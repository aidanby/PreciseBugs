{"buggy_code": ["C Fix\\spossible\\snull\\spointer\\sdereferences\\sin\\sthe\\sfts5_expr()\\sscalar\\sfunction.\nD 2019-12-09T02:20:37.957\nF .fossil-settings/empty-dirs dbb81e8fc0401ac46a1491ab34a7f2c7c0452f2f06b54ebb845d024ca8283ef1\nF .fossil-settings/ignore-glob 35175cdfcf539b2318cb04a9901442804be81cd677d8b889fcc9149c21f239ea\nF LICENSE.md df5091916dbb40e6e9686186587125e1b2ff51f022cc334e886c19a0e9982724\nF Makefile.in d3a862c9742f5a08230a3b295c0a47fd3067f19356dc39935280135f90474b04\nF Makefile.linux-gcc f609543700659711fbd230eced1f01353117621dccae7b9fb70daa64236c5241\nF Makefile.msc 0b0acbf34bb238170bdf1fd343a1fd37bc81c042ce029c1cc53fe15b5d4ed07b\nF README.md 1514a365ffca3c138e00c5cc839906108a01011a6b082bad19b09781e3aa498a\nF VERSION 081500f0aeaadc989d85aafbc717af45512018aebc73d89e5c2368fe62a600ff\nF aclocal.m4 a5c22d164aff7ed549d53a90fa56d56955281f50\nF art/sqlite370.eps aa97a671332b432a54e1d74ff5e8775be34200c2\nF art/sqlite370.ico af56c1d00fee7cd4753e8631ed60703ed0fc6e90\nF art/sqlite370.jpg d512473dae7e378a67e28ff96a34da7cb331def2\nF autoconf/INSTALL 83e4a25da9fd053c7b3665eaaaf7919707915903\nF autoconf/Makefile.am e14b629addaa1ce372b72043f28f40de2e32b7e211b6e0fc18dbb87989197e40\nF autoconf/Makefile.fallback 22fe523eb36dfce31e0f6349f782eb084e86a5620b2b0b4f84a2d6133f53f5ac\nF autoconf/Makefile.msc 492ea431c411378094593a5225b9a02645455a5d87a26d018b5461b723e52125\nF autoconf/README.first 6c4f34fe115ff55d4e8dbfa3cecf04a0188292f7\nF autoconf/README.txt 4f04b0819303aabaa35fff5f7b257fb0c1ef95f1\nF autoconf/configure.ac 308de24343e76ecfbe9a67f8fcd4c5216b790d230c5d9ce10210b7d5965d6192\nF autoconf/tea/Makefile.in b438a7020446c8a8156e8d97c8914a04833da6fd\nF autoconf/tea/README 3e9a3c060f29a44344ab50aec506f4db903fb873\nF autoconf/tea/aclocal.m4 52c47aac44ce0ddb1f918b6993e8beb8eee88f43\nF autoconf/tea/configure.ac 8aa16e3f0a5ca7959d4af198f46934ec187d395f\nF autoconf/tea/doc/sqlite3.n e1fe45d4f5286ee3d0ccc877aca2a0def488e9bb\nF autoconf/tea/license.terms 13bd403c9610fd2b76ece0ab50c4c5eda933d523\nF autoconf/tea/pkgIndex.tcl.in 3ef61715cf1c7bdcff56947ffadb26bc991ca39d\nF autoconf/tea/tclconfig/install-sh bdd5e293591621ae60d9824d86a4b1c5f22c3d00\nF autoconf/tea/tclconfig/tcl.m4 66ddf0a5d5e4b1d29bff472c0985fd7fa89d0fb5\nF autoconf/tea/win/makefile.vc f89d0184d0eee5f7e356ea407964dcd139939928\nF autoconf/tea/win/nmakehlp.c 247538ad8e8c508f33c03ec1fbd67d3a07ef6291\nF autoconf/tea/win/rules.vc c511f222b80064096b705dbeb97060ee1d6b6d63\nF config.guess 883205ddf25b46f10c181818bf42c09da9888884af96f79e1719264345053bd6\nF config.h.in 6376abec766e9a0785178b1823b5a587e9f1ccbc\nF config.sub c2d0260f17f3e4bc0b6808fccf1b291cb5e9126c14fc5890efc77b9fd0175559\nF configure fdc9f8d53360170679349d8f72fb2e5c79f511424891b7bb8a2f48de41c7a6ef x\nF configure.ac 3552d3aecade98a9d4b64bceb48ffb7726cbc85902efde956812942f060fbd0a\nF contrib/sqlitecon.tcl 210a913ad63f9f991070821e599d600bd913e0ad\nF doc/F2FS.txt c1d4a0ae9711cfe0e1d8b019d154f1c29e0d3abfe820787ba1e9ed7691160fcd\nF doc/lemon.html 24956ab2995e55fe171e55bdd04f22b553957dc8bb43501dbb9311e30187e0d3\nF doc/pager-invariants.txt 27fed9a70ddad2088750c4a2b493b63853da2710\nF doc/vfs-shm.txt e101f27ea02a8387ce46a05be2b1a902a021d37a\nF ext/README.md fd5f78013b0a2bc6f0067afb19e6ad040e89a10179b4f6f03eee58fac5f169bd\nF ext/async/README.txt e12275968f6fde133a80e04387d0e839b0c51f91\nF ext/async/sqlite3async.c 0f3070cc3f5ede78f2b9361fb3b629ce200d7d74\nF ext/async/sqlite3async.h f489b080af7e72aec0e1ee6f1d98ab6cf2e4dcef\nF ext/expert/README.md b321c2762bb93c18ea102d5a5f7753a4b8bac646cb392b3b437f633caf2020c3\nF ext/expert/expert.c d548d603a4cc9e61f446cc179c120c6713511c413f82a4a32b1e1e69d3f086a4\nF ext/expert/expert1.test e2afc53a27610e8251e44c7f961806607a5490ff204b3db342740d558e052662\nF ext/expert/sqlite3expert.c 3da865f2286433588260f41e796422c611bceaca3a0bbf9139a619cf7d062c19\nF ext/expert/sqlite3expert.h ca81efc2679a92373a13a3e76a6138d0310e32be53d6c3bfaedabd158ea8969b\nF ext/expert/test_expert.c d56c194b769bdc90cf829a14c9ecbc1edca9c850b837a4d0b13be14095c32a72\nF ext/fts1/README.txt 20ac73b006a70bcfd80069bdaf59214b6cf1db5e\nF ext/fts1/ft_hash.c 3927bd880e65329bdc6f506555b228b28924921b\nF ext/fts1/ft_hash.h 06df7bba40dadd19597aa400a875dbc2fed705ea\nF ext/fts1/fts1.c a39f7d21c2994d27c959ef9c3505c81542c81432\nF ext/fts1/fts1.h 6060b8f62c1d925ea8356cb1a6598073eb9159a6\nF ext/fts1/fts1_hash.c 3196cee866edbebb1c0521e21672e6d599965114\nF ext/fts1/fts1_hash.h e7f0d761353996a8175eda351104acfde23afcb0\nF ext/fts1/fts1_porter.c b1c7304b8988ba3f764a147cdd32043b4913ea7b\nF ext/fts1/fts1_tokenizer.h fdea722c38a9f82ed921642981234f666e47919c\nF ext/fts1/fts1_tokenizer1.c fd00d1fe4dc30dfc5c64cba695ce34f4af20d2fa\nF ext/fts1/fulltext.c 37698e1909584f6d8ea67d1485e3ad39dbf42d19\nF ext/fts1/fulltext.h 08525a47852d1d62a0be81d3fc3fe2d23b094efd\nF ext/fts1/simple_tokenizer.c bbfa4e3b2a26ef17d4edc6d98cd4a3f5396d998a\nF ext/fts1/tokenizer.h 0c53421b832366d20d720d21ea3e1f6e66a36ef9\nF ext/fts2/README.tokenizers 21e3684ea5a095b55d70f6878b4ce6af5932dfb7\nF ext/fts2/README.txt 8c18f41574404623b76917b9da66fcb0ab38328d\nF ext/fts2/fts2.c 72c816a9ae448049fbbe8f18a85698765fc7956c\nF ext/fts2/fts2.h da5f76c65163301d1068a971fd32f4119e3c95fa\nF ext/fts2/fts2_hash.c 011a1d32de45bb1b519a1fd0048e857d6a843558\nF ext/fts2/fts2_hash.h 1824b99dfd8d0225facbdb26a2c87289b2e7dcf8\nF ext/fts2/fts2_icu.c 51c5cd3c04954badd329fa738c95fcdb717b5188\nF ext/fts2/fts2_porter.c 2cd4a507bf3c3085fe66f59b0f2a325f65aaacf5\nF ext/fts2/fts2_tokenizer.c b529493d55e55497213c37e1f31680a77746be26\nF ext/fts2/fts2_tokenizer.h 27a1a99ca2d615cf7e142839b8d79e8751b4529e\nF ext/fts2/fts2_tokenizer1.c 07e223eecb483d448313b5f1553a4f299a7fb7a1\nF ext/fts2/mkfts2amal.tcl 974d5d438cb3f7c4a652639262f82418c1e4cff0\nF ext/fts3/README.content fdc666a70d5257a64fee209f97cf89e0e6e32b51\nF ext/fts3/README.syntax a19711dc5458c20734b8e485e75fb1981ec2427a\nF ext/fts3/README.tokenizers b92bdeb8b46503f0dd301d364efc5ef59ef9fa8e2758b8e742f39fa93a2e422d\nF ext/fts3/README.txt 8c18f41574404623b76917b9da66fcb0ab38328d\nF ext/fts3/fts3.c 9a69143c94195d9342dd4a704021009fb9e45dff9bff775dae024d47e363bab8\nF ext/fts3/fts3.h 3a10a0af180d502cecc50df77b1b22df142817fe\nF ext/fts3/fts3Int.h ba4e5445a0daf4a251345d4704259268fd98a3e0282fedfcaedb9fc6da9f250c\nF ext/fts3/fts3_aux.c 96708c8b3a7d9b8ca1b68ea2b7e503e283f20e95f145becadedfad096dbd0f34\nF ext/fts3/fts3_expr.c b132af223e90e35b9f9efa9fe63d6ae737d34153a3b6066736086df8abc78a1f\nF ext/fts3/fts3_hash.c 8b6e31bfb0844c27dc6092c2620bdb1fca17ed613072db057d96952c6bdb48b7\nF ext/fts3/fts3_hash.h 39cf6874dc239d6b4e30479b1975fe5b22a3caaf\nF ext/fts3/fts3_icu.c 305ce7fb6036484085b5556a9c8e62acdc7763f0f4cdf5fd538212a9f3720116\nF ext/fts3/fts3_porter.c 3565faf04b626cddf85f03825e86056a4562c009\nF ext/fts3/fts3_snippet.c d62e40baa6a200586c3a425478109418f44926b1c318c870b59a4286afbe2795\nF ext/fts3/fts3_term.c f45a1e7c6ef464abb1231245d123dae12266b69e05cc56e14045b76591ae92d1\nF ext/fts3/fts3_test.c 73b16e229e517c1b1f0fb8e1046182a4e5dbc8dbe6eea8a5d4353fcce7dbbf39\nF ext/fts3/fts3_tokenize_vtab.c 1de9a61acfa2a0445ed989310c31839c57f6b6086dd9d5c97177ae734a17fd8b\nF ext/fts3/fts3_tokenizer.c a1ca0ab7c9c688ccb1d605645809f74f5df2bf4ca568e4bb37fb51113fd78e45\nF ext/fts3/fts3_tokenizer.h 64c6ef6c5272c51ebe60fc607a896e84288fcbc3\nF ext/fts3/fts3_tokenizer1.c 5c98225a53705e5ee34824087478cf477bdb7004\nF ext/fts3/fts3_unicode.c 4b9af6151c29b35ed09574937083cece7c31e911f69615e168a39677569b684d\nF ext/fts3/fts3_unicode2.c 416eb7e1e81142703520d284b768ca2751d40e31fa912cae24ba74860532bf0f\nF ext/fts3/fts3_write.c fa971df91b7c9c317ccb76e73de425de372f854cbed16be2d98f42f61be6c0fb\nF ext/fts3/fts3speed.tcl b54caf6a18d38174f1a6e84219950d85e98bb1e9\nF ext/fts3/mkfts3amal.tcl 252ecb7fe6467854f2aa237bf2c390b74e71f100\nF ext/fts3/tool/fts3cov.sh c331d006359456cf6f8f953e37f2b9c7d568f3863f00bb5f7eb87fea4ac01b73\nF ext/fts3/tool/fts3view.c 202801a2056995b763864d60c2dee744d46f1677\nF ext/fts3/unicode/CaseFolding.txt 8c678ca52ecc95e16bc7afc2dbf6fc9ffa05db8c\nF ext/fts3/unicode/UnicodeData.txt cd07314edb62d49fde34debdaf92fa2aa69011e7\nF ext/fts3/unicode/mkunicode.tcl bf7fcaa6d68e6d38223467983785d054f1cff4d9e3905dd51f6ed8801bb590d5\nF ext/fts3/unicode/parseunicode.tcl a981bd6466d12dd17967515801c3ff23f74a281be1a03cf1e6f52a6959fc77eb\nF ext/fts5/extract_api_docs.tcl a36e54ec777172ddd3f9a88daf593b00848368e0\nF ext/fts5/fts5.h c132a9323f22a972c4c93a8d5a3d901113a6e612faf30ca8e695788438c5ca2a\nF ext/fts5/fts5Int.h d7cbc214ee167496f70905667e18f73ea0402f7ef09236ce305e117e0efc866a\nF ext/fts5/fts5_aux.c dcc627d8b6e3fc773db528ff67b39955dab7b51628f9dba8e15849e5bedfd7fa\nF ext/fts5/fts5_buffer.c 5a5fe0159752c0fb0a5a93c722e9db2662822709490769d482b76a6dc8aaca70\nF ext/fts5/fts5_config.c aab6117f8f85933e051c66f227414fdcaf7f2313688e16276b895f9d42d28e5c\nF ext/fts5/fts5_expr.c 2be456484786333d559dc2987a00f2750981fab91d52db8452a8046278c5f22e\nF ext/fts5/fts5_hash.c 1cc0095646f5f3b46721aa112fb4f9bf29ae175cb5338f89dcec66ed97acfe75\nF ext/fts5/fts5_index.c 99b77ae1f503978ca76985bcfff7345c822aed8bbaa8edb3747f804f614685b5\nF ext/fts5/fts5_main.c 9db1f173d299466aeff89bd949fb1eb0a181265726fb56f11e07ea292dcc9a73\nF ext/fts5/fts5_storage.c 167e3d8f8052a71032d498e32a2f2ed5ffe489e5d4d47e298adfa02ed55c7882\nF ext/fts5/fts5_tcl.c 39bcbae507f594aad778172fa914cad0f585bf92fd3b078c686e249282db0d95\nF ext/fts5/fts5_test_mi.c 08c11ec968148d4cb4119d96d819f8c1f329812c568bac3684f5464be177d3ee\nF ext/fts5/fts5_test_tok.c f96c6e193c466711d6d7828d5f190407fe7ab897062d371426dd3036f01258e7\nF ext/fts5/fts5_tokenize.c 2e508c6a3bd8ee56c48e98a38052e1a650e49b32a484cce9b189984114bc3b88\nF ext/fts5/fts5_unicode2.c 8bd0cd07396b74c1a05590e4070d635bccfc849812c305619f109e6c0485e250\nF ext/fts5/fts5_varint.c e64d2113f6e1bfee0032972cffc1207b77af63319746951bf1d09885d1dadf80\nF ext/fts5/fts5_vocab.c c3f12188570abb423303cd193b16dd19ba54e21c2e930e9b748d743de3b385f5\nF ext/fts5/fts5parse.y eb526940f892ade5693f22ffd6c4f2702543a9059942772526eac1fde256bb05\nF ext/fts5/mkportersteps.tcl 5acf962d2e0074f701620bb5308155fa1e4a63ba\nF ext/fts5/test/fts5_common.tcl b01c584144b5064f30e6c648145a2dd6bc440841\nF ext/fts5/test/fts5aa.test 5bd43427b7d08ce2e19c488a26534be450538b9232d4d5305049e8de236e9aa9\nF ext/fts5/test/fts5ab.test 9205c839332c908aaad2b01ab8670ece8b161e8f2ec8a9fabf18ca9385880bb7\nF ext/fts5/test/fts5ac.test a7aa7e1fefc6e1918aa4d3111d5c44a09177168e962c5fd2cca9620de8a7ed6d\nF ext/fts5/test/fts5ad.test e8cf959dfcd57c8e46d6f5f25665686f3b6627130a9a981371dafdf6482790de\nF ext/fts5/test/fts5ae.test 1142d16d9cc193894dc13cc8f9c7a8a21411ac61b5567a878514df6f9f0d7bb7\nF ext/fts5/test/fts5af.test 724247405b13f8f06cc6ce464dc4f152dc5dd4e86b12c2099685d8f19747bf7b\nF ext/fts5/test/fts5ag.test 7816f25a0707578f08145ab539fc0ca025f8951e788b28a6a18a06b2099469dd\nF ext/fts5/test/fts5ah.test 27b5a33bfd0363ca8a4dc659e6e2a5df3dea1c3c5b04bc51ca6aeb1277bd9b21\nF ext/fts5/test/fts5ai.test bc97e4758cc93e06bf851d61c98fdf4e8b8f8315ee28a84fb15f916360856414\nF ext/fts5/test/fts5aj.test 745020852d85f5dd49d11cb7ad11d3cc6dafc4fe6d6d24bc0875ac8f43ee4149\nF ext/fts5/test/fts5ak.test fc3595f8e6873bb86d70c9bd4b67d0413ce577bd4793c39a2b60a7b8825b60a6\nF ext/fts5/test/fts5al.test 00c4c1c6a1366b73aa48ce2068c634520867c3cf7f5d1676ebbb775ee1f35734\nF ext/fts5/test/fts5alter.test 5565f7e4605512b69171ac18ca84398603f9f6456dbe377beeca97e83cc242cd\nF ext/fts5/test/fts5auto.test 78989e6527ce69c9eddbef7392fea5c10b0010cd2b2ae68eec7bc869c471e691\nF ext/fts5/test/fts5aux.test ebf6f2ff7cb556e83f66991b7f12bff016d3c83d4eab36704b649dd6b1437318\nF ext/fts5/test/fts5auxdata.test eacc97ff04892f1a5f3d4df5a73f8bcbc3955ea1d12c9f24137eb1fc079e7611\nF ext/fts5/test/fts5bigpl.test 6466c89b38439f0aba26ac09e232a6b963f29b1cbe1304f6a664fe1e7a8f5fd3\nF ext/fts5/test/fts5bigtok.test 541119e616c637caea925a8c028c37c2c29e94383e00aa2f9198d530724b6e36\nF ext/fts5/test/fts5cat.test daba0b80659460b0cb60bd1f40b402478a761fe7ea414c3c94c2be25568cc33a\nF ext/fts5/test/fts5circref.test f880dfd0d99f6fb73b88ccacb0927d18e833672fd906cc47d6b4e529419eaa62\nF ext/fts5/test/fts5colset.test a30473451321bbf0b6218af62e96b4ae5fa99931cfdb210b5ecc804623b30f75\nF ext/fts5/test/fts5columnsize.test 45459ce4dd9fd853b6044cdc9674921bff89e3d840f348ca8c1630f9edbf5482\nF ext/fts5/test/fts5config.test 60094712debc59286c59aef0e6cf511c37d866802776a825ce437d26afe0817f\nF ext/fts5/test/fts5conflict.test 655925678e630d3cdf145d18725a558971806416f453ac8410ca8c04d934238d\nF ext/fts5/test/fts5connect.test 08030168fc96fc278fa81f28654fb7e90566f33aff269c073e19b3ae9126b2f4\nF ext/fts5/test/fts5content.test 213506436fb2c87567b8e31f6d43ab30aab99354cec74ed679f22aad0cdbf283\nF ext/fts5/test/fts5corrupt.test 77ae6f41a7eba10620efb921cf7dbe218b0ef232b04519deb43581cb17a57ebe\nF ext/fts5/test/fts5corrupt2.test 7453752ba12ce91690c469a6449d412561cc604b1dec994e16ab132952e7805f\nF ext/fts5/test/fts5corrupt3.test 5aaa2f8b44a85246a2ea76db1695bde38a75802979f3961702afa8f322d331c8\nF ext/fts5/test/fts5corrupt4.test ea805c4d7c68b5f185b9db5d2060a7ae5875339738dd48203c92162f41e7ca91\nF ext/fts5/test/fts5delete.test cbf87e3b8867c4d5cfcaed975c7475fd3f99d072bce2075fcedf43d1f82af775\nF ext/fts5/test/fts5detail.test 31b240dbf6d44ac3507e2f8b65f29fdc12465ffd531212378c7ce1066766f54e\nF ext/fts5/test/fts5determin.test 1b77879b2ae818b5b71c859e534ee334dac088b7cf3ff3bf76a2c82b1c788d11\nF ext/fts5/test/fts5dlidx.test b90852c55881b29dbac6380b274de27beae623ac4b6d567c6c8fb9cdc315a86e\nF ext/fts5/test/fts5doclist.test e39a6001495f1dc68e20323586ac965787986c2bf6f515b9b0285627b089d9e6\nF ext/fts5/test/fts5ea.test b01e3a18cdfabbff8104a96a5242a06a68a998a0\nF ext/fts5/test/fts5eb.test af1cd2d2cdff343bd40fd8ad9278e9161bfca81ad629e5aaa8c60a868b16044f\nF ext/fts5/test/fts5fault1.test d28a65caee75db6897c3cf1358c5230d3bb2a3bf7fb31062c19c7e5382b3d2bd\nF ext/fts5/test/fts5fault2.test 69c8fdbef830cd0d450908d4504d5bb86609e255af99c421c20a0756251fe344\nF ext/fts5/test/fts5fault3.test da2f9e3e56ff5740d68ebdd6877c97089e7ed28ddff28a0da87a6afea27e5522\nF ext/fts5/test/fts5fault4.test 1c1db5fcfe59401e7833146100f1d8de284a0a686fac31ddac9fb56c459f725b\nF ext/fts5/test/fts5fault5.test a336e4e11847de24c9497f80cce18e00bb3fab7fb11f97d04eb9af898900a762\nF ext/fts5/test/fts5fault6.test a0fc0a8f99e4b16500c31dfc7e38e1defe0f1693ac47650517ac7b723b1956f8\nF ext/fts5/test/fts5fault7.test 0acbec416edb24b8881f154e99c31e9ccf73f539cfcd164090be139e9e97ed4c\nF ext/fts5/test/fts5fault8.test 318238659d35f82ad215ecb57ca4c87486ea85d45dbeedaee42f148ff5105ee2\nF ext/fts5/test/fts5fault9.test 098e6b894bbdf9b2192f994a30f4043673fb3f338b6b8ab1624c704422f39119\nF ext/fts5/test/fts5faultA.test be4487576bff8c22cee6597d1893b312f306504a8c6ccd3c53ca85af12290c8c\nF ext/fts5/test/fts5faultB.test d606bdb8e81aaeb6f41de3fc9fc7ae315733f0903fbff05cf54f5b045b729ab5\nF ext/fts5/test/fts5faultD.test cc5d1225556e356615e719c612e845d41bff7d5a\nF ext/fts5/test/fts5first.test 3fcf2365c00a15fc9704233674789a3b95131d12de18a9b996159f6909dc8079\nF ext/fts5/test/fts5full.test e1701a112354e0ff9a1fdffb0c940c576530c33732ee20ac5e8361777070d717\nF ext/fts5/test/fts5fuzz1.test 238d8c45f3b81342aa384de3e581ff2fa330bf922a7b69e484bbc06051a1080e\nF ext/fts5/test/fts5hash.test a4cf51acad99bfc43c16fb74f9d22495dc221ae0701fc5e908ca963a9b26a02b\nF ext/fts5/test/fts5integrity.test 4317561cd25eca7df16aa1f7d1a700ee958059fa639785f94aba0a84df9ab17b\nF ext/fts5/test/fts5interrupt.test 09613247b273a99889808ef852898177e671406fe71fdde7ea00e78ea283d227\nF ext/fts5/test/fts5lastrowid.test be98fe3e03235296585b72daad7aed5717ba0062bae5e5c18dd6e04e194c6b28\nF ext/fts5/test/fts5leftjoin.test c0b4cafb9661379e576dc4405c0891d8fcc2782680740513c4d1fc114b43d4ad\nF ext/fts5/test/fts5matchinfo.test 50d86da66ec5b27603dcd90ba0227f5d9deb10351cbc52974a88e24f6fc9b076\nF ext/fts5/test/fts5merge.test e92a8db28b45931e7a9c7b1bbd36101692759d00274df74d83fd29d25d53b3a6\nF ext/fts5/test/fts5merge2.test 3ebad1a59d6ad3fb66eff6523a09e95dc6367cbefb3cd73196801dea0425c8e2\nF ext/fts5/test/fts5misc.test a5b53328b5b79275915de8f67ae85905eb2133d8dbcc808411f67c094b1bd347\nF ext/fts5/test/fts5multi.test a15bc91cdb717492e6e1b66fec1c356cb57386b980c7ba5af1915f97fe878581\nF ext/fts5/test/fts5multiclient.test 5ff811c028d6108045ffef737f1e9f05028af2458e456c0937c1d1b8dea56d45\nF ext/fts5/test/fts5near.test 211477940142d733ac04fad97cb24095513ab2507073a99c2765c3ddd2ef58bd\nF ext/fts5/test/fts5onepass.test f9b7d9b2c334900c6542a869760290e2ab5382af8fbd618834bf1fcc3e7b84da\nF ext/fts5/test/fts5optimize.test 36a752d24c818792032e4ff502936fc9cc5ef938721696396fdc79214b2717f1\nF ext/fts5/test/fts5phrase.test 13e5d8e9083077b3d9c74315b3c92ec723cc6eb37c8155e0bfe1bba00559f07b\nF ext/fts5/test/fts5plan.test 771b999d161e24fd803ce0290adb7c6e7c9b9cc2c6a0adb344813fb89473aa32\nF ext/fts5/test/fts5porter.test 8d08010c28527db66bc3feebd2b8767504aaeb9b101a986342fa7833d49d0d15\nF ext/fts5/test/fts5porter2.test 0d251a673f02fa13ca7f011654873b3add20745f7402f108600a23e52d8c7457\nF ext/fts5/test/fts5prefix.test a0fa67b06650f2deaa7bf27745899d94e0fb547ad9ecbd08bfad98c04912c056\nF ext/fts5/test/fts5query.test ac363b17a442620bb0780e93c24f16a5f963dfe2f23dc85647b869efcfada728\nF ext/fts5/test/fts5rank.test c9fd4a1e36b4fa92d572ec13d846469b97da249d1c2f7fd3ee7e017ce46f2416\nF ext/fts5/test/fts5rebuild.test 55d6f17715cddbf825680dd6551efbc72ed916d8cf1cde40a46fc5d785b451e7\nF ext/fts5/test/fts5restart.test 835ecc8f449e3919f72509ab58056d0cedca40d1fe04108ccf8ac4c2ba41f415\nF ext/fts5/test/fts5rowid.test b8790ec170a8dc1942a15aef3db926a5f3061b1ff171013003d8297203a20ad6\nF ext/fts5/test/fts5simple.test a298670508c1458b88ce6030440f26a30673931884eb5f4094ac1773b3ba217b\nF ext/fts5/test/fts5simple2.test 258a1b0c590409bfa5271e872c79572b319d2a56554d0585f68f146a0da603f0\nF ext/fts5/test/fts5simple3.test d5c74a9d3ca71bd5dd5cacb7c55b86ea12cdddfc8b1910e3de2995206898380f\nF ext/fts5/test/fts5synonym.test 1651815b8008de170e8e600dcacc17521d765482ea8f074ae82cfa870d8bb7fb\nF ext/fts5/test/fts5synonym2.test b54cce5c34ec08ed616f646635538ae82e34a0e28f947ec60b6fadbc4b3fb17a\nF ext/fts5/test/fts5tok1.test ce6551e41ff56f30b69963577324624733bed0d1753589f06120d664d9cd45c9\nF ext/fts5/test/fts5tok2.test dcacb32d4a2a3f0dd3215d4a3987f78ae4be21a2\nF ext/fts5/test/fts5tokenizer.test ac3c9112b263a639fb0508ae73a3ee886bf4866d2153771a8e8a20c721305a43\nF ext/fts5/test/fts5umlaut.test a42fe2fe6387c40c49ab27ccbd070e1ae38e07f38d05926482cc0bccac9ad602\nF ext/fts5/test/fts5unicode.test 17056f4efe6b0a5d4f41fdf7a7dc9af2873004562eaa899d40633b93dc95f5a9\nF ext/fts5/test/fts5unicode2.test 9b3df486de05fb4bde4aa7ee8de2e6dae1df6eb90e3f2e242c9383b95d314e3e\nF ext/fts5/test/fts5unicode3.test 590c72e18195bda2446133f9d82d04a4e89d094bba58c75ae10f4afc6faa0744\nF ext/fts5/test/fts5unicode4.test 6463301d669f963c83988017aa354108be0b947d325aef58d3abddf27147b687\nF ext/fts5/test/fts5unindexed.test 9021af86a0fb9fc616f7a69a996db0116e7936d0db63892db6bafabbec21af4d\nF ext/fts5/test/fts5update.test b8affd796e45c94a4d19ad5c26606ea06065a0f162a9562d9f005b5a80ccf0bc\nF ext/fts5/test/fts5version.test c8f2cc105f0abf0224965f93e584633dee3e06c91478bc67e468f7cfdf97fd6a\nF ext/fts5/test/fts5vocab.test 648fb2fe86b55e08295e34504704718d92fba3e2cf3e1f5d72fa3682df4cd0f0\nF ext/fts5/test/fts5vocab2.test e0fdc3a3095f6eda68ac9bf9a443ff929a124d46f00af19933604085712e9d47\nF ext/fts5/tool/fts5speed.tcl b0056f91a55b2d1a3684ec05729de92b042e2f85\nF ext/fts5/tool/fts5txt2db.tcl 526a9979c963f1c54fd50976a05a502e533a4c59\nF ext/fts5/tool/loadfts5.tcl 95b03429ee6b138645703c6ca192c3ac96eaf093\nF ext/fts5/tool/mkfts5c.tcl d1c2a9ab8e0ec690a52316f33dd9b1d379942f45\nF ext/fts5/tool/showfts5.tcl d54da0e067306663e2d5d523965ca487698e722c\nF ext/icu/README.txt a295e91db742b153e8dce8f7efd31d28ad1eea4df31ef4daa3eedc85be2f5138\nF ext/icu/icu.c c2c7592574c08cd1270d909b8fb8797f6ea1f49e931e71dbcc25506b9b224580\nF ext/icu/sqliteicu.h 728867a802baa5a96de7495e9689a8e01715ef37\nF ext/lsm1/Makefile a553b728bba6c11201b795188c5708915cc4290f02b7df6ba7e8c4c943fd5cd9\nF ext/lsm1/Makefile.msc f8c878b467232226de288da320e1ac71c131f5ec91e08b21f502303347260013\nF ext/lsm1/lsm-test/README 87ea529d2abe615e856d4714bfe8bb185e6c2771b8612aa6298588b7b43e6f86\nF ext/lsm1/lsm-test/lsmtest.h cf58528ffe0cfe535e91b44584e2ec5fb1caacdabecef0d8dcf83bf83168bf28\nF ext/lsm1/lsm-test/lsmtest1.c ae6ba48a0851b39be69a7d0eb220bfb9521a526e926223d5014bd385df10abb3\nF ext/lsm1/lsm-test/lsmtest2.c 188b09aec776516aeedcfd13b9c6faf85ba16b3671a0897a2c740ee00a5dc4f8\nF ext/lsm1/lsm-test/lsmtest3.c 9ab87528a36dbf4a61d7c8ad954f5ee368c0878c127b84b942b2e2abe522de26\nF ext/lsm1/lsm-test/lsmtest4.c d258d6a245db5d8eaede096e2368d23f859c5e92c80ab9122463f708514fe10c\nF ext/lsm1/lsm-test/lsmtest5.c 8d5242a0f870d65eeada191c8945781fed9cb8ece3886573790ebd373b62dac5\nF ext/lsm1/lsm-test/lsmtest6.c 869cb4a172cd07d1a75b3aeaecd61d0a477787b3b8668bad0d3ff0f43b642b7c\nF ext/lsm1/lsm-test/lsmtest7.c 7a917455a0f956a8ed3f44f5c9387ec0ea6627714874464cc3fa5c5a9cabb2f2\nF ext/lsm1/lsm-test/lsmtest8.c 589b68c44531a0f04d5e879bb1e211be5f7100f48eed7e8631e07ed5cbd68f94\nF ext/lsm1/lsm-test/lsmtest9.c dd1a0ebf41134933a744d1e00e60429a2a21fc50d587ae7dd6bdb6e96d805bdc\nF ext/lsm1/lsm-test/lsmtest_bt.c d70d9a9be5eef9360af1251dd083948d74fd30137a08f61bef995f7ac04e037f\nF ext/lsm1/lsm-test/lsmtest_datasource.c 5d770be191d0ca51315926723009b2c25c0b4b8136840494ef710ac324aa916c\nF ext/lsm1/lsm-test/lsmtest_func.c 159aa401bc8032bfa3d8cf2977bd687abebab880255895a5eb45770d626fa38d\nF ext/lsm1/lsm-test/lsmtest_io.c cf11b27b129c6bd5818fa1d440176502dc27229f0db892b4479118d61993ea20\nF ext/lsm1/lsm-test/lsmtest_main.c a9bc647738c0dcaebf205d6d194b3ce4a6ef3925801cd2d919f0a4ea33a15aeb\nF ext/lsm1/lsm-test/lsmtest_mem.c 4e63c764345ab1df59d4f13a77980c6f3643798210b10d6cdbd785b4b888fda5\nF ext/lsm1/lsm-test/lsmtest_tdb.c 618a8619183fda4f5540fcde15f9068293c5e3180e1a246e34409b0c148758b3\nF ext/lsm1/lsm-test/lsmtest_tdb.h 8733eee249b12956a9df8322994b43d19bd8c02ad2e8b0bb5164db4d6ccc1735\nF ext/lsm1/lsm-test/lsmtest_tdb2.cc 99ea7f2dd9c7536c8fb9bdd329e4cfeb76899f3ddf6f48bdd3926e016922b715\nF ext/lsm1/lsm-test/lsmtest_tdb3.c 7a7ccae189f5bb25bcd1ec3bbd740529706eded7f6729a5a0a9eeaeb57785320\nF ext/lsm1/lsm-test/lsmtest_tdb4.c 47e8bb5eba266472d690fb8264f1855ebdba0ae5a0e541e35fcda61ebf1d277f\nF ext/lsm1/lsm-test/lsmtest_util.c 241622db5a332a09c8e6e7606b617d288a37b557f7d3bce0bb97809f67cc2806\nF ext/lsm1/lsm-test/lsmtest_win32.c 0e0a224674c4d3170631c41b026b56c7e1672b151f5261e1b4cc19068641da2d\nF ext/lsm1/lsm.h 0f6f64ff071471cb87bf98beb8386566f30ea001\nF ext/lsm1/lsmInt.h 5983690e05e83653cc01ba9d8fbf8455e534ddf8349ed9adedbf46a7549760b0\nF ext/lsm1/lsm_ckpt.c 0eabfaf812ddb4ea43add38f05e430694cd054eb622c3e35af4c43118a2d5321\nF ext/lsm1/lsm_file.c 3c51841d5b3e7da162693cbac9a9f47eeedf6bcbbe2969a4d25e30c428c9fe36\nF ext/lsm1/lsm_log.c a8bf334532109bba05b09a504ee45fc393828b0d034ca61ab45e3940709d9a7c\nF ext/lsm1/lsm_main.c b5703f8042e71d3a2d65e671f6832e077e79e89e9975818f67f969922618db63\nF ext/lsm1/lsm_mem.c 4c51ea9fa285ee6e35301b33491642d071740a0a\nF ext/lsm1/lsm_mutex.c 378edf0a2b142b4f7640ee982df06d50b98788ea\nF ext/lsm1/lsm_shared.c 76adfc1ed9ffebaf92746dde4b370ccc48143ca8b05b563816eadd2aadf1c525\nF ext/lsm1/lsm_sorted.c 6f7d8cf7a7d3d3f1ab5d9ba6347e8f39f3d73c00ec48afcd0c4bcbefd806f9b8\nF ext/lsm1/lsm_str.c 65e361b488c87b10bf3e5c0070b14ffc602cf84f094880bece77bbf6678bca82\nF ext/lsm1/lsm_tree.c 682679d7ef2b8b6f2fe77aeb532c8d29695bca671c220b0abac77069de5fb9fb\nF ext/lsm1/lsm_unix.c 57361bcf5b1a1a028f5d66571ee490e9064d2cfb145a2cc9e5ddade467bb551b\nF ext/lsm1/lsm_varint.c 43f954af668a66c7928b81597c14d6ad4be9fedbc276bbd80f52fa28a02fdb62\nF ext/lsm1/lsm_vtab.c 169bfe7ef8e6c9de9c77e17c4c50c9ae55fb0167d80be3d1be82c991184b6f35\nF ext/lsm1/lsm_win32.c 0a4acbd7e8d136dd3a5753f0a9e7a9802263a9d96cef3278cf120bcaa724db7c\nF ext/lsm1/test/lsm1_common.tcl 5ed4bab07c93be2e4f300ebe46007ecf4b3e20bc5fbe1dedaf04a8774a6d8d82\nF ext/lsm1/test/lsm1_simple.test a04d08e8661ae6fc53786c67f0bd102c6692f003e859dde03ed9ac3f12e066e5\nF ext/lsm1/tool/mklsm1c.tcl f31561bbee5349f0a554d1ad7236ac1991fc09176626f529f6078e07335398b0\nF ext/misc/README.md d6dd0fe1d8af77040216798a6a2b0c46c73054d2f0ea544fbbcdccf6f238c240\nF ext/misc/amatch.c 50a9ef2d38dabfa371f8c1904097d493271e63d58ccb0e9b79a4fa4a94e66660\nF ext/misc/anycollseq.c 5ffdfde9829eeac52219136ad6aa7cd9a4edb3b15f4f2532de52f4a22525eddb\nF ext/misc/appendvfs.c 3777f22ec1057dc4e5fd89f2fbddcc7a29fbeef1ad038c736c54411bb1967af7\nF ext/misc/blobio.c a867c4c4617f6ec223a307ebfe0eabb45e0992f74dd47722b96f3e631c0edb2a\nF ext/misc/btreeinfo.c 4f0ebf278f46e68e6306c667917766cebc5550fd35d5de17847988e22892d4d2\nF ext/misc/carray.c 91e9a7f512fda934894bed30464552fffa7d3073b5be04189ae0bd0c59f26bfd\nF ext/misc/closure.c dbfd8543b2a017ae6b1a5843986b22ddf99ff126ec9634a2f4047cd14c85c243\nF ext/misc/completion.c cec672d40604075bb341a7f11ac48393efdcd90a979269b8fe7977ea62d0547f\nF ext/misc/compress.c dd4f8a6d0baccff3c694757db5b430f3bbd821d8686d1fc24df55cf9f035b189\nF ext/misc/csv.c 7f047aeb68f5802e7ce6639292095d622a488bb43526ed04810e0649faa71ceb\nF ext/misc/dbdata.c e316fba936571584e55abd5b974a32a191727a6b746053a0c9d439bd2cf93940\nF ext/misc/dbdump.c baf6e37447c9d6968417b1cd34cbedb0b0ab3f91b5329501d8a8d5be3287c336\nF ext/misc/eval.c 4b4757592d00fd32e44c7a067e6a0e4839c81a4d57abc4131ee7806d1be3104e\nF ext/misc/explain.c d5c12962d79913ef774b297006872af1fccda388f61a11d37758f9179a09551f\nF ext/misc/fileio.c 288e7230e0fe464d71b0694e2d8bdd3a353118ac2e31da3964b95f460f09915f\nF ext/misc/fossildelta.c 7708651072eb5620ab21bbfb518d184f27b2c29c0131b09b9a2d8852a8016430\nF ext/misc/fuzzer.c c4e27daf41433a64cad5265cd27dbcb891147e9994d0422200ce81ce9a54b625\nF ext/misc/ieee754.c f190d0cc5182529acb15babd177781be1ac1718c\nF ext/misc/json1.c 760107d0b97ab422952591b0d7519327dcb482954a7706ee387a54c135f8aabf\nF ext/misc/memstat.c 3017a0832c645c0f8c773435620d663855f04690172316bd127270d1a7523d4d\nF ext/misc/memtrace.c 7c0d115d2ef716ad0ba632c91e05bd119cb16c1aedf3bec9f06196ead2d5537b\nF ext/misc/memvfs.c ab36f49e02ebcdf85a1e08dc4d8599ea8f343e073ac9e0bca18a98b7e1ec9567\nF ext/misc/mmapwarm.c 8c5fe90d807a23e44a8b93e96e8b812b19b300d5fd8c1d40a4fd1d8224e33f46\nF ext/misc/nextchar.c 279f80fe8ef5ba413242e2704e246503ac601f005eefb180d19e6c920338a0ba\nF ext/misc/normalize.c b4290464f542bae7a97b43f15bd197949b833ffd668b7c313631bd5d4610212c\nF ext/misc/percentile.c 148dd07286b16e50f232bb638a47850085ad37d51f270429905bd865e595d1ca\nF ext/misc/prefixes.c 7be86d17525cfae6ed462fc3c519efc44488ac329890f77491c8f82871f57e17\nF ext/misc/regexp.c 653b6ab5e89bcb5d45f9ebe0747d7f8f3f5706cac963fcbc9a3ddbe5fdc1efa2\nF ext/misc/remember.c add730f0f7e7436cd15ea3fd6a90fd83c3f706ab44169f7f048438b7d6baa69c\nF ext/misc/rot13.c 540a169cb0d74f15522a8930b0cccdcb37a4fd071d219a5a083a319fc6e8db77\nF ext/misc/scrub.c db9fff56fed322ca587d73727c6021b11ae79ce3f31b389e1d82891d144f22ad\nF ext/misc/series.c 0c97f63378fddc9f425e82ba139b9aaf902211f24ced115c2b6ae12b425f7334\nF ext/misc/sha1.c d8125a88ee9023bc17d6f87ea8850db33f906d5701b30d4fd9bddb57f231e60a\nF ext/misc/shathree.c 22ba7ca84a433d6466a7d05dcc876910b435a715da8cc462517db9351412b8c8\nF ext/misc/showauth.c 732578f0fe4ce42d577e1c86dc89dd14a006ab52\nF ext/misc/spellfix.c f88ecb2c0294453ce8b7704b211f5350c41b085b38c8e056852e3a08b0f5e484\nF ext/misc/sqlar.c 57d5bc45cd5492208e451f697404be88f8612527d64c9d42f96b325b64983d74\nF ext/misc/stmt.c 8a8dc4675042e4551e4afe99b8d0cc7a4a2fc1a8dacc0a9ce1b1bbff145da93d\nF ext/misc/templatevtab.c 8a16a91a5ceaccfcbd6aaaa56d46828806e460dd194965b3f77bf38f14b942c4\nF ext/misc/totype.c 5b6b1eafaa993e29f8df843319b3292b029f1b5cbbbf11c8a88e05d3f714159f\nF ext/misc/unionvtab.c 36237f0607ca954ac13a4a0e2d2ac40c33bc6e032a5f55f431713061ef1625f9\nF ext/misc/uuid.c db4db81e8c6a92ad6176ebd9f81dcb6870e331e1a286d0452f4319e3ba3df812\nF ext/misc/vfslog.c 3b25c2f56ba60788db247287be6ab024b53c4afffd412b4876db563389be0d35\nF ext/misc/vfsstat.c 77b5b4235c9f7f11eddf82487c0a422944ac2f132dafd5af3be7a68a057b1cdb\nF ext/misc/vtablog.c 5538acd0c8ddaae372331bee11608d76973436b77d6a91e8635cfc9432fba5ae\nF ext/misc/vtshim.c 1976e6dd68dd0d64508c91a6dfab8e75f8aaf6cd\nF ext/misc/wholenumber.c 784b12543d60702ebdd47da936e278aa03076212\nF ext/misc/zipfile.c 7ad29133e304e40c8fe239bea10e101580ed56bc68c16d992af514cce19572d0\nF ext/misc/zorder.c b0ff58fa643afa1d846786d51ea8d5c4b6b35aa0254ab5a82617db92f3adda64\nF ext/rbu/rbu.c 8681f6157db6adc82c34af24b14ea8a3be0146ad2a3b6c1d5da6cb8a5796c8ce\nF ext/rbu/rbu1.test 221d9c18a5e600ac9ac6b1810d99d9f99163a7909ba61597876ab6e4d4beb3d6\nF ext/rbu/rbu10.test 0a201c32202143f23c81c0144503da339786fc20acb7a2fda11601b65659f314\nF ext/rbu/rbu11.test 5c834cf491086b45e071eabf71f708febc143e86a384a92de69e0b1a4cace144\nF ext/rbu/rbu12.test 29f8b2118f6c96fac3755bd6d2b55c2db24f878b1f11fbfbe294f3a230a3dcdc\nF ext/rbu/rbu13.test 1285298e3360ec74511764841b3c174dcfe21da2f618c22febf1a20abd0365c2\nF ext/rbu/rbu14.test 4a7bf0b3a4516d3ab0bc0ba4ceb53eb7e3324147ccda152e561060f659dbba31\nF ext/rbu/rbu3.test d6c6cc7a1326e8e23b9820f30bd3054f22092e503fadfd2a660ae006653f6d80\nF ext/rbu/rbu5.test 724b38ea5f722e3d22dc76343860bd998bb676c3f78c4bc8175df5c5d7720e23\nF ext/rbu/rbu6.test 401064236d3cf86b7edc01c586d7c5554f48553946fbfa1a3af35d7e47dce9e3\nF ext/rbu/rbu7.test ae25f47b56f178197fc1098537a35a39176cc73d1629b03dc9d795929fc36ec2\nF ext/rbu/rbu8.test b98a6fc58ead84a0e6ddee775b9702cd981f318d5d4fd1d4df0fa0c40db7251b\nF ext/rbu/rbu9.test 0e4d985e25620d61920597e8ea69c871c9e8c1f5a0be2ae9fa70bb641d74378c\nF ext/rbu/rbuA.test b34a90cb495682c25b5fc03a9d5e7a4fc99541c29256f25e2e2a4f6542b4f5b3\nF ext/rbu/rbuB.test 52b07158824c6927b7e25554ace92a695cdebfc296ae3d308ac386984aded9bc\nF ext/rbu/rbuC.test 80f1cc2fb74f44b1128fd0ed8eedab3a76fefeb72a947860e2869ef76fc8dc6b\nF ext/rbu/rbu_common.tcl 60d904133ff843fe72cc0514e9dd2486707181e6e0fbab20979da28c48d21de9\nF ext/rbu/rbucollate.test cac528a9a46318cba42e61258bb42660bbbf4fdb9a8c863de5a54ad0c658d197\nF ext/rbu/rbucrash.test 000981a1fe8a6e4d9a684232f6a129e66a3ef595f5ed74655e2f9c68ffa613b4\nF ext/rbu/rbucrash2.test efa143cc94228eb0266d3f1abfbee60a5838a84cef7cc3fcb8c145b74d96fd41\nF ext/rbu/rbudiff.test 156957851136b63c143478518dc1bda6c832103cdbe8ac1d7cdd47edb3cbe0a3\nF ext/rbu/rbudor.test e3e8623926012f43eebe51fedf06a102df2640750d971596b052495f2536db20\nF ext/rbu/rbuexpr.test 10d0420537c3bc7666e576d72adeffe7e86cfbb00dcc30aa9ce096c042415190\nF ext/rbu/rbufault.test 2d7f567b79d558f6e093c58808cab4354f8a174e3802f69e7790a9689b3c09f8\nF ext/rbu/rbufault2.test c81327a3ac2c385b9b954db3644d4e0df93eeebfc3de9f1f29975a1e73fd3d0c\nF ext/rbu/rbufault3.test b2fcc9db5c982b869f67d1d4688d8cb515d5b92f58011fff95665f2e62cec179\nF ext/rbu/rbufault4.test 03d2849c3df7d7bd14a622e789ff049e5080edd34a79cd432e01204db2a5930a\nF ext/rbu/rbufts.test 0ae8d1da191c75bd776b86e24456db0fb6e97b7c944259fae5407ea55d23c31d\nF ext/rbu/rbumisc.test 329986cf5dd51890c4eb906c2f960ebb773a79a64bed90f506b7c417825b37eb\nF ext/rbu/rbumulti.test 5fb139058f37ddc5a113c5b93238de915b769b7792de41b44c983bc7c18cf5b9\nF ext/rbu/rbupartial.test f25df014b8dbe3c5345851fba6e66f79ab237f57dc201b2d5f0dbae658ae5a4c\nF ext/rbu/rbuprogress.test 857cf1f8166c83ef977edb9ef4fc42d80f71fbd798652b46ae2f3a7031870f8d\nF ext/rbu/rburesume.test dbdc4ca504e9c76375a69e5f0d91205db967dcc509a5166ca80231f8fda49eb1\nF ext/rbu/rbusave.test f4190a1a86fccf84f723af5c93813365ae33feda35845ba107b59683d1cdd926\nF ext/rbu/rbusplit.test b37e7b40b38760881dc9c854bd40b4744c6b6cd74990754eca3bda0f407051e8\nF ext/rbu/rbutemplimit.test 05ceefa90a2e26a99f40dd48282ed63a00df5e59c1f2bfd479c143e201a1b0ba\nF ext/rbu/rbuvacuum.test 55e101e90168c2b31df6c9638fe73dc7f7cc666b6142266d1563697d79f73534\nF ext/rbu/rbuvacuum2.test b8e5b51dc8b2c0153373d024c0936be3f66f9234acbd6d0baab0869d56b14e6b\nF ext/rbu/rbuvacuum3.test 8addd82e4b83b4c93fa47428eae4fd0dbf410f8512c186f38e348feb49ba03dc\nF ext/rbu/rbuvacuum4.test a78898e438a44803eb2bc897ba3323373c9f277418e2d6d76e90f2f1dbccfd10\nF ext/rbu/sqlite3rbu.c f3a3e09f575157052813be667d6ab3b54f47fb02e6e1c9f767ad7bb8f1fb90b3\nF ext/rbu/sqlite3rbu.h 1dc88ab7bd32d0f15890ea08d23476c4198d3da3056985403991f8c9cd389812\nF ext/rbu/test_rbu.c 03f6f177096a5f822d68d8e4069ad8907fe572c62ff2d19b141f59742821828a\nF ext/repair/README.md 92f5e8aae749a4dae14f02eea8e1bb42d4db2b6ce5e83dbcdd6b1446997e0c15\nF ext/repair/checkfreelist.c 0dbae18c1b552f58d64f8969e4fb1e7f11930c60a8c2a9a8d50b7f15bdfd54bd\nF ext/repair/checkindex.c 7d28c01a2e012ac64257d230fc452b2cafb78311a91a343633d01d95220f66f3\nF ext/repair/sqlite3_checker.c.in 4a5a3af3f450fe503e5a2985e98516dc2a6b9ad247449e284c1cf140fc91720f\nF ext/repair/sqlite3_checker.tcl a9a2caa9660567257c177a91124d8c0dccdfa341e25c51e6da7f1fd9e601eafa\nF ext/repair/test/README.md 34b2f542cf5be7bffe479242b33ee3492cea30711e447cc4a1a86cb5915f419e\nF ext/repair/test/checkfreelist01.test 3e8aa6aeb4007680c94a8d07b41c339aa635cc78249442da72ff3f8297398a69\nF ext/repair/test/checkindex01.test b530f141413b587c9eb78ff734de6bb79bc3515c335096108c12c01bddbadcec\nF ext/repair/test/test.tcl 686d76d888dffd021f64260abf29a55c57b2cedfa7fc69150b42b1d6119aac3c\nF ext/rtree/README 6315c0d73ebf0ec40dedb5aa0e942bc8b54e3761\nF ext/rtree/geopoly.c c591164125808f8bba9659e92665b78412cd263e654b6f05294f3a8da7cdd9fb\nF ext/rtree/rtree.c 26fcb3f7a92fda9afcf5eee684cc3188b7367da69bc9c374492d844fb8ed4e25\nF ext/rtree/rtree.h 4a690463901cb5e6127cf05eb8e642f127012fd5003830dbc974eca5802d9412\nF ext/rtree/rtree1.test 4092a8bd2b5eafc4fafe4fe9024249c12b13e4bab23c2c3eaff57412fdf805fa\nF ext/rtree/rtree2.test 9d9deddbb16fd0c30c36e6b4fdc3ee3132d765567f0f9432ee71e1303d32603d\nF ext/rtree/rtree3.test 4ee5d7df86040efe3d8d84f141f2962a7745452200a7cba1db06f86d97050499\nF ext/rtree/rtree4.test 304de65d484540111b896827e4261815e5dca4ce28eeecd58be648cd73452c4b\nF ext/rtree/rtree5.test 49c9041d713d54560b315c2c7ef7207ee287eba1b20f8266968a06f2e55d3142\nF ext/rtree/rtree6.test 1252a0439da01d2f1f5cbbdeeb80455a2d68b9bae2a9787937b167a5e3957828\nF ext/rtree/rtree7.test c8fb2e555b128dd0f0bdb520c61380014f497f8a23c40f2e820acc9f9e4fdce5\nF ext/rtree/rtree8.test 2d99006a1386663978c9e1df167554671e4f711c419175b39f332719deb1ce0e\nF ext/rtree/rtree9.test c646f12c8c1c68ef015c6c043d86a0c42488e2e68ed1bb1b0771a7ca246cbabf\nF ext/rtree/rtreeA.test ed2f1be9c06dde0b1ab93a95dd9e87eeaa02db2d30bcb4b9179b69ee3dc3319b\nF ext/rtree/rtreeB.test 4cec297f8e5c588654bbf3c6ed0903f10612be8a2878055dd25faf8c71758bc9\nF ext/rtree/rtreeC.test 6aa87eba4d9a3003b941a1ba77db259c5cabc3fd92fc5a6360f5369520eb9a4d\nF ext/rtree/rtreeD.test fe46aa7f012e137bd58294409b16c0d43976c3bb92c8f710481e577c4a1100dc\nF ext/rtree/rtreeE.test e65d3fc625da1800b412fc8785817327d43ccfec5f5973912d8c9e471928caa9\nF ext/rtree/rtreeF.test 81ffa7ef51c4e4618d497a57328c265bf576990c7070633b623b23cd450ed331\nF ext/rtree/rtreeG.test 1b9ca6e3effb48f4161edaa463ddeaa8fca4b2526d084f9cbf5dbe4e0184939c\nF ext/rtree/rtreeH.test 0885151ee8429242625600ae47142cca935332c70a06737f35af53a7bd7aaf90\nF ext/rtree/rtreeI.test 608e77f7fde9be5a12eae316baef640fffaafcfa90a3d67443e78123e19c4ca4\nF ext/rtree/rtree_perf.tcl 6c18c1f23cd48e0f948930c98dfdd37dfccb5195\nF ext/rtree/rtree_util.tcl db734b4c5e75fed6acc56d9701f2235345acfdec750b5fc7b587936f5f6bceed\nF ext/rtree/rtreecheck.test d67d5b3e9e45bfa8cd90734e8e9302144ac415b8e9176c6f02d4f92892ee8a35\nF ext/rtree/rtreecirc.test aec664eb21ae943aeb344191407afff5d392d3ae9d12b9a112ced0d9c5de298e\nF ext/rtree/rtreeconnect.test 225ad3fcb483d36cbee423a25052a6bbae762c9576ae9268332360c68c170d3d\nF ext/rtree/rtreefuzz001.test eef1ed593bb15886cd5d5367a2f2492f81e315848896cdf7afb6e21454978827\nF ext/rtree/sqlite3rtree.h 03c8db3261e435fbddcfc961471795cbf12b24e03001d0015b2636b0f3881373\nF ext/rtree/tkt3363.test 142ab96eded44a3615ec79fba98c7bde7d0f96de\nF ext/rtree/util/randomshape.tcl 54ee03d0d4a1c621806f7f44d5b78d2db8fac26e0e8687c36c4bd0203b27dbff\nF ext/rtree/viewrtree.tcl eea6224b3553599ae665b239bd827e182b466024\nF ext/rtree/visual01.txt e9c2564083bcd30ec51b07f881bffbf0e12b50a3f6fced0c222c5c1d2f94ac66\nF ext/session/changeset.c 7a1e6a14c7e92d36ca177e92e88b5281acd709f3b726298dc34ec0fb58869cb5\nF ext/session/changesetfuzz.c 227076ab0ae4447d742c01ee88a564da6478bbf26b65108bf8fac9cd8b0b24aa\nF ext/session/changesetfuzz1.test 2e1b90d888fbf0eea5e1bd2f1e527a48cc85f8e0ff75df1ec4e320b21f580b3a\nF ext/session/session1.test 0b2f88995832ea040ae8e83a1ad4afa99c00b85c779d213da73a95ea4113233e\nF ext/session/session2.test 284de45abae4cc1082bc52012ee81521d5ac58e0\nF ext/session/session3.test ce9ce3dfa489473987f899e9f6a0f2db9bde3479\nF ext/session/session4.test 6778997065b44d99c51ff9cece047ff9244a32856b328735ae27ddef68979c40\nF ext/session/session5.test 716bc6fafd625ce60dfa62ae128971628c1a1169\nF ext/session/session6.test 443789bc2fca12e4f7075cf692c60b8a2bea1a26\nF ext/session/session8.test 8e194b3f655d861ca36de5d4de53f702751bab3b\nF ext/session/session9.test 5409d90d8141881d08285ed1c2c0d8d10fb92069\nF ext/session/sessionA.test 1feeab0b8e03527f08f2f1defb442da25480138f\nF ext/session/sessionB.test c4fb7f8a688787111606e123a555f18ee04f65bb9f2a4bb2aa71d55ce4e6d02c\nF ext/session/sessionC.test f8a5508bc059ae646e5ec9bdbca66ad24bc92fe99fda5790ac57e1f59fce2fdf\nF ext/session/sessionD.test 4f91d0ca8afc4c3969c72c9f0b5ea9527e21de29039937d0d973f821e8470724\nF ext/session/sessionE.test b2010949c9d7415306f64e3c2072ddabc4b8250c98478d3c0c4d064bce83111d\nF ext/session/sessionF.test d37ed800881e742c208df443537bf29aa49fd56eac520d0f0c6df3e6320f3401\nF ext/session/sessionG.test 3828b944cd1285f4379340fd36f8b64c464fc84df6ff3ccbc95578fd87140b9c\nF ext/session/sessionH.test a417559f29a7e775950fc5fc82b3d01256a7cbe793ddf1180df234df823d56e2\nF ext/session/session_common.tcl 29ec9910aca1e996ca1c8531b8cecabf96eb576aa53de65a8ff03d848b9a2a8b\nF ext/session/session_speed_test.c dcf0ef58d76b70c8fbd9eab3be77cf9deb8bc1638fed8be518b62d6cbdef88b3\nF ext/session/sessionat.test efe88965e74ff1bc2af9c310b28358c02d420c1fb2705cc7a28f0c1cc142c3ec\nF ext/session/sessiondiff.test ad13dd65664bae26744e1f18eb3cbd5588349b7e9118851d8f9364248d67bcec\nF ext/session/sessionfault.test da273f2712b6411e85e71465a1733b8501dbf6f7\nF ext/session/sessionfault2.test dd593f80b6b4786f7adfe83c5939620bc505559770cc181332da26f29cddd7bb\nF ext/session/sessioninvert.test ae1a003a9ab1f8d64227dbb5c3a4c97e65b561b01e7b2953cf48683fb2724169\nF ext/session/sessionrebase.test ccfa716b23bd1d3b03217ee58cfd90c78d4b99f53e6a9a2f05e82363b9142810\nF ext/session/sessionstat1.test 218d351cf9fcd6648f125a26b607b140310160184723c2666091b54450a68fb5\nF ext/session/sessionwor.test 67b5ab91d4f93ce65ff1f58240ac5ddf73f8670facc1ffa49cef56293d52818d\nF ext/session/sqlite3session.c a4dfb372f270df93422b0dc7666fd46849e6979b62a152f11287c21eed4ac21b\nF ext/session/sqlite3session.h a2db5b72b938d12c727b4b4ec632254ca493670a9c0de597af3271a7f774fc57\nF ext/session/test_session.c 98797aba475a799376c9a42214f2d1debf2d0c3cb657d9c8bbf4f70bf3fb4aec\nF ext/userauth/sqlite3userauth.h 7f3ea8c4686db8e40b0a0e7a8e0b00fac13aa7a3\nF ext/userauth/user-auth.txt e6641021a9210364665fe625d067617d03f27b04\nF ext/userauth/userauth.c f81aa5a3ecacf406f170c62a144405858f6f6de51dbdc0920134e629edbe2648\nF install-sh 9d4de14ab9fb0facae2f48780b874848cbf2f895 x\nF ltmain.sh 3ff0879076df340d2e23ae905484d8c15d5fdea8\nF magic.txt 8273bf49ba3b0c8559cb2774495390c31fd61c60\nF main.mk 7ce055f3df31a4f7d21e38f493f907c21db1f673863a573e231f55e2ab005023\nF mkso.sh fd21c06b063bb16a5d25deea1752c2da6ac3ed83\nF mptest/config01.test 3c6adcbc50b991866855f1977ff172eb6d901271\nF mptest/config02.test 4415dfe36c48785f751e16e32c20b077c28ae504\nF mptest/crash01.test 61e61469e257df0850df4293d7d4d6c2af301421\nF mptest/crash02.subtest f4ef05adcd15d60e5d2bd654204f2c008b519df8\nF mptest/mptest.c aa41ace6dbc5050d76b02548d3521e6bbccae4f0\nF mptest/multiwrite01.test dab5c5f8f9534971efce679152c5146da265222d\nF spec.template 86a4a43b99ebb3e75e6b9a735d5fd293a24e90ca\nF sqlite.pc.in 42b7bf0d02e08b9e77734a47798d1a55a9e0716b\nF sqlite3.1 fc7ad8990fc8409983309bb80de8c811a7506786\nF sqlite3.pc.in 48fed132e7cb71ab676105d2a4dc77127d8c1f3a\nF src/alter.c c49548d04914d370864c88ed4b5e3e3b112779ba70562ebd3f191b39be151536\nF src/analyze.c b3ceec3fc052df8a96ca8a8c858d455dc5029ba681b4be98bb5c5a9162cfa58c\nF src/attach.c b30c44333d55a68c0a12920b5b9d40b254cbd3d4509bda77417209eeed8b3d80\nF src/auth.c a3d5bfdba83d25abed1013a8c7a5f204e2e29b0c25242a56bc02bb0c07bf1e06\nF src/backup.c f70077d40c08b7787bfe934e4d1da8030cb0cc57d46b345fba2294b7d1be23ab\nF src/bitvec.c 17ea48eff8ba979f1f5b04cc484c7bb2be632f33\nF src/btmutex.c 8acc2f464ee76324bf13310df5692a262b801808984c1b79defb2503bbafadb6\nF src/btree.c d22498af716953400e314d2d98d1dac3ea5c3b01e0fd243ef9e9b132c74114ec\nF src/btree.h f27a33c49280209a93385e218306c4ee5f46ba8d7649d2f81a7166b282232484\nF src/btreeInt.h 91806f01fd1145a9a86ba3042f25c38d8faf6002701bf5e780742cf88bcff437\nF src/build.c ed6cc3e7e209d92b0ed2fa780c95b1a3aa7ecdd46a97671cfcca95079789bcc9\nF src/callback.c 88615dfc0a82167b65b452b4b305dbf86be77200b3343c6ffc6d03e92a01d181\nF src/complete.c a3634ab1e687055cd002e11b8f43eb75c17da23e\nF src/ctime.c 1b0724e66f95f33b160b1af85caaf9cceb325d22abf39bd24df4f54a73982251\nF src/date.c e1d8ac7102f3f283e63e13867acb0efa33861cf34f0faf4cdbaf9fa7a1eb7041\nF src/dbpage.c 135eb3b5e74f9ef74bde5cec2571192c90c86984fa534c88bf4a055076fa19b7\nF src/dbstat.c 6c407e549406c10fde9ac3987f6d734459205239ad370369bc5fcd683084a4fa\nF src/delete.c a5c59b9c0251cf7682bc52af0d64f09b1aefc6781a63592c8f1136f7b73c66e4\nF src/expr.c 947911a1826673add2311e8650aeaf9c2809706dfaa45fc2445a5ff32f70693d\nF src/fault.c 460f3e55994363812d9d60844b2a6de88826e007\nF src/fkey.c 92a248ec0fa4ed8ab60c98d9b188ce173aaf218f32e7737ba77deb2a684f9847\nF src/func.c ed33e38cd642058182a31a3f518f2e34f4bbe53aa483335705c153c4d3e50b12\nF src/global.c a1a8d698762ddd9a1543aac26c1e0029b20fcc3fcb56bfa41ec8cea2368f2798\nF src/hash.c 8d7dda241d0ebdafb6ffdeda3149a412d7df75102cecfc1021c98d6219823b19\nF src/hash.h 9d56a9079d523b648774c1784b74b89bd93fac7b365210157482e4319a468f38\nF src/hwtime.h cb1d7e3e1ed94b7aa6fde95ae2c2daccc3df826be26fc9ed7fd90d1750ae6144\nF src/in-operator.md 10cd8f4bcd225a32518407c2fb2484089112fd71\nF src/insert.c 730455b1530552212ef67bf51dde86090d3995c432fb5806cd1addc58f2919b7\nF src/legacy.c d7874bc885906868cd51e6c2156698f2754f02d9eee1bae2d687323c3ca8e5aa\nF src/loadext.c d74f5e7bd51f3c9d283442473eb65aef359664efd6513591c03f01881c4ae2da\nF src/main.c 868ae7db7a54fe859bf2ca8b7a4f24e9fa03a6134abfb7c9801d08411ef5dacb\nF src/malloc.c 550021fcae36f0ffe9f8563d83e6385f9df307a854d55d7d0abb7241ee8dbcc6\nF src/mem0.c 6a55ebe57c46ca1a7d98da93aaa07f99f1059645\nF src/mem1.c c12a42539b1ba105e3707d0e628ad70e611040d8f5e38cf942cee30c867083de\nF src/mem2.c f1940d9e91948dd6a908fbb9ce3835c36b5d83c3\nF src/mem3.c 8768ac94694f31ffaf8b4d0ea5dc08af7010a35a\nF src/mem5.c 9bf955937b07f8c32541c8a9991f33ce3173d944\nF src/memdb.c 02a5fcec19b9d40dd449ca802dc1b2e8f93f255fbf2a886277a3c3800d8d35db\nF src/memjournal.c 7561c01c90958f3ba9bc6cb2d857123d932bdfa5539ea34427a0957b2e35154d\nF src/msvc.h 3a15918220367a8876be3fa4f2abe423a861491e84b864fb2b7426bf022a28f8\nF src/mutex.c bae36f8af32c22ad80bbf0ccebec63c252b6a2b86e4d3e42672ff287ebf4a604\nF src/mutex.h a7b2293c48db5f27007c3bdb21d438873637d12658f5a0bf8ad025bb96803c4a\nF src/mutex_noop.c 9d4309c075ba9cc7249e19412d3d62f7f94839c4\nF src/mutex_unix.c aaf9ebc3f89df28483c52208497a99a02cc3650011422fc9d4c57e4392f7fe58\nF src/mutex_w32.c 7670d770c94bbfe8289bec9d7f1394c5a00a57c37f892aab6b6612d085255235\nF src/notify.c 9711a7575036f0d3040ba61bc6e217f13a9888e7\nF src/os.c 669cc3839cc35d20f81faf0be1ab6d4581cea35e9d8f3a9d48a98d6571f7c285\nF src/os.h 48388821692e87da174ea198bf96b1b2d9d83be5dfc908f673ee21fafbe0d432\nF src/os_common.h b2f4707a603e36811d9b1a13278bffd757857b85\nF src/os_setup.h 0dbaea40a7d36bf311613d31342e0b99e2536586\nF src/os_unix.c 3e0e519f27683083a465e948e056759a8340728c222b5c394a135e0c57c220bc\nF src/os_win.c 035a813cbd17f355bdcad7ab894af214a9c13a1db8aeac902365350b98cd45a7\nF src/os_win.h 7b073010f1451abe501be30d12f6bc599824944a\nF src/pager.c 30f20d2263d3717f41a0d9a40f7a3d0f48ce1cfab461b875c6187ead9d6ad1c7\nF src/pager.h 217921e81eb5fe455caa5cda96061959706bcdd29ddb57166198645ef7822ac3\nF src/parse.y 17c1ae265e1b92cb1f3f1661b020e3eb31f2d8b9588322d2b6f2b22f25b674c9\nF src/pcache.c 385ff064bca69789d199a98e2169445dc16e4291fa807babd61d4890c3b34177\nF src/pcache.h 4f87acd914cef5016fae3030343540d75f5b85a1877eed1a2a19b9f284248586\nF src/pcache1.c 62714cbd1b7299a6e6a27a587b66b4fd3a836a84e1181e7f96f5c34a50917848\nF src/pragma.c 36c367a62a9d3415fd3d15523e794cccc2cb74e6d806662b0185b8c686f06acb\nF src/pragma.h ec3b31eac9b1df040f1cc8cb3d89bc06605c3b4cb3d76f833de8d6d6c3f77f04\nF src/prepare.c 6049beb71385f017af6fc320d2c75a4e50b75e280c54232442b785fbb83df057\nF src/printf.c 9be6945837c839ba57837b4bc3af349eba630920fa5532aa518816defe42a7d4\nF src/random.c 80f5d666f23feb3e6665a6ce04c7197212a88384\nF src/resolve.c 618bf4f57fa0617cd5295117fea5f25955b76d278303405a8551c4204593011e\nF src/rowset.c d977b011993aaea002cab3e0bb2ce50cf346000dff94e944d547b989f4b1fe93\nF src/select.c 0fe10579de20eb8dc04ec9ed29659fa782bee2bcc85a35734637f3e2cabc2762\nF src/shell.c.in 4a3a9e1c11847b1904f2b01d087af1c052f660902755abab457cab1756817ded\nF src/sqlite.h.in 2a23e8161775253d9cf383c2c6aa559005dc787d350dcb0be67a6c4cc3bd1d19\nF src/sqlite3.rc 5121c9e10c3964d5755191c80dd1180c122fc3a8\nF src/sqlite3ext.h 72af51aa4e912e14cd495fb6e7fac65f0940db80ed950d90911aff292cc47ce2\nF src/sqliteInt.h daef6c0ec05fdb3dd8ed1b2da6fa2fdce98917dc463a6a65b001f3be5e24ce4c\nF src/sqliteLimit.h 1513bfb7b20378aa0041e7022d04acb73525de35b80b252f1b83fedb4de6a76b\nF src/status.c 46e7aec11f79dad50965a5ca5fa9de009f7d6bde08be2156f1538a0a296d4d0e\nF src/table.c b46ad567748f24a326d9de40e5b9659f96ffff34\nF src/tclsqlite.c 8cd2600e8de23dff6cdf84d39f46ca57139b061b28f6f80b166bace17d52ab1c\nF src/test1.c c654981c1d86ebc90dd23fcc0969e6c85e28112f0acc2e2224a97a2a33e7c42f\nF src/test2.c 3efb99ab7f1fc8d154933e02ae1378bac9637da5\nF src/test3.c 61798bb0d38b915067a8c8e03f5a534b431181f802659a6616f9b4ff7d872644\nF src/test4.c 405834f6a93ec395cc4c9bb8ecebf7c3d8079e7ca16ae65e82d01afd229694bb\nF src/test5.c 328aae2c010c57a9829d255dc099d6899311672d\nF src/test6.c e8d839fbc552ce044bec8234561a2d5b8819b48e29548ad0ba400471697946a8\nF src/test7.c 5612e9aecf934d6df7bba6ce861fdf5ba5456010\nF src/test8.c 3f7d0cc4e12e06832ba3db4455cb16867ccadafa602eb6ff5fcf097bffce56ed\nF src/test9.c 12e5ba554d2d1cbe0158f6ab3f7ffcd7a86ee4e5\nF src/test_async.c 195ab49da082053fdb0f949c114b806a49ca770a\nF src/test_autoext.c 915d245e736652a219a907909bb6710f0d587871\nF src/test_backup.c bf5da90c9926df0a4b941f2d92825a01bbe090a0\nF src/test_bestindex.c 78809f11026f18a93fcfd798d9479cba37e1201c830260bf1edc674b2fa9b857\nF src/test_blob.c ae4a0620b478548afb67963095a7417cd06a4ec0a56adb453542203bfdcb31ce\nF src/test_btree.c 8b2dc8b8848cf3a4db93f11578f075e82252a274\nF src/test_config.c e25826d693039cdd45963de378cbf39e3af0e8aa7a8a6fc159876f4e7b5a4f8c\nF src/test_delete.c e2fe07646dff6300b48d49b2fee2fe192ed389e834dd635e3b3bac0ce0bf9f8f\nF src/test_demovfs.c 86142ba864d4297d54c5b2e972e74f3141ae4b30f05b3a95824184ed2d3d7f91\nF src/test_devsym.c 6109b45c3db3ef7b002320947ed448c027356ab8b885156ff535fd8684d4a571\nF src/test_fs.c ba1e1dc18fd3159fdba0b9c4256f14032159785320dfbd6776eb9973cb75d480\nF src/test_func.c 181f992e5495644434c4f0e3cc72362a78c295eb2cf3ff4d02498b8bde7aa276\nF src/test_hexio.c d170d0e1a6431afdeac086a250d2595078288c2257615d37949355361399bcaa\nF src/test_init.c 4413c211a94b62157ca4c145b3f27c497f03c664\nF src/test_intarray.c 39b4181662a0f33a427748d87218e7578d913e683dc27eab7098bb41617cac71\nF src/test_intarray.h d57ae92f420cda25e22790dac474d60961bd0c500cbaa3338a05152d4a669ef7\nF src/test_journal.c a0b9709b2f12b1ec819eea8a1176f283bca6d688a6d4a502bd6fd79786f4e287\nF src/test_loadext.c 337056bae59f80b9eb00ba82088b39d0f4fe6dfd\nF src/test_malloc.c dec0aa821b230773aeb3dd11d652c1193f7cedb18a20b25659bc672288115242\nF src/test_md5.c 7268e1e8c399d4a5e181b64ac20e1e6f3bc4dd9fc87abac02db145a3d951fa8c\nF src/test_multiplex.c e054459f7633f3ff8ce1245da724f9a8be189e4e\nF src/test_multiplex.h 5436d03f2d0501d04f3ed50a75819e190495b635\nF src/test_mutex.c 7f4337ba23ee6b1d2ec81c189653608cb069926a\nF src/test_onefile.c f31e52e891c5fef6709b9fcef54ce660648a34172423a9cbdf4cbce3ba0049f4\nF src/test_osinst.c 98ef31ff03d55497829ca0f6c74a9f4e1aa48690\nF src/test_pcache.c a5cd24730cb43c5b18629043314548c9169abb00\nF src/test_quota.c 6cb9297115b551f433a9ad1741817a9831abed99\nF src/test_quota.h 2a8ad1952d1d2ca9af0ce0465e56e6c023b5e15d\nF src/test_rtree.c 671f3fae50ff116ef2e32a3bf1fe21b5615b4b7b\nF src/test_schema.c f575932cb6274d12147a77e13ea4b49d52408513\nF src/test_server.c a2615049954cbb9cfb4a62e18e2f0616e4dc38fe\nF src/test_sqllog.c 11e6ce7575f489155c604ac4b439f2ac1d3d5aef\nF src/test_superlock.c 4839644b9201da822f181c5bc406c0b2385f672e\nF src/test_syscall.c 1073306ba2e9bfc886771871a13d3de281ed3939\nF src/test_tclsh.c eeafce33ad2136d57e5dec10f1e9a4347447eb72ffd504a1c7b9c6bfe2e71578\nF src/test_tclvar.c 33ff42149494a39c5fbb0df3d25d6fafb2f668888e41c0688d07273dcb268dfc\nF src/test_thread.c 911d15fb14e19c0c542bdc8aabf981c2f10a4858\nF src/test_vdbecov.c f60c6f135ec42c0de013a1d5136777aa328a776d33277f92abac648930453d43\nF src/test_vfs.c 36822d696789535bdd0260f07d2c9a46546082fea8bb1d0a7354c7f9366e37ea\nF src/test_vfstrace.c bab9594adc976cbe696ff3970728830b4c5ed698\nF src/test_windirent.c a895e2c068a06644eef91a7f0a32182445a893b9a0f33d0cdb4283dca2486ac1\nF src/test_windirent.h 90dfbe95442c9762357fe128dc7ae3dc199d006de93eb33ba3972e0a90484215\nF src/test_window.c cdae419fdcea5bad6dcd9368c685abdad6deb59e9fc8b84b153de513d394ba3f\nF src/test_wsd.c 41cadfd9d97fe8e3e4e44f61a4a8ccd6f7ca8fe9\nF src/threads.c 4ae07fa022a3dc7c5beb373cf744a85d3c5c6c3c\nF src/tokenize.c 7b17f6e2f20f6cbcb0b215025a86b7457c38451fc7622f705e553d7a488c572d\nF src/treeview.c 41d928f04d65931b15f629b4938e9f2c7dc259f02eef34cb2cc6e293f5af813f\nF src/trigger.c 681ccdb910a87243940d63f99b26190d9c5d2534c2ded3c0825b7c0e315a342e\nF src/update.c 07a50767f7d3e26d4c887c31cd66448d700d3215caea6023acf7269336097df7\nF src/upsert.c b445315c8958d8f17ec3297d06842e61dacaad0633ccaec1e4e160de7e562212\nF src/utf.c 2f0fac345c7660d5c5bd3df9e9d8d33d4c27f366bcfb09e07443064d751a0507\nF src/util.c 66b22af7b359ce6493c34fef28c87d5c2d1765f212d6e4cd5e08d99ac30b89bb\nF src/vacuum.c 82dcec9e7b1afa980288718ad11bc499651c722d7b9f32933c4d694d91cb6ebf\nF src/vdbe.c b67d6af853e03c3dd6d1116351567f62d8a2c10d3bd6db5f7f366e75d11c6653\nF src/vdbe.h fdbc0a11e5768a702b46ce63286f60e22e71351a29bd98b3666405e1fccc7802\nF src/vdbeInt.h bd589b8b7273286858950717e0e1ec5c88b18af45079a3366dc1371865cea704\nF src/vdbeapi.c 1252d80c548711e47a6d84dae88ed4e95d3fbb4e7bd0eaa1347299af7efddf02\nF src/vdbeaux.c 0bbbdc70c573d5112b74a3d555dd51c76ee3f8b6d43cf07e5105ced6a3ec0d10\nF src/vdbeblob.c 253ed82894924c362a7fa3079551d3554cd1cdace39aa833da77d3bc67e7c1b1\nF src/vdbemem.c 2eb00a4d1a7d2c97510a4d1ccaf4e12c9143f2ced1c6b96b5eddc372183c9121\nF src/vdbesort.c a3be032cc3fee0e3af31773af4a7a6f931b7230a34f53282ccf1d9a2a72343be\nF src/vdbetrace.c fa3bf238002f0bbbdfb66cc8afb0cea284ff9f148d6439bc1f6f2b4c3b7143f0\nF src/vtab.c 108f79166d4a232a8bfb9d46e2fbec191f83a87fe97f7b93fc4de976c3fa3434\nF src/vxworks.h d2988f4e5a61a4dfe82c6524dd3d6e4f2ce3cdb9\nF src/wal.c 15a2845769f51ba132f9cf0b2c7a6887a91fc8437892dbcce9fcdc68b66d60a1\nF src/wal.h 606292549f5a7be50b6227bd685fa76e3a4affad71bb8ac5ce4cb5c79f6a176a\nF src/walker.c a137468bf36c92e64d2275caa80c83902e3a0fc59273591b96c6416d3253d05d\nF src/where.c bb2d3c08de9ae57f6ff17459cefd9e38e82d3e7aaa544bc49503b6fdaaf2c800\nF src/whereInt.h 4a296fd4fa79fdcbc2b5e8c1b898901617655811223e1082b899c23ecb092217\nF src/wherecode.c 909325b98d5cb313f24e5c8cb304a3e3c73ca6631cdb19cfa1f580dde182fedb\nF src/whereexpr.c 39b6a538804c6e1248c22b33e09d00f89ae6a099c849c4d841ce3995562287b4\nF src/window.c a77f12078dd4b10e655d4ba5a73ca32dbe00e0206018305185c7e86445d3f429\nF test/8_3_names.test ebbb5cd36741350040fd28b432ceadf495be25b2\nF test/affinity2.test ce1aafc86e110685b324e9a763eab4f2a73f737842ec3b687bd965867de90627\nF test/affinity3.test 6a101af2fc945ce2912f6fe54dd646018551710d\nF test/aggerror.test a867e273ef9e3d7919f03ef4f0e8c0d2767944f2\nF test/aggnested.test 12106f0748e8e9bfc1a8e6840e203e051eae06a26ed13fc9fd5db108a8d6db54\nF test/alias.test 4529fbc152f190268a15f9384a5651bbbabc9d87\nF test/all.test 2ecb8bbd52416642e41c9081182a8df05d42c75637afd4488aace78cc4b69e13\nF test/alter.test 16ed8d2470193f34bc711e51506ff1211ebfab8025ca3b9510ff2aef139874cb\nF test/alter2.test a966ccfcddf9ce0a4e0e6ff1aca9e6e7948e0e242cd7e43fc091948521807687\nF test/alter3.test 9351a9f0c59ff9dddecccaaa2f777ffee5369870c63d30d3a74add815254ec0f\nF test/alter4.test 74b22251c5e9c48093cfc4921ed9c11b59df84634aeeb00e501773320beb8424\nF test/alterauth.test 63442ba61ceb0c1eeb63aac1f4f5cebfa509d352276059d27106ae256bafc959\nF test/alterauth2.test c0a1ddf5b93d93cb0d15ba7acaf0c5c6fb515bbe861ede75b2d3fabad33b6499\nF test/altercol.test 54374d2ba18af25bb24e23acf18a60270d4ec120b7ec0558078b59d5aa1a31ad\nF test/alterlegacy.test 82022721ce0de29cedc9a7af63bc9fcc078b0ee000f8283b4b6ea9c3eab2f44b\nF test/altermalloc.test 167a47de41b5c638f5f5c6efb59784002b196fff70f98d9b4ed3cd74a3fb80c9\nF test/altermalloc2.test fa7b1c1139ea39b8dec407cf1feb032ca8e0076bd429574969b619175ad0174b\nF test/altertab.test 4d8b79b0b88b62b90b710390df14fe99e0a3578345526886eaa550e28e3065dc\nF test/altertab2.test 8883693952f6d7fb5f754dbf1d694ed780aa883027bef04cb1fb99a3b88c9272\nF test/altertab3.test 18111c210a4992abe90247e4a83c6f6e901537288c42879d12680088612d0fa2\nF test/amatch1.test b5ae7065f042b7f4c1c922933f4700add50cdb9f\nF test/analyze.test 547bb700f903107b38611b014ca645d6b5bb819f5210d7bf39c40802aafeb7d7\nF test/analyze3.test 01f0b122e3e54ad2544f14f7cc7dcb4c2cb8753cad5e88c6b8d49615b3fd6a2b\nF test/analyze4.test cdf88f3f72b0f0643a1ff6c730fc5af1e42464d47478d9fbac84c333f72c014e\nF test/analyze5.test fa5131952303ac4146aba101b116b9c8cb89e2637531c334a6df7f7d19dddc0d\nF test/analyze6.test 6c3f7df2996cb6872f355a6ac1eb6d5de00a5a9288214bad7ef25c97d9cc72dc\nF test/analyze7.test 6ef0b12369f61ddeadc7d8a705c40e6b52cb29f63de3a4c56581b510b46b5783\nF test/analyze8.test 36ce54947710bd44e4f9484e1ad07e725ef01a9d7078b417c1bc884356febe4d\nF test/analyze9.test 9fbf0e0101eef4f5dc149769aa14e10b76ee06e7c28598264b32173cd1999a54\nF test/analyzeC.test 489fe2ea3be3f17548e8dd895f1b41c9669b52de1b0861f5bffe6eec46eac710\nF test/analyzeD.test e50cd0b3e6063216cc0c88a1776e8645dc0bd65a6bb275769cbee33b7fd8d90c\nF test/analyzeE.test 8684e8ac5722fb97c251887ad97e5d496a98af1d\nF test/analyzeF.test 9e1a0537949eb5483642b1140a5c39e5b4025939024b935398471fa552f4dabb\nF test/analyzer1.test 459fa02c445ddbf0101a3bad47b34290a35f2e49\nF test/async.test 1d0e056ba1bb9729283a0f22718d3a25e82c277b\nF test/async2.test c0a9bd20816d7d6a2ceca7b8c03d3d69c28ffb8b\nF test/async3.test d73a062002376d7edc1fe3edff493edbec1fc2f7\nF test/async4.test 1787e3952128aa10238bf39945126de7ca23685a\nF test/async5.test 383ab533fdb9f7ad228cc99ee66e1acb34cc0dc0\nF test/atof1.test ff0b0156fd705b67c506e1f2bfe9e26102bea9bd\nF test/atomic.test 065a453dde33c77ff586d91ccaa6ed419829d492dbb1a5694b8a09f3f9d7d061\nF test/atomic2.test b6863b4aa552543874f80b42fb3063f1c8c2e3d8e56b6562f00a3cc347b5c1da\nF test/atrc.c ec92d56d8fbed9eb3e11aaf1ab98cf7dd59e69dae31f128013f1d97e54e7dfed\nF test/attach.test 21bce8681f780a8d631a5ec7ecd0d849bfe84611257b038ae4ffeccc609d8a4e\nF test/attach2.test 256bd240da1835fb8408dd59fb7ef71f8358c7a756c46662434d11d07ba3a0ce\nF test/attach3.test c59d92791070c59272e00183b7353eeb94915976\nF test/attach4.test aa05b1d8218b24eba5a7cccf4f224f514ba57ba705c9267f09d2bb63fed0eea1\nF test/attachmalloc.test 12c4f028e570acf9e0a4b0b7fe6f536e21f3d5ebddcece423603d0569beaf438\nF test/auth.test 2154625c05bc79f0e0ea72cb2358395a8041243caa0fd7ce7617d50da4331794\nF test/auth2.test 9eb7fce9f34bf1f50d3f366fb3e606be5a2000a1\nF test/auth3.test db21405b95257c24d29273b6b31d0efc59e1d337e3d5804ba2d1fd4897b1ae49\nF test/autoanalyze1.test b9cc3f32a990fa56669b668d237c6d53e983554ae80c0604992e18869a0b2dec\nF test/autoinc.test 997d6f185f138229dc4251583a1d04816423dddc2fc034871a01aeb1d728cb39\nF test/autoindex1.test 96185415f5faacd5b8d7a7f505efddd5abb1f111d58338e9c0b1dc40b87cd3cc\nF test/autoindex2.test 12ef578928102baaa0dc23ad397601a2f4ecb0df\nF test/autoindex3.test 2dd997d6590438b53e4f715f9278aa91c9299cf3f81246a0915269c35beb790e\nF test/autoindex4.test 49d3cd791a9baa16fb461d7ea3de80d019a819cf\nF test/autoindex5.test a5d72fe8c217cc0ea356dc6fa06a282a8a3fc53aa807709d79dba07a8f248102\nF test/autovacuum.test 0831cd34e14695d297187f7f6519265e3121c5b0a1720e548e86829e796129e9\nF test/autovacuum_ioerr2.test 8a367b224183ad801e0e24dcb7d1501f45f244b4\nF test/avtrans.test b7dc25459ecbd86c6fa9c606ee3068f59d81e225118617dcf2bbb6ded2ade89e\nF test/backcompat.test 3e64cedda754c778ef6bbe417b6e7a295e662a4d\nF test/backup.test dd4a5ff756e3df3931dacb1791db0584d4bad989\nF test/backup2.test 1fd1ad8c5b3d2d5b9c0cce4143a4fc610d51ddc6ae16a7a122973d43e6b50bbd\nF test/backup4.test 8f6fd48e0dfde77b9a3bb26dc471ede3e101df32\nF test/backup5.test ee5da6d7fe5082f5b9b0bbfa31d016f52412a2e4\nF test/backup_ioerr.test 4c3c7147cee85b024ecf6e150e090c32fdbb5135\nF test/backup_malloc.test 0c9abdf74c51e7bedb66d504cd684f28d4bd4027\nF test/badutf.test d5360fc31f643d37a973ab0d8b4fb85799c3169f\nF test/badutf2.test f310fd3b24a491b6b77bccdf14923b85d6ebcce751068c180d93a6b8ff854399\nF test/bc_common.tcl b5e42d80305be95697e6370e015af571e5333a1c\nF test/bestindex1.test 705b57d7f51d53ee5fd043dd9666236e1fc18f4d59abf51da0ea5ea1b4804947\nF test/bestindex2.test 9a0ccd320b6525eec3a706aae6cdab7e1b7b5abca75027e39f39f755e76e5928\nF test/bestindex3.test 7622e792ff2da16d262d3cea6ad914591ac4806d57ed128e6c940b7920b47b84\nF test/bestindex4.test 038e3d0789332f3f1d61474f9bbc9c6d08c6bd1783a978f31f38ad82688de601\nF test/bestindex5.test 67c1166131bb59f9e47c00118f7d432ca5491e6cae6ca3f87ca9db20103a78f9\nF test/bestindex6.test d856a9bb63d927493575823eed44053bc36251e241aa364e54d0f2a2d302e1d4\nF test/between.test 68137a6e941c221417c15b6fe2d55f27bb1b6ab48bdf9e2aa51efdd85bc53802\nF test/bigfile.test aa74f4e5db51c8e54a1d9de9fa65d01d1eb20b59\nF test/bigfile2.test 1b489a3a39ae90c7f027b79110d6b4e1dbc71bfc\nF test/bigmmap.test 31dad31573638bd32de866cdefd11843f75685be4ba6aec1a47918f098f1899b\nF test/bigrow.test f0aeb7573dcb8caaafea76454be3ade29b7fc747\nF test/bigsort.test 8299fa9298f4f1e02fc7d2712e8b77d6cd60e5a2\nF test/bind.test 1e136709b306f7ed3192d349c2930d89df6ab621654ad6f1a72381d3fe76f483\nF test/bindxfer.test efecd12c580c14df5f4ad3b3e83c667744a4f7e0\nF test/bitvec.test 75894a880520164d73b1305c1c3f96882615e142\nF test/blob.test e7ac6c7d3a985cc4678c64f325292529a69ae252\nF test/boundary1.tcl 6421b2d920d8b09539503a8673339d32f7609eb1\nF test/boundary1.test 66d7f4706ccdb42d58eafdb081de07b0eb42d77b\nF test/boundary2.tcl e34ef4e930cf1083150d4d2c603e146bd3b76bcb\nF test/boundary2.test 9ae758d7dab7e882c8b6cc4a6a10278385bff8fa\nF test/boundary3.tcl 23361e108a125dca9c4080c2feb884fe54d69243\nF test/boundary3.test 56ef82096b4329aca2be74fa1e2b0f762ea0eb45\nF test/boundary4.tcl 0bb4b1a94f4fc5ae59b79b9a2b7a140c405e2983\nF test/boundary4.test 89e02fa66397b8a325d5eb102b5806f961f8ec4b\nF test/btree01.test e08b3613540145b353f20c81cb18ead54ff12e0f\nF test/btree02.test 7555a5440453d900410160a52554fe6478af4faf53098f7235f1f443d5a1d6cc\nF test/btreefault.test c2bcb542685eea44621275cfedbd8a13f65201e3\nF test/busy.test 510dc6daaad18bcbbc085bcc6217d6dc418def5e73f72ce1475eea0cb7834727\nF test/cache.test 13bc046b26210471ca6f2889aceb1ea52dc717de\nF test/cacheflush.test af25bb1509df04c1da10e38d8f322d66eceedf61\nF test/cachespill.test 895997f84a25b323b166aecb69baab2d6380ea98f9e0bcc688c4493c535cfab9\nF test/capi2.test 34a1a9a96d543a2ec2c209696b11b164444f57253b1f2cba1c2e53fadede6c7b\nF test/capi3.test 3910a73c38ac76d69778dd9eb481ab7cd6ed59117fc047b4f6056a5c72529de1\nF test/capi3b.test efb2b9cfd127efa84433cd7a2d72ce0454ae0dc4\nF test/capi3c.test 54e2dc0c8fd7c34ad1590d1be6864397da2438c95a9f5aee2f8fbc60c112e44b\nF test/capi3d.test aba917805573a03deed961a21f07a5a84505ad0a616f7e3fc1508844a15bccc4\nF test/capi3e.test 3d49c01ef2a1a55f41d73cba2b23b5059ec460fe\nF test/cast.test 3619f0c58c2e4b2a94aa86e75607e497d34ef40ab74418e71aef7b4ca5155895\nF test/cffault.test 9d6b20606afe712374952eec4f8fd74b1a8097ef\nF test/check.test 25c6035302c846c7ff8e681cf8284473f6f01be94d327de60a688ad84ab01f8b\nF test/checkfault.test da6cb3d50247169efcb20bdf57863a3ccfa1d27d9e55cd324f0680096970f014\nF test/chunksize.test 427d87791743486cbf0c3b8c625002f3255cb3a89c6eba655a98923b1387b760\nF test/close.test eccbad8ecd611d974cbf47278c3d4e5874faf02d811338d5d348af42d56d647c\nF test/closure01.test 9905883f1b171a4638f98fc764879f154e214a306d3d8daf412a15e7f3a9b1e0\nF test/coalesce.test cee0dccb9fbd2d494b77234bccf9dc6c6786eb91\nF test/collate1.test 4178fda6f4cd757b7a278e6b83805868fb1eb46edafb6e3d4bcc2419f8d93202\nF test/collate2.test 9aaa410a00734e48bcb27f3872617d6f69b2a621\nF test/collate3.test 89defc49983ddfbf0a0555aca8c0521a676f56a5\nF test/collate4.test c953715fb498b87163e3e73dd94356bff1f317bd\nF test/collate5.test 65d928034d30d2d263a80f6359f7549ee1598ec6\nF test/collate6.test 8be65a182abaac8011a622131486dafb8076e907\nF test/collate7.test 8ec29d98f3ee4ccebce6e16ce3863fb6b8c7b868\nF test/collate8.test cd9b3d3f999b8520ffaa7cc1647061fc5bab1334\nF test/collate9.test 3adcc799229545940df2f25308dd1ad65869145a\nF test/collateA.test b8218ab90d1fa5c59dcf156efabb1b2599c580d6\nF test/collateB.test 1e68906951b846570f29f20102ed91d29e634854ee47454d725f2151ecac0b95\nF test/colmeta.test 2c765ea61ee37bc43bbe6d6047f89004e6508eb1\nF test/colname.test 87ad5458bb8709312dac0d6755fd30e8e4ca83298d0a9ef6e5c24277a3c3390e\nF test/conflict.test c7cc007e2af151516ddf38f7412fe10d473a694f55e3df437e2c7b31c2590e8d\nF test/conflict2.test bb0b94cf7196c64a3cbd815c66d3ee98c2fecd9c\nF test/conflict3.test f62a2d0cad9162a60e6458fc913dff3a2208feca924120c21737cfee65a6a74a\nF test/contrib01.test 2a1cbc0f2f48955d7d073f725765da6fbceda6b4\nF test/corrupt.test d7cb0300e4a297147b6a05e92a1684bc8973635c3bcaa3d66e983c9cbdbf47a3\nF test/corrupt2.test bb50042cf9a1f1023d73af325d47eb02a6bb11e3c52f8812644b220c5d4bca35\nF test/corrupt3.test f95d7bf78109e0b84eb285a787ce91a3fd6a2dd7d0cb55882abff3bdc081a57e\nF test/corrupt4.test 8d1d86b850fcc43e417450454f2044e52d55778a\nF test/corrupt5.test 387be3250795e2a86e6234745558b80efb248a357d0cd8e53bce75c7463f545d\nF test/corrupt6.test fc6a891716139665dae0073b6945e3670bf92568\nF test/corrupt7.test b036f94bda4b0b23a2919bf717046ce9ecca4543\nF test/corrupt8.test 2399dfe40d2c0c63af86706e30f3e6302a8d0516\nF test/corrupt9.test 730a3db08d4ab9aa43392ea30d9c2b4879cbff85\nF test/corruptA.test 112f4b2ae0b95ebf3ea63718642fb969a93acea557ace3a307234d19c245989b\nF test/corruptB.test 73a8d6c0b9833697ecf16b63e3c5c05c945b5dec\nF test/corruptC.test 74d4498fd25759618b393f1e9cde111de828b88c1848ab320f6c179fd52b5a60\nF test/corruptD.test 33a37ce3ed56a20093ceee778cd2d7109c7085a59f3213d2baede11d952e8e50\nF test/corruptE.test 4143791f2dfb443aec5b7fabfa5821e6063eccc3b49b06f212c2f014715fd476\nF test/corruptF.test be9fde98e4c93648f1ba52b74e5318edc8f59fe4\nF test/corruptG.test adf79b669cbfd19e28c8191a610d083ae53a6d51\nF test/corruptH.test 79801d97ec5c2f9f3c87739aa1ec2eb786f96454\nF test/corruptI.test a17bbf54fdde78d43cf3cc34b0057719fd4a173a3d824285b67dc5257c064c7b\nF test/corruptJ.test 4d5ccc4bf959464229a836d60142831ef76a5aa4\nF test/corruptK.test 5b4212fe346699831c5ad559a62c54e11c0611bdde1ea8423a091f9c01aa32af\nF test/corruptL.test a22a7bbf8da7603960f0bfcc62a68d1c3c41963786bd832ff804ba5e2458fb9c\nF test/corruptM.test 7d574320e08c1b36caa3e47262061f186367d593a7e305d35f15289cc2c3e067\nF test/cost.test 51f4fcaae6e78ad5a57096831259ed6c760e2ac6876836e91c00030fad385b34\nF test/count.test cb2e0f934c6eb33670044520748d2ecccd46259c\nF test/countofview.test e17d6e6688cf74f22783c9ec6e788c0790ee4fbbaee713affd00b1ac0bb39b86\nF test/coveridxscan.test 5ec98719a2e2914e8908dc75f7247d9b54a26df04625f846ac7900d5483f7296\nF test/crash.test fb9dc4a02dcba30d4aa5c2c226f98b220b2b959f\nF test/crash2.test 5b14d4eb58b880e231361d3b609b216acda86651\nF test/crash3.test 8f5de9d32ab9ab95475a9efe7f47a940aa889418\nF test/crash4.test fe2821baf37168dc59dd733dcf7dba2a401487bc\nF test/crash5.test f14ff37eddc41991be4eb63568f86caa306fd9962a0ae3750db8836777bb7aae\nF test/crash6.test 4c56f1e40d0291e1110790a99807aa875b1647ba\nF test/crash7.test 1a194c4900a255258cf94b7fcbfd29536db572df\nF test/crash8.test 64366e459c28dd62edfb7ad87253a409c7533b92d16fcc479a6a8131bdcc3100\nF test/crashM.test d95f59046fa749b0d0822edf18a717788c8f318d\nF test/crashtest1.c 09c1c7d728ccf4feb9e481671e29dda5669bbcc2\nF test/createtab.test 85cdfdae5c3de331cd888d6c66e1aba575b47c2e3c3cc4a1d6f54140699f5165\nF test/cse.test 277350a26264495e86b1785f34d2d0c8600e021c\nF test/csv01.test c9c3af0d58c34e9ac970c5875a77939edb958762c8aafb95409e19a3f088b6cd\nF test/ctime.test 78749e6c9a5f0010d67985be80788f841e3cd2da18114e2ed6010399a7d807f3\nF test/cursorhint.test 7bc346788390475e77a345da2b92270d04d35856\nF test/cursorhint2.test 6f3aa9cb19e7418967a10ec6905209bcbb5968054da855fc36c8beee9ae9c42f\nF test/dataversion1.test 6e5e86ac681f0782e766ebcb56c019ae001522d114e0e111e5ebf68ccf2a7bb8\nF test/date.test 9b73bbeb1b82d9c1f44dec5cf563bf7da58d2373\nF test/date2.test 5ef8265c71460cda6b1698bf18f4bb0ffb40ac08c5092f6afe84d398c2feb5be\nF test/dbdata.test 042f49acff3438f940eeba5868d3af080ae64ddf26ae78f80c92bec3ca7d8603\nF test/dbfuzz.c 73047c920d6210e5912c87cdffd9a1c281d4252e\nF test/dbfuzz001.test 42aad1dcef6219fbee86a9b7d08832c9bbb2e41508f6f128ae91745927276292\nF test/dbfuzz2-seed1.db e6225c6f3d7b63f9c5b6867146a5f329d997ab105bee64644dc2b3a2f2aebaee\nF test/dbfuzz2.c c2c9cb40082a77b7e95ffb8b2da1e93322efadfb1c8c1e0001c95a0af1e156c2\nF test/dbpage.test 650234ba683b9d82b899c6c51439819787e7609f17a0cc40e0080a7b6443bc38\nF test/dbstatus.test 4a4221a883025ffd39696b3d1b3910b928fb097d77e671351acb35f3aed42759\nF test/dbstatus2.test f5fe0afed3fa45e57cfa70d1147606c20d2ba23feac78e9a172f2fe8ab5b78ef\nF test/default.test 3e46c421eebefd2787c2f96673efabf792d360f3a1d5073918cbe450ce672a62\nF test/delete.test 31832b0c45ecb51a54348c68db173be462985901e6ed7f403d6d7a8f70ab4ef0\nF test/delete2.test 3a03f2cca1f9a67ec469915cb8babd6485db43fa\nF test/delete3.test 555e84a00a99230b7d049d477a324a631126a6ab\nF test/delete4.test 6aa279f459f4aa792cc251435c3809415c1ecaf9f27dce91675e26f05b503db3\nF test/delete_db.test 096d828493c7907f9ea11a7098ea6a0f73edba89406487d5d6cc2228dc4ab8b0\nF test/descidx1.test edc8adee58d491b06c7157c50364eaf1c3605c9c19f8093cb1ea2b6184f3ac13\nF test/descidx2.test a0ba347037ff3b811f4c6ceca5fd0f9d5d72e74e59f2d9de346a9d2f6ad78298\nF test/descidx3.test 953c831df7ea219c73826dfbf2f6ee02d95040725aa88ccb4fa43d1a1999b926\nF test/diskfull.test 106391384780753ea6896b7b4f005d10e9866b6e\nF test/distinct.test a1783b960ad8c15a77cd9f207be072898db1026c\nF test/distinct2.test 11b0594c932098e969d084ba45ab81d5040f4d4e766db65d49146705a305ed98\nF test/distinctagg.test 1a6ef9c87a58669438fc771450d7a72577417376\nF test/e_blobbytes.test 439a945953b35cb6948a552edaec4dc31fd70a05\nF test/e_blobclose.test 4b3c8c60c2171164d472059c73e9f3c1844bb66d\nF test/e_blobopen.test e95e1d40f995056f6f322cd5e1a1b83a27e1a145\nF test/e_blobwrite.test f87ff598b67af5b3ec002a8d83e804dc8d23808e88cf0080c176612fc9ffce14\nF test/e_changes.test fd66105385153dbf21fdb35eb8ef6c3e1eade579\nF test/e_createtable.test 1c602347e73ab80b11b9fa083f47155861aaafcff8054aac9e0b76d0df33b0a7\nF test/e_delete.test ab39084f26ae1f033c940b70ebdbbd523dc4962e\nF test/e_droptrigger.test 3cd080807622c13e5bbb61fc9a57bd7754da2412\nF test/e_dropview.test 21ce09c361227ddbc9819a5608ee2700c276bdd5\nF test/e_expr.test 328d2d7c84f8e53e942a13eac771b337bcdfcf4c3569324001868b5639f3c857\nF test/e_fkey.test 2febb2084aef9b0186782421c07bc9d377abf067c9cb4efd49d9647ae31f5afe\nF test/e_fts3.test 17ba7c373aba4d4f5696ba147ee23fd1a1ef70782af050e03e262ca187c5ee07\nF test/e_insert.test f02f7f17852b2163732c6611d193f84fc67bc641fb4882c77a464076e5eba80e\nF test/e_reindex.test 2b0e29344497d9a8a999453a003cb476b6b1d2eef2d6c120f83c2d3a429f3164\nF test/e_resolve.test a61751c368b109db73df0f20fc75fb47e166b1d8\nF test/e_select.test f9474205669a7736ef725b29cc7ae9e8601919a3d0ffc0ab30745a028f2a4b61\nF test/e_select2.test aceb80ab927d46fba5ce7586ebabf23e2bb0604f\nF test/e_totalchanges.test b12ee5809d3e63aeb83238dd501a7bca7fd72c10\nF test/e_update.test f46c2554d915c9197548681e8d8c33a267e84528\nF test/e_uri.test 47eeb2960e74613f0f8722b2f13aef08fde69daa16e5380ac93df84dac8b1f72\nF test/e_vacuum.test 0d8832a2ce92350db0d0cff47b419465fd9772562e1f77ff7d9478c07a4980d2\nF test/e_wal.test ae9a593207a77d711443ee69ffe081fda9243625\nF test/e_walauto.test 248af31e73c98df23476a22bdb815524c9dc3ba8\nF test/e_walckpt.test 28c371a6bb5e5fe7f31679c1df1763a19d19e8a0\nF test/e_walhook.test 01b494287ba9e60b70f6ebf3c6c62e0ffe01788e344a4846b08e5de0b344cb66\nF test/emptytable.test a38110becbdfa6325cd65cb588dca658cd885f62\nF test/enc.test e54531cd6bf941ee6760be041dff19a104c7acea\nF test/enc2.test 83437a79ba1545a55fb549309175c683fb334473\nF test/enc3.test 6807f7a7740a00361ca8d0ccd66bc60c8dc5f2b6\nF test/enc4.test c8f1ce3618508fd0909945beb8b8831feef2c020\nF test/eqp.test 84879b63e3110552bf8ce648a3507dc3ceb72109ecec83c2aef0db37a27f6382\nF test/errmsg.test eae9f091eb39ce7e20305de45d8e5d115b68fa856fba4ea6757b6ca3705ff7f9\nF test/eval.test a64c9105d6ff163df7cf09d6ac29cdad5922078c\nF test/exclusive.test 1206b87e192497d78c7f35552e86a9d05421498da300fb1cce5ca5351ccde3c3\nF test/exclusive2.test 984090e8e9d1b331d2e8111daf6e5d61dda0bef7\nF test/exec.test e949714dc127eaa5ecc7d723efec1ec27118fdd7\nF test/exists.test 79a75323c78f02bbe9c251ea502a092f9ef63dac\nF test/expr.test 7cb55e80aeb41d65fec968c08212505123063fea60bdc355d764d747670e9eea\nF test/expr2.test c27327ae9c017a7ff6280123f67aff496f912da74d78c888926d68b46ec75fd8\nF test/extension01.test 00d13cec817f331a687a243e0e5a2d87b0e358c9\nF test/extraquick.test cb254400bd42bfb777ff675356aabf3287978f79\nF test/fallocate.test 37a62e396a68eeede8f8d2ecf23573a80faceb630788d314d0a073d862616717\nF test/filectrl.test 6e871c2d35dead1d9a88e176e8d2ca094fec6bb3\nF test/filefmt.test f393e80c4b8d493b7a7f8f3809a8425bbf4292af1f5140f01cb1427798a2bbd4\nF test/filter1.test fe7fcfeff48ca399fbc9577f55b60c8be8ccfdffc5e3b4ace21dc3c3e59f0f6a\nF test/filter2.tcl 44e525497ce07382915f01bd29ffd0fa49dab3adb87253b5e5103ba8f93393e8\nF test/filter2.test 485cf95d1f6d6ceee5632201ca52a71868599836f430cdee42e5f7f14666e30a\nF test/filterfault.test c08fb491d698e8df6c122c98f7db1c65ffcfcad2c1ab0e07fa8a5be1b34eaa8b\nF test/fkey1.test d11dbb8a93ead9b5c46ae5d02da016d61245d47662fb2d844c99214f6163f768\nF test/fkey2.test d35d1c81e7569bdd2b872e91750f7098117d2e8291369f70b7e3d50a0e523dc2\nF test/fkey3.test 76d475c80b84ee7a5d062e56ccb6ea68882e2b49\nF test/fkey4.test 86446017011273aad8f9a99c1a65019e7bd9ca9d\nF test/fkey5.test 24dd28eb3d9f1b5a174f47e9899ace5facb08373a4223593c8c631e6cf9f7d5a\nF test/fkey6.test d078a1e323a740062bed38df32b8a736fd320dc0\nF test/fkey7.test 64fb28da03da5dfe3cdef5967aa7e832c2507bf7fb8f0780cacbca1f2338d031\nF test/fkey8.test 48ef829d63f5f7b37aabd4df9363ac05f65539d1da8c4a44251631769d920579\nF test/fkey_malloc.test 594a7ea1fbab553c036c70813cd8bd9407d63749\nF test/fordelete.test eb93a2f34137bb87bdab88fcab06c0bd92719aff\nF test/format4.test eeae341953db8b6bda7f549044797c3278a6cc345d11ada81471671b654f8ef4\nF test/fts-9fd058691.test 78b887e30ae6816df0e1fed6259de4b5a64ad33c\nF test/fts1a.test 46090311f85da51bb33bd5ce84f7948359c6d8d7\nF test/fts1b.test 5d8a01aefbecc8b7442b36c94c05eb7a845462d5\nF test/fts1c.test 85a525ce7428907469b4cce13d5563ce542ce64c\nF test/fts1d.test a73deace5c18df4a549b12908bade4f05dcf1a2f\nF test/fts1e.test 77244843e925560b5a0b70069c3e7ab62f181ed2\nF test/fts1f.test 2d6cb10d8b7a4e6edc321bbdb3982f1f48774714\nF test/fts1i.test 6bfe08cdfdced063a39a50c8601da65e6274d879\nF test/fts1j.test e3797475796043a161e348c46a309664cac83f7f\nF test/fts1k.test 65d3b41487b9f738d11b0f00eca375c0ca6bd970\nF test/fts1l.test 15c119ed2362b2b28d5300c0540a6a43eab66c36\nF test/fts1m.test 2d9ca67b095d49f037a914087cc0a61e89da4f0c\nF test/fts1n.test a2317dcd27b1d087ee3878b30e0a59c593c98b7a\nF test/fts1o.test d1554caede42bba2c82fe613bcc921856c196b752449ead0470fac52a20fd3b8\nF test/fts1porter.test d86e9c3e0c7f8ff95add6582b4b585fb4e02b96d\nF test/fts2.test e3fb95f96a650411574efc136f3fb10eef479ed7\nF test/fts2a.test 473a5c8b473a4e21a8e3fddaed1e59666e0c6ab7\nF test/fts2b.test 964abc0236c849c07ca1ae496bb25c268ae94816\nF test/fts2c.test ffb5a35230ac72c4354535c547965ce6824537c0\nF test/fts2d.test b7eaa671ca9a16997f3e5b158ee777ae21052b0b\nF test/fts2e.test 2da13dbc2d009105f42196845c1e1ce136c03d38\nF test/fts2f.test cf84096235991709c1e61caa389632aa0a4f976d\nF test/fts2g.test 3d26fe171bda6133ebf5a380731d70eaa2ef2f6f73d79769cf8946e622b6d597\nF test/fts2h.test 223af921323b409d4b5b18ff4e51619541b174bb\nF test/fts2i.test 1b22451d1f13f7c509baec620dc3a4a754885dd6\nF test/fts2j.test 298fa1670aa21cd445b282d139b70c72e7ade12b\nF test/fts2k.test c7ebf4a4937594aa07459e3e1bca1251c1be8659\nF test/fts2l.test 3333336621524cf7d60bb62d6ef6ab69647866ed\nF test/fts2m.test 4b30142ead6f3ed076e880a2a464064c5ad58c51\nF test/fts2n.test 12b9c5352128cebd1c6b8395e43788d4b09087c2\nF test/fts2o.test 4054ac7433eb5440f1b1d200cfa449342dc4aabd991759139813e17c73e5bf9a\nF test/fts2p.test 4b48c35c91e6a7dbf5ac8d1e5691823cc999aafb\nF test/fts2q.test b2fbbe038b7a31a52a6079b215e71226d8c6a682\nF test/fts2r.test b154c30b63061d8725e320fba1a39e2201cadd5e\nF test/fts2token.test d8070b241a15ff13592a9ae4a8b7c171af6f445a\nF test/fts3.test 672a040ea57036fb4b6fdc09027c18d7d24ab654\nF test/fts3_common.tcl dffad248f9ce090800e272017d2898005c28ee6314fc1dd5550643a02666907a\nF test/fts3aa.test 814d60a1ba30b4a71d8f9306a6564bc7b636dd6efacd2ad80306f9b23ef3ebee\nF test/fts3ab.test 7f6cf260ae80dda064023df8e8e503e9a412b91f\nF test/fts3ac.test 636ed7486043055d4f126a0e385f2d5a82ebbf63\nF test/fts3ad.test e40570cb6f74f059129ad48bcef3d7cbc20dda49\nF test/fts3ae.test ce32a13b34b0260928e4213b4481acf801533bda\nF test/fts3af.test d394978c534eabf22dd0837e718b913fd66b499c\nF test/fts3ag.test c003672a215124df7fc6000036d896f498b26b53\nF test/fts3ah.test dc9f66c32c296f1bc8bcc4535126bddfeca62894\nF test/fts3ai.test 24058fdc6e9e5102c1fd8459591b114b6a85d285\nF test/fts3aj.test 0ed71e1dd9b03b843a857dc3eb9b15630e0104fc\nF test/fts3ak.test bd14deafe9d1586e8e9bf032411026ac4f8c925d\nF test/fts3al.test 07d64326e79bbdbab20ee87fc3328fbf01641c9f\nF test/fts3am.test 218aa6ba0dfc50c7c16b2022aac5c6be593d08d8\nF test/fts3an.test a49ccadc07a2f7d646ec1b81bc09da2d85a85b18\nF test/fts3ao.test 266989148fec6d9f1bb6c5382f7aa3dcea0e9cd444576e28dd2b9287ac7dd220\nF test/fts3atoken.test bef8a163490098a6b8a6ec5f5407269a3a15b9902c0fcf5e962825a81675b3a0\nF test/fts3auto.test bfe0857bd0b69d68dd685a931b58486411a69f5794a7f6d6fe808bfa31a99614\nF test/fts3aux1.test 7a170e172afdbceb67f5baa05941fd4fbf56af42f61daa3d140f4b4bf4cb68f6\nF test/fts3aux2.test 2459e7fa3e22734aed237d1e2ae192f5541c4d8b218956ad2d90754977bf907f\nF test/fts3b.test c15c4a9d04e210d0be67e54ce6a87b927168fbf9c1e3faec8c1a732c366fd491\nF test/fts3c.test fc723a9cf10b397fdfc2b32e73c53c8b1ec02958\nF test/fts3comp1.test a0f5b16a2df44dd0b15751787130af2183167c0c\nF test/fts3conf.test c84bbaec81281c1788aa545ac6e78a6bd6cde2bdbbce2da261690e3659f5a76b\nF test/fts3corrupt.test ce7f7b5eaeee5f1804584d061b978d85e64abf2af9adaa7577589fac6f7eae01\nF test/fts3corrupt2.test bf55c3fa0b0dc8ea1c0fe5543623bd27714585da6a129038fd6999fe3b0d25f3\nF test/fts3corrupt3.test 0d5b69a0998b4adf868cc301fc78f3d0707745f1d984ce044c205cdb764b491f\nF test/fts3corrupt4.test bc90c0f6ee73df4c6bd20f1b32fefdfc00b44cc577d67ebca43b157fc3efd422\nF test/fts3corrupt5.test 0549f85ec4bd22e992f645f13c59b99d652f2f5e643dac75568bfd23a6db7ed5\nF test/fts3cov.test 7eacdbefd756cfa4dc2241974e3db2834e9b372ca215880e00032222f32194cf\nF test/fts3d.test 2bd8c97bcb9975f2334147173b4872505b6a41359a4f9068960a36afe07a679f\nF test/fts3defer.test f4c20e4c7153d20a98ee49ee5f3faef624fefc9a067f8d8d629db380c4d9f1de\nF test/fts3defer2.test 3da52ca2114e300e9971eee2f0cc1a2e5f27e6a9ee67957d49e63e41fdfcc0e7\nF test/fts3defer3.test dd53fc13223c6d8264a98244e9b19abd35ed71cd\nF test/fts3drop.test 1b906e293d6773812587b3dc458cb9e8f3f0c297\nF test/fts3e.test 1f6c6ac9cc8b772ca256e6b22aaeed50c9350851\nF test/fts3expr.test ebae205a7a89446c32583bcd492dcb817b9f6b31819bb4dde2583bb99c77e526\nF test/fts3expr2.test 18da930352e5693eaa163a3eacf96233b7290d1a\nF test/fts3expr3.test c4d4a7d6327418428c96e0a3a1137c251b8dfbf8\nF test/fts3expr4.test f5b2832549f01b1f7f73389fa21d4b875499bc95bf7c8b36271844888c6a0938\nF test/fts3expr5.test a5b9a053becbdb8e973fbf4d6d3abaabeb42d511d1848bd57931f3e0a1cf983e\nF test/fts3fault.test 798e45af84be7978ca33d5bdc94246eb44724db24174b5d8e9b1ac46c57fb08d\nF test/fts3fault2.test 6a17a11d8034b1c4eca9f3091649273d56c49ff049e2173df8060f94341e9da0\nF test/fts3first.test dbdedd20914c8d539aa3206c9b34a23775644641\nF test/fts3fuzz001.test e3c7b0ce9b04cc02281dcc96812a277f02df03cd7dc082055d87e11eb18aaf56\nF test/fts3join.test 949b4f5ae3ae9cc2423cb865d711e32476bdb205ab2be923fdf48246e4a44166\nF test/fts3malloc.test b0e4c133b8d61d4f6d112d8110f8320e9e453ef6\nF test/fts3matchinfo.test aa66cc50615578b30f6df9984819ae5b702511cf8a94251ec7c594096a703a4a\nF test/fts3misc.test c47d2c1ea1351c51c32c688545b02c8180a3f22156d1aedc206a8c09b9d95905\nF test/fts3near.test 7e3354d46f155a822b59c0e957fd2a70c1d7e905\nF test/fts3offsets.test b85fd382abdc78ebce721d8117bd552dfb75094c\nF test/fts3prefix.test fa794eaab0bdae466494947b0b153d7844478ab2\nF test/fts3prefix2.test e1f0a822ca661dced7f12ce392e14eaf65609dce\nF test/fts3query.test ca033ff2ebcc22c69d89032fb0bc1850997d31e7e60ecd26440796ba1654e78f\nF test/fts3rank.test cd99bc83a3c923c8d52afd90d86979cf05fc41849f892faeac3988055ef37b99\nF test/fts3rnd.test 1320d8826a845e38a96e769562bf83d7a92a15d0\nF test/fts3shared.test 57e26a801f21027b7530da77db54286a6fe4997e\nF test/fts3snippet.test 430bb5ace2b31ccd99de4d71775d956da832c114c4b3e39589748f114458647c\nF test/fts3sort.test ed34c716a11cc2009a35210e84ad5f9c102362ca\nF test/fts3tok1.test a663f4cac22a9505400bc22aacb818d7055240409c28729669ea7d4cc2120d15\nF test/fts3tok_err.test 52273cd193b9036282f7bacb43da78c6be87418d\nF test/fts3varint.test 0b84a3fd4eba8a39f3687523804d18f3b322e6d4539a55bf342079c3614f2ada\nF test/fts4aa.test 4338ea7a67f7e19269bf6e6fb4a291352aa32296e7daed87f9823d57016a1ef7\nF test/fts4check.test 6259f856604445d7b684c9b306b2efb6346834c3f50e8fc4a59a2ca6d5319ad0\nF test/fts4content.test 73bbb123420d2c46ef2fb3b24761e9acdb78b0877179d3a5d7d57aada08066f6\nF test/fts4docid.test e33c383cfbdff0284685604d256f347a18fdbf01\nF test/fts4growth.test 289833c34ad45a5e6e6133b53b6a71647231fb89d36ddcb8d9c87211b6721d7f\nF test/fts4growth2.test 13ad4e76451af6e6906c95cdc725d01b00044269\nF test/fts4incr.test 4e353a0bd886ea984e56fce9e77724fc923b8d0d\nF test/fts4langid.test 2168ba330af34f8a1c8832de0aab4c4b6fa195a16419c9c0c8aad59ceb6ff714\nF test/fts4lastrowid.test 185835895948d5325c7710649824042373b2203149abe8024a9319d25234dfd7\nF test/fts4merge.test e2b2ec21e287d54ec09824ccfb41e66896eeca568fc818ba0e0eb2efd94c35d2\nF test/fts4merge2.test 5faa558d1b672f82b847d2a337465fa745e46891\nF test/fts4merge3.test 8d9ccb4a3d41c4c617a149d6c4b13ad02de797d0\nF test/fts4merge4.test d895b1057a7798b67e03455d0fa50e9ea836c47b\nF test/fts4merge5.test 69932d85cda8a1c4dcfb742865900ed8fbda51724b8cf9a45bbe226dfd06c596\nF test/fts4noti.test 5553d7bb2e20bf4a06b23e849352efc022ce6309\nF test/fts4onepass.test d69ddc4ee3415e40b0c5d1d0408488a87614d4f63ba9c44f3e52db541d6b7cc7\nF test/fts4opt.test 0fd0cc84000743ff2a883b9b84b4a5be07249f0ba790c8848a757164cdd46b2a\nF test/fts4record.test a48508f69a84c9287c8019d3a1ae712f5730d8335ffaf8e2101e691d078950bb\nF test/fts4rename.test 15fd9985c2bce6dea20da2245b22029ec89bd4710ed317c4c53abbe3cfd0c880\nF test/fts4umlaut.test fcaca4471de7e78c9d1f7e8976e3e8704d7d8ad979d57a739d00f3f757380429\nF test/fts4unicode.test ceca76422abc251818cb25dabe33d3c3970da5f7c90e1540f190824e6b3a7c95\nF test/full.test 6b3c8fb43c6beab6b95438c1675374b95fab245d\nF test/func.test 7d425f9a6eaa2c50baa751bef6b0c6c6af1751e0e0e1eb4863d426bb4c886788\nF test/func2.test 772d66227e4e6684b86053302e2d74a2500e1e0f\nF test/func3.test 2bb0f31ab7baaed690b962a88544d7be6b34fa389364bc36a44e441ed3e3f1e6\nF test/func4.test 6beacdfcb0e18c358e6c2dcacf1b65d1fa80955f\nF test/func5.test cdd224400bc3e48d891827cc913a57051a426fa4\nF test/func6.test 90e42b64c4f9fb6f04f44cb8a1da586c8542502e926b19c76504fe74ff2a9b7c\nF test/fuzz-oss1.test e58330d01cbbd8215ee636b17a03fe220b37dbfa\nF test/fuzz.test 96083052bf5765e4518c1ba686ce2bab785670d1\nF test/fuzz2.test 76dc35b32b6d6f965259508508abce75a6c4d7e1\nF test/fuzz3.test 9c813e6613b837cb7a277b0383cd66bfa07042b4cf0317157c35852f30043c31\nF test/fuzz4.test c229bcdb45518a89e1d208a21343e061503460ac69fae1539320a89f572eb634\nF test/fuzz_common.tcl a87dfbb88c2a6b08a38e9a070dabd129e617b45b\nF test/fuzz_malloc.test f348276e732e814802e39f042b1f6da6362a610af73a528d8f76898fde6b22f2\nF test/fuzzcheck.c e8cf694f71a1ee39a59f7c2a38c0f8660db0656ce47c8a334b6e9a11f1e66c6d\nF test/fuzzdata1.db d36e88741b4f23bcbaaf55b006290669d03c6c891cf13c7b3a53bc1b097b693f\nF test/fuzzdata2.db 128b3feeb78918d075c9b14b48610145a0dd4c8d6f1ca7c2870c7e425f5bf31f\nF test/fuzzdata3.db c6586d3e3cef0fbc18108f9bb649aa77bfc38aba\nF test/fuzzdata4.db b502c7d5498261715812dd8b3c2005bad08b3a26e6489414bd13926cd3e42ed2\nF test/fuzzdata5.db e35f64af17ec48926481cfaf3b3855e436bd40d1cfe2d59a9474cb4b748a52a5\nF test/fuzzdata6.db 92a80e4afc172c24f662a10a612d188fb272de4a9bd19e017927c95f737de6d7\nF test/fuzzdata7.db e7a86fd83dda151d160445d542e32e5c6019c541b3a74c2a525b6ac640639711\nF test/fuzzdata8.db b45368bbe9f86d40d30603e8f780ac29807cbcc951a18d7a7fd9d0c0e904706e\nF test/fuzzer1.test 3d4c4b7e547aba5e5511a2991e3e3d07166cfbb8\nF test/fuzzer2.test a85ef814ce071293bce1ad8dffa217cbbaad4c14\nF test/fuzzerfault.test 8792cd77fd5bce765b05d0c8e01b9edcf8af8536\nF test/gcfault.test dd28c228a38976d6336a3fc42d7e5f1ad060cb8c\nF test/gencol1.test 037c5c26dddd984ba7ea11bd16996377f72523a4126804b1bbecafc833fccb47\nF test/genesis.tcl 1e2e2e8e5cc4058549a154ff1892fe5c9de19f98\nF test/having.test e4098a4b8962f9596035c3b87a8928a10648acc509f1bb8d6f96413bbf79a1b3\nF test/hexlit.test 4a6a5f46e3c65c4bf1fa06f5dd5a9507a5627751\nF test/hidden.test 23c1393a79e846d68fd902d72c85d5e5dcf98711\nF test/hook.test 1604b3b2f5931430087540404555c1b6be3618600b81558657c66b533ed70b13\nF test/hook2.test b9ff3b8c6519fb67f33192f1afe86e7782ee4ac8\nF test/icu.test 41aa8847745a879b897a7febea0f8f9efc8e67fe8bf680589b6e07c7b0a1569a\nF test/ieee754.test 806fc0ce7f305f57e3331eaceeddcfec9339e607\nF test/imposter1.test c3f1db2d3db2c24611a6596a3fc0ffc14f1466c8\nF test/in.test 3e9bd58597a444123a40a9ac94cae0fec8897e17e9f519b02fc370bcf5ba5175\nF test/in2.test 5d4c61d17493c832f7d2d32bef785119e87bde75\nF test/in3.test 3cbf58c87f4052cee3a58b37b6389777505aa0c0\nF test/in4.test 0f77b0ff371549e6a119d0356be10bdba72258162e9701e83527a560482f5e98\nF test/in5.test b32ce7f4a93f44c5dee94af16886d922cc16ebe33c8e1765c73d4049d0f4b40f\nF test/in6.test 62d943a02f722948f4410ee0b53c3cb39acd7c41afb083df8d7004238fe90a20\nF test/incrblob.test c9b96afc292aeff43d6687bcb09b0280aa599822\nF test/incrblob2.test a494c9e848560039a23974b9119cfc2cf3ad3bd15cc2694ee6367ae537ef8f1f\nF test/incrblob3.test d8d036fde015d4a159cd3cbae9d29003b37227a4\nF test/incrblob4.test 21a52a6843a56cdcce968c6a86b72a7066d0e6ba\nF test/incrblob_err.test 89372a28f1d98254f03fed705f9efcd34ef61a674df16d2dbb4726944a2de5e9\nF test/incrblobfault.test 74dd8ac108304cea0b4a0df6df63a1567e558758\nF test/incrcorrupt.test 6c567fbf870aa9e91866fe52ce6f200cd548939a\nF test/incrvacuum.test 2aaee202b1f230e55779f70d155f6ba67bbdff8481d650214d256ab0f97d4a2b\nF test/incrvacuum2.test 7d26cfda66c7e55898d196de54ac4ec7d86a4e3d\nF test/incrvacuum3.test 75256fb1377e7c39ef2de62bfc42bbff67be295a\nF test/incrvacuum_ioerr.test 6ae2f783424e47a0033304808fe27789cf93e635\nF test/index.test a2e948ed949e575487b5c1d521767d4584ac42d352f2dcd8e48004638e7bc7dc\nF test/index2.test f835d5e13ca163bd78c4459ca15fd2e4ed487407\nF test/index3.test 51685f39345462b84fcf77eb8537af847fdf438cc96b05c45d6aaca4e473ade0\nF test/index4.test ab92e736d5946840236cd61ac3191f91a7856bf6\nF test/index5.test 8621491915800ec274609e42e02a97d67e9b13e7\nF test/index6.test f172653b35b20233e59200e8b92a76db61bf7285437bf777b93b306ba26a47e7\nF test/index7.test 1d764c0cca45f5a76150b08e127ccc8d52492cfa788b5fafed4be784a351b020\nF test/index8.test bc2e3db70e8e62459aaa1bd7e4a9b39664f8f9d7\nF test/index9.test 0aa3e509dddf81f93380396e40e9bb386904c1054924ba8fa9bcdfe85a8e7721\nF test/indexedby.test a52c8c6abfae4fbfb51d99440de4ca1840dbacc606b05e29328a2a8ba7cd914e\nF test/indexexpr1.test 284e119999d132cc8bf37735a928c9859b28e8e295d02b7a6a4f93977c7f9ba5\nF test/indexexpr2.test dba11dbb0a58fcba4cd694f46b4004976123b81b0501f525d43c9be59f0207b1\nF test/indexfault.test 98d78a8ff1f5335628b62f886a1cb7c7dac1ef6d48fa39c51ec871c87dce9811\nF test/init.test 15c823093fdabbf7b531fe22cf037134d09587a7\nF test/insert.test 4e3f0de67aac3c5be1f4aaedbcea11638f1b5cdc9a3115be14d19aa9db7623c6\nF test/insert2.test 4d14b8f1b810a41995f6286b64a6943215d52208\nF test/insert3.test 1b7db95a03ad9c5013fdf7d6722b6cd66ee55e30\nF test/insert4.test fb9e0f752c75f453555990250b449f6d123ae6a3ebf054d14e4470de4498dce3\nF test/insert5.test 394f96728d1258f406fe5f5aeb0aaf29487c39a6\nF test/insertfault.test ac63d14ea3b49c573673a572f4014b9117383a03e497c58f308b5c776e4a7f74\nF test/instr.test 107df2b9b74a4b59315916b575590a08f2a714de0754abe541f10a0971d0a2a4\nF test/instrfault.test 0f870b218ea17cd477bb19ed330eecdb460dd53a\nF test/intarray.test bb976b0b3df0ebb6a2eddfb61768280440e672beba5460ed49679ea984ccf440\nF test/interrupt.test 16ea879ec728cb76414c148c5f24afd5d1f91054\nF test/interrupt2.test e4408ca770a6feafbadb0801e54a0dcd1a8d108d\nF test/intpkey.test ac71107a49a06492b69b82aafaf225400598d3c8\nF test/intreal.test 2a87e85a5949bd55e41ef04c58f5800587c5380bdbc559ff1c79b614b0e6a533\nF test/io.test f95bca1783b01ea7761671560d023360d2dfa4cc\nF test/ioerr.test 470fcc78e9cd352d162baf782fe301ea807d764241f58a48fc58109c2dfcdb6b\nF test/ioerr2.test 2593563599e2cc6b6b4fcf5878b177bdd5d8df26\nF test/ioerr3.test d3cec5e1a11ad6d27527d0d38573fbff14c71bdd\nF test/ioerr4.test f130fe9e71008577b342b8874d52984bd04ede2c\nF test/ioerr5.test 2edfa4fb0f896f733071303b42224df8bedd9da4\nF test/ioerr6.test a395a6ab144b26a9e3e21059a1ab6a7149cca65b\nF test/istrue.test 75327829744e65cc8700e69340b8e6c192e10e39dfae7ccb0e970d3c4f49090a\nF test/join.test f787ee2716efe5beeb9888d10630f917b112c32b6b3e612e48a17ea8aed3a8eb\nF test/join2.test 10f7047e723ebd68b2f47189be8eed20451a6f665d8bf46f1774c640d1062417\nF test/join3.test 6f0c774ff1ba0489e6c88a3e77b9d3528fb4fda0\nF test/join4.test 1a352e4e267114444c29266ce79e941af5885916\nF test/join5.test 3a96dc62f0b45402d7207e22d1993fe0c2fce1c57644a11439891dd62b990eb7\nF test/join6.test cfe6503791ceb0cbb509966740286ec423cbf10b\nF test/journal1.test c7b768041b7f494471531e17abc2f4f5ebf9e5096984f43ed17c4eb80ba34497\nF test/journal2.test 9dac6b4ba0ca79c3b21446bbae993a462c2397c4\nF test/journal3.test 7c3cf23ffc77db06601c1fcfc9743de8441cb77db9d1aa931863d94f5ffa140e\nF test/jrnlmode.test 9b5bc01dac22223cb60ec2d5f97acf568d73820794386de5634dcadbea9e1946\nF test/jrnlmode2.test 8759a1d4657c064637f8b079592651530db738419e1d649c6df7048cd724363d\nF test/jrnlmode3.test 556b447a05be0e0963f4311e95ab1632b11c9eaa\nF test/json101.test bb71538005f2d9e18620bdd3b76839a93ca0be61903eb8d751a64e78cf99b8fb\nF test/json102.test eeb54efa221e50b74a2d6fb9259963b48d7414dca3ce2fdfdeed45cb28487bc1\nF test/json103.test aff6b7a4c17d5a20b487a7bc1a274bfdc63b829413bdfb83bedac42ec7f67e3b\nF test/json104.test 317f4ec4b2d87afbba4d2460cf5be297aea76f2285eb618d276dbcd40a50950f\nF test/json105.test 45f7d6a9a54c85f8a9589b68d3e7a1f42d02f2359911a8cdbad1f9988f571173\nF test/keyword1.test 37ef6bba5d2ed5b07ecdd6810571de2956599dff\nF test/kvtest.c 94da54bb66aae7a54e47cf7e4ea4acecc0f217560f79ad3abfcc0361d6d557ba\nF test/lastinsert.test 42e948fd6442f07d60acbd15d33fb86473e0ef63\nF test/laststmtchanges.test ae613f53819206b3222771828d024154d51db200\nF test/lemon-test01.y 58b764610fd934e189ffbb0bbfa33d171b9cb06019b55bdc04d090d6767e11d7\nF test/like.test 3d702d79bf871fa32985b1ce334294c587e3948d3ab972001e811a58577e8b3c\nF test/like2.test 3b2ee13149ba4a8a60b59756f4e5d345573852da\nF test/like3.test 4f940ad275c006319950054a7a65661f476772171b82b6fdf795e4dda36f246f\nF test/limit.test 0c99a27a87b14c646a9d583c7c89fd06c352663e\nF test/limit2.test 9409b033284642a859fafc95f29a5a6a557bd57c1f0d7c3f554bd64ed69df77e\nF test/loadext.test faa4f6eed07a5aac35d57fdd7bc07f8fc82464cfd327567c10cf0ba3c86cde04\nF test/loadext2.test 0408380b57adca04004247179837a18e866a74f7\nF test/lock.test be4fe08118fb988fed741f429b7dd5d65e1c90db\nF test/lock2.test 5242d8ac4e2d59c403aebff606af449b455aceff\nF test/lock3.test f271375930711ae044080f4fe6d6eda930870d00\nF test/lock4.test 27143363eda1622f03c133efc8db808fc331afd973486cb571ea71cd717d37b8\nF test/lock5.test c6c5e0ebcb21c61a572870cc86c0cb9f14cede38\nF test/lock6.test ad5b387a3a8096afd3c68a55b9535056431b0cf5\nF test/lock7.test 49f1eaff1cdc491cc5dee3669f3c671d9f172431\nF test/lock_common.tcl 2f3f7f2e9637f93ccf609df48ef5b27a50278b6b1cd752b445d52262e5841413\nF test/lookaside.test 5a828e7256f1ee4da8e1bdaa03373a3ccdb0f1ff98dfa82e9b76cb41a45b1083\nF test/main.test 6bbb3999fd461eb8fb335cbab97409a3d7f91bbb8da60635e8be3e4a04a77772\nF test/make-where7.tcl 05c16b5d4f5d6512881dfec560cb793915932ef9\nF test/malloc.test 18dd1c4188c81ca79cf123527c71b19ee0c31feb9947fdffb0dc6ceb1436816a\nF test/malloc3.test 6e88bae6312854a4adb4ecc2a6a5ea8c59b4db778b724ba718e1c43fc8c3c136\nF test/malloc4.test 957337613002b7058a85116493a262f679f3a261\nF test/malloc5.test 2e4ad7684a13389a44a840499cd47173a8d05f22f082d7d083eece433a7a64eb\nF test/malloc6.test 2f039d9821927eacae43e1831f815e157659a151\nF test/malloc7.test 7c68a32942858bc715284856c5507446bba88c3a\nF test/malloc8.test 9b7a3f8cb9cf0b12fff566e80a980b1767bd961d\nF test/malloc9.test 2307c6ee3703b0a21391f3ea92388b4b73f9105e\nF test/mallocA.test aea76f2dd8bcc2d19748f6b911e876cefda74a563753bf26af046e9d34bb97e6\nF test/mallocAll.test 98f1be74bc9f49a858bc4f361fc58e26486798be\nF test/mallocB.test bc475ab850cda896142ab935bbfbc74c24e51ed6\nF test/mallocC.test 3dffe16532f109293ce1ccecd0c31dca55ef08c4\nF test/mallocD.test f78c295e8e18ea3029e65ca08278690e00c22100\nF test/mallocE.test db1ed69d7eded1b080952e2a7c37f364ad241b08\nF test/mallocF.test 2d5c590ebc2fc7f0dcebdf5aa8498b9aed69107e\nF test/mallocG.test 0ff91b65c50bdaba680fb75d87fe4ad35bb7934f\nF test/mallocH.test 79b65aed612c9b3ed2dcdaa727c85895fd1bfbdb\nF test/mallocI.test 6c23a71df077fa5d387be90e7e669c5b368ca38a\nF test/mallocJ.test b5d1839da331d96223e5f458856f8ffe1366f62e\nF test/mallocK.test 1f4b5efbf61715ab79b20b38739ff4b3d110ceb53f54e5db6da1f01c083707ab\nF test/mallocL.test fb311ff80afddf3b1a75e52289081f4754d901dc\nF test/mallocM.test 78bbe9d3da84a5c679123cdb40d7b2010b18fc46e13897e4f253c6ba6fbff134\nF test/malloc_common.tcl aac62499b76be719fac31e7a3e54a7fd53272e7f\nF test/malloctraceviewer.tcl b7a54595270c1d201abf1c3f3d461f27eaf24cdef623ad08a0fe5e411264c8a9\nF test/manydb.test 28385ae2087967aa05c38624cec7d96ec74feb3e\nF test/mem5.test c6460fba403c5703141348cd90de1c294188c68f\nF test/memdb.test c1f2a343ad14398d5d6debda6ea33e80d0dafcc7\nF test/memdb1.test 58d92c2bf622cc5f0f41461e1b35cf64f3f787199544c2c1dada37d88753f9d4\nF test/memleak.test 10b9c6c57e19fc68c32941495e9ba1c50123f6e2\nF test/memsubsys1.test 9e7555a22173b8f1c96c281ce289b338fcba2abe8b157f8798ca195bbf1d347e\nF test/memsubsys2.test 3e4a8d0c05fd3e5fa92017c64666730a520c7e08\nF test/minmax.test 6751e87b409fe11b02e70a306d846fa544e25a41\nF test/minmax2.test 1edf66901ddfab26ae1e04165e8da834c8d3284e2b20aefb26b80ef217962eab\nF test/minmax3.test cc1e8b010136db0d01a6f2a29ba5a9f321034354\nF test/minmax4.test 272ca395257f05937dc96441c9dde4bc9fbf116a8d4fa02baeb0d13d50e36c87\nF test/misc1.test 7ce84b25df9872e7d7878613a96815d2ba5bc974ac4e15a50118dde8f3917599\nF test/misc2.test 00d7de54eda90e237fc9a38b9e5ccc769ebf6d4d\nF test/misc3.test cf3dda47d5dda3e53fc5804a100d3c82be736c9d\nF test/misc4.test 10cd6addb2fa9093df4751a1b92b50440175dd5468a6ec84d0386e78f087db0e\nF test/misc5.test c4aeaa0fa28faa08f2485309c38db4719e6cd1364215d5687a5b96d340a3fa58\nF test/misc6.test 953cc693924d88e6117aeba16f46f0bf5abede91\nF test/misc7.test 4f21954012e4eb0a923c54a311f38c81bf6798ccdd7b51584db46d4007f63daa\nF test/misc8.test 8fb0f31d7a8aed484d759773ab8ad12ec746a477f4a67394a4af0e677494c3ca\nF test/misuse.test 9e7f78402005e833af71dcab32d048003869eca5abcaccc985d4f8dc1d86bcc7\nF test/mjournal.test 28a08d5cb5fb5b5702a46e19176e45e964e0800d1f894677169e79f34030e152\nF test/mmap1.test fb04e0c10492455007624ade884ca0c8852ff3e4e11d95408f9709ca2ef7f626\nF test/mmap2.test 9d6dd9ddb4ad2379f29cc78f38ce1e63ed418022\nF test/mmap3.test b3c297e78e6a8520aafcc1a8f140535594c9086e\nF test/mmap4.test 2e2b4e32555b58da15176e6fe750f17c9dcf7f93\nF test/mmapfault.test d4c9eff9cd8c2dc14bc43e71e042f175b0a26fe3\nF test/mmapwarm.test 2272005969cd17a910077bd5082f70bc1fefad9a875afec7fc9af483898ecaf3\nF test/multiplex.test dc0d67b66f84b484a83cb8bbdf3f0a7f49562ccd\nF test/multiplex2.test 580ca5817c7edbe4cc68fa150609c9473393003a\nF test/multiplex3.test d228f59eac91839a977eac19f21d053f03e4d101\nF test/multiplex4.test e8ae4c4bd70606a5727743241f13b5701990abe4\nF test/mutex1.test ea2cc74d97f077b9e74c84cbd024f14d79a8126f\nF test/mutex2.test bfeaeac2e73095b2ac32285d2756e3a65e681660\nF test/nan.test 437d40e6d0778b050d7750726c0cbd2c9936b81962926e8f8c48ca698f00f4d1\nF test/nockpt.test 8c43b25af63b0bd620cf1b003529e37b6f1dc53bd22690e96a1bd73f78dde53a\nF test/nolock.test f196cf8b8fbea4e2ca345140a2b3f3b0da45c76e\nF test/normalize.test f23b6c5926c59548635fcf39678ac613e726121e073dd902a3062fbb83903b72\nF test/notify1.test 669b2b743618efdc18ca4b02f45423d5d2304abf\nF test/notify2.test 2ecabaa1305083856b7c39cf32816b612740c161\nF test/notify3.test 10ff25cde502e72a92053a2f215d64bece4ef934\nF test/notnull.test a37b663d5bb728d66fc182016613fb8e4a0a4bbf3d75b8876a7527f7d4ed3f18\nF test/null.test 0dcce4f04284ec66108c503327ad6d224c0752b3\nF test/nulls1.test a325e2f2148fb5c82cd5f734e7b60f5fa28f9394c318edf3140f36f57d39930a\nF test/numcast.test 5d126f7f581432e86a90d1e35cac625164aec4a1\nF test/numindex1.test 20a5450d4b056e48cd5db30e659f13347a099823\nF test/offset1.test f06b83657bcf26f9ce805e67450e189e282143b2\nF test/openv2.test 0d3040974bf402e19b7df4b783e447289d7ab394\nF test/optfuzz-db01.c a0c256905c8ac79f9a5de2f374a3d9f757bef0dca2a238dc7c10cc8a38031834\nF test/optfuzz-db01.txt 21f6bdeadc701cf11528276e2a55c70bfcb846ba42df327f979bd9e7b6ce7041\nF test/optfuzz.c 50e330304eb1992e15ddd11f3daaad9bcc0d9aaad09cb2bcc77f9515df2e88b1\nF test/orderby1.test e4501f54721f804ca56922e253403ac6775f88e9f07569994ce99212b3ca5b10\nF test/orderby2.test bc11009f7cd99d96b1b11e57b199b00633eb5b04\nF test/orderby3.test 8619d06a3debdcd80a27c0fdea5c40b468854b99\nF test/orderby4.test 4d39bfbaaa3ae64d026ca2ff166353d2edca4ba4\nF test/orderby5.test 5f4d6cb93cc2f6d3f4228354310a2ce1fbd95d5bbffcba8c6482eeb62a466407\nF test/orderby6.test 8b38138ab0972588240b3fca0985d2e400432859\nF test/orderby7.test 3d1383d52ade5b9eb3a173b3147fdd296f0202da\nF test/orderby8.test 23ef1a5d72bd3adcc2f65561c654295d1b8047bd\nF test/orderby9.test 87fb9548debcc2cd141c5299002dd94672fa76a3\nF test/orderbyA.test df608e59efc2ef50c1eddf1a773b272de3252e9401bfec86d04b52fd973866d5\nF test/oserror.test 1fc9746b83d778e70d115049747ba19c7fba154afce7cc165b09feb6ca6abbc5\nF test/ossfuzz.c 9636dad2092a05a32110df0ca06713038dd0c43dd89a77dabe4b8b0d71096715\nF test/ossshell.c f125c5bd16e537a2549aa579b328dd1c59905e7ab1338dfc210e755bb7b69f17\nF test/ovfl.test 199c482696defceacee8c8e0e0ef36da62726b2f\nF test/pager1.test 1e9ee778bdeaf4f7f09997d029cdaca6a42dfc2092edafe4f5e590acbf1eab13\nF test/pager2.test 67b8f40ae98112bcdba1f2b2d03ea83266418c71\nF test/pager3.test 4e9a83d6ca0838d7c602c9eb93d1357562d9059c1e02ffb138a8271020838370\nF test/pager4.test a122e9e6925d5b23b31e3dfef8c6a44bbf19590e\nF test/pagerfault.test 63c5da625562c66345ab4528790327ca63db2f6f9cbae2aba8cb7c51de3d1628\nF test/pagerfault2.test caf4c7facb914fd3b03a17b31ae2b180c8d6ca1f\nF test/pagerfault3.test 1003fcda009bf48a8e22a516e193b6ef0dd1bbd8\nF test/pageropt.test 84e4cc5cbca285357f7906e99b21be4f2bf5abc0\nF test/pagesize.test 5769fc62d8c890a83a503f67d47508dfdc543305\nF test/parser1.test 6ccdf5e459a5dc4673d3273dc311a7e9742ca952dd0551a6a6320d27035ce4b3\nF test/pcache.test c8acbedd3b6fd0f9a7ca887a83b11d24a007972b\nF test/pcache2.test af7f3deb1a819f77a6d0d81534e97d1cf62cd442\nF test/percentile.test 4243af26b8f3f4555abe166f723715a1f74c77ff\nF test/permutations.test 8587800fe1a0eb01456a3f4500b821e54e3347e78acf11dbf05f4990530f6cee\nF test/pg_common.tcl 222a1bad1c41c308fa366313cd7b51b3be7e9b21c8736a421b974ac941693b54\nF test/pragma.test 59becdfd720b80d463ab750f69f7118fde10dfd556aa5d554f3bf6b7e5ea7533\nF test/pragma2.test e5d5c176360c321344249354c0c16aec46214c9f\nF test/pragma3.test 8300aa9c63cff1027006ca34bf413a148abbd6dcd471fa9a1ded322fe18c0df9\nF test/pragma4.test 10c624e45a83c0096a82a7579a5ff658542391d3b77355192da6572c8c17c00b\nF test/pragma5.test 2be6a44c91e8585ccb4c71c5f221ccebe0692a49557215a912916ed391188959\nF test/pragmafault.test 275edaf3161771d37de60e5c2b412627ac94cef11739236bec12ed1258b240f8\nF test/prefixes.test b524a1c44bffec225b9aec98bd728480352aa8532ac4c15771fb85e8beef65d9\nF test/printf.test 0300699733e53101b2ce48800518427249edd4053bb50fa0621c6607482f0fdb\nF test/printf2.test 30b5dd0b4b992dc5626496846ecce17ff592cacbcb11c3e589f3ac4d7e129dae\nF test/progress.test ebab27f670bd0d4eb9d20d49cef96e68141d92fb\nF test/ptrchng.test ef1aa72d6cf35a2bbd0869a649b744e9d84977fc\nF test/pushdown.test 5e72c51c5e33253ed639ccee1e01ce62d62b6eee5ca893cd82334e4ee7b1d7fc\nF test/queryonly.test 5f653159e0f552f0552d43259890c1089391dcca\nF test/quick.test 1681febc928d686362d50057c642f77a02c62e57\nF test/quota-glob.test 32901e9eed6705d68ca3faee2a06b73b57cb3c26\nF test/quota.test bfb269ce81ea52f593f9648316cd5013d766dd2a\nF test/quota2.test 7dc12e08b11cbc4c16c9ba2aa2e040ea8d8ab4b8\nF test/quote.test 626149eda89ee64d81a3790de370f9f0211921b11568a49c28c861f394330508\nF test/randexpr1.tcl 40dec52119ed3a2b8b2a773bce24b63a3a746459\nF test/randexpr1.test eda062a97e60f9c38ae8d806b03b0ddf23d796df\nF test/rbu.test 168573d353cd0fd10196b87b0caa322c144ef736\nF test/rdonly.test 64e2696c322e3538df0b1ed624e21f9a23ed9ff8\nF test/recover.test ccb8c2623902a92ebb76770edd075cb4f75a4760bb7afde38026572c6e79070d\nF test/regexp1.test 497ea812f264d12b6198d6e50a76be4a1973a9d8\nF test/regexp2.test 40e894223b3d6672655481493f1be12012f2b33c\nF test/reindex.test cd9d6021729910ece82267b4f5e1b5ac2911a7566c43b43c176a6a4732e2118d\nF test/releasetest.tcl fb76d8fcc95ac29d6356cd9e52b726ab9e43a24082897618dfbcb7c2b0049153 x\nF test/releasetest_data.tcl 9919fc6ac5bc92f8878fecfd1840db15999f660a6c9f609240b41aa62b885c88\nF test/resetdb.test 8062cf10a09d8c048f8de7711e94571c38b38168db0e5877ba7561789e5eeb2b\nF test/resolver01.test f4022acafda7f4d40eca94dbf16bc5fc4ac30ceb\nF test/rollback.test 06680159bc6746d0f26276e339e3ae2f951c64812468308838e0a3362d911eaa\nF test/rollback2.test bc868d57899dc6972e2b4483faae0e03365a0556941474eec487ae21d8d38bb6\nF test/rollbackfault.test 0e646aeab8840c399cfbfa43daab46fd609cf04a\nF test/round1.test 768018b04522ca420b1aba8a24bd76091d269f3bce3902af3ec6ebcee41ab21e\nF test/rowallock.test 3f88ec6819489d0b2341c7a7528ae17c053ab7cc\nF test/rowhash.test 0bc1d31415e4575d10cacf31e1a66b5cc0f8be81\nF test/rowid.test bfbd7b97d9267660be3c8f28507c4ed7f205196b8877c0db42df347c2e8845e3\nF test/rowvalue.test c39cc0be5e33f5294fc9224216198d6709d713ea948fdf8f42d89568e97912c9\nF test/rowvalue2.test 060d238b7e5639a7c5630cb5e63e311b44efef2b\nF test/rowvalue3.test 3068f508753af69884b12125995f023da0dbb256\nF test/rowvalue4.test 02e35f7762371c2f57ebd856aa056eac56cb27ef7715a0bb31eac1895a745356\nF test/rowvalue5.test c81c7d8cf36711ab37675ad7376084ae2a359cb6\nF test/rowvalue6.test d19b54feb604d5601f8614b15e214e0774c01087\nF test/rowvalue7.test c1cbdbf407029db01f87764097c6ac02a1c5a37efd2776eff32a9cdfdf6f2dba\nF test/rowvalue8.test 5900eddad9e2c3c2e26f1a95f74aafc1232ee5e0\nF test/rowvalue9.test d8dd2c6ecac432dadaa79e41dc2434f007be1b6b\nF test/rowvaluefault.test 7cd9ccc6c2fbdd881672984087aad0491bb75504\nF test/rowvaluevtab.test d166df5b666662de1ebf40d6f3849f8a76b34e17183a6cc7f81b420c462ce447\nF test/rtree.test 0c8d9dd458d6824e59683c19ab2ffa9ef946f798\nF test/run-wordcount.sh 891e89c4c2d16e629cd45951d4ed899ad12afc09\nF test/savepoint.test 1f8a6b1aea9a0d05837adc463d4bf47bd9d0f1c842f1c2a9caccd639baf34bf9\nF test/savepoint2.test 9b8543940572a2f01a18298c3135ad0c9f4f67d7\nF test/savepoint4.test c8f8159ade6d2acd9128be61e1230f1c1edc6cc0\nF test/savepoint5.test 0735db177e0ebbaedc39812c8d065075d563c4fd\nF test/savepoint6.test f41279c5e137139fa5c21485773332c7adb98cd7\nF test/savepoint7.test cde525ea3075283eb950cdcdefe23ead4f700daa\nF test/savepointfault.test f044eac64b59f09746c7020ee261734de82bf9b2\nF test/scanstatus.test 874e35011779b07725a47dbf1dd6282b0ca04af7e028fb0b534ee544b571be42\nF test/schema.test 5dd11c96ba64744de955315d2e4f8992e447533690153b93377dffb2a5ef5431\nF test/schema2.test 906408621ea881fdb496d878b1822572a34e32c5\nF test/schema3.test 1bc1008e1f8cb5654b248c55f27249366eb7ed38\nF test/schema4.test 3b26c9fa916abb6dadf894137adcf41b7796f7b9\nF test/schema5.test 29699b4421f183c8f0e88bd28ce7d75d13ea653e\nF test/schema6.test e4bd1f23d368695eb9e7b51ef6e02ca0642ea2ab4a52579959826b5e7dce1f9b\nF test/schemafault.test 1936bceca55ac82c5efbcc9fc91a1933e45c8d1e1d106b9a7e56c972a5a2a51e\nF test/securedel.test 2f70b2449186a1921bd01ec9da407fbfa98c3a7a5521854c300c194b2ff09384\nF test/securedel2.test 2d54c28e46eb1fd6902089958b20b1b056c6f1c5\nF test/select1.test 703154cbf66d0a9fbbd5b771dc3d2c4d3700121d133d695958d4a9c5a33251e8\nF test/select2.test 352480e0e9c66eda9c3044e412abdf5be0215b56\nF test/select3.test 3905450067c28766bc83ee397f6d87342de868baa60f2bcfd00f286dfbd62cb9\nF test/select4.test 5389d9895968d1196c457d59b3ee6515d771d328\nF test/select5.test df9ec0d218cedceb4fe7b63262025b547b50a55e59148c6f40b60ca25f1d4546\nF test/select6.test 319d45e414cdd321bf17cfacedaf19e3935ad64dac357c53f1492338c6e9b801\nF test/select7.test f659f231489349e8c5734e610803d7654207318f\nF test/select8.test 8c8f5ae43894c891efc5755ed905467d1d67ad5d\nF test/select9.test aebc2bb0c3bc44606125033cbcaac2c8d1f33a95\nF test/selectA.test b8a590f6493cad5b0bb4dfe1709bf7dcda0b6c40bb4caf32d1e36a89eebc8fc5\nF test/selectB.test 954e4e49cf1f896d61794e440669e03a27ceea25\nF test/selectC.test e25243f8ca503e06f252eb0218976d07cfeceac3\nF test/selectD.test fc20452847a01775710090383cfb4423275d2f745fed61f34fbf37573ac0d214\nF test/selectE.test a8730ca330fcf40ace158f134f4fe0eb00c7edbf\nF test/selectF.test 21c94e6438f76537b72532fa9fd4710cdd455fc3\nF test/selectG.test 089f7d3d7e6db91566f00b036cb353107a2cca6220eb1cb264085a836dae8840\nF test/server1.test c2b00864514a68a0e6fd518659dc95d0050307a357a08969872bef027d785dc4\nF test/session.test 78fa2365e93d3663a6e933f86e7afc395adf18be\nF test/sessionfuzz-data1.db 1f8d5def831f19b1c74571037f0d53a588ea49a6c4ca2a028fc0c27ef896dbcb\nF test/sessionfuzz.c be9c4d4afd359ce80024d8b541b9b8a880510aef5cf263df56fc0e9b947727f1\nF test/shared.test 1826673eb5eb745fb91a3bdac99a7737057742ae38dcb0fe076a384d6727578b\nF test/shared2.test 03eb4a8d372e290107d34b6ce1809919a698e879\nF test/shared3.test ab693f9b6e156b8bfb2a0ad94f29fe69602a5d38\nF test/shared4.test c75f476804e76e26bf6fa0e7b421fb0ca7d07558\nF test/shared6.test 866bb4982c45ce216c61ded5e8fde4e7e2f3ffa9\nF test/shared7.test a81e99f83e6c51b02ac99c96fb3a2a7b5978c956\nF test/shared8.test 933ed7d71f598bb6c7a8c192a3cd30f2562fdccf514df383798599c34ffa672f\nF test/shared9.test 5f2a8f79b4d6c7d107a01ffa1ed05ae7e6333e21\nF test/sharedA.test 49d87ec54ab640fbbc3786ee3c01de94aaa482a3a9f834ad3fe92770eb69e281\nF test/sharedB.test 16cc7178e20965d75278f410943109b77b2e645e\nF test/shared_err.test 32634e404a3317eeb94abc7a099c556a346fdb8fb3858dbe222a4cbb8926a939\nF test/sharedlock.test 5ede3c37439067c43b0198f580fd374ebf15d304\nF test/shell1.test 3c9707dce15e8fdca529503378660f099777d3ddcedccf801a37589a405c5942\nF test/shell2.test e242a9912f44f4c23c3d1d802a83e934e84c853b\nF test/shell3.test ac8c2b744014c3e9a0e26bfd829ab65f00923dc1a91ffd044863e9423cc91494\nF test/shell4.test 1c6aef11daaa2d6830acaba3ac9cbec93fbc1c3d5530743a637f39b3987d08ce\nF test/shell5.test 23939a4c51f0421330ea61dbd3c74f9c215f5f8d3d1a94846da6ffc777a35458\nF test/shell6.test 1ceb51b2678c472ba6cf1e5da96679ce8347889fe2c3bf93a0e0fa73f00b00d3\nF test/shell7.test 115132f66d0463417f408562cc2cf534f6bbc6d83a6d50f0072a9eb171bae97f\nF test/shell8.test 96be02ea0c21f05b24c1883d7b711a1fa8525a68ab7b636aacf6057876941013\nF test/shmlock.test 3dbf017d34ab0c60abe6a44e447d3552154bd0c87b41eaf5ceacd408dd13fda5\nF test/shortread1.test bb591ef20f0fd9ed26d0d12e80eee6d7ac8897a3\nF test/show_speedtest1_rtree.tcl 32e6c5f073d7426148a6936a0408f4b5b169aba5\nF test/shrink.test 1b4330b1fd9e818c04726d45cb28db73087535ce\nF test/sidedelete.test f0ad71abe6233e3b153100f3b8d679b19a488329\nF test/skipscan1.test 2a64ca7b3e6246bb86b47c9051bfd324603b1b60675fe606513535267713e080\nF test/skipscan2.test 3eb703ce794f139e7b83567911046298bcde29606116727f9b700ce34f559d2d\nF test/skipscan3.test ec5bab3f81c7038b43450e7b3062e04a198bdbb5\nF test/skipscan5.test 67817a4b6857c47e0e33ba3e506da6f23ef68de2\nF test/skipscan6.test 0b4cd1b4ac9f84d91454df513c99a4932fa07e8f27b8049bea605068b3e34ac7\nF test/snapshot.test a504f2e7009f512ef66c719f0ea1c55a556bdaf1e1312c80a04d46fc1a3e9632\nF test/snapshot2.test 8d6ff5dd9cc503f6e12d408a30409c3f9c653507b24408d9cd7195931c89bc54\nF test/snapshot3.test 8744313270c55f6e18574283553d3c5c5fe4c5970585663613a0e75c151e599b\nF test/snapshot4.test d4e9347ef2fcabc491fc893506c7bbaf334da3be111d6eb4f3a97cc623b78322\nF test/snapshot_fault.test f6c5ef7cb93bf92fbb4e864ecc5c87df7d3a250064838822db5b4d3a5563ede4\nF test/snapshot_up.test a0a29c4cf33475fcef07c3f8e64af795e24ab91b4cc68295863402a393cdd41c\nF test/soak.test 18944cf21b94a7fe0df02016a6ee1e9632bc4e8d095a0cb49d95e15d5cca2d5c\nF test/softheap1.test 843cd84db9891b2d01b9ab64cef3e9020f98d087\nF test/sort.test c2adc635c2564241fefec0b3a68391ef6868fd3b\nF test/sort2.test cc23b7c19d684657559e8a55b02f7fcee03851d0\nF test/sort3.test 1480ed7c4c157682542224e05e3b75faf4a149e5\nF test/sort4.test 5c34d9623a4ae5921d956dfa2b70e77ed0fc6e5c\nF test/sort5.test 6b43ae0e2169b5ceed441844492e55ba7f1ae0790528395ddf7888ab3094525d\nF test/sorterref.test a13ed207a0eea3c7898f308f979bfb518f68c598ec737d2c494dfd3deaa83506\nF test/sortfault.test d4ccf606a0c77498e2beb542764fd9394acb4d66\nF test/speed1.test f2974a91d79f58507ada01864c0e323093065452\nF test/speed1p.explain d841e650a04728b39e6740296b852dccdca9b2cb\nF test/speed1p.test b180e98609c7677382cf618c0ec9b69f789033a8\nF test/speed2.test 53177056baf6556dcbdcf032bbdfc41c1aa74ded\nF test/speed3.test 694affeb9100526007436334cf7d08f3d74b85ef\nF test/speed4.test abc0ad3399dcf9703abed2fff8705e4f8e416715\nF test/speed4p.explain 6b5f104ebeb34a038b2f714150f51d01143e59aa\nF test/speed4p.test 377a0c48e5a92e0b11c1c5ebb1bc9d83a7312c922bc0cb05970ef5d6a96d1f0c\nF test/speedtest1.c f3bfe3c6a87cbd88e4c4e38005d972bcc1019d1b2fe9569425f86629b11f6c31\nF test/spellfix.test 951a6405d49d1a23d6b78027d3877b4a33eeb8221dcab5704b499755bb4f552e\nF test/spellfix2.test dfc8f519a3fc204cb2dfa8b4f29821ae90f6f8c3\nF test/spellfix3.test 0f9efaaa502a0e0a09848028518a6fb096c8ad33\nF test/spellfix4.test 51c7c26514ade169855c66bcf130bd5acfb4d7fd090cc624645ab275ae6a41fb\nF test/sqldiff1.test 28cd737cf1b0078b1ec1bbf425e674c47785835e\nF test/sqllimits1.test 264f4b0f941800ba139d25e33ee919c5d95fea06dfbe8ac291d6811a30984ca5\nF test/sqllog.test 6af6cb0b09f4e44e1917e06ce85be7670302517a\nF test/stat.test 05669008edc5ed950e817c24e8c4b66840fda64d8c76bae27e5fc1bd23d95675\nF test/statfault.test f525a7bf633e50afd027700e9a486090684b1ac1\nF test/stmt.test 54ed2cc0764bf3e48a058331813c3dbd19fc1d0827c3d8369914a5d8f564ec75\nF test/stmtvtab1.test 6873dfb24f8e79cbb5b799b95c2e4349060eb7a3b811982749a84b359468e2d5\nF test/subjournal.test 8d4e2572c0ee9a15549f0d8e40863161295107e52f07a3e8012a2e1fdd093c49\nF test/subquery.test d7268d193dd33d5505df965399d3a594e76ae13f\nF test/subquery2.test 90cf944b9de8204569cf656028391e4af1ccc8c0cc02d4ef38ee3be8de1ffb12\nF test/subselect.test 0966aa8e720224dbd6a5e769a3ec2a723e332303\nF test/substr.test 18f57c4ca8a598805c4d64e304c418734d843c1a\nF test/subtype1.test 7fe09496352f97053af1437150751be2d0a0cae8\nF test/superlock.test ec94f0556b6488d97f71c79f9061ae08d9ab8f12\nF test/swarmvtab.test 9a3fd5ab3e9b3c976ad1b3d7646aab725114f2ac26b59395d0778b33bab6cdaf\nF test/swarmvtab2.test c948cb2fdfc5b01d85e8f6d6504854202dc1a0782ab2a0ed61538f27cbd0aa5c\nF test/swarmvtab3.test 247aa38b6ebd2b99db2075847ae47e789ac34f1c2ab5c720dfcffd990004c544\nF test/swarmvtabfault.test 8a67a9f27c61073a47990829e92bc0c64420a807cb642b15a25f6c788210ed95\nF test/symlink.test 72b22238d4405ba34df8e60b335d290a3b1129fd5c260835c944c1e4e77288a9\nF test/symlink2.test 9531f475a53d8781c4f81373f87faf2e2aff4f5fb2102ec6386e0c827916a670\nF test/sync.test 89539f4973c010eda5638407e71ca7fddbcd8e0594f4c9980229f804d4333092\nF test/sync2.test 8f9f7d4f6d5be8ca8941a8dadcc4299e558cb6a1ff653a9469146c7a76ef2039\nF test/syscall.test a39d9a36f852ae6e4800f861bc2f2e83f68bbc2112d9399931ecfadeabd2d69d\nF test/sysfault.test c9f2b0d8d677558f74de750c75e12a5454719d04\nF test/tabfunc01.test 5ca6d004157a3e886a55a9387b960cc0db41acd88753eb597ff409ec6cfb1be0\nF test/table.test eb3463b7add9f16a5bb836badf118cf391b809d09fdccd1f79684600d07ec132\nF test/tableapi.test ecbcc29c4ab62c1912c3717c48ea5c5e59f7d64e4a91034e6148bd2b82f177f4\nF test/tableopts.test dba698ba97251017b7c80d738c198d39ab747930\nF test/tclsqlite.test c4a5f5af3672fbe28a0aa322b88d9d1ce2225b6b1284ea11ede2e6d38e7c812c\nF test/tempdb.test 4cdaa23ddd8acb4d79cbb1b68ccdfd09b0537aaba909ca69a876157c2a2cbd08\nF test/tempdb2.test 353864e96fd3ae2f70773d0ffbf8b1fe48589b02c2ec05013b540879410c3440\nF test/tempfault.test 0c0d349c9a99bf5f374655742577f8712c647900\nF test/temptable.test d2c9b87a54147161bcd1822e30c1d1cd891e5b30\nF test/temptable2.test d2940417496e2b9548e01d09990763fbe88c316504033256d51493e1f1a5ce6a\nF test/temptable3.test d11a0974e52b347e45ee54ef1923c91ed91e4637\nF test/temptrigger.test 38f0ca479b1822d3117069e014daabcaacefffcc\nF test/tester.tcl abba168acd7f01dbfa3ffdbf402d151eb97e8a824d9208e845ab34c194441483\nF test/thread001.test b61a29dd87cf669f5f6ac96124a7c97d71b0c80d9012746072055877055cf9ef\nF test/thread002.test e630504f8a06c00bf8bbe68528774dd96aeb2e58\nF test/thread003.test ee4c9efc3b86a6a2767516a37bd64251272560a7\nF test/thread004.test f51dfc3936184aaf73ee85f315224baad272a87f\nF test/thread005.test 50d10b5684399676174bd96c94ad4250b1a2c8b6\nF test/thread1.test df115faa10a4ba1d456e9d4d9ec165016903eae4\nF test/thread2.test f35d2106452b77523b3a2b7d1dcde2e5ee8f9e46\nF test/thread_common.tcl 334639cadcb9f912bf82aa73f49efd5282e6cadd\nF test/threadtest1.c 6029d9c5567db28e6dc908a0c63099c3ba6c383b\nF test/threadtest2.c a70a8e94bef23339d34226eb9521015ef99f4df8\nF test/threadtest3.c 38a612ea62854349ed66372f330a40d73c5cf956\nF test/threadtest4.c c1e67136ceb6c7ec8184e56ac61db28f96bd2925\nF test/time-wordcount.sh 8e0b0f8109367827ad5d58f5cc849705731e4b90\nF test/tkt-02a8e81d44.test 6c80d9c7514e2a42d4918bf87bf6bc54f379110c\nF test/tkt-18458b1a.test 6a62cb1ee50fa3c620da59e3a6f531eb38fceaf7e2166203816b724524e6f1d6\nF test/tkt-26ff0c2d1e.test c15bec890c4d226c0da2f35ff30f9e84c169cfef90e73a8cb5cec11d723dfa96\nF test/tkt-2a5629202f.test 0521bd25658428baa26665aa53ffed9367d33af2\nF test/tkt-2d1a5c67d.test be1326f3061caec85085f4c9ee4490561ca037c0\nF test/tkt-2ea2425d34.test 1cf13e6f75d149b3209a0cb32927a82d3d79fb28\nF test/tkt-31338dca7e.test 6fb8807851964da0d24e942f2e19c7c705b9fb58\nF test/tkt-313723c356.test 4b306ad45c736cedf2f5221f6155b92143244b6d\nF test/tkt-385a5b56b9.test 5204a7cba0e28c99df0acbf95af5e1af4d32965a7a14de6eccebf949607618b1\nF test/tkt-38cb5df375.test f3cc8671f1eb604d4ae9cf886ed4366bec656678\nF test/tkt-3998683a16.test 6d1d04d551ed1704eb3396ca87bb9ccc8c5c1eb7\nF test/tkt-3a77c9714e.test 90e3e8455ee945a4076d4c44062b8845708af24a880355328fe7008f2047c9f0\nF test/tkt-3fe897352e.test 27e26eb0f1811aeba4d65aba43a4c52e99da5e70\nF test/tkt-4a03edc4c8.test 91c0e135888cdc3d4eea82406a44b05c8c1648d0\nF test/tkt-4c86b126f2.test cbcc611becd0396890169ab23102dd70048bbc9a\nF test/tkt-4dd95f6943.test 3d0ce415d2ee15d3d564121960016b9c7be79407\nF test/tkt-4ef7e3cfca.test 3965ae11cc9cf6e334f9d7d3c1e20bf8d56254b1\nF test/tkt-54844eea3f.test a12b851128f46a695e4e378cca67409b9b8f5894\nF test/tkt-5d863f876e.test 726e76d725f6fe0eb2fc8a522b721b79807380ee\nF test/tkt-5e10420e8d.test 904d1687b3c06d43e5b3555bbcf6802e7c0ffd84\nF test/tkt-5ee23731f.test 9db6e1d7209dc0794948b260d6f82b2b1de83a9f\nF test/tkt-6bfb98dfc0.test 24780633627b5cfc0635a5500c2389ebfb563336\nF test/tkt-752e1646fc.test ea78d88d14fe9866bdd991c634483334639e13bf\nF test/tkt-78e04e52ea.test cb44d0f5e7940223be740a39913a1b9b9b30d7e4a17ed3349141f893bae1b8f2\nF test/tkt-7a31705a7e6.test 9e9c057b6a9497c8f7ba7b16871029414ccf6550e7345d9085d6d71c9a56bb6f\nF test/tkt-7bbfb7d442.test 7b2cd79c7a17ae6750e75ec1a7846712a69c9d18\nF test/tkt-80ba201079.test 105a721e6aad0ae3c5946d7615d1e4d03f6145b8\nF test/tkt-80e031a00f.test 9ee36348b761bf7c14261e002b75a4c0d5a04d4c\nF test/tkt-8454a207b9.test c583a9f814a82a2b5ba95207f55001c9f0cd816c\nF test/tkt-868145d012.test a5f941107ece6a64410ca4755c6329b7eb57a356\nF test/tkt-8c63ff0ec.test 258b7fc8d7e4e1cb5362c7d65c143528b9c4cbed\nF test/tkt-91e2e8ba6f.test 08c4f94ae07696b05c9b822da0b4e5337a2f54c5\nF test/tkt-94c04eaadb.test f738c57c7f68ab8be1c054415af7774617cb6223\nF test/tkt-9a8b09f8e6.test b2ef151d0984b2ebf237760dbeaa50724e5a0667\nF test/tkt-9d68c883.test 16f7cb96781ba579bc2e19bb14b4ad609d9774b6\nF test/tkt-9f2eb3abac.test cb6123ac695a08b4454c3792fbe85108f67fabf8\nF test/tkt-a7b7803e.test 159ef554234fa1f9fb318c751b284bd1cf858da4\nF test/tkt-a7debbe0.test e295fa83cd4416a8ca37b354eb5fadefc5e81fb55253db538d35261fe9c95067\nF test/tkt-a8a0d2996a.test 002e1cde8fc30c39611b52cf981c88200b858765748556822da72e0d32fac73e\nF test/tkt-b1d3a2e531.test 8f7576e41ca179289ee1a8fee28386fd8e4b0550\nF test/tkt-b351d95f9.test d14a503c414c5c58fdde3e80f9a3cfef986498c0\nF test/tkt-b72787b1.test a95e8cdad0b98af1853ac7f0afd4ab27b77bf5f3\nF test/tkt-b75a9ca6b0.test ade89229d853a67a21bbd5e6e1e787a8f9d21f19908d1b7fca6bf3d4d5aa0767\nF test/tkt-ba7cbfaedc.test b4c0deccc12aeb55cfdb57935b16b5d67c5a9877\nF test/tkt-bd484a090c.test 60460bf946f79a79712b71f202eda501ca99b898\nF test/tkt-bdc6bbbb38.test fc38bb09bdd440e3513a1f5f98fc60a075182d7d\nF test/tkt-c48d99d690.test ba61977d62ab612fc515b3c488a6fbd6464a2447\nF test/tkt-c694113d5.test 82c461924ada5c14866c47e85535b0b0923ba16a2e907e370061a5ca77f65d77\nF test/tkt-cbd054fa6b.test 708475ef4d730a6853512c8ce363bcbd3becf0e26826e1f4cd46e2f52ff38edf\nF test/tkt-d11f09d36e.test d999b548fef885d1d1afa49a0e8544ecf436869d\nF test/tkt-d635236375.test 9d37e988b47d87505bc9445be0ca447002df5d09\nF test/tkt-d82e3f3721.test bcc0dfba658d15bab30fd4a9320c9e35d214ce30\nF test/tkt-f3e5abed55.test d5a0126118142d13e27f6ce9f4c47096e9321c00\nF test/tkt-f67b41381a.test a23bc124c981662db712167bacd0ed8ad11abac9\nF test/tkt-f777251dc7a.test d1a8fc3eefb7a9e64d19ff24d5c8c94c34a632fb\nF test/tkt-f7b4edec.test d998a08ff2b18b7f62edce8e3044317c45efe6c7\nF test/tkt-f973c7ac31.test 28ef85c7f015477916795246d8286aeda39d4ead\nF test/tkt-fa7bf5ec.test 9102dfea58aa371d78969da735f9392c57e2e035\nF test/tkt-fc62af4523.test 72825d3febdedcd5593a27989fc05accdbfc2bb4\nF test/tkt-fc7bd6358f.test 634bb4af7d661e82d6b61b80c86727bad698e08f\nF test/tkt1435.test f8c52c41de6e5ca02f1845f3a46e18e25cadac00\nF test/tkt1443.test bacc311da5c96a227bf8c167e77a30c99f8e8368\nF test/tkt1444.test a9d72f9e942708bd82dde6c707da61c489e213e9\nF test/tkt1449.test 93584a449752d52b07d2cfc280a69842b6e16ed5\nF test/tkt1473.test 9d000af3e11a4450d4c596f5e58b4b0d24eb0f8b\nF test/tkt1501.test 2064f98e00871848af4b2f517e46c1a7fb2e32db\nF test/tkt1512.test a1df1f66caf0b9122d6220c15dcee230298c2c2f\nF test/tkt1514.test ddef38e34fea72eb1ab935ded9f17a3fb71dd9df\nF test/tkt1536.test 83ff7a7b6e248016f8d682d4f7a4ae114070d466\nF test/tkt1537.test e3a14332de9770be8ff14bd15c19a49cbec10808\nF test/tkt1567.test 52f329386ac77e59260d4af1c58490d61377db20\nF test/tkt1644.test 80b6a2bb17885f3cf1cb886d97cdad13232bb869\nF test/tkt1667.test 4700d931ed19ea3983e8e703becb28079250b460\nF test/tkt1873.test 0e1b8c023050a430c2525179ed4022ddc7c31264\nF test/tkt2141.test f543d96f50d5a5dc0bc744f7db74ea166720ce46\nF test/tkt2192.test ff40157e5f42e65f844255d220fc6b290470942f\nF test/tkt2213.test a9702175601a57b61aba095a233b001d6f362474\nF test/tkt2251.test 5aab8c7898cd2df2a68fe19289cc29e8f5cf8c82\nF test/tkt2285.test cca17be61cf600b397188e77e7143844d2b977e9\nF test/tkt2332.test fc955609b958ca86dfa102832243370a0cc84070\nF test/tkt2339.test 73bd17818924cd2ac442e5fd9916b58565739450\nF test/tkt2391.test ab7a11be7402da8b51a5be603425367aa0684567\nF test/tkt2409.test be0d60e7d283f639dccea4b0b5e1cd3a4851fb5b\nF test/tkt2450.test 77ed94863f2049c1420288ddfea2d41e5e0971d6\nF test/tkt2565.test 8be666e927cb207aae88188f31c331870878b650\nF test/tkt2640.test 28134f5d1e05658ef182520cf0b680fa3de5211b\nF test/tkt2643.test 3f3ebb743da00d4fed4fcf6daed92a0e18e57813\nF test/tkt2686.test 6ee01c9b9e9c48f6d3a1fdd553b1cc4258f903d6\nF test/tkt2767.test 569000d842678f9cf2db7e0d1b27cbc9011381b0\nF test/tkt2817.test f31839e01f4243cff7399ef654d3af3558cb8d8d\nF test/tkt2820.test 39940276b3436d125deb7d8ebeee053e4cf13213\nF test/tkt2822.test f391776423a7c0d0949edfce375708bfb0f3141e\nF test/tkt2832.test a9b0b74a02dca166a04d9e37739c414b10929caa\nF test/tkt2854.test e432965db29e27e16f539b2ba7f502eb2ccc49af\nF test/tkt2920.test a8737380e4ae6424e00c0273dc12775704efbebf\nF test/tkt2927.test 4752868b9eeeb07a217f7f19f4cbaac98d6d086d\nF test/tkt2942.test c5c87d179799ca6d1fbe83c815510b87cd5ec7ce\nF test/tkt3080.test 1bca7579260920a66b4dd7e196e807c0f25ff804\nF test/tkt3093.test fbdbc5b4969244ad11f540759003e361fcaf391f\nF test/tkt3121.test 536df66a02838c26a12fe98639354ca1290ca68b\nF test/tkt3201.test f1500ccecc0d578dc4cde7d3242008297c4d59b3\nF test/tkt3292.test 7bad4423cf5eb075dbb58511d66d46fe816744754c9f0050ae60157f71a4fca7\nF test/tkt3298.test 20fd8773b825cb602e033aa04f8602e1ebdcd93c\nF test/tkt3334.test 9756631e3c4aa3c416362c279e3c0953a83b7ca8274cb81a13264bb56296d8b0\nF test/tkt3346.test 6f67c3ed7db94dfc5df4f5f0b63809a1f611e01a\nF test/tkt3357.test 77c37c6482b526fe89941ce951c22d011f5922ed\nF test/tkt3419.test 1bbf36d7ea03b638c15804251287c2391f5c1f6b\nF test/tkt3424.test 61f831bd2b071bd128fa5d00fbda57e656ca5812\nF test/tkt3442.test a1fc47c669e651d16494de3ff349bcb53281456f2ca02c8bc14220b6044bbfe8\nF test/tkt3457.test 5651e2cbb94645b677ec663160b9e192b87b7d365aecdfb24e19f749575a6fc2\nF test/tkt3461.test 228ea328a5a21e8663f80ee3d212a6ad92549a19\nF test/tkt3493.test 1686cbde85f8721fc1bdc0ee72f2ef2f63139218\nF test/tkt3508.test d75704db9501625c7f7deec119fcaf1696aefb7d\nF test/tkt3522.test 22ce2ebbcb04a6be56c0977d405c207967318fd6\nF test/tkt3527.test 1a6a48441b560bdc53aec581a868eb576234874d\nF test/tkt3541.test 5dc257bde9bc833ab9cc6844bf170b998dbb950a\nF test/tkt3554.test f599967f279077bace39220cbe76085c7b423725\nF test/tkt3581.test 1966b7193f1e3f14951cce8c66907ae69454e9a3\nF test/tkt35xx.test f38c1b03713179d414969187c941466e44945b35\nF test/tkt3630.test 9a934c58c259f89a0ae6bb6bb846c56285a6fd0f\nF test/tkt3718.test 3b59dcb5c4e7754dacd91e7fd353a61492cc402a\nF test/tkt3731.test 0c5f4cbffe102d43c3b2188af91a9e36348f974b\nF test/tkt3757.test 10cd679a88675c880533083fc79ac04324525595\nF test/tkt3761.test b95ea9c98f21cf91325f18a984887e62caceab33\nF test/tkt3762.test 4d439ff7abdc8d9323150269d182c37c2d514576\nF test/tkt3773.test 7bca904d2a647a6a4a291bd86d7fd7c73855b789\nF test/tkt3791.test a6624b9a80b216a26cf473607f42f3e51898c267\nF test/tkt3793.test d90ffd75c52413908d15e1c44fc2ea9c80fcc449\nF test/tkt3810.test 09608d81c63a6ff3aaf7bc70717909c51f5f4048\nF test/tkt3824.test 150aa00bb6220672e5f0eb14dc8eaa36750425f0\nF test/tkt3832.test 2300d10d57562b89875b72148338ac3e14f8847d\nF test/tkt3838.test 292e72489101cd1320d7278dc111c173ebf334d4\nF test/tkt3841.test 4659845bc53f809a5932c61c6ce8c5bb9d6b947f\nF test/tkt3871.test d921703d07c68f4fd5312073215a17fa34b0401d\nF test/tkt3879.test 2ad5bef2c87e9991ce941e054c31abe26ef7fb90\nF test/tkt3911.test 74cd324f3ba653040cc6d94cc4857b290d12d633\nF test/tkt3918.test ea78bf164e4d55cbde0d83c671ef6fbe930a0032\nF test/tkt3922.test f26be40ab4fe6c00795629bd2006d96e270d9b1a\nF test/tkt3929.test cdf67acf5aa936ec4ffead81db87f8a71fe40e59\nF test/tkt3935.test e15261fedb9e30a4305a311da614a5d8e693c767\nF test/tkt3992.test f3e7d548ac26f763b47bc0f750da3d03c81071da\nF test/tkt3997.test a335fa41ca3985660a139df7b734a26ef53284bd\nF test/tkt4018.test 18dbc6617f7a4b90e938d1bd6d26ad18daafaf08\nF test/tokenize.test ce430a7aed48fc98301611429595883fdfcab5d7\nF test/tpch01.test 7c4eb8cdd79c568f46d344b3e789c9fdb8a766d112871352704861f3fca32a2a\nF test/trace.test a659a9862957f4789e37a92b3bf6d2caf5c86b02cdeefc41e850ae53acf6992a\nF test/trace2.test f5cb67ad3bc09e0c58e8cca78dfd0b5639259983\nF test/trace3.test 1dff966888773ff1bfea01c080caf15417892b3f998408fe920c4791f7337144\nF test/trans.test 6e1b4c6a42dba31bd65f8fa5e61a2708e08ddde6\nF test/trans2.test 62bd045bfc7a1c14c5ba83ba64d21ade31583f76\nF test/trans3.test 91a100e5412b488e22a655fe423a14c26403ab94\nF test/transitive1.test 293300f46916569f08875cdb2fe2134be2c27677\nF test/trigger1.test 746dc327e2a0817a22bfc6f5a5e423483d3e77b3733ac20a8fe939e6541b5e53\nF test/trigger2.test d15da46f7012832faf3e0c536b47024409d5fb1722d2bb77e29c06d96d704bb1\nF test/trigger3.test aa640bb2bbb03edd5ff69c055117ea088f121945\nF test/trigger4.test 74700b76ebf3947b2f7a92405141eb2cf2a5d359\nF test/trigger5.test 619391a3e9fc194081d22cefd830d811e7badf83\nF test/trigger6.test 0e411654f122552da6590f0b4e6f781048a4a9b9\nF test/trigger7.test e7ce54bfda67a88d778aea42544e151c465547a7e617127b6914c2221a6d53c1\nF test/trigger8.test 30cb0530bd7c4728055420e3f739aa00412eafa4\nF test/trigger9.test 2226ec795a33b0460ab5cf8891e9054cc7edef41\nF test/triggerA.test 837be862d8721f903dba3f3ceff05b32e0bee5214cf6ea3da5fadf12d3650e9d\nF test/triggerB.test 56780c031b454abac2340dbb3b71ac5c56c3d7fe\nF test/triggerC.test 29f5a28d0fe39e6e2c01f6e1f53f08c0955170ae10a63ad023e33cb0a1682a51\nF test/triggerD.test 8e7f3921a92a5797d472732108109e44575fa650\nF test/triggerE.test ede2e4bce4ba802337bd69d39447fa04a938e06d84a8bfc53c76850fc36ed86d\nF test/triggerF.test 5d76f0a8c428ff87a4d5ed52da06f6096a2c787a1e21b846111dfac4123de3ad\nF test/triggerG.test d5caeef6144ede2426dd13211fd72248241ff2ebc68e12a4c0bf30f5faa21499\nF test/tt3_checkpoint.c 9e75cf7c1c364f52e1c47fd0f14c4340a9db0fe1\nF test/tt3_index.c 39eec10a35f57672225be4d182862152896dee4a\nF test/tt3_lookaside1.c 0377e202c3c2a50d688cb65ba203afeda6fafeb9\nF test/tt3_stress.c c57d804716165811d979d4a719e05baccd79277f\nF test/tt3_vacuum.c 1753f45917699c9c1f66b64c717a717c9379f776\nF test/types.test bf816ce73c7dfcfe26b700c19f97ef4050d194ff\nF test/types2.test 1aeb81976841a91eef292723649b5c4fe3bc3cac\nF test/types3.test 99e009491a54f4dc02c06bdbc0c5eea56ae3e25a\nF test/unionvtab.test e1704ab1b4c1bb3ffc9da4681f8e85a0b909fd80b937984fc94b27415ac8e5a4\nF test/unionvtabfault.test e8759f3d14fb938ce9657e2342db34aeac0fb9bc1692b0d1ebb0069630151d06\nF test/unique.test 93f8b2ef5ea51b9495f8d6493429b1fd0f465264\nF test/unique2.test 3674e9f2a3f1fbbfd4772ac74b7a97090d0f77d2\nF test/unixexcl.test d936ba2b06794018e136418addd59a2354eeae97\nF test/unordered.test ffeea7747d5ba962a8009a20b7e53d68cbae05b063604c68702c5998eb50c981\nF test/update.test 1148de8d913e9817717990603aadeca07aab9ddbb10a30f167cbfd8d3a3ccb60\nF test/update2.test 67455bc61fcbcf96923c45b3bc4f87bc72be7d67575ad35f134906148c7b06d3\nF test/upsert1.test 0b740c8488fd2f5a06ac317c9913f7ef1eda8282f2db58b544b89480c51efab3\nF test/upsert2.test 9c3cdbb1a890227f6504ce4b0e3de68f4cdfa16bb21d8641208a9239896c5a09\nF test/upsert3.test 88d7d590a1948a9cb6eac1b54b0642f67a9f35a1fc0f19b200e97d5d39e3179c\nF test/upsert4.test 25d2a1da92f149331ae0c51ca6e3eee78189577585eab92de149900d62994fa5\nF test/upsertfault.test f21ca47740841fdb4d61acfa7b17646d773e67724fe8c185b71c018db8a94b35\nF test/uri.test 3481026f00ade6dfe8adb7acb6e1e47b04369568\nF test/uri2.test 9d3ba7a53ee167572d53a298ee4a5d38ec4a8fb7\nF test/userauth01.test e740a2697a7b40d7c5003a7d7edaee16acd349a9\nF test/utf16align.test 54cd35a27c005a9b6e7815d887718780b6a462ae\nF test/vacuum-into.test 48f4cec354fb6f27c98ef58d2fe49a11b71ff131af0cd9140efacc9858b9f670\nF test/vacuum.test ce91c39f7f91a4273bf620efad21086b5aa6ef1d\nF test/vacuum2.test aa048abee196c16c9ba308465494009057b79f9b\nF test/vacuum3.test 77ecdd54592b45a0bcb133339f99f1ae0ae94d0d\nF test/vacuum4.test 7ea76b769fffeb41f925303b04cbcf5a5bbeabe55e4c60ae754ff24eeeb7c010\nF test/vacuum5.test 263b144d537e92ad8e9ca8a73cc6e1583f41cfd0dda9432b87f7806174a2f48c\nF test/vacuummem.test 7b42abb3208bd82dd23a7536588396f295a314f2\nF test/varint.test bbce22cda8fc4d135bcc2b589574be8410614e62\nF test/veryquick.test 57ab846bacf7b90cf4e9a672721ea5c5b669b661\nF test/view.test 10ea54300a097d7c0337fd104abffe4a4786d1598b94017a37efe0e0d3e04dd5\nF test/vtab1.test c5d9e90ed02bcacd776dcbb7360199d290f7f53c26b484ddece543060c54319f\nF test/vtab2.test 14d4ab26cee13ba6cf5c5601b158e4f57552d3b055cdd9406cf7f711e9c84082\nF test/vtab3.test b45f47d20f225ccc9c28dc915d92740c2dee311e\nF test/vtab4.test 8e73ed268f3d596bc3590f45fc948fb40f28e9c3\nF test/vtab5.test 889f444970393c73f1e077e2bdc5d845e157a391\nF test/vtab6.test 8e789f526e6594cf7ae933d1adee0caa87dc9f78\nF test/vtab7.test 70c6f4a1d6177144a8236e4172d5fba92e683440374664ad1f04851fbb335d3c\nF test/vtab8.test e19fa4a538fcd1bb66c22825fa8f71618fb13583\nF test/vtab9.test ea58d2b95d61955f87226381716b2d0b1d4e4f9b\nF test/vtabA.test 1317f06a03597eee29f40a49b6c21e1aaba4285f\nF test/vtabB.test 04df5dc531b9f44d9ca65b9c1b79f12b5922a796\nF test/vtabC.test 4528f459a13136f982e75614d120aef165f17292\nF test/vtabD.test 05b3f1d77117271671089e48719524b676842e96\nF test/vtabE.test 2a143fe75a11275781d1fd1988d86b66a3f69cb98f4add62e3da8fd0f637b45f\nF test/vtabF.test 1918844c7c902f6a16c8dacf1ec8f84886d6e78b\nF test/vtabH.test 2efb5a24b0bb50796b21eca23032cfb77abfa4b0c03938e38ce5897abac404ca\nF test/vtabI.test 751b07636700dbdea328e4265b6077ccd6811a3f\nF test/vtabJ.test d7b73675708cf63cfcb9d443bb451fc01a028347275b7311e51f9fdf3ca6757f\nF test/vtab_alter.test 736e66fb5ec7b4fee58229aa3ada2f27ec58bc58c00edae4836890c3784c6783\nF test/vtab_err.test dcc8b7b9cb67522b3fe7a272c73856829dae4ab7fdb30399aea1b6981bda2b65\nF test/vtab_shared.test 5253bff2355a9a3f014c15337da7e177ab0ef8ad\nF test/vtabdrop.test 65d4cf6722972e5499bdaf0c0d70ee3b8133944a4e4bc31862563f32a7edca12\nF test/wal.test cdf0ca6cc0447520d19ef1c83287824ebeb3e82d75af856511ba96841a79fc9b\nF test/wal2.test 537f59e5c5932e3b45bf3591ae3e48a2601360c2e52821b633e222fe6ebd5b09\nF test/wal3.test 2a93004bc0fb2b5c29888964024695bade278ab2\nF test/wal4.test 4744e155cd6299c6bd99d3eab1c82f77db9cdb3c\nF test/wal5.test 9c11da7aeccd83a46d79a556ad11a18d3cb15aa9\nF test/wal6.test b602704e4b066199bc89d91ca9000f335dcf4572\nF test/wal64k.test 2a525c0f45d709bae3765c71045ccec5df7d100ccbd3a7860fdba46c9addb965\nF test/wal7.test 2ae8f427d240099cc4b2dfef63cff44e2a68a1bd\nF test/wal8.test d9df3fba4caad5854ed69ed673c68482514203c8\nF test/wal9.test 378e76a9ad09cd9bee06c172ad3547b0129a6750\nF test/wal_common.tcl a98f17fba96206122eff624db0ab13ec377be4fe\nF test/walbak.test 018d4e5a3d45c6298d11b99f09a8ef6876527946\nF test/walbig.test f437473a16cfb314867c6b5d1dbcd519e73e3434\nF test/walblock.test be48f3a75eff0b4456209f26b3ce186c2015497d\nF test/walcksum.test bb234a1bb42248b3515d992b719708015c384278\nF test/walcrash.test 21038858cc552077b0522f50b0fa87e38139306a\nF test/walcrash2.test a0edab4e5390f03b99a790de89aad15d6ec70b36\nF test/walcrash3.test e426aa58122d20f2b9fbe9a507f9eb8cab85b8af\nF test/walcrash4.test e7b6e7639a950a0cca8e210e248c8dad4d63bf20\nF test/walfault.test 09b8ad7e52d2f54bce50e31aa7ea51412bb9f70ac13c74e669ddcd8b48b0d98d\nF test/walfault2.test e039ac66c78d5561683cacde04097213cdad3b58e2b3f3fe1112862217bfd915\nF test/walhook.test ed00a40ba7255da22d6b66433ab61fab16a63483\nF test/walmode.test cd6e7cff618eaaa5910ce57c3657aa50110397f86213886a2400afb9bfec7b7b\nF test/walnoshm.test 84ca10c544632a756467336b7c3b864d493ee496\nF test/waloverwrite.test dad2f26567f1b45174e54fbf9a8dc1cb876a7f03\nF test/walpersist.test 8c6b7e3ec1ba91b5e4dc4e0921d6d3f87cd356a6\nF test/walprotocol.test a112aba0b79e3adeaa485fed09484b32c654e97df58e454aa8489ac2cd57bf84\nF test/walprotocol2.test 7d3b6b4bf0b12f8007121b1e6ef714bc99101fb3b48e46371df1db868eebc131\nF test/walro.test cb438d05ba0d191f10b688e39c4f0cd5b71569a1d1f4440e5bdf3c6880e08c20\nF test/walro2.test 0e79dd15cbdb4f482c01ea248373669c732414a726b357d04846a816afafb768\nF test/walrofault.test c70cb6e308c443867701856cce92ad8288cd99488fa52afab77cca6cfd51af68\nF test/walshared.test 0befc811dcf0b287efae21612304d15576e35417\nF test/walslow.test c05c68d4dc2700a982f89133ce103a1a84cc285f\nF test/walthread.test 14b20fcfa6ae152f5d8e12f5dc8a8a724b7ef189f5d8ef1e2ceab79f2af51747\nF test/walvfs.test ca81c9f427e0e5434076dfa948fd1d8e6d5ddd192b2fb6991635d81da5f3f5d4\nF test/wapp.tcl b440cd8cf57953d3a49e7ee81e6a18f18efdaf113b69f7d8482b0710a64566ec\nF test/wapptest.tcl 3cca775aede0591756a1fc0da55bbb3715d8c363873fd2cfdd4d555b0a4af57d x\nF test/where.test 19c709c9f0f6ed12c23f909f6592aa55fba34269d5a2898537aa27a22b9ce650\nF test/where2.test 478d2170637b9211f593120648858593bf2445a1\nF test/where3.test 2341a294e17193a6b1699ea7f192124a5286ca6acfcc3f4b06d16c931fbcda2c\nF test/where4.test 4a371bfcc607f41d233701bdec33ac2972908ba8\nF test/where5.test fdf66f96d29a064b63eb543e28da4dfdccd81ad2\nF test/where6.test 5da5a98cec820d488e82708301b96cb8c18a258b\nF test/where7.test 75722434c486ac9e74718caa6cce234f45ba34c0b6c0f9555b29eb8bb5f6ade1\nF test/where8.test 461ca40265ed996a6305da99bb024b0e41602bb586acf544c08f95922358e49f\nF test/where9.test 2c554b97bbdb2fdf26c57099f60db8a52bfcf7c147f2c256f9798fa0e267ca85\nF test/whereA.test 6c6a420ca7d313242f9b1bd471dc80e4d0f8323700ba9c78df0bb843d4daa3b4\nF test/whereB.test 0def95db3bdec220a731c7e4bec5930327c1d8c5\nF test/whereC.test cae295158703cb3fc23bf1a108a9ab730efff0f6\nF test/whereD.test 711d4df58d6d4fb9b3f5ce040b818564198be002\nF test/whereE.test b3a055eef928c992b0a33198a7b8dc10eea5ad2f\nF test/whereF.test 3d9412b1199d3e2bed34fcb76b4c48d0bf4df95d27e3f8dd27b6f8b4716d0d89\nF test/whereG.test 4cda56de49f0c7d9a4f2590a3ddc5f79a7f2a03d2229d0f5bb5d3981ce57f293\nF test/whereH.test e4b07f7a3c2f5d31195cd33710054c78667573b2\nF test/whereI.test a2874062140ed4aba9ffae76e6190a3df6fc73d1373fdfa8fd632945082a5364\nF test/whereJ.test 88287550f6ee604422403b053455b1ad894eeaa5c35d348532dfa1439286cb9a\nF test/whereK.test f8e3cf26a8513ecc7f514f54df9f0572c046c42b\nF test/whereL.test 0a19fc44cd1122040f56c934f1b14d0ca85bde28f270268a428dd9796ea0634c\nF test/wherefault.test 1374c3aa198388925246475f84ad4cd5f9528864\nF test/wherelfault.test 9012e4ef5259058b771606616bd007af5d154e64cc25fa9fd4170f6411db44e3\nF test/wherelimit.test 592081800806d297dd7449b1030c863d2883d6d42901837ccd2e5a9bd962edb0\nF test/wherelimit2.test 9bf0aa56cca40ea0e4c5e2915341355a2bbc0859ec4ce1589197fe2a9d94635f\nF test/win32heap.test 10fd891266bd00af68671e702317726375e5407561d859be1aa04696f2aeee74\nF test/win32lock.test fbf107c91d8f5512be5a5b87c4c42ab9fdd54972\nF test/win32longpath.test 169c75a3b2e43481f4a62122510210c67b08f26d\nF test/win32nolock.test ac4f08811a562e45a5755e661f45ca85892bdbbc\nF test/window1.test b3567fde130dd65fedf56da66a3916cc992e61f910a56b7dac3f71608809faac\nF test/window2.tcl 66db96fd9fd202bc31ee7f8ce7904cb469564864cff3f74e009bfef8102333f4\nF test/window2.test af2a001ded703bb8f2474fb0edfef170d5aba00f5c1f2aa9f65935b5da13df90\nF test/window3.tcl acea6e86a4324a210fd608d06741010ca83ded9fde438341cb978c49928faf03\nF test/window3.test e9959a993c8a71e96433be8daaa1827d78b8921e4f12debd7bdbeb3c856ef3cb\nF test/window4.tcl d732df0e81beedc0ba8a563ade68611d322d27303ad0c0c8e4444107c39e84ec\nF test/window4.test 807f3e6b15f9338e5b9742b87c5c7ca825b42b9657fde6096e890119370848e0\nF test/window5.test d328dd18221217c49c144181975eea17339eaeaf0e9aa558cee3afb84652821e\nF test/window6.test f8d674254b23289cc17c84d79dec7eda7caa1dfb7836c43122cfdf3640d1df32\nF test/window7.tcl 6a1210f05d40ec89c22960213a22cd3f98d4e2f2eb20646c83c8c30d4d76108f\nF test/window7.test 1d31276961ae7801edc72173edaf7593e3cbc79c06d1f1f09e20d8418af403cd\nF test/window8.tcl f2711aa3571e4e6b0dad98db8d95fd6cb8d9db0c92bbdf535f153b07606a1ce2\nF test/window8.test c4331b27a6f66d69fa8f8bab10cc731db1a81d293ae108a68f7c3487fa94e65b\nF test/window9.test b63f6f74d730547e63e78946f951f5d1a7d4e99f91f6d5906305469043d92a15\nF test/windowA.test 6d63dc1260daa17141a55007600581778523a8b420629f1282d2acfc36af23be\nF test/windowB.test 7a983ea1cc1cf72be7f378e4b32f6cb2d73014c5cd8b25aaee825164cd4269e5\nF test/windowerr.tcl f5acd6fbc210d7b5546c0e879d157888455cd4a17a1d3f28f07c1c8a387019e0\nF test/windowerr.test a8b752402109c15aa1c5efe1b93ccb0ce1ef84fa964ae1cd6684dd0b3cc1819b\nF test/windowfault.test a90b397837209f15e54afa62e8be39b2759a0101fae04e05a08bcc50e243a452\nF test/with1.test d32792084dcb5f6c047d77bb8a032822ef9fe050ade07d0aeffa37753a05e3c9\nF test/with2.test e0030e2f0267a910d6c0e4f46f2dfe941c1cc0d4f659ba69b3597728e7e8f1ab\nF test/with3.test 7de8dff2891aca0f9453463e4a2d6eb995baf137827d5596116fee53e22a4e29\nF test/with4.test 257be66c0c67fee1defbbac0f685c3465e2cad037f21ce65f23f86084f198205\nF test/withM.test 693b61765f2b387b5e3e24a4536e2e82de15ff64\nF test/without_rowid1.test 9cfb83705c506e3849fa7efc88a3c9a15f9a50bf9b1516b41757a7cef9bba8c3\nF test/without_rowid2.test af260339f79d13cb220288b67cd287fbcf81ad99\nF test/without_rowid3.test ea4b59dd1b0d7f5f5e4b7cca978cdb905752a9d7c57dc4344a591dba765a3691\nF test/without_rowid4.test 4e08bcbaee0399f35d58b5581881e7a6243d458a\nF test/without_rowid5.test 89b1c587bd92a0590e440da33e7666bf4891572a\nF test/without_rowid6.test 8463b20098e9f75a501a9f17dfb42fffc79068eac0b2775fe56ef2281d2df45e\nF test/without_rowid7.test d7c59a93d726b55812d620f8f284e01904a5b85f9ee9eea8f2f68571a5e8c40e\nF test/wordcount.c d721a4b6fae93e6e33449700bce1686bc23257c27425bc3ef1599dc912adec66\nF test/writecrash.test f1da7f7adfe8d7f09ea79b42e5ca6dcc41102f27f8e334ad71539501ddd910cc\nF test/zeroblob.test 07a5b11ab591d1f26c626945fb7f228f68b993533b2ada77273edf6ee29db174\nF test/zerodamage.test 9c41628db7e8d9e8a0181e59ea5f189df311a9f6ce99cc376dc461f66db6f8dc\nF test/zipfile.test b3b558639f7a103e095713ad0f57fec1fce1b7d60c8054df5789b98f7547a395\nF test/zipfile2.test 9903388a602a3834189857a985106ff95c3bba6a3969e0134127df991889db5d\nF test/zipfilefault.test 44d4d7a7f7cca7521d569d7f71026b241d65a6b1757aa409c1a168827edbbc2c\nF tool/GetFile.cs 47852aa0d806fe47ed1ac5138bdce7f000fe87aaa7f28107d0cb1e26682aeb44\nF tool/GetTclKit.bat 8995df40c4209808b31f24de0b58f90930239a234f7591e3675d45bfbb990c5d\nF tool/Replace.cs 02c67258801c2fb5f63231e0ac0f220b4b36ba91\nF tool/build-all-msvc.bat c12328d06c45fec8baada5949e3d5af54bf8c887 x\nF tool/build-shell.sh 950f47c6174f1eea171319438b93ba67ff5bf367\nF tool/cg_anno.tcl c1f875f5a4c9caca3d59937b16aff716f8b1883935f1b4c9ae23124705bc8099 x\nF tool/checkSpacing.c 810e51703529a204fc4e1eb060e9ab663e3c06d2\nF tool/dbhash.c 19560c9a2aa2b269b6a5108259b93d26d12f8f0877c31fe9f8f61dfbd219ba63\nF tool/dbtotxt.c b2221864a20fb391c46bd31bc1fbdc4a96f5c8a89bef58f421eb9b9c36b1702c\nF tool/dbtotxt.md c9a57af8739957ef36d2cfad5c4b1443ff3688ed33e4901ee200c8b651f43f3c\nF tool/extract-sqlite3h.tcl 069ceab0cee26cba99952bfa08c0b23e35941c837acabe143f0c355d96c9e2eb x\nF tool/extract.c 054069d81b095fbdc189a6f5d4466e40380505e2\nF tool/fast_vacuum.c 5ba0d6f5963a0a63bdc42840f678bad75b2ebce1\nF tool/fragck.tcl 5265a95126abcf6ab357f7efa544787e5963f439\nF tool/fuzzershell.c e1d90a03ca790d7c331c2aae08ca46ff435f1ae1faa6cb9cc48f4687c18fdc6e\nF tool/genfkey.README cf68fddd4643bbe3ff8e31b8b6d8b0a1b85e20f4\nF tool/genfkey.test b6afd7b825d797a1e1274f519ab5695373552ecad5cd373530c63533638a5a4f\nF tool/getlock.c f4c39b651370156cae979501a7b156bdba50e7ce\nF tool/index_usage.c 9ec344d29cbeb03fdc0fce668eedfb7495792170de933adf95cf8d6904a166ad\nF tool/kvtest-speed.sh 4761a9c4b3530907562314d7757995787f7aef8f\nF tool/lemon.c fa7912caf5662ee9b3afc7ff2a2607e81437d603e2f86c88ab412ef43f78fc24\nF tool/lempar.c 34b136b281ae022277738d8b51061237fb330deaa317010d89375117e3a028aa\nF tool/libvers.c caafc3b689638a1d88d44bc5f526c2278760d9b9\nF tool/loadfts.c c3c64e4d5e90e8ba41159232c2189dba4be7b862\nF tool/logest.c 11346aa019e2e77a00902aa7d0cabd27bd2e8cca\nF tool/max-limits.c cbb635fbb37ae4d05f240bfb5b5270bb63c54439\nF tool/mkautoconfamal.sh 422fc365358a2e92876ffc62971a0ff28ed472fc8bcf9de0df921c736fdeca5e\nF tool/mkccode.tcl 86463e68ce9c15d3041610fedd285ce32a5cf7a58fc88b3202b8b76837650dbe x\nF tool/mkctimec.tcl dd183b73ae1c28249669741c250525f0407e579a70482371668fd5f130d9feb3\nF tool/mkkeywordhash.c 27ffc6f6e7e3ecbfc5bca1f1f11a09fc5badf6d67557a5fb2d3b069dbed90617\nF tool/mkmsvcmin.tcl cad0c7b54d7dd92bc87d59f36d4cc4f070eb2e625f14159dc2f5c4204e6a13ea\nF tool/mkopcodec.tcl d1b6362bd3aa80d5520d4d6f3765badf01f6c43c\nF tool/mkopcodeh.tcl 352a4319c0ad869eb26442bf7c3b015aa15594c21f1cce5a6420dbe999367c21\nF tool/mkopts.tcl 680f785fdb09729fd9ac50632413da4eadbdf9071535e3f26d03795828ab07fa\nF tool/mkpragmatab.tcl 70269c7013dab01c5d366b1bb4cee6e42fa1a3a8d179a052d14d6b31f11ad77f\nF tool/mkshellc.tcl 70a9978e363b0f3280ca9ce1c46d72563ff479c1930a12a7375e3881b7325712\nF tool/mksourceid.c 36aa8020014aed0836fd13c51d6dc9219b0df1761d6b5f58ff5b616211b079b9\nF tool/mkspeedsql.tcl a1a334d288f7adfe6e996f2e712becf076745c97\nF tool/mksqlite3c-noext.tcl 4f7cfef5152b0c91920355cbfc1d608a4ad242cb819f1aea07f6d0274f584a7f\nF tool/mksqlite3c.tcl 5fed3d75069d8f66f202d3b5200b0cea4aa7108481acd06732a06fdd42eb83a2\nF tool/mksqlite3h.tcl 080873e3856eceb9d289a08a00c4b30f875ea3feadcbece796bd509b1532792c\nF tool/mksqlite3internalh.tcl eb994013e833359137eb53a55acdad0b5ae1049b\nF tool/mkvsix.tcl b9e0777a213c23156b6542842c238479e496ebf5\nF tool/offsets.c fe4262fdfa378e8f5499a42136d17bf3b98f6091\nF tool/omittest.tcl 27f9413c3343bac200a28d81e8234adb0f5e141c4771893cb19b40235a91f1e0\nF tool/opcodesum.tcl 740ed206ba8c5040018988129abbf3089a0ccf4a\nF tool/pagesig.c ff0ca355fd3c2398e933da5e22439bbff89b803b\nF tool/replace.tcl 60f91e8dd06ab81f74d213ecbd9c9945f32ac048\nF tool/restore_jrnl.tcl 6957a34f8f1f0f8285e07536225ec3b292a9024a\nF tool/rollback-test.c 9fc98427d1e23e84429d7e6d07d9094fbdec65a5\nF tool/run-speed-test.sh f95d19fd669b68c4c38b6b475242841d47c66076\nF tool/showdb.c 97d14a1ce32d5edda84081a5c939bd8975abd89568a773b288940e67e4c7e3ad\nF tool/showjournal.c 5bad7ae8784a43d2b270d953060423b8bd480818\nF tool/showlocks.c 9920bcc64f58378ff1118caead34147201f48c68\nF tool/showshm.c a0ab6ec32dd1f11218ca2a4018f8fb875b59414801ab8ceed8b2e69b7b45a809\nF tool/showstat4.c 0682ebea7abf4d3657f53c4a243f2e7eab48eab344ed36a94bb75dcd19a5c2a1\nF tool/showwal.c ad9d768f96ca6199ad3a8c9562d679680bd032dd01204ea3e5ea6fb931d81847\nF tool/soak1.tcl 8d407956e1a45b485a8e072470a3e629a27037fe\nF tool/spaceanal.tcl 4bfd19aad7eb3ce0372ef0255f58035e0bba4ff5e9acfd763a10c6fb365c8dec\nF tool/speed-check.sh 2b042d703a9472f08c3b13be27afac658426f8e4fc87cd2d575953fda86f08d1\nF tool/speedtest.tcl 06c76698485ccf597b9e7dbb1ac70706eb873355\nF tool/speedtest16.c ecb6542862151c3e6509bbc00509b234562ae81e\nF tool/speedtest2.tcl ee2149167303ba8e95af97873c575c3e0fab58ff\nF tool/speedtest8.c 2902c46588c40b55661e471d7a86e4dd71a18224\nF tool/speedtest8inst1.c 7ce07da76b5e745783e703a834417d725b7d45fd\nF tool/split-sqlite3c.tcl 3efcd4240b738f6bb2b5af0aea7e1e0ef9bc1c61654f645076cec883030b710c\nF tool/sqldiff.c 7b9b7238284f02131dbb8f21a4e862409bff728045c5473139d28c67ac87580e\nF tool/sqlite3_analyzer.c.in 7eeaae8b0d7577662acaabbb11107af0659d1b41bc1dfdd4d91422de27127968\nF tool/sqltclsh.c.in 1bcc2e9da58fadf17b0bf6a50e68c1159e602ce057210b655d50bad5aaaef898\nF tool/sqltclsh.tcl 862f4cf1418df5e1315b5db3b5ebe88969e2a784525af5fbf9596592f14ed848\nF tool/srcck1.c 371de5363b70154012955544f86fdee8f6e5326f\nF tool/stack_usage.tcl f8e71b92cdb099a147dad572375595eae55eca43\nF tool/symbols-mingw.sh 4dbcea7e74768305384c9fd2ed2b41bbf9f0414d\nF tool/symbols.sh 1612bd947750e21e7b47befad5f6b3825b06cce0705441f903bf35ced65ae9b9\nF tool/varint.c 5d94cb5003db9dbbcbcc5df08d66f16071aee003\nF tool/vdbe-compress.tcl 5926c71f9c12d2ab73ef35c29376e756eb68361c\nF tool/vdbe_profile.tcl 246d0da094856d72d2c12efec03250d71639d19f\nF tool/warnings-clang.sh bbf6a1e685e534c92ec2bfba5b1745f34fb6f0bc2a362850723a9ee87c1b31a7\nF tool/warnings.sh 09311479bdc290e20ec8e35a3d1b14b096bbd96222277cfd6274c3a99b3d012f\nF tool/win/sqlite.vsix deb315d026cc8400325c5863eef847784a219a2f\nF vsixtest/App.xaml b76d3b48860e7454775c47ea38ffea9c4abe3e85\nF vsixtest/App.xaml.cpp c465147f50871165c60ca16955219f6c5812d6d8\nF vsixtest/App.xaml.h 4a9768e2983d05600ad1e1c2f1b00a132967da9f\nF vsixtest/Assets/LockScreenLogo.scale-200.png e820c9a3deb909197081b0bf3216c06e13905f0a\nF vsixtest/Assets/SplashScreen.scale-200.png cab70988ca71bebec7bfeb3b6dbafe17b9ab0b4a\nF vsixtest/Assets/Square150x150Logo.scale-200.png e17b40817db7a239fc239d83efcc951fb824e3ff\nF vsixtest/Assets/Square44x44Logo.scale-200.png 2f166237094dea94d952d10b9eeae81806844f1c\nF vsixtest/Assets/Square44x44Logo.targetsize-24_altform-unplated.png 5f6a6d391b95a3061ccca6e6fdd6955ede63b4ed\nF vsixtest/Assets/StoreLogo.png 0828b7257db74a4ecd5eeb6b7b4971f0fdc4d9d1\nF vsixtest/Assets/Wide310x150Logo.scale-200.png 04ddefe5bc5f43ae12a7433f6f236ddab101ac42\nF vsixtest/MainPage.xaml 34f49897e3ca533a7e74506ba0759b66eebce151\nF vsixtest/MainPage.xaml.cpp 7f31fc6de751b64676c0924c97a5485d950a91d7\nF vsixtest/MainPage.xaml.h cc05cca10d50a003f6c6e4448b701cdd07f52f29\nF vsixtest/Package.appxmanifest 6b6db1eb7df3a315c5d681059754d5f0e0c47a93\nF vsixtest/pch.cpp cb823cfac36f1a39a7eb0acbd7e9a0b0de8f23af\nF vsixtest/pch.h 9cab7980f2ac4baa40807d8b5e52af32a21cf78c\nF vsixtest/vsixtest.sln 77cadbe4e96c1fe1bf51cd77de9e9b0a12ada547\nF vsixtest/vsixtest.tcl 6a9a6ab600c25a91a7acc6293828957a386a8a93\nF vsixtest/vsixtest.vcxproj.data 2ed517e100c66dc455b492e1a33350c1b20fbcdc\nF vsixtest/vsixtest.vcxproj.filters 37e51ffedcdb064aad6ff33b6148725226cd608e\nF vsixtest/vsixtest_TemporaryKey.pfx e5b1b036facdb453873e7084e1cae9102ccc67a0\nP 9d75e1ccc72e9f536f45df3b24e9ecd25076cc1f7cf16b806b19e0e1b68e8326\nR 0a0e9aa93d1e91dec7ab207a55b0f9a7\nU dan\nZ 52b4f37e443381d36a712c3afffc572f\n", "c5d44143599f3fe98492b2b900fa3d77925c7be545096251055ceeab899a41f1", "/*\n** 2005 February 15\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This file contains C code routines that used to generate VDBE code\n** that implements the ALTER TABLE command.\n*/\n#include \"sqliteInt.h\"\n\n/*\n** The code in this file only exists if we are not omitting the\n** ALTER TABLE logic from the build.\n*/\n#ifndef SQLITE_OMIT_ALTERTABLE\n\n/*\n** Parameter zName is the name of a table that is about to be altered\n** (either with ALTER TABLE ... RENAME TO or ALTER TABLE ... ADD COLUMN).\n** If the table is a system table, this function leaves an error message\n** in pParse->zErr (system tables may not be altered) and returns non-zero.\n**\n** Or, if zName is not a system table, zero is returned.\n*/\nstatic int isAlterableTable(Parse *pParse, Table *pTab){\n  if( 0==sqlite3StrNICmp(pTab->zName, \"sqlite_\", 7) \n#ifndef SQLITE_OMIT_VIRTUALTABLE\n   || ( (pTab->tabFlags & TF_Shadow)!=0\n        && sqlite3ReadOnlyShadowTables(pParse->db)\n   )\n#endif\n  ){\n    sqlite3ErrorMsg(pParse, \"table %s may not be altered\", pTab->zName);\n    return 1;\n  }\n  return 0;\n}\n\n/*\n** Generate code to verify that the schemas of database zDb and, if\n** bTemp is not true, database \"temp\", can still be parsed. This is\n** called at the end of the generation of an ALTER TABLE ... RENAME ...\n** statement to ensure that the operation has not rendered any schema\n** objects unusable.\n*/\nstatic void renameTestSchema(Parse *pParse, const char *zDb, int bTemp){\n  sqlite3NestedParse(pParse, \n      \"SELECT 1 \"\n      \"FROM \\\"%w\\\".%s \"\n      \"WHERE name NOT LIKE 'sqliteX_%%' ESCAPE 'X'\"\n      \" AND sql NOT LIKE 'create virtual%%'\"\n      \" AND sqlite_rename_test(%Q, sql, type, name, %d)=NULL \",\n      zDb, MASTER_NAME, \n      zDb, bTemp\n  );\n\n  if( bTemp==0 ){\n    sqlite3NestedParse(pParse, \n        \"SELECT 1 \"\n        \"FROM temp.%s \"\n        \"WHERE name NOT LIKE 'sqliteX_%%' ESCAPE 'X'\"\n        \" AND sql NOT LIKE 'create virtual%%'\"\n        \" AND sqlite_rename_test(%Q, sql, type, name, 1)=NULL \",\n        MASTER_NAME, zDb \n    );\n  }\n}\n\n/*\n** Generate code to reload the schema for database iDb. And, if iDb!=1, for\n** the temp database as well.\n*/\nstatic void renameReloadSchema(Parse *pParse, int iDb){\n  Vdbe *v = pParse->pVdbe;\n  if( v ){\n    sqlite3ChangeCookie(pParse, iDb);\n    sqlite3VdbeAddParseSchemaOp(pParse->pVdbe, iDb, 0);\n    if( iDb!=1 ) sqlite3VdbeAddParseSchemaOp(pParse->pVdbe, 1, 0);\n  }\n}\n\n/*\n** Generate code to implement the \"ALTER TABLE xxx RENAME TO yyy\" \n** command. \n*/\nvoid sqlite3AlterRenameTable(\n  Parse *pParse,            /* Parser context. */\n  SrcList *pSrc,            /* The table to rename. */\n  Token *pName              /* The new table name. */\n){\n  int iDb;                  /* Database that contains the table */\n  char *zDb;                /* Name of database iDb */\n  Table *pTab;              /* Table being renamed */\n  char *zName = 0;          /* NULL-terminated version of pName */ \n  sqlite3 *db = pParse->db; /* Database connection */\n  int nTabName;             /* Number of UTF-8 characters in zTabName */\n  const char *zTabName;     /* Original name of the table */\n  Vdbe *v;\n  VTable *pVTab = 0;        /* Non-zero if this is a v-tab with an xRename() */\n  u32 savedDbFlags;         /* Saved value of db->mDbFlags */\n\n  savedDbFlags = db->mDbFlags;  \n  if( NEVER(db->mallocFailed) ) goto exit_rename_table;\n  assert( pSrc->nSrc==1 );\n  assert( sqlite3BtreeHoldsAllMutexes(pParse->db) );\n\n  pTab = sqlite3LocateTableItem(pParse, 0, &pSrc->a[0]);\n  if( !pTab ) goto exit_rename_table;\n  iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);\n  zDb = db->aDb[iDb].zDbSName;\n  db->mDbFlags |= DBFLAG_PreferBuiltin;\n\n  /* Get a NULL terminated version of the new table name. */\n  zName = sqlite3NameFromToken(db, pName);\n  if( !zName ) goto exit_rename_table;\n\n  /* Check that a table or index named 'zName' does not already exist\n  ** in database iDb. If so, this is an error.\n  */\n  if( sqlite3FindTable(db, zName, zDb) || sqlite3FindIndex(db, zName, zDb) ){\n    sqlite3ErrorMsg(pParse, \n        \"there is already another table or index with this name: %s\", zName);\n    goto exit_rename_table;\n  }\n\n  /* Make sure it is not a system table being altered, or a reserved name\n  ** that the table is being renamed to.\n  */\n  if( SQLITE_OK!=isAlterableTable(pParse, pTab) ){\n    goto exit_rename_table;\n  }\n  if( SQLITE_OK!=sqlite3CheckObjectName(pParse,zName,\"table\",zName) ){\n    goto exit_rename_table;\n  }\n\n#ifndef SQLITE_OMIT_VIEW\n  if( pTab->pSelect ){\n    sqlite3ErrorMsg(pParse, \"view %s may not be altered\", pTab->zName);\n    goto exit_rename_table;\n  }\n#endif\n\n#ifndef SQLITE_OMIT_AUTHORIZATION\n  /* Invoke the authorization callback. */\n  if( sqlite3AuthCheck(pParse, SQLITE_ALTER_TABLE, zDb, pTab->zName, 0) ){\n    goto exit_rename_table;\n  }\n#endif\n\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n  if( sqlite3ViewGetColumnNames(pParse, pTab) ){\n    goto exit_rename_table;\n  }\n  if( IsVirtual(pTab) ){\n    pVTab = sqlite3GetVTable(db, pTab);\n    if( pVTab->pVtab->pModule->xRename==0 ){\n      pVTab = 0;\n    }\n  }\n#endif\n\n  /* Begin a transaction for database iDb. Then modify the schema cookie\n  ** (since the ALTER TABLE modifies the schema). Call sqlite3MayAbort(),\n  ** as the scalar functions (e.g. sqlite_rename_table()) invoked by the \n  ** nested SQL may raise an exception.  */\n  v = sqlite3GetVdbe(pParse);\n  if( v==0 ){\n    goto exit_rename_table;\n  }\n  sqlite3MayAbort(pParse);\n\n  /* figure out how many UTF-8 characters are in zName */\n  zTabName = pTab->zName;\n  nTabName = sqlite3Utf8CharLen(zTabName, -1);\n\n  /* Rewrite all CREATE TABLE, INDEX, TRIGGER or VIEW statements in\n  ** the schema to use the new table name.  */\n  sqlite3NestedParse(pParse, \n      \"UPDATE \\\"%w\\\".%s SET \"\n      \"sql = sqlite_rename_table(%Q, type, name, sql, %Q, %Q, %d) \"\n      \"WHERE (type!='index' OR tbl_name=%Q COLLATE nocase)\"\n      \"AND   name NOT LIKE 'sqliteX_%%' ESCAPE 'X'\"\n      , zDb, MASTER_NAME, zDb, zTabName, zName, (iDb==1), zTabName\n  );\n\n  /* Update the tbl_name and name columns of the sqlite_master table\n  ** as required.  */\n  sqlite3NestedParse(pParse,\n      \"UPDATE %Q.%s SET \"\n          \"tbl_name = %Q, \"\n          \"name = CASE \"\n            \"WHEN type='table' THEN %Q \"\n            \"WHEN name LIKE 'sqliteX_autoindex%%' ESCAPE 'X' \"\n            \"     AND type='index' THEN \"\n             \"'sqlite_autoindex_' || %Q || substr(name,%d+18) \"\n            \"ELSE name END \"\n      \"WHERE tbl_name=%Q COLLATE nocase AND \"\n          \"(type='table' OR type='index' OR type='trigger');\", \n      zDb, MASTER_NAME, \n      zName, zName, zName, \n      nTabName, zTabName\n  );\n\n#ifndef SQLITE_OMIT_AUTOINCREMENT\n  /* If the sqlite_sequence table exists in this database, then update \n  ** it with the new table name.\n  */\n  if( sqlite3FindTable(db, \"sqlite_sequence\", zDb) ){\n    sqlite3NestedParse(pParse,\n        \"UPDATE \\\"%w\\\".sqlite_sequence set name = %Q WHERE name = %Q\",\n        zDb, zName, pTab->zName);\n  }\n#endif\n\n  /* If the table being renamed is not itself part of the temp database,\n  ** edit view and trigger definitions within the temp database \n  ** as required.  */\n  if( iDb!=1 ){\n    sqlite3NestedParse(pParse, \n        \"UPDATE sqlite_temp_master SET \"\n            \"sql = sqlite_rename_table(%Q, type, name, sql, %Q, %Q, 1), \"\n            \"tbl_name = \"\n              \"CASE WHEN tbl_name=%Q COLLATE nocase AND \"\n              \"          sqlite_rename_test(%Q, sql, type, name, 1) \"\n              \"THEN %Q ELSE tbl_name END \"\n            \"WHERE type IN ('view', 'trigger')\"\n        , zDb, zTabName, zName, zTabName, zDb, zName);\n  }\n\n  /* If this is a virtual table, invoke the xRename() function if\n  ** one is defined. The xRename() callback will modify the names\n  ** of any resources used by the v-table implementation (including other\n  ** SQLite tables) that are identified by the name of the virtual table.\n  */\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n  if( pVTab ){\n    int i = ++pParse->nMem;\n    sqlite3VdbeLoadString(v, i, zName);\n    sqlite3VdbeAddOp4(v, OP_VRename, i, 0, 0,(const char*)pVTab, P4_VTAB);\n  }\n#endif\n\n  renameReloadSchema(pParse, iDb);\n  renameTestSchema(pParse, zDb, iDb==1);\n\nexit_rename_table:\n  sqlite3SrcListDelete(db, pSrc);\n  sqlite3DbFree(db, zName);\n  db->mDbFlags = savedDbFlags;\n}\n\n/*\n** This function is called after an \"ALTER TABLE ... ADD\" statement\n** has been parsed. Argument pColDef contains the text of the new\n** column definition.\n**\n** The Table structure pParse->pNewTable was extended to include\n** the new column during parsing.\n*/\nvoid sqlite3AlterFinishAddColumn(Parse *pParse, Token *pColDef){\n  Table *pNew;              /* Copy of pParse->pNewTable */\n  Table *pTab;              /* Table being altered */\n  int iDb;                  /* Database number */\n  const char *zDb;          /* Database name */\n  const char *zTab;         /* Table name */\n  char *zCol;               /* Null-terminated column definition */\n  Column *pCol;             /* The new column */\n  Expr *pDflt;              /* Default value for the new column */\n  sqlite3 *db;              /* The database connection; */\n  Vdbe *v;                  /* The prepared statement under construction */\n  int r1;                   /* Temporary registers */\n\n  db = pParse->db;\n  if( pParse->nErr || db->mallocFailed ) return;\n  pNew = pParse->pNewTable;\n  assert( pNew );\n\n  assert( sqlite3BtreeHoldsAllMutexes(db) );\n  iDb = sqlite3SchemaToIndex(db, pNew->pSchema);\n  zDb = db->aDb[iDb].zDbSName;\n  zTab = &pNew->zName[16];  /* Skip the \"sqlite_altertab_\" prefix on the name */\n  pCol = &pNew->aCol[pNew->nCol-1];\n  pDflt = pCol->pDflt;\n  pTab = sqlite3FindTable(db, zTab, zDb);\n  assert( pTab );\n\n#ifndef SQLITE_OMIT_AUTHORIZATION\n  /* Invoke the authorization callback. */\n  if( sqlite3AuthCheck(pParse, SQLITE_ALTER_TABLE, zDb, pTab->zName, 0) ){\n    return;\n  }\n#endif\n\n\n  /* Check that the new column is not specified as PRIMARY KEY or UNIQUE.\n  ** If there is a NOT NULL constraint, then the default value for the\n  ** column must not be NULL.\n  */\n  if( pCol->colFlags & COLFLAG_PRIMKEY ){\n    sqlite3ErrorMsg(pParse, \"Cannot add a PRIMARY KEY column\");\n    return;\n  }\n  if( pNew->pIndex ){\n    sqlite3ErrorMsg(pParse, \"Cannot add a UNIQUE column\");\n    return;\n  }\n  if( (pCol->colFlags & COLFLAG_GENERATED)==0 ){\n    /* If the default value for the new column was specified with a \n    ** literal NULL, then set pDflt to 0. This simplifies checking\n    ** for an SQL NULL default below.\n    */\n    assert( pDflt==0 || pDflt->op==TK_SPAN );\n    if( pDflt && pDflt->pLeft->op==TK_NULL ){\n      pDflt = 0;\n    }\n    if( (db->flags&SQLITE_ForeignKeys) && pNew->pFKey && pDflt ){\n      sqlite3ErrorMsg(pParse, \n          \"Cannot add a REFERENCES column with non-NULL default value\");\n      return;\n    }\n    if( pCol->notNull && !pDflt ){\n      sqlite3ErrorMsg(pParse, \n          \"Cannot add a NOT NULL column with default value NULL\");\n      return;\n    }\n\n    /* Ensure the default expression is something that sqlite3ValueFromExpr()\n    ** can handle (i.e. not CURRENT_TIME etc.)\n    */\n    if( pDflt ){\n      sqlite3_value *pVal = 0;\n      int rc;\n      rc = sqlite3ValueFromExpr(db, pDflt, SQLITE_UTF8, SQLITE_AFF_BLOB, &pVal);\n      assert( rc==SQLITE_OK || rc==SQLITE_NOMEM );\n      if( rc!=SQLITE_OK ){\n        assert( db->mallocFailed == 1 );\n        return;\n      }\n      if( !pVal ){\n        sqlite3ErrorMsg(pParse,\"Cannot add a column with non-constant default\");\n        return;\n      }\n      sqlite3ValueFree(pVal);\n    }\n  }else if( pCol->colFlags & COLFLAG_STORED ){\n    sqlite3ErrorMsg(pParse, \"cannot add a STORED column\");\n    return;\n  }\n\n\n  /* Modify the CREATE TABLE statement. */\n  zCol = sqlite3DbStrNDup(db, (char*)pColDef->z, pColDef->n);\n  if( zCol ){\n    char *zEnd = &zCol[pColDef->n-1];\n    u32 savedDbFlags = db->mDbFlags;\n    while( zEnd>zCol && (*zEnd==';' || sqlite3Isspace(*zEnd)) ){\n      *zEnd-- = '\\0';\n    }\n    db->mDbFlags |= DBFLAG_PreferBuiltin;\n    sqlite3NestedParse(pParse, \n        \"UPDATE \\\"%w\\\".%s SET \"\n          \"sql = substr(sql,1,%d) || ', ' || %Q || substr(sql,%d) \"\n        \"WHERE type = 'table' AND name = %Q\", \n      zDb, MASTER_NAME, pNew->addColOffset, zCol, pNew->addColOffset+1,\n      zTab\n    );\n    sqlite3DbFree(db, zCol);\n    db->mDbFlags = savedDbFlags;\n  }\n\n  /* Make sure the schema version is at least 3.  But do not upgrade\n  ** from less than 3 to 4, as that will corrupt any preexisting DESC\n  ** index.\n  */\n  v = sqlite3GetVdbe(pParse);\n  if( v ){\n    r1 = sqlite3GetTempReg(pParse);\n    sqlite3VdbeAddOp3(v, OP_ReadCookie, iDb, r1, BTREE_FILE_FORMAT);\n    sqlite3VdbeUsesBtree(v, iDb);\n    sqlite3VdbeAddOp2(v, OP_AddImm, r1, -2);\n    sqlite3VdbeAddOp2(v, OP_IfPos, r1, sqlite3VdbeCurrentAddr(v)+2);\n    VdbeCoverage(v);\n    sqlite3VdbeAddOp3(v, OP_SetCookie, iDb, BTREE_FILE_FORMAT, 3);\n    sqlite3ReleaseTempReg(pParse, r1);\n  }\n\n  /* Reload the table definition */\n  renameReloadSchema(pParse, iDb);\n}\n\n/*\n** This function is called by the parser after the table-name in\n** an \"ALTER TABLE <table-name> ADD\" statement is parsed. Argument \n** pSrc is the full-name of the table being altered.\n**\n** This routine makes a (partial) copy of the Table structure\n** for the table being altered and sets Parse.pNewTable to point\n** to it. Routines called by the parser as the column definition\n** is parsed (i.e. sqlite3AddColumn()) add the new Column data to \n** the copy. The copy of the Table structure is deleted by tokenize.c \n** after parsing is finished.\n**\n** Routine sqlite3AlterFinishAddColumn() will be called to complete\n** coding the \"ALTER TABLE ... ADD\" statement.\n*/\nvoid sqlite3AlterBeginAddColumn(Parse *pParse, SrcList *pSrc){\n  Table *pNew;\n  Table *pTab;\n  int iDb;\n  int i;\n  int nAlloc;\n  sqlite3 *db = pParse->db;\n\n  /* Look up the table being altered. */\n  assert( pParse->pNewTable==0 );\n  assert( sqlite3BtreeHoldsAllMutexes(db) );\n  if( db->mallocFailed ) goto exit_begin_add_column;\n  pTab = sqlite3LocateTableItem(pParse, 0, &pSrc->a[0]);\n  if( !pTab ) goto exit_begin_add_column;\n\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n  if( IsVirtual(pTab) ){\n    sqlite3ErrorMsg(pParse, \"virtual tables may not be altered\");\n    goto exit_begin_add_column;\n  }\n#endif\n\n  /* Make sure this is not an attempt to ALTER a view. */\n  if( pTab->pSelect ){\n    sqlite3ErrorMsg(pParse, \"Cannot add a column to a view\");\n    goto exit_begin_add_column;\n  }\n  if( SQLITE_OK!=isAlterableTable(pParse, pTab) ){\n    goto exit_begin_add_column;\n  }\n\n  sqlite3MayAbort(pParse);\n  assert( pTab->addColOffset>0 );\n  iDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n\n  /* Put a copy of the Table struct in Parse.pNewTable for the\n  ** sqlite3AddColumn() function and friends to modify.  But modify\n  ** the name by adding an \"sqlite_altertab_\" prefix.  By adding this\n  ** prefix, we insure that the name will not collide with an existing\n  ** table because user table are not allowed to have the \"sqlite_\"\n  ** prefix on their name.\n  */\n  pNew = (Table*)sqlite3DbMallocZero(db, sizeof(Table));\n  if( !pNew ) goto exit_begin_add_column;\n  pParse->pNewTable = pNew;\n  pNew->nTabRef = 1;\n  pNew->nCol = pTab->nCol;\n  assert( pNew->nCol>0 );\n  nAlloc = (((pNew->nCol-1)/8)*8)+8;\n  assert( nAlloc>=pNew->nCol && nAlloc%8==0 && nAlloc-pNew->nCol<8 );\n  pNew->aCol = (Column*)sqlite3DbMallocZero(db, sizeof(Column)*nAlloc);\n  pNew->zName = sqlite3MPrintf(db, \"sqlite_altertab_%s\", pTab->zName);\n  if( !pNew->aCol || !pNew->zName ){\n    assert( db->mallocFailed );\n    goto exit_begin_add_column;\n  }\n  memcpy(pNew->aCol, pTab->aCol, sizeof(Column)*pNew->nCol);\n  for(i=0; i<pNew->nCol; i++){\n    Column *pCol = &pNew->aCol[i];\n    pCol->zName = sqlite3DbStrDup(db, pCol->zName);\n    pCol->zColl = 0;\n    pCol->pDflt = 0;\n  }\n  pNew->pSchema = db->aDb[iDb].pSchema;\n  pNew->addColOffset = pTab->addColOffset;\n  pNew->nTabRef = 1;\n\nexit_begin_add_column:\n  sqlite3SrcListDelete(db, pSrc);\n  return;\n}\n\n/*\n** Parameter pTab is the subject of an ALTER TABLE ... RENAME COLUMN\n** command. This function checks if the table is a view or virtual\n** table (columns of views or virtual tables may not be renamed). If so,\n** it loads an error message into pParse and returns non-zero.\n**\n** Or, if pTab is not a view or virtual table, zero is returned.\n*/\n#if !defined(SQLITE_OMIT_VIEW) || !defined(SQLITE_OMIT_VIRTUALTABLE)\nstatic int isRealTable(Parse *pParse, Table *pTab){\n  const char *zType = 0;\n#ifndef SQLITE_OMIT_VIEW\n  if( pTab->pSelect ){\n    zType = \"view\";\n  }\n#endif\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n  if( IsVirtual(pTab) ){\n    zType = \"virtual table\";\n  }\n#endif\n  if( zType ){\n    sqlite3ErrorMsg(\n        pParse, \"cannot rename columns of %s \\\"%s\\\"\", zType, pTab->zName\n    );\n    return 1;\n  }\n  return 0;\n}\n#else /* !defined(SQLITE_OMIT_VIEW) || !defined(SQLITE_OMIT_VIRTUALTABLE) */\n# define isRealTable(x,y) (0)\n#endif\n\n/*\n** Handles the following parser reduction:\n**\n**  cmd ::= ALTER TABLE pSrc RENAME COLUMN pOld TO pNew\n*/\nvoid sqlite3AlterRenameColumn(\n  Parse *pParse,                  /* Parsing context */\n  SrcList *pSrc,                  /* Table being altered.  pSrc->nSrc==1 */\n  Token *pOld,                    /* Name of column being changed */\n  Token *pNew                     /* New column name */\n){\n  sqlite3 *db = pParse->db;       /* Database connection */\n  Table *pTab;                    /* Table being updated */\n  int iCol;                       /* Index of column being renamed */\n  char *zOld = 0;                 /* Old column name */\n  char *zNew = 0;                 /* New column name */\n  const char *zDb;                /* Name of schema containing the table */\n  int iSchema;                    /* Index of the schema */\n  int bQuote;                     /* True to quote the new name */\n\n  /* Locate the table to be altered */\n  pTab = sqlite3LocateTableItem(pParse, 0, &pSrc->a[0]);\n  if( !pTab ) goto exit_rename_column;\n\n  /* Cannot alter a system table */\n  if( SQLITE_OK!=isAlterableTable(pParse, pTab) ) goto exit_rename_column;\n  if( SQLITE_OK!=isRealTable(pParse, pTab) ) goto exit_rename_column;\n\n  /* Which schema holds the table to be altered */  \n  iSchema = sqlite3SchemaToIndex(db, pTab->pSchema);\n  assert( iSchema>=0 );\n  zDb = db->aDb[iSchema].zDbSName;\n\n#ifndef SQLITE_OMIT_AUTHORIZATION\n  /* Invoke the authorization callback. */\n  if( sqlite3AuthCheck(pParse, SQLITE_ALTER_TABLE, zDb, pTab->zName, 0) ){\n    goto exit_rename_column;\n  }\n#endif\n\n  /* Make sure the old name really is a column name in the table to be\n  ** altered.  Set iCol to be the index of the column being renamed */\n  zOld = sqlite3NameFromToken(db, pOld);\n  if( !zOld ) goto exit_rename_column;\n  for(iCol=0; iCol<pTab->nCol; iCol++){\n    if( 0==sqlite3StrICmp(pTab->aCol[iCol].zName, zOld) ) break;\n  }\n  if( iCol==pTab->nCol ){\n    sqlite3ErrorMsg(pParse, \"no such column: \\\"%s\\\"\", zOld);\n    goto exit_rename_column;\n  }\n\n  /* Do the rename operation using a recursive UPDATE statement that\n  ** uses the sqlite_rename_column() SQL function to compute the new\n  ** CREATE statement text for the sqlite_master table.\n  */\n  sqlite3MayAbort(pParse);\n  zNew = sqlite3NameFromToken(db, pNew);\n  if( !zNew ) goto exit_rename_column;\n  assert( pNew->n>0 );\n  bQuote = sqlite3Isquote(pNew->z[0]);\n  sqlite3NestedParse(pParse, \n      \"UPDATE \\\"%w\\\".%s SET \"\n      \"sql = sqlite_rename_column(sql, type, name, %Q, %Q, %d, %Q, %d, %d) \"\n      \"WHERE name NOT LIKE 'sqliteX_%%' ESCAPE 'X' \"\n      \" AND (type != 'index' OR tbl_name = %Q)\"\n      \" AND sql NOT LIKE 'create virtual%%'\",\n      zDb, MASTER_NAME, \n      zDb, pTab->zName, iCol, zNew, bQuote, iSchema==1,\n      pTab->zName\n  );\n\n  sqlite3NestedParse(pParse, \n      \"UPDATE temp.%s SET \"\n      \"sql = sqlite_rename_column(sql, type, name, %Q, %Q, %d, %Q, %d, 1) \"\n      \"WHERE type IN ('trigger', 'view')\",\n      MASTER_NAME, \n      zDb, pTab->zName, iCol, zNew, bQuote\n  );\n\n  /* Drop and reload the database schema. */\n  renameReloadSchema(pParse, iSchema);\n  renameTestSchema(pParse, zDb, iSchema==1);\n\n exit_rename_column:\n  sqlite3SrcListDelete(db, pSrc);\n  sqlite3DbFree(db, zOld);\n  sqlite3DbFree(db, zNew);\n  return;\n}\n\n/*\n** Each RenameToken object maps an element of the parse tree into\n** the token that generated that element.  The parse tree element\n** might be one of:\n**\n**     *  A pointer to an Expr that represents an ID\n**     *  The name of a table column in Column.zName\n**\n** A list of RenameToken objects can be constructed during parsing.\n** Each new object is created by sqlite3RenameTokenMap().\n** As the parse tree is transformed, the sqlite3RenameTokenRemap()\n** routine is used to keep the mapping current.\n**\n** After the parse finishes, renameTokenFind() routine can be used\n** to look up the actual token value that created some element in\n** the parse tree.\n*/\nstruct RenameToken {\n  void *p;               /* Parse tree element created by token t */\n  Token t;               /* The token that created parse tree element p */\n  RenameToken *pNext;    /* Next is a list of all RenameToken objects */\n};\n\n/*\n** The context of an ALTER TABLE RENAME COLUMN operation that gets passed\n** down into the Walker.\n*/\ntypedef struct RenameCtx RenameCtx;\nstruct RenameCtx {\n  RenameToken *pList;             /* List of tokens to overwrite */\n  int nList;                      /* Number of tokens in pList */\n  int iCol;                       /* Index of column being renamed */\n  Table *pTab;                    /* Table being ALTERed */ \n  const char *zOld;               /* Old column name */\n};\n\n#ifdef SQLITE_DEBUG\n/*\n** This function is only for debugging. It performs two tasks:\n**\n**   1. Checks that pointer pPtr does not already appear in the \n**      rename-token list.\n**\n**   2. Dereferences each pointer in the rename-token list.\n**\n** The second is most effective when debugging under valgrind or\n** address-sanitizer or similar. If any of these pointers no longer \n** point to valid objects, an exception is raised by the memory-checking \n** tool.\n**\n** The point of this is to prevent comparisons of invalid pointer values.\n** Even though this always seems to work, it is undefined according to the\n** C standard. Example of undefined comparison:\n**\n**     sqlite3_free(x);\n**     if( x==y ) ...\n**\n** Technically, as x no longer points into a valid object or to the byte\n** following a valid object, it may not be used in comparison operations.\n*/\nstatic void renameTokenCheckAll(Parse *pParse, void *pPtr){\n  if( pParse->nErr==0 && pParse->db->mallocFailed==0 ){\n    RenameToken *p;\n    u8 i = 0;\n    for(p=pParse->pRename; p; p=p->pNext){\n      if( p->p ){\n        assert( p->p!=pPtr );\n        i += *(u8*)(p->p);\n      }\n    }\n  }\n}\n#else\n# define renameTokenCheckAll(x,y)\n#endif\n\n/*\n** Remember that the parser tree element pPtr was created using\n** the token pToken.\n**\n** In other words, construct a new RenameToken object and add it\n** to the list of RenameToken objects currently being built up\n** in pParse->pRename.\n**\n** The pPtr argument is returned so that this routine can be used\n** with tail recursion in tokenExpr() routine, for a small performance\n** improvement.\n*/\nvoid *sqlite3RenameTokenMap(Parse *pParse, void *pPtr, Token *pToken){\n  RenameToken *pNew;\n  assert( pPtr || pParse->db->mallocFailed );\n  renameTokenCheckAll(pParse, pPtr);\n  if( pParse->eParseMode!=PARSE_MODE_UNMAP ){\n    pNew = sqlite3DbMallocZero(pParse->db, sizeof(RenameToken));\n    if( pNew ){\n      pNew->p = pPtr;\n      pNew->t = *pToken;\n      pNew->pNext = pParse->pRename;\n      pParse->pRename = pNew;\n    }\n  }\n\n  return pPtr;\n}\n\n/*\n** It is assumed that there is already a RenameToken object associated\n** with parse tree element pFrom. This function remaps the associated token\n** to parse tree element pTo.\n*/\nvoid sqlite3RenameTokenRemap(Parse *pParse, void *pTo, void *pFrom){\n  RenameToken *p;\n  renameTokenCheckAll(pParse, pTo);\n  for(p=pParse->pRename; p; p=p->pNext){\n    if( p->p==pFrom ){\n      p->p = pTo;\n      break;\n    }\n  }\n}\n\n/*\n** Walker callback used by sqlite3RenameExprUnmap().\n*/\nstatic int renameUnmapExprCb(Walker *pWalker, Expr *pExpr){\n  Parse *pParse = pWalker->pParse;\n  sqlite3RenameTokenRemap(pParse, 0, (void*)pExpr);\n  return WRC_Continue;\n}\n\n/*\n** Iterate through the Select objects that are part of WITH clauses attached\n** to select statement pSelect.\n*/\nstatic void renameWalkWith(Walker *pWalker, Select *pSelect){\n  if( pSelect->pWith ){\n    int i;\n    for(i=0; i<pSelect->pWith->nCte; i++){\n      Select *p = pSelect->pWith->a[i].pSelect;\n      NameContext sNC;\n      memset(&sNC, 0, sizeof(sNC));\n      sNC.pParse = pWalker->pParse;\n      sqlite3SelectPrep(sNC.pParse, p, &sNC);\n      sqlite3WalkSelect(pWalker, p);\n    }\n  }\n}\n\n/*\n** Walker callback used by sqlite3RenameExprUnmap().\n*/\nstatic int renameUnmapSelectCb(Walker *pWalker, Select *p){\n  Parse *pParse = pWalker->pParse;\n  int i;\n  if( pParse->nErr ) return WRC_Abort;\n  if( ALWAYS(p->pEList) ){\n    ExprList *pList = p->pEList;\n    for(i=0; i<pList->nExpr; i++){\n      if( pList->a[i].zName ){\n        sqlite3RenameTokenRemap(pParse, 0, (void*)pList->a[i].zName);\n      }\n    }\n  }\n  if( ALWAYS(p->pSrc) ){  /* Every Select as a SrcList, even if it is empty */\n    SrcList *pSrc = p->pSrc;\n    for(i=0; i<pSrc->nSrc; i++){\n      sqlite3RenameTokenRemap(pParse, 0, (void*)pSrc->a[i].zName);\n    }\n  }\n\n  renameWalkWith(pWalker, p);\n  return WRC_Continue;\n}\n\n/*\n** Remove all nodes that are part of expression pExpr from the rename list.\n*/\nvoid sqlite3RenameExprUnmap(Parse *pParse, Expr *pExpr){\n  u8 eMode = pParse->eParseMode;\n  Walker sWalker;\n  memset(&sWalker, 0, sizeof(Walker));\n  sWalker.pParse = pParse;\n  sWalker.xExprCallback = renameUnmapExprCb;\n  sWalker.xSelectCallback = renameUnmapSelectCb;\n  pParse->eParseMode = PARSE_MODE_UNMAP;\n  sqlite3WalkExpr(&sWalker, pExpr);\n  pParse->eParseMode = eMode;\n}\n\n/*\n** Remove all nodes that are part of expression-list pEList from the \n** rename list.\n*/\nvoid sqlite3RenameExprlistUnmap(Parse *pParse, ExprList *pEList){\n  if( pEList ){\n    int i;\n    Walker sWalker;\n    memset(&sWalker, 0, sizeof(Walker));\n    sWalker.pParse = pParse;\n    sWalker.xExprCallback = renameUnmapExprCb;\n    sqlite3WalkExprList(&sWalker, pEList);\n    for(i=0; i<pEList->nExpr; i++){\n      sqlite3RenameTokenRemap(pParse, 0, (void*)pEList->a[i].zName);\n    }\n  }\n}\n\n/*\n** Free the list of RenameToken objects given in the second argument\n*/\nstatic void renameTokenFree(sqlite3 *db, RenameToken *pToken){\n  RenameToken *pNext;\n  RenameToken *p;\n  for(p=pToken; p; p=pNext){\n    pNext = p->pNext;\n    sqlite3DbFree(db, p);\n  }\n}\n\n/*\n** Search the Parse object passed as the first argument for a RenameToken\n** object associated with parse tree element pPtr. If found, remove it\n** from the Parse object and add it to the list maintained by the\n** RenameCtx object passed as the second argument.\n*/\nstatic void renameTokenFind(Parse *pParse, struct RenameCtx *pCtx, void *pPtr){\n  RenameToken **pp;\n  assert( pPtr!=0 );\n  for(pp=&pParse->pRename; (*pp); pp=&(*pp)->pNext){\n    if( (*pp)->p==pPtr ){\n      RenameToken *pToken = *pp;\n      *pp = pToken->pNext;\n      pToken->pNext = pCtx->pList;\n      pCtx->pList = pToken;\n      pCtx->nList++;\n      break;\n    }\n  }\n}\n\n/*\n** This is a Walker select callback. It does nothing. It is only required\n** because without a dummy callback, sqlite3WalkExpr() and similar do not\n** descend into sub-select statements.\n*/\nstatic int renameColumnSelectCb(Walker *pWalker, Select *p){\n  renameWalkWith(pWalker, p);\n  return WRC_Continue;\n}\n\n/*\n** This is a Walker expression callback.\n**\n** For every TK_COLUMN node in the expression tree, search to see\n** if the column being references is the column being renamed by an\n** ALTER TABLE statement.  If it is, then attach its associated\n** RenameToken object to the list of RenameToken objects being\n** constructed in RenameCtx object at pWalker->u.pRename.\n*/\nstatic int renameColumnExprCb(Walker *pWalker, Expr *pExpr){\n  RenameCtx *p = pWalker->u.pRename;\n  if( pExpr->op==TK_TRIGGER \n   && pExpr->iColumn==p->iCol \n   && pWalker->pParse->pTriggerTab==p->pTab\n  ){\n    renameTokenFind(pWalker->pParse, p, (void*)pExpr);\n  }else if( pExpr->op==TK_COLUMN \n   && pExpr->iColumn==p->iCol \n   && p->pTab==pExpr->y.pTab\n  ){\n    renameTokenFind(pWalker->pParse, p, (void*)pExpr);\n  }\n  return WRC_Continue;\n}\n\n/*\n** The RenameCtx contains a list of tokens that reference a column that\n** is being renamed by an ALTER TABLE statement.  Return the \"last\"\n** RenameToken in the RenameCtx and remove that RenameToken from the\n** RenameContext.  \"Last\" means the last RenameToken encountered when\n** the input SQL is parsed from left to right.  Repeated calls to this routine\n** return all column name tokens in the order that they are encountered\n** in the SQL statement.\n*/\nstatic RenameToken *renameColumnTokenNext(RenameCtx *pCtx){\n  RenameToken *pBest = pCtx->pList;\n  RenameToken *pToken;\n  RenameToken **pp;\n\n  for(pToken=pBest->pNext; pToken; pToken=pToken->pNext){\n    if( pToken->t.z>pBest->t.z ) pBest = pToken;\n  }\n  for(pp=&pCtx->pList; *pp!=pBest; pp=&(*pp)->pNext);\n  *pp = pBest->pNext;\n\n  return pBest;\n}\n\n/*\n** An error occured while parsing or otherwise processing a database\n** object (either pParse->pNewTable, pNewIndex or pNewTrigger) as part of an\n** ALTER TABLE RENAME COLUMN program. The error message emitted by the\n** sub-routine is currently stored in pParse->zErrMsg. This function\n** adds context to the error message and then stores it in pCtx.\n*/\nstatic void renameColumnParseError(\n  sqlite3_context *pCtx, \n  int bPost,\n  sqlite3_value *pType,\n  sqlite3_value *pObject,\n  Parse *pParse\n){\n  const char *zT = (const char*)sqlite3_value_text(pType);\n  const char *zN = (const char*)sqlite3_value_text(pObject);\n  char *zErr;\n\n  zErr = sqlite3_mprintf(\"error in %s %s%s: %s\", \n      zT, zN, (bPost ? \" after rename\" : \"\"),\n      pParse->zErrMsg\n  );\n  sqlite3_result_error(pCtx, zErr, -1);\n  sqlite3_free(zErr);\n}\n\n/*\n** For each name in the the expression-list pEList (i.e. each\n** pEList->a[i].zName) that matches the string in zOld, extract the \n** corresponding rename-token from Parse object pParse and add it\n** to the RenameCtx pCtx.\n*/\nstatic void renameColumnElistNames(\n  Parse *pParse, \n  RenameCtx *pCtx, \n  ExprList *pEList, \n  const char *zOld\n){\n  if( pEList ){\n    int i;\n    for(i=0; i<pEList->nExpr; i++){\n      char *zName = pEList->a[i].zName;\n      if( 0==sqlite3_stricmp(zName, zOld) ){\n        renameTokenFind(pParse, pCtx, (void*)zName);\n      }\n    }\n  }\n}\n\n/*\n** For each name in the the id-list pIdList (i.e. each pIdList->a[i].zName) \n** that matches the string in zOld, extract the corresponding rename-token \n** from Parse object pParse and add it to the RenameCtx pCtx.\n*/\nstatic void renameColumnIdlistNames(\n  Parse *pParse, \n  RenameCtx *pCtx, \n  IdList *pIdList, \n  const char *zOld\n){\n  if( pIdList ){\n    int i;\n    for(i=0; i<pIdList->nId; i++){\n      char *zName = pIdList->a[i].zName;\n      if( 0==sqlite3_stricmp(zName, zOld) ){\n        renameTokenFind(pParse, pCtx, (void*)zName);\n      }\n    }\n  }\n}\n\n/*\n** Parse the SQL statement zSql using Parse object (*p). The Parse object\n** is initialized by this function before it is used.\n*/\nstatic int renameParseSql(\n  Parse *p,                       /* Memory to use for Parse object */\n  const char *zDb,                /* Name of schema SQL belongs to */\n  int bTable,                     /* 1 -> RENAME TABLE, 0 -> RENAME COLUMN */\n  sqlite3 *db,                    /* Database handle */\n  const char *zSql,               /* SQL to parse */\n  int bTemp                       /* True if SQL is from temp schema */\n){\n  int rc;\n  char *zErr = 0;\n\n  db->init.iDb = bTemp ? 1 : sqlite3FindDbName(db, zDb);\n\n  /* Parse the SQL statement passed as the first argument. If no error\n  ** occurs and the parse does not result in a new table, index or\n  ** trigger object, the database must be corrupt. */\n  memset(p, 0, sizeof(Parse));\n  p->eParseMode = PARSE_MODE_RENAME;\n  p->db = db;\n  p->nQueryLoop = 1;\n  rc = sqlite3RunParser(p, zSql, &zErr);\n  assert( p->zErrMsg==0 );\n  assert( rc!=SQLITE_OK || zErr==0 );\n  p->zErrMsg = zErr;\n  if( db->mallocFailed ) rc = SQLITE_NOMEM;\n  if( rc==SQLITE_OK \n   && p->pNewTable==0 && p->pNewIndex==0 && p->pNewTrigger==0 \n  ){\n    rc = SQLITE_CORRUPT_BKPT;\n  }\n\n#ifdef SQLITE_DEBUG\n  /* Ensure that all mappings in the Parse.pRename list really do map to\n  ** a part of the input string.  */\n  if( rc==SQLITE_OK ){\n    int nSql = sqlite3Strlen30(zSql);\n    RenameToken *pToken;\n    for(pToken=p->pRename; pToken; pToken=pToken->pNext){\n      assert( pToken->t.z>=zSql && &pToken->t.z[pToken->t.n]<=&zSql[nSql] );\n    }\n  }\n#endif\n\n  db->init.iDb = 0;\n  return rc;\n}\n\n/*\n** This function edits SQL statement zSql, replacing each token identified\n** by the linked list pRename with the text of zNew. If argument bQuote is\n** true, then zNew is always quoted first. If no error occurs, the result\n** is loaded into context object pCtx as the result.\n**\n** Or, if an error occurs (i.e. an OOM condition), an error is left in\n** pCtx and an SQLite error code returned.\n*/\nstatic int renameEditSql(\n  sqlite3_context *pCtx,          /* Return result here */\n  RenameCtx *pRename,             /* Rename context */\n  const char *zSql,               /* SQL statement to edit */\n  const char *zNew,               /* New token text */\n  int bQuote                      /* True to always quote token */\n){\n  int nNew = sqlite3Strlen30(zNew);\n  int nSql = sqlite3Strlen30(zSql);\n  sqlite3 *db = sqlite3_context_db_handle(pCtx);\n  int rc = SQLITE_OK;\n  char *zQuot;\n  char *zOut;\n  int nQuot;\n\n  /* Set zQuot to point to a buffer containing a quoted copy of the \n  ** identifier zNew. If the corresponding identifier in the original \n  ** ALTER TABLE statement was quoted (bQuote==1), then set zNew to\n  ** point to zQuot so that all substitutions are made using the\n  ** quoted version of the new column name.  */\n  zQuot = sqlite3MPrintf(db, \"\\\"%w\\\"\", zNew);\n  if( zQuot==0 ){\n    return SQLITE_NOMEM;\n  }else{\n    nQuot = sqlite3Strlen30(zQuot);\n  }\n  if( bQuote ){\n    zNew = zQuot;\n    nNew = nQuot;\n  }\n\n  /* At this point pRename->pList contains a list of RenameToken objects\n  ** corresponding to all tokens in the input SQL that must be replaced\n  ** with the new column name. All that remains is to construct and\n  ** return the edited SQL string. */\n  assert( nQuot>=nNew );\n  zOut = sqlite3DbMallocZero(db, nSql + pRename->nList*nQuot + 1);\n  if( zOut ){\n    int nOut = nSql;\n    memcpy(zOut, zSql, nSql);\n    while( pRename->pList ){\n      int iOff;                   /* Offset of token to replace in zOut */\n      RenameToken *pBest = renameColumnTokenNext(pRename);\n\n      u32 nReplace;\n      const char *zReplace;\n      if( sqlite3IsIdChar(*pBest->t.z) ){\n        nReplace = nNew;\n        zReplace = zNew;\n      }else{\n        nReplace = nQuot;\n        zReplace = zQuot;\n      }\n\n      iOff = pBest->t.z - zSql;\n      if( pBest->t.n!=nReplace ){\n        memmove(&zOut[iOff + nReplace], &zOut[iOff + pBest->t.n], \n            nOut - (iOff + pBest->t.n)\n        );\n        nOut += nReplace - pBest->t.n;\n        zOut[nOut] = '\\0';\n      }\n      memcpy(&zOut[iOff], zReplace, nReplace);\n      sqlite3DbFree(db, pBest);\n    }\n\n    sqlite3_result_text(pCtx, zOut, -1, SQLITE_TRANSIENT);\n    sqlite3DbFree(db, zOut);\n  }else{\n    rc = SQLITE_NOMEM;\n  }\n\n  sqlite3_free(zQuot);\n  return rc;\n}\n\n/*\n** Resolve all symbols in the trigger at pParse->pNewTrigger, assuming\n** it was read from the schema of database zDb. Return SQLITE_OK if \n** successful. Otherwise, return an SQLite error code and leave an error\n** message in the Parse object.\n*/\nstatic int renameResolveTrigger(Parse *pParse, const char *zDb){\n  sqlite3 *db = pParse->db;\n  Trigger *pNew = pParse->pNewTrigger;\n  TriggerStep *pStep;\n  NameContext sNC;\n  int rc = SQLITE_OK;\n\n  memset(&sNC, 0, sizeof(sNC));\n  sNC.pParse = pParse;\n  assert( pNew->pTabSchema );\n  pParse->pTriggerTab = sqlite3FindTable(db, pNew->table, \n      db->aDb[sqlite3SchemaToIndex(db, pNew->pTabSchema)].zDbSName\n  );\n  pParse->eTriggerOp = pNew->op;\n  /* ALWAYS() because if the table of the trigger does not exist, the\n  ** error would have been hit before this point */\n  if( ALWAYS(pParse->pTriggerTab) ){\n    rc = sqlite3ViewGetColumnNames(pParse, pParse->pTriggerTab);\n  }\n\n  /* Resolve symbols in WHEN clause */\n  if( rc==SQLITE_OK && pNew->pWhen ){\n    rc = sqlite3ResolveExprNames(&sNC, pNew->pWhen);\n  }\n\n  for(pStep=pNew->step_list; rc==SQLITE_OK && pStep; pStep=pStep->pNext){\n    if( pStep->pSelect ){\n      sqlite3SelectPrep(pParse, pStep->pSelect, &sNC);\n      if( pParse->nErr ) rc = pParse->rc;\n    }\n    if( rc==SQLITE_OK && pStep->zTarget ){\n      Table *pTarget = sqlite3LocateTable(pParse, 0, pStep->zTarget, zDb);\n      if( pTarget==0 ){\n        rc = SQLITE_ERROR;\n      }else if( SQLITE_OK==(rc = sqlite3ViewGetColumnNames(pParse, pTarget)) ){\n        SrcList sSrc;\n        memset(&sSrc, 0, sizeof(sSrc));\n        sSrc.nSrc = 1;\n        sSrc.a[0].zName = pStep->zTarget;\n        sSrc.a[0].pTab = pTarget;\n        sNC.pSrcList = &sSrc;\n        if( pStep->pWhere ){\n          rc = sqlite3ResolveExprNames(&sNC, pStep->pWhere);\n        }\n        if( rc==SQLITE_OK ){\n          rc = sqlite3ResolveExprListNames(&sNC, pStep->pExprList);\n        }\n        assert( !pStep->pUpsert || (!pStep->pWhere && !pStep->pExprList) );\n        if( pStep->pUpsert ){\n          Upsert *pUpsert = pStep->pUpsert;\n          assert( rc==SQLITE_OK );\n          pUpsert->pUpsertSrc = &sSrc;\n          sNC.uNC.pUpsert = pUpsert;\n          sNC.ncFlags = NC_UUpsert;\n          rc = sqlite3ResolveExprListNames(&sNC, pUpsert->pUpsertTarget);\n          if( rc==SQLITE_OK ){\n            ExprList *pUpsertSet = pUpsert->pUpsertSet;\n            rc = sqlite3ResolveExprListNames(&sNC, pUpsertSet);\n          }\n          if( rc==SQLITE_OK ){\n            rc = sqlite3ResolveExprNames(&sNC, pUpsert->pUpsertWhere);\n          }\n          if( rc==SQLITE_OK ){\n            rc = sqlite3ResolveExprNames(&sNC, pUpsert->pUpsertTargetWhere);\n          }\n          sNC.ncFlags = 0;\n        }\n        sNC.pSrcList = 0;\n      }\n    }\n  }\n  return rc;\n}\n\n/*\n** Invoke sqlite3WalkExpr() or sqlite3WalkSelect() on all Select or Expr\n** objects that are part of the trigger passed as the second argument.\n*/\nstatic void renameWalkTrigger(Walker *pWalker, Trigger *pTrigger){\n  TriggerStep *pStep;\n\n  /* Find tokens to edit in WHEN clause */\n  sqlite3WalkExpr(pWalker, pTrigger->pWhen);\n\n  /* Find tokens to edit in trigger steps */\n  for(pStep=pTrigger->step_list; pStep; pStep=pStep->pNext){\n    sqlite3WalkSelect(pWalker, pStep->pSelect);\n    sqlite3WalkExpr(pWalker, pStep->pWhere);\n    sqlite3WalkExprList(pWalker, pStep->pExprList);\n    if( pStep->pUpsert ){\n      Upsert *pUpsert = pStep->pUpsert;\n      sqlite3WalkExprList(pWalker, pUpsert->pUpsertTarget);\n      sqlite3WalkExprList(pWalker, pUpsert->pUpsertSet);\n      sqlite3WalkExpr(pWalker, pUpsert->pUpsertWhere);\n      sqlite3WalkExpr(pWalker, pUpsert->pUpsertTargetWhere);\n    }\n  }\n}\n\n/*\n** Free the contents of Parse object (*pParse). Do not free the memory\n** occupied by the Parse object itself.\n*/\nstatic void renameParseCleanup(Parse *pParse){\n  sqlite3 *db = pParse->db;\n  Index *pIdx;\n  if( pParse->pVdbe ){\n    sqlite3VdbeFinalize(pParse->pVdbe);\n  }\n  sqlite3DeleteTable(db, pParse->pNewTable);\n  while( (pIdx = pParse->pNewIndex)!=0 ){\n    pParse->pNewIndex = pIdx->pNext;\n    sqlite3FreeIndex(db, pIdx);\n  }\n  sqlite3DeleteTrigger(db, pParse->pNewTrigger);\n  sqlite3DbFree(db, pParse->zErrMsg);\n  renameTokenFree(db, pParse->pRename);\n  sqlite3ParserReset(pParse);\n}\n\n/*\n** SQL function:\n**\n**     sqlite_rename_column(zSql, iCol, bQuote, zNew, zTable, zOld)\n**\n**   0. zSql:     SQL statement to rewrite\n**   1. type:     Type of object (\"table\", \"view\" etc.)\n**   2. object:   Name of object\n**   3. Database: Database name (e.g. \"main\")\n**   4. Table:    Table name\n**   5. iCol:     Index of column to rename\n**   6. zNew:     New column name\n**   7. bQuote:   Non-zero if the new column name should be quoted.\n**   8. bTemp:    True if zSql comes from temp schema\n**\n** Do a column rename operation on the CREATE statement given in zSql.\n** The iCol-th column (left-most is 0) of table zTable is renamed from zCol\n** into zNew.  The name should be quoted if bQuote is true.\n**\n** This function is used internally by the ALTER TABLE RENAME COLUMN command.\n** It is only accessible to SQL created using sqlite3NestedParse().  It is\n** not reachable from ordinary SQL passed into sqlite3_prepare().\n*/\nstatic void renameColumnFunc(\n  sqlite3_context *context,\n  int NotUsed,\n  sqlite3_value **argv\n){\n  sqlite3 *db = sqlite3_context_db_handle(context);\n  RenameCtx sCtx;\n  const char *zSql = (const char*)sqlite3_value_text(argv[0]);\n  const char *zDb = (const char*)sqlite3_value_text(argv[3]);\n  const char *zTable = (const char*)sqlite3_value_text(argv[4]);\n  int iCol = sqlite3_value_int(argv[5]);\n  const char *zNew = (const char*)sqlite3_value_text(argv[6]);\n  int bQuote = sqlite3_value_int(argv[7]);\n  int bTemp = sqlite3_value_int(argv[8]);\n  const char *zOld;\n  int rc;\n  Parse sParse;\n  Walker sWalker;\n  Index *pIdx;\n  int i;\n  Table *pTab;\n#ifndef SQLITE_OMIT_AUTHORIZATION\n  sqlite3_xauth xAuth = db->xAuth;\n#endif\n\n  UNUSED_PARAMETER(NotUsed);\n  if( zSql==0 ) return;\n  if( zTable==0 ) return;\n  if( zNew==0 ) return;\n  if( iCol<0 ) return;\n  sqlite3BtreeEnterAll(db);\n  pTab = sqlite3FindTable(db, zTable, zDb);\n  if( pTab==0 || iCol>=pTab->nCol ){\n    sqlite3BtreeLeaveAll(db);\n    return;\n  }\n  zOld = pTab->aCol[iCol].zName;\n  memset(&sCtx, 0, sizeof(sCtx));\n  sCtx.iCol = ((iCol==pTab->iPKey) ? -1 : iCol);\n\n#ifndef SQLITE_OMIT_AUTHORIZATION\n  db->xAuth = 0;\n#endif\n  rc = renameParseSql(&sParse, zDb, 0, db, zSql, bTemp);\n\n  /* Find tokens that need to be replaced. */\n  memset(&sWalker, 0, sizeof(Walker));\n  sWalker.pParse = &sParse;\n  sWalker.xExprCallback = renameColumnExprCb;\n  sWalker.xSelectCallback = renameColumnSelectCb;\n  sWalker.u.pRename = &sCtx;\n\n  sCtx.pTab = pTab;\n  if( rc!=SQLITE_OK ) goto renameColumnFunc_done;\n  if( sParse.pNewTable ){\n    Select *pSelect = sParse.pNewTable->pSelect;\n    if( pSelect ){\n      sParse.rc = SQLITE_OK;\n      sqlite3SelectPrep(&sParse, sParse.pNewTable->pSelect, 0);\n      rc = (db->mallocFailed ? SQLITE_NOMEM : sParse.rc);\n      if( rc==SQLITE_OK ){\n        sqlite3WalkSelect(&sWalker, pSelect);\n      }\n      if( rc!=SQLITE_OK ) goto renameColumnFunc_done;\n    }else{\n      /* A regular table */\n      int bFKOnly = sqlite3_stricmp(zTable, sParse.pNewTable->zName);\n      FKey *pFKey;\n      assert( sParse.pNewTable->pSelect==0 );\n      sCtx.pTab = sParse.pNewTable;\n      if( bFKOnly==0 ){\n        renameTokenFind(\n            &sParse, &sCtx, (void*)sParse.pNewTable->aCol[iCol].zName\n        );\n        if( sCtx.iCol<0 ){\n          renameTokenFind(&sParse, &sCtx, (void*)&sParse.pNewTable->iPKey);\n        }\n        sqlite3WalkExprList(&sWalker, sParse.pNewTable->pCheck);\n        for(pIdx=sParse.pNewTable->pIndex; pIdx; pIdx=pIdx->pNext){\n          sqlite3WalkExprList(&sWalker, pIdx->aColExpr);\n        }\n        for(pIdx=sParse.pNewIndex; pIdx; pIdx=pIdx->pNext){\n          sqlite3WalkExprList(&sWalker, pIdx->aColExpr);\n        }\n      }\n#ifndef SQLITE_OMIT_GENERATED_COLUMNS\n      for(i=0; i<sParse.pNewTable->nCol; i++){\n        sqlite3WalkExpr(&sWalker, sParse.pNewTable->aCol[i].pDflt);\n      }\n#endif\n\n      for(pFKey=sParse.pNewTable->pFKey; pFKey; pFKey=pFKey->pNextFrom){\n        for(i=0; i<pFKey->nCol; i++){\n          if( bFKOnly==0 && pFKey->aCol[i].iFrom==iCol ){\n            renameTokenFind(&sParse, &sCtx, (void*)&pFKey->aCol[i]);\n          }\n          if( 0==sqlite3_stricmp(pFKey->zTo, zTable)\n           && 0==sqlite3_stricmp(pFKey->aCol[i].zCol, zOld)\n          ){\n            renameTokenFind(&sParse, &sCtx, (void*)pFKey->aCol[i].zCol);\n          }\n        }\n      }\n    }\n  }else if( sParse.pNewIndex ){\n    sqlite3WalkExprList(&sWalker, sParse.pNewIndex->aColExpr);\n    sqlite3WalkExpr(&sWalker, sParse.pNewIndex->pPartIdxWhere);\n  }else{\n    /* A trigger */\n    TriggerStep *pStep;\n    rc = renameResolveTrigger(&sParse, (bTemp ? 0 : zDb));\n    if( rc!=SQLITE_OK ) goto renameColumnFunc_done;\n\n    for(pStep=sParse.pNewTrigger->step_list; pStep; pStep=pStep->pNext){\n      if( pStep->zTarget ){ \n        Table *pTarget = sqlite3LocateTable(&sParse, 0, pStep->zTarget, zDb);\n        if( pTarget==pTab ){\n          if( pStep->pUpsert ){\n            ExprList *pUpsertSet = pStep->pUpsert->pUpsertSet;\n            renameColumnElistNames(&sParse, &sCtx, pUpsertSet, zOld);\n          }\n          renameColumnIdlistNames(&sParse, &sCtx, pStep->pIdList, zOld);\n          renameColumnElistNames(&sParse, &sCtx, pStep->pExprList, zOld);\n        }\n      }\n    }\n\n\n    /* Find tokens to edit in UPDATE OF clause */\n    if( sParse.pTriggerTab==pTab ){\n      renameColumnIdlistNames(&sParse, &sCtx,sParse.pNewTrigger->pColumns,zOld);\n    }\n\n    /* Find tokens to edit in various expressions and selects */\n    renameWalkTrigger(&sWalker, sParse.pNewTrigger);\n  }\n\n  assert( rc==SQLITE_OK );\n  rc = renameEditSql(context, &sCtx, zSql, zNew, bQuote);\n\nrenameColumnFunc_done:\n  if( rc!=SQLITE_OK ){\n    if( sParse.zErrMsg ){\n      renameColumnParseError(context, 0, argv[1], argv[2], &sParse);\n    }else{\n      sqlite3_result_error_code(context, rc);\n    }\n  }\n\n  renameParseCleanup(&sParse);\n  renameTokenFree(db, sCtx.pList);\n#ifndef SQLITE_OMIT_AUTHORIZATION\n  db->xAuth = xAuth;\n#endif\n  sqlite3BtreeLeaveAll(db);\n}\n\n/*\n** Walker expression callback used by \"RENAME TABLE\". \n*/\nstatic int renameTableExprCb(Walker *pWalker, Expr *pExpr){\n  RenameCtx *p = pWalker->u.pRename;\n  if( pExpr->op==TK_COLUMN && p->pTab==pExpr->y.pTab ){\n    renameTokenFind(pWalker->pParse, p, (void*)&pExpr->y.pTab);\n  }\n  return WRC_Continue;\n}\n\n/*\n** Walker select callback used by \"RENAME TABLE\". \n*/\nstatic int renameTableSelectCb(Walker *pWalker, Select *pSelect){\n  int i;\n  RenameCtx *p = pWalker->u.pRename;\n  SrcList *pSrc = pSelect->pSrc;\n  if( pSrc==0 ){\n    assert( pWalker->pParse->db->mallocFailed );\n    return WRC_Abort;\n  }\n  for(i=0; i<pSrc->nSrc; i++){\n    struct SrcList_item *pItem = &pSrc->a[i];\n    if( pItem->pTab==p->pTab ){\n      renameTokenFind(pWalker->pParse, p, pItem->zName);\n    }\n  }\n  renameWalkWith(pWalker, pSelect);\n\n  return WRC_Continue;\n}\n\n\n/*\n** This C function implements an SQL user function that is used by SQL code\n** generated by the ALTER TABLE ... RENAME command to modify the definition\n** of any foreign key constraints that use the table being renamed as the \n** parent table. It is passed three arguments:\n**\n**   0: The database containing the table being renamed.\n**   1. type:     Type of object (\"table\", \"view\" etc.)\n**   2. object:   Name of object\n**   3: The complete text of the schema statement being modified,\n**   4: The old name of the table being renamed, and\n**   5: The new name of the table being renamed.\n**   6: True if the schema statement comes from the temp db.\n**\n** It returns the new schema statement. For example:\n**\n** sqlite_rename_table('main', 'CREATE TABLE t1(a REFERENCES t2)','t2','t3',0)\n**       -> 'CREATE TABLE t1(a REFERENCES t3)'\n*/\nstatic void renameTableFunc(\n  sqlite3_context *context,\n  int NotUsed,\n  sqlite3_value **argv\n){\n  sqlite3 *db = sqlite3_context_db_handle(context);\n  const char *zDb = (const char*)sqlite3_value_text(argv[0]);\n  const char *zInput = (const char*)sqlite3_value_text(argv[3]);\n  const char *zOld = (const char*)sqlite3_value_text(argv[4]);\n  const char *zNew = (const char*)sqlite3_value_text(argv[5]);\n  int bTemp = sqlite3_value_int(argv[6]);\n  UNUSED_PARAMETER(NotUsed);\n\n  if( zInput && zOld && zNew ){\n    Parse sParse;\n    int rc;\n    int bQuote = 1;\n    RenameCtx sCtx;\n    Walker sWalker;\n\n#ifndef SQLITE_OMIT_AUTHORIZATION\n    sqlite3_xauth xAuth = db->xAuth;\n    db->xAuth = 0;\n#endif\n\n    sqlite3BtreeEnterAll(db);\n\n    memset(&sCtx, 0, sizeof(RenameCtx));\n    sCtx.pTab = sqlite3FindTable(db, zOld, zDb);\n    memset(&sWalker, 0, sizeof(Walker));\n    sWalker.pParse = &sParse;\n    sWalker.xExprCallback = renameTableExprCb;\n    sWalker.xSelectCallback = renameTableSelectCb;\n    sWalker.u.pRename = &sCtx;\n\n    rc = renameParseSql(&sParse, zDb, 1, db, zInput, bTemp);\n\n    if( rc==SQLITE_OK ){\n      int isLegacy = (db->flags & SQLITE_LegacyAlter);\n      if( sParse.pNewTable ){\n        Table *pTab = sParse.pNewTable;\n\n        if( pTab->pSelect ){\n          if( isLegacy==0 ){\n            NameContext sNC;\n            memset(&sNC, 0, sizeof(sNC));\n            sNC.pParse = &sParse;\n\n            sqlite3SelectPrep(&sParse, pTab->pSelect, &sNC);\n            if( sParse.nErr ) rc = sParse.rc;\n            sqlite3WalkSelect(&sWalker, pTab->pSelect);\n          }\n        }else{\n          /* Modify any FK definitions to point to the new table. */\n#ifndef SQLITE_OMIT_FOREIGN_KEY\n          if( isLegacy==0 || (db->flags & SQLITE_ForeignKeys) ){\n            FKey *pFKey;\n            for(pFKey=pTab->pFKey; pFKey; pFKey=pFKey->pNextFrom){\n              if( sqlite3_stricmp(pFKey->zTo, zOld)==0 ){\n                renameTokenFind(&sParse, &sCtx, (void*)pFKey->zTo);\n              }\n            }\n          }\n#endif\n\n          /* If this is the table being altered, fix any table refs in CHECK\n          ** expressions. Also update the name that appears right after the\n          ** \"CREATE [VIRTUAL] TABLE\" bit. */\n          if( sqlite3_stricmp(zOld, pTab->zName)==0 ){\n            sCtx.pTab = pTab;\n            if( isLegacy==0 ){\n              sqlite3WalkExprList(&sWalker, pTab->pCheck);\n            }\n            renameTokenFind(&sParse, &sCtx, pTab->zName);\n          }\n        }\n      }\n\n      else if( sParse.pNewIndex ){\n        renameTokenFind(&sParse, &sCtx, sParse.pNewIndex->zName);\n        if( isLegacy==0 ){\n          sqlite3WalkExpr(&sWalker, sParse.pNewIndex->pPartIdxWhere);\n        }\n      }\n\n#ifndef SQLITE_OMIT_TRIGGER\n      else{\n        Trigger *pTrigger = sParse.pNewTrigger;\n        TriggerStep *pStep;\n        if( 0==sqlite3_stricmp(sParse.pNewTrigger->table, zOld) \n            && sCtx.pTab->pSchema==pTrigger->pTabSchema\n          ){\n          renameTokenFind(&sParse, &sCtx, sParse.pNewTrigger->table);\n        }\n\n        if( isLegacy==0 ){\n          rc = renameResolveTrigger(&sParse, bTemp ? 0 : zDb);\n          if( rc==SQLITE_OK ){\n            renameWalkTrigger(&sWalker, pTrigger);\n            for(pStep=pTrigger->step_list; pStep; pStep=pStep->pNext){\n              if( pStep->zTarget && 0==sqlite3_stricmp(pStep->zTarget, zOld) ){\n                renameTokenFind(&sParse, &sCtx, pStep->zTarget);\n              }\n            }\n          }\n        }\n      }\n#endif\n    }\n\n    if( rc==SQLITE_OK ){\n      rc = renameEditSql(context, &sCtx, zInput, zNew, bQuote);\n    }\n    if( rc!=SQLITE_OK ){\n      if( sParse.zErrMsg ){\n        renameColumnParseError(context, 0, argv[1], argv[2], &sParse);\n      }else{\n        sqlite3_result_error_code(context, rc);\n      }\n    }\n\n    renameParseCleanup(&sParse);\n    renameTokenFree(db, sCtx.pList);\n    sqlite3BtreeLeaveAll(db);\n#ifndef SQLITE_OMIT_AUTHORIZATION\n    db->xAuth = xAuth;\n#endif\n  }\n\n  return;\n}\n\n/*\n** An SQL user function that checks that there are no parse or symbol\n** resolution problems in a CREATE TRIGGER|TABLE|VIEW|INDEX statement.\n** After an ALTER TABLE .. RENAME operation is performed and the schema\n** reloaded, this function is called on each SQL statement in the schema\n** to ensure that it is still usable.\n**\n**   0: Database name (\"main\", \"temp\" etc.).\n**   1: SQL statement.\n**   2: Object type (\"view\", \"table\", \"trigger\" or \"index\").\n**   3: Object name.\n**   4: True if object is from temp schema.\n**\n** Unless it finds an error, this function normally returns NULL. However, it\n** returns integer value 1 if:\n**\n**   * the SQL argument creates a trigger, and\n**   * the table that the trigger is attached to is in database zDb.\n*/\nstatic void renameTableTest(\n  sqlite3_context *context,\n  int NotUsed,\n  sqlite3_value **argv\n){\n  sqlite3 *db = sqlite3_context_db_handle(context);\n  char const *zDb = (const char*)sqlite3_value_text(argv[0]);\n  char const *zInput = (const char*)sqlite3_value_text(argv[1]);\n  int bTemp = sqlite3_value_int(argv[4]);\n  int isLegacy = (db->flags & SQLITE_LegacyAlter);\n\n#ifndef SQLITE_OMIT_AUTHORIZATION\n  sqlite3_xauth xAuth = db->xAuth;\n  db->xAuth = 0;\n#endif\n\n  UNUSED_PARAMETER(NotUsed);\n  if( zDb && zInput ){\n    int rc;\n    Parse sParse;\n    rc = renameParseSql(&sParse, zDb, 1, db, zInput, bTemp);\n    if( rc==SQLITE_OK ){\n      if( isLegacy==0 && sParse.pNewTable && sParse.pNewTable->pSelect ){\n        NameContext sNC;\n        memset(&sNC, 0, sizeof(sNC));\n        sNC.pParse = &sParse;\n        sqlite3SelectPrep(&sParse, sParse.pNewTable->pSelect, &sNC);\n        if( sParse.nErr ) rc = sParse.rc;\n      }\n\n      else if( sParse.pNewTrigger ){\n        if( isLegacy==0 ){\n          rc = renameResolveTrigger(&sParse, bTemp ? 0 : zDb);\n        }\n        if( rc==SQLITE_OK ){\n          int i1 = sqlite3SchemaToIndex(db, sParse.pNewTrigger->pTabSchema);\n          int i2 = sqlite3FindDbName(db, zDb);\n          if( i1==i2 ) sqlite3_result_int(context, 1);\n        }\n      }\n    }\n\n    if( rc!=SQLITE_OK ){\n      renameColumnParseError(context, 1, argv[2], argv[3], &sParse);\n    }\n    renameParseCleanup(&sParse);\n  }\n\n#ifndef SQLITE_OMIT_AUTHORIZATION\n  db->xAuth = xAuth;\n#endif\n}\n\n/*\n** Register built-in functions used to help implement ALTER TABLE\n*/\nvoid sqlite3AlterFunctions(void){\n  static FuncDef aAlterTableFuncs[] = {\n    INTERNAL_FUNCTION(sqlite_rename_column, 9, renameColumnFunc),\n    INTERNAL_FUNCTION(sqlite_rename_table,  7, renameTableFunc),\n    INTERNAL_FUNCTION(sqlite_rename_test,   5, renameTableTest),\n  };\n  sqlite3InsertBuiltinFuncs(aAlterTableFuncs, ArraySize(aAlterTableFuncs));\n}\n#endif  /* SQLITE_ALTER_TABLE */\n", "/*\n** 2001 September 15\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This file contains C code routines that are called by the SQLite parser\n** when syntax rules are reduced.  The routines in this file handle the\n** following kinds of SQL syntax:\n**\n**     CREATE TABLE\n**     DROP TABLE\n**     CREATE INDEX\n**     DROP INDEX\n**     creating ID lists\n**     BEGIN TRANSACTION\n**     COMMIT\n**     ROLLBACK\n*/\n#include \"sqliteInt.h\"\n\n#ifndef SQLITE_OMIT_SHARED_CACHE\n/*\n** The TableLock structure is only used by the sqlite3TableLock() and\n** codeTableLocks() functions.\n*/\nstruct TableLock {\n  int iDb;               /* The database containing the table to be locked */\n  int iTab;              /* The root page of the table to be locked */\n  u8 isWriteLock;        /* True for write lock.  False for a read lock */\n  const char *zLockName; /* Name of the table */\n};\n\n/*\n** Record the fact that we want to lock a table at run-time.  \n**\n** The table to be locked has root page iTab and is found in database iDb.\n** A read or a write lock can be taken depending on isWritelock.\n**\n** This routine just records the fact that the lock is desired.  The\n** code to make the lock occur is generated by a later call to\n** codeTableLocks() which occurs during sqlite3FinishCoding().\n*/\nvoid sqlite3TableLock(\n  Parse *pParse,     /* Parsing context */\n  int iDb,           /* Index of the database containing the table to lock */\n  int iTab,          /* Root page number of the table to be locked */\n  u8 isWriteLock,    /* True for a write lock */\n  const char *zName  /* Name of the table to be locked */\n){\n  Parse *pToplevel = sqlite3ParseToplevel(pParse);\n  int i;\n  int nBytes;\n  TableLock *p;\n  assert( iDb>=0 );\n\n  if( iDb==1 ) return;\n  if( !sqlite3BtreeSharable(pParse->db->aDb[iDb].pBt) ) return;\n  for(i=0; i<pToplevel->nTableLock; i++){\n    p = &pToplevel->aTableLock[i];\n    if( p->iDb==iDb && p->iTab==iTab ){\n      p->isWriteLock = (p->isWriteLock || isWriteLock);\n      return;\n    }\n  }\n\n  nBytes = sizeof(TableLock) * (pToplevel->nTableLock+1);\n  pToplevel->aTableLock =\n      sqlite3DbReallocOrFree(pToplevel->db, pToplevel->aTableLock, nBytes);\n  if( pToplevel->aTableLock ){\n    p = &pToplevel->aTableLock[pToplevel->nTableLock++];\n    p->iDb = iDb;\n    p->iTab = iTab;\n    p->isWriteLock = isWriteLock;\n    p->zLockName = zName;\n  }else{\n    pToplevel->nTableLock = 0;\n    sqlite3OomFault(pToplevel->db);\n  }\n}\n\n/*\n** Code an OP_TableLock instruction for each table locked by the\n** statement (configured by calls to sqlite3TableLock()).\n*/\nstatic void codeTableLocks(Parse *pParse){\n  int i;\n  Vdbe *pVdbe; \n\n  pVdbe = sqlite3GetVdbe(pParse);\n  assert( pVdbe!=0 ); /* sqlite3GetVdbe cannot fail: VDBE already allocated */\n\n  for(i=0; i<pParse->nTableLock; i++){\n    TableLock *p = &pParse->aTableLock[i];\n    int p1 = p->iDb;\n    sqlite3VdbeAddOp4(pVdbe, OP_TableLock, p1, p->iTab, p->isWriteLock,\n                      p->zLockName, P4_STATIC);\n  }\n}\n#else\n  #define codeTableLocks(x)\n#endif\n\n/*\n** Return TRUE if the given yDbMask object is empty - if it contains no\n** 1 bits.  This routine is used by the DbMaskAllZero() and DbMaskNotZero()\n** macros when SQLITE_MAX_ATTACHED is greater than 30.\n*/\n#if SQLITE_MAX_ATTACHED>30\nint sqlite3DbMaskAllZero(yDbMask m){\n  int i;\n  for(i=0; i<sizeof(yDbMask); i++) if( m[i] ) return 0;\n  return 1;\n}\n#endif\n\n/*\n** This routine is called after a single SQL statement has been\n** parsed and a VDBE program to execute that statement has been\n** prepared.  This routine puts the finishing touches on the\n** VDBE program and resets the pParse structure for the next\n** parse.\n**\n** Note that if an error occurred, it might be the case that\n** no VDBE code was generated.\n*/\nvoid sqlite3FinishCoding(Parse *pParse){\n  sqlite3 *db;\n  Vdbe *v;\n\n  assert( pParse->pToplevel==0 );\n  db = pParse->db;\n  if( pParse->nested ) return;\n  if( db->mallocFailed || pParse->nErr ){\n    if( pParse->rc==SQLITE_OK ) pParse->rc = SQLITE_ERROR;\n    return;\n  }\n\n  /* Begin by generating some termination code at the end of the\n  ** vdbe program\n  */\n  v = sqlite3GetVdbe(pParse);\n  assert( !pParse->isMultiWrite \n       || sqlite3VdbeAssertMayAbort(v, pParse->mayAbort));\n  if( v ){\n    sqlite3VdbeAddOp0(v, OP_Halt);\n\n#if SQLITE_USER_AUTHENTICATION\n    if( pParse->nTableLock>0 && db->init.busy==0 ){\n      sqlite3UserAuthInit(db);\n      if( db->auth.authLevel<UAUTH_User ){\n        sqlite3ErrorMsg(pParse, \"user not authenticated\");\n        pParse->rc = SQLITE_AUTH_USER;\n        return;\n      }\n    }\n#endif\n\n    /* The cookie mask contains one bit for each database file open.\n    ** (Bit 0 is for main, bit 1 is for temp, and so forth.)  Bits are\n    ** set for each database that is used.  Generate code to start a\n    ** transaction on each used database and to verify the schema cookie\n    ** on each used database.\n    */\n    if( db->mallocFailed==0 \n     && (DbMaskNonZero(pParse->cookieMask) || pParse->pConstExpr)\n    ){\n      int iDb, i;\n      assert( sqlite3VdbeGetOp(v, 0)->opcode==OP_Init );\n      sqlite3VdbeJumpHere(v, 0);\n      for(iDb=0; iDb<db->nDb; iDb++){\n        Schema *pSchema;\n        if( DbMaskTest(pParse->cookieMask, iDb)==0 ) continue;\n        sqlite3VdbeUsesBtree(v, iDb);\n        pSchema = db->aDb[iDb].pSchema;\n        sqlite3VdbeAddOp4Int(v,\n          OP_Transaction,                    /* Opcode */\n          iDb,                               /* P1 */\n          DbMaskTest(pParse->writeMask,iDb), /* P2 */\n          pSchema->schema_cookie,            /* P3 */\n          pSchema->iGeneration               /* P4 */\n        );\n        if( db->init.busy==0 ) sqlite3VdbeChangeP5(v, 1);\n        VdbeComment((v,\n              \"usesStmtJournal=%d\", pParse->mayAbort && pParse->isMultiWrite));\n      }\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n      for(i=0; i<pParse->nVtabLock; i++){\n        char *vtab = (char *)sqlite3GetVTable(db, pParse->apVtabLock[i]);\n        sqlite3VdbeAddOp4(v, OP_VBegin, 0, 0, 0, vtab, P4_VTAB);\n      }\n      pParse->nVtabLock = 0;\n#endif\n\n      /* Once all the cookies have been verified and transactions opened, \n      ** obtain the required table-locks. This is a no-op unless the \n      ** shared-cache feature is enabled.\n      */\n      codeTableLocks(pParse);\n\n      /* Initialize any AUTOINCREMENT data structures required.\n      */\n      sqlite3AutoincrementBegin(pParse);\n\n      /* Code constant expressions that where factored out of inner loops */\n      if( pParse->pConstExpr ){\n        ExprList *pEL = pParse->pConstExpr;\n        pParse->okConstFactor = 0;\n        for(i=0; i<pEL->nExpr; i++){\n          sqlite3ExprCode(pParse, pEL->a[i].pExpr, pEL->a[i].u.iConstExprReg);\n        }\n      }\n\n      /* Finally, jump back to the beginning of the executable code. */\n      sqlite3VdbeGoto(v, 1);\n    }\n  }\n\n\n  /* Get the VDBE program ready for execution\n  */\n  if( v && pParse->nErr==0 && !db->mallocFailed ){\n    /* A minimum of one cursor is required if autoincrement is used\n    *  See ticket [a696379c1f08866] */\n    assert( pParse->pAinc==0 || pParse->nTab>0 );\n    sqlite3VdbeMakeReady(v, pParse);\n    pParse->rc = SQLITE_DONE;\n  }else{\n    pParse->rc = SQLITE_ERROR;\n  }\n}\n\n/*\n** Run the parser and code generator recursively in order to generate\n** code for the SQL statement given onto the end of the pParse context\n** currently under construction.  When the parser is run recursively\n** this way, the final OP_Halt is not appended and other initialization\n** and finalization steps are omitted because those are handling by the\n** outermost parser.\n**\n** Not everything is nestable.  This facility is designed to permit\n** INSERT, UPDATE, and DELETE operations against SQLITE_MASTER.  Use\n** care if you decide to try to use this routine for some other purposes.\n*/\nvoid sqlite3NestedParse(Parse *pParse, const char *zFormat, ...){\n  va_list ap;\n  char *zSql;\n  char *zErrMsg = 0;\n  sqlite3 *db = pParse->db;\n  char saveBuf[PARSE_TAIL_SZ];\n\n  if( pParse->nErr ) return;\n  assert( pParse->nested<10 );  /* Nesting should only be of limited depth */\n  va_start(ap, zFormat);\n  zSql = sqlite3VMPrintf(db, zFormat, ap);\n  va_end(ap);\n  if( zSql==0 ){\n    /* This can result either from an OOM or because the formatted string\n    ** exceeds SQLITE_LIMIT_LENGTH.  In the latter case, we need to set\n    ** an error */\n    if( !db->mallocFailed ) pParse->rc = SQLITE_TOOBIG;\n    pParse->nErr++;\n    return;\n  }\n  pParse->nested++;\n  memcpy(saveBuf, PARSE_TAIL(pParse), PARSE_TAIL_SZ);\n  memset(PARSE_TAIL(pParse), 0, PARSE_TAIL_SZ);\n  sqlite3RunParser(pParse, zSql, &zErrMsg);\n  sqlite3DbFree(db, zErrMsg);\n  sqlite3DbFree(db, zSql);\n  memcpy(PARSE_TAIL(pParse), saveBuf, PARSE_TAIL_SZ);\n  pParse->nested--;\n}\n\n#if SQLITE_USER_AUTHENTICATION\n/*\n** Return TRUE if zTable is the name of the system table that stores the\n** list of users and their access credentials.\n*/\nint sqlite3UserAuthTable(const char *zTable){\n  return sqlite3_stricmp(zTable, \"sqlite_user\")==0;\n}\n#endif\n\n/*\n** Locate the in-memory structure that describes a particular database\n** table given the name of that table and (optionally) the name of the\n** database containing the table.  Return NULL if not found.\n**\n** If zDatabase is 0, all databases are searched for the table and the\n** first matching table is returned.  (No checking for duplicate table\n** names is done.)  The search order is TEMP first, then MAIN, then any\n** auxiliary databases added using the ATTACH command.\n**\n** See also sqlite3LocateTable().\n*/\nTable *sqlite3FindTable(sqlite3 *db, const char *zName, const char *zDatabase){\n  Table *p = 0;\n  int i;\n\n  /* All mutexes are required for schema access.  Make sure we hold them. */\n  assert( zDatabase!=0 || sqlite3BtreeHoldsAllMutexes(db) );\n#if SQLITE_USER_AUTHENTICATION\n  /* Only the admin user is allowed to know that the sqlite_user table\n  ** exists */\n  if( db->auth.authLevel<UAUTH_Admin && sqlite3UserAuthTable(zName)!=0 ){\n    return 0;\n  }\n#endif\n  while(1){\n    for(i=OMIT_TEMPDB; i<db->nDb; i++){\n      int j = (i<2) ? i^1 : i;   /* Search TEMP before MAIN */\n      if( zDatabase==0 || sqlite3StrICmp(zDatabase, db->aDb[j].zDbSName)==0 ){\n        assert( sqlite3SchemaMutexHeld(db, j, 0) );\n        p = sqlite3HashFind(&db->aDb[j].pSchema->tblHash, zName);\n        if( p ) return p;\n      }\n    }\n    /* Not found.  If the name we were looking for was temp.sqlite_master\n    ** then change the name to sqlite_temp_master and try again. */\n    if( sqlite3StrICmp(zName, MASTER_NAME)!=0 ) break;\n    if( sqlite3_stricmp(zDatabase, db->aDb[1].zDbSName)!=0 ) break;\n    zName = TEMP_MASTER_NAME;\n  }\n  return 0;\n}\n\n/*\n** Locate the in-memory structure that describes a particular database\n** table given the name of that table and (optionally) the name of the\n** database containing the table.  Return NULL if not found.  Also leave an\n** error message in pParse->zErrMsg.\n**\n** The difference between this routine and sqlite3FindTable() is that this\n** routine leaves an error message in pParse->zErrMsg where\n** sqlite3FindTable() does not.\n*/\nTable *sqlite3LocateTable(\n  Parse *pParse,         /* context in which to report errors */\n  u32 flags,             /* LOCATE_VIEW or LOCATE_NOERR */\n  const char *zName,     /* Name of the table we are looking for */\n  const char *zDbase     /* Name of the database.  Might be NULL */\n){\n  Table *p;\n  sqlite3 *db = pParse->db;\n\n  /* Read the database schema. If an error occurs, leave an error message\n  ** and code in pParse and return NULL. */\n  if( (db->mDbFlags & DBFLAG_SchemaKnownOk)==0 \n   && SQLITE_OK!=sqlite3ReadSchema(pParse)\n  ){\n    return 0;\n  }\n\n  p = sqlite3FindTable(db, zName, zDbase);\n  if( p==0 ){\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n    /* If zName is the not the name of a table in the schema created using\n    ** CREATE, then check to see if it is the name of an virtual table that\n    ** can be an eponymous virtual table. */\n    if( pParse->disableVtab==0 ){\n      Module *pMod = (Module*)sqlite3HashFind(&db->aModule, zName);\n      if( pMod==0 && sqlite3_strnicmp(zName, \"pragma_\", 7)==0 ){\n        pMod = sqlite3PragmaVtabRegister(db, zName);\n      }\n      if( pMod && sqlite3VtabEponymousTableInit(pParse, pMod) ){\n        return pMod->pEpoTab;\n      }\n    }\n#endif\n    if( flags & LOCATE_NOERR ) return 0;\n    pParse->checkSchema = 1;\n  }else if( IsVirtual(p) && pParse->disableVtab ){\n    p = 0;\n  }\n\n  if( p==0 ){\n    const char *zMsg = flags & LOCATE_VIEW ? \"no such view\" : \"no such table\";\n    if( zDbase ){\n      sqlite3ErrorMsg(pParse, \"%s: %s.%s\", zMsg, zDbase, zName);\n    }else{\n      sqlite3ErrorMsg(pParse, \"%s: %s\", zMsg, zName);\n    }\n  }\n\n  return p;\n}\n\n/*\n** Locate the table identified by *p.\n**\n** This is a wrapper around sqlite3LocateTable(). The difference between\n** sqlite3LocateTable() and this function is that this function restricts\n** the search to schema (p->pSchema) if it is not NULL. p->pSchema may be\n** non-NULL if it is part of a view or trigger program definition. See\n** sqlite3FixSrcList() for details.\n*/\nTable *sqlite3LocateTableItem(\n  Parse *pParse, \n  u32 flags,\n  struct SrcList_item *p\n){\n  const char *zDb;\n  assert( p->pSchema==0 || p->zDatabase==0 );\n  if( p->pSchema ){\n    int iDb = sqlite3SchemaToIndex(pParse->db, p->pSchema);\n    zDb = pParse->db->aDb[iDb].zDbSName;\n  }else{\n    zDb = p->zDatabase;\n  }\n  return sqlite3LocateTable(pParse, flags, p->zName, zDb);\n}\n\n/*\n** Locate the in-memory structure that describes \n** a particular index given the name of that index\n** and the name of the database that contains the index.\n** Return NULL if not found.\n**\n** If zDatabase is 0, all databases are searched for the\n** table and the first matching index is returned.  (No checking\n** for duplicate index names is done.)  The search order is\n** TEMP first, then MAIN, then any auxiliary databases added\n** using the ATTACH command.\n*/\nIndex *sqlite3FindIndex(sqlite3 *db, const char *zName, const char *zDb){\n  Index *p = 0;\n  int i;\n  /* All mutexes are required for schema access.  Make sure we hold them. */\n  assert( zDb!=0 || sqlite3BtreeHoldsAllMutexes(db) );\n  for(i=OMIT_TEMPDB; i<db->nDb; i++){\n    int j = (i<2) ? i^1 : i;  /* Search TEMP before MAIN */\n    Schema *pSchema = db->aDb[j].pSchema;\n    assert( pSchema );\n    if( zDb && sqlite3StrICmp(zDb, db->aDb[j].zDbSName) ) continue;\n    assert( sqlite3SchemaMutexHeld(db, j, 0) );\n    p = sqlite3HashFind(&pSchema->idxHash, zName);\n    if( p ) break;\n  }\n  return p;\n}\n\n/*\n** Reclaim the memory used by an index\n*/\nvoid sqlite3FreeIndex(sqlite3 *db, Index *p){\n#ifndef SQLITE_OMIT_ANALYZE\n  sqlite3DeleteIndexSamples(db, p);\n#endif\n  sqlite3ExprDelete(db, p->pPartIdxWhere);\n  sqlite3ExprListDelete(db, p->aColExpr);\n  sqlite3DbFree(db, p->zColAff);\n  if( p->isResized ) sqlite3DbFree(db, (void *)p->azColl);\n#ifdef SQLITE_ENABLE_STAT4\n  sqlite3_free(p->aiRowEst);\n#endif\n  sqlite3DbFree(db, p);\n}\n\n/*\n** For the index called zIdxName which is found in the database iDb,\n** unlike that index from its Table then remove the index from\n** the index hash table and free all memory structures associated\n** with the index.\n*/\nvoid sqlite3UnlinkAndDeleteIndex(sqlite3 *db, int iDb, const char *zIdxName){\n  Index *pIndex;\n  Hash *pHash;\n\n  assert( sqlite3SchemaMutexHeld(db, iDb, 0) );\n  pHash = &db->aDb[iDb].pSchema->idxHash;\n  pIndex = sqlite3HashInsert(pHash, zIdxName, 0);\n  if( ALWAYS(pIndex) ){\n    if( pIndex->pTable->pIndex==pIndex ){\n      pIndex->pTable->pIndex = pIndex->pNext;\n    }else{\n      Index *p;\n      /* Justification of ALWAYS();  The index must be on the list of\n      ** indices. */\n      p = pIndex->pTable->pIndex;\n      while( ALWAYS(p) && p->pNext!=pIndex ){ p = p->pNext; }\n      if( ALWAYS(p && p->pNext==pIndex) ){\n        p->pNext = pIndex->pNext;\n      }\n    }\n    sqlite3FreeIndex(db, pIndex);\n  }\n  db->mDbFlags |= DBFLAG_SchemaChange;\n}\n\n/*\n** Look through the list of open database files in db->aDb[] and if\n** any have been closed, remove them from the list.  Reallocate the\n** db->aDb[] structure to a smaller size, if possible.\n**\n** Entry 0 (the \"main\" database) and entry 1 (the \"temp\" database)\n** are never candidates for being collapsed.\n*/\nvoid sqlite3CollapseDatabaseArray(sqlite3 *db){\n  int i, j;\n  for(i=j=2; i<db->nDb; i++){\n    struct Db *pDb = &db->aDb[i];\n    if( pDb->pBt==0 ){\n      sqlite3DbFree(db, pDb->zDbSName);\n      pDb->zDbSName = 0;\n      continue;\n    }\n    if( j<i ){\n      db->aDb[j] = db->aDb[i];\n    }\n    j++;\n  }\n  db->nDb = j;\n  if( db->nDb<=2 && db->aDb!=db->aDbStatic ){\n    memcpy(db->aDbStatic, db->aDb, 2*sizeof(db->aDb[0]));\n    sqlite3DbFree(db, db->aDb);\n    db->aDb = db->aDbStatic;\n  }\n}\n\n/*\n** Reset the schema for the database at index iDb.  Also reset the\n** TEMP schema.  The reset is deferred if db->nSchemaLock is not zero.\n** Deferred resets may be run by calling with iDb<0.\n*/\nvoid sqlite3ResetOneSchema(sqlite3 *db, int iDb){\n  int i;\n  assert( iDb<db->nDb );\n\n  if( iDb>=0 ){\n    assert( sqlite3SchemaMutexHeld(db, iDb, 0) );\n    DbSetProperty(db, iDb, DB_ResetWanted);\n    DbSetProperty(db, 1, DB_ResetWanted);\n    db->mDbFlags &= ~DBFLAG_SchemaKnownOk;\n  }\n\n  if( db->nSchemaLock==0 ){\n    for(i=0; i<db->nDb; i++){\n      if( DbHasProperty(db, i, DB_ResetWanted) ){\n        sqlite3SchemaClear(db->aDb[i].pSchema);\n      }\n    }\n  }\n}\n\n/*\n** Erase all schema information from all attached databases (including\n** \"main\" and \"temp\") for a single database connection.\n*/\nvoid sqlite3ResetAllSchemasOfConnection(sqlite3 *db){\n  int i;\n  sqlite3BtreeEnterAll(db);\n  for(i=0; i<db->nDb; i++){\n    Db *pDb = &db->aDb[i];\n    if( pDb->pSchema ){\n      if( db->nSchemaLock==0 ){\n        sqlite3SchemaClear(pDb->pSchema);\n      }else{\n        DbSetProperty(db, i, DB_ResetWanted);\n      }\n    }\n  }\n  db->mDbFlags &= ~(DBFLAG_SchemaChange|DBFLAG_SchemaKnownOk);\n  sqlite3VtabUnlockList(db);\n  sqlite3BtreeLeaveAll(db);\n  if( db->nSchemaLock==0 ){\n    sqlite3CollapseDatabaseArray(db);\n  }\n}\n\n/*\n** This routine is called when a commit occurs.\n*/\nvoid sqlite3CommitInternalChanges(sqlite3 *db){\n  db->mDbFlags &= ~DBFLAG_SchemaChange;\n}\n\n/*\n** Delete memory allocated for the column names of a table or view (the\n** Table.aCol[] array).\n*/\nvoid sqlite3DeleteColumnNames(sqlite3 *db, Table *pTable){\n  int i;\n  Column *pCol;\n  assert( pTable!=0 );\n  if( (pCol = pTable->aCol)!=0 ){\n    for(i=0; i<pTable->nCol; i++, pCol++){\n      sqlite3DbFree(db, pCol->zName);\n      sqlite3ExprDelete(db, pCol->pDflt);\n      sqlite3DbFree(db, pCol->zColl);\n    }\n    sqlite3DbFree(db, pTable->aCol);\n  }\n}\n\n/*\n** Remove the memory data structures associated with the given\n** Table.  No changes are made to disk by this routine.\n**\n** This routine just deletes the data structure.  It does not unlink\n** the table data structure from the hash table.  But it does destroy\n** memory structures of the indices and foreign keys associated with \n** the table.\n**\n** The db parameter is optional.  It is needed if the Table object \n** contains lookaside memory.  (Table objects in the schema do not use\n** lookaside memory, but some ephemeral Table objects do.)  Or the\n** db parameter can be used with db->pnBytesFreed to measure the memory\n** used by the Table object.\n*/\nstatic void SQLITE_NOINLINE deleteTable(sqlite3 *db, Table *pTable){\n  Index *pIndex, *pNext;\n\n#ifdef SQLITE_DEBUG\n  /* Record the number of outstanding lookaside allocations in schema Tables\n  ** prior to doing any free() operations. Since schema Tables do not use\n  ** lookaside, this number should not change. \n  **\n  ** If malloc has already failed, it may be that it failed while allocating\n  ** a Table object that was going to be marked ephemeral. So do not check\n  ** that no lookaside memory is used in this case either. */\n  int nLookaside = 0;\n  if( db && !db->mallocFailed && (pTable->tabFlags & TF_Ephemeral)==0 ){\n    nLookaside = sqlite3LookasideUsed(db, 0);\n  }\n#endif\n\n  /* Delete all indices associated with this table. */\n  for(pIndex = pTable->pIndex; pIndex; pIndex=pNext){\n    pNext = pIndex->pNext;\n    assert( pIndex->pSchema==pTable->pSchema\n         || (IsVirtual(pTable) && pIndex->idxType!=SQLITE_IDXTYPE_APPDEF) );\n    if( (db==0 || db->pnBytesFreed==0) && !IsVirtual(pTable) ){\n      char *zName = pIndex->zName; \n      TESTONLY ( Index *pOld = ) sqlite3HashInsert(\n         &pIndex->pSchema->idxHash, zName, 0\n      );\n      assert( db==0 || sqlite3SchemaMutexHeld(db, 0, pIndex->pSchema) );\n      assert( pOld==pIndex || pOld==0 );\n    }\n    sqlite3FreeIndex(db, pIndex);\n  }\n\n  /* Delete any foreign keys attached to this table. */\n  sqlite3FkDelete(db, pTable);\n\n  /* Delete the Table structure itself.\n  */\n  sqlite3DeleteColumnNames(db, pTable);\n  sqlite3DbFree(db, pTable->zName);\n  sqlite3DbFree(db, pTable->zColAff);\n  sqlite3SelectDelete(db, pTable->pSelect);\n  sqlite3ExprListDelete(db, pTable->pCheck);\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n  sqlite3VtabClear(db, pTable);\n#endif\n  sqlite3DbFree(db, pTable);\n\n  /* Verify that no lookaside memory was used by schema tables */\n  assert( nLookaside==0 || nLookaside==sqlite3LookasideUsed(db,0) );\n}\nvoid sqlite3DeleteTable(sqlite3 *db, Table *pTable){\n  /* Do not delete the table until the reference count reaches zero. */\n  if( !pTable ) return;\n  if( ((!db || db->pnBytesFreed==0) && (--pTable->nTabRef)>0) ) return;\n  deleteTable(db, pTable);\n}\n\n\n/*\n** Unlink the given table from the hash tables and the delete the\n** table structure with all its indices and foreign keys.\n*/\nvoid sqlite3UnlinkAndDeleteTable(sqlite3 *db, int iDb, const char *zTabName){\n  Table *p;\n  Db *pDb;\n\n  assert( db!=0 );\n  assert( iDb>=0 && iDb<db->nDb );\n  assert( zTabName );\n  assert( sqlite3SchemaMutexHeld(db, iDb, 0) );\n  testcase( zTabName[0]==0 );  /* Zero-length table names are allowed */\n  pDb = &db->aDb[iDb];\n  p = sqlite3HashInsert(&pDb->pSchema->tblHash, zTabName, 0);\n  sqlite3DeleteTable(db, p);\n  db->mDbFlags |= DBFLAG_SchemaChange;\n}\n\n/*\n** Given a token, return a string that consists of the text of that\n** token.  Space to hold the returned string\n** is obtained from sqliteMalloc() and must be freed by the calling\n** function.\n**\n** Any quotation marks (ex:  \"name\", 'name', [name], or `name`) that\n** surround the body of the token are removed.\n**\n** Tokens are often just pointers into the original SQL text and so\n** are not \\000 terminated and are not persistent.  The returned string\n** is \\000 terminated and is persistent.\n*/\nchar *sqlite3NameFromToken(sqlite3 *db, Token *pName){\n  char *zName;\n  if( pName ){\n    zName = sqlite3DbStrNDup(db, (char*)pName->z, pName->n);\n    sqlite3Dequote(zName);\n  }else{\n    zName = 0;\n  }\n  return zName;\n}\n\n/*\n** Open the sqlite_master table stored in database number iDb for\n** writing. The table is opened using cursor 0.\n*/\nvoid sqlite3OpenMasterTable(Parse *p, int iDb){\n  Vdbe *v = sqlite3GetVdbe(p);\n  sqlite3TableLock(p, iDb, MASTER_ROOT, 1, MASTER_NAME);\n  sqlite3VdbeAddOp4Int(v, OP_OpenWrite, 0, MASTER_ROOT, iDb, 5);\n  if( p->nTab==0 ){\n    p->nTab = 1;\n  }\n}\n\n/*\n** Parameter zName points to a nul-terminated buffer containing the name\n** of a database (\"main\", \"temp\" or the name of an attached db). This\n** function returns the index of the named database in db->aDb[], or\n** -1 if the named db cannot be found.\n*/\nint sqlite3FindDbName(sqlite3 *db, const char *zName){\n  int i = -1;         /* Database number */\n  if( zName ){\n    Db *pDb;\n    for(i=(db->nDb-1), pDb=&db->aDb[i]; i>=0; i--, pDb--){\n      if( 0==sqlite3_stricmp(pDb->zDbSName, zName) ) break;\n      /* \"main\" is always an acceptable alias for the primary database\n      ** even if it has been renamed using SQLITE_DBCONFIG_MAINDBNAME. */\n      if( i==0 && 0==sqlite3_stricmp(\"main\", zName) ) break;\n    }\n  }\n  return i;\n}\n\n/*\n** The token *pName contains the name of a database (either \"main\" or\n** \"temp\" or the name of an attached db). This routine returns the\n** index of the named database in db->aDb[], or -1 if the named db \n** does not exist.\n*/\nint sqlite3FindDb(sqlite3 *db, Token *pName){\n  int i;                               /* Database number */\n  char *zName;                         /* Name we are searching for */\n  zName = sqlite3NameFromToken(db, pName);\n  i = sqlite3FindDbName(db, zName);\n  sqlite3DbFree(db, zName);\n  return i;\n}\n\n/* The table or view or trigger name is passed to this routine via tokens\n** pName1 and pName2. If the table name was fully qualified, for example:\n**\n** CREATE TABLE xxx.yyy (...);\n** \n** Then pName1 is set to \"xxx\" and pName2 \"yyy\". On the other hand if\n** the table name is not fully qualified, i.e.:\n**\n** CREATE TABLE yyy(...);\n**\n** Then pName1 is set to \"yyy\" and pName2 is \"\".\n**\n** This routine sets the *ppUnqual pointer to point at the token (pName1 or\n** pName2) that stores the unqualified table name.  The index of the\n** database \"xxx\" is returned.\n*/\nint sqlite3TwoPartName(\n  Parse *pParse,      /* Parsing and code generating context */\n  Token *pName1,      /* The \"xxx\" in the name \"xxx.yyy\" or \"xxx\" */\n  Token *pName2,      /* The \"yyy\" in the name \"xxx.yyy\" */\n  Token **pUnqual     /* Write the unqualified object name here */\n){\n  int iDb;                    /* Database holding the object */\n  sqlite3 *db = pParse->db;\n\n  assert( pName2!=0 );\n  if( pName2->n>0 ){\n    if( db->init.busy ) {\n      sqlite3ErrorMsg(pParse, \"corrupt database\");\n      return -1;\n    }\n    *pUnqual = pName2;\n    iDb = sqlite3FindDb(db, pName1);\n    if( iDb<0 ){\n      sqlite3ErrorMsg(pParse, \"unknown database %T\", pName1);\n      return -1;\n    }\n  }else{\n    assert( db->init.iDb==0 || db->init.busy || IN_RENAME_OBJECT\n             || (db->mDbFlags & DBFLAG_Vacuum)!=0);\n    iDb = db->init.iDb;\n    *pUnqual = pName1;\n  }\n  return iDb;\n}\n\n/*\n** True if PRAGMA writable_schema is ON\n*/\nint sqlite3WritableSchema(sqlite3 *db){\n  testcase( (db->flags&(SQLITE_WriteSchema|SQLITE_Defensive))==0 );\n  testcase( (db->flags&(SQLITE_WriteSchema|SQLITE_Defensive))==\n               SQLITE_WriteSchema );\n  testcase( (db->flags&(SQLITE_WriteSchema|SQLITE_Defensive))==\n               SQLITE_Defensive );\n  testcase( (db->flags&(SQLITE_WriteSchema|SQLITE_Defensive))==\n               (SQLITE_WriteSchema|SQLITE_Defensive) );\n  return (db->flags&(SQLITE_WriteSchema|SQLITE_Defensive))==SQLITE_WriteSchema;\n}\n\n/*\n** This routine is used to check if the UTF-8 string zName is a legal\n** unqualified name for a new schema object (table, index, view or\n** trigger). All names are legal except those that begin with the string\n** \"sqlite_\" (in upper, lower or mixed case). This portion of the namespace\n** is reserved for internal use.\n**\n** When parsing the sqlite_master table, this routine also checks to\n** make sure the \"type\", \"name\", and \"tbl_name\" columns are consistent\n** with the SQL.\n*/\nint sqlite3CheckObjectName(\n  Parse *pParse,            /* Parsing context */\n  const char *zName,        /* Name of the object to check */\n  const char *zType,        /* Type of this object */\n  const char *zTblName      /* Parent table name for triggers and indexes */\n){\n  sqlite3 *db = pParse->db;\n  if( sqlite3WritableSchema(db) || db->init.imposterTable ){\n    /* Skip these error checks for writable_schema=ON */\n    return SQLITE_OK;\n  }\n  if( db->init.busy ){\n    if( sqlite3_stricmp(zType, db->init.azInit[0])\n     || sqlite3_stricmp(zName, db->init.azInit[1])\n     || sqlite3_stricmp(zTblName, db->init.azInit[2])\n    ){\n      if( sqlite3Config.bExtraSchemaChecks ){\n        sqlite3ErrorMsg(pParse, \"\"); /* corruptSchema() will supply the error */\n        return SQLITE_ERROR;\n      }\n    }\n  }else{\n    if( (pParse->nested==0 && 0==sqlite3StrNICmp(zName, \"sqlite_\", 7))\n     || (sqlite3ReadOnlyShadowTables(db) && sqlite3ShadowTableName(db, zName))\n    ){\n      sqlite3ErrorMsg(pParse, \"object name reserved for internal use: %s\",\n                      zName);\n      return SQLITE_ERROR;\n    }\n\n  }\n  return SQLITE_OK;\n}\n\n/*\n** Return the PRIMARY KEY index of a table\n*/\nIndex *sqlite3PrimaryKeyIndex(Table *pTab){\n  Index *p;\n  for(p=pTab->pIndex; p && !IsPrimaryKeyIndex(p); p=p->pNext){}\n  return p;\n}\n\n/*\n** Convert an table column number into a index column number.  That is,\n** for the column iCol in the table (as defined by the CREATE TABLE statement)\n** find the (first) offset of that column in index pIdx.  Or return -1\n** if column iCol is not used in index pIdx.\n*/\ni16 sqlite3TableColumnToIndex(Index *pIdx, i16 iCol){\n  int i;\n  for(i=0; i<pIdx->nColumn; i++){\n    if( iCol==pIdx->aiColumn[i] ) return i;\n  }\n  return -1;\n}\n\n#ifndef SQLITE_OMIT_GENERATED_COLUMNS\n/* Convert a storage column number into a table column number.\n**\n** The storage column number (0,1,2,....) is the index of the value\n** as it appears in the record on disk.  The true column number\n** is the index (0,1,2,...) of the column in the CREATE TABLE statement.\n**\n** The storage column number is less than the table column number if\n** and only there are VIRTUAL columns to the left.\n**\n** If SQLITE_OMIT_GENERATED_COLUMNS, this routine is a no-op macro.\n*/\ni16 sqlite3StorageColumnToTable(Table *pTab, i16 iCol){\n  if( pTab->tabFlags & TF_HasVirtual ){\n    int i;\n    for(i=0; i<=iCol; i++){\n      if( pTab->aCol[i].colFlags & COLFLAG_VIRTUAL ) iCol++;\n    }\n  }\n  return iCol;\n}\n#endif\n\n#ifndef SQLITE_OMIT_GENERATED_COLUMNS\n/* Convert a table column number into a storage column number.\n**\n** The storage column number (0,1,2,....) is the index of the value\n** as it appears in the record on disk.  Or, if the input column is\n** the N-th virtual column (zero-based) then the storage number is\n** the number of non-virtual columns in the table plus N.  \n**\n** The true column number is the index (0,1,2,...) of the column in\n** the CREATE TABLE statement.\n**\n** If the input column is a VIRTUAL column, then it should not appear\n** in storage.  But the value sometimes is cached in registers that\n** follow the range of registers used to construct storage.  This\n** avoids computing the same VIRTUAL column multiple times, and provides\n** values for use by OP_Param opcodes in triggers.  Hence, if the\n** input column is a VIRTUAL table, put it after all the other columns.\n**\n** In the following, N means \"normal column\", S means STORED, and\n** V means VIRTUAL.  Suppose the CREATE TABLE has columns like this:\n**\n**        CREATE TABLE ex(N,S,V,N,S,V,N,S,V);\n**                     -- 0 1 2 3 4 5 6 7 8\n**\n** Then the mapping from this function is as follows:\n**\n**    INPUTS:     0 1 2 3 4 5 6 7 8\n**    OUTPUTS:    0 1 6 2 3 7 4 5 8\n**\n** So, in other words, this routine shifts all the virtual columns to\n** the end.\n**\n** If SQLITE_OMIT_GENERATED_COLUMNS then there are no virtual columns and\n** this routine is a no-op macro.  If the pTab does not have any virtual\n** columns, then this routine is no-op that always return iCol.  If iCol\n** is negative (indicating the ROWID column) then this routine return iCol.\n*/\ni16 sqlite3TableColumnToStorage(Table *pTab, i16 iCol){\n  int i;\n  i16 n;\n  assert( iCol<pTab->nCol );\n  if( (pTab->tabFlags & TF_HasVirtual)==0 || iCol<0 ) return iCol;\n  for(i=0, n=0; i<iCol; i++){\n    if( (pTab->aCol[i].colFlags & COLFLAG_VIRTUAL)==0 ) n++;\n  }\n  if( pTab->aCol[i].colFlags & COLFLAG_VIRTUAL ){\n    /* iCol is a virtual column itself */\n    return pTab->nNVCol + i - n;\n  }else{\n    /* iCol is a normal or stored column */\n    return n;\n  }\n}\n#endif\n\n/*\n** Begin constructing a new table representation in memory.  This is\n** the first of several action routines that get called in response\n** to a CREATE TABLE statement.  In particular, this routine is called\n** after seeing tokens \"CREATE\" and \"TABLE\" and the table name. The isTemp\n** flag is true if the table should be stored in the auxiliary database\n** file instead of in the main database file.  This is normally the case\n** when the \"TEMP\" or \"TEMPORARY\" keyword occurs in between\n** CREATE and TABLE.\n**\n** The new table record is initialized and put in pParse->pNewTable.\n** As more of the CREATE TABLE statement is parsed, additional action\n** routines will be called to add more information to this record.\n** At the end of the CREATE TABLE statement, the sqlite3EndTable() routine\n** is called to complete the construction of the new table record.\n*/\nvoid sqlite3StartTable(\n  Parse *pParse,   /* Parser context */\n  Token *pName1,   /* First part of the name of the table or view */\n  Token *pName2,   /* Second part of the name of the table or view */\n  int isTemp,      /* True if this is a TEMP table */\n  int isView,      /* True if this is a VIEW */\n  int isVirtual,   /* True if this is a VIRTUAL table */\n  int noErr        /* Do nothing if table already exists */\n){\n  Table *pTable;\n  char *zName = 0; /* The name of the new table */\n  sqlite3 *db = pParse->db;\n  Vdbe *v;\n  int iDb;         /* Database number to create the table in */\n  Token *pName;    /* Unqualified name of the table to create */\n\n  if( db->init.busy && db->init.newTnum==1 ){\n    /* Special case:  Parsing the sqlite_master or sqlite_temp_master schema */\n    iDb = db->init.iDb;\n    zName = sqlite3DbStrDup(db, SCHEMA_TABLE(iDb));\n    pName = pName1;\n  }else{\n    /* The common case */\n    iDb = sqlite3TwoPartName(pParse, pName1, pName2, &pName);\n    if( iDb<0 ) return;\n    if( !OMIT_TEMPDB && isTemp && pName2->n>0 && iDb!=1 ){\n      /* If creating a temp table, the name may not be qualified. Unless \n      ** the database name is \"temp\" anyway.  */\n      sqlite3ErrorMsg(pParse, \"temporary table name must be unqualified\");\n      return;\n    }\n    if( !OMIT_TEMPDB && isTemp ) iDb = 1;\n    zName = sqlite3NameFromToken(db, pName);\n    if( IN_RENAME_OBJECT ){\n      sqlite3RenameTokenMap(pParse, (void*)zName, pName);\n    }\n  }\n  pParse->sNameToken = *pName;\n  if( zName==0 ) return;\n  if( sqlite3CheckObjectName(pParse, zName, isView?\"view\":\"table\", zName) ){\n    goto begin_table_error;\n  }\n  if( db->init.iDb==1 ) isTemp = 1;\n#ifndef SQLITE_OMIT_AUTHORIZATION\n  assert( isTemp==0 || isTemp==1 );\n  assert( isView==0 || isView==1 );\n  {\n    static const u8 aCode[] = {\n       SQLITE_CREATE_TABLE,\n       SQLITE_CREATE_TEMP_TABLE,\n       SQLITE_CREATE_VIEW,\n       SQLITE_CREATE_TEMP_VIEW\n    };\n    char *zDb = db->aDb[iDb].zDbSName;\n    if( sqlite3AuthCheck(pParse, SQLITE_INSERT, SCHEMA_TABLE(isTemp), 0, zDb) ){\n      goto begin_table_error;\n    }\n    if( !isVirtual && sqlite3AuthCheck(pParse, (int)aCode[isTemp+2*isView],\n                                       zName, 0, zDb) ){\n      goto begin_table_error;\n    }\n  }\n#endif\n\n  /* Make sure the new table name does not collide with an existing\n  ** index or table name in the same database.  Issue an error message if\n  ** it does. The exception is if the statement being parsed was passed\n  ** to an sqlite3_declare_vtab() call. In that case only the column names\n  ** and types will be used, so there is no need to test for namespace\n  ** collisions.\n  */\n  if( !IN_SPECIAL_PARSE ){\n    char *zDb = db->aDb[iDb].zDbSName;\n    if( SQLITE_OK!=sqlite3ReadSchema(pParse) ){\n      goto begin_table_error;\n    }\n    pTable = sqlite3FindTable(db, zName, zDb);\n    if( pTable ){\n      if( !noErr ){\n        sqlite3ErrorMsg(pParse, \"table %T already exists\", pName);\n      }else{\n        assert( !db->init.busy || CORRUPT_DB );\n        sqlite3CodeVerifySchema(pParse, iDb);\n      }\n      goto begin_table_error;\n    }\n    if( sqlite3FindIndex(db, zName, zDb)!=0 ){\n      sqlite3ErrorMsg(pParse, \"there is already an index named %s\", zName);\n      goto begin_table_error;\n    }\n  }\n\n  pTable = sqlite3DbMallocZero(db, sizeof(Table));\n  if( pTable==0 ){\n    assert( db->mallocFailed );\n    pParse->rc = SQLITE_NOMEM_BKPT;\n    pParse->nErr++;\n    goto begin_table_error;\n  }\n  pTable->zName = zName;\n  pTable->iPKey = -1;\n  pTable->pSchema = db->aDb[iDb].pSchema;\n  pTable->nTabRef = 1;\n#ifdef SQLITE_DEFAULT_ROWEST\n  pTable->nRowLogEst = sqlite3LogEst(SQLITE_DEFAULT_ROWEST);\n#else\n  pTable->nRowLogEst = 200; assert( 200==sqlite3LogEst(1048576) );\n#endif\n  assert( pParse->pNewTable==0 );\n  pParse->pNewTable = pTable;\n\n  /* If this is the magic sqlite_sequence table used by autoincrement,\n  ** then record a pointer to this table in the main database structure\n  ** so that INSERT can find the table easily.\n  */\n#ifndef SQLITE_OMIT_AUTOINCREMENT\n  if( !pParse->nested && strcmp(zName, \"sqlite_sequence\")==0 ){\n    assert( sqlite3SchemaMutexHeld(db, iDb, 0) );\n    pTable->pSchema->pSeqTab = pTable;\n  }\n#endif\n\n  /* Begin generating the code that will insert the table record into\n  ** the SQLITE_MASTER table.  Note in particular that we must go ahead\n  ** and allocate the record number for the table entry now.  Before any\n  ** PRIMARY KEY or UNIQUE keywords are parsed.  Those keywords will cause\n  ** indices to be created and the table record must come before the \n  ** indices.  Hence, the record number for the table must be allocated\n  ** now.\n  */\n  if( !db->init.busy && (v = sqlite3GetVdbe(pParse))!=0 ){\n    int addr1;\n    int fileFormat;\n    int reg1, reg2, reg3;\n    /* nullRow[] is an OP_Record encoding of a row containing 5 NULLs */\n    static const char nullRow[] = { 6, 0, 0, 0, 0, 0 };\n    sqlite3BeginWriteOperation(pParse, 1, iDb);\n\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n    if( isVirtual ){\n      sqlite3VdbeAddOp0(v, OP_VBegin);\n    }\n#endif\n\n    /* If the file format and encoding in the database have not been set, \n    ** set them now.\n    */\n    reg1 = pParse->regRowid = ++pParse->nMem;\n    reg2 = pParse->regRoot = ++pParse->nMem;\n    reg3 = ++pParse->nMem;\n    sqlite3VdbeAddOp3(v, OP_ReadCookie, iDb, reg3, BTREE_FILE_FORMAT);\n    sqlite3VdbeUsesBtree(v, iDb);\n    addr1 = sqlite3VdbeAddOp1(v, OP_If, reg3); VdbeCoverage(v);\n    fileFormat = (db->flags & SQLITE_LegacyFileFmt)!=0 ?\n                  1 : SQLITE_MAX_FILE_FORMAT;\n    sqlite3VdbeAddOp3(v, OP_SetCookie, iDb, BTREE_FILE_FORMAT, fileFormat);\n    sqlite3VdbeAddOp3(v, OP_SetCookie, iDb, BTREE_TEXT_ENCODING, ENC(db));\n    sqlite3VdbeJumpHere(v, addr1);\n\n    /* This just creates a place-holder record in the sqlite_master table.\n    ** The record created does not contain anything yet.  It will be replaced\n    ** by the real entry in code generated at sqlite3EndTable().\n    **\n    ** The rowid for the new entry is left in register pParse->regRowid.\n    ** The root page number of the new table is left in reg pParse->regRoot.\n    ** The rowid and root page number values are needed by the code that\n    ** sqlite3EndTable will generate.\n    */\n#if !defined(SQLITE_OMIT_VIEW) || !defined(SQLITE_OMIT_VIRTUALTABLE)\n    if( isView || isVirtual ){\n      sqlite3VdbeAddOp2(v, OP_Integer, 0, reg2);\n    }else\n#endif\n    {\n      pParse->addrCrTab =\n         sqlite3VdbeAddOp3(v, OP_CreateBtree, iDb, reg2, BTREE_INTKEY);\n    }\n    sqlite3OpenMasterTable(pParse, iDb);\n    sqlite3VdbeAddOp2(v, OP_NewRowid, 0, reg1);\n    sqlite3VdbeAddOp4(v, OP_Blob, 6, reg3, 0, nullRow, P4_STATIC);\n    sqlite3VdbeAddOp3(v, OP_Insert, 0, reg3, reg1);\n    sqlite3VdbeChangeP5(v, OPFLAG_APPEND);\n    sqlite3VdbeAddOp0(v, OP_Close);\n  }\n\n  /* Normal (non-error) return. */\n  return;\n\n  /* If an error occurs, we jump here */\nbegin_table_error:\n  sqlite3DbFree(db, zName);\n  return;\n}\n\n/* Set properties of a table column based on the (magical)\n** name of the column.\n*/\n#if SQLITE_ENABLE_HIDDEN_COLUMNS\nvoid sqlite3ColumnPropertiesFromName(Table *pTab, Column *pCol){\n  if( sqlite3_strnicmp(pCol->zName, \"__hidden__\", 10)==0 ){\n    pCol->colFlags |= COLFLAG_HIDDEN;\n  }else if( pTab && pCol!=pTab->aCol && (pCol[-1].colFlags & COLFLAG_HIDDEN) ){\n    pTab->tabFlags |= TF_OOOHidden;\n  }\n}\n#endif\n\n\n/*\n** Add a new column to the table currently being constructed.\n**\n** The parser calls this routine once for each column declaration\n** in a CREATE TABLE statement.  sqlite3StartTable() gets called\n** first to get things going.  Then this routine is called for each\n** column.\n*/\nvoid sqlite3AddColumn(Parse *pParse, Token *pName, Token *pType){\n  Table *p;\n  int i;\n  char *z;\n  char *zType;\n  Column *pCol;\n  sqlite3 *db = pParse->db;\n  if( (p = pParse->pNewTable)==0 ) return;\n  if( p->nCol+1>db->aLimit[SQLITE_LIMIT_COLUMN] ){\n    sqlite3ErrorMsg(pParse, \"too many columns on %s\", p->zName);\n    return;\n  }\n  z = sqlite3DbMallocRaw(db, pName->n + pType->n + 2);\n  if( z==0 ) return;\n  if( IN_RENAME_OBJECT ) sqlite3RenameTokenMap(pParse, (void*)z, pName);\n  memcpy(z, pName->z, pName->n);\n  z[pName->n] = 0;\n  sqlite3Dequote(z);\n  for(i=0; i<p->nCol; i++){\n    if( sqlite3_stricmp(z, p->aCol[i].zName)==0 ){\n      sqlite3ErrorMsg(pParse, \"duplicate column name: %s\", z);\n      sqlite3DbFree(db, z);\n      return;\n    }\n  }\n  if( (p->nCol & 0x7)==0 ){\n    Column *aNew;\n    aNew = sqlite3DbRealloc(db,p->aCol,(p->nCol+8)*sizeof(p->aCol[0]));\n    if( aNew==0 ){\n      sqlite3DbFree(db, z);\n      return;\n    }\n    p->aCol = aNew;\n  }\n  pCol = &p->aCol[p->nCol];\n  memset(pCol, 0, sizeof(p->aCol[0]));\n  pCol->zName = z;\n  sqlite3ColumnPropertiesFromName(p, pCol);\n \n  if( pType->n==0 ){\n    /* If there is no type specified, columns have the default affinity\n    ** 'BLOB' with a default size of 4 bytes. */\n    pCol->affinity = SQLITE_AFF_BLOB;\n    pCol->szEst = 1;\n#ifdef SQLITE_ENABLE_SORTER_REFERENCES\n    if( 4>=sqlite3GlobalConfig.szSorterRef ){\n      pCol->colFlags |= COLFLAG_SORTERREF;\n    }\n#endif\n  }else{\n    zType = z + sqlite3Strlen30(z) + 1;\n    memcpy(zType, pType->z, pType->n);\n    zType[pType->n] = 0;\n    sqlite3Dequote(zType);\n    pCol->affinity = sqlite3AffinityType(zType, pCol);\n    pCol->colFlags |= COLFLAG_HASTYPE;\n  }\n  p->nCol++;\n  p->nNVCol++;\n  pParse->constraintName.n = 0;\n}\n\n/*\n** This routine is called by the parser while in the middle of\n** parsing a CREATE TABLE statement.  A \"NOT NULL\" constraint has\n** been seen on a column.  This routine sets the notNull flag on\n** the column currently under construction.\n*/\nvoid sqlite3AddNotNull(Parse *pParse, int onError){\n  Table *p;\n  Column *pCol;\n  p = pParse->pNewTable;\n  if( p==0 || NEVER(p->nCol<1) ) return;\n  pCol = &p->aCol[p->nCol-1];\n  pCol->notNull = (u8)onError;\n  p->tabFlags |= TF_HasNotNull;\n\n  /* Set the uniqNotNull flag on any UNIQUE or PK indexes already created\n  ** on this column.  */\n  if( pCol->colFlags & COLFLAG_UNIQUE ){\n    Index *pIdx;\n    for(pIdx=p->pIndex; pIdx; pIdx=pIdx->pNext){\n      assert( pIdx->nKeyCol==1 && pIdx->onError!=OE_None );\n      if( pIdx->aiColumn[0]==p->nCol-1 ){\n        pIdx->uniqNotNull = 1;\n      }\n    }\n  }\n}\n\n/*\n** Scan the column type name zType (length nType) and return the\n** associated affinity type.\n**\n** This routine does a case-independent search of zType for the \n** substrings in the following table. If one of the substrings is\n** found, the corresponding affinity is returned. If zType contains\n** more than one of the substrings, entries toward the top of \n** the table take priority. For example, if zType is 'BLOBINT', \n** SQLITE_AFF_INTEGER is returned.\n**\n** Substring     | Affinity\n** --------------------------------\n** 'INT'         | SQLITE_AFF_INTEGER\n** 'CHAR'        | SQLITE_AFF_TEXT\n** 'CLOB'        | SQLITE_AFF_TEXT\n** 'TEXT'        | SQLITE_AFF_TEXT\n** 'BLOB'        | SQLITE_AFF_BLOB\n** 'REAL'        | SQLITE_AFF_REAL\n** 'FLOA'        | SQLITE_AFF_REAL\n** 'DOUB'        | SQLITE_AFF_REAL\n**\n** If none of the substrings in the above table are found,\n** SQLITE_AFF_NUMERIC is returned.\n*/\nchar sqlite3AffinityType(const char *zIn, Column *pCol){\n  u32 h = 0;\n  char aff = SQLITE_AFF_NUMERIC;\n  const char *zChar = 0;\n\n  assert( zIn!=0 );\n  while( zIn[0] ){\n    h = (h<<8) + sqlite3UpperToLower[(*zIn)&0xff];\n    zIn++;\n    if( h==(('c'<<24)+('h'<<16)+('a'<<8)+'r') ){             /* CHAR */\n      aff = SQLITE_AFF_TEXT;\n      zChar = zIn;\n    }else if( h==(('c'<<24)+('l'<<16)+('o'<<8)+'b') ){       /* CLOB */\n      aff = SQLITE_AFF_TEXT;\n    }else if( h==(('t'<<24)+('e'<<16)+('x'<<8)+'t') ){       /* TEXT */\n      aff = SQLITE_AFF_TEXT;\n    }else if( h==(('b'<<24)+('l'<<16)+('o'<<8)+'b')          /* BLOB */\n        && (aff==SQLITE_AFF_NUMERIC || aff==SQLITE_AFF_REAL) ){\n      aff = SQLITE_AFF_BLOB;\n      if( zIn[0]=='(' ) zChar = zIn;\n#ifndef SQLITE_OMIT_FLOATING_POINT\n    }else if( h==(('r'<<24)+('e'<<16)+('a'<<8)+'l')          /* REAL */\n        && aff==SQLITE_AFF_NUMERIC ){\n      aff = SQLITE_AFF_REAL;\n    }else if( h==(('f'<<24)+('l'<<16)+('o'<<8)+'a')          /* FLOA */\n        && aff==SQLITE_AFF_NUMERIC ){\n      aff = SQLITE_AFF_REAL;\n    }else if( h==(('d'<<24)+('o'<<16)+('u'<<8)+'b')          /* DOUB */\n        && aff==SQLITE_AFF_NUMERIC ){\n      aff = SQLITE_AFF_REAL;\n#endif\n    }else if( (h&0x00FFFFFF)==(('i'<<16)+('n'<<8)+'t') ){    /* INT */\n      aff = SQLITE_AFF_INTEGER;\n      break;\n    }\n  }\n\n  /* If pCol is not NULL, store an estimate of the field size.  The\n  ** estimate is scaled so that the size of an integer is 1.  */\n  if( pCol ){\n    int v = 0;   /* default size is approx 4 bytes */\n    if( aff<SQLITE_AFF_NUMERIC ){\n      if( zChar ){\n        while( zChar[0] ){\n          if( sqlite3Isdigit(zChar[0]) ){\n            /* BLOB(k), VARCHAR(k), CHAR(k) -> r=(k/4+1) */\n            sqlite3GetInt32(zChar, &v);\n            break;\n          }\n          zChar++;\n        }\n      }else{\n        v = 16;   /* BLOB, TEXT, CLOB -> r=5  (approx 20 bytes)*/\n      }\n    }\n#ifdef SQLITE_ENABLE_SORTER_REFERENCES\n    if( v>=sqlite3GlobalConfig.szSorterRef ){\n      pCol->colFlags |= COLFLAG_SORTERREF;\n    }\n#endif\n    v = v/4 + 1;\n    if( v>255 ) v = 255;\n    pCol->szEst = v;\n  }\n  return aff;\n}\n\n/*\n** The expression is the default value for the most recently added column\n** of the table currently under construction.\n**\n** Default value expressions must be constant.  Raise an exception if this\n** is not the case.\n**\n** This routine is called by the parser while in the middle of\n** parsing a CREATE TABLE statement.\n*/\nvoid sqlite3AddDefaultValue(\n  Parse *pParse,           /* Parsing context */\n  Expr *pExpr,             /* The parsed expression of the default value */\n  const char *zStart,      /* Start of the default value text */\n  const char *zEnd         /* First character past end of defaut value text */\n){\n  Table *p;\n  Column *pCol;\n  sqlite3 *db = pParse->db;\n  p = pParse->pNewTable;\n  if( p!=0 ){\n    pCol = &(p->aCol[p->nCol-1]);\n    if( !sqlite3ExprIsConstantOrFunction(pExpr, db->init.busy) ){\n      sqlite3ErrorMsg(pParse, \"default value of column [%s] is not constant\",\n          pCol->zName);\n#ifndef SQLITE_OMIT_GENERATED_COLUMNS\n    }else if( pCol->colFlags & COLFLAG_GENERATED ){\n      testcase( pCol->colFlags & COLFLAG_VIRTUAL );\n      testcase( pCol->colFlags & COLFLAG_STORED );\n      sqlite3ErrorMsg(pParse, \"cannot use DEFAULT on a generated column\");\n#endif\n    }else{\n      /* A copy of pExpr is used instead of the original, as pExpr contains\n      ** tokens that point to volatile memory.\n      */\n      Expr x;\n      sqlite3ExprDelete(db, pCol->pDflt);\n      memset(&x, 0, sizeof(x));\n      x.op = TK_SPAN;\n      x.u.zToken = sqlite3DbSpanDup(db, zStart, zEnd);\n      x.pLeft = pExpr;\n      x.flags = EP_Skip;\n      pCol->pDflt = sqlite3ExprDup(db, &x, EXPRDUP_REDUCE);\n      sqlite3DbFree(db, x.u.zToken);\n    }\n  }\n  if( IN_RENAME_OBJECT ){\n    sqlite3RenameExprUnmap(pParse, pExpr);\n  }\n  sqlite3ExprDelete(db, pExpr);\n}\n\n/*\n** Backwards Compatibility Hack:\n** \n** Historical versions of SQLite accepted strings as column names in\n** indexes and PRIMARY KEY constraints and in UNIQUE constraints.  Example:\n**\n**     CREATE TABLE xyz(a,b,c,d,e,PRIMARY KEY('a'),UNIQUE('b','c' COLLATE trim)\n**     CREATE INDEX abc ON xyz('c','d' DESC,'e' COLLATE nocase DESC);\n**\n** This is goofy.  But to preserve backwards compatibility we continue to\n** accept it.  This routine does the necessary conversion.  It converts\n** the expression given in its argument from a TK_STRING into a TK_ID\n** if the expression is just a TK_STRING with an optional COLLATE clause.\n** If the expression is anything other than TK_STRING, the expression is\n** unchanged.\n*/\nstatic void sqlite3StringToId(Expr *p){\n  if( p->op==TK_STRING ){\n    p->op = TK_ID;\n  }else if( p->op==TK_COLLATE && p->pLeft->op==TK_STRING ){\n    p->pLeft->op = TK_ID;\n  }\n}\n\n/*\n** Tag the given column as being part of the PRIMARY KEY\n*/\nstatic void makeColumnPartOfPrimaryKey(Parse *pParse, Column *pCol){\n  pCol->colFlags |= COLFLAG_PRIMKEY;\n#ifndef SQLITE_OMIT_GENERATED_COLUMNS\n  if( pCol->colFlags & COLFLAG_GENERATED ){\n    testcase( pCol->colFlags & COLFLAG_VIRTUAL );\n    testcase( pCol->colFlags & COLFLAG_STORED );\n    sqlite3ErrorMsg(pParse,\n      \"generated columns cannot be part of the PRIMARY KEY\");\n  }\n#endif          \n}\n\n/*\n** Designate the PRIMARY KEY for the table.  pList is a list of names \n** of columns that form the primary key.  If pList is NULL, then the\n** most recently added column of the table is the primary key.\n**\n** A table can have at most one primary key.  If the table already has\n** a primary key (and this is the second primary key) then create an\n** error.\n**\n** If the PRIMARY KEY is on a single column whose datatype is INTEGER,\n** then we will try to use that column as the rowid.  Set the Table.iPKey\n** field of the table under construction to be the index of the\n** INTEGER PRIMARY KEY column.  Table.iPKey is set to -1 if there is\n** no INTEGER PRIMARY KEY.\n**\n** If the key is not an INTEGER PRIMARY KEY, then create a unique\n** index for the key.  No index is created for INTEGER PRIMARY KEYs.\n*/\nvoid sqlite3AddPrimaryKey(\n  Parse *pParse,    /* Parsing context */\n  ExprList *pList,  /* List of field names to be indexed */\n  int onError,      /* What to do with a uniqueness conflict */\n  int autoInc,      /* True if the AUTOINCREMENT keyword is present */\n  int sortOrder     /* SQLITE_SO_ASC or SQLITE_SO_DESC */\n){\n  Table *pTab = pParse->pNewTable;\n  Column *pCol = 0;\n  int iCol = -1, i;\n  int nTerm;\n  if( pTab==0 ) goto primary_key_exit;\n  if( pTab->tabFlags & TF_HasPrimaryKey ){\n    sqlite3ErrorMsg(pParse, \n      \"table \\\"%s\\\" has more than one primary key\", pTab->zName);\n    goto primary_key_exit;\n  }\n  pTab->tabFlags |= TF_HasPrimaryKey;\n  if( pList==0 ){\n    iCol = pTab->nCol - 1;\n    pCol = &pTab->aCol[iCol];\n    makeColumnPartOfPrimaryKey(pParse, pCol);\n    nTerm = 1;\n  }else{\n    nTerm = pList->nExpr;\n    for(i=0; i<nTerm; i++){\n      Expr *pCExpr = sqlite3ExprSkipCollate(pList->a[i].pExpr);\n      assert( pCExpr!=0 );\n      sqlite3StringToId(pCExpr);\n      if( pCExpr->op==TK_ID ){\n        const char *zCName = pCExpr->u.zToken;\n        for(iCol=0; iCol<pTab->nCol; iCol++){\n          if( sqlite3StrICmp(zCName, pTab->aCol[iCol].zName)==0 ){\n            pCol = &pTab->aCol[iCol];\n            makeColumnPartOfPrimaryKey(pParse, pCol);\n            break;\n          }\n        }\n      }\n    }\n  }\n  if( nTerm==1\n   && pCol\n   && sqlite3StrICmp(sqlite3ColumnType(pCol,\"\"), \"INTEGER\")==0\n   && sortOrder!=SQLITE_SO_DESC\n  ){\n    if( IN_RENAME_OBJECT && pList ){\n      Expr *pCExpr = sqlite3ExprSkipCollate(pList->a[0].pExpr);\n      sqlite3RenameTokenRemap(pParse, &pTab->iPKey, pCExpr);\n    }\n    pTab->iPKey = iCol;\n    pTab->keyConf = (u8)onError;\n    assert( autoInc==0 || autoInc==1 );\n    pTab->tabFlags |= autoInc*TF_Autoincrement;\n    if( pList ) pParse->iPkSortOrder = pList->a[0].sortFlags;\n  }else if( autoInc ){\n#ifndef SQLITE_OMIT_AUTOINCREMENT\n    sqlite3ErrorMsg(pParse, \"AUTOINCREMENT is only allowed on an \"\n       \"INTEGER PRIMARY KEY\");\n#endif\n  }else{\n    sqlite3CreateIndex(pParse, 0, 0, 0, pList, onError, 0,\n                           0, sortOrder, 0, SQLITE_IDXTYPE_PRIMARYKEY);\n    pList = 0;\n  }\n\nprimary_key_exit:\n  sqlite3ExprListDelete(pParse->db, pList);\n  return;\n}\n\n/*\n** Add a new CHECK constraint to the table currently under construction.\n*/\nvoid sqlite3AddCheckConstraint(\n  Parse *pParse,    /* Parsing context */\n  Expr *pCheckExpr  /* The check expression */\n){\n#ifndef SQLITE_OMIT_CHECK\n  Table *pTab = pParse->pNewTable;\n  sqlite3 *db = pParse->db;\n  if( pTab && !IN_DECLARE_VTAB\n   && !sqlite3BtreeIsReadonly(db->aDb[db->init.iDb].pBt)\n  ){\n    pTab->pCheck = sqlite3ExprListAppend(pParse, pTab->pCheck, pCheckExpr);\n    if( pParse->constraintName.n ){\n      sqlite3ExprListSetName(pParse, pTab->pCheck, &pParse->constraintName, 1);\n    }\n  }else\n#endif\n  {\n    sqlite3ExprDelete(pParse->db, pCheckExpr);\n  }\n}\n\n/*\n** Set the collation function of the most recently parsed table column\n** to the CollSeq given.\n*/\nvoid sqlite3AddCollateType(Parse *pParse, Token *pToken){\n  Table *p;\n  int i;\n  char *zColl;              /* Dequoted name of collation sequence */\n  sqlite3 *db;\n\n  if( (p = pParse->pNewTable)==0 ) return;\n  i = p->nCol-1;\n  db = pParse->db;\n  zColl = sqlite3NameFromToken(db, pToken);\n  if( !zColl ) return;\n\n  if( sqlite3LocateCollSeq(pParse, zColl) ){\n    Index *pIdx;\n    sqlite3DbFree(db, p->aCol[i].zColl);\n    p->aCol[i].zColl = zColl;\n  \n    /* If the column is declared as \"<name> PRIMARY KEY COLLATE <type>\",\n    ** then an index may have been created on this column before the\n    ** collation type was added. Correct this if it is the case.\n    */\n    for(pIdx=p->pIndex; pIdx; pIdx=pIdx->pNext){\n      assert( pIdx->nKeyCol==1 );\n      if( pIdx->aiColumn[0]==i ){\n        pIdx->azColl[0] = p->aCol[i].zColl;\n      }\n    }\n  }else{\n    sqlite3DbFree(db, zColl);\n  }\n}\n\n/* Change the most recently parsed column to be a GENERATED ALWAYS AS\n** column.\n*/\nvoid sqlite3AddGenerated(Parse *pParse, Expr *pExpr, Token *pType){\n#ifndef SQLITE_OMIT_GENERATED_COLUMNS\n  u8 eType = COLFLAG_VIRTUAL;\n  Table *pTab = pParse->pNewTable;\n  Column *pCol;\n  if( pTab==0 ){\n    /* generated column in an CREATE TABLE IF NOT EXISTS that already exists */\n    goto generated_done;\n  }\n  pCol = &(pTab->aCol[pTab->nCol-1]);\n  if( IN_DECLARE_VTAB ){\n    sqlite3ErrorMsg(pParse, \"virtual tables cannot use computed columns\");\n    goto generated_done;\n  }\n  if( pCol->pDflt ) goto generated_error;\n  if( pType ){\n    if( pType->n==7 && sqlite3StrNICmp(\"virtual\",pType->z,7)==0 ){\n      /* no-op */\n    }else if( pType->n==6 && sqlite3StrNICmp(\"stored\",pType->z,6)==0 ){\n      eType = COLFLAG_STORED;\n    }else{\n      goto generated_error;\n    }\n  }\n  if( eType==COLFLAG_VIRTUAL ) pTab->nNVCol--;\n  pCol->colFlags |= eType;\n  assert( TF_HasVirtual==COLFLAG_VIRTUAL );\n  assert( TF_HasStored==COLFLAG_STORED );\n  pTab->tabFlags |= eType;\n  if( pCol->colFlags & COLFLAG_PRIMKEY ){\n    makeColumnPartOfPrimaryKey(pParse, pCol); /* For the error message */\n  }\n  pCol->pDflt = pExpr;\n  pExpr = 0;\n  goto generated_done;\n\ngenerated_error:\n  sqlite3ErrorMsg(pParse, \"error in generated column \\\"%s\\\"\",\n                  pCol->zName);\ngenerated_done:\n  sqlite3ExprDelete(pParse->db, pExpr);\n#else\n  /* Throw and error for the GENERATED ALWAYS AS clause if the\n  ** SQLITE_OMIT_GENERATED_COLUMNS compile-time option is used. */\n  sqlite3ErrorMsg(pParse, \"generated columns not supported\");\n  sqlite3ExprDelete(pParse->db, pExpr);\n#endif\n}\n\n/*\n** Generate code that will increment the schema cookie.\n**\n** The schema cookie is used to determine when the schema for the\n** database changes.  After each schema change, the cookie value\n** changes.  When a process first reads the schema it records the\n** cookie.  Thereafter, whenever it goes to access the database,\n** it checks the cookie to make sure the schema has not changed\n** since it was last read.\n**\n** This plan is not completely bullet-proof.  It is possible for\n** the schema to change multiple times and for the cookie to be\n** set back to prior value.  But schema changes are infrequent\n** and the probability of hitting the same cookie value is only\n** 1 chance in 2^32.  So we're safe enough.\n**\n** IMPLEMENTATION-OF: R-34230-56049 SQLite automatically increments\n** the schema-version whenever the schema changes.\n*/\nvoid sqlite3ChangeCookie(Parse *pParse, int iDb){\n  sqlite3 *db = pParse->db;\n  Vdbe *v = pParse->pVdbe;\n  assert( sqlite3SchemaMutexHeld(db, iDb, 0) );\n  sqlite3VdbeAddOp3(v, OP_SetCookie, iDb, BTREE_SCHEMA_VERSION, \n                   (int)(1+(unsigned)db->aDb[iDb].pSchema->schema_cookie));\n}\n\n/*\n** Measure the number of characters needed to output the given\n** identifier.  The number returned includes any quotes used\n** but does not include the null terminator.\n**\n** The estimate is conservative.  It might be larger that what is\n** really needed.\n*/\nstatic int identLength(const char *z){\n  int n;\n  for(n=0; *z; n++, z++){\n    if( *z=='\"' ){ n++; }\n  }\n  return n + 2;\n}\n\n/*\n** The first parameter is a pointer to an output buffer. The second \n** parameter is a pointer to an integer that contains the offset at\n** which to write into the output buffer. This function copies the\n** nul-terminated string pointed to by the third parameter, zSignedIdent,\n** to the specified offset in the buffer and updates *pIdx to refer\n** to the first byte after the last byte written before returning.\n** \n** If the string zSignedIdent consists entirely of alpha-numeric\n** characters, does not begin with a digit and is not an SQL keyword,\n** then it is copied to the output buffer exactly as it is. Otherwise,\n** it is quoted using double-quotes.\n*/\nstatic void identPut(char *z, int *pIdx, char *zSignedIdent){\n  unsigned char *zIdent = (unsigned char*)zSignedIdent;\n  int i, j, needQuote;\n  i = *pIdx;\n\n  for(j=0; zIdent[j]; j++){\n    if( !sqlite3Isalnum(zIdent[j]) && zIdent[j]!='_' ) break;\n  }\n  needQuote = sqlite3Isdigit(zIdent[0])\n            || sqlite3KeywordCode(zIdent, j)!=TK_ID\n            || zIdent[j]!=0\n            || j==0;\n\n  if( needQuote ) z[i++] = '\"';\n  for(j=0; zIdent[j]; j++){\n    z[i++] = zIdent[j];\n    if( zIdent[j]=='\"' ) z[i++] = '\"';\n  }\n  if( needQuote ) z[i++] = '\"';\n  z[i] = 0;\n  *pIdx = i;\n}\n\n/*\n** Generate a CREATE TABLE statement appropriate for the given\n** table.  Memory to hold the text of the statement is obtained\n** from sqliteMalloc() and must be freed by the calling function.\n*/\nstatic char *createTableStmt(sqlite3 *db, Table *p){\n  int i, k, n;\n  char *zStmt;\n  char *zSep, *zSep2, *zEnd;\n  Column *pCol;\n  n = 0;\n  for(pCol = p->aCol, i=0; i<p->nCol; i++, pCol++){\n    n += identLength(pCol->zName) + 5;\n  }\n  n += identLength(p->zName);\n  if( n<50 ){ \n    zSep = \"\";\n    zSep2 = \",\";\n    zEnd = \")\";\n  }else{\n    zSep = \"\\n  \";\n    zSep2 = \",\\n  \";\n    zEnd = \"\\n)\";\n  }\n  n += 35 + 6*p->nCol;\n  zStmt = sqlite3DbMallocRaw(0, n);\n  if( zStmt==0 ){\n    sqlite3OomFault(db);\n    return 0;\n  }\n  sqlite3_snprintf(n, zStmt, \"CREATE TABLE \");\n  k = sqlite3Strlen30(zStmt);\n  identPut(zStmt, &k, p->zName);\n  zStmt[k++] = '(';\n  for(pCol=p->aCol, i=0; i<p->nCol; i++, pCol++){\n    static const char * const azType[] = {\n        /* SQLITE_AFF_BLOB    */ \"\",\n        /* SQLITE_AFF_TEXT    */ \" TEXT\",\n        /* SQLITE_AFF_NUMERIC */ \" NUM\",\n        /* SQLITE_AFF_INTEGER */ \" INT\",\n        /* SQLITE_AFF_REAL    */ \" REAL\"\n    };\n    int len;\n    const char *zType;\n\n    sqlite3_snprintf(n-k, &zStmt[k], zSep);\n    k += sqlite3Strlen30(&zStmt[k]);\n    zSep = zSep2;\n    identPut(zStmt, &k, pCol->zName);\n    assert( pCol->affinity-SQLITE_AFF_BLOB >= 0 );\n    assert( pCol->affinity-SQLITE_AFF_BLOB < ArraySize(azType) );\n    testcase( pCol->affinity==SQLITE_AFF_BLOB );\n    testcase( pCol->affinity==SQLITE_AFF_TEXT );\n    testcase( pCol->affinity==SQLITE_AFF_NUMERIC );\n    testcase( pCol->affinity==SQLITE_AFF_INTEGER );\n    testcase( pCol->affinity==SQLITE_AFF_REAL );\n    \n    zType = azType[pCol->affinity - SQLITE_AFF_BLOB];\n    len = sqlite3Strlen30(zType);\n    assert( pCol->affinity==SQLITE_AFF_BLOB \n            || pCol->affinity==sqlite3AffinityType(zType, 0) );\n    memcpy(&zStmt[k], zType, len);\n    k += len;\n    assert( k<=n );\n  }\n  sqlite3_snprintf(n-k, &zStmt[k], \"%s\", zEnd);\n  return zStmt;\n}\n\n/*\n** Resize an Index object to hold N columns total.  Return SQLITE_OK\n** on success and SQLITE_NOMEM on an OOM error.\n*/\nstatic int resizeIndexObject(sqlite3 *db, Index *pIdx, int N){\n  char *zExtra;\n  int nByte;\n  if( pIdx->nColumn>=N ) return SQLITE_OK;\n  assert( pIdx->isResized==0 );\n  nByte = (sizeof(char*) + sizeof(i16) + 1)*N;\n  zExtra = sqlite3DbMallocZero(db, nByte);\n  if( zExtra==0 ) return SQLITE_NOMEM_BKPT;\n  memcpy(zExtra, pIdx->azColl, sizeof(char*)*pIdx->nColumn);\n  pIdx->azColl = (const char**)zExtra;\n  zExtra += sizeof(char*)*N;\n  memcpy(zExtra, pIdx->aiColumn, sizeof(i16)*pIdx->nColumn);\n  pIdx->aiColumn = (i16*)zExtra;\n  zExtra += sizeof(i16)*N;\n  memcpy(zExtra, pIdx->aSortOrder, pIdx->nColumn);\n  pIdx->aSortOrder = (u8*)zExtra;\n  pIdx->nColumn = N;\n  pIdx->isResized = 1;\n  return SQLITE_OK;\n}\n\n/*\n** Estimate the total row width for a table.\n*/\nstatic void estimateTableWidth(Table *pTab){\n  unsigned wTable = 0;\n  const Column *pTabCol;\n  int i;\n  for(i=pTab->nCol, pTabCol=pTab->aCol; i>0; i--, pTabCol++){\n    wTable += pTabCol->szEst;\n  }\n  if( pTab->iPKey<0 ) wTable++;\n  pTab->szTabRow = sqlite3LogEst(wTable*4);\n}\n\n/*\n** Estimate the average size of a row for an index.\n*/\nstatic void estimateIndexWidth(Index *pIdx){\n  unsigned wIndex = 0;\n  int i;\n  const Column *aCol = pIdx->pTable->aCol;\n  for(i=0; i<pIdx->nColumn; i++){\n    i16 x = pIdx->aiColumn[i];\n    assert( x<pIdx->pTable->nCol );\n    wIndex += x<0 ? 1 : aCol[pIdx->aiColumn[i]].szEst;\n  }\n  pIdx->szIdxRow = sqlite3LogEst(wIndex*4);\n}\n\n/* Return true if column number x is any of the first nCol entries of aiCol[].\n** This is used to determine if the column number x appears in any of the\n** first nCol entries of an index.\n*/\nstatic int hasColumn(const i16 *aiCol, int nCol, int x){\n  while( nCol-- > 0 ){\n    assert( aiCol[0]>=0 );\n    if( x==*(aiCol++) ){\n      return 1;\n    }\n  }\n  return 0;\n}\n\n/*\n** Return true if any of the first nKey entries of index pIdx exactly\n** match the iCol-th entry of pPk.  pPk is always a WITHOUT ROWID\n** PRIMARY KEY index.  pIdx is an index on the same table.  pIdx may\n** or may not be the same index as pPk.\n**\n** The first nKey entries of pIdx are guaranteed to be ordinary columns,\n** not a rowid or expression.\n**\n** This routine differs from hasColumn() in that both the column and the\n** collating sequence must match for this routine, but for hasColumn() only\n** the column name must match.\n*/\nstatic int isDupColumn(Index *pIdx, int nKey, Index *pPk, int iCol){\n  int i, j;\n  assert( nKey<=pIdx->nColumn );\n  assert( iCol<MAX(pPk->nColumn,pPk->nKeyCol) );\n  assert( pPk->idxType==SQLITE_IDXTYPE_PRIMARYKEY );\n  assert( pPk->pTable->tabFlags & TF_WithoutRowid );\n  assert( pPk->pTable==pIdx->pTable );\n  testcase( pPk==pIdx );\n  j = pPk->aiColumn[iCol];\n  assert( j!=XN_ROWID && j!=XN_EXPR );\n  for(i=0; i<nKey; i++){\n    assert( pIdx->aiColumn[i]>=0 || j>=0 );\n    if( pIdx->aiColumn[i]==j \n     && sqlite3StrICmp(pIdx->azColl[i], pPk->azColl[iCol])==0\n    ){\n      return 1;\n    }\n  }\n  return 0;\n}\n\n/* Recompute the colNotIdxed field of the Index.\n**\n** colNotIdxed is a bitmask that has a 0 bit representing each indexed\n** columns that are within the first 63 columns of the table.  The\n** high-order bit of colNotIdxed is always 1.  All unindexed columns\n** of the table have a 1.\n**\n** 2019-10-24:  For the purpose of this computation, virtual columns are\n** not considered to be covered by the index, even if they are in the\n** index, because we do not trust the logic in whereIndexExprTrans() to be\n** able to find all instances of a reference to the indexed table column\n** and convert them into references to the index.  Hence we always want\n** the actual table at hand in order to recompute the virtual column, if\n** necessary.\n**\n** The colNotIdxed mask is AND-ed with the SrcList.a[].colUsed mask\n** to determine if the index is covering index.\n*/\nstatic void recomputeColumnsNotIndexed(Index *pIdx){\n  Bitmask m = 0;\n  int j;\n  Table *pTab = pIdx->pTable;\n  for(j=pIdx->nColumn-1; j>=0; j--){\n    int x = pIdx->aiColumn[j];\n    if( x>=0 && (pTab->aCol[x].colFlags & COLFLAG_VIRTUAL)==0 ){\n      testcase( x==BMS-1 );\n      testcase( x==BMS-2 );\n      if( x<BMS-1 ) m |= MASKBIT(x);\n    }\n  }\n  pIdx->colNotIdxed = ~m;\n  assert( (pIdx->colNotIdxed>>63)==1 );\n}\n\n/*\n** This routine runs at the end of parsing a CREATE TABLE statement that\n** has a WITHOUT ROWID clause.  The job of this routine is to convert both\n** internal schema data structures and the generated VDBE code so that they\n** are appropriate for a WITHOUT ROWID table instead of a rowid table.\n** Changes include:\n**\n**     (1)  Set all columns of the PRIMARY KEY schema object to be NOT NULL.\n**     (2)  Convert P3 parameter of the OP_CreateBtree from BTREE_INTKEY \n**          into BTREE_BLOBKEY.\n**     (3)  Bypass the creation of the sqlite_master table entry\n**          for the PRIMARY KEY as the primary key index is now\n**          identified by the sqlite_master table entry of the table itself.\n**     (4)  Set the Index.tnum of the PRIMARY KEY Index object in the\n**          schema to the rootpage from the main table.\n**     (5)  Add all table columns to the PRIMARY KEY Index object\n**          so that the PRIMARY KEY is a covering index.  The surplus\n**          columns are part of KeyInfo.nAllField and are not used for\n**          sorting or lookup or uniqueness checks.\n**     (6)  Replace the rowid tail on all automatically generated UNIQUE\n**          indices with the PRIMARY KEY columns.\n**\n** For virtual tables, only (1) is performed.\n*/\nstatic void convertToWithoutRowidTable(Parse *pParse, Table *pTab){\n  Index *pIdx;\n  Index *pPk;\n  int nPk;\n  int nExtra;\n  int i, j;\n  sqlite3 *db = pParse->db;\n  Vdbe *v = pParse->pVdbe;\n\n  /* Mark every PRIMARY KEY column as NOT NULL (except for imposter tables)\n  */\n  if( !db->init.imposterTable ){\n    for(i=0; i<pTab->nCol; i++){\n      if( (pTab->aCol[i].colFlags & COLFLAG_PRIMKEY)!=0 ){\n        pTab->aCol[i].notNull = OE_Abort;\n      }\n    }\n    pTab->tabFlags |= TF_HasNotNull;\n  }\n\n  /* Convert the P3 operand of the OP_CreateBtree opcode from BTREE_INTKEY\n  ** into BTREE_BLOBKEY.\n  */\n  if( pParse->addrCrTab ){\n    assert( v );\n    sqlite3VdbeChangeP3(v, pParse->addrCrTab, BTREE_BLOBKEY);\n  }\n\n  /* Locate the PRIMARY KEY index.  Or, if this table was originally\n  ** an INTEGER PRIMARY KEY table, create a new PRIMARY KEY index. \n  */\n  if( pTab->iPKey>=0 ){\n    ExprList *pList;\n    Token ipkToken;\n    sqlite3TokenInit(&ipkToken, pTab->aCol[pTab->iPKey].zName);\n    pList = sqlite3ExprListAppend(pParse, 0, \n                  sqlite3ExprAlloc(db, TK_ID, &ipkToken, 0));\n    if( pList==0 ) return;\n    if( IN_RENAME_OBJECT ){\n      sqlite3RenameTokenRemap(pParse, pList->a[0].pExpr, &pTab->iPKey);\n    }\n    pList->a[0].sortFlags = pParse->iPkSortOrder;\n    assert( pParse->pNewTable==pTab );\n    pTab->iPKey = -1;\n    sqlite3CreateIndex(pParse, 0, 0, 0, pList, pTab->keyConf, 0, 0, 0, 0,\n                       SQLITE_IDXTYPE_PRIMARYKEY);\n    if( db->mallocFailed || pParse->nErr ) return;\n    pPk = sqlite3PrimaryKeyIndex(pTab);\n    assert( pPk->nKeyCol==1 );\n  }else{\n    pPk = sqlite3PrimaryKeyIndex(pTab);\n    assert( pPk!=0 );\n\n    /*\n    ** Remove all redundant columns from the PRIMARY KEY.  For example, change\n    ** \"PRIMARY KEY(a,b,a,b,c,b,c,d)\" into just \"PRIMARY KEY(a,b,c,d)\".  Later\n    ** code assumes the PRIMARY KEY contains no repeated columns.\n    */\n    for(i=j=1; i<pPk->nKeyCol; i++){\n      if( isDupColumn(pPk, j, pPk, i) ){\n        pPk->nColumn--;\n      }else{\n        testcase( hasColumn(pPk->aiColumn, j, pPk->aiColumn[i]) );\n        pPk->azColl[j] = pPk->azColl[i];\n        pPk->aSortOrder[j] = pPk->aSortOrder[i];\n        pPk->aiColumn[j++] = pPk->aiColumn[i];\n      }\n    }\n    pPk->nKeyCol = j;\n  }\n  assert( pPk!=0 );\n  pPk->isCovering = 1;\n  if( !db->init.imposterTable ) pPk->uniqNotNull = 1;\n  nPk = pPk->nColumn = pPk->nKeyCol;\n\n  /* Bypass the creation of the PRIMARY KEY btree and the sqlite_master\n  ** table entry. This is only required if currently generating VDBE\n  ** code for a CREATE TABLE (not when parsing one as part of reading\n  ** a database schema).  */\n  if( v && pPk->tnum>0 ){\n    assert( db->init.busy==0 );\n    sqlite3VdbeChangeOpcode(v, pPk->tnum, OP_Goto);\n  }\n\n  /* The root page of the PRIMARY KEY is the table root page */\n  pPk->tnum = pTab->tnum;\n\n  /* Update the in-memory representation of all UNIQUE indices by converting\n  ** the final rowid column into one or more columns of the PRIMARY KEY.\n  */\n  for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){\n    int n;\n    if( IsPrimaryKeyIndex(pIdx) ) continue;\n    for(i=n=0; i<nPk; i++){\n      if( !isDupColumn(pIdx, pIdx->nKeyCol, pPk, i) ){\n        testcase( hasColumn(pIdx->aiColumn, pIdx->nKeyCol, pPk->aiColumn[i]) );\n        n++;\n      }\n    }\n    if( n==0 ){\n      /* This index is a superset of the primary key */\n      pIdx->nColumn = pIdx->nKeyCol;\n      continue;\n    }\n    if( resizeIndexObject(db, pIdx, pIdx->nKeyCol+n) ) return;\n    for(i=0, j=pIdx->nKeyCol; i<nPk; i++){\n      if( !isDupColumn(pIdx, pIdx->nKeyCol, pPk, i) ){\n        testcase( hasColumn(pIdx->aiColumn, pIdx->nKeyCol, pPk->aiColumn[i]) );\n        pIdx->aiColumn[j] = pPk->aiColumn[i];\n        pIdx->azColl[j] = pPk->azColl[i];\n        if( pPk->aSortOrder[i] ){\n          /* See ticket https://www.sqlite.org/src/info/bba7b69f9849b5bf */\n          pIdx->bAscKeyBug = 1;\n        }\n        j++;\n      }\n    }\n    assert( pIdx->nColumn>=pIdx->nKeyCol+n );\n    assert( pIdx->nColumn>=j );\n  }\n\n  /* Add all table columns to the PRIMARY KEY index\n  */\n  nExtra = 0;\n  for(i=0; i<pTab->nCol; i++){\n    if( !hasColumn(pPk->aiColumn, nPk, i)\n     && (pTab->aCol[i].colFlags & COLFLAG_VIRTUAL)==0 ) nExtra++;\n  }\n  if( resizeIndexObject(db, pPk, nPk+nExtra) ) return;\n  for(i=0, j=nPk; i<pTab->nCol; i++){\n    if( !hasColumn(pPk->aiColumn, j, i)\n     && (pTab->aCol[i].colFlags & COLFLAG_VIRTUAL)==0\n    ){\n      assert( j<pPk->nColumn );\n      pPk->aiColumn[j] = i;\n      pPk->azColl[j] = sqlite3StrBINARY;\n      j++;\n    }\n  }\n  assert( pPk->nColumn==j );\n  assert( pTab->nNVCol<=j );\n  recomputeColumnsNotIndexed(pPk);\n}\n\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n/*\n** Return true if zName is a shadow table name in the current database\n** connection.\n**\n** zName is temporarily modified while this routine is running, but is\n** restored to its original value prior to this routine returning.\n*/\nint sqlite3ShadowTableName(sqlite3 *db, const char *zName){\n  char *zTail;                  /* Pointer to the last \"_\" in zName */\n  Table *pTab;                  /* Table that zName is a shadow of */\n  Module *pMod;                 /* Module for the virtual table */\n\n  zTail = strrchr(zName, '_');\n  if( zTail==0 ) return 0;\n  *zTail = 0;\n  pTab = sqlite3FindTable(db, zName, 0);\n  *zTail = '_';\n  if( pTab==0 ) return 0;\n  if( !IsVirtual(pTab) ) return 0;\n  pMod = (Module*)sqlite3HashFind(&db->aModule, pTab->azModuleArg[0]);\n  if( pMod==0 ) return 0;\n  if( pMod->pModule->iVersion<3 ) return 0;\n  if( pMod->pModule->xShadowName==0 ) return 0;\n  return pMod->pModule->xShadowName(zTail+1);\n}\n#endif /* ifndef SQLITE_OMIT_VIRTUALTABLE */\n\n/*\n** This routine is called to report the final \")\" that terminates\n** a CREATE TABLE statement.\n**\n** The table structure that other action routines have been building\n** is added to the internal hash tables, assuming no errors have\n** occurred.\n**\n** An entry for the table is made in the master table on disk, unless\n** this is a temporary table or db->init.busy==1.  When db->init.busy==1\n** it means we are reading the sqlite_master table because we just\n** connected to the database or because the sqlite_master table has\n** recently changed, so the entry for this table already exists in\n** the sqlite_master table.  We do not want to create it again.\n**\n** If the pSelect argument is not NULL, it means that this routine\n** was called to create a table generated from a \n** \"CREATE TABLE ... AS SELECT ...\" statement.  The column names of\n** the new table will match the result set of the SELECT.\n*/\nvoid sqlite3EndTable(\n  Parse *pParse,          /* Parse context */\n  Token *pCons,           /* The ',' token after the last column defn. */\n  Token *pEnd,            /* The ')' before options in the CREATE TABLE */\n  u8 tabOpts,             /* Extra table options. Usually 0. */\n  Select *pSelect         /* Select from a \"CREATE ... AS SELECT\" */\n){\n  Table *p;                 /* The new table */\n  sqlite3 *db = pParse->db; /* The database connection */\n  int iDb;                  /* Database in which the table lives */\n  Index *pIdx;              /* An implied index of the table */\n\n  if( pEnd==0 && pSelect==0 ){\n    return;\n  }\n  assert( !db->mallocFailed );\n  p = pParse->pNewTable;\n  if( p==0 ) return;\n\n  if( pSelect==0 && sqlite3ShadowTableName(db, p->zName) ){\n    p->tabFlags |= TF_Shadow;\n  }\n\n  /* If the db->init.busy is 1 it means we are reading the SQL off the\n  ** \"sqlite_master\" or \"sqlite_temp_master\" table on the disk.\n  ** So do not write to the disk again.  Extract the root page number\n  ** for the table from the db->init.newTnum field.  (The page number\n  ** should have been put there by the sqliteOpenCb routine.)\n  **\n  ** If the root page number is 1, that means this is the sqlite_master\n  ** table itself.  So mark it read-only.\n  */\n  if( db->init.busy ){\n    if( pSelect ){\n      sqlite3ErrorMsg(pParse, \"\");\n      return;\n    }\n    p->tnum = db->init.newTnum;\n    if( p->tnum==1 ) p->tabFlags |= TF_Readonly;\n  }\n\n  assert( (p->tabFlags & TF_HasPrimaryKey)==0\n       || p->iPKey>=0 || sqlite3PrimaryKeyIndex(p)!=0 );\n  assert( (p->tabFlags & TF_HasPrimaryKey)!=0\n       || (p->iPKey<0 && sqlite3PrimaryKeyIndex(p)==0) );\n\n  /* Special processing for WITHOUT ROWID Tables */\n  if( tabOpts & TF_WithoutRowid ){\n    if( (p->tabFlags & TF_Autoincrement) ){\n      sqlite3ErrorMsg(pParse,\n          \"AUTOINCREMENT not allowed on WITHOUT ROWID tables\");\n      return;\n    }\n    if( (p->tabFlags & TF_HasPrimaryKey)==0 ){\n      sqlite3ErrorMsg(pParse, \"PRIMARY KEY missing on table %s\", p->zName);\n      return;\n    }\n    p->tabFlags |= TF_WithoutRowid | TF_NoVisibleRowid;\n    convertToWithoutRowidTable(pParse, p);\n  }\n  iDb = sqlite3SchemaToIndex(db, p->pSchema);\n\n#ifndef SQLITE_OMIT_CHECK\n  /* Resolve names in all CHECK constraint expressions.\n  */\n  if( p->pCheck ){\n    sqlite3ResolveSelfReference(pParse, p, NC_IsCheck, 0, p->pCheck);\n  }\n#endif /* !defined(SQLITE_OMIT_CHECK) */\n#ifndef SQLITE_OMIT_GENERATED_COLUMNS\n  if( p->tabFlags & TF_HasGenerated ){\n    int ii, nNG = 0;\n    testcase( p->tabFlags & TF_HasVirtual );\n    testcase( p->tabFlags & TF_HasStored );\n    for(ii=0; ii<p->nCol; ii++){\n      u32 colFlags = p->aCol[ii].colFlags;\n      if( (colFlags & COLFLAG_GENERATED)!=0 ){\n        testcase( colFlags & COLFLAG_VIRTUAL );\n        testcase( colFlags & COLFLAG_STORED );\n        sqlite3ResolveSelfReference(pParse, p, NC_GenCol, \n                                    p->aCol[ii].pDflt, 0);\n      }else{\n        nNG++;\n      }\n    }\n    if( nNG==0 ){\n      sqlite3ErrorMsg(pParse, \"must have at least one non-generated column\");\n      return;\n    }\n  }\n#endif\n\n  /* Estimate the average row size for the table and for all implied indices */\n  estimateTableWidth(p);\n  for(pIdx=p->pIndex; pIdx; pIdx=pIdx->pNext){\n    estimateIndexWidth(pIdx);\n  }\n\n  /* If not initializing, then create a record for the new table\n  ** in the SQLITE_MASTER table of the database.\n  **\n  ** If this is a TEMPORARY table, write the entry into the auxiliary\n  ** file instead of into the main database file.\n  */\n  if( !db->init.busy ){\n    int n;\n    Vdbe *v;\n    char *zType;    /* \"view\" or \"table\" */\n    char *zType2;   /* \"VIEW\" or \"TABLE\" */\n    char *zStmt;    /* Text of the CREATE TABLE or CREATE VIEW statement */\n\n    v = sqlite3GetVdbe(pParse);\n    if( NEVER(v==0) ) return;\n\n    sqlite3VdbeAddOp1(v, OP_Close, 0);\n\n    /* \n    ** Initialize zType for the new view or table.\n    */\n    if( p->pSelect==0 ){\n      /* A regular table */\n      zType = \"table\";\n      zType2 = \"TABLE\";\n#ifndef SQLITE_OMIT_VIEW\n    }else{\n      /* A view */\n      zType = \"view\";\n      zType2 = \"VIEW\";\n#endif\n    }\n\n    /* If this is a CREATE TABLE xx AS SELECT ..., execute the SELECT\n    ** statement to populate the new table. The root-page number for the\n    ** new table is in register pParse->regRoot.\n    **\n    ** Once the SELECT has been coded by sqlite3Select(), it is in a\n    ** suitable state to query for the column names and types to be used\n    ** by the new table.\n    **\n    ** A shared-cache write-lock is not required to write to the new table,\n    ** as a schema-lock must have already been obtained to create it. Since\n    ** a schema-lock excludes all other database users, the write-lock would\n    ** be redundant.\n    */\n    if( pSelect ){\n      SelectDest dest;    /* Where the SELECT should store results */\n      int regYield;       /* Register holding co-routine entry-point */\n      int addrTop;        /* Top of the co-routine */\n      int regRec;         /* A record to be insert into the new table */\n      int regRowid;       /* Rowid of the next row to insert */\n      int addrInsLoop;    /* Top of the loop for inserting rows */\n      Table *pSelTab;     /* A table that describes the SELECT results */\n\n      regYield = ++pParse->nMem;\n      regRec = ++pParse->nMem;\n      regRowid = ++pParse->nMem;\n      assert(pParse->nTab==1);\n      sqlite3MayAbort(pParse);\n      sqlite3VdbeAddOp3(v, OP_OpenWrite, 1, pParse->regRoot, iDb);\n      sqlite3VdbeChangeP5(v, OPFLAG_P2ISREG);\n      pParse->nTab = 2;\n      addrTop = sqlite3VdbeCurrentAddr(v) + 1;\n      sqlite3VdbeAddOp3(v, OP_InitCoroutine, regYield, 0, addrTop);\n      if( pParse->nErr ) return;\n      pSelTab = sqlite3ResultSetOfSelect(pParse, pSelect, SQLITE_AFF_BLOB);\n      if( pSelTab==0 ) return;\n      assert( p->aCol==0 );\n      p->nCol = p->nNVCol = pSelTab->nCol;\n      p->aCol = pSelTab->aCol;\n      pSelTab->nCol = 0;\n      pSelTab->aCol = 0;\n      sqlite3DeleteTable(db, pSelTab);\n      sqlite3SelectDestInit(&dest, SRT_Coroutine, regYield);\n      sqlite3Select(pParse, pSelect, &dest);\n      if( pParse->nErr ) return;\n      sqlite3VdbeEndCoroutine(v, regYield);\n      sqlite3VdbeJumpHere(v, addrTop - 1);\n      addrInsLoop = sqlite3VdbeAddOp1(v, OP_Yield, dest.iSDParm);\n      VdbeCoverage(v);\n      sqlite3VdbeAddOp3(v, OP_MakeRecord, dest.iSdst, dest.nSdst, regRec);\n      sqlite3TableAffinity(v, p, 0);\n      sqlite3VdbeAddOp2(v, OP_NewRowid, 1, regRowid);\n      sqlite3VdbeAddOp3(v, OP_Insert, 1, regRec, regRowid);\n      sqlite3VdbeGoto(v, addrInsLoop);\n      sqlite3VdbeJumpHere(v, addrInsLoop);\n      sqlite3VdbeAddOp1(v, OP_Close, 1);\n    }\n\n    /* Compute the complete text of the CREATE statement */\n    if( pSelect ){\n      zStmt = createTableStmt(db, p);\n    }else{\n      Token *pEnd2 = tabOpts ? &pParse->sLastToken : pEnd;\n      n = (int)(pEnd2->z - pParse->sNameToken.z);\n      if( pEnd2->z[0]!=';' ) n += pEnd2->n;\n      zStmt = sqlite3MPrintf(db, \n          \"CREATE %s %.*s\", zType2, n, pParse->sNameToken.z\n      );\n    }\n\n    /* A slot for the record has already been allocated in the \n    ** SQLITE_MASTER table.  We just need to update that slot with all\n    ** the information we've collected.\n    */\n    sqlite3NestedParse(pParse,\n      \"UPDATE %Q.%s \"\n         \"SET type='%s', name=%Q, tbl_name=%Q, rootpage=#%d, sql=%Q \"\n       \"WHERE rowid=#%d\",\n      db->aDb[iDb].zDbSName, MASTER_NAME,\n      zType,\n      p->zName,\n      p->zName,\n      pParse->regRoot,\n      zStmt,\n      pParse->regRowid\n    );\n    sqlite3DbFree(db, zStmt);\n    sqlite3ChangeCookie(pParse, iDb);\n\n#ifndef SQLITE_OMIT_AUTOINCREMENT\n    /* Check to see if we need to create an sqlite_sequence table for\n    ** keeping track of autoincrement keys.\n    */\n    if( (p->tabFlags & TF_Autoincrement)!=0 ){\n      Db *pDb = &db->aDb[iDb];\n      assert( sqlite3SchemaMutexHeld(db, iDb, 0) );\n      if( pDb->pSchema->pSeqTab==0 ){\n        sqlite3NestedParse(pParse,\n          \"CREATE TABLE %Q.sqlite_sequence(name,seq)\",\n          pDb->zDbSName\n        );\n      }\n    }\n#endif\n\n    /* Reparse everything to update our internal data structures */\n    sqlite3VdbeAddParseSchemaOp(v, iDb,\n           sqlite3MPrintf(db, \"tbl_name='%q' AND type!='trigger'\", p->zName));\n  }\n\n  /* Add the table to the in-memory representation of the database.\n  */\n  if( db->init.busy ){\n    Table *pOld;\n    Schema *pSchema = p->pSchema;\n    assert( sqlite3SchemaMutexHeld(db, iDb, 0) );\n    pOld = sqlite3HashInsert(&pSchema->tblHash, p->zName, p);\n    if( pOld ){\n      assert( p==pOld );  /* Malloc must have failed inside HashInsert() */\n      sqlite3OomFault(db);\n      return;\n    }\n    pParse->pNewTable = 0;\n    db->mDbFlags |= DBFLAG_SchemaChange;\n\n#ifndef SQLITE_OMIT_ALTERTABLE\n    if( !p->pSelect ){\n      const char *zName = (const char *)pParse->sNameToken.z;\n      int nName;\n      assert( !pSelect && pCons && pEnd );\n      if( pCons->z==0 ){\n        pCons = pEnd;\n      }\n      nName = (int)((const char *)pCons->z - zName);\n      p->addColOffset = 13 + sqlite3Utf8CharLen(zName, nName);\n    }\n#endif\n  }\n}\n\n#ifndef SQLITE_OMIT_VIEW\n/*\n** The parser calls this routine in order to create a new VIEW\n*/\nvoid sqlite3CreateView(\n  Parse *pParse,     /* The parsing context */\n  Token *pBegin,     /* The CREATE token that begins the statement */\n  Token *pName1,     /* The token that holds the name of the view */\n  Token *pName2,     /* The token that holds the name of the view */\n  ExprList *pCNames, /* Optional list of view column names */\n  Select *pSelect,   /* A SELECT statement that will become the new view */\n  int isTemp,        /* TRUE for a TEMPORARY view */\n  int noErr          /* Suppress error messages if VIEW already exists */\n){\n  Table *p;\n  int n;\n  const char *z;\n  Token sEnd;\n  DbFixer sFix;\n  Token *pName = 0;\n  int iDb;\n  sqlite3 *db = pParse->db;\n\n  if( pParse->nVar>0 ){\n    sqlite3ErrorMsg(pParse, \"parameters are not allowed in views\");\n    goto create_view_fail;\n  }\n  sqlite3StartTable(pParse, pName1, pName2, isTemp, 1, 0, noErr);\n  p = pParse->pNewTable;\n  if( p==0 || pParse->nErr ) goto create_view_fail;\n  sqlite3TwoPartName(pParse, pName1, pName2, &pName);\n  iDb = sqlite3SchemaToIndex(db, p->pSchema);\n  sqlite3FixInit(&sFix, pParse, iDb, \"view\", pName);\n  if( sqlite3FixSelect(&sFix, pSelect) ) goto create_view_fail;\n\n  /* Make a copy of the entire SELECT statement that defines the view.\n  ** This will force all the Expr.token.z values to be dynamically\n  ** allocated rather than point to the input string - which means that\n  ** they will persist after the current sqlite3_exec() call returns.\n  */\n  if( IN_RENAME_OBJECT ){\n    p->pSelect = pSelect;\n    pSelect = 0;\n  }else{\n    p->pSelect = sqlite3SelectDup(db, pSelect, EXPRDUP_REDUCE);\n  }\n  p->pCheck = sqlite3ExprListDup(db, pCNames, EXPRDUP_REDUCE);\n  if( db->mallocFailed ) goto create_view_fail;\n\n  /* Locate the end of the CREATE VIEW statement.  Make sEnd point to\n  ** the end.\n  */\n  sEnd = pParse->sLastToken;\n  assert( sEnd.z[0]!=0 || sEnd.n==0 );\n  if( sEnd.z[0]!=';' ){\n    sEnd.z += sEnd.n;\n  }\n  sEnd.n = 0;\n  n = (int)(sEnd.z - pBegin->z);\n  assert( n>0 );\n  z = pBegin->z;\n  while( sqlite3Isspace(z[n-1]) ){ n--; }\n  sEnd.z = &z[n-1];\n  sEnd.n = 1;\n\n  /* Use sqlite3EndTable() to add the view to the SQLITE_MASTER table */\n  sqlite3EndTable(pParse, 0, &sEnd, 0, 0);\n\ncreate_view_fail:\n  sqlite3SelectDelete(db, pSelect);\n  if( IN_RENAME_OBJECT ){\n    sqlite3RenameExprlistUnmap(pParse, pCNames);\n  }\n  sqlite3ExprListDelete(db, pCNames);\n  return;\n}\n#endif /* SQLITE_OMIT_VIEW */\n\n#if !defined(SQLITE_OMIT_VIEW) || !defined(SQLITE_OMIT_VIRTUALTABLE)\n/*\n** The Table structure pTable is really a VIEW.  Fill in the names of\n** the columns of the view in the pTable structure.  Return the number\n** of errors.  If an error is seen leave an error message in pParse->zErrMsg.\n*/\nint sqlite3ViewGetColumnNames(Parse *pParse, Table *pTable){\n  Table *pSelTab;   /* A fake table from which we get the result set */\n  Select *pSel;     /* Copy of the SELECT that implements the view */\n  int nErr = 0;     /* Number of errors encountered */\n  int n;            /* Temporarily holds the number of cursors assigned */\n  sqlite3 *db = pParse->db;  /* Database connection for malloc errors */\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n  int rc;\n#endif\n#ifndef SQLITE_OMIT_AUTHORIZATION\n  sqlite3_xauth xAuth;       /* Saved xAuth pointer */\n#endif\n\n  assert( pTable );\n\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n  db->nSchemaLock++;\n  rc = sqlite3VtabCallConnect(pParse, pTable);\n  db->nSchemaLock--;\n  if( rc ){\n    return 1;\n  }\n  if( IsVirtual(pTable) ) return 0;\n#endif\n\n#ifndef SQLITE_OMIT_VIEW\n  /* A positive nCol means the columns names for this view are\n  ** already known.\n  */\n  if( pTable->nCol>0 ) return 0;\n\n  /* A negative nCol is a special marker meaning that we are currently\n  ** trying to compute the column names.  If we enter this routine with\n  ** a negative nCol, it means two or more views form a loop, like this:\n  **\n  **     CREATE VIEW one AS SELECT * FROM two;\n  **     CREATE VIEW two AS SELECT * FROM one;\n  **\n  ** Actually, the error above is now caught prior to reaching this point.\n  ** But the following test is still important as it does come up\n  ** in the following:\n  ** \n  **     CREATE TABLE main.ex1(a);\n  **     CREATE TEMP VIEW ex1 AS SELECT a FROM ex1;\n  **     SELECT * FROM temp.ex1;\n  */\n  if( pTable->nCol<0 ){\n    sqlite3ErrorMsg(pParse, \"view %s is circularly defined\", pTable->zName);\n    return 1;\n  }\n  assert( pTable->nCol>=0 );\n\n  /* If we get this far, it means we need to compute the table names.\n  ** Note that the call to sqlite3ResultSetOfSelect() will expand any\n  ** \"*\" elements in the results set of the view and will assign cursors\n  ** to the elements of the FROM clause.  But we do not want these changes\n  ** to be permanent.  So the computation is done on a copy of the SELECT\n  ** statement that defines the view.\n  */\n  assert( pTable->pSelect );\n  pSel = sqlite3SelectDup(db, pTable->pSelect, 0);\n  if( pSel ){\n#ifndef SQLITE_OMIT_ALTERTABLE\n    u8 eParseMode = pParse->eParseMode;\n    pParse->eParseMode = PARSE_MODE_NORMAL;\n#endif\n    n = pParse->nTab;\n    sqlite3SrcListAssignCursors(pParse, pSel->pSrc);\n    pTable->nCol = -1;\n    DisableLookaside;\n#ifndef SQLITE_OMIT_AUTHORIZATION\n    xAuth = db->xAuth;\n    db->xAuth = 0;\n    pSelTab = sqlite3ResultSetOfSelect(pParse, pSel, SQLITE_AFF_NONE);\n    db->xAuth = xAuth;\n#else\n    pSelTab = sqlite3ResultSetOfSelect(pParse, pSel, SQLITE_AFF_NONE);\n#endif\n    pParse->nTab = n;\n    if( pTable->pCheck ){\n      /* CREATE VIEW name(arglist) AS ...\n      ** The names of the columns in the table are taken from\n      ** arglist which is stored in pTable->pCheck.  The pCheck field\n      ** normally holds CHECK constraints on an ordinary table, but for\n      ** a VIEW it holds the list of column names.\n      */\n      sqlite3ColumnsFromExprList(pParse, pTable->pCheck, \n                                 &pTable->nCol, &pTable->aCol);\n      if( db->mallocFailed==0 \n       && pParse->nErr==0\n       && pTable->nCol==pSel->pEList->nExpr\n      ){\n        sqlite3SelectAddColumnTypeAndCollation(pParse, pTable, pSel,\n                                               SQLITE_AFF_NONE);\n      }\n    }else if( pSelTab ){\n      /* CREATE VIEW name AS...  without an argument list.  Construct\n      ** the column names from the SELECT statement that defines the view.\n      */\n      assert( pTable->aCol==0 );\n      pTable->nCol = pSelTab->nCol;\n      pTable->aCol = pSelTab->aCol;\n      pSelTab->nCol = 0;\n      pSelTab->aCol = 0;\n      assert( sqlite3SchemaMutexHeld(db, 0, pTable->pSchema) );\n    }else{\n      pTable->nCol = 0;\n      nErr++;\n    }\n    pTable->nNVCol = pTable->nCol;\n    sqlite3DeleteTable(db, pSelTab);\n    sqlite3SelectDelete(db, pSel);\n    EnableLookaside;\n#ifndef SQLITE_OMIT_ALTERTABLE\n    pParse->eParseMode = eParseMode;\n#endif\n  } else {\n    nErr++;\n  }\n  pTable->pSchema->schemaFlags |= DB_UnresetViews;\n  if( db->mallocFailed ){\n    sqlite3DeleteColumnNames(db, pTable);\n    pTable->aCol = 0;\n    pTable->nCol = 0;\n  }\n#endif /* SQLITE_OMIT_VIEW */\n  return nErr;  \n}\n#endif /* !defined(SQLITE_OMIT_VIEW) || !defined(SQLITE_OMIT_VIRTUALTABLE) */\n\n#ifndef SQLITE_OMIT_VIEW\n/*\n** Clear the column names from every VIEW in database idx.\n*/\nstatic void sqliteViewResetAll(sqlite3 *db, int idx){\n  HashElem *i;\n  assert( sqlite3SchemaMutexHeld(db, idx, 0) );\n  if( !DbHasProperty(db, idx, DB_UnresetViews) ) return;\n  for(i=sqliteHashFirst(&db->aDb[idx].pSchema->tblHash); i;i=sqliteHashNext(i)){\n    Table *pTab = sqliteHashData(i);\n    if( pTab->pSelect ){\n      sqlite3DeleteColumnNames(db, pTab);\n      pTab->aCol = 0;\n      pTab->nCol = 0;\n    }\n  }\n  DbClearProperty(db, idx, DB_UnresetViews);\n}\n#else\n# define sqliteViewResetAll(A,B)\n#endif /* SQLITE_OMIT_VIEW */\n\n/*\n** This function is called by the VDBE to adjust the internal schema\n** used by SQLite when the btree layer moves a table root page. The\n** root-page of a table or index in database iDb has changed from iFrom\n** to iTo.\n**\n** Ticket #1728:  The symbol table might still contain information\n** on tables and/or indices that are the process of being deleted.\n** If you are unlucky, one of those deleted indices or tables might\n** have the same rootpage number as the real table or index that is\n** being moved.  So we cannot stop searching after the first match \n** because the first match might be for one of the deleted indices\n** or tables and not the table/index that is actually being moved.\n** We must continue looping until all tables and indices with\n** rootpage==iFrom have been converted to have a rootpage of iTo\n** in order to be certain that we got the right one.\n*/\n#ifndef SQLITE_OMIT_AUTOVACUUM\nvoid sqlite3RootPageMoved(sqlite3 *db, int iDb, int iFrom, int iTo){\n  HashElem *pElem;\n  Hash *pHash;\n  Db *pDb;\n\n  assert( sqlite3SchemaMutexHeld(db, iDb, 0) );\n  pDb = &db->aDb[iDb];\n  pHash = &pDb->pSchema->tblHash;\n  for(pElem=sqliteHashFirst(pHash); pElem; pElem=sqliteHashNext(pElem)){\n    Table *pTab = sqliteHashData(pElem);\n    if( pTab->tnum==iFrom ){\n      pTab->tnum = iTo;\n    }\n  }\n  pHash = &pDb->pSchema->idxHash;\n  for(pElem=sqliteHashFirst(pHash); pElem; pElem=sqliteHashNext(pElem)){\n    Index *pIdx = sqliteHashData(pElem);\n    if( pIdx->tnum==iFrom ){\n      pIdx->tnum = iTo;\n    }\n  }\n}\n#endif\n\n/*\n** Write code to erase the table with root-page iTable from database iDb.\n** Also write code to modify the sqlite_master table and internal schema\n** if a root-page of another table is moved by the btree-layer whilst\n** erasing iTable (this can happen with an auto-vacuum database).\n*/ \nstatic void destroyRootPage(Parse *pParse, int iTable, int iDb){\n  Vdbe *v = sqlite3GetVdbe(pParse);\n  int r1 = sqlite3GetTempReg(pParse);\n  if( iTable<2 ) sqlite3ErrorMsg(pParse, \"corrupt schema\");\n  sqlite3VdbeAddOp3(v, OP_Destroy, iTable, r1, iDb);\n  sqlite3MayAbort(pParse);\n#ifndef SQLITE_OMIT_AUTOVACUUM\n  /* OP_Destroy stores an in integer r1. If this integer\n  ** is non-zero, then it is the root page number of a table moved to\n  ** location iTable. The following code modifies the sqlite_master table to\n  ** reflect this.\n  **\n  ** The \"#NNN\" in the SQL is a special constant that means whatever value\n  ** is in register NNN.  See grammar rules associated with the TK_REGISTER\n  ** token for additional information.\n  */\n  sqlite3NestedParse(pParse, \n     \"UPDATE %Q.%s SET rootpage=%d WHERE #%d AND rootpage=#%d\",\n     pParse->db->aDb[iDb].zDbSName, MASTER_NAME, iTable, r1, r1);\n#endif\n  sqlite3ReleaseTempReg(pParse, r1);\n}\n\n/*\n** Write VDBE code to erase table pTab and all associated indices on disk.\n** Code to update the sqlite_master tables and internal schema definitions\n** in case a root-page belonging to another table is moved by the btree layer\n** is also added (this can happen with an auto-vacuum database).\n*/\nstatic void destroyTable(Parse *pParse, Table *pTab){\n  /* If the database may be auto-vacuum capable (if SQLITE_OMIT_AUTOVACUUM\n  ** is not defined), then it is important to call OP_Destroy on the\n  ** table and index root-pages in order, starting with the numerically \n  ** largest root-page number. This guarantees that none of the root-pages\n  ** to be destroyed is relocated by an earlier OP_Destroy. i.e. if the\n  ** following were coded:\n  **\n  ** OP_Destroy 4 0\n  ** ...\n  ** OP_Destroy 5 0\n  **\n  ** and root page 5 happened to be the largest root-page number in the\n  ** database, then root page 5 would be moved to page 4 by the \n  ** \"OP_Destroy 4 0\" opcode. The subsequent \"OP_Destroy 5 0\" would hit\n  ** a free-list page.\n  */\n  int iTab = pTab->tnum;\n  int iDestroyed = 0;\n\n  while( 1 ){\n    Index *pIdx;\n    int iLargest = 0;\n\n    if( iDestroyed==0 || iTab<iDestroyed ){\n      iLargest = iTab;\n    }\n    for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){\n      int iIdx = pIdx->tnum;\n      assert( pIdx->pSchema==pTab->pSchema );\n      if( (iDestroyed==0 || (iIdx<iDestroyed)) && iIdx>iLargest ){\n        iLargest = iIdx;\n      }\n    }\n    if( iLargest==0 ){\n      return;\n    }else{\n      int iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);\n      assert( iDb>=0 && iDb<pParse->db->nDb );\n      destroyRootPage(pParse, iLargest, iDb);\n      iDestroyed = iLargest;\n    }\n  }\n}\n\n/*\n** Remove entries from the sqlite_statN tables (for N in (1,2,3))\n** after a DROP INDEX or DROP TABLE command.\n*/\nstatic void sqlite3ClearStatTables(\n  Parse *pParse,         /* The parsing context */\n  int iDb,               /* The database number */\n  const char *zType,     /* \"idx\" or \"tbl\" */\n  const char *zName      /* Name of index or table */\n){\n  int i;\n  const char *zDbName = pParse->db->aDb[iDb].zDbSName;\n  for(i=1; i<=4; i++){\n    char zTab[24];\n    sqlite3_snprintf(sizeof(zTab),zTab,\"sqlite_stat%d\",i);\n    if( sqlite3FindTable(pParse->db, zTab, zDbName) ){\n      sqlite3NestedParse(pParse,\n        \"DELETE FROM %Q.%s WHERE %s=%Q\",\n        zDbName, zTab, zType, zName\n      );\n    }\n  }\n}\n\n/*\n** Generate code to drop a table.\n*/\nvoid sqlite3CodeDropTable(Parse *pParse, Table *pTab, int iDb, int isView){\n  Vdbe *v;\n  sqlite3 *db = pParse->db;\n  Trigger *pTrigger;\n  Db *pDb = &db->aDb[iDb];\n\n  v = sqlite3GetVdbe(pParse);\n  assert( v!=0 );\n  sqlite3BeginWriteOperation(pParse, 1, iDb);\n\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n  if( IsVirtual(pTab) ){\n    sqlite3VdbeAddOp0(v, OP_VBegin);\n  }\n#endif\n\n  /* Drop all triggers associated with the table being dropped. Code\n  ** is generated to remove entries from sqlite_master and/or\n  ** sqlite_temp_master if required.\n  */\n  pTrigger = sqlite3TriggerList(pParse, pTab);\n  while( pTrigger ){\n    assert( pTrigger->pSchema==pTab->pSchema || \n        pTrigger->pSchema==db->aDb[1].pSchema );\n    sqlite3DropTriggerPtr(pParse, pTrigger);\n    pTrigger = pTrigger->pNext;\n  }\n\n#ifndef SQLITE_OMIT_AUTOINCREMENT\n  /* Remove any entries of the sqlite_sequence table associated with\n  ** the table being dropped. This is done before the table is dropped\n  ** at the btree level, in case the sqlite_sequence table needs to\n  ** move as a result of the drop (can happen in auto-vacuum mode).\n  */\n  if( pTab->tabFlags & TF_Autoincrement ){\n    sqlite3NestedParse(pParse,\n      \"DELETE FROM %Q.sqlite_sequence WHERE name=%Q\",\n      pDb->zDbSName, pTab->zName\n    );\n  }\n#endif\n\n  /* Drop all SQLITE_MASTER table and index entries that refer to the\n  ** table. The program name loops through the master table and deletes\n  ** every row that refers to a table of the same name as the one being\n  ** dropped. Triggers are handled separately because a trigger can be\n  ** created in the temp database that refers to a table in another\n  ** database.\n  */\n  sqlite3NestedParse(pParse, \n      \"DELETE FROM %Q.%s WHERE tbl_name=%Q and type!='trigger'\",\n      pDb->zDbSName, MASTER_NAME, pTab->zName);\n  if( !isView && !IsVirtual(pTab) ){\n    destroyTable(pParse, pTab);\n  }\n\n  /* Remove the table entry from SQLite's internal schema and modify\n  ** the schema cookie.\n  */\n  if( IsVirtual(pTab) ){\n    sqlite3VdbeAddOp4(v, OP_VDestroy, iDb, 0, 0, pTab->zName, 0);\n    sqlite3MayAbort(pParse);\n  }\n  sqlite3VdbeAddOp4(v, OP_DropTable, iDb, 0, 0, pTab->zName, 0);\n  sqlite3ChangeCookie(pParse, iDb);\n  sqliteViewResetAll(db, iDb);\n}\n\n/*\n** Return TRUE if shadow tables should be read-only in the current\n** context.\n*/\nint sqlite3ReadOnlyShadowTables(sqlite3 *db){\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n  if( (db->flags & SQLITE_Defensive)!=0\n   && db->pVtabCtx==0\n   && db->nVdbeExec==0\n  ){\n    return 1;\n  }\n#endif\n  return 0;\n}\n\n/*\n** Return true if it is not allowed to drop the given table\n*/\nstatic int tableMayNotBeDropped(sqlite3 *db, Table *pTab){\n  if( sqlite3StrNICmp(pTab->zName, \"sqlite_\", 7)==0 ){\n    if( sqlite3StrNICmp(pTab->zName+7, \"stat\", 4)==0 ) return 0;\n    if( sqlite3StrNICmp(pTab->zName+7, \"parameters\", 10)==0 ) return 0;\n    return 1;\n  }\n  if( (pTab->tabFlags & TF_Shadow)!=0 && sqlite3ReadOnlyShadowTables(db) ){\n    return 1;\n  }\n  return 0;\n}\n\n/*\n** This routine is called to do the work of a DROP TABLE statement.\n** pName is the name of the table to be dropped.\n*/\nvoid sqlite3DropTable(Parse *pParse, SrcList *pName, int isView, int noErr){\n  Table *pTab;\n  Vdbe *v;\n  sqlite3 *db = pParse->db;\n  int iDb;\n\n  if( db->mallocFailed ){\n    goto exit_drop_table;\n  }\n  assert( pParse->nErr==0 );\n  assert( pName->nSrc==1 );\n  if( sqlite3ReadSchema(pParse) ) goto exit_drop_table;\n  if( noErr ) db->suppressErr++;\n  assert( isView==0 || isView==LOCATE_VIEW );\n  pTab = sqlite3LocateTableItem(pParse, isView, &pName->a[0]);\n  if( noErr ) db->suppressErr--;\n\n  if( pTab==0 ){\n    if( noErr ) sqlite3CodeVerifyNamedSchema(pParse, pName->a[0].zDatabase);\n    goto exit_drop_table;\n  }\n  iDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n  assert( iDb>=0 && iDb<db->nDb );\n\n  /* If pTab is a virtual table, call ViewGetColumnNames() to ensure\n  ** it is initialized.\n  */\n  if( IsVirtual(pTab) && sqlite3ViewGetColumnNames(pParse, pTab) ){\n    goto exit_drop_table;\n  }\n#ifndef SQLITE_OMIT_AUTHORIZATION\n  {\n    int code;\n    const char *zTab = SCHEMA_TABLE(iDb);\n    const char *zDb = db->aDb[iDb].zDbSName;\n    const char *zArg2 = 0;\n    if( sqlite3AuthCheck(pParse, SQLITE_DELETE, zTab, 0, zDb)){\n      goto exit_drop_table;\n    }\n    if( isView ){\n      if( !OMIT_TEMPDB && iDb==1 ){\n        code = SQLITE_DROP_TEMP_VIEW;\n      }else{\n        code = SQLITE_DROP_VIEW;\n      }\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n    }else if( IsVirtual(pTab) ){\n      code = SQLITE_DROP_VTABLE;\n      zArg2 = sqlite3GetVTable(db, pTab)->pMod->zName;\n#endif\n    }else{\n      if( !OMIT_TEMPDB && iDb==1 ){\n        code = SQLITE_DROP_TEMP_TABLE;\n      }else{\n        code = SQLITE_DROP_TABLE;\n      }\n    }\n    if( sqlite3AuthCheck(pParse, code, pTab->zName, zArg2, zDb) ){\n      goto exit_drop_table;\n    }\n    if( sqlite3AuthCheck(pParse, SQLITE_DELETE, pTab->zName, 0, zDb) ){\n      goto exit_drop_table;\n    }\n  }\n#endif\n  if( tableMayNotBeDropped(db, pTab) ){\n    sqlite3ErrorMsg(pParse, \"table %s may not be dropped\", pTab->zName);\n    goto exit_drop_table;\n  }\n\n#ifndef SQLITE_OMIT_VIEW\n  /* Ensure DROP TABLE is not used on a view, and DROP VIEW is not used\n  ** on a table.\n  */\n  if( isView && pTab->pSelect==0 ){\n    sqlite3ErrorMsg(pParse, \"use DROP TABLE to delete table %s\", pTab->zName);\n    goto exit_drop_table;\n  }\n  if( !isView && pTab->pSelect ){\n    sqlite3ErrorMsg(pParse, \"use DROP VIEW to delete view %s\", pTab->zName);\n    goto exit_drop_table;\n  }\n#endif\n\n  /* Generate code to remove the table from the master table\n  ** on disk.\n  */\n  v = sqlite3GetVdbe(pParse);\n  if( v ){\n    sqlite3BeginWriteOperation(pParse, 1, iDb);\n    if( !isView ){\n      sqlite3ClearStatTables(pParse, iDb, \"tbl\", pTab->zName);\n      sqlite3FkDropTable(pParse, pName, pTab);\n    }\n    sqlite3CodeDropTable(pParse, pTab, iDb, isView);\n  }\n\nexit_drop_table:\n  sqlite3SrcListDelete(db, pName);\n}\n\n/*\n** This routine is called to create a new foreign key on the table\n** currently under construction.  pFromCol determines which columns\n** in the current table point to the foreign key.  If pFromCol==0 then\n** connect the key to the last column inserted.  pTo is the name of\n** the table referred to (a.k.a the \"parent\" table).  pToCol is a list\n** of tables in the parent pTo table.  flags contains all\n** information about the conflict resolution algorithms specified\n** in the ON DELETE, ON UPDATE and ON INSERT clauses.\n**\n** An FKey structure is created and added to the table currently\n** under construction in the pParse->pNewTable field.\n**\n** The foreign key is set for IMMEDIATE processing.  A subsequent call\n** to sqlite3DeferForeignKey() might change this to DEFERRED.\n*/\nvoid sqlite3CreateForeignKey(\n  Parse *pParse,       /* Parsing context */\n  ExprList *pFromCol,  /* Columns in this table that point to other table */\n  Token *pTo,          /* Name of the other table */\n  ExprList *pToCol,    /* Columns in the other table */\n  int flags            /* Conflict resolution algorithms. */\n){\n  sqlite3 *db = pParse->db;\n#ifndef SQLITE_OMIT_FOREIGN_KEY\n  FKey *pFKey = 0;\n  FKey *pNextTo;\n  Table *p = pParse->pNewTable;\n  int nByte;\n  int i;\n  int nCol;\n  char *z;\n\n  assert( pTo!=0 );\n  if( p==0 || IN_DECLARE_VTAB ) goto fk_end;\n  if( pFromCol==0 ){\n    int iCol = p->nCol-1;\n    if( NEVER(iCol<0) ) goto fk_end;\n    if( pToCol && pToCol->nExpr!=1 ){\n      sqlite3ErrorMsg(pParse, \"foreign key on %s\"\n         \" should reference only one column of table %T\",\n         p->aCol[iCol].zName, pTo);\n      goto fk_end;\n    }\n    nCol = 1;\n  }else if( pToCol && pToCol->nExpr!=pFromCol->nExpr ){\n    sqlite3ErrorMsg(pParse,\n        \"number of columns in foreign key does not match the number of \"\n        \"columns in the referenced table\");\n    goto fk_end;\n  }else{\n    nCol = pFromCol->nExpr;\n  }\n  nByte = sizeof(*pFKey) + (nCol-1)*sizeof(pFKey->aCol[0]) + pTo->n + 1;\n  if( pToCol ){\n    for(i=0; i<pToCol->nExpr; i++){\n      nByte += sqlite3Strlen30(pToCol->a[i].zName) + 1;\n    }\n  }\n  pFKey = sqlite3DbMallocZero(db, nByte );\n  if( pFKey==0 ){\n    goto fk_end;\n  }\n  pFKey->pFrom = p;\n  pFKey->pNextFrom = p->pFKey;\n  z = (char*)&pFKey->aCol[nCol];\n  pFKey->zTo = z;\n  if( IN_RENAME_OBJECT ){\n    sqlite3RenameTokenMap(pParse, (void*)z, pTo);\n  }\n  memcpy(z, pTo->z, pTo->n);\n  z[pTo->n] = 0;\n  sqlite3Dequote(z);\n  z += pTo->n+1;\n  pFKey->nCol = nCol;\n  if( pFromCol==0 ){\n    pFKey->aCol[0].iFrom = p->nCol-1;\n  }else{\n    for(i=0; i<nCol; i++){\n      int j;\n      for(j=0; j<p->nCol; j++){\n        if( sqlite3StrICmp(p->aCol[j].zName, pFromCol->a[i].zName)==0 ){\n          pFKey->aCol[i].iFrom = j;\n          break;\n        }\n      }\n      if( j>=p->nCol ){\n        sqlite3ErrorMsg(pParse, \n          \"unknown column \\\"%s\\\" in foreign key definition\", \n          pFromCol->a[i].zName);\n        goto fk_end;\n      }\n      if( IN_RENAME_OBJECT ){\n        sqlite3RenameTokenRemap(pParse, &pFKey->aCol[i], pFromCol->a[i].zName);\n      }\n    }\n  }\n  if( pToCol ){\n    for(i=0; i<nCol; i++){\n      int n = sqlite3Strlen30(pToCol->a[i].zName);\n      pFKey->aCol[i].zCol = z;\n      if( IN_RENAME_OBJECT ){\n        sqlite3RenameTokenRemap(pParse, z, pToCol->a[i].zName);\n      }\n      memcpy(z, pToCol->a[i].zName, n);\n      z[n] = 0;\n      z += n+1;\n    }\n  }\n  pFKey->isDeferred = 0;\n  pFKey->aAction[0] = (u8)(flags & 0xff);            /* ON DELETE action */\n  pFKey->aAction[1] = (u8)((flags >> 8 ) & 0xff);    /* ON UPDATE action */\n\n  assert( sqlite3SchemaMutexHeld(db, 0, p->pSchema) );\n  pNextTo = (FKey *)sqlite3HashInsert(&p->pSchema->fkeyHash, \n      pFKey->zTo, (void *)pFKey\n  );\n  if( pNextTo==pFKey ){\n    sqlite3OomFault(db);\n    goto fk_end;\n  }\n  if( pNextTo ){\n    assert( pNextTo->pPrevTo==0 );\n    pFKey->pNextTo = pNextTo;\n    pNextTo->pPrevTo = pFKey;\n  }\n\n  /* Link the foreign key to the table as the last step.\n  */\n  p->pFKey = pFKey;\n  pFKey = 0;\n\nfk_end:\n  sqlite3DbFree(db, pFKey);\n#endif /* !defined(SQLITE_OMIT_FOREIGN_KEY) */\n  sqlite3ExprListDelete(db, pFromCol);\n  sqlite3ExprListDelete(db, pToCol);\n}\n\n/*\n** This routine is called when an INITIALLY IMMEDIATE or INITIALLY DEFERRED\n** clause is seen as part of a foreign key definition.  The isDeferred\n** parameter is 1 for INITIALLY DEFERRED and 0 for INITIALLY IMMEDIATE.\n** The behavior of the most recently created foreign key is adjusted\n** accordingly.\n*/\nvoid sqlite3DeferForeignKey(Parse *pParse, int isDeferred){\n#ifndef SQLITE_OMIT_FOREIGN_KEY\n  Table *pTab;\n  FKey *pFKey;\n  if( (pTab = pParse->pNewTable)==0 || (pFKey = pTab->pFKey)==0 ) return;\n  assert( isDeferred==0 || isDeferred==1 ); /* EV: R-30323-21917 */\n  pFKey->isDeferred = (u8)isDeferred;\n#endif\n}\n\n/*\n** Generate code that will erase and refill index *pIdx.  This is\n** used to initialize a newly created index or to recompute the\n** content of an index in response to a REINDEX command.\n**\n** if memRootPage is not negative, it means that the index is newly\n** created.  The register specified by memRootPage contains the\n** root page number of the index.  If memRootPage is negative, then\n** the index already exists and must be cleared before being refilled and\n** the root page number of the index is taken from pIndex->tnum.\n*/\nstatic void sqlite3RefillIndex(Parse *pParse, Index *pIndex, int memRootPage){\n  Table *pTab = pIndex->pTable;  /* The table that is indexed */\n  int iTab = pParse->nTab++;     /* Btree cursor used for pTab */\n  int iIdx = pParse->nTab++;     /* Btree cursor used for pIndex */\n  int iSorter;                   /* Cursor opened by OpenSorter (if in use) */\n  int addr1;                     /* Address of top of loop */\n  int addr2;                     /* Address to jump to for next iteration */\n  int tnum;                      /* Root page of index */\n  int iPartIdxLabel;             /* Jump to this label to skip a row */\n  Vdbe *v;                       /* Generate code into this virtual machine */\n  KeyInfo *pKey;                 /* KeyInfo for index */\n  int regRecord;                 /* Register holding assembled index record */\n  sqlite3 *db = pParse->db;      /* The database connection */\n  int iDb = sqlite3SchemaToIndex(db, pIndex->pSchema);\n\n#ifndef SQLITE_OMIT_AUTHORIZATION\n  if( sqlite3AuthCheck(pParse, SQLITE_REINDEX, pIndex->zName, 0,\n      db->aDb[iDb].zDbSName ) ){\n    return;\n  }\n#endif\n\n  /* Require a write-lock on the table to perform this operation */\n  sqlite3TableLock(pParse, iDb, pTab->tnum, 1, pTab->zName);\n\n  v = sqlite3GetVdbe(pParse);\n  if( v==0 ) return;\n  if( memRootPage>=0 ){\n    tnum = memRootPage;\n  }else{\n    tnum = pIndex->tnum;\n  }\n  pKey = sqlite3KeyInfoOfIndex(pParse, pIndex);\n  assert( pKey!=0 || db->mallocFailed || pParse->nErr );\n\n  /* Open the sorter cursor if we are to use one. */\n  iSorter = pParse->nTab++;\n  sqlite3VdbeAddOp4(v, OP_SorterOpen, iSorter, 0, pIndex->nKeyCol, (char*)\n                    sqlite3KeyInfoRef(pKey), P4_KEYINFO);\n\n  /* Open the table. Loop through all rows of the table, inserting index\n  ** records into the sorter. */\n  sqlite3OpenTable(pParse, iTab, iDb, pTab, OP_OpenRead);\n  addr1 = sqlite3VdbeAddOp2(v, OP_Rewind, iTab, 0); VdbeCoverage(v);\n  regRecord = sqlite3GetTempReg(pParse);\n  sqlite3MultiWrite(pParse);\n\n  sqlite3GenerateIndexKey(pParse,pIndex,iTab,regRecord,0,&iPartIdxLabel,0,0);\n  sqlite3VdbeAddOp2(v, OP_SorterInsert, iSorter, regRecord);\n  sqlite3ResolvePartIdxLabel(pParse, iPartIdxLabel);\n  sqlite3VdbeAddOp2(v, OP_Next, iTab, addr1+1); VdbeCoverage(v);\n  sqlite3VdbeJumpHere(v, addr1);\n  if( memRootPage<0 ) sqlite3VdbeAddOp2(v, OP_Clear, tnum, iDb);\n  sqlite3VdbeAddOp4(v, OP_OpenWrite, iIdx, tnum, iDb, \n                    (char *)pKey, P4_KEYINFO);\n  sqlite3VdbeChangeP5(v, OPFLAG_BULKCSR|((memRootPage>=0)?OPFLAG_P2ISREG:0));\n\n  addr1 = sqlite3VdbeAddOp2(v, OP_SorterSort, iSorter, 0); VdbeCoverage(v);\n  if( IsUniqueIndex(pIndex) ){\n    int j2 = sqlite3VdbeGoto(v, 1);\n    addr2 = sqlite3VdbeCurrentAddr(v);\n    sqlite3VdbeVerifyAbortable(v, OE_Abort);\n    sqlite3VdbeAddOp4Int(v, OP_SorterCompare, iSorter, j2, regRecord,\n                         pIndex->nKeyCol); VdbeCoverage(v);\n    sqlite3UniqueConstraint(pParse, OE_Abort, pIndex);\n    sqlite3VdbeJumpHere(v, j2);\n  }else{\n    /* Most CREATE INDEX and REINDEX statements that are not UNIQUE can not\n    ** abort. The exception is if one of the indexed expressions contains a\n    ** user function that throws an exception when it is evaluated. But the\n    ** overhead of adding a statement journal to a CREATE INDEX statement is\n    ** very small (since most of the pages written do not contain content that\n    ** needs to be restored if the statement aborts), so we call \n    ** sqlite3MayAbort() for all CREATE INDEX statements.  */\n    sqlite3MayAbort(pParse);\n    addr2 = sqlite3VdbeCurrentAddr(v);\n  }\n  sqlite3VdbeAddOp3(v, OP_SorterData, iSorter, regRecord, iIdx);\n  if( !pIndex->bAscKeyBug ){\n    /* This OP_SeekEnd opcode makes index insert for a REINDEX go much\n    ** faster by avoiding unnecessary seeks.  But the optimization does\n    ** not work for UNIQUE constraint indexes on WITHOUT ROWID tables\n    ** with DESC primary keys, since those indexes have there keys in\n    ** a different order from the main table.\n    ** See ticket: https://www.sqlite.org/src/info/bba7b69f9849b5bf\n    */\n    sqlite3VdbeAddOp1(v, OP_SeekEnd, iIdx);\n  }\n  sqlite3VdbeAddOp2(v, OP_IdxInsert, iIdx, regRecord);\n  sqlite3VdbeChangeP5(v, OPFLAG_USESEEKRESULT);\n  sqlite3ReleaseTempReg(pParse, regRecord);\n  sqlite3VdbeAddOp2(v, OP_SorterNext, iSorter, addr2); VdbeCoverage(v);\n  sqlite3VdbeJumpHere(v, addr1);\n\n  sqlite3VdbeAddOp1(v, OP_Close, iTab);\n  sqlite3VdbeAddOp1(v, OP_Close, iIdx);\n  sqlite3VdbeAddOp1(v, OP_Close, iSorter);\n}\n\n/*\n** Allocate heap space to hold an Index object with nCol columns.\n**\n** Increase the allocation size to provide an extra nExtra bytes\n** of 8-byte aligned space after the Index object and return a\n** pointer to this extra space in *ppExtra.\n*/\nIndex *sqlite3AllocateIndexObject(\n  sqlite3 *db,         /* Database connection */\n  i16 nCol,            /* Total number of columns in the index */\n  int nExtra,          /* Number of bytes of extra space to alloc */\n  char **ppExtra       /* Pointer to the \"extra\" space */\n){\n  Index *p;            /* Allocated index object */\n  int nByte;           /* Bytes of space for Index object + arrays */\n\n  nByte = ROUND8(sizeof(Index)) +              /* Index structure  */\n          ROUND8(sizeof(char*)*nCol) +         /* Index.azColl     */\n          ROUND8(sizeof(LogEst)*(nCol+1) +     /* Index.aiRowLogEst   */\n                 sizeof(i16)*nCol +            /* Index.aiColumn   */\n                 sizeof(u8)*nCol);             /* Index.aSortOrder */\n  p = sqlite3DbMallocZero(db, nByte + nExtra);\n  if( p ){\n    char *pExtra = ((char*)p)+ROUND8(sizeof(Index));\n    p->azColl = (const char**)pExtra; pExtra += ROUND8(sizeof(char*)*nCol);\n    p->aiRowLogEst = (LogEst*)pExtra; pExtra += sizeof(LogEst)*(nCol+1);\n    p->aiColumn = (i16*)pExtra;       pExtra += sizeof(i16)*nCol;\n    p->aSortOrder = (u8*)pExtra;\n    p->nColumn = nCol;\n    p->nKeyCol = nCol - 1;\n    *ppExtra = ((char*)p) + nByte;\n  }\n  return p;\n}\n\n/*\n** If expression list pList contains an expression that was parsed with\n** an explicit \"NULLS FIRST\" or \"NULLS LAST\" clause, leave an error in\n** pParse and return non-zero. Otherwise, return zero.\n*/\nint sqlite3HasExplicitNulls(Parse *pParse, ExprList *pList){\n  if( pList ){\n    int i;\n    for(i=0; i<pList->nExpr; i++){\n      if( pList->a[i].bNulls ){\n        u8 sf = pList->a[i].sortFlags;\n        sqlite3ErrorMsg(pParse, \"unsupported use of NULLS %s\", \n            (sf==0 || sf==3) ? \"FIRST\" : \"LAST\"\n        );\n        return 1;\n      }\n    }\n  }\n  return 0;\n}\n\n/*\n** Create a new index for an SQL table.  pName1.pName2 is the name of the index \n** and pTblList is the name of the table that is to be indexed.  Both will \n** be NULL for a primary key or an index that is created to satisfy a\n** UNIQUE constraint.  If pTable and pIndex are NULL, use pParse->pNewTable\n** as the table to be indexed.  pParse->pNewTable is a table that is\n** currently being constructed by a CREATE TABLE statement.\n**\n** pList is a list of columns to be indexed.  pList will be NULL if this\n** is a primary key or unique-constraint on the most recent column added\n** to the table currently under construction.  \n*/\nvoid sqlite3CreateIndex(\n  Parse *pParse,     /* All information about this parse */\n  Token *pName1,     /* First part of index name. May be NULL */\n  Token *pName2,     /* Second part of index name. May be NULL */\n  SrcList *pTblName, /* Table to index. Use pParse->pNewTable if 0 */\n  ExprList *pList,   /* A list of columns to be indexed */\n  int onError,       /* OE_Abort, OE_Ignore, OE_Replace, or OE_None */\n  Token *pStart,     /* The CREATE token that begins this statement */\n  Expr *pPIWhere,    /* WHERE clause for partial indices */\n  int sortOrder,     /* Sort order of primary key when pList==NULL */\n  int ifNotExist,    /* Omit error if index already exists */\n  u8 idxType         /* The index type */\n){\n  Table *pTab = 0;     /* Table to be indexed */\n  Index *pIndex = 0;   /* The index to be created */\n  char *zName = 0;     /* Name of the index */\n  int nName;           /* Number of characters in zName */\n  int i, j;\n  DbFixer sFix;        /* For assigning database names to pTable */\n  int sortOrderMask;   /* 1 to honor DESC in index.  0 to ignore. */\n  sqlite3 *db = pParse->db;\n  Db *pDb;             /* The specific table containing the indexed database */\n  int iDb;             /* Index of the database that is being written */\n  Token *pName = 0;    /* Unqualified name of the index to create */\n  struct ExprList_item *pListItem; /* For looping over pList */\n  int nExtra = 0;                  /* Space allocated for zExtra[] */\n  int nExtraCol;                   /* Number of extra columns needed */\n  char *zExtra = 0;                /* Extra space after the Index object */\n  Index *pPk = 0;      /* PRIMARY KEY index for WITHOUT ROWID tables */\n\n  if( db->mallocFailed || pParse->nErr>0 ){\n    goto exit_create_index;\n  }\n  if( IN_DECLARE_VTAB && idxType!=SQLITE_IDXTYPE_PRIMARYKEY ){\n    goto exit_create_index;\n  }\n  if( SQLITE_OK!=sqlite3ReadSchema(pParse) ){\n    goto exit_create_index;\n  }\n  if( sqlite3HasExplicitNulls(pParse, pList) ){\n    goto exit_create_index;\n  }\n\n  /*\n  ** Find the table that is to be indexed.  Return early if not found.\n  */\n  if( pTblName!=0 ){\n\n    /* Use the two-part index name to determine the database \n    ** to search for the table. 'Fix' the table name to this db\n    ** before looking up the table.\n    */\n    assert( pName1 && pName2 );\n    iDb = sqlite3TwoPartName(pParse, pName1, pName2, &pName);\n    if( iDb<0 ) goto exit_create_index;\n    assert( pName && pName->z );\n\n#ifndef SQLITE_OMIT_TEMPDB\n    /* If the index name was unqualified, check if the table\n    ** is a temp table. If so, set the database to 1. Do not do this\n    ** if initialising a database schema.\n    */\n    if( !db->init.busy ){\n      pTab = sqlite3SrcListLookup(pParse, pTblName);\n      if( pName2->n==0 && pTab && pTab->pSchema==db->aDb[1].pSchema ){\n        iDb = 1;\n      }\n    }\n#endif\n\n    sqlite3FixInit(&sFix, pParse, iDb, \"index\", pName);\n    if( sqlite3FixSrcList(&sFix, pTblName) ){\n      /* Because the parser constructs pTblName from a single identifier,\n      ** sqlite3FixSrcList can never fail. */\n      assert(0);\n    }\n    pTab = sqlite3LocateTableItem(pParse, 0, &pTblName->a[0]);\n    assert( db->mallocFailed==0 || pTab==0 );\n    if( pTab==0 ) goto exit_create_index;\n    if( iDb==1 && db->aDb[iDb].pSchema!=pTab->pSchema ){\n      sqlite3ErrorMsg(pParse, \n           \"cannot create a TEMP index on non-TEMP table \\\"%s\\\"\",\n           pTab->zName);\n      goto exit_create_index;\n    }\n    if( !HasRowid(pTab) ) pPk = sqlite3PrimaryKeyIndex(pTab);\n  }else{\n    assert( pName==0 );\n    assert( pStart==0 );\n    pTab = pParse->pNewTable;\n    if( !pTab ) goto exit_create_index;\n    iDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n  }\n  pDb = &db->aDb[iDb];\n\n  assert( pTab!=0 );\n  assert( pParse->nErr==0 );\n  if( sqlite3StrNICmp(pTab->zName, \"sqlite_\", 7)==0 \n       && db->init.busy==0\n       && pTblName!=0\n#if SQLITE_USER_AUTHENTICATION\n       && sqlite3UserAuthTable(pTab->zName)==0\n#endif\n#ifdef SQLITE_ALLOW_SQLITE_MASTER_INDEX\n       && sqlite3StrICmp(&pTab->zName[7],\"master\")!=0\n#endif\n ){\n    sqlite3ErrorMsg(pParse, \"table %s may not be indexed\", pTab->zName);\n    goto exit_create_index;\n  }\n#ifndef SQLITE_OMIT_VIEW\n  if( pTab->pSelect ){\n    sqlite3ErrorMsg(pParse, \"views may not be indexed\");\n    goto exit_create_index;\n  }\n#endif\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n  if( IsVirtual(pTab) ){\n    sqlite3ErrorMsg(pParse, \"virtual tables may not be indexed\");\n    goto exit_create_index;\n  }\n#endif\n\n  /*\n  ** Find the name of the index.  Make sure there is not already another\n  ** index or table with the same name.  \n  **\n  ** Exception:  If we are reading the names of permanent indices from the\n  ** sqlite_master table (because some other process changed the schema) and\n  ** one of the index names collides with the name of a temporary table or\n  ** index, then we will continue to process this index.\n  **\n  ** If pName==0 it means that we are\n  ** dealing with a primary key or UNIQUE constraint.  We have to invent our\n  ** own name.\n  */\n  if( pName ){\n    zName = sqlite3NameFromToken(db, pName);\n    if( zName==0 ) goto exit_create_index;\n    assert( pName->z!=0 );\n    if( SQLITE_OK!=sqlite3CheckObjectName(pParse, zName,\"index\",pTab->zName) ){\n      goto exit_create_index;\n    }\n    if( !IN_RENAME_OBJECT ){\n      if( !db->init.busy ){\n        if( sqlite3FindTable(db, zName, 0)!=0 ){\n          sqlite3ErrorMsg(pParse, \"there is already a table named %s\", zName);\n          goto exit_create_index;\n        }\n      }\n      if( sqlite3FindIndex(db, zName, pDb->zDbSName)!=0 ){\n        if( !ifNotExist ){\n          sqlite3ErrorMsg(pParse, \"index %s already exists\", zName);\n        }else{\n          assert( !db->init.busy );\n          sqlite3CodeVerifySchema(pParse, iDb);\n        }\n        goto exit_create_index;\n      }\n    }\n  }else{\n    int n;\n    Index *pLoop;\n    for(pLoop=pTab->pIndex, n=1; pLoop; pLoop=pLoop->pNext, n++){}\n    zName = sqlite3MPrintf(db, \"sqlite_autoindex_%s_%d\", pTab->zName, n);\n    if( zName==0 ){\n      goto exit_create_index;\n    }\n\n    /* Automatic index names generated from within sqlite3_declare_vtab()\n    ** must have names that are distinct from normal automatic index names.\n    ** The following statement converts \"sqlite3_autoindex...\" into\n    ** \"sqlite3_butoindex...\" in order to make the names distinct.\n    ** The \"vtab_err.test\" test demonstrates the need of this statement. */\n    if( IN_SPECIAL_PARSE ) zName[7]++;\n  }\n\n  /* Check for authorization to create an index.\n  */\n#ifndef SQLITE_OMIT_AUTHORIZATION\n  if( !IN_RENAME_OBJECT ){\n    const char *zDb = pDb->zDbSName;\n    if( sqlite3AuthCheck(pParse, SQLITE_INSERT, SCHEMA_TABLE(iDb), 0, zDb) ){\n      goto exit_create_index;\n    }\n    i = SQLITE_CREATE_INDEX;\n    if( !OMIT_TEMPDB && iDb==1 ) i = SQLITE_CREATE_TEMP_INDEX;\n    if( sqlite3AuthCheck(pParse, i, zName, pTab->zName, zDb) ){\n      goto exit_create_index;\n    }\n  }\n#endif\n\n  /* If pList==0, it means this routine was called to make a primary\n  ** key out of the last column added to the table under construction.\n  ** So create a fake list to simulate this.\n  */\n  if( pList==0 ){\n    Token prevCol;\n    Column *pCol = &pTab->aCol[pTab->nCol-1];\n    pCol->colFlags |= COLFLAG_UNIQUE;\n    sqlite3TokenInit(&prevCol, pCol->zName);\n    pList = sqlite3ExprListAppend(pParse, 0,\n              sqlite3ExprAlloc(db, TK_ID, &prevCol, 0));\n    if( pList==0 ) goto exit_create_index;\n    assert( pList->nExpr==1 );\n    sqlite3ExprListSetSortOrder(pList, sortOrder, SQLITE_SO_UNDEFINED);\n  }else{\n    sqlite3ExprListCheckLength(pParse, pList, \"index\");\n    if( pParse->nErr ) goto exit_create_index;\n  }\n\n  /* Figure out how many bytes of space are required to store explicitly\n  ** specified collation sequence names.\n  */\n  for(i=0; i<pList->nExpr; i++){\n    Expr *pExpr = pList->a[i].pExpr;\n    assert( pExpr!=0 );\n    if( pExpr->op==TK_COLLATE ){\n      nExtra += (1 + sqlite3Strlen30(pExpr->u.zToken));\n    }\n  }\n\n  /* \n  ** Allocate the index structure. \n  */\n  nName = sqlite3Strlen30(zName);\n  nExtraCol = pPk ? pPk->nKeyCol : 1;\n  assert( pList->nExpr + nExtraCol <= 32767 /* Fits in i16 */ );\n  pIndex = sqlite3AllocateIndexObject(db, pList->nExpr + nExtraCol,\n                                      nName + nExtra + 1, &zExtra);\n  if( db->mallocFailed ){\n    goto exit_create_index;\n  }\n  assert( EIGHT_BYTE_ALIGNMENT(pIndex->aiRowLogEst) );\n  assert( EIGHT_BYTE_ALIGNMENT(pIndex->azColl) );\n  pIndex->zName = zExtra;\n  zExtra += nName + 1;\n  memcpy(pIndex->zName, zName, nName+1);\n  pIndex->pTable = pTab;\n  pIndex->onError = (u8)onError;\n  pIndex->uniqNotNull = onError!=OE_None;\n  pIndex->idxType = idxType;\n  pIndex->pSchema = db->aDb[iDb].pSchema;\n  pIndex->nKeyCol = pList->nExpr;\n  if( pPIWhere ){\n    sqlite3ResolveSelfReference(pParse, pTab, NC_PartIdx, pPIWhere, 0);\n    pIndex->pPartIdxWhere = pPIWhere;\n    pPIWhere = 0;\n  }\n  assert( sqlite3SchemaMutexHeld(db, iDb, 0) );\n\n  /* Check to see if we should honor DESC requests on index columns\n  */\n  if( pDb->pSchema->file_format>=4 ){\n    sortOrderMask = -1;   /* Honor DESC */\n  }else{\n    sortOrderMask = 0;    /* Ignore DESC */\n  }\n\n  /* Analyze the list of expressions that form the terms of the index and\n  ** report any errors.  In the common case where the expression is exactly\n  ** a table column, store that column in aiColumn[].  For general expressions,\n  ** populate pIndex->aColExpr and store XN_EXPR (-2) in aiColumn[].\n  **\n  ** TODO: Issue a warning if two or more columns of the index are identical.\n  ** TODO: Issue a warning if the table primary key is used as part of the\n  ** index key.\n  */\n  pListItem = pList->a;\n  if( IN_RENAME_OBJECT ){\n    pIndex->aColExpr = pList;\n    pList = 0;\n  }\n  for(i=0; i<pIndex->nKeyCol; i++, pListItem++){\n    Expr *pCExpr;                  /* The i-th index expression */\n    int requestedSortOrder;        /* ASC or DESC on the i-th expression */\n    const char *zColl;             /* Collation sequence name */\n\n    sqlite3StringToId(pListItem->pExpr);\n    sqlite3ResolveSelfReference(pParse, pTab, NC_IdxExpr, pListItem->pExpr, 0);\n    if( pParse->nErr ) goto exit_create_index;\n    pCExpr = sqlite3ExprSkipCollate(pListItem->pExpr);\n    if( pCExpr->op!=TK_COLUMN ){\n      if( pTab==pParse->pNewTable ){\n        sqlite3ErrorMsg(pParse, \"expressions prohibited in PRIMARY KEY and \"\n                                \"UNIQUE constraints\");\n        goto exit_create_index;\n      }\n      if( pIndex->aColExpr==0 ){\n        pIndex->aColExpr = pList;\n        pList = 0;\n      }\n      j = XN_EXPR;\n      pIndex->aiColumn[i] = XN_EXPR;\n      pIndex->uniqNotNull = 0;\n    }else{\n      j = pCExpr->iColumn;\n      assert( j<=0x7fff );\n      if( j<0 ){\n        j = pTab->iPKey;\n      }else{\n        if( pTab->aCol[j].notNull==0 ){\n          pIndex->uniqNotNull = 0;\n        }\n        if( pTab->aCol[j].colFlags & COLFLAG_VIRTUAL ){\n          pIndex->bHasVCol = 1;\n        }\n      }\n      pIndex->aiColumn[i] = (i16)j;\n    }\n    zColl = 0;\n    if( pListItem->pExpr->op==TK_COLLATE ){\n      int nColl;\n      zColl = pListItem->pExpr->u.zToken;\n      nColl = sqlite3Strlen30(zColl) + 1;\n      assert( nExtra>=nColl );\n      memcpy(zExtra, zColl, nColl);\n      zColl = zExtra;\n      zExtra += nColl;\n      nExtra -= nColl;\n    }else if( j>=0 ){\n      zColl = pTab->aCol[j].zColl;\n    }\n    if( !zColl ) zColl = sqlite3StrBINARY;\n    if( !db->init.busy && !sqlite3LocateCollSeq(pParse, zColl) ){\n      goto exit_create_index;\n    }\n    pIndex->azColl[i] = zColl;\n    requestedSortOrder = pListItem->sortFlags & sortOrderMask;\n    pIndex->aSortOrder[i] = (u8)requestedSortOrder;\n  }\n\n  /* Append the table key to the end of the index.  For WITHOUT ROWID\n  ** tables (when pPk!=0) this will be the declared PRIMARY KEY.  For\n  ** normal tables (when pPk==0) this will be the rowid.\n  */\n  if( pPk ){\n    for(j=0; j<pPk->nKeyCol; j++){\n      int x = pPk->aiColumn[j];\n      assert( x>=0 );\n      if( isDupColumn(pIndex, pIndex->nKeyCol, pPk, j) ){\n        pIndex->nColumn--; \n      }else{\n        testcase( hasColumn(pIndex->aiColumn,pIndex->nKeyCol,x) );\n        pIndex->aiColumn[i] = x;\n        pIndex->azColl[i] = pPk->azColl[j];\n        pIndex->aSortOrder[i] = pPk->aSortOrder[j];\n        i++;\n      }\n    }\n    assert( i==pIndex->nColumn );\n  }else{\n    pIndex->aiColumn[i] = XN_ROWID;\n    pIndex->azColl[i] = sqlite3StrBINARY;\n  }\n  sqlite3DefaultRowEst(pIndex);\n  if( pParse->pNewTable==0 ) estimateIndexWidth(pIndex);\n\n  /* If this index contains every column of its table, then mark\n  ** it as a covering index */\n  assert( HasRowid(pTab) \n      || pTab->iPKey<0 || sqlite3TableColumnToIndex(pIndex, pTab->iPKey)>=0 );\n  recomputeColumnsNotIndexed(pIndex);\n  if( pTblName!=0 && pIndex->nColumn>=pTab->nCol ){\n    pIndex->isCovering = 1;\n    for(j=0; j<pTab->nCol; j++){\n      if( j==pTab->iPKey ) continue;\n      if( sqlite3TableColumnToIndex(pIndex,j)>=0 ) continue;\n      pIndex->isCovering = 0;\n      break;\n    }\n  }\n\n  if( pTab==pParse->pNewTable ){\n    /* This routine has been called to create an automatic index as a\n    ** result of a PRIMARY KEY or UNIQUE clause on a column definition, or\n    ** a PRIMARY KEY or UNIQUE clause following the column definitions.\n    ** i.e. one of:\n    **\n    ** CREATE TABLE t(x PRIMARY KEY, y);\n    ** CREATE TABLE t(x, y, UNIQUE(x, y));\n    **\n    ** Either way, check to see if the table already has such an index. If\n    ** so, don't bother creating this one. This only applies to\n    ** automatically created indices. Users can do as they wish with\n    ** explicit indices.\n    **\n    ** Two UNIQUE or PRIMARY KEY constraints are considered equivalent\n    ** (and thus suppressing the second one) even if they have different\n    ** sort orders.\n    **\n    ** If there are different collating sequences or if the columns of\n    ** the constraint occur in different orders, then the constraints are\n    ** considered distinct and both result in separate indices.\n    */\n    Index *pIdx;\n    for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){\n      int k;\n      assert( IsUniqueIndex(pIdx) );\n      assert( pIdx->idxType!=SQLITE_IDXTYPE_APPDEF );\n      assert( IsUniqueIndex(pIndex) );\n\n      if( pIdx->nKeyCol!=pIndex->nKeyCol ) continue;\n      for(k=0; k<pIdx->nKeyCol; k++){\n        const char *z1;\n        const char *z2;\n        assert( pIdx->aiColumn[k]>=0 );\n        if( pIdx->aiColumn[k]!=pIndex->aiColumn[k] ) break;\n        z1 = pIdx->azColl[k];\n        z2 = pIndex->azColl[k];\n        if( sqlite3StrICmp(z1, z2) ) break;\n      }\n      if( k==pIdx->nKeyCol ){\n        if( pIdx->onError!=pIndex->onError ){\n          /* This constraint creates the same index as a previous\n          ** constraint specified somewhere in the CREATE TABLE statement.\n          ** However the ON CONFLICT clauses are different. If both this \n          ** constraint and the previous equivalent constraint have explicit\n          ** ON CONFLICT clauses this is an error. Otherwise, use the\n          ** explicitly specified behavior for the index.\n          */\n          if( !(pIdx->onError==OE_Default || pIndex->onError==OE_Default) ){\n            sqlite3ErrorMsg(pParse, \n                \"conflicting ON CONFLICT clauses specified\", 0);\n          }\n          if( pIdx->onError==OE_Default ){\n            pIdx->onError = pIndex->onError;\n          }\n        }\n        if( idxType==SQLITE_IDXTYPE_PRIMARYKEY ) pIdx->idxType = idxType;\n        if( IN_RENAME_OBJECT ){\n          pIndex->pNext = pParse->pNewIndex;\n          pParse->pNewIndex = pIndex;\n          pIndex = 0;\n        }\n        goto exit_create_index;\n      }\n    }\n  }\n\n  if( !IN_RENAME_OBJECT ){\n\n    /* Link the new Index structure to its table and to the other\n    ** in-memory database structures. \n    */\n    assert( pParse->nErr==0 );\n    if( db->init.busy ){\n      Index *p;\n      assert( !IN_SPECIAL_PARSE );\n      assert( sqlite3SchemaMutexHeld(db, 0, pIndex->pSchema) );\n      if( pTblName!=0 ){\n        pIndex->tnum = db->init.newTnum;\n        if( sqlite3IndexHasDuplicateRootPage(pIndex) ){\n          sqlite3ErrorMsg(pParse, \"invalid rootpage\");\n          pParse->rc = SQLITE_CORRUPT_BKPT;\n          goto exit_create_index;\n        }\n      }\n      p = sqlite3HashInsert(&pIndex->pSchema->idxHash, \n          pIndex->zName, pIndex);\n      if( p ){\n        assert( p==pIndex );  /* Malloc must have failed */\n        sqlite3OomFault(db);\n        goto exit_create_index;\n      }\n      db->mDbFlags |= DBFLAG_SchemaChange;\n    }\n\n    /* If this is the initial CREATE INDEX statement (or CREATE TABLE if the\n    ** index is an implied index for a UNIQUE or PRIMARY KEY constraint) then\n    ** emit code to allocate the index rootpage on disk and make an entry for\n    ** the index in the sqlite_master table and populate the index with\n    ** content.  But, do not do this if we are simply reading the sqlite_master\n    ** table to parse the schema, or if this index is the PRIMARY KEY index\n    ** of a WITHOUT ROWID table.\n    **\n    ** If pTblName==0 it means this index is generated as an implied PRIMARY KEY\n    ** or UNIQUE index in a CREATE TABLE statement.  Since the table\n    ** has just been created, it contains no data and the index initialization\n    ** step can be skipped.\n    */\n    else if( HasRowid(pTab) || pTblName!=0 ){\n      Vdbe *v;\n      char *zStmt;\n      int iMem = ++pParse->nMem;\n\n      v = sqlite3GetVdbe(pParse);\n      if( v==0 ) goto exit_create_index;\n\n      sqlite3BeginWriteOperation(pParse, 1, iDb);\n\n      /* Create the rootpage for the index using CreateIndex. But before\n      ** doing so, code a Noop instruction and store its address in \n      ** Index.tnum. This is required in case this index is actually a \n      ** PRIMARY KEY and the table is actually a WITHOUT ROWID table. In \n      ** that case the convertToWithoutRowidTable() routine will replace\n      ** the Noop with a Goto to jump over the VDBE code generated below. */\n      pIndex->tnum = sqlite3VdbeAddOp0(v, OP_Noop);\n      sqlite3VdbeAddOp3(v, OP_CreateBtree, iDb, iMem, BTREE_BLOBKEY);\n\n      /* Gather the complete text of the CREATE INDEX statement into\n      ** the zStmt variable\n      */\n      assert( pName!=0 || pStart==0 );\n      if( pStart ){\n        int n = (int)(pParse->sLastToken.z - pName->z) + pParse->sLastToken.n;\n        if( pName->z[n-1]==';' ) n--;\n        /* A named index with an explicit CREATE INDEX statement */\n        zStmt = sqlite3MPrintf(db, \"CREATE%s INDEX %.*s\",\n            onError==OE_None ? \"\" : \" UNIQUE\", n, pName->z);\n      }else{\n        /* An automatic index created by a PRIMARY KEY or UNIQUE constraint */\n        /* zStmt = sqlite3MPrintf(\"\"); */\n        zStmt = 0;\n      }\n\n      /* Add an entry in sqlite_master for this index\n      */\n      sqlite3NestedParse(pParse, \n          \"INSERT INTO %Q.%s VALUES('index',%Q,%Q,#%d,%Q);\",\n          db->aDb[iDb].zDbSName, MASTER_NAME,\n          pIndex->zName,\n          pTab->zName,\n          iMem,\n          zStmt\n          );\n      sqlite3DbFree(db, zStmt);\n\n      /* Fill the index with data and reparse the schema. Code an OP_Expire\n      ** to invalidate all pre-compiled statements.\n      */\n      if( pTblName ){\n        sqlite3RefillIndex(pParse, pIndex, iMem);\n        sqlite3ChangeCookie(pParse, iDb);\n        sqlite3VdbeAddParseSchemaOp(v, iDb,\n            sqlite3MPrintf(db, \"name='%q' AND type='index'\", pIndex->zName));\n        sqlite3VdbeAddOp2(v, OP_Expire, 0, 1);\n      }\n\n      sqlite3VdbeJumpHere(v, pIndex->tnum);\n    }\n  }\n\n  /* When adding an index to the list of indices for a table, make\n  ** sure all indices labeled OE_Replace come after all those labeled\n  ** OE_Ignore.  This is necessary for the correct constraint check\n  ** processing (in sqlite3GenerateConstraintChecks()) as part of\n  ** UPDATE and INSERT statements.  \n  */\n  if( db->init.busy || pTblName==0 ){\n    if( onError!=OE_Replace || pTab->pIndex==0\n         || pTab->pIndex->onError==OE_Replace){\n      pIndex->pNext = pTab->pIndex;\n      pTab->pIndex = pIndex;\n    }else{\n      Index *pOther = pTab->pIndex;\n      while( pOther->pNext && pOther->pNext->onError!=OE_Replace ){\n        pOther = pOther->pNext;\n      }\n      pIndex->pNext = pOther->pNext;\n      pOther->pNext = pIndex;\n    }\n    pIndex = 0;\n  }\n  else if( IN_RENAME_OBJECT ){\n    assert( pParse->pNewIndex==0 );\n    pParse->pNewIndex = pIndex;\n    pIndex = 0;\n  }\n\n  /* Clean up before exiting */\nexit_create_index:\n  if( pIndex ) sqlite3FreeIndex(db, pIndex);\n  sqlite3ExprDelete(db, pPIWhere);\n  sqlite3ExprListDelete(db, pList);\n  sqlite3SrcListDelete(db, pTblName);\n  sqlite3DbFree(db, zName);\n}\n\n/*\n** Fill the Index.aiRowEst[] array with default information - information\n** to be used when we have not run the ANALYZE command.\n**\n** aiRowEst[0] is supposed to contain the number of elements in the index.\n** Since we do not know, guess 1 million.  aiRowEst[1] is an estimate of the\n** number of rows in the table that match any particular value of the\n** first column of the index.  aiRowEst[2] is an estimate of the number\n** of rows that match any particular combination of the first 2 columns\n** of the index.  And so forth.  It must always be the case that\n*\n**           aiRowEst[N]<=aiRowEst[N-1]\n**           aiRowEst[N]>=1\n**\n** Apart from that, we have little to go on besides intuition as to\n** how aiRowEst[] should be initialized.  The numbers generated here\n** are based on typical values found in actual indices.\n*/\nvoid sqlite3DefaultRowEst(Index *pIdx){\n  /*                10,  9,  8,  7,  6 */\n  LogEst aVal[] = { 33, 32, 30, 28, 26 };\n  LogEst *a = pIdx->aiRowLogEst;\n  int nCopy = MIN(ArraySize(aVal), pIdx->nKeyCol);\n  int i;\n\n  /* Indexes with default row estimates should not have stat1 data */\n  assert( !pIdx->hasStat1 );\n\n  /* Set the first entry (number of rows in the index) to the estimated \n  ** number of rows in the table, or half the number of rows in the table\n  ** for a partial index.   But do not let the estimate drop below 10. */\n  a[0] = pIdx->pTable->nRowLogEst;\n  if( pIdx->pPartIdxWhere!=0 ) a[0] -= 10;  assert( 10==sqlite3LogEst(2) );\n  if( a[0]<33 ) a[0] = 33;                  assert( 33==sqlite3LogEst(10) );\n\n  /* Estimate that a[1] is 10, a[2] is 9, a[3] is 8, a[4] is 7, a[5] is\n  ** 6 and each subsequent value (if any) is 5.  */\n  memcpy(&a[1], aVal, nCopy*sizeof(LogEst));\n  for(i=nCopy+1; i<=pIdx->nKeyCol; i++){\n    a[i] = 23;                    assert( 23==sqlite3LogEst(5) );\n  }\n\n  assert( 0==sqlite3LogEst(1) );\n  if( IsUniqueIndex(pIdx) ) a[pIdx->nKeyCol] = 0;\n}\n\n/*\n** This routine will drop an existing named index.  This routine\n** implements the DROP INDEX statement.\n*/\nvoid sqlite3DropIndex(Parse *pParse, SrcList *pName, int ifExists){\n  Index *pIndex;\n  Vdbe *v;\n  sqlite3 *db = pParse->db;\n  int iDb;\n\n  assert( pParse->nErr==0 );   /* Never called with prior errors */\n  if( db->mallocFailed ){\n    goto exit_drop_index;\n  }\n  assert( pName->nSrc==1 );\n  if( SQLITE_OK!=sqlite3ReadSchema(pParse) ){\n    goto exit_drop_index;\n  }\n  pIndex = sqlite3FindIndex(db, pName->a[0].zName, pName->a[0].zDatabase);\n  if( pIndex==0 ){\n    if( !ifExists ){\n      sqlite3ErrorMsg(pParse, \"no such index: %S\", pName, 0);\n    }else{\n      sqlite3CodeVerifyNamedSchema(pParse, pName->a[0].zDatabase);\n    }\n    pParse->checkSchema = 1;\n    goto exit_drop_index;\n  }\n  if( pIndex->idxType!=SQLITE_IDXTYPE_APPDEF ){\n    sqlite3ErrorMsg(pParse, \"index associated with UNIQUE \"\n      \"or PRIMARY KEY constraint cannot be dropped\", 0);\n    goto exit_drop_index;\n  }\n  iDb = sqlite3SchemaToIndex(db, pIndex->pSchema);\n#ifndef SQLITE_OMIT_AUTHORIZATION\n  {\n    int code = SQLITE_DROP_INDEX;\n    Table *pTab = pIndex->pTable;\n    const char *zDb = db->aDb[iDb].zDbSName;\n    const char *zTab = SCHEMA_TABLE(iDb);\n    if( sqlite3AuthCheck(pParse, SQLITE_DELETE, zTab, 0, zDb) ){\n      goto exit_drop_index;\n    }\n    if( !OMIT_TEMPDB && iDb ) code = SQLITE_DROP_TEMP_INDEX;\n    if( sqlite3AuthCheck(pParse, code, pIndex->zName, pTab->zName, zDb) ){\n      goto exit_drop_index;\n    }\n  }\n#endif\n\n  /* Generate code to remove the index and from the master table */\n  v = sqlite3GetVdbe(pParse);\n  if( v ){\n    sqlite3BeginWriteOperation(pParse, 1, iDb);\n    sqlite3NestedParse(pParse,\n       \"DELETE FROM %Q.%s WHERE name=%Q AND type='index'\",\n       db->aDb[iDb].zDbSName, MASTER_NAME, pIndex->zName\n    );\n    sqlite3ClearStatTables(pParse, iDb, \"idx\", pIndex->zName);\n    sqlite3ChangeCookie(pParse, iDb);\n    destroyRootPage(pParse, pIndex->tnum, iDb);\n    sqlite3VdbeAddOp4(v, OP_DropIndex, iDb, 0, 0, pIndex->zName, 0);\n  }\n\nexit_drop_index:\n  sqlite3SrcListDelete(db, pName);\n}\n\n/*\n** pArray is a pointer to an array of objects. Each object in the\n** array is szEntry bytes in size. This routine uses sqlite3DbRealloc()\n** to extend the array so that there is space for a new object at the end.\n**\n** When this function is called, *pnEntry contains the current size of\n** the array (in entries - so the allocation is ((*pnEntry) * szEntry) bytes\n** in total).\n**\n** If the realloc() is successful (i.e. if no OOM condition occurs), the\n** space allocated for the new object is zeroed, *pnEntry updated to\n** reflect the new size of the array and a pointer to the new allocation\n** returned. *pIdx is set to the index of the new array entry in this case.\n**\n** Otherwise, if the realloc() fails, *pIdx is set to -1, *pnEntry remains\n** unchanged and a copy of pArray returned.\n*/\nvoid *sqlite3ArrayAllocate(\n  sqlite3 *db,      /* Connection to notify of malloc failures */\n  void *pArray,     /* Array of objects.  Might be reallocated */\n  int szEntry,      /* Size of each object in the array */\n  int *pnEntry,     /* Number of objects currently in use */\n  int *pIdx         /* Write the index of a new slot here */\n){\n  char *z;\n  sqlite3_int64 n = *pIdx = *pnEntry;\n  if( (n & (n-1))==0 ){\n    sqlite3_int64 sz = (n==0) ? 1 : 2*n;\n    void *pNew = sqlite3DbRealloc(db, pArray, sz*szEntry);\n    if( pNew==0 ){\n      *pIdx = -1;\n      return pArray;\n    }\n    pArray = pNew;\n  }\n  z = (char*)pArray;\n  memset(&z[n * szEntry], 0, szEntry);\n  ++*pnEntry;\n  return pArray;\n}\n\n/*\n** Append a new element to the given IdList.  Create a new IdList if\n** need be.\n**\n** A new IdList is returned, or NULL if malloc() fails.\n*/\nIdList *sqlite3IdListAppend(Parse *pParse, IdList *pList, Token *pToken){\n  sqlite3 *db = pParse->db;\n  int i;\n  if( pList==0 ){\n    pList = sqlite3DbMallocZero(db, sizeof(IdList) );\n    if( pList==0 ) return 0;\n  }\n  pList->a = sqlite3ArrayAllocate(\n      db,\n      pList->a,\n      sizeof(pList->a[0]),\n      &pList->nId,\n      &i\n  );\n  if( i<0 ){\n    sqlite3IdListDelete(db, pList);\n    return 0;\n  }\n  pList->a[i].zName = sqlite3NameFromToken(db, pToken);\n  if( IN_RENAME_OBJECT && pList->a[i].zName ){\n    sqlite3RenameTokenMap(pParse, (void*)pList->a[i].zName, pToken);\n  }\n  return pList;\n}\n\n/*\n** Delete an IdList.\n*/\nvoid sqlite3IdListDelete(sqlite3 *db, IdList *pList){\n  int i;\n  if( pList==0 ) return;\n  for(i=0; i<pList->nId; i++){\n    sqlite3DbFree(db, pList->a[i].zName);\n  }\n  sqlite3DbFree(db, pList->a);\n  sqlite3DbFreeNN(db, pList);\n}\n\n/*\n** Return the index in pList of the identifier named zId.  Return -1\n** if not found.\n*/\nint sqlite3IdListIndex(IdList *pList, const char *zName){\n  int i;\n  if( pList==0 ) return -1;\n  for(i=0; i<pList->nId; i++){\n    if( sqlite3StrICmp(pList->a[i].zName, zName)==0 ) return i;\n  }\n  return -1;\n}\n\n/*\n** Maximum size of a SrcList object.\n** The SrcList object is used to represent the FROM clause of a\n** SELECT statement, and the query planner cannot deal with more\n** than 64 tables in a join.  So any value larger than 64 here\n** is sufficient for most uses.  Smaller values, like say 10, are\n** appropriate for small and memory-limited applications.\n*/\n#ifndef SQLITE_MAX_SRCLIST\n# define SQLITE_MAX_SRCLIST 200\n#endif\n\n/*\n** Expand the space allocated for the given SrcList object by\n** creating nExtra new slots beginning at iStart.  iStart is zero based.\n** New slots are zeroed.\n**\n** For example, suppose a SrcList initially contains two entries: A,B.\n** To append 3 new entries onto the end, do this:\n**\n**    sqlite3SrcListEnlarge(db, pSrclist, 3, 2);\n**\n** After the call above it would contain:  A, B, nil, nil, nil.\n** If the iStart argument had been 1 instead of 2, then the result\n** would have been:  A, nil, nil, nil, B.  To prepend the new slots,\n** the iStart value would be 0.  The result then would\n** be: nil, nil, nil, A, B.\n**\n** If a memory allocation fails or the SrcList becomes too large, leave\n** the original SrcList unchanged, return NULL, and leave an error message\n** in pParse.\n*/\nSrcList *sqlite3SrcListEnlarge(\n  Parse *pParse,     /* Parsing context into which errors are reported */\n  SrcList *pSrc,     /* The SrcList to be enlarged */\n  int nExtra,        /* Number of new slots to add to pSrc->a[] */\n  int iStart         /* Index in pSrc->a[] of first new slot */\n){\n  int i;\n\n  /* Sanity checking on calling parameters */\n  assert( iStart>=0 );\n  assert( nExtra>=1 );\n  assert( pSrc!=0 );\n  assert( iStart<=pSrc->nSrc );\n\n  /* Allocate additional space if needed */\n  if( (u32)pSrc->nSrc+nExtra>pSrc->nAlloc ){\n    SrcList *pNew;\n    sqlite3_int64 nAlloc = 2*(sqlite3_int64)pSrc->nSrc+nExtra;\n    sqlite3 *db = pParse->db;\n\n    if( pSrc->nSrc+nExtra>=SQLITE_MAX_SRCLIST ){\n      sqlite3ErrorMsg(pParse, \"too many FROM clause terms, max: %d\",\n                      SQLITE_MAX_SRCLIST);\n      return 0;\n    }\n    if( nAlloc>SQLITE_MAX_SRCLIST ) nAlloc = SQLITE_MAX_SRCLIST;\n    pNew = sqlite3DbRealloc(db, pSrc,\n               sizeof(*pSrc) + (nAlloc-1)*sizeof(pSrc->a[0]) );\n    if( pNew==0 ){\n      assert( db->mallocFailed );\n      return 0;\n    }\n    pSrc = pNew;\n    pSrc->nAlloc = nAlloc;\n  }\n\n  /* Move existing slots that come after the newly inserted slots\n  ** out of the way */\n  for(i=pSrc->nSrc-1; i>=iStart; i--){\n    pSrc->a[i+nExtra] = pSrc->a[i];\n  }\n  pSrc->nSrc += nExtra;\n\n  /* Zero the newly allocated slots */\n  memset(&pSrc->a[iStart], 0, sizeof(pSrc->a[0])*nExtra);\n  for(i=iStart; i<iStart+nExtra; i++){\n    pSrc->a[i].iCursor = -1;\n  }\n\n  /* Return a pointer to the enlarged SrcList */\n  return pSrc;\n}\n\n\n/*\n** Append a new table name to the given SrcList.  Create a new SrcList if\n** need be.  A new entry is created in the SrcList even if pTable is NULL.\n**\n** A SrcList is returned, or NULL if there is an OOM error or if the\n** SrcList grows to large.  The returned\n** SrcList might be the same as the SrcList that was input or it might be\n** a new one.  If an OOM error does occurs, then the prior value of pList\n** that is input to this routine is automatically freed.\n**\n** If pDatabase is not null, it means that the table has an optional\n** database name prefix.  Like this:  \"database.table\".  The pDatabase\n** points to the table name and the pTable points to the database name.\n** The SrcList.a[].zName field is filled with the table name which might\n** come from pTable (if pDatabase is NULL) or from pDatabase.  \n** SrcList.a[].zDatabase is filled with the database name from pTable,\n** or with NULL if no database is specified.\n**\n** In other words, if call like this:\n**\n**         sqlite3SrcListAppend(D,A,B,0);\n**\n** Then B is a table name and the database name is unspecified.  If called\n** like this:\n**\n**         sqlite3SrcListAppend(D,A,B,C);\n**\n** Then C is the table name and B is the database name.  If C is defined\n** then so is B.  In other words, we never have a case where:\n**\n**         sqlite3SrcListAppend(D,A,0,C);\n**\n** Both pTable and pDatabase are assumed to be quoted.  They are dequoted\n** before being added to the SrcList.\n*/\nSrcList *sqlite3SrcListAppend(\n  Parse *pParse,      /* Parsing context, in which errors are reported */\n  SrcList *pList,     /* Append to this SrcList. NULL creates a new SrcList */\n  Token *pTable,      /* Table to append */\n  Token *pDatabase    /* Database of the table */\n){\n  struct SrcList_item *pItem;\n  sqlite3 *db;\n  assert( pDatabase==0 || pTable!=0 );  /* Cannot have C without B */\n  assert( pParse!=0 );\n  assert( pParse->db!=0 );\n  db = pParse->db;\n  if( pList==0 ){\n    pList = sqlite3DbMallocRawNN(pParse->db, sizeof(SrcList) );\n    if( pList==0 ) return 0;\n    pList->nAlloc = 1;\n    pList->nSrc = 1;\n    memset(&pList->a[0], 0, sizeof(pList->a[0]));\n    pList->a[0].iCursor = -1;\n  }else{\n    SrcList *pNew = sqlite3SrcListEnlarge(pParse, pList, 1, pList->nSrc);\n    if( pNew==0 ){\n      sqlite3SrcListDelete(db, pList);\n      return 0;\n    }else{\n      pList = pNew;\n    }\n  }\n  pItem = &pList->a[pList->nSrc-1];\n  if( pDatabase && pDatabase->z==0 ){\n    pDatabase = 0;\n  }\n  if( pDatabase ){\n    pItem->zName = sqlite3NameFromToken(db, pDatabase);\n    pItem->zDatabase = sqlite3NameFromToken(db, pTable);\n  }else{\n    pItem->zName = sqlite3NameFromToken(db, pTable);\n    pItem->zDatabase = 0;\n  }\n  return pList;\n}\n\n/*\n** Assign VdbeCursor index numbers to all tables in a SrcList\n*/\nvoid sqlite3SrcListAssignCursors(Parse *pParse, SrcList *pList){\n  int i;\n  struct SrcList_item *pItem;\n  assert(pList || pParse->db->mallocFailed );\n  if( pList ){\n    for(i=0, pItem=pList->a; i<pList->nSrc; i++, pItem++){\n      if( pItem->iCursor>=0 ) break;\n      pItem->iCursor = pParse->nTab++;\n      if( pItem->pSelect ){\n        sqlite3SrcListAssignCursors(pParse, pItem->pSelect->pSrc);\n      }\n    }\n  }\n}\n\n/*\n** Delete an entire SrcList including all its substructure.\n*/\nvoid sqlite3SrcListDelete(sqlite3 *db, SrcList *pList){\n  int i;\n  struct SrcList_item *pItem;\n  if( pList==0 ) return;\n  for(pItem=pList->a, i=0; i<pList->nSrc; i++, pItem++){\n    sqlite3DbFree(db, pItem->zDatabase);\n    sqlite3DbFree(db, pItem->zName);\n    sqlite3DbFree(db, pItem->zAlias);\n    if( pItem->fg.isIndexedBy ) sqlite3DbFree(db, pItem->u1.zIndexedBy);\n    if( pItem->fg.isTabFunc ) sqlite3ExprListDelete(db, pItem->u1.pFuncArg);\n    sqlite3DeleteTable(db, pItem->pTab);\n    sqlite3SelectDelete(db, pItem->pSelect);\n    sqlite3ExprDelete(db, pItem->pOn);\n    sqlite3IdListDelete(db, pItem->pUsing);\n  }\n  sqlite3DbFreeNN(db, pList);\n}\n\n/*\n** This routine is called by the parser to add a new term to the\n** end of a growing FROM clause.  The \"p\" parameter is the part of\n** the FROM clause that has already been constructed.  \"p\" is NULL\n** if this is the first term of the FROM clause.  pTable and pDatabase\n** are the name of the table and database named in the FROM clause term.\n** pDatabase is NULL if the database name qualifier is missing - the\n** usual case.  If the term has an alias, then pAlias points to the\n** alias token.  If the term is a subquery, then pSubquery is the\n** SELECT statement that the subquery encodes.  The pTable and\n** pDatabase parameters are NULL for subqueries.  The pOn and pUsing\n** parameters are the content of the ON and USING clauses.\n**\n** Return a new SrcList which encodes is the FROM with the new\n** term added.\n*/\nSrcList *sqlite3SrcListAppendFromTerm(\n  Parse *pParse,          /* Parsing context */\n  SrcList *p,             /* The left part of the FROM clause already seen */\n  Token *pTable,          /* Name of the table to add to the FROM clause */\n  Token *pDatabase,       /* Name of the database containing pTable */\n  Token *pAlias,          /* The right-hand side of the AS subexpression */\n  Select *pSubquery,      /* A subquery used in place of a table name */\n  Expr *pOn,              /* The ON clause of a join */\n  IdList *pUsing          /* The USING clause of a join */\n){\n  struct SrcList_item *pItem;\n  sqlite3 *db = pParse->db;\n  if( !p && (pOn || pUsing) ){\n    sqlite3ErrorMsg(pParse, \"a JOIN clause is required before %s\", \n      (pOn ? \"ON\" : \"USING\")\n    );\n    goto append_from_error;\n  }\n  p = sqlite3SrcListAppend(pParse, p, pTable, pDatabase);\n  if( p==0 ){\n    goto append_from_error;\n  }\n  assert( p->nSrc>0 );\n  pItem = &p->a[p->nSrc-1];\n  assert( (pTable==0)==(pDatabase==0) );\n  assert( pItem->zName==0 || pDatabase!=0 );\n  if( IN_RENAME_OBJECT && pItem->zName ){\n    Token *pToken = (ALWAYS(pDatabase) && pDatabase->z) ? pDatabase : pTable;\n    sqlite3RenameTokenMap(pParse, pItem->zName, pToken);\n  }\n  assert( pAlias!=0 );\n  if( pAlias->n ){\n    pItem->zAlias = sqlite3NameFromToken(db, pAlias);\n  }\n  pItem->pSelect = pSubquery;\n  pItem->pOn = pOn;\n  pItem->pUsing = pUsing;\n  return p;\n\n append_from_error:\n  assert( p==0 );\n  sqlite3ExprDelete(db, pOn);\n  sqlite3IdListDelete(db, pUsing);\n  sqlite3SelectDelete(db, pSubquery);\n  return 0;\n}\n\n/*\n** Add an INDEXED BY or NOT INDEXED clause to the most recently added \n** element of the source-list passed as the second argument.\n*/\nvoid sqlite3SrcListIndexedBy(Parse *pParse, SrcList *p, Token *pIndexedBy){\n  assert( pIndexedBy!=0 );\n  if( p && pIndexedBy->n>0 ){\n    struct SrcList_item *pItem;\n    assert( p->nSrc>0 );\n    pItem = &p->a[p->nSrc-1];\n    assert( pItem->fg.notIndexed==0 );\n    assert( pItem->fg.isIndexedBy==0 );\n    assert( pItem->fg.isTabFunc==0 );\n    if( pIndexedBy->n==1 && !pIndexedBy->z ){\n      /* A \"NOT INDEXED\" clause was supplied. See parse.y \n      ** construct \"indexed_opt\" for details. */\n      pItem->fg.notIndexed = 1;\n    }else{\n      pItem->u1.zIndexedBy = sqlite3NameFromToken(pParse->db, pIndexedBy);\n      pItem->fg.isIndexedBy = 1;\n    }\n  }\n}\n\n/*\n** Add the list of function arguments to the SrcList entry for a\n** table-valued-function.\n*/\nvoid sqlite3SrcListFuncArgs(Parse *pParse, SrcList *p, ExprList *pList){\n  if( p ){\n    struct SrcList_item *pItem = &p->a[p->nSrc-1];\n    assert( pItem->fg.notIndexed==0 );\n    assert( pItem->fg.isIndexedBy==0 );\n    assert( pItem->fg.isTabFunc==0 );\n    pItem->u1.pFuncArg = pList;\n    pItem->fg.isTabFunc = 1;\n  }else{\n    sqlite3ExprListDelete(pParse->db, pList);\n  }\n}\n\n/*\n** When building up a FROM clause in the parser, the join operator\n** is initially attached to the left operand.  But the code generator\n** expects the join operator to be on the right operand.  This routine\n** Shifts all join operators from left to right for an entire FROM\n** clause.\n**\n** Example: Suppose the join is like this:\n**\n**           A natural cross join B\n**\n** The operator is \"natural cross join\".  The A and B operands are stored\n** in p->a[0] and p->a[1], respectively.  The parser initially stores the\n** operator with A.  This routine shifts that operator over to B.\n*/\nvoid sqlite3SrcListShiftJoinType(SrcList *p){\n  if( p ){\n    int i;\n    for(i=p->nSrc-1; i>0; i--){\n      p->a[i].fg.jointype = p->a[i-1].fg.jointype;\n    }\n    p->a[0].fg.jointype = 0;\n  }\n}\n\n/*\n** Generate VDBE code for a BEGIN statement.\n*/\nvoid sqlite3BeginTransaction(Parse *pParse, int type){\n  sqlite3 *db;\n  Vdbe *v;\n  int i;\n\n  assert( pParse!=0 );\n  db = pParse->db;\n  assert( db!=0 );\n  if( sqlite3AuthCheck(pParse, SQLITE_TRANSACTION, \"BEGIN\", 0, 0) ){\n    return;\n  }\n  v = sqlite3GetVdbe(pParse);\n  if( !v ) return;\n  if( type!=TK_DEFERRED ){\n    for(i=0; i<db->nDb; i++){\n      sqlite3VdbeAddOp2(v, OP_Transaction, i, (type==TK_EXCLUSIVE)+1);\n      sqlite3VdbeUsesBtree(v, i);\n    }\n  }\n  sqlite3VdbeAddOp0(v, OP_AutoCommit);\n}\n\n/*\n** Generate VDBE code for a COMMIT or ROLLBACK statement.\n** Code for ROLLBACK is generated if eType==TK_ROLLBACK.  Otherwise\n** code is generated for a COMMIT.\n*/\nvoid sqlite3EndTransaction(Parse *pParse, int eType){\n  Vdbe *v;\n  int isRollback;\n\n  assert( pParse!=0 );\n  assert( pParse->db!=0 );\n  assert( eType==TK_COMMIT || eType==TK_END || eType==TK_ROLLBACK );\n  isRollback = eType==TK_ROLLBACK;\n  if( sqlite3AuthCheck(pParse, SQLITE_TRANSACTION, \n       isRollback ? \"ROLLBACK\" : \"COMMIT\", 0, 0) ){\n    return;\n  }\n  v = sqlite3GetVdbe(pParse);\n  if( v ){\n    sqlite3VdbeAddOp2(v, OP_AutoCommit, 1, isRollback);\n  }\n}\n\n/*\n** This function is called by the parser when it parses a command to create,\n** release or rollback an SQL savepoint. \n*/\nvoid sqlite3Savepoint(Parse *pParse, int op, Token *pName){\n  char *zName = sqlite3NameFromToken(pParse->db, pName);\n  if( zName ){\n    Vdbe *v = sqlite3GetVdbe(pParse);\n#ifndef SQLITE_OMIT_AUTHORIZATION\n    static const char * const az[] = { \"BEGIN\", \"RELEASE\", \"ROLLBACK\" };\n    assert( !SAVEPOINT_BEGIN && SAVEPOINT_RELEASE==1 && SAVEPOINT_ROLLBACK==2 );\n#endif\n    if( !v || sqlite3AuthCheck(pParse, SQLITE_SAVEPOINT, az[op], zName, 0) ){\n      sqlite3DbFree(pParse->db, zName);\n      return;\n    }\n    sqlite3VdbeAddOp4(v, OP_Savepoint, op, 0, 0, zName, P4_DYNAMIC);\n  }\n}\n\n/*\n** Make sure the TEMP database is open and available for use.  Return\n** the number of errors.  Leave any error messages in the pParse structure.\n*/\nint sqlite3OpenTempDatabase(Parse *pParse){\n  sqlite3 *db = pParse->db;\n  if( db->aDb[1].pBt==0 && !pParse->explain ){\n    int rc;\n    Btree *pBt;\n    static const int flags = \n          SQLITE_OPEN_READWRITE |\n          SQLITE_OPEN_CREATE |\n          SQLITE_OPEN_EXCLUSIVE |\n          SQLITE_OPEN_DELETEONCLOSE |\n          SQLITE_OPEN_TEMP_DB;\n\n    rc = sqlite3BtreeOpen(db->pVfs, 0, db, &pBt, 0, flags);\n    if( rc!=SQLITE_OK ){\n      sqlite3ErrorMsg(pParse, \"unable to open a temporary database \"\n        \"file for storing temporary tables\");\n      pParse->rc = rc;\n      return 1;\n    }\n    db->aDb[1].pBt = pBt;\n    assert( db->aDb[1].pSchema );\n    if( SQLITE_NOMEM==sqlite3BtreeSetPageSize(pBt, db->nextPagesize, -1, 0) ){\n      sqlite3OomFault(db);\n      return 1;\n    }\n  }\n  return 0;\n}\n\n/*\n** Record the fact that the schema cookie will need to be verified\n** for database iDb.  The code to actually verify the schema cookie\n** will occur at the end of the top-level VDBE and will be generated\n** later, by sqlite3FinishCoding().\n*/\nvoid sqlite3CodeVerifySchema(Parse *pParse, int iDb){\n  Parse *pToplevel = sqlite3ParseToplevel(pParse);\n\n  assert( iDb>=0 && iDb<pParse->db->nDb );\n  assert( pParse->db->aDb[iDb].pBt!=0 || iDb==1 );\n  assert( iDb<SQLITE_MAX_ATTACHED+2 );\n  assert( sqlite3SchemaMutexHeld(pParse->db, iDb, 0) );\n  if( DbMaskTest(pToplevel->cookieMask, iDb)==0 ){\n    DbMaskSet(pToplevel->cookieMask, iDb);\n    if( !OMIT_TEMPDB && iDb==1 ){\n      sqlite3OpenTempDatabase(pToplevel);\n    }\n  }\n}\n\n/*\n** If argument zDb is NULL, then call sqlite3CodeVerifySchema() for each \n** attached database. Otherwise, invoke it for the database named zDb only.\n*/\nvoid sqlite3CodeVerifyNamedSchema(Parse *pParse, const char *zDb){\n  sqlite3 *db = pParse->db;\n  int i;\n  for(i=0; i<db->nDb; i++){\n    Db *pDb = &db->aDb[i];\n    if( pDb->pBt && (!zDb || 0==sqlite3StrICmp(zDb, pDb->zDbSName)) ){\n      sqlite3CodeVerifySchema(pParse, i);\n    }\n  }\n}\n\n/*\n** Generate VDBE code that prepares for doing an operation that\n** might change the database.\n**\n** This routine starts a new transaction if we are not already within\n** a transaction.  If we are already within a transaction, then a checkpoint\n** is set if the setStatement parameter is true.  A checkpoint should\n** be set for operations that might fail (due to a constraint) part of\n** the way through and which will need to undo some writes without having to\n** rollback the whole transaction.  For operations where all constraints\n** can be checked before any changes are made to the database, it is never\n** necessary to undo a write and the checkpoint should not be set.\n*/\nvoid sqlite3BeginWriteOperation(Parse *pParse, int setStatement, int iDb){\n  Parse *pToplevel = sqlite3ParseToplevel(pParse);\n  sqlite3CodeVerifySchema(pParse, iDb);\n  DbMaskSet(pToplevel->writeMask, iDb);\n  pToplevel->isMultiWrite |= setStatement;\n}\n\n/*\n** Indicate that the statement currently under construction might write\n** more than one entry (example: deleting one row then inserting another,\n** inserting multiple rows in a table, or inserting a row and index entries.)\n** If an abort occurs after some of these writes have completed, then it will\n** be necessary to undo the completed writes.\n*/\nvoid sqlite3MultiWrite(Parse *pParse){\n  Parse *pToplevel = sqlite3ParseToplevel(pParse);\n  pToplevel->isMultiWrite = 1;\n}\n\n/* \n** The code generator calls this routine if is discovers that it is\n** possible to abort a statement prior to completion.  In order to \n** perform this abort without corrupting the database, we need to make\n** sure that the statement is protected by a statement transaction.\n**\n** Technically, we only need to set the mayAbort flag if the\n** isMultiWrite flag was previously set.  There is a time dependency\n** such that the abort must occur after the multiwrite.  This makes\n** some statements involving the REPLACE conflict resolution algorithm\n** go a little faster.  But taking advantage of this time dependency\n** makes it more difficult to prove that the code is correct (in \n** particular, it prevents us from writing an effective\n** implementation of sqlite3AssertMayAbort()) and so we have chosen\n** to take the safe route and skip the optimization.\n*/\nvoid sqlite3MayAbort(Parse *pParse){\n  Parse *pToplevel = sqlite3ParseToplevel(pParse);\n  pToplevel->mayAbort = 1;\n}\n\n/*\n** Code an OP_Halt that causes the vdbe to return an SQLITE_CONSTRAINT\n** error. The onError parameter determines which (if any) of the statement\n** and/or current transaction is rolled back.\n*/\nvoid sqlite3HaltConstraint(\n  Parse *pParse,    /* Parsing context */\n  int errCode,      /* extended error code */\n  int onError,      /* Constraint type */\n  char *p4,         /* Error message */\n  i8 p4type,        /* P4_STATIC or P4_TRANSIENT */\n  u8 p5Errmsg       /* P5_ErrMsg type */\n){\n  Vdbe *v = sqlite3GetVdbe(pParse);\n  assert( (errCode&0xff)==SQLITE_CONSTRAINT );\n  if( onError==OE_Abort ){\n    sqlite3MayAbort(pParse);\n  }\n  sqlite3VdbeAddOp4(v, OP_Halt, errCode, onError, 0, p4, p4type);\n  sqlite3VdbeChangeP5(v, p5Errmsg);\n}\n\n/*\n** Code an OP_Halt due to UNIQUE or PRIMARY KEY constraint violation.\n*/\nvoid sqlite3UniqueConstraint(\n  Parse *pParse,    /* Parsing context */\n  int onError,      /* Constraint type */\n  Index *pIdx       /* The index that triggers the constraint */\n){\n  char *zErr;\n  int j;\n  StrAccum errMsg;\n  Table *pTab = pIdx->pTable;\n\n  sqlite3StrAccumInit(&errMsg, pParse->db, 0, 0, \n                      pParse->db->aLimit[SQLITE_LIMIT_LENGTH]);\n  if( pIdx->aColExpr ){\n    sqlite3_str_appendf(&errMsg, \"index '%q'\", pIdx->zName);\n  }else{\n    for(j=0; j<pIdx->nKeyCol; j++){\n      char *zCol;\n      assert( pIdx->aiColumn[j]>=0 );\n      zCol = pTab->aCol[pIdx->aiColumn[j]].zName;\n      if( j ) sqlite3_str_append(&errMsg, \", \", 2);\n      sqlite3_str_appendall(&errMsg, pTab->zName);\n      sqlite3_str_append(&errMsg, \".\", 1);\n      sqlite3_str_appendall(&errMsg, zCol);\n    }\n  }\n  zErr = sqlite3StrAccumFinish(&errMsg);\n  sqlite3HaltConstraint(pParse, \n    IsPrimaryKeyIndex(pIdx) ? SQLITE_CONSTRAINT_PRIMARYKEY \n                            : SQLITE_CONSTRAINT_UNIQUE,\n    onError, zErr, P4_DYNAMIC, P5_ConstraintUnique);\n}\n\n\n/*\n** Code an OP_Halt due to non-unique rowid.\n*/\nvoid sqlite3RowidConstraint(\n  Parse *pParse,    /* Parsing context */\n  int onError,      /* Conflict resolution algorithm */\n  Table *pTab       /* The table with the non-unique rowid */ \n){\n  char *zMsg;\n  int rc;\n  if( pTab->iPKey>=0 ){\n    zMsg = sqlite3MPrintf(pParse->db, \"%s.%s\", pTab->zName,\n                          pTab->aCol[pTab->iPKey].zName);\n    rc = SQLITE_CONSTRAINT_PRIMARYKEY;\n  }else{\n    zMsg = sqlite3MPrintf(pParse->db, \"%s.rowid\", pTab->zName);\n    rc = SQLITE_CONSTRAINT_ROWID;\n  }\n  sqlite3HaltConstraint(pParse, rc, onError, zMsg, P4_DYNAMIC,\n                        P5_ConstraintUnique);\n}\n\n/*\n** Check to see if pIndex uses the collating sequence pColl.  Return\n** true if it does and false if it does not.\n*/\n#ifndef SQLITE_OMIT_REINDEX\nstatic int collationMatch(const char *zColl, Index *pIndex){\n  int i;\n  assert( zColl!=0 );\n  for(i=0; i<pIndex->nColumn; i++){\n    const char *z = pIndex->azColl[i];\n    assert( z!=0 || pIndex->aiColumn[i]<0 );\n    if( pIndex->aiColumn[i]>=0 && 0==sqlite3StrICmp(z, zColl) ){\n      return 1;\n    }\n  }\n  return 0;\n}\n#endif\n\n/*\n** Recompute all indices of pTab that use the collating sequence pColl.\n** If pColl==0 then recompute all indices of pTab.\n*/\n#ifndef SQLITE_OMIT_REINDEX\nstatic void reindexTable(Parse *pParse, Table *pTab, char const *zColl){\n  if( !IsVirtual(pTab) ){\n    Index *pIndex;              /* An index associated with pTab */\n\n    for(pIndex=pTab->pIndex; pIndex; pIndex=pIndex->pNext){\n      if( zColl==0 || collationMatch(zColl, pIndex) ){\n        int iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);\n        sqlite3BeginWriteOperation(pParse, 0, iDb);\n        sqlite3RefillIndex(pParse, pIndex, -1);\n      }\n    }\n  }\n}\n#endif\n\n/*\n** Recompute all indices of all tables in all databases where the\n** indices use the collating sequence pColl.  If pColl==0 then recompute\n** all indices everywhere.\n*/\n#ifndef SQLITE_OMIT_REINDEX\nstatic void reindexDatabases(Parse *pParse, char const *zColl){\n  Db *pDb;                    /* A single database */\n  int iDb;                    /* The database index number */\n  sqlite3 *db = pParse->db;   /* The database connection */\n  HashElem *k;                /* For looping over tables in pDb */\n  Table *pTab;                /* A table in the database */\n\n  assert( sqlite3BtreeHoldsAllMutexes(db) );  /* Needed for schema access */\n  for(iDb=0, pDb=db->aDb; iDb<db->nDb; iDb++, pDb++){\n    assert( pDb!=0 );\n    for(k=sqliteHashFirst(&pDb->pSchema->tblHash);  k; k=sqliteHashNext(k)){\n      pTab = (Table*)sqliteHashData(k);\n      reindexTable(pParse, pTab, zColl);\n    }\n  }\n}\n#endif\n\n/*\n** Generate code for the REINDEX command.\n**\n**        REINDEX                            -- 1\n**        REINDEX  <collation>               -- 2\n**        REINDEX  ?<database>.?<tablename>  -- 3\n**        REINDEX  ?<database>.?<indexname>  -- 4\n**\n** Form 1 causes all indices in all attached databases to be rebuilt.\n** Form 2 rebuilds all indices in all databases that use the named\n** collating function.  Forms 3 and 4 rebuild the named index or all\n** indices associated with the named table.\n*/\n#ifndef SQLITE_OMIT_REINDEX\nvoid sqlite3Reindex(Parse *pParse, Token *pName1, Token *pName2){\n  CollSeq *pColl;             /* Collating sequence to be reindexed, or NULL */\n  char *z;                    /* Name of a table or index */\n  const char *zDb;            /* Name of the database */\n  Table *pTab;                /* A table in the database */\n  Index *pIndex;              /* An index associated with pTab */\n  int iDb;                    /* The database index number */\n  sqlite3 *db = pParse->db;   /* The database connection */\n  Token *pObjName;            /* Name of the table or index to be reindexed */\n\n  /* Read the database schema. If an error occurs, leave an error message\n  ** and code in pParse and return NULL. */\n  if( SQLITE_OK!=sqlite3ReadSchema(pParse) ){\n    return;\n  }\n\n  if( pName1==0 ){\n    reindexDatabases(pParse, 0);\n    return;\n  }else if( NEVER(pName2==0) || pName2->z==0 ){\n    char *zColl;\n    assert( pName1->z );\n    zColl = sqlite3NameFromToken(pParse->db, pName1);\n    if( !zColl ) return;\n    pColl = sqlite3FindCollSeq(db, ENC(db), zColl, 0);\n    if( pColl ){\n      reindexDatabases(pParse, zColl);\n      sqlite3DbFree(db, zColl);\n      return;\n    }\n    sqlite3DbFree(db, zColl);\n  }\n  iDb = sqlite3TwoPartName(pParse, pName1, pName2, &pObjName);\n  if( iDb<0 ) return;\n  z = sqlite3NameFromToken(db, pObjName);\n  if( z==0 ) return;\n  zDb = db->aDb[iDb].zDbSName;\n  pTab = sqlite3FindTable(db, z, zDb);\n  if( pTab ){\n    reindexTable(pParse, pTab, 0);\n    sqlite3DbFree(db, z);\n    return;\n  }\n  pIndex = sqlite3FindIndex(db, z, zDb);\n  sqlite3DbFree(db, z);\n  if( pIndex ){\n    sqlite3BeginWriteOperation(pParse, 0, iDb);\n    sqlite3RefillIndex(pParse, pIndex, -1);\n    return;\n  }\n  sqlite3ErrorMsg(pParse, \"unable to identify the object to be reindexed\");\n}\n#endif\n\n/*\n** Return a KeyInfo structure that is appropriate for the given Index.\n**\n** The caller should invoke sqlite3KeyInfoUnref() on the returned object\n** when it has finished using it.\n*/\nKeyInfo *sqlite3KeyInfoOfIndex(Parse *pParse, Index *pIdx){\n  int i;\n  int nCol = pIdx->nColumn;\n  int nKey = pIdx->nKeyCol;\n  KeyInfo *pKey;\n  if( pParse->nErr ) return 0;\n  if( pIdx->uniqNotNull ){\n    pKey = sqlite3KeyInfoAlloc(pParse->db, nKey, nCol-nKey);\n  }else{\n    pKey = sqlite3KeyInfoAlloc(pParse->db, nCol, 0);\n  }\n  if( pKey ){\n    assert( sqlite3KeyInfoIsWriteable(pKey) );\n    for(i=0; i<nCol; i++){\n      const char *zColl = pIdx->azColl[i];\n      pKey->aColl[i] = zColl==sqlite3StrBINARY ? 0 :\n                        sqlite3LocateCollSeq(pParse, zColl);\n      pKey->aSortFlags[i] = pIdx->aSortOrder[i];\n      assert( 0==(pKey->aSortFlags[i] & KEYINFO_ORDER_BIGNULL) );\n    }\n    if( pParse->nErr ){\n      assert( pParse->rc==SQLITE_ERROR_MISSING_COLLSEQ );\n      if( pIdx->bNoQuery==0 ){\n        /* Deactivate the index because it contains an unknown collating\n        ** sequence.  The only way to reactive the index is to reload the\n        ** schema.  Adding the missing collating sequence later does not\n        ** reactive the index.  The application had the chance to register\n        ** the missing index using the collation-needed callback.  For\n        ** simplicity, SQLite will not give the application a second chance.\n        */\n        pIdx->bNoQuery = 1;\n        pParse->rc = SQLITE_ERROR_RETRY;\n      }\n      sqlite3KeyInfoUnref(pKey);\n      pKey = 0;\n    }\n  }\n  return pKey;\n}\n\n#ifndef SQLITE_OMIT_CTE\n/* \n** This routine is invoked once per CTE by the parser while parsing a \n** WITH clause. \n*/\nWith *sqlite3WithAdd(\n  Parse *pParse,          /* Parsing context */\n  With *pWith,            /* Existing WITH clause, or NULL */\n  Token *pName,           /* Name of the common-table */\n  ExprList *pArglist,     /* Optional column name list for the table */\n  Select *pQuery          /* Query used to initialize the table */\n){\n  sqlite3 *db = pParse->db;\n  With *pNew;\n  char *zName;\n\n  /* Check that the CTE name is unique within this WITH clause. If\n  ** not, store an error in the Parse structure. */\n  zName = sqlite3NameFromToken(pParse->db, pName);\n  if( zName && pWith ){\n    int i;\n    for(i=0; i<pWith->nCte; i++){\n      if( sqlite3StrICmp(zName, pWith->a[i].zName)==0 ){\n        sqlite3ErrorMsg(pParse, \"duplicate WITH table name: %s\", zName);\n      }\n    }\n  }\n\n  if( pWith ){\n    sqlite3_int64 nByte = sizeof(*pWith) + (sizeof(pWith->a[1]) * pWith->nCte);\n    pNew = sqlite3DbRealloc(db, pWith, nByte);\n  }else{\n    pNew = sqlite3DbMallocZero(db, sizeof(*pWith));\n  }\n  assert( (pNew!=0 && zName!=0) || db->mallocFailed );\n\n  if( db->mallocFailed ){\n    sqlite3ExprListDelete(db, pArglist);\n    sqlite3SelectDelete(db, pQuery);\n    sqlite3DbFree(db, zName);\n    pNew = pWith;\n  }else{\n    pNew->a[pNew->nCte].pSelect = pQuery;\n    pNew->a[pNew->nCte].pCols = pArglist;\n    pNew->a[pNew->nCte].zName = zName;\n    pNew->a[pNew->nCte].zCteErr = 0;\n    pNew->nCte++;\n  }\n\n  return pNew;\n}\n\n/*\n** Free the contents of the With object passed as the second argument.\n*/\nvoid sqlite3WithDelete(sqlite3 *db, With *pWith){\n  if( pWith ){\n    int i;\n    for(i=0; i<pWith->nCte; i++){\n      struct Cte *pCte = &pWith->a[i];\n      sqlite3ExprListDelete(db, pCte->pCols);\n      sqlite3SelectDelete(db, pCte->pSelect);\n      sqlite3DbFree(db, pCte->zName);\n    }\n    sqlite3DbFree(db, pWith);\n  }\n}\n#endif /* !defined(SQLITE_OMIT_CTE) */\n", "/*\n** 2001 September 15\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** Internal interface definitions for SQLite.\n**\n*/\n#ifndef SQLITEINT_H\n#define SQLITEINT_H\n\n/* Special Comments:\n**\n** Some comments have special meaning to the tools that measure test\n** coverage:\n**\n**    NO_TEST                     - The branches on this line are not\n**                                  measured by branch coverage.  This is\n**                                  used on lines of code that actually\n**                                  implement parts of coverage testing.\n**\n**    OPTIMIZATION-IF-TRUE        - This branch is allowed to alway be false\n**                                  and the correct answer is still obtained,\n**                                  though perhaps more slowly.\n**\n**    OPTIMIZATION-IF-FALSE       - This branch is allowed to alway be true\n**                                  and the correct answer is still obtained,\n**                                  though perhaps more slowly.\n**\n**    PREVENTS-HARMLESS-OVERREAD  - This branch prevents a buffer overread\n**                                  that would be harmless and undetectable\n**                                  if it did occur.  \n**\n** In all cases, the special comment must be enclosed in the usual\n** slash-asterisk...asterisk-slash comment marks, with no spaces between the \n** asterisks and the comment text.\n*/\n\n/*\n** Make sure the Tcl calling convention macro is defined.  This macro is\n** only used by test code and Tcl integration code.\n*/\n#ifndef SQLITE_TCLAPI\n#  define SQLITE_TCLAPI\n#endif\n\n/*\n** Include the header file used to customize the compiler options for MSVC.\n** This should be done first so that it can successfully prevent spurious\n** compiler warnings due to subsequent content in this file and other files\n** that are included by this file.\n*/\n#include \"msvc.h\"\n\n/*\n** Special setup for VxWorks\n*/\n#include \"vxworks.h\"\n\n/*\n** These #defines should enable >2GB file support on POSIX if the\n** underlying operating system supports it.  If the OS lacks\n** large file support, or if the OS is windows, these should be no-ops.\n**\n** Ticket #2739:  The _LARGEFILE_SOURCE macro must appear before any\n** system #includes.  Hence, this block of code must be the very first\n** code in all source files.\n**\n** Large file support can be disabled using the -DSQLITE_DISABLE_LFS switch\n** on the compiler command line.  This is necessary if you are compiling\n** on a recent machine (ex: Red Hat 7.2) but you want your code to work\n** on an older machine (ex: Red Hat 6.0).  If you compile on Red Hat 7.2\n** without this option, LFS is enable.  But LFS does not exist in the kernel\n** in Red Hat 6.0, so the code won't work.  Hence, for maximum binary\n** portability you should omit LFS.\n**\n** The previous paragraph was written in 2005.  (This paragraph is written\n** on 2008-11-28.) These days, all Linux kernels support large files, so\n** you should probably leave LFS enabled.  But some embedded platforms might\n** lack LFS in which case the SQLITE_DISABLE_LFS macro might still be useful.\n**\n** Similar is true for Mac OS X.  LFS is only supported on Mac OS X 9 and later.\n*/\n#ifndef SQLITE_DISABLE_LFS\n# define _LARGE_FILE       1\n# ifndef _FILE_OFFSET_BITS\n#   define _FILE_OFFSET_BITS 64\n# endif\n# define _LARGEFILE_SOURCE 1\n#endif\n\n/* The GCC_VERSION and MSVC_VERSION macros are used to\n** conditionally include optimizations for each of these compilers.  A\n** value of 0 means that compiler is not being used.  The\n** SQLITE_DISABLE_INTRINSIC macro means do not use any compiler-specific\n** optimizations, and hence set all compiler macros to 0\n**\n** There was once also a CLANG_VERSION macro.  However, we learn that the\n** version numbers in clang are for \"marketing\" only and are inconsistent\n** and unreliable.  Fortunately, all versions of clang also recognize the\n** gcc version numbers and have reasonable settings for gcc version numbers,\n** so the GCC_VERSION macro will be set to a correct non-zero value even\n** when compiling with clang.\n*/\n#if defined(__GNUC__) && !defined(SQLITE_DISABLE_INTRINSIC)\n# define GCC_VERSION (__GNUC__*1000000+__GNUC_MINOR__*1000+__GNUC_PATCHLEVEL__)\n#else\n# define GCC_VERSION 0\n#endif\n#if defined(_MSC_VER) && !defined(SQLITE_DISABLE_INTRINSIC)\n# define MSVC_VERSION _MSC_VER\n#else\n# define MSVC_VERSION 0\n#endif\n\n/* Needed for various definitions... */\n#if defined(__GNUC__) && !defined(_GNU_SOURCE)\n# define _GNU_SOURCE\n#endif\n\n#if defined(__OpenBSD__) && !defined(_BSD_SOURCE)\n# define _BSD_SOURCE\n#endif\n\n/*\n** For MinGW, check to see if we can include the header file containing its\n** version information, among other things.  Normally, this internal MinGW\n** header file would [only] be included automatically by other MinGW header\n** files; however, the contained version information is now required by this\n** header file to work around binary compatibility issues (see below) and\n** this is the only known way to reliably obtain it.  This entire #if block\n** would be completely unnecessary if there was any other way of detecting\n** MinGW via their preprocessor (e.g. if they customized their GCC to define\n** some MinGW-specific macros).  When compiling for MinGW, either the\n** _HAVE_MINGW_H or _HAVE__MINGW_H (note the extra underscore) macro must be\n** defined; otherwise, detection of conditions specific to MinGW will be\n** disabled.\n*/\n#if defined(_HAVE_MINGW_H)\n# include \"mingw.h\"\n#elif defined(_HAVE__MINGW_H)\n# include \"_mingw.h\"\n#endif\n\n/*\n** For MinGW version 4.x (and higher), check to see if the _USE_32BIT_TIME_T\n** define is required to maintain binary compatibility with the MSVC runtime\n** library in use (e.g. for Windows XP).\n*/\n#if !defined(_USE_32BIT_TIME_T) && !defined(_USE_64BIT_TIME_T) && \\\n    defined(_WIN32) && !defined(_WIN64) && \\\n    defined(__MINGW_MAJOR_VERSION) && __MINGW_MAJOR_VERSION >= 4 && \\\n    defined(__MSVCRT__)\n# define _USE_32BIT_TIME_T\n#endif\n\n/* The public SQLite interface.  The _FILE_OFFSET_BITS macro must appear\n** first in QNX.  Also, the _USE_32BIT_TIME_T macro must appear first for\n** MinGW.\n*/\n#include \"sqlite3.h\"\n\n/*\n** Include the configuration header output by 'configure' if we're using the\n** autoconf-based build\n*/\n#if defined(_HAVE_SQLITE_CONFIG_H) && !defined(SQLITECONFIG_H)\n#include \"config.h\"\n#define SQLITECONFIG_H 1\n#endif\n\n#include \"sqliteLimit.h\"\n\n/* Disable nuisance warnings on Borland compilers */\n#if defined(__BORLANDC__)\n#pragma warn -rch /* unreachable code */\n#pragma warn -ccc /* Condition is always true or false */\n#pragma warn -aus /* Assigned value is never used */\n#pragma warn -csu /* Comparing signed and unsigned */\n#pragma warn -spa /* Suspicious pointer arithmetic */\n#endif\n\n/*\n** Include standard header files as necessary\n*/\n#ifdef HAVE_STDINT_H\n#include <stdint.h>\n#endif\n#ifdef HAVE_INTTYPES_H\n#include <inttypes.h>\n#endif\n\n/*\n** The following macros are used to cast pointers to integers and\n** integers to pointers.  The way you do this varies from one compiler\n** to the next, so we have developed the following set of #if statements\n** to generate appropriate macros for a wide range of compilers.\n**\n** The correct \"ANSI\" way to do this is to use the intptr_t type.\n** Unfortunately, that typedef is not available on all compilers, or\n** if it is available, it requires an #include of specific headers\n** that vary from one machine to the next.\n**\n** Ticket #3860:  The llvm-gcc-4.2 compiler from Apple chokes on\n** the ((void*)&((char*)0)[X]) construct.  But MSVC chokes on ((void*)(X)).\n** So we have to define the macros in different ways depending on the\n** compiler.\n*/\n#if defined(HAVE_STDINT_H)   /* Use this case if we have ANSI headers */\n# define SQLITE_INT_TO_PTR(X)  ((void*)(intptr_t)(X))\n# define SQLITE_PTR_TO_INT(X)  ((int)(intptr_t)(X))\n#elif defined(__PTRDIFF_TYPE__)  /* This case should work for GCC */\n# define SQLITE_INT_TO_PTR(X)  ((void*)(__PTRDIFF_TYPE__)(X))\n# define SQLITE_PTR_TO_INT(X)  ((int)(__PTRDIFF_TYPE__)(X))\n#elif !defined(__GNUC__)       /* Works for compilers other than LLVM */\n# define SQLITE_INT_TO_PTR(X)  ((void*)&((char*)0)[X])\n# define SQLITE_PTR_TO_INT(X)  ((int)(((char*)X)-(char*)0))\n#else                          /* Generates a warning - but it always works */\n# define SQLITE_INT_TO_PTR(X)  ((void*)(X))\n# define SQLITE_PTR_TO_INT(X)  ((int)(X))\n#endif\n\n/*\n** A macro to hint to the compiler that a function should not be\n** inlined.\n*/\n#if defined(__GNUC__)\n#  define SQLITE_NOINLINE  __attribute__((noinline))\n#elif defined(_MSC_VER) && _MSC_VER>=1310\n#  define SQLITE_NOINLINE  __declspec(noinline)\n#else\n#  define SQLITE_NOINLINE\n#endif\n\n/*\n** Make sure that the compiler intrinsics we desire are enabled when\n** compiling with an appropriate version of MSVC unless prevented by\n** the SQLITE_DISABLE_INTRINSIC define.\n*/\n#if !defined(SQLITE_DISABLE_INTRINSIC)\n#  if defined(_MSC_VER) && _MSC_VER>=1400\n#    if !defined(_WIN32_WCE)\n#      include <intrin.h>\n#      pragma intrinsic(_byteswap_ushort)\n#      pragma intrinsic(_byteswap_ulong)\n#      pragma intrinsic(_byteswap_uint64)\n#      pragma intrinsic(_ReadWriteBarrier)\n#    else\n#      include <cmnintrin.h>\n#    endif\n#  endif\n#endif\n\n/*\n** The SQLITE_THREADSAFE macro must be defined as 0, 1, or 2.\n** 0 means mutexes are permanently disable and the library is never\n** threadsafe.  1 means the library is serialized which is the highest\n** level of threadsafety.  2 means the library is multithreaded - multiple\n** threads can use SQLite as long as no two threads try to use the same\n** database connection at the same time.\n**\n** Older versions of SQLite used an optional THREADSAFE macro.\n** We support that for legacy.\n**\n** To ensure that the correct value of \"THREADSAFE\" is reported when querying\n** for compile-time options at runtime (e.g. \"PRAGMA compile_options\"), this\n** logic is partially replicated in ctime.c. If it is updated here, it should\n** also be updated there.\n*/\n#if !defined(SQLITE_THREADSAFE)\n# if defined(THREADSAFE)\n#   define SQLITE_THREADSAFE THREADSAFE\n# else\n#   define SQLITE_THREADSAFE 1 /* IMP: R-07272-22309 */\n# endif\n#endif\n\n/*\n** Powersafe overwrite is on by default.  But can be turned off using\n** the -DSQLITE_POWERSAFE_OVERWRITE=0 command-line option.\n*/\n#ifndef SQLITE_POWERSAFE_OVERWRITE\n# define SQLITE_POWERSAFE_OVERWRITE 1\n#endif\n\n/*\n** EVIDENCE-OF: R-25715-37072 Memory allocation statistics are enabled by\n** default unless SQLite is compiled with SQLITE_DEFAULT_MEMSTATUS=0 in\n** which case memory allocation statistics are disabled by default.\n*/\n#if !defined(SQLITE_DEFAULT_MEMSTATUS)\n# define SQLITE_DEFAULT_MEMSTATUS 1\n#endif\n\n/*\n** Exactly one of the following macros must be defined in order to\n** specify which memory allocation subsystem to use.\n**\n**     SQLITE_SYSTEM_MALLOC          // Use normal system malloc()\n**     SQLITE_WIN32_MALLOC           // Use Win32 native heap API\n**     SQLITE_ZERO_MALLOC            // Use a stub allocator that always fails\n**     SQLITE_MEMDEBUG               // Debugging version of system malloc()\n**\n** On Windows, if the SQLITE_WIN32_MALLOC_VALIDATE macro is defined and the\n** assert() macro is enabled, each call into the Win32 native heap subsystem\n** will cause HeapValidate to be called.  If heap validation should fail, an\n** assertion will be triggered.\n**\n** If none of the above are defined, then set SQLITE_SYSTEM_MALLOC as\n** the default.\n*/\n#if defined(SQLITE_SYSTEM_MALLOC) \\\n  + defined(SQLITE_WIN32_MALLOC) \\\n  + defined(SQLITE_ZERO_MALLOC) \\\n  + defined(SQLITE_MEMDEBUG)>1\n# error \"Two or more of the following compile-time configuration options\\\n are defined but at most one is allowed:\\\n SQLITE_SYSTEM_MALLOC, SQLITE_WIN32_MALLOC, SQLITE_MEMDEBUG,\\\n SQLITE_ZERO_MALLOC\"\n#endif\n#if defined(SQLITE_SYSTEM_MALLOC) \\\n  + defined(SQLITE_WIN32_MALLOC) \\\n  + defined(SQLITE_ZERO_MALLOC) \\\n  + defined(SQLITE_MEMDEBUG)==0\n# define SQLITE_SYSTEM_MALLOC 1\n#endif\n\n/*\n** If SQLITE_MALLOC_SOFT_LIMIT is not zero, then try to keep the\n** sizes of memory allocations below this value where possible.\n*/\n#if !defined(SQLITE_MALLOC_SOFT_LIMIT)\n# define SQLITE_MALLOC_SOFT_LIMIT 1024\n#endif\n\n/*\n** We need to define _XOPEN_SOURCE as follows in order to enable\n** recursive mutexes on most Unix systems and fchmod() on OpenBSD.\n** But _XOPEN_SOURCE define causes problems for Mac OS X, so omit\n** it.\n*/\n#if !defined(_XOPEN_SOURCE) && !defined(__DARWIN__) && !defined(__APPLE__)\n#  define _XOPEN_SOURCE 600\n#endif\n\n/*\n** NDEBUG and SQLITE_DEBUG are opposites.  It should always be true that\n** defined(NDEBUG)==!defined(SQLITE_DEBUG).  If this is not currently true,\n** make it true by defining or undefining NDEBUG.\n**\n** Setting NDEBUG makes the code smaller and faster by disabling the\n** assert() statements in the code.  So we want the default action\n** to be for NDEBUG to be set and NDEBUG to be undefined only if SQLITE_DEBUG\n** is set.  Thus NDEBUG becomes an opt-in rather than an opt-out\n** feature.\n*/\n#if !defined(NDEBUG) && !defined(SQLITE_DEBUG)\n# define NDEBUG 1\n#endif\n#if defined(NDEBUG) && defined(SQLITE_DEBUG)\n# undef NDEBUG\n#endif\n\n/*\n** Enable SQLITE_ENABLE_EXPLAIN_COMMENTS if SQLITE_DEBUG is turned on.\n*/\n#if !defined(SQLITE_ENABLE_EXPLAIN_COMMENTS) && defined(SQLITE_DEBUG)\n# define SQLITE_ENABLE_EXPLAIN_COMMENTS 1\n#endif\n\n/*\n** The testcase() macro is used to aid in coverage testing.  When\n** doing coverage testing, the condition inside the argument to\n** testcase() must be evaluated both true and false in order to\n** get full branch coverage.  The testcase() macro is inserted\n** to help ensure adequate test coverage in places where simple\n** condition/decision coverage is inadequate.  For example, testcase()\n** can be used to make sure boundary values are tested.  For\n** bitmask tests, testcase() can be used to make sure each bit\n** is significant and used at least once.  On switch statements\n** where multiple cases go to the same block of code, testcase()\n** can insure that all cases are evaluated.\n**\n*/\n#ifdef SQLITE_COVERAGE_TEST\n  void sqlite3Coverage(int);\n# define testcase(X)  if( X ){ sqlite3Coverage(__LINE__); }\n#else\n# define testcase(X)\n#endif\n\n/*\n** The TESTONLY macro is used to enclose variable declarations or\n** other bits of code that are needed to support the arguments\n** within testcase() and assert() macros.\n*/\n#if !defined(NDEBUG) || defined(SQLITE_COVERAGE_TEST)\n# define TESTONLY(X)  X\n#else\n# define TESTONLY(X)\n#endif\n\n/*\n** Sometimes we need a small amount of code such as a variable initialization\n** to setup for a later assert() statement.  We do not want this code to\n** appear when assert() is disabled.  The following macro is therefore\n** used to contain that setup code.  The \"VVA\" acronym stands for\n** \"Verification, Validation, and Accreditation\".  In other words, the\n** code within VVA_ONLY() will only run during verification processes.\n*/\n#ifndef NDEBUG\n# define VVA_ONLY(X)  X\n#else\n# define VVA_ONLY(X)\n#endif\n\n/*\n** The ALWAYS and NEVER macros surround boolean expressions which\n** are intended to always be true or false, respectively.  Such\n** expressions could be omitted from the code completely.  But they\n** are included in a few cases in order to enhance the resilience\n** of SQLite to unexpected behavior - to make the code \"self-healing\"\n** or \"ductile\" rather than being \"brittle\" and crashing at the first\n** hint of unplanned behavior.\n**\n** In other words, ALWAYS and NEVER are added for defensive code.\n**\n** When doing coverage testing ALWAYS and NEVER are hard-coded to\n** be true and false so that the unreachable code they specify will\n** not be counted as untested code.\n*/\n#if defined(SQLITE_COVERAGE_TEST) || defined(SQLITE_MUTATION_TEST)\n# define ALWAYS(X)      (1)\n# define NEVER(X)       (0)\n#elif !defined(NDEBUG)\n# define ALWAYS(X)      ((X)?1:(assert(0),0))\n# define NEVER(X)       ((X)?(assert(0),1):0)\n#else\n# define ALWAYS(X)      (X)\n# define NEVER(X)       (X)\n#endif\n\n/*\n** Some conditionals are optimizations only.  In other words, if the\n** conditionals are replaced with a constant 1 (true) or 0 (false) then\n** the correct answer is still obtained, though perhaps not as quickly.\n**\n** The following macros mark these optimizations conditionals.\n*/\n#if defined(SQLITE_MUTATION_TEST)\n# define OK_IF_ALWAYS_TRUE(X)  (1)\n# define OK_IF_ALWAYS_FALSE(X) (0)\n#else\n# define OK_IF_ALWAYS_TRUE(X)  (X)\n# define OK_IF_ALWAYS_FALSE(X) (X)\n#endif\n\n/*\n** Some malloc failures are only possible if SQLITE_TEST_REALLOC_STRESS is\n** defined.  We need to defend against those failures when testing with\n** SQLITE_TEST_REALLOC_STRESS, but we don't want the unreachable branches\n** during a normal build.  The following macro can be used to disable tests\n** that are always false except when SQLITE_TEST_REALLOC_STRESS is set.\n*/\n#if defined(SQLITE_TEST_REALLOC_STRESS)\n# define ONLY_IF_REALLOC_STRESS(X)  (X)\n#elif !defined(NDEBUG)\n# define ONLY_IF_REALLOC_STRESS(X)  ((X)?(assert(0),1):0)\n#else\n# define ONLY_IF_REALLOC_STRESS(X)  (0)\n#endif\n\n/*\n** Declarations used for tracing the operating system interfaces.\n*/\n#if defined(SQLITE_FORCE_OS_TRACE) || defined(SQLITE_TEST) || \\\n    (defined(SQLITE_DEBUG) && SQLITE_OS_WIN)\n  extern int sqlite3OSTrace;\n# define OSTRACE(X)          if( sqlite3OSTrace ) sqlite3DebugPrintf X\n# define SQLITE_HAVE_OS_TRACE\n#else\n# define OSTRACE(X)\n# undef  SQLITE_HAVE_OS_TRACE\n#endif\n\n/*\n** Is the sqlite3ErrName() function needed in the build?  Currently,\n** it is needed by \"mutex_w32.c\" (when debugging), \"os_win.c\" (when\n** OSTRACE is enabled), and by several \"test*.c\" files (which are\n** compiled using SQLITE_TEST).\n*/\n#if defined(SQLITE_HAVE_OS_TRACE) || defined(SQLITE_TEST) || \\\n    (defined(SQLITE_DEBUG) && SQLITE_OS_WIN)\n# define SQLITE_NEED_ERR_NAME\n#else\n# undef  SQLITE_NEED_ERR_NAME\n#endif\n\n/*\n** SQLITE_ENABLE_EXPLAIN_COMMENTS is incompatible with SQLITE_OMIT_EXPLAIN\n*/\n#ifdef SQLITE_OMIT_EXPLAIN\n# undef SQLITE_ENABLE_EXPLAIN_COMMENTS\n#endif\n\n/*\n** Return true (non-zero) if the input is an integer that is too large\n** to fit in 32-bits.  This macro is used inside of various testcase()\n** macros to verify that we have tested SQLite for large-file support.\n*/\n#define IS_BIG_INT(X)  (((X)&~(i64)0xffffffff)!=0)\n\n/*\n** The macro unlikely() is a hint that surrounds a boolean\n** expression that is usually false.  Macro likely() surrounds\n** a boolean expression that is usually true.  These hints could,\n** in theory, be used by the compiler to generate better code, but\n** currently they are just comments for human readers.\n*/\n#define likely(X)    (X)\n#define unlikely(X)  (X)\n\n#include \"hash.h\"\n#include \"parse.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <stddef.h>\n\n/*\n** Use a macro to replace memcpy() if compiled with SQLITE_INLINE_MEMCPY.\n** This allows better measurements of where memcpy() is used when running\n** cachegrind.  But this macro version of memcpy() is very slow so it\n** should not be used in production.  This is a performance measurement\n** hack only.\n*/\n#ifdef SQLITE_INLINE_MEMCPY\n# define memcpy(D,S,N) {char*xxd=(char*)(D);const char*xxs=(const char*)(S);\\\n                        int xxn=(N);while(xxn-->0)*(xxd++)=*(xxs++);}\n#endif\n\n/*\n** If compiling for a processor that lacks floating point support,\n** substitute integer for floating-point\n*/\n#ifdef SQLITE_OMIT_FLOATING_POINT\n# define double sqlite_int64\n# define float sqlite_int64\n# define LONGDOUBLE_TYPE sqlite_int64\n# ifndef SQLITE_BIG_DBL\n#   define SQLITE_BIG_DBL (((sqlite3_int64)1)<<50)\n# endif\n# define SQLITE_OMIT_DATETIME_FUNCS 1\n# define SQLITE_OMIT_TRACE 1\n# undef SQLITE_MIXED_ENDIAN_64BIT_FLOAT\n# undef SQLITE_HAVE_ISNAN\n#endif\n#ifndef SQLITE_BIG_DBL\n# define SQLITE_BIG_DBL (1e99)\n#endif\n\n/*\n** OMIT_TEMPDB is set to 1 if SQLITE_OMIT_TEMPDB is defined, or 0\n** afterward. Having this macro allows us to cause the C compiler\n** to omit code used by TEMP tables without messy #ifndef statements.\n*/\n#ifdef SQLITE_OMIT_TEMPDB\n#define OMIT_TEMPDB 1\n#else\n#define OMIT_TEMPDB 0\n#endif\n\n/*\n** The \"file format\" number is an integer that is incremented whenever\n** the VDBE-level file format changes.  The following macros define the\n** the default file format for new databases and the maximum file format\n** that the library can read.\n*/\n#define SQLITE_MAX_FILE_FORMAT 4\n#ifndef SQLITE_DEFAULT_FILE_FORMAT\n# define SQLITE_DEFAULT_FILE_FORMAT 4\n#endif\n\n/*\n** Determine whether triggers are recursive by default.  This can be\n** changed at run-time using a pragma.\n*/\n#ifndef SQLITE_DEFAULT_RECURSIVE_TRIGGERS\n# define SQLITE_DEFAULT_RECURSIVE_TRIGGERS 0\n#endif\n\n/*\n** Provide a default value for SQLITE_TEMP_STORE in case it is not specified\n** on the command-line\n*/\n#ifndef SQLITE_TEMP_STORE\n# define SQLITE_TEMP_STORE 1\n#endif\n\n/*\n** If no value has been provided for SQLITE_MAX_WORKER_THREADS, or if\n** SQLITE_TEMP_STORE is set to 3 (never use temporary files), set it\n** to zero.\n*/\n#if SQLITE_TEMP_STORE==3 || SQLITE_THREADSAFE==0\n# undef SQLITE_MAX_WORKER_THREADS\n# define SQLITE_MAX_WORKER_THREADS 0\n#endif\n#ifndef SQLITE_MAX_WORKER_THREADS\n# define SQLITE_MAX_WORKER_THREADS 8\n#endif\n#ifndef SQLITE_DEFAULT_WORKER_THREADS\n# define SQLITE_DEFAULT_WORKER_THREADS 0\n#endif\n#if SQLITE_DEFAULT_WORKER_THREADS>SQLITE_MAX_WORKER_THREADS\n# undef SQLITE_MAX_WORKER_THREADS\n# define SQLITE_MAX_WORKER_THREADS SQLITE_DEFAULT_WORKER_THREADS\n#endif\n\n/*\n** The default initial allocation for the pagecache when using separate\n** pagecaches for each database connection.  A positive number is the\n** number of pages.  A negative number N translations means that a buffer\n** of -1024*N bytes is allocated and used for as many pages as it will hold.\n**\n** The default value of \"20\" was choosen to minimize the run-time of the\n** speedtest1 test program with options: --shrink-memory --reprepare\n*/\n#ifndef SQLITE_DEFAULT_PCACHE_INITSZ\n# define SQLITE_DEFAULT_PCACHE_INITSZ 20\n#endif\n\n/*\n** Default value for the SQLITE_CONFIG_SORTERREF_SIZE option.\n*/\n#ifndef SQLITE_DEFAULT_SORTERREF_SIZE\n# define SQLITE_DEFAULT_SORTERREF_SIZE 0x7fffffff\n#endif\n\n/*\n** The compile-time options SQLITE_MMAP_READWRITE and \n** SQLITE_ENABLE_BATCH_ATOMIC_WRITE are not compatible with one another.\n** You must choose one or the other (or neither) but not both.\n*/\n#if defined(SQLITE_MMAP_READWRITE) && defined(SQLITE_ENABLE_BATCH_ATOMIC_WRITE)\n#error Cannot use both SQLITE_MMAP_READWRITE and SQLITE_ENABLE_BATCH_ATOMIC_WRITE\n#endif\n\n/*\n** GCC does not define the offsetof() macro so we'll have to do it\n** ourselves.\n*/\n#ifndef offsetof\n#define offsetof(STRUCTURE,FIELD) ((int)((char*)&((STRUCTURE*)0)->FIELD))\n#endif\n\n/*\n** Macros to compute minimum and maximum of two numbers.\n*/\n#ifndef MIN\n# define MIN(A,B) ((A)<(B)?(A):(B))\n#endif\n#ifndef MAX\n# define MAX(A,B) ((A)>(B)?(A):(B))\n#endif\n\n/*\n** Swap two objects of type TYPE.\n*/\n#define SWAP(TYPE,A,B) {TYPE t=A; A=B; B=t;}\n\n/*\n** Check to see if this machine uses EBCDIC.  (Yes, believe it or\n** not, there are still machines out there that use EBCDIC.)\n*/\n#if 'A' == '\\301'\n# define SQLITE_EBCDIC 1\n#else\n# define SQLITE_ASCII 1\n#endif\n\n/*\n** Integers of known sizes.  These typedefs might change for architectures\n** where the sizes very.  Preprocessor macros are available so that the\n** types can be conveniently redefined at compile-type.  Like this:\n**\n**         cc '-DUINTPTR_TYPE=long long int' ...\n*/\n#ifndef UINT32_TYPE\n# ifdef HAVE_UINT32_T\n#  define UINT32_TYPE uint32_t\n# else\n#  define UINT32_TYPE unsigned int\n# endif\n#endif\n#ifndef UINT16_TYPE\n# ifdef HAVE_UINT16_T\n#  define UINT16_TYPE uint16_t\n# else\n#  define UINT16_TYPE unsigned short int\n# endif\n#endif\n#ifndef INT16_TYPE\n# ifdef HAVE_INT16_T\n#  define INT16_TYPE int16_t\n# else\n#  define INT16_TYPE short int\n# endif\n#endif\n#ifndef UINT8_TYPE\n# ifdef HAVE_UINT8_T\n#  define UINT8_TYPE uint8_t\n# else\n#  define UINT8_TYPE unsigned char\n# endif\n#endif\n#ifndef INT8_TYPE\n# ifdef HAVE_INT8_T\n#  define INT8_TYPE int8_t\n# else\n#  define INT8_TYPE signed char\n# endif\n#endif\n#ifndef LONGDOUBLE_TYPE\n# define LONGDOUBLE_TYPE long double\n#endif\ntypedef sqlite_int64 i64;          /* 8-byte signed integer */\ntypedef sqlite_uint64 u64;         /* 8-byte unsigned integer */\ntypedef UINT32_TYPE u32;           /* 4-byte unsigned integer */\ntypedef UINT16_TYPE u16;           /* 2-byte unsigned integer */\ntypedef INT16_TYPE i16;            /* 2-byte signed integer */\ntypedef UINT8_TYPE u8;             /* 1-byte unsigned integer */\ntypedef INT8_TYPE i8;              /* 1-byte signed integer */\n\n/*\n** SQLITE_MAX_U32 is a u64 constant that is the maximum u64 value\n** that can be stored in a u32 without loss of data.  The value\n** is 0x00000000ffffffff.  But because of quirks of some compilers, we\n** have to specify the value in the less intuitive manner shown:\n*/\n#define SQLITE_MAX_U32  ((((u64)1)<<32)-1)\n\n/*\n** The datatype used to store estimates of the number of rows in a\n** table or index.  This is an unsigned integer type.  For 99.9% of\n** the world, a 32-bit integer is sufficient.  But a 64-bit integer\n** can be used at compile-time if desired.\n*/\n#ifdef SQLITE_64BIT_STATS\n typedef u64 tRowcnt;    /* 64-bit only if requested at compile-time */\n#else\n typedef u32 tRowcnt;    /* 32-bit is the default */\n#endif\n\n/*\n** Estimated quantities used for query planning are stored as 16-bit\n** logarithms.  For quantity X, the value stored is 10*log2(X).  This\n** gives a possible range of values of approximately 1.0e986 to 1e-986.\n** But the allowed values are \"grainy\".  Not every value is representable.\n** For example, quantities 16 and 17 are both represented by a LogEst\n** of 40.  However, since LogEst quantities are suppose to be estimates,\n** not exact values, this imprecision is not a problem.\n**\n** \"LogEst\" is short for \"Logarithmic Estimate\".\n**\n** Examples:\n**      1 -> 0              20 -> 43          10000 -> 132\n**      2 -> 10             25 -> 46          25000 -> 146\n**      3 -> 16            100 -> 66        1000000 -> 199\n**      4 -> 20           1000 -> 99        1048576 -> 200\n**     10 -> 33           1024 -> 100    4294967296 -> 320\n**\n** The LogEst can be negative to indicate fractional values.\n** Examples:\n**\n**    0.5 -> -10           0.1 -> -33        0.0625 -> -40\n*/\ntypedef INT16_TYPE LogEst;\n\n/*\n** Set the SQLITE_PTRSIZE macro to the number of bytes in a pointer\n*/\n#ifndef SQLITE_PTRSIZE\n# if defined(__SIZEOF_POINTER__)\n#   define SQLITE_PTRSIZE __SIZEOF_POINTER__\n# elif defined(i386)     || defined(__i386__)   || defined(_M_IX86) ||    \\\n       defined(_M_ARM)   || defined(__arm__)    || defined(__x86)   ||    \\\n      (defined(__TOS_AIX__) && !defined(__64BIT__))\n#   define SQLITE_PTRSIZE 4\n# else\n#   define SQLITE_PTRSIZE 8\n# endif\n#endif\n\n/* The uptr type is an unsigned integer large enough to hold a pointer\n*/\n#if defined(HAVE_STDINT_H)\n  typedef uintptr_t uptr;\n#elif SQLITE_PTRSIZE==4\n  typedef u32 uptr;\n#else\n  typedef u64 uptr;\n#endif\n\n/*\n** The SQLITE_WITHIN(P,S,E) macro checks to see if pointer P points to\n** something between S (inclusive) and E (exclusive).\n**\n** In other words, S is a buffer and E is a pointer to the first byte after\n** the end of buffer S.  This macro returns true if P points to something\n** contained within the buffer S.\n*/\n#define SQLITE_WITHIN(P,S,E) (((uptr)(P)>=(uptr)(S))&&((uptr)(P)<(uptr)(E)))\n\n\n/*\n** Macros to determine whether the machine is big or little endian,\n** and whether or not that determination is run-time or compile-time.\n**\n** For best performance, an attempt is made to guess at the byte-order\n** using C-preprocessor macros.  If that is unsuccessful, or if\n** -DSQLITE_BYTEORDER=0 is set, then byte-order is determined\n** at run-time.\n*/\n#ifndef SQLITE_BYTEORDER\n# if defined(i386)      || defined(__i386__)      || defined(_M_IX86) ||    \\\n     defined(__x86_64)  || defined(__x86_64__)    || defined(_M_X64)  ||    \\\n     defined(_M_AMD64)  || defined(_M_ARM)        || defined(__x86)   ||    \\\n     defined(__ARMEL__) || defined(__AARCH64EL__) || defined(_M_ARM64)\n#   define SQLITE_BYTEORDER    1234\n# elif defined(sparc)     || defined(__ppc__) || \\\n       defined(__ARMEB__) || defined(__AARCH64EB__)\n#   define SQLITE_BYTEORDER    4321\n# else\n#   define SQLITE_BYTEORDER 0\n# endif\n#endif\n#if SQLITE_BYTEORDER==4321\n# define SQLITE_BIGENDIAN    1\n# define SQLITE_LITTLEENDIAN 0\n# define SQLITE_UTF16NATIVE  SQLITE_UTF16BE\n#elif SQLITE_BYTEORDER==1234\n# define SQLITE_BIGENDIAN    0\n# define SQLITE_LITTLEENDIAN 1\n# define SQLITE_UTF16NATIVE  SQLITE_UTF16LE\n#else\n# ifdef SQLITE_AMALGAMATION\n  const int sqlite3one = 1;\n# else\n  extern const int sqlite3one;\n# endif\n# define SQLITE_BIGENDIAN    (*(char *)(&sqlite3one)==0)\n# define SQLITE_LITTLEENDIAN (*(char *)(&sqlite3one)==1)\n# define SQLITE_UTF16NATIVE  (SQLITE_BIGENDIAN?SQLITE_UTF16BE:SQLITE_UTF16LE)\n#endif\n\n/*\n** Constants for the largest and smallest possible 64-bit signed integers.\n** These macros are designed to work correctly on both 32-bit and 64-bit\n** compilers.\n*/\n#define LARGEST_INT64  (0xffffffff|(((i64)0x7fffffff)<<32))\n#define SMALLEST_INT64 (((i64)-1) - LARGEST_INT64)\n\n/*\n** Round up a number to the next larger multiple of 8.  This is used\n** to force 8-byte alignment on 64-bit architectures.\n*/\n#define ROUND8(x)     (((x)+7)&~7)\n\n/*\n** Round down to the nearest multiple of 8\n*/\n#define ROUNDDOWN8(x) ((x)&~7)\n\n/*\n** Assert that the pointer X is aligned to an 8-byte boundary.  This\n** macro is used only within assert() to verify that the code gets\n** all alignment restrictions correct.\n**\n** Except, if SQLITE_4_BYTE_ALIGNED_MALLOC is defined, then the\n** underlying malloc() implementation might return us 4-byte aligned\n** pointers.  In that case, only verify 4-byte alignment.\n*/\n#ifdef SQLITE_4_BYTE_ALIGNED_MALLOC\n# define EIGHT_BYTE_ALIGNMENT(X)   ((((char*)(X) - (char*)0)&3)==0)\n#else\n# define EIGHT_BYTE_ALIGNMENT(X)   ((((char*)(X) - (char*)0)&7)==0)\n#endif\n\n/*\n** Disable MMAP on platforms where it is known to not work\n*/\n#if defined(__OpenBSD__) || defined(__QNXNTO__)\n# undef SQLITE_MAX_MMAP_SIZE\n# define SQLITE_MAX_MMAP_SIZE 0\n#endif\n\n/*\n** Default maximum size of memory used by memory-mapped I/O in the VFS\n*/\n#ifdef __APPLE__\n# include <TargetConditionals.h>\n#endif\n#ifndef SQLITE_MAX_MMAP_SIZE\n# if defined(__linux__) \\\n  || defined(_WIN32) \\\n  || (defined(__APPLE__) && defined(__MACH__)) \\\n  || defined(__sun) \\\n  || defined(__FreeBSD__) \\\n  || defined(__DragonFly__)\n#   define SQLITE_MAX_MMAP_SIZE 0x7fff0000  /* 2147418112 */\n# else\n#   define SQLITE_MAX_MMAP_SIZE 0\n# endif\n#endif\n\n/*\n** The default MMAP_SIZE is zero on all platforms.  Or, even if a larger\n** default MMAP_SIZE is specified at compile-time, make sure that it does\n** not exceed the maximum mmap size.\n*/\n#ifndef SQLITE_DEFAULT_MMAP_SIZE\n# define SQLITE_DEFAULT_MMAP_SIZE 0\n#endif\n#if SQLITE_DEFAULT_MMAP_SIZE>SQLITE_MAX_MMAP_SIZE\n# undef SQLITE_DEFAULT_MMAP_SIZE\n# define SQLITE_DEFAULT_MMAP_SIZE SQLITE_MAX_MMAP_SIZE\n#endif\n\n/*\n** SELECTTRACE_ENABLED will be either 1 or 0 depending on whether or not\n** the Select query generator tracing logic is turned on.\n*/\n#if defined(SQLITE_ENABLE_SELECTTRACE)\n# define SELECTTRACE_ENABLED 1\n#else\n# define SELECTTRACE_ENABLED 0\n#endif\n\n/*\n** An instance of the following structure is used to store the busy-handler\n** callback for a given sqlite handle.\n**\n** The sqlite.busyHandler member of the sqlite struct contains the busy\n** callback for the database handle. Each pager opened via the sqlite\n** handle is passed a pointer to sqlite.busyHandler. The busy-handler\n** callback is currently invoked only from within pager.c.\n*/\ntypedef struct BusyHandler BusyHandler;\nstruct BusyHandler {\n  int (*xBusyHandler)(void *,int);  /* The busy callback */\n  void *pBusyArg;                   /* First arg to busy callback */\n  int nBusy;                        /* Incremented with each busy call */\n  u8 bExtraFileArg;                 /* Include sqlite3_file as callback arg */\n};\n\n/*\n** Name of the master database table.  The master database table\n** is a special table that holds the names and attributes of all\n** user tables and indices.\n*/\n#define MASTER_NAME       \"sqlite_master\"\n#define TEMP_MASTER_NAME  \"sqlite_temp_master\"\n\n/*\n** The root-page of the master database table.\n*/\n#define MASTER_ROOT       1\n\n/*\n** The name of the schema table.\n*/\n#define SCHEMA_TABLE(x)  ((!OMIT_TEMPDB)&&(x==1)?TEMP_MASTER_NAME:MASTER_NAME)\n\n/*\n** A convenience macro that returns the number of elements in\n** an array.\n*/\n#define ArraySize(X)    ((int)(sizeof(X)/sizeof(X[0])))\n\n/*\n** Determine if the argument is a power of two\n*/\n#define IsPowerOfTwo(X) (((X)&((X)-1))==0)\n\n/*\n** The following value as a destructor means to use sqlite3DbFree().\n** The sqlite3DbFree() routine requires two parameters instead of the\n** one parameter that destructors normally want.  So we have to introduce\n** this magic value that the code knows to handle differently.  Any\n** pointer will work here as long as it is distinct from SQLITE_STATIC\n** and SQLITE_TRANSIENT.\n*/\n#define SQLITE_DYNAMIC   ((sqlite3_destructor_type)sqlite3MallocSize)\n\n/*\n** When SQLITE_OMIT_WSD is defined, it means that the target platform does\n** not support Writable Static Data (WSD) such as global and static variables.\n** All variables must either be on the stack or dynamically allocated from\n** the heap.  When WSD is unsupported, the variable declarations scattered\n** throughout the SQLite code must become constants instead.  The SQLITE_WSD\n** macro is used for this purpose.  And instead of referencing the variable\n** directly, we use its constant as a key to lookup the run-time allocated\n** buffer that holds real variable.  The constant is also the initializer\n** for the run-time allocated buffer.\n**\n** In the usual case where WSD is supported, the SQLITE_WSD and GLOBAL\n** macros become no-ops and have zero performance impact.\n*/\n#ifdef SQLITE_OMIT_WSD\n  #define SQLITE_WSD const\n  #define GLOBAL(t,v) (*(t*)sqlite3_wsd_find((void*)&(v), sizeof(v)))\n  #define sqlite3GlobalConfig GLOBAL(struct Sqlite3Config, sqlite3Config)\n  int sqlite3_wsd_init(int N, int J);\n  void *sqlite3_wsd_find(void *K, int L);\n#else\n  #define SQLITE_WSD\n  #define GLOBAL(t,v) v\n  #define sqlite3GlobalConfig sqlite3Config\n#endif\n\n/*\n** The following macros are used to suppress compiler warnings and to\n** make it clear to human readers when a function parameter is deliberately\n** left unused within the body of a function. This usually happens when\n** a function is called via a function pointer. For example the\n** implementation of an SQL aggregate step callback may not use the\n** parameter indicating the number of arguments passed to the aggregate,\n** if it knows that this is enforced elsewhere.\n**\n** When a function parameter is not used at all within the body of a function,\n** it is generally named \"NotUsed\" or \"NotUsed2\" to make things even clearer.\n** However, these macros may also be used to suppress warnings related to\n** parameters that may or may not be used depending on compilation options.\n** For example those parameters only used in assert() statements. In these\n** cases the parameters are named as per the usual conventions.\n*/\n#define UNUSED_PARAMETER(x) (void)(x)\n#define UNUSED_PARAMETER2(x,y) UNUSED_PARAMETER(x),UNUSED_PARAMETER(y)\n\n/*\n** Forward references to structures\n*/\ntypedef struct AggInfo AggInfo;\ntypedef struct AuthContext AuthContext;\ntypedef struct AutoincInfo AutoincInfo;\ntypedef struct Bitvec Bitvec;\ntypedef struct CollSeq CollSeq;\ntypedef struct Column Column;\ntypedef struct Db Db;\ntypedef struct Schema Schema;\ntypedef struct Expr Expr;\ntypedef struct ExprList ExprList;\ntypedef struct FKey FKey;\ntypedef struct FuncDestructor FuncDestructor;\ntypedef struct FuncDef FuncDef;\ntypedef struct FuncDefHash FuncDefHash;\ntypedef struct IdList IdList;\ntypedef struct Index Index;\ntypedef struct IndexSample IndexSample;\ntypedef struct KeyClass KeyClass;\ntypedef struct KeyInfo KeyInfo;\ntypedef struct Lookaside Lookaside;\ntypedef struct LookasideSlot LookasideSlot;\ntypedef struct Module Module;\ntypedef struct NameContext NameContext;\ntypedef struct Parse Parse;\ntypedef struct PreUpdate PreUpdate;\ntypedef struct PrintfArguments PrintfArguments;\ntypedef struct RenameToken RenameToken;\ntypedef struct RowSet RowSet;\ntypedef struct Savepoint Savepoint;\ntypedef struct Select Select;\ntypedef struct SQLiteThread SQLiteThread;\ntypedef struct SelectDest SelectDest;\ntypedef struct SrcList SrcList;\ntypedef struct sqlite3_str StrAccum; /* Internal alias for sqlite3_str */\ntypedef struct Table Table;\ntypedef struct TableLock TableLock;\ntypedef struct Token Token;\ntypedef struct TreeView TreeView;\ntypedef struct Trigger Trigger;\ntypedef struct TriggerPrg TriggerPrg;\ntypedef struct TriggerStep TriggerStep;\ntypedef struct UnpackedRecord UnpackedRecord;\ntypedef struct Upsert Upsert;\ntypedef struct VTable VTable;\ntypedef struct VtabCtx VtabCtx;\ntypedef struct Walker Walker;\ntypedef struct WhereInfo WhereInfo;\ntypedef struct Window Window;\ntypedef struct With With;\n\n\n/*\n** The bitmask datatype defined below is used for various optimizations.\n**\n** Changing this from a 64-bit to a 32-bit type limits the number of\n** tables in a join to 32 instead of 64.  But it also reduces the size\n** of the library by 738 bytes on ix86.\n*/\n#ifdef SQLITE_BITMASK_TYPE\n  typedef SQLITE_BITMASK_TYPE Bitmask;\n#else\n  typedef u64 Bitmask;\n#endif\n\n/*\n** The number of bits in a Bitmask.  \"BMS\" means \"BitMask Size\".\n*/\n#define BMS  ((int)(sizeof(Bitmask)*8))\n\n/*\n** A bit in a Bitmask\n*/\n#define MASKBIT(n)   (((Bitmask)1)<<(n))\n#define MASKBIT32(n) (((unsigned int)1)<<(n))\n#define ALLBITS      ((Bitmask)-1)\n\n/* A VList object records a mapping between parameters/variables/wildcards\n** in the SQL statement (such as $abc, @pqr, or :xyz) and the integer\n** variable number associated with that parameter.  See the format description\n** on the sqlite3VListAdd() routine for more information.  A VList is really\n** just an array of integers.\n*/\ntypedef int VList;\n\n/*\n** Defer sourcing vdbe.h and btree.h until after the \"u8\" and\n** \"BusyHandler\" typedefs. vdbe.h also requires a few of the opaque\n** pointer types (i.e. FuncDef) defined above.\n*/\n#include \"btree.h\"\n#include \"vdbe.h\"\n#include \"pager.h\"\n#include \"pcache.h\"\n#include \"os.h\"\n#include \"mutex.h\"\n\n/* The SQLITE_EXTRA_DURABLE compile-time option used to set the default\n** synchronous setting to EXTRA.  It is no longer supported.\n*/\n#ifdef SQLITE_EXTRA_DURABLE\n# warning Use SQLITE_DEFAULT_SYNCHRONOUS=3 instead of SQLITE_EXTRA_DURABLE\n# define SQLITE_DEFAULT_SYNCHRONOUS 3\n#endif\n\n/*\n** Default synchronous levels.\n**\n** Note that (for historcal reasons) the PAGER_SYNCHRONOUS_* macros differ\n** from the SQLITE_DEFAULT_SYNCHRONOUS value by 1.\n**\n**           PAGER_SYNCHRONOUS       DEFAULT_SYNCHRONOUS\n**   OFF           1                         0\n**   NORMAL        2                         1\n**   FULL          3                         2\n**   EXTRA         4                         3\n**\n** The \"PRAGMA synchronous\" statement also uses the zero-based numbers.\n** In other words, the zero-based numbers are used for all external interfaces\n** and the one-based values are used internally.\n*/\n#ifndef SQLITE_DEFAULT_SYNCHRONOUS\n# define SQLITE_DEFAULT_SYNCHRONOUS 2\n#endif\n#ifndef SQLITE_DEFAULT_WAL_SYNCHRONOUS\n# define SQLITE_DEFAULT_WAL_SYNCHRONOUS SQLITE_DEFAULT_SYNCHRONOUS\n#endif\n\n/*\n** Each database file to be accessed by the system is an instance\n** of the following structure.  There are normally two of these structures\n** in the sqlite.aDb[] array.  aDb[0] is the main database file and\n** aDb[1] is the database file used to hold temporary tables.  Additional\n** databases may be attached.\n*/\nstruct Db {\n  char *zDbSName;      /* Name of this database. (schema name, not filename) */\n  Btree *pBt;          /* The B*Tree structure for this database file */\n  u8 safety_level;     /* How aggressive at syncing data to disk */\n  u8 bSyncSet;         /* True if \"PRAGMA synchronous=N\" has been run */\n  Schema *pSchema;     /* Pointer to database schema (possibly shared) */\n};\n\n/*\n** An instance of the following structure stores a database schema.\n**\n** Most Schema objects are associated with a Btree.  The exception is\n** the Schema for the TEMP databaes (sqlite3.aDb[1]) which is free-standing.\n** In shared cache mode, a single Schema object can be shared by multiple\n** Btrees that refer to the same underlying BtShared object.\n**\n** Schema objects are automatically deallocated when the last Btree that\n** references them is destroyed.   The TEMP Schema is manually freed by\n** sqlite3_close().\n*\n** A thread must be holding a mutex on the corresponding Btree in order\n** to access Schema content.  This implies that the thread must also be\n** holding a mutex on the sqlite3 connection pointer that owns the Btree.\n** For a TEMP Schema, only the connection mutex is required.\n*/\nstruct Schema {\n  int schema_cookie;   /* Database schema version number for this file */\n  int iGeneration;     /* Generation counter.  Incremented with each change */\n  Hash tblHash;        /* All tables indexed by name */\n  Hash idxHash;        /* All (named) indices indexed by name */\n  Hash trigHash;       /* All triggers indexed by name */\n  Hash fkeyHash;       /* All foreign keys by referenced table name */\n  Table *pSeqTab;      /* The sqlite_sequence table used by AUTOINCREMENT */\n  u8 file_format;      /* Schema format version for this file */\n  u8 enc;              /* Text encoding used by this database */\n  u16 schemaFlags;     /* Flags associated with this schema */\n  int cache_size;      /* Number of pages to use in the cache */\n};\n\n/*\n** These macros can be used to test, set, or clear bits in the\n** Db.pSchema->flags field.\n*/\n#define DbHasProperty(D,I,P)     (((D)->aDb[I].pSchema->schemaFlags&(P))==(P))\n#define DbHasAnyProperty(D,I,P)  (((D)->aDb[I].pSchema->schemaFlags&(P))!=0)\n#define DbSetProperty(D,I,P)     (D)->aDb[I].pSchema->schemaFlags|=(P)\n#define DbClearProperty(D,I,P)   (D)->aDb[I].pSchema->schemaFlags&=~(P)\n\n/*\n** Allowed values for the DB.pSchema->flags field.\n**\n** The DB_SchemaLoaded flag is set after the database schema has been\n** read into internal hash tables.\n**\n** DB_UnresetViews means that one or more views have column names that\n** have been filled out.  If the schema changes, these column names might\n** changes and so the view will need to be reset.\n*/\n#define DB_SchemaLoaded    0x0001  /* The schema has been loaded */\n#define DB_UnresetViews    0x0002  /* Some views have defined column names */\n#define DB_Empty           0x0004  /* The file is empty (length 0 bytes) */\n#define DB_ResetWanted     0x0008  /* Reset the schema when nSchemaLock==0 */\n\n/*\n** The number of different kinds of things that can be limited\n** using the sqlite3_limit() interface.\n*/\n#define SQLITE_N_LIMIT (SQLITE_LIMIT_WORKER_THREADS+1)\n\n/*\n** Lookaside malloc is a set of fixed-size buffers that can be used\n** to satisfy small transient memory allocation requests for objects\n** associated with a particular database connection.  The use of\n** lookaside malloc provides a significant performance enhancement\n** (approx 10%) by avoiding numerous malloc/free requests while parsing\n** SQL statements.\n**\n** The Lookaside structure holds configuration information about the\n** lookaside malloc subsystem.  Each available memory allocation in\n** the lookaside subsystem is stored on a linked list of LookasideSlot\n** objects.\n**\n** Lookaside allocations are only allowed for objects that are associated\n** with a particular database connection.  Hence, schema information cannot\n** be stored in lookaside because in shared cache mode the schema information\n** is shared by multiple database connections.  Therefore, while parsing\n** schema information, the Lookaside.bEnabled flag is cleared so that\n** lookaside allocations are not used to construct the schema objects.\n**\n** New lookaside allocations are only allowed if bDisable==0.  When\n** bDisable is greater than zero, sz is set to zero which effectively\n** disables lookaside without adding a new test for the bDisable flag\n** in a performance-critical path.  sz should be set by to szTrue whenever\n** bDisable changes back to zero.\n*/\nstruct Lookaside {\n  u32 bDisable;           /* Only operate the lookaside when zero */\n  u16 sz;                 /* Size of each buffer in bytes */\n  u16 szTrue;             /* True value of sz, even if disabled */\n  u8 bMalloced;           /* True if pStart obtained from sqlite3_malloc() */\n  u32 nSlot;              /* Number of lookaside slots allocated */\n  u32 anStat[3];          /* 0: hits.  1: size misses.  2: full misses */\n  LookasideSlot *pInit;   /* List of buffers not previously used */\n  LookasideSlot *pFree;   /* List of available buffers */\n  void *pStart;           /* First byte of available memory space */\n  void *pEnd;             /* First byte past end of available space */\n};\nstruct LookasideSlot {\n  LookasideSlot *pNext;    /* Next buffer in the list of free buffers */\n};\n\n#define DisableLookaside  db->lookaside.bDisable++;db->lookaside.sz=0\n#define EnableLookaside   db->lookaside.bDisable--;\\\n   db->lookaside.sz=db->lookaside.bDisable?0:db->lookaside.szTrue\n\n/*\n** A hash table for built-in function definitions.  (Application-defined\n** functions use a regular table table from hash.h.)\n**\n** Hash each FuncDef structure into one of the FuncDefHash.a[] slots.\n** Collisions are on the FuncDef.u.pHash chain.  Use the SQLITE_FUNC_HASH()\n** macro to compute a hash on the function name.\n*/\n#define SQLITE_FUNC_HASH_SZ 23\nstruct FuncDefHash {\n  FuncDef *a[SQLITE_FUNC_HASH_SZ];       /* Hash table for functions */\n};\n#define SQLITE_FUNC_HASH(C,L) (((C)+(L))%SQLITE_FUNC_HASH_SZ)\n\n#ifdef SQLITE_USER_AUTHENTICATION\n/*\n** Information held in the \"sqlite3\" database connection object and used\n** to manage user authentication.\n*/\ntypedef struct sqlite3_userauth sqlite3_userauth;\nstruct sqlite3_userauth {\n  u8 authLevel;                 /* Current authentication level */\n  int nAuthPW;                  /* Size of the zAuthPW in bytes */\n  char *zAuthPW;                /* Password used to authenticate */\n  char *zAuthUser;              /* User name used to authenticate */\n};\n\n/* Allowed values for sqlite3_userauth.authLevel */\n#define UAUTH_Unknown     0     /* Authentication not yet checked */\n#define UAUTH_Fail        1     /* User authentication failed */\n#define UAUTH_User        2     /* Authenticated as a normal user */\n#define UAUTH_Admin       3     /* Authenticated as an administrator */\n\n/* Functions used only by user authorization logic */\nint sqlite3UserAuthTable(const char*);\nint sqlite3UserAuthCheckLogin(sqlite3*,const char*,u8*);\nvoid sqlite3UserAuthInit(sqlite3*);\nvoid sqlite3CryptFunc(sqlite3_context*,int,sqlite3_value**);\n\n#endif /* SQLITE_USER_AUTHENTICATION */\n\n/*\n** typedef for the authorization callback function.\n*/\n#ifdef SQLITE_USER_AUTHENTICATION\n  typedef int (*sqlite3_xauth)(void*,int,const char*,const char*,const char*,\n                               const char*, const char*);\n#else\n  typedef int (*sqlite3_xauth)(void*,int,const char*,const char*,const char*,\n                               const char*);\n#endif\n\n#ifndef SQLITE_OMIT_DEPRECATED\n/* This is an extra SQLITE_TRACE macro that indicates \"legacy\" tracing\n** in the style of sqlite3_trace()\n*/\n#define SQLITE_TRACE_LEGACY          0x40     /* Use the legacy xTrace */\n#define SQLITE_TRACE_XPROFILE        0x80     /* Use the legacy xProfile */\n#else\n#define SQLITE_TRACE_LEGACY          0\n#define SQLITE_TRACE_XPROFILE        0\n#endif /* SQLITE_OMIT_DEPRECATED */\n#define SQLITE_TRACE_NONLEGACY_MASK  0x0f     /* Normal flags */\n\n\n/*\n** Each database connection is an instance of the following structure.\n*/\nstruct sqlite3 {\n  sqlite3_vfs *pVfs;            /* OS Interface */\n  struct Vdbe *pVdbe;           /* List of active virtual machines */\n  CollSeq *pDfltColl;           /* The default collating sequence (BINARY) */\n  sqlite3_mutex *mutex;         /* Connection mutex */\n  Db *aDb;                      /* All backends */\n  int nDb;                      /* Number of backends currently in use */\n  u32 mDbFlags;                 /* flags recording internal state */\n  u64 flags;                    /* flags settable by pragmas. See below */\n  i64 lastRowid;                /* ROWID of most recent insert (see above) */\n  i64 szMmap;                   /* Default mmap_size setting */\n  u32 nSchemaLock;              /* Do not reset the schema when non-zero */\n  unsigned int openFlags;       /* Flags passed to sqlite3_vfs.xOpen() */\n  int errCode;                  /* Most recent error code (SQLITE_*) */\n  int errMask;                  /* & result codes with this before returning */\n  int iSysErrno;                /* Errno value from last system error */\n  u16 dbOptFlags;               /* Flags to enable/disable optimizations */\n  u8 enc;                       /* Text encoding */\n  u8 autoCommit;                /* The auto-commit flag. */\n  u8 temp_store;                /* 1: file 2: memory 0: default */\n  u8 mallocFailed;              /* True if we have seen a malloc failure */\n  u8 bBenignMalloc;             /* Do not require OOMs if true */\n  u8 dfltLockMode;              /* Default locking-mode for attached dbs */\n  signed char nextAutovac;      /* Autovac setting after VACUUM if >=0 */\n  u8 suppressErr;               /* Do not issue error messages if true */\n  u8 vtabOnConflict;            /* Value to return for s3_vtab_on_conflict() */\n  u8 isTransactionSavepoint;    /* True if the outermost savepoint is a TS */\n  u8 mTrace;                    /* zero or more SQLITE_TRACE flags */\n  u8 noSharedCache;             /* True if no shared-cache backends */\n  u8 nSqlExec;                  /* Number of pending OP_SqlExec opcodes */\n  int nextPagesize;             /* Pagesize after VACUUM if >0 */\n  u32 magic;                    /* Magic number for detect library misuse */\n  int nChange;                  /* Value returned by sqlite3_changes() */\n  int nTotalChange;             /* Value returned by sqlite3_total_changes() */\n  int aLimit[SQLITE_N_LIMIT];   /* Limits */\n  int nMaxSorterMmap;           /* Maximum size of regions mapped by sorter */\n  struct sqlite3InitInfo {      /* Information used during initialization */\n    int newTnum;                /* Rootpage of table being initialized */\n    u8 iDb;                     /* Which db file is being initialized */\n    u8 busy;                    /* TRUE if currently initializing */\n    unsigned orphanTrigger : 1; /* Last statement is orphaned TEMP trigger */\n    unsigned imposterTable : 1; /* Building an imposter table */\n    unsigned reopenMemdb : 1;   /* ATTACH is really a reopen using MemDB */\n    char **azInit;              /* \"type\", \"name\", and \"tbl_name\" columns */\n  } init;\n  int nVdbeActive;              /* Number of VDBEs currently running */\n  int nVdbeRead;                /* Number of active VDBEs that read or write */\n  int nVdbeWrite;               /* Number of active VDBEs that read and write */\n  int nVdbeExec;                /* Number of nested calls to VdbeExec() */\n  int nVDestroy;                /* Number of active OP_VDestroy operations */\n  int nExtension;               /* Number of loaded extensions */\n  void **aExtension;            /* Array of shared library handles */\n  int (*xTrace)(u32,void*,void*,void*);     /* Trace function */\n  void *pTraceArg;                          /* Argument to the trace function */\n#ifndef SQLITE_OMIT_DEPRECATED\n  void (*xProfile)(void*,const char*,u64);  /* Profiling function */\n  void *pProfileArg;                        /* Argument to profile function */\n#endif\n  void *pCommitArg;                 /* Argument to xCommitCallback() */\n  int (*xCommitCallback)(void*);    /* Invoked at every commit. */\n  void *pRollbackArg;               /* Argument to xRollbackCallback() */\n  void (*xRollbackCallback)(void*); /* Invoked at every commit. */\n  void *pUpdateArg;\n  void (*xUpdateCallback)(void*,int, const char*,const char*,sqlite_int64);\n  Parse *pParse;                /* Current parse */\n#ifdef SQLITE_ENABLE_PREUPDATE_HOOK\n  void *pPreUpdateArg;          /* First argument to xPreUpdateCallback */\n  void (*xPreUpdateCallback)(   /* Registered using sqlite3_preupdate_hook() */\n    void*,sqlite3*,int,char const*,char const*,sqlite3_int64,sqlite3_int64\n  );\n  PreUpdate *pPreUpdate;        /* Context for active pre-update callback */\n#endif /* SQLITE_ENABLE_PREUPDATE_HOOK */\n#ifndef SQLITE_OMIT_WAL\n  int (*xWalCallback)(void *, sqlite3 *, const char *, int);\n  void *pWalArg;\n#endif\n  void(*xCollNeeded)(void*,sqlite3*,int eTextRep,const char*);\n  void(*xCollNeeded16)(void*,sqlite3*,int eTextRep,const void*);\n  void *pCollNeededArg;\n  sqlite3_value *pErr;          /* Most recent error message */\n  union {\n    volatile int isInterrupted; /* True if sqlite3_interrupt has been called */\n    double notUsed1;            /* Spacer */\n  } u1;\n  Lookaside lookaside;          /* Lookaside malloc configuration */\n#ifndef SQLITE_OMIT_AUTHORIZATION\n  sqlite3_xauth xAuth;          /* Access authorization function */\n  void *pAuthArg;               /* 1st argument to the access auth function */\n#endif\n#ifndef SQLITE_OMIT_PROGRESS_CALLBACK\n  int (*xProgress)(void *);     /* The progress callback */\n  void *pProgressArg;           /* Argument to the progress callback */\n  unsigned nProgressOps;        /* Number of opcodes for progress callback */\n#endif\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n  int nVTrans;                  /* Allocated size of aVTrans */\n  Hash aModule;                 /* populated by sqlite3_create_module() */\n  VtabCtx *pVtabCtx;            /* Context for active vtab connect/create */\n  VTable **aVTrans;             /* Virtual tables with open transactions */\n  VTable *pDisconnect;          /* Disconnect these in next sqlite3_prepare() */\n#endif\n  Hash aFunc;                   /* Hash table of connection functions */\n  Hash aCollSeq;                /* All collating sequences */\n  BusyHandler busyHandler;      /* Busy callback */\n  Db aDbStatic[2];              /* Static space for the 2 default backends */\n  Savepoint *pSavepoint;        /* List of active savepoints */\n  int busyTimeout;              /* Busy handler timeout, in msec */\n  int nSavepoint;               /* Number of non-transaction savepoints */\n  int nStatement;               /* Number of nested statement-transactions  */\n  i64 nDeferredCons;            /* Net deferred constraints this transaction. */\n  i64 nDeferredImmCons;         /* Net deferred immediate constraints */\n  int *pnBytesFreed;            /* If not NULL, increment this in DbFree() */\n#ifdef SQLITE_ENABLE_UNLOCK_NOTIFY\n  /* The following variables are all protected by the STATIC_MASTER\n  ** mutex, not by sqlite3.mutex. They are used by code in notify.c.\n  **\n  ** When X.pUnlockConnection==Y, that means that X is waiting for Y to\n  ** unlock so that it can proceed.\n  **\n  ** When X.pBlockingConnection==Y, that means that something that X tried\n  ** tried to do recently failed with an SQLITE_LOCKED error due to locks\n  ** held by Y.\n  */\n  sqlite3 *pBlockingConnection; /* Connection that caused SQLITE_LOCKED */\n  sqlite3 *pUnlockConnection;           /* Connection to watch for unlock */\n  void *pUnlockArg;                     /* Argument to xUnlockNotify */\n  void (*xUnlockNotify)(void **, int);  /* Unlock notify callback */\n  sqlite3 *pNextBlocked;        /* Next in list of all blocked connections */\n#endif\n#ifdef SQLITE_USER_AUTHENTICATION\n  sqlite3_userauth auth;        /* User authentication information */\n#endif\n};\n\n/*\n** A macro to discover the encoding of a database.\n*/\n#define SCHEMA_ENC(db) ((db)->aDb[0].pSchema->enc)\n#define ENC(db)        ((db)->enc)\n\n/*\n** Possible values for the sqlite3.flags.\n**\n** Value constraints (enforced via assert()):\n**      SQLITE_FullFSync     == PAGER_FULLFSYNC\n**      SQLITE_CkptFullFSync == PAGER_CKPT_FULLFSYNC\n**      SQLITE_CacheSpill    == PAGER_CACHE_SPILL\n*/\n#define SQLITE_WriteSchema    0x00000001  /* OK to update SQLITE_MASTER */\n#define SQLITE_LegacyFileFmt  0x00000002  /* Create new databases in format 1 */\n#define SQLITE_FullColNames   0x00000004  /* Show full column names on SELECT */\n#define SQLITE_FullFSync      0x00000008  /* Use full fsync on the backend */\n#define SQLITE_CkptFullFSync  0x00000010  /* Use full fsync for checkpoint */\n#define SQLITE_CacheSpill     0x00000020  /* OK to spill pager cache */\n#define SQLITE_ShortColNames  0x00000040  /* Show short columns names */\n#define SQLITE_CountRows      0x00000080  /* Count rows changed by INSERT, */\n                                          /*   DELETE, or UPDATE and return */\n                                          /*   the count using a callback. */\n#define SQLITE_NullCallback   0x00000100  /* Invoke the callback once if the */\n                                          /*   result set is empty */\n#define SQLITE_IgnoreChecks   0x00000200  /* Do not enforce check constraints */\n#define SQLITE_ReadUncommit   0x00000400  /* READ UNCOMMITTED in shared-cache */\n#define SQLITE_NoCkptOnClose  0x00000800  /* No checkpoint on close()/DETACH */\n#define SQLITE_ReverseOrder   0x00001000  /* Reverse unordered SELECTs */\n#define SQLITE_RecTriggers    0x00002000  /* Enable recursive triggers */\n#define SQLITE_ForeignKeys    0x00004000  /* Enforce foreign key constraints  */\n#define SQLITE_AutoIndex      0x00008000  /* Enable automatic indexes */\n#define SQLITE_LoadExtension  0x00010000  /* Enable load_extension */\n#define SQLITE_LoadExtFunc    0x00020000  /* Enable load_extension() SQL func */\n#define SQLITE_EnableTrigger  0x00040000  /* True to enable triggers */\n#define SQLITE_DeferFKs       0x00080000  /* Defer all FK constraints */\n#define SQLITE_QueryOnly      0x00100000  /* Disable database changes */\n#define SQLITE_CellSizeCk     0x00200000  /* Check btree cell sizes on load */\n#define SQLITE_Fts3Tokenizer  0x00400000  /* Enable fts3_tokenizer(2) */\n#define SQLITE_EnableQPSG     0x00800000  /* Query Planner Stability Guarantee*/\n#define SQLITE_TriggerEQP     0x01000000  /* Show trigger EXPLAIN QUERY PLAN */\n#define SQLITE_ResetDatabase  0x02000000  /* Reset the database */\n#define SQLITE_LegacyAlter    0x04000000  /* Legacy ALTER TABLE behaviour */\n#define SQLITE_NoSchemaError  0x08000000  /* Do not report schema parse errors*/\n#define SQLITE_Defensive      0x10000000  /* Input SQL is likely hostile */\n#define SQLITE_DqsDDL         0x20000000  /* dbl-quoted strings allowed in DDL*/\n#define SQLITE_DqsDML         0x40000000  /* dbl-quoted strings allowed in DML*/\n#define SQLITE_EnableView     0x80000000  /* Enable the use of views */\n\n/* Flags used only if debugging */\n#define HI(X)  ((u64)(X)<<32)\n#ifdef SQLITE_DEBUG\n#define SQLITE_SqlTrace       HI(0x0100000) /* Debug print SQL as it executes */\n#define SQLITE_VdbeListing    HI(0x0200000) /* Debug listings of VDBE progs */\n#define SQLITE_VdbeTrace      HI(0x0400000) /* True to trace VDBE execution */\n#define SQLITE_VdbeAddopTrace HI(0x0800000) /* Trace sqlite3VdbeAddOp() calls */\n#define SQLITE_VdbeEQP        HI(0x1000000) /* Debug EXPLAIN QUERY PLAN */\n#define SQLITE_ParserTrace    HI(0x2000000) /* PRAGMA parser_trace=ON */\n#endif\n\n/*\n** Allowed values for sqlite3.mDbFlags\n*/\n#define DBFLAG_SchemaChange   0x0001  /* Uncommitted Hash table changes */\n#define DBFLAG_PreferBuiltin  0x0002  /* Preference to built-in funcs */\n#define DBFLAG_Vacuum         0x0004  /* Currently in a VACUUM */\n#define DBFLAG_VacuumInto     0x0008  /* Currently running VACUUM INTO */\n#define DBFLAG_SchemaKnownOk  0x0010  /* Schema is known to be valid */\n\n/*\n** Bits of the sqlite3.dbOptFlags field that are used by the\n** sqlite3_test_control(SQLITE_TESTCTRL_OPTIMIZATIONS,...) interface to\n** selectively disable various optimizations.\n*/\n#define SQLITE_QueryFlattener 0x0001   /* Query flattening */\n#define SQLITE_WindowFunc     0x0002   /* Use xInverse for window functions */\n#define SQLITE_GroupByOrder   0x0004   /* GROUPBY cover of ORDERBY */\n#define SQLITE_FactorOutConst 0x0008   /* Constant factoring */\n#define SQLITE_DistinctOpt    0x0010   /* DISTINCT using indexes */\n#define SQLITE_CoverIdxScan   0x0020   /* Covering index scans */\n#define SQLITE_OrderByIdxJoin 0x0040   /* ORDER BY of joins via index */\n#define SQLITE_Transitive     0x0080   /* Transitive constraints */\n#define SQLITE_OmitNoopJoin   0x0100   /* Omit unused tables in joins */\n#define SQLITE_CountOfView    0x0200   /* The count-of-view optimization */\n#define SQLITE_CursorHints    0x0400   /* Add OP_CursorHint opcodes */\n#define SQLITE_Stat4          0x0800   /* Use STAT4 data */\n   /* TH3 expects the Stat4   ^^^^^^ value to be 0x0800.  Don't change it */\n#define SQLITE_PushDown       0x1000   /* The push-down optimization */\n#define SQLITE_SimplifyJoin   0x2000   /* Convert LEFT JOIN to JOIN */\n#define SQLITE_SkipScan       0x4000   /* Skip-scans */\n#define SQLITE_PropagateConst 0x8000   /* The constant propagation opt */\n#define SQLITE_AllOpts        0xffff   /* All optimizations */\n\n/*\n** Macros for testing whether or not optimizations are enabled or disabled.\n*/\n#define OptimizationDisabled(db, mask)  (((db)->dbOptFlags&(mask))!=0)\n#define OptimizationEnabled(db, mask)   (((db)->dbOptFlags&(mask))==0)\n\n/*\n** Return true if it OK to factor constant expressions into the initialization\n** code. The argument is a Parse object for the code generator.\n*/\n#define ConstFactorOk(P) ((P)->okConstFactor)\n\n/*\n** Possible values for the sqlite.magic field.\n** The numbers are obtained at random and have no special meaning, other\n** than being distinct from one another.\n*/\n#define SQLITE_MAGIC_OPEN     0xa029a697  /* Database is open */\n#define SQLITE_MAGIC_CLOSED   0x9f3c2d33  /* Database is closed */\n#define SQLITE_MAGIC_SICK     0x4b771290  /* Error and awaiting close */\n#define SQLITE_MAGIC_BUSY     0xf03b7906  /* Database currently in use */\n#define SQLITE_MAGIC_ERROR    0xb5357930  /* An SQLITE_MISUSE error occurred */\n#define SQLITE_MAGIC_ZOMBIE   0x64cffc7f  /* Close with last statement close */\n\n/*\n** Each SQL function is defined by an instance of the following\n** structure.  For global built-in functions (ex: substr(), max(), count())\n** a pointer to this structure is held in the sqlite3BuiltinFunctions object.\n** For per-connection application-defined functions, a pointer to this\n** structure is held in the db->aHash hash table.\n**\n** The u.pHash field is used by the global built-ins.  The u.pDestructor\n** field is used by per-connection app-def functions.\n*/\nstruct FuncDef {\n  i8 nArg;             /* Number of arguments.  -1 means unlimited */\n  u32 funcFlags;       /* Some combination of SQLITE_FUNC_* */\n  void *pUserData;     /* User data parameter */\n  FuncDef *pNext;      /* Next function with same name */\n  void (*xSFunc)(sqlite3_context*,int,sqlite3_value**); /* func or agg-step */\n  void (*xFinalize)(sqlite3_context*);                  /* Agg finalizer */\n  void (*xValue)(sqlite3_context*);                     /* Current agg value */\n  void (*xInverse)(sqlite3_context*,int,sqlite3_value**); /* inverse agg-step */\n  const char *zName;   /* SQL name of the function. */\n  union {\n    FuncDef *pHash;      /* Next with a different name but the same hash */\n    FuncDestructor *pDestructor;   /* Reference counted destructor function */\n  } u;\n};\n\n/*\n** This structure encapsulates a user-function destructor callback (as\n** configured using create_function_v2()) and a reference counter. When\n** create_function_v2() is called to create a function with a destructor,\n** a single object of this type is allocated. FuncDestructor.nRef is set to\n** the number of FuncDef objects created (either 1 or 3, depending on whether\n** or not the specified encoding is SQLITE_ANY). The FuncDef.pDestructor\n** member of each of the new FuncDef objects is set to point to the allocated\n** FuncDestructor.\n**\n** Thereafter, when one of the FuncDef objects is deleted, the reference\n** count on this object is decremented. When it reaches 0, the destructor\n** is invoked and the FuncDestructor structure freed.\n*/\nstruct FuncDestructor {\n  int nRef;\n  void (*xDestroy)(void *);\n  void *pUserData;\n};\n\n/*\n** Possible values for FuncDef.flags.  Note that the _LENGTH and _TYPEOF\n** values must correspond to OPFLAG_LENGTHARG and OPFLAG_TYPEOFARG.  And\n** SQLITE_FUNC_CONSTANT must be the same as SQLITE_DETERMINISTIC.  There\n** are assert() statements in the code to verify this.\n**\n** Value constraints (enforced via assert()):\n**     SQLITE_FUNC_MINMAX    ==  NC_MinMaxAgg      == SF_MinMaxAgg\n**     SQLITE_FUNC_LENGTH    ==  OPFLAG_LENGTHARG\n**     SQLITE_FUNC_TYPEOF    ==  OPFLAG_TYPEOFARG\n**     SQLITE_FUNC_CONSTANT  ==  SQLITE_DETERMINISTIC from the API\n**     SQLITE_FUNC_DIRECT    ==  SQLITE_DIRECTONLY from the API\n**     SQLITE_FUNC_ENCMASK   depends on SQLITE_UTF* macros in the API\n*/\n#define SQLITE_FUNC_ENCMASK  0x0003 /* SQLITE_UTF8, SQLITE_UTF16BE or UTF16LE */\n#define SQLITE_FUNC_LIKE     0x0004 /* Candidate for the LIKE optimization */\n#define SQLITE_FUNC_CASE     0x0008 /* Case-sensitive LIKE-type function */\n#define SQLITE_FUNC_EPHEM    0x0010 /* Ephemeral.  Delete with VDBE */\n#define SQLITE_FUNC_NEEDCOLL 0x0020 /* sqlite3GetFuncCollSeq() might be called*/\n#define SQLITE_FUNC_LENGTH   0x0040 /* Built-in length() function */\n#define SQLITE_FUNC_TYPEOF   0x0080 /* Built-in typeof() function */\n#define SQLITE_FUNC_COUNT    0x0100 /* Built-in count(*) aggregate */\n#define SQLITE_FUNC_COALESCE 0x0200 /* Built-in coalesce() or ifnull() */\n#define SQLITE_FUNC_UNLIKELY 0x0400 /* Built-in unlikely() function */\n#define SQLITE_FUNC_CONSTANT 0x0800 /* Constant inputs give a constant output */\n#define SQLITE_FUNC_MINMAX   0x1000 /* True for min() and max() aggregates */\n#define SQLITE_FUNC_SLOCHNG  0x2000 /* \"Slow Change\". Value constant during a\n                                    ** single query - might change over time */\n#define SQLITE_FUNC_AFFINITY 0x4000 /* Built-in affinity() function */\n#define SQLITE_FUNC_OFFSET   0x8000 /* Built-in sqlite_offset() function */\n#define SQLITE_FUNC_WINDOW   0x00010000 /* Built-in window-only function */\n#define SQLITE_FUNC_INTERNAL 0x00040000 /* For use by NestedParse() only */\n#define SQLITE_FUNC_DIRECT   0x00080000 /* Not for use in TRIGGERs or VIEWs */\n#define SQLITE_FUNC_SUBTYPE  0x00100000 /* Result likely to have sub-type */\n\n/*\n** The following three macros, FUNCTION(), LIKEFUNC() and AGGREGATE() are\n** used to create the initializers for the FuncDef structures.\n**\n**   FUNCTION(zName, nArg, iArg, bNC, xFunc)\n**     Used to create a scalar function definition of a function zName\n**     implemented by C function xFunc that accepts nArg arguments. The\n**     value passed as iArg is cast to a (void*) and made available\n**     as the user-data (sqlite3_user_data()) for the function. If\n**     argument bNC is true, then the SQLITE_FUNC_NEEDCOLL flag is set.\n**\n**   VFUNCTION(zName, nArg, iArg, bNC, xFunc)\n**     Like FUNCTION except it omits the SQLITE_FUNC_CONSTANT flag.\n**\n**   DFUNCTION(zName, nArg, iArg, bNC, xFunc)\n**     Like FUNCTION except it omits the SQLITE_FUNC_CONSTANT flag and\n**     adds the SQLITE_FUNC_SLOCHNG flag.  Used for date & time functions\n**     and functions like sqlite_version() that can change, but not during\n**     a single query.  The iArg is ignored.  The user-data is always set\n**     to a NULL pointer.  The bNC parameter is not used.\n**\n**   PURE_DATE(zName, nArg, iArg, bNC, xFunc)\n**     Used for \"pure\" date/time functions, this macro is like DFUNCTION\n**     except that it does set the SQLITE_FUNC_CONSTANT flags.  iArg is\n**     ignored and the user-data for these functions is set to an \n**     arbitrary non-NULL pointer.  The bNC parameter is not used.\n**\n**   AGGREGATE(zName, nArg, iArg, bNC, xStep, xFinal)\n**     Used to create an aggregate function definition implemented by\n**     the C functions xStep and xFinal. The first four parameters\n**     are interpreted in the same way as the first 4 parameters to\n**     FUNCTION().\n**\n**   WFUNCTION(zName, nArg, iArg, xStep, xFinal, xValue, xInverse)\n**     Used to create an aggregate function definition implemented by\n**     the C functions xStep and xFinal. The first four parameters\n**     are interpreted in the same way as the first 4 parameters to\n**     FUNCTION().\n**\n**   LIKEFUNC(zName, nArg, pArg, flags)\n**     Used to create a scalar function definition of a function zName\n**     that accepts nArg arguments and is implemented by a call to C\n**     function likeFunc. Argument pArg is cast to a (void *) and made\n**     available as the function user-data (sqlite3_user_data()). The\n**     FuncDef.flags variable is set to the value passed as the flags\n**     parameter.\n*/\n#define FUNCTION(zName, nArg, iArg, bNC, xFunc) \\\n  {nArg, SQLITE_FUNC_CONSTANT|SQLITE_UTF8|(bNC*SQLITE_FUNC_NEEDCOLL), \\\n   SQLITE_INT_TO_PTR(iArg), 0, xFunc, 0, 0, 0, #zName, {0} }\n#define VFUNCTION(zName, nArg, iArg, bNC, xFunc) \\\n  {nArg, SQLITE_UTF8|(bNC*SQLITE_FUNC_NEEDCOLL), \\\n   SQLITE_INT_TO_PTR(iArg), 0, xFunc, 0, 0, 0, #zName, {0} }\n#define DFUNCTION(zName, nArg, iArg, bNC, xFunc) \\\n  {nArg, SQLITE_FUNC_SLOCHNG|SQLITE_UTF8, \\\n   0, 0, xFunc, 0, 0, 0, #zName, {0} }\n#define PURE_DATE(zName, nArg, iArg, bNC, xFunc) \\\n  {nArg, SQLITE_FUNC_SLOCHNG|SQLITE_UTF8|SQLITE_FUNC_CONSTANT, \\\n   (void*)&sqlite3Config, 0, xFunc, 0, 0, 0, #zName, {0} }\n#define FUNCTION2(zName, nArg, iArg, bNC, xFunc, extraFlags) \\\n  {nArg,SQLITE_FUNC_CONSTANT|SQLITE_UTF8|(bNC*SQLITE_FUNC_NEEDCOLL)|extraFlags,\\\n   SQLITE_INT_TO_PTR(iArg), 0, xFunc, 0, 0, 0, #zName, {0} }\n#define STR_FUNCTION(zName, nArg, pArg, bNC, xFunc) \\\n  {nArg, SQLITE_FUNC_SLOCHNG|SQLITE_UTF8|(bNC*SQLITE_FUNC_NEEDCOLL), \\\n   pArg, 0, xFunc, 0, 0, 0, #zName, }\n#define LIKEFUNC(zName, nArg, arg, flags) \\\n  {nArg, SQLITE_FUNC_CONSTANT|SQLITE_UTF8|flags, \\\n   (void *)arg, 0, likeFunc, 0, 0, 0, #zName, {0} }\n#define AGGREGATE(zName, nArg, arg, nc, xStep, xFinal, xValue) \\\n  {nArg, SQLITE_UTF8|(nc*SQLITE_FUNC_NEEDCOLL), \\\n   SQLITE_INT_TO_PTR(arg), 0, xStep,xFinal,xValue,0,#zName, {0}}\n#define AGGREGATE2(zName, nArg, arg, nc, xStep, xFinal, extraFlags) \\\n  {nArg, SQLITE_UTF8|(nc*SQLITE_FUNC_NEEDCOLL)|extraFlags, \\\n   SQLITE_INT_TO_PTR(arg), 0, xStep,xFinal,xFinal,0,#zName, {0}}\n#define WAGGREGATE(zName, nArg, arg, nc, xStep, xFinal, xValue, xInverse, f) \\\n  {nArg, SQLITE_UTF8|(nc*SQLITE_FUNC_NEEDCOLL)|f, \\\n   SQLITE_INT_TO_PTR(arg), 0, xStep,xFinal,xValue,xInverse,#zName, {0}}\n#define INTERNAL_FUNCTION(zName, nArg, xFunc) \\\n  {nArg, SQLITE_FUNC_INTERNAL|SQLITE_UTF8|SQLITE_FUNC_CONSTANT, \\\n   0, 0, xFunc, 0, 0, 0, #zName, {0} }\n\n\n/*\n** All current savepoints are stored in a linked list starting at\n** sqlite3.pSavepoint. The first element in the list is the most recently\n** opened savepoint. Savepoints are added to the list by the vdbe\n** OP_Savepoint instruction.\n*/\nstruct Savepoint {\n  char *zName;                        /* Savepoint name (nul-terminated) */\n  i64 nDeferredCons;                  /* Number of deferred fk violations */\n  i64 nDeferredImmCons;               /* Number of deferred imm fk. */\n  Savepoint *pNext;                   /* Parent savepoint (if any) */\n};\n\n/*\n** The following are used as the second parameter to sqlite3Savepoint(),\n** and as the P1 argument to the OP_Savepoint instruction.\n*/\n#define SAVEPOINT_BEGIN      0\n#define SAVEPOINT_RELEASE    1\n#define SAVEPOINT_ROLLBACK   2\n\n\n/*\n** Each SQLite module (virtual table definition) is defined by an\n** instance of the following structure, stored in the sqlite3.aModule\n** hash table.\n*/\nstruct Module {\n  const sqlite3_module *pModule;       /* Callback pointers */\n  const char *zName;                   /* Name passed to create_module() */\n  int nRefModule;                      /* Number of pointers to this object */\n  void *pAux;                          /* pAux passed to create_module() */\n  void (*xDestroy)(void *);            /* Module destructor function */\n  Table *pEpoTab;                      /* Eponymous table for this module */\n};\n\n/*\n** Information about each column of an SQL table is held in an instance\n** of the Column structure, in the Table.aCol[] array.\n**\n** Definitions:\n**\n**   \"table column index\"     This is the index of the column in the\n**                            Table.aCol[] array, and also the index of\n**                            the column in the original CREATE TABLE stmt.\n**\n**   \"storage column index\"   This is the index of the column in the\n**                            record BLOB generated by the OP_MakeRecord\n**                            opcode.  The storage column index is less than\n**                            or equal to the table column index.  It is\n**                            equal if and only if there are no VIRTUAL\n**                            columns to the left.\n*/\nstruct Column {\n  char *zName;     /* Name of this column, \\000, then the type */\n  Expr *pDflt;     /* Default value or GENERATED ALWAYS AS value */\n  char *zColl;     /* Collating sequence.  If NULL, use the default */\n  u8 notNull;      /* An OE_ code for handling a NOT NULL constraint */\n  char affinity;   /* One of the SQLITE_AFF_... values */\n  u8 szEst;        /* Estimated size of value in this column. sizeof(INT)==1 */\n  u16 colFlags;    /* Boolean properties.  See COLFLAG_ defines below */\n};\n\n/* Allowed values for Column.colFlags:\n*/\n#define COLFLAG_PRIMKEY   0x0001   /* Column is part of the primary key */\n#define COLFLAG_HIDDEN    0x0002   /* A hidden column in a virtual table */\n#define COLFLAG_HASTYPE   0x0004   /* Type name follows column name */\n#define COLFLAG_UNIQUE    0x0008   /* Column def contains \"UNIQUE\" or \"PK\" */\n#define COLFLAG_SORTERREF 0x0010   /* Use sorter-refs with this column */\n#define COLFLAG_VIRTUAL   0x0020   /* GENERATED ALWAYS AS ... VIRTUAL */\n#define COLFLAG_STORED    0x0040   /* GENERATED ALWAYS AS ... STORED */\n#define COLFLAG_NOTAVAIL  0x0080   /* STORED column not yet calculated */\n#define COLFLAG_BUSY      0x0100   /* Blocks recursion on GENERATED columns */\n#define COLFLAG_GENERATED 0x0060   /* Combo: _STORED, _VIRTUAL */\n#define COLFLAG_NOINSERT  0x0062   /* Combo: _HIDDEN, _STORED, _VIRTUAL */\n\n/*\n** A \"Collating Sequence\" is defined by an instance of the following\n** structure. Conceptually, a collating sequence consists of a name and\n** a comparison routine that defines the order of that sequence.\n**\n** If CollSeq.xCmp is NULL, it means that the\n** collating sequence is undefined.  Indices built on an undefined\n** collating sequence may not be read or written.\n*/\nstruct CollSeq {\n  char *zName;          /* Name of the collating sequence, UTF-8 encoded */\n  u8 enc;               /* Text encoding handled by xCmp() */\n  void *pUser;          /* First argument to xCmp() */\n  int (*xCmp)(void*,int, const void*, int, const void*);\n  void (*xDel)(void*);  /* Destructor for pUser */\n};\n\n/*\n** A sort order can be either ASC or DESC.\n*/\n#define SQLITE_SO_ASC       0  /* Sort in ascending order */\n#define SQLITE_SO_DESC      1  /* Sort in ascending order */\n#define SQLITE_SO_UNDEFINED -1 /* No sort order specified */\n\n/*\n** Column affinity types.\n**\n** These used to have mnemonic name like 'i' for SQLITE_AFF_INTEGER and\n** 't' for SQLITE_AFF_TEXT.  But we can save a little space and improve\n** the speed a little by numbering the values consecutively.\n**\n** But rather than start with 0 or 1, we begin with 'A'.  That way,\n** when multiple affinity types are concatenated into a string and\n** used as the P4 operand, they will be more readable.\n**\n** Note also that the numeric types are grouped together so that testing\n** for a numeric type is a single comparison.  And the BLOB type is first.\n*/\n#define SQLITE_AFF_NONE     0x40  /* '@' */\n#define SQLITE_AFF_BLOB     0x41  /* 'A' */\n#define SQLITE_AFF_TEXT     0x42  /* 'B' */\n#define SQLITE_AFF_NUMERIC  0x43  /* 'C' */\n#define SQLITE_AFF_INTEGER  0x44  /* 'D' */\n#define SQLITE_AFF_REAL     0x45  /* 'E' */\n\n#define sqlite3IsNumericAffinity(X)  ((X)>=SQLITE_AFF_NUMERIC)\n\n/*\n** The SQLITE_AFF_MASK values masks off the significant bits of an\n** affinity value.\n*/\n#define SQLITE_AFF_MASK     0x47\n\n/*\n** Additional bit values that can be ORed with an affinity without\n** changing the affinity.\n**\n** The SQLITE_NOTNULL flag is a combination of NULLEQ and JUMPIFNULL.\n** It causes an assert() to fire if either operand to a comparison\n** operator is NULL.  It is added to certain comparison operators to\n** prove that the operands are always NOT NULL.\n*/\n#define SQLITE_KEEPNULL     0x08  /* Used by vector == or <> */\n#define SQLITE_JUMPIFNULL   0x10  /* jumps if either operand is NULL */\n#define SQLITE_STOREP2      0x20  /* Store result in reg[P2] rather than jump */\n#define SQLITE_NULLEQ       0x80  /* NULL=NULL */\n#define SQLITE_NOTNULL      0x90  /* Assert that operands are never NULL */\n\n/*\n** An object of this type is created for each virtual table present in\n** the database schema.\n**\n** If the database schema is shared, then there is one instance of this\n** structure for each database connection (sqlite3*) that uses the shared\n** schema. This is because each database connection requires its own unique\n** instance of the sqlite3_vtab* handle used to access the virtual table\n** implementation. sqlite3_vtab* handles can not be shared between\n** database connections, even when the rest of the in-memory database\n** schema is shared, as the implementation often stores the database\n** connection handle passed to it via the xConnect() or xCreate() method\n** during initialization internally. This database connection handle may\n** then be used by the virtual table implementation to access real tables\n** within the database. So that they appear as part of the callers\n** transaction, these accesses need to be made via the same database\n** connection as that used to execute SQL operations on the virtual table.\n**\n** All VTable objects that correspond to a single table in a shared\n** database schema are initially stored in a linked-list pointed to by\n** the Table.pVTable member variable of the corresponding Table object.\n** When an sqlite3_prepare() operation is required to access the virtual\n** table, it searches the list for the VTable that corresponds to the\n** database connection doing the preparing so as to use the correct\n** sqlite3_vtab* handle in the compiled query.\n**\n** When an in-memory Table object is deleted (for example when the\n** schema is being reloaded for some reason), the VTable objects are not\n** deleted and the sqlite3_vtab* handles are not xDisconnect()ed\n** immediately. Instead, they are moved from the Table.pVTable list to\n** another linked list headed by the sqlite3.pDisconnect member of the\n** corresponding sqlite3 structure. They are then deleted/xDisconnected\n** next time a statement is prepared using said sqlite3*. This is done\n** to avoid deadlock issues involving multiple sqlite3.mutex mutexes.\n** Refer to comments above function sqlite3VtabUnlockList() for an\n** explanation as to why it is safe to add an entry to an sqlite3.pDisconnect\n** list without holding the corresponding sqlite3.mutex mutex.\n**\n** The memory for objects of this type is always allocated by\n** sqlite3DbMalloc(), using the connection handle stored in VTable.db as\n** the first argument.\n*/\nstruct VTable {\n  sqlite3 *db;              /* Database connection associated with this table */\n  Module *pMod;             /* Pointer to module implementation */\n  sqlite3_vtab *pVtab;      /* Pointer to vtab instance */\n  int nRef;                 /* Number of pointers to this structure */\n  u8 bConstraint;           /* True if constraints are supported */\n  int iSavepoint;           /* Depth of the SAVEPOINT stack */\n  VTable *pNext;            /* Next in linked list (see above) */\n};\n\n/*\n** The schema for each SQL table and view is represented in memory\n** by an instance of the following structure.\n*/\nstruct Table {\n  char *zName;         /* Name of the table or view */\n  Column *aCol;        /* Information about each column */\n  Index *pIndex;       /* List of SQL indexes on this table. */\n  Select *pSelect;     /* NULL for tables.  Points to definition if a view. */\n  FKey *pFKey;         /* Linked list of all foreign keys in this table */\n  char *zColAff;       /* String defining the affinity of each column */\n  ExprList *pCheck;    /* All CHECK constraints */\n                       /*   ... also used as column name list in a VIEW */\n  int tnum;            /* Root BTree page for this table */\n  u32 nTabRef;         /* Number of pointers to this Table */\n  u32 tabFlags;        /* Mask of TF_* values */\n  i16 iPKey;           /* If not negative, use aCol[iPKey] as the rowid */\n  i16 nCol;            /* Number of columns in this table */\n  i16 nNVCol;          /* Number of columns that are not VIRTUAL */\n  LogEst nRowLogEst;   /* Estimated rows in table - from sqlite_stat1 table */\n  LogEst szTabRow;     /* Estimated size of each table row in bytes */\n#ifdef SQLITE_ENABLE_COSTMULT\n  LogEst costMult;     /* Cost multiplier for using this table */\n#endif\n  u8 keyConf;          /* What to do in case of uniqueness conflict on iPKey */\n#ifndef SQLITE_OMIT_ALTERTABLE\n  int addColOffset;    /* Offset in CREATE TABLE stmt to add a new column */\n#endif\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n  int nModuleArg;      /* Number of arguments to the module */\n  char **azModuleArg;  /* 0: module 1: schema 2: vtab name 3...: args */\n  VTable *pVTable;     /* List of VTable objects. */\n#endif\n  Trigger *pTrigger;   /* List of triggers stored in pSchema */\n  Schema *pSchema;     /* Schema that contains this table */\n  Table *pNextZombie;  /* Next on the Parse.pZombieTab list */\n};\n\n/*\n** Allowed values for Table.tabFlags.\n**\n** TF_OOOHidden applies to tables or view that have hidden columns that are\n** followed by non-hidden columns.  Example:  \"CREATE VIRTUAL TABLE x USING\n** vtab1(a HIDDEN, b);\".  Since \"b\" is a non-hidden column but \"a\" is hidden,\n** the TF_OOOHidden attribute would apply in this case.  Such tables require\n** special handling during INSERT processing. The \"OOO\" means \"Out Of Order\".\n**\n** Constraints:\n**\n**         TF_HasVirtual == COLFLAG_Virtual\n**         TF_HasStored  == COLFLAG_Stored\n*/\n#define TF_Readonly        0x0001    /* Read-only system table */\n#define TF_Ephemeral       0x0002    /* An ephemeral table */\n#define TF_HasPrimaryKey   0x0004    /* Table has a primary key */\n#define TF_Autoincrement   0x0008    /* Integer primary key is autoincrement */\n#define TF_HasStat1        0x0010    /* nRowLogEst set from sqlite_stat1 */\n#define TF_HasVirtual      0x0020    /* Has one or more VIRTUAL columns */\n#define TF_HasStored       0x0040    /* Has one or more STORED columns */\n#define TF_HasGenerated    0x0060    /* Combo: HasVirtual + HasStored */\n#define TF_WithoutRowid    0x0080    /* No rowid.  PRIMARY KEY is the key */\n#define TF_StatsUsed       0x0100    /* Query planner decisions affected by\n                                     ** Index.aiRowLogEst[] values */\n#define TF_NoVisibleRowid  0x0200    /* No user-visible \"rowid\" column */\n#define TF_OOOHidden       0x0400    /* Out-of-Order hidden columns */\n#define TF_HasNotNull      0x0800    /* Contains NOT NULL constraints */\n#define TF_Shadow          0x1000    /* True for a shadow table */\n\n/*\n** Test to see whether or not a table is a virtual table.  This is\n** done as a macro so that it will be optimized out when virtual\n** table support is omitted from the build.\n*/\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n#  define IsVirtual(X)      ((X)->nModuleArg)\n#else\n#  define IsVirtual(X)      0\n#endif\n\n/*\n** Macros to determine if a column is hidden.  IsOrdinaryHiddenColumn()\n** only works for non-virtual tables (ordinary tables and views) and is\n** always false unless SQLITE_ENABLE_HIDDEN_COLUMNS is defined.  The\n** IsHiddenColumn() macro is general purpose.\n*/\n#if defined(SQLITE_ENABLE_HIDDEN_COLUMNS)\n#  define IsHiddenColumn(X)         (((X)->colFlags & COLFLAG_HIDDEN)!=0)\n#  define IsOrdinaryHiddenColumn(X) (((X)->colFlags & COLFLAG_HIDDEN)!=0)\n#elif !defined(SQLITE_OMIT_VIRTUALTABLE)\n#  define IsHiddenColumn(X)         (((X)->colFlags & COLFLAG_HIDDEN)!=0)\n#  define IsOrdinaryHiddenColumn(X) 0\n#else\n#  define IsHiddenColumn(X)         0\n#  define IsOrdinaryHiddenColumn(X) 0\n#endif\n\n\n/* Does the table have a rowid */\n#define HasRowid(X)     (((X)->tabFlags & TF_WithoutRowid)==0)\n#define VisibleRowid(X) (((X)->tabFlags & TF_NoVisibleRowid)==0)\n\n/*\n** Each foreign key constraint is an instance of the following structure.\n**\n** A foreign key is associated with two tables.  The \"from\" table is\n** the table that contains the REFERENCES clause that creates the foreign\n** key.  The \"to\" table is the table that is named in the REFERENCES clause.\n** Consider this example:\n**\n**     CREATE TABLE ex1(\n**       a INTEGER PRIMARY KEY,\n**       b INTEGER CONSTRAINT fk1 REFERENCES ex2(x)\n**     );\n**\n** For foreign key \"fk1\", the from-table is \"ex1\" and the to-table is \"ex2\".\n** Equivalent names:\n**\n**     from-table == child-table\n**       to-table == parent-table\n**\n** Each REFERENCES clause generates an instance of the following structure\n** which is attached to the from-table.  The to-table need not exist when\n** the from-table is created.  The existence of the to-table is not checked.\n**\n** The list of all parents for child Table X is held at X.pFKey.\n**\n** A list of all children for a table named Z (which might not even exist)\n** is held in Schema.fkeyHash with a hash key of Z.\n*/\nstruct FKey {\n  Table *pFrom;     /* Table containing the REFERENCES clause (aka: Child) */\n  FKey *pNextFrom;  /* Next FKey with the same in pFrom. Next parent of pFrom */\n  char *zTo;        /* Name of table that the key points to (aka: Parent) */\n  FKey *pNextTo;    /* Next with the same zTo. Next child of zTo. */\n  FKey *pPrevTo;    /* Previous with the same zTo */\n  int nCol;         /* Number of columns in this key */\n  /* EV: R-30323-21917 */\n  u8 isDeferred;       /* True if constraint checking is deferred till COMMIT */\n  u8 aAction[2];        /* ON DELETE and ON UPDATE actions, respectively */\n  Trigger *apTrigger[2];/* Triggers for aAction[] actions */\n  struct sColMap {      /* Mapping of columns in pFrom to columns in zTo */\n    int iFrom;            /* Index of column in pFrom */\n    char *zCol;           /* Name of column in zTo.  If NULL use PRIMARY KEY */\n  } aCol[1];            /* One entry for each of nCol columns */\n};\n\n/*\n** SQLite supports many different ways to resolve a constraint\n** error.  ROLLBACK processing means that a constraint violation\n** causes the operation in process to fail and for the current transaction\n** to be rolled back.  ABORT processing means the operation in process\n** fails and any prior changes from that one operation are backed out,\n** but the transaction is not rolled back.  FAIL processing means that\n** the operation in progress stops and returns an error code.  But prior\n** changes due to the same operation are not backed out and no rollback\n** occurs.  IGNORE means that the particular row that caused the constraint\n** error is not inserted or updated.  Processing continues and no error\n** is returned.  REPLACE means that preexisting database rows that caused\n** a UNIQUE constraint violation are removed so that the new insert or\n** update can proceed.  Processing continues and no error is reported.\n**\n** RESTRICT, SETNULL, and CASCADE actions apply only to foreign keys.\n** RESTRICT is the same as ABORT for IMMEDIATE foreign keys and the\n** same as ROLLBACK for DEFERRED keys.  SETNULL means that the foreign\n** key is set to NULL.  CASCADE means that a DELETE or UPDATE of the\n** referenced table row is propagated into the row that holds the\n** foreign key.\n**\n** The following symbolic values are used to record which type\n** of action to take.\n*/\n#define OE_None     0   /* There is no constraint to check */\n#define OE_Rollback 1   /* Fail the operation and rollback the transaction */\n#define OE_Abort    2   /* Back out changes but do no rollback transaction */\n#define OE_Fail     3   /* Stop the operation but leave all prior changes */\n#define OE_Ignore   4   /* Ignore the error. Do not do the INSERT or UPDATE */\n#define OE_Replace  5   /* Delete existing record, then do INSERT or UPDATE */\n#define OE_Update   6   /* Process as a DO UPDATE in an upsert */\n#define OE_Restrict 7   /* OE_Abort for IMMEDIATE, OE_Rollback for DEFERRED */\n#define OE_SetNull  8   /* Set the foreign key value to NULL */\n#define OE_SetDflt  9   /* Set the foreign key value to its default */\n#define OE_Cascade  10  /* Cascade the changes */\n#define OE_Default  11  /* Do whatever the default action is */\n\n\n/*\n** An instance of the following structure is passed as the first\n** argument to sqlite3VdbeKeyCompare and is used to control the\n** comparison of the two index keys.\n**\n** Note that aSortOrder[] and aColl[] have nField+1 slots.  There\n** are nField slots for the columns of an index then one extra slot\n** for the rowid at the end.\n*/\nstruct KeyInfo {\n  u32 nRef;           /* Number of references to this KeyInfo object */\n  u8 enc;             /* Text encoding - one of the SQLITE_UTF* values */\n  u16 nKeyField;      /* Number of key columns in the index */\n  u16 nAllField;      /* Total columns, including key plus others */\n  sqlite3 *db;        /* The database connection */\n  u8 *aSortFlags;     /* Sort order for each column. */\n  CollSeq *aColl[1];  /* Collating sequence for each term of the key */\n};\n\n/*\n** Allowed bit values for entries in the KeyInfo.aSortFlags[] array.\n*/\n#define KEYINFO_ORDER_DESC    0x01    /* DESC sort order */\n#define KEYINFO_ORDER_BIGNULL 0x02    /* NULL is larger than any other value */\n\n/*\n** This object holds a record which has been parsed out into individual\n** fields, for the purposes of doing a comparison.\n**\n** A record is an object that contains one or more fields of data.\n** Records are used to store the content of a table row and to store\n** the key of an index.  A blob encoding of a record is created by\n** the OP_MakeRecord opcode of the VDBE and is disassembled by the\n** OP_Column opcode.\n**\n** An instance of this object serves as a \"key\" for doing a search on\n** an index b+tree. The goal of the search is to find the entry that\n** is closed to the key described by this object.  This object might hold\n** just a prefix of the key.  The number of fields is given by\n** pKeyInfo->nField.\n**\n** The r1 and r2 fields are the values to return if this key is less than\n** or greater than a key in the btree, respectively.  These are normally\n** -1 and +1 respectively, but might be inverted to +1 and -1 if the b-tree\n** is in DESC order.\n**\n** The key comparison functions actually return default_rc when they find\n** an equals comparison.  default_rc can be -1, 0, or +1.  If there are\n** multiple entries in the b-tree with the same key (when only looking\n** at the first pKeyInfo->nFields,) then default_rc can be set to -1 to\n** cause the search to find the last match, or +1 to cause the search to\n** find the first match.\n**\n** The key comparison functions will set eqSeen to true if they ever\n** get and equal results when comparing this structure to a b-tree record.\n** When default_rc!=0, the search might end up on the record immediately\n** before the first match or immediately after the last match.  The\n** eqSeen field will indicate whether or not an exact match exists in the\n** b-tree.\n*/\nstruct UnpackedRecord {\n  KeyInfo *pKeyInfo;  /* Collation and sort-order information */\n  Mem *aMem;          /* Values */\n  u16 nField;         /* Number of entries in apMem[] */\n  i8 default_rc;      /* Comparison result if keys are equal */\n  u8 errCode;         /* Error detected by xRecordCompare (CORRUPT or NOMEM) */\n  i8 r1;              /* Value to return if (lhs < rhs) */\n  i8 r2;              /* Value to return if (lhs > rhs) */\n  u8 eqSeen;          /* True if an equality comparison has been seen */\n};\n\n\n/*\n** Each SQL index is represented in memory by an\n** instance of the following structure.\n**\n** The columns of the table that are to be indexed are described\n** by the aiColumn[] field of this structure.  For example, suppose\n** we have the following table and index:\n**\n**     CREATE TABLE Ex1(c1 int, c2 int, c3 text);\n**     CREATE INDEX Ex2 ON Ex1(c3,c1);\n**\n** In the Table structure describing Ex1, nCol==3 because there are\n** three columns in the table.  In the Index structure describing\n** Ex2, nColumn==2 since 2 of the 3 columns of Ex1 are indexed.\n** The value of aiColumn is {2, 0}.  aiColumn[0]==2 because the\n** first column to be indexed (c3) has an index of 2 in Ex1.aCol[].\n** The second column to be indexed (c1) has an index of 0 in\n** Ex1.aCol[], hence Ex2.aiColumn[1]==0.\n**\n** The Index.onError field determines whether or not the indexed columns\n** must be unique and what to do if they are not.  When Index.onError=OE_None,\n** it means this is not a unique index.  Otherwise it is a unique index\n** and the value of Index.onError indicate the which conflict resolution\n** algorithm to employ whenever an attempt is made to insert a non-unique\n** element.\n**\n** While parsing a CREATE TABLE or CREATE INDEX statement in order to\n** generate VDBE code (as opposed to parsing one read from an sqlite_master\n** table as part of parsing an existing database schema), transient instances\n** of this structure may be created. In this case the Index.tnum variable is\n** used to store the address of a VDBE instruction, not a database page\n** number (it cannot - the database page is not allocated until the VDBE\n** program is executed). See convertToWithoutRowidTable() for details.\n*/\nstruct Index {\n  char *zName;             /* Name of this index */\n  i16 *aiColumn;           /* Which columns are used by this index.  1st is 0 */\n  LogEst *aiRowLogEst;     /* From ANALYZE: Est. rows selected by each column */\n  Table *pTable;           /* The SQL table being indexed */\n  char *zColAff;           /* String defining the affinity of each column */\n  Index *pNext;            /* The next index associated with the same table */\n  Schema *pSchema;         /* Schema containing this index */\n  u8 *aSortOrder;          /* for each column: True==DESC, False==ASC */\n  const char **azColl;     /* Array of collation sequence names for index */\n  Expr *pPartIdxWhere;     /* WHERE clause for partial indices */\n  ExprList *aColExpr;      /* Column expressions */\n  int tnum;                /* DB Page containing root of this index */\n  LogEst szIdxRow;         /* Estimated average row size in bytes */\n  u16 nKeyCol;             /* Number of columns forming the key */\n  u16 nColumn;             /* Number of columns stored in the index */\n  u8 onError;              /* OE_Abort, OE_Ignore, OE_Replace, or OE_None */\n  unsigned idxType:2;      /* 0:Normal 1:UNIQUE, 2:PRIMARY KEY, 3:IPK */\n  unsigned bUnordered:1;   /* Use this index for == or IN queries only */\n  unsigned uniqNotNull:1;  /* True if UNIQUE and NOT NULL for all columns */\n  unsigned isResized:1;    /* True if resizeIndexObject() has been called */\n  unsigned isCovering:1;   /* True if this is a covering index */\n  unsigned noSkipScan:1;   /* Do not try to use skip-scan if true */\n  unsigned hasStat1:1;     /* aiRowLogEst values come from sqlite_stat1 */\n  unsigned bNoQuery:1;     /* Do not use this index to optimize queries */\n  unsigned bAscKeyBug:1;   /* True if the bba7b69f9849b5bf bug applies */\n  unsigned bHasVCol:1;     /* Index references one or more VIRTUAL columns */\n#ifdef SQLITE_ENABLE_STAT4\n  int nSample;             /* Number of elements in aSample[] */\n  int nSampleCol;          /* Size of IndexSample.anEq[] and so on */\n  tRowcnt *aAvgEq;         /* Average nEq values for keys not in aSample */\n  IndexSample *aSample;    /* Samples of the left-most key */\n  tRowcnt *aiRowEst;       /* Non-logarithmic stat1 data for this index */\n  tRowcnt nRowEst0;        /* Non-logarithmic number of rows in the index */\n#endif\n  Bitmask colNotIdxed;     /* 0 for unindexed columns in pTab */\n};\n\n/*\n** Allowed values for Index.idxType\n*/\n#define SQLITE_IDXTYPE_APPDEF      0   /* Created using CREATE INDEX */\n#define SQLITE_IDXTYPE_UNIQUE      1   /* Implements a UNIQUE constraint */\n#define SQLITE_IDXTYPE_PRIMARYKEY  2   /* Is the PRIMARY KEY for the table */\n#define SQLITE_IDXTYPE_IPK         3   /* INTEGER PRIMARY KEY index */\n\n/* Return true if index X is a PRIMARY KEY index */\n#define IsPrimaryKeyIndex(X)  ((X)->idxType==SQLITE_IDXTYPE_PRIMARYKEY)\n\n/* Return true if index X is a UNIQUE index */\n#define IsUniqueIndex(X)      ((X)->onError!=OE_None)\n\n/* The Index.aiColumn[] values are normally positive integer.  But\n** there are some negative values that have special meaning:\n*/\n#define XN_ROWID     (-1)     /* Indexed column is the rowid */\n#define XN_EXPR      (-2)     /* Indexed column is an expression */\n\n/*\n** Each sample stored in the sqlite_stat4 table is represented in memory\n** using a structure of this type.  See documentation at the top of the\n** analyze.c source file for additional information.\n*/\nstruct IndexSample {\n  void *p;          /* Pointer to sampled record */\n  int n;            /* Size of record in bytes */\n  tRowcnt *anEq;    /* Est. number of rows where the key equals this sample */\n  tRowcnt *anLt;    /* Est. number of rows where key is less than this sample */\n  tRowcnt *anDLt;   /* Est. number of distinct keys less than this sample */\n};\n\n/*\n** Possible values to use within the flags argument to sqlite3GetToken().\n*/\n#define SQLITE_TOKEN_QUOTED    0x1 /* Token is a quoted identifier. */\n#define SQLITE_TOKEN_KEYWORD   0x2 /* Token is a keyword. */\n\n/*\n** Each token coming out of the lexer is an instance of\n** this structure.  Tokens are also used as part of an expression.\n**\n** The memory that \"z\" points to is owned by other objects.  Take care\n** that the owner of the \"z\" string does not deallocate the string before\n** the Token goes out of scope!  Very often, the \"z\" points to some place\n** in the middle of the Parse.zSql text.  But it might also point to a\n** static string.\n*/\nstruct Token {\n  const char *z;     /* Text of the token.  Not NULL-terminated! */\n  unsigned int n;    /* Number of characters in this token */\n};\n\n/*\n** An instance of this structure contains information needed to generate\n** code for a SELECT that contains aggregate functions.\n**\n** If Expr.op==TK_AGG_COLUMN or TK_AGG_FUNCTION then Expr.pAggInfo is a\n** pointer to this structure.  The Expr.iColumn field is the index in\n** AggInfo.aCol[] or AggInfo.aFunc[] of information needed to generate\n** code for that node.\n**\n** AggInfo.pGroupBy and AggInfo.aFunc.pExpr point to fields within the\n** original Select structure that describes the SELECT statement.  These\n** fields do not need to be freed when deallocating the AggInfo structure.\n*/\nstruct AggInfo {\n  u8 directMode;          /* Direct rendering mode means take data directly\n                          ** from source tables rather than from accumulators */\n  u8 useSortingIdx;       /* In direct mode, reference the sorting index rather\n                          ** than the source table */\n  int sortingIdx;         /* Cursor number of the sorting index */\n  int sortingIdxPTab;     /* Cursor number of pseudo-table */\n  int nSortingColumn;     /* Number of columns in the sorting index */\n  int mnReg, mxReg;       /* Range of registers allocated for aCol and aFunc */\n  ExprList *pGroupBy;     /* The group by clause */\n  struct AggInfo_col {    /* For each column used in source tables */\n    Table *pTab;             /* Source table */\n    int iTable;              /* Cursor number of the source table */\n    int iColumn;             /* Column number within the source table */\n    int iSorterColumn;       /* Column number in the sorting index */\n    int iMem;                /* Memory location that acts as accumulator */\n    Expr *pExpr;             /* The original expression */\n  } *aCol;\n  int nColumn;            /* Number of used entries in aCol[] */\n  int nAccumulator;       /* Number of columns that show through to the output.\n                          ** Additional columns are used only as parameters to\n                          ** aggregate functions */\n  struct AggInfo_func {   /* For each aggregate function */\n    Expr *pExpr;             /* Expression encoding the function */\n    FuncDef *pFunc;          /* The aggregate function implementation */\n    int iMem;                /* Memory location that acts as accumulator */\n    int iDistinct;           /* Ephemeral table used to enforce DISTINCT */\n  } *aFunc;\n  int nFunc;              /* Number of entries in aFunc[] */\n};\n\n/*\n** The datatype ynVar is a signed integer, either 16-bit or 32-bit.\n** Usually it is 16-bits.  But if SQLITE_MAX_VARIABLE_NUMBER is greater\n** than 32767 we have to make it 32-bit.  16-bit is preferred because\n** it uses less memory in the Expr object, which is a big memory user\n** in systems with lots of prepared statements.  And few applications\n** need more than about 10 or 20 variables.  But some extreme users want\n** to have prepared statements with over 32767 variables, and for them\n** the option is available (at compile-time).\n*/\n#if SQLITE_MAX_VARIABLE_NUMBER<=32767\ntypedef i16 ynVar;\n#else\ntypedef int ynVar;\n#endif\n\n/*\n** Each node of an expression in the parse tree is an instance\n** of this structure.\n**\n** Expr.op is the opcode. The integer parser token codes are reused\n** as opcodes here. For example, the parser defines TK_GE to be an integer\n** code representing the \">=\" operator. This same integer code is reused\n** to represent the greater-than-or-equal-to operator in the expression\n** tree.\n**\n** If the expression is an SQL literal (TK_INTEGER, TK_FLOAT, TK_BLOB,\n** or TK_STRING), then Expr.token contains the text of the SQL literal. If\n** the expression is a variable (TK_VARIABLE), then Expr.token contains the\n** variable name. Finally, if the expression is an SQL function (TK_FUNCTION),\n** then Expr.token contains the name of the function.\n**\n** Expr.pRight and Expr.pLeft are the left and right subexpressions of a\n** binary operator. Either or both may be NULL.\n**\n** Expr.x.pList is a list of arguments if the expression is an SQL function,\n** a CASE expression or an IN expression of the form \"<lhs> IN (<y>, <z>...)\".\n** Expr.x.pSelect is used if the expression is a sub-select or an expression of\n** the form \"<lhs> IN (SELECT ...)\". If the EP_xIsSelect bit is set in the\n** Expr.flags mask, then Expr.x.pSelect is valid. Otherwise, Expr.x.pList is\n** valid.\n**\n** An expression of the form ID or ID.ID refers to a column in a table.\n** For such expressions, Expr.op is set to TK_COLUMN and Expr.iTable is\n** the integer cursor number of a VDBE cursor pointing to that table and\n** Expr.iColumn is the column number for the specific column.  If the\n** expression is used as a result in an aggregate SELECT, then the\n** value is also stored in the Expr.iAgg column in the aggregate so that\n** it can be accessed after all aggregates are computed.\n**\n** If the expression is an unbound variable marker (a question mark\n** character '?' in the original SQL) then the Expr.iTable holds the index\n** number for that variable.\n**\n** If the expression is a subquery then Expr.iColumn holds an integer\n** register number containing the result of the subquery.  If the\n** subquery gives a constant result, then iTable is -1.  If the subquery\n** gives a different answer at different times during statement processing\n** then iTable is the address of a subroutine that computes the subquery.\n**\n** If the Expr is of type OP_Column, and the table it is selecting from\n** is a disk table or the \"old.*\" pseudo-table, then pTab points to the\n** corresponding table definition.\n**\n** ALLOCATION NOTES:\n**\n** Expr objects can use a lot of memory space in database schema.  To\n** help reduce memory requirements, sometimes an Expr object will be\n** truncated.  And to reduce the number of memory allocations, sometimes\n** two or more Expr objects will be stored in a single memory allocation,\n** together with Expr.zToken strings.\n**\n** If the EP_Reduced and EP_TokenOnly flags are set when\n** an Expr object is truncated.  When EP_Reduced is set, then all\n** the child Expr objects in the Expr.pLeft and Expr.pRight subtrees\n** are contained within the same memory allocation.  Note, however, that\n** the subtrees in Expr.x.pList or Expr.x.pSelect are always separately\n** allocated, regardless of whether or not EP_Reduced is set.\n*/\nstruct Expr {\n  u8 op;                 /* Operation performed by this node */\n  char affExpr;          /* affinity, or RAISE type */\n  u8 op2;                /* TK_REGISTER/TK_TRUTH: original value of Expr.op\n                         ** TK_COLUMN: the value of p5 for OP_Column\n                         ** TK_AGG_FUNCTION: nesting depth\n                         ** TK_FUNCTION: NC_SelfRef flag if needs OP_PureFunc */\n  u32 flags;             /* Various flags.  EP_* See below */\n  union {\n    char *zToken;          /* Token value. Zero terminated and dequoted */\n    int iValue;            /* Non-negative integer value if EP_IntValue */\n  } u;\n\n  /* If the EP_TokenOnly flag is set in the Expr.flags mask, then no\n  ** space is allocated for the fields below this point. An attempt to\n  ** access them will result in a segfault or malfunction.\n  *********************************************************************/\n\n  Expr *pLeft;           /* Left subnode */\n  Expr *pRight;          /* Right subnode */\n  union {\n    ExprList *pList;     /* op = IN, EXISTS, SELECT, CASE, FUNCTION, BETWEEN */\n    Select *pSelect;     /* EP_xIsSelect and op = IN, EXISTS, SELECT */\n  } x;\n\n  /* If the EP_Reduced flag is set in the Expr.flags mask, then no\n  ** space is allocated for the fields below this point. An attempt to\n  ** access them will result in a segfault or malfunction.\n  *********************************************************************/\n\n#if SQLITE_MAX_EXPR_DEPTH>0\n  int nHeight;           /* Height of the tree headed by this node */\n#endif\n  int iTable;            /* TK_COLUMN: cursor number of table holding column\n                         ** TK_REGISTER: register number\n                         ** TK_TRIGGER: 1 -> new, 0 -> old\n                         ** EP_Unlikely:  134217728 times likelihood\n                         ** TK_IN: ephemerial table holding RHS\n                         ** TK_SELECT_COLUMN: Number of columns on the LHS\n                         ** TK_SELECT: 1st register of result vector */\n  ynVar iColumn;         /* TK_COLUMN: column index.  -1 for rowid.\n                         ** TK_VARIABLE: variable number (always >= 1).\n                         ** TK_SELECT_COLUMN: column of the result vector */\n  i16 iAgg;              /* Which entry in pAggInfo->aCol[] or ->aFunc[] */\n  i16 iRightJoinTable;   /* If EP_FromJoin, the right table of the join */\n  AggInfo *pAggInfo;     /* Used by TK_AGG_COLUMN and TK_AGG_FUNCTION */\n  union {\n    Table *pTab;           /* TK_COLUMN: Table containing column. Can be NULL\n                           ** for a column of an index on an expression */\n    Window *pWin;          /* EP_WinFunc: Window/Filter defn for a function */\n    struct {               /* TK_IN, TK_SELECT, and TK_EXISTS */\n      int iAddr;             /* Subroutine entry address */\n      int regReturn;         /* Register used to hold return address */\n    } sub;\n  } y;\n};\n\n/*\n** The following are the meanings of bits in the Expr.flags field.\n** Value restrictions:\n**\n**          EP_Agg == NC_HasAgg == SF_HasAgg\n**          EP_Win == NC_HasWin\n*/\n#define EP_FromJoin   0x000001 /* Originates in ON/USING clause of outer join */\n#define EP_Distinct   0x000002 /* Aggregate function with DISTINCT keyword */\n#define EP_HasFunc    0x000004 /* Contains one or more functions of any kind */\n#define EP_FixedCol   0x000008 /* TK_Column with a known fixed value */\n#define EP_Agg        0x000010 /* Contains one or more aggregate functions */\n#define EP_VarSelect  0x000020 /* pSelect is correlated, not constant */\n#define EP_DblQuoted  0x000040 /* token.z was originally in \"...\" */\n#define EP_InfixFunc  0x000080 /* True for an infix function: LIKE, GLOB, etc */\n#define EP_Collate    0x000100 /* Tree contains a TK_COLLATE operator */\n#define EP_Commuted   0x000200 /* Comparison operator has been commuted */\n#define EP_IntValue   0x000400 /* Integer value contained in u.iValue */\n#define EP_xIsSelect  0x000800 /* x.pSelect is valid (otherwise x.pList is) */\n#define EP_Skip       0x001000 /* Operator does not contribute to affinity */\n#define EP_Reduced    0x002000 /* Expr struct EXPR_REDUCEDSIZE bytes only */\n#define EP_TokenOnly  0x004000 /* Expr struct EXPR_TOKENONLYSIZE bytes only */\n#define EP_Win        0x008000 /* Contains window functions */\n#define EP_MemToken   0x010000 /* Need to sqlite3DbFree() Expr.zToken */\n#define EP_NoReduce   0x020000 /* Cannot EXPRDUP_REDUCE this Expr */\n#define EP_Unlikely   0x040000 /* unlikely() or likelihood() function */\n#define EP_ConstFunc  0x080000 /* A SQLITE_FUNC_CONSTANT or _SLOCHNG function */\n#define EP_CanBeNull  0x100000 /* Can be null despite NOT NULL constraint */\n#define EP_Subquery   0x200000 /* Tree contains a TK_SELECT operator */\n#define EP_Alias      0x400000 /* Is an alias for a result set column */\n#define EP_Leaf       0x800000 /* Expr.pLeft, .pRight, .u.pSelect all NULL */\n#define EP_WinFunc   0x1000000 /* TK_FUNCTION with Expr.y.pWin set */\n#define EP_Subrtn    0x2000000 /* Uses Expr.y.sub. TK_IN, _SELECT, or _EXISTS */\n#define EP_Quoted    0x4000000 /* TK_ID was originally quoted */\n#define EP_Static    0x8000000 /* Held in memory not obtained from malloc() */\n#define EP_IsTrue   0x10000000 /* Always has boolean value of TRUE */\n#define EP_IsFalse  0x20000000 /* Always has boolean value of FALSE */\n#define EP_Indirect 0x40000000 /* Contained within a TRIGGER or a VIEW */\n\n/*\n** The EP_Propagate mask is a set of properties that automatically propagate\n** upwards into parent nodes.\n*/\n#define EP_Propagate (EP_Collate|EP_Subquery|EP_HasFunc)\n\n/*\n** These macros can be used to test, set, or clear bits in the\n** Expr.flags field.\n*/\n#define ExprHasProperty(E,P)     (((E)->flags&(P))!=0)\n#define ExprHasAllProperty(E,P)  (((E)->flags&(P))==(P))\n#define ExprSetProperty(E,P)     (E)->flags|=(P)\n#define ExprClearProperty(E,P)   (E)->flags&=~(P)\n#define ExprAlwaysTrue(E)   (((E)->flags&(EP_FromJoin|EP_IsTrue))==EP_IsTrue)\n#define ExprAlwaysFalse(E)  (((E)->flags&(EP_FromJoin|EP_IsFalse))==EP_IsFalse)\n\n/* The ExprSetVVAProperty() macro is used for Verification, Validation,\n** and Accreditation only.  It works like ExprSetProperty() during VVA\n** processes but is a no-op for delivery.\n*/\n#ifdef SQLITE_DEBUG\n# define ExprSetVVAProperty(E,P)  (E)->flags|=(P)\n#else\n# define ExprSetVVAProperty(E,P)\n#endif\n\n/*\n** Macros to determine the number of bytes required by a normal Expr\n** struct, an Expr struct with the EP_Reduced flag set in Expr.flags\n** and an Expr struct with the EP_TokenOnly flag set.\n*/\n#define EXPR_FULLSIZE           sizeof(Expr)           /* Full size */\n#define EXPR_REDUCEDSIZE        offsetof(Expr,iTable)  /* Common features */\n#define EXPR_TOKENONLYSIZE      offsetof(Expr,pLeft)   /* Fewer features */\n\n/*\n** Flags passed to the sqlite3ExprDup() function. See the header comment\n** above sqlite3ExprDup() for details.\n*/\n#define EXPRDUP_REDUCE         0x0001  /* Used reduced-size Expr nodes */\n\n/*\n** True if the expression passed as an argument was a function with\n** an OVER() clause (a window function).\n*/\n#ifdef SQLITE_OMIT_WINDOWFUNC\n# define IsWindowFunc(p) 0\n#else\n# define IsWindowFunc(p) ( \\\n    ExprHasProperty((p), EP_WinFunc) && p->y.pWin->eFrmType!=TK_FILTER \\\n )\n#endif\n\n/*\n** A list of expressions.  Each expression may optionally have a\n** name.  An expr/name combination can be used in several ways, such\n** as the list of \"expr AS ID\" fields following a \"SELECT\" or in the\n** list of \"ID = expr\" items in an UPDATE.  A list of expressions can\n** also be used as the argument to a function, in which case the a.zName\n** field is not used.\n**\n** By default the Expr.zSpan field holds a human-readable description of\n** the expression that is used in the generation of error messages and\n** column labels.  In this case, Expr.zSpan is typically the text of a\n** column expression as it exists in a SELECT statement.  However, if\n** the bSpanIsTab flag is set, then zSpan is overloaded to mean the name\n** of the result column in the form: DATABASE.TABLE.COLUMN.  This later\n** form is used for name resolution with nested FROM clauses.\n*/\nstruct ExprList {\n  int nExpr;             /* Number of expressions on the list */\n  struct ExprList_item { /* For each expression in the list */\n    Expr *pExpr;            /* The parse tree for this expression */\n    char *zName;            /* Token associated with this expression */\n    char *zSpan;            /* Original text of the expression */\n    u8 sortFlags;           /* Mask of KEYINFO_ORDER_* flags */\n    unsigned done :1;       /* A flag to indicate when processing is finished */\n    unsigned bSpanIsTab :1; /* zSpan holds DB.TABLE.COLUMN */\n    unsigned reusable :1;   /* Constant expression is reusable */\n    unsigned bSorterRef :1; /* Defer evaluation until after sorting */\n    unsigned bNulls: 1;     /* True if explicit \"NULLS FIRST/LAST\" */\n    union {\n      struct {\n        u16 iOrderByCol;      /* For ORDER BY, column number in result set */\n        u16 iAlias;           /* Index into Parse.aAlias[] for zName */\n      } x;\n      int iConstExprReg;      /* Register in which Expr value is cached */\n    } u;\n  } a[1];                  /* One slot for each expression in the list */\n};\n\n/*\n** An instance of this structure can hold a simple list of identifiers,\n** such as the list \"a,b,c\" in the following statements:\n**\n**      INSERT INTO t(a,b,c) VALUES ...;\n**      CREATE INDEX idx ON t(a,b,c);\n**      CREATE TRIGGER trig BEFORE UPDATE ON t(a,b,c) ...;\n**\n** The IdList.a.idx field is used when the IdList represents the list of\n** column names after a table name in an INSERT statement.  In the statement\n**\n**     INSERT INTO t(a,b,c) ...\n**\n** If \"a\" is the k-th column of table \"t\", then IdList.a[0].idx==k.\n*/\nstruct IdList {\n  struct IdList_item {\n    char *zName;      /* Name of the identifier */\n    int idx;          /* Index in some Table.aCol[] of a column named zName */\n  } *a;\n  int nId;         /* Number of identifiers on the list */\n};\n\n/*\n** The following structure describes the FROM clause of a SELECT statement.\n** Each table or subquery in the FROM clause is a separate element of\n** the SrcList.a[] array.\n**\n** With the addition of multiple database support, the following structure\n** can also be used to describe a particular table such as the table that\n** is modified by an INSERT, DELETE, or UPDATE statement.  In standard SQL,\n** such a table must be a simple name: ID.  But in SQLite, the table can\n** now be identified by a database name, a dot, then the table name: ID.ID.\n**\n** The jointype starts out showing the join type between the current table\n** and the next table on the list.  The parser builds the list this way.\n** But sqlite3SrcListShiftJoinType() later shifts the jointypes so that each\n** jointype expresses the join between the table and the previous table.\n**\n** In the colUsed field, the high-order bit (bit 63) is set if the table\n** contains more than 63 columns and the 64-th or later column is used.\n*/\nstruct SrcList {\n  int nSrc;        /* Number of tables or subqueries in the FROM clause */\n  u32 nAlloc;      /* Number of entries allocated in a[] below */\n  struct SrcList_item {\n    Schema *pSchema;  /* Schema to which this item is fixed */\n    char *zDatabase;  /* Name of database holding this table */\n    char *zName;      /* Name of the table */\n    char *zAlias;     /* The \"B\" part of a \"A AS B\" phrase.  zName is the \"A\" */\n    Table *pTab;      /* An SQL table corresponding to zName */\n    Select *pSelect;  /* A SELECT statement used in place of a table name */\n    int addrFillSub;  /* Address of subroutine to manifest a subquery */\n    int regReturn;    /* Register holding return address of addrFillSub */\n    int regResult;    /* Registers holding results of a co-routine */\n    struct {\n      u8 jointype;      /* Type of join between this table and the previous */\n      unsigned notIndexed :1;    /* True if there is a NOT INDEXED clause */\n      unsigned isIndexedBy :1;   /* True if there is an INDEXED BY clause */\n      unsigned isTabFunc :1;     /* True if table-valued-function syntax */\n      unsigned isCorrelated :1;  /* True if sub-query is correlated */\n      unsigned viaCoroutine :1;  /* Implemented as a co-routine */\n      unsigned isRecursive :1;   /* True for recursive reference in WITH */\n    } fg;\n    int iCursor;      /* The VDBE cursor number used to access this table */\n    Expr *pOn;        /* The ON clause of a join */\n    IdList *pUsing;   /* The USING clause of a join */\n    Bitmask colUsed;  /* Bit N (1<<N) set if column N of pTab is used */\n    union {\n      char *zIndexedBy;    /* Identifier from \"INDEXED BY <zIndex>\" clause */\n      ExprList *pFuncArg;  /* Arguments to table-valued-function */\n    } u1;\n    Index *pIBIndex;  /* Index structure corresponding to u1.zIndexedBy */\n  } a[1];             /* One entry for each identifier on the list */\n};\n\n/*\n** Permitted values of the SrcList.a.jointype field\n*/\n#define JT_INNER     0x0001    /* Any kind of inner or cross join */\n#define JT_CROSS     0x0002    /* Explicit use of the CROSS keyword */\n#define JT_NATURAL   0x0004    /* True for a \"natural\" join */\n#define JT_LEFT      0x0008    /* Left outer join */\n#define JT_RIGHT     0x0010    /* Right outer join */\n#define JT_OUTER     0x0020    /* The \"OUTER\" keyword is present */\n#define JT_ERROR     0x0040    /* unknown or unsupported join type */\n\n\n/*\n** Flags appropriate for the wctrlFlags parameter of sqlite3WhereBegin()\n** and the WhereInfo.wctrlFlags member.\n**\n** Value constraints (enforced via assert()):\n**     WHERE_USE_LIMIT  == SF_FixedLimit\n*/\n#define WHERE_ORDERBY_NORMAL   0x0000 /* No-op */\n#define WHERE_ORDERBY_MIN      0x0001 /* ORDER BY processing for min() func */\n#define WHERE_ORDERBY_MAX      0x0002 /* ORDER BY processing for max() func */\n#define WHERE_ONEPASS_DESIRED  0x0004 /* Want to do one-pass UPDATE/DELETE */\n#define WHERE_ONEPASS_MULTIROW 0x0008 /* ONEPASS is ok with multiple rows */\n#define WHERE_DUPLICATES_OK    0x0010 /* Ok to return a row more than once */\n#define WHERE_OR_SUBCLAUSE     0x0020 /* Processing a sub-WHERE as part of\n                                      ** the OR optimization  */\n#define WHERE_GROUPBY          0x0040 /* pOrderBy is really a GROUP BY */\n#define WHERE_DISTINCTBY       0x0080 /* pOrderby is really a DISTINCT clause */\n#define WHERE_WANT_DISTINCT    0x0100 /* All output needs to be distinct */\n#define WHERE_SORTBYGROUP      0x0200 /* Support sqlite3WhereIsSorted() */\n#define WHERE_SEEK_TABLE       0x0400 /* Do not defer seeks on main table */\n#define WHERE_ORDERBY_LIMIT    0x0800 /* ORDERBY+LIMIT on the inner loop */\n#define WHERE_SEEK_UNIQ_TABLE  0x1000 /* Do not defer seeks if unique */\n                        /*     0x2000    not currently used */\n#define WHERE_USE_LIMIT        0x4000 /* Use the LIMIT in cost estimates */\n                        /*     0x8000    not currently used */\n\n/* Allowed return values from sqlite3WhereIsDistinct()\n*/\n#define WHERE_DISTINCT_NOOP      0  /* DISTINCT keyword not used */\n#define WHERE_DISTINCT_UNIQUE    1  /* No duplicates */\n#define WHERE_DISTINCT_ORDERED   2  /* All duplicates are adjacent */\n#define WHERE_DISTINCT_UNORDERED 3  /* Duplicates are scattered */\n\n/*\n** A NameContext defines a context in which to resolve table and column\n** names.  The context consists of a list of tables (the pSrcList) field and\n** a list of named expression (pEList).  The named expression list may\n** be NULL.  The pSrc corresponds to the FROM clause of a SELECT or\n** to the table being operated on by INSERT, UPDATE, or DELETE.  The\n** pEList corresponds to the result set of a SELECT and is NULL for\n** other statements.\n**\n** NameContexts can be nested.  When resolving names, the inner-most\n** context is searched first.  If no match is found, the next outer\n** context is checked.  If there is still no match, the next context\n** is checked.  This process continues until either a match is found\n** or all contexts are check.  When a match is found, the nRef member of\n** the context containing the match is incremented.\n**\n** Each subquery gets a new NameContext.  The pNext field points to the\n** NameContext in the parent query.  Thus the process of scanning the\n** NameContext list corresponds to searching through successively outer\n** subqueries looking for a match.\n*/\nstruct NameContext {\n  Parse *pParse;       /* The parser */\n  SrcList *pSrcList;   /* One or more tables used to resolve names */\n  union {\n    ExprList *pEList;    /* Optional list of result-set columns */\n    AggInfo *pAggInfo;   /* Information about aggregates at this level */\n    Upsert *pUpsert;     /* ON CONFLICT clause information from an upsert */\n  } uNC;\n  NameContext *pNext;  /* Next outer name context.  NULL for outermost */\n  int nRef;            /* Number of names resolved by this context */\n  int nErr;            /* Number of errors encountered while resolving names */\n  int ncFlags;         /* Zero or more NC_* flags defined below */\n  Select *pWinSelect;  /* SELECT statement for any window functions */\n};\n\n/*\n** Allowed values for the NameContext, ncFlags field.\n**\n** Value constraints (all checked via assert()):\n**    NC_HasAgg    == SF_HasAgg    == EP_Agg\n**    NC_MinMaxAgg == SF_MinMaxAgg == SQLITE_FUNC_MINMAX\n**    NC_HasWin    == EP_Win\n**\n*/\n#define NC_AllowAgg  0x00001  /* Aggregate functions are allowed here */\n#define NC_PartIdx   0x00002  /* True if resolving a partial index WHERE */\n#define NC_IsCheck   0x00004  /* True if resolving a CHECK constraint */\n#define NC_GenCol    0x00008  /* True for a GENERATED ALWAYS AS clause */\n#define NC_HasAgg    0x00010  /* One or more aggregate functions seen */\n#define NC_IdxExpr   0x00020  /* True if resolving columns of CREATE INDEX */\n#define NC_SelfRef   0x0002e  /* Combo: PartIdx, isCheck, GenCol, and IdxExpr */\n#define NC_VarSelect 0x00040  /* A correlated subquery has been seen */\n#define NC_UEList    0x00080  /* True if uNC.pEList is used */\n#define NC_UAggInfo  0x00100  /* True if uNC.pAggInfo is used */\n#define NC_UUpsert   0x00200  /* True if uNC.pUpsert is used */\n#define NC_MinMaxAgg 0x01000  /* min/max aggregates seen.  See note above */\n#define NC_Complex   0x02000  /* True if a function or subquery seen */\n#define NC_AllowWin  0x04000  /* Window functions are allowed here */\n#define NC_HasWin    0x08000  /* One or more window functions seen */\n#define NC_IsDDL     0x10000  /* Resolving names in a CREATE statement */\n#define NC_InAggFunc 0x20000  /* True if analyzing arguments to an agg func */\n\n/*\n** An instance of the following object describes a single ON CONFLICT\n** clause in an upsert.\n**\n** The pUpsertTarget field is only set if the ON CONFLICT clause includes\n** conflict-target clause.  (In \"ON CONFLICT(a,b)\" the \"(a,b)\" is the\n** conflict-target clause.)  The pUpsertTargetWhere is the optional\n** WHERE clause used to identify partial unique indexes.\n**\n** pUpsertSet is the list of column=expr terms of the UPDATE statement. \n** The pUpsertSet field is NULL for a ON CONFLICT DO NOTHING.  The\n** pUpsertWhere is the WHERE clause for the UPDATE and is NULL if the\n** WHERE clause is omitted.\n*/\nstruct Upsert {\n  ExprList *pUpsertTarget;  /* Optional description of conflicting index */\n  Expr *pUpsertTargetWhere; /* WHERE clause for partial index targets */\n  ExprList *pUpsertSet;     /* The SET clause from an ON CONFLICT UPDATE */\n  Expr *pUpsertWhere;       /* WHERE clause for the ON CONFLICT UPDATE */\n  /* The fields above comprise the parse tree for the upsert clause.\n  ** The fields below are used to transfer information from the INSERT\n  ** processing down into the UPDATE processing while generating code.\n  ** Upsert owns the memory allocated above, but not the memory below. */\n  Index *pUpsertIdx;        /* Constraint that pUpsertTarget identifies */\n  SrcList *pUpsertSrc;      /* Table to be updated */\n  int regData;              /* First register holding array of VALUES */\n  int iDataCur;             /* Index of the data cursor */\n  int iIdxCur;              /* Index of the first index cursor */\n};\n\n/*\n** An instance of the following structure contains all information\n** needed to generate code for a single SELECT statement.\n**\n** See the header comment on the computeLimitRegisters() routine for a\n** detailed description of the meaning of the iLimit and iOffset fields.\n**\n** addrOpenEphm[] entries contain the address of OP_OpenEphemeral opcodes.\n** These addresses must be stored so that we can go back and fill in\n** the P4_KEYINFO and P2 parameters later.  Neither the KeyInfo nor\n** the number of columns in P2 can be computed at the same time\n** as the OP_OpenEphm instruction is coded because not\n** enough information about the compound query is known at that point.\n** The KeyInfo for addrOpenTran[0] and [1] contains collating sequences\n** for the result set.  The KeyInfo for addrOpenEphm[2] contains collating\n** sequences for the ORDER BY clause.\n*/\nstruct Select {\n  ExprList *pEList;      /* The fields of the result */\n  u8 op;                 /* One of: TK_UNION TK_ALL TK_INTERSECT TK_EXCEPT */\n  LogEst nSelectRow;     /* Estimated number of result rows */\n  u32 selFlags;          /* Various SF_* values */\n  int iLimit, iOffset;   /* Memory registers holding LIMIT & OFFSET counters */\n  u32 selId;             /* Unique identifier number for this SELECT */\n  int addrOpenEphm[2];   /* OP_OpenEphem opcodes related to this select */\n  SrcList *pSrc;         /* The FROM clause */\n  Expr *pWhere;          /* The WHERE clause */\n  ExprList *pGroupBy;    /* The GROUP BY clause */\n  Expr *pHaving;         /* The HAVING clause */\n  ExprList *pOrderBy;    /* The ORDER BY clause */\n  Select *pPrior;        /* Prior select in a compound select statement */\n  Select *pNext;         /* Next select to the left in a compound */\n  Expr *pLimit;          /* LIMIT expression. NULL means not used. */\n  With *pWith;           /* WITH clause attached to this select. Or NULL. */\n#ifndef SQLITE_OMIT_WINDOWFUNC\n  Window *pWin;          /* List of window functions */\n  Window *pWinDefn;      /* List of named window definitions */\n#endif\n};\n\n/*\n** Allowed values for Select.selFlags.  The \"SF\" prefix stands for\n** \"Select Flag\".\n**\n** Value constraints (all checked via assert())\n**     SF_HasAgg     == NC_HasAgg\n**     SF_MinMaxAgg  == NC_MinMaxAgg     == SQLITE_FUNC_MINMAX\n**     SF_FixedLimit == WHERE_USE_LIMIT\n*/\n#define SF_Distinct      0x0000001 /* Output should be DISTINCT */\n#define SF_All           0x0000002 /* Includes the ALL keyword */\n#define SF_Resolved      0x0000004 /* Identifiers have been resolved */\n#define SF_Aggregate     0x0000008 /* Contains agg functions or a GROUP BY */\n#define SF_HasAgg        0x0000010 /* Contains aggregate functions */\n#define SF_UsesEphemeral 0x0000020 /* Uses the OpenEphemeral opcode */\n#define SF_Expanded      0x0000040 /* sqlite3SelectExpand() called on this */\n#define SF_HasTypeInfo   0x0000080 /* FROM subqueries have Table metadata */\n#define SF_Compound      0x0000100 /* Part of a compound query */\n#define SF_Values        0x0000200 /* Synthesized from VALUES clause */\n#define SF_MultiValue    0x0000400 /* Single VALUES term with multiple rows */\n#define SF_NestedFrom    0x0000800 /* Part of a parenthesized FROM clause */\n#define SF_MinMaxAgg     0x0001000 /* Aggregate containing min() or max() */\n#define SF_Recursive     0x0002000 /* The recursive part of a recursive CTE */\n#define SF_FixedLimit    0x0004000 /* nSelectRow set by a constant LIMIT */\n#define SF_MaybeConvert  0x0008000 /* Need convertCompoundSelectToSubquery() */\n#define SF_Converted     0x0010000 /* By convertCompoundSelectToSubquery() */\n#define SF_IncludeHidden 0x0020000 /* Include hidden columns in output */\n#define SF_ComplexResult 0x0040000 /* Result contains subquery or function */\n#define SF_WhereBegin    0x0080000 /* Really a WhereBegin() call.  Debug Only */\n#define SF_WinRewrite    0x0100000 /* Window function rewrite accomplished */\n\n/*\n** The results of a SELECT can be distributed in several ways, as defined\n** by one of the following macros.  The \"SRT\" prefix means \"SELECT Result\n** Type\".\n**\n**     SRT_Union       Store results as a key in a temporary index\n**                     identified by pDest->iSDParm.\n**\n**     SRT_Except      Remove results from the temporary index pDest->iSDParm.\n**\n**     SRT_Exists      Store a 1 in memory cell pDest->iSDParm if the result\n**                     set is not empty.\n**\n**     SRT_Discard     Throw the results away.  This is used by SELECT\n**                     statements within triggers whose only purpose is\n**                     the side-effects of functions.\n**\n** All of the above are free to ignore their ORDER BY clause. Those that\n** follow must honor the ORDER BY clause.\n**\n**     SRT_Output      Generate a row of output (using the OP_ResultRow\n**                     opcode) for each row in the result set.\n**\n**     SRT_Mem         Only valid if the result is a single column.\n**                     Store the first column of the first result row\n**                     in register pDest->iSDParm then abandon the rest\n**                     of the query.  This destination implies \"LIMIT 1\".\n**\n**     SRT_Set         The result must be a single column.  Store each\n**                     row of result as the key in table pDest->iSDParm.\n**                     Apply the affinity pDest->affSdst before storing\n**                     results.  Used to implement \"IN (SELECT ...)\".\n**\n**     SRT_EphemTab    Create an temporary table pDest->iSDParm and store\n**                     the result there. The cursor is left open after\n**                     returning.  This is like SRT_Table except that\n**                     this destination uses OP_OpenEphemeral to create\n**                     the table first.\n**\n**     SRT_Coroutine   Generate a co-routine that returns a new row of\n**                     results each time it is invoked.  The entry point\n**                     of the co-routine is stored in register pDest->iSDParm\n**                     and the result row is stored in pDest->nDest registers\n**                     starting with pDest->iSdst.\n**\n**     SRT_Table       Store results in temporary table pDest->iSDParm.\n**     SRT_Fifo        This is like SRT_EphemTab except that the table\n**                     is assumed to already be open.  SRT_Fifo has\n**                     the additional property of being able to ignore\n**                     the ORDER BY clause.\n**\n**     SRT_DistFifo    Store results in a temporary table pDest->iSDParm.\n**                     But also use temporary table pDest->iSDParm+1 as\n**                     a record of all prior results and ignore any duplicate\n**                     rows.  Name means:  \"Distinct Fifo\".\n**\n**     SRT_Queue       Store results in priority queue pDest->iSDParm (really\n**                     an index).  Append a sequence number so that all entries\n**                     are distinct.\n**\n**     SRT_DistQueue   Store results in priority queue pDest->iSDParm only if\n**                     the same record has never been stored before.  The\n**                     index at pDest->iSDParm+1 hold all prior stores.\n*/\n#define SRT_Union        1  /* Store result as keys in an index */\n#define SRT_Except       2  /* Remove result from a UNION index */\n#define SRT_Exists       3  /* Store 1 if the result is not empty */\n#define SRT_Discard      4  /* Do not save the results anywhere */\n#define SRT_Fifo         5  /* Store result as data with an automatic rowid */\n#define SRT_DistFifo     6  /* Like SRT_Fifo, but unique results only */\n#define SRT_Queue        7  /* Store result in an queue */\n#define SRT_DistQueue    8  /* Like SRT_Queue, but unique results only */\n\n/* The ORDER BY clause is ignored for all of the above */\n#define IgnorableOrderby(X) ((X->eDest)<=SRT_DistQueue)\n\n#define SRT_Output       9  /* Output each row of result */\n#define SRT_Mem         10  /* Store result in a memory cell */\n#define SRT_Set         11  /* Store results as keys in an index */\n#define SRT_EphemTab    12  /* Create transient tab and store like SRT_Table */\n#define SRT_Coroutine   13  /* Generate a single row of result */\n#define SRT_Table       14  /* Store result as data with an automatic rowid */\n\n/*\n** An instance of this object describes where to put of the results of\n** a SELECT statement.\n*/\nstruct SelectDest {\n  u8 eDest;            /* How to dispose of the results.  On of SRT_* above. */\n  int iSDParm;         /* A parameter used by the eDest disposal method */\n  int iSdst;           /* Base register where results are written */\n  int nSdst;           /* Number of registers allocated */\n  char *zAffSdst;      /* Affinity used when eDest==SRT_Set */\n  ExprList *pOrderBy;  /* Key columns for SRT_Queue and SRT_DistQueue */\n};\n\n/*\n** During code generation of statements that do inserts into AUTOINCREMENT\n** tables, the following information is attached to the Table.u.autoInc.p\n** pointer of each autoincrement table to record some side information that\n** the code generator needs.  We have to keep per-table autoincrement\n** information in case inserts are done within triggers.  Triggers do not\n** normally coordinate their activities, but we do need to coordinate the\n** loading and saving of autoincrement information.\n*/\nstruct AutoincInfo {\n  AutoincInfo *pNext;   /* Next info block in a list of them all */\n  Table *pTab;          /* Table this info block refers to */\n  int iDb;              /* Index in sqlite3.aDb[] of database holding pTab */\n  int regCtr;           /* Memory register holding the rowid counter */\n};\n\n/*\n** At least one instance of the following structure is created for each\n** trigger that may be fired while parsing an INSERT, UPDATE or DELETE\n** statement. All such objects are stored in the linked list headed at\n** Parse.pTriggerPrg and deleted once statement compilation has been\n** completed.\n**\n** A Vdbe sub-program that implements the body and WHEN clause of trigger\n** TriggerPrg.pTrigger, assuming a default ON CONFLICT clause of\n** TriggerPrg.orconf, is stored in the TriggerPrg.pProgram variable.\n** The Parse.pTriggerPrg list never contains two entries with the same\n** values for both pTrigger and orconf.\n**\n** The TriggerPrg.aColmask[0] variable is set to a mask of old.* columns\n** accessed (or set to 0 for triggers fired as a result of INSERT\n** statements). Similarly, the TriggerPrg.aColmask[1] variable is set to\n** a mask of new.* columns used by the program.\n*/\nstruct TriggerPrg {\n  Trigger *pTrigger;      /* Trigger this program was coded from */\n  TriggerPrg *pNext;      /* Next entry in Parse.pTriggerPrg list */\n  SubProgram *pProgram;   /* Program implementing pTrigger/orconf */\n  int orconf;             /* Default ON CONFLICT policy */\n  u32 aColmask[2];        /* Masks of old.*, new.* columns accessed */\n};\n\n/*\n** The yDbMask datatype for the bitmask of all attached databases.\n*/\n#if SQLITE_MAX_ATTACHED>30\n  typedef unsigned char yDbMask[(SQLITE_MAX_ATTACHED+9)/8];\n# define DbMaskTest(M,I)    (((M)[(I)/8]&(1<<((I)&7)))!=0)\n# define DbMaskZero(M)      memset((M),0,sizeof(M))\n# define DbMaskSet(M,I)     (M)[(I)/8]|=(1<<((I)&7))\n# define DbMaskAllZero(M)   sqlite3DbMaskAllZero(M)\n# define DbMaskNonZero(M)   (sqlite3DbMaskAllZero(M)==0)\n#else\n  typedef unsigned int yDbMask;\n# define DbMaskTest(M,I)    (((M)&(((yDbMask)1)<<(I)))!=0)\n# define DbMaskZero(M)      (M)=0\n# define DbMaskSet(M,I)     (M)|=(((yDbMask)1)<<(I))\n# define DbMaskAllZero(M)   (M)==0\n# define DbMaskNonZero(M)   (M)!=0\n#endif\n\n/*\n** An SQL parser context.  A copy of this structure is passed through\n** the parser and down into all the parser action routine in order to\n** carry around information that is global to the entire parse.\n**\n** The structure is divided into two parts.  When the parser and code\n** generate call themselves recursively, the first part of the structure\n** is constant but the second part is reset at the beginning and end of\n** each recursion.\n**\n** The nTableLock and aTableLock variables are only used if the shared-cache\n** feature is enabled (if sqlite3Tsd()->useSharedData is true). They are\n** used to store the set of table-locks required by the statement being\n** compiled. Function sqlite3TableLock() is used to add entries to the\n** list.\n*/\nstruct Parse {\n  sqlite3 *db;         /* The main database structure */\n  char *zErrMsg;       /* An error message */\n  Vdbe *pVdbe;         /* An engine for executing database bytecode */\n  int rc;              /* Return code from execution */\n  u8 colNamesSet;      /* TRUE after OP_ColumnName has been issued to pVdbe */\n  u8 checkSchema;      /* Causes schema cookie check after an error */\n  u8 nested;           /* Number of nested calls to the parser/code generator */\n  u8 nTempReg;         /* Number of temporary registers in aTempReg[] */\n  u8 isMultiWrite;     /* True if statement may modify/insert multiple rows */\n  u8 mayAbort;         /* True if statement may throw an ABORT exception */\n  u8 hasCompound;      /* Need to invoke convertCompoundSelectToSubquery() */\n  u8 okConstFactor;    /* OK to factor out constants */\n  u8 disableLookaside; /* Number of times lookaside has been disabled */\n  u8 disableVtab;      /* Disable all virtual tables for this parse */\n  int nRangeReg;       /* Size of the temporary register block */\n  int iRangeReg;       /* First register in temporary register block */\n  int nErr;            /* Number of errors seen */\n  int nTab;            /* Number of previously allocated VDBE cursors */\n  int nMem;            /* Number of memory cells used so far */\n  int szOpAlloc;       /* Bytes of memory space allocated for Vdbe.aOp[] */\n  int iSelfTab;        /* Table associated with an index on expr, or negative\n                       ** of the base register during check-constraint eval */\n  int nLabel;          /* The *negative* of the number of labels used */\n  int nLabelAlloc;     /* Number of slots in aLabel */\n  int *aLabel;         /* Space to hold the labels */\n  ExprList *pConstExpr;/* Constant expressions */\n  Token constraintName;/* Name of the constraint currently being parsed */\n  yDbMask writeMask;   /* Start a write transaction on these databases */\n  yDbMask cookieMask;  /* Bitmask of schema verified databases */\n  int regRowid;        /* Register holding rowid of CREATE TABLE entry */\n  int regRoot;         /* Register holding root page number for new objects */\n  int nMaxArg;         /* Max args passed to user function by sub-program */\n  int nSelect;         /* Number of SELECT stmts. Counter for Select.selId */\n#ifndef SQLITE_OMIT_SHARED_CACHE\n  int nTableLock;        /* Number of locks in aTableLock */\n  TableLock *aTableLock; /* Required table locks for shared-cache mode */\n#endif\n  AutoincInfo *pAinc;  /* Information about AUTOINCREMENT counters */\n  Parse *pToplevel;    /* Parse structure for main program (or NULL) */\n  Table *pTriggerTab;  /* Table triggers are being coded for */\n  Parse *pParentParse; /* Parent parser if this parser is nested */\n  int addrCrTab;       /* Address of OP_CreateBtree opcode on CREATE TABLE */\n  u32 nQueryLoop;      /* Est number of iterations of a query (10*log2(N)) */\n  u32 oldmask;         /* Mask of old.* columns referenced */\n  u32 newmask;         /* Mask of new.* columns referenced */\n  u8 eTriggerOp;       /* TK_UPDATE, TK_INSERT or TK_DELETE */\n  u8 eOrconf;          /* Default ON CONFLICT policy for trigger steps */\n  u8 disableTriggers;  /* True to disable triggers */\n\n  /**************************************************************************\n  ** Fields above must be initialized to zero.  The fields that follow,\n  ** down to the beginning of the recursive section, do not need to be\n  ** initialized as they will be set before being used.  The boundary is\n  ** determined by offsetof(Parse,aTempReg).\n  **************************************************************************/\n\n  int aTempReg[8];        /* Holding area for temporary registers */\n  Token sNameToken;       /* Token with unqualified schema object name */\n\n  /************************************************************************\n  ** Above is constant between recursions.  Below is reset before and after\n  ** each recursion.  The boundary between these two regions is determined\n  ** using offsetof(Parse,sLastToken) so the sLastToken field must be the\n  ** first field in the recursive region.\n  ************************************************************************/\n\n  Token sLastToken;       /* The last token parsed */\n  ynVar nVar;               /* Number of '?' variables seen in the SQL so far */\n  u8 iPkSortOrder;          /* ASC or DESC for INTEGER PRIMARY KEY */\n  u8 explain;               /* True if the EXPLAIN flag is found on the query */\n#if !(defined(SQLITE_OMIT_VIRTUALTABLE) && defined(SQLITE_OMIT_ALTERTABLE))\n  u8 eParseMode;            /* PARSE_MODE_XXX constant */\n#endif\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n  int nVtabLock;            /* Number of virtual tables to lock */\n#endif\n  int nHeight;              /* Expression tree height of current sub-select */\n#ifndef SQLITE_OMIT_EXPLAIN\n  int addrExplain;          /* Address of current OP_Explain opcode */\n#endif\n  VList *pVList;            /* Mapping between variable names and numbers */\n  Vdbe *pReprepare;         /* VM being reprepared (sqlite3Reprepare()) */\n  const char *zTail;        /* All SQL text past the last semicolon parsed */\n  Table *pNewTable;         /* A table being constructed by CREATE TABLE */\n  Index *pNewIndex;         /* An index being constructed by CREATE INDEX.\n                            ** Also used to hold redundant UNIQUE constraints\n                            ** during a RENAME COLUMN */\n  Trigger *pNewTrigger;     /* Trigger under construct by a CREATE TRIGGER */\n  const char *zAuthContext; /* The 6th parameter to db->xAuth callbacks */\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n  Token sArg;               /* Complete text of a module argument */\n  Table **apVtabLock;       /* Pointer to virtual tables needing locking */\n#endif\n  Table *pZombieTab;        /* List of Table objects to delete after code gen */\n  TriggerPrg *pTriggerPrg;  /* Linked list of coded triggers */\n  With *pWith;              /* Current WITH clause, or NULL */\n  With *pWithToFree;        /* Free this WITH object at the end of the parse */\n#ifndef SQLITE_OMIT_ALTERTABLE\n  RenameToken *pRename;     /* Tokens subject to renaming by ALTER TABLE */\n#endif\n};\n\n#define PARSE_MODE_NORMAL        0\n#define PARSE_MODE_DECLARE_VTAB  1\n#define PARSE_MODE_RENAME        2\n#define PARSE_MODE_UNMAP         3\n\n/*\n** Sizes and pointers of various parts of the Parse object.\n*/\n#define PARSE_HDR_SZ offsetof(Parse,aTempReg) /* Recursive part w/o aColCache*/\n#define PARSE_RECURSE_SZ offsetof(Parse,sLastToken)    /* Recursive part */\n#define PARSE_TAIL_SZ (sizeof(Parse)-PARSE_RECURSE_SZ) /* Non-recursive part */\n#define PARSE_TAIL(X) (((char*)(X))+PARSE_RECURSE_SZ)  /* Pointer to tail */\n\n/*\n** Return true if currently inside an sqlite3_declare_vtab() call.\n*/\n#ifdef SQLITE_OMIT_VIRTUALTABLE\n  #define IN_DECLARE_VTAB 0\n#else\n  #define IN_DECLARE_VTAB (pParse->eParseMode==PARSE_MODE_DECLARE_VTAB)\n#endif\n\n#if defined(SQLITE_OMIT_ALTERTABLE)\n  #define IN_RENAME_OBJECT 0\n#else\n  #define IN_RENAME_OBJECT (pParse->eParseMode>=PARSE_MODE_RENAME)\n#endif\n\n#if defined(SQLITE_OMIT_VIRTUALTABLE) && defined(SQLITE_OMIT_ALTERTABLE)\n  #define IN_SPECIAL_PARSE 0\n#else\n  #define IN_SPECIAL_PARSE (pParse->eParseMode!=PARSE_MODE_NORMAL)\n#endif\n\n/*\n** An instance of the following structure can be declared on a stack and used\n** to save the Parse.zAuthContext value so that it can be restored later.\n*/\nstruct AuthContext {\n  const char *zAuthContext;   /* Put saved Parse.zAuthContext here */\n  Parse *pParse;              /* The Parse structure */\n};\n\n/*\n** Bitfield flags for P5 value in various opcodes.\n**\n** Value constraints (enforced via assert()):\n**    OPFLAG_LENGTHARG    == SQLITE_FUNC_LENGTH\n**    OPFLAG_TYPEOFARG    == SQLITE_FUNC_TYPEOF\n**    OPFLAG_BULKCSR      == BTREE_BULKLOAD\n**    OPFLAG_SEEKEQ       == BTREE_SEEK_EQ\n**    OPFLAG_FORDELETE    == BTREE_FORDELETE\n**    OPFLAG_SAVEPOSITION == BTREE_SAVEPOSITION\n**    OPFLAG_AUXDELETE    == BTREE_AUXDELETE\n*/\n#define OPFLAG_NCHANGE       0x01    /* OP_Insert: Set to update db->nChange */\n                                     /* Also used in P2 (not P5) of OP_Delete */\n#define OPFLAG_NOCHNG        0x01    /* OP_VColumn nochange for UPDATE */\n#define OPFLAG_EPHEM         0x01    /* OP_Column: Ephemeral output is ok */\n#define OPFLAG_LASTROWID     0x20    /* Set to update db->lastRowid */\n#define OPFLAG_ISUPDATE      0x04    /* This OP_Insert is an sql UPDATE */\n#define OPFLAG_APPEND        0x08    /* This is likely to be an append */\n#define OPFLAG_USESEEKRESULT 0x10    /* Try to avoid a seek in BtreeInsert() */\n#define OPFLAG_ISNOOP        0x40    /* OP_Delete does pre-update-hook only */\n#define OPFLAG_LENGTHARG     0x40    /* OP_Column only used for length() */\n#define OPFLAG_TYPEOFARG     0x80    /* OP_Column only used for typeof() */\n#define OPFLAG_BULKCSR       0x01    /* OP_Open** used to open bulk cursor */\n#define OPFLAG_SEEKEQ        0x02    /* OP_Open** cursor uses EQ seek only */\n#define OPFLAG_FORDELETE     0x08    /* OP_Open should use BTREE_FORDELETE */\n#define OPFLAG_P2ISREG       0x10    /* P2 to OP_Open** is a register number */\n#define OPFLAG_PERMUTE       0x01    /* OP_Compare: use the permutation */\n#define OPFLAG_SAVEPOSITION  0x02    /* OP_Delete/Insert: save cursor pos */\n#define OPFLAG_AUXDELETE     0x04    /* OP_Delete: index in a DELETE op */\n#define OPFLAG_NOCHNG_MAGIC  0x6d    /* OP_MakeRecord: serialtype 10 is ok */\n\n/*\n * Each trigger present in the database schema is stored as an instance of\n * struct Trigger.\n *\n * Pointers to instances of struct Trigger are stored in two ways.\n * 1. In the \"trigHash\" hash table (part of the sqlite3* that represents the\n *    database). This allows Trigger structures to be retrieved by name.\n * 2. All triggers associated with a single table form a linked list, using the\n *    pNext member of struct Trigger. A pointer to the first element of the\n *    linked list is stored as the \"pTrigger\" member of the associated\n *    struct Table.\n *\n * The \"step_list\" member points to the first element of a linked list\n * containing the SQL statements specified as the trigger program.\n */\nstruct Trigger {\n  char *zName;            /* The name of the trigger                        */\n  char *table;            /* The table or view to which the trigger applies */\n  u8 op;                  /* One of TK_DELETE, TK_UPDATE, TK_INSERT         */\n  u8 tr_tm;               /* One of TRIGGER_BEFORE, TRIGGER_AFTER */\n  Expr *pWhen;            /* The WHEN clause of the expression (may be NULL) */\n  IdList *pColumns;       /* If this is an UPDATE OF <column-list> trigger,\n                             the <column-list> is stored here */\n  Schema *pSchema;        /* Schema containing the trigger */\n  Schema *pTabSchema;     /* Schema containing the table */\n  TriggerStep *step_list; /* Link list of trigger program steps             */\n  Trigger *pNext;         /* Next trigger associated with the table */\n};\n\n/*\n** A trigger is either a BEFORE or an AFTER trigger.  The following constants\n** determine which.\n**\n** If there are multiple triggers, you might of some BEFORE and some AFTER.\n** In that cases, the constants below can be ORed together.\n*/\n#define TRIGGER_BEFORE  1\n#define TRIGGER_AFTER   2\n\n/*\n * An instance of struct TriggerStep is used to store a single SQL statement\n * that is a part of a trigger-program.\n *\n * Instances of struct TriggerStep are stored in a singly linked list (linked\n * using the \"pNext\" member) referenced by the \"step_list\" member of the\n * associated struct Trigger instance. The first element of the linked list is\n * the first step of the trigger-program.\n *\n * The \"op\" member indicates whether this is a \"DELETE\", \"INSERT\", \"UPDATE\" or\n * \"SELECT\" statement. The meanings of the other members is determined by the\n * value of \"op\" as follows:\n *\n * (op == TK_INSERT)\n * orconf    -> stores the ON CONFLICT algorithm\n * pSelect   -> If this is an INSERT INTO ... SELECT ... statement, then\n *              this stores a pointer to the SELECT statement. Otherwise NULL.\n * zTarget   -> Dequoted name of the table to insert into.\n * pExprList -> If this is an INSERT INTO ... VALUES ... statement, then\n *              this stores values to be inserted. Otherwise NULL.\n * pIdList   -> If this is an INSERT INTO ... (<column-names>) VALUES ...\n *              statement, then this stores the column-names to be\n *              inserted into.\n *\n * (op == TK_DELETE)\n * zTarget   -> Dequoted name of the table to delete from.\n * pWhere    -> The WHERE clause of the DELETE statement if one is specified.\n *              Otherwise NULL.\n *\n * (op == TK_UPDATE)\n * zTarget   -> Dequoted name of the table to update.\n * pWhere    -> The WHERE clause of the UPDATE statement if one is specified.\n *              Otherwise NULL.\n * pExprList -> A list of the columns to update and the expressions to update\n *              them to. See sqlite3Update() documentation of \"pChanges\"\n *              argument.\n *\n */\nstruct TriggerStep {\n  u8 op;               /* One of TK_DELETE, TK_UPDATE, TK_INSERT, TK_SELECT */\n  u8 orconf;           /* OE_Rollback etc. */\n  Trigger *pTrig;      /* The trigger that this step is a part of */\n  Select *pSelect;     /* SELECT statement or RHS of INSERT INTO SELECT ... */\n  char *zTarget;       /* Target table for DELETE, UPDATE, INSERT */\n  Expr *pWhere;        /* The WHERE clause for DELETE or UPDATE steps */\n  ExprList *pExprList; /* SET clause for UPDATE */\n  IdList *pIdList;     /* Column names for INSERT */\n  Upsert *pUpsert;     /* Upsert clauses on an INSERT */\n  char *zSpan;         /* Original SQL text of this command */\n  TriggerStep *pNext;  /* Next in the link-list */\n  TriggerStep *pLast;  /* Last element in link-list. Valid for 1st elem only */\n};\n\n/*\n** The following structure contains information used by the sqliteFix...\n** routines as they walk the parse tree to make database references\n** explicit.\n*/\ntypedef struct DbFixer DbFixer;\nstruct DbFixer {\n  Parse *pParse;      /* The parsing context.  Error messages written here */\n  Schema *pSchema;    /* Fix items to this schema */\n  int bVarOnly;       /* Check for variable references only */\n  const char *zDb;    /* Make sure all objects are contained in this database */\n  const char *zType;  /* Type of the container - used for error messages */\n  const Token *pName; /* Name of the container - used for error messages */\n};\n\n/*\n** An objected used to accumulate the text of a string where we\n** do not necessarily know how big the string will be in the end.\n*/\nstruct sqlite3_str {\n  sqlite3 *db;         /* Optional database for lookaside.  Can be NULL */\n  char *zText;         /* The string collected so far */\n  u32  nAlloc;         /* Amount of space allocated in zText */\n  u32  mxAlloc;        /* Maximum allowed allocation.  0 for no malloc usage */\n  u32  nChar;          /* Length of the string so far */\n  u8   accError;       /* SQLITE_NOMEM or SQLITE_TOOBIG */\n  u8   printfFlags;    /* SQLITE_PRINTF flags below */\n};\n#define SQLITE_PRINTF_INTERNAL 0x01  /* Internal-use-only converters allowed */\n#define SQLITE_PRINTF_SQLFUNC  0x02  /* SQL function arguments to VXPrintf */\n#define SQLITE_PRINTF_MALLOCED 0x04  /* True if xText is allocated space */\n\n#define isMalloced(X)  (((X)->printfFlags & SQLITE_PRINTF_MALLOCED)!=0)\n\n\n/*\n** A pointer to this structure is used to communicate information\n** from sqlite3Init and OP_ParseSchema into the sqlite3InitCallback.\n*/\ntypedef struct {\n  sqlite3 *db;        /* The database being initialized */\n  char **pzErrMsg;    /* Error message stored here */\n  int iDb;            /* 0 for main database.  1 for TEMP, 2.. for ATTACHed */\n  int rc;             /* Result code stored here */\n  u32 mInitFlags;     /* Flags controlling error messages */\n  u32 nInitRow;       /* Number of rows processed */\n} InitData;\n\n/*\n** Allowed values for mInitFlags\n*/\n#define INITFLAG_AlterTable   0x0001  /* This is a reparse after ALTER TABLE */\n\n/*\n** Structure containing global configuration data for the SQLite library.\n**\n** This structure also contains some state information.\n*/\nstruct Sqlite3Config {\n  int bMemstat;                     /* True to enable memory status */\n  u8 bCoreMutex;                    /* True to enable core mutexing */\n  u8 bFullMutex;                    /* True to enable full mutexing */\n  u8 bOpenUri;                      /* True to interpret filenames as URIs */\n  u8 bUseCis;                       /* Use covering indices for full-scans */\n  u8 bSmallMalloc;                  /* Avoid large memory allocations if true */\n  u8 bExtraSchemaChecks;            /* Verify type,name,tbl_name in schema */\n  int mxStrlen;                     /* Maximum string length */\n  int neverCorrupt;                 /* Database is always well-formed */\n  int szLookaside;                  /* Default lookaside buffer size */\n  int nLookaside;                   /* Default lookaside buffer count */\n  int nStmtSpill;                   /* Stmt-journal spill-to-disk threshold */\n  sqlite3_mem_methods m;            /* Low-level memory allocation interface */\n  sqlite3_mutex_methods mutex;      /* Low-level mutex interface */\n  sqlite3_pcache_methods2 pcache2;  /* Low-level page-cache interface */\n  void *pHeap;                      /* Heap storage space */\n  int nHeap;                        /* Size of pHeap[] */\n  int mnReq, mxReq;                 /* Min and max heap requests sizes */\n  sqlite3_int64 szMmap;             /* mmap() space per open file */\n  sqlite3_int64 mxMmap;             /* Maximum value for szMmap */\n  void *pPage;                      /* Page cache memory */\n  int szPage;                       /* Size of each page in pPage[] */\n  int nPage;                        /* Number of pages in pPage[] */\n  int mxParserStack;                /* maximum depth of the parser stack */\n  int sharedCacheEnabled;           /* true if shared-cache mode enabled */\n  u32 szPma;                        /* Maximum Sorter PMA size */\n  /* The above might be initialized to non-zero.  The following need to always\n  ** initially be zero, however. */\n  int isInit;                       /* True after initialization has finished */\n  int inProgress;                   /* True while initialization in progress */\n  int isMutexInit;                  /* True after mutexes are initialized */\n  int isMallocInit;                 /* True after malloc is initialized */\n  int isPCacheInit;                 /* True after malloc is initialized */\n  int nRefInitMutex;                /* Number of users of pInitMutex */\n  sqlite3_mutex *pInitMutex;        /* Mutex used by sqlite3_initialize() */\n  void (*xLog)(void*,int,const char*); /* Function for logging */\n  void *pLogArg;                       /* First argument to xLog() */\n#ifdef SQLITE_ENABLE_SQLLOG\n  void(*xSqllog)(void*,sqlite3*,const char*, int);\n  void *pSqllogArg;\n#endif\n#ifdef SQLITE_VDBE_COVERAGE\n  /* The following callback (if not NULL) is invoked on every VDBE branch\n  ** operation.  Set the callback using SQLITE_TESTCTRL_VDBE_COVERAGE.\n  */\n  void (*xVdbeBranch)(void*,unsigned iSrcLine,u8 eThis,u8 eMx);  /* Callback */\n  void *pVdbeBranchArg;                                     /* 1st argument */\n#endif\n#ifdef SQLITE_ENABLE_DESERIALIZE\n  sqlite3_int64 mxMemdbSize;        /* Default max memdb size */\n#endif\n#ifndef SQLITE_UNTESTABLE\n  int (*xTestCallback)(int);        /* Invoked by sqlite3FaultSim() */\n#endif\n  int bLocaltimeFault;              /* True to fail localtime() calls */\n  int bInternalFunctions;           /* Internal SQL functions are visible */\n  int iOnceResetThreshold;          /* When to reset OP_Once counters */\n  u32 szSorterRef;                  /* Min size in bytes to use sorter-refs */\n  unsigned int iPrngSeed;           /* Alternative fixed seed for the PRNG */\n};\n\n/*\n** This macro is used inside of assert() statements to indicate that\n** the assert is only valid on a well-formed database.  Instead of:\n**\n**     assert( X );\n**\n** One writes:\n**\n**     assert( X || CORRUPT_DB );\n**\n** CORRUPT_DB is true during normal operation.  CORRUPT_DB does not indicate\n** that the database is definitely corrupt, only that it might be corrupt.\n** For most test cases, CORRUPT_DB is set to false using a special\n** sqlite3_test_control().  This enables assert() statements to prove\n** things that are always true for well-formed databases.\n*/\n#define CORRUPT_DB  (sqlite3Config.neverCorrupt==0)\n\n/*\n** Context pointer passed down through the tree-walk.\n*/\nstruct Walker {\n  Parse *pParse;                            /* Parser context.  */\n  int (*xExprCallback)(Walker*, Expr*);     /* Callback for expressions */\n  int (*xSelectCallback)(Walker*,Select*);  /* Callback for SELECTs */\n  void (*xSelectCallback2)(Walker*,Select*);/* Second callback for SELECTs */\n  int walkerDepth;                          /* Number of subqueries */\n  u16 eCode;                                /* A small processing code */\n  union {                                   /* Extra data for callback */\n    NameContext *pNC;                         /* Naming context */\n    int n;                                    /* A counter */\n    int iCur;                                 /* A cursor number */\n    SrcList *pSrcList;                        /* FROM clause */\n    struct SrcCount *pSrcCount;               /* Counting column references */\n    struct CCurHint *pCCurHint;               /* Used by codeCursorHint() */\n    int *aiCol;                               /* array of column indexes */\n    struct IdxCover *pIdxCover;               /* Check for index coverage */\n    struct IdxExprTrans *pIdxTrans;           /* Convert idxed expr to column */\n    ExprList *pGroupBy;                       /* GROUP BY clause */\n    Select *pSelect;                          /* HAVING to WHERE clause ctx */\n    struct WindowRewrite *pRewrite;           /* Window rewrite context */\n    struct WhereConst *pConst;                /* WHERE clause constants */\n    struct RenameCtx *pRename;                /* RENAME COLUMN context */\n    struct Table *pTab;                       /* Table of generated column */\n  } u;\n};\n\n/* Forward declarations */\nint sqlite3WalkExpr(Walker*, Expr*);\nint sqlite3WalkExprList(Walker*, ExprList*);\nint sqlite3WalkSelect(Walker*, Select*);\nint sqlite3WalkSelectExpr(Walker*, Select*);\nint sqlite3WalkSelectFrom(Walker*, Select*);\nint sqlite3ExprWalkNoop(Walker*, Expr*);\nint sqlite3SelectWalkNoop(Walker*, Select*);\nint sqlite3SelectWalkFail(Walker*, Select*);\n#ifdef SQLITE_DEBUG\nvoid sqlite3SelectWalkAssert2(Walker*, Select*);\n#endif\n\n/*\n** Return code from the parse-tree walking primitives and their\n** callbacks.\n*/\n#define WRC_Continue    0   /* Continue down into children */\n#define WRC_Prune       1   /* Omit children but continue walking siblings */\n#define WRC_Abort       2   /* Abandon the tree walk */\n\n/*\n** An instance of this structure represents a set of one or more CTEs\n** (common table expressions) created by a single WITH clause.\n*/\nstruct With {\n  int nCte;                       /* Number of CTEs in the WITH clause */\n  With *pOuter;                   /* Containing WITH clause, or NULL */\n  struct Cte {                    /* For each CTE in the WITH clause.... */\n    char *zName;                    /* Name of this CTE */\n    ExprList *pCols;                /* List of explicit column names, or NULL */\n    Select *pSelect;                /* The definition of this CTE */\n    const char *zCteErr;            /* Error message for circular references */\n  } a[1];\n};\n\n#ifdef SQLITE_DEBUG\n/*\n** An instance of the TreeView object is used for printing the content of\n** data structures on sqlite3DebugPrintf() using a tree-like view.\n*/\nstruct TreeView {\n  int iLevel;             /* Which level of the tree we are on */\n  u8  bLine[100];         /* Draw vertical in column i if bLine[i] is true */\n};\n#endif /* SQLITE_DEBUG */\n\n/*\n** This object is used in various ways, most (but not all) related to window\n** functions.\n**\n**   (1) A single instance of this structure is attached to the\n**       the Expr.y.pWin field for each window function in an expression tree.\n**       This object holds the information contained in the OVER clause,\n**       plus additional fields used during code generation.\n**\n**   (2) All window functions in a single SELECT form a linked-list\n**       attached to Select.pWin.  The Window.pFunc and Window.pExpr\n**       fields point back to the expression that is the window function.\n**\n**   (3) The terms of the WINDOW clause of a SELECT are instances of this\n**       object on a linked list attached to Select.pWinDefn.\n**\n**   (4) For an aggregate function with a FILTER clause, an instance\n**       of this object is stored in Expr.y.pWin with eFrmType set to\n**       TK_FILTER. In this case the only field used is Window.pFilter.\n**\n** The uses (1) and (2) are really the same Window object that just happens\n** to be accessible in two different ways.  Use case (3) are separate objects.\n*/\nstruct Window {\n  char *zName;            /* Name of window (may be NULL) */\n  char *zBase;            /* Name of base window for chaining (may be NULL) */\n  ExprList *pPartition;   /* PARTITION BY clause */\n  ExprList *pOrderBy;     /* ORDER BY clause */\n  u8 eFrmType;            /* TK_RANGE, TK_GROUPS, TK_ROWS, or 0 */\n  u8 eStart;              /* UNBOUNDED, CURRENT, PRECEDING or FOLLOWING */\n  u8 eEnd;                /* UNBOUNDED, CURRENT, PRECEDING or FOLLOWING */\n  u8 bImplicitFrame;      /* True if frame was implicitly specified */\n  u8 eExclude;            /* TK_NO, TK_CURRENT, TK_TIES, TK_GROUP, or 0 */\n  Expr *pStart;           /* Expression for \"<expr> PRECEDING\" */\n  Expr *pEnd;             /* Expression for \"<expr> FOLLOWING\" */\n  Window **ppThis;        /* Pointer to this object in Select.pWin list */\n  Window *pNextWin;       /* Next window function belonging to this SELECT */\n  Expr *pFilter;          /* The FILTER expression */\n  FuncDef *pFunc;         /* The function */\n  int iEphCsr;            /* Partition buffer or Peer buffer */\n  int regAccum;           /* Accumulator */\n  int regResult;          /* Interim result */\n  int csrApp;             /* Function cursor (used by min/max) */\n  int regApp;             /* Function register (also used by min/max) */\n  int regPart;            /* Array of registers for PARTITION BY values */\n  Expr *pOwner;           /* Expression object this window is attached to */\n  int nBufferCol;         /* Number of columns in buffer table */\n  int iArgCol;            /* Offset of first argument for this function */\n  int regOne;             /* Register containing constant value 1 */\n  int regStartRowid;\n  int regEndRowid;\n  u8 bExprArgs;           /* Defer evaluation of window function arguments\n                          ** due to the SQLITE_SUBTYPE flag */\n};\n\n#ifndef SQLITE_OMIT_WINDOWFUNC\nvoid sqlite3WindowDelete(sqlite3*, Window*);\nvoid sqlite3WindowUnlinkFromSelect(Window*);\nvoid sqlite3WindowListDelete(sqlite3 *db, Window *p);\nWindow *sqlite3WindowAlloc(Parse*, int, int, Expr*, int , Expr*, u8);\nvoid sqlite3WindowAttach(Parse*, Expr*, Window*);\nvoid sqlite3WindowLink(Select *pSel, Window *pWin);\nint sqlite3WindowCompare(Parse*, Window*, Window*, int);\nvoid sqlite3WindowCodeInit(Parse*, Window*);\nvoid sqlite3WindowCodeStep(Parse*, Select*, WhereInfo*, int, int);\nint sqlite3WindowRewrite(Parse*, Select*);\nint sqlite3ExpandSubquery(Parse*, struct SrcList_item*);\nvoid sqlite3WindowUpdate(Parse*, Window*, Window*, FuncDef*);\nWindow *sqlite3WindowDup(sqlite3 *db, Expr *pOwner, Window *p);\nWindow *sqlite3WindowListDup(sqlite3 *db, Window *p);\nvoid sqlite3WindowFunctions(void);\nvoid sqlite3WindowChain(Parse*, Window*, Window*);\nWindow *sqlite3WindowAssemble(Parse*, Window*, ExprList*, ExprList*, Token*);\n#else\n# define sqlite3WindowDelete(a,b)\n# define sqlite3WindowFunctions()\n# define sqlite3WindowAttach(a,b,c)\n#endif\n\n/*\n** Assuming zIn points to the first byte of a UTF-8 character,\n** advance zIn to point to the first byte of the next UTF-8 character.\n*/\n#define SQLITE_SKIP_UTF8(zIn) {                        \\\n  if( (*(zIn++))>=0xc0 ){                              \\\n    while( (*zIn & 0xc0)==0x80 ){ zIn++; }             \\\n  }                                                    \\\n}\n\n/*\n** The SQLITE_*_BKPT macros are substitutes for the error codes with\n** the same name but without the _BKPT suffix.  These macros invoke\n** routines that report the line-number on which the error originated\n** using sqlite3_log().  The routines also provide a convenient place\n** to set a debugger breakpoint.\n*/\nint sqlite3ReportError(int iErr, int lineno, const char *zType);\nint sqlite3CorruptError(int);\nint sqlite3MisuseError(int);\nint sqlite3CantopenError(int);\n#define SQLITE_CORRUPT_BKPT sqlite3CorruptError(__LINE__)\n#define SQLITE_MISUSE_BKPT sqlite3MisuseError(__LINE__)\n#define SQLITE_CANTOPEN_BKPT sqlite3CantopenError(__LINE__)\n#ifdef SQLITE_DEBUG\n  int sqlite3NomemError(int);\n  int sqlite3IoerrnomemError(int);\n  int sqlite3CorruptPgnoError(int,Pgno);\n# define SQLITE_NOMEM_BKPT sqlite3NomemError(__LINE__)\n# define SQLITE_IOERR_NOMEM_BKPT sqlite3IoerrnomemError(__LINE__)\n# define SQLITE_CORRUPT_PGNO(P) sqlite3CorruptPgnoError(__LINE__,(P))\n#else\n# define SQLITE_NOMEM_BKPT SQLITE_NOMEM\n# define SQLITE_IOERR_NOMEM_BKPT SQLITE_IOERR_NOMEM\n# define SQLITE_CORRUPT_PGNO(P) sqlite3CorruptError(__LINE__)\n#endif\n\n/*\n** FTS3 and FTS4 both require virtual table support\n*/\n#if defined(SQLITE_OMIT_VIRTUALTABLE)\n# undef SQLITE_ENABLE_FTS3\n# undef SQLITE_ENABLE_FTS4\n#endif\n\n/*\n** FTS4 is really an extension for FTS3.  It is enabled using the\n** SQLITE_ENABLE_FTS3 macro.  But to avoid confusion we also call\n** the SQLITE_ENABLE_FTS4 macro to serve as an alias for SQLITE_ENABLE_FTS3.\n*/\n#if defined(SQLITE_ENABLE_FTS4) && !defined(SQLITE_ENABLE_FTS3)\n# define SQLITE_ENABLE_FTS3 1\n#endif\n\n/*\n** The ctype.h header is needed for non-ASCII systems.  It is also\n** needed by FTS3 when FTS3 is included in the amalgamation.\n*/\n#if !defined(SQLITE_ASCII) || \\\n    (defined(SQLITE_ENABLE_FTS3) && defined(SQLITE_AMALGAMATION))\n# include <ctype.h>\n#endif\n\n/*\n** The following macros mimic the standard library functions toupper(),\n** isspace(), isalnum(), isdigit() and isxdigit(), respectively. The\n** sqlite versions only work for ASCII characters, regardless of locale.\n*/\n#ifdef SQLITE_ASCII\n# define sqlite3Toupper(x)  ((x)&~(sqlite3CtypeMap[(unsigned char)(x)]&0x20))\n# define sqlite3Isspace(x)   (sqlite3CtypeMap[(unsigned char)(x)]&0x01)\n# define sqlite3Isalnum(x)   (sqlite3CtypeMap[(unsigned char)(x)]&0x06)\n# define sqlite3Isalpha(x)   (sqlite3CtypeMap[(unsigned char)(x)]&0x02)\n# define sqlite3Isdigit(x)   (sqlite3CtypeMap[(unsigned char)(x)]&0x04)\n# define sqlite3Isxdigit(x)  (sqlite3CtypeMap[(unsigned char)(x)]&0x08)\n# define sqlite3Tolower(x)   (sqlite3UpperToLower[(unsigned char)(x)])\n# define sqlite3Isquote(x)   (sqlite3CtypeMap[(unsigned char)(x)]&0x80)\n#else\n# define sqlite3Toupper(x)   toupper((unsigned char)(x))\n# define sqlite3Isspace(x)   isspace((unsigned char)(x))\n# define sqlite3Isalnum(x)   isalnum((unsigned char)(x))\n# define sqlite3Isalpha(x)   isalpha((unsigned char)(x))\n# define sqlite3Isdigit(x)   isdigit((unsigned char)(x))\n# define sqlite3Isxdigit(x)  isxdigit((unsigned char)(x))\n# define sqlite3Tolower(x)   tolower((unsigned char)(x))\n# define sqlite3Isquote(x)   ((x)=='\"'||(x)=='\\''||(x)=='['||(x)=='`')\n#endif\nint sqlite3IsIdChar(u8);\n\n/*\n** Internal function prototypes\n*/\nint sqlite3StrICmp(const char*,const char*);\nint sqlite3Strlen30(const char*);\n#define sqlite3Strlen30NN(C) (strlen(C)&0x3fffffff)\nchar *sqlite3ColumnType(Column*,char*);\n#define sqlite3StrNICmp sqlite3_strnicmp\n\nint sqlite3MallocInit(void);\nvoid sqlite3MallocEnd(void);\nvoid *sqlite3Malloc(u64);\nvoid *sqlite3MallocZero(u64);\nvoid *sqlite3DbMallocZero(sqlite3*, u64);\nvoid *sqlite3DbMallocRaw(sqlite3*, u64);\nvoid *sqlite3DbMallocRawNN(sqlite3*, u64);\nchar *sqlite3DbStrDup(sqlite3*,const char*);\nchar *sqlite3DbStrNDup(sqlite3*,const char*, u64);\nchar *sqlite3DbSpanDup(sqlite3*,const char*,const char*);\nvoid *sqlite3Realloc(void*, u64);\nvoid *sqlite3DbReallocOrFree(sqlite3 *, void *, u64);\nvoid *sqlite3DbRealloc(sqlite3 *, void *, u64);\nvoid sqlite3DbFree(sqlite3*, void*);\nvoid sqlite3DbFreeNN(sqlite3*, void*);\nint sqlite3MallocSize(void*);\nint sqlite3DbMallocSize(sqlite3*, void*);\nvoid *sqlite3PageMalloc(int);\nvoid sqlite3PageFree(void*);\nvoid sqlite3MemSetDefault(void);\n#ifndef SQLITE_UNTESTABLE\nvoid sqlite3BenignMallocHooks(void (*)(void), void (*)(void));\n#endif\nint sqlite3HeapNearlyFull(void);\n\n/*\n** On systems with ample stack space and that support alloca(), make\n** use of alloca() to obtain space for large automatic objects.  By default,\n** obtain space from malloc().\n**\n** The alloca() routine never returns NULL.  This will cause code paths\n** that deal with sqlite3StackAlloc() failures to be unreachable.\n*/\n#ifdef SQLITE_USE_ALLOCA\n# define sqlite3StackAllocRaw(D,N)   alloca(N)\n# define sqlite3StackAllocZero(D,N)  memset(alloca(N), 0, N)\n# define sqlite3StackFree(D,P)\n#else\n# define sqlite3StackAllocRaw(D,N)   sqlite3DbMallocRaw(D,N)\n# define sqlite3StackAllocZero(D,N)  sqlite3DbMallocZero(D,N)\n# define sqlite3StackFree(D,P)       sqlite3DbFree(D,P)\n#endif\n\n/* Do not allow both MEMSYS5 and MEMSYS3 to be defined together.  If they\n** are, disable MEMSYS3\n*/\n#ifdef SQLITE_ENABLE_MEMSYS5\nconst sqlite3_mem_methods *sqlite3MemGetMemsys5(void);\n#undef SQLITE_ENABLE_MEMSYS3\n#endif\n#ifdef SQLITE_ENABLE_MEMSYS3\nconst sqlite3_mem_methods *sqlite3MemGetMemsys3(void);\n#endif\n\n\n#ifndef SQLITE_MUTEX_OMIT\n  sqlite3_mutex_methods const *sqlite3DefaultMutex(void);\n  sqlite3_mutex_methods const *sqlite3NoopMutex(void);\n  sqlite3_mutex *sqlite3MutexAlloc(int);\n  int sqlite3MutexInit(void);\n  int sqlite3MutexEnd(void);\n#endif\n#if !defined(SQLITE_MUTEX_OMIT) && !defined(SQLITE_MUTEX_NOOP)\n  void sqlite3MemoryBarrier(void);\n#else\n# define sqlite3MemoryBarrier()\n#endif\n\nsqlite3_int64 sqlite3StatusValue(int);\nvoid sqlite3StatusUp(int, int);\nvoid sqlite3StatusDown(int, int);\nvoid sqlite3StatusHighwater(int, int);\nint sqlite3LookasideUsed(sqlite3*,int*);\n\n/* Access to mutexes used by sqlite3_status() */\nsqlite3_mutex *sqlite3Pcache1Mutex(void);\nsqlite3_mutex *sqlite3MallocMutex(void);\n\n#if defined(SQLITE_ENABLE_MULTITHREADED_CHECKS) && !defined(SQLITE_MUTEX_OMIT)\nvoid sqlite3MutexWarnOnContention(sqlite3_mutex*);\n#else\n# define sqlite3MutexWarnOnContention(x)\n#endif\n\n#ifndef SQLITE_OMIT_FLOATING_POINT\n# define EXP754 (((u64)0x7ff)<<52)\n# define MAN754 ((((u64)1)<<52)-1)\n# define IsNaN(X) (((X)&EXP754)==EXP754 && ((X)&MAN754)!=0)\n  int sqlite3IsNaN(double);\n#else\n# define IsNaN(X)         0\n# define sqlite3IsNaN(X)  0\n#endif\n\n/*\n** An instance of the following structure holds information about SQL\n** functions arguments that are the parameters to the printf() function.\n*/\nstruct PrintfArguments {\n  int nArg;                /* Total number of arguments */\n  int nUsed;               /* Number of arguments used so far */\n  sqlite3_value **apArg;   /* The argument values */\n};\n\nchar *sqlite3MPrintf(sqlite3*,const char*, ...);\nchar *sqlite3VMPrintf(sqlite3*,const char*, va_list);\n#if defined(SQLITE_DEBUG) || defined(SQLITE_HAVE_OS_TRACE)\n  void sqlite3DebugPrintf(const char*, ...);\n#endif\n#if defined(SQLITE_TEST)\n  void *sqlite3TestTextToPtr(const char*);\n#endif\n\n#if defined(SQLITE_DEBUG)\n  void sqlite3TreeViewExpr(TreeView*, const Expr*, u8);\n  void sqlite3TreeViewBareExprList(TreeView*, const ExprList*, const char*);\n  void sqlite3TreeViewExprList(TreeView*, const ExprList*, u8, const char*);\n  void sqlite3TreeViewSrcList(TreeView*, const SrcList*);\n  void sqlite3TreeViewSelect(TreeView*, const Select*, u8);\n  void sqlite3TreeViewWith(TreeView*, const With*, u8);\n#ifndef SQLITE_OMIT_WINDOWFUNC\n  void sqlite3TreeViewWindow(TreeView*, const Window*, u8);\n  void sqlite3TreeViewWinFunc(TreeView*, const Window*, u8);\n#endif\n#endif\n\n\nvoid sqlite3SetString(char **, sqlite3*, const char*);\nvoid sqlite3ErrorMsg(Parse*, const char*, ...);\nint sqlite3ErrorToParser(sqlite3*,int);\nvoid sqlite3Dequote(char*);\nvoid sqlite3DequoteExpr(Expr*);\nvoid sqlite3TokenInit(Token*,char*);\nint sqlite3KeywordCode(const unsigned char*, int);\nint sqlite3RunParser(Parse*, const char*, char **);\nvoid sqlite3FinishCoding(Parse*);\nint sqlite3GetTempReg(Parse*);\nvoid sqlite3ReleaseTempReg(Parse*,int);\nint sqlite3GetTempRange(Parse*,int);\nvoid sqlite3ReleaseTempRange(Parse*,int,int);\nvoid sqlite3ClearTempRegCache(Parse*);\n#ifdef SQLITE_DEBUG\nint sqlite3NoTempsInRange(Parse*,int,int);\n#endif\nExpr *sqlite3ExprAlloc(sqlite3*,int,const Token*,int);\nExpr *sqlite3Expr(sqlite3*,int,const char*);\nvoid sqlite3ExprAttachSubtrees(sqlite3*,Expr*,Expr*,Expr*);\nExpr *sqlite3PExpr(Parse*, int, Expr*, Expr*);\nvoid sqlite3PExprAddSelect(Parse*, Expr*, Select*);\nExpr *sqlite3ExprAnd(Parse*,Expr*, Expr*);\nExpr *sqlite3ExprSimplifiedAndOr(Expr*);\nExpr *sqlite3ExprFunction(Parse*,ExprList*, Token*, int);\nvoid sqlite3ExprAssignVarNumber(Parse*, Expr*, u32);\nvoid sqlite3ExprDelete(sqlite3*, Expr*);\nvoid sqlite3ExprUnmapAndDelete(Parse*, Expr*);\nExprList *sqlite3ExprListAppend(Parse*,ExprList*,Expr*);\nExprList *sqlite3ExprListAppendVector(Parse*,ExprList*,IdList*,Expr*);\nvoid sqlite3ExprListSetSortOrder(ExprList*,int,int);\nvoid sqlite3ExprListSetName(Parse*,ExprList*,Token*,int);\nvoid sqlite3ExprListSetSpan(Parse*,ExprList*,const char*,const char*);\nvoid sqlite3ExprListDelete(sqlite3*, ExprList*);\nu32 sqlite3ExprListFlags(const ExprList*);\nint sqlite3IndexHasDuplicateRootPage(Index*);\nint sqlite3Init(sqlite3*, char**);\nint sqlite3InitCallback(void*, int, char**, char**);\nint sqlite3InitOne(sqlite3*, int, char**, u32);\nvoid sqlite3Pragma(Parse*,Token*,Token*,Token*,int);\n#ifndef SQLITE_OMIT_VIRTUALTABLE\nModule *sqlite3PragmaVtabRegister(sqlite3*,const char *zName);\n#endif\nvoid sqlite3ResetAllSchemasOfConnection(sqlite3*);\nvoid sqlite3ResetOneSchema(sqlite3*,int);\nvoid sqlite3CollapseDatabaseArray(sqlite3*);\nvoid sqlite3CommitInternalChanges(sqlite3*);\nvoid sqlite3DeleteColumnNames(sqlite3*,Table*);\nint sqlite3ColumnsFromExprList(Parse*,ExprList*,i16*,Column**);\nvoid sqlite3SelectAddColumnTypeAndCollation(Parse*,Table*,Select*,char);\nTable *sqlite3ResultSetOfSelect(Parse*,Select*,char);\nvoid sqlite3OpenMasterTable(Parse *, int);\nIndex *sqlite3PrimaryKeyIndex(Table*);\ni16 sqlite3TableColumnToIndex(Index*, i16);\n#ifdef SQLITE_OMIT_GENERATED_COLUMNS\n# define sqlite3TableColumnToStorage(T,X) (X)  /* No-op pass-through */\n# define sqlite3StorageColumnToTable(T,X) (X)  /* No-op pass-through */\n#else\n  i16 sqlite3TableColumnToStorage(Table*, i16);\n  i16 sqlite3StorageColumnToTable(Table*, i16);\n#endif\nvoid sqlite3StartTable(Parse*,Token*,Token*,int,int,int,int);\n#if SQLITE_ENABLE_HIDDEN_COLUMNS\n  void sqlite3ColumnPropertiesFromName(Table*, Column*);\n#else\n# define sqlite3ColumnPropertiesFromName(T,C) /* no-op */\n#endif\nvoid sqlite3AddColumn(Parse*,Token*,Token*);\nvoid sqlite3AddNotNull(Parse*, int);\nvoid sqlite3AddPrimaryKey(Parse*, ExprList*, int, int, int);\nvoid sqlite3AddCheckConstraint(Parse*, Expr*);\nvoid sqlite3AddDefaultValue(Parse*,Expr*,const char*,const char*);\nvoid sqlite3AddCollateType(Parse*, Token*);\nvoid sqlite3AddGenerated(Parse*,Expr*,Token*);\nvoid sqlite3EndTable(Parse*,Token*,Token*,u8,Select*);\n#ifdef SQLITE_DEBUG\n  int sqlite3UriCount(const char*);\n#endif\nint sqlite3ParseUri(const char*,const char*,unsigned int*,\n                    sqlite3_vfs**,char**,char **);\n#ifdef SQLITE_HAS_CODEC\n  int sqlite3CodecQueryParameters(sqlite3*,const char*,const char*);\n#else\n# define sqlite3CodecQueryParameters(A,B,C) 0\n#endif\nBtree *sqlite3DbNameToBtree(sqlite3*,const char*);\n\n#ifdef SQLITE_UNTESTABLE\n# define sqlite3FaultSim(X) SQLITE_OK\n#else\n  int sqlite3FaultSim(int);\n#endif\n\nBitvec *sqlite3BitvecCreate(u32);\nint sqlite3BitvecTest(Bitvec*, u32);\nint sqlite3BitvecTestNotNull(Bitvec*, u32);\nint sqlite3BitvecSet(Bitvec*, u32);\nvoid sqlite3BitvecClear(Bitvec*, u32, void*);\nvoid sqlite3BitvecDestroy(Bitvec*);\nu32 sqlite3BitvecSize(Bitvec*);\n#ifndef SQLITE_UNTESTABLE\nint sqlite3BitvecBuiltinTest(int,int*);\n#endif\n\nRowSet *sqlite3RowSetInit(sqlite3*);\nvoid sqlite3RowSetDelete(void*);\nvoid sqlite3RowSetClear(void*);\nvoid sqlite3RowSetInsert(RowSet*, i64);\nint sqlite3RowSetTest(RowSet*, int iBatch, i64);\nint sqlite3RowSetNext(RowSet*, i64*);\n\nvoid sqlite3CreateView(Parse*,Token*,Token*,Token*,ExprList*,Select*,int,int);\n\n#if !defined(SQLITE_OMIT_VIEW) || !defined(SQLITE_OMIT_VIRTUALTABLE)\n  int sqlite3ViewGetColumnNames(Parse*,Table*);\n#else\n# define sqlite3ViewGetColumnNames(A,B) 0\n#endif\n\n#if SQLITE_MAX_ATTACHED>30\n  int sqlite3DbMaskAllZero(yDbMask);\n#endif\nvoid sqlite3DropTable(Parse*, SrcList*, int, int);\nvoid sqlite3CodeDropTable(Parse*, Table*, int, int);\nvoid sqlite3DeleteTable(sqlite3*, Table*);\nvoid sqlite3FreeIndex(sqlite3*, Index*);\n#ifndef SQLITE_OMIT_AUTOINCREMENT\n  void sqlite3AutoincrementBegin(Parse *pParse);\n  void sqlite3AutoincrementEnd(Parse *pParse);\n#else\n# define sqlite3AutoincrementBegin(X)\n# define sqlite3AutoincrementEnd(X)\n#endif\nvoid sqlite3Insert(Parse*, SrcList*, Select*, IdList*, int, Upsert*);\n#ifndef SQLITE_OMIT_GENERATED_COLUMNS\n  void sqlite3ComputeGeneratedColumns(Parse*, int, Table*);\n#endif\nvoid *sqlite3ArrayAllocate(sqlite3*,void*,int,int*,int*);\nIdList *sqlite3IdListAppend(Parse*, IdList*, Token*);\nint sqlite3IdListIndex(IdList*,const char*);\nSrcList *sqlite3SrcListEnlarge(Parse*, SrcList*, int, int);\nSrcList *sqlite3SrcListAppend(Parse*, SrcList*, Token*, Token*);\nSrcList *sqlite3SrcListAppendFromTerm(Parse*, SrcList*, Token*, Token*,\n                                      Token*, Select*, Expr*, IdList*);\nvoid sqlite3SrcListIndexedBy(Parse *, SrcList *, Token *);\nvoid sqlite3SrcListFuncArgs(Parse*, SrcList*, ExprList*);\nint sqlite3IndexedByLookup(Parse *, struct SrcList_item *);\nvoid sqlite3SrcListShiftJoinType(SrcList*);\nvoid sqlite3SrcListAssignCursors(Parse*, SrcList*);\nvoid sqlite3IdListDelete(sqlite3*, IdList*);\nvoid sqlite3SrcListDelete(sqlite3*, SrcList*);\nIndex *sqlite3AllocateIndexObject(sqlite3*,i16,int,char**);\nvoid sqlite3CreateIndex(Parse*,Token*,Token*,SrcList*,ExprList*,int,Token*,\n                          Expr*, int, int, u8);\nvoid sqlite3DropIndex(Parse*, SrcList*, int);\nint sqlite3Select(Parse*, Select*, SelectDest*);\nSelect *sqlite3SelectNew(Parse*,ExprList*,SrcList*,Expr*,ExprList*,\n                         Expr*,ExprList*,u32,Expr*);\nvoid sqlite3SelectDelete(sqlite3*, Select*);\nTable *sqlite3SrcListLookup(Parse*, SrcList*);\nint sqlite3IsReadOnly(Parse*, Table*, int);\nvoid sqlite3OpenTable(Parse*, int iCur, int iDb, Table*, int);\n#if defined(SQLITE_ENABLE_UPDATE_DELETE_LIMIT) && !defined(SQLITE_OMIT_SUBQUERY)\nExpr *sqlite3LimitWhere(Parse*,SrcList*,Expr*,ExprList*,Expr*,char*);\n#endif\nvoid sqlite3DeleteFrom(Parse*, SrcList*, Expr*, ExprList*, Expr*);\nvoid sqlite3Update(Parse*, SrcList*, ExprList*,Expr*,int,ExprList*,Expr*,\n                   Upsert*);\nWhereInfo *sqlite3WhereBegin(Parse*,SrcList*,Expr*,ExprList*,ExprList*,u16,int);\nvoid sqlite3WhereEnd(WhereInfo*);\nLogEst sqlite3WhereOutputRowCount(WhereInfo*);\nint sqlite3WhereIsDistinct(WhereInfo*);\nint sqlite3WhereIsOrdered(WhereInfo*);\nint sqlite3WhereOrderByLimitOptLabel(WhereInfo*);\nint sqlite3WhereIsSorted(WhereInfo*);\nint sqlite3WhereContinueLabel(WhereInfo*);\nint sqlite3WhereBreakLabel(WhereInfo*);\nint sqlite3WhereOkOnePass(WhereInfo*, int*);\n#define ONEPASS_OFF      0        /* Use of ONEPASS not allowed */\n#define ONEPASS_SINGLE   1        /* ONEPASS valid for a single row update */\n#define ONEPASS_MULTI    2        /* ONEPASS is valid for multiple rows */\nvoid sqlite3ExprCodeLoadIndexColumn(Parse*, Index*, int, int, int);\nint sqlite3ExprCodeGetColumn(Parse*, Table*, int, int, int, u8);\nvoid sqlite3ExprCodeGetColumnOfTable(Vdbe*, Table*, int, int, int);\nvoid sqlite3ExprCodeMove(Parse*, int, int, int);\nvoid sqlite3ExprCode(Parse*, Expr*, int);\n#ifndef SQLITE_OMIT_GENERATED_COLUMNS\nvoid sqlite3ExprCodeGeneratedColumn(Parse*, Column*, int);\n#endif\nvoid sqlite3ExprCodeCopy(Parse*, Expr*, int);\nvoid sqlite3ExprCodeFactorable(Parse*, Expr*, int);\nint sqlite3ExprCodeAtInit(Parse*, Expr*, int);\nint sqlite3ExprCodeTemp(Parse*, Expr*, int*);\nint sqlite3ExprCodeTarget(Parse*, Expr*, int);\nint sqlite3ExprCodeExprList(Parse*, ExprList*, int, int, u8);\n#define SQLITE_ECEL_DUP      0x01  /* Deep, not shallow copies */\n#define SQLITE_ECEL_FACTOR   0x02  /* Factor out constant terms */\n#define SQLITE_ECEL_REF      0x04  /* Use ExprList.u.x.iOrderByCol */\n#define SQLITE_ECEL_OMITREF  0x08  /* Omit if ExprList.u.x.iOrderByCol */\nvoid sqlite3ExprIfTrue(Parse*, Expr*, int, int);\nvoid sqlite3ExprIfFalse(Parse*, Expr*, int, int);\nvoid sqlite3ExprIfFalseDup(Parse*, Expr*, int, int);\nTable *sqlite3FindTable(sqlite3*,const char*, const char*);\n#define LOCATE_VIEW    0x01\n#define LOCATE_NOERR   0x02\nTable *sqlite3LocateTable(Parse*,u32 flags,const char*, const char*);\nTable *sqlite3LocateTableItem(Parse*,u32 flags,struct SrcList_item *);\nIndex *sqlite3FindIndex(sqlite3*,const char*, const char*);\nvoid sqlite3UnlinkAndDeleteTable(sqlite3*,int,const char*);\nvoid sqlite3UnlinkAndDeleteIndex(sqlite3*,int,const char*);\nvoid sqlite3Vacuum(Parse*,Token*,Expr*);\nint sqlite3RunVacuum(char**, sqlite3*, int, sqlite3_value*);\nchar *sqlite3NameFromToken(sqlite3*, Token*);\nint sqlite3ExprCompare(Parse*,Expr*, Expr*, int);\nint sqlite3ExprCompareSkip(Expr*, Expr*, int);\nint sqlite3ExprListCompare(ExprList*, ExprList*, int);\nint sqlite3ExprImpliesExpr(Parse*,Expr*, Expr*, int);\nint sqlite3ExprImpliesNonNullRow(Expr*,int);\nvoid sqlite3ExprAnalyzeAggregates(NameContext*, Expr*);\nvoid sqlite3ExprAnalyzeAggList(NameContext*,ExprList*);\nint sqlite3ExprCoveredByIndex(Expr*, int iCur, Index *pIdx);\nint sqlite3FunctionUsesThisSrc(Expr*, SrcList*);\nVdbe *sqlite3GetVdbe(Parse*);\n#ifndef SQLITE_UNTESTABLE\nvoid sqlite3PrngSaveState(void);\nvoid sqlite3PrngRestoreState(void);\n#endif\nvoid sqlite3RollbackAll(sqlite3*,int);\nvoid sqlite3CodeVerifySchema(Parse*, int);\nvoid sqlite3CodeVerifyNamedSchema(Parse*, const char *zDb);\nvoid sqlite3BeginTransaction(Parse*, int);\nvoid sqlite3EndTransaction(Parse*,int);\nvoid sqlite3Savepoint(Parse*, int, Token*);\nvoid sqlite3CloseSavepoints(sqlite3 *);\nvoid sqlite3LeaveMutexAndCloseZombie(sqlite3*);\nint sqlite3ExprIdToTrueFalse(Expr*);\nint sqlite3ExprTruthValue(const Expr*);\nint sqlite3ExprIsConstant(Expr*);\nint sqlite3ExprIsConstantNotJoin(Expr*);\nint sqlite3ExprIsConstantOrFunction(Expr*, u8);\nint sqlite3ExprIsConstantOrGroupBy(Parse*, Expr*, ExprList*);\nint sqlite3ExprIsTableConstant(Expr*,int);\n#ifdef SQLITE_ENABLE_CURSOR_HINTS\nint sqlite3ExprContainsSubquery(Expr*);\n#endif\nint sqlite3ExprIsInteger(Expr*, int*);\nint sqlite3ExprCanBeNull(const Expr*);\nint sqlite3ExprNeedsNoAffinityChange(const Expr*, char);\nint sqlite3IsRowid(const char*);\nvoid sqlite3GenerateRowDelete(\n    Parse*,Table*,Trigger*,int,int,int,i16,u8,u8,u8,int);\nvoid sqlite3GenerateRowIndexDelete(Parse*, Table*, int, int, int*, int);\nint sqlite3GenerateIndexKey(Parse*, Index*, int, int, int, int*,Index*,int);\nvoid sqlite3ResolvePartIdxLabel(Parse*,int);\nint sqlite3ExprReferencesUpdatedColumn(Expr*,int*,int);\nvoid sqlite3GenerateConstraintChecks(Parse*,Table*,int*,int,int,int,int,\n                                     u8,u8,int,int*,int*,Upsert*);\n#ifdef SQLITE_ENABLE_NULL_TRIM\n  void sqlite3SetMakeRecordP5(Vdbe*,Table*);\n#else\n# define sqlite3SetMakeRecordP5(A,B)\n#endif\nvoid sqlite3CompleteInsertion(Parse*,Table*,int,int,int,int*,int,int,int);\nint sqlite3OpenTableAndIndices(Parse*, Table*, int, u8, int, u8*, int*, int*);\nvoid sqlite3BeginWriteOperation(Parse*, int, int);\nvoid sqlite3MultiWrite(Parse*);\nvoid sqlite3MayAbort(Parse*);\nvoid sqlite3HaltConstraint(Parse*, int, int, char*, i8, u8);\nvoid sqlite3UniqueConstraint(Parse*, int, Index*);\nvoid sqlite3RowidConstraint(Parse*, int, Table*);\nExpr *sqlite3ExprDup(sqlite3*,Expr*,int);\nExprList *sqlite3ExprListDup(sqlite3*,ExprList*,int);\nSrcList *sqlite3SrcListDup(sqlite3*,SrcList*,int);\nIdList *sqlite3IdListDup(sqlite3*,IdList*);\nSelect *sqlite3SelectDup(sqlite3*,Select*,int);\nFuncDef *sqlite3FunctionSearch(int,const char*);\nvoid sqlite3InsertBuiltinFuncs(FuncDef*,int);\nFuncDef *sqlite3FindFunction(sqlite3*,const char*,int,u8,u8);\nvoid sqlite3RegisterBuiltinFunctions(void);\nvoid sqlite3RegisterDateTimeFunctions(void);\nvoid sqlite3RegisterPerConnectionBuiltinFunctions(sqlite3*);\nint sqlite3SafetyCheckOk(sqlite3*);\nint sqlite3SafetyCheckSickOrOk(sqlite3*);\nvoid sqlite3ChangeCookie(Parse*, int);\n\n#if !defined(SQLITE_OMIT_VIEW) && !defined(SQLITE_OMIT_TRIGGER)\nvoid sqlite3MaterializeView(Parse*, Table*, Expr*, ExprList*,Expr*,int);\n#endif\n\n#ifndef SQLITE_OMIT_TRIGGER\n  void sqlite3BeginTrigger(Parse*, Token*,Token*,int,int,IdList*,SrcList*,\n                           Expr*,int, int);\n  void sqlite3FinishTrigger(Parse*, TriggerStep*, Token*);\n  void sqlite3DropTrigger(Parse*, SrcList*, int);\n  void sqlite3DropTriggerPtr(Parse*, Trigger*);\n  Trigger *sqlite3TriggersExist(Parse *, Table*, int, ExprList*, int *pMask);\n  Trigger *sqlite3TriggerList(Parse *, Table *);\n  void sqlite3CodeRowTrigger(Parse*, Trigger *, int, ExprList*, int, Table *,\n                            int, int, int);\n  void sqlite3CodeRowTriggerDirect(Parse *, Trigger *, Table *, int, int, int);\n  void sqliteViewTriggers(Parse*, Table*, Expr*, int, ExprList*);\n  void sqlite3DeleteTriggerStep(sqlite3*, TriggerStep*);\n  TriggerStep *sqlite3TriggerSelectStep(sqlite3*,Select*,\n                                        const char*,const char*);\n  TriggerStep *sqlite3TriggerInsertStep(Parse*,Token*, IdList*,\n                                        Select*,u8,Upsert*,\n                                        const char*,const char*);\n  TriggerStep *sqlite3TriggerUpdateStep(Parse*,Token*,ExprList*, Expr*, u8,\n                                        const char*,const char*);\n  TriggerStep *sqlite3TriggerDeleteStep(Parse*,Token*, Expr*,\n                                        const char*,const char*);\n  void sqlite3DeleteTrigger(sqlite3*, Trigger*);\n  void sqlite3UnlinkAndDeleteTrigger(sqlite3*,int,const char*);\n  u32 sqlite3TriggerColmask(Parse*,Trigger*,ExprList*,int,int,Table*,int);\n# define sqlite3ParseToplevel(p) ((p)->pToplevel ? (p)->pToplevel : (p))\n# define sqlite3IsToplevel(p) ((p)->pToplevel==0)\n#else\n# define sqlite3TriggersExist(B,C,D,E,F) 0\n# define sqlite3DeleteTrigger(A,B)\n# define sqlite3DropTriggerPtr(A,B)\n# define sqlite3UnlinkAndDeleteTrigger(A,B,C)\n# define sqlite3CodeRowTrigger(A,B,C,D,E,F,G,H,I)\n# define sqlite3CodeRowTriggerDirect(A,B,C,D,E,F)\n# define sqlite3TriggerList(X, Y) 0\n# define sqlite3ParseToplevel(p) p\n# define sqlite3IsToplevel(p) 1\n# define sqlite3TriggerColmask(A,B,C,D,E,F,G) 0\n#endif\n\nint sqlite3JoinType(Parse*, Token*, Token*, Token*);\nvoid sqlite3SetJoinExpr(Expr*,int);\nvoid sqlite3CreateForeignKey(Parse*, ExprList*, Token*, ExprList*, int);\nvoid sqlite3DeferForeignKey(Parse*, int);\n#ifndef SQLITE_OMIT_AUTHORIZATION\n  void sqlite3AuthRead(Parse*,Expr*,Schema*,SrcList*);\n  int sqlite3AuthCheck(Parse*,int, const char*, const char*, const char*);\n  void sqlite3AuthContextPush(Parse*, AuthContext*, const char*);\n  void sqlite3AuthContextPop(AuthContext*);\n  int sqlite3AuthReadCol(Parse*, const char *, const char *, int);\n#else\n# define sqlite3AuthRead(a,b,c,d)\n# define sqlite3AuthCheck(a,b,c,d,e)    SQLITE_OK\n# define sqlite3AuthContextPush(a,b,c)\n# define sqlite3AuthContextPop(a)  ((void)(a))\n#endif\nvoid sqlite3Attach(Parse*, Expr*, Expr*, Expr*);\nvoid sqlite3Detach(Parse*, Expr*);\nvoid sqlite3FixInit(DbFixer*, Parse*, int, const char*, const Token*);\nint sqlite3FixSrcList(DbFixer*, SrcList*);\nint sqlite3FixSelect(DbFixer*, Select*);\nint sqlite3FixExpr(DbFixer*, Expr*);\nint sqlite3FixExprList(DbFixer*, ExprList*);\nint sqlite3FixTriggerStep(DbFixer*, TriggerStep*);\nint sqlite3RealSameAsInt(double,sqlite3_int64);\nint sqlite3AtoF(const char *z, double*, int, u8);\nint sqlite3GetInt32(const char *, int*);\nint sqlite3Atoi(const char*);\n#ifndef SQLITE_OMIT_UTF16\nint sqlite3Utf16ByteLen(const void *pData, int nChar);\n#endif\nint sqlite3Utf8CharLen(const char *pData, int nByte);\nu32 sqlite3Utf8Read(const u8**);\nLogEst sqlite3LogEst(u64);\nLogEst sqlite3LogEstAdd(LogEst,LogEst);\n#ifndef SQLITE_OMIT_VIRTUALTABLE\nLogEst sqlite3LogEstFromDouble(double);\n#endif\n#if defined(SQLITE_ENABLE_STMT_SCANSTATUS) || \\\n    defined(SQLITE_ENABLE_STAT4) || \\\n    defined(SQLITE_EXPLAIN_ESTIMATED_ROWS)\nu64 sqlite3LogEstToInt(LogEst);\n#endif\nVList *sqlite3VListAdd(sqlite3*,VList*,const char*,int,int);\nconst char *sqlite3VListNumToName(VList*,int);\nint sqlite3VListNameToNum(VList*,const char*,int);\n\n/*\n** Routines to read and write variable-length integers.  These used to\n** be defined locally, but now we use the varint routines in the util.c\n** file.\n*/\nint sqlite3PutVarint(unsigned char*, u64);\nu8 sqlite3GetVarint(const unsigned char *, u64 *);\nu8 sqlite3GetVarint32(const unsigned char *, u32 *);\nint sqlite3VarintLen(u64 v);\n\n/*\n** The common case is for a varint to be a single byte.  They following\n** macros handle the common case without a procedure call, but then call\n** the procedure for larger varints.\n*/\n#define getVarint32(A,B)  \\\n  (u8)((*(A)<(u8)0x80)?((B)=(u32)*(A)),1:sqlite3GetVarint32((A),(u32 *)&(B)))\n#define putVarint32(A,B)  \\\n  (u8)(((u32)(B)<(u32)0x80)?(*(A)=(unsigned char)(B)),1:\\\n  sqlite3PutVarint((A),(B)))\n#define getVarint    sqlite3GetVarint\n#define putVarint    sqlite3PutVarint\n\n\nconst char *sqlite3IndexAffinityStr(sqlite3*, Index*);\nvoid sqlite3TableAffinity(Vdbe*, Table*, int);\nchar sqlite3CompareAffinity(Expr *pExpr, char aff2);\nint sqlite3IndexAffinityOk(Expr *pExpr, char idx_affinity);\nchar sqlite3TableColumnAffinity(Table*,int);\nchar sqlite3ExprAffinity(Expr *pExpr);\nint sqlite3Atoi64(const char*, i64*, int, u8);\nint sqlite3DecOrHexToI64(const char*, i64*);\nvoid sqlite3ErrorWithMsg(sqlite3*, int, const char*,...);\nvoid sqlite3Error(sqlite3*,int);\nvoid sqlite3SystemError(sqlite3*,int);\nvoid *sqlite3HexToBlob(sqlite3*, const char *z, int n);\nu8 sqlite3HexToInt(int h);\nint sqlite3TwoPartName(Parse *, Token *, Token *, Token **);\n\n#if defined(SQLITE_NEED_ERR_NAME)\nconst char *sqlite3ErrName(int);\n#endif\n\n#ifdef SQLITE_ENABLE_DESERIALIZE\nint sqlite3MemdbInit(void);\n#endif\n\nconst char *sqlite3ErrStr(int);\nint sqlite3ReadSchema(Parse *pParse);\nCollSeq *sqlite3FindCollSeq(sqlite3*,u8 enc, const char*,int);\nint sqlite3IsBinary(const CollSeq*);\nCollSeq *sqlite3LocateCollSeq(Parse *pParse, const char*zName);\nCollSeq *sqlite3ExprCollSeq(Parse *pParse, Expr *pExpr);\nCollSeq *sqlite3ExprNNCollSeq(Parse *pParse, Expr *pExpr);\nint sqlite3ExprCollSeqMatch(Parse*,Expr*,Expr*);\nExpr *sqlite3ExprAddCollateToken(Parse *pParse, Expr*, const Token*, int);\nExpr *sqlite3ExprAddCollateString(Parse*,Expr*,const char*);\nExpr *sqlite3ExprSkipCollate(Expr*);\nExpr *sqlite3ExprSkipCollateAndLikely(Expr*);\nint sqlite3CheckCollSeq(Parse *, CollSeq *);\nint sqlite3WritableSchema(sqlite3*);\nint sqlite3CheckObjectName(Parse*, const char*,const char*,const char*);\nvoid sqlite3VdbeSetChanges(sqlite3 *, int);\nint sqlite3AddInt64(i64*,i64);\nint sqlite3SubInt64(i64*,i64);\nint sqlite3MulInt64(i64*,i64);\nint sqlite3AbsInt32(int);\n#ifdef SQLITE_ENABLE_8_3_NAMES\nvoid sqlite3FileSuffix3(const char*, char*);\n#else\n# define sqlite3FileSuffix3(X,Y)\n#endif\nu8 sqlite3GetBoolean(const char *z,u8);\n\nconst void *sqlite3ValueText(sqlite3_value*, u8);\nint sqlite3ValueBytes(sqlite3_value*, u8);\nvoid sqlite3ValueSetStr(sqlite3_value*, int, const void *,u8,\n                        void(*)(void*));\nvoid sqlite3ValueSetNull(sqlite3_value*);\nvoid sqlite3ValueFree(sqlite3_value*);\n#ifndef SQLITE_UNTESTABLE\nvoid sqlite3ResultIntReal(sqlite3_context*);\n#endif\nsqlite3_value *sqlite3ValueNew(sqlite3 *);\n#ifndef SQLITE_OMIT_UTF16\nchar *sqlite3Utf16to8(sqlite3 *, const void*, int, u8);\n#endif\nint sqlite3ValueFromExpr(sqlite3 *, Expr *, u8, u8, sqlite3_value **);\nvoid sqlite3ValueApplyAffinity(sqlite3_value *, u8, u8);\n#ifndef SQLITE_AMALGAMATION\nextern const unsigned char sqlite3OpcodeProperty[];\nextern const char sqlite3StrBINARY[];\nextern const unsigned char sqlite3UpperToLower[];\nextern const unsigned char sqlite3CtypeMap[];\nextern SQLITE_WSD struct Sqlite3Config sqlite3Config;\nextern FuncDefHash sqlite3BuiltinFunctions;\n#ifndef SQLITE_OMIT_WSD\nextern int sqlite3PendingByte;\n#endif\n#endif\n#ifdef VDBE_PROFILE\nextern sqlite3_uint64 sqlite3NProfileCnt;\n#endif\nvoid sqlite3RootPageMoved(sqlite3*, int, int, int);\nvoid sqlite3Reindex(Parse*, Token*, Token*);\nvoid sqlite3AlterFunctions(void);\nvoid sqlite3AlterRenameTable(Parse*, SrcList*, Token*);\nvoid sqlite3AlterRenameColumn(Parse*, SrcList*, Token*, Token*);\nint sqlite3GetToken(const unsigned char *, int *);\nvoid sqlite3NestedParse(Parse*, const char*, ...);\nvoid sqlite3ExpirePreparedStatements(sqlite3*, int);\nvoid sqlite3CodeRhsOfIN(Parse*, Expr*, int);\nint sqlite3CodeSubselect(Parse*, Expr*);\nvoid sqlite3SelectPrep(Parse*, Select*, NameContext*);\nvoid sqlite3SelectWrongNumTermsError(Parse *pParse, Select *p);\nint sqlite3MatchSpanName(const char*, const char*, const char*, const char*);\nint sqlite3ResolveExprNames(NameContext*, Expr*);\nint sqlite3ResolveExprListNames(NameContext*, ExprList*);\nvoid sqlite3ResolveSelectNames(Parse*, Select*, NameContext*);\nint sqlite3ResolveSelfReference(Parse*,Table*,int,Expr*,ExprList*);\nint sqlite3ResolveOrderGroupBy(Parse*, Select*, ExprList*, const char*);\nvoid sqlite3ColumnDefault(Vdbe *, Table *, int, int);\nvoid sqlite3AlterFinishAddColumn(Parse *, Token *);\nvoid sqlite3AlterBeginAddColumn(Parse *, SrcList *);\nvoid *sqlite3RenameTokenMap(Parse*, void*, Token*);\nvoid sqlite3RenameTokenRemap(Parse*, void *pTo, void *pFrom);\nvoid sqlite3RenameExprUnmap(Parse*, Expr*);\nvoid sqlite3RenameExprlistUnmap(Parse*, ExprList*);\nCollSeq *sqlite3GetCollSeq(Parse*, u8, CollSeq *, const char*);\nchar sqlite3AffinityType(const char*, Column*);\nvoid sqlite3Analyze(Parse*, Token*, Token*);\nint sqlite3InvokeBusyHandler(BusyHandler*, sqlite3_file*);\nint sqlite3FindDb(sqlite3*, Token*);\nint sqlite3FindDbName(sqlite3 *, const char *);\nint sqlite3AnalysisLoad(sqlite3*,int iDB);\nvoid sqlite3DeleteIndexSamples(sqlite3*,Index*);\nvoid sqlite3DefaultRowEst(Index*);\nvoid sqlite3RegisterLikeFunctions(sqlite3*, int);\nint sqlite3IsLikeFunction(sqlite3*,Expr*,int*,char*);\nvoid sqlite3SchemaClear(void *);\nSchema *sqlite3SchemaGet(sqlite3 *, Btree *);\nint sqlite3SchemaToIndex(sqlite3 *db, Schema *);\nKeyInfo *sqlite3KeyInfoAlloc(sqlite3*,int,int);\nvoid sqlite3KeyInfoUnref(KeyInfo*);\nKeyInfo *sqlite3KeyInfoRef(KeyInfo*);\nKeyInfo *sqlite3KeyInfoOfIndex(Parse*, Index*);\nKeyInfo *sqlite3KeyInfoFromExprList(Parse*, ExprList*, int, int);\nint sqlite3HasExplicitNulls(Parse*, ExprList*);\n\n#ifdef SQLITE_DEBUG\nint sqlite3KeyInfoIsWriteable(KeyInfo*);\n#endif\nint sqlite3CreateFunc(sqlite3 *, const char *, int, int, void *,\n  void (*)(sqlite3_context*,int,sqlite3_value **),\n  void (*)(sqlite3_context*,int,sqlite3_value **), \n  void (*)(sqlite3_context*),\n  void (*)(sqlite3_context*),\n  void (*)(sqlite3_context*,int,sqlite3_value **), \n  FuncDestructor *pDestructor\n);\nvoid sqlite3NoopDestructor(void*);\nvoid sqlite3OomFault(sqlite3*);\nvoid sqlite3OomClear(sqlite3*);\nint sqlite3ApiExit(sqlite3 *db, int);\nint sqlite3OpenTempDatabase(Parse *);\n\nvoid sqlite3StrAccumInit(StrAccum*, sqlite3*, char*, int, int);\nchar *sqlite3StrAccumFinish(StrAccum*);\nvoid sqlite3SelectDestInit(SelectDest*,int,int);\nExpr *sqlite3CreateColumnExpr(sqlite3 *, SrcList *, int, int);\n\nvoid sqlite3BackupRestart(sqlite3_backup *);\nvoid sqlite3BackupUpdate(sqlite3_backup *, Pgno, const u8 *);\n\n#ifndef SQLITE_OMIT_SUBQUERY\nint sqlite3ExprCheckIN(Parse*, Expr*);\n#else\n# define sqlite3ExprCheckIN(x,y) SQLITE_OK\n#endif\n\n#ifdef SQLITE_ENABLE_STAT4\nint sqlite3Stat4ProbeSetValue(\n    Parse*,Index*,UnpackedRecord**,Expr*,int,int,int*);\nint sqlite3Stat4ValueFromExpr(Parse*, Expr*, u8, sqlite3_value**);\nvoid sqlite3Stat4ProbeFree(UnpackedRecord*);\nint sqlite3Stat4Column(sqlite3*, const void*, int, int, sqlite3_value**);\nchar sqlite3IndexColumnAffinity(sqlite3*, Index*, int);\n#endif\n\n/*\n** The interface to the LEMON-generated parser\n*/\n#ifndef SQLITE_AMALGAMATION\n  void *sqlite3ParserAlloc(void*(*)(u64), Parse*);\n  void sqlite3ParserFree(void*, void(*)(void*));\n#endif\nvoid sqlite3Parser(void*, int, Token);\nint sqlite3ParserFallback(int);\n#ifdef YYTRACKMAXSTACKDEPTH\n  int sqlite3ParserStackPeak(void*);\n#endif\n\nvoid sqlite3AutoLoadExtensions(sqlite3*);\n#ifndef SQLITE_OMIT_LOAD_EXTENSION\n  void sqlite3CloseExtensions(sqlite3*);\n#else\n# define sqlite3CloseExtensions(X)\n#endif\n\n#ifndef SQLITE_OMIT_SHARED_CACHE\n  void sqlite3TableLock(Parse *, int, int, u8, const char *);\n#else\n  #define sqlite3TableLock(v,w,x,y,z)\n#endif\n\n#ifdef SQLITE_TEST\n  int sqlite3Utf8To8(unsigned char*);\n#endif\n\n#ifdef SQLITE_OMIT_VIRTUALTABLE\n#  define sqlite3VtabClear(Y)\n#  define sqlite3VtabSync(X,Y) SQLITE_OK\n#  define sqlite3VtabRollback(X)\n#  define sqlite3VtabCommit(X)\n#  define sqlite3VtabInSync(db) 0\n#  define sqlite3VtabLock(X)\n#  define sqlite3VtabUnlock(X)\n#  define sqlite3VtabModuleUnref(D,X)\n#  define sqlite3VtabUnlockList(X)\n#  define sqlite3VtabSavepoint(X, Y, Z) SQLITE_OK\n#  define sqlite3GetVTable(X,Y)  ((VTable*)0)\n#else\n   void sqlite3VtabClear(sqlite3 *db, Table*);\n   void sqlite3VtabDisconnect(sqlite3 *db, Table *p);\n   int sqlite3VtabSync(sqlite3 *db, Vdbe*);\n   int sqlite3VtabRollback(sqlite3 *db);\n   int sqlite3VtabCommit(sqlite3 *db);\n   void sqlite3VtabLock(VTable *);\n   void sqlite3VtabUnlock(VTable *);\n   void sqlite3VtabModuleUnref(sqlite3*,Module*);\n   void sqlite3VtabUnlockList(sqlite3*);\n   int sqlite3VtabSavepoint(sqlite3 *, int, int);\n   void sqlite3VtabImportErrmsg(Vdbe*, sqlite3_vtab*);\n   VTable *sqlite3GetVTable(sqlite3*, Table*);\n   Module *sqlite3VtabCreateModule(\n     sqlite3*,\n     const char*,\n     const sqlite3_module*,\n     void*,\n     void(*)(void*)\n   );\n#  define sqlite3VtabInSync(db) ((db)->nVTrans>0 && (db)->aVTrans==0)\n#endif\nint sqlite3ReadOnlyShadowTables(sqlite3 *db);\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n  int sqlite3ShadowTableName(sqlite3 *db, const char *zName);\n#else\n# define sqlite3ShadowTableName(A,B) 0\n#endif\nint sqlite3VtabEponymousTableInit(Parse*,Module*);\nvoid sqlite3VtabEponymousTableClear(sqlite3*,Module*);\nvoid sqlite3VtabMakeWritable(Parse*,Table*);\nvoid sqlite3VtabBeginParse(Parse*, Token*, Token*, Token*, int);\nvoid sqlite3VtabFinishParse(Parse*, Token*);\nvoid sqlite3VtabArgInit(Parse*);\nvoid sqlite3VtabArgExtend(Parse*, Token*);\nint sqlite3VtabCallCreate(sqlite3*, int, const char *, char **);\nint sqlite3VtabCallConnect(Parse*, Table*);\nint sqlite3VtabCallDestroy(sqlite3*, int, const char *);\nint sqlite3VtabBegin(sqlite3 *, VTable *);\nFuncDef *sqlite3VtabOverloadFunction(sqlite3 *,FuncDef*, int nArg, Expr*);\nsqlite3_int64 sqlite3StmtCurrentTime(sqlite3_context*);\nint sqlite3VdbeParameterIndex(Vdbe*, const char*, int);\nint sqlite3TransferBindings(sqlite3_stmt *, sqlite3_stmt *);\nvoid sqlite3ParserReset(Parse*);\n#ifdef SQLITE_ENABLE_NORMALIZE\nchar *sqlite3Normalize(Vdbe*, const char*);\n#endif\nint sqlite3Reprepare(Vdbe*);\nvoid sqlite3ExprListCheckLength(Parse*, ExprList*, const char*);\nCollSeq *sqlite3ExprCompareCollSeq(Parse*,Expr*);\nCollSeq *sqlite3BinaryCompareCollSeq(Parse *, Expr *, Expr *);\nint sqlite3TempInMemory(const sqlite3*);\nconst char *sqlite3JournalModename(int);\n#ifndef SQLITE_OMIT_WAL\n  int sqlite3Checkpoint(sqlite3*, int, int, int*, int*);\n  int sqlite3WalDefaultHook(void*,sqlite3*,const char*,int);\n#endif\n#ifndef SQLITE_OMIT_CTE\n  With *sqlite3WithAdd(Parse*,With*,Token*,ExprList*,Select*);\n  void sqlite3WithDelete(sqlite3*,With*);\n  void sqlite3WithPush(Parse*, With*, u8);\n#else\n#define sqlite3WithPush(x,y,z)\n#define sqlite3WithDelete(x,y)\n#endif\n#ifndef SQLITE_OMIT_UPSERT\n  Upsert *sqlite3UpsertNew(sqlite3*,ExprList*,Expr*,ExprList*,Expr*);\n  void sqlite3UpsertDelete(sqlite3*,Upsert*);\n  Upsert *sqlite3UpsertDup(sqlite3*,Upsert*);\n  int sqlite3UpsertAnalyzeTarget(Parse*,SrcList*,Upsert*);\n  void sqlite3UpsertDoUpdate(Parse*,Upsert*,Table*,Index*,int);\n#else\n#define sqlite3UpsertNew(v,w,x,y,z) ((Upsert*)0)\n#define sqlite3UpsertDelete(x,y)\n#define sqlite3UpsertDup(x,y)       ((Upsert*)0)\n#endif\n\n\n/* Declarations for functions in fkey.c. All of these are replaced by\n** no-op macros if OMIT_FOREIGN_KEY is defined. In this case no foreign\n** key functionality is available. If OMIT_TRIGGER is defined but\n** OMIT_FOREIGN_KEY is not, only some of the functions are no-oped. In\n** this case foreign keys are parsed, but no other functionality is\n** provided (enforcement of FK constraints requires the triggers sub-system).\n*/\n#if !defined(SQLITE_OMIT_FOREIGN_KEY) && !defined(SQLITE_OMIT_TRIGGER)\n  void sqlite3FkCheck(Parse*, Table*, int, int, int*, int);\n  void sqlite3FkDropTable(Parse*, SrcList *, Table*);\n  void sqlite3FkActions(Parse*, Table*, ExprList*, int, int*, int);\n  int sqlite3FkRequired(Parse*, Table*, int*, int);\n  u32 sqlite3FkOldmask(Parse*, Table*);\n  FKey *sqlite3FkReferences(Table *);\n#else\n  #define sqlite3FkActions(a,b,c,d,e,f)\n  #define sqlite3FkCheck(a,b,c,d,e,f)\n  #define sqlite3FkDropTable(a,b,c)\n  #define sqlite3FkOldmask(a,b)         0\n  #define sqlite3FkRequired(a,b,c,d)    0\n  #define sqlite3FkReferences(a)        0\n#endif\n#ifndef SQLITE_OMIT_FOREIGN_KEY\n  void sqlite3FkDelete(sqlite3 *, Table*);\n  int sqlite3FkLocateIndex(Parse*,Table*,FKey*,Index**,int**);\n#else\n  #define sqlite3FkDelete(a,b)\n  #define sqlite3FkLocateIndex(a,b,c,d,e)\n#endif\n\n\n/*\n** Available fault injectors.  Should be numbered beginning with 0.\n*/\n#define SQLITE_FAULTINJECTOR_MALLOC     0\n#define SQLITE_FAULTINJECTOR_COUNT      1\n\n/*\n** The interface to the code in fault.c used for identifying \"benign\"\n** malloc failures. This is only present if SQLITE_UNTESTABLE\n** is not defined.\n*/\n#ifndef SQLITE_UNTESTABLE\n  void sqlite3BeginBenignMalloc(void);\n  void sqlite3EndBenignMalloc(void);\n#else\n  #define sqlite3BeginBenignMalloc()\n  #define sqlite3EndBenignMalloc()\n#endif\n\n/*\n** Allowed return values from sqlite3FindInIndex()\n*/\n#define IN_INDEX_ROWID        1   /* Search the rowid of the table */\n#define IN_INDEX_EPH          2   /* Search an ephemeral b-tree */\n#define IN_INDEX_INDEX_ASC    3   /* Existing index ASCENDING */\n#define IN_INDEX_INDEX_DESC   4   /* Existing index DESCENDING */\n#define IN_INDEX_NOOP         5   /* No table available. Use comparisons */\n/*\n** Allowed flags for the 3rd parameter to sqlite3FindInIndex().\n*/\n#define IN_INDEX_NOOP_OK     0x0001  /* OK to return IN_INDEX_NOOP */\n#define IN_INDEX_MEMBERSHIP  0x0002  /* IN operator used for membership test */\n#define IN_INDEX_LOOP        0x0004  /* IN operator used as a loop */\nint sqlite3FindInIndex(Parse *, Expr *, u32, int*, int*, int*);\n\nint sqlite3JournalOpen(sqlite3_vfs *, const char *, sqlite3_file *, int, int);\nint sqlite3JournalSize(sqlite3_vfs *);\n#if defined(SQLITE_ENABLE_ATOMIC_WRITE) \\\n || defined(SQLITE_ENABLE_BATCH_ATOMIC_WRITE)\n  int sqlite3JournalCreate(sqlite3_file *);\n#endif\n\nint sqlite3JournalIsInMemory(sqlite3_file *p);\nvoid sqlite3MemJournalOpen(sqlite3_file *);\n\nvoid sqlite3ExprSetHeightAndFlags(Parse *pParse, Expr *p);\n#if SQLITE_MAX_EXPR_DEPTH>0\n  int sqlite3SelectExprHeight(Select *);\n  int sqlite3ExprCheckHeight(Parse*, int);\n#else\n  #define sqlite3SelectExprHeight(x) 0\n  #define sqlite3ExprCheckHeight(x,y)\n#endif\n\nu32 sqlite3Get4byte(const u8*);\nvoid sqlite3Put4byte(u8*, u32);\n\n#ifdef SQLITE_ENABLE_UNLOCK_NOTIFY\n  void sqlite3ConnectionBlocked(sqlite3 *, sqlite3 *);\n  void sqlite3ConnectionUnlocked(sqlite3 *db);\n  void sqlite3ConnectionClosed(sqlite3 *db);\n#else\n  #define sqlite3ConnectionBlocked(x,y)\n  #define sqlite3ConnectionUnlocked(x)\n  #define sqlite3ConnectionClosed(x)\n#endif\n\n#ifdef SQLITE_DEBUG\n  void sqlite3ParserTrace(FILE*, char *);\n#endif\n#if defined(YYCOVERAGE)\n  int sqlite3ParserCoverage(FILE*);\n#endif\n\n/*\n** If the SQLITE_ENABLE IOTRACE exists then the global variable\n** sqlite3IoTrace is a pointer to a printf-like routine used to\n** print I/O tracing messages.\n*/\n#ifdef SQLITE_ENABLE_IOTRACE\n# define IOTRACE(A)  if( sqlite3IoTrace ){ sqlite3IoTrace A; }\n  void sqlite3VdbeIOTraceSql(Vdbe*);\nSQLITE_API SQLITE_EXTERN void (SQLITE_CDECL *sqlite3IoTrace)(const char*,...);\n#else\n# define IOTRACE(A)\n# define sqlite3VdbeIOTraceSql(X)\n#endif\n\n/*\n** These routines are available for the mem2.c debugging memory allocator\n** only.  They are used to verify that different \"types\" of memory\n** allocations are properly tracked by the system.\n**\n** sqlite3MemdebugSetType() sets the \"type\" of an allocation to one of\n** the MEMTYPE_* macros defined below.  The type must be a bitmask with\n** a single bit set.\n**\n** sqlite3MemdebugHasType() returns true if any of the bits in its second\n** argument match the type set by the previous sqlite3MemdebugSetType().\n** sqlite3MemdebugHasType() is intended for use inside assert() statements.\n**\n** sqlite3MemdebugNoType() returns true if none of the bits in its second\n** argument match the type set by the previous sqlite3MemdebugSetType().\n**\n** Perhaps the most important point is the difference between MEMTYPE_HEAP\n** and MEMTYPE_LOOKASIDE.  If an allocation is MEMTYPE_LOOKASIDE, that means\n** it might have been allocated by lookaside, except the allocation was\n** too large or lookaside was already full.  It is important to verify\n** that allocations that might have been satisfied by lookaside are not\n** passed back to non-lookaside free() routines.  Asserts such as the\n** example above are placed on the non-lookaside free() routines to verify\n** this constraint.\n**\n** All of this is no-op for a production build.  It only comes into\n** play when the SQLITE_MEMDEBUG compile-time option is used.\n*/\n#ifdef SQLITE_MEMDEBUG\n  void sqlite3MemdebugSetType(void*,u8);\n  int sqlite3MemdebugHasType(void*,u8);\n  int sqlite3MemdebugNoType(void*,u8);\n#else\n# define sqlite3MemdebugSetType(X,Y)  /* no-op */\n# define sqlite3MemdebugHasType(X,Y)  1\n# define sqlite3MemdebugNoType(X,Y)   1\n#endif\n#define MEMTYPE_HEAP       0x01  /* General heap allocations */\n#define MEMTYPE_LOOKASIDE  0x02  /* Heap that might have been lookaside */\n#define MEMTYPE_PCACHE     0x04  /* Page cache allocations */\n\n/*\n** Threading interface\n*/\n#if SQLITE_MAX_WORKER_THREADS>0\nint sqlite3ThreadCreate(SQLiteThread**,void*(*)(void*),void*);\nint sqlite3ThreadJoin(SQLiteThread*, void**);\n#endif\n\n#if defined(SQLITE_ENABLE_DBPAGE_VTAB) || defined(SQLITE_TEST)\nint sqlite3DbpageRegister(sqlite3*);\n#endif\n#if defined(SQLITE_ENABLE_DBSTAT_VTAB) || defined(SQLITE_TEST)\nint sqlite3DbstatRegister(sqlite3*);\n#endif\n\nint sqlite3ExprVectorSize(Expr *pExpr);\nint sqlite3ExprIsVector(Expr *pExpr);\nExpr *sqlite3VectorFieldSubexpr(Expr*, int);\nExpr *sqlite3ExprForVectorField(Parse*,Expr*,int);\nvoid sqlite3VectorErrorMsg(Parse*, Expr*);\n\n#ifndef SQLITE_OMIT_COMPILEOPTION_DIAGS\nconst char **sqlite3CompileOptions(int *pnOpt);\n#endif\n\n#endif /* SQLITEINT_H */\n", "# 2019 January 23\n#\n# The author disclaims copyright to this source code.  In place of\n# a legal notice, here is a blessing:\n#\n#    May you do good and not evil.\n#    May you find forgiveness for yourself and forgive others.\n#    May you share freely, never taking more than you give.\n#\n#*************************************************************************\n#\n\nset testdir [file dirname $argv0]\nsource $testdir/tester.tcl\nset testprefix altertab3\n\n# If SQLITE_OMIT_ALTERTABLE is defined, omit this file.\nifcapable !altertable {\n  finish_test\n  return\n}\n\nifcapable windowfunc {\ndo_execsql_test 1.0 {\n  CREATE TABLE t1(a, b);\n  CREATE TRIGGER tr1 AFTER INSERT ON t1 BEGIN\n    SELECT sum(b) OVER w FROM t1 WINDOW w AS (ORDER BY a);\n  END;\n}\n\ndo_execsql_test 1.1 {\n  ALTER TABLE t1 RENAME a TO aaa;\n}\n\ndo_execsql_test 1.2 {\n  SELECT sql FROM sqlite_master WHERE name='tr1'\n} {{CREATE TRIGGER tr1 AFTER INSERT ON t1 BEGIN\n    SELECT sum(b) OVER w FROM t1 WINDOW w AS (ORDER BY aaa);\n  END}}\n\ndo_execsql_test 1.3 {\n  INSERT INTO t1 VALUES(1, 2);\n}\n} ;# windowfunc\n\n#-------------------------------------------------------------------------\nreset_db\ndo_execsql_test 2.0 {\n  CREATE TABLE t1(a,b,c);\n  CREATE TABLE t2(a,b,c);\n  CREATE TRIGGER r1 AFTER INSERT ON t1 WHEN new.a NOT NULL BEGIN\n    SELECT a,b, a name FROM t1 \n      INTERSECT \n    SELECT a,b,c FROM t1 WHERE b>='d' ORDER BY name;\n    SELECT new.c;\n  END;\n}\n\ndo_execsql_test 2.1 {\n  ALTER TABLE t1 RENAME TO t1x;\n  SELECT sql FROM sqlite_master WHERE name = 'r1';\n} {{CREATE TRIGGER r1 AFTER INSERT ON \"t1x\" WHEN new.a NOT NULL BEGIN\n    SELECT a,b, a name FROM \"t1x\" \n      INTERSECT \n    SELECT a,b,c FROM \"t1x\" WHERE b>='d' ORDER BY name;\n    SELECT new.c;\n  END}}\n\n#-------------------------------------------------------------------------\nreset_db\ndo_execsql_test 3.0 {\n  CREATE TABLE t1(a, b, c, d);\n  CREATE VIEW v1 AS SELECT * FROM t1 WHERE a=1 OR (b IN ());\n}\n\ndo_execsql_test 3.1 {\n  ALTER TABLE t1 RENAME b TO bbb;\n}\n\ndo_execsql_test 3.2 {\n  SELECT sql FROM sqlite_master WHERE name = 'v1'\n} {{CREATE VIEW v1 AS SELECT * FROM t1 WHERE a=1 OR (b IN ())}}\n\n#-------------------------------------------------------------------------\nreset_db\ndo_execsql_test 4.0 {\n  CREATE TABLE t1(a, b);\n  CREATE TABLE t3(e, f);\n  CREATE TRIGGER tr1 AFTER INSERT ON t1 BEGIN\n    INSERT INTO t2 VALUES(new.a, new.b);\n  END;\n}\n\ndo_catchsql_test 4.1.2 {\n  BEGIN;\n    ALTER TABLE t3 RENAME TO t4;\n} {1 {error in trigger tr1: no such table: main.t2}}\ndo_execsql_test 4.1.2 {\n  COMMIT;\n}\ndo_execsql_test 4.1.3 {\n  SELECT type, name, tbl_name, sql \n  FROM sqlite_master WHERE type='table' AND name!='t1';\n} {table t3 t3 {CREATE TABLE t3(e, f)}}\n\n\ndo_catchsql_test 4.2.1 {\n  BEGIN;\n    ALTER TABLE t3 RENAME e TO eee;\n} {1 {error in trigger tr1: no such table: main.t2}}\ndo_execsql_test 4.2.2 {\n  COMMIT;\n}\ndo_execsql_test 4.2.3 {\n  SELECT type, name, tbl_name, sql \n  FROM sqlite_master WHERE type='table' AND name!='t1';\n} {table t3 t3 {CREATE TABLE t3(e, f)}}\n\n#-------------------------------------------------------------------------\nreset_db\ndo_execsql_test 5.0 {\n  CREATE TABLE t1 (\n      c1 integer, c2, PRIMARY KEY(c1 collate rtrim),\n      UNIQUE(c2)\n  )\n}\ndo_execsql_test 5.1 {\n  ALTER TABLE t1 RENAME c1 TO c3;\n}\n\n#-------------------------------------------------------------------------\nreset_db\ndo_execsql_test 6.0 {\n  CREATE TEMPORARY TABLE Table0 (\n    Col0 INTEGER, \n    PRIMARY KEY(Col0 COLLATE RTRIM), \n    FOREIGN KEY (Col0) REFERENCES Table0\n  );\n}\n\ndo_execsql_test 6.1 {\n  ALTER TABLE Table0 RENAME Col0 TO Col0;\n}\n\n#-------------------------------------------------------------------------\nreset_db\ndo_execsql_test 7.1.0 {\n  CREATE TABLE t1(a,b,c);\n  CREATE TRIGGER AFTER INSERT ON t1 BEGIN\n    SELECT a, rank() OVER w1 FROM t1\n    WINDOW w1 AS (PARTITION BY b, percent_rank() OVER w1);\n  END;\n}\n\ndo_execsql_test 7.1.2 {\n  ALTER TABLE t1 RENAME TO t1x;\n  SELECT sql FROM sqlite_master;\n} {\n  {CREATE TABLE \"t1x\"(a,b,c)}\n  {CREATE TRIGGER AFTER INSERT ON \"t1x\" BEGIN\n    SELECT a, rank() OVER w1 FROM \"t1x\"\n    WINDOW w1 AS (PARTITION BY b, percent_rank() OVER w1);\n  END}\n}\n\ndo_execsql_test 7.2.1 {\n  DROP TRIGGER after;\n  CREATE TRIGGER AFTER INSERT ON t1x BEGIN\n    SELECT a, rank() OVER w1 FROM t1x\n    WINDOW w1 AS (PARTITION BY b, percent_rank() OVER w1 ORDER BY d);\n  END;\n}\n\ndo_catchsql_test 7.2.2 {\n  ALTER TABLE t1x RENAME TO t1;\n} {1 {error in trigger AFTER: no such column: d}}\n\n#-------------------------------------------------------------------------\nreset_db\ndo_execsql_test 8.0 {\n  CREATE TABLE t0(c0);\n  CREATE INDEX i0 ON t0('1' IN ());\n}\ndo_execsql_test 8.1 {\n  ALTER TABLE t0 RENAME TO t1;\n  SELECT sql FROM sqlite_master;\n} {\n  {CREATE TABLE \"t1\"(c0)}\n  {CREATE INDEX i0 ON \"t1\"('1' IN ())}\n}\ndo_execsql_test 8.2.1 {\n  CREATE TABLE t2 (c0);\n  CREATE INDEX i2 ON t2((LIKELIHOOD(c0, 100) IN ()));\n  ALTER TABLE t2 RENAME COLUMN c0 TO c1;\n}\ndo_execsql_test 8.2.2 {\n  SELECT sql FROM sqlite_master WHERE tbl_name = 't2';\n} {\n  {CREATE TABLE t2 (c1)} \n  {CREATE INDEX i2 ON t2((LIKELIHOOD(c0, 100) IN ()))}\n}\ndo_test 8.2.3 {\n  sqlite3 db2 test.db\n  db2 eval { INSERT INTO t2 VALUES (1), (2), (3) }\n  db close\n} {}\ndb2 close\n\n#-------------------------------------------------------------------------\nreset_db\ndo_execsql_test 9.1 {\n  CREATE TABLE t1(a,b,c);\n  CREATE TRIGGER AFTER INSERT ON t1 WHEN new.a NOT NULL BEGIN\n    SELECT true WHERE (SELECT a, b FROM (t1)) IN ();\n  END;\n}\ndo_execsql_test 9.2 {\n  ALTER TABLE t1 RENAME TO t1x;\n}\n\n#-------------------------------------------------------------------------\nreset_db\ndo_execsql_test 10.1 {\n  CREATE TABLE t1(a, b, c);\n  CREATE TABLE t2(a, b, c);\n  CREATE VIEW v1 AS SELECT * FROM t1 WHERE (\n    SELECT t1.a FROM t1, t2\n  ) IN () OR t1.a=5;\n}\n\ndo_execsql_test 10.2 {\n  ALTER TABLE t2 RENAME TO t3;\n  SELECT sql FROM sqlite_master WHERE name='v1';\n} {\n  {CREATE VIEW v1 AS SELECT * FROM t1 WHERE (\n    SELECT t1.a FROM t1, t2\n  ) IN () OR t1.a=5}\n}\n\n#-------------------------------------------------------------------------\nreset_db\ndo_execsql_test 11.1 {\n  CREATE TABLE t1(\n      a,b,c,d,e,f,g,h,j,jj,jjb,k,aa,bb,cc,dd,ee DEFAULT 3.14,\n      ff DEFAULT('hiccup'),Wg NOD NULL DEFAULT(false)\n  );\n\n  CREATE TRIGGER b AFTER INSERT ON t1 WHEN new.a BEGIN\n    SELECT a, sum() w3 FROM t1 \n    WINDOW b AS (ORDER BY NOT EXISTS(SELECT 1 FROM abc));\n  END;\n}\n\ndo_catchsql_test 11.2 {\n  ALTER TABLE t1 RENAME TO t1x;\n} {1 {error in trigger b: no such table: abc}}\n\ndo_execsql_test 11.3 {\n  DROP TRIGGER b;\n  CREATE TRIGGER b AFTER INSERT ON t1 WHEN new.a BEGIN\n    SELECT a, sum() w3 FROM t1 \n    WINDOW b AS (ORDER BY NOT EXISTS(SELECT 1 FROM t1));\n  END;\n} {}\n\ndo_execsql_test 11.4 {\n  ALTER TABLE t1 RENAME TO t1x;\n  SELECT sql FROM sqlite_master WHERE name = 'b';\n} {\n{CREATE TRIGGER b AFTER INSERT ON \"t1x\" WHEN new.a BEGIN\n    SELECT a, sum() w3 FROM \"t1x\" \n    WINDOW b AS (ORDER BY NOT EXISTS(SELECT 1 FROM \"t1x\"));\n  END}\n}\n\n#-------------------------------------------------------------------------\nreset_db\ndo_execsql_test 12.1 {\nCREATE TABLE t1(a,b,c,d,e,f,g,h,j,jj,Zjj,k,aQ,bb,cc,dd,ee DEFAULT 3.14,\nff DEFAULT('hiccup'),gg NOD NULL DEFAULT(false));\nCREATE TRIGGER AFTER INSERT ON t1 WHEN new.a NOT NULL BEGIN\n\nSELECT b () OVER , dense_rank() OVER d, d () OVER w1\nFROM t1\nWINDOW\nw1 AS\n( w1 ORDER BY d\nROWS BETWEEN 2 NOT IN(SELECT a, sum(d) w2,max(d)OVER FROM t1\nWINDOW\nw1 AS\n(PARTITION BY d\nROWS BETWEEN '' PRECEDING AND false FOLLOWING),\nd AS\n(PARTITION BY b ORDER BY d\nROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)\n) PRECEDING AND 1 FOLLOWING),\nw2 AS\n(PARTITION BY b ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW),\nw3 AS\n(PARTITION BY b ORDER BY d\nROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)\n;\nSELECT a, sum(d) w2,max(d)OVER FROM t1\nWINDOW\nw1 AS\n(PARTITION BY d\nROWS BETWEEN '' PRECEDING AND false FOLLOWING),\nd AS\n(PARTITION BY b ORDER BY d\nROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)\n;\n\nEND;\n}\n\ndo_execsql_test 12.2 {\n  ALTER TABLE t1 RENAME TO t1x;\n}\n\n#-------------------------------------------------------------------------\nreset_db\ndo_execsql_test 13.1 {\n  CREATE TABLE t1(a);\n  CREATE TRIGGER r1 INSERT ON t1 BEGIN\n    SELECT a(*) OVER (ORDER BY (SELECT 1)) FROM t1;\n  END;\n}\n\ndo_execsql_test 13.2 {\n  ALTER TABLE t1 RENAME TO t1x;\n}\n\n#-------------------------------------------------------------------------\nreset_db\ndo_execsql_test 14.1 {\n  CREATE TABLE t1(a);\n  CREATE TABLE t2(b);\n  CREATE TRIGGER AFTER INSERT ON t1 BEGIN\n    SELECT sum() FILTER (WHERE (SELECT sum() FILTER (WHERE 0)) AND a);\n  END;\n}\n\ndo_catchsql_test 14.2 {\n  ALTER TABLE t1 RENAME TO t1x;\n} {1 {error in trigger AFTER: no such column: a}}\n\n#-------------------------------------------------------------------------\nreset_db\n\ndo_execsql_test 16.1 {\n  CREATE TABLE t1(x);\n  CREATE TRIGGER AFTER INSERT ON t1 BEGIN\n    SELECT (WITH t2 AS (WITH t3 AS (SELECT true)\n          SELECT * FROM t3 ORDER BY true COLLATE nocase)\n        SELECT 11);\n\n    WITH t4 AS (SELECT * FROM t1) SELECT 33;\n  END;\n}\ndo_execsql_test 16.2 {\n  ALTER TABLE t1 RENAME TO t1x;\n}\n\n#-------------------------------------------------------------------------\nreset_db\ndo_execsql_test 17.1 {\n  CREATE TABLE t1(a,b,c);\n  CREATE TRIGGER AFTER INSERT ON t1 WHEN new.a NOT NULL BEGIN\n    SELECT a () FILTER (WHERE a>0) FROM t1;\n  END;\n}\n\ndo_execsql_test 17.2 {\n  ALTER TABLE t1 RENAME TO t1x;\n  ALTER TABLE t1x RENAME a TO aaa;\n  SELECT sql FROM sqlite_master WHERE type='trigger';\n} {\n{CREATE TRIGGER AFTER INSERT ON \"t1x\" WHEN new.aaa NOT NULL BEGIN\n    SELECT a () FILTER (WHERE aaa>0) FROM \"t1x\";\n  END}\n}\n\n#-------------------------------------------------------------------------\nreset_db\ndo_execsql_test 18.1 {\n  CREATE TABLE t1(a,b);\n  CREATE TRIGGER r1 AFTER INSERT ON t1 BEGIN\n    SELECT a, b FROM t1\n    INTERSECT SELECT b,a FROM t1\n    ORDER BY b IN (\n        SELECT a UNION SELECT b\n        FROM t1\n        ORDER BY b COLLATE nocase\n        )\n    ;\n  END;\n}\n\ndo_catchsql_test 18.2 {\n    SELECT a, b FROM t1\n    INTERSECT \n    SELECT b,a FROM t1\n    ORDER BY b IN (\n        SELECT a UNION SELECT b\n        FROM t1\n        ORDER BY b COLLATE nocase\n        );\n} {1 {1st ORDER BY term does not match any column in the result set}}\n\ndo_catchsql_test 18.3 {\n  ALTER TABLE t1 RENAME TO t1x;\n} {1 {error in trigger r1: 1st ORDER BY term does not match any column in the result set}}\n\n#-------------------------------------------------------------------------\nreset_db \ndo_execsql_test 19.0 {\n  CREATE TABLE a(a,h CONSTRAINT a UNIQUE ON CONFLICT FAIL,CONSTRAINT a);\n}\n\nforeach {tn v res} {\n  1 {\n    CREATE VIEW q AS SELECT 123\n    \n      WINDOW x AS (\n        RANGE BETWEEN UNBOUNDED PRECEDING AND INDEXED() OVER(\n          PARTITION BY ( WITH x AS(VALUES(col1)) VALUES(453) )\n        )\n      FOLLOWING\n    ) \n  } {1 {error in view q: no such column: col1}}\n\n  2 {\n    CREATE VIEW q AS SELECT\n    CAST(CAST(CAST(CAST(CAST(CAST(CAST(CAST(CAST(CAST(CAST(RIGHT\n    AS)AS)AS)AS)AS)AS)AS)AS)AS)AS)AS)WINDOW x AS(RANGE BETWEEN UNBOUNDED\n    PRECEDING AND INDEXED(*)OVER(PARTITION BY\n    CROSS,CROSS,NATURAL,sqlite_master(*)OVER a,(WITH a AS(VALUES(LEFT)UNION\n    VALUES(LEFT)UNION VALUES(LEFT)UNION VALUES(LEFT)UNION VALUES(LEFT)UNION\n    VALUES(LEFT)UNION VALUES(LEFT))VALUES(LEFT))IN\n    STORED,LEFT,LEFT,LEFT,LEFT,LEFT,LEFT)*LEFT FOLLOWING)ORDER BY\n    LEFT,LEFT,LEFT,LEFT,LEFT,LEFT,LEFT,LEFT,LEFT,LEFT,LEFT LIMIT\n    LEFT,INDEXED(*)OVER(PARTITION BY\n    CROSS,CROSS,CROSS,LEFT,INDEXED(*)OVER(PARTITION BY\n    CROSS,CROSS,CROSS),INDEXED(*)OVER(PARTITION BY\n    LEFT,LEFT,LEFT,LEFT,LEFT,LEFT,LEFT,LEFT,LEFT,LEFT,LEFT),\n    LEFT,LEFT,INNER,CROSS,CROSS,CROSS,INNER,NATURAL ORDER BY\n    OUTER,NATURAL,NATURAL,NATURAL,NATURAL,NATURAL,NATURAL,NATURAL,INNER,\n    INNER,INNER NULLS LAST GROUPS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED\n    FOLLOWING); \n  } {1 {error in view q: no such column: LEFT}}\n\n  3 {\n    CREATE VIEW q AS SELECT 99 WINDOW x AS (RANGE BETWEEN UNBOUNDED PRECEDING\n    AND count(*)OVER(PARTITION BY (WITH a AS(VALUES(2),(x3))VALUES(0)))\n    FOLLOWING)ORDER BY x2,sum(1)OVER(PARTITION BY avg(5)OVER(PARTITION BY x1));\n  } {1 {error in view q: no such column: x3}}\n} {\n  do_execsql_test 19.$tn.1 \"\n    DROP VIEW IF EXISTS q;\n    $v\n  \" {}\n\n  do_catchsql_test 19.$tn.2 {\n    ALTER TABLE a RENAME TO g;\n  } $res\n}\n\n# Verify that the \"if( pParse->nErr ) return WRC_Abort\" at the top of the\n# renameUnmapSelectCb() routine in alter.c (2019-12-04) is really required.\n#\nsqlite3 db :memory:\ndo_catchsql_test 20.10 {\n  CREATE TABLE s(a, b, c);\n  CREATE INDEX k ON s( (WITH s AS( SELECT * ) VALUES(2) ) IN () );\n  ALTER TABLE s RENAME a TO a2;\n} {1 {error in index k: no tables specified}}\n\n#------------------------------------------------------------------------\n#\nreset_db\ndo_execsql_test 21.1 {\n  CREATE TABLE s(col);\n  CREATE VIEW v AS SELECT ( \n    WITH x(a) AS(SELECT * FROM s) VALUES(RIGHT) \n  ) IN() ; \n  CREATE TABLE a(a);\n  ALTER TABLE a RENAME a TO b;\n}\n\n\nfinish_test\n"], "fixing_code": ["C Avoid\\sinfinite\\srecursion\\sin\\sthe\\sALTER\\sTABLE\\scode\\swhen\\sa\\sview\\scontains\\san\\sunused\\sCTE\\sthat\\sreferences,\\sdirectly\\sor\\sindirectly,\\sthe\\sview\\sitself.\nD 2019-12-09T08:13:43.318\nF .fossil-settings/empty-dirs dbb81e8fc0401ac46a1491ab34a7f2c7c0452f2f06b54ebb845d024ca8283ef1\nF .fossil-settings/ignore-glob 35175cdfcf539b2318cb04a9901442804be81cd677d8b889fcc9149c21f239ea\nF LICENSE.md df5091916dbb40e6e9686186587125e1b2ff51f022cc334e886c19a0e9982724\nF Makefile.in d3a862c9742f5a08230a3b295c0a47fd3067f19356dc39935280135f90474b04\nF Makefile.linux-gcc f609543700659711fbd230eced1f01353117621dccae7b9fb70daa64236c5241\nF Makefile.msc 0b0acbf34bb238170bdf1fd343a1fd37bc81c042ce029c1cc53fe15b5d4ed07b\nF README.md 1514a365ffca3c138e00c5cc839906108a01011a6b082bad19b09781e3aa498a\nF VERSION 081500f0aeaadc989d85aafbc717af45512018aebc73d89e5c2368fe62a600ff\nF aclocal.m4 a5c22d164aff7ed549d53a90fa56d56955281f50\nF art/sqlite370.eps aa97a671332b432a54e1d74ff5e8775be34200c2\nF art/sqlite370.ico af56c1d00fee7cd4753e8631ed60703ed0fc6e90\nF art/sqlite370.jpg d512473dae7e378a67e28ff96a34da7cb331def2\nF autoconf/INSTALL 83e4a25da9fd053c7b3665eaaaf7919707915903\nF autoconf/Makefile.am e14b629addaa1ce372b72043f28f40de2e32b7e211b6e0fc18dbb87989197e40\nF autoconf/Makefile.fallback 22fe523eb36dfce31e0f6349f782eb084e86a5620b2b0b4f84a2d6133f53f5ac\nF autoconf/Makefile.msc 492ea431c411378094593a5225b9a02645455a5d87a26d018b5461b723e52125\nF autoconf/README.first 6c4f34fe115ff55d4e8dbfa3cecf04a0188292f7\nF autoconf/README.txt 4f04b0819303aabaa35fff5f7b257fb0c1ef95f1\nF autoconf/configure.ac 308de24343e76ecfbe9a67f8fcd4c5216b790d230c5d9ce10210b7d5965d6192\nF autoconf/tea/Makefile.in b438a7020446c8a8156e8d97c8914a04833da6fd\nF autoconf/tea/README 3e9a3c060f29a44344ab50aec506f4db903fb873\nF autoconf/tea/aclocal.m4 52c47aac44ce0ddb1f918b6993e8beb8eee88f43\nF autoconf/tea/configure.ac 8aa16e3f0a5ca7959d4af198f46934ec187d395f\nF autoconf/tea/doc/sqlite3.n e1fe45d4f5286ee3d0ccc877aca2a0def488e9bb\nF autoconf/tea/license.terms 13bd403c9610fd2b76ece0ab50c4c5eda933d523\nF autoconf/tea/pkgIndex.tcl.in 3ef61715cf1c7bdcff56947ffadb26bc991ca39d\nF autoconf/tea/tclconfig/install-sh bdd5e293591621ae60d9824d86a4b1c5f22c3d00\nF autoconf/tea/tclconfig/tcl.m4 66ddf0a5d5e4b1d29bff472c0985fd7fa89d0fb5\nF autoconf/tea/win/makefile.vc f89d0184d0eee5f7e356ea407964dcd139939928\nF autoconf/tea/win/nmakehlp.c 247538ad8e8c508f33c03ec1fbd67d3a07ef6291\nF autoconf/tea/win/rules.vc c511f222b80064096b705dbeb97060ee1d6b6d63\nF config.guess 883205ddf25b46f10c181818bf42c09da9888884af96f79e1719264345053bd6\nF config.h.in 6376abec766e9a0785178b1823b5a587e9f1ccbc\nF config.sub c2d0260f17f3e4bc0b6808fccf1b291cb5e9126c14fc5890efc77b9fd0175559\nF configure fdc9f8d53360170679349d8f72fb2e5c79f511424891b7bb8a2f48de41c7a6ef x\nF configure.ac 3552d3aecade98a9d4b64bceb48ffb7726cbc85902efde956812942f060fbd0a\nF contrib/sqlitecon.tcl 210a913ad63f9f991070821e599d600bd913e0ad\nF doc/F2FS.txt c1d4a0ae9711cfe0e1d8b019d154f1c29e0d3abfe820787ba1e9ed7691160fcd\nF doc/lemon.html 24956ab2995e55fe171e55bdd04f22b553957dc8bb43501dbb9311e30187e0d3\nF doc/pager-invariants.txt 27fed9a70ddad2088750c4a2b493b63853da2710\nF doc/vfs-shm.txt e101f27ea02a8387ce46a05be2b1a902a021d37a\nF ext/README.md fd5f78013b0a2bc6f0067afb19e6ad040e89a10179b4f6f03eee58fac5f169bd\nF ext/async/README.txt e12275968f6fde133a80e04387d0e839b0c51f91\nF ext/async/sqlite3async.c 0f3070cc3f5ede78f2b9361fb3b629ce200d7d74\nF ext/async/sqlite3async.h f489b080af7e72aec0e1ee6f1d98ab6cf2e4dcef\nF ext/expert/README.md b321c2762bb93c18ea102d5a5f7753a4b8bac646cb392b3b437f633caf2020c3\nF ext/expert/expert.c d548d603a4cc9e61f446cc179c120c6713511c413f82a4a32b1e1e69d3f086a4\nF ext/expert/expert1.test e2afc53a27610e8251e44c7f961806607a5490ff204b3db342740d558e052662\nF ext/expert/sqlite3expert.c 3da865f2286433588260f41e796422c611bceaca3a0bbf9139a619cf7d062c19\nF ext/expert/sqlite3expert.h ca81efc2679a92373a13a3e76a6138d0310e32be53d6c3bfaedabd158ea8969b\nF ext/expert/test_expert.c d56c194b769bdc90cf829a14c9ecbc1edca9c850b837a4d0b13be14095c32a72\nF ext/fts1/README.txt 20ac73b006a70bcfd80069bdaf59214b6cf1db5e\nF ext/fts1/ft_hash.c 3927bd880e65329bdc6f506555b228b28924921b\nF ext/fts1/ft_hash.h 06df7bba40dadd19597aa400a875dbc2fed705ea\nF ext/fts1/fts1.c a39f7d21c2994d27c959ef9c3505c81542c81432\nF ext/fts1/fts1.h 6060b8f62c1d925ea8356cb1a6598073eb9159a6\nF ext/fts1/fts1_hash.c 3196cee866edbebb1c0521e21672e6d599965114\nF ext/fts1/fts1_hash.h e7f0d761353996a8175eda351104acfde23afcb0\nF ext/fts1/fts1_porter.c b1c7304b8988ba3f764a147cdd32043b4913ea7b\nF ext/fts1/fts1_tokenizer.h fdea722c38a9f82ed921642981234f666e47919c\nF ext/fts1/fts1_tokenizer1.c fd00d1fe4dc30dfc5c64cba695ce34f4af20d2fa\nF ext/fts1/fulltext.c 37698e1909584f6d8ea67d1485e3ad39dbf42d19\nF ext/fts1/fulltext.h 08525a47852d1d62a0be81d3fc3fe2d23b094efd\nF ext/fts1/simple_tokenizer.c bbfa4e3b2a26ef17d4edc6d98cd4a3f5396d998a\nF ext/fts1/tokenizer.h 0c53421b832366d20d720d21ea3e1f6e66a36ef9\nF ext/fts2/README.tokenizers 21e3684ea5a095b55d70f6878b4ce6af5932dfb7\nF ext/fts2/README.txt 8c18f41574404623b76917b9da66fcb0ab38328d\nF ext/fts2/fts2.c 72c816a9ae448049fbbe8f18a85698765fc7956c\nF ext/fts2/fts2.h da5f76c65163301d1068a971fd32f4119e3c95fa\nF ext/fts2/fts2_hash.c 011a1d32de45bb1b519a1fd0048e857d6a843558\nF ext/fts2/fts2_hash.h 1824b99dfd8d0225facbdb26a2c87289b2e7dcf8\nF ext/fts2/fts2_icu.c 51c5cd3c04954badd329fa738c95fcdb717b5188\nF ext/fts2/fts2_porter.c 2cd4a507bf3c3085fe66f59b0f2a325f65aaacf5\nF ext/fts2/fts2_tokenizer.c b529493d55e55497213c37e1f31680a77746be26\nF ext/fts2/fts2_tokenizer.h 27a1a99ca2d615cf7e142839b8d79e8751b4529e\nF ext/fts2/fts2_tokenizer1.c 07e223eecb483d448313b5f1553a4f299a7fb7a1\nF ext/fts2/mkfts2amal.tcl 974d5d438cb3f7c4a652639262f82418c1e4cff0\nF ext/fts3/README.content fdc666a70d5257a64fee209f97cf89e0e6e32b51\nF ext/fts3/README.syntax a19711dc5458c20734b8e485e75fb1981ec2427a\nF ext/fts3/README.tokenizers b92bdeb8b46503f0dd301d364efc5ef59ef9fa8e2758b8e742f39fa93a2e422d\nF ext/fts3/README.txt 8c18f41574404623b76917b9da66fcb0ab38328d\nF ext/fts3/fts3.c 9a69143c94195d9342dd4a704021009fb9e45dff9bff775dae024d47e363bab8\nF ext/fts3/fts3.h 3a10a0af180d502cecc50df77b1b22df142817fe\nF ext/fts3/fts3Int.h ba4e5445a0daf4a251345d4704259268fd98a3e0282fedfcaedb9fc6da9f250c\nF ext/fts3/fts3_aux.c 96708c8b3a7d9b8ca1b68ea2b7e503e283f20e95f145becadedfad096dbd0f34\nF ext/fts3/fts3_expr.c b132af223e90e35b9f9efa9fe63d6ae737d34153a3b6066736086df8abc78a1f\nF ext/fts3/fts3_hash.c 8b6e31bfb0844c27dc6092c2620bdb1fca17ed613072db057d96952c6bdb48b7\nF ext/fts3/fts3_hash.h 39cf6874dc239d6b4e30479b1975fe5b22a3caaf\nF ext/fts3/fts3_icu.c 305ce7fb6036484085b5556a9c8e62acdc7763f0f4cdf5fd538212a9f3720116\nF ext/fts3/fts3_porter.c 3565faf04b626cddf85f03825e86056a4562c009\nF ext/fts3/fts3_snippet.c d62e40baa6a200586c3a425478109418f44926b1c318c870b59a4286afbe2795\nF ext/fts3/fts3_term.c f45a1e7c6ef464abb1231245d123dae12266b69e05cc56e14045b76591ae92d1\nF ext/fts3/fts3_test.c 73b16e229e517c1b1f0fb8e1046182a4e5dbc8dbe6eea8a5d4353fcce7dbbf39\nF ext/fts3/fts3_tokenize_vtab.c 1de9a61acfa2a0445ed989310c31839c57f6b6086dd9d5c97177ae734a17fd8b\nF ext/fts3/fts3_tokenizer.c a1ca0ab7c9c688ccb1d605645809f74f5df2bf4ca568e4bb37fb51113fd78e45\nF ext/fts3/fts3_tokenizer.h 64c6ef6c5272c51ebe60fc607a896e84288fcbc3\nF ext/fts3/fts3_tokenizer1.c 5c98225a53705e5ee34824087478cf477bdb7004\nF ext/fts3/fts3_unicode.c 4b9af6151c29b35ed09574937083cece7c31e911f69615e168a39677569b684d\nF ext/fts3/fts3_unicode2.c 416eb7e1e81142703520d284b768ca2751d40e31fa912cae24ba74860532bf0f\nF ext/fts3/fts3_write.c fa971df91b7c9c317ccb76e73de425de372f854cbed16be2d98f42f61be6c0fb\nF ext/fts3/fts3speed.tcl b54caf6a18d38174f1a6e84219950d85e98bb1e9\nF ext/fts3/mkfts3amal.tcl 252ecb7fe6467854f2aa237bf2c390b74e71f100\nF ext/fts3/tool/fts3cov.sh c331d006359456cf6f8f953e37f2b9c7d568f3863f00bb5f7eb87fea4ac01b73\nF ext/fts3/tool/fts3view.c 202801a2056995b763864d60c2dee744d46f1677\nF ext/fts3/unicode/CaseFolding.txt 8c678ca52ecc95e16bc7afc2dbf6fc9ffa05db8c\nF ext/fts3/unicode/UnicodeData.txt cd07314edb62d49fde34debdaf92fa2aa69011e7\nF ext/fts3/unicode/mkunicode.tcl bf7fcaa6d68e6d38223467983785d054f1cff4d9e3905dd51f6ed8801bb590d5\nF ext/fts3/unicode/parseunicode.tcl a981bd6466d12dd17967515801c3ff23f74a281be1a03cf1e6f52a6959fc77eb\nF ext/fts5/extract_api_docs.tcl a36e54ec777172ddd3f9a88daf593b00848368e0\nF ext/fts5/fts5.h c132a9323f22a972c4c93a8d5a3d901113a6e612faf30ca8e695788438c5ca2a\nF ext/fts5/fts5Int.h d7cbc214ee167496f70905667e18f73ea0402f7ef09236ce305e117e0efc866a\nF ext/fts5/fts5_aux.c dcc627d8b6e3fc773db528ff67b39955dab7b51628f9dba8e15849e5bedfd7fa\nF ext/fts5/fts5_buffer.c 5a5fe0159752c0fb0a5a93c722e9db2662822709490769d482b76a6dc8aaca70\nF ext/fts5/fts5_config.c aab6117f8f85933e051c66f227414fdcaf7f2313688e16276b895f9d42d28e5c\nF ext/fts5/fts5_expr.c 2be456484786333d559dc2987a00f2750981fab91d52db8452a8046278c5f22e\nF ext/fts5/fts5_hash.c 1cc0095646f5f3b46721aa112fb4f9bf29ae175cb5338f89dcec66ed97acfe75\nF ext/fts5/fts5_index.c 99b77ae1f503978ca76985bcfff7345c822aed8bbaa8edb3747f804f614685b5\nF ext/fts5/fts5_main.c 9db1f173d299466aeff89bd949fb1eb0a181265726fb56f11e07ea292dcc9a73\nF ext/fts5/fts5_storage.c 167e3d8f8052a71032d498e32a2f2ed5ffe489e5d4d47e298adfa02ed55c7882\nF ext/fts5/fts5_tcl.c 39bcbae507f594aad778172fa914cad0f585bf92fd3b078c686e249282db0d95\nF ext/fts5/fts5_test_mi.c 08c11ec968148d4cb4119d96d819f8c1f329812c568bac3684f5464be177d3ee\nF ext/fts5/fts5_test_tok.c f96c6e193c466711d6d7828d5f190407fe7ab897062d371426dd3036f01258e7\nF ext/fts5/fts5_tokenize.c 2e508c6a3bd8ee56c48e98a38052e1a650e49b32a484cce9b189984114bc3b88\nF ext/fts5/fts5_unicode2.c 8bd0cd07396b74c1a05590e4070d635bccfc849812c305619f109e6c0485e250\nF ext/fts5/fts5_varint.c e64d2113f6e1bfee0032972cffc1207b77af63319746951bf1d09885d1dadf80\nF ext/fts5/fts5_vocab.c c3f12188570abb423303cd193b16dd19ba54e21c2e930e9b748d743de3b385f5\nF ext/fts5/fts5parse.y eb526940f892ade5693f22ffd6c4f2702543a9059942772526eac1fde256bb05\nF ext/fts5/mkportersteps.tcl 5acf962d2e0074f701620bb5308155fa1e4a63ba\nF ext/fts5/test/fts5_common.tcl b01c584144b5064f30e6c648145a2dd6bc440841\nF ext/fts5/test/fts5aa.test 5bd43427b7d08ce2e19c488a26534be450538b9232d4d5305049e8de236e9aa9\nF ext/fts5/test/fts5ab.test 9205c839332c908aaad2b01ab8670ece8b161e8f2ec8a9fabf18ca9385880bb7\nF ext/fts5/test/fts5ac.test a7aa7e1fefc6e1918aa4d3111d5c44a09177168e962c5fd2cca9620de8a7ed6d\nF ext/fts5/test/fts5ad.test e8cf959dfcd57c8e46d6f5f25665686f3b6627130a9a981371dafdf6482790de\nF ext/fts5/test/fts5ae.test 1142d16d9cc193894dc13cc8f9c7a8a21411ac61b5567a878514df6f9f0d7bb7\nF ext/fts5/test/fts5af.test 724247405b13f8f06cc6ce464dc4f152dc5dd4e86b12c2099685d8f19747bf7b\nF ext/fts5/test/fts5ag.test 7816f25a0707578f08145ab539fc0ca025f8951e788b28a6a18a06b2099469dd\nF ext/fts5/test/fts5ah.test 27b5a33bfd0363ca8a4dc659e6e2a5df3dea1c3c5b04bc51ca6aeb1277bd9b21\nF ext/fts5/test/fts5ai.test bc97e4758cc93e06bf851d61c98fdf4e8b8f8315ee28a84fb15f916360856414\nF ext/fts5/test/fts5aj.test 745020852d85f5dd49d11cb7ad11d3cc6dafc4fe6d6d24bc0875ac8f43ee4149\nF ext/fts5/test/fts5ak.test fc3595f8e6873bb86d70c9bd4b67d0413ce577bd4793c39a2b60a7b8825b60a6\nF ext/fts5/test/fts5al.test 00c4c1c6a1366b73aa48ce2068c634520867c3cf7f5d1676ebbb775ee1f35734\nF ext/fts5/test/fts5alter.test 5565f7e4605512b69171ac18ca84398603f9f6456dbe377beeca97e83cc242cd\nF ext/fts5/test/fts5auto.test 78989e6527ce69c9eddbef7392fea5c10b0010cd2b2ae68eec7bc869c471e691\nF ext/fts5/test/fts5aux.test ebf6f2ff7cb556e83f66991b7f12bff016d3c83d4eab36704b649dd6b1437318\nF ext/fts5/test/fts5auxdata.test eacc97ff04892f1a5f3d4df5a73f8bcbc3955ea1d12c9f24137eb1fc079e7611\nF ext/fts5/test/fts5bigpl.test 6466c89b38439f0aba26ac09e232a6b963f29b1cbe1304f6a664fe1e7a8f5fd3\nF ext/fts5/test/fts5bigtok.test 541119e616c637caea925a8c028c37c2c29e94383e00aa2f9198d530724b6e36\nF ext/fts5/test/fts5cat.test daba0b80659460b0cb60bd1f40b402478a761fe7ea414c3c94c2be25568cc33a\nF ext/fts5/test/fts5circref.test f880dfd0d99f6fb73b88ccacb0927d18e833672fd906cc47d6b4e529419eaa62\nF ext/fts5/test/fts5colset.test a30473451321bbf0b6218af62e96b4ae5fa99931cfdb210b5ecc804623b30f75\nF ext/fts5/test/fts5columnsize.test 45459ce4dd9fd853b6044cdc9674921bff89e3d840f348ca8c1630f9edbf5482\nF ext/fts5/test/fts5config.test 60094712debc59286c59aef0e6cf511c37d866802776a825ce437d26afe0817f\nF ext/fts5/test/fts5conflict.test 655925678e630d3cdf145d18725a558971806416f453ac8410ca8c04d934238d\nF ext/fts5/test/fts5connect.test 08030168fc96fc278fa81f28654fb7e90566f33aff269c073e19b3ae9126b2f4\nF ext/fts5/test/fts5content.test 213506436fb2c87567b8e31f6d43ab30aab99354cec74ed679f22aad0cdbf283\nF ext/fts5/test/fts5corrupt.test 77ae6f41a7eba10620efb921cf7dbe218b0ef232b04519deb43581cb17a57ebe\nF ext/fts5/test/fts5corrupt2.test 7453752ba12ce91690c469a6449d412561cc604b1dec994e16ab132952e7805f\nF ext/fts5/test/fts5corrupt3.test 5aaa2f8b44a85246a2ea76db1695bde38a75802979f3961702afa8f322d331c8\nF ext/fts5/test/fts5corrupt4.test ea805c4d7c68b5f185b9db5d2060a7ae5875339738dd48203c92162f41e7ca91\nF ext/fts5/test/fts5delete.test cbf87e3b8867c4d5cfcaed975c7475fd3f99d072bce2075fcedf43d1f82af775\nF ext/fts5/test/fts5detail.test 31b240dbf6d44ac3507e2f8b65f29fdc12465ffd531212378c7ce1066766f54e\nF ext/fts5/test/fts5determin.test 1b77879b2ae818b5b71c859e534ee334dac088b7cf3ff3bf76a2c82b1c788d11\nF ext/fts5/test/fts5dlidx.test b90852c55881b29dbac6380b274de27beae623ac4b6d567c6c8fb9cdc315a86e\nF ext/fts5/test/fts5doclist.test e39a6001495f1dc68e20323586ac965787986c2bf6f515b9b0285627b089d9e6\nF ext/fts5/test/fts5ea.test b01e3a18cdfabbff8104a96a5242a06a68a998a0\nF ext/fts5/test/fts5eb.test af1cd2d2cdff343bd40fd8ad9278e9161bfca81ad629e5aaa8c60a868b16044f\nF ext/fts5/test/fts5fault1.test d28a65caee75db6897c3cf1358c5230d3bb2a3bf7fb31062c19c7e5382b3d2bd\nF ext/fts5/test/fts5fault2.test 69c8fdbef830cd0d450908d4504d5bb86609e255af99c421c20a0756251fe344\nF ext/fts5/test/fts5fault3.test da2f9e3e56ff5740d68ebdd6877c97089e7ed28ddff28a0da87a6afea27e5522\nF ext/fts5/test/fts5fault4.test 1c1db5fcfe59401e7833146100f1d8de284a0a686fac31ddac9fb56c459f725b\nF ext/fts5/test/fts5fault5.test a336e4e11847de24c9497f80cce18e00bb3fab7fb11f97d04eb9af898900a762\nF ext/fts5/test/fts5fault6.test a0fc0a8f99e4b16500c31dfc7e38e1defe0f1693ac47650517ac7b723b1956f8\nF ext/fts5/test/fts5fault7.test 0acbec416edb24b8881f154e99c31e9ccf73f539cfcd164090be139e9e97ed4c\nF ext/fts5/test/fts5fault8.test 318238659d35f82ad215ecb57ca4c87486ea85d45dbeedaee42f148ff5105ee2\nF ext/fts5/test/fts5fault9.test 098e6b894bbdf9b2192f994a30f4043673fb3f338b6b8ab1624c704422f39119\nF ext/fts5/test/fts5faultA.test be4487576bff8c22cee6597d1893b312f306504a8c6ccd3c53ca85af12290c8c\nF ext/fts5/test/fts5faultB.test d606bdb8e81aaeb6f41de3fc9fc7ae315733f0903fbff05cf54f5b045b729ab5\nF ext/fts5/test/fts5faultD.test cc5d1225556e356615e719c612e845d41bff7d5a\nF ext/fts5/test/fts5first.test 3fcf2365c00a15fc9704233674789a3b95131d12de18a9b996159f6909dc8079\nF ext/fts5/test/fts5full.test e1701a112354e0ff9a1fdffb0c940c576530c33732ee20ac5e8361777070d717\nF ext/fts5/test/fts5fuzz1.test 238d8c45f3b81342aa384de3e581ff2fa330bf922a7b69e484bbc06051a1080e\nF ext/fts5/test/fts5hash.test a4cf51acad99bfc43c16fb74f9d22495dc221ae0701fc5e908ca963a9b26a02b\nF ext/fts5/test/fts5integrity.test 4317561cd25eca7df16aa1f7d1a700ee958059fa639785f94aba0a84df9ab17b\nF ext/fts5/test/fts5interrupt.test 09613247b273a99889808ef852898177e671406fe71fdde7ea00e78ea283d227\nF ext/fts5/test/fts5lastrowid.test be98fe3e03235296585b72daad7aed5717ba0062bae5e5c18dd6e04e194c6b28\nF ext/fts5/test/fts5leftjoin.test c0b4cafb9661379e576dc4405c0891d8fcc2782680740513c4d1fc114b43d4ad\nF ext/fts5/test/fts5matchinfo.test 50d86da66ec5b27603dcd90ba0227f5d9deb10351cbc52974a88e24f6fc9b076\nF ext/fts5/test/fts5merge.test e92a8db28b45931e7a9c7b1bbd36101692759d00274df74d83fd29d25d53b3a6\nF ext/fts5/test/fts5merge2.test 3ebad1a59d6ad3fb66eff6523a09e95dc6367cbefb3cd73196801dea0425c8e2\nF ext/fts5/test/fts5misc.test a5b53328b5b79275915de8f67ae85905eb2133d8dbcc808411f67c094b1bd347\nF ext/fts5/test/fts5multi.test a15bc91cdb717492e6e1b66fec1c356cb57386b980c7ba5af1915f97fe878581\nF ext/fts5/test/fts5multiclient.test 5ff811c028d6108045ffef737f1e9f05028af2458e456c0937c1d1b8dea56d45\nF ext/fts5/test/fts5near.test 211477940142d733ac04fad97cb24095513ab2507073a99c2765c3ddd2ef58bd\nF ext/fts5/test/fts5onepass.test f9b7d9b2c334900c6542a869760290e2ab5382af8fbd618834bf1fcc3e7b84da\nF ext/fts5/test/fts5optimize.test 36a752d24c818792032e4ff502936fc9cc5ef938721696396fdc79214b2717f1\nF ext/fts5/test/fts5phrase.test 13e5d8e9083077b3d9c74315b3c92ec723cc6eb37c8155e0bfe1bba00559f07b\nF ext/fts5/test/fts5plan.test 771b999d161e24fd803ce0290adb7c6e7c9b9cc2c6a0adb344813fb89473aa32\nF ext/fts5/test/fts5porter.test 8d08010c28527db66bc3feebd2b8767504aaeb9b101a986342fa7833d49d0d15\nF ext/fts5/test/fts5porter2.test 0d251a673f02fa13ca7f011654873b3add20745f7402f108600a23e52d8c7457\nF ext/fts5/test/fts5prefix.test a0fa67b06650f2deaa7bf27745899d94e0fb547ad9ecbd08bfad98c04912c056\nF ext/fts5/test/fts5query.test ac363b17a442620bb0780e93c24f16a5f963dfe2f23dc85647b869efcfada728\nF ext/fts5/test/fts5rank.test c9fd4a1e36b4fa92d572ec13d846469b97da249d1c2f7fd3ee7e017ce46f2416\nF ext/fts5/test/fts5rebuild.test 55d6f17715cddbf825680dd6551efbc72ed916d8cf1cde40a46fc5d785b451e7\nF ext/fts5/test/fts5restart.test 835ecc8f449e3919f72509ab58056d0cedca40d1fe04108ccf8ac4c2ba41f415\nF ext/fts5/test/fts5rowid.test b8790ec170a8dc1942a15aef3db926a5f3061b1ff171013003d8297203a20ad6\nF ext/fts5/test/fts5simple.test a298670508c1458b88ce6030440f26a30673931884eb5f4094ac1773b3ba217b\nF ext/fts5/test/fts5simple2.test 258a1b0c590409bfa5271e872c79572b319d2a56554d0585f68f146a0da603f0\nF ext/fts5/test/fts5simple3.test d5c74a9d3ca71bd5dd5cacb7c55b86ea12cdddfc8b1910e3de2995206898380f\nF ext/fts5/test/fts5synonym.test 1651815b8008de170e8e600dcacc17521d765482ea8f074ae82cfa870d8bb7fb\nF ext/fts5/test/fts5synonym2.test b54cce5c34ec08ed616f646635538ae82e34a0e28f947ec60b6fadbc4b3fb17a\nF ext/fts5/test/fts5tok1.test ce6551e41ff56f30b69963577324624733bed0d1753589f06120d664d9cd45c9\nF ext/fts5/test/fts5tok2.test dcacb32d4a2a3f0dd3215d4a3987f78ae4be21a2\nF ext/fts5/test/fts5tokenizer.test ac3c9112b263a639fb0508ae73a3ee886bf4866d2153771a8e8a20c721305a43\nF ext/fts5/test/fts5umlaut.test a42fe2fe6387c40c49ab27ccbd070e1ae38e07f38d05926482cc0bccac9ad602\nF ext/fts5/test/fts5unicode.test 17056f4efe6b0a5d4f41fdf7a7dc9af2873004562eaa899d40633b93dc95f5a9\nF ext/fts5/test/fts5unicode2.test 9b3df486de05fb4bde4aa7ee8de2e6dae1df6eb90e3f2e242c9383b95d314e3e\nF ext/fts5/test/fts5unicode3.test 590c72e18195bda2446133f9d82d04a4e89d094bba58c75ae10f4afc6faa0744\nF ext/fts5/test/fts5unicode4.test 6463301d669f963c83988017aa354108be0b947d325aef58d3abddf27147b687\nF ext/fts5/test/fts5unindexed.test 9021af86a0fb9fc616f7a69a996db0116e7936d0db63892db6bafabbec21af4d\nF ext/fts5/test/fts5update.test b8affd796e45c94a4d19ad5c26606ea06065a0f162a9562d9f005b5a80ccf0bc\nF ext/fts5/test/fts5version.test c8f2cc105f0abf0224965f93e584633dee3e06c91478bc67e468f7cfdf97fd6a\nF ext/fts5/test/fts5vocab.test 648fb2fe86b55e08295e34504704718d92fba3e2cf3e1f5d72fa3682df4cd0f0\nF ext/fts5/test/fts5vocab2.test e0fdc3a3095f6eda68ac9bf9a443ff929a124d46f00af19933604085712e9d47\nF ext/fts5/tool/fts5speed.tcl b0056f91a55b2d1a3684ec05729de92b042e2f85\nF ext/fts5/tool/fts5txt2db.tcl 526a9979c963f1c54fd50976a05a502e533a4c59\nF ext/fts5/tool/loadfts5.tcl 95b03429ee6b138645703c6ca192c3ac96eaf093\nF ext/fts5/tool/mkfts5c.tcl d1c2a9ab8e0ec690a52316f33dd9b1d379942f45\nF ext/fts5/tool/showfts5.tcl d54da0e067306663e2d5d523965ca487698e722c\nF ext/icu/README.txt a295e91db742b153e8dce8f7efd31d28ad1eea4df31ef4daa3eedc85be2f5138\nF ext/icu/icu.c c2c7592574c08cd1270d909b8fb8797f6ea1f49e931e71dbcc25506b9b224580\nF ext/icu/sqliteicu.h 728867a802baa5a96de7495e9689a8e01715ef37\nF ext/lsm1/Makefile a553b728bba6c11201b795188c5708915cc4290f02b7df6ba7e8c4c943fd5cd9\nF ext/lsm1/Makefile.msc f8c878b467232226de288da320e1ac71c131f5ec91e08b21f502303347260013\nF ext/lsm1/lsm-test/README 87ea529d2abe615e856d4714bfe8bb185e6c2771b8612aa6298588b7b43e6f86\nF ext/lsm1/lsm-test/lsmtest.h cf58528ffe0cfe535e91b44584e2ec5fb1caacdabecef0d8dcf83bf83168bf28\nF ext/lsm1/lsm-test/lsmtest1.c ae6ba48a0851b39be69a7d0eb220bfb9521a526e926223d5014bd385df10abb3\nF ext/lsm1/lsm-test/lsmtest2.c 188b09aec776516aeedcfd13b9c6faf85ba16b3671a0897a2c740ee00a5dc4f8\nF ext/lsm1/lsm-test/lsmtest3.c 9ab87528a36dbf4a61d7c8ad954f5ee368c0878c127b84b942b2e2abe522de26\nF ext/lsm1/lsm-test/lsmtest4.c d258d6a245db5d8eaede096e2368d23f859c5e92c80ab9122463f708514fe10c\nF ext/lsm1/lsm-test/lsmtest5.c 8d5242a0f870d65eeada191c8945781fed9cb8ece3886573790ebd373b62dac5\nF ext/lsm1/lsm-test/lsmtest6.c 869cb4a172cd07d1a75b3aeaecd61d0a477787b3b8668bad0d3ff0f43b642b7c\nF ext/lsm1/lsm-test/lsmtest7.c 7a917455a0f956a8ed3f44f5c9387ec0ea6627714874464cc3fa5c5a9cabb2f2\nF ext/lsm1/lsm-test/lsmtest8.c 589b68c44531a0f04d5e879bb1e211be5f7100f48eed7e8631e07ed5cbd68f94\nF ext/lsm1/lsm-test/lsmtest9.c dd1a0ebf41134933a744d1e00e60429a2a21fc50d587ae7dd6bdb6e96d805bdc\nF ext/lsm1/lsm-test/lsmtest_bt.c d70d9a9be5eef9360af1251dd083948d74fd30137a08f61bef995f7ac04e037f\nF ext/lsm1/lsm-test/lsmtest_datasource.c 5d770be191d0ca51315926723009b2c25c0b4b8136840494ef710ac324aa916c\nF ext/lsm1/lsm-test/lsmtest_func.c 159aa401bc8032bfa3d8cf2977bd687abebab880255895a5eb45770d626fa38d\nF ext/lsm1/lsm-test/lsmtest_io.c cf11b27b129c6bd5818fa1d440176502dc27229f0db892b4479118d61993ea20\nF ext/lsm1/lsm-test/lsmtest_main.c a9bc647738c0dcaebf205d6d194b3ce4a6ef3925801cd2d919f0a4ea33a15aeb\nF ext/lsm1/lsm-test/lsmtest_mem.c 4e63c764345ab1df59d4f13a77980c6f3643798210b10d6cdbd785b4b888fda5\nF ext/lsm1/lsm-test/lsmtest_tdb.c 618a8619183fda4f5540fcde15f9068293c5e3180e1a246e34409b0c148758b3\nF ext/lsm1/lsm-test/lsmtest_tdb.h 8733eee249b12956a9df8322994b43d19bd8c02ad2e8b0bb5164db4d6ccc1735\nF ext/lsm1/lsm-test/lsmtest_tdb2.cc 99ea7f2dd9c7536c8fb9bdd329e4cfeb76899f3ddf6f48bdd3926e016922b715\nF ext/lsm1/lsm-test/lsmtest_tdb3.c 7a7ccae189f5bb25bcd1ec3bbd740529706eded7f6729a5a0a9eeaeb57785320\nF ext/lsm1/lsm-test/lsmtest_tdb4.c 47e8bb5eba266472d690fb8264f1855ebdba0ae5a0e541e35fcda61ebf1d277f\nF ext/lsm1/lsm-test/lsmtest_util.c 241622db5a332a09c8e6e7606b617d288a37b557f7d3bce0bb97809f67cc2806\nF ext/lsm1/lsm-test/lsmtest_win32.c 0e0a224674c4d3170631c41b026b56c7e1672b151f5261e1b4cc19068641da2d\nF ext/lsm1/lsm.h 0f6f64ff071471cb87bf98beb8386566f30ea001\nF ext/lsm1/lsmInt.h 5983690e05e83653cc01ba9d8fbf8455e534ddf8349ed9adedbf46a7549760b0\nF ext/lsm1/lsm_ckpt.c 0eabfaf812ddb4ea43add38f05e430694cd054eb622c3e35af4c43118a2d5321\nF ext/lsm1/lsm_file.c 3c51841d5b3e7da162693cbac9a9f47eeedf6bcbbe2969a4d25e30c428c9fe36\nF ext/lsm1/lsm_log.c a8bf334532109bba05b09a504ee45fc393828b0d034ca61ab45e3940709d9a7c\nF ext/lsm1/lsm_main.c b5703f8042e71d3a2d65e671f6832e077e79e89e9975818f67f969922618db63\nF ext/lsm1/lsm_mem.c 4c51ea9fa285ee6e35301b33491642d071740a0a\nF ext/lsm1/lsm_mutex.c 378edf0a2b142b4f7640ee982df06d50b98788ea\nF ext/lsm1/lsm_shared.c 76adfc1ed9ffebaf92746dde4b370ccc48143ca8b05b563816eadd2aadf1c525\nF ext/lsm1/lsm_sorted.c 6f7d8cf7a7d3d3f1ab5d9ba6347e8f39f3d73c00ec48afcd0c4bcbefd806f9b8\nF ext/lsm1/lsm_str.c 65e361b488c87b10bf3e5c0070b14ffc602cf84f094880bece77bbf6678bca82\nF ext/lsm1/lsm_tree.c 682679d7ef2b8b6f2fe77aeb532c8d29695bca671c220b0abac77069de5fb9fb\nF ext/lsm1/lsm_unix.c 57361bcf5b1a1a028f5d66571ee490e9064d2cfb145a2cc9e5ddade467bb551b\nF ext/lsm1/lsm_varint.c 43f954af668a66c7928b81597c14d6ad4be9fedbc276bbd80f52fa28a02fdb62\nF ext/lsm1/lsm_vtab.c 169bfe7ef8e6c9de9c77e17c4c50c9ae55fb0167d80be3d1be82c991184b6f35\nF ext/lsm1/lsm_win32.c 0a4acbd7e8d136dd3a5753f0a9e7a9802263a9d96cef3278cf120bcaa724db7c\nF ext/lsm1/test/lsm1_common.tcl 5ed4bab07c93be2e4f300ebe46007ecf4b3e20bc5fbe1dedaf04a8774a6d8d82\nF ext/lsm1/test/lsm1_simple.test a04d08e8661ae6fc53786c67f0bd102c6692f003e859dde03ed9ac3f12e066e5\nF ext/lsm1/tool/mklsm1c.tcl f31561bbee5349f0a554d1ad7236ac1991fc09176626f529f6078e07335398b0\nF ext/misc/README.md d6dd0fe1d8af77040216798a6a2b0c46c73054d2f0ea544fbbcdccf6f238c240\nF ext/misc/amatch.c 50a9ef2d38dabfa371f8c1904097d493271e63d58ccb0e9b79a4fa4a94e66660\nF ext/misc/anycollseq.c 5ffdfde9829eeac52219136ad6aa7cd9a4edb3b15f4f2532de52f4a22525eddb\nF ext/misc/appendvfs.c 3777f22ec1057dc4e5fd89f2fbddcc7a29fbeef1ad038c736c54411bb1967af7\nF ext/misc/blobio.c a867c4c4617f6ec223a307ebfe0eabb45e0992f74dd47722b96f3e631c0edb2a\nF ext/misc/btreeinfo.c 4f0ebf278f46e68e6306c667917766cebc5550fd35d5de17847988e22892d4d2\nF ext/misc/carray.c 91e9a7f512fda934894bed30464552fffa7d3073b5be04189ae0bd0c59f26bfd\nF ext/misc/closure.c dbfd8543b2a017ae6b1a5843986b22ddf99ff126ec9634a2f4047cd14c85c243\nF ext/misc/completion.c cec672d40604075bb341a7f11ac48393efdcd90a979269b8fe7977ea62d0547f\nF ext/misc/compress.c dd4f8a6d0baccff3c694757db5b430f3bbd821d8686d1fc24df55cf9f035b189\nF ext/misc/csv.c 7f047aeb68f5802e7ce6639292095d622a488bb43526ed04810e0649faa71ceb\nF ext/misc/dbdata.c e316fba936571584e55abd5b974a32a191727a6b746053a0c9d439bd2cf93940\nF ext/misc/dbdump.c baf6e37447c9d6968417b1cd34cbedb0b0ab3f91b5329501d8a8d5be3287c336\nF ext/misc/eval.c 4b4757592d00fd32e44c7a067e6a0e4839c81a4d57abc4131ee7806d1be3104e\nF ext/misc/explain.c d5c12962d79913ef774b297006872af1fccda388f61a11d37758f9179a09551f\nF ext/misc/fileio.c 288e7230e0fe464d71b0694e2d8bdd3a353118ac2e31da3964b95f460f09915f\nF ext/misc/fossildelta.c 7708651072eb5620ab21bbfb518d184f27b2c29c0131b09b9a2d8852a8016430\nF ext/misc/fuzzer.c c4e27daf41433a64cad5265cd27dbcb891147e9994d0422200ce81ce9a54b625\nF ext/misc/ieee754.c f190d0cc5182529acb15babd177781be1ac1718c\nF ext/misc/json1.c 760107d0b97ab422952591b0d7519327dcb482954a7706ee387a54c135f8aabf\nF ext/misc/memstat.c 3017a0832c645c0f8c773435620d663855f04690172316bd127270d1a7523d4d\nF ext/misc/memtrace.c 7c0d115d2ef716ad0ba632c91e05bd119cb16c1aedf3bec9f06196ead2d5537b\nF ext/misc/memvfs.c ab36f49e02ebcdf85a1e08dc4d8599ea8f343e073ac9e0bca18a98b7e1ec9567\nF ext/misc/mmapwarm.c 8c5fe90d807a23e44a8b93e96e8b812b19b300d5fd8c1d40a4fd1d8224e33f46\nF ext/misc/nextchar.c 279f80fe8ef5ba413242e2704e246503ac601f005eefb180d19e6c920338a0ba\nF ext/misc/normalize.c b4290464f542bae7a97b43f15bd197949b833ffd668b7c313631bd5d4610212c\nF ext/misc/percentile.c 148dd07286b16e50f232bb638a47850085ad37d51f270429905bd865e595d1ca\nF ext/misc/prefixes.c 7be86d17525cfae6ed462fc3c519efc44488ac329890f77491c8f82871f57e17\nF ext/misc/regexp.c 653b6ab5e89bcb5d45f9ebe0747d7f8f3f5706cac963fcbc9a3ddbe5fdc1efa2\nF ext/misc/remember.c add730f0f7e7436cd15ea3fd6a90fd83c3f706ab44169f7f048438b7d6baa69c\nF ext/misc/rot13.c 540a169cb0d74f15522a8930b0cccdcb37a4fd071d219a5a083a319fc6e8db77\nF ext/misc/scrub.c db9fff56fed322ca587d73727c6021b11ae79ce3f31b389e1d82891d144f22ad\nF ext/misc/series.c 0c97f63378fddc9f425e82ba139b9aaf902211f24ced115c2b6ae12b425f7334\nF ext/misc/sha1.c d8125a88ee9023bc17d6f87ea8850db33f906d5701b30d4fd9bddb57f231e60a\nF ext/misc/shathree.c 22ba7ca84a433d6466a7d05dcc876910b435a715da8cc462517db9351412b8c8\nF ext/misc/showauth.c 732578f0fe4ce42d577e1c86dc89dd14a006ab52\nF ext/misc/spellfix.c f88ecb2c0294453ce8b7704b211f5350c41b085b38c8e056852e3a08b0f5e484\nF ext/misc/sqlar.c 57d5bc45cd5492208e451f697404be88f8612527d64c9d42f96b325b64983d74\nF ext/misc/stmt.c 8a8dc4675042e4551e4afe99b8d0cc7a4a2fc1a8dacc0a9ce1b1bbff145da93d\nF ext/misc/templatevtab.c 8a16a91a5ceaccfcbd6aaaa56d46828806e460dd194965b3f77bf38f14b942c4\nF ext/misc/totype.c 5b6b1eafaa993e29f8df843319b3292b029f1b5cbbbf11c8a88e05d3f714159f\nF ext/misc/unionvtab.c 36237f0607ca954ac13a4a0e2d2ac40c33bc6e032a5f55f431713061ef1625f9\nF ext/misc/uuid.c db4db81e8c6a92ad6176ebd9f81dcb6870e331e1a286d0452f4319e3ba3df812\nF ext/misc/vfslog.c 3b25c2f56ba60788db247287be6ab024b53c4afffd412b4876db563389be0d35\nF ext/misc/vfsstat.c 77b5b4235c9f7f11eddf82487c0a422944ac2f132dafd5af3be7a68a057b1cdb\nF ext/misc/vtablog.c 5538acd0c8ddaae372331bee11608d76973436b77d6a91e8635cfc9432fba5ae\nF ext/misc/vtshim.c 1976e6dd68dd0d64508c91a6dfab8e75f8aaf6cd\nF ext/misc/wholenumber.c 784b12543d60702ebdd47da936e278aa03076212\nF ext/misc/zipfile.c 7ad29133e304e40c8fe239bea10e101580ed56bc68c16d992af514cce19572d0\nF ext/misc/zorder.c b0ff58fa643afa1d846786d51ea8d5c4b6b35aa0254ab5a82617db92f3adda64\nF ext/rbu/rbu.c 8681f6157db6adc82c34af24b14ea8a3be0146ad2a3b6c1d5da6cb8a5796c8ce\nF ext/rbu/rbu1.test 221d9c18a5e600ac9ac6b1810d99d9f99163a7909ba61597876ab6e4d4beb3d6\nF ext/rbu/rbu10.test 0a201c32202143f23c81c0144503da339786fc20acb7a2fda11601b65659f314\nF ext/rbu/rbu11.test 5c834cf491086b45e071eabf71f708febc143e86a384a92de69e0b1a4cace144\nF ext/rbu/rbu12.test 29f8b2118f6c96fac3755bd6d2b55c2db24f878b1f11fbfbe294f3a230a3dcdc\nF ext/rbu/rbu13.test 1285298e3360ec74511764841b3c174dcfe21da2f618c22febf1a20abd0365c2\nF ext/rbu/rbu14.test 4a7bf0b3a4516d3ab0bc0ba4ceb53eb7e3324147ccda152e561060f659dbba31\nF ext/rbu/rbu3.test d6c6cc7a1326e8e23b9820f30bd3054f22092e503fadfd2a660ae006653f6d80\nF ext/rbu/rbu5.test 724b38ea5f722e3d22dc76343860bd998bb676c3f78c4bc8175df5c5d7720e23\nF ext/rbu/rbu6.test 401064236d3cf86b7edc01c586d7c5554f48553946fbfa1a3af35d7e47dce9e3\nF ext/rbu/rbu7.test ae25f47b56f178197fc1098537a35a39176cc73d1629b03dc9d795929fc36ec2\nF ext/rbu/rbu8.test b98a6fc58ead84a0e6ddee775b9702cd981f318d5d4fd1d4df0fa0c40db7251b\nF ext/rbu/rbu9.test 0e4d985e25620d61920597e8ea69c871c9e8c1f5a0be2ae9fa70bb641d74378c\nF ext/rbu/rbuA.test b34a90cb495682c25b5fc03a9d5e7a4fc99541c29256f25e2e2a4f6542b4f5b3\nF ext/rbu/rbuB.test 52b07158824c6927b7e25554ace92a695cdebfc296ae3d308ac386984aded9bc\nF ext/rbu/rbuC.test 80f1cc2fb74f44b1128fd0ed8eedab3a76fefeb72a947860e2869ef76fc8dc6b\nF ext/rbu/rbu_common.tcl 60d904133ff843fe72cc0514e9dd2486707181e6e0fbab20979da28c48d21de9\nF ext/rbu/rbucollate.test cac528a9a46318cba42e61258bb42660bbbf4fdb9a8c863de5a54ad0c658d197\nF ext/rbu/rbucrash.test 000981a1fe8a6e4d9a684232f6a129e66a3ef595f5ed74655e2f9c68ffa613b4\nF ext/rbu/rbucrash2.test efa143cc94228eb0266d3f1abfbee60a5838a84cef7cc3fcb8c145b74d96fd41\nF ext/rbu/rbudiff.test 156957851136b63c143478518dc1bda6c832103cdbe8ac1d7cdd47edb3cbe0a3\nF ext/rbu/rbudor.test e3e8623926012f43eebe51fedf06a102df2640750d971596b052495f2536db20\nF ext/rbu/rbuexpr.test 10d0420537c3bc7666e576d72adeffe7e86cfbb00dcc30aa9ce096c042415190\nF ext/rbu/rbufault.test 2d7f567b79d558f6e093c58808cab4354f8a174e3802f69e7790a9689b3c09f8\nF ext/rbu/rbufault2.test c81327a3ac2c385b9b954db3644d4e0df93eeebfc3de9f1f29975a1e73fd3d0c\nF ext/rbu/rbufault3.test b2fcc9db5c982b869f67d1d4688d8cb515d5b92f58011fff95665f2e62cec179\nF ext/rbu/rbufault4.test 03d2849c3df7d7bd14a622e789ff049e5080edd34a79cd432e01204db2a5930a\nF ext/rbu/rbufts.test 0ae8d1da191c75bd776b86e24456db0fb6e97b7c944259fae5407ea55d23c31d\nF ext/rbu/rbumisc.test 329986cf5dd51890c4eb906c2f960ebb773a79a64bed90f506b7c417825b37eb\nF ext/rbu/rbumulti.test 5fb139058f37ddc5a113c5b93238de915b769b7792de41b44c983bc7c18cf5b9\nF ext/rbu/rbupartial.test f25df014b8dbe3c5345851fba6e66f79ab237f57dc201b2d5f0dbae658ae5a4c\nF ext/rbu/rbuprogress.test 857cf1f8166c83ef977edb9ef4fc42d80f71fbd798652b46ae2f3a7031870f8d\nF ext/rbu/rburesume.test dbdc4ca504e9c76375a69e5f0d91205db967dcc509a5166ca80231f8fda49eb1\nF ext/rbu/rbusave.test f4190a1a86fccf84f723af5c93813365ae33feda35845ba107b59683d1cdd926\nF ext/rbu/rbusplit.test b37e7b40b38760881dc9c854bd40b4744c6b6cd74990754eca3bda0f407051e8\nF ext/rbu/rbutemplimit.test 05ceefa90a2e26a99f40dd48282ed63a00df5e59c1f2bfd479c143e201a1b0ba\nF ext/rbu/rbuvacuum.test 55e101e90168c2b31df6c9638fe73dc7f7cc666b6142266d1563697d79f73534\nF ext/rbu/rbuvacuum2.test b8e5b51dc8b2c0153373d024c0936be3f66f9234acbd6d0baab0869d56b14e6b\nF ext/rbu/rbuvacuum3.test 8addd82e4b83b4c93fa47428eae4fd0dbf410f8512c186f38e348feb49ba03dc\nF ext/rbu/rbuvacuum4.test a78898e438a44803eb2bc897ba3323373c9f277418e2d6d76e90f2f1dbccfd10\nF ext/rbu/sqlite3rbu.c f3a3e09f575157052813be667d6ab3b54f47fb02e6e1c9f767ad7bb8f1fb90b3\nF ext/rbu/sqlite3rbu.h 1dc88ab7bd32d0f15890ea08d23476c4198d3da3056985403991f8c9cd389812\nF ext/rbu/test_rbu.c 03f6f177096a5f822d68d8e4069ad8907fe572c62ff2d19b141f59742821828a\nF ext/repair/README.md 92f5e8aae749a4dae14f02eea8e1bb42d4db2b6ce5e83dbcdd6b1446997e0c15\nF ext/repair/checkfreelist.c 0dbae18c1b552f58d64f8969e4fb1e7f11930c60a8c2a9a8d50b7f15bdfd54bd\nF ext/repair/checkindex.c 7d28c01a2e012ac64257d230fc452b2cafb78311a91a343633d01d95220f66f3\nF ext/repair/sqlite3_checker.c.in 4a5a3af3f450fe503e5a2985e98516dc2a6b9ad247449e284c1cf140fc91720f\nF ext/repair/sqlite3_checker.tcl a9a2caa9660567257c177a91124d8c0dccdfa341e25c51e6da7f1fd9e601eafa\nF ext/repair/test/README.md 34b2f542cf5be7bffe479242b33ee3492cea30711e447cc4a1a86cb5915f419e\nF ext/repair/test/checkfreelist01.test 3e8aa6aeb4007680c94a8d07b41c339aa635cc78249442da72ff3f8297398a69\nF ext/repair/test/checkindex01.test b530f141413b587c9eb78ff734de6bb79bc3515c335096108c12c01bddbadcec\nF ext/repair/test/test.tcl 686d76d888dffd021f64260abf29a55c57b2cedfa7fc69150b42b1d6119aac3c\nF ext/rtree/README 6315c0d73ebf0ec40dedb5aa0e942bc8b54e3761\nF ext/rtree/geopoly.c c591164125808f8bba9659e92665b78412cd263e654b6f05294f3a8da7cdd9fb\nF ext/rtree/rtree.c 26fcb3f7a92fda9afcf5eee684cc3188b7367da69bc9c374492d844fb8ed4e25\nF ext/rtree/rtree.h 4a690463901cb5e6127cf05eb8e642f127012fd5003830dbc974eca5802d9412\nF ext/rtree/rtree1.test 4092a8bd2b5eafc4fafe4fe9024249c12b13e4bab23c2c3eaff57412fdf805fa\nF ext/rtree/rtree2.test 9d9deddbb16fd0c30c36e6b4fdc3ee3132d765567f0f9432ee71e1303d32603d\nF ext/rtree/rtree3.test 4ee5d7df86040efe3d8d84f141f2962a7745452200a7cba1db06f86d97050499\nF ext/rtree/rtree4.test 304de65d484540111b896827e4261815e5dca4ce28eeecd58be648cd73452c4b\nF ext/rtree/rtree5.test 49c9041d713d54560b315c2c7ef7207ee287eba1b20f8266968a06f2e55d3142\nF ext/rtree/rtree6.test 1252a0439da01d2f1f5cbbdeeb80455a2d68b9bae2a9787937b167a5e3957828\nF ext/rtree/rtree7.test c8fb2e555b128dd0f0bdb520c61380014f497f8a23c40f2e820acc9f9e4fdce5\nF ext/rtree/rtree8.test 2d99006a1386663978c9e1df167554671e4f711c419175b39f332719deb1ce0e\nF ext/rtree/rtree9.test c646f12c8c1c68ef015c6c043d86a0c42488e2e68ed1bb1b0771a7ca246cbabf\nF ext/rtree/rtreeA.test ed2f1be9c06dde0b1ab93a95dd9e87eeaa02db2d30bcb4b9179b69ee3dc3319b\nF ext/rtree/rtreeB.test 4cec297f8e5c588654bbf3c6ed0903f10612be8a2878055dd25faf8c71758bc9\nF ext/rtree/rtreeC.test 6aa87eba4d9a3003b941a1ba77db259c5cabc3fd92fc5a6360f5369520eb9a4d\nF ext/rtree/rtreeD.test fe46aa7f012e137bd58294409b16c0d43976c3bb92c8f710481e577c4a1100dc\nF ext/rtree/rtreeE.test e65d3fc625da1800b412fc8785817327d43ccfec5f5973912d8c9e471928caa9\nF ext/rtree/rtreeF.test 81ffa7ef51c4e4618d497a57328c265bf576990c7070633b623b23cd450ed331\nF ext/rtree/rtreeG.test 1b9ca6e3effb48f4161edaa463ddeaa8fca4b2526d084f9cbf5dbe4e0184939c\nF ext/rtree/rtreeH.test 0885151ee8429242625600ae47142cca935332c70a06737f35af53a7bd7aaf90\nF ext/rtree/rtreeI.test 608e77f7fde9be5a12eae316baef640fffaafcfa90a3d67443e78123e19c4ca4\nF ext/rtree/rtree_perf.tcl 6c18c1f23cd48e0f948930c98dfdd37dfccb5195\nF ext/rtree/rtree_util.tcl db734b4c5e75fed6acc56d9701f2235345acfdec750b5fc7b587936f5f6bceed\nF ext/rtree/rtreecheck.test d67d5b3e9e45bfa8cd90734e8e9302144ac415b8e9176c6f02d4f92892ee8a35\nF ext/rtree/rtreecirc.test aec664eb21ae943aeb344191407afff5d392d3ae9d12b9a112ced0d9c5de298e\nF ext/rtree/rtreeconnect.test 225ad3fcb483d36cbee423a25052a6bbae762c9576ae9268332360c68c170d3d\nF ext/rtree/rtreefuzz001.test eef1ed593bb15886cd5d5367a2f2492f81e315848896cdf7afb6e21454978827\nF ext/rtree/sqlite3rtree.h 03c8db3261e435fbddcfc961471795cbf12b24e03001d0015b2636b0f3881373\nF ext/rtree/tkt3363.test 142ab96eded44a3615ec79fba98c7bde7d0f96de\nF ext/rtree/util/randomshape.tcl 54ee03d0d4a1c621806f7f44d5b78d2db8fac26e0e8687c36c4bd0203b27dbff\nF ext/rtree/viewrtree.tcl eea6224b3553599ae665b239bd827e182b466024\nF ext/rtree/visual01.txt e9c2564083bcd30ec51b07f881bffbf0e12b50a3f6fced0c222c5c1d2f94ac66\nF ext/session/changeset.c 7a1e6a14c7e92d36ca177e92e88b5281acd709f3b726298dc34ec0fb58869cb5\nF ext/session/changesetfuzz.c 227076ab0ae4447d742c01ee88a564da6478bbf26b65108bf8fac9cd8b0b24aa\nF ext/session/changesetfuzz1.test 2e1b90d888fbf0eea5e1bd2f1e527a48cc85f8e0ff75df1ec4e320b21f580b3a\nF ext/session/session1.test 0b2f88995832ea040ae8e83a1ad4afa99c00b85c779d213da73a95ea4113233e\nF ext/session/session2.test 284de45abae4cc1082bc52012ee81521d5ac58e0\nF ext/session/session3.test ce9ce3dfa489473987f899e9f6a0f2db9bde3479\nF ext/session/session4.test 6778997065b44d99c51ff9cece047ff9244a32856b328735ae27ddef68979c40\nF ext/session/session5.test 716bc6fafd625ce60dfa62ae128971628c1a1169\nF ext/session/session6.test 443789bc2fca12e4f7075cf692c60b8a2bea1a26\nF ext/session/session8.test 8e194b3f655d861ca36de5d4de53f702751bab3b\nF ext/session/session9.test 5409d90d8141881d08285ed1c2c0d8d10fb92069\nF ext/session/sessionA.test 1feeab0b8e03527f08f2f1defb442da25480138f\nF ext/session/sessionB.test c4fb7f8a688787111606e123a555f18ee04f65bb9f2a4bb2aa71d55ce4e6d02c\nF ext/session/sessionC.test f8a5508bc059ae646e5ec9bdbca66ad24bc92fe99fda5790ac57e1f59fce2fdf\nF ext/session/sessionD.test 4f91d0ca8afc4c3969c72c9f0b5ea9527e21de29039937d0d973f821e8470724\nF ext/session/sessionE.test b2010949c9d7415306f64e3c2072ddabc4b8250c98478d3c0c4d064bce83111d\nF ext/session/sessionF.test d37ed800881e742c208df443537bf29aa49fd56eac520d0f0c6df3e6320f3401\nF ext/session/sessionG.test 3828b944cd1285f4379340fd36f8b64c464fc84df6ff3ccbc95578fd87140b9c\nF ext/session/sessionH.test a417559f29a7e775950fc5fc82b3d01256a7cbe793ddf1180df234df823d56e2\nF ext/session/session_common.tcl 29ec9910aca1e996ca1c8531b8cecabf96eb576aa53de65a8ff03d848b9a2a8b\nF ext/session/session_speed_test.c dcf0ef58d76b70c8fbd9eab3be77cf9deb8bc1638fed8be518b62d6cbdef88b3\nF ext/session/sessionat.test efe88965e74ff1bc2af9c310b28358c02d420c1fb2705cc7a28f0c1cc142c3ec\nF ext/session/sessiondiff.test ad13dd65664bae26744e1f18eb3cbd5588349b7e9118851d8f9364248d67bcec\nF ext/session/sessionfault.test da273f2712b6411e85e71465a1733b8501dbf6f7\nF ext/session/sessionfault2.test dd593f80b6b4786f7adfe83c5939620bc505559770cc181332da26f29cddd7bb\nF ext/session/sessioninvert.test ae1a003a9ab1f8d64227dbb5c3a4c97e65b561b01e7b2953cf48683fb2724169\nF ext/session/sessionrebase.test ccfa716b23bd1d3b03217ee58cfd90c78d4b99f53e6a9a2f05e82363b9142810\nF ext/session/sessionstat1.test 218d351cf9fcd6648f125a26b607b140310160184723c2666091b54450a68fb5\nF ext/session/sessionwor.test 67b5ab91d4f93ce65ff1f58240ac5ddf73f8670facc1ffa49cef56293d52818d\nF ext/session/sqlite3session.c a4dfb372f270df93422b0dc7666fd46849e6979b62a152f11287c21eed4ac21b\nF ext/session/sqlite3session.h a2db5b72b938d12c727b4b4ec632254ca493670a9c0de597af3271a7f774fc57\nF ext/session/test_session.c 98797aba475a799376c9a42214f2d1debf2d0c3cb657d9c8bbf4f70bf3fb4aec\nF ext/userauth/sqlite3userauth.h 7f3ea8c4686db8e40b0a0e7a8e0b00fac13aa7a3\nF ext/userauth/user-auth.txt e6641021a9210364665fe625d067617d03f27b04\nF ext/userauth/userauth.c f81aa5a3ecacf406f170c62a144405858f6f6de51dbdc0920134e629edbe2648\nF install-sh 9d4de14ab9fb0facae2f48780b874848cbf2f895 x\nF ltmain.sh 3ff0879076df340d2e23ae905484d8c15d5fdea8\nF magic.txt 8273bf49ba3b0c8559cb2774495390c31fd61c60\nF main.mk 7ce055f3df31a4f7d21e38f493f907c21db1f673863a573e231f55e2ab005023\nF mkso.sh fd21c06b063bb16a5d25deea1752c2da6ac3ed83\nF mptest/config01.test 3c6adcbc50b991866855f1977ff172eb6d901271\nF mptest/config02.test 4415dfe36c48785f751e16e32c20b077c28ae504\nF mptest/crash01.test 61e61469e257df0850df4293d7d4d6c2af301421\nF mptest/crash02.subtest f4ef05adcd15d60e5d2bd654204f2c008b519df8\nF mptest/mptest.c aa41ace6dbc5050d76b02548d3521e6bbccae4f0\nF mptest/multiwrite01.test dab5c5f8f9534971efce679152c5146da265222d\nF spec.template 86a4a43b99ebb3e75e6b9a735d5fd293a24e90ca\nF sqlite.pc.in 42b7bf0d02e08b9e77734a47798d1a55a9e0716b\nF sqlite3.1 fc7ad8990fc8409983309bb80de8c811a7506786\nF sqlite3.pc.in 48fed132e7cb71ab676105d2a4dc77127d8c1f3a\nF src/alter.c ef3519bcc3da6e1d8c0bda63233fb315c99f08e8cd74fe3afb9eeaa2b424bfd4\nF src/analyze.c b3ceec3fc052df8a96ca8a8c858d455dc5029ba681b4be98bb5c5a9162cfa58c\nF src/attach.c b30c44333d55a68c0a12920b5b9d40b254cbd3d4509bda77417209eeed8b3d80\nF src/auth.c a3d5bfdba83d25abed1013a8c7a5f204e2e29b0c25242a56bc02bb0c07bf1e06\nF src/backup.c f70077d40c08b7787bfe934e4d1da8030cb0cc57d46b345fba2294b7d1be23ab\nF src/bitvec.c 17ea48eff8ba979f1f5b04cc484c7bb2be632f33\nF src/btmutex.c 8acc2f464ee76324bf13310df5692a262b801808984c1b79defb2503bbafadb6\nF src/btree.c d22498af716953400e314d2d98d1dac3ea5c3b01e0fd243ef9e9b132c74114ec\nF src/btree.h f27a33c49280209a93385e218306c4ee5f46ba8d7649d2f81a7166b282232484\nF src/btreeInt.h 91806f01fd1145a9a86ba3042f25c38d8faf6002701bf5e780742cf88bcff437\nF src/build.c 7c277ccc24c249b84f29ba829b0ed377e78487c93d17d999798641be0c20fad5\nF src/callback.c 88615dfc0a82167b65b452b4b305dbf86be77200b3343c6ffc6d03e92a01d181\nF src/complete.c a3634ab1e687055cd002e11b8f43eb75c17da23e\nF src/ctime.c 1b0724e66f95f33b160b1af85caaf9cceb325d22abf39bd24df4f54a73982251\nF src/date.c e1d8ac7102f3f283e63e13867acb0efa33861cf34f0faf4cdbaf9fa7a1eb7041\nF src/dbpage.c 135eb3b5e74f9ef74bde5cec2571192c90c86984fa534c88bf4a055076fa19b7\nF src/dbstat.c 6c407e549406c10fde9ac3987f6d734459205239ad370369bc5fcd683084a4fa\nF src/delete.c a5c59b9c0251cf7682bc52af0d64f09b1aefc6781a63592c8f1136f7b73c66e4\nF src/expr.c 947911a1826673add2311e8650aeaf9c2809706dfaa45fc2445a5ff32f70693d\nF src/fault.c 460f3e55994363812d9d60844b2a6de88826e007\nF src/fkey.c 92a248ec0fa4ed8ab60c98d9b188ce173aaf218f32e7737ba77deb2a684f9847\nF src/func.c ed33e38cd642058182a31a3f518f2e34f4bbe53aa483335705c153c4d3e50b12\nF src/global.c a1a8d698762ddd9a1543aac26c1e0029b20fcc3fcb56bfa41ec8cea2368f2798\nF src/hash.c 8d7dda241d0ebdafb6ffdeda3149a412d7df75102cecfc1021c98d6219823b19\nF src/hash.h 9d56a9079d523b648774c1784b74b89bd93fac7b365210157482e4319a468f38\nF src/hwtime.h cb1d7e3e1ed94b7aa6fde95ae2c2daccc3df826be26fc9ed7fd90d1750ae6144\nF src/in-operator.md 10cd8f4bcd225a32518407c2fb2484089112fd71\nF src/insert.c 730455b1530552212ef67bf51dde86090d3995c432fb5806cd1addc58f2919b7\nF src/legacy.c d7874bc885906868cd51e6c2156698f2754f02d9eee1bae2d687323c3ca8e5aa\nF src/loadext.c d74f5e7bd51f3c9d283442473eb65aef359664efd6513591c03f01881c4ae2da\nF src/main.c 868ae7db7a54fe859bf2ca8b7a4f24e9fa03a6134abfb7c9801d08411ef5dacb\nF src/malloc.c 550021fcae36f0ffe9f8563d83e6385f9df307a854d55d7d0abb7241ee8dbcc6\nF src/mem0.c 6a55ebe57c46ca1a7d98da93aaa07f99f1059645\nF src/mem1.c c12a42539b1ba105e3707d0e628ad70e611040d8f5e38cf942cee30c867083de\nF src/mem2.c f1940d9e91948dd6a908fbb9ce3835c36b5d83c3\nF src/mem3.c 8768ac94694f31ffaf8b4d0ea5dc08af7010a35a\nF src/mem5.c 9bf955937b07f8c32541c8a9991f33ce3173d944\nF src/memdb.c 02a5fcec19b9d40dd449ca802dc1b2e8f93f255fbf2a886277a3c3800d8d35db\nF src/memjournal.c 7561c01c90958f3ba9bc6cb2d857123d932bdfa5539ea34427a0957b2e35154d\nF src/msvc.h 3a15918220367a8876be3fa4f2abe423a861491e84b864fb2b7426bf022a28f8\nF src/mutex.c bae36f8af32c22ad80bbf0ccebec63c252b6a2b86e4d3e42672ff287ebf4a604\nF src/mutex.h a7b2293c48db5f27007c3bdb21d438873637d12658f5a0bf8ad025bb96803c4a\nF src/mutex_noop.c 9d4309c075ba9cc7249e19412d3d62f7f94839c4\nF src/mutex_unix.c aaf9ebc3f89df28483c52208497a99a02cc3650011422fc9d4c57e4392f7fe58\nF src/mutex_w32.c 7670d770c94bbfe8289bec9d7f1394c5a00a57c37f892aab6b6612d085255235\nF src/notify.c 9711a7575036f0d3040ba61bc6e217f13a9888e7\nF src/os.c 669cc3839cc35d20f81faf0be1ab6d4581cea35e9d8f3a9d48a98d6571f7c285\nF src/os.h 48388821692e87da174ea198bf96b1b2d9d83be5dfc908f673ee21fafbe0d432\nF src/os_common.h b2f4707a603e36811d9b1a13278bffd757857b85\nF src/os_setup.h 0dbaea40a7d36bf311613d31342e0b99e2536586\nF src/os_unix.c 3e0e519f27683083a465e948e056759a8340728c222b5c394a135e0c57c220bc\nF src/os_win.c 035a813cbd17f355bdcad7ab894af214a9c13a1db8aeac902365350b98cd45a7\nF src/os_win.h 7b073010f1451abe501be30d12f6bc599824944a\nF src/pager.c 30f20d2263d3717f41a0d9a40f7a3d0f48ce1cfab461b875c6187ead9d6ad1c7\nF src/pager.h 217921e81eb5fe455caa5cda96061959706bcdd29ddb57166198645ef7822ac3\nF src/parse.y 17c1ae265e1b92cb1f3f1661b020e3eb31f2d8b9588322d2b6f2b22f25b674c9\nF src/pcache.c 385ff064bca69789d199a98e2169445dc16e4291fa807babd61d4890c3b34177\nF src/pcache.h 4f87acd914cef5016fae3030343540d75f5b85a1877eed1a2a19b9f284248586\nF src/pcache1.c 62714cbd1b7299a6e6a27a587b66b4fd3a836a84e1181e7f96f5c34a50917848\nF src/pragma.c 36c367a62a9d3415fd3d15523e794cccc2cb74e6d806662b0185b8c686f06acb\nF src/pragma.h ec3b31eac9b1df040f1cc8cb3d89bc06605c3b4cb3d76f833de8d6d6c3f77f04\nF src/prepare.c 6049beb71385f017af6fc320d2c75a4e50b75e280c54232442b785fbb83df057\nF src/printf.c 9be6945837c839ba57837b4bc3af349eba630920fa5532aa518816defe42a7d4\nF src/random.c 80f5d666f23feb3e6665a6ce04c7197212a88384\nF src/resolve.c 618bf4f57fa0617cd5295117fea5f25955b76d278303405a8551c4204593011e\nF src/rowset.c d977b011993aaea002cab3e0bb2ce50cf346000dff94e944d547b989f4b1fe93\nF src/select.c 0fe10579de20eb8dc04ec9ed29659fa782bee2bcc85a35734637f3e2cabc2762\nF src/shell.c.in 4a3a9e1c11847b1904f2b01d087af1c052f660902755abab457cab1756817ded\nF src/sqlite.h.in 2a23e8161775253d9cf383c2c6aa559005dc787d350dcb0be67a6c4cc3bd1d19\nF src/sqlite3.rc 5121c9e10c3964d5755191c80dd1180c122fc3a8\nF src/sqlite3ext.h 72af51aa4e912e14cd495fb6e7fac65f0940db80ed950d90911aff292cc47ce2\nF src/sqliteInt.h 1ac4dfde728b9d5812d1223d668d5e1f43c6fe4f469d6a7a482f298a10a03210\nF src/sqliteLimit.h 1513bfb7b20378aa0041e7022d04acb73525de35b80b252f1b83fedb4de6a76b\nF src/status.c 46e7aec11f79dad50965a5ca5fa9de009f7d6bde08be2156f1538a0a296d4d0e\nF src/table.c b46ad567748f24a326d9de40e5b9659f96ffff34\nF src/tclsqlite.c 8cd2600e8de23dff6cdf84d39f46ca57139b061b28f6f80b166bace17d52ab1c\nF src/test1.c c654981c1d86ebc90dd23fcc0969e6c85e28112f0acc2e2224a97a2a33e7c42f\nF src/test2.c 3efb99ab7f1fc8d154933e02ae1378bac9637da5\nF src/test3.c 61798bb0d38b915067a8c8e03f5a534b431181f802659a6616f9b4ff7d872644\nF src/test4.c 405834f6a93ec395cc4c9bb8ecebf7c3d8079e7ca16ae65e82d01afd229694bb\nF src/test5.c 328aae2c010c57a9829d255dc099d6899311672d\nF src/test6.c e8d839fbc552ce044bec8234561a2d5b8819b48e29548ad0ba400471697946a8\nF src/test7.c 5612e9aecf934d6df7bba6ce861fdf5ba5456010\nF src/test8.c 3f7d0cc4e12e06832ba3db4455cb16867ccadafa602eb6ff5fcf097bffce56ed\nF src/test9.c 12e5ba554d2d1cbe0158f6ab3f7ffcd7a86ee4e5\nF src/test_async.c 195ab49da082053fdb0f949c114b806a49ca770a\nF src/test_autoext.c 915d245e736652a219a907909bb6710f0d587871\nF src/test_backup.c bf5da90c9926df0a4b941f2d92825a01bbe090a0\nF src/test_bestindex.c 78809f11026f18a93fcfd798d9479cba37e1201c830260bf1edc674b2fa9b857\nF src/test_blob.c ae4a0620b478548afb67963095a7417cd06a4ec0a56adb453542203bfdcb31ce\nF src/test_btree.c 8b2dc8b8848cf3a4db93f11578f075e82252a274\nF src/test_config.c e25826d693039cdd45963de378cbf39e3af0e8aa7a8a6fc159876f4e7b5a4f8c\nF src/test_delete.c e2fe07646dff6300b48d49b2fee2fe192ed389e834dd635e3b3bac0ce0bf9f8f\nF src/test_demovfs.c 86142ba864d4297d54c5b2e972e74f3141ae4b30f05b3a95824184ed2d3d7f91\nF src/test_devsym.c 6109b45c3db3ef7b002320947ed448c027356ab8b885156ff535fd8684d4a571\nF src/test_fs.c ba1e1dc18fd3159fdba0b9c4256f14032159785320dfbd6776eb9973cb75d480\nF src/test_func.c 181f992e5495644434c4f0e3cc72362a78c295eb2cf3ff4d02498b8bde7aa276\nF src/test_hexio.c d170d0e1a6431afdeac086a250d2595078288c2257615d37949355361399bcaa\nF src/test_init.c 4413c211a94b62157ca4c145b3f27c497f03c664\nF src/test_intarray.c 39b4181662a0f33a427748d87218e7578d913e683dc27eab7098bb41617cac71\nF src/test_intarray.h d57ae92f420cda25e22790dac474d60961bd0c500cbaa3338a05152d4a669ef7\nF src/test_journal.c a0b9709b2f12b1ec819eea8a1176f283bca6d688a6d4a502bd6fd79786f4e287\nF src/test_loadext.c 337056bae59f80b9eb00ba82088b39d0f4fe6dfd\nF src/test_malloc.c dec0aa821b230773aeb3dd11d652c1193f7cedb18a20b25659bc672288115242\nF src/test_md5.c 7268e1e8c399d4a5e181b64ac20e1e6f3bc4dd9fc87abac02db145a3d951fa8c\nF src/test_multiplex.c e054459f7633f3ff8ce1245da724f9a8be189e4e\nF src/test_multiplex.h 5436d03f2d0501d04f3ed50a75819e190495b635\nF src/test_mutex.c 7f4337ba23ee6b1d2ec81c189653608cb069926a\nF src/test_onefile.c f31e52e891c5fef6709b9fcef54ce660648a34172423a9cbdf4cbce3ba0049f4\nF src/test_osinst.c 98ef31ff03d55497829ca0f6c74a9f4e1aa48690\nF src/test_pcache.c a5cd24730cb43c5b18629043314548c9169abb00\nF src/test_quota.c 6cb9297115b551f433a9ad1741817a9831abed99\nF src/test_quota.h 2a8ad1952d1d2ca9af0ce0465e56e6c023b5e15d\nF src/test_rtree.c 671f3fae50ff116ef2e32a3bf1fe21b5615b4b7b\nF src/test_schema.c f575932cb6274d12147a77e13ea4b49d52408513\nF src/test_server.c a2615049954cbb9cfb4a62e18e2f0616e4dc38fe\nF src/test_sqllog.c 11e6ce7575f489155c604ac4b439f2ac1d3d5aef\nF src/test_superlock.c 4839644b9201da822f181c5bc406c0b2385f672e\nF src/test_syscall.c 1073306ba2e9bfc886771871a13d3de281ed3939\nF src/test_tclsh.c eeafce33ad2136d57e5dec10f1e9a4347447eb72ffd504a1c7b9c6bfe2e71578\nF src/test_tclvar.c 33ff42149494a39c5fbb0df3d25d6fafb2f668888e41c0688d07273dcb268dfc\nF src/test_thread.c 911d15fb14e19c0c542bdc8aabf981c2f10a4858\nF src/test_vdbecov.c f60c6f135ec42c0de013a1d5136777aa328a776d33277f92abac648930453d43\nF src/test_vfs.c 36822d696789535bdd0260f07d2c9a46546082fea8bb1d0a7354c7f9366e37ea\nF src/test_vfstrace.c bab9594adc976cbe696ff3970728830b4c5ed698\nF src/test_windirent.c a895e2c068a06644eef91a7f0a32182445a893b9a0f33d0cdb4283dca2486ac1\nF src/test_windirent.h 90dfbe95442c9762357fe128dc7ae3dc199d006de93eb33ba3972e0a90484215\nF src/test_window.c cdae419fdcea5bad6dcd9368c685abdad6deb59e9fc8b84b153de513d394ba3f\nF src/test_wsd.c 41cadfd9d97fe8e3e4e44f61a4a8ccd6f7ca8fe9\nF src/threads.c 4ae07fa022a3dc7c5beb373cf744a85d3c5c6c3c\nF src/tokenize.c 7b17f6e2f20f6cbcb0b215025a86b7457c38451fc7622f705e553d7a488c572d\nF src/treeview.c 41d928f04d65931b15f629b4938e9f2c7dc259f02eef34cb2cc6e293f5af813f\nF src/trigger.c 681ccdb910a87243940d63f99b26190d9c5d2534c2ded3c0825b7c0e315a342e\nF src/update.c 07a50767f7d3e26d4c887c31cd66448d700d3215caea6023acf7269336097df7\nF src/upsert.c b445315c8958d8f17ec3297d06842e61dacaad0633ccaec1e4e160de7e562212\nF src/utf.c 2f0fac345c7660d5c5bd3df9e9d8d33d4c27f366bcfb09e07443064d751a0507\nF src/util.c 66b22af7b359ce6493c34fef28c87d5c2d1765f212d6e4cd5e08d99ac30b89bb\nF src/vacuum.c 82dcec9e7b1afa980288718ad11bc499651c722d7b9f32933c4d694d91cb6ebf\nF src/vdbe.c b67d6af853e03c3dd6d1116351567f62d8a2c10d3bd6db5f7f366e75d11c6653\nF src/vdbe.h fdbc0a11e5768a702b46ce63286f60e22e71351a29bd98b3666405e1fccc7802\nF src/vdbeInt.h bd589b8b7273286858950717e0e1ec5c88b18af45079a3366dc1371865cea704\nF src/vdbeapi.c 1252d80c548711e47a6d84dae88ed4e95d3fbb4e7bd0eaa1347299af7efddf02\nF src/vdbeaux.c 0bbbdc70c573d5112b74a3d555dd51c76ee3f8b6d43cf07e5105ced6a3ec0d10\nF src/vdbeblob.c 253ed82894924c362a7fa3079551d3554cd1cdace39aa833da77d3bc67e7c1b1\nF src/vdbemem.c 2eb00a4d1a7d2c97510a4d1ccaf4e12c9143f2ced1c6b96b5eddc372183c9121\nF src/vdbesort.c a3be032cc3fee0e3af31773af4a7a6f931b7230a34f53282ccf1d9a2a72343be\nF src/vdbetrace.c fa3bf238002f0bbbdfb66cc8afb0cea284ff9f148d6439bc1f6f2b4c3b7143f0\nF src/vtab.c 108f79166d4a232a8bfb9d46e2fbec191f83a87fe97f7b93fc4de976c3fa3434\nF src/vxworks.h d2988f4e5a61a4dfe82c6524dd3d6e4f2ce3cdb9\nF src/wal.c 15a2845769f51ba132f9cf0b2c7a6887a91fc8437892dbcce9fcdc68b66d60a1\nF src/wal.h 606292549f5a7be50b6227bd685fa76e3a4affad71bb8ac5ce4cb5c79f6a176a\nF src/walker.c a137468bf36c92e64d2275caa80c83902e3a0fc59273591b96c6416d3253d05d\nF src/where.c bb2d3c08de9ae57f6ff17459cefd9e38e82d3e7aaa544bc49503b6fdaaf2c800\nF src/whereInt.h 4a296fd4fa79fdcbc2b5e8c1b898901617655811223e1082b899c23ecb092217\nF src/wherecode.c 909325b98d5cb313f24e5c8cb304a3e3c73ca6631cdb19cfa1f580dde182fedb\nF src/whereexpr.c 39b6a538804c6e1248c22b33e09d00f89ae6a099c849c4d841ce3995562287b4\nF src/window.c a77f12078dd4b10e655d4ba5a73ca32dbe00e0206018305185c7e86445d3f429\nF test/8_3_names.test ebbb5cd36741350040fd28b432ceadf495be25b2\nF test/affinity2.test ce1aafc86e110685b324e9a763eab4f2a73f737842ec3b687bd965867de90627\nF test/affinity3.test 6a101af2fc945ce2912f6fe54dd646018551710d\nF test/aggerror.test a867e273ef9e3d7919f03ef4f0e8c0d2767944f2\nF test/aggnested.test 12106f0748e8e9bfc1a8e6840e203e051eae06a26ed13fc9fd5db108a8d6db54\nF test/alias.test 4529fbc152f190268a15f9384a5651bbbabc9d87\nF test/all.test 2ecb8bbd52416642e41c9081182a8df05d42c75637afd4488aace78cc4b69e13\nF test/alter.test 16ed8d2470193f34bc711e51506ff1211ebfab8025ca3b9510ff2aef139874cb\nF test/alter2.test a966ccfcddf9ce0a4e0e6ff1aca9e6e7948e0e242cd7e43fc091948521807687\nF test/alter3.test 9351a9f0c59ff9dddecccaaa2f777ffee5369870c63d30d3a74add815254ec0f\nF test/alter4.test 74b22251c5e9c48093cfc4921ed9c11b59df84634aeeb00e501773320beb8424\nF test/alterauth.test 63442ba61ceb0c1eeb63aac1f4f5cebfa509d352276059d27106ae256bafc959\nF test/alterauth2.test c0a1ddf5b93d93cb0d15ba7acaf0c5c6fb515bbe861ede75b2d3fabad33b6499\nF test/altercol.test 54374d2ba18af25bb24e23acf18a60270d4ec120b7ec0558078b59d5aa1a31ad\nF test/alterlegacy.test 82022721ce0de29cedc9a7af63bc9fcc078b0ee000f8283b4b6ea9c3eab2f44b\nF test/altermalloc.test 167a47de41b5c638f5f5c6efb59784002b196fff70f98d9b4ed3cd74a3fb80c9\nF test/altermalloc2.test fa7b1c1139ea39b8dec407cf1feb032ca8e0076bd429574969b619175ad0174b\nF test/altertab.test 4d8b79b0b88b62b90b710390df14fe99e0a3578345526886eaa550e28e3065dc\nF test/altertab2.test 8883693952f6d7fb5f754dbf1d694ed780aa883027bef04cb1fb99a3b88c9272\nF test/altertab3.test 3faf56b3f5af0dd2c12d954db4746521fc96543222da5b6e2633ed417640ce83\nF test/amatch1.test b5ae7065f042b7f4c1c922933f4700add50cdb9f\nF test/analyze.test 547bb700f903107b38611b014ca645d6b5bb819f5210d7bf39c40802aafeb7d7\nF test/analyze3.test 01f0b122e3e54ad2544f14f7cc7dcb4c2cb8753cad5e88c6b8d49615b3fd6a2b\nF test/analyze4.test cdf88f3f72b0f0643a1ff6c730fc5af1e42464d47478d9fbac84c333f72c014e\nF test/analyze5.test fa5131952303ac4146aba101b116b9c8cb89e2637531c334a6df7f7d19dddc0d\nF test/analyze6.test 6c3f7df2996cb6872f355a6ac1eb6d5de00a5a9288214bad7ef25c97d9cc72dc\nF test/analyze7.test 6ef0b12369f61ddeadc7d8a705c40e6b52cb29f63de3a4c56581b510b46b5783\nF test/analyze8.test 36ce54947710bd44e4f9484e1ad07e725ef01a9d7078b417c1bc884356febe4d\nF test/analyze9.test 9fbf0e0101eef4f5dc149769aa14e10b76ee06e7c28598264b32173cd1999a54\nF test/analyzeC.test 489fe2ea3be3f17548e8dd895f1b41c9669b52de1b0861f5bffe6eec46eac710\nF test/analyzeD.test e50cd0b3e6063216cc0c88a1776e8645dc0bd65a6bb275769cbee33b7fd8d90c\nF test/analyzeE.test 8684e8ac5722fb97c251887ad97e5d496a98af1d\nF test/analyzeF.test 9e1a0537949eb5483642b1140a5c39e5b4025939024b935398471fa552f4dabb\nF test/analyzer1.test 459fa02c445ddbf0101a3bad47b34290a35f2e49\nF test/async.test 1d0e056ba1bb9729283a0f22718d3a25e82c277b\nF test/async2.test c0a9bd20816d7d6a2ceca7b8c03d3d69c28ffb8b\nF test/async3.test d73a062002376d7edc1fe3edff493edbec1fc2f7\nF test/async4.test 1787e3952128aa10238bf39945126de7ca23685a\nF test/async5.test 383ab533fdb9f7ad228cc99ee66e1acb34cc0dc0\nF test/atof1.test ff0b0156fd705b67c506e1f2bfe9e26102bea9bd\nF test/atomic.test 065a453dde33c77ff586d91ccaa6ed419829d492dbb1a5694b8a09f3f9d7d061\nF test/atomic2.test b6863b4aa552543874f80b42fb3063f1c8c2e3d8e56b6562f00a3cc347b5c1da\nF test/atrc.c ec92d56d8fbed9eb3e11aaf1ab98cf7dd59e69dae31f128013f1d97e54e7dfed\nF test/attach.test 21bce8681f780a8d631a5ec7ecd0d849bfe84611257b038ae4ffeccc609d8a4e\nF test/attach2.test 256bd240da1835fb8408dd59fb7ef71f8358c7a756c46662434d11d07ba3a0ce\nF test/attach3.test c59d92791070c59272e00183b7353eeb94915976\nF test/attach4.test aa05b1d8218b24eba5a7cccf4f224f514ba57ba705c9267f09d2bb63fed0eea1\nF test/attachmalloc.test 12c4f028e570acf9e0a4b0b7fe6f536e21f3d5ebddcece423603d0569beaf438\nF test/auth.test 2154625c05bc79f0e0ea72cb2358395a8041243caa0fd7ce7617d50da4331794\nF test/auth2.test 9eb7fce9f34bf1f50d3f366fb3e606be5a2000a1\nF test/auth3.test db21405b95257c24d29273b6b31d0efc59e1d337e3d5804ba2d1fd4897b1ae49\nF test/autoanalyze1.test b9cc3f32a990fa56669b668d237c6d53e983554ae80c0604992e18869a0b2dec\nF test/autoinc.test 997d6f185f138229dc4251583a1d04816423dddc2fc034871a01aeb1d728cb39\nF test/autoindex1.test 96185415f5faacd5b8d7a7f505efddd5abb1f111d58338e9c0b1dc40b87cd3cc\nF test/autoindex2.test 12ef578928102baaa0dc23ad397601a2f4ecb0df\nF test/autoindex3.test 2dd997d6590438b53e4f715f9278aa91c9299cf3f81246a0915269c35beb790e\nF test/autoindex4.test 49d3cd791a9baa16fb461d7ea3de80d019a819cf\nF test/autoindex5.test a5d72fe8c217cc0ea356dc6fa06a282a8a3fc53aa807709d79dba07a8f248102\nF test/autovacuum.test 0831cd34e14695d297187f7f6519265e3121c5b0a1720e548e86829e796129e9\nF test/autovacuum_ioerr2.test 8a367b224183ad801e0e24dcb7d1501f45f244b4\nF test/avtrans.test b7dc25459ecbd86c6fa9c606ee3068f59d81e225118617dcf2bbb6ded2ade89e\nF test/backcompat.test 3e64cedda754c778ef6bbe417b6e7a295e662a4d\nF test/backup.test dd4a5ff756e3df3931dacb1791db0584d4bad989\nF test/backup2.test 1fd1ad8c5b3d2d5b9c0cce4143a4fc610d51ddc6ae16a7a122973d43e6b50bbd\nF test/backup4.test 8f6fd48e0dfde77b9a3bb26dc471ede3e101df32\nF test/backup5.test ee5da6d7fe5082f5b9b0bbfa31d016f52412a2e4\nF test/backup_ioerr.test 4c3c7147cee85b024ecf6e150e090c32fdbb5135\nF test/backup_malloc.test 0c9abdf74c51e7bedb66d504cd684f28d4bd4027\nF test/badutf.test d5360fc31f643d37a973ab0d8b4fb85799c3169f\nF test/badutf2.test f310fd3b24a491b6b77bccdf14923b85d6ebcce751068c180d93a6b8ff854399\nF test/bc_common.tcl b5e42d80305be95697e6370e015af571e5333a1c\nF test/bestindex1.test 705b57d7f51d53ee5fd043dd9666236e1fc18f4d59abf51da0ea5ea1b4804947\nF test/bestindex2.test 9a0ccd320b6525eec3a706aae6cdab7e1b7b5abca75027e39f39f755e76e5928\nF test/bestindex3.test 7622e792ff2da16d262d3cea6ad914591ac4806d57ed128e6c940b7920b47b84\nF test/bestindex4.test 038e3d0789332f3f1d61474f9bbc9c6d08c6bd1783a978f31f38ad82688de601\nF test/bestindex5.test 67c1166131bb59f9e47c00118f7d432ca5491e6cae6ca3f87ca9db20103a78f9\nF test/bestindex6.test d856a9bb63d927493575823eed44053bc36251e241aa364e54d0f2a2d302e1d4\nF test/between.test 68137a6e941c221417c15b6fe2d55f27bb1b6ab48bdf9e2aa51efdd85bc53802\nF test/bigfile.test aa74f4e5db51c8e54a1d9de9fa65d01d1eb20b59\nF test/bigfile2.test 1b489a3a39ae90c7f027b79110d6b4e1dbc71bfc\nF test/bigmmap.test 31dad31573638bd32de866cdefd11843f75685be4ba6aec1a47918f098f1899b\nF test/bigrow.test f0aeb7573dcb8caaafea76454be3ade29b7fc747\nF test/bigsort.test 8299fa9298f4f1e02fc7d2712e8b77d6cd60e5a2\nF test/bind.test 1e136709b306f7ed3192d349c2930d89df6ab621654ad6f1a72381d3fe76f483\nF test/bindxfer.test efecd12c580c14df5f4ad3b3e83c667744a4f7e0\nF test/bitvec.test 75894a880520164d73b1305c1c3f96882615e142\nF test/blob.test e7ac6c7d3a985cc4678c64f325292529a69ae252\nF test/boundary1.tcl 6421b2d920d8b09539503a8673339d32f7609eb1\nF test/boundary1.test 66d7f4706ccdb42d58eafdb081de07b0eb42d77b\nF test/boundary2.tcl e34ef4e930cf1083150d4d2c603e146bd3b76bcb\nF test/boundary2.test 9ae758d7dab7e882c8b6cc4a6a10278385bff8fa\nF test/boundary3.tcl 23361e108a125dca9c4080c2feb884fe54d69243\nF test/boundary3.test 56ef82096b4329aca2be74fa1e2b0f762ea0eb45\nF test/boundary4.tcl 0bb4b1a94f4fc5ae59b79b9a2b7a140c405e2983\nF test/boundary4.test 89e02fa66397b8a325d5eb102b5806f961f8ec4b\nF test/btree01.test e08b3613540145b353f20c81cb18ead54ff12e0f\nF test/btree02.test 7555a5440453d900410160a52554fe6478af4faf53098f7235f1f443d5a1d6cc\nF test/btreefault.test c2bcb542685eea44621275cfedbd8a13f65201e3\nF test/busy.test 510dc6daaad18bcbbc085bcc6217d6dc418def5e73f72ce1475eea0cb7834727\nF test/cache.test 13bc046b26210471ca6f2889aceb1ea52dc717de\nF test/cacheflush.test af25bb1509df04c1da10e38d8f322d66eceedf61\nF test/cachespill.test 895997f84a25b323b166aecb69baab2d6380ea98f9e0bcc688c4493c535cfab9\nF test/capi2.test 34a1a9a96d543a2ec2c209696b11b164444f57253b1f2cba1c2e53fadede6c7b\nF test/capi3.test 3910a73c38ac76d69778dd9eb481ab7cd6ed59117fc047b4f6056a5c72529de1\nF test/capi3b.test efb2b9cfd127efa84433cd7a2d72ce0454ae0dc4\nF test/capi3c.test 54e2dc0c8fd7c34ad1590d1be6864397da2438c95a9f5aee2f8fbc60c112e44b\nF test/capi3d.test aba917805573a03deed961a21f07a5a84505ad0a616f7e3fc1508844a15bccc4\nF test/capi3e.test 3d49c01ef2a1a55f41d73cba2b23b5059ec460fe\nF test/cast.test 3619f0c58c2e4b2a94aa86e75607e497d34ef40ab74418e71aef7b4ca5155895\nF test/cffault.test 9d6b20606afe712374952eec4f8fd74b1a8097ef\nF test/check.test 25c6035302c846c7ff8e681cf8284473f6f01be94d327de60a688ad84ab01f8b\nF test/checkfault.test da6cb3d50247169efcb20bdf57863a3ccfa1d27d9e55cd324f0680096970f014\nF test/chunksize.test 427d87791743486cbf0c3b8c625002f3255cb3a89c6eba655a98923b1387b760\nF test/close.test eccbad8ecd611d974cbf47278c3d4e5874faf02d811338d5d348af42d56d647c\nF test/closure01.test 9905883f1b171a4638f98fc764879f154e214a306d3d8daf412a15e7f3a9b1e0\nF test/coalesce.test cee0dccb9fbd2d494b77234bccf9dc6c6786eb91\nF test/collate1.test 4178fda6f4cd757b7a278e6b83805868fb1eb46edafb6e3d4bcc2419f8d93202\nF test/collate2.test 9aaa410a00734e48bcb27f3872617d6f69b2a621\nF test/collate3.test 89defc49983ddfbf0a0555aca8c0521a676f56a5\nF test/collate4.test c953715fb498b87163e3e73dd94356bff1f317bd\nF test/collate5.test 65d928034d30d2d263a80f6359f7549ee1598ec6\nF test/collate6.test 8be65a182abaac8011a622131486dafb8076e907\nF test/collate7.test 8ec29d98f3ee4ccebce6e16ce3863fb6b8c7b868\nF test/collate8.test cd9b3d3f999b8520ffaa7cc1647061fc5bab1334\nF test/collate9.test 3adcc799229545940df2f25308dd1ad65869145a\nF test/collateA.test b8218ab90d1fa5c59dcf156efabb1b2599c580d6\nF test/collateB.test 1e68906951b846570f29f20102ed91d29e634854ee47454d725f2151ecac0b95\nF test/colmeta.test 2c765ea61ee37bc43bbe6d6047f89004e6508eb1\nF test/colname.test 87ad5458bb8709312dac0d6755fd30e8e4ca83298d0a9ef6e5c24277a3c3390e\nF test/conflict.test c7cc007e2af151516ddf38f7412fe10d473a694f55e3df437e2c7b31c2590e8d\nF test/conflict2.test bb0b94cf7196c64a3cbd815c66d3ee98c2fecd9c\nF test/conflict3.test f62a2d0cad9162a60e6458fc913dff3a2208feca924120c21737cfee65a6a74a\nF test/contrib01.test 2a1cbc0f2f48955d7d073f725765da6fbceda6b4\nF test/corrupt.test d7cb0300e4a297147b6a05e92a1684bc8973635c3bcaa3d66e983c9cbdbf47a3\nF test/corrupt2.test bb50042cf9a1f1023d73af325d47eb02a6bb11e3c52f8812644b220c5d4bca35\nF test/corrupt3.test f95d7bf78109e0b84eb285a787ce91a3fd6a2dd7d0cb55882abff3bdc081a57e\nF test/corrupt4.test 8d1d86b850fcc43e417450454f2044e52d55778a\nF test/corrupt5.test 387be3250795e2a86e6234745558b80efb248a357d0cd8e53bce75c7463f545d\nF test/corrupt6.test fc6a891716139665dae0073b6945e3670bf92568\nF test/corrupt7.test b036f94bda4b0b23a2919bf717046ce9ecca4543\nF test/corrupt8.test 2399dfe40d2c0c63af86706e30f3e6302a8d0516\nF test/corrupt9.test 730a3db08d4ab9aa43392ea30d9c2b4879cbff85\nF test/corruptA.test 112f4b2ae0b95ebf3ea63718642fb969a93acea557ace3a307234d19c245989b\nF test/corruptB.test 73a8d6c0b9833697ecf16b63e3c5c05c945b5dec\nF test/corruptC.test 74d4498fd25759618b393f1e9cde111de828b88c1848ab320f6c179fd52b5a60\nF test/corruptD.test 33a37ce3ed56a20093ceee778cd2d7109c7085a59f3213d2baede11d952e8e50\nF test/corruptE.test 4143791f2dfb443aec5b7fabfa5821e6063eccc3b49b06f212c2f014715fd476\nF test/corruptF.test be9fde98e4c93648f1ba52b74e5318edc8f59fe4\nF test/corruptG.test adf79b669cbfd19e28c8191a610d083ae53a6d51\nF test/corruptH.test 79801d97ec5c2f9f3c87739aa1ec2eb786f96454\nF test/corruptI.test a17bbf54fdde78d43cf3cc34b0057719fd4a173a3d824285b67dc5257c064c7b\nF test/corruptJ.test 4d5ccc4bf959464229a836d60142831ef76a5aa4\nF test/corruptK.test 5b4212fe346699831c5ad559a62c54e11c0611bdde1ea8423a091f9c01aa32af\nF test/corruptL.test a22a7bbf8da7603960f0bfcc62a68d1c3c41963786bd832ff804ba5e2458fb9c\nF test/corruptM.test 7d574320e08c1b36caa3e47262061f186367d593a7e305d35f15289cc2c3e067\nF test/cost.test 51f4fcaae6e78ad5a57096831259ed6c760e2ac6876836e91c00030fad385b34\nF test/count.test cb2e0f934c6eb33670044520748d2ecccd46259c\nF test/countofview.test e17d6e6688cf74f22783c9ec6e788c0790ee4fbbaee713affd00b1ac0bb39b86\nF test/coveridxscan.test 5ec98719a2e2914e8908dc75f7247d9b54a26df04625f846ac7900d5483f7296\nF test/crash.test fb9dc4a02dcba30d4aa5c2c226f98b220b2b959f\nF test/crash2.test 5b14d4eb58b880e231361d3b609b216acda86651\nF test/crash3.test 8f5de9d32ab9ab95475a9efe7f47a940aa889418\nF test/crash4.test fe2821baf37168dc59dd733dcf7dba2a401487bc\nF test/crash5.test f14ff37eddc41991be4eb63568f86caa306fd9962a0ae3750db8836777bb7aae\nF test/crash6.test 4c56f1e40d0291e1110790a99807aa875b1647ba\nF test/crash7.test 1a194c4900a255258cf94b7fcbfd29536db572df\nF test/crash8.test 64366e459c28dd62edfb7ad87253a409c7533b92d16fcc479a6a8131bdcc3100\nF test/crashM.test d95f59046fa749b0d0822edf18a717788c8f318d\nF test/crashtest1.c 09c1c7d728ccf4feb9e481671e29dda5669bbcc2\nF test/createtab.test 85cdfdae5c3de331cd888d6c66e1aba575b47c2e3c3cc4a1d6f54140699f5165\nF test/cse.test 277350a26264495e86b1785f34d2d0c8600e021c\nF test/csv01.test c9c3af0d58c34e9ac970c5875a77939edb958762c8aafb95409e19a3f088b6cd\nF test/ctime.test 78749e6c9a5f0010d67985be80788f841e3cd2da18114e2ed6010399a7d807f3\nF test/cursorhint.test 7bc346788390475e77a345da2b92270d04d35856\nF test/cursorhint2.test 6f3aa9cb19e7418967a10ec6905209bcbb5968054da855fc36c8beee9ae9c42f\nF test/dataversion1.test 6e5e86ac681f0782e766ebcb56c019ae001522d114e0e111e5ebf68ccf2a7bb8\nF test/date.test 9b73bbeb1b82d9c1f44dec5cf563bf7da58d2373\nF test/date2.test 5ef8265c71460cda6b1698bf18f4bb0ffb40ac08c5092f6afe84d398c2feb5be\nF test/dbdata.test 042f49acff3438f940eeba5868d3af080ae64ddf26ae78f80c92bec3ca7d8603\nF test/dbfuzz.c 73047c920d6210e5912c87cdffd9a1c281d4252e\nF test/dbfuzz001.test 42aad1dcef6219fbee86a9b7d08832c9bbb2e41508f6f128ae91745927276292\nF test/dbfuzz2-seed1.db e6225c6f3d7b63f9c5b6867146a5f329d997ab105bee64644dc2b3a2f2aebaee\nF test/dbfuzz2.c c2c9cb40082a77b7e95ffb8b2da1e93322efadfb1c8c1e0001c95a0af1e156c2\nF test/dbpage.test 650234ba683b9d82b899c6c51439819787e7609f17a0cc40e0080a7b6443bc38\nF test/dbstatus.test 4a4221a883025ffd39696b3d1b3910b928fb097d77e671351acb35f3aed42759\nF test/dbstatus2.test f5fe0afed3fa45e57cfa70d1147606c20d2ba23feac78e9a172f2fe8ab5b78ef\nF test/default.test 3e46c421eebefd2787c2f96673efabf792d360f3a1d5073918cbe450ce672a62\nF test/delete.test 31832b0c45ecb51a54348c68db173be462985901e6ed7f403d6d7a8f70ab4ef0\nF test/delete2.test 3a03f2cca1f9a67ec469915cb8babd6485db43fa\nF test/delete3.test 555e84a00a99230b7d049d477a324a631126a6ab\nF test/delete4.test 6aa279f459f4aa792cc251435c3809415c1ecaf9f27dce91675e26f05b503db3\nF test/delete_db.test 096d828493c7907f9ea11a7098ea6a0f73edba89406487d5d6cc2228dc4ab8b0\nF test/descidx1.test edc8adee58d491b06c7157c50364eaf1c3605c9c19f8093cb1ea2b6184f3ac13\nF test/descidx2.test a0ba347037ff3b811f4c6ceca5fd0f9d5d72e74e59f2d9de346a9d2f6ad78298\nF test/descidx3.test 953c831df7ea219c73826dfbf2f6ee02d95040725aa88ccb4fa43d1a1999b926\nF test/diskfull.test 106391384780753ea6896b7b4f005d10e9866b6e\nF test/distinct.test a1783b960ad8c15a77cd9f207be072898db1026c\nF test/distinct2.test 11b0594c932098e969d084ba45ab81d5040f4d4e766db65d49146705a305ed98\nF test/distinctagg.test 1a6ef9c87a58669438fc771450d7a72577417376\nF test/e_blobbytes.test 439a945953b35cb6948a552edaec4dc31fd70a05\nF test/e_blobclose.test 4b3c8c60c2171164d472059c73e9f3c1844bb66d\nF test/e_blobopen.test e95e1d40f995056f6f322cd5e1a1b83a27e1a145\nF test/e_blobwrite.test f87ff598b67af5b3ec002a8d83e804dc8d23808e88cf0080c176612fc9ffce14\nF test/e_changes.test fd66105385153dbf21fdb35eb8ef6c3e1eade579\nF test/e_createtable.test 1c602347e73ab80b11b9fa083f47155861aaafcff8054aac9e0b76d0df33b0a7\nF test/e_delete.test ab39084f26ae1f033c940b70ebdbbd523dc4962e\nF test/e_droptrigger.test 3cd080807622c13e5bbb61fc9a57bd7754da2412\nF test/e_dropview.test 21ce09c361227ddbc9819a5608ee2700c276bdd5\nF test/e_expr.test 328d2d7c84f8e53e942a13eac771b337bcdfcf4c3569324001868b5639f3c857\nF test/e_fkey.test 2febb2084aef9b0186782421c07bc9d377abf067c9cb4efd49d9647ae31f5afe\nF test/e_fts3.test 17ba7c373aba4d4f5696ba147ee23fd1a1ef70782af050e03e262ca187c5ee07\nF test/e_insert.test f02f7f17852b2163732c6611d193f84fc67bc641fb4882c77a464076e5eba80e\nF test/e_reindex.test 2b0e29344497d9a8a999453a003cb476b6b1d2eef2d6c120f83c2d3a429f3164\nF test/e_resolve.test a61751c368b109db73df0f20fc75fb47e166b1d8\nF test/e_select.test f9474205669a7736ef725b29cc7ae9e8601919a3d0ffc0ab30745a028f2a4b61\nF test/e_select2.test aceb80ab927d46fba5ce7586ebabf23e2bb0604f\nF test/e_totalchanges.test b12ee5809d3e63aeb83238dd501a7bca7fd72c10\nF test/e_update.test f46c2554d915c9197548681e8d8c33a267e84528\nF test/e_uri.test 47eeb2960e74613f0f8722b2f13aef08fde69daa16e5380ac93df84dac8b1f72\nF test/e_vacuum.test 0d8832a2ce92350db0d0cff47b419465fd9772562e1f77ff7d9478c07a4980d2\nF test/e_wal.test ae9a593207a77d711443ee69ffe081fda9243625\nF test/e_walauto.test 248af31e73c98df23476a22bdb815524c9dc3ba8\nF test/e_walckpt.test 28c371a6bb5e5fe7f31679c1df1763a19d19e8a0\nF test/e_walhook.test 01b494287ba9e60b70f6ebf3c6c62e0ffe01788e344a4846b08e5de0b344cb66\nF test/emptytable.test a38110becbdfa6325cd65cb588dca658cd885f62\nF test/enc.test e54531cd6bf941ee6760be041dff19a104c7acea\nF test/enc2.test 83437a79ba1545a55fb549309175c683fb334473\nF test/enc3.test 6807f7a7740a00361ca8d0ccd66bc60c8dc5f2b6\nF test/enc4.test c8f1ce3618508fd0909945beb8b8831feef2c020\nF test/eqp.test 84879b63e3110552bf8ce648a3507dc3ceb72109ecec83c2aef0db37a27f6382\nF test/errmsg.test eae9f091eb39ce7e20305de45d8e5d115b68fa856fba4ea6757b6ca3705ff7f9\nF test/eval.test a64c9105d6ff163df7cf09d6ac29cdad5922078c\nF test/exclusive.test 1206b87e192497d78c7f35552e86a9d05421498da300fb1cce5ca5351ccde3c3\nF test/exclusive2.test 984090e8e9d1b331d2e8111daf6e5d61dda0bef7\nF test/exec.test e949714dc127eaa5ecc7d723efec1ec27118fdd7\nF test/exists.test 79a75323c78f02bbe9c251ea502a092f9ef63dac\nF test/expr.test 7cb55e80aeb41d65fec968c08212505123063fea60bdc355d764d747670e9eea\nF test/expr2.test c27327ae9c017a7ff6280123f67aff496f912da74d78c888926d68b46ec75fd8\nF test/extension01.test 00d13cec817f331a687a243e0e5a2d87b0e358c9\nF test/extraquick.test cb254400bd42bfb777ff675356aabf3287978f79\nF test/fallocate.test 37a62e396a68eeede8f8d2ecf23573a80faceb630788d314d0a073d862616717\nF test/filectrl.test 6e871c2d35dead1d9a88e176e8d2ca094fec6bb3\nF test/filefmt.test f393e80c4b8d493b7a7f8f3809a8425bbf4292af1f5140f01cb1427798a2bbd4\nF test/filter1.test fe7fcfeff48ca399fbc9577f55b60c8be8ccfdffc5e3b4ace21dc3c3e59f0f6a\nF test/filter2.tcl 44e525497ce07382915f01bd29ffd0fa49dab3adb87253b5e5103ba8f93393e8\nF test/filter2.test 485cf95d1f6d6ceee5632201ca52a71868599836f430cdee42e5f7f14666e30a\nF test/filterfault.test c08fb491d698e8df6c122c98f7db1c65ffcfcad2c1ab0e07fa8a5be1b34eaa8b\nF test/fkey1.test d11dbb8a93ead9b5c46ae5d02da016d61245d47662fb2d844c99214f6163f768\nF test/fkey2.test d35d1c81e7569bdd2b872e91750f7098117d2e8291369f70b7e3d50a0e523dc2\nF test/fkey3.test 76d475c80b84ee7a5d062e56ccb6ea68882e2b49\nF test/fkey4.test 86446017011273aad8f9a99c1a65019e7bd9ca9d\nF test/fkey5.test 24dd28eb3d9f1b5a174f47e9899ace5facb08373a4223593c8c631e6cf9f7d5a\nF test/fkey6.test d078a1e323a740062bed38df32b8a736fd320dc0\nF test/fkey7.test 64fb28da03da5dfe3cdef5967aa7e832c2507bf7fb8f0780cacbca1f2338d031\nF test/fkey8.test 48ef829d63f5f7b37aabd4df9363ac05f65539d1da8c4a44251631769d920579\nF test/fkey_malloc.test 594a7ea1fbab553c036c70813cd8bd9407d63749\nF test/fordelete.test eb93a2f34137bb87bdab88fcab06c0bd92719aff\nF test/format4.test eeae341953db8b6bda7f549044797c3278a6cc345d11ada81471671b654f8ef4\nF test/fts-9fd058691.test 78b887e30ae6816df0e1fed6259de4b5a64ad33c\nF test/fts1a.test 46090311f85da51bb33bd5ce84f7948359c6d8d7\nF test/fts1b.test 5d8a01aefbecc8b7442b36c94c05eb7a845462d5\nF test/fts1c.test 85a525ce7428907469b4cce13d5563ce542ce64c\nF test/fts1d.test a73deace5c18df4a549b12908bade4f05dcf1a2f\nF test/fts1e.test 77244843e925560b5a0b70069c3e7ab62f181ed2\nF test/fts1f.test 2d6cb10d8b7a4e6edc321bbdb3982f1f48774714\nF test/fts1i.test 6bfe08cdfdced063a39a50c8601da65e6274d879\nF test/fts1j.test e3797475796043a161e348c46a309664cac83f7f\nF test/fts1k.test 65d3b41487b9f738d11b0f00eca375c0ca6bd970\nF test/fts1l.test 15c119ed2362b2b28d5300c0540a6a43eab66c36\nF test/fts1m.test 2d9ca67b095d49f037a914087cc0a61e89da4f0c\nF test/fts1n.test a2317dcd27b1d087ee3878b30e0a59c593c98b7a\nF test/fts1o.test d1554caede42bba2c82fe613bcc921856c196b752449ead0470fac52a20fd3b8\nF test/fts1porter.test d86e9c3e0c7f8ff95add6582b4b585fb4e02b96d\nF test/fts2.test e3fb95f96a650411574efc136f3fb10eef479ed7\nF test/fts2a.test 473a5c8b473a4e21a8e3fddaed1e59666e0c6ab7\nF test/fts2b.test 964abc0236c849c07ca1ae496bb25c268ae94816\nF test/fts2c.test ffb5a35230ac72c4354535c547965ce6824537c0\nF test/fts2d.test b7eaa671ca9a16997f3e5b158ee777ae21052b0b\nF test/fts2e.test 2da13dbc2d009105f42196845c1e1ce136c03d38\nF test/fts2f.test cf84096235991709c1e61caa389632aa0a4f976d\nF test/fts2g.test 3d26fe171bda6133ebf5a380731d70eaa2ef2f6f73d79769cf8946e622b6d597\nF test/fts2h.test 223af921323b409d4b5b18ff4e51619541b174bb\nF test/fts2i.test 1b22451d1f13f7c509baec620dc3a4a754885dd6\nF test/fts2j.test 298fa1670aa21cd445b282d139b70c72e7ade12b\nF test/fts2k.test c7ebf4a4937594aa07459e3e1bca1251c1be8659\nF test/fts2l.test 3333336621524cf7d60bb62d6ef6ab69647866ed\nF test/fts2m.test 4b30142ead6f3ed076e880a2a464064c5ad58c51\nF test/fts2n.test 12b9c5352128cebd1c6b8395e43788d4b09087c2\nF test/fts2o.test 4054ac7433eb5440f1b1d200cfa449342dc4aabd991759139813e17c73e5bf9a\nF test/fts2p.test 4b48c35c91e6a7dbf5ac8d1e5691823cc999aafb\nF test/fts2q.test b2fbbe038b7a31a52a6079b215e71226d8c6a682\nF test/fts2r.test b154c30b63061d8725e320fba1a39e2201cadd5e\nF test/fts2token.test d8070b241a15ff13592a9ae4a8b7c171af6f445a\nF test/fts3.test 672a040ea57036fb4b6fdc09027c18d7d24ab654\nF test/fts3_common.tcl dffad248f9ce090800e272017d2898005c28ee6314fc1dd5550643a02666907a\nF test/fts3aa.test 814d60a1ba30b4a71d8f9306a6564bc7b636dd6efacd2ad80306f9b23ef3ebee\nF test/fts3ab.test 7f6cf260ae80dda064023df8e8e503e9a412b91f\nF test/fts3ac.test 636ed7486043055d4f126a0e385f2d5a82ebbf63\nF test/fts3ad.test e40570cb6f74f059129ad48bcef3d7cbc20dda49\nF test/fts3ae.test ce32a13b34b0260928e4213b4481acf801533bda\nF test/fts3af.test d394978c534eabf22dd0837e718b913fd66b499c\nF test/fts3ag.test c003672a215124df7fc6000036d896f498b26b53\nF test/fts3ah.test dc9f66c32c296f1bc8bcc4535126bddfeca62894\nF test/fts3ai.test 24058fdc6e9e5102c1fd8459591b114b6a85d285\nF test/fts3aj.test 0ed71e1dd9b03b843a857dc3eb9b15630e0104fc\nF test/fts3ak.test bd14deafe9d1586e8e9bf032411026ac4f8c925d\nF test/fts3al.test 07d64326e79bbdbab20ee87fc3328fbf01641c9f\nF test/fts3am.test 218aa6ba0dfc50c7c16b2022aac5c6be593d08d8\nF test/fts3an.test a49ccadc07a2f7d646ec1b81bc09da2d85a85b18\nF test/fts3ao.test 266989148fec6d9f1bb6c5382f7aa3dcea0e9cd444576e28dd2b9287ac7dd220\nF test/fts3atoken.test bef8a163490098a6b8a6ec5f5407269a3a15b9902c0fcf5e962825a81675b3a0\nF test/fts3auto.test bfe0857bd0b69d68dd685a931b58486411a69f5794a7f6d6fe808bfa31a99614\nF test/fts3aux1.test 7a170e172afdbceb67f5baa05941fd4fbf56af42f61daa3d140f4b4bf4cb68f6\nF test/fts3aux2.test 2459e7fa3e22734aed237d1e2ae192f5541c4d8b218956ad2d90754977bf907f\nF test/fts3b.test c15c4a9d04e210d0be67e54ce6a87b927168fbf9c1e3faec8c1a732c366fd491\nF test/fts3c.test fc723a9cf10b397fdfc2b32e73c53c8b1ec02958\nF test/fts3comp1.test a0f5b16a2df44dd0b15751787130af2183167c0c\nF test/fts3conf.test c84bbaec81281c1788aa545ac6e78a6bd6cde2bdbbce2da261690e3659f5a76b\nF test/fts3corrupt.test ce7f7b5eaeee5f1804584d061b978d85e64abf2af9adaa7577589fac6f7eae01\nF test/fts3corrupt2.test bf55c3fa0b0dc8ea1c0fe5543623bd27714585da6a129038fd6999fe3b0d25f3\nF test/fts3corrupt3.test 0d5b69a0998b4adf868cc301fc78f3d0707745f1d984ce044c205cdb764b491f\nF test/fts3corrupt4.test bc90c0f6ee73df4c6bd20f1b32fefdfc00b44cc577d67ebca43b157fc3efd422\nF test/fts3corrupt5.test 0549f85ec4bd22e992f645f13c59b99d652f2f5e643dac75568bfd23a6db7ed5\nF test/fts3cov.test 7eacdbefd756cfa4dc2241974e3db2834e9b372ca215880e00032222f32194cf\nF test/fts3d.test 2bd8c97bcb9975f2334147173b4872505b6a41359a4f9068960a36afe07a679f\nF test/fts3defer.test f4c20e4c7153d20a98ee49ee5f3faef624fefc9a067f8d8d629db380c4d9f1de\nF test/fts3defer2.test 3da52ca2114e300e9971eee2f0cc1a2e5f27e6a9ee67957d49e63e41fdfcc0e7\nF test/fts3defer3.test dd53fc13223c6d8264a98244e9b19abd35ed71cd\nF test/fts3drop.test 1b906e293d6773812587b3dc458cb9e8f3f0c297\nF test/fts3e.test 1f6c6ac9cc8b772ca256e6b22aaeed50c9350851\nF test/fts3expr.test ebae205a7a89446c32583bcd492dcb817b9f6b31819bb4dde2583bb99c77e526\nF test/fts3expr2.test 18da930352e5693eaa163a3eacf96233b7290d1a\nF test/fts3expr3.test c4d4a7d6327418428c96e0a3a1137c251b8dfbf8\nF test/fts3expr4.test f5b2832549f01b1f7f73389fa21d4b875499bc95bf7c8b36271844888c6a0938\nF test/fts3expr5.test a5b9a053becbdb8e973fbf4d6d3abaabeb42d511d1848bd57931f3e0a1cf983e\nF test/fts3fault.test 798e45af84be7978ca33d5bdc94246eb44724db24174b5d8e9b1ac46c57fb08d\nF test/fts3fault2.test 6a17a11d8034b1c4eca9f3091649273d56c49ff049e2173df8060f94341e9da0\nF test/fts3first.test dbdedd20914c8d539aa3206c9b34a23775644641\nF test/fts3fuzz001.test e3c7b0ce9b04cc02281dcc96812a277f02df03cd7dc082055d87e11eb18aaf56\nF test/fts3join.test 949b4f5ae3ae9cc2423cb865d711e32476bdb205ab2be923fdf48246e4a44166\nF test/fts3malloc.test b0e4c133b8d61d4f6d112d8110f8320e9e453ef6\nF test/fts3matchinfo.test aa66cc50615578b30f6df9984819ae5b702511cf8a94251ec7c594096a703a4a\nF test/fts3misc.test c47d2c1ea1351c51c32c688545b02c8180a3f22156d1aedc206a8c09b9d95905\nF test/fts3near.test 7e3354d46f155a822b59c0e957fd2a70c1d7e905\nF test/fts3offsets.test b85fd382abdc78ebce721d8117bd552dfb75094c\nF test/fts3prefix.test fa794eaab0bdae466494947b0b153d7844478ab2\nF test/fts3prefix2.test e1f0a822ca661dced7f12ce392e14eaf65609dce\nF test/fts3query.test ca033ff2ebcc22c69d89032fb0bc1850997d31e7e60ecd26440796ba1654e78f\nF test/fts3rank.test cd99bc83a3c923c8d52afd90d86979cf05fc41849f892faeac3988055ef37b99\nF test/fts3rnd.test 1320d8826a845e38a96e769562bf83d7a92a15d0\nF test/fts3shared.test 57e26a801f21027b7530da77db54286a6fe4997e\nF test/fts3snippet.test 430bb5ace2b31ccd99de4d71775d956da832c114c4b3e39589748f114458647c\nF test/fts3sort.test ed34c716a11cc2009a35210e84ad5f9c102362ca\nF test/fts3tok1.test a663f4cac22a9505400bc22aacb818d7055240409c28729669ea7d4cc2120d15\nF test/fts3tok_err.test 52273cd193b9036282f7bacb43da78c6be87418d\nF test/fts3varint.test 0b84a3fd4eba8a39f3687523804d18f3b322e6d4539a55bf342079c3614f2ada\nF test/fts4aa.test 4338ea7a67f7e19269bf6e6fb4a291352aa32296e7daed87f9823d57016a1ef7\nF test/fts4check.test 6259f856604445d7b684c9b306b2efb6346834c3f50e8fc4a59a2ca6d5319ad0\nF test/fts4content.test 73bbb123420d2c46ef2fb3b24761e9acdb78b0877179d3a5d7d57aada08066f6\nF test/fts4docid.test e33c383cfbdff0284685604d256f347a18fdbf01\nF test/fts4growth.test 289833c34ad45a5e6e6133b53b6a71647231fb89d36ddcb8d9c87211b6721d7f\nF test/fts4growth2.test 13ad4e76451af6e6906c95cdc725d01b00044269\nF test/fts4incr.test 4e353a0bd886ea984e56fce9e77724fc923b8d0d\nF test/fts4langid.test 2168ba330af34f8a1c8832de0aab4c4b6fa195a16419c9c0c8aad59ceb6ff714\nF test/fts4lastrowid.test 185835895948d5325c7710649824042373b2203149abe8024a9319d25234dfd7\nF test/fts4merge.test e2b2ec21e287d54ec09824ccfb41e66896eeca568fc818ba0e0eb2efd94c35d2\nF test/fts4merge2.test 5faa558d1b672f82b847d2a337465fa745e46891\nF test/fts4merge3.test 8d9ccb4a3d41c4c617a149d6c4b13ad02de797d0\nF test/fts4merge4.test d895b1057a7798b67e03455d0fa50e9ea836c47b\nF test/fts4merge5.test 69932d85cda8a1c4dcfb742865900ed8fbda51724b8cf9a45bbe226dfd06c596\nF test/fts4noti.test 5553d7bb2e20bf4a06b23e849352efc022ce6309\nF test/fts4onepass.test d69ddc4ee3415e40b0c5d1d0408488a87614d4f63ba9c44f3e52db541d6b7cc7\nF test/fts4opt.test 0fd0cc84000743ff2a883b9b84b4a5be07249f0ba790c8848a757164cdd46b2a\nF test/fts4record.test a48508f69a84c9287c8019d3a1ae712f5730d8335ffaf8e2101e691d078950bb\nF test/fts4rename.test 15fd9985c2bce6dea20da2245b22029ec89bd4710ed317c4c53abbe3cfd0c880\nF test/fts4umlaut.test fcaca4471de7e78c9d1f7e8976e3e8704d7d8ad979d57a739d00f3f757380429\nF test/fts4unicode.test ceca76422abc251818cb25dabe33d3c3970da5f7c90e1540f190824e6b3a7c95\nF test/full.test 6b3c8fb43c6beab6b95438c1675374b95fab245d\nF test/func.test 7d425f9a6eaa2c50baa751bef6b0c6c6af1751e0e0e1eb4863d426bb4c886788\nF test/func2.test 772d66227e4e6684b86053302e2d74a2500e1e0f\nF test/func3.test 2bb0f31ab7baaed690b962a88544d7be6b34fa389364bc36a44e441ed3e3f1e6\nF test/func4.test 6beacdfcb0e18c358e6c2dcacf1b65d1fa80955f\nF test/func5.test cdd224400bc3e48d891827cc913a57051a426fa4\nF test/func6.test 90e42b64c4f9fb6f04f44cb8a1da586c8542502e926b19c76504fe74ff2a9b7c\nF test/fuzz-oss1.test e58330d01cbbd8215ee636b17a03fe220b37dbfa\nF test/fuzz.test 96083052bf5765e4518c1ba686ce2bab785670d1\nF test/fuzz2.test 76dc35b32b6d6f965259508508abce75a6c4d7e1\nF test/fuzz3.test 9c813e6613b837cb7a277b0383cd66bfa07042b4cf0317157c35852f30043c31\nF test/fuzz4.test c229bcdb45518a89e1d208a21343e061503460ac69fae1539320a89f572eb634\nF test/fuzz_common.tcl a87dfbb88c2a6b08a38e9a070dabd129e617b45b\nF test/fuzz_malloc.test f348276e732e814802e39f042b1f6da6362a610af73a528d8f76898fde6b22f2\nF test/fuzzcheck.c e8cf694f71a1ee39a59f7c2a38c0f8660db0656ce47c8a334b6e9a11f1e66c6d\nF test/fuzzdata1.db d36e88741b4f23bcbaaf55b006290669d03c6c891cf13c7b3a53bc1b097b693f\nF test/fuzzdata2.db 128b3feeb78918d075c9b14b48610145a0dd4c8d6f1ca7c2870c7e425f5bf31f\nF test/fuzzdata3.db c6586d3e3cef0fbc18108f9bb649aa77bfc38aba\nF test/fuzzdata4.db b502c7d5498261715812dd8b3c2005bad08b3a26e6489414bd13926cd3e42ed2\nF test/fuzzdata5.db e35f64af17ec48926481cfaf3b3855e436bd40d1cfe2d59a9474cb4b748a52a5\nF test/fuzzdata6.db 92a80e4afc172c24f662a10a612d188fb272de4a9bd19e017927c95f737de6d7\nF test/fuzzdata7.db e7a86fd83dda151d160445d542e32e5c6019c541b3a74c2a525b6ac640639711\nF test/fuzzdata8.db b45368bbe9f86d40d30603e8f780ac29807cbcc951a18d7a7fd9d0c0e904706e\nF test/fuzzer1.test 3d4c4b7e547aba5e5511a2991e3e3d07166cfbb8\nF test/fuzzer2.test a85ef814ce071293bce1ad8dffa217cbbaad4c14\nF test/fuzzerfault.test 8792cd77fd5bce765b05d0c8e01b9edcf8af8536\nF test/gcfault.test dd28c228a38976d6336a3fc42d7e5f1ad060cb8c\nF test/gencol1.test 037c5c26dddd984ba7ea11bd16996377f72523a4126804b1bbecafc833fccb47\nF test/genesis.tcl 1e2e2e8e5cc4058549a154ff1892fe5c9de19f98\nF test/having.test e4098a4b8962f9596035c3b87a8928a10648acc509f1bb8d6f96413bbf79a1b3\nF test/hexlit.test 4a6a5f46e3c65c4bf1fa06f5dd5a9507a5627751\nF test/hidden.test 23c1393a79e846d68fd902d72c85d5e5dcf98711\nF test/hook.test 1604b3b2f5931430087540404555c1b6be3618600b81558657c66b533ed70b13\nF test/hook2.test b9ff3b8c6519fb67f33192f1afe86e7782ee4ac8\nF test/icu.test 41aa8847745a879b897a7febea0f8f9efc8e67fe8bf680589b6e07c7b0a1569a\nF test/ieee754.test 806fc0ce7f305f57e3331eaceeddcfec9339e607\nF test/imposter1.test c3f1db2d3db2c24611a6596a3fc0ffc14f1466c8\nF test/in.test 3e9bd58597a444123a40a9ac94cae0fec8897e17e9f519b02fc370bcf5ba5175\nF test/in2.test 5d4c61d17493c832f7d2d32bef785119e87bde75\nF test/in3.test 3cbf58c87f4052cee3a58b37b6389777505aa0c0\nF test/in4.test 0f77b0ff371549e6a119d0356be10bdba72258162e9701e83527a560482f5e98\nF test/in5.test b32ce7f4a93f44c5dee94af16886d922cc16ebe33c8e1765c73d4049d0f4b40f\nF test/in6.test 62d943a02f722948f4410ee0b53c3cb39acd7c41afb083df8d7004238fe90a20\nF test/incrblob.test c9b96afc292aeff43d6687bcb09b0280aa599822\nF test/incrblob2.test a494c9e848560039a23974b9119cfc2cf3ad3bd15cc2694ee6367ae537ef8f1f\nF test/incrblob3.test d8d036fde015d4a159cd3cbae9d29003b37227a4\nF test/incrblob4.test 21a52a6843a56cdcce968c6a86b72a7066d0e6ba\nF test/incrblob_err.test 89372a28f1d98254f03fed705f9efcd34ef61a674df16d2dbb4726944a2de5e9\nF test/incrblobfault.test 74dd8ac108304cea0b4a0df6df63a1567e558758\nF test/incrcorrupt.test 6c567fbf870aa9e91866fe52ce6f200cd548939a\nF test/incrvacuum.test 2aaee202b1f230e55779f70d155f6ba67bbdff8481d650214d256ab0f97d4a2b\nF test/incrvacuum2.test 7d26cfda66c7e55898d196de54ac4ec7d86a4e3d\nF test/incrvacuum3.test 75256fb1377e7c39ef2de62bfc42bbff67be295a\nF test/incrvacuum_ioerr.test 6ae2f783424e47a0033304808fe27789cf93e635\nF test/index.test a2e948ed949e575487b5c1d521767d4584ac42d352f2dcd8e48004638e7bc7dc\nF test/index2.test f835d5e13ca163bd78c4459ca15fd2e4ed487407\nF test/index3.test 51685f39345462b84fcf77eb8537af847fdf438cc96b05c45d6aaca4e473ade0\nF test/index4.test ab92e736d5946840236cd61ac3191f91a7856bf6\nF test/index5.test 8621491915800ec274609e42e02a97d67e9b13e7\nF test/index6.test f172653b35b20233e59200e8b92a76db61bf7285437bf777b93b306ba26a47e7\nF test/index7.test 1d764c0cca45f5a76150b08e127ccc8d52492cfa788b5fafed4be784a351b020\nF test/index8.test bc2e3db70e8e62459aaa1bd7e4a9b39664f8f9d7\nF test/index9.test 0aa3e509dddf81f93380396e40e9bb386904c1054924ba8fa9bcdfe85a8e7721\nF test/indexedby.test a52c8c6abfae4fbfb51d99440de4ca1840dbacc606b05e29328a2a8ba7cd914e\nF test/indexexpr1.test 284e119999d132cc8bf37735a928c9859b28e8e295d02b7a6a4f93977c7f9ba5\nF test/indexexpr2.test dba11dbb0a58fcba4cd694f46b4004976123b81b0501f525d43c9be59f0207b1\nF test/indexfault.test 98d78a8ff1f5335628b62f886a1cb7c7dac1ef6d48fa39c51ec871c87dce9811\nF test/init.test 15c823093fdabbf7b531fe22cf037134d09587a7\nF test/insert.test 4e3f0de67aac3c5be1f4aaedbcea11638f1b5cdc9a3115be14d19aa9db7623c6\nF test/insert2.test 4d14b8f1b810a41995f6286b64a6943215d52208\nF test/insert3.test 1b7db95a03ad9c5013fdf7d6722b6cd66ee55e30\nF test/insert4.test fb9e0f752c75f453555990250b449f6d123ae6a3ebf054d14e4470de4498dce3\nF test/insert5.test 394f96728d1258f406fe5f5aeb0aaf29487c39a6\nF test/insertfault.test ac63d14ea3b49c573673a572f4014b9117383a03e497c58f308b5c776e4a7f74\nF test/instr.test 107df2b9b74a4b59315916b575590a08f2a714de0754abe541f10a0971d0a2a4\nF test/instrfault.test 0f870b218ea17cd477bb19ed330eecdb460dd53a\nF test/intarray.test bb976b0b3df0ebb6a2eddfb61768280440e672beba5460ed49679ea984ccf440\nF test/interrupt.test 16ea879ec728cb76414c148c5f24afd5d1f91054\nF test/interrupt2.test e4408ca770a6feafbadb0801e54a0dcd1a8d108d\nF test/intpkey.test ac71107a49a06492b69b82aafaf225400598d3c8\nF test/intreal.test 2a87e85a5949bd55e41ef04c58f5800587c5380bdbc559ff1c79b614b0e6a533\nF test/io.test f95bca1783b01ea7761671560d023360d2dfa4cc\nF test/ioerr.test 470fcc78e9cd352d162baf782fe301ea807d764241f58a48fc58109c2dfcdb6b\nF test/ioerr2.test 2593563599e2cc6b6b4fcf5878b177bdd5d8df26\nF test/ioerr3.test d3cec5e1a11ad6d27527d0d38573fbff14c71bdd\nF test/ioerr4.test f130fe9e71008577b342b8874d52984bd04ede2c\nF test/ioerr5.test 2edfa4fb0f896f733071303b42224df8bedd9da4\nF test/ioerr6.test a395a6ab144b26a9e3e21059a1ab6a7149cca65b\nF test/istrue.test 75327829744e65cc8700e69340b8e6c192e10e39dfae7ccb0e970d3c4f49090a\nF test/join.test f787ee2716efe5beeb9888d10630f917b112c32b6b3e612e48a17ea8aed3a8eb\nF test/join2.test 10f7047e723ebd68b2f47189be8eed20451a6f665d8bf46f1774c640d1062417\nF test/join3.test 6f0c774ff1ba0489e6c88a3e77b9d3528fb4fda0\nF test/join4.test 1a352e4e267114444c29266ce79e941af5885916\nF test/join5.test 3a96dc62f0b45402d7207e22d1993fe0c2fce1c57644a11439891dd62b990eb7\nF test/join6.test cfe6503791ceb0cbb509966740286ec423cbf10b\nF test/journal1.test c7b768041b7f494471531e17abc2f4f5ebf9e5096984f43ed17c4eb80ba34497\nF test/journal2.test 9dac6b4ba0ca79c3b21446bbae993a462c2397c4\nF test/journal3.test 7c3cf23ffc77db06601c1fcfc9743de8441cb77db9d1aa931863d94f5ffa140e\nF test/jrnlmode.test 9b5bc01dac22223cb60ec2d5f97acf568d73820794386de5634dcadbea9e1946\nF test/jrnlmode2.test 8759a1d4657c064637f8b079592651530db738419e1d649c6df7048cd724363d\nF test/jrnlmode3.test 556b447a05be0e0963f4311e95ab1632b11c9eaa\nF test/json101.test bb71538005f2d9e18620bdd3b76839a93ca0be61903eb8d751a64e78cf99b8fb\nF test/json102.test eeb54efa221e50b74a2d6fb9259963b48d7414dca3ce2fdfdeed45cb28487bc1\nF test/json103.test aff6b7a4c17d5a20b487a7bc1a274bfdc63b829413bdfb83bedac42ec7f67e3b\nF test/json104.test 317f4ec4b2d87afbba4d2460cf5be297aea76f2285eb618d276dbcd40a50950f\nF test/json105.test 45f7d6a9a54c85f8a9589b68d3e7a1f42d02f2359911a8cdbad1f9988f571173\nF test/keyword1.test 37ef6bba5d2ed5b07ecdd6810571de2956599dff\nF test/kvtest.c 94da54bb66aae7a54e47cf7e4ea4acecc0f217560f79ad3abfcc0361d6d557ba\nF test/lastinsert.test 42e948fd6442f07d60acbd15d33fb86473e0ef63\nF test/laststmtchanges.test ae613f53819206b3222771828d024154d51db200\nF test/lemon-test01.y 58b764610fd934e189ffbb0bbfa33d171b9cb06019b55bdc04d090d6767e11d7\nF test/like.test 3d702d79bf871fa32985b1ce334294c587e3948d3ab972001e811a58577e8b3c\nF test/like2.test 3b2ee13149ba4a8a60b59756f4e5d345573852da\nF test/like3.test 4f940ad275c006319950054a7a65661f476772171b82b6fdf795e4dda36f246f\nF test/limit.test 0c99a27a87b14c646a9d583c7c89fd06c352663e\nF test/limit2.test 9409b033284642a859fafc95f29a5a6a557bd57c1f0d7c3f554bd64ed69df77e\nF test/loadext.test faa4f6eed07a5aac35d57fdd7bc07f8fc82464cfd327567c10cf0ba3c86cde04\nF test/loadext2.test 0408380b57adca04004247179837a18e866a74f7\nF test/lock.test be4fe08118fb988fed741f429b7dd5d65e1c90db\nF test/lock2.test 5242d8ac4e2d59c403aebff606af449b455aceff\nF test/lock3.test f271375930711ae044080f4fe6d6eda930870d00\nF test/lock4.test 27143363eda1622f03c133efc8db808fc331afd973486cb571ea71cd717d37b8\nF test/lock5.test c6c5e0ebcb21c61a572870cc86c0cb9f14cede38\nF test/lock6.test ad5b387a3a8096afd3c68a55b9535056431b0cf5\nF test/lock7.test 49f1eaff1cdc491cc5dee3669f3c671d9f172431\nF test/lock_common.tcl 2f3f7f2e9637f93ccf609df48ef5b27a50278b6b1cd752b445d52262e5841413\nF test/lookaside.test 5a828e7256f1ee4da8e1bdaa03373a3ccdb0f1ff98dfa82e9b76cb41a45b1083\nF test/main.test 6bbb3999fd461eb8fb335cbab97409a3d7f91bbb8da60635e8be3e4a04a77772\nF test/make-where7.tcl 05c16b5d4f5d6512881dfec560cb793915932ef9\nF test/malloc.test 18dd1c4188c81ca79cf123527c71b19ee0c31feb9947fdffb0dc6ceb1436816a\nF test/malloc3.test 6e88bae6312854a4adb4ecc2a6a5ea8c59b4db778b724ba718e1c43fc8c3c136\nF test/malloc4.test 957337613002b7058a85116493a262f679f3a261\nF test/malloc5.test 2e4ad7684a13389a44a840499cd47173a8d05f22f082d7d083eece433a7a64eb\nF test/malloc6.test 2f039d9821927eacae43e1831f815e157659a151\nF test/malloc7.test 7c68a32942858bc715284856c5507446bba88c3a\nF test/malloc8.test 9b7a3f8cb9cf0b12fff566e80a980b1767bd961d\nF test/malloc9.test 2307c6ee3703b0a21391f3ea92388b4b73f9105e\nF test/mallocA.test aea76f2dd8bcc2d19748f6b911e876cefda74a563753bf26af046e9d34bb97e6\nF test/mallocAll.test 98f1be74bc9f49a858bc4f361fc58e26486798be\nF test/mallocB.test bc475ab850cda896142ab935bbfbc74c24e51ed6\nF test/mallocC.test 3dffe16532f109293ce1ccecd0c31dca55ef08c4\nF test/mallocD.test f78c295e8e18ea3029e65ca08278690e00c22100\nF test/mallocE.test db1ed69d7eded1b080952e2a7c37f364ad241b08\nF test/mallocF.test 2d5c590ebc2fc7f0dcebdf5aa8498b9aed69107e\nF test/mallocG.test 0ff91b65c50bdaba680fb75d87fe4ad35bb7934f\nF test/mallocH.test 79b65aed612c9b3ed2dcdaa727c85895fd1bfbdb\nF test/mallocI.test 6c23a71df077fa5d387be90e7e669c5b368ca38a\nF test/mallocJ.test b5d1839da331d96223e5f458856f8ffe1366f62e\nF test/mallocK.test 1f4b5efbf61715ab79b20b38739ff4b3d110ceb53f54e5db6da1f01c083707ab\nF test/mallocL.test fb311ff80afddf3b1a75e52289081f4754d901dc\nF test/mallocM.test 78bbe9d3da84a5c679123cdb40d7b2010b18fc46e13897e4f253c6ba6fbff134\nF test/malloc_common.tcl aac62499b76be719fac31e7a3e54a7fd53272e7f\nF test/malloctraceviewer.tcl b7a54595270c1d201abf1c3f3d461f27eaf24cdef623ad08a0fe5e411264c8a9\nF test/manydb.test 28385ae2087967aa05c38624cec7d96ec74feb3e\nF test/mem5.test c6460fba403c5703141348cd90de1c294188c68f\nF test/memdb.test c1f2a343ad14398d5d6debda6ea33e80d0dafcc7\nF test/memdb1.test 58d92c2bf622cc5f0f41461e1b35cf64f3f787199544c2c1dada37d88753f9d4\nF test/memleak.test 10b9c6c57e19fc68c32941495e9ba1c50123f6e2\nF test/memsubsys1.test 9e7555a22173b8f1c96c281ce289b338fcba2abe8b157f8798ca195bbf1d347e\nF test/memsubsys2.test 3e4a8d0c05fd3e5fa92017c64666730a520c7e08\nF test/minmax.test 6751e87b409fe11b02e70a306d846fa544e25a41\nF test/minmax2.test 1edf66901ddfab26ae1e04165e8da834c8d3284e2b20aefb26b80ef217962eab\nF test/minmax3.test cc1e8b010136db0d01a6f2a29ba5a9f321034354\nF test/minmax4.test 272ca395257f05937dc96441c9dde4bc9fbf116a8d4fa02baeb0d13d50e36c87\nF test/misc1.test 7ce84b25df9872e7d7878613a96815d2ba5bc974ac4e15a50118dde8f3917599\nF test/misc2.test 00d7de54eda90e237fc9a38b9e5ccc769ebf6d4d\nF test/misc3.test cf3dda47d5dda3e53fc5804a100d3c82be736c9d\nF test/misc4.test 10cd6addb2fa9093df4751a1b92b50440175dd5468a6ec84d0386e78f087db0e\nF test/misc5.test c4aeaa0fa28faa08f2485309c38db4719e6cd1364215d5687a5b96d340a3fa58\nF test/misc6.test 953cc693924d88e6117aeba16f46f0bf5abede91\nF test/misc7.test 4f21954012e4eb0a923c54a311f38c81bf6798ccdd7b51584db46d4007f63daa\nF test/misc8.test 8fb0f31d7a8aed484d759773ab8ad12ec746a477f4a67394a4af0e677494c3ca\nF test/misuse.test 9e7f78402005e833af71dcab32d048003869eca5abcaccc985d4f8dc1d86bcc7\nF test/mjournal.test 28a08d5cb5fb5b5702a46e19176e45e964e0800d1f894677169e79f34030e152\nF test/mmap1.test fb04e0c10492455007624ade884ca0c8852ff3e4e11d95408f9709ca2ef7f626\nF test/mmap2.test 9d6dd9ddb4ad2379f29cc78f38ce1e63ed418022\nF test/mmap3.test b3c297e78e6a8520aafcc1a8f140535594c9086e\nF test/mmap4.test 2e2b4e32555b58da15176e6fe750f17c9dcf7f93\nF test/mmapfault.test d4c9eff9cd8c2dc14bc43e71e042f175b0a26fe3\nF test/mmapwarm.test 2272005969cd17a910077bd5082f70bc1fefad9a875afec7fc9af483898ecaf3\nF test/multiplex.test dc0d67b66f84b484a83cb8bbdf3f0a7f49562ccd\nF test/multiplex2.test 580ca5817c7edbe4cc68fa150609c9473393003a\nF test/multiplex3.test d228f59eac91839a977eac19f21d053f03e4d101\nF test/multiplex4.test e8ae4c4bd70606a5727743241f13b5701990abe4\nF test/mutex1.test ea2cc74d97f077b9e74c84cbd024f14d79a8126f\nF test/mutex2.test bfeaeac2e73095b2ac32285d2756e3a65e681660\nF test/nan.test 437d40e6d0778b050d7750726c0cbd2c9936b81962926e8f8c48ca698f00f4d1\nF test/nockpt.test 8c43b25af63b0bd620cf1b003529e37b6f1dc53bd22690e96a1bd73f78dde53a\nF test/nolock.test f196cf8b8fbea4e2ca345140a2b3f3b0da45c76e\nF test/normalize.test f23b6c5926c59548635fcf39678ac613e726121e073dd902a3062fbb83903b72\nF test/notify1.test 669b2b743618efdc18ca4b02f45423d5d2304abf\nF test/notify2.test 2ecabaa1305083856b7c39cf32816b612740c161\nF test/notify3.test 10ff25cde502e72a92053a2f215d64bece4ef934\nF test/notnull.test a37b663d5bb728d66fc182016613fb8e4a0a4bbf3d75b8876a7527f7d4ed3f18\nF test/null.test 0dcce4f04284ec66108c503327ad6d224c0752b3\nF test/nulls1.test a325e2f2148fb5c82cd5f734e7b60f5fa28f9394c318edf3140f36f57d39930a\nF test/numcast.test 5d126f7f581432e86a90d1e35cac625164aec4a1\nF test/numindex1.test 20a5450d4b056e48cd5db30e659f13347a099823\nF test/offset1.test f06b83657bcf26f9ce805e67450e189e282143b2\nF test/openv2.test 0d3040974bf402e19b7df4b783e447289d7ab394\nF test/optfuzz-db01.c a0c256905c8ac79f9a5de2f374a3d9f757bef0dca2a238dc7c10cc8a38031834\nF test/optfuzz-db01.txt 21f6bdeadc701cf11528276e2a55c70bfcb846ba42df327f979bd9e7b6ce7041\nF test/optfuzz.c 50e330304eb1992e15ddd11f3daaad9bcc0d9aaad09cb2bcc77f9515df2e88b1\nF test/orderby1.test e4501f54721f804ca56922e253403ac6775f88e9f07569994ce99212b3ca5b10\nF test/orderby2.test bc11009f7cd99d96b1b11e57b199b00633eb5b04\nF test/orderby3.test 8619d06a3debdcd80a27c0fdea5c40b468854b99\nF test/orderby4.test 4d39bfbaaa3ae64d026ca2ff166353d2edca4ba4\nF test/orderby5.test 5f4d6cb93cc2f6d3f4228354310a2ce1fbd95d5bbffcba8c6482eeb62a466407\nF test/orderby6.test 8b38138ab0972588240b3fca0985d2e400432859\nF test/orderby7.test 3d1383d52ade5b9eb3a173b3147fdd296f0202da\nF test/orderby8.test 23ef1a5d72bd3adcc2f65561c654295d1b8047bd\nF test/orderby9.test 87fb9548debcc2cd141c5299002dd94672fa76a3\nF test/orderbyA.test df608e59efc2ef50c1eddf1a773b272de3252e9401bfec86d04b52fd973866d5\nF test/oserror.test 1fc9746b83d778e70d115049747ba19c7fba154afce7cc165b09feb6ca6abbc5\nF test/ossfuzz.c 9636dad2092a05a32110df0ca06713038dd0c43dd89a77dabe4b8b0d71096715\nF test/ossshell.c f125c5bd16e537a2549aa579b328dd1c59905e7ab1338dfc210e755bb7b69f17\nF test/ovfl.test 199c482696defceacee8c8e0e0ef36da62726b2f\nF test/pager1.test 1e9ee778bdeaf4f7f09997d029cdaca6a42dfc2092edafe4f5e590acbf1eab13\nF test/pager2.test 67b8f40ae98112bcdba1f2b2d03ea83266418c71\nF test/pager3.test 4e9a83d6ca0838d7c602c9eb93d1357562d9059c1e02ffb138a8271020838370\nF test/pager4.test a122e9e6925d5b23b31e3dfef8c6a44bbf19590e\nF test/pagerfault.test 63c5da625562c66345ab4528790327ca63db2f6f9cbae2aba8cb7c51de3d1628\nF test/pagerfault2.test caf4c7facb914fd3b03a17b31ae2b180c8d6ca1f\nF test/pagerfault3.test 1003fcda009bf48a8e22a516e193b6ef0dd1bbd8\nF test/pageropt.test 84e4cc5cbca285357f7906e99b21be4f2bf5abc0\nF test/pagesize.test 5769fc62d8c890a83a503f67d47508dfdc543305\nF test/parser1.test 6ccdf5e459a5dc4673d3273dc311a7e9742ca952dd0551a6a6320d27035ce4b3\nF test/pcache.test c8acbedd3b6fd0f9a7ca887a83b11d24a007972b\nF test/pcache2.test af7f3deb1a819f77a6d0d81534e97d1cf62cd442\nF test/percentile.test 4243af26b8f3f4555abe166f723715a1f74c77ff\nF test/permutations.test 8587800fe1a0eb01456a3f4500b821e54e3347e78acf11dbf05f4990530f6cee\nF test/pg_common.tcl 222a1bad1c41c308fa366313cd7b51b3be7e9b21c8736a421b974ac941693b54\nF test/pragma.test 59becdfd720b80d463ab750f69f7118fde10dfd556aa5d554f3bf6b7e5ea7533\nF test/pragma2.test e5d5c176360c321344249354c0c16aec46214c9f\nF test/pragma3.test 8300aa9c63cff1027006ca34bf413a148abbd6dcd471fa9a1ded322fe18c0df9\nF test/pragma4.test 10c624e45a83c0096a82a7579a5ff658542391d3b77355192da6572c8c17c00b\nF test/pragma5.test 2be6a44c91e8585ccb4c71c5f221ccebe0692a49557215a912916ed391188959\nF test/pragmafault.test 275edaf3161771d37de60e5c2b412627ac94cef11739236bec12ed1258b240f8\nF test/prefixes.test b524a1c44bffec225b9aec98bd728480352aa8532ac4c15771fb85e8beef65d9\nF test/printf.test 0300699733e53101b2ce48800518427249edd4053bb50fa0621c6607482f0fdb\nF test/printf2.test 30b5dd0b4b992dc5626496846ecce17ff592cacbcb11c3e589f3ac4d7e129dae\nF test/progress.test ebab27f670bd0d4eb9d20d49cef96e68141d92fb\nF test/ptrchng.test ef1aa72d6cf35a2bbd0869a649b744e9d84977fc\nF test/pushdown.test 5e72c51c5e33253ed639ccee1e01ce62d62b6eee5ca893cd82334e4ee7b1d7fc\nF test/queryonly.test 5f653159e0f552f0552d43259890c1089391dcca\nF test/quick.test 1681febc928d686362d50057c642f77a02c62e57\nF test/quota-glob.test 32901e9eed6705d68ca3faee2a06b73b57cb3c26\nF test/quota.test bfb269ce81ea52f593f9648316cd5013d766dd2a\nF test/quota2.test 7dc12e08b11cbc4c16c9ba2aa2e040ea8d8ab4b8\nF test/quote.test 626149eda89ee64d81a3790de370f9f0211921b11568a49c28c861f394330508\nF test/randexpr1.tcl 40dec52119ed3a2b8b2a773bce24b63a3a746459\nF test/randexpr1.test eda062a97e60f9c38ae8d806b03b0ddf23d796df\nF test/rbu.test 168573d353cd0fd10196b87b0caa322c144ef736\nF test/rdonly.test 64e2696c322e3538df0b1ed624e21f9a23ed9ff8\nF test/recover.test ccb8c2623902a92ebb76770edd075cb4f75a4760bb7afde38026572c6e79070d\nF test/regexp1.test 497ea812f264d12b6198d6e50a76be4a1973a9d8\nF test/regexp2.test 40e894223b3d6672655481493f1be12012f2b33c\nF test/reindex.test cd9d6021729910ece82267b4f5e1b5ac2911a7566c43b43c176a6a4732e2118d\nF test/releasetest.tcl fb76d8fcc95ac29d6356cd9e52b726ab9e43a24082897618dfbcb7c2b0049153 x\nF test/releasetest_data.tcl 9919fc6ac5bc92f8878fecfd1840db15999f660a6c9f609240b41aa62b885c88\nF test/resetdb.test 8062cf10a09d8c048f8de7711e94571c38b38168db0e5877ba7561789e5eeb2b\nF test/resolver01.test f4022acafda7f4d40eca94dbf16bc5fc4ac30ceb\nF test/rollback.test 06680159bc6746d0f26276e339e3ae2f951c64812468308838e0a3362d911eaa\nF test/rollback2.test bc868d57899dc6972e2b4483faae0e03365a0556941474eec487ae21d8d38bb6\nF test/rollbackfault.test 0e646aeab8840c399cfbfa43daab46fd609cf04a\nF test/round1.test 768018b04522ca420b1aba8a24bd76091d269f3bce3902af3ec6ebcee41ab21e\nF test/rowallock.test 3f88ec6819489d0b2341c7a7528ae17c053ab7cc\nF test/rowhash.test 0bc1d31415e4575d10cacf31e1a66b5cc0f8be81\nF test/rowid.test bfbd7b97d9267660be3c8f28507c4ed7f205196b8877c0db42df347c2e8845e3\nF test/rowvalue.test c39cc0be5e33f5294fc9224216198d6709d713ea948fdf8f42d89568e97912c9\nF test/rowvalue2.test 060d238b7e5639a7c5630cb5e63e311b44efef2b\nF test/rowvalue3.test 3068f508753af69884b12125995f023da0dbb256\nF test/rowvalue4.test 02e35f7762371c2f57ebd856aa056eac56cb27ef7715a0bb31eac1895a745356\nF test/rowvalue5.test c81c7d8cf36711ab37675ad7376084ae2a359cb6\nF test/rowvalue6.test d19b54feb604d5601f8614b15e214e0774c01087\nF test/rowvalue7.test c1cbdbf407029db01f87764097c6ac02a1c5a37efd2776eff32a9cdfdf6f2dba\nF test/rowvalue8.test 5900eddad9e2c3c2e26f1a95f74aafc1232ee5e0\nF test/rowvalue9.test d8dd2c6ecac432dadaa79e41dc2434f007be1b6b\nF test/rowvaluefault.test 7cd9ccc6c2fbdd881672984087aad0491bb75504\nF test/rowvaluevtab.test d166df5b666662de1ebf40d6f3849f8a76b34e17183a6cc7f81b420c462ce447\nF test/rtree.test 0c8d9dd458d6824e59683c19ab2ffa9ef946f798\nF test/run-wordcount.sh 891e89c4c2d16e629cd45951d4ed899ad12afc09\nF test/savepoint.test 1f8a6b1aea9a0d05837adc463d4bf47bd9d0f1c842f1c2a9caccd639baf34bf9\nF test/savepoint2.test 9b8543940572a2f01a18298c3135ad0c9f4f67d7\nF test/savepoint4.test c8f8159ade6d2acd9128be61e1230f1c1edc6cc0\nF test/savepoint5.test 0735db177e0ebbaedc39812c8d065075d563c4fd\nF test/savepoint6.test f41279c5e137139fa5c21485773332c7adb98cd7\nF test/savepoint7.test cde525ea3075283eb950cdcdefe23ead4f700daa\nF test/savepointfault.test f044eac64b59f09746c7020ee261734de82bf9b2\nF test/scanstatus.test 874e35011779b07725a47dbf1dd6282b0ca04af7e028fb0b534ee544b571be42\nF test/schema.test 5dd11c96ba64744de955315d2e4f8992e447533690153b93377dffb2a5ef5431\nF test/schema2.test 906408621ea881fdb496d878b1822572a34e32c5\nF test/schema3.test 1bc1008e1f8cb5654b248c55f27249366eb7ed38\nF test/schema4.test 3b26c9fa916abb6dadf894137adcf41b7796f7b9\nF test/schema5.test 29699b4421f183c8f0e88bd28ce7d75d13ea653e\nF test/schema6.test e4bd1f23d368695eb9e7b51ef6e02ca0642ea2ab4a52579959826b5e7dce1f9b\nF test/schemafault.test 1936bceca55ac82c5efbcc9fc91a1933e45c8d1e1d106b9a7e56c972a5a2a51e\nF test/securedel.test 2f70b2449186a1921bd01ec9da407fbfa98c3a7a5521854c300c194b2ff09384\nF test/securedel2.test 2d54c28e46eb1fd6902089958b20b1b056c6f1c5\nF test/select1.test 703154cbf66d0a9fbbd5b771dc3d2c4d3700121d133d695958d4a9c5a33251e8\nF test/select2.test 352480e0e9c66eda9c3044e412abdf5be0215b56\nF test/select3.test 3905450067c28766bc83ee397f6d87342de868baa60f2bcfd00f286dfbd62cb9\nF test/select4.test 5389d9895968d1196c457d59b3ee6515d771d328\nF test/select5.test df9ec0d218cedceb4fe7b63262025b547b50a55e59148c6f40b60ca25f1d4546\nF test/select6.test 319d45e414cdd321bf17cfacedaf19e3935ad64dac357c53f1492338c6e9b801\nF test/select7.test f659f231489349e8c5734e610803d7654207318f\nF test/select8.test 8c8f5ae43894c891efc5755ed905467d1d67ad5d\nF test/select9.test aebc2bb0c3bc44606125033cbcaac2c8d1f33a95\nF test/selectA.test b8a590f6493cad5b0bb4dfe1709bf7dcda0b6c40bb4caf32d1e36a89eebc8fc5\nF test/selectB.test 954e4e49cf1f896d61794e440669e03a27ceea25\nF test/selectC.test e25243f8ca503e06f252eb0218976d07cfeceac3\nF test/selectD.test fc20452847a01775710090383cfb4423275d2f745fed61f34fbf37573ac0d214\nF test/selectE.test a8730ca330fcf40ace158f134f4fe0eb00c7edbf\nF test/selectF.test 21c94e6438f76537b72532fa9fd4710cdd455fc3\nF test/selectG.test 089f7d3d7e6db91566f00b036cb353107a2cca6220eb1cb264085a836dae8840\nF test/server1.test c2b00864514a68a0e6fd518659dc95d0050307a357a08969872bef027d785dc4\nF test/session.test 78fa2365e93d3663a6e933f86e7afc395adf18be\nF test/sessionfuzz-data1.db 1f8d5def831f19b1c74571037f0d53a588ea49a6c4ca2a028fc0c27ef896dbcb\nF test/sessionfuzz.c be9c4d4afd359ce80024d8b541b9b8a880510aef5cf263df56fc0e9b947727f1\nF test/shared.test 1826673eb5eb745fb91a3bdac99a7737057742ae38dcb0fe076a384d6727578b\nF test/shared2.test 03eb4a8d372e290107d34b6ce1809919a698e879\nF test/shared3.test ab693f9b6e156b8bfb2a0ad94f29fe69602a5d38\nF test/shared4.test c75f476804e76e26bf6fa0e7b421fb0ca7d07558\nF test/shared6.test 866bb4982c45ce216c61ded5e8fde4e7e2f3ffa9\nF test/shared7.test a81e99f83e6c51b02ac99c96fb3a2a7b5978c956\nF test/shared8.test 933ed7d71f598bb6c7a8c192a3cd30f2562fdccf514df383798599c34ffa672f\nF test/shared9.test 5f2a8f79b4d6c7d107a01ffa1ed05ae7e6333e21\nF test/sharedA.test 49d87ec54ab640fbbc3786ee3c01de94aaa482a3a9f834ad3fe92770eb69e281\nF test/sharedB.test 16cc7178e20965d75278f410943109b77b2e645e\nF test/shared_err.test 32634e404a3317eeb94abc7a099c556a346fdb8fb3858dbe222a4cbb8926a939\nF test/sharedlock.test 5ede3c37439067c43b0198f580fd374ebf15d304\nF test/shell1.test 3c9707dce15e8fdca529503378660f099777d3ddcedccf801a37589a405c5942\nF test/shell2.test e242a9912f44f4c23c3d1d802a83e934e84c853b\nF test/shell3.test ac8c2b744014c3e9a0e26bfd829ab65f00923dc1a91ffd044863e9423cc91494\nF test/shell4.test 1c6aef11daaa2d6830acaba3ac9cbec93fbc1c3d5530743a637f39b3987d08ce\nF test/shell5.test 23939a4c51f0421330ea61dbd3c74f9c215f5f8d3d1a94846da6ffc777a35458\nF test/shell6.test 1ceb51b2678c472ba6cf1e5da96679ce8347889fe2c3bf93a0e0fa73f00b00d3\nF test/shell7.test 115132f66d0463417f408562cc2cf534f6bbc6d83a6d50f0072a9eb171bae97f\nF test/shell8.test 96be02ea0c21f05b24c1883d7b711a1fa8525a68ab7b636aacf6057876941013\nF test/shmlock.test 3dbf017d34ab0c60abe6a44e447d3552154bd0c87b41eaf5ceacd408dd13fda5\nF test/shortread1.test bb591ef20f0fd9ed26d0d12e80eee6d7ac8897a3\nF test/show_speedtest1_rtree.tcl 32e6c5f073d7426148a6936a0408f4b5b169aba5\nF test/shrink.test 1b4330b1fd9e818c04726d45cb28db73087535ce\nF test/sidedelete.test f0ad71abe6233e3b153100f3b8d679b19a488329\nF test/skipscan1.test 2a64ca7b3e6246bb86b47c9051bfd324603b1b60675fe606513535267713e080\nF test/skipscan2.test 3eb703ce794f139e7b83567911046298bcde29606116727f9b700ce34f559d2d\nF test/skipscan3.test ec5bab3f81c7038b43450e7b3062e04a198bdbb5\nF test/skipscan5.test 67817a4b6857c47e0e33ba3e506da6f23ef68de2\nF test/skipscan6.test 0b4cd1b4ac9f84d91454df513c99a4932fa07e8f27b8049bea605068b3e34ac7\nF test/snapshot.test a504f2e7009f512ef66c719f0ea1c55a556bdaf1e1312c80a04d46fc1a3e9632\nF test/snapshot2.test 8d6ff5dd9cc503f6e12d408a30409c3f9c653507b24408d9cd7195931c89bc54\nF test/snapshot3.test 8744313270c55f6e18574283553d3c5c5fe4c5970585663613a0e75c151e599b\nF test/snapshot4.test d4e9347ef2fcabc491fc893506c7bbaf334da3be111d6eb4f3a97cc623b78322\nF test/snapshot_fault.test f6c5ef7cb93bf92fbb4e864ecc5c87df7d3a250064838822db5b4d3a5563ede4\nF test/snapshot_up.test a0a29c4cf33475fcef07c3f8e64af795e24ab91b4cc68295863402a393cdd41c\nF test/soak.test 18944cf21b94a7fe0df02016a6ee1e9632bc4e8d095a0cb49d95e15d5cca2d5c\nF test/softheap1.test 843cd84db9891b2d01b9ab64cef3e9020f98d087\nF test/sort.test c2adc635c2564241fefec0b3a68391ef6868fd3b\nF test/sort2.test cc23b7c19d684657559e8a55b02f7fcee03851d0\nF test/sort3.test 1480ed7c4c157682542224e05e3b75faf4a149e5\nF test/sort4.test 5c34d9623a4ae5921d956dfa2b70e77ed0fc6e5c\nF test/sort5.test 6b43ae0e2169b5ceed441844492e55ba7f1ae0790528395ddf7888ab3094525d\nF test/sorterref.test a13ed207a0eea3c7898f308f979bfb518f68c598ec737d2c494dfd3deaa83506\nF test/sortfault.test d4ccf606a0c77498e2beb542764fd9394acb4d66\nF test/speed1.test f2974a91d79f58507ada01864c0e323093065452\nF test/speed1p.explain d841e650a04728b39e6740296b852dccdca9b2cb\nF test/speed1p.test b180e98609c7677382cf618c0ec9b69f789033a8\nF test/speed2.test 53177056baf6556dcbdcf032bbdfc41c1aa74ded\nF test/speed3.test 694affeb9100526007436334cf7d08f3d74b85ef\nF test/speed4.test abc0ad3399dcf9703abed2fff8705e4f8e416715\nF test/speed4p.explain 6b5f104ebeb34a038b2f714150f51d01143e59aa\nF test/speed4p.test 377a0c48e5a92e0b11c1c5ebb1bc9d83a7312c922bc0cb05970ef5d6a96d1f0c\nF test/speedtest1.c f3bfe3c6a87cbd88e4c4e38005d972bcc1019d1b2fe9569425f86629b11f6c31\nF test/spellfix.test 951a6405d49d1a23d6b78027d3877b4a33eeb8221dcab5704b499755bb4f552e\nF test/spellfix2.test dfc8f519a3fc204cb2dfa8b4f29821ae90f6f8c3\nF test/spellfix3.test 0f9efaaa502a0e0a09848028518a6fb096c8ad33\nF test/spellfix4.test 51c7c26514ade169855c66bcf130bd5acfb4d7fd090cc624645ab275ae6a41fb\nF test/sqldiff1.test 28cd737cf1b0078b1ec1bbf425e674c47785835e\nF test/sqllimits1.test 264f4b0f941800ba139d25e33ee919c5d95fea06dfbe8ac291d6811a30984ca5\nF test/sqllog.test 6af6cb0b09f4e44e1917e06ce85be7670302517a\nF test/stat.test 05669008edc5ed950e817c24e8c4b66840fda64d8c76bae27e5fc1bd23d95675\nF test/statfault.test f525a7bf633e50afd027700e9a486090684b1ac1\nF test/stmt.test 54ed2cc0764bf3e48a058331813c3dbd19fc1d0827c3d8369914a5d8f564ec75\nF test/stmtvtab1.test 6873dfb24f8e79cbb5b799b95c2e4349060eb7a3b811982749a84b359468e2d5\nF test/subjournal.test 8d4e2572c0ee9a15549f0d8e40863161295107e52f07a3e8012a2e1fdd093c49\nF test/subquery.test d7268d193dd33d5505df965399d3a594e76ae13f\nF test/subquery2.test 90cf944b9de8204569cf656028391e4af1ccc8c0cc02d4ef38ee3be8de1ffb12\nF test/subselect.test 0966aa8e720224dbd6a5e769a3ec2a723e332303\nF test/substr.test 18f57c4ca8a598805c4d64e304c418734d843c1a\nF test/subtype1.test 7fe09496352f97053af1437150751be2d0a0cae8\nF test/superlock.test ec94f0556b6488d97f71c79f9061ae08d9ab8f12\nF test/swarmvtab.test 9a3fd5ab3e9b3c976ad1b3d7646aab725114f2ac26b59395d0778b33bab6cdaf\nF test/swarmvtab2.test c948cb2fdfc5b01d85e8f6d6504854202dc1a0782ab2a0ed61538f27cbd0aa5c\nF test/swarmvtab3.test 247aa38b6ebd2b99db2075847ae47e789ac34f1c2ab5c720dfcffd990004c544\nF test/swarmvtabfault.test 8a67a9f27c61073a47990829e92bc0c64420a807cb642b15a25f6c788210ed95\nF test/symlink.test 72b22238d4405ba34df8e60b335d290a3b1129fd5c260835c944c1e4e77288a9\nF test/symlink2.test 9531f475a53d8781c4f81373f87faf2e2aff4f5fb2102ec6386e0c827916a670\nF test/sync.test 89539f4973c010eda5638407e71ca7fddbcd8e0594f4c9980229f804d4333092\nF test/sync2.test 8f9f7d4f6d5be8ca8941a8dadcc4299e558cb6a1ff653a9469146c7a76ef2039\nF test/syscall.test a39d9a36f852ae6e4800f861bc2f2e83f68bbc2112d9399931ecfadeabd2d69d\nF test/sysfault.test c9f2b0d8d677558f74de750c75e12a5454719d04\nF test/tabfunc01.test 5ca6d004157a3e886a55a9387b960cc0db41acd88753eb597ff409ec6cfb1be0\nF test/table.test eb3463b7add9f16a5bb836badf118cf391b809d09fdccd1f79684600d07ec132\nF test/tableapi.test ecbcc29c4ab62c1912c3717c48ea5c5e59f7d64e4a91034e6148bd2b82f177f4\nF test/tableopts.test dba698ba97251017b7c80d738c198d39ab747930\nF test/tclsqlite.test c4a5f5af3672fbe28a0aa322b88d9d1ce2225b6b1284ea11ede2e6d38e7c812c\nF test/tempdb.test 4cdaa23ddd8acb4d79cbb1b68ccdfd09b0537aaba909ca69a876157c2a2cbd08\nF test/tempdb2.test 353864e96fd3ae2f70773d0ffbf8b1fe48589b02c2ec05013b540879410c3440\nF test/tempfault.test 0c0d349c9a99bf5f374655742577f8712c647900\nF test/temptable.test d2c9b87a54147161bcd1822e30c1d1cd891e5b30\nF test/temptable2.test d2940417496e2b9548e01d09990763fbe88c316504033256d51493e1f1a5ce6a\nF test/temptable3.test d11a0974e52b347e45ee54ef1923c91ed91e4637\nF test/temptrigger.test 38f0ca479b1822d3117069e014daabcaacefffcc\nF test/tester.tcl abba168acd7f01dbfa3ffdbf402d151eb97e8a824d9208e845ab34c194441483\nF test/thread001.test b61a29dd87cf669f5f6ac96124a7c97d71b0c80d9012746072055877055cf9ef\nF test/thread002.test e630504f8a06c00bf8bbe68528774dd96aeb2e58\nF test/thread003.test ee4c9efc3b86a6a2767516a37bd64251272560a7\nF test/thread004.test f51dfc3936184aaf73ee85f315224baad272a87f\nF test/thread005.test 50d10b5684399676174bd96c94ad4250b1a2c8b6\nF test/thread1.test df115faa10a4ba1d456e9d4d9ec165016903eae4\nF test/thread2.test f35d2106452b77523b3a2b7d1dcde2e5ee8f9e46\nF test/thread_common.tcl 334639cadcb9f912bf82aa73f49efd5282e6cadd\nF test/threadtest1.c 6029d9c5567db28e6dc908a0c63099c3ba6c383b\nF test/threadtest2.c a70a8e94bef23339d34226eb9521015ef99f4df8\nF test/threadtest3.c 38a612ea62854349ed66372f330a40d73c5cf956\nF test/threadtest4.c c1e67136ceb6c7ec8184e56ac61db28f96bd2925\nF test/time-wordcount.sh 8e0b0f8109367827ad5d58f5cc849705731e4b90\nF test/tkt-02a8e81d44.test 6c80d9c7514e2a42d4918bf87bf6bc54f379110c\nF test/tkt-18458b1a.test 6a62cb1ee50fa3c620da59e3a6f531eb38fceaf7e2166203816b724524e6f1d6\nF test/tkt-26ff0c2d1e.test c15bec890c4d226c0da2f35ff30f9e84c169cfef90e73a8cb5cec11d723dfa96\nF test/tkt-2a5629202f.test 0521bd25658428baa26665aa53ffed9367d33af2\nF test/tkt-2d1a5c67d.test be1326f3061caec85085f4c9ee4490561ca037c0\nF test/tkt-2ea2425d34.test 1cf13e6f75d149b3209a0cb32927a82d3d79fb28\nF test/tkt-31338dca7e.test 6fb8807851964da0d24e942f2e19c7c705b9fb58\nF test/tkt-313723c356.test 4b306ad45c736cedf2f5221f6155b92143244b6d\nF test/tkt-385a5b56b9.test 5204a7cba0e28c99df0acbf95af5e1af4d32965a7a14de6eccebf949607618b1\nF test/tkt-38cb5df375.test f3cc8671f1eb604d4ae9cf886ed4366bec656678\nF test/tkt-3998683a16.test 6d1d04d551ed1704eb3396ca87bb9ccc8c5c1eb7\nF test/tkt-3a77c9714e.test 90e3e8455ee945a4076d4c44062b8845708af24a880355328fe7008f2047c9f0\nF test/tkt-3fe897352e.test 27e26eb0f1811aeba4d65aba43a4c52e99da5e70\nF test/tkt-4a03edc4c8.test 91c0e135888cdc3d4eea82406a44b05c8c1648d0\nF test/tkt-4c86b126f2.test cbcc611becd0396890169ab23102dd70048bbc9a\nF test/tkt-4dd95f6943.test 3d0ce415d2ee15d3d564121960016b9c7be79407\nF test/tkt-4ef7e3cfca.test 3965ae11cc9cf6e334f9d7d3c1e20bf8d56254b1\nF test/tkt-54844eea3f.test a12b851128f46a695e4e378cca67409b9b8f5894\nF test/tkt-5d863f876e.test 726e76d725f6fe0eb2fc8a522b721b79807380ee\nF test/tkt-5e10420e8d.test 904d1687b3c06d43e5b3555bbcf6802e7c0ffd84\nF test/tkt-5ee23731f.test 9db6e1d7209dc0794948b260d6f82b2b1de83a9f\nF test/tkt-6bfb98dfc0.test 24780633627b5cfc0635a5500c2389ebfb563336\nF test/tkt-752e1646fc.test ea78d88d14fe9866bdd991c634483334639e13bf\nF test/tkt-78e04e52ea.test cb44d0f5e7940223be740a39913a1b9b9b30d7e4a17ed3349141f893bae1b8f2\nF test/tkt-7a31705a7e6.test 9e9c057b6a9497c8f7ba7b16871029414ccf6550e7345d9085d6d71c9a56bb6f\nF test/tkt-7bbfb7d442.test 7b2cd79c7a17ae6750e75ec1a7846712a69c9d18\nF test/tkt-80ba201079.test 105a721e6aad0ae3c5946d7615d1e4d03f6145b8\nF test/tkt-80e031a00f.test 9ee36348b761bf7c14261e002b75a4c0d5a04d4c\nF test/tkt-8454a207b9.test c583a9f814a82a2b5ba95207f55001c9f0cd816c\nF test/tkt-868145d012.test a5f941107ece6a64410ca4755c6329b7eb57a356\nF test/tkt-8c63ff0ec.test 258b7fc8d7e4e1cb5362c7d65c143528b9c4cbed\nF test/tkt-91e2e8ba6f.test 08c4f94ae07696b05c9b822da0b4e5337a2f54c5\nF test/tkt-94c04eaadb.test f738c57c7f68ab8be1c054415af7774617cb6223\nF test/tkt-9a8b09f8e6.test b2ef151d0984b2ebf237760dbeaa50724e5a0667\nF test/tkt-9d68c883.test 16f7cb96781ba579bc2e19bb14b4ad609d9774b6\nF test/tkt-9f2eb3abac.test cb6123ac695a08b4454c3792fbe85108f67fabf8\nF test/tkt-a7b7803e.test 159ef554234fa1f9fb318c751b284bd1cf858da4\nF test/tkt-a7debbe0.test e295fa83cd4416a8ca37b354eb5fadefc5e81fb55253db538d35261fe9c95067\nF test/tkt-a8a0d2996a.test 002e1cde8fc30c39611b52cf981c88200b858765748556822da72e0d32fac73e\nF test/tkt-b1d3a2e531.test 8f7576e41ca179289ee1a8fee28386fd8e4b0550\nF test/tkt-b351d95f9.test d14a503c414c5c58fdde3e80f9a3cfef986498c0\nF test/tkt-b72787b1.test a95e8cdad0b98af1853ac7f0afd4ab27b77bf5f3\nF test/tkt-b75a9ca6b0.test ade89229d853a67a21bbd5e6e1e787a8f9d21f19908d1b7fca6bf3d4d5aa0767\nF test/tkt-ba7cbfaedc.test b4c0deccc12aeb55cfdb57935b16b5d67c5a9877\nF test/tkt-bd484a090c.test 60460bf946f79a79712b71f202eda501ca99b898\nF test/tkt-bdc6bbbb38.test fc38bb09bdd440e3513a1f5f98fc60a075182d7d\nF test/tkt-c48d99d690.test ba61977d62ab612fc515b3c488a6fbd6464a2447\nF test/tkt-c694113d5.test 82c461924ada5c14866c47e85535b0b0923ba16a2e907e370061a5ca77f65d77\nF test/tkt-cbd054fa6b.test 708475ef4d730a6853512c8ce363bcbd3becf0e26826e1f4cd46e2f52ff38edf\nF test/tkt-d11f09d36e.test d999b548fef885d1d1afa49a0e8544ecf436869d\nF test/tkt-d635236375.test 9d37e988b47d87505bc9445be0ca447002df5d09\nF test/tkt-d82e3f3721.test bcc0dfba658d15bab30fd4a9320c9e35d214ce30\nF test/tkt-f3e5abed55.test d5a0126118142d13e27f6ce9f4c47096e9321c00\nF test/tkt-f67b41381a.test a23bc124c981662db712167bacd0ed8ad11abac9\nF test/tkt-f777251dc7a.test d1a8fc3eefb7a9e64d19ff24d5c8c94c34a632fb\nF test/tkt-f7b4edec.test d998a08ff2b18b7f62edce8e3044317c45efe6c7\nF test/tkt-f973c7ac31.test 28ef85c7f015477916795246d8286aeda39d4ead\nF test/tkt-fa7bf5ec.test 9102dfea58aa371d78969da735f9392c57e2e035\nF test/tkt-fc62af4523.test 72825d3febdedcd5593a27989fc05accdbfc2bb4\nF test/tkt-fc7bd6358f.test 634bb4af7d661e82d6b61b80c86727bad698e08f\nF test/tkt1435.test f8c52c41de6e5ca02f1845f3a46e18e25cadac00\nF test/tkt1443.test bacc311da5c96a227bf8c167e77a30c99f8e8368\nF test/tkt1444.test a9d72f9e942708bd82dde6c707da61c489e213e9\nF test/tkt1449.test 93584a449752d52b07d2cfc280a69842b6e16ed5\nF test/tkt1473.test 9d000af3e11a4450d4c596f5e58b4b0d24eb0f8b\nF test/tkt1501.test 2064f98e00871848af4b2f517e46c1a7fb2e32db\nF test/tkt1512.test a1df1f66caf0b9122d6220c15dcee230298c2c2f\nF test/tkt1514.test ddef38e34fea72eb1ab935ded9f17a3fb71dd9df\nF test/tkt1536.test 83ff7a7b6e248016f8d682d4f7a4ae114070d466\nF test/tkt1537.test e3a14332de9770be8ff14bd15c19a49cbec10808\nF test/tkt1567.test 52f329386ac77e59260d4af1c58490d61377db20\nF test/tkt1644.test 80b6a2bb17885f3cf1cb886d97cdad13232bb869\nF test/tkt1667.test 4700d931ed19ea3983e8e703becb28079250b460\nF test/tkt1873.test 0e1b8c023050a430c2525179ed4022ddc7c31264\nF test/tkt2141.test f543d96f50d5a5dc0bc744f7db74ea166720ce46\nF test/tkt2192.test ff40157e5f42e65f844255d220fc6b290470942f\nF test/tkt2213.test a9702175601a57b61aba095a233b001d6f362474\nF test/tkt2251.test 5aab8c7898cd2df2a68fe19289cc29e8f5cf8c82\nF test/tkt2285.test cca17be61cf600b397188e77e7143844d2b977e9\nF test/tkt2332.test fc955609b958ca86dfa102832243370a0cc84070\nF test/tkt2339.test 73bd17818924cd2ac442e5fd9916b58565739450\nF test/tkt2391.test ab7a11be7402da8b51a5be603425367aa0684567\nF test/tkt2409.test be0d60e7d283f639dccea4b0b5e1cd3a4851fb5b\nF test/tkt2450.test 77ed94863f2049c1420288ddfea2d41e5e0971d6\nF test/tkt2565.test 8be666e927cb207aae88188f31c331870878b650\nF test/tkt2640.test 28134f5d1e05658ef182520cf0b680fa3de5211b\nF test/tkt2643.test 3f3ebb743da00d4fed4fcf6daed92a0e18e57813\nF test/tkt2686.test 6ee01c9b9e9c48f6d3a1fdd553b1cc4258f903d6\nF test/tkt2767.test 569000d842678f9cf2db7e0d1b27cbc9011381b0\nF test/tkt2817.test f31839e01f4243cff7399ef654d3af3558cb8d8d\nF test/tkt2820.test 39940276b3436d125deb7d8ebeee053e4cf13213\nF test/tkt2822.test f391776423a7c0d0949edfce375708bfb0f3141e\nF test/tkt2832.test a9b0b74a02dca166a04d9e37739c414b10929caa\nF test/tkt2854.test e432965db29e27e16f539b2ba7f502eb2ccc49af\nF test/tkt2920.test a8737380e4ae6424e00c0273dc12775704efbebf\nF test/tkt2927.test 4752868b9eeeb07a217f7f19f4cbaac98d6d086d\nF test/tkt2942.test c5c87d179799ca6d1fbe83c815510b87cd5ec7ce\nF test/tkt3080.test 1bca7579260920a66b4dd7e196e807c0f25ff804\nF test/tkt3093.test fbdbc5b4969244ad11f540759003e361fcaf391f\nF test/tkt3121.test 536df66a02838c26a12fe98639354ca1290ca68b\nF test/tkt3201.test f1500ccecc0d578dc4cde7d3242008297c4d59b3\nF test/tkt3292.test 7bad4423cf5eb075dbb58511d66d46fe816744754c9f0050ae60157f71a4fca7\nF test/tkt3298.test 20fd8773b825cb602e033aa04f8602e1ebdcd93c\nF test/tkt3334.test 9756631e3c4aa3c416362c279e3c0953a83b7ca8274cb81a13264bb56296d8b0\nF test/tkt3346.test 6f67c3ed7db94dfc5df4f5f0b63809a1f611e01a\nF test/tkt3357.test 77c37c6482b526fe89941ce951c22d011f5922ed\nF test/tkt3419.test 1bbf36d7ea03b638c15804251287c2391f5c1f6b\nF test/tkt3424.test 61f831bd2b071bd128fa5d00fbda57e656ca5812\nF test/tkt3442.test a1fc47c669e651d16494de3ff349bcb53281456f2ca02c8bc14220b6044bbfe8\nF test/tkt3457.test 5651e2cbb94645b677ec663160b9e192b87b7d365aecdfb24e19f749575a6fc2\nF test/tkt3461.test 228ea328a5a21e8663f80ee3d212a6ad92549a19\nF test/tkt3493.test 1686cbde85f8721fc1bdc0ee72f2ef2f63139218\nF test/tkt3508.test d75704db9501625c7f7deec119fcaf1696aefb7d\nF test/tkt3522.test 22ce2ebbcb04a6be56c0977d405c207967318fd6\nF test/tkt3527.test 1a6a48441b560bdc53aec581a868eb576234874d\nF test/tkt3541.test 5dc257bde9bc833ab9cc6844bf170b998dbb950a\nF test/tkt3554.test f599967f279077bace39220cbe76085c7b423725\nF test/tkt3581.test 1966b7193f1e3f14951cce8c66907ae69454e9a3\nF test/tkt35xx.test f38c1b03713179d414969187c941466e44945b35\nF test/tkt3630.test 9a934c58c259f89a0ae6bb6bb846c56285a6fd0f\nF test/tkt3718.test 3b59dcb5c4e7754dacd91e7fd353a61492cc402a\nF test/tkt3731.test 0c5f4cbffe102d43c3b2188af91a9e36348f974b\nF test/tkt3757.test 10cd679a88675c880533083fc79ac04324525595\nF test/tkt3761.test b95ea9c98f21cf91325f18a984887e62caceab33\nF test/tkt3762.test 4d439ff7abdc8d9323150269d182c37c2d514576\nF test/tkt3773.test 7bca904d2a647a6a4a291bd86d7fd7c73855b789\nF test/tkt3791.test a6624b9a80b216a26cf473607f42f3e51898c267\nF test/tkt3793.test d90ffd75c52413908d15e1c44fc2ea9c80fcc449\nF test/tkt3810.test 09608d81c63a6ff3aaf7bc70717909c51f5f4048\nF test/tkt3824.test 150aa00bb6220672e5f0eb14dc8eaa36750425f0\nF test/tkt3832.test 2300d10d57562b89875b72148338ac3e14f8847d\nF test/tkt3838.test 292e72489101cd1320d7278dc111c173ebf334d4\nF test/tkt3841.test 4659845bc53f809a5932c61c6ce8c5bb9d6b947f\nF test/tkt3871.test d921703d07c68f4fd5312073215a17fa34b0401d\nF test/tkt3879.test 2ad5bef2c87e9991ce941e054c31abe26ef7fb90\nF test/tkt3911.test 74cd324f3ba653040cc6d94cc4857b290d12d633\nF test/tkt3918.test ea78bf164e4d55cbde0d83c671ef6fbe930a0032\nF test/tkt3922.test f26be40ab4fe6c00795629bd2006d96e270d9b1a\nF test/tkt3929.test cdf67acf5aa936ec4ffead81db87f8a71fe40e59\nF test/tkt3935.test e15261fedb9e30a4305a311da614a5d8e693c767\nF test/tkt3992.test f3e7d548ac26f763b47bc0f750da3d03c81071da\nF test/tkt3997.test a335fa41ca3985660a139df7b734a26ef53284bd\nF test/tkt4018.test 18dbc6617f7a4b90e938d1bd6d26ad18daafaf08\nF test/tokenize.test ce430a7aed48fc98301611429595883fdfcab5d7\nF test/tpch01.test 7c4eb8cdd79c568f46d344b3e789c9fdb8a766d112871352704861f3fca32a2a\nF test/trace.test a659a9862957f4789e37a92b3bf6d2caf5c86b02cdeefc41e850ae53acf6992a\nF test/trace2.test f5cb67ad3bc09e0c58e8cca78dfd0b5639259983\nF test/trace3.test 1dff966888773ff1bfea01c080caf15417892b3f998408fe920c4791f7337144\nF test/trans.test 6e1b4c6a42dba31bd65f8fa5e61a2708e08ddde6\nF test/trans2.test 62bd045bfc7a1c14c5ba83ba64d21ade31583f76\nF test/trans3.test 91a100e5412b488e22a655fe423a14c26403ab94\nF test/transitive1.test 293300f46916569f08875cdb2fe2134be2c27677\nF test/trigger1.test 746dc327e2a0817a22bfc6f5a5e423483d3e77b3733ac20a8fe939e6541b5e53\nF test/trigger2.test d15da46f7012832faf3e0c536b47024409d5fb1722d2bb77e29c06d96d704bb1\nF test/trigger3.test aa640bb2bbb03edd5ff69c055117ea088f121945\nF test/trigger4.test 74700b76ebf3947b2f7a92405141eb2cf2a5d359\nF test/trigger5.test 619391a3e9fc194081d22cefd830d811e7badf83\nF test/trigger6.test 0e411654f122552da6590f0b4e6f781048a4a9b9\nF test/trigger7.test e7ce54bfda67a88d778aea42544e151c465547a7e617127b6914c2221a6d53c1\nF test/trigger8.test 30cb0530bd7c4728055420e3f739aa00412eafa4\nF test/trigger9.test 2226ec795a33b0460ab5cf8891e9054cc7edef41\nF test/triggerA.test 837be862d8721f903dba3f3ceff05b32e0bee5214cf6ea3da5fadf12d3650e9d\nF test/triggerB.test 56780c031b454abac2340dbb3b71ac5c56c3d7fe\nF test/triggerC.test 29f5a28d0fe39e6e2c01f6e1f53f08c0955170ae10a63ad023e33cb0a1682a51\nF test/triggerD.test 8e7f3921a92a5797d472732108109e44575fa650\nF test/triggerE.test ede2e4bce4ba802337bd69d39447fa04a938e06d84a8bfc53c76850fc36ed86d\nF test/triggerF.test 5d76f0a8c428ff87a4d5ed52da06f6096a2c787a1e21b846111dfac4123de3ad\nF test/triggerG.test d5caeef6144ede2426dd13211fd72248241ff2ebc68e12a4c0bf30f5faa21499\nF test/tt3_checkpoint.c 9e75cf7c1c364f52e1c47fd0f14c4340a9db0fe1\nF test/tt3_index.c 39eec10a35f57672225be4d182862152896dee4a\nF test/tt3_lookaside1.c 0377e202c3c2a50d688cb65ba203afeda6fafeb9\nF test/tt3_stress.c c57d804716165811d979d4a719e05baccd79277f\nF test/tt3_vacuum.c 1753f45917699c9c1f66b64c717a717c9379f776\nF test/types.test bf816ce73c7dfcfe26b700c19f97ef4050d194ff\nF test/types2.test 1aeb81976841a91eef292723649b5c4fe3bc3cac\nF test/types3.test 99e009491a54f4dc02c06bdbc0c5eea56ae3e25a\nF test/unionvtab.test e1704ab1b4c1bb3ffc9da4681f8e85a0b909fd80b937984fc94b27415ac8e5a4\nF test/unionvtabfault.test e8759f3d14fb938ce9657e2342db34aeac0fb9bc1692b0d1ebb0069630151d06\nF test/unique.test 93f8b2ef5ea51b9495f8d6493429b1fd0f465264\nF test/unique2.test 3674e9f2a3f1fbbfd4772ac74b7a97090d0f77d2\nF test/unixexcl.test d936ba2b06794018e136418addd59a2354eeae97\nF test/unordered.test ffeea7747d5ba962a8009a20b7e53d68cbae05b063604c68702c5998eb50c981\nF test/update.test 1148de8d913e9817717990603aadeca07aab9ddbb10a30f167cbfd8d3a3ccb60\nF test/update2.test 67455bc61fcbcf96923c45b3bc4f87bc72be7d67575ad35f134906148c7b06d3\nF test/upsert1.test 0b740c8488fd2f5a06ac317c9913f7ef1eda8282f2db58b544b89480c51efab3\nF test/upsert2.test 9c3cdbb1a890227f6504ce4b0e3de68f4cdfa16bb21d8641208a9239896c5a09\nF test/upsert3.test 88d7d590a1948a9cb6eac1b54b0642f67a9f35a1fc0f19b200e97d5d39e3179c\nF test/upsert4.test 25d2a1da92f149331ae0c51ca6e3eee78189577585eab92de149900d62994fa5\nF test/upsertfault.test f21ca47740841fdb4d61acfa7b17646d773e67724fe8c185b71c018db8a94b35\nF test/uri.test 3481026f00ade6dfe8adb7acb6e1e47b04369568\nF test/uri2.test 9d3ba7a53ee167572d53a298ee4a5d38ec4a8fb7\nF test/userauth01.test e740a2697a7b40d7c5003a7d7edaee16acd349a9\nF test/utf16align.test 54cd35a27c005a9b6e7815d887718780b6a462ae\nF test/vacuum-into.test 48f4cec354fb6f27c98ef58d2fe49a11b71ff131af0cd9140efacc9858b9f670\nF test/vacuum.test ce91c39f7f91a4273bf620efad21086b5aa6ef1d\nF test/vacuum2.test aa048abee196c16c9ba308465494009057b79f9b\nF test/vacuum3.test 77ecdd54592b45a0bcb133339f99f1ae0ae94d0d\nF test/vacuum4.test 7ea76b769fffeb41f925303b04cbcf5a5bbeabe55e4c60ae754ff24eeeb7c010\nF test/vacuum5.test 263b144d537e92ad8e9ca8a73cc6e1583f41cfd0dda9432b87f7806174a2f48c\nF test/vacuummem.test 7b42abb3208bd82dd23a7536588396f295a314f2\nF test/varint.test bbce22cda8fc4d135bcc2b589574be8410614e62\nF test/veryquick.test 57ab846bacf7b90cf4e9a672721ea5c5b669b661\nF test/view.test 10ea54300a097d7c0337fd104abffe4a4786d1598b94017a37efe0e0d3e04dd5\nF test/vtab1.test c5d9e90ed02bcacd776dcbb7360199d290f7f53c26b484ddece543060c54319f\nF test/vtab2.test 14d4ab26cee13ba6cf5c5601b158e4f57552d3b055cdd9406cf7f711e9c84082\nF test/vtab3.test b45f47d20f225ccc9c28dc915d92740c2dee311e\nF test/vtab4.test 8e73ed268f3d596bc3590f45fc948fb40f28e9c3\nF test/vtab5.test 889f444970393c73f1e077e2bdc5d845e157a391\nF test/vtab6.test 8e789f526e6594cf7ae933d1adee0caa87dc9f78\nF test/vtab7.test 70c6f4a1d6177144a8236e4172d5fba92e683440374664ad1f04851fbb335d3c\nF test/vtab8.test e19fa4a538fcd1bb66c22825fa8f71618fb13583\nF test/vtab9.test ea58d2b95d61955f87226381716b2d0b1d4e4f9b\nF test/vtabA.test 1317f06a03597eee29f40a49b6c21e1aaba4285f\nF test/vtabB.test 04df5dc531b9f44d9ca65b9c1b79f12b5922a796\nF test/vtabC.test 4528f459a13136f982e75614d120aef165f17292\nF test/vtabD.test 05b3f1d77117271671089e48719524b676842e96\nF test/vtabE.test 2a143fe75a11275781d1fd1988d86b66a3f69cb98f4add62e3da8fd0f637b45f\nF test/vtabF.test 1918844c7c902f6a16c8dacf1ec8f84886d6e78b\nF test/vtabH.test 2efb5a24b0bb50796b21eca23032cfb77abfa4b0c03938e38ce5897abac404ca\nF test/vtabI.test 751b07636700dbdea328e4265b6077ccd6811a3f\nF test/vtabJ.test d7b73675708cf63cfcb9d443bb451fc01a028347275b7311e51f9fdf3ca6757f\nF test/vtab_alter.test 736e66fb5ec7b4fee58229aa3ada2f27ec58bc58c00edae4836890c3784c6783\nF test/vtab_err.test dcc8b7b9cb67522b3fe7a272c73856829dae4ab7fdb30399aea1b6981bda2b65\nF test/vtab_shared.test 5253bff2355a9a3f014c15337da7e177ab0ef8ad\nF test/vtabdrop.test 65d4cf6722972e5499bdaf0c0d70ee3b8133944a4e4bc31862563f32a7edca12\nF test/wal.test cdf0ca6cc0447520d19ef1c83287824ebeb3e82d75af856511ba96841a79fc9b\nF test/wal2.test 537f59e5c5932e3b45bf3591ae3e48a2601360c2e52821b633e222fe6ebd5b09\nF test/wal3.test 2a93004bc0fb2b5c29888964024695bade278ab2\nF test/wal4.test 4744e155cd6299c6bd99d3eab1c82f77db9cdb3c\nF test/wal5.test 9c11da7aeccd83a46d79a556ad11a18d3cb15aa9\nF test/wal6.test b602704e4b066199bc89d91ca9000f335dcf4572\nF test/wal64k.test 2a525c0f45d709bae3765c71045ccec5df7d100ccbd3a7860fdba46c9addb965\nF test/wal7.test 2ae8f427d240099cc4b2dfef63cff44e2a68a1bd\nF test/wal8.test d9df3fba4caad5854ed69ed673c68482514203c8\nF test/wal9.test 378e76a9ad09cd9bee06c172ad3547b0129a6750\nF test/wal_common.tcl a98f17fba96206122eff624db0ab13ec377be4fe\nF test/walbak.test 018d4e5a3d45c6298d11b99f09a8ef6876527946\nF test/walbig.test f437473a16cfb314867c6b5d1dbcd519e73e3434\nF test/walblock.test be48f3a75eff0b4456209f26b3ce186c2015497d\nF test/walcksum.test bb234a1bb42248b3515d992b719708015c384278\nF test/walcrash.test 21038858cc552077b0522f50b0fa87e38139306a\nF test/walcrash2.test a0edab4e5390f03b99a790de89aad15d6ec70b36\nF test/walcrash3.test e426aa58122d20f2b9fbe9a507f9eb8cab85b8af\nF test/walcrash4.test e7b6e7639a950a0cca8e210e248c8dad4d63bf20\nF test/walfault.test 09b8ad7e52d2f54bce50e31aa7ea51412bb9f70ac13c74e669ddcd8b48b0d98d\nF test/walfault2.test e039ac66c78d5561683cacde04097213cdad3b58e2b3f3fe1112862217bfd915\nF test/walhook.test ed00a40ba7255da22d6b66433ab61fab16a63483\nF test/walmode.test cd6e7cff618eaaa5910ce57c3657aa50110397f86213886a2400afb9bfec7b7b\nF test/walnoshm.test 84ca10c544632a756467336b7c3b864d493ee496\nF test/waloverwrite.test dad2f26567f1b45174e54fbf9a8dc1cb876a7f03\nF test/walpersist.test 8c6b7e3ec1ba91b5e4dc4e0921d6d3f87cd356a6\nF test/walprotocol.test a112aba0b79e3adeaa485fed09484b32c654e97df58e454aa8489ac2cd57bf84\nF test/walprotocol2.test 7d3b6b4bf0b12f8007121b1e6ef714bc99101fb3b48e46371df1db868eebc131\nF test/walro.test cb438d05ba0d191f10b688e39c4f0cd5b71569a1d1f4440e5bdf3c6880e08c20\nF test/walro2.test 0e79dd15cbdb4f482c01ea248373669c732414a726b357d04846a816afafb768\nF test/walrofault.test c70cb6e308c443867701856cce92ad8288cd99488fa52afab77cca6cfd51af68\nF test/walshared.test 0befc811dcf0b287efae21612304d15576e35417\nF test/walslow.test c05c68d4dc2700a982f89133ce103a1a84cc285f\nF test/walthread.test 14b20fcfa6ae152f5d8e12f5dc8a8a724b7ef189f5d8ef1e2ceab79f2af51747\nF test/walvfs.test ca81c9f427e0e5434076dfa948fd1d8e6d5ddd192b2fb6991635d81da5f3f5d4\nF test/wapp.tcl b440cd8cf57953d3a49e7ee81e6a18f18efdaf113b69f7d8482b0710a64566ec\nF test/wapptest.tcl 3cca775aede0591756a1fc0da55bbb3715d8c363873fd2cfdd4d555b0a4af57d x\nF test/where.test 19c709c9f0f6ed12c23f909f6592aa55fba34269d5a2898537aa27a22b9ce650\nF test/where2.test 478d2170637b9211f593120648858593bf2445a1\nF test/where3.test 2341a294e17193a6b1699ea7f192124a5286ca6acfcc3f4b06d16c931fbcda2c\nF test/where4.test 4a371bfcc607f41d233701bdec33ac2972908ba8\nF test/where5.test fdf66f96d29a064b63eb543e28da4dfdccd81ad2\nF test/where6.test 5da5a98cec820d488e82708301b96cb8c18a258b\nF test/where7.test 75722434c486ac9e74718caa6cce234f45ba34c0b6c0f9555b29eb8bb5f6ade1\nF test/where8.test 461ca40265ed996a6305da99bb024b0e41602bb586acf544c08f95922358e49f\nF test/where9.test 2c554b97bbdb2fdf26c57099f60db8a52bfcf7c147f2c256f9798fa0e267ca85\nF test/whereA.test 6c6a420ca7d313242f9b1bd471dc80e4d0f8323700ba9c78df0bb843d4daa3b4\nF test/whereB.test 0def95db3bdec220a731c7e4bec5930327c1d8c5\nF test/whereC.test cae295158703cb3fc23bf1a108a9ab730efff0f6\nF test/whereD.test 711d4df58d6d4fb9b3f5ce040b818564198be002\nF test/whereE.test b3a055eef928c992b0a33198a7b8dc10eea5ad2f\nF test/whereF.test 3d9412b1199d3e2bed34fcb76b4c48d0bf4df95d27e3f8dd27b6f8b4716d0d89\nF test/whereG.test 4cda56de49f0c7d9a4f2590a3ddc5f79a7f2a03d2229d0f5bb5d3981ce57f293\nF test/whereH.test e4b07f7a3c2f5d31195cd33710054c78667573b2\nF test/whereI.test a2874062140ed4aba9ffae76e6190a3df6fc73d1373fdfa8fd632945082a5364\nF test/whereJ.test 88287550f6ee604422403b053455b1ad894eeaa5c35d348532dfa1439286cb9a\nF test/whereK.test f8e3cf26a8513ecc7f514f54df9f0572c046c42b\nF test/whereL.test 0a19fc44cd1122040f56c934f1b14d0ca85bde28f270268a428dd9796ea0634c\nF test/wherefault.test 1374c3aa198388925246475f84ad4cd5f9528864\nF test/wherelfault.test 9012e4ef5259058b771606616bd007af5d154e64cc25fa9fd4170f6411db44e3\nF test/wherelimit.test 592081800806d297dd7449b1030c863d2883d6d42901837ccd2e5a9bd962edb0\nF test/wherelimit2.test 9bf0aa56cca40ea0e4c5e2915341355a2bbc0859ec4ce1589197fe2a9d94635f\nF test/win32heap.test 10fd891266bd00af68671e702317726375e5407561d859be1aa04696f2aeee74\nF test/win32lock.test fbf107c91d8f5512be5a5b87c4c42ab9fdd54972\nF test/win32longpath.test 169c75a3b2e43481f4a62122510210c67b08f26d\nF test/win32nolock.test ac4f08811a562e45a5755e661f45ca85892bdbbc\nF test/window1.test b3567fde130dd65fedf56da66a3916cc992e61f910a56b7dac3f71608809faac\nF test/window2.tcl 66db96fd9fd202bc31ee7f8ce7904cb469564864cff3f74e009bfef8102333f4\nF test/window2.test af2a001ded703bb8f2474fb0edfef170d5aba00f5c1f2aa9f65935b5da13df90\nF test/window3.tcl acea6e86a4324a210fd608d06741010ca83ded9fde438341cb978c49928faf03\nF test/window3.test e9959a993c8a71e96433be8daaa1827d78b8921e4f12debd7bdbeb3c856ef3cb\nF test/window4.tcl d732df0e81beedc0ba8a563ade68611d322d27303ad0c0c8e4444107c39e84ec\nF test/window4.test 807f3e6b15f9338e5b9742b87c5c7ca825b42b9657fde6096e890119370848e0\nF test/window5.test d328dd18221217c49c144181975eea17339eaeaf0e9aa558cee3afb84652821e\nF test/window6.test f8d674254b23289cc17c84d79dec7eda7caa1dfb7836c43122cfdf3640d1df32\nF test/window7.tcl 6a1210f05d40ec89c22960213a22cd3f98d4e2f2eb20646c83c8c30d4d76108f\nF test/window7.test 1d31276961ae7801edc72173edaf7593e3cbc79c06d1f1f09e20d8418af403cd\nF test/window8.tcl f2711aa3571e4e6b0dad98db8d95fd6cb8d9db0c92bbdf535f153b07606a1ce2\nF test/window8.test c4331b27a6f66d69fa8f8bab10cc731db1a81d293ae108a68f7c3487fa94e65b\nF test/window9.test b63f6f74d730547e63e78946f951f5d1a7d4e99f91f6d5906305469043d92a15\nF test/windowA.test 6d63dc1260daa17141a55007600581778523a8b420629f1282d2acfc36af23be\nF test/windowB.test 7a983ea1cc1cf72be7f378e4b32f6cb2d73014c5cd8b25aaee825164cd4269e5\nF test/windowerr.tcl f5acd6fbc210d7b5546c0e879d157888455cd4a17a1d3f28f07c1c8a387019e0\nF test/windowerr.test a8b752402109c15aa1c5efe1b93ccb0ce1ef84fa964ae1cd6684dd0b3cc1819b\nF test/windowfault.test a90b397837209f15e54afa62e8be39b2759a0101fae04e05a08bcc50e243a452\nF test/with1.test d32792084dcb5f6c047d77bb8a032822ef9fe050ade07d0aeffa37753a05e3c9\nF test/with2.test e0030e2f0267a910d6c0e4f46f2dfe941c1cc0d4f659ba69b3597728e7e8f1ab\nF test/with3.test 7de8dff2891aca0f9453463e4a2d6eb995baf137827d5596116fee53e22a4e29\nF test/with4.test 257be66c0c67fee1defbbac0f685c3465e2cad037f21ce65f23f86084f198205\nF test/withM.test 693b61765f2b387b5e3e24a4536e2e82de15ff64\nF test/without_rowid1.test 9cfb83705c506e3849fa7efc88a3c9a15f9a50bf9b1516b41757a7cef9bba8c3\nF test/without_rowid2.test af260339f79d13cb220288b67cd287fbcf81ad99\nF test/without_rowid3.test ea4b59dd1b0d7f5f5e4b7cca978cdb905752a9d7c57dc4344a591dba765a3691\nF test/without_rowid4.test 4e08bcbaee0399f35d58b5581881e7a6243d458a\nF test/without_rowid5.test 89b1c587bd92a0590e440da33e7666bf4891572a\nF test/without_rowid6.test 8463b20098e9f75a501a9f17dfb42fffc79068eac0b2775fe56ef2281d2df45e\nF test/without_rowid7.test d7c59a93d726b55812d620f8f284e01904a5b85f9ee9eea8f2f68571a5e8c40e\nF test/wordcount.c d721a4b6fae93e6e33449700bce1686bc23257c27425bc3ef1599dc912adec66\nF test/writecrash.test f1da7f7adfe8d7f09ea79b42e5ca6dcc41102f27f8e334ad71539501ddd910cc\nF test/zeroblob.test 07a5b11ab591d1f26c626945fb7f228f68b993533b2ada77273edf6ee29db174\nF test/zerodamage.test 9c41628db7e8d9e8a0181e59ea5f189df311a9f6ce99cc376dc461f66db6f8dc\nF test/zipfile.test b3b558639f7a103e095713ad0f57fec1fce1b7d60c8054df5789b98f7547a395\nF test/zipfile2.test 9903388a602a3834189857a985106ff95c3bba6a3969e0134127df991889db5d\nF test/zipfilefault.test 44d4d7a7f7cca7521d569d7f71026b241d65a6b1757aa409c1a168827edbbc2c\nF tool/GetFile.cs 47852aa0d806fe47ed1ac5138bdce7f000fe87aaa7f28107d0cb1e26682aeb44\nF tool/GetTclKit.bat 8995df40c4209808b31f24de0b58f90930239a234f7591e3675d45bfbb990c5d\nF tool/Replace.cs 02c67258801c2fb5f63231e0ac0f220b4b36ba91\nF tool/build-all-msvc.bat c12328d06c45fec8baada5949e3d5af54bf8c887 x\nF tool/build-shell.sh 950f47c6174f1eea171319438b93ba67ff5bf367\nF tool/cg_anno.tcl c1f875f5a4c9caca3d59937b16aff716f8b1883935f1b4c9ae23124705bc8099 x\nF tool/checkSpacing.c 810e51703529a204fc4e1eb060e9ab663e3c06d2\nF tool/dbhash.c 19560c9a2aa2b269b6a5108259b93d26d12f8f0877c31fe9f8f61dfbd219ba63\nF tool/dbtotxt.c b2221864a20fb391c46bd31bc1fbdc4a96f5c8a89bef58f421eb9b9c36b1702c\nF tool/dbtotxt.md c9a57af8739957ef36d2cfad5c4b1443ff3688ed33e4901ee200c8b651f43f3c\nF tool/extract-sqlite3h.tcl 069ceab0cee26cba99952bfa08c0b23e35941c837acabe143f0c355d96c9e2eb x\nF tool/extract.c 054069d81b095fbdc189a6f5d4466e40380505e2\nF tool/fast_vacuum.c 5ba0d6f5963a0a63bdc42840f678bad75b2ebce1\nF tool/fragck.tcl 5265a95126abcf6ab357f7efa544787e5963f439\nF tool/fuzzershell.c e1d90a03ca790d7c331c2aae08ca46ff435f1ae1faa6cb9cc48f4687c18fdc6e\nF tool/genfkey.README cf68fddd4643bbe3ff8e31b8b6d8b0a1b85e20f4\nF tool/genfkey.test b6afd7b825d797a1e1274f519ab5695373552ecad5cd373530c63533638a5a4f\nF tool/getlock.c f4c39b651370156cae979501a7b156bdba50e7ce\nF tool/index_usage.c 9ec344d29cbeb03fdc0fce668eedfb7495792170de933adf95cf8d6904a166ad\nF tool/kvtest-speed.sh 4761a9c4b3530907562314d7757995787f7aef8f\nF tool/lemon.c fa7912caf5662ee9b3afc7ff2a2607e81437d603e2f86c88ab412ef43f78fc24\nF tool/lempar.c 34b136b281ae022277738d8b51061237fb330deaa317010d89375117e3a028aa\nF tool/libvers.c caafc3b689638a1d88d44bc5f526c2278760d9b9\nF tool/loadfts.c c3c64e4d5e90e8ba41159232c2189dba4be7b862\nF tool/logest.c 11346aa019e2e77a00902aa7d0cabd27bd2e8cca\nF tool/max-limits.c cbb635fbb37ae4d05f240bfb5b5270bb63c54439\nF tool/mkautoconfamal.sh 422fc365358a2e92876ffc62971a0ff28ed472fc8bcf9de0df921c736fdeca5e\nF tool/mkccode.tcl 86463e68ce9c15d3041610fedd285ce32a5cf7a58fc88b3202b8b76837650dbe x\nF tool/mkctimec.tcl dd183b73ae1c28249669741c250525f0407e579a70482371668fd5f130d9feb3\nF tool/mkkeywordhash.c 27ffc6f6e7e3ecbfc5bca1f1f11a09fc5badf6d67557a5fb2d3b069dbed90617\nF tool/mkmsvcmin.tcl cad0c7b54d7dd92bc87d59f36d4cc4f070eb2e625f14159dc2f5c4204e6a13ea\nF tool/mkopcodec.tcl d1b6362bd3aa80d5520d4d6f3765badf01f6c43c\nF tool/mkopcodeh.tcl 352a4319c0ad869eb26442bf7c3b015aa15594c21f1cce5a6420dbe999367c21\nF tool/mkopts.tcl 680f785fdb09729fd9ac50632413da4eadbdf9071535e3f26d03795828ab07fa\nF tool/mkpragmatab.tcl 70269c7013dab01c5d366b1bb4cee6e42fa1a3a8d179a052d14d6b31f11ad77f\nF tool/mkshellc.tcl 70a9978e363b0f3280ca9ce1c46d72563ff479c1930a12a7375e3881b7325712\nF tool/mksourceid.c 36aa8020014aed0836fd13c51d6dc9219b0df1761d6b5f58ff5b616211b079b9\nF tool/mkspeedsql.tcl a1a334d288f7adfe6e996f2e712becf076745c97\nF tool/mksqlite3c-noext.tcl 4f7cfef5152b0c91920355cbfc1d608a4ad242cb819f1aea07f6d0274f584a7f\nF tool/mksqlite3c.tcl 5fed3d75069d8f66f202d3b5200b0cea4aa7108481acd06732a06fdd42eb83a2\nF tool/mksqlite3h.tcl 080873e3856eceb9d289a08a00c4b30f875ea3feadcbece796bd509b1532792c\nF tool/mksqlite3internalh.tcl eb994013e833359137eb53a55acdad0b5ae1049b\nF tool/mkvsix.tcl b9e0777a213c23156b6542842c238479e496ebf5\nF tool/offsets.c fe4262fdfa378e8f5499a42136d17bf3b98f6091\nF tool/omittest.tcl 27f9413c3343bac200a28d81e8234adb0f5e141c4771893cb19b40235a91f1e0\nF tool/opcodesum.tcl 740ed206ba8c5040018988129abbf3089a0ccf4a\nF tool/pagesig.c ff0ca355fd3c2398e933da5e22439bbff89b803b\nF tool/replace.tcl 60f91e8dd06ab81f74d213ecbd9c9945f32ac048\nF tool/restore_jrnl.tcl 6957a34f8f1f0f8285e07536225ec3b292a9024a\nF tool/rollback-test.c 9fc98427d1e23e84429d7e6d07d9094fbdec65a5\nF tool/run-speed-test.sh f95d19fd669b68c4c38b6b475242841d47c66076\nF tool/showdb.c 97d14a1ce32d5edda84081a5c939bd8975abd89568a773b288940e67e4c7e3ad\nF tool/showjournal.c 5bad7ae8784a43d2b270d953060423b8bd480818\nF tool/showlocks.c 9920bcc64f58378ff1118caead34147201f48c68\nF tool/showshm.c a0ab6ec32dd1f11218ca2a4018f8fb875b59414801ab8ceed8b2e69b7b45a809\nF tool/showstat4.c 0682ebea7abf4d3657f53c4a243f2e7eab48eab344ed36a94bb75dcd19a5c2a1\nF tool/showwal.c ad9d768f96ca6199ad3a8c9562d679680bd032dd01204ea3e5ea6fb931d81847\nF tool/soak1.tcl 8d407956e1a45b485a8e072470a3e629a27037fe\nF tool/spaceanal.tcl 4bfd19aad7eb3ce0372ef0255f58035e0bba4ff5e9acfd763a10c6fb365c8dec\nF tool/speed-check.sh 2b042d703a9472f08c3b13be27afac658426f8e4fc87cd2d575953fda86f08d1\nF tool/speedtest.tcl 06c76698485ccf597b9e7dbb1ac70706eb873355\nF tool/speedtest16.c ecb6542862151c3e6509bbc00509b234562ae81e\nF tool/speedtest2.tcl ee2149167303ba8e95af97873c575c3e0fab58ff\nF tool/speedtest8.c 2902c46588c40b55661e471d7a86e4dd71a18224\nF tool/speedtest8inst1.c 7ce07da76b5e745783e703a834417d725b7d45fd\nF tool/split-sqlite3c.tcl 3efcd4240b738f6bb2b5af0aea7e1e0ef9bc1c61654f645076cec883030b710c\nF tool/sqldiff.c 7b9b7238284f02131dbb8f21a4e862409bff728045c5473139d28c67ac87580e\nF tool/sqlite3_analyzer.c.in 7eeaae8b0d7577662acaabbb11107af0659d1b41bc1dfdd4d91422de27127968\nF tool/sqltclsh.c.in 1bcc2e9da58fadf17b0bf6a50e68c1159e602ce057210b655d50bad5aaaef898\nF tool/sqltclsh.tcl 862f4cf1418df5e1315b5db3b5ebe88969e2a784525af5fbf9596592f14ed848\nF tool/srcck1.c 371de5363b70154012955544f86fdee8f6e5326f\nF tool/stack_usage.tcl f8e71b92cdb099a147dad572375595eae55eca43\nF tool/symbols-mingw.sh 4dbcea7e74768305384c9fd2ed2b41bbf9f0414d\nF tool/symbols.sh 1612bd947750e21e7b47befad5f6b3825b06cce0705441f903bf35ced65ae9b9\nF tool/varint.c 5d94cb5003db9dbbcbcc5df08d66f16071aee003\nF tool/vdbe-compress.tcl 5926c71f9c12d2ab73ef35c29376e756eb68361c\nF tool/vdbe_profile.tcl 246d0da094856d72d2c12efec03250d71639d19f\nF tool/warnings-clang.sh bbf6a1e685e534c92ec2bfba5b1745f34fb6f0bc2a362850723a9ee87c1b31a7\nF tool/warnings.sh 09311479bdc290e20ec8e35a3d1b14b096bbd96222277cfd6274c3a99b3d012f\nF tool/win/sqlite.vsix deb315d026cc8400325c5863eef847784a219a2f\nF vsixtest/App.xaml b76d3b48860e7454775c47ea38ffea9c4abe3e85\nF vsixtest/App.xaml.cpp c465147f50871165c60ca16955219f6c5812d6d8\nF vsixtest/App.xaml.h 4a9768e2983d05600ad1e1c2f1b00a132967da9f\nF vsixtest/Assets/LockScreenLogo.scale-200.png e820c9a3deb909197081b0bf3216c06e13905f0a\nF vsixtest/Assets/SplashScreen.scale-200.png cab70988ca71bebec7bfeb3b6dbafe17b9ab0b4a\nF vsixtest/Assets/Square150x150Logo.scale-200.png e17b40817db7a239fc239d83efcc951fb824e3ff\nF vsixtest/Assets/Square44x44Logo.scale-200.png 2f166237094dea94d952d10b9eeae81806844f1c\nF vsixtest/Assets/Square44x44Logo.targetsize-24_altform-unplated.png 5f6a6d391b95a3061ccca6e6fdd6955ede63b4ed\nF vsixtest/Assets/StoreLogo.png 0828b7257db74a4ecd5eeb6b7b4971f0fdc4d9d1\nF vsixtest/Assets/Wide310x150Logo.scale-200.png 04ddefe5bc5f43ae12a7433f6f236ddab101ac42\nF vsixtest/MainPage.xaml 34f49897e3ca533a7e74506ba0759b66eebce151\nF vsixtest/MainPage.xaml.cpp 7f31fc6de751b64676c0924c97a5485d950a91d7\nF vsixtest/MainPage.xaml.h cc05cca10d50a003f6c6e4448b701cdd07f52f29\nF vsixtest/Package.appxmanifest 6b6db1eb7df3a315c5d681059754d5f0e0c47a93\nF vsixtest/pch.cpp cb823cfac36f1a39a7eb0acbd7e9a0b0de8f23af\nF vsixtest/pch.h 9cab7980f2ac4baa40807d8b5e52af32a21cf78c\nF vsixtest/vsixtest.sln 77cadbe4e96c1fe1bf51cd77de9e9b0a12ada547\nF vsixtest/vsixtest.tcl 6a9a6ab600c25a91a7acc6293828957a386a8a93\nF vsixtest/vsixtest.vcxproj.data 2ed517e100c66dc455b492e1a33350c1b20fbcdc\nF vsixtest/vsixtest.vcxproj.filters 37e51ffedcdb064aad6ff33b6148725226cd608e\nF vsixtest/vsixtest_TemporaryKey.pfx e5b1b036facdb453873e7084e1cae9102ccc67a0\nP c5d44143599f3fe98492b2b900fa3d77925c7be545096251055ceeab899a41f1\nR 22fd1a654a96a45bd7c185276aceb3b2\nU dan\nZ 7090efa7effe7e9fcfeaeecdf4e29b8c\n", "1d2e53a39b87e364685e21de137655b6eee725e4c6d27fc90865072d7c5892b5", "/*\n** 2005 February 15\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This file contains C code routines that used to generate VDBE code\n** that implements the ALTER TABLE command.\n*/\n#include \"sqliteInt.h\"\n\n/*\n** The code in this file only exists if we are not omitting the\n** ALTER TABLE logic from the build.\n*/\n#ifndef SQLITE_OMIT_ALTERTABLE\n\n/*\n** Parameter zName is the name of a table that is about to be altered\n** (either with ALTER TABLE ... RENAME TO or ALTER TABLE ... ADD COLUMN).\n** If the table is a system table, this function leaves an error message\n** in pParse->zErr (system tables may not be altered) and returns non-zero.\n**\n** Or, if zName is not a system table, zero is returned.\n*/\nstatic int isAlterableTable(Parse *pParse, Table *pTab){\n  if( 0==sqlite3StrNICmp(pTab->zName, \"sqlite_\", 7) \n#ifndef SQLITE_OMIT_VIRTUALTABLE\n   || ( (pTab->tabFlags & TF_Shadow)!=0\n        && sqlite3ReadOnlyShadowTables(pParse->db)\n   )\n#endif\n  ){\n    sqlite3ErrorMsg(pParse, \"table %s may not be altered\", pTab->zName);\n    return 1;\n  }\n  return 0;\n}\n\n/*\n** Generate code to verify that the schemas of database zDb and, if\n** bTemp is not true, database \"temp\", can still be parsed. This is\n** called at the end of the generation of an ALTER TABLE ... RENAME ...\n** statement to ensure that the operation has not rendered any schema\n** objects unusable.\n*/\nstatic void renameTestSchema(Parse *pParse, const char *zDb, int bTemp){\n  sqlite3NestedParse(pParse, \n      \"SELECT 1 \"\n      \"FROM \\\"%w\\\".%s \"\n      \"WHERE name NOT LIKE 'sqliteX_%%' ESCAPE 'X'\"\n      \" AND sql NOT LIKE 'create virtual%%'\"\n      \" AND sqlite_rename_test(%Q, sql, type, name, %d)=NULL \",\n      zDb, MASTER_NAME, \n      zDb, bTemp\n  );\n\n  if( bTemp==0 ){\n    sqlite3NestedParse(pParse, \n        \"SELECT 1 \"\n        \"FROM temp.%s \"\n        \"WHERE name NOT LIKE 'sqliteX_%%' ESCAPE 'X'\"\n        \" AND sql NOT LIKE 'create virtual%%'\"\n        \" AND sqlite_rename_test(%Q, sql, type, name, 1)=NULL \",\n        MASTER_NAME, zDb \n    );\n  }\n}\n\n/*\n** Generate code to reload the schema for database iDb. And, if iDb!=1, for\n** the temp database as well.\n*/\nstatic void renameReloadSchema(Parse *pParse, int iDb){\n  Vdbe *v = pParse->pVdbe;\n  if( v ){\n    sqlite3ChangeCookie(pParse, iDb);\n    sqlite3VdbeAddParseSchemaOp(pParse->pVdbe, iDb, 0);\n    if( iDb!=1 ) sqlite3VdbeAddParseSchemaOp(pParse->pVdbe, 1, 0);\n  }\n}\n\n/*\n** Generate code to implement the \"ALTER TABLE xxx RENAME TO yyy\" \n** command. \n*/\nvoid sqlite3AlterRenameTable(\n  Parse *pParse,            /* Parser context. */\n  SrcList *pSrc,            /* The table to rename. */\n  Token *pName              /* The new table name. */\n){\n  int iDb;                  /* Database that contains the table */\n  char *zDb;                /* Name of database iDb */\n  Table *pTab;              /* Table being renamed */\n  char *zName = 0;          /* NULL-terminated version of pName */ \n  sqlite3 *db = pParse->db; /* Database connection */\n  int nTabName;             /* Number of UTF-8 characters in zTabName */\n  const char *zTabName;     /* Original name of the table */\n  Vdbe *v;\n  VTable *pVTab = 0;        /* Non-zero if this is a v-tab with an xRename() */\n  u32 savedDbFlags;         /* Saved value of db->mDbFlags */\n\n  savedDbFlags = db->mDbFlags;  \n  if( NEVER(db->mallocFailed) ) goto exit_rename_table;\n  assert( pSrc->nSrc==1 );\n  assert( sqlite3BtreeHoldsAllMutexes(pParse->db) );\n\n  pTab = sqlite3LocateTableItem(pParse, 0, &pSrc->a[0]);\n  if( !pTab ) goto exit_rename_table;\n  iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);\n  zDb = db->aDb[iDb].zDbSName;\n  db->mDbFlags |= DBFLAG_PreferBuiltin;\n\n  /* Get a NULL terminated version of the new table name. */\n  zName = sqlite3NameFromToken(db, pName);\n  if( !zName ) goto exit_rename_table;\n\n  /* Check that a table or index named 'zName' does not already exist\n  ** in database iDb. If so, this is an error.\n  */\n  if( sqlite3FindTable(db, zName, zDb) || sqlite3FindIndex(db, zName, zDb) ){\n    sqlite3ErrorMsg(pParse, \n        \"there is already another table or index with this name: %s\", zName);\n    goto exit_rename_table;\n  }\n\n  /* Make sure it is not a system table being altered, or a reserved name\n  ** that the table is being renamed to.\n  */\n  if( SQLITE_OK!=isAlterableTable(pParse, pTab) ){\n    goto exit_rename_table;\n  }\n  if( SQLITE_OK!=sqlite3CheckObjectName(pParse,zName,\"table\",zName) ){\n    goto exit_rename_table;\n  }\n\n#ifndef SQLITE_OMIT_VIEW\n  if( pTab->pSelect ){\n    sqlite3ErrorMsg(pParse, \"view %s may not be altered\", pTab->zName);\n    goto exit_rename_table;\n  }\n#endif\n\n#ifndef SQLITE_OMIT_AUTHORIZATION\n  /* Invoke the authorization callback. */\n  if( sqlite3AuthCheck(pParse, SQLITE_ALTER_TABLE, zDb, pTab->zName, 0) ){\n    goto exit_rename_table;\n  }\n#endif\n\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n  if( sqlite3ViewGetColumnNames(pParse, pTab) ){\n    goto exit_rename_table;\n  }\n  if( IsVirtual(pTab) ){\n    pVTab = sqlite3GetVTable(db, pTab);\n    if( pVTab->pVtab->pModule->xRename==0 ){\n      pVTab = 0;\n    }\n  }\n#endif\n\n  /* Begin a transaction for database iDb. Then modify the schema cookie\n  ** (since the ALTER TABLE modifies the schema). Call sqlite3MayAbort(),\n  ** as the scalar functions (e.g. sqlite_rename_table()) invoked by the \n  ** nested SQL may raise an exception.  */\n  v = sqlite3GetVdbe(pParse);\n  if( v==0 ){\n    goto exit_rename_table;\n  }\n  sqlite3MayAbort(pParse);\n\n  /* figure out how many UTF-8 characters are in zName */\n  zTabName = pTab->zName;\n  nTabName = sqlite3Utf8CharLen(zTabName, -1);\n\n  /* Rewrite all CREATE TABLE, INDEX, TRIGGER or VIEW statements in\n  ** the schema to use the new table name.  */\n  sqlite3NestedParse(pParse, \n      \"UPDATE \\\"%w\\\".%s SET \"\n      \"sql = sqlite_rename_table(%Q, type, name, sql, %Q, %Q, %d) \"\n      \"WHERE (type!='index' OR tbl_name=%Q COLLATE nocase)\"\n      \"AND   name NOT LIKE 'sqliteX_%%' ESCAPE 'X'\"\n      , zDb, MASTER_NAME, zDb, zTabName, zName, (iDb==1), zTabName\n  );\n\n  /* Update the tbl_name and name columns of the sqlite_master table\n  ** as required.  */\n  sqlite3NestedParse(pParse,\n      \"UPDATE %Q.%s SET \"\n          \"tbl_name = %Q, \"\n          \"name = CASE \"\n            \"WHEN type='table' THEN %Q \"\n            \"WHEN name LIKE 'sqliteX_autoindex%%' ESCAPE 'X' \"\n            \"     AND type='index' THEN \"\n             \"'sqlite_autoindex_' || %Q || substr(name,%d+18) \"\n            \"ELSE name END \"\n      \"WHERE tbl_name=%Q COLLATE nocase AND \"\n          \"(type='table' OR type='index' OR type='trigger');\", \n      zDb, MASTER_NAME, \n      zName, zName, zName, \n      nTabName, zTabName\n  );\n\n#ifndef SQLITE_OMIT_AUTOINCREMENT\n  /* If the sqlite_sequence table exists in this database, then update \n  ** it with the new table name.\n  */\n  if( sqlite3FindTable(db, \"sqlite_sequence\", zDb) ){\n    sqlite3NestedParse(pParse,\n        \"UPDATE \\\"%w\\\".sqlite_sequence set name = %Q WHERE name = %Q\",\n        zDb, zName, pTab->zName);\n  }\n#endif\n\n  /* If the table being renamed is not itself part of the temp database,\n  ** edit view and trigger definitions within the temp database \n  ** as required.  */\n  if( iDb!=1 ){\n    sqlite3NestedParse(pParse, \n        \"UPDATE sqlite_temp_master SET \"\n            \"sql = sqlite_rename_table(%Q, type, name, sql, %Q, %Q, 1), \"\n            \"tbl_name = \"\n              \"CASE WHEN tbl_name=%Q COLLATE nocase AND \"\n              \"          sqlite_rename_test(%Q, sql, type, name, 1) \"\n              \"THEN %Q ELSE tbl_name END \"\n            \"WHERE type IN ('view', 'trigger')\"\n        , zDb, zTabName, zName, zTabName, zDb, zName);\n  }\n\n  /* If this is a virtual table, invoke the xRename() function if\n  ** one is defined. The xRename() callback will modify the names\n  ** of any resources used by the v-table implementation (including other\n  ** SQLite tables) that are identified by the name of the virtual table.\n  */\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n  if( pVTab ){\n    int i = ++pParse->nMem;\n    sqlite3VdbeLoadString(v, i, zName);\n    sqlite3VdbeAddOp4(v, OP_VRename, i, 0, 0,(const char*)pVTab, P4_VTAB);\n  }\n#endif\n\n  renameReloadSchema(pParse, iDb);\n  renameTestSchema(pParse, zDb, iDb==1);\n\nexit_rename_table:\n  sqlite3SrcListDelete(db, pSrc);\n  sqlite3DbFree(db, zName);\n  db->mDbFlags = savedDbFlags;\n}\n\n/*\n** This function is called after an \"ALTER TABLE ... ADD\" statement\n** has been parsed. Argument pColDef contains the text of the new\n** column definition.\n**\n** The Table structure pParse->pNewTable was extended to include\n** the new column during parsing.\n*/\nvoid sqlite3AlterFinishAddColumn(Parse *pParse, Token *pColDef){\n  Table *pNew;              /* Copy of pParse->pNewTable */\n  Table *pTab;              /* Table being altered */\n  int iDb;                  /* Database number */\n  const char *zDb;          /* Database name */\n  const char *zTab;         /* Table name */\n  char *zCol;               /* Null-terminated column definition */\n  Column *pCol;             /* The new column */\n  Expr *pDflt;              /* Default value for the new column */\n  sqlite3 *db;              /* The database connection; */\n  Vdbe *v;                  /* The prepared statement under construction */\n  int r1;                   /* Temporary registers */\n\n  db = pParse->db;\n  if( pParse->nErr || db->mallocFailed ) return;\n  pNew = pParse->pNewTable;\n  assert( pNew );\n\n  assert( sqlite3BtreeHoldsAllMutexes(db) );\n  iDb = sqlite3SchemaToIndex(db, pNew->pSchema);\n  zDb = db->aDb[iDb].zDbSName;\n  zTab = &pNew->zName[16];  /* Skip the \"sqlite_altertab_\" prefix on the name */\n  pCol = &pNew->aCol[pNew->nCol-1];\n  pDflt = pCol->pDflt;\n  pTab = sqlite3FindTable(db, zTab, zDb);\n  assert( pTab );\n\n#ifndef SQLITE_OMIT_AUTHORIZATION\n  /* Invoke the authorization callback. */\n  if( sqlite3AuthCheck(pParse, SQLITE_ALTER_TABLE, zDb, pTab->zName, 0) ){\n    return;\n  }\n#endif\n\n\n  /* Check that the new column is not specified as PRIMARY KEY or UNIQUE.\n  ** If there is a NOT NULL constraint, then the default value for the\n  ** column must not be NULL.\n  */\n  if( pCol->colFlags & COLFLAG_PRIMKEY ){\n    sqlite3ErrorMsg(pParse, \"Cannot add a PRIMARY KEY column\");\n    return;\n  }\n  if( pNew->pIndex ){\n    sqlite3ErrorMsg(pParse, \"Cannot add a UNIQUE column\");\n    return;\n  }\n  if( (pCol->colFlags & COLFLAG_GENERATED)==0 ){\n    /* If the default value for the new column was specified with a \n    ** literal NULL, then set pDflt to 0. This simplifies checking\n    ** for an SQL NULL default below.\n    */\n    assert( pDflt==0 || pDflt->op==TK_SPAN );\n    if( pDflt && pDflt->pLeft->op==TK_NULL ){\n      pDflt = 0;\n    }\n    if( (db->flags&SQLITE_ForeignKeys) && pNew->pFKey && pDflt ){\n      sqlite3ErrorMsg(pParse, \n          \"Cannot add a REFERENCES column with non-NULL default value\");\n      return;\n    }\n    if( pCol->notNull && !pDflt ){\n      sqlite3ErrorMsg(pParse, \n          \"Cannot add a NOT NULL column with default value NULL\");\n      return;\n    }\n\n    /* Ensure the default expression is something that sqlite3ValueFromExpr()\n    ** can handle (i.e. not CURRENT_TIME etc.)\n    */\n    if( pDflt ){\n      sqlite3_value *pVal = 0;\n      int rc;\n      rc = sqlite3ValueFromExpr(db, pDflt, SQLITE_UTF8, SQLITE_AFF_BLOB, &pVal);\n      assert( rc==SQLITE_OK || rc==SQLITE_NOMEM );\n      if( rc!=SQLITE_OK ){\n        assert( db->mallocFailed == 1 );\n        return;\n      }\n      if( !pVal ){\n        sqlite3ErrorMsg(pParse,\"Cannot add a column with non-constant default\");\n        return;\n      }\n      sqlite3ValueFree(pVal);\n    }\n  }else if( pCol->colFlags & COLFLAG_STORED ){\n    sqlite3ErrorMsg(pParse, \"cannot add a STORED column\");\n    return;\n  }\n\n\n  /* Modify the CREATE TABLE statement. */\n  zCol = sqlite3DbStrNDup(db, (char*)pColDef->z, pColDef->n);\n  if( zCol ){\n    char *zEnd = &zCol[pColDef->n-1];\n    u32 savedDbFlags = db->mDbFlags;\n    while( zEnd>zCol && (*zEnd==';' || sqlite3Isspace(*zEnd)) ){\n      *zEnd-- = '\\0';\n    }\n    db->mDbFlags |= DBFLAG_PreferBuiltin;\n    sqlite3NestedParse(pParse, \n        \"UPDATE \\\"%w\\\".%s SET \"\n          \"sql = substr(sql,1,%d) || ', ' || %Q || substr(sql,%d) \"\n        \"WHERE type = 'table' AND name = %Q\", \n      zDb, MASTER_NAME, pNew->addColOffset, zCol, pNew->addColOffset+1,\n      zTab\n    );\n    sqlite3DbFree(db, zCol);\n    db->mDbFlags = savedDbFlags;\n  }\n\n  /* Make sure the schema version is at least 3.  But do not upgrade\n  ** from less than 3 to 4, as that will corrupt any preexisting DESC\n  ** index.\n  */\n  v = sqlite3GetVdbe(pParse);\n  if( v ){\n    r1 = sqlite3GetTempReg(pParse);\n    sqlite3VdbeAddOp3(v, OP_ReadCookie, iDb, r1, BTREE_FILE_FORMAT);\n    sqlite3VdbeUsesBtree(v, iDb);\n    sqlite3VdbeAddOp2(v, OP_AddImm, r1, -2);\n    sqlite3VdbeAddOp2(v, OP_IfPos, r1, sqlite3VdbeCurrentAddr(v)+2);\n    VdbeCoverage(v);\n    sqlite3VdbeAddOp3(v, OP_SetCookie, iDb, BTREE_FILE_FORMAT, 3);\n    sqlite3ReleaseTempReg(pParse, r1);\n  }\n\n  /* Reload the table definition */\n  renameReloadSchema(pParse, iDb);\n}\n\n/*\n** This function is called by the parser after the table-name in\n** an \"ALTER TABLE <table-name> ADD\" statement is parsed. Argument \n** pSrc is the full-name of the table being altered.\n**\n** This routine makes a (partial) copy of the Table structure\n** for the table being altered and sets Parse.pNewTable to point\n** to it. Routines called by the parser as the column definition\n** is parsed (i.e. sqlite3AddColumn()) add the new Column data to \n** the copy. The copy of the Table structure is deleted by tokenize.c \n** after parsing is finished.\n**\n** Routine sqlite3AlterFinishAddColumn() will be called to complete\n** coding the \"ALTER TABLE ... ADD\" statement.\n*/\nvoid sqlite3AlterBeginAddColumn(Parse *pParse, SrcList *pSrc){\n  Table *pNew;\n  Table *pTab;\n  int iDb;\n  int i;\n  int nAlloc;\n  sqlite3 *db = pParse->db;\n\n  /* Look up the table being altered. */\n  assert( pParse->pNewTable==0 );\n  assert( sqlite3BtreeHoldsAllMutexes(db) );\n  if( db->mallocFailed ) goto exit_begin_add_column;\n  pTab = sqlite3LocateTableItem(pParse, 0, &pSrc->a[0]);\n  if( !pTab ) goto exit_begin_add_column;\n\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n  if( IsVirtual(pTab) ){\n    sqlite3ErrorMsg(pParse, \"virtual tables may not be altered\");\n    goto exit_begin_add_column;\n  }\n#endif\n\n  /* Make sure this is not an attempt to ALTER a view. */\n  if( pTab->pSelect ){\n    sqlite3ErrorMsg(pParse, \"Cannot add a column to a view\");\n    goto exit_begin_add_column;\n  }\n  if( SQLITE_OK!=isAlterableTable(pParse, pTab) ){\n    goto exit_begin_add_column;\n  }\n\n  sqlite3MayAbort(pParse);\n  assert( pTab->addColOffset>0 );\n  iDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n\n  /* Put a copy of the Table struct in Parse.pNewTable for the\n  ** sqlite3AddColumn() function and friends to modify.  But modify\n  ** the name by adding an \"sqlite_altertab_\" prefix.  By adding this\n  ** prefix, we insure that the name will not collide with an existing\n  ** table because user table are not allowed to have the \"sqlite_\"\n  ** prefix on their name.\n  */\n  pNew = (Table*)sqlite3DbMallocZero(db, sizeof(Table));\n  if( !pNew ) goto exit_begin_add_column;\n  pParse->pNewTable = pNew;\n  pNew->nTabRef = 1;\n  pNew->nCol = pTab->nCol;\n  assert( pNew->nCol>0 );\n  nAlloc = (((pNew->nCol-1)/8)*8)+8;\n  assert( nAlloc>=pNew->nCol && nAlloc%8==0 && nAlloc-pNew->nCol<8 );\n  pNew->aCol = (Column*)sqlite3DbMallocZero(db, sizeof(Column)*nAlloc);\n  pNew->zName = sqlite3MPrintf(db, \"sqlite_altertab_%s\", pTab->zName);\n  if( !pNew->aCol || !pNew->zName ){\n    assert( db->mallocFailed );\n    goto exit_begin_add_column;\n  }\n  memcpy(pNew->aCol, pTab->aCol, sizeof(Column)*pNew->nCol);\n  for(i=0; i<pNew->nCol; i++){\n    Column *pCol = &pNew->aCol[i];\n    pCol->zName = sqlite3DbStrDup(db, pCol->zName);\n    pCol->zColl = 0;\n    pCol->pDflt = 0;\n  }\n  pNew->pSchema = db->aDb[iDb].pSchema;\n  pNew->addColOffset = pTab->addColOffset;\n  pNew->nTabRef = 1;\n\nexit_begin_add_column:\n  sqlite3SrcListDelete(db, pSrc);\n  return;\n}\n\n/*\n** Parameter pTab is the subject of an ALTER TABLE ... RENAME COLUMN\n** command. This function checks if the table is a view or virtual\n** table (columns of views or virtual tables may not be renamed). If so,\n** it loads an error message into pParse and returns non-zero.\n**\n** Or, if pTab is not a view or virtual table, zero is returned.\n*/\n#if !defined(SQLITE_OMIT_VIEW) || !defined(SQLITE_OMIT_VIRTUALTABLE)\nstatic int isRealTable(Parse *pParse, Table *pTab){\n  const char *zType = 0;\n#ifndef SQLITE_OMIT_VIEW\n  if( pTab->pSelect ){\n    zType = \"view\";\n  }\n#endif\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n  if( IsVirtual(pTab) ){\n    zType = \"virtual table\";\n  }\n#endif\n  if( zType ){\n    sqlite3ErrorMsg(\n        pParse, \"cannot rename columns of %s \\\"%s\\\"\", zType, pTab->zName\n    );\n    return 1;\n  }\n  return 0;\n}\n#else /* !defined(SQLITE_OMIT_VIEW) || !defined(SQLITE_OMIT_VIRTUALTABLE) */\n# define isRealTable(x,y) (0)\n#endif\n\n/*\n** Handles the following parser reduction:\n**\n**  cmd ::= ALTER TABLE pSrc RENAME COLUMN pOld TO pNew\n*/\nvoid sqlite3AlterRenameColumn(\n  Parse *pParse,                  /* Parsing context */\n  SrcList *pSrc,                  /* Table being altered.  pSrc->nSrc==1 */\n  Token *pOld,                    /* Name of column being changed */\n  Token *pNew                     /* New column name */\n){\n  sqlite3 *db = pParse->db;       /* Database connection */\n  Table *pTab;                    /* Table being updated */\n  int iCol;                       /* Index of column being renamed */\n  char *zOld = 0;                 /* Old column name */\n  char *zNew = 0;                 /* New column name */\n  const char *zDb;                /* Name of schema containing the table */\n  int iSchema;                    /* Index of the schema */\n  int bQuote;                     /* True to quote the new name */\n\n  /* Locate the table to be altered */\n  pTab = sqlite3LocateTableItem(pParse, 0, &pSrc->a[0]);\n  if( !pTab ) goto exit_rename_column;\n\n  /* Cannot alter a system table */\n  if( SQLITE_OK!=isAlterableTable(pParse, pTab) ) goto exit_rename_column;\n  if( SQLITE_OK!=isRealTable(pParse, pTab) ) goto exit_rename_column;\n\n  /* Which schema holds the table to be altered */  \n  iSchema = sqlite3SchemaToIndex(db, pTab->pSchema);\n  assert( iSchema>=0 );\n  zDb = db->aDb[iSchema].zDbSName;\n\n#ifndef SQLITE_OMIT_AUTHORIZATION\n  /* Invoke the authorization callback. */\n  if( sqlite3AuthCheck(pParse, SQLITE_ALTER_TABLE, zDb, pTab->zName, 0) ){\n    goto exit_rename_column;\n  }\n#endif\n\n  /* Make sure the old name really is a column name in the table to be\n  ** altered.  Set iCol to be the index of the column being renamed */\n  zOld = sqlite3NameFromToken(db, pOld);\n  if( !zOld ) goto exit_rename_column;\n  for(iCol=0; iCol<pTab->nCol; iCol++){\n    if( 0==sqlite3StrICmp(pTab->aCol[iCol].zName, zOld) ) break;\n  }\n  if( iCol==pTab->nCol ){\n    sqlite3ErrorMsg(pParse, \"no such column: \\\"%s\\\"\", zOld);\n    goto exit_rename_column;\n  }\n\n  /* Do the rename operation using a recursive UPDATE statement that\n  ** uses the sqlite_rename_column() SQL function to compute the new\n  ** CREATE statement text for the sqlite_master table.\n  */\n  sqlite3MayAbort(pParse);\n  zNew = sqlite3NameFromToken(db, pNew);\n  if( !zNew ) goto exit_rename_column;\n  assert( pNew->n>0 );\n  bQuote = sqlite3Isquote(pNew->z[0]);\n  sqlite3NestedParse(pParse, \n      \"UPDATE \\\"%w\\\".%s SET \"\n      \"sql = sqlite_rename_column(sql, type, name, %Q, %Q, %d, %Q, %d, %d) \"\n      \"WHERE name NOT LIKE 'sqliteX_%%' ESCAPE 'X' \"\n      \" AND (type != 'index' OR tbl_name = %Q)\"\n      \" AND sql NOT LIKE 'create virtual%%'\",\n      zDb, MASTER_NAME, \n      zDb, pTab->zName, iCol, zNew, bQuote, iSchema==1,\n      pTab->zName\n  );\n\n  sqlite3NestedParse(pParse, \n      \"UPDATE temp.%s SET \"\n      \"sql = sqlite_rename_column(sql, type, name, %Q, %Q, %d, %Q, %d, 1) \"\n      \"WHERE type IN ('trigger', 'view')\",\n      MASTER_NAME, \n      zDb, pTab->zName, iCol, zNew, bQuote\n  );\n\n  /* Drop and reload the database schema. */\n  renameReloadSchema(pParse, iSchema);\n  renameTestSchema(pParse, zDb, iSchema==1);\n\n exit_rename_column:\n  sqlite3SrcListDelete(db, pSrc);\n  sqlite3DbFree(db, zOld);\n  sqlite3DbFree(db, zNew);\n  return;\n}\n\n/*\n** Each RenameToken object maps an element of the parse tree into\n** the token that generated that element.  The parse tree element\n** might be one of:\n**\n**     *  A pointer to an Expr that represents an ID\n**     *  The name of a table column in Column.zName\n**\n** A list of RenameToken objects can be constructed during parsing.\n** Each new object is created by sqlite3RenameTokenMap().\n** As the parse tree is transformed, the sqlite3RenameTokenRemap()\n** routine is used to keep the mapping current.\n**\n** After the parse finishes, renameTokenFind() routine can be used\n** to look up the actual token value that created some element in\n** the parse tree.\n*/\nstruct RenameToken {\n  void *p;               /* Parse tree element created by token t */\n  Token t;               /* The token that created parse tree element p */\n  RenameToken *pNext;    /* Next is a list of all RenameToken objects */\n};\n\n/*\n** The context of an ALTER TABLE RENAME COLUMN operation that gets passed\n** down into the Walker.\n*/\ntypedef struct RenameCtx RenameCtx;\nstruct RenameCtx {\n  RenameToken *pList;             /* List of tokens to overwrite */\n  int nList;                      /* Number of tokens in pList */\n  int iCol;                       /* Index of column being renamed */\n  Table *pTab;                    /* Table being ALTERed */ \n  const char *zOld;               /* Old column name */\n};\n\n#ifdef SQLITE_DEBUG\n/*\n** This function is only for debugging. It performs two tasks:\n**\n**   1. Checks that pointer pPtr does not already appear in the \n**      rename-token list.\n**\n**   2. Dereferences each pointer in the rename-token list.\n**\n** The second is most effective when debugging under valgrind or\n** address-sanitizer or similar. If any of these pointers no longer \n** point to valid objects, an exception is raised by the memory-checking \n** tool.\n**\n** The point of this is to prevent comparisons of invalid pointer values.\n** Even though this always seems to work, it is undefined according to the\n** C standard. Example of undefined comparison:\n**\n**     sqlite3_free(x);\n**     if( x==y ) ...\n**\n** Technically, as x no longer points into a valid object or to the byte\n** following a valid object, it may not be used in comparison operations.\n*/\nstatic void renameTokenCheckAll(Parse *pParse, void *pPtr){\n  if( pParse->nErr==0 && pParse->db->mallocFailed==0 ){\n    RenameToken *p;\n    u8 i = 0;\n    for(p=pParse->pRename; p; p=p->pNext){\n      if( p->p ){\n        assert( p->p!=pPtr );\n        i += *(u8*)(p->p);\n      }\n    }\n  }\n}\n#else\n# define renameTokenCheckAll(x,y)\n#endif\n\n/*\n** Remember that the parser tree element pPtr was created using\n** the token pToken.\n**\n** In other words, construct a new RenameToken object and add it\n** to the list of RenameToken objects currently being built up\n** in pParse->pRename.\n**\n** The pPtr argument is returned so that this routine can be used\n** with tail recursion in tokenExpr() routine, for a small performance\n** improvement.\n*/\nvoid *sqlite3RenameTokenMap(Parse *pParse, void *pPtr, Token *pToken){\n  RenameToken *pNew;\n  assert( pPtr || pParse->db->mallocFailed );\n  renameTokenCheckAll(pParse, pPtr);\n  if( pParse->eParseMode!=PARSE_MODE_UNMAP ){\n    pNew = sqlite3DbMallocZero(pParse->db, sizeof(RenameToken));\n    if( pNew ){\n      pNew->p = pPtr;\n      pNew->t = *pToken;\n      pNew->pNext = pParse->pRename;\n      pParse->pRename = pNew;\n    }\n  }\n\n  return pPtr;\n}\n\n/*\n** It is assumed that there is already a RenameToken object associated\n** with parse tree element pFrom. This function remaps the associated token\n** to parse tree element pTo.\n*/\nvoid sqlite3RenameTokenRemap(Parse *pParse, void *pTo, void *pFrom){\n  RenameToken *p;\n  renameTokenCheckAll(pParse, pTo);\n  for(p=pParse->pRename; p; p=p->pNext){\n    if( p->p==pFrom ){\n      p->p = pTo;\n      break;\n    }\n  }\n}\n\n/*\n** Walker callback used by sqlite3RenameExprUnmap().\n*/\nstatic int renameUnmapExprCb(Walker *pWalker, Expr *pExpr){\n  Parse *pParse = pWalker->pParse;\n  sqlite3RenameTokenRemap(pParse, 0, (void*)pExpr);\n  return WRC_Continue;\n}\n\n/*\n** Iterate through the Select objects that are part of WITH clauses attached\n** to select statement pSelect.\n*/\nstatic void renameWalkWith(Walker *pWalker, Select *pSelect){\n  if( pSelect->pWith ){\n    int i;\n    for(i=0; i<pSelect->pWith->nCte; i++){\n      Select *p = pSelect->pWith->a[i].pSelect;\n      NameContext sNC;\n      memset(&sNC, 0, sizeof(sNC));\n      sNC.pParse = pWalker->pParse;\n      sqlite3SelectPrep(sNC.pParse, p, &sNC);\n      sqlite3WalkSelect(pWalker, p);\n    }\n  }\n}\n\n/*\n** Walker callback used by sqlite3RenameExprUnmap().\n*/\nstatic int renameUnmapSelectCb(Walker *pWalker, Select *p){\n  Parse *pParse = pWalker->pParse;\n  int i;\n  if( pParse->nErr ) return WRC_Abort;\n  if( p->selFlags & SF_View ) return WRC_Prune;\n  if( ALWAYS(p->pEList) ){\n    ExprList *pList = p->pEList;\n    for(i=0; i<pList->nExpr; i++){\n      if( pList->a[i].zName ){\n        sqlite3RenameTokenRemap(pParse, 0, (void*)pList->a[i].zName);\n      }\n    }\n  }\n  if( ALWAYS(p->pSrc) ){  /* Every Select as a SrcList, even if it is empty */\n    SrcList *pSrc = p->pSrc;\n    for(i=0; i<pSrc->nSrc; i++){\n      sqlite3RenameTokenRemap(pParse, 0, (void*)pSrc->a[i].zName);\n    }\n  }\n\n  renameWalkWith(pWalker, p);\n  return WRC_Continue;\n}\n\n/*\n** Remove all nodes that are part of expression pExpr from the rename list.\n*/\nvoid sqlite3RenameExprUnmap(Parse *pParse, Expr *pExpr){\n  u8 eMode = pParse->eParseMode;\n  Walker sWalker;\n  memset(&sWalker, 0, sizeof(Walker));\n  sWalker.pParse = pParse;\n  sWalker.xExprCallback = renameUnmapExprCb;\n  sWalker.xSelectCallback = renameUnmapSelectCb;\n  pParse->eParseMode = PARSE_MODE_UNMAP;\n  sqlite3WalkExpr(&sWalker, pExpr);\n  pParse->eParseMode = eMode;\n}\n\n/*\n** Remove all nodes that are part of expression-list pEList from the \n** rename list.\n*/\nvoid sqlite3RenameExprlistUnmap(Parse *pParse, ExprList *pEList){\n  if( pEList ){\n    int i;\n    Walker sWalker;\n    memset(&sWalker, 0, sizeof(Walker));\n    sWalker.pParse = pParse;\n    sWalker.xExprCallback = renameUnmapExprCb;\n    sqlite3WalkExprList(&sWalker, pEList);\n    for(i=0; i<pEList->nExpr; i++){\n      sqlite3RenameTokenRemap(pParse, 0, (void*)pEList->a[i].zName);\n    }\n  }\n}\n\n/*\n** Free the list of RenameToken objects given in the second argument\n*/\nstatic void renameTokenFree(sqlite3 *db, RenameToken *pToken){\n  RenameToken *pNext;\n  RenameToken *p;\n  for(p=pToken; p; p=pNext){\n    pNext = p->pNext;\n    sqlite3DbFree(db, p);\n  }\n}\n\n/*\n** Search the Parse object passed as the first argument for a RenameToken\n** object associated with parse tree element pPtr. If found, remove it\n** from the Parse object and add it to the list maintained by the\n** RenameCtx object passed as the second argument.\n*/\nstatic void renameTokenFind(Parse *pParse, struct RenameCtx *pCtx, void *pPtr){\n  RenameToken **pp;\n  assert( pPtr!=0 );\n  for(pp=&pParse->pRename; (*pp); pp=&(*pp)->pNext){\n    if( (*pp)->p==pPtr ){\n      RenameToken *pToken = *pp;\n      *pp = pToken->pNext;\n      pToken->pNext = pCtx->pList;\n      pCtx->pList = pToken;\n      pCtx->nList++;\n      break;\n    }\n  }\n}\n\n/*\n** This is a Walker select callback. It does nothing. It is only required\n** because without a dummy callback, sqlite3WalkExpr() and similar do not\n** descend into sub-select statements.\n*/\nstatic int renameColumnSelectCb(Walker *pWalker, Select *p){\n  if( p->selFlags & SF_View ) return WRC_Prune;\n  renameWalkWith(pWalker, p);\n  return WRC_Continue;\n}\n\n/*\n** This is a Walker expression callback.\n**\n** For every TK_COLUMN node in the expression tree, search to see\n** if the column being references is the column being renamed by an\n** ALTER TABLE statement.  If it is, then attach its associated\n** RenameToken object to the list of RenameToken objects being\n** constructed in RenameCtx object at pWalker->u.pRename.\n*/\nstatic int renameColumnExprCb(Walker *pWalker, Expr *pExpr){\n  RenameCtx *p = pWalker->u.pRename;\n  if( pExpr->op==TK_TRIGGER \n   && pExpr->iColumn==p->iCol \n   && pWalker->pParse->pTriggerTab==p->pTab\n  ){\n    renameTokenFind(pWalker->pParse, p, (void*)pExpr);\n  }else if( pExpr->op==TK_COLUMN \n   && pExpr->iColumn==p->iCol \n   && p->pTab==pExpr->y.pTab\n  ){\n    renameTokenFind(pWalker->pParse, p, (void*)pExpr);\n  }\n  return WRC_Continue;\n}\n\n/*\n** The RenameCtx contains a list of tokens that reference a column that\n** is being renamed by an ALTER TABLE statement.  Return the \"last\"\n** RenameToken in the RenameCtx and remove that RenameToken from the\n** RenameContext.  \"Last\" means the last RenameToken encountered when\n** the input SQL is parsed from left to right.  Repeated calls to this routine\n** return all column name tokens in the order that they are encountered\n** in the SQL statement.\n*/\nstatic RenameToken *renameColumnTokenNext(RenameCtx *pCtx){\n  RenameToken *pBest = pCtx->pList;\n  RenameToken *pToken;\n  RenameToken **pp;\n\n  for(pToken=pBest->pNext; pToken; pToken=pToken->pNext){\n    if( pToken->t.z>pBest->t.z ) pBest = pToken;\n  }\n  for(pp=&pCtx->pList; *pp!=pBest; pp=&(*pp)->pNext);\n  *pp = pBest->pNext;\n\n  return pBest;\n}\n\n/*\n** An error occured while parsing or otherwise processing a database\n** object (either pParse->pNewTable, pNewIndex or pNewTrigger) as part of an\n** ALTER TABLE RENAME COLUMN program. The error message emitted by the\n** sub-routine is currently stored in pParse->zErrMsg. This function\n** adds context to the error message and then stores it in pCtx.\n*/\nstatic void renameColumnParseError(\n  sqlite3_context *pCtx, \n  int bPost,\n  sqlite3_value *pType,\n  sqlite3_value *pObject,\n  Parse *pParse\n){\n  const char *zT = (const char*)sqlite3_value_text(pType);\n  const char *zN = (const char*)sqlite3_value_text(pObject);\n  char *zErr;\n\n  zErr = sqlite3_mprintf(\"error in %s %s%s: %s\", \n      zT, zN, (bPost ? \" after rename\" : \"\"),\n      pParse->zErrMsg\n  );\n  sqlite3_result_error(pCtx, zErr, -1);\n  sqlite3_free(zErr);\n}\n\n/*\n** For each name in the the expression-list pEList (i.e. each\n** pEList->a[i].zName) that matches the string in zOld, extract the \n** corresponding rename-token from Parse object pParse and add it\n** to the RenameCtx pCtx.\n*/\nstatic void renameColumnElistNames(\n  Parse *pParse, \n  RenameCtx *pCtx, \n  ExprList *pEList, \n  const char *zOld\n){\n  if( pEList ){\n    int i;\n    for(i=0; i<pEList->nExpr; i++){\n      char *zName = pEList->a[i].zName;\n      if( 0==sqlite3_stricmp(zName, zOld) ){\n        renameTokenFind(pParse, pCtx, (void*)zName);\n      }\n    }\n  }\n}\n\n/*\n** For each name in the the id-list pIdList (i.e. each pIdList->a[i].zName) \n** that matches the string in zOld, extract the corresponding rename-token \n** from Parse object pParse and add it to the RenameCtx pCtx.\n*/\nstatic void renameColumnIdlistNames(\n  Parse *pParse, \n  RenameCtx *pCtx, \n  IdList *pIdList, \n  const char *zOld\n){\n  if( pIdList ){\n    int i;\n    for(i=0; i<pIdList->nId; i++){\n      char *zName = pIdList->a[i].zName;\n      if( 0==sqlite3_stricmp(zName, zOld) ){\n        renameTokenFind(pParse, pCtx, (void*)zName);\n      }\n    }\n  }\n}\n\n/*\n** Parse the SQL statement zSql using Parse object (*p). The Parse object\n** is initialized by this function before it is used.\n*/\nstatic int renameParseSql(\n  Parse *p,                       /* Memory to use for Parse object */\n  const char *zDb,                /* Name of schema SQL belongs to */\n  int bTable,                     /* 1 -> RENAME TABLE, 0 -> RENAME COLUMN */\n  sqlite3 *db,                    /* Database handle */\n  const char *zSql,               /* SQL to parse */\n  int bTemp                       /* True if SQL is from temp schema */\n){\n  int rc;\n  char *zErr = 0;\n\n  db->init.iDb = bTemp ? 1 : sqlite3FindDbName(db, zDb);\n\n  /* Parse the SQL statement passed as the first argument. If no error\n  ** occurs and the parse does not result in a new table, index or\n  ** trigger object, the database must be corrupt. */\n  memset(p, 0, sizeof(Parse));\n  p->eParseMode = PARSE_MODE_RENAME;\n  p->db = db;\n  p->nQueryLoop = 1;\n  rc = sqlite3RunParser(p, zSql, &zErr);\n  assert( p->zErrMsg==0 );\n  assert( rc!=SQLITE_OK || zErr==0 );\n  p->zErrMsg = zErr;\n  if( db->mallocFailed ) rc = SQLITE_NOMEM;\n  if( rc==SQLITE_OK \n   && p->pNewTable==0 && p->pNewIndex==0 && p->pNewTrigger==0 \n  ){\n    rc = SQLITE_CORRUPT_BKPT;\n  }\n\n#ifdef SQLITE_DEBUG\n  /* Ensure that all mappings in the Parse.pRename list really do map to\n  ** a part of the input string.  */\n  if( rc==SQLITE_OK ){\n    int nSql = sqlite3Strlen30(zSql);\n    RenameToken *pToken;\n    for(pToken=p->pRename; pToken; pToken=pToken->pNext){\n      assert( pToken->t.z>=zSql && &pToken->t.z[pToken->t.n]<=&zSql[nSql] );\n    }\n  }\n#endif\n\n  db->init.iDb = 0;\n  return rc;\n}\n\n/*\n** This function edits SQL statement zSql, replacing each token identified\n** by the linked list pRename with the text of zNew. If argument bQuote is\n** true, then zNew is always quoted first. If no error occurs, the result\n** is loaded into context object pCtx as the result.\n**\n** Or, if an error occurs (i.e. an OOM condition), an error is left in\n** pCtx and an SQLite error code returned.\n*/\nstatic int renameEditSql(\n  sqlite3_context *pCtx,          /* Return result here */\n  RenameCtx *pRename,             /* Rename context */\n  const char *zSql,               /* SQL statement to edit */\n  const char *zNew,               /* New token text */\n  int bQuote                      /* True to always quote token */\n){\n  int nNew = sqlite3Strlen30(zNew);\n  int nSql = sqlite3Strlen30(zSql);\n  sqlite3 *db = sqlite3_context_db_handle(pCtx);\n  int rc = SQLITE_OK;\n  char *zQuot;\n  char *zOut;\n  int nQuot;\n\n  /* Set zQuot to point to a buffer containing a quoted copy of the \n  ** identifier zNew. If the corresponding identifier in the original \n  ** ALTER TABLE statement was quoted (bQuote==1), then set zNew to\n  ** point to zQuot so that all substitutions are made using the\n  ** quoted version of the new column name.  */\n  zQuot = sqlite3MPrintf(db, \"\\\"%w\\\"\", zNew);\n  if( zQuot==0 ){\n    return SQLITE_NOMEM;\n  }else{\n    nQuot = sqlite3Strlen30(zQuot);\n  }\n  if( bQuote ){\n    zNew = zQuot;\n    nNew = nQuot;\n  }\n\n  /* At this point pRename->pList contains a list of RenameToken objects\n  ** corresponding to all tokens in the input SQL that must be replaced\n  ** with the new column name. All that remains is to construct and\n  ** return the edited SQL string. */\n  assert( nQuot>=nNew );\n  zOut = sqlite3DbMallocZero(db, nSql + pRename->nList*nQuot + 1);\n  if( zOut ){\n    int nOut = nSql;\n    memcpy(zOut, zSql, nSql);\n    while( pRename->pList ){\n      int iOff;                   /* Offset of token to replace in zOut */\n      RenameToken *pBest = renameColumnTokenNext(pRename);\n\n      u32 nReplace;\n      const char *zReplace;\n      if( sqlite3IsIdChar(*pBest->t.z) ){\n        nReplace = nNew;\n        zReplace = zNew;\n      }else{\n        nReplace = nQuot;\n        zReplace = zQuot;\n      }\n\n      iOff = pBest->t.z - zSql;\n      if( pBest->t.n!=nReplace ){\n        memmove(&zOut[iOff + nReplace], &zOut[iOff + pBest->t.n], \n            nOut - (iOff + pBest->t.n)\n        );\n        nOut += nReplace - pBest->t.n;\n        zOut[nOut] = '\\0';\n      }\n      memcpy(&zOut[iOff], zReplace, nReplace);\n      sqlite3DbFree(db, pBest);\n    }\n\n    sqlite3_result_text(pCtx, zOut, -1, SQLITE_TRANSIENT);\n    sqlite3DbFree(db, zOut);\n  }else{\n    rc = SQLITE_NOMEM;\n  }\n\n  sqlite3_free(zQuot);\n  return rc;\n}\n\n/*\n** Resolve all symbols in the trigger at pParse->pNewTrigger, assuming\n** it was read from the schema of database zDb. Return SQLITE_OK if \n** successful. Otherwise, return an SQLite error code and leave an error\n** message in the Parse object.\n*/\nstatic int renameResolveTrigger(Parse *pParse, const char *zDb){\n  sqlite3 *db = pParse->db;\n  Trigger *pNew = pParse->pNewTrigger;\n  TriggerStep *pStep;\n  NameContext sNC;\n  int rc = SQLITE_OK;\n\n  memset(&sNC, 0, sizeof(sNC));\n  sNC.pParse = pParse;\n  assert( pNew->pTabSchema );\n  pParse->pTriggerTab = sqlite3FindTable(db, pNew->table, \n      db->aDb[sqlite3SchemaToIndex(db, pNew->pTabSchema)].zDbSName\n  );\n  pParse->eTriggerOp = pNew->op;\n  /* ALWAYS() because if the table of the trigger does not exist, the\n  ** error would have been hit before this point */\n  if( ALWAYS(pParse->pTriggerTab) ){\n    rc = sqlite3ViewGetColumnNames(pParse, pParse->pTriggerTab);\n  }\n\n  /* Resolve symbols in WHEN clause */\n  if( rc==SQLITE_OK && pNew->pWhen ){\n    rc = sqlite3ResolveExprNames(&sNC, pNew->pWhen);\n  }\n\n  for(pStep=pNew->step_list; rc==SQLITE_OK && pStep; pStep=pStep->pNext){\n    if( pStep->pSelect ){\n      sqlite3SelectPrep(pParse, pStep->pSelect, &sNC);\n      if( pParse->nErr ) rc = pParse->rc;\n    }\n    if( rc==SQLITE_OK && pStep->zTarget ){\n      Table *pTarget = sqlite3LocateTable(pParse, 0, pStep->zTarget, zDb);\n      if( pTarget==0 ){\n        rc = SQLITE_ERROR;\n      }else if( SQLITE_OK==(rc = sqlite3ViewGetColumnNames(pParse, pTarget)) ){\n        SrcList sSrc;\n        memset(&sSrc, 0, sizeof(sSrc));\n        sSrc.nSrc = 1;\n        sSrc.a[0].zName = pStep->zTarget;\n        sSrc.a[0].pTab = pTarget;\n        sNC.pSrcList = &sSrc;\n        if( pStep->pWhere ){\n          rc = sqlite3ResolveExprNames(&sNC, pStep->pWhere);\n        }\n        if( rc==SQLITE_OK ){\n          rc = sqlite3ResolveExprListNames(&sNC, pStep->pExprList);\n        }\n        assert( !pStep->pUpsert || (!pStep->pWhere && !pStep->pExprList) );\n        if( pStep->pUpsert ){\n          Upsert *pUpsert = pStep->pUpsert;\n          assert( rc==SQLITE_OK );\n          pUpsert->pUpsertSrc = &sSrc;\n          sNC.uNC.pUpsert = pUpsert;\n          sNC.ncFlags = NC_UUpsert;\n          rc = sqlite3ResolveExprListNames(&sNC, pUpsert->pUpsertTarget);\n          if( rc==SQLITE_OK ){\n            ExprList *pUpsertSet = pUpsert->pUpsertSet;\n            rc = sqlite3ResolveExprListNames(&sNC, pUpsertSet);\n          }\n          if( rc==SQLITE_OK ){\n            rc = sqlite3ResolveExprNames(&sNC, pUpsert->pUpsertWhere);\n          }\n          if( rc==SQLITE_OK ){\n            rc = sqlite3ResolveExprNames(&sNC, pUpsert->pUpsertTargetWhere);\n          }\n          sNC.ncFlags = 0;\n        }\n        sNC.pSrcList = 0;\n      }\n    }\n  }\n  return rc;\n}\n\n/*\n** Invoke sqlite3WalkExpr() or sqlite3WalkSelect() on all Select or Expr\n** objects that are part of the trigger passed as the second argument.\n*/\nstatic void renameWalkTrigger(Walker *pWalker, Trigger *pTrigger){\n  TriggerStep *pStep;\n\n  /* Find tokens to edit in WHEN clause */\n  sqlite3WalkExpr(pWalker, pTrigger->pWhen);\n\n  /* Find tokens to edit in trigger steps */\n  for(pStep=pTrigger->step_list; pStep; pStep=pStep->pNext){\n    sqlite3WalkSelect(pWalker, pStep->pSelect);\n    sqlite3WalkExpr(pWalker, pStep->pWhere);\n    sqlite3WalkExprList(pWalker, pStep->pExprList);\n    if( pStep->pUpsert ){\n      Upsert *pUpsert = pStep->pUpsert;\n      sqlite3WalkExprList(pWalker, pUpsert->pUpsertTarget);\n      sqlite3WalkExprList(pWalker, pUpsert->pUpsertSet);\n      sqlite3WalkExpr(pWalker, pUpsert->pUpsertWhere);\n      sqlite3WalkExpr(pWalker, pUpsert->pUpsertTargetWhere);\n    }\n  }\n}\n\n/*\n** Free the contents of Parse object (*pParse). Do not free the memory\n** occupied by the Parse object itself.\n*/\nstatic void renameParseCleanup(Parse *pParse){\n  sqlite3 *db = pParse->db;\n  Index *pIdx;\n  if( pParse->pVdbe ){\n    sqlite3VdbeFinalize(pParse->pVdbe);\n  }\n  sqlite3DeleteTable(db, pParse->pNewTable);\n  while( (pIdx = pParse->pNewIndex)!=0 ){\n    pParse->pNewIndex = pIdx->pNext;\n    sqlite3FreeIndex(db, pIdx);\n  }\n  sqlite3DeleteTrigger(db, pParse->pNewTrigger);\n  sqlite3DbFree(db, pParse->zErrMsg);\n  renameTokenFree(db, pParse->pRename);\n  sqlite3ParserReset(pParse);\n}\n\n/*\n** SQL function:\n**\n**     sqlite_rename_column(zSql, iCol, bQuote, zNew, zTable, zOld)\n**\n**   0. zSql:     SQL statement to rewrite\n**   1. type:     Type of object (\"table\", \"view\" etc.)\n**   2. object:   Name of object\n**   3. Database: Database name (e.g. \"main\")\n**   4. Table:    Table name\n**   5. iCol:     Index of column to rename\n**   6. zNew:     New column name\n**   7. bQuote:   Non-zero if the new column name should be quoted.\n**   8. bTemp:    True if zSql comes from temp schema\n**\n** Do a column rename operation on the CREATE statement given in zSql.\n** The iCol-th column (left-most is 0) of table zTable is renamed from zCol\n** into zNew.  The name should be quoted if bQuote is true.\n**\n** This function is used internally by the ALTER TABLE RENAME COLUMN command.\n** It is only accessible to SQL created using sqlite3NestedParse().  It is\n** not reachable from ordinary SQL passed into sqlite3_prepare().\n*/\nstatic void renameColumnFunc(\n  sqlite3_context *context,\n  int NotUsed,\n  sqlite3_value **argv\n){\n  sqlite3 *db = sqlite3_context_db_handle(context);\n  RenameCtx sCtx;\n  const char *zSql = (const char*)sqlite3_value_text(argv[0]);\n  const char *zDb = (const char*)sqlite3_value_text(argv[3]);\n  const char *zTable = (const char*)sqlite3_value_text(argv[4]);\n  int iCol = sqlite3_value_int(argv[5]);\n  const char *zNew = (const char*)sqlite3_value_text(argv[6]);\n  int bQuote = sqlite3_value_int(argv[7]);\n  int bTemp = sqlite3_value_int(argv[8]);\n  const char *zOld;\n  int rc;\n  Parse sParse;\n  Walker sWalker;\n  Index *pIdx;\n  int i;\n  Table *pTab;\n#ifndef SQLITE_OMIT_AUTHORIZATION\n  sqlite3_xauth xAuth = db->xAuth;\n#endif\n\n  UNUSED_PARAMETER(NotUsed);\n  if( zSql==0 ) return;\n  if( zTable==0 ) return;\n  if( zNew==0 ) return;\n  if( iCol<0 ) return;\n  sqlite3BtreeEnterAll(db);\n  pTab = sqlite3FindTable(db, zTable, zDb);\n  if( pTab==0 || iCol>=pTab->nCol ){\n    sqlite3BtreeLeaveAll(db);\n    return;\n  }\n  zOld = pTab->aCol[iCol].zName;\n  memset(&sCtx, 0, sizeof(sCtx));\n  sCtx.iCol = ((iCol==pTab->iPKey) ? -1 : iCol);\n\n#ifndef SQLITE_OMIT_AUTHORIZATION\n  db->xAuth = 0;\n#endif\n  rc = renameParseSql(&sParse, zDb, 0, db, zSql, bTemp);\n\n  /* Find tokens that need to be replaced. */\n  memset(&sWalker, 0, sizeof(Walker));\n  sWalker.pParse = &sParse;\n  sWalker.xExprCallback = renameColumnExprCb;\n  sWalker.xSelectCallback = renameColumnSelectCb;\n  sWalker.u.pRename = &sCtx;\n\n  sCtx.pTab = pTab;\n  if( rc!=SQLITE_OK ) goto renameColumnFunc_done;\n  if( sParse.pNewTable ){\n    Select *pSelect = sParse.pNewTable->pSelect;\n    if( pSelect ){\n      pSelect->selFlags &= ~SF_View;\n      sParse.rc = SQLITE_OK;\n      sqlite3SelectPrep(&sParse, pSelect, 0);\n      rc = (db->mallocFailed ? SQLITE_NOMEM : sParse.rc);\n      if( rc==SQLITE_OK ){\n        sqlite3WalkSelect(&sWalker, pSelect);\n      }\n      if( rc!=SQLITE_OK ) goto renameColumnFunc_done;\n    }else{\n      /* A regular table */\n      int bFKOnly = sqlite3_stricmp(zTable, sParse.pNewTable->zName);\n      FKey *pFKey;\n      assert( sParse.pNewTable->pSelect==0 );\n      sCtx.pTab = sParse.pNewTable;\n      if( bFKOnly==0 ){\n        renameTokenFind(\n            &sParse, &sCtx, (void*)sParse.pNewTable->aCol[iCol].zName\n        );\n        if( sCtx.iCol<0 ){\n          renameTokenFind(&sParse, &sCtx, (void*)&sParse.pNewTable->iPKey);\n        }\n        sqlite3WalkExprList(&sWalker, sParse.pNewTable->pCheck);\n        for(pIdx=sParse.pNewTable->pIndex; pIdx; pIdx=pIdx->pNext){\n          sqlite3WalkExprList(&sWalker, pIdx->aColExpr);\n        }\n        for(pIdx=sParse.pNewIndex; pIdx; pIdx=pIdx->pNext){\n          sqlite3WalkExprList(&sWalker, pIdx->aColExpr);\n        }\n      }\n#ifndef SQLITE_OMIT_GENERATED_COLUMNS\n      for(i=0; i<sParse.pNewTable->nCol; i++){\n        sqlite3WalkExpr(&sWalker, sParse.pNewTable->aCol[i].pDflt);\n      }\n#endif\n\n      for(pFKey=sParse.pNewTable->pFKey; pFKey; pFKey=pFKey->pNextFrom){\n        for(i=0; i<pFKey->nCol; i++){\n          if( bFKOnly==0 && pFKey->aCol[i].iFrom==iCol ){\n            renameTokenFind(&sParse, &sCtx, (void*)&pFKey->aCol[i]);\n          }\n          if( 0==sqlite3_stricmp(pFKey->zTo, zTable)\n           && 0==sqlite3_stricmp(pFKey->aCol[i].zCol, zOld)\n          ){\n            renameTokenFind(&sParse, &sCtx, (void*)pFKey->aCol[i].zCol);\n          }\n        }\n      }\n    }\n  }else if( sParse.pNewIndex ){\n    sqlite3WalkExprList(&sWalker, sParse.pNewIndex->aColExpr);\n    sqlite3WalkExpr(&sWalker, sParse.pNewIndex->pPartIdxWhere);\n  }else{\n    /* A trigger */\n    TriggerStep *pStep;\n    rc = renameResolveTrigger(&sParse, (bTemp ? 0 : zDb));\n    if( rc!=SQLITE_OK ) goto renameColumnFunc_done;\n\n    for(pStep=sParse.pNewTrigger->step_list; pStep; pStep=pStep->pNext){\n      if( pStep->zTarget ){ \n        Table *pTarget = sqlite3LocateTable(&sParse, 0, pStep->zTarget, zDb);\n        if( pTarget==pTab ){\n          if( pStep->pUpsert ){\n            ExprList *pUpsertSet = pStep->pUpsert->pUpsertSet;\n            renameColumnElistNames(&sParse, &sCtx, pUpsertSet, zOld);\n          }\n          renameColumnIdlistNames(&sParse, &sCtx, pStep->pIdList, zOld);\n          renameColumnElistNames(&sParse, &sCtx, pStep->pExprList, zOld);\n        }\n      }\n    }\n\n\n    /* Find tokens to edit in UPDATE OF clause */\n    if( sParse.pTriggerTab==pTab ){\n      renameColumnIdlistNames(&sParse, &sCtx,sParse.pNewTrigger->pColumns,zOld);\n    }\n\n    /* Find tokens to edit in various expressions and selects */\n    renameWalkTrigger(&sWalker, sParse.pNewTrigger);\n  }\n\n  assert( rc==SQLITE_OK );\n  rc = renameEditSql(context, &sCtx, zSql, zNew, bQuote);\n\nrenameColumnFunc_done:\n  if( rc!=SQLITE_OK ){\n    if( sParse.zErrMsg ){\n      renameColumnParseError(context, 0, argv[1], argv[2], &sParse);\n    }else{\n      sqlite3_result_error_code(context, rc);\n    }\n  }\n\n  renameParseCleanup(&sParse);\n  renameTokenFree(db, sCtx.pList);\n#ifndef SQLITE_OMIT_AUTHORIZATION\n  db->xAuth = xAuth;\n#endif\n  sqlite3BtreeLeaveAll(db);\n}\n\n/*\n** Walker expression callback used by \"RENAME TABLE\". \n*/\nstatic int renameTableExprCb(Walker *pWalker, Expr *pExpr){\n  RenameCtx *p = pWalker->u.pRename;\n  if( pExpr->op==TK_COLUMN && p->pTab==pExpr->y.pTab ){\n    renameTokenFind(pWalker->pParse, p, (void*)&pExpr->y.pTab);\n  }\n  return WRC_Continue;\n}\n\n/*\n** Walker select callback used by \"RENAME TABLE\". \n*/\nstatic int renameTableSelectCb(Walker *pWalker, Select *pSelect){\n  int i;\n  RenameCtx *p = pWalker->u.pRename;\n  SrcList *pSrc = pSelect->pSrc;\n  if( pSelect->selFlags & SF_View ) return WRC_Prune;\n  if( pSrc==0 ){\n    assert( pWalker->pParse->db->mallocFailed );\n    return WRC_Abort;\n  }\n  for(i=0; i<pSrc->nSrc; i++){\n    struct SrcList_item *pItem = &pSrc->a[i];\n    if( pItem->pTab==p->pTab ){\n      renameTokenFind(pWalker->pParse, p, pItem->zName);\n    }\n  }\n  renameWalkWith(pWalker, pSelect);\n\n  return WRC_Continue;\n}\n\n\n/*\n** This C function implements an SQL user function that is used by SQL code\n** generated by the ALTER TABLE ... RENAME command to modify the definition\n** of any foreign key constraints that use the table being renamed as the \n** parent table. It is passed three arguments:\n**\n**   0: The database containing the table being renamed.\n**   1. type:     Type of object (\"table\", \"view\" etc.)\n**   2. object:   Name of object\n**   3: The complete text of the schema statement being modified,\n**   4: The old name of the table being renamed, and\n**   5: The new name of the table being renamed.\n**   6: True if the schema statement comes from the temp db.\n**\n** It returns the new schema statement. For example:\n**\n** sqlite_rename_table('main', 'CREATE TABLE t1(a REFERENCES t2)','t2','t3',0)\n**       -> 'CREATE TABLE t1(a REFERENCES t3)'\n*/\nstatic void renameTableFunc(\n  sqlite3_context *context,\n  int NotUsed,\n  sqlite3_value **argv\n){\n  sqlite3 *db = sqlite3_context_db_handle(context);\n  const char *zDb = (const char*)sqlite3_value_text(argv[0]);\n  const char *zInput = (const char*)sqlite3_value_text(argv[3]);\n  const char *zOld = (const char*)sqlite3_value_text(argv[4]);\n  const char *zNew = (const char*)sqlite3_value_text(argv[5]);\n  int bTemp = sqlite3_value_int(argv[6]);\n  UNUSED_PARAMETER(NotUsed);\n\n  if( zInput && zOld && zNew ){\n    Parse sParse;\n    int rc;\n    int bQuote = 1;\n    RenameCtx sCtx;\n    Walker sWalker;\n\n#ifndef SQLITE_OMIT_AUTHORIZATION\n    sqlite3_xauth xAuth = db->xAuth;\n    db->xAuth = 0;\n#endif\n\n    sqlite3BtreeEnterAll(db);\n\n    memset(&sCtx, 0, sizeof(RenameCtx));\n    sCtx.pTab = sqlite3FindTable(db, zOld, zDb);\n    memset(&sWalker, 0, sizeof(Walker));\n    sWalker.pParse = &sParse;\n    sWalker.xExprCallback = renameTableExprCb;\n    sWalker.xSelectCallback = renameTableSelectCb;\n    sWalker.u.pRename = &sCtx;\n\n    rc = renameParseSql(&sParse, zDb, 1, db, zInput, bTemp);\n\n    if( rc==SQLITE_OK ){\n      int isLegacy = (db->flags & SQLITE_LegacyAlter);\n      if( sParse.pNewTable ){\n        Table *pTab = sParse.pNewTable;\n\n        if( pTab->pSelect ){\n          if( isLegacy==0 ){\n            Select *pSelect = pTab->pSelect;\n            NameContext sNC;\n            memset(&sNC, 0, sizeof(sNC));\n            sNC.pParse = &sParse;\n\n            assert( pSelect->selFlags & SF_View );\n            pSelect->selFlags &= ~SF_View;\n            sqlite3SelectPrep(&sParse, pTab->pSelect, &sNC);\n            if( sParse.nErr ) rc = sParse.rc;\n            sqlite3WalkSelect(&sWalker, pTab->pSelect);\n          }\n        }else{\n          /* Modify any FK definitions to point to the new table. */\n#ifndef SQLITE_OMIT_FOREIGN_KEY\n          if( isLegacy==0 || (db->flags & SQLITE_ForeignKeys) ){\n            FKey *pFKey;\n            for(pFKey=pTab->pFKey; pFKey; pFKey=pFKey->pNextFrom){\n              if( sqlite3_stricmp(pFKey->zTo, zOld)==0 ){\n                renameTokenFind(&sParse, &sCtx, (void*)pFKey->zTo);\n              }\n            }\n          }\n#endif\n\n          /* If this is the table being altered, fix any table refs in CHECK\n          ** expressions. Also update the name that appears right after the\n          ** \"CREATE [VIRTUAL] TABLE\" bit. */\n          if( sqlite3_stricmp(zOld, pTab->zName)==0 ){\n            sCtx.pTab = pTab;\n            if( isLegacy==0 ){\n              sqlite3WalkExprList(&sWalker, pTab->pCheck);\n            }\n            renameTokenFind(&sParse, &sCtx, pTab->zName);\n          }\n        }\n      }\n\n      else if( sParse.pNewIndex ){\n        renameTokenFind(&sParse, &sCtx, sParse.pNewIndex->zName);\n        if( isLegacy==0 ){\n          sqlite3WalkExpr(&sWalker, sParse.pNewIndex->pPartIdxWhere);\n        }\n      }\n\n#ifndef SQLITE_OMIT_TRIGGER\n      else{\n        Trigger *pTrigger = sParse.pNewTrigger;\n        TriggerStep *pStep;\n        if( 0==sqlite3_stricmp(sParse.pNewTrigger->table, zOld) \n            && sCtx.pTab->pSchema==pTrigger->pTabSchema\n          ){\n          renameTokenFind(&sParse, &sCtx, sParse.pNewTrigger->table);\n        }\n\n        if( isLegacy==0 ){\n          rc = renameResolveTrigger(&sParse, bTemp ? 0 : zDb);\n          if( rc==SQLITE_OK ){\n            renameWalkTrigger(&sWalker, pTrigger);\n            for(pStep=pTrigger->step_list; pStep; pStep=pStep->pNext){\n              if( pStep->zTarget && 0==sqlite3_stricmp(pStep->zTarget, zOld) ){\n                renameTokenFind(&sParse, &sCtx, pStep->zTarget);\n              }\n            }\n          }\n        }\n      }\n#endif\n    }\n\n    if( rc==SQLITE_OK ){\n      rc = renameEditSql(context, &sCtx, zInput, zNew, bQuote);\n    }\n    if( rc!=SQLITE_OK ){\n      if( sParse.zErrMsg ){\n        renameColumnParseError(context, 0, argv[1], argv[2], &sParse);\n      }else{\n        sqlite3_result_error_code(context, rc);\n      }\n    }\n\n    renameParseCleanup(&sParse);\n    renameTokenFree(db, sCtx.pList);\n    sqlite3BtreeLeaveAll(db);\n#ifndef SQLITE_OMIT_AUTHORIZATION\n    db->xAuth = xAuth;\n#endif\n  }\n\n  return;\n}\n\n/*\n** An SQL user function that checks that there are no parse or symbol\n** resolution problems in a CREATE TRIGGER|TABLE|VIEW|INDEX statement.\n** After an ALTER TABLE .. RENAME operation is performed and the schema\n** reloaded, this function is called on each SQL statement in the schema\n** to ensure that it is still usable.\n**\n**   0: Database name (\"main\", \"temp\" etc.).\n**   1: SQL statement.\n**   2: Object type (\"view\", \"table\", \"trigger\" or \"index\").\n**   3: Object name.\n**   4: True if object is from temp schema.\n**\n** Unless it finds an error, this function normally returns NULL. However, it\n** returns integer value 1 if:\n**\n**   * the SQL argument creates a trigger, and\n**   * the table that the trigger is attached to is in database zDb.\n*/\nstatic void renameTableTest(\n  sqlite3_context *context,\n  int NotUsed,\n  sqlite3_value **argv\n){\n  sqlite3 *db = sqlite3_context_db_handle(context);\n  char const *zDb = (const char*)sqlite3_value_text(argv[0]);\n  char const *zInput = (const char*)sqlite3_value_text(argv[1]);\n  int bTemp = sqlite3_value_int(argv[4]);\n  int isLegacy = (db->flags & SQLITE_LegacyAlter);\n\n#ifndef SQLITE_OMIT_AUTHORIZATION\n  sqlite3_xauth xAuth = db->xAuth;\n  db->xAuth = 0;\n#endif\n\n  UNUSED_PARAMETER(NotUsed);\n  if( zDb && zInput ){\n    int rc;\n    Parse sParse;\n    rc = renameParseSql(&sParse, zDb, 1, db, zInput, bTemp);\n    if( rc==SQLITE_OK ){\n      if( isLegacy==0 && sParse.pNewTable && sParse.pNewTable->pSelect ){\n        NameContext sNC;\n        memset(&sNC, 0, sizeof(sNC));\n        sNC.pParse = &sParse;\n        sqlite3SelectPrep(&sParse, sParse.pNewTable->pSelect, &sNC);\n        if( sParse.nErr ) rc = sParse.rc;\n      }\n\n      else if( sParse.pNewTrigger ){\n        if( isLegacy==0 ){\n          rc = renameResolveTrigger(&sParse, bTemp ? 0 : zDb);\n        }\n        if( rc==SQLITE_OK ){\n          int i1 = sqlite3SchemaToIndex(db, sParse.pNewTrigger->pTabSchema);\n          int i2 = sqlite3FindDbName(db, zDb);\n          if( i1==i2 ) sqlite3_result_int(context, 1);\n        }\n      }\n    }\n\n    if( rc!=SQLITE_OK ){\n      renameColumnParseError(context, 1, argv[2], argv[3], &sParse);\n    }\n    renameParseCleanup(&sParse);\n  }\n\n#ifndef SQLITE_OMIT_AUTHORIZATION\n  db->xAuth = xAuth;\n#endif\n}\n\n/*\n** Register built-in functions used to help implement ALTER TABLE\n*/\nvoid sqlite3AlterFunctions(void){\n  static FuncDef aAlterTableFuncs[] = {\n    INTERNAL_FUNCTION(sqlite_rename_column, 9, renameColumnFunc),\n    INTERNAL_FUNCTION(sqlite_rename_table,  7, renameTableFunc),\n    INTERNAL_FUNCTION(sqlite_rename_test,   5, renameTableTest),\n  };\n  sqlite3InsertBuiltinFuncs(aAlterTableFuncs, ArraySize(aAlterTableFuncs));\n}\n#endif  /* SQLITE_ALTER_TABLE */\n", "/*\n** 2001 September 15\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This file contains C code routines that are called by the SQLite parser\n** when syntax rules are reduced.  The routines in this file handle the\n** following kinds of SQL syntax:\n**\n**     CREATE TABLE\n**     DROP TABLE\n**     CREATE INDEX\n**     DROP INDEX\n**     creating ID lists\n**     BEGIN TRANSACTION\n**     COMMIT\n**     ROLLBACK\n*/\n#include \"sqliteInt.h\"\n\n#ifndef SQLITE_OMIT_SHARED_CACHE\n/*\n** The TableLock structure is only used by the sqlite3TableLock() and\n** codeTableLocks() functions.\n*/\nstruct TableLock {\n  int iDb;               /* The database containing the table to be locked */\n  int iTab;              /* The root page of the table to be locked */\n  u8 isWriteLock;        /* True for write lock.  False for a read lock */\n  const char *zLockName; /* Name of the table */\n};\n\n/*\n** Record the fact that we want to lock a table at run-time.  \n**\n** The table to be locked has root page iTab and is found in database iDb.\n** A read or a write lock can be taken depending on isWritelock.\n**\n** This routine just records the fact that the lock is desired.  The\n** code to make the lock occur is generated by a later call to\n** codeTableLocks() which occurs during sqlite3FinishCoding().\n*/\nvoid sqlite3TableLock(\n  Parse *pParse,     /* Parsing context */\n  int iDb,           /* Index of the database containing the table to lock */\n  int iTab,          /* Root page number of the table to be locked */\n  u8 isWriteLock,    /* True for a write lock */\n  const char *zName  /* Name of the table to be locked */\n){\n  Parse *pToplevel = sqlite3ParseToplevel(pParse);\n  int i;\n  int nBytes;\n  TableLock *p;\n  assert( iDb>=0 );\n\n  if( iDb==1 ) return;\n  if( !sqlite3BtreeSharable(pParse->db->aDb[iDb].pBt) ) return;\n  for(i=0; i<pToplevel->nTableLock; i++){\n    p = &pToplevel->aTableLock[i];\n    if( p->iDb==iDb && p->iTab==iTab ){\n      p->isWriteLock = (p->isWriteLock || isWriteLock);\n      return;\n    }\n  }\n\n  nBytes = sizeof(TableLock) * (pToplevel->nTableLock+1);\n  pToplevel->aTableLock =\n      sqlite3DbReallocOrFree(pToplevel->db, pToplevel->aTableLock, nBytes);\n  if( pToplevel->aTableLock ){\n    p = &pToplevel->aTableLock[pToplevel->nTableLock++];\n    p->iDb = iDb;\n    p->iTab = iTab;\n    p->isWriteLock = isWriteLock;\n    p->zLockName = zName;\n  }else{\n    pToplevel->nTableLock = 0;\n    sqlite3OomFault(pToplevel->db);\n  }\n}\n\n/*\n** Code an OP_TableLock instruction for each table locked by the\n** statement (configured by calls to sqlite3TableLock()).\n*/\nstatic void codeTableLocks(Parse *pParse){\n  int i;\n  Vdbe *pVdbe; \n\n  pVdbe = sqlite3GetVdbe(pParse);\n  assert( pVdbe!=0 ); /* sqlite3GetVdbe cannot fail: VDBE already allocated */\n\n  for(i=0; i<pParse->nTableLock; i++){\n    TableLock *p = &pParse->aTableLock[i];\n    int p1 = p->iDb;\n    sqlite3VdbeAddOp4(pVdbe, OP_TableLock, p1, p->iTab, p->isWriteLock,\n                      p->zLockName, P4_STATIC);\n  }\n}\n#else\n  #define codeTableLocks(x)\n#endif\n\n/*\n** Return TRUE if the given yDbMask object is empty - if it contains no\n** 1 bits.  This routine is used by the DbMaskAllZero() and DbMaskNotZero()\n** macros when SQLITE_MAX_ATTACHED is greater than 30.\n*/\n#if SQLITE_MAX_ATTACHED>30\nint sqlite3DbMaskAllZero(yDbMask m){\n  int i;\n  for(i=0; i<sizeof(yDbMask); i++) if( m[i] ) return 0;\n  return 1;\n}\n#endif\n\n/*\n** This routine is called after a single SQL statement has been\n** parsed and a VDBE program to execute that statement has been\n** prepared.  This routine puts the finishing touches on the\n** VDBE program and resets the pParse structure for the next\n** parse.\n**\n** Note that if an error occurred, it might be the case that\n** no VDBE code was generated.\n*/\nvoid sqlite3FinishCoding(Parse *pParse){\n  sqlite3 *db;\n  Vdbe *v;\n\n  assert( pParse->pToplevel==0 );\n  db = pParse->db;\n  if( pParse->nested ) return;\n  if( db->mallocFailed || pParse->nErr ){\n    if( pParse->rc==SQLITE_OK ) pParse->rc = SQLITE_ERROR;\n    return;\n  }\n\n  /* Begin by generating some termination code at the end of the\n  ** vdbe program\n  */\n  v = sqlite3GetVdbe(pParse);\n  assert( !pParse->isMultiWrite \n       || sqlite3VdbeAssertMayAbort(v, pParse->mayAbort));\n  if( v ){\n    sqlite3VdbeAddOp0(v, OP_Halt);\n\n#if SQLITE_USER_AUTHENTICATION\n    if( pParse->nTableLock>0 && db->init.busy==0 ){\n      sqlite3UserAuthInit(db);\n      if( db->auth.authLevel<UAUTH_User ){\n        sqlite3ErrorMsg(pParse, \"user not authenticated\");\n        pParse->rc = SQLITE_AUTH_USER;\n        return;\n      }\n    }\n#endif\n\n    /* The cookie mask contains one bit for each database file open.\n    ** (Bit 0 is for main, bit 1 is for temp, and so forth.)  Bits are\n    ** set for each database that is used.  Generate code to start a\n    ** transaction on each used database and to verify the schema cookie\n    ** on each used database.\n    */\n    if( db->mallocFailed==0 \n     && (DbMaskNonZero(pParse->cookieMask) || pParse->pConstExpr)\n    ){\n      int iDb, i;\n      assert( sqlite3VdbeGetOp(v, 0)->opcode==OP_Init );\n      sqlite3VdbeJumpHere(v, 0);\n      for(iDb=0; iDb<db->nDb; iDb++){\n        Schema *pSchema;\n        if( DbMaskTest(pParse->cookieMask, iDb)==0 ) continue;\n        sqlite3VdbeUsesBtree(v, iDb);\n        pSchema = db->aDb[iDb].pSchema;\n        sqlite3VdbeAddOp4Int(v,\n          OP_Transaction,                    /* Opcode */\n          iDb,                               /* P1 */\n          DbMaskTest(pParse->writeMask,iDb), /* P2 */\n          pSchema->schema_cookie,            /* P3 */\n          pSchema->iGeneration               /* P4 */\n        );\n        if( db->init.busy==0 ) sqlite3VdbeChangeP5(v, 1);\n        VdbeComment((v,\n              \"usesStmtJournal=%d\", pParse->mayAbort && pParse->isMultiWrite));\n      }\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n      for(i=0; i<pParse->nVtabLock; i++){\n        char *vtab = (char *)sqlite3GetVTable(db, pParse->apVtabLock[i]);\n        sqlite3VdbeAddOp4(v, OP_VBegin, 0, 0, 0, vtab, P4_VTAB);\n      }\n      pParse->nVtabLock = 0;\n#endif\n\n      /* Once all the cookies have been verified and transactions opened, \n      ** obtain the required table-locks. This is a no-op unless the \n      ** shared-cache feature is enabled.\n      */\n      codeTableLocks(pParse);\n\n      /* Initialize any AUTOINCREMENT data structures required.\n      */\n      sqlite3AutoincrementBegin(pParse);\n\n      /* Code constant expressions that where factored out of inner loops */\n      if( pParse->pConstExpr ){\n        ExprList *pEL = pParse->pConstExpr;\n        pParse->okConstFactor = 0;\n        for(i=0; i<pEL->nExpr; i++){\n          sqlite3ExprCode(pParse, pEL->a[i].pExpr, pEL->a[i].u.iConstExprReg);\n        }\n      }\n\n      /* Finally, jump back to the beginning of the executable code. */\n      sqlite3VdbeGoto(v, 1);\n    }\n  }\n\n\n  /* Get the VDBE program ready for execution\n  */\n  if( v && pParse->nErr==0 && !db->mallocFailed ){\n    /* A minimum of one cursor is required if autoincrement is used\n    *  See ticket [a696379c1f08866] */\n    assert( pParse->pAinc==0 || pParse->nTab>0 );\n    sqlite3VdbeMakeReady(v, pParse);\n    pParse->rc = SQLITE_DONE;\n  }else{\n    pParse->rc = SQLITE_ERROR;\n  }\n}\n\n/*\n** Run the parser and code generator recursively in order to generate\n** code for the SQL statement given onto the end of the pParse context\n** currently under construction.  When the parser is run recursively\n** this way, the final OP_Halt is not appended and other initialization\n** and finalization steps are omitted because those are handling by the\n** outermost parser.\n**\n** Not everything is nestable.  This facility is designed to permit\n** INSERT, UPDATE, and DELETE operations against SQLITE_MASTER.  Use\n** care if you decide to try to use this routine for some other purposes.\n*/\nvoid sqlite3NestedParse(Parse *pParse, const char *zFormat, ...){\n  va_list ap;\n  char *zSql;\n  char *zErrMsg = 0;\n  sqlite3 *db = pParse->db;\n  char saveBuf[PARSE_TAIL_SZ];\n\n  if( pParse->nErr ) return;\n  assert( pParse->nested<10 );  /* Nesting should only be of limited depth */\n  va_start(ap, zFormat);\n  zSql = sqlite3VMPrintf(db, zFormat, ap);\n  va_end(ap);\n  if( zSql==0 ){\n    /* This can result either from an OOM or because the formatted string\n    ** exceeds SQLITE_LIMIT_LENGTH.  In the latter case, we need to set\n    ** an error */\n    if( !db->mallocFailed ) pParse->rc = SQLITE_TOOBIG;\n    pParse->nErr++;\n    return;\n  }\n  pParse->nested++;\n  memcpy(saveBuf, PARSE_TAIL(pParse), PARSE_TAIL_SZ);\n  memset(PARSE_TAIL(pParse), 0, PARSE_TAIL_SZ);\n  sqlite3RunParser(pParse, zSql, &zErrMsg);\n  sqlite3DbFree(db, zErrMsg);\n  sqlite3DbFree(db, zSql);\n  memcpy(PARSE_TAIL(pParse), saveBuf, PARSE_TAIL_SZ);\n  pParse->nested--;\n}\n\n#if SQLITE_USER_AUTHENTICATION\n/*\n** Return TRUE if zTable is the name of the system table that stores the\n** list of users and their access credentials.\n*/\nint sqlite3UserAuthTable(const char *zTable){\n  return sqlite3_stricmp(zTable, \"sqlite_user\")==0;\n}\n#endif\n\n/*\n** Locate the in-memory structure that describes a particular database\n** table given the name of that table and (optionally) the name of the\n** database containing the table.  Return NULL if not found.\n**\n** If zDatabase is 0, all databases are searched for the table and the\n** first matching table is returned.  (No checking for duplicate table\n** names is done.)  The search order is TEMP first, then MAIN, then any\n** auxiliary databases added using the ATTACH command.\n**\n** See also sqlite3LocateTable().\n*/\nTable *sqlite3FindTable(sqlite3 *db, const char *zName, const char *zDatabase){\n  Table *p = 0;\n  int i;\n\n  /* All mutexes are required for schema access.  Make sure we hold them. */\n  assert( zDatabase!=0 || sqlite3BtreeHoldsAllMutexes(db) );\n#if SQLITE_USER_AUTHENTICATION\n  /* Only the admin user is allowed to know that the sqlite_user table\n  ** exists */\n  if( db->auth.authLevel<UAUTH_Admin && sqlite3UserAuthTable(zName)!=0 ){\n    return 0;\n  }\n#endif\n  while(1){\n    for(i=OMIT_TEMPDB; i<db->nDb; i++){\n      int j = (i<2) ? i^1 : i;   /* Search TEMP before MAIN */\n      if( zDatabase==0 || sqlite3StrICmp(zDatabase, db->aDb[j].zDbSName)==0 ){\n        assert( sqlite3SchemaMutexHeld(db, j, 0) );\n        p = sqlite3HashFind(&db->aDb[j].pSchema->tblHash, zName);\n        if( p ) return p;\n      }\n    }\n    /* Not found.  If the name we were looking for was temp.sqlite_master\n    ** then change the name to sqlite_temp_master and try again. */\n    if( sqlite3StrICmp(zName, MASTER_NAME)!=0 ) break;\n    if( sqlite3_stricmp(zDatabase, db->aDb[1].zDbSName)!=0 ) break;\n    zName = TEMP_MASTER_NAME;\n  }\n  return 0;\n}\n\n/*\n** Locate the in-memory structure that describes a particular database\n** table given the name of that table and (optionally) the name of the\n** database containing the table.  Return NULL if not found.  Also leave an\n** error message in pParse->zErrMsg.\n**\n** The difference between this routine and sqlite3FindTable() is that this\n** routine leaves an error message in pParse->zErrMsg where\n** sqlite3FindTable() does not.\n*/\nTable *sqlite3LocateTable(\n  Parse *pParse,         /* context in which to report errors */\n  u32 flags,             /* LOCATE_VIEW or LOCATE_NOERR */\n  const char *zName,     /* Name of the table we are looking for */\n  const char *zDbase     /* Name of the database.  Might be NULL */\n){\n  Table *p;\n  sqlite3 *db = pParse->db;\n\n  /* Read the database schema. If an error occurs, leave an error message\n  ** and code in pParse and return NULL. */\n  if( (db->mDbFlags & DBFLAG_SchemaKnownOk)==0 \n   && SQLITE_OK!=sqlite3ReadSchema(pParse)\n  ){\n    return 0;\n  }\n\n  p = sqlite3FindTable(db, zName, zDbase);\n  if( p==0 ){\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n    /* If zName is the not the name of a table in the schema created using\n    ** CREATE, then check to see if it is the name of an virtual table that\n    ** can be an eponymous virtual table. */\n    if( pParse->disableVtab==0 ){\n      Module *pMod = (Module*)sqlite3HashFind(&db->aModule, zName);\n      if( pMod==0 && sqlite3_strnicmp(zName, \"pragma_\", 7)==0 ){\n        pMod = sqlite3PragmaVtabRegister(db, zName);\n      }\n      if( pMod && sqlite3VtabEponymousTableInit(pParse, pMod) ){\n        return pMod->pEpoTab;\n      }\n    }\n#endif\n    if( flags & LOCATE_NOERR ) return 0;\n    pParse->checkSchema = 1;\n  }else if( IsVirtual(p) && pParse->disableVtab ){\n    p = 0;\n  }\n\n  if( p==0 ){\n    const char *zMsg = flags & LOCATE_VIEW ? \"no such view\" : \"no such table\";\n    if( zDbase ){\n      sqlite3ErrorMsg(pParse, \"%s: %s.%s\", zMsg, zDbase, zName);\n    }else{\n      sqlite3ErrorMsg(pParse, \"%s: %s\", zMsg, zName);\n    }\n  }\n\n  return p;\n}\n\n/*\n** Locate the table identified by *p.\n**\n** This is a wrapper around sqlite3LocateTable(). The difference between\n** sqlite3LocateTable() and this function is that this function restricts\n** the search to schema (p->pSchema) if it is not NULL. p->pSchema may be\n** non-NULL if it is part of a view or trigger program definition. See\n** sqlite3FixSrcList() for details.\n*/\nTable *sqlite3LocateTableItem(\n  Parse *pParse, \n  u32 flags,\n  struct SrcList_item *p\n){\n  const char *zDb;\n  assert( p->pSchema==0 || p->zDatabase==0 );\n  if( p->pSchema ){\n    int iDb = sqlite3SchemaToIndex(pParse->db, p->pSchema);\n    zDb = pParse->db->aDb[iDb].zDbSName;\n  }else{\n    zDb = p->zDatabase;\n  }\n  return sqlite3LocateTable(pParse, flags, p->zName, zDb);\n}\n\n/*\n** Locate the in-memory structure that describes \n** a particular index given the name of that index\n** and the name of the database that contains the index.\n** Return NULL if not found.\n**\n** If zDatabase is 0, all databases are searched for the\n** table and the first matching index is returned.  (No checking\n** for duplicate index names is done.)  The search order is\n** TEMP first, then MAIN, then any auxiliary databases added\n** using the ATTACH command.\n*/\nIndex *sqlite3FindIndex(sqlite3 *db, const char *zName, const char *zDb){\n  Index *p = 0;\n  int i;\n  /* All mutexes are required for schema access.  Make sure we hold them. */\n  assert( zDb!=0 || sqlite3BtreeHoldsAllMutexes(db) );\n  for(i=OMIT_TEMPDB; i<db->nDb; i++){\n    int j = (i<2) ? i^1 : i;  /* Search TEMP before MAIN */\n    Schema *pSchema = db->aDb[j].pSchema;\n    assert( pSchema );\n    if( zDb && sqlite3StrICmp(zDb, db->aDb[j].zDbSName) ) continue;\n    assert( sqlite3SchemaMutexHeld(db, j, 0) );\n    p = sqlite3HashFind(&pSchema->idxHash, zName);\n    if( p ) break;\n  }\n  return p;\n}\n\n/*\n** Reclaim the memory used by an index\n*/\nvoid sqlite3FreeIndex(sqlite3 *db, Index *p){\n#ifndef SQLITE_OMIT_ANALYZE\n  sqlite3DeleteIndexSamples(db, p);\n#endif\n  sqlite3ExprDelete(db, p->pPartIdxWhere);\n  sqlite3ExprListDelete(db, p->aColExpr);\n  sqlite3DbFree(db, p->zColAff);\n  if( p->isResized ) sqlite3DbFree(db, (void *)p->azColl);\n#ifdef SQLITE_ENABLE_STAT4\n  sqlite3_free(p->aiRowEst);\n#endif\n  sqlite3DbFree(db, p);\n}\n\n/*\n** For the index called zIdxName which is found in the database iDb,\n** unlike that index from its Table then remove the index from\n** the index hash table and free all memory structures associated\n** with the index.\n*/\nvoid sqlite3UnlinkAndDeleteIndex(sqlite3 *db, int iDb, const char *zIdxName){\n  Index *pIndex;\n  Hash *pHash;\n\n  assert( sqlite3SchemaMutexHeld(db, iDb, 0) );\n  pHash = &db->aDb[iDb].pSchema->idxHash;\n  pIndex = sqlite3HashInsert(pHash, zIdxName, 0);\n  if( ALWAYS(pIndex) ){\n    if( pIndex->pTable->pIndex==pIndex ){\n      pIndex->pTable->pIndex = pIndex->pNext;\n    }else{\n      Index *p;\n      /* Justification of ALWAYS();  The index must be on the list of\n      ** indices. */\n      p = pIndex->pTable->pIndex;\n      while( ALWAYS(p) && p->pNext!=pIndex ){ p = p->pNext; }\n      if( ALWAYS(p && p->pNext==pIndex) ){\n        p->pNext = pIndex->pNext;\n      }\n    }\n    sqlite3FreeIndex(db, pIndex);\n  }\n  db->mDbFlags |= DBFLAG_SchemaChange;\n}\n\n/*\n** Look through the list of open database files in db->aDb[] and if\n** any have been closed, remove them from the list.  Reallocate the\n** db->aDb[] structure to a smaller size, if possible.\n**\n** Entry 0 (the \"main\" database) and entry 1 (the \"temp\" database)\n** are never candidates for being collapsed.\n*/\nvoid sqlite3CollapseDatabaseArray(sqlite3 *db){\n  int i, j;\n  for(i=j=2; i<db->nDb; i++){\n    struct Db *pDb = &db->aDb[i];\n    if( pDb->pBt==0 ){\n      sqlite3DbFree(db, pDb->zDbSName);\n      pDb->zDbSName = 0;\n      continue;\n    }\n    if( j<i ){\n      db->aDb[j] = db->aDb[i];\n    }\n    j++;\n  }\n  db->nDb = j;\n  if( db->nDb<=2 && db->aDb!=db->aDbStatic ){\n    memcpy(db->aDbStatic, db->aDb, 2*sizeof(db->aDb[0]));\n    sqlite3DbFree(db, db->aDb);\n    db->aDb = db->aDbStatic;\n  }\n}\n\n/*\n** Reset the schema for the database at index iDb.  Also reset the\n** TEMP schema.  The reset is deferred if db->nSchemaLock is not zero.\n** Deferred resets may be run by calling with iDb<0.\n*/\nvoid sqlite3ResetOneSchema(sqlite3 *db, int iDb){\n  int i;\n  assert( iDb<db->nDb );\n\n  if( iDb>=0 ){\n    assert( sqlite3SchemaMutexHeld(db, iDb, 0) );\n    DbSetProperty(db, iDb, DB_ResetWanted);\n    DbSetProperty(db, 1, DB_ResetWanted);\n    db->mDbFlags &= ~DBFLAG_SchemaKnownOk;\n  }\n\n  if( db->nSchemaLock==0 ){\n    for(i=0; i<db->nDb; i++){\n      if( DbHasProperty(db, i, DB_ResetWanted) ){\n        sqlite3SchemaClear(db->aDb[i].pSchema);\n      }\n    }\n  }\n}\n\n/*\n** Erase all schema information from all attached databases (including\n** \"main\" and \"temp\") for a single database connection.\n*/\nvoid sqlite3ResetAllSchemasOfConnection(sqlite3 *db){\n  int i;\n  sqlite3BtreeEnterAll(db);\n  for(i=0; i<db->nDb; i++){\n    Db *pDb = &db->aDb[i];\n    if( pDb->pSchema ){\n      if( db->nSchemaLock==0 ){\n        sqlite3SchemaClear(pDb->pSchema);\n      }else{\n        DbSetProperty(db, i, DB_ResetWanted);\n      }\n    }\n  }\n  db->mDbFlags &= ~(DBFLAG_SchemaChange|DBFLAG_SchemaKnownOk);\n  sqlite3VtabUnlockList(db);\n  sqlite3BtreeLeaveAll(db);\n  if( db->nSchemaLock==0 ){\n    sqlite3CollapseDatabaseArray(db);\n  }\n}\n\n/*\n** This routine is called when a commit occurs.\n*/\nvoid sqlite3CommitInternalChanges(sqlite3 *db){\n  db->mDbFlags &= ~DBFLAG_SchemaChange;\n}\n\n/*\n** Delete memory allocated for the column names of a table or view (the\n** Table.aCol[] array).\n*/\nvoid sqlite3DeleteColumnNames(sqlite3 *db, Table *pTable){\n  int i;\n  Column *pCol;\n  assert( pTable!=0 );\n  if( (pCol = pTable->aCol)!=0 ){\n    for(i=0; i<pTable->nCol; i++, pCol++){\n      sqlite3DbFree(db, pCol->zName);\n      sqlite3ExprDelete(db, pCol->pDflt);\n      sqlite3DbFree(db, pCol->zColl);\n    }\n    sqlite3DbFree(db, pTable->aCol);\n  }\n}\n\n/*\n** Remove the memory data structures associated with the given\n** Table.  No changes are made to disk by this routine.\n**\n** This routine just deletes the data structure.  It does not unlink\n** the table data structure from the hash table.  But it does destroy\n** memory structures of the indices and foreign keys associated with \n** the table.\n**\n** The db parameter is optional.  It is needed if the Table object \n** contains lookaside memory.  (Table objects in the schema do not use\n** lookaside memory, but some ephemeral Table objects do.)  Or the\n** db parameter can be used with db->pnBytesFreed to measure the memory\n** used by the Table object.\n*/\nstatic void SQLITE_NOINLINE deleteTable(sqlite3 *db, Table *pTable){\n  Index *pIndex, *pNext;\n\n#ifdef SQLITE_DEBUG\n  /* Record the number of outstanding lookaside allocations in schema Tables\n  ** prior to doing any free() operations. Since schema Tables do not use\n  ** lookaside, this number should not change. \n  **\n  ** If malloc has already failed, it may be that it failed while allocating\n  ** a Table object that was going to be marked ephemeral. So do not check\n  ** that no lookaside memory is used in this case either. */\n  int nLookaside = 0;\n  if( db && !db->mallocFailed && (pTable->tabFlags & TF_Ephemeral)==0 ){\n    nLookaside = sqlite3LookasideUsed(db, 0);\n  }\n#endif\n\n  /* Delete all indices associated with this table. */\n  for(pIndex = pTable->pIndex; pIndex; pIndex=pNext){\n    pNext = pIndex->pNext;\n    assert( pIndex->pSchema==pTable->pSchema\n         || (IsVirtual(pTable) && pIndex->idxType!=SQLITE_IDXTYPE_APPDEF) );\n    if( (db==0 || db->pnBytesFreed==0) && !IsVirtual(pTable) ){\n      char *zName = pIndex->zName; \n      TESTONLY ( Index *pOld = ) sqlite3HashInsert(\n         &pIndex->pSchema->idxHash, zName, 0\n      );\n      assert( db==0 || sqlite3SchemaMutexHeld(db, 0, pIndex->pSchema) );\n      assert( pOld==pIndex || pOld==0 );\n    }\n    sqlite3FreeIndex(db, pIndex);\n  }\n\n  /* Delete any foreign keys attached to this table. */\n  sqlite3FkDelete(db, pTable);\n\n  /* Delete the Table structure itself.\n  */\n  sqlite3DeleteColumnNames(db, pTable);\n  sqlite3DbFree(db, pTable->zName);\n  sqlite3DbFree(db, pTable->zColAff);\n  sqlite3SelectDelete(db, pTable->pSelect);\n  sqlite3ExprListDelete(db, pTable->pCheck);\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n  sqlite3VtabClear(db, pTable);\n#endif\n  sqlite3DbFree(db, pTable);\n\n  /* Verify that no lookaside memory was used by schema tables */\n  assert( nLookaside==0 || nLookaside==sqlite3LookasideUsed(db,0) );\n}\nvoid sqlite3DeleteTable(sqlite3 *db, Table *pTable){\n  /* Do not delete the table until the reference count reaches zero. */\n  if( !pTable ) return;\n  if( ((!db || db->pnBytesFreed==0) && (--pTable->nTabRef)>0) ) return;\n  deleteTable(db, pTable);\n}\n\n\n/*\n** Unlink the given table from the hash tables and the delete the\n** table structure with all its indices and foreign keys.\n*/\nvoid sqlite3UnlinkAndDeleteTable(sqlite3 *db, int iDb, const char *zTabName){\n  Table *p;\n  Db *pDb;\n\n  assert( db!=0 );\n  assert( iDb>=0 && iDb<db->nDb );\n  assert( zTabName );\n  assert( sqlite3SchemaMutexHeld(db, iDb, 0) );\n  testcase( zTabName[0]==0 );  /* Zero-length table names are allowed */\n  pDb = &db->aDb[iDb];\n  p = sqlite3HashInsert(&pDb->pSchema->tblHash, zTabName, 0);\n  sqlite3DeleteTable(db, p);\n  db->mDbFlags |= DBFLAG_SchemaChange;\n}\n\n/*\n** Given a token, return a string that consists of the text of that\n** token.  Space to hold the returned string\n** is obtained from sqliteMalloc() and must be freed by the calling\n** function.\n**\n** Any quotation marks (ex:  \"name\", 'name', [name], or `name`) that\n** surround the body of the token are removed.\n**\n** Tokens are often just pointers into the original SQL text and so\n** are not \\000 terminated and are not persistent.  The returned string\n** is \\000 terminated and is persistent.\n*/\nchar *sqlite3NameFromToken(sqlite3 *db, Token *pName){\n  char *zName;\n  if( pName ){\n    zName = sqlite3DbStrNDup(db, (char*)pName->z, pName->n);\n    sqlite3Dequote(zName);\n  }else{\n    zName = 0;\n  }\n  return zName;\n}\n\n/*\n** Open the sqlite_master table stored in database number iDb for\n** writing. The table is opened using cursor 0.\n*/\nvoid sqlite3OpenMasterTable(Parse *p, int iDb){\n  Vdbe *v = sqlite3GetVdbe(p);\n  sqlite3TableLock(p, iDb, MASTER_ROOT, 1, MASTER_NAME);\n  sqlite3VdbeAddOp4Int(v, OP_OpenWrite, 0, MASTER_ROOT, iDb, 5);\n  if( p->nTab==0 ){\n    p->nTab = 1;\n  }\n}\n\n/*\n** Parameter zName points to a nul-terminated buffer containing the name\n** of a database (\"main\", \"temp\" or the name of an attached db). This\n** function returns the index of the named database in db->aDb[], or\n** -1 if the named db cannot be found.\n*/\nint sqlite3FindDbName(sqlite3 *db, const char *zName){\n  int i = -1;         /* Database number */\n  if( zName ){\n    Db *pDb;\n    for(i=(db->nDb-1), pDb=&db->aDb[i]; i>=0; i--, pDb--){\n      if( 0==sqlite3_stricmp(pDb->zDbSName, zName) ) break;\n      /* \"main\" is always an acceptable alias for the primary database\n      ** even if it has been renamed using SQLITE_DBCONFIG_MAINDBNAME. */\n      if( i==0 && 0==sqlite3_stricmp(\"main\", zName) ) break;\n    }\n  }\n  return i;\n}\n\n/*\n** The token *pName contains the name of a database (either \"main\" or\n** \"temp\" or the name of an attached db). This routine returns the\n** index of the named database in db->aDb[], or -1 if the named db \n** does not exist.\n*/\nint sqlite3FindDb(sqlite3 *db, Token *pName){\n  int i;                               /* Database number */\n  char *zName;                         /* Name we are searching for */\n  zName = sqlite3NameFromToken(db, pName);\n  i = sqlite3FindDbName(db, zName);\n  sqlite3DbFree(db, zName);\n  return i;\n}\n\n/* The table or view or trigger name is passed to this routine via tokens\n** pName1 and pName2. If the table name was fully qualified, for example:\n**\n** CREATE TABLE xxx.yyy (...);\n** \n** Then pName1 is set to \"xxx\" and pName2 \"yyy\". On the other hand if\n** the table name is not fully qualified, i.e.:\n**\n** CREATE TABLE yyy(...);\n**\n** Then pName1 is set to \"yyy\" and pName2 is \"\".\n**\n** This routine sets the *ppUnqual pointer to point at the token (pName1 or\n** pName2) that stores the unqualified table name.  The index of the\n** database \"xxx\" is returned.\n*/\nint sqlite3TwoPartName(\n  Parse *pParse,      /* Parsing and code generating context */\n  Token *pName1,      /* The \"xxx\" in the name \"xxx.yyy\" or \"xxx\" */\n  Token *pName2,      /* The \"yyy\" in the name \"xxx.yyy\" */\n  Token **pUnqual     /* Write the unqualified object name here */\n){\n  int iDb;                    /* Database holding the object */\n  sqlite3 *db = pParse->db;\n\n  assert( pName2!=0 );\n  if( pName2->n>0 ){\n    if( db->init.busy ) {\n      sqlite3ErrorMsg(pParse, \"corrupt database\");\n      return -1;\n    }\n    *pUnqual = pName2;\n    iDb = sqlite3FindDb(db, pName1);\n    if( iDb<0 ){\n      sqlite3ErrorMsg(pParse, \"unknown database %T\", pName1);\n      return -1;\n    }\n  }else{\n    assert( db->init.iDb==0 || db->init.busy || IN_RENAME_OBJECT\n             || (db->mDbFlags & DBFLAG_Vacuum)!=0);\n    iDb = db->init.iDb;\n    *pUnqual = pName1;\n  }\n  return iDb;\n}\n\n/*\n** True if PRAGMA writable_schema is ON\n*/\nint sqlite3WritableSchema(sqlite3 *db){\n  testcase( (db->flags&(SQLITE_WriteSchema|SQLITE_Defensive))==0 );\n  testcase( (db->flags&(SQLITE_WriteSchema|SQLITE_Defensive))==\n               SQLITE_WriteSchema );\n  testcase( (db->flags&(SQLITE_WriteSchema|SQLITE_Defensive))==\n               SQLITE_Defensive );\n  testcase( (db->flags&(SQLITE_WriteSchema|SQLITE_Defensive))==\n               (SQLITE_WriteSchema|SQLITE_Defensive) );\n  return (db->flags&(SQLITE_WriteSchema|SQLITE_Defensive))==SQLITE_WriteSchema;\n}\n\n/*\n** This routine is used to check if the UTF-8 string zName is a legal\n** unqualified name for a new schema object (table, index, view or\n** trigger). All names are legal except those that begin with the string\n** \"sqlite_\" (in upper, lower or mixed case). This portion of the namespace\n** is reserved for internal use.\n**\n** When parsing the sqlite_master table, this routine also checks to\n** make sure the \"type\", \"name\", and \"tbl_name\" columns are consistent\n** with the SQL.\n*/\nint sqlite3CheckObjectName(\n  Parse *pParse,            /* Parsing context */\n  const char *zName,        /* Name of the object to check */\n  const char *zType,        /* Type of this object */\n  const char *zTblName      /* Parent table name for triggers and indexes */\n){\n  sqlite3 *db = pParse->db;\n  if( sqlite3WritableSchema(db) || db->init.imposterTable ){\n    /* Skip these error checks for writable_schema=ON */\n    return SQLITE_OK;\n  }\n  if( db->init.busy ){\n    if( sqlite3_stricmp(zType, db->init.azInit[0])\n     || sqlite3_stricmp(zName, db->init.azInit[1])\n     || sqlite3_stricmp(zTblName, db->init.azInit[2])\n    ){\n      if( sqlite3Config.bExtraSchemaChecks ){\n        sqlite3ErrorMsg(pParse, \"\"); /* corruptSchema() will supply the error */\n        return SQLITE_ERROR;\n      }\n    }\n  }else{\n    if( (pParse->nested==0 && 0==sqlite3StrNICmp(zName, \"sqlite_\", 7))\n     || (sqlite3ReadOnlyShadowTables(db) && sqlite3ShadowTableName(db, zName))\n    ){\n      sqlite3ErrorMsg(pParse, \"object name reserved for internal use: %s\",\n                      zName);\n      return SQLITE_ERROR;\n    }\n\n  }\n  return SQLITE_OK;\n}\n\n/*\n** Return the PRIMARY KEY index of a table\n*/\nIndex *sqlite3PrimaryKeyIndex(Table *pTab){\n  Index *p;\n  for(p=pTab->pIndex; p && !IsPrimaryKeyIndex(p); p=p->pNext){}\n  return p;\n}\n\n/*\n** Convert an table column number into a index column number.  That is,\n** for the column iCol in the table (as defined by the CREATE TABLE statement)\n** find the (first) offset of that column in index pIdx.  Or return -1\n** if column iCol is not used in index pIdx.\n*/\ni16 sqlite3TableColumnToIndex(Index *pIdx, i16 iCol){\n  int i;\n  for(i=0; i<pIdx->nColumn; i++){\n    if( iCol==pIdx->aiColumn[i] ) return i;\n  }\n  return -1;\n}\n\n#ifndef SQLITE_OMIT_GENERATED_COLUMNS\n/* Convert a storage column number into a table column number.\n**\n** The storage column number (0,1,2,....) is the index of the value\n** as it appears in the record on disk.  The true column number\n** is the index (0,1,2,...) of the column in the CREATE TABLE statement.\n**\n** The storage column number is less than the table column number if\n** and only there are VIRTUAL columns to the left.\n**\n** If SQLITE_OMIT_GENERATED_COLUMNS, this routine is a no-op macro.\n*/\ni16 sqlite3StorageColumnToTable(Table *pTab, i16 iCol){\n  if( pTab->tabFlags & TF_HasVirtual ){\n    int i;\n    for(i=0; i<=iCol; i++){\n      if( pTab->aCol[i].colFlags & COLFLAG_VIRTUAL ) iCol++;\n    }\n  }\n  return iCol;\n}\n#endif\n\n#ifndef SQLITE_OMIT_GENERATED_COLUMNS\n/* Convert a table column number into a storage column number.\n**\n** The storage column number (0,1,2,....) is the index of the value\n** as it appears in the record on disk.  Or, if the input column is\n** the N-th virtual column (zero-based) then the storage number is\n** the number of non-virtual columns in the table plus N.  \n**\n** The true column number is the index (0,1,2,...) of the column in\n** the CREATE TABLE statement.\n**\n** If the input column is a VIRTUAL column, then it should not appear\n** in storage.  But the value sometimes is cached in registers that\n** follow the range of registers used to construct storage.  This\n** avoids computing the same VIRTUAL column multiple times, and provides\n** values for use by OP_Param opcodes in triggers.  Hence, if the\n** input column is a VIRTUAL table, put it after all the other columns.\n**\n** In the following, N means \"normal column\", S means STORED, and\n** V means VIRTUAL.  Suppose the CREATE TABLE has columns like this:\n**\n**        CREATE TABLE ex(N,S,V,N,S,V,N,S,V);\n**                     -- 0 1 2 3 4 5 6 7 8\n**\n** Then the mapping from this function is as follows:\n**\n**    INPUTS:     0 1 2 3 4 5 6 7 8\n**    OUTPUTS:    0 1 6 2 3 7 4 5 8\n**\n** So, in other words, this routine shifts all the virtual columns to\n** the end.\n**\n** If SQLITE_OMIT_GENERATED_COLUMNS then there are no virtual columns and\n** this routine is a no-op macro.  If the pTab does not have any virtual\n** columns, then this routine is no-op that always return iCol.  If iCol\n** is negative (indicating the ROWID column) then this routine return iCol.\n*/\ni16 sqlite3TableColumnToStorage(Table *pTab, i16 iCol){\n  int i;\n  i16 n;\n  assert( iCol<pTab->nCol );\n  if( (pTab->tabFlags & TF_HasVirtual)==0 || iCol<0 ) return iCol;\n  for(i=0, n=0; i<iCol; i++){\n    if( (pTab->aCol[i].colFlags & COLFLAG_VIRTUAL)==0 ) n++;\n  }\n  if( pTab->aCol[i].colFlags & COLFLAG_VIRTUAL ){\n    /* iCol is a virtual column itself */\n    return pTab->nNVCol + i - n;\n  }else{\n    /* iCol is a normal or stored column */\n    return n;\n  }\n}\n#endif\n\n/*\n** Begin constructing a new table representation in memory.  This is\n** the first of several action routines that get called in response\n** to a CREATE TABLE statement.  In particular, this routine is called\n** after seeing tokens \"CREATE\" and \"TABLE\" and the table name. The isTemp\n** flag is true if the table should be stored in the auxiliary database\n** file instead of in the main database file.  This is normally the case\n** when the \"TEMP\" or \"TEMPORARY\" keyword occurs in between\n** CREATE and TABLE.\n**\n** The new table record is initialized and put in pParse->pNewTable.\n** As more of the CREATE TABLE statement is parsed, additional action\n** routines will be called to add more information to this record.\n** At the end of the CREATE TABLE statement, the sqlite3EndTable() routine\n** is called to complete the construction of the new table record.\n*/\nvoid sqlite3StartTable(\n  Parse *pParse,   /* Parser context */\n  Token *pName1,   /* First part of the name of the table or view */\n  Token *pName2,   /* Second part of the name of the table or view */\n  int isTemp,      /* True if this is a TEMP table */\n  int isView,      /* True if this is a VIEW */\n  int isVirtual,   /* True if this is a VIRTUAL table */\n  int noErr        /* Do nothing if table already exists */\n){\n  Table *pTable;\n  char *zName = 0; /* The name of the new table */\n  sqlite3 *db = pParse->db;\n  Vdbe *v;\n  int iDb;         /* Database number to create the table in */\n  Token *pName;    /* Unqualified name of the table to create */\n\n  if( db->init.busy && db->init.newTnum==1 ){\n    /* Special case:  Parsing the sqlite_master or sqlite_temp_master schema */\n    iDb = db->init.iDb;\n    zName = sqlite3DbStrDup(db, SCHEMA_TABLE(iDb));\n    pName = pName1;\n  }else{\n    /* The common case */\n    iDb = sqlite3TwoPartName(pParse, pName1, pName2, &pName);\n    if( iDb<0 ) return;\n    if( !OMIT_TEMPDB && isTemp && pName2->n>0 && iDb!=1 ){\n      /* If creating a temp table, the name may not be qualified. Unless \n      ** the database name is \"temp\" anyway.  */\n      sqlite3ErrorMsg(pParse, \"temporary table name must be unqualified\");\n      return;\n    }\n    if( !OMIT_TEMPDB && isTemp ) iDb = 1;\n    zName = sqlite3NameFromToken(db, pName);\n    if( IN_RENAME_OBJECT ){\n      sqlite3RenameTokenMap(pParse, (void*)zName, pName);\n    }\n  }\n  pParse->sNameToken = *pName;\n  if( zName==0 ) return;\n  if( sqlite3CheckObjectName(pParse, zName, isView?\"view\":\"table\", zName) ){\n    goto begin_table_error;\n  }\n  if( db->init.iDb==1 ) isTemp = 1;\n#ifndef SQLITE_OMIT_AUTHORIZATION\n  assert( isTemp==0 || isTemp==1 );\n  assert( isView==0 || isView==1 );\n  {\n    static const u8 aCode[] = {\n       SQLITE_CREATE_TABLE,\n       SQLITE_CREATE_TEMP_TABLE,\n       SQLITE_CREATE_VIEW,\n       SQLITE_CREATE_TEMP_VIEW\n    };\n    char *zDb = db->aDb[iDb].zDbSName;\n    if( sqlite3AuthCheck(pParse, SQLITE_INSERT, SCHEMA_TABLE(isTemp), 0, zDb) ){\n      goto begin_table_error;\n    }\n    if( !isVirtual && sqlite3AuthCheck(pParse, (int)aCode[isTemp+2*isView],\n                                       zName, 0, zDb) ){\n      goto begin_table_error;\n    }\n  }\n#endif\n\n  /* Make sure the new table name does not collide with an existing\n  ** index or table name in the same database.  Issue an error message if\n  ** it does. The exception is if the statement being parsed was passed\n  ** to an sqlite3_declare_vtab() call. In that case only the column names\n  ** and types will be used, so there is no need to test for namespace\n  ** collisions.\n  */\n  if( !IN_SPECIAL_PARSE ){\n    char *zDb = db->aDb[iDb].zDbSName;\n    if( SQLITE_OK!=sqlite3ReadSchema(pParse) ){\n      goto begin_table_error;\n    }\n    pTable = sqlite3FindTable(db, zName, zDb);\n    if( pTable ){\n      if( !noErr ){\n        sqlite3ErrorMsg(pParse, \"table %T already exists\", pName);\n      }else{\n        assert( !db->init.busy || CORRUPT_DB );\n        sqlite3CodeVerifySchema(pParse, iDb);\n      }\n      goto begin_table_error;\n    }\n    if( sqlite3FindIndex(db, zName, zDb)!=0 ){\n      sqlite3ErrorMsg(pParse, \"there is already an index named %s\", zName);\n      goto begin_table_error;\n    }\n  }\n\n  pTable = sqlite3DbMallocZero(db, sizeof(Table));\n  if( pTable==0 ){\n    assert( db->mallocFailed );\n    pParse->rc = SQLITE_NOMEM_BKPT;\n    pParse->nErr++;\n    goto begin_table_error;\n  }\n  pTable->zName = zName;\n  pTable->iPKey = -1;\n  pTable->pSchema = db->aDb[iDb].pSchema;\n  pTable->nTabRef = 1;\n#ifdef SQLITE_DEFAULT_ROWEST\n  pTable->nRowLogEst = sqlite3LogEst(SQLITE_DEFAULT_ROWEST);\n#else\n  pTable->nRowLogEst = 200; assert( 200==sqlite3LogEst(1048576) );\n#endif\n  assert( pParse->pNewTable==0 );\n  pParse->pNewTable = pTable;\n\n  /* If this is the magic sqlite_sequence table used by autoincrement,\n  ** then record a pointer to this table in the main database structure\n  ** so that INSERT can find the table easily.\n  */\n#ifndef SQLITE_OMIT_AUTOINCREMENT\n  if( !pParse->nested && strcmp(zName, \"sqlite_sequence\")==0 ){\n    assert( sqlite3SchemaMutexHeld(db, iDb, 0) );\n    pTable->pSchema->pSeqTab = pTable;\n  }\n#endif\n\n  /* Begin generating the code that will insert the table record into\n  ** the SQLITE_MASTER table.  Note in particular that we must go ahead\n  ** and allocate the record number for the table entry now.  Before any\n  ** PRIMARY KEY or UNIQUE keywords are parsed.  Those keywords will cause\n  ** indices to be created and the table record must come before the \n  ** indices.  Hence, the record number for the table must be allocated\n  ** now.\n  */\n  if( !db->init.busy && (v = sqlite3GetVdbe(pParse))!=0 ){\n    int addr1;\n    int fileFormat;\n    int reg1, reg2, reg3;\n    /* nullRow[] is an OP_Record encoding of a row containing 5 NULLs */\n    static const char nullRow[] = { 6, 0, 0, 0, 0, 0 };\n    sqlite3BeginWriteOperation(pParse, 1, iDb);\n\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n    if( isVirtual ){\n      sqlite3VdbeAddOp0(v, OP_VBegin);\n    }\n#endif\n\n    /* If the file format and encoding in the database have not been set, \n    ** set them now.\n    */\n    reg1 = pParse->regRowid = ++pParse->nMem;\n    reg2 = pParse->regRoot = ++pParse->nMem;\n    reg3 = ++pParse->nMem;\n    sqlite3VdbeAddOp3(v, OP_ReadCookie, iDb, reg3, BTREE_FILE_FORMAT);\n    sqlite3VdbeUsesBtree(v, iDb);\n    addr1 = sqlite3VdbeAddOp1(v, OP_If, reg3); VdbeCoverage(v);\n    fileFormat = (db->flags & SQLITE_LegacyFileFmt)!=0 ?\n                  1 : SQLITE_MAX_FILE_FORMAT;\n    sqlite3VdbeAddOp3(v, OP_SetCookie, iDb, BTREE_FILE_FORMAT, fileFormat);\n    sqlite3VdbeAddOp3(v, OP_SetCookie, iDb, BTREE_TEXT_ENCODING, ENC(db));\n    sqlite3VdbeJumpHere(v, addr1);\n\n    /* This just creates a place-holder record in the sqlite_master table.\n    ** The record created does not contain anything yet.  It will be replaced\n    ** by the real entry in code generated at sqlite3EndTable().\n    **\n    ** The rowid for the new entry is left in register pParse->regRowid.\n    ** The root page number of the new table is left in reg pParse->regRoot.\n    ** The rowid and root page number values are needed by the code that\n    ** sqlite3EndTable will generate.\n    */\n#if !defined(SQLITE_OMIT_VIEW) || !defined(SQLITE_OMIT_VIRTUALTABLE)\n    if( isView || isVirtual ){\n      sqlite3VdbeAddOp2(v, OP_Integer, 0, reg2);\n    }else\n#endif\n    {\n      pParse->addrCrTab =\n         sqlite3VdbeAddOp3(v, OP_CreateBtree, iDb, reg2, BTREE_INTKEY);\n    }\n    sqlite3OpenMasterTable(pParse, iDb);\n    sqlite3VdbeAddOp2(v, OP_NewRowid, 0, reg1);\n    sqlite3VdbeAddOp4(v, OP_Blob, 6, reg3, 0, nullRow, P4_STATIC);\n    sqlite3VdbeAddOp3(v, OP_Insert, 0, reg3, reg1);\n    sqlite3VdbeChangeP5(v, OPFLAG_APPEND);\n    sqlite3VdbeAddOp0(v, OP_Close);\n  }\n\n  /* Normal (non-error) return. */\n  return;\n\n  /* If an error occurs, we jump here */\nbegin_table_error:\n  sqlite3DbFree(db, zName);\n  return;\n}\n\n/* Set properties of a table column based on the (magical)\n** name of the column.\n*/\n#if SQLITE_ENABLE_HIDDEN_COLUMNS\nvoid sqlite3ColumnPropertiesFromName(Table *pTab, Column *pCol){\n  if( sqlite3_strnicmp(pCol->zName, \"__hidden__\", 10)==0 ){\n    pCol->colFlags |= COLFLAG_HIDDEN;\n  }else if( pTab && pCol!=pTab->aCol && (pCol[-1].colFlags & COLFLAG_HIDDEN) ){\n    pTab->tabFlags |= TF_OOOHidden;\n  }\n}\n#endif\n\n\n/*\n** Add a new column to the table currently being constructed.\n**\n** The parser calls this routine once for each column declaration\n** in a CREATE TABLE statement.  sqlite3StartTable() gets called\n** first to get things going.  Then this routine is called for each\n** column.\n*/\nvoid sqlite3AddColumn(Parse *pParse, Token *pName, Token *pType){\n  Table *p;\n  int i;\n  char *z;\n  char *zType;\n  Column *pCol;\n  sqlite3 *db = pParse->db;\n  if( (p = pParse->pNewTable)==0 ) return;\n  if( p->nCol+1>db->aLimit[SQLITE_LIMIT_COLUMN] ){\n    sqlite3ErrorMsg(pParse, \"too many columns on %s\", p->zName);\n    return;\n  }\n  z = sqlite3DbMallocRaw(db, pName->n + pType->n + 2);\n  if( z==0 ) return;\n  if( IN_RENAME_OBJECT ) sqlite3RenameTokenMap(pParse, (void*)z, pName);\n  memcpy(z, pName->z, pName->n);\n  z[pName->n] = 0;\n  sqlite3Dequote(z);\n  for(i=0; i<p->nCol; i++){\n    if( sqlite3_stricmp(z, p->aCol[i].zName)==0 ){\n      sqlite3ErrorMsg(pParse, \"duplicate column name: %s\", z);\n      sqlite3DbFree(db, z);\n      return;\n    }\n  }\n  if( (p->nCol & 0x7)==0 ){\n    Column *aNew;\n    aNew = sqlite3DbRealloc(db,p->aCol,(p->nCol+8)*sizeof(p->aCol[0]));\n    if( aNew==0 ){\n      sqlite3DbFree(db, z);\n      return;\n    }\n    p->aCol = aNew;\n  }\n  pCol = &p->aCol[p->nCol];\n  memset(pCol, 0, sizeof(p->aCol[0]));\n  pCol->zName = z;\n  sqlite3ColumnPropertiesFromName(p, pCol);\n \n  if( pType->n==0 ){\n    /* If there is no type specified, columns have the default affinity\n    ** 'BLOB' with a default size of 4 bytes. */\n    pCol->affinity = SQLITE_AFF_BLOB;\n    pCol->szEst = 1;\n#ifdef SQLITE_ENABLE_SORTER_REFERENCES\n    if( 4>=sqlite3GlobalConfig.szSorterRef ){\n      pCol->colFlags |= COLFLAG_SORTERREF;\n    }\n#endif\n  }else{\n    zType = z + sqlite3Strlen30(z) + 1;\n    memcpy(zType, pType->z, pType->n);\n    zType[pType->n] = 0;\n    sqlite3Dequote(zType);\n    pCol->affinity = sqlite3AffinityType(zType, pCol);\n    pCol->colFlags |= COLFLAG_HASTYPE;\n  }\n  p->nCol++;\n  p->nNVCol++;\n  pParse->constraintName.n = 0;\n}\n\n/*\n** This routine is called by the parser while in the middle of\n** parsing a CREATE TABLE statement.  A \"NOT NULL\" constraint has\n** been seen on a column.  This routine sets the notNull flag on\n** the column currently under construction.\n*/\nvoid sqlite3AddNotNull(Parse *pParse, int onError){\n  Table *p;\n  Column *pCol;\n  p = pParse->pNewTable;\n  if( p==0 || NEVER(p->nCol<1) ) return;\n  pCol = &p->aCol[p->nCol-1];\n  pCol->notNull = (u8)onError;\n  p->tabFlags |= TF_HasNotNull;\n\n  /* Set the uniqNotNull flag on any UNIQUE or PK indexes already created\n  ** on this column.  */\n  if( pCol->colFlags & COLFLAG_UNIQUE ){\n    Index *pIdx;\n    for(pIdx=p->pIndex; pIdx; pIdx=pIdx->pNext){\n      assert( pIdx->nKeyCol==1 && pIdx->onError!=OE_None );\n      if( pIdx->aiColumn[0]==p->nCol-1 ){\n        pIdx->uniqNotNull = 1;\n      }\n    }\n  }\n}\n\n/*\n** Scan the column type name zType (length nType) and return the\n** associated affinity type.\n**\n** This routine does a case-independent search of zType for the \n** substrings in the following table. If one of the substrings is\n** found, the corresponding affinity is returned. If zType contains\n** more than one of the substrings, entries toward the top of \n** the table take priority. For example, if zType is 'BLOBINT', \n** SQLITE_AFF_INTEGER is returned.\n**\n** Substring     | Affinity\n** --------------------------------\n** 'INT'         | SQLITE_AFF_INTEGER\n** 'CHAR'        | SQLITE_AFF_TEXT\n** 'CLOB'        | SQLITE_AFF_TEXT\n** 'TEXT'        | SQLITE_AFF_TEXT\n** 'BLOB'        | SQLITE_AFF_BLOB\n** 'REAL'        | SQLITE_AFF_REAL\n** 'FLOA'        | SQLITE_AFF_REAL\n** 'DOUB'        | SQLITE_AFF_REAL\n**\n** If none of the substrings in the above table are found,\n** SQLITE_AFF_NUMERIC is returned.\n*/\nchar sqlite3AffinityType(const char *zIn, Column *pCol){\n  u32 h = 0;\n  char aff = SQLITE_AFF_NUMERIC;\n  const char *zChar = 0;\n\n  assert( zIn!=0 );\n  while( zIn[0] ){\n    h = (h<<8) + sqlite3UpperToLower[(*zIn)&0xff];\n    zIn++;\n    if( h==(('c'<<24)+('h'<<16)+('a'<<8)+'r') ){             /* CHAR */\n      aff = SQLITE_AFF_TEXT;\n      zChar = zIn;\n    }else if( h==(('c'<<24)+('l'<<16)+('o'<<8)+'b') ){       /* CLOB */\n      aff = SQLITE_AFF_TEXT;\n    }else if( h==(('t'<<24)+('e'<<16)+('x'<<8)+'t') ){       /* TEXT */\n      aff = SQLITE_AFF_TEXT;\n    }else if( h==(('b'<<24)+('l'<<16)+('o'<<8)+'b')          /* BLOB */\n        && (aff==SQLITE_AFF_NUMERIC || aff==SQLITE_AFF_REAL) ){\n      aff = SQLITE_AFF_BLOB;\n      if( zIn[0]=='(' ) zChar = zIn;\n#ifndef SQLITE_OMIT_FLOATING_POINT\n    }else if( h==(('r'<<24)+('e'<<16)+('a'<<8)+'l')          /* REAL */\n        && aff==SQLITE_AFF_NUMERIC ){\n      aff = SQLITE_AFF_REAL;\n    }else if( h==(('f'<<24)+('l'<<16)+('o'<<8)+'a')          /* FLOA */\n        && aff==SQLITE_AFF_NUMERIC ){\n      aff = SQLITE_AFF_REAL;\n    }else if( h==(('d'<<24)+('o'<<16)+('u'<<8)+'b')          /* DOUB */\n        && aff==SQLITE_AFF_NUMERIC ){\n      aff = SQLITE_AFF_REAL;\n#endif\n    }else if( (h&0x00FFFFFF)==(('i'<<16)+('n'<<8)+'t') ){    /* INT */\n      aff = SQLITE_AFF_INTEGER;\n      break;\n    }\n  }\n\n  /* If pCol is not NULL, store an estimate of the field size.  The\n  ** estimate is scaled so that the size of an integer is 1.  */\n  if( pCol ){\n    int v = 0;   /* default size is approx 4 bytes */\n    if( aff<SQLITE_AFF_NUMERIC ){\n      if( zChar ){\n        while( zChar[0] ){\n          if( sqlite3Isdigit(zChar[0]) ){\n            /* BLOB(k), VARCHAR(k), CHAR(k) -> r=(k/4+1) */\n            sqlite3GetInt32(zChar, &v);\n            break;\n          }\n          zChar++;\n        }\n      }else{\n        v = 16;   /* BLOB, TEXT, CLOB -> r=5  (approx 20 bytes)*/\n      }\n    }\n#ifdef SQLITE_ENABLE_SORTER_REFERENCES\n    if( v>=sqlite3GlobalConfig.szSorterRef ){\n      pCol->colFlags |= COLFLAG_SORTERREF;\n    }\n#endif\n    v = v/4 + 1;\n    if( v>255 ) v = 255;\n    pCol->szEst = v;\n  }\n  return aff;\n}\n\n/*\n** The expression is the default value for the most recently added column\n** of the table currently under construction.\n**\n** Default value expressions must be constant.  Raise an exception if this\n** is not the case.\n**\n** This routine is called by the parser while in the middle of\n** parsing a CREATE TABLE statement.\n*/\nvoid sqlite3AddDefaultValue(\n  Parse *pParse,           /* Parsing context */\n  Expr *pExpr,             /* The parsed expression of the default value */\n  const char *zStart,      /* Start of the default value text */\n  const char *zEnd         /* First character past end of defaut value text */\n){\n  Table *p;\n  Column *pCol;\n  sqlite3 *db = pParse->db;\n  p = pParse->pNewTable;\n  if( p!=0 ){\n    pCol = &(p->aCol[p->nCol-1]);\n    if( !sqlite3ExprIsConstantOrFunction(pExpr, db->init.busy) ){\n      sqlite3ErrorMsg(pParse, \"default value of column [%s] is not constant\",\n          pCol->zName);\n#ifndef SQLITE_OMIT_GENERATED_COLUMNS\n    }else if( pCol->colFlags & COLFLAG_GENERATED ){\n      testcase( pCol->colFlags & COLFLAG_VIRTUAL );\n      testcase( pCol->colFlags & COLFLAG_STORED );\n      sqlite3ErrorMsg(pParse, \"cannot use DEFAULT on a generated column\");\n#endif\n    }else{\n      /* A copy of pExpr is used instead of the original, as pExpr contains\n      ** tokens that point to volatile memory.\n      */\n      Expr x;\n      sqlite3ExprDelete(db, pCol->pDflt);\n      memset(&x, 0, sizeof(x));\n      x.op = TK_SPAN;\n      x.u.zToken = sqlite3DbSpanDup(db, zStart, zEnd);\n      x.pLeft = pExpr;\n      x.flags = EP_Skip;\n      pCol->pDflt = sqlite3ExprDup(db, &x, EXPRDUP_REDUCE);\n      sqlite3DbFree(db, x.u.zToken);\n    }\n  }\n  if( IN_RENAME_OBJECT ){\n    sqlite3RenameExprUnmap(pParse, pExpr);\n  }\n  sqlite3ExprDelete(db, pExpr);\n}\n\n/*\n** Backwards Compatibility Hack:\n** \n** Historical versions of SQLite accepted strings as column names in\n** indexes and PRIMARY KEY constraints and in UNIQUE constraints.  Example:\n**\n**     CREATE TABLE xyz(a,b,c,d,e,PRIMARY KEY('a'),UNIQUE('b','c' COLLATE trim)\n**     CREATE INDEX abc ON xyz('c','d' DESC,'e' COLLATE nocase DESC);\n**\n** This is goofy.  But to preserve backwards compatibility we continue to\n** accept it.  This routine does the necessary conversion.  It converts\n** the expression given in its argument from a TK_STRING into a TK_ID\n** if the expression is just a TK_STRING with an optional COLLATE clause.\n** If the expression is anything other than TK_STRING, the expression is\n** unchanged.\n*/\nstatic void sqlite3StringToId(Expr *p){\n  if( p->op==TK_STRING ){\n    p->op = TK_ID;\n  }else if( p->op==TK_COLLATE && p->pLeft->op==TK_STRING ){\n    p->pLeft->op = TK_ID;\n  }\n}\n\n/*\n** Tag the given column as being part of the PRIMARY KEY\n*/\nstatic void makeColumnPartOfPrimaryKey(Parse *pParse, Column *pCol){\n  pCol->colFlags |= COLFLAG_PRIMKEY;\n#ifndef SQLITE_OMIT_GENERATED_COLUMNS\n  if( pCol->colFlags & COLFLAG_GENERATED ){\n    testcase( pCol->colFlags & COLFLAG_VIRTUAL );\n    testcase( pCol->colFlags & COLFLAG_STORED );\n    sqlite3ErrorMsg(pParse,\n      \"generated columns cannot be part of the PRIMARY KEY\");\n  }\n#endif          \n}\n\n/*\n** Designate the PRIMARY KEY for the table.  pList is a list of names \n** of columns that form the primary key.  If pList is NULL, then the\n** most recently added column of the table is the primary key.\n**\n** A table can have at most one primary key.  If the table already has\n** a primary key (and this is the second primary key) then create an\n** error.\n**\n** If the PRIMARY KEY is on a single column whose datatype is INTEGER,\n** then we will try to use that column as the rowid.  Set the Table.iPKey\n** field of the table under construction to be the index of the\n** INTEGER PRIMARY KEY column.  Table.iPKey is set to -1 if there is\n** no INTEGER PRIMARY KEY.\n**\n** If the key is not an INTEGER PRIMARY KEY, then create a unique\n** index for the key.  No index is created for INTEGER PRIMARY KEYs.\n*/\nvoid sqlite3AddPrimaryKey(\n  Parse *pParse,    /* Parsing context */\n  ExprList *pList,  /* List of field names to be indexed */\n  int onError,      /* What to do with a uniqueness conflict */\n  int autoInc,      /* True if the AUTOINCREMENT keyword is present */\n  int sortOrder     /* SQLITE_SO_ASC or SQLITE_SO_DESC */\n){\n  Table *pTab = pParse->pNewTable;\n  Column *pCol = 0;\n  int iCol = -1, i;\n  int nTerm;\n  if( pTab==0 ) goto primary_key_exit;\n  if( pTab->tabFlags & TF_HasPrimaryKey ){\n    sqlite3ErrorMsg(pParse, \n      \"table \\\"%s\\\" has more than one primary key\", pTab->zName);\n    goto primary_key_exit;\n  }\n  pTab->tabFlags |= TF_HasPrimaryKey;\n  if( pList==0 ){\n    iCol = pTab->nCol - 1;\n    pCol = &pTab->aCol[iCol];\n    makeColumnPartOfPrimaryKey(pParse, pCol);\n    nTerm = 1;\n  }else{\n    nTerm = pList->nExpr;\n    for(i=0; i<nTerm; i++){\n      Expr *pCExpr = sqlite3ExprSkipCollate(pList->a[i].pExpr);\n      assert( pCExpr!=0 );\n      sqlite3StringToId(pCExpr);\n      if( pCExpr->op==TK_ID ){\n        const char *zCName = pCExpr->u.zToken;\n        for(iCol=0; iCol<pTab->nCol; iCol++){\n          if( sqlite3StrICmp(zCName, pTab->aCol[iCol].zName)==0 ){\n            pCol = &pTab->aCol[iCol];\n            makeColumnPartOfPrimaryKey(pParse, pCol);\n            break;\n          }\n        }\n      }\n    }\n  }\n  if( nTerm==1\n   && pCol\n   && sqlite3StrICmp(sqlite3ColumnType(pCol,\"\"), \"INTEGER\")==0\n   && sortOrder!=SQLITE_SO_DESC\n  ){\n    if( IN_RENAME_OBJECT && pList ){\n      Expr *pCExpr = sqlite3ExprSkipCollate(pList->a[0].pExpr);\n      sqlite3RenameTokenRemap(pParse, &pTab->iPKey, pCExpr);\n    }\n    pTab->iPKey = iCol;\n    pTab->keyConf = (u8)onError;\n    assert( autoInc==0 || autoInc==1 );\n    pTab->tabFlags |= autoInc*TF_Autoincrement;\n    if( pList ) pParse->iPkSortOrder = pList->a[0].sortFlags;\n  }else if( autoInc ){\n#ifndef SQLITE_OMIT_AUTOINCREMENT\n    sqlite3ErrorMsg(pParse, \"AUTOINCREMENT is only allowed on an \"\n       \"INTEGER PRIMARY KEY\");\n#endif\n  }else{\n    sqlite3CreateIndex(pParse, 0, 0, 0, pList, onError, 0,\n                           0, sortOrder, 0, SQLITE_IDXTYPE_PRIMARYKEY);\n    pList = 0;\n  }\n\nprimary_key_exit:\n  sqlite3ExprListDelete(pParse->db, pList);\n  return;\n}\n\n/*\n** Add a new CHECK constraint to the table currently under construction.\n*/\nvoid sqlite3AddCheckConstraint(\n  Parse *pParse,    /* Parsing context */\n  Expr *pCheckExpr  /* The check expression */\n){\n#ifndef SQLITE_OMIT_CHECK\n  Table *pTab = pParse->pNewTable;\n  sqlite3 *db = pParse->db;\n  if( pTab && !IN_DECLARE_VTAB\n   && !sqlite3BtreeIsReadonly(db->aDb[db->init.iDb].pBt)\n  ){\n    pTab->pCheck = sqlite3ExprListAppend(pParse, pTab->pCheck, pCheckExpr);\n    if( pParse->constraintName.n ){\n      sqlite3ExprListSetName(pParse, pTab->pCheck, &pParse->constraintName, 1);\n    }\n  }else\n#endif\n  {\n    sqlite3ExprDelete(pParse->db, pCheckExpr);\n  }\n}\n\n/*\n** Set the collation function of the most recently parsed table column\n** to the CollSeq given.\n*/\nvoid sqlite3AddCollateType(Parse *pParse, Token *pToken){\n  Table *p;\n  int i;\n  char *zColl;              /* Dequoted name of collation sequence */\n  sqlite3 *db;\n\n  if( (p = pParse->pNewTable)==0 ) return;\n  i = p->nCol-1;\n  db = pParse->db;\n  zColl = sqlite3NameFromToken(db, pToken);\n  if( !zColl ) return;\n\n  if( sqlite3LocateCollSeq(pParse, zColl) ){\n    Index *pIdx;\n    sqlite3DbFree(db, p->aCol[i].zColl);\n    p->aCol[i].zColl = zColl;\n  \n    /* If the column is declared as \"<name> PRIMARY KEY COLLATE <type>\",\n    ** then an index may have been created on this column before the\n    ** collation type was added. Correct this if it is the case.\n    */\n    for(pIdx=p->pIndex; pIdx; pIdx=pIdx->pNext){\n      assert( pIdx->nKeyCol==1 );\n      if( pIdx->aiColumn[0]==i ){\n        pIdx->azColl[0] = p->aCol[i].zColl;\n      }\n    }\n  }else{\n    sqlite3DbFree(db, zColl);\n  }\n}\n\n/* Change the most recently parsed column to be a GENERATED ALWAYS AS\n** column.\n*/\nvoid sqlite3AddGenerated(Parse *pParse, Expr *pExpr, Token *pType){\n#ifndef SQLITE_OMIT_GENERATED_COLUMNS\n  u8 eType = COLFLAG_VIRTUAL;\n  Table *pTab = pParse->pNewTable;\n  Column *pCol;\n  if( pTab==0 ){\n    /* generated column in an CREATE TABLE IF NOT EXISTS that already exists */\n    goto generated_done;\n  }\n  pCol = &(pTab->aCol[pTab->nCol-1]);\n  if( IN_DECLARE_VTAB ){\n    sqlite3ErrorMsg(pParse, \"virtual tables cannot use computed columns\");\n    goto generated_done;\n  }\n  if( pCol->pDflt ) goto generated_error;\n  if( pType ){\n    if( pType->n==7 && sqlite3StrNICmp(\"virtual\",pType->z,7)==0 ){\n      /* no-op */\n    }else if( pType->n==6 && sqlite3StrNICmp(\"stored\",pType->z,6)==0 ){\n      eType = COLFLAG_STORED;\n    }else{\n      goto generated_error;\n    }\n  }\n  if( eType==COLFLAG_VIRTUAL ) pTab->nNVCol--;\n  pCol->colFlags |= eType;\n  assert( TF_HasVirtual==COLFLAG_VIRTUAL );\n  assert( TF_HasStored==COLFLAG_STORED );\n  pTab->tabFlags |= eType;\n  if( pCol->colFlags & COLFLAG_PRIMKEY ){\n    makeColumnPartOfPrimaryKey(pParse, pCol); /* For the error message */\n  }\n  pCol->pDflt = pExpr;\n  pExpr = 0;\n  goto generated_done;\n\ngenerated_error:\n  sqlite3ErrorMsg(pParse, \"error in generated column \\\"%s\\\"\",\n                  pCol->zName);\ngenerated_done:\n  sqlite3ExprDelete(pParse->db, pExpr);\n#else\n  /* Throw and error for the GENERATED ALWAYS AS clause if the\n  ** SQLITE_OMIT_GENERATED_COLUMNS compile-time option is used. */\n  sqlite3ErrorMsg(pParse, \"generated columns not supported\");\n  sqlite3ExprDelete(pParse->db, pExpr);\n#endif\n}\n\n/*\n** Generate code that will increment the schema cookie.\n**\n** The schema cookie is used to determine when the schema for the\n** database changes.  After each schema change, the cookie value\n** changes.  When a process first reads the schema it records the\n** cookie.  Thereafter, whenever it goes to access the database,\n** it checks the cookie to make sure the schema has not changed\n** since it was last read.\n**\n** This plan is not completely bullet-proof.  It is possible for\n** the schema to change multiple times and for the cookie to be\n** set back to prior value.  But schema changes are infrequent\n** and the probability of hitting the same cookie value is only\n** 1 chance in 2^32.  So we're safe enough.\n**\n** IMPLEMENTATION-OF: R-34230-56049 SQLite automatically increments\n** the schema-version whenever the schema changes.\n*/\nvoid sqlite3ChangeCookie(Parse *pParse, int iDb){\n  sqlite3 *db = pParse->db;\n  Vdbe *v = pParse->pVdbe;\n  assert( sqlite3SchemaMutexHeld(db, iDb, 0) );\n  sqlite3VdbeAddOp3(v, OP_SetCookie, iDb, BTREE_SCHEMA_VERSION, \n                   (int)(1+(unsigned)db->aDb[iDb].pSchema->schema_cookie));\n}\n\n/*\n** Measure the number of characters needed to output the given\n** identifier.  The number returned includes any quotes used\n** but does not include the null terminator.\n**\n** The estimate is conservative.  It might be larger that what is\n** really needed.\n*/\nstatic int identLength(const char *z){\n  int n;\n  for(n=0; *z; n++, z++){\n    if( *z=='\"' ){ n++; }\n  }\n  return n + 2;\n}\n\n/*\n** The first parameter is a pointer to an output buffer. The second \n** parameter is a pointer to an integer that contains the offset at\n** which to write into the output buffer. This function copies the\n** nul-terminated string pointed to by the third parameter, zSignedIdent,\n** to the specified offset in the buffer and updates *pIdx to refer\n** to the first byte after the last byte written before returning.\n** \n** If the string zSignedIdent consists entirely of alpha-numeric\n** characters, does not begin with a digit and is not an SQL keyword,\n** then it is copied to the output buffer exactly as it is. Otherwise,\n** it is quoted using double-quotes.\n*/\nstatic void identPut(char *z, int *pIdx, char *zSignedIdent){\n  unsigned char *zIdent = (unsigned char*)zSignedIdent;\n  int i, j, needQuote;\n  i = *pIdx;\n\n  for(j=0; zIdent[j]; j++){\n    if( !sqlite3Isalnum(zIdent[j]) && zIdent[j]!='_' ) break;\n  }\n  needQuote = sqlite3Isdigit(zIdent[0])\n            || sqlite3KeywordCode(zIdent, j)!=TK_ID\n            || zIdent[j]!=0\n            || j==0;\n\n  if( needQuote ) z[i++] = '\"';\n  for(j=0; zIdent[j]; j++){\n    z[i++] = zIdent[j];\n    if( zIdent[j]=='\"' ) z[i++] = '\"';\n  }\n  if( needQuote ) z[i++] = '\"';\n  z[i] = 0;\n  *pIdx = i;\n}\n\n/*\n** Generate a CREATE TABLE statement appropriate for the given\n** table.  Memory to hold the text of the statement is obtained\n** from sqliteMalloc() and must be freed by the calling function.\n*/\nstatic char *createTableStmt(sqlite3 *db, Table *p){\n  int i, k, n;\n  char *zStmt;\n  char *zSep, *zSep2, *zEnd;\n  Column *pCol;\n  n = 0;\n  for(pCol = p->aCol, i=0; i<p->nCol; i++, pCol++){\n    n += identLength(pCol->zName) + 5;\n  }\n  n += identLength(p->zName);\n  if( n<50 ){ \n    zSep = \"\";\n    zSep2 = \",\";\n    zEnd = \")\";\n  }else{\n    zSep = \"\\n  \";\n    zSep2 = \",\\n  \";\n    zEnd = \"\\n)\";\n  }\n  n += 35 + 6*p->nCol;\n  zStmt = sqlite3DbMallocRaw(0, n);\n  if( zStmt==0 ){\n    sqlite3OomFault(db);\n    return 0;\n  }\n  sqlite3_snprintf(n, zStmt, \"CREATE TABLE \");\n  k = sqlite3Strlen30(zStmt);\n  identPut(zStmt, &k, p->zName);\n  zStmt[k++] = '(';\n  for(pCol=p->aCol, i=0; i<p->nCol; i++, pCol++){\n    static const char * const azType[] = {\n        /* SQLITE_AFF_BLOB    */ \"\",\n        /* SQLITE_AFF_TEXT    */ \" TEXT\",\n        /* SQLITE_AFF_NUMERIC */ \" NUM\",\n        /* SQLITE_AFF_INTEGER */ \" INT\",\n        /* SQLITE_AFF_REAL    */ \" REAL\"\n    };\n    int len;\n    const char *zType;\n\n    sqlite3_snprintf(n-k, &zStmt[k], zSep);\n    k += sqlite3Strlen30(&zStmt[k]);\n    zSep = zSep2;\n    identPut(zStmt, &k, pCol->zName);\n    assert( pCol->affinity-SQLITE_AFF_BLOB >= 0 );\n    assert( pCol->affinity-SQLITE_AFF_BLOB < ArraySize(azType) );\n    testcase( pCol->affinity==SQLITE_AFF_BLOB );\n    testcase( pCol->affinity==SQLITE_AFF_TEXT );\n    testcase( pCol->affinity==SQLITE_AFF_NUMERIC );\n    testcase( pCol->affinity==SQLITE_AFF_INTEGER );\n    testcase( pCol->affinity==SQLITE_AFF_REAL );\n    \n    zType = azType[pCol->affinity - SQLITE_AFF_BLOB];\n    len = sqlite3Strlen30(zType);\n    assert( pCol->affinity==SQLITE_AFF_BLOB \n            || pCol->affinity==sqlite3AffinityType(zType, 0) );\n    memcpy(&zStmt[k], zType, len);\n    k += len;\n    assert( k<=n );\n  }\n  sqlite3_snprintf(n-k, &zStmt[k], \"%s\", zEnd);\n  return zStmt;\n}\n\n/*\n** Resize an Index object to hold N columns total.  Return SQLITE_OK\n** on success and SQLITE_NOMEM on an OOM error.\n*/\nstatic int resizeIndexObject(sqlite3 *db, Index *pIdx, int N){\n  char *zExtra;\n  int nByte;\n  if( pIdx->nColumn>=N ) return SQLITE_OK;\n  assert( pIdx->isResized==0 );\n  nByte = (sizeof(char*) + sizeof(i16) + 1)*N;\n  zExtra = sqlite3DbMallocZero(db, nByte);\n  if( zExtra==0 ) return SQLITE_NOMEM_BKPT;\n  memcpy(zExtra, pIdx->azColl, sizeof(char*)*pIdx->nColumn);\n  pIdx->azColl = (const char**)zExtra;\n  zExtra += sizeof(char*)*N;\n  memcpy(zExtra, pIdx->aiColumn, sizeof(i16)*pIdx->nColumn);\n  pIdx->aiColumn = (i16*)zExtra;\n  zExtra += sizeof(i16)*N;\n  memcpy(zExtra, pIdx->aSortOrder, pIdx->nColumn);\n  pIdx->aSortOrder = (u8*)zExtra;\n  pIdx->nColumn = N;\n  pIdx->isResized = 1;\n  return SQLITE_OK;\n}\n\n/*\n** Estimate the total row width for a table.\n*/\nstatic void estimateTableWidth(Table *pTab){\n  unsigned wTable = 0;\n  const Column *pTabCol;\n  int i;\n  for(i=pTab->nCol, pTabCol=pTab->aCol; i>0; i--, pTabCol++){\n    wTable += pTabCol->szEst;\n  }\n  if( pTab->iPKey<0 ) wTable++;\n  pTab->szTabRow = sqlite3LogEst(wTable*4);\n}\n\n/*\n** Estimate the average size of a row for an index.\n*/\nstatic void estimateIndexWidth(Index *pIdx){\n  unsigned wIndex = 0;\n  int i;\n  const Column *aCol = pIdx->pTable->aCol;\n  for(i=0; i<pIdx->nColumn; i++){\n    i16 x = pIdx->aiColumn[i];\n    assert( x<pIdx->pTable->nCol );\n    wIndex += x<0 ? 1 : aCol[pIdx->aiColumn[i]].szEst;\n  }\n  pIdx->szIdxRow = sqlite3LogEst(wIndex*4);\n}\n\n/* Return true if column number x is any of the first nCol entries of aiCol[].\n** This is used to determine if the column number x appears in any of the\n** first nCol entries of an index.\n*/\nstatic int hasColumn(const i16 *aiCol, int nCol, int x){\n  while( nCol-- > 0 ){\n    assert( aiCol[0]>=0 );\n    if( x==*(aiCol++) ){\n      return 1;\n    }\n  }\n  return 0;\n}\n\n/*\n** Return true if any of the first nKey entries of index pIdx exactly\n** match the iCol-th entry of pPk.  pPk is always a WITHOUT ROWID\n** PRIMARY KEY index.  pIdx is an index on the same table.  pIdx may\n** or may not be the same index as pPk.\n**\n** The first nKey entries of pIdx are guaranteed to be ordinary columns,\n** not a rowid or expression.\n**\n** This routine differs from hasColumn() in that both the column and the\n** collating sequence must match for this routine, but for hasColumn() only\n** the column name must match.\n*/\nstatic int isDupColumn(Index *pIdx, int nKey, Index *pPk, int iCol){\n  int i, j;\n  assert( nKey<=pIdx->nColumn );\n  assert( iCol<MAX(pPk->nColumn,pPk->nKeyCol) );\n  assert( pPk->idxType==SQLITE_IDXTYPE_PRIMARYKEY );\n  assert( pPk->pTable->tabFlags & TF_WithoutRowid );\n  assert( pPk->pTable==pIdx->pTable );\n  testcase( pPk==pIdx );\n  j = pPk->aiColumn[iCol];\n  assert( j!=XN_ROWID && j!=XN_EXPR );\n  for(i=0; i<nKey; i++){\n    assert( pIdx->aiColumn[i]>=0 || j>=0 );\n    if( pIdx->aiColumn[i]==j \n     && sqlite3StrICmp(pIdx->azColl[i], pPk->azColl[iCol])==0\n    ){\n      return 1;\n    }\n  }\n  return 0;\n}\n\n/* Recompute the colNotIdxed field of the Index.\n**\n** colNotIdxed is a bitmask that has a 0 bit representing each indexed\n** columns that are within the first 63 columns of the table.  The\n** high-order bit of colNotIdxed is always 1.  All unindexed columns\n** of the table have a 1.\n**\n** 2019-10-24:  For the purpose of this computation, virtual columns are\n** not considered to be covered by the index, even if they are in the\n** index, because we do not trust the logic in whereIndexExprTrans() to be\n** able to find all instances of a reference to the indexed table column\n** and convert them into references to the index.  Hence we always want\n** the actual table at hand in order to recompute the virtual column, if\n** necessary.\n**\n** The colNotIdxed mask is AND-ed with the SrcList.a[].colUsed mask\n** to determine if the index is covering index.\n*/\nstatic void recomputeColumnsNotIndexed(Index *pIdx){\n  Bitmask m = 0;\n  int j;\n  Table *pTab = pIdx->pTable;\n  for(j=pIdx->nColumn-1; j>=0; j--){\n    int x = pIdx->aiColumn[j];\n    if( x>=0 && (pTab->aCol[x].colFlags & COLFLAG_VIRTUAL)==0 ){\n      testcase( x==BMS-1 );\n      testcase( x==BMS-2 );\n      if( x<BMS-1 ) m |= MASKBIT(x);\n    }\n  }\n  pIdx->colNotIdxed = ~m;\n  assert( (pIdx->colNotIdxed>>63)==1 );\n}\n\n/*\n** This routine runs at the end of parsing a CREATE TABLE statement that\n** has a WITHOUT ROWID clause.  The job of this routine is to convert both\n** internal schema data structures and the generated VDBE code so that they\n** are appropriate for a WITHOUT ROWID table instead of a rowid table.\n** Changes include:\n**\n**     (1)  Set all columns of the PRIMARY KEY schema object to be NOT NULL.\n**     (2)  Convert P3 parameter of the OP_CreateBtree from BTREE_INTKEY \n**          into BTREE_BLOBKEY.\n**     (3)  Bypass the creation of the sqlite_master table entry\n**          for the PRIMARY KEY as the primary key index is now\n**          identified by the sqlite_master table entry of the table itself.\n**     (4)  Set the Index.tnum of the PRIMARY KEY Index object in the\n**          schema to the rootpage from the main table.\n**     (5)  Add all table columns to the PRIMARY KEY Index object\n**          so that the PRIMARY KEY is a covering index.  The surplus\n**          columns are part of KeyInfo.nAllField and are not used for\n**          sorting or lookup or uniqueness checks.\n**     (6)  Replace the rowid tail on all automatically generated UNIQUE\n**          indices with the PRIMARY KEY columns.\n**\n** For virtual tables, only (1) is performed.\n*/\nstatic void convertToWithoutRowidTable(Parse *pParse, Table *pTab){\n  Index *pIdx;\n  Index *pPk;\n  int nPk;\n  int nExtra;\n  int i, j;\n  sqlite3 *db = pParse->db;\n  Vdbe *v = pParse->pVdbe;\n\n  /* Mark every PRIMARY KEY column as NOT NULL (except for imposter tables)\n  */\n  if( !db->init.imposterTable ){\n    for(i=0; i<pTab->nCol; i++){\n      if( (pTab->aCol[i].colFlags & COLFLAG_PRIMKEY)!=0 ){\n        pTab->aCol[i].notNull = OE_Abort;\n      }\n    }\n    pTab->tabFlags |= TF_HasNotNull;\n  }\n\n  /* Convert the P3 operand of the OP_CreateBtree opcode from BTREE_INTKEY\n  ** into BTREE_BLOBKEY.\n  */\n  if( pParse->addrCrTab ){\n    assert( v );\n    sqlite3VdbeChangeP3(v, pParse->addrCrTab, BTREE_BLOBKEY);\n  }\n\n  /* Locate the PRIMARY KEY index.  Or, if this table was originally\n  ** an INTEGER PRIMARY KEY table, create a new PRIMARY KEY index. \n  */\n  if( pTab->iPKey>=0 ){\n    ExprList *pList;\n    Token ipkToken;\n    sqlite3TokenInit(&ipkToken, pTab->aCol[pTab->iPKey].zName);\n    pList = sqlite3ExprListAppend(pParse, 0, \n                  sqlite3ExprAlloc(db, TK_ID, &ipkToken, 0));\n    if( pList==0 ) return;\n    if( IN_RENAME_OBJECT ){\n      sqlite3RenameTokenRemap(pParse, pList->a[0].pExpr, &pTab->iPKey);\n    }\n    pList->a[0].sortFlags = pParse->iPkSortOrder;\n    assert( pParse->pNewTable==pTab );\n    pTab->iPKey = -1;\n    sqlite3CreateIndex(pParse, 0, 0, 0, pList, pTab->keyConf, 0, 0, 0, 0,\n                       SQLITE_IDXTYPE_PRIMARYKEY);\n    if( db->mallocFailed || pParse->nErr ) return;\n    pPk = sqlite3PrimaryKeyIndex(pTab);\n    assert( pPk->nKeyCol==1 );\n  }else{\n    pPk = sqlite3PrimaryKeyIndex(pTab);\n    assert( pPk!=0 );\n\n    /*\n    ** Remove all redundant columns from the PRIMARY KEY.  For example, change\n    ** \"PRIMARY KEY(a,b,a,b,c,b,c,d)\" into just \"PRIMARY KEY(a,b,c,d)\".  Later\n    ** code assumes the PRIMARY KEY contains no repeated columns.\n    */\n    for(i=j=1; i<pPk->nKeyCol; i++){\n      if( isDupColumn(pPk, j, pPk, i) ){\n        pPk->nColumn--;\n      }else{\n        testcase( hasColumn(pPk->aiColumn, j, pPk->aiColumn[i]) );\n        pPk->azColl[j] = pPk->azColl[i];\n        pPk->aSortOrder[j] = pPk->aSortOrder[i];\n        pPk->aiColumn[j++] = pPk->aiColumn[i];\n      }\n    }\n    pPk->nKeyCol = j;\n  }\n  assert( pPk!=0 );\n  pPk->isCovering = 1;\n  if( !db->init.imposterTable ) pPk->uniqNotNull = 1;\n  nPk = pPk->nColumn = pPk->nKeyCol;\n\n  /* Bypass the creation of the PRIMARY KEY btree and the sqlite_master\n  ** table entry. This is only required if currently generating VDBE\n  ** code for a CREATE TABLE (not when parsing one as part of reading\n  ** a database schema).  */\n  if( v && pPk->tnum>0 ){\n    assert( db->init.busy==0 );\n    sqlite3VdbeChangeOpcode(v, pPk->tnum, OP_Goto);\n  }\n\n  /* The root page of the PRIMARY KEY is the table root page */\n  pPk->tnum = pTab->tnum;\n\n  /* Update the in-memory representation of all UNIQUE indices by converting\n  ** the final rowid column into one or more columns of the PRIMARY KEY.\n  */\n  for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){\n    int n;\n    if( IsPrimaryKeyIndex(pIdx) ) continue;\n    for(i=n=0; i<nPk; i++){\n      if( !isDupColumn(pIdx, pIdx->nKeyCol, pPk, i) ){\n        testcase( hasColumn(pIdx->aiColumn, pIdx->nKeyCol, pPk->aiColumn[i]) );\n        n++;\n      }\n    }\n    if( n==0 ){\n      /* This index is a superset of the primary key */\n      pIdx->nColumn = pIdx->nKeyCol;\n      continue;\n    }\n    if( resizeIndexObject(db, pIdx, pIdx->nKeyCol+n) ) return;\n    for(i=0, j=pIdx->nKeyCol; i<nPk; i++){\n      if( !isDupColumn(pIdx, pIdx->nKeyCol, pPk, i) ){\n        testcase( hasColumn(pIdx->aiColumn, pIdx->nKeyCol, pPk->aiColumn[i]) );\n        pIdx->aiColumn[j] = pPk->aiColumn[i];\n        pIdx->azColl[j] = pPk->azColl[i];\n        if( pPk->aSortOrder[i] ){\n          /* See ticket https://www.sqlite.org/src/info/bba7b69f9849b5bf */\n          pIdx->bAscKeyBug = 1;\n        }\n        j++;\n      }\n    }\n    assert( pIdx->nColumn>=pIdx->nKeyCol+n );\n    assert( pIdx->nColumn>=j );\n  }\n\n  /* Add all table columns to the PRIMARY KEY index\n  */\n  nExtra = 0;\n  for(i=0; i<pTab->nCol; i++){\n    if( !hasColumn(pPk->aiColumn, nPk, i)\n     && (pTab->aCol[i].colFlags & COLFLAG_VIRTUAL)==0 ) nExtra++;\n  }\n  if( resizeIndexObject(db, pPk, nPk+nExtra) ) return;\n  for(i=0, j=nPk; i<pTab->nCol; i++){\n    if( !hasColumn(pPk->aiColumn, j, i)\n     && (pTab->aCol[i].colFlags & COLFLAG_VIRTUAL)==0\n    ){\n      assert( j<pPk->nColumn );\n      pPk->aiColumn[j] = i;\n      pPk->azColl[j] = sqlite3StrBINARY;\n      j++;\n    }\n  }\n  assert( pPk->nColumn==j );\n  assert( pTab->nNVCol<=j );\n  recomputeColumnsNotIndexed(pPk);\n}\n\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n/*\n** Return true if zName is a shadow table name in the current database\n** connection.\n**\n** zName is temporarily modified while this routine is running, but is\n** restored to its original value prior to this routine returning.\n*/\nint sqlite3ShadowTableName(sqlite3 *db, const char *zName){\n  char *zTail;                  /* Pointer to the last \"_\" in zName */\n  Table *pTab;                  /* Table that zName is a shadow of */\n  Module *pMod;                 /* Module for the virtual table */\n\n  zTail = strrchr(zName, '_');\n  if( zTail==0 ) return 0;\n  *zTail = 0;\n  pTab = sqlite3FindTable(db, zName, 0);\n  *zTail = '_';\n  if( pTab==0 ) return 0;\n  if( !IsVirtual(pTab) ) return 0;\n  pMod = (Module*)sqlite3HashFind(&db->aModule, pTab->azModuleArg[0]);\n  if( pMod==0 ) return 0;\n  if( pMod->pModule->iVersion<3 ) return 0;\n  if( pMod->pModule->xShadowName==0 ) return 0;\n  return pMod->pModule->xShadowName(zTail+1);\n}\n#endif /* ifndef SQLITE_OMIT_VIRTUALTABLE */\n\n/*\n** This routine is called to report the final \")\" that terminates\n** a CREATE TABLE statement.\n**\n** The table structure that other action routines have been building\n** is added to the internal hash tables, assuming no errors have\n** occurred.\n**\n** An entry for the table is made in the master table on disk, unless\n** this is a temporary table or db->init.busy==1.  When db->init.busy==1\n** it means we are reading the sqlite_master table because we just\n** connected to the database or because the sqlite_master table has\n** recently changed, so the entry for this table already exists in\n** the sqlite_master table.  We do not want to create it again.\n**\n** If the pSelect argument is not NULL, it means that this routine\n** was called to create a table generated from a \n** \"CREATE TABLE ... AS SELECT ...\" statement.  The column names of\n** the new table will match the result set of the SELECT.\n*/\nvoid sqlite3EndTable(\n  Parse *pParse,          /* Parse context */\n  Token *pCons,           /* The ',' token after the last column defn. */\n  Token *pEnd,            /* The ')' before options in the CREATE TABLE */\n  u8 tabOpts,             /* Extra table options. Usually 0. */\n  Select *pSelect         /* Select from a \"CREATE ... AS SELECT\" */\n){\n  Table *p;                 /* The new table */\n  sqlite3 *db = pParse->db; /* The database connection */\n  int iDb;                  /* Database in which the table lives */\n  Index *pIdx;              /* An implied index of the table */\n\n  if( pEnd==0 && pSelect==0 ){\n    return;\n  }\n  assert( !db->mallocFailed );\n  p = pParse->pNewTable;\n  if( p==0 ) return;\n\n  if( pSelect==0 && sqlite3ShadowTableName(db, p->zName) ){\n    p->tabFlags |= TF_Shadow;\n  }\n\n  /* If the db->init.busy is 1 it means we are reading the SQL off the\n  ** \"sqlite_master\" or \"sqlite_temp_master\" table on the disk.\n  ** So do not write to the disk again.  Extract the root page number\n  ** for the table from the db->init.newTnum field.  (The page number\n  ** should have been put there by the sqliteOpenCb routine.)\n  **\n  ** If the root page number is 1, that means this is the sqlite_master\n  ** table itself.  So mark it read-only.\n  */\n  if( db->init.busy ){\n    if( pSelect ){\n      sqlite3ErrorMsg(pParse, \"\");\n      return;\n    }\n    p->tnum = db->init.newTnum;\n    if( p->tnum==1 ) p->tabFlags |= TF_Readonly;\n  }\n\n  assert( (p->tabFlags & TF_HasPrimaryKey)==0\n       || p->iPKey>=0 || sqlite3PrimaryKeyIndex(p)!=0 );\n  assert( (p->tabFlags & TF_HasPrimaryKey)!=0\n       || (p->iPKey<0 && sqlite3PrimaryKeyIndex(p)==0) );\n\n  /* Special processing for WITHOUT ROWID Tables */\n  if( tabOpts & TF_WithoutRowid ){\n    if( (p->tabFlags & TF_Autoincrement) ){\n      sqlite3ErrorMsg(pParse,\n          \"AUTOINCREMENT not allowed on WITHOUT ROWID tables\");\n      return;\n    }\n    if( (p->tabFlags & TF_HasPrimaryKey)==0 ){\n      sqlite3ErrorMsg(pParse, \"PRIMARY KEY missing on table %s\", p->zName);\n      return;\n    }\n    p->tabFlags |= TF_WithoutRowid | TF_NoVisibleRowid;\n    convertToWithoutRowidTable(pParse, p);\n  }\n  iDb = sqlite3SchemaToIndex(db, p->pSchema);\n\n#ifndef SQLITE_OMIT_CHECK\n  /* Resolve names in all CHECK constraint expressions.\n  */\n  if( p->pCheck ){\n    sqlite3ResolveSelfReference(pParse, p, NC_IsCheck, 0, p->pCheck);\n  }\n#endif /* !defined(SQLITE_OMIT_CHECK) */\n#ifndef SQLITE_OMIT_GENERATED_COLUMNS\n  if( p->tabFlags & TF_HasGenerated ){\n    int ii, nNG = 0;\n    testcase( p->tabFlags & TF_HasVirtual );\n    testcase( p->tabFlags & TF_HasStored );\n    for(ii=0; ii<p->nCol; ii++){\n      u32 colFlags = p->aCol[ii].colFlags;\n      if( (colFlags & COLFLAG_GENERATED)!=0 ){\n        testcase( colFlags & COLFLAG_VIRTUAL );\n        testcase( colFlags & COLFLAG_STORED );\n        sqlite3ResolveSelfReference(pParse, p, NC_GenCol, \n                                    p->aCol[ii].pDflt, 0);\n      }else{\n        nNG++;\n      }\n    }\n    if( nNG==0 ){\n      sqlite3ErrorMsg(pParse, \"must have at least one non-generated column\");\n      return;\n    }\n  }\n#endif\n\n  /* Estimate the average row size for the table and for all implied indices */\n  estimateTableWidth(p);\n  for(pIdx=p->pIndex; pIdx; pIdx=pIdx->pNext){\n    estimateIndexWidth(pIdx);\n  }\n\n  /* If not initializing, then create a record for the new table\n  ** in the SQLITE_MASTER table of the database.\n  **\n  ** If this is a TEMPORARY table, write the entry into the auxiliary\n  ** file instead of into the main database file.\n  */\n  if( !db->init.busy ){\n    int n;\n    Vdbe *v;\n    char *zType;    /* \"view\" or \"table\" */\n    char *zType2;   /* \"VIEW\" or \"TABLE\" */\n    char *zStmt;    /* Text of the CREATE TABLE or CREATE VIEW statement */\n\n    v = sqlite3GetVdbe(pParse);\n    if( NEVER(v==0) ) return;\n\n    sqlite3VdbeAddOp1(v, OP_Close, 0);\n\n    /* \n    ** Initialize zType for the new view or table.\n    */\n    if( p->pSelect==0 ){\n      /* A regular table */\n      zType = \"table\";\n      zType2 = \"TABLE\";\n#ifndef SQLITE_OMIT_VIEW\n    }else{\n      /* A view */\n      zType = \"view\";\n      zType2 = \"VIEW\";\n#endif\n    }\n\n    /* If this is a CREATE TABLE xx AS SELECT ..., execute the SELECT\n    ** statement to populate the new table. The root-page number for the\n    ** new table is in register pParse->regRoot.\n    **\n    ** Once the SELECT has been coded by sqlite3Select(), it is in a\n    ** suitable state to query for the column names and types to be used\n    ** by the new table.\n    **\n    ** A shared-cache write-lock is not required to write to the new table,\n    ** as a schema-lock must have already been obtained to create it. Since\n    ** a schema-lock excludes all other database users, the write-lock would\n    ** be redundant.\n    */\n    if( pSelect ){\n      SelectDest dest;    /* Where the SELECT should store results */\n      int regYield;       /* Register holding co-routine entry-point */\n      int addrTop;        /* Top of the co-routine */\n      int regRec;         /* A record to be insert into the new table */\n      int regRowid;       /* Rowid of the next row to insert */\n      int addrInsLoop;    /* Top of the loop for inserting rows */\n      Table *pSelTab;     /* A table that describes the SELECT results */\n\n      regYield = ++pParse->nMem;\n      regRec = ++pParse->nMem;\n      regRowid = ++pParse->nMem;\n      assert(pParse->nTab==1);\n      sqlite3MayAbort(pParse);\n      sqlite3VdbeAddOp3(v, OP_OpenWrite, 1, pParse->regRoot, iDb);\n      sqlite3VdbeChangeP5(v, OPFLAG_P2ISREG);\n      pParse->nTab = 2;\n      addrTop = sqlite3VdbeCurrentAddr(v) + 1;\n      sqlite3VdbeAddOp3(v, OP_InitCoroutine, regYield, 0, addrTop);\n      if( pParse->nErr ) return;\n      pSelTab = sqlite3ResultSetOfSelect(pParse, pSelect, SQLITE_AFF_BLOB);\n      if( pSelTab==0 ) return;\n      assert( p->aCol==0 );\n      p->nCol = p->nNVCol = pSelTab->nCol;\n      p->aCol = pSelTab->aCol;\n      pSelTab->nCol = 0;\n      pSelTab->aCol = 0;\n      sqlite3DeleteTable(db, pSelTab);\n      sqlite3SelectDestInit(&dest, SRT_Coroutine, regYield);\n      sqlite3Select(pParse, pSelect, &dest);\n      if( pParse->nErr ) return;\n      sqlite3VdbeEndCoroutine(v, regYield);\n      sqlite3VdbeJumpHere(v, addrTop - 1);\n      addrInsLoop = sqlite3VdbeAddOp1(v, OP_Yield, dest.iSDParm);\n      VdbeCoverage(v);\n      sqlite3VdbeAddOp3(v, OP_MakeRecord, dest.iSdst, dest.nSdst, regRec);\n      sqlite3TableAffinity(v, p, 0);\n      sqlite3VdbeAddOp2(v, OP_NewRowid, 1, regRowid);\n      sqlite3VdbeAddOp3(v, OP_Insert, 1, regRec, regRowid);\n      sqlite3VdbeGoto(v, addrInsLoop);\n      sqlite3VdbeJumpHere(v, addrInsLoop);\n      sqlite3VdbeAddOp1(v, OP_Close, 1);\n    }\n\n    /* Compute the complete text of the CREATE statement */\n    if( pSelect ){\n      zStmt = createTableStmt(db, p);\n    }else{\n      Token *pEnd2 = tabOpts ? &pParse->sLastToken : pEnd;\n      n = (int)(pEnd2->z - pParse->sNameToken.z);\n      if( pEnd2->z[0]!=';' ) n += pEnd2->n;\n      zStmt = sqlite3MPrintf(db, \n          \"CREATE %s %.*s\", zType2, n, pParse->sNameToken.z\n      );\n    }\n\n    /* A slot for the record has already been allocated in the \n    ** SQLITE_MASTER table.  We just need to update that slot with all\n    ** the information we've collected.\n    */\n    sqlite3NestedParse(pParse,\n      \"UPDATE %Q.%s \"\n         \"SET type='%s', name=%Q, tbl_name=%Q, rootpage=#%d, sql=%Q \"\n       \"WHERE rowid=#%d\",\n      db->aDb[iDb].zDbSName, MASTER_NAME,\n      zType,\n      p->zName,\n      p->zName,\n      pParse->regRoot,\n      zStmt,\n      pParse->regRowid\n    );\n    sqlite3DbFree(db, zStmt);\n    sqlite3ChangeCookie(pParse, iDb);\n\n#ifndef SQLITE_OMIT_AUTOINCREMENT\n    /* Check to see if we need to create an sqlite_sequence table for\n    ** keeping track of autoincrement keys.\n    */\n    if( (p->tabFlags & TF_Autoincrement)!=0 ){\n      Db *pDb = &db->aDb[iDb];\n      assert( sqlite3SchemaMutexHeld(db, iDb, 0) );\n      if( pDb->pSchema->pSeqTab==0 ){\n        sqlite3NestedParse(pParse,\n          \"CREATE TABLE %Q.sqlite_sequence(name,seq)\",\n          pDb->zDbSName\n        );\n      }\n    }\n#endif\n\n    /* Reparse everything to update our internal data structures */\n    sqlite3VdbeAddParseSchemaOp(v, iDb,\n           sqlite3MPrintf(db, \"tbl_name='%q' AND type!='trigger'\", p->zName));\n  }\n\n  /* Add the table to the in-memory representation of the database.\n  */\n  if( db->init.busy ){\n    Table *pOld;\n    Schema *pSchema = p->pSchema;\n    assert( sqlite3SchemaMutexHeld(db, iDb, 0) );\n    pOld = sqlite3HashInsert(&pSchema->tblHash, p->zName, p);\n    if( pOld ){\n      assert( p==pOld );  /* Malloc must have failed inside HashInsert() */\n      sqlite3OomFault(db);\n      return;\n    }\n    pParse->pNewTable = 0;\n    db->mDbFlags |= DBFLAG_SchemaChange;\n\n#ifndef SQLITE_OMIT_ALTERTABLE\n    if( !p->pSelect ){\n      const char *zName = (const char *)pParse->sNameToken.z;\n      int nName;\n      assert( !pSelect && pCons && pEnd );\n      if( pCons->z==0 ){\n        pCons = pEnd;\n      }\n      nName = (int)((const char *)pCons->z - zName);\n      p->addColOffset = 13 + sqlite3Utf8CharLen(zName, nName);\n    }\n#endif\n  }\n}\n\n#ifndef SQLITE_OMIT_VIEW\n/*\n** The parser calls this routine in order to create a new VIEW\n*/\nvoid sqlite3CreateView(\n  Parse *pParse,     /* The parsing context */\n  Token *pBegin,     /* The CREATE token that begins the statement */\n  Token *pName1,     /* The token that holds the name of the view */\n  Token *pName2,     /* The token that holds the name of the view */\n  ExprList *pCNames, /* Optional list of view column names */\n  Select *pSelect,   /* A SELECT statement that will become the new view */\n  int isTemp,        /* TRUE for a TEMPORARY view */\n  int noErr          /* Suppress error messages if VIEW already exists */\n){\n  Table *p;\n  int n;\n  const char *z;\n  Token sEnd;\n  DbFixer sFix;\n  Token *pName = 0;\n  int iDb;\n  sqlite3 *db = pParse->db;\n\n  if( pParse->nVar>0 ){\n    sqlite3ErrorMsg(pParse, \"parameters are not allowed in views\");\n    goto create_view_fail;\n  }\n  sqlite3StartTable(pParse, pName1, pName2, isTemp, 1, 0, noErr);\n  p = pParse->pNewTable;\n  if( p==0 || pParse->nErr ) goto create_view_fail;\n  sqlite3TwoPartName(pParse, pName1, pName2, &pName);\n  iDb = sqlite3SchemaToIndex(db, p->pSchema);\n  sqlite3FixInit(&sFix, pParse, iDb, \"view\", pName);\n  if( sqlite3FixSelect(&sFix, pSelect) ) goto create_view_fail;\n\n  /* Make a copy of the entire SELECT statement that defines the view.\n  ** This will force all the Expr.token.z values to be dynamically\n  ** allocated rather than point to the input string - which means that\n  ** they will persist after the current sqlite3_exec() call returns.\n  */\n  pSelect->selFlags |= SF_View;\n  if( IN_RENAME_OBJECT ){\n    p->pSelect = pSelect;\n    pSelect = 0;\n  }else{\n    p->pSelect = sqlite3SelectDup(db, pSelect, EXPRDUP_REDUCE);\n  }\n  p->pCheck = sqlite3ExprListDup(db, pCNames, EXPRDUP_REDUCE);\n  if( db->mallocFailed ) goto create_view_fail;\n\n  /* Locate the end of the CREATE VIEW statement.  Make sEnd point to\n  ** the end.\n  */\n  sEnd = pParse->sLastToken;\n  assert( sEnd.z[0]!=0 || sEnd.n==0 );\n  if( sEnd.z[0]!=';' ){\n    sEnd.z += sEnd.n;\n  }\n  sEnd.n = 0;\n  n = (int)(sEnd.z - pBegin->z);\n  assert( n>0 );\n  z = pBegin->z;\n  while( sqlite3Isspace(z[n-1]) ){ n--; }\n  sEnd.z = &z[n-1];\n  sEnd.n = 1;\n\n  /* Use sqlite3EndTable() to add the view to the SQLITE_MASTER table */\n  sqlite3EndTable(pParse, 0, &sEnd, 0, 0);\n\ncreate_view_fail:\n  sqlite3SelectDelete(db, pSelect);\n  if( IN_RENAME_OBJECT ){\n    sqlite3RenameExprlistUnmap(pParse, pCNames);\n  }\n  sqlite3ExprListDelete(db, pCNames);\n  return;\n}\n#endif /* SQLITE_OMIT_VIEW */\n\n#if !defined(SQLITE_OMIT_VIEW) || !defined(SQLITE_OMIT_VIRTUALTABLE)\n/*\n** The Table structure pTable is really a VIEW.  Fill in the names of\n** the columns of the view in the pTable structure.  Return the number\n** of errors.  If an error is seen leave an error message in pParse->zErrMsg.\n*/\nint sqlite3ViewGetColumnNames(Parse *pParse, Table *pTable){\n  Table *pSelTab;   /* A fake table from which we get the result set */\n  Select *pSel;     /* Copy of the SELECT that implements the view */\n  int nErr = 0;     /* Number of errors encountered */\n  int n;            /* Temporarily holds the number of cursors assigned */\n  sqlite3 *db = pParse->db;  /* Database connection for malloc errors */\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n  int rc;\n#endif\n#ifndef SQLITE_OMIT_AUTHORIZATION\n  sqlite3_xauth xAuth;       /* Saved xAuth pointer */\n#endif\n\n  assert( pTable );\n\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n  db->nSchemaLock++;\n  rc = sqlite3VtabCallConnect(pParse, pTable);\n  db->nSchemaLock--;\n  if( rc ){\n    return 1;\n  }\n  if( IsVirtual(pTable) ) return 0;\n#endif\n\n#ifndef SQLITE_OMIT_VIEW\n  /* A positive nCol means the columns names for this view are\n  ** already known.\n  */\n  if( pTable->nCol>0 ) return 0;\n\n  /* A negative nCol is a special marker meaning that we are currently\n  ** trying to compute the column names.  If we enter this routine with\n  ** a negative nCol, it means two or more views form a loop, like this:\n  **\n  **     CREATE VIEW one AS SELECT * FROM two;\n  **     CREATE VIEW two AS SELECT * FROM one;\n  **\n  ** Actually, the error above is now caught prior to reaching this point.\n  ** But the following test is still important as it does come up\n  ** in the following:\n  ** \n  **     CREATE TABLE main.ex1(a);\n  **     CREATE TEMP VIEW ex1 AS SELECT a FROM ex1;\n  **     SELECT * FROM temp.ex1;\n  */\n  if( pTable->nCol<0 ){\n    sqlite3ErrorMsg(pParse, \"view %s is circularly defined\", pTable->zName);\n    return 1;\n  }\n  assert( pTable->nCol>=0 );\n\n  /* If we get this far, it means we need to compute the table names.\n  ** Note that the call to sqlite3ResultSetOfSelect() will expand any\n  ** \"*\" elements in the results set of the view and will assign cursors\n  ** to the elements of the FROM clause.  But we do not want these changes\n  ** to be permanent.  So the computation is done on a copy of the SELECT\n  ** statement that defines the view.\n  */\n  assert( pTable->pSelect );\n  pSel = sqlite3SelectDup(db, pTable->pSelect, 0);\n  if( pSel ){\n#ifndef SQLITE_OMIT_ALTERTABLE\n    u8 eParseMode = pParse->eParseMode;\n    pParse->eParseMode = PARSE_MODE_NORMAL;\n#endif\n    n = pParse->nTab;\n    sqlite3SrcListAssignCursors(pParse, pSel->pSrc);\n    pTable->nCol = -1;\n    DisableLookaside;\n#ifndef SQLITE_OMIT_AUTHORIZATION\n    xAuth = db->xAuth;\n    db->xAuth = 0;\n    pSelTab = sqlite3ResultSetOfSelect(pParse, pSel, SQLITE_AFF_NONE);\n    db->xAuth = xAuth;\n#else\n    pSelTab = sqlite3ResultSetOfSelect(pParse, pSel, SQLITE_AFF_NONE);\n#endif\n    pParse->nTab = n;\n    if( pTable->pCheck ){\n      /* CREATE VIEW name(arglist) AS ...\n      ** The names of the columns in the table are taken from\n      ** arglist which is stored in pTable->pCheck.  The pCheck field\n      ** normally holds CHECK constraints on an ordinary table, but for\n      ** a VIEW it holds the list of column names.\n      */\n      sqlite3ColumnsFromExprList(pParse, pTable->pCheck, \n                                 &pTable->nCol, &pTable->aCol);\n      if( db->mallocFailed==0 \n       && pParse->nErr==0\n       && pTable->nCol==pSel->pEList->nExpr\n      ){\n        sqlite3SelectAddColumnTypeAndCollation(pParse, pTable, pSel,\n                                               SQLITE_AFF_NONE);\n      }\n    }else if( pSelTab ){\n      /* CREATE VIEW name AS...  without an argument list.  Construct\n      ** the column names from the SELECT statement that defines the view.\n      */\n      assert( pTable->aCol==0 );\n      pTable->nCol = pSelTab->nCol;\n      pTable->aCol = pSelTab->aCol;\n      pSelTab->nCol = 0;\n      pSelTab->aCol = 0;\n      assert( sqlite3SchemaMutexHeld(db, 0, pTable->pSchema) );\n    }else{\n      pTable->nCol = 0;\n      nErr++;\n    }\n    pTable->nNVCol = pTable->nCol;\n    sqlite3DeleteTable(db, pSelTab);\n    sqlite3SelectDelete(db, pSel);\n    EnableLookaside;\n#ifndef SQLITE_OMIT_ALTERTABLE\n    pParse->eParseMode = eParseMode;\n#endif\n  } else {\n    nErr++;\n  }\n  pTable->pSchema->schemaFlags |= DB_UnresetViews;\n  if( db->mallocFailed ){\n    sqlite3DeleteColumnNames(db, pTable);\n    pTable->aCol = 0;\n    pTable->nCol = 0;\n  }\n#endif /* SQLITE_OMIT_VIEW */\n  return nErr;  \n}\n#endif /* !defined(SQLITE_OMIT_VIEW) || !defined(SQLITE_OMIT_VIRTUALTABLE) */\n\n#ifndef SQLITE_OMIT_VIEW\n/*\n** Clear the column names from every VIEW in database idx.\n*/\nstatic void sqliteViewResetAll(sqlite3 *db, int idx){\n  HashElem *i;\n  assert( sqlite3SchemaMutexHeld(db, idx, 0) );\n  if( !DbHasProperty(db, idx, DB_UnresetViews) ) return;\n  for(i=sqliteHashFirst(&db->aDb[idx].pSchema->tblHash); i;i=sqliteHashNext(i)){\n    Table *pTab = sqliteHashData(i);\n    if( pTab->pSelect ){\n      sqlite3DeleteColumnNames(db, pTab);\n      pTab->aCol = 0;\n      pTab->nCol = 0;\n    }\n  }\n  DbClearProperty(db, idx, DB_UnresetViews);\n}\n#else\n# define sqliteViewResetAll(A,B)\n#endif /* SQLITE_OMIT_VIEW */\n\n/*\n** This function is called by the VDBE to adjust the internal schema\n** used by SQLite when the btree layer moves a table root page. The\n** root-page of a table or index in database iDb has changed from iFrom\n** to iTo.\n**\n** Ticket #1728:  The symbol table might still contain information\n** on tables and/or indices that are the process of being deleted.\n** If you are unlucky, one of those deleted indices or tables might\n** have the same rootpage number as the real table or index that is\n** being moved.  So we cannot stop searching after the first match \n** because the first match might be for one of the deleted indices\n** or tables and not the table/index that is actually being moved.\n** We must continue looping until all tables and indices with\n** rootpage==iFrom have been converted to have a rootpage of iTo\n** in order to be certain that we got the right one.\n*/\n#ifndef SQLITE_OMIT_AUTOVACUUM\nvoid sqlite3RootPageMoved(sqlite3 *db, int iDb, int iFrom, int iTo){\n  HashElem *pElem;\n  Hash *pHash;\n  Db *pDb;\n\n  assert( sqlite3SchemaMutexHeld(db, iDb, 0) );\n  pDb = &db->aDb[iDb];\n  pHash = &pDb->pSchema->tblHash;\n  for(pElem=sqliteHashFirst(pHash); pElem; pElem=sqliteHashNext(pElem)){\n    Table *pTab = sqliteHashData(pElem);\n    if( pTab->tnum==iFrom ){\n      pTab->tnum = iTo;\n    }\n  }\n  pHash = &pDb->pSchema->idxHash;\n  for(pElem=sqliteHashFirst(pHash); pElem; pElem=sqliteHashNext(pElem)){\n    Index *pIdx = sqliteHashData(pElem);\n    if( pIdx->tnum==iFrom ){\n      pIdx->tnum = iTo;\n    }\n  }\n}\n#endif\n\n/*\n** Write code to erase the table with root-page iTable from database iDb.\n** Also write code to modify the sqlite_master table and internal schema\n** if a root-page of another table is moved by the btree-layer whilst\n** erasing iTable (this can happen with an auto-vacuum database).\n*/ \nstatic void destroyRootPage(Parse *pParse, int iTable, int iDb){\n  Vdbe *v = sqlite3GetVdbe(pParse);\n  int r1 = sqlite3GetTempReg(pParse);\n  if( iTable<2 ) sqlite3ErrorMsg(pParse, \"corrupt schema\");\n  sqlite3VdbeAddOp3(v, OP_Destroy, iTable, r1, iDb);\n  sqlite3MayAbort(pParse);\n#ifndef SQLITE_OMIT_AUTOVACUUM\n  /* OP_Destroy stores an in integer r1. If this integer\n  ** is non-zero, then it is the root page number of a table moved to\n  ** location iTable. The following code modifies the sqlite_master table to\n  ** reflect this.\n  **\n  ** The \"#NNN\" in the SQL is a special constant that means whatever value\n  ** is in register NNN.  See grammar rules associated with the TK_REGISTER\n  ** token for additional information.\n  */\n  sqlite3NestedParse(pParse, \n     \"UPDATE %Q.%s SET rootpage=%d WHERE #%d AND rootpage=#%d\",\n     pParse->db->aDb[iDb].zDbSName, MASTER_NAME, iTable, r1, r1);\n#endif\n  sqlite3ReleaseTempReg(pParse, r1);\n}\n\n/*\n** Write VDBE code to erase table pTab and all associated indices on disk.\n** Code to update the sqlite_master tables and internal schema definitions\n** in case a root-page belonging to another table is moved by the btree layer\n** is also added (this can happen with an auto-vacuum database).\n*/\nstatic void destroyTable(Parse *pParse, Table *pTab){\n  /* If the database may be auto-vacuum capable (if SQLITE_OMIT_AUTOVACUUM\n  ** is not defined), then it is important to call OP_Destroy on the\n  ** table and index root-pages in order, starting with the numerically \n  ** largest root-page number. This guarantees that none of the root-pages\n  ** to be destroyed is relocated by an earlier OP_Destroy. i.e. if the\n  ** following were coded:\n  **\n  ** OP_Destroy 4 0\n  ** ...\n  ** OP_Destroy 5 0\n  **\n  ** and root page 5 happened to be the largest root-page number in the\n  ** database, then root page 5 would be moved to page 4 by the \n  ** \"OP_Destroy 4 0\" opcode. The subsequent \"OP_Destroy 5 0\" would hit\n  ** a free-list page.\n  */\n  int iTab = pTab->tnum;\n  int iDestroyed = 0;\n\n  while( 1 ){\n    Index *pIdx;\n    int iLargest = 0;\n\n    if( iDestroyed==0 || iTab<iDestroyed ){\n      iLargest = iTab;\n    }\n    for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){\n      int iIdx = pIdx->tnum;\n      assert( pIdx->pSchema==pTab->pSchema );\n      if( (iDestroyed==0 || (iIdx<iDestroyed)) && iIdx>iLargest ){\n        iLargest = iIdx;\n      }\n    }\n    if( iLargest==0 ){\n      return;\n    }else{\n      int iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);\n      assert( iDb>=0 && iDb<pParse->db->nDb );\n      destroyRootPage(pParse, iLargest, iDb);\n      iDestroyed = iLargest;\n    }\n  }\n}\n\n/*\n** Remove entries from the sqlite_statN tables (for N in (1,2,3))\n** after a DROP INDEX or DROP TABLE command.\n*/\nstatic void sqlite3ClearStatTables(\n  Parse *pParse,         /* The parsing context */\n  int iDb,               /* The database number */\n  const char *zType,     /* \"idx\" or \"tbl\" */\n  const char *zName      /* Name of index or table */\n){\n  int i;\n  const char *zDbName = pParse->db->aDb[iDb].zDbSName;\n  for(i=1; i<=4; i++){\n    char zTab[24];\n    sqlite3_snprintf(sizeof(zTab),zTab,\"sqlite_stat%d\",i);\n    if( sqlite3FindTable(pParse->db, zTab, zDbName) ){\n      sqlite3NestedParse(pParse,\n        \"DELETE FROM %Q.%s WHERE %s=%Q\",\n        zDbName, zTab, zType, zName\n      );\n    }\n  }\n}\n\n/*\n** Generate code to drop a table.\n*/\nvoid sqlite3CodeDropTable(Parse *pParse, Table *pTab, int iDb, int isView){\n  Vdbe *v;\n  sqlite3 *db = pParse->db;\n  Trigger *pTrigger;\n  Db *pDb = &db->aDb[iDb];\n\n  v = sqlite3GetVdbe(pParse);\n  assert( v!=0 );\n  sqlite3BeginWriteOperation(pParse, 1, iDb);\n\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n  if( IsVirtual(pTab) ){\n    sqlite3VdbeAddOp0(v, OP_VBegin);\n  }\n#endif\n\n  /* Drop all triggers associated with the table being dropped. Code\n  ** is generated to remove entries from sqlite_master and/or\n  ** sqlite_temp_master if required.\n  */\n  pTrigger = sqlite3TriggerList(pParse, pTab);\n  while( pTrigger ){\n    assert( pTrigger->pSchema==pTab->pSchema || \n        pTrigger->pSchema==db->aDb[1].pSchema );\n    sqlite3DropTriggerPtr(pParse, pTrigger);\n    pTrigger = pTrigger->pNext;\n  }\n\n#ifndef SQLITE_OMIT_AUTOINCREMENT\n  /* Remove any entries of the sqlite_sequence table associated with\n  ** the table being dropped. This is done before the table is dropped\n  ** at the btree level, in case the sqlite_sequence table needs to\n  ** move as a result of the drop (can happen in auto-vacuum mode).\n  */\n  if( pTab->tabFlags & TF_Autoincrement ){\n    sqlite3NestedParse(pParse,\n      \"DELETE FROM %Q.sqlite_sequence WHERE name=%Q\",\n      pDb->zDbSName, pTab->zName\n    );\n  }\n#endif\n\n  /* Drop all SQLITE_MASTER table and index entries that refer to the\n  ** table. The program name loops through the master table and deletes\n  ** every row that refers to a table of the same name as the one being\n  ** dropped. Triggers are handled separately because a trigger can be\n  ** created in the temp database that refers to a table in another\n  ** database.\n  */\n  sqlite3NestedParse(pParse, \n      \"DELETE FROM %Q.%s WHERE tbl_name=%Q and type!='trigger'\",\n      pDb->zDbSName, MASTER_NAME, pTab->zName);\n  if( !isView && !IsVirtual(pTab) ){\n    destroyTable(pParse, pTab);\n  }\n\n  /* Remove the table entry from SQLite's internal schema and modify\n  ** the schema cookie.\n  */\n  if( IsVirtual(pTab) ){\n    sqlite3VdbeAddOp4(v, OP_VDestroy, iDb, 0, 0, pTab->zName, 0);\n    sqlite3MayAbort(pParse);\n  }\n  sqlite3VdbeAddOp4(v, OP_DropTable, iDb, 0, 0, pTab->zName, 0);\n  sqlite3ChangeCookie(pParse, iDb);\n  sqliteViewResetAll(db, iDb);\n}\n\n/*\n** Return TRUE if shadow tables should be read-only in the current\n** context.\n*/\nint sqlite3ReadOnlyShadowTables(sqlite3 *db){\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n  if( (db->flags & SQLITE_Defensive)!=0\n   && db->pVtabCtx==0\n   && db->nVdbeExec==0\n  ){\n    return 1;\n  }\n#endif\n  return 0;\n}\n\n/*\n** Return true if it is not allowed to drop the given table\n*/\nstatic int tableMayNotBeDropped(sqlite3 *db, Table *pTab){\n  if( sqlite3StrNICmp(pTab->zName, \"sqlite_\", 7)==0 ){\n    if( sqlite3StrNICmp(pTab->zName+7, \"stat\", 4)==0 ) return 0;\n    if( sqlite3StrNICmp(pTab->zName+7, \"parameters\", 10)==0 ) return 0;\n    return 1;\n  }\n  if( (pTab->tabFlags & TF_Shadow)!=0 && sqlite3ReadOnlyShadowTables(db) ){\n    return 1;\n  }\n  return 0;\n}\n\n/*\n** This routine is called to do the work of a DROP TABLE statement.\n** pName is the name of the table to be dropped.\n*/\nvoid sqlite3DropTable(Parse *pParse, SrcList *pName, int isView, int noErr){\n  Table *pTab;\n  Vdbe *v;\n  sqlite3 *db = pParse->db;\n  int iDb;\n\n  if( db->mallocFailed ){\n    goto exit_drop_table;\n  }\n  assert( pParse->nErr==0 );\n  assert( pName->nSrc==1 );\n  if( sqlite3ReadSchema(pParse) ) goto exit_drop_table;\n  if( noErr ) db->suppressErr++;\n  assert( isView==0 || isView==LOCATE_VIEW );\n  pTab = sqlite3LocateTableItem(pParse, isView, &pName->a[0]);\n  if( noErr ) db->suppressErr--;\n\n  if( pTab==0 ){\n    if( noErr ) sqlite3CodeVerifyNamedSchema(pParse, pName->a[0].zDatabase);\n    goto exit_drop_table;\n  }\n  iDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n  assert( iDb>=0 && iDb<db->nDb );\n\n  /* If pTab is a virtual table, call ViewGetColumnNames() to ensure\n  ** it is initialized.\n  */\n  if( IsVirtual(pTab) && sqlite3ViewGetColumnNames(pParse, pTab) ){\n    goto exit_drop_table;\n  }\n#ifndef SQLITE_OMIT_AUTHORIZATION\n  {\n    int code;\n    const char *zTab = SCHEMA_TABLE(iDb);\n    const char *zDb = db->aDb[iDb].zDbSName;\n    const char *zArg2 = 0;\n    if( sqlite3AuthCheck(pParse, SQLITE_DELETE, zTab, 0, zDb)){\n      goto exit_drop_table;\n    }\n    if( isView ){\n      if( !OMIT_TEMPDB && iDb==1 ){\n        code = SQLITE_DROP_TEMP_VIEW;\n      }else{\n        code = SQLITE_DROP_VIEW;\n      }\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n    }else if( IsVirtual(pTab) ){\n      code = SQLITE_DROP_VTABLE;\n      zArg2 = sqlite3GetVTable(db, pTab)->pMod->zName;\n#endif\n    }else{\n      if( !OMIT_TEMPDB && iDb==1 ){\n        code = SQLITE_DROP_TEMP_TABLE;\n      }else{\n        code = SQLITE_DROP_TABLE;\n      }\n    }\n    if( sqlite3AuthCheck(pParse, code, pTab->zName, zArg2, zDb) ){\n      goto exit_drop_table;\n    }\n    if( sqlite3AuthCheck(pParse, SQLITE_DELETE, pTab->zName, 0, zDb) ){\n      goto exit_drop_table;\n    }\n  }\n#endif\n  if( tableMayNotBeDropped(db, pTab) ){\n    sqlite3ErrorMsg(pParse, \"table %s may not be dropped\", pTab->zName);\n    goto exit_drop_table;\n  }\n\n#ifndef SQLITE_OMIT_VIEW\n  /* Ensure DROP TABLE is not used on a view, and DROP VIEW is not used\n  ** on a table.\n  */\n  if( isView && pTab->pSelect==0 ){\n    sqlite3ErrorMsg(pParse, \"use DROP TABLE to delete table %s\", pTab->zName);\n    goto exit_drop_table;\n  }\n  if( !isView && pTab->pSelect ){\n    sqlite3ErrorMsg(pParse, \"use DROP VIEW to delete view %s\", pTab->zName);\n    goto exit_drop_table;\n  }\n#endif\n\n  /* Generate code to remove the table from the master table\n  ** on disk.\n  */\n  v = sqlite3GetVdbe(pParse);\n  if( v ){\n    sqlite3BeginWriteOperation(pParse, 1, iDb);\n    if( !isView ){\n      sqlite3ClearStatTables(pParse, iDb, \"tbl\", pTab->zName);\n      sqlite3FkDropTable(pParse, pName, pTab);\n    }\n    sqlite3CodeDropTable(pParse, pTab, iDb, isView);\n  }\n\nexit_drop_table:\n  sqlite3SrcListDelete(db, pName);\n}\n\n/*\n** This routine is called to create a new foreign key on the table\n** currently under construction.  pFromCol determines which columns\n** in the current table point to the foreign key.  If pFromCol==0 then\n** connect the key to the last column inserted.  pTo is the name of\n** the table referred to (a.k.a the \"parent\" table).  pToCol is a list\n** of tables in the parent pTo table.  flags contains all\n** information about the conflict resolution algorithms specified\n** in the ON DELETE, ON UPDATE and ON INSERT clauses.\n**\n** An FKey structure is created and added to the table currently\n** under construction in the pParse->pNewTable field.\n**\n** The foreign key is set for IMMEDIATE processing.  A subsequent call\n** to sqlite3DeferForeignKey() might change this to DEFERRED.\n*/\nvoid sqlite3CreateForeignKey(\n  Parse *pParse,       /* Parsing context */\n  ExprList *pFromCol,  /* Columns in this table that point to other table */\n  Token *pTo,          /* Name of the other table */\n  ExprList *pToCol,    /* Columns in the other table */\n  int flags            /* Conflict resolution algorithms. */\n){\n  sqlite3 *db = pParse->db;\n#ifndef SQLITE_OMIT_FOREIGN_KEY\n  FKey *pFKey = 0;\n  FKey *pNextTo;\n  Table *p = pParse->pNewTable;\n  int nByte;\n  int i;\n  int nCol;\n  char *z;\n\n  assert( pTo!=0 );\n  if( p==0 || IN_DECLARE_VTAB ) goto fk_end;\n  if( pFromCol==0 ){\n    int iCol = p->nCol-1;\n    if( NEVER(iCol<0) ) goto fk_end;\n    if( pToCol && pToCol->nExpr!=1 ){\n      sqlite3ErrorMsg(pParse, \"foreign key on %s\"\n         \" should reference only one column of table %T\",\n         p->aCol[iCol].zName, pTo);\n      goto fk_end;\n    }\n    nCol = 1;\n  }else if( pToCol && pToCol->nExpr!=pFromCol->nExpr ){\n    sqlite3ErrorMsg(pParse,\n        \"number of columns in foreign key does not match the number of \"\n        \"columns in the referenced table\");\n    goto fk_end;\n  }else{\n    nCol = pFromCol->nExpr;\n  }\n  nByte = sizeof(*pFKey) + (nCol-1)*sizeof(pFKey->aCol[0]) + pTo->n + 1;\n  if( pToCol ){\n    for(i=0; i<pToCol->nExpr; i++){\n      nByte += sqlite3Strlen30(pToCol->a[i].zName) + 1;\n    }\n  }\n  pFKey = sqlite3DbMallocZero(db, nByte );\n  if( pFKey==0 ){\n    goto fk_end;\n  }\n  pFKey->pFrom = p;\n  pFKey->pNextFrom = p->pFKey;\n  z = (char*)&pFKey->aCol[nCol];\n  pFKey->zTo = z;\n  if( IN_RENAME_OBJECT ){\n    sqlite3RenameTokenMap(pParse, (void*)z, pTo);\n  }\n  memcpy(z, pTo->z, pTo->n);\n  z[pTo->n] = 0;\n  sqlite3Dequote(z);\n  z += pTo->n+1;\n  pFKey->nCol = nCol;\n  if( pFromCol==0 ){\n    pFKey->aCol[0].iFrom = p->nCol-1;\n  }else{\n    for(i=0; i<nCol; i++){\n      int j;\n      for(j=0; j<p->nCol; j++){\n        if( sqlite3StrICmp(p->aCol[j].zName, pFromCol->a[i].zName)==0 ){\n          pFKey->aCol[i].iFrom = j;\n          break;\n        }\n      }\n      if( j>=p->nCol ){\n        sqlite3ErrorMsg(pParse, \n          \"unknown column \\\"%s\\\" in foreign key definition\", \n          pFromCol->a[i].zName);\n        goto fk_end;\n      }\n      if( IN_RENAME_OBJECT ){\n        sqlite3RenameTokenRemap(pParse, &pFKey->aCol[i], pFromCol->a[i].zName);\n      }\n    }\n  }\n  if( pToCol ){\n    for(i=0; i<nCol; i++){\n      int n = sqlite3Strlen30(pToCol->a[i].zName);\n      pFKey->aCol[i].zCol = z;\n      if( IN_RENAME_OBJECT ){\n        sqlite3RenameTokenRemap(pParse, z, pToCol->a[i].zName);\n      }\n      memcpy(z, pToCol->a[i].zName, n);\n      z[n] = 0;\n      z += n+1;\n    }\n  }\n  pFKey->isDeferred = 0;\n  pFKey->aAction[0] = (u8)(flags & 0xff);            /* ON DELETE action */\n  pFKey->aAction[1] = (u8)((flags >> 8 ) & 0xff);    /* ON UPDATE action */\n\n  assert( sqlite3SchemaMutexHeld(db, 0, p->pSchema) );\n  pNextTo = (FKey *)sqlite3HashInsert(&p->pSchema->fkeyHash, \n      pFKey->zTo, (void *)pFKey\n  );\n  if( pNextTo==pFKey ){\n    sqlite3OomFault(db);\n    goto fk_end;\n  }\n  if( pNextTo ){\n    assert( pNextTo->pPrevTo==0 );\n    pFKey->pNextTo = pNextTo;\n    pNextTo->pPrevTo = pFKey;\n  }\n\n  /* Link the foreign key to the table as the last step.\n  */\n  p->pFKey = pFKey;\n  pFKey = 0;\n\nfk_end:\n  sqlite3DbFree(db, pFKey);\n#endif /* !defined(SQLITE_OMIT_FOREIGN_KEY) */\n  sqlite3ExprListDelete(db, pFromCol);\n  sqlite3ExprListDelete(db, pToCol);\n}\n\n/*\n** This routine is called when an INITIALLY IMMEDIATE or INITIALLY DEFERRED\n** clause is seen as part of a foreign key definition.  The isDeferred\n** parameter is 1 for INITIALLY DEFERRED and 0 for INITIALLY IMMEDIATE.\n** The behavior of the most recently created foreign key is adjusted\n** accordingly.\n*/\nvoid sqlite3DeferForeignKey(Parse *pParse, int isDeferred){\n#ifndef SQLITE_OMIT_FOREIGN_KEY\n  Table *pTab;\n  FKey *pFKey;\n  if( (pTab = pParse->pNewTable)==0 || (pFKey = pTab->pFKey)==0 ) return;\n  assert( isDeferred==0 || isDeferred==1 ); /* EV: R-30323-21917 */\n  pFKey->isDeferred = (u8)isDeferred;\n#endif\n}\n\n/*\n** Generate code that will erase and refill index *pIdx.  This is\n** used to initialize a newly created index or to recompute the\n** content of an index in response to a REINDEX command.\n**\n** if memRootPage is not negative, it means that the index is newly\n** created.  The register specified by memRootPage contains the\n** root page number of the index.  If memRootPage is negative, then\n** the index already exists and must be cleared before being refilled and\n** the root page number of the index is taken from pIndex->tnum.\n*/\nstatic void sqlite3RefillIndex(Parse *pParse, Index *pIndex, int memRootPage){\n  Table *pTab = pIndex->pTable;  /* The table that is indexed */\n  int iTab = pParse->nTab++;     /* Btree cursor used for pTab */\n  int iIdx = pParse->nTab++;     /* Btree cursor used for pIndex */\n  int iSorter;                   /* Cursor opened by OpenSorter (if in use) */\n  int addr1;                     /* Address of top of loop */\n  int addr2;                     /* Address to jump to for next iteration */\n  int tnum;                      /* Root page of index */\n  int iPartIdxLabel;             /* Jump to this label to skip a row */\n  Vdbe *v;                       /* Generate code into this virtual machine */\n  KeyInfo *pKey;                 /* KeyInfo for index */\n  int regRecord;                 /* Register holding assembled index record */\n  sqlite3 *db = pParse->db;      /* The database connection */\n  int iDb = sqlite3SchemaToIndex(db, pIndex->pSchema);\n\n#ifndef SQLITE_OMIT_AUTHORIZATION\n  if( sqlite3AuthCheck(pParse, SQLITE_REINDEX, pIndex->zName, 0,\n      db->aDb[iDb].zDbSName ) ){\n    return;\n  }\n#endif\n\n  /* Require a write-lock on the table to perform this operation */\n  sqlite3TableLock(pParse, iDb, pTab->tnum, 1, pTab->zName);\n\n  v = sqlite3GetVdbe(pParse);\n  if( v==0 ) return;\n  if( memRootPage>=0 ){\n    tnum = memRootPage;\n  }else{\n    tnum = pIndex->tnum;\n  }\n  pKey = sqlite3KeyInfoOfIndex(pParse, pIndex);\n  assert( pKey!=0 || db->mallocFailed || pParse->nErr );\n\n  /* Open the sorter cursor if we are to use one. */\n  iSorter = pParse->nTab++;\n  sqlite3VdbeAddOp4(v, OP_SorterOpen, iSorter, 0, pIndex->nKeyCol, (char*)\n                    sqlite3KeyInfoRef(pKey), P4_KEYINFO);\n\n  /* Open the table. Loop through all rows of the table, inserting index\n  ** records into the sorter. */\n  sqlite3OpenTable(pParse, iTab, iDb, pTab, OP_OpenRead);\n  addr1 = sqlite3VdbeAddOp2(v, OP_Rewind, iTab, 0); VdbeCoverage(v);\n  regRecord = sqlite3GetTempReg(pParse);\n  sqlite3MultiWrite(pParse);\n\n  sqlite3GenerateIndexKey(pParse,pIndex,iTab,regRecord,0,&iPartIdxLabel,0,0);\n  sqlite3VdbeAddOp2(v, OP_SorterInsert, iSorter, regRecord);\n  sqlite3ResolvePartIdxLabel(pParse, iPartIdxLabel);\n  sqlite3VdbeAddOp2(v, OP_Next, iTab, addr1+1); VdbeCoverage(v);\n  sqlite3VdbeJumpHere(v, addr1);\n  if( memRootPage<0 ) sqlite3VdbeAddOp2(v, OP_Clear, tnum, iDb);\n  sqlite3VdbeAddOp4(v, OP_OpenWrite, iIdx, tnum, iDb, \n                    (char *)pKey, P4_KEYINFO);\n  sqlite3VdbeChangeP5(v, OPFLAG_BULKCSR|((memRootPage>=0)?OPFLAG_P2ISREG:0));\n\n  addr1 = sqlite3VdbeAddOp2(v, OP_SorterSort, iSorter, 0); VdbeCoverage(v);\n  if( IsUniqueIndex(pIndex) ){\n    int j2 = sqlite3VdbeGoto(v, 1);\n    addr2 = sqlite3VdbeCurrentAddr(v);\n    sqlite3VdbeVerifyAbortable(v, OE_Abort);\n    sqlite3VdbeAddOp4Int(v, OP_SorterCompare, iSorter, j2, regRecord,\n                         pIndex->nKeyCol); VdbeCoverage(v);\n    sqlite3UniqueConstraint(pParse, OE_Abort, pIndex);\n    sqlite3VdbeJumpHere(v, j2);\n  }else{\n    /* Most CREATE INDEX and REINDEX statements that are not UNIQUE can not\n    ** abort. The exception is if one of the indexed expressions contains a\n    ** user function that throws an exception when it is evaluated. But the\n    ** overhead of adding a statement journal to a CREATE INDEX statement is\n    ** very small (since most of the pages written do not contain content that\n    ** needs to be restored if the statement aborts), so we call \n    ** sqlite3MayAbort() for all CREATE INDEX statements.  */\n    sqlite3MayAbort(pParse);\n    addr2 = sqlite3VdbeCurrentAddr(v);\n  }\n  sqlite3VdbeAddOp3(v, OP_SorterData, iSorter, regRecord, iIdx);\n  if( !pIndex->bAscKeyBug ){\n    /* This OP_SeekEnd opcode makes index insert for a REINDEX go much\n    ** faster by avoiding unnecessary seeks.  But the optimization does\n    ** not work for UNIQUE constraint indexes on WITHOUT ROWID tables\n    ** with DESC primary keys, since those indexes have there keys in\n    ** a different order from the main table.\n    ** See ticket: https://www.sqlite.org/src/info/bba7b69f9849b5bf\n    */\n    sqlite3VdbeAddOp1(v, OP_SeekEnd, iIdx);\n  }\n  sqlite3VdbeAddOp2(v, OP_IdxInsert, iIdx, regRecord);\n  sqlite3VdbeChangeP5(v, OPFLAG_USESEEKRESULT);\n  sqlite3ReleaseTempReg(pParse, regRecord);\n  sqlite3VdbeAddOp2(v, OP_SorterNext, iSorter, addr2); VdbeCoverage(v);\n  sqlite3VdbeJumpHere(v, addr1);\n\n  sqlite3VdbeAddOp1(v, OP_Close, iTab);\n  sqlite3VdbeAddOp1(v, OP_Close, iIdx);\n  sqlite3VdbeAddOp1(v, OP_Close, iSorter);\n}\n\n/*\n** Allocate heap space to hold an Index object with nCol columns.\n**\n** Increase the allocation size to provide an extra nExtra bytes\n** of 8-byte aligned space after the Index object and return a\n** pointer to this extra space in *ppExtra.\n*/\nIndex *sqlite3AllocateIndexObject(\n  sqlite3 *db,         /* Database connection */\n  i16 nCol,            /* Total number of columns in the index */\n  int nExtra,          /* Number of bytes of extra space to alloc */\n  char **ppExtra       /* Pointer to the \"extra\" space */\n){\n  Index *p;            /* Allocated index object */\n  int nByte;           /* Bytes of space for Index object + arrays */\n\n  nByte = ROUND8(sizeof(Index)) +              /* Index structure  */\n          ROUND8(sizeof(char*)*nCol) +         /* Index.azColl     */\n          ROUND8(sizeof(LogEst)*(nCol+1) +     /* Index.aiRowLogEst   */\n                 sizeof(i16)*nCol +            /* Index.aiColumn   */\n                 sizeof(u8)*nCol);             /* Index.aSortOrder */\n  p = sqlite3DbMallocZero(db, nByte + nExtra);\n  if( p ){\n    char *pExtra = ((char*)p)+ROUND8(sizeof(Index));\n    p->azColl = (const char**)pExtra; pExtra += ROUND8(sizeof(char*)*nCol);\n    p->aiRowLogEst = (LogEst*)pExtra; pExtra += sizeof(LogEst)*(nCol+1);\n    p->aiColumn = (i16*)pExtra;       pExtra += sizeof(i16)*nCol;\n    p->aSortOrder = (u8*)pExtra;\n    p->nColumn = nCol;\n    p->nKeyCol = nCol - 1;\n    *ppExtra = ((char*)p) + nByte;\n  }\n  return p;\n}\n\n/*\n** If expression list pList contains an expression that was parsed with\n** an explicit \"NULLS FIRST\" or \"NULLS LAST\" clause, leave an error in\n** pParse and return non-zero. Otherwise, return zero.\n*/\nint sqlite3HasExplicitNulls(Parse *pParse, ExprList *pList){\n  if( pList ){\n    int i;\n    for(i=0; i<pList->nExpr; i++){\n      if( pList->a[i].bNulls ){\n        u8 sf = pList->a[i].sortFlags;\n        sqlite3ErrorMsg(pParse, \"unsupported use of NULLS %s\", \n            (sf==0 || sf==3) ? \"FIRST\" : \"LAST\"\n        );\n        return 1;\n      }\n    }\n  }\n  return 0;\n}\n\n/*\n** Create a new index for an SQL table.  pName1.pName2 is the name of the index \n** and pTblList is the name of the table that is to be indexed.  Both will \n** be NULL for a primary key or an index that is created to satisfy a\n** UNIQUE constraint.  If pTable and pIndex are NULL, use pParse->pNewTable\n** as the table to be indexed.  pParse->pNewTable is a table that is\n** currently being constructed by a CREATE TABLE statement.\n**\n** pList is a list of columns to be indexed.  pList will be NULL if this\n** is a primary key or unique-constraint on the most recent column added\n** to the table currently under construction.  \n*/\nvoid sqlite3CreateIndex(\n  Parse *pParse,     /* All information about this parse */\n  Token *pName1,     /* First part of index name. May be NULL */\n  Token *pName2,     /* Second part of index name. May be NULL */\n  SrcList *pTblName, /* Table to index. Use pParse->pNewTable if 0 */\n  ExprList *pList,   /* A list of columns to be indexed */\n  int onError,       /* OE_Abort, OE_Ignore, OE_Replace, or OE_None */\n  Token *pStart,     /* The CREATE token that begins this statement */\n  Expr *pPIWhere,    /* WHERE clause for partial indices */\n  int sortOrder,     /* Sort order of primary key when pList==NULL */\n  int ifNotExist,    /* Omit error if index already exists */\n  u8 idxType         /* The index type */\n){\n  Table *pTab = 0;     /* Table to be indexed */\n  Index *pIndex = 0;   /* The index to be created */\n  char *zName = 0;     /* Name of the index */\n  int nName;           /* Number of characters in zName */\n  int i, j;\n  DbFixer sFix;        /* For assigning database names to pTable */\n  int sortOrderMask;   /* 1 to honor DESC in index.  0 to ignore. */\n  sqlite3 *db = pParse->db;\n  Db *pDb;             /* The specific table containing the indexed database */\n  int iDb;             /* Index of the database that is being written */\n  Token *pName = 0;    /* Unqualified name of the index to create */\n  struct ExprList_item *pListItem; /* For looping over pList */\n  int nExtra = 0;                  /* Space allocated for zExtra[] */\n  int nExtraCol;                   /* Number of extra columns needed */\n  char *zExtra = 0;                /* Extra space after the Index object */\n  Index *pPk = 0;      /* PRIMARY KEY index for WITHOUT ROWID tables */\n\n  if( db->mallocFailed || pParse->nErr>0 ){\n    goto exit_create_index;\n  }\n  if( IN_DECLARE_VTAB && idxType!=SQLITE_IDXTYPE_PRIMARYKEY ){\n    goto exit_create_index;\n  }\n  if( SQLITE_OK!=sqlite3ReadSchema(pParse) ){\n    goto exit_create_index;\n  }\n  if( sqlite3HasExplicitNulls(pParse, pList) ){\n    goto exit_create_index;\n  }\n\n  /*\n  ** Find the table that is to be indexed.  Return early if not found.\n  */\n  if( pTblName!=0 ){\n\n    /* Use the two-part index name to determine the database \n    ** to search for the table. 'Fix' the table name to this db\n    ** before looking up the table.\n    */\n    assert( pName1 && pName2 );\n    iDb = sqlite3TwoPartName(pParse, pName1, pName2, &pName);\n    if( iDb<0 ) goto exit_create_index;\n    assert( pName && pName->z );\n\n#ifndef SQLITE_OMIT_TEMPDB\n    /* If the index name was unqualified, check if the table\n    ** is a temp table. If so, set the database to 1. Do not do this\n    ** if initialising a database schema.\n    */\n    if( !db->init.busy ){\n      pTab = sqlite3SrcListLookup(pParse, pTblName);\n      if( pName2->n==0 && pTab && pTab->pSchema==db->aDb[1].pSchema ){\n        iDb = 1;\n      }\n    }\n#endif\n\n    sqlite3FixInit(&sFix, pParse, iDb, \"index\", pName);\n    if( sqlite3FixSrcList(&sFix, pTblName) ){\n      /* Because the parser constructs pTblName from a single identifier,\n      ** sqlite3FixSrcList can never fail. */\n      assert(0);\n    }\n    pTab = sqlite3LocateTableItem(pParse, 0, &pTblName->a[0]);\n    assert( db->mallocFailed==0 || pTab==0 );\n    if( pTab==0 ) goto exit_create_index;\n    if( iDb==1 && db->aDb[iDb].pSchema!=pTab->pSchema ){\n      sqlite3ErrorMsg(pParse, \n           \"cannot create a TEMP index on non-TEMP table \\\"%s\\\"\",\n           pTab->zName);\n      goto exit_create_index;\n    }\n    if( !HasRowid(pTab) ) pPk = sqlite3PrimaryKeyIndex(pTab);\n  }else{\n    assert( pName==0 );\n    assert( pStart==0 );\n    pTab = pParse->pNewTable;\n    if( !pTab ) goto exit_create_index;\n    iDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n  }\n  pDb = &db->aDb[iDb];\n\n  assert( pTab!=0 );\n  assert( pParse->nErr==0 );\n  if( sqlite3StrNICmp(pTab->zName, \"sqlite_\", 7)==0 \n       && db->init.busy==0\n       && pTblName!=0\n#if SQLITE_USER_AUTHENTICATION\n       && sqlite3UserAuthTable(pTab->zName)==0\n#endif\n#ifdef SQLITE_ALLOW_SQLITE_MASTER_INDEX\n       && sqlite3StrICmp(&pTab->zName[7],\"master\")!=0\n#endif\n ){\n    sqlite3ErrorMsg(pParse, \"table %s may not be indexed\", pTab->zName);\n    goto exit_create_index;\n  }\n#ifndef SQLITE_OMIT_VIEW\n  if( pTab->pSelect ){\n    sqlite3ErrorMsg(pParse, \"views may not be indexed\");\n    goto exit_create_index;\n  }\n#endif\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n  if( IsVirtual(pTab) ){\n    sqlite3ErrorMsg(pParse, \"virtual tables may not be indexed\");\n    goto exit_create_index;\n  }\n#endif\n\n  /*\n  ** Find the name of the index.  Make sure there is not already another\n  ** index or table with the same name.  \n  **\n  ** Exception:  If we are reading the names of permanent indices from the\n  ** sqlite_master table (because some other process changed the schema) and\n  ** one of the index names collides with the name of a temporary table or\n  ** index, then we will continue to process this index.\n  **\n  ** If pName==0 it means that we are\n  ** dealing with a primary key or UNIQUE constraint.  We have to invent our\n  ** own name.\n  */\n  if( pName ){\n    zName = sqlite3NameFromToken(db, pName);\n    if( zName==0 ) goto exit_create_index;\n    assert( pName->z!=0 );\n    if( SQLITE_OK!=sqlite3CheckObjectName(pParse, zName,\"index\",pTab->zName) ){\n      goto exit_create_index;\n    }\n    if( !IN_RENAME_OBJECT ){\n      if( !db->init.busy ){\n        if( sqlite3FindTable(db, zName, 0)!=0 ){\n          sqlite3ErrorMsg(pParse, \"there is already a table named %s\", zName);\n          goto exit_create_index;\n        }\n      }\n      if( sqlite3FindIndex(db, zName, pDb->zDbSName)!=0 ){\n        if( !ifNotExist ){\n          sqlite3ErrorMsg(pParse, \"index %s already exists\", zName);\n        }else{\n          assert( !db->init.busy );\n          sqlite3CodeVerifySchema(pParse, iDb);\n        }\n        goto exit_create_index;\n      }\n    }\n  }else{\n    int n;\n    Index *pLoop;\n    for(pLoop=pTab->pIndex, n=1; pLoop; pLoop=pLoop->pNext, n++){}\n    zName = sqlite3MPrintf(db, \"sqlite_autoindex_%s_%d\", pTab->zName, n);\n    if( zName==0 ){\n      goto exit_create_index;\n    }\n\n    /* Automatic index names generated from within sqlite3_declare_vtab()\n    ** must have names that are distinct from normal automatic index names.\n    ** The following statement converts \"sqlite3_autoindex...\" into\n    ** \"sqlite3_butoindex...\" in order to make the names distinct.\n    ** The \"vtab_err.test\" test demonstrates the need of this statement. */\n    if( IN_SPECIAL_PARSE ) zName[7]++;\n  }\n\n  /* Check for authorization to create an index.\n  */\n#ifndef SQLITE_OMIT_AUTHORIZATION\n  if( !IN_RENAME_OBJECT ){\n    const char *zDb = pDb->zDbSName;\n    if( sqlite3AuthCheck(pParse, SQLITE_INSERT, SCHEMA_TABLE(iDb), 0, zDb) ){\n      goto exit_create_index;\n    }\n    i = SQLITE_CREATE_INDEX;\n    if( !OMIT_TEMPDB && iDb==1 ) i = SQLITE_CREATE_TEMP_INDEX;\n    if( sqlite3AuthCheck(pParse, i, zName, pTab->zName, zDb) ){\n      goto exit_create_index;\n    }\n  }\n#endif\n\n  /* If pList==0, it means this routine was called to make a primary\n  ** key out of the last column added to the table under construction.\n  ** So create a fake list to simulate this.\n  */\n  if( pList==0 ){\n    Token prevCol;\n    Column *pCol = &pTab->aCol[pTab->nCol-1];\n    pCol->colFlags |= COLFLAG_UNIQUE;\n    sqlite3TokenInit(&prevCol, pCol->zName);\n    pList = sqlite3ExprListAppend(pParse, 0,\n              sqlite3ExprAlloc(db, TK_ID, &prevCol, 0));\n    if( pList==0 ) goto exit_create_index;\n    assert( pList->nExpr==1 );\n    sqlite3ExprListSetSortOrder(pList, sortOrder, SQLITE_SO_UNDEFINED);\n  }else{\n    sqlite3ExprListCheckLength(pParse, pList, \"index\");\n    if( pParse->nErr ) goto exit_create_index;\n  }\n\n  /* Figure out how many bytes of space are required to store explicitly\n  ** specified collation sequence names.\n  */\n  for(i=0; i<pList->nExpr; i++){\n    Expr *pExpr = pList->a[i].pExpr;\n    assert( pExpr!=0 );\n    if( pExpr->op==TK_COLLATE ){\n      nExtra += (1 + sqlite3Strlen30(pExpr->u.zToken));\n    }\n  }\n\n  /* \n  ** Allocate the index structure. \n  */\n  nName = sqlite3Strlen30(zName);\n  nExtraCol = pPk ? pPk->nKeyCol : 1;\n  assert( pList->nExpr + nExtraCol <= 32767 /* Fits in i16 */ );\n  pIndex = sqlite3AllocateIndexObject(db, pList->nExpr + nExtraCol,\n                                      nName + nExtra + 1, &zExtra);\n  if( db->mallocFailed ){\n    goto exit_create_index;\n  }\n  assert( EIGHT_BYTE_ALIGNMENT(pIndex->aiRowLogEst) );\n  assert( EIGHT_BYTE_ALIGNMENT(pIndex->azColl) );\n  pIndex->zName = zExtra;\n  zExtra += nName + 1;\n  memcpy(pIndex->zName, zName, nName+1);\n  pIndex->pTable = pTab;\n  pIndex->onError = (u8)onError;\n  pIndex->uniqNotNull = onError!=OE_None;\n  pIndex->idxType = idxType;\n  pIndex->pSchema = db->aDb[iDb].pSchema;\n  pIndex->nKeyCol = pList->nExpr;\n  if( pPIWhere ){\n    sqlite3ResolveSelfReference(pParse, pTab, NC_PartIdx, pPIWhere, 0);\n    pIndex->pPartIdxWhere = pPIWhere;\n    pPIWhere = 0;\n  }\n  assert( sqlite3SchemaMutexHeld(db, iDb, 0) );\n\n  /* Check to see if we should honor DESC requests on index columns\n  */\n  if( pDb->pSchema->file_format>=4 ){\n    sortOrderMask = -1;   /* Honor DESC */\n  }else{\n    sortOrderMask = 0;    /* Ignore DESC */\n  }\n\n  /* Analyze the list of expressions that form the terms of the index and\n  ** report any errors.  In the common case where the expression is exactly\n  ** a table column, store that column in aiColumn[].  For general expressions,\n  ** populate pIndex->aColExpr and store XN_EXPR (-2) in aiColumn[].\n  **\n  ** TODO: Issue a warning if two or more columns of the index are identical.\n  ** TODO: Issue a warning if the table primary key is used as part of the\n  ** index key.\n  */\n  pListItem = pList->a;\n  if( IN_RENAME_OBJECT ){\n    pIndex->aColExpr = pList;\n    pList = 0;\n  }\n  for(i=0; i<pIndex->nKeyCol; i++, pListItem++){\n    Expr *pCExpr;                  /* The i-th index expression */\n    int requestedSortOrder;        /* ASC or DESC on the i-th expression */\n    const char *zColl;             /* Collation sequence name */\n\n    sqlite3StringToId(pListItem->pExpr);\n    sqlite3ResolveSelfReference(pParse, pTab, NC_IdxExpr, pListItem->pExpr, 0);\n    if( pParse->nErr ) goto exit_create_index;\n    pCExpr = sqlite3ExprSkipCollate(pListItem->pExpr);\n    if( pCExpr->op!=TK_COLUMN ){\n      if( pTab==pParse->pNewTable ){\n        sqlite3ErrorMsg(pParse, \"expressions prohibited in PRIMARY KEY and \"\n                                \"UNIQUE constraints\");\n        goto exit_create_index;\n      }\n      if( pIndex->aColExpr==0 ){\n        pIndex->aColExpr = pList;\n        pList = 0;\n      }\n      j = XN_EXPR;\n      pIndex->aiColumn[i] = XN_EXPR;\n      pIndex->uniqNotNull = 0;\n    }else{\n      j = pCExpr->iColumn;\n      assert( j<=0x7fff );\n      if( j<0 ){\n        j = pTab->iPKey;\n      }else{\n        if( pTab->aCol[j].notNull==0 ){\n          pIndex->uniqNotNull = 0;\n        }\n        if( pTab->aCol[j].colFlags & COLFLAG_VIRTUAL ){\n          pIndex->bHasVCol = 1;\n        }\n      }\n      pIndex->aiColumn[i] = (i16)j;\n    }\n    zColl = 0;\n    if( pListItem->pExpr->op==TK_COLLATE ){\n      int nColl;\n      zColl = pListItem->pExpr->u.zToken;\n      nColl = sqlite3Strlen30(zColl) + 1;\n      assert( nExtra>=nColl );\n      memcpy(zExtra, zColl, nColl);\n      zColl = zExtra;\n      zExtra += nColl;\n      nExtra -= nColl;\n    }else if( j>=0 ){\n      zColl = pTab->aCol[j].zColl;\n    }\n    if( !zColl ) zColl = sqlite3StrBINARY;\n    if( !db->init.busy && !sqlite3LocateCollSeq(pParse, zColl) ){\n      goto exit_create_index;\n    }\n    pIndex->azColl[i] = zColl;\n    requestedSortOrder = pListItem->sortFlags & sortOrderMask;\n    pIndex->aSortOrder[i] = (u8)requestedSortOrder;\n  }\n\n  /* Append the table key to the end of the index.  For WITHOUT ROWID\n  ** tables (when pPk!=0) this will be the declared PRIMARY KEY.  For\n  ** normal tables (when pPk==0) this will be the rowid.\n  */\n  if( pPk ){\n    for(j=0; j<pPk->nKeyCol; j++){\n      int x = pPk->aiColumn[j];\n      assert( x>=0 );\n      if( isDupColumn(pIndex, pIndex->nKeyCol, pPk, j) ){\n        pIndex->nColumn--; \n      }else{\n        testcase( hasColumn(pIndex->aiColumn,pIndex->nKeyCol,x) );\n        pIndex->aiColumn[i] = x;\n        pIndex->azColl[i] = pPk->azColl[j];\n        pIndex->aSortOrder[i] = pPk->aSortOrder[j];\n        i++;\n      }\n    }\n    assert( i==pIndex->nColumn );\n  }else{\n    pIndex->aiColumn[i] = XN_ROWID;\n    pIndex->azColl[i] = sqlite3StrBINARY;\n  }\n  sqlite3DefaultRowEst(pIndex);\n  if( pParse->pNewTable==0 ) estimateIndexWidth(pIndex);\n\n  /* If this index contains every column of its table, then mark\n  ** it as a covering index */\n  assert( HasRowid(pTab) \n      || pTab->iPKey<0 || sqlite3TableColumnToIndex(pIndex, pTab->iPKey)>=0 );\n  recomputeColumnsNotIndexed(pIndex);\n  if( pTblName!=0 && pIndex->nColumn>=pTab->nCol ){\n    pIndex->isCovering = 1;\n    for(j=0; j<pTab->nCol; j++){\n      if( j==pTab->iPKey ) continue;\n      if( sqlite3TableColumnToIndex(pIndex,j)>=0 ) continue;\n      pIndex->isCovering = 0;\n      break;\n    }\n  }\n\n  if( pTab==pParse->pNewTable ){\n    /* This routine has been called to create an automatic index as a\n    ** result of a PRIMARY KEY or UNIQUE clause on a column definition, or\n    ** a PRIMARY KEY or UNIQUE clause following the column definitions.\n    ** i.e. one of:\n    **\n    ** CREATE TABLE t(x PRIMARY KEY, y);\n    ** CREATE TABLE t(x, y, UNIQUE(x, y));\n    **\n    ** Either way, check to see if the table already has such an index. If\n    ** so, don't bother creating this one. This only applies to\n    ** automatically created indices. Users can do as they wish with\n    ** explicit indices.\n    **\n    ** Two UNIQUE or PRIMARY KEY constraints are considered equivalent\n    ** (and thus suppressing the second one) even if they have different\n    ** sort orders.\n    **\n    ** If there are different collating sequences or if the columns of\n    ** the constraint occur in different orders, then the constraints are\n    ** considered distinct and both result in separate indices.\n    */\n    Index *pIdx;\n    for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){\n      int k;\n      assert( IsUniqueIndex(pIdx) );\n      assert( pIdx->idxType!=SQLITE_IDXTYPE_APPDEF );\n      assert( IsUniqueIndex(pIndex) );\n\n      if( pIdx->nKeyCol!=pIndex->nKeyCol ) continue;\n      for(k=0; k<pIdx->nKeyCol; k++){\n        const char *z1;\n        const char *z2;\n        assert( pIdx->aiColumn[k]>=0 );\n        if( pIdx->aiColumn[k]!=pIndex->aiColumn[k] ) break;\n        z1 = pIdx->azColl[k];\n        z2 = pIndex->azColl[k];\n        if( sqlite3StrICmp(z1, z2) ) break;\n      }\n      if( k==pIdx->nKeyCol ){\n        if( pIdx->onError!=pIndex->onError ){\n          /* This constraint creates the same index as a previous\n          ** constraint specified somewhere in the CREATE TABLE statement.\n          ** However the ON CONFLICT clauses are different. If both this \n          ** constraint and the previous equivalent constraint have explicit\n          ** ON CONFLICT clauses this is an error. Otherwise, use the\n          ** explicitly specified behavior for the index.\n          */\n          if( !(pIdx->onError==OE_Default || pIndex->onError==OE_Default) ){\n            sqlite3ErrorMsg(pParse, \n                \"conflicting ON CONFLICT clauses specified\", 0);\n          }\n          if( pIdx->onError==OE_Default ){\n            pIdx->onError = pIndex->onError;\n          }\n        }\n        if( idxType==SQLITE_IDXTYPE_PRIMARYKEY ) pIdx->idxType = idxType;\n        if( IN_RENAME_OBJECT ){\n          pIndex->pNext = pParse->pNewIndex;\n          pParse->pNewIndex = pIndex;\n          pIndex = 0;\n        }\n        goto exit_create_index;\n      }\n    }\n  }\n\n  if( !IN_RENAME_OBJECT ){\n\n    /* Link the new Index structure to its table and to the other\n    ** in-memory database structures. \n    */\n    assert( pParse->nErr==0 );\n    if( db->init.busy ){\n      Index *p;\n      assert( !IN_SPECIAL_PARSE );\n      assert( sqlite3SchemaMutexHeld(db, 0, pIndex->pSchema) );\n      if( pTblName!=0 ){\n        pIndex->tnum = db->init.newTnum;\n        if( sqlite3IndexHasDuplicateRootPage(pIndex) ){\n          sqlite3ErrorMsg(pParse, \"invalid rootpage\");\n          pParse->rc = SQLITE_CORRUPT_BKPT;\n          goto exit_create_index;\n        }\n      }\n      p = sqlite3HashInsert(&pIndex->pSchema->idxHash, \n          pIndex->zName, pIndex);\n      if( p ){\n        assert( p==pIndex );  /* Malloc must have failed */\n        sqlite3OomFault(db);\n        goto exit_create_index;\n      }\n      db->mDbFlags |= DBFLAG_SchemaChange;\n    }\n\n    /* If this is the initial CREATE INDEX statement (or CREATE TABLE if the\n    ** index is an implied index for a UNIQUE or PRIMARY KEY constraint) then\n    ** emit code to allocate the index rootpage on disk and make an entry for\n    ** the index in the sqlite_master table and populate the index with\n    ** content.  But, do not do this if we are simply reading the sqlite_master\n    ** table to parse the schema, or if this index is the PRIMARY KEY index\n    ** of a WITHOUT ROWID table.\n    **\n    ** If pTblName==0 it means this index is generated as an implied PRIMARY KEY\n    ** or UNIQUE index in a CREATE TABLE statement.  Since the table\n    ** has just been created, it contains no data and the index initialization\n    ** step can be skipped.\n    */\n    else if( HasRowid(pTab) || pTblName!=0 ){\n      Vdbe *v;\n      char *zStmt;\n      int iMem = ++pParse->nMem;\n\n      v = sqlite3GetVdbe(pParse);\n      if( v==0 ) goto exit_create_index;\n\n      sqlite3BeginWriteOperation(pParse, 1, iDb);\n\n      /* Create the rootpage for the index using CreateIndex. But before\n      ** doing so, code a Noop instruction and store its address in \n      ** Index.tnum. This is required in case this index is actually a \n      ** PRIMARY KEY and the table is actually a WITHOUT ROWID table. In \n      ** that case the convertToWithoutRowidTable() routine will replace\n      ** the Noop with a Goto to jump over the VDBE code generated below. */\n      pIndex->tnum = sqlite3VdbeAddOp0(v, OP_Noop);\n      sqlite3VdbeAddOp3(v, OP_CreateBtree, iDb, iMem, BTREE_BLOBKEY);\n\n      /* Gather the complete text of the CREATE INDEX statement into\n      ** the zStmt variable\n      */\n      assert( pName!=0 || pStart==0 );\n      if( pStart ){\n        int n = (int)(pParse->sLastToken.z - pName->z) + pParse->sLastToken.n;\n        if( pName->z[n-1]==';' ) n--;\n        /* A named index with an explicit CREATE INDEX statement */\n        zStmt = sqlite3MPrintf(db, \"CREATE%s INDEX %.*s\",\n            onError==OE_None ? \"\" : \" UNIQUE\", n, pName->z);\n      }else{\n        /* An automatic index created by a PRIMARY KEY or UNIQUE constraint */\n        /* zStmt = sqlite3MPrintf(\"\"); */\n        zStmt = 0;\n      }\n\n      /* Add an entry in sqlite_master for this index\n      */\n      sqlite3NestedParse(pParse, \n          \"INSERT INTO %Q.%s VALUES('index',%Q,%Q,#%d,%Q);\",\n          db->aDb[iDb].zDbSName, MASTER_NAME,\n          pIndex->zName,\n          pTab->zName,\n          iMem,\n          zStmt\n          );\n      sqlite3DbFree(db, zStmt);\n\n      /* Fill the index with data and reparse the schema. Code an OP_Expire\n      ** to invalidate all pre-compiled statements.\n      */\n      if( pTblName ){\n        sqlite3RefillIndex(pParse, pIndex, iMem);\n        sqlite3ChangeCookie(pParse, iDb);\n        sqlite3VdbeAddParseSchemaOp(v, iDb,\n            sqlite3MPrintf(db, \"name='%q' AND type='index'\", pIndex->zName));\n        sqlite3VdbeAddOp2(v, OP_Expire, 0, 1);\n      }\n\n      sqlite3VdbeJumpHere(v, pIndex->tnum);\n    }\n  }\n\n  /* When adding an index to the list of indices for a table, make\n  ** sure all indices labeled OE_Replace come after all those labeled\n  ** OE_Ignore.  This is necessary for the correct constraint check\n  ** processing (in sqlite3GenerateConstraintChecks()) as part of\n  ** UPDATE and INSERT statements.  \n  */\n  if( db->init.busy || pTblName==0 ){\n    if( onError!=OE_Replace || pTab->pIndex==0\n         || pTab->pIndex->onError==OE_Replace){\n      pIndex->pNext = pTab->pIndex;\n      pTab->pIndex = pIndex;\n    }else{\n      Index *pOther = pTab->pIndex;\n      while( pOther->pNext && pOther->pNext->onError!=OE_Replace ){\n        pOther = pOther->pNext;\n      }\n      pIndex->pNext = pOther->pNext;\n      pOther->pNext = pIndex;\n    }\n    pIndex = 0;\n  }\n  else if( IN_RENAME_OBJECT ){\n    assert( pParse->pNewIndex==0 );\n    pParse->pNewIndex = pIndex;\n    pIndex = 0;\n  }\n\n  /* Clean up before exiting */\nexit_create_index:\n  if( pIndex ) sqlite3FreeIndex(db, pIndex);\n  sqlite3ExprDelete(db, pPIWhere);\n  sqlite3ExprListDelete(db, pList);\n  sqlite3SrcListDelete(db, pTblName);\n  sqlite3DbFree(db, zName);\n}\n\n/*\n** Fill the Index.aiRowEst[] array with default information - information\n** to be used when we have not run the ANALYZE command.\n**\n** aiRowEst[0] is supposed to contain the number of elements in the index.\n** Since we do not know, guess 1 million.  aiRowEst[1] is an estimate of the\n** number of rows in the table that match any particular value of the\n** first column of the index.  aiRowEst[2] is an estimate of the number\n** of rows that match any particular combination of the first 2 columns\n** of the index.  And so forth.  It must always be the case that\n*\n**           aiRowEst[N]<=aiRowEst[N-1]\n**           aiRowEst[N]>=1\n**\n** Apart from that, we have little to go on besides intuition as to\n** how aiRowEst[] should be initialized.  The numbers generated here\n** are based on typical values found in actual indices.\n*/\nvoid sqlite3DefaultRowEst(Index *pIdx){\n  /*                10,  9,  8,  7,  6 */\n  LogEst aVal[] = { 33, 32, 30, 28, 26 };\n  LogEst *a = pIdx->aiRowLogEst;\n  int nCopy = MIN(ArraySize(aVal), pIdx->nKeyCol);\n  int i;\n\n  /* Indexes with default row estimates should not have stat1 data */\n  assert( !pIdx->hasStat1 );\n\n  /* Set the first entry (number of rows in the index) to the estimated \n  ** number of rows in the table, or half the number of rows in the table\n  ** for a partial index.   But do not let the estimate drop below 10. */\n  a[0] = pIdx->pTable->nRowLogEst;\n  if( pIdx->pPartIdxWhere!=0 ) a[0] -= 10;  assert( 10==sqlite3LogEst(2) );\n  if( a[0]<33 ) a[0] = 33;                  assert( 33==sqlite3LogEst(10) );\n\n  /* Estimate that a[1] is 10, a[2] is 9, a[3] is 8, a[4] is 7, a[5] is\n  ** 6 and each subsequent value (if any) is 5.  */\n  memcpy(&a[1], aVal, nCopy*sizeof(LogEst));\n  for(i=nCopy+1; i<=pIdx->nKeyCol; i++){\n    a[i] = 23;                    assert( 23==sqlite3LogEst(5) );\n  }\n\n  assert( 0==sqlite3LogEst(1) );\n  if( IsUniqueIndex(pIdx) ) a[pIdx->nKeyCol] = 0;\n}\n\n/*\n** This routine will drop an existing named index.  This routine\n** implements the DROP INDEX statement.\n*/\nvoid sqlite3DropIndex(Parse *pParse, SrcList *pName, int ifExists){\n  Index *pIndex;\n  Vdbe *v;\n  sqlite3 *db = pParse->db;\n  int iDb;\n\n  assert( pParse->nErr==0 );   /* Never called with prior errors */\n  if( db->mallocFailed ){\n    goto exit_drop_index;\n  }\n  assert( pName->nSrc==1 );\n  if( SQLITE_OK!=sqlite3ReadSchema(pParse) ){\n    goto exit_drop_index;\n  }\n  pIndex = sqlite3FindIndex(db, pName->a[0].zName, pName->a[0].zDatabase);\n  if( pIndex==0 ){\n    if( !ifExists ){\n      sqlite3ErrorMsg(pParse, \"no such index: %S\", pName, 0);\n    }else{\n      sqlite3CodeVerifyNamedSchema(pParse, pName->a[0].zDatabase);\n    }\n    pParse->checkSchema = 1;\n    goto exit_drop_index;\n  }\n  if( pIndex->idxType!=SQLITE_IDXTYPE_APPDEF ){\n    sqlite3ErrorMsg(pParse, \"index associated with UNIQUE \"\n      \"or PRIMARY KEY constraint cannot be dropped\", 0);\n    goto exit_drop_index;\n  }\n  iDb = sqlite3SchemaToIndex(db, pIndex->pSchema);\n#ifndef SQLITE_OMIT_AUTHORIZATION\n  {\n    int code = SQLITE_DROP_INDEX;\n    Table *pTab = pIndex->pTable;\n    const char *zDb = db->aDb[iDb].zDbSName;\n    const char *zTab = SCHEMA_TABLE(iDb);\n    if( sqlite3AuthCheck(pParse, SQLITE_DELETE, zTab, 0, zDb) ){\n      goto exit_drop_index;\n    }\n    if( !OMIT_TEMPDB && iDb ) code = SQLITE_DROP_TEMP_INDEX;\n    if( sqlite3AuthCheck(pParse, code, pIndex->zName, pTab->zName, zDb) ){\n      goto exit_drop_index;\n    }\n  }\n#endif\n\n  /* Generate code to remove the index and from the master table */\n  v = sqlite3GetVdbe(pParse);\n  if( v ){\n    sqlite3BeginWriteOperation(pParse, 1, iDb);\n    sqlite3NestedParse(pParse,\n       \"DELETE FROM %Q.%s WHERE name=%Q AND type='index'\",\n       db->aDb[iDb].zDbSName, MASTER_NAME, pIndex->zName\n    );\n    sqlite3ClearStatTables(pParse, iDb, \"idx\", pIndex->zName);\n    sqlite3ChangeCookie(pParse, iDb);\n    destroyRootPage(pParse, pIndex->tnum, iDb);\n    sqlite3VdbeAddOp4(v, OP_DropIndex, iDb, 0, 0, pIndex->zName, 0);\n  }\n\nexit_drop_index:\n  sqlite3SrcListDelete(db, pName);\n}\n\n/*\n** pArray is a pointer to an array of objects. Each object in the\n** array is szEntry bytes in size. This routine uses sqlite3DbRealloc()\n** to extend the array so that there is space for a new object at the end.\n**\n** When this function is called, *pnEntry contains the current size of\n** the array (in entries - so the allocation is ((*pnEntry) * szEntry) bytes\n** in total).\n**\n** If the realloc() is successful (i.e. if no OOM condition occurs), the\n** space allocated for the new object is zeroed, *pnEntry updated to\n** reflect the new size of the array and a pointer to the new allocation\n** returned. *pIdx is set to the index of the new array entry in this case.\n**\n** Otherwise, if the realloc() fails, *pIdx is set to -1, *pnEntry remains\n** unchanged and a copy of pArray returned.\n*/\nvoid *sqlite3ArrayAllocate(\n  sqlite3 *db,      /* Connection to notify of malloc failures */\n  void *pArray,     /* Array of objects.  Might be reallocated */\n  int szEntry,      /* Size of each object in the array */\n  int *pnEntry,     /* Number of objects currently in use */\n  int *pIdx         /* Write the index of a new slot here */\n){\n  char *z;\n  sqlite3_int64 n = *pIdx = *pnEntry;\n  if( (n & (n-1))==0 ){\n    sqlite3_int64 sz = (n==0) ? 1 : 2*n;\n    void *pNew = sqlite3DbRealloc(db, pArray, sz*szEntry);\n    if( pNew==0 ){\n      *pIdx = -1;\n      return pArray;\n    }\n    pArray = pNew;\n  }\n  z = (char*)pArray;\n  memset(&z[n * szEntry], 0, szEntry);\n  ++*pnEntry;\n  return pArray;\n}\n\n/*\n** Append a new element to the given IdList.  Create a new IdList if\n** need be.\n**\n** A new IdList is returned, or NULL if malloc() fails.\n*/\nIdList *sqlite3IdListAppend(Parse *pParse, IdList *pList, Token *pToken){\n  sqlite3 *db = pParse->db;\n  int i;\n  if( pList==0 ){\n    pList = sqlite3DbMallocZero(db, sizeof(IdList) );\n    if( pList==0 ) return 0;\n  }\n  pList->a = sqlite3ArrayAllocate(\n      db,\n      pList->a,\n      sizeof(pList->a[0]),\n      &pList->nId,\n      &i\n  );\n  if( i<0 ){\n    sqlite3IdListDelete(db, pList);\n    return 0;\n  }\n  pList->a[i].zName = sqlite3NameFromToken(db, pToken);\n  if( IN_RENAME_OBJECT && pList->a[i].zName ){\n    sqlite3RenameTokenMap(pParse, (void*)pList->a[i].zName, pToken);\n  }\n  return pList;\n}\n\n/*\n** Delete an IdList.\n*/\nvoid sqlite3IdListDelete(sqlite3 *db, IdList *pList){\n  int i;\n  if( pList==0 ) return;\n  for(i=0; i<pList->nId; i++){\n    sqlite3DbFree(db, pList->a[i].zName);\n  }\n  sqlite3DbFree(db, pList->a);\n  sqlite3DbFreeNN(db, pList);\n}\n\n/*\n** Return the index in pList of the identifier named zId.  Return -1\n** if not found.\n*/\nint sqlite3IdListIndex(IdList *pList, const char *zName){\n  int i;\n  if( pList==0 ) return -1;\n  for(i=0; i<pList->nId; i++){\n    if( sqlite3StrICmp(pList->a[i].zName, zName)==0 ) return i;\n  }\n  return -1;\n}\n\n/*\n** Maximum size of a SrcList object.\n** The SrcList object is used to represent the FROM clause of a\n** SELECT statement, and the query planner cannot deal with more\n** than 64 tables in a join.  So any value larger than 64 here\n** is sufficient for most uses.  Smaller values, like say 10, are\n** appropriate for small and memory-limited applications.\n*/\n#ifndef SQLITE_MAX_SRCLIST\n# define SQLITE_MAX_SRCLIST 200\n#endif\n\n/*\n** Expand the space allocated for the given SrcList object by\n** creating nExtra new slots beginning at iStart.  iStart is zero based.\n** New slots are zeroed.\n**\n** For example, suppose a SrcList initially contains two entries: A,B.\n** To append 3 new entries onto the end, do this:\n**\n**    sqlite3SrcListEnlarge(db, pSrclist, 3, 2);\n**\n** After the call above it would contain:  A, B, nil, nil, nil.\n** If the iStart argument had been 1 instead of 2, then the result\n** would have been:  A, nil, nil, nil, B.  To prepend the new slots,\n** the iStart value would be 0.  The result then would\n** be: nil, nil, nil, A, B.\n**\n** If a memory allocation fails or the SrcList becomes too large, leave\n** the original SrcList unchanged, return NULL, and leave an error message\n** in pParse.\n*/\nSrcList *sqlite3SrcListEnlarge(\n  Parse *pParse,     /* Parsing context into which errors are reported */\n  SrcList *pSrc,     /* The SrcList to be enlarged */\n  int nExtra,        /* Number of new slots to add to pSrc->a[] */\n  int iStart         /* Index in pSrc->a[] of first new slot */\n){\n  int i;\n\n  /* Sanity checking on calling parameters */\n  assert( iStart>=0 );\n  assert( nExtra>=1 );\n  assert( pSrc!=0 );\n  assert( iStart<=pSrc->nSrc );\n\n  /* Allocate additional space if needed */\n  if( (u32)pSrc->nSrc+nExtra>pSrc->nAlloc ){\n    SrcList *pNew;\n    sqlite3_int64 nAlloc = 2*(sqlite3_int64)pSrc->nSrc+nExtra;\n    sqlite3 *db = pParse->db;\n\n    if( pSrc->nSrc+nExtra>=SQLITE_MAX_SRCLIST ){\n      sqlite3ErrorMsg(pParse, \"too many FROM clause terms, max: %d\",\n                      SQLITE_MAX_SRCLIST);\n      return 0;\n    }\n    if( nAlloc>SQLITE_MAX_SRCLIST ) nAlloc = SQLITE_MAX_SRCLIST;\n    pNew = sqlite3DbRealloc(db, pSrc,\n               sizeof(*pSrc) + (nAlloc-1)*sizeof(pSrc->a[0]) );\n    if( pNew==0 ){\n      assert( db->mallocFailed );\n      return 0;\n    }\n    pSrc = pNew;\n    pSrc->nAlloc = nAlloc;\n  }\n\n  /* Move existing slots that come after the newly inserted slots\n  ** out of the way */\n  for(i=pSrc->nSrc-1; i>=iStart; i--){\n    pSrc->a[i+nExtra] = pSrc->a[i];\n  }\n  pSrc->nSrc += nExtra;\n\n  /* Zero the newly allocated slots */\n  memset(&pSrc->a[iStart], 0, sizeof(pSrc->a[0])*nExtra);\n  for(i=iStart; i<iStart+nExtra; i++){\n    pSrc->a[i].iCursor = -1;\n  }\n\n  /* Return a pointer to the enlarged SrcList */\n  return pSrc;\n}\n\n\n/*\n** Append a new table name to the given SrcList.  Create a new SrcList if\n** need be.  A new entry is created in the SrcList even if pTable is NULL.\n**\n** A SrcList is returned, or NULL if there is an OOM error or if the\n** SrcList grows to large.  The returned\n** SrcList might be the same as the SrcList that was input or it might be\n** a new one.  If an OOM error does occurs, then the prior value of pList\n** that is input to this routine is automatically freed.\n**\n** If pDatabase is not null, it means that the table has an optional\n** database name prefix.  Like this:  \"database.table\".  The pDatabase\n** points to the table name and the pTable points to the database name.\n** The SrcList.a[].zName field is filled with the table name which might\n** come from pTable (if pDatabase is NULL) or from pDatabase.  \n** SrcList.a[].zDatabase is filled with the database name from pTable,\n** or with NULL if no database is specified.\n**\n** In other words, if call like this:\n**\n**         sqlite3SrcListAppend(D,A,B,0);\n**\n** Then B is a table name and the database name is unspecified.  If called\n** like this:\n**\n**         sqlite3SrcListAppend(D,A,B,C);\n**\n** Then C is the table name and B is the database name.  If C is defined\n** then so is B.  In other words, we never have a case where:\n**\n**         sqlite3SrcListAppend(D,A,0,C);\n**\n** Both pTable and pDatabase are assumed to be quoted.  They are dequoted\n** before being added to the SrcList.\n*/\nSrcList *sqlite3SrcListAppend(\n  Parse *pParse,      /* Parsing context, in which errors are reported */\n  SrcList *pList,     /* Append to this SrcList. NULL creates a new SrcList */\n  Token *pTable,      /* Table to append */\n  Token *pDatabase    /* Database of the table */\n){\n  struct SrcList_item *pItem;\n  sqlite3 *db;\n  assert( pDatabase==0 || pTable!=0 );  /* Cannot have C without B */\n  assert( pParse!=0 );\n  assert( pParse->db!=0 );\n  db = pParse->db;\n  if( pList==0 ){\n    pList = sqlite3DbMallocRawNN(pParse->db, sizeof(SrcList) );\n    if( pList==0 ) return 0;\n    pList->nAlloc = 1;\n    pList->nSrc = 1;\n    memset(&pList->a[0], 0, sizeof(pList->a[0]));\n    pList->a[0].iCursor = -1;\n  }else{\n    SrcList *pNew = sqlite3SrcListEnlarge(pParse, pList, 1, pList->nSrc);\n    if( pNew==0 ){\n      sqlite3SrcListDelete(db, pList);\n      return 0;\n    }else{\n      pList = pNew;\n    }\n  }\n  pItem = &pList->a[pList->nSrc-1];\n  if( pDatabase && pDatabase->z==0 ){\n    pDatabase = 0;\n  }\n  if( pDatabase ){\n    pItem->zName = sqlite3NameFromToken(db, pDatabase);\n    pItem->zDatabase = sqlite3NameFromToken(db, pTable);\n  }else{\n    pItem->zName = sqlite3NameFromToken(db, pTable);\n    pItem->zDatabase = 0;\n  }\n  return pList;\n}\n\n/*\n** Assign VdbeCursor index numbers to all tables in a SrcList\n*/\nvoid sqlite3SrcListAssignCursors(Parse *pParse, SrcList *pList){\n  int i;\n  struct SrcList_item *pItem;\n  assert(pList || pParse->db->mallocFailed );\n  if( pList ){\n    for(i=0, pItem=pList->a; i<pList->nSrc; i++, pItem++){\n      if( pItem->iCursor>=0 ) break;\n      pItem->iCursor = pParse->nTab++;\n      if( pItem->pSelect ){\n        sqlite3SrcListAssignCursors(pParse, pItem->pSelect->pSrc);\n      }\n    }\n  }\n}\n\n/*\n** Delete an entire SrcList including all its substructure.\n*/\nvoid sqlite3SrcListDelete(sqlite3 *db, SrcList *pList){\n  int i;\n  struct SrcList_item *pItem;\n  if( pList==0 ) return;\n  for(pItem=pList->a, i=0; i<pList->nSrc; i++, pItem++){\n    sqlite3DbFree(db, pItem->zDatabase);\n    sqlite3DbFree(db, pItem->zName);\n    sqlite3DbFree(db, pItem->zAlias);\n    if( pItem->fg.isIndexedBy ) sqlite3DbFree(db, pItem->u1.zIndexedBy);\n    if( pItem->fg.isTabFunc ) sqlite3ExprListDelete(db, pItem->u1.pFuncArg);\n    sqlite3DeleteTable(db, pItem->pTab);\n    sqlite3SelectDelete(db, pItem->pSelect);\n    sqlite3ExprDelete(db, pItem->pOn);\n    sqlite3IdListDelete(db, pItem->pUsing);\n  }\n  sqlite3DbFreeNN(db, pList);\n}\n\n/*\n** This routine is called by the parser to add a new term to the\n** end of a growing FROM clause.  The \"p\" parameter is the part of\n** the FROM clause that has already been constructed.  \"p\" is NULL\n** if this is the first term of the FROM clause.  pTable and pDatabase\n** are the name of the table and database named in the FROM clause term.\n** pDatabase is NULL if the database name qualifier is missing - the\n** usual case.  If the term has an alias, then pAlias points to the\n** alias token.  If the term is a subquery, then pSubquery is the\n** SELECT statement that the subquery encodes.  The pTable and\n** pDatabase parameters are NULL for subqueries.  The pOn and pUsing\n** parameters are the content of the ON and USING clauses.\n**\n** Return a new SrcList which encodes is the FROM with the new\n** term added.\n*/\nSrcList *sqlite3SrcListAppendFromTerm(\n  Parse *pParse,          /* Parsing context */\n  SrcList *p,             /* The left part of the FROM clause already seen */\n  Token *pTable,          /* Name of the table to add to the FROM clause */\n  Token *pDatabase,       /* Name of the database containing pTable */\n  Token *pAlias,          /* The right-hand side of the AS subexpression */\n  Select *pSubquery,      /* A subquery used in place of a table name */\n  Expr *pOn,              /* The ON clause of a join */\n  IdList *pUsing          /* The USING clause of a join */\n){\n  struct SrcList_item *pItem;\n  sqlite3 *db = pParse->db;\n  if( !p && (pOn || pUsing) ){\n    sqlite3ErrorMsg(pParse, \"a JOIN clause is required before %s\", \n      (pOn ? \"ON\" : \"USING\")\n    );\n    goto append_from_error;\n  }\n  p = sqlite3SrcListAppend(pParse, p, pTable, pDatabase);\n  if( p==0 ){\n    goto append_from_error;\n  }\n  assert( p->nSrc>0 );\n  pItem = &p->a[p->nSrc-1];\n  assert( (pTable==0)==(pDatabase==0) );\n  assert( pItem->zName==0 || pDatabase!=0 );\n  if( IN_RENAME_OBJECT && pItem->zName ){\n    Token *pToken = (ALWAYS(pDatabase) && pDatabase->z) ? pDatabase : pTable;\n    sqlite3RenameTokenMap(pParse, pItem->zName, pToken);\n  }\n  assert( pAlias!=0 );\n  if( pAlias->n ){\n    pItem->zAlias = sqlite3NameFromToken(db, pAlias);\n  }\n  pItem->pSelect = pSubquery;\n  pItem->pOn = pOn;\n  pItem->pUsing = pUsing;\n  return p;\n\n append_from_error:\n  assert( p==0 );\n  sqlite3ExprDelete(db, pOn);\n  sqlite3IdListDelete(db, pUsing);\n  sqlite3SelectDelete(db, pSubquery);\n  return 0;\n}\n\n/*\n** Add an INDEXED BY or NOT INDEXED clause to the most recently added \n** element of the source-list passed as the second argument.\n*/\nvoid sqlite3SrcListIndexedBy(Parse *pParse, SrcList *p, Token *pIndexedBy){\n  assert( pIndexedBy!=0 );\n  if( p && pIndexedBy->n>0 ){\n    struct SrcList_item *pItem;\n    assert( p->nSrc>0 );\n    pItem = &p->a[p->nSrc-1];\n    assert( pItem->fg.notIndexed==0 );\n    assert( pItem->fg.isIndexedBy==0 );\n    assert( pItem->fg.isTabFunc==0 );\n    if( pIndexedBy->n==1 && !pIndexedBy->z ){\n      /* A \"NOT INDEXED\" clause was supplied. See parse.y \n      ** construct \"indexed_opt\" for details. */\n      pItem->fg.notIndexed = 1;\n    }else{\n      pItem->u1.zIndexedBy = sqlite3NameFromToken(pParse->db, pIndexedBy);\n      pItem->fg.isIndexedBy = 1;\n    }\n  }\n}\n\n/*\n** Add the list of function arguments to the SrcList entry for a\n** table-valued-function.\n*/\nvoid sqlite3SrcListFuncArgs(Parse *pParse, SrcList *p, ExprList *pList){\n  if( p ){\n    struct SrcList_item *pItem = &p->a[p->nSrc-1];\n    assert( pItem->fg.notIndexed==0 );\n    assert( pItem->fg.isIndexedBy==0 );\n    assert( pItem->fg.isTabFunc==0 );\n    pItem->u1.pFuncArg = pList;\n    pItem->fg.isTabFunc = 1;\n  }else{\n    sqlite3ExprListDelete(pParse->db, pList);\n  }\n}\n\n/*\n** When building up a FROM clause in the parser, the join operator\n** is initially attached to the left operand.  But the code generator\n** expects the join operator to be on the right operand.  This routine\n** Shifts all join operators from left to right for an entire FROM\n** clause.\n**\n** Example: Suppose the join is like this:\n**\n**           A natural cross join B\n**\n** The operator is \"natural cross join\".  The A and B operands are stored\n** in p->a[0] and p->a[1], respectively.  The parser initially stores the\n** operator with A.  This routine shifts that operator over to B.\n*/\nvoid sqlite3SrcListShiftJoinType(SrcList *p){\n  if( p ){\n    int i;\n    for(i=p->nSrc-1; i>0; i--){\n      p->a[i].fg.jointype = p->a[i-1].fg.jointype;\n    }\n    p->a[0].fg.jointype = 0;\n  }\n}\n\n/*\n** Generate VDBE code for a BEGIN statement.\n*/\nvoid sqlite3BeginTransaction(Parse *pParse, int type){\n  sqlite3 *db;\n  Vdbe *v;\n  int i;\n\n  assert( pParse!=0 );\n  db = pParse->db;\n  assert( db!=0 );\n  if( sqlite3AuthCheck(pParse, SQLITE_TRANSACTION, \"BEGIN\", 0, 0) ){\n    return;\n  }\n  v = sqlite3GetVdbe(pParse);\n  if( !v ) return;\n  if( type!=TK_DEFERRED ){\n    for(i=0; i<db->nDb; i++){\n      sqlite3VdbeAddOp2(v, OP_Transaction, i, (type==TK_EXCLUSIVE)+1);\n      sqlite3VdbeUsesBtree(v, i);\n    }\n  }\n  sqlite3VdbeAddOp0(v, OP_AutoCommit);\n}\n\n/*\n** Generate VDBE code for a COMMIT or ROLLBACK statement.\n** Code for ROLLBACK is generated if eType==TK_ROLLBACK.  Otherwise\n** code is generated for a COMMIT.\n*/\nvoid sqlite3EndTransaction(Parse *pParse, int eType){\n  Vdbe *v;\n  int isRollback;\n\n  assert( pParse!=0 );\n  assert( pParse->db!=0 );\n  assert( eType==TK_COMMIT || eType==TK_END || eType==TK_ROLLBACK );\n  isRollback = eType==TK_ROLLBACK;\n  if( sqlite3AuthCheck(pParse, SQLITE_TRANSACTION, \n       isRollback ? \"ROLLBACK\" : \"COMMIT\", 0, 0) ){\n    return;\n  }\n  v = sqlite3GetVdbe(pParse);\n  if( v ){\n    sqlite3VdbeAddOp2(v, OP_AutoCommit, 1, isRollback);\n  }\n}\n\n/*\n** This function is called by the parser when it parses a command to create,\n** release or rollback an SQL savepoint. \n*/\nvoid sqlite3Savepoint(Parse *pParse, int op, Token *pName){\n  char *zName = sqlite3NameFromToken(pParse->db, pName);\n  if( zName ){\n    Vdbe *v = sqlite3GetVdbe(pParse);\n#ifndef SQLITE_OMIT_AUTHORIZATION\n    static const char * const az[] = { \"BEGIN\", \"RELEASE\", \"ROLLBACK\" };\n    assert( !SAVEPOINT_BEGIN && SAVEPOINT_RELEASE==1 && SAVEPOINT_ROLLBACK==2 );\n#endif\n    if( !v || sqlite3AuthCheck(pParse, SQLITE_SAVEPOINT, az[op], zName, 0) ){\n      sqlite3DbFree(pParse->db, zName);\n      return;\n    }\n    sqlite3VdbeAddOp4(v, OP_Savepoint, op, 0, 0, zName, P4_DYNAMIC);\n  }\n}\n\n/*\n** Make sure the TEMP database is open and available for use.  Return\n** the number of errors.  Leave any error messages in the pParse structure.\n*/\nint sqlite3OpenTempDatabase(Parse *pParse){\n  sqlite3 *db = pParse->db;\n  if( db->aDb[1].pBt==0 && !pParse->explain ){\n    int rc;\n    Btree *pBt;\n    static const int flags = \n          SQLITE_OPEN_READWRITE |\n          SQLITE_OPEN_CREATE |\n          SQLITE_OPEN_EXCLUSIVE |\n          SQLITE_OPEN_DELETEONCLOSE |\n          SQLITE_OPEN_TEMP_DB;\n\n    rc = sqlite3BtreeOpen(db->pVfs, 0, db, &pBt, 0, flags);\n    if( rc!=SQLITE_OK ){\n      sqlite3ErrorMsg(pParse, \"unable to open a temporary database \"\n        \"file for storing temporary tables\");\n      pParse->rc = rc;\n      return 1;\n    }\n    db->aDb[1].pBt = pBt;\n    assert( db->aDb[1].pSchema );\n    if( SQLITE_NOMEM==sqlite3BtreeSetPageSize(pBt, db->nextPagesize, -1, 0) ){\n      sqlite3OomFault(db);\n      return 1;\n    }\n  }\n  return 0;\n}\n\n/*\n** Record the fact that the schema cookie will need to be verified\n** for database iDb.  The code to actually verify the schema cookie\n** will occur at the end of the top-level VDBE and will be generated\n** later, by sqlite3FinishCoding().\n*/\nvoid sqlite3CodeVerifySchema(Parse *pParse, int iDb){\n  Parse *pToplevel = sqlite3ParseToplevel(pParse);\n\n  assert( iDb>=0 && iDb<pParse->db->nDb );\n  assert( pParse->db->aDb[iDb].pBt!=0 || iDb==1 );\n  assert( iDb<SQLITE_MAX_ATTACHED+2 );\n  assert( sqlite3SchemaMutexHeld(pParse->db, iDb, 0) );\n  if( DbMaskTest(pToplevel->cookieMask, iDb)==0 ){\n    DbMaskSet(pToplevel->cookieMask, iDb);\n    if( !OMIT_TEMPDB && iDb==1 ){\n      sqlite3OpenTempDatabase(pToplevel);\n    }\n  }\n}\n\n/*\n** If argument zDb is NULL, then call sqlite3CodeVerifySchema() for each \n** attached database. Otherwise, invoke it for the database named zDb only.\n*/\nvoid sqlite3CodeVerifyNamedSchema(Parse *pParse, const char *zDb){\n  sqlite3 *db = pParse->db;\n  int i;\n  for(i=0; i<db->nDb; i++){\n    Db *pDb = &db->aDb[i];\n    if( pDb->pBt && (!zDb || 0==sqlite3StrICmp(zDb, pDb->zDbSName)) ){\n      sqlite3CodeVerifySchema(pParse, i);\n    }\n  }\n}\n\n/*\n** Generate VDBE code that prepares for doing an operation that\n** might change the database.\n**\n** This routine starts a new transaction if we are not already within\n** a transaction.  If we are already within a transaction, then a checkpoint\n** is set if the setStatement parameter is true.  A checkpoint should\n** be set for operations that might fail (due to a constraint) part of\n** the way through and which will need to undo some writes without having to\n** rollback the whole transaction.  For operations where all constraints\n** can be checked before any changes are made to the database, it is never\n** necessary to undo a write and the checkpoint should not be set.\n*/\nvoid sqlite3BeginWriteOperation(Parse *pParse, int setStatement, int iDb){\n  Parse *pToplevel = sqlite3ParseToplevel(pParse);\n  sqlite3CodeVerifySchema(pParse, iDb);\n  DbMaskSet(pToplevel->writeMask, iDb);\n  pToplevel->isMultiWrite |= setStatement;\n}\n\n/*\n** Indicate that the statement currently under construction might write\n** more than one entry (example: deleting one row then inserting another,\n** inserting multiple rows in a table, or inserting a row and index entries.)\n** If an abort occurs after some of these writes have completed, then it will\n** be necessary to undo the completed writes.\n*/\nvoid sqlite3MultiWrite(Parse *pParse){\n  Parse *pToplevel = sqlite3ParseToplevel(pParse);\n  pToplevel->isMultiWrite = 1;\n}\n\n/* \n** The code generator calls this routine if is discovers that it is\n** possible to abort a statement prior to completion.  In order to \n** perform this abort without corrupting the database, we need to make\n** sure that the statement is protected by a statement transaction.\n**\n** Technically, we only need to set the mayAbort flag if the\n** isMultiWrite flag was previously set.  There is a time dependency\n** such that the abort must occur after the multiwrite.  This makes\n** some statements involving the REPLACE conflict resolution algorithm\n** go a little faster.  But taking advantage of this time dependency\n** makes it more difficult to prove that the code is correct (in \n** particular, it prevents us from writing an effective\n** implementation of sqlite3AssertMayAbort()) and so we have chosen\n** to take the safe route and skip the optimization.\n*/\nvoid sqlite3MayAbort(Parse *pParse){\n  Parse *pToplevel = sqlite3ParseToplevel(pParse);\n  pToplevel->mayAbort = 1;\n}\n\n/*\n** Code an OP_Halt that causes the vdbe to return an SQLITE_CONSTRAINT\n** error. The onError parameter determines which (if any) of the statement\n** and/or current transaction is rolled back.\n*/\nvoid sqlite3HaltConstraint(\n  Parse *pParse,    /* Parsing context */\n  int errCode,      /* extended error code */\n  int onError,      /* Constraint type */\n  char *p4,         /* Error message */\n  i8 p4type,        /* P4_STATIC or P4_TRANSIENT */\n  u8 p5Errmsg       /* P5_ErrMsg type */\n){\n  Vdbe *v = sqlite3GetVdbe(pParse);\n  assert( (errCode&0xff)==SQLITE_CONSTRAINT );\n  if( onError==OE_Abort ){\n    sqlite3MayAbort(pParse);\n  }\n  sqlite3VdbeAddOp4(v, OP_Halt, errCode, onError, 0, p4, p4type);\n  sqlite3VdbeChangeP5(v, p5Errmsg);\n}\n\n/*\n** Code an OP_Halt due to UNIQUE or PRIMARY KEY constraint violation.\n*/\nvoid sqlite3UniqueConstraint(\n  Parse *pParse,    /* Parsing context */\n  int onError,      /* Constraint type */\n  Index *pIdx       /* The index that triggers the constraint */\n){\n  char *zErr;\n  int j;\n  StrAccum errMsg;\n  Table *pTab = pIdx->pTable;\n\n  sqlite3StrAccumInit(&errMsg, pParse->db, 0, 0, \n                      pParse->db->aLimit[SQLITE_LIMIT_LENGTH]);\n  if( pIdx->aColExpr ){\n    sqlite3_str_appendf(&errMsg, \"index '%q'\", pIdx->zName);\n  }else{\n    for(j=0; j<pIdx->nKeyCol; j++){\n      char *zCol;\n      assert( pIdx->aiColumn[j]>=0 );\n      zCol = pTab->aCol[pIdx->aiColumn[j]].zName;\n      if( j ) sqlite3_str_append(&errMsg, \", \", 2);\n      sqlite3_str_appendall(&errMsg, pTab->zName);\n      sqlite3_str_append(&errMsg, \".\", 1);\n      sqlite3_str_appendall(&errMsg, zCol);\n    }\n  }\n  zErr = sqlite3StrAccumFinish(&errMsg);\n  sqlite3HaltConstraint(pParse, \n    IsPrimaryKeyIndex(pIdx) ? SQLITE_CONSTRAINT_PRIMARYKEY \n                            : SQLITE_CONSTRAINT_UNIQUE,\n    onError, zErr, P4_DYNAMIC, P5_ConstraintUnique);\n}\n\n\n/*\n** Code an OP_Halt due to non-unique rowid.\n*/\nvoid sqlite3RowidConstraint(\n  Parse *pParse,    /* Parsing context */\n  int onError,      /* Conflict resolution algorithm */\n  Table *pTab       /* The table with the non-unique rowid */ \n){\n  char *zMsg;\n  int rc;\n  if( pTab->iPKey>=0 ){\n    zMsg = sqlite3MPrintf(pParse->db, \"%s.%s\", pTab->zName,\n                          pTab->aCol[pTab->iPKey].zName);\n    rc = SQLITE_CONSTRAINT_PRIMARYKEY;\n  }else{\n    zMsg = sqlite3MPrintf(pParse->db, \"%s.rowid\", pTab->zName);\n    rc = SQLITE_CONSTRAINT_ROWID;\n  }\n  sqlite3HaltConstraint(pParse, rc, onError, zMsg, P4_DYNAMIC,\n                        P5_ConstraintUnique);\n}\n\n/*\n** Check to see if pIndex uses the collating sequence pColl.  Return\n** true if it does and false if it does not.\n*/\n#ifndef SQLITE_OMIT_REINDEX\nstatic int collationMatch(const char *zColl, Index *pIndex){\n  int i;\n  assert( zColl!=0 );\n  for(i=0; i<pIndex->nColumn; i++){\n    const char *z = pIndex->azColl[i];\n    assert( z!=0 || pIndex->aiColumn[i]<0 );\n    if( pIndex->aiColumn[i]>=0 && 0==sqlite3StrICmp(z, zColl) ){\n      return 1;\n    }\n  }\n  return 0;\n}\n#endif\n\n/*\n** Recompute all indices of pTab that use the collating sequence pColl.\n** If pColl==0 then recompute all indices of pTab.\n*/\n#ifndef SQLITE_OMIT_REINDEX\nstatic void reindexTable(Parse *pParse, Table *pTab, char const *zColl){\n  if( !IsVirtual(pTab) ){\n    Index *pIndex;              /* An index associated with pTab */\n\n    for(pIndex=pTab->pIndex; pIndex; pIndex=pIndex->pNext){\n      if( zColl==0 || collationMatch(zColl, pIndex) ){\n        int iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);\n        sqlite3BeginWriteOperation(pParse, 0, iDb);\n        sqlite3RefillIndex(pParse, pIndex, -1);\n      }\n    }\n  }\n}\n#endif\n\n/*\n** Recompute all indices of all tables in all databases where the\n** indices use the collating sequence pColl.  If pColl==0 then recompute\n** all indices everywhere.\n*/\n#ifndef SQLITE_OMIT_REINDEX\nstatic void reindexDatabases(Parse *pParse, char const *zColl){\n  Db *pDb;                    /* A single database */\n  int iDb;                    /* The database index number */\n  sqlite3 *db = pParse->db;   /* The database connection */\n  HashElem *k;                /* For looping over tables in pDb */\n  Table *pTab;                /* A table in the database */\n\n  assert( sqlite3BtreeHoldsAllMutexes(db) );  /* Needed for schema access */\n  for(iDb=0, pDb=db->aDb; iDb<db->nDb; iDb++, pDb++){\n    assert( pDb!=0 );\n    for(k=sqliteHashFirst(&pDb->pSchema->tblHash);  k; k=sqliteHashNext(k)){\n      pTab = (Table*)sqliteHashData(k);\n      reindexTable(pParse, pTab, zColl);\n    }\n  }\n}\n#endif\n\n/*\n** Generate code for the REINDEX command.\n**\n**        REINDEX                            -- 1\n**        REINDEX  <collation>               -- 2\n**        REINDEX  ?<database>.?<tablename>  -- 3\n**        REINDEX  ?<database>.?<indexname>  -- 4\n**\n** Form 1 causes all indices in all attached databases to be rebuilt.\n** Form 2 rebuilds all indices in all databases that use the named\n** collating function.  Forms 3 and 4 rebuild the named index or all\n** indices associated with the named table.\n*/\n#ifndef SQLITE_OMIT_REINDEX\nvoid sqlite3Reindex(Parse *pParse, Token *pName1, Token *pName2){\n  CollSeq *pColl;             /* Collating sequence to be reindexed, or NULL */\n  char *z;                    /* Name of a table or index */\n  const char *zDb;            /* Name of the database */\n  Table *pTab;                /* A table in the database */\n  Index *pIndex;              /* An index associated with pTab */\n  int iDb;                    /* The database index number */\n  sqlite3 *db = pParse->db;   /* The database connection */\n  Token *pObjName;            /* Name of the table or index to be reindexed */\n\n  /* Read the database schema. If an error occurs, leave an error message\n  ** and code in pParse and return NULL. */\n  if( SQLITE_OK!=sqlite3ReadSchema(pParse) ){\n    return;\n  }\n\n  if( pName1==0 ){\n    reindexDatabases(pParse, 0);\n    return;\n  }else if( NEVER(pName2==0) || pName2->z==0 ){\n    char *zColl;\n    assert( pName1->z );\n    zColl = sqlite3NameFromToken(pParse->db, pName1);\n    if( !zColl ) return;\n    pColl = sqlite3FindCollSeq(db, ENC(db), zColl, 0);\n    if( pColl ){\n      reindexDatabases(pParse, zColl);\n      sqlite3DbFree(db, zColl);\n      return;\n    }\n    sqlite3DbFree(db, zColl);\n  }\n  iDb = sqlite3TwoPartName(pParse, pName1, pName2, &pObjName);\n  if( iDb<0 ) return;\n  z = sqlite3NameFromToken(db, pObjName);\n  if( z==0 ) return;\n  zDb = db->aDb[iDb].zDbSName;\n  pTab = sqlite3FindTable(db, z, zDb);\n  if( pTab ){\n    reindexTable(pParse, pTab, 0);\n    sqlite3DbFree(db, z);\n    return;\n  }\n  pIndex = sqlite3FindIndex(db, z, zDb);\n  sqlite3DbFree(db, z);\n  if( pIndex ){\n    sqlite3BeginWriteOperation(pParse, 0, iDb);\n    sqlite3RefillIndex(pParse, pIndex, -1);\n    return;\n  }\n  sqlite3ErrorMsg(pParse, \"unable to identify the object to be reindexed\");\n}\n#endif\n\n/*\n** Return a KeyInfo structure that is appropriate for the given Index.\n**\n** The caller should invoke sqlite3KeyInfoUnref() on the returned object\n** when it has finished using it.\n*/\nKeyInfo *sqlite3KeyInfoOfIndex(Parse *pParse, Index *pIdx){\n  int i;\n  int nCol = pIdx->nColumn;\n  int nKey = pIdx->nKeyCol;\n  KeyInfo *pKey;\n  if( pParse->nErr ) return 0;\n  if( pIdx->uniqNotNull ){\n    pKey = sqlite3KeyInfoAlloc(pParse->db, nKey, nCol-nKey);\n  }else{\n    pKey = sqlite3KeyInfoAlloc(pParse->db, nCol, 0);\n  }\n  if( pKey ){\n    assert( sqlite3KeyInfoIsWriteable(pKey) );\n    for(i=0; i<nCol; i++){\n      const char *zColl = pIdx->azColl[i];\n      pKey->aColl[i] = zColl==sqlite3StrBINARY ? 0 :\n                        sqlite3LocateCollSeq(pParse, zColl);\n      pKey->aSortFlags[i] = pIdx->aSortOrder[i];\n      assert( 0==(pKey->aSortFlags[i] & KEYINFO_ORDER_BIGNULL) );\n    }\n    if( pParse->nErr ){\n      assert( pParse->rc==SQLITE_ERROR_MISSING_COLLSEQ );\n      if( pIdx->bNoQuery==0 ){\n        /* Deactivate the index because it contains an unknown collating\n        ** sequence.  The only way to reactive the index is to reload the\n        ** schema.  Adding the missing collating sequence later does not\n        ** reactive the index.  The application had the chance to register\n        ** the missing index using the collation-needed callback.  For\n        ** simplicity, SQLite will not give the application a second chance.\n        */\n        pIdx->bNoQuery = 1;\n        pParse->rc = SQLITE_ERROR_RETRY;\n      }\n      sqlite3KeyInfoUnref(pKey);\n      pKey = 0;\n    }\n  }\n  return pKey;\n}\n\n#ifndef SQLITE_OMIT_CTE\n/* \n** This routine is invoked once per CTE by the parser while parsing a \n** WITH clause. \n*/\nWith *sqlite3WithAdd(\n  Parse *pParse,          /* Parsing context */\n  With *pWith,            /* Existing WITH clause, or NULL */\n  Token *pName,           /* Name of the common-table */\n  ExprList *pArglist,     /* Optional column name list for the table */\n  Select *pQuery          /* Query used to initialize the table */\n){\n  sqlite3 *db = pParse->db;\n  With *pNew;\n  char *zName;\n\n  /* Check that the CTE name is unique within this WITH clause. If\n  ** not, store an error in the Parse structure. */\n  zName = sqlite3NameFromToken(pParse->db, pName);\n  if( zName && pWith ){\n    int i;\n    for(i=0; i<pWith->nCte; i++){\n      if( sqlite3StrICmp(zName, pWith->a[i].zName)==0 ){\n        sqlite3ErrorMsg(pParse, \"duplicate WITH table name: %s\", zName);\n      }\n    }\n  }\n\n  if( pWith ){\n    sqlite3_int64 nByte = sizeof(*pWith) + (sizeof(pWith->a[1]) * pWith->nCte);\n    pNew = sqlite3DbRealloc(db, pWith, nByte);\n  }else{\n    pNew = sqlite3DbMallocZero(db, sizeof(*pWith));\n  }\n  assert( (pNew!=0 && zName!=0) || db->mallocFailed );\n\n  if( db->mallocFailed ){\n    sqlite3ExprListDelete(db, pArglist);\n    sqlite3SelectDelete(db, pQuery);\n    sqlite3DbFree(db, zName);\n    pNew = pWith;\n  }else{\n    pNew->a[pNew->nCte].pSelect = pQuery;\n    pNew->a[pNew->nCte].pCols = pArglist;\n    pNew->a[pNew->nCte].zName = zName;\n    pNew->a[pNew->nCte].zCteErr = 0;\n    pNew->nCte++;\n  }\n\n  return pNew;\n}\n\n/*\n** Free the contents of the With object passed as the second argument.\n*/\nvoid sqlite3WithDelete(sqlite3 *db, With *pWith){\n  if( pWith ){\n    int i;\n    for(i=0; i<pWith->nCte; i++){\n      struct Cte *pCte = &pWith->a[i];\n      sqlite3ExprListDelete(db, pCte->pCols);\n      sqlite3SelectDelete(db, pCte->pSelect);\n      sqlite3DbFree(db, pCte->zName);\n    }\n    sqlite3DbFree(db, pWith);\n  }\n}\n#endif /* !defined(SQLITE_OMIT_CTE) */\n", "/*\n** 2001 September 15\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** Internal interface definitions for SQLite.\n**\n*/\n#ifndef SQLITEINT_H\n#define SQLITEINT_H\n\n/* Special Comments:\n**\n** Some comments have special meaning to the tools that measure test\n** coverage:\n**\n**    NO_TEST                     - The branches on this line are not\n**                                  measured by branch coverage.  This is\n**                                  used on lines of code that actually\n**                                  implement parts of coverage testing.\n**\n**    OPTIMIZATION-IF-TRUE        - This branch is allowed to alway be false\n**                                  and the correct answer is still obtained,\n**                                  though perhaps more slowly.\n**\n**    OPTIMIZATION-IF-FALSE       - This branch is allowed to alway be true\n**                                  and the correct answer is still obtained,\n**                                  though perhaps more slowly.\n**\n**    PREVENTS-HARMLESS-OVERREAD  - This branch prevents a buffer overread\n**                                  that would be harmless and undetectable\n**                                  if it did occur.  \n**\n** In all cases, the special comment must be enclosed in the usual\n** slash-asterisk...asterisk-slash comment marks, with no spaces between the \n** asterisks and the comment text.\n*/\n\n/*\n** Make sure the Tcl calling convention macro is defined.  This macro is\n** only used by test code and Tcl integration code.\n*/\n#ifndef SQLITE_TCLAPI\n#  define SQLITE_TCLAPI\n#endif\n\n/*\n** Include the header file used to customize the compiler options for MSVC.\n** This should be done first so that it can successfully prevent spurious\n** compiler warnings due to subsequent content in this file and other files\n** that are included by this file.\n*/\n#include \"msvc.h\"\n\n/*\n** Special setup for VxWorks\n*/\n#include \"vxworks.h\"\n\n/*\n** These #defines should enable >2GB file support on POSIX if the\n** underlying operating system supports it.  If the OS lacks\n** large file support, or if the OS is windows, these should be no-ops.\n**\n** Ticket #2739:  The _LARGEFILE_SOURCE macro must appear before any\n** system #includes.  Hence, this block of code must be the very first\n** code in all source files.\n**\n** Large file support can be disabled using the -DSQLITE_DISABLE_LFS switch\n** on the compiler command line.  This is necessary if you are compiling\n** on a recent machine (ex: Red Hat 7.2) but you want your code to work\n** on an older machine (ex: Red Hat 6.0).  If you compile on Red Hat 7.2\n** without this option, LFS is enable.  But LFS does not exist in the kernel\n** in Red Hat 6.0, so the code won't work.  Hence, for maximum binary\n** portability you should omit LFS.\n**\n** The previous paragraph was written in 2005.  (This paragraph is written\n** on 2008-11-28.) These days, all Linux kernels support large files, so\n** you should probably leave LFS enabled.  But some embedded platforms might\n** lack LFS in which case the SQLITE_DISABLE_LFS macro might still be useful.\n**\n** Similar is true for Mac OS X.  LFS is only supported on Mac OS X 9 and later.\n*/\n#ifndef SQLITE_DISABLE_LFS\n# define _LARGE_FILE       1\n# ifndef _FILE_OFFSET_BITS\n#   define _FILE_OFFSET_BITS 64\n# endif\n# define _LARGEFILE_SOURCE 1\n#endif\n\n/* The GCC_VERSION and MSVC_VERSION macros are used to\n** conditionally include optimizations for each of these compilers.  A\n** value of 0 means that compiler is not being used.  The\n** SQLITE_DISABLE_INTRINSIC macro means do not use any compiler-specific\n** optimizations, and hence set all compiler macros to 0\n**\n** There was once also a CLANG_VERSION macro.  However, we learn that the\n** version numbers in clang are for \"marketing\" only and are inconsistent\n** and unreliable.  Fortunately, all versions of clang also recognize the\n** gcc version numbers and have reasonable settings for gcc version numbers,\n** so the GCC_VERSION macro will be set to a correct non-zero value even\n** when compiling with clang.\n*/\n#if defined(__GNUC__) && !defined(SQLITE_DISABLE_INTRINSIC)\n# define GCC_VERSION (__GNUC__*1000000+__GNUC_MINOR__*1000+__GNUC_PATCHLEVEL__)\n#else\n# define GCC_VERSION 0\n#endif\n#if defined(_MSC_VER) && !defined(SQLITE_DISABLE_INTRINSIC)\n# define MSVC_VERSION _MSC_VER\n#else\n# define MSVC_VERSION 0\n#endif\n\n/* Needed for various definitions... */\n#if defined(__GNUC__) && !defined(_GNU_SOURCE)\n# define _GNU_SOURCE\n#endif\n\n#if defined(__OpenBSD__) && !defined(_BSD_SOURCE)\n# define _BSD_SOURCE\n#endif\n\n/*\n** For MinGW, check to see if we can include the header file containing its\n** version information, among other things.  Normally, this internal MinGW\n** header file would [only] be included automatically by other MinGW header\n** files; however, the contained version information is now required by this\n** header file to work around binary compatibility issues (see below) and\n** this is the only known way to reliably obtain it.  This entire #if block\n** would be completely unnecessary if there was any other way of detecting\n** MinGW via their preprocessor (e.g. if they customized their GCC to define\n** some MinGW-specific macros).  When compiling for MinGW, either the\n** _HAVE_MINGW_H or _HAVE__MINGW_H (note the extra underscore) macro must be\n** defined; otherwise, detection of conditions specific to MinGW will be\n** disabled.\n*/\n#if defined(_HAVE_MINGW_H)\n# include \"mingw.h\"\n#elif defined(_HAVE__MINGW_H)\n# include \"_mingw.h\"\n#endif\n\n/*\n** For MinGW version 4.x (and higher), check to see if the _USE_32BIT_TIME_T\n** define is required to maintain binary compatibility with the MSVC runtime\n** library in use (e.g. for Windows XP).\n*/\n#if !defined(_USE_32BIT_TIME_T) && !defined(_USE_64BIT_TIME_T) && \\\n    defined(_WIN32) && !defined(_WIN64) && \\\n    defined(__MINGW_MAJOR_VERSION) && __MINGW_MAJOR_VERSION >= 4 && \\\n    defined(__MSVCRT__)\n# define _USE_32BIT_TIME_T\n#endif\n\n/* The public SQLite interface.  The _FILE_OFFSET_BITS macro must appear\n** first in QNX.  Also, the _USE_32BIT_TIME_T macro must appear first for\n** MinGW.\n*/\n#include \"sqlite3.h\"\n\n/*\n** Include the configuration header output by 'configure' if we're using the\n** autoconf-based build\n*/\n#if defined(_HAVE_SQLITE_CONFIG_H) && !defined(SQLITECONFIG_H)\n#include \"config.h\"\n#define SQLITECONFIG_H 1\n#endif\n\n#include \"sqliteLimit.h\"\n\n/* Disable nuisance warnings on Borland compilers */\n#if defined(__BORLANDC__)\n#pragma warn -rch /* unreachable code */\n#pragma warn -ccc /* Condition is always true or false */\n#pragma warn -aus /* Assigned value is never used */\n#pragma warn -csu /* Comparing signed and unsigned */\n#pragma warn -spa /* Suspicious pointer arithmetic */\n#endif\n\n/*\n** Include standard header files as necessary\n*/\n#ifdef HAVE_STDINT_H\n#include <stdint.h>\n#endif\n#ifdef HAVE_INTTYPES_H\n#include <inttypes.h>\n#endif\n\n/*\n** The following macros are used to cast pointers to integers and\n** integers to pointers.  The way you do this varies from one compiler\n** to the next, so we have developed the following set of #if statements\n** to generate appropriate macros for a wide range of compilers.\n**\n** The correct \"ANSI\" way to do this is to use the intptr_t type.\n** Unfortunately, that typedef is not available on all compilers, or\n** if it is available, it requires an #include of specific headers\n** that vary from one machine to the next.\n**\n** Ticket #3860:  The llvm-gcc-4.2 compiler from Apple chokes on\n** the ((void*)&((char*)0)[X]) construct.  But MSVC chokes on ((void*)(X)).\n** So we have to define the macros in different ways depending on the\n** compiler.\n*/\n#if defined(HAVE_STDINT_H)   /* Use this case if we have ANSI headers */\n# define SQLITE_INT_TO_PTR(X)  ((void*)(intptr_t)(X))\n# define SQLITE_PTR_TO_INT(X)  ((int)(intptr_t)(X))\n#elif defined(__PTRDIFF_TYPE__)  /* This case should work for GCC */\n# define SQLITE_INT_TO_PTR(X)  ((void*)(__PTRDIFF_TYPE__)(X))\n# define SQLITE_PTR_TO_INT(X)  ((int)(__PTRDIFF_TYPE__)(X))\n#elif !defined(__GNUC__)       /* Works for compilers other than LLVM */\n# define SQLITE_INT_TO_PTR(X)  ((void*)&((char*)0)[X])\n# define SQLITE_PTR_TO_INT(X)  ((int)(((char*)X)-(char*)0))\n#else                          /* Generates a warning - but it always works */\n# define SQLITE_INT_TO_PTR(X)  ((void*)(X))\n# define SQLITE_PTR_TO_INT(X)  ((int)(X))\n#endif\n\n/*\n** A macro to hint to the compiler that a function should not be\n** inlined.\n*/\n#if defined(__GNUC__)\n#  define SQLITE_NOINLINE  __attribute__((noinline))\n#elif defined(_MSC_VER) && _MSC_VER>=1310\n#  define SQLITE_NOINLINE  __declspec(noinline)\n#else\n#  define SQLITE_NOINLINE\n#endif\n\n/*\n** Make sure that the compiler intrinsics we desire are enabled when\n** compiling with an appropriate version of MSVC unless prevented by\n** the SQLITE_DISABLE_INTRINSIC define.\n*/\n#if !defined(SQLITE_DISABLE_INTRINSIC)\n#  if defined(_MSC_VER) && _MSC_VER>=1400\n#    if !defined(_WIN32_WCE)\n#      include <intrin.h>\n#      pragma intrinsic(_byteswap_ushort)\n#      pragma intrinsic(_byteswap_ulong)\n#      pragma intrinsic(_byteswap_uint64)\n#      pragma intrinsic(_ReadWriteBarrier)\n#    else\n#      include <cmnintrin.h>\n#    endif\n#  endif\n#endif\n\n/*\n** The SQLITE_THREADSAFE macro must be defined as 0, 1, or 2.\n** 0 means mutexes are permanently disable and the library is never\n** threadsafe.  1 means the library is serialized which is the highest\n** level of threadsafety.  2 means the library is multithreaded - multiple\n** threads can use SQLite as long as no two threads try to use the same\n** database connection at the same time.\n**\n** Older versions of SQLite used an optional THREADSAFE macro.\n** We support that for legacy.\n**\n** To ensure that the correct value of \"THREADSAFE\" is reported when querying\n** for compile-time options at runtime (e.g. \"PRAGMA compile_options\"), this\n** logic is partially replicated in ctime.c. If it is updated here, it should\n** also be updated there.\n*/\n#if !defined(SQLITE_THREADSAFE)\n# if defined(THREADSAFE)\n#   define SQLITE_THREADSAFE THREADSAFE\n# else\n#   define SQLITE_THREADSAFE 1 /* IMP: R-07272-22309 */\n# endif\n#endif\n\n/*\n** Powersafe overwrite is on by default.  But can be turned off using\n** the -DSQLITE_POWERSAFE_OVERWRITE=0 command-line option.\n*/\n#ifndef SQLITE_POWERSAFE_OVERWRITE\n# define SQLITE_POWERSAFE_OVERWRITE 1\n#endif\n\n/*\n** EVIDENCE-OF: R-25715-37072 Memory allocation statistics are enabled by\n** default unless SQLite is compiled with SQLITE_DEFAULT_MEMSTATUS=0 in\n** which case memory allocation statistics are disabled by default.\n*/\n#if !defined(SQLITE_DEFAULT_MEMSTATUS)\n# define SQLITE_DEFAULT_MEMSTATUS 1\n#endif\n\n/*\n** Exactly one of the following macros must be defined in order to\n** specify which memory allocation subsystem to use.\n**\n**     SQLITE_SYSTEM_MALLOC          // Use normal system malloc()\n**     SQLITE_WIN32_MALLOC           // Use Win32 native heap API\n**     SQLITE_ZERO_MALLOC            // Use a stub allocator that always fails\n**     SQLITE_MEMDEBUG               // Debugging version of system malloc()\n**\n** On Windows, if the SQLITE_WIN32_MALLOC_VALIDATE macro is defined and the\n** assert() macro is enabled, each call into the Win32 native heap subsystem\n** will cause HeapValidate to be called.  If heap validation should fail, an\n** assertion will be triggered.\n**\n** If none of the above are defined, then set SQLITE_SYSTEM_MALLOC as\n** the default.\n*/\n#if defined(SQLITE_SYSTEM_MALLOC) \\\n  + defined(SQLITE_WIN32_MALLOC) \\\n  + defined(SQLITE_ZERO_MALLOC) \\\n  + defined(SQLITE_MEMDEBUG)>1\n# error \"Two or more of the following compile-time configuration options\\\n are defined but at most one is allowed:\\\n SQLITE_SYSTEM_MALLOC, SQLITE_WIN32_MALLOC, SQLITE_MEMDEBUG,\\\n SQLITE_ZERO_MALLOC\"\n#endif\n#if defined(SQLITE_SYSTEM_MALLOC) \\\n  + defined(SQLITE_WIN32_MALLOC) \\\n  + defined(SQLITE_ZERO_MALLOC) \\\n  + defined(SQLITE_MEMDEBUG)==0\n# define SQLITE_SYSTEM_MALLOC 1\n#endif\n\n/*\n** If SQLITE_MALLOC_SOFT_LIMIT is not zero, then try to keep the\n** sizes of memory allocations below this value where possible.\n*/\n#if !defined(SQLITE_MALLOC_SOFT_LIMIT)\n# define SQLITE_MALLOC_SOFT_LIMIT 1024\n#endif\n\n/*\n** We need to define _XOPEN_SOURCE as follows in order to enable\n** recursive mutexes on most Unix systems and fchmod() on OpenBSD.\n** But _XOPEN_SOURCE define causes problems for Mac OS X, so omit\n** it.\n*/\n#if !defined(_XOPEN_SOURCE) && !defined(__DARWIN__) && !defined(__APPLE__)\n#  define _XOPEN_SOURCE 600\n#endif\n\n/*\n** NDEBUG and SQLITE_DEBUG are opposites.  It should always be true that\n** defined(NDEBUG)==!defined(SQLITE_DEBUG).  If this is not currently true,\n** make it true by defining or undefining NDEBUG.\n**\n** Setting NDEBUG makes the code smaller and faster by disabling the\n** assert() statements in the code.  So we want the default action\n** to be for NDEBUG to be set and NDEBUG to be undefined only if SQLITE_DEBUG\n** is set.  Thus NDEBUG becomes an opt-in rather than an opt-out\n** feature.\n*/\n#if !defined(NDEBUG) && !defined(SQLITE_DEBUG)\n# define NDEBUG 1\n#endif\n#if defined(NDEBUG) && defined(SQLITE_DEBUG)\n# undef NDEBUG\n#endif\n\n/*\n** Enable SQLITE_ENABLE_EXPLAIN_COMMENTS if SQLITE_DEBUG is turned on.\n*/\n#if !defined(SQLITE_ENABLE_EXPLAIN_COMMENTS) && defined(SQLITE_DEBUG)\n# define SQLITE_ENABLE_EXPLAIN_COMMENTS 1\n#endif\n\n/*\n** The testcase() macro is used to aid in coverage testing.  When\n** doing coverage testing, the condition inside the argument to\n** testcase() must be evaluated both true and false in order to\n** get full branch coverage.  The testcase() macro is inserted\n** to help ensure adequate test coverage in places where simple\n** condition/decision coverage is inadequate.  For example, testcase()\n** can be used to make sure boundary values are tested.  For\n** bitmask tests, testcase() can be used to make sure each bit\n** is significant and used at least once.  On switch statements\n** where multiple cases go to the same block of code, testcase()\n** can insure that all cases are evaluated.\n**\n*/\n#ifdef SQLITE_COVERAGE_TEST\n  void sqlite3Coverage(int);\n# define testcase(X)  if( X ){ sqlite3Coverage(__LINE__); }\n#else\n# define testcase(X)\n#endif\n\n/*\n** The TESTONLY macro is used to enclose variable declarations or\n** other bits of code that are needed to support the arguments\n** within testcase() and assert() macros.\n*/\n#if !defined(NDEBUG) || defined(SQLITE_COVERAGE_TEST)\n# define TESTONLY(X)  X\n#else\n# define TESTONLY(X)\n#endif\n\n/*\n** Sometimes we need a small amount of code such as a variable initialization\n** to setup for a later assert() statement.  We do not want this code to\n** appear when assert() is disabled.  The following macro is therefore\n** used to contain that setup code.  The \"VVA\" acronym stands for\n** \"Verification, Validation, and Accreditation\".  In other words, the\n** code within VVA_ONLY() will only run during verification processes.\n*/\n#ifndef NDEBUG\n# define VVA_ONLY(X)  X\n#else\n# define VVA_ONLY(X)\n#endif\n\n/*\n** The ALWAYS and NEVER macros surround boolean expressions which\n** are intended to always be true or false, respectively.  Such\n** expressions could be omitted from the code completely.  But they\n** are included in a few cases in order to enhance the resilience\n** of SQLite to unexpected behavior - to make the code \"self-healing\"\n** or \"ductile\" rather than being \"brittle\" and crashing at the first\n** hint of unplanned behavior.\n**\n** In other words, ALWAYS and NEVER are added for defensive code.\n**\n** When doing coverage testing ALWAYS and NEVER are hard-coded to\n** be true and false so that the unreachable code they specify will\n** not be counted as untested code.\n*/\n#if defined(SQLITE_COVERAGE_TEST) || defined(SQLITE_MUTATION_TEST)\n# define ALWAYS(X)      (1)\n# define NEVER(X)       (0)\n#elif !defined(NDEBUG)\n# define ALWAYS(X)      ((X)?1:(assert(0),0))\n# define NEVER(X)       ((X)?(assert(0),1):0)\n#else\n# define ALWAYS(X)      (X)\n# define NEVER(X)       (X)\n#endif\n\n/*\n** Some conditionals are optimizations only.  In other words, if the\n** conditionals are replaced with a constant 1 (true) or 0 (false) then\n** the correct answer is still obtained, though perhaps not as quickly.\n**\n** The following macros mark these optimizations conditionals.\n*/\n#if defined(SQLITE_MUTATION_TEST)\n# define OK_IF_ALWAYS_TRUE(X)  (1)\n# define OK_IF_ALWAYS_FALSE(X) (0)\n#else\n# define OK_IF_ALWAYS_TRUE(X)  (X)\n# define OK_IF_ALWAYS_FALSE(X) (X)\n#endif\n\n/*\n** Some malloc failures are only possible if SQLITE_TEST_REALLOC_STRESS is\n** defined.  We need to defend against those failures when testing with\n** SQLITE_TEST_REALLOC_STRESS, but we don't want the unreachable branches\n** during a normal build.  The following macro can be used to disable tests\n** that are always false except when SQLITE_TEST_REALLOC_STRESS is set.\n*/\n#if defined(SQLITE_TEST_REALLOC_STRESS)\n# define ONLY_IF_REALLOC_STRESS(X)  (X)\n#elif !defined(NDEBUG)\n# define ONLY_IF_REALLOC_STRESS(X)  ((X)?(assert(0),1):0)\n#else\n# define ONLY_IF_REALLOC_STRESS(X)  (0)\n#endif\n\n/*\n** Declarations used for tracing the operating system interfaces.\n*/\n#if defined(SQLITE_FORCE_OS_TRACE) || defined(SQLITE_TEST) || \\\n    (defined(SQLITE_DEBUG) && SQLITE_OS_WIN)\n  extern int sqlite3OSTrace;\n# define OSTRACE(X)          if( sqlite3OSTrace ) sqlite3DebugPrintf X\n# define SQLITE_HAVE_OS_TRACE\n#else\n# define OSTRACE(X)\n# undef  SQLITE_HAVE_OS_TRACE\n#endif\n\n/*\n** Is the sqlite3ErrName() function needed in the build?  Currently,\n** it is needed by \"mutex_w32.c\" (when debugging), \"os_win.c\" (when\n** OSTRACE is enabled), and by several \"test*.c\" files (which are\n** compiled using SQLITE_TEST).\n*/\n#if defined(SQLITE_HAVE_OS_TRACE) || defined(SQLITE_TEST) || \\\n    (defined(SQLITE_DEBUG) && SQLITE_OS_WIN)\n# define SQLITE_NEED_ERR_NAME\n#else\n# undef  SQLITE_NEED_ERR_NAME\n#endif\n\n/*\n** SQLITE_ENABLE_EXPLAIN_COMMENTS is incompatible with SQLITE_OMIT_EXPLAIN\n*/\n#ifdef SQLITE_OMIT_EXPLAIN\n# undef SQLITE_ENABLE_EXPLAIN_COMMENTS\n#endif\n\n/*\n** Return true (non-zero) if the input is an integer that is too large\n** to fit in 32-bits.  This macro is used inside of various testcase()\n** macros to verify that we have tested SQLite for large-file support.\n*/\n#define IS_BIG_INT(X)  (((X)&~(i64)0xffffffff)!=0)\n\n/*\n** The macro unlikely() is a hint that surrounds a boolean\n** expression that is usually false.  Macro likely() surrounds\n** a boolean expression that is usually true.  These hints could,\n** in theory, be used by the compiler to generate better code, but\n** currently they are just comments for human readers.\n*/\n#define likely(X)    (X)\n#define unlikely(X)  (X)\n\n#include \"hash.h\"\n#include \"parse.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <stddef.h>\n\n/*\n** Use a macro to replace memcpy() if compiled with SQLITE_INLINE_MEMCPY.\n** This allows better measurements of where memcpy() is used when running\n** cachegrind.  But this macro version of memcpy() is very slow so it\n** should not be used in production.  This is a performance measurement\n** hack only.\n*/\n#ifdef SQLITE_INLINE_MEMCPY\n# define memcpy(D,S,N) {char*xxd=(char*)(D);const char*xxs=(const char*)(S);\\\n                        int xxn=(N);while(xxn-->0)*(xxd++)=*(xxs++);}\n#endif\n\n/*\n** If compiling for a processor that lacks floating point support,\n** substitute integer for floating-point\n*/\n#ifdef SQLITE_OMIT_FLOATING_POINT\n# define double sqlite_int64\n# define float sqlite_int64\n# define LONGDOUBLE_TYPE sqlite_int64\n# ifndef SQLITE_BIG_DBL\n#   define SQLITE_BIG_DBL (((sqlite3_int64)1)<<50)\n# endif\n# define SQLITE_OMIT_DATETIME_FUNCS 1\n# define SQLITE_OMIT_TRACE 1\n# undef SQLITE_MIXED_ENDIAN_64BIT_FLOAT\n# undef SQLITE_HAVE_ISNAN\n#endif\n#ifndef SQLITE_BIG_DBL\n# define SQLITE_BIG_DBL (1e99)\n#endif\n\n/*\n** OMIT_TEMPDB is set to 1 if SQLITE_OMIT_TEMPDB is defined, or 0\n** afterward. Having this macro allows us to cause the C compiler\n** to omit code used by TEMP tables without messy #ifndef statements.\n*/\n#ifdef SQLITE_OMIT_TEMPDB\n#define OMIT_TEMPDB 1\n#else\n#define OMIT_TEMPDB 0\n#endif\n\n/*\n** The \"file format\" number is an integer that is incremented whenever\n** the VDBE-level file format changes.  The following macros define the\n** the default file format for new databases and the maximum file format\n** that the library can read.\n*/\n#define SQLITE_MAX_FILE_FORMAT 4\n#ifndef SQLITE_DEFAULT_FILE_FORMAT\n# define SQLITE_DEFAULT_FILE_FORMAT 4\n#endif\n\n/*\n** Determine whether triggers are recursive by default.  This can be\n** changed at run-time using a pragma.\n*/\n#ifndef SQLITE_DEFAULT_RECURSIVE_TRIGGERS\n# define SQLITE_DEFAULT_RECURSIVE_TRIGGERS 0\n#endif\n\n/*\n** Provide a default value for SQLITE_TEMP_STORE in case it is not specified\n** on the command-line\n*/\n#ifndef SQLITE_TEMP_STORE\n# define SQLITE_TEMP_STORE 1\n#endif\n\n/*\n** If no value has been provided for SQLITE_MAX_WORKER_THREADS, or if\n** SQLITE_TEMP_STORE is set to 3 (never use temporary files), set it\n** to zero.\n*/\n#if SQLITE_TEMP_STORE==3 || SQLITE_THREADSAFE==0\n# undef SQLITE_MAX_WORKER_THREADS\n# define SQLITE_MAX_WORKER_THREADS 0\n#endif\n#ifndef SQLITE_MAX_WORKER_THREADS\n# define SQLITE_MAX_WORKER_THREADS 8\n#endif\n#ifndef SQLITE_DEFAULT_WORKER_THREADS\n# define SQLITE_DEFAULT_WORKER_THREADS 0\n#endif\n#if SQLITE_DEFAULT_WORKER_THREADS>SQLITE_MAX_WORKER_THREADS\n# undef SQLITE_MAX_WORKER_THREADS\n# define SQLITE_MAX_WORKER_THREADS SQLITE_DEFAULT_WORKER_THREADS\n#endif\n\n/*\n** The default initial allocation for the pagecache when using separate\n** pagecaches for each database connection.  A positive number is the\n** number of pages.  A negative number N translations means that a buffer\n** of -1024*N bytes is allocated and used for as many pages as it will hold.\n**\n** The default value of \"20\" was choosen to minimize the run-time of the\n** speedtest1 test program with options: --shrink-memory --reprepare\n*/\n#ifndef SQLITE_DEFAULT_PCACHE_INITSZ\n# define SQLITE_DEFAULT_PCACHE_INITSZ 20\n#endif\n\n/*\n** Default value for the SQLITE_CONFIG_SORTERREF_SIZE option.\n*/\n#ifndef SQLITE_DEFAULT_SORTERREF_SIZE\n# define SQLITE_DEFAULT_SORTERREF_SIZE 0x7fffffff\n#endif\n\n/*\n** The compile-time options SQLITE_MMAP_READWRITE and \n** SQLITE_ENABLE_BATCH_ATOMIC_WRITE are not compatible with one another.\n** You must choose one or the other (or neither) but not both.\n*/\n#if defined(SQLITE_MMAP_READWRITE) && defined(SQLITE_ENABLE_BATCH_ATOMIC_WRITE)\n#error Cannot use both SQLITE_MMAP_READWRITE and SQLITE_ENABLE_BATCH_ATOMIC_WRITE\n#endif\n\n/*\n** GCC does not define the offsetof() macro so we'll have to do it\n** ourselves.\n*/\n#ifndef offsetof\n#define offsetof(STRUCTURE,FIELD) ((int)((char*)&((STRUCTURE*)0)->FIELD))\n#endif\n\n/*\n** Macros to compute minimum and maximum of two numbers.\n*/\n#ifndef MIN\n# define MIN(A,B) ((A)<(B)?(A):(B))\n#endif\n#ifndef MAX\n# define MAX(A,B) ((A)>(B)?(A):(B))\n#endif\n\n/*\n** Swap two objects of type TYPE.\n*/\n#define SWAP(TYPE,A,B) {TYPE t=A; A=B; B=t;}\n\n/*\n** Check to see if this machine uses EBCDIC.  (Yes, believe it or\n** not, there are still machines out there that use EBCDIC.)\n*/\n#if 'A' == '\\301'\n# define SQLITE_EBCDIC 1\n#else\n# define SQLITE_ASCII 1\n#endif\n\n/*\n** Integers of known sizes.  These typedefs might change for architectures\n** where the sizes very.  Preprocessor macros are available so that the\n** types can be conveniently redefined at compile-type.  Like this:\n**\n**         cc '-DUINTPTR_TYPE=long long int' ...\n*/\n#ifndef UINT32_TYPE\n# ifdef HAVE_UINT32_T\n#  define UINT32_TYPE uint32_t\n# else\n#  define UINT32_TYPE unsigned int\n# endif\n#endif\n#ifndef UINT16_TYPE\n# ifdef HAVE_UINT16_T\n#  define UINT16_TYPE uint16_t\n# else\n#  define UINT16_TYPE unsigned short int\n# endif\n#endif\n#ifndef INT16_TYPE\n# ifdef HAVE_INT16_T\n#  define INT16_TYPE int16_t\n# else\n#  define INT16_TYPE short int\n# endif\n#endif\n#ifndef UINT8_TYPE\n# ifdef HAVE_UINT8_T\n#  define UINT8_TYPE uint8_t\n# else\n#  define UINT8_TYPE unsigned char\n# endif\n#endif\n#ifndef INT8_TYPE\n# ifdef HAVE_INT8_T\n#  define INT8_TYPE int8_t\n# else\n#  define INT8_TYPE signed char\n# endif\n#endif\n#ifndef LONGDOUBLE_TYPE\n# define LONGDOUBLE_TYPE long double\n#endif\ntypedef sqlite_int64 i64;          /* 8-byte signed integer */\ntypedef sqlite_uint64 u64;         /* 8-byte unsigned integer */\ntypedef UINT32_TYPE u32;           /* 4-byte unsigned integer */\ntypedef UINT16_TYPE u16;           /* 2-byte unsigned integer */\ntypedef INT16_TYPE i16;            /* 2-byte signed integer */\ntypedef UINT8_TYPE u8;             /* 1-byte unsigned integer */\ntypedef INT8_TYPE i8;              /* 1-byte signed integer */\n\n/*\n** SQLITE_MAX_U32 is a u64 constant that is the maximum u64 value\n** that can be stored in a u32 without loss of data.  The value\n** is 0x00000000ffffffff.  But because of quirks of some compilers, we\n** have to specify the value in the less intuitive manner shown:\n*/\n#define SQLITE_MAX_U32  ((((u64)1)<<32)-1)\n\n/*\n** The datatype used to store estimates of the number of rows in a\n** table or index.  This is an unsigned integer type.  For 99.9% of\n** the world, a 32-bit integer is sufficient.  But a 64-bit integer\n** can be used at compile-time if desired.\n*/\n#ifdef SQLITE_64BIT_STATS\n typedef u64 tRowcnt;    /* 64-bit only if requested at compile-time */\n#else\n typedef u32 tRowcnt;    /* 32-bit is the default */\n#endif\n\n/*\n** Estimated quantities used for query planning are stored as 16-bit\n** logarithms.  For quantity X, the value stored is 10*log2(X).  This\n** gives a possible range of values of approximately 1.0e986 to 1e-986.\n** But the allowed values are \"grainy\".  Not every value is representable.\n** For example, quantities 16 and 17 are both represented by a LogEst\n** of 40.  However, since LogEst quantities are suppose to be estimates,\n** not exact values, this imprecision is not a problem.\n**\n** \"LogEst\" is short for \"Logarithmic Estimate\".\n**\n** Examples:\n**      1 -> 0              20 -> 43          10000 -> 132\n**      2 -> 10             25 -> 46          25000 -> 146\n**      3 -> 16            100 -> 66        1000000 -> 199\n**      4 -> 20           1000 -> 99        1048576 -> 200\n**     10 -> 33           1024 -> 100    4294967296 -> 320\n**\n** The LogEst can be negative to indicate fractional values.\n** Examples:\n**\n**    0.5 -> -10           0.1 -> -33        0.0625 -> -40\n*/\ntypedef INT16_TYPE LogEst;\n\n/*\n** Set the SQLITE_PTRSIZE macro to the number of bytes in a pointer\n*/\n#ifndef SQLITE_PTRSIZE\n# if defined(__SIZEOF_POINTER__)\n#   define SQLITE_PTRSIZE __SIZEOF_POINTER__\n# elif defined(i386)     || defined(__i386__)   || defined(_M_IX86) ||    \\\n       defined(_M_ARM)   || defined(__arm__)    || defined(__x86)   ||    \\\n      (defined(__TOS_AIX__) && !defined(__64BIT__))\n#   define SQLITE_PTRSIZE 4\n# else\n#   define SQLITE_PTRSIZE 8\n# endif\n#endif\n\n/* The uptr type is an unsigned integer large enough to hold a pointer\n*/\n#if defined(HAVE_STDINT_H)\n  typedef uintptr_t uptr;\n#elif SQLITE_PTRSIZE==4\n  typedef u32 uptr;\n#else\n  typedef u64 uptr;\n#endif\n\n/*\n** The SQLITE_WITHIN(P,S,E) macro checks to see if pointer P points to\n** something between S (inclusive) and E (exclusive).\n**\n** In other words, S is a buffer and E is a pointer to the first byte after\n** the end of buffer S.  This macro returns true if P points to something\n** contained within the buffer S.\n*/\n#define SQLITE_WITHIN(P,S,E) (((uptr)(P)>=(uptr)(S))&&((uptr)(P)<(uptr)(E)))\n\n\n/*\n** Macros to determine whether the machine is big or little endian,\n** and whether or not that determination is run-time or compile-time.\n**\n** For best performance, an attempt is made to guess at the byte-order\n** using C-preprocessor macros.  If that is unsuccessful, or if\n** -DSQLITE_BYTEORDER=0 is set, then byte-order is determined\n** at run-time.\n*/\n#ifndef SQLITE_BYTEORDER\n# if defined(i386)      || defined(__i386__)      || defined(_M_IX86) ||    \\\n     defined(__x86_64)  || defined(__x86_64__)    || defined(_M_X64)  ||    \\\n     defined(_M_AMD64)  || defined(_M_ARM)        || defined(__x86)   ||    \\\n     defined(__ARMEL__) || defined(__AARCH64EL__) || defined(_M_ARM64)\n#   define SQLITE_BYTEORDER    1234\n# elif defined(sparc)     || defined(__ppc__) || \\\n       defined(__ARMEB__) || defined(__AARCH64EB__)\n#   define SQLITE_BYTEORDER    4321\n# else\n#   define SQLITE_BYTEORDER 0\n# endif\n#endif\n#if SQLITE_BYTEORDER==4321\n# define SQLITE_BIGENDIAN    1\n# define SQLITE_LITTLEENDIAN 0\n# define SQLITE_UTF16NATIVE  SQLITE_UTF16BE\n#elif SQLITE_BYTEORDER==1234\n# define SQLITE_BIGENDIAN    0\n# define SQLITE_LITTLEENDIAN 1\n# define SQLITE_UTF16NATIVE  SQLITE_UTF16LE\n#else\n# ifdef SQLITE_AMALGAMATION\n  const int sqlite3one = 1;\n# else\n  extern const int sqlite3one;\n# endif\n# define SQLITE_BIGENDIAN    (*(char *)(&sqlite3one)==0)\n# define SQLITE_LITTLEENDIAN (*(char *)(&sqlite3one)==1)\n# define SQLITE_UTF16NATIVE  (SQLITE_BIGENDIAN?SQLITE_UTF16BE:SQLITE_UTF16LE)\n#endif\n\n/*\n** Constants for the largest and smallest possible 64-bit signed integers.\n** These macros are designed to work correctly on both 32-bit and 64-bit\n** compilers.\n*/\n#define LARGEST_INT64  (0xffffffff|(((i64)0x7fffffff)<<32))\n#define SMALLEST_INT64 (((i64)-1) - LARGEST_INT64)\n\n/*\n** Round up a number to the next larger multiple of 8.  This is used\n** to force 8-byte alignment on 64-bit architectures.\n*/\n#define ROUND8(x)     (((x)+7)&~7)\n\n/*\n** Round down to the nearest multiple of 8\n*/\n#define ROUNDDOWN8(x) ((x)&~7)\n\n/*\n** Assert that the pointer X is aligned to an 8-byte boundary.  This\n** macro is used only within assert() to verify that the code gets\n** all alignment restrictions correct.\n**\n** Except, if SQLITE_4_BYTE_ALIGNED_MALLOC is defined, then the\n** underlying malloc() implementation might return us 4-byte aligned\n** pointers.  In that case, only verify 4-byte alignment.\n*/\n#ifdef SQLITE_4_BYTE_ALIGNED_MALLOC\n# define EIGHT_BYTE_ALIGNMENT(X)   ((((char*)(X) - (char*)0)&3)==0)\n#else\n# define EIGHT_BYTE_ALIGNMENT(X)   ((((char*)(X) - (char*)0)&7)==0)\n#endif\n\n/*\n** Disable MMAP on platforms where it is known to not work\n*/\n#if defined(__OpenBSD__) || defined(__QNXNTO__)\n# undef SQLITE_MAX_MMAP_SIZE\n# define SQLITE_MAX_MMAP_SIZE 0\n#endif\n\n/*\n** Default maximum size of memory used by memory-mapped I/O in the VFS\n*/\n#ifdef __APPLE__\n# include <TargetConditionals.h>\n#endif\n#ifndef SQLITE_MAX_MMAP_SIZE\n# if defined(__linux__) \\\n  || defined(_WIN32) \\\n  || (defined(__APPLE__) && defined(__MACH__)) \\\n  || defined(__sun) \\\n  || defined(__FreeBSD__) \\\n  || defined(__DragonFly__)\n#   define SQLITE_MAX_MMAP_SIZE 0x7fff0000  /* 2147418112 */\n# else\n#   define SQLITE_MAX_MMAP_SIZE 0\n# endif\n#endif\n\n/*\n** The default MMAP_SIZE is zero on all platforms.  Or, even if a larger\n** default MMAP_SIZE is specified at compile-time, make sure that it does\n** not exceed the maximum mmap size.\n*/\n#ifndef SQLITE_DEFAULT_MMAP_SIZE\n# define SQLITE_DEFAULT_MMAP_SIZE 0\n#endif\n#if SQLITE_DEFAULT_MMAP_SIZE>SQLITE_MAX_MMAP_SIZE\n# undef SQLITE_DEFAULT_MMAP_SIZE\n# define SQLITE_DEFAULT_MMAP_SIZE SQLITE_MAX_MMAP_SIZE\n#endif\n\n/*\n** SELECTTRACE_ENABLED will be either 1 or 0 depending on whether or not\n** the Select query generator tracing logic is turned on.\n*/\n#if defined(SQLITE_ENABLE_SELECTTRACE)\n# define SELECTTRACE_ENABLED 1\n#else\n# define SELECTTRACE_ENABLED 0\n#endif\n\n/*\n** An instance of the following structure is used to store the busy-handler\n** callback for a given sqlite handle.\n**\n** The sqlite.busyHandler member of the sqlite struct contains the busy\n** callback for the database handle. Each pager opened via the sqlite\n** handle is passed a pointer to sqlite.busyHandler. The busy-handler\n** callback is currently invoked only from within pager.c.\n*/\ntypedef struct BusyHandler BusyHandler;\nstruct BusyHandler {\n  int (*xBusyHandler)(void *,int);  /* The busy callback */\n  void *pBusyArg;                   /* First arg to busy callback */\n  int nBusy;                        /* Incremented with each busy call */\n  u8 bExtraFileArg;                 /* Include sqlite3_file as callback arg */\n};\n\n/*\n** Name of the master database table.  The master database table\n** is a special table that holds the names and attributes of all\n** user tables and indices.\n*/\n#define MASTER_NAME       \"sqlite_master\"\n#define TEMP_MASTER_NAME  \"sqlite_temp_master\"\n\n/*\n** The root-page of the master database table.\n*/\n#define MASTER_ROOT       1\n\n/*\n** The name of the schema table.\n*/\n#define SCHEMA_TABLE(x)  ((!OMIT_TEMPDB)&&(x==1)?TEMP_MASTER_NAME:MASTER_NAME)\n\n/*\n** A convenience macro that returns the number of elements in\n** an array.\n*/\n#define ArraySize(X)    ((int)(sizeof(X)/sizeof(X[0])))\n\n/*\n** Determine if the argument is a power of two\n*/\n#define IsPowerOfTwo(X) (((X)&((X)-1))==0)\n\n/*\n** The following value as a destructor means to use sqlite3DbFree().\n** The sqlite3DbFree() routine requires two parameters instead of the\n** one parameter that destructors normally want.  So we have to introduce\n** this magic value that the code knows to handle differently.  Any\n** pointer will work here as long as it is distinct from SQLITE_STATIC\n** and SQLITE_TRANSIENT.\n*/\n#define SQLITE_DYNAMIC   ((sqlite3_destructor_type)sqlite3MallocSize)\n\n/*\n** When SQLITE_OMIT_WSD is defined, it means that the target platform does\n** not support Writable Static Data (WSD) such as global and static variables.\n** All variables must either be on the stack or dynamically allocated from\n** the heap.  When WSD is unsupported, the variable declarations scattered\n** throughout the SQLite code must become constants instead.  The SQLITE_WSD\n** macro is used for this purpose.  And instead of referencing the variable\n** directly, we use its constant as a key to lookup the run-time allocated\n** buffer that holds real variable.  The constant is also the initializer\n** for the run-time allocated buffer.\n**\n** In the usual case where WSD is supported, the SQLITE_WSD and GLOBAL\n** macros become no-ops and have zero performance impact.\n*/\n#ifdef SQLITE_OMIT_WSD\n  #define SQLITE_WSD const\n  #define GLOBAL(t,v) (*(t*)sqlite3_wsd_find((void*)&(v), sizeof(v)))\n  #define sqlite3GlobalConfig GLOBAL(struct Sqlite3Config, sqlite3Config)\n  int sqlite3_wsd_init(int N, int J);\n  void *sqlite3_wsd_find(void *K, int L);\n#else\n  #define SQLITE_WSD\n  #define GLOBAL(t,v) v\n  #define sqlite3GlobalConfig sqlite3Config\n#endif\n\n/*\n** The following macros are used to suppress compiler warnings and to\n** make it clear to human readers when a function parameter is deliberately\n** left unused within the body of a function. This usually happens when\n** a function is called via a function pointer. For example the\n** implementation of an SQL aggregate step callback may not use the\n** parameter indicating the number of arguments passed to the aggregate,\n** if it knows that this is enforced elsewhere.\n**\n** When a function parameter is not used at all within the body of a function,\n** it is generally named \"NotUsed\" or \"NotUsed2\" to make things even clearer.\n** However, these macros may also be used to suppress warnings related to\n** parameters that may or may not be used depending on compilation options.\n** For example those parameters only used in assert() statements. In these\n** cases the parameters are named as per the usual conventions.\n*/\n#define UNUSED_PARAMETER(x) (void)(x)\n#define UNUSED_PARAMETER2(x,y) UNUSED_PARAMETER(x),UNUSED_PARAMETER(y)\n\n/*\n** Forward references to structures\n*/\ntypedef struct AggInfo AggInfo;\ntypedef struct AuthContext AuthContext;\ntypedef struct AutoincInfo AutoincInfo;\ntypedef struct Bitvec Bitvec;\ntypedef struct CollSeq CollSeq;\ntypedef struct Column Column;\ntypedef struct Db Db;\ntypedef struct Schema Schema;\ntypedef struct Expr Expr;\ntypedef struct ExprList ExprList;\ntypedef struct FKey FKey;\ntypedef struct FuncDestructor FuncDestructor;\ntypedef struct FuncDef FuncDef;\ntypedef struct FuncDefHash FuncDefHash;\ntypedef struct IdList IdList;\ntypedef struct Index Index;\ntypedef struct IndexSample IndexSample;\ntypedef struct KeyClass KeyClass;\ntypedef struct KeyInfo KeyInfo;\ntypedef struct Lookaside Lookaside;\ntypedef struct LookasideSlot LookasideSlot;\ntypedef struct Module Module;\ntypedef struct NameContext NameContext;\ntypedef struct Parse Parse;\ntypedef struct PreUpdate PreUpdate;\ntypedef struct PrintfArguments PrintfArguments;\ntypedef struct RenameToken RenameToken;\ntypedef struct RowSet RowSet;\ntypedef struct Savepoint Savepoint;\ntypedef struct Select Select;\ntypedef struct SQLiteThread SQLiteThread;\ntypedef struct SelectDest SelectDest;\ntypedef struct SrcList SrcList;\ntypedef struct sqlite3_str StrAccum; /* Internal alias for sqlite3_str */\ntypedef struct Table Table;\ntypedef struct TableLock TableLock;\ntypedef struct Token Token;\ntypedef struct TreeView TreeView;\ntypedef struct Trigger Trigger;\ntypedef struct TriggerPrg TriggerPrg;\ntypedef struct TriggerStep TriggerStep;\ntypedef struct UnpackedRecord UnpackedRecord;\ntypedef struct Upsert Upsert;\ntypedef struct VTable VTable;\ntypedef struct VtabCtx VtabCtx;\ntypedef struct Walker Walker;\ntypedef struct WhereInfo WhereInfo;\ntypedef struct Window Window;\ntypedef struct With With;\n\n\n/*\n** The bitmask datatype defined below is used for various optimizations.\n**\n** Changing this from a 64-bit to a 32-bit type limits the number of\n** tables in a join to 32 instead of 64.  But it also reduces the size\n** of the library by 738 bytes on ix86.\n*/\n#ifdef SQLITE_BITMASK_TYPE\n  typedef SQLITE_BITMASK_TYPE Bitmask;\n#else\n  typedef u64 Bitmask;\n#endif\n\n/*\n** The number of bits in a Bitmask.  \"BMS\" means \"BitMask Size\".\n*/\n#define BMS  ((int)(sizeof(Bitmask)*8))\n\n/*\n** A bit in a Bitmask\n*/\n#define MASKBIT(n)   (((Bitmask)1)<<(n))\n#define MASKBIT32(n) (((unsigned int)1)<<(n))\n#define ALLBITS      ((Bitmask)-1)\n\n/* A VList object records a mapping between parameters/variables/wildcards\n** in the SQL statement (such as $abc, @pqr, or :xyz) and the integer\n** variable number associated with that parameter.  See the format description\n** on the sqlite3VListAdd() routine for more information.  A VList is really\n** just an array of integers.\n*/\ntypedef int VList;\n\n/*\n** Defer sourcing vdbe.h and btree.h until after the \"u8\" and\n** \"BusyHandler\" typedefs. vdbe.h also requires a few of the opaque\n** pointer types (i.e. FuncDef) defined above.\n*/\n#include \"btree.h\"\n#include \"vdbe.h\"\n#include \"pager.h\"\n#include \"pcache.h\"\n#include \"os.h\"\n#include \"mutex.h\"\n\n/* The SQLITE_EXTRA_DURABLE compile-time option used to set the default\n** synchronous setting to EXTRA.  It is no longer supported.\n*/\n#ifdef SQLITE_EXTRA_DURABLE\n# warning Use SQLITE_DEFAULT_SYNCHRONOUS=3 instead of SQLITE_EXTRA_DURABLE\n# define SQLITE_DEFAULT_SYNCHRONOUS 3\n#endif\n\n/*\n** Default synchronous levels.\n**\n** Note that (for historcal reasons) the PAGER_SYNCHRONOUS_* macros differ\n** from the SQLITE_DEFAULT_SYNCHRONOUS value by 1.\n**\n**           PAGER_SYNCHRONOUS       DEFAULT_SYNCHRONOUS\n**   OFF           1                         0\n**   NORMAL        2                         1\n**   FULL          3                         2\n**   EXTRA         4                         3\n**\n** The \"PRAGMA synchronous\" statement also uses the zero-based numbers.\n** In other words, the zero-based numbers are used for all external interfaces\n** and the one-based values are used internally.\n*/\n#ifndef SQLITE_DEFAULT_SYNCHRONOUS\n# define SQLITE_DEFAULT_SYNCHRONOUS 2\n#endif\n#ifndef SQLITE_DEFAULT_WAL_SYNCHRONOUS\n# define SQLITE_DEFAULT_WAL_SYNCHRONOUS SQLITE_DEFAULT_SYNCHRONOUS\n#endif\n\n/*\n** Each database file to be accessed by the system is an instance\n** of the following structure.  There are normally two of these structures\n** in the sqlite.aDb[] array.  aDb[0] is the main database file and\n** aDb[1] is the database file used to hold temporary tables.  Additional\n** databases may be attached.\n*/\nstruct Db {\n  char *zDbSName;      /* Name of this database. (schema name, not filename) */\n  Btree *pBt;          /* The B*Tree structure for this database file */\n  u8 safety_level;     /* How aggressive at syncing data to disk */\n  u8 bSyncSet;         /* True if \"PRAGMA synchronous=N\" has been run */\n  Schema *pSchema;     /* Pointer to database schema (possibly shared) */\n};\n\n/*\n** An instance of the following structure stores a database schema.\n**\n** Most Schema objects are associated with a Btree.  The exception is\n** the Schema for the TEMP databaes (sqlite3.aDb[1]) which is free-standing.\n** In shared cache mode, a single Schema object can be shared by multiple\n** Btrees that refer to the same underlying BtShared object.\n**\n** Schema objects are automatically deallocated when the last Btree that\n** references them is destroyed.   The TEMP Schema is manually freed by\n** sqlite3_close().\n*\n** A thread must be holding a mutex on the corresponding Btree in order\n** to access Schema content.  This implies that the thread must also be\n** holding a mutex on the sqlite3 connection pointer that owns the Btree.\n** For a TEMP Schema, only the connection mutex is required.\n*/\nstruct Schema {\n  int schema_cookie;   /* Database schema version number for this file */\n  int iGeneration;     /* Generation counter.  Incremented with each change */\n  Hash tblHash;        /* All tables indexed by name */\n  Hash idxHash;        /* All (named) indices indexed by name */\n  Hash trigHash;       /* All triggers indexed by name */\n  Hash fkeyHash;       /* All foreign keys by referenced table name */\n  Table *pSeqTab;      /* The sqlite_sequence table used by AUTOINCREMENT */\n  u8 file_format;      /* Schema format version for this file */\n  u8 enc;              /* Text encoding used by this database */\n  u16 schemaFlags;     /* Flags associated with this schema */\n  int cache_size;      /* Number of pages to use in the cache */\n};\n\n/*\n** These macros can be used to test, set, or clear bits in the\n** Db.pSchema->flags field.\n*/\n#define DbHasProperty(D,I,P)     (((D)->aDb[I].pSchema->schemaFlags&(P))==(P))\n#define DbHasAnyProperty(D,I,P)  (((D)->aDb[I].pSchema->schemaFlags&(P))!=0)\n#define DbSetProperty(D,I,P)     (D)->aDb[I].pSchema->schemaFlags|=(P)\n#define DbClearProperty(D,I,P)   (D)->aDb[I].pSchema->schemaFlags&=~(P)\n\n/*\n** Allowed values for the DB.pSchema->flags field.\n**\n** The DB_SchemaLoaded flag is set after the database schema has been\n** read into internal hash tables.\n**\n** DB_UnresetViews means that one or more views have column names that\n** have been filled out.  If the schema changes, these column names might\n** changes and so the view will need to be reset.\n*/\n#define DB_SchemaLoaded    0x0001  /* The schema has been loaded */\n#define DB_UnresetViews    0x0002  /* Some views have defined column names */\n#define DB_Empty           0x0004  /* The file is empty (length 0 bytes) */\n#define DB_ResetWanted     0x0008  /* Reset the schema when nSchemaLock==0 */\n\n/*\n** The number of different kinds of things that can be limited\n** using the sqlite3_limit() interface.\n*/\n#define SQLITE_N_LIMIT (SQLITE_LIMIT_WORKER_THREADS+1)\n\n/*\n** Lookaside malloc is a set of fixed-size buffers that can be used\n** to satisfy small transient memory allocation requests for objects\n** associated with a particular database connection.  The use of\n** lookaside malloc provides a significant performance enhancement\n** (approx 10%) by avoiding numerous malloc/free requests while parsing\n** SQL statements.\n**\n** The Lookaside structure holds configuration information about the\n** lookaside malloc subsystem.  Each available memory allocation in\n** the lookaside subsystem is stored on a linked list of LookasideSlot\n** objects.\n**\n** Lookaside allocations are only allowed for objects that are associated\n** with a particular database connection.  Hence, schema information cannot\n** be stored in lookaside because in shared cache mode the schema information\n** is shared by multiple database connections.  Therefore, while parsing\n** schema information, the Lookaside.bEnabled flag is cleared so that\n** lookaside allocations are not used to construct the schema objects.\n**\n** New lookaside allocations are only allowed if bDisable==0.  When\n** bDisable is greater than zero, sz is set to zero which effectively\n** disables lookaside without adding a new test for the bDisable flag\n** in a performance-critical path.  sz should be set by to szTrue whenever\n** bDisable changes back to zero.\n*/\nstruct Lookaside {\n  u32 bDisable;           /* Only operate the lookaside when zero */\n  u16 sz;                 /* Size of each buffer in bytes */\n  u16 szTrue;             /* True value of sz, even if disabled */\n  u8 bMalloced;           /* True if pStart obtained from sqlite3_malloc() */\n  u32 nSlot;              /* Number of lookaside slots allocated */\n  u32 anStat[3];          /* 0: hits.  1: size misses.  2: full misses */\n  LookasideSlot *pInit;   /* List of buffers not previously used */\n  LookasideSlot *pFree;   /* List of available buffers */\n  void *pStart;           /* First byte of available memory space */\n  void *pEnd;             /* First byte past end of available space */\n};\nstruct LookasideSlot {\n  LookasideSlot *pNext;    /* Next buffer in the list of free buffers */\n};\n\n#define DisableLookaside  db->lookaside.bDisable++;db->lookaside.sz=0\n#define EnableLookaside   db->lookaside.bDisable--;\\\n   db->lookaside.sz=db->lookaside.bDisable?0:db->lookaside.szTrue\n\n/*\n** A hash table for built-in function definitions.  (Application-defined\n** functions use a regular table table from hash.h.)\n**\n** Hash each FuncDef structure into one of the FuncDefHash.a[] slots.\n** Collisions are on the FuncDef.u.pHash chain.  Use the SQLITE_FUNC_HASH()\n** macro to compute a hash on the function name.\n*/\n#define SQLITE_FUNC_HASH_SZ 23\nstruct FuncDefHash {\n  FuncDef *a[SQLITE_FUNC_HASH_SZ];       /* Hash table for functions */\n};\n#define SQLITE_FUNC_HASH(C,L) (((C)+(L))%SQLITE_FUNC_HASH_SZ)\n\n#ifdef SQLITE_USER_AUTHENTICATION\n/*\n** Information held in the \"sqlite3\" database connection object and used\n** to manage user authentication.\n*/\ntypedef struct sqlite3_userauth sqlite3_userauth;\nstruct sqlite3_userauth {\n  u8 authLevel;                 /* Current authentication level */\n  int nAuthPW;                  /* Size of the zAuthPW in bytes */\n  char *zAuthPW;                /* Password used to authenticate */\n  char *zAuthUser;              /* User name used to authenticate */\n};\n\n/* Allowed values for sqlite3_userauth.authLevel */\n#define UAUTH_Unknown     0     /* Authentication not yet checked */\n#define UAUTH_Fail        1     /* User authentication failed */\n#define UAUTH_User        2     /* Authenticated as a normal user */\n#define UAUTH_Admin       3     /* Authenticated as an administrator */\n\n/* Functions used only by user authorization logic */\nint sqlite3UserAuthTable(const char*);\nint sqlite3UserAuthCheckLogin(sqlite3*,const char*,u8*);\nvoid sqlite3UserAuthInit(sqlite3*);\nvoid sqlite3CryptFunc(sqlite3_context*,int,sqlite3_value**);\n\n#endif /* SQLITE_USER_AUTHENTICATION */\n\n/*\n** typedef for the authorization callback function.\n*/\n#ifdef SQLITE_USER_AUTHENTICATION\n  typedef int (*sqlite3_xauth)(void*,int,const char*,const char*,const char*,\n                               const char*, const char*);\n#else\n  typedef int (*sqlite3_xauth)(void*,int,const char*,const char*,const char*,\n                               const char*);\n#endif\n\n#ifndef SQLITE_OMIT_DEPRECATED\n/* This is an extra SQLITE_TRACE macro that indicates \"legacy\" tracing\n** in the style of sqlite3_trace()\n*/\n#define SQLITE_TRACE_LEGACY          0x40     /* Use the legacy xTrace */\n#define SQLITE_TRACE_XPROFILE        0x80     /* Use the legacy xProfile */\n#else\n#define SQLITE_TRACE_LEGACY          0\n#define SQLITE_TRACE_XPROFILE        0\n#endif /* SQLITE_OMIT_DEPRECATED */\n#define SQLITE_TRACE_NONLEGACY_MASK  0x0f     /* Normal flags */\n\n\n/*\n** Each database connection is an instance of the following structure.\n*/\nstruct sqlite3 {\n  sqlite3_vfs *pVfs;            /* OS Interface */\n  struct Vdbe *pVdbe;           /* List of active virtual machines */\n  CollSeq *pDfltColl;           /* The default collating sequence (BINARY) */\n  sqlite3_mutex *mutex;         /* Connection mutex */\n  Db *aDb;                      /* All backends */\n  int nDb;                      /* Number of backends currently in use */\n  u32 mDbFlags;                 /* flags recording internal state */\n  u64 flags;                    /* flags settable by pragmas. See below */\n  i64 lastRowid;                /* ROWID of most recent insert (see above) */\n  i64 szMmap;                   /* Default mmap_size setting */\n  u32 nSchemaLock;              /* Do not reset the schema when non-zero */\n  unsigned int openFlags;       /* Flags passed to sqlite3_vfs.xOpen() */\n  int errCode;                  /* Most recent error code (SQLITE_*) */\n  int errMask;                  /* & result codes with this before returning */\n  int iSysErrno;                /* Errno value from last system error */\n  u16 dbOptFlags;               /* Flags to enable/disable optimizations */\n  u8 enc;                       /* Text encoding */\n  u8 autoCommit;                /* The auto-commit flag. */\n  u8 temp_store;                /* 1: file 2: memory 0: default */\n  u8 mallocFailed;              /* True if we have seen a malloc failure */\n  u8 bBenignMalloc;             /* Do not require OOMs if true */\n  u8 dfltLockMode;              /* Default locking-mode for attached dbs */\n  signed char nextAutovac;      /* Autovac setting after VACUUM if >=0 */\n  u8 suppressErr;               /* Do not issue error messages if true */\n  u8 vtabOnConflict;            /* Value to return for s3_vtab_on_conflict() */\n  u8 isTransactionSavepoint;    /* True if the outermost savepoint is a TS */\n  u8 mTrace;                    /* zero or more SQLITE_TRACE flags */\n  u8 noSharedCache;             /* True if no shared-cache backends */\n  u8 nSqlExec;                  /* Number of pending OP_SqlExec opcodes */\n  int nextPagesize;             /* Pagesize after VACUUM if >0 */\n  u32 magic;                    /* Magic number for detect library misuse */\n  int nChange;                  /* Value returned by sqlite3_changes() */\n  int nTotalChange;             /* Value returned by sqlite3_total_changes() */\n  int aLimit[SQLITE_N_LIMIT];   /* Limits */\n  int nMaxSorterMmap;           /* Maximum size of regions mapped by sorter */\n  struct sqlite3InitInfo {      /* Information used during initialization */\n    int newTnum;                /* Rootpage of table being initialized */\n    u8 iDb;                     /* Which db file is being initialized */\n    u8 busy;                    /* TRUE if currently initializing */\n    unsigned orphanTrigger : 1; /* Last statement is orphaned TEMP trigger */\n    unsigned imposterTable : 1; /* Building an imposter table */\n    unsigned reopenMemdb : 1;   /* ATTACH is really a reopen using MemDB */\n    char **azInit;              /* \"type\", \"name\", and \"tbl_name\" columns */\n  } init;\n  int nVdbeActive;              /* Number of VDBEs currently running */\n  int nVdbeRead;                /* Number of active VDBEs that read or write */\n  int nVdbeWrite;               /* Number of active VDBEs that read and write */\n  int nVdbeExec;                /* Number of nested calls to VdbeExec() */\n  int nVDestroy;                /* Number of active OP_VDestroy operations */\n  int nExtension;               /* Number of loaded extensions */\n  void **aExtension;            /* Array of shared library handles */\n  int (*xTrace)(u32,void*,void*,void*);     /* Trace function */\n  void *pTraceArg;                          /* Argument to the trace function */\n#ifndef SQLITE_OMIT_DEPRECATED\n  void (*xProfile)(void*,const char*,u64);  /* Profiling function */\n  void *pProfileArg;                        /* Argument to profile function */\n#endif\n  void *pCommitArg;                 /* Argument to xCommitCallback() */\n  int (*xCommitCallback)(void*);    /* Invoked at every commit. */\n  void *pRollbackArg;               /* Argument to xRollbackCallback() */\n  void (*xRollbackCallback)(void*); /* Invoked at every commit. */\n  void *pUpdateArg;\n  void (*xUpdateCallback)(void*,int, const char*,const char*,sqlite_int64);\n  Parse *pParse;                /* Current parse */\n#ifdef SQLITE_ENABLE_PREUPDATE_HOOK\n  void *pPreUpdateArg;          /* First argument to xPreUpdateCallback */\n  void (*xPreUpdateCallback)(   /* Registered using sqlite3_preupdate_hook() */\n    void*,sqlite3*,int,char const*,char const*,sqlite3_int64,sqlite3_int64\n  );\n  PreUpdate *pPreUpdate;        /* Context for active pre-update callback */\n#endif /* SQLITE_ENABLE_PREUPDATE_HOOK */\n#ifndef SQLITE_OMIT_WAL\n  int (*xWalCallback)(void *, sqlite3 *, const char *, int);\n  void *pWalArg;\n#endif\n  void(*xCollNeeded)(void*,sqlite3*,int eTextRep,const char*);\n  void(*xCollNeeded16)(void*,sqlite3*,int eTextRep,const void*);\n  void *pCollNeededArg;\n  sqlite3_value *pErr;          /* Most recent error message */\n  union {\n    volatile int isInterrupted; /* True if sqlite3_interrupt has been called */\n    double notUsed1;            /* Spacer */\n  } u1;\n  Lookaside lookaside;          /* Lookaside malloc configuration */\n#ifndef SQLITE_OMIT_AUTHORIZATION\n  sqlite3_xauth xAuth;          /* Access authorization function */\n  void *pAuthArg;               /* 1st argument to the access auth function */\n#endif\n#ifndef SQLITE_OMIT_PROGRESS_CALLBACK\n  int (*xProgress)(void *);     /* The progress callback */\n  void *pProgressArg;           /* Argument to the progress callback */\n  unsigned nProgressOps;        /* Number of opcodes for progress callback */\n#endif\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n  int nVTrans;                  /* Allocated size of aVTrans */\n  Hash aModule;                 /* populated by sqlite3_create_module() */\n  VtabCtx *pVtabCtx;            /* Context for active vtab connect/create */\n  VTable **aVTrans;             /* Virtual tables with open transactions */\n  VTable *pDisconnect;          /* Disconnect these in next sqlite3_prepare() */\n#endif\n  Hash aFunc;                   /* Hash table of connection functions */\n  Hash aCollSeq;                /* All collating sequences */\n  BusyHandler busyHandler;      /* Busy callback */\n  Db aDbStatic[2];              /* Static space for the 2 default backends */\n  Savepoint *pSavepoint;        /* List of active savepoints */\n  int busyTimeout;              /* Busy handler timeout, in msec */\n  int nSavepoint;               /* Number of non-transaction savepoints */\n  int nStatement;               /* Number of nested statement-transactions  */\n  i64 nDeferredCons;            /* Net deferred constraints this transaction. */\n  i64 nDeferredImmCons;         /* Net deferred immediate constraints */\n  int *pnBytesFreed;            /* If not NULL, increment this in DbFree() */\n#ifdef SQLITE_ENABLE_UNLOCK_NOTIFY\n  /* The following variables are all protected by the STATIC_MASTER\n  ** mutex, not by sqlite3.mutex. They are used by code in notify.c.\n  **\n  ** When X.pUnlockConnection==Y, that means that X is waiting for Y to\n  ** unlock so that it can proceed.\n  **\n  ** When X.pBlockingConnection==Y, that means that something that X tried\n  ** tried to do recently failed with an SQLITE_LOCKED error due to locks\n  ** held by Y.\n  */\n  sqlite3 *pBlockingConnection; /* Connection that caused SQLITE_LOCKED */\n  sqlite3 *pUnlockConnection;           /* Connection to watch for unlock */\n  void *pUnlockArg;                     /* Argument to xUnlockNotify */\n  void (*xUnlockNotify)(void **, int);  /* Unlock notify callback */\n  sqlite3 *pNextBlocked;        /* Next in list of all blocked connections */\n#endif\n#ifdef SQLITE_USER_AUTHENTICATION\n  sqlite3_userauth auth;        /* User authentication information */\n#endif\n};\n\n/*\n** A macro to discover the encoding of a database.\n*/\n#define SCHEMA_ENC(db) ((db)->aDb[0].pSchema->enc)\n#define ENC(db)        ((db)->enc)\n\n/*\n** Possible values for the sqlite3.flags.\n**\n** Value constraints (enforced via assert()):\n**      SQLITE_FullFSync     == PAGER_FULLFSYNC\n**      SQLITE_CkptFullFSync == PAGER_CKPT_FULLFSYNC\n**      SQLITE_CacheSpill    == PAGER_CACHE_SPILL\n*/\n#define SQLITE_WriteSchema    0x00000001  /* OK to update SQLITE_MASTER */\n#define SQLITE_LegacyFileFmt  0x00000002  /* Create new databases in format 1 */\n#define SQLITE_FullColNames   0x00000004  /* Show full column names on SELECT */\n#define SQLITE_FullFSync      0x00000008  /* Use full fsync on the backend */\n#define SQLITE_CkptFullFSync  0x00000010  /* Use full fsync for checkpoint */\n#define SQLITE_CacheSpill     0x00000020  /* OK to spill pager cache */\n#define SQLITE_ShortColNames  0x00000040  /* Show short columns names */\n#define SQLITE_CountRows      0x00000080  /* Count rows changed by INSERT, */\n                                          /*   DELETE, or UPDATE and return */\n                                          /*   the count using a callback. */\n#define SQLITE_NullCallback   0x00000100  /* Invoke the callback once if the */\n                                          /*   result set is empty */\n#define SQLITE_IgnoreChecks   0x00000200  /* Do not enforce check constraints */\n#define SQLITE_ReadUncommit   0x00000400  /* READ UNCOMMITTED in shared-cache */\n#define SQLITE_NoCkptOnClose  0x00000800  /* No checkpoint on close()/DETACH */\n#define SQLITE_ReverseOrder   0x00001000  /* Reverse unordered SELECTs */\n#define SQLITE_RecTriggers    0x00002000  /* Enable recursive triggers */\n#define SQLITE_ForeignKeys    0x00004000  /* Enforce foreign key constraints  */\n#define SQLITE_AutoIndex      0x00008000  /* Enable automatic indexes */\n#define SQLITE_LoadExtension  0x00010000  /* Enable load_extension */\n#define SQLITE_LoadExtFunc    0x00020000  /* Enable load_extension() SQL func */\n#define SQLITE_EnableTrigger  0x00040000  /* True to enable triggers */\n#define SQLITE_DeferFKs       0x00080000  /* Defer all FK constraints */\n#define SQLITE_QueryOnly      0x00100000  /* Disable database changes */\n#define SQLITE_CellSizeCk     0x00200000  /* Check btree cell sizes on load */\n#define SQLITE_Fts3Tokenizer  0x00400000  /* Enable fts3_tokenizer(2) */\n#define SQLITE_EnableQPSG     0x00800000  /* Query Planner Stability Guarantee*/\n#define SQLITE_TriggerEQP     0x01000000  /* Show trigger EXPLAIN QUERY PLAN */\n#define SQLITE_ResetDatabase  0x02000000  /* Reset the database */\n#define SQLITE_LegacyAlter    0x04000000  /* Legacy ALTER TABLE behaviour */\n#define SQLITE_NoSchemaError  0x08000000  /* Do not report schema parse errors*/\n#define SQLITE_Defensive      0x10000000  /* Input SQL is likely hostile */\n#define SQLITE_DqsDDL         0x20000000  /* dbl-quoted strings allowed in DDL*/\n#define SQLITE_DqsDML         0x40000000  /* dbl-quoted strings allowed in DML*/\n#define SQLITE_EnableView     0x80000000  /* Enable the use of views */\n\n/* Flags used only if debugging */\n#define HI(X)  ((u64)(X)<<32)\n#ifdef SQLITE_DEBUG\n#define SQLITE_SqlTrace       HI(0x0100000) /* Debug print SQL as it executes */\n#define SQLITE_VdbeListing    HI(0x0200000) /* Debug listings of VDBE progs */\n#define SQLITE_VdbeTrace      HI(0x0400000) /* True to trace VDBE execution */\n#define SQLITE_VdbeAddopTrace HI(0x0800000) /* Trace sqlite3VdbeAddOp() calls */\n#define SQLITE_VdbeEQP        HI(0x1000000) /* Debug EXPLAIN QUERY PLAN */\n#define SQLITE_ParserTrace    HI(0x2000000) /* PRAGMA parser_trace=ON */\n#endif\n\n/*\n** Allowed values for sqlite3.mDbFlags\n*/\n#define DBFLAG_SchemaChange   0x0001  /* Uncommitted Hash table changes */\n#define DBFLAG_PreferBuiltin  0x0002  /* Preference to built-in funcs */\n#define DBFLAG_Vacuum         0x0004  /* Currently in a VACUUM */\n#define DBFLAG_VacuumInto     0x0008  /* Currently running VACUUM INTO */\n#define DBFLAG_SchemaKnownOk  0x0010  /* Schema is known to be valid */\n\n/*\n** Bits of the sqlite3.dbOptFlags field that are used by the\n** sqlite3_test_control(SQLITE_TESTCTRL_OPTIMIZATIONS,...) interface to\n** selectively disable various optimizations.\n*/\n#define SQLITE_QueryFlattener 0x0001   /* Query flattening */\n#define SQLITE_WindowFunc     0x0002   /* Use xInverse for window functions */\n#define SQLITE_GroupByOrder   0x0004   /* GROUPBY cover of ORDERBY */\n#define SQLITE_FactorOutConst 0x0008   /* Constant factoring */\n#define SQLITE_DistinctOpt    0x0010   /* DISTINCT using indexes */\n#define SQLITE_CoverIdxScan   0x0020   /* Covering index scans */\n#define SQLITE_OrderByIdxJoin 0x0040   /* ORDER BY of joins via index */\n#define SQLITE_Transitive     0x0080   /* Transitive constraints */\n#define SQLITE_OmitNoopJoin   0x0100   /* Omit unused tables in joins */\n#define SQLITE_CountOfView    0x0200   /* The count-of-view optimization */\n#define SQLITE_CursorHints    0x0400   /* Add OP_CursorHint opcodes */\n#define SQLITE_Stat4          0x0800   /* Use STAT4 data */\n   /* TH3 expects the Stat4   ^^^^^^ value to be 0x0800.  Don't change it */\n#define SQLITE_PushDown       0x1000   /* The push-down optimization */\n#define SQLITE_SimplifyJoin   0x2000   /* Convert LEFT JOIN to JOIN */\n#define SQLITE_SkipScan       0x4000   /* Skip-scans */\n#define SQLITE_PropagateConst 0x8000   /* The constant propagation opt */\n#define SQLITE_AllOpts        0xffff   /* All optimizations */\n\n/*\n** Macros for testing whether or not optimizations are enabled or disabled.\n*/\n#define OptimizationDisabled(db, mask)  (((db)->dbOptFlags&(mask))!=0)\n#define OptimizationEnabled(db, mask)   (((db)->dbOptFlags&(mask))==0)\n\n/*\n** Return true if it OK to factor constant expressions into the initialization\n** code. The argument is a Parse object for the code generator.\n*/\n#define ConstFactorOk(P) ((P)->okConstFactor)\n\n/*\n** Possible values for the sqlite.magic field.\n** The numbers are obtained at random and have no special meaning, other\n** than being distinct from one another.\n*/\n#define SQLITE_MAGIC_OPEN     0xa029a697  /* Database is open */\n#define SQLITE_MAGIC_CLOSED   0x9f3c2d33  /* Database is closed */\n#define SQLITE_MAGIC_SICK     0x4b771290  /* Error and awaiting close */\n#define SQLITE_MAGIC_BUSY     0xf03b7906  /* Database currently in use */\n#define SQLITE_MAGIC_ERROR    0xb5357930  /* An SQLITE_MISUSE error occurred */\n#define SQLITE_MAGIC_ZOMBIE   0x64cffc7f  /* Close with last statement close */\n\n/*\n** Each SQL function is defined by an instance of the following\n** structure.  For global built-in functions (ex: substr(), max(), count())\n** a pointer to this structure is held in the sqlite3BuiltinFunctions object.\n** For per-connection application-defined functions, a pointer to this\n** structure is held in the db->aHash hash table.\n**\n** The u.pHash field is used by the global built-ins.  The u.pDestructor\n** field is used by per-connection app-def functions.\n*/\nstruct FuncDef {\n  i8 nArg;             /* Number of arguments.  -1 means unlimited */\n  u32 funcFlags;       /* Some combination of SQLITE_FUNC_* */\n  void *pUserData;     /* User data parameter */\n  FuncDef *pNext;      /* Next function with same name */\n  void (*xSFunc)(sqlite3_context*,int,sqlite3_value**); /* func or agg-step */\n  void (*xFinalize)(sqlite3_context*);                  /* Agg finalizer */\n  void (*xValue)(sqlite3_context*);                     /* Current agg value */\n  void (*xInverse)(sqlite3_context*,int,sqlite3_value**); /* inverse agg-step */\n  const char *zName;   /* SQL name of the function. */\n  union {\n    FuncDef *pHash;      /* Next with a different name but the same hash */\n    FuncDestructor *pDestructor;   /* Reference counted destructor function */\n  } u;\n};\n\n/*\n** This structure encapsulates a user-function destructor callback (as\n** configured using create_function_v2()) and a reference counter. When\n** create_function_v2() is called to create a function with a destructor,\n** a single object of this type is allocated. FuncDestructor.nRef is set to\n** the number of FuncDef objects created (either 1 or 3, depending on whether\n** or not the specified encoding is SQLITE_ANY). The FuncDef.pDestructor\n** member of each of the new FuncDef objects is set to point to the allocated\n** FuncDestructor.\n**\n** Thereafter, when one of the FuncDef objects is deleted, the reference\n** count on this object is decremented. When it reaches 0, the destructor\n** is invoked and the FuncDestructor structure freed.\n*/\nstruct FuncDestructor {\n  int nRef;\n  void (*xDestroy)(void *);\n  void *pUserData;\n};\n\n/*\n** Possible values for FuncDef.flags.  Note that the _LENGTH and _TYPEOF\n** values must correspond to OPFLAG_LENGTHARG and OPFLAG_TYPEOFARG.  And\n** SQLITE_FUNC_CONSTANT must be the same as SQLITE_DETERMINISTIC.  There\n** are assert() statements in the code to verify this.\n**\n** Value constraints (enforced via assert()):\n**     SQLITE_FUNC_MINMAX    ==  NC_MinMaxAgg      == SF_MinMaxAgg\n**     SQLITE_FUNC_LENGTH    ==  OPFLAG_LENGTHARG\n**     SQLITE_FUNC_TYPEOF    ==  OPFLAG_TYPEOFARG\n**     SQLITE_FUNC_CONSTANT  ==  SQLITE_DETERMINISTIC from the API\n**     SQLITE_FUNC_DIRECT    ==  SQLITE_DIRECTONLY from the API\n**     SQLITE_FUNC_ENCMASK   depends on SQLITE_UTF* macros in the API\n*/\n#define SQLITE_FUNC_ENCMASK  0x0003 /* SQLITE_UTF8, SQLITE_UTF16BE or UTF16LE */\n#define SQLITE_FUNC_LIKE     0x0004 /* Candidate for the LIKE optimization */\n#define SQLITE_FUNC_CASE     0x0008 /* Case-sensitive LIKE-type function */\n#define SQLITE_FUNC_EPHEM    0x0010 /* Ephemeral.  Delete with VDBE */\n#define SQLITE_FUNC_NEEDCOLL 0x0020 /* sqlite3GetFuncCollSeq() might be called*/\n#define SQLITE_FUNC_LENGTH   0x0040 /* Built-in length() function */\n#define SQLITE_FUNC_TYPEOF   0x0080 /* Built-in typeof() function */\n#define SQLITE_FUNC_COUNT    0x0100 /* Built-in count(*) aggregate */\n#define SQLITE_FUNC_COALESCE 0x0200 /* Built-in coalesce() or ifnull() */\n#define SQLITE_FUNC_UNLIKELY 0x0400 /* Built-in unlikely() function */\n#define SQLITE_FUNC_CONSTANT 0x0800 /* Constant inputs give a constant output */\n#define SQLITE_FUNC_MINMAX   0x1000 /* True for min() and max() aggregates */\n#define SQLITE_FUNC_SLOCHNG  0x2000 /* \"Slow Change\". Value constant during a\n                                    ** single query - might change over time */\n#define SQLITE_FUNC_AFFINITY 0x4000 /* Built-in affinity() function */\n#define SQLITE_FUNC_OFFSET   0x8000 /* Built-in sqlite_offset() function */\n#define SQLITE_FUNC_WINDOW   0x00010000 /* Built-in window-only function */\n#define SQLITE_FUNC_INTERNAL 0x00040000 /* For use by NestedParse() only */\n#define SQLITE_FUNC_DIRECT   0x00080000 /* Not for use in TRIGGERs or VIEWs */\n#define SQLITE_FUNC_SUBTYPE  0x00100000 /* Result likely to have sub-type */\n\n/*\n** The following three macros, FUNCTION(), LIKEFUNC() and AGGREGATE() are\n** used to create the initializers for the FuncDef structures.\n**\n**   FUNCTION(zName, nArg, iArg, bNC, xFunc)\n**     Used to create a scalar function definition of a function zName\n**     implemented by C function xFunc that accepts nArg arguments. The\n**     value passed as iArg is cast to a (void*) and made available\n**     as the user-data (sqlite3_user_data()) for the function. If\n**     argument bNC is true, then the SQLITE_FUNC_NEEDCOLL flag is set.\n**\n**   VFUNCTION(zName, nArg, iArg, bNC, xFunc)\n**     Like FUNCTION except it omits the SQLITE_FUNC_CONSTANT flag.\n**\n**   DFUNCTION(zName, nArg, iArg, bNC, xFunc)\n**     Like FUNCTION except it omits the SQLITE_FUNC_CONSTANT flag and\n**     adds the SQLITE_FUNC_SLOCHNG flag.  Used for date & time functions\n**     and functions like sqlite_version() that can change, but not during\n**     a single query.  The iArg is ignored.  The user-data is always set\n**     to a NULL pointer.  The bNC parameter is not used.\n**\n**   PURE_DATE(zName, nArg, iArg, bNC, xFunc)\n**     Used for \"pure\" date/time functions, this macro is like DFUNCTION\n**     except that it does set the SQLITE_FUNC_CONSTANT flags.  iArg is\n**     ignored and the user-data for these functions is set to an \n**     arbitrary non-NULL pointer.  The bNC parameter is not used.\n**\n**   AGGREGATE(zName, nArg, iArg, bNC, xStep, xFinal)\n**     Used to create an aggregate function definition implemented by\n**     the C functions xStep and xFinal. The first four parameters\n**     are interpreted in the same way as the first 4 parameters to\n**     FUNCTION().\n**\n**   WFUNCTION(zName, nArg, iArg, xStep, xFinal, xValue, xInverse)\n**     Used to create an aggregate function definition implemented by\n**     the C functions xStep and xFinal. The first four parameters\n**     are interpreted in the same way as the first 4 parameters to\n**     FUNCTION().\n**\n**   LIKEFUNC(zName, nArg, pArg, flags)\n**     Used to create a scalar function definition of a function zName\n**     that accepts nArg arguments and is implemented by a call to C\n**     function likeFunc. Argument pArg is cast to a (void *) and made\n**     available as the function user-data (sqlite3_user_data()). The\n**     FuncDef.flags variable is set to the value passed as the flags\n**     parameter.\n*/\n#define FUNCTION(zName, nArg, iArg, bNC, xFunc) \\\n  {nArg, SQLITE_FUNC_CONSTANT|SQLITE_UTF8|(bNC*SQLITE_FUNC_NEEDCOLL), \\\n   SQLITE_INT_TO_PTR(iArg), 0, xFunc, 0, 0, 0, #zName, {0} }\n#define VFUNCTION(zName, nArg, iArg, bNC, xFunc) \\\n  {nArg, SQLITE_UTF8|(bNC*SQLITE_FUNC_NEEDCOLL), \\\n   SQLITE_INT_TO_PTR(iArg), 0, xFunc, 0, 0, 0, #zName, {0} }\n#define DFUNCTION(zName, nArg, iArg, bNC, xFunc) \\\n  {nArg, SQLITE_FUNC_SLOCHNG|SQLITE_UTF8, \\\n   0, 0, xFunc, 0, 0, 0, #zName, {0} }\n#define PURE_DATE(zName, nArg, iArg, bNC, xFunc) \\\n  {nArg, SQLITE_FUNC_SLOCHNG|SQLITE_UTF8|SQLITE_FUNC_CONSTANT, \\\n   (void*)&sqlite3Config, 0, xFunc, 0, 0, 0, #zName, {0} }\n#define FUNCTION2(zName, nArg, iArg, bNC, xFunc, extraFlags) \\\n  {nArg,SQLITE_FUNC_CONSTANT|SQLITE_UTF8|(bNC*SQLITE_FUNC_NEEDCOLL)|extraFlags,\\\n   SQLITE_INT_TO_PTR(iArg), 0, xFunc, 0, 0, 0, #zName, {0} }\n#define STR_FUNCTION(zName, nArg, pArg, bNC, xFunc) \\\n  {nArg, SQLITE_FUNC_SLOCHNG|SQLITE_UTF8|(bNC*SQLITE_FUNC_NEEDCOLL), \\\n   pArg, 0, xFunc, 0, 0, 0, #zName, }\n#define LIKEFUNC(zName, nArg, arg, flags) \\\n  {nArg, SQLITE_FUNC_CONSTANT|SQLITE_UTF8|flags, \\\n   (void *)arg, 0, likeFunc, 0, 0, 0, #zName, {0} }\n#define AGGREGATE(zName, nArg, arg, nc, xStep, xFinal, xValue) \\\n  {nArg, SQLITE_UTF8|(nc*SQLITE_FUNC_NEEDCOLL), \\\n   SQLITE_INT_TO_PTR(arg), 0, xStep,xFinal,xValue,0,#zName, {0}}\n#define AGGREGATE2(zName, nArg, arg, nc, xStep, xFinal, extraFlags) \\\n  {nArg, SQLITE_UTF8|(nc*SQLITE_FUNC_NEEDCOLL)|extraFlags, \\\n   SQLITE_INT_TO_PTR(arg), 0, xStep,xFinal,xFinal,0,#zName, {0}}\n#define WAGGREGATE(zName, nArg, arg, nc, xStep, xFinal, xValue, xInverse, f) \\\n  {nArg, SQLITE_UTF8|(nc*SQLITE_FUNC_NEEDCOLL)|f, \\\n   SQLITE_INT_TO_PTR(arg), 0, xStep,xFinal,xValue,xInverse,#zName, {0}}\n#define INTERNAL_FUNCTION(zName, nArg, xFunc) \\\n  {nArg, SQLITE_FUNC_INTERNAL|SQLITE_UTF8|SQLITE_FUNC_CONSTANT, \\\n   0, 0, xFunc, 0, 0, 0, #zName, {0} }\n\n\n/*\n** All current savepoints are stored in a linked list starting at\n** sqlite3.pSavepoint. The first element in the list is the most recently\n** opened savepoint. Savepoints are added to the list by the vdbe\n** OP_Savepoint instruction.\n*/\nstruct Savepoint {\n  char *zName;                        /* Savepoint name (nul-terminated) */\n  i64 nDeferredCons;                  /* Number of deferred fk violations */\n  i64 nDeferredImmCons;               /* Number of deferred imm fk. */\n  Savepoint *pNext;                   /* Parent savepoint (if any) */\n};\n\n/*\n** The following are used as the second parameter to sqlite3Savepoint(),\n** and as the P1 argument to the OP_Savepoint instruction.\n*/\n#define SAVEPOINT_BEGIN      0\n#define SAVEPOINT_RELEASE    1\n#define SAVEPOINT_ROLLBACK   2\n\n\n/*\n** Each SQLite module (virtual table definition) is defined by an\n** instance of the following structure, stored in the sqlite3.aModule\n** hash table.\n*/\nstruct Module {\n  const sqlite3_module *pModule;       /* Callback pointers */\n  const char *zName;                   /* Name passed to create_module() */\n  int nRefModule;                      /* Number of pointers to this object */\n  void *pAux;                          /* pAux passed to create_module() */\n  void (*xDestroy)(void *);            /* Module destructor function */\n  Table *pEpoTab;                      /* Eponymous table for this module */\n};\n\n/*\n** Information about each column of an SQL table is held in an instance\n** of the Column structure, in the Table.aCol[] array.\n**\n** Definitions:\n**\n**   \"table column index\"     This is the index of the column in the\n**                            Table.aCol[] array, and also the index of\n**                            the column in the original CREATE TABLE stmt.\n**\n**   \"storage column index\"   This is the index of the column in the\n**                            record BLOB generated by the OP_MakeRecord\n**                            opcode.  The storage column index is less than\n**                            or equal to the table column index.  It is\n**                            equal if and only if there are no VIRTUAL\n**                            columns to the left.\n*/\nstruct Column {\n  char *zName;     /* Name of this column, \\000, then the type */\n  Expr *pDflt;     /* Default value or GENERATED ALWAYS AS value */\n  char *zColl;     /* Collating sequence.  If NULL, use the default */\n  u8 notNull;      /* An OE_ code for handling a NOT NULL constraint */\n  char affinity;   /* One of the SQLITE_AFF_... values */\n  u8 szEst;        /* Estimated size of value in this column. sizeof(INT)==1 */\n  u16 colFlags;    /* Boolean properties.  See COLFLAG_ defines below */\n};\n\n/* Allowed values for Column.colFlags:\n*/\n#define COLFLAG_PRIMKEY   0x0001   /* Column is part of the primary key */\n#define COLFLAG_HIDDEN    0x0002   /* A hidden column in a virtual table */\n#define COLFLAG_HASTYPE   0x0004   /* Type name follows column name */\n#define COLFLAG_UNIQUE    0x0008   /* Column def contains \"UNIQUE\" or \"PK\" */\n#define COLFLAG_SORTERREF 0x0010   /* Use sorter-refs with this column */\n#define COLFLAG_VIRTUAL   0x0020   /* GENERATED ALWAYS AS ... VIRTUAL */\n#define COLFLAG_STORED    0x0040   /* GENERATED ALWAYS AS ... STORED */\n#define COLFLAG_NOTAVAIL  0x0080   /* STORED column not yet calculated */\n#define COLFLAG_BUSY      0x0100   /* Blocks recursion on GENERATED columns */\n#define COLFLAG_GENERATED 0x0060   /* Combo: _STORED, _VIRTUAL */\n#define COLFLAG_NOINSERT  0x0062   /* Combo: _HIDDEN, _STORED, _VIRTUAL */\n\n/*\n** A \"Collating Sequence\" is defined by an instance of the following\n** structure. Conceptually, a collating sequence consists of a name and\n** a comparison routine that defines the order of that sequence.\n**\n** If CollSeq.xCmp is NULL, it means that the\n** collating sequence is undefined.  Indices built on an undefined\n** collating sequence may not be read or written.\n*/\nstruct CollSeq {\n  char *zName;          /* Name of the collating sequence, UTF-8 encoded */\n  u8 enc;               /* Text encoding handled by xCmp() */\n  void *pUser;          /* First argument to xCmp() */\n  int (*xCmp)(void*,int, const void*, int, const void*);\n  void (*xDel)(void*);  /* Destructor for pUser */\n};\n\n/*\n** A sort order can be either ASC or DESC.\n*/\n#define SQLITE_SO_ASC       0  /* Sort in ascending order */\n#define SQLITE_SO_DESC      1  /* Sort in ascending order */\n#define SQLITE_SO_UNDEFINED -1 /* No sort order specified */\n\n/*\n** Column affinity types.\n**\n** These used to have mnemonic name like 'i' for SQLITE_AFF_INTEGER and\n** 't' for SQLITE_AFF_TEXT.  But we can save a little space and improve\n** the speed a little by numbering the values consecutively.\n**\n** But rather than start with 0 or 1, we begin with 'A'.  That way,\n** when multiple affinity types are concatenated into a string and\n** used as the P4 operand, they will be more readable.\n**\n** Note also that the numeric types are grouped together so that testing\n** for a numeric type is a single comparison.  And the BLOB type is first.\n*/\n#define SQLITE_AFF_NONE     0x40  /* '@' */\n#define SQLITE_AFF_BLOB     0x41  /* 'A' */\n#define SQLITE_AFF_TEXT     0x42  /* 'B' */\n#define SQLITE_AFF_NUMERIC  0x43  /* 'C' */\n#define SQLITE_AFF_INTEGER  0x44  /* 'D' */\n#define SQLITE_AFF_REAL     0x45  /* 'E' */\n\n#define sqlite3IsNumericAffinity(X)  ((X)>=SQLITE_AFF_NUMERIC)\n\n/*\n** The SQLITE_AFF_MASK values masks off the significant bits of an\n** affinity value.\n*/\n#define SQLITE_AFF_MASK     0x47\n\n/*\n** Additional bit values that can be ORed with an affinity without\n** changing the affinity.\n**\n** The SQLITE_NOTNULL flag is a combination of NULLEQ and JUMPIFNULL.\n** It causes an assert() to fire if either operand to a comparison\n** operator is NULL.  It is added to certain comparison operators to\n** prove that the operands are always NOT NULL.\n*/\n#define SQLITE_KEEPNULL     0x08  /* Used by vector == or <> */\n#define SQLITE_JUMPIFNULL   0x10  /* jumps if either operand is NULL */\n#define SQLITE_STOREP2      0x20  /* Store result in reg[P2] rather than jump */\n#define SQLITE_NULLEQ       0x80  /* NULL=NULL */\n#define SQLITE_NOTNULL      0x90  /* Assert that operands are never NULL */\n\n/*\n** An object of this type is created for each virtual table present in\n** the database schema.\n**\n** If the database schema is shared, then there is one instance of this\n** structure for each database connection (sqlite3*) that uses the shared\n** schema. This is because each database connection requires its own unique\n** instance of the sqlite3_vtab* handle used to access the virtual table\n** implementation. sqlite3_vtab* handles can not be shared between\n** database connections, even when the rest of the in-memory database\n** schema is shared, as the implementation often stores the database\n** connection handle passed to it via the xConnect() or xCreate() method\n** during initialization internally. This database connection handle may\n** then be used by the virtual table implementation to access real tables\n** within the database. So that they appear as part of the callers\n** transaction, these accesses need to be made via the same database\n** connection as that used to execute SQL operations on the virtual table.\n**\n** All VTable objects that correspond to a single table in a shared\n** database schema are initially stored in a linked-list pointed to by\n** the Table.pVTable member variable of the corresponding Table object.\n** When an sqlite3_prepare() operation is required to access the virtual\n** table, it searches the list for the VTable that corresponds to the\n** database connection doing the preparing so as to use the correct\n** sqlite3_vtab* handle in the compiled query.\n**\n** When an in-memory Table object is deleted (for example when the\n** schema is being reloaded for some reason), the VTable objects are not\n** deleted and the sqlite3_vtab* handles are not xDisconnect()ed\n** immediately. Instead, they are moved from the Table.pVTable list to\n** another linked list headed by the sqlite3.pDisconnect member of the\n** corresponding sqlite3 structure. They are then deleted/xDisconnected\n** next time a statement is prepared using said sqlite3*. This is done\n** to avoid deadlock issues involving multiple sqlite3.mutex mutexes.\n** Refer to comments above function sqlite3VtabUnlockList() for an\n** explanation as to why it is safe to add an entry to an sqlite3.pDisconnect\n** list without holding the corresponding sqlite3.mutex mutex.\n**\n** The memory for objects of this type is always allocated by\n** sqlite3DbMalloc(), using the connection handle stored in VTable.db as\n** the first argument.\n*/\nstruct VTable {\n  sqlite3 *db;              /* Database connection associated with this table */\n  Module *pMod;             /* Pointer to module implementation */\n  sqlite3_vtab *pVtab;      /* Pointer to vtab instance */\n  int nRef;                 /* Number of pointers to this structure */\n  u8 bConstraint;           /* True if constraints are supported */\n  int iSavepoint;           /* Depth of the SAVEPOINT stack */\n  VTable *pNext;            /* Next in linked list (see above) */\n};\n\n/*\n** The schema for each SQL table and view is represented in memory\n** by an instance of the following structure.\n*/\nstruct Table {\n  char *zName;         /* Name of the table or view */\n  Column *aCol;        /* Information about each column */\n  Index *pIndex;       /* List of SQL indexes on this table. */\n  Select *pSelect;     /* NULL for tables.  Points to definition if a view. */\n  FKey *pFKey;         /* Linked list of all foreign keys in this table */\n  char *zColAff;       /* String defining the affinity of each column */\n  ExprList *pCheck;    /* All CHECK constraints */\n                       /*   ... also used as column name list in a VIEW */\n  int tnum;            /* Root BTree page for this table */\n  u32 nTabRef;         /* Number of pointers to this Table */\n  u32 tabFlags;        /* Mask of TF_* values */\n  i16 iPKey;           /* If not negative, use aCol[iPKey] as the rowid */\n  i16 nCol;            /* Number of columns in this table */\n  i16 nNVCol;          /* Number of columns that are not VIRTUAL */\n  LogEst nRowLogEst;   /* Estimated rows in table - from sqlite_stat1 table */\n  LogEst szTabRow;     /* Estimated size of each table row in bytes */\n#ifdef SQLITE_ENABLE_COSTMULT\n  LogEst costMult;     /* Cost multiplier for using this table */\n#endif\n  u8 keyConf;          /* What to do in case of uniqueness conflict on iPKey */\n#ifndef SQLITE_OMIT_ALTERTABLE\n  int addColOffset;    /* Offset in CREATE TABLE stmt to add a new column */\n#endif\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n  int nModuleArg;      /* Number of arguments to the module */\n  char **azModuleArg;  /* 0: module 1: schema 2: vtab name 3...: args */\n  VTable *pVTable;     /* List of VTable objects. */\n#endif\n  Trigger *pTrigger;   /* List of triggers stored in pSchema */\n  Schema *pSchema;     /* Schema that contains this table */\n  Table *pNextZombie;  /* Next on the Parse.pZombieTab list */\n};\n\n/*\n** Allowed values for Table.tabFlags.\n**\n** TF_OOOHidden applies to tables or view that have hidden columns that are\n** followed by non-hidden columns.  Example:  \"CREATE VIRTUAL TABLE x USING\n** vtab1(a HIDDEN, b);\".  Since \"b\" is a non-hidden column but \"a\" is hidden,\n** the TF_OOOHidden attribute would apply in this case.  Such tables require\n** special handling during INSERT processing. The \"OOO\" means \"Out Of Order\".\n**\n** Constraints:\n**\n**         TF_HasVirtual == COLFLAG_Virtual\n**         TF_HasStored  == COLFLAG_Stored\n*/\n#define TF_Readonly        0x0001    /* Read-only system table */\n#define TF_Ephemeral       0x0002    /* An ephemeral table */\n#define TF_HasPrimaryKey   0x0004    /* Table has a primary key */\n#define TF_Autoincrement   0x0008    /* Integer primary key is autoincrement */\n#define TF_HasStat1        0x0010    /* nRowLogEst set from sqlite_stat1 */\n#define TF_HasVirtual      0x0020    /* Has one or more VIRTUAL columns */\n#define TF_HasStored       0x0040    /* Has one or more STORED columns */\n#define TF_HasGenerated    0x0060    /* Combo: HasVirtual + HasStored */\n#define TF_WithoutRowid    0x0080    /* No rowid.  PRIMARY KEY is the key */\n#define TF_StatsUsed       0x0100    /* Query planner decisions affected by\n                                     ** Index.aiRowLogEst[] values */\n#define TF_NoVisibleRowid  0x0200    /* No user-visible \"rowid\" column */\n#define TF_OOOHidden       0x0400    /* Out-of-Order hidden columns */\n#define TF_HasNotNull      0x0800    /* Contains NOT NULL constraints */\n#define TF_Shadow          0x1000    /* True for a shadow table */\n\n/*\n** Test to see whether or not a table is a virtual table.  This is\n** done as a macro so that it will be optimized out when virtual\n** table support is omitted from the build.\n*/\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n#  define IsVirtual(X)      ((X)->nModuleArg)\n#else\n#  define IsVirtual(X)      0\n#endif\n\n/*\n** Macros to determine if a column is hidden.  IsOrdinaryHiddenColumn()\n** only works for non-virtual tables (ordinary tables and views) and is\n** always false unless SQLITE_ENABLE_HIDDEN_COLUMNS is defined.  The\n** IsHiddenColumn() macro is general purpose.\n*/\n#if defined(SQLITE_ENABLE_HIDDEN_COLUMNS)\n#  define IsHiddenColumn(X)         (((X)->colFlags & COLFLAG_HIDDEN)!=0)\n#  define IsOrdinaryHiddenColumn(X) (((X)->colFlags & COLFLAG_HIDDEN)!=0)\n#elif !defined(SQLITE_OMIT_VIRTUALTABLE)\n#  define IsHiddenColumn(X)         (((X)->colFlags & COLFLAG_HIDDEN)!=0)\n#  define IsOrdinaryHiddenColumn(X) 0\n#else\n#  define IsHiddenColumn(X)         0\n#  define IsOrdinaryHiddenColumn(X) 0\n#endif\n\n\n/* Does the table have a rowid */\n#define HasRowid(X)     (((X)->tabFlags & TF_WithoutRowid)==0)\n#define VisibleRowid(X) (((X)->tabFlags & TF_NoVisibleRowid)==0)\n\n/*\n** Each foreign key constraint is an instance of the following structure.\n**\n** A foreign key is associated with two tables.  The \"from\" table is\n** the table that contains the REFERENCES clause that creates the foreign\n** key.  The \"to\" table is the table that is named in the REFERENCES clause.\n** Consider this example:\n**\n**     CREATE TABLE ex1(\n**       a INTEGER PRIMARY KEY,\n**       b INTEGER CONSTRAINT fk1 REFERENCES ex2(x)\n**     );\n**\n** For foreign key \"fk1\", the from-table is \"ex1\" and the to-table is \"ex2\".\n** Equivalent names:\n**\n**     from-table == child-table\n**       to-table == parent-table\n**\n** Each REFERENCES clause generates an instance of the following structure\n** which is attached to the from-table.  The to-table need not exist when\n** the from-table is created.  The existence of the to-table is not checked.\n**\n** The list of all parents for child Table X is held at X.pFKey.\n**\n** A list of all children for a table named Z (which might not even exist)\n** is held in Schema.fkeyHash with a hash key of Z.\n*/\nstruct FKey {\n  Table *pFrom;     /* Table containing the REFERENCES clause (aka: Child) */\n  FKey *pNextFrom;  /* Next FKey with the same in pFrom. Next parent of pFrom */\n  char *zTo;        /* Name of table that the key points to (aka: Parent) */\n  FKey *pNextTo;    /* Next with the same zTo. Next child of zTo. */\n  FKey *pPrevTo;    /* Previous with the same zTo */\n  int nCol;         /* Number of columns in this key */\n  /* EV: R-30323-21917 */\n  u8 isDeferred;       /* True if constraint checking is deferred till COMMIT */\n  u8 aAction[2];        /* ON DELETE and ON UPDATE actions, respectively */\n  Trigger *apTrigger[2];/* Triggers for aAction[] actions */\n  struct sColMap {      /* Mapping of columns in pFrom to columns in zTo */\n    int iFrom;            /* Index of column in pFrom */\n    char *zCol;           /* Name of column in zTo.  If NULL use PRIMARY KEY */\n  } aCol[1];            /* One entry for each of nCol columns */\n};\n\n/*\n** SQLite supports many different ways to resolve a constraint\n** error.  ROLLBACK processing means that a constraint violation\n** causes the operation in process to fail and for the current transaction\n** to be rolled back.  ABORT processing means the operation in process\n** fails and any prior changes from that one operation are backed out,\n** but the transaction is not rolled back.  FAIL processing means that\n** the operation in progress stops and returns an error code.  But prior\n** changes due to the same operation are not backed out and no rollback\n** occurs.  IGNORE means that the particular row that caused the constraint\n** error is not inserted or updated.  Processing continues and no error\n** is returned.  REPLACE means that preexisting database rows that caused\n** a UNIQUE constraint violation are removed so that the new insert or\n** update can proceed.  Processing continues and no error is reported.\n**\n** RESTRICT, SETNULL, and CASCADE actions apply only to foreign keys.\n** RESTRICT is the same as ABORT for IMMEDIATE foreign keys and the\n** same as ROLLBACK for DEFERRED keys.  SETNULL means that the foreign\n** key is set to NULL.  CASCADE means that a DELETE or UPDATE of the\n** referenced table row is propagated into the row that holds the\n** foreign key.\n**\n** The following symbolic values are used to record which type\n** of action to take.\n*/\n#define OE_None     0   /* There is no constraint to check */\n#define OE_Rollback 1   /* Fail the operation and rollback the transaction */\n#define OE_Abort    2   /* Back out changes but do no rollback transaction */\n#define OE_Fail     3   /* Stop the operation but leave all prior changes */\n#define OE_Ignore   4   /* Ignore the error. Do not do the INSERT or UPDATE */\n#define OE_Replace  5   /* Delete existing record, then do INSERT or UPDATE */\n#define OE_Update   6   /* Process as a DO UPDATE in an upsert */\n#define OE_Restrict 7   /* OE_Abort for IMMEDIATE, OE_Rollback for DEFERRED */\n#define OE_SetNull  8   /* Set the foreign key value to NULL */\n#define OE_SetDflt  9   /* Set the foreign key value to its default */\n#define OE_Cascade  10  /* Cascade the changes */\n#define OE_Default  11  /* Do whatever the default action is */\n\n\n/*\n** An instance of the following structure is passed as the first\n** argument to sqlite3VdbeKeyCompare and is used to control the\n** comparison of the two index keys.\n**\n** Note that aSortOrder[] and aColl[] have nField+1 slots.  There\n** are nField slots for the columns of an index then one extra slot\n** for the rowid at the end.\n*/\nstruct KeyInfo {\n  u32 nRef;           /* Number of references to this KeyInfo object */\n  u8 enc;             /* Text encoding - one of the SQLITE_UTF* values */\n  u16 nKeyField;      /* Number of key columns in the index */\n  u16 nAllField;      /* Total columns, including key plus others */\n  sqlite3 *db;        /* The database connection */\n  u8 *aSortFlags;     /* Sort order for each column. */\n  CollSeq *aColl[1];  /* Collating sequence for each term of the key */\n};\n\n/*\n** Allowed bit values for entries in the KeyInfo.aSortFlags[] array.\n*/\n#define KEYINFO_ORDER_DESC    0x01    /* DESC sort order */\n#define KEYINFO_ORDER_BIGNULL 0x02    /* NULL is larger than any other value */\n\n/*\n** This object holds a record which has been parsed out into individual\n** fields, for the purposes of doing a comparison.\n**\n** A record is an object that contains one or more fields of data.\n** Records are used to store the content of a table row and to store\n** the key of an index.  A blob encoding of a record is created by\n** the OP_MakeRecord opcode of the VDBE and is disassembled by the\n** OP_Column opcode.\n**\n** An instance of this object serves as a \"key\" for doing a search on\n** an index b+tree. The goal of the search is to find the entry that\n** is closed to the key described by this object.  This object might hold\n** just a prefix of the key.  The number of fields is given by\n** pKeyInfo->nField.\n**\n** The r1 and r2 fields are the values to return if this key is less than\n** or greater than a key in the btree, respectively.  These are normally\n** -1 and +1 respectively, but might be inverted to +1 and -1 if the b-tree\n** is in DESC order.\n**\n** The key comparison functions actually return default_rc when they find\n** an equals comparison.  default_rc can be -1, 0, or +1.  If there are\n** multiple entries in the b-tree with the same key (when only looking\n** at the first pKeyInfo->nFields,) then default_rc can be set to -1 to\n** cause the search to find the last match, or +1 to cause the search to\n** find the first match.\n**\n** The key comparison functions will set eqSeen to true if they ever\n** get and equal results when comparing this structure to a b-tree record.\n** When default_rc!=0, the search might end up on the record immediately\n** before the first match or immediately after the last match.  The\n** eqSeen field will indicate whether or not an exact match exists in the\n** b-tree.\n*/\nstruct UnpackedRecord {\n  KeyInfo *pKeyInfo;  /* Collation and sort-order information */\n  Mem *aMem;          /* Values */\n  u16 nField;         /* Number of entries in apMem[] */\n  i8 default_rc;      /* Comparison result if keys are equal */\n  u8 errCode;         /* Error detected by xRecordCompare (CORRUPT or NOMEM) */\n  i8 r1;              /* Value to return if (lhs < rhs) */\n  i8 r2;              /* Value to return if (lhs > rhs) */\n  u8 eqSeen;          /* True if an equality comparison has been seen */\n};\n\n\n/*\n** Each SQL index is represented in memory by an\n** instance of the following structure.\n**\n** The columns of the table that are to be indexed are described\n** by the aiColumn[] field of this structure.  For example, suppose\n** we have the following table and index:\n**\n**     CREATE TABLE Ex1(c1 int, c2 int, c3 text);\n**     CREATE INDEX Ex2 ON Ex1(c3,c1);\n**\n** In the Table structure describing Ex1, nCol==3 because there are\n** three columns in the table.  In the Index structure describing\n** Ex2, nColumn==2 since 2 of the 3 columns of Ex1 are indexed.\n** The value of aiColumn is {2, 0}.  aiColumn[0]==2 because the\n** first column to be indexed (c3) has an index of 2 in Ex1.aCol[].\n** The second column to be indexed (c1) has an index of 0 in\n** Ex1.aCol[], hence Ex2.aiColumn[1]==0.\n**\n** The Index.onError field determines whether or not the indexed columns\n** must be unique and what to do if they are not.  When Index.onError=OE_None,\n** it means this is not a unique index.  Otherwise it is a unique index\n** and the value of Index.onError indicate the which conflict resolution\n** algorithm to employ whenever an attempt is made to insert a non-unique\n** element.\n**\n** While parsing a CREATE TABLE or CREATE INDEX statement in order to\n** generate VDBE code (as opposed to parsing one read from an sqlite_master\n** table as part of parsing an existing database schema), transient instances\n** of this structure may be created. In this case the Index.tnum variable is\n** used to store the address of a VDBE instruction, not a database page\n** number (it cannot - the database page is not allocated until the VDBE\n** program is executed). See convertToWithoutRowidTable() for details.\n*/\nstruct Index {\n  char *zName;             /* Name of this index */\n  i16 *aiColumn;           /* Which columns are used by this index.  1st is 0 */\n  LogEst *aiRowLogEst;     /* From ANALYZE: Est. rows selected by each column */\n  Table *pTable;           /* The SQL table being indexed */\n  char *zColAff;           /* String defining the affinity of each column */\n  Index *pNext;            /* The next index associated with the same table */\n  Schema *pSchema;         /* Schema containing this index */\n  u8 *aSortOrder;          /* for each column: True==DESC, False==ASC */\n  const char **azColl;     /* Array of collation sequence names for index */\n  Expr *pPartIdxWhere;     /* WHERE clause for partial indices */\n  ExprList *aColExpr;      /* Column expressions */\n  int tnum;                /* DB Page containing root of this index */\n  LogEst szIdxRow;         /* Estimated average row size in bytes */\n  u16 nKeyCol;             /* Number of columns forming the key */\n  u16 nColumn;             /* Number of columns stored in the index */\n  u8 onError;              /* OE_Abort, OE_Ignore, OE_Replace, or OE_None */\n  unsigned idxType:2;      /* 0:Normal 1:UNIQUE, 2:PRIMARY KEY, 3:IPK */\n  unsigned bUnordered:1;   /* Use this index for == or IN queries only */\n  unsigned uniqNotNull:1;  /* True if UNIQUE and NOT NULL for all columns */\n  unsigned isResized:1;    /* True if resizeIndexObject() has been called */\n  unsigned isCovering:1;   /* True if this is a covering index */\n  unsigned noSkipScan:1;   /* Do not try to use skip-scan if true */\n  unsigned hasStat1:1;     /* aiRowLogEst values come from sqlite_stat1 */\n  unsigned bNoQuery:1;     /* Do not use this index to optimize queries */\n  unsigned bAscKeyBug:1;   /* True if the bba7b69f9849b5bf bug applies */\n  unsigned bHasVCol:1;     /* Index references one or more VIRTUAL columns */\n#ifdef SQLITE_ENABLE_STAT4\n  int nSample;             /* Number of elements in aSample[] */\n  int nSampleCol;          /* Size of IndexSample.anEq[] and so on */\n  tRowcnt *aAvgEq;         /* Average nEq values for keys not in aSample */\n  IndexSample *aSample;    /* Samples of the left-most key */\n  tRowcnt *aiRowEst;       /* Non-logarithmic stat1 data for this index */\n  tRowcnt nRowEst0;        /* Non-logarithmic number of rows in the index */\n#endif\n  Bitmask colNotIdxed;     /* 0 for unindexed columns in pTab */\n};\n\n/*\n** Allowed values for Index.idxType\n*/\n#define SQLITE_IDXTYPE_APPDEF      0   /* Created using CREATE INDEX */\n#define SQLITE_IDXTYPE_UNIQUE      1   /* Implements a UNIQUE constraint */\n#define SQLITE_IDXTYPE_PRIMARYKEY  2   /* Is the PRIMARY KEY for the table */\n#define SQLITE_IDXTYPE_IPK         3   /* INTEGER PRIMARY KEY index */\n\n/* Return true if index X is a PRIMARY KEY index */\n#define IsPrimaryKeyIndex(X)  ((X)->idxType==SQLITE_IDXTYPE_PRIMARYKEY)\n\n/* Return true if index X is a UNIQUE index */\n#define IsUniqueIndex(X)      ((X)->onError!=OE_None)\n\n/* The Index.aiColumn[] values are normally positive integer.  But\n** there are some negative values that have special meaning:\n*/\n#define XN_ROWID     (-1)     /* Indexed column is the rowid */\n#define XN_EXPR      (-2)     /* Indexed column is an expression */\n\n/*\n** Each sample stored in the sqlite_stat4 table is represented in memory\n** using a structure of this type.  See documentation at the top of the\n** analyze.c source file for additional information.\n*/\nstruct IndexSample {\n  void *p;          /* Pointer to sampled record */\n  int n;            /* Size of record in bytes */\n  tRowcnt *anEq;    /* Est. number of rows where the key equals this sample */\n  tRowcnt *anLt;    /* Est. number of rows where key is less than this sample */\n  tRowcnt *anDLt;   /* Est. number of distinct keys less than this sample */\n};\n\n/*\n** Possible values to use within the flags argument to sqlite3GetToken().\n*/\n#define SQLITE_TOKEN_QUOTED    0x1 /* Token is a quoted identifier. */\n#define SQLITE_TOKEN_KEYWORD   0x2 /* Token is a keyword. */\n\n/*\n** Each token coming out of the lexer is an instance of\n** this structure.  Tokens are also used as part of an expression.\n**\n** The memory that \"z\" points to is owned by other objects.  Take care\n** that the owner of the \"z\" string does not deallocate the string before\n** the Token goes out of scope!  Very often, the \"z\" points to some place\n** in the middle of the Parse.zSql text.  But it might also point to a\n** static string.\n*/\nstruct Token {\n  const char *z;     /* Text of the token.  Not NULL-terminated! */\n  unsigned int n;    /* Number of characters in this token */\n};\n\n/*\n** An instance of this structure contains information needed to generate\n** code for a SELECT that contains aggregate functions.\n**\n** If Expr.op==TK_AGG_COLUMN or TK_AGG_FUNCTION then Expr.pAggInfo is a\n** pointer to this structure.  The Expr.iColumn field is the index in\n** AggInfo.aCol[] or AggInfo.aFunc[] of information needed to generate\n** code for that node.\n**\n** AggInfo.pGroupBy and AggInfo.aFunc.pExpr point to fields within the\n** original Select structure that describes the SELECT statement.  These\n** fields do not need to be freed when deallocating the AggInfo structure.\n*/\nstruct AggInfo {\n  u8 directMode;          /* Direct rendering mode means take data directly\n                          ** from source tables rather than from accumulators */\n  u8 useSortingIdx;       /* In direct mode, reference the sorting index rather\n                          ** than the source table */\n  int sortingIdx;         /* Cursor number of the sorting index */\n  int sortingIdxPTab;     /* Cursor number of pseudo-table */\n  int nSortingColumn;     /* Number of columns in the sorting index */\n  int mnReg, mxReg;       /* Range of registers allocated for aCol and aFunc */\n  ExprList *pGroupBy;     /* The group by clause */\n  struct AggInfo_col {    /* For each column used in source tables */\n    Table *pTab;             /* Source table */\n    int iTable;              /* Cursor number of the source table */\n    int iColumn;             /* Column number within the source table */\n    int iSorterColumn;       /* Column number in the sorting index */\n    int iMem;                /* Memory location that acts as accumulator */\n    Expr *pExpr;             /* The original expression */\n  } *aCol;\n  int nColumn;            /* Number of used entries in aCol[] */\n  int nAccumulator;       /* Number of columns that show through to the output.\n                          ** Additional columns are used only as parameters to\n                          ** aggregate functions */\n  struct AggInfo_func {   /* For each aggregate function */\n    Expr *pExpr;             /* Expression encoding the function */\n    FuncDef *pFunc;          /* The aggregate function implementation */\n    int iMem;                /* Memory location that acts as accumulator */\n    int iDistinct;           /* Ephemeral table used to enforce DISTINCT */\n  } *aFunc;\n  int nFunc;              /* Number of entries in aFunc[] */\n};\n\n/*\n** The datatype ynVar is a signed integer, either 16-bit or 32-bit.\n** Usually it is 16-bits.  But if SQLITE_MAX_VARIABLE_NUMBER is greater\n** than 32767 we have to make it 32-bit.  16-bit is preferred because\n** it uses less memory in the Expr object, which is a big memory user\n** in systems with lots of prepared statements.  And few applications\n** need more than about 10 or 20 variables.  But some extreme users want\n** to have prepared statements with over 32767 variables, and for them\n** the option is available (at compile-time).\n*/\n#if SQLITE_MAX_VARIABLE_NUMBER<=32767\ntypedef i16 ynVar;\n#else\ntypedef int ynVar;\n#endif\n\n/*\n** Each node of an expression in the parse tree is an instance\n** of this structure.\n**\n** Expr.op is the opcode. The integer parser token codes are reused\n** as opcodes here. For example, the parser defines TK_GE to be an integer\n** code representing the \">=\" operator. This same integer code is reused\n** to represent the greater-than-or-equal-to operator in the expression\n** tree.\n**\n** If the expression is an SQL literal (TK_INTEGER, TK_FLOAT, TK_BLOB,\n** or TK_STRING), then Expr.token contains the text of the SQL literal. If\n** the expression is a variable (TK_VARIABLE), then Expr.token contains the\n** variable name. Finally, if the expression is an SQL function (TK_FUNCTION),\n** then Expr.token contains the name of the function.\n**\n** Expr.pRight and Expr.pLeft are the left and right subexpressions of a\n** binary operator. Either or both may be NULL.\n**\n** Expr.x.pList is a list of arguments if the expression is an SQL function,\n** a CASE expression or an IN expression of the form \"<lhs> IN (<y>, <z>...)\".\n** Expr.x.pSelect is used if the expression is a sub-select or an expression of\n** the form \"<lhs> IN (SELECT ...)\". If the EP_xIsSelect bit is set in the\n** Expr.flags mask, then Expr.x.pSelect is valid. Otherwise, Expr.x.pList is\n** valid.\n**\n** An expression of the form ID or ID.ID refers to a column in a table.\n** For such expressions, Expr.op is set to TK_COLUMN and Expr.iTable is\n** the integer cursor number of a VDBE cursor pointing to that table and\n** Expr.iColumn is the column number for the specific column.  If the\n** expression is used as a result in an aggregate SELECT, then the\n** value is also stored in the Expr.iAgg column in the aggregate so that\n** it can be accessed after all aggregates are computed.\n**\n** If the expression is an unbound variable marker (a question mark\n** character '?' in the original SQL) then the Expr.iTable holds the index\n** number for that variable.\n**\n** If the expression is a subquery then Expr.iColumn holds an integer\n** register number containing the result of the subquery.  If the\n** subquery gives a constant result, then iTable is -1.  If the subquery\n** gives a different answer at different times during statement processing\n** then iTable is the address of a subroutine that computes the subquery.\n**\n** If the Expr is of type OP_Column, and the table it is selecting from\n** is a disk table or the \"old.*\" pseudo-table, then pTab points to the\n** corresponding table definition.\n**\n** ALLOCATION NOTES:\n**\n** Expr objects can use a lot of memory space in database schema.  To\n** help reduce memory requirements, sometimes an Expr object will be\n** truncated.  And to reduce the number of memory allocations, sometimes\n** two or more Expr objects will be stored in a single memory allocation,\n** together with Expr.zToken strings.\n**\n** If the EP_Reduced and EP_TokenOnly flags are set when\n** an Expr object is truncated.  When EP_Reduced is set, then all\n** the child Expr objects in the Expr.pLeft and Expr.pRight subtrees\n** are contained within the same memory allocation.  Note, however, that\n** the subtrees in Expr.x.pList or Expr.x.pSelect are always separately\n** allocated, regardless of whether or not EP_Reduced is set.\n*/\nstruct Expr {\n  u8 op;                 /* Operation performed by this node */\n  char affExpr;          /* affinity, or RAISE type */\n  u8 op2;                /* TK_REGISTER/TK_TRUTH: original value of Expr.op\n                         ** TK_COLUMN: the value of p5 for OP_Column\n                         ** TK_AGG_FUNCTION: nesting depth\n                         ** TK_FUNCTION: NC_SelfRef flag if needs OP_PureFunc */\n  u32 flags;             /* Various flags.  EP_* See below */\n  union {\n    char *zToken;          /* Token value. Zero terminated and dequoted */\n    int iValue;            /* Non-negative integer value if EP_IntValue */\n  } u;\n\n  /* If the EP_TokenOnly flag is set in the Expr.flags mask, then no\n  ** space is allocated for the fields below this point. An attempt to\n  ** access them will result in a segfault or malfunction.\n  *********************************************************************/\n\n  Expr *pLeft;           /* Left subnode */\n  Expr *pRight;          /* Right subnode */\n  union {\n    ExprList *pList;     /* op = IN, EXISTS, SELECT, CASE, FUNCTION, BETWEEN */\n    Select *pSelect;     /* EP_xIsSelect and op = IN, EXISTS, SELECT */\n  } x;\n\n  /* If the EP_Reduced flag is set in the Expr.flags mask, then no\n  ** space is allocated for the fields below this point. An attempt to\n  ** access them will result in a segfault or malfunction.\n  *********************************************************************/\n\n#if SQLITE_MAX_EXPR_DEPTH>0\n  int nHeight;           /* Height of the tree headed by this node */\n#endif\n  int iTable;            /* TK_COLUMN: cursor number of table holding column\n                         ** TK_REGISTER: register number\n                         ** TK_TRIGGER: 1 -> new, 0 -> old\n                         ** EP_Unlikely:  134217728 times likelihood\n                         ** TK_IN: ephemerial table holding RHS\n                         ** TK_SELECT_COLUMN: Number of columns on the LHS\n                         ** TK_SELECT: 1st register of result vector */\n  ynVar iColumn;         /* TK_COLUMN: column index.  -1 for rowid.\n                         ** TK_VARIABLE: variable number (always >= 1).\n                         ** TK_SELECT_COLUMN: column of the result vector */\n  i16 iAgg;              /* Which entry in pAggInfo->aCol[] or ->aFunc[] */\n  i16 iRightJoinTable;   /* If EP_FromJoin, the right table of the join */\n  AggInfo *pAggInfo;     /* Used by TK_AGG_COLUMN and TK_AGG_FUNCTION */\n  union {\n    Table *pTab;           /* TK_COLUMN: Table containing column. Can be NULL\n                           ** for a column of an index on an expression */\n    Window *pWin;          /* EP_WinFunc: Window/Filter defn for a function */\n    struct {               /* TK_IN, TK_SELECT, and TK_EXISTS */\n      int iAddr;             /* Subroutine entry address */\n      int regReturn;         /* Register used to hold return address */\n    } sub;\n  } y;\n};\n\n/*\n** The following are the meanings of bits in the Expr.flags field.\n** Value restrictions:\n**\n**          EP_Agg == NC_HasAgg == SF_HasAgg\n**          EP_Win == NC_HasWin\n*/\n#define EP_FromJoin   0x000001 /* Originates in ON/USING clause of outer join */\n#define EP_Distinct   0x000002 /* Aggregate function with DISTINCT keyword */\n#define EP_HasFunc    0x000004 /* Contains one or more functions of any kind */\n#define EP_FixedCol   0x000008 /* TK_Column with a known fixed value */\n#define EP_Agg        0x000010 /* Contains one or more aggregate functions */\n#define EP_VarSelect  0x000020 /* pSelect is correlated, not constant */\n#define EP_DblQuoted  0x000040 /* token.z was originally in \"...\" */\n#define EP_InfixFunc  0x000080 /* True for an infix function: LIKE, GLOB, etc */\n#define EP_Collate    0x000100 /* Tree contains a TK_COLLATE operator */\n#define EP_Commuted   0x000200 /* Comparison operator has been commuted */\n#define EP_IntValue   0x000400 /* Integer value contained in u.iValue */\n#define EP_xIsSelect  0x000800 /* x.pSelect is valid (otherwise x.pList is) */\n#define EP_Skip       0x001000 /* Operator does not contribute to affinity */\n#define EP_Reduced    0x002000 /* Expr struct EXPR_REDUCEDSIZE bytes only */\n#define EP_TokenOnly  0x004000 /* Expr struct EXPR_TOKENONLYSIZE bytes only */\n#define EP_Win        0x008000 /* Contains window functions */\n#define EP_MemToken   0x010000 /* Need to sqlite3DbFree() Expr.zToken */\n#define EP_NoReduce   0x020000 /* Cannot EXPRDUP_REDUCE this Expr */\n#define EP_Unlikely   0x040000 /* unlikely() or likelihood() function */\n#define EP_ConstFunc  0x080000 /* A SQLITE_FUNC_CONSTANT or _SLOCHNG function */\n#define EP_CanBeNull  0x100000 /* Can be null despite NOT NULL constraint */\n#define EP_Subquery   0x200000 /* Tree contains a TK_SELECT operator */\n#define EP_Alias      0x400000 /* Is an alias for a result set column */\n#define EP_Leaf       0x800000 /* Expr.pLeft, .pRight, .u.pSelect all NULL */\n#define EP_WinFunc   0x1000000 /* TK_FUNCTION with Expr.y.pWin set */\n#define EP_Subrtn    0x2000000 /* Uses Expr.y.sub. TK_IN, _SELECT, or _EXISTS */\n#define EP_Quoted    0x4000000 /* TK_ID was originally quoted */\n#define EP_Static    0x8000000 /* Held in memory not obtained from malloc() */\n#define EP_IsTrue   0x10000000 /* Always has boolean value of TRUE */\n#define EP_IsFalse  0x20000000 /* Always has boolean value of FALSE */\n#define EP_Indirect 0x40000000 /* Contained within a TRIGGER or a VIEW */\n\n/*\n** The EP_Propagate mask is a set of properties that automatically propagate\n** upwards into parent nodes.\n*/\n#define EP_Propagate (EP_Collate|EP_Subquery|EP_HasFunc)\n\n/*\n** These macros can be used to test, set, or clear bits in the\n** Expr.flags field.\n*/\n#define ExprHasProperty(E,P)     (((E)->flags&(P))!=0)\n#define ExprHasAllProperty(E,P)  (((E)->flags&(P))==(P))\n#define ExprSetProperty(E,P)     (E)->flags|=(P)\n#define ExprClearProperty(E,P)   (E)->flags&=~(P)\n#define ExprAlwaysTrue(E)   (((E)->flags&(EP_FromJoin|EP_IsTrue))==EP_IsTrue)\n#define ExprAlwaysFalse(E)  (((E)->flags&(EP_FromJoin|EP_IsFalse))==EP_IsFalse)\n\n/* The ExprSetVVAProperty() macro is used for Verification, Validation,\n** and Accreditation only.  It works like ExprSetProperty() during VVA\n** processes but is a no-op for delivery.\n*/\n#ifdef SQLITE_DEBUG\n# define ExprSetVVAProperty(E,P)  (E)->flags|=(P)\n#else\n# define ExprSetVVAProperty(E,P)\n#endif\n\n/*\n** Macros to determine the number of bytes required by a normal Expr\n** struct, an Expr struct with the EP_Reduced flag set in Expr.flags\n** and an Expr struct with the EP_TokenOnly flag set.\n*/\n#define EXPR_FULLSIZE           sizeof(Expr)           /* Full size */\n#define EXPR_REDUCEDSIZE        offsetof(Expr,iTable)  /* Common features */\n#define EXPR_TOKENONLYSIZE      offsetof(Expr,pLeft)   /* Fewer features */\n\n/*\n** Flags passed to the sqlite3ExprDup() function. See the header comment\n** above sqlite3ExprDup() for details.\n*/\n#define EXPRDUP_REDUCE         0x0001  /* Used reduced-size Expr nodes */\n\n/*\n** True if the expression passed as an argument was a function with\n** an OVER() clause (a window function).\n*/\n#ifdef SQLITE_OMIT_WINDOWFUNC\n# define IsWindowFunc(p) 0\n#else\n# define IsWindowFunc(p) ( \\\n    ExprHasProperty((p), EP_WinFunc) && p->y.pWin->eFrmType!=TK_FILTER \\\n )\n#endif\n\n/*\n** A list of expressions.  Each expression may optionally have a\n** name.  An expr/name combination can be used in several ways, such\n** as the list of \"expr AS ID\" fields following a \"SELECT\" or in the\n** list of \"ID = expr\" items in an UPDATE.  A list of expressions can\n** also be used as the argument to a function, in which case the a.zName\n** field is not used.\n**\n** By default the Expr.zSpan field holds a human-readable description of\n** the expression that is used in the generation of error messages and\n** column labels.  In this case, Expr.zSpan is typically the text of a\n** column expression as it exists in a SELECT statement.  However, if\n** the bSpanIsTab flag is set, then zSpan is overloaded to mean the name\n** of the result column in the form: DATABASE.TABLE.COLUMN.  This later\n** form is used for name resolution with nested FROM clauses.\n*/\nstruct ExprList {\n  int nExpr;             /* Number of expressions on the list */\n  struct ExprList_item { /* For each expression in the list */\n    Expr *pExpr;            /* The parse tree for this expression */\n    char *zName;            /* Token associated with this expression */\n    char *zSpan;            /* Original text of the expression */\n    u8 sortFlags;           /* Mask of KEYINFO_ORDER_* flags */\n    unsigned done :1;       /* A flag to indicate when processing is finished */\n    unsigned bSpanIsTab :1; /* zSpan holds DB.TABLE.COLUMN */\n    unsigned reusable :1;   /* Constant expression is reusable */\n    unsigned bSorterRef :1; /* Defer evaluation until after sorting */\n    unsigned bNulls: 1;     /* True if explicit \"NULLS FIRST/LAST\" */\n    union {\n      struct {\n        u16 iOrderByCol;      /* For ORDER BY, column number in result set */\n        u16 iAlias;           /* Index into Parse.aAlias[] for zName */\n      } x;\n      int iConstExprReg;      /* Register in which Expr value is cached */\n    } u;\n  } a[1];                  /* One slot for each expression in the list */\n};\n\n/*\n** An instance of this structure can hold a simple list of identifiers,\n** such as the list \"a,b,c\" in the following statements:\n**\n**      INSERT INTO t(a,b,c) VALUES ...;\n**      CREATE INDEX idx ON t(a,b,c);\n**      CREATE TRIGGER trig BEFORE UPDATE ON t(a,b,c) ...;\n**\n** The IdList.a.idx field is used when the IdList represents the list of\n** column names after a table name in an INSERT statement.  In the statement\n**\n**     INSERT INTO t(a,b,c) ...\n**\n** If \"a\" is the k-th column of table \"t\", then IdList.a[0].idx==k.\n*/\nstruct IdList {\n  struct IdList_item {\n    char *zName;      /* Name of the identifier */\n    int idx;          /* Index in some Table.aCol[] of a column named zName */\n  } *a;\n  int nId;         /* Number of identifiers on the list */\n};\n\n/*\n** The following structure describes the FROM clause of a SELECT statement.\n** Each table or subquery in the FROM clause is a separate element of\n** the SrcList.a[] array.\n**\n** With the addition of multiple database support, the following structure\n** can also be used to describe a particular table such as the table that\n** is modified by an INSERT, DELETE, or UPDATE statement.  In standard SQL,\n** such a table must be a simple name: ID.  But in SQLite, the table can\n** now be identified by a database name, a dot, then the table name: ID.ID.\n**\n** The jointype starts out showing the join type between the current table\n** and the next table on the list.  The parser builds the list this way.\n** But sqlite3SrcListShiftJoinType() later shifts the jointypes so that each\n** jointype expresses the join between the table and the previous table.\n**\n** In the colUsed field, the high-order bit (bit 63) is set if the table\n** contains more than 63 columns and the 64-th or later column is used.\n*/\nstruct SrcList {\n  int nSrc;        /* Number of tables or subqueries in the FROM clause */\n  u32 nAlloc;      /* Number of entries allocated in a[] below */\n  struct SrcList_item {\n    Schema *pSchema;  /* Schema to which this item is fixed */\n    char *zDatabase;  /* Name of database holding this table */\n    char *zName;      /* Name of the table */\n    char *zAlias;     /* The \"B\" part of a \"A AS B\" phrase.  zName is the \"A\" */\n    Table *pTab;      /* An SQL table corresponding to zName */\n    Select *pSelect;  /* A SELECT statement used in place of a table name */\n    int addrFillSub;  /* Address of subroutine to manifest a subquery */\n    int regReturn;    /* Register holding return address of addrFillSub */\n    int regResult;    /* Registers holding results of a co-routine */\n    struct {\n      u8 jointype;      /* Type of join between this table and the previous */\n      unsigned notIndexed :1;    /* True if there is a NOT INDEXED clause */\n      unsigned isIndexedBy :1;   /* True if there is an INDEXED BY clause */\n      unsigned isTabFunc :1;     /* True if table-valued-function syntax */\n      unsigned isCorrelated :1;  /* True if sub-query is correlated */\n      unsigned viaCoroutine :1;  /* Implemented as a co-routine */\n      unsigned isRecursive :1;   /* True for recursive reference in WITH */\n    } fg;\n    int iCursor;      /* The VDBE cursor number used to access this table */\n    Expr *pOn;        /* The ON clause of a join */\n    IdList *pUsing;   /* The USING clause of a join */\n    Bitmask colUsed;  /* Bit N (1<<N) set if column N of pTab is used */\n    union {\n      char *zIndexedBy;    /* Identifier from \"INDEXED BY <zIndex>\" clause */\n      ExprList *pFuncArg;  /* Arguments to table-valued-function */\n    } u1;\n    Index *pIBIndex;  /* Index structure corresponding to u1.zIndexedBy */\n  } a[1];             /* One entry for each identifier on the list */\n};\n\n/*\n** Permitted values of the SrcList.a.jointype field\n*/\n#define JT_INNER     0x0001    /* Any kind of inner or cross join */\n#define JT_CROSS     0x0002    /* Explicit use of the CROSS keyword */\n#define JT_NATURAL   0x0004    /* True for a \"natural\" join */\n#define JT_LEFT      0x0008    /* Left outer join */\n#define JT_RIGHT     0x0010    /* Right outer join */\n#define JT_OUTER     0x0020    /* The \"OUTER\" keyword is present */\n#define JT_ERROR     0x0040    /* unknown or unsupported join type */\n\n\n/*\n** Flags appropriate for the wctrlFlags parameter of sqlite3WhereBegin()\n** and the WhereInfo.wctrlFlags member.\n**\n** Value constraints (enforced via assert()):\n**     WHERE_USE_LIMIT  == SF_FixedLimit\n*/\n#define WHERE_ORDERBY_NORMAL   0x0000 /* No-op */\n#define WHERE_ORDERBY_MIN      0x0001 /* ORDER BY processing for min() func */\n#define WHERE_ORDERBY_MAX      0x0002 /* ORDER BY processing for max() func */\n#define WHERE_ONEPASS_DESIRED  0x0004 /* Want to do one-pass UPDATE/DELETE */\n#define WHERE_ONEPASS_MULTIROW 0x0008 /* ONEPASS is ok with multiple rows */\n#define WHERE_DUPLICATES_OK    0x0010 /* Ok to return a row more than once */\n#define WHERE_OR_SUBCLAUSE     0x0020 /* Processing a sub-WHERE as part of\n                                      ** the OR optimization  */\n#define WHERE_GROUPBY          0x0040 /* pOrderBy is really a GROUP BY */\n#define WHERE_DISTINCTBY       0x0080 /* pOrderby is really a DISTINCT clause */\n#define WHERE_WANT_DISTINCT    0x0100 /* All output needs to be distinct */\n#define WHERE_SORTBYGROUP      0x0200 /* Support sqlite3WhereIsSorted() */\n#define WHERE_SEEK_TABLE       0x0400 /* Do not defer seeks on main table */\n#define WHERE_ORDERBY_LIMIT    0x0800 /* ORDERBY+LIMIT on the inner loop */\n#define WHERE_SEEK_UNIQ_TABLE  0x1000 /* Do not defer seeks if unique */\n                        /*     0x2000    not currently used */\n#define WHERE_USE_LIMIT        0x4000 /* Use the LIMIT in cost estimates */\n                        /*     0x8000    not currently used */\n\n/* Allowed return values from sqlite3WhereIsDistinct()\n*/\n#define WHERE_DISTINCT_NOOP      0  /* DISTINCT keyword not used */\n#define WHERE_DISTINCT_UNIQUE    1  /* No duplicates */\n#define WHERE_DISTINCT_ORDERED   2  /* All duplicates are adjacent */\n#define WHERE_DISTINCT_UNORDERED 3  /* Duplicates are scattered */\n\n/*\n** A NameContext defines a context in which to resolve table and column\n** names.  The context consists of a list of tables (the pSrcList) field and\n** a list of named expression (pEList).  The named expression list may\n** be NULL.  The pSrc corresponds to the FROM clause of a SELECT or\n** to the table being operated on by INSERT, UPDATE, or DELETE.  The\n** pEList corresponds to the result set of a SELECT and is NULL for\n** other statements.\n**\n** NameContexts can be nested.  When resolving names, the inner-most\n** context is searched first.  If no match is found, the next outer\n** context is checked.  If there is still no match, the next context\n** is checked.  This process continues until either a match is found\n** or all contexts are check.  When a match is found, the nRef member of\n** the context containing the match is incremented.\n**\n** Each subquery gets a new NameContext.  The pNext field points to the\n** NameContext in the parent query.  Thus the process of scanning the\n** NameContext list corresponds to searching through successively outer\n** subqueries looking for a match.\n*/\nstruct NameContext {\n  Parse *pParse;       /* The parser */\n  SrcList *pSrcList;   /* One or more tables used to resolve names */\n  union {\n    ExprList *pEList;    /* Optional list of result-set columns */\n    AggInfo *pAggInfo;   /* Information about aggregates at this level */\n    Upsert *pUpsert;     /* ON CONFLICT clause information from an upsert */\n  } uNC;\n  NameContext *pNext;  /* Next outer name context.  NULL for outermost */\n  int nRef;            /* Number of names resolved by this context */\n  int nErr;            /* Number of errors encountered while resolving names */\n  int ncFlags;         /* Zero or more NC_* flags defined below */\n  Select *pWinSelect;  /* SELECT statement for any window functions */\n};\n\n/*\n** Allowed values for the NameContext, ncFlags field.\n**\n** Value constraints (all checked via assert()):\n**    NC_HasAgg    == SF_HasAgg    == EP_Agg\n**    NC_MinMaxAgg == SF_MinMaxAgg == SQLITE_FUNC_MINMAX\n**    NC_HasWin    == EP_Win\n**\n*/\n#define NC_AllowAgg  0x00001  /* Aggregate functions are allowed here */\n#define NC_PartIdx   0x00002  /* True if resolving a partial index WHERE */\n#define NC_IsCheck   0x00004  /* True if resolving a CHECK constraint */\n#define NC_GenCol    0x00008  /* True for a GENERATED ALWAYS AS clause */\n#define NC_HasAgg    0x00010  /* One or more aggregate functions seen */\n#define NC_IdxExpr   0x00020  /* True if resolving columns of CREATE INDEX */\n#define NC_SelfRef   0x0002e  /* Combo: PartIdx, isCheck, GenCol, and IdxExpr */\n#define NC_VarSelect 0x00040  /* A correlated subquery has been seen */\n#define NC_UEList    0x00080  /* True if uNC.pEList is used */\n#define NC_UAggInfo  0x00100  /* True if uNC.pAggInfo is used */\n#define NC_UUpsert   0x00200  /* True if uNC.pUpsert is used */\n#define NC_MinMaxAgg 0x01000  /* min/max aggregates seen.  See note above */\n#define NC_Complex   0x02000  /* True if a function or subquery seen */\n#define NC_AllowWin  0x04000  /* Window functions are allowed here */\n#define NC_HasWin    0x08000  /* One or more window functions seen */\n#define NC_IsDDL     0x10000  /* Resolving names in a CREATE statement */\n#define NC_InAggFunc 0x20000  /* True if analyzing arguments to an agg func */\n\n/*\n** An instance of the following object describes a single ON CONFLICT\n** clause in an upsert.\n**\n** The pUpsertTarget field is only set if the ON CONFLICT clause includes\n** conflict-target clause.  (In \"ON CONFLICT(a,b)\" the \"(a,b)\" is the\n** conflict-target clause.)  The pUpsertTargetWhere is the optional\n** WHERE clause used to identify partial unique indexes.\n**\n** pUpsertSet is the list of column=expr terms of the UPDATE statement. \n** The pUpsertSet field is NULL for a ON CONFLICT DO NOTHING.  The\n** pUpsertWhere is the WHERE clause for the UPDATE and is NULL if the\n** WHERE clause is omitted.\n*/\nstruct Upsert {\n  ExprList *pUpsertTarget;  /* Optional description of conflicting index */\n  Expr *pUpsertTargetWhere; /* WHERE clause for partial index targets */\n  ExprList *pUpsertSet;     /* The SET clause from an ON CONFLICT UPDATE */\n  Expr *pUpsertWhere;       /* WHERE clause for the ON CONFLICT UPDATE */\n  /* The fields above comprise the parse tree for the upsert clause.\n  ** The fields below are used to transfer information from the INSERT\n  ** processing down into the UPDATE processing while generating code.\n  ** Upsert owns the memory allocated above, but not the memory below. */\n  Index *pUpsertIdx;        /* Constraint that pUpsertTarget identifies */\n  SrcList *pUpsertSrc;      /* Table to be updated */\n  int regData;              /* First register holding array of VALUES */\n  int iDataCur;             /* Index of the data cursor */\n  int iIdxCur;              /* Index of the first index cursor */\n};\n\n/*\n** An instance of the following structure contains all information\n** needed to generate code for a single SELECT statement.\n**\n** See the header comment on the computeLimitRegisters() routine for a\n** detailed description of the meaning of the iLimit and iOffset fields.\n**\n** addrOpenEphm[] entries contain the address of OP_OpenEphemeral opcodes.\n** These addresses must be stored so that we can go back and fill in\n** the P4_KEYINFO and P2 parameters later.  Neither the KeyInfo nor\n** the number of columns in P2 can be computed at the same time\n** as the OP_OpenEphm instruction is coded because not\n** enough information about the compound query is known at that point.\n** The KeyInfo for addrOpenTran[0] and [1] contains collating sequences\n** for the result set.  The KeyInfo for addrOpenEphm[2] contains collating\n** sequences for the ORDER BY clause.\n*/\nstruct Select {\n  ExprList *pEList;      /* The fields of the result */\n  u8 op;                 /* One of: TK_UNION TK_ALL TK_INTERSECT TK_EXCEPT */\n  LogEst nSelectRow;     /* Estimated number of result rows */\n  u32 selFlags;          /* Various SF_* values */\n  int iLimit, iOffset;   /* Memory registers holding LIMIT & OFFSET counters */\n  u32 selId;             /* Unique identifier number for this SELECT */\n  int addrOpenEphm[2];   /* OP_OpenEphem opcodes related to this select */\n  SrcList *pSrc;         /* The FROM clause */\n  Expr *pWhere;          /* The WHERE clause */\n  ExprList *pGroupBy;    /* The GROUP BY clause */\n  Expr *pHaving;         /* The HAVING clause */\n  ExprList *pOrderBy;    /* The ORDER BY clause */\n  Select *pPrior;        /* Prior select in a compound select statement */\n  Select *pNext;         /* Next select to the left in a compound */\n  Expr *pLimit;          /* LIMIT expression. NULL means not used. */\n  With *pWith;           /* WITH clause attached to this select. Or NULL. */\n#ifndef SQLITE_OMIT_WINDOWFUNC\n  Window *pWin;          /* List of window functions */\n  Window *pWinDefn;      /* List of named window definitions */\n#endif\n};\n\n/*\n** Allowed values for Select.selFlags.  The \"SF\" prefix stands for\n** \"Select Flag\".\n**\n** Value constraints (all checked via assert())\n**     SF_HasAgg     == NC_HasAgg\n**     SF_MinMaxAgg  == NC_MinMaxAgg     == SQLITE_FUNC_MINMAX\n**     SF_FixedLimit == WHERE_USE_LIMIT\n*/\n#define SF_Distinct      0x0000001 /* Output should be DISTINCT */\n#define SF_All           0x0000002 /* Includes the ALL keyword */\n#define SF_Resolved      0x0000004 /* Identifiers have been resolved */\n#define SF_Aggregate     0x0000008 /* Contains agg functions or a GROUP BY */\n#define SF_HasAgg        0x0000010 /* Contains aggregate functions */\n#define SF_UsesEphemeral 0x0000020 /* Uses the OpenEphemeral opcode */\n#define SF_Expanded      0x0000040 /* sqlite3SelectExpand() called on this */\n#define SF_HasTypeInfo   0x0000080 /* FROM subqueries have Table metadata */\n#define SF_Compound      0x0000100 /* Part of a compound query */\n#define SF_Values        0x0000200 /* Synthesized from VALUES clause */\n#define SF_MultiValue    0x0000400 /* Single VALUES term with multiple rows */\n#define SF_NestedFrom    0x0000800 /* Part of a parenthesized FROM clause */\n#define SF_MinMaxAgg     0x0001000 /* Aggregate containing min() or max() */\n#define SF_Recursive     0x0002000 /* The recursive part of a recursive CTE */\n#define SF_FixedLimit    0x0004000 /* nSelectRow set by a constant LIMIT */\n#define SF_MaybeConvert  0x0008000 /* Need convertCompoundSelectToSubquery() */\n#define SF_Converted     0x0010000 /* By convertCompoundSelectToSubquery() */\n#define SF_IncludeHidden 0x0020000 /* Include hidden columns in output */\n#define SF_ComplexResult 0x0040000 /* Result contains subquery or function */\n#define SF_WhereBegin    0x0080000 /* Really a WhereBegin() call.  Debug Only */\n#define SF_WinRewrite    0x0100000 /* Window function rewrite accomplished */\n#define SF_View          0x0200000 /* SELECT statement is a view */\n\n/*\n** The results of a SELECT can be distributed in several ways, as defined\n** by one of the following macros.  The \"SRT\" prefix means \"SELECT Result\n** Type\".\n**\n**     SRT_Union       Store results as a key in a temporary index\n**                     identified by pDest->iSDParm.\n**\n**     SRT_Except      Remove results from the temporary index pDest->iSDParm.\n**\n**     SRT_Exists      Store a 1 in memory cell pDest->iSDParm if the result\n**                     set is not empty.\n**\n**     SRT_Discard     Throw the results away.  This is used by SELECT\n**                     statements within triggers whose only purpose is\n**                     the side-effects of functions.\n**\n** All of the above are free to ignore their ORDER BY clause. Those that\n** follow must honor the ORDER BY clause.\n**\n**     SRT_Output      Generate a row of output (using the OP_ResultRow\n**                     opcode) for each row in the result set.\n**\n**     SRT_Mem         Only valid if the result is a single column.\n**                     Store the first column of the first result row\n**                     in register pDest->iSDParm then abandon the rest\n**                     of the query.  This destination implies \"LIMIT 1\".\n**\n**     SRT_Set         The result must be a single column.  Store each\n**                     row of result as the key in table pDest->iSDParm.\n**                     Apply the affinity pDest->affSdst before storing\n**                     results.  Used to implement \"IN (SELECT ...)\".\n**\n**     SRT_EphemTab    Create an temporary table pDest->iSDParm and store\n**                     the result there. The cursor is left open after\n**                     returning.  This is like SRT_Table except that\n**                     this destination uses OP_OpenEphemeral to create\n**                     the table first.\n**\n**     SRT_Coroutine   Generate a co-routine that returns a new row of\n**                     results each time it is invoked.  The entry point\n**                     of the co-routine is stored in register pDest->iSDParm\n**                     and the result row is stored in pDest->nDest registers\n**                     starting with pDest->iSdst.\n**\n**     SRT_Table       Store results in temporary table pDest->iSDParm.\n**     SRT_Fifo        This is like SRT_EphemTab except that the table\n**                     is assumed to already be open.  SRT_Fifo has\n**                     the additional property of being able to ignore\n**                     the ORDER BY clause.\n**\n**     SRT_DistFifo    Store results in a temporary table pDest->iSDParm.\n**                     But also use temporary table pDest->iSDParm+1 as\n**                     a record of all prior results and ignore any duplicate\n**                     rows.  Name means:  \"Distinct Fifo\".\n**\n**     SRT_Queue       Store results in priority queue pDest->iSDParm (really\n**                     an index).  Append a sequence number so that all entries\n**                     are distinct.\n**\n**     SRT_DistQueue   Store results in priority queue pDest->iSDParm only if\n**                     the same record has never been stored before.  The\n**                     index at pDest->iSDParm+1 hold all prior stores.\n*/\n#define SRT_Union        1  /* Store result as keys in an index */\n#define SRT_Except       2  /* Remove result from a UNION index */\n#define SRT_Exists       3  /* Store 1 if the result is not empty */\n#define SRT_Discard      4  /* Do not save the results anywhere */\n#define SRT_Fifo         5  /* Store result as data with an automatic rowid */\n#define SRT_DistFifo     6  /* Like SRT_Fifo, but unique results only */\n#define SRT_Queue        7  /* Store result in an queue */\n#define SRT_DistQueue    8  /* Like SRT_Queue, but unique results only */\n\n/* The ORDER BY clause is ignored for all of the above */\n#define IgnorableOrderby(X) ((X->eDest)<=SRT_DistQueue)\n\n#define SRT_Output       9  /* Output each row of result */\n#define SRT_Mem         10  /* Store result in a memory cell */\n#define SRT_Set         11  /* Store results as keys in an index */\n#define SRT_EphemTab    12  /* Create transient tab and store like SRT_Table */\n#define SRT_Coroutine   13  /* Generate a single row of result */\n#define SRT_Table       14  /* Store result as data with an automatic rowid */\n\n/*\n** An instance of this object describes where to put of the results of\n** a SELECT statement.\n*/\nstruct SelectDest {\n  u8 eDest;            /* How to dispose of the results.  On of SRT_* above. */\n  int iSDParm;         /* A parameter used by the eDest disposal method */\n  int iSdst;           /* Base register where results are written */\n  int nSdst;           /* Number of registers allocated */\n  char *zAffSdst;      /* Affinity used when eDest==SRT_Set */\n  ExprList *pOrderBy;  /* Key columns for SRT_Queue and SRT_DistQueue */\n};\n\n/*\n** During code generation of statements that do inserts into AUTOINCREMENT\n** tables, the following information is attached to the Table.u.autoInc.p\n** pointer of each autoincrement table to record some side information that\n** the code generator needs.  We have to keep per-table autoincrement\n** information in case inserts are done within triggers.  Triggers do not\n** normally coordinate their activities, but we do need to coordinate the\n** loading and saving of autoincrement information.\n*/\nstruct AutoincInfo {\n  AutoincInfo *pNext;   /* Next info block in a list of them all */\n  Table *pTab;          /* Table this info block refers to */\n  int iDb;              /* Index in sqlite3.aDb[] of database holding pTab */\n  int regCtr;           /* Memory register holding the rowid counter */\n};\n\n/*\n** At least one instance of the following structure is created for each\n** trigger that may be fired while parsing an INSERT, UPDATE or DELETE\n** statement. All such objects are stored in the linked list headed at\n** Parse.pTriggerPrg and deleted once statement compilation has been\n** completed.\n**\n** A Vdbe sub-program that implements the body and WHEN clause of trigger\n** TriggerPrg.pTrigger, assuming a default ON CONFLICT clause of\n** TriggerPrg.orconf, is stored in the TriggerPrg.pProgram variable.\n** The Parse.pTriggerPrg list never contains two entries with the same\n** values for both pTrigger and orconf.\n**\n** The TriggerPrg.aColmask[0] variable is set to a mask of old.* columns\n** accessed (or set to 0 for triggers fired as a result of INSERT\n** statements). Similarly, the TriggerPrg.aColmask[1] variable is set to\n** a mask of new.* columns used by the program.\n*/\nstruct TriggerPrg {\n  Trigger *pTrigger;      /* Trigger this program was coded from */\n  TriggerPrg *pNext;      /* Next entry in Parse.pTriggerPrg list */\n  SubProgram *pProgram;   /* Program implementing pTrigger/orconf */\n  int orconf;             /* Default ON CONFLICT policy */\n  u32 aColmask[2];        /* Masks of old.*, new.* columns accessed */\n};\n\n/*\n** The yDbMask datatype for the bitmask of all attached databases.\n*/\n#if SQLITE_MAX_ATTACHED>30\n  typedef unsigned char yDbMask[(SQLITE_MAX_ATTACHED+9)/8];\n# define DbMaskTest(M,I)    (((M)[(I)/8]&(1<<((I)&7)))!=0)\n# define DbMaskZero(M)      memset((M),0,sizeof(M))\n# define DbMaskSet(M,I)     (M)[(I)/8]|=(1<<((I)&7))\n# define DbMaskAllZero(M)   sqlite3DbMaskAllZero(M)\n# define DbMaskNonZero(M)   (sqlite3DbMaskAllZero(M)==0)\n#else\n  typedef unsigned int yDbMask;\n# define DbMaskTest(M,I)    (((M)&(((yDbMask)1)<<(I)))!=0)\n# define DbMaskZero(M)      (M)=0\n# define DbMaskSet(M,I)     (M)|=(((yDbMask)1)<<(I))\n# define DbMaskAllZero(M)   (M)==0\n# define DbMaskNonZero(M)   (M)!=0\n#endif\n\n/*\n** An SQL parser context.  A copy of this structure is passed through\n** the parser and down into all the parser action routine in order to\n** carry around information that is global to the entire parse.\n**\n** The structure is divided into two parts.  When the parser and code\n** generate call themselves recursively, the first part of the structure\n** is constant but the second part is reset at the beginning and end of\n** each recursion.\n**\n** The nTableLock and aTableLock variables are only used if the shared-cache\n** feature is enabled (if sqlite3Tsd()->useSharedData is true). They are\n** used to store the set of table-locks required by the statement being\n** compiled. Function sqlite3TableLock() is used to add entries to the\n** list.\n*/\nstruct Parse {\n  sqlite3 *db;         /* The main database structure */\n  char *zErrMsg;       /* An error message */\n  Vdbe *pVdbe;         /* An engine for executing database bytecode */\n  int rc;              /* Return code from execution */\n  u8 colNamesSet;      /* TRUE after OP_ColumnName has been issued to pVdbe */\n  u8 checkSchema;      /* Causes schema cookie check after an error */\n  u8 nested;           /* Number of nested calls to the parser/code generator */\n  u8 nTempReg;         /* Number of temporary registers in aTempReg[] */\n  u8 isMultiWrite;     /* True if statement may modify/insert multiple rows */\n  u8 mayAbort;         /* True if statement may throw an ABORT exception */\n  u8 hasCompound;      /* Need to invoke convertCompoundSelectToSubquery() */\n  u8 okConstFactor;    /* OK to factor out constants */\n  u8 disableLookaside; /* Number of times lookaside has been disabled */\n  u8 disableVtab;      /* Disable all virtual tables for this parse */\n  int nRangeReg;       /* Size of the temporary register block */\n  int iRangeReg;       /* First register in temporary register block */\n  int nErr;            /* Number of errors seen */\n  int nTab;            /* Number of previously allocated VDBE cursors */\n  int nMem;            /* Number of memory cells used so far */\n  int szOpAlloc;       /* Bytes of memory space allocated for Vdbe.aOp[] */\n  int iSelfTab;        /* Table associated with an index on expr, or negative\n                       ** of the base register during check-constraint eval */\n  int nLabel;          /* The *negative* of the number of labels used */\n  int nLabelAlloc;     /* Number of slots in aLabel */\n  int *aLabel;         /* Space to hold the labels */\n  ExprList *pConstExpr;/* Constant expressions */\n  Token constraintName;/* Name of the constraint currently being parsed */\n  yDbMask writeMask;   /* Start a write transaction on these databases */\n  yDbMask cookieMask;  /* Bitmask of schema verified databases */\n  int regRowid;        /* Register holding rowid of CREATE TABLE entry */\n  int regRoot;         /* Register holding root page number for new objects */\n  int nMaxArg;         /* Max args passed to user function by sub-program */\n  int nSelect;         /* Number of SELECT stmts. Counter for Select.selId */\n#ifndef SQLITE_OMIT_SHARED_CACHE\n  int nTableLock;        /* Number of locks in aTableLock */\n  TableLock *aTableLock; /* Required table locks for shared-cache mode */\n#endif\n  AutoincInfo *pAinc;  /* Information about AUTOINCREMENT counters */\n  Parse *pToplevel;    /* Parse structure for main program (or NULL) */\n  Table *pTriggerTab;  /* Table triggers are being coded for */\n  Parse *pParentParse; /* Parent parser if this parser is nested */\n  int addrCrTab;       /* Address of OP_CreateBtree opcode on CREATE TABLE */\n  u32 nQueryLoop;      /* Est number of iterations of a query (10*log2(N)) */\n  u32 oldmask;         /* Mask of old.* columns referenced */\n  u32 newmask;         /* Mask of new.* columns referenced */\n  u8 eTriggerOp;       /* TK_UPDATE, TK_INSERT or TK_DELETE */\n  u8 eOrconf;          /* Default ON CONFLICT policy for trigger steps */\n  u8 disableTriggers;  /* True to disable triggers */\n\n  /**************************************************************************\n  ** Fields above must be initialized to zero.  The fields that follow,\n  ** down to the beginning of the recursive section, do not need to be\n  ** initialized as they will be set before being used.  The boundary is\n  ** determined by offsetof(Parse,aTempReg).\n  **************************************************************************/\n\n  int aTempReg[8];        /* Holding area for temporary registers */\n  Token sNameToken;       /* Token with unqualified schema object name */\n\n  /************************************************************************\n  ** Above is constant between recursions.  Below is reset before and after\n  ** each recursion.  The boundary between these two regions is determined\n  ** using offsetof(Parse,sLastToken) so the sLastToken field must be the\n  ** first field in the recursive region.\n  ************************************************************************/\n\n  Token sLastToken;       /* The last token parsed */\n  ynVar nVar;               /* Number of '?' variables seen in the SQL so far */\n  u8 iPkSortOrder;          /* ASC or DESC for INTEGER PRIMARY KEY */\n  u8 explain;               /* True if the EXPLAIN flag is found on the query */\n#if !(defined(SQLITE_OMIT_VIRTUALTABLE) && defined(SQLITE_OMIT_ALTERTABLE))\n  u8 eParseMode;            /* PARSE_MODE_XXX constant */\n#endif\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n  int nVtabLock;            /* Number of virtual tables to lock */\n#endif\n  int nHeight;              /* Expression tree height of current sub-select */\n#ifndef SQLITE_OMIT_EXPLAIN\n  int addrExplain;          /* Address of current OP_Explain opcode */\n#endif\n  VList *pVList;            /* Mapping between variable names and numbers */\n  Vdbe *pReprepare;         /* VM being reprepared (sqlite3Reprepare()) */\n  const char *zTail;        /* All SQL text past the last semicolon parsed */\n  Table *pNewTable;         /* A table being constructed by CREATE TABLE */\n  Index *pNewIndex;         /* An index being constructed by CREATE INDEX.\n                            ** Also used to hold redundant UNIQUE constraints\n                            ** during a RENAME COLUMN */\n  Trigger *pNewTrigger;     /* Trigger under construct by a CREATE TRIGGER */\n  const char *zAuthContext; /* The 6th parameter to db->xAuth callbacks */\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n  Token sArg;               /* Complete text of a module argument */\n  Table **apVtabLock;       /* Pointer to virtual tables needing locking */\n#endif\n  Table *pZombieTab;        /* List of Table objects to delete after code gen */\n  TriggerPrg *pTriggerPrg;  /* Linked list of coded triggers */\n  With *pWith;              /* Current WITH clause, or NULL */\n  With *pWithToFree;        /* Free this WITH object at the end of the parse */\n#ifndef SQLITE_OMIT_ALTERTABLE\n  RenameToken *pRename;     /* Tokens subject to renaming by ALTER TABLE */\n#endif\n};\n\n#define PARSE_MODE_NORMAL        0\n#define PARSE_MODE_DECLARE_VTAB  1\n#define PARSE_MODE_RENAME        2\n#define PARSE_MODE_UNMAP         3\n\n/*\n** Sizes and pointers of various parts of the Parse object.\n*/\n#define PARSE_HDR_SZ offsetof(Parse,aTempReg) /* Recursive part w/o aColCache*/\n#define PARSE_RECURSE_SZ offsetof(Parse,sLastToken)    /* Recursive part */\n#define PARSE_TAIL_SZ (sizeof(Parse)-PARSE_RECURSE_SZ) /* Non-recursive part */\n#define PARSE_TAIL(X) (((char*)(X))+PARSE_RECURSE_SZ)  /* Pointer to tail */\n\n/*\n** Return true if currently inside an sqlite3_declare_vtab() call.\n*/\n#ifdef SQLITE_OMIT_VIRTUALTABLE\n  #define IN_DECLARE_VTAB 0\n#else\n  #define IN_DECLARE_VTAB (pParse->eParseMode==PARSE_MODE_DECLARE_VTAB)\n#endif\n\n#if defined(SQLITE_OMIT_ALTERTABLE)\n  #define IN_RENAME_OBJECT 0\n#else\n  #define IN_RENAME_OBJECT (pParse->eParseMode>=PARSE_MODE_RENAME)\n#endif\n\n#if defined(SQLITE_OMIT_VIRTUALTABLE) && defined(SQLITE_OMIT_ALTERTABLE)\n  #define IN_SPECIAL_PARSE 0\n#else\n  #define IN_SPECIAL_PARSE (pParse->eParseMode!=PARSE_MODE_NORMAL)\n#endif\n\n/*\n** An instance of the following structure can be declared on a stack and used\n** to save the Parse.zAuthContext value so that it can be restored later.\n*/\nstruct AuthContext {\n  const char *zAuthContext;   /* Put saved Parse.zAuthContext here */\n  Parse *pParse;              /* The Parse structure */\n};\n\n/*\n** Bitfield flags for P5 value in various opcodes.\n**\n** Value constraints (enforced via assert()):\n**    OPFLAG_LENGTHARG    == SQLITE_FUNC_LENGTH\n**    OPFLAG_TYPEOFARG    == SQLITE_FUNC_TYPEOF\n**    OPFLAG_BULKCSR      == BTREE_BULKLOAD\n**    OPFLAG_SEEKEQ       == BTREE_SEEK_EQ\n**    OPFLAG_FORDELETE    == BTREE_FORDELETE\n**    OPFLAG_SAVEPOSITION == BTREE_SAVEPOSITION\n**    OPFLAG_AUXDELETE    == BTREE_AUXDELETE\n*/\n#define OPFLAG_NCHANGE       0x01    /* OP_Insert: Set to update db->nChange */\n                                     /* Also used in P2 (not P5) of OP_Delete */\n#define OPFLAG_NOCHNG        0x01    /* OP_VColumn nochange for UPDATE */\n#define OPFLAG_EPHEM         0x01    /* OP_Column: Ephemeral output is ok */\n#define OPFLAG_LASTROWID     0x20    /* Set to update db->lastRowid */\n#define OPFLAG_ISUPDATE      0x04    /* This OP_Insert is an sql UPDATE */\n#define OPFLAG_APPEND        0x08    /* This is likely to be an append */\n#define OPFLAG_USESEEKRESULT 0x10    /* Try to avoid a seek in BtreeInsert() */\n#define OPFLAG_ISNOOP        0x40    /* OP_Delete does pre-update-hook only */\n#define OPFLAG_LENGTHARG     0x40    /* OP_Column only used for length() */\n#define OPFLAG_TYPEOFARG     0x80    /* OP_Column only used for typeof() */\n#define OPFLAG_BULKCSR       0x01    /* OP_Open** used to open bulk cursor */\n#define OPFLAG_SEEKEQ        0x02    /* OP_Open** cursor uses EQ seek only */\n#define OPFLAG_FORDELETE     0x08    /* OP_Open should use BTREE_FORDELETE */\n#define OPFLAG_P2ISREG       0x10    /* P2 to OP_Open** is a register number */\n#define OPFLAG_PERMUTE       0x01    /* OP_Compare: use the permutation */\n#define OPFLAG_SAVEPOSITION  0x02    /* OP_Delete/Insert: save cursor pos */\n#define OPFLAG_AUXDELETE     0x04    /* OP_Delete: index in a DELETE op */\n#define OPFLAG_NOCHNG_MAGIC  0x6d    /* OP_MakeRecord: serialtype 10 is ok */\n\n/*\n * Each trigger present in the database schema is stored as an instance of\n * struct Trigger.\n *\n * Pointers to instances of struct Trigger are stored in two ways.\n * 1. In the \"trigHash\" hash table (part of the sqlite3* that represents the\n *    database). This allows Trigger structures to be retrieved by name.\n * 2. All triggers associated with a single table form a linked list, using the\n *    pNext member of struct Trigger. A pointer to the first element of the\n *    linked list is stored as the \"pTrigger\" member of the associated\n *    struct Table.\n *\n * The \"step_list\" member points to the first element of a linked list\n * containing the SQL statements specified as the trigger program.\n */\nstruct Trigger {\n  char *zName;            /* The name of the trigger                        */\n  char *table;            /* The table or view to which the trigger applies */\n  u8 op;                  /* One of TK_DELETE, TK_UPDATE, TK_INSERT         */\n  u8 tr_tm;               /* One of TRIGGER_BEFORE, TRIGGER_AFTER */\n  Expr *pWhen;            /* The WHEN clause of the expression (may be NULL) */\n  IdList *pColumns;       /* If this is an UPDATE OF <column-list> trigger,\n                             the <column-list> is stored here */\n  Schema *pSchema;        /* Schema containing the trigger */\n  Schema *pTabSchema;     /* Schema containing the table */\n  TriggerStep *step_list; /* Link list of trigger program steps             */\n  Trigger *pNext;         /* Next trigger associated with the table */\n};\n\n/*\n** A trigger is either a BEFORE or an AFTER trigger.  The following constants\n** determine which.\n**\n** If there are multiple triggers, you might of some BEFORE and some AFTER.\n** In that cases, the constants below can be ORed together.\n*/\n#define TRIGGER_BEFORE  1\n#define TRIGGER_AFTER   2\n\n/*\n * An instance of struct TriggerStep is used to store a single SQL statement\n * that is a part of a trigger-program.\n *\n * Instances of struct TriggerStep are stored in a singly linked list (linked\n * using the \"pNext\" member) referenced by the \"step_list\" member of the\n * associated struct Trigger instance. The first element of the linked list is\n * the first step of the trigger-program.\n *\n * The \"op\" member indicates whether this is a \"DELETE\", \"INSERT\", \"UPDATE\" or\n * \"SELECT\" statement. The meanings of the other members is determined by the\n * value of \"op\" as follows:\n *\n * (op == TK_INSERT)\n * orconf    -> stores the ON CONFLICT algorithm\n * pSelect   -> If this is an INSERT INTO ... SELECT ... statement, then\n *              this stores a pointer to the SELECT statement. Otherwise NULL.\n * zTarget   -> Dequoted name of the table to insert into.\n * pExprList -> If this is an INSERT INTO ... VALUES ... statement, then\n *              this stores values to be inserted. Otherwise NULL.\n * pIdList   -> If this is an INSERT INTO ... (<column-names>) VALUES ...\n *              statement, then this stores the column-names to be\n *              inserted into.\n *\n * (op == TK_DELETE)\n * zTarget   -> Dequoted name of the table to delete from.\n * pWhere    -> The WHERE clause of the DELETE statement if one is specified.\n *              Otherwise NULL.\n *\n * (op == TK_UPDATE)\n * zTarget   -> Dequoted name of the table to update.\n * pWhere    -> The WHERE clause of the UPDATE statement if one is specified.\n *              Otherwise NULL.\n * pExprList -> A list of the columns to update and the expressions to update\n *              them to. See sqlite3Update() documentation of \"pChanges\"\n *              argument.\n *\n */\nstruct TriggerStep {\n  u8 op;               /* One of TK_DELETE, TK_UPDATE, TK_INSERT, TK_SELECT */\n  u8 orconf;           /* OE_Rollback etc. */\n  Trigger *pTrig;      /* The trigger that this step is a part of */\n  Select *pSelect;     /* SELECT statement or RHS of INSERT INTO SELECT ... */\n  char *zTarget;       /* Target table for DELETE, UPDATE, INSERT */\n  Expr *pWhere;        /* The WHERE clause for DELETE or UPDATE steps */\n  ExprList *pExprList; /* SET clause for UPDATE */\n  IdList *pIdList;     /* Column names for INSERT */\n  Upsert *pUpsert;     /* Upsert clauses on an INSERT */\n  char *zSpan;         /* Original SQL text of this command */\n  TriggerStep *pNext;  /* Next in the link-list */\n  TriggerStep *pLast;  /* Last element in link-list. Valid for 1st elem only */\n};\n\n/*\n** The following structure contains information used by the sqliteFix...\n** routines as they walk the parse tree to make database references\n** explicit.\n*/\ntypedef struct DbFixer DbFixer;\nstruct DbFixer {\n  Parse *pParse;      /* The parsing context.  Error messages written here */\n  Schema *pSchema;    /* Fix items to this schema */\n  int bVarOnly;       /* Check for variable references only */\n  const char *zDb;    /* Make sure all objects are contained in this database */\n  const char *zType;  /* Type of the container - used for error messages */\n  const Token *pName; /* Name of the container - used for error messages */\n};\n\n/*\n** An objected used to accumulate the text of a string where we\n** do not necessarily know how big the string will be in the end.\n*/\nstruct sqlite3_str {\n  sqlite3 *db;         /* Optional database for lookaside.  Can be NULL */\n  char *zText;         /* The string collected so far */\n  u32  nAlloc;         /* Amount of space allocated in zText */\n  u32  mxAlloc;        /* Maximum allowed allocation.  0 for no malloc usage */\n  u32  nChar;          /* Length of the string so far */\n  u8   accError;       /* SQLITE_NOMEM or SQLITE_TOOBIG */\n  u8   printfFlags;    /* SQLITE_PRINTF flags below */\n};\n#define SQLITE_PRINTF_INTERNAL 0x01  /* Internal-use-only converters allowed */\n#define SQLITE_PRINTF_SQLFUNC  0x02  /* SQL function arguments to VXPrintf */\n#define SQLITE_PRINTF_MALLOCED 0x04  /* True if xText is allocated space */\n\n#define isMalloced(X)  (((X)->printfFlags & SQLITE_PRINTF_MALLOCED)!=0)\n\n\n/*\n** A pointer to this structure is used to communicate information\n** from sqlite3Init and OP_ParseSchema into the sqlite3InitCallback.\n*/\ntypedef struct {\n  sqlite3 *db;        /* The database being initialized */\n  char **pzErrMsg;    /* Error message stored here */\n  int iDb;            /* 0 for main database.  1 for TEMP, 2.. for ATTACHed */\n  int rc;             /* Result code stored here */\n  u32 mInitFlags;     /* Flags controlling error messages */\n  u32 nInitRow;       /* Number of rows processed */\n} InitData;\n\n/*\n** Allowed values for mInitFlags\n*/\n#define INITFLAG_AlterTable   0x0001  /* This is a reparse after ALTER TABLE */\n\n/*\n** Structure containing global configuration data for the SQLite library.\n**\n** This structure also contains some state information.\n*/\nstruct Sqlite3Config {\n  int bMemstat;                     /* True to enable memory status */\n  u8 bCoreMutex;                    /* True to enable core mutexing */\n  u8 bFullMutex;                    /* True to enable full mutexing */\n  u8 bOpenUri;                      /* True to interpret filenames as URIs */\n  u8 bUseCis;                       /* Use covering indices for full-scans */\n  u8 bSmallMalloc;                  /* Avoid large memory allocations if true */\n  u8 bExtraSchemaChecks;            /* Verify type,name,tbl_name in schema */\n  int mxStrlen;                     /* Maximum string length */\n  int neverCorrupt;                 /* Database is always well-formed */\n  int szLookaside;                  /* Default lookaside buffer size */\n  int nLookaside;                   /* Default lookaside buffer count */\n  int nStmtSpill;                   /* Stmt-journal spill-to-disk threshold */\n  sqlite3_mem_methods m;            /* Low-level memory allocation interface */\n  sqlite3_mutex_methods mutex;      /* Low-level mutex interface */\n  sqlite3_pcache_methods2 pcache2;  /* Low-level page-cache interface */\n  void *pHeap;                      /* Heap storage space */\n  int nHeap;                        /* Size of pHeap[] */\n  int mnReq, mxReq;                 /* Min and max heap requests sizes */\n  sqlite3_int64 szMmap;             /* mmap() space per open file */\n  sqlite3_int64 mxMmap;             /* Maximum value for szMmap */\n  void *pPage;                      /* Page cache memory */\n  int szPage;                       /* Size of each page in pPage[] */\n  int nPage;                        /* Number of pages in pPage[] */\n  int mxParserStack;                /* maximum depth of the parser stack */\n  int sharedCacheEnabled;           /* true if shared-cache mode enabled */\n  u32 szPma;                        /* Maximum Sorter PMA size */\n  /* The above might be initialized to non-zero.  The following need to always\n  ** initially be zero, however. */\n  int isInit;                       /* True after initialization has finished */\n  int inProgress;                   /* True while initialization in progress */\n  int isMutexInit;                  /* True after mutexes are initialized */\n  int isMallocInit;                 /* True after malloc is initialized */\n  int isPCacheInit;                 /* True after malloc is initialized */\n  int nRefInitMutex;                /* Number of users of pInitMutex */\n  sqlite3_mutex *pInitMutex;        /* Mutex used by sqlite3_initialize() */\n  void (*xLog)(void*,int,const char*); /* Function for logging */\n  void *pLogArg;                       /* First argument to xLog() */\n#ifdef SQLITE_ENABLE_SQLLOG\n  void(*xSqllog)(void*,sqlite3*,const char*, int);\n  void *pSqllogArg;\n#endif\n#ifdef SQLITE_VDBE_COVERAGE\n  /* The following callback (if not NULL) is invoked on every VDBE branch\n  ** operation.  Set the callback using SQLITE_TESTCTRL_VDBE_COVERAGE.\n  */\n  void (*xVdbeBranch)(void*,unsigned iSrcLine,u8 eThis,u8 eMx);  /* Callback */\n  void *pVdbeBranchArg;                                     /* 1st argument */\n#endif\n#ifdef SQLITE_ENABLE_DESERIALIZE\n  sqlite3_int64 mxMemdbSize;        /* Default max memdb size */\n#endif\n#ifndef SQLITE_UNTESTABLE\n  int (*xTestCallback)(int);        /* Invoked by sqlite3FaultSim() */\n#endif\n  int bLocaltimeFault;              /* True to fail localtime() calls */\n  int bInternalFunctions;           /* Internal SQL functions are visible */\n  int iOnceResetThreshold;          /* When to reset OP_Once counters */\n  u32 szSorterRef;                  /* Min size in bytes to use sorter-refs */\n  unsigned int iPrngSeed;           /* Alternative fixed seed for the PRNG */\n};\n\n/*\n** This macro is used inside of assert() statements to indicate that\n** the assert is only valid on a well-formed database.  Instead of:\n**\n**     assert( X );\n**\n** One writes:\n**\n**     assert( X || CORRUPT_DB );\n**\n** CORRUPT_DB is true during normal operation.  CORRUPT_DB does not indicate\n** that the database is definitely corrupt, only that it might be corrupt.\n** For most test cases, CORRUPT_DB is set to false using a special\n** sqlite3_test_control().  This enables assert() statements to prove\n** things that are always true for well-formed databases.\n*/\n#define CORRUPT_DB  (sqlite3Config.neverCorrupt==0)\n\n/*\n** Context pointer passed down through the tree-walk.\n*/\nstruct Walker {\n  Parse *pParse;                            /* Parser context.  */\n  int (*xExprCallback)(Walker*, Expr*);     /* Callback for expressions */\n  int (*xSelectCallback)(Walker*,Select*);  /* Callback for SELECTs */\n  void (*xSelectCallback2)(Walker*,Select*);/* Second callback for SELECTs */\n  int walkerDepth;                          /* Number of subqueries */\n  u16 eCode;                                /* A small processing code */\n  union {                                   /* Extra data for callback */\n    NameContext *pNC;                         /* Naming context */\n    int n;                                    /* A counter */\n    int iCur;                                 /* A cursor number */\n    SrcList *pSrcList;                        /* FROM clause */\n    struct SrcCount *pSrcCount;               /* Counting column references */\n    struct CCurHint *pCCurHint;               /* Used by codeCursorHint() */\n    int *aiCol;                               /* array of column indexes */\n    struct IdxCover *pIdxCover;               /* Check for index coverage */\n    struct IdxExprTrans *pIdxTrans;           /* Convert idxed expr to column */\n    ExprList *pGroupBy;                       /* GROUP BY clause */\n    Select *pSelect;                          /* HAVING to WHERE clause ctx */\n    struct WindowRewrite *pRewrite;           /* Window rewrite context */\n    struct WhereConst *pConst;                /* WHERE clause constants */\n    struct RenameCtx *pRename;                /* RENAME COLUMN context */\n    struct Table *pTab;                       /* Table of generated column */\n  } u;\n};\n\n/* Forward declarations */\nint sqlite3WalkExpr(Walker*, Expr*);\nint sqlite3WalkExprList(Walker*, ExprList*);\nint sqlite3WalkSelect(Walker*, Select*);\nint sqlite3WalkSelectExpr(Walker*, Select*);\nint sqlite3WalkSelectFrom(Walker*, Select*);\nint sqlite3ExprWalkNoop(Walker*, Expr*);\nint sqlite3SelectWalkNoop(Walker*, Select*);\nint sqlite3SelectWalkFail(Walker*, Select*);\n#ifdef SQLITE_DEBUG\nvoid sqlite3SelectWalkAssert2(Walker*, Select*);\n#endif\n\n/*\n** Return code from the parse-tree walking primitives and their\n** callbacks.\n*/\n#define WRC_Continue    0   /* Continue down into children */\n#define WRC_Prune       1   /* Omit children but continue walking siblings */\n#define WRC_Abort       2   /* Abandon the tree walk */\n\n/*\n** An instance of this structure represents a set of one or more CTEs\n** (common table expressions) created by a single WITH clause.\n*/\nstruct With {\n  int nCte;                       /* Number of CTEs in the WITH clause */\n  With *pOuter;                   /* Containing WITH clause, or NULL */\n  struct Cte {                    /* For each CTE in the WITH clause.... */\n    char *zName;                    /* Name of this CTE */\n    ExprList *pCols;                /* List of explicit column names, or NULL */\n    Select *pSelect;                /* The definition of this CTE */\n    const char *zCteErr;            /* Error message for circular references */\n  } a[1];\n};\n\n#ifdef SQLITE_DEBUG\n/*\n** An instance of the TreeView object is used for printing the content of\n** data structures on sqlite3DebugPrintf() using a tree-like view.\n*/\nstruct TreeView {\n  int iLevel;             /* Which level of the tree we are on */\n  u8  bLine[100];         /* Draw vertical in column i if bLine[i] is true */\n};\n#endif /* SQLITE_DEBUG */\n\n/*\n** This object is used in various ways, most (but not all) related to window\n** functions.\n**\n**   (1) A single instance of this structure is attached to the\n**       the Expr.y.pWin field for each window function in an expression tree.\n**       This object holds the information contained in the OVER clause,\n**       plus additional fields used during code generation.\n**\n**   (2) All window functions in a single SELECT form a linked-list\n**       attached to Select.pWin.  The Window.pFunc and Window.pExpr\n**       fields point back to the expression that is the window function.\n**\n**   (3) The terms of the WINDOW clause of a SELECT are instances of this\n**       object on a linked list attached to Select.pWinDefn.\n**\n**   (4) For an aggregate function with a FILTER clause, an instance\n**       of this object is stored in Expr.y.pWin with eFrmType set to\n**       TK_FILTER. In this case the only field used is Window.pFilter.\n**\n** The uses (1) and (2) are really the same Window object that just happens\n** to be accessible in two different ways.  Use case (3) are separate objects.\n*/\nstruct Window {\n  char *zName;            /* Name of window (may be NULL) */\n  char *zBase;            /* Name of base window for chaining (may be NULL) */\n  ExprList *pPartition;   /* PARTITION BY clause */\n  ExprList *pOrderBy;     /* ORDER BY clause */\n  u8 eFrmType;            /* TK_RANGE, TK_GROUPS, TK_ROWS, or 0 */\n  u8 eStart;              /* UNBOUNDED, CURRENT, PRECEDING or FOLLOWING */\n  u8 eEnd;                /* UNBOUNDED, CURRENT, PRECEDING or FOLLOWING */\n  u8 bImplicitFrame;      /* True if frame was implicitly specified */\n  u8 eExclude;            /* TK_NO, TK_CURRENT, TK_TIES, TK_GROUP, or 0 */\n  Expr *pStart;           /* Expression for \"<expr> PRECEDING\" */\n  Expr *pEnd;             /* Expression for \"<expr> FOLLOWING\" */\n  Window **ppThis;        /* Pointer to this object in Select.pWin list */\n  Window *pNextWin;       /* Next window function belonging to this SELECT */\n  Expr *pFilter;          /* The FILTER expression */\n  FuncDef *pFunc;         /* The function */\n  int iEphCsr;            /* Partition buffer or Peer buffer */\n  int regAccum;           /* Accumulator */\n  int regResult;          /* Interim result */\n  int csrApp;             /* Function cursor (used by min/max) */\n  int regApp;             /* Function register (also used by min/max) */\n  int regPart;            /* Array of registers for PARTITION BY values */\n  Expr *pOwner;           /* Expression object this window is attached to */\n  int nBufferCol;         /* Number of columns in buffer table */\n  int iArgCol;            /* Offset of first argument for this function */\n  int regOne;             /* Register containing constant value 1 */\n  int regStartRowid;\n  int regEndRowid;\n  u8 bExprArgs;           /* Defer evaluation of window function arguments\n                          ** due to the SQLITE_SUBTYPE flag */\n};\n\n#ifndef SQLITE_OMIT_WINDOWFUNC\nvoid sqlite3WindowDelete(sqlite3*, Window*);\nvoid sqlite3WindowUnlinkFromSelect(Window*);\nvoid sqlite3WindowListDelete(sqlite3 *db, Window *p);\nWindow *sqlite3WindowAlloc(Parse*, int, int, Expr*, int , Expr*, u8);\nvoid sqlite3WindowAttach(Parse*, Expr*, Window*);\nvoid sqlite3WindowLink(Select *pSel, Window *pWin);\nint sqlite3WindowCompare(Parse*, Window*, Window*, int);\nvoid sqlite3WindowCodeInit(Parse*, Window*);\nvoid sqlite3WindowCodeStep(Parse*, Select*, WhereInfo*, int, int);\nint sqlite3WindowRewrite(Parse*, Select*);\nint sqlite3ExpandSubquery(Parse*, struct SrcList_item*);\nvoid sqlite3WindowUpdate(Parse*, Window*, Window*, FuncDef*);\nWindow *sqlite3WindowDup(sqlite3 *db, Expr *pOwner, Window *p);\nWindow *sqlite3WindowListDup(sqlite3 *db, Window *p);\nvoid sqlite3WindowFunctions(void);\nvoid sqlite3WindowChain(Parse*, Window*, Window*);\nWindow *sqlite3WindowAssemble(Parse*, Window*, ExprList*, ExprList*, Token*);\n#else\n# define sqlite3WindowDelete(a,b)\n# define sqlite3WindowFunctions()\n# define sqlite3WindowAttach(a,b,c)\n#endif\n\n/*\n** Assuming zIn points to the first byte of a UTF-8 character,\n** advance zIn to point to the first byte of the next UTF-8 character.\n*/\n#define SQLITE_SKIP_UTF8(zIn) {                        \\\n  if( (*(zIn++))>=0xc0 ){                              \\\n    while( (*zIn & 0xc0)==0x80 ){ zIn++; }             \\\n  }                                                    \\\n}\n\n/*\n** The SQLITE_*_BKPT macros are substitutes for the error codes with\n** the same name but without the _BKPT suffix.  These macros invoke\n** routines that report the line-number on which the error originated\n** using sqlite3_log().  The routines also provide a convenient place\n** to set a debugger breakpoint.\n*/\nint sqlite3ReportError(int iErr, int lineno, const char *zType);\nint sqlite3CorruptError(int);\nint sqlite3MisuseError(int);\nint sqlite3CantopenError(int);\n#define SQLITE_CORRUPT_BKPT sqlite3CorruptError(__LINE__)\n#define SQLITE_MISUSE_BKPT sqlite3MisuseError(__LINE__)\n#define SQLITE_CANTOPEN_BKPT sqlite3CantopenError(__LINE__)\n#ifdef SQLITE_DEBUG\n  int sqlite3NomemError(int);\n  int sqlite3IoerrnomemError(int);\n  int sqlite3CorruptPgnoError(int,Pgno);\n# define SQLITE_NOMEM_BKPT sqlite3NomemError(__LINE__)\n# define SQLITE_IOERR_NOMEM_BKPT sqlite3IoerrnomemError(__LINE__)\n# define SQLITE_CORRUPT_PGNO(P) sqlite3CorruptPgnoError(__LINE__,(P))\n#else\n# define SQLITE_NOMEM_BKPT SQLITE_NOMEM\n# define SQLITE_IOERR_NOMEM_BKPT SQLITE_IOERR_NOMEM\n# define SQLITE_CORRUPT_PGNO(P) sqlite3CorruptError(__LINE__)\n#endif\n\n/*\n** FTS3 and FTS4 both require virtual table support\n*/\n#if defined(SQLITE_OMIT_VIRTUALTABLE)\n# undef SQLITE_ENABLE_FTS3\n# undef SQLITE_ENABLE_FTS4\n#endif\n\n/*\n** FTS4 is really an extension for FTS3.  It is enabled using the\n** SQLITE_ENABLE_FTS3 macro.  But to avoid confusion we also call\n** the SQLITE_ENABLE_FTS4 macro to serve as an alias for SQLITE_ENABLE_FTS3.\n*/\n#if defined(SQLITE_ENABLE_FTS4) && !defined(SQLITE_ENABLE_FTS3)\n# define SQLITE_ENABLE_FTS3 1\n#endif\n\n/*\n** The ctype.h header is needed for non-ASCII systems.  It is also\n** needed by FTS3 when FTS3 is included in the amalgamation.\n*/\n#if !defined(SQLITE_ASCII) || \\\n    (defined(SQLITE_ENABLE_FTS3) && defined(SQLITE_AMALGAMATION))\n# include <ctype.h>\n#endif\n\n/*\n** The following macros mimic the standard library functions toupper(),\n** isspace(), isalnum(), isdigit() and isxdigit(), respectively. The\n** sqlite versions only work for ASCII characters, regardless of locale.\n*/\n#ifdef SQLITE_ASCII\n# define sqlite3Toupper(x)  ((x)&~(sqlite3CtypeMap[(unsigned char)(x)]&0x20))\n# define sqlite3Isspace(x)   (sqlite3CtypeMap[(unsigned char)(x)]&0x01)\n# define sqlite3Isalnum(x)   (sqlite3CtypeMap[(unsigned char)(x)]&0x06)\n# define sqlite3Isalpha(x)   (sqlite3CtypeMap[(unsigned char)(x)]&0x02)\n# define sqlite3Isdigit(x)   (sqlite3CtypeMap[(unsigned char)(x)]&0x04)\n# define sqlite3Isxdigit(x)  (sqlite3CtypeMap[(unsigned char)(x)]&0x08)\n# define sqlite3Tolower(x)   (sqlite3UpperToLower[(unsigned char)(x)])\n# define sqlite3Isquote(x)   (sqlite3CtypeMap[(unsigned char)(x)]&0x80)\n#else\n# define sqlite3Toupper(x)   toupper((unsigned char)(x))\n# define sqlite3Isspace(x)   isspace((unsigned char)(x))\n# define sqlite3Isalnum(x)   isalnum((unsigned char)(x))\n# define sqlite3Isalpha(x)   isalpha((unsigned char)(x))\n# define sqlite3Isdigit(x)   isdigit((unsigned char)(x))\n# define sqlite3Isxdigit(x)  isxdigit((unsigned char)(x))\n# define sqlite3Tolower(x)   tolower((unsigned char)(x))\n# define sqlite3Isquote(x)   ((x)=='\"'||(x)=='\\''||(x)=='['||(x)=='`')\n#endif\nint sqlite3IsIdChar(u8);\n\n/*\n** Internal function prototypes\n*/\nint sqlite3StrICmp(const char*,const char*);\nint sqlite3Strlen30(const char*);\n#define sqlite3Strlen30NN(C) (strlen(C)&0x3fffffff)\nchar *sqlite3ColumnType(Column*,char*);\n#define sqlite3StrNICmp sqlite3_strnicmp\n\nint sqlite3MallocInit(void);\nvoid sqlite3MallocEnd(void);\nvoid *sqlite3Malloc(u64);\nvoid *sqlite3MallocZero(u64);\nvoid *sqlite3DbMallocZero(sqlite3*, u64);\nvoid *sqlite3DbMallocRaw(sqlite3*, u64);\nvoid *sqlite3DbMallocRawNN(sqlite3*, u64);\nchar *sqlite3DbStrDup(sqlite3*,const char*);\nchar *sqlite3DbStrNDup(sqlite3*,const char*, u64);\nchar *sqlite3DbSpanDup(sqlite3*,const char*,const char*);\nvoid *sqlite3Realloc(void*, u64);\nvoid *sqlite3DbReallocOrFree(sqlite3 *, void *, u64);\nvoid *sqlite3DbRealloc(sqlite3 *, void *, u64);\nvoid sqlite3DbFree(sqlite3*, void*);\nvoid sqlite3DbFreeNN(sqlite3*, void*);\nint sqlite3MallocSize(void*);\nint sqlite3DbMallocSize(sqlite3*, void*);\nvoid *sqlite3PageMalloc(int);\nvoid sqlite3PageFree(void*);\nvoid sqlite3MemSetDefault(void);\n#ifndef SQLITE_UNTESTABLE\nvoid sqlite3BenignMallocHooks(void (*)(void), void (*)(void));\n#endif\nint sqlite3HeapNearlyFull(void);\n\n/*\n** On systems with ample stack space and that support alloca(), make\n** use of alloca() to obtain space for large automatic objects.  By default,\n** obtain space from malloc().\n**\n** The alloca() routine never returns NULL.  This will cause code paths\n** that deal with sqlite3StackAlloc() failures to be unreachable.\n*/\n#ifdef SQLITE_USE_ALLOCA\n# define sqlite3StackAllocRaw(D,N)   alloca(N)\n# define sqlite3StackAllocZero(D,N)  memset(alloca(N), 0, N)\n# define sqlite3StackFree(D,P)\n#else\n# define sqlite3StackAllocRaw(D,N)   sqlite3DbMallocRaw(D,N)\n# define sqlite3StackAllocZero(D,N)  sqlite3DbMallocZero(D,N)\n# define sqlite3StackFree(D,P)       sqlite3DbFree(D,P)\n#endif\n\n/* Do not allow both MEMSYS5 and MEMSYS3 to be defined together.  If they\n** are, disable MEMSYS3\n*/\n#ifdef SQLITE_ENABLE_MEMSYS5\nconst sqlite3_mem_methods *sqlite3MemGetMemsys5(void);\n#undef SQLITE_ENABLE_MEMSYS3\n#endif\n#ifdef SQLITE_ENABLE_MEMSYS3\nconst sqlite3_mem_methods *sqlite3MemGetMemsys3(void);\n#endif\n\n\n#ifndef SQLITE_MUTEX_OMIT\n  sqlite3_mutex_methods const *sqlite3DefaultMutex(void);\n  sqlite3_mutex_methods const *sqlite3NoopMutex(void);\n  sqlite3_mutex *sqlite3MutexAlloc(int);\n  int sqlite3MutexInit(void);\n  int sqlite3MutexEnd(void);\n#endif\n#if !defined(SQLITE_MUTEX_OMIT) && !defined(SQLITE_MUTEX_NOOP)\n  void sqlite3MemoryBarrier(void);\n#else\n# define sqlite3MemoryBarrier()\n#endif\n\nsqlite3_int64 sqlite3StatusValue(int);\nvoid sqlite3StatusUp(int, int);\nvoid sqlite3StatusDown(int, int);\nvoid sqlite3StatusHighwater(int, int);\nint sqlite3LookasideUsed(sqlite3*,int*);\n\n/* Access to mutexes used by sqlite3_status() */\nsqlite3_mutex *sqlite3Pcache1Mutex(void);\nsqlite3_mutex *sqlite3MallocMutex(void);\n\n#if defined(SQLITE_ENABLE_MULTITHREADED_CHECKS) && !defined(SQLITE_MUTEX_OMIT)\nvoid sqlite3MutexWarnOnContention(sqlite3_mutex*);\n#else\n# define sqlite3MutexWarnOnContention(x)\n#endif\n\n#ifndef SQLITE_OMIT_FLOATING_POINT\n# define EXP754 (((u64)0x7ff)<<52)\n# define MAN754 ((((u64)1)<<52)-1)\n# define IsNaN(X) (((X)&EXP754)==EXP754 && ((X)&MAN754)!=0)\n  int sqlite3IsNaN(double);\n#else\n# define IsNaN(X)         0\n# define sqlite3IsNaN(X)  0\n#endif\n\n/*\n** An instance of the following structure holds information about SQL\n** functions arguments that are the parameters to the printf() function.\n*/\nstruct PrintfArguments {\n  int nArg;                /* Total number of arguments */\n  int nUsed;               /* Number of arguments used so far */\n  sqlite3_value **apArg;   /* The argument values */\n};\n\nchar *sqlite3MPrintf(sqlite3*,const char*, ...);\nchar *sqlite3VMPrintf(sqlite3*,const char*, va_list);\n#if defined(SQLITE_DEBUG) || defined(SQLITE_HAVE_OS_TRACE)\n  void sqlite3DebugPrintf(const char*, ...);\n#endif\n#if defined(SQLITE_TEST)\n  void *sqlite3TestTextToPtr(const char*);\n#endif\n\n#if defined(SQLITE_DEBUG)\n  void sqlite3TreeViewExpr(TreeView*, const Expr*, u8);\n  void sqlite3TreeViewBareExprList(TreeView*, const ExprList*, const char*);\n  void sqlite3TreeViewExprList(TreeView*, const ExprList*, u8, const char*);\n  void sqlite3TreeViewSrcList(TreeView*, const SrcList*);\n  void sqlite3TreeViewSelect(TreeView*, const Select*, u8);\n  void sqlite3TreeViewWith(TreeView*, const With*, u8);\n#ifndef SQLITE_OMIT_WINDOWFUNC\n  void sqlite3TreeViewWindow(TreeView*, const Window*, u8);\n  void sqlite3TreeViewWinFunc(TreeView*, const Window*, u8);\n#endif\n#endif\n\n\nvoid sqlite3SetString(char **, sqlite3*, const char*);\nvoid sqlite3ErrorMsg(Parse*, const char*, ...);\nint sqlite3ErrorToParser(sqlite3*,int);\nvoid sqlite3Dequote(char*);\nvoid sqlite3DequoteExpr(Expr*);\nvoid sqlite3TokenInit(Token*,char*);\nint sqlite3KeywordCode(const unsigned char*, int);\nint sqlite3RunParser(Parse*, const char*, char **);\nvoid sqlite3FinishCoding(Parse*);\nint sqlite3GetTempReg(Parse*);\nvoid sqlite3ReleaseTempReg(Parse*,int);\nint sqlite3GetTempRange(Parse*,int);\nvoid sqlite3ReleaseTempRange(Parse*,int,int);\nvoid sqlite3ClearTempRegCache(Parse*);\n#ifdef SQLITE_DEBUG\nint sqlite3NoTempsInRange(Parse*,int,int);\n#endif\nExpr *sqlite3ExprAlloc(sqlite3*,int,const Token*,int);\nExpr *sqlite3Expr(sqlite3*,int,const char*);\nvoid sqlite3ExprAttachSubtrees(sqlite3*,Expr*,Expr*,Expr*);\nExpr *sqlite3PExpr(Parse*, int, Expr*, Expr*);\nvoid sqlite3PExprAddSelect(Parse*, Expr*, Select*);\nExpr *sqlite3ExprAnd(Parse*,Expr*, Expr*);\nExpr *sqlite3ExprSimplifiedAndOr(Expr*);\nExpr *sqlite3ExprFunction(Parse*,ExprList*, Token*, int);\nvoid sqlite3ExprAssignVarNumber(Parse*, Expr*, u32);\nvoid sqlite3ExprDelete(sqlite3*, Expr*);\nvoid sqlite3ExprUnmapAndDelete(Parse*, Expr*);\nExprList *sqlite3ExprListAppend(Parse*,ExprList*,Expr*);\nExprList *sqlite3ExprListAppendVector(Parse*,ExprList*,IdList*,Expr*);\nvoid sqlite3ExprListSetSortOrder(ExprList*,int,int);\nvoid sqlite3ExprListSetName(Parse*,ExprList*,Token*,int);\nvoid sqlite3ExprListSetSpan(Parse*,ExprList*,const char*,const char*);\nvoid sqlite3ExprListDelete(sqlite3*, ExprList*);\nu32 sqlite3ExprListFlags(const ExprList*);\nint sqlite3IndexHasDuplicateRootPage(Index*);\nint sqlite3Init(sqlite3*, char**);\nint sqlite3InitCallback(void*, int, char**, char**);\nint sqlite3InitOne(sqlite3*, int, char**, u32);\nvoid sqlite3Pragma(Parse*,Token*,Token*,Token*,int);\n#ifndef SQLITE_OMIT_VIRTUALTABLE\nModule *sqlite3PragmaVtabRegister(sqlite3*,const char *zName);\n#endif\nvoid sqlite3ResetAllSchemasOfConnection(sqlite3*);\nvoid sqlite3ResetOneSchema(sqlite3*,int);\nvoid sqlite3CollapseDatabaseArray(sqlite3*);\nvoid sqlite3CommitInternalChanges(sqlite3*);\nvoid sqlite3DeleteColumnNames(sqlite3*,Table*);\nint sqlite3ColumnsFromExprList(Parse*,ExprList*,i16*,Column**);\nvoid sqlite3SelectAddColumnTypeAndCollation(Parse*,Table*,Select*,char);\nTable *sqlite3ResultSetOfSelect(Parse*,Select*,char);\nvoid sqlite3OpenMasterTable(Parse *, int);\nIndex *sqlite3PrimaryKeyIndex(Table*);\ni16 sqlite3TableColumnToIndex(Index*, i16);\n#ifdef SQLITE_OMIT_GENERATED_COLUMNS\n# define sqlite3TableColumnToStorage(T,X) (X)  /* No-op pass-through */\n# define sqlite3StorageColumnToTable(T,X) (X)  /* No-op pass-through */\n#else\n  i16 sqlite3TableColumnToStorage(Table*, i16);\n  i16 sqlite3StorageColumnToTable(Table*, i16);\n#endif\nvoid sqlite3StartTable(Parse*,Token*,Token*,int,int,int,int);\n#if SQLITE_ENABLE_HIDDEN_COLUMNS\n  void sqlite3ColumnPropertiesFromName(Table*, Column*);\n#else\n# define sqlite3ColumnPropertiesFromName(T,C) /* no-op */\n#endif\nvoid sqlite3AddColumn(Parse*,Token*,Token*);\nvoid sqlite3AddNotNull(Parse*, int);\nvoid sqlite3AddPrimaryKey(Parse*, ExprList*, int, int, int);\nvoid sqlite3AddCheckConstraint(Parse*, Expr*);\nvoid sqlite3AddDefaultValue(Parse*,Expr*,const char*,const char*);\nvoid sqlite3AddCollateType(Parse*, Token*);\nvoid sqlite3AddGenerated(Parse*,Expr*,Token*);\nvoid sqlite3EndTable(Parse*,Token*,Token*,u8,Select*);\n#ifdef SQLITE_DEBUG\n  int sqlite3UriCount(const char*);\n#endif\nint sqlite3ParseUri(const char*,const char*,unsigned int*,\n                    sqlite3_vfs**,char**,char **);\n#ifdef SQLITE_HAS_CODEC\n  int sqlite3CodecQueryParameters(sqlite3*,const char*,const char*);\n#else\n# define sqlite3CodecQueryParameters(A,B,C) 0\n#endif\nBtree *sqlite3DbNameToBtree(sqlite3*,const char*);\n\n#ifdef SQLITE_UNTESTABLE\n# define sqlite3FaultSim(X) SQLITE_OK\n#else\n  int sqlite3FaultSim(int);\n#endif\n\nBitvec *sqlite3BitvecCreate(u32);\nint sqlite3BitvecTest(Bitvec*, u32);\nint sqlite3BitvecTestNotNull(Bitvec*, u32);\nint sqlite3BitvecSet(Bitvec*, u32);\nvoid sqlite3BitvecClear(Bitvec*, u32, void*);\nvoid sqlite3BitvecDestroy(Bitvec*);\nu32 sqlite3BitvecSize(Bitvec*);\n#ifndef SQLITE_UNTESTABLE\nint sqlite3BitvecBuiltinTest(int,int*);\n#endif\n\nRowSet *sqlite3RowSetInit(sqlite3*);\nvoid sqlite3RowSetDelete(void*);\nvoid sqlite3RowSetClear(void*);\nvoid sqlite3RowSetInsert(RowSet*, i64);\nint sqlite3RowSetTest(RowSet*, int iBatch, i64);\nint sqlite3RowSetNext(RowSet*, i64*);\n\nvoid sqlite3CreateView(Parse*,Token*,Token*,Token*,ExprList*,Select*,int,int);\n\n#if !defined(SQLITE_OMIT_VIEW) || !defined(SQLITE_OMIT_VIRTUALTABLE)\n  int sqlite3ViewGetColumnNames(Parse*,Table*);\n#else\n# define sqlite3ViewGetColumnNames(A,B) 0\n#endif\n\n#if SQLITE_MAX_ATTACHED>30\n  int sqlite3DbMaskAllZero(yDbMask);\n#endif\nvoid sqlite3DropTable(Parse*, SrcList*, int, int);\nvoid sqlite3CodeDropTable(Parse*, Table*, int, int);\nvoid sqlite3DeleteTable(sqlite3*, Table*);\nvoid sqlite3FreeIndex(sqlite3*, Index*);\n#ifndef SQLITE_OMIT_AUTOINCREMENT\n  void sqlite3AutoincrementBegin(Parse *pParse);\n  void sqlite3AutoincrementEnd(Parse *pParse);\n#else\n# define sqlite3AutoincrementBegin(X)\n# define sqlite3AutoincrementEnd(X)\n#endif\nvoid sqlite3Insert(Parse*, SrcList*, Select*, IdList*, int, Upsert*);\n#ifndef SQLITE_OMIT_GENERATED_COLUMNS\n  void sqlite3ComputeGeneratedColumns(Parse*, int, Table*);\n#endif\nvoid *sqlite3ArrayAllocate(sqlite3*,void*,int,int*,int*);\nIdList *sqlite3IdListAppend(Parse*, IdList*, Token*);\nint sqlite3IdListIndex(IdList*,const char*);\nSrcList *sqlite3SrcListEnlarge(Parse*, SrcList*, int, int);\nSrcList *sqlite3SrcListAppend(Parse*, SrcList*, Token*, Token*);\nSrcList *sqlite3SrcListAppendFromTerm(Parse*, SrcList*, Token*, Token*,\n                                      Token*, Select*, Expr*, IdList*);\nvoid sqlite3SrcListIndexedBy(Parse *, SrcList *, Token *);\nvoid sqlite3SrcListFuncArgs(Parse*, SrcList*, ExprList*);\nint sqlite3IndexedByLookup(Parse *, struct SrcList_item *);\nvoid sqlite3SrcListShiftJoinType(SrcList*);\nvoid sqlite3SrcListAssignCursors(Parse*, SrcList*);\nvoid sqlite3IdListDelete(sqlite3*, IdList*);\nvoid sqlite3SrcListDelete(sqlite3*, SrcList*);\nIndex *sqlite3AllocateIndexObject(sqlite3*,i16,int,char**);\nvoid sqlite3CreateIndex(Parse*,Token*,Token*,SrcList*,ExprList*,int,Token*,\n                          Expr*, int, int, u8);\nvoid sqlite3DropIndex(Parse*, SrcList*, int);\nint sqlite3Select(Parse*, Select*, SelectDest*);\nSelect *sqlite3SelectNew(Parse*,ExprList*,SrcList*,Expr*,ExprList*,\n                         Expr*,ExprList*,u32,Expr*);\nvoid sqlite3SelectDelete(sqlite3*, Select*);\nTable *sqlite3SrcListLookup(Parse*, SrcList*);\nint sqlite3IsReadOnly(Parse*, Table*, int);\nvoid sqlite3OpenTable(Parse*, int iCur, int iDb, Table*, int);\n#if defined(SQLITE_ENABLE_UPDATE_DELETE_LIMIT) && !defined(SQLITE_OMIT_SUBQUERY)\nExpr *sqlite3LimitWhere(Parse*,SrcList*,Expr*,ExprList*,Expr*,char*);\n#endif\nvoid sqlite3DeleteFrom(Parse*, SrcList*, Expr*, ExprList*, Expr*);\nvoid sqlite3Update(Parse*, SrcList*, ExprList*,Expr*,int,ExprList*,Expr*,\n                   Upsert*);\nWhereInfo *sqlite3WhereBegin(Parse*,SrcList*,Expr*,ExprList*,ExprList*,u16,int);\nvoid sqlite3WhereEnd(WhereInfo*);\nLogEst sqlite3WhereOutputRowCount(WhereInfo*);\nint sqlite3WhereIsDistinct(WhereInfo*);\nint sqlite3WhereIsOrdered(WhereInfo*);\nint sqlite3WhereOrderByLimitOptLabel(WhereInfo*);\nint sqlite3WhereIsSorted(WhereInfo*);\nint sqlite3WhereContinueLabel(WhereInfo*);\nint sqlite3WhereBreakLabel(WhereInfo*);\nint sqlite3WhereOkOnePass(WhereInfo*, int*);\n#define ONEPASS_OFF      0        /* Use of ONEPASS not allowed */\n#define ONEPASS_SINGLE   1        /* ONEPASS valid for a single row update */\n#define ONEPASS_MULTI    2        /* ONEPASS is valid for multiple rows */\nvoid sqlite3ExprCodeLoadIndexColumn(Parse*, Index*, int, int, int);\nint sqlite3ExprCodeGetColumn(Parse*, Table*, int, int, int, u8);\nvoid sqlite3ExprCodeGetColumnOfTable(Vdbe*, Table*, int, int, int);\nvoid sqlite3ExprCodeMove(Parse*, int, int, int);\nvoid sqlite3ExprCode(Parse*, Expr*, int);\n#ifndef SQLITE_OMIT_GENERATED_COLUMNS\nvoid sqlite3ExprCodeGeneratedColumn(Parse*, Column*, int);\n#endif\nvoid sqlite3ExprCodeCopy(Parse*, Expr*, int);\nvoid sqlite3ExprCodeFactorable(Parse*, Expr*, int);\nint sqlite3ExprCodeAtInit(Parse*, Expr*, int);\nint sqlite3ExprCodeTemp(Parse*, Expr*, int*);\nint sqlite3ExprCodeTarget(Parse*, Expr*, int);\nint sqlite3ExprCodeExprList(Parse*, ExprList*, int, int, u8);\n#define SQLITE_ECEL_DUP      0x01  /* Deep, not shallow copies */\n#define SQLITE_ECEL_FACTOR   0x02  /* Factor out constant terms */\n#define SQLITE_ECEL_REF      0x04  /* Use ExprList.u.x.iOrderByCol */\n#define SQLITE_ECEL_OMITREF  0x08  /* Omit if ExprList.u.x.iOrderByCol */\nvoid sqlite3ExprIfTrue(Parse*, Expr*, int, int);\nvoid sqlite3ExprIfFalse(Parse*, Expr*, int, int);\nvoid sqlite3ExprIfFalseDup(Parse*, Expr*, int, int);\nTable *sqlite3FindTable(sqlite3*,const char*, const char*);\n#define LOCATE_VIEW    0x01\n#define LOCATE_NOERR   0x02\nTable *sqlite3LocateTable(Parse*,u32 flags,const char*, const char*);\nTable *sqlite3LocateTableItem(Parse*,u32 flags,struct SrcList_item *);\nIndex *sqlite3FindIndex(sqlite3*,const char*, const char*);\nvoid sqlite3UnlinkAndDeleteTable(sqlite3*,int,const char*);\nvoid sqlite3UnlinkAndDeleteIndex(sqlite3*,int,const char*);\nvoid sqlite3Vacuum(Parse*,Token*,Expr*);\nint sqlite3RunVacuum(char**, sqlite3*, int, sqlite3_value*);\nchar *sqlite3NameFromToken(sqlite3*, Token*);\nint sqlite3ExprCompare(Parse*,Expr*, Expr*, int);\nint sqlite3ExprCompareSkip(Expr*, Expr*, int);\nint sqlite3ExprListCompare(ExprList*, ExprList*, int);\nint sqlite3ExprImpliesExpr(Parse*,Expr*, Expr*, int);\nint sqlite3ExprImpliesNonNullRow(Expr*,int);\nvoid sqlite3ExprAnalyzeAggregates(NameContext*, Expr*);\nvoid sqlite3ExprAnalyzeAggList(NameContext*,ExprList*);\nint sqlite3ExprCoveredByIndex(Expr*, int iCur, Index *pIdx);\nint sqlite3FunctionUsesThisSrc(Expr*, SrcList*);\nVdbe *sqlite3GetVdbe(Parse*);\n#ifndef SQLITE_UNTESTABLE\nvoid sqlite3PrngSaveState(void);\nvoid sqlite3PrngRestoreState(void);\n#endif\nvoid sqlite3RollbackAll(sqlite3*,int);\nvoid sqlite3CodeVerifySchema(Parse*, int);\nvoid sqlite3CodeVerifyNamedSchema(Parse*, const char *zDb);\nvoid sqlite3BeginTransaction(Parse*, int);\nvoid sqlite3EndTransaction(Parse*,int);\nvoid sqlite3Savepoint(Parse*, int, Token*);\nvoid sqlite3CloseSavepoints(sqlite3 *);\nvoid sqlite3LeaveMutexAndCloseZombie(sqlite3*);\nint sqlite3ExprIdToTrueFalse(Expr*);\nint sqlite3ExprTruthValue(const Expr*);\nint sqlite3ExprIsConstant(Expr*);\nint sqlite3ExprIsConstantNotJoin(Expr*);\nint sqlite3ExprIsConstantOrFunction(Expr*, u8);\nint sqlite3ExprIsConstantOrGroupBy(Parse*, Expr*, ExprList*);\nint sqlite3ExprIsTableConstant(Expr*,int);\n#ifdef SQLITE_ENABLE_CURSOR_HINTS\nint sqlite3ExprContainsSubquery(Expr*);\n#endif\nint sqlite3ExprIsInteger(Expr*, int*);\nint sqlite3ExprCanBeNull(const Expr*);\nint sqlite3ExprNeedsNoAffinityChange(const Expr*, char);\nint sqlite3IsRowid(const char*);\nvoid sqlite3GenerateRowDelete(\n    Parse*,Table*,Trigger*,int,int,int,i16,u8,u8,u8,int);\nvoid sqlite3GenerateRowIndexDelete(Parse*, Table*, int, int, int*, int);\nint sqlite3GenerateIndexKey(Parse*, Index*, int, int, int, int*,Index*,int);\nvoid sqlite3ResolvePartIdxLabel(Parse*,int);\nint sqlite3ExprReferencesUpdatedColumn(Expr*,int*,int);\nvoid sqlite3GenerateConstraintChecks(Parse*,Table*,int*,int,int,int,int,\n                                     u8,u8,int,int*,int*,Upsert*);\n#ifdef SQLITE_ENABLE_NULL_TRIM\n  void sqlite3SetMakeRecordP5(Vdbe*,Table*);\n#else\n# define sqlite3SetMakeRecordP5(A,B)\n#endif\nvoid sqlite3CompleteInsertion(Parse*,Table*,int,int,int,int*,int,int,int);\nint sqlite3OpenTableAndIndices(Parse*, Table*, int, u8, int, u8*, int*, int*);\nvoid sqlite3BeginWriteOperation(Parse*, int, int);\nvoid sqlite3MultiWrite(Parse*);\nvoid sqlite3MayAbort(Parse*);\nvoid sqlite3HaltConstraint(Parse*, int, int, char*, i8, u8);\nvoid sqlite3UniqueConstraint(Parse*, int, Index*);\nvoid sqlite3RowidConstraint(Parse*, int, Table*);\nExpr *sqlite3ExprDup(sqlite3*,Expr*,int);\nExprList *sqlite3ExprListDup(sqlite3*,ExprList*,int);\nSrcList *sqlite3SrcListDup(sqlite3*,SrcList*,int);\nIdList *sqlite3IdListDup(sqlite3*,IdList*);\nSelect *sqlite3SelectDup(sqlite3*,Select*,int);\nFuncDef *sqlite3FunctionSearch(int,const char*);\nvoid sqlite3InsertBuiltinFuncs(FuncDef*,int);\nFuncDef *sqlite3FindFunction(sqlite3*,const char*,int,u8,u8);\nvoid sqlite3RegisterBuiltinFunctions(void);\nvoid sqlite3RegisterDateTimeFunctions(void);\nvoid sqlite3RegisterPerConnectionBuiltinFunctions(sqlite3*);\nint sqlite3SafetyCheckOk(sqlite3*);\nint sqlite3SafetyCheckSickOrOk(sqlite3*);\nvoid sqlite3ChangeCookie(Parse*, int);\n\n#if !defined(SQLITE_OMIT_VIEW) && !defined(SQLITE_OMIT_TRIGGER)\nvoid sqlite3MaterializeView(Parse*, Table*, Expr*, ExprList*,Expr*,int);\n#endif\n\n#ifndef SQLITE_OMIT_TRIGGER\n  void sqlite3BeginTrigger(Parse*, Token*,Token*,int,int,IdList*,SrcList*,\n                           Expr*,int, int);\n  void sqlite3FinishTrigger(Parse*, TriggerStep*, Token*);\n  void sqlite3DropTrigger(Parse*, SrcList*, int);\n  void sqlite3DropTriggerPtr(Parse*, Trigger*);\n  Trigger *sqlite3TriggersExist(Parse *, Table*, int, ExprList*, int *pMask);\n  Trigger *sqlite3TriggerList(Parse *, Table *);\n  void sqlite3CodeRowTrigger(Parse*, Trigger *, int, ExprList*, int, Table *,\n                            int, int, int);\n  void sqlite3CodeRowTriggerDirect(Parse *, Trigger *, Table *, int, int, int);\n  void sqliteViewTriggers(Parse*, Table*, Expr*, int, ExprList*);\n  void sqlite3DeleteTriggerStep(sqlite3*, TriggerStep*);\n  TriggerStep *sqlite3TriggerSelectStep(sqlite3*,Select*,\n                                        const char*,const char*);\n  TriggerStep *sqlite3TriggerInsertStep(Parse*,Token*, IdList*,\n                                        Select*,u8,Upsert*,\n                                        const char*,const char*);\n  TriggerStep *sqlite3TriggerUpdateStep(Parse*,Token*,ExprList*, Expr*, u8,\n                                        const char*,const char*);\n  TriggerStep *sqlite3TriggerDeleteStep(Parse*,Token*, Expr*,\n                                        const char*,const char*);\n  void sqlite3DeleteTrigger(sqlite3*, Trigger*);\n  void sqlite3UnlinkAndDeleteTrigger(sqlite3*,int,const char*);\n  u32 sqlite3TriggerColmask(Parse*,Trigger*,ExprList*,int,int,Table*,int);\n# define sqlite3ParseToplevel(p) ((p)->pToplevel ? (p)->pToplevel : (p))\n# define sqlite3IsToplevel(p) ((p)->pToplevel==0)\n#else\n# define sqlite3TriggersExist(B,C,D,E,F) 0\n# define sqlite3DeleteTrigger(A,B)\n# define sqlite3DropTriggerPtr(A,B)\n# define sqlite3UnlinkAndDeleteTrigger(A,B,C)\n# define sqlite3CodeRowTrigger(A,B,C,D,E,F,G,H,I)\n# define sqlite3CodeRowTriggerDirect(A,B,C,D,E,F)\n# define sqlite3TriggerList(X, Y) 0\n# define sqlite3ParseToplevel(p) p\n# define sqlite3IsToplevel(p) 1\n# define sqlite3TriggerColmask(A,B,C,D,E,F,G) 0\n#endif\n\nint sqlite3JoinType(Parse*, Token*, Token*, Token*);\nvoid sqlite3SetJoinExpr(Expr*,int);\nvoid sqlite3CreateForeignKey(Parse*, ExprList*, Token*, ExprList*, int);\nvoid sqlite3DeferForeignKey(Parse*, int);\n#ifndef SQLITE_OMIT_AUTHORIZATION\n  void sqlite3AuthRead(Parse*,Expr*,Schema*,SrcList*);\n  int sqlite3AuthCheck(Parse*,int, const char*, const char*, const char*);\n  void sqlite3AuthContextPush(Parse*, AuthContext*, const char*);\n  void sqlite3AuthContextPop(AuthContext*);\n  int sqlite3AuthReadCol(Parse*, const char *, const char *, int);\n#else\n# define sqlite3AuthRead(a,b,c,d)\n# define sqlite3AuthCheck(a,b,c,d,e)    SQLITE_OK\n# define sqlite3AuthContextPush(a,b,c)\n# define sqlite3AuthContextPop(a)  ((void)(a))\n#endif\nvoid sqlite3Attach(Parse*, Expr*, Expr*, Expr*);\nvoid sqlite3Detach(Parse*, Expr*);\nvoid sqlite3FixInit(DbFixer*, Parse*, int, const char*, const Token*);\nint sqlite3FixSrcList(DbFixer*, SrcList*);\nint sqlite3FixSelect(DbFixer*, Select*);\nint sqlite3FixExpr(DbFixer*, Expr*);\nint sqlite3FixExprList(DbFixer*, ExprList*);\nint sqlite3FixTriggerStep(DbFixer*, TriggerStep*);\nint sqlite3RealSameAsInt(double,sqlite3_int64);\nint sqlite3AtoF(const char *z, double*, int, u8);\nint sqlite3GetInt32(const char *, int*);\nint sqlite3Atoi(const char*);\n#ifndef SQLITE_OMIT_UTF16\nint sqlite3Utf16ByteLen(const void *pData, int nChar);\n#endif\nint sqlite3Utf8CharLen(const char *pData, int nByte);\nu32 sqlite3Utf8Read(const u8**);\nLogEst sqlite3LogEst(u64);\nLogEst sqlite3LogEstAdd(LogEst,LogEst);\n#ifndef SQLITE_OMIT_VIRTUALTABLE\nLogEst sqlite3LogEstFromDouble(double);\n#endif\n#if defined(SQLITE_ENABLE_STMT_SCANSTATUS) || \\\n    defined(SQLITE_ENABLE_STAT4) || \\\n    defined(SQLITE_EXPLAIN_ESTIMATED_ROWS)\nu64 sqlite3LogEstToInt(LogEst);\n#endif\nVList *sqlite3VListAdd(sqlite3*,VList*,const char*,int,int);\nconst char *sqlite3VListNumToName(VList*,int);\nint sqlite3VListNameToNum(VList*,const char*,int);\n\n/*\n** Routines to read and write variable-length integers.  These used to\n** be defined locally, but now we use the varint routines in the util.c\n** file.\n*/\nint sqlite3PutVarint(unsigned char*, u64);\nu8 sqlite3GetVarint(const unsigned char *, u64 *);\nu8 sqlite3GetVarint32(const unsigned char *, u32 *);\nint sqlite3VarintLen(u64 v);\n\n/*\n** The common case is for a varint to be a single byte.  They following\n** macros handle the common case without a procedure call, but then call\n** the procedure for larger varints.\n*/\n#define getVarint32(A,B)  \\\n  (u8)((*(A)<(u8)0x80)?((B)=(u32)*(A)),1:sqlite3GetVarint32((A),(u32 *)&(B)))\n#define putVarint32(A,B)  \\\n  (u8)(((u32)(B)<(u32)0x80)?(*(A)=(unsigned char)(B)),1:\\\n  sqlite3PutVarint((A),(B)))\n#define getVarint    sqlite3GetVarint\n#define putVarint    sqlite3PutVarint\n\n\nconst char *sqlite3IndexAffinityStr(sqlite3*, Index*);\nvoid sqlite3TableAffinity(Vdbe*, Table*, int);\nchar sqlite3CompareAffinity(Expr *pExpr, char aff2);\nint sqlite3IndexAffinityOk(Expr *pExpr, char idx_affinity);\nchar sqlite3TableColumnAffinity(Table*,int);\nchar sqlite3ExprAffinity(Expr *pExpr);\nint sqlite3Atoi64(const char*, i64*, int, u8);\nint sqlite3DecOrHexToI64(const char*, i64*);\nvoid sqlite3ErrorWithMsg(sqlite3*, int, const char*,...);\nvoid sqlite3Error(sqlite3*,int);\nvoid sqlite3SystemError(sqlite3*,int);\nvoid *sqlite3HexToBlob(sqlite3*, const char *z, int n);\nu8 sqlite3HexToInt(int h);\nint sqlite3TwoPartName(Parse *, Token *, Token *, Token **);\n\n#if defined(SQLITE_NEED_ERR_NAME)\nconst char *sqlite3ErrName(int);\n#endif\n\n#ifdef SQLITE_ENABLE_DESERIALIZE\nint sqlite3MemdbInit(void);\n#endif\n\nconst char *sqlite3ErrStr(int);\nint sqlite3ReadSchema(Parse *pParse);\nCollSeq *sqlite3FindCollSeq(sqlite3*,u8 enc, const char*,int);\nint sqlite3IsBinary(const CollSeq*);\nCollSeq *sqlite3LocateCollSeq(Parse *pParse, const char*zName);\nCollSeq *sqlite3ExprCollSeq(Parse *pParse, Expr *pExpr);\nCollSeq *sqlite3ExprNNCollSeq(Parse *pParse, Expr *pExpr);\nint sqlite3ExprCollSeqMatch(Parse*,Expr*,Expr*);\nExpr *sqlite3ExprAddCollateToken(Parse *pParse, Expr*, const Token*, int);\nExpr *sqlite3ExprAddCollateString(Parse*,Expr*,const char*);\nExpr *sqlite3ExprSkipCollate(Expr*);\nExpr *sqlite3ExprSkipCollateAndLikely(Expr*);\nint sqlite3CheckCollSeq(Parse *, CollSeq *);\nint sqlite3WritableSchema(sqlite3*);\nint sqlite3CheckObjectName(Parse*, const char*,const char*,const char*);\nvoid sqlite3VdbeSetChanges(sqlite3 *, int);\nint sqlite3AddInt64(i64*,i64);\nint sqlite3SubInt64(i64*,i64);\nint sqlite3MulInt64(i64*,i64);\nint sqlite3AbsInt32(int);\n#ifdef SQLITE_ENABLE_8_3_NAMES\nvoid sqlite3FileSuffix3(const char*, char*);\n#else\n# define sqlite3FileSuffix3(X,Y)\n#endif\nu8 sqlite3GetBoolean(const char *z,u8);\n\nconst void *sqlite3ValueText(sqlite3_value*, u8);\nint sqlite3ValueBytes(sqlite3_value*, u8);\nvoid sqlite3ValueSetStr(sqlite3_value*, int, const void *,u8,\n                        void(*)(void*));\nvoid sqlite3ValueSetNull(sqlite3_value*);\nvoid sqlite3ValueFree(sqlite3_value*);\n#ifndef SQLITE_UNTESTABLE\nvoid sqlite3ResultIntReal(sqlite3_context*);\n#endif\nsqlite3_value *sqlite3ValueNew(sqlite3 *);\n#ifndef SQLITE_OMIT_UTF16\nchar *sqlite3Utf16to8(sqlite3 *, const void*, int, u8);\n#endif\nint sqlite3ValueFromExpr(sqlite3 *, Expr *, u8, u8, sqlite3_value **);\nvoid sqlite3ValueApplyAffinity(sqlite3_value *, u8, u8);\n#ifndef SQLITE_AMALGAMATION\nextern const unsigned char sqlite3OpcodeProperty[];\nextern const char sqlite3StrBINARY[];\nextern const unsigned char sqlite3UpperToLower[];\nextern const unsigned char sqlite3CtypeMap[];\nextern SQLITE_WSD struct Sqlite3Config sqlite3Config;\nextern FuncDefHash sqlite3BuiltinFunctions;\n#ifndef SQLITE_OMIT_WSD\nextern int sqlite3PendingByte;\n#endif\n#endif\n#ifdef VDBE_PROFILE\nextern sqlite3_uint64 sqlite3NProfileCnt;\n#endif\nvoid sqlite3RootPageMoved(sqlite3*, int, int, int);\nvoid sqlite3Reindex(Parse*, Token*, Token*);\nvoid sqlite3AlterFunctions(void);\nvoid sqlite3AlterRenameTable(Parse*, SrcList*, Token*);\nvoid sqlite3AlterRenameColumn(Parse*, SrcList*, Token*, Token*);\nint sqlite3GetToken(const unsigned char *, int *);\nvoid sqlite3NestedParse(Parse*, const char*, ...);\nvoid sqlite3ExpirePreparedStatements(sqlite3*, int);\nvoid sqlite3CodeRhsOfIN(Parse*, Expr*, int);\nint sqlite3CodeSubselect(Parse*, Expr*);\nvoid sqlite3SelectPrep(Parse*, Select*, NameContext*);\nvoid sqlite3SelectWrongNumTermsError(Parse *pParse, Select *p);\nint sqlite3MatchSpanName(const char*, const char*, const char*, const char*);\nint sqlite3ResolveExprNames(NameContext*, Expr*);\nint sqlite3ResolveExprListNames(NameContext*, ExprList*);\nvoid sqlite3ResolveSelectNames(Parse*, Select*, NameContext*);\nint sqlite3ResolveSelfReference(Parse*,Table*,int,Expr*,ExprList*);\nint sqlite3ResolveOrderGroupBy(Parse*, Select*, ExprList*, const char*);\nvoid sqlite3ColumnDefault(Vdbe *, Table *, int, int);\nvoid sqlite3AlterFinishAddColumn(Parse *, Token *);\nvoid sqlite3AlterBeginAddColumn(Parse *, SrcList *);\nvoid *sqlite3RenameTokenMap(Parse*, void*, Token*);\nvoid sqlite3RenameTokenRemap(Parse*, void *pTo, void *pFrom);\nvoid sqlite3RenameExprUnmap(Parse*, Expr*);\nvoid sqlite3RenameExprlistUnmap(Parse*, ExprList*);\nCollSeq *sqlite3GetCollSeq(Parse*, u8, CollSeq *, const char*);\nchar sqlite3AffinityType(const char*, Column*);\nvoid sqlite3Analyze(Parse*, Token*, Token*);\nint sqlite3InvokeBusyHandler(BusyHandler*, sqlite3_file*);\nint sqlite3FindDb(sqlite3*, Token*);\nint sqlite3FindDbName(sqlite3 *, const char *);\nint sqlite3AnalysisLoad(sqlite3*,int iDB);\nvoid sqlite3DeleteIndexSamples(sqlite3*,Index*);\nvoid sqlite3DefaultRowEst(Index*);\nvoid sqlite3RegisterLikeFunctions(sqlite3*, int);\nint sqlite3IsLikeFunction(sqlite3*,Expr*,int*,char*);\nvoid sqlite3SchemaClear(void *);\nSchema *sqlite3SchemaGet(sqlite3 *, Btree *);\nint sqlite3SchemaToIndex(sqlite3 *db, Schema *);\nKeyInfo *sqlite3KeyInfoAlloc(sqlite3*,int,int);\nvoid sqlite3KeyInfoUnref(KeyInfo*);\nKeyInfo *sqlite3KeyInfoRef(KeyInfo*);\nKeyInfo *sqlite3KeyInfoOfIndex(Parse*, Index*);\nKeyInfo *sqlite3KeyInfoFromExprList(Parse*, ExprList*, int, int);\nint sqlite3HasExplicitNulls(Parse*, ExprList*);\n\n#ifdef SQLITE_DEBUG\nint sqlite3KeyInfoIsWriteable(KeyInfo*);\n#endif\nint sqlite3CreateFunc(sqlite3 *, const char *, int, int, void *,\n  void (*)(sqlite3_context*,int,sqlite3_value **),\n  void (*)(sqlite3_context*,int,sqlite3_value **), \n  void (*)(sqlite3_context*),\n  void (*)(sqlite3_context*),\n  void (*)(sqlite3_context*,int,sqlite3_value **), \n  FuncDestructor *pDestructor\n);\nvoid sqlite3NoopDestructor(void*);\nvoid sqlite3OomFault(sqlite3*);\nvoid sqlite3OomClear(sqlite3*);\nint sqlite3ApiExit(sqlite3 *db, int);\nint sqlite3OpenTempDatabase(Parse *);\n\nvoid sqlite3StrAccumInit(StrAccum*, sqlite3*, char*, int, int);\nchar *sqlite3StrAccumFinish(StrAccum*);\nvoid sqlite3SelectDestInit(SelectDest*,int,int);\nExpr *sqlite3CreateColumnExpr(sqlite3 *, SrcList *, int, int);\n\nvoid sqlite3BackupRestart(sqlite3_backup *);\nvoid sqlite3BackupUpdate(sqlite3_backup *, Pgno, const u8 *);\n\n#ifndef SQLITE_OMIT_SUBQUERY\nint sqlite3ExprCheckIN(Parse*, Expr*);\n#else\n# define sqlite3ExprCheckIN(x,y) SQLITE_OK\n#endif\n\n#ifdef SQLITE_ENABLE_STAT4\nint sqlite3Stat4ProbeSetValue(\n    Parse*,Index*,UnpackedRecord**,Expr*,int,int,int*);\nint sqlite3Stat4ValueFromExpr(Parse*, Expr*, u8, sqlite3_value**);\nvoid sqlite3Stat4ProbeFree(UnpackedRecord*);\nint sqlite3Stat4Column(sqlite3*, const void*, int, int, sqlite3_value**);\nchar sqlite3IndexColumnAffinity(sqlite3*, Index*, int);\n#endif\n\n/*\n** The interface to the LEMON-generated parser\n*/\n#ifndef SQLITE_AMALGAMATION\n  void *sqlite3ParserAlloc(void*(*)(u64), Parse*);\n  void sqlite3ParserFree(void*, void(*)(void*));\n#endif\nvoid sqlite3Parser(void*, int, Token);\nint sqlite3ParserFallback(int);\n#ifdef YYTRACKMAXSTACKDEPTH\n  int sqlite3ParserStackPeak(void*);\n#endif\n\nvoid sqlite3AutoLoadExtensions(sqlite3*);\n#ifndef SQLITE_OMIT_LOAD_EXTENSION\n  void sqlite3CloseExtensions(sqlite3*);\n#else\n# define sqlite3CloseExtensions(X)\n#endif\n\n#ifndef SQLITE_OMIT_SHARED_CACHE\n  void sqlite3TableLock(Parse *, int, int, u8, const char *);\n#else\n  #define sqlite3TableLock(v,w,x,y,z)\n#endif\n\n#ifdef SQLITE_TEST\n  int sqlite3Utf8To8(unsigned char*);\n#endif\n\n#ifdef SQLITE_OMIT_VIRTUALTABLE\n#  define sqlite3VtabClear(Y)\n#  define sqlite3VtabSync(X,Y) SQLITE_OK\n#  define sqlite3VtabRollback(X)\n#  define sqlite3VtabCommit(X)\n#  define sqlite3VtabInSync(db) 0\n#  define sqlite3VtabLock(X)\n#  define sqlite3VtabUnlock(X)\n#  define sqlite3VtabModuleUnref(D,X)\n#  define sqlite3VtabUnlockList(X)\n#  define sqlite3VtabSavepoint(X, Y, Z) SQLITE_OK\n#  define sqlite3GetVTable(X,Y)  ((VTable*)0)\n#else\n   void sqlite3VtabClear(sqlite3 *db, Table*);\n   void sqlite3VtabDisconnect(sqlite3 *db, Table *p);\n   int sqlite3VtabSync(sqlite3 *db, Vdbe*);\n   int sqlite3VtabRollback(sqlite3 *db);\n   int sqlite3VtabCommit(sqlite3 *db);\n   void sqlite3VtabLock(VTable *);\n   void sqlite3VtabUnlock(VTable *);\n   void sqlite3VtabModuleUnref(sqlite3*,Module*);\n   void sqlite3VtabUnlockList(sqlite3*);\n   int sqlite3VtabSavepoint(sqlite3 *, int, int);\n   void sqlite3VtabImportErrmsg(Vdbe*, sqlite3_vtab*);\n   VTable *sqlite3GetVTable(sqlite3*, Table*);\n   Module *sqlite3VtabCreateModule(\n     sqlite3*,\n     const char*,\n     const sqlite3_module*,\n     void*,\n     void(*)(void*)\n   );\n#  define sqlite3VtabInSync(db) ((db)->nVTrans>0 && (db)->aVTrans==0)\n#endif\nint sqlite3ReadOnlyShadowTables(sqlite3 *db);\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n  int sqlite3ShadowTableName(sqlite3 *db, const char *zName);\n#else\n# define sqlite3ShadowTableName(A,B) 0\n#endif\nint sqlite3VtabEponymousTableInit(Parse*,Module*);\nvoid sqlite3VtabEponymousTableClear(sqlite3*,Module*);\nvoid sqlite3VtabMakeWritable(Parse*,Table*);\nvoid sqlite3VtabBeginParse(Parse*, Token*, Token*, Token*, int);\nvoid sqlite3VtabFinishParse(Parse*, Token*);\nvoid sqlite3VtabArgInit(Parse*);\nvoid sqlite3VtabArgExtend(Parse*, Token*);\nint sqlite3VtabCallCreate(sqlite3*, int, const char *, char **);\nint sqlite3VtabCallConnect(Parse*, Table*);\nint sqlite3VtabCallDestroy(sqlite3*, int, const char *);\nint sqlite3VtabBegin(sqlite3 *, VTable *);\nFuncDef *sqlite3VtabOverloadFunction(sqlite3 *,FuncDef*, int nArg, Expr*);\nsqlite3_int64 sqlite3StmtCurrentTime(sqlite3_context*);\nint sqlite3VdbeParameterIndex(Vdbe*, const char*, int);\nint sqlite3TransferBindings(sqlite3_stmt *, sqlite3_stmt *);\nvoid sqlite3ParserReset(Parse*);\n#ifdef SQLITE_ENABLE_NORMALIZE\nchar *sqlite3Normalize(Vdbe*, const char*);\n#endif\nint sqlite3Reprepare(Vdbe*);\nvoid sqlite3ExprListCheckLength(Parse*, ExprList*, const char*);\nCollSeq *sqlite3ExprCompareCollSeq(Parse*,Expr*);\nCollSeq *sqlite3BinaryCompareCollSeq(Parse *, Expr *, Expr *);\nint sqlite3TempInMemory(const sqlite3*);\nconst char *sqlite3JournalModename(int);\n#ifndef SQLITE_OMIT_WAL\n  int sqlite3Checkpoint(sqlite3*, int, int, int*, int*);\n  int sqlite3WalDefaultHook(void*,sqlite3*,const char*,int);\n#endif\n#ifndef SQLITE_OMIT_CTE\n  With *sqlite3WithAdd(Parse*,With*,Token*,ExprList*,Select*);\n  void sqlite3WithDelete(sqlite3*,With*);\n  void sqlite3WithPush(Parse*, With*, u8);\n#else\n#define sqlite3WithPush(x,y,z)\n#define sqlite3WithDelete(x,y)\n#endif\n#ifndef SQLITE_OMIT_UPSERT\n  Upsert *sqlite3UpsertNew(sqlite3*,ExprList*,Expr*,ExprList*,Expr*);\n  void sqlite3UpsertDelete(sqlite3*,Upsert*);\n  Upsert *sqlite3UpsertDup(sqlite3*,Upsert*);\n  int sqlite3UpsertAnalyzeTarget(Parse*,SrcList*,Upsert*);\n  void sqlite3UpsertDoUpdate(Parse*,Upsert*,Table*,Index*,int);\n#else\n#define sqlite3UpsertNew(v,w,x,y,z) ((Upsert*)0)\n#define sqlite3UpsertDelete(x,y)\n#define sqlite3UpsertDup(x,y)       ((Upsert*)0)\n#endif\n\n\n/* Declarations for functions in fkey.c. All of these are replaced by\n** no-op macros if OMIT_FOREIGN_KEY is defined. In this case no foreign\n** key functionality is available. If OMIT_TRIGGER is defined but\n** OMIT_FOREIGN_KEY is not, only some of the functions are no-oped. In\n** this case foreign keys are parsed, but no other functionality is\n** provided (enforcement of FK constraints requires the triggers sub-system).\n*/\n#if !defined(SQLITE_OMIT_FOREIGN_KEY) && !defined(SQLITE_OMIT_TRIGGER)\n  void sqlite3FkCheck(Parse*, Table*, int, int, int*, int);\n  void sqlite3FkDropTable(Parse*, SrcList *, Table*);\n  void sqlite3FkActions(Parse*, Table*, ExprList*, int, int*, int);\n  int sqlite3FkRequired(Parse*, Table*, int*, int);\n  u32 sqlite3FkOldmask(Parse*, Table*);\n  FKey *sqlite3FkReferences(Table *);\n#else\n  #define sqlite3FkActions(a,b,c,d,e,f)\n  #define sqlite3FkCheck(a,b,c,d,e,f)\n  #define sqlite3FkDropTable(a,b,c)\n  #define sqlite3FkOldmask(a,b)         0\n  #define sqlite3FkRequired(a,b,c,d)    0\n  #define sqlite3FkReferences(a)        0\n#endif\n#ifndef SQLITE_OMIT_FOREIGN_KEY\n  void sqlite3FkDelete(sqlite3 *, Table*);\n  int sqlite3FkLocateIndex(Parse*,Table*,FKey*,Index**,int**);\n#else\n  #define sqlite3FkDelete(a,b)\n  #define sqlite3FkLocateIndex(a,b,c,d,e)\n#endif\n\n\n/*\n** Available fault injectors.  Should be numbered beginning with 0.\n*/\n#define SQLITE_FAULTINJECTOR_MALLOC     0\n#define SQLITE_FAULTINJECTOR_COUNT      1\n\n/*\n** The interface to the code in fault.c used for identifying \"benign\"\n** malloc failures. This is only present if SQLITE_UNTESTABLE\n** is not defined.\n*/\n#ifndef SQLITE_UNTESTABLE\n  void sqlite3BeginBenignMalloc(void);\n  void sqlite3EndBenignMalloc(void);\n#else\n  #define sqlite3BeginBenignMalloc()\n  #define sqlite3EndBenignMalloc()\n#endif\n\n/*\n** Allowed return values from sqlite3FindInIndex()\n*/\n#define IN_INDEX_ROWID        1   /* Search the rowid of the table */\n#define IN_INDEX_EPH          2   /* Search an ephemeral b-tree */\n#define IN_INDEX_INDEX_ASC    3   /* Existing index ASCENDING */\n#define IN_INDEX_INDEX_DESC   4   /* Existing index DESCENDING */\n#define IN_INDEX_NOOP         5   /* No table available. Use comparisons */\n/*\n** Allowed flags for the 3rd parameter to sqlite3FindInIndex().\n*/\n#define IN_INDEX_NOOP_OK     0x0001  /* OK to return IN_INDEX_NOOP */\n#define IN_INDEX_MEMBERSHIP  0x0002  /* IN operator used for membership test */\n#define IN_INDEX_LOOP        0x0004  /* IN operator used as a loop */\nint sqlite3FindInIndex(Parse *, Expr *, u32, int*, int*, int*);\n\nint sqlite3JournalOpen(sqlite3_vfs *, const char *, sqlite3_file *, int, int);\nint sqlite3JournalSize(sqlite3_vfs *);\n#if defined(SQLITE_ENABLE_ATOMIC_WRITE) \\\n || defined(SQLITE_ENABLE_BATCH_ATOMIC_WRITE)\n  int sqlite3JournalCreate(sqlite3_file *);\n#endif\n\nint sqlite3JournalIsInMemory(sqlite3_file *p);\nvoid sqlite3MemJournalOpen(sqlite3_file *);\n\nvoid sqlite3ExprSetHeightAndFlags(Parse *pParse, Expr *p);\n#if SQLITE_MAX_EXPR_DEPTH>0\n  int sqlite3SelectExprHeight(Select *);\n  int sqlite3ExprCheckHeight(Parse*, int);\n#else\n  #define sqlite3SelectExprHeight(x) 0\n  #define sqlite3ExprCheckHeight(x,y)\n#endif\n\nu32 sqlite3Get4byte(const u8*);\nvoid sqlite3Put4byte(u8*, u32);\n\n#ifdef SQLITE_ENABLE_UNLOCK_NOTIFY\n  void sqlite3ConnectionBlocked(sqlite3 *, sqlite3 *);\n  void sqlite3ConnectionUnlocked(sqlite3 *db);\n  void sqlite3ConnectionClosed(sqlite3 *db);\n#else\n  #define sqlite3ConnectionBlocked(x,y)\n  #define sqlite3ConnectionUnlocked(x)\n  #define sqlite3ConnectionClosed(x)\n#endif\n\n#ifdef SQLITE_DEBUG\n  void sqlite3ParserTrace(FILE*, char *);\n#endif\n#if defined(YYCOVERAGE)\n  int sqlite3ParserCoverage(FILE*);\n#endif\n\n/*\n** If the SQLITE_ENABLE IOTRACE exists then the global variable\n** sqlite3IoTrace is a pointer to a printf-like routine used to\n** print I/O tracing messages.\n*/\n#ifdef SQLITE_ENABLE_IOTRACE\n# define IOTRACE(A)  if( sqlite3IoTrace ){ sqlite3IoTrace A; }\n  void sqlite3VdbeIOTraceSql(Vdbe*);\nSQLITE_API SQLITE_EXTERN void (SQLITE_CDECL *sqlite3IoTrace)(const char*,...);\n#else\n# define IOTRACE(A)\n# define sqlite3VdbeIOTraceSql(X)\n#endif\n\n/*\n** These routines are available for the mem2.c debugging memory allocator\n** only.  They are used to verify that different \"types\" of memory\n** allocations are properly tracked by the system.\n**\n** sqlite3MemdebugSetType() sets the \"type\" of an allocation to one of\n** the MEMTYPE_* macros defined below.  The type must be a bitmask with\n** a single bit set.\n**\n** sqlite3MemdebugHasType() returns true if any of the bits in its second\n** argument match the type set by the previous sqlite3MemdebugSetType().\n** sqlite3MemdebugHasType() is intended for use inside assert() statements.\n**\n** sqlite3MemdebugNoType() returns true if none of the bits in its second\n** argument match the type set by the previous sqlite3MemdebugSetType().\n**\n** Perhaps the most important point is the difference between MEMTYPE_HEAP\n** and MEMTYPE_LOOKASIDE.  If an allocation is MEMTYPE_LOOKASIDE, that means\n** it might have been allocated by lookaside, except the allocation was\n** too large or lookaside was already full.  It is important to verify\n** that allocations that might have been satisfied by lookaside are not\n** passed back to non-lookaside free() routines.  Asserts such as the\n** example above are placed on the non-lookaside free() routines to verify\n** this constraint.\n**\n** All of this is no-op for a production build.  It only comes into\n** play when the SQLITE_MEMDEBUG compile-time option is used.\n*/\n#ifdef SQLITE_MEMDEBUG\n  void sqlite3MemdebugSetType(void*,u8);\n  int sqlite3MemdebugHasType(void*,u8);\n  int sqlite3MemdebugNoType(void*,u8);\n#else\n# define sqlite3MemdebugSetType(X,Y)  /* no-op */\n# define sqlite3MemdebugHasType(X,Y)  1\n# define sqlite3MemdebugNoType(X,Y)   1\n#endif\n#define MEMTYPE_HEAP       0x01  /* General heap allocations */\n#define MEMTYPE_LOOKASIDE  0x02  /* Heap that might have been lookaside */\n#define MEMTYPE_PCACHE     0x04  /* Page cache allocations */\n\n/*\n** Threading interface\n*/\n#if SQLITE_MAX_WORKER_THREADS>0\nint sqlite3ThreadCreate(SQLiteThread**,void*(*)(void*),void*);\nint sqlite3ThreadJoin(SQLiteThread*, void**);\n#endif\n\n#if defined(SQLITE_ENABLE_DBPAGE_VTAB) || defined(SQLITE_TEST)\nint sqlite3DbpageRegister(sqlite3*);\n#endif\n#if defined(SQLITE_ENABLE_DBSTAT_VTAB) || defined(SQLITE_TEST)\nint sqlite3DbstatRegister(sqlite3*);\n#endif\n\nint sqlite3ExprVectorSize(Expr *pExpr);\nint sqlite3ExprIsVector(Expr *pExpr);\nExpr *sqlite3VectorFieldSubexpr(Expr*, int);\nExpr *sqlite3ExprForVectorField(Parse*,Expr*,int);\nvoid sqlite3VectorErrorMsg(Parse*, Expr*);\n\n#ifndef SQLITE_OMIT_COMPILEOPTION_DIAGS\nconst char **sqlite3CompileOptions(int *pnOpt);\n#endif\n\n#endif /* SQLITEINT_H */\n", "# 2019 January 23\n#\n# The author disclaims copyright to this source code.  In place of\n# a legal notice, here is a blessing:\n#\n#    May you do good and not evil.\n#    May you find forgiveness for yourself and forgive others.\n#    May you share freely, never taking more than you give.\n#\n#*************************************************************************\n#\n\nset testdir [file dirname $argv0]\nsource $testdir/tester.tcl\nset testprefix altertab3\n\n# If SQLITE_OMIT_ALTERTABLE is defined, omit this file.\nifcapable !altertable {\n  finish_test\n  return\n}\n\nifcapable windowfunc {\ndo_execsql_test 1.0 {\n  CREATE TABLE t1(a, b);\n  CREATE TRIGGER tr1 AFTER INSERT ON t1 BEGIN\n    SELECT sum(b) OVER w FROM t1 WINDOW w AS (ORDER BY a);\n  END;\n}\n\ndo_execsql_test 1.1 {\n  ALTER TABLE t1 RENAME a TO aaa;\n}\n\ndo_execsql_test 1.2 {\n  SELECT sql FROM sqlite_master WHERE name='tr1'\n} {{CREATE TRIGGER tr1 AFTER INSERT ON t1 BEGIN\n    SELECT sum(b) OVER w FROM t1 WINDOW w AS (ORDER BY aaa);\n  END}}\n\ndo_execsql_test 1.3 {\n  INSERT INTO t1 VALUES(1, 2);\n}\n} ;# windowfunc\n\n#-------------------------------------------------------------------------\nreset_db\ndo_execsql_test 2.0 {\n  CREATE TABLE t1(a,b,c);\n  CREATE TABLE t2(a,b,c);\n  CREATE TRIGGER r1 AFTER INSERT ON t1 WHEN new.a NOT NULL BEGIN\n    SELECT a,b, a name FROM t1 \n      INTERSECT \n    SELECT a,b,c FROM t1 WHERE b>='d' ORDER BY name;\n    SELECT new.c;\n  END;\n}\n\ndo_execsql_test 2.1 {\n  ALTER TABLE t1 RENAME TO t1x;\n  SELECT sql FROM sqlite_master WHERE name = 'r1';\n} {{CREATE TRIGGER r1 AFTER INSERT ON \"t1x\" WHEN new.a NOT NULL BEGIN\n    SELECT a,b, a name FROM \"t1x\" \n      INTERSECT \n    SELECT a,b,c FROM \"t1x\" WHERE b>='d' ORDER BY name;\n    SELECT new.c;\n  END}}\n\n#-------------------------------------------------------------------------\nreset_db\ndo_execsql_test 3.0 {\n  CREATE TABLE t1(a, b, c, d);\n  CREATE VIEW v1 AS SELECT * FROM t1 WHERE a=1 OR (b IN ());\n}\n\ndo_execsql_test 3.1 {\n  ALTER TABLE t1 RENAME b TO bbb;\n}\n\ndo_execsql_test 3.2 {\n  SELECT sql FROM sqlite_master WHERE name = 'v1'\n} {{CREATE VIEW v1 AS SELECT * FROM t1 WHERE a=1 OR (b IN ())}}\n\n#-------------------------------------------------------------------------\nreset_db\ndo_execsql_test 4.0 {\n  CREATE TABLE t1(a, b);\n  CREATE TABLE t3(e, f);\n  CREATE TRIGGER tr1 AFTER INSERT ON t1 BEGIN\n    INSERT INTO t2 VALUES(new.a, new.b);\n  END;\n}\n\ndo_catchsql_test 4.1.2 {\n  BEGIN;\n    ALTER TABLE t3 RENAME TO t4;\n} {1 {error in trigger tr1: no such table: main.t2}}\ndo_execsql_test 4.1.2 {\n  COMMIT;\n}\ndo_execsql_test 4.1.3 {\n  SELECT type, name, tbl_name, sql \n  FROM sqlite_master WHERE type='table' AND name!='t1';\n} {table t3 t3 {CREATE TABLE t3(e, f)}}\n\n\ndo_catchsql_test 4.2.1 {\n  BEGIN;\n    ALTER TABLE t3 RENAME e TO eee;\n} {1 {error in trigger tr1: no such table: main.t2}}\ndo_execsql_test 4.2.2 {\n  COMMIT;\n}\ndo_execsql_test 4.2.3 {\n  SELECT type, name, tbl_name, sql \n  FROM sqlite_master WHERE type='table' AND name!='t1';\n} {table t3 t3 {CREATE TABLE t3(e, f)}}\n\n#-------------------------------------------------------------------------\nreset_db\ndo_execsql_test 5.0 {\n  CREATE TABLE t1 (\n      c1 integer, c2, PRIMARY KEY(c1 collate rtrim),\n      UNIQUE(c2)\n  )\n}\ndo_execsql_test 5.1 {\n  ALTER TABLE t1 RENAME c1 TO c3;\n}\n\n#-------------------------------------------------------------------------\nreset_db\ndo_execsql_test 6.0 {\n  CREATE TEMPORARY TABLE Table0 (\n    Col0 INTEGER, \n    PRIMARY KEY(Col0 COLLATE RTRIM), \n    FOREIGN KEY (Col0) REFERENCES Table0\n  );\n}\n\ndo_execsql_test 6.1 {\n  ALTER TABLE Table0 RENAME Col0 TO Col0;\n}\n\n#-------------------------------------------------------------------------\nreset_db\ndo_execsql_test 7.1.0 {\n  CREATE TABLE t1(a,b,c);\n  CREATE TRIGGER AFTER INSERT ON t1 BEGIN\n    SELECT a, rank() OVER w1 FROM t1\n    WINDOW w1 AS (PARTITION BY b, percent_rank() OVER w1);\n  END;\n}\n\ndo_execsql_test 7.1.2 {\n  ALTER TABLE t1 RENAME TO t1x;\n  SELECT sql FROM sqlite_master;\n} {\n  {CREATE TABLE \"t1x\"(a,b,c)}\n  {CREATE TRIGGER AFTER INSERT ON \"t1x\" BEGIN\n    SELECT a, rank() OVER w1 FROM \"t1x\"\n    WINDOW w1 AS (PARTITION BY b, percent_rank() OVER w1);\n  END}\n}\n\ndo_execsql_test 7.2.1 {\n  DROP TRIGGER after;\n  CREATE TRIGGER AFTER INSERT ON t1x BEGIN\n    SELECT a, rank() OVER w1 FROM t1x\n    WINDOW w1 AS (PARTITION BY b, percent_rank() OVER w1 ORDER BY d);\n  END;\n}\n\ndo_catchsql_test 7.2.2 {\n  ALTER TABLE t1x RENAME TO t1;\n} {1 {error in trigger AFTER: no such column: d}}\n\n#-------------------------------------------------------------------------\nreset_db\ndo_execsql_test 8.0 {\n  CREATE TABLE t0(c0);\n  CREATE INDEX i0 ON t0('1' IN ());\n}\ndo_execsql_test 8.1 {\n  ALTER TABLE t0 RENAME TO t1;\n  SELECT sql FROM sqlite_master;\n} {\n  {CREATE TABLE \"t1\"(c0)}\n  {CREATE INDEX i0 ON \"t1\"('1' IN ())}\n}\ndo_execsql_test 8.2.1 {\n  CREATE TABLE t2 (c0);\n  CREATE INDEX i2 ON t2((LIKELIHOOD(c0, 100) IN ()));\n  ALTER TABLE t2 RENAME COLUMN c0 TO c1;\n}\ndo_execsql_test 8.2.2 {\n  SELECT sql FROM sqlite_master WHERE tbl_name = 't2';\n} {\n  {CREATE TABLE t2 (c1)} \n  {CREATE INDEX i2 ON t2((LIKELIHOOD(c0, 100) IN ()))}\n}\ndo_test 8.2.3 {\n  sqlite3 db2 test.db\n  db2 eval { INSERT INTO t2 VALUES (1), (2), (3) }\n  db close\n} {}\ndb2 close\n\n#-------------------------------------------------------------------------\nreset_db\ndo_execsql_test 9.1 {\n  CREATE TABLE t1(a,b,c);\n  CREATE TRIGGER AFTER INSERT ON t1 WHEN new.a NOT NULL BEGIN\n    SELECT true WHERE (SELECT a, b FROM (t1)) IN ();\n  END;\n}\ndo_execsql_test 9.2 {\n  ALTER TABLE t1 RENAME TO t1x;\n}\n\n#-------------------------------------------------------------------------\nreset_db\ndo_execsql_test 10.1 {\n  CREATE TABLE t1(a, b, c);\n  CREATE TABLE t2(a, b, c);\n  CREATE VIEW v1 AS SELECT * FROM t1 WHERE (\n    SELECT t1.a FROM t1, t2\n  ) IN () OR t1.a=5;\n}\n\ndo_execsql_test 10.2 {\n  ALTER TABLE t2 RENAME TO t3;\n  SELECT sql FROM sqlite_master WHERE name='v1';\n} {\n  {CREATE VIEW v1 AS SELECT * FROM t1 WHERE (\n    SELECT t1.a FROM t1, t2\n  ) IN () OR t1.a=5}\n}\n\n#-------------------------------------------------------------------------\nreset_db\ndo_execsql_test 11.1 {\n  CREATE TABLE t1(\n      a,b,c,d,e,f,g,h,j,jj,jjb,k,aa,bb,cc,dd,ee DEFAULT 3.14,\n      ff DEFAULT('hiccup'),Wg NOD NULL DEFAULT(false)\n  );\n\n  CREATE TRIGGER b AFTER INSERT ON t1 WHEN new.a BEGIN\n    SELECT a, sum() w3 FROM t1 \n    WINDOW b AS (ORDER BY NOT EXISTS(SELECT 1 FROM abc));\n  END;\n}\n\ndo_catchsql_test 11.2 {\n  ALTER TABLE t1 RENAME TO t1x;\n} {1 {error in trigger b: no such table: abc}}\n\ndo_execsql_test 11.3 {\n  DROP TRIGGER b;\n  CREATE TRIGGER b AFTER INSERT ON t1 WHEN new.a BEGIN\n    SELECT a, sum() w3 FROM t1 \n    WINDOW b AS (ORDER BY NOT EXISTS(SELECT 1 FROM t1));\n  END;\n} {}\n\ndo_execsql_test 11.4 {\n  ALTER TABLE t1 RENAME TO t1x;\n  SELECT sql FROM sqlite_master WHERE name = 'b';\n} {\n{CREATE TRIGGER b AFTER INSERT ON \"t1x\" WHEN new.a BEGIN\n    SELECT a, sum() w3 FROM \"t1x\" \n    WINDOW b AS (ORDER BY NOT EXISTS(SELECT 1 FROM \"t1x\"));\n  END}\n}\n\n#-------------------------------------------------------------------------\nreset_db\ndo_execsql_test 12.1 {\nCREATE TABLE t1(a,b,c,d,e,f,g,h,j,jj,Zjj,k,aQ,bb,cc,dd,ee DEFAULT 3.14,\nff DEFAULT('hiccup'),gg NOD NULL DEFAULT(false));\nCREATE TRIGGER AFTER INSERT ON t1 WHEN new.a NOT NULL BEGIN\n\nSELECT b () OVER , dense_rank() OVER d, d () OVER w1\nFROM t1\nWINDOW\nw1 AS\n( w1 ORDER BY d\nROWS BETWEEN 2 NOT IN(SELECT a, sum(d) w2,max(d)OVER FROM t1\nWINDOW\nw1 AS\n(PARTITION BY d\nROWS BETWEEN '' PRECEDING AND false FOLLOWING),\nd AS\n(PARTITION BY b ORDER BY d\nROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)\n) PRECEDING AND 1 FOLLOWING),\nw2 AS\n(PARTITION BY b ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW),\nw3 AS\n(PARTITION BY b ORDER BY d\nROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)\n;\nSELECT a, sum(d) w2,max(d)OVER FROM t1\nWINDOW\nw1 AS\n(PARTITION BY d\nROWS BETWEEN '' PRECEDING AND false FOLLOWING),\nd AS\n(PARTITION BY b ORDER BY d\nROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)\n;\n\nEND;\n}\n\ndo_execsql_test 12.2 {\n  ALTER TABLE t1 RENAME TO t1x;\n}\n\n#-------------------------------------------------------------------------\nreset_db\ndo_execsql_test 13.1 {\n  CREATE TABLE t1(a);\n  CREATE TRIGGER r1 INSERT ON t1 BEGIN\n    SELECT a(*) OVER (ORDER BY (SELECT 1)) FROM t1;\n  END;\n}\n\ndo_execsql_test 13.2 {\n  ALTER TABLE t1 RENAME TO t1x;\n}\n\n#-------------------------------------------------------------------------\nreset_db\ndo_execsql_test 14.1 {\n  CREATE TABLE t1(a);\n  CREATE TABLE t2(b);\n  CREATE TRIGGER AFTER INSERT ON t1 BEGIN\n    SELECT sum() FILTER (WHERE (SELECT sum() FILTER (WHERE 0)) AND a);\n  END;\n}\n\ndo_catchsql_test 14.2 {\n  ALTER TABLE t1 RENAME TO t1x;\n} {1 {error in trigger AFTER: no such column: a}}\n\n#-------------------------------------------------------------------------\nreset_db\n\ndo_execsql_test 16.1 {\n  CREATE TABLE t1(x);\n  CREATE TRIGGER AFTER INSERT ON t1 BEGIN\n    SELECT (WITH t2 AS (WITH t3 AS (SELECT true)\n          SELECT * FROM t3 ORDER BY true COLLATE nocase)\n        SELECT 11);\n\n    WITH t4 AS (SELECT * FROM t1) SELECT 33;\n  END;\n}\ndo_execsql_test 16.2 {\n  ALTER TABLE t1 RENAME TO t1x;\n}\n\n#-------------------------------------------------------------------------\nreset_db\ndo_execsql_test 17.1 {\n  CREATE TABLE t1(a,b,c);\n  CREATE TRIGGER AFTER INSERT ON t1 WHEN new.a NOT NULL BEGIN\n    SELECT a () FILTER (WHERE a>0) FROM t1;\n  END;\n}\n\ndo_execsql_test 17.2 {\n  ALTER TABLE t1 RENAME TO t1x;\n  ALTER TABLE t1x RENAME a TO aaa;\n  SELECT sql FROM sqlite_master WHERE type='trigger';\n} {\n{CREATE TRIGGER AFTER INSERT ON \"t1x\" WHEN new.aaa NOT NULL BEGIN\n    SELECT a () FILTER (WHERE aaa>0) FROM \"t1x\";\n  END}\n}\n\n#-------------------------------------------------------------------------\nreset_db\ndo_execsql_test 18.1 {\n  CREATE TABLE t1(a,b);\n  CREATE TRIGGER r1 AFTER INSERT ON t1 BEGIN\n    SELECT a, b FROM t1\n    INTERSECT SELECT b,a FROM t1\n    ORDER BY b IN (\n        SELECT a UNION SELECT b\n        FROM t1\n        ORDER BY b COLLATE nocase\n        )\n    ;\n  END;\n}\n\ndo_catchsql_test 18.2 {\n    SELECT a, b FROM t1\n    INTERSECT \n    SELECT b,a FROM t1\n    ORDER BY b IN (\n        SELECT a UNION SELECT b\n        FROM t1\n        ORDER BY b COLLATE nocase\n        );\n} {1 {1st ORDER BY term does not match any column in the result set}}\n\ndo_catchsql_test 18.3 {\n  ALTER TABLE t1 RENAME TO t1x;\n} {1 {error in trigger r1: 1st ORDER BY term does not match any column in the result set}}\n\n#-------------------------------------------------------------------------\nreset_db \ndo_execsql_test 19.0 {\n  CREATE TABLE a(a,h CONSTRAINT a UNIQUE ON CONFLICT FAIL,CONSTRAINT a);\n}\n\nforeach {tn v res} {\n  1 {\n    CREATE VIEW q AS SELECT 123\n    \n      WINDOW x AS (\n        RANGE BETWEEN UNBOUNDED PRECEDING AND INDEXED() OVER(\n          PARTITION BY ( WITH x AS(VALUES(col1)) VALUES(453) )\n        )\n      FOLLOWING\n    ) \n  } {1 {error in view q: no such column: col1}}\n\n  2 {\n    CREATE VIEW q AS SELECT\n    CAST(CAST(CAST(CAST(CAST(CAST(CAST(CAST(CAST(CAST(CAST(RIGHT\n    AS)AS)AS)AS)AS)AS)AS)AS)AS)AS)AS)WINDOW x AS(RANGE BETWEEN UNBOUNDED\n    PRECEDING AND INDEXED(*)OVER(PARTITION BY\n    CROSS,CROSS,NATURAL,sqlite_master(*)OVER a,(WITH a AS(VALUES(LEFT)UNION\n    VALUES(LEFT)UNION VALUES(LEFT)UNION VALUES(LEFT)UNION VALUES(LEFT)UNION\n    VALUES(LEFT)UNION VALUES(LEFT))VALUES(LEFT))IN\n    STORED,LEFT,LEFT,LEFT,LEFT,LEFT,LEFT)*LEFT FOLLOWING)ORDER BY\n    LEFT,LEFT,LEFT,LEFT,LEFT,LEFT,LEFT,LEFT,LEFT,LEFT,LEFT LIMIT\n    LEFT,INDEXED(*)OVER(PARTITION BY\n    CROSS,CROSS,CROSS,LEFT,INDEXED(*)OVER(PARTITION BY\n    CROSS,CROSS,CROSS),INDEXED(*)OVER(PARTITION BY\n    LEFT,LEFT,LEFT,LEFT,LEFT,LEFT,LEFT,LEFT,LEFT,LEFT,LEFT),\n    LEFT,LEFT,INNER,CROSS,CROSS,CROSS,INNER,NATURAL ORDER BY\n    OUTER,NATURAL,NATURAL,NATURAL,NATURAL,NATURAL,NATURAL,NATURAL,INNER,\n    INNER,INNER NULLS LAST GROUPS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED\n    FOLLOWING); \n  } {1 {error in view q: no such column: LEFT}}\n\n  3 {\n    CREATE VIEW q AS SELECT 99 WINDOW x AS (RANGE BETWEEN UNBOUNDED PRECEDING\n    AND count(*)OVER(PARTITION BY (WITH a AS(VALUES(2),(x3))VALUES(0)))\n    FOLLOWING)ORDER BY x2,sum(1)OVER(PARTITION BY avg(5)OVER(PARTITION BY x1));\n  } {1 {error in view q: no such column: x3}}\n} {\n  do_execsql_test 19.$tn.1 \"\n    DROP VIEW IF EXISTS q;\n    $v\n  \" {}\n\n  do_catchsql_test 19.$tn.2 {\n    ALTER TABLE a RENAME TO g;\n  } $res\n}\n\n# Verify that the \"if( pParse->nErr ) return WRC_Abort\" at the top of the\n# renameUnmapSelectCb() routine in alter.c (2019-12-04) is really required.\n#\nsqlite3 db :memory:\ndo_catchsql_test 20.10 {\n  CREATE TABLE s(a, b, c);\n  CREATE INDEX k ON s( (WITH s AS( SELECT * ) VALUES(2) ) IN () );\n  ALTER TABLE s RENAME a TO a2;\n} {1 {error in index k: no tables specified}}\n\n#------------------------------------------------------------------------\n#\nreset_db\ndo_execsql_test 21.1 {\n  CREATE TABLE s(col);\n  CREATE VIEW v AS SELECT ( \n    WITH x(a) AS(SELECT * FROM s) VALUES(RIGHT) \n  ) IN() ; \n  CREATE TABLE a(a);\n  ALTER TABLE a RENAME a TO b;\n}\n\n#------------------------------------------------------------------------\n#\nreset_db\ndo_execsql_test 22.1 {\n  CREATE TABLE t1(a);\n  CREATE VIEW v2(b) AS SELECT * FROM v2;\n}\n\ndo_catchsql_test 22.2 {\n  ALTER TABLE t1 RENAME TO t4;\n} {1 {error in view v2: view v2 is circularly defined}}\n\ndo_execsql_test 22.3 {\n  DROP VIEW v2;\n  CREATE VIEW v2(b) AS WITH t3 AS (SELECT b FROM v2) SELECT * FROM t3;\n}\n\nbreakpoint\ndo_catchsql_test 22.4 {\n  ALTER TABLE t1 RENAME TO t4;\n} {1 {error in view v2: view v2 is circularly defined}}\n\ndo_execsql_test 22.5 {\n  DROP VIEW v2;\n  CREATE VIEW v2(b) AS WITH t3 AS (SELECT b FROM v2) VALUES(1);\n}\n\ndo_catchsql_test 22.6 {\n  ALTER TABLE t1 RENAME TO t4;\n} {0 {}}\n\n\nfinish_test\n"], "filenames": ["manifest", "manifest.uuid", "src/alter.c", "src/build.c", "src/sqliteInt.h", "test/altertab3.test"], "buggy_code_start_loc": [1, 1, 762, 2487, 2958, 489], "buggy_code_end_loc": [1859, 2, 1519, 2487, 2958, 489], "fixing_code_start_loc": [1, 1, 763, 2488, 2959, 490], "fixing_code_end_loc": [1859, 2, 1527, 2489, 2960, 521], "type": "CWE-674", "message": "alter.c in SQLite through 3.30.1 allows attackers to trigger infinite recursion via certain types of self-referential views in conjunction with ALTER TABLE statements.", "other": {"cve": {"id": "CVE-2019-19645", "sourceIdentifier": "cve@mitre.org", "published": "2019-12-09T16:15:10.407", "lastModified": "2022-04-15T16:14:43.823", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "alter.c in SQLite through 3.30.1 allows attackers to trigger infinite recursion via certain types of self-referential views in conjunction with ALTER TABLE statements."}, {"lang": "es", "value": "El archivo alter.c en SQLite versiones hasta 3.30.1, permite a atacantes activar una recursi\u00f3n infinita por medio de ciertos tipos de vistas autorreferenciales junto con declaraciones ALTER TABLE."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-674"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:sqlite:sqlite:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.30.1", "matchCriteriaId": "9234ECCF-E771-485D-B89B-9F67AAB332A1"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:cloud_backup:-:*:*:*:*:*:*:*", "matchCriteriaId": "5C2089EE-5D7F-47EC-8EA5-0F69790564C4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:ontap_select_deploy_administration_utility:-:*:*:*:*:*:*:*", "matchCriteriaId": "E7CF3019-975D-40BB-A8A4-894E62BD3797"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:oracle:mysql_workbench:*:*:*:*:*:*:*:*", "versionEndIncluding": "8.0.19", "matchCriteriaId": "7B4DA1DD-9BC1-4D76-BB41-6E6D69838571"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:tenable:tenable.sc:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.19.0", "matchCriteriaId": "41DBA7C7-8084-45F6-B59D-13A9022C34DF"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:siemens:sinec_infrastructure_network_services:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.0.1.1", "matchCriteriaId": "B0F46497-4AB0-49A7-9453-CC26837BF253"}]}]}], "references": [{"url": "https://cert-portal.siemens.com/productcert/pdf/ssa-389290.pdf", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/sqlite/sqlite/commit/38096961c7cd109110ac21d3ed7dad7e0cb0ae06", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20191223-0001/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4394-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpuapr2020.html", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.tenable.com/security/tns-2021-14", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/sqlite/sqlite/commit/38096961c7cd109110ac21d3ed7dad7e0cb0ae06"}}