{"buggy_code": ["<?php\n# MantisBT - a php based bugtracking system\n\n# MantisBT is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 2 of the License, or\n# (at your option) any later version.\n#\n# MantisBT is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with MantisBT.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * @package CoreAPI\n * @subpackage StringProcessingAPI\n * @copyright Copyright (C) 2000 - 2002  Kenzaburo Ito - kenito@300baud.org\n * @copyright Copyright (C) 2002 - 2014  MantisBT Team - mantisbt-dev@lists.sourceforge.net\n * @link http://www.mantisbt.org\n */\n\n/**\n * requires bug_api\n */\nrequire_once( 'bug_api.php' );\n\n/**\n * requires user_pref_api\n */\nrequire_once( 'user_pref_api.php' );\n\n$g_cache_html_valid_tags = '';\n$g_cache_html_valid_tags_single_line = '';\n\n/**\n * Preserve spaces at beginning of lines.\n * Lines must be separated by \\n rather than <br />\n * @param string $p_string\n * @return string\n */\n function string_preserve_spaces_at_bol( $p_string ) {\n\t$lines = explode( \"\\n\", $p_string );\n\t$line_count = count( $lines );\n\tfor( $i = 0;$i < $line_count;$i++ ) {\n\t\t$count = 0;\n\t\t$prefix = '';\n\n\t\t$t_char = utf8_substr( $lines[$i], $count, 1 );\n\t\t$spaces = 0;\n\t\twhile(( $t_char == ' ' ) || ( $t_char == \"\\t\" ) ) {\n\t\t\tif( $t_char == ' ' ) {\n\t\t\t\t$spaces++;\n\t\t\t} else {\n\t\t\t\t$spaces += 4;\n\t\t\t}\n\n\t\t\t// 1 tab = 4 spaces, can be configurable.\n\n\t\t\t$count++;\n\t\t\t$t_char = utf8_substr( $lines[$i], $count, 1 );\n\t\t}\n\n\t\tfor( $j = 0;$j < $spaces;$j++ ) {\n\t\t\t$prefix .= '&#160;';\n\t\t}\n\n\t\t$lines[$i] = $prefix . utf8_substr( $lines[$i], $count );\n\t}\n\treturn implode( \"\\n\", $lines );\n}\n\n/**\n * Prepare a string to be printed without being broken into multiple lines\n * @param string $p_string\n * @return string\n */\nfunction string_no_break( $p_string ) {\n\tif( strpos( $p_string, ' ' ) !== false ) {\n\t\treturn '<span class=\"nowrap\">' . $p_string . \"</span>\";\n\t} else {\n\t\treturn $p_string;\n\t}\n}\n\n/**\n * Similar to nl2br, but fixes up a problem where new lines are doubled between\n * html pre tags.\n * additionally, wrap the text an $p_wrap character intervals if the config is set\n * @param string $p_string\n * @param int $p_wrap\n * @return string\n */\nfunction string_nl2br( $p_string, $p_wrap = 100 ) {\n\t$output = '';\n\t$pieces = preg_split( '/(<pre[^>]*>.*?<\\/pre>)/is', $p_string, -1, PREG_SPLIT_DELIM_CAPTURE );\n\tif( isset( $pieces[1] ) ) {\n\t\tforeach( $pieces as $piece ) {\n\t\t\tif( preg_match( '/(<pre[^>]*>.*?<\\/pre>)/is', $piece ) ) {\n\t\t\t\t$piece = preg_replace( \"/<br[^>]*?>/\", '', $piece );\n\n\t\t\t\t# @@@ thraxisp - this may want to be replaced by html_entity_decode (or equivalent)\n\t\t\t\t#     if other encoded characters are a problem\n\t\t\t\t$piece = preg_replace( '/&#160;/', ' ', $piece );\n\t\t\t\tif( ON == config_get( 'wrap_in_preformatted_text' ) ) {\n\t\t\t\t\t$output .= preg_replace( '/([^\\n]{' . $p_wrap . ',}?[\\s]+)(?!<\\/pre>)/', \"$1\\n\", $piece );\n\t\t\t\t} else {\n\t\t\t\t\t$output .= $piece;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t$output .= nl2br( $piece );\n\t\t\t}\n\t\t}\n\t\treturn $output;\n\t} else {\n\t\treturn nl2br( $p_string );\n\t}\n}\n\n/**\n * Prepare a multiple line string for display to HTML\n * @param string $p_string\n * @return string\n */\nfunction string_display( $p_string ) {\n\t$t_data = event_signal( 'EVENT_DISPLAY_TEXT', $p_string, true );\n\treturn $t_data;\n}\n\n/**\n * Prepare a single line string for display to HTML\n * @param string $p_string\n * @return string\n */\nfunction string_display_line( $p_string ) {\n\t$t_data = event_signal( 'EVENT_DISPLAY_TEXT', $p_string, false );\n\treturn $t_data;\n}\n\n/**\n * Prepare a string for display to HTML and add href anchors for URLs, emails,\n * bug references, and cvs references\n * @param string $p_string\n * @return string\n */\nfunction string_display_links( $p_string ) {\n\t$t_data = event_signal( 'EVENT_DISPLAY_FORMATTED', $p_string, true );\n\treturn $t_data;\n}\n\n/**\n * Prepare a single line string for display to HTML and add href anchors for\n * URLs, emails, bug references, and cvs references\n * @param string $p_string\n * @return string\n */\nfunction string_display_line_links( $p_string ) {\n\t$t_data = event_signal( 'EVENT_DISPLAY_FORMATTED', $p_string, false );\n\treturn $t_data;\n}\n\n/**\n * Prepare a string for display in rss\n * @param string\n * @return string\n */\nfunction string_rss_links( $p_string ) {\n\t# rss can not start with &#160; which spaces will be replaced into by string_display().\n\t$t_string = trim( $p_string );\n\n\t$t_string = event_signal( 'EVENT_DISPLAY_RSS', $t_string );\n\n\t# another escaping to escape the special characters created by the generated links\n\treturn string_html_specialchars( $t_string );\n}\n\n/**\n * Prepare a string for plain text display in email\n * @param string $p_string\n * @return string\n */\nfunction string_email( $p_string ) {\n\treturn string_strip_hrefs( $p_string );\n}\n\n/**\n * Prepare a string for plain text display in email and add URLs for bug\n * links and cvs links\n * @param string\n * @return string\n */\nfunction string_email_links( $p_string ) {\n\treturn event_signal( 'EVENT_DISPLAY_EMAIL', $p_string );\n}\n\n# --------------------\n# Process a string for display in a textarea box\n/**\n * @todo function documentation\n * @param string\n * @return string\n */\nfunction string_textarea( $p_string ) {\n\treturn string_html_specialchars( $p_string );\n}\n\n/**\n * Process a string for display in a text box\n * @param string\n * @return string\n */\nfunction string_attribute( $p_string ) {\n\treturn string_html_specialchars( $p_string );\n}\n\n/**\n * Process a string for inclusion in a URL as a GET parameter\n * @param string $p_string\n * @return string\n */\nfunction string_url( $p_string ) {\n\treturn rawurlencode( $p_string );\n}\n\n/**\n * validate the url as part of this site before continuing\n * @param string $p_url\n * @param bool $p_return_absolute\n * @return string\n */\nfunction string_sanitize_url( $p_url, $p_return_absolute = false ) {\n\t$t_url = strip_tags( urldecode( $p_url ) );\n\n\t$t_path = rtrim( config_get( 'path' ), '/' );\n\t$t_short_path = rtrim( config_get( 'short_path' ), '/' );\n\n\t$t_pattern = '(?:/*(?P<script>[^\\?#]*))(?:\\?(?P<query>[^#]*))?(?:#(?P<anchor>[^#]*))?';\n\n\t# Break the given URL into pieces for path, script, query, and anchor\n\t$t_type = 0;\n\tif ( preg_match( '@^(?P<path>' . preg_quote( $t_path, '@' ) . ')' . $t_pattern . '$@', $t_url, $t_matches ) ) {\n\t\t$t_type = 1;\n\t} else if ( !empty( $t_short_path )\n\t\t\t && preg_match( '@^(?P<path>' . preg_quote( $t_short_path, '@' ) . ')' . $t_pattern . '$@', $t_url, $t_matches )\n\t) {\n\t\t$t_type = 2;\n\t} else if ( preg_match( '@^(?P<path>)' . $t_pattern . '$@', $t_url, $t_matches ) ) {\n\t\t$t_type = 3;\n\t}\n\n\t# Check for URL's pointing to other domains\n\tif ( 0 == $t_type || empty( $t_matches['script'] ) ||\n\t\t3 == $t_type && preg_match( '@(?:[^:]*)?://@', $t_url ) > 0 ) {\n\n\t\treturn ( $p_return_absolute ? $t_path . '/' : '' ) . 'index.php';\n\t}\n\n\t# Start extracting regex matches\n\t$t_script = $t_matches['script'];\n\t$t_script_path = $t_matches['path'];\n\n\t# Clean/encode query params\n\t$t_query = '';\n\tif ( isset( $t_matches['query'] ) ) {\n\t\t$t_pairs = array();\n\t\tparse_str( html_entity_decode( $t_matches['query'] ), $t_pairs );\n\n\t\t$t_clean_pairs = array();\n\t\tforeach( $t_pairs as $t_key => $t_value ) {\n\t\t\tif ( is_array( $t_value ) ) {\n\t\t\t\tforeach( $t_value as $t_value_each ) {\n\t\t\t\t\t$t_clean_pairs[] .= rawurlencode( $t_key ) . '[]=' . rawurlencode( $t_value_each );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t$t_clean_pairs[] = rawurlencode( $t_key ) . '=' . rawurlencode( $t_value );\n\t\t\t}\n\t\t}\n\n\t\tif ( !empty( $t_clean_pairs ) ) {\n\t\t\t$t_query = '?' . join( '&', $t_clean_pairs );\n\t\t}\n\t}\n\n\t# encode link anchor\n\t$t_anchor = '';\n\tif ( isset( $t_matches['anchor'] ) ) {\n\t\t$t_anchor = '#' . rawurlencode( $t_matches['anchor'] );\n\t}\n\n\t# Return an appropriate re-combined URL string\n\tif ( $p_return_absolute ) {\n\t\treturn $t_path . '/' . $t_script . $t_query . $t_anchor;\n\t} else {\n\t\treturn ( !empty( $t_script_path ) ? $t_script_path . '/' : '' ) . $t_script . $t_query . $t_anchor;\n\t}\n}\n\n/**\n * process the $p_string and convert filenames in the format\n *  cvs:filename.ext or cvs:filename.ext:n.nn to a html link\n * if $p_include_anchor is true, include an <a href=\"...\"> tag,\n *  otherwise, just insert the URL as text\n * @param string $p_string\n * @param bool $p_include_anchor\n * @return string\n */\nfunction string_process_cvs_link( $p_string, $p_include_anchor = true ) {\n\t$t_cvs_web = config_get( 'cvs_web' );\n\n\tif( $p_include_anchor ) {\n\t\t$t_replace_with = '[CVS] <a href=\"' . $t_cvs_web . '\\\\1?rev=\\\\4\" target=\"_new\">\\\\1</a>\\\\5';\n\t} else {\n\t\t$t_replace_with = '[CVS] ' . $t_cvs_web . '\\\\1?rev=\\\\4\\\\5';\n\t}\n\n\treturn preg_replace( '/cvs:([^\\.\\s:,\\?!<]+(\\.[^\\.\\s:,\\?!<]+)*)(:)?(\\d\\.[\\d\\.]+)?([\\W\\s])?/i', $t_replace_with, $p_string );\n}\n\n$string_process_bug_link_callback = array();\n\n/**\n * Process $p_string, looking for bug ID references and creating bug view\n * links for them.\n *\n * Returns the processed string.\n *\n * If $p_include_anchor is true, include the href tag, otherwise just insert\n * the URL\n *\n * The bug tag ('#' by default) must be at the beginning of the string or\n * preceeded by a character that is not a letter, a number or an underscore\n *\n * if $p_include_anchor = false, $p_fqdn is ignored and assumed to true.\n * @param string $p_string\n * @param bool $p_include_anchor\n * @param bool $p_detail_info\n * @param bool $p_fqdn\n * @return string\n */\nfunction string_process_bug_link( $p_string, $p_include_anchor = true, $p_detail_info = true, $p_fqdn = false ) {\n\tglobal $string_process_bug_link_callback;\n\n\t$t_tag = config_get( 'bug_link_tag' );\n\n\t# bail if the link tag is blank\n\tif( '' == $t_tag || $p_string == '' ) {\n\t\treturn $p_string;\n\t}\n\n\tif( !isset( $string_process_bug_link_callback[$p_include_anchor][$p_detail_info][$p_fqdn] ) ) {\n\t\tif( $p_include_anchor ) {\n\t\t\t$string_process_bug_link_callback[$p_include_anchor][$p_detail_info][$p_fqdn] = create_function( '$p_array', '\n\t\t\t\t\t\t\t\t\t\tif ( bug_exists( (int)$p_array[2] ) && access_has_bug_level( VIEWER, (int)$p_array[2] ) ) {\n\t\t\t\t\t\t\t\t\t\t\treturn $p_array[1] . string_get_bug_view_link( (int)$p_array[2], null, ' . ( $p_detail_info ? 'true' : 'false' ) . ', ' . ( $p_fqdn ? 'true' : 'false' ) . ');\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\treturn $p_array[0];\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t' );\n\t\t} else {\n\t\t\t$string_process_bug_link_callback[$p_include_anchor][$p_detail_info][$p_fqdn] = create_function( '$p_array', '\n\t\t\t\t\t\t\t\t\t\t# We might as well create the link here even if the bug\n\t\t\t\t\t\t\t\t\t\t#  doesnt exist.  In the case above we dont want to do\n\t\t\t\t\t\t\t\t\t\t#  the summary lookup on a non-existant bug.  But here, we\n\t\t\t\t\t\t\t\t\t\t#  can create the link and by the time it is clicked on, the\n\t\t\t\t\t\t\t\t\t\t#  bug may exist.\n\t\t\t\t\t\t\t\t\t\treturn $p_array[1] . string_get_bug_view_url_with_fqdn( (int)$p_array[2], null );\n\t\t\t\t\t\t\t\t\t\t' );\n\t\t}\n\t}\n\n\t$p_string = preg_replace_callback( '/(^|[^\\w&])' . preg_quote( $t_tag, '/' ) . '(\\d+)\\b/', $string_process_bug_link_callback[$p_include_anchor][$p_detail_info][$p_fqdn], $p_string );\n\treturn $p_string;\n}\n\n$string_process_bugnote_link_callback = array();\n\n/**\n * Process $p_string, looking for bugnote ID references and creating bug view\n * links for them.\n *\n * Returns the processed string.\n *\n * If $p_include_anchor is true, include the href tag, otherwise just insert\n * the URL\n *\n * The bugnote tag ('~' by default) must be at the beginning of the string or\n * preceeded by a character that is not a letter, a number or an underscore\n *\n * if $p_include_anchor = false, $p_fqdn is ignored and assumed to true.\n * @param string $p_string\n * @param bool $p_include_anchor\n * @param bool $p_detail_info\n * @param bool $p_fqdn\n * @return string\n */\nfunction string_process_bugnote_link( $p_string, $p_include_anchor = true, $p_detail_info = true, $p_fqdn = false ) {\n\tglobal $string_process_bugnote_link_callback;\n\t$t_tag = config_get( 'bugnote_link_tag' );\n\n\t# bail if the link tag is blank\n\tif( '' == $t_tag || $p_string == '' ) {\n\t\treturn $p_string;\n\t}\n\n\tif( !isset( $string_process_bugnote_link_callback[$p_include_anchor][$p_detail_info][$p_fqdn] ) ) {\n\t\tif( $p_include_anchor ) {\n\t\t\t$string_process_bugnote_link_callback[$p_include_anchor][$p_detail_info][$p_fqdn] =\n\t\t\t\tcreate_function( '$p_array',\n\t\t\t\t\t'\n\t\t\t\t\tif ( bugnote_exists( (int)$p_array[2] ) ) {\n\t\t\t\t\t\t$t_bug_id = bugnote_get_field( (int)$p_array[2], \\'bug_id\\' );\n\t\t\t\t\t\tif ( bug_exists( $t_bug_id ) ) {\n\t\t\t\t\t\t\t$g_project_override = bug_get_field( $t_bug_id, \\'project_id\\' );\n\t\t\t\t\t\t\tif (   access_compare_level(\n\t\t\t\t\t\t\t\t\t\tuser_get_access_level( auth_get_current_user_id(),\n\t\t\t\t\t\t\t\t\t\tbug_get_field( $t_bug_id, \\'project_id\\' ) ),\n\t\t\t\t\t\t\t\t\t\tconfig_get( \\'private_bugnote_threshold\\' )\n\t\t\t\t\t\t\t\t   )\n\t\t\t\t\t\t\t\t|| bugnote_get_field( (int)$p_array[2], \\'reporter_id\\' ) == auth_get_current_user_id()\n\t\t\t\t\t\t\t\t|| bugnote_get_field( (int)$p_array[2], \\'view_state\\' ) == VS_PUBLIC\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t$g_project_override = null;\n\t\t\t\t\t\t\t\treturn $p_array[1] .\n\t\t\t\t\t\t\t\t\tstring_get_bugnote_view_link(\n\t\t\t\t\t\t\t\t\t\t$t_bug_id,\n\t\t\t\t\t\t\t\t\t\t(int)$p_array[2],\n\t\t\t\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\t\t\t\t' . ( $p_detail_info ? 'true' : 'false' ) . ', ' . ( $p_fqdn ? 'true' : 'false' ) . '\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t$g_project_override = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn $p_array[0];\n\t\t\t\t\t'\n\t\t\t\t);\n\t\t} else {\n\t\t\t$string_process_bugnote_link_callback[$p_include_anchor][$p_detail_info][$p_fqdn] =\n\t\t\t\tcreate_function(\n\t\t\t\t\t'$p_array',\n\t\t\t\t\t'\n\t\t\t\t\t# We might as well create the link here even if the bug\n\t\t\t\t\t#  doesnt exist.  In the case above we dont want to do\n\t\t\t\t\t#  the summary lookup on a non-existant bug.  But here, we\n\t\t\t\t\t#  can create the link and by the time it is clicked on, the\n\t\t\t\t\t#  bug may exist.\n\t\t\t\t\t$t_bug_id = bugnote_get_field( (int)$p_array[2], \\'bug_id\\' );\n\t\t\t\t\tif ( bug_exists( $t_bug_id ) ) {\n\t\t\t\t\t\treturn $p_array[1] . string_get_bugnote_view_url_with_fqdn( $t_bug_id, (int)$p_array[2], null );\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn $p_array[0];\n\t\t\t\t\t}\n\t\t\t\t\t'\n\t\t\t\t);\n\t\t}\n\t}\n\t$p_string = preg_replace_callback( '/(^|[^\\w])' . preg_quote( $t_tag, '/' ) . '(\\d+)\\b/', $string_process_bugnote_link_callback[$p_include_anchor][$p_detail_info][$p_fqdn], $p_string );\n\treturn $p_string;\n}\n\n/**\n * Search email addresses and URLs for a few common protocols in the given\n * string, and replace occurences with href anchors.\n * @param string $p_string\n * @return string\n */\nfunction string_insert_hrefs( $p_string ) {\n\tstatic $s_url_regex = null;\n\tstatic $s_email_regex = null;\n\tstatic $s_anchor_regex = '/(<a[^>]*>.*?<\\/a>)/is';\n\n\tif( !config_get( 'html_make_links' ) ) {\n\t\treturn $p_string;\n\t}\n\n\t$t_change_quotes = false;\n\tif( ini_get_bool( 'magic_quotes_sybase' ) && function_exists( 'ini_set' ) ) {\n\t\t$t_change_quotes = true;\n\t\tini_set( 'magic_quotes_sybase', false );\n\t}\n\n\t# Initialize static variables\n\tif ( is_null( $s_url_regex ) ) {\n\t\t# URL protocol. The regex accepts a small subset from the list of valid\n\t\t# IANA permanent and provisional schemes defined in\n\t\t# http://www.iana.org/assignments/uri-schemes/uri-schemes.xhtml\n\t\t$t_url_protocol = '(?:https?|s?ftp|file|irc[6s]?|ssh|telnet|nntp|git|svn(?:\\+ssh)?|cvs):\\/\\/';\n\n\t\t# %2A notation in url's\n\t\t$t_url_hex = '%[[:digit:]A-Fa-f]{2}';\n\n\t\t# valid set of characters that may occur in url scheme. Note: - should be first (A-F != -AF).\n\t\t$t_url_valid_chars       = '-_.,!~*\\';\\/?%^\\\\\\\\:@&={\\|}+$#[:alnum:]\\pL';\n\t\t$t_url_chars             = \"(?:${t_url_hex}|[${t_url_valid_chars}\\(\\)\\[\\]])\";\n\t\t$t_url_chars2            = \"(?:${t_url_hex}|[${t_url_valid_chars}])\";\n\t\t$t_url_chars_in_brackets = \"(?:${t_url_hex}|[${t_url_valid_chars}\\(\\)])\";\n\t\t$t_url_chars_in_parens   = \"(?:${t_url_hex}|[${t_url_valid_chars}\\[\\]])\";\n\n\t\t$t_url_part1 = \"${t_url_chars}\";\n\t\t$t_url_part2 = \"(?:\\(${t_url_chars_in_parens}*\\)|\\[${t_url_chars_in_brackets}*\\]|${t_url_chars2})\";\n\n\t\t$s_url_regex = \"/(${t_url_protocol}(${t_url_part1}*?${t_url_part2}+))/su\";\n\n\t\t# e-mail regex\n\t\t$s_email_regex = substr_replace( email_regex_simple(), '(?:mailto:)?', 1, 0 );\n\t}\n\n\t# Find any URL in a string and replace it by a clickable link\n\t$t_function = create_function( '$p_match', '\n\t\t$t_url_href = \\'href=\"\\' . rtrim( $p_match[1], \\'.\\' ) . \\'\"\\';\n\t\treturn \"<a ${t_url_href}>${p_match[1]}</a> [<a ${t_url_href} target=\\\"_blank\\\">^</a>]\";\n\t' );\n\t$p_string = preg_replace_callback( $s_url_regex, $t_function, $p_string );\n\tif( $t_change_quotes ) {\n\t\tini_set( 'magic_quotes_sybase', true );\n\t}\n\n\t# Find any email addresses in the string and replace them with a clickable\n\t# mailto: link, making sure that we skip processing of any existing anchor\n\t# tags, to avoid parts of URLs such as https://user@example.com/ or\n\t# http://user:password@example.com/ to be not treated as an email.\n\t$t_pieces = preg_split( $s_anchor_regex, $p_string, null, PREG_SPLIT_DELIM_CAPTURE );\n\t$p_string = '';\n\tforeach( $t_pieces as $piece ) {\n\t\tif( preg_match( $s_anchor_regex, $piece ) ) {\n\t\t\t$p_string .= $piece;\n\t\t} else {\n\t\t\t$p_string .= preg_replace( $s_email_regex, '<a href=\"mailto:\\0\">\\0</a>', $piece );\n\t\t}\n\t}\n\n\treturn $p_string;\n}\n\n/**\n * Detect href anchors in the string and replace them with URLs and email addresses\n * @param string $p_string\n * @return string\n */\nfunction string_strip_hrefs( $p_string ) {\n\t# First grab mailto: hrefs.  We don't care whether the URL is actually\n\t# correct - just that it's inside an href attribute.\n\t$p_string = preg_replace( '/<a\\s[^\\>]*href=\"mailto:([^\\\"]+)\"[^\\>]*>[^\\<]*<\\/a>/si', '\\1', $p_string );\n\n\t# Then grab any other href\n\t$p_string = preg_replace( '/<a\\s[^\\>]*href=\"([^\\\"]+)\"[^\\>]*>[^\\<]*<\\/a>/si', '\\1', $p_string );\n\treturn $p_string;\n}\n\n/**\n * This function looks for text with htmlentities\n * like &lt;b&gt; and converts is into corresponding\n * html < b > tag based on the configuration presets\n * @param string $p_string\n * @param bool $p_multiline\n * @return string\n */\nfunction string_restore_valid_html_tags( $p_string, $p_multiline = true ) {\n\tglobal $g_cache_html_valid_tags_single_line, $g_cache_html_valid_tags;\n\t$tags = '';\n\tif( is_blank(( $p_multiline ? $g_cache_html_valid_tags : $g_cache_html_valid_tags_single_line ) ) ) {\n\t\t$t_html_valid_tags = config_get( $p_multiline ? 'html_valid_tags' : 'html_valid_tags_single_line' );\n\n\t\tif( OFF === $t_html_valid_tags || is_blank( $t_html_valid_tags ) ) {\n\t\t\treturn $p_string;\n\t\t}\n\n\t\t$tags = explode( ',', $t_html_valid_tags );\n\t\tforeach( $tags as $key => $value ) {\n\t\t\tif( !is_blank( $value ) ) {\n\t\t\t\t$tags[$key] = trim( $value );\n\t\t\t}\n\t\t}\n\t\t$tags = implode( '|', $tags );\n\t\tif( $p_multiline ) {\n\t\t\t$g_cache_html_valid_tags = $tags;\n\t\t} else {\n\t\t\t$g_cache_html_valid_tags_single_line = $tags;\n\t\t}\n\t} else {\n\t\t$tags = ( $p_multiline ? $g_cache_html_valid_tags : $g_cache_html_valid_tags_single_line );\n\t}\n\n\t$p_string = preg_replace( '/&lt;(' . $tags . ')\\s*&gt;/ui', '<\\\\1>', $p_string );\n\t$p_string = preg_replace( '/&lt;\\/(' . $tags . ')\\s*&gt;/ui', '</\\\\1>', $p_string );\n\t$p_string = preg_replace( '/&lt;(' . $tags . ')\\s*\\/&gt;/ui', '<\\\\1 />', $p_string );\n\n\treturn $p_string;\n}\n\n/**\n * return the name of a bug page for the user\n * account for the user preference and site override\n * $p_action should be something like 'view', 'update', or 'report'\n * If $p_user_id is null or not specified, use the current user * @param string $p_action\n * @param string $p_action\n * @param int $p_user_id\n * @return string\n */\nfunction string_get_bug_page( $p_action, $p_user_id = null ) {\n\tif ( $p_action == 'view' ) {\n\t\treturn 'bug_view_page.php';\n\t}\n\n\tif ( $p_action == 'update' ) {\n\t\treturn 'bug_update_page.php';\n\t}\n\n\tif ( $p_action == 'report' ) {\n\t\treturn 'bug_report_page.php';\n\t}\n\n\ttrigger_error( ERROR_GENERIC, ERROR );\n}\n\n/**\n * return an href anchor that links to a bug VIEW page for the given bug\n * account for the user preference and site override\n * @param int $p_bug_id\n * @param int $p_user_id\n * @param bool $p_detail_info\n * @param bool $p_fqdn\n * @return string\n */\nfunction string_get_bug_view_link( $p_bug_id, $p_user_id = null, $p_detail_info = true, $p_fqdn = false ) {\n\tif( bug_exists( $p_bug_id ) ) {\n\t\t$t_link = '<a href=\"';\n\t\tif( $p_fqdn ) {\n\t\t\t$t_link .= config_get_global( 'path' );\n\t\t} else {\n\t\t\t$t_link .= config_get_global( 'short_path' );\n\t\t}\n\t\t$t_link .= string_get_bug_view_url( $p_bug_id, $p_user_id ) . '\"';\n\t\tif( $p_detail_info ) {\n\t\t\t$t_summary = string_attribute( bug_get_field( $p_bug_id, 'summary' ) );\n\t\t\t$t_status = string_attribute( get_enum_element( 'status', bug_get_field( $p_bug_id, 'status' ) ) );\n\t\t\t$t_link .= ' title=\"[' . $t_status . '] ' . $t_summary . '\"';\n\n\t\t\t$t_resolved = bug_get_field( $p_bug_id, 'status' ) >= config_get( 'bug_resolved_status_threshold' );\n\t\t\tif( $t_resolved ) {\n\t\t\t\t$t_link .= ' class=\"resolved\"';\n\t\t\t}\n\t\t}\n\t\t$t_link .= '>' . bug_format_id( $p_bug_id ) . '</a>';\n\t} else {\n\t\t$t_link = bug_format_id( $p_bug_id );\n\t}\n\n\treturn $t_link;\n}\n\n/**\n * return an href anchor that links to a bug VIEW page for the given bug\n * account for the user preference and site override\n * @param int $p_bug_id\n * @param int $p_bugnote_id\n * @param int $p_user_id\n * @param bool $p_detail_info\n * @param bool $p_fqdn\n * @return string\n */\nfunction string_get_bugnote_view_link( $p_bug_id, $p_bugnote_id, $p_user_id = null, $p_detail_info = true, $p_fqdn = false ) {\n\t$t_bug_id = (int)$p_bug_id;\n\n\tif( bug_exists( $t_bug_id ) && bugnote_exists( $p_bugnote_id ) ) {\n\t\t$t_link = '<a href=\"';\n\t\tif( $p_fqdn ) {\n\t\t\t$t_link .= config_get_global( 'path' );\n\t\t} else {\n\t\t\t$t_link .= config_get_global( 'short_path' );\n\t\t}\n\n\t\t$t_link .= string_get_bugnote_view_url( $p_bug_id, $p_bugnote_id, $p_user_id ) . '\"';\n\t\tif( $p_detail_info ) {\n\t\t\t$t_reporter = string_attribute( user_get_name( bugnote_get_field( $p_bugnote_id, 'reporter_id' ) ) );\n\t\t\t$t_update_date = string_attribute( date( config_get( 'normal_date_format' ), ( bugnote_get_field( $p_bugnote_id, 'last_modified' ) ) ) );\n\t\t\t$t_link .= ' title=\"' . bug_format_id( $t_bug_id ) . ': [' . $t_update_date . '] ' . $t_reporter . '\"';\n\t\t}\n\n\t\t$t_link .= '>' . bug_format_id( $t_bug_id ) . ':' . bugnote_format_id( $p_bugnote_id ) . '</a>';\n\t} else {\n\t\t$t_link = bugnote_format_id( $t_bug_id ) . ':' . bugnote_format_id( $p_bugnote_id );\n\t}\n\n\treturn $t_link;\n}\n\n/**\n * return the name and GET parameters of a bug VIEW page for the given bug\n * @param int $p_bug_id\n * @return string\n */\nfunction string_get_bug_view_url( $p_bug_id ) {\n\treturn 'view.php?id=' . $p_bug_id;\n}\n\n/**\n * return the name and GET parameters of a bug VIEW page for the given bug\n * @param int $p_bug_id\n * @param int $p_bugnote_id\n * @return string\n */\nfunction string_get_bugnote_view_url( $p_bug_id, $p_bugnote_id ) {\n\treturn 'view.php?id=' . $p_bug_id . '#c' . $p_bugnote_id;\n}\n\n/**\n * return the name and GET parameters of a bug VIEW page for the given bug\n * account for the user preference and site override\n * The returned url includes the fully qualified domain, hence it is suitable to be included\n * in emails.\n * @param int $p_bug_id\n * @param int $p_bugnote_id\n * @param int $p_user_id\n * @return string\n */\nfunction string_get_bugnote_view_url_with_fqdn( $p_bug_id, $p_bugnote_id, $p_user_id = null ) {\n\treturn config_get( 'path' ) . string_get_bug_view_url( $p_bug_id, $p_user_id ) . '#c' . $p_bugnote_id;\n}\n\n/**\n * return the name and GET parameters of a bug VIEW page for the given bug\n * account for the user preference and site override\n * The returned url includes the fully qualified domain, hence it is suitable to be included in emails.\n * @param int $p_bug_id\n * @param int $p_user_id\n * @return string\n */\nfunction string_get_bug_view_url_with_fqdn( $p_bug_id, $p_user_id = null ) {\n\treturn config_get( 'path' ) . string_get_bug_view_url( $p_bug_id, $p_user_id );\n}\n\n/**\n * return the name of a bug VIEW page for the user\n * account for the user preference and site override\n * @param int $p_user_id\n * @return string\n */\nfunction string_get_bug_view_page( $p_user_id = null ) {\n\treturn string_get_bug_page( 'view', $p_user_id );\n}\n\n/**\n * return an href anchor that links to a bug UPDATE page for the given bug\n * account for the user preference and site override\n * @param int $p_bug_id\n * @param int $p_user_id\n * @return string\n */\nfunction string_get_bug_update_link( $p_bug_id, $p_user_id = null ) {\n\t$t_summary = string_attribute( bug_get_field( $p_bug_id, 'summary' ) );\n\treturn '<a href=\"' . helper_mantis_url( string_get_bug_update_url( $p_bug_id, $p_user_id ) ) . '\" title=\"' . $t_summary . '\">' . bug_format_id( $p_bug_id ) . '</a>';\n}\n\n/**\n * return the name and GET parameters of a bug UPDATE page for the given bug\n * account for the user preference and site override\n * @param int $p_bug_id\n * @param int $p_user_id\n * @return string\n */\nfunction string_get_bug_update_url( $p_bug_id, $p_user_id = null ) {\n\treturn string_get_bug_update_page( $p_user_id ) . '?bug_id=' . $p_bug_id;\n}\n\n/**\n * return the name of a bug UPDATE page for the user\n * account for the user preference and site override\n * @param int $p_user_id\n * @return string\n */\nfunction string_get_bug_update_page( $p_user_id = null ) {\n\treturn string_get_bug_page( 'update', $p_user_id );\n}\n\n/**\n * return an href anchor that links to a bug REPORT page for the given bug\n * account for the user preference and site override\n * @param int $p_user_id\n * @return string\n */\nfunction string_get_bug_report_link( $p_user_id = null ) {\n\treturn '<a href=\"' . helper_mantis_url( string_get_bug_report_url( $p_user_id ) ) . '\">' . lang_get( 'report_bug_link' ) . '</a>';\n}\n\n/**\n * return the name and GET parameters of a bug REPORT page for the given bug\n * account for the user preference and site override\n * @param int $p_user_id\n * @return string\n */\nfunction string_get_bug_report_url( $p_user_id = null ) {\n\treturn string_get_bug_report_page( $p_user_id );\n}\n\n/**\n * return the name of a bug REPORT page for the user\n * account for the user preference and site override\n * @param int $p_user_id\n * @return string\n */\nfunction string_get_bug_report_page( $p_user_id = null ) {\n\treturn string_get_bug_page( 'report', $p_user_id );\n}\n\n/**\n * return the complete url link to checkin using the confirm_hash\n * @param int $p_user_id\n * @param string $p_confirm_hash\n * @return string\n */\nfunction string_get_confirm_hash_url( $p_user_id, $p_confirm_hash ) {\n\t$t_path = config_get( 'path' );\n\treturn $t_path . \"verify.php?id=\" . string_url( $p_user_id ) . \"&confirm_hash=\" . string_url( $p_confirm_hash );\n}\n\n/**\n * Format date for display\n * @param int $p_date\n * @return string\n */\nfunction string_format_complete_date( $p_date ) {\n\treturn date( config_get( 'complete_date_format' ), $p_date );\n}\n\n/**\n * Shorten a string for display on a dropdown to prevent the page rendering too wide\n * ref issues #4630, #5072, #5131\n * @param string $p_string\n * @param int $p_max\n * @return string\n */\nfunction string_shorten( $p_string, $p_max = null ) {\n\tif( $p_max === null ) {\n\t\t$t_max = config_get( 'max_dropdown_length' );\n\t} else {\n\t\t$t_max = (int) $p_max;\n\t}\n\n\tif( ( $t_max > 0 ) && ( utf8_strlen( $p_string ) > $t_max ) ) {\n\t\t$t_pattern = '/([\\s|.|,|\\-|_|\\/|\\?]+)/';\n\t\t$t_bits = preg_split( $t_pattern, $p_string, -1, PREG_SPLIT_DELIM_CAPTURE );\n\n\t\t$t_string = '';\n\t\t$t_last = $t_bits[count( $t_bits ) - 1];\n\t\t$t_last_len = strlen( $t_last );\n\n\t\tif( count( $t_bits ) == 1 ) {\n\t\t\t$t_string .= utf8_substr( $t_last, 0, $t_max - 3 );\n\t\t\t$t_string .= '...';\n\t\t} else {\n\t\t\tforeach( $t_bits as $t_bit ) {\n\t\t\t\tif(( utf8_strlen( $t_string ) + utf8_strlen( $t_bit ) + $t_last_len + 3 <= $t_max ) || ( strpos( $t_bit, '.,-/?' ) > 0 ) ) {\n\t\t\t\t\t$t_string .= $t_bit;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t$t_string .= '...' . $t_last;\n\t\t}\n\t\treturn $t_string;\n\t} else {\n\t\treturn $p_string;\n\t}\n}\n\n/**\n * Normalize a string by removing leading, trailing and excessive internal spaces\n * note a space is used as the pattern instead of '\\s' to make it work with UTF-8 strings\n * @param string $p_string\n * @return string\n */\nfunction string_normalize( $p_string ) {\n\treturn preg_replace( '/ +/', ' ', trim( $p_string ) );\n}\n\n/**\n * remap a field name to a string name (for sort filter)\n * @param string $p_string\n * @return string\n */\nfunction string_get_field_name( $p_string ) {\n\t$t_map = array(\n\t\t'attachment_count' => 'attachments',\n\t\t'category_id' => 'category',\n\t\t'handler_id' => 'assigned_to',\n\t\t'id' => 'email_bug',\n\t\t'last_updated' => 'updated',\n\t\t'project_id' => 'email_project',\n\t\t'reporter_id' => 'reporter',\n\t\t'view_state' => 'view_status',\n\t);\n\n\t$t_string = $p_string;\n\tif( isset( $t_map[$p_string] ) ) {\n\t\t$t_string = $t_map[$p_string];\n\t}\n\treturn lang_get_defaulted( $t_string );\n}\n\n/**\n * Calls htmlentities on the specified string, passing along\n * the current charset.\n * @param string $p_string\n * @return string\n */\nfunction string_html_entities( $p_string ) {\n\treturn htmlentities( $p_string, ENT_COMPAT, 'utf-8' );\n}\n\n/**\n * Calls htmlspecialchars on the specified string, handling utf8\n * @param string $p_string\n * @return string\n */\nfunction string_html_specialchars( $p_string ) {\n\t# achumakov: @ added to avoid warning output in unsupported codepages\n\t# e.g. 8859-2, windows-1257, Korean, which are treated as 8859-1.\n\t# This is VERY important for Eastern European, Baltic and Korean languages\n\treturn preg_replace( \"/&amp;(#[0-9]+|[a-z]+);/i\", \"&$1;\", @htmlspecialchars( $p_string, ENT_COMPAT, 'utf-8' ) );\n}\n\n/**\n * Prepares a string to be used as part of header().\n * @param string $p_string\n * @return string\n */\nfunction string_prepare_header( $p_string ) {\n\t$t_string= explode( \"\\n\", $p_string, 2 );\n\t$t_string= explode( \"\\r\", $t_string[0], 2 );\n\treturn $t_string[0];\n}\n\n/**\n * Checks the supplied string for scripting characters, if it contains any, then return true, otherwise return false.\n * @param string $p_string\n * @return bool\n */\nfunction string_contains_scripting_chars( $p_string ) {\n\tif(( strstr( $p_string, '<' ) !== false ) || ( strstr( $p_string, '>' ) !== false ) ) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n"], "fixing_code": ["<?php\n# MantisBT - a php based bugtracking system\n\n# MantisBT is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 2 of the License, or\n# (at your option) any later version.\n#\n# MantisBT is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with MantisBT.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * @package CoreAPI\n * @subpackage StringProcessingAPI\n * @copyright Copyright (C) 2000 - 2002  Kenzaburo Ito - kenito@300baud.org\n * @copyright Copyright (C) 2002 - 2014  MantisBT Team - mantisbt-dev@lists.sourceforge.net\n * @link http://www.mantisbt.org\n */\n\n/**\n * requires bug_api\n */\nrequire_once( 'bug_api.php' );\n\n/**\n * requires user_pref_api\n */\nrequire_once( 'user_pref_api.php' );\n\n$g_cache_html_valid_tags = '';\n$g_cache_html_valid_tags_single_line = '';\n\n/**\n * Preserve spaces at beginning of lines.\n * Lines must be separated by \\n rather than <br />\n * @param string $p_string\n * @return string\n */\n function string_preserve_spaces_at_bol( $p_string ) {\n\t$lines = explode( \"\\n\", $p_string );\n\t$line_count = count( $lines );\n\tfor( $i = 0;$i < $line_count;$i++ ) {\n\t\t$count = 0;\n\t\t$prefix = '';\n\n\t\t$t_char = utf8_substr( $lines[$i], $count, 1 );\n\t\t$spaces = 0;\n\t\twhile(( $t_char == ' ' ) || ( $t_char == \"\\t\" ) ) {\n\t\t\tif( $t_char == ' ' ) {\n\t\t\t\t$spaces++;\n\t\t\t} else {\n\t\t\t\t$spaces += 4;\n\t\t\t}\n\n\t\t\t// 1 tab = 4 spaces, can be configurable.\n\n\t\t\t$count++;\n\t\t\t$t_char = utf8_substr( $lines[$i], $count, 1 );\n\t\t}\n\n\t\tfor( $j = 0;$j < $spaces;$j++ ) {\n\t\t\t$prefix .= '&#160;';\n\t\t}\n\n\t\t$lines[$i] = $prefix . utf8_substr( $lines[$i], $count );\n\t}\n\treturn implode( \"\\n\", $lines );\n}\n\n/**\n * Prepare a string to be printed without being broken into multiple lines\n * @param string $p_string\n * @return string\n */\nfunction string_no_break( $p_string ) {\n\tif( strpos( $p_string, ' ' ) !== false ) {\n\t\treturn '<span class=\"nowrap\">' . $p_string . \"</span>\";\n\t} else {\n\t\treturn $p_string;\n\t}\n}\n\n/**\n * Similar to nl2br, but fixes up a problem where new lines are doubled between\n * html pre tags.\n * additionally, wrap the text an $p_wrap character intervals if the config is set\n * @param string $p_string\n * @param int $p_wrap\n * @return string\n */\nfunction string_nl2br( $p_string, $p_wrap = 100 ) {\n\t$output = '';\n\t$pieces = preg_split( '/(<pre[^>]*>.*?<\\/pre>)/is', $p_string, -1, PREG_SPLIT_DELIM_CAPTURE );\n\tif( isset( $pieces[1] ) ) {\n\t\tforeach( $pieces as $piece ) {\n\t\t\tif( preg_match( '/(<pre[^>]*>.*?<\\/pre>)/is', $piece ) ) {\n\t\t\t\t$piece = preg_replace( \"/<br[^>]*?>/\", '', $piece );\n\n\t\t\t\t# @@@ thraxisp - this may want to be replaced by html_entity_decode (or equivalent)\n\t\t\t\t#     if other encoded characters are a problem\n\t\t\t\t$piece = preg_replace( '/&#160;/', ' ', $piece );\n\t\t\t\tif( ON == config_get( 'wrap_in_preformatted_text' ) ) {\n\t\t\t\t\t$output .= preg_replace( '/([^\\n]{' . $p_wrap . ',}?[\\s]+)(?!<\\/pre>)/', \"$1\\n\", $piece );\n\t\t\t\t} else {\n\t\t\t\t\t$output .= $piece;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t$output .= nl2br( $piece );\n\t\t\t}\n\t\t}\n\t\treturn $output;\n\t} else {\n\t\treturn nl2br( $p_string );\n\t}\n}\n\n/**\n * Prepare a multiple line string for display to HTML\n * @param string $p_string\n * @return string\n */\nfunction string_display( $p_string ) {\n\t$t_data = event_signal( 'EVENT_DISPLAY_TEXT', $p_string, true );\n\treturn $t_data;\n}\n\n/**\n * Prepare a single line string for display to HTML\n * @param string $p_string\n * @return string\n */\nfunction string_display_line( $p_string ) {\n\t$t_data = event_signal( 'EVENT_DISPLAY_TEXT', $p_string, false );\n\treturn $t_data;\n}\n\n/**\n * Prepare a string for display to HTML and add href anchors for URLs, emails,\n * bug references, and cvs references\n * @param string $p_string\n * @return string\n */\nfunction string_display_links( $p_string ) {\n\t$t_data = event_signal( 'EVENT_DISPLAY_FORMATTED', $p_string, true );\n\treturn $t_data;\n}\n\n/**\n * Prepare a single line string for display to HTML and add href anchors for\n * URLs, emails, bug references, and cvs references\n * @param string $p_string\n * @return string\n */\nfunction string_display_line_links( $p_string ) {\n\t$t_data = event_signal( 'EVENT_DISPLAY_FORMATTED', $p_string, false );\n\treturn $t_data;\n}\n\n/**\n * Prepare a string for display in rss\n * @param string\n * @return string\n */\nfunction string_rss_links( $p_string ) {\n\t# rss can not start with &#160; which spaces will be replaced into by string_display().\n\t$t_string = trim( $p_string );\n\n\t$t_string = event_signal( 'EVENT_DISPLAY_RSS', $t_string );\n\n\t# another escaping to escape the special characters created by the generated links\n\treturn string_html_specialchars( $t_string );\n}\n\n/**\n * Prepare a string for plain text display in email\n * @param string $p_string\n * @return string\n */\nfunction string_email( $p_string ) {\n\treturn string_strip_hrefs( $p_string );\n}\n\n/**\n * Prepare a string for plain text display in email and add URLs for bug\n * links and cvs links\n * @param string\n * @return string\n */\nfunction string_email_links( $p_string ) {\n\treturn event_signal( 'EVENT_DISPLAY_EMAIL', $p_string );\n}\n\n# --------------------\n# Process a string for display in a textarea box\n/**\n * @todo function documentation\n * @param string\n * @return string\n */\nfunction string_textarea( $p_string ) {\n\treturn string_html_specialchars( $p_string );\n}\n\n/**\n * Process a string for display in a text box\n * @param string\n * @return string\n */\nfunction string_attribute( $p_string ) {\n\treturn string_html_specialchars( $p_string );\n}\n\n/**\n * Process a string for inclusion in a URL as a GET parameter\n * @param string $p_string\n * @return string\n */\nfunction string_url( $p_string ) {\n\treturn rawurlencode( $p_string );\n}\n\n/**\n * validate the url as part of this site before continuing\n * @param string $p_url\n * @param bool $p_return_absolute\n * @return string\n */\nfunction string_sanitize_url( $p_url, $p_return_absolute = false ) {\n\t$t_url = strip_tags( urldecode( $p_url ) );\n\n\t$t_path = rtrim( config_get( 'path' ), '/' );\n\t$t_short_path = rtrim( config_get( 'short_path' ), '/' );\n\n\t$t_pattern = '(?:/*(?P<script>[^\\?#]*))(?:\\?(?P<query>[^#]*))?(?:#(?P<anchor>[^#]*))?';\n\n\t# Break the given URL into pieces for path, script, query, and anchor\n\t$t_type = 0;\n\tif ( preg_match( '@^(?P<path>' . preg_quote( $t_path, '@' ) . ')' . $t_pattern . '$@', $t_url, $t_matches ) ) {\n\t\t$t_type = 1;\n\t} else if ( !empty( $t_short_path )\n\t\t\t && preg_match( '@^(?P<path>' . preg_quote( $t_short_path, '@' ) . ')' . $t_pattern . '$@', $t_url, $t_matches )\n\t) {\n\t\t$t_type = 2;\n\t} else if ( preg_match( '@^(?P<path>)' . $t_pattern . '$@', $t_url, $t_matches ) ) {\n\t\t$t_type = 3;\n\t}\n\n\t# Check for URL's pointing to other domains\n\tif ( 0 == $t_type || empty( $t_matches['script'] ) ||\n\t\t3 == $t_type && preg_match( '@(?:[^:]*)?:/*@', $t_url ) > 0 ) {\n\t\treturn ( $p_return_absolute ? $t_path . '/' : '' ) . 'index.php';\n\t}\n\n\t# Start extracting regex matches\n\t$t_script = $t_matches['script'];\n\t$t_script_path = $t_matches['path'];\n\n\t# Clean/encode query params\n\t$t_query = '';\n\tif ( isset( $t_matches['query'] ) ) {\n\t\t$t_pairs = array();\n\t\tparse_str( html_entity_decode( $t_matches['query'] ), $t_pairs );\n\n\t\t$t_clean_pairs = array();\n\t\tforeach( $t_pairs as $t_key => $t_value ) {\n\t\t\tif ( is_array( $t_value ) ) {\n\t\t\t\tforeach( $t_value as $t_value_each ) {\n\t\t\t\t\t$t_clean_pairs[] .= rawurlencode( $t_key ) . '[]=' . rawurlencode( $t_value_each );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t$t_clean_pairs[] = rawurlencode( $t_key ) . '=' . rawurlencode( $t_value );\n\t\t\t}\n\t\t}\n\n\t\tif ( !empty( $t_clean_pairs ) ) {\n\t\t\t$t_query = '?' . join( '&', $t_clean_pairs );\n\t\t}\n\t}\n\n\t# encode link anchor\n\t$t_anchor = '';\n\tif ( isset( $t_matches['anchor'] ) ) {\n\t\t$t_anchor = '#' . rawurlencode( $t_matches['anchor'] );\n\t}\n\n\t# Return an appropriate re-combined URL string\n\tif ( $p_return_absolute ) {\n\t\treturn $t_path . '/' . $t_script . $t_query . $t_anchor;\n\t} else {\n\t\treturn ( !empty( $t_script_path ) ? $t_script_path . '/' : '' ) . $t_script . $t_query . $t_anchor;\n\t}\n}\n\n/**\n * process the $p_string and convert filenames in the format\n *  cvs:filename.ext or cvs:filename.ext:n.nn to a html link\n * if $p_include_anchor is true, include an <a href=\"...\"> tag,\n *  otherwise, just insert the URL as text\n * @param string $p_string\n * @param bool $p_include_anchor\n * @return string\n */\nfunction string_process_cvs_link( $p_string, $p_include_anchor = true ) {\n\t$t_cvs_web = config_get( 'cvs_web' );\n\n\tif( $p_include_anchor ) {\n\t\t$t_replace_with = '[CVS] <a href=\"' . $t_cvs_web . '\\\\1?rev=\\\\4\" target=\"_new\">\\\\1</a>\\\\5';\n\t} else {\n\t\t$t_replace_with = '[CVS] ' . $t_cvs_web . '\\\\1?rev=\\\\4\\\\5';\n\t}\n\n\treturn preg_replace( '/cvs:([^\\.\\s:,\\?!<]+(\\.[^\\.\\s:,\\?!<]+)*)(:)?(\\d\\.[\\d\\.]+)?([\\W\\s])?/i', $t_replace_with, $p_string );\n}\n\n$string_process_bug_link_callback = array();\n\n/**\n * Process $p_string, looking for bug ID references and creating bug view\n * links for them.\n *\n * Returns the processed string.\n *\n * If $p_include_anchor is true, include the href tag, otherwise just insert\n * the URL\n *\n * The bug tag ('#' by default) must be at the beginning of the string or\n * preceeded by a character that is not a letter, a number or an underscore\n *\n * if $p_include_anchor = false, $p_fqdn is ignored and assumed to true.\n * @param string $p_string\n * @param bool $p_include_anchor\n * @param bool $p_detail_info\n * @param bool $p_fqdn\n * @return string\n */\nfunction string_process_bug_link( $p_string, $p_include_anchor = true, $p_detail_info = true, $p_fqdn = false ) {\n\tglobal $string_process_bug_link_callback;\n\n\t$t_tag = config_get( 'bug_link_tag' );\n\n\t# bail if the link tag is blank\n\tif( '' == $t_tag || $p_string == '' ) {\n\t\treturn $p_string;\n\t}\n\n\tif( !isset( $string_process_bug_link_callback[$p_include_anchor][$p_detail_info][$p_fqdn] ) ) {\n\t\tif( $p_include_anchor ) {\n\t\t\t$string_process_bug_link_callback[$p_include_anchor][$p_detail_info][$p_fqdn] = create_function( '$p_array', '\n\t\t\t\t\t\t\t\t\t\tif ( bug_exists( (int)$p_array[2] ) && access_has_bug_level( VIEWER, (int)$p_array[2] ) ) {\n\t\t\t\t\t\t\t\t\t\t\treturn $p_array[1] . string_get_bug_view_link( (int)$p_array[2], null, ' . ( $p_detail_info ? 'true' : 'false' ) . ', ' . ( $p_fqdn ? 'true' : 'false' ) . ');\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\treturn $p_array[0];\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t' );\n\t\t} else {\n\t\t\t$string_process_bug_link_callback[$p_include_anchor][$p_detail_info][$p_fqdn] = create_function( '$p_array', '\n\t\t\t\t\t\t\t\t\t\t# We might as well create the link here even if the bug\n\t\t\t\t\t\t\t\t\t\t#  doesnt exist.  In the case above we dont want to do\n\t\t\t\t\t\t\t\t\t\t#  the summary lookup on a non-existant bug.  But here, we\n\t\t\t\t\t\t\t\t\t\t#  can create the link and by the time it is clicked on, the\n\t\t\t\t\t\t\t\t\t\t#  bug may exist.\n\t\t\t\t\t\t\t\t\t\treturn $p_array[1] . string_get_bug_view_url_with_fqdn( (int)$p_array[2], null );\n\t\t\t\t\t\t\t\t\t\t' );\n\t\t}\n\t}\n\n\t$p_string = preg_replace_callback( '/(^|[^\\w&])' . preg_quote( $t_tag, '/' ) . '(\\d+)\\b/', $string_process_bug_link_callback[$p_include_anchor][$p_detail_info][$p_fqdn], $p_string );\n\treturn $p_string;\n}\n\n$string_process_bugnote_link_callback = array();\n\n/**\n * Process $p_string, looking for bugnote ID references and creating bug view\n * links for them.\n *\n * Returns the processed string.\n *\n * If $p_include_anchor is true, include the href tag, otherwise just insert\n * the URL\n *\n * The bugnote tag ('~' by default) must be at the beginning of the string or\n * preceeded by a character that is not a letter, a number or an underscore\n *\n * if $p_include_anchor = false, $p_fqdn is ignored and assumed to true.\n * @param string $p_string\n * @param bool $p_include_anchor\n * @param bool $p_detail_info\n * @param bool $p_fqdn\n * @return string\n */\nfunction string_process_bugnote_link( $p_string, $p_include_anchor = true, $p_detail_info = true, $p_fqdn = false ) {\n\tglobal $string_process_bugnote_link_callback;\n\t$t_tag = config_get( 'bugnote_link_tag' );\n\n\t# bail if the link tag is blank\n\tif( '' == $t_tag || $p_string == '' ) {\n\t\treturn $p_string;\n\t}\n\n\tif( !isset( $string_process_bugnote_link_callback[$p_include_anchor][$p_detail_info][$p_fqdn] ) ) {\n\t\tif( $p_include_anchor ) {\n\t\t\t$string_process_bugnote_link_callback[$p_include_anchor][$p_detail_info][$p_fqdn] =\n\t\t\t\tcreate_function( '$p_array',\n\t\t\t\t\t'\n\t\t\t\t\tif ( bugnote_exists( (int)$p_array[2] ) ) {\n\t\t\t\t\t\t$t_bug_id = bugnote_get_field( (int)$p_array[2], \\'bug_id\\' );\n\t\t\t\t\t\tif ( bug_exists( $t_bug_id ) ) {\n\t\t\t\t\t\t\t$g_project_override = bug_get_field( $t_bug_id, \\'project_id\\' );\n\t\t\t\t\t\t\tif (   access_compare_level(\n\t\t\t\t\t\t\t\t\t\tuser_get_access_level( auth_get_current_user_id(),\n\t\t\t\t\t\t\t\t\t\tbug_get_field( $t_bug_id, \\'project_id\\' ) ),\n\t\t\t\t\t\t\t\t\t\tconfig_get( \\'private_bugnote_threshold\\' )\n\t\t\t\t\t\t\t\t   )\n\t\t\t\t\t\t\t\t|| bugnote_get_field( (int)$p_array[2], \\'reporter_id\\' ) == auth_get_current_user_id()\n\t\t\t\t\t\t\t\t|| bugnote_get_field( (int)$p_array[2], \\'view_state\\' ) == VS_PUBLIC\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t$g_project_override = null;\n\t\t\t\t\t\t\t\treturn $p_array[1] .\n\t\t\t\t\t\t\t\t\tstring_get_bugnote_view_link(\n\t\t\t\t\t\t\t\t\t\t$t_bug_id,\n\t\t\t\t\t\t\t\t\t\t(int)$p_array[2],\n\t\t\t\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\t\t\t\t' . ( $p_detail_info ? 'true' : 'false' ) . ', ' . ( $p_fqdn ? 'true' : 'false' ) . '\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t$g_project_override = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn $p_array[0];\n\t\t\t\t\t'\n\t\t\t\t);\n\t\t} else {\n\t\t\t$string_process_bugnote_link_callback[$p_include_anchor][$p_detail_info][$p_fqdn] =\n\t\t\t\tcreate_function(\n\t\t\t\t\t'$p_array',\n\t\t\t\t\t'\n\t\t\t\t\t# We might as well create the link here even if the bug\n\t\t\t\t\t#  doesnt exist.  In the case above we dont want to do\n\t\t\t\t\t#  the summary lookup on a non-existant bug.  But here, we\n\t\t\t\t\t#  can create the link and by the time it is clicked on, the\n\t\t\t\t\t#  bug may exist.\n\t\t\t\t\t$t_bug_id = bugnote_get_field( (int)$p_array[2], \\'bug_id\\' );\n\t\t\t\t\tif ( bug_exists( $t_bug_id ) ) {\n\t\t\t\t\t\treturn $p_array[1] . string_get_bugnote_view_url_with_fqdn( $t_bug_id, (int)$p_array[2], null );\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn $p_array[0];\n\t\t\t\t\t}\n\t\t\t\t\t'\n\t\t\t\t);\n\t\t}\n\t}\n\t$p_string = preg_replace_callback( '/(^|[^\\w])' . preg_quote( $t_tag, '/' ) . '(\\d+)\\b/', $string_process_bugnote_link_callback[$p_include_anchor][$p_detail_info][$p_fqdn], $p_string );\n\treturn $p_string;\n}\n\n/**\n * Search email addresses and URLs for a few common protocols in the given\n * string, and replace occurences with href anchors.\n * @param string $p_string\n * @return string\n */\nfunction string_insert_hrefs( $p_string ) {\n\tstatic $s_url_regex = null;\n\tstatic $s_email_regex = null;\n\tstatic $s_anchor_regex = '/(<a[^>]*>.*?<\\/a>)/is';\n\n\tif( !config_get( 'html_make_links' ) ) {\n\t\treturn $p_string;\n\t}\n\n\t$t_change_quotes = false;\n\tif( ini_get_bool( 'magic_quotes_sybase' ) && function_exists( 'ini_set' ) ) {\n\t\t$t_change_quotes = true;\n\t\tini_set( 'magic_quotes_sybase', false );\n\t}\n\n\t# Initialize static variables\n\tif ( is_null( $s_url_regex ) ) {\n\t\t# URL protocol. The regex accepts a small subset from the list of valid\n\t\t# IANA permanent and provisional schemes defined in\n\t\t# http://www.iana.org/assignments/uri-schemes/uri-schemes.xhtml\n\t\t$t_url_protocol = '(?:https?|s?ftp|file|irc[6s]?|ssh|telnet|nntp|git|svn(?:\\+ssh)?|cvs):\\/\\/';\n\n\t\t# %2A notation in url's\n\t\t$t_url_hex = '%[[:digit:]A-Fa-f]{2}';\n\n\t\t# valid set of characters that may occur in url scheme. Note: - should be first (A-F != -AF).\n\t\t$t_url_valid_chars       = '-_.,!~*\\';\\/?%^\\\\\\\\:@&={\\|}+$#[:alnum:]\\pL';\n\t\t$t_url_chars             = \"(?:${t_url_hex}|[${t_url_valid_chars}\\(\\)\\[\\]])\";\n\t\t$t_url_chars2            = \"(?:${t_url_hex}|[${t_url_valid_chars}])\";\n\t\t$t_url_chars_in_brackets = \"(?:${t_url_hex}|[${t_url_valid_chars}\\(\\)])\";\n\t\t$t_url_chars_in_parens   = \"(?:${t_url_hex}|[${t_url_valid_chars}\\[\\]])\";\n\n\t\t$t_url_part1 = \"${t_url_chars}\";\n\t\t$t_url_part2 = \"(?:\\(${t_url_chars_in_parens}*\\)|\\[${t_url_chars_in_brackets}*\\]|${t_url_chars2})\";\n\n\t\t$s_url_regex = \"/(${t_url_protocol}(${t_url_part1}*?${t_url_part2}+))/su\";\n\n\t\t# e-mail regex\n\t\t$s_email_regex = substr_replace( email_regex_simple(), '(?:mailto:)?', 1, 0 );\n\t}\n\n\t# Find any URL in a string and replace it by a clickable link\n\t$t_function = create_function( '$p_match', '\n\t\t$t_url_href = \\'href=\"\\' . rtrim( $p_match[1], \\'.\\' ) . \\'\"\\';\n\t\treturn \"<a ${t_url_href}>${p_match[1]}</a> [<a ${t_url_href} target=\\\"_blank\\\">^</a>]\";\n\t' );\n\t$p_string = preg_replace_callback( $s_url_regex, $t_function, $p_string );\n\tif( $t_change_quotes ) {\n\t\tini_set( 'magic_quotes_sybase', true );\n\t}\n\n\t# Find any email addresses in the string and replace them with a clickable\n\t# mailto: link, making sure that we skip processing of any existing anchor\n\t# tags, to avoid parts of URLs such as https://user@example.com/ or\n\t# http://user:password@example.com/ to be not treated as an email.\n\t$t_pieces = preg_split( $s_anchor_regex, $p_string, null, PREG_SPLIT_DELIM_CAPTURE );\n\t$p_string = '';\n\tforeach( $t_pieces as $piece ) {\n\t\tif( preg_match( $s_anchor_regex, $piece ) ) {\n\t\t\t$p_string .= $piece;\n\t\t} else {\n\t\t\t$p_string .= preg_replace( $s_email_regex, '<a href=\"mailto:\\0\">\\0</a>', $piece );\n\t\t}\n\t}\n\n\treturn $p_string;\n}\n\n/**\n * Detect href anchors in the string and replace them with URLs and email addresses\n * @param string $p_string\n * @return string\n */\nfunction string_strip_hrefs( $p_string ) {\n\t# First grab mailto: hrefs.  We don't care whether the URL is actually\n\t# correct - just that it's inside an href attribute.\n\t$p_string = preg_replace( '/<a\\s[^\\>]*href=\"mailto:([^\\\"]+)\"[^\\>]*>[^\\<]*<\\/a>/si', '\\1', $p_string );\n\n\t# Then grab any other href\n\t$p_string = preg_replace( '/<a\\s[^\\>]*href=\"([^\\\"]+)\"[^\\>]*>[^\\<]*<\\/a>/si', '\\1', $p_string );\n\treturn $p_string;\n}\n\n/**\n * This function looks for text with htmlentities\n * like &lt;b&gt; and converts is into corresponding\n * html < b > tag based on the configuration presets\n * @param string $p_string\n * @param bool $p_multiline\n * @return string\n */\nfunction string_restore_valid_html_tags( $p_string, $p_multiline = true ) {\n\tglobal $g_cache_html_valid_tags_single_line, $g_cache_html_valid_tags;\n\t$tags = '';\n\tif( is_blank(( $p_multiline ? $g_cache_html_valid_tags : $g_cache_html_valid_tags_single_line ) ) ) {\n\t\t$t_html_valid_tags = config_get( $p_multiline ? 'html_valid_tags' : 'html_valid_tags_single_line' );\n\n\t\tif( OFF === $t_html_valid_tags || is_blank( $t_html_valid_tags ) ) {\n\t\t\treturn $p_string;\n\t\t}\n\n\t\t$tags = explode( ',', $t_html_valid_tags );\n\t\tforeach( $tags as $key => $value ) {\n\t\t\tif( !is_blank( $value ) ) {\n\t\t\t\t$tags[$key] = trim( $value );\n\t\t\t}\n\t\t}\n\t\t$tags = implode( '|', $tags );\n\t\tif( $p_multiline ) {\n\t\t\t$g_cache_html_valid_tags = $tags;\n\t\t} else {\n\t\t\t$g_cache_html_valid_tags_single_line = $tags;\n\t\t}\n\t} else {\n\t\t$tags = ( $p_multiline ? $g_cache_html_valid_tags : $g_cache_html_valid_tags_single_line );\n\t}\n\n\t$p_string = preg_replace( '/&lt;(' . $tags . ')\\s*&gt;/ui', '<\\\\1>', $p_string );\n\t$p_string = preg_replace( '/&lt;\\/(' . $tags . ')\\s*&gt;/ui', '</\\\\1>', $p_string );\n\t$p_string = preg_replace( '/&lt;(' . $tags . ')\\s*\\/&gt;/ui', '<\\\\1 />', $p_string );\n\n\treturn $p_string;\n}\n\n/**\n * return the name of a bug page for the user\n * account for the user preference and site override\n * $p_action should be something like 'view', 'update', or 'report'\n * If $p_user_id is null or not specified, use the current user * @param string $p_action\n * @param string $p_action\n * @param int $p_user_id\n * @return string\n */\nfunction string_get_bug_page( $p_action, $p_user_id = null ) {\n\tif ( $p_action == 'view' ) {\n\t\treturn 'bug_view_page.php';\n\t}\n\n\tif ( $p_action == 'update' ) {\n\t\treturn 'bug_update_page.php';\n\t}\n\n\tif ( $p_action == 'report' ) {\n\t\treturn 'bug_report_page.php';\n\t}\n\n\ttrigger_error( ERROR_GENERIC, ERROR );\n}\n\n/**\n * return an href anchor that links to a bug VIEW page for the given bug\n * account for the user preference and site override\n * @param int $p_bug_id\n * @param int $p_user_id\n * @param bool $p_detail_info\n * @param bool $p_fqdn\n * @return string\n */\nfunction string_get_bug_view_link( $p_bug_id, $p_user_id = null, $p_detail_info = true, $p_fqdn = false ) {\n\tif( bug_exists( $p_bug_id ) ) {\n\t\t$t_link = '<a href=\"';\n\t\tif( $p_fqdn ) {\n\t\t\t$t_link .= config_get_global( 'path' );\n\t\t} else {\n\t\t\t$t_link .= config_get_global( 'short_path' );\n\t\t}\n\t\t$t_link .= string_get_bug_view_url( $p_bug_id, $p_user_id ) . '\"';\n\t\tif( $p_detail_info ) {\n\t\t\t$t_summary = string_attribute( bug_get_field( $p_bug_id, 'summary' ) );\n\t\t\t$t_status = string_attribute( get_enum_element( 'status', bug_get_field( $p_bug_id, 'status' ) ) );\n\t\t\t$t_link .= ' title=\"[' . $t_status . '] ' . $t_summary . '\"';\n\n\t\t\t$t_resolved = bug_get_field( $p_bug_id, 'status' ) >= config_get( 'bug_resolved_status_threshold' );\n\t\t\tif( $t_resolved ) {\n\t\t\t\t$t_link .= ' class=\"resolved\"';\n\t\t\t}\n\t\t}\n\t\t$t_link .= '>' . bug_format_id( $p_bug_id ) . '</a>';\n\t} else {\n\t\t$t_link = bug_format_id( $p_bug_id );\n\t}\n\n\treturn $t_link;\n}\n\n/**\n * return an href anchor that links to a bug VIEW page for the given bug\n * account for the user preference and site override\n * @param int $p_bug_id\n * @param int $p_bugnote_id\n * @param int $p_user_id\n * @param bool $p_detail_info\n * @param bool $p_fqdn\n * @return string\n */\nfunction string_get_bugnote_view_link( $p_bug_id, $p_bugnote_id, $p_user_id = null, $p_detail_info = true, $p_fqdn = false ) {\n\t$t_bug_id = (int)$p_bug_id;\n\n\tif( bug_exists( $t_bug_id ) && bugnote_exists( $p_bugnote_id ) ) {\n\t\t$t_link = '<a href=\"';\n\t\tif( $p_fqdn ) {\n\t\t\t$t_link .= config_get_global( 'path' );\n\t\t} else {\n\t\t\t$t_link .= config_get_global( 'short_path' );\n\t\t}\n\n\t\t$t_link .= string_get_bugnote_view_url( $p_bug_id, $p_bugnote_id, $p_user_id ) . '\"';\n\t\tif( $p_detail_info ) {\n\t\t\t$t_reporter = string_attribute( user_get_name( bugnote_get_field( $p_bugnote_id, 'reporter_id' ) ) );\n\t\t\t$t_update_date = string_attribute( date( config_get( 'normal_date_format' ), ( bugnote_get_field( $p_bugnote_id, 'last_modified' ) ) ) );\n\t\t\t$t_link .= ' title=\"' . bug_format_id( $t_bug_id ) . ': [' . $t_update_date . '] ' . $t_reporter . '\"';\n\t\t}\n\n\t\t$t_link .= '>' . bug_format_id( $t_bug_id ) . ':' . bugnote_format_id( $p_bugnote_id ) . '</a>';\n\t} else {\n\t\t$t_link = bugnote_format_id( $t_bug_id ) . ':' . bugnote_format_id( $p_bugnote_id );\n\t}\n\n\treturn $t_link;\n}\n\n/**\n * return the name and GET parameters of a bug VIEW page for the given bug\n * @param int $p_bug_id\n * @return string\n */\nfunction string_get_bug_view_url( $p_bug_id ) {\n\treturn 'view.php?id=' . $p_bug_id;\n}\n\n/**\n * return the name and GET parameters of a bug VIEW page for the given bug\n * @param int $p_bug_id\n * @param int $p_bugnote_id\n * @return string\n */\nfunction string_get_bugnote_view_url( $p_bug_id, $p_bugnote_id ) {\n\treturn 'view.php?id=' . $p_bug_id . '#c' . $p_bugnote_id;\n}\n\n/**\n * return the name and GET parameters of a bug VIEW page for the given bug\n * account for the user preference and site override\n * The returned url includes the fully qualified domain, hence it is suitable to be included\n * in emails.\n * @param int $p_bug_id\n * @param int $p_bugnote_id\n * @param int $p_user_id\n * @return string\n */\nfunction string_get_bugnote_view_url_with_fqdn( $p_bug_id, $p_bugnote_id, $p_user_id = null ) {\n\treturn config_get( 'path' ) . string_get_bug_view_url( $p_bug_id, $p_user_id ) . '#c' . $p_bugnote_id;\n}\n\n/**\n * return the name and GET parameters of a bug VIEW page for the given bug\n * account for the user preference and site override\n * The returned url includes the fully qualified domain, hence it is suitable to be included in emails.\n * @param int $p_bug_id\n * @param int $p_user_id\n * @return string\n */\nfunction string_get_bug_view_url_with_fqdn( $p_bug_id, $p_user_id = null ) {\n\treturn config_get( 'path' ) . string_get_bug_view_url( $p_bug_id, $p_user_id );\n}\n\n/**\n * return the name of a bug VIEW page for the user\n * account for the user preference and site override\n * @param int $p_user_id\n * @return string\n */\nfunction string_get_bug_view_page( $p_user_id = null ) {\n\treturn string_get_bug_page( 'view', $p_user_id );\n}\n\n/**\n * return an href anchor that links to a bug UPDATE page for the given bug\n * account for the user preference and site override\n * @param int $p_bug_id\n * @param int $p_user_id\n * @return string\n */\nfunction string_get_bug_update_link( $p_bug_id, $p_user_id = null ) {\n\t$t_summary = string_attribute( bug_get_field( $p_bug_id, 'summary' ) );\n\treturn '<a href=\"' . helper_mantis_url( string_get_bug_update_url( $p_bug_id, $p_user_id ) ) . '\" title=\"' . $t_summary . '\">' . bug_format_id( $p_bug_id ) . '</a>';\n}\n\n/**\n * return the name and GET parameters of a bug UPDATE page for the given bug\n * account for the user preference and site override\n * @param int $p_bug_id\n * @param int $p_user_id\n * @return string\n */\nfunction string_get_bug_update_url( $p_bug_id, $p_user_id = null ) {\n\treturn string_get_bug_update_page( $p_user_id ) . '?bug_id=' . $p_bug_id;\n}\n\n/**\n * return the name of a bug UPDATE page for the user\n * account for the user preference and site override\n * @param int $p_user_id\n * @return string\n */\nfunction string_get_bug_update_page( $p_user_id = null ) {\n\treturn string_get_bug_page( 'update', $p_user_id );\n}\n\n/**\n * return an href anchor that links to a bug REPORT page for the given bug\n * account for the user preference and site override\n * @param int $p_user_id\n * @return string\n */\nfunction string_get_bug_report_link( $p_user_id = null ) {\n\treturn '<a href=\"' . helper_mantis_url( string_get_bug_report_url( $p_user_id ) ) . '\">' . lang_get( 'report_bug_link' ) . '</a>';\n}\n\n/**\n * return the name and GET parameters of a bug REPORT page for the given bug\n * account for the user preference and site override\n * @param int $p_user_id\n * @return string\n */\nfunction string_get_bug_report_url( $p_user_id = null ) {\n\treturn string_get_bug_report_page( $p_user_id );\n}\n\n/**\n * return the name of a bug REPORT page for the user\n * account for the user preference and site override\n * @param int $p_user_id\n * @return string\n */\nfunction string_get_bug_report_page( $p_user_id = null ) {\n\treturn string_get_bug_page( 'report', $p_user_id );\n}\n\n/**\n * return the complete url link to checkin using the confirm_hash\n * @param int $p_user_id\n * @param string $p_confirm_hash\n * @return string\n */\nfunction string_get_confirm_hash_url( $p_user_id, $p_confirm_hash ) {\n\t$t_path = config_get( 'path' );\n\treturn $t_path . \"verify.php?id=\" . string_url( $p_user_id ) . \"&confirm_hash=\" . string_url( $p_confirm_hash );\n}\n\n/**\n * Format date for display\n * @param int $p_date\n * @return string\n */\nfunction string_format_complete_date( $p_date ) {\n\treturn date( config_get( 'complete_date_format' ), $p_date );\n}\n\n/**\n * Shorten a string for display on a dropdown to prevent the page rendering too wide\n * ref issues #4630, #5072, #5131\n * @param string $p_string\n * @param int $p_max\n * @return string\n */\nfunction string_shorten( $p_string, $p_max = null ) {\n\tif( $p_max === null ) {\n\t\t$t_max = config_get( 'max_dropdown_length' );\n\t} else {\n\t\t$t_max = (int) $p_max;\n\t}\n\n\tif( ( $t_max > 0 ) && ( utf8_strlen( $p_string ) > $t_max ) ) {\n\t\t$t_pattern = '/([\\s|.|,|\\-|_|\\/|\\?]+)/';\n\t\t$t_bits = preg_split( $t_pattern, $p_string, -1, PREG_SPLIT_DELIM_CAPTURE );\n\n\t\t$t_string = '';\n\t\t$t_last = $t_bits[count( $t_bits ) - 1];\n\t\t$t_last_len = strlen( $t_last );\n\n\t\tif( count( $t_bits ) == 1 ) {\n\t\t\t$t_string .= utf8_substr( $t_last, 0, $t_max - 3 );\n\t\t\t$t_string .= '...';\n\t\t} else {\n\t\t\tforeach( $t_bits as $t_bit ) {\n\t\t\t\tif(( utf8_strlen( $t_string ) + utf8_strlen( $t_bit ) + $t_last_len + 3 <= $t_max ) || ( strpos( $t_bit, '.,-/?' ) > 0 ) ) {\n\t\t\t\t\t$t_string .= $t_bit;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t$t_string .= '...' . $t_last;\n\t\t}\n\t\treturn $t_string;\n\t} else {\n\t\treturn $p_string;\n\t}\n}\n\n/**\n * Normalize a string by removing leading, trailing and excessive internal spaces\n * note a space is used as the pattern instead of '\\s' to make it work with UTF-8 strings\n * @param string $p_string\n * @return string\n */\nfunction string_normalize( $p_string ) {\n\treturn preg_replace( '/ +/', ' ', trim( $p_string ) );\n}\n\n/**\n * remap a field name to a string name (for sort filter)\n * @param string $p_string\n * @return string\n */\nfunction string_get_field_name( $p_string ) {\n\t$t_map = array(\n\t\t'attachment_count' => 'attachments',\n\t\t'category_id' => 'category',\n\t\t'handler_id' => 'assigned_to',\n\t\t'id' => 'email_bug',\n\t\t'last_updated' => 'updated',\n\t\t'project_id' => 'email_project',\n\t\t'reporter_id' => 'reporter',\n\t\t'view_state' => 'view_status',\n\t);\n\n\t$t_string = $p_string;\n\tif( isset( $t_map[$p_string] ) ) {\n\t\t$t_string = $t_map[$p_string];\n\t}\n\treturn lang_get_defaulted( $t_string );\n}\n\n/**\n * Calls htmlentities on the specified string, passing along\n * the current charset.\n * @param string $p_string\n * @return string\n */\nfunction string_html_entities( $p_string ) {\n\treturn htmlentities( $p_string, ENT_COMPAT, 'utf-8' );\n}\n\n/**\n * Calls htmlspecialchars on the specified string, handling utf8\n * @param string $p_string\n * @return string\n */\nfunction string_html_specialchars( $p_string ) {\n\t# achumakov: @ added to avoid warning output in unsupported codepages\n\t# e.g. 8859-2, windows-1257, Korean, which are treated as 8859-1.\n\t# This is VERY important for Eastern European, Baltic and Korean languages\n\treturn preg_replace( \"/&amp;(#[0-9]+|[a-z]+);/i\", \"&$1;\", @htmlspecialchars( $p_string, ENT_COMPAT, 'utf-8' ) );\n}\n\n/**\n * Prepares a string to be used as part of header().\n * @param string $p_string\n * @return string\n */\nfunction string_prepare_header( $p_string ) {\n\t$t_string= explode( \"\\n\", $p_string, 2 );\n\t$t_string= explode( \"\\r\", $t_string[0], 2 );\n\treturn $t_string[0];\n}\n\n/**\n * Checks the supplied string for scripting characters, if it contains any, then return true, otherwise return false.\n * @param string $p_string\n * @return bool\n */\nfunction string_contains_scripting_chars( $p_string ) {\n\tif(( strstr( $p_string, '<' ) !== false ) || ( strstr( $p_string, '>' ) !== false ) ) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n"], "filenames": ["core/string_api.php"], "buggy_code_start_loc": [255], "buggy_code_end_loc": [257], "fixing_code_start_loc": [255], "fixing_code_end_loc": [256], "type": "CWE-79", "message": "Cross-site scripting (XSS) vulnerability in MantisBT before 1.2.19 and 1.3.x before 1.3.0-beta.2 allows remote attackers to inject arbitrary web script or HTML via the url parameter to permalink_page.php.", "other": {"cve": {"id": "CVE-2014-9701", "sourceIdentifier": "cve@mitre.org", "published": "2017-08-09T18:29:00.510", "lastModified": "2017-08-17T17:49:02.840", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Cross-site scripting (XSS) vulnerability in MantisBT before 1.2.19 and 1.3.x before 1.3.0-beta.2 allows remote attackers to inject arbitrary web script or HTML via the url parameter to permalink_page.php."}, {"lang": "es", "value": "Una vulnerabilidad de tipo cross-site scripting (XSS) en MantisBT en versiones anteriores a la 1.2.19 y en versiones 1.3.x anteriores a la 1.3.0-beta.2 permite que atacantes remotos inyecten scripts web o HTML mediante el par\u00e1metro url a permalink_page.php."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 2.5}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.2.18", "matchCriteriaId": "449F99FC-A5C4-4858-9013-C88827660E20"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mantisbt:mantisbt:1.3.0:beta1:*:*:*:*:*:*", "matchCriteriaId": "D355450F-4354-4E0B-BA86-A6BCF0672E1A"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2015/03/15/2", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1202885", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/mantisbt/mantisbt/commit/d95f070db852614fa18ccca6a4f12f4bffede1fd", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/mantisbt/mantisbt/commit/e7e2b5503580e42db9d91e0d599d61d3ff03c27e", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.mantisbt.org/bugs/view.php?id=17362#c40613", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "https://www.mantisbt.org/bugs/view.php?id=19493", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/mantisbt/mantisbt/commit/d95f070db852614fa18ccca6a4f12f4bffede1fd"}}