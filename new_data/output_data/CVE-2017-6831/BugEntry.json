{"buggy_code": ["/*\n\tAudio File Library\n\tCopyright (C) 1998-2000, 2003-2004, 2010-2013, Michael Pruett <michael@68k.org>\n\tCopyright (C) 2000-2002, Silicon Graphics, Inc.\n\tCopyright (C) 2002-2003, Davy Durham\n\n\tThis library is free software; you can redistribute it and/or\n\tmodify it under the terms of the GNU Lesser General Public\n\tLicense as published by the Free Software Foundation; either\n\tversion 2.1 of the License, or (at your option) any later version.\n\n\tThis library is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n\tLesser General Public License for more details.\n\n\tYou should have received a copy of the GNU Lesser General Public\n\tLicense along with this library; if not, write to the\n\tFree Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n\tBoston, MA  02110-1301  USA\n*/\n\n/*\n\tWAVE.cpp\n\n\tThis file contains code for reading and writing RIFF WAVE format\n\tsound files.\n*/\n\n#include \"config.h\"\n#include \"WAVE.h\"\n\n#include <assert.h>\n#include <math.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"File.h\"\n#include \"Instrument.h\"\n#include \"Marker.h\"\n#include \"Setup.h\"\n#include \"Tag.h\"\n#include \"Track.h\"\n#include \"UUID.h\"\n#include \"byteorder.h\"\n#include \"util.h\"\n\n/* These constants are from RFC 2361. */\nenum\n{\n\tWAVE_FORMAT_UNKNOWN = 0x0000,\t/* Microsoft Unknown Wave Format */\n\tWAVE_FORMAT_PCM = 0x0001,\t/* Microsoft PCM Format */\n\tWAVE_FORMAT_ADPCM = 0x0002,\t/* Microsoft ADPCM Format */\n\tWAVE_FORMAT_IEEE_FLOAT = 0x0003,\t/* IEEE Float */\n\tWAVE_FORMAT_VSELP = 0x0004,\t/* Compaq Computer's VSELP */\n\tWAVE_FORMAT_IBM_CVSD = 0x0005,\t/* IBM CVSD */\n\tWAVE_FORMAT_ALAW = 0x0006,\t/* Microsoft ALAW */\n\tWAVE_FORMAT_MULAW = 0x0007,\t/* Microsoft MULAW */\n\tWAVE_FORMAT_OKI_ADPCM = 0x0010,\t/* OKI ADPCM */\n\tWAVE_FORMAT_DVI_ADPCM = 0x0011,\t/* Intel's DVI ADPCM */\n\tWAVE_FORMAT_MEDIASPACE_ADPCM = 0x0012,\t/* Videologic's MediaSpace ADPCM */\n\tWAVE_FORMAT_SIERRA_ADPCM = 0x0013,\t/* Sierra ADPCM */\n\tWAVE_FORMAT_G723_ADPCM = 0x0014,\t/* G.723 ADPCM */\n\tWAVE_FORMAT_DIGISTD = 0x0015,\t/* DSP Solutions' DIGISTD */\n\tWAVE_FORMAT_DIGIFIX = 0x0016,\t/* DSP Solutions' DIGIFIX */\n\tWAVE_FORMAT_DIALOGIC_OKI_ADPCM = 0x0017,\t/* Dialogic OKI ADPCM */\n\tWAVE_FORMAT_MEDIAVISION_ADPCM = 0x0018,\t/* MediaVision ADPCM */\n\tWAVE_FORMAT_CU_CODEC = 0x0019,\t/* HP CU */\n\tWAVE_FORMAT_YAMAHA_ADPCM = 0x0020,\t/* Yamaha ADPCM */\n\tWAVE_FORMAT_SONARC = 0x0021,\t/* Speech Compression's Sonarc */\n\tWAVE_FORMAT_DSP_TRUESPEECH = 0x0022,\t/* DSP Group's True Speech */\n\tWAVE_FORMAT_ECHOSC1 = 0x0023,\t/* Echo Speech's EchoSC1 */\n\tWAVE_FORMAT_AUDIOFILE_AF36 = 0x0024,\t/* Audiofile AF36 */\n\tWAVE_FORMAT_APTX = 0x0025,\t/* APTX */\n\tWAVE_FORMAT_DOLBY_AC2 = 0x0030,\t/* Dolby AC2 */\n\tWAVE_FORMAT_GSM610 = 0x0031,\t/* GSM610 */\n\tWAVE_FORMAT_MSNAUDIO = 0x0032,\t/* MSNAudio */\n\tWAVE_FORMAT_ANTEX_ADPCME = 0x0033,\t/* Antex ADPCME */\n\n\tWAVE_FORMAT_MPEG = 0x0050,\t\t/* MPEG */\n\tWAVE_FORMAT_MPEGLAYER3 = 0x0055,\t/* MPEG layer 3 */\n\tWAVE_FORMAT_LUCENT_G723 = 0x0059,\t/* Lucent G.723 */\n\tWAVE_FORMAT_G726_ADPCM = 0x0064,\t/* G.726 ADPCM */\n\tWAVE_FORMAT_G722_ADPCM = 0x0065,\t/* G.722 ADPCM */\n\n\tIBM_FORMAT_MULAW = 0x0101,\n\tIBM_FORMAT_ALAW = 0x0102,\n\tIBM_FORMAT_ADPCM = 0x0103,\n\n\tWAVE_FORMAT_CREATIVE_ADPCM = 0x0200,\n\n\tWAVE_FORMAT_EXTENSIBLE = 0xfffe\n};\n\nconst int _af_wave_compression_types[_AF_WAVE_NUM_COMPTYPES] =\n{\n\tAF_COMPRESSION_G711_ULAW,\n\tAF_COMPRESSION_G711_ALAW,\n\tAF_COMPRESSION_IMA,\n\tAF_COMPRESSION_MS_ADPCM\n};\n\nconst InstParamInfo _af_wave_inst_params[_AF_WAVE_NUM_INSTPARAMS] =\n{\n\t{ AF_INST_MIDI_BASENOTE, AU_PVTYPE_LONG, \"MIDI base note\", {60} },\n\t{ AF_INST_NUMCENTS_DETUNE, AU_PVTYPE_LONG, \"Detune in cents\", {0} },\n\t{ AF_INST_MIDI_LOVELOCITY, AU_PVTYPE_LONG, \"Low velocity\", {1} },\n\t{ AF_INST_MIDI_HIVELOCITY, AU_PVTYPE_LONG, \"High velocity\", {127} },\n\t{ AF_INST_MIDI_LONOTE, AU_PVTYPE_LONG, \"Low note\", {0} },\n\t{ AF_INST_MIDI_HINOTE, AU_PVTYPE_LONG, \"High note\", {127} },\n\t{ AF_INST_NUMDBS_GAIN, AU_PVTYPE_LONG, \"Gain in dB\", {0} }\n};\n\nstatic const _AFfilesetup waveDefaultFileSetup =\n{\n\t_AF_VALID_FILESETUP,\t/* valid */\n\tAF_FILE_WAVE,\t\t/* fileFormat */\n\ttrue,\t\t\t/* trackSet */\n\ttrue,\t\t\t/* instrumentSet */\n\ttrue,\t\t\t/* miscellaneousSet  */\n\t1,\t\t\t/* trackCount */\n\tNULL,\t\t\t/* tracks */\n\t0,\t\t\t/* instrumentCount */\n\tNULL,\t\t\t/* instruments */\n\t0,\t\t\t/* miscellaneousCount */\n\tNULL\t\t\t/* miscellaneous */\n};\n\nstatic const UUID _af_wave_guid_pcm =\n{{\n\t0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,\n\t0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71\n}};\nstatic const UUID _af_wave_guid_ieee_float =\n{{\n\t0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,\n\t0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71\n}};\nstatic const UUID _af_wave_guid_ulaw =\n{{\n\t0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,\n\t0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71\n}};\nstatic const UUID _af_wave_guid_alaw =\n{{\n\t0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,\n\t0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71\n}};\n\nWAVEFile::WAVEFile()\n{\n\tsetFormatByteOrder(AF_BYTEORDER_LITTLEENDIAN);\n\n\tm_factOffset = 0;\n\tm_miscellaneousOffset = 0;\n\tm_markOffset = 0;\n\tm_dataSizeOffset = 0;\n\n\tm_msadpcmNumCoefficients = 0;\n}\n\nstatus WAVEFile::parseFrameCount(const Tag &id, uint32_t size)\n{\n\tTrack *track = getTrack();\n\n\tuint32_t totalFrames;\n\treadU32(&totalFrames);\n\n\ttrack->totalfframes = totalFrames;\n\n\treturn AF_SUCCEED;\n}\n\nstatus WAVEFile::parseFormat(const Tag &id, uint32_t size)\n{\n\tTrack *track = getTrack();\n\n\tuint16_t formatTag;\n\treadU16(&formatTag);\n\tuint16_t channelCount;\n\treadU16(&channelCount);\n\tuint32_t sampleRate;\n\treadU32(&sampleRate);\n\tuint32_t averageBytesPerSecond;\n\treadU32(&averageBytesPerSecond);\n\tuint16_t blockAlign;\n\treadU16(&blockAlign);\n\n\tif (!channelCount)\n\t{\n\t\t_af_error(AF_BAD_CHANNELS, \"invalid file with 0 channels\");\n\t\treturn AF_FAIL;\n\t}\n\n\ttrack->f.channelCount = channelCount;\n\ttrack->f.sampleRate = sampleRate;\n\ttrack->f.byteOrder = AF_BYTEORDER_LITTLEENDIAN;\n\n\t/* Default to uncompressed audio data. */\n\ttrack->f.compressionType = AF_COMPRESSION_NONE;\n\ttrack->f.framesPerPacket = 1;\n\n\tswitch (formatTag)\n\t{\n\t\tcase WAVE_FORMAT_PCM:\n\t\t{\n\t\t\tuint16_t bitsPerSample;\n\t\t\treadU16(&bitsPerSample);\n\n\t\t\ttrack->f.sampleWidth = bitsPerSample;\n\n\t\t\tif (bitsPerSample == 0 || bitsPerSample > 32)\n\t\t\t{\n\t\t\t\t_af_error(AF_BAD_WIDTH,\n\t\t\t\t\t\"bad sample width of %d bits\",\n\t\t\t\t\tbitsPerSample);\n\t\t\t\treturn AF_FAIL;\n\t\t\t}\n\n\t\t\tif (bitsPerSample <= 8)\n\t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_UNSIGNED;\n\t\t\telse\n\t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n\t\t}\n\t\tbreak;\n\n\t\tcase WAVE_FORMAT_MULAW:\n\t\tcase IBM_FORMAT_MULAW:\n\t\t\ttrack->f.sampleWidth = 16;\n\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n\t\t\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n\t\t\ttrack->f.compressionType = AF_COMPRESSION_G711_ULAW;\n\t\t\ttrack->f.bytesPerPacket = track->f.channelCount;\n\t\t\tbreak;\n\n\t\tcase WAVE_FORMAT_ALAW:\n\t\tcase IBM_FORMAT_ALAW:\n\t\t\ttrack->f.sampleWidth = 16;\n\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n\t\t\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n\t\t\ttrack->f.compressionType = AF_COMPRESSION_G711_ALAW;\n\t\t\ttrack->f.bytesPerPacket = track->f.channelCount;\n\t\t\tbreak;\n\n\t\tcase WAVE_FORMAT_IEEE_FLOAT:\n\t\t{\n\t\t\tuint16_t bitsPerSample;\n\t\t\treadU16(&bitsPerSample);\n\n\t\t\tif (bitsPerSample == 64)\n\t\t\t{\n\t\t\t\ttrack->f.sampleWidth = 64;\n\t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_DOUBLE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttrack->f.sampleWidth = 32;\n\t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_FLOAT;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase WAVE_FORMAT_ADPCM:\n\t\t{\n\t\t\tuint16_t bitsPerSample, extraByteCount,\n\t\t\t\t\tsamplesPerBlock, numCoefficients;\n\n\t\t\tif (track->f.channelCount != 1 &&\n\t\t\t\ttrack->f.channelCount != 2)\n\t\t\t{\n\t\t\t\t_af_error(AF_BAD_CHANNELS,\n\t\t\t\t\t\"WAVE file with MS ADPCM compression \"\n\t\t\t\t\t\"must have 1 or 2 channels\");\n\t\t\t}\n\n\t\t\treadU16(&bitsPerSample);\n\t\t\treadU16(&extraByteCount);\n\t\t\treadU16(&samplesPerBlock);\n\t\t\treadU16(&numCoefficients);\n\n\t\t\t/* numCoefficients should be at least 7. */\n\t\t\tassert(numCoefficients >= 7 && numCoefficients <= 255);\n\n\t\t\tm_msadpcmNumCoefficients = numCoefficients;\n\n\t\t\tfor (int i=0; i<m_msadpcmNumCoefficients; i++)\n\t\t\t{\n\t\t\t\treadS16(&m_msadpcmCoefficients[i][0]);\n\t\t\t\treadS16(&m_msadpcmCoefficients[i][1]);\n\t\t\t}\n\n\t\t\ttrack->f.sampleWidth = 16;\n\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n\t\t\ttrack->f.compressionType = AF_COMPRESSION_MS_ADPCM;\n\t\t\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n\n\t\t\ttrack->f.framesPerPacket = samplesPerBlock;\n\t\t\ttrack->f.bytesPerPacket = blockAlign;\n\n\t\t\t// Create the parameter list.\n\t\t\tAUpvlist pv = AUpvnew(2);\n\t\t\tAUpvsetparam(pv, 0, _AF_MS_ADPCM_NUM_COEFFICIENTS);\n\t\t\tAUpvsetvaltype(pv, 0, AU_PVTYPE_LONG);\n\t\t\tlong l = m_msadpcmNumCoefficients;\n\t\t\tAUpvsetval(pv, 0, &l);\n\n\t\t\tAUpvsetparam(pv, 1, _AF_MS_ADPCM_COEFFICIENTS);\n\t\t\tAUpvsetvaltype(pv, 1, AU_PVTYPE_PTR);\n\t\t\tvoid *v = m_msadpcmCoefficients;\n\t\t\tAUpvsetval(pv, 1, &v);\n\n\t\t\ttrack->f.compressionParams = pv;\n\t\t}\n\t\tbreak;\n\n\t\tcase WAVE_FORMAT_DVI_ADPCM:\n\t\t{\n\t\t\tuint16_t bitsPerSample, extraByteCount, samplesPerBlock;\n\n\t\t\treadU16(&bitsPerSample);\n\t\t\treadU16(&extraByteCount);\n\t\t\treadU16(&samplesPerBlock);\n\n\t\t\tif (bitsPerSample != 4)\n\t\t\t{\n\t\t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED,\n\t\t\t\t\t\"IMA ADPCM compression supports only 4 bits per sample\");\n\t\t\t}\n\n\t\t\tint bytesPerBlock = (samplesPerBlock + 14) / 8 * 4 * channelCount;\n\t\t\tif (bytesPerBlock > blockAlign || (samplesPerBlock % 8) != 1)\n\t\t\t{\n\t\t\t\t_af_error(AF_BAD_CODEC_CONFIG,\n\t\t\t\t\t\"Invalid samples per block for IMA ADPCM compression\");\n\t\t\t}\n\n\t\t\ttrack->f.sampleWidth = 16;\n\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n\t\t\ttrack->f.compressionType = AF_COMPRESSION_IMA;\n\t\t\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n\n\t\t\tinitIMACompressionParams();\n\n\t\t\ttrack->f.framesPerPacket = samplesPerBlock;\n\t\t\ttrack->f.bytesPerPacket = blockAlign;\n\t\t}\n\t\tbreak;\n\n\t\tcase WAVE_FORMAT_EXTENSIBLE:\n\t\t{\n\t\t\tuint16_t bitsPerSample;\n\t\t\treadU16(&bitsPerSample);\n\t\t\tuint16_t extraByteCount;\n\t\t\treadU16(&extraByteCount);\n\t\t\tuint16_t reserved;\n\t\t\treadU16(&reserved);\n\t\t\tuint32_t channelMask;\n\t\t\treadU32(&channelMask);\n\t\t\tUUID subformat;\n\t\t\treadUUID(&subformat);\n\t\t\tif (subformat == _af_wave_guid_pcm)\n\t\t\t{\n\t\t\t\ttrack->f.sampleWidth = bitsPerSample;\n\n\t\t\t\tif (bitsPerSample == 0 || bitsPerSample > 32)\n\t\t\t\t{\n\t\t\t\t\t_af_error(AF_BAD_WIDTH,\n\t\t\t\t\t\t\"bad sample width of %d bits\",\n\t\t\t\t\t\tbitsPerSample);\n\t\t\t\t\treturn AF_FAIL;\n\t\t\t\t}\n\n\t\t\t\t// Use valid bits per sample if bytes per sample is the same.\n\t\t\t\tif (reserved <= bitsPerSample &&\n\t\t\t\t\t(reserved + 7) / 8 == (bitsPerSample + 7) / 8)\n\t\t\t\t\ttrack->f.sampleWidth = reserved;\n\n\t\t\t\tif (bitsPerSample <= 8)\n\t\t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_UNSIGNED;\n\t\t\t\telse\n\t\t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n\t\t\t}\n\t\t\telse if (subformat == _af_wave_guid_ieee_float)\n\t\t\t{\n\t\t\t\tif (bitsPerSample == 64)\n\t\t\t\t{\n\t\t\t\t\ttrack->f.sampleWidth = 64;\n\t\t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_DOUBLE;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttrack->f.sampleWidth = 32;\n\t\t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_FLOAT;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (subformat == _af_wave_guid_alaw ||\n\t\t\t\tsubformat == _af_wave_guid_ulaw)\n\t\t\t{\n\t\t\t\ttrack->f.compressionType = subformat == _af_wave_guid_alaw ?\n\t\t\t\t\tAF_COMPRESSION_G711_ALAW : AF_COMPRESSION_G711_ULAW;\n\t\t\t\ttrack->f.sampleWidth = 16;\n\t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n\t\t\t\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n\t\t\t\ttrack->f.bytesPerPacket = channelCount;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"WAVE extensible data format %s is not currently supported\", subformat.name().c_str());\n\t\t\t\treturn AF_FAIL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase WAVE_FORMAT_YAMAHA_ADPCM:\n\t\tcase WAVE_FORMAT_OKI_ADPCM:\n\t\tcase WAVE_FORMAT_CREATIVE_ADPCM:\n\t\tcase IBM_FORMAT_ADPCM:\n\t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"WAVE ADPCM data format 0x%x is not currently supported\", formatTag);\n\t\t\treturn AF_FAIL;\n\t\t\tbreak;\n\n\t\tcase WAVE_FORMAT_MPEG:\n\t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"WAVE MPEG data format is not supported\");\n\t\t\treturn AF_FAIL;\n\t\t\tbreak;\n\n\t\tcase WAVE_FORMAT_MPEGLAYER3:\n\t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"WAVE MPEG layer 3 data format is not supported\");\n\t\t\treturn AF_FAIL;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"WAVE file data format 0x%x not currently supported != 0xfffe ? %d, != EXTENSIBLE? %d\", formatTag, formatTag != 0xfffe, formatTag != WAVE_FORMAT_EXTENSIBLE);\n\t\t\treturn AF_FAIL;\n\t\t\tbreak;\n\t}\n\n\tif (track->f.isUncompressed())\n\t\ttrack->f.computeBytesPerPacketPCM();\n\n\t_af_set_sample_format(&track->f, track->f.sampleFormat, track->f.sampleWidth);\n\n\treturn AF_SUCCEED;\n}\n\nstatus WAVEFile::parseData(const Tag &id, uint32_t size)\n{\n\tTrack *track = getTrack();\n\n\ttrack->fpos_first_frame = m_fh->tell();\n\ttrack->data_size = size;\n\n\treturn AF_SUCCEED;\n}\n\nstatus WAVEFile::parsePlayList(const Tag &id, uint32_t size)\n{\n\tuint32_t segmentCount;\n\treadU32(&segmentCount);\n\n\tif (segmentCount == 0)\n\t{\n\t\tm_instrumentCount = 0;\n\t\tm_instruments = NULL;\n\t\treturn AF_SUCCEED;\n\t}\n\n\tfor (unsigned segment=0; segment<segmentCount; segment++)\n\t{\n\t\tuint32_t startMarkID, loopLength, loopCount;\n\n\t\treadU32(&startMarkID);\n\t\treadU32(&loopLength);\n\t\treadU32(&loopCount);\n\t}\n\n\treturn AF_SUCCEED;\n}\n\nstatus WAVEFile::parseCues(const Tag &id, uint32_t size)\n{\n\tTrack *track = getTrack();\n\n\tuint32_t markerCount;\n\treadU32(&markerCount);\n\ttrack->markerCount = markerCount;\n\n\tif (markerCount == 0)\n\t{\n\t\ttrack->markers = NULL;\n\t\treturn AF_SUCCEED;\n\t}\n\n\tif ((track->markers = _af_marker_new(markerCount)) == NULL)\n\t\treturn AF_FAIL;\n\n\tfor (unsigned i=0; i<markerCount; i++)\n\t{\n\t\tuint32_t id, position, chunkid;\n\t\tuint32_t chunkByteOffset, blockByteOffset;\n\t\tuint32_t sampleFrameOffset;\n\t\tMarker *marker = &track->markers[i];\n\n\t\treadU32(&id);\n\t\treadU32(&position);\n\t\treadU32(&chunkid);\n\t\treadU32(&chunkByteOffset);\n\t\treadU32(&blockByteOffset);\n\n\t\t/*\n\t\t\tsampleFrameOffset represents the position of\n\t\t\tthe mark in units of frames.\n\t\t*/\n\t\treadU32(&sampleFrameOffset);\n\n\t\tmarker->id = id;\n\t\tmarker->position = sampleFrameOffset;\n\t\tmarker->name = _af_strdup(\"\");\n\t\tmarker->comment = _af_strdup(\"\");\n\t}\n\n\treturn AF_SUCCEED;\n}\n\n/* Parse an adtl sub-chunk within a LIST chunk. */\nstatus WAVEFile::parseADTLSubChunk(const Tag &id, uint32_t size)\n{\n\tTrack *track = getTrack();\n\n\tAFfileoffset endPos = m_fh->tell() + size;\n\n\twhile (m_fh->tell() < endPos)\n\t{\n\t\tTag chunkID;\n\t\tuint32_t chunkSize;\n\n\t\treadTag(&chunkID);\n\t\treadU32(&chunkSize);\n\n\t\tif (chunkID == \"labl\" || chunkID == \"note\")\n\t\t{\n\t\t\tuint32_t id;\n\t\t\tlong length=chunkSize-4;\n\t\t\tchar *p = (char *) _af_malloc(length);\n\n\t\t\treadU32(&id);\n\t\t\tm_fh->read(p, length);\n\n\t\t\tMarker *marker = track->getMarker(id);\n\n\t\t\tif (marker)\n\t\t\t{\n\t\t\t\tif (chunkID == \"labl\")\n\t\t\t\t{\n\t\t\t\t\tfree(marker->name);\n\t\t\t\t\tmarker->name = p;\n\t\t\t\t}\n\t\t\t\telse if (chunkID == \"note\")\n\t\t\t\t{\n\t\t\t\t\tfree(marker->comment);\n\t\t\t\t\tmarker->comment = p;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tfree(p);\n\t\t\t}\n\t\t\telse\n\t\t\t\tfree(p);\n\n\t\t\t/*\n\t\t\t\tIf chunkSize is odd, skip an extra byte\n\t\t\t\tat the end of the chunk.\n\t\t\t*/\n\t\t\tif ((chunkSize % 2) != 0)\n\t\t\t\tm_fh->seek(1, File::SeekFromCurrent);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* If chunkSize is odd, skip an extra byte. */\n\t\t\tm_fh->seek(chunkSize + (chunkSize % 2), File::SeekFromCurrent);\n\t\t}\n\t}\n\treturn AF_SUCCEED;\n}\n\n/* Parse an INFO sub-chunk within a LIST chunk. */\nstatus WAVEFile::parseINFOSubChunk(const Tag &id, uint32_t size)\n{\n\tAFfileoffset endPos = m_fh->tell() + size;\n\n\twhile (m_fh->tell() < endPos)\n\t{\n\t\tint misctype = AF_MISC_UNRECOGNIZED;\n\t\tTag miscid;\n\t\tuint32_t miscsize;\n\n\t\treadTag(&miscid);\n\t\treadU32(&miscsize);\n\n\t\tif (miscid == \"IART\")\n\t\t\tmisctype = AF_MISC_AUTH;\n\t\telse if (miscid == \"INAM\")\n\t\t\tmisctype = AF_MISC_NAME;\n\t\telse if (miscid == \"ICOP\")\n\t\t\tmisctype = AF_MISC_COPY;\n\t\telse if (miscid == \"ICMT\")\n\t\t\tmisctype = AF_MISC_ICMT;\n\t\telse if (miscid == \"ICRD\")\n\t\t\tmisctype = AF_MISC_ICRD;\n\t\telse if (miscid == \"ISFT\")\n\t\t\tmisctype = AF_MISC_ISFT;\n\n\t\tif (misctype != AF_MISC_UNRECOGNIZED)\n\t\t{\n\t\t\tchar *string = (char *) _af_malloc(miscsize);\n\n\t\t\tm_fh->read(string, miscsize);\n\n\t\t\tm_miscellaneousCount++;\n\t\t\tm_miscellaneous = (Miscellaneous *) _af_realloc(m_miscellaneous, sizeof (Miscellaneous) * m_miscellaneousCount);\n\n\t\t\tm_miscellaneous[m_miscellaneousCount-1].id = m_miscellaneousCount;\n\t\t\tm_miscellaneous[m_miscellaneousCount-1].type = misctype;\n\t\t\tm_miscellaneous[m_miscellaneousCount-1].size = miscsize;\n\t\t\tm_miscellaneous[m_miscellaneousCount-1].position = 0;\n\t\t\tm_miscellaneous[m_miscellaneousCount-1].buffer = string;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tm_fh->seek(miscsize, File::SeekFromCurrent);\n\t\t}\n\n\t\t/* Make the current position an even number of bytes.  */\n\t\tif (miscsize % 2 != 0)\n\t\t\tm_fh->seek(1, File::SeekFromCurrent);\n\t}\n\treturn AF_SUCCEED;\n}\n\nstatus WAVEFile::parseList(const Tag &id, uint32_t size)\n{\n\tTag typeID;\n\treadTag(&typeID);\n\tsize-=4;\n\n\tif (typeID == \"adtl\")\n\t{\n\t\t/* Handle adtl sub-chunks. */\n\t\treturn parseADTLSubChunk(typeID, size);\n\t}\n\telse if (typeID == \"INFO\")\n\t{\n\t\t/* Handle INFO sub-chunks. */\n\t\treturn parseINFOSubChunk(typeID, size);\n\t}\n\telse\n\t{\n\t\t/* Skip unhandled sub-chunks. */\n\t\tm_fh->seek(size, File::SeekFromCurrent);\n\t\treturn AF_SUCCEED;\n\t}\n\treturn AF_SUCCEED;\n}\n\nstatus WAVEFile::parseInstrument(const Tag &id, uint32_t size)\n{\n\tuint8_t baseNote;\n\tint8_t detune, gain;\n\tuint8_t lowNote, highNote, lowVelocity, highVelocity;\n\tuint8_t padByte;\n\n\treadU8(&baseNote);\n\treadS8(&detune);\n\treadS8(&gain);\n\treadU8(&lowNote);\n\treadU8(&highNote);\n\treadU8(&lowVelocity);\n\treadU8(&highVelocity);\n\treadU8(&padByte);\n\n\treturn AF_SUCCEED;\n}\n\nbool WAVEFile::recognize(File *fh)\n{\n\tuint8_t buffer[8];\n\n\tfh->seek(0, File::SeekFromBeginning);\n\n\tif (fh->read(buffer, 8) != 8 || memcmp(buffer, \"RIFF\", 4) != 0)\n\t\treturn false;\n\tif (fh->read(buffer, 4) != 4 || memcmp(buffer, \"WAVE\", 4) != 0)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatus WAVEFile::readInit(AFfilesetup setup)\n{\n\tTag type, formtype;\n\tuint32_t size;\n\tuint32_t index = 0;\n\n\tbool hasFormat = false;\n\tbool hasData = false;\n\tbool hasFrameCount = false;\n\n\tTrack *track = allocateTrack();\n\n\tm_fh->seek(0, File::SeekFromBeginning);\n\n\treadTag(&type);\n\treadU32(&size);\n\treadTag(&formtype);\n\n\tassert(type == \"RIFF\");\n\tassert(formtype == \"WAVE\");\n\n\t/* Include the offset of the form type. */\n\tindex += 4;\n\n\twhile (index < size)\n\t{\n\t\tTag chunkid;\n\t\tuint32_t chunksize = 0;\n\t\tstatus result;\n\n\t\treadTag(&chunkid);\n\t\treadU32(&chunksize);\n\n\t\tif (chunkid == \"fmt \")\n\t\t{\n\t\t\tresult = parseFormat(chunkid, chunksize);\n\t\t\tif (result == AF_FAIL)\n\t\t\t\treturn AF_FAIL;\n\n\t\t\thasFormat = true;\n\t\t}\n\t\telse if (chunkid == \"data\")\n\t\t{\n\t\t\t/* The format chunk must precede the data chunk. */\n\t\t\tif (!hasFormat)\n\t\t\t{\n\t\t\t\t_af_error(AF_BAD_HEADER, \"missing format chunk in WAVE file\");\n\t\t\t\treturn AF_FAIL;\n\t\t\t}\n\n\t\t\tresult = parseData(chunkid, chunksize);\n\t\t\tif (result == AF_FAIL)\n\t\t\t\treturn AF_FAIL;\n\n\t\t\thasData = true;\n\t\t}\n\t\telse if (chunkid == \"inst\")\n\t\t{\n\t\t\tresult = parseInstrument(chunkid, chunksize);\n\t\t\tif (result == AF_FAIL)\n\t\t\t\treturn AF_FAIL;\n\t\t}\n\t\telse if (chunkid == \"fact\")\n\t\t{\n\t\t\thasFrameCount = true;\n\t\t\tresult = parseFrameCount(chunkid, chunksize);\n\t\t\tif (result == AF_FAIL)\n\t\t\t\treturn AF_FAIL;\n\t\t}\n\t\telse if (chunkid == \"cue \")\n\t\t{\n\t\t\tresult = parseCues(chunkid, chunksize);\n\t\t\tif (result == AF_FAIL)\n\t\t\t\treturn AF_FAIL;\n\t\t}\n\t\telse if (chunkid == \"LIST\" || chunkid == \"list\")\n\t\t{\n\t\t\tresult = parseList(chunkid, chunksize);\n\t\t\tif (result == AF_FAIL)\n\t\t\t\treturn AF_FAIL;\n\t\t}\n\t\telse if (chunkid == \"INST\")\n\t\t{\n\t\t\tresult = parseInstrument(chunkid, chunksize);\n\t\t\tif (result == AF_FAIL)\n\t\t\t\treturn AF_FAIL;\n\t\t}\n\t\telse if (chunkid == \"plst\")\n\t\t{\n\t\t\tresult = parsePlayList(chunkid, chunksize);\n\t\t\tif (result == AF_FAIL)\n\t\t\t\treturn AF_FAIL;\n\t\t}\n\n\t\tindex += chunksize + 8;\n\n\t\t/* All chunks must be aligned on an even number of bytes */\n\t\tif ((index % 2) != 0)\n\t\t\tindex++;\n\n\t\tm_fh->seek(index + 8, File::SeekFromBeginning);\n\t}\n\n\t/* The format chunk and the data chunk are required. */\n\tif (!hasFormat || !hasData)\n\t{\n\t\treturn AF_FAIL;\n\t}\n\n\t/*\n\t\tAt this point we know that the file has a format chunk and a\n\t\tdata chunk, so we can assume that track->f and track->data_size\n\t\thave been initialized.\n\t*/\n\tif (!hasFrameCount)\n\t{\n\t\tif (track->f.bytesPerPacket && track->f.framesPerPacket)\n\t\t{\n\t\t\ttrack->computeTotalFileFrames();\n\t\t}\n\t\telse\n\t\t{\n\t\t\t_af_error(AF_BAD_HEADER, \"Frame count required but not found\");\n\t\t\treturn AF_FAIL;\n\t\t}\n\t}\n\n\treturn AF_SUCCEED;\n}\n\nAFfilesetup WAVEFile::completeSetup(AFfilesetup setup)\n{\n\tif (setup->trackSet && setup->trackCount != 1)\n\t{\n\t\t_af_error(AF_BAD_NUMTRACKS, \"WAVE file must have 1 track\");\n\t\treturn AF_NULL_FILESETUP;\n\t}\n\n\tTrackSetup *track = setup->getTrack();\n\tif (!track)\n\t\treturn AF_NULL_FILESETUP;\n\n\tif (track->f.isCompressed())\n\t{\n\t\tif (!track->sampleFormatSet)\n\t\t\t_af_set_sample_format(&track->f, AF_SAMPFMT_TWOSCOMP, 16);\n\t\telse\n\t\t\t_af_set_sample_format(&track->f, track->f.sampleFormat, track->f.sampleWidth);\n\t}\n\telse if (track->sampleFormatSet)\n\t{\n\t\tswitch (track->f.sampleFormat)\n\t\t{\n\t\t\tcase AF_SAMPFMT_FLOAT:\n\t\t\t\tif (track->sampleWidthSet &&\n\t\t\t\t\ttrack->f.sampleWidth != 32)\n\t\t\t\t{\n\t\t\t\t\t_af_error(AF_BAD_WIDTH,\n\t\t\t\t\t\t\"Warning: invalid sample width for floating-point WAVE file: %d (must be 32 bits)\\n\",\n\t\t\t\t\t\ttrack->f.sampleWidth);\n\t\t\t\t\t_af_set_sample_format(&track->f, AF_SAMPFMT_FLOAT, 32);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase AF_SAMPFMT_DOUBLE:\n\t\t\t\tif (track->sampleWidthSet &&\n\t\t\t\t\ttrack->f.sampleWidth != 64)\n\t\t\t\t{\n\t\t\t\t\t_af_error(AF_BAD_WIDTH,\n\t\t\t\t\t\t\"Warning: invalid sample width for double-precision floating-point WAVE file: %d (must be 64 bits)\\n\",\n\t\t\t\t\t\ttrack->f.sampleWidth);\n\t\t\t\t\t_af_set_sample_format(&track->f, AF_SAMPFMT_DOUBLE, 64);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase AF_SAMPFMT_UNSIGNED:\n\t\t\t\tif (track->sampleWidthSet)\n\t\t\t\t{\n\t\t\t\t\tif (track->f.sampleWidth < 1 || track->f.sampleWidth > 32)\n\t\t\t\t\t{\n\t\t\t\t\t\t_af_error(AF_BAD_WIDTH, \"invalid sample width for WAVE file: %d (must be 1-32 bits)\\n\", track->f.sampleWidth);\n\t\t\t\t\t\treturn AF_NULL_FILESETUP;\n\t\t\t\t\t}\n\t\t\t\t\tif (track->f.sampleWidth > 8)\n\t\t\t\t\t{\n\t\t\t\t\t\t_af_error(AF_BAD_SAMPFMT, \"WAVE integer data of more than 8 bits must be two's complement signed\");\n\t\t\t\t\t\t_af_set_sample_format(&track->f, AF_SAMPFMT_TWOSCOMP, track->f.sampleWidth);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t/*\n\t\t\t\t\tIf the sample width is not set but the user requests\n\t\t\t\t\tunsigned data, set the width to 8 bits.\n\t\t\t\t*/\n\t\t\t\t\t_af_set_sample_format(&track->f, track->f.sampleFormat, 8);\n\t\t\t\tbreak;\n\n\t\t\tcase AF_SAMPFMT_TWOSCOMP:\n\t\t\t\tif (track->sampleWidthSet)\n\t\t\t\t{\n\t\t\t\t\tif (track->f.sampleWidth < 1 || track->f.sampleWidth > 32)\n\t\t\t\t\t{\n\t\t\t\t\t\t_af_error(AF_BAD_WIDTH, \"invalid sample width %d for WAVE file (must be 1-32)\", track->f.sampleWidth);\n\t\t\t\t\t\treturn AF_NULL_FILESETUP;\n\t\t\t\t\t}\n\t\t\t\t\telse if (track->f.sampleWidth <= 8)\n\t\t\t\t\t{\n\t\t\t\t\t\t_af_error(AF_BAD_SAMPFMT, \"Warning: WAVE format integer data of 1-8 bits must be unsigned; setting sample format to unsigned\");\n\t\t\t\t\t\t_af_set_sample_format(&track->f, AF_SAMPFMT_UNSIGNED, track->f.sampleWidth);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t/*\n\t\t\t\t\tIf no sample width was specified, we default to 16 bits\n\t\t\t\t\tfor signed integer data.\n\t\t\t\t*/\n\t\t\t\t\t_af_set_sample_format(&track->f, track->f.sampleFormat, 16);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t/*\n\t\tOtherwise set the sample format depending on the sample\n\t\twidth or set completely to default.\n\t*/\n\telse\n\t{\n\t\tif (!track->sampleWidthSet)\n\t\t{\n\t\t\ttrack->f.sampleWidth = 16;\n\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (track->f.sampleWidth < 1 || track->f.sampleWidth > 32)\n\t\t\t{\n\t\t\t\t_af_error(AF_BAD_WIDTH, \"invalid sample width %d for WAVE file (must be 1-32)\", track->f.sampleWidth);\n\t\t\t\treturn AF_NULL_FILESETUP;\n\t\t\t}\n\t\t\telse if (track->f.sampleWidth > 8)\n\t\t\t\t/* Here track->f.sampleWidth is in {1..32}. */\n\t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n\t\t\telse\n\t\t\t\t/* Here track->f.sampleWidth is in {1..8}. */\n\t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_UNSIGNED;\n\t\t}\n\t}\n\n\tif (track->f.compressionType != AF_COMPRESSION_NONE &&\n\t\ttrack->f.compressionType != AF_COMPRESSION_G711_ULAW &&\n\t\ttrack->f.compressionType != AF_COMPRESSION_G711_ALAW &&\n\t\ttrack->f.compressionType != AF_COMPRESSION_IMA &&\n\t\ttrack->f.compressionType != AF_COMPRESSION_MS_ADPCM)\n\t{\n\t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"compression format not supported in WAVE format\");\n\t\treturn AF_NULL_FILESETUP;\n\t}\n\n\tif (track->f.isUncompressed() &&\n\t\ttrack->byteOrderSet &&\n\t\ttrack->f.byteOrder != AF_BYTEORDER_LITTLEENDIAN &&\n\t\ttrack->f.isByteOrderSignificant())\n\t{\n\t\t_af_error(AF_BAD_BYTEORDER, \"WAVE format only supports little-endian data\");\n\t\treturn AF_NULL_FILESETUP;\n\t}\n\n\tif (track->f.isUncompressed())\n\t\ttrack->f.byteOrder = AF_BYTEORDER_LITTLEENDIAN;\n\n\tif (track->aesDataSet)\n\t{\n\t\t_af_error(AF_BAD_FILESETUP, \"WAVE files cannot have AES data\");\n\t\treturn AF_NULL_FILESETUP;\n\t}\n\n\tif (setup->instrumentSet)\n\t{\n\t\tif (setup->instrumentCount > 1)\n\t\t{\n\t\t\t_af_error(AF_BAD_NUMINSTS, \"WAVE files can have 0 or 1 instrument\");\n\t\t\treturn AF_NULL_FILESETUP;\n\t\t}\n\t\telse if (setup->instrumentCount == 1)\n\t\t{\n\t\t\tif (setup->instruments[0].loopSet &&\n\t\t\t\tsetup->instruments[0].loopCount > 0 &&\n\t\t\t\t(!track->markersSet || track->markerCount == 0))\n\t\t\t{\n\t\t\t\t_af_error(AF_BAD_NUMMARKS, \"WAVE files with loops must contain at least 1 marker\");\n\t\t\t\treturn AF_NULL_FILESETUP;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Make sure the miscellaneous data is of an acceptable type. */\n\tif (setup->miscellaneousSet)\n\t{\n\t\tfor (int i=0; i<setup->miscellaneousCount; i++)\n\t\t{\n\t\t\tswitch (setup->miscellaneous[i].type)\n\t\t\t{\n\t\t\t\tcase AF_MISC_COPY:\n\t\t\t\tcase AF_MISC_AUTH:\n\t\t\t\tcase AF_MISC_NAME:\n\t\t\t\tcase AF_MISC_ICRD:\n\t\t\t\tcase AF_MISC_ISFT:\n\t\t\t\tcase AF_MISC_ICMT:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t_af_error(AF_BAD_MISCTYPE, \"illegal miscellaneous type [%d] for WAVE file\", setup->miscellaneous[i].type);\n\t\t\t\t\treturn AF_NULL_FILESETUP;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t\tAllocate an AFfilesetup and make all the unset fields correct.\n\t*/\n\tAFfilesetup\tnewsetup = _af_filesetup_copy(setup, &waveDefaultFileSetup, false);\n\n\t/* Make sure we do not copy loops if they are not specified in setup. */\n\tif (setup->instrumentSet && setup->instrumentCount > 0 &&\n\t\tsetup->instruments[0].loopSet)\n\t{\n\t\tfree(newsetup->instruments[0].loops);\n\t\tnewsetup->instruments[0].loopCount = 0;\n\t}\n\n\treturn newsetup;\n}\n\nbool WAVEFile::isInstrumentParameterValid(AUpvlist list, int i)\n{\n\tint param, type;\n\n\tAUpvgetparam(list, i, &param);\n\tAUpvgetvaltype(list, i, &type);\n\tif (type != AU_PVTYPE_LONG)\n\t\treturn false;\n\n\tlong lval;\n\tAUpvgetval(list, i, &lval);\n\n\tswitch (param)\n\t{\n\t\tcase AF_INST_MIDI_BASENOTE:\n\t\t\treturn ((lval >= 0) && (lval <= 127));\n\n\t\tcase AF_INST_NUMCENTS_DETUNE:\n\t\t\treturn ((lval >= -50) && (lval <= 50));\n\n\t\tcase AF_INST_MIDI_LOVELOCITY:\n\t\t\treturn ((lval >= 1) && (lval <= 127));\n\n\t\tcase AF_INST_MIDI_HIVELOCITY:\n\t\t\treturn ((lval >= 1) && (lval <= 127));\n\n\t\tcase AF_INST_MIDI_LONOTE:\n\t\t\treturn ((lval >= 0) && (lval <= 127));\n\n\t\tcase AF_INST_MIDI_HINOTE:\n\t\t\treturn ((lval >= 0) && (lval <= 127));\n\n\t\tcase AF_INST_NUMDBS_GAIN:\n\t\t\treturn true;\n\n\t\tdefault:\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatus WAVEFile::writeFormat()\n{\n\tuint16_t\tformatTag, channelCount;\n\tuint32_t\tsampleRate, averageBytesPerSecond;\n\tuint16_t\tblockAlign;\n\tuint32_t\tchunkSize;\n\tuint16_t\tbitsPerSample;\n\n\tTrack *track = getTrack();\n\n\tm_fh->write(\"fmt \", 4);\n\n\tswitch (track->f.compressionType)\n\t{\n\t\tcase AF_COMPRESSION_NONE:\n\t\t\tchunkSize = 16;\n\t\t\tif (track->f.sampleFormat == AF_SAMPFMT_FLOAT ||\n\t\t\t\ttrack->f.sampleFormat == AF_SAMPFMT_DOUBLE)\n\t\t\t{\n\t\t\t\tformatTag = WAVE_FORMAT_IEEE_FLOAT;\n\t\t\t}\n\t\t\telse if (track->f.sampleFormat == AF_SAMPFMT_TWOSCOMP ||\n\t\t\t\ttrack->f.sampleFormat == AF_SAMPFMT_UNSIGNED)\n\t\t\t{\n\t\t\t\tformatTag = WAVE_FORMAT_PCM;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t_af_error(AF_BAD_COMPTYPE, \"bad sample format\");\n\t\t\t\treturn AF_FAIL;\n\t\t\t}\n\n\t\t\tblockAlign = _af_format_frame_size(&track->f, false);\n\t\t\tbitsPerSample = 8 * _af_format_sample_size(&track->f, false);\n\t\t\tbreak;\n\n\t\t/*\n\t\t\tG.711 compression uses eight bits per sample.\n\t\t*/\n\t\tcase AF_COMPRESSION_G711_ULAW:\n\t\t\tchunkSize = 18;\n\t\t\tformatTag = IBM_FORMAT_MULAW;\n\t\t\tblockAlign = track->f.channelCount;\n\t\t\tbitsPerSample = 8;\n\t\t\tbreak;\n\n\t\tcase AF_COMPRESSION_G711_ALAW:\n\t\t\tchunkSize = 18;\n\t\t\tformatTag = IBM_FORMAT_ALAW;\n\t\t\tblockAlign = track->f.channelCount;\n\t\t\tbitsPerSample = 8;\n\t\t\tbreak;\n\n\t\tcase AF_COMPRESSION_IMA:\n\t\t\tchunkSize = 20;\n\t\t\tformatTag = WAVE_FORMAT_DVI_ADPCM;\n\t\t\tblockAlign = track->f.bytesPerPacket;\n\t\t\tbitsPerSample = 4;\n\t\t\tbreak;\n\n\t\tcase AF_COMPRESSION_MS_ADPCM:\n\t\t\tchunkSize = 50;\n\t\t\tformatTag = WAVE_FORMAT_ADPCM;\n\t\t\tblockAlign = track->f.bytesPerPacket;\n\t\t\tbitsPerSample = 4;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t_af_error(AF_BAD_COMPTYPE, \"bad compression type\");\n\t\t\treturn AF_FAIL;\n\t}\n\n\twriteU32(&chunkSize);\n\twriteU16(&formatTag);\n\n\tchannelCount = track->f.channelCount;\n\twriteU16(&channelCount);\n\n\tsampleRate = track->f.sampleRate;\n\twriteU32(&sampleRate);\n\n\taverageBytesPerSecond =\n\t\ttrack->f.sampleRate * _af_format_frame_size(&track->f, false);\n\tif (track->f.compressionType == AF_COMPRESSION_IMA ||\n\t\ttrack->f.compressionType == AF_COMPRESSION_MS_ADPCM)\n\t\taverageBytesPerSecond = track->f.sampleRate * track->f.bytesPerPacket /\n\t\t\ttrack->f.framesPerPacket;\n\twriteU32(&averageBytesPerSecond);\n\n\twriteU16(&blockAlign);\n\n\twriteU16(&bitsPerSample);\n\n\tif (track->f.compressionType == AF_COMPRESSION_G711_ULAW ||\n\t\ttrack->f.compressionType == AF_COMPRESSION_G711_ALAW)\n\t{\n\t\tuint16_t zero = 0;\n\t\twriteU16(&zero);\n\t}\n\telse if (track->f.compressionType == AF_COMPRESSION_IMA)\n\t{\n\t\tuint16_t extraByteCount = 2;\n\t\twriteU16(&extraByteCount);\n\t\tuint16_t samplesPerBlock = track->f.framesPerPacket;\n\t\twriteU16(&samplesPerBlock);\n\t}\n\telse if (track->f.compressionType == AF_COMPRESSION_MS_ADPCM)\n\t{\n\t\tuint16_t extraByteCount = 2 + 2 + m_msadpcmNumCoefficients * 4;\n\t\twriteU16(&extraByteCount);\n\t\tuint16_t samplesPerBlock = track->f.framesPerPacket;\n\t\twriteU16(&samplesPerBlock);\n\n\t\tuint16_t numCoefficients = m_msadpcmNumCoefficients;\n\t\twriteU16(&numCoefficients);\n\n\t\tfor (int i=0; i<m_msadpcmNumCoefficients; i++)\n\t\t{\n\t\t\twriteS16(&m_msadpcmCoefficients[i][0]);\n\t\t\twriteS16(&m_msadpcmCoefficients[i][1]);\n\t\t}\n\t}\n\n\treturn AF_SUCCEED;\n}\n\nstatus WAVEFile::writeFrameCount()\n{\n\tuint32_t factSize = 4;\n\tuint32_t totalFrameCount;\n\n\tTrack *track = getTrack();\n\n\t/* Omit the fact chunk only for uncompressed integer audio formats. */\n\tif (track->f.compressionType == AF_COMPRESSION_NONE &&\n\t\t(track->f.sampleFormat == AF_SAMPFMT_TWOSCOMP ||\n\t\ttrack->f.sampleFormat == AF_SAMPFMT_UNSIGNED))\n\t\treturn AF_SUCCEED;\n\n\t/*\n\t\tIf the offset for the fact chunk hasn't been set yet,\n\t\tset it to the file's current position.\n\t*/\n\tif (m_factOffset == 0)\n\t\tm_factOffset = m_fh->tell();\n\telse\n\t\tm_fh->seek(m_factOffset, File::SeekFromBeginning);\n\n\tm_fh->write(\"fact\", 4);\n\twriteU32(&factSize);\n\n\ttotalFrameCount = track->totalfframes;\n\twriteU32(&totalFrameCount);\n\n\treturn AF_SUCCEED;\n}\n\nstatus WAVEFile::writeData()\n{\n\tTrack *track = getTrack();\n\n\tm_fh->write(\"data\", 4);\n\tm_dataSizeOffset = m_fh->tell();\n\n\tuint32_t chunkSize = track->data_size;\n\n\twriteU32(&chunkSize);\n\ttrack->fpos_first_frame = m_fh->tell();\n\n\treturn AF_SUCCEED;\n}\n\nstatus WAVEFile::update()\n{\n\tTrack *track = getTrack();\n\n\tif (track->fpos_first_frame != 0)\n\t{\n\t\tuint32_t dataLength, fileLength;\n\n\t\t// Update the frame count chunk if present.\n\t\twriteFrameCount();\n\n\t\t// Update the length of the data chunk.\n\t\tm_fh->seek(m_dataSizeOffset, File::SeekFromBeginning);\n\t\tdataLength = (uint32_t) track->data_size;\n\t\twriteU32(&dataLength);\n\n\t\t// Update the length of the RIFF chunk.\n\t\tfileLength = (uint32_t) m_fh->length();\n\t\tfileLength -= 8;\n\n\t\tm_fh->seek(4, File::SeekFromBeginning);\n\t\twriteU32(&fileLength);\n\t}\n\n\t/*\n\t\tWrite the actual data that was set after initializing\n\t\tthe miscellaneous IDs.\tThe size of the data will be\n\t\tunchanged.\n\t*/\n\twriteMiscellaneous();\n\n\t// Write the new positions; the size of the data will be unchanged.\n\twriteCues();\n\n\treturn AF_SUCCEED;\n}\n\n/* Convert an Audio File Library miscellaneous type to a WAVE type. */\nstatic bool misc_type_to_wave (int misctype, Tag *miscid)\n{\n\tif (misctype == AF_MISC_AUTH)\n\t\t*miscid = \"IART\";\n\telse if (misctype == AF_MISC_NAME)\n\t\t*miscid = \"INAM\";\n\telse if (misctype == AF_MISC_COPY)\n\t\t*miscid = \"ICOP\";\n\telse if (misctype == AF_MISC_ICMT)\n\t\t*miscid = \"ICMT\";\n\telse if (misctype == AF_MISC_ICRD)\n\t\t*miscid = \"ICRD\";\n\telse if (misctype == AF_MISC_ISFT)\n\t\t*miscid = \"ISFT\";\n\telse\n\t\treturn false;\n\n\treturn true;\n}\n\nstatus WAVEFile::writeMiscellaneous()\n{\n\tif (m_miscellaneousCount != 0)\n\t{\n\t\tuint32_t\tmiscellaneousBytes;\n\t\tuint32_t \tchunkSize;\n\n\t\t/* Start at 12 to account for 'LIST', size, and 'INFO'. */\n\t\tmiscellaneousBytes = 12;\n\n\t\t/* Then calculate the size of the whole INFO chunk. */\n\t\tfor (int i=0; i<m_miscellaneousCount; i++)\n\t\t{\n\t\t\tTag miscid;\n\n\t\t\t// Skip miscellaneous data of an unsupported type.\n\t\t\tif (!misc_type_to_wave(m_miscellaneous[i].type, &miscid))\n\t\t\t\tcontinue;\n\n\t\t\t// Account for miscellaneous type and size.\n\t\t\tmiscellaneousBytes += 8;\n\t\t\tmiscellaneousBytes += m_miscellaneous[i].size;\n\n\t\t\t// Add a pad byte if necessary.\n\t\t\tif (m_miscellaneous[i].size % 2 != 0)\n\t\t\t\tmiscellaneousBytes++;\n\n\t\t\tassert(miscellaneousBytes % 2 == 0);\n\t\t}\n\n\t\tif (m_miscellaneousOffset == 0)\n\t\t\tm_miscellaneousOffset = m_fh->tell();\n\t\telse\n\t\t\tm_fh->seek(m_miscellaneousOffset, File::SeekFromBeginning);\n\n\t\t/*\n\t\t\tWrite the data.  On the first call to this\n\t\t\tfunction (from _af_wave_write_init), the\n\t\t\tdata won't be available, fh->seek is used to\n\t\t\treserve space until the data has been provided.\n\t\t\tOn subseuent calls to this function (from\n\t\t\t_af_wave_update), the data will really be written.\n\t\t*/\n\n\t\t/* Write 'LIST'. */\n\t\tm_fh->write(\"LIST\", 4);\n\n\t\t/* Write the size of the following chunk. */\n\t\tchunkSize = miscellaneousBytes-8;\n\t\twriteU32(&chunkSize);\n\n\t\t/* Write 'INFO'. */\n\t\tm_fh->write(\"INFO\", 4);\n\n\t\t/* Write each miscellaneous chunk. */\n\t\tfor (int i=0; i<m_miscellaneousCount; i++)\n\t\t{\n\t\t\tuint32_t miscsize = m_miscellaneous[i].size;\n\t\t\tTag miscid;\n\n\t\t\t// Skip miscellaneous data of an unsupported type.\n\t\t\tif (!misc_type_to_wave(m_miscellaneous[i].type, &miscid))\n\t\t\t\tcontinue;\n\n\t\t\twriteTag(&miscid);\n\t\t\twriteU32(&miscsize);\n\t\t\tif (m_miscellaneous[i].buffer != NULL)\n\t\t\t{\n\t\t\t\tuint8_t\tzero = 0;\n\n\t\t\t\tm_fh->write(m_miscellaneous[i].buffer, m_miscellaneous[i].size);\n\n\t\t\t\t// Pad if necessary.\n\t\t\t\tif ((m_miscellaneous[i].size%2) != 0)\n\t\t\t\t\twriteU8(&zero);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint\tsize;\n\t\t\t\tsize = m_miscellaneous[i].size;\n\n\t\t\t\t// Pad if necessary.\n\t\t\t\tif ((size % 2) != 0)\n\t\t\t\t\tsize++;\n\t\t\t\tm_fh->seek(size, File::SeekFromCurrent);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn AF_SUCCEED;\n}\n\nstatus WAVEFile::writeCues()\n{\n\tTrack *track = getTrack();\n\n\tif (!track->markerCount)\n\t\treturn AF_SUCCEED;\n\n\tif (m_markOffset == 0)\n\t\tm_markOffset = m_fh->tell();\n\telse\n\t\tm_fh->seek(m_markOffset, File::SeekFromBeginning);\n\n\tTag cue(\"cue \");\n\twriteTag(&cue);\n\n\t/*\n\t\tThe cue chunk consists of 4 bytes for the number of cue points\n\t\tfollowed by 24 bytes for each cue point record.\n\t*/\n\tuint32_t cueChunkSize = 4 + track->markerCount * 24;\n\twriteU32(&cueChunkSize);\n\tuint32_t numCues = track->markerCount;\n\twriteU32(&numCues);\n\n\t// Write each marker to the file.\n\tfor (int i=0; i<track->markerCount; i++)\n\t{\n\t\tuint32_t identifier = track->markers[i].id;\n\t\twriteU32(&identifier);\n\n\t\tuint32_t position = i;\n\t\twriteU32(&position);\n\n\t\tTag data(\"data\");\n\t\twriteTag(&data);\n\n\t\t/*\n\t\t\tFor an uncompressed WAVE file which contains only one data chunk,\n\t\t\tchunkStart and blockStart are zero.\n\t\t*/\n\t\tuint32_t chunkStart = 0;\n\t\twriteU32(&chunkStart);\n\n\t\tuint32_t blockStart = 0;\n\t\twriteU32(&blockStart);\n\n\t\tAFframecount markPosition = track->markers[i].position;\n\t\tuint32_t sampleOffset = markPosition;\n\t\twriteU32(&sampleOffset);\n\t}\n\n\t// Now write the cue names and comments within a master list chunk.\n\tuint32_t listChunkSize = 4;\n\tfor (int i=0; i<track->markerCount; i++)\n\t{\n\t\tconst char *name = track->markers[i].name;\n\t\tconst char *comment = track->markers[i].comment;\n\n\t\t/*\n\t\t\tEach 'labl' or 'note' chunk consists of 4 bytes for the chunk ID,\n\t\t\t4 bytes for the chunk data size, 4 bytes for the cue point ID,\n\t\t\tand then the length of the label as a null-terminated string.\n\n\t\t\tIn all, this is 12 bytes plus the length of the string, its null\n\t\t\ttermination byte, and a trailing pad byte if the length of the\n\t\t\tchunk is otherwise odd.\n\t\t*/\n\t\tlistChunkSize += 12 + zStringLength(name);\n\t\tlistChunkSize += 12 + zStringLength(comment);\n\t}\n\n\tTag list(\"LIST\");\n\twriteTag(&list);\n\twriteU32(&listChunkSize);\n\tTag adtl(\"adtl\");\n\twriteTag(&adtl);\n\n\tfor (int i=0; i<track->markerCount; i++)\n\t{\n\t\tuint32_t cuePointID = track->markers[i].id;\n\n\t\tconst char *name = track->markers[i].name;\n\t\tuint32_t labelSize = 4 + zStringLength(name);\n\t\tTag lablTag(\"labl\");\n\t\twriteTag(&lablTag);\n\t\twriteU32(&labelSize);\n\t\twriteU32(&cuePointID);\n\t\twriteZString(name);\n\n\t\tconst char *comment = track->markers[i].comment;\n\t\tuint32_t noteSize = 4 + zStringLength(comment);\n\t\tTag noteTag(\"note\");\n\t\twriteTag(&noteTag);\n\t\twriteU32(&noteSize);\n\t\twriteU32(&cuePointID);\n\t\twriteZString(comment);\n\t}\n\n\treturn AF_SUCCEED;\n}\n\nbool WAVEFile::writeZString(const char *s)\n{\n\tssize_t lengthPlusNull = strlen(s) + 1;\n\tif (m_fh->write(s, lengthPlusNull) != lengthPlusNull)\n\t\treturn false;\n\tif (lengthPlusNull & 1)\n\t{\n\t\tuint8_t zero = 0;\n\t\tif (!writeU8(&zero))\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nsize_t WAVEFile::zStringLength(const char *s)\n{\n\tsize_t lengthPlusNull = strlen(s) + 1;\n\treturn lengthPlusNull + (lengthPlusNull & 1);\n}\n\nstatus WAVEFile::writeInit(AFfilesetup setup)\n{\n\tif (initFromSetup(setup) == AF_FAIL)\n\t\treturn AF_FAIL;\n\n\tinitCompressionParams();\n\n\tuint32_t zero = 0;\n\n\tm_fh->seek(0, File::SeekFromBeginning);\n\tm_fh->write(\"RIFF\", 4);\n\tm_fh->write(&zero, 4);\n\tm_fh->write(\"WAVE\", 4);\n\n\twriteMiscellaneous();\n\twriteCues();\n\twriteFormat();\n\twriteFrameCount();\n\twriteData();\n\n\treturn AF_SUCCEED;\n}\n\nbool WAVEFile::readUUID(UUID *u)\n{\n\treturn m_fh->read(u->data, 16) == 16;\n}\n\nbool WAVEFile::writeUUID(const UUID *u)\n{\n\treturn m_fh->write(u->data, 16) == 16;\n}\n\nvoid WAVEFile::initCompressionParams()\n{\n\tTrack *track = getTrack();\n\tif (track->f.compressionType == AF_COMPRESSION_IMA)\n\t\tinitIMACompressionParams();\n\telse if (track->f.compressionType == AF_COMPRESSION_MS_ADPCM)\n\t\tinitMSADPCMCompressionParams();\n}\n\nvoid WAVEFile::initIMACompressionParams()\n{\n\tTrack *track = getTrack();\n\n\ttrack->f.framesPerPacket = 505;\n\ttrack->f.bytesPerPacket = 256 * track->f.channelCount;\n\n\tAUpvlist pv = AUpvnew(1);\n\tAUpvsetparam(pv, 0, _AF_IMA_ADPCM_TYPE);\n\tAUpvsetvaltype(pv, 0, AU_PVTYPE_LONG);\n\tlong l = _AF_IMA_ADPCM_TYPE_WAVE;\n\tAUpvsetval(pv, 0, &l);\n\n\ttrack->f.compressionParams = pv;\n}\n\nvoid WAVEFile::initMSADPCMCompressionParams()\n{\n\tconst int16_t coefficients[7][2] =\n\t{\n\t\t{ 256, 0 },\n\t\t{ 512, -256 },\n\t\t{ 0, 0 },\n\t\t{ 192, 64 },\n\t\t{ 240, 0 },\n\t\t{ 460, -208 },\n\t\t{ 392, -232 }\n\t};\n\tmemcpy(m_msadpcmCoefficients, coefficients, sizeof (int16_t) * 7 * 2);\n\tm_msadpcmNumCoefficients = 7;\n\n\tTrack *track = getTrack();\n\n\ttrack->f.framesPerPacket = 500;\n\ttrack->f.bytesPerPacket = 256 * track->f.channelCount;\n\n\tAUpvlist pv = AUpvnew(2);\n\tAUpvsetparam(pv, 0, _AF_MS_ADPCM_NUM_COEFFICIENTS);\n\tAUpvsetvaltype(pv, 0, AU_PVTYPE_LONG);\n\tlong l = m_msadpcmNumCoefficients;\n\tAUpvsetval(pv, 0, &l);\n\n\tAUpvsetparam(pv, 1, _AF_MS_ADPCM_COEFFICIENTS);\n\tAUpvsetvaltype(pv, 1, AU_PVTYPE_PTR);\n\tvoid *v = m_msadpcmCoefficients;\n\tAUpvsetval(pv, 1, &v);\n\n\ttrack->f.compressionParams = pv;\n}\n"], "fixing_code": ["/*\n\tAudio File Library\n\tCopyright (C) 1998-2000, 2003-2004, 2010-2013, Michael Pruett <michael@68k.org>\n\tCopyright (C) 2000-2002, Silicon Graphics, Inc.\n\tCopyright (C) 2002-2003, Davy Durham\n\n\tThis library is free software; you can redistribute it and/or\n\tmodify it under the terms of the GNU Lesser General Public\n\tLicense as published by the Free Software Foundation; either\n\tversion 2.1 of the License, or (at your option) any later version.\n\n\tThis library is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n\tLesser General Public License for more details.\n\n\tYou should have received a copy of the GNU Lesser General Public\n\tLicense along with this library; if not, write to the\n\tFree Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n\tBoston, MA  02110-1301  USA\n*/\n\n/*\n\tWAVE.cpp\n\n\tThis file contains code for reading and writing RIFF WAVE format\n\tsound files.\n*/\n\n#include \"config.h\"\n#include \"WAVE.h\"\n\n#include <assert.h>\n#include <math.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"File.h\"\n#include \"Instrument.h\"\n#include \"Marker.h\"\n#include \"Setup.h\"\n#include \"Tag.h\"\n#include \"Track.h\"\n#include \"UUID.h\"\n#include \"byteorder.h\"\n#include \"util.h\"\n\n/* These constants are from RFC 2361. */\nenum\n{\n\tWAVE_FORMAT_UNKNOWN = 0x0000,\t/* Microsoft Unknown Wave Format */\n\tWAVE_FORMAT_PCM = 0x0001,\t/* Microsoft PCM Format */\n\tWAVE_FORMAT_ADPCM = 0x0002,\t/* Microsoft ADPCM Format */\n\tWAVE_FORMAT_IEEE_FLOAT = 0x0003,\t/* IEEE Float */\n\tWAVE_FORMAT_VSELP = 0x0004,\t/* Compaq Computer's VSELP */\n\tWAVE_FORMAT_IBM_CVSD = 0x0005,\t/* IBM CVSD */\n\tWAVE_FORMAT_ALAW = 0x0006,\t/* Microsoft ALAW */\n\tWAVE_FORMAT_MULAW = 0x0007,\t/* Microsoft MULAW */\n\tWAVE_FORMAT_OKI_ADPCM = 0x0010,\t/* OKI ADPCM */\n\tWAVE_FORMAT_DVI_ADPCM = 0x0011,\t/* Intel's DVI ADPCM */\n\tWAVE_FORMAT_MEDIASPACE_ADPCM = 0x0012,\t/* Videologic's MediaSpace ADPCM */\n\tWAVE_FORMAT_SIERRA_ADPCM = 0x0013,\t/* Sierra ADPCM */\n\tWAVE_FORMAT_G723_ADPCM = 0x0014,\t/* G.723 ADPCM */\n\tWAVE_FORMAT_DIGISTD = 0x0015,\t/* DSP Solutions' DIGISTD */\n\tWAVE_FORMAT_DIGIFIX = 0x0016,\t/* DSP Solutions' DIGIFIX */\n\tWAVE_FORMAT_DIALOGIC_OKI_ADPCM = 0x0017,\t/* Dialogic OKI ADPCM */\n\tWAVE_FORMAT_MEDIAVISION_ADPCM = 0x0018,\t/* MediaVision ADPCM */\n\tWAVE_FORMAT_CU_CODEC = 0x0019,\t/* HP CU */\n\tWAVE_FORMAT_YAMAHA_ADPCM = 0x0020,\t/* Yamaha ADPCM */\n\tWAVE_FORMAT_SONARC = 0x0021,\t/* Speech Compression's Sonarc */\n\tWAVE_FORMAT_DSP_TRUESPEECH = 0x0022,\t/* DSP Group's True Speech */\n\tWAVE_FORMAT_ECHOSC1 = 0x0023,\t/* Echo Speech's EchoSC1 */\n\tWAVE_FORMAT_AUDIOFILE_AF36 = 0x0024,\t/* Audiofile AF36 */\n\tWAVE_FORMAT_APTX = 0x0025,\t/* APTX */\n\tWAVE_FORMAT_DOLBY_AC2 = 0x0030,\t/* Dolby AC2 */\n\tWAVE_FORMAT_GSM610 = 0x0031,\t/* GSM610 */\n\tWAVE_FORMAT_MSNAUDIO = 0x0032,\t/* MSNAudio */\n\tWAVE_FORMAT_ANTEX_ADPCME = 0x0033,\t/* Antex ADPCME */\n\n\tWAVE_FORMAT_MPEG = 0x0050,\t\t/* MPEG */\n\tWAVE_FORMAT_MPEGLAYER3 = 0x0055,\t/* MPEG layer 3 */\n\tWAVE_FORMAT_LUCENT_G723 = 0x0059,\t/* Lucent G.723 */\n\tWAVE_FORMAT_G726_ADPCM = 0x0064,\t/* G.726 ADPCM */\n\tWAVE_FORMAT_G722_ADPCM = 0x0065,\t/* G.722 ADPCM */\n\n\tIBM_FORMAT_MULAW = 0x0101,\n\tIBM_FORMAT_ALAW = 0x0102,\n\tIBM_FORMAT_ADPCM = 0x0103,\n\n\tWAVE_FORMAT_CREATIVE_ADPCM = 0x0200,\n\n\tWAVE_FORMAT_EXTENSIBLE = 0xfffe\n};\n\nconst int _af_wave_compression_types[_AF_WAVE_NUM_COMPTYPES] =\n{\n\tAF_COMPRESSION_G711_ULAW,\n\tAF_COMPRESSION_G711_ALAW,\n\tAF_COMPRESSION_IMA,\n\tAF_COMPRESSION_MS_ADPCM\n};\n\nconst InstParamInfo _af_wave_inst_params[_AF_WAVE_NUM_INSTPARAMS] =\n{\n\t{ AF_INST_MIDI_BASENOTE, AU_PVTYPE_LONG, \"MIDI base note\", {60} },\n\t{ AF_INST_NUMCENTS_DETUNE, AU_PVTYPE_LONG, \"Detune in cents\", {0} },\n\t{ AF_INST_MIDI_LOVELOCITY, AU_PVTYPE_LONG, \"Low velocity\", {1} },\n\t{ AF_INST_MIDI_HIVELOCITY, AU_PVTYPE_LONG, \"High velocity\", {127} },\n\t{ AF_INST_MIDI_LONOTE, AU_PVTYPE_LONG, \"Low note\", {0} },\n\t{ AF_INST_MIDI_HINOTE, AU_PVTYPE_LONG, \"High note\", {127} },\n\t{ AF_INST_NUMDBS_GAIN, AU_PVTYPE_LONG, \"Gain in dB\", {0} }\n};\n\nstatic const _AFfilesetup waveDefaultFileSetup =\n{\n\t_AF_VALID_FILESETUP,\t/* valid */\n\tAF_FILE_WAVE,\t\t/* fileFormat */\n\ttrue,\t\t\t/* trackSet */\n\ttrue,\t\t\t/* instrumentSet */\n\ttrue,\t\t\t/* miscellaneousSet  */\n\t1,\t\t\t/* trackCount */\n\tNULL,\t\t\t/* tracks */\n\t0,\t\t\t/* instrumentCount */\n\tNULL,\t\t\t/* instruments */\n\t0,\t\t\t/* miscellaneousCount */\n\tNULL\t\t\t/* miscellaneous */\n};\n\nstatic const UUID _af_wave_guid_pcm =\n{{\n\t0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,\n\t0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71\n}};\nstatic const UUID _af_wave_guid_ieee_float =\n{{\n\t0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,\n\t0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71\n}};\nstatic const UUID _af_wave_guid_ulaw =\n{{\n\t0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,\n\t0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71\n}};\nstatic const UUID _af_wave_guid_alaw =\n{{\n\t0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,\n\t0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71\n}};\n\nWAVEFile::WAVEFile()\n{\n\tsetFormatByteOrder(AF_BYTEORDER_LITTLEENDIAN);\n\n\tm_factOffset = 0;\n\tm_miscellaneousOffset = 0;\n\tm_markOffset = 0;\n\tm_dataSizeOffset = 0;\n\n\tm_msadpcmNumCoefficients = 0;\n}\n\nstatus WAVEFile::parseFrameCount(const Tag &id, uint32_t size)\n{\n\tTrack *track = getTrack();\n\n\tuint32_t totalFrames;\n\treadU32(&totalFrames);\n\n\ttrack->totalfframes = totalFrames;\n\n\treturn AF_SUCCEED;\n}\n\nstatus WAVEFile::parseFormat(const Tag &id, uint32_t size)\n{\n\tTrack *track = getTrack();\n\n\tuint16_t formatTag;\n\treadU16(&formatTag);\n\tuint16_t channelCount;\n\treadU16(&channelCount);\n\tuint32_t sampleRate;\n\treadU32(&sampleRate);\n\tuint32_t averageBytesPerSecond;\n\treadU32(&averageBytesPerSecond);\n\tuint16_t blockAlign;\n\treadU16(&blockAlign);\n\n\tif (!channelCount)\n\t{\n\t\t_af_error(AF_BAD_CHANNELS, \"invalid file with 0 channels\");\n\t\treturn AF_FAIL;\n\t}\n\n\ttrack->f.channelCount = channelCount;\n\ttrack->f.sampleRate = sampleRate;\n\ttrack->f.byteOrder = AF_BYTEORDER_LITTLEENDIAN;\n\n\t/* Default to uncompressed audio data. */\n\ttrack->f.compressionType = AF_COMPRESSION_NONE;\n\ttrack->f.framesPerPacket = 1;\n\n\tswitch (formatTag)\n\t{\n\t\tcase WAVE_FORMAT_PCM:\n\t\t{\n\t\t\tuint16_t bitsPerSample;\n\t\t\treadU16(&bitsPerSample);\n\n\t\t\ttrack->f.sampleWidth = bitsPerSample;\n\n\t\t\tif (bitsPerSample == 0 || bitsPerSample > 32)\n\t\t\t{\n\t\t\t\t_af_error(AF_BAD_WIDTH,\n\t\t\t\t\t\"bad sample width of %d bits\",\n\t\t\t\t\tbitsPerSample);\n\t\t\t\treturn AF_FAIL;\n\t\t\t}\n\n\t\t\tif (bitsPerSample <= 8)\n\t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_UNSIGNED;\n\t\t\telse\n\t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n\t\t}\n\t\tbreak;\n\n\t\tcase WAVE_FORMAT_MULAW:\n\t\tcase IBM_FORMAT_MULAW:\n\t\t\ttrack->f.sampleWidth = 16;\n\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n\t\t\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n\t\t\ttrack->f.compressionType = AF_COMPRESSION_G711_ULAW;\n\t\t\ttrack->f.bytesPerPacket = track->f.channelCount;\n\t\t\tbreak;\n\n\t\tcase WAVE_FORMAT_ALAW:\n\t\tcase IBM_FORMAT_ALAW:\n\t\t\ttrack->f.sampleWidth = 16;\n\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n\t\t\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n\t\t\ttrack->f.compressionType = AF_COMPRESSION_G711_ALAW;\n\t\t\ttrack->f.bytesPerPacket = track->f.channelCount;\n\t\t\tbreak;\n\n\t\tcase WAVE_FORMAT_IEEE_FLOAT:\n\t\t{\n\t\t\tuint16_t bitsPerSample;\n\t\t\treadU16(&bitsPerSample);\n\n\t\t\tif (bitsPerSample == 64)\n\t\t\t{\n\t\t\t\ttrack->f.sampleWidth = 64;\n\t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_DOUBLE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttrack->f.sampleWidth = 32;\n\t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_FLOAT;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase WAVE_FORMAT_ADPCM:\n\t\t{\n\t\t\tuint16_t bitsPerSample, extraByteCount,\n\t\t\t\t\tsamplesPerBlock, numCoefficients;\n\n\t\t\tif (track->f.channelCount != 1 &&\n\t\t\t\ttrack->f.channelCount != 2)\n\t\t\t{\n\t\t\t\t_af_error(AF_BAD_CHANNELS,\n\t\t\t\t\t\"WAVE file with MS ADPCM compression \"\n\t\t\t\t\t\"must have 1 or 2 channels\");\n\t\t\t}\n\n\t\t\treadU16(&bitsPerSample);\n\t\t\treadU16(&extraByteCount);\n\t\t\treadU16(&samplesPerBlock);\n\t\t\treadU16(&numCoefficients);\n\n\t\t\t/* numCoefficients should be at least 7. */\n\t\t\tassert(numCoefficients >= 7 && numCoefficients <= 255);\n\n\t\t\tm_msadpcmNumCoefficients = numCoefficients;\n\n\t\t\tfor (int i=0; i<m_msadpcmNumCoefficients; i++)\n\t\t\t{\n\t\t\t\treadS16(&m_msadpcmCoefficients[i][0]);\n\t\t\t\treadS16(&m_msadpcmCoefficients[i][1]);\n\t\t\t}\n\n\t\t\ttrack->f.sampleWidth = 16;\n\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n\t\t\ttrack->f.compressionType = AF_COMPRESSION_MS_ADPCM;\n\t\t\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n\n\t\t\ttrack->f.framesPerPacket = samplesPerBlock;\n\t\t\ttrack->f.bytesPerPacket = blockAlign;\n\n\t\t\t// Create the parameter list.\n\t\t\tAUpvlist pv = AUpvnew(2);\n\t\t\tAUpvsetparam(pv, 0, _AF_MS_ADPCM_NUM_COEFFICIENTS);\n\t\t\tAUpvsetvaltype(pv, 0, AU_PVTYPE_LONG);\n\t\t\tlong l = m_msadpcmNumCoefficients;\n\t\t\tAUpvsetval(pv, 0, &l);\n\n\t\t\tAUpvsetparam(pv, 1, _AF_MS_ADPCM_COEFFICIENTS);\n\t\t\tAUpvsetvaltype(pv, 1, AU_PVTYPE_PTR);\n\t\t\tvoid *v = m_msadpcmCoefficients;\n\t\t\tAUpvsetval(pv, 1, &v);\n\n\t\t\ttrack->f.compressionParams = pv;\n\t\t}\n\t\tbreak;\n\n\t\tcase WAVE_FORMAT_DVI_ADPCM:\n\t\t{\n\t\t\tuint16_t bitsPerSample, extraByteCount, samplesPerBlock;\n\n\t\t\treadU16(&bitsPerSample);\n\t\t\treadU16(&extraByteCount);\n\t\t\treadU16(&samplesPerBlock);\n\n\t\t\tif (bitsPerSample != 4)\n\t\t\t{\n\t\t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED,\n\t\t\t\t\t\"IMA ADPCM compression supports only 4 bits per sample\");\n\t\t\t\treturn AF_FAIL;\n\t\t\t}\n\n\t\t\tint bytesPerBlock = (samplesPerBlock + 14) / 8 * 4 * channelCount;\n\t\t\tif (bytesPerBlock > blockAlign || (samplesPerBlock % 8) != 1)\n\t\t\t{\n\t\t\t\t_af_error(AF_BAD_CODEC_CONFIG,\n\t\t\t\t\t\"Invalid samples per block for IMA ADPCM compression\");\n\t\t\t\treturn AF_FAIL;\n\t\t\t}\n\n\t\t\ttrack->f.sampleWidth = 16;\n\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n\t\t\ttrack->f.compressionType = AF_COMPRESSION_IMA;\n\t\t\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n\n\t\t\tinitIMACompressionParams();\n\n\t\t\ttrack->f.framesPerPacket = samplesPerBlock;\n\t\t\ttrack->f.bytesPerPacket = blockAlign;\n\t\t}\n\t\tbreak;\n\n\t\tcase WAVE_FORMAT_EXTENSIBLE:\n\t\t{\n\t\t\tuint16_t bitsPerSample;\n\t\t\treadU16(&bitsPerSample);\n\t\t\tuint16_t extraByteCount;\n\t\t\treadU16(&extraByteCount);\n\t\t\tuint16_t reserved;\n\t\t\treadU16(&reserved);\n\t\t\tuint32_t channelMask;\n\t\t\treadU32(&channelMask);\n\t\t\tUUID subformat;\n\t\t\treadUUID(&subformat);\n\t\t\tif (subformat == _af_wave_guid_pcm)\n\t\t\t{\n\t\t\t\ttrack->f.sampleWidth = bitsPerSample;\n\n\t\t\t\tif (bitsPerSample == 0 || bitsPerSample > 32)\n\t\t\t\t{\n\t\t\t\t\t_af_error(AF_BAD_WIDTH,\n\t\t\t\t\t\t\"bad sample width of %d bits\",\n\t\t\t\t\t\tbitsPerSample);\n\t\t\t\t\treturn AF_FAIL;\n\t\t\t\t}\n\n\t\t\t\t// Use valid bits per sample if bytes per sample is the same.\n\t\t\t\tif (reserved <= bitsPerSample &&\n\t\t\t\t\t(reserved + 7) / 8 == (bitsPerSample + 7) / 8)\n\t\t\t\t\ttrack->f.sampleWidth = reserved;\n\n\t\t\t\tif (bitsPerSample <= 8)\n\t\t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_UNSIGNED;\n\t\t\t\telse\n\t\t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n\t\t\t}\n\t\t\telse if (subformat == _af_wave_guid_ieee_float)\n\t\t\t{\n\t\t\t\tif (bitsPerSample == 64)\n\t\t\t\t{\n\t\t\t\t\ttrack->f.sampleWidth = 64;\n\t\t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_DOUBLE;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttrack->f.sampleWidth = 32;\n\t\t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_FLOAT;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (subformat == _af_wave_guid_alaw ||\n\t\t\t\tsubformat == _af_wave_guid_ulaw)\n\t\t\t{\n\t\t\t\ttrack->f.compressionType = subformat == _af_wave_guid_alaw ?\n\t\t\t\t\tAF_COMPRESSION_G711_ALAW : AF_COMPRESSION_G711_ULAW;\n\t\t\t\ttrack->f.sampleWidth = 16;\n\t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n\t\t\t\ttrack->f.byteOrder = _AF_BYTEORDER_NATIVE;\n\t\t\t\ttrack->f.bytesPerPacket = channelCount;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"WAVE extensible data format %s is not currently supported\", subformat.name().c_str());\n\t\t\t\treturn AF_FAIL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase WAVE_FORMAT_YAMAHA_ADPCM:\n\t\tcase WAVE_FORMAT_OKI_ADPCM:\n\t\tcase WAVE_FORMAT_CREATIVE_ADPCM:\n\t\tcase IBM_FORMAT_ADPCM:\n\t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"WAVE ADPCM data format 0x%x is not currently supported\", formatTag);\n\t\t\treturn AF_FAIL;\n\t\t\tbreak;\n\n\t\tcase WAVE_FORMAT_MPEG:\n\t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"WAVE MPEG data format is not supported\");\n\t\t\treturn AF_FAIL;\n\t\t\tbreak;\n\n\t\tcase WAVE_FORMAT_MPEGLAYER3:\n\t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"WAVE MPEG layer 3 data format is not supported\");\n\t\t\treturn AF_FAIL;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"WAVE file data format 0x%x not currently supported != 0xfffe ? %d, != EXTENSIBLE? %d\", formatTag, formatTag != 0xfffe, formatTag != WAVE_FORMAT_EXTENSIBLE);\n\t\t\treturn AF_FAIL;\n\t\t\tbreak;\n\t}\n\n\tif (track->f.isUncompressed())\n\t\ttrack->f.computeBytesPerPacketPCM();\n\n\t_af_set_sample_format(&track->f, track->f.sampleFormat, track->f.sampleWidth);\n\n\treturn AF_SUCCEED;\n}\n\nstatus WAVEFile::parseData(const Tag &id, uint32_t size)\n{\n\tTrack *track = getTrack();\n\n\ttrack->fpos_first_frame = m_fh->tell();\n\ttrack->data_size = size;\n\n\treturn AF_SUCCEED;\n}\n\nstatus WAVEFile::parsePlayList(const Tag &id, uint32_t size)\n{\n\tuint32_t segmentCount;\n\treadU32(&segmentCount);\n\n\tif (segmentCount == 0)\n\t{\n\t\tm_instrumentCount = 0;\n\t\tm_instruments = NULL;\n\t\treturn AF_SUCCEED;\n\t}\n\n\tfor (unsigned segment=0; segment<segmentCount; segment++)\n\t{\n\t\tuint32_t startMarkID, loopLength, loopCount;\n\n\t\treadU32(&startMarkID);\n\t\treadU32(&loopLength);\n\t\treadU32(&loopCount);\n\t}\n\n\treturn AF_SUCCEED;\n}\n\nstatus WAVEFile::parseCues(const Tag &id, uint32_t size)\n{\n\tTrack *track = getTrack();\n\n\tuint32_t markerCount;\n\treadU32(&markerCount);\n\ttrack->markerCount = markerCount;\n\n\tif (markerCount == 0)\n\t{\n\t\ttrack->markers = NULL;\n\t\treturn AF_SUCCEED;\n\t}\n\n\tif ((track->markers = _af_marker_new(markerCount)) == NULL)\n\t\treturn AF_FAIL;\n\n\tfor (unsigned i=0; i<markerCount; i++)\n\t{\n\t\tuint32_t id, position, chunkid;\n\t\tuint32_t chunkByteOffset, blockByteOffset;\n\t\tuint32_t sampleFrameOffset;\n\t\tMarker *marker = &track->markers[i];\n\n\t\treadU32(&id);\n\t\treadU32(&position);\n\t\treadU32(&chunkid);\n\t\treadU32(&chunkByteOffset);\n\t\treadU32(&blockByteOffset);\n\n\t\t/*\n\t\t\tsampleFrameOffset represents the position of\n\t\t\tthe mark in units of frames.\n\t\t*/\n\t\treadU32(&sampleFrameOffset);\n\n\t\tmarker->id = id;\n\t\tmarker->position = sampleFrameOffset;\n\t\tmarker->name = _af_strdup(\"\");\n\t\tmarker->comment = _af_strdup(\"\");\n\t}\n\n\treturn AF_SUCCEED;\n}\n\n/* Parse an adtl sub-chunk within a LIST chunk. */\nstatus WAVEFile::parseADTLSubChunk(const Tag &id, uint32_t size)\n{\n\tTrack *track = getTrack();\n\n\tAFfileoffset endPos = m_fh->tell() + size;\n\n\twhile (m_fh->tell() < endPos)\n\t{\n\t\tTag chunkID;\n\t\tuint32_t chunkSize;\n\n\t\treadTag(&chunkID);\n\t\treadU32(&chunkSize);\n\n\t\tif (chunkID == \"labl\" || chunkID == \"note\")\n\t\t{\n\t\t\tuint32_t id;\n\t\t\tlong length=chunkSize-4;\n\t\t\tchar *p = (char *) _af_malloc(length);\n\n\t\t\treadU32(&id);\n\t\t\tm_fh->read(p, length);\n\n\t\t\tMarker *marker = track->getMarker(id);\n\n\t\t\tif (marker)\n\t\t\t{\n\t\t\t\tif (chunkID == \"labl\")\n\t\t\t\t{\n\t\t\t\t\tfree(marker->name);\n\t\t\t\t\tmarker->name = p;\n\t\t\t\t}\n\t\t\t\telse if (chunkID == \"note\")\n\t\t\t\t{\n\t\t\t\t\tfree(marker->comment);\n\t\t\t\t\tmarker->comment = p;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tfree(p);\n\t\t\t}\n\t\t\telse\n\t\t\t\tfree(p);\n\n\t\t\t/*\n\t\t\t\tIf chunkSize is odd, skip an extra byte\n\t\t\t\tat the end of the chunk.\n\t\t\t*/\n\t\t\tif ((chunkSize % 2) != 0)\n\t\t\t\tm_fh->seek(1, File::SeekFromCurrent);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* If chunkSize is odd, skip an extra byte. */\n\t\t\tm_fh->seek(chunkSize + (chunkSize % 2), File::SeekFromCurrent);\n\t\t}\n\t}\n\treturn AF_SUCCEED;\n}\n\n/* Parse an INFO sub-chunk within a LIST chunk. */\nstatus WAVEFile::parseINFOSubChunk(const Tag &id, uint32_t size)\n{\n\tAFfileoffset endPos = m_fh->tell() + size;\n\n\twhile (m_fh->tell() < endPos)\n\t{\n\t\tint misctype = AF_MISC_UNRECOGNIZED;\n\t\tTag miscid;\n\t\tuint32_t miscsize;\n\n\t\treadTag(&miscid);\n\t\treadU32(&miscsize);\n\n\t\tif (miscid == \"IART\")\n\t\t\tmisctype = AF_MISC_AUTH;\n\t\telse if (miscid == \"INAM\")\n\t\t\tmisctype = AF_MISC_NAME;\n\t\telse if (miscid == \"ICOP\")\n\t\t\tmisctype = AF_MISC_COPY;\n\t\telse if (miscid == \"ICMT\")\n\t\t\tmisctype = AF_MISC_ICMT;\n\t\telse if (miscid == \"ICRD\")\n\t\t\tmisctype = AF_MISC_ICRD;\n\t\telse if (miscid == \"ISFT\")\n\t\t\tmisctype = AF_MISC_ISFT;\n\n\t\tif (misctype != AF_MISC_UNRECOGNIZED)\n\t\t{\n\t\t\tchar *string = (char *) _af_malloc(miscsize);\n\n\t\t\tm_fh->read(string, miscsize);\n\n\t\t\tm_miscellaneousCount++;\n\t\t\tm_miscellaneous = (Miscellaneous *) _af_realloc(m_miscellaneous, sizeof (Miscellaneous) * m_miscellaneousCount);\n\n\t\t\tm_miscellaneous[m_miscellaneousCount-1].id = m_miscellaneousCount;\n\t\t\tm_miscellaneous[m_miscellaneousCount-1].type = misctype;\n\t\t\tm_miscellaneous[m_miscellaneousCount-1].size = miscsize;\n\t\t\tm_miscellaneous[m_miscellaneousCount-1].position = 0;\n\t\t\tm_miscellaneous[m_miscellaneousCount-1].buffer = string;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tm_fh->seek(miscsize, File::SeekFromCurrent);\n\t\t}\n\n\t\t/* Make the current position an even number of bytes.  */\n\t\tif (miscsize % 2 != 0)\n\t\t\tm_fh->seek(1, File::SeekFromCurrent);\n\t}\n\treturn AF_SUCCEED;\n}\n\nstatus WAVEFile::parseList(const Tag &id, uint32_t size)\n{\n\tTag typeID;\n\treadTag(&typeID);\n\tsize-=4;\n\n\tif (typeID == \"adtl\")\n\t{\n\t\t/* Handle adtl sub-chunks. */\n\t\treturn parseADTLSubChunk(typeID, size);\n\t}\n\telse if (typeID == \"INFO\")\n\t{\n\t\t/* Handle INFO sub-chunks. */\n\t\treturn parseINFOSubChunk(typeID, size);\n\t}\n\telse\n\t{\n\t\t/* Skip unhandled sub-chunks. */\n\t\tm_fh->seek(size, File::SeekFromCurrent);\n\t\treturn AF_SUCCEED;\n\t}\n\treturn AF_SUCCEED;\n}\n\nstatus WAVEFile::parseInstrument(const Tag &id, uint32_t size)\n{\n\tuint8_t baseNote;\n\tint8_t detune, gain;\n\tuint8_t lowNote, highNote, lowVelocity, highVelocity;\n\tuint8_t padByte;\n\n\treadU8(&baseNote);\n\treadS8(&detune);\n\treadS8(&gain);\n\treadU8(&lowNote);\n\treadU8(&highNote);\n\treadU8(&lowVelocity);\n\treadU8(&highVelocity);\n\treadU8(&padByte);\n\n\treturn AF_SUCCEED;\n}\n\nbool WAVEFile::recognize(File *fh)\n{\n\tuint8_t buffer[8];\n\n\tfh->seek(0, File::SeekFromBeginning);\n\n\tif (fh->read(buffer, 8) != 8 || memcmp(buffer, \"RIFF\", 4) != 0)\n\t\treturn false;\n\tif (fh->read(buffer, 4) != 4 || memcmp(buffer, \"WAVE\", 4) != 0)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatus WAVEFile::readInit(AFfilesetup setup)\n{\n\tTag type, formtype;\n\tuint32_t size;\n\tuint32_t index = 0;\n\n\tbool hasFormat = false;\n\tbool hasData = false;\n\tbool hasFrameCount = false;\n\n\tTrack *track = allocateTrack();\n\n\tm_fh->seek(0, File::SeekFromBeginning);\n\n\treadTag(&type);\n\treadU32(&size);\n\treadTag(&formtype);\n\n\tassert(type == \"RIFF\");\n\tassert(formtype == \"WAVE\");\n\n\t/* Include the offset of the form type. */\n\tindex += 4;\n\n\twhile (index < size)\n\t{\n\t\tTag chunkid;\n\t\tuint32_t chunksize = 0;\n\t\tstatus result;\n\n\t\treadTag(&chunkid);\n\t\treadU32(&chunksize);\n\n\t\tif (chunkid == \"fmt \")\n\t\t{\n\t\t\tresult = parseFormat(chunkid, chunksize);\n\t\t\tif (result == AF_FAIL)\n\t\t\t\treturn AF_FAIL;\n\n\t\t\thasFormat = true;\n\t\t}\n\t\telse if (chunkid == \"data\")\n\t\t{\n\t\t\t/* The format chunk must precede the data chunk. */\n\t\t\tif (!hasFormat)\n\t\t\t{\n\t\t\t\t_af_error(AF_BAD_HEADER, \"missing format chunk in WAVE file\");\n\t\t\t\treturn AF_FAIL;\n\t\t\t}\n\n\t\t\tresult = parseData(chunkid, chunksize);\n\t\t\tif (result == AF_FAIL)\n\t\t\t\treturn AF_FAIL;\n\n\t\t\thasData = true;\n\t\t}\n\t\telse if (chunkid == \"inst\")\n\t\t{\n\t\t\tresult = parseInstrument(chunkid, chunksize);\n\t\t\tif (result == AF_FAIL)\n\t\t\t\treturn AF_FAIL;\n\t\t}\n\t\telse if (chunkid == \"fact\")\n\t\t{\n\t\t\thasFrameCount = true;\n\t\t\tresult = parseFrameCount(chunkid, chunksize);\n\t\t\tif (result == AF_FAIL)\n\t\t\t\treturn AF_FAIL;\n\t\t}\n\t\telse if (chunkid == \"cue \")\n\t\t{\n\t\t\tresult = parseCues(chunkid, chunksize);\n\t\t\tif (result == AF_FAIL)\n\t\t\t\treturn AF_FAIL;\n\t\t}\n\t\telse if (chunkid == \"LIST\" || chunkid == \"list\")\n\t\t{\n\t\t\tresult = parseList(chunkid, chunksize);\n\t\t\tif (result == AF_FAIL)\n\t\t\t\treturn AF_FAIL;\n\t\t}\n\t\telse if (chunkid == \"INST\")\n\t\t{\n\t\t\tresult = parseInstrument(chunkid, chunksize);\n\t\t\tif (result == AF_FAIL)\n\t\t\t\treturn AF_FAIL;\n\t\t}\n\t\telse if (chunkid == \"plst\")\n\t\t{\n\t\t\tresult = parsePlayList(chunkid, chunksize);\n\t\t\tif (result == AF_FAIL)\n\t\t\t\treturn AF_FAIL;\n\t\t}\n\n\t\tindex += chunksize + 8;\n\n\t\t/* All chunks must be aligned on an even number of bytes */\n\t\tif ((index % 2) != 0)\n\t\t\tindex++;\n\n\t\tm_fh->seek(index + 8, File::SeekFromBeginning);\n\t}\n\n\t/* The format chunk and the data chunk are required. */\n\tif (!hasFormat || !hasData)\n\t{\n\t\treturn AF_FAIL;\n\t}\n\n\t/*\n\t\tAt this point we know that the file has a format chunk and a\n\t\tdata chunk, so we can assume that track->f and track->data_size\n\t\thave been initialized.\n\t*/\n\tif (!hasFrameCount)\n\t{\n\t\tif (track->f.bytesPerPacket && track->f.framesPerPacket)\n\t\t{\n\t\t\ttrack->computeTotalFileFrames();\n\t\t}\n\t\telse\n\t\t{\n\t\t\t_af_error(AF_BAD_HEADER, \"Frame count required but not found\");\n\t\t\treturn AF_FAIL;\n\t\t}\n\t}\n\n\treturn AF_SUCCEED;\n}\n\nAFfilesetup WAVEFile::completeSetup(AFfilesetup setup)\n{\n\tif (setup->trackSet && setup->trackCount != 1)\n\t{\n\t\t_af_error(AF_BAD_NUMTRACKS, \"WAVE file must have 1 track\");\n\t\treturn AF_NULL_FILESETUP;\n\t}\n\n\tTrackSetup *track = setup->getTrack();\n\tif (!track)\n\t\treturn AF_NULL_FILESETUP;\n\n\tif (track->f.isCompressed())\n\t{\n\t\tif (!track->sampleFormatSet)\n\t\t\t_af_set_sample_format(&track->f, AF_SAMPFMT_TWOSCOMP, 16);\n\t\telse\n\t\t\t_af_set_sample_format(&track->f, track->f.sampleFormat, track->f.sampleWidth);\n\t}\n\telse if (track->sampleFormatSet)\n\t{\n\t\tswitch (track->f.sampleFormat)\n\t\t{\n\t\t\tcase AF_SAMPFMT_FLOAT:\n\t\t\t\tif (track->sampleWidthSet &&\n\t\t\t\t\ttrack->f.sampleWidth != 32)\n\t\t\t\t{\n\t\t\t\t\t_af_error(AF_BAD_WIDTH,\n\t\t\t\t\t\t\"Warning: invalid sample width for floating-point WAVE file: %d (must be 32 bits)\\n\",\n\t\t\t\t\t\ttrack->f.sampleWidth);\n\t\t\t\t\t_af_set_sample_format(&track->f, AF_SAMPFMT_FLOAT, 32);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase AF_SAMPFMT_DOUBLE:\n\t\t\t\tif (track->sampleWidthSet &&\n\t\t\t\t\ttrack->f.sampleWidth != 64)\n\t\t\t\t{\n\t\t\t\t\t_af_error(AF_BAD_WIDTH,\n\t\t\t\t\t\t\"Warning: invalid sample width for double-precision floating-point WAVE file: %d (must be 64 bits)\\n\",\n\t\t\t\t\t\ttrack->f.sampleWidth);\n\t\t\t\t\t_af_set_sample_format(&track->f, AF_SAMPFMT_DOUBLE, 64);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase AF_SAMPFMT_UNSIGNED:\n\t\t\t\tif (track->sampleWidthSet)\n\t\t\t\t{\n\t\t\t\t\tif (track->f.sampleWidth < 1 || track->f.sampleWidth > 32)\n\t\t\t\t\t{\n\t\t\t\t\t\t_af_error(AF_BAD_WIDTH, \"invalid sample width for WAVE file: %d (must be 1-32 bits)\\n\", track->f.sampleWidth);\n\t\t\t\t\t\treturn AF_NULL_FILESETUP;\n\t\t\t\t\t}\n\t\t\t\t\tif (track->f.sampleWidth > 8)\n\t\t\t\t\t{\n\t\t\t\t\t\t_af_error(AF_BAD_SAMPFMT, \"WAVE integer data of more than 8 bits must be two's complement signed\");\n\t\t\t\t\t\t_af_set_sample_format(&track->f, AF_SAMPFMT_TWOSCOMP, track->f.sampleWidth);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t/*\n\t\t\t\t\tIf the sample width is not set but the user requests\n\t\t\t\t\tunsigned data, set the width to 8 bits.\n\t\t\t\t*/\n\t\t\t\t\t_af_set_sample_format(&track->f, track->f.sampleFormat, 8);\n\t\t\t\tbreak;\n\n\t\t\tcase AF_SAMPFMT_TWOSCOMP:\n\t\t\t\tif (track->sampleWidthSet)\n\t\t\t\t{\n\t\t\t\t\tif (track->f.sampleWidth < 1 || track->f.sampleWidth > 32)\n\t\t\t\t\t{\n\t\t\t\t\t\t_af_error(AF_BAD_WIDTH, \"invalid sample width %d for WAVE file (must be 1-32)\", track->f.sampleWidth);\n\t\t\t\t\t\treturn AF_NULL_FILESETUP;\n\t\t\t\t\t}\n\t\t\t\t\telse if (track->f.sampleWidth <= 8)\n\t\t\t\t\t{\n\t\t\t\t\t\t_af_error(AF_BAD_SAMPFMT, \"Warning: WAVE format integer data of 1-8 bits must be unsigned; setting sample format to unsigned\");\n\t\t\t\t\t\t_af_set_sample_format(&track->f, AF_SAMPFMT_UNSIGNED, track->f.sampleWidth);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t/*\n\t\t\t\t\tIf no sample width was specified, we default to 16 bits\n\t\t\t\t\tfor signed integer data.\n\t\t\t\t*/\n\t\t\t\t\t_af_set_sample_format(&track->f, track->f.sampleFormat, 16);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t/*\n\t\tOtherwise set the sample format depending on the sample\n\t\twidth or set completely to default.\n\t*/\n\telse\n\t{\n\t\tif (!track->sampleWidthSet)\n\t\t{\n\t\t\ttrack->f.sampleWidth = 16;\n\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (track->f.sampleWidth < 1 || track->f.sampleWidth > 32)\n\t\t\t{\n\t\t\t\t_af_error(AF_BAD_WIDTH, \"invalid sample width %d for WAVE file (must be 1-32)\", track->f.sampleWidth);\n\t\t\t\treturn AF_NULL_FILESETUP;\n\t\t\t}\n\t\t\telse if (track->f.sampleWidth > 8)\n\t\t\t\t/* Here track->f.sampleWidth is in {1..32}. */\n\t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_TWOSCOMP;\n\t\t\telse\n\t\t\t\t/* Here track->f.sampleWidth is in {1..8}. */\n\t\t\t\ttrack->f.sampleFormat = AF_SAMPFMT_UNSIGNED;\n\t\t}\n\t}\n\n\tif (track->f.compressionType != AF_COMPRESSION_NONE &&\n\t\ttrack->f.compressionType != AF_COMPRESSION_G711_ULAW &&\n\t\ttrack->f.compressionType != AF_COMPRESSION_G711_ALAW &&\n\t\ttrack->f.compressionType != AF_COMPRESSION_IMA &&\n\t\ttrack->f.compressionType != AF_COMPRESSION_MS_ADPCM)\n\t{\n\t\t_af_error(AF_BAD_NOT_IMPLEMENTED, \"compression format not supported in WAVE format\");\n\t\treturn AF_NULL_FILESETUP;\n\t}\n\n\tif (track->f.isUncompressed() &&\n\t\ttrack->byteOrderSet &&\n\t\ttrack->f.byteOrder != AF_BYTEORDER_LITTLEENDIAN &&\n\t\ttrack->f.isByteOrderSignificant())\n\t{\n\t\t_af_error(AF_BAD_BYTEORDER, \"WAVE format only supports little-endian data\");\n\t\treturn AF_NULL_FILESETUP;\n\t}\n\n\tif (track->f.isUncompressed())\n\t\ttrack->f.byteOrder = AF_BYTEORDER_LITTLEENDIAN;\n\n\tif (track->aesDataSet)\n\t{\n\t\t_af_error(AF_BAD_FILESETUP, \"WAVE files cannot have AES data\");\n\t\treturn AF_NULL_FILESETUP;\n\t}\n\n\tif (setup->instrumentSet)\n\t{\n\t\tif (setup->instrumentCount > 1)\n\t\t{\n\t\t\t_af_error(AF_BAD_NUMINSTS, \"WAVE files can have 0 or 1 instrument\");\n\t\t\treturn AF_NULL_FILESETUP;\n\t\t}\n\t\telse if (setup->instrumentCount == 1)\n\t\t{\n\t\t\tif (setup->instruments[0].loopSet &&\n\t\t\t\tsetup->instruments[0].loopCount > 0 &&\n\t\t\t\t(!track->markersSet || track->markerCount == 0))\n\t\t\t{\n\t\t\t\t_af_error(AF_BAD_NUMMARKS, \"WAVE files with loops must contain at least 1 marker\");\n\t\t\t\treturn AF_NULL_FILESETUP;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Make sure the miscellaneous data is of an acceptable type. */\n\tif (setup->miscellaneousSet)\n\t{\n\t\tfor (int i=0; i<setup->miscellaneousCount; i++)\n\t\t{\n\t\t\tswitch (setup->miscellaneous[i].type)\n\t\t\t{\n\t\t\t\tcase AF_MISC_COPY:\n\t\t\t\tcase AF_MISC_AUTH:\n\t\t\t\tcase AF_MISC_NAME:\n\t\t\t\tcase AF_MISC_ICRD:\n\t\t\t\tcase AF_MISC_ISFT:\n\t\t\t\tcase AF_MISC_ICMT:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t_af_error(AF_BAD_MISCTYPE, \"illegal miscellaneous type [%d] for WAVE file\", setup->miscellaneous[i].type);\n\t\t\t\t\treturn AF_NULL_FILESETUP;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t\tAllocate an AFfilesetup and make all the unset fields correct.\n\t*/\n\tAFfilesetup\tnewsetup = _af_filesetup_copy(setup, &waveDefaultFileSetup, false);\n\n\t/* Make sure we do not copy loops if they are not specified in setup. */\n\tif (setup->instrumentSet && setup->instrumentCount > 0 &&\n\t\tsetup->instruments[0].loopSet)\n\t{\n\t\tfree(newsetup->instruments[0].loops);\n\t\tnewsetup->instruments[0].loopCount = 0;\n\t}\n\n\treturn newsetup;\n}\n\nbool WAVEFile::isInstrumentParameterValid(AUpvlist list, int i)\n{\n\tint param, type;\n\n\tAUpvgetparam(list, i, &param);\n\tAUpvgetvaltype(list, i, &type);\n\tif (type != AU_PVTYPE_LONG)\n\t\treturn false;\n\n\tlong lval;\n\tAUpvgetval(list, i, &lval);\n\n\tswitch (param)\n\t{\n\t\tcase AF_INST_MIDI_BASENOTE:\n\t\t\treturn ((lval >= 0) && (lval <= 127));\n\n\t\tcase AF_INST_NUMCENTS_DETUNE:\n\t\t\treturn ((lval >= -50) && (lval <= 50));\n\n\t\tcase AF_INST_MIDI_LOVELOCITY:\n\t\t\treturn ((lval >= 1) && (lval <= 127));\n\n\t\tcase AF_INST_MIDI_HIVELOCITY:\n\t\t\treturn ((lval >= 1) && (lval <= 127));\n\n\t\tcase AF_INST_MIDI_LONOTE:\n\t\t\treturn ((lval >= 0) && (lval <= 127));\n\n\t\tcase AF_INST_MIDI_HINOTE:\n\t\t\treturn ((lval >= 0) && (lval <= 127));\n\n\t\tcase AF_INST_NUMDBS_GAIN:\n\t\t\treturn true;\n\n\t\tdefault:\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatus WAVEFile::writeFormat()\n{\n\tuint16_t\tformatTag, channelCount;\n\tuint32_t\tsampleRate, averageBytesPerSecond;\n\tuint16_t\tblockAlign;\n\tuint32_t\tchunkSize;\n\tuint16_t\tbitsPerSample;\n\n\tTrack *track = getTrack();\n\n\tm_fh->write(\"fmt \", 4);\n\n\tswitch (track->f.compressionType)\n\t{\n\t\tcase AF_COMPRESSION_NONE:\n\t\t\tchunkSize = 16;\n\t\t\tif (track->f.sampleFormat == AF_SAMPFMT_FLOAT ||\n\t\t\t\ttrack->f.sampleFormat == AF_SAMPFMT_DOUBLE)\n\t\t\t{\n\t\t\t\tformatTag = WAVE_FORMAT_IEEE_FLOAT;\n\t\t\t}\n\t\t\telse if (track->f.sampleFormat == AF_SAMPFMT_TWOSCOMP ||\n\t\t\t\ttrack->f.sampleFormat == AF_SAMPFMT_UNSIGNED)\n\t\t\t{\n\t\t\t\tformatTag = WAVE_FORMAT_PCM;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t_af_error(AF_BAD_COMPTYPE, \"bad sample format\");\n\t\t\t\treturn AF_FAIL;\n\t\t\t}\n\n\t\t\tblockAlign = _af_format_frame_size(&track->f, false);\n\t\t\tbitsPerSample = 8 * _af_format_sample_size(&track->f, false);\n\t\t\tbreak;\n\n\t\t/*\n\t\t\tG.711 compression uses eight bits per sample.\n\t\t*/\n\t\tcase AF_COMPRESSION_G711_ULAW:\n\t\t\tchunkSize = 18;\n\t\t\tformatTag = IBM_FORMAT_MULAW;\n\t\t\tblockAlign = track->f.channelCount;\n\t\t\tbitsPerSample = 8;\n\t\t\tbreak;\n\n\t\tcase AF_COMPRESSION_G711_ALAW:\n\t\t\tchunkSize = 18;\n\t\t\tformatTag = IBM_FORMAT_ALAW;\n\t\t\tblockAlign = track->f.channelCount;\n\t\t\tbitsPerSample = 8;\n\t\t\tbreak;\n\n\t\tcase AF_COMPRESSION_IMA:\n\t\t\tchunkSize = 20;\n\t\t\tformatTag = WAVE_FORMAT_DVI_ADPCM;\n\t\t\tblockAlign = track->f.bytesPerPacket;\n\t\t\tbitsPerSample = 4;\n\t\t\tbreak;\n\n\t\tcase AF_COMPRESSION_MS_ADPCM:\n\t\t\tchunkSize = 50;\n\t\t\tformatTag = WAVE_FORMAT_ADPCM;\n\t\t\tblockAlign = track->f.bytesPerPacket;\n\t\t\tbitsPerSample = 4;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t_af_error(AF_BAD_COMPTYPE, \"bad compression type\");\n\t\t\treturn AF_FAIL;\n\t}\n\n\twriteU32(&chunkSize);\n\twriteU16(&formatTag);\n\n\tchannelCount = track->f.channelCount;\n\twriteU16(&channelCount);\n\n\tsampleRate = track->f.sampleRate;\n\twriteU32(&sampleRate);\n\n\taverageBytesPerSecond =\n\t\ttrack->f.sampleRate * _af_format_frame_size(&track->f, false);\n\tif (track->f.compressionType == AF_COMPRESSION_IMA ||\n\t\ttrack->f.compressionType == AF_COMPRESSION_MS_ADPCM)\n\t\taverageBytesPerSecond = track->f.sampleRate * track->f.bytesPerPacket /\n\t\t\ttrack->f.framesPerPacket;\n\twriteU32(&averageBytesPerSecond);\n\n\twriteU16(&blockAlign);\n\n\twriteU16(&bitsPerSample);\n\n\tif (track->f.compressionType == AF_COMPRESSION_G711_ULAW ||\n\t\ttrack->f.compressionType == AF_COMPRESSION_G711_ALAW)\n\t{\n\t\tuint16_t zero = 0;\n\t\twriteU16(&zero);\n\t}\n\telse if (track->f.compressionType == AF_COMPRESSION_IMA)\n\t{\n\t\tuint16_t extraByteCount = 2;\n\t\twriteU16(&extraByteCount);\n\t\tuint16_t samplesPerBlock = track->f.framesPerPacket;\n\t\twriteU16(&samplesPerBlock);\n\t}\n\telse if (track->f.compressionType == AF_COMPRESSION_MS_ADPCM)\n\t{\n\t\tuint16_t extraByteCount = 2 + 2 + m_msadpcmNumCoefficients * 4;\n\t\twriteU16(&extraByteCount);\n\t\tuint16_t samplesPerBlock = track->f.framesPerPacket;\n\t\twriteU16(&samplesPerBlock);\n\n\t\tuint16_t numCoefficients = m_msadpcmNumCoefficients;\n\t\twriteU16(&numCoefficients);\n\n\t\tfor (int i=0; i<m_msadpcmNumCoefficients; i++)\n\t\t{\n\t\t\twriteS16(&m_msadpcmCoefficients[i][0]);\n\t\t\twriteS16(&m_msadpcmCoefficients[i][1]);\n\t\t}\n\t}\n\n\treturn AF_SUCCEED;\n}\n\nstatus WAVEFile::writeFrameCount()\n{\n\tuint32_t factSize = 4;\n\tuint32_t totalFrameCount;\n\n\tTrack *track = getTrack();\n\n\t/* Omit the fact chunk only for uncompressed integer audio formats. */\n\tif (track->f.compressionType == AF_COMPRESSION_NONE &&\n\t\t(track->f.sampleFormat == AF_SAMPFMT_TWOSCOMP ||\n\t\ttrack->f.sampleFormat == AF_SAMPFMT_UNSIGNED))\n\t\treturn AF_SUCCEED;\n\n\t/*\n\t\tIf the offset for the fact chunk hasn't been set yet,\n\t\tset it to the file's current position.\n\t*/\n\tif (m_factOffset == 0)\n\t\tm_factOffset = m_fh->tell();\n\telse\n\t\tm_fh->seek(m_factOffset, File::SeekFromBeginning);\n\n\tm_fh->write(\"fact\", 4);\n\twriteU32(&factSize);\n\n\ttotalFrameCount = track->totalfframes;\n\twriteU32(&totalFrameCount);\n\n\treturn AF_SUCCEED;\n}\n\nstatus WAVEFile::writeData()\n{\n\tTrack *track = getTrack();\n\n\tm_fh->write(\"data\", 4);\n\tm_dataSizeOffset = m_fh->tell();\n\n\tuint32_t chunkSize = track->data_size;\n\n\twriteU32(&chunkSize);\n\ttrack->fpos_first_frame = m_fh->tell();\n\n\treturn AF_SUCCEED;\n}\n\nstatus WAVEFile::update()\n{\n\tTrack *track = getTrack();\n\n\tif (track->fpos_first_frame != 0)\n\t{\n\t\tuint32_t dataLength, fileLength;\n\n\t\t// Update the frame count chunk if present.\n\t\twriteFrameCount();\n\n\t\t// Update the length of the data chunk.\n\t\tm_fh->seek(m_dataSizeOffset, File::SeekFromBeginning);\n\t\tdataLength = (uint32_t) track->data_size;\n\t\twriteU32(&dataLength);\n\n\t\t// Update the length of the RIFF chunk.\n\t\tfileLength = (uint32_t) m_fh->length();\n\t\tfileLength -= 8;\n\n\t\tm_fh->seek(4, File::SeekFromBeginning);\n\t\twriteU32(&fileLength);\n\t}\n\n\t/*\n\t\tWrite the actual data that was set after initializing\n\t\tthe miscellaneous IDs.\tThe size of the data will be\n\t\tunchanged.\n\t*/\n\twriteMiscellaneous();\n\n\t// Write the new positions; the size of the data will be unchanged.\n\twriteCues();\n\n\treturn AF_SUCCEED;\n}\n\n/* Convert an Audio File Library miscellaneous type to a WAVE type. */\nstatic bool misc_type_to_wave (int misctype, Tag *miscid)\n{\n\tif (misctype == AF_MISC_AUTH)\n\t\t*miscid = \"IART\";\n\telse if (misctype == AF_MISC_NAME)\n\t\t*miscid = \"INAM\";\n\telse if (misctype == AF_MISC_COPY)\n\t\t*miscid = \"ICOP\";\n\telse if (misctype == AF_MISC_ICMT)\n\t\t*miscid = \"ICMT\";\n\telse if (misctype == AF_MISC_ICRD)\n\t\t*miscid = \"ICRD\";\n\telse if (misctype == AF_MISC_ISFT)\n\t\t*miscid = \"ISFT\";\n\telse\n\t\treturn false;\n\n\treturn true;\n}\n\nstatus WAVEFile::writeMiscellaneous()\n{\n\tif (m_miscellaneousCount != 0)\n\t{\n\t\tuint32_t\tmiscellaneousBytes;\n\t\tuint32_t \tchunkSize;\n\n\t\t/* Start at 12 to account for 'LIST', size, and 'INFO'. */\n\t\tmiscellaneousBytes = 12;\n\n\t\t/* Then calculate the size of the whole INFO chunk. */\n\t\tfor (int i=0; i<m_miscellaneousCount; i++)\n\t\t{\n\t\t\tTag miscid;\n\n\t\t\t// Skip miscellaneous data of an unsupported type.\n\t\t\tif (!misc_type_to_wave(m_miscellaneous[i].type, &miscid))\n\t\t\t\tcontinue;\n\n\t\t\t// Account for miscellaneous type and size.\n\t\t\tmiscellaneousBytes += 8;\n\t\t\tmiscellaneousBytes += m_miscellaneous[i].size;\n\n\t\t\t// Add a pad byte if necessary.\n\t\t\tif (m_miscellaneous[i].size % 2 != 0)\n\t\t\t\tmiscellaneousBytes++;\n\n\t\t\tassert(miscellaneousBytes % 2 == 0);\n\t\t}\n\n\t\tif (m_miscellaneousOffset == 0)\n\t\t\tm_miscellaneousOffset = m_fh->tell();\n\t\telse\n\t\t\tm_fh->seek(m_miscellaneousOffset, File::SeekFromBeginning);\n\n\t\t/*\n\t\t\tWrite the data.  On the first call to this\n\t\t\tfunction (from _af_wave_write_init), the\n\t\t\tdata won't be available, fh->seek is used to\n\t\t\treserve space until the data has been provided.\n\t\t\tOn subseuent calls to this function (from\n\t\t\t_af_wave_update), the data will really be written.\n\t\t*/\n\n\t\t/* Write 'LIST'. */\n\t\tm_fh->write(\"LIST\", 4);\n\n\t\t/* Write the size of the following chunk. */\n\t\tchunkSize = miscellaneousBytes-8;\n\t\twriteU32(&chunkSize);\n\n\t\t/* Write 'INFO'. */\n\t\tm_fh->write(\"INFO\", 4);\n\n\t\t/* Write each miscellaneous chunk. */\n\t\tfor (int i=0; i<m_miscellaneousCount; i++)\n\t\t{\n\t\t\tuint32_t miscsize = m_miscellaneous[i].size;\n\t\t\tTag miscid;\n\n\t\t\t// Skip miscellaneous data of an unsupported type.\n\t\t\tif (!misc_type_to_wave(m_miscellaneous[i].type, &miscid))\n\t\t\t\tcontinue;\n\n\t\t\twriteTag(&miscid);\n\t\t\twriteU32(&miscsize);\n\t\t\tif (m_miscellaneous[i].buffer != NULL)\n\t\t\t{\n\t\t\t\tuint8_t\tzero = 0;\n\n\t\t\t\tm_fh->write(m_miscellaneous[i].buffer, m_miscellaneous[i].size);\n\n\t\t\t\t// Pad if necessary.\n\t\t\t\tif ((m_miscellaneous[i].size%2) != 0)\n\t\t\t\t\twriteU8(&zero);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint\tsize;\n\t\t\t\tsize = m_miscellaneous[i].size;\n\n\t\t\t\t// Pad if necessary.\n\t\t\t\tif ((size % 2) != 0)\n\t\t\t\t\tsize++;\n\t\t\t\tm_fh->seek(size, File::SeekFromCurrent);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn AF_SUCCEED;\n}\n\nstatus WAVEFile::writeCues()\n{\n\tTrack *track = getTrack();\n\n\tif (!track->markerCount)\n\t\treturn AF_SUCCEED;\n\n\tif (m_markOffset == 0)\n\t\tm_markOffset = m_fh->tell();\n\telse\n\t\tm_fh->seek(m_markOffset, File::SeekFromBeginning);\n\n\tTag cue(\"cue \");\n\twriteTag(&cue);\n\n\t/*\n\t\tThe cue chunk consists of 4 bytes for the number of cue points\n\t\tfollowed by 24 bytes for each cue point record.\n\t*/\n\tuint32_t cueChunkSize = 4 + track->markerCount * 24;\n\twriteU32(&cueChunkSize);\n\tuint32_t numCues = track->markerCount;\n\twriteU32(&numCues);\n\n\t// Write each marker to the file.\n\tfor (int i=0; i<track->markerCount; i++)\n\t{\n\t\tuint32_t identifier = track->markers[i].id;\n\t\twriteU32(&identifier);\n\n\t\tuint32_t position = i;\n\t\twriteU32(&position);\n\n\t\tTag data(\"data\");\n\t\twriteTag(&data);\n\n\t\t/*\n\t\t\tFor an uncompressed WAVE file which contains only one data chunk,\n\t\t\tchunkStart and blockStart are zero.\n\t\t*/\n\t\tuint32_t chunkStart = 0;\n\t\twriteU32(&chunkStart);\n\n\t\tuint32_t blockStart = 0;\n\t\twriteU32(&blockStart);\n\n\t\tAFframecount markPosition = track->markers[i].position;\n\t\tuint32_t sampleOffset = markPosition;\n\t\twriteU32(&sampleOffset);\n\t}\n\n\t// Now write the cue names and comments within a master list chunk.\n\tuint32_t listChunkSize = 4;\n\tfor (int i=0; i<track->markerCount; i++)\n\t{\n\t\tconst char *name = track->markers[i].name;\n\t\tconst char *comment = track->markers[i].comment;\n\n\t\t/*\n\t\t\tEach 'labl' or 'note' chunk consists of 4 bytes for the chunk ID,\n\t\t\t4 bytes for the chunk data size, 4 bytes for the cue point ID,\n\t\t\tand then the length of the label as a null-terminated string.\n\n\t\t\tIn all, this is 12 bytes plus the length of the string, its null\n\t\t\ttermination byte, and a trailing pad byte if the length of the\n\t\t\tchunk is otherwise odd.\n\t\t*/\n\t\tlistChunkSize += 12 + zStringLength(name);\n\t\tlistChunkSize += 12 + zStringLength(comment);\n\t}\n\n\tTag list(\"LIST\");\n\twriteTag(&list);\n\twriteU32(&listChunkSize);\n\tTag adtl(\"adtl\");\n\twriteTag(&adtl);\n\n\tfor (int i=0; i<track->markerCount; i++)\n\t{\n\t\tuint32_t cuePointID = track->markers[i].id;\n\n\t\tconst char *name = track->markers[i].name;\n\t\tuint32_t labelSize = 4 + zStringLength(name);\n\t\tTag lablTag(\"labl\");\n\t\twriteTag(&lablTag);\n\t\twriteU32(&labelSize);\n\t\twriteU32(&cuePointID);\n\t\twriteZString(name);\n\n\t\tconst char *comment = track->markers[i].comment;\n\t\tuint32_t noteSize = 4 + zStringLength(comment);\n\t\tTag noteTag(\"note\");\n\t\twriteTag(&noteTag);\n\t\twriteU32(&noteSize);\n\t\twriteU32(&cuePointID);\n\t\twriteZString(comment);\n\t}\n\n\treturn AF_SUCCEED;\n}\n\nbool WAVEFile::writeZString(const char *s)\n{\n\tssize_t lengthPlusNull = strlen(s) + 1;\n\tif (m_fh->write(s, lengthPlusNull) != lengthPlusNull)\n\t\treturn false;\n\tif (lengthPlusNull & 1)\n\t{\n\t\tuint8_t zero = 0;\n\t\tif (!writeU8(&zero))\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nsize_t WAVEFile::zStringLength(const char *s)\n{\n\tsize_t lengthPlusNull = strlen(s) + 1;\n\treturn lengthPlusNull + (lengthPlusNull & 1);\n}\n\nstatus WAVEFile::writeInit(AFfilesetup setup)\n{\n\tif (initFromSetup(setup) == AF_FAIL)\n\t\treturn AF_FAIL;\n\n\tinitCompressionParams();\n\n\tuint32_t zero = 0;\n\n\tm_fh->seek(0, File::SeekFromBeginning);\n\tm_fh->write(\"RIFF\", 4);\n\tm_fh->write(&zero, 4);\n\tm_fh->write(\"WAVE\", 4);\n\n\twriteMiscellaneous();\n\twriteCues();\n\twriteFormat();\n\twriteFrameCount();\n\twriteData();\n\n\treturn AF_SUCCEED;\n}\n\nbool WAVEFile::readUUID(UUID *u)\n{\n\treturn m_fh->read(u->data, 16) == 16;\n}\n\nbool WAVEFile::writeUUID(const UUID *u)\n{\n\treturn m_fh->write(u->data, 16) == 16;\n}\n\nvoid WAVEFile::initCompressionParams()\n{\n\tTrack *track = getTrack();\n\tif (track->f.compressionType == AF_COMPRESSION_IMA)\n\t\tinitIMACompressionParams();\n\telse if (track->f.compressionType == AF_COMPRESSION_MS_ADPCM)\n\t\tinitMSADPCMCompressionParams();\n}\n\nvoid WAVEFile::initIMACompressionParams()\n{\n\tTrack *track = getTrack();\n\n\ttrack->f.framesPerPacket = 505;\n\ttrack->f.bytesPerPacket = 256 * track->f.channelCount;\n\n\tAUpvlist pv = AUpvnew(1);\n\tAUpvsetparam(pv, 0, _AF_IMA_ADPCM_TYPE);\n\tAUpvsetvaltype(pv, 0, AU_PVTYPE_LONG);\n\tlong l = _AF_IMA_ADPCM_TYPE_WAVE;\n\tAUpvsetval(pv, 0, &l);\n\n\ttrack->f.compressionParams = pv;\n}\n\nvoid WAVEFile::initMSADPCMCompressionParams()\n{\n\tconst int16_t coefficients[7][2] =\n\t{\n\t\t{ 256, 0 },\n\t\t{ 512, -256 },\n\t\t{ 0, 0 },\n\t\t{ 192, 64 },\n\t\t{ 240, 0 },\n\t\t{ 460, -208 },\n\t\t{ 392, -232 }\n\t};\n\tmemcpy(m_msadpcmCoefficients, coefficients, sizeof (int16_t) * 7 * 2);\n\tm_msadpcmNumCoefficients = 7;\n\n\tTrack *track = getTrack();\n\n\ttrack->f.framesPerPacket = 500;\n\ttrack->f.bytesPerPacket = 256 * track->f.channelCount;\n\n\tAUpvlist pv = AUpvnew(2);\n\tAUpvsetparam(pv, 0, _AF_MS_ADPCM_NUM_COEFFICIENTS);\n\tAUpvsetvaltype(pv, 0, AU_PVTYPE_LONG);\n\tlong l = m_msadpcmNumCoefficients;\n\tAUpvsetval(pv, 0, &l);\n\n\tAUpvsetparam(pv, 1, _AF_MS_ADPCM_COEFFICIENTS);\n\tAUpvsetvaltype(pv, 1, AU_PVTYPE_PTR);\n\tvoid *v = m_msadpcmCoefficients;\n\tAUpvsetval(pv, 1, &v);\n\n\ttrack->f.compressionParams = pv;\n}\n"], "filenames": ["libaudiofile/WAVE.cpp"], "buggy_code_start_loc": [328], "buggy_code_end_loc": [335], "fixing_code_start_loc": [329], "fixing_code_end_loc": [338], "type": "CWE-119", "message": "Heap-based buffer overflow in the decodeBlockWAVE function in IMA.cpp in Audio File Library (aka audiofile) 0.3.6, 0.3.5, 0.3.4, 0.3.3, 0.3.2, 0.3.1, 0.3.0 and 0.2.7 allows remote attackers to cause a denial of service (crash) via a crafted file.", "other": {"cve": {"id": "CVE-2017-6831", "sourceIdentifier": "cve@mitre.org", "published": "2017-03-20T16:59:02.703", "lastModified": "2021-03-31T14:24:19.843", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Heap-based buffer overflow in the decodeBlockWAVE function in IMA.cpp in Audio File Library (aka audiofile) 0.3.6, 0.3.5, 0.3.4, 0.3.3, 0.3.2, 0.3.1, 0.3.0 and 0.2.7 allows remote attackers to cause a denial of service (crash) via a crafted file."}, {"lang": "es", "value": "El desbordamiento del b\u00fafer basado en Heap en la funci\u00f3n decodeBlockWAVE en IMA.cpp en Audio File Library (alias audiofile) 0.3.6, 0.3.5, 0.3.4, 0.3.3, 0.3.2, 0.3.1, 0.3.0 y 0.2.7 permite a los atacantes remotos causar una denegaci\u00f3n de servicio (crash) a trav\u00e9s de un archivo elaborado"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:audiofile:audiofile:0.2.7:*:*:*:*:*:*:*", "matchCriteriaId": "AF5A99FB-F881-4621-A9E2-3D261CC94F74"}, {"vulnerable": true, "criteria": "cpe:2.3:a:audiofile:audiofile:0.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "A874AFAB-9FE8-4436-B446-A106E336A4CE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:audiofile:audiofile:0.3.1:*:*:*:*:*:*:*", "matchCriteriaId": "FE480807-B149-4227-BC43-25A140F6D71C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:audiofile:audiofile:0.3.2:*:*:*:*:*:*:*", "matchCriteriaId": "AB2006C1-2EB3-4F4E-8DB0-C99B72700A7D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:audiofile:audiofile:0.3.3:*:*:*:*:*:*:*", "matchCriteriaId": "F2F08B96-44AC-4894-B304-642A49E6AAEE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:audiofile:audiofile:0.3.4:*:*:*:*:*:*:*", "matchCriteriaId": "A8E21929-705E-4FCC-8E61-9A5972660568"}, {"vulnerable": true, "criteria": "cpe:2.3:a:audiofile:audiofile:0.3.5:*:*:*:*:*:*:*", "matchCriteriaId": "128EEF53-482C-4FC5-9C2E-2D70E9013C6D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:audiofile:audiofile:0.3.6:*:*:*:*:*:*:*", "matchCriteriaId": "3C7E74B2-432B-4CCD-873F-AA7E012D8C7F"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "http://www.debian.org/security/2017/dsa-3814", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2017/03/13/3", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/97588", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://blogs.gentoo.org/ago/2017/02/20/audiofile-heap-based-buffer-overflow-in-imadecodeblockwave-ima-cpp/", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/Hack-Me/Pocs_for_Multi_Versions/tree/main/CVE-2017-6831", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/antlarr/audiofile/commit/a2e9eab8ea87c4ffc494d839ebb4ea145eb9f2e6", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/mpruett/audiofile/issues/35", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/antlarr/audiofile/commit/a2e9eab8ea87c4ffc494d839ebb4ea145eb9f2e6"}}