{"buggy_code": ["//! Implements the pooling instance allocator.\n//!\n//! The pooling instance allocator maps memory in advance\n//! and allocates instances, memories, tables, and stacks from\n//! a pool of available resources.\n//!\n//! Using the pooling instance allocator can speed up module instantiation\n//! when modules can be constrained based on configurable limits.\n\nuse super::{\n    initialize_instance, InstanceAllocationRequest, InstanceAllocator, InstanceHandle,\n    InstantiationError,\n};\nuse crate::{instance::Instance, Memory, Mmap, Table};\nuse crate::{MemoryImageSlot, ModuleRuntimeInfo, Store};\nuse anyhow::{anyhow, bail, Context, Result};\nuse libc::c_void;\nuse std::convert::TryFrom;\nuse std::mem;\nuse std::sync::Mutex;\nuse wasmtime_environ::{\n    DefinedMemoryIndex, DefinedTableIndex, HostPtr, Module, PrimaryMap, Tunables, VMOffsets,\n    WASM_PAGE_SIZE,\n};\n\nmod index_allocator;\nuse index_allocator::{PoolingAllocationState, SlotId};\n\ncfg_if::cfg_if! {\n    if #[cfg(windows)] {\n        mod windows;\n        use windows as imp;\n    } else {\n        mod unix;\n        use unix as imp;\n    }\n}\n\nuse imp::{commit_memory_pages, commit_table_pages, decommit_memory_pages, decommit_table_pages};\n\n#[cfg(all(feature = \"async\", unix))]\nuse imp::{commit_stack_pages, reset_stack_pages_to_zero};\n\n#[cfg(feature = \"async\")]\nuse super::FiberStackError;\n\nfn round_up_to_pow2(n: usize, to: usize) -> usize {\n    debug_assert!(to > 0);\n    debug_assert!(to.is_power_of_two());\n    (n + to - 1) & !(to - 1)\n}\n\n/// Represents the limits placed on instances by the pooling instance allocator.\n#[derive(Debug, Copy, Clone)]\npub struct InstanceLimits {\n    /// The maximum number of concurrent instances supported (default is 1000).\n    ///\n    /// This value has a direct impact on the amount of memory allocated by the pooling\n    /// instance allocator.\n    ///\n    /// The pooling instance allocator allocates three memory pools with sizes depending on this value:\n    ///\n    /// * An instance pool, where each entry in the pool can store the runtime representation\n    ///   of an instance, including a maximal `VMContext` structure.\n    ///\n    /// * A memory pool, where each entry in the pool contains the reserved address space for each\n    ///   linear memory supported by an instance.\n    ///\n    /// * A table pool, where each entry in the pool contains the space needed for each WebAssembly table\n    ///   supported by an instance (see `table_elements` to control the size of each table).\n    ///\n    /// Additionally, this value will also control the maximum number of execution stacks allowed for\n    /// asynchronous execution (one per instance), when enabled.\n    ///\n    /// The memory pool will reserve a large quantity of host process address space to elide the bounds\n    /// checks required for correct WebAssembly memory semantics. Even for 64-bit address spaces, the\n    /// address space is limited when dealing with a large number of supported instances.\n    ///\n    /// For example, on Linux x86_64, the userland address space limit is 128 TiB. That might seem like a lot,\n    /// but each linear memory will *reserve* 6 GiB of space by default. Multiply that by the number of linear\n    /// memories each instance supports and then by the number of supported instances and it becomes apparent\n    /// that address space can be exhausted depending on the number of supported instances.\n    pub count: u32,\n\n    /// The maximum size, in bytes, allocated for an instance and its\n    /// `VMContext`.\n    ///\n    /// This amount of space is pre-allocated for `count` number of instances\n    /// and is used to store the runtime `wasmtime_runtime::Instance` structure\n    /// along with its adjacent `VMContext` structure. The `Instance` type has a\n    /// static size but `VMContext` is dynamically sized depending on the module\n    /// being instantiated. This size limit loosely correlates to the size of\n    /// the wasm module, taking into account factors such as:\n    ///\n    /// * number of functions\n    /// * number of globals\n    /// * number of memories\n    /// * number of tables\n    /// * number of function types\n    ///\n    /// If the allocated size per instance is too small then instantiation of a\n    /// module will fail at runtime with an error indicating how many bytes were\n    /// needed. This amount of bytes are committed to memory per-instance when\n    /// a pooling allocator is created.\n    ///\n    /// The default value for this is 1MB.\n    pub size: usize,\n\n    /// The maximum number of defined tables for a module (default is 1).\n    ///\n    /// This value controls the capacity of the `VMTableDefinition` table in each instance's\n    /// `VMContext` structure.\n    ///\n    /// The allocated size of the table will be `tables * sizeof(VMTableDefinition)` for each\n    /// instance regardless of how many tables are defined by an instance's module.\n    pub tables: u32,\n\n    /// The maximum table elements for any table defined in a module (default is 10000).\n    ///\n    /// If a table's minimum element limit is greater than this value, the module will\n    /// fail to instantiate.\n    ///\n    /// If a table's maximum element limit is unbounded or greater than this value,\n    /// the maximum will be `table_elements` for the purpose of any `table.grow` instruction.\n    ///\n    /// This value is used to reserve the maximum space for each supported table; table elements\n    /// are pointer-sized in the Wasmtime runtime.  Therefore, the space reserved for each instance\n    /// is `tables * table_elements * sizeof::<*const ()>`.\n    pub table_elements: u32,\n\n    /// The maximum number of defined linear memories for a module (default is 1).\n    ///\n    /// This value controls the capacity of the `VMMemoryDefinition` table in each instance's\n    /// `VMContext` structure.\n    ///\n    /// The allocated size of the table will be `memories * sizeof(VMMemoryDefinition)` for each\n    /// instance regardless of how many memories are defined by an instance's module.\n    pub memories: u32,\n\n    /// The maximum number of pages for any linear memory defined in a module (default is 160).\n    ///\n    /// The default of 160 means at most 10 MiB of host memory may be committed for each instance.\n    ///\n    /// If a memory's minimum page limit is greater than this value, the module will\n    /// fail to instantiate.\n    ///\n    /// If a memory's maximum page limit is unbounded or greater than this value,\n    /// the maximum will be `memory_pages` for the purpose of any `memory.grow` instruction.\n    ///\n    /// This value is used to control the maximum accessible space for each linear memory of an instance.\n    ///\n    /// The reservation size of each linear memory is controlled by the\n    /// `static_memory_maximum_size` setting and this value cannot\n    /// exceed the configured static memory maximum size.\n    pub memory_pages: u64,\n}\n\nimpl Default for InstanceLimits {\n    fn default() -> Self {\n        // See doc comments for `wasmtime::InstanceLimits` for these default values\n        Self {\n            count: 1000,\n            size: 1 << 20, // 1 MB\n            tables: 1,\n            table_elements: 10_000,\n            memories: 1,\n            memory_pages: 160,\n        }\n    }\n}\n\n/// The allocation strategy to use for the pooling instance allocator.\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum PoolingAllocationStrategy {\n    /// Allocate from the next available instance.\n    NextAvailable,\n    /// Allocate from a random available instance.\n    Random,\n    /// Try to allocate an instance slot that was previously used for\n    /// the same module, potentially enabling faster instantiation by\n    /// reusing e.g. memory mappings.\n    ReuseAffinity,\n}\n\nimpl Default for PoolingAllocationStrategy {\n    fn default() -> Self {\n        if cfg!(memory_init_cow) {\n            Self::ReuseAffinity\n        } else {\n            Self::NextAvailable\n        }\n    }\n}\n\n/// Represents a pool of maximal `Instance` structures.\n///\n/// Each index in the pool provides enough space for a maximal `Instance`\n/// structure depending on the limits used to create the pool.\n///\n/// The pool maintains a free list for fast instance allocation.\n#[derive(Debug)]\nstruct InstancePool {\n    mapping: Mmap,\n    instance_size: usize,\n    max_instances: usize,\n    index_allocator: Mutex<PoolingAllocationState>,\n    memories: MemoryPool,\n    tables: TablePool,\n}\n\nimpl InstancePool {\n    fn new(\n        strategy: PoolingAllocationStrategy,\n        instance_limits: &InstanceLimits,\n        tunables: &Tunables,\n    ) -> Result<Self> {\n        let page_size = crate::page_size();\n\n        let instance_size = round_up_to_pow2(instance_limits.size, mem::align_of::<Instance>());\n\n        let max_instances = instance_limits.count as usize;\n\n        let allocation_size = round_up_to_pow2(\n            instance_size\n                .checked_mul(max_instances)\n                .ok_or_else(|| anyhow!(\"total size of instance data exceeds addressable memory\"))?,\n            page_size,\n        );\n\n        let mapping = Mmap::accessible_reserved(allocation_size, allocation_size)\n            .context(\"failed to create instance pool mapping\")?;\n\n        let pool = Self {\n            mapping,\n            instance_size,\n            max_instances,\n            index_allocator: Mutex::new(PoolingAllocationState::new(strategy, max_instances)),\n            memories: MemoryPool::new(instance_limits, tunables)?,\n            tables: TablePool::new(instance_limits)?,\n        };\n\n        Ok(pool)\n    }\n\n    unsafe fn instance(&self, index: usize) -> &mut Instance {\n        assert!(index < self.max_instances);\n        &mut *(self.mapping.as_mut_ptr().add(index * self.instance_size) as *mut Instance)\n    }\n\n    unsafe fn initialize_instance(\n        &self,\n        instance_index: usize,\n        req: InstanceAllocationRequest,\n    ) -> Result<InstanceHandle, InstantiationError> {\n        let module = req.runtime_info.module();\n\n        // Before doing anything else ensure that our instance slot is actually\n        // big enough to hold the `Instance` and `VMContext` for this instance.\n        // If this fails then it's a configuration error at the `Engine` level\n        // from when this pooling allocator was created and that needs updating\n        // if this is to succeed.\n        let offsets = self\n            .validate_instance_size(module)\n            .map_err(InstantiationError::Resource)?;\n\n        let mut memories =\n            PrimaryMap::with_capacity(module.memory_plans.len() - module.num_imported_memories);\n        let mut tables =\n            PrimaryMap::with_capacity(module.table_plans.len() - module.num_imported_tables);\n\n        // If we fail to allocate the instance's resources, deallocate\n        // what was successfully allocated and return before initializing the instance\n        if let Err(e) = self.allocate_instance_resources(\n            instance_index,\n            req.runtime_info.as_ref(),\n            req.store.as_raw(),\n            &mut memories,\n            &mut tables,\n        ) {\n            self.deallocate_memories(instance_index, &mut memories);\n            self.deallocate_tables(instance_index, &mut tables);\n            return Err(e);\n        }\n\n        let instance_ptr = self.instance(instance_index) as _;\n\n        Instance::new_at(\n            instance_ptr,\n            self.instance_size,\n            offsets,\n            req,\n            memories,\n            tables,\n        );\n\n        Ok(InstanceHandle {\n            instance: instance_ptr,\n        })\n    }\n\n    fn allocate(\n        &self,\n        req: InstanceAllocationRequest,\n    ) -> Result<InstanceHandle, InstantiationError> {\n        let index = {\n            let mut alloc = self.index_allocator.lock().unwrap();\n            if alloc.is_empty() {\n                return Err(InstantiationError::Limit(self.max_instances as u32));\n            }\n            alloc.alloc(req.runtime_info.unique_id()).index()\n        };\n\n        match unsafe { self.initialize_instance(index, req) } {\n            Ok(handle) => Ok(handle),\n            Err(e) => {\n                // If we failed to initialize the instance, there's no need to drop\n                // it as it was never \"allocated\", but we still need to free the\n                // instance's slot.\n                self.index_allocator.lock().unwrap().free(SlotId(index));\n                Err(e)\n            }\n        }\n    }\n\n    fn deallocate(&self, handle: &InstanceHandle) {\n        let addr = handle.instance as usize;\n        let base = self.mapping.as_ptr() as usize;\n\n        assert!(addr >= base && addr < base + self.mapping.len());\n        assert!((addr - base) % self.instance_size == 0);\n\n        let index = (addr - base) / self.instance_size;\n        assert!(index < self.max_instances);\n\n        let instance = unsafe { &mut *handle.instance };\n\n        // Deallocate any resources used by the instance\n        self.deallocate_memories(index, &mut instance.memories);\n        self.deallocate_tables(index, &mut instance.tables);\n\n        // We've now done all of the pooling-allocator-specific\n        // teardown, so we can drop the Instance and let destructors\n        // take care of any other fields (host state, globals, etc.).\n        unsafe {\n            std::ptr::drop_in_place(instance as *mut _);\n        }\n        // The instance is now uninitialized memory and cannot be\n        // touched again until we write a fresh Instance in-place with\n        // std::ptr::write in allocate() above.\n\n        self.index_allocator.lock().unwrap().free(SlotId(index));\n    }\n\n    fn allocate_instance_resources(\n        &self,\n        instance_index: usize,\n        runtime_info: &dyn ModuleRuntimeInfo,\n        store: Option<*mut dyn Store>,\n        memories: &mut PrimaryMap<DefinedMemoryIndex, Memory>,\n        tables: &mut PrimaryMap<DefinedTableIndex, Table>,\n    ) -> Result<(), InstantiationError> {\n        self.allocate_memories(instance_index, runtime_info, store, memories)?;\n        self.allocate_tables(instance_index, runtime_info, store, tables)?;\n\n        Ok(())\n    }\n\n    fn allocate_memories(\n        &self,\n        instance_index: usize,\n        runtime_info: &dyn ModuleRuntimeInfo,\n        store: Option<*mut dyn Store>,\n        memories: &mut PrimaryMap<DefinedMemoryIndex, Memory>,\n    ) -> Result<(), InstantiationError> {\n        let module = runtime_info.module();\n\n        self.validate_memory_plans(module)\n            .map_err(InstantiationError::Resource)?;\n\n        for (memory_index, plan) in module\n            .memory_plans\n            .iter()\n            .skip(module.num_imported_memories)\n        {\n            let defined_index = module\n                .defined_memory_index(memory_index)\n                .expect(\"should be a defined memory since we skipped imported ones\");\n\n            let memory = unsafe {\n                std::slice::from_raw_parts_mut(\n                    self.memories.get_base(instance_index, defined_index),\n                    self.memories.max_memory_size,\n                )\n            };\n\n            if let Some(image) = runtime_info\n                .memory_image(defined_index)\n                .map_err(|err| InstantiationError::Resource(err.into()))?\n            {\n                let mut slot = self\n                    .memories\n                    .take_memory_image_slot(instance_index, defined_index);\n                let initial_size = plan.memory.minimum * WASM_PAGE_SIZE as u64;\n\n                // If instantiation fails, we can propagate the error\n                // upward and drop the slot. This will cause the Drop\n                // handler to attempt to map the range with PROT_NONE\n                // memory, to reserve the space while releasing any\n                // stale mappings. The next use of this slot will then\n                // create a new slot that will try to map over\n                // this, returning errors as well if the mapping\n                // errors persist. The unmap-on-drop is best effort;\n                // if it fails, then we can still soundly continue\n                // using the rest of the pool and allowing the rest of\n                // the process to continue, because we never perform a\n                // mmap that would leave an open space for someone\n                // else to come in and map something.\n                slot.instantiate(initial_size as usize, Some(image))\n                    .map_err(|e| InstantiationError::Resource(e.into()))?;\n\n                memories.push(\n                    Memory::new_static(plan, memory, None, Some(slot), unsafe {\n                        &mut *store.unwrap()\n                    })\n                    .map_err(InstantiationError::Resource)?,\n                );\n            } else {\n                memories.push(\n                    Memory::new_static(plan, memory, Some(commit_memory_pages), None, unsafe {\n                        &mut *store.unwrap()\n                    })\n                    .map_err(InstantiationError::Resource)?,\n                );\n            }\n        }\n\n        Ok(())\n    }\n\n    fn deallocate_memories(\n        &self,\n        instance_index: usize,\n        memories: &mut PrimaryMap<DefinedMemoryIndex, Memory>,\n    ) {\n        // Decommit any linear memories that were used.\n        let memories = mem::take(memories);\n        for ((def_mem_idx, mut memory), base) in\n            memories.into_iter().zip(self.memories.get(instance_index))\n        {\n            assert!(memory.is_static());\n            let size = memory.byte_size();\n            if let Some(mut image) = memory.unwrap_static_image() {\n                // Reset the image slot. If there is any error clearing the\n                // image, just drop it here, and let the drop handler for the\n                // slot unmap in a way that retains the address space\n                // reservation.\n                if image.clear_and_remain_ready().is_ok() {\n                    self.memories\n                        .return_memory_image_slot(instance_index, def_mem_idx, image);\n                }\n            } else {\n                // Otherwise, decommit the memory pages.\n                decommit_memory_pages(base, size).expect(\"failed to decommit linear memory pages\");\n            }\n        }\n    }\n\n    fn allocate_tables(\n        &self,\n        instance_index: usize,\n        runtime_info: &dyn ModuleRuntimeInfo,\n        store: Option<*mut dyn Store>,\n        tables: &mut PrimaryMap<DefinedTableIndex, Table>,\n    ) -> Result<(), InstantiationError> {\n        let module = runtime_info.module();\n\n        self.validate_table_plans(module)\n            .map_err(InstantiationError::Resource)?;\n\n        let mut bases = self.tables.get(instance_index);\n        for (_, plan) in module.table_plans.iter().skip(module.num_imported_tables) {\n            let base = bases.next().unwrap() as _;\n\n            commit_table_pages(\n                base as *mut u8,\n                self.tables.max_elements as usize * mem::size_of::<*mut u8>(),\n            )\n            .map_err(InstantiationError::Resource)?;\n\n            tables.push(\n                Table::new_static(\n                    plan,\n                    unsafe {\n                        std::slice::from_raw_parts_mut(base, self.tables.max_elements as usize)\n                    },\n                    unsafe { &mut *store.unwrap() },\n                )\n                .map_err(InstantiationError::Resource)?,\n            );\n        }\n\n        Ok(())\n    }\n\n    fn deallocate_tables(\n        &self,\n        instance_index: usize,\n        tables: &mut PrimaryMap<DefinedTableIndex, Table>,\n    ) {\n        // Decommit any tables that were used\n        for (table, base) in tables.values_mut().zip(self.tables.get(instance_index)) {\n            let table = mem::take(table);\n            assert!(table.is_static());\n\n            let size = round_up_to_pow2(\n                table.size() as usize * mem::size_of::<*mut u8>(),\n                self.tables.page_size,\n            );\n\n            drop(table);\n            decommit_table_pages(base, size).expect(\"failed to decommit table pages\");\n        }\n    }\n\n    fn validate_table_plans(&self, module: &Module) -> Result<()> {\n        let tables = module.table_plans.len() - module.num_imported_tables;\n        if tables > self.tables.max_tables {\n            bail!(\n                \"defined tables count of {} exceeds the limit of {}\",\n                tables,\n                self.tables.max_tables,\n            );\n        }\n\n        for (i, plan) in module.table_plans.iter().skip(module.num_imported_tables) {\n            if plan.table.minimum > self.tables.max_elements {\n                bail!(\n                    \"table index {} has a minimum element size of {} which exceeds the limit of {}\",\n                    i.as_u32(),\n                    plan.table.minimum,\n                    self.tables.max_elements,\n                );\n            }\n        }\n        Ok(())\n    }\n\n    fn validate_memory_plans(&self, module: &Module) -> Result<()> {\n        let memories = module.memory_plans.len() - module.num_imported_memories;\n        if memories > self.memories.max_memories {\n            bail!(\n                \"defined memories count of {} exceeds the limit of {}\",\n                memories,\n                self.memories.max_memories,\n            );\n        }\n\n        for (i, plan) in module\n            .memory_plans\n            .iter()\n            .skip(module.num_imported_memories)\n        {\n            let max = self.memories.max_memory_size / (WASM_PAGE_SIZE as usize);\n            if plan.memory.minimum > (max as u64) {\n                bail!(\n                    \"memory index {} has a minimum page size of {} which exceeds the limit of {}\",\n                    i.as_u32(),\n                    plan.memory.minimum,\n                    max,\n                );\n            }\n        }\n        Ok(())\n    }\n\n    fn validate_instance_size(&self, module: &Module) -> Result<VMOffsets<HostPtr>> {\n        let offsets = VMOffsets::new(HostPtr, module);\n        let layout = Instance::alloc_layout(&offsets);\n        if layout.size() <= self.instance_size {\n            return Ok(offsets);\n        }\n\n        // If this `module` exceeds the allocation size allotted to it then an\n        // error will be reported here. The error of \"required N bytes but\n        // cannot allocate that\" is pretty opaque, however, because it's not\n        // clear what the breakdown of the N bytes are and what to optimize\n        // next. To help provide a better error message here some fancy-ish\n        // logic is done here to report the breakdown of the byte request into\n        // the largest portions and where it's coming from.\n        let mut message = format!(\n            \"instance allocation for this module \\\n             requires {} bytes which exceeds the configured maximum \\\n             of {} bytes; breakdown of allocation requirement:\\n\\n\",\n            layout.size(),\n            self.instance_size,\n        );\n\n        let mut remaining = layout.size();\n        let mut push = |name: &str, bytes: usize| {\n            assert!(remaining >= bytes);\n            remaining -= bytes;\n\n            // If the `name` region is more than 5% of the allocation request\n            // then report it here, otherwise ignore it. We have less than 20\n            // fields so we're guaranteed that something should be reported, and\n            // otherwise it's not particularly interesting to learn about 5\n            // different fields that are all 8 or 0 bytes. Only try to report\n            // the \"major\" sources of bytes here.\n            if bytes > layout.size() / 20 {\n                message.push_str(&format!(\n                    \" * {:.02}% - {} bytes - {}\\n\",\n                    ((bytes as f32) / (layout.size() as f32)) * 100.0,\n                    bytes,\n                    name,\n                ));\n            }\n        };\n\n        // The `Instance` itself requires some size allocated to it.\n        push(\"instance state management\", mem::size_of::<Instance>());\n\n        // Afterwards the `VMContext`'s regions are why we're requesting bytes,\n        // so ask it for descriptions on each region's byte size.\n        for (desc, size) in offsets.region_sizes() {\n            push(desc, size as usize);\n        }\n\n        // double-check we accounted for all the bytes\n        assert_eq!(remaining, 0);\n\n        bail!(\"{}\", message)\n    }\n}\n\n/// Represents a pool of WebAssembly linear memories.\n///\n/// A linear memory is divided into accessible pages and guard pages.\n///\n/// Each instance index into the pool returns an iterator over the base addresses\n/// of the instance's linear memories.\n#[derive(Debug)]\nstruct MemoryPool {\n    mapping: Mmap,\n    // If using a copy-on-write allocation scheme, the slot management. We\n    // dynamically transfer ownership of a slot to a Memory when in\n    // use.\n    image_slots: Vec<Mutex<Option<MemoryImageSlot>>>,\n    // The size, in bytes, of each linear memory's reservation plus the guard\n    // region allocated for it.\n    memory_reservation_size: usize,\n    // The maximum size, in bytes, of each linear memory. Guaranteed to be a\n    // whole number of wasm pages.\n    max_memory_size: usize,\n    // The size, in bytes, of the offset to the first linear memory in this\n    // pool. This is here to help account for the first region of guard pages,\n    // if desired, before the first linear memory.\n    initial_memory_offset: usize,\n    max_memories: usize,\n    max_instances: usize,\n}\n\nimpl MemoryPool {\n    fn new(instance_limits: &InstanceLimits, tunables: &Tunables) -> Result<Self> {\n        // The maximum module memory page count cannot exceed 65536 pages\n        if instance_limits.memory_pages > 0x10000 {\n            bail!(\n                \"module memory page limit of {} exceeds the maximum of 65536\",\n                instance_limits.memory_pages\n            );\n        }\n\n        // The maximum module memory page count cannot exceed the memory reservation size\n        if u64::from(instance_limits.memory_pages) > tunables.static_memory_bound {\n            bail!(\n                \"module memory page limit of {} pages exceeds maximum static memory limit of {} pages\",\n                instance_limits.memory_pages,\n                tunables.static_memory_bound,\n            );\n        }\n\n        let memory_size = if instance_limits.memory_pages > 0 {\n            usize::try_from(\n                u64::from(tunables.static_memory_bound) * u64::from(WASM_PAGE_SIZE)\n                    + tunables.static_memory_offset_guard_size,\n            )\n            .map_err(|_| anyhow!(\"memory reservation size exceeds addressable memory\"))?\n        } else {\n            0\n        };\n\n        assert!(\n            memory_size % crate::page_size() == 0,\n            \"memory size {} is not a multiple of system page size\",\n            memory_size\n        );\n\n        let max_instances = instance_limits.count as usize;\n        let max_memories = instance_limits.memories as usize;\n        let initial_memory_offset = if tunables.guard_before_linear_memory {\n            usize::try_from(tunables.static_memory_offset_guard_size).unwrap()\n        } else {\n            0\n        };\n\n        // The entire allocation here is the size of each memory times the\n        // max memories per instance times the number of instances allowed in\n        // this pool, plus guard regions.\n        //\n        // Note, though, that guard regions are required to be after each linear\n        // memory. If the `guard_before_linear_memory` setting is specified,\n        // then due to the contiguous layout of linear memories the guard pages\n        // after one memory are also guard pages preceding the next linear\n        // memory. This means that we only need to handle pre-guard-page sizes\n        // specially for the first linear memory, hence the\n        // `initial_memory_offset` variable here. If guards aren't specified\n        // before linear memories this is set to `0`, otherwise it's set to\n        // the same size as guard regions for other memories.\n        let allocation_size = memory_size\n            .checked_mul(max_memories)\n            .and_then(|c| c.checked_mul(max_instances))\n            .and_then(|c| c.checked_add(initial_memory_offset))\n            .ok_or_else(|| {\n                anyhow!(\"total size of memory reservation exceeds addressable memory\")\n            })?;\n\n        // Create a completely inaccessible region to start\n        let mapping = Mmap::accessible_reserved(0, allocation_size)\n            .context(\"failed to create memory pool mapping\")?;\n\n        let num_image_slots = if cfg!(memory_init_cow) {\n            max_instances * max_memories\n        } else {\n            0\n        };\n        let image_slots: Vec<_> = std::iter::repeat_with(|| Mutex::new(None))\n            .take(num_image_slots)\n            .collect();\n\n        let pool = Self {\n            mapping,\n            image_slots,\n            memory_reservation_size: memory_size,\n            initial_memory_offset,\n            max_memories,\n            max_instances,\n            max_memory_size: (instance_limits.memory_pages as usize) * (WASM_PAGE_SIZE as usize),\n        };\n\n        Ok(pool)\n    }\n\n    fn get_base(&self, instance_index: usize, memory_index: DefinedMemoryIndex) -> *mut u8 {\n        assert!(instance_index < self.max_instances);\n        let memory_index = memory_index.as_u32() as usize;\n        assert!(memory_index < self.max_memories);\n        let idx = instance_index * self.max_memories + memory_index;\n        let offset = self.initial_memory_offset + idx * self.memory_reservation_size;\n        unsafe { self.mapping.as_mut_ptr().offset(offset as isize) }\n    }\n\n    fn get<'a>(&'a self, instance_index: usize) -> impl Iterator<Item = *mut u8> + 'a {\n        (0..self.max_memories)\n            .map(move |i| self.get_base(instance_index, DefinedMemoryIndex::from_u32(i as u32)))\n    }\n\n    /// Take ownership of the given image slot. Must be returned via\n    /// `return_memory_image_slot` when the instance is done using it.\n    fn take_memory_image_slot(\n        &self,\n        instance_index: usize,\n        memory_index: DefinedMemoryIndex,\n    ) -> MemoryImageSlot {\n        let idx = instance_index * self.max_memories + (memory_index.as_u32() as usize);\n        let maybe_slot = self.image_slots[idx].lock().unwrap().take();\n\n        maybe_slot.unwrap_or_else(|| {\n            MemoryImageSlot::create(\n                self.get_base(instance_index, memory_index) as *mut c_void,\n                0,\n                self.max_memory_size,\n            )\n        })\n    }\n\n    /// Return ownership of the given image slot.\n    fn return_memory_image_slot(\n        &self,\n        instance_index: usize,\n        memory_index: DefinedMemoryIndex,\n        slot: MemoryImageSlot,\n    ) {\n        assert!(!slot.is_dirty());\n        let idx = instance_index * self.max_memories + (memory_index.as_u32() as usize);\n        *self.image_slots[idx].lock().unwrap() = Some(slot);\n    }\n}\n\nimpl Drop for MemoryPool {\n    fn drop(&mut self) {\n        // Clear the `clear_no_drop` flag (i.e., ask to *not* clear on\n        // drop) for all slots, and then drop them here. This is\n        // valid because the one `Mmap` that covers the whole region\n        // can just do its one munmap.\n        for mut slot in std::mem::take(&mut self.image_slots) {\n            if let Some(slot) = slot.get_mut().unwrap() {\n                slot.no_clear_on_drop();\n            }\n        }\n    }\n}\n\n/// Represents a pool of WebAssembly tables.\n///\n/// Each instance index into the pool returns an iterator over the base addresses\n/// of the instance's tables.\n#[derive(Debug)]\nstruct TablePool {\n    mapping: Mmap,\n    table_size: usize,\n    max_tables: usize,\n    max_instances: usize,\n    page_size: usize,\n    max_elements: u32,\n}\n\nimpl TablePool {\n    fn new(instance_limits: &InstanceLimits) -> Result<Self> {\n        let page_size = crate::page_size();\n\n        let table_size = round_up_to_pow2(\n            mem::size_of::<*mut u8>()\n                .checked_mul(instance_limits.table_elements as usize)\n                .ok_or_else(|| anyhow!(\"table size exceeds addressable memory\"))?,\n            page_size,\n        );\n\n        let max_instances = instance_limits.count as usize;\n        let max_tables = instance_limits.tables as usize;\n\n        let allocation_size = table_size\n            .checked_mul(max_tables)\n            .and_then(|c| c.checked_mul(max_instances))\n            .ok_or_else(|| anyhow!(\"total size of instance tables exceeds addressable memory\"))?;\n\n        let mapping = Mmap::accessible_reserved(allocation_size, allocation_size)\n            .context(\"failed to create table pool mapping\")?;\n\n        Ok(Self {\n            mapping,\n            table_size,\n            max_tables,\n            max_instances,\n            page_size,\n            max_elements: instance_limits.table_elements,\n        })\n    }\n\n    fn get(&self, instance_index: usize) -> impl Iterator<Item = *mut u8> {\n        assert!(instance_index < self.max_instances);\n\n        let base: *mut u8 = unsafe {\n            self.mapping\n                .as_mut_ptr()\n                .add(instance_index * self.table_size * self.max_tables) as _\n        };\n\n        let size = self.table_size;\n        (0..self.max_tables).map(move |i| unsafe { base.add(i * size) })\n    }\n}\n\n/// Represents a pool of execution stacks (used for the async fiber implementation).\n///\n/// Each index into the pool represents a single execution stack. The maximum number of\n/// stacks is the same as the maximum number of instances.\n///\n/// As stacks grow downwards, each stack starts (lowest address) with a guard page\n/// that can be used to detect stack overflow.\n///\n/// The top of the stack (starting stack pointer) is returned when a stack is allocated\n/// from the pool.\n#[cfg(all(feature = \"async\", unix))]\n#[derive(Debug)]\nstruct StackPool {\n    mapping: Mmap,\n    stack_size: usize,\n    max_instances: usize,\n    page_size: usize,\n    index_allocator: Mutex<PoolingAllocationState>,\n    async_stack_zeroing: bool,\n}\n\n#[cfg(all(feature = \"async\", unix))]\nimpl StackPool {\n    fn new(\n        instance_limits: &InstanceLimits,\n        stack_size: usize,\n        async_stack_zeroing: bool,\n    ) -> Result<Self> {\n        use rustix::mm::{mprotect, MprotectFlags};\n\n        let page_size = crate::page_size();\n\n        // Add a page to the stack size for the guard page when using fiber stacks\n        let stack_size = if stack_size == 0 {\n            0\n        } else {\n            round_up_to_pow2(stack_size, page_size)\n                .checked_add(page_size)\n                .ok_or_else(|| anyhow!(\"stack size exceeds addressable memory\"))?\n        };\n\n        let max_instances = instance_limits.count as usize;\n\n        let allocation_size = stack_size\n            .checked_mul(max_instances)\n            .ok_or_else(|| anyhow!(\"total size of execution stacks exceeds addressable memory\"))?;\n\n        let mapping = Mmap::accessible_reserved(allocation_size, allocation_size)\n            .context(\"failed to create stack pool mapping\")?;\n\n        // Set up the stack guard pages\n        if allocation_size > 0 {\n            unsafe {\n                for i in 0..max_instances {\n                    // Make the stack guard page inaccessible\n                    let bottom_of_stack = mapping.as_mut_ptr().add(i * stack_size);\n                    mprotect(bottom_of_stack.cast(), page_size, MprotectFlags::empty())\n                        .context(\"failed to protect stack guard page\")?;\n                }\n            }\n        }\n\n        Ok(Self {\n            mapping,\n            stack_size,\n            max_instances,\n            page_size,\n            async_stack_zeroing,\n            // We always use a `NextAvailable` strategy for stack\n            // allocation. We don't want or need an affinity policy\n            // here: stacks do not benefit from being allocated to the\n            // same compiled module with the same image (they always\n            // start zeroed just the same for everyone).\n            index_allocator: Mutex::new(PoolingAllocationState::new(\n                PoolingAllocationStrategy::NextAvailable,\n                max_instances,\n            )),\n        })\n    }\n\n    fn allocate(&self) -> Result<wasmtime_fiber::FiberStack, FiberStackError> {\n        if self.stack_size == 0 {\n            return Err(FiberStackError::NotSupported);\n        }\n\n        let index = {\n            let mut alloc = self.index_allocator.lock().unwrap();\n            if alloc.is_empty() {\n                return Err(FiberStackError::Limit(self.max_instances as u32));\n            }\n            alloc.alloc(None).index()\n        };\n\n        assert!(index < self.max_instances);\n\n        unsafe {\n            // Remove the guard page from the size\n            let size_without_guard = self.stack_size - self.page_size;\n\n            let bottom_of_stack = self\n                .mapping\n                .as_mut_ptr()\n                .add((index * self.stack_size) + self.page_size);\n\n            commit_stack_pages(bottom_of_stack, size_without_guard)\n                .map_err(FiberStackError::Resource)?;\n\n            wasmtime_fiber::FiberStack::from_top_ptr(bottom_of_stack.add(size_without_guard))\n                .map_err(|e| FiberStackError::Resource(e.into()))\n        }\n    }\n\n    fn deallocate(&self, stack: &wasmtime_fiber::FiberStack) {\n        let top = stack\n            .top()\n            .expect(\"fiber stack not allocated from the pool\") as usize;\n\n        let base = self.mapping.as_ptr() as usize;\n        let len = self.mapping.len();\n        assert!(\n            top > base && top <= (base + len),\n            \"fiber stack top pointer not in range\"\n        );\n\n        // Remove the guard page from the size\n        let stack_size = self.stack_size - self.page_size;\n        let bottom_of_stack = top - stack_size;\n        let start_of_stack = bottom_of_stack - self.page_size;\n        assert!(start_of_stack >= base && start_of_stack < (base + len));\n        assert!((start_of_stack - base) % self.stack_size == 0);\n\n        let index = (start_of_stack - base) / self.stack_size;\n        assert!(index < self.max_instances);\n\n        if self.async_stack_zeroing {\n            reset_stack_pages_to_zero(bottom_of_stack as _, stack_size).unwrap();\n        }\n\n        self.index_allocator.lock().unwrap().free(SlotId(index));\n    }\n}\n\n/// Implements the pooling instance allocator.\n///\n/// This allocator internally maintains pools of instances, memories, tables, and stacks.\n///\n/// Note: the resource pools are manually dropped so that the fault handler terminates correctly.\n#[derive(Debug)]\npub struct PoolingInstanceAllocator {\n    instances: InstancePool,\n    #[cfg(all(feature = \"async\", unix))]\n    stacks: StackPool,\n    #[cfg(all(feature = \"async\", windows))]\n    stack_size: usize,\n}\n\nimpl PoolingInstanceAllocator {\n    /// Creates a new pooling instance allocator with the given strategy and limits.\n    pub fn new(\n        strategy: PoolingAllocationStrategy,\n        instance_limits: InstanceLimits,\n        stack_size: usize,\n        tunables: &Tunables,\n        async_stack_zeroing: bool,\n    ) -> Result<Self> {\n        if instance_limits.count == 0 {\n            bail!(\"the instance count limit cannot be zero\");\n        }\n\n        let instances = InstancePool::new(strategy, &instance_limits, tunables)?;\n\n        drop(stack_size); // suppress unused warnings w/o async feature\n        drop(async_stack_zeroing); // suppress unused warnings w/o async feature\n\n        Ok(Self {\n            instances: instances,\n            #[cfg(all(feature = \"async\", unix))]\n            stacks: StackPool::new(&instance_limits, stack_size, async_stack_zeroing)?,\n            #[cfg(all(feature = \"async\", windows))]\n            stack_size,\n        })\n    }\n}\n\nunsafe impl InstanceAllocator for PoolingInstanceAllocator {\n    fn validate(&self, module: &Module) -> Result<()> {\n        self.instances.validate_memory_plans(module)?;\n        self.instances.validate_table_plans(module)?;\n\n        // Note that this check is not 100% accurate for cross-compiled systems\n        // where the pointer size may change since this check is often performed\n        // at compile time instead of runtime. Given that Wasmtime is almost\n        // always on a 64-bit platform though this is generally ok, and\n        // otherwise this check also happens during instantiation to\n        // double-check at that point.\n        self.instances.validate_instance_size(module)?;\n\n        Ok(())\n    }\n\n    fn adjust_tunables(&self, tunables: &mut Tunables) {\n        // Treat the static memory bound as the maximum for unbounded Wasm memories\n        // Because we guarantee a module cannot compile unless it fits in the limits of\n        // the pool allocator, this ensures all memories are treated as static (i.e. immovable).\n        tunables.static_memory_bound_is_maximum = true;\n    }\n\n    unsafe fn allocate(\n        &self,\n        req: InstanceAllocationRequest,\n    ) -> Result<InstanceHandle, InstantiationError> {\n        self.instances.allocate(req)\n    }\n\n    unsafe fn initialize(\n        &self,\n        handle: &mut InstanceHandle,\n        module: &Module,\n        is_bulk_memory: bool,\n    ) -> Result<(), InstantiationError> {\n        let instance = handle.instance_mut();\n        initialize_instance(instance, module, is_bulk_memory)\n    }\n\n    unsafe fn deallocate(&self, handle: &InstanceHandle) {\n        self.instances.deallocate(handle);\n    }\n\n    #[cfg(all(feature = \"async\", unix))]\n    fn allocate_fiber_stack(&self) -> Result<wasmtime_fiber::FiberStack, FiberStackError> {\n        self.stacks.allocate()\n    }\n\n    #[cfg(all(feature = \"async\", unix))]\n    unsafe fn deallocate_fiber_stack(&self, stack: &wasmtime_fiber::FiberStack) {\n        self.stacks.deallocate(stack);\n    }\n\n    #[cfg(all(feature = \"async\", windows))]\n    fn allocate_fiber_stack(&self) -> Result<wasmtime_fiber::FiberStack, FiberStackError> {\n        if self.stack_size == 0 {\n            return Err(FiberStackError::NotSupported);\n        }\n\n        // On windows, we don't use a stack pool as we use the native fiber implementation\n        wasmtime_fiber::FiberStack::new(self.stack_size)\n            .map_err(|e| FiberStackError::Resource(e.into()))\n    }\n\n    #[cfg(all(feature = \"async\", windows))]\n    unsafe fn deallocate_fiber_stack(&self, _stack: &wasmtime_fiber::FiberStack) {\n        // A no-op as we don't own the fiber stack on Windows\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n    use crate::{CompiledModuleId, Imports, MemoryImage, StorePtr, VMSharedSignatureIndex};\n    use std::sync::Arc;\n    use wasmtime_environ::{DefinedFuncIndex, DefinedMemoryIndex, FunctionInfo, SignatureIndex};\n\n    pub(crate) fn empty_runtime_info(\n        module: Arc<wasmtime_environ::Module>,\n    ) -> Arc<dyn ModuleRuntimeInfo> {\n        struct RuntimeInfo(Arc<wasmtime_environ::Module>);\n\n        impl ModuleRuntimeInfo for RuntimeInfo {\n            fn module(&self) -> &Arc<wasmtime_environ::Module> {\n                &self.0\n            }\n            fn image_base(&self) -> usize {\n                0\n            }\n            fn function_info(&self, _: DefinedFuncIndex) -> &FunctionInfo {\n                unimplemented!()\n            }\n            fn signature(&self, _: SignatureIndex) -> VMSharedSignatureIndex {\n                unimplemented!()\n            }\n            fn memory_image(\n                &self,\n                _: DefinedMemoryIndex,\n            ) -> anyhow::Result<Option<&Arc<MemoryImage>>> {\n                Ok(None)\n            }\n\n            fn unique_id(&self) -> Option<CompiledModuleId> {\n                None\n            }\n            fn wasm_data(&self) -> &[u8] {\n                &[]\n            }\n            fn signature_ids(&self) -> &[VMSharedSignatureIndex] {\n                &[]\n            }\n        }\n\n        Arc::new(RuntimeInfo(module))\n    }\n\n    #[cfg(target_pointer_width = \"64\")]\n    #[test]\n    fn test_instance_pool() -> Result<()> {\n        let instance_limits = InstanceLimits {\n            count: 3,\n            tables: 1,\n            memories: 1,\n            table_elements: 10,\n            size: 1000,\n            memory_pages: 1,\n            ..Default::default()\n        };\n\n        let instances = InstancePool::new(\n            PoolingAllocationStrategy::NextAvailable,\n            &instance_limits,\n            &Tunables {\n                static_memory_bound: 1,\n                ..Tunables::default()\n            },\n        )?;\n\n        assert_eq!(instances.instance_size, 1008); // round 1000 up to alignment\n        assert_eq!(instances.max_instances, 3);\n\n        assert_eq!(\n            instances.index_allocator.lock().unwrap().testing_freelist(),\n            &[SlotId(0), SlotId(1), SlotId(2)]\n        );\n\n        let mut handles = Vec::new();\n        let module = Arc::new(Module::default());\n\n        for _ in (0..3).rev() {\n            handles.push(\n                instances\n                    .allocate(InstanceAllocationRequest {\n                        runtime_info: &empty_runtime_info(module.clone()),\n                        imports: Imports {\n                            functions: &[],\n                            tables: &[],\n                            memories: &[],\n                            globals: &[],\n                        },\n                        host_state: Box::new(()),\n                        store: StorePtr::empty(),\n                    })\n                    .expect(\"allocation should succeed\"),\n            );\n        }\n\n        assert_eq!(\n            instances.index_allocator.lock().unwrap().testing_freelist(),\n            &[]\n        );\n\n        match instances.allocate(InstanceAllocationRequest {\n            runtime_info: &empty_runtime_info(module),\n            imports: Imports {\n                functions: &[],\n                tables: &[],\n                memories: &[],\n                globals: &[],\n            },\n            host_state: Box::new(()),\n            store: StorePtr::empty(),\n        }) {\n            Err(InstantiationError::Limit(3)) => {}\n            _ => panic!(\"unexpected error\"),\n        };\n\n        for handle in handles.drain(..) {\n            instances.deallocate(&handle);\n        }\n\n        assert_eq!(\n            instances.index_allocator.lock().unwrap().testing_freelist(),\n            &[SlotId(2), SlotId(1), SlotId(0)]\n        );\n\n        Ok(())\n    }\n\n    #[cfg(target_pointer_width = \"64\")]\n    #[test]\n    fn test_memory_pool() -> Result<()> {\n        let pool = MemoryPool::new(\n            &InstanceLimits {\n                count: 5,\n                tables: 0,\n                memories: 3,\n                table_elements: 0,\n                memory_pages: 1,\n                ..Default::default()\n            },\n            &Tunables {\n                static_memory_bound: 1,\n                static_memory_offset_guard_size: 0,\n                ..Tunables::default()\n            },\n        )?;\n\n        assert_eq!(pool.memory_reservation_size, WASM_PAGE_SIZE as usize);\n        assert_eq!(pool.max_memories, 3);\n        assert_eq!(pool.max_instances, 5);\n        assert_eq!(pool.max_memory_size, WASM_PAGE_SIZE as usize);\n\n        let base = pool.mapping.as_ptr() as usize;\n\n        for i in 0..5 {\n            let mut iter = pool.get(i);\n\n            for j in 0..3 {\n                assert_eq!(\n                    iter.next().unwrap() as usize - base,\n                    ((i * 3) + j) * pool.memory_reservation_size\n                );\n            }\n\n            assert_eq!(iter.next(), None);\n        }\n\n        Ok(())\n    }\n\n    #[cfg(target_pointer_width = \"64\")]\n    #[test]\n    fn test_table_pool() -> Result<()> {\n        let pool = TablePool::new(&InstanceLimits {\n            count: 7,\n            table_elements: 100,\n            memory_pages: 0,\n            tables: 4,\n            memories: 0,\n            ..Default::default()\n        })?;\n\n        let host_page_size = crate::page_size();\n\n        assert_eq!(pool.table_size, host_page_size);\n        assert_eq!(pool.max_tables, 4);\n        assert_eq!(pool.max_instances, 7);\n        assert_eq!(pool.page_size, host_page_size);\n        assert_eq!(pool.max_elements, 100);\n\n        let base = pool.mapping.as_ptr() as usize;\n\n        for i in 0..7 {\n            let mut iter = pool.get(i);\n\n            for j in 0..4 {\n                assert_eq!(\n                    iter.next().unwrap() as usize - base,\n                    ((i * 4) + j) * pool.table_size\n                );\n            }\n\n            assert_eq!(iter.next(), None);\n        }\n\n        Ok(())\n    }\n\n    #[cfg(all(unix, target_pointer_width = \"64\", feature = \"async\"))]\n    #[test]\n    fn test_stack_pool() -> Result<()> {\n        let pool = StackPool::new(\n            &InstanceLimits {\n                count: 10,\n                ..Default::default()\n            },\n            1,\n            true,\n        )?;\n\n        let native_page_size = crate::page_size();\n        assert_eq!(pool.stack_size, 2 * native_page_size);\n        assert_eq!(pool.max_instances, 10);\n        assert_eq!(pool.page_size, native_page_size);\n\n        assert_eq!(\n            pool.index_allocator.lock().unwrap().testing_freelist(),\n            &[\n                SlotId(0),\n                SlotId(1),\n                SlotId(2),\n                SlotId(3),\n                SlotId(4),\n                SlotId(5),\n                SlotId(6),\n                SlotId(7),\n                SlotId(8),\n                SlotId(9)\n            ],\n        );\n\n        let base = pool.mapping.as_ptr() as usize;\n\n        let mut stacks = Vec::new();\n        for i in (0..10).rev() {\n            let stack = pool.allocate().expect(\"allocation should succeed\");\n            assert_eq!(\n                ((stack.top().unwrap() as usize - base) / pool.stack_size) - 1,\n                i\n            );\n            stacks.push(stack);\n        }\n\n        assert_eq!(pool.index_allocator.lock().unwrap().testing_freelist(), &[]);\n\n        match pool.allocate().unwrap_err() {\n            FiberStackError::Limit(10) => {}\n            _ => panic!(\"unexpected error\"),\n        };\n\n        for stack in stacks {\n            pool.deallocate(&stack);\n        }\n\n        assert_eq!(\n            pool.index_allocator.lock().unwrap().testing_freelist(),\n            &[\n                SlotId(9),\n                SlotId(8),\n                SlotId(7),\n                SlotId(6),\n                SlotId(5),\n                SlotId(4),\n                SlotId(3),\n                SlotId(2),\n                SlotId(1),\n                SlotId(0)\n            ],\n        );\n\n        Ok(())\n    }\n\n    #[test]\n    fn test_pooling_allocator_with_zero_instance_count() {\n        assert_eq!(\n            PoolingInstanceAllocator::new(\n                PoolingAllocationStrategy::Random,\n                InstanceLimits {\n                    count: 0,\n                    ..Default::default()\n                },\n                4096,\n                &Tunables::default(),\n                true,\n            )\n            .map_err(|e| e.to_string())\n            .expect_err(\"expected a failure constructing instance allocator\"),\n            \"the instance count limit cannot be zero\"\n        );\n    }\n\n    #[test]\n    fn test_pooling_allocator_with_memory_pages_exceeded() {\n        assert_eq!(\n            PoolingInstanceAllocator::new(\n                PoolingAllocationStrategy::Random,\n                InstanceLimits {\n                    count: 1,\n                    memory_pages: 0x10001,\n                    ..Default::default()\n                },\n                4096,\n                &Tunables {\n                    static_memory_bound: 1,\n                    ..Tunables::default()\n                },\n                true,\n            )\n            .map_err(|e| e.to_string())\n            .expect_err(\"expected a failure constructing instance allocator\"),\n            \"module memory page limit of 65537 exceeds the maximum of 65536\"\n        );\n    }\n\n    #[test]\n    fn test_pooling_allocator_with_reservation_size_exceeded() {\n        assert_eq!(\n            PoolingInstanceAllocator::new(\n                PoolingAllocationStrategy::Random,\n                InstanceLimits {\n                    count: 1,\n                    memory_pages: 2,\n                    ..Default::default()\n                },\n                4096,\n                &Tunables {\n                    static_memory_bound: 1,\n                    static_memory_offset_guard_size: 0,\n                    ..Tunables::default()\n                },\n                true\n            )\n            .map_err(|e| e.to_string())\n            .expect_err(\"expected a failure constructing instance allocator\"),\n            \"module memory page limit of 2 pages exceeds maximum static memory limit of 1 pages\"\n        );\n    }\n\n    #[cfg(all(unix, target_pointer_width = \"64\", feature = \"async\"))]\n    #[test]\n    fn test_stack_zeroed() -> Result<()> {\n        let allocator = PoolingInstanceAllocator::new(\n            PoolingAllocationStrategy::NextAvailable,\n            InstanceLimits {\n                count: 1,\n                table_elements: 0,\n                memory_pages: 0,\n                tables: 0,\n                memories: 0,\n                ..Default::default()\n            },\n            128,\n            &Tunables::default(),\n            true,\n        )?;\n\n        unsafe {\n            for _ in 0..255 {\n                let stack = allocator.allocate_fiber_stack()?;\n\n                // The stack pointer is at the top, so decrement it first\n                let addr = stack.top().unwrap().sub(1);\n\n                assert_eq!(*addr, 0);\n                *addr = 1;\n\n                allocator.deallocate_fiber_stack(&stack);\n            }\n        }\n\n        Ok(())\n    }\n\n    #[cfg(all(unix, target_pointer_width = \"64\", feature = \"async\"))]\n    #[test]\n    fn test_stack_unzeroed() -> Result<()> {\n        let allocator = PoolingInstanceAllocator::new(\n            PoolingAllocationStrategy::NextAvailable,\n            InstanceLimits {\n                count: 1,\n                table_elements: 0,\n                memory_pages: 0,\n                tables: 0,\n                memories: 0,\n                ..Default::default()\n            },\n            128,\n            &Tunables::default(),\n            false,\n        )?;\n\n        unsafe {\n            for i in 0..255 {\n                let stack = allocator.allocate_fiber_stack()?;\n\n                // The stack pointer is at the top, so decrement it first\n                let addr = stack.top().unwrap().sub(1);\n\n                assert_eq!(*addr, i);\n                *addr = i + 1;\n\n                allocator.deallocate_fiber_stack(&stack);\n            }\n        }\n\n        Ok(())\n    }\n}\n", "use super::skip_pooling_allocator_tests;\nuse anyhow::Result;\nuse wasmtime::*;\n\n#[test]\nfn successful_instantiation() -> Result<()> {\n    let mut config = Config::new();\n    config.allocation_strategy(InstanceAllocationStrategy::Pooling {\n        strategy: PoolingAllocationStrategy::NextAvailable,\n        instance_limits: InstanceLimits {\n            count: 1,\n            memory_pages: 1,\n            table_elements: 10,\n            ..Default::default()\n        },\n    });\n    config.dynamic_memory_guard_size(0);\n    config.static_memory_guard_size(0);\n    config.static_memory_maximum_size(65536);\n\n    let engine = Engine::new(&config)?;\n    let module = Module::new(&engine, r#\"(module (memory 1) (table 10 funcref))\"#)?;\n\n    // Module should instantiate\n    let mut store = Store::new(&engine, ());\n    Instance::new(&mut store, &module, &[])?;\n\n    Ok(())\n}\n\n#[test]\nfn memory_limit() -> Result<()> {\n    let mut config = Config::new();\n    config.allocation_strategy(InstanceAllocationStrategy::Pooling {\n        strategy: PoolingAllocationStrategy::NextAvailable,\n        instance_limits: InstanceLimits {\n            count: 1,\n            memory_pages: 3,\n            table_elements: 10,\n            ..Default::default()\n        },\n    });\n    config.dynamic_memory_guard_size(0);\n    config.static_memory_guard_size(65536);\n    config.static_memory_maximum_size(3 * 65536);\n    config.wasm_multi_memory(true);\n\n    let engine = Engine::new(&config)?;\n\n    // Module should fail to instantiate because it has too many memories\n    match Module::new(&engine, r#\"(module (memory 1) (memory 1))\"#) {\n        Ok(_) => panic!(\"module instantiation should fail\"),\n        Err(e) => assert_eq!(\n            e.to_string(),\n            \"defined memories count of 2 exceeds the limit of 1\",\n        ),\n    }\n\n    // Module should fail to instantiate because the minimum is greater than\n    // the configured limit\n    match Module::new(&engine, r#\"(module (memory 4))\"#) {\n        Ok(_) => panic!(\"module instantiation should fail\"),\n        Err(e) => assert_eq!(\n            e.to_string(),\n            \"memory index 0 has a minimum page size of 4 which exceeds the limit of 3\",\n        ),\n    }\n\n    let module = Module::new(\n        &engine,\n        r#\"(module (memory (export \"m\") 0) (func (export \"f\") (result i32) (memory.grow (i32.const 1))))\"#,\n    )?;\n\n    // Instantiate the module and grow the memory via the `f` function\n    {\n        let mut store = Store::new(&engine, ());\n        let instance = Instance::new(&mut store, &module, &[])?;\n        let f = instance.get_typed_func::<(), i32, _>(&mut store, \"f\")?;\n\n        assert_eq!(f.call(&mut store, ()).expect(\"function should not trap\"), 0);\n        assert_eq!(f.call(&mut store, ()).expect(\"function should not trap\"), 1);\n        assert_eq!(f.call(&mut store, ()).expect(\"function should not trap\"), 2);\n        assert_eq!(\n            f.call(&mut store, ()).expect(\"function should not trap\"),\n            -1\n        );\n        assert_eq!(\n            f.call(&mut store, ()).expect(\"function should not trap\"),\n            -1\n        );\n    }\n\n    // Instantiate the module and grow the memory via the Wasmtime API\n    let mut store = Store::new(&engine, ());\n    let instance = Instance::new(&mut store, &module, &[])?;\n\n    let memory = instance.get_memory(&mut store, \"m\").unwrap();\n    assert_eq!(memory.size(&store), 0);\n    assert_eq!(memory.grow(&mut store, 1).expect(\"memory should grow\"), 0);\n    assert_eq!(memory.size(&store), 1);\n    assert_eq!(memory.grow(&mut store, 1).expect(\"memory should grow\"), 1);\n    assert_eq!(memory.size(&store), 2);\n    assert_eq!(memory.grow(&mut store, 1).expect(\"memory should grow\"), 2);\n    assert_eq!(memory.size(&store), 3);\n    assert!(memory.grow(&mut store, 1).is_err());\n\n    Ok(())\n}\n\n#[test]\nfn memory_init() -> Result<()> {\n    let mut config = Config::new();\n    config.allocation_strategy(InstanceAllocationStrategy::Pooling {\n        strategy: PoolingAllocationStrategy::NextAvailable,\n        instance_limits: InstanceLimits {\n            count: 1,\n            memory_pages: 2,\n            table_elements: 0,\n            ..Default::default()\n        },\n    });\n\n    let engine = Engine::new(&config)?;\n\n    let module = Module::new(\n        &engine,\n        r#\"(module (memory (export \"m\") 2) (data (i32.const 65530) \"this data spans multiple pages\") (data (i32.const 10) \"hello world\"))\"#,\n    )?;\n\n    let mut store = Store::new(&engine, ());\n    let instance = Instance::new(&mut store, &module, &[])?;\n    let memory = instance.get_memory(&mut store, \"m\").unwrap();\n\n    assert_eq!(\n        &memory.data(&store)[65530..65560],\n        b\"this data spans multiple pages\"\n    );\n    assert_eq!(&memory.data(&store)[10..21], b\"hello world\");\n\n    Ok(())\n}\n\n#[test]\nfn memory_guard_page_trap() -> Result<()> {\n    let mut config = Config::new();\n    config.allocation_strategy(InstanceAllocationStrategy::Pooling {\n        strategy: PoolingAllocationStrategy::NextAvailable,\n        instance_limits: InstanceLimits {\n            count: 1,\n            memory_pages: 2,\n            table_elements: 0,\n            ..Default::default()\n        },\n    });\n\n    let engine = Engine::new(&config)?;\n\n    let module = Module::new(\n        &engine,\n        r#\"(module (memory (export \"m\") 0) (func (export \"f\") (param i32) local.get 0 i32.load drop))\"#,\n    )?;\n\n    // Instantiate the module and check for out of bounds trap\n    for _ in 0..10 {\n        let mut store = Store::new(&engine, ());\n        let instance = Instance::new(&mut store, &module, &[])?;\n        let m = instance.get_memory(&mut store, \"m\").unwrap();\n        let f = instance.get_typed_func::<i32, (), _>(&mut store, \"f\")?;\n\n        let trap = f.call(&mut store, 0).expect_err(\"function should trap\");\n        assert!(trap.to_string().contains(\"out of bounds\"));\n\n        let trap = f.call(&mut store, 1).expect_err(\"function should trap\");\n        assert!(trap.to_string().contains(\"out of bounds\"));\n\n        m.grow(&mut store, 1).expect(\"memory should grow\");\n        f.call(&mut store, 0).expect(\"function should not trap\");\n\n        let trap = f.call(&mut store, 65536).expect_err(\"function should trap\");\n        assert!(trap.to_string().contains(\"out of bounds\"));\n\n        let trap = f.call(&mut store, 65537).expect_err(\"function should trap\");\n        assert!(trap.to_string().contains(\"out of bounds\"));\n\n        m.grow(&mut store, 1).expect(\"memory should grow\");\n        f.call(&mut store, 65536).expect(\"function should not trap\");\n\n        m.grow(&mut store, 1)\n            .expect_err(\"memory should be at the limit\");\n    }\n\n    Ok(())\n}\n\n#[test]\nfn memory_zeroed() -> Result<()> {\n    if skip_pooling_allocator_tests() {\n        return Ok(());\n    }\n\n    let mut config = Config::new();\n    config.allocation_strategy(InstanceAllocationStrategy::Pooling {\n        strategy: PoolingAllocationStrategy::NextAvailable,\n        instance_limits: InstanceLimits {\n            count: 1,\n            memory_pages: 1,\n            table_elements: 0,\n            ..Default::default()\n        },\n    });\n    config.dynamic_memory_guard_size(0);\n    config.static_memory_guard_size(0);\n    config.static_memory_maximum_size(65536);\n\n    let engine = Engine::new(&config)?;\n\n    let module = Module::new(&engine, r#\"(module (memory (export \"m\") 1))\"#)?;\n\n    // Instantiate the module repeatedly after writing data to the entire memory\n    for _ in 0..10 {\n        let mut store = Store::new(&engine, ());\n        let instance = Instance::new(&mut store, &module, &[])?;\n        let memory = instance.get_memory(&mut store, \"m\").unwrap();\n\n        assert_eq!(memory.size(&store,), 1);\n        assert_eq!(memory.data_size(&store), 65536);\n\n        let ptr = memory.data_mut(&mut store).as_mut_ptr();\n\n        unsafe {\n            for i in 0..8192 {\n                assert_eq!(*ptr.cast::<u64>().offset(i), 0);\n            }\n            std::ptr::write_bytes(ptr, 0xFE, memory.data_size(&store));\n        }\n    }\n\n    Ok(())\n}\n\n#[test]\nfn table_limit() -> Result<()> {\n    const TABLE_ELEMENTS: u32 = 10;\n    let mut config = Config::new();\n    config.allocation_strategy(InstanceAllocationStrategy::Pooling {\n        strategy: PoolingAllocationStrategy::NextAvailable,\n        instance_limits: InstanceLimits {\n            count: 1,\n            memory_pages: 1,\n            table_elements: TABLE_ELEMENTS,\n            ..Default::default()\n        },\n    });\n    config.dynamic_memory_guard_size(0);\n    config.static_memory_guard_size(0);\n    config.static_memory_maximum_size(65536);\n\n    let engine = Engine::new(&config)?;\n\n    // Module should fail to instantiate because it has too many tables\n    match Module::new(&engine, r#\"(module (table 1 funcref) (table 1 funcref))\"#) {\n        Ok(_) => panic!(\"module compilation should fail\"),\n        Err(e) => assert_eq!(\n            e.to_string(),\n            \"defined tables count of 2 exceeds the limit of 1\",\n        ),\n    }\n\n    // Module should fail to instantiate because the minimum is greater than\n    // the configured limit\n    match Module::new(&engine, r#\"(module (table 31 funcref))\"#) {\n        Ok(_) => panic!(\"module compilation should fail\"),\n        Err(e) => assert_eq!(\n            e.to_string(),\n            \"table index 0 has a minimum element size of 31 which exceeds the limit of 10\",\n        ),\n    }\n\n    let module = Module::new(\n        &engine,\n        r#\"(module (table (export \"t\") 0 funcref) (func (export \"f\") (result i32) (table.grow (ref.null func) (i32.const 1))))\"#,\n    )?;\n\n    // Instantiate the module and grow the table via the `f` function\n    {\n        let mut store = Store::new(&engine, ());\n        let instance = Instance::new(&mut store, &module, &[])?;\n        let f = instance.get_typed_func::<(), i32, _>(&mut store, \"f\")?;\n\n        for i in 0..TABLE_ELEMENTS {\n            assert_eq!(\n                f.call(&mut store, ()).expect(\"function should not trap\"),\n                i as i32\n            );\n        }\n\n        assert_eq!(\n            f.call(&mut store, ()).expect(\"function should not trap\"),\n            -1\n        );\n        assert_eq!(\n            f.call(&mut store, ()).expect(\"function should not trap\"),\n            -1\n        );\n    }\n\n    // Instantiate the module and grow the table via the Wasmtime API\n    let mut store = Store::new(&engine, ());\n    let instance = Instance::new(&mut store, &module, &[])?;\n\n    let table = instance.get_table(&mut store, \"t\").unwrap();\n\n    for i in 0..TABLE_ELEMENTS {\n        assert_eq!(table.size(&store), i);\n        assert_eq!(\n            table\n                .grow(&mut store, 1, Val::FuncRef(None))\n                .expect(\"table should grow\"),\n            i\n        );\n    }\n\n    assert_eq!(table.size(&store), TABLE_ELEMENTS);\n    assert!(table.grow(&mut store, 1, Val::FuncRef(None)).is_err());\n\n    Ok(())\n}\n\n#[test]\nfn table_init() -> Result<()> {\n    let mut config = Config::new();\n    config.allocation_strategy(InstanceAllocationStrategy::Pooling {\n        strategy: PoolingAllocationStrategy::NextAvailable,\n        instance_limits: InstanceLimits {\n            count: 1,\n            memory_pages: 0,\n            table_elements: 6,\n            ..Default::default()\n        },\n    });\n\n    let engine = Engine::new(&config)?;\n\n    let module = Module::new(\n        &engine,\n        r#\"(module (table (export \"t\") 6 funcref) (elem (i32.const 1) 1 2 3 4) (elem (i32.const 0) 0) (func) (func (param i32)) (func (param i32 i32)) (func (param i32 i32 i32)) (func (param i32 i32 i32 i32)))\"#,\n    )?;\n\n    let mut store = Store::new(&engine, ());\n    let instance = Instance::new(&mut store, &module, &[])?;\n    let table = instance.get_table(&mut store, \"t\").unwrap();\n\n    for i in 0..5 {\n        let v = table.get(&mut store, i).expect(\"table should have entry\");\n        let f = v\n            .funcref()\n            .expect(\"expected funcref\")\n            .expect(\"expected non-null value\");\n        assert_eq!(f.ty(&store).params().len(), i as usize);\n    }\n\n    assert!(\n        table\n            .get(&mut store, 5)\n            .expect(\"table should have entry\")\n            .funcref()\n            .expect(\"expected funcref\")\n            .is_none(),\n        \"funcref should be null\"\n    );\n\n    Ok(())\n}\n\n#[test]\nfn table_zeroed() -> Result<()> {\n    if skip_pooling_allocator_tests() {\n        return Ok(());\n    }\n\n    let mut config = Config::new();\n    config.allocation_strategy(InstanceAllocationStrategy::Pooling {\n        strategy: PoolingAllocationStrategy::NextAvailable,\n        instance_limits: InstanceLimits {\n            count: 1,\n            memory_pages: 1,\n            table_elements: 10,\n            ..Default::default()\n        },\n    });\n    config.dynamic_memory_guard_size(0);\n    config.static_memory_guard_size(0);\n    config.static_memory_maximum_size(65536);\n\n    let engine = Engine::new(&config)?;\n\n    let module = Module::new(&engine, r#\"(module (table (export \"t\") 10 funcref))\"#)?;\n\n    // Instantiate the module repeatedly after filling table elements\n    for _ in 0..10 {\n        let mut store = Store::new(&engine, ());\n        let instance = Instance::new(&mut store, &module, &[])?;\n        let table = instance.get_table(&mut store, \"t\").unwrap();\n        let f = Func::wrap(&mut store, || {});\n\n        assert_eq!(table.size(&store), 10);\n\n        for i in 0..10 {\n            match table.get(&mut store, i).unwrap() {\n                Val::FuncRef(r) => assert!(r.is_none()),\n                _ => panic!(\"expected a funcref\"),\n            }\n            table\n                .set(&mut store, i, Val::FuncRef(Some(f.clone())))\n                .unwrap();\n        }\n    }\n\n    Ok(())\n}\n\n#[test]\nfn instantiation_limit() -> Result<()> {\n    const INSTANCE_LIMIT: u32 = 10;\n    let mut config = Config::new();\n    config.allocation_strategy(InstanceAllocationStrategy::Pooling {\n        strategy: PoolingAllocationStrategy::NextAvailable,\n        instance_limits: InstanceLimits {\n            count: INSTANCE_LIMIT,\n            memory_pages: 1,\n            table_elements: 10,\n            ..Default::default()\n        },\n    });\n    config.dynamic_memory_guard_size(0);\n    config.static_memory_guard_size(0);\n    config.static_memory_maximum_size(65536);\n\n    let engine = Engine::new(&config)?;\n    let module = Module::new(&engine, r#\"(module)\"#)?;\n\n    // Instantiate to the limit\n    {\n        let mut store = Store::new(&engine, ());\n\n        for _ in 0..INSTANCE_LIMIT {\n            Instance::new(&mut store, &module, &[])?;\n        }\n\n        match Instance::new(&mut store, &module, &[]) {\n            Ok(_) => panic!(\"instantiation should fail\"),\n            Err(e) => assert_eq!(\n                e.to_string(),\n                format!(\n                    \"Limit of {} concurrent instances has been reached\",\n                    INSTANCE_LIMIT\n                )\n            ),\n        }\n    }\n\n    // With the above store dropped, ensure instantiations can be made\n\n    let mut store = Store::new(&engine, ());\n\n    for _ in 0..INSTANCE_LIMIT {\n        Instance::new(&mut store, &module, &[])?;\n    }\n\n    Ok(())\n}\n\n#[test]\nfn preserve_data_segments() -> Result<()> {\n    let mut config = Config::new();\n    config.allocation_strategy(InstanceAllocationStrategy::Pooling {\n        strategy: PoolingAllocationStrategy::NextAvailable,\n        instance_limits: InstanceLimits {\n            count: 2,\n            memory_pages: 1,\n            table_elements: 10,\n            ..Default::default()\n        },\n    });\n    let engine = Engine::new(&config)?;\n    let m = Module::new(\n        &engine,\n        r#\"\n            (module\n                (memory (export \"mem\") 1 1)\n                (data (i32.const 0) \"foo\"))\n        \"#,\n    )?;\n    let mut store = Store::new(&engine, ());\n    let i = Instance::new(&mut store, &m, &[])?;\n\n    // Drop the module. This should *not* drop the actual data referenced by the\n    // module.\n    drop(m);\n\n    // Spray some stuff on the heap. If wasm data lived on the heap this should\n    // paper over things and help us catch use-after-free here if it would\n    // otherwise happen.\n    let mut strings = Vec::new();\n    for _ in 0..1000 {\n        let mut string = String::new();\n        for _ in 0..1000 {\n            string.push('g');\n        }\n        strings.push(string);\n    }\n    drop(strings);\n\n    let mem = i.get_memory(&mut store, \"mem\").unwrap();\n\n    // Hopefully it's still `foo`!\n    assert!(mem.data(&store).starts_with(b\"foo\"));\n\n    Ok(())\n}\n\n#[test]\nfn multi_memory_with_imported_memories() -> Result<()> {\n    // This test checks that the base address for the defined memory is correct for the instance\n    // despite the presence of an imported memory.\n\n    let mut config = Config::new();\n    config.allocation_strategy(InstanceAllocationStrategy::Pooling {\n        strategy: PoolingAllocationStrategy::NextAvailable,\n        instance_limits: InstanceLimits {\n            count: 1,\n            memories: 2,\n            memory_pages: 1,\n            ..Default::default()\n        },\n    });\n    config.wasm_multi_memory(true);\n\n    let engine = Engine::new(&config)?;\n    let module = Module::new(\n        &engine,\n        r#\"(module (import \"\" \"m1\" (memory 0)) (memory (export \"m2\") 1))\"#,\n    )?;\n\n    let mut store = Store::new(&engine, ());\n\n    let m1 = Memory::new(&mut store, MemoryType::new(0, None))?;\n    let instance = Instance::new(&mut store, &module, &[m1.into()])?;\n\n    let m2 = instance.get_memory(&mut store, \"m2\").unwrap();\n\n    m2.data_mut(&mut store)[0] = 0x42;\n    assert_eq!(m2.data(&store)[0], 0x42);\n\n    Ok(())\n}\n\n#[test]\nfn drop_externref_global_during_module_init() -> Result<()> {\n    struct Limiter;\n\n    impl ResourceLimiter for Limiter {\n        fn memory_growing(&mut self, _: usize, _: usize, _: Option<usize>) -> bool {\n            false\n        }\n\n        fn table_growing(&mut self, _: u32, _: u32, _: Option<u32>) -> bool {\n            false\n        }\n    }\n\n    let mut config = Config::new();\n    config.wasm_reference_types(true);\n    config.allocation_strategy(InstanceAllocationStrategy::Pooling {\n        strategy: PoolingAllocationStrategy::NextAvailable,\n        instance_limits: InstanceLimits {\n            count: 1,\n            ..Default::default()\n        },\n    });\n\n    let engine = Engine::new(&config)?;\n\n    let module = Module::new(\n        &engine,\n        r#\"\n            (module\n                (global i32 (i32.const 1))\n                (global i32 (i32.const 2))\n                (global i32 (i32.const 3))\n                (global i32 (i32.const 4))\n                (global i32 (i32.const 5))\n            )\n        \"#,\n    )?;\n\n    let mut store = Store::new(&engine, Limiter);\n    drop(Instance::new(&mut store, &module, &[])?);\n    drop(store);\n\n    let module = Module::new(\n        &engine,\n        r#\"\n            (module\n                (memory 1)\n                (global (mut externref) (ref.null extern))\n            )\n        \"#,\n    )?;\n\n    let mut store = Store::new(&engine, Limiter);\n    store.limiter(|s| s);\n    assert!(Instance::new(&mut store, &module, &[]).is_err());\n\n    Ok(())\n}\n\n#[test]\n#[cfg(target_pointer_width = \"64\")]\nfn instance_too_large() -> Result<()> {\n    let mut config = Config::new();\n    config.allocation_strategy(InstanceAllocationStrategy::Pooling {\n        strategy: PoolingAllocationStrategy::NextAvailable,\n        instance_limits: InstanceLimits {\n            size: 16,\n            count: 1,\n            ..Default::default()\n        },\n    });\n\n    let engine = Engine::new(&config)?;\n    let expected = \"\\\ninstance allocation for this module requires 336 bytes which exceeds the \\\nconfigured maximum of 16 bytes; breakdown of allocation requirement:\n\n * 76.19% - 256 bytes - instance state management\n\";\n    match Module::new(&engine, \"(module)\") {\n        Ok(_) => panic!(\"should have failed to compile\"),\n        Err(e) => assert_eq!(e.to_string(), expected),\n    }\n\n    let mut lots_of_globals = format!(\"(module\");\n    for _ in 0..100 {\n        lots_of_globals.push_str(\"(global i32 i32.const 0)\\n\");\n    }\n    lots_of_globals.push_str(\")\");\n\n    let expected = \"\\\ninstance allocation for this module requires 1936 bytes which exceeds the \\\nconfigured maximum of 16 bytes; breakdown of allocation requirement:\n\n * 13.22% - 256 bytes - instance state management\n * 82.64% - 1600 bytes - defined globals\n\";\n    match Module::new(&engine, &lots_of_globals) {\n        Ok(_) => panic!(\"should have failed to compile\"),\n        Err(e) => assert_eq!(e.to_string(), expected),\n    }\n\n    Ok(())\n}\n"], "fixing_code": ["//! Implements the pooling instance allocator.\n//!\n//! The pooling instance allocator maps memory in advance\n//! and allocates instances, memories, tables, and stacks from\n//! a pool of available resources.\n//!\n//! Using the pooling instance allocator can speed up module instantiation\n//! when modules can be constrained based on configurable limits.\n\nuse super::{\n    initialize_instance, InstanceAllocationRequest, InstanceAllocator, InstanceHandle,\n    InstantiationError,\n};\nuse crate::{instance::Instance, Memory, Mmap, Table};\nuse crate::{MemoryImageSlot, ModuleRuntimeInfo, Store};\nuse anyhow::{anyhow, bail, Context, Result};\nuse libc::c_void;\nuse std::convert::TryFrom;\nuse std::mem;\nuse std::sync::Mutex;\nuse wasmtime_environ::{\n    DefinedMemoryIndex, DefinedTableIndex, HostPtr, Module, PrimaryMap, Tunables, VMOffsets,\n    WASM_PAGE_SIZE,\n};\n\nmod index_allocator;\nuse index_allocator::{PoolingAllocationState, SlotId};\n\ncfg_if::cfg_if! {\n    if #[cfg(windows)] {\n        mod windows;\n        use windows as imp;\n    } else {\n        mod unix;\n        use unix as imp;\n    }\n}\n\nuse imp::{commit_memory_pages, commit_table_pages, decommit_memory_pages, decommit_table_pages};\n\n#[cfg(all(feature = \"async\", unix))]\nuse imp::{commit_stack_pages, reset_stack_pages_to_zero};\n\n#[cfg(feature = \"async\")]\nuse super::FiberStackError;\n\nfn round_up_to_pow2(n: usize, to: usize) -> usize {\n    debug_assert!(to > 0);\n    debug_assert!(to.is_power_of_two());\n    (n + to - 1) & !(to - 1)\n}\n\n/// Represents the limits placed on instances by the pooling instance allocator.\n#[derive(Debug, Copy, Clone)]\npub struct InstanceLimits {\n    /// The maximum number of concurrent instances supported (default is 1000).\n    ///\n    /// This value has a direct impact on the amount of memory allocated by the pooling\n    /// instance allocator.\n    ///\n    /// The pooling instance allocator allocates three memory pools with sizes depending on this value:\n    ///\n    /// * An instance pool, where each entry in the pool can store the runtime representation\n    ///   of an instance, including a maximal `VMContext` structure.\n    ///\n    /// * A memory pool, where each entry in the pool contains the reserved address space for each\n    ///   linear memory supported by an instance.\n    ///\n    /// * A table pool, where each entry in the pool contains the space needed for each WebAssembly table\n    ///   supported by an instance (see `table_elements` to control the size of each table).\n    ///\n    /// Additionally, this value will also control the maximum number of execution stacks allowed for\n    /// asynchronous execution (one per instance), when enabled.\n    ///\n    /// The memory pool will reserve a large quantity of host process address space to elide the bounds\n    /// checks required for correct WebAssembly memory semantics. Even for 64-bit address spaces, the\n    /// address space is limited when dealing with a large number of supported instances.\n    ///\n    /// For example, on Linux x86_64, the userland address space limit is 128 TiB. That might seem like a lot,\n    /// but each linear memory will *reserve* 6 GiB of space by default. Multiply that by the number of linear\n    /// memories each instance supports and then by the number of supported instances and it becomes apparent\n    /// that address space can be exhausted depending on the number of supported instances.\n    pub count: u32,\n\n    /// The maximum size, in bytes, allocated for an instance and its\n    /// `VMContext`.\n    ///\n    /// This amount of space is pre-allocated for `count` number of instances\n    /// and is used to store the runtime `wasmtime_runtime::Instance` structure\n    /// along with its adjacent `VMContext` structure. The `Instance` type has a\n    /// static size but `VMContext` is dynamically sized depending on the module\n    /// being instantiated. This size limit loosely correlates to the size of\n    /// the wasm module, taking into account factors such as:\n    ///\n    /// * number of functions\n    /// * number of globals\n    /// * number of memories\n    /// * number of tables\n    /// * number of function types\n    ///\n    /// If the allocated size per instance is too small then instantiation of a\n    /// module will fail at runtime with an error indicating how many bytes were\n    /// needed. This amount of bytes are committed to memory per-instance when\n    /// a pooling allocator is created.\n    ///\n    /// The default value for this is 1MB.\n    pub size: usize,\n\n    /// The maximum number of defined tables for a module (default is 1).\n    ///\n    /// This value controls the capacity of the `VMTableDefinition` table in each instance's\n    /// `VMContext` structure.\n    ///\n    /// The allocated size of the table will be `tables * sizeof(VMTableDefinition)` for each\n    /// instance regardless of how many tables are defined by an instance's module.\n    pub tables: u32,\n\n    /// The maximum table elements for any table defined in a module (default is 10000).\n    ///\n    /// If a table's minimum element limit is greater than this value, the module will\n    /// fail to instantiate.\n    ///\n    /// If a table's maximum element limit is unbounded or greater than this value,\n    /// the maximum will be `table_elements` for the purpose of any `table.grow` instruction.\n    ///\n    /// This value is used to reserve the maximum space for each supported table; table elements\n    /// are pointer-sized in the Wasmtime runtime.  Therefore, the space reserved for each instance\n    /// is `tables * table_elements * sizeof::<*const ()>`.\n    pub table_elements: u32,\n\n    /// The maximum number of defined linear memories for a module (default is 1).\n    ///\n    /// This value controls the capacity of the `VMMemoryDefinition` table in each instance's\n    /// `VMContext` structure.\n    ///\n    /// The allocated size of the table will be `memories * sizeof(VMMemoryDefinition)` for each\n    /// instance regardless of how many memories are defined by an instance's module.\n    pub memories: u32,\n\n    /// The maximum number of pages for any linear memory defined in a module (default is 160).\n    ///\n    /// The default of 160 means at most 10 MiB of host memory may be committed for each instance.\n    ///\n    /// If a memory's minimum page limit is greater than this value, the module will\n    /// fail to instantiate.\n    ///\n    /// If a memory's maximum page limit is unbounded or greater than this value,\n    /// the maximum will be `memory_pages` for the purpose of any `memory.grow` instruction.\n    ///\n    /// This value is used to control the maximum accessible space for each linear memory of an instance.\n    ///\n    /// The reservation size of each linear memory is controlled by the\n    /// `static_memory_maximum_size` setting and this value cannot\n    /// exceed the configured static memory maximum size.\n    pub memory_pages: u64,\n}\n\nimpl Default for InstanceLimits {\n    fn default() -> Self {\n        // See doc comments for `wasmtime::InstanceLimits` for these default values\n        Self {\n            count: 1000,\n            size: 1 << 20, // 1 MB\n            tables: 1,\n            table_elements: 10_000,\n            memories: 1,\n            memory_pages: 160,\n        }\n    }\n}\n\n/// The allocation strategy to use for the pooling instance allocator.\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum PoolingAllocationStrategy {\n    /// Allocate from the next available instance.\n    NextAvailable,\n    /// Allocate from a random available instance.\n    Random,\n    /// Try to allocate an instance slot that was previously used for\n    /// the same module, potentially enabling faster instantiation by\n    /// reusing e.g. memory mappings.\n    ReuseAffinity,\n}\n\nimpl Default for PoolingAllocationStrategy {\n    fn default() -> Self {\n        if cfg!(memory_init_cow) {\n            Self::ReuseAffinity\n        } else {\n            Self::NextAvailable\n        }\n    }\n}\n\n/// Represents a pool of maximal `Instance` structures.\n///\n/// Each index in the pool provides enough space for a maximal `Instance`\n/// structure depending on the limits used to create the pool.\n///\n/// The pool maintains a free list for fast instance allocation.\n#[derive(Debug)]\nstruct InstancePool {\n    mapping: Mmap,\n    instance_size: usize,\n    max_instances: usize,\n    index_allocator: Mutex<PoolingAllocationState>,\n    memories: MemoryPool,\n    tables: TablePool,\n}\n\nimpl InstancePool {\n    fn new(\n        strategy: PoolingAllocationStrategy,\n        instance_limits: &InstanceLimits,\n        tunables: &Tunables,\n    ) -> Result<Self> {\n        let page_size = crate::page_size();\n\n        let instance_size = round_up_to_pow2(instance_limits.size, mem::align_of::<Instance>());\n\n        let max_instances = instance_limits.count as usize;\n\n        let allocation_size = round_up_to_pow2(\n            instance_size\n                .checked_mul(max_instances)\n                .ok_or_else(|| anyhow!(\"total size of instance data exceeds addressable memory\"))?,\n            page_size,\n        );\n\n        let mapping = Mmap::accessible_reserved(allocation_size, allocation_size)\n            .context(\"failed to create instance pool mapping\")?;\n\n        let pool = Self {\n            mapping,\n            instance_size,\n            max_instances,\n            index_allocator: Mutex::new(PoolingAllocationState::new(strategy, max_instances)),\n            memories: MemoryPool::new(instance_limits, tunables)?,\n            tables: TablePool::new(instance_limits)?,\n        };\n\n        Ok(pool)\n    }\n\n    unsafe fn instance(&self, index: usize) -> &mut Instance {\n        assert!(index < self.max_instances);\n        &mut *(self.mapping.as_mut_ptr().add(index * self.instance_size) as *mut Instance)\n    }\n\n    unsafe fn initialize_instance(\n        &self,\n        instance_index: usize,\n        req: InstanceAllocationRequest,\n    ) -> Result<InstanceHandle, InstantiationError> {\n        let module = req.runtime_info.module();\n\n        // Before doing anything else ensure that our instance slot is actually\n        // big enough to hold the `Instance` and `VMContext` for this instance.\n        // If this fails then it's a configuration error at the `Engine` level\n        // from when this pooling allocator was created and that needs updating\n        // if this is to succeed.\n        let offsets = self\n            .validate_instance_size(module)\n            .map_err(InstantiationError::Resource)?;\n\n        let mut memories =\n            PrimaryMap::with_capacity(module.memory_plans.len() - module.num_imported_memories);\n        let mut tables =\n            PrimaryMap::with_capacity(module.table_plans.len() - module.num_imported_tables);\n\n        // If we fail to allocate the instance's resources, deallocate\n        // what was successfully allocated and return before initializing the instance\n        if let Err(e) = self.allocate_instance_resources(\n            instance_index,\n            req.runtime_info.as_ref(),\n            req.store.as_raw(),\n            &mut memories,\n            &mut tables,\n        ) {\n            self.deallocate_memories(instance_index, &mut memories);\n            self.deallocate_tables(instance_index, &mut tables);\n            return Err(e);\n        }\n\n        let instance_ptr = self.instance(instance_index) as _;\n\n        Instance::new_at(\n            instance_ptr,\n            self.instance_size,\n            offsets,\n            req,\n            memories,\n            tables,\n        );\n\n        Ok(InstanceHandle {\n            instance: instance_ptr,\n        })\n    }\n\n    fn allocate(\n        &self,\n        req: InstanceAllocationRequest,\n    ) -> Result<InstanceHandle, InstantiationError> {\n        let index = {\n            let mut alloc = self.index_allocator.lock().unwrap();\n            if alloc.is_empty() {\n                return Err(InstantiationError::Limit(self.max_instances as u32));\n            }\n            alloc.alloc(req.runtime_info.unique_id()).index()\n        };\n\n        match unsafe { self.initialize_instance(index, req) } {\n            Ok(handle) => Ok(handle),\n            Err(e) => {\n                // If we failed to initialize the instance, there's no need to drop\n                // it as it was never \"allocated\", but we still need to free the\n                // instance's slot.\n                self.index_allocator.lock().unwrap().free(SlotId(index));\n                Err(e)\n            }\n        }\n    }\n\n    fn deallocate(&self, handle: &InstanceHandle) {\n        let addr = handle.instance as usize;\n        let base = self.mapping.as_ptr() as usize;\n\n        assert!(addr >= base && addr < base + self.mapping.len());\n        assert!((addr - base) % self.instance_size == 0);\n\n        let index = (addr - base) / self.instance_size;\n        assert!(index < self.max_instances);\n\n        let instance = unsafe { &mut *handle.instance };\n\n        // Deallocate any resources used by the instance\n        self.deallocate_memories(index, &mut instance.memories);\n        self.deallocate_tables(index, &mut instance.tables);\n\n        // We've now done all of the pooling-allocator-specific\n        // teardown, so we can drop the Instance and let destructors\n        // take care of any other fields (host state, globals, etc.).\n        unsafe {\n            std::ptr::drop_in_place(instance as *mut _);\n        }\n        // The instance is now uninitialized memory and cannot be\n        // touched again until we write a fresh Instance in-place with\n        // std::ptr::write in allocate() above.\n\n        self.index_allocator.lock().unwrap().free(SlotId(index));\n    }\n\n    fn allocate_instance_resources(\n        &self,\n        instance_index: usize,\n        runtime_info: &dyn ModuleRuntimeInfo,\n        store: Option<*mut dyn Store>,\n        memories: &mut PrimaryMap<DefinedMemoryIndex, Memory>,\n        tables: &mut PrimaryMap<DefinedTableIndex, Table>,\n    ) -> Result<(), InstantiationError> {\n        self.allocate_memories(instance_index, runtime_info, store, memories)?;\n        self.allocate_tables(instance_index, runtime_info, store, tables)?;\n\n        Ok(())\n    }\n\n    fn allocate_memories(\n        &self,\n        instance_index: usize,\n        runtime_info: &dyn ModuleRuntimeInfo,\n        store: Option<*mut dyn Store>,\n        memories: &mut PrimaryMap<DefinedMemoryIndex, Memory>,\n    ) -> Result<(), InstantiationError> {\n        let module = runtime_info.module();\n\n        self.validate_memory_plans(module)\n            .map_err(InstantiationError::Resource)?;\n\n        for (memory_index, plan) in module\n            .memory_plans\n            .iter()\n            .skip(module.num_imported_memories)\n        {\n            let defined_index = module\n                .defined_memory_index(memory_index)\n                .expect(\"should be a defined memory since we skipped imported ones\");\n\n            let memory = unsafe {\n                std::slice::from_raw_parts_mut(\n                    self.memories.get_base(instance_index, defined_index),\n                    self.memories.max_memory_size,\n                )\n            };\n\n            let mut slot = self\n                .memories\n                .take_memory_image_slot(instance_index, defined_index);\n            if let Some(image) = runtime_info\n                .memory_image(defined_index)\n                .map_err(|err| InstantiationError::Resource(err.into()))?\n            {\n                let initial_size = plan.memory.minimum * WASM_PAGE_SIZE as u64;\n\n                // If instantiation fails, we can propagate the error\n                // upward and drop the slot. This will cause the Drop\n                // handler to attempt to map the range with PROT_NONE\n                // memory, to reserve the space while releasing any\n                // stale mappings. The next use of this slot will then\n                // create a new slot that will try to map over\n                // this, returning errors as well if the mapping\n                // errors persist. The unmap-on-drop is best effort;\n                // if it fails, then we can still soundly continue\n                // using the rest of the pool and allowing the rest of\n                // the process to continue, because we never perform a\n                // mmap that would leave an open space for someone\n                // else to come in and map something.\n                slot.instantiate(initial_size as usize, Some(image))\n                    .map_err(|e| InstantiationError::Resource(e.into()))?;\n\n                memories.push(\n                    Memory::new_static(plan, memory, None, Some(slot), unsafe {\n                        &mut *store.unwrap()\n                    })\n                    .map_err(InstantiationError::Resource)?,\n                );\n            } else {\n                drop(slot);\n                memories.push(\n                    Memory::new_static(plan, memory, Some(commit_memory_pages), None, unsafe {\n                        &mut *store.unwrap()\n                    })\n                    .map_err(InstantiationError::Resource)?,\n                );\n            }\n        }\n\n        Ok(())\n    }\n\n    fn deallocate_memories(\n        &self,\n        instance_index: usize,\n        memories: &mut PrimaryMap<DefinedMemoryIndex, Memory>,\n    ) {\n        // Decommit any linear memories that were used.\n        let memories = mem::take(memories);\n        for ((def_mem_idx, mut memory), base) in\n            memories.into_iter().zip(self.memories.get(instance_index))\n        {\n            assert!(memory.is_static());\n            let size = memory.byte_size();\n            if let Some(mut image) = memory.unwrap_static_image() {\n                // Reset the image slot. If there is any error clearing the\n                // image, just drop it here, and let the drop handler for the\n                // slot unmap in a way that retains the address space\n                // reservation.\n                if image.clear_and_remain_ready().is_ok() {\n                    self.memories\n                        .return_memory_image_slot(instance_index, def_mem_idx, image);\n                }\n            } else {\n                // Otherwise, decommit the memory pages.\n                decommit_memory_pages(base, size).expect(\"failed to decommit linear memory pages\");\n            }\n        }\n    }\n\n    fn allocate_tables(\n        &self,\n        instance_index: usize,\n        runtime_info: &dyn ModuleRuntimeInfo,\n        store: Option<*mut dyn Store>,\n        tables: &mut PrimaryMap<DefinedTableIndex, Table>,\n    ) -> Result<(), InstantiationError> {\n        let module = runtime_info.module();\n\n        self.validate_table_plans(module)\n            .map_err(InstantiationError::Resource)?;\n\n        let mut bases = self.tables.get(instance_index);\n        for (_, plan) in module.table_plans.iter().skip(module.num_imported_tables) {\n            let base = bases.next().unwrap() as _;\n\n            commit_table_pages(\n                base as *mut u8,\n                self.tables.max_elements as usize * mem::size_of::<*mut u8>(),\n            )\n            .map_err(InstantiationError::Resource)?;\n\n            tables.push(\n                Table::new_static(\n                    plan,\n                    unsafe {\n                        std::slice::from_raw_parts_mut(base, self.tables.max_elements as usize)\n                    },\n                    unsafe { &mut *store.unwrap() },\n                )\n                .map_err(InstantiationError::Resource)?,\n            );\n        }\n\n        Ok(())\n    }\n\n    fn deallocate_tables(\n        &self,\n        instance_index: usize,\n        tables: &mut PrimaryMap<DefinedTableIndex, Table>,\n    ) {\n        // Decommit any tables that were used\n        for (table, base) in tables.values_mut().zip(self.tables.get(instance_index)) {\n            let table = mem::take(table);\n            assert!(table.is_static());\n\n            let size = round_up_to_pow2(\n                table.size() as usize * mem::size_of::<*mut u8>(),\n                self.tables.page_size,\n            );\n\n            drop(table);\n            decommit_table_pages(base, size).expect(\"failed to decommit table pages\");\n        }\n    }\n\n    fn validate_table_plans(&self, module: &Module) -> Result<()> {\n        let tables = module.table_plans.len() - module.num_imported_tables;\n        if tables > self.tables.max_tables {\n            bail!(\n                \"defined tables count of {} exceeds the limit of {}\",\n                tables,\n                self.tables.max_tables,\n            );\n        }\n\n        for (i, plan) in module.table_plans.iter().skip(module.num_imported_tables) {\n            if plan.table.minimum > self.tables.max_elements {\n                bail!(\n                    \"table index {} has a minimum element size of {} which exceeds the limit of {}\",\n                    i.as_u32(),\n                    plan.table.minimum,\n                    self.tables.max_elements,\n                );\n            }\n        }\n        Ok(())\n    }\n\n    fn validate_memory_plans(&self, module: &Module) -> Result<()> {\n        let memories = module.memory_plans.len() - module.num_imported_memories;\n        if memories > self.memories.max_memories {\n            bail!(\n                \"defined memories count of {} exceeds the limit of {}\",\n                memories,\n                self.memories.max_memories,\n            );\n        }\n\n        for (i, plan) in module\n            .memory_plans\n            .iter()\n            .skip(module.num_imported_memories)\n        {\n            let max = self.memories.max_memory_size / (WASM_PAGE_SIZE as usize);\n            if plan.memory.minimum > (max as u64) {\n                bail!(\n                    \"memory index {} has a minimum page size of {} which exceeds the limit of {}\",\n                    i.as_u32(),\n                    plan.memory.minimum,\n                    max,\n                );\n            }\n        }\n        Ok(())\n    }\n\n    fn validate_instance_size(&self, module: &Module) -> Result<VMOffsets<HostPtr>> {\n        let offsets = VMOffsets::new(HostPtr, module);\n        let layout = Instance::alloc_layout(&offsets);\n        if layout.size() <= self.instance_size {\n            return Ok(offsets);\n        }\n\n        // If this `module` exceeds the allocation size allotted to it then an\n        // error will be reported here. The error of \"required N bytes but\n        // cannot allocate that\" is pretty opaque, however, because it's not\n        // clear what the breakdown of the N bytes are and what to optimize\n        // next. To help provide a better error message here some fancy-ish\n        // logic is done here to report the breakdown of the byte request into\n        // the largest portions and where it's coming from.\n        let mut message = format!(\n            \"instance allocation for this module \\\n             requires {} bytes which exceeds the configured maximum \\\n             of {} bytes; breakdown of allocation requirement:\\n\\n\",\n            layout.size(),\n            self.instance_size,\n        );\n\n        let mut remaining = layout.size();\n        let mut push = |name: &str, bytes: usize| {\n            assert!(remaining >= bytes);\n            remaining -= bytes;\n\n            // If the `name` region is more than 5% of the allocation request\n            // then report it here, otherwise ignore it. We have less than 20\n            // fields so we're guaranteed that something should be reported, and\n            // otherwise it's not particularly interesting to learn about 5\n            // different fields that are all 8 or 0 bytes. Only try to report\n            // the \"major\" sources of bytes here.\n            if bytes > layout.size() / 20 {\n                message.push_str(&format!(\n                    \" * {:.02}% - {} bytes - {}\\n\",\n                    ((bytes as f32) / (layout.size() as f32)) * 100.0,\n                    bytes,\n                    name,\n                ));\n            }\n        };\n\n        // The `Instance` itself requires some size allocated to it.\n        push(\"instance state management\", mem::size_of::<Instance>());\n\n        // Afterwards the `VMContext`'s regions are why we're requesting bytes,\n        // so ask it for descriptions on each region's byte size.\n        for (desc, size) in offsets.region_sizes() {\n            push(desc, size as usize);\n        }\n\n        // double-check we accounted for all the bytes\n        assert_eq!(remaining, 0);\n\n        bail!(\"{}\", message)\n    }\n}\n\n/// Represents a pool of WebAssembly linear memories.\n///\n/// A linear memory is divided into accessible pages and guard pages.\n///\n/// Each instance index into the pool returns an iterator over the base addresses\n/// of the instance's linear memories.\n#[derive(Debug)]\nstruct MemoryPool {\n    mapping: Mmap,\n    // If using a copy-on-write allocation scheme, the slot management. We\n    // dynamically transfer ownership of a slot to a Memory when in\n    // use.\n    image_slots: Vec<Mutex<Option<MemoryImageSlot>>>,\n    // The size, in bytes, of each linear memory's reservation plus the guard\n    // region allocated for it.\n    memory_reservation_size: usize,\n    // The maximum size, in bytes, of each linear memory. Guaranteed to be a\n    // whole number of wasm pages.\n    max_memory_size: usize,\n    // The size, in bytes, of the offset to the first linear memory in this\n    // pool. This is here to help account for the first region of guard pages,\n    // if desired, before the first linear memory.\n    initial_memory_offset: usize,\n    max_memories: usize,\n    max_instances: usize,\n}\n\nimpl MemoryPool {\n    fn new(instance_limits: &InstanceLimits, tunables: &Tunables) -> Result<Self> {\n        // The maximum module memory page count cannot exceed 65536 pages\n        if instance_limits.memory_pages > 0x10000 {\n            bail!(\n                \"module memory page limit of {} exceeds the maximum of 65536\",\n                instance_limits.memory_pages\n            );\n        }\n\n        // The maximum module memory page count cannot exceed the memory reservation size\n        if u64::from(instance_limits.memory_pages) > tunables.static_memory_bound {\n            bail!(\n                \"module memory page limit of {} pages exceeds maximum static memory limit of {} pages\",\n                instance_limits.memory_pages,\n                tunables.static_memory_bound,\n            );\n        }\n\n        let memory_size = if instance_limits.memory_pages > 0 {\n            usize::try_from(\n                u64::from(tunables.static_memory_bound) * u64::from(WASM_PAGE_SIZE)\n                    + tunables.static_memory_offset_guard_size,\n            )\n            .map_err(|_| anyhow!(\"memory reservation size exceeds addressable memory\"))?\n        } else {\n            0\n        };\n\n        assert!(\n            memory_size % crate::page_size() == 0,\n            \"memory size {} is not a multiple of system page size\",\n            memory_size\n        );\n\n        let max_instances = instance_limits.count as usize;\n        let max_memories = instance_limits.memories as usize;\n        let initial_memory_offset = if tunables.guard_before_linear_memory {\n            usize::try_from(tunables.static_memory_offset_guard_size).unwrap()\n        } else {\n            0\n        };\n\n        // The entire allocation here is the size of each memory times the\n        // max memories per instance times the number of instances allowed in\n        // this pool, plus guard regions.\n        //\n        // Note, though, that guard regions are required to be after each linear\n        // memory. If the `guard_before_linear_memory` setting is specified,\n        // then due to the contiguous layout of linear memories the guard pages\n        // after one memory are also guard pages preceding the next linear\n        // memory. This means that we only need to handle pre-guard-page sizes\n        // specially for the first linear memory, hence the\n        // `initial_memory_offset` variable here. If guards aren't specified\n        // before linear memories this is set to `0`, otherwise it's set to\n        // the same size as guard regions for other memories.\n        let allocation_size = memory_size\n            .checked_mul(max_memories)\n            .and_then(|c| c.checked_mul(max_instances))\n            .and_then(|c| c.checked_add(initial_memory_offset))\n            .ok_or_else(|| {\n                anyhow!(\"total size of memory reservation exceeds addressable memory\")\n            })?;\n\n        // Create a completely inaccessible region to start\n        let mapping = Mmap::accessible_reserved(0, allocation_size)\n            .context(\"failed to create memory pool mapping\")?;\n\n        let num_image_slots = if cfg!(memory_init_cow) {\n            max_instances * max_memories\n        } else {\n            0\n        };\n        let image_slots: Vec<_> = std::iter::repeat_with(|| Mutex::new(None))\n            .take(num_image_slots)\n            .collect();\n\n        let pool = Self {\n            mapping,\n            image_slots,\n            memory_reservation_size: memory_size,\n            initial_memory_offset,\n            max_memories,\n            max_instances,\n            max_memory_size: (instance_limits.memory_pages as usize) * (WASM_PAGE_SIZE as usize),\n        };\n\n        Ok(pool)\n    }\n\n    fn get_base(&self, instance_index: usize, memory_index: DefinedMemoryIndex) -> *mut u8 {\n        assert!(instance_index < self.max_instances);\n        let memory_index = memory_index.as_u32() as usize;\n        assert!(memory_index < self.max_memories);\n        let idx = instance_index * self.max_memories + memory_index;\n        let offset = self.initial_memory_offset + idx * self.memory_reservation_size;\n        unsafe { self.mapping.as_mut_ptr().offset(offset as isize) }\n    }\n\n    fn get<'a>(&'a self, instance_index: usize) -> impl Iterator<Item = *mut u8> + 'a {\n        (0..self.max_memories)\n            .map(move |i| self.get_base(instance_index, DefinedMemoryIndex::from_u32(i as u32)))\n    }\n\n    /// Take ownership of the given image slot. Must be returned via\n    /// `return_memory_image_slot` when the instance is done using it.\n    fn take_memory_image_slot(\n        &self,\n        instance_index: usize,\n        memory_index: DefinedMemoryIndex,\n    ) -> MemoryImageSlot {\n        let idx = instance_index * self.max_memories + (memory_index.as_u32() as usize);\n        let maybe_slot = self.image_slots[idx].lock().unwrap().take();\n\n        maybe_slot.unwrap_or_else(|| {\n            MemoryImageSlot::create(\n                self.get_base(instance_index, memory_index) as *mut c_void,\n                0,\n                self.max_memory_size,\n            )\n        })\n    }\n\n    /// Return ownership of the given image slot.\n    fn return_memory_image_slot(\n        &self,\n        instance_index: usize,\n        memory_index: DefinedMemoryIndex,\n        slot: MemoryImageSlot,\n    ) {\n        assert!(!slot.is_dirty());\n        let idx = instance_index * self.max_memories + (memory_index.as_u32() as usize);\n        *self.image_slots[idx].lock().unwrap() = Some(slot);\n    }\n}\n\nimpl Drop for MemoryPool {\n    fn drop(&mut self) {\n        // Clear the `clear_no_drop` flag (i.e., ask to *not* clear on\n        // drop) for all slots, and then drop them here. This is\n        // valid because the one `Mmap` that covers the whole region\n        // can just do its one munmap.\n        for mut slot in std::mem::take(&mut self.image_slots) {\n            if let Some(slot) = slot.get_mut().unwrap() {\n                slot.no_clear_on_drop();\n            }\n        }\n    }\n}\n\n/// Represents a pool of WebAssembly tables.\n///\n/// Each instance index into the pool returns an iterator over the base addresses\n/// of the instance's tables.\n#[derive(Debug)]\nstruct TablePool {\n    mapping: Mmap,\n    table_size: usize,\n    max_tables: usize,\n    max_instances: usize,\n    page_size: usize,\n    max_elements: u32,\n}\n\nimpl TablePool {\n    fn new(instance_limits: &InstanceLimits) -> Result<Self> {\n        let page_size = crate::page_size();\n\n        let table_size = round_up_to_pow2(\n            mem::size_of::<*mut u8>()\n                .checked_mul(instance_limits.table_elements as usize)\n                .ok_or_else(|| anyhow!(\"table size exceeds addressable memory\"))?,\n            page_size,\n        );\n\n        let max_instances = instance_limits.count as usize;\n        let max_tables = instance_limits.tables as usize;\n\n        let allocation_size = table_size\n            .checked_mul(max_tables)\n            .and_then(|c| c.checked_mul(max_instances))\n            .ok_or_else(|| anyhow!(\"total size of instance tables exceeds addressable memory\"))?;\n\n        let mapping = Mmap::accessible_reserved(allocation_size, allocation_size)\n            .context(\"failed to create table pool mapping\")?;\n\n        Ok(Self {\n            mapping,\n            table_size,\n            max_tables,\n            max_instances,\n            page_size,\n            max_elements: instance_limits.table_elements,\n        })\n    }\n\n    fn get(&self, instance_index: usize) -> impl Iterator<Item = *mut u8> {\n        assert!(instance_index < self.max_instances);\n\n        let base: *mut u8 = unsafe {\n            self.mapping\n                .as_mut_ptr()\n                .add(instance_index * self.table_size * self.max_tables) as _\n        };\n\n        let size = self.table_size;\n        (0..self.max_tables).map(move |i| unsafe { base.add(i * size) })\n    }\n}\n\n/// Represents a pool of execution stacks (used for the async fiber implementation).\n///\n/// Each index into the pool represents a single execution stack. The maximum number of\n/// stacks is the same as the maximum number of instances.\n///\n/// As stacks grow downwards, each stack starts (lowest address) with a guard page\n/// that can be used to detect stack overflow.\n///\n/// The top of the stack (starting stack pointer) is returned when a stack is allocated\n/// from the pool.\n#[cfg(all(feature = \"async\", unix))]\n#[derive(Debug)]\nstruct StackPool {\n    mapping: Mmap,\n    stack_size: usize,\n    max_instances: usize,\n    page_size: usize,\n    index_allocator: Mutex<PoolingAllocationState>,\n    async_stack_zeroing: bool,\n}\n\n#[cfg(all(feature = \"async\", unix))]\nimpl StackPool {\n    fn new(\n        instance_limits: &InstanceLimits,\n        stack_size: usize,\n        async_stack_zeroing: bool,\n    ) -> Result<Self> {\n        use rustix::mm::{mprotect, MprotectFlags};\n\n        let page_size = crate::page_size();\n\n        // Add a page to the stack size for the guard page when using fiber stacks\n        let stack_size = if stack_size == 0 {\n            0\n        } else {\n            round_up_to_pow2(stack_size, page_size)\n                .checked_add(page_size)\n                .ok_or_else(|| anyhow!(\"stack size exceeds addressable memory\"))?\n        };\n\n        let max_instances = instance_limits.count as usize;\n\n        let allocation_size = stack_size\n            .checked_mul(max_instances)\n            .ok_or_else(|| anyhow!(\"total size of execution stacks exceeds addressable memory\"))?;\n\n        let mapping = Mmap::accessible_reserved(allocation_size, allocation_size)\n            .context(\"failed to create stack pool mapping\")?;\n\n        // Set up the stack guard pages\n        if allocation_size > 0 {\n            unsafe {\n                for i in 0..max_instances {\n                    // Make the stack guard page inaccessible\n                    let bottom_of_stack = mapping.as_mut_ptr().add(i * stack_size);\n                    mprotect(bottom_of_stack.cast(), page_size, MprotectFlags::empty())\n                        .context(\"failed to protect stack guard page\")?;\n                }\n            }\n        }\n\n        Ok(Self {\n            mapping,\n            stack_size,\n            max_instances,\n            page_size,\n            async_stack_zeroing,\n            // We always use a `NextAvailable` strategy for stack\n            // allocation. We don't want or need an affinity policy\n            // here: stacks do not benefit from being allocated to the\n            // same compiled module with the same image (they always\n            // start zeroed just the same for everyone).\n            index_allocator: Mutex::new(PoolingAllocationState::new(\n                PoolingAllocationStrategy::NextAvailable,\n                max_instances,\n            )),\n        })\n    }\n\n    fn allocate(&self) -> Result<wasmtime_fiber::FiberStack, FiberStackError> {\n        if self.stack_size == 0 {\n            return Err(FiberStackError::NotSupported);\n        }\n\n        let index = {\n            let mut alloc = self.index_allocator.lock().unwrap();\n            if alloc.is_empty() {\n                return Err(FiberStackError::Limit(self.max_instances as u32));\n            }\n            alloc.alloc(None).index()\n        };\n\n        assert!(index < self.max_instances);\n\n        unsafe {\n            // Remove the guard page from the size\n            let size_without_guard = self.stack_size - self.page_size;\n\n            let bottom_of_stack = self\n                .mapping\n                .as_mut_ptr()\n                .add((index * self.stack_size) + self.page_size);\n\n            commit_stack_pages(bottom_of_stack, size_without_guard)\n                .map_err(FiberStackError::Resource)?;\n\n            wasmtime_fiber::FiberStack::from_top_ptr(bottom_of_stack.add(size_without_guard))\n                .map_err(|e| FiberStackError::Resource(e.into()))\n        }\n    }\n\n    fn deallocate(&self, stack: &wasmtime_fiber::FiberStack) {\n        let top = stack\n            .top()\n            .expect(\"fiber stack not allocated from the pool\") as usize;\n\n        let base = self.mapping.as_ptr() as usize;\n        let len = self.mapping.len();\n        assert!(\n            top > base && top <= (base + len),\n            \"fiber stack top pointer not in range\"\n        );\n\n        // Remove the guard page from the size\n        let stack_size = self.stack_size - self.page_size;\n        let bottom_of_stack = top - stack_size;\n        let start_of_stack = bottom_of_stack - self.page_size;\n        assert!(start_of_stack >= base && start_of_stack < (base + len));\n        assert!((start_of_stack - base) % self.stack_size == 0);\n\n        let index = (start_of_stack - base) / self.stack_size;\n        assert!(index < self.max_instances);\n\n        if self.async_stack_zeroing {\n            reset_stack_pages_to_zero(bottom_of_stack as _, stack_size).unwrap();\n        }\n\n        self.index_allocator.lock().unwrap().free(SlotId(index));\n    }\n}\n\n/// Implements the pooling instance allocator.\n///\n/// This allocator internally maintains pools of instances, memories, tables, and stacks.\n///\n/// Note: the resource pools are manually dropped so that the fault handler terminates correctly.\n#[derive(Debug)]\npub struct PoolingInstanceAllocator {\n    instances: InstancePool,\n    #[cfg(all(feature = \"async\", unix))]\n    stacks: StackPool,\n    #[cfg(all(feature = \"async\", windows))]\n    stack_size: usize,\n}\n\nimpl PoolingInstanceAllocator {\n    /// Creates a new pooling instance allocator with the given strategy and limits.\n    pub fn new(\n        strategy: PoolingAllocationStrategy,\n        instance_limits: InstanceLimits,\n        stack_size: usize,\n        tunables: &Tunables,\n        async_stack_zeroing: bool,\n    ) -> Result<Self> {\n        if instance_limits.count == 0 {\n            bail!(\"the instance count limit cannot be zero\");\n        }\n\n        let instances = InstancePool::new(strategy, &instance_limits, tunables)?;\n\n        drop(stack_size); // suppress unused warnings w/o async feature\n        drop(async_stack_zeroing); // suppress unused warnings w/o async feature\n\n        Ok(Self {\n            instances: instances,\n            #[cfg(all(feature = \"async\", unix))]\n            stacks: StackPool::new(&instance_limits, stack_size, async_stack_zeroing)?,\n            #[cfg(all(feature = \"async\", windows))]\n            stack_size,\n        })\n    }\n}\n\nunsafe impl InstanceAllocator for PoolingInstanceAllocator {\n    fn validate(&self, module: &Module) -> Result<()> {\n        self.instances.validate_memory_plans(module)?;\n        self.instances.validate_table_plans(module)?;\n\n        // Note that this check is not 100% accurate for cross-compiled systems\n        // where the pointer size may change since this check is often performed\n        // at compile time instead of runtime. Given that Wasmtime is almost\n        // always on a 64-bit platform though this is generally ok, and\n        // otherwise this check also happens during instantiation to\n        // double-check at that point.\n        self.instances.validate_instance_size(module)?;\n\n        Ok(())\n    }\n\n    fn adjust_tunables(&self, tunables: &mut Tunables) {\n        // Treat the static memory bound as the maximum for unbounded Wasm memories\n        // Because we guarantee a module cannot compile unless it fits in the limits of\n        // the pool allocator, this ensures all memories are treated as static (i.e. immovable).\n        tunables.static_memory_bound_is_maximum = true;\n    }\n\n    unsafe fn allocate(\n        &self,\n        req: InstanceAllocationRequest,\n    ) -> Result<InstanceHandle, InstantiationError> {\n        self.instances.allocate(req)\n    }\n\n    unsafe fn initialize(\n        &self,\n        handle: &mut InstanceHandle,\n        module: &Module,\n        is_bulk_memory: bool,\n    ) -> Result<(), InstantiationError> {\n        let instance = handle.instance_mut();\n        initialize_instance(instance, module, is_bulk_memory)\n    }\n\n    unsafe fn deallocate(&self, handle: &InstanceHandle) {\n        self.instances.deallocate(handle);\n    }\n\n    #[cfg(all(feature = \"async\", unix))]\n    fn allocate_fiber_stack(&self) -> Result<wasmtime_fiber::FiberStack, FiberStackError> {\n        self.stacks.allocate()\n    }\n\n    #[cfg(all(feature = \"async\", unix))]\n    unsafe fn deallocate_fiber_stack(&self, stack: &wasmtime_fiber::FiberStack) {\n        self.stacks.deallocate(stack);\n    }\n\n    #[cfg(all(feature = \"async\", windows))]\n    fn allocate_fiber_stack(&self) -> Result<wasmtime_fiber::FiberStack, FiberStackError> {\n        if self.stack_size == 0 {\n            return Err(FiberStackError::NotSupported);\n        }\n\n        // On windows, we don't use a stack pool as we use the native fiber implementation\n        wasmtime_fiber::FiberStack::new(self.stack_size)\n            .map_err(|e| FiberStackError::Resource(e.into()))\n    }\n\n    #[cfg(all(feature = \"async\", windows))]\n    unsafe fn deallocate_fiber_stack(&self, _stack: &wasmtime_fiber::FiberStack) {\n        // A no-op as we don't own the fiber stack on Windows\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n    use crate::{CompiledModuleId, Imports, MemoryImage, StorePtr, VMSharedSignatureIndex};\n    use std::sync::Arc;\n    use wasmtime_environ::{DefinedFuncIndex, DefinedMemoryIndex, FunctionInfo, SignatureIndex};\n\n    pub(crate) fn empty_runtime_info(\n        module: Arc<wasmtime_environ::Module>,\n    ) -> Arc<dyn ModuleRuntimeInfo> {\n        struct RuntimeInfo(Arc<wasmtime_environ::Module>);\n\n        impl ModuleRuntimeInfo for RuntimeInfo {\n            fn module(&self) -> &Arc<wasmtime_environ::Module> {\n                &self.0\n            }\n            fn image_base(&self) -> usize {\n                0\n            }\n            fn function_info(&self, _: DefinedFuncIndex) -> &FunctionInfo {\n                unimplemented!()\n            }\n            fn signature(&self, _: SignatureIndex) -> VMSharedSignatureIndex {\n                unimplemented!()\n            }\n            fn memory_image(\n                &self,\n                _: DefinedMemoryIndex,\n            ) -> anyhow::Result<Option<&Arc<MemoryImage>>> {\n                Ok(None)\n            }\n\n            fn unique_id(&self) -> Option<CompiledModuleId> {\n                None\n            }\n            fn wasm_data(&self) -> &[u8] {\n                &[]\n            }\n            fn signature_ids(&self) -> &[VMSharedSignatureIndex] {\n                &[]\n            }\n        }\n\n        Arc::new(RuntimeInfo(module))\n    }\n\n    #[cfg(target_pointer_width = \"64\")]\n    #[test]\n    fn test_instance_pool() -> Result<()> {\n        let instance_limits = InstanceLimits {\n            count: 3,\n            tables: 1,\n            memories: 1,\n            table_elements: 10,\n            size: 1000,\n            memory_pages: 1,\n            ..Default::default()\n        };\n\n        let instances = InstancePool::new(\n            PoolingAllocationStrategy::NextAvailable,\n            &instance_limits,\n            &Tunables {\n                static_memory_bound: 1,\n                ..Tunables::default()\n            },\n        )?;\n\n        assert_eq!(instances.instance_size, 1008); // round 1000 up to alignment\n        assert_eq!(instances.max_instances, 3);\n\n        assert_eq!(\n            instances.index_allocator.lock().unwrap().testing_freelist(),\n            &[SlotId(0), SlotId(1), SlotId(2)]\n        );\n\n        let mut handles = Vec::new();\n        let module = Arc::new(Module::default());\n\n        for _ in (0..3).rev() {\n            handles.push(\n                instances\n                    .allocate(InstanceAllocationRequest {\n                        runtime_info: &empty_runtime_info(module.clone()),\n                        imports: Imports {\n                            functions: &[],\n                            tables: &[],\n                            memories: &[],\n                            globals: &[],\n                        },\n                        host_state: Box::new(()),\n                        store: StorePtr::empty(),\n                    })\n                    .expect(\"allocation should succeed\"),\n            );\n        }\n\n        assert_eq!(\n            instances.index_allocator.lock().unwrap().testing_freelist(),\n            &[]\n        );\n\n        match instances.allocate(InstanceAllocationRequest {\n            runtime_info: &empty_runtime_info(module),\n            imports: Imports {\n                functions: &[],\n                tables: &[],\n                memories: &[],\n                globals: &[],\n            },\n            host_state: Box::new(()),\n            store: StorePtr::empty(),\n        }) {\n            Err(InstantiationError::Limit(3)) => {}\n            _ => panic!(\"unexpected error\"),\n        };\n\n        for handle in handles.drain(..) {\n            instances.deallocate(&handle);\n        }\n\n        assert_eq!(\n            instances.index_allocator.lock().unwrap().testing_freelist(),\n            &[SlotId(2), SlotId(1), SlotId(0)]\n        );\n\n        Ok(())\n    }\n\n    #[cfg(target_pointer_width = \"64\")]\n    #[test]\n    fn test_memory_pool() -> Result<()> {\n        let pool = MemoryPool::new(\n            &InstanceLimits {\n                count: 5,\n                tables: 0,\n                memories: 3,\n                table_elements: 0,\n                memory_pages: 1,\n                ..Default::default()\n            },\n            &Tunables {\n                static_memory_bound: 1,\n                static_memory_offset_guard_size: 0,\n                ..Tunables::default()\n            },\n        )?;\n\n        assert_eq!(pool.memory_reservation_size, WASM_PAGE_SIZE as usize);\n        assert_eq!(pool.max_memories, 3);\n        assert_eq!(pool.max_instances, 5);\n        assert_eq!(pool.max_memory_size, WASM_PAGE_SIZE as usize);\n\n        let base = pool.mapping.as_ptr() as usize;\n\n        for i in 0..5 {\n            let mut iter = pool.get(i);\n\n            for j in 0..3 {\n                assert_eq!(\n                    iter.next().unwrap() as usize - base,\n                    ((i * 3) + j) * pool.memory_reservation_size\n                );\n            }\n\n            assert_eq!(iter.next(), None);\n        }\n\n        Ok(())\n    }\n\n    #[cfg(target_pointer_width = \"64\")]\n    #[test]\n    fn test_table_pool() -> Result<()> {\n        let pool = TablePool::new(&InstanceLimits {\n            count: 7,\n            table_elements: 100,\n            memory_pages: 0,\n            tables: 4,\n            memories: 0,\n            ..Default::default()\n        })?;\n\n        let host_page_size = crate::page_size();\n\n        assert_eq!(pool.table_size, host_page_size);\n        assert_eq!(pool.max_tables, 4);\n        assert_eq!(pool.max_instances, 7);\n        assert_eq!(pool.page_size, host_page_size);\n        assert_eq!(pool.max_elements, 100);\n\n        let base = pool.mapping.as_ptr() as usize;\n\n        for i in 0..7 {\n            let mut iter = pool.get(i);\n\n            for j in 0..4 {\n                assert_eq!(\n                    iter.next().unwrap() as usize - base,\n                    ((i * 4) + j) * pool.table_size\n                );\n            }\n\n            assert_eq!(iter.next(), None);\n        }\n\n        Ok(())\n    }\n\n    #[cfg(all(unix, target_pointer_width = \"64\", feature = \"async\"))]\n    #[test]\n    fn test_stack_pool() -> Result<()> {\n        let pool = StackPool::new(\n            &InstanceLimits {\n                count: 10,\n                ..Default::default()\n            },\n            1,\n            true,\n        )?;\n\n        let native_page_size = crate::page_size();\n        assert_eq!(pool.stack_size, 2 * native_page_size);\n        assert_eq!(pool.max_instances, 10);\n        assert_eq!(pool.page_size, native_page_size);\n\n        assert_eq!(\n            pool.index_allocator.lock().unwrap().testing_freelist(),\n            &[\n                SlotId(0),\n                SlotId(1),\n                SlotId(2),\n                SlotId(3),\n                SlotId(4),\n                SlotId(5),\n                SlotId(6),\n                SlotId(7),\n                SlotId(8),\n                SlotId(9)\n            ],\n        );\n\n        let base = pool.mapping.as_ptr() as usize;\n\n        let mut stacks = Vec::new();\n        for i in (0..10).rev() {\n            let stack = pool.allocate().expect(\"allocation should succeed\");\n            assert_eq!(\n                ((stack.top().unwrap() as usize - base) / pool.stack_size) - 1,\n                i\n            );\n            stacks.push(stack);\n        }\n\n        assert_eq!(pool.index_allocator.lock().unwrap().testing_freelist(), &[]);\n\n        match pool.allocate().unwrap_err() {\n            FiberStackError::Limit(10) => {}\n            _ => panic!(\"unexpected error\"),\n        };\n\n        for stack in stacks {\n            pool.deallocate(&stack);\n        }\n\n        assert_eq!(\n            pool.index_allocator.lock().unwrap().testing_freelist(),\n            &[\n                SlotId(9),\n                SlotId(8),\n                SlotId(7),\n                SlotId(6),\n                SlotId(5),\n                SlotId(4),\n                SlotId(3),\n                SlotId(2),\n                SlotId(1),\n                SlotId(0)\n            ],\n        );\n\n        Ok(())\n    }\n\n    #[test]\n    fn test_pooling_allocator_with_zero_instance_count() {\n        assert_eq!(\n            PoolingInstanceAllocator::new(\n                PoolingAllocationStrategy::Random,\n                InstanceLimits {\n                    count: 0,\n                    ..Default::default()\n                },\n                4096,\n                &Tunables::default(),\n                true,\n            )\n            .map_err(|e| e.to_string())\n            .expect_err(\"expected a failure constructing instance allocator\"),\n            \"the instance count limit cannot be zero\"\n        );\n    }\n\n    #[test]\n    fn test_pooling_allocator_with_memory_pages_exceeded() {\n        assert_eq!(\n            PoolingInstanceAllocator::new(\n                PoolingAllocationStrategy::Random,\n                InstanceLimits {\n                    count: 1,\n                    memory_pages: 0x10001,\n                    ..Default::default()\n                },\n                4096,\n                &Tunables {\n                    static_memory_bound: 1,\n                    ..Tunables::default()\n                },\n                true,\n            )\n            .map_err(|e| e.to_string())\n            .expect_err(\"expected a failure constructing instance allocator\"),\n            \"module memory page limit of 65537 exceeds the maximum of 65536\"\n        );\n    }\n\n    #[test]\n    fn test_pooling_allocator_with_reservation_size_exceeded() {\n        assert_eq!(\n            PoolingInstanceAllocator::new(\n                PoolingAllocationStrategy::Random,\n                InstanceLimits {\n                    count: 1,\n                    memory_pages: 2,\n                    ..Default::default()\n                },\n                4096,\n                &Tunables {\n                    static_memory_bound: 1,\n                    static_memory_offset_guard_size: 0,\n                    ..Tunables::default()\n                },\n                true\n            )\n            .map_err(|e| e.to_string())\n            .expect_err(\"expected a failure constructing instance allocator\"),\n            \"module memory page limit of 2 pages exceeds maximum static memory limit of 1 pages\"\n        );\n    }\n\n    #[cfg(all(unix, target_pointer_width = \"64\", feature = \"async\"))]\n    #[test]\n    fn test_stack_zeroed() -> Result<()> {\n        let allocator = PoolingInstanceAllocator::new(\n            PoolingAllocationStrategy::NextAvailable,\n            InstanceLimits {\n                count: 1,\n                table_elements: 0,\n                memory_pages: 0,\n                tables: 0,\n                memories: 0,\n                ..Default::default()\n            },\n            128,\n            &Tunables::default(),\n            true,\n        )?;\n\n        unsafe {\n            for _ in 0..255 {\n                let stack = allocator.allocate_fiber_stack()?;\n\n                // The stack pointer is at the top, so decrement it first\n                let addr = stack.top().unwrap().sub(1);\n\n                assert_eq!(*addr, 0);\n                *addr = 1;\n\n                allocator.deallocate_fiber_stack(&stack);\n            }\n        }\n\n        Ok(())\n    }\n\n    #[cfg(all(unix, target_pointer_width = \"64\", feature = \"async\"))]\n    #[test]\n    fn test_stack_unzeroed() -> Result<()> {\n        let allocator = PoolingInstanceAllocator::new(\n            PoolingAllocationStrategy::NextAvailable,\n            InstanceLimits {\n                count: 1,\n                table_elements: 0,\n                memory_pages: 0,\n                tables: 0,\n                memories: 0,\n                ..Default::default()\n            },\n            128,\n            &Tunables::default(),\n            false,\n        )?;\n\n        unsafe {\n            for i in 0..255 {\n                let stack = allocator.allocate_fiber_stack()?;\n\n                // The stack pointer is at the top, so decrement it first\n                let addr = stack.top().unwrap().sub(1);\n\n                assert_eq!(*addr, i);\n                *addr = i + 1;\n\n                allocator.deallocate_fiber_stack(&stack);\n            }\n        }\n\n        Ok(())\n    }\n}\n", "use super::skip_pooling_allocator_tests;\nuse anyhow::Result;\nuse wasmtime::*;\n\n#[test]\nfn successful_instantiation() -> Result<()> {\n    let mut config = Config::new();\n    config.allocation_strategy(InstanceAllocationStrategy::Pooling {\n        strategy: PoolingAllocationStrategy::NextAvailable,\n        instance_limits: InstanceLimits {\n            count: 1,\n            memory_pages: 1,\n            table_elements: 10,\n            ..Default::default()\n        },\n    });\n    config.dynamic_memory_guard_size(0);\n    config.static_memory_guard_size(0);\n    config.static_memory_maximum_size(65536);\n\n    let engine = Engine::new(&config)?;\n    let module = Module::new(&engine, r#\"(module (memory 1) (table 10 funcref))\"#)?;\n\n    // Module should instantiate\n    let mut store = Store::new(&engine, ());\n    Instance::new(&mut store, &module, &[])?;\n\n    Ok(())\n}\n\n#[test]\nfn memory_limit() -> Result<()> {\n    let mut config = Config::new();\n    config.allocation_strategy(InstanceAllocationStrategy::Pooling {\n        strategy: PoolingAllocationStrategy::NextAvailable,\n        instance_limits: InstanceLimits {\n            count: 1,\n            memory_pages: 3,\n            table_elements: 10,\n            ..Default::default()\n        },\n    });\n    config.dynamic_memory_guard_size(0);\n    config.static_memory_guard_size(65536);\n    config.static_memory_maximum_size(3 * 65536);\n    config.wasm_multi_memory(true);\n\n    let engine = Engine::new(&config)?;\n\n    // Module should fail to instantiate because it has too many memories\n    match Module::new(&engine, r#\"(module (memory 1) (memory 1))\"#) {\n        Ok(_) => panic!(\"module instantiation should fail\"),\n        Err(e) => assert_eq!(\n            e.to_string(),\n            \"defined memories count of 2 exceeds the limit of 1\",\n        ),\n    }\n\n    // Module should fail to instantiate because the minimum is greater than\n    // the configured limit\n    match Module::new(&engine, r#\"(module (memory 4))\"#) {\n        Ok(_) => panic!(\"module instantiation should fail\"),\n        Err(e) => assert_eq!(\n            e.to_string(),\n            \"memory index 0 has a minimum page size of 4 which exceeds the limit of 3\",\n        ),\n    }\n\n    let module = Module::new(\n        &engine,\n        r#\"(module (memory (export \"m\") 0) (func (export \"f\") (result i32) (memory.grow (i32.const 1))))\"#,\n    )?;\n\n    // Instantiate the module and grow the memory via the `f` function\n    {\n        let mut store = Store::new(&engine, ());\n        let instance = Instance::new(&mut store, &module, &[])?;\n        let f = instance.get_typed_func::<(), i32, _>(&mut store, \"f\")?;\n\n        assert_eq!(f.call(&mut store, ()).expect(\"function should not trap\"), 0);\n        assert_eq!(f.call(&mut store, ()).expect(\"function should not trap\"), 1);\n        assert_eq!(f.call(&mut store, ()).expect(\"function should not trap\"), 2);\n        assert_eq!(\n            f.call(&mut store, ()).expect(\"function should not trap\"),\n            -1\n        );\n        assert_eq!(\n            f.call(&mut store, ()).expect(\"function should not trap\"),\n            -1\n        );\n    }\n\n    // Instantiate the module and grow the memory via the Wasmtime API\n    let mut store = Store::new(&engine, ());\n    let instance = Instance::new(&mut store, &module, &[])?;\n\n    let memory = instance.get_memory(&mut store, \"m\").unwrap();\n    assert_eq!(memory.size(&store), 0);\n    assert_eq!(memory.grow(&mut store, 1).expect(\"memory should grow\"), 0);\n    assert_eq!(memory.size(&store), 1);\n    assert_eq!(memory.grow(&mut store, 1).expect(\"memory should grow\"), 1);\n    assert_eq!(memory.size(&store), 2);\n    assert_eq!(memory.grow(&mut store, 1).expect(\"memory should grow\"), 2);\n    assert_eq!(memory.size(&store), 3);\n    assert!(memory.grow(&mut store, 1).is_err());\n\n    Ok(())\n}\n\n#[test]\nfn memory_init() -> Result<()> {\n    let mut config = Config::new();\n    config.allocation_strategy(InstanceAllocationStrategy::Pooling {\n        strategy: PoolingAllocationStrategy::NextAvailable,\n        instance_limits: InstanceLimits {\n            count: 1,\n            memory_pages: 2,\n            table_elements: 0,\n            ..Default::default()\n        },\n    });\n\n    let engine = Engine::new(&config)?;\n\n    let module = Module::new(\n        &engine,\n        r#\"(module (memory (export \"m\") 2) (data (i32.const 65530) \"this data spans multiple pages\") (data (i32.const 10) \"hello world\"))\"#,\n    )?;\n\n    let mut store = Store::new(&engine, ());\n    let instance = Instance::new(&mut store, &module, &[])?;\n    let memory = instance.get_memory(&mut store, \"m\").unwrap();\n\n    assert_eq!(\n        &memory.data(&store)[65530..65560],\n        b\"this data spans multiple pages\"\n    );\n    assert_eq!(&memory.data(&store)[10..21], b\"hello world\");\n\n    Ok(())\n}\n\n#[test]\nfn memory_guard_page_trap() -> Result<()> {\n    let mut config = Config::new();\n    config.allocation_strategy(InstanceAllocationStrategy::Pooling {\n        strategy: PoolingAllocationStrategy::NextAvailable,\n        instance_limits: InstanceLimits {\n            count: 1,\n            memory_pages: 2,\n            table_elements: 0,\n            ..Default::default()\n        },\n    });\n\n    let engine = Engine::new(&config)?;\n\n    let module = Module::new(\n        &engine,\n        r#\"(module (memory (export \"m\") 0) (func (export \"f\") (param i32) local.get 0 i32.load drop))\"#,\n    )?;\n\n    // Instantiate the module and check for out of bounds trap\n    for _ in 0..10 {\n        let mut store = Store::new(&engine, ());\n        let instance = Instance::new(&mut store, &module, &[])?;\n        let m = instance.get_memory(&mut store, \"m\").unwrap();\n        let f = instance.get_typed_func::<i32, (), _>(&mut store, \"f\")?;\n\n        let trap = f.call(&mut store, 0).expect_err(\"function should trap\");\n        assert!(trap.to_string().contains(\"out of bounds\"));\n\n        let trap = f.call(&mut store, 1).expect_err(\"function should trap\");\n        assert!(trap.to_string().contains(\"out of bounds\"));\n\n        m.grow(&mut store, 1).expect(\"memory should grow\");\n        f.call(&mut store, 0).expect(\"function should not trap\");\n\n        let trap = f.call(&mut store, 65536).expect_err(\"function should trap\");\n        assert!(trap.to_string().contains(\"out of bounds\"));\n\n        let trap = f.call(&mut store, 65537).expect_err(\"function should trap\");\n        assert!(trap.to_string().contains(\"out of bounds\"));\n\n        m.grow(&mut store, 1).expect(\"memory should grow\");\n        f.call(&mut store, 65536).expect(\"function should not trap\");\n\n        m.grow(&mut store, 1)\n            .expect_err(\"memory should be at the limit\");\n    }\n\n    Ok(())\n}\n\n#[test]\nfn memory_zeroed() -> Result<()> {\n    if skip_pooling_allocator_tests() {\n        return Ok(());\n    }\n\n    let mut config = Config::new();\n    config.allocation_strategy(InstanceAllocationStrategy::Pooling {\n        strategy: PoolingAllocationStrategy::NextAvailable,\n        instance_limits: InstanceLimits {\n            count: 1,\n            memory_pages: 1,\n            table_elements: 0,\n            ..Default::default()\n        },\n    });\n    config.dynamic_memory_guard_size(0);\n    config.static_memory_guard_size(0);\n    config.static_memory_maximum_size(65536);\n\n    let engine = Engine::new(&config)?;\n\n    let module = Module::new(&engine, r#\"(module (memory (export \"m\") 1))\"#)?;\n\n    // Instantiate the module repeatedly after writing data to the entire memory\n    for _ in 0..10 {\n        let mut store = Store::new(&engine, ());\n        let instance = Instance::new(&mut store, &module, &[])?;\n        let memory = instance.get_memory(&mut store, \"m\").unwrap();\n\n        assert_eq!(memory.size(&store,), 1);\n        assert_eq!(memory.data_size(&store), 65536);\n\n        let ptr = memory.data_mut(&mut store).as_mut_ptr();\n\n        unsafe {\n            for i in 0..8192 {\n                assert_eq!(*ptr.cast::<u64>().offset(i), 0);\n            }\n            std::ptr::write_bytes(ptr, 0xFE, memory.data_size(&store));\n        }\n    }\n\n    Ok(())\n}\n\n#[test]\nfn table_limit() -> Result<()> {\n    const TABLE_ELEMENTS: u32 = 10;\n    let mut config = Config::new();\n    config.allocation_strategy(InstanceAllocationStrategy::Pooling {\n        strategy: PoolingAllocationStrategy::NextAvailable,\n        instance_limits: InstanceLimits {\n            count: 1,\n            memory_pages: 1,\n            table_elements: TABLE_ELEMENTS,\n            ..Default::default()\n        },\n    });\n    config.dynamic_memory_guard_size(0);\n    config.static_memory_guard_size(0);\n    config.static_memory_maximum_size(65536);\n\n    let engine = Engine::new(&config)?;\n\n    // Module should fail to instantiate because it has too many tables\n    match Module::new(&engine, r#\"(module (table 1 funcref) (table 1 funcref))\"#) {\n        Ok(_) => panic!(\"module compilation should fail\"),\n        Err(e) => assert_eq!(\n            e.to_string(),\n            \"defined tables count of 2 exceeds the limit of 1\",\n        ),\n    }\n\n    // Module should fail to instantiate because the minimum is greater than\n    // the configured limit\n    match Module::new(&engine, r#\"(module (table 31 funcref))\"#) {\n        Ok(_) => panic!(\"module compilation should fail\"),\n        Err(e) => assert_eq!(\n            e.to_string(),\n            \"table index 0 has a minimum element size of 31 which exceeds the limit of 10\",\n        ),\n    }\n\n    let module = Module::new(\n        &engine,\n        r#\"(module (table (export \"t\") 0 funcref) (func (export \"f\") (result i32) (table.grow (ref.null func) (i32.const 1))))\"#,\n    )?;\n\n    // Instantiate the module and grow the table via the `f` function\n    {\n        let mut store = Store::new(&engine, ());\n        let instance = Instance::new(&mut store, &module, &[])?;\n        let f = instance.get_typed_func::<(), i32, _>(&mut store, \"f\")?;\n\n        for i in 0..TABLE_ELEMENTS {\n            assert_eq!(\n                f.call(&mut store, ()).expect(\"function should not trap\"),\n                i as i32\n            );\n        }\n\n        assert_eq!(\n            f.call(&mut store, ()).expect(\"function should not trap\"),\n            -1\n        );\n        assert_eq!(\n            f.call(&mut store, ()).expect(\"function should not trap\"),\n            -1\n        );\n    }\n\n    // Instantiate the module and grow the table via the Wasmtime API\n    let mut store = Store::new(&engine, ());\n    let instance = Instance::new(&mut store, &module, &[])?;\n\n    let table = instance.get_table(&mut store, \"t\").unwrap();\n\n    for i in 0..TABLE_ELEMENTS {\n        assert_eq!(table.size(&store), i);\n        assert_eq!(\n            table\n                .grow(&mut store, 1, Val::FuncRef(None))\n                .expect(\"table should grow\"),\n            i\n        );\n    }\n\n    assert_eq!(table.size(&store), TABLE_ELEMENTS);\n    assert!(table.grow(&mut store, 1, Val::FuncRef(None)).is_err());\n\n    Ok(())\n}\n\n#[test]\nfn table_init() -> Result<()> {\n    let mut config = Config::new();\n    config.allocation_strategy(InstanceAllocationStrategy::Pooling {\n        strategy: PoolingAllocationStrategy::NextAvailable,\n        instance_limits: InstanceLimits {\n            count: 1,\n            memory_pages: 0,\n            table_elements: 6,\n            ..Default::default()\n        },\n    });\n\n    let engine = Engine::new(&config)?;\n\n    let module = Module::new(\n        &engine,\n        r#\"(module (table (export \"t\") 6 funcref) (elem (i32.const 1) 1 2 3 4) (elem (i32.const 0) 0) (func) (func (param i32)) (func (param i32 i32)) (func (param i32 i32 i32)) (func (param i32 i32 i32 i32)))\"#,\n    )?;\n\n    let mut store = Store::new(&engine, ());\n    let instance = Instance::new(&mut store, &module, &[])?;\n    let table = instance.get_table(&mut store, \"t\").unwrap();\n\n    for i in 0..5 {\n        let v = table.get(&mut store, i).expect(\"table should have entry\");\n        let f = v\n            .funcref()\n            .expect(\"expected funcref\")\n            .expect(\"expected non-null value\");\n        assert_eq!(f.ty(&store).params().len(), i as usize);\n    }\n\n    assert!(\n        table\n            .get(&mut store, 5)\n            .expect(\"table should have entry\")\n            .funcref()\n            .expect(\"expected funcref\")\n            .is_none(),\n        \"funcref should be null\"\n    );\n\n    Ok(())\n}\n\n#[test]\nfn table_zeroed() -> Result<()> {\n    if skip_pooling_allocator_tests() {\n        return Ok(());\n    }\n\n    let mut config = Config::new();\n    config.allocation_strategy(InstanceAllocationStrategy::Pooling {\n        strategy: PoolingAllocationStrategy::NextAvailable,\n        instance_limits: InstanceLimits {\n            count: 1,\n            memory_pages: 1,\n            table_elements: 10,\n            ..Default::default()\n        },\n    });\n    config.dynamic_memory_guard_size(0);\n    config.static_memory_guard_size(0);\n    config.static_memory_maximum_size(65536);\n\n    let engine = Engine::new(&config)?;\n\n    let module = Module::new(&engine, r#\"(module (table (export \"t\") 10 funcref))\"#)?;\n\n    // Instantiate the module repeatedly after filling table elements\n    for _ in 0..10 {\n        let mut store = Store::new(&engine, ());\n        let instance = Instance::new(&mut store, &module, &[])?;\n        let table = instance.get_table(&mut store, \"t\").unwrap();\n        let f = Func::wrap(&mut store, || {});\n\n        assert_eq!(table.size(&store), 10);\n\n        for i in 0..10 {\n            match table.get(&mut store, i).unwrap() {\n                Val::FuncRef(r) => assert!(r.is_none()),\n                _ => panic!(\"expected a funcref\"),\n            }\n            table\n                .set(&mut store, i, Val::FuncRef(Some(f.clone())))\n                .unwrap();\n        }\n    }\n\n    Ok(())\n}\n\n#[test]\nfn instantiation_limit() -> Result<()> {\n    const INSTANCE_LIMIT: u32 = 10;\n    let mut config = Config::new();\n    config.allocation_strategy(InstanceAllocationStrategy::Pooling {\n        strategy: PoolingAllocationStrategy::NextAvailable,\n        instance_limits: InstanceLimits {\n            count: INSTANCE_LIMIT,\n            memory_pages: 1,\n            table_elements: 10,\n            ..Default::default()\n        },\n    });\n    config.dynamic_memory_guard_size(0);\n    config.static_memory_guard_size(0);\n    config.static_memory_maximum_size(65536);\n\n    let engine = Engine::new(&config)?;\n    let module = Module::new(&engine, r#\"(module)\"#)?;\n\n    // Instantiate to the limit\n    {\n        let mut store = Store::new(&engine, ());\n\n        for _ in 0..INSTANCE_LIMIT {\n            Instance::new(&mut store, &module, &[])?;\n        }\n\n        match Instance::new(&mut store, &module, &[]) {\n            Ok(_) => panic!(\"instantiation should fail\"),\n            Err(e) => assert_eq!(\n                e.to_string(),\n                format!(\n                    \"Limit of {} concurrent instances has been reached\",\n                    INSTANCE_LIMIT\n                )\n            ),\n        }\n    }\n\n    // With the above store dropped, ensure instantiations can be made\n\n    let mut store = Store::new(&engine, ());\n\n    for _ in 0..INSTANCE_LIMIT {\n        Instance::new(&mut store, &module, &[])?;\n    }\n\n    Ok(())\n}\n\n#[test]\nfn preserve_data_segments() -> Result<()> {\n    let mut config = Config::new();\n    config.allocation_strategy(InstanceAllocationStrategy::Pooling {\n        strategy: PoolingAllocationStrategy::NextAvailable,\n        instance_limits: InstanceLimits {\n            count: 2,\n            memory_pages: 1,\n            table_elements: 10,\n            ..Default::default()\n        },\n    });\n    let engine = Engine::new(&config)?;\n    let m = Module::new(\n        &engine,\n        r#\"\n            (module\n                (memory (export \"mem\") 1 1)\n                (data (i32.const 0) \"foo\"))\n        \"#,\n    )?;\n    let mut store = Store::new(&engine, ());\n    let i = Instance::new(&mut store, &m, &[])?;\n\n    // Drop the module. This should *not* drop the actual data referenced by the\n    // module.\n    drop(m);\n\n    // Spray some stuff on the heap. If wasm data lived on the heap this should\n    // paper over things and help us catch use-after-free here if it would\n    // otherwise happen.\n    let mut strings = Vec::new();\n    for _ in 0..1000 {\n        let mut string = String::new();\n        for _ in 0..1000 {\n            string.push('g');\n        }\n        strings.push(string);\n    }\n    drop(strings);\n\n    let mem = i.get_memory(&mut store, \"mem\").unwrap();\n\n    // Hopefully it's still `foo`!\n    assert!(mem.data(&store).starts_with(b\"foo\"));\n\n    Ok(())\n}\n\n#[test]\nfn multi_memory_with_imported_memories() -> Result<()> {\n    // This test checks that the base address for the defined memory is correct for the instance\n    // despite the presence of an imported memory.\n\n    let mut config = Config::new();\n    config.allocation_strategy(InstanceAllocationStrategy::Pooling {\n        strategy: PoolingAllocationStrategy::NextAvailable,\n        instance_limits: InstanceLimits {\n            count: 1,\n            memories: 2,\n            memory_pages: 1,\n            ..Default::default()\n        },\n    });\n    config.wasm_multi_memory(true);\n\n    let engine = Engine::new(&config)?;\n    let module = Module::new(\n        &engine,\n        r#\"(module (import \"\" \"m1\" (memory 0)) (memory (export \"m2\") 1))\"#,\n    )?;\n\n    let mut store = Store::new(&engine, ());\n\n    let m1 = Memory::new(&mut store, MemoryType::new(0, None))?;\n    let instance = Instance::new(&mut store, &module, &[m1.into()])?;\n\n    let m2 = instance.get_memory(&mut store, \"m2\").unwrap();\n\n    m2.data_mut(&mut store)[0] = 0x42;\n    assert_eq!(m2.data(&store)[0], 0x42);\n\n    Ok(())\n}\n\n#[test]\nfn drop_externref_global_during_module_init() -> Result<()> {\n    struct Limiter;\n\n    impl ResourceLimiter for Limiter {\n        fn memory_growing(&mut self, _: usize, _: usize, _: Option<usize>) -> bool {\n            false\n        }\n\n        fn table_growing(&mut self, _: u32, _: u32, _: Option<u32>) -> bool {\n            false\n        }\n    }\n\n    let mut config = Config::new();\n    config.wasm_reference_types(true);\n    config.allocation_strategy(InstanceAllocationStrategy::Pooling {\n        strategy: PoolingAllocationStrategy::NextAvailable,\n        instance_limits: InstanceLimits {\n            count: 1,\n            ..Default::default()\n        },\n    });\n\n    let engine = Engine::new(&config)?;\n\n    let module = Module::new(\n        &engine,\n        r#\"\n            (module\n                (global i32 (i32.const 1))\n                (global i32 (i32.const 2))\n                (global i32 (i32.const 3))\n                (global i32 (i32.const 4))\n                (global i32 (i32.const 5))\n            )\n        \"#,\n    )?;\n\n    let mut store = Store::new(&engine, Limiter);\n    drop(Instance::new(&mut store, &module, &[])?);\n    drop(store);\n\n    let module = Module::new(\n        &engine,\n        r#\"\n            (module\n                (memory 1)\n                (global (mut externref) (ref.null extern))\n            )\n        \"#,\n    )?;\n\n    let mut store = Store::new(&engine, Limiter);\n    store.limiter(|s| s);\n    assert!(Instance::new(&mut store, &module, &[]).is_err());\n\n    Ok(())\n}\n\n#[test]\nfn switch_image_and_non_image() -> Result<()> {\n    let mut c = Config::new();\n    c.allocation_strategy(InstanceAllocationStrategy::Pooling {\n        instance_limits: InstanceLimits {\n            count: 1,\n            ..Default::default()\n        },\n        strategy: Default::default(),\n    });\n    let engine = Engine::new(&c)?;\n    let module1 = Module::new(\n        &engine,\n        r#\"\n            (module\n                (memory 1)\n                (func (export \"load\") (param i32) (result i32)\n                    local.get 0\n                    i32.load\n                )\n            )\n        \"#,\n    )?;\n    let module2 = Module::new(\n        &engine,\n        r#\"\n            (module\n                (memory (export \"memory\") 1)\n                (data (i32.const 0) \"1234\")\n            )\n        \"#,\n    )?;\n\n    let assert_zero = || -> Result<()> {\n        let mut store = Store::new(&engine, ());\n        let instance = Instance::new(&mut store, &module1, &[])?;\n        let func = instance.get_typed_func::<i32, i32, _>(&mut store, \"load\")?;\n        assert_eq!(func.call(&mut store, 0)?, 0);\n        Ok(())\n    };\n\n    // Initialize with a heap image and make sure the next instance, without an\n    // image, is zeroed\n    Instance::new(&mut Store::new(&engine, ()), &module2, &[])?;\n    assert_zero()?;\n\n    // ... transition back to heap image and do this again\n    Instance::new(&mut Store::new(&engine, ()), &module2, &[])?;\n    assert_zero()?;\n\n    // And go back to an image and make sure it's read/write on the host.\n    let mut store = Store::new(&engine, ());\n    let instance = Instance::new(&mut store, &module2, &[])?;\n    let memory = instance.get_memory(&mut store, \"memory\").unwrap();\n    let mem = memory.data_mut(&mut store);\n    assert!(mem.starts_with(b\"1234\"));\n    mem[..6].copy_from_slice(b\"567890\");\n\n    Ok(())\n}\n\n#[test]\n#[cfg(target_pointer_width = \"64\")]\nfn instance_too_large() -> Result<()> {\n    let mut config = Config::new();\n    config.allocation_strategy(InstanceAllocationStrategy::Pooling {\n        strategy: PoolingAllocationStrategy::NextAvailable,\n        instance_limits: InstanceLimits {\n            size: 16,\n            count: 1,\n            ..Default::default()\n        },\n    });\n\n    let engine = Engine::new(&config)?;\n    let expected = \"\\\ninstance allocation for this module requires 336 bytes which exceeds the \\\nconfigured maximum of 16 bytes; breakdown of allocation requirement:\n\n * 76.19% - 256 bytes - instance state management\n\";\n    match Module::new(&engine, \"(module)\") {\n        Ok(_) => panic!(\"should have failed to compile\"),\n        Err(e) => assert_eq!(e.to_string(), expected),\n    }\n\n    let mut lots_of_globals = format!(\"(module\");\n    for _ in 0..100 {\n        lots_of_globals.push_str(\"(global i32 i32.const 0)\\n\");\n    }\n    lots_of_globals.push_str(\")\");\n\n    let expected = \"\\\ninstance allocation for this module requires 1936 bytes which exceeds the \\\nconfigured maximum of 16 bytes; breakdown of allocation requirement:\n\n * 13.22% - 256 bytes - instance state management\n * 82.64% - 1600 bytes - defined globals\n\";\n    match Module::new(&engine, &lots_of_globals) {\n        Ok(_) => panic!(\"should have failed to compile\"),\n        Err(e) => assert_eq!(e.to_string(), expected),\n    }\n\n    Ok(())\n}\n"], "filenames": ["crates/runtime/src/instance/allocator/pooling.rs", "tests/all/pooling_allocator.rs"], "buggy_code_start_loc": [395, 618], "buggy_code_end_loc": [427, 618], "fixing_code_start_loc": [396, 619], "fixing_code_end_loc": [429, 680], "type": "CWE-212", "message": "Wasmtime is a standalone runtime for WebAssembly. Prior to version 2.0.2, there is a bug in Wasmtime's implementation of its pooling instance allocator where when a linear memory is reused for another instance the initial heap snapshot of the prior instance can be visible, erroneously to the next instance. This bug has been patched and users should upgrade to Wasmtime 2.0.2. Other mitigations include disabling the pooling allocator and disabling the `memory-init-cow`.", "other": {"cve": {"id": "CVE-2022-39393", "sourceIdentifier": "security-advisories@github.com", "published": "2022-11-10T20:15:11.520", "lastModified": "2022-11-17T16:01:15.650", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Wasmtime is a standalone runtime for WebAssembly. Prior to version 2.0.2, there is a bug in Wasmtime's implementation of its pooling instance allocator where when a linear memory is reused for another instance the initial heap snapshot of the prior instance can be visible, erroneously to the next instance. This bug has been patched and users should upgrade to Wasmtime 2.0.2. Other mitigations include disabling the pooling allocator and disabling the `memory-init-cow`."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 8.6, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 4.0}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 8.6, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 4.0}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-212"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-226"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:bytecodealliance:wasmtime:*:*:*:*:*:rust:*:*", "versionEndExcluding": "1.0.2", "matchCriteriaId": "DD102201-19F4-4CB7-828B-0B8A8A209919"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bytecodealliance:wasmtime:*:*:*:*:*:rust:*:*", "versionStartIncluding": "2.0.0", "versionEndExcluding": "2.0.2", "matchCriteriaId": "838C8442-0507-4DFD-B6B8-29462F63E721"}]}]}], "references": [{"url": "https://github.com/bytecodealliance/wasmtime/commit/2614f2e9d2d36805ead8a8da0fa0c6e0d9e428a0", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-wh6w-3828-g9qf", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/bytecodealliance/wasmtime/commit/2614f2e9d2d36805ead8a8da0fa0c6e0d9e428a0"}}