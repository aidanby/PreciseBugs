{"buggy_code": ["<?php\n/**\n * @link https://craftcms.com/\n * @copyright Copyright (c) Pixel & Tonic, Inc.\n * @license https://craftcms.github.io/license/\n */\n\nnamespace craft\\helpers;\n\nuse Craft;\nuse craft\\base\\Element;\nuse craft\\base\\ElementInterface;\nuse craft\\base\\FieldLayoutElement;\nuse craft\\behaviors\\DraftBehavior;\nuse craft\\elements\\Address;\nuse craft\\enums\\LicenseKeyStatus;\nuse craft\\events\\DefineElementInnerHtmlEvent;\nuse craft\\events\\RegisterCpAlertsEvent;\nuse craft\\fieldlayoutelements\\BaseField;\nuse craft\\models\\FieldLayout;\nuse craft\\models\\FieldLayoutTab;\nuse craft\\models\\Site;\nuse craft\\web\\twig\\TemplateLoaderException;\nuse craft\\web\\View;\nuse yii\\base\\Event;\nuse yii\\base\\InvalidArgumentException;\nuse yii\\helpers\\Markdown;\nuse yii\\validators\\RequiredValidator;\n\n/**\n * Class Cp\n *\n * @author Pixel & Tonic, Inc. <support@pixelandtonic.com>\n * @since 3.0.0\n */\nclass Cp\n{\n    /**\n     * @event RegisterCpAlertsEvent The event that is triggered when registering control panel alerts.\n     */\n    public const EVENT_REGISTER_ALERTS = 'registerAlerts';\n\n    /**\n     * @event DefineElementInnerHtmlEvent The event that is triggered when defining an element\u2019s inner HTML.\n     * @since 4.0.0\n     */\n    public const EVENT_DEFINE_ELEMENT_INNER_HTML = 'defineElementInnerHtml';\n\n    /**\n     * @since 3.5.8\n     */\n    public const ELEMENT_SIZE_SMALL = 'small';\n    /**\n     * @since 3.5.8\n     */\n    public const ELEMENT_SIZE_LARGE = 'large';\n\n    /**\n     * @var Site|false\n     * @see requestedSite()\n     */\n    private static Site|false $_requestedSite;\n\n    /**\n     * Renders a control panel template.\n     *\n     * @param string $template\n     * @param array $variables\n     * @return string\n     * @throws TemplateLoaderException if `$template` is an invalid template path\n     */\n    public static function renderTemplate(string $template, array $variables = []): string\n    {\n        return Craft::$app->getView()->renderTemplate($template, $variables, View::TEMPLATE_MODE_CP);\n    }\n\n    /**\n     * @param string|null $path\n     * @param bool $fetch\n     * @return array\n     */\n    public static function alerts(?string $path = null, bool $fetch = false): array\n    {\n        $alerts = [];\n        $user = Craft::$app->getUser()->getIdentity();\n        $generalConfig = Craft::$app->getConfig()->getGeneral();\n\n        if (!$user) {\n            return $alerts;\n        }\n\n        $updatesService = Craft::$app->getUpdates();\n        $canSettleUp = true;\n        $licenseAlerts = [];\n\n        if ($updatesService->getIsUpdateInfoCached() || $fetch) {\n            // Fetch the updates regardless of whether we're on the Updates page or not, because the other alerts are\n            // relying on cached Craftnet info\n            $updatesService->getUpdates();\n\n            // Get the license key status\n            $licenseKeyStatus = Craft::$app->getCache()->get('licenseKeyStatus');\n\n            if ($path !== 'plugin-store/upgrade-craft') {\n                // Invalid license?\n                if ($licenseKeyStatus === LicenseKeyStatus::Invalid) {\n                    $alerts[] = Craft::t('app', 'Your Craft license key is invalid.');\n                } elseif (Craft::$app->getHasWrongEdition()) {\n                    $message = Craft::t('app', 'You\u2019re running Craft {edition} with a Craft {licensedEdition} license.', [\n                            'edition' => Craft::$app->getEditionName(),\n                            'licensedEdition' => Craft::$app->getLicensedEditionName(),\n                        ]) . ' ';\n                    if ($user->admin) {\n                        if ($generalConfig->allowAdminChanges) {\n                            $message .= '<a class=\"go\" href=\"' . UrlHelper::url('plugin-store/upgrade-craft') . '\">' . Craft::t('app', 'Resolve') . '</a>';\n                        } else {\n                            $message .= Craft::t('app', 'Please fix on an environment where administrative changes are allowed.');\n                        }\n                    } else {\n                        $message .= Craft::t('app', 'Please notify one of your site\u2019s admins.');\n                    }\n\n                    $licenseAlerts[] = $message;\n                }\n            }\n\n            // Any plugin issues?\n            if ($path != 'settings/plugins') {\n                $pluginsService = Craft::$app->getPlugins();\n                $issuePlugins = [];\n                foreach ($pluginsService->getAllPlugins() as $pluginHandle => $plugin) {\n                    if ($pluginsService->hasIssues($pluginHandle)) {\n                        $issuePlugins[] = [$plugin->name, $plugin->handle];\n                    }\n                }\n                if (!empty($issuePlugins)) {\n                    if (count($issuePlugins) === 1) {\n                        $message = Craft::t('app', 'There\u2019s a licensing issue with the {name} plugin.', [\n                            'name' => reset($issuePlugins)[0],\n                        ]);\n                    } else {\n                        $message = Craft::t('app', '{num} plugins have licensing issues.', [\n                            'num' => count($issuePlugins),\n                        ]);\n                    }\n                    $message .= ' ';\n                    if ($user->admin) {\n                        if ($generalConfig->allowAdminChanges) {\n                            $message .= '<a class=\"go\" href=\"' . UrlHelper::cpUrl('settings/plugins') . '\">' . Craft::t('app', 'Resolve') . '</a>';\n                        } else {\n                            $message .= Craft::t('app', 'Please fix on an environment where administrative changes are allowed.');\n                        }\n                    } else {\n                        $message .= Craft::t('app', 'Please notify one of your site\u2019s admins.');\n                    }\n\n                    $licenseAlerts[] = $message;\n\n                    // Is this reconcilable?\n                    foreach ($issuePlugins as [$pluginName, $pluginHandle]) {\n                        if ($pluginsService->getPluginLicenseKeyStatus($pluginHandle) !== LicenseKeyStatus::Trial) {\n                            $canSettleUp = false;\n                            break;\n                        }\n                    }\n                }\n            }\n\n            if (!empty($licenseAlerts)) {\n                if ($canSettleUp) {\n                    if ($path !== 'plugin-store/buy-all-trials') {\n                        $alerts[] = Craft::t('app', 'There are trial licenses that require payment.') . ' ' .\n                            Html::a(Craft::t('app', 'Buy now'), UrlHelper::cpUrl('plugin-store/buy-all-trials'), ['class' => 'go']);\n                    }\n                } else {\n                    array_push($alerts, ...$licenseAlerts);\n                }\n            }\n\n            if (\n                $path !== 'utilities/updates' &&\n                $user->can('utility:updates') &&\n                $updatesService->getIsCriticalUpdateAvailable()\n            ) {\n                $alerts[] = Craft::t('app', 'A critical update is available.') .\n                    ' <a class=\"go nowrap\" href=\"' . UrlHelper::url('utilities/updates') . '\">' . Craft::t('app', 'Go to Updates') . '</a>';\n            }\n\n            // Domain mismatch?\n            if ($licenseKeyStatus === LicenseKeyStatus::Mismatched) {\n                $licensedDomain = Craft::$app->getCache()->get('licensedDomain');\n                $domainLink = '<a href=\"http://' . $licensedDomain . '\" rel=\"noopener\" target=\"_blank\">' . $licensedDomain . '</a>';\n\n                if (defined('CRAFT_LICENSE_KEY')) {\n                    $message = Craft::t('app', 'The license key in use belongs to {domain}', [\n                        'domain' => $domainLink,\n                    ]);\n                } else {\n                    $keyPath = Craft::$app->getPath()->getLicenseKeyPath();\n\n                    // If the license key path starts with the root project path, trim the project path off\n                    $rootPath = Craft::getAlias('@root');\n                    if (str_starts_with($keyPath, $rootPath . '/')) {\n                        $keyPath = substr($keyPath, strlen($rootPath) + 1);\n                    }\n\n                    $message = Craft::t('app', 'The license located at {file} belongs to {domain}.', [\n                        'file' => $keyPath,\n                        'domain' => $domainLink,\n                    ]);\n                }\n\n                $alerts[] = $message . ' <a class=\"go\" href=\"https://craftcms.com/support/resolving-mismatched-licenses\">' . Craft::t('app', 'Learn more') . '</a>';\n            }\n        }\n\n        // Display an alert if there are pending project config YAML changes\n        $projectConfig = Craft::$app->getProjectConfig();\n        if (\n            $path !== 'utilities/project-config' &&\n            $user->can('utility:project-config') &&\n            $projectConfig->areChangesPending() &&\n            ($projectConfig->writeYamlAutomatically || $projectConfig->get('dateModified') <= $projectConfig->get('dateModified', true))\n        ) {\n            $alerts[] = Craft::t('app', 'Your project config YAML files contain pending changes.') .\n                ' ' . '<a class=\"go\" href=\"' . UrlHelper::url('utilities/project-config') . '\">' . Craft::t('app', 'Review') . '</a>';\n        }\n\n        // Display a warning if admin changes are allowed, and project.yaml is being used but not writable\n        if (\n            $user->admin &&\n            $generalConfig->allowAdminChanges &&\n            $projectConfig->getHadFileWriteIssues()\n        ) {\n            $alerts[] = Craft::t('app', 'Your {folder} folder isn\u2019t writable.', [\n                'folder' => \"config/$projectConfig->folderName/\",\n            ]);\n        }\n\n        // Give plugins a chance to add their own alerts\n        $event = new RegisterCpAlertsEvent();\n        Event::trigger(self::class, self::EVENT_REGISTER_ALERTS, $event);\n        return array_merge($alerts, $event->alerts);\n    }\n\n    /**\n     * Renders an element\u2019s HTML.\n     *\n     * @param ElementInterface $element The element to be rendered\n     * @param string $context The context the element is going to be shown in (`index`, `field`, etc.)\n     * @param string $size The size of the element (`small` or `large`)\n     * @param string|null $inputName The `name` attribute that should be set on the hidden input, if `$context` is set to `field`\n     * @param bool $showStatus Whether the element status should be shown (if the element type has statuses)\n     * @param bool $showThumb Whether the element thumb should be shown (if the element has one)\n     * @param bool $showLabel Whether the element label should be shown\n     * @param bool $showDraftName Whether to show the draft name beside the label if the element is a draft of a published element\n     * @param bool $single Whether the input name should omit the trailing `[]`\n     * @param bool $autoReload Whether the element should auto-reload itself when it\u2019s saved\n     * @return string\n     * @since 3.5.8\n     */\n    public static function elementHtml(\n        ElementInterface $element,\n        string $context = 'index',\n        string $size = self::ELEMENT_SIZE_SMALL,\n        ?string $inputName = null,\n        bool $showStatus = true,\n        bool $showThumb = true,\n        bool $showLabel = true,\n        bool $showDraftName = true,\n        bool $single = false,\n        bool $autoReload = true,\n    ): string {\n        $isDraft = $element->getIsDraft();\n        $isRevision = !$isDraft && $element->getIsRevision();\n        $label = $element->getUiLabel();\n        $showStatus = $showStatus && ($isDraft || $element::hasStatuses());\n\n        // Create the thumb/icon image, if there is one\n        if ($showThumb) {\n            $thumbSizePx = $size === self::ELEMENT_SIZE_SMALL ? 34 : 120;\n            $thumbUrl = $element->getThumbUrl($thumbSizePx);\n        } else {\n            $thumbSizePx = $thumbUrl = null;\n        }\n\n        if ($thumbUrl !== null) {\n            $imageSize2x = $thumbSizePx * 2;\n            $thumbUrl2x = $element->getThumbUrl($imageSize2x);\n\n            $srcsets = [\n                \"$thumbUrl {$thumbSizePx}w\",\n                \"$thumbUrl2x {$imageSize2x}w\",\n            ];\n            $sizesHtml = \"{$thumbSizePx}px\";\n            $srcsetHtml = implode(', ', $srcsets);\n            $imgHtml = Html::tag('div', '', [\n                'class' => array_filter([\n                    'elementthumb',\n                    $element->getHasCheckeredThumb() ? 'checkered' : null,\n                    $size === self::ELEMENT_SIZE_SMALL && $element->getHasRoundedThumb() ? 'rounded' : null,\n                ]),\n                'data' => [\n                    'sizes' => $sizesHtml,\n                    'srcset' => $srcsetHtml,\n                    'alt' => $element->getThumbAlt(),\n                ],\n            ]);\n        } else {\n            $imgHtml = '';\n        }\n\n        $attributes = ArrayHelper::merge(\n            Html::normalizeTagAttributes($element->getHtmlAttributes($context)),\n            [\n                'class' => ['element', $size],\n                'title' => $label . (Craft::$app->getIsMultiSite() ? ' \u2013 ' . Craft::t('site', $element->getSite()->getName()) : ''),\n                'data' => array_filter([\n                    'type' => get_class($element),\n                    'id' => $element->id,\n                    'draft-id' => $element->draftId,\n                    'revision-id' => $element->revisionId,\n                    'site-id' => $element->siteId,\n                    'status' => $element->getStatus(),\n                    'label' => (string)$element,\n                    'url' => $element->getUrl(),\n                    'level' => $element->level,\n                    'settings' => $autoReload ? compact(\n                        'context',\n                        'size',\n                        'showStatus',\n                        'showThumb',\n                        'showLabel',\n                        'showDraftName',\n                    ) : false,\n                ]),\n            ]\n        );\n\n        if ($context === 'field') {\n            $attributes['class'][] = 'removable';\n        }\n\n        if ($element->hasErrors()) {\n            $attributes['class'][] = 'error';\n        }\n\n        if ($showStatus) {\n            $attributes['class'][] = 'hasstatus';\n        }\n\n        if ($thumbUrl !== null) {\n            $attributes['class'][] = 'hasthumb';\n        }\n\n        $user = Craft::$app->getUser()->getIdentity();\n\n        if ($user) {\n            if ($element->canView($user)) {\n                $attributes['data']['editable'] = true;\n            }\n\n            if ($context === 'index') {\n                if ($element->canSave($user)) {\n                    $attributes['data']['savable'] = true;\n                }\n\n                if ($element->canDelete($user)) {\n                    $attributes['data']['deletable'] = true;\n                }\n            }\n        }\n\n        if ($element->trashed) {\n            $attributes['data']['trashed'] = true;\n        }\n\n        $innerHtml = '';\n\n        if ($context === 'field' && $inputName !== null) {\n            $innerHtml .= Html::hiddenInput($inputName . ($single ? '' : '[]'), (string)$element->id) .\n                Html::button('', [\n                    'class' => ['delete', 'icon'],\n                    'title' => Craft::t('app', 'Remove'),\n                    'aria' => [\n                        'label' => Craft::t('app', 'Remove {label}', [\n                            'label' => $label,\n                        ]),\n                    ],\n                ]);\n        }\n\n        if ($showStatus) {\n            if ($isDraft) {\n                $innerHtml .= Html::tag('span', '', [\n                    'class' => ['icon'],\n                    'aria' => [\n                        'hidden' => 'true',\n                    ],\n                    'data' => [\n                        'icon' => 'draft',\n                    ],\n                ]);\n            } else {\n                $status = !$isRevision ? $element->getStatus() : null;\n                $innerHtml .= Html::tag('span', '', [\n                    'class' => array_filter([\n                        'status',\n                        $status,\n                        $status ? ($element::statuses()[$status]['color'] ?? null) : null,\n                    ]),\n                ]);\n            }\n        }\n\n        $innerHtml .= $imgHtml;\n\n        if ($showLabel) {\n            $innerHtml .= '<div class=\"label\">';\n            $innerHtml .= '<span class=\"title\">';\n\n            $encodedLabel = Html::encode($label);\n\n            if ($showDraftName && $isDraft && !$element->getIsUnpublishedDraft()) {\n                /** @var DraftBehavior|ElementInterface $element */\n                $encodedLabel .= Html::tag('span', $element->draftName ?: Craft::t('app', 'Draft'), [\n                    'class' => 'draft-label',\n                ]);\n            }\n\n            // Should we make the element a link?\n            if (\n                $context === 'index' &&\n                !$element->trashed &&\n                ($cpEditUrl = $element->getCpEditUrl())\n            ) {\n                $innerHtml .= Html::a($encodedLabel, $cpEditUrl);\n            } else {\n                $innerHtml .= $encodedLabel;\n            }\n\n            $innerHtml .= '</span></div>';\n        }\n\n        // Allow plugins to modify the inner HTML\n        $event = new DefineElementInnerHtmlEvent(compact(\n            'element',\n            'context',\n            'size',\n            'showStatus',\n            'showThumb',\n            'showLabel',\n            'showDraftName',\n            'innerHtml',\n        ));\n        Event::trigger(self::class, self::EVENT_DEFINE_ELEMENT_INNER_HTML, $event);\n\n        return Html::tag('div', $event->innerHtml, $attributes);\n    }\n\n    /**\n     * Returns element preview HTML, for a list of elements.\n     *\n     * @param ElementInterface[] $elements The elements\n     * @param string $size The size of the element (`small` or `large`)\n     * @param bool $showStatus Whether the element status should be shown (if the element type has statuses)\n     * @param bool $showThumb Whether the element thumb should be shown (if the element has one)\n     * @param bool $showLabel Whether the element label should be shown\n     * @param bool $showDraftName Whether to show the draft name beside the label if the element is a draft of a published element\n     * @return string\n     * @since 3.6.3\n     */\n    public static function elementPreviewHtml(\n        array $elements,\n        string $size = self::ELEMENT_SIZE_SMALL,\n        bool $showStatus = true,\n        bool $showThumb = true,\n        bool $showLabel = true,\n        bool $showDraftName = true,\n    ): string {\n        if (empty($elements)) {\n            return '';\n        }\n\n        $first = array_shift($elements);\n        $html = static::elementHtml($first, 'index', $size, null, $showStatus, $showThumb, $showLabel, $showDraftName);\n\n        if (!empty($elements)) {\n            $otherHtml = '';\n            foreach ($elements as $other) {\n                $otherHtml .= static::elementHtml($other, 'index', $size, null, $showStatus, $showThumb, $showLabel, $showDraftName);\n            }\n            $html .= Html::tag('span', '+' . Craft::$app->getFormatter()->asInteger(count($elements)), [\n                'title' => implode(', ', ArrayHelper::getColumn($elements, 'title')),\n                'class' => 'btn small',\n                'role' => 'button',\n                'onclick' => 'jQuery(this).replaceWith(' . Json::encode($otherHtml) . ')',\n            ]);\n        }\n\n        return $html;\n    }\n\n    /**\n     * Renders a field\u2019s HTML, for the given input HTML or a template.\n     *\n     * @param string $input The input HTML or template path. If passing a template path, it must begin with `template:`.\n     * @param array $config\n     * @return string\n     * @throws TemplateLoaderException if $input begins with `template:` and is followed by an invalid template path\n     * @throws InvalidArgumentException if `$config['siteId']` is invalid\n     * @since 3.5.8\n     */\n    public static function fieldHtml(string $input, array $config = []): string\n    {\n        $attribute = $config['attribute'] ?? $config['id'] ?? null;\n        $id = $config['id'] = $config['id'] ?? 'field' . mt_rand();\n        $labelId = $config['labelId'] ?? \"$id-label\";\n        $instructionsId = $config['instructionsId'] ?? \"$id-instructions\";\n        $tipId = $config['tipId'] ?? \"$id-tip\";\n        $warningId = $config['warningId'] ?? \"$id-warning\";\n        $errorsId = $config['errorsId'] ?? \"$id-errors\";\n        $statusId = $config['statusId'] ?? \"$id-status\";\n\n        $instructions = $config['instructions'] ?? null;\n        $tip = $config['tip'] ?? null;\n        $warning = $config['warning'] ?? null;\n        $errors = $config['errors'] ?? null;\n        $status = $config['status'] ?? null;\n\n        if (str_starts_with($input, 'template:')) {\n            // Set labelledBy and describedBy values in case the input template supports it\n            if (!isset($config['labelledBy'])) {\n                $config['labelledBy'] = $labelId;\n            }\n            if (!isset($config['describedBy'])) {\n                $descriptorIds = array_filter([\n                    $errors ? $errorsId : null,\n                    $status ? $statusId : null,\n                    $instructions ? $instructionsId : null,\n                    $tip ? $tipId : null,\n                    $warning ? $warningId : null,\n                ]);\n                $config['describedBy'] = $descriptorIds ? implode(' ', $descriptorIds) : null;\n            }\n\n            $input = static::renderTemplate(substr($input, 9), $config);\n        }\n\n        $fieldset = $config['fieldset'] ?? false;\n        $fieldId = $config['fieldId'] ?? \"$id-field\";\n        $label = $config['fieldLabel'] ?? $config['label'] ?? null;\n\n        if ($label === '__blank__') {\n            $label = null;\n        }\n\n        $siteId = Craft::$app->getIsMultiSite() && isset($config['siteId']) ? (int)$config['siteId'] : null;\n\n        if ($siteId) {\n            $site = Craft::$app->getSites()->getSiteById($siteId);\n            if (!$site) {\n                throw new InvalidArgumentException(\"Invalid site ID: $siteId\");\n            }\n        } else {\n            $site = null;\n        }\n\n        $required = (bool)($config['required'] ?? false);\n        $instructionsPosition = $config['instructionsPosition'] ?? 'before';\n        $orientation = $config['orientation'] ?? ($site ? $site->getLocale() : Craft::$app->getLocale())->getOrientation();\n        $translatable = Craft::$app->getIsMultiSite() ? ($config['translatable'] ?? ($site !== null)) : false;\n\n        $fieldClass = array_merge(array_filter([\n            'field',\n            ($config['first'] ?? false) ? 'first' : null,\n            $errors ? 'has-errors' : null,\n        ]), Html::explodeClass($config['fieldClass'] ?? []));\n\n        if (isset($config['attribute']) && ($currentUser = Craft::$app->getUser()->getIdentity())) {\n            $showAttribute = $currentUser->admin && $currentUser->getPreference('showFieldHandles');\n        } else {\n            $showAttribute = false;\n        }\n\n        $instructionsHtml = $instructions\n            ? Html::tag('div', preg_replace('/&amp;(\\w+);/', '&$1;', Markdown::process(Html::encodeInvalidTags($instructions), 'gfm-comment')), [\n                'id' => $instructionsId,\n                'class' => ['instructions'],\n            ])\n            : '';\n\n        $labelHtml = $label . (\n            $required\n                ? Html::tag('span', Craft::t('app', 'Required'), [\n                    'class' => ['visually-hidden'],\n                ]) .\n                Html::tag('span', '', [\n                    'class' => ['required'],\n                    'aria' => [\n                        'hidden' => 'true',\n                    ],\n                ])\n                : ''\n            );\n\n        $containerTag = $fieldset ? 'fieldset' : 'div';\n\n        return\n            Html::beginTag($containerTag, ArrayHelper::merge(\n                [\n                    'class' => $fieldClass,\n                    'id' => $fieldId,\n                    'data' => [\n                        'attribute' => $attribute,\n                    ],\n                ],\n                $config['fieldAttributes'] ?? []\n            )) .\n            (($label && $fieldset)\n                ? Html::tag('legend', $labelHtml, [\n                    'class' => ['visually-hidden'],\n                    'data' => [\n                        'label' => $label,\n                    ],\n                ])\n                : '') .\n            ($status\n                ? Html::beginTag('div', [\n                    'id' => $statusId,\n                    'class' => ['status-badge', $status[0]],\n                    'title' => $status[1],\n                ]) .\n                Html::tag('span', $status[1], [\n                    'class' => 'visually-hidden',\n                ]) .\n                Html::endTag('div')\n                : '') .\n            (($label || $showAttribute)\n                ? (\n                    Html::beginTag('div', ['class' => 'heading']) .\n                    ($config['headingPrefix'] ?? '') .\n                    ($label\n                        ? Html::tag($fieldset ? 'legend' : 'label', $labelHtml, ArrayHelper::merge([\n                            'id' => $labelId,\n                            'class' => $config['labelClass'] ?? null,\n                            'for' => !$fieldset ? $id : null,\n                            'aria' => [\n                                'hidden' => $fieldset ? 'true' : null,\n                            ],\n                        ], $config['labelAttributes'] ?? []))\n                        : '') .\n                    ($translatable\n                        ? Html::beginTag('div', [\n                            'class' => ['t9n-indicator'],\n                            'title' => $config['translationDescription'] ?? Craft::t('app', 'This field is translatable.'),\n                        ]) .\n                        Html::tag('span', '', [\n                            'data' => [\n                                'icon' => 'language',\n                            ],\n                            'aria' => [\n                                'hidden' => 'true',\n                            ],\n                        ]) .\n                        Html::tag('span', $config['translationDescription'] ?? Craft::t('app', 'This field is translatable.'), [\n                            'class' => 'visually-hidden',\n                        ]) .\n                        Html::endTag('div')\n                        : '') .\n                    ($showAttribute\n                        ? Html::tag('div', '', [\n                            'class' => ['flex-grow'],\n                        ]) . static::renderTemplate('_includes/forms/copytextbtn', [\n                            'id' => \"$id-attribute\",\n                            'class' => ['code', 'small', 'light'],\n                            'value' => $config['attribute'],\n                        ])\n                        : '') .\n                    ($config['headingSuffix'] ?? '') .\n                    Html::endTag('div')\n                )\n                : '') .\n            ($instructionsPosition === 'before' ? $instructionsHtml : '') .\n            Html::tag('div', $input, ArrayHelper::merge(\n                [\n                    'class' => array_filter([\n                        'input',\n                        $orientation,\n                        $errors ? 'errors' : null,\n                    ]),\n                ],\n                $config['inputContainerAttributes'] ?? []\n            )) .\n            ($instructionsPosition === 'after' ? $instructionsHtml : '') .\n            self::_noticeHtml($tipId, 'notice', Craft::t('app', 'Tip:'), $tip) .\n            self::_noticeHtml($warningId, 'warning', Craft::t('app', 'Warning:'), $warning) .\n            ($errors\n                ? static::renderTemplate('_includes/forms/errorList', [\n                    'id' => $errorsId,\n                    'errors' => $errors,\n                ])\n                : '') .\n            Html::endTag($containerTag);\n    }\n\n    /**\n     * Returns the HTML for a field tip/warning.\n     *\n     * @param string $id\n     * @param string $class\n     * @param string $label\n     * @param string|null $message\n     * @return string\n     */\n    private static function _noticeHtml(string $id, string $class, string $label, ?string $message): string\n    {\n        if (!$message) {\n            return '';\n        }\n\n        return\n            Html::beginTag('p', [\n                'id' => $id,\n                'class' => [$class, 'has-icon'],\n            ]) .\n            Html::tag('span', '', [\n                'class' => 'icon',\n                'aria' => [\n                    'hidden' => 'true',\n                ],\n            ]) .\n            Html::tag('span', \"$label \", [\n                'class' => 'visually-hidden',\n            ]) .\n            Html::tag('span', preg_replace('/&amp;(\\w+);/', '&$1;', Markdown::processParagraph(Html::encodeInvalidTags($message)))) .\n            Html::endTag('p');\n    }\n\n    /**\n     * Renders a checkbox field\u2019s HTML.\n     *\n     * Note that unlike the `checkboxField` macro in `_includes/forms.html`, you must set the checkbox label via\n     * `$config['checkboxLabel']`.\n     *\n     * @param array $config\n     * @return string\n     * @throws InvalidArgumentException if `$config['siteId']` is invalid\n     * @since 3.6.0\n     */\n    public static function checkboxFieldHtml(array $config): string\n    {\n        $config['id'] = $config['id'] ?? 'checkbox' . mt_rand();\n\n        $config['fieldClass'] = Html::explodeClass($config['fieldClass'] ?? []);\n        $config['fieldClass'][] = 'checkboxfield';\n        $config['instructionsPosition'] = $config['instructionsPosition'] ?? 'after';\n\n        // Don't pass along `label` since it's ambiguous\n        unset($config['label']);\n\n        return static::fieldHtml('template:_includes/forms/checkbox', $config);\n    }\n\n    /**\n     * Renders a checkbox select field\u2019s HTML.\n     *\n     * @param array $config\n     * @return string\n     * @throws InvalidArgumentException if `$config['siteId']` is invalid\n     * @since 3.6.0\n     */\n    public static function checkboxSelectFieldHtml(array $config): string\n    {\n        $config['id'] = $config['id'] ?? 'checkboxselect' . mt_rand();\n        $config['fieldset'] = true;\n        return static::fieldHtml('template:_includes/forms/checkboxSelect', $config);\n    }\n\n    /**\n     * Renders a color field\u2019s HTML.\n     *\n     * @param array $config\n     * @return string\n     * @throws InvalidArgumentException if `$config['siteId']` is invalid\n     * @since 3.6.0\n     */\n    public static function colorFieldHtml(array $config): string\n    {\n        $config['id'] = $config['id'] ?? 'color' . mt_rand();\n        $config['fieldset'] = true;\n        return static::fieldHtml('template:_includes/forms/color', $config);\n    }\n\n    /**\n     * Renders an editable table field\u2019s HTML.\n     *\n     * @param array $config\n     * @return string\n     * @throws InvalidArgumentException if `$config['siteId']` is invalid\n     * @since 3.6.0\n     */\n    public static function editableTableFieldHtml(array $config): string\n    {\n        $config['id'] = $config['id'] ?? 'editabletable' . mt_rand();\n        return static::fieldHtml('template:_includes/forms/editableTable', $config);\n    }\n\n    /**\n     * Renders a lightswitch input\u2019s HTML.\n     *\n     * @param array $config\n     * @return string\n     * @throws InvalidArgumentException if `$config['siteId']` is invalid\n     * @since 4.0.0\n     */\n    public static function lightswitchHtml(array $config): string\n    {\n        return static::renderTemplate('_includes/forms/lightswitch', $config);\n    }\n\n    /**\n     * Renders a lightswitch field\u2019s HTML.\n     *\n     * @param array $config\n     * @return string\n     * @throws InvalidArgumentException if `$config['siteId']` is invalid\n     * @since 3.6.0\n     */\n    public static function lightswitchFieldHtml(array $config): string\n    {\n        $config['id'] = $config['id'] ?? 'lightswitch' . mt_rand();\n\n        $config['fieldClass'] = Html::explodeClass($config['fieldClass'] ?? []);\n        $config['fieldClass'][] = 'lightswitch-field';\n\n        // Don't pass along `label` since it's ambiguous\n        $config['fieldLabel'] = $config['fieldLabel'] ?? $config['label'] ?? null;\n        unset($config['label']);\n\n        return static::fieldHtml('template:_includes/forms/lightswitch', $config);\n    }\n\n    /**\n     * Renders a select input.\n     *\n     * @param array $config\n     * @return string\n     * @since 3.6.0\n     */\n    public static function selectHtml(array $config): string\n    {\n        return static::renderTemplate('_includes/forms/select', $config);\n    }\n\n    /**\n     * Renders a select field\u2019s HTML.\n     *\n     * @param array $config\n     * @return string\n     * @throws InvalidArgumentException if `$config['siteId']` is invalid\n     * @since 3.6.0\n     */\n    public static function selectFieldHtml(array $config): string\n    {\n        $config['id'] = $config['id'] ?? 'select' . mt_rand();\n        return static::fieldHtml('template:_includes/forms/select', $config);\n    }\n\n    /**\n     * Renders a selectize input.\n     *\n     * @param array $config\n     * @return string\n     * @since 4.0.0\n     */\n    public static function selectizeHtml(array $config): string\n    {\n        return static::renderTemplate('_includes/forms/selectize', $config);\n    }\n\n    /**\n     * Renders a selectize field\u2019s HTML.\n     *\n     * @param array $config\n     * @return string\n     * @throws InvalidArgumentException if `$config['siteId']` is invalid\n     * @since 4.0.0\n     */\n    public static function selectizeFieldHtml(array $config): string\n    {\n        $config['id'] = $config['id'] ?? 'selectize' . mt_rand();\n        return static::fieldHtml('template:_includes/forms/selectize', $config);\n    }\n\n    /**\n     * Renders a multi-select input.\n     *\n     * @param array $config\n     * @return string\n     * @since 4.0.0\n     */\n    public static function multiSelectHtml(array $config): string\n    {\n        return static::renderTemplate('_includes/forms/multiselect', $config);\n    }\n\n    /**\n     * Renders a multi-select field\u2019s HTML.\n     *\n     * @param array $config\n     * @return string\n     * @throws InvalidArgumentException if `$config['siteId']` is invalid\n     * @since 4.0.0\n     */\n    public static function multiSelectFieldHtml(array $config): string\n    {\n        $config['id'] = $config['id'] ?? 'multiselect' . mt_rand();\n        return static::fieldHtml('template:_includes/forms/multiselect', $config);\n    }\n\n    /**\n     * Renders a text input\u2019s HTML.\n     *\n     * @param array $config\n     * @return string\n     * @throws InvalidArgumentException if `$config['siteId']` is invalid\n     * @since 4.0.0\n     */\n    public static function textHtml(array $config): string\n    {\n        return static::renderTemplate('_includes/forms/text', $config);\n    }\n\n    /**\n     * Renders a text field\u2019s HTML.\n     *\n     * @param array $config\n     * @return string\n     * @throws InvalidArgumentException if `$config['siteId']` is invalid\n     * @since 3.6.0\n     */\n    public static function textFieldHtml(array $config): string\n    {\n        $config['id'] = $config['id'] ?? 'text' . mt_rand();\n        return static::fieldHtml('template:_includes/forms/text', $config);\n    }\n\n    /**\n     * Renders a textarea input\u2019s HTML.\n     *\n     * @param array $config\n     * @return string\n     * @throws InvalidArgumentException if `$config['siteId']` is invalid\n     * @since 4.0.0\n     */\n    public static function textareaHtml(array $config): string\n    {\n        return static::renderTemplate('_includes/forms/textarea', $config);\n    }\n\n    /**\n     * Renders a textarea field\u2019s HTML.\n     *\n     * @param array $config\n     * @return string\n     * @throws InvalidArgumentException if `$config['siteId']` is invalid\n     * @since 3.6.0\n     */\n    public static function textareaFieldHtml(array $config): string\n    {\n        $config['id'] = $config['id'] ?? 'textarea' . mt_rand();\n        return static::fieldHtml('template:_includes/forms/textarea', $config);\n    }\n\n    /**\n     * Returns a date input\u2019s HTML.\n     *\n     * @param array $config\n     * @return string\n     * @throws InvalidArgumentException if `$config['siteId']` is invalid\n     * @since 4.0.0\n     */\n    public static function dateHtml(array $config): string\n    {\n        return static::renderTemplate('_includes/forms/date', $config);\n    }\n\n    /**\n     * Returns a date field\u2019s HTML.\n     *\n     * @param array $config\n     * @return string\n     * @throws InvalidArgumentException if `$config['siteId']` is invalid\n     * @since 4.0.0\n     */\n    public static function dateFieldHtml(array $config): string\n    {\n        $config['id'] = $config['id'] ?? 'date' . mt_rand();\n        return static::fieldHtml('template:_includes/forms/date', $config);\n    }\n\n    /**\n     * Returns a time input\u2019s HTML.\n     *\n     * @param array $config\n     * @return string\n     * @throws InvalidArgumentException if `$config['siteId']` is invalid\n     * @since 4.0.0\n     */\n    public static function timeHtml(array $config): string\n    {\n        return static::renderTemplate('_includes/forms/time', $config);\n    }\n\n    /**\n     * Returns a date field\u2019s HTML.\n     *\n     * @param array $config\n     * @return string\n     * @throws InvalidArgumentException if `$config['siteId']` is invalid\n     * @since 4.0.0\n     */\n    public static function timeFieldHtml(array $config): string\n    {\n        $config['id'] = $config['id'] ?? 'time' . mt_rand();\n        return static::fieldHtml('template:_includes/forms/time', $config);\n    }\n\n    /**\n     * Renders a date + time field\u2019s HTML.\n     *\n     * @param array $config\n     * @return string\n     * @throws InvalidArgumentException if `$config['siteId']` is invalid\n     * @since 3.7.0\n     */\n    public static function dateTimeFieldHtml(array $config): string\n    {\n        $config['id'] = $config['id'] ?? 'datetime' . mt_rand();\n        return static::fieldHtml('template:_includes/forms/datetime', $config);\n    }\n\n    /**\n     * Renders an element select input\u2019s HTML\n     *\n     * @param array $config\n     * @return string\n     * @throws InvalidArgumentException if `$config['siteId']` is invalid\n     * @since 4.0.0\n     */\n    public static function elementSelectHtml(array $config): string\n    {\n        return static::renderTemplate('_includes/forms/elementSelect', $config);\n    }\n\n    /**\n     * Renders an element select field\u2019s HTML.\n     *\n     * @param array $config\n     * @return string\n     * @throws InvalidArgumentException if `$config['siteId']` is invalid\n     * @since 3.7.0\n     */\n    public static function elementSelectFieldHtml(array $config): string\n    {\n        $config['id'] = $config['id'] ?? 'elementselect' . mt_rand();\n        return static::fieldHtml('template:_includes/forms/elementSelect', $config);\n    }\n\n    /**\n     * Renders an autosuggest field\u2019s HTML.\n     *\n     * @param array $config\n     * @return string\n     * @throws InvalidArgumentException if `$config['siteId']` is invalid\n     * @since 3.7.0\n     */\n    public static function autosuggestFieldHtml(array $config): string\n    {\n        $config['id'] = $config['id'] ?? 'autosuggest' . mt_rand();\n\n        // Suggest an environment variable / alias?\n        if ($config['suggestEnvVars'] ?? false) {\n            $value = $config['value'] ?? '';\n            if (!isset($config['tip']) && (!isset($value[0]) || !in_array($value[0], ['$', '@']))) {\n                if ($config['suggestAliases'] ?? false) {\n                    $config['tip'] = Craft::t('app', 'This can be set to an environment variable, or begin with an alias.');\n                } else {\n                    $config['tip'] = Craft::t('app', 'This can be set to an environment variable.');\n                }\n                $config['tip'] .= ' ' .\n                    Html::a(Craft::t('app', 'Learn more'), 'https://craftcms.com/docs/4.x/config/#environmental-configuration', [\n                        'class' => 'go',\n                    ]);\n            } elseif (\n                !isset($config['warning']) &&\n                ($value === '@web' || str_starts_with($value, '@web/')) &&\n                Craft::$app->getRequest()->isWebAliasSetDynamically\n            ) {\n                $config['warning'] = Craft::t('app', 'The `@web` alias is not recommended if it is determined automatically.');\n            }\n        }\n\n        return static::fieldHtml('template:_includes/forms/autosuggest', $config);\n    }\n\n    /**\n     * Renders address cards.\n     *\n     * @param Address[] $addresses\n     * @param array $config\n     * @return string\n     * @since 4.0.0\n     */\n    public static function addressCardsHtml(array $addresses, array $config = []): string\n    {\n        $config += [\n            'id' => sprintf('addresses%s', mt_rand()),\n            'ownerId' => null,\n            'maxAddresses' => null,\n        ];\n\n        $view = Craft::$app->getView();\n\n        $view->registerJsWithVars(fn($selector, $settings) => <<<JS\nnew Craft.AddressesInput($($selector), $settings);\nJS, [\n            sprintf('#%s', $view->namespaceInputId($config['id'])),\n            [\n                'ownerId' => $config['ownerId'],\n                'maxAddresses' => $config['maxAddresses'],\n            ],\n        ]);\n\n        return\n            Html::beginTag('ul', [\n                'id' => $config['id'],\n                'class' => 'address-cards',\n            ]) .\n            implode(\"\\n\", array_map(fn(Address $address) => static::addressCardHtml($address, $config), $addresses)) .\n            Html::beginTag('li') .\n            Html::beginTag('button', [\n                'type' => 'button',\n                'class' => ['btn', 'dashed', 'add', 'icon', 'address-cards__add-btn'],\n            ]) .\n            Html::tag('div', '', [\n                'class' => ['spinner', 'spinner-absolute'],\n            ]) .\n            Html::tag('div', Craft::t('app', 'Add an address'), [\n                'class' => 'label',\n            ]) .\n            Html::endTag('button') . // .add\n            Html::endTag('li') .\n            Html::endTag('ul'); // .address-cards\n    }\n\n    /**\n     * Renders an address card for an Addresses input.\n     *\n     * @param Address $address\n     * @param array $config\n     * @return string\n     * @since 4.0.0\n     */\n    public static function addressCardHtml(Address $address, array $config = []): string\n    {\n        $config += [\n            'name' => null,\n        ];\n\n        $label = $address->title;\n        $canDelete = $address->canDelete(Craft::$app->getUser()->getIdentity());\n        $actionMenuId = sprintf('address-card-action-menu-%s', mt_rand());\n\n        return\n            Html::beginTag('li', [\n                'class' => 'address-card',\n                'data' => [\n                    'id' => $address->id,\n                    'draftId' => $address->draftId,\n                ],\n            ]) .\n            ($config['name'] ? Html::hiddenInput(\"{$config['name']}[]\", (string)$address->id) : '') .\n            Html::beginTag('div', ['class' => 'address-card-header']) .\n            Html::tag('h2', $address->title, [\n                'class' => array_filter([\n                    'address-card-label',\n                    !$label ? 'hidden' : null,\n                ]),\n            ]) .\n            ($canDelete\n                ? Html::beginTag('div', [\n                    'class' => 'address-card-header-actions',\n                    'data' => [\n                        'wrapper' => true,\n                    ],\n                ]) .\n                Html::button('', [\n                    'class' => ['btn', 'menubtn'],\n                    'title' => Craft::t('app', 'Actions'),\n                    'aria' => [\n                        'controls' => $actionMenuId,\n                        'label' => sprintf('%s %s', $label ?? Craft::t('app', 'New Address'), Craft::t('app', 'Settings')),\n                    ],\n                    'data' => [\n                        'icon' => 'settings',\n                        'disclosure-trigger' => true,\n                    ],\n                ]) .\n                Html::beginTag('div', [\n                    'id' => $actionMenuId,\n                    'class' => ['menu', 'menu--disclosure'],\n                ]) .\n                Html::beginTag('ul', ['class' => 'padded']) .\n                Html::beginTag('li') .\n                Html::button(Craft::t('app', 'Edit'), [\n                    'class' => 'menu-option',\n                    'type' => 'button',\n                    'aria' => [\n                        'label' => Craft::t('app', 'Edit'),\n                    ],\n                    'data' => [\n                        'icon' => 'edit',\n                        'action' => 'edit',\n                    ],\n                ]) .\n                Html::endTag('li') .\n                Html::beginTag('li') .\n                Html::button(Craft::t('app', 'Delete'), [\n                    'class' => 'error menu-option',\n                    'type' => 'button',\n                    'aria' => [\n                        'label' => Craft::t('app', 'Delete'),\n                    ],\n                    'data' => [\n                        'icon' => 'remove',\n                        'action' => 'delete',\n                    ],\n                ]) .\n                Html::endTag('li') .\n                Html::endTag('ul') .\n                Html::endTag('div') . // .menu\n                Html::endTag('div') // .address-card-header-actions\n                : ''\n            ) .\n            Html::endTag('div') . // .address-card-header\n            Html::tag('div', Craft::$app->getAddresses()->formatAddress($address), [\n                'class' => 'address-card-body',\n            ]) .\n            Html::endTag('li'); // .address-card\n    }\n\n    /**\n     * Returns address fields\u2019 HTML (sans country) for a given address.\n     *\n     * @param Address $address\n     * @return string\n     * @since 4.0.0\n     */\n    public static function addressFieldsHtml(Address $address): string\n    {\n        $formatRepo = Craft::$app->getAddresses()->getAddressFormatRepository()->get($address->countryCode);\n\n        $requiredFields = [];\n        $scenario = $address->getScenario();\n        $address->setScenario(Element::SCENARIO_LIVE);\n        $activeValidators = $address->getActiveValidators();\n        $address->setScenario($scenario);\n\n        foreach ($activeValidators as $validator) {\n            if ($validator instanceof RequiredValidator) {\n                foreach ($validator->getAttributeNames() as $attr) {\n                    if ($validator->when === null || call_user_func($validator->when, $address, $attr)) {\n                        $requiredFields[$attr] = true;\n                    }\n                }\n            }\n        }\n\n        $visibleFields = array_flip(array_merge(\n                $formatRepo->getUsedFields(),\n                $formatRepo->getUsedSubdivisionFields(),\n            )) + $requiredFields;\n\n        return\n            static::textFieldHtml([\n                'label' => $address->getAttributeLabel('addressLine1'),\n                'id' => 'addressLine1',\n                'name' => 'addressLine1',\n                'value' => $address->addressLine1,\n                'required' => isset($requiredFields['addressLine1']),\n                'errors' => $address->getErrors('addressLine1'),\n            ]) .\n            static::textFieldHtml([\n                'label' => $address->getAttributeLabel('addressLine2'),\n                'id' => 'addressLine2',\n                'name' => 'addressLine2',\n                'value' => $address->addressLine2,\n                'required' => isset($requiredFields['addressLine2']),\n                'errors' => $address->getErrors('addressLine2'),\n            ]) .\n            self::_subdivisionField(\n                $address,\n                'administrativeArea',\n                isset($visibleFields['administrativeArea']),\n                isset($requiredFields['administrativeArea']),\n                [$address->countryCode],\n                true,\n            ) .\n            self::_subdivisionField(\n                $address,\n                'locality',\n                isset($visibleFields['locality']),\n                isset($requiredFields['locality']),\n                [$address->countryCode, $address->administrativeArea],\n                true,\n            ) .\n            self::_subdivisionField(\n                $address,\n                'dependentLocality',\n                isset($visibleFields['dependentLocality']),\n                isset($requiredFields['dependentLocality']),\n                [$address->countryCode, $address->administrativeArea, $address->locality],\n                false,\n            ) .\n            Html::beginTag('div', ['class' => 'flex-fields']) .\n            static::textFieldHtml([\n                'fieldClass' => array_filter([\n                    'width-50',\n                    !isset($visibleFields['postalCode']) ? 'hidden' : null,\n                ]),\n                'label' => $address->getAttributeLabel('postalCode'),\n                'id' => 'postalCode',\n                'name' => 'postalCode',\n                'value' => $address->postalCode,\n                'required' => isset($requiredFields['postalCode']),\n                'errors' => $address->getErrors('postalCode'),\n            ]) .\n            static::textFieldHtml([\n                'fieldClass' => array_filter([\n                    'width-50',\n                    !isset($visibleFields['sortingCode']) ? 'hidden' : null,\n                ]),\n                'label' => $address->getAttributeLabel('sortingCode'),\n                'id' => 'sortingCode',\n                'name' => 'sortingCode',\n                'value' => $address->sortingCode,\n                'required' => isset($requiredFields['sortingCode']),\n                'errors' => $address->getErrors('sortingCode'),\n            ]) .\n            Html::endTag('div'); // .flex-fields\n    }\n\n    private static function _subdivisionField(\n        Address $address,\n        string $name,\n        bool $visible,\n        bool $required,\n        ?array $parents,\n        bool $spinner,\n    ): string {\n        $value = $address->$name;\n        $options = Craft::$app->getAddresses()->getSubdivisionRepository()->getList($parents, Craft::$app->language);\n\n        if ($options) {\n            // Persist invalid values in the UI\n            if ($value && !isset($options[$value])) {\n                $options[$value] = $value;\n            }\n\n            if ($spinner) {\n                $errors = $address->getErrors($name);\n                $input =\n                    Html::beginTag('div', [\n                        'class' => ['flex', 'flex-nowrap'],\n                    ]) .\n                    static::selectizeHtml([\n                        'id' => $name,\n                        'name' => $name,\n                        'value' => $value,\n                        'options' => $options,\n                        'errors' => $errors,\n                    ]) .\n                    Html::tag('div', '', [\n                        'id' => \"$name-spinner\",\n                        'class' => ['spinner', 'hidden'],\n                    ]) .\n                    Html::endTag('div');\n\n                return static::fieldHtml($input, [\n                    'fieldClass' => !$visible ? 'hidden' : null,\n                    'label' => $address->getAttributeLabel($name),\n                    'id' => $name,\n                    'required' => $required,\n                    'errors' => $errors,\n                ]);\n            }\n\n            return static::selectizeFieldHtml([\n                'fieldClass' => !$visible ? 'hidden' : null,\n                'label' => $address->getAttributeLabel($name),\n                'id' => $name,\n                'name' => $name,\n                'value' => $value,\n                'options' => $options,\n                'required' => $required,\n                'errors' => $address->getErrors($name),\n            ]);\n        }\n\n        // No preconfigured subdivisions for the given parents, so just output a text input\n        return static::textFieldHtml([\n            'fieldClass' => !$visible ? 'hidden' : null,\n            'label' => $address->getAttributeLabel($name),\n            'id' => $name,\n            'name' => $name,\n            'value' => $value,\n            'required' => $required,\n            'errors' => $address->getErrors($name),\n        ]);\n    }\n\n    /**\n     * Renders a field layout designer.\n     *\n     * @param FieldLayout $fieldLayout\n     * @param array $config\n     * @return string\n     * @since 4.0.0\n     */\n    public static function fieldLayoutDesignerHtml(FieldLayout $fieldLayout, array $config = []): string\n    {\n        $config += [\n            'id' => 'fld' . mt_rand(),\n            'customizableTabs' => true,\n            'customizableUi' => true,\n        ];\n\n        $tabs = array_filter($fieldLayout->getTabs(), fn(FieldLayoutTab $tab) => !empty($tab->getElements()));\n\n        if (!$config['customizableTabs']) {\n            $tab = array_shift($tabs) ?? new FieldLayoutTab([\n                    'uid' => StringHelper::UUID(),\n                    'layout' => $fieldLayout,\n                ]);\n            $tab->name = $config['pretendTabName'] ?? Craft::t('app', 'Content');\n\n            // Any extra tabs?\n            if (!empty($tabs)) {\n                $elements = $tab->getElements();\n                foreach ($tabs as $extraTab) {\n                    array_push($elements, ...$extraTab->getElements());\n                }\n                $tab->setElements($elements);\n            }\n\n            $tabs = [$tab];\n        }\n\n        // Make sure all tabs and their elements have UUIDs\n        // (We do this here instead of from FieldLayoutComponent::init() because the we don't want field layout forms to\n        // get the impression that tabs/elements have persisting UUIDs if they don't.)\n        foreach ($tabs as $tab) {\n            if (!isset($tab->uid)) {\n                $tab->uid = StringHelper::UUID();\n            }\n\n            foreach ($tab->getElements() as $layoutElement) {\n                if (!isset($layoutElement->uid)) {\n                    $layoutElement->uid = StringHelper::UUID();\n                }\n            }\n        }\n\n        $view = Craft::$app->getView();\n        $jsSettings = Json::encode([\n            'customizableTabs' => $config['customizableTabs'],\n            'customizableUi' => $config['customizableUi'],\n        ]);\n        $namespacedId = $view->namespaceInputId($config['id']);\n\n        $js = <<<JS\nnew Craft.FieldLayoutDesigner(\"#$namespacedId\", $jsSettings);\nJS;\n        $view->registerJs($js);\n\n        $availableCustomFields = $fieldLayout->getAvailableCustomFields();\n        $availableNativeFields = $fieldLayout->getAvailableNativeFields();\n        $availableUiElements = $fieldLayout->getAvailableUiElements();\n\n        // Make sure everything has the field layout set properly\n        foreach ($availableCustomFields as $groupFields) {\n            self::_setLayoutOnElements($groupFields, $fieldLayout);\n        }\n        self::_setLayoutOnElements($availableNativeFields, $fieldLayout);\n        self::_setLayoutOnElements($availableUiElements, $fieldLayout);\n\n        // Don't call FieldLayout::getConfig() here because we want to include *all* tabs, not just non-empty ones\n        $fieldLayoutConfig = [\n            'uid' => $fieldLayout->uid,\n            'tabs' => array_map(fn(FieldLayoutTab $tab) => $tab->getConfig(), $tabs),\n        ];\n\n        if ($fieldLayout->id) {\n            $fieldLayoutConfig['id'] = $fieldLayout->id;\n        }\n\n        $newTabSettingsData = self::_fldTabSettingsData(new FieldLayoutTab([\n            'uid' => 'TAB_UID',\n            'name' => 'TAB_NAME',\n            'layout' => $fieldLayout,\n        ]));\n\n        return\n            Html::beginTag('div', [\n                'id' => $config['id'],\n                'class' => 'layoutdesigner',\n                'data' => [\n                    'new-tab-settings-namespace' => $newTabSettingsData['settings-namespace'],\n                    'new-tab-settings-html' => $newTabSettingsData['settings-html'],\n                    'new-tab-settings-js' => $newTabSettingsData['settings-js'],\n                ],\n            ]) .\n            Html::hiddenInput('fieldLayout', Json::encode($fieldLayoutConfig), [\n                'data' => ['config-input' => true],\n            ]) .\n            Html::beginTag('div', ['class' => 'fld-workspace']) .\n            Html::beginTag('div', ['class' => 'fld-tabs']) .\n            implode('', array_map(fn(FieldLayoutTab $tab) => self::_fldTabHtml($tab, $config['customizableTabs']), $tabs)) .\n            Html::endTag('div') . // .fld-tabs\n            ($config['customizableTabs']\n                ? Html::button(Craft::t('app', 'New Tab'), [\n                    'type' => 'button',\n                    'class' => ['fld-new-tab-btn', 'btn', 'add', 'icon'],\n                ])\n                : '') .\n            Html::endTag('div') . // .fld-workspace\n            Html::beginTag('div', ['class' => 'fld-sidebar']) .\n            ($config['customizableUi']\n                ? Html::beginTag('div', [\n                    'role' => 'listbox',\n                    'class' => ['btngroup', 'small', 'fullwidth'],\n                    'aria' => ['label' => Craft::t('app', 'Layout element types')],\n                    'tabindex' => '0',\n                ]) .\n                Html::button(Craft::t('app', 'Fields'), [\n                    'role' => 'option',\n                    'type' => 'button',\n                    'class' => ['btn', 'small', 'active'],\n                    'aria' => ['selected' => 'true'],\n                    'data' => ['library' => 'field'],\n                    'tabindex' => '-1',\n                ]) .\n                Html::button(Craft::t('app', 'UI Elements'), [\n                    'role' => 'option',\n                    'type' => 'button',\n                    'class' => ['btn', 'small'],\n                    'aria' => ['selected' => 'false'],\n                    'data' => ['library' => 'ui'],\n                    'tabindex' => '-1',\n                ]) .\n                Html::endTag('div') // .btngroup\n                : '') .\n            Html::beginTag('div', ['class' => 'fld-field-library']) .\n            Html::beginTag('div', ['class' => ['texticon', 'search', 'icon', 'clearable']]) .\n            static::textHtml([\n                'class' => 'fullwidth',\n                'inputmode' => 'search',\n                'placeholder' => Craft::t('app', 'Search'),\n            ]) .\n            Html::tag('div', '', [\n                'class' => ['clear', 'hidden'],\n                'title' => Craft::t('app', 'Clear'),\n                'aria' => ['label' => Craft::t('app', 'Clear')],\n            ]) .\n            Html::endTag('div') . // .texticon\n            self::_fldFieldSelectorsHtml(Craft::t('app', 'Native Fields'), $availableNativeFields, $fieldLayout) .\n            implode('', array_map(fn(string $groupName) => self::_fldFieldSelectorsHtml($groupName, $availableCustomFields[$groupName], $fieldLayout), array_keys($availableCustomFields))) .\n            Html::endTag('div') . // .fld-field-library\n            ($config['customizableUi']\n                ? Html::beginTag('div', ['class' => ['fld-ui-library', 'hidden']]) .\n                implode('', array_map(fn(FieldLayoutElement $element) => self::_fldElementSelectorHtml($element, true), $availableUiElements)) .\n                Html::endTag('div') // .fld-ui-library\n                : '') .\n            Html::endTag('div') . // .fld-sidebar\n            Html::endTag('div'); // .layoutdesigner\n    }\n\n    /**\n     * @param FieldLayoutElement[] $elements\n     * @param FieldLayout $fieldLayout\n     */\n    private static function _setLayoutOnElements(array $elements, FieldLayout $fieldLayout): void\n    {\n        foreach ($elements as $element) {\n            $element->setLayout($fieldLayout);\n        }\n    }\n\n    /**\n     * @param FieldLayoutTab $tab\n     * @param bool $customizable\n     * @return string\n     */\n    private static function _fldTabHtml(FieldLayoutTab $tab, bool $customizable): string\n    {\n        return\n            Html::beginTag('div', [\n                'class' => 'fld-tab',\n                'data' => array_merge([\n                    'uid' => $tab->uid,\n                ], self::_fldTabSettingsData($tab)),\n            ]) .\n            Html::beginTag('div', ['class' => 'tabs']) .\n            Html::beginTag('div', [\n                'class' => array_filter([\n                    'tab',\n                    'sel',\n                    $customizable ? 'draggable' : null,\n                ]),\n            ]) .\n            Html::tag('span', Html::encode($tab->name)) .\n            ($customizable\n                ? Html::a('', null, [\n                    'role' => 'button',\n                    'class' => ['settings', 'icon'],\n                    'title' => Craft::t('app', 'Edit'),\n                    'aria' => ['label' => Craft::t('app', 'Edit')],\n                ]) :\n                '') .\n            Html::endTag('div') . // .tab\n            Html::endTag('div') . // .tabs\n            Html::beginTag('div', ['class' => 'fld-tabcontent']) .\n            implode('', array_map(fn(FieldLayoutElement $element) => self::_fldElementSelectorHtml($element, false), $tab->getElements())) .\n            Html::endTag('div') . // .fld-tabcontent\n            Html::endTag('div'); // .fld-tab\n    }\n\n    /**\n     * @param FieldLayoutTab $tab\n     * @return array\n     */\n    private static function _fldTabSettingsData(FieldLayoutTab $tab): array\n    {\n        $view = Craft::$app->getView();\n        $oldNamespace = $view->getNamespace();\n        $namespace = $view->namespaceInputName(\"tab-$tab->uid\");\n        $view->setNamespace($namespace);\n        $view->startJsBuffer();\n        $settingsHtml = $view->namespaceInputs($tab->getSettingsHtml());\n        $settingsJs = $view->clearJsBuffer(false);\n        $view->setNamespace($oldNamespace);\n\n        return [\n            'settings-namespace' => $namespace,\n            'settings-html' => $settingsHtml,\n            'settings-js' => $settingsJs,\n        ];\n    }\n\n    /**\n     * @param FieldLayoutElement $element\n     * @param bool $forLibrary\n     * @param array $attr\n     * @return string\n     */\n    private static function _fldElementSelectorHtml(FieldLayoutElement $element, bool $forLibrary, array $attr = []): string\n    {\n        if ($element instanceof BaseField) {\n            $attr = ArrayHelper::merge($attr, [\n                'class' => !$forLibrary && $element->required ? ['fld-required'] : [],\n                'data' => [\n                    'keywords' => $forLibrary ? implode(' ', array_map('mb_strtolower', $element->keywords())) : false,\n                ],\n            ]);\n        }\n\n        $view = Craft::$app->getView();\n        $oldNamespace = $view->getNamespace();\n        $namespace = $view->namespaceInputName('element-' . ($forLibrary ? 'ELEMENT_UID' : $element->uid));\n        $view->setNamespace($namespace);\n        $view->startJsBuffer();\n        $settingsHtml = $view->namespaceInputs($element->getSettingsHtml());\n        $settingsJs = $view->clearJsBuffer(false);\n        $view->setNamespace($oldNamespace);\n\n        $attr = ArrayHelper::merge($attr, [\n            'class' => array_filter([\n                'fld-element',\n                $forLibrary ? 'unused' : null,\n                !$forLibrary && $element->hasConditions() ? 'has-conditions' : null,\n            ]),\n            'data' => [\n                'uid' => !$forLibrary ? $element->uid : false,\n                'config' => $forLibrary ? ['type' => get_class($element)] + $element->toArray() : false,\n                'has-custom-width' => $element->hasCustomWidth(),\n                'settings-namespace' => $namespace,\n                'settings-html' => $settingsHtml ?: false,\n                'settings-js' => $settingsJs ?: false,\n            ],\n        ]);\n\n        return Html::modifyTagAttributes($element->selectorHtml(), $attr);\n    }\n\n    /**\n     * @param string $groupName\n     * @param BaseField[] $groupFields\n     * @param FieldLayout $fieldLayout\n     * @return string\n     */\n    private static function _fldFieldSelectorsHtml(string $groupName, array $groupFields, FieldLayout $fieldLayout): string\n    {\n        $showGroup = ArrayHelper::contains($groupFields, fn(BaseField $field) => !$fieldLayout->isFieldIncluded($field->attribute()));\n\n        return\n            Html::beginTag('div', [\n                'class' => array_filter([\n                    'fld-field-group',\n                    $showGroup ? null : 'hidden',\n                ]),\n                'data' => ['name' => mb_strtolower($groupName)],\n            ]) .\n            Html::tag('h6', Html::encode($groupName)) .\n            implode('', array_map(fn(BaseField $field) => self::_fldElementSelectorHtml($field, true, [\n                'class' => array_filter([\n                    $fieldLayout->isFieldIncluded($field->attribute()) ? 'hidden' : null,\n                ]),\n            ]), $groupFields)) .\n            Html::endTag('div'); // .fld-field-group\n    }\n\n    /**\n     * Returns a metadata component\u2019s HTML.\n     *\n     * @param array $data The data, with keys representing the labels. The values can either be strings or callables.\n     * If a value is `false`, it will be omitted.\n     * @return string\n     */\n    public static function metadataHtml(array $data): string\n    {\n        $defs = [];\n\n        foreach ($data as $label => $value) {\n            if (is_callable($value)) {\n                $value = $value();\n            }\n            if ($value !== false) {\n                $defs[] =\n                    Html::beginTag('div', [\n                        'class' => 'data',\n                    ]) .\n                    Html::tag('dt', Html::encode($label), ['class' => 'heading']) . \"\\n\" .\n                    Html::tag('dd', $value, ['class' => 'value']) . \"\\n\" .\n                    Html::endTag('div');\n            }\n        }\n\n        if (empty($defs)) {\n            return '';\n        }\n\n        return Html::tag('dl', implode(\"\\n\", $defs), [\n            'class' => ['meta', 'read-only'],\n        ]);\n    }\n\n    /**\n     * Returns the site the control panel is currently working with, via a `site` query string param if sent.\n     *\n     * @return Site|null The site, or `null` if the user doesn\u2019t have permission to edit any sites.\n     * @since 4.0.0\n     */\n    public static function requestedSite(): ?Site\n    {\n        if (!isset(self::$_requestedSite)) {\n            $sitesService = Craft::$app->getSites();\n            $editableSiteIds = $sitesService->getEditableSiteIds();\n\n            if (!empty($editableSiteIds)) {\n                $request = Craft::$app->getRequest();\n                if (\n                    !$request->getIsConsoleRequest() &&\n                    ($handle = $request->getQueryParam('site')) !== null &&\n                    ($site = $sitesService->getSiteByHandle($handle, true)) !== null &&\n                    in_array($site->id, $editableSiteIds, false)\n                ) {\n                    self::$_requestedSite = $site;\n                } else {\n                    self::$_requestedSite = $sitesService->getCurrentSite();\n\n                    if (!in_array(self::$_requestedSite->id, $editableSiteIds, false)) {\n                        // Just go with the first editable site\n                        self::$_requestedSite = $sitesService->getSiteById($editableSiteIds[0]);\n                    }\n                }\n            } else {\n                self::$_requestedSite = false;\n            }\n        }\n\n        return self::$_requestedSite ?: null;\n    }\n}\n"], "fixing_code": ["<?php\n/**\n * @link https://craftcms.com/\n * @copyright Copyright (c) Pixel & Tonic, Inc.\n * @license https://craftcms.github.io/license/\n */\n\nnamespace craft\\helpers;\n\nuse Craft;\nuse craft\\base\\Element;\nuse craft\\base\\ElementInterface;\nuse craft\\base\\FieldLayoutElement;\nuse craft\\behaviors\\DraftBehavior;\nuse craft\\elements\\Address;\nuse craft\\enums\\LicenseKeyStatus;\nuse craft\\events\\DefineElementInnerHtmlEvent;\nuse craft\\events\\RegisterCpAlertsEvent;\nuse craft\\fieldlayoutelements\\BaseField;\nuse craft\\models\\FieldLayout;\nuse craft\\models\\FieldLayoutTab;\nuse craft\\models\\Site;\nuse craft\\web\\twig\\TemplateLoaderException;\nuse craft\\web\\View;\nuse yii\\base\\Event;\nuse yii\\base\\InvalidArgumentException;\nuse yii\\helpers\\Markdown;\nuse yii\\validators\\RequiredValidator;\n\n/**\n * Class Cp\n *\n * @author Pixel & Tonic, Inc. <support@pixelandtonic.com>\n * @since 3.0.0\n */\nclass Cp\n{\n    /**\n     * @event RegisterCpAlertsEvent The event that is triggered when registering control panel alerts.\n     */\n    public const EVENT_REGISTER_ALERTS = 'registerAlerts';\n\n    /**\n     * @event DefineElementInnerHtmlEvent The event that is triggered when defining an element\u2019s inner HTML.\n     * @since 4.0.0\n     */\n    public const EVENT_DEFINE_ELEMENT_INNER_HTML = 'defineElementInnerHtml';\n\n    /**\n     * @since 3.5.8\n     */\n    public const ELEMENT_SIZE_SMALL = 'small';\n    /**\n     * @since 3.5.8\n     */\n    public const ELEMENT_SIZE_LARGE = 'large';\n\n    /**\n     * @var Site|false\n     * @see requestedSite()\n     */\n    private static Site|false $_requestedSite;\n\n    /**\n     * Renders a control panel template.\n     *\n     * @param string $template\n     * @param array $variables\n     * @return string\n     * @throws TemplateLoaderException if `$template` is an invalid template path\n     */\n    public static function renderTemplate(string $template, array $variables = []): string\n    {\n        return Craft::$app->getView()->renderTemplate($template, $variables, View::TEMPLATE_MODE_CP);\n    }\n\n    /**\n     * @param string|null $path\n     * @param bool $fetch\n     * @return array\n     */\n    public static function alerts(?string $path = null, bool $fetch = false): array\n    {\n        $alerts = [];\n        $user = Craft::$app->getUser()->getIdentity();\n        $generalConfig = Craft::$app->getConfig()->getGeneral();\n\n        if (!$user) {\n            return $alerts;\n        }\n\n        $updatesService = Craft::$app->getUpdates();\n        $canSettleUp = true;\n        $licenseAlerts = [];\n\n        if ($updatesService->getIsUpdateInfoCached() || $fetch) {\n            // Fetch the updates regardless of whether we're on the Updates page or not, because the other alerts are\n            // relying on cached Craftnet info\n            $updatesService->getUpdates();\n\n            // Get the license key status\n            $licenseKeyStatus = Craft::$app->getCache()->get('licenseKeyStatus');\n\n            if ($path !== 'plugin-store/upgrade-craft') {\n                // Invalid license?\n                if ($licenseKeyStatus === LicenseKeyStatus::Invalid) {\n                    $alerts[] = Craft::t('app', 'Your Craft license key is invalid.');\n                } elseif (Craft::$app->getHasWrongEdition()) {\n                    $message = Craft::t('app', 'You\u2019re running Craft {edition} with a Craft {licensedEdition} license.', [\n                            'edition' => Craft::$app->getEditionName(),\n                            'licensedEdition' => Craft::$app->getLicensedEditionName(),\n                        ]) . ' ';\n                    if ($user->admin) {\n                        if ($generalConfig->allowAdminChanges) {\n                            $message .= '<a class=\"go\" href=\"' . UrlHelper::url('plugin-store/upgrade-craft') . '\">' . Craft::t('app', 'Resolve') . '</a>';\n                        } else {\n                            $message .= Craft::t('app', 'Please fix on an environment where administrative changes are allowed.');\n                        }\n                    } else {\n                        $message .= Craft::t('app', 'Please notify one of your site\u2019s admins.');\n                    }\n\n                    $licenseAlerts[] = $message;\n                }\n            }\n\n            // Any plugin issues?\n            if ($path != 'settings/plugins') {\n                $pluginsService = Craft::$app->getPlugins();\n                $issuePlugins = [];\n                foreach ($pluginsService->getAllPlugins() as $pluginHandle => $plugin) {\n                    if ($pluginsService->hasIssues($pluginHandle)) {\n                        $issuePlugins[] = [$plugin->name, $plugin->handle];\n                    }\n                }\n                if (!empty($issuePlugins)) {\n                    if (count($issuePlugins) === 1) {\n                        $message = Craft::t('app', 'There\u2019s a licensing issue with the {name} plugin.', [\n                            'name' => reset($issuePlugins)[0],\n                        ]);\n                    } else {\n                        $message = Craft::t('app', '{num} plugins have licensing issues.', [\n                            'num' => count($issuePlugins),\n                        ]);\n                    }\n                    $message .= ' ';\n                    if ($user->admin) {\n                        if ($generalConfig->allowAdminChanges) {\n                            $message .= '<a class=\"go\" href=\"' . UrlHelper::cpUrl('settings/plugins') . '\">' . Craft::t('app', 'Resolve') . '</a>';\n                        } else {\n                            $message .= Craft::t('app', 'Please fix on an environment where administrative changes are allowed.');\n                        }\n                    } else {\n                        $message .= Craft::t('app', 'Please notify one of your site\u2019s admins.');\n                    }\n\n                    $licenseAlerts[] = $message;\n\n                    // Is this reconcilable?\n                    foreach ($issuePlugins as [$pluginName, $pluginHandle]) {\n                        if ($pluginsService->getPluginLicenseKeyStatus($pluginHandle) !== LicenseKeyStatus::Trial) {\n                            $canSettleUp = false;\n                            break;\n                        }\n                    }\n                }\n            }\n\n            if (!empty($licenseAlerts)) {\n                if ($canSettleUp) {\n                    if ($path !== 'plugin-store/buy-all-trials') {\n                        $alerts[] = Craft::t('app', 'There are trial licenses that require payment.') . ' ' .\n                            Html::a(Craft::t('app', 'Buy now'), UrlHelper::cpUrl('plugin-store/buy-all-trials'), ['class' => 'go']);\n                    }\n                } else {\n                    array_push($alerts, ...$licenseAlerts);\n                }\n            }\n\n            if (\n                $path !== 'utilities/updates' &&\n                $user->can('utility:updates') &&\n                $updatesService->getIsCriticalUpdateAvailable()\n            ) {\n                $alerts[] = Craft::t('app', 'A critical update is available.') .\n                    ' <a class=\"go nowrap\" href=\"' . UrlHelper::url('utilities/updates') . '\">' . Craft::t('app', 'Go to Updates') . '</a>';\n            }\n\n            // Domain mismatch?\n            if ($licenseKeyStatus === LicenseKeyStatus::Mismatched) {\n                $licensedDomain = Craft::$app->getCache()->get('licensedDomain');\n                $domainLink = '<a href=\"http://' . $licensedDomain . '\" rel=\"noopener\" target=\"_blank\">' . $licensedDomain . '</a>';\n\n                if (defined('CRAFT_LICENSE_KEY')) {\n                    $message = Craft::t('app', 'The license key in use belongs to {domain}', [\n                        'domain' => $domainLink,\n                    ]);\n                } else {\n                    $keyPath = Craft::$app->getPath()->getLicenseKeyPath();\n\n                    // If the license key path starts with the root project path, trim the project path off\n                    $rootPath = Craft::getAlias('@root');\n                    if (str_starts_with($keyPath, $rootPath . '/')) {\n                        $keyPath = substr($keyPath, strlen($rootPath) + 1);\n                    }\n\n                    $message = Craft::t('app', 'The license located at {file} belongs to {domain}.', [\n                        'file' => $keyPath,\n                        'domain' => $domainLink,\n                    ]);\n                }\n\n                $alerts[] = $message . ' <a class=\"go\" href=\"https://craftcms.com/support/resolving-mismatched-licenses\">' . Craft::t('app', 'Learn more') . '</a>';\n            }\n        }\n\n        // Display an alert if there are pending project config YAML changes\n        $projectConfig = Craft::$app->getProjectConfig();\n        if (\n            $path !== 'utilities/project-config' &&\n            $user->can('utility:project-config') &&\n            $projectConfig->areChangesPending() &&\n            ($projectConfig->writeYamlAutomatically || $projectConfig->get('dateModified') <= $projectConfig->get('dateModified', true))\n        ) {\n            $alerts[] = Craft::t('app', 'Your project config YAML files contain pending changes.') .\n                ' ' . '<a class=\"go\" href=\"' . UrlHelper::url('utilities/project-config') . '\">' . Craft::t('app', 'Review') . '</a>';\n        }\n\n        // Display a warning if admin changes are allowed, and project.yaml is being used but not writable\n        if (\n            $user->admin &&\n            $generalConfig->allowAdminChanges &&\n            $projectConfig->getHadFileWriteIssues()\n        ) {\n            $alerts[] = Craft::t('app', 'Your {folder} folder isn\u2019t writable.', [\n                'folder' => \"config/$projectConfig->folderName/\",\n            ]);\n        }\n\n        // Give plugins a chance to add their own alerts\n        $event = new RegisterCpAlertsEvent();\n        Event::trigger(self::class, self::EVENT_REGISTER_ALERTS, $event);\n        return array_merge($alerts, $event->alerts);\n    }\n\n    /**\n     * Renders an element\u2019s HTML.\n     *\n     * @param ElementInterface $element The element to be rendered\n     * @param string $context The context the element is going to be shown in (`index`, `field`, etc.)\n     * @param string $size The size of the element (`small` or `large`)\n     * @param string|null $inputName The `name` attribute that should be set on the hidden input, if `$context` is set to `field`\n     * @param bool $showStatus Whether the element status should be shown (if the element type has statuses)\n     * @param bool $showThumb Whether the element thumb should be shown (if the element has one)\n     * @param bool $showLabel Whether the element label should be shown\n     * @param bool $showDraftName Whether to show the draft name beside the label if the element is a draft of a published element\n     * @param bool $single Whether the input name should omit the trailing `[]`\n     * @param bool $autoReload Whether the element should auto-reload itself when it\u2019s saved\n     * @return string\n     * @since 3.5.8\n     */\n    public static function elementHtml(\n        ElementInterface $element,\n        string $context = 'index',\n        string $size = self::ELEMENT_SIZE_SMALL,\n        ?string $inputName = null,\n        bool $showStatus = true,\n        bool $showThumb = true,\n        bool $showLabel = true,\n        bool $showDraftName = true,\n        bool $single = false,\n        bool $autoReload = true,\n    ): string {\n        $isDraft = $element->getIsDraft();\n        $isRevision = !$isDraft && $element->getIsRevision();\n        $label = $element->getUiLabel();\n        $showStatus = $showStatus && ($isDraft || $element::hasStatuses());\n\n        // Create the thumb/icon image, if there is one\n        if ($showThumb) {\n            $thumbSizePx = $size === self::ELEMENT_SIZE_SMALL ? 34 : 120;\n            $thumbUrl = $element->getThumbUrl($thumbSizePx);\n        } else {\n            $thumbSizePx = $thumbUrl = null;\n        }\n\n        if ($thumbUrl !== null) {\n            $imageSize2x = $thumbSizePx * 2;\n            $thumbUrl2x = $element->getThumbUrl($imageSize2x);\n\n            $srcsets = [\n                \"$thumbUrl {$thumbSizePx}w\",\n                \"$thumbUrl2x {$imageSize2x}w\",\n            ];\n            $sizesHtml = \"{$thumbSizePx}px\";\n            $srcsetHtml = implode(', ', $srcsets);\n            $imgHtml = Html::tag('div', '', [\n                'class' => array_filter([\n                    'elementthumb',\n                    $element->getHasCheckeredThumb() ? 'checkered' : null,\n                    $size === self::ELEMENT_SIZE_SMALL && $element->getHasRoundedThumb() ? 'rounded' : null,\n                ]),\n                'data' => [\n                    'sizes' => $sizesHtml,\n                    'srcset' => $srcsetHtml,\n                    'alt' => $element->getThumbAlt(),\n                ],\n            ]);\n        } else {\n            $imgHtml = '';\n        }\n\n        $attributes = ArrayHelper::merge(\n            Html::normalizeTagAttributes($element->getHtmlAttributes($context)),\n            [\n                'class' => ['element', $size],\n                'title' => $label . (Craft::$app->getIsMultiSite() ? ' \u2013 ' . Craft::t('site', $element->getSite()->getName()) : ''),\n                'data' => array_filter([\n                    'type' => get_class($element),\n                    'id' => $element->id,\n                    'draft-id' => $element->draftId,\n                    'revision-id' => $element->revisionId,\n                    'site-id' => $element->siteId,\n                    'status' => $element->getStatus(),\n                    'label' => (string)$element,\n                    'url' => $element->getUrl(),\n                    'level' => $element->level,\n                    'settings' => $autoReload ? compact(\n                        'context',\n                        'size',\n                        'showStatus',\n                        'showThumb',\n                        'showLabel',\n                        'showDraftName',\n                    ) : false,\n                ]),\n            ]\n        );\n\n        if ($context === 'field') {\n            $attributes['class'][] = 'removable';\n        }\n\n        if ($element->hasErrors()) {\n            $attributes['class'][] = 'error';\n        }\n\n        if ($showStatus) {\n            $attributes['class'][] = 'hasstatus';\n        }\n\n        if ($thumbUrl !== null) {\n            $attributes['class'][] = 'hasthumb';\n        }\n\n        $user = Craft::$app->getUser()->getIdentity();\n\n        if ($user) {\n            if ($element->canView($user)) {\n                $attributes['data']['editable'] = true;\n            }\n\n            if ($context === 'index') {\n                if ($element->canSave($user)) {\n                    $attributes['data']['savable'] = true;\n                }\n\n                if ($element->canDelete($user)) {\n                    $attributes['data']['deletable'] = true;\n                }\n            }\n        }\n\n        if ($element->trashed) {\n            $attributes['data']['trashed'] = true;\n        }\n\n        $innerHtml = '';\n\n        if ($context === 'field' && $inputName !== null) {\n            $innerHtml .= Html::hiddenInput($inputName . ($single ? '' : '[]'), (string)$element->id) .\n                Html::button('', [\n                    'class' => ['delete', 'icon'],\n                    'title' => Craft::t('app', 'Remove'),\n                    'aria' => [\n                        'label' => Craft::t('app', 'Remove {label}', [\n                            'label' => $label,\n                        ]),\n                    ],\n                ]);\n        }\n\n        if ($showStatus) {\n            if ($isDraft) {\n                $innerHtml .= Html::tag('span', '', [\n                    'class' => ['icon'],\n                    'aria' => [\n                        'hidden' => 'true',\n                    ],\n                    'data' => [\n                        'icon' => 'draft',\n                    ],\n                ]);\n            } else {\n                $status = !$isRevision ? $element->getStatus() : null;\n                $innerHtml .= Html::tag('span', '', [\n                    'class' => array_filter([\n                        'status',\n                        $status,\n                        $status ? ($element::statuses()[$status]['color'] ?? null) : null,\n                    ]),\n                ]);\n            }\n        }\n\n        $innerHtml .= $imgHtml;\n\n        if ($showLabel) {\n            $innerHtml .= '<div class=\"label\">';\n            $innerHtml .= '<span class=\"title\">';\n\n            $encodedLabel = Html::encode($label);\n\n            if ($showDraftName && $isDraft && !$element->getIsUnpublishedDraft()) {\n                /** @var DraftBehavior|ElementInterface $element */\n                $encodedLabel .= Html::tag('span', $element->draftName ?: Craft::t('app', 'Draft'), [\n                    'class' => 'draft-label',\n                ]);\n            }\n\n            // Should we make the element a link?\n            if (\n                $context === 'index' &&\n                !$element->trashed &&\n                ($cpEditUrl = $element->getCpEditUrl())\n            ) {\n                $innerHtml .= Html::a($encodedLabel, $cpEditUrl);\n            } else {\n                $innerHtml .= $encodedLabel;\n            }\n\n            $innerHtml .= '</span></div>';\n        }\n\n        // Allow plugins to modify the inner HTML\n        $event = new DefineElementInnerHtmlEvent(compact(\n            'element',\n            'context',\n            'size',\n            'showStatus',\n            'showThumb',\n            'showLabel',\n            'showDraftName',\n            'innerHtml',\n        ));\n        Event::trigger(self::class, self::EVENT_DEFINE_ELEMENT_INNER_HTML, $event);\n\n        return Html::tag('div', $event->innerHtml, $attributes);\n    }\n\n    /**\n     * Returns element preview HTML, for a list of elements.\n     *\n     * @param ElementInterface[] $elements The elements\n     * @param string $size The size of the element (`small` or `large`)\n     * @param bool $showStatus Whether the element status should be shown (if the element type has statuses)\n     * @param bool $showThumb Whether the element thumb should be shown (if the element has one)\n     * @param bool $showLabel Whether the element label should be shown\n     * @param bool $showDraftName Whether to show the draft name beside the label if the element is a draft of a published element\n     * @return string\n     * @since 3.6.3\n     */\n    public static function elementPreviewHtml(\n        array $elements,\n        string $size = self::ELEMENT_SIZE_SMALL,\n        bool $showStatus = true,\n        bool $showThumb = true,\n        bool $showLabel = true,\n        bool $showDraftName = true,\n    ): string {\n        if (empty($elements)) {\n            return '';\n        }\n\n        $first = array_shift($elements);\n        $html = static::elementHtml($first, 'index', $size, null, $showStatus, $showThumb, $showLabel, $showDraftName);\n\n        if (!empty($elements)) {\n            $otherHtml = '';\n            foreach ($elements as $other) {\n                $otherHtml .= static::elementHtml($other, 'index', $size, null, $showStatus, $showThumb, $showLabel, $showDraftName);\n            }\n            $html .= Html::tag('span', '+' . Craft::$app->getFormatter()->asInteger(count($elements)), [\n                'title' => implode(', ', ArrayHelper::getColumn($elements, 'title')),\n                'class' => 'btn small',\n                'role' => 'button',\n                'onclick' => 'jQuery(this).replaceWith(' . Json::encode($otherHtml) . ')',\n            ]);\n        }\n\n        return $html;\n    }\n\n    /**\n     * Renders a field\u2019s HTML, for the given input HTML or a template.\n     *\n     * @param string $input The input HTML or template path. If passing a template path, it must begin with `template:`.\n     * @param array $config\n     * @return string\n     * @throws TemplateLoaderException if $input begins with `template:` and is followed by an invalid template path\n     * @throws InvalidArgumentException if `$config['siteId']` is invalid\n     * @since 3.5.8\n     */\n    public static function fieldHtml(string $input, array $config = []): string\n    {\n        $attribute = $config['attribute'] ?? $config['id'] ?? null;\n        $id = $config['id'] = $config['id'] ?? 'field' . mt_rand();\n        $labelId = $config['labelId'] ?? \"$id-label\";\n        $instructionsId = $config['instructionsId'] ?? \"$id-instructions\";\n        $tipId = $config['tipId'] ?? \"$id-tip\";\n        $warningId = $config['warningId'] ?? \"$id-warning\";\n        $errorsId = $config['errorsId'] ?? \"$id-errors\";\n        $statusId = $config['statusId'] ?? \"$id-status\";\n\n        $instructions = $config['instructions'] ?? null;\n        $tip = $config['tip'] ?? null;\n        $warning = $config['warning'] ?? null;\n        $errors = $config['errors'] ?? null;\n        $status = $config['status'] ?? null;\n\n        if (str_starts_with($input, 'template:')) {\n            // Set labelledBy and describedBy values in case the input template supports it\n            if (!isset($config['labelledBy'])) {\n                $config['labelledBy'] = $labelId;\n            }\n            if (!isset($config['describedBy'])) {\n                $descriptorIds = array_filter([\n                    $errors ? $errorsId : null,\n                    $status ? $statusId : null,\n                    $instructions ? $instructionsId : null,\n                    $tip ? $tipId : null,\n                    $warning ? $warningId : null,\n                ]);\n                $config['describedBy'] = $descriptorIds ? implode(' ', $descriptorIds) : null;\n            }\n\n            $input = static::renderTemplate(substr($input, 9), $config);\n        }\n\n        $fieldset = $config['fieldset'] ?? false;\n        $fieldId = $config['fieldId'] ?? \"$id-field\";\n        $label = $config['fieldLabel'] ?? $config['label'] ?? null;\n\n        if ($label === '__blank__') {\n            $label = null;\n        }\n\n        $siteId = Craft::$app->getIsMultiSite() && isset($config['siteId']) ? (int)$config['siteId'] : null;\n\n        if ($siteId) {\n            $site = Craft::$app->getSites()->getSiteById($siteId);\n            if (!$site) {\n                throw new InvalidArgumentException(\"Invalid site ID: $siteId\");\n            }\n        } else {\n            $site = null;\n        }\n\n        $required = (bool)($config['required'] ?? false);\n        $instructionsPosition = $config['instructionsPosition'] ?? 'before';\n        $orientation = $config['orientation'] ?? ($site ? $site->getLocale() : Craft::$app->getLocale())->getOrientation();\n        $translatable = Craft::$app->getIsMultiSite() ? ($config['translatable'] ?? ($site !== null)) : false;\n\n        $fieldClass = array_merge(array_filter([\n            'field',\n            ($config['first'] ?? false) ? 'first' : null,\n            $errors ? 'has-errors' : null,\n        ]), Html::explodeClass($config['fieldClass'] ?? []));\n\n        if (isset($config['attribute']) && ($currentUser = Craft::$app->getUser()->getIdentity())) {\n            $showAttribute = $currentUser->admin && $currentUser->getPreference('showFieldHandles');\n        } else {\n            $showAttribute = false;\n        }\n\n        $instructionsHtml = $instructions\n            ? Html::tag('div', preg_replace('/&amp;(\\w+);/', '&$1;', Markdown::process(Html::encodeInvalidTags($instructions), 'gfm-comment')), [\n                'id' => $instructionsId,\n                'class' => ['instructions'],\n            ])\n            : '';\n\n        $labelHtml = $label . (\n            $required\n                ? Html::tag('span', Craft::t('app', 'Required'), [\n                    'class' => ['visually-hidden'],\n                ]) .\n                Html::tag('span', '', [\n                    'class' => ['required'],\n                    'aria' => [\n                        'hidden' => 'true',\n                    ],\n                ])\n                : ''\n            );\n\n        $containerTag = $fieldset ? 'fieldset' : 'div';\n\n        return\n            Html::beginTag($containerTag, ArrayHelper::merge(\n                [\n                    'class' => $fieldClass,\n                    'id' => $fieldId,\n                    'data' => [\n                        'attribute' => $attribute,\n                    ],\n                ],\n                $config['fieldAttributes'] ?? []\n            )) .\n            (($label && $fieldset)\n                ? Html::tag('legend', $labelHtml, [\n                    'class' => ['visually-hidden'],\n                    'data' => [\n                        'label' => $label,\n                    ],\n                ])\n                : '') .\n            ($status\n                ? Html::beginTag('div', [\n                    'id' => $statusId,\n                    'class' => ['status-badge', $status[0]],\n                    'title' => $status[1],\n                ]) .\n                Html::tag('span', $status[1], [\n                    'class' => 'visually-hidden',\n                ]) .\n                Html::endTag('div')\n                : '') .\n            (($label || $showAttribute)\n                ? (\n                    Html::beginTag('div', ['class' => 'heading']) .\n                    ($config['headingPrefix'] ?? '') .\n                    ($label\n                        ? Html::tag($fieldset ? 'legend' : 'label', $labelHtml, ArrayHelper::merge([\n                            'id' => $labelId,\n                            'class' => $config['labelClass'] ?? null,\n                            'for' => !$fieldset ? $id : null,\n                            'aria' => [\n                                'hidden' => $fieldset ? 'true' : null,\n                            ],\n                        ], $config['labelAttributes'] ?? []))\n                        : '') .\n                    ($translatable\n                        ? Html::beginTag('div', [\n                            'class' => ['t9n-indicator'],\n                            'title' => $config['translationDescription'] ?? Craft::t('app', 'This field is translatable.'),\n                        ]) .\n                        Html::tag('span', '', [\n                            'data' => [\n                                'icon' => 'language',\n                            ],\n                            'aria' => [\n                                'hidden' => 'true',\n                            ],\n                        ]) .\n                        Html::tag('span', $config['translationDescription'] ?? Craft::t('app', 'This field is translatable.'), [\n                            'class' => 'visually-hidden',\n                        ]) .\n                        Html::endTag('div')\n                        : '') .\n                    ($showAttribute\n                        ? Html::tag('div', '', [\n                            'class' => ['flex-grow'],\n                        ]) . static::renderTemplate('_includes/forms/copytextbtn', [\n                            'id' => \"$id-attribute\",\n                            'class' => ['code', 'small', 'light'],\n                            'value' => $config['attribute'],\n                        ])\n                        : '') .\n                    ($config['headingSuffix'] ?? '') .\n                    Html::endTag('div')\n                )\n                : '') .\n            ($instructionsPosition === 'before' ? $instructionsHtml : '') .\n            Html::tag('div', $input, ArrayHelper::merge(\n                [\n                    'class' => array_filter([\n                        'input',\n                        $orientation,\n                        $errors ? 'errors' : null,\n                    ]),\n                ],\n                $config['inputContainerAttributes'] ?? []\n            )) .\n            ($instructionsPosition === 'after' ? $instructionsHtml : '') .\n            self::_noticeHtml($tipId, 'notice', Craft::t('app', 'Tip:'), $tip) .\n            self::_noticeHtml($warningId, 'warning', Craft::t('app', 'Warning:'), $warning) .\n            ($errors\n                ? static::renderTemplate('_includes/forms/errorList', [\n                    'id' => $errorsId,\n                    'errors' => $errors,\n                ])\n                : '') .\n            Html::endTag($containerTag);\n    }\n\n    /**\n     * Returns the HTML for a field tip/warning.\n     *\n     * @param string $id\n     * @param string $class\n     * @param string $label\n     * @param string|null $message\n     * @return string\n     */\n    private static function _noticeHtml(string $id, string $class, string $label, ?string $message): string\n    {\n        if (!$message) {\n            return '';\n        }\n\n        return\n            Html::beginTag('p', [\n                'id' => $id,\n                'class' => [$class, 'has-icon'],\n            ]) .\n            Html::tag('span', '', [\n                'class' => 'icon',\n                'aria' => [\n                    'hidden' => 'true',\n                ],\n            ]) .\n            Html::tag('span', \"$label \", [\n                'class' => 'visually-hidden',\n            ]) .\n            Html::tag('span', preg_replace('/&amp;(\\w+);/', '&$1;', Markdown::processParagraph(Html::encodeInvalidTags($message)))) .\n            Html::endTag('p');\n    }\n\n    /**\n     * Renders a checkbox field\u2019s HTML.\n     *\n     * Note that unlike the `checkboxField` macro in `_includes/forms.html`, you must set the checkbox label via\n     * `$config['checkboxLabel']`.\n     *\n     * @param array $config\n     * @return string\n     * @throws InvalidArgumentException if `$config['siteId']` is invalid\n     * @since 3.6.0\n     */\n    public static function checkboxFieldHtml(array $config): string\n    {\n        $config['id'] = $config['id'] ?? 'checkbox' . mt_rand();\n\n        $config['fieldClass'] = Html::explodeClass($config['fieldClass'] ?? []);\n        $config['fieldClass'][] = 'checkboxfield';\n        $config['instructionsPosition'] = $config['instructionsPosition'] ?? 'after';\n\n        // Don't pass along `label` since it's ambiguous\n        unset($config['label']);\n\n        return static::fieldHtml('template:_includes/forms/checkbox', $config);\n    }\n\n    /**\n     * Renders a checkbox select field\u2019s HTML.\n     *\n     * @param array $config\n     * @return string\n     * @throws InvalidArgumentException if `$config['siteId']` is invalid\n     * @since 3.6.0\n     */\n    public static function checkboxSelectFieldHtml(array $config): string\n    {\n        $config['id'] = $config['id'] ?? 'checkboxselect' . mt_rand();\n        $config['fieldset'] = true;\n        return static::fieldHtml('template:_includes/forms/checkboxSelect', $config);\n    }\n\n    /**\n     * Renders a color field\u2019s HTML.\n     *\n     * @param array $config\n     * @return string\n     * @throws InvalidArgumentException if `$config['siteId']` is invalid\n     * @since 3.6.0\n     */\n    public static function colorFieldHtml(array $config): string\n    {\n        $config['id'] = $config['id'] ?? 'color' . mt_rand();\n        $config['fieldset'] = true;\n        return static::fieldHtml('template:_includes/forms/color', $config);\n    }\n\n    /**\n     * Renders an editable table field\u2019s HTML.\n     *\n     * @param array $config\n     * @return string\n     * @throws InvalidArgumentException if `$config['siteId']` is invalid\n     * @since 3.6.0\n     */\n    public static function editableTableFieldHtml(array $config): string\n    {\n        $config['id'] = $config['id'] ?? 'editabletable' . mt_rand();\n        return static::fieldHtml('template:_includes/forms/editableTable', $config);\n    }\n\n    /**\n     * Renders a lightswitch input\u2019s HTML.\n     *\n     * @param array $config\n     * @return string\n     * @throws InvalidArgumentException if `$config['siteId']` is invalid\n     * @since 4.0.0\n     */\n    public static function lightswitchHtml(array $config): string\n    {\n        return static::renderTemplate('_includes/forms/lightswitch', $config);\n    }\n\n    /**\n     * Renders a lightswitch field\u2019s HTML.\n     *\n     * @param array $config\n     * @return string\n     * @throws InvalidArgumentException if `$config['siteId']` is invalid\n     * @since 3.6.0\n     */\n    public static function lightswitchFieldHtml(array $config): string\n    {\n        $config['id'] = $config['id'] ?? 'lightswitch' . mt_rand();\n\n        $config['fieldClass'] = Html::explodeClass($config['fieldClass'] ?? []);\n        $config['fieldClass'][] = 'lightswitch-field';\n\n        // Don't pass along `label` since it's ambiguous\n        $config['fieldLabel'] = $config['fieldLabel'] ?? $config['label'] ?? null;\n        unset($config['label']);\n\n        return static::fieldHtml('template:_includes/forms/lightswitch', $config);\n    }\n\n    /**\n     * Renders a select input.\n     *\n     * @param array $config\n     * @return string\n     * @since 3.6.0\n     */\n    public static function selectHtml(array $config): string\n    {\n        return static::renderTemplate('_includes/forms/select', $config);\n    }\n\n    /**\n     * Renders a select field\u2019s HTML.\n     *\n     * @param array $config\n     * @return string\n     * @throws InvalidArgumentException if `$config['siteId']` is invalid\n     * @since 3.6.0\n     */\n    public static function selectFieldHtml(array $config): string\n    {\n        $config['id'] = $config['id'] ?? 'select' . mt_rand();\n        return static::fieldHtml('template:_includes/forms/select', $config);\n    }\n\n    /**\n     * Renders a selectize input.\n     *\n     * @param array $config\n     * @return string\n     * @since 4.0.0\n     */\n    public static function selectizeHtml(array $config): string\n    {\n        return static::renderTemplate('_includes/forms/selectize', $config);\n    }\n\n    /**\n     * Renders a selectize field\u2019s HTML.\n     *\n     * @param array $config\n     * @return string\n     * @throws InvalidArgumentException if `$config['siteId']` is invalid\n     * @since 4.0.0\n     */\n    public static function selectizeFieldHtml(array $config): string\n    {\n        $config['id'] = $config['id'] ?? 'selectize' . mt_rand();\n        return static::fieldHtml('template:_includes/forms/selectize', $config);\n    }\n\n    /**\n     * Renders a multi-select input.\n     *\n     * @param array $config\n     * @return string\n     * @since 4.0.0\n     */\n    public static function multiSelectHtml(array $config): string\n    {\n        return static::renderTemplate('_includes/forms/multiselect', $config);\n    }\n\n    /**\n     * Renders a multi-select field\u2019s HTML.\n     *\n     * @param array $config\n     * @return string\n     * @throws InvalidArgumentException if `$config['siteId']` is invalid\n     * @since 4.0.0\n     */\n    public static function multiSelectFieldHtml(array $config): string\n    {\n        $config['id'] = $config['id'] ?? 'multiselect' . mt_rand();\n        return static::fieldHtml('template:_includes/forms/multiselect', $config);\n    }\n\n    /**\n     * Renders a text input\u2019s HTML.\n     *\n     * @param array $config\n     * @return string\n     * @throws InvalidArgumentException if `$config['siteId']` is invalid\n     * @since 4.0.0\n     */\n    public static function textHtml(array $config): string\n    {\n        return static::renderTemplate('_includes/forms/text', $config);\n    }\n\n    /**\n     * Renders a text field\u2019s HTML.\n     *\n     * @param array $config\n     * @return string\n     * @throws InvalidArgumentException if `$config['siteId']` is invalid\n     * @since 3.6.0\n     */\n    public static function textFieldHtml(array $config): string\n    {\n        $config['id'] = $config['id'] ?? 'text' . mt_rand();\n        return static::fieldHtml('template:_includes/forms/text', $config);\n    }\n\n    /**\n     * Renders a textarea input\u2019s HTML.\n     *\n     * @param array $config\n     * @return string\n     * @throws InvalidArgumentException if `$config['siteId']` is invalid\n     * @since 4.0.0\n     */\n    public static function textareaHtml(array $config): string\n    {\n        return static::renderTemplate('_includes/forms/textarea', $config);\n    }\n\n    /**\n     * Renders a textarea field\u2019s HTML.\n     *\n     * @param array $config\n     * @return string\n     * @throws InvalidArgumentException if `$config['siteId']` is invalid\n     * @since 3.6.0\n     */\n    public static function textareaFieldHtml(array $config): string\n    {\n        $config['id'] = $config['id'] ?? 'textarea' . mt_rand();\n        return static::fieldHtml('template:_includes/forms/textarea', $config);\n    }\n\n    /**\n     * Returns a date input\u2019s HTML.\n     *\n     * @param array $config\n     * @return string\n     * @throws InvalidArgumentException if `$config['siteId']` is invalid\n     * @since 4.0.0\n     */\n    public static function dateHtml(array $config): string\n    {\n        return static::renderTemplate('_includes/forms/date', $config);\n    }\n\n    /**\n     * Returns a date field\u2019s HTML.\n     *\n     * @param array $config\n     * @return string\n     * @throws InvalidArgumentException if `$config['siteId']` is invalid\n     * @since 4.0.0\n     */\n    public static function dateFieldHtml(array $config): string\n    {\n        $config['id'] = $config['id'] ?? 'date' . mt_rand();\n        return static::fieldHtml('template:_includes/forms/date', $config);\n    }\n\n    /**\n     * Returns a time input\u2019s HTML.\n     *\n     * @param array $config\n     * @return string\n     * @throws InvalidArgumentException if `$config['siteId']` is invalid\n     * @since 4.0.0\n     */\n    public static function timeHtml(array $config): string\n    {\n        return static::renderTemplate('_includes/forms/time', $config);\n    }\n\n    /**\n     * Returns a date field\u2019s HTML.\n     *\n     * @param array $config\n     * @return string\n     * @throws InvalidArgumentException if `$config['siteId']` is invalid\n     * @since 4.0.0\n     */\n    public static function timeFieldHtml(array $config): string\n    {\n        $config['id'] = $config['id'] ?? 'time' . mt_rand();\n        return static::fieldHtml('template:_includes/forms/time', $config);\n    }\n\n    /**\n     * Renders a date + time field\u2019s HTML.\n     *\n     * @param array $config\n     * @return string\n     * @throws InvalidArgumentException if `$config['siteId']` is invalid\n     * @since 3.7.0\n     */\n    public static function dateTimeFieldHtml(array $config): string\n    {\n        $config['id'] = $config['id'] ?? 'datetime' . mt_rand();\n        return static::fieldHtml('template:_includes/forms/datetime', $config);\n    }\n\n    /**\n     * Renders an element select input\u2019s HTML\n     *\n     * @param array $config\n     * @return string\n     * @throws InvalidArgumentException if `$config['siteId']` is invalid\n     * @since 4.0.0\n     */\n    public static function elementSelectHtml(array $config): string\n    {\n        return static::renderTemplate('_includes/forms/elementSelect', $config);\n    }\n\n    /**\n     * Renders an element select field\u2019s HTML.\n     *\n     * @param array $config\n     * @return string\n     * @throws InvalidArgumentException if `$config['siteId']` is invalid\n     * @since 3.7.0\n     */\n    public static function elementSelectFieldHtml(array $config): string\n    {\n        $config['id'] = $config['id'] ?? 'elementselect' . mt_rand();\n        return static::fieldHtml('template:_includes/forms/elementSelect', $config);\n    }\n\n    /**\n     * Renders an autosuggest field\u2019s HTML.\n     *\n     * @param array $config\n     * @return string\n     * @throws InvalidArgumentException if `$config['siteId']` is invalid\n     * @since 3.7.0\n     */\n    public static function autosuggestFieldHtml(array $config): string\n    {\n        $config['id'] = $config['id'] ?? 'autosuggest' . mt_rand();\n\n        // Suggest an environment variable / alias?\n        if ($config['suggestEnvVars'] ?? false) {\n            $value = $config['value'] ?? '';\n            if (!isset($config['tip']) && (!isset($value[0]) || !in_array($value[0], ['$', '@']))) {\n                if ($config['suggestAliases'] ?? false) {\n                    $config['tip'] = Craft::t('app', 'This can be set to an environment variable, or begin with an alias.');\n                } else {\n                    $config['tip'] = Craft::t('app', 'This can be set to an environment variable.');\n                }\n                $config['tip'] .= ' ' .\n                    Html::a(Craft::t('app', 'Learn more'), 'https://craftcms.com/docs/4.x/config/#environmental-configuration', [\n                        'class' => 'go',\n                    ]);\n            } elseif (\n                !isset($config['warning']) &&\n                ($value === '@web' || str_starts_with($value, '@web/')) &&\n                Craft::$app->getRequest()->isWebAliasSetDynamically\n            ) {\n                $config['warning'] = Craft::t('app', 'The `@web` alias is not recommended if it is determined automatically.');\n            }\n        }\n\n        return static::fieldHtml('template:_includes/forms/autosuggest', $config);\n    }\n\n    /**\n     * Renders address cards.\n     *\n     * @param Address[] $addresses\n     * @param array $config\n     * @return string\n     * @since 4.0.0\n     */\n    public static function addressCardsHtml(array $addresses, array $config = []): string\n    {\n        $config += [\n            'id' => sprintf('addresses%s', mt_rand()),\n            'ownerId' => null,\n            'maxAddresses' => null,\n        ];\n\n        $view = Craft::$app->getView();\n\n        $view->registerJsWithVars(fn($selector, $settings) => <<<JS\nnew Craft.AddressesInput($($selector), $settings);\nJS, [\n            sprintf('#%s', $view->namespaceInputId($config['id'])),\n            [\n                'ownerId' => $config['ownerId'],\n                'maxAddresses' => $config['maxAddresses'],\n            ],\n        ]);\n\n        return\n            Html::beginTag('ul', [\n                'id' => $config['id'],\n                'class' => 'address-cards',\n            ]) .\n            implode(\"\\n\", array_map(fn(Address $address) => static::addressCardHtml($address, $config), $addresses)) .\n            Html::beginTag('li') .\n            Html::beginTag('button', [\n                'type' => 'button',\n                'class' => ['btn', 'dashed', 'add', 'icon', 'address-cards__add-btn'],\n            ]) .\n            Html::tag('div', '', [\n                'class' => ['spinner', 'spinner-absolute'],\n            ]) .\n            Html::tag('div', Craft::t('app', 'Add an address'), [\n                'class' => 'label',\n            ]) .\n            Html::endTag('button') . // .add\n            Html::endTag('li') .\n            Html::endTag('ul'); // .address-cards\n    }\n\n    /**\n     * Renders an address card for an Addresses input.\n     *\n     * @param Address $address\n     * @param array $config\n     * @return string\n     * @since 4.0.0\n     */\n    public static function addressCardHtml(Address $address, array $config = []): string\n    {\n        $config += [\n            'name' => null,\n        ];\n\n        $canDelete = $address->canDelete(Craft::$app->getUser()->getIdentity());\n        $actionMenuId = sprintf('address-card-action-menu-%s', mt_rand());\n\n        return\n            Html::beginTag('li', [\n                'class' => 'address-card',\n                'data' => [\n                    'id' => $address->id,\n                    'draftId' => $address->draftId,\n                ],\n            ]) .\n            ($config['name'] ? Html::hiddenInput(\"{$config['name']}[]\", (string)$address->id) : '') .\n            Html::beginTag('div', ['class' => 'address-card-header']) .\n            Html::tag('h2', Html::encode($address->title), [\n                'class' => array_filter([\n                    'address-card-label',\n                    !$address->title ? 'hidden' : null,\n                ]),\n            ]) .\n            ($canDelete\n                ? Html::beginTag('div', [\n                    'class' => 'address-card-header-actions',\n                    'data' => [\n                        'wrapper' => true,\n                    ],\n                ]) .\n                Html::button('', [\n                    'class' => ['btn', 'menubtn'],\n                    'title' => Craft::t('app', 'Actions'),\n                    'aria' => [\n                        'controls' => $actionMenuId,\n                        'label' => sprintf('%s %s', $address->title ? Html::encode($address->title) : Craft::t('app', 'New Address'), Craft::t('app', 'Settings')),\n                    ],\n                    'data' => [\n                        'icon' => 'settings',\n                        'disclosure-trigger' => true,\n                    ],\n                ]) .\n                Html::beginTag('div', [\n                    'id' => $actionMenuId,\n                    'class' => ['menu', 'menu--disclosure'],\n                ]) .\n                Html::beginTag('ul', ['class' => 'padded']) .\n                Html::beginTag('li') .\n                Html::button(Craft::t('app', 'Edit'), [\n                    'class' => 'menu-option',\n                    'type' => 'button',\n                    'aria' => [\n                        'label' => Craft::t('app', 'Edit'),\n                    ],\n                    'data' => [\n                        'icon' => 'edit',\n                        'action' => 'edit',\n                    ],\n                ]) .\n                Html::endTag('li') .\n                Html::beginTag('li') .\n                Html::button(Craft::t('app', 'Delete'), [\n                    'class' => 'error menu-option',\n                    'type' => 'button',\n                    'aria' => [\n                        'label' => Craft::t('app', 'Delete'),\n                    ],\n                    'data' => [\n                        'icon' => 'remove',\n                        'action' => 'delete',\n                    ],\n                ]) .\n                Html::endTag('li') .\n                Html::endTag('ul') .\n                Html::endTag('div') . // .menu\n                Html::endTag('div') // .address-card-header-actions\n                : ''\n            ) .\n            Html::endTag('div') . // .address-card-header\n            Html::tag('div', Craft::$app->getAddresses()->formatAddress($address), [\n                'class' => 'address-card-body',\n            ]) .\n            Html::endTag('li'); // .address-card\n    }\n\n    /**\n     * Returns address fields\u2019 HTML (sans country) for a given address.\n     *\n     * @param Address $address\n     * @return string\n     * @since 4.0.0\n     */\n    public static function addressFieldsHtml(Address $address): string\n    {\n        $formatRepo = Craft::$app->getAddresses()->getAddressFormatRepository()->get($address->countryCode);\n\n        $requiredFields = [];\n        $scenario = $address->getScenario();\n        $address->setScenario(Element::SCENARIO_LIVE);\n        $activeValidators = $address->getActiveValidators();\n        $address->setScenario($scenario);\n\n        foreach ($activeValidators as $validator) {\n            if ($validator instanceof RequiredValidator) {\n                foreach ($validator->getAttributeNames() as $attr) {\n                    if ($validator->when === null || call_user_func($validator->when, $address, $attr)) {\n                        $requiredFields[$attr] = true;\n                    }\n                }\n            }\n        }\n\n        $visibleFields = array_flip(array_merge(\n                $formatRepo->getUsedFields(),\n                $formatRepo->getUsedSubdivisionFields(),\n            )) + $requiredFields;\n\n        return\n            static::textFieldHtml([\n                'label' => $address->getAttributeLabel('addressLine1'),\n                'id' => 'addressLine1',\n                'name' => 'addressLine1',\n                'value' => $address->addressLine1,\n                'required' => isset($requiredFields['addressLine1']),\n                'errors' => $address->getErrors('addressLine1'),\n            ]) .\n            static::textFieldHtml([\n                'label' => $address->getAttributeLabel('addressLine2'),\n                'id' => 'addressLine2',\n                'name' => 'addressLine2',\n                'value' => $address->addressLine2,\n                'required' => isset($requiredFields['addressLine2']),\n                'errors' => $address->getErrors('addressLine2'),\n            ]) .\n            self::_subdivisionField(\n                $address,\n                'administrativeArea',\n                isset($visibleFields['administrativeArea']),\n                isset($requiredFields['administrativeArea']),\n                [$address->countryCode],\n                true,\n            ) .\n            self::_subdivisionField(\n                $address,\n                'locality',\n                isset($visibleFields['locality']),\n                isset($requiredFields['locality']),\n                [$address->countryCode, $address->administrativeArea],\n                true,\n            ) .\n            self::_subdivisionField(\n                $address,\n                'dependentLocality',\n                isset($visibleFields['dependentLocality']),\n                isset($requiredFields['dependentLocality']),\n                [$address->countryCode, $address->administrativeArea, $address->locality],\n                false,\n            ) .\n            Html::beginTag('div', ['class' => 'flex-fields']) .\n            static::textFieldHtml([\n                'fieldClass' => array_filter([\n                    'width-50',\n                    !isset($visibleFields['postalCode']) ? 'hidden' : null,\n                ]),\n                'label' => $address->getAttributeLabel('postalCode'),\n                'id' => 'postalCode',\n                'name' => 'postalCode',\n                'value' => $address->postalCode,\n                'required' => isset($requiredFields['postalCode']),\n                'errors' => $address->getErrors('postalCode'),\n            ]) .\n            static::textFieldHtml([\n                'fieldClass' => array_filter([\n                    'width-50',\n                    !isset($visibleFields['sortingCode']) ? 'hidden' : null,\n                ]),\n                'label' => $address->getAttributeLabel('sortingCode'),\n                'id' => 'sortingCode',\n                'name' => 'sortingCode',\n                'value' => $address->sortingCode,\n                'required' => isset($requiredFields['sortingCode']),\n                'errors' => $address->getErrors('sortingCode'),\n            ]) .\n            Html::endTag('div'); // .flex-fields\n    }\n\n    private static function _subdivisionField(\n        Address $address,\n        string $name,\n        bool $visible,\n        bool $required,\n        ?array $parents,\n        bool $spinner,\n    ): string {\n        $value = $address->$name;\n        $options = Craft::$app->getAddresses()->getSubdivisionRepository()->getList($parents, Craft::$app->language);\n\n        if ($options) {\n            // Persist invalid values in the UI\n            if ($value && !isset($options[$value])) {\n                $options[$value] = $value;\n            }\n\n            if ($spinner) {\n                $errors = $address->getErrors($name);\n                $input =\n                    Html::beginTag('div', [\n                        'class' => ['flex', 'flex-nowrap'],\n                    ]) .\n                    static::selectizeHtml([\n                        'id' => $name,\n                        'name' => $name,\n                        'value' => $value,\n                        'options' => $options,\n                        'errors' => $errors,\n                    ]) .\n                    Html::tag('div', '', [\n                        'id' => \"$name-spinner\",\n                        'class' => ['spinner', 'hidden'],\n                    ]) .\n                    Html::endTag('div');\n\n                return static::fieldHtml($input, [\n                    'fieldClass' => !$visible ? 'hidden' : null,\n                    'label' => $address->getAttributeLabel($name),\n                    'id' => $name,\n                    'required' => $required,\n                    'errors' => $errors,\n                ]);\n            }\n\n            return static::selectizeFieldHtml([\n                'fieldClass' => !$visible ? 'hidden' : null,\n                'label' => $address->getAttributeLabel($name),\n                'id' => $name,\n                'name' => $name,\n                'value' => $value,\n                'options' => $options,\n                'required' => $required,\n                'errors' => $address->getErrors($name),\n            ]);\n        }\n\n        // No preconfigured subdivisions for the given parents, so just output a text input\n        return static::textFieldHtml([\n            'fieldClass' => !$visible ? 'hidden' : null,\n            'label' => $address->getAttributeLabel($name),\n            'id' => $name,\n            'name' => $name,\n            'value' => $value,\n            'required' => $required,\n            'errors' => $address->getErrors($name),\n        ]);\n    }\n\n    /**\n     * Renders a field layout designer.\n     *\n     * @param FieldLayout $fieldLayout\n     * @param array $config\n     * @return string\n     * @since 4.0.0\n     */\n    public static function fieldLayoutDesignerHtml(FieldLayout $fieldLayout, array $config = []): string\n    {\n        $config += [\n            'id' => 'fld' . mt_rand(),\n            'customizableTabs' => true,\n            'customizableUi' => true,\n        ];\n\n        $tabs = array_filter($fieldLayout->getTabs(), fn(FieldLayoutTab $tab) => !empty($tab->getElements()));\n\n        if (!$config['customizableTabs']) {\n            $tab = array_shift($tabs) ?? new FieldLayoutTab([\n                    'uid' => StringHelper::UUID(),\n                    'layout' => $fieldLayout,\n                ]);\n            $tab->name = $config['pretendTabName'] ?? Craft::t('app', 'Content');\n\n            // Any extra tabs?\n            if (!empty($tabs)) {\n                $elements = $tab->getElements();\n                foreach ($tabs as $extraTab) {\n                    array_push($elements, ...$extraTab->getElements());\n                }\n                $tab->setElements($elements);\n            }\n\n            $tabs = [$tab];\n        }\n\n        // Make sure all tabs and their elements have UUIDs\n        // (We do this here instead of from FieldLayoutComponent::init() because the we don't want field layout forms to\n        // get the impression that tabs/elements have persisting UUIDs if they don't.)\n        foreach ($tabs as $tab) {\n            if (!isset($tab->uid)) {\n                $tab->uid = StringHelper::UUID();\n            }\n\n            foreach ($tab->getElements() as $layoutElement) {\n                if (!isset($layoutElement->uid)) {\n                    $layoutElement->uid = StringHelper::UUID();\n                }\n            }\n        }\n\n        $view = Craft::$app->getView();\n        $jsSettings = Json::encode([\n            'customizableTabs' => $config['customizableTabs'],\n            'customizableUi' => $config['customizableUi'],\n        ]);\n        $namespacedId = $view->namespaceInputId($config['id']);\n\n        $js = <<<JS\nnew Craft.FieldLayoutDesigner(\"#$namespacedId\", $jsSettings);\nJS;\n        $view->registerJs($js);\n\n        $availableCustomFields = $fieldLayout->getAvailableCustomFields();\n        $availableNativeFields = $fieldLayout->getAvailableNativeFields();\n        $availableUiElements = $fieldLayout->getAvailableUiElements();\n\n        // Make sure everything has the field layout set properly\n        foreach ($availableCustomFields as $groupFields) {\n            self::_setLayoutOnElements($groupFields, $fieldLayout);\n        }\n        self::_setLayoutOnElements($availableNativeFields, $fieldLayout);\n        self::_setLayoutOnElements($availableUiElements, $fieldLayout);\n\n        // Don't call FieldLayout::getConfig() here because we want to include *all* tabs, not just non-empty ones\n        $fieldLayoutConfig = [\n            'uid' => $fieldLayout->uid,\n            'tabs' => array_map(fn(FieldLayoutTab $tab) => $tab->getConfig(), $tabs),\n        ];\n\n        if ($fieldLayout->id) {\n            $fieldLayoutConfig['id'] = $fieldLayout->id;\n        }\n\n        $newTabSettingsData = self::_fldTabSettingsData(new FieldLayoutTab([\n            'uid' => 'TAB_UID',\n            'name' => 'TAB_NAME',\n            'layout' => $fieldLayout,\n        ]));\n\n        return\n            Html::beginTag('div', [\n                'id' => $config['id'],\n                'class' => 'layoutdesigner',\n                'data' => [\n                    'new-tab-settings-namespace' => $newTabSettingsData['settings-namespace'],\n                    'new-tab-settings-html' => $newTabSettingsData['settings-html'],\n                    'new-tab-settings-js' => $newTabSettingsData['settings-js'],\n                ],\n            ]) .\n            Html::hiddenInput('fieldLayout', Json::encode($fieldLayoutConfig), [\n                'data' => ['config-input' => true],\n            ]) .\n            Html::beginTag('div', ['class' => 'fld-workspace']) .\n            Html::beginTag('div', ['class' => 'fld-tabs']) .\n            implode('', array_map(fn(FieldLayoutTab $tab) => self::_fldTabHtml($tab, $config['customizableTabs']), $tabs)) .\n            Html::endTag('div') . // .fld-tabs\n            ($config['customizableTabs']\n                ? Html::button(Craft::t('app', 'New Tab'), [\n                    'type' => 'button',\n                    'class' => ['fld-new-tab-btn', 'btn', 'add', 'icon'],\n                ])\n                : '') .\n            Html::endTag('div') . // .fld-workspace\n            Html::beginTag('div', ['class' => 'fld-sidebar']) .\n            ($config['customizableUi']\n                ? Html::beginTag('div', [\n                    'role' => 'listbox',\n                    'class' => ['btngroup', 'small', 'fullwidth'],\n                    'aria' => ['label' => Craft::t('app', 'Layout element types')],\n                    'tabindex' => '0',\n                ]) .\n                Html::button(Craft::t('app', 'Fields'), [\n                    'role' => 'option',\n                    'type' => 'button',\n                    'class' => ['btn', 'small', 'active'],\n                    'aria' => ['selected' => 'true'],\n                    'data' => ['library' => 'field'],\n                    'tabindex' => '-1',\n                ]) .\n                Html::button(Craft::t('app', 'UI Elements'), [\n                    'role' => 'option',\n                    'type' => 'button',\n                    'class' => ['btn', 'small'],\n                    'aria' => ['selected' => 'false'],\n                    'data' => ['library' => 'ui'],\n                    'tabindex' => '-1',\n                ]) .\n                Html::endTag('div') // .btngroup\n                : '') .\n            Html::beginTag('div', ['class' => 'fld-field-library']) .\n            Html::beginTag('div', ['class' => ['texticon', 'search', 'icon', 'clearable']]) .\n            static::textHtml([\n                'class' => 'fullwidth',\n                'inputmode' => 'search',\n                'placeholder' => Craft::t('app', 'Search'),\n            ]) .\n            Html::tag('div', '', [\n                'class' => ['clear', 'hidden'],\n                'title' => Craft::t('app', 'Clear'),\n                'aria' => ['label' => Craft::t('app', 'Clear')],\n            ]) .\n            Html::endTag('div') . // .texticon\n            self::_fldFieldSelectorsHtml(Craft::t('app', 'Native Fields'), $availableNativeFields, $fieldLayout) .\n            implode('', array_map(fn(string $groupName) => self::_fldFieldSelectorsHtml($groupName, $availableCustomFields[$groupName], $fieldLayout), array_keys($availableCustomFields))) .\n            Html::endTag('div') . // .fld-field-library\n            ($config['customizableUi']\n                ? Html::beginTag('div', ['class' => ['fld-ui-library', 'hidden']]) .\n                implode('', array_map(fn(FieldLayoutElement $element) => self::_fldElementSelectorHtml($element, true), $availableUiElements)) .\n                Html::endTag('div') // .fld-ui-library\n                : '') .\n            Html::endTag('div') . // .fld-sidebar\n            Html::endTag('div'); // .layoutdesigner\n    }\n\n    /**\n     * @param FieldLayoutElement[] $elements\n     * @param FieldLayout $fieldLayout\n     */\n    private static function _setLayoutOnElements(array $elements, FieldLayout $fieldLayout): void\n    {\n        foreach ($elements as $element) {\n            $element->setLayout($fieldLayout);\n        }\n    }\n\n    /**\n     * @param FieldLayoutTab $tab\n     * @param bool $customizable\n     * @return string\n     */\n    private static function _fldTabHtml(FieldLayoutTab $tab, bool $customizable): string\n    {\n        return\n            Html::beginTag('div', [\n                'class' => 'fld-tab',\n                'data' => array_merge([\n                    'uid' => $tab->uid,\n                ], self::_fldTabSettingsData($tab)),\n            ]) .\n            Html::beginTag('div', ['class' => 'tabs']) .\n            Html::beginTag('div', [\n                'class' => array_filter([\n                    'tab',\n                    'sel',\n                    $customizable ? 'draggable' : null,\n                ]),\n            ]) .\n            Html::tag('span', Html::encode($tab->name)) .\n            ($customizable\n                ? Html::a('', null, [\n                    'role' => 'button',\n                    'class' => ['settings', 'icon'],\n                    'title' => Craft::t('app', 'Edit'),\n                    'aria' => ['label' => Craft::t('app', 'Edit')],\n                ]) :\n                '') .\n            Html::endTag('div') . // .tab\n            Html::endTag('div') . // .tabs\n            Html::beginTag('div', ['class' => 'fld-tabcontent']) .\n            implode('', array_map(fn(FieldLayoutElement $element) => self::_fldElementSelectorHtml($element, false), $tab->getElements())) .\n            Html::endTag('div') . // .fld-tabcontent\n            Html::endTag('div'); // .fld-tab\n    }\n\n    /**\n     * @param FieldLayoutTab $tab\n     * @return array\n     */\n    private static function _fldTabSettingsData(FieldLayoutTab $tab): array\n    {\n        $view = Craft::$app->getView();\n        $oldNamespace = $view->getNamespace();\n        $namespace = $view->namespaceInputName(\"tab-$tab->uid\");\n        $view->setNamespace($namespace);\n        $view->startJsBuffer();\n        $settingsHtml = $view->namespaceInputs($tab->getSettingsHtml());\n        $settingsJs = $view->clearJsBuffer(false);\n        $view->setNamespace($oldNamespace);\n\n        return [\n            'settings-namespace' => $namespace,\n            'settings-html' => $settingsHtml,\n            'settings-js' => $settingsJs,\n        ];\n    }\n\n    /**\n     * @param FieldLayoutElement $element\n     * @param bool $forLibrary\n     * @param array $attr\n     * @return string\n     */\n    private static function _fldElementSelectorHtml(FieldLayoutElement $element, bool $forLibrary, array $attr = []): string\n    {\n        if ($element instanceof BaseField) {\n            $attr = ArrayHelper::merge($attr, [\n                'class' => !$forLibrary && $element->required ? ['fld-required'] : [],\n                'data' => [\n                    'keywords' => $forLibrary ? implode(' ', array_map('mb_strtolower', $element->keywords())) : false,\n                ],\n            ]);\n        }\n\n        $view = Craft::$app->getView();\n        $oldNamespace = $view->getNamespace();\n        $namespace = $view->namespaceInputName('element-' . ($forLibrary ? 'ELEMENT_UID' : $element->uid));\n        $view->setNamespace($namespace);\n        $view->startJsBuffer();\n        $settingsHtml = $view->namespaceInputs($element->getSettingsHtml());\n        $settingsJs = $view->clearJsBuffer(false);\n        $view->setNamespace($oldNamespace);\n\n        $attr = ArrayHelper::merge($attr, [\n            'class' => array_filter([\n                'fld-element',\n                $forLibrary ? 'unused' : null,\n                !$forLibrary && $element->hasConditions() ? 'has-conditions' : null,\n            ]),\n            'data' => [\n                'uid' => !$forLibrary ? $element->uid : false,\n                'config' => $forLibrary ? ['type' => get_class($element)] + $element->toArray() : false,\n                'has-custom-width' => $element->hasCustomWidth(),\n                'settings-namespace' => $namespace,\n                'settings-html' => $settingsHtml ?: false,\n                'settings-js' => $settingsJs ?: false,\n            ],\n        ]);\n\n        return Html::modifyTagAttributes($element->selectorHtml(), $attr);\n    }\n\n    /**\n     * @param string $groupName\n     * @param BaseField[] $groupFields\n     * @param FieldLayout $fieldLayout\n     * @return string\n     */\n    private static function _fldFieldSelectorsHtml(string $groupName, array $groupFields, FieldLayout $fieldLayout): string\n    {\n        $showGroup = ArrayHelper::contains($groupFields, fn(BaseField $field) => !$fieldLayout->isFieldIncluded($field->attribute()));\n\n        return\n            Html::beginTag('div', [\n                'class' => array_filter([\n                    'fld-field-group',\n                    $showGroup ? null : 'hidden',\n                ]),\n                'data' => ['name' => mb_strtolower($groupName)],\n            ]) .\n            Html::tag('h6', Html::encode($groupName)) .\n            implode('', array_map(fn(BaseField $field) => self::_fldElementSelectorHtml($field, true, [\n                'class' => array_filter([\n                    $fieldLayout->isFieldIncluded($field->attribute()) ? 'hidden' : null,\n                ]),\n            ]), $groupFields)) .\n            Html::endTag('div'); // .fld-field-group\n    }\n\n    /**\n     * Returns a metadata component\u2019s HTML.\n     *\n     * @param array $data The data, with keys representing the labels. The values can either be strings or callables.\n     * If a value is `false`, it will be omitted.\n     * @return string\n     */\n    public static function metadataHtml(array $data): string\n    {\n        $defs = [];\n\n        foreach ($data as $label => $value) {\n            if (is_callable($value)) {\n                $value = $value();\n            }\n            if ($value !== false) {\n                $defs[] =\n                    Html::beginTag('div', [\n                        'class' => 'data',\n                    ]) .\n                    Html::tag('dt', Html::encode($label), ['class' => 'heading']) . \"\\n\" .\n                    Html::tag('dd', $value, ['class' => 'value']) . \"\\n\" .\n                    Html::endTag('div');\n            }\n        }\n\n        if (empty($defs)) {\n            return '';\n        }\n\n        return Html::tag('dl', implode(\"\\n\", $defs), [\n            'class' => ['meta', 'read-only'],\n        ]);\n    }\n\n    /**\n     * Returns the site the control panel is currently working with, via a `site` query string param if sent.\n     *\n     * @return Site|null The site, or `null` if the user doesn\u2019t have permission to edit any sites.\n     * @since 4.0.0\n     */\n    public static function requestedSite(): ?Site\n    {\n        if (!isset(self::$_requestedSite)) {\n            $sitesService = Craft::$app->getSites();\n            $editableSiteIds = $sitesService->getEditableSiteIds();\n\n            if (!empty($editableSiteIds)) {\n                $request = Craft::$app->getRequest();\n                if (\n                    !$request->getIsConsoleRequest() &&\n                    ($handle = $request->getQueryParam('site')) !== null &&\n                    ($site = $sitesService->getSiteByHandle($handle, true)) !== null &&\n                    in_array($site->id, $editableSiteIds, false)\n                ) {\n                    self::$_requestedSite = $site;\n                } else {\n                    self::$_requestedSite = $sitesService->getCurrentSite();\n\n                    if (!in_array(self::$_requestedSite->id, $editableSiteIds, false)) {\n                        // Just go with the first editable site\n                        self::$_requestedSite = $sitesService->getSiteById($editableSiteIds[0]);\n                    }\n                }\n            } else {\n                self::$_requestedSite = false;\n            }\n        }\n\n        return self::$_requestedSite ?: null;\n    }\n}\n"], "filenames": ["src/helpers/Cp.php"], "buggy_code_start_loc": [1172], "buggy_code_end_loc": [1205], "fixing_code_start_loc": [1171], "fixing_code_end_loc": [1204], "type": "CWE-79", "message": "Craft CMS 4.2.0.1 suffers from Stored Cross Site Scripting (XSS) in /admin/myaccount.", "other": {"cve": {"id": "CVE-2022-37250", "sourceIdentifier": "cve@mitre.org", "published": "2022-09-16T15:15:09.767", "lastModified": "2022-09-17T02:23:19.767", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Craft CMS 4.2.0.1 suffers from Stored Cross Site Scripting (XSS) in /admin/myaccount."}, {"lang": "es", "value": "Craft CMS versi\u00f3n  4.2.0.1, sufre de un ataque de tipo Cross Site Scripting (XSS) Almacenado en /admin/myaccount"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:craftcms:craft_cms:4.2.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "3AFD2A34-547A-4DFE-A60A-2A4032CC8BC7"}]}]}], "references": [{"url": "https://github.com/craftcms/cms/commit/cdc9cb66d0716c9552e4113c8e426fd1a31f9516", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://labs.integrity.pt/advisories/cve-2022-37250/", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/craftcms/cms/commit/cdc9cb66d0716c9552e4113c8e426fd1a31f9516"}}