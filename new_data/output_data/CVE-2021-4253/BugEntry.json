{"buggy_code": ["=pod\nLenio - Web-based Facilities Management Software\nCopyright (C) 2013 A Beverley\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU Affero General Public License as\npublished by the Free Software Foundation, either version 3 of the\nLicense, or (at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Affero General Public License for more details.\n\nYou should have received a copy of the GNU Affero General Public License\nalong with this program.  If not, see <http://www.gnu.org/licenses/>.\n=cut\n\npackage Lenio;\n\nuse CtrlO::Crypt::XkcdPassword;\nuse Dancer2;\nuse Dancer2::Core::Cookie;\nuse DateTime::Format::Strptime;\nuse JSON qw(encode_json);\nuse Lenio::Calendar;\nuse Lenio::Config;\nuse Lenio::Email;\nuse Session::Token;\nuse Text::CSV;\n\nuse Dancer2::Plugin::DBIC;\nuse Dancer2::Plugin::Auth::Extensible;\nuse Dancer2::Plugin::LogReport;\n\nset behind_proxy => config->{behind_proxy};\n\nLenio::Config->instance(\n    config => config,\n);\n\nour $VERSION = '0.1';\n\n# There should never be exceptions from DBIC, so we want to panic them to\n# ensure they get notified at the correct level.\nschema->exception_action(sub {\n    # Older versions of DBIC use this handler during expected exceptions.\n    # Temporary hack: do not panic these as DBIC does not catch them\n    die $_[0] if $_[0] =~ /^Unable to satisfy requested constraint/; # Expected\n    die $_[0] if $_[0] =~ /MySQL server has gone away/; # Expected\n    panic @_; # Not expected\n});\n\nmy $dateformat = config->{lenio}->{dateformat};\n\nmy $password_generator = CtrlO::Crypt::XkcdPassword->new;\n\nsub _update_csrf_token\n{   session csrf_token => Session::Token->new(length => 32)->get;\n}\n\nhook before => sub {\n\n    # Used to display error messages\n    return if param 'error';\n\n    my $user = logged_in_user\n\n    my $method      = request->method;\n    my $path        = request->path;\n    my $query       = request->query_string;\n    my $username    = $user && $user->{username};\n    my $description = $user\n        ? qq(User \"$username\" made \"$method\" request to \"$path\")\n        : qq(Unauthenticated user made \"$method\" request to \"$path\");\n    $description .= qq( with query \"$query\") if $query;\n    # Log to audit\n    rset('Audit')->user_action(description => $description, url => $path, method => $method, login_id => $user && $user->{id});\n\n    $user\n        or return;\n\n    header \"X-Frame-Options\" => \"DENY\"; # Prevent clickjacking\n\n    if (!session 'csrf_token')\n    {\n        _update_csrf_token();\n    }\n\n    if (request->is_post)\n    {\n        # Protect against CSRF attacks\n        panic __x\"csrf-token missing for path {path}\", path => request->path\n            if !param 'csrf_token';\n        error __x\"Suspected attack: CSRF token does not match that in the session\"\n            if param('csrf_token') ne session('csrf_token');\n\n        # If it's a potential login, change the token\n        _update_csrf_token()\n            if request->path eq '/login';\n    }\n\n    my $login = rset('Login')->find($user->{id});\n\n    # Do not try and get sites etc if logging out. User may have received \"no\n    # sites associated\" error and be trying to logout, in which case we don't\n    # want to run the following code as it will generate errors\n    return if request->uri eq '/logout';\n\n    # Sites associated with the user \n    forward '/error', { 'error' => 'There are no sites associated with this username' }\n        unless $login->sites;\n \n    # Select individual site and check user has access\n    if ( query_parameters->get('site') && query_parameters->get('site') eq 'all' ) {\n        session site_id => '';\n        session group_id => undef;\n    }\n    elsif ($login->is_admin && query_parameters->get('group'))\n    {\n        session site_id => undef;\n        session group_id => query_parameters->get('group');\n    }\n    elsif ( query_parameters->get('site') ) {\n        session site_id => query_parameters->get('site')\n            if $login->has_site(query_parameters->get('site'));\n        session group_id => undef;\n    }\n    elsif (!defined(session 'site_id') && !defined(session 'group_id')) {\n        session(site_id => ($login->sites)[0]->id) unless (defined session('site_id'));\n    }\n\n    my $contractors = session('contractors') || {};\n    if (my $contractor_id = query_parameters->get('contractor'))\n    {\n        if ($contractors->{$contractor_id}) {\n            delete $contractors->{$contractor_id};\n        } else {\n            $contractors->{$contractor_id} = 1;\n        }\n    }\n    elsif (defined query_parameters->get('contractor')) # clear all\n    {\n        $contractors = {};\n    }\n    session 'contractors' => $contractors;\n\n    my $site_ids = $login->is_admin && session('site_id')\n                 ? session('site_id')\n                 : $login->is_admin && session('group_id') && rset('Group')->find(session 'group_id')\n                 ? rset('Group')->find(session 'group_id')->site_ids\n                 : session('site_id')\n                 ? session('site_id')\n                 : $login->site_ids;\n    var site_ids => $site_ids;\n\n    session 'fy' => query_parameters->get('fy') if query_parameters->get('fy');\n    session 'fy' => Lenio::FY->new(site_id => session('site_id'), schema => schema)->year\n        if !session('fy');\n\n    var login => $login;\n};\n\nhook before_template => sub {\n    my $tokens = shift;\n\n    my $base = $tokens->{base} || request->base;\n    $tokens->{url}->{css}  = \"${base}css\";\n    $tokens->{url}->{js}   = \"${base}js\";\n    $tokens->{url}->{page} = $base;\n    $tokens->{url}->{page} =~ s!.*/!!; # Remove trailing slash\n    $tokens->{scheme}    ||= request->scheme; # May already be set for phantomjs requests\n    $tokens->{hostlocal}   = config->{gads}->{hostlocal};\n\n    $tokens->{messages}   = session('messages');\n    $tokens->{csrf_token} = session 'csrf_token';\n    $tokens->{login}      = var('login');\n    $tokens->{groups}     = [schema->resultset('Group')->ordered];\n    $tokens->{contractors} = [rset('Contractor')->ordered];\n    $tokens->{contractors_selected} = session 'contractors';\n    $tokens->{company_name} = config->{lenio}->{invoice}->{company};\n    $tokens->{logo} = config->{lenio}->{logo};\n};\n\nget '/' => require_login sub {\n\n    # Deal with sort options\n    if (query_parameters->get('sort'))\n    {\n        session task_desc => session('task_sort') && session('task_sort') eq query_paremeters->get('sort') ? !session('task_desc') : 0;\n        session task_sort => query_parameters->get('sort');\n    }\n\n    # Overdue tasks for non-global items are not being used so are now removed\n    # from the template. Code retained here anyway for time being.\n    my $local = var('login')->is_admin ? 0 : 1; # Only show local tasks for non-admin\n    my @overdue = rset('Task')->overdue(\n        site_id   => var('site_ids'),\n        login     => var('login'),\n        local     => $local,\n        sort      => session('task_sort'),\n        sort_desc => session('task_desc'),\n    );\n    template 'index' => {\n        dateformat => config->{lenio}->{dateformat},\n        tasks      => \\@overdue,\n        page       => 'index'\n    };\n};\n\nsub login_page_handler\n{\n    my $messages = session('messages') || undef;\n    success __\"A password reset request has been sent if the email address\n           entered was valid\" if defined param('reset_sent');\n    if (defined param('login_failed'))\n    {\n        status 401;\n        report {is_fatal=>0}, ERROR => \"Username or password not valid\";\n    }\n    template login => {\n        page                => 'login',\n        new_password        => request->parameters->get('new_password'),\n        password_code_valid => request->parameters->get('password_code_valid'),\n        reset_code          => request->parameters->get('new_password') || request->parameters->get('password_code_valid'),\n    };\n}\n\nget '/logout' => sub {\n    app->destroy_session;\n    rset('Audit')->logout(logged_in_user->{username}, logged_in_user->{id}) = @_;\n    forwardHome();\n};\n\n# Dismiss a notice\npost '/close/:id' => require_login sub {\n    my $notice = rset('LoginNotice')->find(route_parameters->get('id')) or return;\n    $notice->delete if $notice->login_id == var('login')->id;\n};\n\nany ['get', 'post'] => '/user/:id' => require_login sub {\n\n    my $is_admin = var('login')->is_admin;\n    my $id       = $is_admin ? route_parameters->get('id') : var('login')->id;\n\n    my $email_comment = body_parameters->get('email_comment') ? 1 : 0;\n    my $email_ticket  = body_parameters->get('email_ticket') ? 1 : 0;\n    my $only_mine  = body_parameters->get('only_mine') ? 1 : 0;\n    if (!$id && $is_admin && body_parameters->get('submit'))\n    {\n        my $email = body_parameters->get('email')\n            or error \"Please enter an email address for the new user\";\n        # check existing\n        rset('Login')->active_rs->search({ email => $email })->count\n            and error __x\"The email address {email} already exists\", email => $email;\n        my $newuser = create_user username => $email, email => $email, realm => 'dbic', email_welcome => 1;\n        $id = $newuser->{id};\n        # Default to on\n        $email_comment = 1;\n        $email_ticket  = 1;\n    }\n\n    my $login    = $id && rset('Login')->find($id);\n    $id && !$login and error \"User ID {id} not found\", id => $id;\n\n    if ($is_admin && body_parameters->get('delete'))\n    {\n        if (process sub { $login->disable })\n        {\n            forwardHome({ success => \"User has been deleted successfully\" }, 'users');\n        }\n    }\n\n    if (body_parameters->get('submit')) {\n        $login->username(body_parameters->get('email'));\n        $login->email(body_parameters->get('email'));\n        $login->firstname(body_parameters->get('firstname'));\n        $login->surname(body_parameters->get('surname'));\n        $login->email_comment($email_comment);\n        $login->email_ticket($email_ticket);\n        $login->only_mine($only_mine);\n\n        $login->is_admin(body_parameters->get('is_admin') ? 1 : 0)\n            if $is_admin;\n        if ($is_admin && !$login->is_admin)\n        {\n            my @org_ids = body_parameters->get_all('org_ids');\n            $login->update_orgs(@org_ids);\n        }\n        if (process sub { $login->update_or_insert } )\n        {\n            my $forward = $is_admin ? 'users' : '';\n            forwardHome({ success => \"User has been submitted successfully\" }, $forward);\n        }\n    }\n\n    my @orgs = rset('Org')->all;\n    template 'user' => {\n        id         => $id,\n        orgs       => \\@orgs,\n        edit_login => $login,\n        page       => 'user'\n    };\n};\n\nget '/users/?' => require_login sub {\n\n    var('login')->is_admin\n        or error \"You do not have access to this page\";\n\n    template 'users' => {\n        logins    => [rset('Login')->active],\n        page      => 'user'\n    };\n};\n\nany ['get', 'post'] => '/group/:id' => require_login sub {\n\n    var('login')->is_admin\n        or error \"You do not have access to this page\";\n\n    my $id = route_parameters->get('id');\n\n    my $group = ($id && rset('Group')->find($id)) || rset('Group')->new({});\n\n    if (body_parameters->get('submit'))\n    {\n        $group->name(body_parameters->get('name'));\n        $group->set_site_ids([body_parameters->get_all('site_ids')]);\n        if (process sub { $group->write })\n        {\n            forwardHome(\n                { success => 'The group has been successfully updated' }, 'groups' );\n        }\n    }\n\n    template 'group' => {\n        group => $group,\n        sites => [rset('Site')->ordered_org->all],\n        page  => 'group'\n    };\n};\n\nget '/groups/?' => require_login sub {\n\n    var('login')->is_admin\n        or error \"You do not have access to this page\";\n\n    template 'groups' => {\n        groups => [rset('Group')->ordered],\n        page   => 'groups'\n    };\n};\n\nany ['get', 'post'] => '/contractor/?:id?' => require_login sub {\n\n    var('login')->is_admin\n        or forwardHome({ danger => 'You do not have permission to view contractors' });\n\n    my $contractor;\n    my $id = route_parameters->get('id');\n    if (defined $id)\n    {\n        $contractor = rset('Contractor')->find($id) || rset('Contractor')->new({});\n    }\n\n    if (body_parameters->get('delete'))\n    {\n        if (process (sub { $contractor->delete } ) )\n        {\n            forwardHome({ success => 'Contractor has been successfully deleted' }, 'contractor');\n        }\n    }\n\n    if (body_parameters->get('submit'))\n    {\n        $contractor->name(body_parameters->get('name'));\n        if (process sub { $contractor->update_or_insert })\n        {\n            forwardHome({ success => 'Contractor has been successfully added' }, 'contractor');\n        }\n    }\n\n    template 'contractor' => {\n        id          => $id,\n        contractor  => $contractor,\n        contractors => [rset('Contractor')->ordered],\n        page        => 'contractor'\n    };\n};\n\nany ['get', 'post'] => '/notice/?:id?' => require_login sub {\n\n    var('login')->is_admin\n        or forwardHome({ danger => 'You do not have permission to view notice settings' });\n\n    my $id = route_parameters->get('id');\n    my $notice = defined $id && (rset('Notice')->find($id) || rset('Notice')->new({}));\n\n    if (body_parameters->get('delete'))\n    {\n        if (process (sub { $notice->delete } ) )\n        {\n            forwardHome({ success => 'The notice has been successfully deleted' }, 'notice');\n        }\n    }\n\n    if (body_parameters->get('submit'))\n    {\n        $notice->text(body_parameters->get('text'));\n        if (process sub { $notice->update_or_insert })\n        {\n            forwardHome({ success => 'The notice has been successfully created' }, 'notice');\n        }\n    }\n\n    template 'notice' => {\n        id      => $id,\n        notice  => $notice,\n        notices => [rset('Notice')->all_with_count],\n        page    => 'notice'\n    };\n};\n \nany ['get', 'post'] => '/check_edit/:id' => require_login sub {\n\n    my $id = route_parameters->get('id');\n\n    my $check = ($id && rset('Task')->find($id)) || rset('Task')->new({ site_check => 1, global => 0 });\n\n    my $site_id = ($check && ($check->site_tasks)[0] && ($check->site_tasks)[0]->site_id) || body_parameters->get('site_id');\n    error \"You do not have access to this check\"\n        if $id && !var('login')->has_site($site_id);\n\n    if (body_parameters->get('submitcheck') && !$check->deleted)\n    {\n        $check->name(body_parameters->get('name'));\n        $check->description(body_parameters->get('description'));\n        $check->period_qty(body_parameters->get('period_qty'));\n        $check->period_unit(body_parameters->get('period_unit'));\n        $check->set_site_id(body_parameters->get('site_id'));\n        if (process sub { $check->update_or_insert })\n        {\n            forwardHome(\n                { success => 'The site check has been successfully updated' }, 'task' );\n        }\n    }\n\n    if (body_parameters->get('submit_name'))\n    {\n        my $checkitem = body_parameters->get('checkitemid')\n            ? rset('CheckItem')->find(body_parameters->get('checkitemid'))\n            : rset('CheckItem')->create({ task_id => $id });\n        error \"You do not have access to this check item\"\n            if body_parameters->get('checkitemid') && $checkitem->task->id != $check->id;\n        $checkitem->name(body_parameters->get('checkitem'));\n        if (process sub { $checkitem->insert_or_update } )\n        {\n            my $status = body_parameters->get('checkitemid') ? 'updated' : 'added';\n            forwardHome(\n                { success => \"The check item has been $status successfully\" }, \"check_edit/$id\" );\n        }\n    }\n\n    if (body_parameters->get('submit_options'))\n    {\n        my $checkitem = rset('CheckItem')->find(body_parameters->get('checkitemid'));\n        error \"You do not have access to this check item\"\n            if body_parameters->get('checkitemid') && $checkitem->task->id != $check->id;\n        if (process sub {\n            $checkitem->update({ has_custom_options => body_parameters->get('has_custom_options') ? 1 : 0 });\n            my @options = body_parameters->get_all('check_option');\n            # options are id followed by name\n            my %existing;\n            while (@options)\n            {\n                my $option_id = shift @options;\n                my $option_name = shift @options;\n                next if !$option_id && !$option_name;\n                my $option = $option_id\n                    ? rset('CheckItemOption')->find($option_id)\n                    : rset('CheckItemOption')->new({ check_item_id => $checkitem->id });\n                error \"You do not have access to this check item option\"\n                    if $option_id && $option->check_item_id != $checkitem->id;\n                $option->name($option_name);\n                $option->insert_or_update;\n                $existing{$option->id} = 1;\n            }\n            foreach my $ci (rset('CheckItemOption')->search({ check_item_id => $checkitem->id })->all)\n            {\n                $ci->update({ is_deleted => 1 }) if !$existing{$ci->id};\n            }\n        })\n        {\n            forwardHome(\n                { success => \"The check item has been updated successfully\" }, \"check_edit/$id\" );\n        }\n    }\n\n    if (body_parameters->get('delete'))\n    {\n        if (process sub { $check->update({ deleted => DateTime->now }) })\n        {\n            forwardHome(\n                { success => 'The check has been successfully deleted' }, 'task' );\n        }\n    }\n\n    template 'check_edit' => {\n        check       => $check,\n        site_id     => session('site_id'),\n        page        => 'check_edit'\n    };\n};\n\nget '/checks/?' => require_login sub {\n\n    my $site_id = session 'site_id'\n        or error __\"Please select a single site before viewing site checks\";\n\n    template 'checks' => {\n        site        => rset('Site')->find(session 'site_id'),\n        site_checks => [rset('Task')->site_checks($site_id)],\n        dateformat  => config->{lenio}->{dateformat},\n        page        => 'check',\n    };\n};\n\nany ['get', 'post'] => '/check/?:task_id?/?:check_done_id?/?' => require_login sub {\n\n    my $task_id       = route_parameters->get('task_id');\n    my $check_done_id = route_parameters->get('check_done_id');\n    my $check         = rset('Task')->find($task_id);\n\n    my $site_id = session 'site_id'\n        or error __\"Please select a single site before viewing site checks\";\n\n    my $check_done = $check_done_id ? rset('CheckDone')->find($check_done_id) : rset('CheckDone')->new({});\n\n    my $check_site_id = ($check->site_tasks)[0]->site_id;\n    error \"You do not have access to this check\"\n        unless var('login')->has_site($check_site_id);\n\n    if (body_parameters->get('submit_check_done'))\n    {\n        my $site_task_id = $check_done_id ? $check_done->site_task_id : rset('SiteTask')->search({\n            task_id => $task_id,\n            site_id => $site_id,\n        })->next->id;\n        # Log the completion of a site check\n        # Check user has permission first\n        error __x\"You do not have permission for site ID {id}\", id => $site_id\n            unless var('login')->has_site_task( $site_task_id );\n\n        my $datetime = _to_dt(body_parameters->get('completed')) || DateTime->now;\n\n        $check_done->datetime($datetime);\n        $check_done->comment(body_parameters->get('comment'));\n        $check_done->site_task_id($site_task_id);\n        $check_done->login_id(var('login')->id);\n        $check_done->update_or_insert;\n\n        my $params = body_parameters;\n        foreach my $key (keys %$params)\n        {\n            next unless $key =~ /^item([0-9]+)/;\n            my $check_item_id = $1;\n            my $check_item = rset('CheckItem')->find($check_item_id)\n                or error \"Check item not found\";\n            $check_item->task_id == $check->id\n                or error \"Check item is not valid\";\n            if ($check_item->has_custom_options)\n            {\n                my $check_item_done = rset('CheckItemDone')->update_or_create({\n                    check_item_id => $check_item_id,\n                    check_done_id => $check_done->id,\n                    status_custom => param(\"item$check_item_id\") || undef,\n                });\n            }\n            else {\n                my $check_item_done = rset('CheckItemDone')->update_or_create({\n                    check_item_id => $check_item_id,\n                    check_done_id => $check_done->id,\n                    status        => param(\"item$check_item_id\") || undef,\n                });\n            }\n        }\n        forwardHome({ success => \"Check has been recorded successfully\" }, 'checks');\n    }\n\n    template 'check' => {\n        check       => rset('Task')->find($task_id),\n        check_done  => $check_done,\n        dateformat  => config->{lenio}->{dateformat},\n        page        => 'check',\n    };\n};\n\nget '/ticket/view/:id?' => require_login sub {\n    my $id = route_parameters->get('id');\n    redirect '/ticket'\n        unless $id =~ /^[0-9]+$/;\n    redirect \"/ticket/$id\";\n};\n\nany ['get', 'post'] => '/ticket/:id?' => require_login sub {\n\n    my $date    = query_parameters->get('date');\n    my $id      = route_parameters->get('id');\n\n    # Check for comment deletion\n    if (my $comment_id = body_parameters->get('delete_comment'))\n    {\n        error \"You do not have access to delete comments\"\n            unless var('login')->is_admin;\n        if (my $comment = rset('Comment')->find($comment_id))\n        {\n            my $ticket_id = $comment->ticket_id;\n            if (process sub { $comment->delete })\n            {\n                forwardHome({ success => \"Comment has been successfully deleted\" }, \"ticket/$ticket_id\");\n            }\n        }\n        else {\n            error \"Comment id {id} not found\", id => $comment_id;\n        }\n    }\n\n    # task_id can be specified in posted form or prefilled in ticket url\n    my $task;\n    if (my $task_id = body_parameters->get('task_id') || query_parameters->get('task_id'))\n    {\n        $task = rset('Task')->find($task_id);\n    }\n\n    my $ticket;\n    if (defined($id) && $id)\n    {\n        $ticket = rset('Ticket')->find($id)\n            or error __x\"Ticket ID {id} not found\", id => $id;\n        # Check whether the user has access to this ticket\n        error __x\"You do not have permission for ticket ID {id}\", id => $id\n            unless var('login')->has_site($ticket->site_id);\n        # Existing ticket, get task from DB\n        $task = $ticket->task;\n    }\n    elsif (defined($id) && !body_parameters->get('submit'))\n    {\n        # If applicable, Prefill ticket fields with initial values based on task\n        if ($task)\n        {\n            my $sid  = $task->site_task_local && $task->site_task_local->site_id; # site_id associated with local task\n            # See if the user has permission to view associated task\n            if ( var('login')->is_admin\n                || (!$task->global && var('login')->has_site($sid))\n            ) {\n                $ticket = rset('Ticket')->new({\n                    name        => $task->name,\n                    description => $task->description,\n                    planned     => $date,\n                    actionee    => $task->global ? 'external' : 'local',\n                    task_id     => $task->id,\n                    site_id     => query_parameters->get('site_id') || session('site_id'),\n                });\n            }\n        }\n        else {\n            $ticket = rset('Ticket')->new({\n                site_id => query_parameters->get('site_id') || session('site_id'),\n            });\n        }\n    }\n    elsif (defined($id))\n    {\n        # New ticket submitted, create base object to be updated\n        $ticket = rset('Ticket')->new({\n            created_by => logged_in_user->{id},\n            created_at => DateTime->now,\n        });\n    }\n\n    if ( body_parameters->get('attach') ) {\n        my $upload = request->upload('newattach')\n            or error __\"Please select a file to upload\";\n        my $attach = {\n            name        => $upload->basename,\n            ticket_id   => $id,\n            upload      => $upload,\n            mimetype    => $upload->type,\n        };\n\n        if (process sub { rset('Attach')->create_with_file($attach) })\n        {\n            my $args = {\n                login    => var('login'),\n                template => 'ticket/attach',\n                ticket   => $ticket,\n                url      => \"/ticket/\".$ticket->id,\n                subject  => \"Ticket \".$ticket->id.\" attachment added - \",\n                attach   => {\n                    data      => $upload->content,\n                    mime_type => $upload->type,\n                },\n            };\n            my $email = Lenio::Email->new(\n                config   => config,\n                schema   => schema,\n                uri_base => request->uri_base,\n                site     => $ticket->site, # rset('Site')->find(param 'site_id'),\n            );\n            $email->send($args);\n            success __\"File has been added successfully\";\n        }\n    }\n\n    if ( body_parameters->get('attachrm') ) {\n        error __\"You do not have permission to delete attachments\"\n            unless var('login')->is_admin;\n\n        if (process sub { rset('Attach')->find(body_parameters->get('attachrm'))->delete })\n        {\n            success __\"Attachment has been deleted successfully\";\n        }\n    }\n\n    if (body_parameters->get('delete'))\n    {\n        error __\"You do not have permission to delete this ticket\"\n            unless var('login')->is_admin || $ticket->actionee eq 'local';\n        if (process sub { $ticket->delete })\n        {\n            forwardHome({ success => \"Ticket has been successfully deleted\" }, 'tickets');\n        }\n    }\n\n    if (body_parameters->get('cancel_ticket'))\n    {\n        error __\"You do not have permission to cancel this ticket\"\n            unless var('login')->is_admin || $ticket->actionee eq 'local';\n        if (process sub { $ticket->update({ cancelled => DateTime->now }) })\n        {\n            forwardHome({ success => \"Ticket has been successfully cancelled\" }, 'tickets');\n        }\n    }\n\n    # Comment can be added on ticket creation or separately.  Create the\n    # object, which will be added at ticket insertion time or otherwise later.\n    my $comment = body_parameters->get('comment')\n        && rset('Comment')->new({\n            text      => body_parameters->get('comment'),\n            login_id  => var('login')->id,\n            datetime  => DateTime->now,\n        });\n\n    if (body_parameters->get('submit'))\n    {\n        # Find out if this is related to locally created task.\n        # If so, allow dates to be input\n        my $global = $task && $task->global;\n\n        my $completed   = (var('login')->is_admin || !$global) && _to_dt(param('completed'));\n        my $planned     = (var('login')->is_admin || !$global) && _to_dt(param('planned'));\n        my $provisional = (var('login')->is_admin || !$global) && _to_dt(param('provisional'));\n\n        $ticket->name(body_parameters->get('name'));\n        $ticket->description(body_parameters->get('description'));\n        $ticket->contractor_invoice(body_parameters->get('contractor_invoice'));\n        $ticket->contractor_id(body_parameters->get('contractor') || undef);\n        $ticket->cost_planned(body_parameters->get('cost_planned') || undef);\n        $ticket->cost_actual(body_parameters->get('cost_actual') || undef);\n        $ticket->actionee(body_parameters->get('actionee'));\n        $ticket->report_received(body_parameters->get('report_received') ? 1 : 0);\n        $ticket->invoice_sent(body_parameters->get('invoice_sent') ? 1 : 0);\n        $ticket->completed($completed);\n        $ticket->planned($planned);\n        $ticket->provisional($provisional);\n        $ticket->task_id($task && $task->id);\n        $ticket->site_id(body_parameters->get('site_id'));\n\n        # A normal user cannot edit a ticket that has already been created,\n        # unless it is related to a locally created task\n        if ($id)\n        {\n            error __\"You do not have permission to edit this ticket\"\n                unless var('login')->is_admin || $ticket->actionee eq 'local';\n        }\n        else {\n            error __\"You do not have permission to create a service item ticket\"\n                if $global && !var('login')->is_admin;\n        }\n\n        my $was_local = $id && $ticket->actionee eq 'local'; # Need old setting to see if to send email\n        if (process sub { $ticket->update_or_insert })\n        {\n            # XXX Ideally the comment would be written as a relationship\n            # at the same time as the ticket, but I couldn't get it to\n            # work ($ticket->comments([ .. ]) appears to do nothing)\n            if ($comment)\n            {\n                $comment->ticket_id($ticket->id);\n                $comment->insert;\n            }\n            my $template; my $subject; my $status;\n            if ($id)\n            {\n                $template = 'ticket/update';\n                $subject  = \"Ticket \".$ticket->id.\" updated - \";\n                $status   = 'updated';\n            }\n            else {\n                $template = 'ticket/new';\n                $subject  = \"New ticket ID \".$ticket->id.\" - \";\n                $status   = 'created';\n            }\n            my $args = {\n                login       => var('login'),\n                template    => $template,\n                ticket      => $ticket,\n                url         => \"/ticket/\".$ticket->id,\n                subject     => $subject,\n            };\n            # Assume send update to admin\n            my $send_email = 1;\n            # Do not send email update if new ticket and local, or was local and still is local only\n            $send_email = 0 if ((!$id && $ticket->actionee eq 'local') || ($id && $ticket->actionee eq 'local' && $was_local));\n            # Do not send email if local site task\n            $send_email = 0 if $task && !$task->global;\n            if ($send_email)\n            {\n                my $email = Lenio::Email->new(\n                    config   => config,\n                    schema   => schema,\n                    uri_base => request->uri_base,\n                    site     => $ticket->site,\n                );\n                $email->send($args);\n            }\n            forwardHome(\n                { success => \"Ticket \".$ticket->id.\" has been successfully $status\" }, 'ticket/'.$ticket->id );\n        }\n    }\n\n    if (my $submit = body_parameters->get('addcomment'))\n    {\n        $comment->ticket_id($ticket->id);\n        if ($submit eq 'private' && var('login')->is_admin)\n        {\n            $comment->admin_only(1);\n            if (process sub { $comment->insert })\n            {\n                forwardHome(\n                    { success => \"Comment has been added successfully\" }, 'ticket/'.$ticket->id );\n            }\n        }\n        else {\n            if (process sub { $comment->insert })\n            {\n                my $args = {\n                    login       => var('login'),\n                    template    => 'ticket/comment',\n                    url         => \"/ticket/$id\",\n                    ticket      => $ticket,\n                    subject     => \"Ticket \".$ticket->id.\" updated - \",\n                    comment     => body_parameters->get('comment'),\n                };\n                my $email = Lenio::Email->new(\n                    config   => config,\n                    schema   => schema,\n                    uri_base => request->uri_base,\n                    site     => $ticket->site,\n                );\n                $email->send($args);\n                forwardHome(\n                    { success => \"Comment has been added successfully\" }, 'ticket/'.$ticket->id );\n            }\n        }\n    }\n\n    template 'ticket' => {\n        id           => $id,\n        ticket       => $ticket,\n        contractors  => [rset('Contractor')->ordered],\n        dateformat   => config->{lenio}->{dateformat},\n        page         => 'ticket'\n    };\n};\n\nget '/tickets/?' => require_login sub {\n\n    # Deal with sort options\n    if (query_parameters->get('sort'))\n    {\n        if (my $order = query_parameters->get('order'))\n        {\n            session ticket_desc => $order eq 'desc' ? 1 : 0;\n        }\n        else {\n            session ticket_desc => session('ticket_sort') && session('ticket_sort') eq query_parameters->get('sort') ? !session('ticket_desc') : 0;\n        }\n        session ticket_sort => query_parameters->get('sort');\n    }\n\n    # Set filtering of tickets based on drop-down\n    my $ticket_filter = session 'ticket_filter';\n\n    my $filter_names = {\n        reactive        => {\n            url   => 'reactive',\n            group => 'type',\n            name  => 'Reactive tickets',\n        },\n        task            => {\n            url   => 'task',\n            group => 'type',\n            name  => 'Tickets for services',\n        },\n        not_planned     => {\n            url   => 'not-planned',\n            group => 'status',\n            name  => 'Not planned',\n        },\n        planned         => {\n            url   => 'planned',\n            group => 'status',\n            name  => 'Planned but not completed',\n        },\n        completed       => {\n            url   => 'completed',\n            group => 'status',\n            name  => 'Completed',\n        },\n        cancelled       => {\n            url   => 'cancelled',\n            group => 'status',\n            name  => 'Cancelled',\n        },\n        admin           => {\n            url   => 'admin',\n            group => 'actionee',\n            name  => 'Action currently on '.config->{lenio}->{invoice}->{company},\n        },\n        contractor      => {\n            url   => 'contractor',\n            group => 'actionee',\n            name  => 'Action on contractor',\n        },\n        local_action    => {\n            url   => 'local-action',\n            group => 'actionee',\n            name  => 'Action currently with site',\n        },\n        local_site      => {\n            url   => 'local-site',\n            group => 'actionee',\n            name  => 'To be rectified in-house',\n        },\n        this_month      => {\n            url   => 'this-month',\n            group => 'dates',\n            name  => 'This month',\n        },\n        next_month      => {\n            url   => 'next-month',\n            group => 'dates',\n            name  => 'Next month',\n        },\n        this_fy         => {\n            url   => 'this-fy',\n            group => 'dates',\n            name  => 'This financial year',\n        },\n        blank           => {\n            url   => 'blank',\n            group => 'dates',\n            name  => 'Dates blank',\n        },\n        no_invoice      => {\n            url   => 'no-invoice',\n            group => 'ir',\n            name  => 'Tickets without invoice',\n        },\n        no_invoice_sent => {\n            url   => 'no-invoice-sent',\n            group => 'ir',\n            name  => 'Tickets without invoice sent',\n        },\n        no_report       => {\n            url   => 'no-report',\n            group => 'ir',\n            name  => 'Tickets without report',\n        },\n    };\n\n    if (defined query_parameters->get('filter-type'))\n    {\n        if (my $tt = query_parameters->get('filter-type'))\n        {\n            $ticket_filter->{type}->{reactive} = !!query_parameters->get('set')\n                if $tt eq 'reactive';\n            $ticket_filter->{type}->{task} = !!query_parameters->get('set')\n                if $tt eq 'task';\n        }\n        else {\n            # Clear\n            delete $ticket_filter->{type};\n        }\n    }\n\n    if (defined query_parameters->get('filter-status'))\n    {\n        if (my $tt = query_parameters->get('filter-status'))\n        {\n            $ticket_filter->{status}->{not_planned} = !!query_parameters->get('set')\n                if $tt eq 'not-planned';\n            $ticket_filter->{status}->{planned} = !!query_parameters->get('set')\n                if $tt eq 'planned';\n            $ticket_filter->{status}->{completed} = !!query_parameters->get('set')\n                if $tt eq 'completed';\n            $ticket_filter->{status}->{cancelled} = !!query_parameters->get('set')\n                if $tt eq 'cancelled';\n        }\n        else {\n            # Clear\n            delete $ticket_filter->{status};\n        }\n    }\n\n    if (defined query_parameters->get('filter-actionee'))\n    {\n        if (my $tt = query_parameters->get('filter-actionee'))\n        {\n            $ticket_filter->{actionee}->{admin} = !!query_parameters->get('set')\n                if $tt eq 'admin';\n            $ticket_filter->{actionee}->{contractor} = !!query_parameters->get('set')\n                if $tt eq 'contractor';\n            $ticket_filter->{actionee}->{local_action} = !!query_parameters->get('set')\n                if $tt eq 'local-action';\n            $ticket_filter->{actionee}->{local_site} = !!query_parameters->get('set')\n                if $tt eq 'local-site';\n        }\n        else {\n            # Clear\n            delete $ticket_filter->{actionee};\n        }\n    }\n\n    if (defined query_parameters->get('filter-dates'))\n    {\n        if (my $tt = query_parameters->get('filter-dates'))\n        {\n            $ticket_filter->{dates}->{this_month} = !!query_parameters->get('set')\n                if $tt eq 'this-month';\n            $ticket_filter->{dates}->{next_month} = !!query_parameters->get('set')\n                if $tt eq 'next-month';\n            $ticket_filter->{dates}->{this_fy} = !!query_parameters->get('set')\n                if $tt eq 'this-fy';\n            $ticket_filter->{dates}->{blank} = !!query_parameters->get('set')\n                if $tt eq 'blank';\n        }\n        else {\n            # Clear\n            delete $ticket_filter->{dates};\n        }\n    }\n\n    if (defined query_parameters->get('filter-ir'))\n    {\n        if (my $tt = query_parameters->get('filter-ir'))\n        {\n            $ticket_filter->{ir}->{no_invoice} = !!query_parameters->get('set')\n                if $tt eq 'no-invoice';\n            $ticket_filter->{ir}->{no_invoice_sent} = !!query_parameters->get('set')\n                if $tt eq 'no-invoice-sent';\n            $ticket_filter->{ir}->{no_report} = !!query_parameters->get('set')\n                if $tt eq 'no-report';\n        }\n        else {\n            # Clear\n            delete $ticket_filter->{ir};\n        }\n    }\n\n    session ticket_filter => $ticket_filter;\n\n    if (defined query_parameters->get('task_id'))\n    {\n        if (my $task_id = query_parameters->get('task_id'))\n        {\n            session task_id => $task_id\n                if $task_id =~ /^[0-9]+$/;\n        }\n        else {\n            session task_id => undef;\n        }\n    }\n\n    my $task = session('task_id') && rset('Task')->find(session('task_id'));\n\n    my @tickets = rset('Ticket')->summary(\n        login     => var('login'),\n        site_id   => query_parameters->get('site_id') || var('site_ids'),\n        sort      => session('ticket_sort'),\n        sort_desc => session('ticket_desc'),\n        task_id   => $task && $task->id,\n        filter    => $ticket_filter,\n    );\n\n    my @selected_filters;\n    foreach my $type (keys %$ticket_filter)\n    {\n        foreach my $name (keys %{$ticket_filter->{$type}})\n        {\n            push @selected_filters, $name if $ticket_filter->{$type}->{$name};\n        }\n    };\n\n    template 'tickets' => {\n        task             => $task, # Tickets related to task\n        site_tasks       => [rset('Task')->site_tasks_grouped(site_ids => var('site_ids'))],\n        tickets          => \\@tickets,\n        sort             => session('ticket_sort'),\n        sort_desc        => session('ticket_desc'),\n        dateformat       => config->{lenio}->{dateformat},\n        ticket_filter    => session('ticket_filter'),\n        selected_filters => \\@selected_filters,\n        filter_names     => $filter_names,\n        page             => 'ticket'\n    };\n};\n\nget '/attach/:file' => require_login sub {\n    my $file = rset('Attach')->find(route_parameters->get('file'))\n        or error __x\"File ID {id} not found\", id => route_parameters->get('file');\n    my $site_id = $file->ticket->site_id;\n    if ( var('login')->has_site($site_id))\n    {\n        send_file( $file->content, content_type => $file->mimetype, system_path => 1 );\n    } else {\n        forwardHome(\n            { danger => 'You do not have permission to view this file' } );\n    }\n};\n\nany ['get', 'post'] => '/invoice/:id' => require_login sub {\n\n    my $id      = route_parameters->get('id');\n    my $invoice = defined $id && (rset('Invoice')->find($id) || rset('Invoice')->new({}));\n    my $ticket  = query_parameters->get('ticket') && rset('Ticket')->find(query_parameters->get('ticket'));\n\n    if (defined query_parameters->get('download'))\n    {\n        my %options = %{config->{lenio}->{invoice}};\n        $options{dateformat} = config->{lenio}->{dateformat};\n        my $pdf = $invoice->pdf(%options);\n\treturn send_file(\n\t    \\$pdf,\n\t    content_type => 'application/pdf',\n\t    filename     => (config->{lenio}->{invoice}->{prefix}).$invoice->id.\".pdf\",\n\t);\n    }\n\n    var('login')->is_admin\n        or forwardHome({ danger => 'You do not have permission to edit invoices' });\n\n    if (body_parameters->get('delete'))\n    {\n        if (process (sub { $invoice->delete } ) )\n        {\n            forwardHome({ success => 'The invoice has been successfully deleted' }, 'invoices');\n        }\n    }\n\n    if (body_parameters->get('submit'))\n    {\n        $ticket or error __\"No ticket specified to create the invoice for\";\n        $invoice->description(body_parameters->get('description'));\n        $invoice->number(body_parameters->get('number'));\n        $invoice->disbursements(body_parameters->get('disbursements') || undef);\n        $invoice->ticket_id($ticket->id);\n        $invoice->datetime(DateTime->now)\n            if !$id;\n        if (process sub { $invoice->update_or_insert })\n        {\n            # Email new invoice to users\n            my %options = %{config->{lenio}->{invoice}};\n            $options{dateformat} = config->{lenio}->{dateformat};\n            my $pdf = $invoice->pdf(%options);\n            my $args = {\n                login    => var('login'),\n                template => 'ticket/invoice',\n                ticket   => $ticket,\n                url      => \"/ticket/\".$ticket->id,\n                subject  => \"Ticket \".$ticket->id.\" invoice added - \",\n                attach   => {\n                    data      => $pdf,\n                    mime_type => 'application/pdf',\n                },\n            };\n            my $email = Lenio::Email->new(\n                config   => config,\n                schema   => schema,\n                uri_base => request->uri_base,\n                site     => $ticket->site, # rset('Site')->find(param 'site_id'),\n            );\n            $email->send($args);\n\n            my $action = $id ? 'updated' : 'created';\n            $id = $invoice->id;\n            forwardHome({ success => \"The invoice has been successfully $action\" }, \"invoice/$id\");\n        }\n\n    }\n\n    template 'invoice' => {\n        id      => $id,\n        invoice => $invoice,\n        ticket  => $ticket,\n        page    => 'invoice'\n    };\n};\n\nget '/invoices' => require_login sub {\n\n    if (query_parameters->get('sort'))\n    {\n        session invoice_desc => session('invoice_sort') && session('invoice_sort') eq query_parameters->get('sort') ? !session('invoice_desc') : 0;\n        session invoice_sort => query_parameters->get('sort');\n    }\n\n    my @invoices = rset('Invoice')->summary(\n        login     => var('login'),\n        site_id   => var('site_ids'),\n        sort      => session('invoice_sort'),\n        sort_desc => session('invoice_desc'),\n    );\n\n    template 'invoices' => {\n        invoices => \\@invoices,\n        page     => 'invoice'\n    };\n};\n\nany ['get', 'post'] => '/task/?:id?' => require_login sub {\n\n    my $action;\n    my $id = route_parameters->get('id');\n\n    if (var('login')->is_admin)\n    {\n        session('site_id') or error \"Please select a single site first\";\n        if (body_parameters->get('taskadd'))\n        {\n            rset('SiteTask')->find_or_create({ task_id => body_parameters->get('taskadd'), site_id => session('site_id') });\n        }\n        if (body_parameters->get('taskrm'))\n        {\n            rset('SiteTask')->search({ task_id => body_parameters->get('taskrm'), site_id => session('site_id') })->delete;\n        }\n    }\n\n    my $task = defined($id) && ($id && rset('Task')->find($id) || rset('Task')->new({}));\n\n    my @tasks; my @tasks_local; my @adhocs;\n\n    if ($task && $task->id)\n    {\n        # Check whether the user has access to this task\n        my @sites = map { $_->site_id } $task->site_tasks->all;\n        forwardHome(\n            { danger => \"You do not have permission for service item $id\" } )\n                unless var('login')->is_admin || (!$task->global && var('login')->has_site(@sites));\n    }\n\n    if (body_parameters->get('delete'))\n    {\n        my $site_id = $task->site_task_local && $task->site_task_local->site_id; # Site ID for local tasks\n        if (var('login')->is_admin)\n        {\n            if (process sub { $task->delete })\n            {\n                    forwardHome({ success => 'Service item has been successfully deleted' }, 'task' );\n            }\n        }\n        elsif (var('login')->has_site($site_id))\n        {\n            if (process sub { $task->delete })\n            {\n                    forwardHome({ success => 'Service item has been successfully deleted' }, 'task' );\n            }\n        }\n        else {\n            error __x\"You do not have permission to delete task ID {id}\", id => $id;\n        }\n    }\n\n    if ( var('login')->is_admin && body_parameters->get('tasktype_add') )\n    {\n        if (process sub { rset('Tasktype')->create({name => body_parameters->get('tasktype_name')}) })\n        {\n            forwardHome(\n                { success => 'Task type has been added' }, \"task/$id\" );\n        }\n    }\n\n    my $download = {\n        default_from => DateTime->now->subtract(months => 1),\n        default_to   => DateTime->now,\n    };\n    if (body_parameters->get('download_site_checks'))\n    {\n        session('site_id') or error \"Please select a single site first\";\n        my $from = _to_dt(body_parameters->get('download_from') || $download->{default_from});\n        my $to = _to_dt(body_parameters->get('download_to') || $download->{default_to});\n        my $csv = rset('CheckDone')->summary_csv(\n            from       => $from,\n            to         => $to,\n            site_id    => session('site_id'),\n            dateformat => $dateformat,\n        );\n\n        my $site = rset('Site')->find(session 'site_id')->org->name;\n        utf8::encode($csv);\n        return send_file(\n            \\$csv,\n            content_type => 'text/csv; chrset=\"utf-8\"',\n            filename     => \"$site site checks \".$from->strftime($dateformat).\" to \".$to->strftime($dateformat).\".csv\"\n        );\n    }\n\n    if (body_parameters->get('populate'))\n    {\n        session('site_id') or error \"Please select a single site first\";\n        my $year = body_parameters->get('populate_from');\n        if (process sub { rset('Task')->populate_tickets(\n                site_id  => session('site_id'),\n                from     => $year,\n                to       => session('fy'),\n                login_id => var('login')->id,\n            ) })\n        {\n            forwardHome({ success => 'Tickets have been populated successfully' }, 'task' );\n        }\n    }\n\n    if ( body_parameters->get('submit') )\n    {\n        session('site_id') or error \"Please select a single site first\";\n        if (var('login')->is_admin)\n        {\n            $task->global(1);\n        }\n        else\n        {\n            $task->set_site_id(session('site_id'));\n            $task->global(0);\n        }\n\n        $task->name(body_parameters->get('name'));\n        $task->description(body_parameters->get('description'));\n        $task->contractor_requirements(body_parameters->get('contractor_requirements'));\n        $task->evidence_required(body_parameters->get('evidence_required'));\n        $task->statutory(body_parameters->get('statutory'));\n        $task->tasktype_id(body_parameters->get('tasktype_id') || undef); # Fix empty string from form\n        $task->period_qty(body_parameters->get('period_qty'));\n        $task->period_unit(body_parameters->get('period_unit'));\n\n        if (process sub { $task->update_or_insert })\n        {\n                forwardHome({ success => 'Service item has been successfully created' }, 'task' );\n        }\n    }\n\n    else\n    {\n        session('site_id') or error \"Please select a single site first\";\n        my $csv = (session('site_id') && query_parameters->get('csv')) || \"\"; # prevent warnings. not for all sites\n\n        if ($csv eq 'service')\n        {\n\n            my $csvout = rset('Task')->csv(\n                site_id    => session('site_id'),\n                global     => 1,\n                fy         => session('fy'),\n                dateformat => $dateformat,\n            );\n\n            my $now = DateTime->now->ymd;\n            my $site = rset('Site')->find(session 'site_id')->org->name;\n            # XXX Is this correct? We can't send native utf-8 without getting the error\n            # \"Strings with code points over 0xFF may not be mapped into in-memory file handles\".\n            # So, encode the string (e.g. \"\\x{100}\"  becomes \"\\xc4\\x80) and then send it,\n            # telling the browser it's utf-8\n            utf8::encode($csvout);\n            return send_file(\n                \\$csvout,\n                content_type => 'text/csv; chrset=\"utf-8\"',\n                filename     => \"$site service items $now.csv\"\n            );\n        }\n\n        if (var('login')->is_admin && query_parameters->get('sla') && query_parameters->get('sla') eq 'pdf')\n        {\n            session('site_id') or error \"Please select a single site first\";\n            my $site = rset('Site')->find(session 'site_id');\n\n            my $pdf = rset('Task')->sla(\n                fy         => session('fy'),\n                site       => $site,\n                dateformat => $dateformat,\n                %{config->{lenio}->{invoice}},\n            );\n\n            my $now = DateTime->now->ymd;\n            return send_file(\n                \\$pdf->content,\n                content_type => 'application/pdf',\n                filename     => $site->org->name.\" Service Level Agreement $now.pdf\"\n            );\n        }\n\n        if (var('login')->is_admin && query_parameters->get('finsum') && query_parameters->get('finsum') eq 'pdf')\n        {\n            session('site_id') or error \"Please select a single site first\";\n            my $site = rset('Site')->find(session 'site_id');\n\n            my $pdf = rset('Task')->finsum(\n                fy         => session('fy'),\n                site       => $site,\n                dateformat => $dateformat,\n                %{config->{lenio}->{invoice}},\n            );\n\n            my $now = DateTime->now->ymd;\n            return send_file(\n                \\$pdf->content,\n                content_type => 'application/pdf',\n                filename     => $site->org->name.\" Financial Summary $now.pdf\"\n            );\n        }\n\n        # Get all the global tasks.\n        @tasks = rset('Task')->summary(site_id => var('site_ids'), global => 1, fy => session('fy'), onlysite => 1);\n\n        # Get any adhoc tasks\n        @adhocs = rset('Ticket')->summary(\n            login        => var('login'),\n            site_id      => var('site_ids'),\n            task_tickets => 0,\n            fy           => session('site_id') && session('fy'),\n            filter       => {\n                type => {\n                    reactive => 1,\n                },\n                costs => {\n                    actual => 1,\n                },\n            },\n        ) if var('site_ids');\n        if ($csv eq 'reactive')\n        {\n            my $csv = Text::CSV->new;\n            my @headings = qw/title cost_planned cost_actual completed contractor/;\n            $csv->combine(@headings);\n            my $csvout = $csv->string.\"\\n\";\n            my ($cost_planned_total, $cost_actual_total);\n            foreach my $adhoc (@adhocs)\n            {\n                my @row = (\n                    $adhoc->name,\n                    $adhoc->cost_planned,\n                    $adhoc->cost_actual,\n                    $adhoc->completed && $adhoc->completed->strftime($dateformat),\n                    $adhoc->contractor && $adhoc->contractor->name,\n                );\n                $csv->combine(@row);\n                $csvout .= $csv->string.\"\\n\";\n                $cost_planned_total += ($adhoc->cost_planned || 0);\n                $cost_actual_total  += ($adhoc->cost_actual || 0);\n            }\n            $csv->combine('Totals:', sprintf(\"%.2f\", $cost_planned_total), sprintf(\"%.2f\", $cost_actual_total),'','');\n            $csvout .= $csv->string.\"\\n\";\n            my $now = DateTime->now->ymd;\n            my $site = rset('Site')->find(session 'site_id')->org->name;\n            utf8::encode($csvout); # See comment above\n            return send_file(\n                \\$csvout,\n                content_type => 'text/csv; chrset=\"utf-8\"',\n                filename     => \"$site reactive $now.csv\"\n            );\n        }\n        # Get all the local tasks\n        @tasks_local = rset('Task')->summary(site_id => var('site_ids'), global => 0, onlysite => 1, fy => session('fy'));\n        $action = '';\n    }\n\n    my $show_populate = ! grep $_->get_column('cost_planned'), @tasks;\n\n    template 'task' => {\n        show_populate    => $show_populate,\n        dateformat       => $dateformat,\n        download         => $download,\n        action           => $action,\n        site             => rset('Site')->find(session 'site_id'),\n        site_checks      => [rset('Task')->site_checks(session 'site_id')],\n        task             => $task,\n        tasks            => \\@tasks,\n        all_tasks        => [rset('Task')->global->all],\n        tasks_local      => \\@tasks_local,\n        tasktypes        => [rset('Tasktype')->all],\n        adhocs           => \\@adhocs,\n        page             => 'task'\n    };\n};\n\nget '/data' => require_login sub {\n\n    my $utc_offset = query_parameters->get('utc_offset') * -1; # Passed from calendar plugin as query parameter\n    my $from  = DateTime->from_epoch( epoch => ( query_parameters->get('from') / 1000 ) )->add( minutes => $utc_offset );\n    my $to    = DateTime->from_epoch( epoch => ( query_parameters->get('to') / 1000 ) )->add(minutes => $utc_offset );\n    my $login = var('login');\n\n    my @tasks;\n    my @sites = rset('Site')->search({\n        'me.id' => var('site_ids'),\n    });\n    foreach my $site (@sites) {\n        my $calendar = Lenio::Calendar->new(\n            from           => $from,\n            to             => $to,\n            site           => $site,\n            multiple_sites => @sites > 1,\n            contractors    => session('contractors'),\n            login          => $login,\n            schema         => schema,\n            dateformat     => $dateformat,\n        );\n        push @tasks, $calendar->tasks;\n        push @tasks, $calendar->checks\n            if !$login->is_admin;\n    }\n    _send_json ({\n        success => 1,\n        result => \\@tasks\n    });\n};\n\nsub forwardHome {\n    my ($message, $page, %options) = @_;\n\n    if ($message)\n    {\n        my ($type) = keys %$message;\n        my $lroptions = {};\n        # Check for option to only display to user (e.g. passwords)\n        $lroptions->{to} = 'error_handler' if $options{user_only};\n\n        if ($type eq 'danger')\n        {\n            $lroptions->{is_fatal} = 0;\n            report $lroptions, ERROR => $message->{$type};\n        }\n        else {\n            report $lroptions, NOTICE => $message->{$type}, _class => 'success';\n        }\n    }\n    $page ||= '';\n    redirect \"/$page\";\n}\n\nsub _send_json\n{   header \"Cache-Control\" => \"max-age=0, must-revalidate, private\";\n    content_type 'application/json';\n    encode_json(shift);\n}\n\nsub password_generator\n{   $password_generator->xkcd( words => 3 );\n}\n\nsub _to_dt\n{   my $parser = DateTime::Format::Strptime->new(\n         pattern   => '%Y-%m-%d',\n         time_zone => 'local',\n    );\n    $parser->parse_datetime(shift);\n}\n\ntrue;\n"], "fixing_code": ["=pod\nLenio - Web-based Facilities Management Software\nCopyright (C) 2013 A Beverley\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU Affero General Public License as\npublished by the Free Software Foundation, either version 3 of the\nLicense, or (at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Affero General Public License for more details.\n\nYou should have received a copy of the GNU Affero General Public License\nalong with this program.  If not, see <http://www.gnu.org/licenses/>.\n=cut\n\npackage Lenio;\n\nuse CtrlO::Crypt::XkcdPassword;\nuse Dancer2;\nuse Dancer2::Core::Cookie;\nuse DateTime::Format::Strptime;\nuse JSON qw(encode_json);\nuse Lenio::Calendar;\nuse Lenio::Config;\nuse Lenio::Email;\nuse Session::Token;\nuse Text::CSV;\n\nuse Dancer2::Plugin::DBIC;\nuse Dancer2::Plugin::Auth::Extensible;\nuse Dancer2::Plugin::LogReport;\n\nset behind_proxy => config->{behind_proxy};\n\nLenio::Config->instance(\n    config => config,\n);\n\nour $VERSION = '0.1';\n\n# There should never be exceptions from DBIC, so we want to panic them to\n# ensure they get notified at the correct level.\nschema->exception_action(sub {\n    # Older versions of DBIC use this handler during expected exceptions.\n    # Temporary hack: do not panic these as DBIC does not catch them\n    die $_[0] if $_[0] =~ /^Unable to satisfy requested constraint/; # Expected\n    die $_[0] if $_[0] =~ /MySQL server has gone away/; # Expected\n    panic @_; # Not expected\n});\n\nmy $dateformat = config->{lenio}->{dateformat};\n\nmy $password_generator = CtrlO::Crypt::XkcdPassword->new;\n\nsub _update_csrf_token\n{   session csrf_token => Session::Token->new(length => 32)->get;\n}\n\nhook before => sub {\n\n    # Used to display error messages\n    return if param 'error';\n\n    my $user = logged_in_user\n\n    my $method      = request->method;\n    my $path        = request->path;\n    my $query       = request->query_string;\n    my $username    = $user && $user->{username};\n    my $description = $user\n        ? qq(User \"$username\" made \"$method\" request to \"$path\")\n        : qq(Unauthenticated user made \"$method\" request to \"$path\");\n    $description .= qq( with query \"$query\") if $query;\n    # Log to audit\n    rset('Audit')->user_action(description => $description, url => $path, method => $method, login_id => $user && $user->{id});\n\n    $user\n        or return;\n\n    header \"X-Frame-Options\" => \"DENY\"; # Prevent clickjacking\n\n    if (!session 'csrf_token')\n    {\n        _update_csrf_token();\n    }\n\n    if (request->is_post)\n    {\n        # Protect against CSRF attacks\n        panic __x\"csrf-token missing for path {path}\", path => request->path\n            if !param 'csrf_token';\n        error __x\"Suspected attack: CSRF token does not match that in the session\"\n            if param('csrf_token') ne session('csrf_token');\n\n        # If it's a potential login, change the token\n        _update_csrf_token()\n            if request->path eq '/login';\n    }\n\n    my $login = rset('Login')->find($user->{id});\n\n    # Do not try and get sites etc if logging out. User may have received \"no\n    # sites associated\" error and be trying to logout, in which case we don't\n    # want to run the following code as it will generate errors\n    return if request->uri eq '/logout';\n\n    # Sites associated with the user \n    forward '/error', { 'error' => 'There are no sites associated with this username' }\n        unless $login->sites;\n \n    # Select individual site and check user has access\n    if ( query_parameters->get('site') && query_parameters->get('site') eq 'all' ) {\n        session site_id => '';\n        session group_id => undef;\n    }\n    elsif ($login->is_admin && query_parameters->get('group'))\n    {\n        session site_id => undef;\n        session group_id => query_parameters->get('group');\n    }\n    elsif ( query_parameters->get('site') ) {\n        session site_id => query_parameters->get('site')\n            if $login->has_site(query_parameters->get('site'));\n        session group_id => undef;\n    }\n    elsif (!defined(session 'site_id') && !defined(session 'group_id')) {\n        session(site_id => ($login->sites)[0]->id) unless (defined session('site_id'));\n    }\n\n    my $contractors = session('contractors') || {};\n    if (my $contractor_id = query_parameters->get('contractor'))\n    {\n        if ($contractors->{$contractor_id}) {\n            delete $contractors->{$contractor_id};\n        } else {\n            $contractors->{$contractor_id} = 1;\n        }\n    }\n    elsif (defined query_parameters->get('contractor')) # clear all\n    {\n        $contractors = {};\n    }\n    session 'contractors' => $contractors;\n\n    my $site_ids = $login->is_admin && session('site_id')\n                 ? session('site_id')\n                 : $login->is_admin && session('group_id') && rset('Group')->find(session 'group_id')\n                 ? rset('Group')->find(session 'group_id')->site_ids\n                 : session('site_id')\n                 ? session('site_id')\n                 : $login->site_ids;\n    var site_ids => $site_ids;\n\n    session 'fy' => query_parameters->get('fy') if query_parameters->get('fy');\n    session 'fy' => Lenio::FY->new(site_id => session('site_id'), schema => schema)->year\n        if !session('fy');\n\n    var login => $login;\n};\n\nhook before_template => sub {\n    my $tokens = shift;\n\n    my $base = $tokens->{base} || request->base;\n    $tokens->{url}->{css}  = \"${base}css\";\n    $tokens->{url}->{js}   = \"${base}js\";\n    $tokens->{url}->{page} = $base;\n    $tokens->{url}->{page} =~ s!.*/!!; # Remove trailing slash\n    $tokens->{scheme}    ||= request->scheme; # May already be set for phantomjs requests\n    $tokens->{hostlocal}   = config->{gads}->{hostlocal};\n\n    $tokens->{messages}   = session('messages');\n    $tokens->{csrf_token} = session 'csrf_token';\n    $tokens->{login}      = var('login');\n    $tokens->{groups}     = [schema->resultset('Group')->ordered];\n    $tokens->{contractors} = [rset('Contractor')->ordered];\n    $tokens->{contractors_selected} = session 'contractors';\n    $tokens->{company_name} = config->{lenio}->{invoice}->{company};\n    $tokens->{logo} = config->{lenio}->{logo};\n};\n\nget '/' => require_login sub {\n\n    # Deal with sort options\n    if (query_parameters->get('sort'))\n    {\n        session task_desc => session('task_sort') && session('task_sort') eq query_paremeters->get('sort') ? !session('task_desc') : 0;\n        session task_sort => query_parameters->get('sort');\n    }\n\n    # Overdue tasks for non-global items are not being used so are now removed\n    # from the template. Code retained here anyway for time being.\n    my $local = var('login')->is_admin ? 0 : 1; # Only show local tasks for non-admin\n    my @overdue = rset('Task')->overdue(\n        site_id   => var('site_ids'),\n        login     => var('login'),\n        local     => $local,\n        sort      => session('task_sort'),\n        sort_desc => session('task_desc'),\n    );\n    template 'index' => {\n        dateformat => config->{lenio}->{dateformat},\n        tasks      => \\@overdue,\n        page       => 'index'\n    };\n};\n\nsub login_page_handler\n{\n    my $messages = session('messages') || undef;\n    success __\"A password reset request has been sent if the email address\n           entered was valid\" if defined param('reset_sent');\n    if (defined param('login_failed'))\n    {\n        status 401;\n        report {is_fatal=>0}, ERROR => \"Username or password not valid\";\n    }\n    template login => {\n        page                => 'login',\n        new_password        => request->parameters->get('new_password'),\n        password_code_valid => request->parameters->get('password_code_valid'),\n        reset_code          => request->parameters->get('new_password') || request->parameters->get('password_code_valid'),\n    };\n}\n\nget '/logout' => sub {\n    app->destroy_session;\n    rset('Audit')->logout(logged_in_user->{username}, logged_in_user->{id}) = @_;\n    forwardHome();\n};\n\n# Dismiss a notice\npost '/close/:id' => require_login sub {\n    my $notice = rset('LoginNotice')->find(route_parameters->get('id')) or return;\n    $notice->delete if $notice->login_id == var('login')->id;\n};\n\nany ['get', 'post'] => '/user/:id' => require_login sub {\n\n    my $is_admin = var('login')->is_admin;\n    my $id       = $is_admin ? route_parameters->get('id') : var('login')->id;\n\n    my $email_comment = body_parameters->get('email_comment') ? 1 : 0;\n    my $email_ticket  = body_parameters->get('email_ticket') ? 1 : 0;\n    my $only_mine  = body_parameters->get('only_mine') ? 1 : 0;\n    if (!$id && $is_admin && body_parameters->get('submit'))\n    {\n        my $email = body_parameters->get('email')\n            or error \"Please enter an email address for the new user\";\n        # check existing\n        rset('Login')->active_rs->search({ email => $email })->count\n            and error __x\"The email address {email} already exists\", email => $email;\n        my $newuser = create_user username => $email, email => $email, realm => 'dbic', email_welcome => 1;\n        $id = $newuser->{id};\n        # Default to on\n        $email_comment = 1;\n        $email_ticket  = 1;\n    }\n\n    my $login    = $id && rset('Login')->find($id);\n    $id && !$login and error \"User ID {id} not found\", id => $id;\n\n    if ($is_admin && body_parameters->get('delete'))\n    {\n        if (process sub { $login->disable })\n        {\n            forwardHome({ success => \"User has been deleted successfully\" }, 'users');\n        }\n    }\n\n    if (body_parameters->get('submit')) {\n        $login->username(body_parameters->get('email'));\n        $login->email(body_parameters->get('email'));\n        $login->firstname(body_parameters->get('firstname'));\n        $login->surname(body_parameters->get('surname'));\n        $login->email_comment($email_comment);\n        $login->email_ticket($email_ticket);\n        $login->only_mine($only_mine);\n\n        $login->is_admin(body_parameters->get('is_admin') ? 1 : 0)\n            if $is_admin;\n        if ($is_admin && !$login->is_admin)\n        {\n            my @org_ids = body_parameters->get_all('org_ids');\n            $login->update_orgs(@org_ids);\n        }\n        if (process sub { $login->update_or_insert } )\n        {\n            my $forward = $is_admin ? 'users' : '';\n            forwardHome({ success => \"User has been submitted successfully\" }, $forward);\n        }\n    }\n\n    my @orgs = rset('Org')->all;\n    template 'user' => {\n        id         => $id,\n        orgs       => \\@orgs,\n        edit_login => $login,\n        page       => 'user'\n    };\n};\n\nget '/users/?' => require_login sub {\n\n    var('login')->is_admin\n        or error \"You do not have access to this page\";\n\n    template 'users' => {\n        logins    => [rset('Login')->active],\n        page      => 'user'\n    };\n};\n\nany ['get', 'post'] => '/group/:id' => require_login sub {\n\n    var('login')->is_admin\n        or error \"You do not have access to this page\";\n\n    my $id = route_parameters->get('id');\n\n    my $group = ($id && rset('Group')->find($id)) || rset('Group')->new({});\n\n    if (body_parameters->get('submit'))\n    {\n        $group->name(body_parameters->get('name'));\n        $group->set_site_ids([body_parameters->get_all('site_ids')]);\n        if (process sub { $group->write })\n        {\n            forwardHome(\n                { success => 'The group has been successfully updated' }, 'groups' );\n        }\n    }\n\n    template 'group' => {\n        group => $group,\n        sites => [rset('Site')->ordered_org->all],\n        page  => 'group'\n    };\n};\n\nget '/groups/?' => require_login sub {\n\n    var('login')->is_admin\n        or error \"You do not have access to this page\";\n\n    template 'groups' => {\n        groups => [rset('Group')->ordered],\n        page   => 'groups'\n    };\n};\n\nany ['get', 'post'] => '/contractor/?:id?' => require_login sub {\n\n    var('login')->is_admin\n        or forwardHome({ danger => 'You do not have permission to view contractors' });\n\n    my $contractor;\n    my $id = route_parameters->get('id');\n    if (defined $id)\n    {\n        $contractor = rset('Contractor')->find($id) || rset('Contractor')->new({});\n    }\n\n    if (body_parameters->get('delete'))\n    {\n        if (process (sub { $contractor->delete } ) )\n        {\n            forwardHome({ success => 'Contractor has been successfully deleted' }, 'contractor');\n        }\n    }\n\n    if (body_parameters->get('submit'))\n    {\n        $contractor->name(body_parameters->get('name'));\n        if (process sub { $contractor->update_or_insert })\n        {\n            forwardHome({ success => 'Contractor has been successfully added' }, 'contractor');\n        }\n    }\n\n    template 'contractor' => {\n        id          => $id,\n        contractor  => $contractor,\n        contractors => [rset('Contractor')->ordered],\n        page        => 'contractor'\n    };\n};\n\nany ['get', 'post'] => '/notice/?:id?' => require_login sub {\n\n    var('login')->is_admin\n        or forwardHome({ danger => 'You do not have permission to view notice settings' });\n\n    my $id = route_parameters->get('id');\n    my $notice = defined $id && (rset('Notice')->find($id) || rset('Notice')->new({}));\n\n    if (body_parameters->get('delete'))\n    {\n        if (process (sub { $notice->delete } ) )\n        {\n            forwardHome({ success => 'The notice has been successfully deleted' }, 'notice');\n        }\n    }\n\n    if (body_parameters->get('submit'))\n    {\n        $notice->text(body_parameters->get('text'));\n        if (process sub { $notice->update_or_insert })\n        {\n            forwardHome({ success => 'The notice has been successfully created' }, 'notice');\n        }\n    }\n\n    template 'notice' => {\n        id      => $id,\n        notice  => $notice,\n        notices => [rset('Notice')->all_with_count],\n        page    => 'notice'\n    };\n};\n \nany ['get', 'post'] => '/check_edit/:id' => require_login sub {\n\n    my $id = route_parameters->get('id');\n\n    my $check = ($id && rset('Task')->find($id)) || rset('Task')->new({ site_check => 1, global => 0 });\n\n    my $site_id = ($check && ($check->site_tasks)[0] && ($check->site_tasks)[0]->site_id) || body_parameters->get('site_id');\n    error \"You do not have access to this check\"\n        if $id && !var('login')->has_site($site_id);\n\n    if (body_parameters->get('submitcheck') && !$check->deleted)\n    {\n        $check->name(body_parameters->get('name'));\n        $check->description(body_parameters->get('description'));\n        $check->period_qty(body_parameters->get('period_qty'));\n        $check->period_unit(body_parameters->get('period_unit'));\n        $check->set_site_id(body_parameters->get('site_id'));\n        if (process sub { $check->update_or_insert })\n        {\n            forwardHome(\n                { success => 'The site check has been successfully updated' }, 'task' );\n        }\n    }\n\n    if (body_parameters->get('submit_name'))\n    {\n        my $checkitem = body_parameters->get('checkitemid')\n            ? rset('CheckItem')->find(body_parameters->get('checkitemid'))\n            : rset('CheckItem')->create({ task_id => $id });\n        error \"You do not have access to this check item\"\n            if body_parameters->get('checkitemid') && $checkitem->task->id != $check->id;\n        $checkitem->name(body_parameters->get('checkitem'));\n        if (process sub { $checkitem->insert_or_update } )\n        {\n            my $status = body_parameters->get('checkitemid') ? 'updated' : 'added';\n            forwardHome(\n                { success => \"The check item has been $status successfully\" }, \"check_edit/$id\" );\n        }\n    }\n\n    if (body_parameters->get('submit_options'))\n    {\n        my $checkitem = rset('CheckItem')->find(body_parameters->get('checkitemid'));\n        error \"You do not have access to this check item\"\n            if body_parameters->get('checkitemid') && $checkitem->task->id != $check->id;\n        if (process sub {\n            $checkitem->update({ has_custom_options => body_parameters->get('has_custom_options') ? 1 : 0 });\n            my @options = body_parameters->get_all('check_option');\n            # options are id followed by name\n            my %existing;\n            while (@options)\n            {\n                my $option_id = shift @options;\n                my $option_name = shift @options;\n                next if !$option_id && !$option_name;\n                my $option = $option_id\n                    ? rset('CheckItemOption')->find($option_id)\n                    : rset('CheckItemOption')->new({ check_item_id => $checkitem->id });\n                error \"You do not have access to this check item option\"\n                    if $option_id && $option->check_item_id != $checkitem->id;\n                $option->name($option_name);\n                $option->insert_or_update;\n                $existing{$option->id} = 1;\n            }\n            foreach my $ci (rset('CheckItemOption')->search({ check_item_id => $checkitem->id })->all)\n            {\n                $ci->update({ is_deleted => 1 }) if !$existing{$ci->id};\n            }\n        })\n        {\n            forwardHome(\n                { success => \"The check item has been updated successfully\" }, \"check_edit/$id\" );\n        }\n    }\n\n    if (body_parameters->get('delete'))\n    {\n        if (process sub { $check->update({ deleted => DateTime->now }) })\n        {\n            forwardHome(\n                { success => 'The check has been successfully deleted' }, 'task' );\n        }\n    }\n\n    template 'check_edit' => {\n        check       => $check,\n        site_id     => session('site_id'),\n        page        => 'check_edit'\n    };\n};\n\nget '/checks/?' => require_login sub {\n\n    my $site_id = session 'site_id'\n        or error __\"Please select a single site before viewing site checks\";\n\n    template 'checks' => {\n        site        => rset('Site')->find(session 'site_id'),\n        site_checks => [rset('Task')->site_checks($site_id)],\n        dateformat  => config->{lenio}->{dateformat},\n        page        => 'check',\n    };\n};\n\nany ['get', 'post'] => '/check/?:task_id?/?:check_done_id?/?' => require_login sub {\n\n    my $task_id       = route_parameters->get('task_id');\n    my $check_done_id = route_parameters->get('check_done_id');\n    my $check         = rset('Task')->find($task_id);\n\n    my $site_id = session 'site_id'\n        or error __\"Please select a single site before viewing site checks\";\n\n    my $check_done = $check_done_id ? rset('CheckDone')->find($check_done_id) : rset('CheckDone')->new({});\n\n    my $check_site_id = ($check->site_tasks)[0]->site_id;\n    error \"You do not have access to this check\"\n        unless var('login')->has_site($check_site_id);\n\n    if (body_parameters->get('submit_check_done'))\n    {\n        my $site_task_id = $check_done_id ? $check_done->site_task_id : rset('SiteTask')->search({\n            task_id => $task_id,\n            site_id => $site_id,\n        })->next->id;\n        # Log the completion of a site check\n        # Check user has permission first\n        error __x\"You do not have permission for site ID {id}\", id => $site_id\n            unless var('login')->has_site_task( $site_task_id );\n\n        my $datetime = _to_dt(body_parameters->get('completed')) || DateTime->now;\n\n        $check_done->datetime($datetime);\n        $check_done->comment(body_parameters->get('comment'));\n        $check_done->site_task_id($site_task_id);\n        $check_done->login_id(var('login')->id);\n        $check_done->update_or_insert;\n\n        my $params = body_parameters;\n        foreach my $key (keys %$params)\n        {\n            next unless $key =~ /^item([0-9]+)/;\n            my $check_item_id = $1;\n            my $check_item = rset('CheckItem')->find($check_item_id)\n                or error \"Check item not found\";\n            $check_item->task_id == $check->id\n                or error \"Check item is not valid\";\n            if ($check_item->has_custom_options)\n            {\n                my $check_item_done = rset('CheckItemDone')->update_or_create({\n                    check_item_id => $check_item_id,\n                    check_done_id => $check_done->id,\n                    status_custom => param(\"item$check_item_id\") || undef,\n                });\n            }\n            else {\n                my $check_item_done = rset('CheckItemDone')->update_or_create({\n                    check_item_id => $check_item_id,\n                    check_done_id => $check_done->id,\n                    status        => param(\"item$check_item_id\") || undef,\n                });\n            }\n        }\n        forwardHome({ success => \"Check has been recorded successfully\" }, 'checks');\n    }\n\n    template 'check' => {\n        check       => rset('Task')->find($task_id),\n        check_done  => $check_done,\n        dateformat  => config->{lenio}->{dateformat},\n        page        => 'check',\n    };\n};\n\nget '/ticket/view/:id?' => require_login sub {\n    my $id = route_parameters->get('id');\n    redirect '/ticket'\n        unless $id =~ /^[0-9]+$/;\n    redirect \"/ticket/$id\";\n};\n\nany ['get', 'post'] => '/ticket/:id?' => require_login sub {\n\n    my $date    = query_parameters->get('date');\n    my $id      = route_parameters->get('id');\n\n    # Check for comment deletion\n    if (my $comment_id = body_parameters->get('delete_comment'))\n    {\n        error \"You do not have access to delete comments\"\n            unless var('login')->is_admin;\n        if (my $comment = rset('Comment')->find($comment_id))\n        {\n            my $ticket_id = $comment->ticket_id;\n            if (process sub { $comment->delete })\n            {\n                forwardHome({ success => \"Comment has been successfully deleted\" }, \"ticket/$ticket_id\");\n            }\n        }\n        else {\n            error \"Comment id {id} not found\", id => $comment_id;\n        }\n    }\n\n    # task_id can be specified in posted form or prefilled in ticket url\n    my $task;\n    if (my $task_id = body_parameters->get('task_id') || query_parameters->get('task_id'))\n    {\n        $task = rset('Task')->find($task_id);\n    }\n\n    my $ticket;\n    if (defined($id) && $id)\n    {\n        $ticket = rset('Ticket')->find($id)\n            or error __x\"Ticket ID {id} not found\", id => $id;\n        # Check whether the user has access to this ticket\n        error __x\"You do not have permission for ticket ID {id}\", id => $id\n            unless var('login')->has_site($ticket->site_id);\n        # Existing ticket, get task from DB\n        $task = $ticket->task;\n    }\n    elsif (defined($id) && !body_parameters->get('submit'))\n    {\n        my $site_id = query_parameters->get('site_id')\n            ? int(query_parameters->get('site_id'))\n            : session('site_id');\n        # If applicable, Prefill ticket fields with initial values based on task\n        if ($task)\n        {\n            my $sid  = $task->site_task_local && $task->site_task_local->site_id; # site_id associated with local task\n            # See if the user has permission to view associated task\n            if ( var('login')->is_admin\n                || (!$task->global && var('login')->has_site($sid))\n            ) {\n                $ticket = rset('Ticket')->new({\n                    name        => $task->name,\n                    description => $task->description,\n                    planned     => $date,\n                    actionee    => $task->global ? 'external' : 'local',\n                    task_id     => $task->id,\n                    site_id     => $site_id,\n                });\n            }\n        }\n        else {\n            $ticket = rset('Ticket')->new({\n                site_id => $site_id,\n            });\n        }\n    }\n    elsif (defined($id))\n    {\n        # New ticket submitted, create base object to be updated\n        $ticket = rset('Ticket')->new({\n            created_by => logged_in_user->{id},\n            created_at => DateTime->now,\n        });\n    }\n\n    if ( body_parameters->get('attach') ) {\n        my $upload = request->upload('newattach')\n            or error __\"Please select a file to upload\";\n        my $attach = {\n            name        => $upload->basename,\n            ticket_id   => $id,\n            upload      => $upload,\n            mimetype    => $upload->type,\n        };\n\n        if (process sub { rset('Attach')->create_with_file($attach) })\n        {\n            my $args = {\n                login    => var('login'),\n                template => 'ticket/attach',\n                ticket   => $ticket,\n                url      => \"/ticket/\".$ticket->id,\n                subject  => \"Ticket \".$ticket->id.\" attachment added - \",\n                attach   => {\n                    data      => $upload->content,\n                    mime_type => $upload->type,\n                },\n            };\n            my $email = Lenio::Email->new(\n                config   => config,\n                schema   => schema,\n                uri_base => request->uri_base,\n                site     => $ticket->site, # rset('Site')->find(param 'site_id'),\n            );\n            $email->send($args);\n            success __\"File has been added successfully\";\n        }\n    }\n\n    if ( body_parameters->get('attachrm') ) {\n        error __\"You do not have permission to delete attachments\"\n            unless var('login')->is_admin;\n\n        if (process sub { rset('Attach')->find(body_parameters->get('attachrm'))->delete })\n        {\n            success __\"Attachment has been deleted successfully\";\n        }\n    }\n\n    if (body_parameters->get('delete'))\n    {\n        error __\"You do not have permission to delete this ticket\"\n            unless var('login')->is_admin || $ticket->actionee eq 'local';\n        if (process sub { $ticket->delete })\n        {\n            forwardHome({ success => \"Ticket has been successfully deleted\" }, 'tickets');\n        }\n    }\n\n    if (body_parameters->get('cancel_ticket'))\n    {\n        error __\"You do not have permission to cancel this ticket\"\n            unless var('login')->is_admin || $ticket->actionee eq 'local';\n        if (process sub { $ticket->update({ cancelled => DateTime->now }) })\n        {\n            forwardHome({ success => \"Ticket has been successfully cancelled\" }, 'tickets');\n        }\n    }\n\n    # Comment can be added on ticket creation or separately.  Create the\n    # object, which will be added at ticket insertion time or otherwise later.\n    my $comment = body_parameters->get('comment')\n        && rset('Comment')->new({\n            text      => body_parameters->get('comment'),\n            login_id  => var('login')->id,\n            datetime  => DateTime->now,\n        });\n\n    if (body_parameters->get('submit'))\n    {\n        # Find out if this is related to locally created task.\n        # If so, allow dates to be input\n        my $global = $task && $task->global;\n\n        my $completed   = (var('login')->is_admin || !$global) && _to_dt(param('completed'));\n        my $planned     = (var('login')->is_admin || !$global) && _to_dt(param('planned'));\n        my $provisional = (var('login')->is_admin || !$global) && _to_dt(param('provisional'));\n\n        $ticket->name(body_parameters->get('name'));\n        $ticket->description(body_parameters->get('description'));\n        $ticket->contractor_invoice(body_parameters->get('contractor_invoice'));\n        $ticket->contractor_id(body_parameters->get('contractor') || undef);\n        $ticket->cost_planned(body_parameters->get('cost_planned') || undef);\n        $ticket->cost_actual(body_parameters->get('cost_actual') || undef);\n        $ticket->actionee(body_parameters->get('actionee'));\n        $ticket->report_received(body_parameters->get('report_received') ? 1 : 0);\n        $ticket->invoice_sent(body_parameters->get('invoice_sent') ? 1 : 0);\n        $ticket->completed($completed);\n        $ticket->planned($planned);\n        $ticket->provisional($provisional);\n        $ticket->task_id($task && $task->id);\n        $ticket->site_id(body_parameters->get('site_id'));\n\n        # A normal user cannot edit a ticket that has already been created,\n        # unless it is related to a locally created task\n        if ($id)\n        {\n            error __\"You do not have permission to edit this ticket\"\n                unless var('login')->is_admin || $ticket->actionee eq 'local';\n        }\n        else {\n            error __\"You do not have permission to create a service item ticket\"\n                if $global && !var('login')->is_admin;\n        }\n\n        my $was_local = $id && $ticket->actionee eq 'local'; # Need old setting to see if to send email\n        if (process sub { $ticket->update_or_insert })\n        {\n            # XXX Ideally the comment would be written as a relationship\n            # at the same time as the ticket, but I couldn't get it to\n            # work ($ticket->comments([ .. ]) appears to do nothing)\n            if ($comment)\n            {\n                $comment->ticket_id($ticket->id);\n                $comment->insert;\n            }\n            my $template; my $subject; my $status;\n            if ($id)\n            {\n                $template = 'ticket/update';\n                $subject  = \"Ticket \".$ticket->id.\" updated - \";\n                $status   = 'updated';\n            }\n            else {\n                $template = 'ticket/new';\n                $subject  = \"New ticket ID \".$ticket->id.\" - \";\n                $status   = 'created';\n            }\n            my $args = {\n                login       => var('login'),\n                template    => $template,\n                ticket      => $ticket,\n                url         => \"/ticket/\".$ticket->id,\n                subject     => $subject,\n            };\n            # Assume send update to admin\n            my $send_email = 1;\n            # Do not send email update if new ticket and local, or was local and still is local only\n            $send_email = 0 if ((!$id && $ticket->actionee eq 'local') || ($id && $ticket->actionee eq 'local' && $was_local));\n            # Do not send email if local site task\n            $send_email = 0 if $task && !$task->global;\n            if ($send_email)\n            {\n                my $email = Lenio::Email->new(\n                    config   => config,\n                    schema   => schema,\n                    uri_base => request->uri_base,\n                    site     => $ticket->site,\n                );\n                $email->send($args);\n            }\n            forwardHome(\n                { success => \"Ticket \".$ticket->id.\" has been successfully $status\" }, 'ticket/'.$ticket->id );\n        }\n    }\n\n    if (my $submit = body_parameters->get('addcomment'))\n    {\n        $comment->ticket_id($ticket->id);\n        if ($submit eq 'private' && var('login')->is_admin)\n        {\n            $comment->admin_only(1);\n            if (process sub { $comment->insert })\n            {\n                forwardHome(\n                    { success => \"Comment has been added successfully\" }, 'ticket/'.$ticket->id );\n            }\n        }\n        else {\n            if (process sub { $comment->insert })\n            {\n                my $args = {\n                    login       => var('login'),\n                    template    => 'ticket/comment',\n                    url         => \"/ticket/$id\",\n                    ticket      => $ticket,\n                    subject     => \"Ticket \".$ticket->id.\" updated - \",\n                    comment     => body_parameters->get('comment'),\n                };\n                my $email = Lenio::Email->new(\n                    config   => config,\n                    schema   => schema,\n                    uri_base => request->uri_base,\n                    site     => $ticket->site,\n                );\n                $email->send($args);\n                forwardHome(\n                    { success => \"Comment has been added successfully\" }, 'ticket/'.$ticket->id );\n            }\n        }\n    }\n\n    template 'ticket' => {\n        id           => $id,\n        ticket       => $ticket,\n        contractors  => [rset('Contractor')->ordered],\n        dateformat   => config->{lenio}->{dateformat},\n        page         => 'ticket'\n    };\n};\n\nget '/tickets/?' => require_login sub {\n\n    # Deal with sort options\n    if (query_parameters->get('sort'))\n    {\n        if (my $order = query_parameters->get('order'))\n        {\n            session ticket_desc => $order eq 'desc' ? 1 : 0;\n        }\n        else {\n            session ticket_desc => session('ticket_sort') && session('ticket_sort') eq query_parameters->get('sort') ? !session('ticket_desc') : 0;\n        }\n        session ticket_sort => query_parameters->get('sort');\n    }\n\n    # Set filtering of tickets based on drop-down\n    my $ticket_filter = session 'ticket_filter';\n\n    my $filter_names = {\n        reactive        => {\n            url   => 'reactive',\n            group => 'type',\n            name  => 'Reactive tickets',\n        },\n        task            => {\n            url   => 'task',\n            group => 'type',\n            name  => 'Tickets for services',\n        },\n        not_planned     => {\n            url   => 'not-planned',\n            group => 'status',\n            name  => 'Not planned',\n        },\n        planned         => {\n            url   => 'planned',\n            group => 'status',\n            name  => 'Planned but not completed',\n        },\n        completed       => {\n            url   => 'completed',\n            group => 'status',\n            name  => 'Completed',\n        },\n        cancelled       => {\n            url   => 'cancelled',\n            group => 'status',\n            name  => 'Cancelled',\n        },\n        admin           => {\n            url   => 'admin',\n            group => 'actionee',\n            name  => 'Action currently on '.config->{lenio}->{invoice}->{company},\n        },\n        contractor      => {\n            url   => 'contractor',\n            group => 'actionee',\n            name  => 'Action on contractor',\n        },\n        local_action    => {\n            url   => 'local-action',\n            group => 'actionee',\n            name  => 'Action currently with site',\n        },\n        local_site      => {\n            url   => 'local-site',\n            group => 'actionee',\n            name  => 'To be rectified in-house',\n        },\n        this_month      => {\n            url   => 'this-month',\n            group => 'dates',\n            name  => 'This month',\n        },\n        next_month      => {\n            url   => 'next-month',\n            group => 'dates',\n            name  => 'Next month',\n        },\n        this_fy         => {\n            url   => 'this-fy',\n            group => 'dates',\n            name  => 'This financial year',\n        },\n        blank           => {\n            url   => 'blank',\n            group => 'dates',\n            name  => 'Dates blank',\n        },\n        no_invoice      => {\n            url   => 'no-invoice',\n            group => 'ir',\n            name  => 'Tickets without invoice',\n        },\n        no_invoice_sent => {\n            url   => 'no-invoice-sent',\n            group => 'ir',\n            name  => 'Tickets without invoice sent',\n        },\n        no_report       => {\n            url   => 'no-report',\n            group => 'ir',\n            name  => 'Tickets without report',\n        },\n    };\n\n    if (defined query_parameters->get('filter-type'))\n    {\n        if (my $tt = query_parameters->get('filter-type'))\n        {\n            $ticket_filter->{type}->{reactive} = !!query_parameters->get('set')\n                if $tt eq 'reactive';\n            $ticket_filter->{type}->{task} = !!query_parameters->get('set')\n                if $tt eq 'task';\n        }\n        else {\n            # Clear\n            delete $ticket_filter->{type};\n        }\n    }\n\n    if (defined query_parameters->get('filter-status'))\n    {\n        if (my $tt = query_parameters->get('filter-status'))\n        {\n            $ticket_filter->{status}->{not_planned} = !!query_parameters->get('set')\n                if $tt eq 'not-planned';\n            $ticket_filter->{status}->{planned} = !!query_parameters->get('set')\n                if $tt eq 'planned';\n            $ticket_filter->{status}->{completed} = !!query_parameters->get('set')\n                if $tt eq 'completed';\n            $ticket_filter->{status}->{cancelled} = !!query_parameters->get('set')\n                if $tt eq 'cancelled';\n        }\n        else {\n            # Clear\n            delete $ticket_filter->{status};\n        }\n    }\n\n    if (defined query_parameters->get('filter-actionee'))\n    {\n        if (my $tt = query_parameters->get('filter-actionee'))\n        {\n            $ticket_filter->{actionee}->{admin} = !!query_parameters->get('set')\n                if $tt eq 'admin';\n            $ticket_filter->{actionee}->{contractor} = !!query_parameters->get('set')\n                if $tt eq 'contractor';\n            $ticket_filter->{actionee}->{local_action} = !!query_parameters->get('set')\n                if $tt eq 'local-action';\n            $ticket_filter->{actionee}->{local_site} = !!query_parameters->get('set')\n                if $tt eq 'local-site';\n        }\n        else {\n            # Clear\n            delete $ticket_filter->{actionee};\n        }\n    }\n\n    if (defined query_parameters->get('filter-dates'))\n    {\n        if (my $tt = query_parameters->get('filter-dates'))\n        {\n            $ticket_filter->{dates}->{this_month} = !!query_parameters->get('set')\n                if $tt eq 'this-month';\n            $ticket_filter->{dates}->{next_month} = !!query_parameters->get('set')\n                if $tt eq 'next-month';\n            $ticket_filter->{dates}->{this_fy} = !!query_parameters->get('set')\n                if $tt eq 'this-fy';\n            $ticket_filter->{dates}->{blank} = !!query_parameters->get('set')\n                if $tt eq 'blank';\n        }\n        else {\n            # Clear\n            delete $ticket_filter->{dates};\n        }\n    }\n\n    if (defined query_parameters->get('filter-ir'))\n    {\n        if (my $tt = query_parameters->get('filter-ir'))\n        {\n            $ticket_filter->{ir}->{no_invoice} = !!query_parameters->get('set')\n                if $tt eq 'no-invoice';\n            $ticket_filter->{ir}->{no_invoice_sent} = !!query_parameters->get('set')\n                if $tt eq 'no-invoice-sent';\n            $ticket_filter->{ir}->{no_report} = !!query_parameters->get('set')\n                if $tt eq 'no-report';\n        }\n        else {\n            # Clear\n            delete $ticket_filter->{ir};\n        }\n    }\n\n    session ticket_filter => $ticket_filter;\n\n    if (defined query_parameters->get('task_id'))\n    {\n        if (my $task_id = query_parameters->get('task_id'))\n        {\n            session task_id => $task_id\n                if $task_id =~ /^[0-9]+$/;\n        }\n        else {\n            session task_id => undef;\n        }\n    }\n\n    my $task = session('task_id') && rset('Task')->find(session('task_id'));\n\n    my @tickets = rset('Ticket')->summary(\n        login     => var('login'),\n        site_id   => query_parameters->get('site_id') || var('site_ids'),\n        sort      => session('ticket_sort'),\n        sort_desc => session('ticket_desc'),\n        task_id   => $task && $task->id,\n        filter    => $ticket_filter,\n    );\n\n    my @selected_filters;\n    foreach my $type (keys %$ticket_filter)\n    {\n        foreach my $name (keys %{$ticket_filter->{$type}})\n        {\n            push @selected_filters, $name if $ticket_filter->{$type}->{$name};\n        }\n    };\n\n    template 'tickets' => {\n        task             => $task, # Tickets related to task\n        site_tasks       => [rset('Task')->site_tasks_grouped(site_ids => var('site_ids'))],\n        tickets          => \\@tickets,\n        sort             => session('ticket_sort'),\n        sort_desc        => session('ticket_desc'),\n        dateformat       => config->{lenio}->{dateformat},\n        ticket_filter    => session('ticket_filter'),\n        selected_filters => \\@selected_filters,\n        filter_names     => $filter_names,\n        page             => 'ticket'\n    };\n};\n\nget '/attach/:file' => require_login sub {\n    my $file = rset('Attach')->find(route_parameters->get('file'))\n        or error __x\"File ID {id} not found\", id => route_parameters->get('file');\n    my $site_id = $file->ticket->site_id;\n    if ( var('login')->has_site($site_id))\n    {\n        send_file( $file->content, content_type => $file->mimetype, system_path => 1 );\n    } else {\n        forwardHome(\n            { danger => 'You do not have permission to view this file' } );\n    }\n};\n\nany ['get', 'post'] => '/invoice/:id' => require_login sub {\n\n    my $id      = route_parameters->get('id');\n    my $invoice = defined $id && (rset('Invoice')->find($id) || rset('Invoice')->new({}));\n    my $ticket  = query_parameters->get('ticket') && rset('Ticket')->find(query_parameters->get('ticket'));\n\n    if (defined query_parameters->get('download'))\n    {\n        my %options = %{config->{lenio}->{invoice}};\n        $options{dateformat} = config->{lenio}->{dateformat};\n        my $pdf = $invoice->pdf(%options);\n\treturn send_file(\n\t    \\$pdf,\n\t    content_type => 'application/pdf',\n\t    filename     => (config->{lenio}->{invoice}->{prefix}).$invoice->id.\".pdf\",\n\t);\n    }\n\n    var('login')->is_admin\n        or forwardHome({ danger => 'You do not have permission to edit invoices' });\n\n    if (body_parameters->get('delete'))\n    {\n        if (process (sub { $invoice->delete } ) )\n        {\n            forwardHome({ success => 'The invoice has been successfully deleted' }, 'invoices');\n        }\n    }\n\n    if (body_parameters->get('submit'))\n    {\n        $ticket or error __\"No ticket specified to create the invoice for\";\n        $invoice->description(body_parameters->get('description'));\n        $invoice->number(body_parameters->get('number'));\n        $invoice->disbursements(body_parameters->get('disbursements') || undef);\n        $invoice->ticket_id($ticket->id);\n        $invoice->datetime(DateTime->now)\n            if !$id;\n        if (process sub { $invoice->update_or_insert })\n        {\n            # Email new invoice to users\n            my %options = %{config->{lenio}->{invoice}};\n            $options{dateformat} = config->{lenio}->{dateformat};\n            my $pdf = $invoice->pdf(%options);\n            my $args = {\n                login    => var('login'),\n                template => 'ticket/invoice',\n                ticket   => $ticket,\n                url      => \"/ticket/\".$ticket->id,\n                subject  => \"Ticket \".$ticket->id.\" invoice added - \",\n                attach   => {\n                    data      => $pdf,\n                    mime_type => 'application/pdf',\n                },\n            };\n            my $email = Lenio::Email->new(\n                config   => config,\n                schema   => schema,\n                uri_base => request->uri_base,\n                site     => $ticket->site, # rset('Site')->find(param 'site_id'),\n            );\n            $email->send($args);\n\n            my $action = $id ? 'updated' : 'created';\n            $id = $invoice->id;\n            forwardHome({ success => \"The invoice has been successfully $action\" }, \"invoice/$id\");\n        }\n\n    }\n\n    template 'invoice' => {\n        id      => $id,\n        invoice => $invoice,\n        ticket  => $ticket,\n        page    => 'invoice'\n    };\n};\n\nget '/invoices' => require_login sub {\n\n    if (query_parameters->get('sort'))\n    {\n        session invoice_desc => session('invoice_sort') && session('invoice_sort') eq query_parameters->get('sort') ? !session('invoice_desc') : 0;\n        session invoice_sort => query_parameters->get('sort');\n    }\n\n    my @invoices = rset('Invoice')->summary(\n        login     => var('login'),\n        site_id   => var('site_ids'),\n        sort      => session('invoice_sort'),\n        sort_desc => session('invoice_desc'),\n    );\n\n    template 'invoices' => {\n        invoices => \\@invoices,\n        page     => 'invoice'\n    };\n};\n\nany ['get', 'post'] => '/task/?:id?' => require_login sub {\n\n    my $action;\n    my $id = route_parameters->get('id');\n\n    if (var('login')->is_admin)\n    {\n        session('site_id') or error \"Please select a single site first\";\n        if (body_parameters->get('taskadd'))\n        {\n            rset('SiteTask')->find_or_create({ task_id => body_parameters->get('taskadd'), site_id => session('site_id') });\n        }\n        if (body_parameters->get('taskrm'))\n        {\n            rset('SiteTask')->search({ task_id => body_parameters->get('taskrm'), site_id => session('site_id') })->delete;\n        }\n    }\n\n    my $task = defined($id) && ($id && rset('Task')->find($id) || rset('Task')->new({}));\n\n    my @tasks; my @tasks_local; my @adhocs;\n\n    if ($task && $task->id)\n    {\n        # Check whether the user has access to this task\n        my @sites = map { $_->site_id } $task->site_tasks->all;\n        forwardHome(\n            { danger => \"You do not have permission for service item $id\" } )\n                unless var('login')->is_admin || (!$task->global && var('login')->has_site(@sites));\n    }\n\n    if (body_parameters->get('delete'))\n    {\n        my $site_id = $task->site_task_local && $task->site_task_local->site_id; # Site ID for local tasks\n        if (var('login')->is_admin)\n        {\n            if (process sub { $task->delete })\n            {\n                    forwardHome({ success => 'Service item has been successfully deleted' }, 'task' );\n            }\n        }\n        elsif (var('login')->has_site($site_id))\n        {\n            if (process sub { $task->delete })\n            {\n                    forwardHome({ success => 'Service item has been successfully deleted' }, 'task' );\n            }\n        }\n        else {\n            error __x\"You do not have permission to delete task ID {id}\", id => $id;\n        }\n    }\n\n    if ( var('login')->is_admin && body_parameters->get('tasktype_add') )\n    {\n        if (process sub { rset('Tasktype')->create({name => body_parameters->get('tasktype_name')}) })\n        {\n            forwardHome(\n                { success => 'Task type has been added' }, \"task/$id\" );\n        }\n    }\n\n    my $download = {\n        default_from => DateTime->now->subtract(months => 1),\n        default_to   => DateTime->now,\n    };\n    if (body_parameters->get('download_site_checks'))\n    {\n        session('site_id') or error \"Please select a single site first\";\n        my $from = _to_dt(body_parameters->get('download_from') || $download->{default_from});\n        my $to = _to_dt(body_parameters->get('download_to') || $download->{default_to});\n        my $csv = rset('CheckDone')->summary_csv(\n            from       => $from,\n            to         => $to,\n            site_id    => session('site_id'),\n            dateformat => $dateformat,\n        );\n\n        my $site = rset('Site')->find(session 'site_id')->org->name;\n        utf8::encode($csv);\n        return send_file(\n            \\$csv,\n            content_type => 'text/csv; chrset=\"utf-8\"',\n            filename     => \"$site site checks \".$from->strftime($dateformat).\" to \".$to->strftime($dateformat).\".csv\"\n        );\n    }\n\n    if (body_parameters->get('populate'))\n    {\n        session('site_id') or error \"Please select a single site first\";\n        my $year = body_parameters->get('populate_from');\n        if (process sub { rset('Task')->populate_tickets(\n                site_id  => session('site_id'),\n                from     => $year,\n                to       => session('fy'),\n                login_id => var('login')->id,\n            ) })\n        {\n            forwardHome({ success => 'Tickets have been populated successfully' }, 'task' );\n        }\n    }\n\n    if ( body_parameters->get('submit') )\n    {\n        session('site_id') or error \"Please select a single site first\";\n        if (var('login')->is_admin)\n        {\n            $task->global(1);\n        }\n        else\n        {\n            $task->set_site_id(session('site_id'));\n            $task->global(0);\n        }\n\n        $task->name(body_parameters->get('name'));\n        $task->description(body_parameters->get('description'));\n        $task->contractor_requirements(body_parameters->get('contractor_requirements'));\n        $task->evidence_required(body_parameters->get('evidence_required'));\n        $task->statutory(body_parameters->get('statutory'));\n        $task->tasktype_id(body_parameters->get('tasktype_id') || undef); # Fix empty string from form\n        $task->period_qty(body_parameters->get('period_qty'));\n        $task->period_unit(body_parameters->get('period_unit'));\n\n        if (process sub { $task->update_or_insert })\n        {\n                forwardHome({ success => 'Service item has been successfully created' }, 'task' );\n        }\n    }\n\n    else\n    {\n        session('site_id') or error \"Please select a single site first\";\n        my $csv = (session('site_id') && query_parameters->get('csv')) || \"\"; # prevent warnings. not for all sites\n\n        if ($csv eq 'service')\n        {\n\n            my $csvout = rset('Task')->csv(\n                site_id    => session('site_id'),\n                global     => 1,\n                fy         => session('fy'),\n                dateformat => $dateformat,\n            );\n\n            my $now = DateTime->now->ymd;\n            my $site = rset('Site')->find(session 'site_id')->org->name;\n            # XXX Is this correct? We can't send native utf-8 without getting the error\n            # \"Strings with code points over 0xFF may not be mapped into in-memory file handles\".\n            # So, encode the string (e.g. \"\\x{100}\"  becomes \"\\xc4\\x80) and then send it,\n            # telling the browser it's utf-8\n            utf8::encode($csvout);\n            return send_file(\n                \\$csvout,\n                content_type => 'text/csv; chrset=\"utf-8\"',\n                filename     => \"$site service items $now.csv\"\n            );\n        }\n\n        if (var('login')->is_admin && query_parameters->get('sla') && query_parameters->get('sla') eq 'pdf')\n        {\n            session('site_id') or error \"Please select a single site first\";\n            my $site = rset('Site')->find(session 'site_id');\n\n            my $pdf = rset('Task')->sla(\n                fy         => session('fy'),\n                site       => $site,\n                dateformat => $dateformat,\n                %{config->{lenio}->{invoice}},\n            );\n\n            my $now = DateTime->now->ymd;\n            return send_file(\n                \\$pdf->content,\n                content_type => 'application/pdf',\n                filename     => $site->org->name.\" Service Level Agreement $now.pdf\"\n            );\n        }\n\n        if (var('login')->is_admin && query_parameters->get('finsum') && query_parameters->get('finsum') eq 'pdf')\n        {\n            session('site_id') or error \"Please select a single site first\";\n            my $site = rset('Site')->find(session 'site_id');\n\n            my $pdf = rset('Task')->finsum(\n                fy         => session('fy'),\n                site       => $site,\n                dateformat => $dateformat,\n                %{config->{lenio}->{invoice}},\n            );\n\n            my $now = DateTime->now->ymd;\n            return send_file(\n                \\$pdf->content,\n                content_type => 'application/pdf',\n                filename     => $site->org->name.\" Financial Summary $now.pdf\"\n            );\n        }\n\n        # Get all the global tasks.\n        @tasks = rset('Task')->summary(site_id => var('site_ids'), global => 1, fy => session('fy'), onlysite => 1);\n\n        # Get any adhoc tasks\n        @adhocs = rset('Ticket')->summary(\n            login        => var('login'),\n            site_id      => var('site_ids'),\n            task_tickets => 0,\n            fy           => session('site_id') && session('fy'),\n            filter       => {\n                type => {\n                    reactive => 1,\n                },\n                costs => {\n                    actual => 1,\n                },\n            },\n        ) if var('site_ids');\n        if ($csv eq 'reactive')\n        {\n            my $csv = Text::CSV->new;\n            my @headings = qw/title cost_planned cost_actual completed contractor/;\n            $csv->combine(@headings);\n            my $csvout = $csv->string.\"\\n\";\n            my ($cost_planned_total, $cost_actual_total);\n            foreach my $adhoc (@adhocs)\n            {\n                my @row = (\n                    $adhoc->name,\n                    $adhoc->cost_planned,\n                    $adhoc->cost_actual,\n                    $adhoc->completed && $adhoc->completed->strftime($dateformat),\n                    $adhoc->contractor && $adhoc->contractor->name,\n                );\n                $csv->combine(@row);\n                $csvout .= $csv->string.\"\\n\";\n                $cost_planned_total += ($adhoc->cost_planned || 0);\n                $cost_actual_total  += ($adhoc->cost_actual || 0);\n            }\n            $csv->combine('Totals:', sprintf(\"%.2f\", $cost_planned_total), sprintf(\"%.2f\", $cost_actual_total),'','');\n            $csvout .= $csv->string.\"\\n\";\n            my $now = DateTime->now->ymd;\n            my $site = rset('Site')->find(session 'site_id')->org->name;\n            utf8::encode($csvout); # See comment above\n            return send_file(\n                \\$csvout,\n                content_type => 'text/csv; chrset=\"utf-8\"',\n                filename     => \"$site reactive $now.csv\"\n            );\n        }\n        # Get all the local tasks\n        @tasks_local = rset('Task')->summary(site_id => var('site_ids'), global => 0, onlysite => 1, fy => session('fy'));\n        $action = '';\n    }\n\n    my $show_populate = ! grep $_->get_column('cost_planned'), @tasks;\n\n    template 'task' => {\n        show_populate    => $show_populate,\n        dateformat       => $dateformat,\n        download         => $download,\n        action           => $action,\n        site             => rset('Site')->find(session 'site_id'),\n        site_checks      => [rset('Task')->site_checks(session 'site_id')],\n        task             => $task,\n        tasks            => \\@tasks,\n        all_tasks        => [rset('Task')->global->all],\n        tasks_local      => \\@tasks_local,\n        tasktypes        => [rset('Tasktype')->all],\n        adhocs           => \\@adhocs,\n        page             => 'task'\n    };\n};\n\nget '/data' => require_login sub {\n\n    my $utc_offset = query_parameters->get('utc_offset') * -1; # Passed from calendar plugin as query parameter\n    my $from  = DateTime->from_epoch( epoch => ( query_parameters->get('from') / 1000 ) )->add( minutes => $utc_offset );\n    my $to    = DateTime->from_epoch( epoch => ( query_parameters->get('to') / 1000 ) )->add(minutes => $utc_offset );\n    my $login = var('login');\n\n    my @tasks;\n    my @sites = rset('Site')->search({\n        'me.id' => var('site_ids'),\n    });\n    foreach my $site (@sites) {\n        my $calendar = Lenio::Calendar->new(\n            from           => $from,\n            to             => $to,\n            site           => $site,\n            multiple_sites => @sites > 1,\n            contractors    => session('contractors'),\n            login          => $login,\n            schema         => schema,\n            dateformat     => $dateformat,\n        );\n        push @tasks, $calendar->tasks;\n        push @tasks, $calendar->checks\n            if !$login->is_admin;\n    }\n    _send_json ({\n        success => 1,\n        result => \\@tasks\n    });\n};\n\nsub forwardHome {\n    my ($message, $page, %options) = @_;\n\n    if ($message)\n    {\n        my ($type) = keys %$message;\n        my $lroptions = {};\n        # Check for option to only display to user (e.g. passwords)\n        $lroptions->{to} = 'error_handler' if $options{user_only};\n\n        if ($type eq 'danger')\n        {\n            $lroptions->{is_fatal} = 0;\n            report $lroptions, ERROR => $message->{$type};\n        }\n        else {\n            report $lroptions, NOTICE => $message->{$type}, _class => 'success';\n        }\n    }\n    $page ||= '';\n    redirect \"/$page\";\n}\n\nsub _send_json\n{   header \"Cache-Control\" => \"max-age=0, must-revalidate, private\";\n    content_type 'application/json';\n    encode_json(shift);\n}\n\nsub password_generator\n{   $password_generator->xkcd( words => 3 );\n}\n\nsub _to_dt\n{   my $parser = DateTime::Format::Strptime->new(\n         pattern   => '%Y-%m-%d',\n         time_zone => 'local',\n    );\n    $parser->parse_datetime(shift);\n}\n\ntrue;\n"], "filenames": ["lib/Lenio.pm"], "buggy_code_start_loc": [648], "buggy_code_end_loc": [670], "fixing_code_start_loc": [649], "fixing_code_end_loc": [673], "type": "CWE-707", "message": "A vulnerability, which was classified as problematic, was found in ctrlo lenio. Affected is an unknown function in the library lib/Lenio.pm of the component Ticket Handler. The manipulation of the argument site_id leads to cross site scripting. It is possible to launch the attack remotely. The name of the patch is 7a1f90bd2a0ce95b8338ec0926902da975ec64d9. It is recommended to apply a patch to fix this issue. VDB-216210 is the identifier assigned to this vulnerability.", "other": {"cve": {"id": "CVE-2021-4253", "sourceIdentifier": "cna@vuldb.com", "published": "2022-12-18T22:15:10.317", "lastModified": "2022-12-22T20:06:12.400", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability, which was classified as problematic, was found in ctrlo lenio. Affected is an unknown function in the library lib/Lenio.pm of the component Ticket Handler. The manipulation of the argument site_id leads to cross site scripting. It is possible to launch the attack remotely. The name of the patch is 7a1f90bd2a0ce95b8338ec0926902da975ec64d9. It is recommended to apply a patch to fix this issue. VDB-216210 is the identifier assigned to this vulnerability."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}, {"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 3.5, "baseSeverity": "LOW"}, "exploitabilityScore": 2.1, "impactScore": 1.4}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-707"}, {"lang": "en", "value": "CWE-74"}, {"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ctrlo:lenio:*:*:*:*:*:*:*:*", "versionEndExcluding": "2021-02-09", "matchCriteriaId": "14AD53A4-BA52-43D8-95A3-F612A9328807"}]}]}], "references": [{"url": "https://github.com/ctrlo/lenio/commit/7a1f90bd2a0ce95b8338ec0926902da975ec64d9", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://vuldb.com/?id.216210", "source": "cna@vuldb.com", "tags": ["Permissions Required", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ctrlo/lenio/commit/7a1f90bd2a0ce95b8338ec0926902da975ec64d9"}}