{"buggy_code": ["# frozen_string_literal: true\n\n# AUTHOR: blink <blinketje@gmail.com>; blink#ruby-lang@irc.freenode.net\n# bugrep: Andreas Zehnder\n\nrequire 'rack'\nrequire 'time'\nrequire 'rack/request'\nrequire 'rack/response'\nrequire 'securerandom'\n\nmodule Rack\n\n  module Session\n\n    module Abstract\n      # SessionHash is responsible to lazily load the session from store.\n\n      class SessionHash\n        using Module.new {\n          refine Hash do\n            def transform_keys(&block)\n              hash = {}\n              each do |key, value|\n                hash[block.call(key)] = value\n              end\n              hash\n            end\n          end\n        } unless {}.respond_to?(:transform_keys)\n\n        def transform_keys(&block)\n          hash = dup\n          each do |key, value|\n            hash[block.call(key)] = value\n          end\n          hash\n        end\n\n        include Enumerable\n        attr_writer :id\n\n        Unspecified = Object.new\n\n        def self.find(req)\n          req.get_header RACK_SESSION\n        end\n\n        def self.set(req, session)\n          req.set_header RACK_SESSION, session\n        end\n\n        def self.set_options(req, options)\n          req.set_header RACK_SESSION_OPTIONS, options.dup\n        end\n\n        def initialize(store, req)\n          @store = store\n          @req = req\n          @loaded = false\n        end\n\n        def id\n          return @id if @loaded or instance_variable_defined?(:@id)\n          @id = @store.send(:extract_session_id, @req)\n        end\n\n        def options\n          @req.session_options\n        end\n\n        def each(&block)\n          load_for_read!\n          @data.each(&block)\n        end\n\n        def [](key)\n          load_for_read!\n          @data[key.to_s]\n        end\n\n        def fetch(key, default = Unspecified, &block)\n          load_for_read!\n          if default == Unspecified\n            @data.fetch(key.to_s, &block)\n          else\n            @data.fetch(key.to_s, default, &block)\n          end\n        end\n\n        def has_key?(key)\n          load_for_read!\n          @data.has_key?(key.to_s)\n        end\n        alias :key? :has_key?\n        alias :include? :has_key?\n\n        def []=(key, value)\n          load_for_write!\n          @data[key.to_s] = value\n        end\n        alias :store :[]=\n\n        def clear\n          load_for_write!\n          @data.clear\n        end\n\n        def destroy\n          clear\n          @id = @store.send(:delete_session, @req, id, options)\n        end\n\n        def to_hash\n          load_for_read!\n          @data.dup\n        end\n\n        def update(hash)\n          load_for_write!\n          @data.update(stringify_keys(hash))\n        end\n        alias :merge! :update\n\n        def replace(hash)\n          load_for_write!\n          @data.replace(stringify_keys(hash))\n        end\n\n        def delete(key)\n          load_for_write!\n          @data.delete(key.to_s)\n        end\n\n        def inspect\n          if loaded?\n            @data.inspect\n          else\n            \"#<#{self.class}:0x#{self.object_id.to_s(16)} not yet loaded>\"\n          end\n        end\n\n        def exists?\n          return @exists if instance_variable_defined?(:@exists)\n          @data = {}\n          @exists = @store.send(:session_exists?, @req)\n        end\n\n        def loaded?\n          @loaded\n        end\n\n        def empty?\n          load_for_read!\n          @data.empty?\n        end\n\n        def keys\n          load_for_read!\n          @data.keys\n        end\n\n        def values\n          load_for_read!\n          @data.values\n        end\n\n      private\n\n        def load_for_read!\n          load! if !loaded? && exists?\n        end\n\n        def load_for_write!\n          load! unless loaded?\n        end\n\n        def load!\n          @id, session = @store.send(:load_session, @req)\n          @data = stringify_keys(session)\n          @loaded = true\n        end\n\n        def stringify_keys(other)\n          other.transform_keys(&:to_s)\n        end\n      end\n\n      # ID sets up a basic framework for implementing an id based sessioning\n      # service. Cookies sent to the client for maintaining sessions will only\n      # contain an id reference. Only #find_session and #write_session are\n      # required to be overwritten.\n      #\n      # All parameters are optional.\n      # * :key determines the name of the cookie, by default it is\n      #   'rack.session'\n      # * :path, :domain, :expire_after, :secure, and :httponly set the related\n      #   cookie options as by Rack::Response#set_cookie\n      # * :skip will not a set a cookie in the response nor update the session state\n      # * :defer will not set a cookie in the response but still update the session\n      #   state if it is used with a backend\n      # * :renew (implementation dependent) will prompt the generation of a new\n      #   session id, and migration of data to be referenced at the new id. If\n      #   :defer is set, it will be overridden and the cookie will be set.\n      # * :sidbits sets the number of bits in length that a generated session\n      #   id will be.\n      #\n      # These options can be set on a per request basis, at the location of\n      # <tt>env['rack.session.options']</tt>. Additionally the id of the\n      # session can be found within the options hash at the key :id. It is\n      # highly not recommended to change its value.\n      #\n      # Is Rack::Utils::Context compatible.\n      #\n      # Not included by default; you must require 'rack/session/abstract/id'\n      # to use.\n\n      class Persisted\n        DEFAULT_OPTIONS = {\n          key: RACK_SESSION,\n          path: '/',\n          domain: nil,\n          expire_after: nil,\n          secure: false,\n          httponly: true,\n          defer: false,\n          renew: false,\n          sidbits: 128,\n          cookie_only: true,\n          secure_random: ::SecureRandom\n        }.freeze\n\n        attr_reader :key, :default_options, :sid_secure\n\n        def initialize(app, options = {})\n          @app = app\n          @default_options = self.class::DEFAULT_OPTIONS.merge(options)\n          @key = @default_options.delete(:key)\n          @cookie_only = @default_options.delete(:cookie_only)\n          initialize_sid\n        end\n\n        def call(env)\n          context(env)\n        end\n\n        def context(env, app = @app)\n          req = make_request env\n          prepare_session(req)\n          status, headers, body = app.call(req.env)\n          res = Rack::Response::Raw.new status, headers\n          commit_session(req, res)\n          [status, headers, body]\n        end\n\n        private\n\n        def make_request(env)\n          Rack::Request.new env\n        end\n\n        def initialize_sid\n          @sidbits = @default_options[:sidbits]\n          @sid_secure = @default_options[:secure_random]\n          @sid_length = @sidbits / 4\n        end\n\n        # Generate a new session id using Ruby #rand.  The size of the\n        # session id is controlled by the :sidbits option.\n        # Monkey patch this to use custom methods for session id generation.\n\n        def generate_sid(secure = @sid_secure)\n          if secure\n            secure.hex(@sid_length)\n          else\n            \"%0#{@sid_length}x\" % Kernel.rand(2**@sidbits - 1)\n          end\n        rescue NotImplementedError\n          generate_sid(false)\n        end\n\n        # Sets the lazy session at 'rack.session' and places options and session\n        # metadata into 'rack.session.options'.\n\n        def prepare_session(req)\n          session_was               = req.get_header RACK_SESSION\n          session                   = session_class.new(self, req)\n          req.set_header RACK_SESSION, session\n          req.set_header RACK_SESSION_OPTIONS, @default_options.dup\n          session.merge! session_was if session_was\n        end\n\n        # Extracts the session id from provided cookies and passes it and the\n        # environment to #find_session.\n\n        def load_session(req)\n          sid = current_session_id(req)\n          sid, session = find_session(req, sid)\n          [sid, session || {}]\n        end\n\n        # Extract session id from request object.\n\n        def extract_session_id(request)\n          sid = request.cookies[@key]\n          sid ||= request.params[@key] unless @cookie_only\n          sid\n        end\n\n        # Returns the current session id from the SessionHash.\n\n        def current_session_id(req)\n          req.get_header(RACK_SESSION).id\n        end\n\n        # Check if the session exists or not.\n\n        def session_exists?(req)\n          value = current_session_id(req)\n          value && !value.empty?\n        end\n\n        # Session should be committed if it was loaded, any of specific options like :renew, :drop\n        # or :expire_after was given and the security permissions match. Skips if skip is given.\n\n        def commit_session?(req, session, options)\n          if options[:skip]\n            false\n          else\n            has_session = loaded_session?(session) || forced_session_update?(session, options)\n            has_session && security_matches?(req, options)\n          end\n        end\n\n        def loaded_session?(session)\n          !session.is_a?(session_class) || session.loaded?\n        end\n\n        def forced_session_update?(session, options)\n          force_options?(options) && session && !session.empty?\n        end\n\n        def force_options?(options)\n          options.values_at(:max_age, :renew, :drop, :defer, :expire_after).any?\n        end\n\n        def security_matches?(request, options)\n          return true unless options[:secure]\n          request.ssl?\n        end\n\n        # Acquires the session from the environment and the session id from\n        # the session options and passes them to #write_session. If successful\n        # and the :defer option is not true, a cookie will be added to the\n        # response with the session's id.\n\n        def commit_session(req, res)\n          session = req.get_header RACK_SESSION\n          options = session.options\n\n          if options[:drop] || options[:renew]\n            session_id = delete_session(req, session.id || generate_sid, options)\n            return unless session_id\n          end\n\n          return unless commit_session?(req, session, options)\n\n          session.send(:load!) unless loaded_session?(session)\n          session_id ||= session.id\n          session_data = session.to_hash.delete_if { |k, v| v.nil? }\n\n          if not data = write_session(req, session_id, session_data, options)\n            req.get_header(RACK_ERRORS).puts(\"Warning! #{self.class.name} failed to save session. Content dropped.\")\n          elsif options[:defer] and not options[:renew]\n            req.get_header(RACK_ERRORS).puts(\"Deferring cookie for #{session_id}\") if $VERBOSE\n          else\n            cookie = Hash.new\n            cookie[:value] = data\n            cookie[:expires] = Time.now + options[:expire_after] if options[:expire_after]\n            cookie[:expires] = Time.now + options[:max_age] if options[:max_age]\n            set_cookie(req, res, cookie.merge!(options))\n          end\n        end\n        public :commit_session\n\n        # Sets the cookie back to the client with session id. We skip the cookie\n        # setting if the value didn't change (sid is the same) or expires was given.\n\n        def set_cookie(request, res, cookie)\n          if request.cookies[@key] != cookie[:value] || cookie[:expires]\n            res.set_cookie_header =\n              Utils.add_cookie_to_header(res.set_cookie_header, @key, cookie)\n          end\n        end\n\n        # Allow subclasses to prepare_session for different Session classes\n\n        def session_class\n          SessionHash\n        end\n\n        # All thread safety and session retrieval procedures should occur here.\n        # Should return [session_id, session].\n        # If nil is provided as the session id, generation of a new valid id\n        # should occur within.\n\n        def find_session(env, sid)\n          raise '#find_session not implemented.'\n        end\n\n        # All thread safety and session storage procedures should occur here.\n        # Must return the session id if the session was saved successfully, or\n        # false if the session could not be saved.\n\n        def write_session(req, sid, session, options)\n          raise '#write_session not implemented.'\n        end\n\n        # All thread safety and session destroy procedures should occur here.\n        # Should return a new session id or nil if options[:drop]\n\n        def delete_session(req, sid, options)\n          raise '#delete_session not implemented'\n        end\n      end\n\n      class ID < Persisted\n        def self.inherited(klass)\n          k = klass.ancestors.find { |kl| kl.respond_to?(:superclass) && kl.superclass == ID }\n          unless k.instance_variable_defined?(:\"@_rack_warned\")\n            warn \"#{klass} is inheriting from #{ID}.  Inheriting from #{ID} is deprecated, please inherit from #{Persisted} instead\" if $VERBOSE\n            k.instance_variable_set(:\"@_rack_warned\", true)\n          end\n          super\n        end\n\n        # All thread safety and session retrieval procedures should occur here.\n        # Should return [session_id, session].\n        # If nil is provided as the session id, generation of a new valid id\n        # should occur within.\n\n        def find_session(req, sid)\n          get_session req.env, sid\n        end\n\n        # All thread safety and session storage procedures should occur here.\n        # Must return the session id if the session was saved successfully, or\n        # false if the session could not be saved.\n\n        def write_session(req, sid, session, options)\n          set_session req.env, sid, session, options\n        end\n\n        # All thread safety and session destroy procedures should occur here.\n        # Should return a new session id or nil if options[:drop]\n\n        def delete_session(req, sid, options)\n          destroy_session req.env, sid, options\n        end\n      end\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire 'openssl'\nrequire 'zlib'\nrequire 'rack/request'\nrequire 'rack/response'\nrequire 'rack/session/abstract/id'\nrequire 'json'\nrequire 'base64'\n\nmodule Rack\n\n  module Session\n\n    # Rack::Session::Cookie provides simple cookie based session management.\n    # By default, the session is a Ruby Hash stored as base64 encoded marshalled\n    # data set to :key (default: rack.session).  The object that encodes the\n    # session data is configurable and must respond to +encode+ and +decode+.\n    # Both methods must take a string and return a string.\n    #\n    # When the secret key is set, cookie data is checked for data integrity.\n    # The old secret key is also accepted and allows graceful secret rotation.\n    #\n    # Example:\n    #\n    #     use Rack::Session::Cookie, :key => 'rack.session',\n    #                                :domain => 'foo.com',\n    #                                :path => '/',\n    #                                :expire_after => 2592000,\n    #                                :secret => 'change_me',\n    #                                :old_secret => 'also_change_me'\n    #\n    #     All parameters are optional.\n    #\n    # Example of a cookie with no encoding:\n    #\n    #   Rack::Session::Cookie.new(application, {\n    #     :coder => Rack::Session::Cookie::Identity.new\n    #   })\n    #\n    # Example of a cookie with custom encoding:\n    #\n    #   Rack::Session::Cookie.new(application, {\n    #     :coder => Class.new {\n    #       def encode(str); str.reverse; end\n    #       def decode(str); str.reverse; end\n    #     }.new\n    #   })\n    #\n\n    class Cookie < Abstract::Persisted\n      # Encode session cookies as Base64\n      class Base64\n        def encode(str)\n          ::Base64.encode64(str)\n        end\n\n        def decode(str)\n          ::Base64.decode64(str)\n        end\n\n        # Encode session cookies as Marshaled Base64 data\n        class Marshal < Base64\n          def encode(str)\n            super(::Marshal.dump(str))\n          end\n\n          def decode(str)\n            return unless str\n            ::Marshal.load(super(str)) rescue nil\n          end\n        end\n\n        # N.B. Unlike other encoding methods, the contained objects must be a\n        # valid JSON composite type, either a Hash or an Array.\n        class JSON < Base64\n          def encode(obj)\n            super(::JSON.dump(obj))\n          end\n\n          def decode(str)\n            return unless str\n            ::JSON.parse(super(str)) rescue nil\n          end\n        end\n\n        class ZipJSON < Base64\n          def encode(obj)\n            super(Zlib::Deflate.deflate(::JSON.dump(obj)))\n          end\n\n          def decode(str)\n            return unless str\n            ::JSON.parse(Zlib::Inflate.inflate(super(str)))\n          rescue\n            nil\n          end\n        end\n      end\n\n      # Use no encoding for session cookies\n      class Identity\n        def encode(str); str; end\n        def decode(str); str; end\n      end\n\n      attr_reader :coder\n\n      def initialize(app, options = {})\n        @secrets = options.values_at(:secret, :old_secret).compact\n        @hmac = options.fetch(:hmac, OpenSSL::Digest::SHA1)\n\n        warn <<-MSG unless secure?(options)\n        SECURITY WARNING: No secret option provided to Rack::Session::Cookie.\n        This poses a security threat. It is strongly recommended that you\n        provide a secret to prevent exploits that may be possible from crafted\n        cookies. This will not be supported in future versions of Rack, and\n        future versions will even invalidate your existing user cookies.\n\n        Called from: #{caller[0]}.\n        MSG\n        @coder = options[:coder] ||= Base64::Marshal.new\n        super(app, options.merge!(cookie_only: true))\n      end\n\n      private\n\n      def find_session(req, sid)\n        data = unpacked_cookie_data(req)\n        data = persistent_session_id!(data)\n        [data[\"session_id\"], data]\n      end\n\n      def extract_session_id(request)\n        unpacked_cookie_data(request)[\"session_id\"]\n      end\n\n      def unpacked_cookie_data(request)\n        request.fetch_header(RACK_SESSION_UNPACKED_COOKIE_DATA) do |k|\n          session_data = request.cookies[@key]\n\n          if @secrets.size > 0 && session_data\n            session_data, _, digest = session_data.rpartition('--')\n            session_data = nil unless digest_match?(session_data, digest)\n          end\n\n          request.set_header(k, coder.decode(session_data) || {})\n        end\n      end\n\n      def persistent_session_id!(data, sid = nil)\n        data ||= {}\n        data[\"session_id\"] ||= sid || generate_sid\n        data\n      end\n\n      def write_session(req, session_id, session, options)\n        session = session.merge(\"session_id\" => session_id)\n        session_data = coder.encode(session)\n\n        if @secrets.first\n          session_data << \"--#{generate_hmac(session_data, @secrets.first)}\"\n        end\n\n        if session_data.size > (4096 - @key.size)\n          req.get_header(RACK_ERRORS).puts(\"Warning! Rack::Session::Cookie data size exceeds 4K.\")\n          nil\n        else\n          session_data\n        end\n      end\n\n      def delete_session(req, session_id, options)\n        # Nothing to do here, data is in the client\n        generate_sid unless options[:drop]\n      end\n\n      def digest_match?(data, digest)\n        return unless data && digest\n        @secrets.any? do |secret|\n          Rack::Utils.secure_compare(digest, generate_hmac(data, secret))\n        end\n      end\n\n      def generate_hmac(data, secret)\n        OpenSSL::HMAC.hexdigest(@hmac.new, secret, data)\n      end\n\n      def secure?(options)\n        @secrets.size >= 1 ||\n        (options[:coder] && options[:let_coder_handle_secure_encoding])\n      end\n\n    end\n  end\nend\n", "# frozen_string_literal: true\n\n# AUTHOR: blink <blinketje@gmail.com>; blink#ruby-lang@irc.freenode.net\n# THANKS:\n#   apeiros, for session id generation, expiry setup, and threadiness\n#   sergio, threadiness and bugreps\n\nrequire 'rack/session/abstract/id'\nrequire 'thread'\n\nmodule Rack\n  module Session\n    # Rack::Session::Pool provides simple cookie based session management.\n    # Session data is stored in a hash held by @pool.\n    # In the context of a multithreaded environment, sessions being\n    # committed to the pool is done in a merging manner.\n    #\n    # The :drop option is available in rack.session.options if you wish to\n    # explicitly remove the session from the session cache.\n    #\n    # Example:\n    #   myapp = MyRackApp.new\n    #   sessioned = Rack::Session::Pool.new(myapp,\n    #     :domain => 'foo.com',\n    #     :expire_after => 2592000\n    #   )\n    #   Rack::Handler::WEBrick.run sessioned\n\n    class Pool < Abstract::Persisted\n      attr_reader :mutex, :pool\n      DEFAULT_OPTIONS = Abstract::ID::DEFAULT_OPTIONS.merge drop: false\n\n      def initialize(app, options = {})\n        super\n        @pool = Hash.new\n        @mutex = Mutex.new\n      end\n\n      def generate_sid\n        loop do\n          sid = super\n          break sid unless @pool.key? sid\n        end\n      end\n\n      def find_session(req, sid)\n        with_lock(req) do\n          unless sid and session = @pool[sid]\n            sid, session = generate_sid, {}\n            @pool.store sid, session\n          end\n          [sid, session]\n        end\n      end\n\n      def write_session(req, session_id, new_session, options)\n        with_lock(req) do\n          @pool.store session_id, new_session\n          session_id\n        end\n      end\n\n      def delete_session(req, session_id, options)\n        with_lock(req) do\n          @pool.delete(session_id)\n          generate_sid unless options[:drop]\n        end\n      end\n\n      def with_lock(req)\n        @mutex.lock if req.multithread?\n        yield\n      ensure\n        @mutex.unlock if @mutex.locked?\n      end\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire 'minitest/global_expectations/autorun'\nrequire 'thread'\nrequire 'rack/lint'\nrequire 'rack/mock'\nrequire 'rack/session/pool'\n\ndescribe Rack::Session::Pool do\n  session_key = Rack::Session::Pool::DEFAULT_OPTIONS[:key]\n  session_match = /#{session_key}=[0-9a-fA-F]+;/\n\n  incrementor = lambda do |env|\n    env[\"rack.session\"][\"counter\"] ||= 0\n    env[\"rack.session\"][\"counter\"] += 1\n    Rack::Response.new(env[\"rack.session\"].inspect).to_a\n  end\n\n  session_id = Rack::Lint.new(lambda do |env|\n    Rack::Response.new(env[\"rack.session\"].inspect).to_a\n  end)\n\n  nothing = Rack::Lint.new(lambda do |env|\n    Rack::Response.new(\"Nothing\").to_a\n  end)\n\n  drop_session = Rack::Lint.new(lambda do |env|\n    env['rack.session.options'][:drop] = true\n    incrementor.call(env)\n  end)\n\n  renew_session = Rack::Lint.new(lambda do |env|\n    env['rack.session.options'][:renew] = true\n    incrementor.call(env)\n  end)\n\n  defer_session = Rack::Lint.new(lambda do |env|\n    env['rack.session.options'][:defer] = true\n    incrementor.call(env)\n  end)\n\n  incrementor = Rack::Lint.new(incrementor)\n\n  it \"creates a new cookie\" do\n    pool = Rack::Session::Pool.new(incrementor)\n    res = Rack::MockRequest.new(pool).get(\"/\")\n    res[\"Set-Cookie\"].must_match(session_match)\n    res.body.must_equal '{\"counter\"=>1}'\n  end\n\n  it \"determines session from a cookie\" do\n    pool = Rack::Session::Pool.new(incrementor)\n    req = Rack::MockRequest.new(pool)\n    cookie = req.get(\"/\")[\"Set-Cookie\"]\n    req.get(\"/\", \"HTTP_COOKIE\" => cookie).\n      body.must_equal '{\"counter\"=>2}'\n    req.get(\"/\", \"HTTP_COOKIE\" => cookie).\n      body.must_equal '{\"counter\"=>3}'\n  end\n\n  it \"survives nonexistant cookies\" do\n    pool = Rack::Session::Pool.new(incrementor)\n    res = Rack::MockRequest.new(pool).\n      get(\"/\", \"HTTP_COOKIE\" => \"#{session_key}=blarghfasel\")\n    res.body.must_equal '{\"counter\"=>1}'\n  end\n\n  it \"does not send the same session id if it did not change\" do\n    pool = Rack::Session::Pool.new(incrementor)\n    req = Rack::MockRequest.new(pool)\n\n    res0 = req.get(\"/\")\n    cookie = res0[\"Set-Cookie\"][session_match]\n    res0.body.must_equal '{\"counter\"=>1}'\n    pool.pool.size.must_equal 1\n\n    res1 = req.get(\"/\", \"HTTP_COOKIE\" => cookie)\n    res1[\"Set-Cookie\"].must_be_nil\n    res1.body.must_equal '{\"counter\"=>2}'\n    pool.pool.size.must_equal 1\n\n    res2 = req.get(\"/\", \"HTTP_COOKIE\" => cookie)\n    res2[\"Set-Cookie\"].must_be_nil\n    res2.body.must_equal '{\"counter\"=>3}'\n    pool.pool.size.must_equal 1\n  end\n\n  it \"deletes cookies with :drop option\" do\n    pool = Rack::Session::Pool.new(incrementor)\n    req = Rack::MockRequest.new(pool)\n    drop = Rack::Utils::Context.new(pool, drop_session)\n    dreq = Rack::MockRequest.new(drop)\n\n    res1 = req.get(\"/\")\n    session = (cookie = res1[\"Set-Cookie\"])[session_match]\n    res1.body.must_equal '{\"counter\"=>1}'\n    pool.pool.size.must_equal 1\n\n    res2 = dreq.get(\"/\", \"HTTP_COOKIE\" => cookie)\n    res2[\"Set-Cookie\"].must_be_nil\n    res2.body.must_equal '{\"counter\"=>2}'\n    pool.pool.size.must_equal 0\n\n    res3 = req.get(\"/\", \"HTTP_COOKIE\" => cookie)\n    res3[\"Set-Cookie\"][session_match].wont_equal session\n    res3.body.must_equal '{\"counter\"=>1}'\n    pool.pool.size.must_equal 1\n  end\n\n  it \"provides new session id with :renew option\" do\n    pool = Rack::Session::Pool.new(incrementor)\n    req = Rack::MockRequest.new(pool)\n    renew = Rack::Utils::Context.new(pool, renew_session)\n    rreq = Rack::MockRequest.new(renew)\n\n    res1 = req.get(\"/\")\n    session = (cookie = res1[\"Set-Cookie\"])[session_match]\n    res1.body.must_equal '{\"counter\"=>1}'\n    pool.pool.size.must_equal 1\n\n    res2 = rreq.get(\"/\", \"HTTP_COOKIE\" => cookie)\n    new_cookie = res2[\"Set-Cookie\"]\n    new_session = new_cookie[session_match]\n    new_session.wont_equal session\n    res2.body.must_equal '{\"counter\"=>2}'\n    pool.pool.size.must_equal 1\n\n    res3 = req.get(\"/\", \"HTTP_COOKIE\" => new_cookie)\n    res3.body.must_equal '{\"counter\"=>3}'\n    pool.pool.size.must_equal 1\n\n    res4 = req.get(\"/\", \"HTTP_COOKIE\" => cookie)\n    res4.body.must_equal '{\"counter\"=>1}'\n    pool.pool.size.must_equal 2\n  end\n\n  it \"omits cookie with :defer option\" do\n    pool = Rack::Session::Pool.new(incrementor)\n    defer = Rack::Utils::Context.new(pool, defer_session)\n    dreq = Rack::MockRequest.new(defer)\n\n    res1 = dreq.get(\"/\")\n    res1[\"Set-Cookie\"].must_be_nil\n    res1.body.must_equal '{\"counter\"=>1}'\n    pool.pool.size.must_equal 1\n  end\n\n  # anyone know how to do this better?\n  it \"should merge sessions when multithreaded\" do\n    unless $DEBUG\n      1.must_equal 1\n      next\n    end\n\n    warn 'Running multithread tests for Session::Pool'\n    pool = Rack::Session::Pool.new(incrementor)\n    req = Rack::MockRequest.new(pool)\n\n    res = req.get('/')\n    res.body.must_equal '{\"counter\"=>1}'\n    cookie = res[\"Set-Cookie\"]\n    sess_id = cookie[/#{pool.key}=([^,;]+)/, 1]\n\n    delta_incrementor = lambda do |env|\n      # emulate disconjoinment of threading\n      env['rack.session'] = env['rack.session'].dup\n      Thread.stop\n      env['rack.session'][(Time.now.usec * rand).to_i] = true\n      incrementor.call(env)\n    end\n    tses = Rack::Utils::Context.new pool, delta_incrementor\n    treq = Rack::MockRequest.new(tses)\n    tnum = rand(7).to_i + 5\n    r = Array.new(tnum) do\n      Thread.new(treq) do |run|\n        run.get('/', \"HTTP_COOKIE\" => cookie, 'rack.multithread' => true)\n      end\n    end.reverse.map{|t| t.run.join.value }\n    r.each do |resp|\n      resp['Set-Cookie'].must_equal cookie\n      resp.body.must_include '\"counter\"=>2'\n    end\n\n    session = pool.pool[sess_id]\n    session.size.must_equal tnum + 1 # counter\n    session['counter'].must_equal 2 # meeeh\n  end\n\n  it \"does not return a cookie if cookie was not read/written\" do\n    app = Rack::Session::Pool.new(nothing)\n    res = Rack::MockRequest.new(app).get(\"/\")\n    res[\"Set-Cookie\"].must_be_nil\n  end\n\n  it \"does not return a cookie if cookie was not written (only read)\" do\n    app = Rack::Session::Pool.new(session_id)\n    res = Rack::MockRequest.new(app).get(\"/\")\n    res[\"Set-Cookie\"].must_be_nil\n  end\n\n  it \"returns even if not read/written if :expire_after is set\" do\n    app = Rack::Session::Pool.new(nothing, expire_after: 3600)\n    res = Rack::MockRequest.new(app).get(\"/\", 'rack.session' => { 'not' => 'empty' })\n    res[\"Set-Cookie\"].wont_be :nil?\n  end\n\n  it \"returns no cookie if no data was written and no session was created previously, even if :expire_after is set\" do\n    app = Rack::Session::Pool.new(nothing, expire_after: 3600)\n    res = Rack::MockRequest.new(app).get(\"/\")\n    res[\"Set-Cookie\"].must_be_nil\n  end\nend\n"], "fixing_code": ["# frozen_string_literal: true\n\n# AUTHOR: blink <blinketje@gmail.com>; blink#ruby-lang@irc.freenode.net\n# bugrep: Andreas Zehnder\n\nrequire 'rack'\nrequire 'time'\nrequire 'rack/request'\nrequire 'rack/response'\nrequire 'securerandom'\nrequire 'digest/sha2'\n\nmodule Rack\n\n  module Session\n\n    class SessionId\n      ID_VERSION = 2\n\n      attr_reader :public_id\n\n      def initialize(public_id)\n        @public_id = public_id\n      end\n\n      def private_id\n        \"#{ID_VERSION}::#{hash_sid(public_id)}\"\n      end\n\n      alias :cookie_value :public_id\n\n      def empty?; false; end\n      def to_s; raise; end\n      def inspect; public_id.inspect; end\n\n      private\n\n      def hash_sid(sid)\n        Digest::SHA256.hexdigest(sid)\n      end\n    end\n\n    module Abstract\n      # SessionHash is responsible to lazily load the session from store.\n\n      class SessionHash\n        using Module.new {\n          refine Hash do\n            def transform_keys(&block)\n              hash = {}\n              each do |key, value|\n                hash[block.call(key)] = value\n              end\n              hash\n            end\n          end\n        } unless {}.respond_to?(:transform_keys)\n\n        def transform_keys(&block)\n          hash = dup\n          each do |key, value|\n            hash[block.call(key)] = value\n          end\n          hash\n        end\n\n        include Enumerable\n        attr_writer :id\n\n        Unspecified = Object.new\n\n        def self.find(req)\n          req.get_header RACK_SESSION\n        end\n\n        def self.set(req, session)\n          req.set_header RACK_SESSION, session\n        end\n\n        def self.set_options(req, options)\n          req.set_header RACK_SESSION_OPTIONS, options.dup\n        end\n\n        def initialize(store, req)\n          @store = store\n          @req = req\n          @loaded = false\n        end\n\n        def id\n          return @id if @loaded or instance_variable_defined?(:@id)\n          @id = @store.send(:extract_session_id, @req)\n        end\n\n        def options\n          @req.session_options\n        end\n\n        def each(&block)\n          load_for_read!\n          @data.each(&block)\n        end\n\n        def [](key)\n          load_for_read!\n          @data[key.to_s]\n        end\n\n        def fetch(key, default = Unspecified, &block)\n          load_for_read!\n          if default == Unspecified\n            @data.fetch(key.to_s, &block)\n          else\n            @data.fetch(key.to_s, default, &block)\n          end\n        end\n\n        def has_key?(key)\n          load_for_read!\n          @data.has_key?(key.to_s)\n        end\n        alias :key? :has_key?\n        alias :include? :has_key?\n\n        def []=(key, value)\n          load_for_write!\n          @data[key.to_s] = value\n        end\n        alias :store :[]=\n\n        def clear\n          load_for_write!\n          @data.clear\n        end\n\n        def destroy\n          clear\n          @id = @store.send(:delete_session, @req, id, options)\n        end\n\n        def to_hash\n          load_for_read!\n          @data.dup\n        end\n\n        def update(hash)\n          load_for_write!\n          @data.update(stringify_keys(hash))\n        end\n        alias :merge! :update\n\n        def replace(hash)\n          load_for_write!\n          @data.replace(stringify_keys(hash))\n        end\n\n        def delete(key)\n          load_for_write!\n          @data.delete(key.to_s)\n        end\n\n        def inspect\n          if loaded?\n            @data.inspect\n          else\n            \"#<#{self.class}:0x#{self.object_id.to_s(16)} not yet loaded>\"\n          end\n        end\n\n        def exists?\n          return @exists if instance_variable_defined?(:@exists)\n          @data = {}\n          @exists = @store.send(:session_exists?, @req)\n        end\n\n        def loaded?\n          @loaded\n        end\n\n        def empty?\n          load_for_read!\n          @data.empty?\n        end\n\n        def keys\n          load_for_read!\n          @data.keys\n        end\n\n        def values\n          load_for_read!\n          @data.values\n        end\n\n      private\n\n        def load_for_read!\n          load! if !loaded? && exists?\n        end\n\n        def load_for_write!\n          load! unless loaded?\n        end\n\n        def load!\n          @id, session = @store.send(:load_session, @req)\n          @data = stringify_keys(session)\n          @loaded = true\n        end\n\n        def stringify_keys(other)\n          other.transform_keys(&:to_s)\n        end\n      end\n\n      # ID sets up a basic framework for implementing an id based sessioning\n      # service. Cookies sent to the client for maintaining sessions will only\n      # contain an id reference. Only #find_session and #write_session are\n      # required to be overwritten.\n      #\n      # All parameters are optional.\n      # * :key determines the name of the cookie, by default it is\n      #   'rack.session'\n      # * :path, :domain, :expire_after, :secure, and :httponly set the related\n      #   cookie options as by Rack::Response#set_cookie\n      # * :skip will not a set a cookie in the response nor update the session state\n      # * :defer will not set a cookie in the response but still update the session\n      #   state if it is used with a backend\n      # * :renew (implementation dependent) will prompt the generation of a new\n      #   session id, and migration of data to be referenced at the new id. If\n      #   :defer is set, it will be overridden and the cookie will be set.\n      # * :sidbits sets the number of bits in length that a generated session\n      #   id will be.\n      #\n      # These options can be set on a per request basis, at the location of\n      # <tt>env['rack.session.options']</tt>. Additionally the id of the\n      # session can be found within the options hash at the key :id. It is\n      # highly not recommended to change its value.\n      #\n      # Is Rack::Utils::Context compatible.\n      #\n      # Not included by default; you must require 'rack/session/abstract/id'\n      # to use.\n\n      class Persisted\n        DEFAULT_OPTIONS = {\n          key: RACK_SESSION,\n          path: '/',\n          domain: nil,\n          expire_after: nil,\n          secure: false,\n          httponly: true,\n          defer: false,\n          renew: false,\n          sidbits: 128,\n          cookie_only: true,\n          secure_random: ::SecureRandom\n        }.freeze\n\n        attr_reader :key, :default_options, :sid_secure\n\n        def initialize(app, options = {})\n          @app = app\n          @default_options = self.class::DEFAULT_OPTIONS.merge(options)\n          @key = @default_options.delete(:key)\n          @cookie_only = @default_options.delete(:cookie_only)\n          initialize_sid\n        end\n\n        def call(env)\n          context(env)\n        end\n\n        def context(env, app = @app)\n          req = make_request env\n          prepare_session(req)\n          status, headers, body = app.call(req.env)\n          res = Rack::Response::Raw.new status, headers\n          commit_session(req, res)\n          [status, headers, body]\n        end\n\n        private\n\n        def make_request(env)\n          Rack::Request.new env\n        end\n\n        def initialize_sid\n          @sidbits = @default_options[:sidbits]\n          @sid_secure = @default_options[:secure_random]\n          @sid_length = @sidbits / 4\n        end\n\n        # Generate a new session id using Ruby #rand.  The size of the\n        # session id is controlled by the :sidbits option.\n        # Monkey patch this to use custom methods for session id generation.\n\n        def generate_sid(secure = @sid_secure)\n          if secure\n            secure.hex(@sid_length)\n          else\n            \"%0#{@sid_length}x\" % Kernel.rand(2**@sidbits - 1)\n          end\n        rescue NotImplementedError\n          generate_sid(false)\n        end\n\n        # Sets the lazy session at 'rack.session' and places options and session\n        # metadata into 'rack.session.options'.\n\n        def prepare_session(req)\n          session_was               = req.get_header RACK_SESSION\n          session                   = session_class.new(self, req)\n          req.set_header RACK_SESSION, session\n          req.set_header RACK_SESSION_OPTIONS, @default_options.dup\n          session.merge! session_was if session_was\n        end\n\n        # Extracts the session id from provided cookies and passes it and the\n        # environment to #find_session.\n\n        def load_session(req)\n          sid = current_session_id(req)\n          sid, session = find_session(req, sid)\n          [sid, session || {}]\n        end\n\n        # Extract session id from request object.\n\n        def extract_session_id(request)\n          sid = request.cookies[@key]\n          sid ||= request.params[@key] unless @cookie_only\n          sid\n        end\n\n        # Returns the current session id from the SessionHash.\n\n        def current_session_id(req)\n          req.get_header(RACK_SESSION).id\n        end\n\n        # Check if the session exists or not.\n\n        def session_exists?(req)\n          value = current_session_id(req)\n          value && !value.empty?\n        end\n\n        # Session should be committed if it was loaded, any of specific options like :renew, :drop\n        # or :expire_after was given and the security permissions match. Skips if skip is given.\n\n        def commit_session?(req, session, options)\n          if options[:skip]\n            false\n          else\n            has_session = loaded_session?(session) || forced_session_update?(session, options)\n            has_session && security_matches?(req, options)\n          end\n        end\n\n        def loaded_session?(session)\n          !session.is_a?(session_class) || session.loaded?\n        end\n\n        def forced_session_update?(session, options)\n          force_options?(options) && session && !session.empty?\n        end\n\n        def force_options?(options)\n          options.values_at(:max_age, :renew, :drop, :defer, :expire_after).any?\n        end\n\n        def security_matches?(request, options)\n          return true unless options[:secure]\n          request.ssl?\n        end\n\n        # Acquires the session from the environment and the session id from\n        # the session options and passes them to #write_session. If successful\n        # and the :defer option is not true, a cookie will be added to the\n        # response with the session's id.\n\n        def commit_session(req, res)\n          session = req.get_header RACK_SESSION\n          options = session.options\n\n          if options[:drop] || options[:renew]\n            session_id = delete_session(req, session.id || generate_sid, options)\n            return unless session_id\n          end\n\n          return unless commit_session?(req, session, options)\n\n          session.send(:load!) unless loaded_session?(session)\n          session_id ||= session.id\n          session_data = session.to_hash.delete_if { |k, v| v.nil? }\n\n          if not data = write_session(req, session_id, session_data, options)\n            req.get_header(RACK_ERRORS).puts(\"Warning! #{self.class.name} failed to save session. Content dropped.\")\n          elsif options[:defer] and not options[:renew]\n            req.get_header(RACK_ERRORS).puts(\"Deferring cookie for #{session_id}\") if $VERBOSE\n          else\n            cookie = Hash.new\n            cookie[:value] = cookie_value(data)\n            cookie[:expires] = Time.now + options[:expire_after] if options[:expire_after]\n            cookie[:expires] = Time.now + options[:max_age] if options[:max_age]\n            set_cookie(req, res, cookie.merge!(options))\n          end\n        end\n        public :commit_session\n\n        def cookie_value(data)\n          data\n        end\n\n        # Sets the cookie back to the client with session id. We skip the cookie\n        # setting if the value didn't change (sid is the same) or expires was given.\n\n        def set_cookie(request, res, cookie)\n          if request.cookies[@key] != cookie[:value] || cookie[:expires]\n            res.set_cookie_header =\n              Utils.add_cookie_to_header(res.set_cookie_header, @key, cookie)\n          end\n        end\n\n        # Allow subclasses to prepare_session for different Session classes\n\n        def session_class\n          SessionHash\n        end\n\n        # All thread safety and session retrieval procedures should occur here.\n        # Should return [session_id, session].\n        # If nil is provided as the session id, generation of a new valid id\n        # should occur within.\n\n        def find_session(env, sid)\n          raise '#find_session not implemented.'\n        end\n\n        # All thread safety and session storage procedures should occur here.\n        # Must return the session id if the session was saved successfully, or\n        # false if the session could not be saved.\n\n        def write_session(req, sid, session, options)\n          raise '#write_session not implemented.'\n        end\n\n        # All thread safety and session destroy procedures should occur here.\n        # Should return a new session id or nil if options[:drop]\n\n        def delete_session(req, sid, options)\n          raise '#delete_session not implemented'\n        end\n      end\n\n      class PersistedSecure < Persisted\n        class SecureSessionHash < SessionHash\n          def [](key)\n            if key == \"session_id\"\n              load_for_read!\n              id.public_id\n            else\n              super\n            end\n          end\n        end\n\n        def generate_sid(*)\n          public_id = super\n\n          SessionId.new(public_id)\n        end\n\n        def extract_session_id(*)\n          public_id = super\n          public_id && SessionId.new(public_id)\n        end\n\n        private\n\n        def session_class\n          SecureSessionHash\n        end\n\n        def cookie_value(data)\n          data.cookie_value\n        end\n      end\n\n      class ID < Persisted\n        def self.inherited(klass)\n          k = klass.ancestors.find { |kl| kl.respond_to?(:superclass) && kl.superclass == ID }\n          unless k.instance_variable_defined?(:\"@_rack_warned\")\n            warn \"#{klass} is inheriting from #{ID}.  Inheriting from #{ID} is deprecated, please inherit from #{Persisted} instead\" if $VERBOSE\n            k.instance_variable_set(:\"@_rack_warned\", true)\n          end\n          super\n        end\n\n        # All thread safety and session retrieval procedures should occur here.\n        # Should return [session_id, session].\n        # If nil is provided as the session id, generation of a new valid id\n        # should occur within.\n\n        def find_session(req, sid)\n          get_session req.env, sid\n        end\n\n        # All thread safety and session storage procedures should occur here.\n        # Must return the session id if the session was saved successfully, or\n        # false if the session could not be saved.\n\n        def write_session(req, sid, session, options)\n          set_session req.env, sid, session, options\n        end\n\n        # All thread safety and session destroy procedures should occur here.\n        # Should return a new session id or nil if options[:drop]\n\n        def delete_session(req, sid, options)\n          destroy_session req.env, sid, options\n        end\n      end\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire 'openssl'\nrequire 'zlib'\nrequire 'rack/request'\nrequire 'rack/response'\nrequire 'rack/session/abstract/id'\nrequire 'json'\nrequire 'base64'\n\nmodule Rack\n\n  module Session\n\n    # Rack::Session::Cookie provides simple cookie based session management.\n    # By default, the session is a Ruby Hash stored as base64 encoded marshalled\n    # data set to :key (default: rack.session).  The object that encodes the\n    # session data is configurable and must respond to +encode+ and +decode+.\n    # Both methods must take a string and return a string.\n    #\n    # When the secret key is set, cookie data is checked for data integrity.\n    # The old secret key is also accepted and allows graceful secret rotation.\n    #\n    # Example:\n    #\n    #     use Rack::Session::Cookie, :key => 'rack.session',\n    #                                :domain => 'foo.com',\n    #                                :path => '/',\n    #                                :expire_after => 2592000,\n    #                                :secret => 'change_me',\n    #                                :old_secret => 'also_change_me'\n    #\n    #     All parameters are optional.\n    #\n    # Example of a cookie with no encoding:\n    #\n    #   Rack::Session::Cookie.new(application, {\n    #     :coder => Rack::Session::Cookie::Identity.new\n    #   })\n    #\n    # Example of a cookie with custom encoding:\n    #\n    #   Rack::Session::Cookie.new(application, {\n    #     :coder => Class.new {\n    #       def encode(str); str.reverse; end\n    #       def decode(str); str.reverse; end\n    #     }.new\n    #   })\n    #\n\n    class Cookie < Abstract::PersistedSecure\n      # Encode session cookies as Base64\n      class Base64\n        def encode(str)\n          ::Base64.encode64(str)\n        end\n\n        def decode(str)\n          ::Base64.decode64(str)\n        end\n\n        # Encode session cookies as Marshaled Base64 data\n        class Marshal < Base64\n          def encode(str)\n            super(::Marshal.dump(str))\n          end\n\n          def decode(str)\n            return unless str\n            ::Marshal.load(super(str)) rescue nil\n          end\n        end\n\n        # N.B. Unlike other encoding methods, the contained objects must be a\n        # valid JSON composite type, either a Hash or an Array.\n        class JSON < Base64\n          def encode(obj)\n            super(::JSON.dump(obj))\n          end\n\n          def decode(str)\n            return unless str\n            ::JSON.parse(super(str)) rescue nil\n          end\n        end\n\n        class ZipJSON < Base64\n          def encode(obj)\n            super(Zlib::Deflate.deflate(::JSON.dump(obj)))\n          end\n\n          def decode(str)\n            return unless str\n            ::JSON.parse(Zlib::Inflate.inflate(super(str)))\n          rescue\n            nil\n          end\n        end\n      end\n\n      # Use no encoding for session cookies\n      class Identity\n        def encode(str); str; end\n        def decode(str); str; end\n      end\n\n      attr_reader :coder\n\n      def initialize(app, options = {})\n        @secrets = options.values_at(:secret, :old_secret).compact\n        @hmac = options.fetch(:hmac, OpenSSL::Digest::SHA1)\n\n        warn <<-MSG unless secure?(options)\n        SECURITY WARNING: No secret option provided to Rack::Session::Cookie.\n        This poses a security threat. It is strongly recommended that you\n        provide a secret to prevent exploits that may be possible from crafted\n        cookies. This will not be supported in future versions of Rack, and\n        future versions will even invalidate your existing user cookies.\n\n        Called from: #{caller[0]}.\n        MSG\n        @coder = options[:coder] ||= Base64::Marshal.new\n        super(app, options.merge!(cookie_only: true))\n      end\n\n      private\n\n      def find_session(req, sid)\n        data = unpacked_cookie_data(req)\n        data = persistent_session_id!(data)\n        [data[\"session_id\"], data]\n      end\n\n      def extract_session_id(request)\n        unpacked_cookie_data(request)[\"session_id\"]\n      end\n\n      def unpacked_cookie_data(request)\n        request.fetch_header(RACK_SESSION_UNPACKED_COOKIE_DATA) do |k|\n          session_data = request.cookies[@key]\n\n          if @secrets.size > 0 && session_data\n            session_data, _, digest = session_data.rpartition('--')\n            session_data = nil unless digest_match?(session_data, digest)\n          end\n\n          request.set_header(k, coder.decode(session_data) || {})\n        end\n      end\n\n      def persistent_session_id!(data, sid = nil)\n        data ||= {}\n        data[\"session_id\"] ||= sid || generate_sid\n        data\n      end\n\n      class SessionId < DelegateClass(Session::SessionId)\n        attr_reader :cookie_value\n\n        def initialize(session_id, cookie_value)\n          super(session_id)\n          @cookie_value = cookie_value\n        end\n      end\n\n      def write_session(req, session_id, session, options)\n        session = session.merge(\"session_id\" => session_id)\n        session_data = coder.encode(session)\n\n        if @secrets.first\n          session_data << \"--#{generate_hmac(session_data, @secrets.first)}\"\n        end\n\n        if session_data.size > (4096 - @key.size)\n          req.get_header(RACK_ERRORS).puts(\"Warning! Rack::Session::Cookie data size exceeds 4K.\")\n          nil\n        else\n          SessionId.new(session_id, session_data)\n        end\n      end\n\n      def delete_session(req, session_id, options)\n        # Nothing to do here, data is in the client\n        generate_sid unless options[:drop]\n      end\n\n      def digest_match?(data, digest)\n        return unless data && digest\n        @secrets.any? do |secret|\n          Rack::Utils.secure_compare(digest, generate_hmac(data, secret))\n        end\n      end\n\n      def generate_hmac(data, secret)\n        OpenSSL::HMAC.hexdigest(@hmac.new, secret, data)\n      end\n\n      def secure?(options)\n        @secrets.size >= 1 ||\n        (options[:coder] && options[:let_coder_handle_secure_encoding])\n      end\n\n    end\n  end\nend\n", "# frozen_string_literal: true\n\n# AUTHOR: blink <blinketje@gmail.com>; blink#ruby-lang@irc.freenode.net\n# THANKS:\n#   apeiros, for session id generation, expiry setup, and threadiness\n#   sergio, threadiness and bugreps\n\nrequire 'rack/session/abstract/id'\nrequire 'thread'\n\nmodule Rack\n  module Session\n    # Rack::Session::Pool provides simple cookie based session management.\n    # Session data is stored in a hash held by @pool.\n    # In the context of a multithreaded environment, sessions being\n    # committed to the pool is done in a merging manner.\n    #\n    # The :drop option is available in rack.session.options if you wish to\n    # explicitly remove the session from the session cache.\n    #\n    # Example:\n    #   myapp = MyRackApp.new\n    #   sessioned = Rack::Session::Pool.new(myapp,\n    #     :domain => 'foo.com',\n    #     :expire_after => 2592000\n    #   )\n    #   Rack::Handler::WEBrick.run sessioned\n\n    class Pool < Abstract::PersistedSecure\n      attr_reader :mutex, :pool\n      DEFAULT_OPTIONS = Abstract::ID::DEFAULT_OPTIONS.merge drop: false\n\n      def initialize(app, options = {})\n        super\n        @pool = Hash.new\n        @mutex = Mutex.new\n      end\n\n      def generate_sid\n        loop do\n          sid = super\n          break sid unless @pool.key? sid.private_id\n        end\n      end\n\n      def find_session(req, sid)\n        with_lock(req) do\n          unless sid and session = get_session_with_fallback(sid)\n            sid, session = generate_sid, {}\n            @pool.store sid.private_id, session\n          end\n          [sid, session]\n        end\n      end\n\n      def write_session(req, session_id, new_session, options)\n        with_lock(req) do\n          @pool.store session_id.private_id, new_session\n          session_id\n        end\n      end\n\n      def delete_session(req, session_id, options)\n        with_lock(req) do\n          @pool.delete(session_id.public_id)\n          @pool.delete(session_id.private_id)\n          generate_sid unless options[:drop]\n        end\n      end\n\n      def with_lock(req)\n        @mutex.lock if req.multithread?\n        yield\n      ensure\n        @mutex.unlock if @mutex.locked?\n      end\n\n      private\n\n      def get_session_with_fallback(sid)\n        @pool[sid.private_id] || @pool[sid.public_id]\n      end\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire 'minitest/global_expectations/autorun'\nrequire 'thread'\nrequire 'rack/lint'\nrequire 'rack/mock'\nrequire 'rack/session/pool'\n\ndescribe Rack::Session::Pool do\n  session_key = Rack::Session::Pool::DEFAULT_OPTIONS[:key]\n  session_match = /#{session_key}=([0-9a-fA-F]+);/\n\n  incrementor = lambda do |env|\n    env[\"rack.session\"][\"counter\"] ||= 0\n    env[\"rack.session\"][\"counter\"] += 1\n    Rack::Response.new(env[\"rack.session\"].inspect).to_a\n  end\n\n  get_session_id = Rack::Lint.new(lambda do |env|\n    Rack::Response.new(env[\"rack.session\"].inspect).to_a\n  end)\n\n  nothing = Rack::Lint.new(lambda do |env|\n    Rack::Response.new(\"Nothing\").to_a\n  end)\n\n  drop_session = Rack::Lint.new(lambda do |env|\n    env['rack.session.options'][:drop] = true\n    incrementor.call(env)\n  end)\n\n  renew_session = Rack::Lint.new(lambda do |env|\n    env['rack.session.options'][:renew] = true\n    incrementor.call(env)\n  end)\n\n  defer_session = Rack::Lint.new(lambda do |env|\n    env['rack.session.options'][:defer] = true\n    incrementor.call(env)\n  end)\n\n  incrementor = Rack::Lint.new(incrementor)\n\n  it \"creates a new cookie\" do\n    pool = Rack::Session::Pool.new(incrementor)\n    res = Rack::MockRequest.new(pool).get(\"/\")\n    res[\"Set-Cookie\"].must_match(session_match)\n    res.body.must_equal '{\"counter\"=>1}'\n  end\n\n  it \"determines session from a cookie\" do\n    pool = Rack::Session::Pool.new(incrementor)\n    req = Rack::MockRequest.new(pool)\n    cookie = req.get(\"/\")[\"Set-Cookie\"]\n    req.get(\"/\", \"HTTP_COOKIE\" => cookie).\n      body.must_equal '{\"counter\"=>2}'\n    req.get(\"/\", \"HTTP_COOKIE\" => cookie).\n      body.must_equal '{\"counter\"=>3}'\n  end\n\n  it \"survives nonexistant cookies\" do\n    pool = Rack::Session::Pool.new(incrementor)\n    res = Rack::MockRequest.new(pool).\n      get(\"/\", \"HTTP_COOKIE\" => \"#{session_key}=blarghfasel\")\n    res.body.must_equal '{\"counter\"=>1}'\n  end\n\n  it \"does not send the same session id if it did not change\" do\n    pool = Rack::Session::Pool.new(incrementor)\n    req = Rack::MockRequest.new(pool)\n\n    res0 = req.get(\"/\")\n    cookie = res0[\"Set-Cookie\"][session_match]\n    res0.body.must_equal '{\"counter\"=>1}'\n    pool.pool.size.must_equal 1\n\n    res1 = req.get(\"/\", \"HTTP_COOKIE\" => cookie)\n    res1[\"Set-Cookie\"].must_be_nil\n    res1.body.must_equal '{\"counter\"=>2}'\n    pool.pool.size.must_equal 1\n\n    res2 = req.get(\"/\", \"HTTP_COOKIE\" => cookie)\n    res2[\"Set-Cookie\"].must_be_nil\n    res2.body.must_equal '{\"counter\"=>3}'\n    pool.pool.size.must_equal 1\n  end\n\n  it \"deletes cookies with :drop option\" do\n    pool = Rack::Session::Pool.new(incrementor)\n    req = Rack::MockRequest.new(pool)\n    drop = Rack::Utils::Context.new(pool, drop_session)\n    dreq = Rack::MockRequest.new(drop)\n\n    res1 = req.get(\"/\")\n    session = (cookie = res1[\"Set-Cookie\"])[session_match]\n    res1.body.must_equal '{\"counter\"=>1}'\n    pool.pool.size.must_equal 1\n\n    res2 = dreq.get(\"/\", \"HTTP_COOKIE\" => cookie)\n    res2[\"Set-Cookie\"].must_be_nil\n    res2.body.must_equal '{\"counter\"=>2}'\n    pool.pool.size.must_equal 0\n\n    res3 = req.get(\"/\", \"HTTP_COOKIE\" => cookie)\n    res3[\"Set-Cookie\"][session_match].wont_equal session\n    res3.body.must_equal '{\"counter\"=>1}'\n    pool.pool.size.must_equal 1\n  end\n\n  it \"provides new session id with :renew option\" do\n    pool = Rack::Session::Pool.new(incrementor)\n    req = Rack::MockRequest.new(pool)\n    renew = Rack::Utils::Context.new(pool, renew_session)\n    rreq = Rack::MockRequest.new(renew)\n\n    res1 = req.get(\"/\")\n    session = (cookie = res1[\"Set-Cookie\"])[session_match]\n    res1.body.must_equal '{\"counter\"=>1}'\n    pool.pool.size.must_equal 1\n\n    res2 = rreq.get(\"/\", \"HTTP_COOKIE\" => cookie)\n    new_cookie = res2[\"Set-Cookie\"]\n    new_session = new_cookie[session_match]\n    new_session.wont_equal session\n    res2.body.must_equal '{\"counter\"=>2}'\n    pool.pool.size.must_equal 1\n\n    res3 = req.get(\"/\", \"HTTP_COOKIE\" => new_cookie)\n    res3.body.must_equal '{\"counter\"=>3}'\n    pool.pool.size.must_equal 1\n\n    res4 = req.get(\"/\", \"HTTP_COOKIE\" => cookie)\n    res4.body.must_equal '{\"counter\"=>1}'\n    pool.pool.size.must_equal 2\n  end\n\n  it \"omits cookie with :defer option\" do\n    pool = Rack::Session::Pool.new(incrementor)\n    defer = Rack::Utils::Context.new(pool, defer_session)\n    dreq = Rack::MockRequest.new(defer)\n\n    res1 = dreq.get(\"/\")\n    res1[\"Set-Cookie\"].must_be_nil\n    res1.body.must_equal '{\"counter\"=>1}'\n    pool.pool.size.must_equal 1\n  end\n\n  it \"can read the session with the legacy id\" do\n    pool = Rack::Session::Pool.new(incrementor)\n    req = Rack::MockRequest.new(pool)\n\n    res0 = req.get(\"/\")\n    cookie = res0[\"Set-Cookie\"]\n    session_id = Rack::Session::SessionId.new cookie[session_match, 1]\n    ses0 = pool.pool[session_id.private_id]\n    pool.pool[session_id.public_id] = ses0\n    pool.pool.delete(session_id.private_id)\n\n    res1 = req.get(\"/\", \"HTTP_COOKIE\" => cookie)\n    res1[\"Set-Cookie\"].must_be_nil\n    res1.body.must_equal '{\"counter\"=>2}'\n    pool.pool[session_id.private_id].wont_be_nil\n  end\n\n  it \"drops the session in the legacy id as well\" do\n    pool = Rack::Session::Pool.new(incrementor)\n    req = Rack::MockRequest.new(pool)\n    drop = Rack::Utils::Context.new(pool, drop_session)\n    dreq = Rack::MockRequest.new(drop)\n\n    res0 = req.get(\"/\")\n    cookie = res0[\"Set-Cookie\"]\n    session_id = Rack::Session::SessionId.new cookie[session_match, 1]\n    ses0 = pool.pool[session_id.private_id]\n    pool.pool[session_id.public_id] = ses0\n    pool.pool.delete(session_id.private_id)\n\n    res2 = dreq.get(\"/\", \"HTTP_COOKIE\" => cookie)\n    res2[\"Set-Cookie\"].must_be_nil\n    res2.body.must_equal '{\"counter\"=>2}'\n    pool.pool[session_id.private_id].must_be_nil\n    pool.pool[session_id.public_id].must_be_nil\n  end\n\n  # anyone know how to do this better?\n  it \"should merge sessions when multithreaded\" do\n    unless $DEBUG\n      1.must_equal 1\n      next\n    end\n\n    warn 'Running multithread tests for Session::Pool'\n    pool = Rack::Session::Pool.new(incrementor)\n    req = Rack::MockRequest.new(pool)\n\n    res = req.get('/')\n    res.body.must_equal '{\"counter\"=>1}'\n    cookie = res[\"Set-Cookie\"]\n    sess_id = cookie[/#{pool.key}=([^,;]+)/, 1]\n\n    delta_incrementor = lambda do |env|\n      # emulate disconjoinment of threading\n      env['rack.session'] = env['rack.session'].dup\n      Thread.stop\n      env['rack.session'][(Time.now.usec * rand).to_i] = true\n      incrementor.call(env)\n    end\n    tses = Rack::Utils::Context.new pool, delta_incrementor\n    treq = Rack::MockRequest.new(tses)\n    tnum = rand(7).to_i + 5\n    r = Array.new(tnum) do\n      Thread.new(treq) do |run|\n        run.get('/', \"HTTP_COOKIE\" => cookie, 'rack.multithread' => true)\n      end\n    end.reverse.map{|t| t.run.join.value }\n    r.each do |resp|\n      resp['Set-Cookie'].must_equal cookie\n      resp.body.must_include '\"counter\"=>2'\n    end\n\n    session = pool.pool[sess_id]\n    session.size.must_equal tnum + 1 # counter\n    session['counter'].must_equal 2 # meeeh\n  end\n\n  it \"does not return a cookie if cookie was not read/written\" do\n    app = Rack::Session::Pool.new(nothing)\n    res = Rack::MockRequest.new(app).get(\"/\")\n    res[\"Set-Cookie\"].must_be_nil\n  end\n\n  it \"does not return a cookie if cookie was not written (only read)\" do\n    app = Rack::Session::Pool.new(get_session_id)\n    res = Rack::MockRequest.new(app).get(\"/\")\n    res[\"Set-Cookie\"].must_be_nil\n  end\n\n  it \"returns even if not read/written if :expire_after is set\" do\n    app = Rack::Session::Pool.new(nothing, expire_after: 3600)\n    res = Rack::MockRequest.new(app).get(\"/\", 'rack.session' => { 'not' => 'empty' })\n    res[\"Set-Cookie\"].wont_be :nil?\n  end\n\n  it \"returns no cookie if no data was written and no session was created previously, even if :expire_after is set\" do\n    app = Rack::Session::Pool.new(nothing, expire_after: 3600)\n    res = Rack::MockRequest.new(app).get(\"/\")\n    res[\"Set-Cookie\"].must_be_nil\n  end\nend\n"], "filenames": ["lib/rack/session/abstract/id.rb", "lib/rack/session/cookie.rb", "lib/rack/session/pool.rb", "test/spec_session_pool.rb"], "buggy_code_start_loc": [10, 51, 29, 11], "buggy_code_end_loc": [423, 170, 75, 197], "fixing_code_start_loc": [11, 51, 29, 11], "fixing_code_end_loc": [489, 179, 83, 234], "type": "CWE-203", "message": "There's a possible information leak / session hijack vulnerability in Rack (RubyGem rack). This vulnerability is patched in versions 1.6.12 and 2.0.8. Attackers may be able to find and hijack sessions by using timing attacks targeting the session id. Session ids are usually stored and indexed in a database that uses some kind of scheme for speeding up lookups of that session id. By carefully measuring the amount of time it takes to look up a session, an attacker may be able to find a valid session id and hijack the session. The session id itself may be generated randomly, but the way the session is indexed by the backing store does not use a secure comparison.", "other": {"cve": {"id": "CVE-2019-16782", "sourceIdentifier": "security-advisories@github.com", "published": "2019-12-18T20:15:16.180", "lastModified": "2021-11-02T18:04:03.773", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "There's a possible information leak / session hijack vulnerability in Rack (RubyGem rack). This vulnerability is patched in versions 1.6.12 and 2.0.8. Attackers may be able to find and hijack sessions by using timing attacks targeting the session id. Session ids are usually stored and indexed in a database that uses some kind of scheme for speeding up lookups of that session id. By carefully measuring the amount of time it takes to look up a session, an attacker may be able to find a valid session id and hijack the session. The session id itself may be generated randomly, but the way the session is indexed by the backing store does not use a secure comparison."}, {"lang": "es", "value": "Se presenta una posible vulnerabilidad de fuga de informaci\u00f3n y secuestro de sesi\u00f3n en Rack (rack RubyGem). Esta vulnerabilidad est\u00e1 parchada en las versiones 1.6.12 y 2.0.8. Los atacantes pueden ser capaces de encontrar y secuestrar sesiones utilizando ataques de sincronizaci\u00f3n dirigidos al id de sesi\u00f3n. Los id de sesi\u00f3n com\u00fanmente son almacenados e indexados a una base de datos que utiliza alg\u00fan tipo de esquema para acelerar las b\u00fasquedas de ese identificador de sesi\u00f3n. Al medir cuidadosamente la cantidad de tiempo que toma buscar una sesi\u00f3n, un atacante puede encontrar un id de sesi\u00f3n v\u00e1lida y secuestrar la sesi\u00f3n. El id de sesi\u00f3n en s\u00ed puede ser generado aleatoriamente, pero la forma en que es indexada la sesi\u00f3n por parte del almac\u00e9n de respaldo no utiliza una comparaci\u00f3n segura."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:C/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 4.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-203"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-208"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:rack_project:rack:*:*:*:*:*:ruby:*:*", "versionEndExcluding": "1.6.12", "matchCriteriaId": "9D82859F-CE7F-46CD-B8AD-323A5DAF4DAF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rack_project:rack:*:*:*:*:*:ruby:*:*", "versionStartIncluding": "2.0.0", "versionEndExcluding": "2.0.8", "matchCriteriaId": "08C26D46-A794-46E5-B417-9FAC01552413"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:31:*:*:*:*:*:*:*", "matchCriteriaId": "80F0FA5D-8D3B-4C0E-81E2-87998286AF33"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-02/msg00016.html", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2019/12/18/2", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2019/12/18/3", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2019/12/19/3", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2020/04/08/1", "source": "security-advisories@github.com", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2020/04/09/2", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/rack/rack/commit/7fecaee81f59926b6e1913511c90650e76673b38", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/rack/rack/security/advisories/GHSA-hrqr-hxpp-chr3", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/HZXMWILCICQLA2BYSP6I2CRMUG53YBLX/", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/rack/rack/commit/7fecaee81f59926b6e1913511c90650e76673b38"}}