{"buggy_code": ["/*\n * This file is part of the Sofia-SIP package\n *\n * Copyright (C) 2005 Nokia Corporation.\n *\n * Contact: Pekka Pessi <pekka.pessi@nokia.com>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public License\n * as published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA\n *\n */\n\n/**@ingroup sdp_parser\n * @CFILE sdp_parse.c\n * @brief Simple SDP parser interface.\n *\n * @author Pekka Pessi <Pekka.Pessi@nokia.com>\n * @author Kai Vehmanen <kai.vehmanen@nokia.com>\n *\n * @date  Created: Fri Feb 18 10:25:08 2000 ppessi\n *\n * @sa @RFC4566, @RFC2327.\n */\n\n#include \"config.h\"\n\n#include <sofia-sip/su_alloc.h>\n#include <sofia-sip/su_string.h>\n\n#include \"sofia-sip/sdp.h\"\n\n#include <stddef.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <limits.h>\n#include <assert.h>\n\n/** @typedef struct sdp_parser_s sdp_parser_t;\n *\n * SDP parser handle.\n *\n * The SDP parser handle returned by sdp_parse() contains either\n * a successfully parsed SDP session #sdp_session_t or an error message.\n * If sdp_session() returns non-NULL, parsing was successful.\n *\n * @sa #sdp_session_t, sdp_parse(), sdp_session(), sdp_parsing_error(),\n * sdp_sanity_check(), sdp_parser_home(), sdp_parser_free(), @RFC4566,\n * @RFC2327.\n */\n\nstruct sdp_parser_s {\n  su_home_t       pr_home[1];\n  union {\n    char          pru_error[128];\n    sdp_session_t pru_session[1];\n  } pr_output;\n  char      *pr_message;\n\n  sdp_mode_t pr_session_mode;\n\n  unsigned   pr_ok : 1;\n\n  unsigned   pr_strict : 1;\n  unsigned   pr_anynet : 1;\n  unsigned   pr_mode_0000 : 1;\n  unsigned   pr_mode_manual : 1;\n  unsigned   pr_insane : 1;\n  unsigned   pr_c_missing : 1;\n  unsigned   pr_config : 1;\n};\n\n#define is_posdigit(c) ((c) >= '1' && (c) <= '9')\n#define is_digit(c) ((c) >= '0' && (c) <= '9')\n#define is_space(c) ((c) == ' ')\n#define is_tab(c) ((c) == '\\t')\n\n#define pr_error   pr_output.pru_error\n#define pr_session pr_output.pru_session\n\n#ifdef _MSC_VER\n#undef STRICT\n#endif\n#define STRICT(pr) (pr->pr_strict)\n\n/* Static parser object used when running out of memory */\nstatic const struct sdp_parser_s no_mem_error =\n{\n  { SU_HOME_INIT(no_mem_error) },\n  { \"sdp: not enough memory\" }\n};\n\n/* Internal prototypes */\nstatic void parse_message(sdp_parser_t *p);\nstatic int parsing_error(sdp_parser_t *p, char const *fmt, ...);\n\n/** Parse an SDP message.\n *\n * The function sdp_parse() parses an SDP message @a msg of size @a\n * msgsize. Parsing is done according to the given @a flags. The SDP message\n * may not contain a NUL.\n *\n * The parsing result is stored to an #sdp_session_t structure.\n *\n * @param home    memory home\n * @param msg     pointer to message\n * @param msgsize size of the message (excluding final NUL, if any)\n * @param flags   flags affecting the parsing.\n *\n * The following flags are used by parser:\n *\n * @li #sdp_f_strict Parser should accept only messages conforming strictly\n *                   to the specification.\n * @li #sdp_f_anynet Parser accepts unknown network or address types.\n * @li #sdp_f_insane Do not run sanity check.\n * @li #sdp_f_c_missing  Sanity check does not require c= for each m= line\n * @li #sdp_f_mode_0000 Parser regards \"c=IN IP4 0.0.0.0\" as \"a=inactive\"\n *                      (likewise with c=IN IP6 ::)\n * @li #sdp_f_mode_manual Do not generate or parse SDP mode\n * @li #sdp_f_config   Parse config files (any line can be missing)\n *\n * @return\n * Always a valid parser handle.\n *\n * @todo Parser accepts some non-conforming SDP even with #sdp_f_strict.\n *\n * @sa sdp_session(), sdp_parsing_error(), sdp_sanity_check(),\n * sdp_parser_home(), sdp_parser_free(), @RFC4566, @RFC2327.\n */\nsdp_parser_t *\nsdp_parse(su_home_t *home, char const msg[], issize_t msgsize, int flags)\n{\n  sdp_parser_t *p;\n  char *b;\n  size_t len;\n\n  if (msgsize == -1 || msg == NULL) {\n    p = su_home_clone(home, sizeof(*p));\n    if (p)\n      parsing_error(p, \"invalid input message\");\n    else\n      p = (sdp_parser_t*)&no_mem_error;\n    return p;\n  }\n\n  if (msgsize == -1 && msg)\n    len = strlen(msg);\n  else\n    len = msgsize;\n\n  if (len > ISSIZE_MAX)\n    len = ISSIZE_MAX;\n\n  p = su_home_clone(home, sizeof(*p) + len + 1);\n\n  if (p) {\n    b = strncpy((void *)(p + 1), msg, len);\n    b[len] = 0;\n\n    p->pr_message = b;\n    p->pr_strict = (flags & sdp_f_strict) != 0;\n    p->pr_anynet = (flags & sdp_f_anynet) != 0;\n    p->pr_mode_0000 = (flags & sdp_f_mode_0000) != 0;\n    p->pr_insane = (flags & sdp_f_insane) != 0;\n    p->pr_c_missing = (flags & sdp_f_c_missing) != 0;\n    if (flags & sdp_f_config)\n      p->pr_c_missing = 1, p->pr_config = 1;\n    p->pr_mode_manual = (flags & sdp_f_mode_manual) != 0;\n    p->pr_session_mode = sdp_sendrecv;\n\n    parse_message(p);\n\n    return p;\n  }\n\n  if (p)\n    sdp_parser_free(p);\n\n  return (sdp_parser_t*)&no_mem_error;\n}\n\n\n/** Obtain memory home used by parser */\nsu_home_t *sdp_parser_home(sdp_parser_t *parser)\n{\n  if (parser != &no_mem_error)\n    return parser->pr_home;\n  else\n    return NULL;\n}\n\n/** Retrieve an SDP session structure.\n *\n * The function sdp_session() returns a pointer to the SDP session\n * structure associated with the SDP parser @a p. The pointer and all the\n * data in the structure are valid until sdp_parser_free() is called.\n *\n * @param p SDP parser\n *\n * @return\n *   The function sdp_session() returns a pointer to an parsed SDP message\n *   or NULL, if an error has occurred.  */\nsdp_session_t *\nsdp_session(sdp_parser_t *p)\n{\n  return p && p->pr_ok ? p->pr_session : NULL;\n}\n\n/** Get a parsing error message.\n *\n * The function sdp_parsing_error() returns the error message associated\n * with an SDP parser @a p.\n *\n * @param p SDP parser\n *\n * @return\n * The function sdp_parsing_error() returns a C string describing parsing\n * error, or NULL if no error occurred.\n */\nchar const *sdp_parsing_error(sdp_parser_t *p)\n{\n  return !p->pr_ok ? p->pr_error : NULL;\n}\n\n/** Free an SDP parser.\n *\n * The function sdp_parser_free() frees an SDP parser object along with\n * the memory blocks associated with it.\n *\n * @param p pointer to the SDP parser to be freed\n */\nvoid sdp_parser_free(sdp_parser_t *p)\n{\n  if (p && p != &no_mem_error)\n    su_home_unref(p->pr_home);\n}\n\n/* ========================================================================= */\n\n/* =========================================================================\n * Private part\n */\n\n/* Parsing tokens */\n#define SPACE \" \"\n#define TAB   \"\\011\"\n#define CRLF  \"\\015\\012\"\n#define ALPHA \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n#define DIGIT \"0123456789\"\n#define TOKEN ALPHA DIGIT \"-!#$%&'*+.^_`{|}~\"\n\n/* ========================================================================= */\n/* Parsing functions */\n\nstatic void post_session(sdp_parser_t *p, sdp_session_t *sdp);\nstatic void parse_origin(sdp_parser_t *p, char *r, sdp_origin_t **result);\nstatic void parse_subject(sdp_parser_t *p, char *r, sdp_text_t **result);\nstatic void parse_information(sdp_parser_t *p, char *r, sdp_text_t **result);\nstatic void parse_uri(sdp_parser_t *p, char *r, sdp_text_t **result);\nstatic void parse_email(sdp_parser_t *p, char *r, sdp_list_t **result);\nstatic void parse_phone(sdp_parser_t *p, char *r, sdp_list_t **result);\nstatic void parse_connection(sdp_parser_t *p, char *r, sdp_connection_t **result);\nstatic void parse_bandwidth(sdp_parser_t *p, char *r, sdp_bandwidth_t **result);\nstatic void parse_time(sdp_parser_t *p, char *r, sdp_time_t **result);\nstatic void parse_repeat(sdp_parser_t *p, char *r, sdp_repeat_t **result);\nstatic void parse_zone(sdp_parser_t *p, char *r, sdp_zone_t **result);\nstatic void parse_key(sdp_parser_t *p, char *r, sdp_key_t **result);\nstatic void parse_session_attr(sdp_parser_t *p, char *r, sdp_attribute_t **result);\nstatic void parse_media(sdp_parser_t *p, char *r, sdp_media_t **result);\nstatic void parse_payload(sdp_parser_t *p, char *r, sdp_rtpmap_t **result);\nstatic void parse_media_attr(sdp_parser_t *p, char *r, sdp_media_t *m,\n\t\t\t     sdp_attribute_t **result);\nstatic int parse_rtpmap(sdp_parser_t *p, char *r, sdp_media_t *m);\nstatic int parse_fmtp(sdp_parser_t *p, char *r, sdp_media_t *m);\nstatic void parse_text_list(sdp_parser_t *p, char *r, sdp_list_t **result);\n\nstatic void parse_descs(sdp_parser_t *p, char *r, char *m, sdp_media_t **result);\n\nstatic int parse_ul(sdp_parser_t *p, char **r, unsigned long *result,\n\t\t    unsigned long max_value);\nstatic int parse_ull(sdp_parser_t *p, char **r, uint64_t *result,\n\t\t     uint64_t max_value);\nstatic void parse_alloc_error(sdp_parser_t *p, const char *typename);\nstatic char *next(char **message, const char *sep, const char *strip);\nstatic char *token(char **message, const char *sep, const char *legal,\n\t\t   const char *strip);\n#if 0\nstatic void check_mandatory(sdp_parser_t *p, sdp_session_t *sdp);\n#endif\n\n/* -------------------------------------------------------------------------\n * Macro PARSE_ALLOC\n *\n * Description:\n *   This macro declares a pointer (v) of given type (t). It then allocates\n *   an structure of given type (t). If allocation was succesful, it assigns\n *   the XX_size member with appropriate value.\n */\n#define PARSE_ALLOC(p, t, v) \\\n t *v = su_salloc(p->pr_home, sizeof(*v)); \\\n if (!v && (parse_alloc_error(p, #t), 1)) return;\n\n/* -------------------------------------------------------------------------\n * Macro PARSE_CHECK_REST\n *\n * Description:\n *   This macro check if there is extra data at the end of field.\n */\n#define PARSE_CHECK_REST(p, s, n)\\\n if (*s && (parsing_error(p, \"extra data after %s (\\\"%.04s\\\")\", n, s), 1)) \\\n    return\n\n/* -------------------------------------------------------------------------\n * Function parse_message() - parse an SDP message\n *\n * Description:\n *   This function parses an SDP message, which is copied into the\n *   p->pr_message. The p->pr_message is modified during the parsing,\n *   and parts of it are returned in p->pr_session.\n *\n * Parameters:\n *   p - pointer to SDP parser object\n */\nstatic void parse_message(sdp_parser_t *p)\n{\n/*\n   announcement =        proto-version\n                         origin-field\n                         session-name-field\n                         information-field\n                         uri-field\n                         email-fields\n                         phone-fields\n                         connection-field\n                         bandwidth-fields\n                         time-fields\n                         key-field\n                         attribute-fields\n                         media-descriptions\n*/\n\n  sdp_session_t *sdp = p->pr_session;\n  char *record, *rest;\n  char const *strip;\n  char *message = p->pr_message;\n  char field = '\\0';\n  sdp_list_t **emails = &sdp->sdp_emails;\n  sdp_list_t **phones = &sdp->sdp_phones;\n  sdp_bandwidth_t **bandwidths = &sdp->sdp_bandwidths;\n  sdp_time_t **times = &sdp->sdp_time;\n  sdp_repeat_t **repeats = NULL;\n  sdp_zone_t **zones = NULL;\n  sdp_attribute_t **attributes = &sdp->sdp_attributes;\n\n  if (!STRICT(p))\n    strip = SPACE TAB;\t\t/* skip initial whitespace */\n  else\n    strip = \"\";\n\n  p->pr_ok = 1;\n  p->pr_session->sdp_size = sizeof(p->pr_session);\n\n  /* Require that version comes first */\n  record = next(&message, CRLF, strip);\n\n  if (!su_strmatch(record, \"v=0\")) {\n    if (!p->pr_config || !record || record[1] != '=') {\n      parsing_error(p, \"bad SDP message\");\n      return;\n    }\n  }\n  else {\n    record = next(&message, CRLF, strip);\n  }\n\n  /*\n    XXX - the lines in SDP are in certain order, which we don't check here.\n     For stricter parsing we might want to parse o= and s= next.\n  */\n\n  for (;\n       record && p->pr_ok;\n       record = next(&message, CRLF, strip)) {\n    field = record[0];\n\n    rest = record + 2; rest += strspn(rest, strip);\n\n    if (record[1] != '=') {\n      parsing_error(p, \"bad line \\\"%s\\\"\", record);\n      return;\n    }\n\n    switch (field) {\n    case 'o':\n      parse_origin(p, rest, &sdp->sdp_origin);\n      break;\n\n    case 's':\n      parse_subject(p, rest, &sdp->sdp_subject);\n      break;\n\n    case 'i':\n      parse_information(p, rest, &sdp->sdp_information);\n      break;\n\n    case 'u':\n      parse_uri(p, rest, &sdp->sdp_uri);\n      break;\n\n    case 'e':\n      parse_email(p, rest, emails);\n      emails = &(*emails)->l_next;\n      break;\n\n    case 'p':\n      parse_phone(p, rest, phones);\n      phones = &(*phones)->l_next;\n      break;\n\n    case 'c':\n      parse_connection(p, rest, &sdp->sdp_connection);\n      break;\n\n    case 'b':\n      parse_bandwidth(p, rest, bandwidths);\n      bandwidths = &(*bandwidths)->b_next;\n      break;\n\n    case 't':\n      parse_time(p, rest, times);\n      repeats = &(*times)->t_repeat;\n      zones = &(*times)->t_zone;\n      times = &(*times)->t_next;\n      break;\n\n    case 'r':\n      if (repeats)\n\tparse_repeat(p, rest, repeats);\n      else\n\tparsing_error(p, \"repeat field without time field\");\n      break;\n\n    case 'z':\n      if (zones)\n\tparse_zone(p, rest, zones), zones = NULL;\n      else\n\tparsing_error(p, \"zone field without time field\");\n      break;\n\n    case 'k':\n      parse_key(p, rest, &sdp->sdp_key);\n      break;\n\n    case 'a':\n      parse_session_attr(p, rest, attributes);\n      if (*attributes)\n\tattributes = &(*attributes)->a_next;\n      break;\n\n    case 'm':\n      parse_descs(p, record, message, &sdp->sdp_media);\n      post_session(p, sdp);\n      return;\n\n    default:\n      parsing_error(p, \"unknown field \\\"%s\\\"\", record);\n      return;\n    }\n  }\n\n  post_session(p, sdp);\n}\n#ifdef SOFIA_AUTO_CORRECT_INADDR_ANY\nint sdp_connection_is_inaddr_any(sdp_connection_t const *c)\n{\n  return\n    c &&\n    c->c_nettype == sdp_net_in &&\n    ((c->c_addrtype == sdp_addr_ip4 && su_strmatch(c->c_address, \"0.0.0.0\")) ||\n     (c->c_addrtype == sdp_addr_ip6 && su_strmatch(c->c_address, \"::\")));\n}\n#endif\n\n/**Postprocess session description.\n *\n * Postprocessing includes setting the session backpointer for each media,\n * doing sanity checks and setting rejected and mode flags.\n */\nstatic void post_session(sdp_parser_t *p, sdp_session_t *sdp)\n{\n  sdp_media_t *m;\n#ifdef SOFIA_AUTO_CORRECT_INADDR_ANY\n  sdp_connection_t const *c;\n#endif\n\n  if (!p->pr_ok)\n    return;\n\n  /* Set session back-pointer */\n  for (m = sdp->sdp_media; m; m = m->m_next) {\n    m->m_session = sdp;\n  }\n\n  if (p->pr_config) {\n    if (sdp->sdp_version[0] != 0)\n      parsing_error(p, \"Incorrect version\");\n    return;\n  }\n\n  /* Go through all media and set mode */\n  for (m = sdp->sdp_media; m; m = m->m_next) {\n    if (m->m_port == 0) {\n      m->m_mode = sdp_inactive;\n      m->m_rejected = 1;\n      continue;\n    }\n\n#ifdef SOFIA_AUTO_CORRECT_INADDR_ANY\n    c = sdp_media_connections(m);\n\n\n    if (p->pr_mode_0000 && sdp_connection_is_inaddr_any(c)) {\n      /* Reset recvonly flag */\n      m->m_mode &= ~sdp_recvonly;\n    }\n#endif\n  }\n\n  if (p->pr_insane)\n    return;\n\n  /* Verify that all mandatory fields are present */\n  if (sdp_sanity_check(p) < 0)\n    return;\n}\n\n/** Validates that all mandatory fields exist\n *\n * Checks that all necessary fields (v=, o=) exists in the parsed sdp. If\n * strict, check that all mandatory fields (c=, o=, s=, t=) are present.\n * This function also goes through all media, marks rejected media as such,\n * and updates the mode accordingly.\n *\n * @retval 0 if parsed SDP description is valid\n * @retval -1 if some SDP line is missing\n * @retval -2 if c= line is missing\n */\nint sdp_sanity_check(sdp_parser_t *p)\n{\n  sdp_session_t *sdp = p->pr_session;\n  sdp_media_t *m;\n\n  if (!p || !p->pr_ok)\n    return -1;\n  else if (sdp->sdp_version[0] != 0)\n    return parsing_error(p, \"Incorrect version\");\n  else if (!sdp->sdp_origin)\n    return parsing_error(p, \"No o= present\");\n  else if (p->pr_strict && !sdp->sdp_subject)\n    return parsing_error(p, \"No s= present\");\n  else if (p->pr_strict && !sdp->sdp_time)\n    return parsing_error(p, \"No t= present\");\n\n  /* If there is no session level c= check that one exists for all media */\n  /* c= line may be missing if this is a RTSP description */\n  if (!p->pr_c_missing && !sdp->sdp_connection) {\n    for (m = sdp->sdp_media ; m ; m = m->m_next) {\n      if (!m->m_connections && !m->m_rejected) {\n\tparsing_error(p, \"No c= on either session level or all mediums\");\n\treturn -2;\n      }\n    }\n  }\n\n  return 0;\n}\n\n#if 0\n/**\n * Parse a \"v=\" field\n *\n * The function parser_version() parses the SDP version field.\n *\n * @param p      pointer to SDP parser object\n * @param r      pointer to record data\n * @param result pointer to which parsed record is assigned\n */\nstatic void parse_version(sdp_parser_t *p, char *r, sdp_version_t *result)\n{\n  /*\n   proto-version =       \"v=\" 1*DIGIT CRLF\n                         ;[RFC2327] describes version 0\n   */\n  if (parse_ul(p, &r, result, 0))\n    parsing_error(p, \"version \\\"%s\\\" is invalid\", r);\n  else if (*result > 0)\n    parsing_error(p, \"unknown version v=%s\", r);\n}\n#endif\n\n/* -------------------------------------------------------------------------\n * Function parse_origin() - parse an \"o=\" field\n *\n * Description:\n *   This function parses an SDP origin field.\n *\n * Parameters:\n *   p      - pointer to SDP parser object\n *   r      - pointer to record data\n *   result - pointer to which parsed record is assigned\n */\nstatic void parse_origin(sdp_parser_t *p, char *r, sdp_origin_t **result)\n{\n  /*\n   origin-field =        \"o=\" username space\n                         sess-id space sess-version space\n                         nettype space addrtype space\n                         addr CRLF\n\n   username =            safe\n                         ;pretty wide definition, but doesn't include space\n\n   sess-id =             1*(DIGIT)\n                         ;should be unique for this originating username/host\n\n   sess-version =        1*(DIGIT)\n                         ;0 is a new session\n\n\n   */\n  PARSE_ALLOC(p, sdp_origin_t, o);\n\n  *result = o;\n\n  o->o_username = token(&r, SPACE TAB, NULL, SPACE TAB);\n  if (!o->o_username) {\n    parsing_error(p, \"invalid username\");\n    return;\n  }\n  if (parse_ull(p, &r, &o->o_id, 0)) {\n    parsing_error(p, \"invalid session id\");\n    return;\n  }\n\n  if (parse_ull(p, &r, &o->o_version, 0)) {\n    parsing_error(p, \"invalid session version\");\n    return;\n  }\n\n  parse_connection(p, r, &o->o_address);\n}\n\n/* -------------------------------------------------------------------------\n * Function parse_subject() - parse an \"s=\" field\n *\n * Description:\n *   This function parses an SDP subject field.\n *\n * Parameters:\n *   p      - pointer to SDP parser object\n *   r      - pointer to record data\n *   result - pointer to which parsed record is assigned\n */\nstatic void parse_subject(sdp_parser_t *p, char *r, sdp_text_t **result)\n{\n  /*\n   session-name-field =  \"s=\" text CRLF\n   text =                byte-string\n   */\n  *result = r;\n}\n\n/* -------------------------------------------------------------------------\n * Function parse_information() - parse an \"i=\" field\n *\n * Description:\n *   This function parses an SDP information field.\n *\n * Parameters:\n *   p      - pointer to SDP parser object\n *   r      - pointer to record data\n *   result - pointer to which parsed record is assigned\n */\nstatic void parse_information(sdp_parser_t *p, char *r, sdp_text_t **result)\n{\n  /*\n   information-field =   [\"i=\" text CRLF]\n   */\n  if (result) *result = r;\n}\n\n/* -------------------------------------------------------------------------\n * Function parse_uri() - parse an \"u=\" field\n *\n * Description:\n *   This function parses an SDP URI field.\n *\n * Parameters:\n *   p      - pointer to SDP parser object\n *   r      - pointer to record data\n *   result - pointer to which parsed record is assigned\n */\nstatic void parse_uri(sdp_parser_t *p, char *r, sdp_text_t **result)\n{\n  /*\n    uri-field =           [\"u=\" uri CRLF]\n\n    uri=                  ;defined in RFC1630\n  */\n  /* XXX - no syntax checking here */\n  *result = r;\n}\n\n/* -------------------------------------------------------------------------\n * Function parse_email() - parse an \"e=\" field\n *\n * Description:\n *   This function parses an SDP email field.\n *\n * Parameters:\n *   p      - pointer to SDP parser object\n *   r      - pointer to record data\n *   result - pointer to which parsed record is assigned\n */\nstatic void parse_email(sdp_parser_t *p, char *r, sdp_list_t **result)\n{\n  /*\n   email-fields =        *(\"e=\" email-address CRLF)\n\n   email-address =       email | email \"(\" email-safe \")\" |\n                         email-safe \"<\" email \">\"\n\n   email =               ;defined in RFC822  */\n  parse_text_list(p, r, result);\n}\n\n/* -------------------------------------------------------------------------\n * Function parse_phone() - parse an \"p=\" field\n *\n * Description:\n *   This function parses an SDP phone field.\n *\n * Parameters:\n *   p      - pointer to SDP parser object\n *   r      - pointer to record data\n *   result - pointer to which parsed record is assigned\n */\nstatic void parse_phone(sdp_parser_t *p, char *r, sdp_list_t **result)\n{\n  /*\n   phone-fields =        *(\"p=\" phone-number CRLF)\n\n   phone-number =        phone | phone \"(\" email-safe \")\" |\n                         email-safe \"<\" phone \">\"\n\n   phone =               \"+\" POS-DIGIT 1*(space | \"-\" | DIGIT)\n                         ;there must be a space or hyphen between the\n                         ;international code and the rest of the number.\n  */\n  parse_text_list(p, r, result);\n}\n\n/* -------------------------------------------------------------------------\n * Function parse_connection() - parse an \"c=\" field\n *\n * Description:\n *   This function parses an SDP connection field.\n *\n * Parameters:\n *   p      - pointer to SDP parser object\n *   r      - pointer to record data\n *   result - pointer to which parsed record is assigned\n */\nstatic void parse_connection(sdp_parser_t *p, char *r, sdp_connection_t **result)\n{\n  /*\n   connection-field =    [\"c=\" nettype space addrtype space\n                         connection-address CRLF]\n                         ;a connection field must be present\n                         ;in every media description or at the\n                         ;session-level\n\n   nettype =             \"IN\"\n                         ;list to be extended\n\n   addrtype =            \"IP4\" | \"IP6\"\n                         ;list to be extended\n\n   connection-address =  multicast-address\n                         | addr\n\n   multicast-address =   3*(decimal-uchar \".\") decimal-uchar \"/\" ttl\n                         [ \"/\" integer ]\n                         ;multicast addresses may be in the range\n                         ;224.0.0.0 to 239.255.255.255\n\n   ttl =                 decimal-uchar\n\n   addr =                FQDN | unicast-address\n\n   FQDN =                4*(alpha-numeric|\"-\"|\".\")\n                         ;fully qualified domain name as specified in RFC1035\n\n   unicast-address =     IP4-address | IP6-address\n\n   IP4-address =         b1 \".\" decimal-uchar \".\" decimal-uchar \".\" b4\n   b1 =                  decimal-uchar\n                         ;less than \"224\"; not \"0\" or \"127\"\n   b4 =                  decimal-uchar\n                         ;not \"0\"\n\n   IP6-address =         ;to be defined\n   */\n  PARSE_ALLOC(p, sdp_connection_t, c);\n\n  *result = c;\n\n  if (su_casenmatch(r, \"IN\", 2)) {\n    char *s;\n\n    /* nettype is internet */\n    c->c_nettype = sdp_net_in;\n    s = token(&r, SPACE TAB, NULL, NULL);\n\n    /* addrtype */\n    s = token(&r, SPACE TAB, NULL, NULL);\n    if (su_casematch(s, \"IP4\"))\n      c->c_addrtype = sdp_addr_ip4;\n    else if (su_casematch(s, \"IP6\"))\n      c->c_addrtype = sdp_addr_ip6;\n    else {\n      parsing_error(p, \"unknown IN address type: %s\", s);\n      return;\n    }\n\n    /* address */\n    s = next(&r, SPACE TAB, SPACE TAB);\n    c->c_address = s;\n    if (!s || !*s) {\n      parsing_error(p, \"invalid address\");\n      return;\n    }\n\n    /* ttl */\n    s = strchr(s, '/');\n    if (s) {\n      unsigned long value;\n      *s++ = 0;\n      if (parse_ul(p, &s, &value, 256) ||\n\t  (*s && *s != '/')) {\n\tparsing_error(p, \"invalid ttl\");\n\treturn;\n      }\n      c->c_ttl = value;\n      c->c_mcast = 1;\n\n      /* multiple groups */\n      value = 1;\n      if (*s++ == '/')\n\tif (parse_ul(p, &s, &value, 0) || *s) {\n\t  parsing_error(p, \"invalid number of multicast groups\");\n\t  return;\n\t}\n      c->c_groups = value;\n    }\n    else\n      c->c_groups = 1;\n  }\n  else if (p->pr_anynet) {\n    c->c_nettype = sdp_net_x;\n    c->c_addrtype = sdp_addr_x;\n    c->c_address = r;\n    c->c_ttl = 0;\n    c->c_groups = 1;\n  }\n  else\n    parsing_error(p, \"invalid address\");\n}\n\n/* -------------------------------------------------------------------------\n * Function parse_bandwidth() - parse an \"b=\" field\n *\n * Description:\n *   This function parses an SDP bandwidth field.\n *\n * Parameters:\n *   p      - pointer to SDP parser object\n *   r      - pointer to record data\n *   result - pointer to which parsed record is assigned\n */\nstatic void parse_bandwidth(sdp_parser_t *p, char *r, sdp_bandwidth_t **result)\n{\n  /*\n   bandwidth-fields =    *(\"b=\" bwtype \":\" bandwidth CRLF)\n   bwtype =              token\n   bandwidth =           1*(DIGIT)\n   */\n  /* NOTE: bwtype can also be like X-barf */\n  sdp_bandwidth_e modifier;\n  char *name;\n  unsigned long value;\n\n  name = token(&r, \":\", TOKEN, SPACE TAB);\n\n  if (name == NULL || parse_ul(p, &r, &value, 0)) {\n    parsing_error(p, \"invalid bandwidth\");\n    return;\n  }\n\n  if (su_casematch(name, \"CT\"))\n    modifier = sdp_bw_ct, name = \"CT\";\n  else if (su_casematch(name, \"TIAS\") == 1)\n    modifier = sdp_bw_tias, name = \"TIAS\";\n  else if (su_casematch(name, \"AS\") == 1)\n    modifier = sdp_bw_as, name = \"AS\";\n  else if (su_casematch(name, \"RS\") == 1)\n    modifier = sdp_bw_rs, name = \"RS\";\n  else if (su_casematch(name, \"RR\") == 1)\n    modifier = sdp_bw_rr, name = \"RR\";\n  else\n\tmodifier = sdp_bw_x, name = \"BW-X\";\n\n  if (STRICT(p))\n    PARSE_CHECK_REST(p, r, \"b\");\n\n  {\n    PARSE_ALLOC(p, sdp_bandwidth_t, b);\n    *result = b;\n    b->b_modifier = modifier;\n    b->b_modifier_name = name;\n    b->b_value = value;\n  }\n}\n\n/* -------------------------------------------------------------------------\n * Function parse_time() - parse an \"t=\" field\n *\n * Description:\n *   This function parses an SDP time field.\n *\n * Parameters:\n *   p      - pointer to SDP parser object\n *   r      - pointer to record data\n *   result - pointer to which parsed record is assigned\n */\nstatic void parse_time(sdp_parser_t *p, char *r, sdp_time_t **result)\n{\n  /*\n   time-fields =         1*( \"t=\" start-time SP stop-time\n                         *(CRLF repeat-fields) CRLF)\n                         [zone-adjustments CRLF]\n\n   start-time =          time / \"0\"\n\n   stop-time =           time / \"0\"\n\n   time =                POS-DIGIT 9*DIGIT\n                         ; Decimal representation of NTP time in\n                         ; seconds since 1900.  The representation\n                         ; of NTP time is an unbounded length field\n                         ; containing at least 10 digits.  Unlike the\n                         ; 64-bit representation used elsewhere, time\n                         ; in SDP does not wrap in the year 2036.\n   */\n  PARSE_ALLOC(p, sdp_time_t, t);\n  *result = t;\n  if (parse_ul(p, &r, &t->t_start, 0) ||\n      parse_ul(p, &r, &t->t_stop, 0))\n    parsing_error(p, \"invalid time\");\n  else if (STRICT(p)) {\n    PARSE_CHECK_REST(p, r, \"t\");\n  }\n}\n\n/**\n * Parse an \"r=\" field\n *\n * The function parse_repeat() parses an SDP repeat field.\n *\n * @param p      pointer to SDP parser object\n * @param r      pointer to record data\n * @param result pointer to which parsed record is assigned\n *\n */\nstatic void parse_repeat(sdp_parser_t *p, char *d, sdp_repeat_t **result)\n{\n  /*\n   repeat-fields =       %x72 \"=\" repeat-interval 2*(SP typed-time)\n\n   repeat-interval =     POS-DIGIT *DIGIT [fixed-len-time-unit]\n\n   typed-time =          1*DIGIT [fixed-len-time-unit]\n\n   fixed-len-time-unit = %x64 / %x68 / %x6d / %x73 ; \"d\" | \"h\" | \"m\" | \"s\"\n   */\n\n  unsigned long tt, *interval;\n  size_t i;\n  int n, N;\n  char *s;\n  sdp_repeat_t *r;\n  int strict = STRICT(p);\n\n  /** Count number of intervals */\n  for (N = 0, s = d; *s; ) {\n    if (!(is_posdigit(*s) || (!strict && (*s) == '0')))\n      break;\n    do { s++; } while (is_digit(*s));\n    if (*s && strchr(strict ? \"dhms\" : \"dhmsDHMS\", *s))\n      s++;\n    N++;\n    if (!(i = strict ? is_space(*s) : strspn(s, SPACE TAB)))\n      break;\n    s += i;\n  }\n\n  PARSE_CHECK_REST(p, s, \"r\");\n  if (N < 2) {\n    parsing_error(p, \"invalid repeat\");\n    return;\n  }\n  if (!(r = su_salloc(p->pr_home, offsetof(sdp_repeat_t, r_offsets[N - 1])))) {\n    parse_alloc_error(p, \"sdp_repeat_t\");\n    return;\n  }\n\n  r->r_number_of_offsets = N - 2;\n  r->r_offsets[N - 2] = 0;\n\n  for (n = 0, interval = &r->r_interval; n < N; n++) {\n    tt = strtoul(d, &d, 10);\n\n    switch (*d) {\n    case 'd': case 'D': tt *= 24;\n    case 'h': case 'H': tt *= 60;\n    case 'm': case 'M': tt *= 60;\n    case 's': case 'S': d++;\n      break;\n    }\n\n    interval[n] = tt;\n\n    while (is_space(*d))\n      d++;\n  }\n\n  *result = r;\n}\n\n/* -------------------------------------------------------------------------\n * Function parse_zone() - parse an \"z=\" field\n *\n * Description:\n *   This function parses an SDP time zone field.\n *\n * Parameters:\n *   p      - pointer to SDP parser object\n *   r      - pointer to record data\n *   result - pointer to which parsed record is assigned\n *\n */\nstatic void parse_zone(sdp_parser_t *p, char *r, sdp_zone_t **result)\n{\n  char *s;\n  size_t i;\n  int n, N;\n  sdp_zone_t *z;\n\n  /*\n   zone-adjustments =    time space [\"-\"] typed-time\n                         *(space time space [\"-\"] typed-time)\n   */\n\n  /** Count number of timezones, check syntax */\n  for (N = 0, s = r; *s;) {\n    if (!(is_posdigit(*s) || (!STRICT(p) && (*s) == '0')))\n      break;\n    do { s++; } while (is_digit(*s));\n    if (!(i = STRICT(p) ? is_space(*s) : strspn(s, SPACE TAB)))\n      break;\n    s += i;\n    if (!(*s == '-' || is_posdigit(*s) || (!STRICT(p) && (*s) == '0')))\n      break;\n    do { s++; } while (is_digit(*s));\n    if (*s && strchr(\"dhms\", *s))\n      s++;\n    N++;\n    if (!(i = STRICT(p) ? is_space(*s) : strspn(s, SPACE TAB)))\n      break;\n    s += i;\n  }\n\n  PARSE_CHECK_REST(p, s, \"z\");\n\n  if (N < 1) {\n    parsing_error(p, \"invalid timezone\");\n    return;\n  }\n  if (!(z = su_salloc(p->pr_home, offsetof(sdp_zone_t, z_adjustments[N])))) {\n    parse_alloc_error(p, \"sdp_zone_t\");\n    return;\n  }\n\n  z->z_number_of_adjustments = N;\n\n  for (n = 0; n < N; n++) {\n    unsigned long at = strtoul(r, &r, 10);\n    long offset = strtol(r, &r, 10);\n    switch (*r) {\n    case 'd': offset *= 24;\n    case 'h': offset *= 60;\n    case 'm': offset *= 60;\n    case 's': r++;\n      break;\n    }\n\n    z->z_adjustments[n].z_at = at;\n    z->z_adjustments[n].z_offset = offset;\n  }\n\n  *result = z;\n}\n\n/* -------------------------------------------------------------------------\n * Function parse_key() - parse an \"k=\" field\n *\n * Description:\n *   This function parses an SDP key field.\n *\n * Parameters:\n *   p      - pointer to SDP parser object\n *   r      - pointer to record data\n *   result - pointer to which parsed record is assigned\n *\n */\nstatic void parse_key(sdp_parser_t *p, char *r, sdp_key_t **result)\n{\n  char *s;\n  /*\n   key-field =           [\"k=\" key-type CRLF]\n\n   key-type =            \"prompt\" |\n                         \"clear:\" key-data |\n                         \"base64:\" key-data |\n                         \"uri:\" uri\n\n   key-data =            email-safe | \"~\" | \"\n   */\n\n  s = token(&r, \":\", TOKEN, SPACE TAB);\n  if (!s) {\n    parsing_error(p, \"invalid key method\");\n    return;\n  }\n\n  {\n    PARSE_ALLOC(p, sdp_key_t, k);\n    if (result) *result = k;\n\n    /* These are defined as key-sensitive in RFC 4566 */\n#define MATCH(s, tok) \\\n    (STRICT(p) ? su_strmatch((s), (tok)) : su_casematch((s), (tok)))\n\n    if (MATCH(s, \"clear\"))\n      k->k_method = sdp_key_clear, k->k_method_name = \"clear\";\n    else if (MATCH(s, \"base64\"))\n      k->k_method = sdp_key_base64, k->k_method_name = \"base64\";\n    else if (MATCH(s, \"uri\"))\n      k->k_method = sdp_key_uri, k->k_method_name = \"uri\";\n    else if (MATCH(s, \"prompt\"))\n      k->k_method = sdp_key_prompt, k->k_method_name = \"prompt\";\n    else if (!STRICT(p))\n      k->k_method = sdp_key_x, k->k_method_name = s;\n    else {\n      parsing_error(p, \"invalid key method\");\n      return;\n    }\n\n    k->k_material = r;\n  }\n}\n\n/* -------------------------------------------------------------------------\n * Function parse_session_attr() - parse a session \"a=\" field\n *\n * Description:\n *   This function parses an SDP attribute field regarding whole session.\n *\n * Parameters:\n *   p      - pointer to SDP parser object\n *   r      - pointer to record data\n *   result - pointer to which parsed record is assigned\n */\nstatic void parse_session_attr(sdp_parser_t *p, char *r, sdp_attribute_t **result)\n{\n  /*\n   attribute-fields =    *(\"a=\" attribute CRLF)\n\n   attribute =           (att-field \":\" att-value) / att-field\n\n   att-field =           token\n\n   att-value =           byte-string\n   */\n\n  char *name = NULL, *value = NULL;\n\n  if (!(name = token(&r, \":\", TOKEN, SPACE TAB))) {\n    parsing_error(p,\"invalid attribute name\");\n    return;\n  }\n\n  if (*r)\n    value = r;\n  else\n    PARSE_CHECK_REST(p, r, \"a\");\n\n  if (su_casematch(name, \"charset\")) {\n    p->pr_session->sdp_charset = value;\n    return;\n  }\n\n  if (p->pr_mode_manual)\n    ;\n  else if (su_casematch(name, \"inactive\"))\n    p->pr_session_mode = sdp_inactive;\n  else if (su_casematch(name, \"sendonly\"))\n    p->pr_session_mode = sdp_sendonly;\n  else if (su_casematch(name, \"recvonly\"))\n    p->pr_session_mode = sdp_recvonly;\n  else if (su_casematch(name, \"sendrecv\"))\n    p->pr_session_mode = sdp_sendrecv;\n\n  {\n    PARSE_ALLOC(p, sdp_attribute_t, a);\n    *result = a;\n\n    a->a_name  = name;\n    a->a_value = value;\n  }\n}\n\n/* -------------------------------------------------------------------------\n * Function parse_media() - parse an \"m=\" field\n *\n * Description:\n *   This function parses an SDP media field.\n *\n * Parameters:\n *   p      - pointer to SDP parser object\n *   r      - pointer to record data\n *   result - pointer to which parsed record is assigned\n */\nstatic void parse_media(sdp_parser_t *p, char *r, sdp_media_t **result)\n{\n  /*\n   media-descriptions =  *( media-field\n                         information-field\n                         *(connection-field)\n                         bandwidth-fields\n                         key-field\n                         attribute-fields )\n\n   media-field =         \"m=\" media space port [\"/\" integer]\n                         space proto 1*(space fmt) CRLF\n\n   media =               token\n                         ;typically \"audio\", \"video\", \"application\"\n                         ;or \"data\" or \"text\"\n\n   fmt =                 token\n                         ;typically an RTP payload type for audio\n                         ;and video media\n\n   proto =               token *(\"/\" token)\n                         ;typically \"RTP/AVP\" or \"udp\" for IP4\n\n   port =                1*(DIGIT)\n                         ;should in the range \"1024\" to \"65535\" inclusive\n   */\n  char *s;\n  unsigned long value;\n  PARSE_ALLOC(p, sdp_media_t, m);\n\n  *result = m;\n\n  m->m_mode = sdp_sendrecv;\n\n  s = token(&r, SPACE, TOKEN, NULL);\n  if (!s) {\n    parsing_error(p, \"m= invalid media field\");\n    return;\n  }\n\n  sdp_media_type(m, s);\n\n  /* Accept m=* in configuration file */\n  if (p->pr_config && m->m_type == sdp_media_any) {\n    r += strspn(r, SPACE TAB);\n    if (r[0] == '\\0') {\n      m->m_proto = sdp_proto_any, m->m_proto_name = \"*\";\n      return;\n    }\n  }\n\n  if (parse_ul(p, &r, &value, 0)) {\n    parsing_error(p, \"m= invalid port number\");\n    return;\n  }\n  m->m_port = value;\n\n  if (*r == '/') {\n    r++;\n    if (parse_ul(p, &r, &value, 0)) {\n      parsing_error(p, \"m= invalid port specification\");\n      return;\n    }\n    m->m_number_of_ports = value;\n  }\n\n  s = token(&r, SPACE, \"/\" TOKEN, SPACE);\n  if (s == NULL) {\n    parsing_error(p, \"m= missing protocol\");\n    return;\n  }\n\n  if (!STRICT(p) && su_casematch(s, \"RTP\"))\n    m->m_proto = sdp_proto_rtp, m->m_proto_name = \"RTP/AVP\";\n  else\n    sdp_media_transport(m, s);\n\n  /* RTP format list */\n  if (*r && sdp_media_has_rtp(m)) {\n\t  parse_payload(p, r, &m->m_rtpmaps);\n\t  return;\n  }\n\n  /* \"normal\" format list */\n  if (*r) {\n    sdp_list_t **fmt = &m->m_format;\n\n    while (r && *r) {\n      PARSE_ALLOC(p, sdp_list_t, l);\n      *fmt = l;\n      l->l_text = token(&r, SPACE TAB, TOKEN, SPACE TAB);\n      if (!l->l_text) {\n         parsing_error(p, \"m= invalid\");\n         return;\n      }\n      fmt = &l->l_next;\n    }\n  }\n}\n\n/** Set media type */\nvoid sdp_media_type(sdp_media_t *m, char const *s)\n{\n  if (su_strmatch(s, \"*\"))\n    m->m_type = sdp_media_any, m->m_type_name = \"*\";\n  else if (su_casematch(s, \"audio\"))\n    m->m_type = sdp_media_audio, m->m_type_name = \"audio\";\n  else if (su_casematch(s, \"video\"))\n    m->m_type = sdp_media_video, m->m_type_name = \"video\";\n  else if (su_casematch(s, \"application\"))\n    m->m_type = sdp_media_application, m->m_type_name = \"application\";\n  else if (su_casematch(s, \"data\"))\n    m->m_type = sdp_media_data, m->m_type_name = \"data\";\n  else if (su_casematch(s, \"control\"))\n    m->m_type = sdp_media_control, m->m_type_name = \"control\";\n  else if (su_casematch(s, \"message\"))\n    m->m_type = sdp_media_message, m->m_type_name = \"message\";\n  else if (su_casematch(s, \"image\"))\n    m->m_type = sdp_media_image, m->m_type_name = \"image\";\n  else if (su_casematch(s, \"red\"))\n    m->m_type = sdp_media_red, m->m_type_name = \"red\";\n  else if (su_casematch(s, \"text\"))\n    m->m_type = sdp_media_text, m->m_type_name = \"text\";\n  else\n    m->m_type = sdp_media_x, m->m_type_name = s;\n}\n\n/** Set transport protocol.\n *\n * Set the @m->m_proto to a well-known protocol type as\n * well as canonize case of @a m_proto_name.\n */\nvoid sdp_media_transport(sdp_media_t *m, char const *s)\n{\n  if (m == NULL || s == NULL)\n    ;\n  else if (su_strmatch(s, \"*\"))\n    m->m_proto = sdp_proto_any, m->m_proto_name = \"*\";\n  else if (su_casematch(s, \"RTP/AVP\"))\n    m->m_proto = sdp_proto_rtp, m->m_proto_name = \"RTP/AVP\";\n  else if (su_casematch(s, \"RTP/SAVP\"))\n    m->m_proto = sdp_proto_srtp, m->m_proto_name = \"RTP/SAVP\";\n  else if (su_casematch(s, \"UDP/TLS/RTP/SAVP\"))\n    m->m_proto = sdp_proto_srtp, m->m_proto_name = \"RTP/SAVP\";\n  else if (su_casematch(s, \"RTP/SAVPF\"))\n\t  m->m_proto = sdp_proto_extended_srtp, m->m_proto_name = \"RTP/SAVPF\";\n  else if (su_casematch(s, \"UDP/TLS/RTP/SAVPF\"))\n    m->m_proto = sdp_proto_extended_srtp, m->m_proto_name = \"UDP/TLS/RTP/SAVPF\";\n  else if (su_casematch(s, \"RTP/AVPF\"))\n\t  m->m_proto = sdp_proto_extended_rtp, m->m_proto_name = \"RTP/AVPF\";\n  else if (su_casematch(s, \"UDP/RTP/AVPF\"))\n    m->m_proto = sdp_proto_extended_rtp, m->m_proto_name = \"UDP/RTP/AVPF\";\n  else if (su_casematch(s, \"udptl\"))\n    /* Lower case - be compatible with people living by T.38 examples */\n    m->m_proto = sdp_proto_udptl, m->m_proto_name = \"udptl\";\n  else if (su_casematch(s, \"TCP/MSRP\"))\n    m->m_proto = sdp_proto_msrp, m->m_proto_name = \"TCP/MSRP\";\n  else if (su_casematch(s, \"TCP/TLS/MSRP\"))\n    m->m_proto = sdp_proto_msrps, m->m_proto_name = \"TCP/TLS/MSRP\";\n  else if (su_casematch(s, \"UDP\"))\n    m->m_proto = sdp_proto_udp, m->m_proto_name = \"UDP\";\n  else if (su_casematch(s, \"TCP\"))\n    m->m_proto = sdp_proto_tcp, m->m_proto_name = \"TCP\";\n  else if (su_casematch(s, \"TLS\"))\n    m->m_proto = sdp_proto_tls, m->m_proto_name = \"TLS\";\n  else\n    m->m_proto = sdp_proto_x, m->m_proto_name = s;\n}\n\n/** Check if media uses RTP as its transport protocol.  */\nint sdp_media_has_rtp(sdp_media_t const *m)\n{\n\treturn m && (m->m_proto == sdp_proto_rtp || m->m_proto == sdp_proto_srtp || m->m_proto == sdp_proto_extended_srtp || m->m_proto == sdp_proto_extended_rtp);\n}\n\n#define RTPMAP(pt, encoding, rate, params) \\\n  { sizeof(sdp_rtpmap_t), NULL, encoding, rate, (char *)params, NULL, 1, pt, 0 }\n\n/* rtpmaps for well-known codecs */\nstatic sdp_rtpmap_t const\n  sdp_rtpmap_pcmu = RTPMAP(0, \"PCMU\", 8000, 0),\n  sdp_rtpmap_1016 = RTPMAP(1, \"1016\", 8000, 0),\n  sdp_rtpmap_g721 = RTPMAP(2, \"G721\", 8000, 0),\n  sdp_rtpmap_gsm =  RTPMAP(3, \"GSM\",  8000, 0),\n  sdp_rtpmap_g723 = RTPMAP(4, \"G723\", 8000, 0),\n  sdp_rtpmap_dvi4_8000 = RTPMAP(5, \"DVI4\", 8000, 0),\n  sdp_rtpmap_dvi4_16000 = RTPMAP(6, \"DVI4\", 16000, 0),\n  sdp_rtpmap_lpc = RTPMAP(7, \"LPC\",  8000, 0),\n  sdp_rtpmap_pcma = RTPMAP(8, \"PCMA\", 8000, 0),\n  sdp_rtpmap_g722 = RTPMAP(9, \"G722\", 8000, 0),\n  sdp_rtpmap_l16_2 = RTPMAP(10, \"L16\", 44100, \"2\"),\n  sdp_rtpmap_l16 = RTPMAP(11, \"L16\", 44100, 0),\n  sdp_rtpmap_qcelp = RTPMAP(12, \"QCELP\", 8000, 0),\n  sdp_rtpmap_cn = RTPMAP(13, \"CN\", 8000, 0),\n  sdp_rtpmap_mpa = RTPMAP(14, \"MPA\", 90000, 0),\n  sdp_rtpmap_g728 = RTPMAP(15, \"G728\", 8000, 0),\n  sdp_rtpmap_dvi4_11025 = RTPMAP(16, \"DVI4\", 11025, 0),\n  sdp_rtpmap_dvi4_22050 = RTPMAP(17, \"DVI4\", 22050, 0),\n  sdp_rtpmap_g729 = RTPMAP(18, \"G729\", 8000, 0),\n  sdp_rtpmap_reserved_cn = RTPMAP(19, \"CN\", 8000, 0),\n  /* video codecs */\n  sdp_rtpmap_celb = RTPMAP(25, \"CelB\", 90000, 0),\n  sdp_rtpmap_jpeg = RTPMAP(26, \"JPEG\", 90000, 0),\n  sdp_rtpmap_nv = RTPMAP(28, \"nv\",   90000, 0),\n  sdp_rtpmap_h261 = RTPMAP(31, \"H261\", 90000, 0),\n  sdp_rtpmap_mpv = RTPMAP(32, \"MPV\",  90000, 0),\n  sdp_rtpmap_mp2t = RTPMAP(33, \"MP2T\", 90000, 0),\n  sdp_rtpmap_h263 = RTPMAP(34, \"H263\", 90000, 0);\n\n/** Table of rtpmap structures by payload type numbers.\n *\n * The table of reserved payload numbers is constructed from @RFC3551\n * and @RFC1890. Note the clock rate of G722.\n *\n * Use sdp_rtpmap_dup() to copy these structures.\n */\nsdp_rtpmap_t const * const sdp_rtpmap_well_known[128] =\n{\n  &sdp_rtpmap_pcmu,\t\t/* 0 */\n  &sdp_rtpmap_1016,\t\t/* 1 */\n  &sdp_rtpmap_g721,\t\t/* 2 */\n  &sdp_rtpmap_gsm,\t\t/* 3 */\n  &sdp_rtpmap_g723,\t\t/* 4 */\n  &sdp_rtpmap_dvi4_8000,\t/* 5 */\n  &sdp_rtpmap_dvi4_16000,\t/* 6 */\n  &sdp_rtpmap_lpc,\t\t/* 7 */\n  &sdp_rtpmap_pcma,\t\t/* 8 */\n  &sdp_rtpmap_g722,\t\t/* 9 */\n  &sdp_rtpmap_l16_2,\t\t/* 10 */\n  &sdp_rtpmap_l16,\t\t/* 11 */\n  &sdp_rtpmap_qcelp,\t\t/* 12 */\n  &sdp_rtpmap_cn,\t\t/* 13 */\n  &sdp_rtpmap_mpa,\t\t/* 14 */\n  &sdp_rtpmap_g728,\t\t/* 15 */\n  &sdp_rtpmap_dvi4_11025,\t/* 16 */\n  &sdp_rtpmap_dvi4_22050,\t/* 17 */\n  &sdp_rtpmap_g729,\t\t/* 18 */\n  &sdp_rtpmap_reserved_cn,\t/* 19 */\n  NULL,\t\t\t\t/* 20 */\n  NULL,\t\t\t\t/* 21 */\n  NULL,\t\t\t\t/* 22 */\n  NULL,\t\t\t\t/* 23 */\n  NULL,\t\t\t\t/* 24 */\n  &sdp_rtpmap_celb,\t\t/* 25 */\n  &sdp_rtpmap_jpeg,\t\t/* 26 */\n  NULL,\t\t\t\t/* 27 */\n  &sdp_rtpmap_nv,\t\t/* 28 */\n  NULL,\t\t\t\t/* 29 */\n  NULL,\t\t\t\t/* 30 */\n  &sdp_rtpmap_h261,\t\t/* 31 */\n  &sdp_rtpmap_mpv,\t\t/* 32 */\n  &sdp_rtpmap_mp2t,\t\t/* 33 */\n  &sdp_rtpmap_h263,\t\t/* 34 */\n  NULL,\n};\n\n/**\n * The function parse_payload() parses an RTP payload type list, and\n * creates an rtpmap structure for each payload type.\n *\n * @param p       pointer to SDP parser object\n * @param r       pointer to record data\n * @param result  pointer to which parsed record is assigned\n */\nstatic void parse_payload(sdp_parser_t *p, char *r, sdp_rtpmap_t **result)\n{\n  while (*r) {\n    unsigned long value;\n\n    if (parse_ul(p, &r, &value, 128) == 0) {\n      PARSE_ALLOC(p, sdp_rtpmap_t, rm);\n\n      assert(0 <= value && value < 128);\n\n      *result = rm; result = &rm->rm_next;\n\n      if (sdp_rtpmap_well_known[value]) {\n\t*rm = *sdp_rtpmap_well_known[value];\n      }\n      else {\n\trm->rm_predef = 1;\n\trm->rm_pt = value;\n\trm->rm_encoding = \"\";\n\trm->rm_rate = 0;\n      }\n    }\n    else if (p->pr_config && r[0] == '*' && (r[1] == ' ' || r[1] == '\\0')) {\n      PARSE_ALLOC(p, sdp_rtpmap_t, rm);\n\n      *result = rm;\n\n      rm->rm_predef = 1;\n      rm->rm_any = 1;\n      rm->rm_encoding = \"*\";\n      rm->rm_rate = 0;\n\n      return;\n    }\n    else {\n      parsing_error(p, \"m= invalid format for RTP/AVT\");\n\n      return;\n    }\n  }\n}\n\n/* -------------------------------------------------------------------------\n * Function parse_media_attr() - parse a media-specific \"a=\" field\n *\n * Description:\n *   This function parses a media-specific attribute field.\n *\n * Parameters:\n *   p      - pointer to SDP parser object\n *   r      - pointer to record data\n *   result - pointer to which parsed record is assigned\n */\nstatic void parse_media_attr(sdp_parser_t *p, char *r, sdp_media_t *m,\n\t\t\t     sdp_attribute_t **result)\n{\n  /*\n   attribute-fields =    *(\"a=\" attribute CRLF)\n\n   attribute =           (att-field \":\" att-value) / att-field\n\n   att-field =           token\n\n   att-value =           byte-string\n\n   a=rtpmap:<payload type> <encoding name>/<clock rate>[/<encoding parameters>]\n   a=fmtp:<payload type> <parameters>\n   */\n  int rtp = sdp_media_has_rtp(m);\n  char *name = NULL, *value = NULL;\n  int n;\n\n  if (!(name = token(&r, \":\", TOKEN, SPACE TAB))) {\n    parsing_error(p,\"invalid attribute name\");\n    return;\n  }\n\n  if (*r)\n    value = r;\n  else\n    PARSE_CHECK_REST(p, r, \"a\");\n\n  if (p->pr_mode_manual)\n    ;\n  else if (m->m_port == 0 || su_casematch(name, \"inactive\")) {\n    m->m_mode = sdp_inactive;\n    return;\n  }\n  else if (su_casematch(name, \"sendonly\")) {\n    m->m_mode = sdp_sendonly;\n    return;\n  }\n  else if (su_casematch(name, \"recvonly\")) {\n    m->m_mode = sdp_recvonly;\n    return;\n  }\n  else if (su_casematch(name, \"sendrecv\")) {\n    m->m_mode = sdp_sendrecv;\n    return;\n  }\n\n  if (rtp && su_casematch(name, \"rtpmap\")) {\n\t  if ((n = parse_rtpmap(p, r, m)) == 0 || n < -1)\n\t\t  return;\n  }\n  else if (rtp && su_casematch(name, \"fmtp\")) {\n    if ((n = parse_fmtp(p, r, m)) == 0 || n < -1)\n      return;\n  }\n  else {\n    PARSE_ALLOC(p, sdp_attribute_t, a);\n    *result = a;\n\n    a->a_name  = name;\n    a->a_value = value;\n  }\n}\n\n/** Parse rtpmap attribute.\n *\n * a=rtpmap:<payload type> <encoding name>/<clock rate>[/<encoding parameters>]\n */\nstatic int parse_rtpmap(sdp_parser_t *p, char *r, sdp_media_t *m)\n{\n  unsigned long pt, rate;\n  char *encoding, *params;\n  sdp_rtpmap_t *rm;\n\n  int strict = STRICT(p);\n\n  if (parse_ul(p, &r, &pt, 128)) {\n    if (strict)\n      parsing_error(p, \"a=rtpmap: invalid payload type\");\n    return -1;\n  }\n\n  for (rm = m->m_rtpmaps; rm; rm = rm->rm_next)\n    if (rm->rm_pt == pt)\n      break;\n\n  if (!rm) {\n    if (strict)\n      parsing_error(p, \"a=rtpmap:%lu: unknown payload type\", pt);\n    return -1;\n  }\n\n  encoding = token(&r, \"/\", TOKEN, NULL);\n  if (!r) {\n    parsing_error(p, \"a=rtpmap:%lu: missing <clock rate>\", pt);\n    return -2;\n  }\n  if (parse_ul(p, &r, &rate, 0)) {\n    parsing_error(p, \"a=rtpmap:%lu %s: invalid <clock rate>\", pt, encoding);\n    return -2;\n  }\n\n  if (*r == '/')\n    params = ++r;\n  else\n    params = 0;\n\n  rm->rm_predef = 0;\n  rm->rm_encoding = encoding;\n  rm->rm_rate = rate;\n  rm->rm_params = params;\n\n  return 0;\n}\n\n/** Parse fmtp attribute.\n *\n * a=fmtp:<payload type> <parameters>\n */\nstatic int parse_fmtp(sdp_parser_t *p, char *r, sdp_media_t *m)\n{\n  unsigned long pt;\n  sdp_rtpmap_t *rm;\n\n  int strict = STRICT(p);\n\n  if (parse_ul(p, &r, &pt, 128)) {\n    if (strict)\n      parsing_error(p, \"a=rtpmap: invalid payload type\");\n    return -1;\n  }\n\n  for (rm = m->m_rtpmaps; rm; rm = rm->rm_next)\n    if (rm->rm_pt == pt)\n      break;\n\n  if (!rm) {\n    if (strict)\n      parsing_error(p, \"a=fmtp:%lu: unknown payload type\", pt);\n    return -1;\n  }\n\n  rm->rm_fmtp = r;\n  return 0;\n}\n\n/* -------------------------------------------------------------------------\n * Function parse_descs() - parse media descriptors\n *\n * Description:\n *   This function parses media descriptors at the end of SDP message.\n *\n * Parameters:\n *   p      - pointer to SDP parser object\n *   record - pointer to first media field\n *   message - pointer to rest\n *   medias - pointer to which parsed media structures are assigned\n */\nstatic void parse_descs(sdp_parser_t *p,\n\t\t\tchar *record,\n\t\t\tchar *message,\n\t\t\tsdp_media_t **medias)\n{\n  char *rest;\n  const char *strip;\n  sdp_media_t *m = NULL;\n  sdp_connection_t **connections = NULL;\n  sdp_bandwidth_t **bandwidths = NULL;\n  sdp_attribute_t **attributes = NULL;\n\n  if (!STRICT(p))\n    strip = SPACE TAB;\t\t/* skip initial whitespace */\n  else\n    strip = \"\";\n\n  for (;\n       record && p->pr_ok;\n       record = next(&message, CRLF, strip)) {\n    char field = record[0];\n\n    rest = record + 2; rest += strspn(rest, strip);\n\n    if (record[1] == '=') switch (field) {\n    case 'c':\n      assert(connections);\n      parse_connection(p, rest, connections);\n      connections = &(*connections)->c_next;\n      break;\n\n    case 'b':\n      assert(bandwidths);\n      parse_bandwidth(p, rest, bandwidths);\n      bandwidths = &(*bandwidths)->b_next;\n      break;\n\n    case 'i': \n      parse_information(p, rest, &m->m_information);\n      break;\n     \n    case 'k':\n      parse_key(p, rest, &m->m_key);\n      break;\n\n    case 'a':\n      assert(attributes);\n      parse_media_attr(p, rest, m, attributes);\n      if (*attributes)\n\tattributes = &(*attributes)->a_next;\n      break;\n\n    case 'm':\n      parse_media(p, rest, medias);\n      m = *medias;\n      if (m) {\n\tm->m_mode = p->pr_session_mode;\n\tmedias = &m->m_next;\n\tconnections = &m->m_connections;\n\tbandwidths = &m->m_bandwidths;\n\tattributes = &m->m_attributes;\n      }\n    }\n  }\n}\n\nstatic void parse_text_list(sdp_parser_t *p, char *r, sdp_list_t **result)\n{\n  PARSE_ALLOC(p, sdp_list_t, l);\n\n  *result = l;\n\n  l->l_text = r;\n}\n\n/*\n * parse_ul: parse an unsigned long\n */\nstatic int parse_ul(sdp_parser_t *p, char **r,\n\t\t    unsigned long *result, unsigned long max)\n{\n  char *ul = *r;\n\n  ul += strspn(ul, SPACE TAB);\n\n  *result = strtoul(ul, r, 10);\n  if (ul != *r && !(max && max <= *result)) {\n    *r += strspn(*r, SPACE TAB);\n    return 0;\n  }\n\n  return -1;\n}\n\n#if !HAVE_STRTOULL\n#if !((defined(WIN32) || defined(_WIN32)) && (_MSC_VER >= 1800))\nunsigned long long strtoull(char const *string, char **return_end, int base);\n#endif\n#endif\n\n/*\n * parse_ull: parse an unsigned long long\n */\nstatic int parse_ull(sdp_parser_t *p, char **r,\n\t\t     uint64_t *result, uint64_t max)\n{\n  unsigned long long ull;\n\n  char *s = *r;\n\n  s += strspn(s, SPACE TAB);\n\n  ull = strtoull(s, r, 10);\n\n  if (s != *r && !(max && max <= ull)) {\n    *result = (uint64_t)ull;\n    *r += strspn(*r, SPACE TAB);\n    return 0;\n  }\n\n  return -1;\n}\n\nstatic char *token(char **message,\n\t\t   const char *sep,\n\t\t   const char *legal,\n\t\t   const char *strip)\n{\n  size_t n;\n  char *retval = *message;\n\n  if (strip)\n    retval += strspn(retval, strip);\n\n  if (legal)\n    n = strspn(retval, legal);\n  else\n    n = strcspn(retval, sep);\n\n  if (n == 0)\n    return NULL;\n\n  if (retval[n]) {\n    retval[n++] = '\\0';\n    n += strspn(retval + n, sep);\n  }\n\n  *message = retval + n;\n\n  if (*retval == '\\0')\n    return NULL;\n\n  return retval;\n}\n\nstatic char *next(char **message, const char *sep, const char *strip)\n{\n  size_t n;\n  char *retval = *message;\n\n  if (strip[0])\n    retval += strspn(retval, strip);\n\n  n = strcspn(retval, sep);\n\n  if (n == 0)\n    return NULL;\n\n  if (retval[n]) {\n    retval[n++] = '\\0';\n    n += strspn(retval + n, sep);\n  }\n\n  *message = retval + n;\n\n  if (*retval == '\\0')\n    return NULL;\n\n  return retval;\n}\n\nstatic int parsing_error(sdp_parser_t *p, char const *fmt, ...)\n{\n  va_list ap;\n  va_start(ap, fmt);\n\n  memset(p->pr_error, 0, sizeof(p->pr_error));\n  vsnprintf(p->pr_error, sizeof(p->pr_error), fmt, ap);\n  va_end(ap);\n\n  p->pr_ok = 0;\n\n  return -1;\n}\n\nstatic void parse_alloc_error(sdp_parser_t *p, const char *typename)\n{\n  parsing_error(p, \"memory exhausted (while allocating memory for %s)\",\n\t\ttypename);\n}\n"], "fixing_code": ["/*\n * This file is part of the Sofia-SIP package\n *\n * Copyright (C) 2005 Nokia Corporation.\n *\n * Contact: Pekka Pessi <pekka.pessi@nokia.com>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public License\n * as published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA\n *\n */\n\n/**@ingroup sdp_parser\n * @CFILE sdp_parse.c\n * @brief Simple SDP parser interface.\n *\n * @author Pekka Pessi <Pekka.Pessi@nokia.com>\n * @author Kai Vehmanen <kai.vehmanen@nokia.com>\n *\n * @date  Created: Fri Feb 18 10:25:08 2000 ppessi\n *\n * @sa @RFC4566, @RFC2327.\n */\n\n#include \"config.h\"\n\n#include <sofia-sip/su_alloc.h>\n#include <sofia-sip/su_string.h>\n\n#include \"sofia-sip/sdp.h\"\n\n#include <stddef.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <limits.h>\n#include <assert.h>\n\n/** @typedef struct sdp_parser_s sdp_parser_t;\n *\n * SDP parser handle.\n *\n * The SDP parser handle returned by sdp_parse() contains either\n * a successfully parsed SDP session #sdp_session_t or an error message.\n * If sdp_session() returns non-NULL, parsing was successful.\n *\n * @sa #sdp_session_t, sdp_parse(), sdp_session(), sdp_parsing_error(),\n * sdp_sanity_check(), sdp_parser_home(), sdp_parser_free(), @RFC4566,\n * @RFC2327.\n */\n\nstruct sdp_parser_s {\n  su_home_t       pr_home[1];\n  union {\n    char          pru_error[128];\n    sdp_session_t pru_session[1];\n  } pr_output;\n  char      *pr_message;\n\n  sdp_mode_t pr_session_mode;\n\n  unsigned   pr_ok : 1;\n\n  unsigned   pr_strict : 1;\n  unsigned   pr_anynet : 1;\n  unsigned   pr_mode_0000 : 1;\n  unsigned   pr_mode_manual : 1;\n  unsigned   pr_insane : 1;\n  unsigned   pr_c_missing : 1;\n  unsigned   pr_config : 1;\n};\n\n#define is_posdigit(c) ((c) >= '1' && (c) <= '9')\n#define is_digit(c) ((c) >= '0' && (c) <= '9')\n#define is_space(c) ((c) == ' ')\n#define is_tab(c) ((c) == '\\t')\n\n#define pr_error   pr_output.pru_error\n#define pr_session pr_output.pru_session\n\n#ifdef _MSC_VER\n#undef STRICT\n#endif\n#define STRICT(pr) (pr->pr_strict)\n\n/* Static parser object used when running out of memory */\nstatic const struct sdp_parser_s no_mem_error =\n{\n  { SU_HOME_INIT(no_mem_error) },\n  { \"sdp: not enough memory\" }\n};\n\n/* Internal prototypes */\nstatic void parse_message(sdp_parser_t *p);\nstatic int parsing_error(sdp_parser_t *p, char const *fmt, ...);\n\n/** Parse an SDP message.\n *\n * The function sdp_parse() parses an SDP message @a msg of size @a\n * msgsize. Parsing is done according to the given @a flags. The SDP message\n * may not contain a NUL.\n *\n * The parsing result is stored to an #sdp_session_t structure.\n *\n * @param home    memory home\n * @param msg     pointer to message\n * @param msgsize size of the message (excluding final NUL, if any)\n * @param flags   flags affecting the parsing.\n *\n * The following flags are used by parser:\n *\n * @li #sdp_f_strict Parser should accept only messages conforming strictly\n *                   to the specification.\n * @li #sdp_f_anynet Parser accepts unknown network or address types.\n * @li #sdp_f_insane Do not run sanity check.\n * @li #sdp_f_c_missing  Sanity check does not require c= for each m= line\n * @li #sdp_f_mode_0000 Parser regards \"c=IN IP4 0.0.0.0\" as \"a=inactive\"\n *                      (likewise with c=IN IP6 ::)\n * @li #sdp_f_mode_manual Do not generate or parse SDP mode\n * @li #sdp_f_config   Parse config files (any line can be missing)\n *\n * @return\n * Always a valid parser handle.\n *\n * @todo Parser accepts some non-conforming SDP even with #sdp_f_strict.\n *\n * @sa sdp_session(), sdp_parsing_error(), sdp_sanity_check(),\n * sdp_parser_home(), sdp_parser_free(), @RFC4566, @RFC2327.\n */\nsdp_parser_t *\nsdp_parse(su_home_t *home, char const msg[], issize_t msgsize, int flags)\n{\n  sdp_parser_t *p;\n  char *b;\n  size_t len;\n\n  if (msgsize == -1 || msg == NULL) {\n    p = su_home_clone(home, sizeof(*p));\n    if (p)\n      parsing_error(p, \"invalid input message\");\n    else\n      p = (sdp_parser_t*)&no_mem_error;\n    return p;\n  }\n\n  if (msgsize == -1 && msg)\n    len = strlen(msg);\n  else\n    len = msgsize;\n\n  if (len > ISSIZE_MAX)\n    len = ISSIZE_MAX;\n\n  p = su_home_clone(home, sizeof(*p) + len + 1);\n\n  if (p) {\n    b = strncpy((void *)(p + 1), msg, len);\n    b[len] = 0;\n\n    p->pr_message = b;\n    p->pr_strict = (flags & sdp_f_strict) != 0;\n    p->pr_anynet = (flags & sdp_f_anynet) != 0;\n    p->pr_mode_0000 = (flags & sdp_f_mode_0000) != 0;\n    p->pr_insane = (flags & sdp_f_insane) != 0;\n    p->pr_c_missing = (flags & sdp_f_c_missing) != 0;\n    if (flags & sdp_f_config)\n      p->pr_c_missing = 1, p->pr_config = 1;\n    p->pr_mode_manual = (flags & sdp_f_mode_manual) != 0;\n    p->pr_session_mode = sdp_sendrecv;\n\n    parse_message(p);\n\n    return p;\n  }\n\n  if (p)\n    sdp_parser_free(p);\n\n  return (sdp_parser_t*)&no_mem_error;\n}\n\n\n/** Obtain memory home used by parser */\nsu_home_t *sdp_parser_home(sdp_parser_t *parser)\n{\n  if (parser != &no_mem_error)\n    return parser->pr_home;\n  else\n    return NULL;\n}\n\n/** Retrieve an SDP session structure.\n *\n * The function sdp_session() returns a pointer to the SDP session\n * structure associated with the SDP parser @a p. The pointer and all the\n * data in the structure are valid until sdp_parser_free() is called.\n *\n * @param p SDP parser\n *\n * @return\n *   The function sdp_session() returns a pointer to an parsed SDP message\n *   or NULL, if an error has occurred.  */\nsdp_session_t *\nsdp_session(sdp_parser_t *p)\n{\n  return p && p->pr_ok ? p->pr_session : NULL;\n}\n\n/** Get a parsing error message.\n *\n * The function sdp_parsing_error() returns the error message associated\n * with an SDP parser @a p.\n *\n * @param p SDP parser\n *\n * @return\n * The function sdp_parsing_error() returns a C string describing parsing\n * error, or NULL if no error occurred.\n */\nchar const *sdp_parsing_error(sdp_parser_t *p)\n{\n  return !p->pr_ok ? p->pr_error : NULL;\n}\n\n/** Free an SDP parser.\n *\n * The function sdp_parser_free() frees an SDP parser object along with\n * the memory blocks associated with it.\n *\n * @param p pointer to the SDP parser to be freed\n */\nvoid sdp_parser_free(sdp_parser_t *p)\n{\n  if (p && p != &no_mem_error)\n    su_home_unref(p->pr_home);\n}\n\n/* ========================================================================= */\n\n/* =========================================================================\n * Private part\n */\n\n/* Parsing tokens */\n#define SPACE \" \"\n#define TAB   \"\\011\"\n#define CRLF  \"\\015\\012\"\n#define ALPHA \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n#define DIGIT \"0123456789\"\n#define TOKEN ALPHA DIGIT \"-!#$%&'*+.^_`{|}~\"\n\n/* ========================================================================= */\n/* Parsing functions */\n\nstatic void post_session(sdp_parser_t *p, sdp_session_t *sdp);\nstatic void parse_origin(sdp_parser_t *p, char *r, sdp_origin_t **result);\nstatic void parse_subject(sdp_parser_t *p, char *r, sdp_text_t **result);\nstatic void parse_information(sdp_parser_t *p, char *r, sdp_text_t **result);\nstatic void parse_uri(sdp_parser_t *p, char *r, sdp_text_t **result);\nstatic void parse_email(sdp_parser_t *p, char *r, sdp_list_t **result);\nstatic void parse_phone(sdp_parser_t *p, char *r, sdp_list_t **result);\nstatic void parse_connection(sdp_parser_t *p, char *r, sdp_connection_t **result);\nstatic void parse_bandwidth(sdp_parser_t *p, char *r, sdp_bandwidth_t **result);\nstatic void parse_time(sdp_parser_t *p, char *r, sdp_time_t **result);\nstatic void parse_repeat(sdp_parser_t *p, char *r, sdp_repeat_t **result);\nstatic void parse_zone(sdp_parser_t *p, char *r, sdp_zone_t **result);\nstatic void parse_key(sdp_parser_t *p, char *r, sdp_key_t **result);\nstatic void parse_session_attr(sdp_parser_t *p, char *r, sdp_attribute_t **result);\nstatic void parse_media(sdp_parser_t *p, char *r, sdp_media_t **result);\nstatic void parse_payload(sdp_parser_t *p, char *r, sdp_rtpmap_t **result);\nstatic void parse_media_attr(sdp_parser_t *p, char *r, sdp_media_t *m,\n\t\t\t     sdp_attribute_t **result);\nstatic int parse_rtpmap(sdp_parser_t *p, char *r, sdp_media_t *m);\nstatic int parse_fmtp(sdp_parser_t *p, char *r, sdp_media_t *m);\nstatic void parse_text_list(sdp_parser_t *p, char *r, sdp_list_t **result);\n\nstatic void parse_descs(sdp_parser_t *p, char *r, char *m, sdp_media_t **result);\n\nstatic int parse_ul(sdp_parser_t *p, char **r, unsigned long *result,\n\t\t    unsigned long max_value);\nstatic int parse_ull(sdp_parser_t *p, char **r, uint64_t *result,\n\t\t     uint64_t max_value);\nstatic void parse_alloc_error(sdp_parser_t *p, const char *typename);\nstatic char *next(char **message, const char *sep, const char *strip);\nstatic char *token(char **message, const char *sep, const char *legal,\n\t\t   const char *strip);\n#if 0\nstatic void check_mandatory(sdp_parser_t *p, sdp_session_t *sdp);\n#endif\n\n/* -------------------------------------------------------------------------\n * Macro PARSE_ALLOC\n *\n * Description:\n *   This macro declares a pointer (v) of given type (t). It then allocates\n *   an structure of given type (t). If allocation was succesful, it assigns\n *   the XX_size member with appropriate value.\n */\n#define PARSE_ALLOC(p, t, v) \\\n t *v = su_salloc(p->pr_home, sizeof(*v)); \\\n if (!v && (parse_alloc_error(p, #t), 1)) return;\n\n/* -------------------------------------------------------------------------\n * Macro PARSE_CHECK_REST\n *\n * Description:\n *   This macro check if there is extra data at the end of field.\n */\n#define PARSE_CHECK_REST(p, s, n)\\\n if (*s && (parsing_error(p, \"extra data after %s (\\\"%.04s\\\")\", n, s), 1)) \\\n    return\n\n/* -------------------------------------------------------------------------\n * Function parse_message() - parse an SDP message\n *\n * Description:\n *   This function parses an SDP message, which is copied into the\n *   p->pr_message. The p->pr_message is modified during the parsing,\n *   and parts of it are returned in p->pr_session.\n *\n * Parameters:\n *   p - pointer to SDP parser object\n */\nstatic void parse_message(sdp_parser_t *p)\n{\n/*\n   announcement =        proto-version\n                         origin-field\n                         session-name-field\n                         information-field\n                         uri-field\n                         email-fields\n                         phone-fields\n                         connection-field\n                         bandwidth-fields\n                         time-fields\n                         key-field\n                         attribute-fields\n                         media-descriptions\n*/\n\n  sdp_session_t *sdp = p->pr_session;\n  char *record, *rest;\n  char const *strip;\n  char *message = p->pr_message;\n  char field = '\\0';\n  sdp_list_t **emails = &sdp->sdp_emails;\n  sdp_list_t **phones = &sdp->sdp_phones;\n  sdp_bandwidth_t **bandwidths = &sdp->sdp_bandwidths;\n  sdp_time_t **times = &sdp->sdp_time;\n  sdp_repeat_t **repeats = NULL;\n  sdp_zone_t **zones = NULL;\n  sdp_attribute_t **attributes = &sdp->sdp_attributes;\n\n  if (!STRICT(p))\n    strip = SPACE TAB;\t\t/* skip initial whitespace */\n  else\n    strip = \"\";\n\n  p->pr_ok = 1;\n  p->pr_session->sdp_size = sizeof(p->pr_session);\n\n  /* Require that version comes first */\n  record = next(&message, CRLF, strip);\n\n  if (!su_strmatch(record, \"v=0\")) {\n    if (!p->pr_config || !record || record[1] != '=') {\n      parsing_error(p, \"bad SDP message\");\n      return;\n    }\n  }\n  else {\n    record = next(&message, CRLF, strip);\n  }\n\n  /*\n    XXX - the lines in SDP are in certain order, which we don't check here.\n     For stricter parsing we might want to parse o= and s= next.\n  */\n\n  for (;\n       record && p->pr_ok;\n       record = next(&message, CRLF, strip)) {\n    field = record[0];\n\n    if (strlen(record) < 2) {\n      return;\n    }\n\n    rest = record + 2; rest += strspn(rest, strip);\n\n    if (record[1] != '=') {\n      parsing_error(p, \"bad line \\\"%s\\\"\", record);\n      return;\n    }\n\n    switch (field) {\n    case 'o':\n      parse_origin(p, rest, &sdp->sdp_origin);\n      break;\n\n    case 's':\n      parse_subject(p, rest, &sdp->sdp_subject);\n      break;\n\n    case 'i':\n      parse_information(p, rest, &sdp->sdp_information);\n      break;\n\n    case 'u':\n      parse_uri(p, rest, &sdp->sdp_uri);\n      break;\n\n    case 'e':\n      parse_email(p, rest, emails);\n      emails = &(*emails)->l_next;\n      break;\n\n    case 'p':\n      parse_phone(p, rest, phones);\n      phones = &(*phones)->l_next;\n      break;\n\n    case 'c':\n      parse_connection(p, rest, &sdp->sdp_connection);\n      break;\n\n    case 'b':\n      parse_bandwidth(p, rest, bandwidths);\n      bandwidths = &(*bandwidths)->b_next;\n      break;\n\n    case 't':\n      parse_time(p, rest, times);\n      repeats = &(*times)->t_repeat;\n      zones = &(*times)->t_zone;\n      times = &(*times)->t_next;\n      break;\n\n    case 'r':\n      if (repeats)\n\tparse_repeat(p, rest, repeats);\n      else\n\tparsing_error(p, \"repeat field without time field\");\n      break;\n\n    case 'z':\n      if (zones)\n\tparse_zone(p, rest, zones), zones = NULL;\n      else\n\tparsing_error(p, \"zone field without time field\");\n      break;\n\n    case 'k':\n      parse_key(p, rest, &sdp->sdp_key);\n      break;\n\n    case 'a':\n      parse_session_attr(p, rest, attributes);\n      if (*attributes)\n\tattributes = &(*attributes)->a_next;\n      break;\n\n    case 'm':\n      parse_descs(p, record, message, &sdp->sdp_media);\n      post_session(p, sdp);\n      return;\n\n    default:\n      parsing_error(p, \"unknown field \\\"%s\\\"\", record);\n      return;\n    }\n  }\n\n  post_session(p, sdp);\n}\n#ifdef SOFIA_AUTO_CORRECT_INADDR_ANY\nint sdp_connection_is_inaddr_any(sdp_connection_t const *c)\n{\n  return\n    c &&\n    c->c_nettype == sdp_net_in &&\n    ((c->c_addrtype == sdp_addr_ip4 && su_strmatch(c->c_address, \"0.0.0.0\")) ||\n     (c->c_addrtype == sdp_addr_ip6 && su_strmatch(c->c_address, \"::\")));\n}\n#endif\n\n/**Postprocess session description.\n *\n * Postprocessing includes setting the session backpointer for each media,\n * doing sanity checks and setting rejected and mode flags.\n */\nstatic void post_session(sdp_parser_t *p, sdp_session_t *sdp)\n{\n  sdp_media_t *m;\n#ifdef SOFIA_AUTO_CORRECT_INADDR_ANY\n  sdp_connection_t const *c;\n#endif\n\n  if (!p->pr_ok)\n    return;\n\n  /* Set session back-pointer */\n  for (m = sdp->sdp_media; m; m = m->m_next) {\n    m->m_session = sdp;\n  }\n\n  if (p->pr_config) {\n    if (sdp->sdp_version[0] != 0)\n      parsing_error(p, \"Incorrect version\");\n    return;\n  }\n\n  /* Go through all media and set mode */\n  for (m = sdp->sdp_media; m; m = m->m_next) {\n    if (m->m_port == 0) {\n      m->m_mode = sdp_inactive;\n      m->m_rejected = 1;\n      continue;\n    }\n\n#ifdef SOFIA_AUTO_CORRECT_INADDR_ANY\n    c = sdp_media_connections(m);\n\n\n    if (p->pr_mode_0000 && sdp_connection_is_inaddr_any(c)) {\n      /* Reset recvonly flag */\n      m->m_mode &= ~sdp_recvonly;\n    }\n#endif\n  }\n\n  if (p->pr_insane)\n    return;\n\n  /* Verify that all mandatory fields are present */\n  if (sdp_sanity_check(p) < 0)\n    return;\n}\n\n/** Validates that all mandatory fields exist\n *\n * Checks that all necessary fields (v=, o=) exists in the parsed sdp. If\n * strict, check that all mandatory fields (c=, o=, s=, t=) are present.\n * This function also goes through all media, marks rejected media as such,\n * and updates the mode accordingly.\n *\n * @retval 0 if parsed SDP description is valid\n * @retval -1 if some SDP line is missing\n * @retval -2 if c= line is missing\n */\nint sdp_sanity_check(sdp_parser_t *p)\n{\n  sdp_session_t *sdp = p->pr_session;\n  sdp_media_t *m;\n\n  if (!p || !p->pr_ok)\n    return -1;\n  else if (sdp->sdp_version[0] != 0)\n    return parsing_error(p, \"Incorrect version\");\n  else if (!sdp->sdp_origin)\n    return parsing_error(p, \"No o= present\");\n  else if (p->pr_strict && !sdp->sdp_subject)\n    return parsing_error(p, \"No s= present\");\n  else if (p->pr_strict && !sdp->sdp_time)\n    return parsing_error(p, \"No t= present\");\n\n  /* If there is no session level c= check that one exists for all media */\n  /* c= line may be missing if this is a RTSP description */\n  if (!p->pr_c_missing && !sdp->sdp_connection) {\n    for (m = sdp->sdp_media ; m ; m = m->m_next) {\n      if (!m->m_connections && !m->m_rejected) {\n\tparsing_error(p, \"No c= on either session level or all mediums\");\n\treturn -2;\n      }\n    }\n  }\n\n  return 0;\n}\n\n#if 0\n/**\n * Parse a \"v=\" field\n *\n * The function parser_version() parses the SDP version field.\n *\n * @param p      pointer to SDP parser object\n * @param r      pointer to record data\n * @param result pointer to which parsed record is assigned\n */\nstatic void parse_version(sdp_parser_t *p, char *r, sdp_version_t *result)\n{\n  /*\n   proto-version =       \"v=\" 1*DIGIT CRLF\n                         ;[RFC2327] describes version 0\n   */\n  if (parse_ul(p, &r, result, 0))\n    parsing_error(p, \"version \\\"%s\\\" is invalid\", r);\n  else if (*result > 0)\n    parsing_error(p, \"unknown version v=%s\", r);\n}\n#endif\n\n/* -------------------------------------------------------------------------\n * Function parse_origin() - parse an \"o=\" field\n *\n * Description:\n *   This function parses an SDP origin field.\n *\n * Parameters:\n *   p      - pointer to SDP parser object\n *   r      - pointer to record data\n *   result - pointer to which parsed record is assigned\n */\nstatic void parse_origin(sdp_parser_t *p, char *r, sdp_origin_t **result)\n{\n  /*\n   origin-field =        \"o=\" username space\n                         sess-id space sess-version space\n                         nettype space addrtype space\n                         addr CRLF\n\n   username =            safe\n                         ;pretty wide definition, but doesn't include space\n\n   sess-id =             1*(DIGIT)\n                         ;should be unique for this originating username/host\n\n   sess-version =        1*(DIGIT)\n                         ;0 is a new session\n\n\n   */\n  PARSE_ALLOC(p, sdp_origin_t, o);\n\n  *result = o;\n\n  o->o_username = token(&r, SPACE TAB, NULL, SPACE TAB);\n  if (!o->o_username) {\n    parsing_error(p, \"invalid username\");\n    return;\n  }\n  if (parse_ull(p, &r, &o->o_id, 0)) {\n    parsing_error(p, \"invalid session id\");\n    return;\n  }\n\n  if (parse_ull(p, &r, &o->o_version, 0)) {\n    parsing_error(p, \"invalid session version\");\n    return;\n  }\n\n  parse_connection(p, r, &o->o_address);\n}\n\n/* -------------------------------------------------------------------------\n * Function parse_subject() - parse an \"s=\" field\n *\n * Description:\n *   This function parses an SDP subject field.\n *\n * Parameters:\n *   p      - pointer to SDP parser object\n *   r      - pointer to record data\n *   result - pointer to which parsed record is assigned\n */\nstatic void parse_subject(sdp_parser_t *p, char *r, sdp_text_t **result)\n{\n  /*\n   session-name-field =  \"s=\" text CRLF\n   text =                byte-string\n   */\n  *result = r;\n}\n\n/* -------------------------------------------------------------------------\n * Function parse_information() - parse an \"i=\" field\n *\n * Description:\n *   This function parses an SDP information field.\n *\n * Parameters:\n *   p      - pointer to SDP parser object\n *   r      - pointer to record data\n *   result - pointer to which parsed record is assigned\n */\nstatic void parse_information(sdp_parser_t *p, char *r, sdp_text_t **result)\n{\n  /*\n   information-field =   [\"i=\" text CRLF]\n   */\n  if (result) *result = r;\n}\n\n/* -------------------------------------------------------------------------\n * Function parse_uri() - parse an \"u=\" field\n *\n * Description:\n *   This function parses an SDP URI field.\n *\n * Parameters:\n *   p      - pointer to SDP parser object\n *   r      - pointer to record data\n *   result - pointer to which parsed record is assigned\n */\nstatic void parse_uri(sdp_parser_t *p, char *r, sdp_text_t **result)\n{\n  /*\n    uri-field =           [\"u=\" uri CRLF]\n\n    uri=                  ;defined in RFC1630\n  */\n  /* XXX - no syntax checking here */\n  *result = r;\n}\n\n/* -------------------------------------------------------------------------\n * Function parse_email() - parse an \"e=\" field\n *\n * Description:\n *   This function parses an SDP email field.\n *\n * Parameters:\n *   p      - pointer to SDP parser object\n *   r      - pointer to record data\n *   result - pointer to which parsed record is assigned\n */\nstatic void parse_email(sdp_parser_t *p, char *r, sdp_list_t **result)\n{\n  /*\n   email-fields =        *(\"e=\" email-address CRLF)\n\n   email-address =       email | email \"(\" email-safe \")\" |\n                         email-safe \"<\" email \">\"\n\n   email =               ;defined in RFC822  */\n  parse_text_list(p, r, result);\n}\n\n/* -------------------------------------------------------------------------\n * Function parse_phone() - parse an \"p=\" field\n *\n * Description:\n *   This function parses an SDP phone field.\n *\n * Parameters:\n *   p      - pointer to SDP parser object\n *   r      - pointer to record data\n *   result - pointer to which parsed record is assigned\n */\nstatic void parse_phone(sdp_parser_t *p, char *r, sdp_list_t **result)\n{\n  /*\n   phone-fields =        *(\"p=\" phone-number CRLF)\n\n   phone-number =        phone | phone \"(\" email-safe \")\" |\n                         email-safe \"<\" phone \">\"\n\n   phone =               \"+\" POS-DIGIT 1*(space | \"-\" | DIGIT)\n                         ;there must be a space or hyphen between the\n                         ;international code and the rest of the number.\n  */\n  parse_text_list(p, r, result);\n}\n\n/* -------------------------------------------------------------------------\n * Function parse_connection() - parse an \"c=\" field\n *\n * Description:\n *   This function parses an SDP connection field.\n *\n * Parameters:\n *   p      - pointer to SDP parser object\n *   r      - pointer to record data\n *   result - pointer to which parsed record is assigned\n */\nstatic void parse_connection(sdp_parser_t *p, char *r, sdp_connection_t **result)\n{\n  /*\n   connection-field =    [\"c=\" nettype space addrtype space\n                         connection-address CRLF]\n                         ;a connection field must be present\n                         ;in every media description or at the\n                         ;session-level\n\n   nettype =             \"IN\"\n                         ;list to be extended\n\n   addrtype =            \"IP4\" | \"IP6\"\n                         ;list to be extended\n\n   connection-address =  multicast-address\n                         | addr\n\n   multicast-address =   3*(decimal-uchar \".\") decimal-uchar \"/\" ttl\n                         [ \"/\" integer ]\n                         ;multicast addresses may be in the range\n                         ;224.0.0.0 to 239.255.255.255\n\n   ttl =                 decimal-uchar\n\n   addr =                FQDN | unicast-address\n\n   FQDN =                4*(alpha-numeric|\"-\"|\".\")\n                         ;fully qualified domain name as specified in RFC1035\n\n   unicast-address =     IP4-address | IP6-address\n\n   IP4-address =         b1 \".\" decimal-uchar \".\" decimal-uchar \".\" b4\n   b1 =                  decimal-uchar\n                         ;less than \"224\"; not \"0\" or \"127\"\n   b4 =                  decimal-uchar\n                         ;not \"0\"\n\n   IP6-address =         ;to be defined\n   */\n  PARSE_ALLOC(p, sdp_connection_t, c);\n\n  *result = c;\n\n  if (su_casenmatch(r, \"IN\", 2)) {\n    char *s;\n\n    /* nettype is internet */\n    c->c_nettype = sdp_net_in;\n    s = token(&r, SPACE TAB, NULL, NULL);\n\n    /* addrtype */\n    s = token(&r, SPACE TAB, NULL, NULL);\n    if (su_casematch(s, \"IP4\"))\n      c->c_addrtype = sdp_addr_ip4;\n    else if (su_casematch(s, \"IP6\"))\n      c->c_addrtype = sdp_addr_ip6;\n    else {\n      parsing_error(p, \"unknown IN address type: %s\", s);\n      return;\n    }\n\n    /* address */\n    s = next(&r, SPACE TAB, SPACE TAB);\n    c->c_address = s;\n    if (!s || !*s) {\n      parsing_error(p, \"invalid address\");\n      return;\n    }\n\n    /* ttl */\n    s = strchr(s, '/');\n    if (s) {\n      unsigned long value;\n      *s++ = 0;\n      if (parse_ul(p, &s, &value, 256) ||\n\t  (*s && *s != '/')) {\n\tparsing_error(p, \"invalid ttl\");\n\treturn;\n      }\n      c->c_ttl = value;\n      c->c_mcast = 1;\n\n      /* multiple groups */\n      value = 1;\n      if (*s++ == '/')\n\tif (parse_ul(p, &s, &value, 0) || *s) {\n\t  parsing_error(p, \"invalid number of multicast groups\");\n\t  return;\n\t}\n      c->c_groups = value;\n    }\n    else\n      c->c_groups = 1;\n  }\n  else if (p->pr_anynet) {\n    c->c_nettype = sdp_net_x;\n    c->c_addrtype = sdp_addr_x;\n    c->c_address = r;\n    c->c_ttl = 0;\n    c->c_groups = 1;\n  }\n  else\n    parsing_error(p, \"invalid address\");\n}\n\n/* -------------------------------------------------------------------------\n * Function parse_bandwidth() - parse an \"b=\" field\n *\n * Description:\n *   This function parses an SDP bandwidth field.\n *\n * Parameters:\n *   p      - pointer to SDP parser object\n *   r      - pointer to record data\n *   result - pointer to which parsed record is assigned\n */\nstatic void parse_bandwidth(sdp_parser_t *p, char *r, sdp_bandwidth_t **result)\n{\n  /*\n   bandwidth-fields =    *(\"b=\" bwtype \":\" bandwidth CRLF)\n   bwtype =              token\n   bandwidth =           1*(DIGIT)\n   */\n  /* NOTE: bwtype can also be like X-barf */\n  sdp_bandwidth_e modifier;\n  char *name;\n  unsigned long value;\n\n  name = token(&r, \":\", TOKEN, SPACE TAB);\n\n  if (name == NULL || parse_ul(p, &r, &value, 0)) {\n    parsing_error(p, \"invalid bandwidth\");\n    return;\n  }\n\n  if (su_casematch(name, \"CT\"))\n    modifier = sdp_bw_ct, name = \"CT\";\n  else if (su_casematch(name, \"TIAS\") == 1)\n    modifier = sdp_bw_tias, name = \"TIAS\";\n  else if (su_casematch(name, \"AS\") == 1)\n    modifier = sdp_bw_as, name = \"AS\";\n  else if (su_casematch(name, \"RS\") == 1)\n    modifier = sdp_bw_rs, name = \"RS\";\n  else if (su_casematch(name, \"RR\") == 1)\n    modifier = sdp_bw_rr, name = \"RR\";\n  else\n\tmodifier = sdp_bw_x, name = \"BW-X\";\n\n  if (STRICT(p))\n    PARSE_CHECK_REST(p, r, \"b\");\n\n  {\n    PARSE_ALLOC(p, sdp_bandwidth_t, b);\n    *result = b;\n    b->b_modifier = modifier;\n    b->b_modifier_name = name;\n    b->b_value = value;\n  }\n}\n\n/* -------------------------------------------------------------------------\n * Function parse_time() - parse an \"t=\" field\n *\n * Description:\n *   This function parses an SDP time field.\n *\n * Parameters:\n *   p      - pointer to SDP parser object\n *   r      - pointer to record data\n *   result - pointer to which parsed record is assigned\n */\nstatic void parse_time(sdp_parser_t *p, char *r, sdp_time_t **result)\n{\n  /*\n   time-fields =         1*( \"t=\" start-time SP stop-time\n                         *(CRLF repeat-fields) CRLF)\n                         [zone-adjustments CRLF]\n\n   start-time =          time / \"0\"\n\n   stop-time =           time / \"0\"\n\n   time =                POS-DIGIT 9*DIGIT\n                         ; Decimal representation of NTP time in\n                         ; seconds since 1900.  The representation\n                         ; of NTP time is an unbounded length field\n                         ; containing at least 10 digits.  Unlike the\n                         ; 64-bit representation used elsewhere, time\n                         ; in SDP does not wrap in the year 2036.\n   */\n  PARSE_ALLOC(p, sdp_time_t, t);\n  *result = t;\n  if (parse_ul(p, &r, &t->t_start, 0) ||\n      parse_ul(p, &r, &t->t_stop, 0))\n    parsing_error(p, \"invalid time\");\n  else if (STRICT(p)) {\n    PARSE_CHECK_REST(p, r, \"t\");\n  }\n}\n\n/**\n * Parse an \"r=\" field\n *\n * The function parse_repeat() parses an SDP repeat field.\n *\n * @param p      pointer to SDP parser object\n * @param r      pointer to record data\n * @param result pointer to which parsed record is assigned\n *\n */\nstatic void parse_repeat(sdp_parser_t *p, char *d, sdp_repeat_t **result)\n{\n  /*\n   repeat-fields =       %x72 \"=\" repeat-interval 2*(SP typed-time)\n\n   repeat-interval =     POS-DIGIT *DIGIT [fixed-len-time-unit]\n\n   typed-time =          1*DIGIT [fixed-len-time-unit]\n\n   fixed-len-time-unit = %x64 / %x68 / %x6d / %x73 ; \"d\" | \"h\" | \"m\" | \"s\"\n   */\n\n  unsigned long tt, *interval;\n  size_t i;\n  int n, N;\n  char *s;\n  sdp_repeat_t *r;\n  int strict = STRICT(p);\n\n  /** Count number of intervals */\n  for (N = 0, s = d; *s; ) {\n    if (!(is_posdigit(*s) || (!strict && (*s) == '0')))\n      break;\n    do { s++; } while (is_digit(*s));\n    if (*s && strchr(strict ? \"dhms\" : \"dhmsDHMS\", *s))\n      s++;\n    N++;\n    if (!(i = strict ? is_space(*s) : strspn(s, SPACE TAB)))\n      break;\n    s += i;\n  }\n\n  PARSE_CHECK_REST(p, s, \"r\");\n  if (N < 2) {\n    parsing_error(p, \"invalid repeat\");\n    return;\n  }\n  if (!(r = su_salloc(p->pr_home, offsetof(sdp_repeat_t, r_offsets[N - 1])))) {\n    parse_alloc_error(p, \"sdp_repeat_t\");\n    return;\n  }\n\n  r->r_number_of_offsets = N - 2;\n  r->r_offsets[N - 2] = 0;\n\n  for (n = 0, interval = &r->r_interval; n < N; n++) {\n    tt = strtoul(d, &d, 10);\n\n    switch (*d) {\n    case 'd': case 'D': tt *= 24;\n    case 'h': case 'H': tt *= 60;\n    case 'm': case 'M': tt *= 60;\n    case 's': case 'S': d++;\n      break;\n    }\n\n    interval[n] = tt;\n\n    while (is_space(*d))\n      d++;\n  }\n\n  *result = r;\n}\n\n/* -------------------------------------------------------------------------\n * Function parse_zone() - parse an \"z=\" field\n *\n * Description:\n *   This function parses an SDP time zone field.\n *\n * Parameters:\n *   p      - pointer to SDP parser object\n *   r      - pointer to record data\n *   result - pointer to which parsed record is assigned\n *\n */\nstatic void parse_zone(sdp_parser_t *p, char *r, sdp_zone_t **result)\n{\n  char *s;\n  size_t i;\n  int n, N;\n  sdp_zone_t *z;\n\n  /*\n   zone-adjustments =    time space [\"-\"] typed-time\n                         *(space time space [\"-\"] typed-time)\n   */\n\n  /** Count number of timezones, check syntax */\n  for (N = 0, s = r; *s;) {\n    if (!(is_posdigit(*s) || (!STRICT(p) && (*s) == '0')))\n      break;\n    do { s++; } while (is_digit(*s));\n    if (!(i = STRICT(p) ? is_space(*s) : strspn(s, SPACE TAB)))\n      break;\n    s += i;\n    if (!(*s == '-' || is_posdigit(*s) || (!STRICT(p) && (*s) == '0')))\n      break;\n    do { s++; } while (is_digit(*s));\n    if (*s && strchr(\"dhms\", *s))\n      s++;\n    N++;\n    if (!(i = STRICT(p) ? is_space(*s) : strspn(s, SPACE TAB)))\n      break;\n    s += i;\n  }\n\n  PARSE_CHECK_REST(p, s, \"z\");\n\n  if (N < 1) {\n    parsing_error(p, \"invalid timezone\");\n    return;\n  }\n  if (!(z = su_salloc(p->pr_home, offsetof(sdp_zone_t, z_adjustments[N])))) {\n    parse_alloc_error(p, \"sdp_zone_t\");\n    return;\n  }\n\n  z->z_number_of_adjustments = N;\n\n  for (n = 0; n < N; n++) {\n    unsigned long at = strtoul(r, &r, 10);\n    long offset = strtol(r, &r, 10);\n    switch (*r) {\n    case 'd': offset *= 24;\n    case 'h': offset *= 60;\n    case 'm': offset *= 60;\n    case 's': r++;\n      break;\n    }\n\n    z->z_adjustments[n].z_at = at;\n    z->z_adjustments[n].z_offset = offset;\n  }\n\n  *result = z;\n}\n\n/* -------------------------------------------------------------------------\n * Function parse_key() - parse an \"k=\" field\n *\n * Description:\n *   This function parses an SDP key field.\n *\n * Parameters:\n *   p      - pointer to SDP parser object\n *   r      - pointer to record data\n *   result - pointer to which parsed record is assigned\n *\n */\nstatic void parse_key(sdp_parser_t *p, char *r, sdp_key_t **result)\n{\n  char *s;\n  /*\n   key-field =           [\"k=\" key-type CRLF]\n\n   key-type =            \"prompt\" |\n                         \"clear:\" key-data |\n                         \"base64:\" key-data |\n                         \"uri:\" uri\n\n   key-data =            email-safe | \"~\" | \"\n   */\n\n  s = token(&r, \":\", TOKEN, SPACE TAB);\n  if (!s) {\n    parsing_error(p, \"invalid key method\");\n    return;\n  }\n\n  {\n    PARSE_ALLOC(p, sdp_key_t, k);\n    if (result) *result = k;\n\n    /* These are defined as key-sensitive in RFC 4566 */\n#define MATCH(s, tok) \\\n    (STRICT(p) ? su_strmatch((s), (tok)) : su_casematch((s), (tok)))\n\n    if (MATCH(s, \"clear\"))\n      k->k_method = sdp_key_clear, k->k_method_name = \"clear\";\n    else if (MATCH(s, \"base64\"))\n      k->k_method = sdp_key_base64, k->k_method_name = \"base64\";\n    else if (MATCH(s, \"uri\"))\n      k->k_method = sdp_key_uri, k->k_method_name = \"uri\";\n    else if (MATCH(s, \"prompt\"))\n      k->k_method = sdp_key_prompt, k->k_method_name = \"prompt\";\n    else if (!STRICT(p))\n      k->k_method = sdp_key_x, k->k_method_name = s;\n    else {\n      parsing_error(p, \"invalid key method\");\n      return;\n    }\n\n    k->k_material = r;\n  }\n}\n\n/* -------------------------------------------------------------------------\n * Function parse_session_attr() - parse a session \"a=\" field\n *\n * Description:\n *   This function parses an SDP attribute field regarding whole session.\n *\n * Parameters:\n *   p      - pointer to SDP parser object\n *   r      - pointer to record data\n *   result - pointer to which parsed record is assigned\n */\nstatic void parse_session_attr(sdp_parser_t *p, char *r, sdp_attribute_t **result)\n{\n  /*\n   attribute-fields =    *(\"a=\" attribute CRLF)\n\n   attribute =           (att-field \":\" att-value) / att-field\n\n   att-field =           token\n\n   att-value =           byte-string\n   */\n\n  char *name = NULL, *value = NULL;\n\n  if (!(name = token(&r, \":\", TOKEN, SPACE TAB))) {\n    parsing_error(p,\"invalid attribute name\");\n    return;\n  }\n\n  if (*r)\n    value = r;\n  else\n    PARSE_CHECK_REST(p, r, \"a\");\n\n  if (su_casematch(name, \"charset\")) {\n    p->pr_session->sdp_charset = value;\n    return;\n  }\n\n  if (p->pr_mode_manual)\n    ;\n  else if (su_casematch(name, \"inactive\"))\n    p->pr_session_mode = sdp_inactive;\n  else if (su_casematch(name, \"sendonly\"))\n    p->pr_session_mode = sdp_sendonly;\n  else if (su_casematch(name, \"recvonly\"))\n    p->pr_session_mode = sdp_recvonly;\n  else if (su_casematch(name, \"sendrecv\"))\n    p->pr_session_mode = sdp_sendrecv;\n\n  {\n    PARSE_ALLOC(p, sdp_attribute_t, a);\n    *result = a;\n\n    a->a_name  = name;\n    a->a_value = value;\n  }\n}\n\n/* -------------------------------------------------------------------------\n * Function parse_media() - parse an \"m=\" field\n *\n * Description:\n *   This function parses an SDP media field.\n *\n * Parameters:\n *   p      - pointer to SDP parser object\n *   r      - pointer to record data\n *   result - pointer to which parsed record is assigned\n */\nstatic void parse_media(sdp_parser_t *p, char *r, sdp_media_t **result)\n{\n  /*\n   media-descriptions =  *( media-field\n                         information-field\n                         *(connection-field)\n                         bandwidth-fields\n                         key-field\n                         attribute-fields )\n\n   media-field =         \"m=\" media space port [\"/\" integer]\n                         space proto 1*(space fmt) CRLF\n\n   media =               token\n                         ;typically \"audio\", \"video\", \"application\"\n                         ;or \"data\" or \"text\"\n\n   fmt =                 token\n                         ;typically an RTP payload type for audio\n                         ;and video media\n\n   proto =               token *(\"/\" token)\n                         ;typically \"RTP/AVP\" or \"udp\" for IP4\n\n   port =                1*(DIGIT)\n                         ;should in the range \"1024\" to \"65535\" inclusive\n   */\n  char *s;\n  unsigned long value;\n  PARSE_ALLOC(p, sdp_media_t, m);\n\n  *result = m;\n\n  m->m_mode = sdp_sendrecv;\n\n  s = token(&r, SPACE, TOKEN, NULL);\n  if (!s) {\n    parsing_error(p, \"m= invalid media field\");\n    return;\n  }\n\n  sdp_media_type(m, s);\n\n  /* Accept m=* in configuration file */\n  if (p->pr_config && m->m_type == sdp_media_any) {\n    r += strspn(r, SPACE TAB);\n    if (r[0] == '\\0') {\n      m->m_proto = sdp_proto_any, m->m_proto_name = \"*\";\n      return;\n    }\n  }\n\n  if (parse_ul(p, &r, &value, 0)) {\n    parsing_error(p, \"m= invalid port number\");\n    return;\n  }\n  m->m_port = value;\n\n  if (*r == '/') {\n    r++;\n    if (parse_ul(p, &r, &value, 0)) {\n      parsing_error(p, \"m= invalid port specification\");\n      return;\n    }\n    m->m_number_of_ports = value;\n  }\n\n  s = token(&r, SPACE, \"/\" TOKEN, SPACE);\n  if (s == NULL) {\n    parsing_error(p, \"m= missing protocol\");\n    return;\n  }\n\n  if (!STRICT(p) && su_casematch(s, \"RTP\"))\n    m->m_proto = sdp_proto_rtp, m->m_proto_name = \"RTP/AVP\";\n  else\n    sdp_media_transport(m, s);\n\n  /* RTP format list */\n  if (*r && sdp_media_has_rtp(m)) {\n\t  parse_payload(p, r, &m->m_rtpmaps);\n\t  return;\n  }\n\n  /* \"normal\" format list */\n  if (*r) {\n    sdp_list_t **fmt = &m->m_format;\n\n    while (r && *r) {\n      PARSE_ALLOC(p, sdp_list_t, l);\n      *fmt = l;\n      l->l_text = token(&r, SPACE TAB, TOKEN, SPACE TAB);\n      if (!l->l_text) {\n         parsing_error(p, \"m= invalid\");\n         return;\n      }\n      fmt = &l->l_next;\n    }\n  }\n}\n\n/** Set media type */\nvoid sdp_media_type(sdp_media_t *m, char const *s)\n{\n  if (su_strmatch(s, \"*\"))\n    m->m_type = sdp_media_any, m->m_type_name = \"*\";\n  else if (su_casematch(s, \"audio\"))\n    m->m_type = sdp_media_audio, m->m_type_name = \"audio\";\n  else if (su_casematch(s, \"video\"))\n    m->m_type = sdp_media_video, m->m_type_name = \"video\";\n  else if (su_casematch(s, \"application\"))\n    m->m_type = sdp_media_application, m->m_type_name = \"application\";\n  else if (su_casematch(s, \"data\"))\n    m->m_type = sdp_media_data, m->m_type_name = \"data\";\n  else if (su_casematch(s, \"control\"))\n    m->m_type = sdp_media_control, m->m_type_name = \"control\";\n  else if (su_casematch(s, \"message\"))\n    m->m_type = sdp_media_message, m->m_type_name = \"message\";\n  else if (su_casematch(s, \"image\"))\n    m->m_type = sdp_media_image, m->m_type_name = \"image\";\n  else if (su_casematch(s, \"red\"))\n    m->m_type = sdp_media_red, m->m_type_name = \"red\";\n  else if (su_casematch(s, \"text\"))\n    m->m_type = sdp_media_text, m->m_type_name = \"text\";\n  else\n    m->m_type = sdp_media_x, m->m_type_name = s;\n}\n\n/** Set transport protocol.\n *\n * Set the @m->m_proto to a well-known protocol type as\n * well as canonize case of @a m_proto_name.\n */\nvoid sdp_media_transport(sdp_media_t *m, char const *s)\n{\n  if (m == NULL || s == NULL)\n    ;\n  else if (su_strmatch(s, \"*\"))\n    m->m_proto = sdp_proto_any, m->m_proto_name = \"*\";\n  else if (su_casematch(s, \"RTP/AVP\"))\n    m->m_proto = sdp_proto_rtp, m->m_proto_name = \"RTP/AVP\";\n  else if (su_casematch(s, \"RTP/SAVP\"))\n    m->m_proto = sdp_proto_srtp, m->m_proto_name = \"RTP/SAVP\";\n  else if (su_casematch(s, \"UDP/TLS/RTP/SAVP\"))\n    m->m_proto = sdp_proto_srtp, m->m_proto_name = \"RTP/SAVP\";\n  else if (su_casematch(s, \"RTP/SAVPF\"))\n\t  m->m_proto = sdp_proto_extended_srtp, m->m_proto_name = \"RTP/SAVPF\";\n  else if (su_casematch(s, \"UDP/TLS/RTP/SAVPF\"))\n    m->m_proto = sdp_proto_extended_srtp, m->m_proto_name = \"UDP/TLS/RTP/SAVPF\";\n  else if (su_casematch(s, \"RTP/AVPF\"))\n\t  m->m_proto = sdp_proto_extended_rtp, m->m_proto_name = \"RTP/AVPF\";\n  else if (su_casematch(s, \"UDP/RTP/AVPF\"))\n    m->m_proto = sdp_proto_extended_rtp, m->m_proto_name = \"UDP/RTP/AVPF\";\n  else if (su_casematch(s, \"udptl\"))\n    /* Lower case - be compatible with people living by T.38 examples */\n    m->m_proto = sdp_proto_udptl, m->m_proto_name = \"udptl\";\n  else if (su_casematch(s, \"TCP/MSRP\"))\n    m->m_proto = sdp_proto_msrp, m->m_proto_name = \"TCP/MSRP\";\n  else if (su_casematch(s, \"TCP/TLS/MSRP\"))\n    m->m_proto = sdp_proto_msrps, m->m_proto_name = \"TCP/TLS/MSRP\";\n  else if (su_casematch(s, \"UDP\"))\n    m->m_proto = sdp_proto_udp, m->m_proto_name = \"UDP\";\n  else if (su_casematch(s, \"TCP\"))\n    m->m_proto = sdp_proto_tcp, m->m_proto_name = \"TCP\";\n  else if (su_casematch(s, \"TLS\"))\n    m->m_proto = sdp_proto_tls, m->m_proto_name = \"TLS\";\n  else\n    m->m_proto = sdp_proto_x, m->m_proto_name = s;\n}\n\n/** Check if media uses RTP as its transport protocol.  */\nint sdp_media_has_rtp(sdp_media_t const *m)\n{\n\treturn m && (m->m_proto == sdp_proto_rtp || m->m_proto == sdp_proto_srtp || m->m_proto == sdp_proto_extended_srtp || m->m_proto == sdp_proto_extended_rtp);\n}\n\n#define RTPMAP(pt, encoding, rate, params) \\\n  { sizeof(sdp_rtpmap_t), NULL, encoding, rate, (char *)params, NULL, 1, pt, 0 }\n\n/* rtpmaps for well-known codecs */\nstatic sdp_rtpmap_t const\n  sdp_rtpmap_pcmu = RTPMAP(0, \"PCMU\", 8000, 0),\n  sdp_rtpmap_1016 = RTPMAP(1, \"1016\", 8000, 0),\n  sdp_rtpmap_g721 = RTPMAP(2, \"G721\", 8000, 0),\n  sdp_rtpmap_gsm =  RTPMAP(3, \"GSM\",  8000, 0),\n  sdp_rtpmap_g723 = RTPMAP(4, \"G723\", 8000, 0),\n  sdp_rtpmap_dvi4_8000 = RTPMAP(5, \"DVI4\", 8000, 0),\n  sdp_rtpmap_dvi4_16000 = RTPMAP(6, \"DVI4\", 16000, 0),\n  sdp_rtpmap_lpc = RTPMAP(7, \"LPC\",  8000, 0),\n  sdp_rtpmap_pcma = RTPMAP(8, \"PCMA\", 8000, 0),\n  sdp_rtpmap_g722 = RTPMAP(9, \"G722\", 8000, 0),\n  sdp_rtpmap_l16_2 = RTPMAP(10, \"L16\", 44100, \"2\"),\n  sdp_rtpmap_l16 = RTPMAP(11, \"L16\", 44100, 0),\n  sdp_rtpmap_qcelp = RTPMAP(12, \"QCELP\", 8000, 0),\n  sdp_rtpmap_cn = RTPMAP(13, \"CN\", 8000, 0),\n  sdp_rtpmap_mpa = RTPMAP(14, \"MPA\", 90000, 0),\n  sdp_rtpmap_g728 = RTPMAP(15, \"G728\", 8000, 0),\n  sdp_rtpmap_dvi4_11025 = RTPMAP(16, \"DVI4\", 11025, 0),\n  sdp_rtpmap_dvi4_22050 = RTPMAP(17, \"DVI4\", 22050, 0),\n  sdp_rtpmap_g729 = RTPMAP(18, \"G729\", 8000, 0),\n  sdp_rtpmap_reserved_cn = RTPMAP(19, \"CN\", 8000, 0),\n  /* video codecs */\n  sdp_rtpmap_celb = RTPMAP(25, \"CelB\", 90000, 0),\n  sdp_rtpmap_jpeg = RTPMAP(26, \"JPEG\", 90000, 0),\n  sdp_rtpmap_nv = RTPMAP(28, \"nv\",   90000, 0),\n  sdp_rtpmap_h261 = RTPMAP(31, \"H261\", 90000, 0),\n  sdp_rtpmap_mpv = RTPMAP(32, \"MPV\",  90000, 0),\n  sdp_rtpmap_mp2t = RTPMAP(33, \"MP2T\", 90000, 0),\n  sdp_rtpmap_h263 = RTPMAP(34, \"H263\", 90000, 0);\n\n/** Table of rtpmap structures by payload type numbers.\n *\n * The table of reserved payload numbers is constructed from @RFC3551\n * and @RFC1890. Note the clock rate of G722.\n *\n * Use sdp_rtpmap_dup() to copy these structures.\n */\nsdp_rtpmap_t const * const sdp_rtpmap_well_known[128] =\n{\n  &sdp_rtpmap_pcmu,\t\t/* 0 */\n  &sdp_rtpmap_1016,\t\t/* 1 */\n  &sdp_rtpmap_g721,\t\t/* 2 */\n  &sdp_rtpmap_gsm,\t\t/* 3 */\n  &sdp_rtpmap_g723,\t\t/* 4 */\n  &sdp_rtpmap_dvi4_8000,\t/* 5 */\n  &sdp_rtpmap_dvi4_16000,\t/* 6 */\n  &sdp_rtpmap_lpc,\t\t/* 7 */\n  &sdp_rtpmap_pcma,\t\t/* 8 */\n  &sdp_rtpmap_g722,\t\t/* 9 */\n  &sdp_rtpmap_l16_2,\t\t/* 10 */\n  &sdp_rtpmap_l16,\t\t/* 11 */\n  &sdp_rtpmap_qcelp,\t\t/* 12 */\n  &sdp_rtpmap_cn,\t\t/* 13 */\n  &sdp_rtpmap_mpa,\t\t/* 14 */\n  &sdp_rtpmap_g728,\t\t/* 15 */\n  &sdp_rtpmap_dvi4_11025,\t/* 16 */\n  &sdp_rtpmap_dvi4_22050,\t/* 17 */\n  &sdp_rtpmap_g729,\t\t/* 18 */\n  &sdp_rtpmap_reserved_cn,\t/* 19 */\n  NULL,\t\t\t\t/* 20 */\n  NULL,\t\t\t\t/* 21 */\n  NULL,\t\t\t\t/* 22 */\n  NULL,\t\t\t\t/* 23 */\n  NULL,\t\t\t\t/* 24 */\n  &sdp_rtpmap_celb,\t\t/* 25 */\n  &sdp_rtpmap_jpeg,\t\t/* 26 */\n  NULL,\t\t\t\t/* 27 */\n  &sdp_rtpmap_nv,\t\t/* 28 */\n  NULL,\t\t\t\t/* 29 */\n  NULL,\t\t\t\t/* 30 */\n  &sdp_rtpmap_h261,\t\t/* 31 */\n  &sdp_rtpmap_mpv,\t\t/* 32 */\n  &sdp_rtpmap_mp2t,\t\t/* 33 */\n  &sdp_rtpmap_h263,\t\t/* 34 */\n  NULL,\n};\n\n/**\n * The function parse_payload() parses an RTP payload type list, and\n * creates an rtpmap structure for each payload type.\n *\n * @param p       pointer to SDP parser object\n * @param r       pointer to record data\n * @param result  pointer to which parsed record is assigned\n */\nstatic void parse_payload(sdp_parser_t *p, char *r, sdp_rtpmap_t **result)\n{\n  while (*r) {\n    unsigned long value;\n\n    if (parse_ul(p, &r, &value, 128) == 0) {\n      PARSE_ALLOC(p, sdp_rtpmap_t, rm);\n\n      assert(0 <= value && value < 128);\n\n      *result = rm; result = &rm->rm_next;\n\n      if (sdp_rtpmap_well_known[value]) {\n\t*rm = *sdp_rtpmap_well_known[value];\n      }\n      else {\n\trm->rm_predef = 1;\n\trm->rm_pt = value;\n\trm->rm_encoding = \"\";\n\trm->rm_rate = 0;\n      }\n    }\n    else if (p->pr_config && r[0] == '*' && (r[1] == ' ' || r[1] == '\\0')) {\n      PARSE_ALLOC(p, sdp_rtpmap_t, rm);\n\n      *result = rm;\n\n      rm->rm_predef = 1;\n      rm->rm_any = 1;\n      rm->rm_encoding = \"*\";\n      rm->rm_rate = 0;\n\n      return;\n    }\n    else {\n      parsing_error(p, \"m= invalid format for RTP/AVT\");\n\n      return;\n    }\n  }\n}\n\n/* -------------------------------------------------------------------------\n * Function parse_media_attr() - parse a media-specific \"a=\" field\n *\n * Description:\n *   This function parses a media-specific attribute field.\n *\n * Parameters:\n *   p      - pointer to SDP parser object\n *   r      - pointer to record data\n *   result - pointer to which parsed record is assigned\n */\nstatic void parse_media_attr(sdp_parser_t *p, char *r, sdp_media_t *m,\n\t\t\t     sdp_attribute_t **result)\n{\n  /*\n   attribute-fields =    *(\"a=\" attribute CRLF)\n\n   attribute =           (att-field \":\" att-value) / att-field\n\n   att-field =           token\n\n   att-value =           byte-string\n\n   a=rtpmap:<payload type> <encoding name>/<clock rate>[/<encoding parameters>]\n   a=fmtp:<payload type> <parameters>\n   */\n  int rtp = sdp_media_has_rtp(m);\n  char *name = NULL, *value = NULL;\n  int n;\n\n  if (!(name = token(&r, \":\", TOKEN, SPACE TAB))) {\n    parsing_error(p,\"invalid attribute name\");\n    return;\n  }\n\n  if (*r)\n    value = r;\n  else\n    PARSE_CHECK_REST(p, r, \"a\");\n\n  if (p->pr_mode_manual)\n    ;\n  else if (m->m_port == 0 || su_casematch(name, \"inactive\")) {\n    m->m_mode = sdp_inactive;\n    return;\n  }\n  else if (su_casematch(name, \"sendonly\")) {\n    m->m_mode = sdp_sendonly;\n    return;\n  }\n  else if (su_casematch(name, \"recvonly\")) {\n    m->m_mode = sdp_recvonly;\n    return;\n  }\n  else if (su_casematch(name, \"sendrecv\")) {\n    m->m_mode = sdp_sendrecv;\n    return;\n  }\n\n  if (rtp && su_casematch(name, \"rtpmap\")) {\n\t  if ((n = parse_rtpmap(p, r, m)) == 0 || n < -1)\n\t\t  return;\n  }\n  else if (rtp && su_casematch(name, \"fmtp\")) {\n    if ((n = parse_fmtp(p, r, m)) == 0 || n < -1)\n      return;\n  }\n  else {\n    PARSE_ALLOC(p, sdp_attribute_t, a);\n    *result = a;\n\n    a->a_name  = name;\n    a->a_value = value;\n  }\n}\n\n/** Parse rtpmap attribute.\n *\n * a=rtpmap:<payload type> <encoding name>/<clock rate>[/<encoding parameters>]\n */\nstatic int parse_rtpmap(sdp_parser_t *p, char *r, sdp_media_t *m)\n{\n  unsigned long pt, rate;\n  char *encoding, *params;\n  sdp_rtpmap_t *rm;\n\n  int strict = STRICT(p);\n\n  if (parse_ul(p, &r, &pt, 128)) {\n    if (strict)\n      parsing_error(p, \"a=rtpmap: invalid payload type\");\n    return -1;\n  }\n\n  for (rm = m->m_rtpmaps; rm; rm = rm->rm_next)\n    if (rm->rm_pt == pt)\n      break;\n\n  if (!rm) {\n    if (strict)\n      parsing_error(p, \"a=rtpmap:%lu: unknown payload type\", pt);\n    return -1;\n  }\n\n  encoding = token(&r, \"/\", TOKEN, NULL);\n  if (!r) {\n    parsing_error(p, \"a=rtpmap:%lu: missing <clock rate>\", pt);\n    return -2;\n  }\n  if (parse_ul(p, &r, &rate, 0)) {\n    parsing_error(p, \"a=rtpmap:%lu %s: invalid <clock rate>\", pt, encoding);\n    return -2;\n  }\n\n  if (*r == '/')\n    params = ++r;\n  else\n    params = 0;\n\n  rm->rm_predef = 0;\n  rm->rm_encoding = encoding;\n  rm->rm_rate = rate;\n  rm->rm_params = params;\n\n  return 0;\n}\n\n/** Parse fmtp attribute.\n *\n * a=fmtp:<payload type> <parameters>\n */\nstatic int parse_fmtp(sdp_parser_t *p, char *r, sdp_media_t *m)\n{\n  unsigned long pt;\n  sdp_rtpmap_t *rm;\n\n  int strict = STRICT(p);\n\n  if (parse_ul(p, &r, &pt, 128)) {\n    if (strict)\n      parsing_error(p, \"a=rtpmap: invalid payload type\");\n    return -1;\n  }\n\n  for (rm = m->m_rtpmaps; rm; rm = rm->rm_next)\n    if (rm->rm_pt == pt)\n      break;\n\n  if (!rm) {\n    if (strict)\n      parsing_error(p, \"a=fmtp:%lu: unknown payload type\", pt);\n    return -1;\n  }\n\n  rm->rm_fmtp = r;\n  return 0;\n}\n\n/* -------------------------------------------------------------------------\n * Function parse_descs() - parse media descriptors\n *\n * Description:\n *   This function parses media descriptors at the end of SDP message.\n *\n * Parameters:\n *   p      - pointer to SDP parser object\n *   record - pointer to first media field\n *   message - pointer to rest\n *   medias - pointer to which parsed media structures are assigned\n */\nstatic void parse_descs(sdp_parser_t *p,\n\t\t\tchar *record,\n\t\t\tchar *message,\n\t\t\tsdp_media_t **medias)\n{\n  char *rest;\n  const char *strip;\n  sdp_media_t *m = NULL;\n  sdp_connection_t **connections = NULL;\n  sdp_bandwidth_t **bandwidths = NULL;\n  sdp_attribute_t **attributes = NULL;\n\n  if (!STRICT(p))\n    strip = SPACE TAB;\t\t/* skip initial whitespace */\n  else\n    strip = \"\";\n\n  for (;\n       record && p->pr_ok;\n       record = next(&message, CRLF, strip)) {\n    char field = record[0];\n\n    if (strlen(record) < 2) {\n      return;\n    }\n\n    rest = record + 2; rest += strspn(rest, strip);\n\n    if (record[1] == '=') switch (field) {\n    case 'c':\n      assert(connections);\n      parse_connection(p, rest, connections);\n      connections = &(*connections)->c_next;\n      break;\n\n    case 'b':\n      assert(bandwidths);\n      parse_bandwidth(p, rest, bandwidths);\n      bandwidths = &(*bandwidths)->b_next;\n      break;\n\n    case 'i': \n      parse_information(p, rest, &m->m_information);\n      break;\n     \n    case 'k':\n      parse_key(p, rest, &m->m_key);\n      break;\n\n    case 'a':\n      assert(attributes);\n      parse_media_attr(p, rest, m, attributes);\n      if (*attributes)\n\tattributes = &(*attributes)->a_next;\n      break;\n\n    case 'm':\n      parse_media(p, rest, medias);\n      m = *medias;\n      if (m) {\n\tm->m_mode = p->pr_session_mode;\n\tmedias = &m->m_next;\n\tconnections = &m->m_connections;\n\tbandwidths = &m->m_bandwidths;\n\tattributes = &m->m_attributes;\n      }\n    }\n  }\n}\n\nstatic void parse_text_list(sdp_parser_t *p, char *r, sdp_list_t **result)\n{\n  PARSE_ALLOC(p, sdp_list_t, l);\n\n  *result = l;\n\n  l->l_text = r;\n}\n\n/*\n * parse_ul: parse an unsigned long\n */\nstatic int parse_ul(sdp_parser_t *p, char **r,\n\t\t    unsigned long *result, unsigned long max)\n{\n  char *ul = *r;\n\n  ul += strspn(ul, SPACE TAB);\n\n  *result = strtoul(ul, r, 10);\n  if (ul != *r && !(max && max <= *result)) {\n    *r += strspn(*r, SPACE TAB);\n    return 0;\n  }\n\n  return -1;\n}\n\n#if !HAVE_STRTOULL\n#if !((defined(WIN32) || defined(_WIN32)) && (_MSC_VER >= 1800))\nunsigned long long strtoull(char const *string, char **return_end, int base);\n#endif\n#endif\n\n/*\n * parse_ull: parse an unsigned long long\n */\nstatic int parse_ull(sdp_parser_t *p, char **r,\n\t\t     uint64_t *result, uint64_t max)\n{\n  unsigned long long ull;\n\n  char *s = *r;\n\n  s += strspn(s, SPACE TAB);\n\n  ull = strtoull(s, r, 10);\n\n  if (s != *r && !(max && max <= ull)) {\n    *result = (uint64_t)ull;\n    *r += strspn(*r, SPACE TAB);\n    return 0;\n  }\n\n  return -1;\n}\n\nstatic char *token(char **message,\n\t\t   const char *sep,\n\t\t   const char *legal,\n\t\t   const char *strip)\n{\n  size_t n;\n  char *retval = *message;\n\n  if (strip)\n    retval += strspn(retval, strip);\n\n  if (legal)\n    n = strspn(retval, legal);\n  else\n    n = strcspn(retval, sep);\n\n  if (n == 0)\n    return NULL;\n\n  if (retval[n]) {\n    retval[n++] = '\\0';\n    n += strspn(retval + n, sep);\n  }\n\n  *message = retval + n;\n\n  if (*retval == '\\0')\n    return NULL;\n\n  return retval;\n}\n\nstatic char *next(char **message, const char *sep, const char *strip)\n{\n  size_t n;\n  char *retval = *message;\n\n  if (strip[0])\n    retval += strspn(retval, strip);\n\n  n = strcspn(retval, sep);\n\n  if (n == 0)\n    return NULL;\n\n  if (retval[n]) {\n    retval[n++] = '\\0';\n    n += strspn(retval + n, sep);\n  }\n\n  *message = retval + n;\n\n  if (*retval == '\\0')\n    return NULL;\n\n  return retval;\n}\n\nstatic int parsing_error(sdp_parser_t *p, char const *fmt, ...)\n{\n  va_list ap;\n  va_start(ap, fmt);\n\n  memset(p->pr_error, 0, sizeof(p->pr_error));\n  vsnprintf(p->pr_error, sizeof(p->pr_error), fmt, ap);\n  va_end(ap);\n\n  p->pr_ok = 0;\n\n  return -1;\n}\n\nstatic void parse_alloc_error(sdp_parser_t *p, const char *typename)\n{\n  parsing_error(p, \"memory exhausted (while allocating memory for %s)\",\n\t\ttypename);\n}\n"], "filenames": ["libsofia-sip-ua/sdp/sdp_parse.c"], "buggy_code_start_loc": [397], "buggy_code_end_loc": [1765], "fixing_code_start_loc": [398], "fixing_code_end_loc": [1774], "type": "CWE-122", "message": "Sofia-SIP is an open-source Session Initiation Protocol (SIP) User-Agent library. Prior to version 1.13.8, when parsing each line of a sdp message, `rest = record + 2` will access the memory behind `\\0` and cause an out-of-bounds write. An attacker can send a message with evil sdp to FreeSWITCH, causing a crash or more serious consequence, such as remote code execution. Version 1.13.8 contains a patch for this issue.", "other": {"cve": {"id": "CVE-2022-31003", "sourceIdentifier": "security-advisories@github.com", "published": "2022-05-31T20:15:07.910", "lastModified": "2023-05-24T21:15:10.760", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Sofia-SIP is an open-source Session Initiation Protocol (SIP) User-Agent library. Prior to version 1.13.8, when parsing each line of a sdp message, `rest = record + 2` will access the memory behind `\\0` and cause an out-of-bounds write. An attacker can send a message with evil sdp to FreeSWITCH, causing a crash or more serious consequence, such as remote code execution. Version 1.13.8 contains a patch for this issue."}, {"lang": "es", "value": "Sofia-SIP es una biblioteca de agente de usuario del Protocolo de Iniciaci\u00f3n de Sesi\u00f3n (SIP) de c\u00f3digo abierto. En versiones anteriores a 1.13.8, cuando es analizada cada l\u00ednea de un mensaje sdp, \"rest = record + 2\" acced\u00eda a la memoria detr\u00e1s de \"\\0\" y causaba una escritura fuera de l\u00edmites. Un atacante puede enviar un mensaje con sdp maligno a FreeSWITCH, causando un bloqueo o una consecuencia m\u00e1s grave, como una ejecuci\u00f3n remota de c\u00f3digo. La versi\u00f3n 1.13.8 contiene un parche para este problema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-122"}, {"lang": "en", "value": "CWE-787"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:signalwire:sofia-sip:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.13.8", "matchCriteriaId": "C8062138-09E2-4610-9FFB-037EDC6FA766"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "https://github.com/freeswitch/sofia-sip/commit/907f2ac0ee504c93ebfefd676b4632a3575908c9", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/freeswitch/sofia-sip/security/advisories/GHSA-8w5j-6g2j-pxcp", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/09/msg00001.html", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202210-18", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2023/dsa-5410", "source": "security-advisories@github.com"}]}, "github_commit_url": "https://github.com/freeswitch/sofia-sip/commit/907f2ac0ee504c93ebfefd676b4632a3575908c9"}}