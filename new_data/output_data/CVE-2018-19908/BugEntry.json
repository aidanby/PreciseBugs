{"buggy_code": ["<?php\nApp::uses('AppModel', 'Model');\nApp::uses('CakeEmail', 'Network/Email');\nApp::uses('RandomTool', 'Tools');\nConfigure::load('config'); // This is needed to load GnuPG.bodyonlyencrypted\n\nclass Event extends AppModel\n{\n    public $actsAs = array(\n        'SysLogLogable.SysLogLogable' => array(\n            'userModel' => 'User',\n            'userKey' => 'user_id',\n            'change' => 'full'),\n        'Trim',\n        'Containable',\n    );\n\n    public $displayField = 'id';\n\n    public $virtualFields = array();\n\n    public $mispVersion = '2.4.0';\n\n    public $fieldDescriptions = array(\n        'threat_level_id' => array('desc' => 'Risk levels: *low* means mass-malware, *medium* means APT malware, *high* means sophisticated APT malware or 0-day attack', 'formdesc' => 'Risk levels: low: mass-malware medium: APT malware high: sophisticated APT malware or 0-day attack'),\n        'classification' => array('desc' => 'Set the Traffic Light Protocol classification. <ol><li><em>TLP:AMBER</em>- Share only within the organization on a need-to-know basis</li><li><em>TLP:GREEN:NeedToKnow</em>- Share within your constituency on the need-to-know basis.</li><li><em>TLP:GREEN</em>- Share within your constituency.</li></ol>'),\n        'submittedioc' => array('desc' => '', 'formdesc' => ''),\n        'analysis' => array('desc' => 'Analysis Levels: *Initial* means the event has just been created, *Ongoing* means that the event is being populated, *Complete* means that the event\\'s creation is complete', 'formdesc' => 'Analysis levels: Initial: event has been started Ongoing: event population is in progress Complete: event creation has finished'),\n        'distribution' => array('desc' => 'Describes who will have access to the event.')\n    );\n\n    public $analysisDescriptions = array(\n        0 => array('desc' => '*Initial* means the event has just been created', 'formdesc' => 'Event has just been created and is in an initial state'),\n        1 => array('desc' => '*Ongoing* means that the event is being populated', 'formdesc' => 'The analysis is still ongoing'),\n        2 => array('desc' => '*Complete* means that the event\\'s creation is complete', 'formdesc' => 'The event creator considers the analysis complete')\n    );\n\n    public $distributionDescriptions = array(\n        0 => array('desc' => 'This field determines the current distribution of the event', 'formdesc' => \"This setting will only allow members of your organisation on this server to see it.\"),\n        1 => array('desc' => 'This field determines the current distribution of the event', 'formdesc' => \"Organisations that are part of this MISP community will be able to see the event.\"),\n        2 => array('desc' => 'This field determines the current distribution of the event', 'formdesc' => \"Organisations that are either part of this MISP community or part of a directly connected MISP community will be able to see the event.\"),\n        3 => array('desc' => 'This field determines the current distribution of the event', 'formdesc' => \"This will share the event with all MISP communities, allowing the event to be freely propagated from one server to the next.\"),\n        4 => array('desc' => 'This field determines the current distribution of the event', 'formdesc' => \"This distribution of this event will be handled by the selected sharing group.\"),\n\n    );\n\n    public $analysisLevels = array(\n        0 => 'Initial', 1 => 'Ongoing', 2 => 'Completed'\n    );\n\n    public $distributionLevels = array(\n        0 => 'Your organisation only', 1 => 'This community only', 2 => 'Connected communities', 3 => 'All communities', 4 => 'Sharing group'\n    );\n\n    private $__fTool = false;\n\n    public $shortDist = array(0 => 'Organisation', 1 => 'Community', 2 => 'Connected', 3 => 'All', 4 => ' sharing Group');\n\n    private $__assetCache = array();\n\n    public $export_types = array(\n            'json' => array(\n                    'extension' => '.json',\n                    'type' => 'JSON',\n                    'scope' => 'Event',\n                    'requiresPublished' => 0,\n                    'params' => array('includeAttachments' => 1, 'ignore' => 1, 'returnFormat' => 'json'),\n                    'description' => 'Click this to download all events and attributes that you have access to in MISP JSON format.',\n            ),\n            'xml' => array(\n                    'extension' => '.xml',\n                    'type' => 'XML',\n                    'scope' => 'Event',\n                    'params' => array('includeAttachments' => 1, 'ignore' => 1, 'returnFormat' => 'xml'),\n                    'requiresPublished' => 0,\n                    'description' => 'Click this to download all events and attributes that you have access to in MISP XML format.',\n            ),\n            'csv_sig' => array(\n                    'extension' => '.csv',\n                    'type' => 'CSV_Sig',\n                    'scope' => 'Event',\n                    'requiresPublished' => 1,\n                    'params' => array('published' => 1, 'to_ids' => 1, 'returnFormat' => 'csv'),\n                    'description' => 'Click this to download all attributes that are indicators and that you have access to <small>(except file attachments)</small> in CSV format.',\n            ),\n            'csv_all' => array(\n                    'extension' => '.csv',\n                    'type' => 'CSV_All',\n                    'scope' => 'Event',\n                    'requiresPublished' => 0,\n                    'params' => array('ignore' => 1, 'returnFormat' => 'csv'),\n                    'description' => 'Click this to download all attributes that you have access to <small>(except file attachments)</small> in CSV format.',\n            ),\n            'suricata' => array(\n                    'extension' => '.rules',\n                    'type' => 'Suricata',\n                    'scope' => 'Attribute',\n                    'requiresPublished' => 1,\n                    'params' => array('returnFormat' => 'suricata'),\n                    'description' => 'Click this to download all network related attributes that you have access to under the Suricata rule format. Only published events and attributes marked as IDS Signature are exported. Administration is able to maintain a whitelist containing host, domain name and IP numbers to exclude from the NIDS export.',\n            ),\n            'snort' => array(\n                    'extension' => '.rules',\n                    'type' => 'Snort',\n                    'scope' => 'Attribute',\n                    'requiresPublished' => 1,\n                    'params' => array('returnFormat' => 'snort'),\n                    'description' => 'Click this to download all network related attributes that you have access to under the Snort rule format. Only published events and attributes marked as IDS Signature are exported. Administration is able to maintain a whitelist containing host, domain name and IP numbers to exclude from the NIDS export.',\n            ),\n            'bro' => array(\n                    'extension' => '.intel',\n                    'type' => 'Bro',\n                    'scope' => 'Attribute',\n                    'requiresPublished' => 1,\n                    'params' => array('returnFormat' => 'bro'),\n                    'description' => 'Click this to download all network related attributes that you have access to under the Bro rule format. Only published events and attributes marked as IDS Signature are exported. Administration is able to maintain a whitelist containing host, domain name and IP numbers to exclude from the NIDS export.',\n            ),\n            'stix' => array(\n                    'extension' => '.xml',\n                    'type' => 'STIX',\n                    'scope' => 'Event',\n                    'requiresPublished' => 1,\n                    'params' => array('returnFormat' => 'stix', 'includeAttachments' => 1),\n                    'description' => 'Click this to download an a STIX document containing the STIX version of all events and attributes that you have access to.'\n            ),\n            'stix2' => array(\n                    'extension' => '.json',\n                    'type' => 'STIX2',\n                    'scope' => 'Event',\n                    'requiresPublished' => 1,\n                    'params' => array('returnFormat' => 'stix2', 'includeAttachments' => 1),\n                    'description' => 'Click this to download an a STIX2 document containing the STIX2 version of all events and attributes that you have access to.'\n            ),\n            'rpz' => array(\n                    'extension' => '.txt',\n                    'type' => 'RPZ',\n                    'scope' => 'Attribute',\n                    'requiresPublished' => 1,\n                    'params' => array('returnFormat' => 'rpz'),\n                    'description' => 'Click this to download an RPZ Zone file generated from all ip-src/ip-dst, hostname, domain attributes. This can be useful for DNS level firewalling. Only published events and attributes marked as IDS Signature are exported.'\n            ),\n            'text' => array(\n                    'extension' => '.txt',\n                    'type' => 'TEXT',\n                    'scope' => 'Attribute',\n                    'requiresPublished' => 1,\n                    'params' => array('returnFormat' => 'text', 'includeAttachments' => 1),\n                    'description' => 'Click on one of the buttons below to download all the attributes with the matching type. This list can be used to feed forensic software when searching for susipicious files. Only published events and attributes marked as IDS Signature are exported.'\n            ),\n    );\n\n    public $validFormats = array(\n        'openioc' => array('xml', 'OpeniocExport', 'ioc'),\n        'json' => array('json', 'JsonExport', 'json'),\n        'xml' => array('xml', 'XmlExport', 'xml'),\n        'suricata' => array('txt', 'NidsSuricataExport', 'rules'),\n        'snort' => array('txt', 'NidsSnortExport', 'rules'),\n        'rpz' => array('rpz', 'RPZExport', 'rpz'),\n        'text' => array('text', 'TextExport', 'txt'),\n        'csv' => array('csv', 'CsvExport', 'csv'),\n        'stix' => array('xml', 'Stix1Export', 'xml'),\n        'stix2' => array('json', 'Stix2Export', 'json'),\n        'cache' => array('txt', 'CacheExport', 'cache')\n    );\n\n    public $csv_event_context_fields_to_fetch = array(\n        'event_info' => array('object' => false, 'var' => 'info'),\n        'event_member_org' => array('object' => 'Org', 'var' => 'name'),\n        'event_source_org' => array('object' => 'Orgc', 'var' => 'name'),\n        'event_distribution' => array('object' => false, 'var' => 'distribution'),\n        'event_threat_level_id' => array('object' => 'ThreatLevel', 'var' => 'name'),\n        'event_analysis' => array('object' => false, 'var' => 'analysis'),\n        'event_date' => array('object' => false, 'var' => 'date'),\n        'event_tag' => array('object' => 'Tag', 'var' => 'name')\n    );\n\n    public $validate = array(\n        'org_id' => array(\n            'valueNotEmpty' => array(\n                'rule' => array('valueNotEmpty'),\n            ),\n            'numeric' => array(\n                'rule' => array('numeric'),\n            ),\n        ),\n        'orgc_id' => array(\n            'valueNotEmpty' => array(\n                'rule' => array('valueNotEmpty'),\n            ),\n            'numeric' => array(\n                    'rule' => array('numeric'),\n            ),\n        ),\n        'date' => array(\n            'date' => array(\n                'rule' => array('date'),\n                'message' => 'Expected date format: YYYY-MM-DD',\n                //'allowEmpty' => false,\n                'required' => true,\n                //'last' => false, // Stop validation after this rule\n                //'on' => 'create', // Limit validation to 'create' or 'update' operations\n            ),\n        ),\n        'threat_level_id' => array(\n            'rule' => array('inList', array('1', '2', '3', '4')),\n            'message' => 'Options : 1, 2, 3, 4 (for High, Medium, Low, Undefined)',\n            'required' => true\n        ),\n\n        'distribution' => array(\n            'not_empty_if_sg' => array(\n                'rule' => array('inList', array('0', '1', '2', '3', '4')),\n                'message' => 'Options : Your organisation only, This community only, Connected communities, All communities',\n                //'allowEmpty' => false,\n                'required' => true,\n                //'last' => false, // Stop validation after this rule\n                //'on' => 'create', // Limit validation to 'create' or 'update' operations\n                )\n        ),\n\n        'sharing_group_id' => array(\n            'rule' => array('sharingGroupRequired'),\n                'message' => 'If the distribution is set to \"Sharing Group\", a sharing group has to be selected.',\n                //'required' => true,\n                //'allowEmpty' => true\n        ),\n\n        'analysis' => array(\n            'rule' => array('inList', array('0', '1', '2')),\n                'message' => 'Options : 0, 1, 2 (for Initial, Ongoing, Completed)',\n                //'allowEmpty' => false,\n                'required' => true,\n                //'last' => false, // Stop validation after this rule\n                //'on' => 'create', // Limit validation to 'create' or 'update' operations\n        ),\n        'info' => array(\n            'valueNotEmpty' => array(\n                'rule' => array('valueNotEmpty'),\n            ),\n        ),\n        'user_id' => array(\n            'numeric' => array(\n                'rule' => array('numeric')\n            )\n        ),\n        'published' => array(\n            'boolean' => array(\n                'rule' => array('boolean'),\n                //'message' => 'Your custom message here',\n                //'allowEmpty' => false,\n                //'required' => false,\n                //'last' => false, // Stop validation after this rule\n                //'on' => 'create', // Limit validation to 'create' or 'update' operations\n            ),\n        ),\n        'uuid' => array(\n            'uuid' => array(\n                'rule' => array('custom', '/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/'),\n                'message' => 'Please provide a valid UUID'\n            ),\n        ),\n        'extends_uuid' => array(\n            'uuid' => array(\n                'rule' => array('custom', '/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/'),\n                'message' => 'Please provide a valid UUID',\n                'allowEmpty' => true\n            )\n        )\n    );\n\n    // The Associations below have been created with all possible keys, those that are not needed can be removed\n    public $belongsTo = array(\n        'User' => array(\n            'className' => 'User',\n            'foreignKey' => 'user_id',\n            'conditions' => '',\n            'fields' => '',\n            'order' => ''\n        ),\n        'ThreatLevel' => array(\n            'className' => 'ThreatLevel',\n            'foreignKey' => 'threat_level_id'\n        ),\n        'Org' => array(\n                'className' => 'Organisation',\n                'foreignKey' => 'org_id'\n        ),\n        'Orgc' => array(\n                'className' => 'Organisation',\n                'foreignKey' => 'orgc_id'\n        ),\n        'SharingGroup' => array(\n                'className' => 'SharingGroup',\n                'foreignKey' => 'sharing_group_id'\n        )\n    );\n\n    public $hasMany = array(\n        'Attribute' => array(\n            'className' => 'Attribute',\n            'foreignKey' => 'event_id',\n            'dependent' => true,\t// cascade deletes\n            'conditions' => '',\n            'fields' => '',\n            'order' => array('Attribute.category ASC', 'Attribute.type ASC'),\n            'limit' => '',\n            'offset' => '',\n            'exclusive' => '',\n            'finderQuery' => '',\n            'counterQuery' => ''\n        ),\n        'ShadowAttribute' => array(\n            'className' => 'ShadowAttribute',\n            'foreignKey' => 'event_id',\n            'dependent' => true,\t// cascade deletes\n            'conditions' => '',\n            'fields' => '',\n            'order' => array('ShadowAttribute.old_id DESC', 'ShadowAttribute.old_id DESC'),\n            'limit' => '',\n            'offset' => '',\n            'exclusive' => '',\n            'finderQuery' => '',\n            'counterQuery' => ''\n        ),\n        'Object' => array(\n            'className' => 'MispObject',\n            'foreignKey' => 'event_id',\n            'dependent' => true,\n            'conditions' => '',\n            'fields' => '',\n            'order' => false,\n            'limit' => '',\n            'offset' => '',\n            'exclusive' => '',\n            'finderQuery' => '',\n            'counterQuery' => ''\n        ),\n        'EventTag' => array(\n            'className' => 'EventTag',\n            'dependent' => true,\n        ),\n        'Sighting' => array(\n            'className' => 'Sighting',\n            'dependent' => true,\n        )\n    );\n\n    public function beforeDelete($cascade = true)\n    {\n        // blacklist the event UUID if the feature is enabled\n        if (Configure::read('MISP.enableEventBlacklisting') !== false) {\n            $this->EventBlacklist = ClassRegistry::init('EventBlacklist');\n            $this->EventBlacklist->create();\n            $orgc = $this->Orgc->find('first', array('conditions' => array('Orgc.id' => $this->data['Event']['orgc_id']), 'recursive' => -1, 'fields' => array('Orgc.name')));\n            $this->EventBlacklist->save(array('event_uuid' => $this->data['Event']['uuid'], 'event_info' => $this->data['Event']['info'], 'event_orgc' => $orgc['Orgc']['name']));\n            if (!empty($this->data['Event']['id'])) {\n                if (Configure::read('Plugin.ZeroMQ_enable') && Configure::read('Plugin.ZeroMQ_attribute_notifications_enable')) {\n                    $pubSubTool = $this->getPubSubTool();\n                    $pubSubTool->event_save(array('Event' => $this->data['Event']), 'delete');\n                }\n            }\n        }\n\n        // delete all of the event->tag combinations that involve the deleted event\n        $this->EventTag->deleteAll(array('event_id' => $this->id));\n\n        // only delete the file if it exists\n        $attachments_dir = Configure::read('MISP.attachments_dir');\n        if (empty($attachments_dir)) {\n            $attachments_dir = $this->getDefaultAttachments_dir();\n        }\n\n        // Things get a little funky here\n        if ($this->attachmentDirIsS3()) {\n            // S3 doesn't have folders\n            // So we have to basically `ls` them to look for a prefix\n            $s3 = $this->getS3Client();\n            $s3->deleteDirectory($this->id);\n        } else {\n            $filepath = $attachments_dir . DS . $this->id;\n            App::uses('Folder', 'Utility');\n            if (is_dir($filepath)) {\n                if (!$this->destroyDir($filepath)) {\n                    throw new InternalErrorException('Delete of event file directory failed. Please report to administrator.');\n                }\n            }\n        }\n    }\n\n    public function destroyDir($dir)\n    {\n        if (!is_dir($dir) || is_link($dir)) {\n            return unlink($dir);\n        }\n        foreach (scandir($dir) as $file) {\n            if ($file == '.' || $file == '..') {\n                continue;\n            }\n            if (!$this->destroyDir($dir . DS . $file)) {\n                chmod($dir . DS . $file, 0777);\n                if (!$this->destroyDir($dir . DS . $file)) {\n                    return false;\n                }\n            }\n        }\n        return rmdir($dir);\n    }\n\n    public function beforeValidate($options = array())\n    {\n        parent::beforeValidate();\n        // analysis - setting correct vars\n        if (isset($this->data['Event']['analysis'])) {\n            switch ($this->data['Event']['analysis']) {\n                case 'Initial':\n                    $this->data['Event']['analysis'] = 0;\n                    break;\n                case 'Ongoing':\n                    $this->data['Event']['analysis'] = 1;\n                    break;\n                case 'Completed':\n                    $this->data['Event']['analysis'] = 2;\n                    break;\n            }\n        } else {\n            $this->data['Event']['analysis'] = 0;\n        }\n\n        if (!isset($this->data['Event']['threat_level_id'])) {\n            $this->data['Event']['threat_level_id'] = Configure::read('MISP.default_event_threat_level') ? Configure::read('MISP.default_event_threat_level') : 4;\n        }\n\n        // generate UUID if it doesn't exist\n        if (empty($this->data['Event']['uuid'])) {\n            $this->data['Event']['uuid'] = CakeText::uuid();\n        }\n\n        // Convert event ID to uuid if needed\n        if (!empty($this->data['Event']['extends_uuid']) && is_numeric($this->data['Event']['extends_uuid'])) {\n            $extended_event = $this->find('first', array(\n                'recursive' => -1,\n                'conditions' => array('Event.id' => $this->data['Event']['extends_uuid']),\n                'fields' => array('Event.uuid')\n            ));\n            if (empty($extended_event)) {\n                $this->data['Event']['extends_uuid'] = '';\n            } else {\n                $this->data['Event']['extends_uuid'] = $extended_event['Event']['uuid'];\n            }\n        }\n\n        // generate timestamp if it doesn't exist\n        if (empty($this->data['Event']['timestamp'])) {\n            $date = new DateTime();\n            $this->data['Event']['timestamp'] = $date->getTimestamp();\n        }\n\n        if (empty($this->data['Event']['date'])) {\n            $this->data['Event']['date'] = date('Y-m-d');\n        }\n\n        if (!isset($this->data['Event']['distribution']) || $this->data['Event']['distribution'] != 4) {\n            $this->data['Event']['sharing_group_id'] = 0;\n        }\n    }\n\n    public function afterSave($created, $options = array())\n    {\n        if (!Configure::read('MISP.completely_disable_correlation') && !$created) {\n            $this->Correlation = ClassRegistry::init('Correlation');\n            $db = $this->getDataSource();\n            if (isset($this->data['Event']['date'])) {\n                $this->Correlation->updateAll(array('Correlation.date' => $db->value($this->data['Event']['date'])), array('Correlation.event_id' => intval($this->data['Event']['id'])));\n            }\n            if (isset($this->data['Event']['info'])) {\n                $this->Correlation->updateAll(array('Correlation.info' => $db->value($this->data['Event']['info'])), array('Correlation.event_id' => intval($this->data['Event']['id'])));\n            }\n        }\n        if (empty($this->data['Event']['unpublishAction']) && empty($this->data['Event']['skip_zmq']) && Configure::read('Plugin.ZeroMQ_enable') && Configure::read('Plugin.ZeroMQ_event_notifications_enable')) {\n            $pubSubTool = $this->getPubSubTool();\n            $event = $this->quickFetchEvent($this->data['Event']['id']);\n            if (!empty($event)) {\n                $pubSubTool->event_save($event, $created ? 'add' : 'edit');\n            }\n        }\n    }\n\n    public function buildEventConditions($user)\n    {\n        $conditions = array();\n        if ($user['Role']['perm_site_admin']) {\n            return $conditions;\n        }\n        $sgids = $this->SharingGroup->fetchAllAuthorised($user);\n        $conditions['OR'] = array(\n            'Event.orgc_id' => $user['org_id'],\n            'Event.distribution' => array(1, 2, 3),\n            'AND' => array(\n                'Event.distribution' => 4,\n                'Event.sharing_group_id' => $sgids\n            )\n        );\n        return $conditions;\n    }\n\n    public function isOwnedByOrg($eventid, $org)\n    {\n        return $this->field('id', array('id' => $eventid, 'org_id' => $org)) === $eventid;\n    }\n\n    public function attachtagsToEvents($events)\n    {\n        $tagsToFetch = array();\n        foreach ($events as $k => $event) {\n            if (!empty($event['EventTag'])) {\n                foreach ($event['EventTag'] as $et) {\n                    $tagsToFetch[$et['tag_id']] = $et['tag_id'];\n                }\n            }\n        }\n        $tags = $this->EventTag->Tag->find('all', array(\n            'conditions' => array('Tag.id' => $tagsToFetch),\n            'recursive' => -1,\n            'order' => false\n        ));\n        $tags = Set::combine($tags, '{n}.Tag.id', '{n}');\n        foreach ($events as $k => $event) {\n            if (!empty($event['EventTag'])) {\n                foreach ($event['EventTag'] as $k2 => $et) {\n                    $events[$k]['EventTag'][$k2]['Tag'] = $tags[$et['tag_id']]['Tag'];\n                }\n            }\n        }\n        return $events;\n    }\n\n    // gets the logged in user + an array of events, attaches the correlation count to each\n    public function attachCorrelationCountToEvents($user, $events)\n    {\n        $sgids = $this->SharingGroup->fetchAllAuthorised($user);\n        if (!isset($sgids) || empty($sgids)) {\n            $sgids = array(-1);\n        }\n        $this->Correlation = ClassRegistry::init('Correlation');\n        $eventIds = Set::extract('/Event/id', $events);\n        $conditionsCorrelation = $this->__buildEventConditionsCorrelation($user, $eventIds, $sgids);\n        $correlations = $this->Correlation->find('all', array(\n            'fields' => array('Correlation.1_event_id', 'count(distinct(Correlation.event_id)) as count'),\n            'conditions' => $conditionsCorrelation,\n            'recursive' => -1,\n            'group' => array('Correlation.1_event_id'),\n        ));\n        $correlations = Hash::combine($correlations, '{n}.Correlation.1_event_id', '{n}.0.count');\n        foreach ($events as &$event) {\n            $event['Event']['correlation_count'] = (isset($correlations[$event['Event']['id']])) ? $correlations[$event['Event']['id']] : 0;\n        }\n        return $events;\n    }\n\n    public function attachSightingsCountToEvents($user, $events)\n    {\n        $eventIds = Set::extract('/Event/id', $events);\n        $this->Sighting = ClassRegistry::init('Sighting');\n        $sightings = $this->Sighting->find('all', array(\n            'fields' => array('Sighting.event_id', 'count(distinct(Sighting.id)) as count'),\n            'conditions' => array('event_id' => $eventIds),\n            'recursive' => -1,\n            'group' => array('event_id')\n        ));\n        $sightings = Hash::combine($sightings, '{n}.Sighting.event_id', '{n}.0.count');\n        foreach ($events as $key => $event) {\n            $events[$key]['Event']['sightings_count'] = (isset($sightings[$event['Event']['id']])) ? $sightings[$event['Event']['id']] : 0;\n        }\n        return $events;\n    }\n\n    public function attachProposalsCountToEvents($user, $events)\n    {\n        $eventIds = Set::extract('/Event/id', $events);\n        $proposals = $this->ShadowAttribute->find('all', array(\n                'fields' => array('ShadowAttribute.event_id', 'count(distinct(ShadowAttribute.id)) as count'),\n                'conditions' => array('event_id' => $eventIds, 'deleted' => 0),\n                'recursive' => -1,\n                'group' => array('event_id')\n        ));\n        $proposals = Hash::combine($proposals, '{n}.ShadowAttribute.event_id', '{n}.0.count');\n        foreach ($events as $key => $event) {\n            $events[$key]['Event']['proposals_count'] = (isset($proposals[$event['Event']['id']])) ? $proposals[$event['Event']['id']] : 0;\n        }\n        return $events;\n    }\n\n    public function attachDiscussionsCountToEvents($user, $events)\n    {\n        $eventIds = Set::extract('/Event/id', $events);\n        $this->Thread = ClassRegistry::init('Thread');\n        $threads = $this->Thread->find('list', array(\n            'conditions' => array('Thread.event_id' => $eventIds),\n            'fields' => array('Thread.event_id', 'Thread.id')\n        ));\n        $posts = $this->Thread->Post->find('all', array(\n            'conditions' => array('Post.thread_id' => $threads),\n            'recursive' => -1,\n            'fields' => array('Count(id) AS post_count', 'thread_id', 'max(date_modified) as last_post'),\n            'group' => array('Post.thread_id')\n        ));\n        $event_threads = array();\n        foreach ($posts as $k => $v) {\n            foreach ($threads as $k2 => $v2) {\n                if ($v2 == $v['Post']['thread_id']) {\n                    $event_threads[$k2] = array(\n                        'post_count' => $v[0]['post_count'],\n                        'last_post' => strtotime($v[0]['last_post'])\n                    );\n                }\n            }\n        }\n        foreach ($events as $k => $v) {\n            $events[$k]['Event']['post_count'] = !empty($event_threads[$events[$k]['Event']['id']]) ? $event_threads[$events[$k]['Event']['id']]['post_count'] : 0;\n            $events[$k]['Event']['last_post'] = !empty($event_threads[$events[$k]['Event']['id']]) ? $event_threads[$events[$k]['Event']['id']]['last_post'] : 0;\n        }\n        return $events;\n    }\n\n    private function __buildEventConditionsCorrelation($user, $eventIds, $sgids)\n    {\n        if (!is_array($eventIds)) {\n            $eventIds = array($eventIds);\n        }\n        if (!$user['Role']['perm_site_admin']) {\n            $conditionsCorrelation = array(\n                    'AND' => array(\n                            'Correlation.1_event_id' => $eventIds,\n                            array(\n                                    'OR' => array(\n                                            'Correlation.org_id' => $user['org_id'],\n                                            'AND' => array(\n                                                    array(\n                                                            'OR' => array(\n                                                                    array(\n                                                                            'AND' => array(\n                                                                                    'Correlation.distribution >' => 0,\n                                                                                    'Correlation.distribution <' => 4,\n                                                                            ),\n                                                                    ),\n                                                                    array(\n                                                                            'AND' => array(\n                                                                                    'Correlation.distribution' => 4,\n                                                                                    'Correlation.sharing_group_id' => $sgids\n                                                                            ),\n                                                                    ),\n                                                            ),\n                                                    ),\n                                                    array(\n                                                            'OR' => array(\n                                                                    'Correlation.a_distribution' => 5,\n                                                                    array(\n                                                                            'AND' => array(\n                                                                                    'Correlation.a_distribution >' => 0,\n                                                                                    'Correlation.a_distribution <' => 4,\n                                                                            ),\n                                                                    ),\n                                                                    array(\n                                                                            'AND' => array(\n                                                                                    'Correlation.a_distribution' => 4,\n                                                                                    'Correlation.a_sharing_group_id' => $sgids\n                                                                            ),\n                                                                    ),\n                                                            ),\n                                                    ),\n                                            ),\n                                    ),\n                            ),\n                    ),\n            );\n        } else {\n            $conditionsCorrelation = array('Correlation.1_event_id' => $eventIds);\n        }\n        return $conditionsCorrelation;\n    }\n\n    public function getRelatedEvents($user, $eventId = null, $sgids)\n    {\n        if ($eventId == null) {\n            $eventId = $this->data['Event']['id'];\n        }\n        if (!isset($sgids) || empty($sgids)) {\n            $sgids = array(-1);\n        }\n        $this->Correlation = ClassRegistry::init('Correlation');\n        // search the correlation table for the event ids of the related events\n        // Rules:\n        // 1. Event is owned by the user (org_id matches)\n        // 2. User is allowed to see both the event and the org:\n        //    a.  Event:\n        //        i. Event has a distribution between 1-3 (community only, connected communities, all orgs)\n        //        ii. Event has a sharing group that the user is accessible to view\n        //    b.  Attribute:\n        //        i. Attribute has a distribution of 5 (inheritance of the event, for this the event check has to pass anyway)\n        //        ii. Atttibute has a distribution between 1-3 (community only, connected communities, all orgs)\n        //        iii. Attribute has a sharing group that the user is accessible to view\n        $conditionsCorrelation = $this->__buildEventConditionsCorrelation($user, $eventId, $sgids);\n        $correlations = $this->Correlation->find('list', array(\n                'fields' => array('Correlation.event_id', 'Correlation.event_id'),\n                'conditions' => $conditionsCorrelation,\n                'recursive' => 0,\n                'group' => 'Correlation.event_id',\n                'order' => array('Correlation.event_id DESC')));\n\n        $relatedEventIds = array_values($correlations);\n        // now look up the event data for these attributes\n        $conditions = array(\"Event.id\" => $relatedEventIds);\n        $fields = array('id', 'date', 'threat_level_id', 'info', 'published', 'uuid', 'analysis', 'timestamp', 'distribution', 'org_id', 'orgc_id');\n        $orgfields = array('id', 'name', 'uuid');\n        $relatedEvents = $this->find(\n            'all',\n            array('conditions' => $conditions,\n                'recursive' => -1,\n                'order' => 'Event.date DESC',\n                'fields' => $fields,\n                'contain' => array(\n                    'Org' => array(\n                        'fields' => $orgfields\n                    ),\n                    'Orgc' => array(\n                        'fields' => $orgfields\n                    )\n                )\n            )\n        );\n        $fieldsToRearrange = array('Org', 'Orgc');\n        foreach ($relatedEvents as $k => $relatedEvent) {\n            foreach ($fieldsToRearrange as $field) {\n                if (isset($relatedEvent[$field])) {\n                    $relatedEvents[$k]['Event'][$field] = $relatedEvent[$field];\n                    unset($relatedEvents[$k][$field]);\n                }\n            }\n        }\n        return $relatedEvents;\n    }\n\n    public function getRelatedAttributes($user, $id = null, $sgids, $shadowAttribute = false, $scope = 'event')\n    {\n        $context = $shadowAttribute ? 'ShadowAttribute' : 'Attribute';\n        $settings = array(\n            'Attribute' => array('model' => 'Attribute', 'correlationModel' => 'Correlation', 'parentIdField' => '1_attribute_id'),\n            'ShadowAttribute' => array('model' => 'ShadowAttribute', 'correlationModel' => 'ShadowAttributeCorrelation', 'parentIdField' => '1_shadow_attribute_id')\n        );\n        if ($scope === 'event' && $id == null) {\n            $id = $this->data['Event']['id'];\n        } elseif ($scope === 'attribute' && $id == null) {\n            $id = $this->data['Attribute']['id'];\n        }\n        if (!isset($sgids) || empty($sgids)) {\n            $sgids = array(-1);\n        }\n        $this->{$settings[$context]['correlationModel']} = ClassRegistry::init($settings[$context]['correlationModel']);\n        if (!$user['Role']['perm_site_admin']) {\n            $conditionsCorrelation = array(\n                    'AND' => array(\n                            $settings[$context]['correlationModel'] . '.1_' . $scope . '_id' => $id,\n                            array(\n                                    'OR' => array(\n                                            $settings[$context]['correlationModel'] . '.org_id' => $user['org_id'],\n                                            'AND' => array(\n                                                    array(\n                                                            'OR' => array(\n                                                                    array(\n                                                                            'AND' => array(\n                                                                                    $settings[$context]['correlationModel'] . '.distribution >' => 0,\n                                                                                    $settings[$context]['correlationModel'] . '.distribution <' => 4,\n                                                                            ),\n                                                                    ),\n                                                                    array(\n                                                                            'AND' => array(\n                                                                                    $settings[$context]['correlationModel'] . '.distribution' => 4,\n                                                                                    $settings[$context]['correlationModel'] . '.sharing_group_id' => $sgids\n                                                                            ),\n                                                                    ),\n                                                            ),\n                                                    ),\n                                                    array(\n                                                            'OR' => array(\n                                                                    $settings[$context]['correlationModel'] . '.a_distribution' => 5,\n                                                                    array(\n                                                                            'AND' => array(\n                                                                                    $settings[$context]['correlationModel'] . '.a_distribution >' => 0,\n                                                                                    $settings[$context]['correlationModel'] . '.a_distribution <' => 4,\n                                                                            ),\n                                                                    ),\n                                                                    array(\n                                                                            'AND' => array(\n                                                                                    $settings[$context]['correlationModel'] . '.a_distribution' => 4,\n                                                                                    $settings[$context]['correlationModel'] . '.a_sharing_group_id' => $sgids\n                                                                            ),\n                                                                    ),\n                                                            ),\n                                                    ),\n                                            ),\n                                    )\n                            )\n\n                    )\n            );\n        } else {\n            $conditionsCorrelation = array($settings[$context]['correlationModel'] . '.1_' . $scope . '_id' => $id);\n        }\n        $max_correlations = Configure::read('MISP.max_correlations_per_event');\n        if (empty($max_correlations)) {\n            $max_correlations = 5000;\n        }\n        $correlations = $this->{$settings[$context]['correlationModel']}->find('all', array(\n                'fields' => $settings[$context]['correlationModel'] . '.*',\n                'conditions' => $conditionsCorrelation,\n                'recursive' => -1,\n                'order' => false,\n                'limit' => $max_correlations\n        ));\n        $relatedAttributes = array();\n        foreach ($correlations as $k => $correlation) {\n            $current = array(\n                    'id' => $correlation[$settings[$context]['correlationModel']]['event_id'],\n                    'attribute_id' => $correlation[$settings[$context]['correlationModel']]['attribute_id'],\n                    'org_id' => $correlation[$settings[$context]['correlationModel']]['org_id'],\n                    'info' => $correlation[$settings[$context]['correlationModel']]['info'],\n                    'value' => $correlation[$settings[$context]['correlationModel']]['value'],\n            );\n            if (empty($relatedAttributes[$correlation[$settings[$context]['correlationModel']][$settings[$context]['parentIdField']]]) || !in_array($current, $relatedAttributes[$correlation[$settings[$context]['correlationModel']][$settings[$context]['parentIdField']]])) {\n                $relatedAttributes[$correlation[$settings[$context]['correlationModel']][$settings[$context]['parentIdField']]][] = $current;\n            }\n            unset($correlations[$k]);\n        }\n        return $relatedAttributes;\n    }\n\n    /**\n     * Clean up an Event Array that was received by an XML request.\n     * The structure needs to be changed a little bit to be compatible with what CakePHP expects\n     *\n     * This function receives the reference of the variable, so no return is required as it directly\n     * modifies the original data.\n     */\n    public function cleanupEventArrayFromXML(&$data)\n    {\n        $objects = array('Attribute', 'ShadowAttribute', 'Object');\n        foreach ($objects as $object) {\n            // Workaround for different structure in XML/array than what CakePHP expects\n            if (isset($data['Event'][$object]) && is_array($data['Event'][$object]) && count($data['Event'][$object])) {\n                if (!is_numeric(implode(array_keys($data['Event'][$object]), ''))) {\n                    // single attribute\n                    $data['Event'][$object] = array(0 => $data['Event'][$object]);\n                }\n                $data['Event'][$object] = array_values($data['Event'][$object]);\n            }\n        }\n        $objects = array('Org', 'Orgc', 'SharingGroup');\n        foreach ($objects as $object) {\n            if (isset($data['Event'][$object][0])) {\n                $data['Event'][$object] = $data['Event'][$object][0];\n            }\n        }\n        return $data;\n    }\n\n    private function __resolveErrorCode($code, &$event, &$server)\n    {\n        $error = false;\n        switch ($code) {\n            case 403:\n                return 'The distribution level of this event blocks it from being pushed.';\n            case 405:\n                $error = 'The sync user on the remote instance does not have the required privileges to handle this event.';\n                break;\n        }\n        if ($error) {\n            $newTextBody = 'Uploading Event (' . $event['Event']['id'] . ') to Server (' . $server['Server']['id'] . ')';\n            $this->__logUploadResult($server, $event, $newTextBody);\n        }\n        return $error;\n    }\n\n    private function __executeRestfulEventToServer($event, $server, $resourceId, &$newLocation, &$newTextBody, $HttpSocket)\n    {\n        $result = $this->restfulEventToServer($event, $server, $resourceId, $newLocation, $newTextBody, $HttpSocket);\n        if (is_numeric($result)) {\n            $error = $this->__resolveErrorCode($result, $event, $server);\n            if ($error) {\n                return $error . ' Error code: ' . $result;\n            }\n        }\n        return true;\n    }\n\n    public function uploadEventToServer($event, $server, $HttpSocket = null)\n    {\n        $this->Server = ClassRegistry::init('Server');\n        $push = $this->Server->checkVersionCompatibility($server['Server']['id'], false, $HttpSocket);\n        if (empty($push['canPush'])) {\n            return 'The remote user is not a sync user - the upload of the event has been blocked.';\n        }\n        if (!empty($server['Server']['unpublish_event'])) {\n            $event['Event']['published'] = 0;\n        }\n        $updated = null;\n        $newLocation = $newTextBody = '';\n        $result = $this->__executeRestfulEventToServer($event, $server, null, $newLocation, $newTextBody, $HttpSocket);\n        if ($result !== true) {\n            return $result;\n        }\n        if (strlen($newLocation)) { // HTTP/1.1 302 Found and Location: http://<newLocation>\n            $result = $this->__executeRestfulEventToServer($event, $server, $newLocation, $newLocation, $newTextBody, $HttpSocket);\n            if ($result !== true) {\n                return $result;\n            }\n        }\n        $uploadFailed = false;\n        try {\n            $json = json_decode($newTextBody, true);\n        } catch (Exception $e) {\n            $uploadFailed = true;\n        }\n        if (!is_array($json) || $uploadFailed) {\n            return $this->__logUploadResult($server, $event, $newTextBody);\n        }\n        return 'Success';\n    }\n\n    private function __prepareForPushToServer($event, $server)\n    {\n        if ($event['Event']['distribution'] == 4) {\n            if (!empty($event['SharingGroup']['SharingGroupServer'])) {\n                $found = false;\n                foreach ($event['SharingGroup']['SharingGroupServer'] as $sgs) {\n                    if ($sgs['server_id'] == $server['Server']['id']) {\n                        $found = true;\n                    }\n                }\n                if (!$found) {\n                    return 403;\n                }\n            }\n        }\n        $serverModel = ClassRegistry::init('Server');\n        $server = $serverModel->eventFilterPushableServers($event, array($server));\n        if (empty($server)) {\n            return 403;\n        }\n        $server = $server[0];\n        if ($this->checkDistributionForPush($event, $server, 'Event')) {\n            $event = $this->__updateEventForSync($event, $server);\n        } else {\n            return 403;\n        }\n        return $event;\n    }\n\n    private function __getLastUrlPathComponent($urlPath)\n    {\n        if (!empty($urlPath)) {\n            $pieces = explode('/', $urlPath);\n            return '/' . end($pieces);\n        }\n        return '';\n    }\n\n    private function __handleRestfulEventToServerResponse($response, &$newLocation, &$newTextBody)\n    {\n        switch ($response->code) {\n            case '200':\t// 200 (OK) + entity-action-result\n                if ($response->isOk()) {\n                    $newTextBody = $response->body();\n                    return true;\n                } else {\n                    try {\n                        $jsonArray = json_decode($response->body, true);\n                    } catch (Exception $e) {\n                        return true;\n                    }\n                    return $jsonArray['name'];\n                }\n                // no break\n            case '302': // Found\n                $newLocation = $response->headers['Location'];\n                $newTextBody = $response->body();\n                return true;\n            case '404': // Not Found\n                $newLocation = $response->headers['Location'];\n                $newTextBody = $response->body();\n                return 404;\n            case '405':\n                return 405;\n            case '403': // Not authorised\n                return 403;\n        }\n    }\n\n    // Uploads the event and the associated Attributes to another Server\n    public function restfulEventToServer($event, $server, $urlPath, &$newLocation, &$newTextBody, $HttpSocket = null)\n    {\n        $event = $this->__prepareForPushToServer($event, $server);\n        if (is_numeric($event)) {\n            return $event;\n        }\n        $url = $server['Server']['url'];\n        $HttpSocket = $this->setupHttpSocket($server, $HttpSocket);\n        $request = $this->setupSyncRequest($server);\n        $uri = $url . '/events' . $this->__getLastUrlPathComponent($urlPath);\n        $data = json_encode($event);\n        $response = $HttpSocket->post($uri, $data, $request);\n        return $this->__handleRestfulEventToServerResponse($response, $newLocation, $newTextBody);\n    }\n\n    private function __rearrangeEventStructureForSync($event)\n    {\n        // rearrange things to be compatible with the Xml::fromArray()\n        $objectsToRearrange = array('Attribute', 'Object', 'Orgc', 'SharingGroup', 'EventTag', 'Org', 'ShadowAttribute');\n        foreach ($objectsToRearrange as $o) {\n            if (isset($event[$o])) {\n                $event['Event'][$o] = $event[$o];\n                unset($event[$o]);\n            }\n        }\n        // cleanup the array from things we do not want to expose\n        foreach (array('Org', 'org_id', 'orgc_id', 'proposal_email_lock', 'org', 'orgc') as $field) {\n            unset($event['Event'][$field]);\n        }\n        return $event;\n    }\n\n    // since we fetch the event and filter on tags after / server, we need to cull all of the non exportable tags\n    private function __removeNonExportableTags($data, $dataType)\n    {\n        if (!empty($data[$dataType . 'Tag'])) {\n            foreach ($data[$dataType . 'Tag'] as $k => $tag) {\n                if (!$tag['Tag']['exportable']) {\n                    unset($data[$dataType . 'Tag'][$k]);\n                } else {\n                    unset($tag['org_id']);\n                    $data['Tag'][] = $tag['Tag'];\n                }\n            }\n            unset($data[$dataType . 'Tag']);\n        }\n        return $data;\n    }\n\n    private function __prepareAttributesForSync($data, $server)\n    {\n        // prepare attribute for sync\n        if (!empty($data['Attribute'])) {\n            foreach ($data['Attribute'] as $key => $attribute) {\n                $data['Attribute'][$key] = $this->__updateAttributeForSync($attribute, $server);\n                if (empty($data['Attribute'][$key])) {\n                    unset($data['Attribute'][$key]);\n                } else {\n                    $data['Attribute'][$key] = $this->__removeNonExportableTags($data['Attribute'][$key], 'Attribute');\n                }\n            }\n            $data['Attribute'] = array_values($data['Attribute']);\n        }\n        return $data;\n    }\n\n    private function __prepareObjectsForSync($data, $server)\n    {\n        // prepare Object for sync\n        if (!empty($data['Object'])) {\n            foreach ($data['Object'] as $key => $object) {\n                $data['Object'][$key] = $this->__updateObjectForSync($object, $server);\n                if (empty($data['Object'][$key])) {\n                    unset($data['Object'][$key]);\n                } else {\n                    $data['Object'][$key]['Attribute'] = $this->__prepareAttributesForSync($data['Object'][$key]['Attribute'], $server);\n                }\n            }\n            $data['Object'] = array_values($data['Object']);\n        }\n        return $data;\n    }\n\n    private function __updateEventForSync($event, $server)\n    {\n        $event = $this->__rearrangeEventStructureForSync($event);\n        $event['Event'] = $this->__removeNonExportableTags($event['Event'], 'Event');\n        // Add the local server to the list of instances in the SG\n        if (isset($event['Event']['SharingGroup']) && isset($event['Event']['SharingGroup']['SharingGroupServer'])) {\n            foreach ($event['Event']['SharingGroup']['SharingGroupServer'] as &$s) {\n                if ($s['server_id'] == 0) {\n                    $s['Server'] = array('id' => 0, 'url' => Configure::read('MISP.baseurl'));\n                }\n            }\n        }\n        $event['Event'] = $this->__prepareAttributesForSync($event['Event'], $server);\n        $event['Event'] = $this->__prepareObjectsForSync($event['Event'], $server);\n\n        // Downgrade the event from connected communities to community only\n        if (!$server['Server']['internal'] && $event['Event']['distribution'] == 2) {\n            $event['Event']['distribution'] = 1;\n        }\n        return $event;\n    }\n\n    private function __updateObjectForSync($object, $server)\n    {\n        if (!$server['Server']['internal'] && $object['distribution'] < 2) {\n            return false;\n        }\n        // Downgrade the object from connected communities to community only\n        if (!$server['Server']['internal'] && $object['distribution'] == 2) {\n            $object['distribution'] = 1;\n        }\n        // If the object has a sharing group attached, make sure it can be transfered\n        if ($object['distribution'] == 4) {\n            if (!$server['Server']['internal'] && $this->checkDistributionForPush(array('Object' => $object), $server, 'Object') === false) {\n                return false;\n            }\n            // Add the local server to the list of instances in the SG\n            if (isset($object['SharingGroup']['SharingGroupServer'])) {\n                foreach ($object['SharingGroup']['SharingGroupServer'] as &$s) {\n                    if ($s['server_id'] == 0) {\n                        $s['Server'] = array('id' => 0, 'url' => Configure::read('MISP.baseurl'));\n                    }\n                }\n            }\n        }\n        return $object;\n    }\n\n    private function __updateAttributeForSync($attribute, $server)\n    {\n        // do not keep attributes that are private, nor cluster\n        if (!$server['Server']['internal'] && $attribute['distribution'] < 2) {\n            return false;\n        }\n        // Downgrade the attribute from connected communities to community only\n        if (!$server['Server']['internal'] && $attribute['distribution'] == 2) {\n            $attribute['distribution'] = 1;\n        }\n\n        // If the attribute has a sharing group attached, make sure it can be transfered\n        if ($attribute['distribution'] == 4) {\n            if (!$server['Server']['internal'] && $this->checkDistributionForPush(array('Attribute' => $attribute), $server, 'Attribute') === false) {\n                return false;\n            }\n            // Add the local server to the list of instances in the SG\n            if (!empty($attribute['SharingGroup']['SharingGroupServer'])) {\n                foreach ($attribute['SharingGroup']['SharingGroupServer'] as &$s) {\n                    if ($s['server_id'] == 0) {\n                        $s['Server'] = array('id' => 0, 'url' => Configure::read('MISP.baseurl'));\n                    }\n                }\n            }\n        }\n        // also add the encoded attachment\n        if ($this->Attribute->typeIsAttachment($attribute['type'])) {\n            $attribute['data'] = $this->Attribute->base64EncodeAttachment($attribute);\n        }\n        // Passing the attribute ID together with the attribute could cause the deletion of attributes after a publish/push\n        // Basically, if the attribute count differed between two instances, and the instance with the lower attribute\n        // count pushed, the old attributes with the same ID got overwritten. Unsetting the ID before pushing it\n        // solves the issue and a new attribute is always created.\n        unset($attribute['id']);\n        // remove value1 and value2 from the output\n        unset($attribute['value1']);\n        unset($attribute['value2']);\n        return $attribute;\n    }\n\n    public function downloadEventFromServer($eventId, $server, $HttpSocket=null)\n    {\n        $url = $server['Server']['url'];\n        $HttpSocket = $this->setupHttpSocket($server, $HttpSocket);\n        $request = $this->setupSyncRequest($server);\n        $uri = $url . '/events/view/' . $eventId . '/deleted:1/excludeGalaxy:1';\n        $response = $HttpSocket->get($uri, $data = '', $request);\n        if ($response->isOk()) {\n            return json_decode($response->body, true);\n        }\n        return null;\n    }\n\n    public function quickDelete($event)\n    {\n        $id = $event['Event']['id'];\n        $this->Thread = ClassRegistry::init('Thread');\n        $thread = $this->Thread->find('first', array(\n            'conditions' => array('Thread.event_id' => $id),\n            'fields' => array('Thread.id'),\n            'recursive' => -1\n        ));\n        $thread_id = !empty($thread) ? $thread['Thread']['id'] : false;\n        $relations = array(\n            array(\n                'table' => 'attributes',\n                'foreign_key' => 'event_id',\n                'value' => $id\n            ),\n            array(\n                'table' => 'shadow_attributes',\n                'foreign_key' => 'event_id',\n                'value' => $id\n            ),\n            array(\n                'table' => 'event_tags',\n                'foreign_key' => 'event_id',\n                'value' => $id\n            ),\n            array(\n                'table' => 'attribute_tags',\n                'foreign_key' => 'event_id',\n                'value' => $id\n            ),\n            array(\n                'table' => 'threads',\n                'foreign_key' => 'event_id',\n                'value' => $id\n            ),\n            array(\n                'table' => 'sightings',\n                'foreign_key' => 'event_id',\n                'value' => $id\n            ),\n            array(\n                'table' => 'event_delegations',\n                'foreign_key' => 'event_id',\n                'value' => $id\n            ),\n            array(\n                'table' => 'objects',\n                'foreign_key' => 'event_id',\n                'value' => $id\n            ),\n            array(\n                'table' => 'object_references',\n                'foreign_key' => 'event_id',\n                'value' => $id\n            )\n        );\n        if ($thread_id) {\n            $relations[] = \tarray(\n                'table' => 'posts',\n                'foreign_key' => 'thread_id',\n                'value' => $thread_id\n            );\n        }\n        if (!Configure::read('MISP.completely_disable_correlation')) {\n            array_push(\n                $relations,\n                array(\n                    'table' => 'correlations',\n                    'foreign_key' => 'event_id',\n                    'value' => $id\n                ),\n                array(\n                    'table' => 'correlations',\n                    'foreign_key' => '1_event_id',\n                    'value' => $id\n                )\n            );\n        }\n        App::uses('QueryTool', 'Tools');\n        $queryTool = new QueryTool();\n        foreach ($relations as $relation) {\n            $queryTool->quickDelete($relation['table'], $relation['foreign_key'], $relation['value'], $this);\n        }\n        return $this->delete($id, false);\n    }\n\n    public function downloadProposalsFromServer($uuidList, $server, $HttpSocket = null)\n    {\n        $url = $server['Server']['url'];\n        $HttpSocket = $this->setupHttpSocket($server, $HttpSocket);\n        $request = $this->setupSyncRequest($server);\n        $uri = $url . '/shadow_attributes/getProposalsByUuidList';\n        $response = $HttpSocket->post($uri, json_encode($uuidList), $request);\n        if ($response->isOk()) {\n            return(json_decode($response->body, true));\n        } else {\n            return false;\n        }\n    }\n\n    public function createEventConditions($user)\n    {\n        $conditions = array();\n        if (!$user['Role']['perm_site_admin']) {\n            $sgids = $this->cacheSgids($user, true);\n            $conditions['AND']['OR'] = array(\n                'Event.org_id' => $user['org_id'],\n                array(\n                    'AND' => array(\n                        'Event.distribution >' => 0,\n                        'Event.distribution <' => 4,\n                        Configure::read('MISP.unpublishedprivate') ? array('Event.published =' => 1) : array(),\n                    ),\n                ),\n                array(\n                    'AND' => array(\n                        'Event.sharing_group_id' => $sgids,\n                        'Event.distribution' => 4,\n                        Configure::read('MISP.unpublishedprivate') ? array('Event.published =' => 1) : array(),\n                    )\n                )\n            );\n        }\n        return $conditions;\n    }\n\n    public function set_filter_wildcard(&$params, $conditions, $options)\n    {\n        $tempConditions = array();\n        $tempConditions[] = array('Event.info LIKE' => $params['wildcard']);\n        $attributeParams = array('value1', 'value2', 'comment');\n        foreach ($attributeParams as $attributeParam) {\n            $subQueryOptions = array(\n                'conditions' => array('Attribute.' . $attributeParam . ' LIKE' => $params['wildcard']),\n                'fields' => array('event_id')\n            );\n            $tempConditions[] = $this->subQueryGenerator($this->Attribute, $subQueryOptions, 'Event.id');\n        }\n        $tagScopes = array('Event', 'Attribute');\n        $this->AttributeTag = ClassRegistry::init('AttributeTag');\n        $tagIds = $this->AttributeTag->Tag->find('list', array(\n            'recursive' => -1,\n            'conditions' => array('Tag.name LIKE' => $params['wildcard']),\n            'fields' => array('Tag.id')\n        ));\n        if (!empty($tagIds)) {\n            foreach ($tagScopes as $tagScope) {\n                $subQueryOptions = array(\n                    'conditions' => array(\n                        'tag_id' => $tagIds,\n                    ),\n                    'fields' => array('event_id')\n                );\n                $tempConditions[] = $this->subQueryGenerator($this->{$tagScope . 'Tag'}, $subQueryOptions, 'Event.id');\n            }\n        }\n        return $tempConditions;\n    }\n\n    public function set_filter_wildcard_attributes(&$params, $conditions, $options)\n    {\n        $tempConditions = array();\n        $tempConditions[] = array('Event.info LIKE' => $params['wildcard']);\n        $attributeParams = array('value1', 'value2', 'comment');\n        foreach ($attributeParams as $attributeParam) {\n            $tempConditions[] = array('Attribute.' . $attributeParam . ' LIKE' => $params['wildcard']);\n        }\n        $tagScopes = array('Event', 'Attribute');\n        $this->AttributeTag = ClassRegistry::init('AttributeTag');\n        $tagIds = $this->AttributeTag->Tag->find('list', array(\n            'recursive' => -1,\n            'conditions' => array('Tag.name LIKE' => $params['wildcard']),\n            'fields' => array('Tag.id')\n        ));\n        if (!empty($tagIds)) {\n            $subQueryOptions = array(\n                'conditions' => array(\n                    'tag_id' => $tagIds,\n                ),\n                'fields' => array('event_id')\n            );\n            $tempConditions[] = $this->subQueryGenerator($this->EventTag, $subQueryOptions, 'Attribute.event_id');\n            $subQueryOptions = array(\n                'conditions' => array(\n                    'tag_id' => $tagIds,\n                ),\n                'fields' => array('attribute_id')\n            );\n            $tempConditions[] = $this->subQueryGenerator($this->AttributeTag, $subQueryOptions, 'Attribute.id');\n        }\n        return $tempConditions;\n    }\n\n    public function filterEventIds($user, &$params = array())\n    {\n        $conditions = $this->createEventConditions($user);\n        if (isset($params['wildcard'])) {\n            $temp = array();\n            $options = array(\n                'filter' => 'wildcard',\n                'scope' => 'Event',\n                'pop' => false,\n                'context' => 'Event'\n            );\n            $conditions['AND'][] = array('OR' => $this->set_filter_wildcard($params, $temp, $options));\n        } else {\n            $simple_params = array(\n                'Event' => array(\n                    'eventid' => array('function' => 'set_filter_eventid', 'pop' => true),\n                    'eventinfo' => array('function' => 'set_filter_eventinfo'),\n                    'ignore' => array('function' => 'set_filter_ignore'),\n                    'tags' => array('function' => 'set_filter_tags'),\n                    'from' => array('function' => 'set_filter_timestamp', 'pop' => true),\n                    'to' => array('function' => 'set_filter_timestamp', 'pop' => true),\n                    'last' => array('function' => 'set_filter_timestamp', 'pop' => true),\n                    'timestamp' => array('function' => 'set_filter_timestamp', 'pop' => true),\n                    'event_timestamp' => array('function' => 'set_filter_timestamp', 'pop' => true),\n                    'publish_timestamp' => array('function' => 'set_filter_timestamp', 'pop' => true),\n                    'org' => array('function' => 'set_filter_org', 'pop' => true),\n                    'uuid' => array('function' => 'set_filter_uuid', 'pop' => true),\n                    'published' => array('function' => 'set_filter_published', 'pop' => true)\n                ),\n                'Object' => array(\n                    'object_name' => array('function' => 'set_filter_object_name'),\n                    'deleted' => array('function' => 'set_filter_deleted')\n                ),\n                'Attribute' => array(\n                    'value' => array('function' => 'set_filter_value', 'pop' => true),\n                    'category' => array('function' => 'set_filter_simple_attribute'),\n                    'type' => array('function' => 'set_filter_simple_attribute'),\n                    'tags' => array('function' => 'set_filter_tags', 'pop' => true),\n                    'ignore' => array('function' => 'set_filter_ignore'),\n                    'uuid' => array('function' => 'set_filter_uuid'),\n                    'deleted' => array('function' => 'set_filter_deleted'),\n                    'to_ids' => array('function' => 'set_filter_to_ids'),\n                    'comment' => array('function' => 'set_filter_comment')\n                )\n            );\n            foreach ($params as $param => $paramData) {\n                foreach ($simple_params as $scope => $simple_param_scoped) {\n                    if (isset($simple_param_scoped[$param]) && $params[$param] !== false) {\n                        $options = array(\n                            'filter' => $param,\n                            'scope' => $scope,\n                            'pop' => !empty($simple_param_scoped[$param]['pop']),\n                            'context' => 'Event'\n                        );\n                        if ($scope === 'Event') {\n                            $conditions = $this->{$simple_param_scoped[$param]['function']}($params, $conditions, $options);\n                        } else {\n                            $temp = array();\n                            $temp = $this->{$simple_param_scoped[$param]['function']}($params, $temp, $options);\n                            if (!empty($temp)) {\n                                $subQueryOptions = array(\n                                    'conditions' => $temp,\n                                    'fields' => array(\n                                        'event_id'\n                                    )\n                                );\n                                $conditions['AND'][] = $this->subQueryGenerator($this->{$scope}, $subQueryOptions, 'Event.id');\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        $fields = array('Event.id');\n        if (!empty($params['include_attribute_count'])) {\n            $fields[] = 'Event.attribute_count';\n        }\n        $find_params = array(\n            'conditions' => $conditions,\n            'recursive' => -1,\n            'fields' => $fields\n        );\n        if (isset($params['limit'])) {\n            $find_params['limit'] = $params['limit'];\n            if (isset($params['page'])) {\n                $find_params['page'] = $params['page'];\n            }\n        }\n        $results = $this->find('list', $find_params);\n        return $results;\n    }\n\n    public function fetchSimpleEventIds($user, $params = array())\n    {\n        $conditions = $this->createEventConditions($user);\n        $conditions['AND'][] = $params['conditions'];\n        $results = array_values($this->find('list', array(\n            'conditions' => $conditions,\n            'recursive' => -1,\n            'fields' => array('Event.id')\n        )));\n        return $results;\n    }\n\n    public function fetchSimpleEvents($user, $params, $includeOrgc = false)\n    {\n        $conditions = $this->createEventConditions($user);\n        $conditions['AND'][] = $params['conditions'];\n        $params = array(\n            'conditions' => $conditions,\n            'recursive' => -1\n        );\n        if ($includeOrgc) {\n            $params['contain'] = array('Orgc.name');\n        }\n        $results = array_values($this->find('all', $params));\n        return $results;\n    }\n\n    public function fetchEventIds($user, $from = false, $to = false, $last = false, $list = false, $timestamp = false, $publish_timestamp = false, $eventIdList = false)\n    {\n        // restricting to non-private or same org if the user is not a site-admin.\n        $conditions = $this->createEventConditions($user);\n        $fields = array('Event.id', 'Event.org_id', 'Event.distribution', 'Event.sharing_group_id');\n\n        if ($from) {\n            $conditions['AND'][] = array('Event.date >=' => $from);\n        }\n        if ($to) {\n            $conditions['AND'][] = array('Event.date <=' => $to);\n        }\n        if ($last) {\n            $conditions['AND'][] = array('Event.publish_timestamp >=' => $last);\n        }\n        if ($timestamp) {\n            $conditions['AND'][] = array('Event.timestamp >=' => $timestamp);\n        }\n        if ($publish_timestamp) {\n            $conditions['AND'][] = array('Event.publish_timestamp >=' => $publish_timestamp);\n        }\n        if ($eventIdList) {\n            $conditions['AND'][] = array('Event.id' => $eventIdList);\n        }\n        if ($list) {\n            $params = array(\n                'conditions' => $conditions,\n                'recursive' => -1,\n            );\n            $results = array_values($this->find('list', $params));\n        } else {\n            $params = array(\n                'conditions' => $conditions,\n                'recursive' => -1,\n                'fields' => $fields,\n            );\n            $results = $this->find('all', $params);\n        }\n        return $results;\n    }\n\n    /*\n     * Unlike the other fetchers, this one foregoes any ACL checks.\n     * the objective is simple: Fetch the given event with all related objects needed for the ZMQ output,\n     * standardising on this function for fetching the event to be passed to the pubsub handler\n     */\n    public function quickFetchEvent($id)\n    {\n        $event = $this->find('first', array(\n            'recursive' => -1,\n            'conditions' => array('Event.id' => $id),\n            'contain' => array(\n                'Orgc' => array(\n                    'fields' => array('Orgc.id', 'Orgc.uuid', 'Orgc.name')\n                ),\n                'EventTag' => array(\n                    'Tag' => array('fields' => array('Tag.id', 'Tag.name', 'Tag.colour', 'Tag.exportable'))\n                )\n            )\n        ));\n        return $event;\n    }\n\n    //Once the data about the user is gathered from the appropriate sources, fetchEvent is called from the controller or background process.\n    // Possible options:\n    // eventid: single event ID\n    // idList: array with event IDs\n    // tags: string with the usual tag syntax\n    // from: date string (YYYY-MM-DD)\n    // to: date string (YYYY-MM-DD)\n    // includeAllTags: true will include the tags that are marked as non-exportable\n    // includeAttachments: true will attach the attachments to the attributes in the data field\n    public function fetchEvent($user, $options = array(), $useCache = false)\n    {\n        if (isset($options['Event.id'])) {\n            $options['eventid'] = $options['Event.id'];\n        }\n        $possibleOptions = array(\n            'eventid',\n            'idList',\n            'tags',\n            'from',\n            'to',\n            'last',\n            'to_ids',\n            'includeAllTags',\n            'withAttachments',\n            'includeAttachments',\n            'event_uuid',\n            'distribution',\n            'sharing_group_id',\n            'disableSiteAdmin',\n            'metadata',\n            'enforceWarninglist',\n            'sgReferenceOnly',\n            'flatten',\n            'blockedAttributeTags',\n            'eventsExtendingUuid',\n            'extended',\n            'excludeGalaxy',\n            'includeRelatedTags'\n        );\n        if (!isset($options['excludeGalaxy']) || !$options['excludeGalaxy']) {\n            $this->GalaxyCluster = ClassRegistry::init('GalaxyCluster');\n        }\n        foreach ($possibleOptions as &$opt) {\n            if (!isset($options[$opt])) {\n                $options[$opt] = false;\n            }\n        }\n        $conditions = $this->createEventConditions($user);\n        if ($options['eventid']) {\n            $conditions['AND'][] = array(\"Event.id\" => $options['eventid']);\n        }\n        if ($options['eventsExtendingUuid']) {\n            if (!is_array($options['eventsExtendingUuid'])) {\n                $options['eventsExtendingUuid'] = array($options['eventsExtendingUuid']);\n            }\n            foreach ($options['eventsExtendingUuid'] as $extendedEvent) {\n                $extendedUuids = array();\n                if (!Validation::uuid($extendedEvent)) {\n                    $eventUuid = $this->find('first', array(\n                        'recursive' => -1,\n                        'conditions' => array('Event.id' => $extendedEvent),\n                        'fields' => array('Event.uuid')\n                    ));\n                    if (!empty($eventUuid)) {\n                        $extendedUuids[] = $eventUuid['Event']['uuid'];\n                    }\n                } else {\n                    $extendedUuids[] = $extendedEvent;\n                }\n            }\n            if (!empty($extendedUuids)) {\n                $conditions['AND'][] = array('Event.extends_uuid' => $extendedUuids);\n            } else {\n                // We've set as a search pattern any event that extends an event and didn't find anything\n                // valid, make sure we don't get everything thrown in our face that the user can see.\n                $conditions['AND'][] = array('Event.id' => -1);\n            }\n        }\n        if (!isset($user['org_id'])) {\n            throw new Exception('There was an error with the user account.');\n        }\n        $isSiteAdmin = $user['Role']['perm_site_admin'];\n        if (isset($options['disableSiteAdmin']) && $options['disableSiteAdmin']) {\n            $isSiteAdmin = false;\n        }\n        $conditionsAttributes = array();\n        $conditionsObjects = array();\n        $conditionsObjectReferences = array();\n\n        if (isset($options['flatten']) && $options['flatten']) {\n            $flatten = true;\n        } else {\n            $flatten = false;\n        }\n        $sgids = $this->cacheSgids($user, $useCache);\n        // restricting to non-private or same org if the user is not a site-admin.\n        if (!$isSiteAdmin) {\n            // if delegations are enabled, check if there is an event that the current user might see because of the request itself\n            if (Configure::read('MISP.delegation')) {\n                $delegatedEventIDs = $this->__cachedelegatedEventIDs($user, $useCache);\n                $conditions['AND']['OR']['Event.id'] = $delegatedEventIDs;\n            }\n            $conditionsAttributes['AND'][0]['OR'] = array(\n                array('AND' => array(\n                    'Attribute.distribution >' => 0,\n                    'Attribute.distribution !=' => 4,\n                )),\n                array('AND' => array(\n                    'Attribute.distribution' => 4,\n                    'Attribute.sharing_group_id' => $sgids,\n                )),\n                '(SELECT events.org_id FROM events WHERE events.id = Attribute.event_id)' => $user['org_id']\n            );\n\n            $conditionsObjects['AND'][0]['OR'] = array(\n                array('AND' => array(\n                    'Object.distribution >' => 0,\n                    'Object.distribution !=' => 4,\n                )),\n                array('AND' => array(\n                    'Object.distribution' => 4,\n                    'Object.sharing_group_id' => $sgids,\n                )),\n                '(SELECT events.org_id FROM events WHERE events.id = Object.event_id)' => $user['org_id']\n            );\n        }\n        if ($options['distribution']) {\n            $conditions['AND'][] = array('Event.distribution' => $options['distribution']);\n            $conditionsAttributes['AND'][] = array('Attribute.distribution' => $options['distribution']);\n            $conditionsObjects['AND'][] = array('Object.distribution' => $options['distribution']);\n        }\n        if ($options['sharing_group_id']) {\n            $conditions['AND'][] = array('Event.sharing_group_id' => $options['sharing_group_id']);\n            $conditionsAttributes['AND'][] = array('Attribute.sharing_group_id' => $options['sharing_group_id']);\n            $conditionsObjects['AND'][] = array('Object.sharing_group_id' => $options['sharing_group_id']);\n        }\n        if ($options['from']) {\n            $conditions['AND'][] = array('Event.date >=' => $options['from']);\n        }\n        if ($options['to']) {\n            $conditions['AND'][] = array('Event.date <=' => $options['to']);\n        }\n        if ($options['last']) {\n            $conditions['AND'][] = array('Event.publish_timestamp >=' => $options['last']);\n        }\n        if ($options['event_uuid']) {\n            $conditions['AND'][] = array('Event.uuid' => $options['event_uuid']);\n        }\n        if (!empty($options['includeRelatedTags'])) {\n            $options['includeGranularCorrelations'] = 1;\n        }\n        if (isset($options['ignore']) && empty($options['ignore'])) {\n            $conditions['AND'][] = array('Event.published' => 1);\n            $conditionsAttributes['AND'][] = array('Attribute.to_ids' => 1);\n        }\n        $softDeletables = array('Attribute', 'Object', 'ObjectReference');\n        if (isset($options['deleted']) && $options['deleted']) {\n            if (!$user['Role']['perm_sync']) {\n                foreach ($softDeletables as $softDeletable) {\n                    ${'conditions' . $softDeletable . 's'}['AND'][] = array(\n                        'OR' => array(\n                            '(SELECT events.org_id FROM events WHERE events.id = ' . $softDeletable . '.event_id)' => $user['org_id'],\n                            $softDeletable . '.deleted LIKE' => 0\n                        )\n                    );\n                }\n            }\n        } else {\n            foreach ($softDeletables as $softDeletable) {\n                ${'conditions' . $softDeletable . 's'}['AND'][$softDeletable . '.deleted LIKE'] = 0;\n            }\n        }\n        if ($options['idList'] && !$options['tags']) {\n            $conditions['AND'][] = array('Event.id' => $options['idList']);\n        }\n        // If we sent any tags along, load the associated tag names for each attribute\n        if ($options['tags']) {\n            $temp = $this->__generateCachedTagFilters($options['tags']);\n            foreach ($temp as $rules) {\n                $conditions['AND'][] = $rules;\n            }\n        }\n\n        if (!empty($options['to_ids']) || $options['to_ids'] === 0) {\n            $conditionsAttributes['AND'][] = array('Attribute.to_ids' => $options['to_ids']);\n        }\n\n        // removing this for now, we export the to_ids == 0 attributes too, since there is a to_ids field indicating it in the .xml\n        // $conditionsAttributes['AND'] = array('Attribute.to_ids =' => 1);\n        // Same idea for the published. Just adjust the tools to check for this\n        // $conditions['AND'][] = array('Event.published =' => 1);\n\n        // do not expose all the data ...\n        $fields = array('Event.id', 'Event.orgc_id', 'Event.org_id', 'Event.date', 'Event.threat_level_id', 'Event.info', 'Event.published', 'Event.uuid', 'Event.attribute_count', 'Event.analysis', 'Event.timestamp', 'Event.distribution', 'Event.proposal_email_lock', 'Event.user_id', 'Event.locked', 'Event.publish_timestamp', 'Event.sharing_group_id', 'Event.disable_correlation', 'Event.extends_uuid');\n        $fieldsAtt = array('Attribute.id', 'Attribute.type', 'Attribute.category', 'Attribute.value', 'Attribute.to_ids', 'Attribute.uuid', 'Attribute.event_id', 'Attribute.distribution', 'Attribute.timestamp', 'Attribute.comment', 'Attribute.sharing_group_id', 'Attribute.deleted', 'Attribute.disable_correlation', 'Attribute.object_id', 'Attribute.object_relation');\n        $fieldsObj = array('*');\n        $fieldsShadowAtt = array('ShadowAttribute.id', 'ShadowAttribute.type', 'ShadowAttribute.category', 'ShadowAttribute.value', 'ShadowAttribute.to_ids', 'ShadowAttribute.uuid', 'ShadowAttribute.event_uuid', 'ShadowAttribute.event_id', 'ShadowAttribute.old_id', 'ShadowAttribute.comment', 'ShadowAttribute.org_id', 'ShadowAttribute.proposal_to_delete', 'ShadowAttribute.timestamp');\n        $fieldsOrg = array('id', 'name', 'uuid');\n        $fieldsServer = array('id', 'url', 'name');\n        if (!$options['includeAllTags']) {\n            $tagConditions = array('exportable' => 1);\n        } else {\n            $tagConditions = array();\n        }\n        $sharingGroupData = $this->__cacheSharingGroupData($user, $useCache);\n        $params = array(\n            'conditions' => $conditions,\n            'recursive' => 0,\n            'fields' => $fields,\n            'contain' => array(\n                'ThreatLevel' => array(\n                        'fields' => array('ThreatLevel.name')\n                ),\n                'Attribute' => array(\n                    'fields' => $fieldsAtt,\n                    'conditions' => $conditionsAttributes,\n                    'AttributeTag' => array(\n                        'Tag' => array('conditions' => $tagConditions, 'order' => false),\n                        'order' => false\n                    ),\n                    'order' => false\n                ),\n                'Object' => array(\n                    'fields' => $fieldsObj,\n                    'conditions' => $conditionsObjects,\n                    'order' => false,\n                    'ObjectReference' => array(\n                        'conditions' => $conditionsObjectReferences,\n                        'order' => false\n                    )\n                ),\n                'ShadowAttribute' => array(\n                    'fields' => $fieldsShadowAtt,\n                    'conditions' => array('deleted' => 0),\n                    'Org' => array('fields' => $fieldsOrg),\n                    'order' => false\n                ),\n                'EventTag' => array(\n                    'Tag' => array('conditions' => $tagConditions, 'order' => false),\n                    'order' => false\n                 )\n            )\n        );\n        if ($flatten) {\n            unset($params['contain']['Object']);\n        }\n        if ($options['metadata']) {\n            unset($params['contain']['Attribute']);\n            unset($params['contain']['ShadowAttribute']);\n        }\n        if ($user['Role']['perm_site_admin']) {\n            $params['contain']['User'] = array('fields' => 'email');\n        }\n        $results = $this->find('all', $params);\n        if (empty($results)) {\n            return array();\n        }\n        // Do some refactoring with the event\n        $this->Sighting = ClassRegistry::init('Sighting');\n        $userEmails = array();\n        $fields = array(\n            'common' => array('distribution', 'sharing_group_id', 'uuid'),\n            'Attribute' => array('value', 'type', 'category', 'to_ids'),\n            'Object' => array('name', 'meta-category')\n        );\n        foreach ($results as $eventKey => &$event) {\n            $this->__attachReferences($user, $event, $sgids, $fields);\n            $event = $this->Orgc->attachOrgsToEvent($event, $fieldsOrg);\n            if (!$options['sgReferenceOnly'] && $event['Event']['sharing_group_id']) {\n                $event['SharingGroup'] = $sharingGroupData[$event['Event']['sharing_group_id']]['SharingGroup'];\n            }\n            // Add information for auditor user\n            if ($event['Event']['orgc_id'] === $user['org_id'] && $user['Role']['perm_audit']) {\n                if (!isset($userEmails[$event['Event']['user_id']])) {\n                    $userEmails[$event['Event']['user_id']] = $this->User->getAuthUser($event['Event']['user_id'])['email'];\n                }\n                $event['Event']['event_creator_email'] = $userEmails[$event['Event']['user_id']];\n            }\n            $event = $this->massageTags($event, 'Event', $options['excludeGalaxy']);\n            // Let's find all the related events and attach it to the event itself\n            $results[$eventKey]['RelatedEvent'] = $this->getRelatedEvents($user, $event['Event']['id'], $sgids);\n            // Let's also find all the relations for the attributes - this won't be in the xml export though\n            if (!empty($options['includeGranularCorrelations'])) {\n                $results[$eventKey]['RelatedAttribute'] = $this->getRelatedAttributes($user, $event['Event']['id'], $sgids);\n                if (!empty($options['includeRelatedTags'])) {\n                    $results[$eventKey] = $this->includeRelatedTags($results[$eventKey], $options);\n                }\n                $results[$eventKey]['RelatedShadowAttribute'] = $this->getRelatedAttributes($user, $event['Event']['id'], $sgids, true);\n            }\n            if (isset($event['ShadowAttribute']) && !empty($event['ShadowAttribute']) && isset($options['includeAttachments']) && $options['includeAttachments']) {\n                foreach ($event['ShadowAttribute'] as $k => $sa) {\n                    if ($this->ShadowAttribute->typeIsAttachment($sa['type'])) {\n                        $encodedFile = $this->ShadowAttribute->base64EncodeAttachment($sa);\n                        $event['ShadowAttribute'][$k]['data'] = $encodedFile;\n                    }\n                }\n            }\n            if (isset($event['Attribute'])) {\n                if ($options['enforceWarninglist']) {\n                    $this->Warninglist = ClassRegistry::init('Warninglist');\n                    $warninglists = $this->Warninglist->fetchForEventView();\n                }\n                if (isset($options['includeFeedCorrelations']) && $options['includeFeedCorrelations']) {\n                    $this->Feed = ClassRegistry::init('Feed');\n                    if (!empty($options['overrideLimit'])) {\n                        $overrideLimit = true;\n                    } else {\n                        $overrideLimit = false;\n                    }\n                    $event['Attribute'] = $this->Feed->attachFeedCorrelations($event['Attribute'], $user, $event['Event'], $overrideLimit);\n                }\n                $event = $this->__filterBlockedAttributesByTags($event, $options, $user);\n                $event['Attribute'] = $this->__attachSharingGroups(!$options['sgReferenceOnly'], $event['Attribute'], $sharingGroupData);\n                foreach ($event['Attribute'] as $key => $attribute) {\n                    if ($options['enforceWarninglist'] && !$this->Warninglist->filterWarninglistAttributes($warninglists, $attribute, $this->Warninglist)) {\n                        unset($event['Attribute'][$key]);\n                        continue;\n                    }\n                    $event['Attribute'][$key] = $this->massageTags($attribute, 'Attribute', $options['excludeGalaxy']);\n                    if ($event['Attribute'][$key]['category'] === 'Financial fraud') {\n                        $event['Attribute'][$key] = $this->Attribute->attachValidationWarnings($event['Attribute'][$key]);\n                    }\n                    if (isset($options['includeAttachments']) && $options['includeAttachments']) {\n                        if ($this->Attribute->typeIsAttachment($attribute['type'])) {\n                            $encodedFile = $this->Attribute->base64EncodeAttachment($attribute);\n                            $event['Attribute'][$key]['data'] = $encodedFile;\n                        }\n                    }\n                    // unset empty attribute tags that got added because the tag wasn't exportable\n                    if (!empty($attribute['AttributeTag'])) {\n                        foreach ($attribute['AttributeTag'] as $atk => $attributeTag) {\n                            if (empty($attributeTag['Tag'])) {\n                                unset($event['Attribute'][$key]['AttributeTag'][$atk]);\n                            }\n                        }\n                        $event['Attribute'][$key]['AttributeTag'] = array_values($event['Attribute'][$key]['AttributeTag']);\n                    }\n                    $event['Attribute'][$key]['ShadowAttribute'] = array();\n                    // If a shadowattribute can be linked to an attribute, link it to it then remove it from the event\n                    // This is to differentiate between proposals that were made to an attribute for modification and between proposals for new attributes\n\n                    if (isset($event['ShadowAttribute'])) {\n                        foreach ($event['ShadowAttribute'] as $k => $sa) {\n                            if (!empty($sa['old_id'])) {\n                                if ($event['ShadowAttribute'][$k]['old_id'] == $attribute['id']) {\n                                    $results[$eventKey]['Attribute'][$key]['ShadowAttribute'][] = $sa;\n                                    unset($results[$eventKey]['ShadowAttribute'][$k]);\n                                }\n                            }\n                        }\n                    }\n                    if (Configure::read('MISP.proposals_block_attributes') && isset($options['to_ids']) && $options['to_ids']) {\n                        foreach ($results[$eventKey]['Attribute'][$key]['ShadowAttribute'] as $sa) {\n                            if ($sa['proposal_to_delete'] || $sa['to_ids'] == 0) {\n                                unset($results[$eventKey]['Attribute'][$key]);\n                                continue;\n                            }\n                        }\n                    }\n                    if (!$flatten && $event['Attribute'][$key]['object_id'] != 0) {\n                        foreach ($event['Object'] as $objectKey => $object) {\n                            if ($object['id'] == $event['Attribute'][$key]['object_id']) {\n                                $event['Object'][$objectKey]['Attribute'][] = $event['Attribute'][$key];\n                                break;\n                            }\n                        }\n                        unset($event['Attribute'][$key]);\n                    }\n                }\n                $event['Attribute'] = array_values($event['Attribute']);\n            }\n            if (!empty($event['Object'])) {\n                $event['Object'] = $this->__attachSharingGroups(!$options['sgReferenceOnly'], $event['Object'], $sharingGroupData);\n                foreach ($event['Object'] as $objectKey => $objectValue) {\n                    if (!empty($event['Object'][$objectKey]['Attribute'])) {\n                        $event['Object'][$objectKey]['Attribute'] = $this->__attachSharingGroups(!$options['sgReferenceOnly'], $event['Object'][$objectKey]['Attribute'], $sharingGroupData);\n                        foreach ($event['Object'][$objectKey]['Attribute'] as $akey => $adata) {\n                            if ($adata['category'] === 'Financial fraud') {\n                                $event['Object'][$objectKey]['Attribute'][$akey] = $this->Attribute->attachValidationWarnings($adata);\n                            }\n                        }\n                    }\n                }\n            }\n            if (!empty($event['ShadowAttribute'])) {\n                if ($isSiteAdmin && isset($options['includeFeedCorrelations']) && $options['includeFeedCorrelations']) {\n                    $this->Feed = ClassRegistry::init('Feed');\n                    if (!empty($options['overrideLimit'])) {\n                        $overrideLimit = true;\n                    } else {\n                        $overrideLimit = false;\n                    }\n                    $event['ShadowAttribute'] = $this->Feed->attachFeedCorrelations($event['ShadowAttribute'], $user, $event['Event'], $overrideLimit);\n                }\n            }\n            $event['Sighting'] = $this->Sighting->attachToEvent($event, $user);\n            // remove proposals to attributes that we cannot see\n            // if the shadow attribute wasn't moved within an attribute before, this is the case\n            if (isset($event['ShadowAttribute'])) {\n                foreach ($event['ShadowAttribute'] as $k => $sa) {\n                    if (!empty($sa['old_id'])) {\n                        unset($event['ShadowAttribute'][$k]);\n                    }\n                }\n                $event['ShadowAttribute'] = array_values($event['ShadowAttribute']);\n            }\n            if ($event['Event']['orgc_id'] === $user['org_id'] && $user['Role']['perm_audit']) {\n                $UserEmail = $this->User->getAuthUser($event['Event']['user_id'])['email'];\n                $event['Event']['event_creator_email'] = $UserEmail;\n            }\n        }\n        if ($options['extended']) {\n            foreach ($results as $k => $result) {\n                $results[$k] = $this->__mergeExtensions($user, $result['Event']['uuid'], $result);\n            }\n        }\n        return $results;\n    }\n\n    private function __cacheRelatedEventTags($eventTagCache, $relatedAttribute)\n    {\n        if (empty($eventTagCache[$relatedAttribute['id']])) {\n            $params = array(\n                'contain' => array(\n                    'Tag' => array(\n                        'fields' => array(\n                            'Tag.id', 'Tag.name', 'Tag.colour', 'Tag.numerical_value'\n                        )\n                    )\n                ),\n                'recursive' => -1,\n                'conditions' => array(\n                    'EventTag.event_id' => $relatedAttribute['id']\n                )\n            );\n            $eventTags = $this->EventTag->find('all', $params);\n            if (!empty($eventTags)) {\n                foreach ($eventTags as $et) {\n                    if (!isset($eventTagCache[$relatedAttribute['id']][$et['Tag']['id']])) {\n                        $eventTagCache[$relatedAttribute['id']][$et['Tag']['id']] = $et['Tag'];\n                    }\n                }\n            }\n        }\n        return $eventTagCache;\n    }\n\n    public function includeRelatedTags($event, $options)\n    {\n        $eventTagCache = array();\n        $tags = array();\n        $includeAllTags = !empty($options['includeAllTags']);\n        foreach ($event['RelatedAttribute'] as $attributeId => $relatedAttributes) {\n            $attributePos = false;\n            foreach ($event['Attribute'] as $k => $attribute) {\n                if ($attribute['id'] == $attributeId) {\n                    $attributePos = $k;\n                    break;\n                }\n            }\n            foreach ($relatedAttributes as $relatedAttribute) {\n                $eventTagCache = $this->__cacheRelatedEventTags($eventTagCache, $relatedAttribute);\n                if (!empty($eventTagCache[$relatedAttribute['id']])) {\n                    if (!isset($event['Attribute'][$attributePos]['RelatedTags'])) {\n                        $event['Attribute'][$attributePos]['RelatedTags'] = array();\n                    }\n                    $event['Attribute'][$attributePos]['RelatedTags'] = array_merge($event['Attribute'][$attributePos]['RelatedTags'], $eventTagCache[$relatedAttribute['id']]);\n                }\n                $params = array(\n                    'contain' => array(\n                        'Tag' => array(\n                            'fields' => array(\n                                'Tag.id', 'Tag.name', 'Tag.colour', 'Tag.numerical_value'\n                            )\n                        )\n                    ),\n                    'recursive' => -1,\n                    'conditions' => array(\n                        'AttributeTag.attribute_id' => $relatedAttribute['attribute_id']\n                    )\n                );\n                $attributeTags = $this->Attribute->AttributeTag->find('all', $params);\n                if (!empty($attributeTags)) {\n                    foreach ($attributeTags as $at) {\n                        $event['Attribute'][$attributePos]['RelatedTags'][$at['Tag']['id']] = $at['Tag'];\n                    }\n                }\n            }\n        }\n        return $event;\n    }\n\n    private function __mergeExtensions($user, $uuid, $event)\n    {\n        $extensions = $this->fetchEvent($user, array('eventsExtendingUuid' => $uuid));\n        $thingsToMerge = array('Attribute', 'Object', 'ShadowAttribute', 'EventTag', 'Galaxy', 'RelatedEvent');\n        foreach ($extensions as $k2 => $extensionEvent) {\n            $eventMeta = array(\n                'id' => $extensionEvent['Event']['id'],\n                'info' => $extensionEvent['Event']['info'],\n                'Orgc' => array(\n                    'id' => $extensionEvent['Orgc']['id'],\n                    'name' => $extensionEvent['Orgc']['name'],\n                    'uuid' => $extensionEvent['Orgc']['uuid']\n                )\n            );\n            $event['Event']['extensionEvents'][$eventMeta['id']] = $eventMeta;\n            foreach ($thingsToMerge as $thingToMerge) {\n                $event[$thingToMerge] = array_merge($event[$thingToMerge], $extensionEvent[$thingToMerge]);\n            }\n        }\n        return $event;\n    }\n\n    private function __attachSharingGroups($doAttach, $data, $sharingGroupData)\n    {\n        if (!$doAttach) {\n            return $data;\n        }\n        foreach ($data as $k => $v) {\n            if ($v['distribution'] == 4) {\n                $data[$k]['SharingGroup'] = $sharingGroupData[$v['sharing_group_id']]['SharingGroup'];\n            }\n        }\n        return $data;\n    }\n\n    // Filter the attributes within an event based on the tag filter block rules\n    private function __filterBlockedAttributesByTags($event, $options, $user)\n    {\n        if (!empty($options['blockedAttributeTags'])) {\n            foreach ($options['blockedAttributeTags'] as $key => $blockedTag) {\n                if (!is_numeric($blockedTag)) {\n                    $options['blockedAttributeTags'][$key] = $this->EventTag->Tag->lookupTagIdFromName($blockedTag);\n                } else {\n                    $options['blockedAttributeTags'][$key] = $blockedTag;\n                }\n            }\n        }\n        if (!empty($user['Server']['push_rules'])) {\n            $push_rules = json_decode($user['Server']['push_rules'], true);\n            if (!empty($push_rules['tags']['NOT'])) {\n                if (empty($options['blockedAttributeTags'])) {\n                    $options['blockedAttributeTags'] = array();\n                }\n                $options['blockedAttributeTags'] = array_merge($options['blockedAttributeTags'], $push_rules['tags']['NOT']);\n            }\n        }\n        if (!empty($options['blockedAttributeTags'])) {\n            if (!empty($event['Attribute'])) {\n                $event['Attribute'] = $this->__filterBlockedAttributesFromContainer($event['Attribute'], $options['blockedAttributeTags']);\n            }\n        }\n        return $event;\n    }\n\n    // accepts an attribute array and a list of blocked tags. Returns the attribute array with the blocked attributes cleaned out.\n    private function __filterBlockedAttributesFromContainer($container, $blockedTags)\n    {\n        foreach ($container as $key => $attribute) {\n            if (!empty($attribute['AttributeTag'])) {\n                foreach ($attribute['AttributeTag'] as $at) {\n                    if (in_array($at['tag_id'], $blockedTags)) {\n                        unset($container[$key]);\n                    }\n                }\n            }\n        }\n        $container = array_values($container);\n        return $container;\n    }\n\n    private function __escapeCSVField(&$field)\n    {\n        $field = str_replace(array('\"'), '\"\"', $field);\n        $field = '\"' . $field . '\"';\n    }\n\n    public function set_filter_org(&$params, $conditions, $options)\n    {\n        if (!empty($params['org'])) {\n            $params['org'] = $this->convert_filters($params['org']);\n            if (!empty($params['org']['OR'])) {\n                foreach ($params['org']['OR'] as $k => $org) {\n                    if (!is_numeric($org)) {\n                        $existingOrg = $this->Orgc->find('first', array(\n                            'recursive' => -1,\n                            'conditions' => array('Orgc.name' => $org),\n                            'fields' => array('Orgc.name', 'Orgc.id')\n                        ));\n                        if (empty($existingOrg)) {\n                            $params['org']['OR'][$k] = -1;\n                        } else {\n                            $params['org']['OR'][$k] = $existingOrg['Orgc']['id'];\n                        }\n                    }\n                }\n            }\n            if (!empty($params['org']['NOT'])) {\n                $temp = array();\n                foreach ($params['org']['NOT'] as $org) {\n                    if (!is_numeric($org)) {\n                        $existingOrg = $this->Orgc->find('first', array(\n                            'recursive' => -1,\n                            'conditions' => array('Orgc.name' => $org),\n                            'fields' => array('Orgc.name', 'Orgc.id')\n                        ));\n                        if (!empty($existingOrg)) {\n                            $temp[] = $existingOrg['Orgc']['id'];\n                        }\n                    } else {\n                        $temp[] = $org;\n                    }\n                }\n                if (!empty($temp)) {\n                    $params['org']['NOT'] = $temp;\n                } else {\n                    unset($params['org']['NOT']);\n                }\n            }\n            $conditions = $this->generic_add_filter($conditions, $params['org'], 'Event.orgc_id');\n        }\n        return $conditions;\n    }\n\n    public function set_filter_eventid(&$params, $conditions, $options)\n    {\n        if (!empty($params['eventid']) && $params['eventid'] !== 'all') {\n            $params['eventid'] = $this->convert_filters($params['eventid']);\n            $conditions = $this->generic_add_filter($conditions, $params['eventid'], 'Event.id');\n        }\n        return $conditions;\n    }\n\n    public function set_filter_eventinfo(&$params, $conditions, $options)\n    {\n        if (!empty($params['eventinfo'])) {\n            $params['eventinfo'] = $this->convert_filters($params['eventinfo']);\n            $conditions = $this->generic_add_filter($conditions, $params['eventinfo'], 'Event.info');\n        }\n        return $conditions;\n    }\n\n    public function set_filter_uuid(&$params, $conditions, $options)\n    {\n        if (!empty($params['uuid'])) {\n            $params['uuid'] = $this->convert_filters($params['uuid']);\n            if (!empty($options['scope']) || $options['scope'] === 'Event') {\n                $conditions = $this->generic_add_filter($conditions, $params['uuid'], 'Event.uuid');\n            }\n            if (!empty($options['scope']) || $options['scope'] === 'Attribute') {\n                $conditions = $this->generic_add_filter($conditions, $params['uuid'], 'Attribute.uuid');\n            }\n        }\n        return $conditions;\n    }\n\n    public function set_filter_deleted(&$params, $conditions, $options)\n    {\n        if (!empty($params['deleted'])) {\n            if (empty($options['scope'])) {\n                $scope = 'Attribute';\n            } else {\n                $scope = $options['scope'];\n            }\n            if ($params['deleted']) {\n                $conditions = $this->generic_add_filter($conditions, $params['deleted'], $scope . '.deleted');\n            }\n        }\n        return $conditions;\n    }\n\n    public function set_filter_to_ids(&$params, $conditions, $options)\n    {\n        if (isset($params['to_ids'])) {\n            if ($params['to_ids'] === 'exclude') {\n                $params['to_ids'] = 0;\n            }\n            $conditions['AND']['Attribute.to_ids'] = $params['to_ids'];\n        }\n        return $conditions;\n    }\n\n    public function set_filter_ignore(&$params, $conditions, $options)\n    {\n        if (empty($params['ignore'])) {\n            if (empty($options['scope'])) {\n                $scope = 'Attribute';\n            } else {\n                $scope = $options['scope'];\n            }\n            if ($scope === 'Attribute') {\n                $conditions['AND']['Attribute.to_ids'] = 1;\n            } else {\n                $conditions['AND']['Event.published'] = 1;\n            }\n        }\n        return $conditions;\n    }\n\n    public function set_filter_published(&$params, $conditions, $options)\n    {\n        if (isset($params['published'])) {\n            $conditions['AND']['Event.published'] = $params['published'];\n        }\n        return $conditions;\n    }\n\n    public function set_filter_tags(&$params, $conditions, $options)\n    {\n        if (!empty($params['tags'])) {\n            $conditions = $this->Attribute->set_filter_tags($params, $conditions, $options);\n        }\n        return $conditions;\n    }\n\n    public function set_filter_simple_attribute(&$params, $conditions, $options)\n    {\n        if (!empty($params[$options['filter']])) {\n            $params[$options['filter']] = $this->convert_filters($params[$options['filter']]);\n            $conditions = $this->generic_add_filter($conditions, $params[$options['filter']], 'Attribute.' . $options['filter']);\n        }\n        return $conditions;\n    }\n\n    public function set_filter_attribute_id(&$params, $conditions, $options)\n    {\n        if (!empty($params[$options['filter']])) {\n            $params[$options['filter']] = $this->convert_filters($params[$options['filter']]);\n            $conditions = $this->generic_add_filter($conditions, $params[$options['filter']], 'Attribute.' . $options['filter']);\n        }\n        return $conditions;\n    }\n\n    public function set_filter_value(&$params, $conditions, $options)\n    {\n        if (!empty($params['value'])) {\n            $params[$options['filter']] = $this->convert_filters($params[$options['filter']]);\n            $conditions = $this->generic_add_filter($conditions, $params[$options['filter']], array('Attribute.value1', 'Attribute.value2'));\n        }\n        return $conditions;\n    }\n\n    public function set_filter_comment(&$params, $conditions, $options)\n    {\n        if (!empty($params['comment'])) {\n            $params['comment'] = $this->convert_filters($params['comment']);\n            $conditions = $this->generic_add_filter($conditions, $params['comment'], 'Attribute.comment');\n        }\n        return $conditions;\n    }\n\n    public function set_filter_timestamp(&$params, $conditions, $options)\n    {\n        if ($options['filter'] == 'from') {\n            $conditions['AND']['Event.date >='] = $params['from'];\n        } elseif ($options['filter'] == 'to') {\n            $conditions['AND']['Event.date <='] = $params['to'];\n        } else {\n            if (empty($options['scope'])) {\n                $scope = 'Attribute';\n            } else {\n                $scope = $options['scope'];\n            }\n            $filters = array(\n                'timestamp' => array(\n                    $scope . '.timestamp'\n                ),\n                'publish_timestamp' => array(\n                    'Event.publish_timestamp'\n                ),\n                'last' => array(\n                    'Event.publish_timestamp'\n                ),\n                'event_timestamp' => array(\n                    'Event.timestamp'\n                )\n            );\n            foreach ($filters[$options['filter']] as $f) {\n                $conditions = $this->Attribute->setTimestampConditions($params[$options['filter']], $conditions, $f);\n            }\n        }\n        return $conditions;\n    }\n\n    public function csv($user, $params, $search = false, &$continue = true)\n    {\n        $conditions = array();\n        $simple_params = array(\n            'eventid' => array('function' => 'set_filter_eventid'),\n            'ignore' => array('function' => 'set_filter_ignore'),\n            'tags' => array('function' => 'set_filter_tags'),\n            'category' => array('function' => 'set_filter_simple_attribute'),\n            'type' => array('function' => 'set_filter_simple_attribute'),\n            'from' => array('function' => 'set_filter_timestamp'),\n            'to' => array('function' => 'set_filter_timestamp'),\n            'last' => array('function' => 'set_filter_timestamp'),\n            'value' => array('function' => 'set_filter_value'),\n            'timestamp' => array('function' => 'set_filter_timestamp'),\n            'attributeIDList' => array('functon' => 'set_filter_attribute_id')\n        );\n        foreach ($params as $param => $paramData) {\n            if (isset($simple_params[$param]) && $params[$param] !== false) {\n                $options = array(\n                    'filter' => $param,\n                    'scope' => 'Event',\n                    'pop' => !empty($simple_param_scoped[$param]['pop'])\n                );\n                $conditions = $this->{$simple_params[$param]['function']}($params, $conditions, $options);\n            }\n        }\n        //$attributeIDList = array(), $includeContext = false, $enforceWarninglist = false\n        $this->recursive = -1;\n        if (!empty($params['eventid']) && $params['eventid'] === 'search') {\n            foreach ($params['attributeIDList'] as $aID) {\n                $conditions['AND']['OR'][] = array('Attribute.id' => $aID);\n            }\n        }\n        $csv_params = array(\n                'conditions' => $conditions, //array of conditions\n                'fields' => array('Attribute.event_id', 'Attribute.distribution', 'Attribute.category', 'Attribute.type', 'Attribute.value', 'Attribute.comment', 'Attribute.uuid', 'Attribute.to_ids', 'Attribute.timestamp', 'Attribute.id', 'Attribute.object_relation'),\n                'order' => array('Attribute.uuid ASC'),\n                'flatten' => true\n        );\n\n        // copy over the parameters that have to deal with pagination or additional functionality to be executed\n        $control_params = array(\n            'limit', 'page', 'enforceWarninglist'\n        );\n        foreach ($control_params as $control_param) {\n            if (!empty($params[$control_param])) {\n                $csv_params[$control_param] = $params[$control_param];\n            }\n        }\n        $csv_params = $this->__appendIncludesCSV($csv_params, !empty($params['includeContext']));\n        $attributes = $this->Attribute->fetchAttributes($user, $csv_params, $continue);\n        $attributes = $this->__sanitiseCSVAttributes($attributes, !empty($params['includeContext']), !empty($params['ignore']));\n        return $attributes;\n    }\n\n    private function __appendIncludesCSV($params, $includeContext)\n    {\n        if ($includeContext) {\n            $params['contain'] = array(\n                'Event' => array(\n                        'fields' => array('id', 'info', 'org_id', 'orgc_id', 'date', 'distribution', 'analysis'),\n                        'SharingGroup' => array('fields' => array('id', 'name')),\n                        'Org' => array('id', 'name'),\n                        'Orgc' => array('id', 'name'),\n                        'ThreatLevel' => array(\n                                'fields' => array('id', 'name'),\n                        ),\n                        'EventTag' => array(\n                                'Tag' => array(\n                                        'fields' => array('id', 'name')\n                                )\n                        )\n                ),\n            );\n        }\n        $params['contain']['Object'] = array('fields' => array('id', 'uuid', 'name', 'meta-category'));\n        return $params;\n    }\n\n    private function __sanitiseCSVAttributes($attributes, $includeContext, $ignore)\n    {\n        if (!empty($ignore)) {\n            $this->Whitelist = ClassRegistry::init('Whitelist');\n            $attributes = $this->Whitelist->removeWhitelistedFromArray($attributes, true);\n        }\n        foreach ($attributes as &$attribute) {\n            $this->__escapeCSVField($attribute['Attribute']['value']);\n            $this->__escapeCSVField($attribute['Attribute']['comment']);\n            $this->__escapeCSVField($attribute['Attribute']['object_relation']);\n            $this->__escapeCSVField($attribute['Attribute']['uuid']);\n            $this->__escapeCSVField($attribute['Attribute']['category']);\n            $this->__escapeCSVField($attribute['Attribute']['type']);\n            $attribute['Attribute']['timestamp'] = date('Ymd', $attribute['Attribute']['timestamp']);\n            if (empty($attribute['Object'])) {\n                $attribute['Object']['uuid'] = '\"\"';\n                $attribute['Object']['name'] = '';\n                $attribute['Object']['meta-category'] = '';\n            }\n            $this->__escapeCSVField($attribute['Object']['name']);\n            $this->__escapeCSVField($attribute['Object']['uuid']);\n            $this->__escapeCSVField($attribute['Object']['meta-category']);\n            if ($includeContext) {\n                $this->__escapeCSVField($attribute['Event']['info']);\n                $this->__escapeCSVField($attribute['Event']['uuid']);\n                $this->__escapeCSVField($attribute['Org']['name']);\n                $this->__escapeCSVField($attribute['Orgc']['name']);\n                $attribute['Event']['Tag']['name'] = '';\n                $attribute['attribute_tag'] = '';\n                if (!empty($attribute['AttributeTag'])) {\n                    $tags = array();\n                    foreach ($attribute['AttributeTag'] as $attributeTag) {\n                        if (!empty($attributeTag['Tag']['name'])) {\n                            $tags[] = $attributeTag['Tag']['name'];\n                        }\n                    }\n                    $attribute['Attribute']['attribute_tag'] = implode(',', $tags);\n                }\n                $this->__escapeCSVField($attribute['Attribute']['attribute_tag']);\n                if (!empty($attribute['Event']['EventTag'])) {\n                    $tags = array();\n                    foreach ($attribute['Event']['EventTag'] as $eventTag) {\n                        if (!empty($eventTag['Tag']['name'])) {\n                            $tags[] = $eventTag['Tag']['name'];\n                        }\n                    }\n                    $attribute['Event']['Tag']['name'] = implode(',', $tags);\n                }\n                $this->__escapeCSVField($attribute['Event']['Tag']['name']);\n            }\n        }\n        return $attributes;\n    }\n\n    public function sendAlertEmailRouter($id, $user, $oldpublish = null)\n    {\n        if (Configure::read('MISP.block_old_event_alert') && Configure::read('MISP.block_old_event_alert_age') && is_numeric(Configure::read('MISP.block_old_event_alert_age'))) {\n            $oldest = time() - (Configure::read('MISP.block_old_event_alert_age') * 86400);\n            $event = $this->find('first', array(\n                    'conditions' => array('Event.id' => $id),\n                    'recursive' => -1,\n                    'fields' => array('Event.date')\n            ));\n            if (empty($event)) {\n                return false;\n            }\n            if (strtotime($event['Event']['date']) < $oldest) {\n                return true;\n            }\n        }\n        if (Configure::read('MISP.block_event_alert') && Configure::read('MISP.block_event_alert_tag') && !empty(Configure::read('MISP.block_event_alert_tag'))) {\n            $noAlertTag = Configure::read('MISP.block_event_alert_tag');\n            $tagLen = strlen($noAlertTag);\n            $event = $this->fetchEvent($user, array('eventid' => $id, 'includeAllTags' => true));\n            if (empty($event)) {\n                return false;\n            }\n            foreach ($event[0]['EventTag'] as $k => $tag) {\n                if (strcasecmp($noAlertTag, $tag['Tag']['name']) == 0) {\n                    return true;\n                }\n            }\n        }\n        if (Configure::read('MISP.disable_emailing')) {\n            $this->Log = ClassRegistry::init('Log');\n            $this->Log->create();\n            $this->Log->save(array(\n                    'org' => 'SYSTEM',\n                    'model' => 'Event',\n                    'model_id' => $id,\n                    'email' => $user['email'],\n                    'action' => 'publish',\n                    'title' => 'E-mail alerts not sent out during publishing. Reason: Emailing is currently disabled on this instance.',\n                    'change' => null,\n            ));\n            return true;\n        }\n        if (Configure::read('MISP.background_jobs')) {\n            $job = ClassRegistry::init('Job');\n            $job->create();\n            $data = array(\n                    'worker' => 'email',\n                    'job_type' => 'publish_alert_email',\n                    'job_input' => 'Event: ' . $id,\n                    'status' => 0,\n                    'retries' => 0,\n                    'org_id' => $user['org_id'],\n                    'org' => $user['Organisation']['name'],\n                    'message' => 'Sending...',\n            );\n            $job->save($data);\n            $jobId = $job->id;\n            $process_id = CakeResque::enqueue(\n                    'email',\n                    'EventShell',\n                    array('alertemail', $user['id'], $jobId, $id, $oldpublish),\n                    true\n            );\n            $job->saveField('process_id', $process_id);\n            return true;\n        } else {\n            return ($this->sendAlertEmail($id, $user, $oldpublish));\n        }\n    }\n\n    public function sendAlertEmail($id, $senderUser, $oldpublish = null, $processId = null)\n    {\n        $event = $this->fetchEvent($senderUser, array('eventid' => $id, 'includeAllTags' => true));\n        if (empty($event)) {\n            throw new MethodNotFoundException('Invalid Event.');\n        }\n        $userConditions = array('autoalert' => 1);\n        $this->User = ClassRegistry::init('User');\n        $users = $this->User->getUsersWithAccess(\n            $owners = array(\n                $event[0]['Event']['orgc_id'],\n                $event[0]['Event']['org_id']\n            ),\n            $event[0]['Event']['distribution'],\n            $event[0]['Event']['sharing_group_id'],\n            $userConditions\n        );\n        if (Configure::read('MISP.extended_alert_subject')) {\n            $subject = preg_replace(\"/\\r|\\n/\", \"\", $event[0]['Event']['info']);\n            if (strlen($subject) > 58) {\n                $subject = substr($subject, 0, 55) . '... - ';\n            } else {\n                $subject .= \" - \";\n            }\n        } else {\n            $subject = '';\n        }\n        $subjMarkingString = !empty(Configure::read('MISP.email_subject_TLP_string')) ? Configure::read('MISP.email_subject_TLP_string') : \"tlp:amber\";\n        $subjTag = !empty(Configure::read('MISP.email_subject_tag')) ? Configure::read('MISP.email_subject_tag') : \"tlp\";\n        $tagLen = strlen($subjTag);\n        foreach ($event[0]['EventTag'] as $k => $tag) {\n            $tagName=$tag['Tag']['name'];\n            if (strncasecmp($subjTag, $tagName, $tagLen) == 0 && strlen($tagName) > $tagLen && ($tagName[$tagLen] == ':' || $tagName[$tagLen] == '=')) {\n                if (Configure::read('MISP.email_subject_include_tag_name') === false) {\n                    $subjMarkingString = trim(substr($tagName, $tagLen+1), '\"');\n                } else {\n                    $subjMarkingString = $tagName;\n                }\n                break;\n            }\n        }\n        $threatLevel = $event[0]['ThreatLevel']['name'] . \" - \";\n        if (Configure::read('MISP.threatlevel_in_email_subject') === false) {\n            $threatLevel = '';\n        }\n        $subject = \"[\" . Configure::read('MISP.org') . \" MISP] Event \" . $id . \" - \" . $subject . $threatLevel . $subjMarkingString;\n\n        // Initialise the Job class if we have a background process ID\n        // This will keep updating the process's progress bar\n        if ($processId) {\n            $this->Job = ClassRegistry::init('Job');\n        }\n        $sgModel = ClassRegistry::init('SharingGroup');\n\n        $userCount = count($users);\n        foreach ($users as $k => $user) {\n            $body = $this->__buildAlertEmailBody($event[0], $user, $oldpublish, $sgModel);\n            $bodyNoEnc = \"A new or modified event was just published on \" . Configure::read('MISP.baseurl') . \"/events/view/\" . $event[0]['Event']['id'];\n            $this->User->sendEmail(array('User' => $user), $body, $bodyNoEnc, $subject);\n            if ($processId) {\n                $this->Job->id = $processId;\n                $this->Job->saveField('progress', $k / $userCount * 100);\n            }\n        }\n\n        if ($processId) {\n            $this->Job->saveField('message', 'Mails sent.');\n        }\n        return true;\n    }\n\n    private function __buildAlertEmailObject($user, &$body, &$bodyTempOther, $objects, $owner, $oldpublish)\n    {\n        foreach ($objects as $object) {\n            if (!$owner && $object['distribution'] == 0) {\n                continue;\n            }\n            if ($object['distribution'] == 4 && !$this->SharingGroup->checkIfAuthorised($user, $object['sharing_group_id'])) {\n                continue;\n            }\n            if (isset($oldpublish) && isset($object['timestamp']) && $object['timestamp'] > $oldpublish) {\n                $body .= '* ';\n            } else {\n                $body .= '  ';\n            }\n            $body .= $object['name'] . '/' . $object['meta-category'] . \"\\n\";\n            if (!empty($object['Attribute'])) {\n                $body .= $this->__buildAlertEmailAttribute($user, $body, $bodyTempOther, $object['Attribute'], $owner, $oldpublish, '    ');\n            }\n        }\n    }\n\n    private function __buildAlertEmailAttribute($user, &$body, &$bodyTempOther, $attributes, $owner, $oldpublish, $indent = '  ')\n    {\n        $appendlen = 20;\n        foreach ($attributes as $attribute) {\n            if (!$owner && $attribute['distribution'] == 0) {\n                continue;\n            }\n            if ($attribute['distribution'] == 4 && !$this->SharingGroup->checkIfAuthorised($user, $attribute['sharing_group_id'])) {\n                continue;\n            }\n            $ids = '';\n            if ($attribute['to_ids']) {\n                $ids = ' (IDS)';\n            }\n            $strRepeatCount = $appendlen - 2 - strlen($attribute['type']);\n            $strRepeat = ($strRepeatCount > 0) ? str_repeat(' ', $strRepeatCount) : '';\n            if (isset($oldpublish) && isset($attribute['timestamp']) && $attribute['timestamp'] > $oldpublish) {\n                $line = '* ' . $indent . $attribute['category'] . '/' . $attribute['type'] . $strRepeat . ': ' . $attribute['value'] . $ids . \" *\\n\";\n            } else {\n                $line = $indent . $attribute['category'] . '/' . $attribute['type'] . $strRepeat . ': ' . $attribute['value'] . $ids .  \"\\n\";\n            }\n            // Defanging URLs (Not \"links\") emails domains/ips in notification emails\n            if ('url' == $attribute['type'] || 'uri' == $attribute['type']) {\n                $line = str_ireplace(\"http\", \"hxxp\", $line);\n                $line = str_ireplace(\".\", \"[.]\", $line);\n            } elseif (in_array($attribute['type'], array('email-src', 'email-dst', 'whois-registrant-email', 'dns-soa-email', 'email-reply-to'))) {\n                $line = str_replace(\"@\", \"[at]\", $line);\n            } elseif (in_array($attribute['type'], array('hostname', 'domain', 'ip-src', 'ip-dst', 'domain|ip'))) {\n                $line = str_replace(\".\", \"[.]\", $line);\n            }\n            if (!empty($attribute['AttributeTag'])) {\n                $line .= '  - Tags: ';\n                foreach ($attribute['AttributeTag'] as $k => $aT) {\n                    if ($k > 0) {\n                        $line .= ', ';\n                    }\n                    $line .= $aT['Tag']['name'];\n                }\n                $line .= \"\\n\";\n            }\n            if ('other' == $attribute['type']) { // append the 'other' attribute types to the bottom.\n                $bodyTempOther .= $line;\n            } else {\n                $body .= $line;\n            }\n        }\n    }\n\n    private function __buildAlertEmailBody($event, $user, $oldpublish, $sgModel)\n    {\n        $owner = false;\n        if ($user['org_id'] == $event['Event']['orgc_id'] || $user['org_id'] == $event['Event']['org_id'] || $user['Role']['perm_site_admin']) {\n            $owner = true;\n        }\n        // The mail body, h() is NOT needed as we are sending plain-text mails.\n        $body = \"\";\n        $body .= '==============================================' . \"\\n\";\n        $appendlen = 20;\n        $body .= 'URL         : ' . Configure::read('MISP.baseurl') . '/events/view/' . $event['Event']['id'] . \"\\n\";\n        $body .= 'Event ID    : ' . $event['Event']['id'] . \"\\n\";\n        $body .= 'Date        : ' . $event['Event']['date'] . \"\\n\";\n        if (Configure::read('MISP.showorg')) {\n            $body .= 'Reported by : ' . $event['Orgc']['name'] . \"\\n\";\n            $body .= 'Local owner of the event : ' . $event['Org']['name'] . \"\\n\";\n        }\n        $body .= 'Distribution: ' . $this->distributionLevels[$event['Event']['distribution']] . \"\\n\";\n        if ($event['Event']['distribution'] == 4) {\n            $body .= 'Sharing Group:' . $event['SharingGroup']['name'] . \"\\n\";\n        }\n        $tags = \"\";\n        foreach ($event['EventTag'] as $k => $tag) {\n            $tags .= $tag['Tag']['name'];\n            if (($k+1) != count($event['EventTag'])) {\n                $tags .= \", \";\n            }\n        }\n        $body .= 'Tags: ' . $tags . \"\\n\";\n        $body .= 'Threat Level: ' . $event['ThreatLevel']['name'] . \"\\n\";\n        $body .= 'Analysis    : ' . $this->analysisLevels[$event['Event']['analysis']] . \"\\n\";\n        $body .= 'Description : ' . $event['Event']['info'] . \"\\n\";\n        $relatedEvents = $this->getRelatedEvents($user, $event['Event']['id'], array());\n        if (!empty($relatedEvents)) {\n            $body .= '==============================================' . \"\\n\";\n            $body .= 'Related to: '. \"\\n\";\n            foreach ($relatedEvents as &$relatedEvent) {\n                $body .= Configure::read('MISP.baseurl') . '/events/view/' . $relatedEvent['Event']['id'] . ' (' . $relatedEvent['Event']['date'] . ') ' .\"\\n\";\n            }\n            $body .= '==============================================' . \"\\n\";\n        }\n        $bodyTempOther = \"\";\n        if (!empty($event['Attribute'])) {\n            $body .= 'Attributes (* indicates a new or modified attribute):' . \"\\n\";\n            $this->__buildAlertEmailAttribute($user, $body, $bodyTempOther, $event['Attribute'], $owner, $oldpublish);\n        }\n        if (!empty($event['Object'])) {\n            $body .= 'Objects (* indicates a new or modified object):' . \"\\n\";\n            $this->__buildAlertEmailObject($user, $body, $bodyTempOther, $event['Object'], $owner, $oldpublish);\n        }\n        if (!empty($bodyTempOther)) {\n            $body .= \"\\n\";\n        }\n        $body .= $bodyTempOther;\t// append the 'other' attribute types to the bottom.\n        $body .= '==============================================' . \"\\n\";\n        return $body;\n    }\n\n    public function sendContactEmail($id, $message, $creator_only, $user, $isSiteAdmin)\n    {\n        // fetch the event\n        $event = $this->read(null, $id);\n        $this->User = ClassRegistry::init('User');\n        if (!$creator_only) {\n            // Insert extra field here: alertOrg or something, then foreach all the org members\n            // limit this array to users with contactalerts turned on!\n            $orgMembers = array();\n            $this->User->recursive = 0;\n            $temp = $this->User->find('all', array(\n                    'fields' => array('email', 'gpgkey', 'certif_public', 'contactalert', 'id', 'org_id'),\n                    'conditions' => array('disabled' => 0, 'User.org_id' => $event['Event']['orgc_id']),\n                    'recursive' => -1\n            ));\n            if (empty($temp)) {\n                $temp = $this->User->find('all', array(\n                        'fields' => array('email', 'gpgkey', 'certif_public', 'contactalert', 'id', 'org_id'),\n                        'conditions' => array('disabled' => 0, 'User.org_id' => $event['Event']['org_id']),\n                        'recursive' => -1\n                ));\n            }\n            foreach ($temp as $tempElement) {\n                if ($tempElement['User']['contactalert'] || $tempElement['User']['id'] == $event['Event']['user_id']) {\n                    array_push($orgMembers, $tempElement);\n                }\n            }\n        } else {\n            $temp = $this->User->find('first', array(\n                    'conditions' => array('User.id' => $event['Event']['user_id'], 'User.disabled' => 0),\n                    'fields' => array('User.email', 'User.gpgkey', 'User.certif_public'),\n            ));\n            if (!empty($temp)) {\n                $orgMembers = array(0 => $temp);\n            }\n        }\n        if (empty($orgMembers)) {\n            return false;\n        }\n        $temp = $this->__buildContactEventEmailBody($user, $message, $event, $targetUser, $id);\n        $bodyevent = $temp[0];\n        $body = $temp[1];\n        $result = true;\n        $tplColorString = !empty(Configure::read('MISP.email_subject_TLP_string')) ? Configure::read('MISP.email_subject_TLP_string') : \"TLP Amber\";\n        foreach ($orgMembers as &$reporter) {\n            $subject = \"[\" . Configure::read('MISP.org') . \" MISP] Need info about event \" . $id . \" - \".$tplColorString;\n            $result = $this->User->sendEmail($reporter, $bodyevent, $body, $subject, $user) && $result;\n        }\n        return $result;\n    }\n\n    private function __buildContactEventEmailBody($user, $message, $event, $targetUser, $id)\n    {\n        // The mail body, h() is NOT needed as we are sending plain-text mails.\n        $body = \"\";\n        $body .= \"Hello, \\n\";\n        $body .= \"\\n\";\n        $body .= \"Someone wants to get in touch with you concerning a MISP event. \\n\";\n        $body .= \"\\n\";\n        $body .= \"You can reach him at \" . $user['User']['email'] . \"\\n\";\n        if (!$user['User']['gpgkey']) {\n            $body .= \"His GnuPG key is added as attachment to this email. \\n\";\n        }\n        if (!$user['User']['certif_public']) {\n            $body .= \"His Public certificate is added as attachment to this email. \\n\";\n        }\n        $body .= \"\\n\";\n        $body .= \"He wrote the following message: \\n\";\n        $body .= $message . \"\\n\";\n        $body .= \"\\n\";\n        $body .= \"\\n\";\n        $body .= \"The event is the following: \\n\";\n\n        // print the event in mail-format\n        // LATER place event-to-email-layout in a function\n        $appendlen = 20;\n        $body .= 'URL         : ' . Configure::read('MISP.baseurl') . '/events/view/' . $event['Event']['id'] . \"\\n\";\n        $bodyevent = $body;\n        $bodyevent .= 'Event ID    : ' . $event['Event']['id'] . \"\\n\";\n        $bodyevent .= 'Date        : ' . $event['Event']['date'] . \"\\n\";\n        if (Configure::read('MISP.showorg')) {\n            $body .= 'Reported by : ' . $event['Orgc']['name'] . \"\\n\";\n        }\n        $bodyevent .= 'Risk        : ' . $event['ThreatLevel']['name'] . \"\\n\";\n        $bodyevent .= 'Analysis    : ' . $event['Event']['analysis'] . \"\\n\";\n\n        $userModel = ClassRegistry::init('User');\n        $targetUser = $userModel->getAuthUser($orgMembers[0]['User']['id']);\n        $sgModel = ClassRegistry::init('SharingGroup');\n        $sgs = $sgModel->fetchAllAuthorised($targetUser, false);\n\n        $relatedEvents = $this->getRelatedEvents($targetUser, $id, $sgs);\n        if (!empty($relatedEvents)) {\n            foreach ($relatedEvents as &$relatedEvent) {\n                $bodyevent .= 'Related to  : ' . Configure::read('MISP.baseurl') . '/events/view/' . $relatedEvent['Event']['id'] . ' (' . $relatedEvent['Event']['date'] . ')' . \"\\n\";\n            }\n        }\n        $bodyevent .= 'Info  : ' . \"\\n\";\n        $bodyevent .= $event['Event']['info'] . \"\\n\";\n        $bodyevent .= \"\\n\";\n        $bodyevent .= 'Attributes  :' . \"\\n\";\n        $bodyTempOther = \"\";\n        if (!empty($event['Attribute'])) {\n            foreach ($event['Attribute'] as &$attribute) {\n                $line = '- ' . $attribute['type'] . str_repeat(' ', $appendlen - 2 - strlen($attribute['type'])) . ': ' . $attribute['value'] . \"\\n\";\n                if ('other' == $attribute['type']) { // append the 'other' attribute types to the bottom.\n                    $bodyTempOther .= $line;\n                } else {\n                    $bodyevent .= $line;\n                }\n            }\n        }\n        $bodyevent .= \"\\n\";\n        $bodyevent .= $bodyTempOther;\t// append the 'other' attribute types to the bottom.\n        return array($bodyevent, $body);\n    }\n\n    private function __captureSGForElement($element, $user)\n    {\n        if (isset($element['SharingGroup'])) {\n            $sg = $this->SharingGroup->captureSG($element['SharingGroup'], $user);\n            unset($element['SharingGroup']);\n        } elseif (isset($element['sharing_group_id'])) {\n            $sg = $this->SharingGroup->checkIfAuthorised($user, $element['sharing_group_id']) ? $element['sharing_group_id'] : false;\n        } else {\n            $sg = false;\n        }\n        if ($sg===false) {\n            $sg = 0;\n            $element['distribution'] = 0;\n        }\n        $element['sharing_group_id'] = $sg;\n        return $element;\n    }\n\n    // When we receive an event via REST, we might end up with organisations, sharing groups, tags that we do not know\n    // or which we need to update. All of that is controlled in this method.\n    private function __captureObjects($data, $user)\n    {\n        // First we need to check whether the event or any attributes are tied to a sharing group and whether the user is even allowed to create the sharing group / is part of it\n        if (isset($data['Event']['distribution']) && $data['Event']['distribution'] == 4) {\n            $data['Event'] = $this->__captureSGForElement($data['Event'], $user);\n        }\n        if (!empty($data['Event']['Attribute'])) {\n            foreach ($data['Event']['Attribute'] as $k => $a) {\n                unset($data['Event']['Attribute']['id']);\n                if (isset($a['distribution']) && $a['distribution'] == 4) {\n                    $data['Event']['Attribute'][$k] = $this->__captureSGForElement($a, $user);\n                    if ($data['Event']['Attribute'][$k] === false) {\n                        unset($data['Event']['Attribute']);\n                    }\n                }\n            }\n        }\n        if (!empty($data['Event']['Object'])) {\n            foreach ($data['Event']['Object'] as $k => $o) {\n                if (isset($o['distribution']) && $o['distribution'] == 4) {\n                    $data['Event']['Object'][$k] = $this->__captureSGForElement($o, $user);\n                    if ($data['Event']['Object'][$k] === false) {\n                        unset($data['Event']['Object'][$k]);\n                        continue;\n                    }\n                }\n                foreach ($o['Attribute'] as $k2 => $a) {\n                    if (isset($a['distribution']) && $a['distribution'] == 4) {\n                        $data['Event']['Object'][$k]['Attribute'][$k2] = $this->__captureSGForElement($a, $user);\n                        if ($data['Event']['Object'][$k]['Attribute'][$k2] === false) {\n                            unset($data['Event']['Object'][$k]['Attribute'][$k2]);\n                        }\n                    }\n                }\n            }\n        }\n\n        // first we want to see how the creator organisation is encoded\n        // The options here are either by passing an organisation object along or simply passing a string along\n        if (isset($data['Event']['Orgc'])) {\n            $data['Event']['orgc_id'] = $this->Orgc->captureOrg($data['Event']['Orgc'], $user);\n            unset($data['Event']['Orgc']);\n        } elseif (isset($data['Event']['orgc'])) {\n            $data['Event']['orgc_id'] = $this->Orgc->captureOrg($data['Event']['orgc'], $user);\n            unset($data['Event']['orgc']);\n        } else {\n            $data['Event']['orgc_id'] = $user['org_id'];\n        }\n\n        $event_tag_ids = array();\n        if (isset($data['Event']['EventTag'])) {\n            if (isset($data['Event']['EventTag']['id'])) {\n                $data['Event']['EventTag'] = array($data['Event']['EventTag']);\n            }\n            $eventTags = array();\n            foreach ($data['Event']['EventTag'] as $k => $tag) {\n                $temp = $this->EventTag->Tag->captureTag($data['Event']['EventTag'][$k]['Tag'], $user);\n                if ($temp && !in_array($temp, $event_tag_ids)) {\n                    $eventTags[] = array('tag_id' => $temp);\n                    $event_tag_ids[] = $temp;\n                }\n                unset($data['Event']['EventTag'][$k]);\n            }\n            $data['Event']['EventTag'] = $eventTags;\n        } else {\n            $data['Event']['EventTag'] = array();\n        }\n        if (isset($data['Event']['Tag'])) {\n            if (isset($data['Event']['Tag']['name'])) {\n                $data['Event']['Tag'] = array($data['Event']['Tag']);\n            }\n            foreach ($data['Event']['Tag'] as $tag) {\n                $tag_id = $this->EventTag->Tag->captureTag($tag, $user);\n                if ($tag_id && !in_array($tag_id, $event_tag_ids)) {\n                    $data['Event']['EventTag'][] = array('tag_id' => $tag_id);\n                    $event_tag_ids[] = $tag_id;\n                }\n            }\n            unset($data['Event']['Tag']);\n        }\n\n        if (!empty($data['Event']['Attribute'])) {\n            $data['Event']['Attribute'] = $this->__captureAttributeTags($data['Event']['Attribute'], $user);\n        }\n        if (!empty($data['Event']['Object'])) {\n            foreach ($data['Event']['Object'] as $k => $object) {\n                if (!empty($data['Event']['Object'][$k]['Attribute'])) {\n                    $data['Event']['Object'][$k]['Attribute'] = $this->__captureAttributeTags($data['Event']['Object'][$k]['Attribute'], $user);\n                }\n            }\n        }\n        return $data;\n    }\n\n    private function __captureAttributeTags($attributes, $user)\n    {\n        foreach ($attributes as $k => $a) {\n            if (isset($attributes[$k]['AttributeTag'])) {\n                if (isset($attributes[$k]['AttributeTag']['id'])) {\n                    $attributes[$k]['AttributeTag'] = array($attributes[$k]['AttributeTag']);\n                }\n                $attributeTags = array();\n                foreach ($attributes[$k]['AttributeTag'] as $tk => $tag) {\n                    $attributeTags[] = array('tag_id' => $this->Attribute->AttributeTag->Tag->captureTag($attributes[$k]['AttributeTag'][$tk]['Tag'], $user));\n                    unset($attributes[$k]['AttributeTag'][$tk]);\n                }\n                $attributes[$k]['AttributeTag'] = $attributeTags;\n            } else {\n                $attributes[$k]['AttributeTag'] = array();\n            }\n            if (isset($attributes[$k]['Tag'])) {\n                if (isset($attributes[$k]['Tag']['name'])) {\n                    $attributes[$k]['Tag'] = array($attributes[$k]['Tag']);\n                }\n                foreach ($attributes[$k]['Tag'] as $tag) {\n                    $tag_id = $this->Attribute->AttributeTag->Tag->captureTag($tag, $user);\n                    if ($tag_id) {\n                        $attributes[$k]['AttributeTag'][] = array('tag_id' => $tag_id);\n                    }\n                }\n                unset($attributes[$k]['Tag']);\n            }\n        }\n        return $attributes;\n    }\n\n    // Low level function to add an Event based on an Event $data array\n    public function _add(&$data, $fromXml, $user, $org_id = 0, $passAlong = null, $fromPull = false, $jobId = null, &$created_id = 0, &$validationErrors = array())\n    {\n        if ($jobId) {\n            App::uses('AuthComponent', 'Controller/Component');\n        }\n        if (Configure::read('MISP.enableEventBlacklisting') !== false && isset($data['Event']['uuid'])) {\n            $this->EventBlacklist = ClassRegistry::init('EventBlacklist');\n            $r = $this->EventBlacklist->find('first', array('conditions' => array('event_uuid' => $data['Event']['uuid'])));\n            if (!empty($r)) {\n                return 'Blocked by blacklist';\n            }\n        }\n        $this->create();\n        // force check userid and orgname to be from yourself\n        $data['Event']['user_id'] = $user['id'];\n\n        if ($fromPull) {\n            $data['Event']['org_id'] = $org_id;\n        } else {\n            $data['Event']['org_id'] = $user['Organisation']['id'];\n        }\n        // set these fields if the event is freshly created and not pushed from another instance.\n        // Moved out of if (!$fromXML), since we might get a restful event without the orgc/timestamp set\n        if (!isset($data['Event']['orgc_id']) && !isset($data['Event']['orgc'])) {\n            $data['Event']['orgc_id'] = $data['Event']['org_id'];\n        } else {\n            if (!isset($data['Event']['Orgc'])) {\n                if (isset($data['Event']['orgc_id']) && $data['Event']['orgc_id'] != $user['org_id'] && !$user['Role']['perm_sync'] && !$user['Role']['perm_site_admin']) {\n                    throw new MethodNotAllowedException('Event cannot be created as you are not a member of the creator organisation.');\n                }\n            } else {\n                if ($data['Event']['Orgc']['uuid'] != $user['Organisation']['uuid'] && !$user['Role']['perm_sync'] && !$user['Role']['perm_site_admin']) {\n                    throw new MethodNotAllowedException('Event cannot be created as you are not a member of the creator organisation.');\n                }\n                if (isset($data['Event']['orgc']) && $data['Event']['orgc'] != $user['Organisation']['name'] && !$user['Role']['perm_sync'] && !$user['Role']['perm_site_admin']) {\n                    throw new MethodNotAllowedException('Event cannot be created as you are not a member of the creator organisation.');\n                }\n            }\n            if (isset($data['Event']['orgc_id']) && $data['Event']['orgc_id'] != $user['org_id'] && !$user['Role']['perm_sync'] && !$user['Role']['perm_site_admin']) {\n                throw new MethodNotAllowedException('Event cannot be created as you are not a member of the creator organisation.');\n            }\n        }\n        if (!Configure::check('MISP.enableOrgBlacklisting') || Configure::read('MISP.enableOrgBlacklisting') !== false) {\n            $this->OrgBlacklist = ClassRegistry::init('OrgBlacklist');\n            if (!isset($data['Event']['Orgc']['uuid'])) {\n                $orgc = $this->Orgc->find('first', array('conditions' => array('Orgc.id' => $data['Event']['orgc_id']), 'fields' => array('Orgc.uuid'), 'recursive' => -1));\n            } else {\n                $orgc = array('Orgc' => array('uuid' => $data['Event']['Orgc']['uuid']));\n            }\n            if ($this->OrgBlacklist->hasAny(array('OrgBlacklist.org_uuid' => $orgc['Orgc']['uuid']))) {\n                return 'blocked';\n            }\n        }\n        if ($fromXml) {\n            // Workaround for different structure in XML/array than what CakePHP expects\n            $data = $this->cleanupEventArrayFromXML($data);\n            // the event_id field is not set (normal) so make sure no validation errors are thrown\n            // LATER do this with\t$this->validator()->remove('event_id');\n            unset($this->Attribute->validate['event_id']); // otherwise gives bugs because event_id is not set\n            unset($this->Attribute->validate['value']['uniqueValue']); // unset this - we are saving a new event, there are no values to compare against and event_id is not set in the attributes\n        }\n        unset($data['Event']['id']);\n        if (isset($data['Event']['published']) && $data['Event']['published'] && $user['Role']['perm_publish'] == 0) {\n            $data['Event']['published'] = 0;\n        }\n        if (isset($data['Event']['uuid'])) {\n            // check if the uuid already exists\n            $existingEventCount = $this->find('count', array('conditions' => array('Event.uuid' => $data['Event']['uuid'])));\n            if ($existingEventCount > 0) {\n                // RESTful, set response location header so client can find right URL to edit\n                if ($fromPull) {\n                    return false;\n                }\n                $existingEvent = $this->find('first', array('conditions' => array('Event.uuid' => $data['Event']['uuid'])));\n                if ($fromXml) {\n                    $created_id = $existingEvent['Event']['id'];\n                }\n                return $existingEvent['Event']['id'];\n            } else {\n                if ($fromXml) {\n                    $data = $this->__captureObjects($data, $user);\n                }\n                if ($data === false) {\n                    $failedCapture = true;\n                }\n            }\n        } else {\n            if ($fromXml) {\n                $data = $this->__captureObjects($data, $user);\n            }\n            if ($data === false) {\n                $failedCapture = true;\n            }\n        }\n        if (!empty($failedCapture)) {\n            $this->Log = ClassRegistry::init('Log');\n            $this->Log->create();\n            $this->Log->save(array(\n                    'org' => $user['Organisation']['name'],\n                    'model' => 'Event',\n                    'model_id' => 0,\n                    'email' => $user['email'],\n                    'action' => 'add',\n                    'user_id' => $user['id'],\n                    'title' => 'Event could not be saved due to a failed sharing group capture.',\n                    'change' => ''\n            ));\n            $validationErrors['Event'] = 'Issues saving a Sharing Group.';\n            return json_encode($validationErrors);\n        }\n        $fieldList = array(\n                'Event' => array(\n                    'org_id',\n                    'orgc_id',\n                    'date',\n                    'threat_level_id',\n                    'analysis',\n                    'info',\n                    'user_id',\n                    'published',\n                    'uuid',\n                    'timestamp',\n                    'distribution',\n                    'sharing_group_id',\n                    'locked',\n                    'disable_correlation',\n                    'extends_uuid'\n                ),\n                'Attribute' => $this->Attribute->captureFields,\n                'Object' => array(\n                    'name',\n                    'meta-category',\n                    'description',\n                    'template_uuid',\n                    'template_version',\n                    'event_id',\n                    'uuid',\n                    'timestamp',\n                    'distribution',\n                    'sharing_group_id',\n                    'comment',\n                    'deleted'\n                ),\n                'ObjectRelation' => array()\n        );\n        $saveResult = $this->save(array('Event' => $data['Event']), array('fieldList' => $fieldList['Event']));\n        $this->Log = ClassRegistry::init('Log');\n        if ($saveResult) {\n            if ($passAlong) {\n                $this->Server = ClassRegistry::init('Server');\n                $server = $this->Server->find('first', array(\n                    'conditions' => array(\n                        'Server.id' => $passAlong\n                    ),\n                    'recursive' => -1,\n                    'fields' => array(\n                        'Server.name',\n                        'Server.id',\n                        'Server.unpublish_event',\n                        'Server.publish_without_email'\n                    )\n                ));\n                if ($server['Server']['publish_without_email'] == 0) {\n                    $st = \"enabled\";\n                } else {\n                    $st = \"disabled\";\n                }\n                $this->Log->create();\n                $this->Log->save(array(\n                        'org' => $user['Organisation']['name'],\n                        'model' => 'Event',\n                        'model_id' => $saveResult['Event']['id'],\n                        'email' => $user['email'],\n                        'action' => 'add',\n                        'user_id' => $user['id'],\n                        'title' => 'Event pulled from Server(' . $server['Server']['id'] . ') - \"' . $server['Server']['name'] . '\" - Notification by mail ' . $st,\n                        'change' => ''\n                ));\n            }\n            if (isset($data['Event']['EventTag'])) {\n                foreach ($data['Event']['EventTag'] as $et) {\n                    $this->EventTag->create();\n                    $et['event_id'] = $this->id;\n                    $this->EventTag->save($et);\n                }\n            }\n            $parentEvent = $this->find('first', array(\n                'conditions' => array('Event.id' => $this->id),\n                'recursive' => -1\n            ));\n            if (isset($data['Event']['Attribute']) && !empty($data['Event']['Attribute'])) {\n                foreach ($data['Event']['Attribute'] as $k => $attribute) {\n                    $block = false;\n                    for ($i = 0; $i < $k; $i++) {\n                        if (empty($data['Event']['Attribute'][$i])) {\n                            continue;\n                        }\n                        if (\n                            $data['Event']['Attribute'][$i]['value'] == $attribute['value'] &&\n                            $data['Event']['Attribute'][$i]['type'] == $attribute['type'] &&\n                            $data['Event']['Attribute'][$i]['category'] == $attribute['category']\n                        ) {\n                            $block = true;\n                            unset($data['Event']['Attribute'][$i]);\n                            break;\n                        }\n                    }\n                    if (!$block) {\n                        $data['Event']['Attribute'][$k] = $this->Attribute->captureAttribute($attribute, $this->id, $user, 0, $this->Log, $parentEvent);\n                    }\n                }\n                $data['Event']['Attribute'] = array_values($data['Event']['Attribute']);\n            }\n            $referencesToCapture = array();\n            if (!empty($data['Event']['Object'])) {\n                foreach ($data['Event']['Object'] as $object) {\n                    $result = $this->Object->captureObject($object, $this->id, $user, $this->Log);\n                }\n                foreach ($data['Event']['Object'] as $object) {\n                    if (isset($object['ObjectReference'])) {\n                        foreach ($object['ObjectReference'] as $objectRef) {\n                            $objectRef['source_uuid'] = $object['uuid'];\n                            $referencesToCapture[] = $objectRef;\n                        }\n                    }\n                }\n            }\n            foreach ($referencesToCapture as $referenceToCapture) {\n                $result = $this->Object->ObjectReference->captureReference(\n                    $referenceToCapture,\n                    $this->id,\n                    $user,\n                    $this->Log\n                );\n            }\n            // zeroq: check if sightings are attached and add to event\n            if (isset($data['Sighting']) && !empty($data['Sighting'])) {\n                $this->Sighting = ClassRegistry::init('Sighting');\n                foreach ($data['Sighting'] as $s) {\n                    $result = $this->Sighting->saveSightings($s['attribute_uuid'], false, $s['date_sighting'], $user, $s['type'], $s['source'], $s['uuid']);\n                }\n            }\n            if ($fromXml) {\n                $created_id = $this->id;\n            }\n            if (!empty($data['Event']['published']) && 1 == $data['Event']['published']) {\n                // do the necessary actions to publish the event (email, upload,...)\n                if (('true' != Configure::read('MISP.disablerestalert')) && (empty($server) || $server['Server']['publish_without_email'] == 0)) {\n                    $this->sendAlertEmailRouter($this->getID(), $user);\n                }\n                $this->publish($this->getID(), $passAlong);\n            }\n            return true;\n        } else {\n            $validationErrors['Event'] = $this->validationErrors;\n            return json_encode($validationErrors);\n        }\n    }\n\n    public function _edit(&$data, $user, $id, $jobId = null, $passAlong = null)\n    {\n        $data = $this->cleanupEventArrayFromXML($data);\n        unset($this->Attribute->validate['event_id']);\n        unset($this->Attribute->validate['value']['unique']); // otherwise gives bugs because event_id is not set\n\n        // reposition to get the event.id with given uuid\n        if (isset($data['Event']['uuid'])) {\n            $existingEvent = $this->findByUuid($data['Event']['uuid']);\n        } else {\n            $existingEvent = $this->findById($id);\n        }\n        // If the event exists...\n        $dateObj = new DateTime();\n        $date = $dateObj->getTimestamp();\n        if (count($existingEvent)) {\n            $data['Event']['id'] = $existingEvent['Event']['id'];\n            $id = $existingEvent['Event']['id'];\n            // Conditions affecting all:\n            // user.org == event.org\n            // edit timestamp newer than existing event timestamp\n            if (!isset($data['Event']['timestamp']) || $data['Event']['timestamp'] > $existingEvent['Event']['timestamp']) {\n                if (!isset($data['Event']['timestamp'])) {\n                    $data['Event']['timestamp'] = $date;\n                }\n                if (isset($data['Event']['distribution']) && $data['Event']['distribution'] == 4) {\n                    if (!isset($data['Event']['SharingGroup'])) {\n                        if (!isset($data['Event']['sharing_group_id'])) {\n                            return(array('error' => 'Event could not be saved: Sharing group chosen as the distribution level, but no sharing group specified. Make sure that the event includes a valid sharing_group_id or change to a different distribution level.'));\n                        }\n                        if (!$this->SharingGroup->checkIfAuthorised($user, $data['Event']['sharing_group_id'])) {\n                            return(array('error' => 'Event could not be saved: Invalid sharing group or you don\\'t have access to that sharing group.'));\n                        }\n                    } else {\n                        $data['Event']['sharing_group_id'] = $this->SharingGroup->captureSG($data['Event']['SharingGroup'], $user);\n                        unset($data['Event']['SharingGroup']);\n                        if ($data['Event']['sharing_group_id'] === false) {\n                            return (array('error' => 'Event could not be saved: User not authorised to create the associated sharing group.'));\n                        }\n                    }\n                }\n                // If the above is true, we have two more options:\n                // For users that are of the creating org of the event, always allow the edit\n                // For users that are sync users, only allow the edit if the event is locked\n                if ($existingEvent['Event']['orgc_id'] === $user['org_id']\n                || ($user['Role']['perm_sync'] && $existingEvent['Event']['locked']) || $user['Role']['perm_site_admin']) {\n                    if ($user['Role']['perm_sync']) {\n                        if (isset($data['Event']['distribution']) && $data['Event']['distribution'] == 4 && !$this->SharingGroup->checkIfAuthorised($user, $data['Event']['sharing_group_id'])) {\n                            return (array('error' => 'Event could not be saved: The sync user has to have access to the sharing group in order to be able to edit it.'));\n                        }\n                    }\n                } else {\n                    return (array('error' => 'Event could not be saved: The user used to edit the event is not authorised to do so. This can be caused by the user not being of the same organisation as the original creator of the event whilst also not being a site administrator.'));\n                }\n            } else {\n                return (array('error' => 'Event could not be saved: Event in the request not newer than the local copy.'));\n            }\n            // If a field is not set in the request, just reuse the old value\n            $recoverFields = array('analysis', 'threat_level_id', 'info', 'distribution', 'date');\n            foreach ($recoverFields as $rF) {\n                if (!isset($data['Event'][$rF])) {\n                    $data['Event'][$rF] = $existingEvent['Event'][$rF];\n                }\n            }\n        } else {\n            return (array('error' => 'Event could not be saved: Could not find the local event.'));\n        }\n        if (!empty($data['Event']['published']) && !$user['Role']['perm_publish']) {\n            $data['Event']['published'] = 0;\n        }\n        if (!isset($data['Event']['published'])) {\n            $data['Event']['published'] = 0;\n        }\n        $fieldList = array(\n            'date',\n            'threat_level_id',\n            'analysis',\n            'info',\n            'published',\n            'uuid',\n            'distribution',\n            'timestamp',\n            'sharing_group_id',\n            'disable_correlation',\n            'extends_uuid'\n        );\n        $saveResult = $this->save(array('Event' => $data['Event']), array('fieldList' => $fieldList));\n        $this->Log = ClassRegistry::init('Log');\n        if ($saveResult) {\n            $validationErrors = array();\n            if (isset($data['Event']['Attribute'])) {\n                $data['Event']['Attribute'] = array_values($data['Event']['Attribute']);\n                foreach ($data['Event']['Attribute'] as $k => $attribute) {\n                    $result = $this->Attribute->editAttribute($attribute, $this->id, $user, 0, $this->Log);\n                    if ($result !== true) {\n                        $validationErrors['Attribute'][] = $result;\n                    }\n                }\n            }\n            if (isset($data['Event']['Object'])) {\n                $data['Event']['Object'] = array_values($data['Event']['Object']);\n                foreach ($data['Event']['Object'] as $k => $object) {\n                    $result = $this->Object->editObject($object, $this->id, $user, $this->Log);\n                    if ($result !== true) {\n                        $validationErrors['Object'][] = $result;\n                    }\n                }\n                foreach ($data['Event']['Object'] as $object) {\n                    if (isset($object['ObjectReference'])) {\n                        foreach ($object['ObjectReference'] as $objectRef) {\n                            $result = $this->Object->ObjectReference->captureReference($objectRef, $this->id, $user, $this->Log);\n                        }\n                    }\n                }\n            }\n            if (isset($data['Event']['EventTag'])) {\n                $data['Event']['Tag'] = $data['Event']['EventTag']['Tag'];\n                unset($data['Event']['EventTag']);\n            }\n            if (isset($data['Event']['Tag']) && $user['Role']['perm_tagger']) {\n                foreach ($data['Event']['Tag'] as $tag) {\n                    $tag_id = $this->EventTag->Tag->captureTag($tag, $user);\n                    if ($tag_id) {\n                        $this->EventTag->attachTagToEvent($this->id, $tag_id);\n                    } else {\n                        // If we couldn't attach the tag it is most likely because we couldn't create it - which could have many reasons\n                        // However, if a tag couldn't be added, it could also be that the user is a tagger but not a tag editor\n                        // In which case if no matching tag is found, no tag ID is returned. Logging these is pointless as it is the correct behaviour.\n                        if ($user['Role']['perm_tag_editor']) {\n                            $this->Log->create();\n                            $this->Log->save(array(\n                                'org' => $user['Organisation']['name'],\n                                'model' => 'Event',\n                                'model_id' => $this->id,\n                                'email' => $user['email'],\n                                'action' => 'edit',\n                                'user_id' => $user['id'],\n                                'title' => 'Failed create or attach Tag ' . $tag['name'] . ' to the event.',\n                                'change' => ''\n                            ));\n                        }\n                    }\n                }\n            }\n            // zeroq: if sightings then attach to event\n            if (isset($data['Sighting']) && !empty($data['Sighting'])) {\n                $this->Sighting = ClassRegistry::init('Sighting');\n                foreach ($data['Sighting'] as $s) {\n                    $result = $this->Sighting->saveSightings($s['attribute_uuid'], false, $s['date_sighting'], $user, $s['type'], $s['source'], $s['uuid']);\n                }\n            }\n            // if published -> do the actual publishing\n            if ((!empty($data['Event']['published']) && 1 == $data['Event']['published'])) {\n\t\t\t    // The edited event is from a remote server ?\n\t\t\t\tif ($passAlong) {\n\t\t\t\t\t$this->Server = ClassRegistry::init('Server');\n\t\t\t\t\t$server = $this->Server->find('first', array(\n\t\t\t\t\t    'conditions' => array(\n\t\t\t\t\t\t    'Server.id' => $passAlong\n\t\t\t\t\t\t),\n\t\t\t\t\t\t'recursive' => -1,\n\t\t\t\t\t\t'fields' => array(\n\t\t\t\t\t\t    'Server.name',\n\t\t\t\t\t\t\t'Server.id',\n\t\t\t\t\t\t\t'Server.unpublish_event',\n\t\t\t\t\t\t\t'Server.publish_without_email'\n\t\t\t\t\t\t)\n\t\t\t\t\t));\n\t\t\t\t\tif ($server['Server']['publish_without_email'] == 0) {\n\t\t\t\t\t    $st = \"enabled\";\n\t\t\t\t\t} else {\n\t\t\t\t\t    $st = \"disabled\";\n\t\t\t\t\t}\n\t\t\t\t\t$this->Log->create();\n\t\t\t\t\t$this->Log->save(array(\n\t\t\t\t\t    'org' => $user['Organisation']['name'],\n\t\t\t\t\t\t'model' => 'Event',\n\t\t\t\t\t\t'model_id' => $saveResult['Event']['id'],\n\t\t\t\t\t\t'email' => $user['email'],\n\t\t\t\t\t\t'action' => 'add',\n\t\t\t\t\t\t'user_id' => $user['id'],\n\t\t\t\t\t\t'title' => 'Event edited from Server(' . $server['Server']['id'] . ') - \"' . $server['Server']['name'] . '\" - Notification by mail ' . $st,\n\t\t\t\t\t\t'change' => ''\n                    ));\n\t\t\t\t} else {\n\t\t\t\t    $this->Log->create();\n\t\t\t\t\t$this->Log->save(array(\n\t\t\t\t\t\t'org' => $user['Organisation']['name'],\n\t\t\t\t\t\t'model' => 'Event',\n\t\t\t\t\t    'model_id' => $saveResult['Event']['id'],\n\t\t\t\t\t\t'email' => $user['email'],\n\t\t\t\t\t\t'action' => 'add',\n\t\t\t\t\t\t'user_id' => $user['id'],\n\t\t\t\t\t\t'title' => 'Event edited (locally)',\n\t\t\t\t\t\t'change' => ''\n\t\t\t\t\t));\n                }\n                // do the necessary actions to publish the event (email, upload,...)\n                if ((true != Configure::read('MISP.disablerestalert')) && (empty($server) || $server['Server']['publish_without_email'] == 0)) {\n                    $this->sendAlertEmailRouter($id, $user, $existingEvent['Event']['publish_timestamp']);\n                }\n                $this->publish($existingEvent['Event']['id']);\n            }\n            return true;\n        }\n        return $this->validationErrors;\n    }\n\n    // format has to be:\n    // array('Event' => array(), 'Attribute' => array('ShadowAttribute' => array()), 'EventTag' => array(), 'ShadowAttribute' => array());\n    public function savePreparedEvent($event)\n    {\n        unset($event['Event']['id']);\n        $this->create();\n        $this->save($event['Event']);\n        $event['Event']['id'] = $this->id;\n        $objects = array('Attribute', 'ShadowAttribute', 'EventTag', 'Object');\n        foreach ($objects as $object_type) {\n            if (!empty($event[$object_type])) {\n                $saveMethod = '__savePrepared' . $object_type;\n                foreach ($event[$object_type] as $object) {\n                    $this->$saveMethod($object, $event);\n                }\n            }\n        }\n        if (!empty($event['Object'])) {\n            $objectRefTypes = array('Attribute', 'Object');\n            foreach ($event['Object'] as $k => $object) {\n                foreach ($object['ObjectReference'] as $k2 => $objectRef) {\n                    $savedObjectRef = $this->Object->ObjectReference->find('first', array(\n                        'recursive' => -1,\n                        'conditions' => array('ObjectReference.uuid' => $objectRef['uuid'])\n                    ));\n                    $objectRefType = intval($savedObjectRef['ObjectReference']['referenced_type']);\n                    $element = $this->{$objectRefTypes[$objectRefType]}->find('first', array(\n                        'conditions' => array($objectRefTypes[$objectRefType] . '.uuid' => $objectRef['referenced_uuid']),\n                        'recursive' => -1,\n                        'fields' => array($objectRefTypes[$objectRefType] . '.id')\n                    ));\n                    $savedObjectRef['ObjectReference']['referenced_id'] = $element[$objectRefTypes[$objectRefType]]['id'];\n                    $result = $this->Object->ObjectReference->save($savedObjectRef);\n                }\n            }\n        }\n        return $event['Event']['id'];\n    }\n\n    private function __savePreparedAttribute(&$attribute, $event, $object_id = 0)\n    {\n        unset($attribute['id']);\n        $attribute['event_id'] = $event['Event']['id'];\n        $attribute['object_id'] = $object_id;\n        $this->Attribute->create();\n        $this->Attribute->save($attribute);\n        foreach ($attribute['ShadowAttribute'] as $k => $sa) {\n            $this->__savePreparedShadowAttribute($sa, $event, $this->Attribute->id);\n        }\n        foreach ($attribute['AttributeTag'] as $k => $at) {\n            $this->__savePreparedAttributeTag($at, $event, $this->Attribute->id);\n        }\n        return true;\n    }\n\n    private function __savePreparedObject(&$object, $event)\n    {\n        unset($object['id']);\n        $object['event_id'] = $event['Event']['id'];\n        $this->Object->create();\n        $this->Object->save($object);\n        foreach ($object['Attribute'] as $k => $a) {\n            $this->__savePreparedAttribute($a, $event, $this->Object->id);\n        }\n        foreach ($object['ObjectReference'] as $objectRef) {\n            $this->__savePreparedObjectReference($objectRef, $event, $this->Object->id, $object['uuid']);\n        }\n        return true;\n    }\n\n    #referenced IDs have to be updated after everything else is done!\n    private function __savePreparedObjectReference($objectRef, $event, $object_id, $object_uuid)\n    {\n        unset($objectRef['id']);\n        $objectRef['event_id'] = $event['Event']['id'];\n        $objectRef['object_id'] = $object_id;\n        $objectRef['object_uuid'] = $object_uuid;\n        $this->Object->ObjectReference->create();\n        $this->Object->ObjectReference->save($objectRef);\n        return true;\n    }\n\n    private function __savePreparedShadowAttribute($shadow_attribute, $event, $old_id = 0)\n    {\n        unset($shadow_attribute['id']);\n        $shadow_attribute['event_id'] = $event['Event']['id'];\n        $shadow_attribute['old_id'] = $old_id;\n        $this->ShadowAttribute->create();\n        $this->ShadowAttribute->save($shadow_attribute);\n        return true;\n    }\n\n    private function __savePreparedEventTag($event_tag, $event)\n    {\n        unset($event_tag['id']);\n        $event_tag['event_id'] = $event['Event']['id'];\n        $this->EventTag->create();\n        $this->EventTag->save($event_tag);\n        return true;\n    }\n\n    private function __savePreparedAttributeTag($attribute_tag, $event, $attribute_id)\n    {\n        unset($attribute_tag['id']);\n        $attribute_tag['event_id'] = $event['Event']['id'];\n        $attribute_tag['attribute_id'] = $attribute_id;\n        $this->Attribute->AttributeTag->create();\n        $this->Attribute->AttributeTag->save($attribute_tag);\n        return true;\n    }\n\n    // pass an event or an attribute together with the server id.\n    // If the distribution of the object outright allows for it to be shared, return true\n    // If the distribution is org only / comm only, return false\n    // If the distribution is sharing group only, check if the sync user is in the sharing group or not, return true if yes, false if no\n    public function checkDistributionForPush($object, $server, $context = 'Event')\n    {\n        if (empty(Configure::read('MISP.host_org_id')) || !$server['Server']['internal'] || Configure::read('MISP.host_org_id') != $server['Server']['remote_org_id']) {\n            if ($object[$context]['distribution'] < 2) {\n                return false;\n            }\n        }\n        if ($object[$context]['distribution'] == 4) {\n            if ($context === 'Event') {\n                return $this->SharingGroup->checkIfServerInSG($object['SharingGroup'], $server);\n            } else {\n                return $this->SharingGroup->checkIfServerInSG($object[$context]['SharingGroup'], $server);\n            }\n        }\n        return true;\n    }\n\n    // Uploads this specific event to all remote servers\n    public function uploadEventToServersRouter($id, $passAlong = null)\n    {\n        $eventOrgcId = $this->find('first', array(\n            'conditions' => array('Event.id' => $id),\n            'recursive' => -1,\n            'fields' => array('Event.orgc_id')\n        ));\n        // we create a fake site admin user object to fetch the event with everything included\n        // This replaces the old method of manually just fetching everything, staying consistent\n        // with the fetchEvent() output\n        $elevatedUser = array(\n            'Role' => array(\n                'perm_site_admin' => 1,\n                'perm_sync' => 1\n            ),\n            'org_id' => $eventOrgcId['Event']['orgc_id']\n        );\n        $elevatedUser['Role']['perm_site_admin'] = 1;\n        $elevatedUser['Role']['perm_sync'] = 1;\n        $elevatedUser['Role']['perm_audit'] = 0;\n        $event = $this->fetchEvent($elevatedUser, array('eventid' => $id, 'metadata' => 1));\n        if (empty($event)) {\n            return true;\n        }\n        $event = $event[0];\n        $event['Event']['locked'] = 1;\n        // get a list of the servers\n        $this->Server = ClassRegistry::init('Server');\n        $conditions = array('push' => 1);\n        if ($passAlong) {\n            $conditions[] = array('Server.id !=' => $passAlong);\n        }\n        $servers = $this->Server->find('all', array('conditions' => $conditions));\n        // iterate over the servers and upload the event\n        if (empty($servers)) {\n            return true;\n        }\n        $uploaded = true;\n        $failedServers = array();\n        App::uses('SyncTool', 'Tools');\n        foreach ($servers as &$server) {\n            if ((!isset($server['Server']['internal']) || !$server['Server']['internal']) && $event['Event']['distribution'] < 2) {\n                continue;\n            }\n            $syncTool = new SyncTool();\n            $HttpSocket = $syncTool->setupHttpSocket($server);\n            // Skip servers where the event has come from.\n            if (($passAlong != $server)) {\n                $params = array();\n                if (!empty($server['Server']['push_rules'])) {\n                    $push_rules = json_decode($server['Server']['push_rules'], true);\n                    if (!empty($push_rules['tags']['NOT'])) {\n                        $params['blockedAttributeTags'] = $push_rules['tags']['NOT'];\n                    }\n                }\n                $params = array_merge($params, array(\n                    'eventid' => $id,\n                    'includeAttachments' => true,\n                    'includeAllTags' => true,\n                    'deleted' => true,\n                    'excludeGalaxy' => 1\n                ));\n                $event = $this->fetchEvent($elevatedUser, $params);\n                $event = $event[0];\n                $event['Event']['locked'] = 1;\n                $thisUploaded = $this->uploadEventToServer($event, $server, $HttpSocket);\n                if (!$thisUploaded) {\n                    $uploaded = !$uploaded ? $uploaded : $thisUploaded;\n                    $failedServers[] = $server['Server']['url'];\n                }\n                if (isset($this->data['ShadowAttribute'])) {\n                    $this->Server->syncProposals($HttpSocket, $server, null, $id, $this);\n                }\n            }\n        }\n        if (!$uploaded) {\n            if (empty($failedServers)) {\n                return true;\n            }\n            return $failedServers;\n        } else {\n            return true;\n        }\n    }\n\n    private function __getPrioWorkerIfPossible()\n    {\n        $this->ResqueStatus = new ResqueStatus\\ResqueStatus(Resque::redis());\n        $workers = $this->ResqueStatus->getWorkers();\n        $workerType = 'default';\n        foreach ($workers as $worker) {\n            if ($worker['queue'] === 'prio') {\n                $workerType = 'prio';\n            }\n        }\n        return $workerType;\n    }\n\n    public function publishRouter($id, $passAlong = null, $user)\n    {\n        if (Configure::read('MISP.background_jobs')) {\n            $job = ClassRegistry::init('Job');\n            $job->create();\n            $data = array(\n                    'worker' => $this->__getPrioWorkerIfPossible(),\n                    'job_type' => 'publish_event',\n                    'job_input' => 'Event ID: ' . $id,\n                    'status' => 0,\n                    'retries' => 0,\n                    'org_id' => $user['org_id'],\n                    'org' => $user['Organisation']['name'],\n                    'message' => 'Publishing.',\n            );\n            $job->save($data);\n            $jobId = $job->id;\n            $process_id = CakeResque::enqueue(\n                    'prio',\n                    'EventShell',\n                    array('publish', $id, $passAlong, $jobId, $user['id']),\n                    true\n            );\n            $job->saveField('process_id', $process_id);\n            return $process_id;\n        } else {\n            $result = $this->publish($id, $passAlong);\n            return $result;\n        }\n    }\n\n    // Performs all the actions required to publish an event\n    public function publish($id, $passAlong = null, $jobId = null)\n    {\n        $this->id = $id;\n        $this->recursive = 0;\n        $event = $this->read(null, $id);\n        if ($jobId) {\n            $this->Behaviors->unload('SysLogLogable.SysLogLogable');\n        } else {\n            // update the DB to set the published flag\n            // for background jobs, this should be done already\n            $fieldList = array('published', 'id', 'info', 'publish_timestamp');\n            $event['Event']['published'] = 1;\n            $event['Event']['publish_timestamp'] = time();\n            $event['Event']['skip_zmq'] = 1;\n            $this->save($event, array('fieldList' => $fieldList));\n        }\n        if (Configure::read('Plugin.ZeroMQ_enable')) {\n            $pubSubTool = $this->getPubSubTool();\n            $hostOrg = $this->Org->find('first', array('conditions' => array('name' => Configure::read('MISP.org')), 'fields' => array('id')));\n            if (!empty($hostOrg)) {\n                $user = array('org_id' => $hostOrg['Org']['id'], 'Role' => array('perm_sync' => 0, 'perm_audit' => 0, 'perm_site_admin' => 0), 'Organisation' => $hostOrg['Org']);\n                $params = array('eventid' => $id);\n                if (Configure::read('Plugin.ZeroMQ_include_attachments')) {\n                    $params['includeAttachments'] = 1;\n                }\n                $fullEvent = $this->fetchEvent($user, $params);\n                if (!empty($fullEvent)) {\n                    $pubSubTool->publishEvent($fullEvent[0], 'publish');\n                }\n            }\n        }\n        $uploaded = $this->uploadEventToServersRouter($id, $passAlong);\n        return $uploaded;\n    }\n\n\n    // Sends out an email to all people within the same org with the request to be contacted about a specific event.\n    public function sendContactEmailRouter($id, $message, $creator_only, $user, $isSiteAdmin, $JobId = false)\n    {\n        if (Configure::read('MISP.background_jobs')) {\n            $job = ClassRegistry::init('Job');\n            $job->create();\n            $data = array(\n                    'worker' => 'email',\n                    'job_type' => 'contact_alert',\n                    'job_input' => 'Owner ' . ($creator_only ? 'user' : 'org') . ' of event #' . $id,\n                    'status' => 0,\n                    'retries' => 0,\n                    'org_id' => $user['org_id'],\n                    'message' => 'Contacting.',\n            );\n            $job->save($data);\n            $jobId = $job->id;\n            $process_id = CakeResque::enqueue(\n                    'email',\n                    'EventShell',\n                    array('contactemail', $id, $message, $creator_only, $user['id'], $isSiteAdmin, $jobId),\n                    true\n            );\n            $job->saveField('process_id', $process_id);\n            return true;\n        } else {\n            $result = $this->sendContactEmail($id, $message, $creator_only, array('User' => $user), $isSiteAdmin);\n            return $result;\n        }\n    }\n\n    public function generateLocked()\n    {\n        $this->User = ClassRegistry::init('User');\n        $this->User->recursive = -1;\n        $localOrgs = array();\n        $conditions = array();\n        $orgs = $this->User->find('all', array('fields' => array('DISTINCT org_id')));\n        foreach ($orgs as $k => $org) {\n            $orgs[$k]['User']['count'] = $this->User->getOrgMemberCount($orgs[$k]['User']['org_id']);\n            if ($orgs[$k]['User']['count'] > 1) {\n                $localOrgs[] = $orgs[$k]['User']['org_id'];\n                $conditions['AND'][] = array('orgc !=' => $orgs[$k]['User']['org_id']);\n            } elseif ($orgs[$k]['User']['count'] == 1) {\n                // If we only have a single user for an org, check if that user is a sync user. If not, then it is a valid local org and the events created by him/her should be unlocked.\n                $this->User->recursive = 1;\n                $user = ($this->User->find('first', array(\n                        'fields' => array('id', 'role_id'),\n                        'conditions' => array('org_id' => $org['User']['org_id']),\n                        'contain' => array('Role' => array(\n                                'fields' => array('id', 'perm_sync'),\n                        ))\n                )));\n                if (!$user['Role']['perm_sync']) {\n                    $conditions['AND'][] = array('orgc !=' => $orgs[$k]['User']['org_id']);\n                }\n            }\n        }\n        // Don't lock stuff that's already locked\n        $conditions['AND'][] = array('locked !=' => true);\n        $this->recursive = -1;\n        $toBeUpdated = $this->find('count', array(\n                'conditions' => $conditions\n        ));\n        $this->updateAll(\n                array('Event.locked' => 1),\n                $conditions\n        );\n        return $toBeUpdated;\n    }\n\n    public function reportValidationIssuesEvents()\n    {\n        $this->Behaviors->detach('Regexp');\n        // get all events..\n        $events = $this->find('all', array('recursive' => -1));\n        // for all events..\n        $result = array();\n        $k = 0;\n        $i = 0;\n        foreach ($events as $k => $event) {\n            $this->set($event);\n            if (!$this->validates()) {\n                $errors = $this->validationErrors;\n                $result[$i]['id'] = $event['Event']['id'];\n                $result[$i]['error'] = $errors;\n                $result[$i]['details'] = $event;\n                $i++;\n            }\n        }\n        return array($result, $k);\n    }\n\n    public function generateThreatLevelFromRisk()\n    {\n        $risk = array('Undefined' => 4, 'Low' => 3, 'Medium' => 2, 'High' => 1);\n        $events = $this->find('all', array('recursive' => -1));\n        $k = 0;\n        foreach ($events as $k => $event) {\n            if ($event['Event']['threat_level_id'] == 0 && isset($event['Event']['risk'])) {\n                $event['Event']['threat_level_id'] = $risk[$event['Event']['risk']];\n                $this->save($event);\n            }\n        }\n        return $k;\n    }\n\n    // check two version strings. If version 1 is older than 2, return -1, if they are the same return 0, if version 2 is older return 1\n    public function compareVersions($version1, $version2)\n    {\n        $version1Array = explode('.', $version1);\n        $version2Array = explode('.', $version2);\n\n        if ($version1Array[0] != $version2Array[0]) {\n            if ($version1Array[0] > $version2Array[0]) {\n                return 1;\n            } else {\n                return -1;\n            }\n        }\n        if ($version1Array[1] != $version2Array[1]) {\n            if ($version1Array[1] > $version2Array[1]) {\n                return 1;\n            } else {\n                return -1;\n            }\n        }\n        if ($version1Array[2] != $version2Array[2]) {\n            if ($version1Array[2] > $version2Array[2]) {\n                return 1;\n            } else {\n                return -1;\n            }\n        }\n    }\n\n    // main dispatch method for updating an incoming xmlArray - pass xmlArray to all of the appropriate transformation methods to make all the changes necessary to save the imported event\n    public function updateXMLArray($xmlArray, $response = true)\n    {\n        if (isset($xmlArray['xml_version']) && $response) {\n            $xmlArray['response']['xml_version'] = $xmlArray['xml_version'];\n            unset($xmlArray['xml_version']);\n        }\n\n        if (!$response) {\n            $xmlArray = array('response' => $xmlArray);\n        }\n        // if a version is set, it must be at least 2.2.0 - check the version and save the result of the comparison\n        if (isset($xmlArray['response']['xml_version'])) {\n            $version = $this->compareVersions($xmlArray['response']['xml_version'], $this->mispVersion);\n        }\n        // if no version is set, set the version to older (-1) manually\n        else {\n            $version = -1;\n        }\n        // same version, proceed normally\n        if ($version != 0) {\n            // The xml is from an instance that is newer than the local instance, let the user know that the admin needs to upgrade before it could be imported\n            if ($version == 1) {\n                throw new Exception('This XML file is from a MISP instance that is newer than the current instance. Please contact your administrator about upgrading this instance.');\n            }\n\n            // if the xml contains an event or events from an older MISP instance, let's try to upgrade it!\n            // Let's manually set the version to something below 2.2.0 if there is no version set in the xml\n            if (!isset($xmlArray['response']['xml_version'])) {\n                $xmlArray['response']['xml_version'] = '2.1.0';\n            }\n\n            // Upgrade from versions below 2.2.0 will need to replace the risk field with threat level id\n            if ($this->compareVersions($xmlArray['response']['xml_version'], '2.2.0') < 0) {\n                if ($response) {\n                    $xmlArray['response'] = $this->__updateXMLArray220($xmlArray['response']);\n                } else {\n                    $xmlArray = $this->__updateXMLArray220($xmlArray);\n                }\n            }\n        }\n        unset($xmlArray['response']['xml_version']);\n        if ($response) {\n            return $xmlArray;\n        } else {\n            return $xmlArray['response'];\n        }\n    }\n\n    // replaces the old risk value with the new threat level id\n    private function __updateXMLArray220($xmlArray)\n    {\n        $risk = array('Undefined' => 4, 'Low' => 3, 'Medium' => 2, 'High' => 1);\n        if (isset($xmlArray['Event'][0])) {\n            foreach ($xmlArray['Event'] as &$event) {\n                if (!isset($event['threat_level_id'])) {\n                    $event['threat_level_id'] = $risk[$event['risk']];\n                }\n            }\n        } else {\n            if (!isset($xmlArray['Event']['threat_level_id']) && isset($xmlArray['Event']['risk'])) {\n                $xmlArray['Event']['threat_level_id'] = $risk[$xmlArray['Event']['risk']];\n            }\n        }\n        return $xmlArray;\n    }\n\n    public function checkIfNewer($incomingEvent)\n    {\n        $localEvent = $this->find('first', array('conditions' => array('uuid' => $incomingEvent['uuid']), 'recursive' => -1, 'fields' => array('Event.uuid', 'Event.timestamp')));\n        if (empty($localEvent) || $incomingEvent['timestamp'] > $localEvent['Event']['timestamp']) {\n            return true;\n        }\n        return false;\n    }\n\n    public function removeOlder(&$eventArray)\n    {\n        $uuidsToCheck = array();\n        foreach ($eventArray as $k => &$event) {\n            $uuidsToCheck[$event['uuid']] = $k;\n        }\n        $localEvents = $this->find('list', array('recursive' => -1, 'fields' => array('Event.uuid', 'Event.timestamp')));\n        foreach ($uuidsToCheck as $uuid => $eventArrayId) {\n            if (isset($localEvents[$uuid]) && $localEvents[$uuid] >= $eventArray[$eventArrayId]['timestamp']) {\n                unset($eventArray[$eventArrayId]);\n            }\n        }\n    }\n\n    public function stix2($id, $tags, $attachments, $user, $returnType = 'json', $from = false, $to = false, $last = false, $jobId = false, $returnFile = false)\n    {\n        $eventIDs = $this->Attribute->dissectArgs($id);\n        $tagIDs = $this->Attribute->dissectArgs($tags);\n        $idList = $this->getAccessibleEventIds($eventIDs[0], $eventIDs[1], $tagIDs[0], $tagIDs[1]);\n        if (!empty($idList)) {\n            $event_ids = $this->fetchEventIds($user, $from, $to, $last, true);\n            $event_ids = array_intersect($event_ids, $idList);\n        }\n        $randomFileName = $this->generateRandomFileName();\n        $scriptDir = APP . \"files/scripts/\";\n        $stix2_framing_cmd = $this->getPythonVersion() . ' ' . $scriptDir . 'misp_framing.py stix2 ' . escapeshellarg(CakeText::uuid()) . ' 2>' . APP . 'tmp/logs/exec-errors.log';\n        $stix2_framing = json_decode(shell_exec($stix2_framing_cmd), true);\n        if (empty($stix2_framing)) {\n            return array('success' => 0, 'message' => 'There was an issue generating the STIX 2.0 export.');\n        }\n        $separator = $stix2_framing['separator'];\n        $tmpDir = $scriptDir . \"tmp/\";\n        $stixFile = new File($tmpDir . $randomFileName . \".stix\");\n        $stixFile->write($stix2_framing['header']);\n        if ($jobId) {\n            $this->Job = ClassRegistry::init('Job');\n            $this->Job->id = $jobId;\n            if (!$this->Job->exists()) {\n                $jobId = false;\n            }\n        }\n        $i = 0;\n        $eventCount = count($event_ids);\n        if ($event_ids) {\n            foreach ($event_ids as $event_id) {\n                $tempFile = new File($tmpDir . $randomFileName, true, 0644);\n                $event = $this->fetchEvent($user, array('eventid' => $event_id, 'includeAttachments' => 1));\n                if (empty($event)) {\n                    continue;\n                }\n                $event[0]['Tag'] = array();\n                foreach ($event[0]['EventTag'] as $tag) {\n                    $event[0]['Tag'][] = $tag['Tag'];\n                }\n                App::uses('JSONConverterTool', 'Tools');\n                $converter = new JSONConverterTool();\n                $event = $converter->convert($event[0]);\n                $tempFile->write($event);\n                unset($event);\n                $scriptFile = $scriptDir . \"stix2/misp2stix2.py \";\n                $result = shell_exec($this->getPythonVersion() . ' ' . $scriptFile . $tempFile->path . ' 2>' . APP . 'tmp/logs/exec-errors.log');\n                $decoded = json_decode($result, true);\n                if (isset($decoded['success']) && $decoded['success'] == 1) {\n                    $file = new File($tmpDir . $randomFileName . '.out', true, 0644);\n                    $result = substr($file->read(), 1, -1);\n                    $file->delete();\n                    $stixFile->append($result . (($i + 1) != $eventCount ? $separator : ''));\n                } else {\n                    return false;\n                }\n                $i++;\n                if ($jobId) {\n                    $this->Job->saveField('message', 'Event ' . $i . '/' . $eventCount);\n                    if ($i % 10 == 0) {\n                        $this->Job->saveField('progress', $i * 80 / $eventCount);\n                    }\n                }\n                $tempFile->close();\n            }\n        }\n        $stixFile->append($stix2_framing['footer']);\n        if ($tempFile) {\n            $tempFile->delete();\n        }\n        if (!$returnFile) {\n            $data2return = $stixFile->read();\n            $stixFile->delete();\n        }\n        return array('success' => 1, 'data' => $returnFile ? $stixFile->path : $data2return);\n    }\n\n    public function stix($id, $tags, $attachments, $user, $returnType = 'xml', $from = false, $to = false, $last = false, $jobId = false, $returnFile = false)\n    {\n        $eventIDs = $this->Attribute->dissectArgs($id);\n        $tagIDs = $this->Attribute->dissectArgs($tags);\n        $idList = $this->getAccessibleEventIds($eventIDs[0], $eventIDs[1], $tagIDs[0], $tagIDs[1]);\n        if (!empty($idList)) {\n            $event_ids = $this->fetchEventIds($user, $from, $to, $last, true);\n            $event_ids = array_intersect($event_ids, $idList);\n        }\n        $randomFileName = $this->generateRandomFileName();\n        $tmpDir = APP . \"files\" . DS . \"scripts\";\n        $stix_framing_cmd = $this->getPythonVersion() . ' ' . $tmpDir . DS . 'misp_framing.py stix ' . escapeshellarg(Configure::read('MISP.baseurl')) . ' ' . escapeshellarg(Configure::read('MISP.org')) . ' ' . escapeshellarg($returnType) . ' 2>' . APP . 'tmp/logs/exec-errors.log';\n        $stix_framing = json_decode(shell_exec($stix_framing_cmd), true);\n        if (empty($stix_framing)) {\n            return array('success' => 0, 'message' => 'There was an issue generating the STIX export.');\n        }\n        $separator = $stix_framing['separator'];\n        $tmpDir = $tmpDir . DS . \"tmp\";\n        $stixFile = new File($tmpDir . DS . $randomFileName . \".stix\");\n        $stixFile->write($stix_framing['header']);\n        $result = array();\n        if ($jobId) {\n            $this->Job = ClassRegistry::init('Job');\n            $this->Job->id = $jobId;\n            if (!$this->Job->exists()) {\n                $jobId = false;\n            }\n        }\n        $i = 0;\n        $eventCount = count($event_ids);\n        if ($event_ids) {\n            foreach ($event_ids as $event_id) {\n                $tempFile = new File($tmpDir . DS . $randomFileName, true, 0644);\n                $event = $this->fetchEvent($user, array('eventid' => $event_id));\n                if (empty($event)) {\n                    continue;\n                }\n                if ($attachments == \"yes\" || $attachments == \"true\" || $attachments == 1) {\n                    foreach ($event[0]['Attribute'] as &$attribute) {\n                        if ($this->Attribute->typeIsAttachment($attribute['type'])) {\n                            $encodedFile = $this->Attribute->base64EncodeAttachment($attribute);\n                            $attribute['data'] = $encodedFile;\n                        }\n                    }\n                }\n                $event[0]['Tag'] = array();\n                foreach ($event[0]['EventTag'] as $tag) {\n                    $event[0]['Tag'][] = $tag['Tag'];\n                }\n                App::uses('JSONConverterTool', 'Tools');\n                $converter = new JSONConverterTool();\n                $event = $converter->convert($event[0]);\n                $tempFile->write($event);\n                unset($event);\n                $scriptFile = APP . \"files\" . DS . \"scripts\" . DS . \"misp2stix.py\";\n                $result = shell_exec($this->getPythonVersion() . ' ' . $scriptFile . ' ' . $randomFileName . ' ' . escapeshellarg($returnType) . ' ' . escapeshellarg(Configure::read('MISP.baseurl')) . ' ' . escapeshellarg(Configure::read('MISP.org')) . ' 2>' . APP . 'tmp/logs/exec-errors.log');\n                // The result of the script will be a returned JSON object with 2 variables: success (boolean) and message\n                // If success = 1 then the temporary output file was successfully written, otherwise an error message is passed along\n                $decoded = json_decode($result, true);\n                if (!isset($decoded['success']) || !$decoded['success']) {\n                    $tempFile->delete();\n                    $stixFile->delete();\n                    return array('success' => 0, 'message' => $decoded['message']);\n                }\n                $file = new File(APP . \"files\" . DS . \"scripts\" . DS . \"tmp\" . DS . $randomFileName . \".out\");\n                $stix_event = $file->read();\n                if (($i + 1) != $eventCount) {\n                    $stix_event .= $separator;\n                }\n                $stixFile->append($stix_event);\n                $file->close();\n                $file->delete();\n                $i++;\n                if ($jobId) {\n                    $this->Job->saveField('message', 'Event ' . $i . '/' . $eventCount);\n                    if ($i % 10 == 0) {\n                        $this->Job->saveField('progress', $i * 80 / $eventCount);\n                    }\n                }\n                $tempFile->close();\n            }\n        }\n        $stixFile->append($stix_framing['footer']);\n        if ($tempFile) {\n            $tempFile->delete();\n        }\n        if (!$returnFile) {\n            $data = $stixFile->read();\n            $stixFile->delete();\n        }\n        return array('success' => 1, 'data' => $returnFile ? $stixFile->path : $data);\n    }\n\n    public function getAccessibleEventIds($include, $exclude, $includedTags, $excludedTags)\n    {\n        $conditions = array();\n\n        // get all of the event IDs based on include / exclude\n        if (!empty($include)) {\n            $conditions['OR'] = array('id' => $include);\n        }\n        if (!empty($exclude)) {\n            $conditions['NOT'] = array('id' => $exclude);\n        }\n        $events = $this->find('all', array(\n            'recursive' => -1,\n            'fields' => array('id', 'org_id', 'orgc_id', 'distribution'),\n            'conditions' => $conditions\n        ));\n        $ids = array();\n        foreach ($events as $event) {\n            $ids[] = $event['Event']['id'];\n        }\n        // get all of the event IDs based on includedTags / excludedTags\n        if (!empty($includedTags) || !empty($excludedTags)) {\n            $eventIDsFromTags = $this->EventTag->getEventIDsFromTags($includedTags, $excludedTags);\n            // get the intersect of the two\n            $ids = array_intersect($ids, $eventIDsFromTags);\n        }\n        return $ids;\n    }\n\n    public function generateRandomFileName()\n    {\n        return (new RandomTool())->random_str(false, 12);\n    }\n\n\n    public function sharingGroupRequired($field)\n    {\n        if ($this->data[$this->alias]['distribution'] == 4) {\n            return (!empty($field));\n        }\n        return true;\n    }\n\n    // convenience method to check whether a user can see an event\n    public function checkIfAuthorised($user, $id)\n    {\n        if (!isset($user['id'])) {\n            throw new MethodNotAllowedException('Invalid user.');\n        }\n        $this->id = $id;\n        if (!$this->exists()) {\n            return false;\n        }\n        if ($user['Role']['perm_site_admin']) {\n            return true;\n        }\n        $event = $this->find('first', array(\n            'conditions' => array('id' => $id),\n            'recursive' => -1,\n            'fields' => array('id', 'sharing_group_id', 'distribution', 'org_id')\n        ));\n        if ($event['Event']['org_id'] == $user['org_id'] || ($event['Event']['distribution'] > 0 && $event['Event']['distribution'] < 4)) {\n            return true;\n        }\n        if ($event['Event']['distribution'] == 4 && $this->SharingGroup->checkIfAuthorised($user, $event['Event']['sharing_group_id'])) {\n            return true;\n        }\n        return false;\n    }\n\n    // expects a date string in the YYYY-MM-DD format\n    // returns the passed string or false if the format is invalid\n    // based on the fix provided by stevengoosensB\n    public function dateFieldCheck($date)\n    {\n        // regex check for from / to field by stevengoossensB\n        return (preg_match('/^[0-9]{4}-(0[1-9]|1[012])-(0[1-9]|1[0-9]|2[0-9]|3[01])$/', $date)) ? $date : false;\n    }\n\n    public function resolveTimeDelta($delta)\n    {\n        if (is_numeric($delta)) {\n            return $delta;\n        }\n        $multiplierArray = array('d' => 86400, 'h' => 3600, 'm' => 60, 's' => 1);\n        $multiplier = $multiplierArray['d'];\n        $lastChar = strtolower(substr($delta, -1));\n        if (!is_numeric($lastChar) && array_key_exists($lastChar, $multiplierArray)) {\n            $multiplier = $multiplierArray[$lastChar];\n            $delta = substr($delta, 0, -1);\n        } else {\n            // invalid filter, make sure we don't return anything\n            return time() + 1;\n        }\n        if (!is_numeric($delta)) {\n            // Same here. (returning false dumps the whole database)\n            return time() + 1;\n        }\n        return time() - ($delta * $multiplier);\n    }\n\n    private function __prepareAttributeForView(\n        $attribute,\n        $correlatedAttributes,\n        $correlatedShadowAttributes,\n        $filterType = false,\n        &$eventWarnings,\n        $warningLists\n    ) {\n        $attribute['objectType'] = 'attribute';\n        $include = true;\n        if ($filterType && !in_array($filterType, array('proposal', 'correlation', 'warning'))) {\n            if (!in_array($attribute['type'], $this->Attribute->typeGroupings[$filterType])) {\n                $include = false;\n            }\n        }\n        if ($filterType === 'proposal' && empty($attribute['ShadowAttribute'])) {\n            $include = false;\n        }\n        if ($filterType === 'correlation' && !in_array($attribute['id'], $correlatedAttributes)) {\n            $include = false;\n        }\n        if (!empty($attribute['ShadowAttribute'])) {\n            $temp = array();\n            foreach ($attribute['ShadowAttribute'] as $k => $proposal) {\n                $result = $this->__prepareProposalForView(\n                    $proposal,\n                    $correlatedShadowAttributes,\n                    $filterType,\n                    $eventWarnings,\n                    $warningLists\n                );\n                if ($result['include']) {\n                    $temp[] = $result['data'];\n                }\n            }\n            $attribute['ShadowAttribute'] = $temp;\n        }\n        $attribute = $this->__prepareGenericForView($attribute, $eventWarnings, $warningLists);\n        if ($filterType === 'warning') {\n            if (empty($attribute['warnings'])) {\n                $include = false;\n            }\n        }\n        return array('include' => $include, 'data' => $attribute);\n    }\n\n    private function __prepareProposalForView(\n        $proposal,\n        $correlatedShadowAttributes,\n        $filterType = false,\n        &$eventWarnings,\n        $warningLists\n    ) {\n        if ($proposal['proposal_to_delete']) {\n            $proposal['objectType'] = 'proposal_delete';\n        } else {\n            $proposal['objectType'] = 'proposal';\n        }\n\n        $include = true;\n        if ($filterType === 'correlation' && !in_array($proposal['id'], $correlatedShadowAttributes)) {\n            $include = false;\n        }\n        if ($filterType && !in_array($filterType, array('proposal', 'correlation', 'warning'))) {\n            if (!in_array($proposal['type'], $this->Attribute->typeGroupings[$filterType])) {\n                $include = false;\n            }\n        }\n        $proposal = $this->__prepareGenericForView($proposal, $eventWarnings, $warningLists);\n        if ($filterType === 'warning') {\n            if (empty($proposal['warnings'])) {\n                $include = false;\n            }\n        }\n        return array('include' => $include, 'data' => $proposal);\n    }\n\n    private function __prepareObjectForView(\n        $object,\n        $correlatedAttributes,\n        $correlatedShadowAttributes,\n        $filterType = false,\n        &$eventWarnings,\n        $warningLists\n    ) {\n        $object['category'] = $object['meta-category'];\n        $proposal['objectType'] = 'object';\n        // filters depend on child objects\n        $include = empty($filterType) || $filterType == 'object' || $object['meta-category'] === $filterType;\n        if ($filterType === 'correlation' || $filterType === 'proposal') {\n            $include = $this->__checkObjectByFilter($object, $filterType, $correlatedAttributes, $correlatedShadowAttributes);\n        }\n        if (!empty($object['Attribute'])) {\n            $temp = array();\n            foreach ($object['Attribute'] as $k => $proposal) {\n                $result = $this->__prepareAttributeForView(\n                    $proposal,\n                    $correlatedAttributes,\n                    $correlatedShadowAttributes,\n                    false,\n                    $eventWarnings,\n                    $warningLists\n                );\n                if ($result['include']) {\n                    $temp[] = $result['data'];\n                }\n            }\n            $object['Attribute'] = $temp;\n        }\n        if ($filterType === 'warning') {\n            $include = $this->__checkObjectByFilter($object, $filterType, $correlatedAttributes, $correlatedShadowAttributes);\n        }\n        return array('include' => $include, 'data' => $object);\n    }\n\n    private function __checkObjectByFilter($object, $filterType, $correlatedAttributes, $correlatedShadowAttributes)\n    {\n        $include = false;\n        switch ($filterType) {\n            case 'warning':\n                if (!empty($object['Attribute'])) {\n                    foreach ($object['Attribute'] as $k => $attribute) {\n                        if (!empty($attribute['warnings'])) {\n                            $include = true;\n                        }\n                        if (!empty($attribute['ShadowAttribute'])) {\n                            foreach ($attribute['ShadowAttribute'] as $shadowAttribute) {\n                                if (!empty($shadowAttribute['warnings'])) {\n                                    $include = true;\n                                }\n                            }\n                        }\n                    }\n                }\n                break;\n            case 'correlation':\n                if (!empty($object['Attribute'])) {\n                    foreach ($object['Attribute'] as $k => $attribute) {\n                        if (in_array($attribute['id'], $correlatedAttributes)) {\n                            $include = true;\n                        } else {\n                            if (!empty($attribute['ShadowAttribute'])) {\n                                foreach ($attribute['ShadowAttribute'] as $k => $shadowAttribute) {\n                                    if (in_array($shadowAttribute['id'], $correlatedShadowAttributes)) {\n                                        $include = true;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n                break;\n            case 'proposal':\n                if (!empty($object['Attribute'])) {\n                    foreach ($object['Attribute'] as $k => $attribute) {\n                        if (!empty($attribute['ShadowAttribute'])) {\n                            $include = true;\n                        }\n                    }\n                }\n                break;\n        }\n        return $include;\n    }\n\n    private function __prepareGenericForView(\n        $object,\n        &$eventWarnings,\n        $warningLists\n    ) {\n        if (!$this->__fTool) {\n            $this->__fTool = new FinancialTool();\n        }\n        if ($object['type'] == 'attachment' && preg_match('/.*\\.(jpg|png|jpeg|gif)$/i', $object['value'])) {\n            if (!empty($object['data'])) {\n                $object['image'] = $object['data'];\n            } else {\n                if ($object['objectType'] === 'proposal') {\n                    $object['image'] = $this->ShadowAttribute->base64EncodeAttachment($object);\n                } else {\n                    $object['image'] = $this->Attribute->base64EncodeAttachment($object);\n                }\n            }\n        }\n        if (isset($object['distribution']) && $object['distribution'] != 4) {\n            unset($object['SharingGroup']);\n        }\n        if ($object['objectType'] !== 'object') {\n            if ($object['category'] === 'Financial fraud') {\n                if (!$this->__fTool->validateRouter($object['type'], $object['value'])) {\n                    $object['validationIssue'] = true;\n                }\n            }\n        }\n        $object = $this->Warninglist->checkForWarning($object, $eventWarnings, $warningLists);\n        return $object;\n    }\n\n    public function rearrangeEventForView(&$event, $passedArgs = array(), $all = false)\n    {\n        $this->Warninglist = ClassRegistry::init('Warninglist');\n        $warningLists = $this->Warninglist->fetchForEventView();\n        foreach ($event['Event'] as $k => $v) {\n            if (is_array($v)) {\n                $event[$k] = $v;\n                unset($event['Event'][$k]);\n            }\n        }\n        $filterType = false;\n        if (isset($passedArgs['attributeFilter'])) {\n            if (in_array($passedArgs['attributeFilter'], array_keys($this->Attribute->typeGroupings)) || in_array($passedArgs['attributeFilter'], array('proposal', 'correlation', 'warning'))) {\n                $filterType = $passedArgs['attributeFilter'];\n            } else {\n                unset($passedArgs['attributeFilter']);\n            }\n        }\n        $eventArray = array();\n        $eventWarnings = array();\n        $correlatedAttributes = isset($event['RelatedAttribute']) ? array_keys($event['RelatedAttribute']) : array();\n        $correlatedShadowAttributes = isset($event['RelatedShadowAttribute']) ? array_keys($event['RelatedShadowAttribute']) : array();\n        $event['objects'] = array();\n        foreach ($event['Attribute'] as $attribute) {\n            $result = $this->__prepareAttributeForView(\n                $attribute,\n                $correlatedAttributes,\n                $correlatedShadowAttributes,\n                $filterType,\n                $eventWarnings,\n                $warningLists\n            );\n            if ($result['include']) {\n                $event['objects'][] = $result['data'];\n            }\n        }\n        unset($event['Attribute']);\n        if (!empty($event['ShadowAttribute'])) {\n            foreach ($event['ShadowAttribute'] as $proposal) {\n                $result = $this->__prepareProposalForView(\n                    $proposal,\n                    $correlatedShadowAttributes,\n                    $filterType,\n                    $eventWarnings,\n                    $warningLists\n                );\n                $event['objects'][] = $result['data'];\n            }\n        }\n        if (!empty($event['Object'])) {\n            foreach ($event['Object'] as $object) {\n                $object['objectType'] = 'object';\n                $result = $this->__prepareObjectForView(\n                    $object,\n                    $correlatedAttributes,\n                    $correlatedShadowAttributes,\n                    $filterType,\n                    $eventWarnings,\n                    $warningLists\n                );\n                if ($result['include']) {\n                    $event['objects'][] = $result['data'];\n                }\n            }\n        }\n        unset($event['Object']);\n        unset($event['ShadowAttribute']);\n        $referencedObjectFields = array('meta-category', 'name', 'uuid', 'id');\n        $objectReferenceCount = 0;\n        $referencedByArray = array();\n        foreach ($event['objects'] as $object) {\n            if (!in_array($object['objectType'], array('attribute', 'object'))) {\n                continue;\n            }\n            if (!empty($object['ObjectReference'])) {\n                foreach ($object['ObjectReference'] as $reference) {\n                    if (isset($reference['referenced_uuid'])) {\n                        $referencedByArray[$reference['referenced_uuid']][$object['objectType']][] = array(\n                            'meta-category' => $object['meta-category'],\n                            'name' => $object['name'],\n                            'uuid' => $object['uuid'],\n                            'id' => $object['id'],\n                            'object_type' => $object['objectType']\n                        );\n                    }\n                }\n            }\n        }\n        App::uses('CustomPaginationTool', 'Tools');\n        $customPagination = new CustomPaginationTool();\n        if ($all) {\n            $passedArgs['page'] = 0;\n        }\n        $params = $customPagination->applyRulesOnArray($event['objects'], $passedArgs, 'events', 'category');\n        foreach ($event['objects'] as $k => $object) {\n            if (isset($referencedByArray[$object['uuid']])) {\n                foreach ($referencedByArray[$object['uuid']] as $objectType => $references) {\n                    $event['objects'][$k]['referenced_by'][$objectType] = $references;\n                }\n            }\n        }\n        $params['total_elements'] = count($event['objects']);\n        $event['Event']['warnings'] = $eventWarnings;\n        return $params;\n    }\n\n    // pass along a json from the server filter rules\n    // returns a conditions set to be merged into pagination / event fetch / etc\n    public function filterRulesToConditions($rules)\n    {\n        $rules = json_decode($rules, true);\n        $operators = array('OR', 'NOT');\n        foreach ($operators as $op) {\n            if (!empty($rules['tags'][$op])) {\n                $event_ids = $this->EventTag->find('list', array(\n                    'recursive' => -1,\n                    'conditions' => array('EventTag.tag_id' => $rules['tags'][$op]),\n                    'fields' => array('EventTag.event_id')\n                ));\n                $rules['events'][$op] = $event_ids;\n            }\n        }\n        $conditions = array();\n        $fields = array('events' => 'Event.id', 'orgs' => 'Event.orgc_id');\n        foreach ($fields as $k => $field) {\n            $temp = array();\n            if (!empty($rules[$k]['OR'])) {\n                $temp['OR'][$field] = $rules[$k]['OR'];\n            }\n            if (!empty($rules[$k]['NOT'])) {\n                $temp['AND'][$field . ' !='] = $rules[$k]['NOT'];\n            }\n            $conditions['AND'][] = $temp;\n        }\n        return $conditions;\n    }\n\n    public function handleModuleResult($result, $event_id)\n    {\n        $resultArray = array();\n        $freetextResults = array();\n        App::uses('ComplexTypeTool', 'Tools');\n        $complexTypeTool = new ComplexTypeTool();\n        if (isset($result['results']) && !empty($result['results'])) {\n            foreach ($result['results'] as $k => &$r) {\n                if (!is_array($r['values'])) {\n                    $r['values'] = array($r['values']);\n                }\n                if (!isset($r['types']) && isset($r['type'])) {\n                    $r['types'] = array($r['type']);\n                }\n                if (!is_array($r['types'])) {\n                    $r['types'] = array($r['types']);\n                }\n                if (isset($r['categories']) && !is_array($r['categories'])) {\n                    $r['categories'] = array($r['categories']);\n                }\n                if (isset($r['tags']) && !is_array($r['tags'])) {\n                    $r['tags'] = array($r['tags']);\n                }\n                foreach ($r['values'] as &$value) {\n                    if (!is_array($r['values']) || !isset($r['values'][0])) {\n                        $r['values'] = array($r['values']);\n                    }\n                }\n                foreach ($r['values'] as $valueKey => &$value) {\n                    if (empty($value)) {\n                        unset($r['values'][$valueKey]);\n                        continue;\n                    }\n                    if (in_array('freetext', $r['types'])) {\n                        if (is_array($value)) {\n                            $value = json_encode($value);\n                        }\n                        $this->Warninglist = ClassRegistry::init('Warninglist');\n                        $complexTypeTool->setTLDs($this->Warninglist->fetchTLDLists());\n                        $freetextResults = array_merge($freetextResults, $complexTypeTool->checkComplexRouter($value, 'FreeText'));\n                        if (!empty($freetextResults)) {\n                            foreach ($freetextResults as &$ft) {\n                                $temp = array();\n                                foreach ($ft['types'] as $type) {\n                                    $temp[$type] = $type;\n                                }\n                                $ft['types'] = $temp;\n                                $ft['comment'] = isset($r['comment']) ? $r['comment'] : false;\n                            }\n                        }\n                        $r['types'] = array_diff($r['types'], array('freetext'));\n                        // if we just removed the only type in the result then more on to the next result\n                        if (empty($r['types'])) {\n                            continue 2;\n                        }\n                        $r['types'] = array_values($r['types']);\n                    }\n                }\n                foreach ($r['values'] as &$value) {\n                    $temp = array(\n                            'event_id' => $event_id,\n                            'types' => $r['types'],\n                            'default_type' => $r['types'][0],\n                            'comment' => isset($r['comment']) ? $r['comment'] : false,\n                            'to_ids' => isset($r['to_ids']) ? $r['to_ids'] : false,\n                            'value' => $value,\n                            'tags' => isset($r['tags']) ? $r['tags'] : false\n                    );\n                    if (isset($r['categories'])) {\n                        $temp['categories'] = $r['categories'];\n                        $temp['default_category'] = $r['categories'][0];\n                    }\n                    if (isset($r['data'])) {\n                        $temp['data'] = $r['data'];\n                    }\n                    if (isset($r['distribution'])) {\n                        $temp['distribution'] = $r['distribution'];\n                    }\n                    // if data_is_handled is set then MISP assumes that the sample is already zipped and encrypted\n                    // in this case it will not try to do this by itself - however it also won't create additional hashes\n                    if (isset($r['data_is_handled'])) {\n                        $temp['data_is_handled'] = $r['data_is_handled'];\n                    }\n                    $resultArray[] = $temp;\n                }\n            }\n            $resultArray = array_merge($resultArray, $freetextResults);\n        }\n        return $resultArray;\n    }\n\n    public function export($user = false, $module = false, $options = array())\n    {\n        if (empty($user)) {\n            return 'Invalid user.';\n        }\n        if (empty($module)) {\n            return 'Invalid module.';\n        }\n        $this->Module = ClassRegistry::init('Module');\n        $module = $this->Module->getEnabledModule($module, 'Export');\n        $events = $this->fetchEvent($user, $options);\n        if (empty($events)) {\n            return 'Invalid event.';\n        }\n        $standard_format = false;\n        $modulePayload = array('module' => $module['name']);\n        if (!empty($module['meta']['require_standard_format'])) {\n            $standard_format = true;\n        }\n        if (isset($module['meta']['config'])) {\n            foreach ($module['meta']['config'] as $conf) {\n                $modulePayload['config'][$conf] = Configure::read('Plugin.Export_' . $module['name'] . '_' . $conf);\n            }\n        }\n        if ($standard_format) {\n            App::uses('JSONConverterTool', 'Tools');\n            $converter = new JSONConverterTool();\n            foreach ($events as $k => $event) {\n                $events[$k] = $converter->convert($event, false, true);\n            }\n        }\n        $modulePayload['data'] = $events;\n        $result = $this->Module->queryModuleServer('/query', json_encode($modulePayload, true), false, 'Export');\n        return array(\n                'data' => $result['data'],\n                'extension' => $module['mispattributes']['outputFileExtension'],\n                'response' => $module['mispattributes']['responseType']\n        );\n    }\n\n    public function getSightingData($event)\n    {\n        $this->Sighting = ClassRegistry::init('Sighting');\n        if (!empty($event['Sighting'])) {\n            $attributeSightings = array();\n            $attributeOwnSightings = array();\n            $attributeSightingsPopover = array();\n            $sightingsData = array();\n            $sparklineData = array();\n            $startDates = array();\n            $range = (!empty(Configure::read('MISP.Sightings_range')) && is_numeric(Configure::read('MISP.Sightings_range'))) ? Configure::read('MISP.Sightings_range') : 365;\n            $range = strtotime(\"-\" . $range . \" days\", time());\n            foreach ($event['Sighting'] as $sighting) {\n                $type = $this->Sighting->type[$sighting['type']];\n                if (!isset($sightingsData[$sighting['attribute_id']][$type])) {\n                    $sightingsData[$sighting['attribute_id']][$type] = array('count' => 0);\n                }\n                $sightingsData[$sighting['attribute_id']][$type]['count']++;\n                $orgName = isset($sighting['Organisation']['name']) ? $sighting['Organisation']['name'] : 'Others';\n                if ($sighting['type'] == '0' && (!isset($startDates[$sighting['attribute_id']]) || $startDates[$sighting['attribute_id']] > $sighting['date_sighting'])) {\n                    if ($sighting['date_sighting'] >= $range) {\n                        $startDates[$sighting['attribute_id']] = $sighting['date_sighting'];\n                    }\n                }\n                if ($sighting['type'] == '0' && (!isset($startDates['event']) || $startDates['event'] > $sighting['date_sighting'])) {\n                    if ($sighting['date_sighting'] >= $range) {\n                        $startDates['event'] = $sighting['date_sighting'];\n                    }\n                }\n                if (!isset($sightingsData[$sighting['attribute_id']][$type]['orgs'][$orgName])) {\n                    $sightingsData[$sighting['attribute_id']][$type]['orgs'][$orgName] = array('count' => 1, 'date' => $sighting['date_sighting']);\n                } else {\n                    $sightingsData[$sighting['attribute_id']][$type]['orgs'][$orgName]['count']++;\n                    if ($sightingsData[$sighting['attribute_id']][$type]['orgs'][$orgName]['date'] < $sighting['date_sighting']) {\n                        $sightingsData[$sighting['attribute_id']][$type]['orgs'][$orgName]['date'] = $sighting['date_sighting'];\n                    }\n                }\n                if ($sighting['type'] !== '0') {\n                    continue;\n                }\n                $date = date(\"Y-m-d\", $sighting['date_sighting']);\n                if (!isset($sparklineData[$sighting['attribute_id']][$date])) {\n                    $sparklineData[$sighting['attribute_id']][$date] = 1;\n                } else {\n                    $sparklineData[$sighting['attribute_id']][$date]++;\n                }\n                if (!isset($sparklineData['event'][$date])) {\n                    $sparklineData['event'][$date] = 1;\n                } else {\n                    $sparklineData['event'][$date]++;\n                }\n            }\n            $csv = array();\n            foreach ($startDates as $k => $v) {\n                $startDates[$k] = date('Y-m-d', $v);\n            }\n            $range = (!empty(Configure::read('MISP.Sightings_range')) && is_numeric(Configure::read('MISP.Sightings_range'))) ? Configure::read('MISP.Sightings_range') : 365;\n            foreach ($sparklineData as $aid => $data) {\n                if (!isset($startDates[$aid])) {\n                    continue;\n                }\n                $startDate = $startDates[$aid];\n                if (strtotime($startDate) < strtotime('-' . $range . ' days', time())) {\n                    $startDate = date('Y-m-d');\n                }\n                $startDate = date('Y-m-d', strtotime(\"-3 days\", strtotime($startDate)));\n                $to = date('Y-m-d', time());\n                $sighting = $data;\n                for ($date = $startDate; strtotime($date) <= strtotime($to); $date = date('Y-m-d', strtotime(\"+1 day\", strtotime($date)))) {\n                    if (!isset($csv[$aid])) {\n                        $csv[$aid] = 'Date,Close\\n';\n                    }\n                    if (isset($sighting[$date])) {\n                        $csv[$aid] .= $date . ',' . $sighting[$date] . '\\n';\n                    } else {\n                        $csv[$aid] .= $date . ',0\\n';\n                    }\n                }\n            }\n            return array(\n                    'data' => $sightingsData,\n                    'csv' => $csv\n            );\n        }\n        return array('data' => array(), 'csv' => array());\n    }\n\n    public function setSimpleConditions($parameterKey, $parameterValue, $conditions, $restrictScopeToEvents = false)\n    {\n        if (is_array($parameterValue)) {\n            $elements = $parameterValue;\n        } else {\n            $elements = explode('&&', $parameterValue);\n        }\n        App::uses('CIDRTool', 'Tools');\n        $cidr = new CIDRTool();\n        $subcondition = array();\n        foreach ($elements as $v) {\n            if ($v === '') {\n                continue;\n            }\n            if (substr($v, 0, 1) === '!') {\n                // check for an IPv4 address and subnet in CIDR notation (e.g. 127.0.0.1/8)\n                if ($parameterKey === 'value' && $cidr->checkCIDR(substr($v, 1), 4)) {\n                    $cidrresults = $cidr->CIDR(substr($v, 1));\n                    foreach ($cidrresults as $result) {\n                        $subcondition['AND'][] = array('Attribute.value NOT LIKE' => $result);\n                    }\n                } else {\n                    if ($parameterKey === 'org') {\n                        $found_orgs = $this->Org->find('all', array(\n                            'recursive' => -1,\n                            'conditions' => array('name' => substr($v, 1)),\n                        ));\n                        foreach ($found_orgs as $o) {\n                            $subcondition['AND'][] = array('Event.orgc_id !=' => $o['Org']['id']);\n                        }\n                    } elseif ($parameterKey === 'eventid') {\n                        if ($restrictScopeToEvents) {\n                            $subcondition['AND'][] = array('Event.id !=' => substr($v, 1));\n                        } else {\n                            $subcondition['AND'][] = array('Attribute.event_id !=' => substr($v, 1));\n                        }\n                    } elseif ($parameterKey === 'uuid') {\n                        $subcondition['AND'][] = array('Event.uuid !=' => substr($v, 1));\n                        $subcondition['AND'][] = array('Attribute.uuid !=' => substr($v, 1));\n                    } else {\n                        $lookup = substr($v, 1);\n                        if (strlen($lookup) != strlen(trim($lookup, '%'))) {\n                            $subcondition['AND'][] = array('Attribute.' . $parameterKey . ' NOT LIKE' => $lookup);\n                        } else {\n                            $subcondition['AND'][] = array('NOT' => array('Attribute.' . $parameterKey => $lookup));\n                        }\n                    }\n                }\n            } else {\n                // check for an IPv4 address and subnet in CIDR notation (e.g. 127.0.0.1/8)\n                if ($parameterKey === 'value' && $cidr->checkCIDR($v, 4)) {\n                    $cidrresults = $cidr->CIDR($v);\n                    foreach ($cidrresults as $result) {\n                        if (!empty($result)) {\n                            $subcondition['OR'][] = array('Attribute.value LIKE' => $result);\n                        }\n                    }\n                } else {\n                    if ($parameterKey === 'org') {\n                        $found_orgs = $this->Org->find('all', array(\n                                'recursive' => -1,\n                                'conditions' => array('name' => $v),\n                        ));\n                        foreach ($found_orgs as $o) {\n                            $subcondition['OR'][] = array('Event.orgc_id' => $o['Org']['id']);\n                        }\n                    } elseif ($parameterKey === 'eventid') {\n                        if ($restrictScopeToEvents) {\n                            $subcondition['OR'][] = array('Event.id' => $v);\n                        } else {\n                            $subcondition['OR'][] = array('Attribute.event_id' => $v);\n                        }\n                    } elseif ($parameterKey === 'uuid') {\n                        $subcondition['OR'][] = array('Attribute.uuid' => $v);\n                        $subcondition['OR'][] = array('Event.uuid' => $v);\n                    } else {\n                        if (!empty($v)) {\n                            if (strlen($v) != strlen(trim($v, '%'))) {\n                                $subcondition['AND'][] = array('Attribute.' . $parameterKey . ' LIKE' => $v);\n                            } else {\n                                $subcondition['AND'][] = array('Attribute.' . $parameterKey => $v);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (!empty($subcondition)) {\n            array_push($conditions['AND'], $subcondition);\n        }\n        return $conditions;\n    }\n\n    public function prepareEventForView()\n    {\n        // workaround to get the event dates in to the attribute relations\n        $relatedDates = array();\n        if (!empty($event['RelatedEvent'])) {\n            foreach ($event['RelatedEvent'] as $relation) {\n                $relatedDates[$relation['Event']['id']] = $relation['Event']['date'];\n            }\n            if (!empty($event['RelatedAttribute'])) {\n                foreach ($event['RelatedAttribute'] as $key => $relatedAttribute) {\n                    foreach ($relatedAttribute as $key2 => $relation) {\n                        $event['RelatedAttribute'][$key][$key2]['date'] = $relatedDates[$relation['id']];\n                    }\n                }\n            }\n        }\n        $dataForView = array(\n            'Attribute' => array('attrDescriptions', 'typeDefinitions', 'categoryDefinitions', 'distributionDescriptions', 'distributionLevels', 'shortDist'),\n            'Event' => array('fieldDescriptions')\n        );\n        foreach ($dataForView as $m => $variables) {\n            if ($m === 'Event') {\n                $currentModel = $this;\n            } elseif ($m === 'Attribute') {\n                $currentModel = $this->Attribute;\n            }\n            foreach ($variables as $alias => $variable) {\n                $this->set($alias, $currentModel->{$variable});\n            }\n        }\n    }\n\n    public function cacheSgids($user, $useCache = false)\n    {\n        if ($useCache && isset($this->__assetCache['sgids'])) {\n            return $this->__assetCache['sgids'];\n        } else {\n            $sgids = $this->SharingGroup->fetchAllAuthorised($user);\n            if (empty($sgids)) {\n                $sgids = array(-1);\n            }\n            if ($useCache) {\n                $this->__assetCache['sgids'] = $sgids;\n            }\n            return $sgids;\n        }\n    }\n\n    private function __cacheSharingGroupData($user, $useCache = false)\n    {\n        if ($useCache && isset($this->__assetCache['sharingGroupData'])) {\n            return $this->__assetCache['sharingGroupData'];\n        } else {\n            $sharingGroupDataTemp = $this->SharingGroup->fetchAllAuthorised($user, 'simplified');\n            $sharingGroupData = array();\n            foreach ($sharingGroupDataTemp as $k => $v) {\n                if (isset($v['Organisation'])) {\n                    $v['SharingGroup']['Organisation'] = $v['Organisation'];\n                }\n                if (isset($v['SharingGroupOrg'])) {\n                    $v['SharingGroup']['SharingGroupOrg'] = $v['SharingGroupOrg'];\n                }\n                if (isset($v['SharingGroupServer'])) {\n                    $v['SharingGroup']['SharingGroupServer'] = $v['SharingGroupServer'];\n                    foreach ($v['SharingGroup']['SharingGroupServer'] as &$sgs) {\n                        if ($sgs['server_id'] == 0) {\n                            $sgs['Server'] = array('id' => '0', 'url' => Configure::read('MISP.baseurl'), 'name' => Configure::read('MISP.baseurl'));\n                        }\n                    }\n                }\n                $sharingGroupData[$v['SharingGroup']['id']] = array('SharingGroup' => $v['SharingGroup']);\n            }\n            if ($useCache) {\n                $this->__assetCache['sharingGroupData'] = $sharingGroupData;\n            }\n            return $sharingGroupData;\n        }\n    }\n\n    private function __cachedelegatedEventIDs($user, $useCache = false)\n    {\n        if ($useCache && isset($this->__assetCache['delegatedEventIDs'])) {\n            return $this->__assetCache['delegatedEventIDs'];\n        } else {\n            $this->EventDelegation = ClassRegistry::init('EventDelegation');\n            $delegatedEventIDs = $this->EventDelegation->find('list', array(\n                'conditions' => array('EventDelegation.org_id' => $user['org_id']),\n                'fields' => array('event_id')\n            ));\n            if ($useCache) {\n                $this->__assetCache['delegationEventIDs'] = $delegatedEventIDs;\n            }\n            return $delegatedEventIDs;\n        }\n    }\n\n    private function __generateCachedTagFilters($tagRules, $useCache = false)\n    {\n        if ($useCache && isset($this->__assetCache['tagFilters'])) {\n            return $this->__assetCache['tagFilters'];\n        } else {\n            $filters = array();\n            $tag = ClassRegistry::init('Tag');\n            $args = $this->Attribute->dissectArgs($tagRules);\n            $tagArray = $this->EventTag->Tag->fetchEventTagIds($args[0], $args[1]);\n            $temp = array();\n            foreach ($tagArray[0] as $accepted) {\n                $temp['OR'][] = array('Event.id' => $accepted);\n            }\n            $filters[] = $temp;\n            $temp = array();\n            foreach ($tagArray[1] as $rejected) {\n                $temp['AND'][] = array('Event.id !=' => $rejected);\n            }\n            $filters[] = $temp;\n            if ($useCache) {\n                $this->__assetCache['tagFilters'] = $filters;\n            }\n            return $filters;\n        }\n    }\n\n    private function __destroyCaches()\n    {\n        $this->__assetCache = array();\n    }\n\n    public function unpublishEvent($id, $proposalLock = false)\n    {\n        $event = $this->find('first', array(\n            'recursive' => -1,\n            'conditions' => array('Event.id' => $id)\n        ));\n        if (empty($event)) {\n            return false;\n        }\n        $event['Event']['published'] = 0;\n        $date = new DateTime();\n        $event['Event']['timestamp'] = $date->getTimestamp();\n        if ($proposalLock) {\n            $event['Event']['proposal_email_lock'] = 0;\n        }\n        $event['Event']['unpublishAction'] = true;\n        return $this->save($event);\n    }\n\n    public function upload_stix($user, $filename, $stix_version, $original_file)\n    {\n        App::uses('Folder', 'Utility');\n        App::uses('File', 'Utility');\n        if ($stix_version == '2') {\n            $scriptFile = APP . 'files/scripts/stix2/stix2misp.py';\n            $tempFilePath = APP . 'files/scripts/tmp/' . $filename;\n            $shell_command = $this->getPythonVersion() . ' ' . $scriptFile . ' ' . $tempFilePath;\n            $output_path = $tempFilePath . '.stix2';\n        } elseif ($stix_version == '1' || $stix_version == '1.1' || $stix_version == '1.2') {\n            $scriptFile = APP . 'files/scripts/stix2misp.py';\n            $tempFilePath = APP . 'files/scripts/tmp/' . $filename;\n            $shell_command = $this->getPythonVersion() . ' ' . $scriptFile . ' ' . $filename;\n            $output_path = $tempFilePath . '.json';\n        } else {\n            throw new MethodNotAllowedException('Invalid STIX version');\n        }\n        $shell_command .=  ' ' . $original_file . ' ' . escapeshellarg(Configure::read('MISP.default_event_distribution')) . ' ' . escapeshellarg(Configure::read('MISP.default_attribute_distribution')) . ' 2>' . APP . 'tmp/logs/exec-errors.log';\n        $result = shell_exec($shell_command);\n        unlink($tempFilePath);\n        if (trim($result) == '1') {\n            $data = file_get_contents($output_path);\n            $data = json_decode($data, true);\n            unlink($output_path);\n            $created_id = false;\n            $validationIssues = false;\n            $result = $this->_add($data, true, $user, '', null, false, null, $created_id, $validationIssues);\n            if ($result) {\n                return $created_id;\n            }\n            return $validationIssues;\n        } else {\n            if (trim($result) == '2') {\n                $response = __('Issues while loading the stix file. ');\n            } elseif (trim($result) == '3') {\n                $response = __('Issues with the maec library. ');\n            } else {\n                $response = __('Issues executing the ingestion script or invalid input. ');\n            }\n            if (!$user['Role']['perm_site_admin']) {\n                $response .= __('Please ask your administrator to ');\n            } else {\n                $response .= __('Please ');\n            }\n            $response .= ' ' . __('check whether the dependencies for STIX are met via the diagnostic tool.');\n            return $response;\n        }\n    }\n\n    public function enrichmentRouter($options)\n    {\n        if (Configure::read('MISP.background_jobs')) {\n            $job = ClassRegistry::init('Job');\n            $job->create();\n            $data = array(\n                    'worker' => $this->__getPrioWorkerIfPossible(),\n                    'job_type' => 'enrichment',\n                    'job_input' => 'Event ID: ' . $options['event_id'] . ' modules: ' . json_encode($options['modules']),\n                    'status' => 0,\n                    'retries' => 0,\n                    'org_id' => $options['user']['org_id'],\n                    'org' => $options['user']['Organisation']['name'],\n                    'message' => 'Enriching event.',\n            );\n            $job->save($data);\n            $jobId = $job->id;\n            $process_id = CakeResque::enqueue(\n                    'prio',\n                    'EventShell',\n                    array('enrichment', $options['user']['id'], $options['event_id'], json_encode($options['modules']), $jobId),\n                    true\n            );\n            $job->saveField('process_id', $process_id);\n            return true;\n        } else {\n            $result = $this->enrichment($options);\n            return __('#' . $result . ' attributes have been created during the enrichment process.');\n        }\n    }\n\n    public function enrichment($params)\n    {\n        $option_fields = array('user', 'event_id', 'modules');\n        foreach ($option_fields as $option_field) {\n            if (empty($params[$option_field])) {\n                throw new MethodNotAllowedException(__('%s not set', $params[$option_field]));\n            }\n        }\n        $event = $this->fetchEvent($params['user'], array('eventid' => $params['event_id'], 'includeAttachments' => 1, 'flatten' => 1));\n        $this->Module = ClassRegistry::init('Module');\n        $enabledModules = $this->Module->getEnabledModules($params['user']);\n        if (empty($enabledModules)) {\n            return true;\n        }\n        $options = array();\n        foreach ($enabledModules['modules'] as $k => $temp) {\n            if (isset($temp['meta']['config'])) {\n                $settings = array();\n                foreach ($temp['meta']['config'] as $conf) {\n                    $settings[$conf] = Configure::read('Plugin.Enrichment_' . $temp['name'] . '_' . $conf);\n                }\n                $enabledModules['modules'][$k]['config'] = $settings;\n            }\n        }\n        if (empty($event)) {\n            throw new MethodNotAllowedException('Invalid event.');\n        }\n        $attributes_added = 0;\n        foreach ($event[0]['Attribute'] as $attribute) {\n            foreach ($enabledModules['modules'] as $module) {\n                if (in_array($module['name'], $params['modules'])) {\n                    if (in_array($attribute['type'], $module['mispattributes']['input'])) {\n                        $data = array('module' => $module['name'], $attribute['type'] => $attribute['value'], 'event_id' => $attribute['event_id'], 'attribute_uuid' => $attribute['uuid']);\n                        if (!empty($module['config'])) {\n                            $data['config'] = $module['config'];\n                        }\n                        $data = json_encode($data);\n                        $result = $this->Module->queryModuleServer('/query', $data, false, 'Enrichment');\n                        if (!$result) {\n                            throw new MethodNotAllowedException($type . ' service not reachable.');\n                        }\n                        //if (isset($result['error'])) $this->Session->setFlash($result['error']);\n                        if (!is_array($result)) {\n                            throw new Exception($result);\n                        }\n                        $attributes = $this->handleModuleResult($result, $attribute['event_id']);\n                        foreach ($attributes as $a) {\n                            $this->Attribute->create();\n                            $a['distribution'] = $attribute['distribution'];\n                            $a['sharing_group_id'] = $attribute['sharing_group_id'];\n                            $comment = 'Attribute #' . $attribute['id'] . ' enriched by ' . $module['name'] . '.';\n                            if (!empty($a['comment'])) {\n                                $a['comment'] .= PHP_EOL . $comment;\n                            } else {\n                                $a['comment'] = $comment;\n                            }\n                            $a['type'] = empty($a['default_type']) ? $a['types'][0] : $a['default_type'];\n                            $result = $this->Attribute->save($a);\n                            if ($result) {\n                                $attributes_added++;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return $attributes_added;\n    }\n\n    public function massageTags($data, $dataType = 'Event', $excludeGalaxy = false)\n    {\n        $data['Galaxy'] = array();\n        if (empty($this->GalaxyCluster)) {\n            $this->GalaxyCluster = ClassRegistry::init('GalaxyCluster');\n        }\n        // unset empty event tags that got added because the tag wasn't exportable\n        if (!empty($data[$dataType . 'Tag'])) {\n            foreach ($data[$dataType . 'Tag'] as $k => &$dataTag) {\n                if (empty($dataTag['Tag'])) {\n                    unset($data[$dataType . 'Tag'][$k]);\n                    continue;\n                }\n                if (!isset($excludeGalaxy) || !$excludeGalaxy) {\n                    if (substr($dataTag['Tag']['name'], 0, strlen('misp-galaxy:')) === 'misp-galaxy:') {\n                        $cluster = $this->GalaxyCluster->getCluster($dataTag['Tag']['name']);\n                        if ($cluster) {\n                            $found = false;\n                            foreach ($data['Galaxy'] as $k => $galaxy) {\n                                if ($galaxy['id'] == $cluster['GalaxyCluster']['Galaxy']['id']) {\n                                    $found = true;\n                                    $temp = $cluster;\n                                    unset($temp['GalaxyCluster']['Galaxy']);\n                                    $data['Galaxy'][$k]['GalaxyCluster'][] = $temp['GalaxyCluster'];\n                                    continue;\n                                }\n                            }\n                            if (!$found) {\n                                $data['Galaxy'][] = $cluster['GalaxyCluster']['Galaxy'];\n                                $temp = $cluster;\n                                unset($temp['GalaxyCluster']['Galaxy']);\n                                $data['Galaxy'][count($data['Galaxy']) - 1]['GalaxyCluster'][] = $temp['GalaxyCluster'];\n                            }\n                        }\n                    }\n                }\n            }\n            $data[$dataType . 'Tag'] = array_values($data[$dataType . 'Tag']);\n        }\n        return $data;\n    }\n\n    public function insertLock($user, $id)\n    {\n        $eventLock = ClassRegistry::init('EventLock');\n        $eventLock->insertLock($user, $id);\n    }\n\n    private function __logUploadResult($server, $event, $newTextBody)\n    {\n        $this->Log = ClassRegistry::init('Log');\n        $this->Log->create();\n        $this->Log->save(array(\n                'org' => 'SYSTEM',\n                'model' => 'Server',\n                'model_id' => $server['Server']['id'],\n                'email' => 'SYSTEM',\n                'action' => 'warning',\n                'user_id' => 0,\n                'title' => 'Uploading Event (' . $event['Event']['id'] . ') to Server (' . $server['Server']['id'] . ')',\n                'change' => 'Returned message: ', $newTextBody,\n        ));\n        return false;\n    }\n\n    public function processFreeTextData($user, $attributes, $id, $default_comment = '', $force = false, $adhereToWarninglists = false, $jobId = false)\n    {\n        $event = $this->find('first', array(\n            'conditions' => array('id' => $id),\n            'recursive' => -1,\n            'fields' => array('orgc_id', 'id', 'distribution', 'published', 'uuid'),\n        ));\n        if (!$user['Role']['perm_site_admin'] && !empty($event) && $event['Event']['orgc_id'] != $user['org_id']) {\n            $objectType = 'ShadowAttribute';\n        } elseif ($user['Role']['perm_site_admin'] && isset($force) && $force) {\n            $objectType = 'ShadowAttribute';\n        } else {\n            $objectType = 'Attribute';\n        }\n\n        if ($adhereToWarninglists) {\n            $this->Warninglist = ClassRegistry::init('Warninglist');\n            $warninglists = $this->Warninglist->fetchForEventView();\n        }\n        $saved = 0;\n        $failed = 0;\n        $attributeSources = array('attributes', 'ontheflyattributes');\n        $ontheflyattributes = array();\n        $i = 0;\n        $total = count($attributeSources);\n        if ($jobId) {\n            $this->Job = ClassRegistry::init('Job');\n            $this->Job->id = $jobId;\n        }\n        foreach ($attributeSources as $sourceKey => $source) {\n            foreach (${$source} as $k => $attribute) {\n                if ($attribute['type'] == 'ip-src/ip-dst') {\n                    $types = array('ip-src', 'ip-dst');\n                } elseif ($attribute['type'] == 'ip-src|port/ip-dst|port') {\n                    $types = array('ip-src|port', 'ip-dst|port');\n                } elseif ($attribute['type'] == 'malware-sample') {\n                    if (!isset($attribute['data_is_handled']) || !$attribute['data_is_handled']) {\n                        $result = $this->Attribute->handleMaliciousBase64($id, $attribute['value'], $attribute['data'], array('md5', 'sha1', 'sha256'), $objectType == 'ShadowAttribute' ? true : false);\n                        if (!$result['success']) {\n                            $failed++;\n                            continue;\n                        }\n                        $attribute['data'] = $result['data'];\n                        $shortValue = $attribute['value'];\n                        $attribute['value'] = $shortValue . '|' . $result['md5'];\n                        $additionalHashes = array('sha1', 'sha256');\n                        foreach ($additionalHashes as $hash) {\n                            $temp = $attribute;\n                            $temp['type'] = 'filename|' . $hash;\n                            $temp['value'] = $shortValue . '|' . $result[$hash];\n                            unset($temp['data']);\n                            $ontheflyattributes[] = $temp;\n                        }\n                    }\n                    $types = array($attribute['type']);\n                } else {\n                    $types = array($attribute['type']);\n                }\n                foreach ($types as $type) {\n                    $this->$objectType->create();\n                    $attribute['type'] = $type;\n                    if (empty($attribute['comment'])) {\n                        $attribute['comment'] = $default_comment;\n                    }\n                    $attribute['event_id'] = $id;\n                    if ($objectType == 'ShadowAttribute') {\n                        $attribute['org_id'] = $user['Role']['org_id'];\n                        $attribute['event_org_id'] = $event['Event']['orgc_id'];\n                        $attribute['email'] = $user['Role']['email'];\n                        $attribute['event_uuid'] = $event['Event']['uuid'];\n                    }\n                    // adhere to the warninglist\n                    if ($adhereToWarninglists) {\n                        if (!$this->Warninglist->filterWarninglistAttributes($warninglists, $attribute)) {\n                            if ($adhereToWarninglists == 'soft') {\n                                $attribute['to_ids'] = 0;\n                            } else {\n                                // just ignore the attribute\n                                continue;\n                            }\n                        }\n                    }\n                    $AttributSave = $this->$objectType->save($attribute);\n                    if ($AttributSave) {\n                        // If Tags, attach each tags to attribute\n                        if (!empty($attribute['tags'])) {\n                            foreach (explode(\",\", $attribute['tags']) as $tagName) {\n                                $this->Tag = ClassRegistry::init('Tag');\n                                $TagId = $this->Tag->captureTag(array('name' => $tagName), array('Role' => $user['Role']));\n                                $this->AttributeTag = ClassRegistry::init('AttributeTag');\n                                if (!$this->AttributeTag->attachTagToAttribute($AttributSave['Attribute']['id'], $id, $TagId)) {\n                                    throw new MethodNotAllowedException(__('Could not add tags.'));\n                                }\n                            }\n                        }\n                        $saved++;\n                    } else {\n                        $lastError = $this->$objectType->validationErrors;\n                        $failed++;\n                    }\n                }\n                if ($jobId) {\n                    if ($i % 20 == 0) {\n                        $this->Job->saveField('message', 'Attribute ' . $i . '/' . $total);\n                        $this->Job->saveField('progress', $i * 80 / $total);\n                    }\n                }\n            }\n        }\n        $emailResult = '';\n        $messageScope = $objectType == 'ShadowAttribute' ? 'proposals' : 'attributes';\n        if ($saved > 0) {\n            if ($objectType != 'ShadowAttribute') {\n                $event = $this->find('first', array(\n                        'conditions' => array('Event.id' => $id),\n                        'recursive' => -1\n                ));\n                if ($event['Event']['published'] == 1) {\n                    $event['Event']['published'] = 0;\n                }\n                $date = new DateTime();\n                $event['Event']['timestamp'] = $date->getTimestamp();\n                $this->save($event);\n            } else {\n                if (!$this->ShadowAttribute->sendProposalAlertEmail($id)) {\n                    $emailResult = \" but sending out the alert e-mails has failed for at least one recipient\";\n                }\n            }\n        }\n        if ($failed > 0) {\n            if ($failed == 1) {\n                $message = $saved . ' ' . $messageScope . ' created' . $emailResult . '. ' . $failed . ' ' . $messageScope . ' could not be saved. Reason for the failure: ' . json_encode($lastError);\n            } else {\n                $message = $saved . ' ' . $messageScope . ' created' . $emailResult . '. ' . $failed . ' ' . $messageScope . ' could not be saved. This may be due to attributes with similar values already existing.';\n            }\n        } else {\n            $message = $saved . ' ' . $messageScope . ' created' . $emailResult . '.';\n        }\n        if ($jobId) {\n            if ($i % 20 == 0) {\n                $this->Job->saveField('message', 'Processing complete. ' . $message);\n                $this->Job->saveField('progress', 100);\n            }\n        }\n        return $message;\n    }\n\n    public function processFreeTextDataRouter($user, $attributes, $id, $default_comment = '', $force = false, $adhereToWarninglists = false)\n    {\n        if (Configure::read('MISP.background_jobs')) {\n            $job = ClassRegistry::init('Job');\n            $job->create();\n            $data = array(\n                    'worker' => 'default',\n                    'job_type' => 'process_freetext_data',\n                    'job_input' => 'Event: ' . $id,\n                    'status' => 0,\n                    'retries' => 0,\n                    'org_id' => $user['org_id'],\n                    'org' => $user['Organisation']['name'],\n                    'message' => 'Processing...',\n            );\n            $job->save($data);\n            $randomFileName = $this->generateRandomFileName() . '.json';\n            App::uses('Folder', 'Utility');\n            App::uses('File', 'Utility');\n            $tempdir = new Folder(APP . 'tmp/cache/ingest', true, 0755);\n            $tempFile = new File(APP . 'tmp/cache/ingest' . DS . $randomFileName, true, 0644);\n            $tempData = array(\n                    'user' => $user,\n                    'attributes' => $attributes,\n                    'id' => $id,\n                    'default_comment' => $default_comment,\n                    'force' => $force,\n                    'adhereToWarninglists' => $adhereToWarninglists,\n                    'jobId' => $job->id\n            );\n\n            $writeResult = $tempFile->write(json_encode($tempData));\n            if (!$writeResult) {\n                return ($this->processFreeTextData($user, $attributes, $id, $default_comment = '', $force = false, $adhereToWarninglists = false));\n            }\n            $tempFile->close();\n            $jobId = $job->id;\n            $process_id = CakeResque::enqueue(\n                    'prio',\n                    'EventShell',\n                    array('processfreetext', $randomFileName),\n                    true\n            );\n            $job->saveField('process_id', $process_id);\n            return 'Freetext ingestion queued for background processing. Attributes will be added to the event as they are being processed.';\n        } else {\n            return ($this->processFreeTextData($user, $attributes, $id, $default_comment = '', $force = false, $adhereToWarninglists = false));\n        }\n    }\n\n    private function __attachReferences($user, &$event, $sgids, $fields)\n    {\n        if (!empty($event['Object'])) {\n            foreach ($event['Object'] as $k => $object) {\n                if (!empty($object['ObjectReference'])) {\n                    foreach ($object['ObjectReference'] as $k2 => $reference) {\n                        $type = array('Attribute', 'Object')[$reference['referenced_type']];\n                        $temp = $this->{$type}->find('first', array(\n                            'recursive' => -1,\n                            'fields' => array_merge($fields['common'], $fields[array('Attribute', 'Object')[$reference['referenced_type']]]),\n                            'conditions' => array('id' => $reference['referenced_id'])\n                        ));\n                        if (!empty($temp)) {\n                            if (!$user['Role']['perm_site_admin'] && $user['org_id'] != $event['Event']['orgc_id']) {\n                                if ($temp[$type]['distribution'] == 0 || ($temp[$type]['distribution'] == 4 && !in_array($temp[$type]['sharing_group_id'], $sgsids))) {\n                                    unset($object['ObjectReference'][$k2]);\n                                    continue;\n                                }\n                            }\n                            $event['Object'][$k]['ObjectReference'][$k2][$type] = $temp[$type];\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    public function restSearch($user, $returnFormat, $filters, $paramsOnly = false, $jobId = false, &$elementCounter = 0)\n    {\n        if (!isset($this->validFormats[$returnFormat][1])) {\n            throw new NotFoundException('Invalid output format.');\n        }\n        App::uses($this->validFormats[$returnFormat][1], 'Export');\n        $exportTool = new $this->validFormats[$returnFormat][1]();\n\n        if ($jobId) {\n            $this->Job = ClassRegistry::init('Job');\n            $this->Job->id = $jobId;\n        }\n\n        if (empty($exportTool->non_restrictive_export)) {\n            if (!isset($filters['to_ids'])) {\n                $filters['to_ids'] = 1;\n            }\n            if (!isset($filters['published'])) {\n                $filters['published'] = 1;\n            }\n        }\n        if (!empty($filters['ignore'])) {\n            $filters['to_ids'] = array(0, 1);\n            $filters['published'] = array(0, 1);\n        }\n        if (!empty($filters['quickFilter'])) {\n            $filters['searchall'] = $filters['quickFilter'];\n            if (!empty($filters['value'])) {\n                unset($filters['value']);\n            }\n        }\n        if (isset($filters['searchall'])) {\n            if (!empty($filters['value'])) {\n                $filters['wildcard'] = $filters['value'];\n            } else {\n                $filters['wildcard'] = $filters['searchall'];\n            }\n        }\n        $filters['include_attribute_count'] = 1;\n        $eventid = $this->filterEventIds($user, $filters);\n        $eventCount = count($eventid);\n        $eventids_chunked = $this->__clusterEventIds($exportTool, $eventid);\n        unset($eventid);\n        if (!empty($exportTool->additional_params)) {\n            $filters = array_merge($filters, $exportTool->additional_params);\n        }\n        $exportToolParams = array(\n            'user' => $user,\n            'params' => array(),\n            'returnFormat' => $returnFormat,\n            'scope' => 'Event',\n            'filters' => $filters\n        );\n        if (empty($exportTool->non_restrictive_export)) {\n            if (!isset($filters['to_ids'])) {\n                $filters['to_ids'] = 1;\n            }\n            if (!isset($filters['published'])) {\n                $filters['published'] = 1;\n            }\n        }\n        $tmpfile = tmpfile();\n        fwrite($tmpfile, $exportTool->header($exportToolParams));\n        $i = 0;\n        if (!empty($filters['withAttachments'])) {\n            $filters['includeAttachments'] = 1;\n        }\n        $this->Whitelist = ClassRegistry::init('Whitelist');\n        foreach ($eventids_chunked as $chunk_index => $chunk) {\n            $filters['eventid'] = $chunk;\n            if (!empty($filters['tags']['NOT'])) {\n                $filters['blockedAttributeTags'] = $filters['tags']['NOT'];\n            }\n            $result = $this->fetchEvent(\n                $user,\n                $filters,\n                true\n            );\n            if (!empty($result)) {\n                foreach ($result as $event) {\n                    $elementCounter++;\n                    if ($jobId && $i%10 == 0) {\n                        $this->Job->saveField('progress', intval((100 * $i) / $eventCount));\n                        $this->Job->saveField('message', 'Converting Event ' . $i . '/' . $eventCount . '.');\n                    }\n                    $result = $this->Whitelist->removeWhitelistedFromArray($result, false);\n                    $temp = $exportTool->handler($event, $exportToolParams);\n                    if ($temp !== '') {\n                        if ($i !== 0) {\n                            $temp = $exportTool->separator($exportToolParams) . $temp;\n                        }\n                        fwrite($tmpfile, $temp);\n                        $i++;\n                    }\n                }\n            }\n        }\n        unset($result);\n        unset($temp);\n        fwrite($tmpfile, $exportTool->footer($exportToolParams));\n        fseek($tmpfile, 0);\n        $final = fread($tmpfile, fstat($tmpfile)['size']);\n        fclose($tmpfile);\n        return $final;\n    }\n\n    /*\n     *  Receive a list of eventids in the id=>count format\n     *  Chunk them by the attribute count to fit the memory limits\n     *\n     */\n    private function __clusterEventIds($exportTool, $eventIds)\n    {\n        $memory_in_mb = $this->Attribute->convert_to_memory_limit_to_mb(ini_get('memory_limit'));\n        $memory_scaling_factor = isset($exportTool->memory_scaling_factor) ? $exportTool->memory_scaling_factor : 100;\n        $limit = $memory_in_mb * $memory_scaling_factor;\n        $eventIdList = array();\n        $continue = true;\n        $i = 0;\n        $current_chunk_size = 0;\n        while (!empty($eventIds)) {\n            foreach ($eventIds as $id => $count) {\n                if ($current_chunk_size == 0 && $count > $limit) {\n                    $eventIdList[$i][] = $id;\n                    $current_chunk_size = $count;\n                    unset($eventIds[$id]);\n                    $i++;\n                    break;\n                } else {\n                    if (($current_chunk_size + $count) > $limit) {\n                        $i++;\n                        $current_chunk_size = 0;\n                        break;\n                    } else {\n                        $current_chunk_size += $count;\n                        $eventIdList[$i][] = $id;\n                        unset($eventIds[$id]);\n                    }\n                }\n            }\n        }\n        return $eventIdList;\n    }\n}\n", "# -*- coding: utf-8 -*-\n#    Copyright (C) 2017-2018 CIRCL Computer Incident Response Center Luxembourg (smile gie)\n#    Copyright (C) 2017-2018 Christian Studer\n#\n#    This program is free software: you can redistribute it and/or modify\n#    it under the terms of the GNU Affero General Public License as\n#    published by the Free Software Foundation, either version 3 of the\n#    License, or (at your option) any later version.\n#\n#    This program is distributed in the hope that it will be useful,\n#    but WITHOUT ANY WARRANTY; without even the implied warranty of\n#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#    GNU Affero General Public License for more details.\n#\n#    You should have received a copy of the GNU Affero General Public License\n#    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nimport sys\nimport json\nimport os\nimport time\nimport uuid\nimport base64\nimport stix2misp_mapping\nimport stix.extensions.marking.ais\nfrom operator import attrgetter\nfrom pymisp import MISPEvent, MISPObject, MISPAttribute, __path__\nfrom stix.core import STIXPackage\nfrom collections import defaultdict\n\ncybox_to_misp_object = {\"Account\": \"credential\", \"AutonomousSystem\": \"asn\",\n                        \"EmailMessage\": \"email\", \"NetworkConnection\": \"network-connection\",\n                        \"NetworkSocket\": \"network-socket\", \"Process\": \"process\",\n                        \"x509Certificate\": \"x509\", \"Whois\": \"whois\"}\n\nthreat_level_mapping = {'High': '1', 'Medium': '2', 'Low': '3', 'Undefined': '4'}\n\ndescFilename = os.path.join(__path__[0], 'data/describeTypes.json')\nwith open(descFilename, 'r') as f:\n    categories = json.loads(f.read())['result'].get('categories')\n\nclass StixParser():\n    def __init__(self):\n        super(StixParser, self).__init__()\n        self.misp_event = MISPEvent()\n        self.misp_event['Galaxy'] = []\n        self.references = defaultdict(list)\n\n    ################################################################################\n    ##            LOADING & UTILITY FUNCTIONS USED BY BOTH SUBCLASSES.            ##\n    ################################################################################\n\n    # Load data from STIX document, and other usefull data\n    def load_event(self, args, filename, from_misp, stix_version):\n        self.outputname = '{}.json'.format(filename)\n        if len(args) > 0 and args[0]:\n            self.add_original_file(filename, args[0], stix_version)\n        try:\n            event_distribution = args[1]\n            if not isinstance(event_distribution, int):\n                event_distribution = int(event_distribution) if event_distribution.isdigit() else 5\n        except IndexError:\n            event_distribution = 5\n        try:\n            attribute_distribution = args[2]\n            if attribute_distribution == 'event':\n                attribute_distribution = event_distribution\n            elif not isinstance(attribute_distribution, int):\n                attribute_distribution = int(attribute_distribution) if attribute_distribution.isdigit() else event_distribution\n        except IndexError:\n            attribute_distribution = event_distribution\n        self.misp_event.distribution = event_distribution\n        self.__attribute_distribution = attribute_distribution\n        self.from_misp = from_misp\n        self.load_mapping()\n\n    # Convert the MISP event we create from the STIX document into json format\n    # and write it in the output file\n    def saveFile(self):\n        eventDict = self.misp_event.to_json()\n        with open(self.outputname, 'wt', encoding='utf-8') as f:\n            f.write(eventDict)\n\n    def add_original_file(self, filename, original_filename, version):\n        with open(filename, 'rb') as f:\n            sample = base64.b64encode(f.read()).decode('utf-8')\n        original_file = MISPObject('original-imported-file')\n        original_file.add_attribute(**{'type': 'attachment', 'value': original_filename,\n                                       'object_relation': 'imported-sample', 'data': sample})\n        original_file.add_attribute(**{'type': 'text', 'object_relation': 'format',\n                                       'value': 'STIX {}'.format(version)})\n        self.misp_event.add_object(**original_file)\n\n    # Load the mapping dictionary for STIX object types\n    def load_mapping(self):\n        self.attribute_types_mapping = {\n            \"AccountObjectType\": self.handle_credential,\n            'AddressObjectType': self.handle_address,\n            \"ArtifactObjectType\": self.handle_attachment,\n            \"ASObjectType\": self.handle_as,\n            \"CustomObjectType\": self.handle_custom,\n            \"DNSRecordObjectType\": self.handle_dns,\n            'DomainNameObjectType': self.handle_domain_or_url,\n            'EmailMessageObjectType': self.handle_email_attribute,\n            'FileObjectType': self.handle_file,\n            'HostnameObjectType': self.handle_hostname,\n            'HTTPSessionObjectType': self.handle_http,\n            'MutexObjectType': self.handle_mutex,\n            'NetworkConnectionObjectType': self.handle_network_connection,\n            'NetworkSocketObjectType': self.handle_network_socket,\n            'PDFFileObjectType': self.handle_file,\n            'PortObjectType': self.handle_port,\n            'ProcessObjectType': self.handle_process,\n            'SocketAddressObjectType': self.handle_socket_address,\n            'SystemObjectType': self.handle_system,\n            'URIObjectType': self.handle_domain_or_url,\n            \"WhoisObjectType\": self.handle_whois,\n            \"WindowsFileObjectType\": self.handle_file,\n            'WindowsRegistryKeyObjectType': self.handle_regkey,\n            \"WindowsExecutableFileObjectType\": self.handle_pe,\n            \"WindowsServiceObjectType\": self.handle_windows_service,\n            \"X509CertificateObjectType\": self.handle_x509\n        }\n\n        self.marking_mapping = {\n            'AIS:AISMarkingStructure': self.parse_AIS_marking,\n            'tlpMarking:TLPMarkingStructureType': self.parse_TLP_marking\n        }\n\n    def parse_marking(self, handling):\n        tags = []\n        if hasattr(handling, 'marking_structures') and handling.marking_structures:\n            for marking in handling.marking_structures:\n                try:\n                    tags.extend(self.marking_mapping[marking._XSI_TYPE](marking))\n                except KeyError:\n                    print(marking._XSI_TYPE, file=sys.stderr)\n                    continue\n        return tags\n\n    def set_distribution(self):\n        for attribute in self.misp_event.attributes:\n            attribute.distribution = self.__attribute_distribution\n        for misp_object in self.misp_event.objects:\n            misp_object.distribution = self.__attribute_distribution\n            for attribute in misp_object.attributes:\n                attribute.distribution = self.__attribute_distribution\n\n    # Make references between objects\n    def build_references(self):\n        for misp_object in self.misp_event.objects:\n            object_uuid = misp_object.uuid\n            if object_uuid in self.references:\n                for reference in self.references[object_uuid]:\n                    misp_object.add_reference(reference['idref'], reference['relationship'])\n\n    # Set info & title values in the new MISP event\n    def get_event_info(self):\n        info = \"Imported from external STIX event\"\n        try:\n            try:\n                title = self.event.stix_header.title\n            except AttributeError:\n                title = self.event.title\n            if title:\n                info = title\n        except AttributeError:\n            pass\n        return info\n\n    # Get timestamp & date values in the new MISP event\n    def get_timestamp_and_date(self):\n        stix_date = self.event.timestamp\n        try:\n            date = stix_date.split(\"T\")[0]\n        except AttributeError:\n            date = stix_date\n        return date, self.getTimestampfromDate(stix_date)\n\n    # Translate date into timestamp\n    @staticmethod\n    def getTimestampfromDate(date):\n        try:\n            try:\n                dt = date.split('+')[0]\n                d = int(time.mktime(time.strptime(dt, \"%Y-%m-%d %H:%M:%S\")))\n            except ValueError:\n                dt = date.split('.')[0]\n                d = int(time.mktime(time.strptime(dt, \"%Y-%m-%d %H:%M:%S\")))\n        except AttributeError:\n            d = int(time.mktime(date.timetuple()))\n        return d\n\n    ################################################################################\n    ##           STIX OBJECTS PARSING FUNCTIONS USED BY BOTH SUBCLASSES           ##\n    ################################################################################\n\n    # Define type & value of an attribute or object in MISP\n    def handle_attribute_type(self, properties, is_object=False, title=None, observable_id=None):\n        xsi_type = properties._XSI_TYPE\n        # try:\n        args = [properties]\n        if xsi_type in (\"FileObjectType\", \"PDFFileObjectType\", \"WindowsFileObjectType\"):\n            args.append(is_object)\n        elif xsi_type == \"ArtifactObjectType\":\n            args.append(title)\n        return self.attribute_types_mapping[xsi_type](*args)\n        # except AttributeError:\n        #     # ATM USED TO TEST TYPES\n        #     print(\"Unparsed type: {}\".format(xsi_type))\n        #     sys.exit(1)\n\n    # Return type & value of an ip address attribute\n    @staticmethod\n    def handle_address(properties):\n        if properties.is_source:\n            ip_type = \"ip-src\"\n        else:\n            ip_type = \"ip-dst\"\n        return ip_type, properties.address_value.value, \"ip\"\n\n    def handle_as(self, properties):\n        attributes = self.fetch_attributes_with_partial_key_parsing(properties, stix2misp_mapping._as_mapping)\n        return attributes[0] if len(attributes) == 1 else ('asn', self.return_attributes(attributes), '')\n\n    # Return type & value of an attachment attribute\n    @staticmethod\n    def handle_attachment(properties, title):\n        if properties.hashes:\n            return \"malware-sample\", \"{}|{}\".format(title, properties.hashes[0], properties.raw_artifact.value)\n        return stix2misp_mapping.eventTypes[properties._XSI_TYPE]['type'], title, properties.raw_artifact.value\n\n    # Return type & attributes of a credential object\n    def handle_credential(self, properties):\n        attributes = []\n        if properties.description:\n            attributes.append([\"text\", properties.description.value, \"text\"])\n        if properties.authentication:\n            for authentication in properties.authentication:\n                attributes += self.fetch_attributes_with_key_parsing(authentication, stix2misp_mapping._credential_authentication_mapping)\n        if properties.custom_properties:\n            for prop in properties.custom_properties:\n                if prop.name in stix2misp_mapping._credential_custom_types:\n                    attributes.append(['text', prop.value, prop.name])\n        return attributes[0] if len(attributes) == 1 else (\"credential\", self.return_attributes(attributes), \"\")\n\n    # Return type & attributes of a dns object\n    def handle_dns(self, properties):\n        relation = []\n        if properties.domain_name:\n            relation.append([\"domain\", str(properties.domain_name.value), \"\"])\n        if properties.ip_address:\n            relation.append([\"ip-dst\", str(properties.ip_address.value), \"\"])\n        if relation:\n            if len(relation) == '2':\n                domain = relation[0][1]\n                ip = relattion[1][1]\n                attributes = [[\"text\", domain, \"rrname\"], [\"text\", ip, \"rdata\"]]\n                rrtype = \"AAAA\" if \":\" in ip else \"A\"\n                attributes.append([\"text\", rrtype, \"rrtype\"])\n                return \"passive-dns\", self.return_attributes(attributes), \"\"\n            return relation[0]\n\n    # Return type & value of a domain or url attribute\n    @staticmethod\n    def handle_domain_or_url(properties):\n        event_types = stix2misp_mapping.eventTypes[properties._XSI_TYPE]\n        return event_types['type'], properties.value.value, event_types['relation']\n\n    # Return type & value of an email attribute\n    def handle_email_attribute(self, properties):\n        if properties.header:\n            header = properties.header\n            attributes = self.fetch_attributes_with_key_parsing(header, stix2misp_mapping._email_mapping)\n            if header.to:\n                for to in header.to:\n                    attributes.append([\"email-dst\", to.address_value.value, \"to\"])\n            if header.cc:\n                for cc in header.cc:\n                    attributes.append([\"email-dst\", cc.address_value.value, \"cc\"])\n        else:\n            attributes = []\n        if properties.attachments:\n            attributes.append(self.handle_email_attachment(properties.parent))\n        return attributes[0] if len(attributes) == 1 else (\"email\", self.return_attributes(attributes), \"\")\n\n    # Return type & value of an email attachment\n    @staticmethod\n    def handle_email_attachment(indicator_object):\n        properties = indicator_object.related_objects[0].properties\n        return [\"email-attachment\", properties.file_name.value, \"attachment\"]\n\n    # Return type & attributes of a file object\n    def handle_file(self, properties, is_object):\n        b_hash, b_file = False, False\n        attributes = []\n        if properties.hashes:\n            b_hash = True\n            for h in properties.hashes:\n                attributes.append(self.handle_hashes_attribute(h))\n        if properties.file_name:\n            value = properties.file_name.value\n            if value:\n                b_file = True\n                attribute_type, relation = stix2misp_mapping.eventTypes[properties._XSI_TYPE]\n                attributes.append([attribute_type, value, relation])\n        attributes.extend(self.fetch_attributes_with_keys(properties, stix2misp_mapping._file_mapping))\n        if len(attributes) == 1:\n            attribute = attributes[0]\n            return attribute[0] if attribute[2] != \"fullpath\" else \"filename\", attribute[1], \"\"\n        if len(attributes) == 2:\n            if b_hash and b_file:\n                return self.handle_filename_object(attributes, is_object)\n            path, filename = self.handle_filename_path_case(attributes)\n            if path and filename:\n                attribute_value = \"{}\\\\{}\".format(path, filename)\n                if '\\\\' in filename and path == filename:\n                    attribute_value = filename\n                return \"filename\", attribute_value, \"\"\n        return \"file\", self.return_attributes(attributes), \"\"\n\n    # Determine path & filename from a complete path or filename attribute\n    @staticmethod\n    def handle_filename_path_case(attributes):\n        path, filename = [\"\"] * 2\n        if attributes[0][2] == 'filename' and attributes[1][2] == 'path':\n            path = attributes[1][1]\n            filename = attributes[0][1]\n        elif attributes[0][2] == 'path' and attributes[1][2] == 'filename':\n            path = attributes[0][1]\n            filename = attributes[1][1]\n        return path, filename\n\n    # Return the appropriate type & value when we have 1 filename & 1 hash value\n    @staticmethod\n    def handle_filename_object(attributes, is_object):\n        for attribute in attributes:\n            attribute_type, attribute_value, _ = attribute\n            if attribute_type == \"filename\":\n                filename_value = attribute_value\n            else:\n                hash_type, hash_value = attribute_type, attribute_value\n        value = \"{}|{}\".format(filename_value,  hash_value)\n        if is_object:\n            # file object attributes cannot be filename|hash, so it is malware-sample\n            attr_type = \"malware-sample\"\n            return attr_type, value, attr_type\n        # it could be malware-sample as well, but STIX is losing this information\n        return \"filename|{}\".format(hash_type), value, \"\"\n\n    # Return type & value of a hash attribute\n    @staticmethod\n    def handle_hashes_attribute(properties):\n        hash_type = properties.type_.value.lower()\n        try:\n            hash_value = properties.simple_hash_value.value\n        except AttributeError:\n            hash_value = properties.fuzzy_hash_value.value\n        return hash_type, hash_value, hash_type\n\n    # Return type & value of a hostname attribute\n    @staticmethod\n    def handle_hostname(properties):\n        event_types = stix2misp_mapping.eventTypes[properties._XSI_TYPE]\n        return event_types['type'], properties.hostname_value.value, event_types['relation']\n\n    # Return type & value of a http request attribute\n    @staticmethod\n    def handle_http(properties):\n        client_request = properties.http_request_response[0].http_client_request\n        if client_request.http_request_header:\n            request_header = client_request.http_request_header\n            if request_header.parsed_header:\n                value = request_header.parsed_header.user_agent.value\n                return \"user-agent\", value, \"user-agent\"\n            elif request_header.raw_header:\n                value = request_header.raw_header.value\n                return \"http-method\", value, \"method\"\n        elif client_request.http_request_line:\n            value = client_request.http_request_line.http_method.value\n            return \"http-method\", value, \"method\"\n\n    # Return type & value of a mutex attribute\n    @staticmethod\n    def handle_mutex(properties):\n        event_types = stix2misp_mapping.eventTypes[properties._XSI_TYPE]\n        return event_types['type'], properties.name.value, event_types['relation']\n\n    # Return type & attributes of a network connection object\n    def handle_network_connection(self, properties):\n        attributes = self.fetch_attributes_from_sockets(properties, stix2misp_mapping._network_connection_addresses)\n        for prop in ('layer3_protocol', 'layer4_protocol', 'layer7_protocol'):\n            if getattr(properties, prop):\n                attributes.append(['text', attrgetter(\"{}.value\".format(prop))(properties), prop.replace('_', '-')])\n        if attributes:\n            return \"network-connection\", self.return_attributes(attributes), \"\"\n\n    # Return type & attributes of a network socket objet\n    def handle_network_socket(self, properties):\n        attributes = self.fetch_attributes_from_sockets(properties, stix2misp_mapping._network_socket_addresses)\n        attributes.extend(self.fetch_attributes_with_keys(properties, stix2misp_mapping._network_socket_mapping))\n        for prop in ('is_listening', 'is_blocking'):\n            if getattr(properties, prop):\n                attributes.append([\"text\", prop.split('_')[1], \"state\"])\n        if attributes:\n            return \"network-socket\", self.return_attributes(attributes), \"\"\n\n    # Return type & value of a port attribute\n    @staticmethod\n    def handle_port(*kwargs):\n        properties = kwargs[0]\n        event_types = stix2misp_mapping.eventTypes[properties._XSI_TYPE]\n        relation = event_types['relation']\n        if len(kwargs) > 1:\n            observable_id = kwargs[1]\n            if \"srcPort\" in observable_id:\n                relation = \"src-{}\".format(relation)\n            elif \"dstPort\" in observable_id:\n                relation = \"dst-{}\".format(relation)\n        return event_types['type'], properties.port_value.value, relation\n\n    # Return type & attributes of a process object\n    def handle_process(self, properties):\n        attributes = self.fetch_attributes_with_partial_key_parsing(properties, stix2misp_mapping._process_mapping)\n        if properties.child_pid_list:\n            for child in properties.child_pid_list:\n                attributes.append([\"text\", child.value, \"child-pid\"])\n        # if properties.port_list:\n        #     for port in properties.port_list:\n        #         attributes.append([\"src-port\", port.port_value.value, \"port\"])\n        if properties.network_connection_list:\n            references = []\n            for connection in properties.network_connection_list:\n                object_name, object_attributes, _ = self.handle_network_connection(connection)\n                object_uuid = str(uuid.uuid4())\n                misp_object = MISPObject(object_name)\n                misp_object.uuid = object_uuid\n                for attribute in object_attributes:\n                    misp_object.add_attribute(**attribute)\n                references.append(object_uuid)\n            return \"process\", self.return_attributes(attributes), {\"process_uuid\": references}\n        return \"process\", self.return_attributes(attributes), \"\"\n\n    # Return type & value of a regkey attribute\n    def handle_regkey(self, properties):\n        attributes = self.fetch_attributes_with_partial_key_parsing(properties, stix2misp_mapping._regkey_mapping)\n        if properties.values:\n            values = properties.values\n            value = values[0]\n            attributes += self.fetch_attributes_with_partial_key_parsing(value, stix2misp_mapping._regkey_value_mapping)\n        if len(attributes) in (2,3):\n            d_regkey = {key: value for (_, value, key) in attributes}\n            if 'hive' in d_regkey and 'key' in d_regkey:\n                regkey = \"{}\\\\{}\".format(d_regkey['hive'], d_regkey['key'])\n                if 'data' in d_regkey:\n                    return \"regkey|value\", \"{} | {}\".format(regkey, d_regkey['data']), \"\"\n                return \"regkey\", regkey, \"\"\n        return \"registry-key\", self.return_attributes(attributes), \"\"\n\n    @staticmethod\n    def handle_socket(attributes, socket, s_type):\n        for prop, mapping in stix2misp_mapping._socket_mapping.items():\n            if getattr(socket, prop):\n                attribute_type, properties_key, relation = mapping\n                attribute_type, relation = [elem.format(s_type) for elem in (attribute_type, relation)]\n                attributes.append([attribute_type, attrgetter('{}.{}.value'.format(prop, properties_key))(socket), relation])\n\n    # Parse a socket address object in order to return type & value\n    # of a composite attribute ip|port or hostname|port\n    def handle_socket_address(self, properties):\n        if properties.ip_address:\n            type1, value1, _ = self.handle_address(properties.ip_address)\n        elif properties.hostname:\n            type1 = \"hostname\"\n            value1 = properties.hostname.hostname_value.value\n        return \"{}|port\".format(type1), \"{}|{}\".format(value1, properties.port.port_value.value), \"\"\n\n    # Parse a system object to extract a mac-address attribute\n    @staticmethod\n    def handle_system(properties):\n        if properties.network_interface_list:\n            return \"mac-address\", str(properties.network_interface_list[0].mac), \"\"\n\n    # Parse a whois object:\n    # Return type & attributes of a whois object if we have the required fields\n    # Otherwise create attributes and return type & value of the last attribute to avoid crashing the parent function\n    def handle_whois(self, properties):\n        attributes = self.fetch_attributes_with_key_parsing(properties, stix2misp_mapping._whois_mapping)\n        required_one_of = True if attributes else False\n        if properties.registrants:\n            registrant = properties.registrants[0]\n            attributes += self.fetch_attributes_with_key_parsing(registrant, stix2misp_mapping._whois_registrant_mapping)\n        if properties.creation_date:\n            attributes.append([\"datetime\", properties.creation_date.value.strftime('%Y-%m-%d'), \"creation-date\"])\n            required_one_of = True\n        if properties.updated_date:\n            attributes.append([\"datetime\", properties.updated_date.value.strftime('%Y-%m-%d'), \"modification-date\"])\n        if properties.expiration_date:\n            attributes.append([\"datetime\", properties.expiration_date.value.strftime('%Y-%m-%d'), \"expiration-date\"])\n        if properties.nameservers:\n            for nameserver in properties.nameservers:\n                attributes.append([\"hostname\", nameserver.value.value, \"nameserver\"])\n        if properties.remarks:\n            attribute_type = \"text\"\n            relation = \"comment\" if attributes else attribute_type\n            attributes.append([attribute_type, properties.remarks.value, relation])\n            required_one_of = True\n        # Testing if we have the required attribute types for Object whois\n        if required_one_of:\n            # if yes, we return the object type and the attributes\n            return \"whois\", self.return_attributes(attributes), \"\"\n        # otherwise, attributes are added in the event, and one attribute is returned to not make the function crash\n        if len(attributes) == 1:\n            return attributes[0]\n        last_attribute = attributes.pop(-1)\n        for attribute in attributes:\n            attribute_type, attribute_value, attribute_relation = attribute\n            misp_attributes = {\"comment\": \"Whois {}\".format(attribute_relation)}\n            self.misp_event.add_attribute(attribute_type, attribute_value, **misp_attributes)\n        return last_attribute\n\n    # Return type & value of a windows service object\n    @staticmethod\n    def handle_windows_service(properties):\n        if properties.name:\n            return \"windows-service-name\", properties.name.value, \"\"\n\n    def handle_x509(self, properties):\n        attributes = self.handle_x509_certificate(properties.certificate) if properties.certificate else []\n        if properties.raw_certificate:\n            raw = properties.raw_certificate.value\n            try:\n                relation = \"raw-base64\" if raw == base64.b64encode(base64.b64decode(raw)).strip() else \"pem\"\n            except Exception:\n                relation = \"pem\"\n            attributes.append([\"text\", raw, relation])\n        if properties.certificate_signature:\n            signature = properties.certificate_signature\n            attribute_type = \"x509-fingerprint-{}\".format(signature.signature_algorithm.value.lower())\n            attributes.append([attribute_type, signature.signature.value, attribute_type])\n        return \"x509\", self.return_attributes(attributes), \"\"\n\n    @staticmethod\n    def handle_x509_certificate(certificate):\n        attributes = []\n        if certificate.validity:\n            validity = certificate.validity\n            for prop in stix2misp_mapping._x509_datetime_types:\n                if getattr(validity, prop):\n                    attributes.append(['datetime', attrgetter('{}.value'.format(prop))(validity), 'validity-{}'.format(prop.replace('_', '-'))])\n        if certificate.subject_public_key:\n            subject_pubkey = certificate.subject_public_key\n            if subject_pubkey.rsa_public_key:\n                rsa_pubkey = subject_pubkey.rsa_public_key\n                for prop in stix2misp_mapping._x509__x509_pubkey_types:\n                    if getattr(rsa_pubkey, prop):\n                        attributes.append(['text', attrgetter('{}.value'.format(prop))(rsa_pubkey), 'pubkey-info-{}'.format(prop)])\n            if subject_pubkey.public_key_algorithm:\n                attributes.append([\"text\", subject_pubkey.public_key_algorithm.value, \"pubkey-info-algorithm\"])\n        for prop in stix2misp_mapping._x509_certificate_types:\n            if getattr(certificate, prop):\n                attributes.append(['text', attrgetter('{}.value'.format(prop))(certificate), prop.replace('_', '-')])\n        return attributes\n\n    # Return type & attributes of the file defining a portable executable object\n    def handle_pe(self, properties):\n        pe_uuid = self.parse_pe(properties)\n        file_type, file_value, _ = self.handle_file(properties, False)\n        return file_type, file_value, pe_uuid\n\n    # Parse attributes of a portable executable, create the corresponding object,\n    # and return its uuid to build the reference for the file object generated at the same time\n    def parse_pe(self, properties):\n        misp_object = MISPObject('pe')\n        filename = properties.file_name.value\n        for attr in ('internal-filename', 'original-filename'):\n            misp_object.add_attribute(**dict(zip(('type', 'value', 'object_relation'),('filename', filename, attr))))\n        if properties.headers:\n            headers = properties.headers\n            header_object = MISPObject('pe-section')\n            if headers.entropy:\n                header_object.add_attribute(**{\"type\": \"float\", \"object_relation\": \"entropy\",\n                                               \"value\": headers.entropy.value.value})\n            file_header = headers.file_header\n            misp_object.add_attribute(**{\"type\": \"counter\", \"object_relation\": \"number-sections\",\n                                         \"value\": file_header.number_of_sections.value})\n            for h in file_header.hashes:\n                hash_type, hash_value, hash_relation = self.handle_hashes_attribute(h)\n                header_object.add_attribute(**{\"type\": hash_type, \"value\": hash_value, \"object_relation\": hash_relation})\n            if file_header.size_of_optional_header:\n                header_object.add_attribute(**{\"type\": \"size-in-bytes\", \"object_relation\": \"size-in-bytes\",\n                                               \"value\": file_header.size_of_optional_header.value})\n            self.misp_event.add_object(**header_object)\n            misp_object.add_reference(header_object.uuid, 'header-of')\n        if properties.sections:\n            for section in properties.sections:\n                section_uuid = self.parse_pe_section(section)\n                misp_object.add_reference(section_uuid, 'included-in')\n        self.misp_event.add_object(**misp_object)\n        return {\"pe_uuid\": misp_object.uuid}\n\n    # Parse attributes of a portable executable section, create the corresponding object,\n    # and return its uuid to build the reference for the pe object generated at the same time\n    def parse_pe_section(self, section):\n        section_object = MISPObject('pe-section')\n        header_hashes = section.header_hashes\n        for h in header_hashes:\n            hash_type, hash_value, hash_relation = self.handle_hashes_attribute(h)\n            section_object.add_attribute(**{\"type\": hash_type, \"value\": hash_value, \"object_relation\": hash_relation})\n        if section.entropy:\n            section_object.add_attribute(**{\"type\": \"float\", \"object_relation\": \"entropy\",\n                                            \"value\": section.entropy.value.value})\n        if section.section_header:\n            section_header = section.section_header\n            section_object.add_attribute(**{\"type\": \"text\", \"object_relation\": \"name\",\n                                            \"value\": section_header.name.value})\n            section_object.add_attribute(**{\"type\": \"size-in-bytes\", \"object_relation\": \"size-in-bytes\",\n                                            \"value\": section_header.size_of_raw_data.value})\n        self.misp_event.add_object(**section_object)\n        return section_object.uuid\n\n    ################################################################################\n    ##             MARKINGS PARSING FUNCTIONS USED BY BOTH SUBCLASSES             ##\n    ################################################################################\n\n    def parse_AIS_marking(self, marking):\n        tags = []\n        if hasattr(marking, 'is_proprietary') and marking.is_proprietary:\n            proprietary = \"Is\"\n            marking = marking.is_proprietary\n        elif hasattr(marking, 'not_proprietary') and marking.not_proprietary:\n            proprietary = \"Not\"\n            marking = marking.not_proprietary\n        else:\n            return\n        mapping = stix2misp_mapping._AIS_marking_mapping\n        prefix = mapping['prefix']\n        tags.append('{}{}'.format(prefix, mapping['proprietary'].format(proprietary)))\n        if hasattr(marking, 'cisa_proprietary'):\n            try:\n                cisa_proprietary = marking.cisa_proprietary.numerator\n                cisa_proprietary = 'true' if cisa_proprietary == 1 else 'false'\n                tags.append('{}{}'.format(prefix, mapping['cisa_proprietary'].format(cisa_proprietary)))\n            except AttributeError:\n                pass\n        for ais_field in ('ais_consent', 'tlp_marking'):\n            if hasattr(marking, ais_field) and getattr(marking, ais_field):\n                key, tag = mapping[ais_field]\n                tags.append('{}{}'.format(prefix, tag.format(getattr(getattr(marking, ais_field), key))))\n        return tags\n\n    def parse_TLP_marking(self, marking):\n        return ['tlp:{}'.format(marking.color.lower())]\n\n    ################################################################################\n    ##          FUNCTIONS HANDLING PARSED DATA, USED BY BOTH SUBCLASSES.          ##\n    ################################################################################\n\n    # The value returned by the indicators or observables parser is of type str or int\n    # Thus we can add an attribute in the MISP event with the type & value\n    def handle_attribute_case(self, attribute_type, attribute_value, data, attribute):\n        if attribute_type == 'attachment':\n            attribute['data'] = data\n        elif attribute_type == 'text':\n            attribute['comment'] = data\n        self.misp_event.add_attribute(attribute_type, attribute_value, **attribute)\n\n    # The value returned by the indicators or observables parser is a list of dictionaries\n    # These dictionaries are the attributes we add in an object, itself added in the MISP event\n    def handle_object_case(self, attribute_type, attribute_value, compl_data, to_ids=False, object_uuid=None):\n        misp_object = MISPObject(attribute_type)\n        if object_uuid:\n            misp_object.uuid = object_uuid\n        for attribute in attribute_value:\n            attribute['to_ids'] = to_ids\n            misp_object.add_attribute(**attribute)\n        if isinstance(compl_data, dict):\n            # if some complementary data is a dictionary containing an uuid,\n            # it means we are using it to add an object reference\n            if \"pe_uuid\" in compl_data:\n                misp_object.add_reference(compl_data['pe_uuid'], 'included-in')\n            if \"process_uuid\" in compl_data:\n                for uuid in compl_data[\"process_uuid\"]:\n                    misp_object.add_reference(uuid, 'connected-to')\n        self.misp_event.add_object(**misp_object)\n\n    ################################################################################\n    ##              UTILITY FUNCTIONS USED BY PARSING FUNCTION ABOVE              ##\n    ################################################################################\n\n    def fetch_attributes_from_sockets(self, properties, mapping_dict):\n        attributes = []\n        for prop, s_type in zip(mapping_dict, stix2misp_mapping._s_types):\n            address_property = getattr(properties, prop)\n            if address_property:\n                self.handle_socket(attributes, address_property, s_type)\n        return attributes\n\n    @staticmethod\n    def fetch_attributes_with_keys(properties, mapping_dict):\n        attributes = []\n        for prop, mapping in mapping_dict.items():\n            if getattr(properties,prop):\n                attribute_type, properties_key, relation = mapping\n                attributes.append([attribute_type, attrgetter(properties_key)(properties), relation])\n        return attributes\n\n    @staticmethod\n    def fetch_attributes_with_key_parsing(properties, mapping_dict):\n        attributes = []\n        for prop, mapping in mapping_dict.items():\n            if getattr(properties, prop):\n                attribute_type, properties_key, relation = mapping\n                attributes.append([attribute_type, attrgetter('{}.{}'.format(prop, properties_key))(properties), relation])\n        return attributes\n\n    @staticmethod\n    def fetch_attributes_with_partial_key_parsing(properties, mapping_dict):\n        attributes = []\n        for prop, mapping in mapping_dict.items():\n            if getattr(properties, prop):\n                attribute_type, relation = mapping\n                attributes.append([attribute_type, attrgetter('{}.value'.format(prop))(properties), relation])\n        return attributes\n\n    # Extract the uuid from a stix id\n    @staticmethod\n    def fetch_uuid(object_id):\n        try:\n            return \"-\".join(object_id.split(\"-\")[-5:])\n        except Exception:\n            return str(uuid.uuid4())\n\n    # Return the attributes that will be added in a MISP object as a list of dictionaries\n    @staticmethod\n    def return_attributes(attributes):\n        return_attributes = []\n        for attribute in attributes:\n            return_attributes.append(dict(zip(('type', 'value', 'object_relation'), attribute)))\n        return return_attributes\n\n\nclass StixFromMISPParser(StixParser):\n    def __init__(self):\n        super(StixFromMISPParser, self).__init__()\n        self.dates = []\n        self.timestamps = []\n        self.titles = []\n\n    def build_misp_dict(self, event):\n        for item in event.related_packages.related_package:\n            package = item.item\n            self.event = package.incidents[0]\n            self.set_timestamp_and_date()\n            self.set_event_info()\n            if self.event.related_indicators:\n                for indicator in self.event.related_indicators.indicator:\n                    self.parse_misp_indicator(indicator)\n            if self.event.related_observables:\n                for observable in self.event.related_observables.observable:\n                    self.parse_misp_observable(observable)\n            if self.event.history:\n                self.parse_journal_entries()\n            if self.event.information_source and self.event.information_source.references:\n                for reference in self.event.information_source.references:\n                    self.misp_event.add_attribute(**{'type': 'link', 'value': reference})\n            if package.ttps:\n                for ttp in package.ttps.ttps:\n                    if ttp.exploit_targets:\n                        self.parse_vulnerability(ttp.exploit_targets.exploit_target)\n                    # if ttp.handling:\n                    #     self.parse_tlp_marking(ttp.handling)\n        self.set_distribution()\n\n    # Return type & attributes (or value) of a Custom Object\n    def handle_custom(self, properties):\n        custom_properties = properties.custom_properties\n        attributes = []\n        for prop in custom_properties:\n            attribute_type, relation = prop.name.split(': ')\n            attribute_type = attribute_type.split(' ')[1]\n            attributes.append([attribute_type, prop.value, relation])\n        if len(attributes) > 1:\n            name = custom_properties[0].name.split(' ')[0]\n            return name, self.return_attributes(attributes), \"\"\n        return attributes[0]\n\n    def parse_journal_entries(self):\n        for entry in self.event.history.history_items:\n            journal_entry = entry.journal_entry.value\n            try:\n                entry_type, entry_value = journal_entry.split(': ')\n                if entry_type == \"MISP Tag\":\n                    self.parse_tag(entry_value)\n                elif entry_type.startswith('attribute['):\n                    _, category, attribute_type = entry_type.split('[')\n                    self.misp_event.add_attribute(**{'type': attribute_type[:-1], 'category': category[:-1], 'value': entry_value})\n                elif entry_type == \"Event Threat Level\":\n                    self.misp_event.threat_level_id = threat_level_mapping[entry_value]\n            except ValueError:\n                continue\n\n    # Parse indicators of a STIX document coming from our exporter\n    def parse_misp_indicator(self, indicator):\n        # define is an indicator will be imported as attribute or object\n        if indicator.relationship in categories:\n            self.parse_misp_attribute_indicator(indicator)\n        else:\n            self.parse_misp_object_indicator(indicator)\n\n    def parse_misp_observable(self, observable):\n        if observable.relationship in categories:\n            self.parse_misp_attribute_observable(observable)\n        else:\n            self.parse_misp_object_observable(observable)\n\n    # Parse STIX objects that we know will give MISP attributes\n    def parse_misp_attribute_indicator(self, indicator):\n        misp_attribute = {'to_ids': True, 'category': str(indicator.relationship),\n                          'uuid': self.fetch_uuid(indicator.id_)}\n        item = indicator.item\n        misp_attribute['timestamp'] = self.getTimestampfromDate(item.timestamp)\n        if item.observable:\n            observable = item.observable\n            self.parse_misp_attribute(observable, misp_attribute, to_ids=True)\n\n    def parse_misp_attribute_observable(self, observable):\n        misp_attribute = {'to_ids': False, 'category': str(observable.relationship),\n                          'uuid': self.fetch_uuid(observable.id_)}\n        if observable.item:\n            self.parse_misp_attribute(observable.item, misp_attribute)\n\n    def parse_misp_attribute(self, observable, misp_attribute, to_ids=False):\n        try:\n            properties = observable.object_.properties\n            if properties:\n                attribute_type, attribute_value, compl_data = self.handle_attribute_type(properties)\n                if isinstance(attribute_value, (str, int)):\n                    self.handle_attribute_case(attribute_type, attribute_value, compl_data, misp_attribute)\n                else:\n                    self.handle_object_case(attribute_type, attribute_value, compl_data, to_ids=to_ids)\n        except AttributeError:\n            attribute_dict = {}\n            for observables in observable.observable_composition.observables:\n                properties = observables.object_.properties\n                attribute_type, attribute_value, _ = self.handle_attribute_type(properties, observable_id=observable.id_)\n                attribute_dict[attribute_type] = attribute_value\n            attribute_type, attribute_value = self.composite_type(attribute_dict)\n            self.misp_event.add_attribute(attribute_type, attribute_value, **misp_attribute)\n\n    # Return type & value of a composite attribute in MISP\n    @staticmethod\n    def composite_type(attributes):\n        if \"port\" in attributes:\n            if \"ip-src\" in attributes:\n                return \"ip-src|port\", \"{}|{}\".format(attributes[\"ip-src\"], attributes[\"port\"])\n            elif \"ip-dst\" in attributes:\n                return \"ip-dst|port\", \"{}|{}\".format(attributes[\"ip-dst\"], attributes[\"port\"])\n            elif \"hostname\" in attributes:\n                return \"hostname|port\", \"{}|{}\".format(attributes[\"hostname\"], attributes[\"port\"])\n        elif \"domain\" in attributes:\n            if \"ip-src\" in attributes:\n                ip_value = attributes[\"ip-src\"]\n            elif \"ip-dst\" in attributes:\n                ip_value = attributes[\"ip-dst\"]\n            return \"domain|ip\", \"{}|{}\".format(attributes[\"domain\"], ip_value)\n\n    # Parse STIX object that we know will give MISP objects\n    def parse_misp_object_indicator(self, indicator):\n        object_type = str(indicator.relationship)\n        item = indicator.item\n        name = item.title.split(' ')[0]\n        if name not in ('passive-dns'):\n            self.fill_misp_object(item, name, to_ids=True)\n        else:\n            if object_type != \"misc\":\n                print(\"Unparsed Object type: {}\".format(name), file=sys.stderr)\n\n    def parse_misp_object_observable(self, observable):\n        object_type = str(observable.relationship)\n        observable = observable.item\n        observable_id = observable.id_\n        if object_type == \"file\":\n            name = \"registry-key\" if \"WinRegistryKey\" in observable_id else \"file\"\n        elif object_type == \"network\":\n            if \"Custom\" in observable_id:\n                name = observable_id.split(\"Custom\")[0].split(\":\")[1]\n            elif \"ObservableComposition\" in observable_id:\n                name = observable_id.split(\"_\")[0].split(\":\")[1]\n            else:\n                name = cybox_to_misp_object[observable_id.split('-')[0].split(':')[1]]\n        else:\n            name = cybox_to_misp_object[observable_id.split('-')[0].split(':')[1]]\n        try:\n            self.fill_misp_object(observable, name)\n        except Exception:\n            print(\"Unparsed Object type: {}\".format(observable.to_json()), file=sys.stderr)\n\n    # Create a MISP object, its attributes, and add it in the MISP event\n    def fill_misp_object(self, item, name, to_ids=False):\n        uuid = self.fetch_uuid(item.id_)\n        try:\n            misp_object = MISPObject(name)\n            misp_object.uuid = uuid\n            if to_ids:\n                observables = item.observable.observable_composition.observables\n                misp_object.timestamp = self.getTimestampfromDate(item.timestamp)\n            else:\n                observables = item.observable_composition.observables\n            for observable in observables:\n                properties = observable.object_.properties\n                misp_attribute = MISPAttribute()\n                misp_attribute.type, misp_attribute.value, misp_attribute.object_relation = self.handle_attribute_type(properties, is_object=True, observable_id=observable.id_)\n                misp_attribute.to_ids = to_ids\n                misp_object.add_attribute(**misp_attribute)\n            self.misp_event.add_object(**misp_object)\n        except AttributeError:\n            properties = item.observable.object_.properties if to_ids else item.object_.properties\n            self.parse_observable(properties, to_ids, uuid)\n\n    # Create a MISP attribute and add it in its MISP object\n    def parse_observable(self, properties, to_ids, uuid):\n        attribute_type, attribute_value, compl_data = self.handle_attribute_type(properties)\n        if isinstance(attribute_value, (str, int)):\n            attribute = {'to_ids': to_ids, 'uuid': uuid}\n            self.handle_attribute_case(attribute_type, attribute_value, compl_data, attribute)\n        else:\n            self.handle_object_case(attribute_type, attribute_value, compl_data, to_ids=to_ids, object_uuid=uuid)\n\n    def parse_tag(self, entry):\n        if entry.startswith('misp-galaxy:'):\n            tag_type, value = entry.split('=')\n            galaxy_type = tag_type.split(':')[1]\n            cluster = {'type': galaxy_type, 'value': value[1:-1], 'tag_name': entry}\n            self.misp_event['Galaxy'].append({'type': galaxy_type, 'GalaxyCluster': [cluster]})\n        self.misp_event.add_tag(entry)\n\n    def parse_vulnerability(self, exploit_targets):\n        for exploit_target in exploit_targets:\n            if exploit_target.item:\n                for vulnerability in exploit_target.item.vulnerabilities:\n                    self.misp_event.add_attribute(**{'type': 'vulnerability', 'value': vulnerability.cve_id})\n\n    def set_event_info(self):\n        info = self.get_event_info()\n        self.titles.append(info)\n\n    def set_timestamp_and_date(self):\n        if self.event.timestamp:\n            date, timestamp = self.get_timestamp_and_date()\n            self.dates.append(date)\n            self.timestamps.append(timestamp)\n\n\nclass ExternalStixParser(StixParser):\n    def __init__(self):\n        super(ExternalStixParser, self).__init__()\n        self.dns_objects = defaultdict(dict)\n        self.dns_ips = []\n\n    def build_misp_dict(self, event):\n        self.event = event\n        self.set_timestamp_and_date()\n        self.set_event_info()\n        header = self.event.stix_header\n        if hasattr(header, 'description') and hasattr(header.description, 'value'):\n            self.misp_event.add_attribute(**{'type': 'comment', 'value': header.description.value,\n                                             'comment': 'Imported from STIX header description'})\n        if hasattr(header, 'handling') and header.handling:\n            for handling in header.handling:\n                tags = self.parse_marking(handling)\n                for tag in  tags:\n                    self.misp_event.add_tag(tag)\n        if self.event.indicators:\n            self.parse_external_indicators(self.event.indicators)\n        if self.event.observables:\n            self.parse_external_observable(self.event.observables.observables)\n        if self.event.ttps:\n            self.parse_ttps(self.event.ttps.ttps)\n        if self.event.courses_of_action:\n            self.parse_coa(self.event.courses_of_action)\n        if self.dns_objects:\n            self.resolve_dns_objects()\n        self.set_distribution()\n        if self.references:\n            self.build_references()\n\n    def set_event_info(self):\n        info =  self.get_event_info()\n        self.misp_event.info = str(info)\n\n    def set_timestamp_and_date(self):\n        if self.event.timestamp:\n            date, timestamp = self.get_timestamp_and_date()\n            self.misp_event.date = date\n            self.misp_event.timestamp = timestamp\n\n    # Return type & attributes (or value) of a Custom Object\n    def handle_custom(self, properties):\n        custom_properties = properties.custom_properties\n        if len(custom_properties) > 1:\n            for prop in custom_properties[:-1]:\n                misp_attribute = {'type': 'text', 'value': prop.value, 'comment': prop.name}\n                self.misp_event.add_attribute(**misp_attribute)\n        to_return = custom_properties[-1]\n        return 'text', to_return.value, to_return.name\n\n    # Parse the courses of action field of an external STIX document\n    def parse_coa(self, courses_of_action):\n        for coa in courses_of_action:\n            misp_object = MISPObject('course-of-action')\n            if coa.title:\n                attribute = {'type': 'text', 'object_relation': 'name',\n                             'value': coa.title}\n                misp_object.add_attribute(**attribute)\n            for prop, properties_key in stix2misp_mapping._coa_mapping.items():\n                if getattr(coa, prop):\n                    attribute = {'type': 'text', 'object_relation': prop.replace('_', ''),\n                                 'value': attrgetter('{}.{}'.format(prop, properties_key))(coa)}\n                    misp_object.add_attribute(**attribute)\n            if coa.parameter_observables:\n                for observable in coa.parameter_observables.observables:\n                    properties = observable.object_.properties\n                    attribute = MISPAttribute()\n                    attribute.type, attribute.value, _ = self.handle_attribute_type(properties)\n                    referenced_uuid = str(uuid.uuid4())\n                    attribute.uuid = referenced_uuid\n                    self.misp_event.add_attribute(**attribute)\n                    misp_object.add_reference(referenced_uuid, 'observable', None, **attribute)\n            self.misp_event.add_object(**misp_object)\n\n    # Parse description of an external indicator or observable and add it in the MISP event as an attribute\n    def parse_description(self, stix_object):\n        if stix_object.description:\n            misp_attribute = {}\n            if stix_object.timestamp:\n                misp_attribute['timestamp'] = self.getTimestampfromDate(stix_object.timestamp)\n            self.misp_event.add_attribute(\"text\", stix_object.description.value, **misp_attribute)\n\n    # Parse indicators of an external STIX document\n    def parse_external_indicators(self, indicators):\n        for indicator in indicators:\n            self.parse_external_single_indicator(indicator)\n\n    def parse_external_single_indicator(self, indicator):\n        if hasattr(indicator, 'observable') and indicator.observable:\n            observable = indicator.observable\n            if hasattr(observable, 'object_') and observable.object_:\n                uuid = self.fetch_uuid(observable.object_.id_)\n                try:\n                    properties = observable.object_.properties\n                    if properties:\n                        attribute_type, attribute_value, compl_data = self.handle_attribute_type(properties)\n                        if isinstance(attribute_value, (str, int)):\n                            # if the returned value is a simple value, we build an attribute\n                            attribute = {'to_ids': True, 'uuid': uuid}\n                            if indicator.timestamp:\n                                attribute['timestamp'] = self.getTimestampfromDate(indicator.timestamp)\n                            if hasattr(observable, 'handling') and observable.handling:\n                                attribute['Tag'] = []\n                                for handling in observable.handling:\n                                    attribute['Tag'].extend(self.parse_marking(handling))\n                            parsed = self.special_parsing(observable.object_, attribute_type, attribute_value, attribute, uuid)\n                            if parsed is not None:\n                                return\n                            self.handle_attribute_case(attribute_type, attribute_value, compl_data, attribute)\n                        else:\n                            # otherwise, it is a dictionary of attributes, so we build an object\n                            self.handle_object_case(attribute_type, attribute_value, compl_data, to_ids=True, object_uuid=uuid)\n                except AttributeError:\n                    self.parse_description(indicator)\n        if hasattr(indicator, 'related_indicators') and indicator.related_indicators:\n            for related_indicator in indicator.related_indicators:\n                self.parse_external_single_indicator(related_indicator.item)\n\n    # Parse observables of an external STIX document\n    def parse_external_observable(self, observables):\n        for observable in observables:\n            title = observable.title\n            observable_object = observable.object_\n            try:\n                properties = observable_object.properties\n            except AttributeError:\n                self.parse_description(observable)\n                continue\n            if properties:\n                try:\n                    attribute_type, attribute_value, compl_data = self.handle_attribute_type(properties, title=title)\n                except KeyError:\n                    # print(\"Error with an object of type: {}\\n{}\".format(properties._XSI_TYPE, observable.to_json()))\n                    continue\n                object_uuid = self.fetch_uuid(observable_object.id_)\n                if isinstance(attribute_value, (str, int)):\n                    # if the returned value is a simple value, we build an attribute\n                    attribute = {'to_ids': False, 'uuid': object_uuid}\n                    if hasattr(observable, 'handling') and observable.handling:\n                        attribute['Tag'] = []\n                        for handling in observable.handling:\n                            attribute['Tag'].extend(self.parse_marking(handling))\n                    parsed = self.special_parsing(observable_object, attribute_type, attribute_value, attribute, object_uuid)\n                    if parsed is not None:\n                        continue\n                    self.handle_attribute_case(attribute_type, attribute_value, compl_data, attribute)\n                else:\n                    # otherwise, it is a dictionary of attributes, so we build an object\n                    if attribute_value:\n                        self.handle_object_case(attribute_type, attribute_value, compl_data, object_uuid=object_uuid)\n                    if observable_object.related_objects:\n                        for related_object in observable_object.related_objects:\n                            relationship = related_object.relationship.value.lower().replace('_', '-')\n                            self.references[object_uuid].append({\"idref\": self.fetch_uuid(related_object.idref),\n                                                                 \"relationship\": relationship})\n\n    # Parse the ttps field of an external STIX document\n    def parse_ttps(self, ttps):\n        for ttp in ttps:\n            if ttp.behavior and ttp.behavior.malware_instances:\n                mi = ttp.behavior.malware_instances[0]\n                if mi.types:\n                    mi_type = mi.types[0].value\n                    galaxy = {'type': mi_type}\n                    cluster = defaultdict(dict)\n                    cluster['type'] = mi_type\n                    if mi.description:\n                        cluster['description'] = mi.description.value\n                    cluster['value'] = ttp.title\n                    if mi.names:\n                        synonyms = []\n                        for name in mi.names:\n                            synonyms.append(name.value)\n                        cluster['meta']['synonyms'] = synonyms\n                    galaxy['GalaxyCluster'] = [cluster]\n                    self.misp_event['Galaxy'].append(galaxy)\n\n    # Parse a DNS object\n    def resolve_dns_objects(self):\n        for domain, domain_dict in self.dns_objects['domain'].items():\n            ip_reference = domain_dict['related']\n            domain_attribute = domain_dict['data']\n            if ip_reference in self.dns_objects['ip']:\n                misp_object = MISPObject('passive-dns')\n                domain_attribute['object_relation'] = \"rrname\"\n                misp_object.add_attribute(**domain_attribute)\n                ip = self.dns_objects['ip'][ip_reference]['value']\n                ip_attribute = {\"type\": \"text\", \"value\": ip, \"object_relation\": \"rdata\"}\n                misp_object.add_attribute(**ip_attribute)\n                rrtype = \"AAAA\" if \":\" in ip else \"A\"\n                rrtype_attribute = {\"type\": \"text\", \"value\": rrtype, \"object_relation\": \"rrtype\"}\n                misp_object.add_attribute(**rrtype_attribute)\n                self.misp_event.add_object(**misp_object)\n            else:\n                self.misp_event.add_attribute(**domain_attribute)\n        for ip, ip_dict in self.dns_objects['ip'].items():\n            if ip not in self.dns_ips:\n                self.misp_event.add_attribute(**ip_dict)\n\n    def special_parsing(self, observable_object, attribute_type, attribute_value, attribute, uuid):\n        if observable_object.related_objects:\n            related_objects = observable_object.related_objects\n            if attribute_type == \"url\" and len(related_objects) == 1 and related_objects[0].relationship.value == \"Resolved_To\":\n                related_ip = self.fetch_uuid(related_objects[0].idref)\n                self.dns_objects['domain'][uuid] = {\"related\": related_ip,\n                                                    \"data\": {\"type\": \"text\", \"value\": attribute_value}}\n                if related_ip not in self.dns_ips:\n                    self.dns_ips.append(related_ip)\n                return 1\n        if attribute_type in ('ip-src', 'ip-dst'):\n            attribute['type'] = attribute_type\n            attribute['value'] = attribute_value\n            self.dns_objects['ip'][uuid] = attribute\n            return 2\n\n\ndef generate_event(filename):\n    try:\n        return STIXPackage.from_xml(filename)\n    except Exception:\n        try:\n            import maec\n            print(2)\n        except ImportError:\n            print(3)\n        sys.exit(0)\n\ndef main(args):\n    filename = '{}/tmp/{}'.format(os.path.dirname(args[0]), args[1])\n    event = generate_event(filename)\n    title = event.stix_header.title\n    from_misp = (title is not None and \"Export from \" in title and \"MISP\" in title)\n    stix_parser = StixFromMISPParser() if from_misp else ExternalStixParser()\n    stix_parser.load_event(args[2:], filename, from_misp, event.version)\n    stix_parser.build_misp_dict(event)\n    stix_parser.saveFile()\n    print(1)\n\nif __name__ == \"__main__\":\n    main(sys.argv)\n"], "fixing_code": ["<?php\nApp::uses('AppModel', 'Model');\nApp::uses('CakeEmail', 'Network/Email');\nApp::uses('RandomTool', 'Tools');\nConfigure::load('config'); // This is needed to load GnuPG.bodyonlyencrypted\n\nclass Event extends AppModel\n{\n    public $actsAs = array(\n        'SysLogLogable.SysLogLogable' => array(\n            'userModel' => 'User',\n            'userKey' => 'user_id',\n            'change' => 'full'),\n        'Trim',\n        'Containable',\n    );\n\n    public $displayField = 'id';\n\n    public $virtualFields = array();\n\n    public $mispVersion = '2.4.0';\n\n    public $fieldDescriptions = array(\n        'threat_level_id' => array('desc' => 'Risk levels: *low* means mass-malware, *medium* means APT malware, *high* means sophisticated APT malware or 0-day attack', 'formdesc' => 'Risk levels: low: mass-malware medium: APT malware high: sophisticated APT malware or 0-day attack'),\n        'classification' => array('desc' => 'Set the Traffic Light Protocol classification. <ol><li><em>TLP:AMBER</em>- Share only within the organization on a need-to-know basis</li><li><em>TLP:GREEN:NeedToKnow</em>- Share within your constituency on the need-to-know basis.</li><li><em>TLP:GREEN</em>- Share within your constituency.</li></ol>'),\n        'submittedioc' => array('desc' => '', 'formdesc' => ''),\n        'analysis' => array('desc' => 'Analysis Levels: *Initial* means the event has just been created, *Ongoing* means that the event is being populated, *Complete* means that the event\\'s creation is complete', 'formdesc' => 'Analysis levels: Initial: event has been started Ongoing: event population is in progress Complete: event creation has finished'),\n        'distribution' => array('desc' => 'Describes who will have access to the event.')\n    );\n\n    public $analysisDescriptions = array(\n        0 => array('desc' => '*Initial* means the event has just been created', 'formdesc' => 'Event has just been created and is in an initial state'),\n        1 => array('desc' => '*Ongoing* means that the event is being populated', 'formdesc' => 'The analysis is still ongoing'),\n        2 => array('desc' => '*Complete* means that the event\\'s creation is complete', 'formdesc' => 'The event creator considers the analysis complete')\n    );\n\n    public $distributionDescriptions = array(\n        0 => array('desc' => 'This field determines the current distribution of the event', 'formdesc' => \"This setting will only allow members of your organisation on this server to see it.\"),\n        1 => array('desc' => 'This field determines the current distribution of the event', 'formdesc' => \"Organisations that are part of this MISP community will be able to see the event.\"),\n        2 => array('desc' => 'This field determines the current distribution of the event', 'formdesc' => \"Organisations that are either part of this MISP community or part of a directly connected MISP community will be able to see the event.\"),\n        3 => array('desc' => 'This field determines the current distribution of the event', 'formdesc' => \"This will share the event with all MISP communities, allowing the event to be freely propagated from one server to the next.\"),\n        4 => array('desc' => 'This field determines the current distribution of the event', 'formdesc' => \"This distribution of this event will be handled by the selected sharing group.\"),\n\n    );\n\n    public $analysisLevels = array(\n        0 => 'Initial', 1 => 'Ongoing', 2 => 'Completed'\n    );\n\n    public $distributionLevels = array(\n        0 => 'Your organisation only', 1 => 'This community only', 2 => 'Connected communities', 3 => 'All communities', 4 => 'Sharing group'\n    );\n\n    private $__fTool = false;\n\n    public $shortDist = array(0 => 'Organisation', 1 => 'Community', 2 => 'Connected', 3 => 'All', 4 => ' sharing Group');\n\n    private $__assetCache = array();\n\n    public $export_types = array(\n            'json' => array(\n                    'extension' => '.json',\n                    'type' => 'JSON',\n                    'scope' => 'Event',\n                    'requiresPublished' => 0,\n                    'params' => array('includeAttachments' => 1, 'ignore' => 1, 'returnFormat' => 'json'),\n                    'description' => 'Click this to download all events and attributes that you have access to in MISP JSON format.',\n            ),\n            'xml' => array(\n                    'extension' => '.xml',\n                    'type' => 'XML',\n                    'scope' => 'Event',\n                    'params' => array('includeAttachments' => 1, 'ignore' => 1, 'returnFormat' => 'xml'),\n                    'requiresPublished' => 0,\n                    'description' => 'Click this to download all events and attributes that you have access to in MISP XML format.',\n            ),\n            'csv_sig' => array(\n                    'extension' => '.csv',\n                    'type' => 'CSV_Sig',\n                    'scope' => 'Event',\n                    'requiresPublished' => 1,\n                    'params' => array('published' => 1, 'to_ids' => 1, 'returnFormat' => 'csv'),\n                    'description' => 'Click this to download all attributes that are indicators and that you have access to <small>(except file attachments)</small> in CSV format.',\n            ),\n            'csv_all' => array(\n                    'extension' => '.csv',\n                    'type' => 'CSV_All',\n                    'scope' => 'Event',\n                    'requiresPublished' => 0,\n                    'params' => array('ignore' => 1, 'returnFormat' => 'csv'),\n                    'description' => 'Click this to download all attributes that you have access to <small>(except file attachments)</small> in CSV format.',\n            ),\n            'suricata' => array(\n                    'extension' => '.rules',\n                    'type' => 'Suricata',\n                    'scope' => 'Attribute',\n                    'requiresPublished' => 1,\n                    'params' => array('returnFormat' => 'suricata'),\n                    'description' => 'Click this to download all network related attributes that you have access to under the Suricata rule format. Only published events and attributes marked as IDS Signature are exported. Administration is able to maintain a whitelist containing host, domain name and IP numbers to exclude from the NIDS export.',\n            ),\n            'snort' => array(\n                    'extension' => '.rules',\n                    'type' => 'Snort',\n                    'scope' => 'Attribute',\n                    'requiresPublished' => 1,\n                    'params' => array('returnFormat' => 'snort'),\n                    'description' => 'Click this to download all network related attributes that you have access to under the Snort rule format. Only published events and attributes marked as IDS Signature are exported. Administration is able to maintain a whitelist containing host, domain name and IP numbers to exclude from the NIDS export.',\n            ),\n            'bro' => array(\n                    'extension' => '.intel',\n                    'type' => 'Bro',\n                    'scope' => 'Attribute',\n                    'requiresPublished' => 1,\n                    'params' => array('returnFormat' => 'bro'),\n                    'description' => 'Click this to download all network related attributes that you have access to under the Bro rule format. Only published events and attributes marked as IDS Signature are exported. Administration is able to maintain a whitelist containing host, domain name and IP numbers to exclude from the NIDS export.',\n            ),\n            'stix' => array(\n                    'extension' => '.xml',\n                    'type' => 'STIX',\n                    'scope' => 'Event',\n                    'requiresPublished' => 1,\n                    'params' => array('returnFormat' => 'stix', 'includeAttachments' => 1),\n                    'description' => 'Click this to download an a STIX document containing the STIX version of all events and attributes that you have access to.'\n            ),\n            'stix2' => array(\n                    'extension' => '.json',\n                    'type' => 'STIX2',\n                    'scope' => 'Event',\n                    'requiresPublished' => 1,\n                    'params' => array('returnFormat' => 'stix2', 'includeAttachments' => 1),\n                    'description' => 'Click this to download an a STIX2 document containing the STIX2 version of all events and attributes that you have access to.'\n            ),\n            'rpz' => array(\n                    'extension' => '.txt',\n                    'type' => 'RPZ',\n                    'scope' => 'Attribute',\n                    'requiresPublished' => 1,\n                    'params' => array('returnFormat' => 'rpz'),\n                    'description' => 'Click this to download an RPZ Zone file generated from all ip-src/ip-dst, hostname, domain attributes. This can be useful for DNS level firewalling. Only published events and attributes marked as IDS Signature are exported.'\n            ),\n            'text' => array(\n                    'extension' => '.txt',\n                    'type' => 'TEXT',\n                    'scope' => 'Attribute',\n                    'requiresPublished' => 1,\n                    'params' => array('returnFormat' => 'text', 'includeAttachments' => 1),\n                    'description' => 'Click on one of the buttons below to download all the attributes with the matching type. This list can be used to feed forensic software when searching for susipicious files. Only published events and attributes marked as IDS Signature are exported.'\n            ),\n    );\n\n    public $validFormats = array(\n        'openioc' => array('xml', 'OpeniocExport', 'ioc'),\n        'json' => array('json', 'JsonExport', 'json'),\n        'xml' => array('xml', 'XmlExport', 'xml'),\n        'suricata' => array('txt', 'NidsSuricataExport', 'rules'),\n        'snort' => array('txt', 'NidsSnortExport', 'rules'),\n        'rpz' => array('rpz', 'RPZExport', 'rpz'),\n        'text' => array('text', 'TextExport', 'txt'),\n        'csv' => array('csv', 'CsvExport', 'csv'),\n        'stix' => array('xml', 'Stix1Export', 'xml'),\n        'stix2' => array('json', 'Stix2Export', 'json'),\n        'cache' => array('txt', 'CacheExport', 'cache')\n    );\n\n    public $csv_event_context_fields_to_fetch = array(\n        'event_info' => array('object' => false, 'var' => 'info'),\n        'event_member_org' => array('object' => 'Org', 'var' => 'name'),\n        'event_source_org' => array('object' => 'Orgc', 'var' => 'name'),\n        'event_distribution' => array('object' => false, 'var' => 'distribution'),\n        'event_threat_level_id' => array('object' => 'ThreatLevel', 'var' => 'name'),\n        'event_analysis' => array('object' => false, 'var' => 'analysis'),\n        'event_date' => array('object' => false, 'var' => 'date'),\n        'event_tag' => array('object' => 'Tag', 'var' => 'name')\n    );\n\n    public $validate = array(\n        'org_id' => array(\n            'valueNotEmpty' => array(\n                'rule' => array('valueNotEmpty'),\n            ),\n            'numeric' => array(\n                'rule' => array('numeric'),\n            ),\n        ),\n        'orgc_id' => array(\n            'valueNotEmpty' => array(\n                'rule' => array('valueNotEmpty'),\n            ),\n            'numeric' => array(\n                    'rule' => array('numeric'),\n            ),\n        ),\n        'date' => array(\n            'date' => array(\n                'rule' => array('date'),\n                'message' => 'Expected date format: YYYY-MM-DD',\n                //'allowEmpty' => false,\n                'required' => true,\n                //'last' => false, // Stop validation after this rule\n                //'on' => 'create', // Limit validation to 'create' or 'update' operations\n            ),\n        ),\n        'threat_level_id' => array(\n            'rule' => array('inList', array('1', '2', '3', '4')),\n            'message' => 'Options : 1, 2, 3, 4 (for High, Medium, Low, Undefined)',\n            'required' => true\n        ),\n\n        'distribution' => array(\n            'not_empty_if_sg' => array(\n                'rule' => array('inList', array('0', '1', '2', '3', '4')),\n                'message' => 'Options : Your organisation only, This community only, Connected communities, All communities',\n                //'allowEmpty' => false,\n                'required' => true,\n                //'last' => false, // Stop validation after this rule\n                //'on' => 'create', // Limit validation to 'create' or 'update' operations\n                )\n        ),\n\n        'sharing_group_id' => array(\n            'rule' => array('sharingGroupRequired'),\n                'message' => 'If the distribution is set to \"Sharing Group\", a sharing group has to be selected.',\n                //'required' => true,\n                //'allowEmpty' => true\n        ),\n\n        'analysis' => array(\n            'rule' => array('inList', array('0', '1', '2')),\n                'message' => 'Options : 0, 1, 2 (for Initial, Ongoing, Completed)',\n                //'allowEmpty' => false,\n                'required' => true,\n                //'last' => false, // Stop validation after this rule\n                //'on' => 'create', // Limit validation to 'create' or 'update' operations\n        ),\n        'info' => array(\n            'valueNotEmpty' => array(\n                'rule' => array('valueNotEmpty'),\n            ),\n        ),\n        'user_id' => array(\n            'numeric' => array(\n                'rule' => array('numeric')\n            )\n        ),\n        'published' => array(\n            'boolean' => array(\n                'rule' => array('boolean'),\n                //'message' => 'Your custom message here',\n                //'allowEmpty' => false,\n                //'required' => false,\n                //'last' => false, // Stop validation after this rule\n                //'on' => 'create', // Limit validation to 'create' or 'update' operations\n            ),\n        ),\n        'uuid' => array(\n            'uuid' => array(\n                'rule' => array('custom', '/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/'),\n                'message' => 'Please provide a valid UUID'\n            ),\n        ),\n        'extends_uuid' => array(\n            'uuid' => array(\n                'rule' => array('custom', '/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/'),\n                'message' => 'Please provide a valid UUID',\n                'allowEmpty' => true\n            )\n        )\n    );\n\n    // The Associations below have been created with all possible keys, those that are not needed can be removed\n    public $belongsTo = array(\n        'User' => array(\n            'className' => 'User',\n            'foreignKey' => 'user_id',\n            'conditions' => '',\n            'fields' => '',\n            'order' => ''\n        ),\n        'ThreatLevel' => array(\n            'className' => 'ThreatLevel',\n            'foreignKey' => 'threat_level_id'\n        ),\n        'Org' => array(\n                'className' => 'Organisation',\n                'foreignKey' => 'org_id'\n        ),\n        'Orgc' => array(\n                'className' => 'Organisation',\n                'foreignKey' => 'orgc_id'\n        ),\n        'SharingGroup' => array(\n                'className' => 'SharingGroup',\n                'foreignKey' => 'sharing_group_id'\n        )\n    );\n\n    public $hasMany = array(\n        'Attribute' => array(\n            'className' => 'Attribute',\n            'foreignKey' => 'event_id',\n            'dependent' => true,\t// cascade deletes\n            'conditions' => '',\n            'fields' => '',\n            'order' => array('Attribute.category ASC', 'Attribute.type ASC'),\n            'limit' => '',\n            'offset' => '',\n            'exclusive' => '',\n            'finderQuery' => '',\n            'counterQuery' => ''\n        ),\n        'ShadowAttribute' => array(\n            'className' => 'ShadowAttribute',\n            'foreignKey' => 'event_id',\n            'dependent' => true,\t// cascade deletes\n            'conditions' => '',\n            'fields' => '',\n            'order' => array('ShadowAttribute.old_id DESC', 'ShadowAttribute.old_id DESC'),\n            'limit' => '',\n            'offset' => '',\n            'exclusive' => '',\n            'finderQuery' => '',\n            'counterQuery' => ''\n        ),\n        'Object' => array(\n            'className' => 'MispObject',\n            'foreignKey' => 'event_id',\n            'dependent' => true,\n            'conditions' => '',\n            'fields' => '',\n            'order' => false,\n            'limit' => '',\n            'offset' => '',\n            'exclusive' => '',\n            'finderQuery' => '',\n            'counterQuery' => ''\n        ),\n        'EventTag' => array(\n            'className' => 'EventTag',\n            'dependent' => true,\n        ),\n        'Sighting' => array(\n            'className' => 'Sighting',\n            'dependent' => true,\n        )\n    );\n\n    public function beforeDelete($cascade = true)\n    {\n        // blacklist the event UUID if the feature is enabled\n        if (Configure::read('MISP.enableEventBlacklisting') !== false) {\n            $this->EventBlacklist = ClassRegistry::init('EventBlacklist');\n            $this->EventBlacklist->create();\n            $orgc = $this->Orgc->find('first', array('conditions' => array('Orgc.id' => $this->data['Event']['orgc_id']), 'recursive' => -1, 'fields' => array('Orgc.name')));\n            $this->EventBlacklist->save(array('event_uuid' => $this->data['Event']['uuid'], 'event_info' => $this->data['Event']['info'], 'event_orgc' => $orgc['Orgc']['name']));\n            if (!empty($this->data['Event']['id'])) {\n                if (Configure::read('Plugin.ZeroMQ_enable') && Configure::read('Plugin.ZeroMQ_attribute_notifications_enable')) {\n                    $pubSubTool = $this->getPubSubTool();\n                    $pubSubTool->event_save(array('Event' => $this->data['Event']), 'delete');\n                }\n            }\n        }\n\n        // delete all of the event->tag combinations that involve the deleted event\n        $this->EventTag->deleteAll(array('event_id' => $this->id));\n\n        // only delete the file if it exists\n        $attachments_dir = Configure::read('MISP.attachments_dir');\n        if (empty($attachments_dir)) {\n            $attachments_dir = $this->getDefaultAttachments_dir();\n        }\n\n        // Things get a little funky here\n        if ($this->attachmentDirIsS3()) {\n            // S3 doesn't have folders\n            // So we have to basically `ls` them to look for a prefix\n            $s3 = $this->getS3Client();\n            $s3->deleteDirectory($this->id);\n        } else {\n            $filepath = $attachments_dir . DS . $this->id;\n            App::uses('Folder', 'Utility');\n            if (is_dir($filepath)) {\n                if (!$this->destroyDir($filepath)) {\n                    throw new InternalErrorException('Delete of event file directory failed. Please report to administrator.');\n                }\n            }\n        }\n    }\n\n    public function destroyDir($dir)\n    {\n        if (!is_dir($dir) || is_link($dir)) {\n            return unlink($dir);\n        }\n        foreach (scandir($dir) as $file) {\n            if ($file == '.' || $file == '..') {\n                continue;\n            }\n            if (!$this->destroyDir($dir . DS . $file)) {\n                chmod($dir . DS . $file, 0777);\n                if (!$this->destroyDir($dir . DS . $file)) {\n                    return false;\n                }\n            }\n        }\n        return rmdir($dir);\n    }\n\n    public function beforeValidate($options = array())\n    {\n        parent::beforeValidate();\n        // analysis - setting correct vars\n        if (isset($this->data['Event']['analysis'])) {\n            switch ($this->data['Event']['analysis']) {\n                case 'Initial':\n                    $this->data['Event']['analysis'] = 0;\n                    break;\n                case 'Ongoing':\n                    $this->data['Event']['analysis'] = 1;\n                    break;\n                case 'Completed':\n                    $this->data['Event']['analysis'] = 2;\n                    break;\n            }\n        } else {\n            $this->data['Event']['analysis'] = 0;\n        }\n\n        if (!isset($this->data['Event']['threat_level_id'])) {\n            $this->data['Event']['threat_level_id'] = Configure::read('MISP.default_event_threat_level') ? Configure::read('MISP.default_event_threat_level') : 4;\n        }\n\n        // generate UUID if it doesn't exist\n        if (empty($this->data['Event']['uuid'])) {\n            $this->data['Event']['uuid'] = CakeText::uuid();\n        }\n\n        // Convert event ID to uuid if needed\n        if (!empty($this->data['Event']['extends_uuid']) && is_numeric($this->data['Event']['extends_uuid'])) {\n            $extended_event = $this->find('first', array(\n                'recursive' => -1,\n                'conditions' => array('Event.id' => $this->data['Event']['extends_uuid']),\n                'fields' => array('Event.uuid')\n            ));\n            if (empty($extended_event)) {\n                $this->data['Event']['extends_uuid'] = '';\n            } else {\n                $this->data['Event']['extends_uuid'] = $extended_event['Event']['uuid'];\n            }\n        }\n\n        // generate timestamp if it doesn't exist\n        if (empty($this->data['Event']['timestamp'])) {\n            $date = new DateTime();\n            $this->data['Event']['timestamp'] = $date->getTimestamp();\n        }\n\n        if (empty($this->data['Event']['date'])) {\n            $this->data['Event']['date'] = date('Y-m-d');\n        }\n\n        if (!isset($this->data['Event']['distribution']) || $this->data['Event']['distribution'] != 4) {\n            $this->data['Event']['sharing_group_id'] = 0;\n        }\n    }\n\n    public function afterSave($created, $options = array())\n    {\n        if (!Configure::read('MISP.completely_disable_correlation') && !$created) {\n            $this->Correlation = ClassRegistry::init('Correlation');\n            $db = $this->getDataSource();\n            if (isset($this->data['Event']['date'])) {\n                $this->Correlation->updateAll(array('Correlation.date' => $db->value($this->data['Event']['date'])), array('Correlation.event_id' => intval($this->data['Event']['id'])));\n            }\n            if (isset($this->data['Event']['info'])) {\n                $this->Correlation->updateAll(array('Correlation.info' => $db->value($this->data['Event']['info'])), array('Correlation.event_id' => intval($this->data['Event']['id'])));\n            }\n        }\n        if (empty($this->data['Event']['unpublishAction']) && empty($this->data['Event']['skip_zmq']) && Configure::read('Plugin.ZeroMQ_enable') && Configure::read('Plugin.ZeroMQ_event_notifications_enable')) {\n            $pubSubTool = $this->getPubSubTool();\n            $event = $this->quickFetchEvent($this->data['Event']['id']);\n            if (!empty($event)) {\n                $pubSubTool->event_save($event, $created ? 'add' : 'edit');\n            }\n        }\n    }\n\n    public function buildEventConditions($user)\n    {\n        $conditions = array();\n        if ($user['Role']['perm_site_admin']) {\n            return $conditions;\n        }\n        $sgids = $this->SharingGroup->fetchAllAuthorised($user);\n        $conditions['OR'] = array(\n            'Event.orgc_id' => $user['org_id'],\n            'Event.distribution' => array(1, 2, 3),\n            'AND' => array(\n                'Event.distribution' => 4,\n                'Event.sharing_group_id' => $sgids\n            )\n        );\n        return $conditions;\n    }\n\n    public function isOwnedByOrg($eventid, $org)\n    {\n        return $this->field('id', array('id' => $eventid, 'org_id' => $org)) === $eventid;\n    }\n\n    public function attachtagsToEvents($events)\n    {\n        $tagsToFetch = array();\n        foreach ($events as $k => $event) {\n            if (!empty($event['EventTag'])) {\n                foreach ($event['EventTag'] as $et) {\n                    $tagsToFetch[$et['tag_id']] = $et['tag_id'];\n                }\n            }\n        }\n        $tags = $this->EventTag->Tag->find('all', array(\n            'conditions' => array('Tag.id' => $tagsToFetch),\n            'recursive' => -1,\n            'order' => false\n        ));\n        $tags = Set::combine($tags, '{n}.Tag.id', '{n}');\n        foreach ($events as $k => $event) {\n            if (!empty($event['EventTag'])) {\n                foreach ($event['EventTag'] as $k2 => $et) {\n                    $events[$k]['EventTag'][$k2]['Tag'] = $tags[$et['tag_id']]['Tag'];\n                }\n            }\n        }\n        return $events;\n    }\n\n    // gets the logged in user + an array of events, attaches the correlation count to each\n    public function attachCorrelationCountToEvents($user, $events)\n    {\n        $sgids = $this->SharingGroup->fetchAllAuthorised($user);\n        if (!isset($sgids) || empty($sgids)) {\n            $sgids = array(-1);\n        }\n        $this->Correlation = ClassRegistry::init('Correlation');\n        $eventIds = Set::extract('/Event/id', $events);\n        $conditionsCorrelation = $this->__buildEventConditionsCorrelation($user, $eventIds, $sgids);\n        $correlations = $this->Correlation->find('all', array(\n            'fields' => array('Correlation.1_event_id', 'count(distinct(Correlation.event_id)) as count'),\n            'conditions' => $conditionsCorrelation,\n            'recursive' => -1,\n            'group' => array('Correlation.1_event_id'),\n        ));\n        $correlations = Hash::combine($correlations, '{n}.Correlation.1_event_id', '{n}.0.count');\n        foreach ($events as &$event) {\n            $event['Event']['correlation_count'] = (isset($correlations[$event['Event']['id']])) ? $correlations[$event['Event']['id']] : 0;\n        }\n        return $events;\n    }\n\n    public function attachSightingsCountToEvents($user, $events)\n    {\n        $eventIds = Set::extract('/Event/id', $events);\n        $this->Sighting = ClassRegistry::init('Sighting');\n        $sightings = $this->Sighting->find('all', array(\n            'fields' => array('Sighting.event_id', 'count(distinct(Sighting.id)) as count'),\n            'conditions' => array('event_id' => $eventIds),\n            'recursive' => -1,\n            'group' => array('event_id')\n        ));\n        $sightings = Hash::combine($sightings, '{n}.Sighting.event_id', '{n}.0.count');\n        foreach ($events as $key => $event) {\n            $events[$key]['Event']['sightings_count'] = (isset($sightings[$event['Event']['id']])) ? $sightings[$event['Event']['id']] : 0;\n        }\n        return $events;\n    }\n\n    public function attachProposalsCountToEvents($user, $events)\n    {\n        $eventIds = Set::extract('/Event/id', $events);\n        $proposals = $this->ShadowAttribute->find('all', array(\n                'fields' => array('ShadowAttribute.event_id', 'count(distinct(ShadowAttribute.id)) as count'),\n                'conditions' => array('event_id' => $eventIds, 'deleted' => 0),\n                'recursive' => -1,\n                'group' => array('event_id')\n        ));\n        $proposals = Hash::combine($proposals, '{n}.ShadowAttribute.event_id', '{n}.0.count');\n        foreach ($events as $key => $event) {\n            $events[$key]['Event']['proposals_count'] = (isset($proposals[$event['Event']['id']])) ? $proposals[$event['Event']['id']] : 0;\n        }\n        return $events;\n    }\n\n    public function attachDiscussionsCountToEvents($user, $events)\n    {\n        $eventIds = Set::extract('/Event/id', $events);\n        $this->Thread = ClassRegistry::init('Thread');\n        $threads = $this->Thread->find('list', array(\n            'conditions' => array('Thread.event_id' => $eventIds),\n            'fields' => array('Thread.event_id', 'Thread.id')\n        ));\n        $posts = $this->Thread->Post->find('all', array(\n            'conditions' => array('Post.thread_id' => $threads),\n            'recursive' => -1,\n            'fields' => array('Count(id) AS post_count', 'thread_id', 'max(date_modified) as last_post'),\n            'group' => array('Post.thread_id')\n        ));\n        $event_threads = array();\n        foreach ($posts as $k => $v) {\n            foreach ($threads as $k2 => $v2) {\n                if ($v2 == $v['Post']['thread_id']) {\n                    $event_threads[$k2] = array(\n                        'post_count' => $v[0]['post_count'],\n                        'last_post' => strtotime($v[0]['last_post'])\n                    );\n                }\n            }\n        }\n        foreach ($events as $k => $v) {\n            $events[$k]['Event']['post_count'] = !empty($event_threads[$events[$k]['Event']['id']]) ? $event_threads[$events[$k]['Event']['id']]['post_count'] : 0;\n            $events[$k]['Event']['last_post'] = !empty($event_threads[$events[$k]['Event']['id']]) ? $event_threads[$events[$k]['Event']['id']]['last_post'] : 0;\n        }\n        return $events;\n    }\n\n    private function __buildEventConditionsCorrelation($user, $eventIds, $sgids)\n    {\n        if (!is_array($eventIds)) {\n            $eventIds = array($eventIds);\n        }\n        if (!$user['Role']['perm_site_admin']) {\n            $conditionsCorrelation = array(\n                    'AND' => array(\n                            'Correlation.1_event_id' => $eventIds,\n                            array(\n                                    'OR' => array(\n                                            'Correlation.org_id' => $user['org_id'],\n                                            'AND' => array(\n                                                    array(\n                                                            'OR' => array(\n                                                                    array(\n                                                                            'AND' => array(\n                                                                                    'Correlation.distribution >' => 0,\n                                                                                    'Correlation.distribution <' => 4,\n                                                                            ),\n                                                                    ),\n                                                                    array(\n                                                                            'AND' => array(\n                                                                                    'Correlation.distribution' => 4,\n                                                                                    'Correlation.sharing_group_id' => $sgids\n                                                                            ),\n                                                                    ),\n                                                            ),\n                                                    ),\n                                                    array(\n                                                            'OR' => array(\n                                                                    'Correlation.a_distribution' => 5,\n                                                                    array(\n                                                                            'AND' => array(\n                                                                                    'Correlation.a_distribution >' => 0,\n                                                                                    'Correlation.a_distribution <' => 4,\n                                                                            ),\n                                                                    ),\n                                                                    array(\n                                                                            'AND' => array(\n                                                                                    'Correlation.a_distribution' => 4,\n                                                                                    'Correlation.a_sharing_group_id' => $sgids\n                                                                            ),\n                                                                    ),\n                                                            ),\n                                                    ),\n                                            ),\n                                    ),\n                            ),\n                    ),\n            );\n        } else {\n            $conditionsCorrelation = array('Correlation.1_event_id' => $eventIds);\n        }\n        return $conditionsCorrelation;\n    }\n\n    public function getRelatedEvents($user, $eventId = null, $sgids)\n    {\n        if ($eventId == null) {\n            $eventId = $this->data['Event']['id'];\n        }\n        if (!isset($sgids) || empty($sgids)) {\n            $sgids = array(-1);\n        }\n        $this->Correlation = ClassRegistry::init('Correlation');\n        // search the correlation table for the event ids of the related events\n        // Rules:\n        // 1. Event is owned by the user (org_id matches)\n        // 2. User is allowed to see both the event and the org:\n        //    a.  Event:\n        //        i. Event has a distribution between 1-3 (community only, connected communities, all orgs)\n        //        ii. Event has a sharing group that the user is accessible to view\n        //    b.  Attribute:\n        //        i. Attribute has a distribution of 5 (inheritance of the event, for this the event check has to pass anyway)\n        //        ii. Atttibute has a distribution between 1-3 (community only, connected communities, all orgs)\n        //        iii. Attribute has a sharing group that the user is accessible to view\n        $conditionsCorrelation = $this->__buildEventConditionsCorrelation($user, $eventId, $sgids);\n        $correlations = $this->Correlation->find('list', array(\n                'fields' => array('Correlation.event_id', 'Correlation.event_id'),\n                'conditions' => $conditionsCorrelation,\n                'recursive' => 0,\n                'group' => 'Correlation.event_id',\n                'order' => array('Correlation.event_id DESC')));\n\n        $relatedEventIds = array_values($correlations);\n        // now look up the event data for these attributes\n        $conditions = array(\"Event.id\" => $relatedEventIds);\n        $fields = array('id', 'date', 'threat_level_id', 'info', 'published', 'uuid', 'analysis', 'timestamp', 'distribution', 'org_id', 'orgc_id');\n        $orgfields = array('id', 'name', 'uuid');\n        $relatedEvents = $this->find(\n            'all',\n            array('conditions' => $conditions,\n                'recursive' => -1,\n                'order' => 'Event.date DESC',\n                'fields' => $fields,\n                'contain' => array(\n                    'Org' => array(\n                        'fields' => $orgfields\n                    ),\n                    'Orgc' => array(\n                        'fields' => $orgfields\n                    )\n                )\n            )\n        );\n        $fieldsToRearrange = array('Org', 'Orgc');\n        foreach ($relatedEvents as $k => $relatedEvent) {\n            foreach ($fieldsToRearrange as $field) {\n                if (isset($relatedEvent[$field])) {\n                    $relatedEvents[$k]['Event'][$field] = $relatedEvent[$field];\n                    unset($relatedEvents[$k][$field]);\n                }\n            }\n        }\n        return $relatedEvents;\n    }\n\n    public function getRelatedAttributes($user, $id = null, $sgids, $shadowAttribute = false, $scope = 'event')\n    {\n        $context = $shadowAttribute ? 'ShadowAttribute' : 'Attribute';\n        $settings = array(\n            'Attribute' => array('model' => 'Attribute', 'correlationModel' => 'Correlation', 'parentIdField' => '1_attribute_id'),\n            'ShadowAttribute' => array('model' => 'ShadowAttribute', 'correlationModel' => 'ShadowAttributeCorrelation', 'parentIdField' => '1_shadow_attribute_id')\n        );\n        if ($scope === 'event' && $id == null) {\n            $id = $this->data['Event']['id'];\n        } elseif ($scope === 'attribute' && $id == null) {\n            $id = $this->data['Attribute']['id'];\n        }\n        if (!isset($sgids) || empty($sgids)) {\n            $sgids = array(-1);\n        }\n        $this->{$settings[$context]['correlationModel']} = ClassRegistry::init($settings[$context]['correlationModel']);\n        if (!$user['Role']['perm_site_admin']) {\n            $conditionsCorrelation = array(\n                    'AND' => array(\n                            $settings[$context]['correlationModel'] . '.1_' . $scope . '_id' => $id,\n                            array(\n                                    'OR' => array(\n                                            $settings[$context]['correlationModel'] . '.org_id' => $user['org_id'],\n                                            'AND' => array(\n                                                    array(\n                                                            'OR' => array(\n                                                                    array(\n                                                                            'AND' => array(\n                                                                                    $settings[$context]['correlationModel'] . '.distribution >' => 0,\n                                                                                    $settings[$context]['correlationModel'] . '.distribution <' => 4,\n                                                                            ),\n                                                                    ),\n                                                                    array(\n                                                                            'AND' => array(\n                                                                                    $settings[$context]['correlationModel'] . '.distribution' => 4,\n                                                                                    $settings[$context]['correlationModel'] . '.sharing_group_id' => $sgids\n                                                                            ),\n                                                                    ),\n                                                            ),\n                                                    ),\n                                                    array(\n                                                            'OR' => array(\n                                                                    $settings[$context]['correlationModel'] . '.a_distribution' => 5,\n                                                                    array(\n                                                                            'AND' => array(\n                                                                                    $settings[$context]['correlationModel'] . '.a_distribution >' => 0,\n                                                                                    $settings[$context]['correlationModel'] . '.a_distribution <' => 4,\n                                                                            ),\n                                                                    ),\n                                                                    array(\n                                                                            'AND' => array(\n                                                                                    $settings[$context]['correlationModel'] . '.a_distribution' => 4,\n                                                                                    $settings[$context]['correlationModel'] . '.a_sharing_group_id' => $sgids\n                                                                            ),\n                                                                    ),\n                                                            ),\n                                                    ),\n                                            ),\n                                    )\n                            )\n\n                    )\n            );\n        } else {\n            $conditionsCorrelation = array($settings[$context]['correlationModel'] . '.1_' . $scope . '_id' => $id);\n        }\n        $max_correlations = Configure::read('MISP.max_correlations_per_event');\n        if (empty($max_correlations)) {\n            $max_correlations = 5000;\n        }\n        $correlations = $this->{$settings[$context]['correlationModel']}->find('all', array(\n                'fields' => $settings[$context]['correlationModel'] . '.*',\n                'conditions' => $conditionsCorrelation,\n                'recursive' => -1,\n                'order' => false,\n                'limit' => $max_correlations\n        ));\n        $relatedAttributes = array();\n        foreach ($correlations as $k => $correlation) {\n            $current = array(\n                    'id' => $correlation[$settings[$context]['correlationModel']]['event_id'],\n                    'attribute_id' => $correlation[$settings[$context]['correlationModel']]['attribute_id'],\n                    'org_id' => $correlation[$settings[$context]['correlationModel']]['org_id'],\n                    'info' => $correlation[$settings[$context]['correlationModel']]['info'],\n                    'value' => $correlation[$settings[$context]['correlationModel']]['value'],\n            );\n            if (empty($relatedAttributes[$correlation[$settings[$context]['correlationModel']][$settings[$context]['parentIdField']]]) || !in_array($current, $relatedAttributes[$correlation[$settings[$context]['correlationModel']][$settings[$context]['parentIdField']]])) {\n                $relatedAttributes[$correlation[$settings[$context]['correlationModel']][$settings[$context]['parentIdField']]][] = $current;\n            }\n            unset($correlations[$k]);\n        }\n        return $relatedAttributes;\n    }\n\n    /**\n     * Clean up an Event Array that was received by an XML request.\n     * The structure needs to be changed a little bit to be compatible with what CakePHP expects\n     *\n     * This function receives the reference of the variable, so no return is required as it directly\n     * modifies the original data.\n     */\n    public function cleanupEventArrayFromXML(&$data)\n    {\n        $objects = array('Attribute', 'ShadowAttribute', 'Object');\n        foreach ($objects as $object) {\n            // Workaround for different structure in XML/array than what CakePHP expects\n            if (isset($data['Event'][$object]) && is_array($data['Event'][$object]) && count($data['Event'][$object])) {\n                if (!is_numeric(implode(array_keys($data['Event'][$object]), ''))) {\n                    // single attribute\n                    $data['Event'][$object] = array(0 => $data['Event'][$object]);\n                }\n                $data['Event'][$object] = array_values($data['Event'][$object]);\n            }\n        }\n        $objects = array('Org', 'Orgc', 'SharingGroup');\n        foreach ($objects as $object) {\n            if (isset($data['Event'][$object][0])) {\n                $data['Event'][$object] = $data['Event'][$object][0];\n            }\n        }\n        return $data;\n    }\n\n    private function __resolveErrorCode($code, &$event, &$server)\n    {\n        $error = false;\n        switch ($code) {\n            case 403:\n                return 'The distribution level of this event blocks it from being pushed.';\n            case 405:\n                $error = 'The sync user on the remote instance does not have the required privileges to handle this event.';\n                break;\n        }\n        if ($error) {\n            $newTextBody = 'Uploading Event (' . $event['Event']['id'] . ') to Server (' . $server['Server']['id'] . ')';\n            $this->__logUploadResult($server, $event, $newTextBody);\n        }\n        return $error;\n    }\n\n    private function __executeRestfulEventToServer($event, $server, $resourceId, &$newLocation, &$newTextBody, $HttpSocket)\n    {\n        $result = $this->restfulEventToServer($event, $server, $resourceId, $newLocation, $newTextBody, $HttpSocket);\n        if (is_numeric($result)) {\n            $error = $this->__resolveErrorCode($result, $event, $server);\n            if ($error) {\n                return $error . ' Error code: ' . $result;\n            }\n        }\n        return true;\n    }\n\n    public function uploadEventToServer($event, $server, $HttpSocket = null)\n    {\n        $this->Server = ClassRegistry::init('Server');\n        $push = $this->Server->checkVersionCompatibility($server['Server']['id'], false, $HttpSocket);\n        if (empty($push['canPush'])) {\n            return 'The remote user is not a sync user - the upload of the event has been blocked.';\n        }\n        if (!empty($server['Server']['unpublish_event'])) {\n            $event['Event']['published'] = 0;\n        }\n        $updated = null;\n        $newLocation = $newTextBody = '';\n        $result = $this->__executeRestfulEventToServer($event, $server, null, $newLocation, $newTextBody, $HttpSocket);\n        if ($result !== true) {\n            return $result;\n        }\n        if (strlen($newLocation)) { // HTTP/1.1 302 Found and Location: http://<newLocation>\n            $result = $this->__executeRestfulEventToServer($event, $server, $newLocation, $newLocation, $newTextBody, $HttpSocket);\n            if ($result !== true) {\n                return $result;\n            }\n        }\n        $uploadFailed = false;\n        try {\n            $json = json_decode($newTextBody, true);\n        } catch (Exception $e) {\n            $uploadFailed = true;\n        }\n        if (!is_array($json) || $uploadFailed) {\n            return $this->__logUploadResult($server, $event, $newTextBody);\n        }\n        return 'Success';\n    }\n\n    private function __prepareForPushToServer($event, $server)\n    {\n        if ($event['Event']['distribution'] == 4) {\n            if (!empty($event['SharingGroup']['SharingGroupServer'])) {\n                $found = false;\n                foreach ($event['SharingGroup']['SharingGroupServer'] as $sgs) {\n                    if ($sgs['server_id'] == $server['Server']['id']) {\n                        $found = true;\n                    }\n                }\n                if (!$found) {\n                    return 403;\n                }\n            }\n        }\n        $serverModel = ClassRegistry::init('Server');\n        $server = $serverModel->eventFilterPushableServers($event, array($server));\n        if (empty($server)) {\n            return 403;\n        }\n        $server = $server[0];\n        if ($this->checkDistributionForPush($event, $server, 'Event')) {\n            $event = $this->__updateEventForSync($event, $server);\n        } else {\n            return 403;\n        }\n        return $event;\n    }\n\n    private function __getLastUrlPathComponent($urlPath)\n    {\n        if (!empty($urlPath)) {\n            $pieces = explode('/', $urlPath);\n            return '/' . end($pieces);\n        }\n        return '';\n    }\n\n    private function __handleRestfulEventToServerResponse($response, &$newLocation, &$newTextBody)\n    {\n        switch ($response->code) {\n            case '200':\t// 200 (OK) + entity-action-result\n                if ($response->isOk()) {\n                    $newTextBody = $response->body();\n                    return true;\n                } else {\n                    try {\n                        $jsonArray = json_decode($response->body, true);\n                    } catch (Exception $e) {\n                        return true;\n                    }\n                    return $jsonArray['name'];\n                }\n                // no break\n            case '302': // Found\n                $newLocation = $response->headers['Location'];\n                $newTextBody = $response->body();\n                return true;\n            case '404': // Not Found\n                $newLocation = $response->headers['Location'];\n                $newTextBody = $response->body();\n                return 404;\n            case '405':\n                return 405;\n            case '403': // Not authorised\n                return 403;\n        }\n    }\n\n    // Uploads the event and the associated Attributes to another Server\n    public function restfulEventToServer($event, $server, $urlPath, &$newLocation, &$newTextBody, $HttpSocket = null)\n    {\n        $event = $this->__prepareForPushToServer($event, $server);\n        if (is_numeric($event)) {\n            return $event;\n        }\n        $url = $server['Server']['url'];\n        $HttpSocket = $this->setupHttpSocket($server, $HttpSocket);\n        $request = $this->setupSyncRequest($server);\n        $uri = $url . '/events' . $this->__getLastUrlPathComponent($urlPath);\n        $data = json_encode($event);\n        $response = $HttpSocket->post($uri, $data, $request);\n        return $this->__handleRestfulEventToServerResponse($response, $newLocation, $newTextBody);\n    }\n\n    private function __rearrangeEventStructureForSync($event)\n    {\n        // rearrange things to be compatible with the Xml::fromArray()\n        $objectsToRearrange = array('Attribute', 'Object', 'Orgc', 'SharingGroup', 'EventTag', 'Org', 'ShadowAttribute');\n        foreach ($objectsToRearrange as $o) {\n            if (isset($event[$o])) {\n                $event['Event'][$o] = $event[$o];\n                unset($event[$o]);\n            }\n        }\n        // cleanup the array from things we do not want to expose\n        foreach (array('Org', 'org_id', 'orgc_id', 'proposal_email_lock', 'org', 'orgc') as $field) {\n            unset($event['Event'][$field]);\n        }\n        return $event;\n    }\n\n    // since we fetch the event and filter on tags after / server, we need to cull all of the non exportable tags\n    private function __removeNonExportableTags($data, $dataType)\n    {\n        if (!empty($data[$dataType . 'Tag'])) {\n            foreach ($data[$dataType . 'Tag'] as $k => $tag) {\n                if (!$tag['Tag']['exportable']) {\n                    unset($data[$dataType . 'Tag'][$k]);\n                } else {\n                    unset($tag['org_id']);\n                    $data['Tag'][] = $tag['Tag'];\n                }\n            }\n            unset($data[$dataType . 'Tag']);\n        }\n        return $data;\n    }\n\n    private function __prepareAttributesForSync($data, $server)\n    {\n        // prepare attribute for sync\n        if (!empty($data['Attribute'])) {\n            foreach ($data['Attribute'] as $key => $attribute) {\n                $data['Attribute'][$key] = $this->__updateAttributeForSync($attribute, $server);\n                if (empty($data['Attribute'][$key])) {\n                    unset($data['Attribute'][$key]);\n                } else {\n                    $data['Attribute'][$key] = $this->__removeNonExportableTags($data['Attribute'][$key], 'Attribute');\n                }\n            }\n            $data['Attribute'] = array_values($data['Attribute']);\n        }\n        return $data;\n    }\n\n    private function __prepareObjectsForSync($data, $server)\n    {\n        // prepare Object for sync\n        if (!empty($data['Object'])) {\n            foreach ($data['Object'] as $key => $object) {\n                $data['Object'][$key] = $this->__updateObjectForSync($object, $server);\n                if (empty($data['Object'][$key])) {\n                    unset($data['Object'][$key]);\n                } else {\n                    $data['Object'][$key]['Attribute'] = $this->__prepareAttributesForSync($data['Object'][$key]['Attribute'], $server);\n                }\n            }\n            $data['Object'] = array_values($data['Object']);\n        }\n        return $data;\n    }\n\n    private function __updateEventForSync($event, $server)\n    {\n        $event = $this->__rearrangeEventStructureForSync($event);\n        $event['Event'] = $this->__removeNonExportableTags($event['Event'], 'Event');\n        // Add the local server to the list of instances in the SG\n        if (isset($event['Event']['SharingGroup']) && isset($event['Event']['SharingGroup']['SharingGroupServer'])) {\n            foreach ($event['Event']['SharingGroup']['SharingGroupServer'] as &$s) {\n                if ($s['server_id'] == 0) {\n                    $s['Server'] = array('id' => 0, 'url' => Configure::read('MISP.baseurl'));\n                }\n            }\n        }\n        $event['Event'] = $this->__prepareAttributesForSync($event['Event'], $server);\n        $event['Event'] = $this->__prepareObjectsForSync($event['Event'], $server);\n\n        // Downgrade the event from connected communities to community only\n        if (!$server['Server']['internal'] && $event['Event']['distribution'] == 2) {\n            $event['Event']['distribution'] = 1;\n        }\n        return $event;\n    }\n\n    private function __updateObjectForSync($object, $server)\n    {\n        if (!$server['Server']['internal'] && $object['distribution'] < 2) {\n            return false;\n        }\n        // Downgrade the object from connected communities to community only\n        if (!$server['Server']['internal'] && $object['distribution'] == 2) {\n            $object['distribution'] = 1;\n        }\n        // If the object has a sharing group attached, make sure it can be transfered\n        if ($object['distribution'] == 4) {\n            if (!$server['Server']['internal'] && $this->checkDistributionForPush(array('Object' => $object), $server, 'Object') === false) {\n                return false;\n            }\n            // Add the local server to the list of instances in the SG\n            if (isset($object['SharingGroup']['SharingGroupServer'])) {\n                foreach ($object['SharingGroup']['SharingGroupServer'] as &$s) {\n                    if ($s['server_id'] == 0) {\n                        $s['Server'] = array('id' => 0, 'url' => Configure::read('MISP.baseurl'));\n                    }\n                }\n            }\n        }\n        return $object;\n    }\n\n    private function __updateAttributeForSync($attribute, $server)\n    {\n        // do not keep attributes that are private, nor cluster\n        if (!$server['Server']['internal'] && $attribute['distribution'] < 2) {\n            return false;\n        }\n        // Downgrade the attribute from connected communities to community only\n        if (!$server['Server']['internal'] && $attribute['distribution'] == 2) {\n            $attribute['distribution'] = 1;\n        }\n\n        // If the attribute has a sharing group attached, make sure it can be transfered\n        if ($attribute['distribution'] == 4) {\n            if (!$server['Server']['internal'] && $this->checkDistributionForPush(array('Attribute' => $attribute), $server, 'Attribute') === false) {\n                return false;\n            }\n            // Add the local server to the list of instances in the SG\n            if (!empty($attribute['SharingGroup']['SharingGroupServer'])) {\n                foreach ($attribute['SharingGroup']['SharingGroupServer'] as &$s) {\n                    if ($s['server_id'] == 0) {\n                        $s['Server'] = array('id' => 0, 'url' => Configure::read('MISP.baseurl'));\n                    }\n                }\n            }\n        }\n        // also add the encoded attachment\n        if ($this->Attribute->typeIsAttachment($attribute['type'])) {\n            $attribute['data'] = $this->Attribute->base64EncodeAttachment($attribute);\n        }\n        // Passing the attribute ID together with the attribute could cause the deletion of attributes after a publish/push\n        // Basically, if the attribute count differed between two instances, and the instance with the lower attribute\n        // count pushed, the old attributes with the same ID got overwritten. Unsetting the ID before pushing it\n        // solves the issue and a new attribute is always created.\n        unset($attribute['id']);\n        // remove value1 and value2 from the output\n        unset($attribute['value1']);\n        unset($attribute['value2']);\n        return $attribute;\n    }\n\n    public function downloadEventFromServer($eventId, $server, $HttpSocket=null)\n    {\n        $url = $server['Server']['url'];\n        $HttpSocket = $this->setupHttpSocket($server, $HttpSocket);\n        $request = $this->setupSyncRequest($server);\n        $uri = $url . '/events/view/' . $eventId . '/deleted:1/excludeGalaxy:1';\n        $response = $HttpSocket->get($uri, $data = '', $request);\n        if ($response->isOk()) {\n            return json_decode($response->body, true);\n        }\n        return null;\n    }\n\n    public function quickDelete($event)\n    {\n        $id = $event['Event']['id'];\n        $this->Thread = ClassRegistry::init('Thread');\n        $thread = $this->Thread->find('first', array(\n            'conditions' => array('Thread.event_id' => $id),\n            'fields' => array('Thread.id'),\n            'recursive' => -1\n        ));\n        $thread_id = !empty($thread) ? $thread['Thread']['id'] : false;\n        $relations = array(\n            array(\n                'table' => 'attributes',\n                'foreign_key' => 'event_id',\n                'value' => $id\n            ),\n            array(\n                'table' => 'shadow_attributes',\n                'foreign_key' => 'event_id',\n                'value' => $id\n            ),\n            array(\n                'table' => 'event_tags',\n                'foreign_key' => 'event_id',\n                'value' => $id\n            ),\n            array(\n                'table' => 'attribute_tags',\n                'foreign_key' => 'event_id',\n                'value' => $id\n            ),\n            array(\n                'table' => 'threads',\n                'foreign_key' => 'event_id',\n                'value' => $id\n            ),\n            array(\n                'table' => 'sightings',\n                'foreign_key' => 'event_id',\n                'value' => $id\n            ),\n            array(\n                'table' => 'event_delegations',\n                'foreign_key' => 'event_id',\n                'value' => $id\n            ),\n            array(\n                'table' => 'objects',\n                'foreign_key' => 'event_id',\n                'value' => $id\n            ),\n            array(\n                'table' => 'object_references',\n                'foreign_key' => 'event_id',\n                'value' => $id\n            )\n        );\n        if ($thread_id) {\n            $relations[] = \tarray(\n                'table' => 'posts',\n                'foreign_key' => 'thread_id',\n                'value' => $thread_id\n            );\n        }\n        if (!Configure::read('MISP.completely_disable_correlation')) {\n            array_push(\n                $relations,\n                array(\n                    'table' => 'correlations',\n                    'foreign_key' => 'event_id',\n                    'value' => $id\n                ),\n                array(\n                    'table' => 'correlations',\n                    'foreign_key' => '1_event_id',\n                    'value' => $id\n                )\n            );\n        }\n        App::uses('QueryTool', 'Tools');\n        $queryTool = new QueryTool();\n        foreach ($relations as $relation) {\n            $queryTool->quickDelete($relation['table'], $relation['foreign_key'], $relation['value'], $this);\n        }\n        return $this->delete($id, false);\n    }\n\n    public function downloadProposalsFromServer($uuidList, $server, $HttpSocket = null)\n    {\n        $url = $server['Server']['url'];\n        $HttpSocket = $this->setupHttpSocket($server, $HttpSocket);\n        $request = $this->setupSyncRequest($server);\n        $uri = $url . '/shadow_attributes/getProposalsByUuidList';\n        $response = $HttpSocket->post($uri, json_encode($uuidList), $request);\n        if ($response->isOk()) {\n            return(json_decode($response->body, true));\n        } else {\n            return false;\n        }\n    }\n\n    public function createEventConditions($user)\n    {\n        $conditions = array();\n        if (!$user['Role']['perm_site_admin']) {\n            $sgids = $this->cacheSgids($user, true);\n            $conditions['AND']['OR'] = array(\n                'Event.org_id' => $user['org_id'],\n                array(\n                    'AND' => array(\n                        'Event.distribution >' => 0,\n                        'Event.distribution <' => 4,\n                        Configure::read('MISP.unpublishedprivate') ? array('Event.published =' => 1) : array(),\n                    ),\n                ),\n                array(\n                    'AND' => array(\n                        'Event.sharing_group_id' => $sgids,\n                        'Event.distribution' => 4,\n                        Configure::read('MISP.unpublishedprivate') ? array('Event.published =' => 1) : array(),\n                    )\n                )\n            );\n        }\n        return $conditions;\n    }\n\n    public function set_filter_wildcard(&$params, $conditions, $options)\n    {\n        $tempConditions = array();\n        $tempConditions[] = array('Event.info LIKE' => $params['wildcard']);\n        $attributeParams = array('value1', 'value2', 'comment');\n        foreach ($attributeParams as $attributeParam) {\n            $subQueryOptions = array(\n                'conditions' => array('Attribute.' . $attributeParam . ' LIKE' => $params['wildcard']),\n                'fields' => array('event_id')\n            );\n            $tempConditions[] = $this->subQueryGenerator($this->Attribute, $subQueryOptions, 'Event.id');\n        }\n        $tagScopes = array('Event', 'Attribute');\n        $this->AttributeTag = ClassRegistry::init('AttributeTag');\n        $tagIds = $this->AttributeTag->Tag->find('list', array(\n            'recursive' => -1,\n            'conditions' => array('Tag.name LIKE' => $params['wildcard']),\n            'fields' => array('Tag.id')\n        ));\n        if (!empty($tagIds)) {\n            foreach ($tagScopes as $tagScope) {\n                $subQueryOptions = array(\n                    'conditions' => array(\n                        'tag_id' => $tagIds,\n                    ),\n                    'fields' => array('event_id')\n                );\n                $tempConditions[] = $this->subQueryGenerator($this->{$tagScope . 'Tag'}, $subQueryOptions, 'Event.id');\n            }\n        }\n        return $tempConditions;\n    }\n\n    public function set_filter_wildcard_attributes(&$params, $conditions, $options)\n    {\n        $tempConditions = array();\n        $tempConditions[] = array('Event.info LIKE' => $params['wildcard']);\n        $attributeParams = array('value1', 'value2', 'comment');\n        foreach ($attributeParams as $attributeParam) {\n            $tempConditions[] = array('Attribute.' . $attributeParam . ' LIKE' => $params['wildcard']);\n        }\n        $tagScopes = array('Event', 'Attribute');\n        $this->AttributeTag = ClassRegistry::init('AttributeTag');\n        $tagIds = $this->AttributeTag->Tag->find('list', array(\n            'recursive' => -1,\n            'conditions' => array('Tag.name LIKE' => $params['wildcard']),\n            'fields' => array('Tag.id')\n        ));\n        if (!empty($tagIds)) {\n            $subQueryOptions = array(\n                'conditions' => array(\n                    'tag_id' => $tagIds,\n                ),\n                'fields' => array('event_id')\n            );\n            $tempConditions[] = $this->subQueryGenerator($this->EventTag, $subQueryOptions, 'Attribute.event_id');\n            $subQueryOptions = array(\n                'conditions' => array(\n                    'tag_id' => $tagIds,\n                ),\n                'fields' => array('attribute_id')\n            );\n            $tempConditions[] = $this->subQueryGenerator($this->AttributeTag, $subQueryOptions, 'Attribute.id');\n        }\n        return $tempConditions;\n    }\n\n    public function filterEventIds($user, &$params = array())\n    {\n        $conditions = $this->createEventConditions($user);\n        if (isset($params['wildcard'])) {\n            $temp = array();\n            $options = array(\n                'filter' => 'wildcard',\n                'scope' => 'Event',\n                'pop' => false,\n                'context' => 'Event'\n            );\n            $conditions['AND'][] = array('OR' => $this->set_filter_wildcard($params, $temp, $options));\n        } else {\n            $simple_params = array(\n                'Event' => array(\n                    'eventid' => array('function' => 'set_filter_eventid', 'pop' => true),\n                    'eventinfo' => array('function' => 'set_filter_eventinfo'),\n                    'ignore' => array('function' => 'set_filter_ignore'),\n                    'tags' => array('function' => 'set_filter_tags'),\n                    'from' => array('function' => 'set_filter_timestamp', 'pop' => true),\n                    'to' => array('function' => 'set_filter_timestamp', 'pop' => true),\n                    'last' => array('function' => 'set_filter_timestamp', 'pop' => true),\n                    'timestamp' => array('function' => 'set_filter_timestamp', 'pop' => true),\n                    'event_timestamp' => array('function' => 'set_filter_timestamp', 'pop' => true),\n                    'publish_timestamp' => array('function' => 'set_filter_timestamp', 'pop' => true),\n                    'org' => array('function' => 'set_filter_org', 'pop' => true),\n                    'uuid' => array('function' => 'set_filter_uuid', 'pop' => true),\n                    'published' => array('function' => 'set_filter_published', 'pop' => true)\n                ),\n                'Object' => array(\n                    'object_name' => array('function' => 'set_filter_object_name'),\n                    'deleted' => array('function' => 'set_filter_deleted')\n                ),\n                'Attribute' => array(\n                    'value' => array('function' => 'set_filter_value', 'pop' => true),\n                    'category' => array('function' => 'set_filter_simple_attribute'),\n                    'type' => array('function' => 'set_filter_simple_attribute'),\n                    'tags' => array('function' => 'set_filter_tags', 'pop' => true),\n                    'ignore' => array('function' => 'set_filter_ignore'),\n                    'uuid' => array('function' => 'set_filter_uuid'),\n                    'deleted' => array('function' => 'set_filter_deleted'),\n                    'to_ids' => array('function' => 'set_filter_to_ids'),\n                    'comment' => array('function' => 'set_filter_comment')\n                )\n            );\n            foreach ($params as $param => $paramData) {\n                foreach ($simple_params as $scope => $simple_param_scoped) {\n                    if (isset($simple_param_scoped[$param]) && $params[$param] !== false) {\n                        $options = array(\n                            'filter' => $param,\n                            'scope' => $scope,\n                            'pop' => !empty($simple_param_scoped[$param]['pop']),\n                            'context' => 'Event'\n                        );\n                        if ($scope === 'Event') {\n                            $conditions = $this->{$simple_param_scoped[$param]['function']}($params, $conditions, $options);\n                        } else {\n                            $temp = array();\n                            $temp = $this->{$simple_param_scoped[$param]['function']}($params, $temp, $options);\n                            if (!empty($temp)) {\n                                $subQueryOptions = array(\n                                    'conditions' => $temp,\n                                    'fields' => array(\n                                        'event_id'\n                                    )\n                                );\n                                $conditions['AND'][] = $this->subQueryGenerator($this->{$scope}, $subQueryOptions, 'Event.id');\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        $fields = array('Event.id');\n        if (!empty($params['include_attribute_count'])) {\n            $fields[] = 'Event.attribute_count';\n        }\n        $find_params = array(\n            'conditions' => $conditions,\n            'recursive' => -1,\n            'fields' => $fields\n        );\n        if (isset($params['limit'])) {\n            $find_params['limit'] = $params['limit'];\n            if (isset($params['page'])) {\n                $find_params['page'] = $params['page'];\n            }\n        }\n        $results = $this->find('list', $find_params);\n        return $results;\n    }\n\n    public function fetchSimpleEventIds($user, $params = array())\n    {\n        $conditions = $this->createEventConditions($user);\n        $conditions['AND'][] = $params['conditions'];\n        $results = array_values($this->find('list', array(\n            'conditions' => $conditions,\n            'recursive' => -1,\n            'fields' => array('Event.id')\n        )));\n        return $results;\n    }\n\n    public function fetchSimpleEvents($user, $params, $includeOrgc = false)\n    {\n        $conditions = $this->createEventConditions($user);\n        $conditions['AND'][] = $params['conditions'];\n        $params = array(\n            'conditions' => $conditions,\n            'recursive' => -1\n        );\n        if ($includeOrgc) {\n            $params['contain'] = array('Orgc.name');\n        }\n        $results = array_values($this->find('all', $params));\n        return $results;\n    }\n\n    public function fetchEventIds($user, $from = false, $to = false, $last = false, $list = false, $timestamp = false, $publish_timestamp = false, $eventIdList = false)\n    {\n        // restricting to non-private or same org if the user is not a site-admin.\n        $conditions = $this->createEventConditions($user);\n        $fields = array('Event.id', 'Event.org_id', 'Event.distribution', 'Event.sharing_group_id');\n\n        if ($from) {\n            $conditions['AND'][] = array('Event.date >=' => $from);\n        }\n        if ($to) {\n            $conditions['AND'][] = array('Event.date <=' => $to);\n        }\n        if ($last) {\n            $conditions['AND'][] = array('Event.publish_timestamp >=' => $last);\n        }\n        if ($timestamp) {\n            $conditions['AND'][] = array('Event.timestamp >=' => $timestamp);\n        }\n        if ($publish_timestamp) {\n            $conditions['AND'][] = array('Event.publish_timestamp >=' => $publish_timestamp);\n        }\n        if ($eventIdList) {\n            $conditions['AND'][] = array('Event.id' => $eventIdList);\n        }\n        if ($list) {\n            $params = array(\n                'conditions' => $conditions,\n                'recursive' => -1,\n            );\n            $results = array_values($this->find('list', $params));\n        } else {\n            $params = array(\n                'conditions' => $conditions,\n                'recursive' => -1,\n                'fields' => $fields,\n            );\n            $results = $this->find('all', $params);\n        }\n        return $results;\n    }\n\n    /*\n     * Unlike the other fetchers, this one foregoes any ACL checks.\n     * the objective is simple: Fetch the given event with all related objects needed for the ZMQ output,\n     * standardising on this function for fetching the event to be passed to the pubsub handler\n     */\n    public function quickFetchEvent($id)\n    {\n        $event = $this->find('first', array(\n            'recursive' => -1,\n            'conditions' => array('Event.id' => $id),\n            'contain' => array(\n                'Orgc' => array(\n                    'fields' => array('Orgc.id', 'Orgc.uuid', 'Orgc.name')\n                ),\n                'EventTag' => array(\n                    'Tag' => array('fields' => array('Tag.id', 'Tag.name', 'Tag.colour', 'Tag.exportable'))\n                )\n            )\n        ));\n        return $event;\n    }\n\n    //Once the data about the user is gathered from the appropriate sources, fetchEvent is called from the controller or background process.\n    // Possible options:\n    // eventid: single event ID\n    // idList: array with event IDs\n    // tags: string with the usual tag syntax\n    // from: date string (YYYY-MM-DD)\n    // to: date string (YYYY-MM-DD)\n    // includeAllTags: true will include the tags that are marked as non-exportable\n    // includeAttachments: true will attach the attachments to the attributes in the data field\n    public function fetchEvent($user, $options = array(), $useCache = false)\n    {\n        if (isset($options['Event.id'])) {\n            $options['eventid'] = $options['Event.id'];\n        }\n        $possibleOptions = array(\n            'eventid',\n            'idList',\n            'tags',\n            'from',\n            'to',\n            'last',\n            'to_ids',\n            'includeAllTags',\n            'withAttachments',\n            'includeAttachments',\n            'event_uuid',\n            'distribution',\n            'sharing_group_id',\n            'disableSiteAdmin',\n            'metadata',\n            'enforceWarninglist',\n            'sgReferenceOnly',\n            'flatten',\n            'blockedAttributeTags',\n            'eventsExtendingUuid',\n            'extended',\n            'excludeGalaxy',\n            'includeRelatedTags'\n        );\n        if (!isset($options['excludeGalaxy']) || !$options['excludeGalaxy']) {\n            $this->GalaxyCluster = ClassRegistry::init('GalaxyCluster');\n        }\n        foreach ($possibleOptions as &$opt) {\n            if (!isset($options[$opt])) {\n                $options[$opt] = false;\n            }\n        }\n        $conditions = $this->createEventConditions($user);\n        if ($options['eventid']) {\n            $conditions['AND'][] = array(\"Event.id\" => $options['eventid']);\n        }\n        if ($options['eventsExtendingUuid']) {\n            if (!is_array($options['eventsExtendingUuid'])) {\n                $options['eventsExtendingUuid'] = array($options['eventsExtendingUuid']);\n            }\n            foreach ($options['eventsExtendingUuid'] as $extendedEvent) {\n                $extendedUuids = array();\n                if (!Validation::uuid($extendedEvent)) {\n                    $eventUuid = $this->find('first', array(\n                        'recursive' => -1,\n                        'conditions' => array('Event.id' => $extendedEvent),\n                        'fields' => array('Event.uuid')\n                    ));\n                    if (!empty($eventUuid)) {\n                        $extendedUuids[] = $eventUuid['Event']['uuid'];\n                    }\n                } else {\n                    $extendedUuids[] = $extendedEvent;\n                }\n            }\n            if (!empty($extendedUuids)) {\n                $conditions['AND'][] = array('Event.extends_uuid' => $extendedUuids);\n            } else {\n                // We've set as a search pattern any event that extends an event and didn't find anything\n                // valid, make sure we don't get everything thrown in our face that the user can see.\n                $conditions['AND'][] = array('Event.id' => -1);\n            }\n        }\n        if (!isset($user['org_id'])) {\n            throw new Exception('There was an error with the user account.');\n        }\n        $isSiteAdmin = $user['Role']['perm_site_admin'];\n        if (isset($options['disableSiteAdmin']) && $options['disableSiteAdmin']) {\n            $isSiteAdmin = false;\n        }\n        $conditionsAttributes = array();\n        $conditionsObjects = array();\n        $conditionsObjectReferences = array();\n\n        if (isset($options['flatten']) && $options['flatten']) {\n            $flatten = true;\n        } else {\n            $flatten = false;\n        }\n        $sgids = $this->cacheSgids($user, $useCache);\n        // restricting to non-private or same org if the user is not a site-admin.\n        if (!$isSiteAdmin) {\n            // if delegations are enabled, check if there is an event that the current user might see because of the request itself\n            if (Configure::read('MISP.delegation')) {\n                $delegatedEventIDs = $this->__cachedelegatedEventIDs($user, $useCache);\n                $conditions['AND']['OR']['Event.id'] = $delegatedEventIDs;\n            }\n            $conditionsAttributes['AND'][0]['OR'] = array(\n                array('AND' => array(\n                    'Attribute.distribution >' => 0,\n                    'Attribute.distribution !=' => 4,\n                )),\n                array('AND' => array(\n                    'Attribute.distribution' => 4,\n                    'Attribute.sharing_group_id' => $sgids,\n                )),\n                '(SELECT events.org_id FROM events WHERE events.id = Attribute.event_id)' => $user['org_id']\n            );\n\n            $conditionsObjects['AND'][0]['OR'] = array(\n                array('AND' => array(\n                    'Object.distribution >' => 0,\n                    'Object.distribution !=' => 4,\n                )),\n                array('AND' => array(\n                    'Object.distribution' => 4,\n                    'Object.sharing_group_id' => $sgids,\n                )),\n                '(SELECT events.org_id FROM events WHERE events.id = Object.event_id)' => $user['org_id']\n            );\n        }\n        if ($options['distribution']) {\n            $conditions['AND'][] = array('Event.distribution' => $options['distribution']);\n            $conditionsAttributes['AND'][] = array('Attribute.distribution' => $options['distribution']);\n            $conditionsObjects['AND'][] = array('Object.distribution' => $options['distribution']);\n        }\n        if ($options['sharing_group_id']) {\n            $conditions['AND'][] = array('Event.sharing_group_id' => $options['sharing_group_id']);\n            $conditionsAttributes['AND'][] = array('Attribute.sharing_group_id' => $options['sharing_group_id']);\n            $conditionsObjects['AND'][] = array('Object.sharing_group_id' => $options['sharing_group_id']);\n        }\n        if ($options['from']) {\n            $conditions['AND'][] = array('Event.date >=' => $options['from']);\n        }\n        if ($options['to']) {\n            $conditions['AND'][] = array('Event.date <=' => $options['to']);\n        }\n        if ($options['last']) {\n            $conditions['AND'][] = array('Event.publish_timestamp >=' => $options['last']);\n        }\n        if ($options['event_uuid']) {\n            $conditions['AND'][] = array('Event.uuid' => $options['event_uuid']);\n        }\n        if (!empty($options['includeRelatedTags'])) {\n            $options['includeGranularCorrelations'] = 1;\n        }\n        if (isset($options['ignore']) && empty($options['ignore'])) {\n            $conditions['AND'][] = array('Event.published' => 1);\n            $conditionsAttributes['AND'][] = array('Attribute.to_ids' => 1);\n        }\n        $softDeletables = array('Attribute', 'Object', 'ObjectReference');\n        if (isset($options['deleted']) && $options['deleted']) {\n            if (!$user['Role']['perm_sync']) {\n                foreach ($softDeletables as $softDeletable) {\n                    ${'conditions' . $softDeletable . 's'}['AND'][] = array(\n                        'OR' => array(\n                            '(SELECT events.org_id FROM events WHERE events.id = ' . $softDeletable . '.event_id)' => $user['org_id'],\n                            $softDeletable . '.deleted LIKE' => 0\n                        )\n                    );\n                }\n            }\n        } else {\n            foreach ($softDeletables as $softDeletable) {\n                ${'conditions' . $softDeletable . 's'}['AND'][$softDeletable . '.deleted LIKE'] = 0;\n            }\n        }\n        if ($options['idList'] && !$options['tags']) {\n            $conditions['AND'][] = array('Event.id' => $options['idList']);\n        }\n        // If we sent any tags along, load the associated tag names for each attribute\n        if ($options['tags']) {\n            $temp = $this->__generateCachedTagFilters($options['tags']);\n            foreach ($temp as $rules) {\n                $conditions['AND'][] = $rules;\n            }\n        }\n\n        if (!empty($options['to_ids']) || $options['to_ids'] === 0) {\n            $conditionsAttributes['AND'][] = array('Attribute.to_ids' => $options['to_ids']);\n        }\n\n        // removing this for now, we export the to_ids == 0 attributes too, since there is a to_ids field indicating it in the .xml\n        // $conditionsAttributes['AND'] = array('Attribute.to_ids =' => 1);\n        // Same idea for the published. Just adjust the tools to check for this\n        // $conditions['AND'][] = array('Event.published =' => 1);\n\n        // do not expose all the data ...\n        $fields = array('Event.id', 'Event.orgc_id', 'Event.org_id', 'Event.date', 'Event.threat_level_id', 'Event.info', 'Event.published', 'Event.uuid', 'Event.attribute_count', 'Event.analysis', 'Event.timestamp', 'Event.distribution', 'Event.proposal_email_lock', 'Event.user_id', 'Event.locked', 'Event.publish_timestamp', 'Event.sharing_group_id', 'Event.disable_correlation', 'Event.extends_uuid');\n        $fieldsAtt = array('Attribute.id', 'Attribute.type', 'Attribute.category', 'Attribute.value', 'Attribute.to_ids', 'Attribute.uuid', 'Attribute.event_id', 'Attribute.distribution', 'Attribute.timestamp', 'Attribute.comment', 'Attribute.sharing_group_id', 'Attribute.deleted', 'Attribute.disable_correlation', 'Attribute.object_id', 'Attribute.object_relation');\n        $fieldsObj = array('*');\n        $fieldsShadowAtt = array('ShadowAttribute.id', 'ShadowAttribute.type', 'ShadowAttribute.category', 'ShadowAttribute.value', 'ShadowAttribute.to_ids', 'ShadowAttribute.uuid', 'ShadowAttribute.event_uuid', 'ShadowAttribute.event_id', 'ShadowAttribute.old_id', 'ShadowAttribute.comment', 'ShadowAttribute.org_id', 'ShadowAttribute.proposal_to_delete', 'ShadowAttribute.timestamp');\n        $fieldsOrg = array('id', 'name', 'uuid');\n        $fieldsServer = array('id', 'url', 'name');\n        if (!$options['includeAllTags']) {\n            $tagConditions = array('exportable' => 1);\n        } else {\n            $tagConditions = array();\n        }\n        $sharingGroupData = $this->__cacheSharingGroupData($user, $useCache);\n        $params = array(\n            'conditions' => $conditions,\n            'recursive' => 0,\n            'fields' => $fields,\n            'contain' => array(\n                'ThreatLevel' => array(\n                        'fields' => array('ThreatLevel.name')\n                ),\n                'Attribute' => array(\n                    'fields' => $fieldsAtt,\n                    'conditions' => $conditionsAttributes,\n                    'AttributeTag' => array(\n                        'Tag' => array('conditions' => $tagConditions, 'order' => false),\n                        'order' => false\n                    ),\n                    'order' => false\n                ),\n                'Object' => array(\n                    'fields' => $fieldsObj,\n                    'conditions' => $conditionsObjects,\n                    'order' => false,\n                    'ObjectReference' => array(\n                        'conditions' => $conditionsObjectReferences,\n                        'order' => false\n                    )\n                ),\n                'ShadowAttribute' => array(\n                    'fields' => $fieldsShadowAtt,\n                    'conditions' => array('deleted' => 0),\n                    'Org' => array('fields' => $fieldsOrg),\n                    'order' => false\n                ),\n                'EventTag' => array(\n                    'Tag' => array('conditions' => $tagConditions, 'order' => false),\n                    'order' => false\n                 )\n            )\n        );\n        if ($flatten) {\n            unset($params['contain']['Object']);\n        }\n        if ($options['metadata']) {\n            unset($params['contain']['Attribute']);\n            unset($params['contain']['ShadowAttribute']);\n        }\n        if ($user['Role']['perm_site_admin']) {\n            $params['contain']['User'] = array('fields' => 'email');\n        }\n        $results = $this->find('all', $params);\n        if (empty($results)) {\n            return array();\n        }\n        // Do some refactoring with the event\n        $this->Sighting = ClassRegistry::init('Sighting');\n        $userEmails = array();\n        $fields = array(\n            'common' => array('distribution', 'sharing_group_id', 'uuid'),\n            'Attribute' => array('value', 'type', 'category', 'to_ids'),\n            'Object' => array('name', 'meta-category')\n        );\n        foreach ($results as $eventKey => &$event) {\n            $this->__attachReferences($user, $event, $sgids, $fields);\n            $event = $this->Orgc->attachOrgsToEvent($event, $fieldsOrg);\n            if (!$options['sgReferenceOnly'] && $event['Event']['sharing_group_id']) {\n                $event['SharingGroup'] = $sharingGroupData[$event['Event']['sharing_group_id']]['SharingGroup'];\n            }\n            // Add information for auditor user\n            if ($event['Event']['orgc_id'] === $user['org_id'] && $user['Role']['perm_audit']) {\n                if (!isset($userEmails[$event['Event']['user_id']])) {\n                    $userEmails[$event['Event']['user_id']] = $this->User->getAuthUser($event['Event']['user_id'])['email'];\n                }\n                $event['Event']['event_creator_email'] = $userEmails[$event['Event']['user_id']];\n            }\n            $event = $this->massageTags($event, 'Event', $options['excludeGalaxy']);\n            // Let's find all the related events and attach it to the event itself\n            $results[$eventKey]['RelatedEvent'] = $this->getRelatedEvents($user, $event['Event']['id'], $sgids);\n            // Let's also find all the relations for the attributes - this won't be in the xml export though\n            if (!empty($options['includeGranularCorrelations'])) {\n                $results[$eventKey]['RelatedAttribute'] = $this->getRelatedAttributes($user, $event['Event']['id'], $sgids);\n                if (!empty($options['includeRelatedTags'])) {\n                    $results[$eventKey] = $this->includeRelatedTags($results[$eventKey], $options);\n                }\n                $results[$eventKey]['RelatedShadowAttribute'] = $this->getRelatedAttributes($user, $event['Event']['id'], $sgids, true);\n            }\n            if (isset($event['ShadowAttribute']) && !empty($event['ShadowAttribute']) && isset($options['includeAttachments']) && $options['includeAttachments']) {\n                foreach ($event['ShadowAttribute'] as $k => $sa) {\n                    if ($this->ShadowAttribute->typeIsAttachment($sa['type'])) {\n                        $encodedFile = $this->ShadowAttribute->base64EncodeAttachment($sa);\n                        $event['ShadowAttribute'][$k]['data'] = $encodedFile;\n                    }\n                }\n            }\n            if (isset($event['Attribute'])) {\n                if ($options['enforceWarninglist']) {\n                    $this->Warninglist = ClassRegistry::init('Warninglist');\n                    $warninglists = $this->Warninglist->fetchForEventView();\n                }\n                if (isset($options['includeFeedCorrelations']) && $options['includeFeedCorrelations']) {\n                    $this->Feed = ClassRegistry::init('Feed');\n                    if (!empty($options['overrideLimit'])) {\n                        $overrideLimit = true;\n                    } else {\n                        $overrideLimit = false;\n                    }\n                    $event['Attribute'] = $this->Feed->attachFeedCorrelations($event['Attribute'], $user, $event['Event'], $overrideLimit);\n                }\n                $event = $this->__filterBlockedAttributesByTags($event, $options, $user);\n                $event['Attribute'] = $this->__attachSharingGroups(!$options['sgReferenceOnly'], $event['Attribute'], $sharingGroupData);\n                foreach ($event['Attribute'] as $key => $attribute) {\n                    if ($options['enforceWarninglist'] && !$this->Warninglist->filterWarninglistAttributes($warninglists, $attribute, $this->Warninglist)) {\n                        unset($event['Attribute'][$key]);\n                        continue;\n                    }\n                    $event['Attribute'][$key] = $this->massageTags($attribute, 'Attribute', $options['excludeGalaxy']);\n                    if ($event['Attribute'][$key]['category'] === 'Financial fraud') {\n                        $event['Attribute'][$key] = $this->Attribute->attachValidationWarnings($event['Attribute'][$key]);\n                    }\n                    if (isset($options['includeAttachments']) && $options['includeAttachments']) {\n                        if ($this->Attribute->typeIsAttachment($attribute['type'])) {\n                            $encodedFile = $this->Attribute->base64EncodeAttachment($attribute);\n                            $event['Attribute'][$key]['data'] = $encodedFile;\n                        }\n                    }\n                    // unset empty attribute tags that got added because the tag wasn't exportable\n                    if (!empty($attribute['AttributeTag'])) {\n                        foreach ($attribute['AttributeTag'] as $atk => $attributeTag) {\n                            if (empty($attributeTag['Tag'])) {\n                                unset($event['Attribute'][$key]['AttributeTag'][$atk]);\n                            }\n                        }\n                        $event['Attribute'][$key]['AttributeTag'] = array_values($event['Attribute'][$key]['AttributeTag']);\n                    }\n                    $event['Attribute'][$key]['ShadowAttribute'] = array();\n                    // If a shadowattribute can be linked to an attribute, link it to it then remove it from the event\n                    // This is to differentiate between proposals that were made to an attribute for modification and between proposals for new attributes\n\n                    if (isset($event['ShadowAttribute'])) {\n                        foreach ($event['ShadowAttribute'] as $k => $sa) {\n                            if (!empty($sa['old_id'])) {\n                                if ($event['ShadowAttribute'][$k]['old_id'] == $attribute['id']) {\n                                    $results[$eventKey]['Attribute'][$key]['ShadowAttribute'][] = $sa;\n                                    unset($results[$eventKey]['ShadowAttribute'][$k]);\n                                }\n                            }\n                        }\n                    }\n                    if (Configure::read('MISP.proposals_block_attributes') && isset($options['to_ids']) && $options['to_ids']) {\n                        foreach ($results[$eventKey]['Attribute'][$key]['ShadowAttribute'] as $sa) {\n                            if ($sa['proposal_to_delete'] || $sa['to_ids'] == 0) {\n                                unset($results[$eventKey]['Attribute'][$key]);\n                                continue;\n                            }\n                        }\n                    }\n                    if (!$flatten && $event['Attribute'][$key]['object_id'] != 0) {\n                        foreach ($event['Object'] as $objectKey => $object) {\n                            if ($object['id'] == $event['Attribute'][$key]['object_id']) {\n                                $event['Object'][$objectKey]['Attribute'][] = $event['Attribute'][$key];\n                                break;\n                            }\n                        }\n                        unset($event['Attribute'][$key]);\n                    }\n                }\n                $event['Attribute'] = array_values($event['Attribute']);\n            }\n            if (!empty($event['Object'])) {\n                $event['Object'] = $this->__attachSharingGroups(!$options['sgReferenceOnly'], $event['Object'], $sharingGroupData);\n                foreach ($event['Object'] as $objectKey => $objectValue) {\n                    if (!empty($event['Object'][$objectKey]['Attribute'])) {\n                        $event['Object'][$objectKey]['Attribute'] = $this->__attachSharingGroups(!$options['sgReferenceOnly'], $event['Object'][$objectKey]['Attribute'], $sharingGroupData);\n                        foreach ($event['Object'][$objectKey]['Attribute'] as $akey => $adata) {\n                            if ($adata['category'] === 'Financial fraud') {\n                                $event['Object'][$objectKey]['Attribute'][$akey] = $this->Attribute->attachValidationWarnings($adata);\n                            }\n                        }\n                    }\n                }\n            }\n            if (!empty($event['ShadowAttribute'])) {\n                if ($isSiteAdmin && isset($options['includeFeedCorrelations']) && $options['includeFeedCorrelations']) {\n                    $this->Feed = ClassRegistry::init('Feed');\n                    if (!empty($options['overrideLimit'])) {\n                        $overrideLimit = true;\n                    } else {\n                        $overrideLimit = false;\n                    }\n                    $event['ShadowAttribute'] = $this->Feed->attachFeedCorrelations($event['ShadowAttribute'], $user, $event['Event'], $overrideLimit);\n                }\n            }\n            $event['Sighting'] = $this->Sighting->attachToEvent($event, $user);\n            // remove proposals to attributes that we cannot see\n            // if the shadow attribute wasn't moved within an attribute before, this is the case\n            if (isset($event['ShadowAttribute'])) {\n                foreach ($event['ShadowAttribute'] as $k => $sa) {\n                    if (!empty($sa['old_id'])) {\n                        unset($event['ShadowAttribute'][$k]);\n                    }\n                }\n                $event['ShadowAttribute'] = array_values($event['ShadowAttribute']);\n            }\n            if ($event['Event']['orgc_id'] === $user['org_id'] && $user['Role']['perm_audit']) {\n                $UserEmail = $this->User->getAuthUser($event['Event']['user_id'])['email'];\n                $event['Event']['event_creator_email'] = $UserEmail;\n            }\n        }\n        if ($options['extended']) {\n            foreach ($results as $k => $result) {\n                $results[$k] = $this->__mergeExtensions($user, $result['Event']['uuid'], $result);\n            }\n        }\n        return $results;\n    }\n\n    private function __cacheRelatedEventTags($eventTagCache, $relatedAttribute)\n    {\n        if (empty($eventTagCache[$relatedAttribute['id']])) {\n            $params = array(\n                'contain' => array(\n                    'Tag' => array(\n                        'fields' => array(\n                            'Tag.id', 'Tag.name', 'Tag.colour', 'Tag.numerical_value'\n                        )\n                    )\n                ),\n                'recursive' => -1,\n                'conditions' => array(\n                    'EventTag.event_id' => $relatedAttribute['id']\n                )\n            );\n            $eventTags = $this->EventTag->find('all', $params);\n            if (!empty($eventTags)) {\n                foreach ($eventTags as $et) {\n                    if (!isset($eventTagCache[$relatedAttribute['id']][$et['Tag']['id']])) {\n                        $eventTagCache[$relatedAttribute['id']][$et['Tag']['id']] = $et['Tag'];\n                    }\n                }\n            }\n        }\n        return $eventTagCache;\n    }\n\n    public function includeRelatedTags($event, $options)\n    {\n        $eventTagCache = array();\n        $tags = array();\n        $includeAllTags = !empty($options['includeAllTags']);\n        foreach ($event['RelatedAttribute'] as $attributeId => $relatedAttributes) {\n            $attributePos = false;\n            foreach ($event['Attribute'] as $k => $attribute) {\n                if ($attribute['id'] == $attributeId) {\n                    $attributePos = $k;\n                    break;\n                }\n            }\n            foreach ($relatedAttributes as $relatedAttribute) {\n                $eventTagCache = $this->__cacheRelatedEventTags($eventTagCache, $relatedAttribute);\n                if (!empty($eventTagCache[$relatedAttribute['id']])) {\n                    if (!isset($event['Attribute'][$attributePos]['RelatedTags'])) {\n                        $event['Attribute'][$attributePos]['RelatedTags'] = array();\n                    }\n                    $event['Attribute'][$attributePos]['RelatedTags'] = array_merge($event['Attribute'][$attributePos]['RelatedTags'], $eventTagCache[$relatedAttribute['id']]);\n                }\n                $params = array(\n                    'contain' => array(\n                        'Tag' => array(\n                            'fields' => array(\n                                'Tag.id', 'Tag.name', 'Tag.colour', 'Tag.numerical_value'\n                            )\n                        )\n                    ),\n                    'recursive' => -1,\n                    'conditions' => array(\n                        'AttributeTag.attribute_id' => $relatedAttribute['attribute_id']\n                    )\n                );\n                $attributeTags = $this->Attribute->AttributeTag->find('all', $params);\n                if (!empty($attributeTags)) {\n                    foreach ($attributeTags as $at) {\n                        $event['Attribute'][$attributePos]['RelatedTags'][$at['Tag']['id']] = $at['Tag'];\n                    }\n                }\n            }\n        }\n        return $event;\n    }\n\n    private function __mergeExtensions($user, $uuid, $event)\n    {\n        $extensions = $this->fetchEvent($user, array('eventsExtendingUuid' => $uuid));\n        $thingsToMerge = array('Attribute', 'Object', 'ShadowAttribute', 'EventTag', 'Galaxy', 'RelatedEvent');\n        foreach ($extensions as $k2 => $extensionEvent) {\n            $eventMeta = array(\n                'id' => $extensionEvent['Event']['id'],\n                'info' => $extensionEvent['Event']['info'],\n                'Orgc' => array(\n                    'id' => $extensionEvent['Orgc']['id'],\n                    'name' => $extensionEvent['Orgc']['name'],\n                    'uuid' => $extensionEvent['Orgc']['uuid']\n                )\n            );\n            $event['Event']['extensionEvents'][$eventMeta['id']] = $eventMeta;\n            foreach ($thingsToMerge as $thingToMerge) {\n                $event[$thingToMerge] = array_merge($event[$thingToMerge], $extensionEvent[$thingToMerge]);\n            }\n        }\n        return $event;\n    }\n\n    private function __attachSharingGroups($doAttach, $data, $sharingGroupData)\n    {\n        if (!$doAttach) {\n            return $data;\n        }\n        foreach ($data as $k => $v) {\n            if ($v['distribution'] == 4) {\n                $data[$k]['SharingGroup'] = $sharingGroupData[$v['sharing_group_id']]['SharingGroup'];\n            }\n        }\n        return $data;\n    }\n\n    // Filter the attributes within an event based on the tag filter block rules\n    private function __filterBlockedAttributesByTags($event, $options, $user)\n    {\n        if (!empty($options['blockedAttributeTags'])) {\n            foreach ($options['blockedAttributeTags'] as $key => $blockedTag) {\n                if (!is_numeric($blockedTag)) {\n                    $options['blockedAttributeTags'][$key] = $this->EventTag->Tag->lookupTagIdFromName($blockedTag);\n                } else {\n                    $options['blockedAttributeTags'][$key] = $blockedTag;\n                }\n            }\n        }\n        if (!empty($user['Server']['push_rules'])) {\n            $push_rules = json_decode($user['Server']['push_rules'], true);\n            if (!empty($push_rules['tags']['NOT'])) {\n                if (empty($options['blockedAttributeTags'])) {\n                    $options['blockedAttributeTags'] = array();\n                }\n                $options['blockedAttributeTags'] = array_merge($options['blockedAttributeTags'], $push_rules['tags']['NOT']);\n            }\n        }\n        if (!empty($options['blockedAttributeTags'])) {\n            if (!empty($event['Attribute'])) {\n                $event['Attribute'] = $this->__filterBlockedAttributesFromContainer($event['Attribute'], $options['blockedAttributeTags']);\n            }\n        }\n        return $event;\n    }\n\n    // accepts an attribute array and a list of blocked tags. Returns the attribute array with the blocked attributes cleaned out.\n    private function __filterBlockedAttributesFromContainer($container, $blockedTags)\n    {\n        foreach ($container as $key => $attribute) {\n            if (!empty($attribute['AttributeTag'])) {\n                foreach ($attribute['AttributeTag'] as $at) {\n                    if (in_array($at['tag_id'], $blockedTags)) {\n                        unset($container[$key]);\n                    }\n                }\n            }\n        }\n        $container = array_values($container);\n        return $container;\n    }\n\n    private function __escapeCSVField(&$field)\n    {\n        $field = str_replace(array('\"'), '\"\"', $field);\n        $field = '\"' . $field . '\"';\n    }\n\n    public function set_filter_org(&$params, $conditions, $options)\n    {\n        if (!empty($params['org'])) {\n            $params['org'] = $this->convert_filters($params['org']);\n            if (!empty($params['org']['OR'])) {\n                foreach ($params['org']['OR'] as $k => $org) {\n                    if (!is_numeric($org)) {\n                        $existingOrg = $this->Orgc->find('first', array(\n                            'recursive' => -1,\n                            'conditions' => array('Orgc.name' => $org),\n                            'fields' => array('Orgc.name', 'Orgc.id')\n                        ));\n                        if (empty($existingOrg)) {\n                            $params['org']['OR'][$k] = -1;\n                        } else {\n                            $params['org']['OR'][$k] = $existingOrg['Orgc']['id'];\n                        }\n                    }\n                }\n            }\n            if (!empty($params['org']['NOT'])) {\n                $temp = array();\n                foreach ($params['org']['NOT'] as $org) {\n                    if (!is_numeric($org)) {\n                        $existingOrg = $this->Orgc->find('first', array(\n                            'recursive' => -1,\n                            'conditions' => array('Orgc.name' => $org),\n                            'fields' => array('Orgc.name', 'Orgc.id')\n                        ));\n                        if (!empty($existingOrg)) {\n                            $temp[] = $existingOrg['Orgc']['id'];\n                        }\n                    } else {\n                        $temp[] = $org;\n                    }\n                }\n                if (!empty($temp)) {\n                    $params['org']['NOT'] = $temp;\n                } else {\n                    unset($params['org']['NOT']);\n                }\n            }\n            $conditions = $this->generic_add_filter($conditions, $params['org'], 'Event.orgc_id');\n        }\n        return $conditions;\n    }\n\n    public function set_filter_eventid(&$params, $conditions, $options)\n    {\n        if (!empty($params['eventid']) && $params['eventid'] !== 'all') {\n            $params['eventid'] = $this->convert_filters($params['eventid']);\n            $conditions = $this->generic_add_filter($conditions, $params['eventid'], 'Event.id');\n        }\n        return $conditions;\n    }\n\n    public function set_filter_eventinfo(&$params, $conditions, $options)\n    {\n        if (!empty($params['eventinfo'])) {\n            $params['eventinfo'] = $this->convert_filters($params['eventinfo']);\n            $conditions = $this->generic_add_filter($conditions, $params['eventinfo'], 'Event.info');\n        }\n        return $conditions;\n    }\n\n    public function set_filter_uuid(&$params, $conditions, $options)\n    {\n        if (!empty($params['uuid'])) {\n            $params['uuid'] = $this->convert_filters($params['uuid']);\n            if (!empty($options['scope']) || $options['scope'] === 'Event') {\n                $conditions = $this->generic_add_filter($conditions, $params['uuid'], 'Event.uuid');\n            }\n            if (!empty($options['scope']) || $options['scope'] === 'Attribute') {\n                $conditions = $this->generic_add_filter($conditions, $params['uuid'], 'Attribute.uuid');\n            }\n        }\n        return $conditions;\n    }\n\n    public function set_filter_deleted(&$params, $conditions, $options)\n    {\n        if (!empty($params['deleted'])) {\n            if (empty($options['scope'])) {\n                $scope = 'Attribute';\n            } else {\n                $scope = $options['scope'];\n            }\n            if ($params['deleted']) {\n                $conditions = $this->generic_add_filter($conditions, $params['deleted'], $scope . '.deleted');\n            }\n        }\n        return $conditions;\n    }\n\n    public function set_filter_to_ids(&$params, $conditions, $options)\n    {\n        if (isset($params['to_ids'])) {\n            if ($params['to_ids'] === 'exclude') {\n                $params['to_ids'] = 0;\n            }\n            $conditions['AND']['Attribute.to_ids'] = $params['to_ids'];\n        }\n        return $conditions;\n    }\n\n    public function set_filter_ignore(&$params, $conditions, $options)\n    {\n        if (empty($params['ignore'])) {\n            if (empty($options['scope'])) {\n                $scope = 'Attribute';\n            } else {\n                $scope = $options['scope'];\n            }\n            if ($scope === 'Attribute') {\n                $conditions['AND']['Attribute.to_ids'] = 1;\n            } else {\n                $conditions['AND']['Event.published'] = 1;\n            }\n        }\n        return $conditions;\n    }\n\n    public function set_filter_published(&$params, $conditions, $options)\n    {\n        if (isset($params['published'])) {\n            $conditions['AND']['Event.published'] = $params['published'];\n        }\n        return $conditions;\n    }\n\n    public function set_filter_tags(&$params, $conditions, $options)\n    {\n        if (!empty($params['tags'])) {\n            $conditions = $this->Attribute->set_filter_tags($params, $conditions, $options);\n        }\n        return $conditions;\n    }\n\n    public function set_filter_simple_attribute(&$params, $conditions, $options)\n    {\n        if (!empty($params[$options['filter']])) {\n            $params[$options['filter']] = $this->convert_filters($params[$options['filter']]);\n            $conditions = $this->generic_add_filter($conditions, $params[$options['filter']], 'Attribute.' . $options['filter']);\n        }\n        return $conditions;\n    }\n\n    public function set_filter_attribute_id(&$params, $conditions, $options)\n    {\n        if (!empty($params[$options['filter']])) {\n            $params[$options['filter']] = $this->convert_filters($params[$options['filter']]);\n            $conditions = $this->generic_add_filter($conditions, $params[$options['filter']], 'Attribute.' . $options['filter']);\n        }\n        return $conditions;\n    }\n\n    public function set_filter_value(&$params, $conditions, $options)\n    {\n        if (!empty($params['value'])) {\n            $params[$options['filter']] = $this->convert_filters($params[$options['filter']]);\n            $conditions = $this->generic_add_filter($conditions, $params[$options['filter']], array('Attribute.value1', 'Attribute.value2'));\n        }\n        return $conditions;\n    }\n\n    public function set_filter_comment(&$params, $conditions, $options)\n    {\n        if (!empty($params['comment'])) {\n            $params['comment'] = $this->convert_filters($params['comment']);\n            $conditions = $this->generic_add_filter($conditions, $params['comment'], 'Attribute.comment');\n        }\n        return $conditions;\n    }\n\n    public function set_filter_timestamp(&$params, $conditions, $options)\n    {\n        if ($options['filter'] == 'from') {\n            $conditions['AND']['Event.date >='] = $params['from'];\n        } elseif ($options['filter'] == 'to') {\n            $conditions['AND']['Event.date <='] = $params['to'];\n        } else {\n            if (empty($options['scope'])) {\n                $scope = 'Attribute';\n            } else {\n                $scope = $options['scope'];\n            }\n            $filters = array(\n                'timestamp' => array(\n                    $scope . '.timestamp'\n                ),\n                'publish_timestamp' => array(\n                    'Event.publish_timestamp'\n                ),\n                'last' => array(\n                    'Event.publish_timestamp'\n                ),\n                'event_timestamp' => array(\n                    'Event.timestamp'\n                )\n            );\n            foreach ($filters[$options['filter']] as $f) {\n                $conditions = $this->Attribute->setTimestampConditions($params[$options['filter']], $conditions, $f);\n            }\n        }\n        return $conditions;\n    }\n\n    public function csv($user, $params, $search = false, &$continue = true)\n    {\n        $conditions = array();\n        $simple_params = array(\n            'eventid' => array('function' => 'set_filter_eventid'),\n            'ignore' => array('function' => 'set_filter_ignore'),\n            'tags' => array('function' => 'set_filter_tags'),\n            'category' => array('function' => 'set_filter_simple_attribute'),\n            'type' => array('function' => 'set_filter_simple_attribute'),\n            'from' => array('function' => 'set_filter_timestamp'),\n            'to' => array('function' => 'set_filter_timestamp'),\n            'last' => array('function' => 'set_filter_timestamp'),\n            'value' => array('function' => 'set_filter_value'),\n            'timestamp' => array('function' => 'set_filter_timestamp'),\n            'attributeIDList' => array('functon' => 'set_filter_attribute_id')\n        );\n        foreach ($params as $param => $paramData) {\n            if (isset($simple_params[$param]) && $params[$param] !== false) {\n                $options = array(\n                    'filter' => $param,\n                    'scope' => 'Event',\n                    'pop' => !empty($simple_param_scoped[$param]['pop'])\n                );\n                $conditions = $this->{$simple_params[$param]['function']}($params, $conditions, $options);\n            }\n        }\n        //$attributeIDList = array(), $includeContext = false, $enforceWarninglist = false\n        $this->recursive = -1;\n        if (!empty($params['eventid']) && $params['eventid'] === 'search') {\n            foreach ($params['attributeIDList'] as $aID) {\n                $conditions['AND']['OR'][] = array('Attribute.id' => $aID);\n            }\n        }\n        $csv_params = array(\n                'conditions' => $conditions, //array of conditions\n                'fields' => array('Attribute.event_id', 'Attribute.distribution', 'Attribute.category', 'Attribute.type', 'Attribute.value', 'Attribute.comment', 'Attribute.uuid', 'Attribute.to_ids', 'Attribute.timestamp', 'Attribute.id', 'Attribute.object_relation'),\n                'order' => array('Attribute.uuid ASC'),\n                'flatten' => true\n        );\n\n        // copy over the parameters that have to deal with pagination or additional functionality to be executed\n        $control_params = array(\n            'limit', 'page', 'enforceWarninglist'\n        );\n        foreach ($control_params as $control_param) {\n            if (!empty($params[$control_param])) {\n                $csv_params[$control_param] = $params[$control_param];\n            }\n        }\n        $csv_params = $this->__appendIncludesCSV($csv_params, !empty($params['includeContext']));\n        $attributes = $this->Attribute->fetchAttributes($user, $csv_params, $continue);\n        $attributes = $this->__sanitiseCSVAttributes($attributes, !empty($params['includeContext']), !empty($params['ignore']));\n        return $attributes;\n    }\n\n    private function __appendIncludesCSV($params, $includeContext)\n    {\n        if ($includeContext) {\n            $params['contain'] = array(\n                'Event' => array(\n                        'fields' => array('id', 'info', 'org_id', 'orgc_id', 'date', 'distribution', 'analysis'),\n                        'SharingGroup' => array('fields' => array('id', 'name')),\n                        'Org' => array('id', 'name'),\n                        'Orgc' => array('id', 'name'),\n                        'ThreatLevel' => array(\n                                'fields' => array('id', 'name'),\n                        ),\n                        'EventTag' => array(\n                                'Tag' => array(\n                                        'fields' => array('id', 'name')\n                                )\n                        )\n                ),\n            );\n        }\n        $params['contain']['Object'] = array('fields' => array('id', 'uuid', 'name', 'meta-category'));\n        return $params;\n    }\n\n    private function __sanitiseCSVAttributes($attributes, $includeContext, $ignore)\n    {\n        if (!empty($ignore)) {\n            $this->Whitelist = ClassRegistry::init('Whitelist');\n            $attributes = $this->Whitelist->removeWhitelistedFromArray($attributes, true);\n        }\n        foreach ($attributes as &$attribute) {\n            $this->__escapeCSVField($attribute['Attribute']['value']);\n            $this->__escapeCSVField($attribute['Attribute']['comment']);\n            $this->__escapeCSVField($attribute['Attribute']['object_relation']);\n            $this->__escapeCSVField($attribute['Attribute']['uuid']);\n            $this->__escapeCSVField($attribute['Attribute']['category']);\n            $this->__escapeCSVField($attribute['Attribute']['type']);\n            $attribute['Attribute']['timestamp'] = date('Ymd', $attribute['Attribute']['timestamp']);\n            if (empty($attribute['Object'])) {\n                $attribute['Object']['uuid'] = '\"\"';\n                $attribute['Object']['name'] = '';\n                $attribute['Object']['meta-category'] = '';\n            }\n            $this->__escapeCSVField($attribute['Object']['name']);\n            $this->__escapeCSVField($attribute['Object']['uuid']);\n            $this->__escapeCSVField($attribute['Object']['meta-category']);\n            if ($includeContext) {\n                $this->__escapeCSVField($attribute['Event']['info']);\n                $this->__escapeCSVField($attribute['Event']['uuid']);\n                $this->__escapeCSVField($attribute['Org']['name']);\n                $this->__escapeCSVField($attribute['Orgc']['name']);\n                $attribute['Event']['Tag']['name'] = '';\n                $attribute['attribute_tag'] = '';\n                if (!empty($attribute['AttributeTag'])) {\n                    $tags = array();\n                    foreach ($attribute['AttributeTag'] as $attributeTag) {\n                        if (!empty($attributeTag['Tag']['name'])) {\n                            $tags[] = $attributeTag['Tag']['name'];\n                        }\n                    }\n                    $attribute['Attribute']['attribute_tag'] = implode(',', $tags);\n                }\n                $this->__escapeCSVField($attribute['Attribute']['attribute_tag']);\n                if (!empty($attribute['Event']['EventTag'])) {\n                    $tags = array();\n                    foreach ($attribute['Event']['EventTag'] as $eventTag) {\n                        if (!empty($eventTag['Tag']['name'])) {\n                            $tags[] = $eventTag['Tag']['name'];\n                        }\n                    }\n                    $attribute['Event']['Tag']['name'] = implode(',', $tags);\n                }\n                $this->__escapeCSVField($attribute['Event']['Tag']['name']);\n            }\n        }\n        return $attributes;\n    }\n\n    public function sendAlertEmailRouter($id, $user, $oldpublish = null)\n    {\n        if (Configure::read('MISP.block_old_event_alert') && Configure::read('MISP.block_old_event_alert_age') && is_numeric(Configure::read('MISP.block_old_event_alert_age'))) {\n            $oldest = time() - (Configure::read('MISP.block_old_event_alert_age') * 86400);\n            $event = $this->find('first', array(\n                    'conditions' => array('Event.id' => $id),\n                    'recursive' => -1,\n                    'fields' => array('Event.date')\n            ));\n            if (empty($event)) {\n                return false;\n            }\n            if (strtotime($event['Event']['date']) < $oldest) {\n                return true;\n            }\n        }\n        if (Configure::read('MISP.block_event_alert') && Configure::read('MISP.block_event_alert_tag') && !empty(Configure::read('MISP.block_event_alert_tag'))) {\n            $noAlertTag = Configure::read('MISP.block_event_alert_tag');\n            $tagLen = strlen($noAlertTag);\n            $event = $this->fetchEvent($user, array('eventid' => $id, 'includeAllTags' => true));\n            if (empty($event)) {\n                return false;\n            }\n            foreach ($event[0]['EventTag'] as $k => $tag) {\n                if (strcasecmp($noAlertTag, $tag['Tag']['name']) == 0) {\n                    return true;\n                }\n            }\n        }\n        if (Configure::read('MISP.disable_emailing')) {\n            $this->Log = ClassRegistry::init('Log');\n            $this->Log->create();\n            $this->Log->save(array(\n                    'org' => 'SYSTEM',\n                    'model' => 'Event',\n                    'model_id' => $id,\n                    'email' => $user['email'],\n                    'action' => 'publish',\n                    'title' => 'E-mail alerts not sent out during publishing. Reason: Emailing is currently disabled on this instance.',\n                    'change' => null,\n            ));\n            return true;\n        }\n        if (Configure::read('MISP.background_jobs')) {\n            $job = ClassRegistry::init('Job');\n            $job->create();\n            $data = array(\n                    'worker' => 'email',\n                    'job_type' => 'publish_alert_email',\n                    'job_input' => 'Event: ' . $id,\n                    'status' => 0,\n                    'retries' => 0,\n                    'org_id' => $user['org_id'],\n                    'org' => $user['Organisation']['name'],\n                    'message' => 'Sending...',\n            );\n            $job->save($data);\n            $jobId = $job->id;\n            $process_id = CakeResque::enqueue(\n                    'email',\n                    'EventShell',\n                    array('alertemail', $user['id'], $jobId, $id, $oldpublish),\n                    true\n            );\n            $job->saveField('process_id', $process_id);\n            return true;\n        } else {\n            return ($this->sendAlertEmail($id, $user, $oldpublish));\n        }\n    }\n\n    public function sendAlertEmail($id, $senderUser, $oldpublish = null, $processId = null)\n    {\n        $event = $this->fetchEvent($senderUser, array('eventid' => $id, 'includeAllTags' => true));\n        if (empty($event)) {\n            throw new MethodNotFoundException('Invalid Event.');\n        }\n        $userConditions = array('autoalert' => 1);\n        $this->User = ClassRegistry::init('User');\n        $users = $this->User->getUsersWithAccess(\n            $owners = array(\n                $event[0]['Event']['orgc_id'],\n                $event[0]['Event']['org_id']\n            ),\n            $event[0]['Event']['distribution'],\n            $event[0]['Event']['sharing_group_id'],\n            $userConditions\n        );\n        if (Configure::read('MISP.extended_alert_subject')) {\n            $subject = preg_replace(\"/\\r|\\n/\", \"\", $event[0]['Event']['info']);\n            if (strlen($subject) > 58) {\n                $subject = substr($subject, 0, 55) . '... - ';\n            } else {\n                $subject .= \" - \";\n            }\n        } else {\n            $subject = '';\n        }\n        $subjMarkingString = !empty(Configure::read('MISP.email_subject_TLP_string')) ? Configure::read('MISP.email_subject_TLP_string') : \"tlp:amber\";\n        $subjTag = !empty(Configure::read('MISP.email_subject_tag')) ? Configure::read('MISP.email_subject_tag') : \"tlp\";\n        $tagLen = strlen($subjTag);\n        foreach ($event[0]['EventTag'] as $k => $tag) {\n            $tagName=$tag['Tag']['name'];\n            if (strncasecmp($subjTag, $tagName, $tagLen) == 0 && strlen($tagName) > $tagLen && ($tagName[$tagLen] == ':' || $tagName[$tagLen] == '=')) {\n                if (Configure::read('MISP.email_subject_include_tag_name') === false) {\n                    $subjMarkingString = trim(substr($tagName, $tagLen+1), '\"');\n                } else {\n                    $subjMarkingString = $tagName;\n                }\n                break;\n            }\n        }\n        $threatLevel = $event[0]['ThreatLevel']['name'] . \" - \";\n        if (Configure::read('MISP.threatlevel_in_email_subject') === false) {\n            $threatLevel = '';\n        }\n        $subject = \"[\" . Configure::read('MISP.org') . \" MISP] Event \" . $id . \" - \" . $subject . $threatLevel . $subjMarkingString;\n\n        // Initialise the Job class if we have a background process ID\n        // This will keep updating the process's progress bar\n        if ($processId) {\n            $this->Job = ClassRegistry::init('Job');\n        }\n        $sgModel = ClassRegistry::init('SharingGroup');\n\n        $userCount = count($users);\n        foreach ($users as $k => $user) {\n            $body = $this->__buildAlertEmailBody($event[0], $user, $oldpublish, $sgModel);\n            $bodyNoEnc = \"A new or modified event was just published on \" . Configure::read('MISP.baseurl') . \"/events/view/\" . $event[0]['Event']['id'];\n            $this->User->sendEmail(array('User' => $user), $body, $bodyNoEnc, $subject);\n            if ($processId) {\n                $this->Job->id = $processId;\n                $this->Job->saveField('progress', $k / $userCount * 100);\n            }\n        }\n\n        if ($processId) {\n            $this->Job->saveField('message', 'Mails sent.');\n        }\n        return true;\n    }\n\n    private function __buildAlertEmailObject($user, &$body, &$bodyTempOther, $objects, $owner, $oldpublish)\n    {\n        foreach ($objects as $object) {\n            if (!$owner && $object['distribution'] == 0) {\n                continue;\n            }\n            if ($object['distribution'] == 4 && !$this->SharingGroup->checkIfAuthorised($user, $object['sharing_group_id'])) {\n                continue;\n            }\n            if (isset($oldpublish) && isset($object['timestamp']) && $object['timestamp'] > $oldpublish) {\n                $body .= '* ';\n            } else {\n                $body .= '  ';\n            }\n            $body .= $object['name'] . '/' . $object['meta-category'] . \"\\n\";\n            if (!empty($object['Attribute'])) {\n                $body .= $this->__buildAlertEmailAttribute($user, $body, $bodyTempOther, $object['Attribute'], $owner, $oldpublish, '    ');\n            }\n        }\n    }\n\n    private function __buildAlertEmailAttribute($user, &$body, &$bodyTempOther, $attributes, $owner, $oldpublish, $indent = '  ')\n    {\n        $appendlen = 20;\n        foreach ($attributes as $attribute) {\n            if (!$owner && $attribute['distribution'] == 0) {\n                continue;\n            }\n            if ($attribute['distribution'] == 4 && !$this->SharingGroup->checkIfAuthorised($user, $attribute['sharing_group_id'])) {\n                continue;\n            }\n            $ids = '';\n            if ($attribute['to_ids']) {\n                $ids = ' (IDS)';\n            }\n            $strRepeatCount = $appendlen - 2 - strlen($attribute['type']);\n            $strRepeat = ($strRepeatCount > 0) ? str_repeat(' ', $strRepeatCount) : '';\n            if (isset($oldpublish) && isset($attribute['timestamp']) && $attribute['timestamp'] > $oldpublish) {\n                $line = '* ' . $indent . $attribute['category'] . '/' . $attribute['type'] . $strRepeat . ': ' . $attribute['value'] . $ids . \" *\\n\";\n            } else {\n                $line = $indent . $attribute['category'] . '/' . $attribute['type'] . $strRepeat . ': ' . $attribute['value'] . $ids .  \"\\n\";\n            }\n            // Defanging URLs (Not \"links\") emails domains/ips in notification emails\n            if ('url' == $attribute['type'] || 'uri' == $attribute['type']) {\n                $line = str_ireplace(\"http\", \"hxxp\", $line);\n                $line = str_ireplace(\".\", \"[.]\", $line);\n            } elseif (in_array($attribute['type'], array('email-src', 'email-dst', 'whois-registrant-email', 'dns-soa-email', 'email-reply-to'))) {\n                $line = str_replace(\"@\", \"[at]\", $line);\n            } elseif (in_array($attribute['type'], array('hostname', 'domain', 'ip-src', 'ip-dst', 'domain|ip'))) {\n                $line = str_replace(\".\", \"[.]\", $line);\n            }\n            if (!empty($attribute['AttributeTag'])) {\n                $line .= '  - Tags: ';\n                foreach ($attribute['AttributeTag'] as $k => $aT) {\n                    if ($k > 0) {\n                        $line .= ', ';\n                    }\n                    $line .= $aT['Tag']['name'];\n                }\n                $line .= \"\\n\";\n            }\n            if ('other' == $attribute['type']) { // append the 'other' attribute types to the bottom.\n                $bodyTempOther .= $line;\n            } else {\n                $body .= $line;\n            }\n        }\n    }\n\n    private function __buildAlertEmailBody($event, $user, $oldpublish, $sgModel)\n    {\n        $owner = false;\n        if ($user['org_id'] == $event['Event']['orgc_id'] || $user['org_id'] == $event['Event']['org_id'] || $user['Role']['perm_site_admin']) {\n            $owner = true;\n        }\n        // The mail body, h() is NOT needed as we are sending plain-text mails.\n        $body = \"\";\n        $body .= '==============================================' . \"\\n\";\n        $appendlen = 20;\n        $body .= 'URL         : ' . Configure::read('MISP.baseurl') . '/events/view/' . $event['Event']['id'] . \"\\n\";\n        $body .= 'Event ID    : ' . $event['Event']['id'] . \"\\n\";\n        $body .= 'Date        : ' . $event['Event']['date'] . \"\\n\";\n        if (Configure::read('MISP.showorg')) {\n            $body .= 'Reported by : ' . $event['Orgc']['name'] . \"\\n\";\n            $body .= 'Local owner of the event : ' . $event['Org']['name'] . \"\\n\";\n        }\n        $body .= 'Distribution: ' . $this->distributionLevels[$event['Event']['distribution']] . \"\\n\";\n        if ($event['Event']['distribution'] == 4) {\n            $body .= 'Sharing Group:' . $event['SharingGroup']['name'] . \"\\n\";\n        }\n        $tags = \"\";\n        foreach ($event['EventTag'] as $k => $tag) {\n            $tags .= $tag['Tag']['name'];\n            if (($k+1) != count($event['EventTag'])) {\n                $tags .= \", \";\n            }\n        }\n        $body .= 'Tags: ' . $tags . \"\\n\";\n        $body .= 'Threat Level: ' . $event['ThreatLevel']['name'] . \"\\n\";\n        $body .= 'Analysis    : ' . $this->analysisLevels[$event['Event']['analysis']] . \"\\n\";\n        $body .= 'Description : ' . $event['Event']['info'] . \"\\n\";\n        $relatedEvents = $this->getRelatedEvents($user, $event['Event']['id'], array());\n        if (!empty($relatedEvents)) {\n            $body .= '==============================================' . \"\\n\";\n            $body .= 'Related to: '. \"\\n\";\n            foreach ($relatedEvents as &$relatedEvent) {\n                $body .= Configure::read('MISP.baseurl') . '/events/view/' . $relatedEvent['Event']['id'] . ' (' . $relatedEvent['Event']['date'] . ') ' .\"\\n\";\n            }\n            $body .= '==============================================' . \"\\n\";\n        }\n        $bodyTempOther = \"\";\n        if (!empty($event['Attribute'])) {\n            $body .= 'Attributes (* indicates a new or modified attribute):' . \"\\n\";\n            $this->__buildAlertEmailAttribute($user, $body, $bodyTempOther, $event['Attribute'], $owner, $oldpublish);\n        }\n        if (!empty($event['Object'])) {\n            $body .= 'Objects (* indicates a new or modified object):' . \"\\n\";\n            $this->__buildAlertEmailObject($user, $body, $bodyTempOther, $event['Object'], $owner, $oldpublish);\n        }\n        if (!empty($bodyTempOther)) {\n            $body .= \"\\n\";\n        }\n        $body .= $bodyTempOther;\t// append the 'other' attribute types to the bottom.\n        $body .= '==============================================' . \"\\n\";\n        return $body;\n    }\n\n    public function sendContactEmail($id, $message, $creator_only, $user, $isSiteAdmin)\n    {\n        // fetch the event\n        $event = $this->read(null, $id);\n        $this->User = ClassRegistry::init('User');\n        if (!$creator_only) {\n            // Insert extra field here: alertOrg or something, then foreach all the org members\n            // limit this array to users with contactalerts turned on!\n            $orgMembers = array();\n            $this->User->recursive = 0;\n            $temp = $this->User->find('all', array(\n                    'fields' => array('email', 'gpgkey', 'certif_public', 'contactalert', 'id', 'org_id'),\n                    'conditions' => array('disabled' => 0, 'User.org_id' => $event['Event']['orgc_id']),\n                    'recursive' => -1\n            ));\n            if (empty($temp)) {\n                $temp = $this->User->find('all', array(\n                        'fields' => array('email', 'gpgkey', 'certif_public', 'contactalert', 'id', 'org_id'),\n                        'conditions' => array('disabled' => 0, 'User.org_id' => $event['Event']['org_id']),\n                        'recursive' => -1\n                ));\n            }\n            foreach ($temp as $tempElement) {\n                if ($tempElement['User']['contactalert'] || $tempElement['User']['id'] == $event['Event']['user_id']) {\n                    array_push($orgMembers, $tempElement);\n                }\n            }\n        } else {\n            $temp = $this->User->find('first', array(\n                    'conditions' => array('User.id' => $event['Event']['user_id'], 'User.disabled' => 0),\n                    'fields' => array('User.email', 'User.gpgkey', 'User.certif_public'),\n            ));\n            if (!empty($temp)) {\n                $orgMembers = array(0 => $temp);\n            }\n        }\n        if (empty($orgMembers)) {\n            return false;\n        }\n        $temp = $this->__buildContactEventEmailBody($user, $message, $event, $targetUser, $id);\n        $bodyevent = $temp[0];\n        $body = $temp[1];\n        $result = true;\n        $tplColorString = !empty(Configure::read('MISP.email_subject_TLP_string')) ? Configure::read('MISP.email_subject_TLP_string') : \"TLP Amber\";\n        foreach ($orgMembers as &$reporter) {\n            $subject = \"[\" . Configure::read('MISP.org') . \" MISP] Need info about event \" . $id . \" - \".$tplColorString;\n            $result = $this->User->sendEmail($reporter, $bodyevent, $body, $subject, $user) && $result;\n        }\n        return $result;\n    }\n\n    private function __buildContactEventEmailBody($user, $message, $event, $targetUser, $id)\n    {\n        // The mail body, h() is NOT needed as we are sending plain-text mails.\n        $body = \"\";\n        $body .= \"Hello, \\n\";\n        $body .= \"\\n\";\n        $body .= \"Someone wants to get in touch with you concerning a MISP event. \\n\";\n        $body .= \"\\n\";\n        $body .= \"You can reach him at \" . $user['User']['email'] . \"\\n\";\n        if (!$user['User']['gpgkey']) {\n            $body .= \"His GnuPG key is added as attachment to this email. \\n\";\n        }\n        if (!$user['User']['certif_public']) {\n            $body .= \"His Public certificate is added as attachment to this email. \\n\";\n        }\n        $body .= \"\\n\";\n        $body .= \"He wrote the following message: \\n\";\n        $body .= $message . \"\\n\";\n        $body .= \"\\n\";\n        $body .= \"\\n\";\n        $body .= \"The event is the following: \\n\";\n\n        // print the event in mail-format\n        // LATER place event-to-email-layout in a function\n        $appendlen = 20;\n        $body .= 'URL         : ' . Configure::read('MISP.baseurl') . '/events/view/' . $event['Event']['id'] . \"\\n\";\n        $bodyevent = $body;\n        $bodyevent .= 'Event ID    : ' . $event['Event']['id'] . \"\\n\";\n        $bodyevent .= 'Date        : ' . $event['Event']['date'] . \"\\n\";\n        if (Configure::read('MISP.showorg')) {\n            $body .= 'Reported by : ' . $event['Orgc']['name'] . \"\\n\";\n        }\n        $bodyevent .= 'Risk        : ' . $event['ThreatLevel']['name'] . \"\\n\";\n        $bodyevent .= 'Analysis    : ' . $event['Event']['analysis'] . \"\\n\";\n\n        $userModel = ClassRegistry::init('User');\n        $targetUser = $userModel->getAuthUser($orgMembers[0]['User']['id']);\n        $sgModel = ClassRegistry::init('SharingGroup');\n        $sgs = $sgModel->fetchAllAuthorised($targetUser, false);\n\n        $relatedEvents = $this->getRelatedEvents($targetUser, $id, $sgs);\n        if (!empty($relatedEvents)) {\n            foreach ($relatedEvents as &$relatedEvent) {\n                $bodyevent .= 'Related to  : ' . Configure::read('MISP.baseurl') . '/events/view/' . $relatedEvent['Event']['id'] . ' (' . $relatedEvent['Event']['date'] . ')' . \"\\n\";\n            }\n        }\n        $bodyevent .= 'Info  : ' . \"\\n\";\n        $bodyevent .= $event['Event']['info'] . \"\\n\";\n        $bodyevent .= \"\\n\";\n        $bodyevent .= 'Attributes  :' . \"\\n\";\n        $bodyTempOther = \"\";\n        if (!empty($event['Attribute'])) {\n            foreach ($event['Attribute'] as &$attribute) {\n                $line = '- ' . $attribute['type'] . str_repeat(' ', $appendlen - 2 - strlen($attribute['type'])) . ': ' . $attribute['value'] . \"\\n\";\n                if ('other' == $attribute['type']) { // append the 'other' attribute types to the bottom.\n                    $bodyTempOther .= $line;\n                } else {\n                    $bodyevent .= $line;\n                }\n            }\n        }\n        $bodyevent .= \"\\n\";\n        $bodyevent .= $bodyTempOther;\t// append the 'other' attribute types to the bottom.\n        return array($bodyevent, $body);\n    }\n\n    private function __captureSGForElement($element, $user)\n    {\n        if (isset($element['SharingGroup'])) {\n            $sg = $this->SharingGroup->captureSG($element['SharingGroup'], $user);\n            unset($element['SharingGroup']);\n        } elseif (isset($element['sharing_group_id'])) {\n            $sg = $this->SharingGroup->checkIfAuthorised($user, $element['sharing_group_id']) ? $element['sharing_group_id'] : false;\n        } else {\n            $sg = false;\n        }\n        if ($sg===false) {\n            $sg = 0;\n            $element['distribution'] = 0;\n        }\n        $element['sharing_group_id'] = $sg;\n        return $element;\n    }\n\n    // When we receive an event via REST, we might end up with organisations, sharing groups, tags that we do not know\n    // or which we need to update. All of that is controlled in this method.\n    private function __captureObjects($data, $user)\n    {\n        // First we need to check whether the event or any attributes are tied to a sharing group and whether the user is even allowed to create the sharing group / is part of it\n        if (isset($data['Event']['distribution']) && $data['Event']['distribution'] == 4) {\n            $data['Event'] = $this->__captureSGForElement($data['Event'], $user);\n        }\n        if (!empty($data['Event']['Attribute'])) {\n            foreach ($data['Event']['Attribute'] as $k => $a) {\n                unset($data['Event']['Attribute']['id']);\n                if (isset($a['distribution']) && $a['distribution'] == 4) {\n                    $data['Event']['Attribute'][$k] = $this->__captureSGForElement($a, $user);\n                    if ($data['Event']['Attribute'][$k] === false) {\n                        unset($data['Event']['Attribute']);\n                    }\n                }\n            }\n        }\n        if (!empty($data['Event']['Object'])) {\n            foreach ($data['Event']['Object'] as $k => $o) {\n                if (isset($o['distribution']) && $o['distribution'] == 4) {\n                    $data['Event']['Object'][$k] = $this->__captureSGForElement($o, $user);\n                    if ($data['Event']['Object'][$k] === false) {\n                        unset($data['Event']['Object'][$k]);\n                        continue;\n                    }\n                }\n                foreach ($o['Attribute'] as $k2 => $a) {\n                    if (isset($a['distribution']) && $a['distribution'] == 4) {\n                        $data['Event']['Object'][$k]['Attribute'][$k2] = $this->__captureSGForElement($a, $user);\n                        if ($data['Event']['Object'][$k]['Attribute'][$k2] === false) {\n                            unset($data['Event']['Object'][$k]['Attribute'][$k2]);\n                        }\n                    }\n                }\n            }\n        }\n\n        // first we want to see how the creator organisation is encoded\n        // The options here are either by passing an organisation object along or simply passing a string along\n        if (isset($data['Event']['Orgc'])) {\n            $data['Event']['orgc_id'] = $this->Orgc->captureOrg($data['Event']['Orgc'], $user);\n            unset($data['Event']['Orgc']);\n        } elseif (isset($data['Event']['orgc'])) {\n            $data['Event']['orgc_id'] = $this->Orgc->captureOrg($data['Event']['orgc'], $user);\n            unset($data['Event']['orgc']);\n        } else {\n            $data['Event']['orgc_id'] = $user['org_id'];\n        }\n\n        $event_tag_ids = array();\n        if (isset($data['Event']['EventTag'])) {\n            if (isset($data['Event']['EventTag']['id'])) {\n                $data['Event']['EventTag'] = array($data['Event']['EventTag']);\n            }\n            $eventTags = array();\n            foreach ($data['Event']['EventTag'] as $k => $tag) {\n                $temp = $this->EventTag->Tag->captureTag($data['Event']['EventTag'][$k]['Tag'], $user);\n                if ($temp && !in_array($temp, $event_tag_ids)) {\n                    $eventTags[] = array('tag_id' => $temp);\n                    $event_tag_ids[] = $temp;\n                }\n                unset($data['Event']['EventTag'][$k]);\n            }\n            $data['Event']['EventTag'] = $eventTags;\n        } else {\n            $data['Event']['EventTag'] = array();\n        }\n        if (isset($data['Event']['Tag'])) {\n            if (isset($data['Event']['Tag']['name'])) {\n                $data['Event']['Tag'] = array($data['Event']['Tag']);\n            }\n            foreach ($data['Event']['Tag'] as $tag) {\n                $tag_id = $this->EventTag->Tag->captureTag($tag, $user);\n                if ($tag_id && !in_array($tag_id, $event_tag_ids)) {\n                    $data['Event']['EventTag'][] = array('tag_id' => $tag_id);\n                    $event_tag_ids[] = $tag_id;\n                }\n            }\n            unset($data['Event']['Tag']);\n        }\n\n        if (!empty($data['Event']['Attribute'])) {\n            $data['Event']['Attribute'] = $this->__captureAttributeTags($data['Event']['Attribute'], $user);\n        }\n        if (!empty($data['Event']['Object'])) {\n            foreach ($data['Event']['Object'] as $k => $object) {\n                if (!empty($data['Event']['Object'][$k]['Attribute'])) {\n                    $data['Event']['Object'][$k]['Attribute'] = $this->__captureAttributeTags($data['Event']['Object'][$k]['Attribute'], $user);\n                }\n            }\n        }\n        return $data;\n    }\n\n    private function __captureAttributeTags($attributes, $user)\n    {\n        foreach ($attributes as $k => $a) {\n            if (isset($attributes[$k]['AttributeTag'])) {\n                if (isset($attributes[$k]['AttributeTag']['id'])) {\n                    $attributes[$k]['AttributeTag'] = array($attributes[$k]['AttributeTag']);\n                }\n                $attributeTags = array();\n                foreach ($attributes[$k]['AttributeTag'] as $tk => $tag) {\n                    $attributeTags[] = array('tag_id' => $this->Attribute->AttributeTag->Tag->captureTag($attributes[$k]['AttributeTag'][$tk]['Tag'], $user));\n                    unset($attributes[$k]['AttributeTag'][$tk]);\n                }\n                $attributes[$k]['AttributeTag'] = $attributeTags;\n            } else {\n                $attributes[$k]['AttributeTag'] = array();\n            }\n            if (isset($attributes[$k]['Tag'])) {\n                if (isset($attributes[$k]['Tag']['name'])) {\n                    $attributes[$k]['Tag'] = array($attributes[$k]['Tag']);\n                }\n                foreach ($attributes[$k]['Tag'] as $tag) {\n                    $tag_id = $this->Attribute->AttributeTag->Tag->captureTag($tag, $user);\n                    if ($tag_id) {\n                        $attributes[$k]['AttributeTag'][] = array('tag_id' => $tag_id);\n                    }\n                }\n                unset($attributes[$k]['Tag']);\n            }\n        }\n        return $attributes;\n    }\n\n    // Low level function to add an Event based on an Event $data array\n    public function _add(&$data, $fromXml, $user, $org_id = 0, $passAlong = null, $fromPull = false, $jobId = null, &$created_id = 0, &$validationErrors = array())\n    {\n        if ($jobId) {\n            App::uses('AuthComponent', 'Controller/Component');\n        }\n        if (Configure::read('MISP.enableEventBlacklisting') !== false && isset($data['Event']['uuid'])) {\n            $this->EventBlacklist = ClassRegistry::init('EventBlacklist');\n            $r = $this->EventBlacklist->find('first', array('conditions' => array('event_uuid' => $data['Event']['uuid'])));\n            if (!empty($r)) {\n                return 'Blocked by blacklist';\n            }\n        }\n        $this->create();\n        // force check userid and orgname to be from yourself\n        $data['Event']['user_id'] = $user['id'];\n\n        if ($fromPull) {\n            $data['Event']['org_id'] = $org_id;\n        } else {\n            $data['Event']['org_id'] = $user['Organisation']['id'];\n        }\n        // set these fields if the event is freshly created and not pushed from another instance.\n        // Moved out of if (!$fromXML), since we might get a restful event without the orgc/timestamp set\n        if (!isset($data['Event']['orgc_id']) && !isset($data['Event']['orgc'])) {\n            $data['Event']['orgc_id'] = $data['Event']['org_id'];\n        } else {\n            if (!isset($data['Event']['Orgc'])) {\n                if (isset($data['Event']['orgc_id']) && $data['Event']['orgc_id'] != $user['org_id'] && !$user['Role']['perm_sync'] && !$user['Role']['perm_site_admin']) {\n                    throw new MethodNotAllowedException('Event cannot be created as you are not a member of the creator organisation.');\n                }\n            } else {\n                if ($data['Event']['Orgc']['uuid'] != $user['Organisation']['uuid'] && !$user['Role']['perm_sync'] && !$user['Role']['perm_site_admin']) {\n                    throw new MethodNotAllowedException('Event cannot be created as you are not a member of the creator organisation.');\n                }\n                if (isset($data['Event']['orgc']) && $data['Event']['orgc'] != $user['Organisation']['name'] && !$user['Role']['perm_sync'] && !$user['Role']['perm_site_admin']) {\n                    throw new MethodNotAllowedException('Event cannot be created as you are not a member of the creator organisation.');\n                }\n            }\n            if (isset($data['Event']['orgc_id']) && $data['Event']['orgc_id'] != $user['org_id'] && !$user['Role']['perm_sync'] && !$user['Role']['perm_site_admin']) {\n                throw new MethodNotAllowedException('Event cannot be created as you are not a member of the creator organisation.');\n            }\n        }\n        if (!Configure::check('MISP.enableOrgBlacklisting') || Configure::read('MISP.enableOrgBlacklisting') !== false) {\n            $this->OrgBlacklist = ClassRegistry::init('OrgBlacklist');\n            if (!isset($data['Event']['Orgc']['uuid'])) {\n                $orgc = $this->Orgc->find('first', array('conditions' => array('Orgc.id' => $data['Event']['orgc_id']), 'fields' => array('Orgc.uuid'), 'recursive' => -1));\n            } else {\n                $orgc = array('Orgc' => array('uuid' => $data['Event']['Orgc']['uuid']));\n            }\n            if ($this->OrgBlacklist->hasAny(array('OrgBlacklist.org_uuid' => $orgc['Orgc']['uuid']))) {\n                return 'blocked';\n            }\n        }\n        if ($fromXml) {\n            // Workaround for different structure in XML/array than what CakePHP expects\n            $data = $this->cleanupEventArrayFromXML($data);\n            // the event_id field is not set (normal) so make sure no validation errors are thrown\n            // LATER do this with\t$this->validator()->remove('event_id');\n            unset($this->Attribute->validate['event_id']); // otherwise gives bugs because event_id is not set\n            unset($this->Attribute->validate['value']['uniqueValue']); // unset this - we are saving a new event, there are no values to compare against and event_id is not set in the attributes\n        }\n        unset($data['Event']['id']);\n        if (isset($data['Event']['published']) && $data['Event']['published'] && $user['Role']['perm_publish'] == 0) {\n            $data['Event']['published'] = 0;\n        }\n        if (isset($data['Event']['uuid'])) {\n            // check if the uuid already exists\n            $existingEventCount = $this->find('count', array('conditions' => array('Event.uuid' => $data['Event']['uuid'])));\n            if ($existingEventCount > 0) {\n                // RESTful, set response location header so client can find right URL to edit\n                if ($fromPull) {\n                    return false;\n                }\n                $existingEvent = $this->find('first', array('conditions' => array('Event.uuid' => $data['Event']['uuid'])));\n                if ($fromXml) {\n                    $created_id = $existingEvent['Event']['id'];\n                }\n                return $existingEvent['Event']['id'];\n            } else {\n                if ($fromXml) {\n                    $data = $this->__captureObjects($data, $user);\n                }\n                if ($data === false) {\n                    $failedCapture = true;\n                }\n            }\n        } else {\n            if ($fromXml) {\n                $data = $this->__captureObjects($data, $user);\n            }\n            if ($data === false) {\n                $failedCapture = true;\n            }\n        }\n        if (!empty($failedCapture)) {\n            $this->Log = ClassRegistry::init('Log');\n            $this->Log->create();\n            $this->Log->save(array(\n                    'org' => $user['Organisation']['name'],\n                    'model' => 'Event',\n                    'model_id' => 0,\n                    'email' => $user['email'],\n                    'action' => 'add',\n                    'user_id' => $user['id'],\n                    'title' => 'Event could not be saved due to a failed sharing group capture.',\n                    'change' => ''\n            ));\n            $validationErrors['Event'] = 'Issues saving a Sharing Group.';\n            return json_encode($validationErrors);\n        }\n        $fieldList = array(\n                'Event' => array(\n                    'org_id',\n                    'orgc_id',\n                    'date',\n                    'threat_level_id',\n                    'analysis',\n                    'info',\n                    'user_id',\n                    'published',\n                    'uuid',\n                    'timestamp',\n                    'distribution',\n                    'sharing_group_id',\n                    'locked',\n                    'disable_correlation',\n                    'extends_uuid'\n                ),\n                'Attribute' => $this->Attribute->captureFields,\n                'Object' => array(\n                    'name',\n                    'meta-category',\n                    'description',\n                    'template_uuid',\n                    'template_version',\n                    'event_id',\n                    'uuid',\n                    'timestamp',\n                    'distribution',\n                    'sharing_group_id',\n                    'comment',\n                    'deleted'\n                ),\n                'ObjectRelation' => array()\n        );\n        $saveResult = $this->save(array('Event' => $data['Event']), array('fieldList' => $fieldList['Event']));\n        $this->Log = ClassRegistry::init('Log');\n        if ($saveResult) {\n            if ($passAlong) {\n                $this->Server = ClassRegistry::init('Server');\n                $server = $this->Server->find('first', array(\n                    'conditions' => array(\n                        'Server.id' => $passAlong\n                    ),\n                    'recursive' => -1,\n                    'fields' => array(\n                        'Server.name',\n                        'Server.id',\n                        'Server.unpublish_event',\n                        'Server.publish_without_email'\n                    )\n                ));\n                if ($server['Server']['publish_without_email'] == 0) {\n                    $st = \"enabled\";\n                } else {\n                    $st = \"disabled\";\n                }\n                $this->Log->create();\n                $this->Log->save(array(\n                        'org' => $user['Organisation']['name'],\n                        'model' => 'Event',\n                        'model_id' => $saveResult['Event']['id'],\n                        'email' => $user['email'],\n                        'action' => 'add',\n                        'user_id' => $user['id'],\n                        'title' => 'Event pulled from Server(' . $server['Server']['id'] . ') - \"' . $server['Server']['name'] . '\" - Notification by mail ' . $st,\n                        'change' => ''\n                ));\n            }\n            if (isset($data['Event']['EventTag'])) {\n                foreach ($data['Event']['EventTag'] as $et) {\n                    $this->EventTag->create();\n                    $et['event_id'] = $this->id;\n                    $this->EventTag->save($et);\n                }\n            }\n            $parentEvent = $this->find('first', array(\n                'conditions' => array('Event.id' => $this->id),\n                'recursive' => -1\n            ));\n            if (isset($data['Event']['Attribute']) && !empty($data['Event']['Attribute'])) {\n                foreach ($data['Event']['Attribute'] as $k => $attribute) {\n                    $block = false;\n                    for ($i = 0; $i < $k; $i++) {\n                        if (empty($data['Event']['Attribute'][$i])) {\n                            continue;\n                        }\n                        if (\n                            $data['Event']['Attribute'][$i]['value'] == $attribute['value'] &&\n                            $data['Event']['Attribute'][$i]['type'] == $attribute['type'] &&\n                            $data['Event']['Attribute'][$i]['category'] == $attribute['category']\n                        ) {\n                            $block = true;\n                            unset($data['Event']['Attribute'][$i]);\n                            break;\n                        }\n                    }\n                    if (!$block) {\n                        $data['Event']['Attribute'][$k] = $this->Attribute->captureAttribute($attribute, $this->id, $user, 0, $this->Log, $parentEvent);\n                    }\n                }\n                $data['Event']['Attribute'] = array_values($data['Event']['Attribute']);\n            }\n            $referencesToCapture = array();\n            if (!empty($data['Event']['Object'])) {\n                foreach ($data['Event']['Object'] as $object) {\n                    $result = $this->Object->captureObject($object, $this->id, $user, $this->Log);\n                }\n                foreach ($data['Event']['Object'] as $object) {\n                    if (isset($object['ObjectReference'])) {\n                        foreach ($object['ObjectReference'] as $objectRef) {\n                            $objectRef['source_uuid'] = $object['uuid'];\n                            $referencesToCapture[] = $objectRef;\n                        }\n                    }\n                }\n            }\n            foreach ($referencesToCapture as $referenceToCapture) {\n                $result = $this->Object->ObjectReference->captureReference(\n                    $referenceToCapture,\n                    $this->id,\n                    $user,\n                    $this->Log\n                );\n            }\n            // zeroq: check if sightings are attached and add to event\n            if (isset($data['Sighting']) && !empty($data['Sighting'])) {\n                $this->Sighting = ClassRegistry::init('Sighting');\n                foreach ($data['Sighting'] as $s) {\n                    $result = $this->Sighting->saveSightings($s['attribute_uuid'], false, $s['date_sighting'], $user, $s['type'], $s['source'], $s['uuid']);\n                }\n            }\n            if ($fromXml) {\n                $created_id = $this->id;\n            }\n            if (!empty($data['Event']['published']) && 1 == $data['Event']['published']) {\n                // do the necessary actions to publish the event (email, upload,...)\n                if (('true' != Configure::read('MISP.disablerestalert')) && (empty($server) || $server['Server']['publish_without_email'] == 0)) {\n                    $this->sendAlertEmailRouter($this->getID(), $user);\n                }\n                $this->publish($this->getID(), $passAlong);\n            }\n            return true;\n        } else {\n            $validationErrors['Event'] = $this->validationErrors;\n            return json_encode($validationErrors);\n        }\n    }\n\n    public function _edit(&$data, $user, $id, $jobId = null, $passAlong = null)\n    {\n        $data = $this->cleanupEventArrayFromXML($data);\n        unset($this->Attribute->validate['event_id']);\n        unset($this->Attribute->validate['value']['unique']); // otherwise gives bugs because event_id is not set\n\n        // reposition to get the event.id with given uuid\n        if (isset($data['Event']['uuid'])) {\n            $existingEvent = $this->findByUuid($data['Event']['uuid']);\n        } else {\n            $existingEvent = $this->findById($id);\n        }\n        // If the event exists...\n        $dateObj = new DateTime();\n        $date = $dateObj->getTimestamp();\n        if (count($existingEvent)) {\n            $data['Event']['id'] = $existingEvent['Event']['id'];\n            $id = $existingEvent['Event']['id'];\n            // Conditions affecting all:\n            // user.org == event.org\n            // edit timestamp newer than existing event timestamp\n            if (!isset($data['Event']['timestamp']) || $data['Event']['timestamp'] > $existingEvent['Event']['timestamp']) {\n                if (!isset($data['Event']['timestamp'])) {\n                    $data['Event']['timestamp'] = $date;\n                }\n                if (isset($data['Event']['distribution']) && $data['Event']['distribution'] == 4) {\n                    if (!isset($data['Event']['SharingGroup'])) {\n                        if (!isset($data['Event']['sharing_group_id'])) {\n                            return(array('error' => 'Event could not be saved: Sharing group chosen as the distribution level, but no sharing group specified. Make sure that the event includes a valid sharing_group_id or change to a different distribution level.'));\n                        }\n                        if (!$this->SharingGroup->checkIfAuthorised($user, $data['Event']['sharing_group_id'])) {\n                            return(array('error' => 'Event could not be saved: Invalid sharing group or you don\\'t have access to that sharing group.'));\n                        }\n                    } else {\n                        $data['Event']['sharing_group_id'] = $this->SharingGroup->captureSG($data['Event']['SharingGroup'], $user);\n                        unset($data['Event']['SharingGroup']);\n                        if ($data['Event']['sharing_group_id'] === false) {\n                            return (array('error' => 'Event could not be saved: User not authorised to create the associated sharing group.'));\n                        }\n                    }\n                }\n                // If the above is true, we have two more options:\n                // For users that are of the creating org of the event, always allow the edit\n                // For users that are sync users, only allow the edit if the event is locked\n                if ($existingEvent['Event']['orgc_id'] === $user['org_id']\n                || ($user['Role']['perm_sync'] && $existingEvent['Event']['locked']) || $user['Role']['perm_site_admin']) {\n                    if ($user['Role']['perm_sync']) {\n                        if (isset($data['Event']['distribution']) && $data['Event']['distribution'] == 4 && !$this->SharingGroup->checkIfAuthorised($user, $data['Event']['sharing_group_id'])) {\n                            return (array('error' => 'Event could not be saved: The sync user has to have access to the sharing group in order to be able to edit it.'));\n                        }\n                    }\n                } else {\n                    return (array('error' => 'Event could not be saved: The user used to edit the event is not authorised to do so. This can be caused by the user not being of the same organisation as the original creator of the event whilst also not being a site administrator.'));\n                }\n            } else {\n                return (array('error' => 'Event could not be saved: Event in the request not newer than the local copy.'));\n            }\n            // If a field is not set in the request, just reuse the old value\n            $recoverFields = array('analysis', 'threat_level_id', 'info', 'distribution', 'date');\n            foreach ($recoverFields as $rF) {\n                if (!isset($data['Event'][$rF])) {\n                    $data['Event'][$rF] = $existingEvent['Event'][$rF];\n                }\n            }\n        } else {\n            return (array('error' => 'Event could not be saved: Could not find the local event.'));\n        }\n        if (!empty($data['Event']['published']) && !$user['Role']['perm_publish']) {\n            $data['Event']['published'] = 0;\n        }\n        if (!isset($data['Event']['published'])) {\n            $data['Event']['published'] = 0;\n        }\n        $fieldList = array(\n            'date',\n            'threat_level_id',\n            'analysis',\n            'info',\n            'published',\n            'uuid',\n            'distribution',\n            'timestamp',\n            'sharing_group_id',\n            'disable_correlation',\n            'extends_uuid'\n        );\n        $saveResult = $this->save(array('Event' => $data['Event']), array('fieldList' => $fieldList));\n        $this->Log = ClassRegistry::init('Log');\n        if ($saveResult) {\n            $validationErrors = array();\n            if (isset($data['Event']['Attribute'])) {\n                $data['Event']['Attribute'] = array_values($data['Event']['Attribute']);\n                foreach ($data['Event']['Attribute'] as $k => $attribute) {\n                    $result = $this->Attribute->editAttribute($attribute, $this->id, $user, 0, $this->Log);\n                    if ($result !== true) {\n                        $validationErrors['Attribute'][] = $result;\n                    }\n                }\n            }\n            if (isset($data['Event']['Object'])) {\n                $data['Event']['Object'] = array_values($data['Event']['Object']);\n                foreach ($data['Event']['Object'] as $k => $object) {\n                    $result = $this->Object->editObject($object, $this->id, $user, $this->Log);\n                    if ($result !== true) {\n                        $validationErrors['Object'][] = $result;\n                    }\n                }\n                foreach ($data['Event']['Object'] as $object) {\n                    if (isset($object['ObjectReference'])) {\n                        foreach ($object['ObjectReference'] as $objectRef) {\n                            $result = $this->Object->ObjectReference->captureReference($objectRef, $this->id, $user, $this->Log);\n                        }\n                    }\n                }\n            }\n            if (isset($data['Event']['EventTag'])) {\n                $data['Event']['Tag'] = $data['Event']['EventTag']['Tag'];\n                unset($data['Event']['EventTag']);\n            }\n            if (isset($data['Event']['Tag']) && $user['Role']['perm_tagger']) {\n                foreach ($data['Event']['Tag'] as $tag) {\n                    $tag_id = $this->EventTag->Tag->captureTag($tag, $user);\n                    if ($tag_id) {\n                        $this->EventTag->attachTagToEvent($this->id, $tag_id);\n                    } else {\n                        // If we couldn't attach the tag it is most likely because we couldn't create it - which could have many reasons\n                        // However, if a tag couldn't be added, it could also be that the user is a tagger but not a tag editor\n                        // In which case if no matching tag is found, no tag ID is returned. Logging these is pointless as it is the correct behaviour.\n                        if ($user['Role']['perm_tag_editor']) {\n                            $this->Log->create();\n                            $this->Log->save(array(\n                                'org' => $user['Organisation']['name'],\n                                'model' => 'Event',\n                                'model_id' => $this->id,\n                                'email' => $user['email'],\n                                'action' => 'edit',\n                                'user_id' => $user['id'],\n                                'title' => 'Failed create or attach Tag ' . $tag['name'] . ' to the event.',\n                                'change' => ''\n                            ));\n                        }\n                    }\n                }\n            }\n            // zeroq: if sightings then attach to event\n            if (isset($data['Sighting']) && !empty($data['Sighting'])) {\n                $this->Sighting = ClassRegistry::init('Sighting');\n                foreach ($data['Sighting'] as $s) {\n                    $result = $this->Sighting->saveSightings($s['attribute_uuid'], false, $s['date_sighting'], $user, $s['type'], $s['source'], $s['uuid']);\n                }\n            }\n            // if published -> do the actual publishing\n            if ((!empty($data['Event']['published']) && 1 == $data['Event']['published'])) {\n\t\t\t    // The edited event is from a remote server ?\n\t\t\t\tif ($passAlong) {\n\t\t\t\t\t$this->Server = ClassRegistry::init('Server');\n\t\t\t\t\t$server = $this->Server->find('first', array(\n\t\t\t\t\t    'conditions' => array(\n\t\t\t\t\t\t    'Server.id' => $passAlong\n\t\t\t\t\t\t),\n\t\t\t\t\t\t'recursive' => -1,\n\t\t\t\t\t\t'fields' => array(\n\t\t\t\t\t\t    'Server.name',\n\t\t\t\t\t\t\t'Server.id',\n\t\t\t\t\t\t\t'Server.unpublish_event',\n\t\t\t\t\t\t\t'Server.publish_without_email'\n\t\t\t\t\t\t)\n\t\t\t\t\t));\n\t\t\t\t\tif ($server['Server']['publish_without_email'] == 0) {\n\t\t\t\t\t    $st = \"enabled\";\n\t\t\t\t\t} else {\n\t\t\t\t\t    $st = \"disabled\";\n\t\t\t\t\t}\n\t\t\t\t\t$this->Log->create();\n\t\t\t\t\t$this->Log->save(array(\n\t\t\t\t\t    'org' => $user['Organisation']['name'],\n\t\t\t\t\t\t'model' => 'Event',\n\t\t\t\t\t\t'model_id' => $saveResult['Event']['id'],\n\t\t\t\t\t\t'email' => $user['email'],\n\t\t\t\t\t\t'action' => 'add',\n\t\t\t\t\t\t'user_id' => $user['id'],\n\t\t\t\t\t\t'title' => 'Event edited from Server(' . $server['Server']['id'] . ') - \"' . $server['Server']['name'] . '\" - Notification by mail ' . $st,\n\t\t\t\t\t\t'change' => ''\n                    ));\n\t\t\t\t} else {\n\t\t\t\t    $this->Log->create();\n\t\t\t\t\t$this->Log->save(array(\n\t\t\t\t\t\t'org' => $user['Organisation']['name'],\n\t\t\t\t\t\t'model' => 'Event',\n\t\t\t\t\t    'model_id' => $saveResult['Event']['id'],\n\t\t\t\t\t\t'email' => $user['email'],\n\t\t\t\t\t\t'action' => 'add',\n\t\t\t\t\t\t'user_id' => $user['id'],\n\t\t\t\t\t\t'title' => 'Event edited (locally)',\n\t\t\t\t\t\t'change' => ''\n\t\t\t\t\t));\n                }\n                // do the necessary actions to publish the event (email, upload,...)\n                if ((true != Configure::read('MISP.disablerestalert')) && (empty($server) || $server['Server']['publish_without_email'] == 0)) {\n                    $this->sendAlertEmailRouter($id, $user, $existingEvent['Event']['publish_timestamp']);\n                }\n                $this->publish($existingEvent['Event']['id']);\n            }\n            return true;\n        }\n        return $this->validationErrors;\n    }\n\n    // format has to be:\n    // array('Event' => array(), 'Attribute' => array('ShadowAttribute' => array()), 'EventTag' => array(), 'ShadowAttribute' => array());\n    public function savePreparedEvent($event)\n    {\n        unset($event['Event']['id']);\n        $this->create();\n        $this->save($event['Event']);\n        $event['Event']['id'] = $this->id;\n        $objects = array('Attribute', 'ShadowAttribute', 'EventTag', 'Object');\n        foreach ($objects as $object_type) {\n            if (!empty($event[$object_type])) {\n                $saveMethod = '__savePrepared' . $object_type;\n                foreach ($event[$object_type] as $object) {\n                    $this->$saveMethod($object, $event);\n                }\n            }\n        }\n        if (!empty($event['Object'])) {\n            $objectRefTypes = array('Attribute', 'Object');\n            foreach ($event['Object'] as $k => $object) {\n                foreach ($object['ObjectReference'] as $k2 => $objectRef) {\n                    $savedObjectRef = $this->Object->ObjectReference->find('first', array(\n                        'recursive' => -1,\n                        'conditions' => array('ObjectReference.uuid' => $objectRef['uuid'])\n                    ));\n                    $objectRefType = intval($savedObjectRef['ObjectReference']['referenced_type']);\n                    $element = $this->{$objectRefTypes[$objectRefType]}->find('first', array(\n                        'conditions' => array($objectRefTypes[$objectRefType] . '.uuid' => $objectRef['referenced_uuid']),\n                        'recursive' => -1,\n                        'fields' => array($objectRefTypes[$objectRefType] . '.id')\n                    ));\n                    $savedObjectRef['ObjectReference']['referenced_id'] = $element[$objectRefTypes[$objectRefType]]['id'];\n                    $result = $this->Object->ObjectReference->save($savedObjectRef);\n                }\n            }\n        }\n        return $event['Event']['id'];\n    }\n\n    private function __savePreparedAttribute(&$attribute, $event, $object_id = 0)\n    {\n        unset($attribute['id']);\n        $attribute['event_id'] = $event['Event']['id'];\n        $attribute['object_id'] = $object_id;\n        $this->Attribute->create();\n        $this->Attribute->save($attribute);\n        foreach ($attribute['ShadowAttribute'] as $k => $sa) {\n            $this->__savePreparedShadowAttribute($sa, $event, $this->Attribute->id);\n        }\n        foreach ($attribute['AttributeTag'] as $k => $at) {\n            $this->__savePreparedAttributeTag($at, $event, $this->Attribute->id);\n        }\n        return true;\n    }\n\n    private function __savePreparedObject(&$object, $event)\n    {\n        unset($object['id']);\n        $object['event_id'] = $event['Event']['id'];\n        $this->Object->create();\n        $this->Object->save($object);\n        foreach ($object['Attribute'] as $k => $a) {\n            $this->__savePreparedAttribute($a, $event, $this->Object->id);\n        }\n        foreach ($object['ObjectReference'] as $objectRef) {\n            $this->__savePreparedObjectReference($objectRef, $event, $this->Object->id, $object['uuid']);\n        }\n        return true;\n    }\n\n    #referenced IDs have to be updated after everything else is done!\n    private function __savePreparedObjectReference($objectRef, $event, $object_id, $object_uuid)\n    {\n        unset($objectRef['id']);\n        $objectRef['event_id'] = $event['Event']['id'];\n        $objectRef['object_id'] = $object_id;\n        $objectRef['object_uuid'] = $object_uuid;\n        $this->Object->ObjectReference->create();\n        $this->Object->ObjectReference->save($objectRef);\n        return true;\n    }\n\n    private function __savePreparedShadowAttribute($shadow_attribute, $event, $old_id = 0)\n    {\n        unset($shadow_attribute['id']);\n        $shadow_attribute['event_id'] = $event['Event']['id'];\n        $shadow_attribute['old_id'] = $old_id;\n        $this->ShadowAttribute->create();\n        $this->ShadowAttribute->save($shadow_attribute);\n        return true;\n    }\n\n    private function __savePreparedEventTag($event_tag, $event)\n    {\n        unset($event_tag['id']);\n        $event_tag['event_id'] = $event['Event']['id'];\n        $this->EventTag->create();\n        $this->EventTag->save($event_tag);\n        return true;\n    }\n\n    private function __savePreparedAttributeTag($attribute_tag, $event, $attribute_id)\n    {\n        unset($attribute_tag['id']);\n        $attribute_tag['event_id'] = $event['Event']['id'];\n        $attribute_tag['attribute_id'] = $attribute_id;\n        $this->Attribute->AttributeTag->create();\n        $this->Attribute->AttributeTag->save($attribute_tag);\n        return true;\n    }\n\n    // pass an event or an attribute together with the server id.\n    // If the distribution of the object outright allows for it to be shared, return true\n    // If the distribution is org only / comm only, return false\n    // If the distribution is sharing group only, check if the sync user is in the sharing group or not, return true if yes, false if no\n    public function checkDistributionForPush($object, $server, $context = 'Event')\n    {\n        if (empty(Configure::read('MISP.host_org_id')) || !$server['Server']['internal'] || Configure::read('MISP.host_org_id') != $server['Server']['remote_org_id']) {\n            if ($object[$context]['distribution'] < 2) {\n                return false;\n            }\n        }\n        if ($object[$context]['distribution'] == 4) {\n            if ($context === 'Event') {\n                return $this->SharingGroup->checkIfServerInSG($object['SharingGroup'], $server);\n            } else {\n                return $this->SharingGroup->checkIfServerInSG($object[$context]['SharingGroup'], $server);\n            }\n        }\n        return true;\n    }\n\n    // Uploads this specific event to all remote servers\n    public function uploadEventToServersRouter($id, $passAlong = null)\n    {\n        $eventOrgcId = $this->find('first', array(\n            'conditions' => array('Event.id' => $id),\n            'recursive' => -1,\n            'fields' => array('Event.orgc_id')\n        ));\n        // we create a fake site admin user object to fetch the event with everything included\n        // This replaces the old method of manually just fetching everything, staying consistent\n        // with the fetchEvent() output\n        $elevatedUser = array(\n            'Role' => array(\n                'perm_site_admin' => 1,\n                'perm_sync' => 1\n            ),\n            'org_id' => $eventOrgcId['Event']['orgc_id']\n        );\n        $elevatedUser['Role']['perm_site_admin'] = 1;\n        $elevatedUser['Role']['perm_sync'] = 1;\n        $elevatedUser['Role']['perm_audit'] = 0;\n        $event = $this->fetchEvent($elevatedUser, array('eventid' => $id, 'metadata' => 1));\n        if (empty($event)) {\n            return true;\n        }\n        $event = $event[0];\n        $event['Event']['locked'] = 1;\n        // get a list of the servers\n        $this->Server = ClassRegistry::init('Server');\n        $conditions = array('push' => 1);\n        if ($passAlong) {\n            $conditions[] = array('Server.id !=' => $passAlong);\n        }\n        $servers = $this->Server->find('all', array('conditions' => $conditions));\n        // iterate over the servers and upload the event\n        if (empty($servers)) {\n            return true;\n        }\n        $uploaded = true;\n        $failedServers = array();\n        App::uses('SyncTool', 'Tools');\n        foreach ($servers as &$server) {\n            if ((!isset($server['Server']['internal']) || !$server['Server']['internal']) && $event['Event']['distribution'] < 2) {\n                continue;\n            }\n            $syncTool = new SyncTool();\n            $HttpSocket = $syncTool->setupHttpSocket($server);\n            // Skip servers where the event has come from.\n            if (($passAlong != $server)) {\n                $params = array();\n                if (!empty($server['Server']['push_rules'])) {\n                    $push_rules = json_decode($server['Server']['push_rules'], true);\n                    if (!empty($push_rules['tags']['NOT'])) {\n                        $params['blockedAttributeTags'] = $push_rules['tags']['NOT'];\n                    }\n                }\n                $params = array_merge($params, array(\n                    'eventid' => $id,\n                    'includeAttachments' => true,\n                    'includeAllTags' => true,\n                    'deleted' => true,\n                    'excludeGalaxy' => 1\n                ));\n                $event = $this->fetchEvent($elevatedUser, $params);\n                $event = $event[0];\n                $event['Event']['locked'] = 1;\n                $thisUploaded = $this->uploadEventToServer($event, $server, $HttpSocket);\n                if (!$thisUploaded) {\n                    $uploaded = !$uploaded ? $uploaded : $thisUploaded;\n                    $failedServers[] = $server['Server']['url'];\n                }\n                if (isset($this->data['ShadowAttribute'])) {\n                    $this->Server->syncProposals($HttpSocket, $server, null, $id, $this);\n                }\n            }\n        }\n        if (!$uploaded) {\n            if (empty($failedServers)) {\n                return true;\n            }\n            return $failedServers;\n        } else {\n            return true;\n        }\n    }\n\n    private function __getPrioWorkerIfPossible()\n    {\n        $this->ResqueStatus = new ResqueStatus\\ResqueStatus(Resque::redis());\n        $workers = $this->ResqueStatus->getWorkers();\n        $workerType = 'default';\n        foreach ($workers as $worker) {\n            if ($worker['queue'] === 'prio') {\n                $workerType = 'prio';\n            }\n        }\n        return $workerType;\n    }\n\n    public function publishRouter($id, $passAlong = null, $user)\n    {\n        if (Configure::read('MISP.background_jobs')) {\n            $job = ClassRegistry::init('Job');\n            $job->create();\n            $data = array(\n                    'worker' => $this->__getPrioWorkerIfPossible(),\n                    'job_type' => 'publish_event',\n                    'job_input' => 'Event ID: ' . $id,\n                    'status' => 0,\n                    'retries' => 0,\n                    'org_id' => $user['org_id'],\n                    'org' => $user['Organisation']['name'],\n                    'message' => 'Publishing.',\n            );\n            $job->save($data);\n            $jobId = $job->id;\n            $process_id = CakeResque::enqueue(\n                    'prio',\n                    'EventShell',\n                    array('publish', $id, $passAlong, $jobId, $user['id']),\n                    true\n            );\n            $job->saveField('process_id', $process_id);\n            return $process_id;\n        } else {\n            $result = $this->publish($id, $passAlong);\n            return $result;\n        }\n    }\n\n    // Performs all the actions required to publish an event\n    public function publish($id, $passAlong = null, $jobId = null)\n    {\n        $this->id = $id;\n        $this->recursive = 0;\n        $event = $this->read(null, $id);\n        if ($jobId) {\n            $this->Behaviors->unload('SysLogLogable.SysLogLogable');\n        } else {\n            // update the DB to set the published flag\n            // for background jobs, this should be done already\n            $fieldList = array('published', 'id', 'info', 'publish_timestamp');\n            $event['Event']['published'] = 1;\n            $event['Event']['publish_timestamp'] = time();\n            $event['Event']['skip_zmq'] = 1;\n            $this->save($event, array('fieldList' => $fieldList));\n        }\n        if (Configure::read('Plugin.ZeroMQ_enable')) {\n            $pubSubTool = $this->getPubSubTool();\n            $hostOrg = $this->Org->find('first', array('conditions' => array('name' => Configure::read('MISP.org')), 'fields' => array('id')));\n            if (!empty($hostOrg)) {\n                $user = array('org_id' => $hostOrg['Org']['id'], 'Role' => array('perm_sync' => 0, 'perm_audit' => 0, 'perm_site_admin' => 0), 'Organisation' => $hostOrg['Org']);\n                $params = array('eventid' => $id);\n                if (Configure::read('Plugin.ZeroMQ_include_attachments')) {\n                    $params['includeAttachments'] = 1;\n                }\n                $fullEvent = $this->fetchEvent($user, $params);\n                if (!empty($fullEvent)) {\n                    $pubSubTool->publishEvent($fullEvent[0], 'publish');\n                }\n            }\n        }\n        $uploaded = $this->uploadEventToServersRouter($id, $passAlong);\n        return $uploaded;\n    }\n\n\n    // Sends out an email to all people within the same org with the request to be contacted about a specific event.\n    public function sendContactEmailRouter($id, $message, $creator_only, $user, $isSiteAdmin, $JobId = false)\n    {\n        if (Configure::read('MISP.background_jobs')) {\n            $job = ClassRegistry::init('Job');\n            $job->create();\n            $data = array(\n                    'worker' => 'email',\n                    'job_type' => 'contact_alert',\n                    'job_input' => 'Owner ' . ($creator_only ? 'user' : 'org') . ' of event #' . $id,\n                    'status' => 0,\n                    'retries' => 0,\n                    'org_id' => $user['org_id'],\n                    'message' => 'Contacting.',\n            );\n            $job->save($data);\n            $jobId = $job->id;\n            $process_id = CakeResque::enqueue(\n                    'email',\n                    'EventShell',\n                    array('contactemail', $id, $message, $creator_only, $user['id'], $isSiteAdmin, $jobId),\n                    true\n            );\n            $job->saveField('process_id', $process_id);\n            return true;\n        } else {\n            $result = $this->sendContactEmail($id, $message, $creator_only, array('User' => $user), $isSiteAdmin);\n            return $result;\n        }\n    }\n\n    public function generateLocked()\n    {\n        $this->User = ClassRegistry::init('User');\n        $this->User->recursive = -1;\n        $localOrgs = array();\n        $conditions = array();\n        $orgs = $this->User->find('all', array('fields' => array('DISTINCT org_id')));\n        foreach ($orgs as $k => $org) {\n            $orgs[$k]['User']['count'] = $this->User->getOrgMemberCount($orgs[$k]['User']['org_id']);\n            if ($orgs[$k]['User']['count'] > 1) {\n                $localOrgs[] = $orgs[$k]['User']['org_id'];\n                $conditions['AND'][] = array('orgc !=' => $orgs[$k]['User']['org_id']);\n            } elseif ($orgs[$k]['User']['count'] == 1) {\n                // If we only have a single user for an org, check if that user is a sync user. If not, then it is a valid local org and the events created by him/her should be unlocked.\n                $this->User->recursive = 1;\n                $user = ($this->User->find('first', array(\n                        'fields' => array('id', 'role_id'),\n                        'conditions' => array('org_id' => $org['User']['org_id']),\n                        'contain' => array('Role' => array(\n                                'fields' => array('id', 'perm_sync'),\n                        ))\n                )));\n                if (!$user['Role']['perm_sync']) {\n                    $conditions['AND'][] = array('orgc !=' => $orgs[$k]['User']['org_id']);\n                }\n            }\n        }\n        // Don't lock stuff that's already locked\n        $conditions['AND'][] = array('locked !=' => true);\n        $this->recursive = -1;\n        $toBeUpdated = $this->find('count', array(\n                'conditions' => $conditions\n        ));\n        $this->updateAll(\n                array('Event.locked' => 1),\n                $conditions\n        );\n        return $toBeUpdated;\n    }\n\n    public function reportValidationIssuesEvents()\n    {\n        $this->Behaviors->detach('Regexp');\n        // get all events..\n        $events = $this->find('all', array('recursive' => -1));\n        // for all events..\n        $result = array();\n        $k = 0;\n        $i = 0;\n        foreach ($events as $k => $event) {\n            $this->set($event);\n            if (!$this->validates()) {\n                $errors = $this->validationErrors;\n                $result[$i]['id'] = $event['Event']['id'];\n                $result[$i]['error'] = $errors;\n                $result[$i]['details'] = $event;\n                $i++;\n            }\n        }\n        return array($result, $k);\n    }\n\n    public function generateThreatLevelFromRisk()\n    {\n        $risk = array('Undefined' => 4, 'Low' => 3, 'Medium' => 2, 'High' => 1);\n        $events = $this->find('all', array('recursive' => -1));\n        $k = 0;\n        foreach ($events as $k => $event) {\n            if ($event['Event']['threat_level_id'] == 0 && isset($event['Event']['risk'])) {\n                $event['Event']['threat_level_id'] = $risk[$event['Event']['risk']];\n                $this->save($event);\n            }\n        }\n        return $k;\n    }\n\n    // check two version strings. If version 1 is older than 2, return -1, if they are the same return 0, if version 2 is older return 1\n    public function compareVersions($version1, $version2)\n    {\n        $version1Array = explode('.', $version1);\n        $version2Array = explode('.', $version2);\n\n        if ($version1Array[0] != $version2Array[0]) {\n            if ($version1Array[0] > $version2Array[0]) {\n                return 1;\n            } else {\n                return -1;\n            }\n        }\n        if ($version1Array[1] != $version2Array[1]) {\n            if ($version1Array[1] > $version2Array[1]) {\n                return 1;\n            } else {\n                return -1;\n            }\n        }\n        if ($version1Array[2] != $version2Array[2]) {\n            if ($version1Array[2] > $version2Array[2]) {\n                return 1;\n            } else {\n                return -1;\n            }\n        }\n    }\n\n    // main dispatch method for updating an incoming xmlArray - pass xmlArray to all of the appropriate transformation methods to make all the changes necessary to save the imported event\n    public function updateXMLArray($xmlArray, $response = true)\n    {\n        if (isset($xmlArray['xml_version']) && $response) {\n            $xmlArray['response']['xml_version'] = $xmlArray['xml_version'];\n            unset($xmlArray['xml_version']);\n        }\n\n        if (!$response) {\n            $xmlArray = array('response' => $xmlArray);\n        }\n        // if a version is set, it must be at least 2.2.0 - check the version and save the result of the comparison\n        if (isset($xmlArray['response']['xml_version'])) {\n            $version = $this->compareVersions($xmlArray['response']['xml_version'], $this->mispVersion);\n        }\n        // if no version is set, set the version to older (-1) manually\n        else {\n            $version = -1;\n        }\n        // same version, proceed normally\n        if ($version != 0) {\n            // The xml is from an instance that is newer than the local instance, let the user know that the admin needs to upgrade before it could be imported\n            if ($version == 1) {\n                throw new Exception('This XML file is from a MISP instance that is newer than the current instance. Please contact your administrator about upgrading this instance.');\n            }\n\n            // if the xml contains an event or events from an older MISP instance, let's try to upgrade it!\n            // Let's manually set the version to something below 2.2.0 if there is no version set in the xml\n            if (!isset($xmlArray['response']['xml_version'])) {\n                $xmlArray['response']['xml_version'] = '2.1.0';\n            }\n\n            // Upgrade from versions below 2.2.0 will need to replace the risk field with threat level id\n            if ($this->compareVersions($xmlArray['response']['xml_version'], '2.2.0') < 0) {\n                if ($response) {\n                    $xmlArray['response'] = $this->__updateXMLArray220($xmlArray['response']);\n                } else {\n                    $xmlArray = $this->__updateXMLArray220($xmlArray);\n                }\n            }\n        }\n        unset($xmlArray['response']['xml_version']);\n        if ($response) {\n            return $xmlArray;\n        } else {\n            return $xmlArray['response'];\n        }\n    }\n\n    // replaces the old risk value with the new threat level id\n    private function __updateXMLArray220($xmlArray)\n    {\n        $risk = array('Undefined' => 4, 'Low' => 3, 'Medium' => 2, 'High' => 1);\n        if (isset($xmlArray['Event'][0])) {\n            foreach ($xmlArray['Event'] as &$event) {\n                if (!isset($event['threat_level_id'])) {\n                    $event['threat_level_id'] = $risk[$event['risk']];\n                }\n            }\n        } else {\n            if (!isset($xmlArray['Event']['threat_level_id']) && isset($xmlArray['Event']['risk'])) {\n                $xmlArray['Event']['threat_level_id'] = $risk[$xmlArray['Event']['risk']];\n            }\n        }\n        return $xmlArray;\n    }\n\n    public function checkIfNewer($incomingEvent)\n    {\n        $localEvent = $this->find('first', array('conditions' => array('uuid' => $incomingEvent['uuid']), 'recursive' => -1, 'fields' => array('Event.uuid', 'Event.timestamp')));\n        if (empty($localEvent) || $incomingEvent['timestamp'] > $localEvent['Event']['timestamp']) {\n            return true;\n        }\n        return false;\n    }\n\n    public function removeOlder(&$eventArray)\n    {\n        $uuidsToCheck = array();\n        foreach ($eventArray as $k => &$event) {\n            $uuidsToCheck[$event['uuid']] = $k;\n        }\n        $localEvents = $this->find('list', array('recursive' => -1, 'fields' => array('Event.uuid', 'Event.timestamp')));\n        foreach ($uuidsToCheck as $uuid => $eventArrayId) {\n            if (isset($localEvents[$uuid]) && $localEvents[$uuid] >= $eventArray[$eventArrayId]['timestamp']) {\n                unset($eventArray[$eventArrayId]);\n            }\n        }\n    }\n\n    public function stix2($id, $tags, $attachments, $user, $returnType = 'json', $from = false, $to = false, $last = false, $jobId = false, $returnFile = false)\n    {\n        $eventIDs = $this->Attribute->dissectArgs($id);\n        $tagIDs = $this->Attribute->dissectArgs($tags);\n        $idList = $this->getAccessibleEventIds($eventIDs[0], $eventIDs[1], $tagIDs[0], $tagIDs[1]);\n        if (!empty($idList)) {\n            $event_ids = $this->fetchEventIds($user, $from, $to, $last, true);\n            $event_ids = array_intersect($event_ids, $idList);\n        }\n        $randomFileName = $this->generateRandomFileName();\n        $scriptDir = APP . \"files/scripts/\";\n        $stix2_framing_cmd = $this->getPythonVersion() . ' ' . $scriptDir . 'misp_framing.py stix2 ' . escapeshellarg(CakeText::uuid()) . ' 2>' . APP . 'tmp/logs/exec-errors.log';\n        $stix2_framing = json_decode(shell_exec($stix2_framing_cmd), true);\n        if (empty($stix2_framing)) {\n            return array('success' => 0, 'message' => 'There was an issue generating the STIX 2.0 export.');\n        }\n        $separator = $stix2_framing['separator'];\n        $tmpDir = $scriptDir . \"tmp/\";\n        $stixFile = new File($tmpDir . $randomFileName . \".stix\");\n        $stixFile->write($stix2_framing['header']);\n        if ($jobId) {\n            $this->Job = ClassRegistry::init('Job');\n            $this->Job->id = $jobId;\n            if (!$this->Job->exists()) {\n                $jobId = false;\n            }\n        }\n        $i = 0;\n        $eventCount = count($event_ids);\n        if ($event_ids) {\n            foreach ($event_ids as $event_id) {\n                $tempFile = new File($tmpDir . $randomFileName, true, 0644);\n                $event = $this->fetchEvent($user, array('eventid' => $event_id, 'includeAttachments' => 1));\n                if (empty($event)) {\n                    continue;\n                }\n                $event[0]['Tag'] = array();\n                foreach ($event[0]['EventTag'] as $tag) {\n                    $event[0]['Tag'][] = $tag['Tag'];\n                }\n                App::uses('JSONConverterTool', 'Tools');\n                $converter = new JSONConverterTool();\n                $event = $converter->convert($event[0]);\n                $tempFile->write($event);\n                unset($event);\n                $scriptFile = $scriptDir . \"stix2/misp2stix2.py \";\n                $result = shell_exec($this->getPythonVersion() . ' ' . $scriptFile . $tempFile->path . ' 2>' . APP . 'tmp/logs/exec-errors.log');\n                $decoded = json_decode($result, true);\n                if (isset($decoded['success']) && $decoded['success'] == 1) {\n                    $file = new File($tmpDir . $randomFileName . '.out', true, 0644);\n                    $result = substr($file->read(), 1, -1);\n                    $file->delete();\n                    $stixFile->append($result . (($i + 1) != $eventCount ? $separator : ''));\n                } else {\n                    return false;\n                }\n                $i++;\n                if ($jobId) {\n                    $this->Job->saveField('message', 'Event ' . $i . '/' . $eventCount);\n                    if ($i % 10 == 0) {\n                        $this->Job->saveField('progress', $i * 80 / $eventCount);\n                    }\n                }\n                $tempFile->close();\n            }\n        }\n        $stixFile->append($stix2_framing['footer']);\n        if ($tempFile) {\n            $tempFile->delete();\n        }\n        if (!$returnFile) {\n            $data2return = $stixFile->read();\n            $stixFile->delete();\n        }\n        return array('success' => 1, 'data' => $returnFile ? $stixFile->path : $data2return);\n    }\n\n    public function stix($id, $tags, $attachments, $user, $returnType = 'xml', $from = false, $to = false, $last = false, $jobId = false, $returnFile = false)\n    {\n        $eventIDs = $this->Attribute->dissectArgs($id);\n        $tagIDs = $this->Attribute->dissectArgs($tags);\n        $idList = $this->getAccessibleEventIds($eventIDs[0], $eventIDs[1], $tagIDs[0], $tagIDs[1]);\n        if (!empty($idList)) {\n            $event_ids = $this->fetchEventIds($user, $from, $to, $last, true);\n            $event_ids = array_intersect($event_ids, $idList);\n        }\n        $randomFileName = $this->generateRandomFileName();\n        $tmpDir = APP . \"files\" . DS . \"scripts\";\n        $stix_framing_cmd = $this->getPythonVersion() . ' ' . $tmpDir . DS . 'misp_framing.py stix ' . escapeshellarg(Configure::read('MISP.baseurl')) . ' ' . escapeshellarg(Configure::read('MISP.org')) . ' ' . escapeshellarg($returnType) . ' 2>' . APP . 'tmp/logs/exec-errors.log';\n        $stix_framing = json_decode(shell_exec($stix_framing_cmd), true);\n        if (empty($stix_framing)) {\n            return array('success' => 0, 'message' => 'There was an issue generating the STIX export.');\n        }\n        $separator = $stix_framing['separator'];\n        $tmpDir = $tmpDir . DS . \"tmp\";\n        $stixFile = new File($tmpDir . DS . $randomFileName . \".stix\");\n        $stixFile->write($stix_framing['header']);\n        $result = array();\n        if ($jobId) {\n            $this->Job = ClassRegistry::init('Job');\n            $this->Job->id = $jobId;\n            if (!$this->Job->exists()) {\n                $jobId = false;\n            }\n        }\n        $i = 0;\n        $eventCount = count($event_ids);\n        if ($event_ids) {\n            foreach ($event_ids as $event_id) {\n                $tempFile = new File($tmpDir . DS . $randomFileName, true, 0644);\n                $event = $this->fetchEvent($user, array('eventid' => $event_id));\n                if (empty($event)) {\n                    continue;\n                }\n                if ($attachments == \"yes\" || $attachments == \"true\" || $attachments == 1) {\n                    foreach ($event[0]['Attribute'] as &$attribute) {\n                        if ($this->Attribute->typeIsAttachment($attribute['type'])) {\n                            $encodedFile = $this->Attribute->base64EncodeAttachment($attribute);\n                            $attribute['data'] = $encodedFile;\n                        }\n                    }\n                }\n                $event[0]['Tag'] = array();\n                foreach ($event[0]['EventTag'] as $tag) {\n                    $event[0]['Tag'][] = $tag['Tag'];\n                }\n                App::uses('JSONConverterTool', 'Tools');\n                $converter = new JSONConverterTool();\n                $event = $converter->convert($event[0]);\n                $tempFile->write($event);\n                unset($event);\n                $scriptFile = APP . \"files\" . DS . \"scripts\" . DS . \"misp2stix.py\";\n                $result = shell_exec($this->getPythonVersion() . ' ' . $scriptFile . ' ' . $randomFileName . ' ' . escapeshellarg($returnType) . ' ' . escapeshellarg(Configure::read('MISP.baseurl')) . ' ' . escapeshellarg(Configure::read('MISP.org')) . ' 2>' . APP . 'tmp/logs/exec-errors.log');\n                // The result of the script will be a returned JSON object with 2 variables: success (boolean) and message\n                // If success = 1 then the temporary output file was successfully written, otherwise an error message is passed along\n                $decoded = json_decode($result, true);\n                if (!isset($decoded['success']) || !$decoded['success']) {\n                    $tempFile->delete();\n                    $stixFile->delete();\n                    return array('success' => 0, 'message' => $decoded['message']);\n                }\n                $file = new File(APP . \"files\" . DS . \"scripts\" . DS . \"tmp\" . DS . $randomFileName . \".out\");\n                $stix_event = $file->read();\n                if (($i + 1) != $eventCount) {\n                    $stix_event .= $separator;\n                }\n                $stixFile->append($stix_event);\n                $file->close();\n                $file->delete();\n                $i++;\n                if ($jobId) {\n                    $this->Job->saveField('message', 'Event ' . $i . '/' . $eventCount);\n                    if ($i % 10 == 0) {\n                        $this->Job->saveField('progress', $i * 80 / $eventCount);\n                    }\n                }\n                $tempFile->close();\n            }\n        }\n        $stixFile->append($stix_framing['footer']);\n        if ($tempFile) {\n            $tempFile->delete();\n        }\n        if (!$returnFile) {\n            $data = $stixFile->read();\n            $stixFile->delete();\n        }\n        return array('success' => 1, 'data' => $returnFile ? $stixFile->path : $data);\n    }\n\n    public function getAccessibleEventIds($include, $exclude, $includedTags, $excludedTags)\n    {\n        $conditions = array();\n\n        // get all of the event IDs based on include / exclude\n        if (!empty($include)) {\n            $conditions['OR'] = array('id' => $include);\n        }\n        if (!empty($exclude)) {\n            $conditions['NOT'] = array('id' => $exclude);\n        }\n        $events = $this->find('all', array(\n            'recursive' => -1,\n            'fields' => array('id', 'org_id', 'orgc_id', 'distribution'),\n            'conditions' => $conditions\n        ));\n        $ids = array();\n        foreach ($events as $event) {\n            $ids[] = $event['Event']['id'];\n        }\n        // get all of the event IDs based on includedTags / excludedTags\n        if (!empty($includedTags) || !empty($excludedTags)) {\n            $eventIDsFromTags = $this->EventTag->getEventIDsFromTags($includedTags, $excludedTags);\n            // get the intersect of the two\n            $ids = array_intersect($ids, $eventIDsFromTags);\n        }\n        return $ids;\n    }\n\n    public function generateRandomFileName()\n    {\n        return (new RandomTool())->random_str(false, 12);\n    }\n\n\n    public function sharingGroupRequired($field)\n    {\n        if ($this->data[$this->alias]['distribution'] == 4) {\n            return (!empty($field));\n        }\n        return true;\n    }\n\n    // convenience method to check whether a user can see an event\n    public function checkIfAuthorised($user, $id)\n    {\n        if (!isset($user['id'])) {\n            throw new MethodNotAllowedException('Invalid user.');\n        }\n        $this->id = $id;\n        if (!$this->exists()) {\n            return false;\n        }\n        if ($user['Role']['perm_site_admin']) {\n            return true;\n        }\n        $event = $this->find('first', array(\n            'conditions' => array('id' => $id),\n            'recursive' => -1,\n            'fields' => array('id', 'sharing_group_id', 'distribution', 'org_id')\n        ));\n        if ($event['Event']['org_id'] == $user['org_id'] || ($event['Event']['distribution'] > 0 && $event['Event']['distribution'] < 4)) {\n            return true;\n        }\n        if ($event['Event']['distribution'] == 4 && $this->SharingGroup->checkIfAuthorised($user, $event['Event']['sharing_group_id'])) {\n            return true;\n        }\n        return false;\n    }\n\n    // expects a date string in the YYYY-MM-DD format\n    // returns the passed string or false if the format is invalid\n    // based on the fix provided by stevengoosensB\n    public function dateFieldCheck($date)\n    {\n        // regex check for from / to field by stevengoossensB\n        return (preg_match('/^[0-9]{4}-(0[1-9]|1[012])-(0[1-9]|1[0-9]|2[0-9]|3[01])$/', $date)) ? $date : false;\n    }\n\n    public function resolveTimeDelta($delta)\n    {\n        if (is_numeric($delta)) {\n            return $delta;\n        }\n        $multiplierArray = array('d' => 86400, 'h' => 3600, 'm' => 60, 's' => 1);\n        $multiplier = $multiplierArray['d'];\n        $lastChar = strtolower(substr($delta, -1));\n        if (!is_numeric($lastChar) && array_key_exists($lastChar, $multiplierArray)) {\n            $multiplier = $multiplierArray[$lastChar];\n            $delta = substr($delta, 0, -1);\n        } else {\n            // invalid filter, make sure we don't return anything\n            return time() + 1;\n        }\n        if (!is_numeric($delta)) {\n            // Same here. (returning false dumps the whole database)\n            return time() + 1;\n        }\n        return time() - ($delta * $multiplier);\n    }\n\n    private function __prepareAttributeForView(\n        $attribute,\n        $correlatedAttributes,\n        $correlatedShadowAttributes,\n        $filterType = false,\n        &$eventWarnings,\n        $warningLists\n    ) {\n        $attribute['objectType'] = 'attribute';\n        $include = true;\n        if ($filterType && !in_array($filterType, array('proposal', 'correlation', 'warning'))) {\n            if (!in_array($attribute['type'], $this->Attribute->typeGroupings[$filterType])) {\n                $include = false;\n            }\n        }\n        if ($filterType === 'proposal' && empty($attribute['ShadowAttribute'])) {\n            $include = false;\n        }\n        if ($filterType === 'correlation' && !in_array($attribute['id'], $correlatedAttributes)) {\n            $include = false;\n        }\n        if (!empty($attribute['ShadowAttribute'])) {\n            $temp = array();\n            foreach ($attribute['ShadowAttribute'] as $k => $proposal) {\n                $result = $this->__prepareProposalForView(\n                    $proposal,\n                    $correlatedShadowAttributes,\n                    $filterType,\n                    $eventWarnings,\n                    $warningLists\n                );\n                if ($result['include']) {\n                    $temp[] = $result['data'];\n                }\n            }\n            $attribute['ShadowAttribute'] = $temp;\n        }\n        $attribute = $this->__prepareGenericForView($attribute, $eventWarnings, $warningLists);\n        if ($filterType === 'warning') {\n            if (empty($attribute['warnings'])) {\n                $include = false;\n            }\n        }\n        return array('include' => $include, 'data' => $attribute);\n    }\n\n    private function __prepareProposalForView(\n        $proposal,\n        $correlatedShadowAttributes,\n        $filterType = false,\n        &$eventWarnings,\n        $warningLists\n    ) {\n        if ($proposal['proposal_to_delete']) {\n            $proposal['objectType'] = 'proposal_delete';\n        } else {\n            $proposal['objectType'] = 'proposal';\n        }\n\n        $include = true;\n        if ($filterType === 'correlation' && !in_array($proposal['id'], $correlatedShadowAttributes)) {\n            $include = false;\n        }\n        if ($filterType && !in_array($filterType, array('proposal', 'correlation', 'warning'))) {\n            if (!in_array($proposal['type'], $this->Attribute->typeGroupings[$filterType])) {\n                $include = false;\n            }\n        }\n        $proposal = $this->__prepareGenericForView($proposal, $eventWarnings, $warningLists);\n        if ($filterType === 'warning') {\n            if (empty($proposal['warnings'])) {\n                $include = false;\n            }\n        }\n        return array('include' => $include, 'data' => $proposal);\n    }\n\n    private function __prepareObjectForView(\n        $object,\n        $correlatedAttributes,\n        $correlatedShadowAttributes,\n        $filterType = false,\n        &$eventWarnings,\n        $warningLists\n    ) {\n        $object['category'] = $object['meta-category'];\n        $proposal['objectType'] = 'object';\n        // filters depend on child objects\n        $include = empty($filterType) || $filterType == 'object' || $object['meta-category'] === $filterType;\n        if ($filterType === 'correlation' || $filterType === 'proposal') {\n            $include = $this->__checkObjectByFilter($object, $filterType, $correlatedAttributes, $correlatedShadowAttributes);\n        }\n        if (!empty($object['Attribute'])) {\n            $temp = array();\n            foreach ($object['Attribute'] as $k => $proposal) {\n                $result = $this->__prepareAttributeForView(\n                    $proposal,\n                    $correlatedAttributes,\n                    $correlatedShadowAttributes,\n                    false,\n                    $eventWarnings,\n                    $warningLists\n                );\n                if ($result['include']) {\n                    $temp[] = $result['data'];\n                }\n            }\n            $object['Attribute'] = $temp;\n        }\n        if ($filterType === 'warning') {\n            $include = $this->__checkObjectByFilter($object, $filterType, $correlatedAttributes, $correlatedShadowAttributes);\n        }\n        return array('include' => $include, 'data' => $object);\n    }\n\n    private function __checkObjectByFilter($object, $filterType, $correlatedAttributes, $correlatedShadowAttributes)\n    {\n        $include = false;\n        switch ($filterType) {\n            case 'warning':\n                if (!empty($object['Attribute'])) {\n                    foreach ($object['Attribute'] as $k => $attribute) {\n                        if (!empty($attribute['warnings'])) {\n                            $include = true;\n                        }\n                        if (!empty($attribute['ShadowAttribute'])) {\n                            foreach ($attribute['ShadowAttribute'] as $shadowAttribute) {\n                                if (!empty($shadowAttribute['warnings'])) {\n                                    $include = true;\n                                }\n                            }\n                        }\n                    }\n                }\n                break;\n            case 'correlation':\n                if (!empty($object['Attribute'])) {\n                    foreach ($object['Attribute'] as $k => $attribute) {\n                        if (in_array($attribute['id'], $correlatedAttributes)) {\n                            $include = true;\n                        } else {\n                            if (!empty($attribute['ShadowAttribute'])) {\n                                foreach ($attribute['ShadowAttribute'] as $k => $shadowAttribute) {\n                                    if (in_array($shadowAttribute['id'], $correlatedShadowAttributes)) {\n                                        $include = true;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n                break;\n            case 'proposal':\n                if (!empty($object['Attribute'])) {\n                    foreach ($object['Attribute'] as $k => $attribute) {\n                        if (!empty($attribute['ShadowAttribute'])) {\n                            $include = true;\n                        }\n                    }\n                }\n                break;\n        }\n        return $include;\n    }\n\n    private function __prepareGenericForView(\n        $object,\n        &$eventWarnings,\n        $warningLists\n    ) {\n        if (!$this->__fTool) {\n            $this->__fTool = new FinancialTool();\n        }\n        if ($object['type'] == 'attachment' && preg_match('/.*\\.(jpg|png|jpeg|gif)$/i', $object['value'])) {\n            if (!empty($object['data'])) {\n                $object['image'] = $object['data'];\n            } else {\n                if ($object['objectType'] === 'proposal') {\n                    $object['image'] = $this->ShadowAttribute->base64EncodeAttachment($object);\n                } else {\n                    $object['image'] = $this->Attribute->base64EncodeAttachment($object);\n                }\n            }\n        }\n        if (isset($object['distribution']) && $object['distribution'] != 4) {\n            unset($object['SharingGroup']);\n        }\n        if ($object['objectType'] !== 'object') {\n            if ($object['category'] === 'Financial fraud') {\n                if (!$this->__fTool->validateRouter($object['type'], $object['value'])) {\n                    $object['validationIssue'] = true;\n                }\n            }\n        }\n        $object = $this->Warninglist->checkForWarning($object, $eventWarnings, $warningLists);\n        return $object;\n    }\n\n    public function rearrangeEventForView(&$event, $passedArgs = array(), $all = false)\n    {\n        $this->Warninglist = ClassRegistry::init('Warninglist');\n        $warningLists = $this->Warninglist->fetchForEventView();\n        foreach ($event['Event'] as $k => $v) {\n            if (is_array($v)) {\n                $event[$k] = $v;\n                unset($event['Event'][$k]);\n            }\n        }\n        $filterType = false;\n        if (isset($passedArgs['attributeFilter'])) {\n            if (in_array($passedArgs['attributeFilter'], array_keys($this->Attribute->typeGroupings)) || in_array($passedArgs['attributeFilter'], array('proposal', 'correlation', 'warning'))) {\n                $filterType = $passedArgs['attributeFilter'];\n            } else {\n                unset($passedArgs['attributeFilter']);\n            }\n        }\n        $eventArray = array();\n        $eventWarnings = array();\n        $correlatedAttributes = isset($event['RelatedAttribute']) ? array_keys($event['RelatedAttribute']) : array();\n        $correlatedShadowAttributes = isset($event['RelatedShadowAttribute']) ? array_keys($event['RelatedShadowAttribute']) : array();\n        $event['objects'] = array();\n        foreach ($event['Attribute'] as $attribute) {\n            $result = $this->__prepareAttributeForView(\n                $attribute,\n                $correlatedAttributes,\n                $correlatedShadowAttributes,\n                $filterType,\n                $eventWarnings,\n                $warningLists\n            );\n            if ($result['include']) {\n                $event['objects'][] = $result['data'];\n            }\n        }\n        unset($event['Attribute']);\n        if (!empty($event['ShadowAttribute'])) {\n            foreach ($event['ShadowAttribute'] as $proposal) {\n                $result = $this->__prepareProposalForView(\n                    $proposal,\n                    $correlatedShadowAttributes,\n                    $filterType,\n                    $eventWarnings,\n                    $warningLists\n                );\n                $event['objects'][] = $result['data'];\n            }\n        }\n        if (!empty($event['Object'])) {\n            foreach ($event['Object'] as $object) {\n                $object['objectType'] = 'object';\n                $result = $this->__prepareObjectForView(\n                    $object,\n                    $correlatedAttributes,\n                    $correlatedShadowAttributes,\n                    $filterType,\n                    $eventWarnings,\n                    $warningLists\n                );\n                if ($result['include']) {\n                    $event['objects'][] = $result['data'];\n                }\n            }\n        }\n        unset($event['Object']);\n        unset($event['ShadowAttribute']);\n        $referencedObjectFields = array('meta-category', 'name', 'uuid', 'id');\n        $objectReferenceCount = 0;\n        $referencedByArray = array();\n        foreach ($event['objects'] as $object) {\n            if (!in_array($object['objectType'], array('attribute', 'object'))) {\n                continue;\n            }\n            if (!empty($object['ObjectReference'])) {\n                foreach ($object['ObjectReference'] as $reference) {\n                    if (isset($reference['referenced_uuid'])) {\n                        $referencedByArray[$reference['referenced_uuid']][$object['objectType']][] = array(\n                            'meta-category' => $object['meta-category'],\n                            'name' => $object['name'],\n                            'uuid' => $object['uuid'],\n                            'id' => $object['id'],\n                            'object_type' => $object['objectType']\n                        );\n                    }\n                }\n            }\n        }\n        App::uses('CustomPaginationTool', 'Tools');\n        $customPagination = new CustomPaginationTool();\n        if ($all) {\n            $passedArgs['page'] = 0;\n        }\n        $params = $customPagination->applyRulesOnArray($event['objects'], $passedArgs, 'events', 'category');\n        foreach ($event['objects'] as $k => $object) {\n            if (isset($referencedByArray[$object['uuid']])) {\n                foreach ($referencedByArray[$object['uuid']] as $objectType => $references) {\n                    $event['objects'][$k]['referenced_by'][$objectType] = $references;\n                }\n            }\n        }\n        $params['total_elements'] = count($event['objects']);\n        $event['Event']['warnings'] = $eventWarnings;\n        return $params;\n    }\n\n    // pass along a json from the server filter rules\n    // returns a conditions set to be merged into pagination / event fetch / etc\n    public function filterRulesToConditions($rules)\n    {\n        $rules = json_decode($rules, true);\n        $operators = array('OR', 'NOT');\n        foreach ($operators as $op) {\n            if (!empty($rules['tags'][$op])) {\n                $event_ids = $this->EventTag->find('list', array(\n                    'recursive' => -1,\n                    'conditions' => array('EventTag.tag_id' => $rules['tags'][$op]),\n                    'fields' => array('EventTag.event_id')\n                ));\n                $rules['events'][$op] = $event_ids;\n            }\n        }\n        $conditions = array();\n        $fields = array('events' => 'Event.id', 'orgs' => 'Event.orgc_id');\n        foreach ($fields as $k => $field) {\n            $temp = array();\n            if (!empty($rules[$k]['OR'])) {\n                $temp['OR'][$field] = $rules[$k]['OR'];\n            }\n            if (!empty($rules[$k]['NOT'])) {\n                $temp['AND'][$field . ' !='] = $rules[$k]['NOT'];\n            }\n            $conditions['AND'][] = $temp;\n        }\n        return $conditions;\n    }\n\n    public function handleModuleResult($result, $event_id)\n    {\n        $resultArray = array();\n        $freetextResults = array();\n        App::uses('ComplexTypeTool', 'Tools');\n        $complexTypeTool = new ComplexTypeTool();\n        if (isset($result['results']) && !empty($result['results'])) {\n            foreach ($result['results'] as $k => &$r) {\n                if (!is_array($r['values'])) {\n                    $r['values'] = array($r['values']);\n                }\n                if (!isset($r['types']) && isset($r['type'])) {\n                    $r['types'] = array($r['type']);\n                }\n                if (!is_array($r['types'])) {\n                    $r['types'] = array($r['types']);\n                }\n                if (isset($r['categories']) && !is_array($r['categories'])) {\n                    $r['categories'] = array($r['categories']);\n                }\n                if (isset($r['tags']) && !is_array($r['tags'])) {\n                    $r['tags'] = array($r['tags']);\n                }\n                foreach ($r['values'] as &$value) {\n                    if (!is_array($r['values']) || !isset($r['values'][0])) {\n                        $r['values'] = array($r['values']);\n                    }\n                }\n                foreach ($r['values'] as $valueKey => &$value) {\n                    if (empty($value)) {\n                        unset($r['values'][$valueKey]);\n                        continue;\n                    }\n                    if (in_array('freetext', $r['types'])) {\n                        if (is_array($value)) {\n                            $value = json_encode($value);\n                        }\n                        $this->Warninglist = ClassRegistry::init('Warninglist');\n                        $complexTypeTool->setTLDs($this->Warninglist->fetchTLDLists());\n                        $freetextResults = array_merge($freetextResults, $complexTypeTool->checkComplexRouter($value, 'FreeText'));\n                        if (!empty($freetextResults)) {\n                            foreach ($freetextResults as &$ft) {\n                                $temp = array();\n                                foreach ($ft['types'] as $type) {\n                                    $temp[$type] = $type;\n                                }\n                                $ft['types'] = $temp;\n                                $ft['comment'] = isset($r['comment']) ? $r['comment'] : false;\n                            }\n                        }\n                        $r['types'] = array_diff($r['types'], array('freetext'));\n                        // if we just removed the only type in the result then more on to the next result\n                        if (empty($r['types'])) {\n                            continue 2;\n                        }\n                        $r['types'] = array_values($r['types']);\n                    }\n                }\n                foreach ($r['values'] as &$value) {\n                    $temp = array(\n                            'event_id' => $event_id,\n                            'types' => $r['types'],\n                            'default_type' => $r['types'][0],\n                            'comment' => isset($r['comment']) ? $r['comment'] : false,\n                            'to_ids' => isset($r['to_ids']) ? $r['to_ids'] : false,\n                            'value' => $value,\n                            'tags' => isset($r['tags']) ? $r['tags'] : false\n                    );\n                    if (isset($r['categories'])) {\n                        $temp['categories'] = $r['categories'];\n                        $temp['default_category'] = $r['categories'][0];\n                    }\n                    if (isset($r['data'])) {\n                        $temp['data'] = $r['data'];\n                    }\n                    if (isset($r['distribution'])) {\n                        $temp['distribution'] = $r['distribution'];\n                    }\n                    // if data_is_handled is set then MISP assumes that the sample is already zipped and encrypted\n                    // in this case it will not try to do this by itself - however it also won't create additional hashes\n                    if (isset($r['data_is_handled'])) {\n                        $temp['data_is_handled'] = $r['data_is_handled'];\n                    }\n                    $resultArray[] = $temp;\n                }\n            }\n            $resultArray = array_merge($resultArray, $freetextResults);\n        }\n        return $resultArray;\n    }\n\n    public function export($user = false, $module = false, $options = array())\n    {\n        if (empty($user)) {\n            return 'Invalid user.';\n        }\n        if (empty($module)) {\n            return 'Invalid module.';\n        }\n        $this->Module = ClassRegistry::init('Module');\n        $module = $this->Module->getEnabledModule($module, 'Export');\n        $events = $this->fetchEvent($user, $options);\n        if (empty($events)) {\n            return 'Invalid event.';\n        }\n        $standard_format = false;\n        $modulePayload = array('module' => $module['name']);\n        if (!empty($module['meta']['require_standard_format'])) {\n            $standard_format = true;\n        }\n        if (isset($module['meta']['config'])) {\n            foreach ($module['meta']['config'] as $conf) {\n                $modulePayload['config'][$conf] = Configure::read('Plugin.Export_' . $module['name'] . '_' . $conf);\n            }\n        }\n        if ($standard_format) {\n            App::uses('JSONConverterTool', 'Tools');\n            $converter = new JSONConverterTool();\n            foreach ($events as $k => $event) {\n                $events[$k] = $converter->convert($event, false, true);\n            }\n        }\n        $modulePayload['data'] = $events;\n        $result = $this->Module->queryModuleServer('/query', json_encode($modulePayload, true), false, 'Export');\n        return array(\n                'data' => $result['data'],\n                'extension' => $module['mispattributes']['outputFileExtension'],\n                'response' => $module['mispattributes']['responseType']\n        );\n    }\n\n    public function getSightingData($event)\n    {\n        $this->Sighting = ClassRegistry::init('Sighting');\n        if (!empty($event['Sighting'])) {\n            $attributeSightings = array();\n            $attributeOwnSightings = array();\n            $attributeSightingsPopover = array();\n            $sightingsData = array();\n            $sparklineData = array();\n            $startDates = array();\n            $range = (!empty(Configure::read('MISP.Sightings_range')) && is_numeric(Configure::read('MISP.Sightings_range'))) ? Configure::read('MISP.Sightings_range') : 365;\n            $range = strtotime(\"-\" . $range . \" days\", time());\n            foreach ($event['Sighting'] as $sighting) {\n                $type = $this->Sighting->type[$sighting['type']];\n                if (!isset($sightingsData[$sighting['attribute_id']][$type])) {\n                    $sightingsData[$sighting['attribute_id']][$type] = array('count' => 0);\n                }\n                $sightingsData[$sighting['attribute_id']][$type]['count']++;\n                $orgName = isset($sighting['Organisation']['name']) ? $sighting['Organisation']['name'] : 'Others';\n                if ($sighting['type'] == '0' && (!isset($startDates[$sighting['attribute_id']]) || $startDates[$sighting['attribute_id']] > $sighting['date_sighting'])) {\n                    if ($sighting['date_sighting'] >= $range) {\n                        $startDates[$sighting['attribute_id']] = $sighting['date_sighting'];\n                    }\n                }\n                if ($sighting['type'] == '0' && (!isset($startDates['event']) || $startDates['event'] > $sighting['date_sighting'])) {\n                    if ($sighting['date_sighting'] >= $range) {\n                        $startDates['event'] = $sighting['date_sighting'];\n                    }\n                }\n                if (!isset($sightingsData[$sighting['attribute_id']][$type]['orgs'][$orgName])) {\n                    $sightingsData[$sighting['attribute_id']][$type]['orgs'][$orgName] = array('count' => 1, 'date' => $sighting['date_sighting']);\n                } else {\n                    $sightingsData[$sighting['attribute_id']][$type]['orgs'][$orgName]['count']++;\n                    if ($sightingsData[$sighting['attribute_id']][$type]['orgs'][$orgName]['date'] < $sighting['date_sighting']) {\n                        $sightingsData[$sighting['attribute_id']][$type]['orgs'][$orgName]['date'] = $sighting['date_sighting'];\n                    }\n                }\n                if ($sighting['type'] !== '0') {\n                    continue;\n                }\n                $date = date(\"Y-m-d\", $sighting['date_sighting']);\n                if (!isset($sparklineData[$sighting['attribute_id']][$date])) {\n                    $sparklineData[$sighting['attribute_id']][$date] = 1;\n                } else {\n                    $sparklineData[$sighting['attribute_id']][$date]++;\n                }\n                if (!isset($sparklineData['event'][$date])) {\n                    $sparklineData['event'][$date] = 1;\n                } else {\n                    $sparklineData['event'][$date]++;\n                }\n            }\n            $csv = array();\n            foreach ($startDates as $k => $v) {\n                $startDates[$k] = date('Y-m-d', $v);\n            }\n            $range = (!empty(Configure::read('MISP.Sightings_range')) && is_numeric(Configure::read('MISP.Sightings_range'))) ? Configure::read('MISP.Sightings_range') : 365;\n            foreach ($sparklineData as $aid => $data) {\n                if (!isset($startDates[$aid])) {\n                    continue;\n                }\n                $startDate = $startDates[$aid];\n                if (strtotime($startDate) < strtotime('-' . $range . ' days', time())) {\n                    $startDate = date('Y-m-d');\n                }\n                $startDate = date('Y-m-d', strtotime(\"-3 days\", strtotime($startDate)));\n                $to = date('Y-m-d', time());\n                $sighting = $data;\n                for ($date = $startDate; strtotime($date) <= strtotime($to); $date = date('Y-m-d', strtotime(\"+1 day\", strtotime($date)))) {\n                    if (!isset($csv[$aid])) {\n                        $csv[$aid] = 'Date,Close\\n';\n                    }\n                    if (isset($sighting[$date])) {\n                        $csv[$aid] .= $date . ',' . $sighting[$date] . '\\n';\n                    } else {\n                        $csv[$aid] .= $date . ',0\\n';\n                    }\n                }\n            }\n            return array(\n                    'data' => $sightingsData,\n                    'csv' => $csv\n            );\n        }\n        return array('data' => array(), 'csv' => array());\n    }\n\n    public function setSimpleConditions($parameterKey, $parameterValue, $conditions, $restrictScopeToEvents = false)\n    {\n        if (is_array($parameterValue)) {\n            $elements = $parameterValue;\n        } else {\n            $elements = explode('&&', $parameterValue);\n        }\n        App::uses('CIDRTool', 'Tools');\n        $cidr = new CIDRTool();\n        $subcondition = array();\n        foreach ($elements as $v) {\n            if ($v === '') {\n                continue;\n            }\n            if (substr($v, 0, 1) === '!') {\n                // check for an IPv4 address and subnet in CIDR notation (e.g. 127.0.0.1/8)\n                if ($parameterKey === 'value' && $cidr->checkCIDR(substr($v, 1), 4)) {\n                    $cidrresults = $cidr->CIDR(substr($v, 1));\n                    foreach ($cidrresults as $result) {\n                        $subcondition['AND'][] = array('Attribute.value NOT LIKE' => $result);\n                    }\n                } else {\n                    if ($parameterKey === 'org') {\n                        $found_orgs = $this->Org->find('all', array(\n                            'recursive' => -1,\n                            'conditions' => array('name' => substr($v, 1)),\n                        ));\n                        foreach ($found_orgs as $o) {\n                            $subcondition['AND'][] = array('Event.orgc_id !=' => $o['Org']['id']);\n                        }\n                    } elseif ($parameterKey === 'eventid') {\n                        if ($restrictScopeToEvents) {\n                            $subcondition['AND'][] = array('Event.id !=' => substr($v, 1));\n                        } else {\n                            $subcondition['AND'][] = array('Attribute.event_id !=' => substr($v, 1));\n                        }\n                    } elseif ($parameterKey === 'uuid') {\n                        $subcondition['AND'][] = array('Event.uuid !=' => substr($v, 1));\n                        $subcondition['AND'][] = array('Attribute.uuid !=' => substr($v, 1));\n                    } else {\n                        $lookup = substr($v, 1);\n                        if (strlen($lookup) != strlen(trim($lookup, '%'))) {\n                            $subcondition['AND'][] = array('Attribute.' . $parameterKey . ' NOT LIKE' => $lookup);\n                        } else {\n                            $subcondition['AND'][] = array('NOT' => array('Attribute.' . $parameterKey => $lookup));\n                        }\n                    }\n                }\n            } else {\n                // check for an IPv4 address and subnet in CIDR notation (e.g. 127.0.0.1/8)\n                if ($parameterKey === 'value' && $cidr->checkCIDR($v, 4)) {\n                    $cidrresults = $cidr->CIDR($v);\n                    foreach ($cidrresults as $result) {\n                        if (!empty($result)) {\n                            $subcondition['OR'][] = array('Attribute.value LIKE' => $result);\n                        }\n                    }\n                } else {\n                    if ($parameterKey === 'org') {\n                        $found_orgs = $this->Org->find('all', array(\n                                'recursive' => -1,\n                                'conditions' => array('name' => $v),\n                        ));\n                        foreach ($found_orgs as $o) {\n                            $subcondition['OR'][] = array('Event.orgc_id' => $o['Org']['id']);\n                        }\n                    } elseif ($parameterKey === 'eventid') {\n                        if ($restrictScopeToEvents) {\n                            $subcondition['OR'][] = array('Event.id' => $v);\n                        } else {\n                            $subcondition['OR'][] = array('Attribute.event_id' => $v);\n                        }\n                    } elseif ($parameterKey === 'uuid') {\n                        $subcondition['OR'][] = array('Attribute.uuid' => $v);\n                        $subcondition['OR'][] = array('Event.uuid' => $v);\n                    } else {\n                        if (!empty($v)) {\n                            if (strlen($v) != strlen(trim($v, '%'))) {\n                                $subcondition['AND'][] = array('Attribute.' . $parameterKey . ' LIKE' => $v);\n                            } else {\n                                $subcondition['AND'][] = array('Attribute.' . $parameterKey => $v);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (!empty($subcondition)) {\n            array_push($conditions['AND'], $subcondition);\n        }\n        return $conditions;\n    }\n\n    public function prepareEventForView()\n    {\n        // workaround to get the event dates in to the attribute relations\n        $relatedDates = array();\n        if (!empty($event['RelatedEvent'])) {\n            foreach ($event['RelatedEvent'] as $relation) {\n                $relatedDates[$relation['Event']['id']] = $relation['Event']['date'];\n            }\n            if (!empty($event['RelatedAttribute'])) {\n                foreach ($event['RelatedAttribute'] as $key => $relatedAttribute) {\n                    foreach ($relatedAttribute as $key2 => $relation) {\n                        $event['RelatedAttribute'][$key][$key2]['date'] = $relatedDates[$relation['id']];\n                    }\n                }\n            }\n        }\n        $dataForView = array(\n            'Attribute' => array('attrDescriptions', 'typeDefinitions', 'categoryDefinitions', 'distributionDescriptions', 'distributionLevels', 'shortDist'),\n            'Event' => array('fieldDescriptions')\n        );\n        foreach ($dataForView as $m => $variables) {\n            if ($m === 'Event') {\n                $currentModel = $this;\n            } elseif ($m === 'Attribute') {\n                $currentModel = $this->Attribute;\n            }\n            foreach ($variables as $alias => $variable) {\n                $this->set($alias, $currentModel->{$variable});\n            }\n        }\n    }\n\n    public function cacheSgids($user, $useCache = false)\n    {\n        if ($useCache && isset($this->__assetCache['sgids'])) {\n            return $this->__assetCache['sgids'];\n        } else {\n            $sgids = $this->SharingGroup->fetchAllAuthorised($user);\n            if (empty($sgids)) {\n                $sgids = array(-1);\n            }\n            if ($useCache) {\n                $this->__assetCache['sgids'] = $sgids;\n            }\n            return $sgids;\n        }\n    }\n\n    private function __cacheSharingGroupData($user, $useCache = false)\n    {\n        if ($useCache && isset($this->__assetCache['sharingGroupData'])) {\n            return $this->__assetCache['sharingGroupData'];\n        } else {\n            $sharingGroupDataTemp = $this->SharingGroup->fetchAllAuthorised($user, 'simplified');\n            $sharingGroupData = array();\n            foreach ($sharingGroupDataTemp as $k => $v) {\n                if (isset($v['Organisation'])) {\n                    $v['SharingGroup']['Organisation'] = $v['Organisation'];\n                }\n                if (isset($v['SharingGroupOrg'])) {\n                    $v['SharingGroup']['SharingGroupOrg'] = $v['SharingGroupOrg'];\n                }\n                if (isset($v['SharingGroupServer'])) {\n                    $v['SharingGroup']['SharingGroupServer'] = $v['SharingGroupServer'];\n                    foreach ($v['SharingGroup']['SharingGroupServer'] as &$sgs) {\n                        if ($sgs['server_id'] == 0) {\n                            $sgs['Server'] = array('id' => '0', 'url' => Configure::read('MISP.baseurl'), 'name' => Configure::read('MISP.baseurl'));\n                        }\n                    }\n                }\n                $sharingGroupData[$v['SharingGroup']['id']] = array('SharingGroup' => $v['SharingGroup']);\n            }\n            if ($useCache) {\n                $this->__assetCache['sharingGroupData'] = $sharingGroupData;\n            }\n            return $sharingGroupData;\n        }\n    }\n\n    private function __cachedelegatedEventIDs($user, $useCache = false)\n    {\n        if ($useCache && isset($this->__assetCache['delegatedEventIDs'])) {\n            return $this->__assetCache['delegatedEventIDs'];\n        } else {\n            $this->EventDelegation = ClassRegistry::init('EventDelegation');\n            $delegatedEventIDs = $this->EventDelegation->find('list', array(\n                'conditions' => array('EventDelegation.org_id' => $user['org_id']),\n                'fields' => array('event_id')\n            ));\n            if ($useCache) {\n                $this->__assetCache['delegationEventIDs'] = $delegatedEventIDs;\n            }\n            return $delegatedEventIDs;\n        }\n    }\n\n    private function __generateCachedTagFilters($tagRules, $useCache = false)\n    {\n        if ($useCache && isset($this->__assetCache['tagFilters'])) {\n            return $this->__assetCache['tagFilters'];\n        } else {\n            $filters = array();\n            $tag = ClassRegistry::init('Tag');\n            $args = $this->Attribute->dissectArgs($tagRules);\n            $tagArray = $this->EventTag->Tag->fetchEventTagIds($args[0], $args[1]);\n            $temp = array();\n            foreach ($tagArray[0] as $accepted) {\n                $temp['OR'][] = array('Event.id' => $accepted);\n            }\n            $filters[] = $temp;\n            $temp = array();\n            foreach ($tagArray[1] as $rejected) {\n                $temp['AND'][] = array('Event.id !=' => $rejected);\n            }\n            $filters[] = $temp;\n            if ($useCache) {\n                $this->__assetCache['tagFilters'] = $filters;\n            }\n            return $filters;\n        }\n    }\n\n    private function __destroyCaches()\n    {\n        $this->__assetCache = array();\n    }\n\n    public function unpublishEvent($id, $proposalLock = false)\n    {\n        $event = $this->find('first', array(\n            'recursive' => -1,\n            'conditions' => array('Event.id' => $id)\n        ));\n        if (empty($event)) {\n            return false;\n        }\n        $event['Event']['published'] = 0;\n        $date = new DateTime();\n        $event['Event']['timestamp'] = $date->getTimestamp();\n        if ($proposalLock) {\n            $event['Event']['proposal_email_lock'] = 0;\n        }\n        $event['Event']['unpublishAction'] = true;\n        return $this->save($event);\n    }\n\n    public function upload_stix($user, $filename, $stix_version, $original_file)\n    {\n        App::uses('Folder', 'Utility');\n        App::uses('File', 'Utility');\n        if ($stix_version == '2') {\n            $scriptFile = APP . 'files/scripts/stix2/stix2misp.py';\n            $tempFilePath = APP . 'files/scripts/tmp/' . $filename;\n            $shell_command = $this->getPythonVersion() . ' ' . $scriptFile . ' ' . $tempFilePath;\n            $output_path = $tempFilePath . '.stix2';\n        } elseif ($stix_version == '1' || $stix_version == '1.1' || $stix_version == '1.2') {\n            $scriptFile = APP . 'files/scripts/stix2misp.py';\n            $tempFilePath = APP . 'files/scripts/tmp/' . $filename;\n            $shell_command = $this->getPythonVersion() . ' ' . $scriptFile . ' ' . $filename;\n            $output_path = $tempFilePath . '.json';\n        } else {\n            throw new MethodNotAllowedException('Invalid STIX version');\n        }\n        $shell_command .=  ' ' . escapeshellarg(Configure::read('MISP.default_event_distribution')) . ' ' . escapeshellarg(Configure::read('MISP.default_attribute_distribution')) . ' 2>' . APP . 'tmp/logs/exec-errors.log';\n        $result = shell_exec($shell_command);\n        unlink($tempFilePath);\n        if (trim($result) == '1') {\n            $data = file_get_contents($output_path);\n            $data = json_decode($data, true);\n            unlink($output_path);\n            $created_id = false;\n            $validationIssues = false;\n            $result = $this->_add($data, true, $user, '', null, false, null, $created_id, $validationIssues);\n            if ($result) {\n                $this->add_original_file($tempFilePath, $original_filename, $created_id, 'STIX 1.1');\n                return $created_id;\n            }\n            return $validationIssues;\n        } else {\n            if (trim($result) == '2') {\n                $response = __('Issues while loading the stix file. ');\n            } elseif (trim($result) == '3') {\n                $response = __('Issues with the maec library. ');\n            } else {\n                $response = __('Issues executing the ingestion script or invalid input. ');\n            }\n            if (!$user['Role']['perm_site_admin']) {\n                $response .= __('Please ask your administrator to ');\n            } else {\n                $response .= __('Please ');\n            }\n            $response .= ' ' . __('check whether the dependencies for STIX are met via the diagnostic tool.');\n            return $response;\n        }\n    }\n\n    public function enrichmentRouter($options)\n    {\n        if (Configure::read('MISP.background_jobs')) {\n            $job = ClassRegistry::init('Job');\n            $job->create();\n            $data = array(\n                    'worker' => $this->__getPrioWorkerIfPossible(),\n                    'job_type' => 'enrichment',\n                    'job_input' => 'Event ID: ' . $options['event_id'] . ' modules: ' . json_encode($options['modules']),\n                    'status' => 0,\n                    'retries' => 0,\n                    'org_id' => $options['user']['org_id'],\n                    'org' => $options['user']['Organisation']['name'],\n                    'message' => 'Enriching event.',\n            );\n            $job->save($data);\n            $jobId = $job->id;\n            $process_id = CakeResque::enqueue(\n                    'prio',\n                    'EventShell',\n                    array('enrichment', $options['user']['id'], $options['event_id'], json_encode($options['modules']), $jobId),\n                    true\n            );\n            $job->saveField('process_id', $process_id);\n            return true;\n        } else {\n            $result = $this->enrichment($options);\n            return __('#' . $result . ' attributes have been created during the enrichment process.');\n        }\n    }\n\n    public function enrichment($params)\n    {\n        $option_fields = array('user', 'event_id', 'modules');\n        foreach ($option_fields as $option_field) {\n            if (empty($params[$option_field])) {\n                throw new MethodNotAllowedException(__('%s not set', $params[$option_field]));\n            }\n        }\n        $event = $this->fetchEvent($params['user'], array('eventid' => $params['event_id'], 'includeAttachments' => 1, 'flatten' => 1));\n        $this->Module = ClassRegistry::init('Module');\n        $enabledModules = $this->Module->getEnabledModules($params['user']);\n        if (empty($enabledModules)) {\n            return true;\n        }\n        $options = array();\n        foreach ($enabledModules['modules'] as $k => $temp) {\n            if (isset($temp['meta']['config'])) {\n                $settings = array();\n                foreach ($temp['meta']['config'] as $conf) {\n                    $settings[$conf] = Configure::read('Plugin.Enrichment_' . $temp['name'] . '_' . $conf);\n                }\n                $enabledModules['modules'][$k]['config'] = $settings;\n            }\n        }\n        if (empty($event)) {\n            throw new MethodNotAllowedException('Invalid event.');\n        }\n        $attributes_added = 0;\n        foreach ($event[0]['Attribute'] as $attribute) {\n            foreach ($enabledModules['modules'] as $module) {\n                if (in_array($module['name'], $params['modules'])) {\n                    if (in_array($attribute['type'], $module['mispattributes']['input'])) {\n                        $data = array('module' => $module['name'], $attribute['type'] => $attribute['value'], 'event_id' => $attribute['event_id'], 'attribute_uuid' => $attribute['uuid']);\n                        if (!empty($module['config'])) {\n                            $data['config'] = $module['config'];\n                        }\n                        $data = json_encode($data);\n                        $result = $this->Module->queryModuleServer('/query', $data, false, 'Enrichment');\n                        if (!$result) {\n                            throw new MethodNotAllowedException($type . ' service not reachable.');\n                        }\n                        //if (isset($result['error'])) $this->Session->setFlash($result['error']);\n                        if (!is_array($result)) {\n                            throw new Exception($result);\n                        }\n                        $attributes = $this->handleModuleResult($result, $attribute['event_id']);\n                        foreach ($attributes as $a) {\n                            $this->Attribute->create();\n                            $a['distribution'] = $attribute['distribution'];\n                            $a['sharing_group_id'] = $attribute['sharing_group_id'];\n                            $comment = 'Attribute #' . $attribute['id'] . ' enriched by ' . $module['name'] . '.';\n                            if (!empty($a['comment'])) {\n                                $a['comment'] .= PHP_EOL . $comment;\n                            } else {\n                                $a['comment'] = $comment;\n                            }\n                            $a['type'] = empty($a['default_type']) ? $a['types'][0] : $a['default_type'];\n                            $result = $this->Attribute->save($a);\n                            if ($result) {\n                                $attributes_added++;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return $attributes_added;\n    }\n\n    public function massageTags($data, $dataType = 'Event', $excludeGalaxy = false)\n    {\n        $data['Galaxy'] = array();\n        if (empty($this->GalaxyCluster)) {\n            $this->GalaxyCluster = ClassRegistry::init('GalaxyCluster');\n        }\n        // unset empty event tags that got added because the tag wasn't exportable\n        if (!empty($data[$dataType . 'Tag'])) {\n            foreach ($data[$dataType . 'Tag'] as $k => &$dataTag) {\n                if (empty($dataTag['Tag'])) {\n                    unset($data[$dataType . 'Tag'][$k]);\n                    continue;\n                }\n                if (!isset($excludeGalaxy) || !$excludeGalaxy) {\n                    if (substr($dataTag['Tag']['name'], 0, strlen('misp-galaxy:')) === 'misp-galaxy:') {\n                        $cluster = $this->GalaxyCluster->getCluster($dataTag['Tag']['name']);\n                        if ($cluster) {\n                            $found = false;\n                            foreach ($data['Galaxy'] as $k => $galaxy) {\n                                if ($galaxy['id'] == $cluster['GalaxyCluster']['Galaxy']['id']) {\n                                    $found = true;\n                                    $temp = $cluster;\n                                    unset($temp['GalaxyCluster']['Galaxy']);\n                                    $data['Galaxy'][$k]['GalaxyCluster'][] = $temp['GalaxyCluster'];\n                                    continue;\n                                }\n                            }\n                            if (!$found) {\n                                $data['Galaxy'][] = $cluster['GalaxyCluster']['Galaxy'];\n                                $temp = $cluster;\n                                unset($temp['GalaxyCluster']['Galaxy']);\n                                $data['Galaxy'][count($data['Galaxy']) - 1]['GalaxyCluster'][] = $temp['GalaxyCluster'];\n                            }\n                        }\n                    }\n                }\n            }\n            $data[$dataType . 'Tag'] = array_values($data[$dataType . 'Tag']);\n        }\n        return $data;\n    }\n\n    public function insertLock($user, $id)\n    {\n        $eventLock = ClassRegistry::init('EventLock');\n        $eventLock->insertLock($user, $id);\n    }\n\n    private function __logUploadResult($server, $event, $newTextBody)\n    {\n        $this->Log = ClassRegistry::init('Log');\n        $this->Log->create();\n        $this->Log->save(array(\n                'org' => 'SYSTEM',\n                'model' => 'Server',\n                'model_id' => $server['Server']['id'],\n                'email' => 'SYSTEM',\n                'action' => 'warning',\n                'user_id' => 0,\n                'title' => 'Uploading Event (' . $event['Event']['id'] . ') to Server (' . $server['Server']['id'] . ')',\n                'change' => 'Returned message: ', $newTextBody,\n        ));\n        return false;\n    }\n\n    public function processFreeTextData($user, $attributes, $id, $default_comment = '', $force = false, $adhereToWarninglists = false, $jobId = false)\n    {\n        $event = $this->find('first', array(\n            'conditions' => array('id' => $id),\n            'recursive' => -1,\n            'fields' => array('orgc_id', 'id', 'distribution', 'published', 'uuid'),\n        ));\n        if (!$user['Role']['perm_site_admin'] && !empty($event) && $event['Event']['orgc_id'] != $user['org_id']) {\n            $objectType = 'ShadowAttribute';\n        } elseif ($user['Role']['perm_site_admin'] && isset($force) && $force) {\n            $objectType = 'ShadowAttribute';\n        } else {\n            $objectType = 'Attribute';\n        }\n\n        if ($adhereToWarninglists) {\n            $this->Warninglist = ClassRegistry::init('Warninglist');\n            $warninglists = $this->Warninglist->fetchForEventView();\n        }\n        $saved = 0;\n        $failed = 0;\n        $attributeSources = array('attributes', 'ontheflyattributes');\n        $ontheflyattributes = array();\n        $i = 0;\n        $total = count($attributeSources);\n        if ($jobId) {\n            $this->Job = ClassRegistry::init('Job');\n            $this->Job->id = $jobId;\n        }\n        foreach ($attributeSources as $sourceKey => $source) {\n            foreach (${$source} as $k => $attribute) {\n                if ($attribute['type'] == 'ip-src/ip-dst') {\n                    $types = array('ip-src', 'ip-dst');\n                } elseif ($attribute['type'] == 'ip-src|port/ip-dst|port') {\n                    $types = array('ip-src|port', 'ip-dst|port');\n                } elseif ($attribute['type'] == 'malware-sample') {\n                    if (!isset($attribute['data_is_handled']) || !$attribute['data_is_handled']) {\n                        $result = $this->Attribute->handleMaliciousBase64($id, $attribute['value'], $attribute['data'], array('md5', 'sha1', 'sha256'), $objectType == 'ShadowAttribute' ? true : false);\n                        if (!$result['success']) {\n                            $failed++;\n                            continue;\n                        }\n                        $attribute['data'] = $result['data'];\n                        $shortValue = $attribute['value'];\n                        $attribute['value'] = $shortValue . '|' . $result['md5'];\n                        $additionalHashes = array('sha1', 'sha256');\n                        foreach ($additionalHashes as $hash) {\n                            $temp = $attribute;\n                            $temp['type'] = 'filename|' . $hash;\n                            $temp['value'] = $shortValue . '|' . $result[$hash];\n                            unset($temp['data']);\n                            $ontheflyattributes[] = $temp;\n                        }\n                    }\n                    $types = array($attribute['type']);\n                } else {\n                    $types = array($attribute['type']);\n                }\n                foreach ($types as $type) {\n                    $this->$objectType->create();\n                    $attribute['type'] = $type;\n                    if (empty($attribute['comment'])) {\n                        $attribute['comment'] = $default_comment;\n                    }\n                    $attribute['event_id'] = $id;\n                    if ($objectType == 'ShadowAttribute') {\n                        $attribute['org_id'] = $user['Role']['org_id'];\n                        $attribute['event_org_id'] = $event['Event']['orgc_id'];\n                        $attribute['email'] = $user['Role']['email'];\n                        $attribute['event_uuid'] = $event['Event']['uuid'];\n                    }\n                    // adhere to the warninglist\n                    if ($adhereToWarninglists) {\n                        if (!$this->Warninglist->filterWarninglistAttributes($warninglists, $attribute)) {\n                            if ($adhereToWarninglists == 'soft') {\n                                $attribute['to_ids'] = 0;\n                            } else {\n                                // just ignore the attribute\n                                continue;\n                            }\n                        }\n                    }\n                    $AttributSave = $this->$objectType->save($attribute);\n                    if ($AttributSave) {\n                        // If Tags, attach each tags to attribute\n                        if (!empty($attribute['tags'])) {\n                            foreach (explode(\",\", $attribute['tags']) as $tagName) {\n                                $this->Tag = ClassRegistry::init('Tag');\n                                $TagId = $this->Tag->captureTag(array('name' => $tagName), array('Role' => $user['Role']));\n                                $this->AttributeTag = ClassRegistry::init('AttributeTag');\n                                if (!$this->AttributeTag->attachTagToAttribute($AttributSave['Attribute']['id'], $id, $TagId)) {\n                                    throw new MethodNotAllowedException(__('Could not add tags.'));\n                                }\n                            }\n                        }\n                        $saved++;\n                    } else {\n                        $lastError = $this->$objectType->validationErrors;\n                        $failed++;\n                    }\n                }\n                if ($jobId) {\n                    if ($i % 20 == 0) {\n                        $this->Job->saveField('message', 'Attribute ' . $i . '/' . $total);\n                        $this->Job->saveField('progress', $i * 80 / $total);\n                    }\n                }\n            }\n        }\n        $emailResult = '';\n        $messageScope = $objectType == 'ShadowAttribute' ? 'proposals' : 'attributes';\n        if ($saved > 0) {\n            if ($objectType != 'ShadowAttribute') {\n                $event = $this->find('first', array(\n                        'conditions' => array('Event.id' => $id),\n                        'recursive' => -1\n                ));\n                if ($event['Event']['published'] == 1) {\n                    $event['Event']['published'] = 0;\n                }\n                $date = new DateTime();\n                $event['Event']['timestamp'] = $date->getTimestamp();\n                $this->save($event);\n            } else {\n                if (!$this->ShadowAttribute->sendProposalAlertEmail($id)) {\n                    $emailResult = \" but sending out the alert e-mails has failed for at least one recipient\";\n                }\n            }\n        }\n        if ($failed > 0) {\n            if ($failed == 1) {\n                $message = $saved . ' ' . $messageScope . ' created' . $emailResult . '. ' . $failed . ' ' . $messageScope . ' could not be saved. Reason for the failure: ' . json_encode($lastError);\n            } else {\n                $message = $saved . ' ' . $messageScope . ' created' . $emailResult . '. ' . $failed . ' ' . $messageScope . ' could not be saved. This may be due to attributes with similar values already existing.';\n            }\n        } else {\n            $message = $saved . ' ' . $messageScope . ' created' . $emailResult . '.';\n        }\n        if ($jobId) {\n            if ($i % 20 == 0) {\n                $this->Job->saveField('message', 'Processing complete. ' . $message);\n                $this->Job->saveField('progress', 100);\n            }\n        }\n        return $message;\n    }\n\n    public function processFreeTextDataRouter($user, $attributes, $id, $default_comment = '', $force = false, $adhereToWarninglists = false)\n    {\n        if (Configure::read('MISP.background_jobs')) {\n            $job = ClassRegistry::init('Job');\n            $job->create();\n            $data = array(\n                    'worker' => 'default',\n                    'job_type' => 'process_freetext_data',\n                    'job_input' => 'Event: ' . $id,\n                    'status' => 0,\n                    'retries' => 0,\n                    'org_id' => $user['org_id'],\n                    'org' => $user['Organisation']['name'],\n                    'message' => 'Processing...',\n            );\n            $job->save($data);\n            $randomFileName = $this->generateRandomFileName() . '.json';\n            App::uses('Folder', 'Utility');\n            App::uses('File', 'Utility');\n            $tempdir = new Folder(APP . 'tmp/cache/ingest', true, 0755);\n            $tempFile = new File(APP . 'tmp/cache/ingest' . DS . $randomFileName, true, 0644);\n            $tempData = array(\n                    'user' => $user,\n                    'attributes' => $attributes,\n                    'id' => $id,\n                    'default_comment' => $default_comment,\n                    'force' => $force,\n                    'adhereToWarninglists' => $adhereToWarninglists,\n                    'jobId' => $job->id\n            );\n\n            $writeResult = $tempFile->write(json_encode($tempData));\n            if (!$writeResult) {\n                return ($this->processFreeTextData($user, $attributes, $id, $default_comment = '', $force = false, $adhereToWarninglists = false));\n            }\n            $tempFile->close();\n            $jobId = $job->id;\n            $process_id = CakeResque::enqueue(\n                    'prio',\n                    'EventShell',\n                    array('processfreetext', $randomFileName),\n                    true\n            );\n            $job->saveField('process_id', $process_id);\n            return 'Freetext ingestion queued for background processing. Attributes will be added to the event as they are being processed.';\n        } else {\n            return ($this->processFreeTextData($user, $attributes, $id, $default_comment = '', $force = false, $adhereToWarninglists = false));\n        }\n    }\n\n    private function __attachReferences($user, &$event, $sgids, $fields)\n    {\n        if (!empty($event['Object'])) {\n            foreach ($event['Object'] as $k => $object) {\n                if (!empty($object['ObjectReference'])) {\n                    foreach ($object['ObjectReference'] as $k2 => $reference) {\n                        $type = array('Attribute', 'Object')[$reference['referenced_type']];\n                        $temp = $this->{$type}->find('first', array(\n                            'recursive' => -1,\n                            'fields' => array_merge($fields['common'], $fields[array('Attribute', 'Object')[$reference['referenced_type']]]),\n                            'conditions' => array('id' => $reference['referenced_id'])\n                        ));\n                        if (!empty($temp)) {\n                            if (!$user['Role']['perm_site_admin'] && $user['org_id'] != $event['Event']['orgc_id']) {\n                                if ($temp[$type]['distribution'] == 0 || ($temp[$type]['distribution'] == 4 && !in_array($temp[$type]['sharing_group_id'], $sgsids))) {\n                                    unset($object['ObjectReference'][$k2]);\n                                    continue;\n                                }\n                            }\n                            $event['Object'][$k]['ObjectReference'][$k2][$type] = $temp[$type];\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    public function restSearch($user, $returnFormat, $filters, $paramsOnly = false, $jobId = false, &$elementCounter = 0)\n    {\n        if (!isset($this->validFormats[$returnFormat][1])) {\n            throw new NotFoundException('Invalid output format.');\n        }\n        App::uses($this->validFormats[$returnFormat][1], 'Export');\n        $exportTool = new $this->validFormats[$returnFormat][1]();\n\n        if ($jobId) {\n            $this->Job = ClassRegistry::init('Job');\n            $this->Job->id = $jobId;\n        }\n\n        if (empty($exportTool->non_restrictive_export)) {\n            if (!isset($filters['to_ids'])) {\n                $filters['to_ids'] = 1;\n            }\n            if (!isset($filters['published'])) {\n                $filters['published'] = 1;\n            }\n        }\n        if (!empty($filters['ignore'])) {\n            $filters['to_ids'] = array(0, 1);\n            $filters['published'] = array(0, 1);\n        }\n        if (!empty($filters['quickFilter'])) {\n            $filters['searchall'] = $filters['quickFilter'];\n            if (!empty($filters['value'])) {\n                unset($filters['value']);\n            }\n        }\n        if (isset($filters['searchall'])) {\n            if (!empty($filters['value'])) {\n                $filters['wildcard'] = $filters['value'];\n            } else {\n                $filters['wildcard'] = $filters['searchall'];\n            }\n        }\n        $filters['include_attribute_count'] = 1;\n        $eventid = $this->filterEventIds($user, $filters);\n        $eventCount = count($eventid);\n        $eventids_chunked = $this->__clusterEventIds($exportTool, $eventid);\n        unset($eventid);\n        if (!empty($exportTool->additional_params)) {\n            $filters = array_merge($filters, $exportTool->additional_params);\n        }\n        $exportToolParams = array(\n            'user' => $user,\n            'params' => array(),\n            'returnFormat' => $returnFormat,\n            'scope' => 'Event',\n            'filters' => $filters\n        );\n        if (empty($exportTool->non_restrictive_export)) {\n            if (!isset($filters['to_ids'])) {\n                $filters['to_ids'] = 1;\n            }\n            if (!isset($filters['published'])) {\n                $filters['published'] = 1;\n            }\n        }\n        $tmpfile = tmpfile();\n        fwrite($tmpfile, $exportTool->header($exportToolParams));\n        $i = 0;\n        if (!empty($filters['withAttachments'])) {\n            $filters['includeAttachments'] = 1;\n        }\n        $this->Whitelist = ClassRegistry::init('Whitelist');\n        foreach ($eventids_chunked as $chunk_index => $chunk) {\n            $filters['eventid'] = $chunk;\n            if (!empty($filters['tags']['NOT'])) {\n                $filters['blockedAttributeTags'] = $filters['tags']['NOT'];\n            }\n            $result = $this->fetchEvent(\n                $user,\n                $filters,\n                true\n            );\n            if (!empty($result)) {\n                foreach ($result as $event) {\n                    $elementCounter++;\n                    if ($jobId && $i%10 == 0) {\n                        $this->Job->saveField('progress', intval((100 * $i) / $eventCount));\n                        $this->Job->saveField('message', 'Converting Event ' . $i . '/' . $eventCount . '.');\n                    }\n                    $result = $this->Whitelist->removeWhitelistedFromArray($result, false);\n                    $temp = $exportTool->handler($event, $exportToolParams);\n                    if ($temp !== '') {\n                        if ($i !== 0) {\n                            $temp = $exportTool->separator($exportToolParams) . $temp;\n                        }\n                        fwrite($tmpfile, $temp);\n                        $i++;\n                    }\n                }\n            }\n        }\n        unset($result);\n        unset($temp);\n        fwrite($tmpfile, $exportTool->footer($exportToolParams));\n        fseek($tmpfile, 0);\n        $final = fread($tmpfile, fstat($tmpfile)['size']);\n        fclose($tmpfile);\n        return $final;\n    }\n\n    /*\n     *  Receive a list of eventids in the id=>count format\n     *  Chunk them by the attribute count to fit the memory limits\n     *\n     */\n    private function __clusterEventIds($exportTool, $eventIds)\n    {\n        $memory_in_mb = $this->Attribute->convert_to_memory_limit_to_mb(ini_get('memory_limit'));\n        $memory_scaling_factor = isset($exportTool->memory_scaling_factor) ? $exportTool->memory_scaling_factor : 100;\n        $limit = $memory_in_mb * $memory_scaling_factor;\n        $eventIdList = array();\n        $continue = true;\n        $i = 0;\n        $current_chunk_size = 0;\n        while (!empty($eventIds)) {\n            foreach ($eventIds as $id => $count) {\n                if ($current_chunk_size == 0 && $count > $limit) {\n                    $eventIdList[$i][] = $id;\n                    $current_chunk_size = $count;\n                    unset($eventIds[$id]);\n                    $i++;\n                    break;\n                } else {\n                    if (($current_chunk_size + $count) > $limit) {\n                        $i++;\n                        $current_chunk_size = 0;\n                        break;\n                    } else {\n                        $current_chunk_size += $count;\n                        $eventIdList[$i][] = $id;\n                        unset($eventIds[$id]);\n                    }\n                }\n            }\n        }\n        return $eventIdList;\n    }\n\n    public function add_original_file($file_path, $original_filename, $event_id, $format)\n    {\n        if (!Configure::check('MISP.default_attribute_distribution') || Configure::read('MISP.default_attribute_distribution') === 'event') {\n            $distribution = 5;\n        } else {\n            $distribution = Configure::read('MISP.default_attribute_distribution');\n        }\n        $this->MispObject->create();\n        $object = array(\n            'name' => 'original-imported-file',\n            'meta-category' => 'file',\n            'description' => 'Object describing the original file used to import data in MISP.',\n            'template_uuid' => '4cd560e9-2cfe-40a1-9964-7b2e797ecac5',\n            'template_version' => '2',\n            'event_id' => $event_id,\n            'distribution' => $distribution\n        );\n        $this->MispObject->save($object);\n        $object_id = $this->MispObject->id;\n        $file = file_get_contents($file_path);\n        $attributes = array(\n            array(\n                'type' => 'attachment',\n                'category' => 'External analysis',\n                'to_ids' => false,\n                'event_id' => $event_id,\n                'distribution' => $distribution,\n                'object_relation' => 'imported-sample',\n                'value' => $original_filename,\n                'data' => base64_encode($file),\n                'object_id' => $object_id,\n            ),\n            array(\n                'type' => 'text',\n                'category' => 'Other',\n                'to_ids' => false,\n                'uuid' => '5c08f00d-2174-4ab7-ad0d-1b1a011fb688',\n                'event_id' => $event_id,\n                'distribution' => $distribution,\n                'object_id' => $object_id,\n                'object_relation' => 'format',\n                'value' => 'STIX 1.1'\n            )\n        );\n        foreach ($attributes as $attribute) {\n            $this->Attribute->create();\n            $this->Attribute->save($attribute);\n        }\n        return true;\n    }\n}\n", "# -*- coding: utf-8 -*-\n#    Copyright (C) 2017-2018 CIRCL Computer Incident Response Center Luxembourg (smile gie)\n#    Copyright (C) 2017-2018 Christian Studer\n#\n#    This program is free software: you can redistribute it and/or modify\n#    it under the terms of the GNU Affero General Public License as\n#    published by the Free Software Foundation, either version 3 of the\n#    License, or (at your option) any later version.\n#\n#    This program is distributed in the hope that it will be useful,\n#    but WITHOUT ANY WARRANTY; without even the implied warranty of\n#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#    GNU Affero General Public License for more details.\n#\n#    You should have received a copy of the GNU Affero General Public License\n#    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nimport sys\nimport json\nimport os\nimport time\nimport uuid\nimport base64\nimport stix2misp_mapping\nimport stix.extensions.marking.ais\nfrom operator import attrgetter\nfrom pymisp import MISPEvent, MISPObject, MISPAttribute, __path__\nfrom stix.core import STIXPackage\nfrom collections import defaultdict\n\ncybox_to_misp_object = {\"Account\": \"credential\", \"AutonomousSystem\": \"asn\",\n                        \"EmailMessage\": \"email\", \"NetworkConnection\": \"network-connection\",\n                        \"NetworkSocket\": \"network-socket\", \"Process\": \"process\",\n                        \"x509Certificate\": \"x509\", \"Whois\": \"whois\"}\n\nthreat_level_mapping = {'High': '1', 'Medium': '2', 'Low': '3', 'Undefined': '4'}\n\ndescFilename = os.path.join(__path__[0], 'data/describeTypes.json')\nwith open(descFilename, 'r') as f:\n    categories = json.loads(f.read())['result'].get('categories')\n\nclass StixParser():\n    def __init__(self):\n        super(StixParser, self).__init__()\n        self.misp_event = MISPEvent()\n        self.misp_event['Galaxy'] = []\n        self.references = defaultdict(list)\n\n    ################################################################################\n    ##            LOADING & UTILITY FUNCTIONS USED BY BOTH SUBCLASSES.            ##\n    ################################################################################\n\n    # Load data from STIX document, and other usefull data\n    def load_event(self, args, filename, from_misp, stix_version):\n        self.outputname = '{}.json'.format(filename)\n        try:\n            event_distribution = args[0]\n            if not isinstance(event_distribution, int):\n                event_distribution = int(event_distribution) if event_distribution.isdigit() else 5\n        except IndexError:\n            event_distribution = 5\n        try:\n            attribute_distribution = args[1]\n            if attribute_distribution == 'event':\n                attribute_distribution = event_distribution\n            elif not isinstance(attribute_distribution, int):\n                attribute_distribution = int(attribute_distribution) if attribute_distribution.isdigit() else event_distribution\n        except IndexError:\n            attribute_distribution = event_distribution\n        self.misp_event.distribution = event_distribution\n        self.__attribute_distribution = attribute_distribution\n        self.from_misp = from_misp\n        self.load_mapping()\n\n    # Convert the MISP event we create from the STIX document into json format\n    # and write it in the output file\n    def saveFile(self):\n        eventDict = self.misp_event.to_json()\n        with open(self.outputname, 'wt', encoding='utf-8') as f:\n            f.write(eventDict)\n\n    # Load the mapping dictionary for STIX object types\n    def load_mapping(self):\n        self.attribute_types_mapping = {\n            \"AccountObjectType\": self.handle_credential,\n            'AddressObjectType': self.handle_address,\n            \"ArtifactObjectType\": self.handle_attachment,\n            \"ASObjectType\": self.handle_as,\n            \"CustomObjectType\": self.handle_custom,\n            \"DNSRecordObjectType\": self.handle_dns,\n            'DomainNameObjectType': self.handle_domain_or_url,\n            'EmailMessageObjectType': self.handle_email_attribute,\n            'FileObjectType': self.handle_file,\n            'HostnameObjectType': self.handle_hostname,\n            'HTTPSessionObjectType': self.handle_http,\n            'MutexObjectType': self.handle_mutex,\n            'NetworkConnectionObjectType': self.handle_network_connection,\n            'NetworkSocketObjectType': self.handle_network_socket,\n            'PDFFileObjectType': self.handle_file,\n            'PortObjectType': self.handle_port,\n            'ProcessObjectType': self.handle_process,\n            'SocketAddressObjectType': self.handle_socket_address,\n            'SystemObjectType': self.handle_system,\n            'URIObjectType': self.handle_domain_or_url,\n            \"WhoisObjectType\": self.handle_whois,\n            \"WindowsFileObjectType\": self.handle_file,\n            'WindowsRegistryKeyObjectType': self.handle_regkey,\n            \"WindowsExecutableFileObjectType\": self.handle_pe,\n            \"WindowsServiceObjectType\": self.handle_windows_service,\n            \"X509CertificateObjectType\": self.handle_x509\n        }\n\n        self.marking_mapping = {\n            'AIS:AISMarkingStructure': self.parse_AIS_marking,\n            'tlpMarking:TLPMarkingStructureType': self.parse_TLP_marking\n        }\n\n    def parse_marking(self, handling):\n        tags = []\n        if hasattr(handling, 'marking_structures') and handling.marking_structures:\n            for marking in handling.marking_structures:\n                try:\n                    tags.extend(self.marking_mapping[marking._XSI_TYPE](marking))\n                except KeyError:\n                    print(marking._XSI_TYPE, file=sys.stderr)\n                    continue\n        return tags\n\n    def set_distribution(self):\n        for attribute in self.misp_event.attributes:\n            attribute.distribution = self.__attribute_distribution\n        for misp_object in self.misp_event.objects:\n            misp_object.distribution = self.__attribute_distribution\n            for attribute in misp_object.attributes:\n                attribute.distribution = self.__attribute_distribution\n\n    # Make references between objects\n    def build_references(self):\n        for misp_object in self.misp_event.objects:\n            object_uuid = misp_object.uuid\n            if object_uuid in self.references:\n                for reference in self.references[object_uuid]:\n                    misp_object.add_reference(reference['idref'], reference['relationship'])\n\n    # Set info & title values in the new MISP event\n    def get_event_info(self):\n        info = \"Imported from external STIX event\"\n        try:\n            try:\n                title = self.event.stix_header.title\n            except AttributeError:\n                title = self.event.title\n            if title:\n                info = title\n        except AttributeError:\n            pass\n        return info\n\n    # Get timestamp & date values in the new MISP event\n    def get_timestamp_and_date(self):\n        stix_date = self.event.timestamp\n        try:\n            date = stix_date.split(\"T\")[0]\n        except AttributeError:\n            date = stix_date\n        return date, self.getTimestampfromDate(stix_date)\n\n    # Translate date into timestamp\n    @staticmethod\n    def getTimestampfromDate(date):\n        try:\n            try:\n                dt = date.split('+')[0]\n                d = int(time.mktime(time.strptime(dt, \"%Y-%m-%d %H:%M:%S\")))\n            except ValueError:\n                dt = date.split('.')[0]\n                d = int(time.mktime(time.strptime(dt, \"%Y-%m-%d %H:%M:%S\")))\n        except AttributeError:\n            d = int(time.mktime(date.timetuple()))\n        return d\n\n    ################################################################################\n    ##           STIX OBJECTS PARSING FUNCTIONS USED BY BOTH SUBCLASSES           ##\n    ################################################################################\n\n    # Define type & value of an attribute or object in MISP\n    def handle_attribute_type(self, properties, is_object=False, title=None, observable_id=None):\n        xsi_type = properties._XSI_TYPE\n        # try:\n        args = [properties]\n        if xsi_type in (\"FileObjectType\", \"PDFFileObjectType\", \"WindowsFileObjectType\"):\n            args.append(is_object)\n        elif xsi_type == \"ArtifactObjectType\":\n            args.append(title)\n        return self.attribute_types_mapping[xsi_type](*args)\n        # except AttributeError:\n        #     # ATM USED TO TEST TYPES\n        #     print(\"Unparsed type: {}\".format(xsi_type))\n        #     sys.exit(1)\n\n    # Return type & value of an ip address attribute\n    @staticmethod\n    def handle_address(properties):\n        if properties.is_source:\n            ip_type = \"ip-src\"\n        else:\n            ip_type = \"ip-dst\"\n        return ip_type, properties.address_value.value, \"ip\"\n\n    def handle_as(self, properties):\n        attributes = self.fetch_attributes_with_partial_key_parsing(properties, stix2misp_mapping._as_mapping)\n        return attributes[0] if len(attributes) == 1 else ('asn', self.return_attributes(attributes), '')\n\n    # Return type & value of an attachment attribute\n    @staticmethod\n    def handle_attachment(properties, title):\n        if properties.hashes:\n            return \"malware-sample\", \"{}|{}\".format(title, properties.hashes[0], properties.raw_artifact.value)\n        return stix2misp_mapping.eventTypes[properties._XSI_TYPE]['type'], title, properties.raw_artifact.value\n\n    # Return type & attributes of a credential object\n    def handle_credential(self, properties):\n        attributes = []\n        if properties.description:\n            attributes.append([\"text\", properties.description.value, \"text\"])\n        if properties.authentication:\n            for authentication in properties.authentication:\n                attributes += self.fetch_attributes_with_key_parsing(authentication, stix2misp_mapping._credential_authentication_mapping)\n        if properties.custom_properties:\n            for prop in properties.custom_properties:\n                if prop.name in stix2misp_mapping._credential_custom_types:\n                    attributes.append(['text', prop.value, prop.name])\n        return attributes[0] if len(attributes) == 1 else (\"credential\", self.return_attributes(attributes), \"\")\n\n    # Return type & attributes of a dns object\n    def handle_dns(self, properties):\n        relation = []\n        if properties.domain_name:\n            relation.append([\"domain\", str(properties.domain_name.value), \"\"])\n        if properties.ip_address:\n            relation.append([\"ip-dst\", str(properties.ip_address.value), \"\"])\n        if relation:\n            if len(relation) == '2':\n                domain = relation[0][1]\n                ip = relattion[1][1]\n                attributes = [[\"text\", domain, \"rrname\"], [\"text\", ip, \"rdata\"]]\n                rrtype = \"AAAA\" if \":\" in ip else \"A\"\n                attributes.append([\"text\", rrtype, \"rrtype\"])\n                return \"passive-dns\", self.return_attributes(attributes), \"\"\n            return relation[0]\n\n    # Return type & value of a domain or url attribute\n    @staticmethod\n    def handle_domain_or_url(properties):\n        event_types = stix2misp_mapping.eventTypes[properties._XSI_TYPE]\n        return event_types['type'], properties.value.value, event_types['relation']\n\n    # Return type & value of an email attribute\n    def handle_email_attribute(self, properties):\n        if properties.header:\n            header = properties.header\n            attributes = self.fetch_attributes_with_key_parsing(header, stix2misp_mapping._email_mapping)\n            if header.to:\n                for to in header.to:\n                    attributes.append([\"email-dst\", to.address_value.value, \"to\"])\n            if header.cc:\n                for cc in header.cc:\n                    attributes.append([\"email-dst\", cc.address_value.value, \"cc\"])\n        else:\n            attributes = []\n        if properties.attachments:\n            attributes.append(self.handle_email_attachment(properties.parent))\n        return attributes[0] if len(attributes) == 1 else (\"email\", self.return_attributes(attributes), \"\")\n\n    # Return type & value of an email attachment\n    @staticmethod\n    def handle_email_attachment(indicator_object):\n        properties = indicator_object.related_objects[0].properties\n        return [\"email-attachment\", properties.file_name.value, \"attachment\"]\n\n    # Return type & attributes of a file object\n    def handle_file(self, properties, is_object):\n        b_hash, b_file = False, False\n        attributes = []\n        if properties.hashes:\n            b_hash = True\n            for h in properties.hashes:\n                attributes.append(self.handle_hashes_attribute(h))\n        if properties.file_name:\n            value = properties.file_name.value\n            if value:\n                b_file = True\n                attribute_type, relation = stix2misp_mapping.eventTypes[properties._XSI_TYPE]\n                attributes.append([attribute_type, value, relation])\n        attributes.extend(self.fetch_attributes_with_keys(properties, stix2misp_mapping._file_mapping))\n        if len(attributes) == 1:\n            attribute = attributes[0]\n            return attribute[0] if attribute[2] != \"fullpath\" else \"filename\", attribute[1], \"\"\n        if len(attributes) == 2:\n            if b_hash and b_file:\n                return self.handle_filename_object(attributes, is_object)\n            path, filename = self.handle_filename_path_case(attributes)\n            if path and filename:\n                attribute_value = \"{}\\\\{}\".format(path, filename)\n                if '\\\\' in filename and path == filename:\n                    attribute_value = filename\n                return \"filename\", attribute_value, \"\"\n        return \"file\", self.return_attributes(attributes), \"\"\n\n    # Determine path & filename from a complete path or filename attribute\n    @staticmethod\n    def handle_filename_path_case(attributes):\n        path, filename = [\"\"] * 2\n        if attributes[0][2] == 'filename' and attributes[1][2] == 'path':\n            path = attributes[1][1]\n            filename = attributes[0][1]\n        elif attributes[0][2] == 'path' and attributes[1][2] == 'filename':\n            path = attributes[0][1]\n            filename = attributes[1][1]\n        return path, filename\n\n    # Return the appropriate type & value when we have 1 filename & 1 hash value\n    @staticmethod\n    def handle_filename_object(attributes, is_object):\n        for attribute in attributes:\n            attribute_type, attribute_value, _ = attribute\n            if attribute_type == \"filename\":\n                filename_value = attribute_value\n            else:\n                hash_type, hash_value = attribute_type, attribute_value\n        value = \"{}|{}\".format(filename_value,  hash_value)\n        if is_object:\n            # file object attributes cannot be filename|hash, so it is malware-sample\n            attr_type = \"malware-sample\"\n            return attr_type, value, attr_type\n        # it could be malware-sample as well, but STIX is losing this information\n        return \"filename|{}\".format(hash_type), value, \"\"\n\n    # Return type & value of a hash attribute\n    @staticmethod\n    def handle_hashes_attribute(properties):\n        hash_type = properties.type_.value.lower()\n        try:\n            hash_value = properties.simple_hash_value.value\n        except AttributeError:\n            hash_value = properties.fuzzy_hash_value.value\n        return hash_type, hash_value, hash_type\n\n    # Return type & value of a hostname attribute\n    @staticmethod\n    def handle_hostname(properties):\n        event_types = stix2misp_mapping.eventTypes[properties._XSI_TYPE]\n        return event_types['type'], properties.hostname_value.value, event_types['relation']\n\n    # Return type & value of a http request attribute\n    @staticmethod\n    def handle_http(properties):\n        client_request = properties.http_request_response[0].http_client_request\n        if client_request.http_request_header:\n            request_header = client_request.http_request_header\n            if request_header.parsed_header:\n                value = request_header.parsed_header.user_agent.value\n                return \"user-agent\", value, \"user-agent\"\n            elif request_header.raw_header:\n                value = request_header.raw_header.value\n                return \"http-method\", value, \"method\"\n        elif client_request.http_request_line:\n            value = client_request.http_request_line.http_method.value\n            return \"http-method\", value, \"method\"\n\n    # Return type & value of a mutex attribute\n    @staticmethod\n    def handle_mutex(properties):\n        event_types = stix2misp_mapping.eventTypes[properties._XSI_TYPE]\n        return event_types['type'], properties.name.value, event_types['relation']\n\n    # Return type & attributes of a network connection object\n    def handle_network_connection(self, properties):\n        attributes = self.fetch_attributes_from_sockets(properties, stix2misp_mapping._network_connection_addresses)\n        for prop in ('layer3_protocol', 'layer4_protocol', 'layer7_protocol'):\n            if getattr(properties, prop):\n                attributes.append(['text', attrgetter(\"{}.value\".format(prop))(properties), prop.replace('_', '-')])\n        if attributes:\n            return \"network-connection\", self.return_attributes(attributes), \"\"\n\n    # Return type & attributes of a network socket objet\n    def handle_network_socket(self, properties):\n        attributes = self.fetch_attributes_from_sockets(properties, stix2misp_mapping._network_socket_addresses)\n        attributes.extend(self.fetch_attributes_with_keys(properties, stix2misp_mapping._network_socket_mapping))\n        for prop in ('is_listening', 'is_blocking'):\n            if getattr(properties, prop):\n                attributes.append([\"text\", prop.split('_')[1], \"state\"])\n        if attributes:\n            return \"network-socket\", self.return_attributes(attributes), \"\"\n\n    # Return type & value of a port attribute\n    @staticmethod\n    def handle_port(*kwargs):\n        properties = kwargs[0]\n        event_types = stix2misp_mapping.eventTypes[properties._XSI_TYPE]\n        relation = event_types['relation']\n        if len(kwargs) > 1:\n            observable_id = kwargs[1]\n            if \"srcPort\" in observable_id:\n                relation = \"src-{}\".format(relation)\n            elif \"dstPort\" in observable_id:\n                relation = \"dst-{}\".format(relation)\n        return event_types['type'], properties.port_value.value, relation\n\n    # Return type & attributes of a process object\n    def handle_process(self, properties):\n        attributes = self.fetch_attributes_with_partial_key_parsing(properties, stix2misp_mapping._process_mapping)\n        if properties.child_pid_list:\n            for child in properties.child_pid_list:\n                attributes.append([\"text\", child.value, \"child-pid\"])\n        # if properties.port_list:\n        #     for port in properties.port_list:\n        #         attributes.append([\"src-port\", port.port_value.value, \"port\"])\n        if properties.network_connection_list:\n            references = []\n            for connection in properties.network_connection_list:\n                object_name, object_attributes, _ = self.handle_network_connection(connection)\n                object_uuid = str(uuid.uuid4())\n                misp_object = MISPObject(object_name)\n                misp_object.uuid = object_uuid\n                for attribute in object_attributes:\n                    misp_object.add_attribute(**attribute)\n                references.append(object_uuid)\n            return \"process\", self.return_attributes(attributes), {\"process_uuid\": references}\n        return \"process\", self.return_attributes(attributes), \"\"\n\n    # Return type & value of a regkey attribute\n    def handle_regkey(self, properties):\n        attributes = self.fetch_attributes_with_partial_key_parsing(properties, stix2misp_mapping._regkey_mapping)\n        if properties.values:\n            values = properties.values\n            value = values[0]\n            attributes += self.fetch_attributes_with_partial_key_parsing(value, stix2misp_mapping._regkey_value_mapping)\n        if len(attributes) in (2,3):\n            d_regkey = {key: value for (_, value, key) in attributes}\n            if 'hive' in d_regkey and 'key' in d_regkey:\n                regkey = \"{}\\\\{}\".format(d_regkey['hive'], d_regkey['key'])\n                if 'data' in d_regkey:\n                    return \"regkey|value\", \"{} | {}\".format(regkey, d_regkey['data']), \"\"\n                return \"regkey\", regkey, \"\"\n        return \"registry-key\", self.return_attributes(attributes), \"\"\n\n    @staticmethod\n    def handle_socket(attributes, socket, s_type):\n        for prop, mapping in stix2misp_mapping._socket_mapping.items():\n            if getattr(socket, prop):\n                attribute_type, properties_key, relation = mapping\n                attribute_type, relation = [elem.format(s_type) for elem in (attribute_type, relation)]\n                attributes.append([attribute_type, attrgetter('{}.{}.value'.format(prop, properties_key))(socket), relation])\n\n    # Parse a socket address object in order to return type & value\n    # of a composite attribute ip|port or hostname|port\n    def handle_socket_address(self, properties):\n        if properties.ip_address:\n            type1, value1, _ = self.handle_address(properties.ip_address)\n        elif properties.hostname:\n            type1 = \"hostname\"\n            value1 = properties.hostname.hostname_value.value\n        return \"{}|port\".format(type1), \"{}|{}\".format(value1, properties.port.port_value.value), \"\"\n\n    # Parse a system object to extract a mac-address attribute\n    @staticmethod\n    def handle_system(properties):\n        if properties.network_interface_list:\n            return \"mac-address\", str(properties.network_interface_list[0].mac), \"\"\n\n    # Parse a whois object:\n    # Return type & attributes of a whois object if we have the required fields\n    # Otherwise create attributes and return type & value of the last attribute to avoid crashing the parent function\n    def handle_whois(self, properties):\n        attributes = self.fetch_attributes_with_key_parsing(properties, stix2misp_mapping._whois_mapping)\n        required_one_of = True if attributes else False\n        if properties.registrants:\n            registrant = properties.registrants[0]\n            attributes += self.fetch_attributes_with_key_parsing(registrant, stix2misp_mapping._whois_registrant_mapping)\n        if properties.creation_date:\n            attributes.append([\"datetime\", properties.creation_date.value.strftime('%Y-%m-%d'), \"creation-date\"])\n            required_one_of = True\n        if properties.updated_date:\n            attributes.append([\"datetime\", properties.updated_date.value.strftime('%Y-%m-%d'), \"modification-date\"])\n        if properties.expiration_date:\n            attributes.append([\"datetime\", properties.expiration_date.value.strftime('%Y-%m-%d'), \"expiration-date\"])\n        if properties.nameservers:\n            for nameserver in properties.nameservers:\n                attributes.append([\"hostname\", nameserver.value.value, \"nameserver\"])\n        if properties.remarks:\n            attribute_type = \"text\"\n            relation = \"comment\" if attributes else attribute_type\n            attributes.append([attribute_type, properties.remarks.value, relation])\n            required_one_of = True\n        # Testing if we have the required attribute types for Object whois\n        if required_one_of:\n            # if yes, we return the object type and the attributes\n            return \"whois\", self.return_attributes(attributes), \"\"\n        # otherwise, attributes are added in the event, and one attribute is returned to not make the function crash\n        if len(attributes) == 1:\n            return attributes[0]\n        last_attribute = attributes.pop(-1)\n        for attribute in attributes:\n            attribute_type, attribute_value, attribute_relation = attribute\n            misp_attributes = {\"comment\": \"Whois {}\".format(attribute_relation)}\n            self.misp_event.add_attribute(attribute_type, attribute_value, **misp_attributes)\n        return last_attribute\n\n    # Return type & value of a windows service object\n    @staticmethod\n    def handle_windows_service(properties):\n        if properties.name:\n            return \"windows-service-name\", properties.name.value, \"\"\n\n    def handle_x509(self, properties):\n        attributes = self.handle_x509_certificate(properties.certificate) if properties.certificate else []\n        if properties.raw_certificate:\n            raw = properties.raw_certificate.value\n            try:\n                relation = \"raw-base64\" if raw == base64.b64encode(base64.b64decode(raw)).strip() else \"pem\"\n            except Exception:\n                relation = \"pem\"\n            attributes.append([\"text\", raw, relation])\n        if properties.certificate_signature:\n            signature = properties.certificate_signature\n            attribute_type = \"x509-fingerprint-{}\".format(signature.signature_algorithm.value.lower())\n            attributes.append([attribute_type, signature.signature.value, attribute_type])\n        return \"x509\", self.return_attributes(attributes), \"\"\n\n    @staticmethod\n    def handle_x509_certificate(certificate):\n        attributes = []\n        if certificate.validity:\n            validity = certificate.validity\n            for prop in stix2misp_mapping._x509_datetime_types:\n                if getattr(validity, prop):\n                    attributes.append(['datetime', attrgetter('{}.value'.format(prop))(validity), 'validity-{}'.format(prop.replace('_', '-'))])\n        if certificate.subject_public_key:\n            subject_pubkey = certificate.subject_public_key\n            if subject_pubkey.rsa_public_key:\n                rsa_pubkey = subject_pubkey.rsa_public_key\n                for prop in stix2misp_mapping._x509__x509_pubkey_types:\n                    if getattr(rsa_pubkey, prop):\n                        attributes.append(['text', attrgetter('{}.value'.format(prop))(rsa_pubkey), 'pubkey-info-{}'.format(prop)])\n            if subject_pubkey.public_key_algorithm:\n                attributes.append([\"text\", subject_pubkey.public_key_algorithm.value, \"pubkey-info-algorithm\"])\n        for prop in stix2misp_mapping._x509_certificate_types:\n            if getattr(certificate, prop):\n                attributes.append(['text', attrgetter('{}.value'.format(prop))(certificate), prop.replace('_', '-')])\n        return attributes\n\n    # Return type & attributes of the file defining a portable executable object\n    def handle_pe(self, properties):\n        pe_uuid = self.parse_pe(properties)\n        file_type, file_value, _ = self.handle_file(properties, False)\n        return file_type, file_value, pe_uuid\n\n    # Parse attributes of a portable executable, create the corresponding object,\n    # and return its uuid to build the reference for the file object generated at the same time\n    def parse_pe(self, properties):\n        misp_object = MISPObject('pe')\n        filename = properties.file_name.value\n        for attr in ('internal-filename', 'original-filename'):\n            misp_object.add_attribute(**dict(zip(('type', 'value', 'object_relation'),('filename', filename, attr))))\n        if properties.headers:\n            headers = properties.headers\n            header_object = MISPObject('pe-section')\n            if headers.entropy:\n                header_object.add_attribute(**{\"type\": \"float\", \"object_relation\": \"entropy\",\n                                               \"value\": headers.entropy.value.value})\n            file_header = headers.file_header\n            misp_object.add_attribute(**{\"type\": \"counter\", \"object_relation\": \"number-sections\",\n                                         \"value\": file_header.number_of_sections.value})\n            for h in file_header.hashes:\n                hash_type, hash_value, hash_relation = self.handle_hashes_attribute(h)\n                header_object.add_attribute(**{\"type\": hash_type, \"value\": hash_value, \"object_relation\": hash_relation})\n            if file_header.size_of_optional_header:\n                header_object.add_attribute(**{\"type\": \"size-in-bytes\", \"object_relation\": \"size-in-bytes\",\n                                               \"value\": file_header.size_of_optional_header.value})\n            self.misp_event.add_object(**header_object)\n            misp_object.add_reference(header_object.uuid, 'header-of')\n        if properties.sections:\n            for section in properties.sections:\n                section_uuid = self.parse_pe_section(section)\n                misp_object.add_reference(section_uuid, 'included-in')\n        self.misp_event.add_object(**misp_object)\n        return {\"pe_uuid\": misp_object.uuid}\n\n    # Parse attributes of a portable executable section, create the corresponding object,\n    # and return its uuid to build the reference for the pe object generated at the same time\n    def parse_pe_section(self, section):\n        section_object = MISPObject('pe-section')\n        header_hashes = section.header_hashes\n        for h in header_hashes:\n            hash_type, hash_value, hash_relation = self.handle_hashes_attribute(h)\n            section_object.add_attribute(**{\"type\": hash_type, \"value\": hash_value, \"object_relation\": hash_relation})\n        if section.entropy:\n            section_object.add_attribute(**{\"type\": \"float\", \"object_relation\": \"entropy\",\n                                            \"value\": section.entropy.value.value})\n        if section.section_header:\n            section_header = section.section_header\n            section_object.add_attribute(**{\"type\": \"text\", \"object_relation\": \"name\",\n                                            \"value\": section_header.name.value})\n            section_object.add_attribute(**{\"type\": \"size-in-bytes\", \"object_relation\": \"size-in-bytes\",\n                                            \"value\": section_header.size_of_raw_data.value})\n        self.misp_event.add_object(**section_object)\n        return section_object.uuid\n\n    ################################################################################\n    ##             MARKINGS PARSING FUNCTIONS USED BY BOTH SUBCLASSES             ##\n    ################################################################################\n\n    def parse_AIS_marking(self, marking):\n        tags = []\n        if hasattr(marking, 'is_proprietary') and marking.is_proprietary:\n            proprietary = \"Is\"\n            marking = marking.is_proprietary\n        elif hasattr(marking, 'not_proprietary') and marking.not_proprietary:\n            proprietary = \"Not\"\n            marking = marking.not_proprietary\n        else:\n            return\n        mapping = stix2misp_mapping._AIS_marking_mapping\n        prefix = mapping['prefix']\n        tags.append('{}{}'.format(prefix, mapping['proprietary'].format(proprietary)))\n        if hasattr(marking, 'cisa_proprietary'):\n            try:\n                cisa_proprietary = marking.cisa_proprietary.numerator\n                cisa_proprietary = 'true' if cisa_proprietary == 1 else 'false'\n                tags.append('{}{}'.format(prefix, mapping['cisa_proprietary'].format(cisa_proprietary)))\n            except AttributeError:\n                pass\n        for ais_field in ('ais_consent', 'tlp_marking'):\n            if hasattr(marking, ais_field) and getattr(marking, ais_field):\n                key, tag = mapping[ais_field]\n                tags.append('{}{}'.format(prefix, tag.format(getattr(getattr(marking, ais_field), key))))\n        return tags\n\n    def parse_TLP_marking(self, marking):\n        return ['tlp:{}'.format(marking.color.lower())]\n\n    ################################################################################\n    ##          FUNCTIONS HANDLING PARSED DATA, USED BY BOTH SUBCLASSES.          ##\n    ################################################################################\n\n    # The value returned by the indicators or observables parser is of type str or int\n    # Thus we can add an attribute in the MISP event with the type & value\n    def handle_attribute_case(self, attribute_type, attribute_value, data, attribute):\n        if attribute_type == 'attachment':\n            attribute['data'] = data\n        elif attribute_type == 'text':\n            attribute['comment'] = data\n        self.misp_event.add_attribute(attribute_type, attribute_value, **attribute)\n\n    # The value returned by the indicators or observables parser is a list of dictionaries\n    # These dictionaries are the attributes we add in an object, itself added in the MISP event\n    def handle_object_case(self, attribute_type, attribute_value, compl_data, to_ids=False, object_uuid=None):\n        misp_object = MISPObject(attribute_type)\n        if object_uuid:\n            misp_object.uuid = object_uuid\n        for attribute in attribute_value:\n            attribute['to_ids'] = to_ids\n            misp_object.add_attribute(**attribute)\n        if isinstance(compl_data, dict):\n            # if some complementary data is a dictionary containing an uuid,\n            # it means we are using it to add an object reference\n            if \"pe_uuid\" in compl_data:\n                misp_object.add_reference(compl_data['pe_uuid'], 'included-in')\n            if \"process_uuid\" in compl_data:\n                for uuid in compl_data[\"process_uuid\"]:\n                    misp_object.add_reference(uuid, 'connected-to')\n        self.misp_event.add_object(**misp_object)\n\n    ################################################################################\n    ##              UTILITY FUNCTIONS USED BY PARSING FUNCTION ABOVE              ##\n    ################################################################################\n\n    def fetch_attributes_from_sockets(self, properties, mapping_dict):\n        attributes = []\n        for prop, s_type in zip(mapping_dict, stix2misp_mapping._s_types):\n            address_property = getattr(properties, prop)\n            if address_property:\n                self.handle_socket(attributes, address_property, s_type)\n        return attributes\n\n    @staticmethod\n    def fetch_attributes_with_keys(properties, mapping_dict):\n        attributes = []\n        for prop, mapping in mapping_dict.items():\n            if getattr(properties,prop):\n                attribute_type, properties_key, relation = mapping\n                attributes.append([attribute_type, attrgetter(properties_key)(properties), relation])\n        return attributes\n\n    @staticmethod\n    def fetch_attributes_with_key_parsing(properties, mapping_dict):\n        attributes = []\n        for prop, mapping in mapping_dict.items():\n            if getattr(properties, prop):\n                attribute_type, properties_key, relation = mapping\n                attributes.append([attribute_type, attrgetter('{}.{}'.format(prop, properties_key))(properties), relation])\n        return attributes\n\n    @staticmethod\n    def fetch_attributes_with_partial_key_parsing(properties, mapping_dict):\n        attributes = []\n        for prop, mapping in mapping_dict.items():\n            if getattr(properties, prop):\n                attribute_type, relation = mapping\n                attributes.append([attribute_type, attrgetter('{}.value'.format(prop))(properties), relation])\n        return attributes\n\n    # Extract the uuid from a stix id\n    @staticmethod\n    def fetch_uuid(object_id):\n        try:\n            return \"-\".join(object_id.split(\"-\")[-5:])\n        except Exception:\n            return str(uuid.uuid4())\n\n    # Return the attributes that will be added in a MISP object as a list of dictionaries\n    @staticmethod\n    def return_attributes(attributes):\n        return_attributes = []\n        for attribute in attributes:\n            return_attributes.append(dict(zip(('type', 'value', 'object_relation'), attribute)))\n        return return_attributes\n\n\nclass StixFromMISPParser(StixParser):\n    def __init__(self):\n        super(StixFromMISPParser, self).__init__()\n        self.dates = []\n        self.timestamps = []\n        self.titles = []\n\n    def build_misp_dict(self, event):\n        for item in event.related_packages.related_package:\n            package = item.item\n            self.event = package.incidents[0]\n            self.set_timestamp_and_date()\n            self.set_event_info()\n            if self.event.related_indicators:\n                for indicator in self.event.related_indicators.indicator:\n                    self.parse_misp_indicator(indicator)\n            if self.event.related_observables:\n                for observable in self.event.related_observables.observable:\n                    self.parse_misp_observable(observable)\n            if self.event.history:\n                self.parse_journal_entries()\n            if self.event.information_source and self.event.information_source.references:\n                for reference in self.event.information_source.references:\n                    self.misp_event.add_attribute(**{'type': 'link', 'value': reference})\n            if package.ttps:\n                for ttp in package.ttps.ttps:\n                    if ttp.exploit_targets:\n                        self.parse_vulnerability(ttp.exploit_targets.exploit_target)\n                    # if ttp.handling:\n                    #     self.parse_tlp_marking(ttp.handling)\n        self.set_distribution()\n\n    # Return type & attributes (or value) of a Custom Object\n    def handle_custom(self, properties):\n        custom_properties = properties.custom_properties\n        attributes = []\n        for prop in custom_properties:\n            attribute_type, relation = prop.name.split(': ')\n            attribute_type = attribute_type.split(' ')[1]\n            attributes.append([attribute_type, prop.value, relation])\n        if len(attributes) > 1:\n            name = custom_properties[0].name.split(' ')[0]\n            return name, self.return_attributes(attributes), \"\"\n        return attributes[0]\n\n    def parse_journal_entries(self):\n        for entry in self.event.history.history_items:\n            journal_entry = entry.journal_entry.value\n            try:\n                entry_type, entry_value = journal_entry.split(': ')\n                if entry_type == \"MISP Tag\":\n                    self.parse_tag(entry_value)\n                elif entry_type.startswith('attribute['):\n                    _, category, attribute_type = entry_type.split('[')\n                    self.misp_event.add_attribute(**{'type': attribute_type[:-1], 'category': category[:-1], 'value': entry_value})\n                elif entry_type == \"Event Threat Level\":\n                    self.misp_event.threat_level_id = threat_level_mapping[entry_value]\n            except ValueError:\n                continue\n\n    # Parse indicators of a STIX document coming from our exporter\n    def parse_misp_indicator(self, indicator):\n        # define is an indicator will be imported as attribute or object\n        if indicator.relationship in categories:\n            self.parse_misp_attribute_indicator(indicator)\n        else:\n            self.parse_misp_object_indicator(indicator)\n\n    def parse_misp_observable(self, observable):\n        if observable.relationship in categories:\n            self.parse_misp_attribute_observable(observable)\n        else:\n            self.parse_misp_object_observable(observable)\n\n    # Parse STIX objects that we know will give MISP attributes\n    def parse_misp_attribute_indicator(self, indicator):\n        misp_attribute = {'to_ids': True, 'category': str(indicator.relationship),\n                          'uuid': self.fetch_uuid(indicator.id_)}\n        item = indicator.item\n        misp_attribute['timestamp'] = self.getTimestampfromDate(item.timestamp)\n        if item.observable:\n            observable = item.observable\n            self.parse_misp_attribute(observable, misp_attribute, to_ids=True)\n\n    def parse_misp_attribute_observable(self, observable):\n        misp_attribute = {'to_ids': False, 'category': str(observable.relationship),\n                          'uuid': self.fetch_uuid(observable.id_)}\n        if observable.item:\n            self.parse_misp_attribute(observable.item, misp_attribute)\n\n    def parse_misp_attribute(self, observable, misp_attribute, to_ids=False):\n        try:\n            properties = observable.object_.properties\n            if properties:\n                attribute_type, attribute_value, compl_data = self.handle_attribute_type(properties)\n                if isinstance(attribute_value, (str, int)):\n                    self.handle_attribute_case(attribute_type, attribute_value, compl_data, misp_attribute)\n                else:\n                    self.handle_object_case(attribute_type, attribute_value, compl_data, to_ids=to_ids)\n        except AttributeError:\n            attribute_dict = {}\n            for observables in observable.observable_composition.observables:\n                properties = observables.object_.properties\n                attribute_type, attribute_value, _ = self.handle_attribute_type(properties, observable_id=observable.id_)\n                attribute_dict[attribute_type] = attribute_value\n            attribute_type, attribute_value = self.composite_type(attribute_dict)\n            self.misp_event.add_attribute(attribute_type, attribute_value, **misp_attribute)\n\n    # Return type & value of a composite attribute in MISP\n    @staticmethod\n    def composite_type(attributes):\n        if \"port\" in attributes:\n            if \"ip-src\" in attributes:\n                return \"ip-src|port\", \"{}|{}\".format(attributes[\"ip-src\"], attributes[\"port\"])\n            elif \"ip-dst\" in attributes:\n                return \"ip-dst|port\", \"{}|{}\".format(attributes[\"ip-dst\"], attributes[\"port\"])\n            elif \"hostname\" in attributes:\n                return \"hostname|port\", \"{}|{}\".format(attributes[\"hostname\"], attributes[\"port\"])\n        elif \"domain\" in attributes:\n            if \"ip-src\" in attributes:\n                ip_value = attributes[\"ip-src\"]\n            elif \"ip-dst\" in attributes:\n                ip_value = attributes[\"ip-dst\"]\n            return \"domain|ip\", \"{}|{}\".format(attributes[\"domain\"], ip_value)\n\n    # Parse STIX object that we know will give MISP objects\n    def parse_misp_object_indicator(self, indicator):\n        object_type = str(indicator.relationship)\n        item = indicator.item\n        name = item.title.split(' ')[0]\n        if name not in ('passive-dns'):\n            self.fill_misp_object(item, name, to_ids=True)\n        else:\n            if object_type != \"misc\":\n                print(\"Unparsed Object type: {}\".format(name), file=sys.stderr)\n\n    def parse_misp_object_observable(self, observable):\n        object_type = str(observable.relationship)\n        observable = observable.item\n        observable_id = observable.id_\n        if object_type == \"file\":\n            name = \"registry-key\" if \"WinRegistryKey\" in observable_id else \"file\"\n        elif object_type == \"network\":\n            if \"Custom\" in observable_id:\n                name = observable_id.split(\"Custom\")[0].split(\":\")[1]\n            elif \"ObservableComposition\" in observable_id:\n                name = observable_id.split(\"_\")[0].split(\":\")[1]\n            else:\n                name = cybox_to_misp_object[observable_id.split('-')[0].split(':')[1]]\n        else:\n            name = cybox_to_misp_object[observable_id.split('-')[0].split(':')[1]]\n        try:\n            self.fill_misp_object(observable, name)\n        except Exception:\n            print(\"Unparsed Object type: {}\".format(observable.to_json()), file=sys.stderr)\n\n    # Create a MISP object, its attributes, and add it in the MISP event\n    def fill_misp_object(self, item, name, to_ids=False):\n        uuid = self.fetch_uuid(item.id_)\n        try:\n            misp_object = MISPObject(name)\n            misp_object.uuid = uuid\n            if to_ids:\n                observables = item.observable.observable_composition.observables\n                misp_object.timestamp = self.getTimestampfromDate(item.timestamp)\n            else:\n                observables = item.observable_composition.observables\n            for observable in observables:\n                properties = observable.object_.properties\n                misp_attribute = MISPAttribute()\n                misp_attribute.type, misp_attribute.value, misp_attribute.object_relation = self.handle_attribute_type(properties, is_object=True, observable_id=observable.id_)\n                misp_attribute.to_ids = to_ids\n                misp_object.add_attribute(**misp_attribute)\n            self.misp_event.add_object(**misp_object)\n        except AttributeError:\n            properties = item.observable.object_.properties if to_ids else item.object_.properties\n            self.parse_observable(properties, to_ids, uuid)\n\n    # Create a MISP attribute and add it in its MISP object\n    def parse_observable(self, properties, to_ids, uuid):\n        attribute_type, attribute_value, compl_data = self.handle_attribute_type(properties)\n        if isinstance(attribute_value, (str, int)):\n            attribute = {'to_ids': to_ids, 'uuid': uuid}\n            self.handle_attribute_case(attribute_type, attribute_value, compl_data, attribute)\n        else:\n            self.handle_object_case(attribute_type, attribute_value, compl_data, to_ids=to_ids, object_uuid=uuid)\n\n    def parse_tag(self, entry):\n        if entry.startswith('misp-galaxy:'):\n            tag_type, value = entry.split('=')\n            galaxy_type = tag_type.split(':')[1]\n            cluster = {'type': galaxy_type, 'value': value[1:-1], 'tag_name': entry}\n            self.misp_event['Galaxy'].append({'type': galaxy_type, 'GalaxyCluster': [cluster]})\n        self.misp_event.add_tag(entry)\n\n    def parse_vulnerability(self, exploit_targets):\n        for exploit_target in exploit_targets:\n            if exploit_target.item:\n                for vulnerability in exploit_target.item.vulnerabilities:\n                    self.misp_event.add_attribute(**{'type': 'vulnerability', 'value': vulnerability.cve_id})\n\n    def set_event_info(self):\n        info = self.get_event_info()\n        self.titles.append(info)\n\n    def set_timestamp_and_date(self):\n        if self.event.timestamp:\n            date, timestamp = self.get_timestamp_and_date()\n            self.dates.append(date)\n            self.timestamps.append(timestamp)\n\n\nclass ExternalStixParser(StixParser):\n    def __init__(self):\n        super(ExternalStixParser, self).__init__()\n        self.dns_objects = defaultdict(dict)\n        self.dns_ips = []\n\n    def build_misp_dict(self, event):\n        self.event = event\n        self.set_timestamp_and_date()\n        self.set_event_info()\n        header = self.event.stix_header\n        if hasattr(header, 'description') and hasattr(header.description, 'value'):\n            self.misp_event.add_attribute(**{'type': 'comment', 'value': header.description.value,\n                                             'comment': 'Imported from STIX header description'})\n        if hasattr(header, 'handling') and header.handling:\n            for handling in header.handling:\n                tags = self.parse_marking(handling)\n                for tag in  tags:\n                    self.misp_event.add_tag(tag)\n        if self.event.indicators:\n            self.parse_external_indicators(self.event.indicators)\n        if self.event.observables:\n            self.parse_external_observable(self.event.observables.observables)\n        if self.event.ttps:\n            self.parse_ttps(self.event.ttps.ttps)\n        if self.event.courses_of_action:\n            self.parse_coa(self.event.courses_of_action)\n        if self.dns_objects:\n            self.resolve_dns_objects()\n        self.set_distribution()\n        if self.references:\n            self.build_references()\n\n    def set_event_info(self):\n        info =  self.get_event_info()\n        self.misp_event.info = str(info)\n\n    def set_timestamp_and_date(self):\n        if self.event.timestamp:\n            date, timestamp = self.get_timestamp_and_date()\n            self.misp_event.date = date\n            self.misp_event.timestamp = timestamp\n\n    # Return type & attributes (or value) of a Custom Object\n    def handle_custom(self, properties):\n        custom_properties = properties.custom_properties\n        if len(custom_properties) > 1:\n            for prop in custom_properties[:-1]:\n                misp_attribute = {'type': 'text', 'value': prop.value, 'comment': prop.name}\n                self.misp_event.add_attribute(**misp_attribute)\n        to_return = custom_properties[-1]\n        return 'text', to_return.value, to_return.name\n\n    # Parse the courses of action field of an external STIX document\n    def parse_coa(self, courses_of_action):\n        for coa in courses_of_action:\n            misp_object = MISPObject('course-of-action')\n            if coa.title:\n                attribute = {'type': 'text', 'object_relation': 'name',\n                             'value': coa.title}\n                misp_object.add_attribute(**attribute)\n            for prop, properties_key in stix2misp_mapping._coa_mapping.items():\n                if getattr(coa, prop):\n                    attribute = {'type': 'text', 'object_relation': prop.replace('_', ''),\n                                 'value': attrgetter('{}.{}'.format(prop, properties_key))(coa)}\n                    misp_object.add_attribute(**attribute)\n            if coa.parameter_observables:\n                for observable in coa.parameter_observables.observables:\n                    properties = observable.object_.properties\n                    attribute = MISPAttribute()\n                    attribute.type, attribute.value, _ = self.handle_attribute_type(properties)\n                    referenced_uuid = str(uuid.uuid4())\n                    attribute.uuid = referenced_uuid\n                    self.misp_event.add_attribute(**attribute)\n                    misp_object.add_reference(referenced_uuid, 'observable', None, **attribute)\n            self.misp_event.add_object(**misp_object)\n\n    # Parse description of an external indicator or observable and add it in the MISP event as an attribute\n    def parse_description(self, stix_object):\n        if stix_object.description:\n            misp_attribute = {}\n            if stix_object.timestamp:\n                misp_attribute['timestamp'] = self.getTimestampfromDate(stix_object.timestamp)\n            self.misp_event.add_attribute(\"text\", stix_object.description.value, **misp_attribute)\n\n    # Parse indicators of an external STIX document\n    def parse_external_indicators(self, indicators):\n        for indicator in indicators:\n            self.parse_external_single_indicator(indicator)\n\n    def parse_external_single_indicator(self, indicator):\n        if hasattr(indicator, 'observable') and indicator.observable:\n            observable = indicator.observable\n            if hasattr(observable, 'object_') and observable.object_:\n                uuid = self.fetch_uuid(observable.object_.id_)\n                try:\n                    properties = observable.object_.properties\n                    if properties:\n                        attribute_type, attribute_value, compl_data = self.handle_attribute_type(properties)\n                        if isinstance(attribute_value, (str, int)):\n                            # if the returned value is a simple value, we build an attribute\n                            attribute = {'to_ids': True, 'uuid': uuid}\n                            if indicator.timestamp:\n                                attribute['timestamp'] = self.getTimestampfromDate(indicator.timestamp)\n                            if hasattr(observable, 'handling') and observable.handling:\n                                attribute['Tag'] = []\n                                for handling in observable.handling:\n                                    attribute['Tag'].extend(self.parse_marking(handling))\n                            parsed = self.special_parsing(observable.object_, attribute_type, attribute_value, attribute, uuid)\n                            if parsed is not None:\n                                return\n                            self.handle_attribute_case(attribute_type, attribute_value, compl_data, attribute)\n                        else:\n                            # otherwise, it is a dictionary of attributes, so we build an object\n                            self.handle_object_case(attribute_type, attribute_value, compl_data, to_ids=True, object_uuid=uuid)\n                except AttributeError:\n                    self.parse_description(indicator)\n        if hasattr(indicator, 'related_indicators') and indicator.related_indicators:\n            for related_indicator in indicator.related_indicators:\n                self.parse_external_single_indicator(related_indicator.item)\n\n    # Parse observables of an external STIX document\n    def parse_external_observable(self, observables):\n        for observable in observables:\n            title = observable.title\n            observable_object = observable.object_\n            try:\n                properties = observable_object.properties\n            except AttributeError:\n                self.parse_description(observable)\n                continue\n            if properties:\n                try:\n                    attribute_type, attribute_value, compl_data = self.handle_attribute_type(properties, title=title)\n                except KeyError:\n                    # print(\"Error with an object of type: {}\\n{}\".format(properties._XSI_TYPE, observable.to_json()))\n                    continue\n                object_uuid = self.fetch_uuid(observable_object.id_)\n                if isinstance(attribute_value, (str, int)):\n                    # if the returned value is a simple value, we build an attribute\n                    attribute = {'to_ids': False, 'uuid': object_uuid}\n                    if hasattr(observable, 'handling') and observable.handling:\n                        attribute['Tag'] = []\n                        for handling in observable.handling:\n                            attribute['Tag'].extend(self.parse_marking(handling))\n                    parsed = self.special_parsing(observable_object, attribute_type, attribute_value, attribute, object_uuid)\n                    if parsed is not None:\n                        continue\n                    self.handle_attribute_case(attribute_type, attribute_value, compl_data, attribute)\n                else:\n                    # otherwise, it is a dictionary of attributes, so we build an object\n                    if attribute_value:\n                        self.handle_object_case(attribute_type, attribute_value, compl_data, object_uuid=object_uuid)\n                    if observable_object.related_objects:\n                        for related_object in observable_object.related_objects:\n                            relationship = related_object.relationship.value.lower().replace('_', '-')\n                            self.references[object_uuid].append({\"idref\": self.fetch_uuid(related_object.idref),\n                                                                 \"relationship\": relationship})\n\n    # Parse the ttps field of an external STIX document\n    def parse_ttps(self, ttps):\n        for ttp in ttps:\n            if ttp.behavior and ttp.behavior.malware_instances:\n                mi = ttp.behavior.malware_instances[0]\n                if mi.types:\n                    mi_type = mi.types[0].value\n                    galaxy = {'type': mi_type}\n                    cluster = defaultdict(dict)\n                    cluster['type'] = mi_type\n                    if mi.description:\n                        cluster['description'] = mi.description.value\n                    cluster['value'] = ttp.title\n                    if mi.names:\n                        synonyms = []\n                        for name in mi.names:\n                            synonyms.append(name.value)\n                        cluster['meta']['synonyms'] = synonyms\n                    galaxy['GalaxyCluster'] = [cluster]\n                    self.misp_event['Galaxy'].append(galaxy)\n\n    # Parse a DNS object\n    def resolve_dns_objects(self):\n        for domain, domain_dict in self.dns_objects['domain'].items():\n            ip_reference = domain_dict['related']\n            domain_attribute = domain_dict['data']\n            if ip_reference in self.dns_objects['ip']:\n                misp_object = MISPObject('passive-dns')\n                domain_attribute['object_relation'] = \"rrname\"\n                misp_object.add_attribute(**domain_attribute)\n                ip = self.dns_objects['ip'][ip_reference]['value']\n                ip_attribute = {\"type\": \"text\", \"value\": ip, \"object_relation\": \"rdata\"}\n                misp_object.add_attribute(**ip_attribute)\n                rrtype = \"AAAA\" if \":\" in ip else \"A\"\n                rrtype_attribute = {\"type\": \"text\", \"value\": rrtype, \"object_relation\": \"rrtype\"}\n                misp_object.add_attribute(**rrtype_attribute)\n                self.misp_event.add_object(**misp_object)\n            else:\n                self.misp_event.add_attribute(**domain_attribute)\n        for ip, ip_dict in self.dns_objects['ip'].items():\n            if ip not in self.dns_ips:\n                self.misp_event.add_attribute(**ip_dict)\n\n    def special_parsing(self, observable_object, attribute_type, attribute_value, attribute, uuid):\n        if observable_object.related_objects:\n            related_objects = observable_object.related_objects\n            if attribute_type == \"url\" and len(related_objects) == 1 and related_objects[0].relationship.value == \"Resolved_To\":\n                related_ip = self.fetch_uuid(related_objects[0].idref)\n                self.dns_objects['domain'][uuid] = {\"related\": related_ip,\n                                                    \"data\": {\"type\": \"text\", \"value\": attribute_value}}\n                if related_ip not in self.dns_ips:\n                    self.dns_ips.append(related_ip)\n                return 1\n        if attribute_type in ('ip-src', 'ip-dst'):\n            attribute['type'] = attribute_type\n            attribute['value'] = attribute_value\n            self.dns_objects['ip'][uuid] = attribute\n            return 2\n\n\ndef generate_event(filename):\n    try:\n        return STIXPackage.from_xml(filename)\n    except Exception:\n        try:\n            import maec\n            print(2)\n        except ImportError:\n            print(3)\n        sys.exit(0)\n\ndef main(args):\n    filename = '{}/tmp/{}'.format(os.path.dirname(args[0]), args[1])\n    event = generate_event(filename)\n    title = event.stix_header.title\n    from_misp = (title is not None and \"Export from \" in title and \"MISP\" in title)\n    stix_parser = StixFromMISPParser() if from_misp else ExternalStixParser()\n    stix_parser.load_event(args[2:], filename, from_misp, event.version)\n    stix_parser.build_misp_dict(event)\n    stix_parser.saveFile()\n    print(1)\n\nif __name__ == \"__main__\":\n    main(sys.argv)\n"], "filenames": ["app/Model/Event.php", "app/files/scripts/stix2misp.py"], "buggy_code_start_loc": [5082, 56], "buggy_code_end_loc": [5645, 93], "fixing_code_start_loc": [5082, 55], "fixing_code_end_loc": [5698, 80], "type": "CWE-78", "message": "An issue was discovered in MISP 2.4.9x before 2.4.99. In app/Model/Event.php (the STIX 1 import code), an unescaped filename string is used to construct a shell command. This vulnerability can be abused by a malicious authenticated user to execute arbitrary commands by tweaking the original filename of the STIX import.", "other": {"cve": {"id": "CVE-2018-19908", "sourceIdentifier": "cve@mitre.org", "published": "2018-12-06T16:29:00.290", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in MISP 2.4.9x before 2.4.99. In app/Model/Event.php (the STIX 1 import code), an unescaped filename string is used to construct a shell command. This vulnerability can be abused by a malicious authenticated user to execute arbitrary commands by tweaking the original filename of the STIX import."}, {"lang": "es", "value": "Vulnerabilidad de escalado de privilegios en Microsoft Windows Client en McAfee True Key (TK) 5.1.230.7 permite que usuarios locales ejecuten c\u00f3digo arbitrario mediante malware especialmente manipulado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:C/I:C/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 9.0}, "baseSeverity": "HIGH", "exploitabilityScore": 8.0, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-78"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:misp:misp:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.4.90", "versionEndExcluding": "2.4.99", "matchCriteriaId": "B9A76AD5-52DF-480E-971C-FEEE8A54DE41"}]}]}], "references": [{"url": "https://github.com/MISP/MISP/commit/211ac0737281b65e7da160f0aac52f401a94e1a3", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/MISP/MISP/releases/tag/v2.4.99", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://www.exploit-db.com/exploits/46401/", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory", "VDB Entry"]}]}, "github_commit_url": "https://github.com/MISP/MISP/commit/211ac0737281b65e7da160f0aac52f401a94e1a3"}}