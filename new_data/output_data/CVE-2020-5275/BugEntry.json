{"buggy_code": ["<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Security\\Core\\Authorization;\n\nuse Symfony\\Component\\Security\\Core\\Authentication\\Token\\TokenInterface;\nuse Symfony\\Component\\Security\\Core\\Authorization\\Voter\\VoterInterface;\n\n/**\n * AccessDecisionManager is the base class for all access decision managers\n * that use decision voters.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n */\nclass AccessDecisionManager implements AccessDecisionManagerInterface\n{\n    const STRATEGY_AFFIRMATIVE = 'affirmative';\n    const STRATEGY_CONSENSUS = 'consensus';\n    const STRATEGY_UNANIMOUS = 'unanimous';\n\n    private $voters;\n    private $strategy;\n    private $allowIfAllAbstainDecisions;\n    private $allowIfEqualGrantedDeniedDecisions;\n\n    /**\n     * @param iterable|VoterInterface[] $voters                             An array or an iterator of VoterInterface instances\n     * @param string                    $strategy                           The vote strategy\n     * @param bool                      $allowIfAllAbstainDecisions         Whether to grant access if all voters abstained or not\n     * @param bool                      $allowIfEqualGrantedDeniedDecisions Whether to grant access if result are equals\n     *\n     * @throws \\InvalidArgumentException\n     */\n    public function __construct(iterable $voters = [], string $strategy = self::STRATEGY_AFFIRMATIVE, bool $allowIfAllAbstainDecisions = false, bool $allowIfEqualGrantedDeniedDecisions = true)\n    {\n        $strategyMethod = 'decide'.ucfirst($strategy);\n        if ('' === $strategy || !\\is_callable([$this, $strategyMethod])) {\n            throw new \\InvalidArgumentException(sprintf('The strategy \"%s\" is not supported.', $strategy));\n        }\n\n        $this->voters = $voters;\n        $this->strategy = $strategyMethod;\n        $this->allowIfAllAbstainDecisions = $allowIfAllAbstainDecisions;\n        $this->allowIfEqualGrantedDeniedDecisions = $allowIfEqualGrantedDeniedDecisions;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function decide(TokenInterface $token, array $attributes, $object = null)\n    {\n        if (\\count($attributes) > 1) {\n            @trigger_error(sprintf('Passing more than one Security attribute to \"%s()\" is deprecated since Symfony 4.4. Use multiple \"decide()\" calls or the expression language (e.g. \"is_granted(...) or is_granted(...)\") instead.', __METHOD__), E_USER_DEPRECATED);\n        }\n\n        return $this->{$this->strategy}($token, $attributes, $object);\n    }\n\n    /**\n     * Grants access if any voter returns an affirmative response.\n     *\n     * If all voters abstained from voting, the decision will be based on the\n     * allowIfAllAbstainDecisions property value (defaults to false).\n     */\n    private function decideAffirmative(TokenInterface $token, array $attributes, $object = null): bool\n    {\n        $deny = 0;\n        foreach ($this->voters as $voter) {\n            $result = $voter->vote($token, $object, $attributes);\n\n            if (VoterInterface::ACCESS_GRANTED === $result) {\n                return true;\n            }\n\n            if (VoterInterface::ACCESS_DENIED === $result) {\n                ++$deny;\n            }\n        }\n\n        if ($deny > 0) {\n            return false;\n        }\n\n        return $this->allowIfAllAbstainDecisions;\n    }\n\n    /**\n     * Grants access if there is consensus of granted against denied responses.\n     *\n     * Consensus means majority-rule (ignoring abstains) rather than unanimous\n     * agreement (ignoring abstains). If you require unanimity, see\n     * UnanimousBased.\n     *\n     * If there were an equal number of grant and deny votes, the decision will\n     * be based on the allowIfEqualGrantedDeniedDecisions property value\n     * (defaults to true).\n     *\n     * If all voters abstained from voting, the decision will be based on the\n     * allowIfAllAbstainDecisions property value (defaults to false).\n     */\n    private function decideConsensus(TokenInterface $token, array $attributes, $object = null): bool\n    {\n        $grant = 0;\n        $deny = 0;\n        foreach ($this->voters as $voter) {\n            $result = $voter->vote($token, $object, $attributes);\n\n            if (VoterInterface::ACCESS_GRANTED === $result) {\n                ++$grant;\n            } elseif (VoterInterface::ACCESS_DENIED === $result) {\n                ++$deny;\n            }\n        }\n\n        if ($grant > $deny) {\n            return true;\n        }\n\n        if ($deny > $grant) {\n            return false;\n        }\n\n        if ($grant > 0) {\n            return $this->allowIfEqualGrantedDeniedDecisions;\n        }\n\n        return $this->allowIfAllAbstainDecisions;\n    }\n\n    /**\n     * Grants access if only grant (or abstain) votes were received.\n     *\n     * If all voters abstained from voting, the decision will be based on the\n     * allowIfAllAbstainDecisions property value (defaults to false).\n     */\n    private function decideUnanimous(TokenInterface $token, array $attributes, $object = null): bool\n    {\n        $grant = 0;\n        foreach ($this->voters as $voter) {\n            foreach ($attributes as $attribute) {\n                $result = $voter->vote($token, $object, [$attribute]);\n\n                if (VoterInterface::ACCESS_DENIED === $result) {\n                    return false;\n                }\n\n                if (VoterInterface::ACCESS_GRANTED === $result) {\n                    ++$grant;\n                }\n            }\n        }\n\n        // no deny votes\n        if ($grant > 0) {\n            return true;\n        }\n\n        return $this->allowIfAllAbstainDecisions;\n    }\n}\n", "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Security\\Http\\Firewall;\n\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpKernel\\Event\\RequestEvent;\nuse Symfony\\Component\\Security\\Core\\Authentication\\AuthenticationManagerInterface;\nuse Symfony\\Component\\Security\\Core\\Authentication\\Token\\Storage\\TokenStorageInterface;\nuse Symfony\\Component\\Security\\Core\\Authorization\\AccessDecisionManagerInterface;\nuse Symfony\\Component\\Security\\Core\\Authorization\\Voter\\AuthenticatedVoter;\nuse Symfony\\Component\\Security\\Core\\Exception\\AccessDeniedException;\nuse Symfony\\Component\\Security\\Core\\Exception\\AuthenticationCredentialsNotFoundException;\nuse Symfony\\Component\\Security\\Http\\AccessMapInterface;\nuse Symfony\\Component\\Security\\Http\\Event\\LazyResponseEvent;\n\n/**\n * AccessListener enforces access control rules.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n *\n * @final since Symfony 4.3\n */\nclass AccessListener extends AbstractListener implements ListenerInterface\n{\n    use LegacyListenerTrait;\n\n    private $tokenStorage;\n    private $accessDecisionManager;\n    private $map;\n    private $authManager;\n\n    public function __construct(TokenStorageInterface $tokenStorage, AccessDecisionManagerInterface $accessDecisionManager, AccessMapInterface $map, AuthenticationManagerInterface $authManager)\n    {\n        $this->tokenStorage = $tokenStorage;\n        $this->accessDecisionManager = $accessDecisionManager;\n        $this->map = $map;\n        $this->authManager = $authManager;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function supports(Request $request): ?bool\n    {\n        [$attributes] = $this->map->getPatterns($request);\n        $request->attributes->set('_access_control_attributes', $attributes);\n\n        return $attributes && [AuthenticatedVoter::IS_AUTHENTICATED_ANONYMOUSLY] !== $attributes ? true : null;\n    }\n\n    /**\n     * Handles access authorization.\n     *\n     * @throws AccessDeniedException\n     * @throws AuthenticationCredentialsNotFoundException\n     */\n    public function authenticate(RequestEvent $event)\n    {\n        if (!$event instanceof LazyResponseEvent && null === $token = $this->tokenStorage->getToken()) {\n            throw new AuthenticationCredentialsNotFoundException('A Token was not found in the TokenStorage.');\n        }\n\n        $request = $event->getRequest();\n\n        $attributes = $request->attributes->get('_access_control_attributes');\n        $request->attributes->remove('_access_control_attributes');\n\n        if (!$attributes || ([AuthenticatedVoter::IS_AUTHENTICATED_ANONYMOUSLY] === $attributes && $event instanceof LazyResponseEvent)) {\n            return;\n        }\n\n        if ($event instanceof LazyResponseEvent && null === $token = $this->tokenStorage->getToken()) {\n            throw new AuthenticationCredentialsNotFoundException('A Token was not found in the TokenStorage.');\n        }\n\n        if (!$token->isAuthenticated()) {\n            $token = $this->authManager->authenticate($token);\n            $this->tokenStorage->setToken($token);\n        }\n\n        $granted = false;\n        foreach ($attributes as $key => $value) {\n            if ($this->accessDecisionManager->decide($token, [$key => $value], $request)) {\n                $granted = true;\n                break;\n            }\n        }\n\n        if (!$granted) {\n            $exception = new AccessDeniedException();\n            $exception->setAttributes($attributes);\n            $exception->setSubject($request);\n\n            throw $exception;\n        }\n    }\n}\n", "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Security\\Http\\Tests\\Firewall;\n\nuse PHPUnit\\Framework\\TestCase;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpKernel\\Event\\RequestEvent;\nuse Symfony\\Component\\HttpKernel\\HttpKernelInterface;\nuse Symfony\\Component\\Security\\Core\\Authentication\\AuthenticationManagerInterface;\nuse Symfony\\Component\\Security\\Core\\Authentication\\Token\\Storage\\TokenStorageInterface;\nuse Symfony\\Component\\Security\\Core\\Authorization\\AccessDecisionManagerInterface;\nuse Symfony\\Component\\Security\\Http\\AccessMapInterface;\nuse Symfony\\Component\\Security\\Http\\Event\\LazyResponseEvent;\nuse Symfony\\Component\\Security\\Http\\Firewall\\AccessListener;\n\nclass AccessListenerTest extends TestCase\n{\n    public function testHandleWhenTheAccessDecisionManagerDecidesToRefuseAccess()\n    {\n        $this->expectException('Symfony\\Component\\Security\\Core\\Exception\\AccessDeniedException');\n        $request = new Request();\n\n        $accessMap = $this->getMockBuilder('Symfony\\Component\\Security\\Http\\AccessMapInterface')->getMock();\n        $accessMap\n            ->expects($this->any())\n            ->method('getPatterns')\n            ->with($this->equalTo($request))\n            ->willReturn([['foo' => 'bar'], null])\n        ;\n\n        $token = $this->getMockBuilder('Symfony\\Component\\Security\\Core\\Authentication\\Token\\TokenInterface')->getMock();\n        $token\n            ->expects($this->any())\n            ->method('isAuthenticated')\n            ->willReturn(true)\n        ;\n\n        $tokenStorage = $this->getMockBuilder('Symfony\\Component\\Security\\Core\\Authentication\\Token\\Storage\\TokenStorageInterface')->getMock();\n        $tokenStorage\n            ->expects($this->any())\n            ->method('getToken')\n            ->willReturn($token)\n        ;\n\n        $accessDecisionManager = $this->getMockBuilder('Symfony\\Component\\Security\\Core\\Authorization\\AccessDecisionManagerInterface')->getMock();\n        $accessDecisionManager\n            ->expects($this->once())\n            ->method('decide')\n            ->with($this->equalTo($token), $this->equalTo(['foo' => 'bar']), $this->equalTo($request))\n            ->willReturn(false)\n        ;\n\n        $listener = new AccessListener(\n            $tokenStorage,\n            $accessDecisionManager,\n            $accessMap,\n            $this->getMockBuilder('Symfony\\Component\\Security\\Core\\Authentication\\AuthenticationManagerInterface')->getMock()\n        );\n\n        $listener(new RequestEvent($this->createMock(HttpKernelInterface::class), $request, HttpKernelInterface::MASTER_REQUEST));\n    }\n\n    public function testHandleWhenTheTokenIsNotAuthenticated()\n    {\n        $request = new Request();\n\n        $accessMap = $this->getMockBuilder('Symfony\\Component\\Security\\Http\\AccessMapInterface')->getMock();\n        $accessMap\n            ->expects($this->any())\n            ->method('getPatterns')\n            ->with($this->equalTo($request))\n            ->willReturn([['foo' => 'bar'], null])\n        ;\n\n        $notAuthenticatedToken = $this->getMockBuilder('Symfony\\Component\\Security\\Core\\Authentication\\Token\\TokenInterface')->getMock();\n        $notAuthenticatedToken\n            ->expects($this->any())\n            ->method('isAuthenticated')\n            ->willReturn(false)\n        ;\n\n        $authenticatedToken = $this->getMockBuilder('Symfony\\Component\\Security\\Core\\Authentication\\Token\\TokenInterface')->getMock();\n        $authenticatedToken\n            ->expects($this->any())\n            ->method('isAuthenticated')\n            ->willReturn(true)\n        ;\n\n        $authManager = $this->getMockBuilder('Symfony\\Component\\Security\\Core\\Authentication\\AuthenticationManagerInterface')->getMock();\n        $authManager\n            ->expects($this->once())\n            ->method('authenticate')\n            ->with($this->equalTo($notAuthenticatedToken))\n            ->willReturn($authenticatedToken)\n        ;\n\n        $tokenStorage = $this->getMockBuilder('Symfony\\Component\\Security\\Core\\Authentication\\Token\\Storage\\TokenStorageInterface')->getMock();\n        $tokenStorage\n            ->expects($this->any())\n            ->method('getToken')\n            ->willReturn($notAuthenticatedToken)\n        ;\n        $tokenStorage\n            ->expects($this->once())\n            ->method('setToken')\n            ->with($this->equalTo($authenticatedToken))\n        ;\n\n        $accessDecisionManager = $this->getMockBuilder('Symfony\\Component\\Security\\Core\\Authorization\\AccessDecisionManagerInterface')->getMock();\n        $accessDecisionManager\n            ->expects($this->once())\n            ->method('decide')\n            ->with($this->equalTo($authenticatedToken), $this->equalTo(['foo' => 'bar']), $this->equalTo($request))\n            ->willReturn(true)\n        ;\n\n        $listener = new AccessListener(\n            $tokenStorage,\n            $accessDecisionManager,\n            $accessMap,\n            $authManager\n        );\n\n        $listener(new RequestEvent($this->createMock(HttpKernelInterface::class), $request, HttpKernelInterface::MASTER_REQUEST));\n    }\n\n    public function testHandleWhenThereIsNoAccessMapEntryMatchingTheRequest()\n    {\n        $request = new Request();\n\n        $accessMap = $this->getMockBuilder('Symfony\\Component\\Security\\Http\\AccessMapInterface')->getMock();\n        $accessMap\n            ->expects($this->any())\n            ->method('getPatterns')\n            ->with($this->equalTo($request))\n            ->willReturn([null, null])\n        ;\n\n        $token = $this->getMockBuilder('Symfony\\Component\\Security\\Core\\Authentication\\Token\\TokenInterface')->getMock();\n        $token\n            ->expects($this->never())\n            ->method('isAuthenticated')\n        ;\n\n        $tokenStorage = $this->getMockBuilder('Symfony\\Component\\Security\\Core\\Authentication\\Token\\Storage\\TokenStorageInterface')->getMock();\n        $tokenStorage\n            ->expects($this->any())\n            ->method('getToken')\n            ->willReturn($token)\n        ;\n\n        $listener = new AccessListener(\n            $tokenStorage,\n            $this->getMockBuilder('Symfony\\Component\\Security\\Core\\Authorization\\AccessDecisionManagerInterface')->getMock(),\n            $accessMap,\n            $this->getMockBuilder('Symfony\\Component\\Security\\Core\\Authentication\\AuthenticationManagerInterface')->getMock()\n        );\n\n        $listener(new RequestEvent($this->createMock(HttpKernelInterface::class), $request, HttpKernelInterface::MASTER_REQUEST));\n    }\n\n    public function testHandleWhenAccessMapReturnsEmptyAttributes()\n    {\n        $request = new Request();\n\n        $accessMap = $this->getMockBuilder(AccessMapInterface::class)->getMock();\n        $accessMap\n            ->expects($this->any())\n            ->method('getPatterns')\n            ->with($this->equalTo($request))\n            ->willReturn([[], null])\n        ;\n\n        $tokenStorage = $this->getMockBuilder(TokenStorageInterface::class)->getMock();\n        $tokenStorage\n            ->expects($this->never())\n            ->method('getToken')\n        ;\n\n        $listener = new AccessListener(\n            $tokenStorage,\n            $this->getMockBuilder(AccessDecisionManagerInterface::class)->getMock(),\n            $accessMap,\n            $this->getMockBuilder(AuthenticationManagerInterface::class)->getMock()\n        );\n\n        $event = new RequestEvent($this->createMock(HttpKernelInterface::class), $request, HttpKernelInterface::MASTER_REQUEST);\n\n        $listener(new LazyResponseEvent($event));\n    }\n\n    public function testHandleWhenTheSecurityTokenStorageHasNoToken()\n    {\n        $this->expectException('Symfony\\Component\\Security\\Core\\Exception\\AuthenticationCredentialsNotFoundException');\n        $tokenStorage = $this->getMockBuilder('Symfony\\Component\\Security\\Core\\Authentication\\Token\\Storage\\TokenStorageInterface')->getMock();\n        $tokenStorage\n            ->expects($this->any())\n            ->method('getToken')\n            ->willReturn(null)\n        ;\n\n        $request = new Request();\n\n        $accessMap = $this->getMockBuilder(AccessMapInterface::class)->getMock();\n        $accessMap\n            ->expects($this->any())\n            ->method('getPatterns')\n            ->with($this->equalTo($request))\n            ->willReturn([['foo' => 'bar'], null])\n        ;\n\n        $listener = new AccessListener(\n            $tokenStorage,\n            $this->getMockBuilder('Symfony\\Component\\Security\\Core\\Authorization\\AccessDecisionManagerInterface')->getMock(),\n            $accessMap,\n            $this->getMockBuilder('Symfony\\Component\\Security\\Core\\Authentication\\AuthenticationManagerInterface')->getMock()\n        );\n\n        $listener(new RequestEvent($this->createMock(HttpKernelInterface::class), $request, HttpKernelInterface::MASTER_REQUEST));\n    }\n}\n", "{\n    \"name\": \"symfony/security-http\",\n    \"type\": \"library\",\n    \"description\": \"Symfony Security Component - HTTP Integration\",\n    \"keywords\": [],\n    \"homepage\": \"https://symfony.com\",\n    \"license\": \"MIT\",\n    \"authors\": [\n        {\n            \"name\": \"Fabien Potencier\",\n            \"email\": \"fabien@symfony.com\"\n        },\n        {\n            \"name\": \"Symfony Community\",\n            \"homepage\": \"https://symfony.com/contributors\"\n        }\n    ],\n    \"require\": {\n        \"php\": \"^7.1.3\",\n        \"symfony/security-core\": \"^4.4\",\n        \"symfony/http-foundation\": \"^3.4.40|^4.4.7|^5.0.7\",\n        \"symfony/http-kernel\": \"^4.4\",\n        \"symfony/property-access\": \"^3.4|^4.0|^5.0\"\n    },\n    \"require-dev\": {\n        \"symfony/routing\": \"^3.4|^4.0|^5.0\",\n        \"symfony/security-csrf\": \"^3.4.11|^4.0.11|^5.0\",\n        \"psr/log\": \"~1.0\"\n    },\n    \"conflict\": {\n        \"symfony/event-dispatcher\": \">=5\",\n        \"symfony/security-csrf\": \"<3.4.11|~4.0,<4.0.11\"\n    },\n    \"suggest\": {\n        \"symfony/security-csrf\": \"For using tokens to protect authentication/logout attempts\",\n        \"symfony/routing\": \"For using the HttpUtils class to create sub-requests, redirect the user, and match URLs\"\n    },\n    \"autoload\": {\n        \"psr-4\": { \"Symfony\\\\Component\\\\Security\\\\Http\\\\\": \"\" },\n        \"exclude-from-classmap\": [\n            \"/Tests/\"\n        ]\n    },\n    \"minimum-stability\": \"dev\",\n    \"extra\": {\n        \"branch-alias\": {\n            \"dev-master\": \"4.4-dev\"\n        }\n    }\n}\n"], "fixing_code": ["<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Security\\Core\\Authorization;\n\nuse Symfony\\Component\\Security\\Core\\Authentication\\Token\\TokenInterface;\nuse Symfony\\Component\\Security\\Core\\Authorization\\Voter\\VoterInterface;\n\n/**\n * AccessDecisionManager is the base class for all access decision managers\n * that use decision voters.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n */\nclass AccessDecisionManager implements AccessDecisionManagerInterface\n{\n    const STRATEGY_AFFIRMATIVE = 'affirmative';\n    const STRATEGY_CONSENSUS = 'consensus';\n    const STRATEGY_UNANIMOUS = 'unanimous';\n\n    private $voters;\n    private $strategy;\n    private $allowIfAllAbstainDecisions;\n    private $allowIfEqualGrantedDeniedDecisions;\n\n    /**\n     * @param iterable|VoterInterface[] $voters                             An array or an iterator of VoterInterface instances\n     * @param string                    $strategy                           The vote strategy\n     * @param bool                      $allowIfAllAbstainDecisions         Whether to grant access if all voters abstained or not\n     * @param bool                      $allowIfEqualGrantedDeniedDecisions Whether to grant access if result are equals\n     *\n     * @throws \\InvalidArgumentException\n     */\n    public function __construct(iterable $voters = [], string $strategy = self::STRATEGY_AFFIRMATIVE, bool $allowIfAllAbstainDecisions = false, bool $allowIfEqualGrantedDeniedDecisions = true)\n    {\n        $strategyMethod = 'decide'.ucfirst($strategy);\n        if ('' === $strategy || !\\is_callable([$this, $strategyMethod])) {\n            throw new \\InvalidArgumentException(sprintf('The strategy \"%s\" is not supported.', $strategy));\n        }\n\n        $this->voters = $voters;\n        $this->strategy = $strategyMethod;\n        $this->allowIfAllAbstainDecisions = $allowIfAllAbstainDecisions;\n        $this->allowIfEqualGrantedDeniedDecisions = $allowIfEqualGrantedDeniedDecisions;\n    }\n\n    /**\n     * @param bool $allowMultipleAttributes Whether to allow passing multiple values to the $attributes array\n     *\n     * {@inheritdoc}\n     */\n    public function decide(TokenInterface $token, array $attributes, $object = null/*, bool $allowMultipleAttributes = false*/)\n    {\n        $allowMultipleAttributes =  3 < func_num_args() && func_get_arg(3);\n\n        // Special case for AccessListener, do not remove the right side of the condition before 6.0\n        if (\\count($attributes) > 1 && !$allowMultipleAttributes) {\n            @trigger_error(sprintf('Passing more than one Security attribute to \"%s()\" is deprecated since Symfony 4.4. Use multiple \"decide()\" calls or the expression language (e.g. \"is_granted(...) or is_granted(...)\") instead.', __METHOD__), E_USER_DEPRECATED);\n        }\n\n        return $this->{$this->strategy}($token, $attributes, $object);\n    }\n\n    /**\n     * Grants access if any voter returns an affirmative response.\n     *\n     * If all voters abstained from voting, the decision will be based on the\n     * allowIfAllAbstainDecisions property value (defaults to false).\n     */\n    private function decideAffirmative(TokenInterface $token, array $attributes, $object = null): bool\n    {\n        $deny = 0;\n        foreach ($this->voters as $voter) {\n            $result = $voter->vote($token, $object, $attributes);\n\n            if (VoterInterface::ACCESS_GRANTED === $result) {\n                return true;\n            }\n\n            if (VoterInterface::ACCESS_DENIED === $result) {\n                ++$deny;\n            }\n        }\n\n        if ($deny > 0) {\n            return false;\n        }\n\n        return $this->allowIfAllAbstainDecisions;\n    }\n\n    /**\n     * Grants access if there is consensus of granted against denied responses.\n     *\n     * Consensus means majority-rule (ignoring abstains) rather than unanimous\n     * agreement (ignoring abstains). If you require unanimity, see\n     * UnanimousBased.\n     *\n     * If there were an equal number of grant and deny votes, the decision will\n     * be based on the allowIfEqualGrantedDeniedDecisions property value\n     * (defaults to true).\n     *\n     * If all voters abstained from voting, the decision will be based on the\n     * allowIfAllAbstainDecisions property value (defaults to false).\n     */\n    private function decideConsensus(TokenInterface $token, array $attributes, $object = null): bool\n    {\n        $grant = 0;\n        $deny = 0;\n        foreach ($this->voters as $voter) {\n            $result = $voter->vote($token, $object, $attributes);\n\n            if (VoterInterface::ACCESS_GRANTED === $result) {\n                ++$grant;\n            } elseif (VoterInterface::ACCESS_DENIED === $result) {\n                ++$deny;\n            }\n        }\n\n        if ($grant > $deny) {\n            return true;\n        }\n\n        if ($deny > $grant) {\n            return false;\n        }\n\n        if ($grant > 0) {\n            return $this->allowIfEqualGrantedDeniedDecisions;\n        }\n\n        return $this->allowIfAllAbstainDecisions;\n    }\n\n    /**\n     * Grants access if only grant (or abstain) votes were received.\n     *\n     * If all voters abstained from voting, the decision will be based on the\n     * allowIfAllAbstainDecisions property value (defaults to false).\n     */\n    private function decideUnanimous(TokenInterface $token, array $attributes, $object = null): bool\n    {\n        $grant = 0;\n        foreach ($this->voters as $voter) {\n            foreach ($attributes as $attribute) {\n                $result = $voter->vote($token, $object, [$attribute]);\n\n                if (VoterInterface::ACCESS_DENIED === $result) {\n                    return false;\n                }\n\n                if (VoterInterface::ACCESS_GRANTED === $result) {\n                    ++$grant;\n                }\n            }\n        }\n\n        // no deny votes\n        if ($grant > 0) {\n            return true;\n        }\n\n        return $this->allowIfAllAbstainDecisions;\n    }\n}\n", "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Security\\Http\\Firewall;\n\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpKernel\\Event\\RequestEvent;\nuse Symfony\\Component\\Security\\Core\\Authentication\\AuthenticationManagerInterface;\nuse Symfony\\Component\\Security\\Core\\Authentication\\Token\\Storage\\TokenStorageInterface;\nuse Symfony\\Component\\Security\\Core\\Authorization\\AccessDecisionManagerInterface;\nuse Symfony\\Component\\Security\\Core\\Authorization\\Voter\\AuthenticatedVoter;\nuse Symfony\\Component\\Security\\Core\\Exception\\AccessDeniedException;\nuse Symfony\\Component\\Security\\Core\\Exception\\AuthenticationCredentialsNotFoundException;\nuse Symfony\\Component\\Security\\Http\\AccessMapInterface;\nuse Symfony\\Component\\Security\\Http\\Event\\LazyResponseEvent;\n\n/**\n * AccessListener enforces access control rules.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n *\n * @final since Symfony 4.3\n */\nclass AccessListener extends AbstractListener implements ListenerInterface\n{\n    use LegacyListenerTrait;\n\n    private $tokenStorage;\n    private $accessDecisionManager;\n    private $map;\n    private $authManager;\n\n    public function __construct(TokenStorageInterface $tokenStorage, AccessDecisionManagerInterface $accessDecisionManager, AccessMapInterface $map, AuthenticationManagerInterface $authManager)\n    {\n        $this->tokenStorage = $tokenStorage;\n        $this->accessDecisionManager = $accessDecisionManager;\n        $this->map = $map;\n        $this->authManager = $authManager;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function supports(Request $request): ?bool\n    {\n        [$attributes] = $this->map->getPatterns($request);\n        $request->attributes->set('_access_control_attributes', $attributes);\n\n        return $attributes && [AuthenticatedVoter::IS_AUTHENTICATED_ANONYMOUSLY] !== $attributes ? true : null;\n    }\n\n    /**\n     * Handles access authorization.\n     *\n     * @throws AccessDeniedException\n     * @throws AuthenticationCredentialsNotFoundException\n     */\n    public function authenticate(RequestEvent $event)\n    {\n        if (!$event instanceof LazyResponseEvent && null === $token = $this->tokenStorage->getToken()) {\n            throw new AuthenticationCredentialsNotFoundException('A Token was not found in the TokenStorage.');\n        }\n\n        $request = $event->getRequest();\n\n        $attributes = $request->attributes->get('_access_control_attributes');\n        $request->attributes->remove('_access_control_attributes');\n\n        if (!$attributes || ([AuthenticatedVoter::IS_AUTHENTICATED_ANONYMOUSLY] === $attributes && $event instanceof LazyResponseEvent)) {\n            return;\n        }\n\n        if ($event instanceof LazyResponseEvent && null === $token = $this->tokenStorage->getToken()) {\n            throw new AuthenticationCredentialsNotFoundException('A Token was not found in the TokenStorage.');\n        }\n\n        if (!$token->isAuthenticated()) {\n            $token = $this->authManager->authenticate($token);\n            $this->tokenStorage->setToken($token);\n        }\n\n        if (!$this->accessDecisionManager->decide($token, $attributes, $request, true)) {\n            $exception = new AccessDeniedException();\n            $exception->setAttributes($attributes);\n            $exception->setSubject($request);\n\n            throw $exception;\n        }\n    }\n}\n", "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Security\\Http\\Tests\\Firewall;\n\nuse PHPUnit\\Framework\\TestCase;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpKernel\\Event\\RequestEvent;\nuse Symfony\\Component\\HttpKernel\\HttpKernelInterface;\nuse Symfony\\Component\\Security\\Core\\Authentication\\AuthenticationManagerInterface;\nuse Symfony\\Component\\Security\\Core\\Authentication\\Token\\Storage\\TokenStorage;\nuse Symfony\\Component\\Security\\Core\\Authentication\\Token\\Storage\\TokenStorageInterface;\nuse Symfony\\Component\\Security\\Core\\Authorization\\AccessDecisionManagerInterface;\nuse Symfony\\Component\\Security\\Http\\AccessMapInterface;\nuse Symfony\\Component\\Security\\Http\\Event\\LazyResponseEvent;\nuse Symfony\\Component\\Security\\Http\\Firewall\\AccessListener;\n\nclass AccessListenerTest extends TestCase\n{\n    public function testHandleWhenTheAccessDecisionManagerDecidesToRefuseAccess()\n    {\n        $this->expectException('Symfony\\Component\\Security\\Core\\Exception\\AccessDeniedException');\n        $request = new Request();\n\n        $accessMap = $this->getMockBuilder('Symfony\\Component\\Security\\Http\\AccessMapInterface')->getMock();\n        $accessMap\n            ->expects($this->any())\n            ->method('getPatterns')\n            ->with($this->equalTo($request))\n            ->willReturn([['foo' => 'bar'], null])\n        ;\n\n        $token = $this->getMockBuilder('Symfony\\Component\\Security\\Core\\Authentication\\Token\\TokenInterface')->getMock();\n        $token\n            ->expects($this->any())\n            ->method('isAuthenticated')\n            ->willReturn(true)\n        ;\n\n        $tokenStorage = $this->getMockBuilder('Symfony\\Component\\Security\\Core\\Authentication\\Token\\Storage\\TokenStorageInterface')->getMock();\n        $tokenStorage\n            ->expects($this->any())\n            ->method('getToken')\n            ->willReturn($token)\n        ;\n\n        $accessDecisionManager = $this->getMockBuilder('Symfony\\Component\\Security\\Core\\Authorization\\AccessDecisionManagerInterface')->getMock();\n        $accessDecisionManager\n            ->expects($this->once())\n            ->method('decide')\n            ->with($this->equalTo($token), $this->equalTo(['foo' => 'bar']), $this->equalTo($request))\n            ->willReturn(false)\n        ;\n\n        $listener = new AccessListener(\n            $tokenStorage,\n            $accessDecisionManager,\n            $accessMap,\n            $this->getMockBuilder('Symfony\\Component\\Security\\Core\\Authentication\\AuthenticationManagerInterface')->getMock()\n        );\n\n        $listener(new RequestEvent($this->createMock(HttpKernelInterface::class), $request, HttpKernelInterface::MASTER_REQUEST));\n    }\n\n    public function testHandleWhenTheTokenIsNotAuthenticated()\n    {\n        $request = new Request();\n\n        $accessMap = $this->getMockBuilder('Symfony\\Component\\Security\\Http\\AccessMapInterface')->getMock();\n        $accessMap\n            ->expects($this->any())\n            ->method('getPatterns')\n            ->with($this->equalTo($request))\n            ->willReturn([['foo' => 'bar'], null])\n        ;\n\n        $notAuthenticatedToken = $this->getMockBuilder('Symfony\\Component\\Security\\Core\\Authentication\\Token\\TokenInterface')->getMock();\n        $notAuthenticatedToken\n            ->expects($this->any())\n            ->method('isAuthenticated')\n            ->willReturn(false)\n        ;\n\n        $authenticatedToken = $this->getMockBuilder('Symfony\\Component\\Security\\Core\\Authentication\\Token\\TokenInterface')->getMock();\n        $authenticatedToken\n            ->expects($this->any())\n            ->method('isAuthenticated')\n            ->willReturn(true)\n        ;\n\n        $authManager = $this->getMockBuilder('Symfony\\Component\\Security\\Core\\Authentication\\AuthenticationManagerInterface')->getMock();\n        $authManager\n            ->expects($this->once())\n            ->method('authenticate')\n            ->with($this->equalTo($notAuthenticatedToken))\n            ->willReturn($authenticatedToken)\n        ;\n\n        $tokenStorage = $this->getMockBuilder('Symfony\\Component\\Security\\Core\\Authentication\\Token\\Storage\\TokenStorageInterface')->getMock();\n        $tokenStorage\n            ->expects($this->any())\n            ->method('getToken')\n            ->willReturn($notAuthenticatedToken)\n        ;\n        $tokenStorage\n            ->expects($this->once())\n            ->method('setToken')\n            ->with($this->equalTo($authenticatedToken))\n        ;\n\n        $accessDecisionManager = $this->getMockBuilder('Symfony\\Component\\Security\\Core\\Authorization\\AccessDecisionManagerInterface')->getMock();\n        $accessDecisionManager\n            ->expects($this->once())\n            ->method('decide')\n            ->with($this->equalTo($authenticatedToken), $this->equalTo(['foo' => 'bar']), $this->equalTo($request))\n            ->willReturn(true)\n        ;\n\n        $listener = new AccessListener(\n            $tokenStorage,\n            $accessDecisionManager,\n            $accessMap,\n            $authManager\n        );\n\n        $listener(new RequestEvent($this->createMock(HttpKernelInterface::class), $request, HttpKernelInterface::MASTER_REQUEST));\n    }\n\n    public function testHandleWhenThereIsNoAccessMapEntryMatchingTheRequest()\n    {\n        $request = new Request();\n\n        $accessMap = $this->getMockBuilder('Symfony\\Component\\Security\\Http\\AccessMapInterface')->getMock();\n        $accessMap\n            ->expects($this->any())\n            ->method('getPatterns')\n            ->with($this->equalTo($request))\n            ->willReturn([null, null])\n        ;\n\n        $token = $this->getMockBuilder('Symfony\\Component\\Security\\Core\\Authentication\\Token\\TokenInterface')->getMock();\n        $token\n            ->expects($this->never())\n            ->method('isAuthenticated')\n        ;\n\n        $tokenStorage = $this->getMockBuilder('Symfony\\Component\\Security\\Core\\Authentication\\Token\\Storage\\TokenStorageInterface')->getMock();\n        $tokenStorage\n            ->expects($this->any())\n            ->method('getToken')\n            ->willReturn($token)\n        ;\n\n        $listener = new AccessListener(\n            $tokenStorage,\n            $this->getMockBuilder('Symfony\\Component\\Security\\Core\\Authorization\\AccessDecisionManagerInterface')->getMock(),\n            $accessMap,\n            $this->getMockBuilder('Symfony\\Component\\Security\\Core\\Authentication\\AuthenticationManagerInterface')->getMock()\n        );\n\n        $listener(new RequestEvent($this->createMock(HttpKernelInterface::class), $request, HttpKernelInterface::MASTER_REQUEST));\n    }\n\n    public function testHandleWhenAccessMapReturnsEmptyAttributes()\n    {\n        $request = new Request();\n\n        $accessMap = $this->getMockBuilder(AccessMapInterface::class)->getMock();\n        $accessMap\n            ->expects($this->any())\n            ->method('getPatterns')\n            ->with($this->equalTo($request))\n            ->willReturn([[], null])\n        ;\n\n        $tokenStorage = $this->getMockBuilder(TokenStorageInterface::class)->getMock();\n        $tokenStorage\n            ->expects($this->never())\n            ->method('getToken')\n        ;\n\n        $listener = new AccessListener(\n            $tokenStorage,\n            $this->getMockBuilder(AccessDecisionManagerInterface::class)->getMock(),\n            $accessMap,\n            $this->getMockBuilder(AuthenticationManagerInterface::class)->getMock()\n        );\n\n        $event = new RequestEvent($this->createMock(HttpKernelInterface::class), $request, HttpKernelInterface::MASTER_REQUEST);\n\n        $listener(new LazyResponseEvent($event));\n    }\n\n    public function testHandleWhenTheSecurityTokenStorageHasNoToken()\n    {\n        $this->expectException('Symfony\\Component\\Security\\Core\\Exception\\AuthenticationCredentialsNotFoundException');\n        $tokenStorage = $this->getMockBuilder('Symfony\\Component\\Security\\Core\\Authentication\\Token\\Storage\\TokenStorageInterface')->getMock();\n        $tokenStorage\n            ->expects($this->any())\n            ->method('getToken')\n            ->willReturn(null)\n        ;\n\n        $request = new Request();\n\n        $accessMap = $this->getMockBuilder(AccessMapInterface::class)->getMock();\n        $accessMap\n            ->expects($this->any())\n            ->method('getPatterns')\n            ->with($this->equalTo($request))\n            ->willReturn([['foo' => 'bar'], null])\n        ;\n\n        $listener = new AccessListener(\n            $tokenStorage,\n            $this->getMockBuilder('Symfony\\Component\\Security\\Core\\Authorization\\AccessDecisionManagerInterface')->getMock(),\n            $accessMap,\n            $this->getMockBuilder('Symfony\\Component\\Security\\Core\\Authentication\\AuthenticationManagerInterface')->getMock()\n        );\n\n        $listener(new RequestEvent($this->createMock(HttpKernelInterface::class), $request, HttpKernelInterface::MASTER_REQUEST));\n    }\n\n    public function testHandleMWithultipleAttributesShouldBeHandledAsAnd()\n    {\n        $request = new Request();\n\n        $accessMap = $this->getMockBuilder('Symfony\\Component\\Security\\Http\\AccessMapInterface')->getMock();\n        $accessMap\n            ->expects($this->any())\n            ->method('getPatterns')\n            ->with($this->equalTo($request))\n            ->willReturn([['foo' => 'bar', 'bar' => 'baz'], null])\n        ;\n\n        $authenticatedToken = $this->getMockBuilder('Symfony\\Component\\Security\\Core\\Authentication\\Token\\TokenInterface')->getMock();\n        $authenticatedToken\n            ->expects($this->any())\n            ->method('isAuthenticated')\n            ->willReturn(true)\n        ;\n\n        $tokenStorage = new TokenStorage();\n        $tokenStorage->setToken($authenticatedToken);\n\n        $accessDecisionManager = $this->getMockBuilder('Symfony\\Component\\Security\\Core\\Authorization\\AccessDecisionManagerInterface')->getMock();\n        $accessDecisionManager\n            ->expects($this->once())\n            ->method('decide')\n            ->with($this->equalTo($authenticatedToken), $this->equalTo(['foo' => 'bar', 'bar' => 'baz']), $this->equalTo($request), true)\n            ->willReturn(true)\n        ;\n\n        $listener = new AccessListener(\n            $tokenStorage,\n            $accessDecisionManager,\n            $accessMap,\n            $this->createMock('Symfony\\Component\\Security\\Core\\Authentication\\AuthenticationManagerInterface')\n        );\n\n        $listener(new RequestEvent($this->createMock(HttpKernelInterface::class), $request, HttpKernelInterface::MASTER_REQUEST));\n    }\n}\n", "{\n    \"name\": \"symfony/security-http\",\n    \"type\": \"library\",\n    \"description\": \"Symfony Security Component - HTTP Integration\",\n    \"keywords\": [],\n    \"homepage\": \"https://symfony.com\",\n    \"license\": \"MIT\",\n    \"authors\": [\n        {\n            \"name\": \"Fabien Potencier\",\n            \"email\": \"fabien@symfony.com\"\n        },\n        {\n            \"name\": \"Symfony Community\",\n            \"homepage\": \"https://symfony.com/contributors\"\n        }\n    ],\n    \"require\": {\n        \"php\": \"^7.1.3\",\n        \"symfony/security-core\": \"^4.4.7\",\n        \"symfony/http-foundation\": \"^3.4.40|^4.4.7|^5.0.7\",\n        \"symfony/http-kernel\": \"^4.4\",\n        \"symfony/property-access\": \"^3.4|^4.0|^5.0\"\n    },\n    \"require-dev\": {\n        \"symfony/routing\": \"^3.4|^4.0|^5.0\",\n        \"symfony/security-csrf\": \"^3.4.11|^4.0.11|^5.0\",\n        \"psr/log\": \"~1.0\"\n    },\n    \"conflict\": {\n        \"symfony/event-dispatcher\": \">=5\",\n        \"symfony/security-csrf\": \"<3.4.11|~4.0,<4.0.11\"\n    },\n    \"suggest\": {\n        \"symfony/security-csrf\": \"For using tokens to protect authentication/logout attempts\",\n        \"symfony/routing\": \"For using the HttpUtils class to create sub-requests, redirect the user, and match URLs\"\n    },\n    \"autoload\": {\n        \"psr-4\": { \"Symfony\\\\Component\\\\Security\\\\Http\\\\\": \"\" },\n        \"exclude-from-classmap\": [\n            \"/Tests/\"\n        ]\n    },\n    \"minimum-stability\": \"dev\",\n    \"extra\": {\n        \"branch-alias\": {\n            \"dev-master\": \"4.4-dev\"\n        }\n    }\n}\n"], "filenames": ["src/Symfony/Component/Security/Core/Authorization/AccessDecisionManager.php", "src/Symfony/Component/Security/Http/Firewall/AccessListener.php", "src/Symfony/Component/Security/Http/Tests/Firewall/AccessListenerTest.php", "src/Symfony/Component/Security/Http/composer.json"], "buggy_code_start_loc": [55, 90, 18, 20], "buggy_code_end_loc": [61, 99, 229, 21], "fixing_code_start_loc": [56, 90, 19, 20], "fixing_code_end_loc": [66, 91, 271, 21], "type": "CWE-863", "message": "In symfony/security-http before versions 4.4.7 and 5.0.7, when a `Firewall` checks access control rule, it iterate overs each rule's attributes and stops as soon as the accessDecisionManager decides to grant access on the attribute, preventing the check of next attributes that should have been take into account in an unanimous strategy. The accessDecisionManager is now called with all attributes at once, allowing the unanimous strategy being applied on each attribute. This issue is patched in versions 4.4.7 and 5.0.7.", "other": {"cve": {"id": "CVE-2020-5275", "sourceIdentifier": "security-advisories@github.com", "published": "2020-03-30T20:15:19.837", "lastModified": "2020-04-09T17:15:13.343", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "In symfony/security-http before versions 4.4.7 and 5.0.7, when a `Firewall` checks access control rule, it iterate overs each rule's attributes and stops as soon as the accessDecisionManager decides to grant access on the attribute, preventing the check of next attributes that should have been take into account in an unanimous strategy. The accessDecisionManager is now called with all attributes at once, allowing the unanimous strategy being applied on each attribute. This issue is patched in versions 4.4.7 and 5.0.7."}, {"lang": "es", "value": "En symfony/security-http versiones anteriores a 4.4.7 y 5.0.7, cuando un \"Firewall\" comprueba la regla de control de acceso, itera sobre los atributos de cada regla y se detiene tan pronto como accessDecisionManager decide otorgar acceso sobre el atributo, impidiendo la comprobaci\u00f3n de los siguientes atributos que deber\u00edan haberse tenido en cuenta en una estrategia un\u00e1nime. AccessDecisionManager es ahora llamado con todos los atributos a la vez, permitiendo que la estrategia un\u00e1nime  sea aplicada en cada atributo. Este problema est\u00e1 parcheado en las versiones 4.4.7 y 5.0.7."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.2}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:H/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 7.6, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.3, "impactScore": 4.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-863"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-285"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:sensiolabs:symfony:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.4.0", "versionEndExcluding": "4.4.7", "matchCriteriaId": "95F04BAB-4B76-4142-B000-67FA0A9F73F4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sensiolabs:symfony:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.0.0", "versionEndExcluding": "5.0.7", "matchCriteriaId": "A656BCAC-1974-4E5D-B7E3-4162A6153A4B"}]}]}], "references": [{"url": "https://github.com/symfony/symfony/commit/c935e4a3fba6cc2ab463a6ca382858068d63cebf", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/symfony/symfony/security/advisories/GHSA-g4m9-5hpf-hx72", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/C36JLPHUPKDFAX6D5WYFC4ALO2K7RDUQ/", "source": "security-advisories@github.com"}]}, "github_commit_url": "https://github.com/symfony/symfony/commit/c935e4a3fba6cc2ab463a6ca382858068d63cebf"}}