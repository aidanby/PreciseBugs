{"buggy_code": ["/*\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that: (1) source code\n * distributions retain the above copyright notice and this paragraph\n * in its entirety, and (2) distributions including binary code include\n * the above copyright notice and this paragraph in its entirety in\n * the documentation or other materials provided with the distribution.\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND\n * WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, WITHOUT\n * LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n * FOR A PARTICULAR PURPOSE.\n *\n * Original code by Hannes Gredler (hannes@gredler.at)\n * Support for LMP service discovery extensions (defined by OIF UNI 1.0)\n * added by Manu Pathak (mapathak@cisco.com), May 2005\n */\n\n/* \\summary: Link Management Protocol (LMP) printer */\n\n/* specification: RFC 4204 */\n/* OIF UNI 1.0: http://www.oiforum.com/public/documents/OIF-UNI-01.0.pdf */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <netdissect-stdinc.h>\n\n#include \"netdissect.h\"\n#include \"extract.h\"\n#include \"addrtoname.h\"\n#include \"gmpls.h\"\n\n/*\n * LMP common header\n *\n *  0                   1                   2                   3\n *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n * | Vers  |      (Reserved)       |    Flags      |    Msg Type   |\n * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n * |          LMP Length           |          (Reserved)           |\n * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n */\n\nstruct lmp_common_header {\n    uint8_t version_res[2];\n    uint8_t flags;\n    uint8_t msg_type;\n    uint8_t length[2];\n    uint8_t reserved[2];\n};\n\n#define LMP_VERSION            1\n#define\tLMP_EXTRACT_VERSION(x) (((x)&0xf0)>>4)\n\nstatic const struct tok lmp_header_flag_values[] = {\n    { 0x01, \"Control Channel Down\"},\n    { 0x02, \"LMP restart\"},\n    { 0, NULL}\n};\n\nstatic const struct tok lmp_obj_te_link_flag_values[] = {\n    { 0x01, \"Fault Management Supported\"},\n    { 0x02, \"Link Verification Supported\"},\n    { 0, NULL}\n};\n\nstatic const struct tok lmp_obj_data_link_flag_values[] = {\n    { 0x01, \"Data Link Port\"},\n    { 0x02, \"Allocated for user traffic\"},\n    { 0x04, \"Failed link\"},\n    { 0, NULL}\n};\n\nstatic const struct tok lmp_obj_channel_status_values[] = {\n    { 1, \"Signal Okay\"},\n    { 2, \"Signal Degraded\"},\n    { 3, \"Signal Fail\"},\n    { 0, NULL}\n};\n\nstatic const struct tok lmp_obj_begin_verify_flag_values[] = {\n    { 0x0001, \"Verify all links\"},\n    { 0x0002, \"Data link type\"},\n    { 0, NULL}\n};\n\nstatic const struct tok lmp_obj_begin_verify_error_values[] = {\n    { 0x01, \"Link Verification Procedure Not supported\"},\n    { 0x02, \"Unwilling to verify\"},\n    { 0x04, \"Unsupported verification transport mechanism\"},\n    { 0x08, \"Link-Id configuration error\"},\n    { 0x10, \"Unknown object c-type\"},\n    { 0, NULL}\n};\n\nstatic const struct tok lmp_obj_link_summary_error_values[] = {\n    { 0x01, \"Unacceptable non-negotiable LINK-SUMMARY parameters\"},\n    { 0x02, \"Renegotiate LINK-SUMMARY parameters\"},\n    { 0x04, \"Invalid TE-LINK Object\"},\n    { 0x08, \"Invalid DATA-LINK Object\"},\n    { 0x10, \"Unknown TE-LINK Object c-type\"},\n    { 0x20, \"Unknown DATA-LINK Object c-type\"},\n    { 0, NULL}\n};\n\n/* Service Config Supported Protocols Flags */\nstatic const struct tok lmp_obj_service_config_sp_flag_values[] = {\n    { 0x01, \"RSVP Supported\"},\n    { 0x02, \"LDP Supported\"},\n    { 0, NULL}\n};\n\n/* Service Config Client Port Service Attribute Transparency Flags */\nstatic const struct tok lmp_obj_service_config_cpsa_tp_flag_values[] = {\n    { 0x01, \"Path/VC Overhead Transparency Supported\"},\n    { 0x02, \"Line/MS Overhead Transparency Supported\"},\n    { 0x04, \"Section/RS Overhead Transparency Supported\"},\n    { 0, NULL}\n};\n\n/* Service Config Client Port Service Attribute Contiguous Concatenation Types Flags */\nstatic const struct tok lmp_obj_service_config_cpsa_cct_flag_values[] = {\n    { 0x01, \"Contiguous Concatenation Types Supported\"},\n    { 0, NULL}\n};\n\n/* Service Config Network Service Attributes Transparency Flags */\nstatic const struct tok lmp_obj_service_config_nsa_transparency_flag_values[] = {\n    { 0x01, \"Standard SOH/RSOH Transparency Supported\"},\n    { 0x02, \"Standard LOH/MSOH Transparency Supported\"},\n    { 0, NULL}\n};\n\n/* Service Config Network Service Attributes TCM Monitoring Flags */\nstatic const struct tok lmp_obj_service_config_nsa_tcm_flag_values[] = {\n    { 0x01, \"Transparent Tandem Connection Monitoring Supported\"},\n    { 0, NULL}\n};\n\n/* Network Service Attributes Network Diversity Flags */\nstatic const struct tok lmp_obj_service_config_nsa_network_diversity_flag_values[] = {\n    { 0x01, \"Node Diversity Supported\"},\n    { 0x02, \"Link Diversity Supported\"},\n    { 0x04, \"SRLG Diversity Supported\"},\n    { 0, NULL}\n};\n\n#define\tLMP_MSGTYPE_CONFIG                 1\n#define\tLMP_MSGTYPE_CONFIG_ACK             2\n#define\tLMP_MSGTYPE_CONFIG_NACK            3\n#define\tLMP_MSGTYPE_HELLO                  4\n#define\tLMP_MSGTYPE_VERIFY_BEGIN           5\n#define\tLMP_MSGTYPE_VERIFY_BEGIN_ACK       6\n#define\tLMP_MSGTYPE_VERIFY_BEGIN_NACK      7\n#define LMP_MSGTYPE_VERIFY_END             8\n#define LMP_MSGTYPE_VERIFY_END_ACK         9\n#define LMP_MSGTYPE_TEST                  10\n#define LMP_MSGTYPE_TEST_STATUS_SUCCESS   11\n#define\tLMP_MSGTYPE_TEST_STATUS_FAILURE   12\n#define\tLMP_MSGTYPE_TEST_STATUS_ACK       13\n#define\tLMP_MSGTYPE_LINK_SUMMARY          14\n#define\tLMP_MSGTYPE_LINK_SUMMARY_ACK      15\n#define\tLMP_MSGTYPE_LINK_SUMMARY_NACK     16\n#define\tLMP_MSGTYPE_CHANNEL_STATUS        17\n#define\tLMP_MSGTYPE_CHANNEL_STATUS_ACK    18\n#define\tLMP_MSGTYPE_CHANNEL_STATUS_REQ    19\n#define\tLMP_MSGTYPE_CHANNEL_STATUS_RESP   20\n/* LMP Service Discovery message types defined by UNI 1.0 */\n#define LMP_MSGTYPE_SERVICE_CONFIG        50\n#define LMP_MSGTYPE_SERVICE_CONFIG_ACK    51\n#define LMP_MSGTYPE_SERVICE_CONFIG_NACK   52\n\nstatic const struct tok lmp_msg_type_values[] = {\n    { LMP_MSGTYPE_CONFIG, \"Config\"},\n    { LMP_MSGTYPE_CONFIG_ACK, \"Config ACK\"},\n    { LMP_MSGTYPE_CONFIG_NACK, \"Config NACK\"},\n    { LMP_MSGTYPE_HELLO, \"Hello\"},\n    { LMP_MSGTYPE_VERIFY_BEGIN, \"Begin Verify\"},\n    { LMP_MSGTYPE_VERIFY_BEGIN_ACK, \"Begin Verify ACK\"},\n    { LMP_MSGTYPE_VERIFY_BEGIN_NACK, \"Begin Verify NACK\"},\n    { LMP_MSGTYPE_VERIFY_END, \"End Verify\"},\n    { LMP_MSGTYPE_VERIFY_END_ACK, \"End Verify ACK\"},\n    { LMP_MSGTYPE_TEST, \"Test\"},\n    { LMP_MSGTYPE_TEST_STATUS_SUCCESS, \"Test Status Success\"},\n    { LMP_MSGTYPE_TEST_STATUS_FAILURE, \"Test Status Failure\"},\n    { LMP_MSGTYPE_TEST_STATUS_ACK, \"Test Status ACK\"},\n    { LMP_MSGTYPE_LINK_SUMMARY, \"Link Summary\"},\n    { LMP_MSGTYPE_LINK_SUMMARY_ACK, \"Link Summary ACK\"},\n    { LMP_MSGTYPE_LINK_SUMMARY_NACK, \"Link Summary NACK\"},\n    { LMP_MSGTYPE_CHANNEL_STATUS, \"Channel Status\"},\n    { LMP_MSGTYPE_CHANNEL_STATUS_ACK, \"Channel Status ACK\"},\n    { LMP_MSGTYPE_CHANNEL_STATUS_REQ, \"Channel Status Request\"},\n    { LMP_MSGTYPE_CHANNEL_STATUS_RESP, \"Channel Status Response\"},\n    { LMP_MSGTYPE_SERVICE_CONFIG, \"Service Config\"},\n    { LMP_MSGTYPE_SERVICE_CONFIG_ACK, \"Service Config ACK\"},\n    { LMP_MSGTYPE_SERVICE_CONFIG_NACK, \"Service Config NACK\"},\n    { 0, NULL}\n};\n\n/*\n * LMP object header\n *\n *  0                   1                   2                   3\n *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n * |N|   C-Type    |     Class     |            Length             |\n * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n * |                                                               |\n * //                       (object contents)                     //\n * |                                                               |\n * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n */\n\nstruct lmp_object_header {\n    uint8_t ctype;\n    uint8_t class_num;\n    uint8_t length[2];\n};\n\n#define\tLMP_OBJ_CC_ID                 1\n#define\tLMP_OBJ_NODE_ID               2\n#define\tLMP_OBJ_LINK_ID               3\n#define\tLMP_OBJ_INTERFACE_ID          4\n#define\tLMP_OBJ_MESSAGE_ID            5\n#define\tLMP_OBJ_CONFIG                6\n#define\tLMP_OBJ_HELLO                 7\n#define\tLMP_OBJ_VERIFY_BEGIN          8\n#define LMP_OBJ_VERIFY_BEGIN_ACK      9\n#define LMP_OBJ_VERIFY_ID            10\n#define LMP_OBJ_TE_LINK              11\n#define LMP_OBJ_DATA_LINK            12\n#define LMP_OBJ_CHANNEL_STATUS       13\n#define LMP_OBJ_CHANNEL_STATUS_REQ   14\n#define LMP_OBJ_ERROR_CODE           20\n\n#define LMP_OBJ_SERVICE_CONFIG       51 /* defined in UNI 1.0 */\n\nstatic const struct tok lmp_obj_values[] = {\n    { LMP_OBJ_CC_ID, \"Control Channel ID\" },\n    { LMP_OBJ_NODE_ID, \"Node ID\" },\n    { LMP_OBJ_LINK_ID, \"Link ID\" },\n    { LMP_OBJ_INTERFACE_ID, \"Interface ID\" },\n    { LMP_OBJ_MESSAGE_ID, \"Message ID\" },\n    { LMP_OBJ_CONFIG, \"Configuration\" },\n    { LMP_OBJ_HELLO, \"Hello\" },\n    { LMP_OBJ_VERIFY_BEGIN, \"Verify Begin\" },\n    { LMP_OBJ_VERIFY_BEGIN_ACK, \"Verify Begin ACK\" },\n    { LMP_OBJ_VERIFY_ID, \"Verify ID\" },\n    { LMP_OBJ_TE_LINK, \"TE Link\" },\n    { LMP_OBJ_DATA_LINK, \"Data Link\" },\n    { LMP_OBJ_CHANNEL_STATUS, \"Channel Status\" },\n    { LMP_OBJ_CHANNEL_STATUS_REQ, \"Channel Status Request\" },\n    { LMP_OBJ_ERROR_CODE, \"Error Code\" },\n    { LMP_OBJ_SERVICE_CONFIG, \"Service Config\" },\n\n    { 0, NULL}\n};\n\n#define INT_SWITCHING_TYPE_SUBOBJ 1\n#define WAVELENGTH_SUBOBJ         2\n\nstatic const struct tok lmp_data_link_subobj[] = {\n    { INT_SWITCHING_TYPE_SUBOBJ, \"Interface Switching Type\" },\n    { WAVELENGTH_SUBOBJ        , \"Wavelength\" },\n    { 0, NULL}\n};\n\n#define\tLMP_CTYPE_IPV4       1\n#define\tLMP_CTYPE_IPV6       2\n\n#define\tLMP_CTYPE_LOC        1\n#define\tLMP_CTYPE_RMT        2\n#define\tLMP_CTYPE_UNMD       3\n\n#define\tLMP_CTYPE_IPV4_LOC   1\n#define\tLMP_CTYPE_IPV4_RMT   2\n#define\tLMP_CTYPE_IPV6_LOC   3\n#define\tLMP_CTYPE_IPV6_RMT   4\n#define\tLMP_CTYPE_UNMD_LOC   5\n#define\tLMP_CTYPE_UNMD_RMT   6\n\n#define\tLMP_CTYPE_1          1\n#define\tLMP_CTYPE_2          2\n\n#define LMP_CTYPE_HELLO_CONFIG  1\n#define LMP_CTYPE_HELLO         1\n\n#define LMP_CTYPE_BEGIN_VERIFY_ERROR 1\n#define LMP_CTYPE_LINK_SUMMARY_ERROR 2\n\n/* C-Types for Service Config Object */\n#define LMP_CTYPE_SERVICE_CONFIG_SP                   1\n#define LMP_CTYPE_SERVICE_CONFIG_CPSA                 2\n#define LMP_CTYPE_SERVICE_CONFIG_TRANSPARENCY_TCM     3\n#define LMP_CTYPE_SERVICE_CONFIG_NETWORK_DIVERSITY    4\n\n/*\n * Different link types allowed in the Client Port Service Attributes\n * subobject defined for LMP Service Discovery in the UNI 1.0 spec\n */\n#define LMP_SD_SERVICE_CONFIG_CPSA_LINK_TYPE_SDH     5 /* UNI 1.0 Sec 9.4.2 */\n#define LMP_SD_SERVICE_CONFIG_CPSA_LINK_TYPE_SONET   6 /* UNI 1.0 Sec 9.4.2 */\n\n/*\n * the ctypes are not globally unique so for\n * translating it to strings we build a table based\n * on objects offsetted by the ctype\n */\n\nstatic const struct tok lmp_ctype_values[] = {\n    { 256*LMP_OBJ_CC_ID+LMP_CTYPE_LOC, \"Local\" },\n    { 256*LMP_OBJ_CC_ID+LMP_CTYPE_RMT, \"Remote\" },\n    { 256*LMP_OBJ_NODE_ID+LMP_CTYPE_LOC, \"Local\" },\n    { 256*LMP_OBJ_NODE_ID+LMP_CTYPE_RMT, \"Remote\" },\n    { 256*LMP_OBJ_LINK_ID+LMP_CTYPE_IPV4_LOC, \"IPv4 Local\" },\n    { 256*LMP_OBJ_LINK_ID+LMP_CTYPE_IPV4_RMT, \"IPv4 Remote\" },\n    { 256*LMP_OBJ_LINK_ID+LMP_CTYPE_IPV6_LOC, \"IPv6 Local\" },\n    { 256*LMP_OBJ_LINK_ID+LMP_CTYPE_IPV6_RMT, \"IPv6 Remote\" },\n    { 256*LMP_OBJ_LINK_ID+LMP_CTYPE_UNMD_LOC, \"Unnumbered Local\" },\n    { 256*LMP_OBJ_LINK_ID+LMP_CTYPE_UNMD_RMT, \"Unnumbered Remote\" },\n    { 256*LMP_OBJ_INTERFACE_ID+LMP_CTYPE_IPV4_LOC, \"IPv4 Local\" },\n    { 256*LMP_OBJ_INTERFACE_ID+LMP_CTYPE_IPV4_RMT, \"IPv4 Remote\" },\n    { 256*LMP_OBJ_INTERFACE_ID+LMP_CTYPE_IPV6_LOC, \"IPv6 Local\" },\n    { 256*LMP_OBJ_INTERFACE_ID+LMP_CTYPE_IPV6_RMT, \"IPv6 Remote\" },\n    { 256*LMP_OBJ_INTERFACE_ID+LMP_CTYPE_UNMD_LOC, \"Unnumbered Local\" },\n    { 256*LMP_OBJ_INTERFACE_ID+LMP_CTYPE_UNMD_RMT, \"Unnumbered Remote\" },\n    { 256*LMP_OBJ_MESSAGE_ID+LMP_CTYPE_1, \"1\" },\n    { 256*LMP_OBJ_MESSAGE_ID+LMP_CTYPE_2, \"2\" },\n    { 256*LMP_OBJ_CONFIG+LMP_CTYPE_1, \"1\" },\n    { 256*LMP_OBJ_HELLO+LMP_CTYPE_1, \"1\" },\n    { 256*LMP_OBJ_VERIFY_BEGIN+LMP_CTYPE_1, \"1\" },\n    { 256*LMP_OBJ_VERIFY_BEGIN_ACK+LMP_CTYPE_1, \"1\" },\n    { 256*LMP_OBJ_VERIFY_ID+LMP_CTYPE_1, \"1\" },\n    { 256*LMP_OBJ_TE_LINK+LMP_CTYPE_IPV4, \"IPv4\" },\n    { 256*LMP_OBJ_TE_LINK+LMP_CTYPE_IPV6, \"IPv6\" },\n    { 256*LMP_OBJ_TE_LINK+LMP_CTYPE_UNMD, \"Unnumbered\" },\n    { 256*LMP_OBJ_DATA_LINK+LMP_CTYPE_IPV4, \"IPv4\" },\n    { 256*LMP_OBJ_DATA_LINK+LMP_CTYPE_IPV6, \"IPv6\" },\n    { 256*LMP_OBJ_DATA_LINK+LMP_CTYPE_UNMD, \"Unnumbered\" },\n    { 256*LMP_OBJ_CHANNEL_STATUS+LMP_CTYPE_IPV4, \"IPv4\" },\n    { 256*LMP_OBJ_CHANNEL_STATUS+LMP_CTYPE_IPV6, \"IPv6\" },\n    { 256*LMP_OBJ_CHANNEL_STATUS+LMP_CTYPE_UNMD, \"Unnumbered\" },\n    { 256*LMP_OBJ_CHANNEL_STATUS_REQ+LMP_CTYPE_IPV4, \"IPv4\" },\n    { 256*LMP_OBJ_CHANNEL_STATUS_REQ+LMP_CTYPE_IPV6, \"IPv6\" },\n    { 256*LMP_OBJ_CHANNEL_STATUS_REQ+LMP_CTYPE_UNMD, \"Unnumbered\" },\n    { 256*LMP_OBJ_ERROR_CODE+LMP_CTYPE_1, \"1\" },\n    { 256*LMP_OBJ_ERROR_CODE+LMP_CTYPE_2, \"2\" },\n    { 256*LMP_OBJ_SERVICE_CONFIG+LMP_CTYPE_SERVICE_CONFIG_SP, \"1\" },\n    { 256*LMP_OBJ_SERVICE_CONFIG+LMP_CTYPE_SERVICE_CONFIG_CPSA, \"2\" },\n    { 256*LMP_OBJ_SERVICE_CONFIG+LMP_CTYPE_SERVICE_CONFIG_TRANSPARENCY_TCM, \"3\" },\n    { 256*LMP_OBJ_SERVICE_CONFIG+LMP_CTYPE_SERVICE_CONFIG_NETWORK_DIVERSITY, \"4\" },\n    { 0, NULL}\n};\n\nstatic int\nlmp_print_data_link_subobjs(netdissect_options *ndo, const u_char *obj_tptr,\n                            int total_subobj_len, int offset)\n{\n    int hexdump = FALSE;\n    int subobj_type, subobj_len;\n\n    union { /* int to float conversion buffer */\n        float f;\n        uint32_t i;\n    } bw;\n\n    while (total_subobj_len > 0 && hexdump == FALSE ) {\n\tsubobj_type = EXTRACT_8BITS(obj_tptr + offset);\n\tsubobj_len  = EXTRACT_8BITS(obj_tptr + offset + 1);\n\tND_PRINT((ndo, \"\\n\\t    Subobject, Type: %s (%u), Length: %u\",\n\t\ttok2str(lmp_data_link_subobj,\n\t\t\t\"Unknown\",\n\t\t\tsubobj_type),\n\t\t\tsubobj_type,\n\t\t\tsubobj_len));\n\tif (subobj_len < 4) {\n\t    ND_PRINT((ndo, \" (too short)\"));\n\t    break;\n\t}\n\tif ((subobj_len % 4) != 0) {\n\t    ND_PRINT((ndo, \" (not a multiple of 4)\"));\n\t    break;\n\t}\n\tif (total_subobj_len < subobj_len) {\n\t    ND_PRINT((ndo, \" (goes past the end of the object)\"));\n\t    break;\n\t}\n\tswitch(subobj_type) {\n\tcase INT_SWITCHING_TYPE_SUBOBJ:\n\t    ND_PRINT((ndo, \"\\n\\t      Switching Type: %s (%u)\",\n\t\ttok2str(gmpls_switch_cap_values,\n\t\t\t\"Unknown\",\n\t\t\tEXTRACT_8BITS(obj_tptr + offset + 2)),\n\t\t\tEXTRACT_8BITS(obj_tptr + offset + 2)));\n\t    ND_PRINT((ndo, \"\\n\\t      Encoding Type: %s (%u)\",\n\t\ttok2str(gmpls_encoding_values,\n\t\t\t\"Unknown\",\n\t\t\tEXTRACT_8BITS(obj_tptr + offset + 3)),\n\t\t\tEXTRACT_8BITS(obj_tptr + offset + 3)));\n\t    ND_TCHECK_32BITS(obj_tptr + offset + 4);\n\t    bw.i = EXTRACT_32BITS(obj_tptr+offset+4);\n\t    ND_PRINT((ndo, \"\\n\\t      Min Reservable Bandwidth: %.3f Mbps\",\n                bw.f*8/1000000));\n\t    bw.i = EXTRACT_32BITS(obj_tptr+offset+8);\n\t    ND_PRINT((ndo, \"\\n\\t      Max Reservable Bandwidth: %.3f Mbps\",\n                bw.f*8/1000000));\n\t    break;\n\tcase WAVELENGTH_SUBOBJ:\n\t    ND_PRINT((ndo, \"\\n\\t      Wavelength: %u\",\n\t\tEXTRACT_32BITS(obj_tptr+offset+4)));\n\t    break;\n\tdefault:\n\t    /* Any Unknown Subobject ==> Exit loop */\n\t    hexdump=TRUE;\n\t    break;\n\t}\n\ttotal_subobj_len-=subobj_len;\n\toffset+=subobj_len;\n    }\n    return (hexdump);\ntrunc:\n    return -1;\n}\n\nvoid\nlmp_print(netdissect_options *ndo,\n          register const u_char *pptr, register u_int len)\n{\n    const struct lmp_common_header *lmp_com_header;\n    const struct lmp_object_header *lmp_obj_header;\n    const u_char *tptr,*obj_tptr;\n    u_int tlen,lmp_obj_len,lmp_obj_ctype,obj_tlen;\n    int hexdump, ret;\n    u_int offset;\n    u_int link_type;\n\n    union { /* int to float conversion buffer */\n        float f;\n        uint32_t i;\n    } bw;\n\n    tptr=pptr;\n    lmp_com_header = (const struct lmp_common_header *)pptr;\n    ND_TCHECK(*lmp_com_header);\n\n    /*\n     * Sanity checking of the header.\n     */\n    if (LMP_EXTRACT_VERSION(lmp_com_header->version_res[0]) != LMP_VERSION) {\n\tND_PRINT((ndo, \"LMP version %u packet not supported\",\n               LMP_EXTRACT_VERSION(lmp_com_header->version_res[0])));\n\treturn;\n    }\n\n    /* in non-verbose mode just lets print the basic Message Type*/\n    if (ndo->ndo_vflag < 1) {\n        ND_PRINT((ndo, \"LMPv%u %s Message, length: %u\",\n               LMP_EXTRACT_VERSION(lmp_com_header->version_res[0]),\n               tok2str(lmp_msg_type_values, \"unknown (%u)\",lmp_com_header->msg_type),\n               len));\n        return;\n    }\n\n    /* ok they seem to want to know everything - lets fully decode it */\n\n    tlen=EXTRACT_16BITS(lmp_com_header->length);\n\n    ND_PRINT((ndo, \"\\n\\tLMPv%u, msg-type: %s, Flags: [%s], length: %u\",\n           LMP_EXTRACT_VERSION(lmp_com_header->version_res[0]),\n           tok2str(lmp_msg_type_values, \"unknown, type: %u\",lmp_com_header->msg_type),\n           bittok2str(lmp_header_flag_values,\"none\",lmp_com_header->flags),\n           tlen));\n    if (tlen < sizeof(const struct lmp_common_header)) {\n        ND_PRINT((ndo, \" (too short)\"));\n        return;\n    }\n    if (tlen > len) {\n        ND_PRINT((ndo, \" (too long)\"));\n        tlen = len;\n    }\n\n    tptr+=sizeof(const struct lmp_common_header);\n    tlen-=sizeof(const struct lmp_common_header);\n\n    while(tlen>0) {\n        /* did we capture enough for fully decoding the object header ? */\n        ND_TCHECK2(*tptr, sizeof(struct lmp_object_header));\n\n        lmp_obj_header = (const struct lmp_object_header *)tptr;\n        lmp_obj_len=EXTRACT_16BITS(lmp_obj_header->length);\n        lmp_obj_ctype=(lmp_obj_header->ctype)&0x7f;\n\n        ND_PRINT((ndo, \"\\n\\t  %s Object (%u), Class-Type: %s (%u) Flags: [%snegotiable], length: %u\",\n               tok2str(lmp_obj_values,\n                       \"Unknown\",\n                       lmp_obj_header->class_num),\n               lmp_obj_header->class_num,\n               tok2str(lmp_ctype_values,\n                       \"Unknown\",\n                       ((lmp_obj_header->class_num)<<8)+lmp_obj_ctype),\n               lmp_obj_ctype,\n               (lmp_obj_header->ctype)&0x80 ? \"\" : \"non-\",\n               lmp_obj_len));\n\n        if (lmp_obj_len < 4) {\n            ND_PRINT((ndo, \" (too short)\"));\n            return;\n        }\n        if ((lmp_obj_len % 4) != 0) {\n            ND_PRINT((ndo, \" (not a multiple of 4)\"));\n            return;\n        }\n\n        obj_tptr=tptr+sizeof(struct lmp_object_header);\n        obj_tlen=lmp_obj_len-sizeof(struct lmp_object_header);\n\n        /* did we capture enough for fully decoding the object ? */\n        ND_TCHECK2(*tptr, lmp_obj_len);\n        hexdump=FALSE;\n\n        switch(lmp_obj_header->class_num) {\n\n        case LMP_OBJ_CC_ID:\n            switch(lmp_obj_ctype) {\n            case LMP_CTYPE_LOC:\n            case LMP_CTYPE_RMT:\n                if (obj_tlen != 4) {\n                    ND_PRINT((ndo, \" (not correct for object)\"));\n                    break;\n                }\n                ND_PRINT((ndo, \"\\n\\t    Control Channel ID: %u (0x%08x)\",\n                       EXTRACT_32BITS(obj_tptr),\n                       EXTRACT_32BITS(obj_tptr)));\n                break;\n\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case LMP_OBJ_LINK_ID:\n        case LMP_OBJ_INTERFACE_ID:\n            switch(lmp_obj_ctype) {\n            case LMP_CTYPE_IPV4_LOC:\n            case LMP_CTYPE_IPV4_RMT:\n                if (obj_tlen != 4) {\n                    ND_PRINT((ndo, \" (not correct for object)\"));\n                    break;\n                }\n                ND_PRINT((ndo, \"\\n\\t    IPv4 Link ID: %s (0x%08x)\",\n                       ipaddr_string(ndo, obj_tptr),\n                       EXTRACT_32BITS(obj_tptr)));\n                break;\n            case LMP_CTYPE_IPV6_LOC:\n            case LMP_CTYPE_IPV6_RMT:\n                if (obj_tlen != 16) {\n                    ND_PRINT((ndo, \" (not correct for object)\"));\n                    break;\n                }\n                ND_PRINT((ndo, \"\\n\\t    IPv6 Link ID: %s (0x%08x)\",\n                       ip6addr_string(ndo, obj_tptr),\n                       EXTRACT_32BITS(obj_tptr)));\n                break;\n            case LMP_CTYPE_UNMD_LOC:\n            case LMP_CTYPE_UNMD_RMT:\n                if (obj_tlen != 4) {\n                    ND_PRINT((ndo, \" (not correct for object)\"));\n                    break;\n                }\n                ND_PRINT((ndo, \"\\n\\t    Link ID: %u (0x%08x)\",\n                       EXTRACT_32BITS(obj_tptr),\n                       EXTRACT_32BITS(obj_tptr)));\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case LMP_OBJ_MESSAGE_ID:\n            switch(lmp_obj_ctype) {\n            case LMP_CTYPE_1:\n                if (obj_tlen != 4) {\n                    ND_PRINT((ndo, \" (not correct for object)\"));\n                    break;\n                }\n                ND_PRINT((ndo, \"\\n\\t    Message ID: %u (0x%08x)\",\n                       EXTRACT_32BITS(obj_tptr),\n                       EXTRACT_32BITS(obj_tptr)));\n                break;\n            case LMP_CTYPE_2:\n                if (obj_tlen != 4) {\n                    ND_PRINT((ndo, \" (not correct for object)\"));\n                    break;\n                }\n                ND_PRINT((ndo, \"\\n\\t    Message ID Ack: %u (0x%08x)\",\n                       EXTRACT_32BITS(obj_tptr),\n                       EXTRACT_32BITS(obj_tptr)));\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case LMP_OBJ_NODE_ID:\n            switch(lmp_obj_ctype) {\n            case LMP_CTYPE_LOC:\n            case LMP_CTYPE_RMT:\n                if (obj_tlen != 4) {\n                    ND_PRINT((ndo, \" (not correct for object)\"));\n                    break;\n                }\n                ND_PRINT((ndo, \"\\n\\t    Node ID: %s (0x%08x)\",\n                       ipaddr_string(ndo, obj_tptr),\n                       EXTRACT_32BITS(obj_tptr)));\n                break;\n\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case LMP_OBJ_CONFIG:\n            switch(lmp_obj_ctype) {\n            case LMP_CTYPE_HELLO_CONFIG:\n                if (obj_tlen != 4) {\n                    ND_PRINT((ndo, \" (not correct for object)\"));\n                    break;\n                }\n                ND_PRINT((ndo, \"\\n\\t    Hello Interval: %u\\n\\t    Hello Dead Interval: %u\",\n                       EXTRACT_16BITS(obj_tptr),\n                       EXTRACT_16BITS(obj_tptr+2)));\n                break;\n\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case LMP_OBJ_HELLO:\n            switch(lmp_obj_ctype) {\n\t    case LMP_CTYPE_HELLO:\n                if (obj_tlen != 8) {\n                    ND_PRINT((ndo, \" (not correct for object)\"));\n                    break;\n                }\n                ND_PRINT((ndo, \"\\n\\t    Tx Seq: %u, Rx Seq: %u\",\n                       EXTRACT_32BITS(obj_tptr),\n                       EXTRACT_32BITS(obj_tptr+4)));\n                break;\n\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case LMP_OBJ_TE_LINK:\n\t    switch(lmp_obj_ctype) {\n\t    case LMP_CTYPE_IPV4:\n                if (obj_tlen != 12) {\n                    ND_PRINT((ndo, \" (not correct for object)\"));\n                    break;\n                }\n\t\tND_PRINT((ndo, \"\\n\\t    Flags: [%s]\",\n\t\t    bittok2str(lmp_obj_te_link_flag_values,\n\t\t\t\"none\",\n\t\t\tEXTRACT_8BITS(obj_tptr))));\n\n\t\tND_PRINT((ndo, \"\\n\\t    Local Link-ID: %s (0x%08x)\"\n\t\t       \"\\n\\t    Remote Link-ID: %s (0x%08x)\",\n                       ipaddr_string(ndo, obj_tptr+4),\n                       EXTRACT_32BITS(obj_tptr+4),\n                       ipaddr_string(ndo, obj_tptr+8),\n                       EXTRACT_32BITS(obj_tptr+8)));\n\t\tbreak;\n\n\t    case LMP_CTYPE_IPV6:\n                if (obj_tlen != 36) {\n                    ND_PRINT((ndo, \" (not correct for object)\"));\n                    break;\n                }\n\t\tND_PRINT((ndo, \"\\n\\t    Flags: [%s]\",\n\t\t    bittok2str(lmp_obj_te_link_flag_values,\n\t\t\t\"none\",\n\t\t\tEXTRACT_8BITS(obj_tptr))));\n\n\t\tND_PRINT((ndo, \"\\n\\t    Local Link-ID: %s (0x%08x)\"\n\t\t       \"\\n\\t    Remote Link-ID: %s (0x%08x)\",\n                       ip6addr_string(ndo, obj_tptr+4),\n                       EXTRACT_32BITS(obj_tptr+4),\n                       ip6addr_string(ndo, obj_tptr+20),\n                       EXTRACT_32BITS(obj_tptr+20)));\n                break;\n\n\t    case LMP_CTYPE_UNMD:\n                if (obj_tlen != 12) {\n                    ND_PRINT((ndo, \" (not correct for object)\"));\n                    break;\n                }\n\t\tND_PRINT((ndo, \"\\n\\t    Flags: [%s]\",\n\t\t    bittok2str(lmp_obj_te_link_flag_values,\n\t\t\t\"none\",\n\t\t\tEXTRACT_8BITS(obj_tptr))));\n\n\t\tND_PRINT((ndo, \"\\n\\t    Local Link-ID: %u (0x%08x)\"\n\t\t       \"\\n\\t    Remote Link-ID: %u (0x%08x)\",\n                       EXTRACT_32BITS(obj_tptr+4),\n                       EXTRACT_32BITS(obj_tptr+4),\n                       EXTRACT_32BITS(obj_tptr+8),\n                       EXTRACT_32BITS(obj_tptr+8)));\n\t\tbreak;\n\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case LMP_OBJ_DATA_LINK:\n\t    switch(lmp_obj_ctype) {\n\t    case LMP_CTYPE_IPV4:\n                if (obj_tlen < 12) {\n                    ND_PRINT((ndo, \" (not correct for object)\"));\n                    break;\n                }\n\t        ND_PRINT((ndo, \"\\n\\t    Flags: [%s]\",\n\t\t    bittok2str(lmp_obj_data_link_flag_values,\n\t\t\t\"none\",\n\t\t\tEXTRACT_8BITS(obj_tptr))));\n                ND_PRINT((ndo, \"\\n\\t    Local Interface ID: %s (0x%08x)\"\n                       \"\\n\\t    Remote Interface ID: %s (0x%08x)\",\n                       ipaddr_string(ndo, obj_tptr+4),\n                       EXTRACT_32BITS(obj_tptr+4),\n                       ipaddr_string(ndo, obj_tptr+8),\n                       EXTRACT_32BITS(obj_tptr+8)));\n\n\t\tret = lmp_print_data_link_subobjs(ndo, obj_tptr, obj_tlen - 12, 12);\n\t\tif (ret == -1)\n\t\t    goto trunc;\n\t\tif (ret == TRUE)\n\t\t    hexdump=TRUE;\n\t\tbreak;\n\n\t    case LMP_CTYPE_IPV6:\n                if (obj_tlen < 36) {\n                    ND_PRINT((ndo, \" (not correct for object)\"));\n                    break;\n                }\n\t        ND_PRINT((ndo, \"\\n\\t    Flags: [%s]\",\n\t\t    bittok2str(lmp_obj_data_link_flag_values,\n\t\t\t\"none\",\n\t\t\tEXTRACT_8BITS(obj_tptr))));\n                ND_PRINT((ndo, \"\\n\\t    Local Interface ID: %s (0x%08x)\"\n                       \"\\n\\t    Remote Interface ID: %s (0x%08x)\",\n                       ip6addr_string(ndo, obj_tptr+4),\n                       EXTRACT_32BITS(obj_tptr+4),\n                       ip6addr_string(ndo, obj_tptr+20),\n                       EXTRACT_32BITS(obj_tptr+20)));\n\n\t\tret = lmp_print_data_link_subobjs(ndo, obj_tptr, obj_tlen - 36, 36);\n\t\tif (ret == -1)\n\t\t    goto trunc;\n\t\tif (ret == TRUE)\n\t\t    hexdump=TRUE;\n\t\tbreak;\n\n\t    case LMP_CTYPE_UNMD:\n                if (obj_tlen < 12) {\n                    ND_PRINT((ndo, \" (not correct for object)\"));\n                    break;\n                }\n\t        ND_PRINT((ndo, \"\\n\\t    Flags: [%s]\",\n\t\t    bittok2str(lmp_obj_data_link_flag_values,\n\t\t\t\"none\",\n\t\t\tEXTRACT_8BITS(obj_tptr))));\n                ND_PRINT((ndo, \"\\n\\t    Local Interface ID: %u (0x%08x)\"\n                       \"\\n\\t    Remote Interface ID: %u (0x%08x)\",\n                       EXTRACT_32BITS(obj_tptr+4),\n                       EXTRACT_32BITS(obj_tptr+4),\n                       EXTRACT_32BITS(obj_tptr+8),\n                       EXTRACT_32BITS(obj_tptr+8)));\n\n\t\tret = lmp_print_data_link_subobjs(ndo, obj_tptr, obj_tlen - 12, 12);\n\t\tif (ret == -1)\n\t\t    goto trunc;\n\t\tif (ret == TRUE)\n\t\t    hexdump=TRUE;\n\t\tbreak;\n\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case LMP_OBJ_VERIFY_BEGIN:\n\t    switch(lmp_obj_ctype) {\n            case LMP_CTYPE_1:\n                if (obj_tlen != 20) {\n                    ND_PRINT((ndo, \" (not correct for object)\"));\n                    break;\n                }\n\t\tND_PRINT((ndo, \"\\n\\t    Flags: %s\",\n\t\tbittok2str(lmp_obj_begin_verify_flag_values,\n\t\t\t\"none\",\n\t\t\tEXTRACT_16BITS(obj_tptr))));\n\t\tND_PRINT((ndo, \"\\n\\t    Verify Interval: %u\",\n\t\t\tEXTRACT_16BITS(obj_tptr+2)));\n\t\tND_PRINT((ndo, \"\\n\\t    Data links: %u\",\n\t\t\tEXTRACT_32BITS(obj_tptr+4)));\n                ND_PRINT((ndo, \"\\n\\t    Encoding type: %s\",\n\t\t\ttok2str(gmpls_encoding_values, \"Unknown\", *(obj_tptr+8))));\n                ND_PRINT((ndo, \"\\n\\t    Verify Transport Mechanism: %u (0x%x)%s\",\n\t\t\tEXTRACT_16BITS(obj_tptr+10),\n\t\t\tEXTRACT_16BITS(obj_tptr+10),\n\t\t\tEXTRACT_16BITS(obj_tptr+10)&8000 ? \" (Payload test messages capable)\" : \"\"));\n                bw.i = EXTRACT_32BITS(obj_tptr+12);\n\t\tND_PRINT((ndo, \"\\n\\t    Transmission Rate: %.3f Mbps\",bw.f*8/1000000));\n\t\tND_PRINT((ndo, \"\\n\\t    Wavelength: %u\",\n\t\t\tEXTRACT_32BITS(obj_tptr+16)));\n\t\tbreak;\n\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case LMP_OBJ_VERIFY_BEGIN_ACK:\n\t    switch(lmp_obj_ctype) {\n            case LMP_CTYPE_1:\n                if (obj_tlen != 4) {\n                    ND_PRINT((ndo, \" (not correct for object)\"));\n                    break;\n                }\n                ND_PRINT((ndo, \"\\n\\t    Verify Dead Interval: %u\"\n                       \"\\n\\t    Verify Transport Response: %u\",\n                       EXTRACT_16BITS(obj_tptr),\n                       EXTRACT_16BITS(obj_tptr+2)));\n                break;\n\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n\tcase LMP_OBJ_VERIFY_ID:\n\t    switch(lmp_obj_ctype) {\n            case LMP_CTYPE_1:\n                if (obj_tlen != 4) {\n                    ND_PRINT((ndo, \" (not correct for object)\"));\n                    break;\n                }\n                ND_PRINT((ndo, \"\\n\\t    Verify ID: %u\",\n                       EXTRACT_32BITS(obj_tptr)));\n                break;\n\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n\tcase LMP_OBJ_CHANNEL_STATUS:\n            switch(lmp_obj_ctype) {\n\t    case LMP_CTYPE_IPV4:\n\t\toffset = 0;\n\t\t/* Decode pairs: <Interface_ID (4 bytes), Channel_status (4 bytes)> */\n\t\twhile (offset+8 <= obj_tlen) {\n\t\t\tND_PRINT((ndo, \"\\n\\t    Interface ID: %s (0x%08x)\",\n\t\t\tipaddr_string(ndo, obj_tptr+offset),\n\t\t\tEXTRACT_32BITS(obj_tptr+offset)));\n\n\t\t\tND_PRINT((ndo, \"\\n\\t\\t    Active: %s (%u)\",\n\t\t\t\t(EXTRACT_32BITS(obj_tptr+offset+4)>>31) ?\n\t\t\t\t\t\t\"Allocated\" : \"Non-allocated\",\n\t\t\t\t(EXTRACT_32BITS(obj_tptr+offset+4)>>31)));\n\n\t\t\tND_PRINT((ndo, \"\\n\\t\\t    Direction: %s (%u)\",\n\t\t\t\t(EXTRACT_32BITS(obj_tptr+offset+4)>>30)&0x1 ?\n\t\t\t\t\t\t\"Transmit\" : \"Receive\",\n\t\t\t\t(EXTRACT_32BITS(obj_tptr+offset+4)>>30)&0x1));\n\n\t\t\tND_PRINT((ndo, \"\\n\\t\\t    Channel Status: %s (%u)\",\n\t\t\t\t\ttok2str(lmp_obj_channel_status_values,\n\t\t\t \t\t\"Unknown\",\n\t\t\t\t\tEXTRACT_32BITS(obj_tptr+offset+4)&0x3FFFFFF),\n\t\t\tEXTRACT_32BITS(obj_tptr+offset+4)&0x3FFFFFF));\n\t\t\toffset+=8;\n\t\t}\n                break;\n\n\t    case LMP_CTYPE_IPV6:\n\t\toffset = 0;\n\t\t/* Decode pairs: <Interface_ID (16 bytes), Channel_status (4 bytes)> */\n\t\twhile (offset+20 <= obj_tlen) {\n\t\t\tND_PRINT((ndo, \"\\n\\t    Interface ID: %s (0x%08x)\",\n\t\t\tip6addr_string(ndo, obj_tptr+offset),\n\t\t\tEXTRACT_32BITS(obj_tptr+offset)));\n\n\t\t\tND_PRINT((ndo, \"\\n\\t\\t    Active: %s (%u)\",\n\t\t\t\t(EXTRACT_32BITS(obj_tptr+offset+16)>>31) ?\n\t\t\t\t\t\t\"Allocated\" : \"Non-allocated\",\n\t\t\t\t(EXTRACT_32BITS(obj_tptr+offset+16)>>31)));\n\n\t\t\tND_PRINT((ndo, \"\\n\\t\\t    Direction: %s (%u)\",\n\t\t\t\t(EXTRACT_32BITS(obj_tptr+offset+16)>>30)&0x1 ?\n\t\t\t\t\t\t\"Transmit\" : \"Receive\",\n\t\t\t\t(EXTRACT_32BITS(obj_tptr+offset+16)>>30)&0x1));\n\n\t\t\tND_PRINT((ndo, \"\\n\\t\\t    Channel Status: %s (%u)\",\n\t\t\t\t\ttok2str(lmp_obj_channel_status_values,\n\t\t\t\t\t\"Unknown\",\n\t\t\t\t\tEXTRACT_32BITS(obj_tptr+offset+16)&0x3FFFFFF),\n\t\t\tEXTRACT_32BITS(obj_tptr+offset+16)&0x3FFFFFF));\n\t\t\toffset+=20;\n\t\t}\n                break;\n\n\t    case LMP_CTYPE_UNMD:\n\t\toffset = 0;\n\t\t/* Decode pairs: <Interface_ID (4 bytes), Channel_status (4 bytes)> */\n\t\twhile (offset+8 <= obj_tlen) {\n\t\t\tND_PRINT((ndo, \"\\n\\t    Interface ID: %u (0x%08x)\",\n\t\t\tEXTRACT_32BITS(obj_tptr+offset),\n\t\t\tEXTRACT_32BITS(obj_tptr+offset)));\n\n\t\t\tND_PRINT((ndo, \"\\n\\t\\t    Active: %s (%u)\",\n\t\t\t\t(EXTRACT_32BITS(obj_tptr+offset+4)>>31) ?\n\t\t\t\t\t\t\"Allocated\" : \"Non-allocated\",\n\t\t\t\t(EXTRACT_32BITS(obj_tptr+offset+4)>>31)));\n\n\t\t\tND_PRINT((ndo, \"\\n\\t\\t    Direction: %s (%u)\",\n\t\t\t\t(EXTRACT_32BITS(obj_tptr+offset+4)>>30)&0x1 ?\n\t\t\t\t\t\t\"Transmit\" : \"Receive\",\n\t\t\t\t(EXTRACT_32BITS(obj_tptr+offset+4)>>30)&0x1));\n\n\t\t\tND_PRINT((ndo, \"\\n\\t\\t    Channel Status: %s (%u)\",\n\t\t\t\t\ttok2str(lmp_obj_channel_status_values,\n\t\t\t\t\t\"Unknown\",\n\t\t\t\t\tEXTRACT_32BITS(obj_tptr+offset+4)&0x3FFFFFF),\n\t\t\tEXTRACT_32BITS(obj_tptr+offset+4)&0x3FFFFFF));\n\t\t\toffset+=8;\n\t\t}\n                break;\n\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n\tcase LMP_OBJ_CHANNEL_STATUS_REQ:\n            switch(lmp_obj_ctype) {\n\t    case LMP_CTYPE_IPV4:\n\t\toffset = 0;\n\t\twhile (offset+4 <= obj_tlen) {\n\t\t\tND_PRINT((ndo, \"\\n\\t    Interface ID: %s (0x%08x)\",\n\t\t\tipaddr_string(ndo, obj_tptr+offset),\n\t\t\tEXTRACT_32BITS(obj_tptr+offset)));\n\t\t\toffset+=4;\n\t\t}\n                break;\n\n\t    case LMP_CTYPE_IPV6:\n\t\toffset = 0;\n\t\twhile (offset+16 <= obj_tlen) {\n\t\t\tND_PRINT((ndo, \"\\n\\t    Interface ID: %s (0x%08x)\",\n\t\t\tip6addr_string(ndo, obj_tptr+offset),\n\t\t\tEXTRACT_32BITS(obj_tptr+offset)));\n\t\t\toffset+=16;\n\t\t}\n                break;\n\n\t    case LMP_CTYPE_UNMD:\n\t\toffset = 0;\n\t\twhile (offset+4 <= obj_tlen) {\n\t\t\tND_PRINT((ndo, \"\\n\\t    Interface ID: %u (0x%08x)\",\n\t\t\tEXTRACT_32BITS(obj_tptr+offset),\n\t\t\tEXTRACT_32BITS(obj_tptr+offset)));\n\t\t\toffset+=4;\n\t\t}\n                break;\n\n\t    default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case LMP_OBJ_ERROR_CODE:\n\t    switch(lmp_obj_ctype) {\n            case LMP_CTYPE_BEGIN_VERIFY_ERROR:\n                if (obj_tlen != 4) {\n                    ND_PRINT((ndo, \" (not correct for object)\"));\n                    break;\n                }\n\t\tND_PRINT((ndo, \"\\n\\t    Error Code: %s\",\n\t\tbittok2str(lmp_obj_begin_verify_error_values,\n\t\t\t\"none\",\n\t\t\tEXTRACT_32BITS(obj_tptr))));\n                break;\n\n            case LMP_CTYPE_LINK_SUMMARY_ERROR:\n                if (obj_tlen != 4) {\n                    ND_PRINT((ndo, \" (not correct for object)\"));\n                    break;\n                }\n\t\tND_PRINT((ndo, \"\\n\\t    Error Code: %s\",\n\t\tbittok2str(lmp_obj_link_summary_error_values,\n\t\t\t\"none\",\n\t\t\tEXTRACT_32BITS(obj_tptr))));\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n\tcase LMP_OBJ_SERVICE_CONFIG:\n\t    switch (lmp_obj_ctype) {\n\t    case LMP_CTYPE_SERVICE_CONFIG_SP:\n                if (obj_tlen != 4) {\n                    ND_PRINT((ndo, \" (not correct for object)\"));\n                    break;\n                }\n\t\tND_PRINT((ndo, \"\\n\\t Flags: %s\",\n\t\t       bittok2str(lmp_obj_service_config_sp_flag_values,\n\t\t\t\t  \"none\",\n\t\t\t\t  EXTRACT_8BITS(obj_tptr))));\n\n\t\tND_PRINT((ndo, \"\\n\\t  UNI Version: %u\",\n\t\t       EXTRACT_8BITS(obj_tptr + 1)));\n\n\t\tbreak;\n\n            case LMP_CTYPE_SERVICE_CONFIG_CPSA:\n                if (obj_tlen != 16) {\n                    ND_PRINT((ndo, \" (not correct for object)\"));\n                    break;\n                }\n\n\t\tlink_type = EXTRACT_8BITS(obj_tptr);\n\n\t\tND_PRINT((ndo, \"\\n\\t Link Type: %s (%u)\",\n\t\t       tok2str(lmp_sd_service_config_cpsa_link_type_values,\n\t\t\t       \"Unknown\", link_type),\n\t\t       link_type));\n\n\t\tswitch (link_type) {\n\t\tcase LMP_SD_SERVICE_CONFIG_CPSA_LINK_TYPE_SDH:\n\t\t    ND_PRINT((ndo, \"\\n\\t Signal Type: %s (%u)\",\n\t\t\t   tok2str(lmp_sd_service_config_cpsa_signal_type_sdh_values,\n\t\t\t\t   \"Unknown\",\n\t\t\t\t   EXTRACT_8BITS(obj_tptr + 1)),\n\t\t\t\t   EXTRACT_8BITS(obj_tptr + 1)));\n\t\t    break;\n\n\t\tcase LMP_SD_SERVICE_CONFIG_CPSA_LINK_TYPE_SONET:\n\t\t    ND_PRINT((ndo, \"\\n\\t Signal Type: %s (%u)\",\n\t\t\t   tok2str(lmp_sd_service_config_cpsa_signal_type_sonet_values,\n\t\t\t\t   \"Unknown\",\n\t\t\t\t   EXTRACT_8BITS(obj_tptr + 1)),\n\t\t\t\t   EXTRACT_8BITS(obj_tptr + 1)));\n\t\t    break;\n\t\t}\n\n\t\tND_PRINT((ndo, \"\\n\\t Transparency: %s\",\n\t\t       bittok2str(lmp_obj_service_config_cpsa_tp_flag_values,\n\t\t\t\t  \"none\",\n\t\t\t\t  EXTRACT_8BITS(obj_tptr + 2))));\n\n\t\tND_PRINT((ndo, \"\\n\\t Contiguous Concatenation Types: %s\",\n\t\t       bittok2str(lmp_obj_service_config_cpsa_cct_flag_values,\n\t\t\t\t  \"none\",\n\t\t\t\t  EXTRACT_8BITS(obj_tptr + 3))));\n\n\t\tND_PRINT((ndo, \"\\n\\t Minimum NCC: %u\",\n\t\t       EXTRACT_16BITS(obj_tptr+4)));\n\n\t\tND_PRINT((ndo, \"\\n\\t Maximum NCC: %u\",\n\t\t       EXTRACT_16BITS(obj_tptr+6)));\n\n\t\tND_PRINT((ndo, \"\\n\\t Minimum NVC:%u\",\n\t\t       EXTRACT_16BITS(obj_tptr+8)));\n\n\t\tND_PRINT((ndo, \"\\n\\t Maximum NVC:%u\",\n\t\t       EXTRACT_16BITS(obj_tptr+10)));\n\n\t\tND_PRINT((ndo, \"\\n\\t    Local Interface ID: %s (0x%08x)\",\n\t\t       ipaddr_string(ndo, obj_tptr+12),\n\t\t       EXTRACT_32BITS(obj_tptr+12)));\n\n\t\tbreak;\n\n\t    case LMP_CTYPE_SERVICE_CONFIG_TRANSPARENCY_TCM:\n                if (obj_tlen != 8) {\n                    ND_PRINT((ndo, \" (not correct for object)\"));\n                    break;\n                }\n\n\t\tND_PRINT((ndo, \"\\n\\t Transparency Flags: %s\",\n\t\t       bittok2str(\n\t\t\t   lmp_obj_service_config_nsa_transparency_flag_values,\n\t\t\t   \"none\",\n\t\t\t   EXTRACT_32BITS(obj_tptr))));\n\n\t\tND_PRINT((ndo, \"\\n\\t TCM Monitoring Flags: %s\",\n\t\t       bittok2str(\n\t\t\t   lmp_obj_service_config_nsa_tcm_flag_values,\n\t\t\t   \"none\",\n\t\t\t   EXTRACT_8BITS(obj_tptr + 7))));\n\n\t\tbreak;\n\n\t    case LMP_CTYPE_SERVICE_CONFIG_NETWORK_DIVERSITY:\n                if (obj_tlen != 4) {\n                    ND_PRINT((ndo, \" (not correct for object)\"));\n                    break;\n                }\n\n\t\tND_PRINT((ndo, \"\\n\\t Diversity: Flags: %s\",\n\t\t       bittok2str(\n\t\t\t   lmp_obj_service_config_nsa_network_diversity_flag_values,\n\t\t\t   \"none\",\n\t\t\t   EXTRACT_8BITS(obj_tptr + 3))));\n\t\tbreak;\n\n\t    default:\n\t\thexdump = TRUE;\n\t    }\n\n\tbreak;\n\n        default:\n            if (ndo->ndo_vflag <= 1)\n                print_unknown_data(ndo,obj_tptr,\"\\n\\t    \",obj_tlen);\n            break;\n        }\n        /* do we want to see an additionally hexdump ? */\n        if (ndo->ndo_vflag > 1 || hexdump==TRUE)\n            print_unknown_data(ndo,tptr+sizeof(struct lmp_object_header),\"\\n\\t    \",\n                               lmp_obj_len-sizeof(struct lmp_object_header));\n\n        tptr+=lmp_obj_len;\n        tlen-=lmp_obj_len;\n    }\n    return;\ntrunc:\n    ND_PRINT((ndo, \"\\n\\t\\t packet exceeded snapshot\"));\n}\n/*\n * Local Variables:\n * c-style: whitesmith\n * c-basic-offset: 8\n * End:\n */\n", "IP (tos 0xfd,ECT(1), ttl 254, id 45839, offset 0, flags [+, DF, rsvd], proto UDP (17), length 56871, bad cksum fe07 (->ddf0)!)\n    17.8.8.255.701 > 40.184.42.8.12: \n\tLMPv1, msg-type: unknown, type: 249, Flags: [none], length: 212\n\t  Data Link Object (12), Class-Type: Unnumbered (3) Flags: [non-negotiable], length: 20\n\t    Flags: [none]\n\t    Local Interface ID: 2435832538 (0x912fdada)\n\t    Remote Interface ID: 3657433088 (0xda000000)\n\t    Subobject, Type: Interface Switching Type (1), Length: 4\n\t      Switching Type: Unknown (0)\n\t      Encoding Type: Unknown (0)\n\t\t packet exceeded snapshot\nIP (tos 0xfd,ECT(1), ttl 254, id 45839, offset 0, flags [+, DF, rsvd], proto UDP (17), length 56871, bad cksum fe07 (->ddf0)!)\n    17.8.8.255.701 > 40.184.42.8.12: \n\tLMPv1, msg-type: unknown, type: 249, Flags: [none], length: 212\n\t  Data Link Object (12), Class-Type: Unnumbered (3) Flags: [non-negotiable], length: 20\n\t    Flags: [none]\n\t    Local Interface ID: 2435832538 (0x912fdada)\n\t    Remote Interface ID: 3657433088 (0xda000000)\n\t    Subobject, Type: Interface Switching Type (1), Length: 4\n\t      Switching Type: Unknown (0)\n\t      Encoding Type: Unknown (0)\n\t\t packet exceeded snapshot\n", "00:80:ad:91:d8:6f > 00:0b:64:00:10:72, ethertype IPv4 (0x0800), length 725: (tos 0x0, ttl 128, id 35978, offset 0, flags [none], proto UDP (17), length 711)\n    168.152.32.1.701 > 168.152.32.39.701: [udp sum ok] \n\tLMPv1, msg-type: Config, Flags: [Control Channel Down], length: 257\n\t  Data Link Object (12), Class-Type: IPv4 (1) Flags: [non-negotiable], length: 516\n\t    Flags: [Allocated for user traffic]\n\t    Local Interface ID: 0.0.2.0 (0x00000200)\n\t    Remote Interface ID: 2.0.2.0 (0x02000200)\n\t    Subobject, Type: Wavelength (2), Length: 0 (too short)\n\t    0x0000:  0253 e10b 0000 0200 0200 0200 0200 0200\n\t    0x0010:  0200 0200 0200 0200 0200 0200 0200 0200\n\t    0x0020:  0200 0200 0200 0200 0200 0200 0200 0200\n\t    0x0030:  0200 0200 0200 0200 0200 0200 0200 0200\n\t    0x0040:  0200 0280 6d00 0200 0200 0200 0200 0200\n\t    0x0050:  0200 0200 0200 0200 0200 0200 0200 0200\n\t    0x0060:  0200 0200 0200 0200 0200 0200 0200 0200\n\t    0x0070:  0200 0200 0200 0200 0200 0200 0200 8202\n\t    0x0080:  0002 0002 0002 0002 0002 0002 0002 0002\n\t    0x0090:  0002 0002 0002 0002 0002 0002 0002 0002\n\t    0x00a0:  0002 0002 0002 0002 0002 0002 0002 0002\n\t    0x00b0:  2002 0002 0002 0002 0002 0002 0002 0002\n\t    0x00c0:  0000 0200 0200 0002 0002 0000 0200 0200\n\t    0x00d0:  0002 0002 0000 0200 0200 0002 0002 0000\n\t    0x00e0:  0200 0200 0002 0002 0000 0200 0200 0002\n\t    0x00f0:  0002 0000 0200 0200 0002 0002 0000 0200\n\t    0x0100:  0200 0002 0002 0000 0200 0200 0002 0002\n\t    0x0110:  0000 0200 0200 0002 0002 0000 0200 0200\n\t    0x0120:  0002 0002 0000 0200 0200 0002 0002 0000\n\t    0x0130:  0200 0200 0002 0002 0000 0200 0200 0002\n\t    0x0140:  0002 0000 0200 0200 0002 0002 0000 0200\n\t    0x0150:  0200 0002 0002 0000 0200 0200 0002 0002\n\t    0x0160:  0000 0200 0200 0002 0002 0000 0200 0200\n\t    0x0170:  0002 0002 0000 0200 0200 0002 0002 0000\n\t    0x0180:  0200 0200 0002 0002 0000 0200 0200 0002\n\t    0x0190:  0002 0000 0200 0200 0002 0002 0000 0200\n\t    0x01a0:  0200 0002 0002 0000 0200 0200 0002 0002\n\t    0x01b0:  0000 0200 0200 0002 0002 0000 0200 0200\n\t    0x01c0:  0002 0002 0000 0200 0200 0002 0002 0000\n\t    0x01d0:  0200 0200 0002 0002 0000 0200 0200 0002\n\t    0x01e0:  0002 0000 0200 0200 0002 0002 0000 0200\n\t    0x01f0:  0200 0002 0002 0000 0200 0200 0002 0002\n\t  Unknown Object (0), Class-Type: Unknown (0) Flags: [non-negotiable], length: 512\n\t\t packet exceeded snapshot\n"], "fixing_code": ["/*\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that: (1) source code\n * distributions retain the above copyright notice and this paragraph\n * in its entirety, and (2) distributions including binary code include\n * the above copyright notice and this paragraph in its entirety in\n * the documentation or other materials provided with the distribution.\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND\n * WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, WITHOUT\n * LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n * FOR A PARTICULAR PURPOSE.\n *\n * Original code by Hannes Gredler (hannes@gredler.at)\n * Support for LMP service discovery extensions (defined by OIF UNI 1.0)\n * added by Manu Pathak (mapathak@cisco.com), May 2005\n */\n\n/* \\summary: Link Management Protocol (LMP) printer */\n\n/* specification: RFC 4204 */\n/* OIF UNI 1.0: http://www.oiforum.com/public/documents/OIF-UNI-01.0.pdf */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <netdissect-stdinc.h>\n\n#include \"netdissect.h\"\n#include \"extract.h\"\n#include \"addrtoname.h\"\n#include \"gmpls.h\"\n\nstatic const char tstr[] = \" [|LMP]\";\n\n/*\n * LMP common header\n *\n *  0                   1                   2                   3\n *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n * | Vers  |      (Reserved)       |    Flags      |    Msg Type   |\n * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n * |          LMP Length           |          (Reserved)           |\n * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n */\n\nstruct lmp_common_header {\n    uint8_t version_res[2];\n    uint8_t flags;\n    uint8_t msg_type;\n    uint8_t length[2];\n    uint8_t reserved[2];\n};\n\n#define LMP_VERSION            1\n#define\tLMP_EXTRACT_VERSION(x) (((x)&0xf0)>>4)\n\nstatic const struct tok lmp_header_flag_values[] = {\n    { 0x01, \"Control Channel Down\"},\n    { 0x02, \"LMP restart\"},\n    { 0, NULL}\n};\n\nstatic const struct tok lmp_obj_te_link_flag_values[] = {\n    { 0x01, \"Fault Management Supported\"},\n    { 0x02, \"Link Verification Supported\"},\n    { 0, NULL}\n};\n\nstatic const struct tok lmp_obj_data_link_flag_values[] = {\n    { 0x01, \"Data Link Port\"},\n    { 0x02, \"Allocated for user traffic\"},\n    { 0x04, \"Failed link\"},\n    { 0, NULL}\n};\n\nstatic const struct tok lmp_obj_channel_status_values[] = {\n    { 1, \"Signal Okay\"},\n    { 2, \"Signal Degraded\"},\n    { 3, \"Signal Fail\"},\n    { 0, NULL}\n};\n\nstatic const struct tok lmp_obj_begin_verify_flag_values[] = {\n    { 0x0001, \"Verify all links\"},\n    { 0x0002, \"Data link type\"},\n    { 0, NULL}\n};\n\nstatic const struct tok lmp_obj_begin_verify_error_values[] = {\n    { 0x01, \"Link Verification Procedure Not supported\"},\n    { 0x02, \"Unwilling to verify\"},\n    { 0x04, \"Unsupported verification transport mechanism\"},\n    { 0x08, \"Link-Id configuration error\"},\n    { 0x10, \"Unknown object c-type\"},\n    { 0, NULL}\n};\n\nstatic const struct tok lmp_obj_link_summary_error_values[] = {\n    { 0x01, \"Unacceptable non-negotiable LINK-SUMMARY parameters\"},\n    { 0x02, \"Renegotiate LINK-SUMMARY parameters\"},\n    { 0x04, \"Invalid TE-LINK Object\"},\n    { 0x08, \"Invalid DATA-LINK Object\"},\n    { 0x10, \"Unknown TE-LINK Object c-type\"},\n    { 0x20, \"Unknown DATA-LINK Object c-type\"},\n    { 0, NULL}\n};\n\n/* Service Config Supported Protocols Flags */\nstatic const struct tok lmp_obj_service_config_sp_flag_values[] = {\n    { 0x01, \"RSVP Supported\"},\n    { 0x02, \"LDP Supported\"},\n    { 0, NULL}\n};\n\n/* Service Config Client Port Service Attribute Transparency Flags */\nstatic const struct tok lmp_obj_service_config_cpsa_tp_flag_values[] = {\n    { 0x01, \"Path/VC Overhead Transparency Supported\"},\n    { 0x02, \"Line/MS Overhead Transparency Supported\"},\n    { 0x04, \"Section/RS Overhead Transparency Supported\"},\n    { 0, NULL}\n};\n\n/* Service Config Client Port Service Attribute Contiguous Concatenation Types Flags */\nstatic const struct tok lmp_obj_service_config_cpsa_cct_flag_values[] = {\n    { 0x01, \"Contiguous Concatenation Types Supported\"},\n    { 0, NULL}\n};\n\n/* Service Config Network Service Attributes Transparency Flags */\nstatic const struct tok lmp_obj_service_config_nsa_transparency_flag_values[] = {\n    { 0x01, \"Standard SOH/RSOH Transparency Supported\"},\n    { 0x02, \"Standard LOH/MSOH Transparency Supported\"},\n    { 0, NULL}\n};\n\n/* Service Config Network Service Attributes TCM Monitoring Flags */\nstatic const struct tok lmp_obj_service_config_nsa_tcm_flag_values[] = {\n    { 0x01, \"Transparent Tandem Connection Monitoring Supported\"},\n    { 0, NULL}\n};\n\n/* Network Service Attributes Network Diversity Flags */\nstatic const struct tok lmp_obj_service_config_nsa_network_diversity_flag_values[] = {\n    { 0x01, \"Node Diversity Supported\"},\n    { 0x02, \"Link Diversity Supported\"},\n    { 0x04, \"SRLG Diversity Supported\"},\n    { 0, NULL}\n};\n\n#define\tLMP_MSGTYPE_CONFIG                 1\n#define\tLMP_MSGTYPE_CONFIG_ACK             2\n#define\tLMP_MSGTYPE_CONFIG_NACK            3\n#define\tLMP_MSGTYPE_HELLO                  4\n#define\tLMP_MSGTYPE_VERIFY_BEGIN           5\n#define\tLMP_MSGTYPE_VERIFY_BEGIN_ACK       6\n#define\tLMP_MSGTYPE_VERIFY_BEGIN_NACK      7\n#define LMP_MSGTYPE_VERIFY_END             8\n#define LMP_MSGTYPE_VERIFY_END_ACK         9\n#define LMP_MSGTYPE_TEST                  10\n#define LMP_MSGTYPE_TEST_STATUS_SUCCESS   11\n#define\tLMP_MSGTYPE_TEST_STATUS_FAILURE   12\n#define\tLMP_MSGTYPE_TEST_STATUS_ACK       13\n#define\tLMP_MSGTYPE_LINK_SUMMARY          14\n#define\tLMP_MSGTYPE_LINK_SUMMARY_ACK      15\n#define\tLMP_MSGTYPE_LINK_SUMMARY_NACK     16\n#define\tLMP_MSGTYPE_CHANNEL_STATUS        17\n#define\tLMP_MSGTYPE_CHANNEL_STATUS_ACK    18\n#define\tLMP_MSGTYPE_CHANNEL_STATUS_REQ    19\n#define\tLMP_MSGTYPE_CHANNEL_STATUS_RESP   20\n/* LMP Service Discovery message types defined by UNI 1.0 */\n#define LMP_MSGTYPE_SERVICE_CONFIG        50\n#define LMP_MSGTYPE_SERVICE_CONFIG_ACK    51\n#define LMP_MSGTYPE_SERVICE_CONFIG_NACK   52\n\nstatic const struct tok lmp_msg_type_values[] = {\n    { LMP_MSGTYPE_CONFIG, \"Config\"},\n    { LMP_MSGTYPE_CONFIG_ACK, \"Config ACK\"},\n    { LMP_MSGTYPE_CONFIG_NACK, \"Config NACK\"},\n    { LMP_MSGTYPE_HELLO, \"Hello\"},\n    { LMP_MSGTYPE_VERIFY_BEGIN, \"Begin Verify\"},\n    { LMP_MSGTYPE_VERIFY_BEGIN_ACK, \"Begin Verify ACK\"},\n    { LMP_MSGTYPE_VERIFY_BEGIN_NACK, \"Begin Verify NACK\"},\n    { LMP_MSGTYPE_VERIFY_END, \"End Verify\"},\n    { LMP_MSGTYPE_VERIFY_END_ACK, \"End Verify ACK\"},\n    { LMP_MSGTYPE_TEST, \"Test\"},\n    { LMP_MSGTYPE_TEST_STATUS_SUCCESS, \"Test Status Success\"},\n    { LMP_MSGTYPE_TEST_STATUS_FAILURE, \"Test Status Failure\"},\n    { LMP_MSGTYPE_TEST_STATUS_ACK, \"Test Status ACK\"},\n    { LMP_MSGTYPE_LINK_SUMMARY, \"Link Summary\"},\n    { LMP_MSGTYPE_LINK_SUMMARY_ACK, \"Link Summary ACK\"},\n    { LMP_MSGTYPE_LINK_SUMMARY_NACK, \"Link Summary NACK\"},\n    { LMP_MSGTYPE_CHANNEL_STATUS, \"Channel Status\"},\n    { LMP_MSGTYPE_CHANNEL_STATUS_ACK, \"Channel Status ACK\"},\n    { LMP_MSGTYPE_CHANNEL_STATUS_REQ, \"Channel Status Request\"},\n    { LMP_MSGTYPE_CHANNEL_STATUS_RESP, \"Channel Status Response\"},\n    { LMP_MSGTYPE_SERVICE_CONFIG, \"Service Config\"},\n    { LMP_MSGTYPE_SERVICE_CONFIG_ACK, \"Service Config ACK\"},\n    { LMP_MSGTYPE_SERVICE_CONFIG_NACK, \"Service Config NACK\"},\n    { 0, NULL}\n};\n\n/*\n * LMP object header\n *\n *  0                   1                   2                   3\n *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n * |N|   C-Type    |     Class     |            Length             |\n * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n * |                                                               |\n * //                       (object contents)                     //\n * |                                                               |\n * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n */\n\nstruct lmp_object_header {\n    uint8_t ctype;\n    uint8_t class_num;\n    uint8_t length[2];\n};\n\n#define\tLMP_OBJ_CC_ID                 1\n#define\tLMP_OBJ_NODE_ID               2\n#define\tLMP_OBJ_LINK_ID               3\n#define\tLMP_OBJ_INTERFACE_ID          4\n#define\tLMP_OBJ_MESSAGE_ID            5\n#define\tLMP_OBJ_CONFIG                6\n#define\tLMP_OBJ_HELLO                 7\n#define\tLMP_OBJ_VERIFY_BEGIN          8\n#define LMP_OBJ_VERIFY_BEGIN_ACK      9\n#define LMP_OBJ_VERIFY_ID            10\n#define LMP_OBJ_TE_LINK              11\n#define LMP_OBJ_DATA_LINK            12\n#define LMP_OBJ_CHANNEL_STATUS       13\n#define LMP_OBJ_CHANNEL_STATUS_REQ   14\n#define LMP_OBJ_ERROR_CODE           20\n\n#define LMP_OBJ_SERVICE_CONFIG       51 /* defined in UNI 1.0 */\n\nstatic const struct tok lmp_obj_values[] = {\n    { LMP_OBJ_CC_ID, \"Control Channel ID\" },\n    { LMP_OBJ_NODE_ID, \"Node ID\" },\n    { LMP_OBJ_LINK_ID, \"Link ID\" },\n    { LMP_OBJ_INTERFACE_ID, \"Interface ID\" },\n    { LMP_OBJ_MESSAGE_ID, \"Message ID\" },\n    { LMP_OBJ_CONFIG, \"Configuration\" },\n    { LMP_OBJ_HELLO, \"Hello\" },\n    { LMP_OBJ_VERIFY_BEGIN, \"Verify Begin\" },\n    { LMP_OBJ_VERIFY_BEGIN_ACK, \"Verify Begin ACK\" },\n    { LMP_OBJ_VERIFY_ID, \"Verify ID\" },\n    { LMP_OBJ_TE_LINK, \"TE Link\" },\n    { LMP_OBJ_DATA_LINK, \"Data Link\" },\n    { LMP_OBJ_CHANNEL_STATUS, \"Channel Status\" },\n    { LMP_OBJ_CHANNEL_STATUS_REQ, \"Channel Status Request\" },\n    { LMP_OBJ_ERROR_CODE, \"Error Code\" },\n    { LMP_OBJ_SERVICE_CONFIG, \"Service Config\" },\n\n    { 0, NULL}\n};\n\n#define INT_SWITCHING_TYPE_SUBOBJ 1\n#define WAVELENGTH_SUBOBJ         2\n\nstatic const struct tok lmp_data_link_subobj[] = {\n    { INT_SWITCHING_TYPE_SUBOBJ, \"Interface Switching Type\" },\n    { WAVELENGTH_SUBOBJ        , \"Wavelength\" },\n    { 0, NULL}\n};\n\n#define\tLMP_CTYPE_IPV4       1\n#define\tLMP_CTYPE_IPV6       2\n\n#define\tLMP_CTYPE_LOC        1\n#define\tLMP_CTYPE_RMT        2\n#define\tLMP_CTYPE_UNMD       3\n\n#define\tLMP_CTYPE_IPV4_LOC   1\n#define\tLMP_CTYPE_IPV4_RMT   2\n#define\tLMP_CTYPE_IPV6_LOC   3\n#define\tLMP_CTYPE_IPV6_RMT   4\n#define\tLMP_CTYPE_UNMD_LOC   5\n#define\tLMP_CTYPE_UNMD_RMT   6\n\n#define\tLMP_CTYPE_1          1\n#define\tLMP_CTYPE_2          2\n\n#define LMP_CTYPE_HELLO_CONFIG  1\n#define LMP_CTYPE_HELLO         1\n\n#define LMP_CTYPE_BEGIN_VERIFY_ERROR 1\n#define LMP_CTYPE_LINK_SUMMARY_ERROR 2\n\n/* C-Types for Service Config Object */\n#define LMP_CTYPE_SERVICE_CONFIG_SP                   1\n#define LMP_CTYPE_SERVICE_CONFIG_CPSA                 2\n#define LMP_CTYPE_SERVICE_CONFIG_TRANSPARENCY_TCM     3\n#define LMP_CTYPE_SERVICE_CONFIG_NETWORK_DIVERSITY    4\n\n/*\n * Different link types allowed in the Client Port Service Attributes\n * subobject defined for LMP Service Discovery in the UNI 1.0 spec\n */\n#define LMP_SD_SERVICE_CONFIG_CPSA_LINK_TYPE_SDH     5 /* UNI 1.0 Sec 9.4.2 */\n#define LMP_SD_SERVICE_CONFIG_CPSA_LINK_TYPE_SONET   6 /* UNI 1.0 Sec 9.4.2 */\n\n/*\n * the ctypes are not globally unique so for\n * translating it to strings we build a table based\n * on objects offsetted by the ctype\n */\n\nstatic const struct tok lmp_ctype_values[] = {\n    { 256*LMP_OBJ_CC_ID+LMP_CTYPE_LOC, \"Local\" },\n    { 256*LMP_OBJ_CC_ID+LMP_CTYPE_RMT, \"Remote\" },\n    { 256*LMP_OBJ_NODE_ID+LMP_CTYPE_LOC, \"Local\" },\n    { 256*LMP_OBJ_NODE_ID+LMP_CTYPE_RMT, \"Remote\" },\n    { 256*LMP_OBJ_LINK_ID+LMP_CTYPE_IPV4_LOC, \"IPv4 Local\" },\n    { 256*LMP_OBJ_LINK_ID+LMP_CTYPE_IPV4_RMT, \"IPv4 Remote\" },\n    { 256*LMP_OBJ_LINK_ID+LMP_CTYPE_IPV6_LOC, \"IPv6 Local\" },\n    { 256*LMP_OBJ_LINK_ID+LMP_CTYPE_IPV6_RMT, \"IPv6 Remote\" },\n    { 256*LMP_OBJ_LINK_ID+LMP_CTYPE_UNMD_LOC, \"Unnumbered Local\" },\n    { 256*LMP_OBJ_LINK_ID+LMP_CTYPE_UNMD_RMT, \"Unnumbered Remote\" },\n    { 256*LMP_OBJ_INTERFACE_ID+LMP_CTYPE_IPV4_LOC, \"IPv4 Local\" },\n    { 256*LMP_OBJ_INTERFACE_ID+LMP_CTYPE_IPV4_RMT, \"IPv4 Remote\" },\n    { 256*LMP_OBJ_INTERFACE_ID+LMP_CTYPE_IPV6_LOC, \"IPv6 Local\" },\n    { 256*LMP_OBJ_INTERFACE_ID+LMP_CTYPE_IPV6_RMT, \"IPv6 Remote\" },\n    { 256*LMP_OBJ_INTERFACE_ID+LMP_CTYPE_UNMD_LOC, \"Unnumbered Local\" },\n    { 256*LMP_OBJ_INTERFACE_ID+LMP_CTYPE_UNMD_RMT, \"Unnumbered Remote\" },\n    { 256*LMP_OBJ_MESSAGE_ID+LMP_CTYPE_1, \"1\" },\n    { 256*LMP_OBJ_MESSAGE_ID+LMP_CTYPE_2, \"2\" },\n    { 256*LMP_OBJ_CONFIG+LMP_CTYPE_1, \"1\" },\n    { 256*LMP_OBJ_HELLO+LMP_CTYPE_1, \"1\" },\n    { 256*LMP_OBJ_VERIFY_BEGIN+LMP_CTYPE_1, \"1\" },\n    { 256*LMP_OBJ_VERIFY_BEGIN_ACK+LMP_CTYPE_1, \"1\" },\n    { 256*LMP_OBJ_VERIFY_ID+LMP_CTYPE_1, \"1\" },\n    { 256*LMP_OBJ_TE_LINK+LMP_CTYPE_IPV4, \"IPv4\" },\n    { 256*LMP_OBJ_TE_LINK+LMP_CTYPE_IPV6, \"IPv6\" },\n    { 256*LMP_OBJ_TE_LINK+LMP_CTYPE_UNMD, \"Unnumbered\" },\n    { 256*LMP_OBJ_DATA_LINK+LMP_CTYPE_IPV4, \"IPv4\" },\n    { 256*LMP_OBJ_DATA_LINK+LMP_CTYPE_IPV6, \"IPv6\" },\n    { 256*LMP_OBJ_DATA_LINK+LMP_CTYPE_UNMD, \"Unnumbered\" },\n    { 256*LMP_OBJ_CHANNEL_STATUS+LMP_CTYPE_IPV4, \"IPv4\" },\n    { 256*LMP_OBJ_CHANNEL_STATUS+LMP_CTYPE_IPV6, \"IPv6\" },\n    { 256*LMP_OBJ_CHANNEL_STATUS+LMP_CTYPE_UNMD, \"Unnumbered\" },\n    { 256*LMP_OBJ_CHANNEL_STATUS_REQ+LMP_CTYPE_IPV4, \"IPv4\" },\n    { 256*LMP_OBJ_CHANNEL_STATUS_REQ+LMP_CTYPE_IPV6, \"IPv6\" },\n    { 256*LMP_OBJ_CHANNEL_STATUS_REQ+LMP_CTYPE_UNMD, \"Unnumbered\" },\n    { 256*LMP_OBJ_ERROR_CODE+LMP_CTYPE_1, \"1\" },\n    { 256*LMP_OBJ_ERROR_CODE+LMP_CTYPE_2, \"2\" },\n    { 256*LMP_OBJ_SERVICE_CONFIG+LMP_CTYPE_SERVICE_CONFIG_SP, \"1\" },\n    { 256*LMP_OBJ_SERVICE_CONFIG+LMP_CTYPE_SERVICE_CONFIG_CPSA, \"2\" },\n    { 256*LMP_OBJ_SERVICE_CONFIG+LMP_CTYPE_SERVICE_CONFIG_TRANSPARENCY_TCM, \"3\" },\n    { 256*LMP_OBJ_SERVICE_CONFIG+LMP_CTYPE_SERVICE_CONFIG_NETWORK_DIVERSITY, \"4\" },\n    { 0, NULL}\n};\n\nstatic int\nlmp_print_data_link_subobjs(netdissect_options *ndo, const u_char *obj_tptr,\n                            int total_subobj_len, int offset)\n{\n    int hexdump = FALSE;\n    int subobj_type, subobj_len;\n\n    union { /* int to float conversion buffer */\n        float f;\n        uint32_t i;\n    } bw;\n\n    while (total_subobj_len > 0 && hexdump == FALSE ) {\n\tND_TCHECK_16BITS(obj_tptr + offset);\n\tsubobj_type = EXTRACT_8BITS(obj_tptr + offset);\n\tsubobj_len  = EXTRACT_8BITS(obj_tptr + offset + 1);\n\tND_PRINT((ndo, \"\\n\\t    Subobject, Type: %s (%u), Length: %u\",\n\t\ttok2str(lmp_data_link_subobj,\n\t\t\t\"Unknown\",\n\t\t\tsubobj_type),\n\t\t\tsubobj_type,\n\t\t\tsubobj_len));\n\tif (subobj_len < 4) {\n\t    ND_PRINT((ndo, \" (too short)\"));\n\t    break;\n\t}\n\tif ((subobj_len % 4) != 0) {\n\t    ND_PRINT((ndo, \" (not a multiple of 4)\"));\n\t    break;\n\t}\n\tif (total_subobj_len < subobj_len) {\n\t    ND_PRINT((ndo, \" (goes past the end of the object)\"));\n\t    break;\n\t}\n\tswitch(subobj_type) {\n\tcase INT_SWITCHING_TYPE_SUBOBJ:\n\t    ND_TCHECK_8BITS(obj_tptr + offset + 2);\n\t    ND_PRINT((ndo, \"\\n\\t      Switching Type: %s (%u)\",\n\t\ttok2str(gmpls_switch_cap_values,\n\t\t\t\"Unknown\",\n\t\t\tEXTRACT_8BITS(obj_tptr + offset + 2)),\n\t\t\tEXTRACT_8BITS(obj_tptr + offset + 2)));\n\t    ND_TCHECK_8BITS(obj_tptr + offset + 3);\n\t    ND_PRINT((ndo, \"\\n\\t      Encoding Type: %s (%u)\",\n\t\ttok2str(gmpls_encoding_values,\n\t\t\t\"Unknown\",\n\t\t\tEXTRACT_8BITS(obj_tptr + offset + 3)),\n\t\t\tEXTRACT_8BITS(obj_tptr + offset + 3)));\n\t    ND_TCHECK_32BITS(obj_tptr + offset + 4);\n\t    bw.i = EXTRACT_32BITS(obj_tptr+offset+4);\n\t    ND_PRINT((ndo, \"\\n\\t      Min Reservable Bandwidth: %.3f Mbps\",\n                bw.f*8/1000000));\n\t    ND_TCHECK_32BITS(obj_tptr + offset + 8);\n\t    bw.i = EXTRACT_32BITS(obj_tptr+offset+8);\n\t    ND_PRINT((ndo, \"\\n\\t      Max Reservable Bandwidth: %.3f Mbps\",\n                bw.f*8/1000000));\n\t    break;\n\tcase WAVELENGTH_SUBOBJ:\n\t    ND_TCHECK_32BITS(obj_tptr + offset + 4);\n\t    ND_PRINT((ndo, \"\\n\\t      Wavelength: %u\",\n\t\tEXTRACT_32BITS(obj_tptr+offset+4)));\n\t    break;\n\tdefault:\n\t    /* Any Unknown Subobject ==> Exit loop */\n\t    hexdump=TRUE;\n\t    break;\n\t}\n\ttotal_subobj_len-=subobj_len;\n\toffset+=subobj_len;\n    }\n    return (hexdump);\ntrunc:\n    return -1;\n}\n\nvoid\nlmp_print(netdissect_options *ndo,\n          register const u_char *pptr, register u_int len)\n{\n    const struct lmp_common_header *lmp_com_header;\n    const struct lmp_object_header *lmp_obj_header;\n    const u_char *tptr,*obj_tptr;\n    u_int tlen,lmp_obj_len,lmp_obj_ctype,obj_tlen;\n    int hexdump, ret;\n    u_int offset;\n    u_int link_type;\n\n    union { /* int to float conversion buffer */\n        float f;\n        uint32_t i;\n    } bw;\n\n    tptr=pptr;\n    lmp_com_header = (const struct lmp_common_header *)pptr;\n    ND_TCHECK(*lmp_com_header);\n\n    /*\n     * Sanity checking of the header.\n     */\n    if (LMP_EXTRACT_VERSION(lmp_com_header->version_res[0]) != LMP_VERSION) {\n\tND_PRINT((ndo, \"LMP version %u packet not supported\",\n               LMP_EXTRACT_VERSION(lmp_com_header->version_res[0])));\n\treturn;\n    }\n\n    /* in non-verbose mode just lets print the basic Message Type*/\n    if (ndo->ndo_vflag < 1) {\n        ND_PRINT((ndo, \"LMPv%u %s Message, length: %u\",\n               LMP_EXTRACT_VERSION(lmp_com_header->version_res[0]),\n               tok2str(lmp_msg_type_values, \"unknown (%u)\",lmp_com_header->msg_type),\n               len));\n        return;\n    }\n\n    /* ok they seem to want to know everything - lets fully decode it */\n\n    tlen=EXTRACT_16BITS(lmp_com_header->length);\n\n    ND_PRINT((ndo, \"\\n\\tLMPv%u, msg-type: %s, Flags: [%s], length: %u\",\n           LMP_EXTRACT_VERSION(lmp_com_header->version_res[0]),\n           tok2str(lmp_msg_type_values, \"unknown, type: %u\",lmp_com_header->msg_type),\n           bittok2str(lmp_header_flag_values,\"none\",lmp_com_header->flags),\n           tlen));\n    if (tlen < sizeof(const struct lmp_common_header)) {\n        ND_PRINT((ndo, \" (too short)\"));\n        return;\n    }\n    if (tlen > len) {\n        ND_PRINT((ndo, \" (too long)\"));\n        tlen = len;\n    }\n\n    tptr+=sizeof(const struct lmp_common_header);\n    tlen-=sizeof(const struct lmp_common_header);\n\n    while(tlen>0) {\n        /* did we capture enough for fully decoding the object header ? */\n        ND_TCHECK2(*tptr, sizeof(struct lmp_object_header));\n\n        lmp_obj_header = (const struct lmp_object_header *)tptr;\n        lmp_obj_len=EXTRACT_16BITS(lmp_obj_header->length);\n        lmp_obj_ctype=(lmp_obj_header->ctype)&0x7f;\n\n        ND_PRINT((ndo, \"\\n\\t  %s Object (%u), Class-Type: %s (%u) Flags: [%snegotiable], length: %u\",\n               tok2str(lmp_obj_values,\n                       \"Unknown\",\n                       lmp_obj_header->class_num),\n               lmp_obj_header->class_num,\n               tok2str(lmp_ctype_values,\n                       \"Unknown\",\n                       ((lmp_obj_header->class_num)<<8)+lmp_obj_ctype),\n               lmp_obj_ctype,\n               (lmp_obj_header->ctype)&0x80 ? \"\" : \"non-\",\n               lmp_obj_len));\n\n        if (lmp_obj_len < 4) {\n            ND_PRINT((ndo, \" (too short)\"));\n            return;\n        }\n        if ((lmp_obj_len % 4) != 0) {\n            ND_PRINT((ndo, \" (not a multiple of 4)\"));\n            return;\n        }\n\n        obj_tptr=tptr+sizeof(struct lmp_object_header);\n        obj_tlen=lmp_obj_len-sizeof(struct lmp_object_header);\n\n        /* did we capture enough for fully decoding the object ? */\n        ND_TCHECK2(*tptr, lmp_obj_len);\n        hexdump=FALSE;\n\n        switch(lmp_obj_header->class_num) {\n\n        case LMP_OBJ_CC_ID:\n            switch(lmp_obj_ctype) {\n            case LMP_CTYPE_LOC:\n            case LMP_CTYPE_RMT:\n                if (obj_tlen != 4) {\n                    ND_PRINT((ndo, \" (not correct for object)\"));\n                    break;\n                }\n                ND_PRINT((ndo, \"\\n\\t    Control Channel ID: %u (0x%08x)\",\n                       EXTRACT_32BITS(obj_tptr),\n                       EXTRACT_32BITS(obj_tptr)));\n                break;\n\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case LMP_OBJ_LINK_ID:\n        case LMP_OBJ_INTERFACE_ID:\n            switch(lmp_obj_ctype) {\n            case LMP_CTYPE_IPV4_LOC:\n            case LMP_CTYPE_IPV4_RMT:\n                if (obj_tlen != 4) {\n                    ND_PRINT((ndo, \" (not correct for object)\"));\n                    break;\n                }\n                ND_PRINT((ndo, \"\\n\\t    IPv4 Link ID: %s (0x%08x)\",\n                       ipaddr_string(ndo, obj_tptr),\n                       EXTRACT_32BITS(obj_tptr)));\n                break;\n            case LMP_CTYPE_IPV6_LOC:\n            case LMP_CTYPE_IPV6_RMT:\n                if (obj_tlen != 16) {\n                    ND_PRINT((ndo, \" (not correct for object)\"));\n                    break;\n                }\n                ND_PRINT((ndo, \"\\n\\t    IPv6 Link ID: %s (0x%08x)\",\n                       ip6addr_string(ndo, obj_tptr),\n                       EXTRACT_32BITS(obj_tptr)));\n                break;\n            case LMP_CTYPE_UNMD_LOC:\n            case LMP_CTYPE_UNMD_RMT:\n                if (obj_tlen != 4) {\n                    ND_PRINT((ndo, \" (not correct for object)\"));\n                    break;\n                }\n                ND_PRINT((ndo, \"\\n\\t    Link ID: %u (0x%08x)\",\n                       EXTRACT_32BITS(obj_tptr),\n                       EXTRACT_32BITS(obj_tptr)));\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case LMP_OBJ_MESSAGE_ID:\n            switch(lmp_obj_ctype) {\n            case LMP_CTYPE_1:\n                if (obj_tlen != 4) {\n                    ND_PRINT((ndo, \" (not correct for object)\"));\n                    break;\n                }\n                ND_PRINT((ndo, \"\\n\\t    Message ID: %u (0x%08x)\",\n                       EXTRACT_32BITS(obj_tptr),\n                       EXTRACT_32BITS(obj_tptr)));\n                break;\n            case LMP_CTYPE_2:\n                if (obj_tlen != 4) {\n                    ND_PRINT((ndo, \" (not correct for object)\"));\n                    break;\n                }\n                ND_PRINT((ndo, \"\\n\\t    Message ID Ack: %u (0x%08x)\",\n                       EXTRACT_32BITS(obj_tptr),\n                       EXTRACT_32BITS(obj_tptr)));\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case LMP_OBJ_NODE_ID:\n            switch(lmp_obj_ctype) {\n            case LMP_CTYPE_LOC:\n            case LMP_CTYPE_RMT:\n                if (obj_tlen != 4) {\n                    ND_PRINT((ndo, \" (not correct for object)\"));\n                    break;\n                }\n                ND_PRINT((ndo, \"\\n\\t    Node ID: %s (0x%08x)\",\n                       ipaddr_string(ndo, obj_tptr),\n                       EXTRACT_32BITS(obj_tptr)));\n                break;\n\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case LMP_OBJ_CONFIG:\n            switch(lmp_obj_ctype) {\n            case LMP_CTYPE_HELLO_CONFIG:\n                if (obj_tlen != 4) {\n                    ND_PRINT((ndo, \" (not correct for object)\"));\n                    break;\n                }\n                ND_PRINT((ndo, \"\\n\\t    Hello Interval: %u\\n\\t    Hello Dead Interval: %u\",\n                       EXTRACT_16BITS(obj_tptr),\n                       EXTRACT_16BITS(obj_tptr+2)));\n                break;\n\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case LMP_OBJ_HELLO:\n            switch(lmp_obj_ctype) {\n\t    case LMP_CTYPE_HELLO:\n                if (obj_tlen != 8) {\n                    ND_PRINT((ndo, \" (not correct for object)\"));\n                    break;\n                }\n                ND_PRINT((ndo, \"\\n\\t    Tx Seq: %u, Rx Seq: %u\",\n                       EXTRACT_32BITS(obj_tptr),\n                       EXTRACT_32BITS(obj_tptr+4)));\n                break;\n\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case LMP_OBJ_TE_LINK:\n\t    switch(lmp_obj_ctype) {\n\t    case LMP_CTYPE_IPV4:\n                if (obj_tlen != 12) {\n                    ND_PRINT((ndo, \" (not correct for object)\"));\n                    break;\n                }\n\t\tND_PRINT((ndo, \"\\n\\t    Flags: [%s]\",\n\t\t    bittok2str(lmp_obj_te_link_flag_values,\n\t\t\t\"none\",\n\t\t\tEXTRACT_8BITS(obj_tptr))));\n\n\t\tND_PRINT((ndo, \"\\n\\t    Local Link-ID: %s (0x%08x)\"\n\t\t       \"\\n\\t    Remote Link-ID: %s (0x%08x)\",\n                       ipaddr_string(ndo, obj_tptr+4),\n                       EXTRACT_32BITS(obj_tptr+4),\n                       ipaddr_string(ndo, obj_tptr+8),\n                       EXTRACT_32BITS(obj_tptr+8)));\n\t\tbreak;\n\n\t    case LMP_CTYPE_IPV6:\n                if (obj_tlen != 36) {\n                    ND_PRINT((ndo, \" (not correct for object)\"));\n                    break;\n                }\n\t\tND_PRINT((ndo, \"\\n\\t    Flags: [%s]\",\n\t\t    bittok2str(lmp_obj_te_link_flag_values,\n\t\t\t\"none\",\n\t\t\tEXTRACT_8BITS(obj_tptr))));\n\n\t\tND_PRINT((ndo, \"\\n\\t    Local Link-ID: %s (0x%08x)\"\n\t\t       \"\\n\\t    Remote Link-ID: %s (0x%08x)\",\n                       ip6addr_string(ndo, obj_tptr+4),\n                       EXTRACT_32BITS(obj_tptr+4),\n                       ip6addr_string(ndo, obj_tptr+20),\n                       EXTRACT_32BITS(obj_tptr+20)));\n                break;\n\n\t    case LMP_CTYPE_UNMD:\n                if (obj_tlen != 12) {\n                    ND_PRINT((ndo, \" (not correct for object)\"));\n                    break;\n                }\n\t\tND_PRINT((ndo, \"\\n\\t    Flags: [%s]\",\n\t\t    bittok2str(lmp_obj_te_link_flag_values,\n\t\t\t\"none\",\n\t\t\tEXTRACT_8BITS(obj_tptr))));\n\n\t\tND_PRINT((ndo, \"\\n\\t    Local Link-ID: %u (0x%08x)\"\n\t\t       \"\\n\\t    Remote Link-ID: %u (0x%08x)\",\n                       EXTRACT_32BITS(obj_tptr+4),\n                       EXTRACT_32BITS(obj_tptr+4),\n                       EXTRACT_32BITS(obj_tptr+8),\n                       EXTRACT_32BITS(obj_tptr+8)));\n\t\tbreak;\n\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case LMP_OBJ_DATA_LINK:\n\t    switch(lmp_obj_ctype) {\n\t    case LMP_CTYPE_IPV4:\n                if (obj_tlen < 12) {\n                    ND_PRINT((ndo, \" (not correct for object)\"));\n                    break;\n                }\n\t        ND_PRINT((ndo, \"\\n\\t    Flags: [%s]\",\n\t\t    bittok2str(lmp_obj_data_link_flag_values,\n\t\t\t\"none\",\n\t\t\tEXTRACT_8BITS(obj_tptr))));\n                ND_PRINT((ndo, \"\\n\\t    Local Interface ID: %s (0x%08x)\"\n                       \"\\n\\t    Remote Interface ID: %s (0x%08x)\",\n                       ipaddr_string(ndo, obj_tptr+4),\n                       EXTRACT_32BITS(obj_tptr+4),\n                       ipaddr_string(ndo, obj_tptr+8),\n                       EXTRACT_32BITS(obj_tptr+8)));\n\n\t\tret = lmp_print_data_link_subobjs(ndo, obj_tptr, obj_tlen - 12, 12);\n\t\tif (ret == -1)\n\t\t    goto trunc;\n\t\tif (ret == TRUE)\n\t\t    hexdump=TRUE;\n\t\tbreak;\n\n\t    case LMP_CTYPE_IPV6:\n                if (obj_tlen < 36) {\n                    ND_PRINT((ndo, \" (not correct for object)\"));\n                    break;\n                }\n\t        ND_PRINT((ndo, \"\\n\\t    Flags: [%s]\",\n\t\t    bittok2str(lmp_obj_data_link_flag_values,\n\t\t\t\"none\",\n\t\t\tEXTRACT_8BITS(obj_tptr))));\n                ND_PRINT((ndo, \"\\n\\t    Local Interface ID: %s (0x%08x)\"\n                       \"\\n\\t    Remote Interface ID: %s (0x%08x)\",\n                       ip6addr_string(ndo, obj_tptr+4),\n                       EXTRACT_32BITS(obj_tptr+4),\n                       ip6addr_string(ndo, obj_tptr+20),\n                       EXTRACT_32BITS(obj_tptr+20)));\n\n\t\tret = lmp_print_data_link_subobjs(ndo, obj_tptr, obj_tlen - 36, 36);\n\t\tif (ret == -1)\n\t\t    goto trunc;\n\t\tif (ret == TRUE)\n\t\t    hexdump=TRUE;\n\t\tbreak;\n\n\t    case LMP_CTYPE_UNMD:\n                if (obj_tlen < 12) {\n                    ND_PRINT((ndo, \" (not correct for object)\"));\n                    break;\n                }\n\t        ND_PRINT((ndo, \"\\n\\t    Flags: [%s]\",\n\t\t    bittok2str(lmp_obj_data_link_flag_values,\n\t\t\t\"none\",\n\t\t\tEXTRACT_8BITS(obj_tptr))));\n                ND_PRINT((ndo, \"\\n\\t    Local Interface ID: %u (0x%08x)\"\n                       \"\\n\\t    Remote Interface ID: %u (0x%08x)\",\n                       EXTRACT_32BITS(obj_tptr+4),\n                       EXTRACT_32BITS(obj_tptr+4),\n                       EXTRACT_32BITS(obj_tptr+8),\n                       EXTRACT_32BITS(obj_tptr+8)));\n\n\t\tret = lmp_print_data_link_subobjs(ndo, obj_tptr, obj_tlen - 12, 12);\n\t\tif (ret == -1)\n\t\t    goto trunc;\n\t\tif (ret == TRUE)\n\t\t    hexdump=TRUE;\n\t\tbreak;\n\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case LMP_OBJ_VERIFY_BEGIN:\n\t    switch(lmp_obj_ctype) {\n            case LMP_CTYPE_1:\n                if (obj_tlen != 20) {\n                    ND_PRINT((ndo, \" (not correct for object)\"));\n                    break;\n                }\n\t\tND_PRINT((ndo, \"\\n\\t    Flags: %s\",\n\t\tbittok2str(lmp_obj_begin_verify_flag_values,\n\t\t\t\"none\",\n\t\t\tEXTRACT_16BITS(obj_tptr))));\n\t\tND_PRINT((ndo, \"\\n\\t    Verify Interval: %u\",\n\t\t\tEXTRACT_16BITS(obj_tptr+2)));\n\t\tND_PRINT((ndo, \"\\n\\t    Data links: %u\",\n\t\t\tEXTRACT_32BITS(obj_tptr+4)));\n                ND_PRINT((ndo, \"\\n\\t    Encoding type: %s\",\n\t\t\ttok2str(gmpls_encoding_values, \"Unknown\", *(obj_tptr+8))));\n                ND_PRINT((ndo, \"\\n\\t    Verify Transport Mechanism: %u (0x%x)%s\",\n\t\t\tEXTRACT_16BITS(obj_tptr+10),\n\t\t\tEXTRACT_16BITS(obj_tptr+10),\n\t\t\tEXTRACT_16BITS(obj_tptr+10)&8000 ? \" (Payload test messages capable)\" : \"\"));\n                bw.i = EXTRACT_32BITS(obj_tptr+12);\n\t\tND_PRINT((ndo, \"\\n\\t    Transmission Rate: %.3f Mbps\",bw.f*8/1000000));\n\t\tND_PRINT((ndo, \"\\n\\t    Wavelength: %u\",\n\t\t\tEXTRACT_32BITS(obj_tptr+16)));\n\t\tbreak;\n\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case LMP_OBJ_VERIFY_BEGIN_ACK:\n\t    switch(lmp_obj_ctype) {\n            case LMP_CTYPE_1:\n                if (obj_tlen != 4) {\n                    ND_PRINT((ndo, \" (not correct for object)\"));\n                    break;\n                }\n                ND_PRINT((ndo, \"\\n\\t    Verify Dead Interval: %u\"\n                       \"\\n\\t    Verify Transport Response: %u\",\n                       EXTRACT_16BITS(obj_tptr),\n                       EXTRACT_16BITS(obj_tptr+2)));\n                break;\n\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n\tcase LMP_OBJ_VERIFY_ID:\n\t    switch(lmp_obj_ctype) {\n            case LMP_CTYPE_1:\n                if (obj_tlen != 4) {\n                    ND_PRINT((ndo, \" (not correct for object)\"));\n                    break;\n                }\n                ND_PRINT((ndo, \"\\n\\t    Verify ID: %u\",\n                       EXTRACT_32BITS(obj_tptr)));\n                break;\n\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n\tcase LMP_OBJ_CHANNEL_STATUS:\n            switch(lmp_obj_ctype) {\n\t    case LMP_CTYPE_IPV4:\n\t\toffset = 0;\n\t\t/* Decode pairs: <Interface_ID (4 bytes), Channel_status (4 bytes)> */\n\t\twhile (offset+8 <= obj_tlen) {\n\t\t\tND_PRINT((ndo, \"\\n\\t    Interface ID: %s (0x%08x)\",\n\t\t\tipaddr_string(ndo, obj_tptr+offset),\n\t\t\tEXTRACT_32BITS(obj_tptr+offset)));\n\n\t\t\tND_PRINT((ndo, \"\\n\\t\\t    Active: %s (%u)\",\n\t\t\t\t(EXTRACT_32BITS(obj_tptr+offset+4)>>31) ?\n\t\t\t\t\t\t\"Allocated\" : \"Non-allocated\",\n\t\t\t\t(EXTRACT_32BITS(obj_tptr+offset+4)>>31)));\n\n\t\t\tND_PRINT((ndo, \"\\n\\t\\t    Direction: %s (%u)\",\n\t\t\t\t(EXTRACT_32BITS(obj_tptr+offset+4)>>30)&0x1 ?\n\t\t\t\t\t\t\"Transmit\" : \"Receive\",\n\t\t\t\t(EXTRACT_32BITS(obj_tptr+offset+4)>>30)&0x1));\n\n\t\t\tND_PRINT((ndo, \"\\n\\t\\t    Channel Status: %s (%u)\",\n\t\t\t\t\ttok2str(lmp_obj_channel_status_values,\n\t\t\t \t\t\"Unknown\",\n\t\t\t\t\tEXTRACT_32BITS(obj_tptr+offset+4)&0x3FFFFFF),\n\t\t\tEXTRACT_32BITS(obj_tptr+offset+4)&0x3FFFFFF));\n\t\t\toffset+=8;\n\t\t}\n                break;\n\n\t    case LMP_CTYPE_IPV6:\n\t\toffset = 0;\n\t\t/* Decode pairs: <Interface_ID (16 bytes), Channel_status (4 bytes)> */\n\t\twhile (offset+20 <= obj_tlen) {\n\t\t\tND_PRINT((ndo, \"\\n\\t    Interface ID: %s (0x%08x)\",\n\t\t\tip6addr_string(ndo, obj_tptr+offset),\n\t\t\tEXTRACT_32BITS(obj_tptr+offset)));\n\n\t\t\tND_PRINT((ndo, \"\\n\\t\\t    Active: %s (%u)\",\n\t\t\t\t(EXTRACT_32BITS(obj_tptr+offset+16)>>31) ?\n\t\t\t\t\t\t\"Allocated\" : \"Non-allocated\",\n\t\t\t\t(EXTRACT_32BITS(obj_tptr+offset+16)>>31)));\n\n\t\t\tND_PRINT((ndo, \"\\n\\t\\t    Direction: %s (%u)\",\n\t\t\t\t(EXTRACT_32BITS(obj_tptr+offset+16)>>30)&0x1 ?\n\t\t\t\t\t\t\"Transmit\" : \"Receive\",\n\t\t\t\t(EXTRACT_32BITS(obj_tptr+offset+16)>>30)&0x1));\n\n\t\t\tND_PRINT((ndo, \"\\n\\t\\t    Channel Status: %s (%u)\",\n\t\t\t\t\ttok2str(lmp_obj_channel_status_values,\n\t\t\t\t\t\"Unknown\",\n\t\t\t\t\tEXTRACT_32BITS(obj_tptr+offset+16)&0x3FFFFFF),\n\t\t\tEXTRACT_32BITS(obj_tptr+offset+16)&0x3FFFFFF));\n\t\t\toffset+=20;\n\t\t}\n                break;\n\n\t    case LMP_CTYPE_UNMD:\n\t\toffset = 0;\n\t\t/* Decode pairs: <Interface_ID (4 bytes), Channel_status (4 bytes)> */\n\t\twhile (offset+8 <= obj_tlen) {\n\t\t\tND_PRINT((ndo, \"\\n\\t    Interface ID: %u (0x%08x)\",\n\t\t\tEXTRACT_32BITS(obj_tptr+offset),\n\t\t\tEXTRACT_32BITS(obj_tptr+offset)));\n\n\t\t\tND_PRINT((ndo, \"\\n\\t\\t    Active: %s (%u)\",\n\t\t\t\t(EXTRACT_32BITS(obj_tptr+offset+4)>>31) ?\n\t\t\t\t\t\t\"Allocated\" : \"Non-allocated\",\n\t\t\t\t(EXTRACT_32BITS(obj_tptr+offset+4)>>31)));\n\n\t\t\tND_PRINT((ndo, \"\\n\\t\\t    Direction: %s (%u)\",\n\t\t\t\t(EXTRACT_32BITS(obj_tptr+offset+4)>>30)&0x1 ?\n\t\t\t\t\t\t\"Transmit\" : \"Receive\",\n\t\t\t\t(EXTRACT_32BITS(obj_tptr+offset+4)>>30)&0x1));\n\n\t\t\tND_PRINT((ndo, \"\\n\\t\\t    Channel Status: %s (%u)\",\n\t\t\t\t\ttok2str(lmp_obj_channel_status_values,\n\t\t\t\t\t\"Unknown\",\n\t\t\t\t\tEXTRACT_32BITS(obj_tptr+offset+4)&0x3FFFFFF),\n\t\t\tEXTRACT_32BITS(obj_tptr+offset+4)&0x3FFFFFF));\n\t\t\toffset+=8;\n\t\t}\n                break;\n\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n\tcase LMP_OBJ_CHANNEL_STATUS_REQ:\n            switch(lmp_obj_ctype) {\n\t    case LMP_CTYPE_IPV4:\n\t\toffset = 0;\n\t\twhile (offset+4 <= obj_tlen) {\n\t\t\tND_PRINT((ndo, \"\\n\\t    Interface ID: %s (0x%08x)\",\n\t\t\tipaddr_string(ndo, obj_tptr+offset),\n\t\t\tEXTRACT_32BITS(obj_tptr+offset)));\n\t\t\toffset+=4;\n\t\t}\n                break;\n\n\t    case LMP_CTYPE_IPV6:\n\t\toffset = 0;\n\t\twhile (offset+16 <= obj_tlen) {\n\t\t\tND_PRINT((ndo, \"\\n\\t    Interface ID: %s (0x%08x)\",\n\t\t\tip6addr_string(ndo, obj_tptr+offset),\n\t\t\tEXTRACT_32BITS(obj_tptr+offset)));\n\t\t\toffset+=16;\n\t\t}\n                break;\n\n\t    case LMP_CTYPE_UNMD:\n\t\toffset = 0;\n\t\twhile (offset+4 <= obj_tlen) {\n\t\t\tND_PRINT((ndo, \"\\n\\t    Interface ID: %u (0x%08x)\",\n\t\t\tEXTRACT_32BITS(obj_tptr+offset),\n\t\t\tEXTRACT_32BITS(obj_tptr+offset)));\n\t\t\toffset+=4;\n\t\t}\n                break;\n\n\t    default:\n                hexdump=TRUE;\n            }\n            break;\n\n        case LMP_OBJ_ERROR_CODE:\n\t    switch(lmp_obj_ctype) {\n            case LMP_CTYPE_BEGIN_VERIFY_ERROR:\n                if (obj_tlen != 4) {\n                    ND_PRINT((ndo, \" (not correct for object)\"));\n                    break;\n                }\n\t\tND_PRINT((ndo, \"\\n\\t    Error Code: %s\",\n\t\tbittok2str(lmp_obj_begin_verify_error_values,\n\t\t\t\"none\",\n\t\t\tEXTRACT_32BITS(obj_tptr))));\n                break;\n\n            case LMP_CTYPE_LINK_SUMMARY_ERROR:\n                if (obj_tlen != 4) {\n                    ND_PRINT((ndo, \" (not correct for object)\"));\n                    break;\n                }\n\t\tND_PRINT((ndo, \"\\n\\t    Error Code: %s\",\n\t\tbittok2str(lmp_obj_link_summary_error_values,\n\t\t\t\"none\",\n\t\t\tEXTRACT_32BITS(obj_tptr))));\n                break;\n            default:\n                hexdump=TRUE;\n            }\n            break;\n\n\tcase LMP_OBJ_SERVICE_CONFIG:\n\t    switch (lmp_obj_ctype) {\n\t    case LMP_CTYPE_SERVICE_CONFIG_SP:\n                if (obj_tlen != 4) {\n                    ND_PRINT((ndo, \" (not correct for object)\"));\n                    break;\n                }\n\t\tND_PRINT((ndo, \"\\n\\t Flags: %s\",\n\t\t       bittok2str(lmp_obj_service_config_sp_flag_values,\n\t\t\t\t  \"none\",\n\t\t\t\t  EXTRACT_8BITS(obj_tptr))));\n\n\t\tND_PRINT((ndo, \"\\n\\t  UNI Version: %u\",\n\t\t       EXTRACT_8BITS(obj_tptr + 1)));\n\n\t\tbreak;\n\n            case LMP_CTYPE_SERVICE_CONFIG_CPSA:\n                if (obj_tlen != 16) {\n                    ND_PRINT((ndo, \" (not correct for object)\"));\n                    break;\n                }\n\n\t\tlink_type = EXTRACT_8BITS(obj_tptr);\n\n\t\tND_PRINT((ndo, \"\\n\\t Link Type: %s (%u)\",\n\t\t       tok2str(lmp_sd_service_config_cpsa_link_type_values,\n\t\t\t       \"Unknown\", link_type),\n\t\t       link_type));\n\n\t\tswitch (link_type) {\n\t\tcase LMP_SD_SERVICE_CONFIG_CPSA_LINK_TYPE_SDH:\n\t\t    ND_PRINT((ndo, \"\\n\\t Signal Type: %s (%u)\",\n\t\t\t   tok2str(lmp_sd_service_config_cpsa_signal_type_sdh_values,\n\t\t\t\t   \"Unknown\",\n\t\t\t\t   EXTRACT_8BITS(obj_tptr + 1)),\n\t\t\t\t   EXTRACT_8BITS(obj_tptr + 1)));\n\t\t    break;\n\n\t\tcase LMP_SD_SERVICE_CONFIG_CPSA_LINK_TYPE_SONET:\n\t\t    ND_PRINT((ndo, \"\\n\\t Signal Type: %s (%u)\",\n\t\t\t   tok2str(lmp_sd_service_config_cpsa_signal_type_sonet_values,\n\t\t\t\t   \"Unknown\",\n\t\t\t\t   EXTRACT_8BITS(obj_tptr + 1)),\n\t\t\t\t   EXTRACT_8BITS(obj_tptr + 1)));\n\t\t    break;\n\t\t}\n\n\t\tND_PRINT((ndo, \"\\n\\t Transparency: %s\",\n\t\t       bittok2str(lmp_obj_service_config_cpsa_tp_flag_values,\n\t\t\t\t  \"none\",\n\t\t\t\t  EXTRACT_8BITS(obj_tptr + 2))));\n\n\t\tND_PRINT((ndo, \"\\n\\t Contiguous Concatenation Types: %s\",\n\t\t       bittok2str(lmp_obj_service_config_cpsa_cct_flag_values,\n\t\t\t\t  \"none\",\n\t\t\t\t  EXTRACT_8BITS(obj_tptr + 3))));\n\n\t\tND_PRINT((ndo, \"\\n\\t Minimum NCC: %u\",\n\t\t       EXTRACT_16BITS(obj_tptr+4)));\n\n\t\tND_PRINT((ndo, \"\\n\\t Maximum NCC: %u\",\n\t\t       EXTRACT_16BITS(obj_tptr+6)));\n\n\t\tND_PRINT((ndo, \"\\n\\t Minimum NVC:%u\",\n\t\t       EXTRACT_16BITS(obj_tptr+8)));\n\n\t\tND_PRINT((ndo, \"\\n\\t Maximum NVC:%u\",\n\t\t       EXTRACT_16BITS(obj_tptr+10)));\n\n\t\tND_PRINT((ndo, \"\\n\\t    Local Interface ID: %s (0x%08x)\",\n\t\t       ipaddr_string(ndo, obj_tptr+12),\n\t\t       EXTRACT_32BITS(obj_tptr+12)));\n\n\t\tbreak;\n\n\t    case LMP_CTYPE_SERVICE_CONFIG_TRANSPARENCY_TCM:\n                if (obj_tlen != 8) {\n                    ND_PRINT((ndo, \" (not correct for object)\"));\n                    break;\n                }\n\n\t\tND_PRINT((ndo, \"\\n\\t Transparency Flags: %s\",\n\t\t       bittok2str(\n\t\t\t   lmp_obj_service_config_nsa_transparency_flag_values,\n\t\t\t   \"none\",\n\t\t\t   EXTRACT_32BITS(obj_tptr))));\n\n\t\tND_PRINT((ndo, \"\\n\\t TCM Monitoring Flags: %s\",\n\t\t       bittok2str(\n\t\t\t   lmp_obj_service_config_nsa_tcm_flag_values,\n\t\t\t   \"none\",\n\t\t\t   EXTRACT_8BITS(obj_tptr + 7))));\n\n\t\tbreak;\n\n\t    case LMP_CTYPE_SERVICE_CONFIG_NETWORK_DIVERSITY:\n                if (obj_tlen != 4) {\n                    ND_PRINT((ndo, \" (not correct for object)\"));\n                    break;\n                }\n\n\t\tND_PRINT((ndo, \"\\n\\t Diversity: Flags: %s\",\n\t\t       bittok2str(\n\t\t\t   lmp_obj_service_config_nsa_network_diversity_flag_values,\n\t\t\t   \"none\",\n\t\t\t   EXTRACT_8BITS(obj_tptr + 3))));\n\t\tbreak;\n\n\t    default:\n\t\thexdump = TRUE;\n\t    }\n\n\tbreak;\n\n        default:\n            if (ndo->ndo_vflag <= 1)\n                print_unknown_data(ndo,obj_tptr,\"\\n\\t    \",obj_tlen);\n            break;\n        }\n        /* do we want to see an additionally hexdump ? */\n        if (ndo->ndo_vflag > 1 || hexdump==TRUE)\n            print_unknown_data(ndo,tptr+sizeof(struct lmp_object_header),\"\\n\\t    \",\n                               lmp_obj_len-sizeof(struct lmp_object_header));\n\n        tptr+=lmp_obj_len;\n        tlen-=lmp_obj_len;\n    }\n    return;\ntrunc:\n    ND_PRINT((ndo, \"%s\", tstr));\n}\n/*\n * Local Variables:\n * c-style: whitesmith\n * c-basic-offset: 8\n * End:\n */\n", "IP (tos 0xfd,ECT(1), ttl 254, id 45839, offset 0, flags [+, DF, rsvd], proto UDP (17), length 56871, bad cksum fe07 (->ddf0)!)\n    17.8.8.255.701 > 40.184.42.8.12: \n\tLMPv1, msg-type: unknown, type: 249, Flags: [none], length: 212\n\t  Data Link Object (12), Class-Type: Unnumbered (3) Flags: [non-negotiable], length: 20\n\t    Flags: [none]\n\t    Local Interface ID: 2435832538 (0x912fdada)\n\t    Remote Interface ID: 3657433088 (0xda000000)\n\t    Subobject, Type: Interface Switching Type (1), Length: 4\n\t      Switching Type: Unknown (0)\n\t      Encoding Type: Unknown (0) [|LMP]\nIP (tos 0xfd,ECT(1), ttl 254, id 45839, offset 0, flags [+, DF, rsvd], proto UDP (17), length 56871, bad cksum fe07 (->ddf0)!)\n    17.8.8.255.701 > 40.184.42.8.12: \n\tLMPv1, msg-type: unknown, type: 249, Flags: [none], length: 212\n\t  Data Link Object (12), Class-Type: Unnumbered (3) Flags: [non-negotiable], length: 20\n\t    Flags: [none]\n\t    Local Interface ID: 2435832538 (0x912fdada)\n\t    Remote Interface ID: 3657433088 (0xda000000)\n\t    Subobject, Type: Interface Switching Type (1), Length: 4\n\t      Switching Type: Unknown (0)\n\t      Encoding Type: Unknown (0) [|LMP]\n", "00:80:ad:91:d8:6f > 00:0b:64:00:10:72, ethertype IPv4 (0x0800), length 725: (tos 0x0, ttl 128, id 35978, offset 0, flags [none], proto UDP (17), length 711)\n    168.152.32.1.701 > 168.152.32.39.701: [udp sum ok] \n\tLMPv1, msg-type: Config, Flags: [Control Channel Down], length: 257\n\t  Data Link Object (12), Class-Type: IPv4 (1) Flags: [non-negotiable], length: 516\n\t    Flags: [Allocated for user traffic]\n\t    Local Interface ID: 0.0.2.0 (0x00000200)\n\t    Remote Interface ID: 2.0.2.0 (0x02000200)\n\t    Subobject, Type: Wavelength (2), Length: 0 (too short)\n\t    0x0000:  0253 e10b 0000 0200 0200 0200 0200 0200\n\t    0x0010:  0200 0200 0200 0200 0200 0200 0200 0200\n\t    0x0020:  0200 0200 0200 0200 0200 0200 0200 0200\n\t    0x0030:  0200 0200 0200 0200 0200 0200 0200 0200\n\t    0x0040:  0200 0280 6d00 0200 0200 0200 0200 0200\n\t    0x0050:  0200 0200 0200 0200 0200 0200 0200 0200\n\t    0x0060:  0200 0200 0200 0200 0200 0200 0200 0200\n\t    0x0070:  0200 0200 0200 0200 0200 0200 0200 8202\n\t    0x0080:  0002 0002 0002 0002 0002 0002 0002 0002\n\t    0x0090:  0002 0002 0002 0002 0002 0002 0002 0002\n\t    0x00a0:  0002 0002 0002 0002 0002 0002 0002 0002\n\t    0x00b0:  2002 0002 0002 0002 0002 0002 0002 0002\n\t    0x00c0:  0000 0200 0200 0002 0002 0000 0200 0200\n\t    0x00d0:  0002 0002 0000 0200 0200 0002 0002 0000\n\t    0x00e0:  0200 0200 0002 0002 0000 0200 0200 0002\n\t    0x00f0:  0002 0000 0200 0200 0002 0002 0000 0200\n\t    0x0100:  0200 0002 0002 0000 0200 0200 0002 0002\n\t    0x0110:  0000 0200 0200 0002 0002 0000 0200 0200\n\t    0x0120:  0002 0002 0000 0200 0200 0002 0002 0000\n\t    0x0130:  0200 0200 0002 0002 0000 0200 0200 0002\n\t    0x0140:  0002 0000 0200 0200 0002 0002 0000 0200\n\t    0x0150:  0200 0002 0002 0000 0200 0200 0002 0002\n\t    0x0160:  0000 0200 0200 0002 0002 0000 0200 0200\n\t    0x0170:  0002 0002 0000 0200 0200 0002 0002 0000\n\t    0x0180:  0200 0200 0002 0002 0000 0200 0200 0002\n\t    0x0190:  0002 0000 0200 0200 0002 0002 0000 0200\n\t    0x01a0:  0200 0002 0002 0000 0200 0200 0002 0002\n\t    0x01b0:  0000 0200 0200 0002 0002 0000 0200 0200\n\t    0x01c0:  0002 0002 0000 0200 0200 0002 0002 0000\n\t    0x01d0:  0200 0200 0002 0002 0000 0200 0200 0002\n\t    0x01e0:  0002 0000 0200 0200 0002 0002 0000 0200\n\t    0x01f0:  0200 0002 0002 0000 0200 0200 0002 0002\n\t  Unknown Object (0), Class-Type: Unknown (0) Flags: [non-negotiable], length: 512 [|LMP]\n"], "filenames": ["print-lmp.c", "tests/lmp-lmp_print_data_link_subobjs-oobr.out", "tests/lmpv1_busyloop.out"], "buggy_code_start_loc": [32, 10, 41], "buggy_code_end_loc": [1145, 23, 43], "fixing_code_start_loc": [33, 10, 41], "fixing_code_end_loc": [1152, 21, 42], "type": "CWE-120", "message": "lmp_print_data_link_subobjs() in print-lmp.c in tcpdump before 4.9.3 lacks certain bounds checks.", "other": {"cve": {"id": "CVE-2019-15166", "sourceIdentifier": "cve@mitre.org", "published": "2019-10-03T17:15:11.050", "lastModified": "2022-04-13T14:48:13.550", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "lmp_print_data_link_subobjs() in print-lmp.c in tcpdump before 4.9.3 lacks certain bounds checks."}, {"lang": "es", "value": "La funci\u00f3n lmp_print_data_link_subobjs() en el archivo print-lmp.c en tcpdump versiones anteriores a 4.9.3, carece de ciertas comprobaciones de l\u00edmites."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "cve@mitre.org", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:P/AC:H/PR:H/UI:N/S:U/C:N/I:N/A:L", "attackVector": "PHYSICAL", "attackComplexity": "HIGH", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 1.6, "baseSeverity": "LOW"}, "exploitabilityScore": 0.2, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-120"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:tcpdump:tcpdump:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.9.3", "matchCriteriaId": "CA59BD9C-6C0C-4584-A8CC-8C652E9D36AF"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:apple:mac_os_x:*:*:*:*:*:*:*:*", "versionEndExcluding": "10.15.2", "matchCriteriaId": "F15588EA-D854-4694-97C6-53D9AA8B6F2D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:29:*:*:*:*:*:*:*", "matchCriteriaId": "D100F7CE-FC64-4CC6-852A-6136D72DA419"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:30:*:*:*:*:*:*:*", "matchCriteriaId": "97A4B8DF-58DA-4AB6-A1F9-331B36409BA3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:31:*:*:*:*:*:*:*", "matchCriteriaId": "80F0FA5D-8D3B-4C0E-81E2-87998286AF33"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.0:*:*:*:*:*:*:*", "matchCriteriaId": "F1E78106-58E6-4D59-990F-75DA575BFAD9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "142AD0DD-4CF3-4D74-9442-459CE3347E3A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "F4CFF558-3C47-480D-A2F0-BABF26042943"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:cloud_backup:-:*:*:*:*:*:*:*", "matchCriteriaId": "5C2089EE-5D7F-47EC-8EA5-0F69790564C4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:hci_management_node:-:*:*:*:*:*:*:*", "matchCriteriaId": "A3C19813-E823-456A-B1CE-EC0684CE1953"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:solidfire:-:*:*:*:*:*:*:*", "matchCriteriaId": "A6E9EF0C-AFA8-4F7B-9FDC-1E0F7C26E737"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:-:*:*:*", "matchCriteriaId": "CB66DB75-2B16-4EBF-9B93-CE49D8086E41"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:esm:*:*:*", "matchCriteriaId": "815D70A8-47D3-459C-A32C-9FEACA0659D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:esm:*:*:*", "matchCriteriaId": "7A5301BF-1402-4BE0-A0F8-69FBE79BC6D6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-10/msg00050.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2019-10/msg00053.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://seclists.org/fulldisclosure/2019/Dec/26", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/the-tcpdump-group/tcpdump/blob/tcpdump-4.9/CHANGES", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/the-tcpdump-group/tcpdump/commit/0b661e0aa61850234b64394585cf577aac570bf4", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/10/msg00015.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/62XY42U6HY3H2APR5EHNWCZ7SAQNMMJN/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/FNYXF3IY2X65IOD422SA6EQUULSGW7FN/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/R2UDPOSGVJQIYC33SQBXMDXHH4QDSDMU/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://seclists.org/bugtraq/2019/Dec/23", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://seclists.org/bugtraq/2019/Oct/28", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20200120-0001/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://support.apple.com/kb/HT210788", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4252-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4252-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2019/dsa-4547", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/the-tcpdump-group/tcpdump/commit/0b661e0aa61850234b64394585cf577aac570bf4"}}