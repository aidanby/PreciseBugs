{"buggy_code": ["import asyncio\nimport discord\nimport logging\nimport re\nimport functools\n\nfrom copy import deepcopy\nfrom collections import namedtuple\nfrom typing import Union, Optional, Iterable, Callable, Awaitable\nfrom datetime import datetime, timedelta\nfrom multiprocessing import TimeoutError\nfrom multiprocessing.pool import Pool\n\nfrom redbot.core import Config\nfrom redbot.core.bot import Red\nfrom redbot.core.i18n import Translator\nfrom redbot.core.commands import BadArgument, MemberConverter\n\ntry:\n    from redbot.core.modlog import get_modlog_channel as get_red_modlog_channel\nexcept RuntimeError:\n    pass  # running sphinx-build raises an error when importing this module\n\nfrom .cache import MemoryCache\nfrom . import errors\n\nlog = logging.getLogger(\"red.laggron.warnsystem\")\n_ = Translator(\"WarnSystem\", __file__)\nid_pattern = re.compile(r\"([0-9]{15,21})$\")\n\n\nclass FakeRole:\n    \"\"\"\n    We need to fake some attributes of roles for the class UnavailableMember\n    \"\"\"\n\n    position = 0\n    colour = discord.Embed.Empty\n\n\nclass UnavailableMember(discord.abc.User, discord.abc.Messageable):\n    \"\"\"\n    A class that reproduces the behaviour of a discord.Member instance, except\n    the member is not in the guild. This is used to prevent calling bot.fetch_info\n    which has a very high cooldown.\n    \"\"\"\n\n    def __init__(self, bot, state, user_id: int):\n        self.bot = bot\n        self._state = state\n        self.id = user_id\n        self.top_role = FakeRole()\n\n    @classmethod\n    def _check_id(cls, member_id):\n        if not id_pattern.match(member_id):\n            raise ValueError(f\"You provided an invalid ID: {member_id}\")\n        return int(member_id)\n\n    @classmethod\n    async def convert(cls, ctx, text):\n        try:\n            member = await MemberConverter().convert(ctx, text)\n        except BadArgument:\n            pass\n        else:\n            return member\n        try:\n            member_id = cls._check_id(text)\n        except ValueError:\n            raise BadArgument(\n                _(\n                    \"The given member cannot be found.\\n\"\n                    \"If you're trying to hackban, the user ID is not valid.\"\n                )\n            )\n        return cls(ctx.bot, ctx._state, member_id)\n\n    @property\n    def name(self):\n        return \"Unknown\"\n\n    @property\n    def display_name(self):\n        return \"Unknown\"\n\n    @property\n    def mention(self):\n        return f\"<@{self.id}>\"\n\n    @property\n    def avatar_url(self):\n        return \"\"\n\n    def __str__(self):\n        return \"Unknown#0000\"\n\n    # the 3 following functions were copied from the discord.User class, credit to Rapptz\n    # https://github.com/Rapptz/discord.py/blob/master/discord/user.py#L668\n\n    @property\n    def dm_channel(self):\n        \"\"\"Optional[:class:`DMChannel`]: Returns the channel associated with this user if it exists.\n        If this returns ``None``, you can create a DM channel by calling the\n        :meth:`create_dm` coroutine function.\n        \"\"\"\n        return self._state._get_private_channel_by_user(self.id)\n\n    async def create_dm(self):\n        \"\"\"Creates a :class:`DMChannel` with this user.\n        This should be rarely called, as this is done transparently for most\n        people.\n        \"\"\"\n        found = self.dm_channel\n        if found is not None:\n            return found\n\n        state = self._state\n        data = await state.http.start_private_message(self.id)\n        return state.add_dm_channel(data)\n\n    async def _get_channel(self):\n        channel = await self.create_dm()\n        return channel\n\n\nclass API:\n    \"\"\"\n    Interact with WarnSystem from your cog.\n\n    To import the cog and use the functions, type this in your code:\n\n    .. code-block:: python\n\n        warnsystem = bot.get_cog('WarnSystem').api\n\n    .. warning:: If ``warnsystem`` is :py:obj:`None`, the cog is\n      not loaded/installed. You won't be able to interact with\n      the API at this point.\n\n    .. tip:: You can get the cog version by doing this\n\n        .. code-block:: python\n\n            version = bot.get_cog('WarnSystem').__version__\n    \"\"\"\n\n    def __init__(self, bot: Red, config: Config, cache: MemoryCache):\n        self.bot = bot\n        self.data = config\n        self.cache = cache\n        self.re_pool = Pool(maxtasksperchild=1000)\n        self.regex_timeout = 1\n        self.warned_guilds = []  # see automod_check_for_autowarn\n        self.antispam = {}  # see automod_process_antispam\n        self.antispam_warn_queue = {}  # see automod_warn\n        self.automod_warn_task: asyncio.Task\n\n    def _get_datetime(self, time: int) -> datetime:\n        return datetime.fromtimestamp(int(time))\n\n    def _get_timedelta(self, time: int) -> timedelta:\n        return timedelta(seconds=int(time))\n\n    def _format_datetime(self, time: datetime):\n        return time.strftime(\"%a %d %B %Y %H:%M:%S\")\n\n    def _format_timedelta(self, time: timedelta):\n        \"\"\"Format a timedelta object into a string\"\"\"\n        # blame python for not creating a strftime attribute\n        plural = lambda name, amount: name[1] if amount > 1 else name[0]\n        strings = []\n\n        seconds = time.total_seconds()\n        years, seconds = divmod(seconds, 31622400)\n        months, seconds = divmod(seconds, 2635200)\n        weeks, seconds = divmod(seconds, 604800)\n        days, seconds = divmod(seconds, 86400)\n        hours, seconds = divmod(seconds, 3600)\n        minutes, seconds = divmod(seconds, 60)\n        units = [years, months, weeks, days, hours, minutes, seconds]\n\n        # tuples inspired from mikeshardmind\n        # https://github.com/mikeshardmind/SinbadCogs/blob/v3/scheduler/time_utils.py#L29\n        units_name = {\n            0: (_(\"year\"), _(\"years\")),\n            1: (_(\"month\"), _(\"months\")),\n            2: (_(\"week\"), _(\"weeks\")),\n            3: (_(\"day\"), _(\"days\")),\n            4: (_(\"hour\"), _(\"hours\")),\n            5: (_(\"minute\"), _(\"minutes\")),\n            6: (_(\"second\"), _(\"seconds\")),\n        }\n        for i, value in enumerate(units):\n            if value < 1:\n                continue\n            unit_name = plural(units_name.get(i), value)\n            strings.append(f\"{round(value)} {unit_name}\")\n        string = \", \".join(strings[:-1])\n        if len(strings) > 1:\n            string += _(\" and \") + strings[-1]\n        else:\n            string = strings[0]\n        return string\n\n    async def _start_timer(self, guild: discord.Guild, member: discord.Member, case: dict) -> bool:\n        \"\"\"Start the timer for a temporary mute/ban.\"\"\"\n        if not case[\"duration\"]:\n            raise errors.BadArgument(\"No duration for this warning!\")\n        await self.cache.add_temp_action(guild, member, case)\n        return True\n\n    async def _mute(self, member: discord.Member, reason: Optional[str] = None):\n        \"\"\"Mute an user on the guild.\"\"\"\n        old_roles = []\n        guild = member.guild\n        mute_role = guild.get_role(await self.cache.get_mute_role(guild))\n        remove_roles = await self.data.guild(guild).remove_roles()\n        if not mute_role:\n            raise errors.MissingMuteRole(\"You need to create the mute role before doing this.\")\n        if remove_roles:\n            old_roles = member.roles.copy()\n            old_roles.remove(guild.default_role)\n            old_roles = [\n                x for x in old_roles if x.position < guild.me.top_role.position and not x.managed\n            ]\n            fails = []\n            for role in old_roles:\n                try:\n                    await member.remove_roles(role, reason=reason)\n                except discord.errors.HTTPException:\n                    fails.append(role)\n            if fails:\n                log.warn(\n                    f\"[Guild {guild.id}] Failed to remove roles from {member} (ID: {member.id}) \"\n                    f\"while muting. Roles: {', '.join([f'{x.name} ({x.id})' for x in fails])}\",\n                )\n        await member.add_roles(mute_role, reason=reason)\n        return old_roles\n\n    async def _unmute(self, member: discord.Member, reason: str, old_roles: list = None):\n        \"\"\"Unmute an user on the guild.\"\"\"\n        guild = member.guild\n        mute_role = guild.get_role(await self.cache.get_mute_role(guild))\n        if not mute_role:\n            raise errors.MissingMuteRole(\n                f\"Lost the mute role on guild {guild.name} (ID: {guild.id}\"\n            )\n        await member.remove_roles(mute_role, reason=reason)\n        await member.add_roles(*old_roles, reason=reason)\n\n    async def _create_case(\n        self,\n        guild: discord.Guild,\n        user: discord.User,\n        author: Union[discord.Member, str],\n        level: int,\n        time: datetime,\n        reason: Optional[str] = None,\n        duration: Optional[timedelta] = None,\n        roles: Optional[list] = None,\n        modlog_message: Optional[discord.Message] = None,\n    ) -> dict:\n        \"\"\"Create a new case for a member. Don't call this, call warn instead.\"\"\"\n        data = {\n            \"level\": level,\n            \"author\": author\n            if not isinstance(author, (discord.User, discord.Member))\n            else author.id,\n            \"reason\": reason,\n            \"time\": int(time.timestamp()),  # seconds since epoch\n            \"duration\": None if not duration else duration.total_seconds(),\n            \"roles\": [] if not roles else [x.id for x in roles],\n        }\n        if modlog_message:\n            data[\"modlog_message\"] = {\n                \"channel_id\": modlog_message.channel.id,\n                \"message_id\": modlog_message.id,\n            }\n        async with self.data.custom(\"MODLOGS\", guild.id, user.id).x() as logs:\n            logs.append(data)\n        return data\n\n    async def get_case(\n        self, guild: discord.Guild, user: Union[discord.User, discord.Member], index: int\n    ) -> dict:\n        \"\"\"\n        Get a specific case for a user.\n\n        Parameters\n        ----------\n        guild: discord.Guild\n            The guild of the member.\n        user: Union[discord.User, discord.Member]\n            The user you want to get the case from. Can be a :class:`discord.User` if the member is\n            not in the server.\n        index: int\n            The case index you want to get. Must be positive.\n\n        Returns\n        -------\n        dict\n            A :py:class:`dict` which has the following body:\n\n            .. code-block: python3\n\n                {\n                    \"level\"     : int,  # between 1 and 5, the warning level\n                    \"author\"    : Union[discord.Member, str],  # the member that warned the user\n                    \"reason\"    : Optional[str],  # the reason of the warn, can be None\n                    \"time\"      : datetime.datetime,  # the date when the warn was set\n                }\n\n        Raises\n        ------\n        ~warnsystem.errors.NotFound\n            The case requested doesn't exist.\n        \"\"\"\n        try:\n            case = (await self.data.custom(\"MODLOGS\", guild.id, user.id).x())[index - 1]\n        except IndexError:\n            raise errors.NotFound(\"The case requested doesn't exist.\")\n        else:\n            time = case[\"time\"]\n            if time:\n                case[\"time\"] = self._get_datetime(time)\n            return case\n\n    async def get_all_cases(\n        self, guild: discord.Guild, user: Optional[Union[discord.User, discord.Member]] = None\n    ) -> list:\n        \"\"\"\n        Get all cases for a member of a guild.\n\n        Parameters\n        ----------\n        guild: discord.Guild\n            The guild where you want to get the cases from.\n        user: Optional[Union[discord.User, discord.Member]]\n            The user you want to get the cases from. If this arguments is omitted, all cases of\n            the guild are returned.\n\n        Returns\n        -------\n        list\n            A list of all cases of a user/guild. The cases are sorted from the oldest to the\n            newest.\n\n            If you specified a user, you should get something like this:\n\n            .. code-block:: python3\n\n                [\n                    {  # case #1\n                        \"level\"     : int,  # between 1 and 5, the warning level\n                        \"author\"    : Union[discord.Member, str],  # the member that warned the user\n                        \"reason\"    : Optional[str],  # the reason of the warn, can be None\n                        \"time\"      : datetime.datetime,  # the date when the warn was set\n                    },\n                    {\n                        # case #2\n                    },\n                    # ...\n                ]\n\n            However, if you didn't specify a user, you got all cases of the guild. As for the user,\n            you will get a :py:class:`list` of the cases, with another key for specifying the\n            warned user:\n\n            .. code-block:: python3\n\n                {  # case #1\n                    \"level\"     : int,  # between 1 and 5, the warning level\n                    \"author\"    : Union[discord.Member, str],  # the member that warned the user\n                    \"reason\"    : Optional[str],  # the reason of the warn, can be None\n                    \"time\"      : datetime.datetime,  # the date when the warn was set\n\n                    \"member\"    : discord.User,  # the member warned, this key is specific to guild\n                }\n        \"\"\"\n        if user:\n            return await self.data.custom(\"MODLOGS\", guild.id, user.id).x()\n        logs = await self.data.custom(\"MODLOGS\", guild.id).all()\n        all_cases = []\n        for member, content in logs.items():\n            if member == \"x\":\n                continue\n            for log in content[\"x\"]:\n                time = log[\"time\"]\n                if time:\n                    log[\"time\"] = self._get_datetime(time)\n                # gotta get that state somehow\n                log[\"member\"] = self.bot.get_user(int(member)) or UnavailableMember(\n                    self.bot, self.bot.user._state, member\n                )\n                log[\"author\"] = self.bot.get_user(int(log[\"author\"])) or UnavailableMember(\n                    self.bot, self.bot.user._state, log[\"author\"]\n                )\n                all_cases.append(log)\n        return sorted(all_cases, key=lambda x: x[\"time\"])  # sorted from oldest to newest\n\n    async def edit_case(\n        self,\n        guild: discord.Guild,\n        user: Union[discord.User, discord.Member],\n        index: int,\n        new_reason: str,\n    ) -> bool:\n        \"\"\"\n        Edit the reason of a case.\n\n        Parameters\n        ----------\n        guild: discord.Guild\n            The guild where you want to get the case from.\n        user: Union[discord.User, discord.Member]\n            The user you want to get the case from.\n        index: int\n            The number of the case you want to edit.\n        new_reason: str\n            The new reason to set.\n\n        Returns\n        -------\n        bool\n            :py:obj:`True` if the action succeeded.\n\n        Raises\n        ------\n        ~warnsystem.errors.BadArgument\n            The reason is above 1024 characters. Due to Discord embed rules, you have to make it\n            shorter.\n        ~warnsystem.errors.NotFound\n            The case requested doesn't exist.\n        \"\"\"\n        if len(new_reason) > 1024:\n            raise errors.BadArgument(\"The reason must not be above 1024 characters.\")\n        case = await self.get_case(guild, user, index)\n        case[\"reason\"] = new_reason\n        case[\"time\"] = int(case[\"time\"].timestamp())\n        async with self.data.custom(\"MODLOGS\", guild.id, user.id).x() as logs:\n            logs[index - 1] = case\n        return True\n\n    async def get_modlog_channel(\n        self, guild: discord.Guild, level: Optional[Union[int, str]] = None\n    ) -> discord.TextChannel:\n        \"\"\"\n        Get the WarnSystem's modlog channel on the current guild.\n\n        When you call this, the channel is get with the following order:\n\n        #.  Get the modlog channel associated to the type, if provided\n        #.  Get the defult modlog channel set with WarnSystem\n        #.  Get the Red's modlog channel associated to the server\n\n        Parameters\n        ----------\n        guild: discord.Guild\n            The guild you want to get the modlog from.\n        level: Optional[Union[int, str]]\n            Can be an :py:class:`int` between 1 and 5, a :py:class:`str` (``\"all\"``)\n            or :py:obj:`None`.\n\n            *   If the argument is omitted (or :py:obj:`None` is provided), the default modlog\n                channel will be returned.\n\n            *   If an :py:class:`int` is given, the modlog channel associated to this warning\n                level will be returned. If a specific channel was not set for this level, the\n                default modlog channel will be returned instead.\n\n            *   If ``\"all\"`` is returned, a :py:class:`dict` will be returned. It should be built\n                like this:\n\n                .. code-block:: python3\n\n                    {\n                        \"main\"      : 012345678987654321,\n                        \"1\"         : None,\n                        \"2\"         : None,\n                        \"3\"         : None,\n                        \"4\"         : 478065433996537900,\n                        \"5\"         : 567943553912O46428,\n                    }\n\n                A dict with the possible channels is returned, associated with an :py:class:`int`\n                corresponding to the channel ID set, or :py:obj:`None` if it was not set.\n\n                For technical reasons, the default channel is actually named ``\"main\"`` in the dict.\n\n        Returns\n        -------\n        channel: discord.TextChannel\n            The channel requested.\n\n            .. note:: It can be :py:obj:`None` if the channel doesn't exist anymore.\n\n        Raises\n        ------\n        ~warnsystem.errors.NotFound\n            There is no modlog channel set with WarnSystem or Red, ask the user to set one.\n        \"\"\"\n        # raise errors if the arguments are wrong\n        if level:\n            msg = \"The level must be an int between 1 and 5 ; or a string that \" 'should be \"all\"'\n            if not isinstance(level, int) and level != \"all\":\n                raise errors.InvalidLevel(msg)\n            elif isinstance(level, int) and not 1 <= level <= 5:\n                raise errors.InvalidLevel(msg)\n\n        if level == \"all\":\n            return await self.data.guild(guild).channels.all()\n        default_channel = await self.data.guild(guild).channels.main()\n        if level:\n            channel = await self.data.guild(guild).channels.get_raw(str(level))\n        else:\n            return default_channel\n\n        if not default_channel and not channel:\n            # warnsystem default channel doesn't exist, let's try to get Red's one\n            try:\n                return await get_red_modlog_channel(guild)\n            except RuntimeError:\n                raise errors.NotFound(\"No modlog found from WarnSystem or Red\")\n\n        return self.bot.get_channel(channel if channel else default_channel)\n\n    async def get_embeds(\n        self,\n        guild: discord.Guild,\n        member: Union[discord.Member, UnavailableMember],\n        author: Union[discord.Member, str],\n        level: int,\n        reason: Optional[str] = None,\n        time: Optional[timedelta] = None,\n        date: Optional[datetime] = None,\n        message_sent: bool = True,\n    ) -> tuple:\n        \"\"\"\n        Return two embeds, one for the modlog and one for the member.\n\n        .. warning:: Unlike for the warning, the arguments are not checked and won't raise errors\n            if they are wrong. It is recommanded to call :func:`~warnsystem.api.API.warn` and let\n            it generate the embeds instead.\n\n        Parameters\n        ----------\n        guild: discord.Guild\n            The Discord guild where the warning takes place.\n        member: Union[discord.Member, UnavailableMember]\n            The warned member. Should only be :class:`UnavailableMember` in case of a hack ban.\n        author: Union[discord.Member, str]\n            The moderator that warned the user. If it's not a Discord user, you can specify a\n            :py:class:`str` instead (e.g. \"Automod\").\n        level: int\n            The level of the warning which should be between 1 and 5.\n        reason: Optional[str]\n            The reason of the warning.\n        time: Optional[timedelta]\n            The time before the action ends. Only for mute and ban.\n        date: Optional[datetime]\n            When the action was taken.\n        message_sent: bool\n            Set to :py:obj:`False` if the embed couldn't be sent to the warned user.\n\n        Returns\n        -------\n        tuple\n            A :py:class:`tuple` with the modlog embed at index 0, and the user embed at index 1.\n        \"\"\"\n        action = {\n            1: (_(\"warn\"), _(\"warns\")),\n            2: (_(\"mute\"), _(\"mutes\")),\n            3: (_(\"kick\"), _(\"kicks\")),\n            4: (_(\"softban\"), _(\"softbans\")),\n            5: (_(\"ban\"), _(\"bans\")),\n        }.get(level, _(\"unknown\"))\n        mod_message = \"\"\n        if not reason:\n            reason = _(\"No reason was provided.\")\n            mod_message = _(\"\\nEdit this with `[p]warnings {id}`\").format(id=member.id)\n        logs = await self.data.custom(\"MODLOGS\", guild.id, member.id).x()\n\n        # prepare the status field\n        total_warns = len(logs) + 1\n        total_type_warns = (\n            len([x for x in logs if x[\"level\"] == level]) + 1\n        )  # number of warns of the received type\n\n        # a lambda that returns a string; if True is given, a third person sentence is returned\n        # (modlog), if False is given, a first person sentence is returned (DM user)\n        current_status = lambda x: _(\n            \"{who} now {verb} {total} {warning} ({total_type} {action})\"\n        ).format(\n            who=_(\"The member\") if x else _(\"You\"),\n            verb=_(\"has\") if x else _(\"have\"),\n            total=total_warns,\n            warning=_(\"warnings\") if total_warns > 1 else _(\"warning\"),\n            total_type=total_type_warns,\n            action=action[1] if total_type_warns > 1 else action[0],\n        )\n\n        # we set any value that can be used multiple times\n        invite = None\n        log_description = await self.data.guild(guild).embed_description_modlog.get_raw(level)\n        if \"{invite}\" in log_description:\n            try:\n                invite = await guild.create_invite(max_uses=1)\n            except Exception:\n                invite = _(\"*[couldn't create an invite]*\")\n        user_description = await self.data.guild(guild).embed_description_user.get_raw(level)\n        if \"{invite}\" in user_description and not invite:\n            try:\n                invite = await guild.create_invite(max_uses=1)\n            except Exception:\n                invite = _(\"*[couldn't create an invite]*\")\n        if date:\n            today = date.strftime(\"%a %d %B %Y %H:%M\")\n        else:\n            today = datetime.utcnow()\n        if time:\n            duration = self._format_timedelta(time)\n        else:\n            duration = _(\"*[No time given]*\")\n        format_description = lambda x: x.format(\n            invite=invite, member=member, mod=author, duration=duration, time=today\n        )\n        link = re.search(r\"(https?://)\\S+\\.(jpg|jpeg|png|gif|webm)\", reason)\n\n        # embed for the modlog\n        log_embed = discord.Embed()\n        log_embed.set_author(name=f\"{member.name} | {member.id}\", icon_url=member.avatar_url)\n        log_embed.title = _(\"Level {level} warning ({action})\").format(\n            level=level, action=action[0]\n        )\n        log_embed.description = format_description(log_description)\n        log_embed.add_field(name=_(\"Member\"), value=member.mention, inline=True)\n        log_embed.add_field(name=_(\"Moderator\"), value=author.mention, inline=True)\n        if time:\n            log_embed.add_field(name=_(\"Duration\"), value=duration, inline=True)\n        log_embed.add_field(name=_(\"Reason\"), value=reason + mod_message, inline=False)\n        log_embed.add_field(name=_(\"Status\"), value=current_status(True), inline=False)\n        log_embed.timestamp = date\n        log_embed.set_thumbnail(url=await self.data.guild(guild).thumbnails.get_raw(level))\n        log_embed.colour = await self.data.guild(guild).colors.get_raw(level)\n        log_embed.url = await self.data.guild(guild).url()\n        log_embed.set_image(url=link.group() if link else \"\")\n        if not message_sent:\n            log_embed.description += _(\n                \"\\n\\n***The message could not be delivered to the user. They may have DMs \"\n                \"disabled, blocked the bot, or may not have a mutual server.***\"\n            )\n\n        # embed for the member in DM\n        user_embed = deepcopy(log_embed)\n        user_embed.set_author(name=\"\")\n        user_embed.description = format_description(user_description)\n        if mod_message:\n            user_embed.set_field_at(3 if time else 2, name=_(\"Reason\"), value=reason)\n        user_embed.remove_field(4 if time else 3)  # removes status field (gonna be added back)\n        user_embed.remove_field(0)  # removes member field\n        user_embed.add_field(name=_(\"Status\"), value=current_status(False), inline=False)\n        if time:\n            user_embed.set_field_at(\n                1, name=_(\"Duration\"), value=self._format_timedelta(time), inline=True\n            )\n        if not await self.data.guild(guild).show_mod():\n            user_embed.remove_field(0)  # called twice, removing moderator field\n\n        return (log_embed, user_embed)\n\n    async def maybe_create_mute_role(self, guild: discord.Guild) -> bool:\n        \"\"\"\n        Create the mod role for WarnSystem if it doesn't exist.\n        This will also edit all channels to deny the following permissions to this role:\n\n        *   ``send_messages``\n        *   ``add_reactions``\n        *   ``speak``\n\n        Parameters\n        ----------\n        guild: discord.Guild\n            The guild you want to set up the mute in.\n\n        Returns\n        -------\n        Union[bool, list]\n            *   :py:obj:`False` if the role already exists.\n            *   :py:class:`list` if the role was created, with a list of errors for each channel.\n                Empty list means completly successful edition.\n\n        Raises\n        ------\n        ~warnsystem.errors.MissingPermissions\n            The bot lacks the :attr:`discord.Permissions.create_roles` permission.\n        discord.errors.HTTPException\n            Creating the role failed.\n        \"\"\"\n        role = await self.cache.get_mute_role(guild)\n        role = guild.get_role(role)\n        if role:\n            return False\n\n        if not guild.me.guild_permissions.manage_roles:\n            raise errors.MissingPermissions(\n                _(\"I can't manage roles, please give me this permission to continue.\")\n            )\n\n        # no mod role on this guild, let's create one\n        role = await guild.create_role(\n            name=\"Muted\",\n            reason=_(\n                \"WarnSystem mute role. This role will be assigned to the muted members, \"\n                \"feel free to move it or modify its channel permissions.\"\n            ),\n        )\n        await asyncio.sleep(0.5)  # prevents an error when repositionning the role\n        await role.edit(\n            position=guild.me.top_role.position - 1,\n            reason=_(\n                \"Modifying role's position, keep it under my top role so \"\n                \"I can add it to muted members.\"\n            ),\n        )\n        perms = discord.PermissionOverwrite(send_messages=False, add_reactions=False, speak=False)\n        errors = []\n        for channel in guild.channels:\n            try:\n                await channel.set_permissions(\n                    target=role,\n                    overwrite=perms,\n                    reason=_(\n                        \"Setting up WarnSystem mute. All muted members will have this role, \"\n                        \"feel free to edit its permissions.\"\n                    ),\n                )\n            except discord.errors.Forbidden:\n                errors.append(\n                    _(\n                        \"Cannot edit permissions of the channel {channel} because of a \"\n                        \"permission error (probably enforced permission for `Manage channel`).\"\n                    ).format(channel=channel.mention)\n                )\n            except discord.errors.HTTPException as e:\n                errors.append(\n                    _(\n                        \"Cannot edit permissions of the channel {channel} because of \"\n                        \"an unknown error.\"\n                    ).format(channel=channel.mention)\n                )\n                log.warn(\n                    f\"[Guild {guild.id}] Couldn't edit permissions of {channel} (ID: \"\n                    f\"{channel.id}) for setting up the mute role because of an HTTPException.\",\n                    exc_info=e,\n                )\n            except Exception as e:\n                errors.append(\n                    _(\n                        \"Cannot edit permissions of the channel {channel} because of \"\n                        \"an unknown error.\"\n                    ).format(channel=channel.mention)\n                )\n                log.error(\n                    f\"[Guild {guild.id}] Couldn't edit permissions of {channel} (ID: \"\n                    f\"{channel.id}) for setting up the mute role because of an unknwon error.\",\n                    exc_info=e,\n                )\n        await self.cache.update_mute_role(guild, role)\n        return errors\n\n    async def format_reason(self, guild: discord.Guild, reason: str = None) -> str:\n        \"\"\"\n        Reformat a reason with the substitutions set on the guild.\n\n        Parameters\n        ----------\n        guild: discord.Guild\n            The guild where the warn is set.\n        reason: str\n            The string you want to reformat.\n\n        Returns\n        -------\n        str\n            The reformatted string\n        \"\"\"\n        if not reason:\n            return\n        substitutions = await self.data.guild(guild).substitutions()\n        for key, substitute in substitutions.items():\n            reason = reason.replace(f\"[{key}]\", substitute)\n        return reason\n\n    async def warn(\n        self,\n        guild: discord.Guild,\n        members: Iterable[Union[discord.Member, UnavailableMember]],\n        author: Union[discord.Member, str],\n        level: int,\n        reason: Optional[str] = None,\n        time: Optional[timedelta] = None,\n        date: Optional[datetime] = None,\n        log_modlog: Optional[bool] = True,\n        log_dm: Optional[bool] = True,\n        take_action: Optional[bool] = True,\n        automod: Optional[bool] = True,\n        progress_tracker: Optional[Callable[[int], Awaitable[None]]] = None,\n    ) -> bool:\n        \"\"\"\n        Set a warning on a member of a Discord guild and log it with the WarnSystem system.\n\n        .. tip:: The message that comes with the following exceptions are already\n            translated and ready to be sent to Discord:\n\n            *   :class:`~warnsystem.errors.NotFound`\n            *   :class:`~warnsystem.errors.LostPermissions`\n            *   :class:`~warnsystem.errors.MemberTooHigh`\n            *   :class:`~warnsystem.errors.MissingPermissions`\n            *   :class:`~warnsystem.errors.SuicidePrevention`\n\n        Parameters\n        ----------\n        guild: discord.Guild\n            The guild of the member to warn\n        member: Iterable[Union[discord.Member, UnavailableMember]]\n            The member that will be warned. It can be an instance of\n            :py:class:`warnsystem.api.UnavailableMember` if you need\n            to ban someone not in the guild.\n        author: Union[discord.Member, str]\n            The member that called the action, which will be associated to the log.\n        level: int\n            An :py:class:`int` between 1 and 5, specifying the warning level:\n\n            #.  Simple DM warning\n            #.  Mute (can be temporary)\n            #.  Kick\n            #.  Softban\n            #.  Ban (can be temporary ban, or hack ban, if the member is not in the server)\n        reason: Optional[str]\n            The optional reason of the warning. It is strongly recommanded to set one.\n        time: Optional[timedelta]\n            The time before cancelling the action. This only works for a mute or a ban.\n        date: Optional[datetime]\n            When the action was taken. Only use if you want to overwrite the current date and time.\n        log_modlog: Optional[bool]\n            Specify if an embed should be posted to the modlog channel. Default to :py:obj:`True`.\n        log_dm: Optional[bool]\n            Specify if an embed should be sent to the warned user. Default to :py:obj:`True`.\n        take_action: Optional[bool]\n            Specify if the bot should take action on the member (mute, kick, softban, ban). If set\n            to :py:obj:`False`, the bot will only send a log embed to the member and in the modlog.\n            Default to :py:obj:`True`.\n        automod: Optional[bool]\n            Set to :py:obj:`False` to skip automod, preventing multiple warnings at once and\n            saving performances. Automod might trigger on a next warning though.\n        progress_tracker: Optional[Callable[[int], Awaitable[None]]]\n            an async callable (function or lambda) which takes one argument to follow the progress\n            of the warn. The argument is the number of warns committed. Here's an example:\n\n            .. code-block:: python3\n\n                i = 0\n                message = await ctx.send(\"Mass warn started...\")\n\n                async def update_count(count):\n                    i = count\n\n                async def update_msg():\n                    await message.edit(content=f\"{i}/{len(members)} members warned.\")\n                    await asyncio.sleep(1)\n\n                await api.warn(guild, members, ctx.author, 1, progress_tracker=update_count)\n\n        Returns\n        -------\n        dict\n            A dict of members which couldn't be warned associated to the exception related.\n\n\n        Raises\n        ------\n        ~warnsystem.errors.InvalidLevel\n            The level must be an :py:class:`int` between 1 and 5.\n        ~warnsystem.errors.BadArgument\n            You need to provide a valid :class:`discord.Member` object, except for a\n            hackban where a :class:`discord.User` works.\n        ~warnsystem.errors.MissingMuteRole\n            You're trying to mute someone but the mute role was not setup yet.\n            You can fix this by calling :func:`~warnsystem.api.API.maybe_create_mute_role`.\n        ~warnsystem.errors.LostPermissions\n            The bot lost a permission to do something (it had the perm before). This\n            can be lost permissions for sending messages to the modlog channel or\n            interacting with the mute role.\n        ~warnsystem.errors.MemberTooHigh\n            The bot is trying to take actions on someone but his top role is higher\n            than the bot's top role in the guild's hierarchy.\n        ~warnsystem.errors.NotAllowedByHierarchy\n            The moderator trying to warn someone is lower than him in the role hierarchy,\n            while the bot still has permissions to act. This is raised only if the\n            hierarchy check is enabled.\n        ~warnsystem.errors.MissingPermissions\n            The bot lacks a permissions to do something. Can be adding role, kicking\n            or banning members.\n        discord.errors.NotFound\n            When the user ID provided for hackban isn't recognized by Discord.\n        discord.errors.HTTPException\n            Unknown error from Discord API. It's recommanded to catch this\n            potential error too.\n        \"\"\"\n\n        async def warn_member(member: Union[discord.Member, UnavailableMember], audit_reason: str):\n            nonlocal i\n            roles = []\n            # permissions check\n            if level > 1 and guild.me.top_role.position <= member.top_role.position:\n                # check if the member is below the bot in the roles's hierarchy\n                return errors.MemberTooHigh(\n                    _(\n                        \"Cannot take actions on this member, they are \"\n                        \"above me in the roles hierarchy. Modify \"\n                        \"the hierarchy so my top role ({bot_role}) is above {member_role}.\"\n                    ).format(bot_role=guild.me.top_role.name, member_role=member.top_role.name)\n                )\n            if await self.data.guild(guild).respect_hierarchy() and (\n                not (await self.bot.is_owner(author) or author.id == guild.owner_id)\n                and member.top_role.position >= author.top_role.position\n            ):\n                return errors.NotAllowedByHierarchy(\n                    \"The moderator is lower than the member in the servers's role hierarchy.\"\n                )\n            if level > 2 and member.id == guild.owner_id:\n                return errors.MissingPermissions(\n                    _(\"I can't take actions on the owner of the guild.\")\n                )\n            if member == guild.me:\n                return errors.SuicidePrevention(\n                    _(\n                        \"Why would you warn me? I did nothing wrong :c\\n\"\n                        \"(use a manual kick/ban instead, warning the bot will cause issues)\"\n                    )\n                )\n            # send the message to the user\n            if log_modlog or log_dm:\n                modlog_e, user_e = await self.get_embeds(\n                    guild, member, author, level, reason, time, date\n                )\n            if log_dm:\n                try:\n                    await member.send(embed=user_e)\n                except (discord.errors.Forbidden, errors.UserNotFound):\n                    modlog_e = (\n                        await self.get_embeds(\n                            guild, member, author, level, reason, time, date, message_sent=False\n                        )\n                    )[0]\n                except discord.errors.NotFound:\n                    raise\n                except discord.errors.HTTPException as e:\n                    modlog_e = (\n                        await self.get_embeds(\n                            guild, member, author, level, reason, time, date, message_sent=False\n                        )\n                    )[0]\n                    log.warn(\n                        f\"[Guild {guild.id}] Couldn't send a message to {member} \"\n                        f\"(ID: {member.id}) because of an HTTPException.\",\n                        exc_info=e,\n                    )\n            # take actions\n            if take_action:\n                audit_reason = audit_reason.format(member=member)\n                try:\n                    if level == 2:\n                        roles = await self._mute(member, audit_reason)\n                    elif level == 3:\n                        await guild.kick(member, reason=audit_reason)\n                    elif level == 4:\n                        await guild.ban(\n                            member,\n                            reason=audit_reason,\n                            delete_message_days=await self.data.guild(guild).bandays.softban(),\n                        )\n                        await guild.unban(\n                            member,\n                            reason=_(\n                                \"Unbanning the softbanned member after cleaning up the messages.\"\n                            ),\n                        )\n                    elif level == 5:\n                        await guild.ban(\n                            member,\n                            reason=audit_reason,\n                            delete_message_days=await self.data.guild(guild).bandays.ban(),\n                        )\n                except discord.errors.HTTPException as e:\n                    log.warn(\n                        f\"[Guild {guild.id}] Failed to warn {member} because of \"\n                        \"an unknown error from Discord.\",\n                        exc_info=e,\n                    )\n                    return e\n            # actions were taken, time to log\n            if log_modlog:\n                modlog_message = await mod_channel.send(embed=modlog_e)\n            else:\n                modlog_message = None\n            data = await self._create_case(\n                guild, member, author, level, date, reason, time, roles, modlog_message\n            )\n            # start timer if there is a temporary warning\n            if time and (level == 2 or level == 5):\n                await self._start_timer(guild, member, data)\n            if automod:\n                # This function can be pretty heavy, and the response can be seriously delayed\n                # because of this, so we make it a side process instead\n                self.bot.loop.create_task(\n                    self.automod_check_for_autowarn(guild, member, author, level)\n                )\n            i += 1\n            if progress_tracker:\n                await progress_tracker(i)\n\n        if not 1 <= level <= 5:\n            raise errors.InvalidLevel(\"The level must be between 1 and 5.\")\n        # we get the modlog channel now to make sure it exists before doing anything\n        if log_modlog:\n            mod_channel = await self.get_modlog_channel(guild, level)\n        # check if the mute role exists\n        mute_role = guild.get_role(await self.cache.get_mute_role(guild))\n        if not mute_role and level == 2:\n            raise errors.MissingMuteRole(\"You need to create the mute role before doing this.\")\n        # we check for all permission problem that can occur before calling the API\n        # checks if the bot has send_messages and embed_links permissions in modlog channel\n        if not (\n            guild.me.guild_permissions.send_messages and guild.me.guild_permissions.embed_links\n        ):\n            raise errors.LostPermissions(\n                _(\n                    \"I need the `Send messages` and `Embed links` \"\n                    \"permissions in {channel} to do this.\"\n                ).format(channel=mod_channel.mention)\n            )\n        if level == 2:\n            # mute with role\n            if not guild.me.guild_permissions.manage_roles:\n                raise errors.MissingPermissions(\n                    _(\"I can't manage roles, please give me this permission to continue.\")\n                )\n            if mute_role.position >= guild.me.top_role.position:\n                raise errors.LostPermissions(\n                    _(\n                        \"The mute role `{mute_role}` was moved above my top role `{my_role}`. \"\n                        \"Please move the roles so my top role is above the mute role.\"\n                    ).format(mute_role=mute_role.name, my_role=guild.me.top_role.name)\n                )\n        if level == 3:\n            # kick\n            if not guild.me.guild_permissions.kick_members:\n                raise errors.MissingPermissions(\n                    _(\"I can't kick members, please give me this permission to continue.\")\n                )\n        if level >= 4:\n            # softban or ban\n            if not guild.me.guild_permissions.ban_members:\n                raise errors.MissingPermissions(\n                    _(\"I can't ban members, please give me this permission to continue.\")\n                )\n\n        action = {1: _(\"warn\"), 2: _(\"mute\"), 3: _(\"kick\"), 4: _(\"softban\"), 5: _(\"ban\")}.get(\n            level, _(\"unknown\")\n        )\n        audit_reason = _(\n            \"[WarnSystem] {action} requested by {author} (ID: {author.id}) against {member}. \"\n        ).format(\n            author=author, action=action, member=\"{member}\"\n        )  # member will be edited later\n        if time:\n            audit_reason += _(\"\\n\\nDuration: {time} \").format(time=self._format_timedelta(time))\n        if reason:\n            if len(audit_reason + reason) < 490:\n                audit_reason += _(\"Reason: {reason}\").format(reason=reason)\n            else:\n                audit_reason += _(\"Reason too long to be shown.\")\n        if not date:\n            date = datetime.utcnow()\n\n        i = 0\n        fails = [await warn_member(x, audit_reason) for x in members if x]\n        # all good!\n        return list(filter(None, fails))\n\n    async def _check_endwarn(self):\n        async def reinvite(guild, user, reason, duration):\n            channel = next(\n                (\n                    c  # guild.text_channels is already sorted by position\n                    for c in guild.text_channels\n                    if c.permissions_for(guild.me).create_instant_invite\n                ),\n                None,\n            )\n            if channel is None:\n                # can't find a valid channel\n                log.info(\n                    f\"[Guild {guild.id}] Can't find a text channel where I can create an invite \"\n                    f\"when reinviting {member} (ID: {member.id}) after its unban.\"\n                )\n                return\n\n            try:\n                invite = await channel.create_invite(max_uses=1)\n            except Exception as e:\n                log.warn(\n                    f\"[Guild {guild.id}] Couldn't create an invite to reinvite \"\n                    f\"{member} (ID: {member.id}) after its unban.\",\n                    exc_info=e,\n                )\n            else:\n                try:\n                    await member.send(\n                        _(\n                            \"You were unbanned from {guild}, your temporary ban (reason: \"\n                            \"{reason}) just ended after {duration}.\\nYou can join back using this \"\n                            \"invite: {invite}\"\n                        ).format(guild=guild.name, reason=reason, duration=duration, invite=invite)\n                    )\n                except discord.errors.Forbidden:\n                    # couldn't send message to the user, quite common\n                    log.info(\n                        f\"[Guild {guild.id}] Couldn't reinvite member {member} \"\n                        f\"(ID: {member.id}) after its temporary ban.\"\n                    )\n\n        now = datetime.utcnow()\n        for guild in self.bot.guilds:\n            data = await self.cache.get_temp_action(guild)\n            if not data:\n                continue\n            to_remove = []\n            for member_id, action in data.items():\n                member_id = int(member_id)\n                try:\n                    taken_on = self._get_datetime(action[\"time\"])\n                    duration = self._get_timedelta(action[\"duration\"])\n                except ValueError as e:\n                    log.error(\n                        f\"[Guild {guild.id}] Time or duration cannot be fetched. This is \"\n                        \"probably leftovers from the conversion of post 1.3 data. Removing the \"\n                        f\"temp warning, not taking actions... Member: {member_id}, data: {action}\",\n                        exc_info=e,\n                    )\n                    to_remove.append(UnavailableMember(self.bot, guild._state, member_id))\n                    continue\n                author = guild.get_member(action[\"author\"])\n                member = guild.get_member(member_id)\n                case_reason = action[\"reason\"]\n                level = action[\"level\"]\n                action_str = _(\"mute\") if level == 2 else _(\"ban\")\n                if not member:\n                    member = UnavailableMember(self.bot, guild._state, member_id)\n                    if level == 2:\n                        to_remove.append(member)\n                        continue\n                roles = list(filter(None, [guild.get_role(x) for x in action.get(\"roles\") or []]))\n\n                reason = _(\n                    \"End of timed {action} of {member} requested by {author} that lasted \"\n                    \"for {time}. Reason of the {action}: {reason}\"\n                ).format(\n                    action=action_str,\n                    member=member,\n                    author=author if author else action[\"author\"],\n                    time=self._format_timedelta(duration),\n                    reason=case_reason,\n                )\n                if (taken_on + duration) < now:\n                    # end of warn\n                    try:\n                        if level == 2:\n                            await self._unmute(member, reason=reason, old_roles=roles)\n                        if level == 5:\n                            await guild.unban(member, reason=reason)\n                            if await self.data.guild(guild).reinvite():\n                                await reinvite(\n                                    guild,\n                                    member,\n                                    case_reason,\n                                    self._format_timedelta(timedelta(seconds=action[\"duration\"])),\n                                )\n                    except discord.errors.Forbidden:\n                        log.warn(\n                            f\"[Guild {guild.id}] I lost required permissions for \"\n                            f\"ending the timed {action_str}. Member {member} (ID: {member.id}) \"\n                            \"will stay as it is now.\"\n                        )\n                    except discord.errors.HTTPException as e:\n                        log.warn(\n                            f\"[Guild {guild.id}] Couldn't end the timed {action_str} of {member} \"\n                            f\"(ID: {member.id}). He will stay as it is now.\",\n                            exc_info=e,\n                        )\n                    else:\n                        log.debug(\n                            f\"[Guild {guild.id}] Ended timed {action_str} of {member} (ID: \"\n                            f\"{member.id}) taken on {self._format_datetime(taken_on)} requested \"\n                            f\"by {author} (ID: {author.id}) that lasted for \"\n                            f\"{self._format_timedelta(duration)} for the reason {case_reason}\"\n                            f\"\\nCurrent time: {now}\\nExpected end time of warn: \"\n                            f\"{self._format_datetime(taken_on + duration)}\"\n                        )\n                    to_remove.append(member)\n            if to_remove:\n                await self.cache.bulk_remove_temp_action(guild, to_remove)\n\n    async def _loop_task(self):\n        \"\"\"\n        This is an infinite loop task started with the cog that will check\\\n        if a temporary warn (mute or ban) is over, and cancel the action if it's true.\n\n        The loop runs every 10 seconds.\n        \"\"\"\n        await self.bot.wait_until_ready()\n        log.debug(\n            \"Starting infinite loop for unmutes and unbans. Canel the \"\n            'task with bot.get_cog(\"WarnSystem\").task.cancel()'\n        )\n        errors = 0\n        while True:\n            try:\n                await self._check_endwarn()\n            except Exception as e:\n                errors += 1\n                if errors >= 3:\n                    # more than 3 errors in our loop, let's shut down the loop\n                    log.critical(\n                        \"The loop for unmutes and unbans encountered a third error. To prevent \"\n                        \"more damages, the loop will be cancelled. Timed mutes and bans no longer \"\n                        \"works for now. Reload the cog to start the loop back. If the problem \"\n                        \"persists, report the error and update the cog.\",\n                        exc_info=e,\n                    )\n                    return\n                log.error(\n                    \"Error in loop for unmutes and unbans. The loop will be resumed.\", exc_info=e\n                )\n            await asyncio.sleep(10)\n\n    # automod stuff\n    def enable_automod(self):\n        \"\"\"\n        Enable automod checks and listeners on the bot.\n        \"\"\"\n        log.info(\"Enabling automod listeners and event loops.\")\n        self.bot.add_listener(self.automod_on_message, name=\"on_message\")\n        self.automod_warn_task = self.bot.loop.create_task(self.automod_warn_loop())\n\n    def disable_automod(self):\n        \"\"\"\n        Disable automod checks and listeners on the bot.\n        \"\"\"\n        log.info(\"Disabling automod listeners and event loops.\")\n        self.bot.remove_listener(self.automod_on_message, name=\"on_message\")\n        if hasattr(self, \"automod_warn_task\"):\n            self.automod_warn_task.cancel()\n\n    async def automod_on_message(self, message: discord.Message):\n        guild = message.guild\n        member = message.author\n        if not guild:\n            return\n        if member.bot:\n            return\n        if guild.owner_id == member.id:\n            return\n        if not self.cache.is_automod_enabled(guild):\n            return\n        if await self.bot.is_automod_immune(message):\n            return\n        if await self.bot.is_mod(member):\n            return\n        # we run all tasks concurrently\n        # results are returned in the same order (either None or an exception)\n        regex_exception, antispam_exception = await asyncio.gather(\n            self.automod_process_regex(message),\n            self.automod_process_antispam(message),\n            return_exceptions=True,\n        )\n        if regex_exception:\n            log.error(\n                f\"[Guild {message.guild.id}] Error while processing message for regex automod.\",\n                exc_info=regex_exception,\n            )\n        if antispam_exception:\n            log.error(\n                f\"[Guild {message.guild.id}] Error while processing message for antispam system.\",\n                exc_info=antispam_exception,\n            )\n\n    async def _safe_regex_search(self, regex: re.Pattern, message: discord.Message):\n        \"\"\"\n        Mostly safe regex search to prevent reDOS from user defined regex patterns\n\n        This works by running the regex pattern inside a process pool defined at the\n        cog level and then checking that process in the default executor to keep\n        things asynchronous. If the process takes too long to complete we log a\n        warning and remove the trigger from trying to run again.\n\n        This function was fully made by TrustyJAID for Trusty-cogs/retrigger (amazing cog btw)\n        https://github.com/TrustyJAID/Trusty-cogs/blob/f08a88040dcc67291a463517a70dcbbe702ba8e3/retrigger/triggerhandler.py#L494\n        \"\"\"\n        guild = message.guild\n        try:\n            process = self.re_pool.apply_async(regex.findall, (message.content,))\n            task = functools.partial(process.get, timeout=self.regex_timeout)\n            new_task = self.bot.loop.run_in_executor(None, task)\n            search = await asyncio.wait_for(new_task, timeout=self.regex_timeout + 5)\n        except TimeoutError:\n            error_msg = (\n                f\"[Guild {guild.id}] Automod: regex process took too long. \"\n                f\"Removing from memory. Offending regex: {regex.pattern}\"\n            )\n            log.warning(error_msg)\n            return (False, [])\n            # we certainly don't want to be performing multiple triggers if this happens\n        except asyncio.TimeoutError:\n            error_msg = (\n                f\"[Guild {guild.id}] Automod: regex asyncio timed out. \"\n                f\"Removing from memory. Offending regex: {regex.pattern}\"\n            )\n            log.warning(error_msg)\n            return (False, [])\n        except Exception:\n            log.error(\n                f\"[Guild {guild.id}] Automod regex encountered an error with {regex.pattern}\",\n                exc_info=True,\n            )\n            return (True, [])\n        else:\n            return (True, search)\n\n    async def automod_process_regex(self, message: discord.Message):\n        guild = message.guild\n        member = message.author\n        all_regex = await self.cache.get_automod_regex(guild)\n        for name, regex in all_regex.items():\n            result = await self._safe_regex_search(regex[\"regex\"], message)\n            if not result[1]:\n                if result[0] is False:\n                    await self.cache.remove_automod_regex(guild, name)\n                continue\n            time = None\n            if regex[\"time\"]:\n                time = self._get_timedelta(regex[\"time\"])\n            level = regex[\"level\"]\n            reason = regex[\"reason\"].format(guild=guild, channel=message.channel, member=member)\n            fail = await self.warn(guild, [member], guild.me, level, reason, time)\n            if fail:\n                log.warn(\n                    f\"[Guild {guild.id}] Regex automod warn on member {member} ({member.id})\\n\"\n                    f\"Level: {level}. Time: {time}. Reason: {reason}\\n\"\n                    f\"Original message: {message.content}\\n\"\n                    f\"Automatic warn failed due to the following exception:\",\n                    exc_info=fail[0],\n                )\n            else:\n                log.info(\n                    f\"[Guild {guild.id}] Regex automod warn on member {member} ({member.id})\\n\"\n                    f\"Level: {level}. Time: {time}. Reason: {reason}\\n\"\n                    f\"Original message: {message.content}\"\n                )\n\n    async def automod_process_antispam(self, message: discord.Message):\n        # we store the data in self.antispam\n        # keys are as follow: GUILD_ID > CHANNEL_ID > MEMBER_ID = tuple\n        # tuple contains list timestamps of recent messages + check if the member was warned\n        # if the antispam is triggered once, we send a message in the chat (refered as text warn)\n        # if it's triggered a second time, an actual warn is given\n        guild = message.guild\n        channel = message.channel\n        member = message.author\n        antispam_data = await self.cache.get_automod_antispam(guild)\n        if antispam_data is False:\n            return\n\n        # we slowly go across each key, if it doesn't exist, data is created then the\n        # function ends since there's no data to check\n        InitialData = namedtuple(\"InitialData\", [\"messages\", \"warned\"])\n        data = InitialData(messages=[], warned=False)\n        try:\n            guild_data = self.antispam[guild.id]\n        except KeyError:\n            self.antispam[guild.id] = {channel.id: {member.id: data}}\n            return\n        else:\n            pass\n        try:\n            channel_data = guild_data[channel.id]\n        except KeyError:\n            self.antispam[guild.id][channel.id] = {member.id: data}\n            return\n        else:\n            del guild_data\n        try:\n            data = channel_data[member.id]\n        except KeyError:\n            pass\n        del channel_data\n\n        data.messages.append(message.created_at)\n        # now we've got our list of timestamps, just gotta clean the old ones\n        data = data._replace(\n            messages=self._automod_clean_old_messages(\n                antispam_data[\"delay\"], message.created_at, data.messages\n            )\n        )\n        if len(data.messages) <= antispam_data[\"max_messages\"]:\n            # antispam not triggered, we can exit now\n            self.antispam[guild.id][channel.id][member.id] = data\n            return\n        # at this point, user is considered to be spamming\n        # we cleanup his x last messages (max_messages + 1), then either send a text warn\n        # or perform an actual warnsystem warn (I'm confusing ik)\n        if (\n            data.warned is False\n            or (datetime.now() - data.warned).total_seconds()\n            < antispam_data[\"delay_before_action\"]\n        ):\n            bot_message = await channel.send(\n                _(\"{member} you're sending messages too fast!\").format(member=member.mention),\n                delete_after=5,\n            )\n            data = InitialData(messages=[], warned=bot_message.created_at)\n        else:\n            # already warned once within delay_before_action, gotta take actions\n            warn_data = antispam_data[\"warn\"]\n            warn_data[\"author\"] = guild.me\n            if warn_data[\"time\"]:\n                warn_data[\"time\"] = self._get_timedelta(warn_data[\"time\"])\n            try:\n                self.antispam_warn_queue[guild.id][member] = warn_data\n            except KeyError:\n                self.antispam_warn_queue[guild.id] = {member: warn_data}\n            # also reset the data\n            data = InitialData(messages=[], warned=message.created_at)\n        self.antispam[guild.id][channel.id][member.id] = data\n\n    def _automod_clean_old_messages(self, delay: int, current_time: datetime, messages: list):\n        \"\"\"\n        We don't keep messages older than the delay in the cache\n        \"\"\"\n        message: datetime\n        delta: timedelta\n        new_list = []\n        for message in messages:\n            delta = current_time - message\n            if delta.total_seconds() <= delay:\n                new_list.append(message)\n        return new_list\n\n    def _automod_clean_cache(\n        self, guild: discord.Guild, channel: discord.TextChannel, member: discord.Member\n    ):\n        \"\"\"\n        We quickly end up with a dict filled with empty values, we gotta clean that.\n        \"\"\"\n        del self.automod[guild.id][channel.id][member.id]\n        if not self.automod[guild.id][channel.id]:\n            del self.automod[guild.id][channel.id]\n            if not self.automod[guild.id]:\n                del self.automod[guild.id]\n\n    async def automod_check_for_autowarn(\n        self, guild: discord.Guild, member: discord.Member, author: discord.Member, level: int\n    ):\n        \"\"\"\n        Iterate through member's modlog, looking for possible automatic warns.\n\n        Level is the last warning's level, which will filter a lot of possible autowarns and,\n        therefore, save performances.\n\n        This can be a heavy call if there are a lot of possible autowarns and a long modlog.\n        \"\"\"\n        t = datetime.now()\n        try:\n            await self._automod_check_for_autowarn(guild, member, author, level)\n        except Exception as e:\n            log.error(f\"[Guild {guild.id}] A problem occured with automod check.\", exc_info=e)\n        time_taken: timedelta = datetime.now() - t\n        if time_taken.total_seconds() > 10 and guild.id not in self.warned_guilds:\n            self.warned_guilds.append(guild.id)\n            log.warning(\n                f\"[Guild {guild.id}] Automod check took a long time! Time taken: {time_taken}\\n\"\n                \"Try to reduce the amount of warns/autowarns or blame Laggron for poorly \"\n                \"written code (second option is preferred).\\nThis warning will not show again \"\n                \"for this guild until reload.\"\n            )\n\n    async def _automod_check_for_autowarn(\n        self, guild: discord.Guild, member: discord.Member, author: discord.Member, level: int\n    ):\n        \"\"\"\n        Prevents having to put this whole function into a try/except block.\n        \"\"\"\n        if not self.cache.is_automod_enabled(guild):\n            return\n        # starting the iteration through warnings can cost performances\n        # so we look for conditions that confirms the member cannot be affected by automod\n        if await self.bot.is_automod_immune(member):\n            return\n        warns = await self.get_all_cases(guild, member)\n        if len(warns) < 2:\n            return  # autowarn can't be triggered with a single warning in the modlog\n        autowarns = await self.data.guild(guild).automod.warnings()\n        # remove all autowarns that are locked to a specific level\n        # where the last warning's level doesn't correspond\n        # also remove autowarns that are automod only if warn author isn't the bot\n\n        def is_autowarn_valid(warn):\n            if author.id != self.bot.user.id and warn[\"automod_only\"]:\n                return False\n            return warn[\"level\"] == 0 or warn[\"level\"] == level\n\n        autowarns = list(filter(is_autowarn_valid, autowarns))\n        if not autowarns:\n            return  # no autowarn to iterate through\n        for i, autowarn in enumerate(autowarns):\n            # prepare for iteration\n            autowarns[i][\"count\"] = 0\n            # if the condition is met (within the specified time? not an automatic warn?)\n            # we increase this value until reaching the given limit\n            time = autowarn[\"time\"]\n            if time:\n                until = datetime.utcnow() - timedelta(seconds=time)\n                autowarns[i][\"until\"] = until\n        del time\n        found_warnings = {}  # we fill this list with the valid autowarns, there can be more than 1\n        for warn in warns[::-1]:\n            to_remove = []  # list of autowarns to remove during the iteration (duration expired)\n            taken_on = datetime.fromtimestamp(warn[\"time\"])\n            for i, autowarn in enumerate(autowarns):\n                try:\n                    if autowarn[\"until\"] >= taken_on:\n                        to_remove.append(i)\n                        continue\n                except KeyError:\n                    pass\n                autowarns[i][\"count\"] += 1\n                if autowarns[i][\"count\"] == autowarn[\"number\"]:\n                    found_warnings[i] = autowarn[\"warn\"]\n                if autowarns[i][\"count\"] > autowarn[\"number\"]:\n                    # value exceeded, no need to continue, it's already done for this one warn\n                    to_remove.append(i)\n                    del found_warnings[i]\n            for index in reversed(to_remove):\n                autowarns.pop(index)\n            if not autowarns:\n                # we could be out of autowarns to check after a certain time\n                # no need to continue the iteration\n                break\n        del to_remove, taken_on, autowarns\n        for i, warn in found_warnings.items():\n            try:\n                await self.warn(\n                    guild,\n                    members=[member],\n                    author=guild.me,\n                    level=warn[\"level\"],\n                    reason=warn[\"reason\"],\n                    time=self._get_timedelta(warn[\"duration\"]) if warn[\"duration\"] else None,\n                )\n            except Exception as e:\n                log.error(\n                    f\"[Guild {guild.id}] Failed to perform automod warn on member {member} \"\n                    f\"({member.id}). Needed to perform automatic warn {i}\",\n                    exc_info=e,\n                )\n            else:\n                log.debug(\n                    f\"[Guild {guild.id}] Successfully performed automatic \"\n                    f\"warn {i} on member {member} ({member.id}).\"\n                )\n\n    async def automod_warn_loop(self):\n        # since this is asyncronous code, sometimes there can be too many warnings performed\n        # especially with message antispam, since it treats multiple messages simultaneously\n        # instead, we have a dict of warnings to perform, and we remove it only once the warn is\n        # done. That way, duplicate warnings won't happen.\n\n        async def warn(member: discord.Member, data: dict):\n            guild = member.guild\n            try:\n                await self.warn(guild, [member], **data)\n            except Exception as e:\n                log.error(\n                    f\"Cannot perform autowarn on member {member} ({member.id}). Data: {data}\",\n                    exc_info=e,\n                )\n            finally:\n                await asyncio.sleep(1)\n                del self.antispam_warn_queue[guild.id][member]\n                if not self.antispam_warn_queue[guild.id]:\n                    del self.antispam_warn_queue[guild.id]\n\n        async def loop():\n            guild: discord.Guild\n            member: discord.Member\n            coros = []\n            for guild_id, data in self.antispam_warn_queue.items():\n                for member, value in data.items():\n                    coros.append(warn(member, value))\n            coros = asyncio.gather(*coros, return_exceptions=True)\n            await coros\n\n        errors = 0\n        while True:\n            try:\n                await loop()\n            except Exception as e:\n                errors += 1\n                if errors >= 3:\n                    # more than 3 errors in our loop, let's shut down the loop\n                    log.critical(\n                        \"The loop for automod warnings encountered a third error. To prevent \"\n                        \"more damages, the loop will be cancelled. Timed mutes and bans no longer \"\n                        \"works for now. Reload the cog to start the loop back. If the problem \"\n                        \"persists, report the error and update the cog.\",\n                        exc_info=e,\n                    )\n                    return\n                log.error(\n                    \"Error in loop for automod warnings. The loop will be resumed.\", exc_info=e\n                )\n            await asyncio.sleep(1)\n", "# WarnSystem by retke, aka El Laggron\nimport discord\nimport logging\nimport asyncio\nimport re\n\nfrom typing import Optional\nfrom asyncio import TimeoutError as AsyncTimeoutError\nfrom abc import ABC\nfrom datetime import datetime, timedelta\nfrom laggron_utils.logging import close_logger, DisabledConsoleOutput\n\nfrom redbot.core import commands, Config, checks\nfrom redbot.core.commands.converter import TimedeltaConverter\nfrom redbot.core.i18n import Translator, cog_i18n\nfrom redbot.core.utils import predicates, menus, mod\nfrom redbot.core.utils.chat_formatting import pagify\n\nfrom . import errors\nfrom .api import API, UnavailableMember\nfrom .automod import AutomodMixin\nfrom .cache import MemoryCache\nfrom .converters import AdvancedMemberSelect\nfrom .settings import SettingsMixin\n\nlog = logging.getLogger(\"red.laggron.warnsystem\")\n_ = Translator(\"WarnSystem\", __file__)\nBaseCog = getattr(commands, \"Cog\", object)\n\n# Red 3.0 backwards compatibility, thanks Sinbad\nlistener = getattr(commands.Cog, \"listener\", None)\nif listener is None:\n\n    def listener(name=None):\n        return lambda x: x\n\n\ndef pretty_date(time: datetime):\n    \"\"\"\n    Get a datetime object and return a pretty string like 'an hour ago',\n    'Yesterday', '3 months ago', 'just now', etc\n\n    This is based on this answer, modified for i18n compatibility:\n    https://stackoverflow.com/questions/1551382/user-friendly-time-format-in-python\n    \"\"\"\n\n    def text(amount: float, unit: tuple):\n        amount = round(amount)\n        if amount > 1:\n            unit = unit[1]\n        else:\n            unit = unit[0]\n        return _(\"{amount} {unit} ago.\").format(amount=amount, unit=unit)\n\n    units_name = {\n        0: (_(\"year\"), _(\"years\")),\n        1: (_(\"month\"), _(\"months\")),\n        2: (_(\"week\"), _(\"weeks\")),\n        3: (_(\"day\"), _(\"days\")),\n        4: (_(\"hour\"), _(\"hours\")),\n        5: (_(\"minute\"), _(\"minutes\")),\n        6: (_(\"second\"), _(\"seconds\")),\n    }\n    now = datetime.now()\n    diff = now - time\n    second_diff = diff.seconds\n    day_diff = diff.days\n    if day_diff < 0:\n        return \"\"\n    if day_diff == 0:\n        if second_diff < 10:\n            return _(\"Just now\")\n        if second_diff < 60:\n            return text(second_diff, units_name[6])\n        if second_diff < 120:\n            return _(\"A minute ago\")\n        if second_diff < 3600:\n            return text(second_diff / 60, units_name[5])\n        if second_diff < 7200:\n            return _(\"An hour ago\")\n        if second_diff < 86400:\n            return text(second_diff / 3600, units_name[4])\n    if day_diff == 1:\n        return _(\"Yesterday\")\n    if day_diff < 7:\n        return text(day_diff, units_name[3])\n    if day_diff < 31:\n        return text(day_diff / 7, units_name[2])\n    if day_diff < 365:\n        return text(day_diff / 30, units_name[1])\n    return text(day_diff / 365, units_name[0])\n\n\n# Red 3.1 backwards compatibility\ntry:\n    from redbot.core.utils.chat_formatting import text_to_file\nexcept ImportError:\n    from io import BytesIO\n\n    log.warn(\"Outdated redbot, consider updating.\")\n    # I'm the author of this function but it was made for Cog-Creators\n    # Source: https://github.com/Cog-Creators/Red-DiscordBot/blob/V3/develop/redbot/core/utils/chat_formatting.py#L478\n    def text_to_file(\n        text: str, filename: str = \"file.txt\", *, spoiler: bool = False, encoding: str = \"utf-8\"\n    ):\n        file = BytesIO(text.encode(encoding))\n        return discord.File(file, filename, spoiler=spoiler)\n\n\nEMBED_MODLOG = lambda x: _(\"A member got a level {} warning.\").format(x)\nEMBED_USER = lambda x: _(\"The moderation team set you a level {} warning.\").format(x)\n\n\nclass CompositeMetaClass(type(commands.Cog), type(ABC)):\n    \"\"\"\n    This allows the metaclass used for proper type detection to\n    coexist with discord.py's metaclass\n\n    Credit to https://github.com/Cog-Creators/Red-DiscordBot (mod cog) for all mixin stuff.\n    \"\"\"\n\n    pass\n\n\n@cog_i18n(_)\nclass WarnSystem(SettingsMixin, AutomodMixin, BaseCog, metaclass=CompositeMetaClass):\n    \"\"\"\n    An alternative to the Red core moderation system, providing a different system of moderation\\\n    similar to Dyno.\n\n    Report a bug or ask a question: https://discord.gg/AVzjfpR\n    Full documentation and FAQ: http://laggron.red/warnsystem.html\n    \"\"\"\n\n    default_global = {\n        \"data_version\": \"0.0\"  # will be edited after config update, current version is 1.0\n    }\n    default_guild = {\n        \"delete_message\": False,  # if the [p]warn commands should delete the context message\n        \"show_mod\": False,  # if the responsible mod should be revealed to the warned user\n        \"mute_role\": None,  # the role used for mute\n        \"update_mute\": False,  # if the bot should update perms of each new text channel/category\n        \"remove_roles\": False,  # if the bot should remove all other roles on mute\n        \"respect_hierarchy\": False,  # if the bot should check if the mod is allowed by hierarchy\n        # TODO use bot settingfor respect_hierarchy ?\n        \"reinvite\": True,  # if the bot should try to send an invite to an unbanned/kicked member\n        \"log_manual\": False,  # if the bot should log manual kicks and bans\n        \"channels\": {  # modlog channels\n            \"main\": None,  # default\n            \"1\": None,\n            \"2\": None,\n            \"3\": None,\n            \"4\": None,\n            \"5\": None,\n        },\n        \"bandays\": {  # the number of days of messages to delte in case of a ban/softban\n            \"softban\": 7,\n            \"ban\": 0,\n        },\n        \"embed_description_modlog\": {  # the description of each type of warn in modlog\n            \"1\": EMBED_MODLOG(1),\n            \"2\": EMBED_MODLOG(2),\n            \"3\": EMBED_MODLOG(3),\n            \"4\": EMBED_MODLOG(4),\n            \"5\": EMBED_MODLOG(5),\n        },\n        \"embed_description_user\": {  # the description of each type of warn for the user\n            \"1\": EMBED_USER(1),\n            \"2\": EMBED_USER(2),\n            \"3\": EMBED_USER(3),\n            \"4\": EMBED_USER(4),\n            \"5\": EMBED_USER(5),\n        },\n        \"substitutions\": {},\n        \"thumbnails\": {  # image at the top right corner of an embed\n            \"1\": \"https://i.imgur.com/Bl62rGd.png\",\n            \"2\": \"https://i.imgur.com/cVtzp1M.png\",\n            \"3\": \"https://i.imgur.com/uhrYzyt.png\",\n            \"4\": \"https://i.imgur.com/uhrYzyt.png\",\n            \"5\": \"https://i.imgur.com/DfBvmic.png\",\n        },\n        \"colors\": {  # color bar of an embed\n            \"1\": 0xF4AA42,\n            \"2\": 0xD1ED35,\n            \"3\": 0xED9735,\n            \"4\": 0xED6F35,\n            \"5\": 0xFF4C4C,\n        },\n        \"url\": None,  # URL set for the title of all embeds\n        \"temporary_warns\": {},  # list of temporary warns (need to unmute/unban after some time)\n        \"automod\": {  # everything related to auto moderation\n            \"enabled\": False,\n            \"antispam\": {\n                \"enabled\": False,\n                \"max_messages\": 5,  # maximum number of messages allowed within the delay\n                \"delay\": 2,  # in seconds\n                \"delay_before_action\": 60,  # if triggered twice within this delay, take action\n                \"warn\": {  # data of the warn\n                    \"level\": 1,\n                    \"reason\": \"Sending messages too fast!\",\n                    \"time\": None,\n                },\n            },\n            \"regex\": {},  # all regex expressions\n            \"warnings\": [],  # all automatic warns\n        },\n    }\n    default_custom_member = {\"x\": []}  # cannot set a list as base group\n\n    def __init__(self, bot):\n        self.bot = bot\n\n        self.data = Config.get_conf(self, 260, force_registration=True)\n        self.data.register_global(**self.default_global)\n        self.data.register_guild(**self.default_guild)\n        try:\n            self.data.init_custom(\"MODLOGS\", 2)\n        except AttributeError:\n            pass\n        self.data.register_custom(\"MODLOGS\", **self.default_custom_member)\n\n        self.cache = MemoryCache(self.bot, self.data)\n        self.api = API(self.bot, self.data, self.cache)\n\n        self.task: asyncio.Task\n\n    __version__ = \"1.3.17\"\n    __author__ = [\"retke (El Laggron)\"]\n\n    # helpers\n    async def call_warn(self, ctx, level, member, reason=None, time=None):\n        \"\"\"No need to repeat, let's do what's common to all 5 warnings.\"\"\"\n        reason = await self.api.format_reason(ctx.guild, reason)\n        if reason and len(reason) > 2000:  # embed limits\n            await ctx.send(\n                _(\n                    \"The reason is too long for an embed.\\n\\n\"\n                    \"*Tip: You can use Github Gist to write a long text formatted in Markdown, \"\n                    \"create a new file with the extension `.md` at the end and write as if you \"\n                    \"were on Discord.\\n<https://gist.github.com/>*\"\n                    # I was paid $99999999 for this, you're welcome\n                )\n            )\n            return\n        try:\n            fail = await self.api.warn(ctx.guild, [member], ctx.author, level, reason, time)\n            if fail:\n                raise fail[0]\n        except errors.MissingPermissions as e:\n            await ctx.send(e)\n        except errors.MemberTooHigh as e:\n            await ctx.send(e)\n        except errors.LostPermissions as e:\n            await ctx.send(e)\n        except errors.SuicidePrevention as e:\n            await ctx.send(e)\n        except errors.MissingMuteRole:\n            await ctx.send(\n                _(\n                    \"You need to set up the mute role before doing this.\\n\"\n                    \"Use the `[p]warnset mute` command for this.\"\n                )\n            )\n        except errors.NotFound:\n            await ctx.send(\n                _(\n                    \"Please set up a modlog channel before warning a member.\\n\\n\"\n                    \"**With WarnSystem**\\n\"\n                    \"*Use the `[p]warnset channel` command.*\\n\\n\"\n                    \"**With Red Modlog**\\n\"\n                    \"*Load the `modlogs` cog and use the `[p]modlogset modlog` command.*\"\n                )\n            )\n        except errors.NotAllowedByHierarchy:\n            is_admin = mod.is_admin_or_superior(self.bot, member)\n            await ctx.send(\n                _(\n                    \"You are not allowed to do this, {member} is higher than you in the role \"\n                    \"hierarchy. You can only warn members which top role is lower than yours.\\n\\n\"\n                ).format(member=str(member))\n                + (\n                    _(\"You can disable this check by using the `[p]warnset hierarchy` command.\")\n                    if is_admin\n                    else \"\"\n                )\n            )\n        except discord.errors.NotFound:\n            await ctx.send(_(\"Hackban failed: No user found.\"))\n        else:\n            if ctx.channel.permissions_for(ctx.guild.me).add_reactions:\n                try:\n                    await ctx.message.add_reaction(\"\u2705\")\n                except discord.errors.NotFound:\n                    # retrigger or scheduler probably executed the command\n                    pass\n            else:\n                await ctx.send(_(\"Done.\"))\n\n    async def call_masswarn(\n        self,\n        ctx,\n        level,\n        members,\n        unavailable_members,\n        log_modlog,\n        log_dm,\n        take_action,\n        reason=None,\n        time=None,\n        confirm=False,\n    ):\n        guild = ctx.guild\n        message = None\n        i = 0\n        total_members = len(members)\n        total_unavailable_members = len(unavailable_members)\n        tick1 = \"\u2705\" if log_modlog else \"\u274c\"\n        tick2 = \"\u2705\" if log_dm else \"\u274c\"\n        tick3 = f\"{'\u2705' if take_action else '\u274c'} Take action\\n\" if level != 1 else \"\"\n        tick4 = f\"{'\u2705' if time else '\u274c'} Time: \" if (level == 2 or level == 5) else \"\"\n        tick5 = \"\u2705\" if reason else \"\u274c\"\n        time_str = (self.api._format_timedelta(time) + \"\\n\") if time else \"\"\n\n        async def update_count(count):\n            nonlocal i\n            i = count\n\n        async def update_message():\n            while True:\n                nonlocal message\n                content = _(\n                    \"Processing mass warning...\\n\"\n                    \"{i}/{total} {members} warned ({percent}%)\\n\\n\"\n                    \"{tick1} Log to the modlog\\n\"\n                    \"{tick2} Send a DM to all members\\n\"\n                    \"{tick3}\"\n                    \"{tick4} {time}\\n\"\n                    \"{tick5} Reason: {reason}\"\n                ).format(\n                    i=i,\n                    total=total_members + total_unavailable_members,\n                    members=_(\"members\") if i != 1 else _(\"member\"),\n                    percent=round((i / total_members) * 100, 2),\n                    tick1=tick1,\n                    tick2=tick2,\n                    tick3=tick3,\n                    tick4=tick4,\n                    time=time_str,\n                    tick5=tick5,\n                    reason=reason or \"Not set\",\n                )\n                if message:\n                    await message.edit(content=content)\n                else:\n                    message = await ctx.send(content)\n                await asyncio.sleep(5)\n\n        if unavailable_members and level < 5:\n            await ctx.send(_(\"You can only use `--hackban-select` with a level 5 warn.\"))\n            return\n        reason = await self.api.format_reason(ctx.guild, reason)\n        if (log_modlog or log_dm) and reason and len(reason) > 2000:  # embed limits\n            await ctx.send(\n                _(\n                    \"The reason is too long for an embed.\\n\\n\"\n                    \"*Tip: You can use Github Gist to write a long text formatted in Markdown, \"\n                    \"create a new file with the extension `.md` at the end and write as if you \"\n                    \"were on Discord.\\n<https://gist.github.com/>*\"\n                    # I was paid $99999999 for this, you're welcome\n                )\n            )\n            return\n        file = text_to_file(\n            \"\\n\".join([f\"{str(x)} ({x.id})\" for x in members + unavailable_members])\n        )\n        targets = []\n        if members:\n            targets.append(\n                _(\"{total} {members} ({percent}% of the server)\").format(\n                    total=total_members,\n                    members=_(\"members\") if total_members > 1 else _(\"member\"),\n                    percent=round((total_members / len(guild.members) * 100), 2),\n                )\n            )\n        if unavailable_members:\n            targets.append(\n                _(\"{total} {users} not in the server.\").format(\n                    total=total_unavailable_members,\n                    users=_(\"users\") if total_unavailable_members > 1 else _(\"user\"),\n                )\n            )\n        if not confirm:\n            msg = await ctx.send(\n                _(\n                    \"You're about to set a level {level} warning on {target}.\\n\\n\"\n                    \"{tick1} Log to the modlog\\n\"\n                    \"{tick2} Send a DM to all members\\n\"\n                    \"{tick3}\"\n                    \"{tick4} {time}\\n\"\n                    \"{tick5} Reason: {reason}\\n\\n{warning}\"\n                    \"Continue?\"\n                ).format(\n                    level=level,\n                    target=_(\" and \").join(targets),\n                    tick1=tick1,\n                    tick2=tick2,\n                    tick3=tick3,\n                    tick4=tick4,\n                    time=time_str,\n                    tick5=tick5,\n                    reason=reason or _(\"Not set\"),\n                    warning=_(\n                        \":warning: You're about to warn a lot of members! Avoid doing this to \"\n                        \"prevent being rate limited by Discord, especially if you enabled DMs.\\n\\n\"\n                    )\n                    if len(members) > 50 and level > 1\n                    else \"\",\n                ),\n                file=file,\n            )\n            menus.start_adding_reactions(msg, predicates.ReactionPredicate.YES_OR_NO_EMOJIS)\n            pred = predicates.ReactionPredicate.yes_or_no(msg, ctx.author)\n            try:\n                await self.bot.wait_for(\"reaction_add\", check=pred, timeout=120)\n            except AsyncTimeoutError:\n                if ctx.guild.me.guild_permissions.manage_messages:\n                    await msg.clear_reactions()\n                else:\n                    for reaction in msg.reactions():\n                        await msg.remove_reaction(reaction, ctx.guild.me)\n                return\n            if not pred.result:\n                await ctx.send(_(\"Mass warn cancelled.\"))\n                return\n            task = self.bot.loop.create_task(update_message())\n        try:\n            fails = await self.api.warn(\n                guild=guild,\n                members=members + unavailable_members,\n                author=ctx.author,\n                level=level,\n                reason=reason,\n                time=time,\n                log_modlog=log_modlog,\n                log_dm=log_dm,\n                take_action=take_action,\n                progress_tracker=update_count if not confirm else None,\n            )\n        except errors.MissingPermissions as e:\n            await ctx.send(e)\n        except errors.LostPermissions as e:\n            await ctx.send(e)\n        except errors.MissingMuteRole:\n            if not confirm:\n                await ctx.send(\n                    _(\n                        \"You need to set up the mute role before doing this.\\n\"\n                        \"Use the `[p]warnset mute` command for this.\"\n                    )\n                )\n        except errors.NotFound:\n            if not confirm:\n                await ctx.send(\n                    _(\n                        \"Please set up a modlog channel before warning a member.\\n\\n\"\n                        \"**With WarnSystem**\\n\"\n                        \"*Use the `[p]warnset channel` command.*\\n\\n\"\n                        \"**With Red Modlog**\\n\"\n                        \"*Load the `modlogs` cog and use the `[p]modlogset modlog` command.*\"\n                    )\n                )\n        else:\n            if not confirm:\n                if fails:\n                    await ctx.send(\n                        _(\"Done! {failed} {members} out of {total} couldn't be warned.\").format(\n                            failed=len(fails),\n                            members=_(\"members\") if len(fails) > 1 else _(\"member\"),\n                            total=total_members,\n                        )\n                    )\n                else:\n                    await ctx.send(\n                        _(\"Done! {total} {members} successfully warned.\").format(\n                            total=total_members,\n                            members=_(\"members\") if total_members > 1 else _(\"member\"),\n                        )\n                    )\n            else:\n                try:\n                    await ctx.message.add_reaction(\"\u2705\")\n                except discord.errors.HTTPException:\n                    pass\n        finally:\n            if not confirm:\n                task.cancel()\n            if message:\n                await message.delete()\n\n    # all warning commands\n    @commands.group(invoke_without_command=True, name=\"warn\")\n    @checks.mod_or_permissions(administrator=True)\n    @commands.guild_only()\n    async def _warn(self, ctx: commands.Context, member: discord.Member, *, reason: str = None):\n        \"\"\"\n        Take actions against a user and log it.\n        The warned user will receive a DM.\n\n        If not given, the warn level will be 1.\n        \"\"\"\n        await self.call_warn(ctx, 1, member, reason)\n\n    @_warn.command(name=\"1\", aliases=[\"simple\"])\n    @checks.mod_or_permissions(administrator=True)\n    async def warn_1(self, ctx: commands.Context, member: discord.Member, *, reason: str = None):\n        \"\"\"\n        Set a simple warning on a user.\n\n        Note: You can either call `[p]warn 1` or `[p]warn`.\n        \"\"\"\n        await self.call_warn(ctx, 1, member, reason)\n\n    @_warn.command(name=\"2\", aliases=[\"mute\"])\n    @checks.mod_or_permissions(administrator=True)\n    async def warn_2(\n        self,\n        ctx: commands.Context,\n        member: discord.Member,\n        time: Optional[TimedeltaConverter],\n        *,\n        reason: str = None,\n    ):\n        \"\"\"\n        Mute the user in all channels, including voice channels.\n\n        This mute will use a role that will automatically be created, if it was not already done.\n        Feel free to edit the role's permissions and move it in the roles hierarchy.\n\n        You can set a timed mute by providing a valid time before the reason.\n\n        Examples:\n        - `[p]warn 2 @user 30m`: 30 minutes mute\n        - `[p]warn 2 @user 5h Spam`: 5 hours mute for the reason \"Spam\"\n        - `[p]warn 2 @user Advertising`: Infinite mute for the reason \"Advertising\"\n        \"\"\"\n        await self.call_warn(ctx, 2, member, reason, time)\n\n    @_warn.command(name=\"3\", aliases=[\"kick\"])\n    @checks.mod_or_permissions(administrator=True)\n    async def warn_3(self, ctx: commands.Context, member: discord.Member, *, reason: str = None):\n        \"\"\"\n        Kick the member from the server.\n        \"\"\"\n        await self.call_warn(ctx, 3, member, reason)\n\n    @_warn.command(name=\"4\", aliases=[\"softban\"])\n    @checks.mod_or_permissions(administrator=True)\n    async def warn_4(self, ctx: commands.Context, member: discord.Member, *, reason: str = None):\n        \"\"\"\n        Softban the member from the server.\n\n        This means that the user will be banned and immediately unbanned, so it will purge their\\\n        messages in all channels.\n\n        It will delete 7 days of messages by default, but you can edit this with the\\\n        `[p]warnset bandays` command.\n        \"\"\"\n        await self.call_warn(ctx, 4, member, reason)\n\n    @_warn.command(name=\"5\", aliases=[\"ban\"], usage=\"<member> [time] <reason>\")\n    @checks.mod_or_permissions(administrator=True)\n    async def warn_5(\n        self,\n        ctx: commands.Context,\n        member: UnavailableMember,\n        time: Optional[TimedeltaConverter],\n        *,\n        reason: str = None,\n    ):\n        \"\"\"\n        Ban the member from the server.\n\n        This ban can be a normal ban, a temporary ban or a hack ban (bans a user not in the\\\n        server).\n        It won't delete messages by default, but you can edit this with the `[p]warnset bandays`\\\n        command.\n\n        If you want to perform a temporary ban, provide the time before the reason. A hack ban\\\n        needs a user ID, you can get it with the Developer mode (enable it in the Appearance tab\\\n        of the user settings, then right click on the user and select \"Copy ID\").\n\n        Examples:\n        - `[p]warn 5 @user`: Ban for no reason :c\n        - `[p]warn 5 @user 7d Insults`: 7 days ban for the reason \"Insults\"\n        - `[p]warn 5 012345678987654321 Advertising and leave`: Ban the user with the ID provided\\\n        while they're not in the server for the reason \"Advertising and leave\" (if the user shares\\\n        another server with the bot, a DM will be sent).\n        \"\"\"\n        await self.call_warn(ctx, 5, member, reason, time)\n\n    @commands.group(invoke_without_command=True)\n    @commands.guild_only()\n    @checks.mod_or_permissions(administrator=True)\n    @commands.cooldown(1, 10, commands.BucketType.guild)\n    async def masswarn(self, ctx, *selection: str):\n        \"\"\"\n        Perform a warn on multiple members at once.\n\n        To select members, you have to use UNIX-like flags to add conditions\\\n        which will be checked for each member.\n\n        Example: `[p]masswarn 3 --take-action --send-dm --has-role \"Danger\"\\\n        --joined-after \"May 2019\" --reason \"Cleaning dangerous members\"`\n\n        To get the full list of flags and how to use them, please read the\\\n        wiki: https://laggrons-dumb-cogs.readthedocs.io/\n        \"\"\"\n        if not selection:\n            await ctx.send_help()\n            return\n        try:\n            selection = await AdvancedMemberSelect().convert(ctx, selection)\n        except commands.BadArgument as e:\n            await ctx.send(e)\n            return\n        await self.call_masswarn(\n            ctx,\n            1,\n            selection.members,\n            selection.unavailable_members,\n            selection.send_modlog,\n            selection.send_dm,\n            selection.take_action,\n            selection.reason,\n            None,\n            selection.confirm,\n        )\n\n    @masswarn.command(name=\"1\", aliases=[\"simple\"])\n    @checks.mod_or_permissions(administrator=True)\n    async def masswarn_1(self, ctx, *selection: str):\n        \"\"\"\n        Perform a simple mass warning.\n        \"\"\"\n        if not selection:\n            await ctx.send_help()\n            return\n        try:\n            selection = await AdvancedMemberSelect().convert(ctx, selection)\n        except commands.BadArgument as e:\n            await ctx.send(e)\n            return\n        await self.call_masswarn(\n            ctx,\n            1,\n            selection.members,\n            selection.unavailable_members,\n            selection.send_modlog,\n            selection.send_dm,\n            selection.take_action,\n            selection.reason,\n            None,\n            selection.confirm,\n        )\n\n    @masswarn.command(name=\"2\", aliases=[\"mute\"])\n    @checks.mod_or_permissions(administrator=True)\n    async def masswarn_2(self, ctx, *selection: str):\n        \"\"\"\n        Perform a mass mute.\n\n        You can provide a duration with the `--time` flag, the format is the same as the simple\\\n        level 2 warning.\n        \"\"\"\n        if not selection:\n            await ctx.send_help()\n            return\n        try:\n            selection = await AdvancedMemberSelect().convert(ctx, selection)\n        except commands.BadArgument as e:\n            await ctx.send(e)\n            return\n        await self.call_masswarn(\n            ctx,\n            2,\n            selection.members,\n            selection.unavailable_members,\n            selection.send_modlog,\n            selection.send_dm,\n            selection.take_action,\n            selection.reason,\n            selection.time,\n            selection.confirm,\n        )\n\n    @masswarn.command(name=\"3\", aliases=[\"kick\"])\n    @checks.mod_or_permissions(administrator=True)\n    async def masswarn_3(self, ctx, *selection: str):\n        \"\"\"\n        Perform a mass kick.\n        \"\"\"\n        if not selection:\n            await ctx.send_help()\n            return\n        try:\n            selection = await AdvancedMemberSelect().convert(ctx, selection)\n        except commands.BadArgument as e:\n            await ctx.send(e)\n            return\n        await self.call_masswarn(\n            ctx,\n            3,\n            selection.members,\n            selection.unavailable_members,\n            selection.send_modlog,\n            selection.send_dm,\n            selection.take_action,\n            selection.reason,\n            None,\n            selection.confirm,\n        )\n\n    @masswarn.command(name=\"4\", aliases=[\"softban\"])\n    @checks.mod_or_permissions(administrator=True)\n    async def masswarn_4(self, ctx, *selection: str):\n        \"\"\"\n        Perform a mass softban.\n        \"\"\"\n        if not selection:\n            await ctx.send_help()\n            return\n        try:\n            selection = await AdvancedMemberSelect().convert(ctx, selection)\n        except commands.BadArgument as e:\n            await ctx.send(e)\n            return\n        await self.call_masswarn(\n            ctx,\n            4,\n            selection.members,\n            selection.unavailable_members,\n            selection.send_modlog,\n            selection.send_dm,\n            selection.take_action,\n            selection.reason,\n            None,\n            selection.confirm,\n        )\n\n    @masswarn.command(name=\"5\", aliases=[\"ban\"])\n    @checks.mod_or_permissions(administrator=True)\n    async def masswarn_5(self, ctx, *selection: str):\n        \"\"\"\n        Perform a mass ban.\n\n        You can provide a duration with the `--time` flag, the format is the same as the simple\\\n        level 5 warning.\n        \"\"\"\n        if not selection:\n            await ctx.send_help()\n            return\n        try:\n            selection = await AdvancedMemberSelect().convert(ctx, selection)\n        except commands.BadArgument as e:\n            await ctx.send(e)\n            return\n        await self.call_masswarn(\n            ctx,\n            5,\n            selection.members,\n            selection.unavailable_members,\n            selection.send_modlog,\n            selection.send_dm,\n            selection.take_action,\n            selection.reason,\n            selection.time,\n            selection.confirm,\n        )\n\n    @commands.command()\n    @commands.guild_only()\n    @commands.bot_has_permissions(add_reactions=True, manage_messages=True)\n    @commands.cooldown(1, 3, commands.BucketType.member)\n    async def warnings(\n        self, ctx: commands.Context, user: UnavailableMember = None, index: int = 0\n    ):\n        \"\"\"\n        Shows all warnings of a member.\n\n        This command can be used by everyone, but only moderators can see other's warnings.\n        Moderators can also edit or delete warnings by using the reactions.\n        \"\"\"\n        if not user:\n            await ctx.send_help()\n            return\n        if (\n            not (\n                await mod.is_mod_or_superior(self.bot, ctx.author)\n                or ctx.author.guild_permissions.kick_members\n            )\n            and user != ctx.author\n        ):\n            await ctx.send(_(\"You are not allowed to see other's warnings!\"))\n            return\n        cases = await self.api.get_all_cases(ctx.guild, user)\n        if not cases:\n            await ctx.send(_(\"That member was never warned.\"))\n            return\n        if 0 < index < len(cases):\n            await ctx.send(_(\"That case doesn't exist.\"))\n            return\n\n        total = lambda level: len([x for x in cases if x[\"level\"] == level])\n        warning_str = lambda level, plural: {\n            1: (_(\"Warning\"), _(\"Warnings\")),\n            2: (_(\"Mute\"), _(\"Mutes\")),\n            3: (_(\"Kick\"), _(\"Kicks\")),\n            4: (_(\"Softban\"), _(\"Softbans\")),\n            5: (_(\"Ban\"), _(\"Bans\")),\n        }.get(level, _(\"unknown\"))[1 if plural else 0]\n\n        embeds = []\n        msg = []\n        for i in range(6):\n            total_warns = total(i)\n            if total_warns > 0:\n                msg.append(f\"{warning_str(i, total_warns > 1)}: {total_warns}\")\n        warn_field = \"\\n\".join(msg) if len(msg) > 1 else msg[0]\n        warn_list = []\n        for case in cases[:-10:-1]:\n            level = case[\"level\"]\n            reason = str(case[\"reason\"]).splitlines()\n            if len(reason) > 1:\n                reason = reason[0] + \"...\"\n            else:\n                reason = reason[0]\n            date = pretty_date(self.api._get_datetime(case[\"time\"]))\n            text = f\"**{warning_str(level, False)}:** {reason} \u2022 *{date}*\\n\"\n            if len(\"\".join(warn_list + [text])) > 1024:  # embed limits\n                break\n            else:\n                warn_list.append(text)\n        embed = discord.Embed(description=_(\"User modlog summary.\"))\n        embed.set_author(name=f\"{user} | {user.id}\", icon_url=user.avatar_url)\n        embed.add_field(\n            name=_(\"Total number of warnings: \") + str(len(cases)), value=warn_field, inline=False\n        )\n        embed.add_field(\n            name=_(\"{len} last warnings\").format(len=len(warn_list))\n            if len(warn_list) > 1\n            else _(\"Last warning\"),\n            value=\"\".join(warn_list),\n            inline=False,\n        )\n        embed.set_footer(text=_(\"Click on the reactions to scroll through the warnings\"))\n        embed.colour = user.top_role.colour\n        embeds.append(embed)\n\n        for i, case in enumerate(cases):\n            level = case[\"level\"]\n            moderator = ctx.guild.get_member(case[\"author\"])\n            moderator = \"ID: \" + str(case[\"author\"]) if not moderator else moderator.mention\n\n            time = self.api._get_datetime(case[\"time\"])\n            embed = discord.Embed(\n                description=_(\"Case #{number} informations\").format(number=i + 1)\n            )\n            embed.set_author(name=f\"{user} | {user.id}\", icon_url=user.avatar_url)\n            embed.add_field(\n                name=_(\"Level\"), value=f\"{warning_str(level, False)} ({level})\", inline=True\n            )\n            embed.add_field(name=_(\"Moderator\"), value=moderator, inline=True)\n            if case[\"duration\"]:\n                duration = self.api._get_timedelta(case[\"duration\"])\n                embed.add_field(\n                    name=_(\"Duration\"),\n                    value=_(\"{duration}\\n(Until {date})\").format(\n                        duration=self.api._format_timedelta(duration),\n                        date=self.api._format_datetime(time + duration),\n                    ),\n                )\n            embed.add_field(name=_(\"Reason\"), value=case[\"reason\"], inline=False),\n            embed.timestamp = time\n            embed.colour = await self.data.guild(ctx.guild).colors.get_raw(level)\n            embeds.append(embed)\n\n        controls = {\"\u2b05\": menus.prev_page, \"\u274c\": menus.close_menu, \"\u27a1\": menus.next_page}\n        if await mod.is_mod_or_superior(self.bot, ctx.author):\n            controls.update({\"\u270f\": self._edit_case, \"\ud83d\uddd1\": self._delete_case})\n\n        await menus.menu(\n            ctx=ctx, pages=embeds, controls=controls, message=None, page=index, timeout=60\n        )\n\n    async def _edit_case(\n        self,\n        ctx: commands.Context,\n        pages: list,\n        controls: dict,\n        message: discord.Message,\n        page: int,\n        timeout: float,\n        emoji: str,\n    ):\n        \"\"\"\n        Edit a case, this is linked to the warnings menu system.\n        \"\"\"\n\n        async def edit_message(channel_id: int, message_id: int, new_reason: str):\n            channel: discord.TextChannel = guild.get_channel(channel_id)\n            if channel is None:\n                log.warn(\n                    f\"[Guild {guild.id}] Failed to edit modlog message. \"\n                    f\"Channel {channel_id} not found.\"\n                )\n                return False\n            try:\n                message: discord.Message = await channel.fetch_message(message_id)\n            except discord.errors.NotFound:\n                log.warn(\n                    f\"[Guild {guild.id}] Failed to edit modlog message. \"\n                    f\"Message {message_id} in channel {channel.id} not found.\"\n                )\n                return False\n            except discord.errors.Forbidden:\n                log.warn(\n                    f\"[Guild {guild.id}] Failed to edit modlog message. \"\n                    f\"No permissions to fetch messages in channel {channel.id}.\"\n                )\n                return False\n            except discord.errors.HTTPException as e:\n                log.error(\n                    f\"[Guild {guild.id}] Failed to edit modlog message. API exception raised.\",\n                    exc_info=e,\n                )\n                return False\n            try:\n                embed: discord.Embed = message.embeds[0]\n                embed.set_field_at(\n                    len(embed.fields) - 2, name=_(\"Reason\"), value=new_reason, inline=False\n                )\n            except IndexError as e:\n                log.error(\n                    f\"[Guild {guild.id}] Failed to edit modlog message. Embed is malformed.\",\n                    exc_info=e,\n                )\n                return False\n            try:\n                await message.edit(embed=embed)\n            except discord.errors.HTTPException as e:\n                log.error(\n                    f\"[Guild {guild.id}] Failed to edit modlog message. \"\n                    \"Unknown error when attempting message edition.\",\n                    exc_info=e,\n                )\n                return False\n            return True\n\n        guild = ctx.guild\n        if page == 0:\n            # first page, no case to edit\n            await message.remove_reaction(emoji, ctx.author)\n            return await menus.menu(\n                ctx, pages, controls, message=message, page=page, timeout=timeout\n            )\n        await message.clear_reactions()\n        try:\n            old_embed = message.embeds[0]\n        except IndexError:\n            return\n        embed = discord.Embed()\n        member_id = int(\n            re.match(r\"(?:.*#[0-9]{4})(?: \\| )([0-9]{15,21})\", old_embed.author.name).group(1)\n        )\n        member = self.bot.get_user(member_id) or UnavailableMember(\n            self.bot, guild._state, member_id\n        )\n        embed.clear_fields()\n        embed.description = _(\n            \"Case #{number} edition.\\n\\n**Please type the new reason to set**\"\n        ).format(number=page)\n        embed.set_footer(text=_(\"You have two minutes to type your text in the chat.\"))\n        case = (await self.data.custom(\"MODLOGS\", guild.id, member.id).x())[page - 1]\n        await message.edit(embed=embed)\n        try:\n            response = await self.bot.wait_for(\n                \"message\", check=predicates.MessagePredicate.same_context(ctx), timeout=120\n            )\n        except AsyncTimeoutError:\n            await message.delete()\n            return\n        case = (await self.data.custom(\"MODLOGS\", guild.id, member.id).x())[page - 1]\n        new_reason = await self.api.format_reason(guild, response.content)\n        embed.description = _(\"Case #{number} edition.\").format(number=page)\n        embed.add_field(name=_(\"Old reason\"), value=case[\"reason\"], inline=False)\n        embed.add_field(name=_(\"New reason\"), value=new_reason, inline=False)\n        embed.set_footer(text=_(\"Click on \u2705 to confirm the changes.\"))\n        await message.edit(embed=embed)\n        menus.start_adding_reactions(message, predicates.ReactionPredicate.YES_OR_NO_EMOJIS)\n        pred = predicates.ReactionPredicate.yes_or_no(message, ctx.author)\n        try:\n            await ctx.bot.wait_for(\"reaction_add\", check=pred, timeout=30)\n        except AsyncTimeoutError:\n            await message.clear_reactions()\n            await message.edit(content=_(\"Question timed out.\"), embed=None)\n            return\n        if pred.result:\n            async with self.data.custom(\"MODLOGS\", guild.id, member.id).x() as logs:\n                logs[page - 1][\"reason\"] = new_reason\n                try:\n                    channel_id, message_id = logs[page - 1][\"modlog_message\"].values()\n                except KeyError:\n                    result = None\n                else:\n                    result = await edit_message(channel_id, message_id, new_reason)\n            await message.clear_reactions()\n            text = _(\"The reason was successfully edited!\\n\")\n            if result is False:\n                text += _(\"*The modlog message couldn't be edited. Check your logs for details.*\")\n            await message.edit(content=text, embed=None)\n        else:\n            await message.clear_reactions()\n            await message.edit(content=_(\"The reason was not edited.\"), embed=None)\n\n    async def _delete_case(\n        self,\n        ctx: commands.Context,\n        pages: list,\n        controls: dict,\n        message: discord.Message,\n        page: int,\n        timeout: float,\n        emoji: str,\n    ):\n        \"\"\"\n        Remove a case, this is linked to the warning system.\n        \"\"\"\n\n        async def delete_message(channel_id: int, message_id: int):\n            channel: discord.TextChannel = guild.get_channel(channel_id)\n            if channel is None:\n                log.warn(\n                    f\"[Guild {guild.id}] Failed to delete modlog message. \"\n                    f\"Channel {channel_id} not found.\"\n                )\n                return False\n            try:\n                message: discord.Message = await channel.fetch_message(message_id)\n            except discord.errors.NotFound:\n                log.warn(\n                    f\"[Guild {guild.id}] Failed to delete modlog message. \"\n                    f\"Message {message_id} in channel {channel.id} not found.\"\n                )\n                return False\n            except discord.errors.Forbidden:\n                log.warn(\n                    f\"[Guild {guild.id}] Failed to delete modlog message. \"\n                    f\"No permissions to fetch messages in channel {channel.id}.\"\n                )\n                return False\n            except discord.errors.HTTPException as e:\n                log.error(\n                    f\"[Guild {guild.id}] Failed to delete modlog message. API exception raised.\",\n                    exc_info=e,\n                )\n                return False\n            try:\n                await message.delete()\n            except discord.errors.HTTPException as e:\n                log.error(\n                    f\"[Guild {guild.id}] Failed to delete modlog message. \"\n                    \"Unknown error when attempting message deletion.\",\n                    exc_info=e,\n                )\n                return False\n            return True\n\n        guild = ctx.guild\n        await message.clear_reactions()\n        try:\n            old_embed = message.embeds[0]\n        except IndexError:\n            return\n        embed = discord.Embed()\n        member_id = int(\n            re.match(r\"(?:.*#[0-9]{4})(?: \\| )([0-9]{15,21})\", old_embed.author.name).group(1)\n        )\n        member = self.bot.get_user(member_id) or UnavailableMember(\n            self.bot, guild._state, member_id\n        )\n        if page == 0:\n            # no warning specified, mod wants to completly clear the member\n            embed.colour = 0xEE2B2B\n            embed.description = _(\n                \"Member {member}'s clearance. By selecting \u274c on the user modlog summary, you can \"\n                \"remove all warnings given to {member}. __All levels and notes are affected.__\\n\"\n                \"**Click on the reaction to confirm the removal of the entire user's modlog. \"\n                \"This cannot be undone.**\"\n            ).format(member=str(member))\n        else:\n            level = int(re.match(r\".*\\(([0-9]*)\\)\", old_embed.fields[0].value).group(1))\n            can_unmute = False\n            add_roles = False\n            if level == 2:\n                mute_role = guild.get_role(await self.cache.get_mute_role(guild))\n                member = guild.get_member(member.id)\n                if member:\n                    if mute_role and mute_role in member.roles:\n                        can_unmute = True\n                    add_roles = await self.data.guild(guild).remove_roles()\n            description = _(\n                \"Case #{number} deletion.\\n**Click on the reaction to confirm your action.**\"\n            ).format(number=page)\n            if can_unmute or add_roles:\n                description += _(\"\\nNote: Deleting the case will also do the following:\")\n                if can_unmute:\n                    description += _(\"\\n- unmute the member\")\n                if add_roles:\n                    description += _(\"\\n- add all roles back to the member\")\n            embed.description = description\n        await message.edit(embed=embed)\n        menus.start_adding_reactions(message, predicates.ReactionPredicate.YES_OR_NO_EMOJIS)\n        pred = predicates.ReactionPredicate.yes_or_no(message, ctx.author)\n        try:\n            await ctx.bot.wait_for(\"reaction_add\", check=pred, timeout=30)\n        except AsyncTimeoutError:\n            await message.clear_reactions()\n            await message.edit(content=_(\"Question timed out.\"), embed=None)\n            return\n        if not pred.result:\n            await message.clear_reactions()\n            await message.edit(content=_(\"Nothing was removed.\"), embed=None)\n            return\n        if page == 0:\n            # removing entire modlog\n            await self.data.custom(\"MODLOGS\", guild.id, member.id).x.set([])\n            log.debug(f\"[Guild {guild.id}] Cleared modlog of member {member} (ID: {member.id}).\")\n            await message.clear_reactions()\n            await message.edit(content=_(\"User modlog cleared.\"), embed=None)\n            return\n        async with self.data.custom(\"MODLOGS\", guild.id, member.id).x() as logs:\n            try:\n                roles = logs[page - 1][\"roles\"]\n            except KeyError:\n                roles = []\n            try:\n                channel_id, message_id = logs[page - 1][\"modlog_message\"].values()\n            except KeyError:\n                result = None\n            else:\n                result = await delete_message(channel_id, message_id)\n            logs.remove(logs[page - 1])\n        log.debug(\n            f\"[Guild {guild.id}] Removed case #{page} from member {member} (ID: {member.id}).\"\n        )\n        await message.clear_reactions()\n        if can_unmute:\n            await member.remove_roles(\n                mute_role,\n                reason=_(\"Warning deleted by {author}\").format(\n                    author=f\"{str(ctx.author)} (ID: {ctx.author.id})\"\n                ),\n            )\n        if roles:\n            roles = [guild.get_role(x) for x in roles]\n            await member.add_roles(*roles, reason=_(\"Adding removed roles back after unmute.\"))\n        text = _(\"The case was successfully deleted!\")\n        if result is False:\n            text += _(\"*The modlog message couldn't be deleted. Check your logs for details.*\")\n        await message.edit(content=_(\"The case was successfully deleted!\"), embed=None)\n\n    @commands.command()\n    @checks.mod_or_permissions(kick_members=True)\n    @commands.cooldown(1, 10, commands.BucketType.channel)\n    async def warnlist(self, ctx: commands.Context, short: bool = False):\n        \"\"\"\n        List the latest warnings issued on the server.\n        \"\"\"\n        guild = ctx.guild\n        full_text = \"\"\n        warns = await self.api.get_all_cases(guild)\n        if not warns:\n            await ctx.send(_(\"No warnings have been issued in this server yet.\"))\n            return\n        for i, warn in enumerate(warns, start=1):\n            text = _(\n                \"--- Case {number} ---\\n\"\n                \"Member:    {member} (ID: {member.id})\\n\"\n                \"Level:     {level}\\n\"\n                \"Reason:    {reason}\\n\"\n                \"Author:    {author} (ID: {author.id})\\n\"\n                \"Date:      {time}\\n\"\n            ).format(number=i, **warn)\n            if warn[\"duration\"]:\n                duration = self.api._get_timedelta(warn[\"duration\"])\n                text += _(\"Duration:  {duration}\\nUntil:     {until}\\n\").format(\n                    duration=self.api._format_timedelta(duration),\n                    until=self.api._format_datetime(warn[\"time\"] + duration),\n                )\n            text += \"\\n\\n\"\n            full_text = text + full_text\n        pages = [\n            x for x in pagify(full_text, delims=[\"\\n\\n\", \"\\n\"], priority=True, page_length=1900)\n        ]\n        total_pages = len(pages)\n        total_warns = len(warns)\n        pages = [\n            f\"```yml\\n{x}```\\n\"\n            + _(\"{total} warnings. Page {i}/{pages}\").format(\n                total=total_warns, i=i, pages=total_pages\n            )\n            for i, x in enumerate(pages, start=1)\n        ]\n        await menus.menu(ctx=ctx, pages=pages, controls=menus.DEFAULT_CONTROLS, timeout=60)\n\n    @commands.command()\n    @checks.mod_or_permissions(manage_roles=True)\n    async def wsunmute(self, ctx: commands.Context, member: discord.Member):\n        \"\"\"\n        Unmute a member muted with WarnSystem.\n\n        If the member's roles were removed, they will be granted back.\n\n        *wsunmute = WarnSystem unmute. Feel free to add an alias.*\n        \"\"\"\n        guild = ctx.guild\n        mute_role = guild.get_role(await self.cache.get_mute_role(guild))\n        if not mute_role:\n            await ctx.send(_(\"The mute role is not set or lost.\"))\n            return\n        if mute_role not in member.roles:\n            await ctx.send(_(\"That member isn't muted.\"))\n            return\n        case = await self.cache.get_temp_action(guild, member)\n        if case and case[\"level\"] == 2:\n            roles = case[\"roles\"]\n            await self.cache.remove_temp_action(guild, member)\n        else:\n            cases = await self.api.get_all_cases(guild, member)\n            roles = []\n            for data in cases[::-1]:\n                if data[\"level\"] == 2:\n                    try:\n                        roles = data[\"roles\"]\n                    except KeyError:\n                        continue\n                    break\n        await member.remove_roles(\n            mute_role,\n            reason=_(\"[WarnSystem] Member unmuted by {author} (ID: {author.id})\").format(\n                author=ctx.author\n            ),\n        )\n        roles = list(filter(None, [guild.get_role(x) for x in roles]))\n        if not roles:\n            await ctx.send(_(\"Member unmuted.\"))\n            return\n        await ctx.send(\n            _(\"Member unmuted. {len_roles} roles to reassign...\").format(len_roles=len(roles))\n        )\n        async with ctx.typing():\n            fails = []\n            for role in roles:\n                try:\n                    await member.add_roles(role)\n                except discord.errors.HTTPException as e:\n                    log.error(\n                        f\"Failed to reapply role {role} ({role.id}) on guild {guild} \"\n                        f\"({guild.id}) after unmute.\",\n                        exc_info=e,\n                    )\n                    fails.append(role)\n        text = _(\"Done.\")\n        if fails:\n            text.append(_(\"\\n\\nFailed to add {fails}/{len_roles} roles back:\\n\"))\n            for role in fails:\n                text.append(f\"- {role.name}\\n\")\n        for page in pagify(text):\n            await ctx.send(page)\n\n    @commands.command()\n    @checks.mod_or_permissions(ban_members=True)\n    async def wsunban(self, ctx: commands.Context, member: UnavailableMember):\n        \"\"\"\n        Unban a member banned with WarnSystem.\n\n        *wsunban = WarnSystem unban. Feel free to add an alias.*\n        \"\"\"\n        guild = ctx.guild\n        bans = await guild.bans()\n        if member.id not in [x.user.id for x in bans]:\n            await ctx.send(_(\"That user is not banned.\"))\n            return\n        try:\n            await guild.unban(member)\n        except discord.errors.HTTPException as e:\n            await ctx.send(_(\"Failed to unban the given member. Check your logs for details.\"))\n            log.error(f\"Can't unban user {member.id} from guild {guild} ({guild.id})\", exc_info=e)\n            return\n        case = await self.cache.get_temp_action(guild, member)\n        if case and case[\"level\"] == 5:\n            await self.cache.remove_temp_action(guild, member)\n        await ctx.send(_(\"User unbanned.\"))\n\n    @commands.command(hidden=True)\n    async def warnsysteminfo(self, ctx):\n        \"\"\"\n        Get informations about the cog.\n        \"\"\"\n        await ctx.send(\n            _(\n                \"Laggron's Dumb Cogs V3 - warnsystem\\n\\n\"\n                \"Version: {0.__version__}\\n\"\n                \"Author: {0.__author__[0]}\\n\\n\"\n                \"Github repository: https://github.com/retke/Laggrons-Dumb-Cogs/tree/v3\\n\"\n                \"Discord server: https://discord.gg/AVzjfpR\\n\"\n                \"Documentation: http://laggrons-dumb-cogs.readthedocs.io/\\n\"\n                \"Help translating the cog: https://crowdin.com/project/laggrons-dumb-cogs/\\n\\n\"\n                \"Support my work on Patreon: https://www.patreon.com/retke\"\n            ).format(self)\n        )\n\n    @listener()\n    async def on_member_unban(self, guild: discord.Guild, user: discord.User):\n        # if a member gets unbanned, we check if he was temp banned with warnsystem\n        # if it was, we remove the case so it won't unban him a second time\n        warns = await self.cache.get_temp_action(guild)\n        to_remove = []  # there can be multiple temp bans, let's not question the moderators\n        for member, data in warns.items():\n            if data[\"level\"] == 2 or int(member) != user.id:\n                continue\n            to_remove.append(UnavailableMember(self.bot, guild._state, member))\n        if to_remove:\n            await self.cache.bulk_remove_temp_action(guild, to_remove)\n            log.info(\n                f\"[Guild {guild.id}] The temporary ban of user {user} (ID: {user.id}) \"\n                \"was cancelled due to his manual unban.\"\n            )\n\n    @listener()\n    async def on_member_update(self, before: discord.Member, after: discord.Member):\n        guild = after.guild\n        mute_role = guild.get_role(await self.cache.get_mute_role(guild))\n        if not mute_role:\n            return\n        if not (mute_role in before.roles and mute_role not in after.roles):\n            return\n        if after.id in self.cache.temp_actions:\n            await self.cache.remove_temp_action(guild, after)\n            log.info(\n                f\"[Guild {guild.id}] The temporary mute of member {after} (ID: {after.id}) \"\n                \"was ended due to a manual unmute (role removed).\"\n            )\n\n    @listener()\n    async def on_guild_channel_create(self, channel: discord.abc.GuildChannel):\n        guild = channel.guild\n        if isinstance(channel, discord.VoiceChannel):\n            return\n        if not await self.data.guild(guild).update_mute():\n            return\n        role = guild.get_role(await self.cache.get_mute_role(guild))\n        if not role:\n            return\n        try:\n            await channel.set_permissions(\n                role,\n                send_messages=False,\n                add_reactions=False,\n                reason=_(\n                    \"Updating channel settings so the mute role will work here. \"\n                    \"Disable the auto-update with [p]warnset autoupdate\"\n                ),\n            )\n        except discord.errors.Forbidden:\n            log.warn(\n                f\"[Guild {guild.id}] Couldn't update permissions of new channel {channel.name} \"\n                f\"(ID: {channel.id}) due to a permission error.\"\n            )\n        except discord.errors.HTTPException as e:\n            log.error(\n                f\"[Guild {guild.id}] Couldn't update permissions of new channel {channel.name} \"\n                f\"(ID: {channel.id}) due to an unknown error.\",\n                exc_info=e,\n            )\n\n    @listener()\n    async def on_member_ban(self, guild: discord.Guild, member: discord.Member):\n        # most of this code is from Cog-Creators, modlog cog\n        # https://github.com/Cog-Creators/Red-DiscordBot/blob/bc21f779762ec9f460aecae525fdcd634f6c2d85/redbot/core/modlog.py#L68\n        if not guild.me.guild_permissions.view_audit_log:\n            return\n        if not await self.data.guild(guild).log_manual():\n            return\n        # check for that before doing anything else, means WarnSystem isn't setup\n        try:\n            await self.api.get_modlog_channel(guild, 5)\n        except errors.NotFound:\n            return\n        when = datetime.utcnow()\n        before = when + timedelta(minutes=1)\n        after = when - timedelta(minutes=1)\n        await asyncio.sleep(10)  # prevent small delays from causing a 5 minute delay on entry\n        attempts = 0\n        # wait up to an hour to find a matching case\n        while attempts < 12:\n            attempts += 1\n            try:\n                entry = await guild.audit_logs(\n                    action=discord.AuditLogAction.ban, before=before, after=after\n                ).find(lambda e: e.target.id == member.id and after < e.created_at < before)\n            except discord.Forbidden:\n                break\n            except discord.HTTPException:\n                pass\n            else:\n                if entry:\n                    if entry.user.id != guild.me.id:\n                        # Don't create modlog entires for the bot's own bans, cogs do this.\n                        mod, reason, date = entry.user, entry.reason, entry.created_at\n                        try:\n                            await self.api.warn(\n                                guild,\n                                [member],\n                                mod,\n                                5,\n                                reason,\n                                date=date,\n                                log_dm=False,\n                                take_action=False,\n                            )\n                        except Exception as e:\n                            log.error(\n                                f\"[Guild {guild.id}] Failed to create a case based on manual ban. \"\n                                f\"Member: {member} ({member.id}). Author: {mod} ({mod.id}). \"\n                                f\"Reason: {reason}\",\n                                exc_info=e,\n                            )\n                    return\n            await asyncio.sleep(300)\n\n    @listener()\n    async def on_command_error(self, ctx, error):\n        if not isinstance(error, commands.CommandInvokeError):\n            return\n        if not ctx.command.cog_name == self.__class__.__name__:\n            # That error doesn't belong to the cog\n            return\n        if isinstance(error, commands.MissingPermissions):\n            await ctx.send(\n                _(\n                    \"I need the `Add reactions` and `Manage messages` in the \"\n                    \"current channel if you want to use this command.\"\n                )\n            )\n            return\n        with DisabledConsoleOutput(log):\n            log.error(\n                f\"Exception in command '{ctx.command.qualified_name}'.\\n\\n\",\n                exc_info=error.original,\n            )\n\n    # correctly unload the cog\n    def __unload(self):\n        self.cog_unload()\n\n    def cog_unload(self):\n        log.debug(\"Unloading cog...\")\n\n        # remove all handlers from the logger, this prevents adding\n        # multiple times the same handler if the cog gets reloaded\n        close_logger(log)\n\n        # stop checking for unmute and unban\n        self.task.cancel()\n        self.api.disable_automod()\n"], "fixing_code": ["import asyncio\nimport discord\nimport logging\nimport re\nimport functools\n\nfrom copy import deepcopy\nfrom collections import namedtuple\nfrom typing import Union, Optional, Iterable, Callable, Awaitable\nfrom datetime import datetime, timedelta\nfrom multiprocessing import TimeoutError\nfrom multiprocessing.pool import Pool\n\nfrom redbot.core import Config\nfrom redbot.core.bot import Red\nfrom redbot.core.i18n import Translator\nfrom redbot.core.commands import BadArgument, MemberConverter\n\ntry:\n    from redbot.core.modlog import get_modlog_channel as get_red_modlog_channel\nexcept RuntimeError:\n    pass  # running sphinx-build raises an error when importing this module\n\nfrom .cache import MemoryCache\nfrom . import errors\n\nlog = logging.getLogger(\"red.laggron.warnsystem\")\n_ = Translator(\"WarnSystem\", __file__)\nid_pattern = re.compile(r\"([0-9]{15,21})$\")\n\n\nclass SafeMember:\n    def __init__(self, member: discord.Member) -> None:\n        self.name = str(member.name)\n        self.display_name = str(member.display_name)\n        self.nick = str(member.nick)\n        self.id = str(member.id)\n        self.mention = str(member.mention)\n        self.discriminator = str(member.discriminator)\n        self.color = str(member.color)\n        self.colour = str(member.colour)\n        self.created_at = str(member.created_at)\n        self.joined_at = str(member.joined_at)\n\n    def __str__(self):\n        return self.name\n\n    def __getattr__(self, name):\n        return self\n\n\nclass FakeRole:\n    \"\"\"\n    We need to fake some attributes of roles for the class UnavailableMember\n    \"\"\"\n\n    position = 0\n    colour = discord.Embed.Empty\n\n\nclass UnavailableMember(discord.abc.User, discord.abc.Messageable):\n    \"\"\"\n    A class that reproduces the behaviour of a discord.Member instance, except\n    the member is not in the guild. This is used to prevent calling bot.fetch_info\n    which has a very high cooldown.\n    \"\"\"\n\n    def __init__(self, bot, state, user_id: int):\n        self.bot = bot\n        self._state = state\n        self.id = user_id\n        self.top_role = FakeRole()\n\n    @classmethod\n    def _check_id(cls, member_id):\n        if not id_pattern.match(member_id):\n            raise ValueError(f\"You provided an invalid ID: {member_id}\")\n        return int(member_id)\n\n    @classmethod\n    async def convert(cls, ctx, text):\n        try:\n            member = await MemberConverter().convert(ctx, text)\n        except BadArgument:\n            pass\n        else:\n            return member\n        try:\n            member_id = cls._check_id(text)\n        except ValueError:\n            raise BadArgument(\n                _(\n                    \"The given member cannot be found.\\n\"\n                    \"If you're trying to hackban, the user ID is not valid.\"\n                )\n            )\n        return cls(ctx.bot, ctx._state, member_id)\n\n    @property\n    def name(self):\n        return \"Unknown\"\n\n    @property\n    def display_name(self):\n        return \"Unknown\"\n\n    @property\n    def mention(self):\n        return f\"<@{self.id}>\"\n\n    @property\n    def avatar_url(self):\n        return \"\"\n\n    def __str__(self):\n        return \"Unknown#0000\"\n\n    # the 3 following functions were copied from the discord.User class, credit to Rapptz\n    # https://github.com/Rapptz/discord.py/blob/master/discord/user.py#L668\n\n    @property\n    def dm_channel(self):\n        \"\"\"Optional[:class:`DMChannel`]: Returns the channel associated with this user if it exists.\n        If this returns ``None``, you can create a DM channel by calling the\n        :meth:`create_dm` coroutine function.\n        \"\"\"\n        return self._state._get_private_channel_by_user(self.id)\n\n    async def create_dm(self):\n        \"\"\"Creates a :class:`DMChannel` with this user.\n        This should be rarely called, as this is done transparently for most\n        people.\n        \"\"\"\n        found = self.dm_channel\n        if found is not None:\n            return found\n\n        state = self._state\n        data = await state.http.start_private_message(self.id)\n        return state.add_dm_channel(data)\n\n    async def _get_channel(self):\n        channel = await self.create_dm()\n        return channel\n\n\nclass API:\n    \"\"\"\n    Interact with WarnSystem from your cog.\n\n    To import the cog and use the functions, type this in your code:\n\n    .. code-block:: python\n\n        warnsystem = bot.get_cog('WarnSystem').api\n\n    .. warning:: If ``warnsystem`` is :py:obj:`None`, the cog is\n      not loaded/installed. You won't be able to interact with\n      the API at this point.\n\n    .. tip:: You can get the cog version by doing this\n\n        .. code-block:: python\n\n            version = bot.get_cog('WarnSystem').__version__\n    \"\"\"\n\n    def __init__(self, bot: Red, config: Config, cache: MemoryCache):\n        self.bot = bot\n        self.data = config\n        self.cache = cache\n        self.re_pool = Pool(maxtasksperchild=1000)\n        self.regex_timeout = 1\n        self.warned_guilds = []  # see automod_check_for_autowarn\n        self.antispam = {}  # see automod_process_antispam\n        self.antispam_warn_queue = {}  # see automod_warn\n        self.automod_warn_task: asyncio.Task\n\n    def _get_datetime(self, time: int) -> datetime:\n        return datetime.fromtimestamp(int(time))\n\n    def _get_timedelta(self, time: int) -> timedelta:\n        return timedelta(seconds=int(time))\n\n    def _format_datetime(self, time: datetime):\n        return time.strftime(\"%a %d %B %Y %H:%M:%S\")\n\n    def _format_timedelta(self, time: timedelta):\n        \"\"\"Format a timedelta object into a string\"\"\"\n        # blame python for not creating a strftime attribute\n        plural = lambda name, amount: name[1] if amount > 1 else name[0]\n        strings = []\n\n        seconds = time.total_seconds()\n        years, seconds = divmod(seconds, 31622400)\n        months, seconds = divmod(seconds, 2635200)\n        weeks, seconds = divmod(seconds, 604800)\n        days, seconds = divmod(seconds, 86400)\n        hours, seconds = divmod(seconds, 3600)\n        minutes, seconds = divmod(seconds, 60)\n        units = [years, months, weeks, days, hours, minutes, seconds]\n\n        # tuples inspired from mikeshardmind\n        # https://github.com/mikeshardmind/SinbadCogs/blob/v3/scheduler/time_utils.py#L29\n        units_name = {\n            0: (_(\"year\"), _(\"years\")),\n            1: (_(\"month\"), _(\"months\")),\n            2: (_(\"week\"), _(\"weeks\")),\n            3: (_(\"day\"), _(\"days\")),\n            4: (_(\"hour\"), _(\"hours\")),\n            5: (_(\"minute\"), _(\"minutes\")),\n            6: (_(\"second\"), _(\"seconds\")),\n        }\n        for i, value in enumerate(units):\n            if value < 1:\n                continue\n            unit_name = plural(units_name.get(i), value)\n            strings.append(f\"{round(value)} {unit_name}\")\n        string = \", \".join(strings[:-1])\n        if len(strings) > 1:\n            string += _(\" and \") + strings[-1]\n        else:\n            string = strings[0]\n        return string\n\n    async def _start_timer(self, guild: discord.Guild, member: discord.Member, case: dict) -> bool:\n        \"\"\"Start the timer for a temporary mute/ban.\"\"\"\n        if not case[\"duration\"]:\n            raise errors.BadArgument(\"No duration for this warning!\")\n        await self.cache.add_temp_action(guild, member, case)\n        return True\n\n    async def _mute(self, member: discord.Member, reason: Optional[str] = None):\n        \"\"\"Mute an user on the guild.\"\"\"\n        old_roles = []\n        guild = member.guild\n        mute_role = guild.get_role(await self.cache.get_mute_role(guild))\n        remove_roles = await self.data.guild(guild).remove_roles()\n        if not mute_role:\n            raise errors.MissingMuteRole(\"You need to create the mute role before doing this.\")\n        if remove_roles:\n            old_roles = member.roles.copy()\n            old_roles.remove(guild.default_role)\n            old_roles = [\n                x for x in old_roles if x.position < guild.me.top_role.position and not x.managed\n            ]\n            fails = []\n            for role in old_roles:\n                try:\n                    await member.remove_roles(role, reason=reason)\n                except discord.errors.HTTPException:\n                    fails.append(role)\n            if fails:\n                log.warn(\n                    f\"[Guild {guild.id}] Failed to remove roles from {member} (ID: {member.id}) \"\n                    f\"while muting. Roles: {', '.join([f'{x.name} ({x.id})' for x in fails])}\",\n                )\n        await member.add_roles(mute_role, reason=reason)\n        return old_roles\n\n    async def _unmute(self, member: discord.Member, reason: str, old_roles: list = None):\n        \"\"\"Unmute an user on the guild.\"\"\"\n        guild = member.guild\n        mute_role = guild.get_role(await self.cache.get_mute_role(guild))\n        if not mute_role:\n            raise errors.MissingMuteRole(\n                f\"Lost the mute role on guild {guild.name} (ID: {guild.id}\"\n            )\n        await member.remove_roles(mute_role, reason=reason)\n        await member.add_roles(*old_roles, reason=reason)\n\n    async def _create_case(\n        self,\n        guild: discord.Guild,\n        user: discord.User,\n        author: Union[discord.Member, str],\n        level: int,\n        time: datetime,\n        reason: Optional[str] = None,\n        duration: Optional[timedelta] = None,\n        roles: Optional[list] = None,\n        modlog_message: Optional[discord.Message] = None,\n    ) -> dict:\n        \"\"\"Create a new case for a member. Don't call this, call warn instead.\"\"\"\n        data = {\n            \"level\": level,\n            \"author\": author\n            if not isinstance(author, (discord.User, discord.Member))\n            else author.id,\n            \"reason\": reason,\n            \"time\": int(time.timestamp()),  # seconds since epoch\n            \"duration\": None if not duration else duration.total_seconds(),\n            \"roles\": [] if not roles else [x.id for x in roles],\n        }\n        if modlog_message:\n            data[\"modlog_message\"] = {\n                \"channel_id\": modlog_message.channel.id,\n                \"message_id\": modlog_message.id,\n            }\n        async with self.data.custom(\"MODLOGS\", guild.id, user.id).x() as logs:\n            logs.append(data)\n        return data\n\n    async def get_case(\n        self, guild: discord.Guild, user: Union[discord.User, discord.Member], index: int\n    ) -> dict:\n        \"\"\"\n        Get a specific case for a user.\n\n        Parameters\n        ----------\n        guild: discord.Guild\n            The guild of the member.\n        user: Union[discord.User, discord.Member]\n            The user you want to get the case from. Can be a :class:`discord.User` if the member is\n            not in the server.\n        index: int\n            The case index you want to get. Must be positive.\n\n        Returns\n        -------\n        dict\n            A :py:class:`dict` which has the following body:\n\n            .. code-block: python3\n\n                {\n                    \"level\"     : int,  # between 1 and 5, the warning level\n                    \"author\"    : Union[discord.Member, str],  # the member that warned the user\n                    \"reason\"    : Optional[str],  # the reason of the warn, can be None\n                    \"time\"      : datetime.datetime,  # the date when the warn was set\n                }\n\n        Raises\n        ------\n        ~warnsystem.errors.NotFound\n            The case requested doesn't exist.\n        \"\"\"\n        try:\n            case = (await self.data.custom(\"MODLOGS\", guild.id, user.id).x())[index - 1]\n        except IndexError:\n            raise errors.NotFound(\"The case requested doesn't exist.\")\n        else:\n            time = case[\"time\"]\n            if time:\n                case[\"time\"] = self._get_datetime(time)\n            return case\n\n    async def get_all_cases(\n        self, guild: discord.Guild, user: Optional[Union[discord.User, discord.Member]] = None\n    ) -> list:\n        \"\"\"\n        Get all cases for a member of a guild.\n\n        Parameters\n        ----------\n        guild: discord.Guild\n            The guild where you want to get the cases from.\n        user: Optional[Union[discord.User, discord.Member]]\n            The user you want to get the cases from. If this arguments is omitted, all cases of\n            the guild are returned.\n\n        Returns\n        -------\n        list\n            A list of all cases of a user/guild. The cases are sorted from the oldest to the\n            newest.\n\n            If you specified a user, you should get something like this:\n\n            .. code-block:: python3\n\n                [\n                    {  # case #1\n                        \"level\"     : int,  # between 1 and 5, the warning level\n                        \"author\"    : Union[discord.Member, str],  # the member that warned the user\n                        \"reason\"    : Optional[str],  # the reason of the warn, can be None\n                        \"time\"      : datetime.datetime,  # the date when the warn was set\n                    },\n                    {\n                        # case #2\n                    },\n                    # ...\n                ]\n\n            However, if you didn't specify a user, you got all cases of the guild. As for the user,\n            you will get a :py:class:`list` of the cases, with another key for specifying the\n            warned user:\n\n            .. code-block:: python3\n\n                {  # case #1\n                    \"level\"     : int,  # between 1 and 5, the warning level\n                    \"author\"    : Union[discord.Member, str],  # the member that warned the user\n                    \"reason\"    : Optional[str],  # the reason of the warn, can be None\n                    \"time\"      : datetime.datetime,  # the date when the warn was set\n\n                    \"member\"    : discord.User,  # the member warned, this key is specific to guild\n                }\n        \"\"\"\n        if user:\n            return await self.data.custom(\"MODLOGS\", guild.id, user.id).x()\n        logs = await self.data.custom(\"MODLOGS\", guild.id).all()\n        all_cases = []\n        for member, content in logs.items():\n            if member == \"x\":\n                continue\n            for log in content[\"x\"]:\n                time = log[\"time\"]\n                if time:\n                    log[\"time\"] = self._get_datetime(time)\n                # gotta get that state somehow\n                log[\"member\"] = self.bot.get_user(int(member)) or UnavailableMember(\n                    self.bot, self.bot.user._state, member\n                )\n                log[\"author\"] = self.bot.get_user(int(log[\"author\"])) or UnavailableMember(\n                    self.bot, self.bot.user._state, log[\"author\"]\n                )\n                all_cases.append(log)\n        return sorted(all_cases, key=lambda x: x[\"time\"])  # sorted from oldest to newest\n\n    async def edit_case(\n        self,\n        guild: discord.Guild,\n        user: Union[discord.User, discord.Member],\n        index: int,\n        new_reason: str,\n    ) -> bool:\n        \"\"\"\n        Edit the reason of a case.\n\n        Parameters\n        ----------\n        guild: discord.Guild\n            The guild where you want to get the case from.\n        user: Union[discord.User, discord.Member]\n            The user you want to get the case from.\n        index: int\n            The number of the case you want to edit.\n        new_reason: str\n            The new reason to set.\n\n        Returns\n        -------\n        bool\n            :py:obj:`True` if the action succeeded.\n\n        Raises\n        ------\n        ~warnsystem.errors.BadArgument\n            The reason is above 1024 characters. Due to Discord embed rules, you have to make it\n            shorter.\n        ~warnsystem.errors.NotFound\n            The case requested doesn't exist.\n        \"\"\"\n        if len(new_reason) > 1024:\n            raise errors.BadArgument(\"The reason must not be above 1024 characters.\")\n        case = await self.get_case(guild, user, index)\n        case[\"reason\"] = new_reason\n        case[\"time\"] = int(case[\"time\"].timestamp())\n        async with self.data.custom(\"MODLOGS\", guild.id, user.id).x() as logs:\n            logs[index - 1] = case\n        return True\n\n    async def get_modlog_channel(\n        self, guild: discord.Guild, level: Optional[Union[int, str]] = None\n    ) -> discord.TextChannel:\n        \"\"\"\n        Get the WarnSystem's modlog channel on the current guild.\n\n        When you call this, the channel is get with the following order:\n\n        #.  Get the modlog channel associated to the type, if provided\n        #.  Get the defult modlog channel set with WarnSystem\n        #.  Get the Red's modlog channel associated to the server\n\n        Parameters\n        ----------\n        guild: discord.Guild\n            The guild you want to get the modlog from.\n        level: Optional[Union[int, str]]\n            Can be an :py:class:`int` between 1 and 5, a :py:class:`str` (``\"all\"``)\n            or :py:obj:`None`.\n\n            *   If the argument is omitted (or :py:obj:`None` is provided), the default modlog\n                channel will be returned.\n\n            *   If an :py:class:`int` is given, the modlog channel associated to this warning\n                level will be returned. If a specific channel was not set for this level, the\n                default modlog channel will be returned instead.\n\n            *   If ``\"all\"`` is returned, a :py:class:`dict` will be returned. It should be built\n                like this:\n\n                .. code-block:: python3\n\n                    {\n                        \"main\"      : 012345678987654321,\n                        \"1\"         : None,\n                        \"2\"         : None,\n                        \"3\"         : None,\n                        \"4\"         : 478065433996537900,\n                        \"5\"         : 567943553912O46428,\n                    }\n\n                A dict with the possible channels is returned, associated with an :py:class:`int`\n                corresponding to the channel ID set, or :py:obj:`None` if it was not set.\n\n                For technical reasons, the default channel is actually named ``\"main\"`` in the dict.\n\n        Returns\n        -------\n        channel: discord.TextChannel\n            The channel requested.\n\n            .. note:: It can be :py:obj:`None` if the channel doesn't exist anymore.\n\n        Raises\n        ------\n        ~warnsystem.errors.NotFound\n            There is no modlog channel set with WarnSystem or Red, ask the user to set one.\n        \"\"\"\n        # raise errors if the arguments are wrong\n        if level:\n            msg = \"The level must be an int between 1 and 5 ; or a string that \" 'should be \"all\"'\n            if not isinstance(level, int) and level != \"all\":\n                raise errors.InvalidLevel(msg)\n            elif isinstance(level, int) and not 1 <= level <= 5:\n                raise errors.InvalidLevel(msg)\n\n        if level == \"all\":\n            return await self.data.guild(guild).channels.all()\n        default_channel = await self.data.guild(guild).channels.main()\n        if level:\n            channel = await self.data.guild(guild).channels.get_raw(str(level))\n        else:\n            return default_channel\n\n        if not default_channel and not channel:\n            # warnsystem default channel doesn't exist, let's try to get Red's one\n            try:\n                return await get_red_modlog_channel(guild)\n            except RuntimeError:\n                raise errors.NotFound(\"No modlog found from WarnSystem or Red\")\n\n        return self.bot.get_channel(channel if channel else default_channel)\n\n    async def get_embeds(\n        self,\n        guild: discord.Guild,\n        member: Union[discord.Member, UnavailableMember],\n        author: Union[discord.Member, str],\n        level: int,\n        reason: Optional[str] = None,\n        time: Optional[timedelta] = None,\n        date: Optional[datetime] = None,\n        message_sent: bool = True,\n    ) -> tuple:\n        \"\"\"\n        Return two embeds, one for the modlog and one for the member.\n\n        .. warning:: Unlike for the warning, the arguments are not checked and won't raise errors\n            if they are wrong. It is recommanded to call :func:`~warnsystem.api.API.warn` and let\n            it generate the embeds instead.\n\n        Parameters\n        ----------\n        guild: discord.Guild\n            The Discord guild where the warning takes place.\n        member: Union[discord.Member, UnavailableMember]\n            The warned member. Should only be :class:`UnavailableMember` in case of a hack ban.\n        author: Union[discord.Member, str]\n            The moderator that warned the user. If it's not a Discord user, you can specify a\n            :py:class:`str` instead (e.g. \"Automod\").\n        level: int\n            The level of the warning which should be between 1 and 5.\n        reason: Optional[str]\n            The reason of the warning.\n        time: Optional[timedelta]\n            The time before the action ends. Only for mute and ban.\n        date: Optional[datetime]\n            When the action was taken.\n        message_sent: bool\n            Set to :py:obj:`False` if the embed couldn't be sent to the warned user.\n\n        Returns\n        -------\n        tuple\n            A :py:class:`tuple` with the modlog embed at index 0, and the user embed at index 1.\n        \"\"\"\n        action = {\n            1: (_(\"warn\"), _(\"warns\")),\n            2: (_(\"mute\"), _(\"mutes\")),\n            3: (_(\"kick\"), _(\"kicks\")),\n            4: (_(\"softban\"), _(\"softbans\")),\n            5: (_(\"ban\"), _(\"bans\")),\n        }.get(level, _(\"unknown\"))\n        mod_message = \"\"\n        if not reason:\n            reason = _(\"No reason was provided.\")\n            mod_message = _(\"\\nEdit this with `[p]warnings {id}`\").format(id=member.id)\n        logs = await self.data.custom(\"MODLOGS\", guild.id, member.id).x()\n\n        # prepare the status field\n        total_warns = len(logs) + 1\n        total_type_warns = (\n            len([x for x in logs if x[\"level\"] == level]) + 1\n        )  # number of warns of the received type\n\n        # a lambda that returns a string; if True is given, a third person sentence is returned\n        # (modlog), if False is given, a first person sentence is returned (DM user)\n        current_status = lambda x: _(\n            \"{who} now {verb} {total} {warning} ({total_type} {action})\"\n        ).format(\n            who=_(\"The member\") if x else _(\"You\"),\n            verb=_(\"has\") if x else _(\"have\"),\n            total=total_warns,\n            warning=_(\"warnings\") if total_warns > 1 else _(\"warning\"),\n            total_type=total_type_warns,\n            action=action[1] if total_type_warns > 1 else action[0],\n        )\n\n        # we set any value that can be used multiple times\n        invite = None\n        log_description = await self.data.guild(guild).embed_description_modlog.get_raw(level)\n        if \"{invite}\" in log_description:\n            try:\n                invite = await guild.create_invite(max_uses=1)\n            except Exception:\n                invite = _(\"*[couldn't create an invite]*\")\n        user_description = await self.data.guild(guild).embed_description_user.get_raw(level)\n        if \"{invite}\" in user_description and not invite:\n            try:\n                invite = await guild.create_invite(max_uses=1)\n            except Exception:\n                invite = _(\"*[couldn't create an invite]*\")\n        if date:\n            today = date.strftime(\"%a %d %B %Y %H:%M\")\n        else:\n            today = datetime.utcnow()\n        if time:\n            duration = self._format_timedelta(time)\n        else:\n            duration = _(\"*[No time given]*\")\n\n        def format_description(text):\n            try:\n                return text.format(\n                    invite=invite,\n                    member=SafeMember(member),\n                    mod=SafeMember(author),\n                    duration=duration,\n                    time=today,\n                )\n            except Exception:\n                log.error(\n                    f\"[Guild {guild.id}] Failed to format description in embed\", exc_info=True\n                )\n                return \"Failed to format field.\"\n\n        link = re.search(r\"(https?://)\\S+\\.(jpg|jpeg|png|gif|webm)\", reason)\n\n        # embed for the modlog\n        log_embed = discord.Embed()\n        log_embed.set_author(name=f\"{member.name} | {member.id}\", icon_url=member.avatar_url)\n        log_embed.title = _(\"Level {level} warning ({action})\").format(\n            level=level, action=action[0]\n        )\n        log_embed.description = format_description(log_description)\n        log_embed.add_field(name=_(\"Member\"), value=member.mention, inline=True)\n        log_embed.add_field(name=_(\"Moderator\"), value=author.mention, inline=True)\n        if time:\n            log_embed.add_field(name=_(\"Duration\"), value=duration, inline=True)\n        log_embed.add_field(name=_(\"Reason\"), value=reason + mod_message, inline=False)\n        log_embed.add_field(name=_(\"Status\"), value=current_status(True), inline=False)\n        log_embed.timestamp = date\n        log_embed.set_thumbnail(url=await self.data.guild(guild).thumbnails.get_raw(level))\n        log_embed.colour = await self.data.guild(guild).colors.get_raw(level)\n        log_embed.url = await self.data.guild(guild).url()\n        log_embed.set_image(url=link.group() if link else \"\")\n        if not message_sent:\n            log_embed.description += _(\n                \"\\n\\n***The message could not be delivered to the user. They may have DMs \"\n                \"disabled, blocked the bot, or may not have a mutual server.***\"\n            )\n\n        # embed for the member in DM\n        user_embed = deepcopy(log_embed)\n        user_embed.set_author(name=\"\")\n        user_embed.description = format_description(user_description)\n        if mod_message:\n            user_embed.set_field_at(3 if time else 2, name=_(\"Reason\"), value=reason)\n        user_embed.remove_field(4 if time else 3)  # removes status field (gonna be added back)\n        user_embed.remove_field(0)  # removes member field\n        user_embed.add_field(name=_(\"Status\"), value=current_status(False), inline=False)\n        if time:\n            user_embed.set_field_at(\n                1, name=_(\"Duration\"), value=self._format_timedelta(time), inline=True\n            )\n        if not await self.data.guild(guild).show_mod():\n            user_embed.remove_field(0)  # called twice, removing moderator field\n\n        return (log_embed, user_embed)\n\n    async def maybe_create_mute_role(self, guild: discord.Guild) -> bool:\n        \"\"\"\n        Create the mod role for WarnSystem if it doesn't exist.\n        This will also edit all channels to deny the following permissions to this role:\n\n        *   ``send_messages``\n        *   ``add_reactions``\n        *   ``speak``\n\n        Parameters\n        ----------\n        guild: discord.Guild\n            The guild you want to set up the mute in.\n\n        Returns\n        -------\n        Union[bool, list]\n            *   :py:obj:`False` if the role already exists.\n            *   :py:class:`list` if the role was created, with a list of errors for each channel.\n                Empty list means completly successful edition.\n\n        Raises\n        ------\n        ~warnsystem.errors.MissingPermissions\n            The bot lacks the :attr:`discord.Permissions.create_roles` permission.\n        discord.errors.HTTPException\n            Creating the role failed.\n        \"\"\"\n        role = await self.cache.get_mute_role(guild)\n        role = guild.get_role(role)\n        if role:\n            return False\n\n        if not guild.me.guild_permissions.manage_roles:\n            raise errors.MissingPermissions(\n                _(\"I can't manage roles, please give me this permission to continue.\")\n            )\n\n        # no mod role on this guild, let's create one\n        role = await guild.create_role(\n            name=\"Muted\",\n            reason=_(\n                \"WarnSystem mute role. This role will be assigned to the muted members, \"\n                \"feel free to move it or modify its channel permissions.\"\n            ),\n        )\n        await asyncio.sleep(0.5)  # prevents an error when repositionning the role\n        await role.edit(\n            position=guild.me.top_role.position - 1,\n            reason=_(\n                \"Modifying role's position, keep it under my top role so \"\n                \"I can add it to muted members.\"\n            ),\n        )\n        perms = discord.PermissionOverwrite(send_messages=False, add_reactions=False, speak=False)\n        errors = []\n        for channel in guild.channels:\n            try:\n                await channel.set_permissions(\n                    target=role,\n                    overwrite=perms,\n                    reason=_(\n                        \"Setting up WarnSystem mute. All muted members will have this role, \"\n                        \"feel free to edit its permissions.\"\n                    ),\n                )\n            except discord.errors.Forbidden:\n                errors.append(\n                    _(\n                        \"Cannot edit permissions of the channel {channel} because of a \"\n                        \"permission error (probably enforced permission for `Manage channel`).\"\n                    ).format(channel=channel.mention)\n                )\n            except discord.errors.HTTPException as e:\n                errors.append(\n                    _(\n                        \"Cannot edit permissions of the channel {channel} because of \"\n                        \"an unknown error.\"\n                    ).format(channel=channel.mention)\n                )\n                log.warn(\n                    f\"[Guild {guild.id}] Couldn't edit permissions of {channel} (ID: \"\n                    f\"{channel.id}) for setting up the mute role because of an HTTPException.\",\n                    exc_info=e,\n                )\n            except Exception as e:\n                errors.append(\n                    _(\n                        \"Cannot edit permissions of the channel {channel} because of \"\n                        \"an unknown error.\"\n                    ).format(channel=channel.mention)\n                )\n                log.error(\n                    f\"[Guild {guild.id}] Couldn't edit permissions of {channel} (ID: \"\n                    f\"{channel.id}) for setting up the mute role because of an unknwon error.\",\n                    exc_info=e,\n                )\n        await self.cache.update_mute_role(guild, role)\n        return errors\n\n    async def format_reason(self, guild: discord.Guild, reason: str = None) -> str:\n        \"\"\"\n        Reformat a reason with the substitutions set on the guild.\n\n        Parameters\n        ----------\n        guild: discord.Guild\n            The guild where the warn is set.\n        reason: str\n            The string you want to reformat.\n\n        Returns\n        -------\n        str\n            The reformatted string\n        \"\"\"\n        if not reason:\n            return\n        substitutions = await self.data.guild(guild).substitutions()\n        for key, substitute in substitutions.items():\n            reason = reason.replace(f\"[{key}]\", substitute)\n        return reason\n\n    async def warn(\n        self,\n        guild: discord.Guild,\n        members: Iterable[Union[discord.Member, UnavailableMember]],\n        author: Union[discord.Member, str],\n        level: int,\n        reason: Optional[str] = None,\n        time: Optional[timedelta] = None,\n        date: Optional[datetime] = None,\n        log_modlog: Optional[bool] = True,\n        log_dm: Optional[bool] = True,\n        take_action: Optional[bool] = True,\n        automod: Optional[bool] = True,\n        progress_tracker: Optional[Callable[[int], Awaitable[None]]] = None,\n    ) -> bool:\n        \"\"\"\n        Set a warning on a member of a Discord guild and log it with the WarnSystem system.\n\n        .. tip:: The message that comes with the following exceptions are already\n            translated and ready to be sent to Discord:\n\n            *   :class:`~warnsystem.errors.NotFound`\n            *   :class:`~warnsystem.errors.LostPermissions`\n            *   :class:`~warnsystem.errors.MemberTooHigh`\n            *   :class:`~warnsystem.errors.MissingPermissions`\n            *   :class:`~warnsystem.errors.SuicidePrevention`\n\n        Parameters\n        ----------\n        guild: discord.Guild\n            The guild of the member to warn\n        member: Iterable[Union[discord.Member, UnavailableMember]]\n            The member that will be warned. It can be an instance of\n            :py:class:`warnsystem.api.UnavailableMember` if you need\n            to ban someone not in the guild.\n        author: Union[discord.Member, str]\n            The member that called the action, which will be associated to the log.\n        level: int\n            An :py:class:`int` between 1 and 5, specifying the warning level:\n\n            #.  Simple DM warning\n            #.  Mute (can be temporary)\n            #.  Kick\n            #.  Softban\n            #.  Ban (can be temporary ban, or hack ban, if the member is not in the server)\n        reason: Optional[str]\n            The optional reason of the warning. It is strongly recommanded to set one.\n        time: Optional[timedelta]\n            The time before cancelling the action. This only works for a mute or a ban.\n        date: Optional[datetime]\n            When the action was taken. Only use if you want to overwrite the current date and time.\n        log_modlog: Optional[bool]\n            Specify if an embed should be posted to the modlog channel. Default to :py:obj:`True`.\n        log_dm: Optional[bool]\n            Specify if an embed should be sent to the warned user. Default to :py:obj:`True`.\n        take_action: Optional[bool]\n            Specify if the bot should take action on the member (mute, kick, softban, ban). If set\n            to :py:obj:`False`, the bot will only send a log embed to the member and in the modlog.\n            Default to :py:obj:`True`.\n        automod: Optional[bool]\n            Set to :py:obj:`False` to skip automod, preventing multiple warnings at once and\n            saving performances. Automod might trigger on a next warning though.\n        progress_tracker: Optional[Callable[[int], Awaitable[None]]]\n            an async callable (function or lambda) which takes one argument to follow the progress\n            of the warn. The argument is the number of warns committed. Here's an example:\n\n            .. code-block:: python3\n\n                i = 0\n                message = await ctx.send(\"Mass warn started...\")\n\n                async def update_count(count):\n                    i = count\n\n                async def update_msg():\n                    await message.edit(content=f\"{i}/{len(members)} members warned.\")\n                    await asyncio.sleep(1)\n\n                await api.warn(guild, members, ctx.author, 1, progress_tracker=update_count)\n\n        Returns\n        -------\n        dict\n            A dict of members which couldn't be warned associated to the exception related.\n\n\n        Raises\n        ------\n        ~warnsystem.errors.InvalidLevel\n            The level must be an :py:class:`int` between 1 and 5.\n        ~warnsystem.errors.BadArgument\n            You need to provide a valid :class:`discord.Member` object, except for a\n            hackban where a :class:`discord.User` works.\n        ~warnsystem.errors.MissingMuteRole\n            You're trying to mute someone but the mute role was not setup yet.\n            You can fix this by calling :func:`~warnsystem.api.API.maybe_create_mute_role`.\n        ~warnsystem.errors.LostPermissions\n            The bot lost a permission to do something (it had the perm before). This\n            can be lost permissions for sending messages to the modlog channel or\n            interacting with the mute role.\n        ~warnsystem.errors.MemberTooHigh\n            The bot is trying to take actions on someone but his top role is higher\n            than the bot's top role in the guild's hierarchy.\n        ~warnsystem.errors.NotAllowedByHierarchy\n            The moderator trying to warn someone is lower than him in the role hierarchy,\n            while the bot still has permissions to act. This is raised only if the\n            hierarchy check is enabled.\n        ~warnsystem.errors.MissingPermissions\n            The bot lacks a permissions to do something. Can be adding role, kicking\n            or banning members.\n        discord.errors.NotFound\n            When the user ID provided for hackban isn't recognized by Discord.\n        discord.errors.HTTPException\n            Unknown error from Discord API. It's recommanded to catch this\n            potential error too.\n        \"\"\"\n\n        async def warn_member(member: Union[discord.Member, UnavailableMember], audit_reason: str):\n            nonlocal i\n            roles = []\n            # permissions check\n            if level > 1 and guild.me.top_role.position <= member.top_role.position:\n                # check if the member is below the bot in the roles's hierarchy\n                return errors.MemberTooHigh(\n                    _(\n                        \"Cannot take actions on this member, they are \"\n                        \"above me in the roles hierarchy. Modify \"\n                        \"the hierarchy so my top role ({bot_role}) is above {member_role}.\"\n                    ).format(bot_role=guild.me.top_role.name, member_role=member.top_role.name)\n                )\n            if await self.data.guild(guild).respect_hierarchy() and (\n                not (await self.bot.is_owner(author) or author.id == guild.owner_id)\n                and member.top_role.position >= author.top_role.position\n            ):\n                return errors.NotAllowedByHierarchy(\n                    \"The moderator is lower than the member in the servers's role hierarchy.\"\n                )\n            if level > 2 and member.id == guild.owner_id:\n                return errors.MissingPermissions(\n                    _(\"I can't take actions on the owner of the guild.\")\n                )\n            if member == guild.me:\n                return errors.SuicidePrevention(\n                    _(\n                        \"Why would you warn me? I did nothing wrong :c\\n\"\n                        \"(use a manual kick/ban instead, warning the bot will cause issues)\"\n                    )\n                )\n            # send the message to the user\n            if log_modlog or log_dm:\n                modlog_e, user_e = await self.get_embeds(\n                    guild, member, author, level, reason, time, date\n                )\n            if log_dm:\n                try:\n                    await member.send(embed=user_e)\n                except (discord.errors.Forbidden, errors.UserNotFound):\n                    modlog_e = (\n                        await self.get_embeds(\n                            guild, member, author, level, reason, time, date, message_sent=False\n                        )\n                    )[0]\n                except discord.errors.NotFound:\n                    raise\n                except discord.errors.HTTPException as e:\n                    modlog_e = (\n                        await self.get_embeds(\n                            guild, member, author, level, reason, time, date, message_sent=False\n                        )\n                    )[0]\n                    log.warn(\n                        f\"[Guild {guild.id}] Couldn't send a message to {member} \"\n                        f\"(ID: {member.id}) because of an HTTPException.\",\n                        exc_info=e,\n                    )\n            # take actions\n            if take_action:\n                audit_reason = audit_reason.format(member=member)\n                try:\n                    if level == 2:\n                        roles = await self._mute(member, audit_reason)\n                    elif level == 3:\n                        await guild.kick(member, reason=audit_reason)\n                    elif level == 4:\n                        await guild.ban(\n                            member,\n                            reason=audit_reason,\n                            delete_message_days=await self.data.guild(guild).bandays.softban(),\n                        )\n                        await guild.unban(\n                            member,\n                            reason=_(\n                                \"Unbanning the softbanned member after cleaning up the messages.\"\n                            ),\n                        )\n                    elif level == 5:\n                        await guild.ban(\n                            member,\n                            reason=audit_reason,\n                            delete_message_days=await self.data.guild(guild).bandays.ban(),\n                        )\n                except discord.errors.HTTPException as e:\n                    log.warn(\n                        f\"[Guild {guild.id}] Failed to warn {member} because of \"\n                        \"an unknown error from Discord.\",\n                        exc_info=e,\n                    )\n                    return e\n            # actions were taken, time to log\n            if log_modlog:\n                modlog_message = await mod_channel.send(embed=modlog_e)\n            else:\n                modlog_message = None\n            data = await self._create_case(\n                guild, member, author, level, date, reason, time, roles, modlog_message\n            )\n            # start timer if there is a temporary warning\n            if time and (level == 2 or level == 5):\n                await self._start_timer(guild, member, data)\n            if automod:\n                # This function can be pretty heavy, and the response can be seriously delayed\n                # because of this, so we make it a side process instead\n                self.bot.loop.create_task(\n                    self.automod_check_for_autowarn(guild, member, author, level)\n                )\n            i += 1\n            if progress_tracker:\n                await progress_tracker(i)\n\n        if not 1 <= level <= 5:\n            raise errors.InvalidLevel(\"The level must be between 1 and 5.\")\n        # we get the modlog channel now to make sure it exists before doing anything\n        if log_modlog:\n            mod_channel = await self.get_modlog_channel(guild, level)\n        # check if the mute role exists\n        mute_role = guild.get_role(await self.cache.get_mute_role(guild))\n        if not mute_role and level == 2:\n            raise errors.MissingMuteRole(\"You need to create the mute role before doing this.\")\n        # we check for all permission problem that can occur before calling the API\n        # checks if the bot has send_messages and embed_links permissions in modlog channel\n        if not (\n            guild.me.guild_permissions.send_messages and guild.me.guild_permissions.embed_links\n        ):\n            raise errors.LostPermissions(\n                _(\n                    \"I need the `Send messages` and `Embed links` \"\n                    \"permissions in {channel} to do this.\"\n                ).format(channel=mod_channel.mention)\n            )\n        if level == 2:\n            # mute with role\n            if not guild.me.guild_permissions.manage_roles:\n                raise errors.MissingPermissions(\n                    _(\"I can't manage roles, please give me this permission to continue.\")\n                )\n            if mute_role.position >= guild.me.top_role.position:\n                raise errors.LostPermissions(\n                    _(\n                        \"The mute role `{mute_role}` was moved above my top role `{my_role}`. \"\n                        \"Please move the roles so my top role is above the mute role.\"\n                    ).format(mute_role=mute_role.name, my_role=guild.me.top_role.name)\n                )\n        if level == 3:\n            # kick\n            if not guild.me.guild_permissions.kick_members:\n                raise errors.MissingPermissions(\n                    _(\"I can't kick members, please give me this permission to continue.\")\n                )\n        if level >= 4:\n            # softban or ban\n            if not guild.me.guild_permissions.ban_members:\n                raise errors.MissingPermissions(\n                    _(\"I can't ban members, please give me this permission to continue.\")\n                )\n\n        action = {1: _(\"warn\"), 2: _(\"mute\"), 3: _(\"kick\"), 4: _(\"softban\"), 5: _(\"ban\")}.get(\n            level, _(\"unknown\")\n        )\n        audit_reason = _(\n            \"[WarnSystem] {action} requested by {author} (ID: {author.id}) against {member}. \"\n        ).format(\n            author=author, action=action, member=\"{member}\"\n        )  # member will be edited later\n        if time:\n            audit_reason += _(\"\\n\\nDuration: {time} \").format(time=self._format_timedelta(time))\n        if reason:\n            if len(audit_reason + reason) < 490:\n                audit_reason += _(\"Reason: {reason}\").format(reason=reason)\n            else:\n                audit_reason += _(\"Reason too long to be shown.\")\n        if not date:\n            date = datetime.utcnow()\n\n        i = 0\n        fails = [await warn_member(x, audit_reason) for x in members if x]\n        # all good!\n        return list(filter(None, fails))\n\n    async def _check_endwarn(self):\n        async def reinvite(guild, user, reason, duration):\n            channel = next(\n                (\n                    c  # guild.text_channels is already sorted by position\n                    for c in guild.text_channels\n                    if c.permissions_for(guild.me).create_instant_invite\n                ),\n                None,\n            )\n            if channel is None:\n                # can't find a valid channel\n                log.info(\n                    f\"[Guild {guild.id}] Can't find a text channel where I can create an invite \"\n                    f\"when reinviting {member} (ID: {member.id}) after its unban.\"\n                )\n                return\n\n            try:\n                invite = await channel.create_invite(max_uses=1)\n            except Exception as e:\n                log.warn(\n                    f\"[Guild {guild.id}] Couldn't create an invite to reinvite \"\n                    f\"{member} (ID: {member.id}) after its unban.\",\n                    exc_info=e,\n                )\n            else:\n                try:\n                    await member.send(\n                        _(\n                            \"You were unbanned from {guild}, your temporary ban (reason: \"\n                            \"{reason}) just ended after {duration}.\\nYou can join back using this \"\n                            \"invite: {invite}\"\n                        ).format(guild=guild.name, reason=reason, duration=duration, invite=invite)\n                    )\n                except discord.errors.Forbidden:\n                    # couldn't send message to the user, quite common\n                    log.info(\n                        f\"[Guild {guild.id}] Couldn't reinvite member {member} \"\n                        f\"(ID: {member.id}) after its temporary ban.\"\n                    )\n\n        now = datetime.utcnow()\n        for guild in self.bot.guilds:\n            data = await self.cache.get_temp_action(guild)\n            if not data:\n                continue\n            to_remove = []\n            for member_id, action in data.items():\n                member_id = int(member_id)\n                try:\n                    taken_on = self._get_datetime(action[\"time\"])\n                    duration = self._get_timedelta(action[\"duration\"])\n                except ValueError as e:\n                    log.error(\n                        f\"[Guild {guild.id}] Time or duration cannot be fetched. This is \"\n                        \"probably leftovers from the conversion of post 1.3 data. Removing the \"\n                        f\"temp warning, not taking actions... Member: {member_id}, data: {action}\",\n                        exc_info=e,\n                    )\n                    to_remove.append(UnavailableMember(self.bot, guild._state, member_id))\n                    continue\n                author = guild.get_member(action[\"author\"])\n                member = guild.get_member(member_id)\n                case_reason = action[\"reason\"]\n                level = action[\"level\"]\n                action_str = _(\"mute\") if level == 2 else _(\"ban\")\n                if not member:\n                    member = UnavailableMember(self.bot, guild._state, member_id)\n                    if level == 2:\n                        to_remove.append(member)\n                        continue\n                roles = list(filter(None, [guild.get_role(x) for x in action.get(\"roles\") or []]))\n\n                reason = _(\n                    \"End of timed {action} of {member} requested by {author} that lasted \"\n                    \"for {time}. Reason of the {action}: {reason}\"\n                ).format(\n                    action=action_str,\n                    member=member,\n                    author=author if author else action[\"author\"],\n                    time=self._format_timedelta(duration),\n                    reason=case_reason,\n                )\n                if (taken_on + duration) < now:\n                    # end of warn\n                    try:\n                        if level == 2:\n                            await self._unmute(member, reason=reason, old_roles=roles)\n                        if level == 5:\n                            await guild.unban(member, reason=reason)\n                            if await self.data.guild(guild).reinvite():\n                                await reinvite(\n                                    guild,\n                                    member,\n                                    case_reason,\n                                    self._format_timedelta(timedelta(seconds=action[\"duration\"])),\n                                )\n                    except discord.errors.Forbidden:\n                        log.warn(\n                            f\"[Guild {guild.id}] I lost required permissions for \"\n                            f\"ending the timed {action_str}. Member {member} (ID: {member.id}) \"\n                            \"will stay as it is now.\"\n                        )\n                    except discord.errors.HTTPException as e:\n                        log.warn(\n                            f\"[Guild {guild.id}] Couldn't end the timed {action_str} of {member} \"\n                            f\"(ID: {member.id}). He will stay as it is now.\",\n                            exc_info=e,\n                        )\n                    else:\n                        log.debug(\n                            f\"[Guild {guild.id}] Ended timed {action_str} of {member} (ID: \"\n                            f\"{member.id}) taken on {self._format_datetime(taken_on)} requested \"\n                            f\"by {author} (ID: {author.id}) that lasted for \"\n                            f\"{self._format_timedelta(duration)} for the reason {case_reason}\"\n                            f\"\\nCurrent time: {now}\\nExpected end time of warn: \"\n                            f\"{self._format_datetime(taken_on + duration)}\"\n                        )\n                    to_remove.append(member)\n            if to_remove:\n                await self.cache.bulk_remove_temp_action(guild, to_remove)\n\n    async def _loop_task(self):\n        \"\"\"\n        This is an infinite loop task started with the cog that will check\\\n        if a temporary warn (mute or ban) is over, and cancel the action if it's true.\n\n        The loop runs every 10 seconds.\n        \"\"\"\n        await self.bot.wait_until_ready()\n        log.debug(\n            \"Starting infinite loop for unmutes and unbans. Canel the \"\n            'task with bot.get_cog(\"WarnSystem\").task.cancel()'\n        )\n        errors = 0\n        while True:\n            try:\n                await self._check_endwarn()\n            except Exception as e:\n                errors += 1\n                if errors >= 3:\n                    # more than 3 errors in our loop, let's shut down the loop\n                    log.critical(\n                        \"The loop for unmutes and unbans encountered a third error. To prevent \"\n                        \"more damages, the loop will be cancelled. Timed mutes and bans no longer \"\n                        \"works for now. Reload the cog to start the loop back. If the problem \"\n                        \"persists, report the error and update the cog.\",\n                        exc_info=e,\n                    )\n                    return\n                log.error(\n                    \"Error in loop for unmutes and unbans. The loop will be resumed.\", exc_info=e\n                )\n            await asyncio.sleep(10)\n\n    # automod stuff\n    def enable_automod(self):\n        \"\"\"\n        Enable automod checks and listeners on the bot.\n        \"\"\"\n        log.info(\"Enabling automod listeners and event loops.\")\n        self.bot.add_listener(self.automod_on_message, name=\"on_message\")\n        self.automod_warn_task = self.bot.loop.create_task(self.automod_warn_loop())\n\n    def disable_automod(self):\n        \"\"\"\n        Disable automod checks and listeners on the bot.\n        \"\"\"\n        log.info(\"Disabling automod listeners and event loops.\")\n        self.bot.remove_listener(self.automod_on_message, name=\"on_message\")\n        if hasattr(self, \"automod_warn_task\"):\n            self.automod_warn_task.cancel()\n\n    async def automod_on_message(self, message: discord.Message):\n        guild = message.guild\n        member = message.author\n        if not guild:\n            return\n        if member.bot:\n            return\n        if guild.owner_id == member.id:\n            return\n        if not self.cache.is_automod_enabled(guild):\n            return\n        if await self.bot.is_automod_immune(message):\n            return\n        if await self.bot.is_mod(member):\n            return\n        # we run all tasks concurrently\n        # results are returned in the same order (either None or an exception)\n        regex_exception, antispam_exception = await asyncio.gather(\n            self.automod_process_regex(message),\n            self.automod_process_antispam(message),\n            return_exceptions=True,\n        )\n        if regex_exception:\n            log.error(\n                f\"[Guild {message.guild.id}] Error while processing message for regex automod.\",\n                exc_info=regex_exception,\n            )\n        if antispam_exception:\n            log.error(\n                f\"[Guild {message.guild.id}] Error while processing message for antispam system.\",\n                exc_info=antispam_exception,\n            )\n\n    async def _safe_regex_search(self, regex: re.Pattern, message: discord.Message):\n        \"\"\"\n        Mostly safe regex search to prevent reDOS from user defined regex patterns\n\n        This works by running the regex pattern inside a process pool defined at the\n        cog level and then checking that process in the default executor to keep\n        things asynchronous. If the process takes too long to complete we log a\n        warning and remove the trigger from trying to run again.\n\n        This function was fully made by TrustyJAID for Trusty-cogs/retrigger (amazing cog btw)\n        https://github.com/TrustyJAID/Trusty-cogs/blob/f08a88040dcc67291a463517a70dcbbe702ba8e3/retrigger/triggerhandler.py#L494\n        \"\"\"\n        guild = message.guild\n        try:\n            process = self.re_pool.apply_async(regex.findall, (message.content,))\n            task = functools.partial(process.get, timeout=self.regex_timeout)\n            new_task = self.bot.loop.run_in_executor(None, task)\n            search = await asyncio.wait_for(new_task, timeout=self.regex_timeout + 5)\n        except TimeoutError:\n            error_msg = (\n                f\"[Guild {guild.id}] Automod: regex process took too long. \"\n                f\"Removing from memory. Offending regex: {regex.pattern}\"\n            )\n            log.warning(error_msg)\n            return (False, [])\n            # we certainly don't want to be performing multiple triggers if this happens\n        except asyncio.TimeoutError:\n            error_msg = (\n                f\"[Guild {guild.id}] Automod: regex asyncio timed out. \"\n                f\"Removing from memory. Offending regex: {regex.pattern}\"\n            )\n            log.warning(error_msg)\n            return (False, [])\n        except Exception:\n            log.error(\n                f\"[Guild {guild.id}] Automod regex encountered an error with {regex.pattern}\",\n                exc_info=True,\n            )\n            return (True, [])\n        else:\n            return (True, search)\n\n    async def automod_process_regex(self, message: discord.Message):\n        guild = message.guild\n        member = message.author\n        all_regex = await self.cache.get_automod_regex(guild)\n        for name, regex in all_regex.items():\n            result = await self._safe_regex_search(regex[\"regex\"], message)\n            if not result[1]:\n                if result[0] is False:\n                    await self.cache.remove_automod_regex(guild, name)\n                continue\n            time = None\n            if regex[\"time\"]:\n                time = self._get_timedelta(regex[\"time\"])\n            level = regex[\"level\"]\n            reason = regex[\"reason\"].format(guild=guild, channel=message.channel, member=member)\n            fail = await self.warn(guild, [member], guild.me, level, reason, time)\n            if fail:\n                log.warn(\n                    f\"[Guild {guild.id}] Regex automod warn on member {member} ({member.id})\\n\"\n                    f\"Level: {level}. Time: {time}. Reason: {reason}\\n\"\n                    f\"Original message: {message.content}\\n\"\n                    f\"Automatic warn failed due to the following exception:\",\n                    exc_info=fail[0],\n                )\n            else:\n                log.info(\n                    f\"[Guild {guild.id}] Regex automod warn on member {member} ({member.id})\\n\"\n                    f\"Level: {level}. Time: {time}. Reason: {reason}\\n\"\n                    f\"Original message: {message.content}\"\n                )\n\n    async def automod_process_antispam(self, message: discord.Message):\n        # we store the data in self.antispam\n        # keys are as follow: GUILD_ID > CHANNEL_ID > MEMBER_ID = tuple\n        # tuple contains list timestamps of recent messages + check if the member was warned\n        # if the antispam is triggered once, we send a message in the chat (refered as text warn)\n        # if it's triggered a second time, an actual warn is given\n        guild = message.guild\n        channel = message.channel\n        member = message.author\n        antispam_data = await self.cache.get_automod_antispam(guild)\n        if antispam_data is False:\n            return\n\n        # we slowly go across each key, if it doesn't exist, data is created then the\n        # function ends since there's no data to check\n        InitialData = namedtuple(\"InitialData\", [\"messages\", \"warned\"])\n        data = InitialData(messages=[], warned=False)\n        try:\n            guild_data = self.antispam[guild.id]\n        except KeyError:\n            self.antispam[guild.id] = {channel.id: {member.id: data}}\n            return\n        else:\n            pass\n        try:\n            channel_data = guild_data[channel.id]\n        except KeyError:\n            self.antispam[guild.id][channel.id] = {member.id: data}\n            return\n        else:\n            del guild_data\n        try:\n            data = channel_data[member.id]\n        except KeyError:\n            pass\n        del channel_data\n\n        data.messages.append(message.created_at)\n        # now we've got our list of timestamps, just gotta clean the old ones\n        data = data._replace(\n            messages=self._automod_clean_old_messages(\n                antispam_data[\"delay\"], message.created_at, data.messages\n            )\n        )\n        if len(data.messages) <= antispam_data[\"max_messages\"]:\n            # antispam not triggered, we can exit now\n            self.antispam[guild.id][channel.id][member.id] = data\n            return\n        # at this point, user is considered to be spamming\n        # we cleanup his x last messages (max_messages + 1), then either send a text warn\n        # or perform an actual warnsystem warn (I'm confusing ik)\n        if (\n            data.warned is False\n            or (datetime.now() - data.warned).total_seconds()\n            < antispam_data[\"delay_before_action\"]\n        ):\n            bot_message = await channel.send(\n                _(\"{member} you're sending messages too fast!\").format(member=member.mention),\n                delete_after=5,\n            )\n            data = InitialData(messages=[], warned=bot_message.created_at)\n        else:\n            # already warned once within delay_before_action, gotta take actions\n            warn_data = antispam_data[\"warn\"]\n            warn_data[\"author\"] = guild.me\n            if warn_data[\"time\"]:\n                warn_data[\"time\"] = self._get_timedelta(warn_data[\"time\"])\n            try:\n                self.antispam_warn_queue[guild.id][member] = warn_data\n            except KeyError:\n                self.antispam_warn_queue[guild.id] = {member: warn_data}\n            # also reset the data\n            data = InitialData(messages=[], warned=message.created_at)\n        self.antispam[guild.id][channel.id][member.id] = data\n\n    def _automod_clean_old_messages(self, delay: int, current_time: datetime, messages: list):\n        \"\"\"\n        We don't keep messages older than the delay in the cache\n        \"\"\"\n        message: datetime\n        delta: timedelta\n        new_list = []\n        for message in messages:\n            delta = current_time - message\n            if delta.total_seconds() <= delay:\n                new_list.append(message)\n        return new_list\n\n    def _automod_clean_cache(\n        self, guild: discord.Guild, channel: discord.TextChannel, member: discord.Member\n    ):\n        \"\"\"\n        We quickly end up with a dict filled with empty values, we gotta clean that.\n        \"\"\"\n        del self.automod[guild.id][channel.id][member.id]\n        if not self.automod[guild.id][channel.id]:\n            del self.automod[guild.id][channel.id]\n            if not self.automod[guild.id]:\n                del self.automod[guild.id]\n\n    async def automod_check_for_autowarn(\n        self, guild: discord.Guild, member: discord.Member, author: discord.Member, level: int\n    ):\n        \"\"\"\n        Iterate through member's modlog, looking for possible automatic warns.\n\n        Level is the last warning's level, which will filter a lot of possible autowarns and,\n        therefore, save performances.\n\n        This can be a heavy call if there are a lot of possible autowarns and a long modlog.\n        \"\"\"\n        t = datetime.now()\n        try:\n            await self._automod_check_for_autowarn(guild, member, author, level)\n        except Exception as e:\n            log.error(f\"[Guild {guild.id}] A problem occured with automod check.\", exc_info=e)\n        time_taken: timedelta = datetime.now() - t\n        if time_taken.total_seconds() > 10 and guild.id not in self.warned_guilds:\n            self.warned_guilds.append(guild.id)\n            log.warning(\n                f\"[Guild {guild.id}] Automod check took a long time! Time taken: {time_taken}\\n\"\n                \"Try to reduce the amount of warns/autowarns or blame Laggron for poorly \"\n                \"written code (second option is preferred).\\nThis warning will not show again \"\n                \"for this guild until reload.\"\n            )\n\n    async def _automod_check_for_autowarn(\n        self, guild: discord.Guild, member: discord.Member, author: discord.Member, level: int\n    ):\n        \"\"\"\n        Prevents having to put this whole function into a try/except block.\n        \"\"\"\n        if not self.cache.is_automod_enabled(guild):\n            return\n        # starting the iteration through warnings can cost performances\n        # so we look for conditions that confirms the member cannot be affected by automod\n        if await self.bot.is_automod_immune(member):\n            return\n        warns = await self.get_all_cases(guild, member)\n        if len(warns) < 2:\n            return  # autowarn can't be triggered with a single warning in the modlog\n        autowarns = await self.data.guild(guild).automod.warnings()\n        # remove all autowarns that are locked to a specific level\n        # where the last warning's level doesn't correspond\n        # also remove autowarns that are automod only if warn author isn't the bot\n\n        def is_autowarn_valid(warn):\n            if author.id != self.bot.user.id and warn[\"automod_only\"]:\n                return False\n            return warn[\"level\"] == 0 or warn[\"level\"] == level\n\n        autowarns = list(filter(is_autowarn_valid, autowarns))\n        if not autowarns:\n            return  # no autowarn to iterate through\n        for i, autowarn in enumerate(autowarns):\n            # prepare for iteration\n            autowarns[i][\"count\"] = 0\n            # if the condition is met (within the specified time? not an automatic warn?)\n            # we increase this value until reaching the given limit\n            time = autowarn[\"time\"]\n            if time:\n                until = datetime.utcnow() - timedelta(seconds=time)\n                autowarns[i][\"until\"] = until\n        del time\n        found_warnings = {}  # we fill this list with the valid autowarns, there can be more than 1\n        for warn in warns[::-1]:\n            to_remove = []  # list of autowarns to remove during the iteration (duration expired)\n            taken_on = datetime.fromtimestamp(warn[\"time\"])\n            for i, autowarn in enumerate(autowarns):\n                try:\n                    if autowarn[\"until\"] >= taken_on:\n                        to_remove.append(i)\n                        continue\n                except KeyError:\n                    pass\n                autowarns[i][\"count\"] += 1\n                if autowarns[i][\"count\"] == autowarn[\"number\"]:\n                    found_warnings[i] = autowarn[\"warn\"]\n                if autowarns[i][\"count\"] > autowarn[\"number\"]:\n                    # value exceeded, no need to continue, it's already done for this one warn\n                    to_remove.append(i)\n                    del found_warnings[i]\n            for index in reversed(to_remove):\n                autowarns.pop(index)\n            if not autowarns:\n                # we could be out of autowarns to check after a certain time\n                # no need to continue the iteration\n                break\n        del to_remove, taken_on, autowarns\n        for i, warn in found_warnings.items():\n            try:\n                await self.warn(\n                    guild,\n                    members=[member],\n                    author=guild.me,\n                    level=warn[\"level\"],\n                    reason=warn[\"reason\"],\n                    time=self._get_timedelta(warn[\"duration\"]) if warn[\"duration\"] else None,\n                )\n            except Exception as e:\n                log.error(\n                    f\"[Guild {guild.id}] Failed to perform automod warn on member {member} \"\n                    f\"({member.id}). Needed to perform automatic warn {i}\",\n                    exc_info=e,\n                )\n            else:\n                log.debug(\n                    f\"[Guild {guild.id}] Successfully performed automatic \"\n                    f\"warn {i} on member {member} ({member.id}).\"\n                )\n\n    async def automod_warn_loop(self):\n        # since this is asyncronous code, sometimes there can be too many warnings performed\n        # especially with message antispam, since it treats multiple messages simultaneously\n        # instead, we have a dict of warnings to perform, and we remove it only once the warn is\n        # done. That way, duplicate warnings won't happen.\n\n        async def warn(member: discord.Member, data: dict):\n            guild = member.guild\n            try:\n                await self.warn(guild, [member], **data)\n            except Exception as e:\n                log.error(\n                    f\"Cannot perform autowarn on member {member} ({member.id}). Data: {data}\",\n                    exc_info=e,\n                )\n            finally:\n                await asyncio.sleep(1)\n                del self.antispam_warn_queue[guild.id][member]\n                if not self.antispam_warn_queue[guild.id]:\n                    del self.antispam_warn_queue[guild.id]\n\n        async def loop():\n            guild: discord.Guild\n            member: discord.Member\n            coros = []\n            for guild_id, data in self.antispam_warn_queue.items():\n                for member, value in data.items():\n                    coros.append(warn(member, value))\n            coros = asyncio.gather(*coros, return_exceptions=True)\n            await coros\n\n        errors = 0\n        while True:\n            try:\n                await loop()\n            except Exception as e:\n                errors += 1\n                if errors >= 3:\n                    # more than 3 errors in our loop, let's shut down the loop\n                    log.critical(\n                        \"The loop for automod warnings encountered a third error. To prevent \"\n                        \"more damages, the loop will be cancelled. Timed mutes and bans no longer \"\n                        \"works for now. Reload the cog to start the loop back. If the problem \"\n                        \"persists, report the error and update the cog.\",\n                        exc_info=e,\n                    )\n                    return\n                log.error(\n                    \"Error in loop for automod warnings. The loop will be resumed.\", exc_info=e\n                )\n            await asyncio.sleep(1)\n", "# WarnSystem by retke, aka El Laggron\nimport discord\nimport logging\nimport asyncio\nimport re\n\nfrom typing import Optional\nfrom asyncio import TimeoutError as AsyncTimeoutError\nfrom abc import ABC\nfrom datetime import datetime, timedelta\nfrom laggron_utils.logging import close_logger, DisabledConsoleOutput\n\nfrom redbot.core import commands, Config, checks\nfrom redbot.core.commands.converter import TimedeltaConverter\nfrom redbot.core.i18n import Translator, cog_i18n\nfrom redbot.core.utils import predicates, menus, mod\nfrom redbot.core.utils.chat_formatting import pagify\n\nfrom . import errors\nfrom .api import API, UnavailableMember\nfrom .automod import AutomodMixin\nfrom .cache import MemoryCache\nfrom .converters import AdvancedMemberSelect\nfrom .settings import SettingsMixin\n\nlog = logging.getLogger(\"red.laggron.warnsystem\")\n_ = Translator(\"WarnSystem\", __file__)\nBaseCog = getattr(commands, \"Cog\", object)\n\n# Red 3.0 backwards compatibility, thanks Sinbad\nlistener = getattr(commands.Cog, \"listener\", None)\nif listener is None:\n\n    def listener(name=None):\n        return lambda x: x\n\n\ndef pretty_date(time: datetime):\n    \"\"\"\n    Get a datetime object and return a pretty string like 'an hour ago',\n    'Yesterday', '3 months ago', 'just now', etc\n\n    This is based on this answer, modified for i18n compatibility:\n    https://stackoverflow.com/questions/1551382/user-friendly-time-format-in-python\n    \"\"\"\n\n    def text(amount: float, unit: tuple):\n        amount = round(amount)\n        if amount > 1:\n            unit = unit[1]\n        else:\n            unit = unit[0]\n        return _(\"{amount} {unit} ago.\").format(amount=amount, unit=unit)\n\n    units_name = {\n        0: (_(\"year\"), _(\"years\")),\n        1: (_(\"month\"), _(\"months\")),\n        2: (_(\"week\"), _(\"weeks\")),\n        3: (_(\"day\"), _(\"days\")),\n        4: (_(\"hour\"), _(\"hours\")),\n        5: (_(\"minute\"), _(\"minutes\")),\n        6: (_(\"second\"), _(\"seconds\")),\n    }\n    now = datetime.now()\n    diff = now - time\n    second_diff = diff.seconds\n    day_diff = diff.days\n    if day_diff < 0:\n        return \"\"\n    if day_diff == 0:\n        if second_diff < 10:\n            return _(\"Just now\")\n        if second_diff < 60:\n            return text(second_diff, units_name[6])\n        if second_diff < 120:\n            return _(\"A minute ago\")\n        if second_diff < 3600:\n            return text(second_diff / 60, units_name[5])\n        if second_diff < 7200:\n            return _(\"An hour ago\")\n        if second_diff < 86400:\n            return text(second_diff / 3600, units_name[4])\n    if day_diff == 1:\n        return _(\"Yesterday\")\n    if day_diff < 7:\n        return text(day_diff, units_name[3])\n    if day_diff < 31:\n        return text(day_diff / 7, units_name[2])\n    if day_diff < 365:\n        return text(day_diff / 30, units_name[1])\n    return text(day_diff / 365, units_name[0])\n\n\n# Red 3.1 backwards compatibility\ntry:\n    from redbot.core.utils.chat_formatting import text_to_file\nexcept ImportError:\n    from io import BytesIO\n\n    log.warn(\"Outdated redbot, consider updating.\")\n    # I'm the author of this function but it was made for Cog-Creators\n    # Source: https://github.com/Cog-Creators/Red-DiscordBot/blob/V3/develop/redbot/core/utils/chat_formatting.py#L478\n    def text_to_file(\n        text: str, filename: str = \"file.txt\", *, spoiler: bool = False, encoding: str = \"utf-8\"\n    ):\n        file = BytesIO(text.encode(encoding))\n        return discord.File(file, filename, spoiler=spoiler)\n\n\nEMBED_MODLOG = lambda x: _(\"A member got a level {} warning.\").format(x)\nEMBED_USER = lambda x: _(\"The moderation team set you a level {} warning.\").format(x)\n\n\nclass CompositeMetaClass(type(commands.Cog), type(ABC)):\n    \"\"\"\n    This allows the metaclass used for proper type detection to\n    coexist with discord.py's metaclass\n\n    Credit to https://github.com/Cog-Creators/Red-DiscordBot (mod cog) for all mixin stuff.\n    \"\"\"\n\n    pass\n\n\n@cog_i18n(_)\nclass WarnSystem(SettingsMixin, AutomodMixin, BaseCog, metaclass=CompositeMetaClass):\n    \"\"\"\n    An alternative to the Red core moderation system, providing a different system of moderation\\\n    similar to Dyno.\n\n    Report a bug or ask a question: https://discord.gg/AVzjfpR\n    Full documentation and FAQ: http://laggron.red/warnsystem.html\n    \"\"\"\n\n    default_global = {\n        \"data_version\": \"0.0\"  # will be edited after config update, current version is 1.0\n    }\n    default_guild = {\n        \"delete_message\": False,  # if the [p]warn commands should delete the context message\n        \"show_mod\": False,  # if the responsible mod should be revealed to the warned user\n        \"mute_role\": None,  # the role used for mute\n        \"update_mute\": False,  # if the bot should update perms of each new text channel/category\n        \"remove_roles\": False,  # if the bot should remove all other roles on mute\n        \"respect_hierarchy\": False,  # if the bot should check if the mod is allowed by hierarchy\n        # TODO use bot settingfor respect_hierarchy ?\n        \"reinvite\": True,  # if the bot should try to send an invite to an unbanned/kicked member\n        \"log_manual\": False,  # if the bot should log manual kicks and bans\n        \"channels\": {  # modlog channels\n            \"main\": None,  # default\n            \"1\": None,\n            \"2\": None,\n            \"3\": None,\n            \"4\": None,\n            \"5\": None,\n        },\n        \"bandays\": {  # the number of days of messages to delte in case of a ban/softban\n            \"softban\": 7,\n            \"ban\": 0,\n        },\n        \"embed_description_modlog\": {  # the description of each type of warn in modlog\n            \"1\": EMBED_MODLOG(1),\n            \"2\": EMBED_MODLOG(2),\n            \"3\": EMBED_MODLOG(3),\n            \"4\": EMBED_MODLOG(4),\n            \"5\": EMBED_MODLOG(5),\n        },\n        \"embed_description_user\": {  # the description of each type of warn for the user\n            \"1\": EMBED_USER(1),\n            \"2\": EMBED_USER(2),\n            \"3\": EMBED_USER(3),\n            \"4\": EMBED_USER(4),\n            \"5\": EMBED_USER(5),\n        },\n        \"substitutions\": {},\n        \"thumbnails\": {  # image at the top right corner of an embed\n            \"1\": \"https://i.imgur.com/Bl62rGd.png\",\n            \"2\": \"https://i.imgur.com/cVtzp1M.png\",\n            \"3\": \"https://i.imgur.com/uhrYzyt.png\",\n            \"4\": \"https://i.imgur.com/uhrYzyt.png\",\n            \"5\": \"https://i.imgur.com/DfBvmic.png\",\n        },\n        \"colors\": {  # color bar of an embed\n            \"1\": 0xF4AA42,\n            \"2\": 0xD1ED35,\n            \"3\": 0xED9735,\n            \"4\": 0xED6F35,\n            \"5\": 0xFF4C4C,\n        },\n        \"url\": None,  # URL set for the title of all embeds\n        \"temporary_warns\": {},  # list of temporary warns (need to unmute/unban after some time)\n        \"automod\": {  # everything related to auto moderation\n            \"enabled\": False,\n            \"antispam\": {\n                \"enabled\": False,\n                \"max_messages\": 5,  # maximum number of messages allowed within the delay\n                \"delay\": 2,  # in seconds\n                \"delay_before_action\": 60,  # if triggered twice within this delay, take action\n                \"warn\": {  # data of the warn\n                    \"level\": 1,\n                    \"reason\": \"Sending messages too fast!\",\n                    \"time\": None,\n                },\n            },\n            \"regex\": {},  # all regex expressions\n            \"warnings\": [],  # all automatic warns\n        },\n    }\n    default_custom_member = {\"x\": []}  # cannot set a list as base group\n\n    def __init__(self, bot):\n        self.bot = bot\n\n        self.data = Config.get_conf(self, 260, force_registration=True)\n        self.data.register_global(**self.default_global)\n        self.data.register_guild(**self.default_guild)\n        try:\n            self.data.init_custom(\"MODLOGS\", 2)\n        except AttributeError:\n            pass\n        self.data.register_custom(\"MODLOGS\", **self.default_custom_member)\n\n        self.cache = MemoryCache(self.bot, self.data)\n        self.api = API(self.bot, self.data, self.cache)\n\n        self.task: asyncio.Task\n\n    __version__ = \"1.3.18\"\n    __author__ = [\"retke (El Laggron)\"]\n\n    # helpers\n    async def call_warn(self, ctx, level, member, reason=None, time=None):\n        \"\"\"No need to repeat, let's do what's common to all 5 warnings.\"\"\"\n        reason = await self.api.format_reason(ctx.guild, reason)\n        if reason and len(reason) > 2000:  # embed limits\n            await ctx.send(\n                _(\n                    \"The reason is too long for an embed.\\n\\n\"\n                    \"*Tip: You can use Github Gist to write a long text formatted in Markdown, \"\n                    \"create a new file with the extension `.md` at the end and write as if you \"\n                    \"were on Discord.\\n<https://gist.github.com/>*\"\n                    # I was paid $99999999 for this, you're welcome\n                )\n            )\n            return\n        try:\n            fail = await self.api.warn(ctx.guild, [member], ctx.author, level, reason, time)\n            if fail:\n                raise fail[0]\n        except errors.MissingPermissions as e:\n            await ctx.send(e)\n        except errors.MemberTooHigh as e:\n            await ctx.send(e)\n        except errors.LostPermissions as e:\n            await ctx.send(e)\n        except errors.SuicidePrevention as e:\n            await ctx.send(e)\n        except errors.MissingMuteRole:\n            await ctx.send(\n                _(\n                    \"You need to set up the mute role before doing this.\\n\"\n                    \"Use the `[p]warnset mute` command for this.\"\n                )\n            )\n        except errors.NotFound:\n            await ctx.send(\n                _(\n                    \"Please set up a modlog channel before warning a member.\\n\\n\"\n                    \"**With WarnSystem**\\n\"\n                    \"*Use the `[p]warnset channel` command.*\\n\\n\"\n                    \"**With Red Modlog**\\n\"\n                    \"*Load the `modlogs` cog and use the `[p]modlogset modlog` command.*\"\n                )\n            )\n        except errors.NotAllowedByHierarchy:\n            is_admin = mod.is_admin_or_superior(self.bot, member)\n            await ctx.send(\n                _(\n                    \"You are not allowed to do this, {member} is higher than you in the role \"\n                    \"hierarchy. You can only warn members which top role is lower than yours.\\n\\n\"\n                ).format(member=str(member))\n                + (\n                    _(\"You can disable this check by using the `[p]warnset hierarchy` command.\")\n                    if is_admin\n                    else \"\"\n                )\n            )\n        except discord.errors.NotFound:\n            await ctx.send(_(\"Hackban failed: No user found.\"))\n        else:\n            if ctx.channel.permissions_for(ctx.guild.me).add_reactions:\n                try:\n                    await ctx.message.add_reaction(\"\u2705\")\n                except discord.errors.NotFound:\n                    # retrigger or scheduler probably executed the command\n                    pass\n            else:\n                await ctx.send(_(\"Done.\"))\n\n    async def call_masswarn(\n        self,\n        ctx,\n        level,\n        members,\n        unavailable_members,\n        log_modlog,\n        log_dm,\n        take_action,\n        reason=None,\n        time=None,\n        confirm=False,\n    ):\n        guild = ctx.guild\n        message = None\n        i = 0\n        total_members = len(members)\n        total_unavailable_members = len(unavailable_members)\n        tick1 = \"\u2705\" if log_modlog else \"\u274c\"\n        tick2 = \"\u2705\" if log_dm else \"\u274c\"\n        tick3 = f\"{'\u2705' if take_action else '\u274c'} Take action\\n\" if level != 1 else \"\"\n        tick4 = f\"{'\u2705' if time else '\u274c'} Time: \" if (level == 2 or level == 5) else \"\"\n        tick5 = \"\u2705\" if reason else \"\u274c\"\n        time_str = (self.api._format_timedelta(time) + \"\\n\") if time else \"\"\n\n        async def update_count(count):\n            nonlocal i\n            i = count\n\n        async def update_message():\n            while True:\n                nonlocal message\n                content = _(\n                    \"Processing mass warning...\\n\"\n                    \"{i}/{total} {members} warned ({percent}%)\\n\\n\"\n                    \"{tick1} Log to the modlog\\n\"\n                    \"{tick2} Send a DM to all members\\n\"\n                    \"{tick3}\"\n                    \"{tick4} {time}\\n\"\n                    \"{tick5} Reason: {reason}\"\n                ).format(\n                    i=i,\n                    total=total_members + total_unavailable_members,\n                    members=_(\"members\") if i != 1 else _(\"member\"),\n                    percent=round((i / total_members) * 100, 2),\n                    tick1=tick1,\n                    tick2=tick2,\n                    tick3=tick3,\n                    tick4=tick4,\n                    time=time_str,\n                    tick5=tick5,\n                    reason=reason or \"Not set\",\n                )\n                if message:\n                    await message.edit(content=content)\n                else:\n                    message = await ctx.send(content)\n                await asyncio.sleep(5)\n\n        if unavailable_members and level < 5:\n            await ctx.send(_(\"You can only use `--hackban-select` with a level 5 warn.\"))\n            return\n        reason = await self.api.format_reason(ctx.guild, reason)\n        if (log_modlog or log_dm) and reason and len(reason) > 2000:  # embed limits\n            await ctx.send(\n                _(\n                    \"The reason is too long for an embed.\\n\\n\"\n                    \"*Tip: You can use Github Gist to write a long text formatted in Markdown, \"\n                    \"create a new file with the extension `.md` at the end and write as if you \"\n                    \"were on Discord.\\n<https://gist.github.com/>*\"\n                    # I was paid $99999999 for this, you're welcome\n                )\n            )\n            return\n        file = text_to_file(\n            \"\\n\".join([f\"{str(x)} ({x.id})\" for x in members + unavailable_members])\n        )\n        targets = []\n        if members:\n            targets.append(\n                _(\"{total} {members} ({percent}% of the server)\").format(\n                    total=total_members,\n                    members=_(\"members\") if total_members > 1 else _(\"member\"),\n                    percent=round((total_members / len(guild.members) * 100), 2),\n                )\n            )\n        if unavailable_members:\n            targets.append(\n                _(\"{total} {users} not in the server.\").format(\n                    total=total_unavailable_members,\n                    users=_(\"users\") if total_unavailable_members > 1 else _(\"user\"),\n                )\n            )\n        if not confirm:\n            msg = await ctx.send(\n                _(\n                    \"You're about to set a level {level} warning on {target}.\\n\\n\"\n                    \"{tick1} Log to the modlog\\n\"\n                    \"{tick2} Send a DM to all members\\n\"\n                    \"{tick3}\"\n                    \"{tick4} {time}\\n\"\n                    \"{tick5} Reason: {reason}\\n\\n{warning}\"\n                    \"Continue?\"\n                ).format(\n                    level=level,\n                    target=_(\" and \").join(targets),\n                    tick1=tick1,\n                    tick2=tick2,\n                    tick3=tick3,\n                    tick4=tick4,\n                    time=time_str,\n                    tick5=tick5,\n                    reason=reason or _(\"Not set\"),\n                    warning=_(\n                        \":warning: You're about to warn a lot of members! Avoid doing this to \"\n                        \"prevent being rate limited by Discord, especially if you enabled DMs.\\n\\n\"\n                    )\n                    if len(members) > 50 and level > 1\n                    else \"\",\n                ),\n                file=file,\n            )\n            menus.start_adding_reactions(msg, predicates.ReactionPredicate.YES_OR_NO_EMOJIS)\n            pred = predicates.ReactionPredicate.yes_or_no(msg, ctx.author)\n            try:\n                await self.bot.wait_for(\"reaction_add\", check=pred, timeout=120)\n            except AsyncTimeoutError:\n                if ctx.guild.me.guild_permissions.manage_messages:\n                    await msg.clear_reactions()\n                else:\n                    for reaction in msg.reactions():\n                        await msg.remove_reaction(reaction, ctx.guild.me)\n                return\n            if not pred.result:\n                await ctx.send(_(\"Mass warn cancelled.\"))\n                return\n            task = self.bot.loop.create_task(update_message())\n        try:\n            fails = await self.api.warn(\n                guild=guild,\n                members=members + unavailable_members,\n                author=ctx.author,\n                level=level,\n                reason=reason,\n                time=time,\n                log_modlog=log_modlog,\n                log_dm=log_dm,\n                take_action=take_action,\n                progress_tracker=update_count if not confirm else None,\n            )\n        except errors.MissingPermissions as e:\n            await ctx.send(e)\n        except errors.LostPermissions as e:\n            await ctx.send(e)\n        except errors.MissingMuteRole:\n            if not confirm:\n                await ctx.send(\n                    _(\n                        \"You need to set up the mute role before doing this.\\n\"\n                        \"Use the `[p]warnset mute` command for this.\"\n                    )\n                )\n        except errors.NotFound:\n            if not confirm:\n                await ctx.send(\n                    _(\n                        \"Please set up a modlog channel before warning a member.\\n\\n\"\n                        \"**With WarnSystem**\\n\"\n                        \"*Use the `[p]warnset channel` command.*\\n\\n\"\n                        \"**With Red Modlog**\\n\"\n                        \"*Load the `modlogs` cog and use the `[p]modlogset modlog` command.*\"\n                    )\n                )\n        else:\n            if not confirm:\n                if fails:\n                    await ctx.send(\n                        _(\"Done! {failed} {members} out of {total} couldn't be warned.\").format(\n                            failed=len(fails),\n                            members=_(\"members\") if len(fails) > 1 else _(\"member\"),\n                            total=total_members,\n                        )\n                    )\n                else:\n                    await ctx.send(\n                        _(\"Done! {total} {members} successfully warned.\").format(\n                            total=total_members,\n                            members=_(\"members\") if total_members > 1 else _(\"member\"),\n                        )\n                    )\n            else:\n                try:\n                    await ctx.message.add_reaction(\"\u2705\")\n                except discord.errors.HTTPException:\n                    pass\n        finally:\n            if not confirm:\n                task.cancel()\n            if message:\n                await message.delete()\n\n    # all warning commands\n    @commands.group(invoke_without_command=True, name=\"warn\")\n    @checks.mod_or_permissions(administrator=True)\n    @commands.guild_only()\n    async def _warn(self, ctx: commands.Context, member: discord.Member, *, reason: str = None):\n        \"\"\"\n        Take actions against a user and log it.\n        The warned user will receive a DM.\n\n        If not given, the warn level will be 1.\n        \"\"\"\n        await self.call_warn(ctx, 1, member, reason)\n\n    @_warn.command(name=\"1\", aliases=[\"simple\"])\n    @checks.mod_or_permissions(administrator=True)\n    async def warn_1(self, ctx: commands.Context, member: discord.Member, *, reason: str = None):\n        \"\"\"\n        Set a simple warning on a user.\n\n        Note: You can either call `[p]warn 1` or `[p]warn`.\n        \"\"\"\n        await self.call_warn(ctx, 1, member, reason)\n\n    @_warn.command(name=\"2\", aliases=[\"mute\"])\n    @checks.mod_or_permissions(administrator=True)\n    async def warn_2(\n        self,\n        ctx: commands.Context,\n        member: discord.Member,\n        time: Optional[TimedeltaConverter],\n        *,\n        reason: str = None,\n    ):\n        \"\"\"\n        Mute the user in all channels, including voice channels.\n\n        This mute will use a role that will automatically be created, if it was not already done.\n        Feel free to edit the role's permissions and move it in the roles hierarchy.\n\n        You can set a timed mute by providing a valid time before the reason.\n\n        Examples:\n        - `[p]warn 2 @user 30m`: 30 minutes mute\n        - `[p]warn 2 @user 5h Spam`: 5 hours mute for the reason \"Spam\"\n        - `[p]warn 2 @user Advertising`: Infinite mute for the reason \"Advertising\"\n        \"\"\"\n        await self.call_warn(ctx, 2, member, reason, time)\n\n    @_warn.command(name=\"3\", aliases=[\"kick\"])\n    @checks.mod_or_permissions(administrator=True)\n    async def warn_3(self, ctx: commands.Context, member: discord.Member, *, reason: str = None):\n        \"\"\"\n        Kick the member from the server.\n        \"\"\"\n        await self.call_warn(ctx, 3, member, reason)\n\n    @_warn.command(name=\"4\", aliases=[\"softban\"])\n    @checks.mod_or_permissions(administrator=True)\n    async def warn_4(self, ctx: commands.Context, member: discord.Member, *, reason: str = None):\n        \"\"\"\n        Softban the member from the server.\n\n        This means that the user will be banned and immediately unbanned, so it will purge their\\\n        messages in all channels.\n\n        It will delete 7 days of messages by default, but you can edit this with the\\\n        `[p]warnset bandays` command.\n        \"\"\"\n        await self.call_warn(ctx, 4, member, reason)\n\n    @_warn.command(name=\"5\", aliases=[\"ban\"], usage=\"<member> [time] <reason>\")\n    @checks.mod_or_permissions(administrator=True)\n    async def warn_5(\n        self,\n        ctx: commands.Context,\n        member: UnavailableMember,\n        time: Optional[TimedeltaConverter],\n        *,\n        reason: str = None,\n    ):\n        \"\"\"\n        Ban the member from the server.\n\n        This ban can be a normal ban, a temporary ban or a hack ban (bans a user not in the\\\n        server).\n        It won't delete messages by default, but you can edit this with the `[p]warnset bandays`\\\n        command.\n\n        If you want to perform a temporary ban, provide the time before the reason. A hack ban\\\n        needs a user ID, you can get it with the Developer mode (enable it in the Appearance tab\\\n        of the user settings, then right click on the user and select \"Copy ID\").\n\n        Examples:\n        - `[p]warn 5 @user`: Ban for no reason :c\n        - `[p]warn 5 @user 7d Insults`: 7 days ban for the reason \"Insults\"\n        - `[p]warn 5 012345678987654321 Advertising and leave`: Ban the user with the ID provided\\\n        while they're not in the server for the reason \"Advertising and leave\" (if the user shares\\\n        another server with the bot, a DM will be sent).\n        \"\"\"\n        await self.call_warn(ctx, 5, member, reason, time)\n\n    @commands.group(invoke_without_command=True)\n    @commands.guild_only()\n    @checks.mod_or_permissions(administrator=True)\n    @commands.cooldown(1, 10, commands.BucketType.guild)\n    async def masswarn(self, ctx, *selection: str):\n        \"\"\"\n        Perform a warn on multiple members at once.\n\n        To select members, you have to use UNIX-like flags to add conditions\\\n        which will be checked for each member.\n\n        Example: `[p]masswarn 3 --take-action --send-dm --has-role \"Danger\"\\\n        --joined-after \"May 2019\" --reason \"Cleaning dangerous members\"`\n\n        To get the full list of flags and how to use them, please read the\\\n        wiki: https://laggrons-dumb-cogs.readthedocs.io/\n        \"\"\"\n        if not selection:\n            await ctx.send_help()\n            return\n        try:\n            selection = await AdvancedMemberSelect().convert(ctx, selection)\n        except commands.BadArgument as e:\n            await ctx.send(e)\n            return\n        await self.call_masswarn(\n            ctx,\n            1,\n            selection.members,\n            selection.unavailable_members,\n            selection.send_modlog,\n            selection.send_dm,\n            selection.take_action,\n            selection.reason,\n            None,\n            selection.confirm,\n        )\n\n    @masswarn.command(name=\"1\", aliases=[\"simple\"])\n    @checks.mod_or_permissions(administrator=True)\n    async def masswarn_1(self, ctx, *selection: str):\n        \"\"\"\n        Perform a simple mass warning.\n        \"\"\"\n        if not selection:\n            await ctx.send_help()\n            return\n        try:\n            selection = await AdvancedMemberSelect().convert(ctx, selection)\n        except commands.BadArgument as e:\n            await ctx.send(e)\n            return\n        await self.call_masswarn(\n            ctx,\n            1,\n            selection.members,\n            selection.unavailable_members,\n            selection.send_modlog,\n            selection.send_dm,\n            selection.take_action,\n            selection.reason,\n            None,\n            selection.confirm,\n        )\n\n    @masswarn.command(name=\"2\", aliases=[\"mute\"])\n    @checks.mod_or_permissions(administrator=True)\n    async def masswarn_2(self, ctx, *selection: str):\n        \"\"\"\n        Perform a mass mute.\n\n        You can provide a duration with the `--time` flag, the format is the same as the simple\\\n        level 2 warning.\n        \"\"\"\n        if not selection:\n            await ctx.send_help()\n            return\n        try:\n            selection = await AdvancedMemberSelect().convert(ctx, selection)\n        except commands.BadArgument as e:\n            await ctx.send(e)\n            return\n        await self.call_masswarn(\n            ctx,\n            2,\n            selection.members,\n            selection.unavailable_members,\n            selection.send_modlog,\n            selection.send_dm,\n            selection.take_action,\n            selection.reason,\n            selection.time,\n            selection.confirm,\n        )\n\n    @masswarn.command(name=\"3\", aliases=[\"kick\"])\n    @checks.mod_or_permissions(administrator=True)\n    async def masswarn_3(self, ctx, *selection: str):\n        \"\"\"\n        Perform a mass kick.\n        \"\"\"\n        if not selection:\n            await ctx.send_help()\n            return\n        try:\n            selection = await AdvancedMemberSelect().convert(ctx, selection)\n        except commands.BadArgument as e:\n            await ctx.send(e)\n            return\n        await self.call_masswarn(\n            ctx,\n            3,\n            selection.members,\n            selection.unavailable_members,\n            selection.send_modlog,\n            selection.send_dm,\n            selection.take_action,\n            selection.reason,\n            None,\n            selection.confirm,\n        )\n\n    @masswarn.command(name=\"4\", aliases=[\"softban\"])\n    @checks.mod_or_permissions(administrator=True)\n    async def masswarn_4(self, ctx, *selection: str):\n        \"\"\"\n        Perform a mass softban.\n        \"\"\"\n        if not selection:\n            await ctx.send_help()\n            return\n        try:\n            selection = await AdvancedMemberSelect().convert(ctx, selection)\n        except commands.BadArgument as e:\n            await ctx.send(e)\n            return\n        await self.call_masswarn(\n            ctx,\n            4,\n            selection.members,\n            selection.unavailable_members,\n            selection.send_modlog,\n            selection.send_dm,\n            selection.take_action,\n            selection.reason,\n            None,\n            selection.confirm,\n        )\n\n    @masswarn.command(name=\"5\", aliases=[\"ban\"])\n    @checks.mod_or_permissions(administrator=True)\n    async def masswarn_5(self, ctx, *selection: str):\n        \"\"\"\n        Perform a mass ban.\n\n        You can provide a duration with the `--time` flag, the format is the same as the simple\\\n        level 5 warning.\n        \"\"\"\n        if not selection:\n            await ctx.send_help()\n            return\n        try:\n            selection = await AdvancedMemberSelect().convert(ctx, selection)\n        except commands.BadArgument as e:\n            await ctx.send(e)\n            return\n        await self.call_masswarn(\n            ctx,\n            5,\n            selection.members,\n            selection.unavailable_members,\n            selection.send_modlog,\n            selection.send_dm,\n            selection.take_action,\n            selection.reason,\n            selection.time,\n            selection.confirm,\n        )\n\n    @commands.command()\n    @commands.guild_only()\n    @commands.bot_has_permissions(add_reactions=True, manage_messages=True)\n    @commands.cooldown(1, 3, commands.BucketType.member)\n    async def warnings(\n        self, ctx: commands.Context, user: UnavailableMember = None, index: int = 0\n    ):\n        \"\"\"\n        Shows all warnings of a member.\n\n        This command can be used by everyone, but only moderators can see other's warnings.\n        Moderators can also edit or delete warnings by using the reactions.\n        \"\"\"\n        if not user:\n            await ctx.send_help()\n            return\n        if (\n            not (\n                await mod.is_mod_or_superior(self.bot, ctx.author)\n                or ctx.author.guild_permissions.kick_members\n            )\n            and user != ctx.author\n        ):\n            await ctx.send(_(\"You are not allowed to see other's warnings!\"))\n            return\n        cases = await self.api.get_all_cases(ctx.guild, user)\n        if not cases:\n            await ctx.send(_(\"That member was never warned.\"))\n            return\n        if 0 < index < len(cases):\n            await ctx.send(_(\"That case doesn't exist.\"))\n            return\n\n        total = lambda level: len([x for x in cases if x[\"level\"] == level])\n        warning_str = lambda level, plural: {\n            1: (_(\"Warning\"), _(\"Warnings\")),\n            2: (_(\"Mute\"), _(\"Mutes\")),\n            3: (_(\"Kick\"), _(\"Kicks\")),\n            4: (_(\"Softban\"), _(\"Softbans\")),\n            5: (_(\"Ban\"), _(\"Bans\")),\n        }.get(level, _(\"unknown\"))[1 if plural else 0]\n\n        embeds = []\n        msg = []\n        for i in range(6):\n            total_warns = total(i)\n            if total_warns > 0:\n                msg.append(f\"{warning_str(i, total_warns > 1)}: {total_warns}\")\n        warn_field = \"\\n\".join(msg) if len(msg) > 1 else msg[0]\n        warn_list = []\n        for case in cases[:-10:-1]:\n            level = case[\"level\"]\n            reason = str(case[\"reason\"]).splitlines()\n            if len(reason) > 1:\n                reason = reason[0] + \"...\"\n            else:\n                reason = reason[0]\n            date = pretty_date(self.api._get_datetime(case[\"time\"]))\n            text = f\"**{warning_str(level, False)}:** {reason} \u2022 *{date}*\\n\"\n            if len(\"\".join(warn_list + [text])) > 1024:  # embed limits\n                break\n            else:\n                warn_list.append(text)\n        embed = discord.Embed(description=_(\"User modlog summary.\"))\n        embed.set_author(name=f\"{user} | {user.id}\", icon_url=user.avatar_url)\n        embed.add_field(\n            name=_(\"Total number of warnings: \") + str(len(cases)), value=warn_field, inline=False\n        )\n        embed.add_field(\n            name=_(\"{len} last warnings\").format(len=len(warn_list))\n            if len(warn_list) > 1\n            else _(\"Last warning\"),\n            value=\"\".join(warn_list),\n            inline=False,\n        )\n        embed.set_footer(text=_(\"Click on the reactions to scroll through the warnings\"))\n        embed.colour = user.top_role.colour\n        embeds.append(embed)\n\n        for i, case in enumerate(cases):\n            level = case[\"level\"]\n            moderator = ctx.guild.get_member(case[\"author\"])\n            moderator = \"ID: \" + str(case[\"author\"]) if not moderator else moderator.mention\n\n            time = self.api._get_datetime(case[\"time\"])\n            embed = discord.Embed(\n                description=_(\"Case #{number} informations\").format(number=i + 1)\n            )\n            embed.set_author(name=f\"{user} | {user.id}\", icon_url=user.avatar_url)\n            embed.add_field(\n                name=_(\"Level\"), value=f\"{warning_str(level, False)} ({level})\", inline=True\n            )\n            embed.add_field(name=_(\"Moderator\"), value=moderator, inline=True)\n            if case[\"duration\"]:\n                duration = self.api._get_timedelta(case[\"duration\"])\n                embed.add_field(\n                    name=_(\"Duration\"),\n                    value=_(\"{duration}\\n(Until {date})\").format(\n                        duration=self.api._format_timedelta(duration),\n                        date=self.api._format_datetime(time + duration),\n                    ),\n                )\n            embed.add_field(name=_(\"Reason\"), value=case[\"reason\"], inline=False),\n            embed.timestamp = time\n            embed.colour = await self.data.guild(ctx.guild).colors.get_raw(level)\n            embeds.append(embed)\n\n        controls = {\"\u2b05\": menus.prev_page, \"\u274c\": menus.close_menu, \"\u27a1\": menus.next_page}\n        if await mod.is_mod_or_superior(self.bot, ctx.author):\n            controls.update({\"\u270f\": self._edit_case, \"\ud83d\uddd1\": self._delete_case})\n\n        await menus.menu(\n            ctx=ctx, pages=embeds, controls=controls, message=None, page=index, timeout=60\n        )\n\n    async def _edit_case(\n        self,\n        ctx: commands.Context,\n        pages: list,\n        controls: dict,\n        message: discord.Message,\n        page: int,\n        timeout: float,\n        emoji: str,\n    ):\n        \"\"\"\n        Edit a case, this is linked to the warnings menu system.\n        \"\"\"\n\n        async def edit_message(channel_id: int, message_id: int, new_reason: str):\n            channel: discord.TextChannel = guild.get_channel(channel_id)\n            if channel is None:\n                log.warn(\n                    f\"[Guild {guild.id}] Failed to edit modlog message. \"\n                    f\"Channel {channel_id} not found.\"\n                )\n                return False\n            try:\n                message: discord.Message = await channel.fetch_message(message_id)\n            except discord.errors.NotFound:\n                log.warn(\n                    f\"[Guild {guild.id}] Failed to edit modlog message. \"\n                    f\"Message {message_id} in channel {channel.id} not found.\"\n                )\n                return False\n            except discord.errors.Forbidden:\n                log.warn(\n                    f\"[Guild {guild.id}] Failed to edit modlog message. \"\n                    f\"No permissions to fetch messages in channel {channel.id}.\"\n                )\n                return False\n            except discord.errors.HTTPException as e:\n                log.error(\n                    f\"[Guild {guild.id}] Failed to edit modlog message. API exception raised.\",\n                    exc_info=e,\n                )\n                return False\n            try:\n                embed: discord.Embed = message.embeds[0]\n                embed.set_field_at(\n                    len(embed.fields) - 2, name=_(\"Reason\"), value=new_reason, inline=False\n                )\n            except IndexError as e:\n                log.error(\n                    f\"[Guild {guild.id}] Failed to edit modlog message. Embed is malformed.\",\n                    exc_info=e,\n                )\n                return False\n            try:\n                await message.edit(embed=embed)\n            except discord.errors.HTTPException as e:\n                log.error(\n                    f\"[Guild {guild.id}] Failed to edit modlog message. \"\n                    \"Unknown error when attempting message edition.\",\n                    exc_info=e,\n                )\n                return False\n            return True\n\n        guild = ctx.guild\n        if page == 0:\n            # first page, no case to edit\n            await message.remove_reaction(emoji, ctx.author)\n            return await menus.menu(\n                ctx, pages, controls, message=message, page=page, timeout=timeout\n            )\n        await message.clear_reactions()\n        try:\n            old_embed = message.embeds[0]\n        except IndexError:\n            return\n        embed = discord.Embed()\n        member_id = int(\n            re.match(r\"(?:.*#[0-9]{4})(?: \\| )([0-9]{15,21})\", old_embed.author.name).group(1)\n        )\n        member = self.bot.get_user(member_id) or UnavailableMember(\n            self.bot, guild._state, member_id\n        )\n        embed.clear_fields()\n        embed.description = _(\n            \"Case #{number} edition.\\n\\n**Please type the new reason to set**\"\n        ).format(number=page)\n        embed.set_footer(text=_(\"You have two minutes to type your text in the chat.\"))\n        case = (await self.data.custom(\"MODLOGS\", guild.id, member.id).x())[page - 1]\n        await message.edit(embed=embed)\n        try:\n            response = await self.bot.wait_for(\n                \"message\", check=predicates.MessagePredicate.same_context(ctx), timeout=120\n            )\n        except AsyncTimeoutError:\n            await message.delete()\n            return\n        case = (await self.data.custom(\"MODLOGS\", guild.id, member.id).x())[page - 1]\n        new_reason = await self.api.format_reason(guild, response.content)\n        embed.description = _(\"Case #{number} edition.\").format(number=page)\n        embed.add_field(name=_(\"Old reason\"), value=case[\"reason\"], inline=False)\n        embed.add_field(name=_(\"New reason\"), value=new_reason, inline=False)\n        embed.set_footer(text=_(\"Click on \u2705 to confirm the changes.\"))\n        await message.edit(embed=embed)\n        menus.start_adding_reactions(message, predicates.ReactionPredicate.YES_OR_NO_EMOJIS)\n        pred = predicates.ReactionPredicate.yes_or_no(message, ctx.author)\n        try:\n            await ctx.bot.wait_for(\"reaction_add\", check=pred, timeout=30)\n        except AsyncTimeoutError:\n            await message.clear_reactions()\n            await message.edit(content=_(\"Question timed out.\"), embed=None)\n            return\n        if pred.result:\n            async with self.data.custom(\"MODLOGS\", guild.id, member.id).x() as logs:\n                logs[page - 1][\"reason\"] = new_reason\n                try:\n                    channel_id, message_id = logs[page - 1][\"modlog_message\"].values()\n                except KeyError:\n                    result = None\n                else:\n                    result = await edit_message(channel_id, message_id, new_reason)\n            await message.clear_reactions()\n            text = _(\"The reason was successfully edited!\\n\")\n            if result is False:\n                text += _(\"*The modlog message couldn't be edited. Check your logs for details.*\")\n            await message.edit(content=text, embed=None)\n        else:\n            await message.clear_reactions()\n            await message.edit(content=_(\"The reason was not edited.\"), embed=None)\n\n    async def _delete_case(\n        self,\n        ctx: commands.Context,\n        pages: list,\n        controls: dict,\n        message: discord.Message,\n        page: int,\n        timeout: float,\n        emoji: str,\n    ):\n        \"\"\"\n        Remove a case, this is linked to the warning system.\n        \"\"\"\n\n        async def delete_message(channel_id: int, message_id: int):\n            channel: discord.TextChannel = guild.get_channel(channel_id)\n            if channel is None:\n                log.warn(\n                    f\"[Guild {guild.id}] Failed to delete modlog message. \"\n                    f\"Channel {channel_id} not found.\"\n                )\n                return False\n            try:\n                message: discord.Message = await channel.fetch_message(message_id)\n            except discord.errors.NotFound:\n                log.warn(\n                    f\"[Guild {guild.id}] Failed to delete modlog message. \"\n                    f\"Message {message_id} in channel {channel.id} not found.\"\n                )\n                return False\n            except discord.errors.Forbidden:\n                log.warn(\n                    f\"[Guild {guild.id}] Failed to delete modlog message. \"\n                    f\"No permissions to fetch messages in channel {channel.id}.\"\n                )\n                return False\n            except discord.errors.HTTPException as e:\n                log.error(\n                    f\"[Guild {guild.id}] Failed to delete modlog message. API exception raised.\",\n                    exc_info=e,\n                )\n                return False\n            try:\n                await message.delete()\n            except discord.errors.HTTPException as e:\n                log.error(\n                    f\"[Guild {guild.id}] Failed to delete modlog message. \"\n                    \"Unknown error when attempting message deletion.\",\n                    exc_info=e,\n                )\n                return False\n            return True\n\n        guild = ctx.guild\n        await message.clear_reactions()\n        try:\n            old_embed = message.embeds[0]\n        except IndexError:\n            return\n        embed = discord.Embed()\n        member_id = int(\n            re.match(r\"(?:.*#[0-9]{4})(?: \\| )([0-9]{15,21})\", old_embed.author.name).group(1)\n        )\n        member = self.bot.get_user(member_id) or UnavailableMember(\n            self.bot, guild._state, member_id\n        )\n        if page == 0:\n            # no warning specified, mod wants to completly clear the member\n            embed.colour = 0xEE2B2B\n            embed.description = _(\n                \"Member {member}'s clearance. By selecting \u274c on the user modlog summary, you can \"\n                \"remove all warnings given to {member}. __All levels and notes are affected.__\\n\"\n                \"**Click on the reaction to confirm the removal of the entire user's modlog. \"\n                \"This cannot be undone.**\"\n            ).format(member=str(member))\n        else:\n            level = int(re.match(r\".*\\(([0-9]*)\\)\", old_embed.fields[0].value).group(1))\n            can_unmute = False\n            add_roles = False\n            if level == 2:\n                mute_role = guild.get_role(await self.cache.get_mute_role(guild))\n                member = guild.get_member(member.id)\n                if member:\n                    if mute_role and mute_role in member.roles:\n                        can_unmute = True\n                    add_roles = await self.data.guild(guild).remove_roles()\n            description = _(\n                \"Case #{number} deletion.\\n**Click on the reaction to confirm your action.**\"\n            ).format(number=page)\n            if can_unmute or add_roles:\n                description += _(\"\\nNote: Deleting the case will also do the following:\")\n                if can_unmute:\n                    description += _(\"\\n- unmute the member\")\n                if add_roles:\n                    description += _(\"\\n- add all roles back to the member\")\n            embed.description = description\n        await message.edit(embed=embed)\n        menus.start_adding_reactions(message, predicates.ReactionPredicate.YES_OR_NO_EMOJIS)\n        pred = predicates.ReactionPredicate.yes_or_no(message, ctx.author)\n        try:\n            await ctx.bot.wait_for(\"reaction_add\", check=pred, timeout=30)\n        except AsyncTimeoutError:\n            await message.clear_reactions()\n            await message.edit(content=_(\"Question timed out.\"), embed=None)\n            return\n        if not pred.result:\n            await message.clear_reactions()\n            await message.edit(content=_(\"Nothing was removed.\"), embed=None)\n            return\n        if page == 0:\n            # removing entire modlog\n            await self.data.custom(\"MODLOGS\", guild.id, member.id).x.set([])\n            log.debug(f\"[Guild {guild.id}] Cleared modlog of member {member} (ID: {member.id}).\")\n            await message.clear_reactions()\n            await message.edit(content=_(\"User modlog cleared.\"), embed=None)\n            return\n        async with self.data.custom(\"MODLOGS\", guild.id, member.id).x() as logs:\n            try:\n                roles = logs[page - 1][\"roles\"]\n            except KeyError:\n                roles = []\n            try:\n                channel_id, message_id = logs[page - 1][\"modlog_message\"].values()\n            except KeyError:\n                result = None\n            else:\n                result = await delete_message(channel_id, message_id)\n            logs.remove(logs[page - 1])\n        log.debug(\n            f\"[Guild {guild.id}] Removed case #{page} from member {member} (ID: {member.id}).\"\n        )\n        await message.clear_reactions()\n        if can_unmute:\n            await member.remove_roles(\n                mute_role,\n                reason=_(\"Warning deleted by {author}\").format(\n                    author=f\"{str(ctx.author)} (ID: {ctx.author.id})\"\n                ),\n            )\n        if roles:\n            roles = [guild.get_role(x) for x in roles]\n            await member.add_roles(*roles, reason=_(\"Adding removed roles back after unmute.\"))\n        text = _(\"The case was successfully deleted!\")\n        if result is False:\n            text += _(\"*The modlog message couldn't be deleted. Check your logs for details.*\")\n        await message.edit(content=_(\"The case was successfully deleted!\"), embed=None)\n\n    @commands.command()\n    @checks.mod_or_permissions(kick_members=True)\n    @commands.cooldown(1, 10, commands.BucketType.channel)\n    async def warnlist(self, ctx: commands.Context, short: bool = False):\n        \"\"\"\n        List the latest warnings issued on the server.\n        \"\"\"\n        guild = ctx.guild\n        full_text = \"\"\n        warns = await self.api.get_all_cases(guild)\n        if not warns:\n            await ctx.send(_(\"No warnings have been issued in this server yet.\"))\n            return\n        for i, warn in enumerate(warns, start=1):\n            text = _(\n                \"--- Case {number} ---\\n\"\n                \"Member:    {member} (ID: {member.id})\\n\"\n                \"Level:     {level}\\n\"\n                \"Reason:    {reason}\\n\"\n                \"Author:    {author} (ID: {author.id})\\n\"\n                \"Date:      {time}\\n\"\n            ).format(number=i, **warn)\n            if warn[\"duration\"]:\n                duration = self.api._get_timedelta(warn[\"duration\"])\n                text += _(\"Duration:  {duration}\\nUntil:     {until}\\n\").format(\n                    duration=self.api._format_timedelta(duration),\n                    until=self.api._format_datetime(warn[\"time\"] + duration),\n                )\n            text += \"\\n\\n\"\n            full_text = text + full_text\n        pages = [\n            x for x in pagify(full_text, delims=[\"\\n\\n\", \"\\n\"], priority=True, page_length=1900)\n        ]\n        total_pages = len(pages)\n        total_warns = len(warns)\n        pages = [\n            f\"```yml\\n{x}```\\n\"\n            + _(\"{total} warnings. Page {i}/{pages}\").format(\n                total=total_warns, i=i, pages=total_pages\n            )\n            for i, x in enumerate(pages, start=1)\n        ]\n        await menus.menu(ctx=ctx, pages=pages, controls=menus.DEFAULT_CONTROLS, timeout=60)\n\n    @commands.command()\n    @checks.mod_or_permissions(manage_roles=True)\n    async def wsunmute(self, ctx: commands.Context, member: discord.Member):\n        \"\"\"\n        Unmute a member muted with WarnSystem.\n\n        If the member's roles were removed, they will be granted back.\n\n        *wsunmute = WarnSystem unmute. Feel free to add an alias.*\n        \"\"\"\n        guild = ctx.guild\n        mute_role = guild.get_role(await self.cache.get_mute_role(guild))\n        if not mute_role:\n            await ctx.send(_(\"The mute role is not set or lost.\"))\n            return\n        if mute_role not in member.roles:\n            await ctx.send(_(\"That member isn't muted.\"))\n            return\n        case = await self.cache.get_temp_action(guild, member)\n        if case and case[\"level\"] == 2:\n            roles = case[\"roles\"]\n            await self.cache.remove_temp_action(guild, member)\n        else:\n            cases = await self.api.get_all_cases(guild, member)\n            roles = []\n            for data in cases[::-1]:\n                if data[\"level\"] == 2:\n                    try:\n                        roles = data[\"roles\"]\n                    except KeyError:\n                        continue\n                    break\n        await member.remove_roles(\n            mute_role,\n            reason=_(\"[WarnSystem] Member unmuted by {author} (ID: {author.id})\").format(\n                author=ctx.author\n            ),\n        )\n        roles = list(filter(None, [guild.get_role(x) for x in roles]))\n        if not roles:\n            await ctx.send(_(\"Member unmuted.\"))\n            return\n        await ctx.send(\n            _(\"Member unmuted. {len_roles} roles to reassign...\").format(len_roles=len(roles))\n        )\n        async with ctx.typing():\n            fails = []\n            for role in roles:\n                try:\n                    await member.add_roles(role)\n                except discord.errors.HTTPException as e:\n                    log.error(\n                        f\"Failed to reapply role {role} ({role.id}) on guild {guild} \"\n                        f\"({guild.id}) after unmute.\",\n                        exc_info=e,\n                    )\n                    fails.append(role)\n        text = _(\"Done.\")\n        if fails:\n            text.append(_(\"\\n\\nFailed to add {fails}/{len_roles} roles back:\\n\"))\n            for role in fails:\n                text.append(f\"- {role.name}\\n\")\n        for page in pagify(text):\n            await ctx.send(page)\n\n    @commands.command()\n    @checks.mod_or_permissions(ban_members=True)\n    async def wsunban(self, ctx: commands.Context, member: UnavailableMember):\n        \"\"\"\n        Unban a member banned with WarnSystem.\n\n        *wsunban = WarnSystem unban. Feel free to add an alias.*\n        \"\"\"\n        guild = ctx.guild\n        bans = await guild.bans()\n        if member.id not in [x.user.id for x in bans]:\n            await ctx.send(_(\"That user is not banned.\"))\n            return\n        try:\n            await guild.unban(member)\n        except discord.errors.HTTPException as e:\n            await ctx.send(_(\"Failed to unban the given member. Check your logs for details.\"))\n            log.error(f\"Can't unban user {member.id} from guild {guild} ({guild.id})\", exc_info=e)\n            return\n        case = await self.cache.get_temp_action(guild, member)\n        if case and case[\"level\"] == 5:\n            await self.cache.remove_temp_action(guild, member)\n        await ctx.send(_(\"User unbanned.\"))\n\n    @commands.command(hidden=True)\n    async def warnsysteminfo(self, ctx):\n        \"\"\"\n        Get informations about the cog.\n        \"\"\"\n        await ctx.send(\n            _(\n                \"Laggron's Dumb Cogs V3 - warnsystem\\n\\n\"\n                \"Version: {0.__version__}\\n\"\n                \"Author: {0.__author__[0]}\\n\\n\"\n                \"Github repository: https://github.com/retke/Laggrons-Dumb-Cogs/tree/v3\\n\"\n                \"Discord server: https://discord.gg/AVzjfpR\\n\"\n                \"Documentation: http://laggrons-dumb-cogs.readthedocs.io/\\n\"\n                \"Help translating the cog: https://crowdin.com/project/laggrons-dumb-cogs/\\n\\n\"\n                \"Support my work on Patreon: https://www.patreon.com/retke\"\n            ).format(self)\n        )\n\n    @listener()\n    async def on_member_unban(self, guild: discord.Guild, user: discord.User):\n        # if a member gets unbanned, we check if he was temp banned with warnsystem\n        # if it was, we remove the case so it won't unban him a second time\n        warns = await self.cache.get_temp_action(guild)\n        to_remove = []  # there can be multiple temp bans, let's not question the moderators\n        for member, data in warns.items():\n            if data[\"level\"] == 2 or int(member) != user.id:\n                continue\n            to_remove.append(UnavailableMember(self.bot, guild._state, member))\n        if to_remove:\n            await self.cache.bulk_remove_temp_action(guild, to_remove)\n            log.info(\n                f\"[Guild {guild.id}] The temporary ban of user {user} (ID: {user.id}) \"\n                \"was cancelled due to his manual unban.\"\n            )\n\n    @listener()\n    async def on_member_update(self, before: discord.Member, after: discord.Member):\n        guild = after.guild\n        mute_role = guild.get_role(await self.cache.get_mute_role(guild))\n        if not mute_role:\n            return\n        if not (mute_role in before.roles and mute_role not in after.roles):\n            return\n        if after.id in self.cache.temp_actions:\n            await self.cache.remove_temp_action(guild, after)\n            log.info(\n                f\"[Guild {guild.id}] The temporary mute of member {after} (ID: {after.id}) \"\n                \"was ended due to a manual unmute (role removed).\"\n            )\n\n    @listener()\n    async def on_guild_channel_create(self, channel: discord.abc.GuildChannel):\n        guild = channel.guild\n        if isinstance(channel, discord.VoiceChannel):\n            return\n        if not await self.data.guild(guild).update_mute():\n            return\n        role = guild.get_role(await self.cache.get_mute_role(guild))\n        if not role:\n            return\n        try:\n            await channel.set_permissions(\n                role,\n                send_messages=False,\n                add_reactions=False,\n                reason=_(\n                    \"Updating channel settings so the mute role will work here. \"\n                    \"Disable the auto-update with [p]warnset autoupdate\"\n                ),\n            )\n        except discord.errors.Forbidden:\n            log.warn(\n                f\"[Guild {guild.id}] Couldn't update permissions of new channel {channel.name} \"\n                f\"(ID: {channel.id}) due to a permission error.\"\n            )\n        except discord.errors.HTTPException as e:\n            log.error(\n                f\"[Guild {guild.id}] Couldn't update permissions of new channel {channel.name} \"\n                f\"(ID: {channel.id}) due to an unknown error.\",\n                exc_info=e,\n            )\n\n    @listener()\n    async def on_member_ban(self, guild: discord.Guild, member: discord.Member):\n        # most of this code is from Cog-Creators, modlog cog\n        # https://github.com/Cog-Creators/Red-DiscordBot/blob/bc21f779762ec9f460aecae525fdcd634f6c2d85/redbot/core/modlog.py#L68\n        if not guild.me.guild_permissions.view_audit_log:\n            return\n        if not await self.data.guild(guild).log_manual():\n            return\n        # check for that before doing anything else, means WarnSystem isn't setup\n        try:\n            await self.api.get_modlog_channel(guild, 5)\n        except errors.NotFound:\n            return\n        when = datetime.utcnow()\n        before = when + timedelta(minutes=1)\n        after = when - timedelta(minutes=1)\n        await asyncio.sleep(10)  # prevent small delays from causing a 5 minute delay on entry\n        attempts = 0\n        # wait up to an hour to find a matching case\n        while attempts < 12:\n            attempts += 1\n            try:\n                entry = await guild.audit_logs(\n                    action=discord.AuditLogAction.ban, before=before, after=after\n                ).find(lambda e: e.target.id == member.id and after < e.created_at < before)\n            except discord.Forbidden:\n                break\n            except discord.HTTPException:\n                pass\n            else:\n                if entry:\n                    if entry.user.id != guild.me.id:\n                        # Don't create modlog entires for the bot's own bans, cogs do this.\n                        mod, reason, date = entry.user, entry.reason, entry.created_at\n                        try:\n                            await self.api.warn(\n                                guild,\n                                [member],\n                                mod,\n                                5,\n                                reason,\n                                date=date,\n                                log_dm=False,\n                                take_action=False,\n                            )\n                        except Exception as e:\n                            log.error(\n                                f\"[Guild {guild.id}] Failed to create a case based on manual ban. \"\n                                f\"Member: {member} ({member.id}). Author: {mod} ({mod.id}). \"\n                                f\"Reason: {reason}\",\n                                exc_info=e,\n                            )\n                    return\n            await asyncio.sleep(300)\n\n    @listener()\n    async def on_command_error(self, ctx, error):\n        if not isinstance(error, commands.CommandInvokeError):\n            return\n        if not ctx.command.cog_name == self.__class__.__name__:\n            # That error doesn't belong to the cog\n            return\n        if isinstance(error, commands.MissingPermissions):\n            await ctx.send(\n                _(\n                    \"I need the `Add reactions` and `Manage messages` in the \"\n                    \"current channel if you want to use this command.\"\n                )\n            )\n            return\n        with DisabledConsoleOutput(log):\n            log.error(\n                f\"Exception in command '{ctx.command.qualified_name}'.\\n\\n\",\n                exc_info=error.original,\n            )\n\n    # correctly unload the cog\n    def __unload(self):\n        self.cog_unload()\n\n    def cog_unload(self):\n        log.debug(\"Unloading cog...\")\n\n        # remove all handlers from the logger, this prevents adding\n        # multiple times the same handler if the cog gets reloaded\n        close_logger(log)\n\n        # stop checking for unmute and unban\n        self.task.cancel()\n        self.api.disable_automod()\n"], "filenames": ["warnsystem/api.py", "warnsystem/warnsystem.py"], "buggy_code_start_loc": [29, 227], "buggy_code_end_loc": [628, 228], "fixing_code_start_loc": [30, 227], "fixing_code_end_loc": [661, 228], "type": "CWE-94", "message": "WarnSystem is a cog (plugin) for the Red discord bot. A vulnerability has been found in the code that allows any user to access sensible informations by setting up a specific template which is not properly sanitized. The problem has been patched in version 1.3.18. Users should update and type `!warnsysteminfo` to check that their version is 1.3.18 or above. As a workaround users may unload the WarnSystem cog or disable the `!warnset description` command globally.", "other": {"cve": {"id": "CVE-2021-29502", "sourceIdentifier": "security-advisories@github.com", "published": "2021-05-10T18:15:07.833", "lastModified": "2022-10-25T19:55:48.623", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "WarnSystem is a cog (plugin) for the Red discord bot. A vulnerability has been found in the code that allows any user to access sensible informations by setting up a specific template which is not properly sanitized. The problem has been patched in version 1.3.18. Users should update and type `!warnsysteminfo` to check that their version is 1.3.18 or above. As a workaround users may unload the WarnSystem cog or disable the `!warnset description` command globally."}, {"lang": "es", "value": "WarnSystem es un engranaje (plugin) para el bot Red discord.&#xa0;Se ha encontrado una vulnerabilidad en el c\u00f3digo que permite a cualquier usuario acceder a informaci\u00f3n confidencial al configurar una plantilla espec\u00edfica que no est\u00e1 debidamente saneada.&#xa0;El problema ha sido parcheado en la versi\u00f3n 1.3.18.&#xa0;Los usuarios deben actualizar y escribir \"!warnsysteminfo\" para comprobar que su versi\u00f3n sea 1.3.18 o superior.&#xa0;Como soluci\u00f3n alternativa, los usuarios pueden descargar el engranaje WarnSystem o deshabilitar el comando \"!warnset description\" globalmente"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.1, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-94"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-74"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:warnsystem_project:warnsystem:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.3.18", "matchCriteriaId": "91C552DD-5209-49FB-90C2-89E9A207B802"}]}]}], "references": [{"url": "https://github.com/retke/Laggrons-Dumb-Cogs/commit/c79dd2cc879989cf2018e76ba2aad0baef3b4ec8", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/retke/Laggrons-Dumb-Cogs/security/advisories/GHSA-834g-67vv-m9wq", "source": "security-advisories@github.com", "tags": ["Mitigation", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/retke/Laggrons-Dumb-Cogs/commit/c79dd2cc879989cf2018e76ba2aad0baef3b4ec8"}}