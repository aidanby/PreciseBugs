{"buggy_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2023\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISOBMFF reader filter\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n\n#include \"isoffin.h\"\n\n#if !defined(GPAC_DISABLE_ISOM) && !defined(GPAC_DISABLE_MP4DMX)\n\n#include <gpac/network.h>\n#include <gpac/avparse.h>\n\nGF_Err gf_isom_set_sample_alloc(GF_ISOFile *the_file, u32 trackNumber, \tu8 *(*sample_realloc)(u32 size, void *cbk), void *udta);\n\nvoid isor_reset_reader(ISOMChannel *ch)\n{\n\tch->last_state = GF_OK;\n\tisor_reader_release_sample(ch);\n\n\tif (ch->static_sample) {\n\t\tch->static_sample->dataLength = ch->static_sample->alloc_size;\n\t\tgf_isom_sample_del(&ch->static_sample);\n\t}\n\tch->sample = NULL;\n\tch->sample_num = 0;\n\tch->speed = 1.0;\n\tch->start = ch->end = 0;\n\tch->to_init = 1;\n\tch->playing = 0;\n\tch->nb_empty_retry = 0;\n\tif (ch->sai_buffer) gf_free(ch->sai_buffer);\n\tch->sai_buffer = NULL;\n\tch->sai_alloc_size = 0;\n\tch->dts = ch->cts = 0;\n\tch->seek_flag = 0;\n}\n\nvoid isor_check_producer_ref_time(ISOMReader *read)\n{\n\tGF_ISOTrackID trackID;\n\tu64 ntp;\n\tu64 timestamp;\n\n\tif (gf_sys_is_test_mode()) {\n\t\treturn;\n\t}\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (gf_isom_get_last_producer_time_box(read->mov, &trackID, &ntp, &timestamp, GF_TRUE)) {\n#if !defined(_WIN32_WCE) && !defined(GPAC_DISABLE_LOG)\n\n\t\tif (gf_log_tool_level_on(GF_LOG_DASH, GF_LOG_DEBUG)) {\n\t\t\ttime_t secs;\n\t\t\tstruct tm t;\n\n\t\t\ts32 diff = gf_net_get_ntp_diff_ms(ntp);\n\n\t\t\tsecs = (ntp>>32) - GF_NTP_SEC_1900_TO_1970;\n\t\t\tt = *gf_gmtime(&secs);\n\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, (\"[IsoMedia] TrackID %d: Timestamp \"LLU\" matches sender NTP time %d-%02d-%02dT%02d:%02d:%02dZ - NTP clock diff (local - remote): %d ms\\n\", trackID, timestamp, 1900+t.tm_year, t.tm_mon+1, t.tm_mday, t.tm_hour, t.tm_min, t.tm_sec, diff));\n\t\t}\n#endif\n\t\tread->last_sender_ntp = ntp;\n\t\tread->cts_for_last_sender_ntp = timestamp;\n\t\tread->ntp_at_last_sender_ntp = gf_net_get_ntp_ts();\n\t}\n#endif\n}\n\n\nstatic void init_reader(ISOMChannel *ch)\n{\n\tu32 sample_desc_index=0;\n\n\tch->au_seq_num = 1;\n\n\tassert(ch->sample==NULL);\n\tif (!ch->static_sample) {\n\t\tch->static_sample = gf_isom_sample_new();\n\t}\n\n\tif (ch->streamType==GF_STREAM_OCR) {\n\t\tassert(!ch->sample);\n\t\tch->sample = gf_isom_sample_new();\n\t\tch->sample->IsRAP = RAP;\n\t\tch->sample->DTS = ch->start;\n\t\tch->last_state=GF_OK;\n\t} else if (ch->sample_num) {\n\t\tch->sample = gf_isom_get_sample_ex(ch->owner->mov, ch->track, ch->sample_num, &sample_desc_index, ch->static_sample, &ch->sample_data_offset);\n\t\tch->disable_seek = 1;\n\t\tch->au_seq_num = ch->sample_num;\n\t} else {\n\t\t//if seek is disabled, get the next closest sample for this time; otherwise, get the previous RAP sample for this time\n\t\tu32 mode = ch->disable_seek ? GF_ISOM_SEARCH_BACKWARD : GF_ISOM_SEARCH_SYNC_BACKWARD;\n\n\t\t/*take care of seeking out of the track range*/\n\t\tif (!ch->owner->frag_type && (ch->duration<=ch->start)) {\n\t\t\tch->last_state = gf_isom_get_sample_for_movie_time(ch->owner->mov, ch->track, ch->duration-1, &sample_desc_index, mode, &ch->static_sample, &ch->sample_num, &ch->sample_data_offset);\n\t\t} else if (ch->start || ch->has_edit_list) {\n\t\t\tch->last_state = gf_isom_get_sample_for_movie_time(ch->owner->mov, ch->track, ch->start, &sample_desc_index, mode, &ch->static_sample, &ch->sample_num, &ch->sample_data_offset);\n\t\t} else {\n\t\t\tch->sample_num = 1;\n\t\t\tif (ch->owner->nodata) {\n\t\t\t\tch->sample = gf_isom_get_sample_info_ex(ch->owner->mov, ch->track, ch->sample_num, &sample_desc_index, &ch->sample_data_offset, ch->static_sample);\n\t\t\t} else {\n\t\t\t\tch->sample = gf_isom_get_sample_ex(ch->owner->mov, ch->track, ch->sample_num, &sample_desc_index, ch->static_sample, &ch->sample_data_offset);\n\t\t\t}\n\t\t\tif (!ch->sample) ch->last_state = GF_EOS;\n\t\t}\n\t\tif (ch->last_state) {\n\t\t\tch->sample = NULL;\n\t\t\tch->last_state = GF_OK;\n\t\t} else {\n\t\t\tch->sample = ch->static_sample;\n\t\t}\n\n\t\tif (ch->has_rap && ch->has_edit_list) {\n\t\t\tch->edit_sync_frame = ch->sample_num;\n\t\t}\n\n\t\tif (ch->sample && !ch->sample->data && ch->owner->frag_type && !ch->has_edit_list) {\n\t\t\tch->static_sample->alloc_size = 0;\n\t\t\tch->sample = NULL;\n\t\t\tch->sample_num = 1;\n\t\t\tch->sample = gf_isom_get_sample_ex(ch->owner->mov, ch->track, ch->sample_num, &sample_desc_index, ch->static_sample, &ch->sample_data_offset);\n\t\t}\n\t}\n\n\n\t/*no sample means we're not in the track range - stop*/\n\tif (!ch->sample) {\n\t\t/*incomplete file - check if we're still downloading or not*/\n\t\tif (gf_isom_get_missing_bytes(ch->owner->mov, ch->track)) {\n\t\t\tif (!ch->owner->input_loaded) {\n\t\t\t\tch->last_state = GF_OK;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tch->last_state = GF_ISOM_INCOMPLETE_FILE;\n\t\t} else if (ch->sample_num) {\n\t\t\tch->last_state = (ch->owner->frag_type==1) ? GF_OK : GF_EOS;\n\t\t\tch->to_init = 0;\n\t\t}\n\t\treturn;\n\t}\n\n\tch->sample_time = ch->sample->DTS;\n\n\tch->to_init = 0;\n\n\tch->seek_flag = 0;\n\tif (ch->disable_seek) {\n\t\tch->dts = ch->sample->DTS;\n\t\tch->cts = ch->sample->DTS + ch->sample->CTS_Offset;\n\t\tch->start = 0;\n\t} else {\n\t\ts64 cts;\n\t\tch->dts = ch->start;\n\t\tch->cts = ch->start;\n\n\t\tcts = ch->sample->DTS + ch->sample->CTS_Offset;\n\t\tif (ch->ts_offset<0)\n\t\t\tcts += ch->ts_offset;\n\n\t\t//TODO - we need to notify scene decoder how many secs elapsed between RAP and seek point\n\t\tif (ch->cts != cts) {\n\t\t\tch->seek_flag = 1;\n\t\t}\n\t}\n\tif (!sample_desc_index) sample_desc_index = 1;\n\tch->last_sample_desc_index = sample_desc_index;\n\tch->owner->no_order_check = ch->speed < 0 ? GF_TRUE : GF_FALSE;\n}\n\n\nstatic void isor_update_cenc_info(ISOMChannel *ch, Bool for_item)\n{\n\tGF_Err e;\n\tBool Is_Encrypted;\n\tu32 out_size;\n\tu8 crypt_byte_block, skip_byte_block;\n\tu8 piff_info[20];\n\tu8 *key_info = NULL;\n\tu32 key_info_size = 0;\n\tu8 item_mkey = 0;\n\n\t//this will be skipped anyways, don't fectch ...\n\tif (ch->owner->stsd && (ch->last_sample_desc_index != ch->owner->stsd) && ch->sample) {\n\t\treturn;\n\t}\n\n\n\tout_size = ch->sai_alloc_size;\n\tif (for_item) {\n\t\tu32 aux_info_param=0;\n\t\te = gf_isom_extract_meta_item_get_cenc_info(ch->owner->mov, GF_TRUE, 0, ch->item_id, &Is_Encrypted, &skip_byte_block, &crypt_byte_block, (const u8 **) &key_info, &key_info_size, &aux_info_param, &ch->sai_buffer, &out_size, &ch->sai_alloc_size);\n\n\t\t/*The ienc property is always exposed as a multiple key info in GPAC\n\t\tHowever the type of SAI may be single-key (aux_info_param==0) or multiple-key (aux_info_param==1) for the same ienc used\n\t\tWe therefore temporary force the key info type to single key if v0 SAI CENC are used\n\t\tNote that this is thread safe as this filter is the only one using the opened file\n\t\t*/\n\t\tif (aux_info_param==0) {\n\t\t\titem_mkey = key_info[0];\n\t\t}\n\t} else {\n\t\te = gf_isom_get_sample_cenc_info(ch->owner->mov, ch->track, ch->sample_num, &Is_Encrypted, &crypt_byte_block, &skip_byte_block, (const u8 **) &key_info, &key_info_size);\n\t}\n\tif (!key_info) {\n\t\tpiff_info[0] = 0;\n\t\tpiff_info[1] = 0;\n\t\tpiff_info[2] = 0;\n\t\tpiff_info[3] = key_info_size;\n\t\tmemset(piff_info + 4, 0, 16);\n\t\tkey_info_size = 20;\n\t\tkey_info = (u8 *) piff_info;\n\t}\n\n\n\tif (!for_item && (e==GF_OK) && Is_Encrypted) {\n\t\te = gf_isom_cenc_get_sample_aux_info(ch->owner->mov, ch->track, ch->sample_num, ch->last_sample_desc_index, NULL, &ch->sai_buffer, &out_size);\n\t}\n\n\tif (out_size > ch->sai_alloc_size) ch->sai_alloc_size = out_size;\n\tch->sai_buffer_size = out_size;\n\n\tif (e) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[IsoMedia] Failed to fetch CENC auxiliary info for %s %d: %s\\n\", for_item ? \"item\" : \"track\", for_item ? ch->item_id : ch->track, gf_error_to_string(e) ));\n\t\treturn;\n\t}\n\n\tch->pck_encrypted = Is_Encrypted;\n\tch->cenc_ki = NULL;\n\n\t/*notify change of IV/KID only when packet is encrypted\n\t1- these info are ignored when packet is not encrypted\n\t2- this allows us to define the initial CENC state for multi-stsd cases*/\n\tif (Is_Encrypted) {\n\t\tu32 ki_crc;\n\n\t\tif ((ch->crypt_byte_block != crypt_byte_block) || (ch->skip_byte_block != skip_byte_block)) {\n\t\t\tch->crypt_byte_block = crypt_byte_block;\n\t\t\tch->skip_byte_block = skip_byte_block;\n\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_CENC_PATTERN, &PROP_FRAC_INT(ch->skip_byte_block, ch->crypt_byte_block) );\n\t\t}\n\t\tif (item_mkey)\n\t\t\tkey_info[0] = 0;\n\n\t\tki_crc = gf_crc_32(key_info, key_info_size);\n\t\tif (ch->key_info_crc != ki_crc) {\n\t\t\tch->key_info_crc = ki_crc;\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_CENC_KEY_INFO, &PROP_DATA((u8 *)key_info, key_info_size) );\n\t\t}\n\n\t\tif (item_mkey)\n\t\t\tkey_info[0] = item_mkey;\n\n\t\tch->cenc_ki = gf_filter_pid_get_property(ch->pid, GF_PROP_PID_CENC_KEY_INFO);\n\t}\n}\n\nvoid isor_reader_get_sample_from_item(ISOMChannel *ch)\n{\n\tif (ch->au_seq_num) {\n\t\tif (!ch->owner->itt || !isor_declare_item_properties(ch->owner, ch, 1+ch->au_seq_num)) {\n\t\t\tch->last_state = GF_EOS;\n\t\t\treturn;\n\t\t}\n\t}\n\tch->sample_time = 0;\n\tch->last_state = GF_OK;\n\tif (!ch->static_sample) {\n\t\tch->static_sample = gf_isom_sample_new();\n\t}\n\n\tch->sample = ch->static_sample;\n\tch->sample->IsRAP = RAP;\n\tch->sample->duration = 1000;\n\tch->dts = ch->cts = 1000 * ch->au_seq_num;\n\tgf_isom_extract_meta_item_mem(ch->owner->mov, GF_TRUE, 0, ch->item_id, &ch->sample->data, &ch->sample->dataLength, &ch->static_sample->alloc_size, NULL, GF_FALSE);\n\n\tif (ch->is_encrypted && ch->is_cenc) {\n\t\tisor_update_cenc_info(ch, GF_TRUE);\n\t}\n}\n\nu8 *isor_sample_alloc(u32 size, void *udta)\n{\n\tu8 *output;\n\tISOMChannel *ch = (ISOMChannel *)udta;\n\tif (ch->pck) {\n\t\tif (size<ch->alloc_size) {\n\t\t\tu32 size;\n\t\t\treturn (u8 *) gf_filter_pck_get_data(ch->pck, &size);\n\t\t}\n\t\tgf_filter_pck_expand(ch->pck, size - ch->alloc_size, &output, NULL, NULL);\n\t\tch->alloc_size = size;\n\t\treturn output;\n\t}\n\tch->pck = gf_filter_pck_new_alloc(ch->pid, size, &output);\n\tch->alloc_size = size;\n\treturn output;\n}\n\nvoid isor_reader_get_sample(ISOMChannel *ch)\n{\n\tGF_Err e;\n\tBool skip_sample=GF_FALSE;\n\tu32 sample_desc_index;\n\tif (ch->sample) return;\n\n\tif (ch->next_track) {\n\t\tch->track = ch->next_track;\n\t\tif (!ch->owner->nodata)\n\t\t\tgf_isom_set_sample_alloc(ch->owner->mov, ch->track, isor_sample_alloc, ch);\n\t\tch->next_track = 0;\n\t}\n\n\tif (ch->to_init) {\n\t\tif (!ch->owner->nodata)\n\t\t\tgf_isom_set_sample_alloc(ch->owner->mov, ch->track, isor_sample_alloc, ch);\n\t\tinit_reader(ch);\n\t\tsample_desc_index = ch->last_sample_desc_index;\n\t} else if (ch->speed < 0) {\n\t\tif (ch->last_state == GF_EOS) {\n\t\t\tch->sample = NULL;\n\t\t\treturn;\n\t\t}\n\n\t\tif (ch->static_sample->IsRAP) {\n\t\t\tch->last_rap_sample_time = ch->sample_time;\n\t\t}\n\n\t\te = gf_isom_get_sample_for_movie_time(ch->owner->mov, ch->track, ch->sample_time + 1, &sample_desc_index, GF_ISOM_SEARCH_FORWARD, &ch->static_sample, &ch->sample_num, NULL);\n\t\tch->static_sample->alloc_size = 0;\n\n\t\tif ((e==GF_EOS) || (ch->static_sample->IsRAP)) {\n\t\t\tif (!ch->last_rap_sample_time) {\n\t\t\t\te = GF_EOS;\n\t\t\t} else {\n\t\t\t\te = gf_isom_get_sample_for_movie_time(ch->owner->mov, ch->track, ch->last_rap_sample_time - 1, &sample_desc_index, GF_ISOM_SEARCH_SYNC_BACKWARD, &ch->static_sample, &ch->sample_num, NULL);\n\t\t\t\tch->static_sample->alloc_size = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (e) {\n\t\t\tif ((e==GF_EOS) && !ch->owner->frag_type) {\n\t\t\t\tch->last_state = GF_EOS;\n\t\t\t}\n\t\t\tch->sample = NULL;\n\t\t\treturn;\n\t\t}\n\t\tch->sample = ch->static_sample;\n\n\t\tif (ch->sample->DTS == ch->sample_time) {\n\t\t\tif (!ch->owner->frag_type) {\n\t\t\t\tch->last_state = GF_EOS;\n\t\t\t}\n\t\t}\n\t\tif (ch->sample) {\n\t\t\tch->sample_time = ch->sample->DTS;\n\t\t}\n\n\t} else if (ch->has_edit_list) {\n\t\tu32 prev_sample = ch->sample_num;\n\t\te = gf_isom_get_sample_for_movie_time(ch->owner->mov, ch->track, ch->sample_time + 1, &sample_desc_index, GF_ISOM_SEARCH_FORWARD, &ch->static_sample, &ch->sample_num, &ch->sample_data_offset);\n\t\tch->static_sample->alloc_size = 0;\n\n\t\tif (e == GF_OK) {\n\t\t\tch->sample = ch->static_sample;\n\n\t\t\t/*we are in forced seek mode: fetch all samples before the one matching the sample time*/\n\t\t\tif (ch->edit_sync_frame) {\n\t\t\t\tch->edit_sync_frame++;\n\t\t\t\tif (ch->edit_sync_frame < ch->sample_num) {\n\t\t\t\t\tch->sample = gf_isom_get_sample_ex(ch->owner->mov, ch->track, ch->edit_sync_frame, &sample_desc_index, ch->static_sample, &ch->sample_data_offset);\n\t\t\t\t\tif (ch->sample) {\n\t\t\t\t\t\tch->sample->DTS = ch->sample_time;\n\t\t\t\t\t\tch->sample->CTS_Offset = 0;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tch->edit_sync_frame = 0;\n\t\t\t\t\tif (ch->sample) ch->sample_time = ch->sample->DTS;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/*if we get the same sample, figure out next interesting time (current sample + DTS gap to next sample should be a good bet)*/\n\t\t\t\tif (prev_sample == ch->sample_num) {\n\t\t\t\t\tif (ch->owner->frag_type && (ch->sample_num==gf_isom_get_sample_count(ch->owner->mov, ch->track))) {\n\t\t\t\t\t\tch->sample = NULL;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tu32 sample_num = ch->sample_num ? ch->sample_num : 1;\n\n\t\t\t\t\t\tif (sample_num >= gf_isom_get_sample_count(ch->owner->mov, ch->track) ) {\n\t\t\t\t\t\t\t//e = GF_EOS;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tu32 time_diff = gf_isom_get_sample_duration(ch->owner->mov, ch->track, sample_num);\n\t\t\t\t\t\t\te = gf_isom_get_sample_for_movie_time(ch->owner->mov, ch->track, ch->sample_time + time_diff, &sample_desc_index, GF_ISOM_SEARCH_FORWARD, &ch->static_sample, &ch->sample_num, &ch->sample_data_offset);\n\t\t\t\t\t\t\tch->static_sample->alloc_size = 0;\n\t\t\t\t\t\t\tif (e==GF_OK) {\n\t\t\t\t\t\t\t\tif (ch->sample_num == prev_sample) {\n\t\t\t\t\t\t\t\t\tch->sample_time += time_diff;\n\t\t\t\t\t\t\t\t\tch->sample = NULL;\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tch->sample = ch->static_sample;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/*we jumped to another segment - if RAP is needed look for closest rap in decoding order and\n\t\t\t\tforce seek mode*/\n\t\t\t\tif (ch->sample && !ch->sample->IsRAP && ch->has_rap && (ch->sample_num != prev_sample+1)) {\n\t\t\t\t\tGF_ISOSample *found = ch->static_sample;\n\t\t\t\t\tu32 samp_num = ch->sample_num;\n\t\t\t\t\tch->sample = NULL;\n\t\t\t\t\te = gf_isom_get_sample_for_movie_time(ch->owner->mov, ch->track, ch->sample_time + 1, &sample_desc_index, GF_ISOM_SEARCH_SYNC_BACKWARD, &ch->static_sample, &ch->sample_num, &ch->sample_data_offset);\n\n\t\t\t\t\tch->static_sample->alloc_size = 0;\n\t\t\t\t\tch->sample = (e == GF_OK) ? ch->static_sample : NULL;\n\n\t\t\t\t\t/*if no sync point in the past, use the first non-sync for the given time*/\n\t\t\t\t\tif (!ch->sample || !ch->sample->data) {\n\t\t\t\t\t\tch->sample = ch->static_sample = found;\n\t\t\t\t\t\tch->sample_time = ch->sample->DTS;\n\t\t\t\t\t\tch->sample_num = samp_num;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tch->sample = ch->static_sample;\n\t\t\t\t\t\tch->edit_sync_frame = ch->sample_num;\n\t\t\t\t\t\tch->sample->DTS = ch->sample_time;\n\t\t\t\t\t\tch->sample->CTS_Offset = 0;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (ch->sample) ch->sample_time = ch->sample->DTS;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tBool do_fetch = GF_TRUE;\n\t\tch->sample_num++;\n\t\tif (ch->sample_last && (ch->sample_last<ch->sample_num)) {\n\t\t\tch->sample = NULL;\n\t\t\tch->last_state = GF_EOS;\n\t\t\tch->playing = 2;\n\t\t\treturn;\n\t\t}\n\n\t\tif (ch->sap_only) {\n\t\t\tBool is_rap = gf_isom_get_sample_sync(ch->owner->mov, ch->track, ch->sample_num);\n\t\t\tif (!is_rap) {\n\t\t\t\tGF_ISOSampleRollType roll_type;\n\t\t\t\tgf_isom_get_sample_rap_roll_info(ch->owner->mov, ch->track, ch->sample_num, &is_rap, &roll_type, NULL);\n\t\t\t\tif (roll_type) is_rap = GF_TRUE;\n\t\t\t}\n\n\t\t\tif (!is_rap) {\n\t\t\t\tdo_fetch = GF_FALSE;\n\t\t\t} else if (ch->sap_only==2) {\n\t\t\t\tch->sap_only = 0;\n\t\t\t}\n\t\t}\n\t\tif (do_fetch) {\n\t\t\tif (ch->owner->nodata) {\n\t\t\t\tch->sample = gf_isom_get_sample_info_ex(ch->owner->mov, ch->track, ch->sample_num, &sample_desc_index, &ch->sample_data_offset, ch->static_sample);\n\t\t\t} else {\n\t\t\t\tch->sample = gf_isom_get_sample_ex(ch->owner->mov, ch->track, ch->sample_num, &sample_desc_index, ch->static_sample, &ch->sample_data_offset);\n\t\t\t}\n\t\t\t/*if sync shadow / carousel RAP skip*/\n\t\t\tif (ch->sample && (ch->sample->IsRAP==RAP_REDUNDANT)) {\n\t\t\t\tch->sample = NULL;\n\t\t\t\tch->sample_num++;\n\t\t\t\tif (ch->pck) {\n\t\t\t\t\tgf_filter_pck_discard(ch->pck);\n\t\t\t\t\tch->pck = NULL;\n\t\t\t\t\tch->static_sample->alloc_size = ch->static_sample->dataLength = 0;\n\t\t\t\t}\n\t\t\t\tisor_reader_get_sample(ch);\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\tskip_sample = GF_TRUE;\n\t\t}\n\t}\n\n\t//check scalable track change\n\tif (ch->sample && ch->sample->IsRAP && ch->next_track) {\n\t\tch->track = ch->next_track;\n\t\tch->next_track = 0;\n\t\tch->sample = NULL;\n\t\tif (ch->pck) {\n\t\t\tgf_filter_pck_discard(ch->pck);\n\t\t\tch->pck = NULL;\n\t\t}\n\t\tisor_reader_get_sample(ch);\n\t\treturn;\n\t}\n\n\tif (!ch->sample) {\n\t\tu32 sample_count = gf_isom_get_sample_count(ch->owner->mov, ch->track);\n\t\tch->sample_data_offset = 0;\n\t\t/*incomplete file - check if we're still downloading or not*/\n\t\tif (gf_isom_get_missing_bytes(ch->owner->mov, ch->track)) {\n\t\t\tch->last_state = GF_ISOM_INCOMPLETE_FILE;\n\t\t\tif (ch->owner->mem_load_mode==2)\n\t\t\t\tch->owner->force_fetch = GF_TRUE;\n\n\t\t\tif (!ch->owner->input_loaded) {\n\t\t\t\tch->last_state = GF_OK;\n\t\t\t\tif (!ch->has_edit_list && ch->sample_num)\n\t\t\t\t\tch->sample_num--;\n\t\t\t} else {\n\t\t\t\tif (ch->to_init && ch->sample_num) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[IsoMedia] Failed to fetch initial sample %d for track %d\\n\", ch->sample_num, ch->track));\n\t\t\t\t\tch->last_state = GF_ISOM_INVALID_FILE;\n\t\t\t\t} else {\n\t\t\t\t\tif (!ch->eos_sent) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[IsoMedia] File truncated, aborting read for track %d\\n\", ch->track));\n\t\t\t\t\t}\n\t\t\t\t\tch->last_state = GF_EOS;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (!ch->sample_num\n\t\t         || ((ch->speed >= 0) && (ch->sample_num >= sample_count))\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t         || ((ch->speed < 0) && (ch->sample_time == gf_isom_get_current_tfdt(ch->owner->mov, ch->track) ))\n#endif\n\t\t) {\n\n\t\t\tif (ch->owner->frag_type==1) {\n\t\t\t\t/*if sample cannot be found and file is fragmented, rewind sample*/\n\t\t\t\tif (ch->sample_num) ch->sample_num--;\n\t\t\t\tch->last_state = GF_EOS;\n\t\t\t} else if (ch->last_state != GF_EOS) {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[IsoMedia] Track #%d end of stream reached\\n\", ch->track));\n\t\t\t\tch->last_state = GF_EOS;\n\t\t\t\tif (ch->sample_num>sample_count) ch->sample_num = sample_count;\n\t\t\t} else {\n\t\t\t\tif (ch->sample_num>sample_count) ch->sample_num = sample_count;\n\t\t\t}\n\t\t} else if (!skip_sample) {\n\t\t\te = gf_isom_last_error(ch->owner->mov);\n\t\t\tGF_LOG((e==GF_ISOM_INCOMPLETE_FILE) ? GF_LOG_DEBUG : GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[IsoMedia] Track #%d fail to fetch sample %d / %d: %s\\n\", ch->track, ch->sample_num, gf_isom_get_sample_count(ch->owner->mov, ch->track), gf_error_to_string(e) ));\n\n\t\t\tif ((e<GF_OK) && (e!=GF_ISOM_INCOMPLETE_FILE)) {\n\t\t\t\tch->last_state = GF_EOS;\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\t//first sample fetched has DTS, we have a tfdt so ignore the hinted one\n\tif ((ch->sample_num==1) && ch->hint_first_tfdt && ch->sample->DTS) {\n\t\tch->hint_first_tfdt = 0;\n\t}\n\tch->sample->DTS += ch->hint_first_tfdt;\n\n\tif (sample_desc_index != ch->last_sample_desc_index) {\n\t\tif (!ch->owner->stsd) {\n\t\t\t//we used sample entry 1 by default to setup, if no active prev sample (edit list might trigger this)\n\t\t\t//and new sample desc is 1, do not reconfigure\n\t\t\tif (!ch->last_sample_desc_index && (sample_desc_index==1)) {\n\n\t\t\t} else {\n\t\t\t\tch->needs_pid_reconfig = 1;\n\t\t\t}\n\t\t}\n\t\tch->last_sample_desc_index = sample_desc_index;\n\t}\n\n\tch->last_state = GF_OK;\n\n\tch->sap_3 = GF_FALSE;\n\tch->sap_4_type = 0;\n\tch->roll = 0;\n\n\tif (ch->sample) {\n\t\tgf_isom_get_sample_rap_roll_info(ch->owner->mov, ch->track, ch->sample_num, &ch->sap_3, &ch->sap_4_type, &ch->roll);\n\n\t\t/*still seeking or not ?\n\t\t 1- when speed is negative, the RAP found is \"after\" the seek point in playback order since we used backward RAP search: nothing to do\n\t\t 2- otherwise set DTS+CTS to start value\n\t\t */\n\t\tif ((ch->speed < 0) || (ch->start <= ch->sample->DTS + ch->sample->CTS_Offset)) {\n\t\t\tch->dts = ch->sample->DTS;\n\t\t\tch->cts = ch->sample->DTS + ch->sample->CTS_Offset;\n\t\t\tch->seek_flag = 0;\n\t\t} else {\n\t\t\tch->cts = ch->start;\n\t\t\tch->seek_flag = 1;\n\t\t\tch->dts = ch->start;\n\t\t}\n\n\t\tif (ch->end && (ch->end < ch->sample->DTS + ch->sample->CTS_Offset + ch->sample->duration)) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[IsoMedia] End of Channel \"LLD\" (CTS \"LLD\")\\n\", ch->end, ch->sample->DTS + ch->sample->CTS_Offset));\n\t\t\tch->sample = NULL;\n\t\t\tch->last_state = GF_EOS;\n\t\t\tch->playing = 2;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (ch->owner->last_sender_ntp && ch->cts==ch->owner->cts_for_last_sender_ntp) {\n\t\tch->sender_ntp = ch->owner->last_sender_ntp;\n\t\tch->ntp_at_server_ntp = ch->owner->ntp_at_last_sender_ntp;\n\t} else if (ch->owner->last_sender_ntp && ch->dts==ch->owner->cts_for_last_sender_ntp) {\n\t\tch->sender_ntp = ch->owner->last_sender_ntp;\n\t\tch->ntp_at_server_ntp = ch->owner->ntp_at_last_sender_ntp;\n\t} else {\n\t\tch->sender_ntp = ch->ntp_at_server_ntp = 0;\n\t}\n\n\tif (!ch->sample_num) return;\n\n\tgf_isom_get_sample_flags(ch->owner->mov, ch->track, ch->sample_num, &ch->isLeading, &ch->dependsOn, &ch->dependedOn, &ch->redundant);\n\n\tif (ch->is_encrypted) {\n\t\t/*in case of CENC: we write sample auxiliary information to slh->sai; its size is in saiz*/\n\t\tif (gf_isom_is_cenc_media(ch->owner->mov, ch->track, ch->last_sample_desc_index)) {\n\t\t\tisor_update_cenc_info(ch, GF_FALSE);\n\n\t\t} else if (gf_isom_is_media_encrypted(ch->owner->mov, ch->track, ch->last_sample_desc_index)) {\n\t\t\tch->pck_encrypted = GF_TRUE;\n\t\t} else {\n\t\t\tch->pck_encrypted = GF_FALSE;\n\t\t}\n\t}\n\tif (ch->sample && ch->sample->nb_pack)\n\t\tch->sample_num += ch->sample->nb_pack-1;\n}\n\nvoid isor_reader_release_sample(ISOMChannel *ch)\n{\n\tif (ch->sample)\n\t\tch->au_seq_num++;\n\tch->sample = NULL;\n\tch->sai_buffer_size = 0;\n}\n\nenum\n{\n\tRESET_STATE_VPS=1,\n\tRESET_STATE_SPS=1<<1,\n\tRESET_STATE_PPS=1<<2,\n\tRESET_STATE_SPS_EXT=1<<3,\n\tRESET_STATE_DCI=1<<4,\n};\n\n#include <gpac/internal/media_dev.h>\n\n//quick way of reading ID of AVC/HEVC/VVC param sets\nstatic s32 isor_ps_get_id(u8 nal_type, u8 *data, u32 size, Bool is_avc)\n{\n\ts32 res=-1;\n\tGF_BitStream *bs = gf_bs_new(data, size, GF_BITSTREAM_READ);\n\tgf_bs_enable_emulation_byte_removal(bs, GF_TRUE);\n\tswitch (nal_type) {\n\tcase GF_AVC_NALU_PIC_PARAM:\n\t\tgf_bs_read_u8(bs); //nal header\n\t\tres = gf_bs_read_ue(bs);\n\t\tbreak;\n\tcase GF_AVC_NALU_SEQ_PARAM:\n\t\tgf_bs_read_u32(bs); //nal header + start of sps\n\t\tres = gf_bs_read_ue(bs);\n\t\tbreak;\n\tcase GF_HEVC_NALU_VID_PARAM:\n\t\tgf_bs_read_u16(bs); //nal header\n\t\tres = gf_bs_read_int(bs, 4);\n\t\tbreak;\n\tcase GF_HEVC_NALU_SEQ_PARAM:\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\tres = gf_hevc_read_sps(data, size, NULL);\n#else\n\t\tres = -1;\n#endif\n\t\tbreak;\n\tcase GF_HEVC_NALU_PIC_PARAM:\n\t\tgf_bs_read_u16(bs); //nal header\n\t\tres = gf_bs_read_ue(bs);\n\t\tbreak;\n\tcase GF_VVC_NALU_VID_PARAM:\n\t\tgf_bs_read_u16(bs); //nal header\n\t\tres = gf_bs_read_int(bs, 4);\n\t\tbreak;\n\tcase GF_VVC_NALU_SEQ_PARAM:\n\t\tgf_bs_read_u16(bs); //nal header\n\t\tres = gf_bs_read_int(bs, 4);\n\t\tbreak;\n\tcase GF_VVC_NALU_PIC_PARAM:\n\t\tgf_bs_read_u16(bs); //nal header\n\t\tres = gf_bs_read_int(bs, 6);\n\t\tbreak;\n\t//case GF_AVC_NALU_SEQ_PARAM_EXT: - same value as VVC_DEC_PARAM\n\tcase GF_VVC_NALU_DEC_PARAM:\n\t\tif (is_avc) {\n\t\t\tgf_bs_read_u8(bs); //nal header\n\t\t\tres = (s32) gf_bs_read_ue(bs);\n\t\t} else {\n\t\t\tres = 0; //no ID for DCI\n\t\t}\n\t\tbreak;\n\t}\n\tgf_bs_del(bs);\n\treturn res;\n}\n\nstatic void isor_reset_seq_list(GF_List *list)\n{\n   while (gf_list_count(list)) {\n\t\t   GF_NALUFFParam *sl = gf_list_pop_back(list);\n\t\t   gf_free(sl->data);\n\t\t   gf_free(sl);\n   }\n}\n\nstatic void isor_reset_all_ps(ISOMChannel *ch)\n{\n\tu32 i, count;\n\tif (ch->avcc) {\n\t\tisor_reset_seq_list(ch->avcc->pictureParameterSets);\n\t\tisor_reset_seq_list(ch->avcc->sequenceParameterSets);\n\t\tisor_reset_seq_list(ch->avcc->sequenceParameterSetExtensions);\n\t}\n\telse if (ch->hvcc) {\n\t\tcount = gf_list_count(ch->hvcc->param_array);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_NALUFFParamArray *hvca = gf_list_get(ch->hvcc->param_array, i);\n\t\t\tisor_reset_seq_list(hvca->nalus);\n\t\t}\n\t}\n\telse if (ch->vvcc) {\n\t\tcount = gf_list_count(ch->vvcc->param_array);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_NALUFFParamArray *vvca = gf_list_get(ch->vvcc->param_array, i);\n\t\t\tisor_reset_seq_list(vvca->nalus);\n\t\t}\n\t}\n}\n\nstatic void isor_replace_nal(ISOMChannel *ch, u8 *data, u32 size, u8 nal_type, Bool *needs_reset)\n{\n\ts32 ps_id;\n\tu32 i, count, state=0;\n\tGF_NALUFFParam *sl;\n\tGF_List *list=NULL;\n\tif (ch->avcc) {\n\t\tif (nal_type==GF_AVC_NALU_PIC_PARAM) {\n\t\t\tlist = ch->avcc->pictureParameterSets;\n\t\t\tstate=RESET_STATE_PPS;\n\t\t} else if (nal_type==GF_AVC_NALU_SEQ_PARAM) {\n\t\t\tlist = ch->avcc->sequenceParameterSets;\n\t\t\tstate=RESET_STATE_SPS;\n\t\t} else if (nal_type==GF_AVC_NALU_SEQ_PARAM_EXT) {\n\t\t\tlist = ch->avcc->sequenceParameterSetExtensions;\n\t\t\tstate=RESET_STATE_SPS_EXT;\n\t\t} else return;\n\t}\n\telse if (ch->hvcc) {\n\t\tGF_NALUFFParamArray *hvca=NULL;\n\t\tcount = gf_list_count(ch->hvcc->param_array);\n\t\tfor (i=0; i<count; i++) {\n\t\t\thvca = gf_list_get(ch->hvcc->param_array, i);\n\t\t\tif (hvca->type==nal_type) {\n\t\t\t\tlist = hvca->nalus;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\thvca = NULL;\n\t\t}\n\t\tif (!hvca) {\n\t\t\tGF_SAFEALLOC(hvca, GF_NALUFFParamArray);\n\t\t\tif (hvca) {\n\t\t\t\tlist = hvca->nalus = gf_list_new();\n\t\t\t\thvca->type = nal_type;\n\t\t\t\tgf_list_add(ch->hvcc->param_array, hvca);\n\t\t\t}\n\t\t}\n\t\tswitch (nal_type) {\n\t\tcase GF_HEVC_NALU_VID_PARAM:\n\t\t\tstate = RESET_STATE_VPS;\n\t\t\tbreak;\n\t\tcase GF_HEVC_NALU_SEQ_PARAM:\n\t\t\tstate = RESET_STATE_SPS;\n\t\t\tbreak;\n\t\tcase GF_HEVC_NALU_PIC_PARAM:\n\t\t\tstate = RESET_STATE_PPS;\n\t\t\tbreak;\n\t\t}\n\t}\n\telse if (ch->vvcc) {\n\t\tGF_NALUFFParamArray *vvca=NULL;\n\t\tcount = gf_list_count(ch->vvcc->param_array);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tvvca = gf_list_get(ch->vvcc->param_array, i);\n\t\t\tif (vvca->type==nal_type) {\n\t\t\t\tlist = vvca->nalus;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvvca = NULL;\n\t\t}\n\t\tif (!vvca) {\n\t\t\tGF_SAFEALLOC(vvca, GF_NALUFFParamArray);\n\t\t\tif (vvca) {\n\t\t\t\tlist = vvca->nalus = gf_list_new();\n\t\t\t\tvvca->type = nal_type;\n\t\t\t\tgf_list_add(ch->vvcc->param_array, vvca);\n\t\t\t}\n\t\t}\n\t\tswitch (nal_type) {\n\t\tcase GF_VVC_NALU_VID_PARAM:\n\t\t\tstate = RESET_STATE_VPS;\n\t\t\tbreak;\n\t\tcase GF_VVC_NALU_SEQ_PARAM:\n\t\t\tstate = RESET_STATE_SPS;\n\t\t\tbreak;\n\t\tcase GF_VVC_NALU_PIC_PARAM:\n\t\t\tstate = RESET_STATE_PPS;\n\t\t\tbreak;\n\t\tcase GF_VVC_NALU_DEC_PARAM:\n\t\t\tstate = RESET_STATE_DCI;\n\t\t\tbreak;\n\t\t}\n\t}\n\t//get ps\n\tps_id = 1 + isor_ps_get_id(nal_type, data, size, ch->avcc ? 1 : 0);\n\n\tcount = gf_list_count(list);\n\tfor (i=0; i<count; i++) {\n\t\tsl = gf_list_get(list, i);\n\t\tif (!sl->id) {\n\t\t\tsl->id = 1 + isor_ps_get_id(nal_type, sl->data, sl->size, ch->avcc ? 1 : 0);\n\t\t}\n\t\tif (sl->id != ps_id) {\n\t\t\t//reset everything whenever we change ID of seq / vps / dci\n\t\t\tif (!ch->xps_mask && (state != RESET_STATE_PPS)) {\n\t\t\t\tisor_reset_all_ps(ch);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((sl->size==size) && !memcmp(sl->data, data, size)) {\n\t\t\tch->xps_mask |= state;\n\t\t\treturn;\n\t\t}\n\t\tif (state == RESET_STATE_PPS) {\n\t\t\t//PS modified, copy\n\t\t\tsl->data = gf_realloc(sl->data, size);\n\t\t\tmemcpy(sl->data, data, size);\n\t\t\tsl->size = size;\n\t\t\t*needs_reset = 1;\n\t\t\tch->xps_mask |= state;\n\t\t\treturn;\n\t\t}\n\t\t//reset, same as above\n\t\telse if (!ch->xps_mask) {\n\t\t\tisor_reset_all_ps(ch);\n\t\t\tbreak;\n\t\t}\n\t}\n\tch->xps_mask |= state;\n\t*needs_reset = 1;\n\n\tGF_SAFEALLOC(sl, GF_NALUFFParam);\n\tif (!sl) return;\n\tsl->data = gf_malloc(sizeof(char)*size);\n\tmemcpy(sl->data, data, size);\n\tsl->size = size;\n\tsl->id = ps_id;\n\tgf_list_add(list, sl);\n}\n\nu8 key_info_get_iv_size(const u8 *key_info, u32 nb_keys, u32 idx, u8 *const_iv_size, const u8 **const_iv);\n\nvoid isor_sai_bytes_removed(ISOMChannel *ch, u32 pos, u32 removed)\n{\n\tu32 offset = 0;\n\tu8 *sai;\n\tu32 sai_size, cur_pos;\n\tu32 sub_count_size = 0;\n\tu32 i, subs_count = 0;\n\n\tif (!ch->cenc_ki || !ch->sai_buffer) return;\n\n\tsai = ch->sai_buffer;\n\tsai_size = ch->sai_buffer_size;\n\n\t//multikey\n\tif (ch->cenc_ki->value.data.ptr[0]) {\n\t\tu32 remain;\n\t\tu32 j, nb_iv_init = sai[0];\n\t\tnb_iv_init <<= 8;\n\t\tnb_iv_init |= sai[1];\n\t\tu8 *sai_p = sai + 2;\n\t\tremain = sai_size-2;\n\n\t\tfor (j=0; j<nb_iv_init; j++) {\n\t\t\tu32 mk_iv_size;\n\t\t\tu32 idx = sai_p[0];\n\t\t\tidx<<=8;\n\t\t\tidx |= sai_p[1];\n\n\t\t\tmk_iv_size = key_info_get_iv_size(ch->cenc_ki->value.data.ptr, ch->cenc_ki->value.data.size, idx, NULL, NULL);\n\t\t\tmk_iv_size += 2; //idx\n\t\t\tif (mk_iv_size > remain) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Invalid multi-key CENC SAI, cannot modify first subsample !\\n\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsai_p += mk_iv_size;\n\t\t\tremain -= mk_iv_size;\n\t\t}\n\t\toffset = (u32) (sai_p - sai);\n\t\tsub_count_size = 4; //32bit sub count\n\n\t} else {\n\t\toffset = key_info_get_iv_size(ch->cenc_ki->value.data.ptr, ch->cenc_ki->value.data.size, 1, NULL, NULL);\n\t\tsub_count_size = 2; //16bit sub count\n\t}\n\tif (sai_size < offset + sub_count_size) return;\n\n\tsai += offset;\n\tif (sub_count_size==2) {\n\t\tsubs_count = ((u32) sai[0]) << 8 | sai[1];\n\t} else {\n\t\tsubs_count = GF_4CC(sai[0], sai[1], sai[2], sai[3]);\n\t}\n\tsai += sub_count_size;\n\tsai_size -= offset + sub_count_size;\n\tcur_pos = 0;\n\tfor (i=0; i<subs_count; i++) {\n\t\tif (sai_size<6)\n\t\t\treturn;\n\t\tu32 clear = ((u32) sai[0]) << 8 | sai[1];\n\t\tu32 crypt = GF_4CC(sai[2], sai[3], sai[4], sai[5]);\n\t\tif (cur_pos + clear > pos) {\n\t\t\tclear -= removed;\n\t\t\tsai[0] = (clear>>8) & 0xFF;\n\t\t\tsai[1] = (clear) & 0xFF;\n\t\t\treturn;\n\t\t}\n\t\tcur_pos += clear + crypt;\n\t\tsai += 6;\n\t\tsai_size-=6;\n\t}\n}\n\nvoid isor_reader_check_config(ISOMChannel *ch)\n{\n\tu32 nalu_len, pos;\n\tBool needs_reset;\n\tif (!ch->check_hevc_ps && !ch->check_avc_ps && !ch->check_vvc_ps && !ch->check_mhas_pl) return;\n\n\tif (!ch->sample || !ch->sample->data) return;\n\tch->xps_mask = 0;\n\n\t//we cannot touch the payload if encrypted but not CENC !!\n\tif (ch->is_encrypted && !ch->is_cenc)\n\t\treturn;\n\n\tif (ch->check_mhas_pl) {\n\t\t//we cannot touch the payload if encrypted !!\n\t\tif (ch->pck_encrypted) return;\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\tu64 ch_layout = 0;\n\t\ts32 PL = gf_mpegh_get_mhas_pl(ch->sample->data, ch->sample->dataLength, &ch_layout);\n\t\tif (PL>0) {\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_PROFILE_LEVEL, &PROP_UINT((u32) PL));\n\t\t\tch->check_mhas_pl = 0;\n\t\t\tif (ch_layout)\n\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_CHANNEL_LAYOUT, &PROP_LONGUINT(ch_layout));\n\t\t}\n#endif\n\t\treturn;\n\t}\n\t//analyze mode, do not rewrite\n\tif (ch->owner->analyze) return;\n\n\t//we cannot touch the payload if encrypted but no SAI buffer\n\tif (ch->pck_encrypted && !ch->sai_buffer)\n\t\treturn;\n\n\tnalu_len = 4;\n\tif (ch->avcc) nalu_len = ch->avcc->nal_unit_size;\n\telse if (ch->hvcc) nalu_len = ch->hvcc->nal_unit_size;\n\telse if (ch->vvcc) nalu_len = ch->vvcc->nal_unit_size;\n\n\tif (!nalu_len) return;\n\tneeds_reset = 0;\n\n\tpos = 0;\n\n\twhile (1) {\n\t\tBool replace_nal = GF_FALSE;\n\t\tu8 nal_type=0;\n\t\tif (pos + nalu_len >= ch->sample->dataLength) break;\n\t\tu32 tmp=0, size = 0;\n\t\twhile (tmp<nalu_len-1) {\n\t\t\tsize |= ch->sample->data[pos+tmp];\n\t\t\ttmp++;\n\t\t\tsize<<=8;\n\t\t}\n\t\tsize |= ch->sample->data[pos+tmp];\n\t\t//we allow nal_size=0 for incomplete files, abort as soon as we see one to avoid parsing thousands of 0 bytes\n\t\tif (!size) break;\n\n\t\t//this takes care of size + pos + nalu_len > 0 but (s32) size < 0 ...\n\t\tif (ch->sample->dataLength < size) break;\n\t\tif (ch->sample->dataLength < size + pos + nalu_len) break;\n\t\tif (ch->check_avc_ps) {\n\t\t\tu8 hdr = ch->sample->data[pos + nalu_len];\n\t\t\tnal_type = hdr & 0x1F;\n\t\t\tswitch (nal_type) {\n\t\t\tcase GF_AVC_NALU_SEQ_PARAM:\n\t\t\tcase GF_AVC_NALU_SEQ_PARAM_EXT:\n\t\t\tcase GF_AVC_NALU_PIC_PARAM:\n\t\t\t\treplace_nal = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse if (ch->check_hevc_ps) {\n\t\t\tu8 hdr = ch->sample->data[pos + nalu_len];\n\t\t\tnal_type = (hdr & 0x7E) >> 1;\n\t\t\tswitch (nal_type) {\n\t\t\tcase GF_HEVC_NALU_VID_PARAM:\n\t\t\tcase GF_HEVC_NALU_SEQ_PARAM:\n\t\t\tcase GF_HEVC_NALU_PIC_PARAM:\n\t\t\t\treplace_nal = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse if (ch->check_vvc_ps) {\n\t\t\tu8 hdr = ch->sample->data[pos + nalu_len + 1];\n\t\t\tnal_type = hdr >> 3;\n\t\t\tswitch (nal_type) {\n\t\t\tcase GF_VVC_NALU_VID_PARAM:\n\t\t\tcase GF_VVC_NALU_SEQ_PARAM:\n\t\t\tcase GF_VVC_NALU_PIC_PARAM:\n\t\t\tcase GF_VVC_NALU_DEC_PARAM:\n\t\t\tcase GF_VVC_NALU_OPI:\n\t\t\t\treplace_nal = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (replace_nal) {\n\t\t\tu32 move_size = ch->sample->dataLength - size - pos - nalu_len;\n\t\t\tisor_replace_nal(ch, ch->sample->data + pos + nalu_len, size, nal_type, &needs_reset);\n\t\t\tif (move_size)\n\t\t\t\tmemmove(ch->sample->data + pos, ch->sample->data + pos + size + nalu_len, ch->sample->dataLength - size - pos - nalu_len);\n\n\t\t\tch->sample->dataLength -= size + nalu_len;\n\n\t\t\t//remove nal from clear subsample range\n\t\t\tif (ch->pck_encrypted)\n\t\t\t\tisor_sai_bytes_removed(ch, pos, nalu_len+size);\n\t\t}\n\t\t//not skipped, increase pos\n\t\telse {\n\t\t\tpos += nalu_len + size;\n\t\t}\n\t}\n\n\tif (needs_reset) {\n\t\tu8 *dsi=NULL;\n\t\tu32 dsi_size=0;\n\t\tif (ch->check_avc_ps) {\n\t\t\tgf_odf_avc_cfg_write(ch->avcc, &dsi, &dsi_size);\n\t\t}\n\t\telse if (ch->check_hevc_ps) {\n\t\t\tgf_odf_hevc_cfg_write(ch->hvcc, &dsi, &dsi_size);\n\t\t}\n\t\telse if (ch->check_vvc_ps) {\n\t\t\tgf_odf_vvc_cfg_write(ch->vvcc, &dsi, &dsi_size);\n\t\t}\n\t\tif (dsi && dsi_size) {\n\t\t\tu32 dsi_crc = gf_crc_32(dsi, dsi_size);\n\t\t\tif (ch->dsi_crc == dsi_crc) {\n\t\t\t\tgf_free(dsi);\n\t\t\t} else {\n\t\t\t\tch->dsi_crc = dsi_crc;\n\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_DECODER_CONFIG, &PROP_DATA_NO_COPY(dsi, dsi_size) );\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid isor_set_sample_groups_and_aux_data(ISOMReader *read, ISOMChannel *ch, GF_FilterPacket *pck)\n{\n\tchar szPName[100];\n\n\tu32 grp_idx=0;\n\twhile (1) {\n\t\tu32 grp_type=0, grp_size=0, grp_parameter=0, grp_flags=0;\n\t\tu8 *grp_data=NULL;\n\t\tGF_Err e = gf_isom_enum_sample_group(read->mov, ch->track, ch->sample_num, &grp_idx, &grp_type, &grp_flags, &grp_parameter, &grp_data, &grp_size);\n\t\tif (e || !grp_type) break;\n\t\tif (!grp_size || !grp_data) continue;\n\n\t\t//prepare prop name sample groups\n\t\tif (grp_parameter) sprintf(szPName, \"grp_%s_%d\", gf_4cc_to_str(grp_type), grp_parameter);\n\t\telse sprintf(szPName, \"grp_%s\", gf_4cc_to_str(grp_type));\n\t\tif (grp_flags) {\n\t\t\tchar szPFLags[30];\n\t\t\tsprintf(szPFLags, \"_z%x\", grp_flags);\n\t\t\tstrcat(szPName, szPFLags);\n\t\t}\n\n\t\tswitch (grp_type) {\n\t\tcase GF_4CC('P','S','S','H'):\n\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PID_CENC_PSSH, &PROP_DATA_NO_COPY((u8*)grp_data, grp_size) );\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgf_filter_pck_set_property_dyn(pck, szPName, &PROP_DATA_NO_COPY(grp_data, grp_size) );\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tu32 sai_idx=0;\n\twhile (1) {\n\t\tu32 sai_type=0, sai_size=0, sai_parameter=0;\n\t\tu8 *sai_data=NULL;\n\t\tGF_Err e = gf_isom_enum_sample_aux_data(read->mov, ch->track, ch->sample_num, &sai_idx, &sai_type, &sai_parameter, &sai_data, &sai_size);\n\t\tif (e) continue;\n\t\tif (!sai_type) break;\n\t\tif (!sai_size || !sai_data) continue;\n\n\t\t//all other are mapped to sample groups\n\t\tif (sai_parameter) sprintf(szPName, \"sai_%s_%d\", gf_4cc_to_str(sai_type), sai_parameter);\n\t\telse sprintf(szPName, \"sai_%s\", gf_4cc_to_str(sai_type));\n\n\t\tgf_filter_pck_set_property_dyn(pck, szPName, &PROP_DATA_NO_COPY(sai_data, sai_size) );\n\t}\n\n\n\twhile (1) {\n\t\tGF_Err gf_isom_pop_emsg(GF_ISOFile *the_file, u8 **emsg_data, u32 *emsg_size);\n\t\tu8 *data=NULL;\n\t\tu32 size;\n\t\tGF_Err e = gf_isom_pop_emsg(read->mov, &data, &size);\n\t\tif (e || !data) break;\n\n\t\tgf_filter_pck_set_property_str(pck, \"emsg\", &PROP_DATA_NO_COPY(data, size));\n\t}\n\n}\n\n\n#endif // !defined(GPAC_DISABLE_ISOM) && !defined(GPAC_DISABLE_MP4DMX)\n"], "fixing_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2023\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISOBMFF reader filter\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n\n#include \"isoffin.h\"\n\n#if !defined(GPAC_DISABLE_ISOM) && !defined(GPAC_DISABLE_MP4DMX)\n\n#include <gpac/network.h>\n#include <gpac/avparse.h>\n\nGF_Err gf_isom_set_sample_alloc(GF_ISOFile *the_file, u32 trackNumber, \tu8 *(*sample_realloc)(u32 size, void *cbk), void *udta);\n\nvoid isor_reset_reader(ISOMChannel *ch)\n{\n\tch->last_state = GF_OK;\n\tisor_reader_release_sample(ch);\n\n\tif (ch->static_sample) {\n\t\tch->static_sample->dataLength = ch->static_sample->alloc_size;\n\t\tgf_isom_sample_del(&ch->static_sample);\n\t}\n\tch->sample = NULL;\n\tch->sample_num = 0;\n\tch->speed = 1.0;\n\tch->start = ch->end = 0;\n\tch->to_init = 1;\n\tch->playing = 0;\n\tch->nb_empty_retry = 0;\n\tif (ch->sai_buffer) gf_free(ch->sai_buffer);\n\tch->sai_buffer = NULL;\n\tch->sai_alloc_size = 0;\n\tch->dts = ch->cts = 0;\n\tch->seek_flag = 0;\n}\n\nvoid isor_check_producer_ref_time(ISOMReader *read)\n{\n\tGF_ISOTrackID trackID;\n\tu64 ntp;\n\tu64 timestamp;\n\n\tif (gf_sys_is_test_mode()) {\n\t\treturn;\n\t}\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (gf_isom_get_last_producer_time_box(read->mov, &trackID, &ntp, &timestamp, GF_TRUE)) {\n#if !defined(_WIN32_WCE) && !defined(GPAC_DISABLE_LOG)\n\n\t\tif (gf_log_tool_level_on(GF_LOG_DASH, GF_LOG_DEBUG)) {\n\t\t\ttime_t secs;\n\t\t\tstruct tm t;\n\n\t\t\ts32 diff = gf_net_get_ntp_diff_ms(ntp);\n\n\t\t\tsecs = (ntp>>32) - GF_NTP_SEC_1900_TO_1970;\n\t\t\tt = *gf_gmtime(&secs);\n\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, (\"[IsoMedia] TrackID %d: Timestamp \"LLU\" matches sender NTP time %d-%02d-%02dT%02d:%02d:%02dZ - NTP clock diff (local - remote): %d ms\\n\", trackID, timestamp, 1900+t.tm_year, t.tm_mon+1, t.tm_mday, t.tm_hour, t.tm_min, t.tm_sec, diff));\n\t\t}\n#endif\n\t\tread->last_sender_ntp = ntp;\n\t\tread->cts_for_last_sender_ntp = timestamp;\n\t\tread->ntp_at_last_sender_ntp = gf_net_get_ntp_ts();\n\t}\n#endif\n}\n\n\nstatic void init_reader(ISOMChannel *ch)\n{\n\tu32 sample_desc_index=0;\n\n\tch->au_seq_num = 1;\n\n\tassert(ch->sample==NULL);\n\tif (!ch->static_sample) {\n\t\tch->static_sample = gf_isom_sample_new();\n\t}\n\n\tif (ch->streamType==GF_STREAM_OCR) {\n\t\tassert(!ch->sample);\n\t\tch->sample = gf_isom_sample_new();\n\t\tch->sample->IsRAP = RAP;\n\t\tch->sample->DTS = ch->start;\n\t\tch->last_state=GF_OK;\n\t} else if (ch->sample_num) {\n\t\tch->sample = gf_isom_get_sample_ex(ch->owner->mov, ch->track, ch->sample_num, &sample_desc_index, ch->static_sample, &ch->sample_data_offset);\n\t\tch->disable_seek = 1;\n\t\tch->au_seq_num = ch->sample_num;\n\t} else {\n\t\t//if seek is disabled, get the next closest sample for this time; otherwise, get the previous RAP sample for this time\n\t\tu32 mode = ch->disable_seek ? GF_ISOM_SEARCH_BACKWARD : GF_ISOM_SEARCH_SYNC_BACKWARD;\n\n\t\t/*take care of seeking out of the track range*/\n\t\tif (!ch->owner->frag_type && (ch->duration<=ch->start)) {\n\t\t\tch->last_state = gf_isom_get_sample_for_movie_time(ch->owner->mov, ch->track, ch->duration-1, &sample_desc_index, mode, &ch->static_sample, &ch->sample_num, &ch->sample_data_offset);\n\t\t} else if (ch->start || ch->has_edit_list) {\n\t\t\tch->last_state = gf_isom_get_sample_for_movie_time(ch->owner->mov, ch->track, ch->start, &sample_desc_index, mode, &ch->static_sample, &ch->sample_num, &ch->sample_data_offset);\n\t\t} else {\n\t\t\tch->sample_num = 1;\n\t\t\tif (ch->owner->nodata) {\n\t\t\t\tch->sample = gf_isom_get_sample_info_ex(ch->owner->mov, ch->track, ch->sample_num, &sample_desc_index, &ch->sample_data_offset, ch->static_sample);\n\t\t\t} else {\n\t\t\t\tch->sample = gf_isom_get_sample_ex(ch->owner->mov, ch->track, ch->sample_num, &sample_desc_index, ch->static_sample, &ch->sample_data_offset);\n\t\t\t}\n\t\t\tif (!ch->sample) ch->last_state = GF_EOS;\n\t\t}\n\t\tif (ch->last_state) {\n\t\t\tch->sample = NULL;\n\t\t\tch->last_state = GF_OK;\n\t\t} else {\n\t\t\tch->sample = ch->static_sample;\n\t\t}\n\n\t\tif (ch->has_rap && ch->has_edit_list) {\n\t\t\tch->edit_sync_frame = ch->sample_num;\n\t\t}\n\n\t\tif (ch->sample && !ch->sample->data && ch->owner->frag_type && !ch->has_edit_list) {\n\t\t\tch->static_sample->alloc_size = 0;\n\t\t\tch->sample = NULL;\n\t\t\tch->sample_num = 1;\n\t\t\tch->sample = gf_isom_get_sample_ex(ch->owner->mov, ch->track, ch->sample_num, &sample_desc_index, ch->static_sample, &ch->sample_data_offset);\n\t\t}\n\t}\n\n\n\t/*no sample means we're not in the track range - stop*/\n\tif (!ch->sample) {\n\t\t/*incomplete file - check if we're still downloading or not*/\n\t\tif (gf_isom_get_missing_bytes(ch->owner->mov, ch->track)) {\n\t\t\tif (!ch->owner->input_loaded) {\n\t\t\t\tch->last_state = GF_OK;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tch->last_state = GF_ISOM_INCOMPLETE_FILE;\n\t\t} else if (ch->sample_num) {\n\t\t\tch->last_state = (ch->owner->frag_type==1) ? GF_OK : GF_EOS;\n\t\t\tch->to_init = 0;\n\t\t}\n\t\treturn;\n\t}\n\n\tch->sample_time = ch->sample->DTS;\n\n\tch->to_init = 0;\n\n\tch->seek_flag = 0;\n\tif (ch->disable_seek) {\n\t\tch->dts = ch->sample->DTS;\n\t\tch->cts = ch->sample->DTS + ch->sample->CTS_Offset;\n\t\tch->start = 0;\n\t} else {\n\t\ts64 cts;\n\t\tch->dts = ch->start;\n\t\tch->cts = ch->start;\n\n\t\tcts = ch->sample->DTS + ch->sample->CTS_Offset;\n\t\tif (ch->ts_offset<0)\n\t\t\tcts += ch->ts_offset;\n\n\t\t//TODO - we need to notify scene decoder how many secs elapsed between RAP and seek point\n\t\tif (ch->cts != cts) {\n\t\t\tch->seek_flag = 1;\n\t\t}\n\t}\n\tif (!sample_desc_index) sample_desc_index = 1;\n\tch->last_sample_desc_index = sample_desc_index;\n\tch->owner->no_order_check = ch->speed < 0 ? GF_TRUE : GF_FALSE;\n}\n\n\nstatic void isor_update_cenc_info(ISOMChannel *ch, Bool for_item)\n{\n\tGF_Err e;\n\tBool Is_Encrypted;\n\tu32 out_size;\n\tu8 crypt_byte_block, skip_byte_block;\n\tu8 piff_info[20];\n\tu8 *key_info = NULL;\n\tu32 key_info_size = 0;\n\tu8 item_mkey = 0;\n\n\t//this will be skipped anyways, don't fectch ...\n\tif (ch->owner->stsd && (ch->last_sample_desc_index != ch->owner->stsd) && ch->sample) {\n\t\treturn;\n\t}\n\n\n\tout_size = ch->sai_alloc_size;\n\tif (for_item) {\n\t\tu32 aux_info_param=0;\n\t\te = gf_isom_extract_meta_item_get_cenc_info(ch->owner->mov, GF_TRUE, 0, ch->item_id, &Is_Encrypted, &skip_byte_block, &crypt_byte_block, (const u8 **) &key_info, &key_info_size, &aux_info_param, &ch->sai_buffer, &out_size, &ch->sai_alloc_size);\n\n\t\t/*The ienc property is always exposed as a multiple key info in GPAC\n\t\tHowever the type of SAI may be single-key (aux_info_param==0) or multiple-key (aux_info_param==1) for the same ienc used\n\t\tWe therefore temporary force the key info type to single key if v0 SAI CENC are used\n\t\tNote that this is thread safe as this filter is the only one using the opened file\n\t\t*/\n\t\tif (aux_info_param==0) {\n\t\t\titem_mkey = key_info[0];\n\t\t}\n\t} else {\n\t\te = gf_isom_get_sample_cenc_info(ch->owner->mov, ch->track, ch->sample_num, &Is_Encrypted, &crypt_byte_block, &skip_byte_block, (const u8 **) &key_info, &key_info_size);\n\t}\n\tif (!key_info) {\n\t\tpiff_info[0] = 0;\n\t\tpiff_info[1] = 0;\n\t\tpiff_info[2] = 0;\n\t\tpiff_info[3] = key_info_size;\n\t\tmemset(piff_info + 4, 0, 16);\n\t\tkey_info_size = 20;\n\t\tkey_info = (u8 *) piff_info;\n\t}\n\n\n\tif (!for_item && (e==GF_OK) && Is_Encrypted) {\n\t\te = gf_isom_cenc_get_sample_aux_info(ch->owner->mov, ch->track, ch->sample_num, ch->last_sample_desc_index, NULL, &ch->sai_buffer, &out_size);\n\t}\n\n\tif (out_size > ch->sai_alloc_size) ch->sai_alloc_size = out_size;\n\tch->sai_buffer_size = out_size;\n\n\tif (e) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[IsoMedia] Failed to fetch CENC auxiliary info for %s %d: %s\\n\", for_item ? \"item\" : \"track\", for_item ? ch->item_id : ch->track, gf_error_to_string(e) ));\n\t\treturn;\n\t}\n\n\tch->pck_encrypted = Is_Encrypted;\n\tch->cenc_ki = NULL;\n\n\t/*notify change of IV/KID only when packet is encrypted\n\t1- these info are ignored when packet is not encrypted\n\t2- this allows us to define the initial CENC state for multi-stsd cases*/\n\tif (Is_Encrypted) {\n\t\tu32 ki_crc;\n\n\t\tif ((ch->crypt_byte_block != crypt_byte_block) || (ch->skip_byte_block != skip_byte_block)) {\n\t\t\tch->crypt_byte_block = crypt_byte_block;\n\t\t\tch->skip_byte_block = skip_byte_block;\n\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_CENC_PATTERN, &PROP_FRAC_INT(ch->skip_byte_block, ch->crypt_byte_block) );\n\t\t}\n\t\tif (item_mkey)\n\t\t\tkey_info[0] = 0;\n\n\t\tki_crc = gf_crc_32(key_info, key_info_size);\n\t\tif (ch->key_info_crc != ki_crc) {\n\t\t\tch->key_info_crc = ki_crc;\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_CENC_KEY_INFO, &PROP_DATA((u8 *)key_info, key_info_size) );\n\t\t}\n\n\t\tif (item_mkey)\n\t\t\tkey_info[0] = item_mkey;\n\n\t\tch->cenc_ki = gf_filter_pid_get_property(ch->pid, GF_PROP_PID_CENC_KEY_INFO);\n\t}\n}\n\nvoid isor_reader_get_sample_from_item(ISOMChannel *ch)\n{\n\tif (ch->au_seq_num) {\n\t\tif (!ch->owner->itt || !isor_declare_item_properties(ch->owner, ch, 1+ch->au_seq_num)) {\n\t\t\tch->last_state = GF_EOS;\n\t\t\treturn;\n\t\t}\n\t}\n\tch->sample_time = 0;\n\tch->last_state = GF_OK;\n\tif (!ch->static_sample) {\n\t\tch->static_sample = gf_isom_sample_new();\n\t}\n\n\tch->sample = ch->static_sample;\n\tch->sample->IsRAP = RAP;\n\tch->sample->duration = 1000;\n\tch->dts = ch->cts = 1000 * ch->au_seq_num;\n\tgf_isom_extract_meta_item_mem(ch->owner->mov, GF_TRUE, 0, ch->item_id, &ch->sample->data, &ch->sample->dataLength, &ch->static_sample->alloc_size, NULL, GF_FALSE);\n\n\tif (ch->is_encrypted && ch->is_cenc) {\n\t\tisor_update_cenc_info(ch, GF_TRUE);\n\t}\n}\n\nu8 *isor_sample_alloc(u32 size, void *udta)\n{\n\tu8 *output;\n\tISOMChannel *ch = (ISOMChannel *)udta;\n\tif (ch->pck) {\n\t\tif (size<ch->alloc_size) {\n\t\t\tu32 size;\n\t\t\treturn (u8 *) gf_filter_pck_get_data(ch->pck, &size);\n\t\t}\n\t\tgf_filter_pck_expand(ch->pck, size - ch->alloc_size, &output, NULL, NULL);\n\t\tch->alloc_size = size;\n\t\treturn output;\n\t}\n\tch->pck = gf_filter_pck_new_alloc(ch->pid, size, &output);\n\tch->alloc_size = size;\n\treturn output;\n}\n\nvoid isor_reader_get_sample(ISOMChannel *ch)\n{\n\tGF_Err e;\n\tBool skip_sample=GF_FALSE;\n\tu32 sample_desc_index;\n\tif (ch->sample) return;\n\n\tif (ch->next_track) {\n\t\tch->track = ch->next_track;\n\t\tif (!ch->owner->nodata)\n\t\t\tgf_isom_set_sample_alloc(ch->owner->mov, ch->track, isor_sample_alloc, ch);\n\t\tch->next_track = 0;\n\t}\n\n\tif (ch->to_init) {\n\t\tif (!ch->owner->nodata)\n\t\t\tgf_isom_set_sample_alloc(ch->owner->mov, ch->track, isor_sample_alloc, ch);\n\t\tinit_reader(ch);\n\t\tsample_desc_index = ch->last_sample_desc_index;\n\t} else if (ch->speed < 0) {\n\t\tif (ch->last_state == GF_EOS) {\n\t\t\tch->sample = NULL;\n\t\t\treturn;\n\t\t}\n\n\t\tif (ch->static_sample->IsRAP) {\n\t\t\tch->last_rap_sample_time = ch->sample_time;\n\t\t}\n\n\t\te = gf_isom_get_sample_for_movie_time(ch->owner->mov, ch->track, ch->sample_time + 1, &sample_desc_index, GF_ISOM_SEARCH_FORWARD, &ch->static_sample, &ch->sample_num, NULL);\n\t\tch->static_sample->alloc_size = 0;\n\n\t\tif ((e==GF_EOS) || (ch->static_sample->IsRAP)) {\n\t\t\tif (!ch->last_rap_sample_time) {\n\t\t\t\te = GF_EOS;\n\t\t\t} else {\n\t\t\t\te = gf_isom_get_sample_for_movie_time(ch->owner->mov, ch->track, ch->last_rap_sample_time - 1, &sample_desc_index, GF_ISOM_SEARCH_SYNC_BACKWARD, &ch->static_sample, &ch->sample_num, NULL);\n\t\t\t\tch->static_sample->alloc_size = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (e) {\n\t\t\tif ((e==GF_EOS) && !ch->owner->frag_type) {\n\t\t\t\tch->last_state = GF_EOS;\n\t\t\t}\n\t\t\tch->sample = NULL;\n\t\t\treturn;\n\t\t}\n\t\tch->sample = ch->static_sample;\n\n\t\tif (ch->sample->DTS == ch->sample_time) {\n\t\t\tif (!ch->owner->frag_type) {\n\t\t\t\tch->last_state = GF_EOS;\n\t\t\t}\n\t\t}\n\t\tif (ch->sample) {\n\t\t\tch->sample_time = ch->sample->DTS;\n\t\t}\n\n\t} else if (ch->has_edit_list) {\n\t\tu32 prev_sample = ch->sample_num;\n\t\te = gf_isom_get_sample_for_movie_time(ch->owner->mov, ch->track, ch->sample_time + 1, &sample_desc_index, GF_ISOM_SEARCH_FORWARD, &ch->static_sample, &ch->sample_num, &ch->sample_data_offset);\n\t\tch->static_sample->alloc_size = 0;\n\n\t\tif (e == GF_OK) {\n\t\t\tch->sample = ch->static_sample;\n\n\t\t\t/*we are in forced seek mode: fetch all samples before the one matching the sample time*/\n\t\t\tif (ch->edit_sync_frame) {\n\t\t\t\tch->edit_sync_frame++;\n\t\t\t\tif (ch->edit_sync_frame < ch->sample_num) {\n\t\t\t\t\tch->static_sample->alloc_size = 0;\n\t\t\t\t\tch->static_sample->dataLength = 0;\n\t\t\t\t\tch->sample = gf_isom_get_sample_ex(ch->owner->mov, ch->track, ch->edit_sync_frame, &sample_desc_index, ch->static_sample, &ch->sample_data_offset);\n\t\t\t\t\tif (ch->sample) {\n\t\t\t\t\t\tch->sample->DTS = ch->sample_time;\n\t\t\t\t\t\tch->sample->CTS_Offset = 0;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tch->edit_sync_frame = 0;\n\t\t\t\t\tif (ch->sample) ch->sample_time = ch->sample->DTS;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/*if we get the same sample, figure out next interesting time (current sample + DTS gap to next sample should be a good bet)*/\n\t\t\t\tif (prev_sample == ch->sample_num) {\n\t\t\t\t\tif (ch->owner->frag_type && (ch->sample_num==gf_isom_get_sample_count(ch->owner->mov, ch->track))) {\n\t\t\t\t\t\tch->sample = NULL;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tu32 sample_num = ch->sample_num ? ch->sample_num : 1;\n\n\t\t\t\t\t\tif (sample_num >= gf_isom_get_sample_count(ch->owner->mov, ch->track) ) {\n\t\t\t\t\t\t\t//e = GF_EOS;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tu32 time_diff = gf_isom_get_sample_duration(ch->owner->mov, ch->track, sample_num);\n\n\t\t\t\t\t\t\tch->static_sample->alloc_size = 0;\n\t\t\t\t\t\t\tch->static_sample->dataLength = 0;\n\n\t\t\t\t\t\t\te = gf_isom_get_sample_for_movie_time(ch->owner->mov, ch->track, ch->sample_time + time_diff, &sample_desc_index, GF_ISOM_SEARCH_FORWARD, &ch->static_sample, &ch->sample_num, &ch->sample_data_offset);\n\t\t\t\t\t\t\tch->static_sample->alloc_size = 0;\n\t\t\t\t\t\t\tif (e==GF_OK) {\n\t\t\t\t\t\t\t\tif (ch->sample_num == prev_sample) {\n\t\t\t\t\t\t\t\t\tch->sample_time += time_diff;\n\t\t\t\t\t\t\t\t\tch->sample = NULL;\n\t\t\t\t\t\t\t\t\tif (ch->pck) {\n\t\t\t\t\t\t\t\t\t\tgf_filter_pck_discard(ch->pck);\n\t\t\t\t\t\t\t\t\t\tch->pck = NULL;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tch->sample = ch->static_sample;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/*we jumped to another segment - if RAP is needed look for closest rap in decoding order and\n\t\t\t\tforce seek mode*/\n\t\t\t\tif (ch->sample && !ch->sample->IsRAP && ch->has_rap && (ch->sample_num != prev_sample+1)) {\n\t\t\t\t\tGF_ISOSample *found = ch->static_sample;\n\t\t\t\t\tu32 samp_num = ch->sample_num;\n\t\t\t\t\tch->sample = NULL;\n\t\t\t\t\tch->static_sample->alloc_size = 0;\n\t\t\t\t\tch->static_sample->dataLength = 0;\n\t\t\t\t\te = gf_isom_get_sample_for_movie_time(ch->owner->mov, ch->track, ch->sample_time + 1, &sample_desc_index, GF_ISOM_SEARCH_SYNC_BACKWARD, &ch->static_sample, &ch->sample_num, &ch->sample_data_offset);\n\n\t\t\t\t\tch->static_sample->alloc_size = 0;\n\t\t\t\t\tch->sample = (e == GF_OK) ? ch->static_sample : NULL;\n\n\t\t\t\t\t/*if no sync point in the past, use the first non-sync for the given time*/\n\t\t\t\t\tif (!ch->sample || !ch->sample->data) {\n\t\t\t\t\t\tch->sample = ch->static_sample = found;\n\t\t\t\t\t\tch->sample_time = ch->sample->DTS;\n\t\t\t\t\t\tch->sample_num = samp_num;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tch->sample = ch->static_sample;\n\t\t\t\t\t\tch->edit_sync_frame = ch->sample_num;\n\t\t\t\t\t\tch->sample->DTS = ch->sample_time;\n\t\t\t\t\t\tch->sample->CTS_Offset = 0;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (ch->sample) ch->sample_time = ch->sample->DTS;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tBool do_fetch = GF_TRUE;\n\t\tch->sample_num++;\n\t\tif (ch->sample_last && (ch->sample_last<ch->sample_num)) {\n\t\t\tch->sample = NULL;\n\t\t\tch->last_state = GF_EOS;\n\t\t\tch->playing = 2;\n\t\t\treturn;\n\t\t}\n\n\t\tif (ch->sap_only) {\n\t\t\tBool is_rap = gf_isom_get_sample_sync(ch->owner->mov, ch->track, ch->sample_num);\n\t\t\tif (!is_rap) {\n\t\t\t\tGF_ISOSampleRollType roll_type;\n\t\t\t\tgf_isom_get_sample_rap_roll_info(ch->owner->mov, ch->track, ch->sample_num, &is_rap, &roll_type, NULL);\n\t\t\t\tif (roll_type) is_rap = GF_TRUE;\n\t\t\t}\n\n\t\t\tif (!is_rap) {\n\t\t\t\tdo_fetch = GF_FALSE;\n\t\t\t} else if (ch->sap_only==2) {\n\t\t\t\tch->sap_only = 0;\n\t\t\t}\n\t\t}\n\t\tif (do_fetch) {\n\t\t\tif (ch->owner->nodata) {\n\t\t\t\tch->sample = gf_isom_get_sample_info_ex(ch->owner->mov, ch->track, ch->sample_num, &sample_desc_index, &ch->sample_data_offset, ch->static_sample);\n\t\t\t} else {\n\t\t\t\tch->sample = gf_isom_get_sample_ex(ch->owner->mov, ch->track, ch->sample_num, &sample_desc_index, ch->static_sample, &ch->sample_data_offset);\n\t\t\t}\n\t\t\t/*if sync shadow / carousel RAP skip*/\n\t\t\tif (ch->sample && (ch->sample->IsRAP==RAP_REDUNDANT)) {\n\t\t\t\tch->sample = NULL;\n\t\t\t\tch->sample_num++;\n\t\t\t\tif (ch->pck) {\n\t\t\t\t\tgf_filter_pck_discard(ch->pck);\n\t\t\t\t\tch->pck = NULL;\n\t\t\t\t\tch->static_sample->alloc_size = ch->static_sample->dataLength = 0;\n\t\t\t\t}\n\t\t\t\tisor_reader_get_sample(ch);\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\tskip_sample = GF_TRUE;\n\t\t}\n\t}\n\n\t//check scalable track change\n\tif (ch->sample && ch->sample->IsRAP && ch->next_track) {\n\t\tch->track = ch->next_track;\n\t\tch->next_track = 0;\n\t\tch->sample = NULL;\n\t\tif (ch->pck) {\n\t\t\tgf_filter_pck_discard(ch->pck);\n\t\t\tch->pck = NULL;\n\t\t}\n\t\tisor_reader_get_sample(ch);\n\t\treturn;\n\t}\n\n\tif (!ch->sample) {\n\t\tu32 sample_count = gf_isom_get_sample_count(ch->owner->mov, ch->track);\n\t\tch->sample_data_offset = 0;\n\t\t/*incomplete file - check if we're still downloading or not*/\n\t\tif (gf_isom_get_missing_bytes(ch->owner->mov, ch->track)) {\n\t\t\tch->last_state = GF_ISOM_INCOMPLETE_FILE;\n\t\t\tif (ch->owner->mem_load_mode==2)\n\t\t\t\tch->owner->force_fetch = GF_TRUE;\n\n\t\t\tif (!ch->owner->input_loaded) {\n\t\t\t\tch->last_state = GF_OK;\n\t\t\t\tif (!ch->has_edit_list && ch->sample_num)\n\t\t\t\t\tch->sample_num--;\n\t\t\t} else {\n\t\t\t\tif (ch->to_init && ch->sample_num) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[IsoMedia] Failed to fetch initial sample %d for track %d\\n\", ch->sample_num, ch->track));\n\t\t\t\t\tch->last_state = GF_ISOM_INVALID_FILE;\n\t\t\t\t} else {\n\t\t\t\t\tif (!ch->eos_sent) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[IsoMedia] File truncated, aborting read for track %d\\n\", ch->track));\n\t\t\t\t\t}\n\t\t\t\t\tch->last_state = GF_EOS;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (!ch->sample_num\n\t\t         || ((ch->speed >= 0) && (ch->sample_num >= sample_count))\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t         || ((ch->speed < 0) && (ch->sample_time == gf_isom_get_current_tfdt(ch->owner->mov, ch->track) ))\n#endif\n\t\t) {\n\n\t\t\tif (ch->owner->frag_type==1) {\n\t\t\t\t/*if sample cannot be found and file is fragmented, rewind sample*/\n\t\t\t\tif (ch->sample_num) ch->sample_num--;\n\t\t\t\tch->last_state = GF_EOS;\n\t\t\t} else if (ch->last_state != GF_EOS) {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[IsoMedia] Track #%d end of stream reached\\n\", ch->track));\n\t\t\t\tch->last_state = GF_EOS;\n\t\t\t\tif (ch->sample_num>sample_count) ch->sample_num = sample_count;\n\t\t\t} else {\n\t\t\t\tif (ch->sample_num>sample_count) ch->sample_num = sample_count;\n\t\t\t}\n\t\t} else if (!skip_sample) {\n\t\t\te = gf_isom_last_error(ch->owner->mov);\n\t\t\tGF_LOG((e==GF_ISOM_INCOMPLETE_FILE) ? GF_LOG_DEBUG : GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[IsoMedia] Track #%d fail to fetch sample %d / %d: %s\\n\", ch->track, ch->sample_num, gf_isom_get_sample_count(ch->owner->mov, ch->track), gf_error_to_string(e) ));\n\n\t\t\tif ((e<GF_OK) && (e!=GF_ISOM_INCOMPLETE_FILE)) {\n\t\t\t\tch->last_state = GF_EOS;\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\t//first sample fetched has DTS, we have a tfdt so ignore the hinted one\n\tif ((ch->sample_num==1) && ch->hint_first_tfdt && ch->sample->DTS) {\n\t\tch->hint_first_tfdt = 0;\n\t}\n\tch->sample->DTS += ch->hint_first_tfdt;\n\n\tif (sample_desc_index != ch->last_sample_desc_index) {\n\t\tif (!ch->owner->stsd) {\n\t\t\t//we used sample entry 1 by default to setup, if no active prev sample (edit list might trigger this)\n\t\t\t//and new sample desc is 1, do not reconfigure\n\t\t\tif (!ch->last_sample_desc_index && (sample_desc_index==1)) {\n\n\t\t\t} else {\n\t\t\t\tch->needs_pid_reconfig = 1;\n\t\t\t}\n\t\t}\n\t\tch->last_sample_desc_index = sample_desc_index;\n\t}\n\n\tch->last_state = GF_OK;\n\n\tch->sap_3 = GF_FALSE;\n\tch->sap_4_type = 0;\n\tch->roll = 0;\n\n\tif (ch->sample) {\n\t\tgf_isom_get_sample_rap_roll_info(ch->owner->mov, ch->track, ch->sample_num, &ch->sap_3, &ch->sap_4_type, &ch->roll);\n\n\t\t/*still seeking or not ?\n\t\t 1- when speed is negative, the RAP found is \"after\" the seek point in playback order since we used backward RAP search: nothing to do\n\t\t 2- otherwise set DTS+CTS to start value\n\t\t */\n\t\tif ((ch->speed < 0) || (ch->start <= ch->sample->DTS + ch->sample->CTS_Offset)) {\n\t\t\tch->dts = ch->sample->DTS;\n\t\t\tch->cts = ch->sample->DTS + ch->sample->CTS_Offset;\n\t\t\tch->seek_flag = 0;\n\t\t} else {\n\t\t\tch->cts = ch->start;\n\t\t\tch->seek_flag = 1;\n\t\t\tch->dts = ch->start;\n\t\t}\n\n\t\tif (ch->end && (ch->end < ch->sample->DTS + ch->sample->CTS_Offset + ch->sample->duration)) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[IsoMedia] End of Channel \"LLD\" (CTS \"LLD\")\\n\", ch->end, ch->sample->DTS + ch->sample->CTS_Offset));\n\t\t\tch->sample = NULL;\n\t\t\tch->last_state = GF_EOS;\n\t\t\tch->playing = 2;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (ch->owner->last_sender_ntp && ch->cts==ch->owner->cts_for_last_sender_ntp) {\n\t\tch->sender_ntp = ch->owner->last_sender_ntp;\n\t\tch->ntp_at_server_ntp = ch->owner->ntp_at_last_sender_ntp;\n\t} else if (ch->owner->last_sender_ntp && ch->dts==ch->owner->cts_for_last_sender_ntp) {\n\t\tch->sender_ntp = ch->owner->last_sender_ntp;\n\t\tch->ntp_at_server_ntp = ch->owner->ntp_at_last_sender_ntp;\n\t} else {\n\t\tch->sender_ntp = ch->ntp_at_server_ntp = 0;\n\t}\n\n\tif (!ch->sample_num) return;\n\n\tgf_isom_get_sample_flags(ch->owner->mov, ch->track, ch->sample_num, &ch->isLeading, &ch->dependsOn, &ch->dependedOn, &ch->redundant);\n\n\tif (ch->is_encrypted) {\n\t\t/*in case of CENC: we write sample auxiliary information to slh->sai; its size is in saiz*/\n\t\tif (gf_isom_is_cenc_media(ch->owner->mov, ch->track, ch->last_sample_desc_index)) {\n\t\t\tisor_update_cenc_info(ch, GF_FALSE);\n\n\t\t} else if (gf_isom_is_media_encrypted(ch->owner->mov, ch->track, ch->last_sample_desc_index)) {\n\t\t\tch->pck_encrypted = GF_TRUE;\n\t\t} else {\n\t\t\tch->pck_encrypted = GF_FALSE;\n\t\t}\n\t}\n\tif (ch->sample && ch->sample->nb_pack)\n\t\tch->sample_num += ch->sample->nb_pack-1;\n}\n\nvoid isor_reader_release_sample(ISOMChannel *ch)\n{\n\tif (ch->sample)\n\t\tch->au_seq_num++;\n\tch->sample = NULL;\n\tch->sai_buffer_size = 0;\n}\n\nenum\n{\n\tRESET_STATE_VPS=1,\n\tRESET_STATE_SPS=1<<1,\n\tRESET_STATE_PPS=1<<2,\n\tRESET_STATE_SPS_EXT=1<<3,\n\tRESET_STATE_DCI=1<<4,\n};\n\n#include <gpac/internal/media_dev.h>\n\n//quick way of reading ID of AVC/HEVC/VVC param sets\nstatic s32 isor_ps_get_id(u8 nal_type, u8 *data, u32 size, Bool is_avc)\n{\n\ts32 res=-1;\n\tGF_BitStream *bs = gf_bs_new(data, size, GF_BITSTREAM_READ);\n\tgf_bs_enable_emulation_byte_removal(bs, GF_TRUE);\n\tswitch (nal_type) {\n\tcase GF_AVC_NALU_PIC_PARAM:\n\t\tgf_bs_read_u8(bs); //nal header\n\t\tres = gf_bs_read_ue(bs);\n\t\tbreak;\n\tcase GF_AVC_NALU_SEQ_PARAM:\n\t\tgf_bs_read_u32(bs); //nal header + start of sps\n\t\tres = gf_bs_read_ue(bs);\n\t\tbreak;\n\tcase GF_HEVC_NALU_VID_PARAM:\n\t\tgf_bs_read_u16(bs); //nal header\n\t\tres = gf_bs_read_int(bs, 4);\n\t\tbreak;\n\tcase GF_HEVC_NALU_SEQ_PARAM:\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\tres = gf_hevc_read_sps(data, size, NULL);\n#else\n\t\tres = -1;\n#endif\n\t\tbreak;\n\tcase GF_HEVC_NALU_PIC_PARAM:\n\t\tgf_bs_read_u16(bs); //nal header\n\t\tres = gf_bs_read_ue(bs);\n\t\tbreak;\n\tcase GF_VVC_NALU_VID_PARAM:\n\t\tgf_bs_read_u16(bs); //nal header\n\t\tres = gf_bs_read_int(bs, 4);\n\t\tbreak;\n\tcase GF_VVC_NALU_SEQ_PARAM:\n\t\tgf_bs_read_u16(bs); //nal header\n\t\tres = gf_bs_read_int(bs, 4);\n\t\tbreak;\n\tcase GF_VVC_NALU_PIC_PARAM:\n\t\tgf_bs_read_u16(bs); //nal header\n\t\tres = gf_bs_read_int(bs, 6);\n\t\tbreak;\n\t//case GF_AVC_NALU_SEQ_PARAM_EXT: - same value as VVC_DEC_PARAM\n\tcase GF_VVC_NALU_DEC_PARAM:\n\t\tif (is_avc) {\n\t\t\tgf_bs_read_u8(bs); //nal header\n\t\t\tres = (s32) gf_bs_read_ue(bs);\n\t\t} else {\n\t\t\tres = 0; //no ID for DCI\n\t\t}\n\t\tbreak;\n\t}\n\tgf_bs_del(bs);\n\treturn res;\n}\n\nstatic void isor_reset_seq_list(GF_List *list)\n{\n   while (gf_list_count(list)) {\n\t\t   GF_NALUFFParam *sl = gf_list_pop_back(list);\n\t\t   gf_free(sl->data);\n\t\t   gf_free(sl);\n   }\n}\n\nstatic void isor_reset_all_ps(ISOMChannel *ch)\n{\n\tu32 i, count;\n\tif (ch->avcc) {\n\t\tisor_reset_seq_list(ch->avcc->pictureParameterSets);\n\t\tisor_reset_seq_list(ch->avcc->sequenceParameterSets);\n\t\tisor_reset_seq_list(ch->avcc->sequenceParameterSetExtensions);\n\t}\n\telse if (ch->hvcc) {\n\t\tcount = gf_list_count(ch->hvcc->param_array);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_NALUFFParamArray *hvca = gf_list_get(ch->hvcc->param_array, i);\n\t\t\tisor_reset_seq_list(hvca->nalus);\n\t\t}\n\t}\n\telse if (ch->vvcc) {\n\t\tcount = gf_list_count(ch->vvcc->param_array);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_NALUFFParamArray *vvca = gf_list_get(ch->vvcc->param_array, i);\n\t\t\tisor_reset_seq_list(vvca->nalus);\n\t\t}\n\t}\n}\n\nstatic void isor_replace_nal(ISOMChannel *ch, u8 *data, u32 size, u8 nal_type, Bool *needs_reset)\n{\n\ts32 ps_id;\n\tu32 i, count, state=0;\n\tGF_NALUFFParam *sl;\n\tGF_List *list=NULL;\n\tif (ch->avcc) {\n\t\tif (nal_type==GF_AVC_NALU_PIC_PARAM) {\n\t\t\tlist = ch->avcc->pictureParameterSets;\n\t\t\tstate=RESET_STATE_PPS;\n\t\t} else if (nal_type==GF_AVC_NALU_SEQ_PARAM) {\n\t\t\tlist = ch->avcc->sequenceParameterSets;\n\t\t\tstate=RESET_STATE_SPS;\n\t\t} else if (nal_type==GF_AVC_NALU_SEQ_PARAM_EXT) {\n\t\t\tlist = ch->avcc->sequenceParameterSetExtensions;\n\t\t\tstate=RESET_STATE_SPS_EXT;\n\t\t} else return;\n\t}\n\telse if (ch->hvcc) {\n\t\tGF_NALUFFParamArray *hvca=NULL;\n\t\tcount = gf_list_count(ch->hvcc->param_array);\n\t\tfor (i=0; i<count; i++) {\n\t\t\thvca = gf_list_get(ch->hvcc->param_array, i);\n\t\t\tif (hvca->type==nal_type) {\n\t\t\t\tlist = hvca->nalus;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\thvca = NULL;\n\t\t}\n\t\tif (!hvca) {\n\t\t\tGF_SAFEALLOC(hvca, GF_NALUFFParamArray);\n\t\t\tif (hvca) {\n\t\t\t\tlist = hvca->nalus = gf_list_new();\n\t\t\t\thvca->type = nal_type;\n\t\t\t\tgf_list_add(ch->hvcc->param_array, hvca);\n\t\t\t}\n\t\t}\n\t\tswitch (nal_type) {\n\t\tcase GF_HEVC_NALU_VID_PARAM:\n\t\t\tstate = RESET_STATE_VPS;\n\t\t\tbreak;\n\t\tcase GF_HEVC_NALU_SEQ_PARAM:\n\t\t\tstate = RESET_STATE_SPS;\n\t\t\tbreak;\n\t\tcase GF_HEVC_NALU_PIC_PARAM:\n\t\t\tstate = RESET_STATE_PPS;\n\t\t\tbreak;\n\t\t}\n\t}\n\telse if (ch->vvcc) {\n\t\tGF_NALUFFParamArray *vvca=NULL;\n\t\tcount = gf_list_count(ch->vvcc->param_array);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tvvca = gf_list_get(ch->vvcc->param_array, i);\n\t\t\tif (vvca->type==nal_type) {\n\t\t\t\tlist = vvca->nalus;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvvca = NULL;\n\t\t}\n\t\tif (!vvca) {\n\t\t\tGF_SAFEALLOC(vvca, GF_NALUFFParamArray);\n\t\t\tif (vvca) {\n\t\t\t\tlist = vvca->nalus = gf_list_new();\n\t\t\t\tvvca->type = nal_type;\n\t\t\t\tgf_list_add(ch->vvcc->param_array, vvca);\n\t\t\t}\n\t\t}\n\t\tswitch (nal_type) {\n\t\tcase GF_VVC_NALU_VID_PARAM:\n\t\t\tstate = RESET_STATE_VPS;\n\t\t\tbreak;\n\t\tcase GF_VVC_NALU_SEQ_PARAM:\n\t\t\tstate = RESET_STATE_SPS;\n\t\t\tbreak;\n\t\tcase GF_VVC_NALU_PIC_PARAM:\n\t\t\tstate = RESET_STATE_PPS;\n\t\t\tbreak;\n\t\tcase GF_VVC_NALU_DEC_PARAM:\n\t\t\tstate = RESET_STATE_DCI;\n\t\t\tbreak;\n\t\t}\n\t}\n\t//get ps\n\tps_id = 1 + isor_ps_get_id(nal_type, data, size, ch->avcc ? 1 : 0);\n\n\tcount = gf_list_count(list);\n\tfor (i=0; i<count; i++) {\n\t\tsl = gf_list_get(list, i);\n\t\tif (!sl->id) {\n\t\t\tsl->id = 1 + isor_ps_get_id(nal_type, sl->data, sl->size, ch->avcc ? 1 : 0);\n\t\t}\n\t\tif (sl->id != ps_id) {\n\t\t\t//reset everything whenever we change ID of seq / vps / dci\n\t\t\tif (!ch->xps_mask && (state != RESET_STATE_PPS)) {\n\t\t\t\tisor_reset_all_ps(ch);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((sl->size==size) && !memcmp(sl->data, data, size)) {\n\t\t\tch->xps_mask |= state;\n\t\t\treturn;\n\t\t}\n\t\tif (state == RESET_STATE_PPS) {\n\t\t\t//PS modified, copy\n\t\t\tsl->data = gf_realloc(sl->data, size);\n\t\t\tmemcpy(sl->data, data, size);\n\t\t\tsl->size = size;\n\t\t\t*needs_reset = 1;\n\t\t\tch->xps_mask |= state;\n\t\t\treturn;\n\t\t}\n\t\t//reset, same as above\n\t\telse if (!ch->xps_mask) {\n\t\t\tisor_reset_all_ps(ch);\n\t\t\tbreak;\n\t\t}\n\t}\n\tch->xps_mask |= state;\n\t*needs_reset = 1;\n\n\tGF_SAFEALLOC(sl, GF_NALUFFParam);\n\tif (!sl) return;\n\tsl->data = gf_malloc(sizeof(char)*size);\n\tmemcpy(sl->data, data, size);\n\tsl->size = size;\n\tsl->id = ps_id;\n\tgf_list_add(list, sl);\n}\n\nu8 key_info_get_iv_size(const u8 *key_info, u32 nb_keys, u32 idx, u8 *const_iv_size, const u8 **const_iv);\n\nvoid isor_sai_bytes_removed(ISOMChannel *ch, u32 pos, u32 removed)\n{\n\tu32 offset = 0;\n\tu8 *sai;\n\tu32 sai_size, cur_pos;\n\tu32 sub_count_size = 0;\n\tu32 i, subs_count = 0;\n\n\tif (!ch->cenc_ki || !ch->sai_buffer) return;\n\n\tsai = ch->sai_buffer;\n\tsai_size = ch->sai_buffer_size;\n\n\t//multikey\n\tif (ch->cenc_ki->value.data.ptr[0]) {\n\t\tu32 remain;\n\t\tu32 j, nb_iv_init = sai[0];\n\t\tnb_iv_init <<= 8;\n\t\tnb_iv_init |= sai[1];\n\t\tu8 *sai_p = sai + 2;\n\t\tremain = sai_size-2;\n\n\t\tfor (j=0; j<nb_iv_init; j++) {\n\t\t\tu32 mk_iv_size;\n\t\t\tu32 idx = sai_p[0];\n\t\t\tidx<<=8;\n\t\t\tidx |= sai_p[1];\n\n\t\t\tmk_iv_size = key_info_get_iv_size(ch->cenc_ki->value.data.ptr, ch->cenc_ki->value.data.size, idx, NULL, NULL);\n\t\t\tmk_iv_size += 2; //idx\n\t\t\tif (mk_iv_size > remain) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Invalid multi-key CENC SAI, cannot modify first subsample !\\n\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsai_p += mk_iv_size;\n\t\t\tremain -= mk_iv_size;\n\t\t}\n\t\toffset = (u32) (sai_p - sai);\n\t\tsub_count_size = 4; //32bit sub count\n\n\t} else {\n\t\toffset = key_info_get_iv_size(ch->cenc_ki->value.data.ptr, ch->cenc_ki->value.data.size, 1, NULL, NULL);\n\t\tsub_count_size = 2; //16bit sub count\n\t}\n\tif (sai_size < offset + sub_count_size) return;\n\n\tsai += offset;\n\tif (sub_count_size==2) {\n\t\tsubs_count = ((u32) sai[0]) << 8 | sai[1];\n\t} else {\n\t\tsubs_count = GF_4CC(sai[0], sai[1], sai[2], sai[3]);\n\t}\n\tsai += sub_count_size;\n\tsai_size -= offset + sub_count_size;\n\tcur_pos = 0;\n\tfor (i=0; i<subs_count; i++) {\n\t\tif (sai_size<6)\n\t\t\treturn;\n\t\tu32 clear = ((u32) sai[0]) << 8 | sai[1];\n\t\tu32 crypt = GF_4CC(sai[2], sai[3], sai[4], sai[5]);\n\t\tif (cur_pos + clear > pos) {\n\t\t\tclear -= removed;\n\t\t\tsai[0] = (clear>>8) & 0xFF;\n\t\t\tsai[1] = (clear) & 0xFF;\n\t\t\treturn;\n\t\t}\n\t\tcur_pos += clear + crypt;\n\t\tsai += 6;\n\t\tsai_size-=6;\n\t}\n}\n\nvoid isor_reader_check_config(ISOMChannel *ch)\n{\n\tu32 nalu_len, pos;\n\tBool needs_reset;\n\tif (!ch->check_hevc_ps && !ch->check_avc_ps && !ch->check_vvc_ps && !ch->check_mhas_pl) return;\n\n\tif (!ch->sample || !ch->sample->data) return;\n\tch->xps_mask = 0;\n\n\t//we cannot touch the payload if encrypted but not CENC !!\n\tif (ch->is_encrypted && !ch->is_cenc)\n\t\treturn;\n\n\tif (ch->check_mhas_pl) {\n\t\t//we cannot touch the payload if encrypted !!\n\t\tif (ch->pck_encrypted) return;\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\tu64 ch_layout = 0;\n\t\ts32 PL = gf_mpegh_get_mhas_pl(ch->sample->data, ch->sample->dataLength, &ch_layout);\n\t\tif (PL>0) {\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_PROFILE_LEVEL, &PROP_UINT((u32) PL));\n\t\t\tch->check_mhas_pl = 0;\n\t\t\tif (ch_layout)\n\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_CHANNEL_LAYOUT, &PROP_LONGUINT(ch_layout));\n\t\t}\n#endif\n\t\treturn;\n\t}\n\t//analyze mode, do not rewrite\n\tif (ch->owner->analyze) return;\n\n\t//we cannot touch the payload if encrypted but no SAI buffer\n\tif (ch->pck_encrypted && !ch->sai_buffer)\n\t\treturn;\n\n\tnalu_len = 4;\n\tif (ch->avcc) nalu_len = ch->avcc->nal_unit_size;\n\telse if (ch->hvcc) nalu_len = ch->hvcc->nal_unit_size;\n\telse if (ch->vvcc) nalu_len = ch->vvcc->nal_unit_size;\n\n\tif (!nalu_len) return;\n\tneeds_reset = 0;\n\n\tpos = 0;\n\n\twhile (1) {\n\t\tBool replace_nal = GF_FALSE;\n\t\tu8 nal_type=0;\n\t\tif (pos + nalu_len >= ch->sample->dataLength) break;\n\t\tu32 tmp=0, size = 0;\n\t\twhile (tmp<nalu_len-1) {\n\t\t\tsize |= ch->sample->data[pos+tmp];\n\t\t\ttmp++;\n\t\t\tsize<<=8;\n\t\t}\n\t\tsize |= ch->sample->data[pos+tmp];\n\t\t//we allow nal_size=0 for incomplete files, abort as soon as we see one to avoid parsing thousands of 0 bytes\n\t\tif (!size) break;\n\n\t\t//this takes care of size + pos + nalu_len > 0 but (s32) size < 0 ...\n\t\tif (ch->sample->dataLength < size) break;\n\t\tif (ch->sample->dataLength < size + pos + nalu_len) break;\n\t\tif (ch->check_avc_ps) {\n\t\t\tu8 hdr = ch->sample->data[pos + nalu_len];\n\t\t\tnal_type = hdr & 0x1F;\n\t\t\tswitch (nal_type) {\n\t\t\tcase GF_AVC_NALU_SEQ_PARAM:\n\t\t\tcase GF_AVC_NALU_SEQ_PARAM_EXT:\n\t\t\tcase GF_AVC_NALU_PIC_PARAM:\n\t\t\t\treplace_nal = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse if (ch->check_hevc_ps) {\n\t\t\tu8 hdr = ch->sample->data[pos + nalu_len];\n\t\t\tnal_type = (hdr & 0x7E) >> 1;\n\t\t\tswitch (nal_type) {\n\t\t\tcase GF_HEVC_NALU_VID_PARAM:\n\t\t\tcase GF_HEVC_NALU_SEQ_PARAM:\n\t\t\tcase GF_HEVC_NALU_PIC_PARAM:\n\t\t\t\treplace_nal = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse if (ch->check_vvc_ps) {\n\t\t\tu8 hdr = ch->sample->data[pos + nalu_len + 1];\n\t\t\tnal_type = hdr >> 3;\n\t\t\tswitch (nal_type) {\n\t\t\tcase GF_VVC_NALU_VID_PARAM:\n\t\t\tcase GF_VVC_NALU_SEQ_PARAM:\n\t\t\tcase GF_VVC_NALU_PIC_PARAM:\n\t\t\tcase GF_VVC_NALU_DEC_PARAM:\n\t\t\tcase GF_VVC_NALU_OPI:\n\t\t\t\treplace_nal = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (replace_nal) {\n\t\t\tu32 move_size = ch->sample->dataLength - size - pos - nalu_len;\n\t\t\tisor_replace_nal(ch, ch->sample->data + pos + nalu_len, size, nal_type, &needs_reset);\n\t\t\tif (move_size)\n\t\t\t\tmemmove(ch->sample->data + pos, ch->sample->data + pos + size + nalu_len, ch->sample->dataLength - size - pos - nalu_len);\n\n\t\t\tch->sample->dataLength -= size + nalu_len;\n\n\t\t\t//remove nal from clear subsample range\n\t\t\tif (ch->pck_encrypted)\n\t\t\t\tisor_sai_bytes_removed(ch, pos, nalu_len+size);\n\t\t}\n\t\t//not skipped, increase pos\n\t\telse {\n\t\t\tpos += nalu_len + size;\n\t\t}\n\t}\n\n\tif (needs_reset) {\n\t\tu8 *dsi=NULL;\n\t\tu32 dsi_size=0;\n\t\tif (ch->check_avc_ps) {\n\t\t\tgf_odf_avc_cfg_write(ch->avcc, &dsi, &dsi_size);\n\t\t}\n\t\telse if (ch->check_hevc_ps) {\n\t\t\tgf_odf_hevc_cfg_write(ch->hvcc, &dsi, &dsi_size);\n\t\t}\n\t\telse if (ch->check_vvc_ps) {\n\t\t\tgf_odf_vvc_cfg_write(ch->vvcc, &dsi, &dsi_size);\n\t\t}\n\t\tif (dsi && dsi_size) {\n\t\t\tu32 dsi_crc = gf_crc_32(dsi, dsi_size);\n\t\t\tif (ch->dsi_crc == dsi_crc) {\n\t\t\t\tgf_free(dsi);\n\t\t\t} else {\n\t\t\t\tch->dsi_crc = dsi_crc;\n\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_DECODER_CONFIG, &PROP_DATA_NO_COPY(dsi, dsi_size) );\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid isor_set_sample_groups_and_aux_data(ISOMReader *read, ISOMChannel *ch, GF_FilterPacket *pck)\n{\n\tchar szPName[100];\n\n\tu32 grp_idx=0;\n\twhile (1) {\n\t\tu32 grp_type=0, grp_size=0, grp_parameter=0, grp_flags=0;\n\t\tu8 *grp_data=NULL;\n\t\tGF_Err e = gf_isom_enum_sample_group(read->mov, ch->track, ch->sample_num, &grp_idx, &grp_type, &grp_flags, &grp_parameter, &grp_data, &grp_size);\n\t\tif (e || !grp_type) break;\n\t\tif (!grp_size || !grp_data) continue;\n\n\t\t//prepare prop name sample groups\n\t\tif (grp_parameter) sprintf(szPName, \"grp_%s_%d\", gf_4cc_to_str(grp_type), grp_parameter);\n\t\telse sprintf(szPName, \"grp_%s\", gf_4cc_to_str(grp_type));\n\t\tif (grp_flags) {\n\t\t\tchar szPFLags[30];\n\t\t\tsprintf(szPFLags, \"_z%x\", grp_flags);\n\t\t\tstrcat(szPName, szPFLags);\n\t\t}\n\n\t\tswitch (grp_type) {\n\t\tcase GF_4CC('P','S','S','H'):\n\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PID_CENC_PSSH, &PROP_DATA_NO_COPY((u8*)grp_data, grp_size) );\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgf_filter_pck_set_property_dyn(pck, szPName, &PROP_DATA_NO_COPY(grp_data, grp_size) );\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tu32 sai_idx=0;\n\twhile (1) {\n\t\tu32 sai_type=0, sai_size=0, sai_parameter=0;\n\t\tu8 *sai_data=NULL;\n\t\tGF_Err e = gf_isom_enum_sample_aux_data(read->mov, ch->track, ch->sample_num, &sai_idx, &sai_type, &sai_parameter, &sai_data, &sai_size);\n\t\tif (e) continue;\n\t\tif (!sai_type) break;\n\t\tif (!sai_size || !sai_data) continue;\n\n\t\t//all other are mapped to sample groups\n\t\tif (sai_parameter) sprintf(szPName, \"sai_%s_%d\", gf_4cc_to_str(sai_type), sai_parameter);\n\t\telse sprintf(szPName, \"sai_%s\", gf_4cc_to_str(sai_type));\n\n\t\tgf_filter_pck_set_property_dyn(pck, szPName, &PROP_DATA_NO_COPY(sai_data, sai_size) );\n\t}\n\n\n\twhile (1) {\n\t\tGF_Err gf_isom_pop_emsg(GF_ISOFile *the_file, u8 **emsg_data, u32 *emsg_size);\n\t\tu8 *data=NULL;\n\t\tu32 size;\n\t\tGF_Err e = gf_isom_pop_emsg(read->mov, &data, &size);\n\t\tif (e || !data) break;\n\n\t\tgf_filter_pck_set_property_str(pck, \"emsg\", &PROP_DATA_NO_COPY(data, size));\n\t}\n\n}\n\n\n#endif // !defined(GPAC_DISABLE_ISOM) && !defined(GPAC_DISABLE_MP4DMX)\n"], "filenames": ["src/filters/isoffin_read_ch.c"], "buggy_code_start_loc": [397], "buggy_code_end_loc": [439], "fixing_code_start_loc": [398], "fixing_code_end_loc": [452], "type": "CWE-415", "message": "GPAC v2.3-DEV-rev566-g50c2ab06f-master was discovered to contain a double free via the gf_filterpacket_del function at /gpac/src/filter_core/filter.c.", "other": {"cve": {"id": "CVE-2023-48013", "sourceIdentifier": "cve@mitre.org", "published": "2023-11-15T19:15:07.753", "lastModified": "2023-11-22T17:42:31.463", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "GPAC v2.3-DEV-rev566-g50c2ab06f-master was discovered to contain a double free via the gf_filterpacket_del function at /gpac/src/filter_core/filter.c."}, {"lang": "es", "value": "Se descubri\u00f3 que GPAC v2.3-DEV-rev566-g50c2ab06f-master contiene un doble libre a trav\u00e9s de la funci\u00f3n gf_filterpacket_del en /gpac/src/filter_core/filter.c."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-415"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gpac:gpac:2.3-dev-rev566-g50c2ab06f-master:*:*:*:*:*:*:*", "matchCriteriaId": "ECEFB340-26A2-43CD-A8DC-518262E4DC36"}]}]}], "references": [{"url": "https://github.com/gpac/gpac/commit/cd8a95c1efb8f5bfc950b86c2ef77b4c76f6b893", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/gpac/gpac/issues/2612", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking"]}]}, "github_commit_url": "https://github.com/gpac/gpac/commit/cd8a95c1efb8f5bfc950b86c2ef77b4c76f6b893"}}