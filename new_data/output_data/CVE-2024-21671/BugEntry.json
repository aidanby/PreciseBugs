{"buggy_code": ["# Human readable description of the server instance. This is to help\n# your peers to identify the server\ndescription: Test\n\n# Should be prod, acc, test or dev. In case the type is set to test\n# the JWT-tokens expiration is set to 1 day (default is 6 hours). The\n# other types can be used in future releases of vantage6\ntype: test\n\n# IP adress to which the server binds. In case you specify 0.0.0.0\n# the server listens on all interfaces\nip: 0.0.0.0\n\n# Port to which the server binds\nport: 5000\n\n# API path prefix. (i.e. https://yourdomain.org/api_path/<endpoint>). In the\n# case you use a referse proxy and use a subpath, make sure to include it\n# here also.\napi_path: /api\n\n# The URI to the server database. This should be a valid SQLAlchemy URI,\n# e.g. for an Sqlite database: sqlite:///database-name.sqlite,\n# or Postgres: postgresql://username:password@172.17.0.1/database).\nuri: sqlite:///test.sqlite\n\n# This should be set to false in production as this allows to completely\n# wipe the database in a single command. Useful to set to true when\n# testing/developing.\nallow_drop_all: True\n\n# Enable or disable two-factor authentication. If enabled, users will be\n# presented with a QR-code to scan with their phone the first time they log in.\ntwo_factor_auth: true\n\n# The secret key used to generate JWT authorization tokens. This should\n# be kept secret as others are able to generate access tokens if they\n# know this secret. This parameter is optional. In case it is not\n# provided in the configuration it is generated each time the server\n# starts. Thereby invalidating all previous distributed keys.\n# OPTIONAL\njwt_secret_key: super-secret-key! # recommended but optional\n\n# Settings for the logger\nlogging:\n\n  # Controls the logging output level. Could be one of the following\n  # levels: CRITICAL, ERROR, WARNING, INFO, DEBUG, NOTSET\n  level:        DEBUG\n\n  # Filename of the log-file, used by RotatingFileHandler\n  file:         test.log\n\n  # Whether the output is shown in the console or not\n  use_console:  True\n\n  # The number of log files that are kept, used by RotatingFileHandler\n  backup_count: 5\n\n  # Size in kB of a single log file, used by RotatingFileHandler\n  max_size:     1024\n\n  # format: input for logging.Formatter,\n  format:       \"%(asctime)s - %(name)-14s - %(levelname)-8s - %(message)s\"\n  datefmt:      \"%Y-%m-%d %H:%M:%S\"\n\n# (optional) set the individual log levels per logger name, for example\n# mute some loggers that are too verbose.\n  loggers:\n    - name: urllib3\n      level: warning\n    - name: socketIO-client\n      level: warning\n    - name: engineio.server\n      level: warning\n    - name: socketio.server\n      level: warning\n    - name: sqlalchemy.engine\n      level: warning\n    - name: requests_oauthlib.oauth2_session\n      level: warning\n\n# Additional debug flags\ndebug:\n\n  # Set to `true` to enable debug mode for the socketio server\n  socketio: false\n\n  # Set to `true` to enable debug mode in the Flask app\n  flask: false\n\n# Configure a smtp mail server for the server to use for administrative\n# purposes. e.g. allowing users to reset their password.\n# OPTIONAL\nsmtp:\n  port: 587\n  server: smtp.yourmailserver.example.com\n  # credentials for authenticating with the SMTP server\n  username: your-username\n  password: super-secret-password\n  # email address to send emails from (header)\n  # (defaults to noreply@vantage6.ai)\n  email_from: noreply@example.com\n\n# Set an email address you want to direct your users to for support\n# (defaults to support@vantage6.ai)\nsupport_email: your-support@example.com\n\n# set how long reset token provided via email are valid (default 1 hour)\nemail_token_validity_minutes: 60\n\n# set how long tokens and refresh tokens are valid (default 6 and 48\n# hours, respectively)\ntoken_expires_hours: 6\nrefresh_token_expires_hours: 48\n\n# If you have a server with a high workload, it is recommended to use\n# multiple server instances (horizontal scaling). If you do so, you also\n# need to set up a RabbitMQ message service to ensure that the communication\n# between the server and the nodes is handled properly. Then, fill out the\n# RabbitMQ connection URI below to connect the server to it. Also, set the\n# start_with_server flag to true to start RabbitMQ when you start the server.\nrabbitmq:\n  uri: amqp://myuser:mypassword@myhostname:5672/myvhost\n  start_with_server: false\n\n# If algorithm containers need direct communication between each other\n# the server also requires a VPN server. (!) This must be a EduVPN\n# instance as vantage6 makes use of their API (!)\n# OPTIONAL\nvpn_server:\n  # the URL of your VPN server\n  url: https://your-vpn-server.ext\n\n  # OATH2 settings, make sure these are the same as in the\n  # configuration file of your EduVPN instance\n  redirect_url: http://localhost\n  client_id: your_VPN_client_user_name\n  client_secret: your_VPN_client_user_password\n\n  # Username and password to acccess the EduVPN portal\n  portal_username: your_eduvpn_portal_user_name\n  portal_userpass: your_eduvpn_portal_user_password\n\n# specify custom Docker images to use for starting the different\n# components.\n# OPTIONAL\nimages:\n  server: harbor2.vantage6.ai/infrastructure/server:cotopaxi\n  ui: harbor2.vantage6.ai/infrastructure/ui:cotopaxi\n\n# options for starting the User Interface when starting the server\nui:\n  # set this to true to start the UI when starting the server with\n  # `v6 server start`\n  enabled: true\n\n  # port at which the UI will be available on your local machine\n  port: 3456\n", "from pathlib import Path\n\nfrom vantage6.common.globals import APPNAME\n\n#\n#   INSTALLATION SETTINGS\n#\nPACKAGE_FOLDER = Path(__file__).parent.parent.parent\n\nDATA_FOLDER = PACKAGE_FOLDER / APPNAME / \"server\" / \"_data\"\n\nSERVER_MODULE_NAME = APPNAME + \"-server\"\n\n#\n#   RUNTIME SETTINGS\n#\n\n# Expiretime of JWT tokens\nACCESS_TOKEN_EXPIRES_HOURS = 6\n\n# minimum validity of JWT Tokens in seconds\nMIN_TOKEN_VALIDITY_SECONDS = 1800\n\n# Expiration time of refresh tokens\nREFRESH_TOKENS_EXPIRE_HOURS = 48\n\n# Minimum time in seconds that a refresh token must be valid *longer than* the\n# access token. This is to prevent the access token from expiring before the\n# refresh token.\nMIN_REFRESH_TOKEN_EXPIRY_DELTA = 1\n\n# Which resources should be initialized. These names correspond to the\n# file-names in the resource directory\nRESOURCES = ['node', 'collaboration', 'organization', 'task', 'run',\n             'token', 'user', 'version', 'recover', 'role',\n             'rule', 'health', 'vpn', 'port', 'event', 'ui.column']\n\n# Super user information. This user is only created if it is not in the\n# database yet at startup time.\nSUPER_USER_INFO = {\n    \"username\": \"root\",\n    \"password\": \"root\"\n}\n\n# default support email address to make users aware of\nDEFAULT_SUPPORT_EMAIL_ADDRESS = 'support@vantage6.ai'\n\n# default email address used in 'from' header\nDEFAULT_EMAIL_FROM_ADDRESS = 'noreply@vantage6.ai'\n\n# default time that token is valid in minutes\nDEFAULT_EMAILED_TOKEN_VALIDITY_MINUTES = 60\n\n# pagination settings\nDEFAULT_PAGE = 1\nDEFAULT_PAGE_SIZE = 10\n", "from __future__ import annotations\nimport bcrypt\nimport datetime as dt\n\nfrom sqlalchemy import Column, String, Integer, ForeignKey, DateTime\nfrom sqlalchemy.orm import relationship, validates\n\nfrom vantage6.server.model.base import DatabaseSessionManager\nfrom vantage6.server.model.authenticatable import Authenticatable\nfrom vantage6.server.model.rule import Operation, Rule, Scope\nfrom vantage6.server.model.common.utils import validate_password\n\n\nclass User(Authenticatable):\n    \"\"\"\n    Table to keep track of Users (persons) that can access the system.\n\n    Users always belong to an organization and can have certain\n    rights within an organization.\n\n    Attributes\n    ----------\n    username : str\n        Username of the user\n    password : str\n        Password of the user\n    firstname : str\n        First name of the user\n    lastname : str\n        Last name of the user\n    email : str\n        Email address of the user\n    organization_id : int\n        Foreign key to the organization to which the user belongs\n    failed_login_attempts : int\n        Number of failed login attempts\n    last_login_attempt : datetime.datetime\n        Date and time of the last login attempt\n    otp_secret : str\n        Secret key for one time passwords\n    organization : :class:`~.model.organization.Organization`\n        Organization to which the user belongs\n    roles : list[:class:`~.model.role.Role`]\n        Roles that the user has\n    rules : list[:class:`~.model.rule.Rule`]\n        Rules that the user has\n    created_tasks : list[:class:`~.model.task.Task`]\n        Tasks that the user has created\n    \"\"\"\n    _hidden_attributes = ['password']\n\n    # overwrite id with linked id to the authenticatable\n    id = Column(Integer, ForeignKey('authenticatable.id'), primary_key=True)\n    __mapper_args__ = {\n        'polymorphic_identity': 'user',\n    }\n\n    # fields\n    username = Column(String, unique=True)\n    password = Column(String)\n    firstname = Column(String)\n    lastname = Column(String)\n    email = Column(String, unique=True)\n    organization_id = Column(Integer, ForeignKey(\"organization.id\"))\n    failed_login_attempts = Column(Integer, default=0)\n    last_login_attempt = Column(DateTime)\n    otp_secret = Column(String(32))\n\n    # relationships\n    organization = relationship(\"Organization\", back_populates=\"users\")\n    roles = relationship(\"Role\", back_populates=\"users\",\n                         secondary=\"Permission\")\n    rules = relationship(\"Rule\", back_populates=\"users\",\n                         secondary=\"UserPermission\")\n    created_tasks = relationship(\"Task\", back_populates=\"init_user\")\n\n    def __repr__(self) -> str:\n        \"\"\"\n        String representation of the user.\n\n        Returns\n        -------\n        str\n            String representation of the user\n        \"\"\"\n        organization = self.organization.name if self.organization else \"None\"\n        return (\n            f\"<User \"\n            f\"id={self.id}, username='{self.username}', roles='{self.roles}', \"\n            f\"organization='{organization}'\"\n            f\">\"\n        )\n\n    @validates(\"password\")\n    def _validate_password(self, key: str, password: str) -> str:\n        \"\"\"\n        Validate the password of the user by hashing it, as it is also hashed\n        in the database.\n\n        Parameters\n        ----------\n        key: str\n            Name of the attribute (in this case 'password')\n        password: str\n            Password of the user\n\n        Returns\n        -------\n        str\n            Hashed password\n        \"\"\"\n        return self.hash(password)\n\n    def set_password(self, pw: str) -> str | None:\n        \"\"\"\n        Set the password of the current user. This function doesn't save the\n        new password to the database\n\n        Parameters\n        ----------\n        pw: str\n            The new password\n\n        Returns\n        -------\n        str | None\n            If the new password fails to pass the checks, a message is\n            returned. Else, none is returned\n        \"\"\"\n        try:\n            validate_password(pw)\n        except ValueError as e:\n            return str(e)\n\n        self.password = pw\n        self.save()\n\n    def check_password(self, pw: str) -> bool:\n        \"\"\"\n        Check if the password is correct\n\n        Parameters\n        ----------\n        pw: str\n            Password to check\n\n        Returns\n        -------\n        bool\n            Whether or not the password is correct\n        \"\"\"\n        if self.password is not None:\n            expected_hash = self.password.encode('utf8')\n            return bcrypt.checkpw(pw.encode('utf8'), expected_hash)\n        return False\n\n    def is_blocked(self, max_failed_attempts: int,\n                   inactivation_in_minutes: int) -> tuple[bool, str | None]:\n        \"\"\"\n        Check if user can login or if they are temporarily blocked because they\n        entered a wrong password too often\n\n        Parameters\n        ----------\n        max_failed_attempts: int\n            Maximum number of attempts to login before temporary deactivation\n        inactivation_minutes: int\n            How many minutes an account is deactivated\n\n        Returns\n        -------\n        bool\n            Whether or not user is blocked temporarily\n        str | None\n            Message if user is blocked, else None\n        \"\"\"\n        td_max_blocked = dt.timedelta(minutes=inactivation_in_minutes)\n        td_last_login = dt.datetime.now() - self.last_login_attempt \\\n            if self.last_login_attempt else None\n        has_max_attempts = (\n            self.failed_login_attempts >= max_failed_attempts\n            if self.failed_login_attempts else False\n        )\n        if has_max_attempts and td_last_login < td_max_blocked:\n            minutes_remaining = \\\n                (td_max_blocked - td_last_login).seconds // 60 + 1\n            return True, minutes_remaining\n        else:\n            return False, None\n\n    @classmethod\n    def get_by_username(cls, username: str) -> User:\n        \"\"\"\n        Get a user by their username\n\n        Parameters\n        ----------\n        username: str\n            Username of the user\n\n        Returns\n        -------\n        User\n            User with the given username\n\n        Raises\n        ------\n        NoResultFound\n            If no user with the given username exists\n        \"\"\"\n        session = DatabaseSessionManager.get_session()\n        result = session.query(cls).filter_by(username=username).one()\n        session.commit()\n        return result\n\n    @classmethod\n    def get_by_email(cls, email: str) -> User:\n        \"\"\"\n        Get a user by their email\n\n        Parameters\n        ----------\n        email: str\n            Email of the user\n\n        Returns\n        -------\n        User\n            User with the given email\n\n        Raises\n        ------\n        NoResultFound\n            If no user with the given email exists\n        \"\"\"\n        session = DatabaseSessionManager.get_session()\n        result = session.query(cls).filter_by(email=email).one()\n        session.commit()\n        return result\n\n    @classmethod\n    def username_exists(cls, username) -> bool:\n        \"\"\"\n        Check if a user with the given username exists\n\n        Parameters\n        ----------\n        username: str\n            Username to check\n\n        Returns\n        -------\n        bool\n            Whether or not a user with the given username exists\n        \"\"\"\n        return cls.exists(field='username', value=username)\n\n    def can(self, resource: str, scope: Scope, operation: Operation) -> bool:\n        \"\"\"\n        Check if user is allowed to execute a certain action\n\n        Parameters\n        ---------\n        resource: str\n            The resource type on which the action is to be performed\n        scope: Scope\n            The scope within which the user wants to perform an action\n        operation: Operation\n            The operation a user wants to execute\n\n        Returns\n        -------\n        bool\n            Whether or not user is allowed to execute the requested operation\n            on the resource\n        \"\"\"\n        rule = Rule.get_by_(resource, scope, operation)\n        return rule in self.rules or \\\n            any(rule in role.rules for role in self.roles)\n", "import logging\nimport datetime as dt\nimport pyotp\n\nfrom http import HTTPStatus\nfrom flask import request, render_template\nfrom flask_mail import Mail\n\nfrom vantage6.common.globals import APPNAME, MAIN_VERSION_NAME\nfrom vantage6.server.globals import (\n    DEFAULT_SUPPORT_EMAIL_ADDRESS, DEFAULT_EMAIL_FROM_ADDRESS\n)\nfrom vantage6.server.model.user import User\n\nmodule_name = __name__.split('.')[-1]\nlog = logging.getLogger(module_name)\n\n\ndef user_login(\n    config: dict, username: str, password: str, mail: Mail\n) -> tuple[dict | User, HTTPStatus]:\n    \"\"\"\n    Returns user a message in case of failed login attempt.\n\n    config: dict\n        Dictionary with configuration settings\n    username: str\n        Username of user to be logged in\n    password: str\n        Password of user to be logged in\n    mail: flask_mail.Mail\n        An instance of the Flask mail class. Used to send email to user in case\n        of too many failed login attempts.\n\n    Returns\n    -------\n    :class:`~vantage6.server.model.user.User` or dict:\n        User SQLAlchemy model if user is logged in, otherwise dictionary with\n        error message\n    HTTPStatus:\n        Status code that the current request should return\n    \"\"\"\n    log.info(f\"Trying to login '{username}'\")\n    failed_login_msg = \"Failed to login\"\n    if User.username_exists(username):\n        user = User.get_by_username(username)\n        password_policy = config.get(\"password_policy\", {})\n        max_failed_attempts = password_policy.get('max_failed_attempts', 5)\n        inactivation_time = password_policy.get('inactivation_minutes', 15)\n\n        is_blocked, min_rem = user.is_blocked(max_failed_attempts,\n                                              inactivation_time)\n        if is_blocked:\n            notify_user_blocked(user, max_failed_attempts, min_rem, mail,\n                                config)\n            return {\"msg\": failed_login_msg}, HTTPStatus.UNAUTHORIZED\n        elif user.check_password(password):\n            user.failed_login_attempts = 0\n            user.save()\n            return user, HTTPStatus.OK\n        else:\n            # update the number of failed login attempts\n            user.failed_login_attempts = 1 \\\n                if (\n                    not user.failed_login_attempts or\n                    user.failed_login_attempts >= max_failed_attempts\n                ) else user.failed_login_attempts + 1\n            user.last_login_attempt = dt.datetime.now()\n            user.save()\n\n    return {\"msg\": failed_login_msg}, HTTPStatus.UNAUTHORIZED\n\n\ndef notify_user_blocked(\n    user: User, max_n_attempts: int, min_rem: int, mail: Mail,\n    config: dict\n) -> None:\n    \"\"\"\n    Sends an email to the user when his or her account is locked\n\n    Parameters\n    ----------\n    user: :class:`~vantage6.server.model.user.User`\n        User who is temporarily blocked\n    max_n_attempts: int\n        Maximum number of failed login attempts before the account is locked\n    min_rem: int\n        Number of minutes remaining before the account is unlocked\n    mail: flask_mail.Mail\n        An instance of the Flask mail class. Used to send email to user in case\n        of too many failed login attempts.\n    config: dict\n        Dictionary with configuration settings\n    \"\"\"\n    if not user.email:\n        log.warning(f'User {user.username} is locked, but does not have'\n                    'an email registered. So no message has been sent.')\n\n    log.info(f'User {user.username} is locked. Sending them an email.')\n\n    smtp_settings = config.get(\"smtp\", {})\n    email_from = smtp_settings.get(\"email_from\", DEFAULT_EMAIL_FROM_ADDRESS)\n    support_email = config.get(\"support_email\", DEFAULT_SUPPORT_EMAIL_ADDRESS)\n\n    template_vars = {\n        'firstname': user.firstname,\n        'number_of_allowed_attempts': max_n_attempts,\n        'ip': request.access_route[-1],\n        'time': dt.datetime.now(dt.timezone.utc),\n        'time_remaining': min_rem,\n        'support_email': support_email,\n    }\n\n    mail.send_email(\n        \"Failed login attempts on your vantage6 account\",\n        sender=email_from,\n        recipients=[user.email],\n        text_body=render_template(\"mail/blocked_account.txt\", **template_vars),\n        html_body=render_template(\"mail/blocked_account.html\", **template_vars)\n    )\n\n\ndef create_qr_uri(user: User) -> dict:\n    \"\"\"\n    Create the URI to generate a QR code for authenticator apps\n\n    Parameters\n    ----------\n    user: :class:`~vantage6.server.model.user.User`\n        User for whom two-factor authentication is to be set up\n\n    Returns\n    -------\n    dict\n        Dictionary with information on the TOTP secret required to generate\n        a QR code or to enter it manually in an authenticator app\n    \"\"\"\n    otp_secret = pyotp.random_base32()\n    qr_uri = pyotp.totp.TOTP(otp_secret).provisioning_uri(\n        name=user.username, issuer_name=f\"{APPNAME} ({MAIN_VERSION_NAME})\"\n    )\n    user.otp_secret = otp_secret\n    user.save()\n    return {\n        'qr_uri': qr_uri,\n        'otp_secret': otp_secret,\n        'msg': ('Two-factor authentication is obligatory on this server. '\n                'Please visualize the QR code to set up authentication.')\n    }\n"], "fixing_code": ["# Human readable description of the server instance. This is to help\n# your peers to identify the server\ndescription: Test\n\n# Should be prod, acc, test or dev. In case the type is set to test\n# the JWT-tokens expiration is set to 1 day (default is 6 hours). The\n# other types can be used in future releases of vantage6\ntype: test\n\n# IP adress to which the server binds. In case you specify 0.0.0.0\n# the server listens on all interfaces\nip: 0.0.0.0\n\n# Port to which the server binds\nport: 5000\n\n# API path prefix. (i.e. https://yourdomain.org/api_path/<endpoint>). In the\n# case you use a referse proxy and use a subpath, make sure to include it\n# here also.\napi_path: /api\n\n# The URI to the server database. This should be a valid SQLAlchemy URI,\n# e.g. for an Sqlite database: sqlite:///database-name.sqlite,\n# or Postgres: postgresql://username:password@172.17.0.1/database).\nuri: sqlite:///test.sqlite\n\n# This should be set to false in production as this allows to completely\n# wipe the database in a single command. Useful to set to true when\n# testing/developing.\nallow_drop_all: True\n\n# Enable or disable two-factor authentication. If enabled, users will be\n# presented with a QR-code to scan with their phone the first time they log in.\ntwo_factor_auth: true\n\n# The secret key used to generate JWT authorization tokens. This should\n# be kept secret as others are able to generate access tokens if they\n# know this secret. This parameter is optional. In case it is not\n# provided in the configuration it is generated each time the server\n# starts. Thereby invalidating all previous distributed keys.\n# OPTIONAL\njwt_secret_key: super-secret-key! # recommended but optional\n\n# Settings for the logger\nlogging:\n\n  # Controls the logging output level. Could be one of the following\n  # levels: CRITICAL, ERROR, WARNING, INFO, DEBUG, NOTSET\n  level:        DEBUG\n\n  # Filename of the log-file, used by RotatingFileHandler\n  file:         test.log\n\n  # Whether the output is shown in the console or not\n  use_console:  True\n\n  # The number of log files that are kept, used by RotatingFileHandler\n  backup_count: 5\n\n  # Size in kB of a single log file, used by RotatingFileHandler\n  max_size:     1024\n\n  # format: input for logging.Formatter,\n  format:       \"%(asctime)s - %(name)-14s - %(levelname)-8s - %(message)s\"\n  datefmt:      \"%Y-%m-%d %H:%M:%S\"\n\n# (optional) set the individual log levels per logger name, for example\n# mute some loggers that are too verbose.\n  loggers:\n    - name: urllib3\n      level: warning\n    - name: socketIO-client\n      level: warning\n    - name: engineio.server\n      level: warning\n    - name: socketio.server\n      level: warning\n    - name: sqlalchemy.engine\n      level: warning\n    - name: requests_oauthlib.oauth2_session\n      level: warning\n\n# Additional debug flags\ndebug:\n\n  # Set to `true` to enable debug mode for the socketio server\n  socketio: false\n\n  # Set to `true` to enable debug mode in the Flask app\n  flask: false\n\n# Configure a smtp mail server for the server to use for administrative\n# purposes. e.g. allowing users to reset their password.\n# OPTIONAL\nsmtp:\n  port: 587\n  server: smtp.yourmailserver.example.com\n  # credentials for authenticating with the SMTP server\n  username: your-username\n  password: super-secret-password\n  # email address to send emails from (header)\n  # (defaults to noreply@vantage6.ai)\n  email_from: noreply@example.com\n\n# Set an email address you want to direct your users to for support\n# (defaults to support@vantage6.ai)\nsupport_email: your-support@example.com\n\n# set how long reset token provided via email are valid (default 1 hour)\nemail_token_validity_minutes: 60\n\n# set how long tokens and refresh tokens are valid (default 6 and 48\n# hours, respectively)\ntoken_expires_hours: 6\nrefresh_token_expires_hours: 48\n\n# If you have a server with a high workload, it is recommended to use\n# multiple server instances (horizontal scaling). If you do so, you also\n# need to set up a RabbitMQ message service to ensure that the communication\n# between the server and the nodes is handled properly. Then, fill out the\n# RabbitMQ connection URI below to connect the server to it. Also, set the\n# start_with_server flag to true to start RabbitMQ when you start the server.\nrabbitmq:\n  uri: amqp://myuser:mypassword@myhostname:5672/myvhost\n  start_with_server: false\n\n# If algorithm containers need direct communication between each other\n# the server also requires a VPN server. (!) This must be a EduVPN\n# instance as vantage6 makes use of their API (!)\n# OPTIONAL\nvpn_server:\n  # the URL of your VPN server\n  url: https://your-vpn-server.ext\n\n  # OATH2 settings, make sure these are the same as in the\n  # configuration file of your EduVPN instance\n  redirect_url: http://localhost\n  client_id: your_VPN_client_user_name\n  client_secret: your_VPN_client_user_password\n\n  # Username and password to acccess the EduVPN portal\n  portal_username: your_eduvpn_portal_user_name\n  portal_userpass: your_eduvpn_portal_user_password\n\n# specify custom Docker images to use for starting the different\n# components.\n# OPTIONAL\nimages:\n  server: harbor2.vantage6.ai/infrastructure/server:cotopaxi\n  ui: harbor2.vantage6.ai/infrastructure/ui:cotopaxi\n\n# options for starting the User Interface when starting the server\nui:\n  # set this to true to start the UI when starting the server with\n  # `v6 server start`\n  enabled: true\n\n  # port at which the UI will be available on your local machine\n  port: 3456\n\n# set password policies for the server\npassword_policy:\n  # maximum number of failed login attempts before the user is locked out for\n  # a certain amount of time. Default is 5.\n  max_failed_attempts: 5\n\n  # number of minutes the user is locked out after the maximum number of failed\n  # login attempts is reached. Default is 15.\n  inactivation_minutes: 15\n\n  # number of minutes to wait between emails that alert a user that someone is\n  # trying to log in to their account. Default is 60.\n  between_email_blocked_login_minutes: 60\n", "from pathlib import Path\n\nfrom vantage6.common.globals import APPNAME\n\n#\n#   INSTALLATION SETTINGS\n#\nPACKAGE_FOLDER = Path(__file__).parent.parent.parent\n\nDATA_FOLDER = PACKAGE_FOLDER / APPNAME / \"server\" / \"_data\"\n\nSERVER_MODULE_NAME = APPNAME + \"-server\"\n\n#\n#   RUNTIME SETTINGS\n#\n\n# Expiretime of JWT tokens\nACCESS_TOKEN_EXPIRES_HOURS = 6\n\n# minimum validity of JWT Tokens in seconds\nMIN_TOKEN_VALIDITY_SECONDS = 1800\n\n# Expiration time of refresh tokens\nREFRESH_TOKENS_EXPIRE_HOURS = 48\n\n# Minimum time in seconds that a refresh token must be valid *longer than* the\n# access token. This is to prevent the access token from expiring before the\n# refresh token.\nMIN_REFRESH_TOKEN_EXPIRY_DELTA = 1\n\n# Which resources should be initialized. These names correspond to the\n# file-names in the resource directory\nRESOURCES = ['node', 'collaboration', 'organization', 'task', 'run',\n             'token', 'user', 'version', 'recover', 'role',\n             'rule', 'health', 'vpn', 'port', 'event', 'ui.column']\n\n# Super user information. This user is only created if it is not in the\n# database yet at startup time.\nSUPER_USER_INFO = {\n    \"username\": \"root\",\n    \"password\": \"root\"\n}\n\n# default support email address to make users aware of\nDEFAULT_SUPPORT_EMAIL_ADDRESS = 'support@vantage6.ai'\n\n# default email address used in 'from' header\nDEFAULT_EMAIL_FROM_ADDRESS = 'noreply@vantage6.ai'\n\n# default time that token is valid in minutes\nDEFAULT_EMAILED_TOKEN_VALIDITY_MINUTES = 60\n\n# pagination settings\nDEFAULT_PAGE = 1\nDEFAULT_PAGE_SIZE = 10\n\n# default password policies\nDEFAULT_MAX_FAILED_ATTEMPTS = 5\nDEFAULT_INACTIVATION_MINUTES = 15\nDEFAULT_BETWEEN_BLOCKED_LOGIN_EMAIL_MINUTES = 60\n", "from __future__ import annotations\nimport bcrypt\nimport datetime as dt\n\nfrom sqlalchemy import Column, String, Integer, ForeignKey, DateTime\nfrom sqlalchemy.orm import relationship, validates\n\nfrom vantage6.server.model.base import DatabaseSessionManager\nfrom vantage6.server.model.authenticatable import Authenticatable\nfrom vantage6.server.model.rule import Operation, Rule, Scope\nfrom vantage6.server.model.common.utils import validate_password\n\n\nclass User(Authenticatable):\n    \"\"\"\n    Table to keep track of Users (persons) that can access the system.\n\n    Users always belong to an organization and can have certain\n    rights within an organization.\n\n    Attributes\n    ----------\n    username : str\n        Username of the user\n    password : str\n        Password of the user\n    firstname : str\n        First name of the user\n    lastname : str\n        Last name of the user\n    email : str\n        Email address of the user\n    organization_id : int\n        Foreign key to the organization to which the user belongs\n    failed_login_attempts : int\n        Number of failed login attempts\n    last_login_attempt : datetime.datetime\n        Date and time of the last login attempt\n    otp_secret : str\n        Secret key for one time passwords\n    organization : :class:`~.model.organization.Organization`\n        Organization to which the user belongs\n    roles : list[:class:`~.model.role.Role`]\n        Roles that the user has\n    rules : list[:class:`~.model.rule.Rule`]\n        Rules that the user has\n    created_tasks : list[:class:`~.model.task.Task`]\n        Tasks that the user has created\n    \"\"\"\n    _hidden_attributes = ['password']\n\n    # overwrite id with linked id to the authenticatable\n    id = Column(Integer, ForeignKey('authenticatable.id'), primary_key=True)\n    __mapper_args__ = {\n        'polymorphic_identity': 'user',\n    }\n\n    # fields\n    username = Column(String, unique=True)\n    password = Column(String)\n    firstname = Column(String)\n    lastname = Column(String)\n    email = Column(String, unique=True)\n    organization_id = Column(Integer, ForeignKey(\"organization.id\"))\n    failed_login_attempts = Column(Integer, default=0)\n    last_login_attempt = Column(DateTime)\n    otp_secret = Column(String(32))\n    last_email_failed_login_sent = Column(DateTime)\n\n    # relationships\n    organization = relationship(\"Organization\", back_populates=\"users\")\n    roles = relationship(\"Role\", back_populates=\"users\",\n                         secondary=\"Permission\")\n    rules = relationship(\"Rule\", back_populates=\"users\",\n                         secondary=\"UserPermission\")\n    created_tasks = relationship(\"Task\", back_populates=\"init_user\")\n\n    def __repr__(self) -> str:\n        \"\"\"\n        String representation of the user.\n\n        Returns\n        -------\n        str\n            String representation of the user\n        \"\"\"\n        organization = self.organization.name if self.organization else \"None\"\n        return (\n            f\"<User \"\n            f\"id={self.id}, username='{self.username}', roles='{self.roles}', \"\n            f\"organization='{organization}'\"\n            f\">\"\n        )\n\n    @validates(\"password\")\n    def _validate_password(self, key: str, password: str) -> str:\n        \"\"\"\n        Validate the password of the user by hashing it, as it is also hashed\n        in the database.\n\n        Parameters\n        ----------\n        key: str\n            Name of the attribute (in this case 'password')\n        password: str\n            Password of the user\n\n        Returns\n        -------\n        str\n            Hashed password\n        \"\"\"\n        return self.hash(password)\n\n    def set_password(self, pw: str) -> str | None:\n        \"\"\"\n        Set the password of the current user. This function doesn't save the\n        new password to the database\n\n        Parameters\n        ----------\n        pw: str\n            The new password\n\n        Returns\n        -------\n        str | None\n            If the new password fails to pass the checks, a message is\n            returned. Else, none is returned\n        \"\"\"\n        try:\n            validate_password(pw)\n        except ValueError as e:\n            return str(e)\n\n        self.password = pw\n        self.save()\n\n    def check_password(self, pw: str) -> bool:\n        \"\"\"\n        Check if the password is correct\n\n        Parameters\n        ----------\n        pw: str\n            Password to check\n\n        Returns\n        -------\n        bool\n            Whether or not the password is correct\n        \"\"\"\n        if self.password is not None:\n            expected_hash = self.password.encode('utf8')\n            return bcrypt.checkpw(pw.encode('utf8'), expected_hash)\n        return False\n\n    def is_blocked(self, max_failed_attempts: int,\n                   inactivation_in_minutes: int) -> tuple[bool, int | None]:\n        \"\"\"\n        Check if user can login or if they are temporarily blocked because they\n        entered a wrong password too often\n\n        Parameters\n        ----------\n        max_failed_attempts: int\n            Maximum number of attempts to login before temporary deactivation\n        inactivation_in_minutes: int\n            How many minutes an account is deactivated\n\n        Returns\n        -------\n        bool\n            Whether or not user is blocked temporarily\n        int | None\n            How many minutes user is still blocked for\n        \"\"\"\n        td_max_blocked = dt.timedelta(minutes=inactivation_in_minutes)\n        td_last_login = dt.datetime.now() - self.last_login_attempt \\\n            if self.last_login_attempt else None\n        has_max_attempts = (\n            self.failed_login_attempts >= max_failed_attempts\n            if self.failed_login_attempts else False\n        )\n        if has_max_attempts and td_last_login < td_max_blocked:\n            minutes_remaining = \\\n                (td_max_blocked - td_last_login).seconds // 60 + 1\n            return True, minutes_remaining\n        else:\n            return False, None\n\n    @classmethod\n    def get_by_username(cls, username: str) -> User:\n        \"\"\"\n        Get a user by their username\n\n        Parameters\n        ----------\n        username: str\n            Username of the user\n\n        Returns\n        -------\n        User\n            User with the given username\n\n        Raises\n        ------\n        NoResultFound\n            If no user with the given username exists\n        \"\"\"\n        session = DatabaseSessionManager.get_session()\n        result = session.query(cls).filter_by(username=username).one()\n        session.commit()\n        return result\n\n    @classmethod\n    def get_first_user(cls) -> User:\n        \"\"\"\n        Get a random user by their username.\n\n        This function is used to prevent an attacker from finding out which\n        usernames exist.\n\n        Returns\n        -------\n        User\n            A random user that is in the database\n        \"\"\"\n        session = DatabaseSessionManager.get_session()\n        result = session.query(cls).order_by(cls.id).first()\n        session.commit()\n        return result\n\n    @classmethod\n    def get_by_email(cls, email: str) -> User:\n        \"\"\"\n        Get a user by their email\n\n        Parameters\n        ----------\n        email: str\n            Email of the user\n\n        Returns\n        -------\n        User\n            User with the given email\n\n        Raises\n        ------\n        NoResultFound\n            If no user with the given email exists\n        \"\"\"\n        session = DatabaseSessionManager.get_session()\n        result = session.query(cls).filter_by(email=email).one()\n        session.commit()\n        return result\n\n    @classmethod\n    def username_exists(cls, username) -> bool:\n        \"\"\"\n        Check if a user with the given username exists\n\n        Parameters\n        ----------\n        username: str\n            Username to check\n\n        Returns\n        -------\n        bool\n            Whether or not a user with the given username exists\n        \"\"\"\n        return cls.exists(field='username', value=username)\n\n    def can(self, resource: str, scope: Scope, operation: Operation) -> bool:\n        \"\"\"\n        Check if user is allowed to execute a certain action\n\n        Parameters\n        ---------\n        resource: str\n            The resource type on which the action is to be performed\n        scope: Scope\n            The scope within which the user wants to perform an action\n        operation: Operation\n            The operation a user wants to execute\n\n        Returns\n        -------\n        bool\n            Whether or not user is allowed to execute the requested operation\n            on the resource\n        \"\"\"\n        rule = Rule.get_by_(resource, scope, operation)\n        return rule in self.rules or \\\n            any(rule in role.rules for role in self.roles)\n", "import sys\nimport logging\nimport datetime as dt\nimport pyotp\n\nfrom http import HTTPStatus\nfrom flask import request, render_template, current_app, Flask\nfrom flask_mail import Mail\nfrom threading import Thread\n\nfrom vantage6.common.globals import APPNAME, MAIN_VERSION_NAME\nfrom vantage6.server.globals import (\n    DEFAULT_SUPPORT_EMAIL_ADDRESS, DEFAULT_MAX_FAILED_ATTEMPTS,\n    DEFAULT_INACTIVATION_MINUTES, DEFAULT_BETWEEN_BLOCKED_LOGIN_EMAIL_MINUTES,\n    DEFAULT_EMAIL_FROM_ADDRESS\n)\nfrom vantage6.server.model.user import User\n\nmodule_name = __name__.split('.')[-1]\nlog = logging.getLogger(module_name)\n\n\ndef user_login(\n    config: dict, username: str, password: str, mail: Mail\n) -> tuple[dict | User, HTTPStatus]:\n    \"\"\"\n    Returns user a message in case of failed login attempt.\n\n    config: dict\n        Dictionary with configuration settings\n    username: str\n        Username of user to be logged in\n    password: str\n        Password of user to be logged in\n    mail: flask_mail.Mail\n        An instance of the Flask mail class. Used to send email to user in case\n        of too many failed login attempts.\n\n    Returns\n    -------\n    :class:`~vantage6.server.model.user.User` or dict:\n        User SQLAlchemy model if user is logged in, otherwise dictionary with\n        error message\n    HTTPStatus:\n        Status code that the current request should return\n    \"\"\"\n    log.info(\"Trying to login '%s'\", username)\n    failed_login_msg = \"Failed to login\"\n\n    # check if username exists. If it does not, we continue anyway, to prevent\n    # that an attacker can find out which usernames exist via a timing attack.\n    # In that case, we fetch the first user as random user.\n    username_exists = User.username_exists(username)\n    random_username = User.get_first_user().username\n    user = User.get_by_username(username) if username_exists \\\n        else User.get_by_username(random_username)\n\n    password_policy = config.get(\"password_policy\", {})\n    max_failed_attempts = password_policy.get(\n        'max_failed_attempts', DEFAULT_MAX_FAILED_ATTEMPTS\n    )\n    inactivation_time = password_policy.get(\n        'inactivation_minutes', DEFAULT_INACTIVATION_MINUTES\n    )\n\n    is_blocked, min_rem = user.is_blocked(max_failed_attempts,\n                                          inactivation_time)\n\n    if user.check_password(password) and not is_blocked and username_exists:\n        # Note: above the username_exists is checked to prevent that an\n        # attacker happens to get the correct password for the random user\n        # that is returned when the username does not exist. Note also that\n        # the password is checked first to keep the timing equal for both.\n        user.failed_login_attempts = 0\n        user.save()\n        return user, HTTPStatus.OK\n\n    # Handle database updates required upon failed login in a separate thread\n    # to ensure similar response times\n    # pylint: disable=W0212\n    t1 = Thread(target=__handle_failed_login, args=(\n        current_app._get_current_object(), username_exists, username,\n        password_policy, is_blocked, min_rem, mail, config,\n        request.access_route[-1]\n    ))\n    t1.start()\n\n    return {\"msg\": failed_login_msg}, HTTPStatus.UNAUTHORIZED\n\n\ndef __handle_failed_login(\n    app: Flask, user_exists: bool, username: str, password_policy: dict,\n    is_blocked: bool, min_rem: int, mail: Mail, config: dict, ip: str\n) -> None:\n    \"\"\"\n    When a user login fails, this function is called to update the database\n    with the failed login attempt and send an email to the user if necessary.\n\n    Note that this function is called in a separate thread to keep response\n    times for login attempts similar in all cases. Therefore, this function\n    calls `sys.exit()` to terminate the thread.\n\n    Parameters\n    ----------\n    app: flask.Flask\n        The current Flask app\n    user_exists: bool\n        Whether user exists or not\n    username: str\n        Username of the user that failed to login\n    password_policy: dict\n        Dictionary with password policy settings.\n    min_rem: int\n        Number of minutes remaining before the account is unlocked\n    mail: flask_mail.Mail\n        An instance of the Flask mail class. Used to send email to user in case\n        of too many failed login attempts.\n    config: dict\n        Dictionary with configuration settings\n    ip: str\n        IP address from where the login attempt was made\n    \"\"\"\n    if not user_exists:\n        sys.exit()\n    # get user object again (required because we are in a new thread)\n    user = User.get_by_username(username)\n\n    max_failed_attempts = password_policy.get(\n        'max_failed_attempts', DEFAULT_MAX_FAILED_ATTEMPTS\n    )\n\n    if is_blocked:\n        # alert the user via email that they are blocked\n        __notify_user_blocked(app, user, min_rem, mail, config, ip)\n        sys.exit()\n    elif (\n        not user.failed_login_attempts or\n        user.failed_login_attempts >= max_failed_attempts\n    ):\n        # set failed login attempts to 1 if first failed login attempt or if\n        # user got unblocked after being blocked previously\n        user.failed_login_attempts = 1\n    else:\n        user.failed_login_attempts += 1\n    user.last_login_attempt = dt.datetime.now()\n    user.save()\n    sys.exit()\n\n\ndef __notify_user_blocked(\n    app: Flask, user: User, min_rem: int, mail: Mail, config: dict, ip: str\n) -> None:\n    \"\"\"\n    Sends an email to the user when their account is locked.\n\n    This function also checks that emails are not sent too often to the same\n    user.\n\n    Parameters\n    ----------\n    app: flask.Flask\n        The current Flask app\n    user: :class:`~vantage6.server.model.user.User`\n        User who is temporarily blocked\n    min_rem: int\n        Number of minutes remaining before the account is unlocked\n    mail: flask_mail.Mail\n        An instance of the Flask mail class. Used to send email to user in case\n        of too many failed login attempts.\n    config: dict\n        Dictionary with configuration settings\n    ip: str\n        IP address from where the login attempt was made\n    \"\"\"\n    log.info('User %s is locked. Sending them an email.', user.username)\n\n    # check that email has not already been sent recently\n    password_policy = config.get(\"password_policy\", {})\n    minutes_between_blocked_emails = password_policy.get(\n        'between_email_blocked_login_minutes',\n        DEFAULT_BETWEEN_BLOCKED_LOGIN_EMAIL_MINUTES\n    )\n    email_sent_recently = user.last_email_failed_login_sent and (\n        dt.datetime.now() < user.last_email_failed_login_sent +\n        dt.timedelta(minutes=minutes_between_blocked_emails)\n    )\n    if email_sent_recently:\n        return\n\n    # send email\n    smtp_settings = config.get(\"smtp\", {})\n    email_from = smtp_settings.get(\"email_from\", DEFAULT_EMAIL_FROM_ADDRESS)\n    support_email = config.get(\"support_email\", DEFAULT_SUPPORT_EMAIL_ADDRESS)\n\n    max_failed_attempts = password_policy.get(\n        'max_failed_attempts', DEFAULT_MAX_FAILED_ATTEMPTS\n    )\n    template_vars = {\n        'firstname': user.firstname if user.firstname else user.username,\n        'number_of_allowed_attempts': max_failed_attempts,\n        'ip': ip,\n        'time': dt.datetime.now(dt.timezone.utc),\n        'time_remaining': min_rem,\n        'support_email': support_email,\n    }\n\n    with app.app_context():\n        mail.send_email(\n            \"Failed login attempts on your vantage6 account\",\n            sender=email_from,\n            recipients=[user.email],\n            text_body=render_template(\n                \"mail/blocked_account.txt\", **template_vars\n            ),\n            html_body=render_template(\n                \"mail/blocked_account.html\", **template_vars\n            )\n        )\n\n    # Update latest email sent timestamp\n    user.last_email_failed_login_sent = dt.datetime.now()\n    user.save()\n\n\ndef create_qr_uri(user: User) -> dict:\n    \"\"\"\n    Create the URI to generate a QR code for authenticator apps\n\n    Parameters\n    ----------\n    user: :class:`~vantage6.server.model.user.User`\n        User for whom two-factor authentication is to be set up\n\n    Returns\n    -------\n    dict\n        Dictionary with information on the TOTP secret required to generate\n        a QR code or to enter it manually in an authenticator app\n    \"\"\"\n    otp_secret = pyotp.random_base32()\n    qr_uri = pyotp.totp.TOTP(otp_secret).provisioning_uri(\n        name=user.username, issuer_name=f\"{APPNAME} ({MAIN_VERSION_NAME})\"\n    )\n    user.otp_secret = otp_secret\n    user.save()\n    return {\n        'qr_uri': qr_uri,\n        'otp_secret': otp_secret,\n        'msg': ('Two-factor authentication is obligatory on this server. '\n                'Please visualize the QR code to set up authentication.')\n    }\n"], "filenames": ["docs/server/yaml/server_config.yaml", "vantage6-server/vantage6/server/globals.py", "vantage6-server/vantage6/server/model/user.py", "vantage6-server/vantage6/server/resource/common/auth_helper.py"], "buggy_code_start_loc": [159, 56, 67, 0], "buggy_code_end_loc": [159, 56, 216, 121], "fixing_code_start_loc": [160, 57, 68, 1], "fixing_code_end_loc": [174, 62, 236, 223], "type": "CWE-203", "message": "The vantage6 technology enables to manage and deploy privacy enhancing technologies like Federated Learning (FL) and Multi-Party Computation (MPC).  It is possible to find out usernames from the response time of login requests. This could aid attackers in credential attacks.  Version 4.2.0 patches this vulnerability.", "other": {"cve": {"id": "CVE-2024-21671", "sourceIdentifier": "security-advisories@github.com", "published": "2024-01-30T16:15:48.090", "lastModified": "2024-02-08T16:42:41.923", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The vantage6 technology enables to manage and deploy privacy enhancing technologies like Federated Learning (FL) and Multi-Party Computation (MPC).  It is possible to find out usernames from the response time of login requests. This could aid attackers in credential attacks.  Version 4.2.0 patches this vulnerability."}, {"lang": "es", "value": "La tecnolog\u00eda vantage6 permite gestionar e implementar tecnolog\u00edas que mejoran la privacidad, como el Federated Learning (FL) y la Multi-Party Computation (MPC). Es posible averiguar los nombres de usuario a partir del tiempo de respuesta de las solicitudes de inicio de sesi\u00f3n. Esto podr\u00eda ayudar a los atacantes en ataques de credenciales. La versi\u00f3n 4.2.0 parchea esta vulnerabilidad."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 3.7, "baseSeverity": "LOW"}, "exploitabilityScore": 2.2, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 3.7, "baseSeverity": "LOW"}, "exploitabilityScore": 2.2, "impactScore": 1.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-203"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-208"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vantage6:vantage6:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.2.0", "matchCriteriaId": "A9E3A3A7-C004-4E76-B2A3-46F0F1C68AD4"}]}]}], "references": [{"url": "https://github.com/vantage6/vantage6/commit/389f416c445da4f2438c72f34c3b1084485c4e30", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/vantage6/vantage6/security/advisories/GHSA-45gq-q4xh-cp53", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/vantage6/vantage6/commit/389f416c445da4f2438c72f34c3b1084485c4e30"}}