{"buggy_code": ["/*\n *  fs/timerfd.c\n *\n *  Copyright (C) 2007  Davide Libenzi <davidel@xmailserver.org>\n *\n *\n *  Thanks to Thomas Gleixner for code reviews and useful comments.\n *\n */\n\n#include <linux/alarmtimer.h>\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/time.h>\n#include <linux/hrtimer.h>\n#include <linux/anon_inodes.h>\n#include <linux/timerfd.h>\n#include <linux/syscalls.h>\n#include <linux/compat.h>\n#include <linux/rcupdate.h>\n\nstruct timerfd_ctx {\n\tunion {\n\t\tstruct hrtimer tmr;\n\t\tstruct alarm alarm;\n\t} t;\n\tktime_t tintv;\n\tktime_t moffs;\n\twait_queue_head_t wqh;\n\tu64 ticks;\n\tint clockid;\n\tshort unsigned expired;\n\tshort unsigned settime_flags;\t/* to show in fdinfo */\n\tstruct rcu_head rcu;\n\tstruct list_head clist;\n\tbool might_cancel;\n};\n\nstatic LIST_HEAD(cancel_list);\nstatic DEFINE_SPINLOCK(cancel_lock);\n\nstatic inline bool isalarm(struct timerfd_ctx *ctx)\n{\n\treturn ctx->clockid == CLOCK_REALTIME_ALARM ||\n\t\tctx->clockid == CLOCK_BOOTTIME_ALARM;\n}\n\n/*\n * This gets called when the timer event triggers. We set the \"expired\"\n * flag, but we do not re-arm the timer (in case it's necessary,\n * tintv != 0) until the timer is accessed.\n */\nstatic void timerfd_triggered(struct timerfd_ctx *ctx)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ctx->wqh.lock, flags);\n\tctx->expired = 1;\n\tctx->ticks++;\n\twake_up_locked(&ctx->wqh);\n\tspin_unlock_irqrestore(&ctx->wqh.lock, flags);\n}\n\nstatic enum hrtimer_restart timerfd_tmrproc(struct hrtimer *htmr)\n{\n\tstruct timerfd_ctx *ctx = container_of(htmr, struct timerfd_ctx,\n\t\t\t\t\t       t.tmr);\n\ttimerfd_triggered(ctx);\n\treturn HRTIMER_NORESTART;\n}\n\nstatic enum alarmtimer_restart timerfd_alarmproc(struct alarm *alarm,\n\tktime_t now)\n{\n\tstruct timerfd_ctx *ctx = container_of(alarm, struct timerfd_ctx,\n\t\t\t\t\t       t.alarm);\n\ttimerfd_triggered(ctx);\n\treturn ALARMTIMER_NORESTART;\n}\n\n/*\n * Called when the clock was set to cancel the timers in the cancel\n * list. This will wake up processes waiting on these timers. The\n * wake-up requires ctx->ticks to be non zero, therefore we increment\n * it before calling wake_up_locked().\n */\nvoid timerfd_clock_was_set(void)\n{\n\tktime_t moffs = ktime_mono_to_real(0);\n\tstruct timerfd_ctx *ctx;\n\tunsigned long flags;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(ctx, &cancel_list, clist) {\n\t\tif (!ctx->might_cancel)\n\t\t\tcontinue;\n\t\tspin_lock_irqsave(&ctx->wqh.lock, flags);\n\t\tif (ctx->moffs != moffs) {\n\t\t\tctx->moffs = KTIME_MAX;\n\t\t\tctx->ticks++;\n\t\t\twake_up_locked(&ctx->wqh);\n\t\t}\n\t\tspin_unlock_irqrestore(&ctx->wqh.lock, flags);\n\t}\n\trcu_read_unlock();\n}\n\nstatic void timerfd_remove_cancel(struct timerfd_ctx *ctx)\n{\n\tif (ctx->might_cancel) {\n\t\tctx->might_cancel = false;\n\t\tspin_lock(&cancel_lock);\n\t\tlist_del_rcu(&ctx->clist);\n\t\tspin_unlock(&cancel_lock);\n\t}\n}\n\nstatic bool timerfd_canceled(struct timerfd_ctx *ctx)\n{\n\tif (!ctx->might_cancel || ctx->moffs != KTIME_MAX)\n\t\treturn false;\n\tctx->moffs = ktime_mono_to_real(0);\n\treturn true;\n}\n\nstatic void timerfd_setup_cancel(struct timerfd_ctx *ctx, int flags)\n{\n\tif ((ctx->clockid == CLOCK_REALTIME ||\n\t     ctx->clockid == CLOCK_REALTIME_ALARM) &&\n\t    (flags & TFD_TIMER_ABSTIME) && (flags & TFD_TIMER_CANCEL_ON_SET)) {\n\t\tif (!ctx->might_cancel) {\n\t\t\tctx->might_cancel = true;\n\t\t\tspin_lock(&cancel_lock);\n\t\t\tlist_add_rcu(&ctx->clist, &cancel_list);\n\t\t\tspin_unlock(&cancel_lock);\n\t\t}\n\t} else if (ctx->might_cancel) {\n\t\ttimerfd_remove_cancel(ctx);\n\t}\n}\n\nstatic ktime_t timerfd_get_remaining(struct timerfd_ctx *ctx)\n{\n\tktime_t remaining;\n\n\tif (isalarm(ctx))\n\t\tremaining = alarm_expires_remaining(&ctx->t.alarm);\n\telse\n\t\tremaining = hrtimer_expires_remaining_adjusted(&ctx->t.tmr);\n\n\treturn remaining < 0 ? 0: remaining;\n}\n\nstatic int timerfd_setup(struct timerfd_ctx *ctx, int flags,\n\t\t\t const struct itimerspec *ktmr)\n{\n\tenum hrtimer_mode htmode;\n\tktime_t texp;\n\tint clockid = ctx->clockid;\n\n\thtmode = (flags & TFD_TIMER_ABSTIME) ?\n\t\tHRTIMER_MODE_ABS: HRTIMER_MODE_REL;\n\n\ttexp = timespec_to_ktime(ktmr->it_value);\n\tctx->expired = 0;\n\tctx->ticks = 0;\n\tctx->tintv = timespec_to_ktime(ktmr->it_interval);\n\n\tif (isalarm(ctx)) {\n\t\talarm_init(&ctx->t.alarm,\n\t\t\t   ctx->clockid == CLOCK_REALTIME_ALARM ?\n\t\t\t   ALARM_REALTIME : ALARM_BOOTTIME,\n\t\t\t   timerfd_alarmproc);\n\t} else {\n\t\thrtimer_init(&ctx->t.tmr, clockid, htmode);\n\t\thrtimer_set_expires(&ctx->t.tmr, texp);\n\t\tctx->t.tmr.function = timerfd_tmrproc;\n\t}\n\n\tif (texp != 0) {\n\t\tif (isalarm(ctx)) {\n\t\t\tif (flags & TFD_TIMER_ABSTIME)\n\t\t\t\talarm_start(&ctx->t.alarm, texp);\n\t\t\telse\n\t\t\t\talarm_start_relative(&ctx->t.alarm, texp);\n\t\t} else {\n\t\t\thrtimer_start(&ctx->t.tmr, texp, htmode);\n\t\t}\n\n\t\tif (timerfd_canceled(ctx))\n\t\t\treturn -ECANCELED;\n\t}\n\n\tctx->settime_flags = flags & TFD_SETTIME_FLAGS;\n\treturn 0;\n}\n\nstatic int timerfd_release(struct inode *inode, struct file *file)\n{\n\tstruct timerfd_ctx *ctx = file->private_data;\n\n\ttimerfd_remove_cancel(ctx);\n\n\tif (isalarm(ctx))\n\t\talarm_cancel(&ctx->t.alarm);\n\telse\n\t\thrtimer_cancel(&ctx->t.tmr);\n\tkfree_rcu(ctx, rcu);\n\treturn 0;\n}\n\nstatic unsigned int timerfd_poll(struct file *file, poll_table *wait)\n{\n\tstruct timerfd_ctx *ctx = file->private_data;\n\tunsigned int events = 0;\n\tunsigned long flags;\n\n\tpoll_wait(file, &ctx->wqh, wait);\n\n\tspin_lock_irqsave(&ctx->wqh.lock, flags);\n\tif (ctx->ticks)\n\t\tevents |= POLLIN;\n\tspin_unlock_irqrestore(&ctx->wqh.lock, flags);\n\n\treturn events;\n}\n\nstatic ssize_t timerfd_read(struct file *file, char __user *buf, size_t count,\n\t\t\t    loff_t *ppos)\n{\n\tstruct timerfd_ctx *ctx = file->private_data;\n\tssize_t res;\n\tu64 ticks = 0;\n\n\tif (count < sizeof(ticks))\n\t\treturn -EINVAL;\n\tspin_lock_irq(&ctx->wqh.lock);\n\tif (file->f_flags & O_NONBLOCK)\n\t\tres = -EAGAIN;\n\telse\n\t\tres = wait_event_interruptible_locked_irq(ctx->wqh, ctx->ticks);\n\n\t/*\n\t * If clock has changed, we do not care about the\n\t * ticks and we do not rearm the timer. Userspace must\n\t * reevaluate anyway.\n\t */\n\tif (timerfd_canceled(ctx)) {\n\t\tctx->ticks = 0;\n\t\tctx->expired = 0;\n\t\tres = -ECANCELED;\n\t}\n\n\tif (ctx->ticks) {\n\t\tticks = ctx->ticks;\n\n\t\tif (ctx->expired && ctx->tintv) {\n\t\t\t/*\n\t\t\t * If tintv != 0, this is a periodic timer that\n\t\t\t * needs to be re-armed. We avoid doing it in the timer\n\t\t\t * callback to avoid DoS attacks specifying a very\n\t\t\t * short timer period.\n\t\t\t */\n\t\t\tif (isalarm(ctx)) {\n\t\t\t\tticks += alarm_forward_now(\n\t\t\t\t\t&ctx->t.alarm, ctx->tintv) - 1;\n\t\t\t\talarm_restart(&ctx->t.alarm);\n\t\t\t} else {\n\t\t\t\tticks += hrtimer_forward_now(&ctx->t.tmr,\n\t\t\t\t\t\t\t     ctx->tintv) - 1;\n\t\t\t\thrtimer_restart(&ctx->t.tmr);\n\t\t\t}\n\t\t}\n\t\tctx->expired = 0;\n\t\tctx->ticks = 0;\n\t}\n\tspin_unlock_irq(&ctx->wqh.lock);\n\tif (ticks)\n\t\tres = put_user(ticks, (u64 __user *) buf) ? -EFAULT: sizeof(ticks);\n\treturn res;\n}\n\n#ifdef CONFIG_PROC_FS\nstatic void timerfd_show(struct seq_file *m, struct file *file)\n{\n\tstruct timerfd_ctx *ctx = file->private_data;\n\tstruct itimerspec t;\n\n\tspin_lock_irq(&ctx->wqh.lock);\n\tt.it_value = ktime_to_timespec(timerfd_get_remaining(ctx));\n\tt.it_interval = ktime_to_timespec(ctx->tintv);\n\tspin_unlock_irq(&ctx->wqh.lock);\n\n\tseq_printf(m,\n\t\t   \"clockid: %d\\n\"\n\t\t   \"ticks: %llu\\n\"\n\t\t   \"settime flags: 0%o\\n\"\n\t\t   \"it_value: (%llu, %llu)\\n\"\n\t\t   \"it_interval: (%llu, %llu)\\n\",\n\t\t   ctx->clockid,\n\t\t   (unsigned long long)ctx->ticks,\n\t\t   ctx->settime_flags,\n\t\t   (unsigned long long)t.it_value.tv_sec,\n\t\t   (unsigned long long)t.it_value.tv_nsec,\n\t\t   (unsigned long long)t.it_interval.tv_sec,\n\t\t   (unsigned long long)t.it_interval.tv_nsec);\n}\n#else\n#define timerfd_show NULL\n#endif\n\n#ifdef CONFIG_CHECKPOINT_RESTORE\nstatic long timerfd_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct timerfd_ctx *ctx = file->private_data;\n\tint ret = 0;\n\n\tswitch (cmd) {\n\tcase TFD_IOC_SET_TICKS: {\n\t\tu64 ticks;\n\n\t\tif (copy_from_user(&ticks, (u64 __user *)arg, sizeof(ticks)))\n\t\t\treturn -EFAULT;\n\t\tif (!ticks)\n\t\t\treturn -EINVAL;\n\n\t\tspin_lock_irq(&ctx->wqh.lock);\n\t\tif (!timerfd_canceled(ctx)) {\n\t\t\tctx->ticks = ticks;\n\t\t\twake_up_locked(&ctx->wqh);\n\t\t} else\n\t\t\tret = -ECANCELED;\n\t\tspin_unlock_irq(&ctx->wqh.lock);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tret = -ENOTTY;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n#else\n#define timerfd_ioctl NULL\n#endif\n\nstatic const struct file_operations timerfd_fops = {\n\t.release\t= timerfd_release,\n\t.poll\t\t= timerfd_poll,\n\t.read\t\t= timerfd_read,\n\t.llseek\t\t= noop_llseek,\n\t.show_fdinfo\t= timerfd_show,\n\t.unlocked_ioctl\t= timerfd_ioctl,\n};\n\nstatic int timerfd_fget(int fd, struct fd *p)\n{\n\tstruct fd f = fdget(fd);\n\tif (!f.file)\n\t\treturn -EBADF;\n\tif (f.file->f_op != &timerfd_fops) {\n\t\tfdput(f);\n\t\treturn -EINVAL;\n\t}\n\t*p = f;\n\treturn 0;\n}\n\nSYSCALL_DEFINE2(timerfd_create, int, clockid, int, flags)\n{\n\tint ufd;\n\tstruct timerfd_ctx *ctx;\n\n\t/* Check the TFD_* constants for consistency.  */\n\tBUILD_BUG_ON(TFD_CLOEXEC != O_CLOEXEC);\n\tBUILD_BUG_ON(TFD_NONBLOCK != O_NONBLOCK);\n\n\tif ((flags & ~TFD_CREATE_FLAGS) ||\n\t    (clockid != CLOCK_MONOTONIC &&\n\t     clockid != CLOCK_REALTIME &&\n\t     clockid != CLOCK_REALTIME_ALARM &&\n\t     clockid != CLOCK_BOOTTIME &&\n\t     clockid != CLOCK_BOOTTIME_ALARM))\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_WAKE_ALARM) &&\n\t    (clockid == CLOCK_REALTIME_ALARM ||\n\t     clockid == CLOCK_BOOTTIME_ALARM))\n\t\treturn -EPERM;\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tinit_waitqueue_head(&ctx->wqh);\n\tctx->clockid = clockid;\n\n\tif (isalarm(ctx))\n\t\talarm_init(&ctx->t.alarm,\n\t\t\t   ctx->clockid == CLOCK_REALTIME_ALARM ?\n\t\t\t   ALARM_REALTIME : ALARM_BOOTTIME,\n\t\t\t   timerfd_alarmproc);\n\telse\n\t\thrtimer_init(&ctx->t.tmr, clockid, HRTIMER_MODE_ABS);\n\n\tctx->moffs = ktime_mono_to_real(0);\n\n\tufd = anon_inode_getfd(\"[timerfd]\", &timerfd_fops, ctx,\n\t\t\t       O_RDWR | (flags & TFD_SHARED_FCNTL_FLAGS));\n\tif (ufd < 0)\n\t\tkfree(ctx);\n\n\treturn ufd;\n}\n\nstatic int do_timerfd_settime(int ufd, int flags, \n\t\tconst struct itimerspec *new,\n\t\tstruct itimerspec *old)\n{\n\tstruct fd f;\n\tstruct timerfd_ctx *ctx;\n\tint ret;\n\n\tif ((flags & ~TFD_SETTIME_FLAGS) ||\n\t    !timespec_valid(&new->it_value) ||\n\t    !timespec_valid(&new->it_interval))\n\t\treturn -EINVAL;\n\n\tret = timerfd_fget(ufd, &f);\n\tif (ret)\n\t\treturn ret;\n\tctx = f.file->private_data;\n\n\tif (!capable(CAP_WAKE_ALARM) && isalarm(ctx)) {\n\t\tfdput(f);\n\t\treturn -EPERM;\n\t}\n\n\ttimerfd_setup_cancel(ctx, flags);\n\n\t/*\n\t * We need to stop the existing timer before reprogramming\n\t * it to the new values.\n\t */\n\tfor (;;) {\n\t\tspin_lock_irq(&ctx->wqh.lock);\n\n\t\tif (isalarm(ctx)) {\n\t\t\tif (alarm_try_to_cancel(&ctx->t.alarm) >= 0)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (hrtimer_try_to_cancel(&ctx->t.tmr) >= 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tspin_unlock_irq(&ctx->wqh.lock);\n\t\tcpu_relax();\n\t}\n\n\t/*\n\t * If the timer is expired and it's periodic, we need to advance it\n\t * because the caller may want to know the previous expiration time.\n\t * We do not update \"ticks\" and \"expired\" since the timer will be\n\t * re-programmed again in the following timerfd_setup() call.\n\t */\n\tif (ctx->expired && ctx->tintv) {\n\t\tif (isalarm(ctx))\n\t\t\talarm_forward_now(&ctx->t.alarm, ctx->tintv);\n\t\telse\n\t\t\thrtimer_forward_now(&ctx->t.tmr, ctx->tintv);\n\t}\n\n\told->it_value = ktime_to_timespec(timerfd_get_remaining(ctx));\n\told->it_interval = ktime_to_timespec(ctx->tintv);\n\n\t/*\n\t * Re-program the timer to the new value ...\n\t */\n\tret = timerfd_setup(ctx, flags, new);\n\n\tspin_unlock_irq(&ctx->wqh.lock);\n\tfdput(f);\n\treturn ret;\n}\n\nstatic int do_timerfd_gettime(int ufd, struct itimerspec *t)\n{\n\tstruct fd f;\n\tstruct timerfd_ctx *ctx;\n\tint ret = timerfd_fget(ufd, &f);\n\tif (ret)\n\t\treturn ret;\n\tctx = f.file->private_data;\n\n\tspin_lock_irq(&ctx->wqh.lock);\n\tif (ctx->expired && ctx->tintv) {\n\t\tctx->expired = 0;\n\n\t\tif (isalarm(ctx)) {\n\t\t\tctx->ticks +=\n\t\t\t\talarm_forward_now(\n\t\t\t\t\t&ctx->t.alarm, ctx->tintv) - 1;\n\t\t\talarm_restart(&ctx->t.alarm);\n\t\t} else {\n\t\t\tctx->ticks +=\n\t\t\t\thrtimer_forward_now(&ctx->t.tmr, ctx->tintv)\n\t\t\t\t- 1;\n\t\t\thrtimer_restart(&ctx->t.tmr);\n\t\t}\n\t}\n\tt->it_value = ktime_to_timespec(timerfd_get_remaining(ctx));\n\tt->it_interval = ktime_to_timespec(ctx->tintv);\n\tspin_unlock_irq(&ctx->wqh.lock);\n\tfdput(f);\n\treturn 0;\n}\n\nSYSCALL_DEFINE4(timerfd_settime, int, ufd, int, flags,\n\t\tconst struct itimerspec __user *, utmr,\n\t\tstruct itimerspec __user *, otmr)\n{\n\tstruct itimerspec new, old;\n\tint ret;\n\n\tif (copy_from_user(&new, utmr, sizeof(new)))\n\t\treturn -EFAULT;\n\tret = do_timerfd_settime(ufd, flags, &new, &old);\n\tif (ret)\n\t\treturn ret;\n\tif (otmr && copy_to_user(otmr, &old, sizeof(old)))\n\t\treturn -EFAULT;\n\n\treturn ret;\n}\n\nSYSCALL_DEFINE2(timerfd_gettime, int, ufd, struct itimerspec __user *, otmr)\n{\n\tstruct itimerspec kotmr;\n\tint ret = do_timerfd_gettime(ufd, &kotmr);\n\tif (ret)\n\t\treturn ret;\n\treturn copy_to_user(otmr, &kotmr, sizeof(kotmr)) ? -EFAULT: 0;\n}\n\n#ifdef CONFIG_COMPAT\nCOMPAT_SYSCALL_DEFINE4(timerfd_settime, int, ufd, int, flags,\n\t\tconst struct compat_itimerspec __user *, utmr,\n\t\tstruct compat_itimerspec __user *, otmr)\n{\n\tstruct itimerspec new, old;\n\tint ret;\n\n\tif (get_compat_itimerspec(&new, utmr))\n\t\treturn -EFAULT;\n\tret = do_timerfd_settime(ufd, flags, &new, &old);\n\tif (ret)\n\t\treturn ret;\n\tif (otmr && put_compat_itimerspec(otmr, &old))\n\t\treturn -EFAULT;\n\treturn ret;\n}\n\nCOMPAT_SYSCALL_DEFINE2(timerfd_gettime, int, ufd,\n\t\tstruct compat_itimerspec __user *, otmr)\n{\n\tstruct itimerspec kotmr;\n\tint ret = do_timerfd_gettime(ufd, &kotmr);\n\tif (ret)\n\t\treturn ret;\n\treturn put_compat_itimerspec(otmr, &kotmr) ? -EFAULT: 0;\n}\n#endif\n"], "fixing_code": ["/*\n *  fs/timerfd.c\n *\n *  Copyright (C) 2007  Davide Libenzi <davidel@xmailserver.org>\n *\n *\n *  Thanks to Thomas Gleixner for code reviews and useful comments.\n *\n */\n\n#include <linux/alarmtimer.h>\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/time.h>\n#include <linux/hrtimer.h>\n#include <linux/anon_inodes.h>\n#include <linux/timerfd.h>\n#include <linux/syscalls.h>\n#include <linux/compat.h>\n#include <linux/rcupdate.h>\n\nstruct timerfd_ctx {\n\tunion {\n\t\tstruct hrtimer tmr;\n\t\tstruct alarm alarm;\n\t} t;\n\tktime_t tintv;\n\tktime_t moffs;\n\twait_queue_head_t wqh;\n\tu64 ticks;\n\tint clockid;\n\tshort unsigned expired;\n\tshort unsigned settime_flags;\t/* to show in fdinfo */\n\tstruct rcu_head rcu;\n\tstruct list_head clist;\n\tspinlock_t cancel_lock;\n\tbool might_cancel;\n};\n\nstatic LIST_HEAD(cancel_list);\nstatic DEFINE_SPINLOCK(cancel_lock);\n\nstatic inline bool isalarm(struct timerfd_ctx *ctx)\n{\n\treturn ctx->clockid == CLOCK_REALTIME_ALARM ||\n\t\tctx->clockid == CLOCK_BOOTTIME_ALARM;\n}\n\n/*\n * This gets called when the timer event triggers. We set the \"expired\"\n * flag, but we do not re-arm the timer (in case it's necessary,\n * tintv != 0) until the timer is accessed.\n */\nstatic void timerfd_triggered(struct timerfd_ctx *ctx)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ctx->wqh.lock, flags);\n\tctx->expired = 1;\n\tctx->ticks++;\n\twake_up_locked(&ctx->wqh);\n\tspin_unlock_irqrestore(&ctx->wqh.lock, flags);\n}\n\nstatic enum hrtimer_restart timerfd_tmrproc(struct hrtimer *htmr)\n{\n\tstruct timerfd_ctx *ctx = container_of(htmr, struct timerfd_ctx,\n\t\t\t\t\t       t.tmr);\n\ttimerfd_triggered(ctx);\n\treturn HRTIMER_NORESTART;\n}\n\nstatic enum alarmtimer_restart timerfd_alarmproc(struct alarm *alarm,\n\tktime_t now)\n{\n\tstruct timerfd_ctx *ctx = container_of(alarm, struct timerfd_ctx,\n\t\t\t\t\t       t.alarm);\n\ttimerfd_triggered(ctx);\n\treturn ALARMTIMER_NORESTART;\n}\n\n/*\n * Called when the clock was set to cancel the timers in the cancel\n * list. This will wake up processes waiting on these timers. The\n * wake-up requires ctx->ticks to be non zero, therefore we increment\n * it before calling wake_up_locked().\n */\nvoid timerfd_clock_was_set(void)\n{\n\tktime_t moffs = ktime_mono_to_real(0);\n\tstruct timerfd_ctx *ctx;\n\tunsigned long flags;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(ctx, &cancel_list, clist) {\n\t\tif (!ctx->might_cancel)\n\t\t\tcontinue;\n\t\tspin_lock_irqsave(&ctx->wqh.lock, flags);\n\t\tif (ctx->moffs != moffs) {\n\t\t\tctx->moffs = KTIME_MAX;\n\t\t\tctx->ticks++;\n\t\t\twake_up_locked(&ctx->wqh);\n\t\t}\n\t\tspin_unlock_irqrestore(&ctx->wqh.lock, flags);\n\t}\n\trcu_read_unlock();\n}\n\nstatic void __timerfd_remove_cancel(struct timerfd_ctx *ctx)\n{\n\tif (ctx->might_cancel) {\n\t\tctx->might_cancel = false;\n\t\tspin_lock(&cancel_lock);\n\t\tlist_del_rcu(&ctx->clist);\n\t\tspin_unlock(&cancel_lock);\n\t}\n}\n\nstatic void timerfd_remove_cancel(struct timerfd_ctx *ctx)\n{\n\tspin_lock(&ctx->cancel_lock);\n\t__timerfd_remove_cancel(ctx);\n\tspin_unlock(&ctx->cancel_lock);\n}\n\nstatic bool timerfd_canceled(struct timerfd_ctx *ctx)\n{\n\tif (!ctx->might_cancel || ctx->moffs != KTIME_MAX)\n\t\treturn false;\n\tctx->moffs = ktime_mono_to_real(0);\n\treturn true;\n}\n\nstatic void timerfd_setup_cancel(struct timerfd_ctx *ctx, int flags)\n{\n\tspin_lock(&ctx->cancel_lock);\n\tif ((ctx->clockid == CLOCK_REALTIME ||\n\t     ctx->clockid == CLOCK_REALTIME_ALARM) &&\n\t    (flags & TFD_TIMER_ABSTIME) && (flags & TFD_TIMER_CANCEL_ON_SET)) {\n\t\tif (!ctx->might_cancel) {\n\t\t\tctx->might_cancel = true;\n\t\t\tspin_lock(&cancel_lock);\n\t\t\tlist_add_rcu(&ctx->clist, &cancel_list);\n\t\t\tspin_unlock(&cancel_lock);\n\t\t}\n\t} else {\n\t\t__timerfd_remove_cancel(ctx);\n\t}\n\tspin_unlock(&ctx->cancel_lock);\n}\n\nstatic ktime_t timerfd_get_remaining(struct timerfd_ctx *ctx)\n{\n\tktime_t remaining;\n\n\tif (isalarm(ctx))\n\t\tremaining = alarm_expires_remaining(&ctx->t.alarm);\n\telse\n\t\tremaining = hrtimer_expires_remaining_adjusted(&ctx->t.tmr);\n\n\treturn remaining < 0 ? 0: remaining;\n}\n\nstatic int timerfd_setup(struct timerfd_ctx *ctx, int flags,\n\t\t\t const struct itimerspec *ktmr)\n{\n\tenum hrtimer_mode htmode;\n\tktime_t texp;\n\tint clockid = ctx->clockid;\n\n\thtmode = (flags & TFD_TIMER_ABSTIME) ?\n\t\tHRTIMER_MODE_ABS: HRTIMER_MODE_REL;\n\n\ttexp = timespec_to_ktime(ktmr->it_value);\n\tctx->expired = 0;\n\tctx->ticks = 0;\n\tctx->tintv = timespec_to_ktime(ktmr->it_interval);\n\n\tif (isalarm(ctx)) {\n\t\talarm_init(&ctx->t.alarm,\n\t\t\t   ctx->clockid == CLOCK_REALTIME_ALARM ?\n\t\t\t   ALARM_REALTIME : ALARM_BOOTTIME,\n\t\t\t   timerfd_alarmproc);\n\t} else {\n\t\thrtimer_init(&ctx->t.tmr, clockid, htmode);\n\t\thrtimer_set_expires(&ctx->t.tmr, texp);\n\t\tctx->t.tmr.function = timerfd_tmrproc;\n\t}\n\n\tif (texp != 0) {\n\t\tif (isalarm(ctx)) {\n\t\t\tif (flags & TFD_TIMER_ABSTIME)\n\t\t\t\talarm_start(&ctx->t.alarm, texp);\n\t\t\telse\n\t\t\t\talarm_start_relative(&ctx->t.alarm, texp);\n\t\t} else {\n\t\t\thrtimer_start(&ctx->t.tmr, texp, htmode);\n\t\t}\n\n\t\tif (timerfd_canceled(ctx))\n\t\t\treturn -ECANCELED;\n\t}\n\n\tctx->settime_flags = flags & TFD_SETTIME_FLAGS;\n\treturn 0;\n}\n\nstatic int timerfd_release(struct inode *inode, struct file *file)\n{\n\tstruct timerfd_ctx *ctx = file->private_data;\n\n\ttimerfd_remove_cancel(ctx);\n\n\tif (isalarm(ctx))\n\t\talarm_cancel(&ctx->t.alarm);\n\telse\n\t\thrtimer_cancel(&ctx->t.tmr);\n\tkfree_rcu(ctx, rcu);\n\treturn 0;\n}\n\nstatic unsigned int timerfd_poll(struct file *file, poll_table *wait)\n{\n\tstruct timerfd_ctx *ctx = file->private_data;\n\tunsigned int events = 0;\n\tunsigned long flags;\n\n\tpoll_wait(file, &ctx->wqh, wait);\n\n\tspin_lock_irqsave(&ctx->wqh.lock, flags);\n\tif (ctx->ticks)\n\t\tevents |= POLLIN;\n\tspin_unlock_irqrestore(&ctx->wqh.lock, flags);\n\n\treturn events;\n}\n\nstatic ssize_t timerfd_read(struct file *file, char __user *buf, size_t count,\n\t\t\t    loff_t *ppos)\n{\n\tstruct timerfd_ctx *ctx = file->private_data;\n\tssize_t res;\n\tu64 ticks = 0;\n\n\tif (count < sizeof(ticks))\n\t\treturn -EINVAL;\n\tspin_lock_irq(&ctx->wqh.lock);\n\tif (file->f_flags & O_NONBLOCK)\n\t\tres = -EAGAIN;\n\telse\n\t\tres = wait_event_interruptible_locked_irq(ctx->wqh, ctx->ticks);\n\n\t/*\n\t * If clock has changed, we do not care about the\n\t * ticks and we do not rearm the timer. Userspace must\n\t * reevaluate anyway.\n\t */\n\tif (timerfd_canceled(ctx)) {\n\t\tctx->ticks = 0;\n\t\tctx->expired = 0;\n\t\tres = -ECANCELED;\n\t}\n\n\tif (ctx->ticks) {\n\t\tticks = ctx->ticks;\n\n\t\tif (ctx->expired && ctx->tintv) {\n\t\t\t/*\n\t\t\t * If tintv != 0, this is a periodic timer that\n\t\t\t * needs to be re-armed. We avoid doing it in the timer\n\t\t\t * callback to avoid DoS attacks specifying a very\n\t\t\t * short timer period.\n\t\t\t */\n\t\t\tif (isalarm(ctx)) {\n\t\t\t\tticks += alarm_forward_now(\n\t\t\t\t\t&ctx->t.alarm, ctx->tintv) - 1;\n\t\t\t\talarm_restart(&ctx->t.alarm);\n\t\t\t} else {\n\t\t\t\tticks += hrtimer_forward_now(&ctx->t.tmr,\n\t\t\t\t\t\t\t     ctx->tintv) - 1;\n\t\t\t\thrtimer_restart(&ctx->t.tmr);\n\t\t\t}\n\t\t}\n\t\tctx->expired = 0;\n\t\tctx->ticks = 0;\n\t}\n\tspin_unlock_irq(&ctx->wqh.lock);\n\tif (ticks)\n\t\tres = put_user(ticks, (u64 __user *) buf) ? -EFAULT: sizeof(ticks);\n\treturn res;\n}\n\n#ifdef CONFIG_PROC_FS\nstatic void timerfd_show(struct seq_file *m, struct file *file)\n{\n\tstruct timerfd_ctx *ctx = file->private_data;\n\tstruct itimerspec t;\n\n\tspin_lock_irq(&ctx->wqh.lock);\n\tt.it_value = ktime_to_timespec(timerfd_get_remaining(ctx));\n\tt.it_interval = ktime_to_timespec(ctx->tintv);\n\tspin_unlock_irq(&ctx->wqh.lock);\n\n\tseq_printf(m,\n\t\t   \"clockid: %d\\n\"\n\t\t   \"ticks: %llu\\n\"\n\t\t   \"settime flags: 0%o\\n\"\n\t\t   \"it_value: (%llu, %llu)\\n\"\n\t\t   \"it_interval: (%llu, %llu)\\n\",\n\t\t   ctx->clockid,\n\t\t   (unsigned long long)ctx->ticks,\n\t\t   ctx->settime_flags,\n\t\t   (unsigned long long)t.it_value.tv_sec,\n\t\t   (unsigned long long)t.it_value.tv_nsec,\n\t\t   (unsigned long long)t.it_interval.tv_sec,\n\t\t   (unsigned long long)t.it_interval.tv_nsec);\n}\n#else\n#define timerfd_show NULL\n#endif\n\n#ifdef CONFIG_CHECKPOINT_RESTORE\nstatic long timerfd_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct timerfd_ctx *ctx = file->private_data;\n\tint ret = 0;\n\n\tswitch (cmd) {\n\tcase TFD_IOC_SET_TICKS: {\n\t\tu64 ticks;\n\n\t\tif (copy_from_user(&ticks, (u64 __user *)arg, sizeof(ticks)))\n\t\t\treturn -EFAULT;\n\t\tif (!ticks)\n\t\t\treturn -EINVAL;\n\n\t\tspin_lock_irq(&ctx->wqh.lock);\n\t\tif (!timerfd_canceled(ctx)) {\n\t\t\tctx->ticks = ticks;\n\t\t\twake_up_locked(&ctx->wqh);\n\t\t} else\n\t\t\tret = -ECANCELED;\n\t\tspin_unlock_irq(&ctx->wqh.lock);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tret = -ENOTTY;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n#else\n#define timerfd_ioctl NULL\n#endif\n\nstatic const struct file_operations timerfd_fops = {\n\t.release\t= timerfd_release,\n\t.poll\t\t= timerfd_poll,\n\t.read\t\t= timerfd_read,\n\t.llseek\t\t= noop_llseek,\n\t.show_fdinfo\t= timerfd_show,\n\t.unlocked_ioctl\t= timerfd_ioctl,\n};\n\nstatic int timerfd_fget(int fd, struct fd *p)\n{\n\tstruct fd f = fdget(fd);\n\tif (!f.file)\n\t\treturn -EBADF;\n\tif (f.file->f_op != &timerfd_fops) {\n\t\tfdput(f);\n\t\treturn -EINVAL;\n\t}\n\t*p = f;\n\treturn 0;\n}\n\nSYSCALL_DEFINE2(timerfd_create, int, clockid, int, flags)\n{\n\tint ufd;\n\tstruct timerfd_ctx *ctx;\n\n\t/* Check the TFD_* constants for consistency.  */\n\tBUILD_BUG_ON(TFD_CLOEXEC != O_CLOEXEC);\n\tBUILD_BUG_ON(TFD_NONBLOCK != O_NONBLOCK);\n\n\tif ((flags & ~TFD_CREATE_FLAGS) ||\n\t    (clockid != CLOCK_MONOTONIC &&\n\t     clockid != CLOCK_REALTIME &&\n\t     clockid != CLOCK_REALTIME_ALARM &&\n\t     clockid != CLOCK_BOOTTIME &&\n\t     clockid != CLOCK_BOOTTIME_ALARM))\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_WAKE_ALARM) &&\n\t    (clockid == CLOCK_REALTIME_ALARM ||\n\t     clockid == CLOCK_BOOTTIME_ALARM))\n\t\treturn -EPERM;\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tinit_waitqueue_head(&ctx->wqh);\n\tspin_lock_init(&ctx->cancel_lock);\n\tctx->clockid = clockid;\n\n\tif (isalarm(ctx))\n\t\talarm_init(&ctx->t.alarm,\n\t\t\t   ctx->clockid == CLOCK_REALTIME_ALARM ?\n\t\t\t   ALARM_REALTIME : ALARM_BOOTTIME,\n\t\t\t   timerfd_alarmproc);\n\telse\n\t\thrtimer_init(&ctx->t.tmr, clockid, HRTIMER_MODE_ABS);\n\n\tctx->moffs = ktime_mono_to_real(0);\n\n\tufd = anon_inode_getfd(\"[timerfd]\", &timerfd_fops, ctx,\n\t\t\t       O_RDWR | (flags & TFD_SHARED_FCNTL_FLAGS));\n\tif (ufd < 0)\n\t\tkfree(ctx);\n\n\treturn ufd;\n}\n\nstatic int do_timerfd_settime(int ufd, int flags, \n\t\tconst struct itimerspec *new,\n\t\tstruct itimerspec *old)\n{\n\tstruct fd f;\n\tstruct timerfd_ctx *ctx;\n\tint ret;\n\n\tif ((flags & ~TFD_SETTIME_FLAGS) ||\n\t    !timespec_valid(&new->it_value) ||\n\t    !timespec_valid(&new->it_interval))\n\t\treturn -EINVAL;\n\n\tret = timerfd_fget(ufd, &f);\n\tif (ret)\n\t\treturn ret;\n\tctx = f.file->private_data;\n\n\tif (!capable(CAP_WAKE_ALARM) && isalarm(ctx)) {\n\t\tfdput(f);\n\t\treturn -EPERM;\n\t}\n\n\ttimerfd_setup_cancel(ctx, flags);\n\n\t/*\n\t * We need to stop the existing timer before reprogramming\n\t * it to the new values.\n\t */\n\tfor (;;) {\n\t\tspin_lock_irq(&ctx->wqh.lock);\n\n\t\tif (isalarm(ctx)) {\n\t\t\tif (alarm_try_to_cancel(&ctx->t.alarm) >= 0)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (hrtimer_try_to_cancel(&ctx->t.tmr) >= 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tspin_unlock_irq(&ctx->wqh.lock);\n\t\tcpu_relax();\n\t}\n\n\t/*\n\t * If the timer is expired and it's periodic, we need to advance it\n\t * because the caller may want to know the previous expiration time.\n\t * We do not update \"ticks\" and \"expired\" since the timer will be\n\t * re-programmed again in the following timerfd_setup() call.\n\t */\n\tif (ctx->expired && ctx->tintv) {\n\t\tif (isalarm(ctx))\n\t\t\talarm_forward_now(&ctx->t.alarm, ctx->tintv);\n\t\telse\n\t\t\thrtimer_forward_now(&ctx->t.tmr, ctx->tintv);\n\t}\n\n\told->it_value = ktime_to_timespec(timerfd_get_remaining(ctx));\n\told->it_interval = ktime_to_timespec(ctx->tintv);\n\n\t/*\n\t * Re-program the timer to the new value ...\n\t */\n\tret = timerfd_setup(ctx, flags, new);\n\n\tspin_unlock_irq(&ctx->wqh.lock);\n\tfdput(f);\n\treturn ret;\n}\n\nstatic int do_timerfd_gettime(int ufd, struct itimerspec *t)\n{\n\tstruct fd f;\n\tstruct timerfd_ctx *ctx;\n\tint ret = timerfd_fget(ufd, &f);\n\tif (ret)\n\t\treturn ret;\n\tctx = f.file->private_data;\n\n\tspin_lock_irq(&ctx->wqh.lock);\n\tif (ctx->expired && ctx->tintv) {\n\t\tctx->expired = 0;\n\n\t\tif (isalarm(ctx)) {\n\t\t\tctx->ticks +=\n\t\t\t\talarm_forward_now(\n\t\t\t\t\t&ctx->t.alarm, ctx->tintv) - 1;\n\t\t\talarm_restart(&ctx->t.alarm);\n\t\t} else {\n\t\t\tctx->ticks +=\n\t\t\t\thrtimer_forward_now(&ctx->t.tmr, ctx->tintv)\n\t\t\t\t- 1;\n\t\t\thrtimer_restart(&ctx->t.tmr);\n\t\t}\n\t}\n\tt->it_value = ktime_to_timespec(timerfd_get_remaining(ctx));\n\tt->it_interval = ktime_to_timespec(ctx->tintv);\n\tspin_unlock_irq(&ctx->wqh.lock);\n\tfdput(f);\n\treturn 0;\n}\n\nSYSCALL_DEFINE4(timerfd_settime, int, ufd, int, flags,\n\t\tconst struct itimerspec __user *, utmr,\n\t\tstruct itimerspec __user *, otmr)\n{\n\tstruct itimerspec new, old;\n\tint ret;\n\n\tif (copy_from_user(&new, utmr, sizeof(new)))\n\t\treturn -EFAULT;\n\tret = do_timerfd_settime(ufd, flags, &new, &old);\n\tif (ret)\n\t\treturn ret;\n\tif (otmr && copy_to_user(otmr, &old, sizeof(old)))\n\t\treturn -EFAULT;\n\n\treturn ret;\n}\n\nSYSCALL_DEFINE2(timerfd_gettime, int, ufd, struct itimerspec __user *, otmr)\n{\n\tstruct itimerspec kotmr;\n\tint ret = do_timerfd_gettime(ufd, &kotmr);\n\tif (ret)\n\t\treturn ret;\n\treturn copy_to_user(otmr, &kotmr, sizeof(kotmr)) ? -EFAULT: 0;\n}\n\n#ifdef CONFIG_COMPAT\nCOMPAT_SYSCALL_DEFINE4(timerfd_settime, int, ufd, int, flags,\n\t\tconst struct compat_itimerspec __user *, utmr,\n\t\tstruct compat_itimerspec __user *, otmr)\n{\n\tstruct itimerspec new, old;\n\tint ret;\n\n\tif (get_compat_itimerspec(&new, utmr))\n\t\treturn -EFAULT;\n\tret = do_timerfd_settime(ufd, flags, &new, &old);\n\tif (ret)\n\t\treturn ret;\n\tif (otmr && put_compat_itimerspec(otmr, &old))\n\t\treturn -EFAULT;\n\treturn ret;\n}\n\nCOMPAT_SYSCALL_DEFINE2(timerfd_gettime, int, ufd,\n\t\tstruct compat_itimerspec __user *, otmr)\n{\n\tstruct itimerspec kotmr;\n\tint ret = do_timerfd_gettime(ufd, &kotmr);\n\tif (ret)\n\t\treturn ret;\n\treturn put_compat_itimerspec(otmr, &kotmr) ? -EFAULT: 0;\n}\n#endif\n"], "filenames": ["fs/timerfd.c"], "buggy_code_start_loc": [42], "buggy_code_end_loc": [402], "fixing_code_start_loc": [43], "fixing_code_end_loc": [414], "type": "CWE-416", "message": "Race condition in fs/timerfd.c in the Linux kernel before 4.10.15 allows local users to gain privileges or cause a denial of service (list corruption or use-after-free) via simultaneous file-descriptor operations that leverage improper might_cancel queueing.", "other": {"cve": {"id": "CVE-2017-10661", "sourceIdentifier": "cve@mitre.org", "published": "2017-08-19T18:29:00.257", "lastModified": "2018-10-31T10:29:04.183", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Race condition in fs/timerfd.c in the Linux kernel before 4.10.15 allows local users to gain privileges or cause a denial of service (list corruption or use-after-free) via simultaneous file-descriptor operations that leverage improper might_cancel queueing."}, {"lang": "es", "value": "Una condici\u00f3n de carrera en fs/timerfd.c en el kernel Linux en versiones anteriores a la 4.10.15 permite que usuarios locales obtengan privilegios o provoquen una denegaci\u00f3n de servicio (corrupci\u00f3n de lista o use-after-free) mediante operaciones simult\u00e1neas de descriptor de archivo que aprovechan la cola inadecuada might_cancel."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:H/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.0, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.0, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:H/Au:N/C:C/I:C/A:C", "accessVector": "NETWORK", "accessComplexity": "HIGH", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.6}, "baseSeverity": "HIGH", "exploitabilityScore": 4.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.10.14", "matchCriteriaId": "FCD21859-C02B-4853-843A-4F88C23EA7C2"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=1e38da300e1e395a15048b0af1e5305bd91402f6", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "http://www.debian.org/security/2017/dsa-3981", "source": "cve@mitre.org"}, {"url": "http://www.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.10.15", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "http://www.securityfocus.com/bid/100215", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:3083", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2018:3096", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2019:4057", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2019:4058", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2020:0036", "source": "cve@mitre.org"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1481136", "source": "cve@mitre.org", "tags": ["Issue Tracking"]}, {"url": "https://github.com/torvalds/linux/commit/1e38da300e1e395a15048b0af1e5305bd91402f6", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://source.android.com/security/bulletin/2017-08-01", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://www.exploit-db.com/exploits/43345/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/1e38da300e1e395a15048b0af1e5305bd91402f6"}}