{"buggy_code": ["import NIOCore\nimport NIOExtras\nimport NIOHTTP1\nimport NIOHTTP2\nimport NIOHTTPCompression\nimport NIOSSL\nimport Logging\nimport NIOPosix\nimport NIOConcurrencyHelpers\n\npublic enum HTTPVersionMajor: Equatable, Hashable, Sendable {\n    case one\n    case two\n}\n\npublic final class HTTPServer: Server, Sendable {\n    /// Engine server config struct.\n    ///\n    ///     let serverConfig = HTTPServerConfig.default(port: 8123)\n    ///     services.register(serverConfig)\n    ///\n    public struct Configuration: Sendable {\n        public static let defaultHostname = \"127.0.0.1\"\n        public static let defaultPort = 8080\n        \n        /// Address the server will bind to. Configuring an address using a hostname with a nil host or port will use the default hostname or port respectively.\n        public var address: BindAddress\n        \n        /// Host name the server will bind to.\n        public var hostname: String {\n            get {\n                switch address {\n                case .hostname(let hostname, _):\n                    return hostname ?? Self.defaultHostname\n                default:\n                    return Self.defaultHostname\n                }\n            }\n            set {\n                switch address {\n                case .hostname(_, let port):\n                    address = .hostname(newValue, port: port)\n                default:\n                    address = .hostname(newValue, port: nil)\n                }\n            }\n        }\n        \n        /// Port the server will bind to.\n        public var port: Int {\n           get {\n               switch address {\n               case .hostname(_, let port):\n                   return port ?? Self.defaultPort\n               default:\n                   return Self.defaultPort\n               }\n           }\n           set {\n               switch address {\n               case .hostname(let hostname, _):\n                   address = .hostname(hostname, port: newValue)\n               default:\n                   address = .hostname(nil, port: newValue)\n               }\n           }\n       }\n        \n        /// Listen backlog.\n        public var backlog: Int\n        \n        /// When `true`, can prevent errors re-binding to a socket after successive server restarts.\n        public var reuseAddress: Bool\n        \n        /// When `true`, OS will attempt to minimize TCP packet delay.\n        public var tcpNoDelay: Bool\n\n        /// Response compression configuration.\n        public var responseCompression: CompressionConfiguration\n\n        /// Supported HTTP compression options.\n        public struct CompressionConfiguration: Sendable {\n            /// Disables compression. This is the default.\n            public static var disabled: Self {\n                .init(storage: .disabled)\n            }\n\n            /// Enables compression with default configuration.\n            public static var enabled: Self {\n                .enabled(initialByteBufferCapacity: 1024)\n            }\n\n            /// Enables compression with custom configuration.\n            public static func enabled(\n                initialByteBufferCapacity: Int\n            ) -> Self {\n                .init(storage: .enabled(\n                    initialByteBufferCapacity: initialByteBufferCapacity\n                ))\n            }\n\n            enum Storage {\n                case disabled\n                case enabled(initialByteBufferCapacity: Int)\n            }\n\n            var storage: Storage\n        }\n\n        /// Request decompression configuration.\n        public var requestDecompression: DecompressionConfiguration\n\n        /// Supported HTTP decompression options.\n        public struct DecompressionConfiguration: Sendable {\n            /// Disables decompression. This is the default option.\n            public static var disabled: Self {\n                .init(storage: .disabled)\n            }\n\n            /// Enables decompression with default configuration.\n            public static var enabled: Self {\n                .enabled(limit: .ratio(10))\n            }\n\n            /// Enables decompression with custom configuration.\n            public static func enabled(\n                limit: NIOHTTPDecompression.DecompressionLimit\n            ) -> Self {\n                .init(storage: .enabled(limit: limit))\n            }\n\n            enum Storage {\n                case disabled\n                case enabled(limit: NIOHTTPDecompression.DecompressionLimit)\n            }\n\n            var storage: Storage\n        }\n        \n        /// When `true`, HTTP server will support pipelined requests.\n        public var supportPipelining: Bool\n        \n        public var supportVersions: Set<HTTPVersionMajor>\n        \n        public var tlsConfiguration: TLSConfiguration?\n        \n        /// If set, this name will be serialized as the `Server` header in outgoing responses.\n        public var serverName: String?\n\n        /// When `true`, report http metrics through `swift-metrics`\n        public var reportMetrics: Bool\n\n        /// Any uncaught server or responder errors will go here.\n        public var logger: Logger\n\n        /// A time limit to complete a graceful shutdown\n        public var shutdownTimeout: TimeAmount\n\n        /// An optional callback that will be called instead of using swift-nio-ssl's regular certificate verification logic.\n        /// This is the same as `NIOSSLCustomVerificationCallback` but just marked as `Sendable`\n        @preconcurrency\n        public var customCertificateVerifyCallback: (@Sendable ([NIOSSLCertificate], EventLoopPromise<NIOSSLVerificationResult>) -> Void)?\n\n        public init(\n            hostname: String = Self.defaultHostname,\n            port: Int = Self.defaultPort,\n            backlog: Int = 256,\n            reuseAddress: Bool = true,\n            tcpNoDelay: Bool = true,\n            responseCompression: CompressionConfiguration = .disabled,\n            requestDecompression: DecompressionConfiguration = .disabled,\n            supportPipelining: Bool = true,\n            supportVersions: Set<HTTPVersionMajor>? = nil,\n            tlsConfiguration: TLSConfiguration? = nil,\n            serverName: String? = nil,\n            reportMetrics: Bool = true,\n            logger: Logger? = nil,\n            shutdownTimeout: TimeAmount = .seconds(10)\n        ) {\n            self.init(\n                address: .hostname(hostname, port: port),\n                backlog: backlog,\n                reuseAddress: reuseAddress,\n                tcpNoDelay: tcpNoDelay,\n                responseCompression: responseCompression,\n                requestDecompression: requestDecompression,\n                supportPipelining: supportPipelining,\n                supportVersions: supportVersions,\n                tlsConfiguration: tlsConfiguration,\n                serverName: serverName,\n                reportMetrics: reportMetrics,\n                logger: logger,\n                shutdownTimeout: shutdownTimeout\n            )\n        }\n        \n        public init(\n            address: BindAddress,\n            backlog: Int = 256,\n            reuseAddress: Bool = true,\n            tcpNoDelay: Bool = true,\n            responseCompression: CompressionConfiguration = .disabled,\n            requestDecompression: DecompressionConfiguration = .disabled,\n            supportPipelining: Bool = true,\n            supportVersions: Set<HTTPVersionMajor>? = nil,\n            tlsConfiguration: TLSConfiguration? = nil,\n            serverName: String? = nil,\n            reportMetrics: Bool = true,\n            logger: Logger? = nil,\n            shutdownTimeout: TimeAmount = .seconds(10)\n        ) {\n            self.address = address\n            self.backlog = backlog\n            self.reuseAddress = reuseAddress\n            self.tcpNoDelay = tcpNoDelay\n            self.responseCompression = responseCompression\n            self.requestDecompression = requestDecompression\n            self.supportPipelining = supportPipelining\n            if let supportVersions = supportVersions {\n                self.supportVersions = supportVersions\n            } else {\n                self.supportVersions = tlsConfiguration == nil ? [.one] : [.one, .two]\n            }\n            self.tlsConfiguration = tlsConfiguration\n            self.serverName = serverName\n            self.reportMetrics = reportMetrics\n            self.logger = logger ?? Logger(label: \"codes.vapor.http-server\")\n            self.shutdownTimeout = shutdownTimeout\n            self.customCertificateVerifyCallback = nil\n        }\n    }\n    \n    public var onShutdown: EventLoopFuture<Void> {\n        guard let connection = self.connection.withLockedValue({ $0 }) else {\n            fatalError(\"Server has not started yet\")\n        }\n        return connection.channel.closeFuture\n    }\n\n    public var configuration: Configuration {\n        get { _configuration.withLockedValue { $0 } }\n        set {\n            guard !didStart.withLockedValue({ $0 }) else {\n                _configuration.withLockedValue({ $0 }).logger.warning(\"Cannot modify server configuration after server has been started.\")\n                return\n            }\n            self.application.storage[Application.HTTP.Server.ConfigurationKey.self] = newValue\n            _configuration.withLockedValue { $0 = newValue }\n        }\n    }\n\n    private let responder: Responder\n    private let _configuration: NIOLockedValueBox<Configuration>\n    private let eventLoopGroup: EventLoopGroup\n    private let connection: NIOLockedValueBox<HTTPServerConnection?>\n    private let didShutdown: NIOLockedValueBox<Bool>\n    private let didStart: NIOLockedValueBox<Bool>\n    private let application: Application\n    \n    public init(\n        application: Application,\n        responder: Responder,\n        configuration: Configuration,\n        on eventLoopGroup: EventLoopGroup\n    ) {\n        self.application = application\n        self.responder = responder\n        self._configuration = .init(configuration)\n        self.eventLoopGroup = eventLoopGroup\n        self.didStart = .init(false)\n        self.didShutdown = .init(false)\n        self.connection = .init(nil)\n    }\n    \n    public func start(address: BindAddress?) throws {\n        var configuration = self.configuration\n        \n        switch address {\n        case .none: // use the configuration as is\n            break\n        case .hostname(let hostname, let port): // override the hostname, port, neither, or both\n            configuration.address = .hostname(hostname ?? configuration.hostname, port: port ?? configuration.port)\n        case .unixDomainSocket: // override the socket path\n            configuration.address = address!\n        }\n        \n        // print starting message\n        let scheme = configuration.tlsConfiguration == nil ? \"http\" : \"https\"\n        let addressDescription: String\n        switch configuration.address {\n        case .hostname(let hostname, let port):\n            addressDescription = \"\\(scheme)://\\(hostname ?? configuration.hostname):\\(port ?? configuration.port)\"\n        case .unixDomainSocket(let socketPath):\n            addressDescription = \"\\(scheme)+unix: \\(socketPath)\"\n        }\n        \n        self.configuration.logger.notice(\"Server starting on \\(addressDescription)\")\n\n        // start the actual HTTPServer\n        try self.connection.withLockedValue {\n            $0 = try HTTPServerConnection.start(\n                application: self.application,\n                responder: self.responder,\n                configuration: configuration,\n                on: self.eventLoopGroup\n            ).wait()\n        }\n\n        self.configuration = configuration\n        self.didStart.withLockedValue { $0 = true }\n    }\n    \n    public func shutdown() {\n        guard let connection = self.connection.withLockedValue({ $0 }) else {\n            return\n        }\n        self.configuration.logger.debug(\"Requesting HTTP server shutdown\")\n        do {\n            try connection.close(timeout: self.configuration.shutdownTimeout).wait()\n        } catch {\n            self.configuration.logger.error(\"Could not stop HTTP server: \\(error)\")\n        }\n        self.configuration.logger.debug(\"HTTP server shutting down\")\n        self.didShutdown.withLockedValue { $0 = true }\n    }\n\n    public var localAddress: SocketAddress? {\n        return self.connection.withLockedValue({ $0 })?.channel.localAddress\n    }\n    \n    deinit {\n        let started = self.didStart.withLockedValue { $0 }\n        let shutdown = self.didShutdown.withLockedValue { $0 }\n        assert(!started || shutdown, \"HTTPServer did not shutdown before deinitializing\")\n    }\n}\n\nprivate final class HTTPServerConnection: Sendable {\n    let channel: Channel\n    let quiesce: ServerQuiescingHelper\n    \n    static func start(\n        application: Application,\n        responder: Responder,\n        configuration: HTTPServer.Configuration,\n        on eventLoopGroup: EventLoopGroup\n    ) -> EventLoopFuture<HTTPServerConnection> {\n        let quiesce = ServerQuiescingHelper(group: eventLoopGroup)\n        let bootstrap = ServerBootstrap(group: eventLoopGroup)\n            // Specify backlog and enable SO_REUSEADDR for the server itself\n            .serverChannelOption(ChannelOptions.backlog, value: Int32(configuration.backlog))\n            .serverChannelOption(ChannelOptions.socket(SocketOptionLevel(SOL_SOCKET), SO_REUSEADDR), value: configuration.reuseAddress ? SocketOptionValue(1) : SocketOptionValue(0))\n            \n            // Set handlers that are applied to the Server's channel\n            .serverChannelInitializer { channel in\n                channel.pipeline.addHandler(quiesce.makeServerChannelHandler(channel: channel))\n            }\n            \n            // Set the handlers that are applied to the accepted Channels\n            .childChannelInitializer { [unowned application] channel in\n                // add TLS handlers if configured\n                if var tlsConfiguration = configuration.tlsConfiguration {\n                    // prioritize http/2\n                    if configuration.supportVersions.contains(.two) {\n                        tlsConfiguration.applicationProtocols.append(\"h2\")\n                    }\n                    if configuration.supportVersions.contains(.one) {\n                        tlsConfiguration.applicationProtocols.append(\"http/1.1\")\n                    }\n                    let sslContext: NIOSSLContext\n                    let tlsHandler: NIOSSLServerHandler\n                    do {\n                        sslContext = try NIOSSLContext(configuration: tlsConfiguration)\n                        tlsHandler = NIOSSLServerHandler(context: sslContext, customVerifyCallback: configuration.customCertificateVerifyCallback)\n                    } catch {\n                        configuration.logger.error(\"Could not configure TLS: \\(error)\")\n                        return channel.close(mode: .all)\n                    }\n                    return channel.pipeline.addHandler(tlsHandler).flatMap { _ in\n                        channel.configureHTTP2SecureUpgrade(h2ChannelConfigurator: { channel in\n                            channel.configureHTTP2Pipeline(\n                                mode: .server,\n                                inboundStreamInitializer: { channel in\n                                    return channel.pipeline.addVaporHTTP2Handlers(\n                                        application: application,\n                                        responder: responder,\n                                        configuration: configuration\n                                    )\n                                }\n                            ).map { _ in }\n                        }, http1ChannelConfigurator: { channel in\n                            return channel.pipeline.addVaporHTTP1Handlers(\n                                application: application,\n                                responder: responder,\n                                configuration: configuration\n                            )\n                        })\n                    }\n                } else {\n                    guard !configuration.supportVersions.contains(.two) else {\n                        fatalError(\"Plaintext HTTP/2 (h2c) not yet supported.\")\n                    }\n                    return channel.pipeline.addVaporHTTP1Handlers(\n                        application: application,\n                        responder: responder,\n                        configuration: configuration\n                    )\n                }\n            }\n            \n            // Enable TCP_NODELAY and SO_REUSEADDR for the accepted Channels\n            .childChannelOption(ChannelOptions.socket(IPPROTO_TCP, TCP_NODELAY), value: configuration.tcpNoDelay ? SocketOptionValue(1) : SocketOptionValue(0))\n            .childChannelOption(ChannelOptions.socket(SocketOptionLevel(SOL_SOCKET), SO_REUSEADDR), value: configuration.reuseAddress ? SocketOptionValue(1) : SocketOptionValue(0))\n            .childChannelOption(ChannelOptions.maxMessagesPerRead, value: 1)\n        \n        let channel: EventLoopFuture<Channel>\n        switch configuration.address {\n        case .hostname:\n            channel = bootstrap.bind(host: configuration.hostname, port: configuration.port)\n        case .unixDomainSocket(let socketPath):\n            channel = bootstrap.bind(unixDomainSocketPath: socketPath)\n        }\n        \n        return channel.map { channel in\n            return .init(channel: channel, quiesce: quiesce)\n        }.flatMapErrorThrowing { error -> HTTPServerConnection in\n            quiesce.initiateShutdown(promise: nil)\n            throw error\n        }\n    }\n    \n    init(channel: Channel, quiesce: ServerQuiescingHelper) {\n        self.channel = channel\n        self.quiesce = quiesce\n    }\n    \n    func close(timeout: TimeAmount) -> EventLoopFuture<Void> {\n        let promise = self.channel.eventLoop.makePromise(of: Void.self)\n        self.channel.eventLoop.scheduleTask(in: timeout) {\n            promise.fail(Abort(.internalServerError, reason: \"Server stop took too long.\"))\n        }\n        self.quiesce.initiateShutdown(promise: promise)\n        return promise.futureResult\n    }\n    \n    var onClose: EventLoopFuture<Void> {\n        self.channel.closeFuture\n    }\n    \n    deinit {\n        assert(!self.channel.isActive, \"HTTPServerConnection deinitialized without calling shutdown()\")\n    }\n}\n\n/// A simple channel handler that catches errors emitted by parsing HTTP requests\n/// and sends 400 Bad Request responses.\n///\n/// This channel handler provides the basic behaviour that the majority of simple HTTP\n/// servers want. This handler does not suppress the parser errors: it allows them to\n/// continue to pass through the pipeline so that other handlers (e.g. logging ones) can\n/// deal with the error.\n/// \n/// adapted from: https://github.com/apple/swift-nio/blob/00341c92770e0a7bebdc5fda783f08765eb3ff56/Sources/NIOHTTP1/HTTPServerProtocolErrorHandler.swift\nfinal class HTTP1ServerErrorHandler: ChannelDuplexHandler, RemovableChannelHandler {\n    typealias InboundIn = Never\n    typealias InboundOut = Never\n    typealias OutboundIn = HTTPServerResponsePart\n    typealias OutboundOut = HTTPServerResponsePart\n    let logger: Logger\n    private var hasUnterminatedResponse: Bool = false\n    \n    init(logger: Logger) {\n        self.logger = logger\n    }\n    \n    func errorCaught(context: ChannelHandlerContext, error: Error) {\n        if let error = error as? HTTPParserError {\n            self.makeHTTPParserErrorResponse(context: context, error: error)\n        }\n\n        // Now pass the error on in case someone else wants to see it.\n        // In the Vapor ChannelPipeline the connection will eventually \n        // be closed by the NIOCloseOnErrorHandler\n        context.fireErrorCaught(error)\n    }\n\n    private func makeHTTPParserErrorResponse(context: ChannelHandlerContext, error: HTTPParserError) {\n        // Any HTTPParserError is automatically fatal, and we don't actually need (or want) to\n        // provide that error to the client: we just want to inform them something went wrong\n        // and then close off the pipeline. However, we can only send an\n        // HTTP error response if another response hasn't started yet.\n        //\n        // A side note here: we cannot block or do any delayed work. \n        // The channel might be closed right after we return from this function.\n        if !self.hasUnterminatedResponse {\n            self.logger.debug(\"Bad Request - Invalid HTTP: \\(error)\")\n            let headers = HTTPHeaders([(\"Connection\", \"close\"), (\"Content-Length\", \"0\")])\n            let head = HTTPResponseHead(version: .http1_1, status: .badRequest, headers: headers)\n            context.write(self.wrapOutboundOut(.head(head)), promise: nil)\n            context.writeAndFlush(self.wrapOutboundOut(.end(nil)), promise: nil)\n        }\n    }\n\n    public func write(context: ChannelHandlerContext, data: NIOAny, promise: EventLoopPromise<Void>?) {\n        let res = self.unwrapOutboundIn(data)\n        switch res {\n        case .head(let head) where head.isInformational:\n            precondition(!self.hasUnterminatedResponse)\n        case .head:\n            precondition(!self.hasUnterminatedResponse)\n            self.hasUnterminatedResponse = true\n        case .body:\n            precondition(self.hasUnterminatedResponse)\n        case .end:\n            precondition(self.hasUnterminatedResponse)\n            self.hasUnterminatedResponse = false\n        }\n        context.write(data, promise: promise)\n    }\n}\n\nextension HTTPResponseHead {\n    /// Determines if the head is purely informational. If a head is informational another head will follow this\n    /// head eventually.\n    /// \n    /// This is also from SwiftNIO\n    var isInformational: Bool {\n        100 <= self.status.code && self.status.code < 200 && self.status.code != 101\n    }\n}\n\nextension ChannelPipeline {\n    func addVaporHTTP2Handlers(\n        application: Application,\n        responder: Responder,\n        configuration: HTTPServer.Configuration\n    ) -> EventLoopFuture<Void> {\n        // create server pipeline array\n        var handlers: [ChannelHandler] = []\n        \n        let http2 = HTTP2FramePayloadToHTTP1ServerCodec()\n        handlers.append(http2)\n        \n        // add NIO -> HTTP request decoder\n        let serverReqDecoder = HTTPServerRequestDecoder(\n            application: application\n        )\n        handlers.append(serverReqDecoder)\n        \n        // add NIO -> HTTP response encoder\n        let serverResEncoder = HTTPServerResponseEncoder(\n            serverHeader: configuration.serverName,\n            dateCache: .eventLoop(self.eventLoop)\n        )\n        handlers.append(serverResEncoder)\n        \n        // add server request -> response delegate\n        let handler = HTTPServerHandler(responder: responder, logger: application.logger)\n        handlers.append(handler)\n        \n        return self.addHandlers(handlers).flatMap {\n            // close the connection in case of any errors\n            self.addHandler(NIOCloseOnErrorHandler())\n        }\n    }\n    \n    func addVaporHTTP1Handlers(\n        application: Application,\n        responder: Responder,\n        configuration: HTTPServer.Configuration\n    ) -> EventLoopFuture<Void> {\n        // create server pipeline array\n        var handlers: [RemovableChannelHandler] = []\n        \n        // configure HTTP/1\n        // add http parsing and serializing\n        let httpResEncoder = HTTPResponseEncoder()\n        let httpReqDecoder = ByteToMessageHandler(HTTPRequestDecoder(\n            leftOverBytesStrategy: .forwardBytes\n        ))\n        handlers += [httpResEncoder, httpReqDecoder]\n        \n        // add pipelining support if configured\n        if configuration.supportPipelining {\n            let pipelineHandler = HTTPServerPipelineHandler()\n            handlers.append(pipelineHandler)\n        }\n        \n        // add response compressor if configured\n        switch configuration.responseCompression.storage {\n        case .enabled(let initialByteBufferCapacity):\n            let responseCompressionHandler = HTTPResponseCompressor(\n                initialByteBufferCapacity: initialByteBufferCapacity\n            )\n            handlers.append(responseCompressionHandler)\n        case .disabled:\n            break\n        }\n\n        // add request decompressor if configured\n        switch configuration.requestDecompression.storage {\n        case .enabled(let limit):\n            let requestDecompressionHandler = NIOHTTPRequestDecompressor(\n                limit: limit\n            )\n            handlers.append(requestDecompressionHandler)\n        case .disabled:\n            break\n        }\n\n        let errorHandler = HTTP1ServerErrorHandler(logger: configuration.logger)\n        handlers.append(errorHandler)\n\n        // add NIO -> HTTP response encoder\n        let serverResEncoder = HTTPServerResponseEncoder(\n            serverHeader: configuration.serverName,\n            dateCache: .eventLoop(self.eventLoop)\n        )\n        handlers.append(serverResEncoder)\n        \n        // add NIO -> HTTP request decoder\n        let serverReqDecoder = HTTPServerRequestDecoder(\n            application: application\n        )\n        handlers.append(serverReqDecoder)\n        // add server request -> response delegate\n        let handler = HTTPServerHandler(responder: responder, logger: application.logger)\n\n        // add HTTP upgrade handler\n        let upgrader = HTTPServerUpgradeHandler(\n            httpRequestDecoder: httpReqDecoder,\n            httpHandlers: handlers + [handler]\n        )\n\n        handlers.append(upgrader)\n        handlers.append(handler)\n        \n        return self.addHandlers(handlers).flatMap {\n            // close the connection in case of any errors\n            self.addHandler(NIOCloseOnErrorHandler())\n        }\n    }\n}\n\n// MARK: Helper function for constructing NIOSSLServerHandler.\nextension NIOSSLServerHandler {\n    convenience init(context: NIOSSLContext, customVerifyCallback: NIOSSLCustomVerificationCallback?) {\n        if let callback = customVerifyCallback {\n            self.init(context: context, customVerificationCallback: callback)\n        } else {\n            self.init(context: context)\n        }\n    }\n}\n", "import NIOCore\nimport Logging\n\nfinal class HTTPServerHandler: ChannelInboundHandler, RemovableChannelHandler {\n    typealias InboundIn = Request\n    typealias OutboundOut = Response\n    \n    let responder: Responder\n    let logger: Logger\n    var isShuttingDown: Bool\n    \n    init(responder: Responder, logger: Logger) {\n        self.responder = responder\n        self.logger = logger\n        self.isShuttingDown = false\n    }\n    \n    func channelRead(context: ChannelHandlerContext, data: NIOAny) {\n        let box = NIOLoopBound((context, self), eventLoop: context.eventLoop)\n        let request = self.unwrapInboundIn(data)\n        self.responder.respond(to: request).whenComplete { response in\n            let (context, handler) = box.value\n            handler.serialize(response, for: request, context: context)\n        }\n    }\n    \n    func serialize(_ response: Result<Response, Error>, for request: Request, context: ChannelHandlerContext) {\n        switch response {\n        case .failure(let error):\n            self.errorCaught(context: context, error: error)\n        case .success(let response):\n            if request.method == .HEAD {\n                response.forHeadRequest = true\n            }\n            self.serialize(response, for: request, context: context)\n        }\n    }\n    \n    func serialize(_ response: Response, for request: Request, context: ChannelHandlerContext) {\n        switch request.version.major {\n        case 2:\n            context.write(self.wrapOutboundOut(response), promise: nil)\n        default:\n            let keepAlive = !self.isShuttingDown && request.isKeepAlive\n            if self.isShuttingDown {\n                self.logger.debug(\"In-flight request has completed\")\n            }\n            response.headers.add(name: .connection, value: keepAlive ? \"keep-alive\" : \"close\")\n            let done = context.write(self.wrapOutboundOut(response))\n            let box = NIOLoopBound((context, self), eventLoop: context.eventLoop)\n            done.whenComplete { result in\n                let (context, handler) = box.value\n                switch result {\n                case .success:\n                    if !keepAlive {\n                        context.close(mode: .output, promise: nil)\n                    }\n                case .failure(let error):\n                    if case .stream(let stream) = response.body.storage {\n                        stream.callback(ErrorBodyStreamWriter(eventLoop: request.eventLoop, error: error))\n                    }\n                    handler.errorCaught(context: context, error: error)\n                }\n            }\n        }\n    }\n    \n    func userInboundEventTriggered(context: ChannelHandlerContext, event: Any) {\n        switch event {\n        case is ChannelShouldQuiesceEvent:\n            self.logger.trace(\"HTTP handler will no longer respect keep-alive\")\n            self.isShuttingDown = true\n        default:\n            self.logger.trace(\"Unhandled user event: \\(event)\")\n        }\n    }\n}\n\nstruct ErrorBodyStreamWriter: BodyStreamWriter {\n    var eventLoop: EventLoop\n    var error: Error\n    func write(_ result: BodyStreamResult, promise: EventLoopPromise<Void>?) {\n        promise?.fail(error)\n    }\n}\n", "import Logging\nimport NIOCore\nimport NIOHTTP1\nimport Foundation\n\nfinal class HTTPServerRequestDecoder: ChannelDuplexHandler, RemovableChannelHandler {\n    typealias InboundIn = HTTPServerRequestPart\n    typealias InboundOut = Request\n    typealias OutboundIn = Never\n\n    enum RequestState {\n        case ready\n        case awaitingBody(Request)\n        case awaitingEnd(Request, ByteBuffer)\n        case streamingBody(Request.BodyStream)\n        case skipping\n    }\n\n    var requestState: RequestState\n    var bodyStreamState: HTTPBodyStreamState\n\n    var logger: Logger {\n        self.application.logger\n    }\n    var application: Application\n    \n    init(application: Application) {\n        self.application = application\n        self.requestState = .ready\n        self.bodyStreamState = .init()\n    }\n    \n    func channelRead(context: ChannelHandlerContext, data: NIOAny) {\n        assert(context.channel.eventLoop.inEventLoop)\n        let part = self.unwrapInboundIn(data)\n        self.logger.trace(\"Decoded HTTP part: \\(part)\")\n        switch part {\n        case .head(let head):\n            switch self.requestState {\n            case .ready:\n                let request = Request(\n                    application: self.application,\n                    method: head.method,\n                    url: .init(string: head.uri),\n                    version: head.version,\n                    headersNoUpdate: head.headers,\n                    remoteAddress: context.channel.remoteAddress,\n                    logger: self.application.logger,\n                    byteBufferAllocator: context.channel.allocator,\n                    on: context.channel.eventLoop\n                )\n                switch head.version.major {\n                case 2:\n                    request.isKeepAlive = true\n                default:\n                    request.isKeepAlive = head.isKeepAlive\n                }\n                self.requestState = .awaitingBody(request)\n            default: assertionFailure(\"Unexpected state: \\(self.requestState)\")\n            }\n        case .body(let buffer):\n            switch self.requestState {\n            case .ready, .awaitingEnd:\n                assertionFailure(\"Unexpected state: \\(self.requestState)\")\n            case .awaitingBody(let request):\n                // We cannot assume that a request's content-length represents the length of all of the body\n                // because when a request is g-zipped, content-length refers to the gzipped length.\n                // Therefore, we can receive data after our expected end-of-request\n                // When decompressing data, more bytes come out than came in, so content-length does not represent the maximum length\n                if request.headers.first(name: .contentLength) == buffer.readableBytes.description {\n                    self.requestState = .awaitingEnd(request, buffer)\n                } else {\n                    let stream = Request.BodyStream(on: context.eventLoop, byteBufferAllocator: context.channel.allocator)\n                    request.bodyStorage = .stream(stream)\n                    self.requestState = .streamingBody(stream)\n                    context.fireChannelRead(self.wrapInboundOut(request))\n                    self.handleBodyStreamStateResult(\n                        context: context,\n                        self.bodyStreamState.didReadBytes(buffer),\n                        stream: stream\n                    )\n                }\n            case .streamingBody(let stream):\n                self.handleBodyStreamStateResult(\n                    context: context,\n                    self.bodyStreamState.didReadBytes(buffer),\n                    stream: stream\n                )\n            case .skipping: break\n            }\n        case .end(let tailHeaders):\n            assert(tailHeaders == nil, \"Tail headers are not supported.\")\n            switch self.requestState {\n            case .ready: assertionFailure(\"Unexpected state: \\(self.requestState)\")\n            case .awaitingBody(let request):\n                context.fireChannelRead(self.wrapInboundOut(request))\n            case .awaitingEnd(let request, let buffer):\n                request.bodyStorage = .collected(buffer)\n                context.fireChannelRead(self.wrapInboundOut(request))\n            case .streamingBody(let stream):\n                self.handleBodyStreamStateResult(\n                    context: context,\n                    self.bodyStreamState.didEnd(),\n                    stream: stream\n                )\n            case .skipping: break\n            }\n            self.requestState = .ready\n        }\n    }\n\n    func read(context: ChannelHandlerContext) {\n        switch self.requestState {\n        case .streamingBody(let stream):\n            self.handleBodyStreamStateResult(\n                context: context,\n                self.bodyStreamState.didReceiveReadRequest(),\n                stream: stream\n            )\n        default:\n            context.read()\n        }\n    }\n\n    func errorCaught(context: ChannelHandlerContext, error: Error) {\n        switch self.requestState {\n        case .streamingBody(let stream):\n            self.handleBodyStreamStateResult(\n                context: context,\n                self.bodyStreamState.didError(error),\n                stream: stream\n            )\n        default:\n            break\n        }\n        context.fireErrorCaught(error)\n    }\n\n    func channelInactive(context: ChannelHandlerContext) {\n        switch self.requestState {\n        case .streamingBody(let stream):\n            self.handleBodyStreamStateResult(\n                context: context,\n                self.bodyStreamState.didEnd(),\n                stream: stream\n            )\n        default:\n            break\n        }\n        context.fireChannelInactive()\n    }\n\n    func handleBodyStreamStateResult(\n        context: ChannelHandlerContext,\n        _ result: HTTPBodyStreamState.Result,\n        stream: Request.BodyStream\n    ) {\n        switch result.action {\n        case .nothing: break\n        case .write(let buffer):\n            let box = NIOLoopBound((context, self), eventLoop: context.eventLoop)\n            stream.write(.buffer(buffer)).whenComplete { writeResult in\n                let (context, handler) = box.value\n                switch writeResult {\n                case .failure(let error):\n                    handler.handleBodyStreamStateResult(\n                        context: context,\n                        handler.bodyStreamState.didError(error),\n                        stream: stream\n                    )\n                case .success: break\n                }\n                handler.handleBodyStreamStateResult(\n                    context: context,\n                    handler.bodyStreamState.didWrite(),\n                    stream: stream\n                )\n            }\n        case .close(let maybeError):\n            if let error = maybeError {\n                stream.write(.error(error), promise: nil)\n            } else {\n                stream.write(.end, promise: nil)\n            }\n        }\n        if result.callRead {\n            context.read()\n        }\n    }\n\n    func userInboundEventTriggered(context: ChannelHandlerContext, event: Any) {\n        switch event {\n        case is HTTPServerResponseEncoder.ResponseEndSentEvent:\n            switch self.requestState {\n            case .streamingBody(let bodyStream):\n                // Response ended during request stream.\n                if !bodyStream.isBeingRead {\n                    self.logger.trace(\"Response already sent, draining unhandled request stream.\")\n                    bodyStream.read { _, promise in\n                        promise?.succeed(())\n                    }\n                }\n            case .awaitingBody, .awaitingEnd:\n                // Response ended before request started streaming.\n                self.logger.trace(\"Response already sent, skipping request body.\")\n                self.requestState = .skipping\n            case .ready, .skipping:\n                // Response ended after request had been read.\n                break\n            }\n        case is ChannelShouldQuiesceEvent:\n            switch self.requestState {\n            case .ready:\n                self.logger.trace(\"Closing keep-alive HTTP connection since server is going away\")\n                context.channel.close(mode: .all, promise: nil)\n            default:\n                self.logger.debug(\"A request is currently in-flight\")\n                context.fireUserInboundEventTriggered(event)\n            }\n        default:\n            self.logger.trace(\"Unhandled user event: \\(event)\")\n        }\n    }\n}\n\nextension HTTPPart: CustomStringConvertible {\n    public var description: String {\n        switch self {\n        case .head(let head):\n            return \"head: \\(head)\"\n        case .body(let body):\n            return \"body: \\(body)\"\n        case .end(let headers):\n            if let headers = headers {\n                return \"end: \\(headers)\"\n            } else {\n                return \"end\"\n            }\n        }\n    }\n}\n\nstruct HTTPBodyStreamState: CustomStringConvertible {\n    struct Result {\n        enum Action {\n            case nothing\n            case write(ByteBuffer)\n            case close(Error?)\n        }\n        let action: Action\n        let callRead: Bool\n    }\n\n    private struct BufferState {\n        var bufferedWrites: CircularBuffer<ByteBuffer>\n        var heldUpRead: Bool\n        var hasClosed: Bool\n\n        mutating func append(_ buffer: ByteBuffer) {\n            self.bufferedWrites.append(buffer)\n        }\n\n        var isEmpty: Bool {\n            return self.bufferedWrites.isEmpty\n        }\n\n        mutating func removeFirst() -> ByteBuffer {\n            return self.bufferedWrites.removeFirst()\n        }\n    }\n\n    private enum State {\n        case idle\n        case writing(BufferState)\n        case error(Error)\n    }\n\n    private var state: State\n\n    var description: String {\n        \"\\(self.state)\"\n    }\n\n    init() {\n        self.state = .idle\n    }\n\n    mutating func didReadBytes(_ buffer: ByteBuffer) -> Result {\n        switch self.state {\n        case .idle:\n            self.state = .writing(.init(\n                bufferedWrites: .init(),\n                heldUpRead: false,\n                hasClosed: false\n            ))\n            return .init(action: .write(buffer), callRead: false)\n        case .writing(var buffers):\n            buffers.append(buffer)\n            self.state = .writing(buffers)\n            return .init(action: .nothing, callRead: false)\n        case .error:\n            return .init(action: .nothing, callRead: false)\n        }\n    }\n\n    mutating func didReceiveReadRequest() -> Result {\n        switch self.state {\n        case .idle:\n            return .init(action: .nothing, callRead: true)\n        case .writing(var buffers):\n            buffers.heldUpRead = true\n            self.state = .writing(buffers)\n            return .init(action: .nothing, callRead: false)\n        case .error:\n            return .init(action: .nothing, callRead: false)\n        }\n    }\n\n    mutating func didEnd() -> Result {\n        switch self.state {\n        case .idle:\n            return .init(action: .close(nil), callRead: false)\n        case .writing(var buffers):\n            buffers.hasClosed = true\n            self.state = .writing(buffers)\n            return .init(action: .nothing, callRead: false)\n        case .error:\n            return .init(action: .nothing, callRead: false)\n        }\n    }\n\n    mutating func didError(_ error: Error) -> Result {\n        switch self.state {\n        case .idle:\n            self.state = .error(error)\n            return .init(action: .close(error), callRead: false)\n        case .writing:\n            self.state = .error(error)\n            return .init(action: .nothing, callRead: false)\n        case .error:\n            return .init(action: .nothing, callRead: false)\n        }\n    }\n\n    mutating func didWrite() -> Result {\n        switch self.state {\n        case .idle:\n            self.illegalTransition()\n        case .writing(var buffers):\n            if buffers.isEmpty {\n                self.state = .idle\n                return .init(\n                    action: buffers.hasClosed ? .close(nil) : .nothing,\n                    callRead: buffers.heldUpRead\n                )\n            } else {\n                let first = buffers.removeFirst()\n                self.state = .writing(buffers)\n                return .init(action: .write(first), callRead: false)\n            }\n        case .error(let error):\n            return .init(action: .close(error), callRead: false)\n        }\n    }\n\n    private func illegalTransition(_ function: String = #function) -> Never {\n        preconditionFailure(\"illegal transition \\(function) in \\(self)\")\n    }\n}\n", "@testable import Vapor\nimport enum NIOHTTP1.HTTPParserError\nimport XCTest\nimport NIOEmbedded\nimport NIOCore\n\nfinal class PipelineTests: XCTestCase {\n    func testEchoHandlers() throws {\n        let app = Application(.testing)\n        defer { app.shutdown() }\n\n        app.on(.POST, \"echo\", body: .stream) { request -> Response in\n            Response(body: .init(stream: { writer in\n                request.body.drain { body in\n                    switch body {\n                    case .buffer(let buffer):\n                        return writer.write(.buffer(buffer))\n                    case .error(let error):\n                        return writer.write(.error(error))\n                    case .end:\n                        return writer.write(.end)\n                    }\n                }\n            }))\n        }\n\n        let channel = EmbeddedChannel()\n        try channel.pipeline.addVaporHTTP1Handlers(\n            application: app,\n            responder: app.responder,\n            configuration: app.http.server.configuration\n        ).wait()\n\n        try channel.writeInbound(ByteBuffer(string: \"POST /echo HTTP/1.1\\r\\ntransfer-encoding: chunked\\r\\n\\r\\n1\\r\\na\\r\\n\"))\n        let chunk = try channel.readOutbound(as: ByteBuffer.self)?.string\n        XCTAssertContains(chunk, \"HTTP/1.1 200 OK\")\n        XCTAssertContains(chunk, \"connection: keep-alive\")\n        XCTAssertContains(chunk, \"transfer-encoding: chunked\")\n        try XCTAssertEqual(channel.readOutbound(as: ByteBuffer.self)?.string, \"1\\r\\n\")\n        try XCTAssertEqual(channel.readOutbound(as: ByteBuffer.self)?.string, \"a\")\n        try XCTAssertEqual(channel.readOutbound(as: ByteBuffer.self)?.string, \"\\r\\n\")\n        try XCTAssertNil(channel.readOutbound(as: ByteBuffer.self)?.string)\n\n        try channel.writeInbound(ByteBuffer(string: \"1\\r\\nb\\r\\n\"))\n        try XCTAssertEqual(channel.readOutbound(as: ByteBuffer.self)?.string, \"1\\r\\n\")\n        try XCTAssertEqual(channel.readOutbound(as: ByteBuffer.self)?.string, \"b\")\n        try XCTAssertEqual(channel.readOutbound(as: ByteBuffer.self)?.string, \"\\r\\n\")\n        try XCTAssertNil(channel.readOutbound(as: ByteBuffer.self)?.string)\n\n        try channel.writeInbound(ByteBuffer(string: \"1\\r\\nc\\r\\n\"))\n        try XCTAssertEqual(channel.readOutbound(as: ByteBuffer.self)?.string, \"1\\r\\n\")\n        try XCTAssertEqual(channel.readOutbound(as: ByteBuffer.self)?.string, \"c\")\n        try XCTAssertEqual(channel.readOutbound(as: ByteBuffer.self)?.string, \"\\r\\n\")\n        try XCTAssertNil(channel.readOutbound(as: ByteBuffer.self)?.string)\n\n        try channel.writeInbound(ByteBuffer(string: \"0\\r\\n\\r\\n\"))\n        try XCTAssertEqual(channel.readOutbound(as: ByteBuffer.self)?.string, \"0\\r\\n\\r\\n\")\n        try XCTAssertNil(channel.readOutbound(as: ByteBuffer.self)?.string)\n    }\n\n    func testEOFFraming() throws {\n        let app = Application(.testing)\n        defer { app.shutdown() }\n\n        app.on(.POST, \"echo\", body: .stream) { request -> Response in\n            Response(body: .init(stream: { writer in\n                request.body.drain { body in\n                    switch body {\n                    case .buffer(let buffer):\n                        return writer.write(.buffer(buffer))\n                    case .error(let error):\n                        return writer.write(.error(error))\n                    case .end:\n                        return writer.write(.end)\n                    }\n                }\n            }))\n        }\n\n        let channel = EmbeddedChannel()\n        try channel.pipeline.addVaporHTTP1Handlers(\n            application: app,\n            responder: app.responder,\n            configuration: app.http.server.configuration\n        ).wait()\n\n        try channel.writeInbound(ByteBuffer(string: \"POST /echo HTTP/1.1\\r\\n\\r\\n\"))\n        try XCTAssertContains(channel.readOutbound(as: ByteBuffer.self)?.string, \"HTTP/1.1 200 OK\")\n    }\n\n    func testBadStreamLength() throws {\n        let app = Application(.testing)\n        defer { app.shutdown() }\n\n        app.on(.POST, \"echo\", body: .stream) { request -> Response in\n            Response(body: .init(stream: { writer in\n                writer.write(.buffer(.init(string: \"a\")), promise: nil)\n                writer.write(.end, promise: nil)\n            }, count: 2))\n        }\n\n        let channel = EmbeddedChannel()\n        try channel.connect(to: .init(unixDomainSocketPath: \"/foo\")).wait()\n        try channel.pipeline.addVaporHTTP1Handlers(\n            application: app,\n            responder: app.responder,\n            configuration: app.http.server.configuration\n        ).wait()\n\n        XCTAssertEqual(channel.isActive, true)\n        // throws a notEnoughBytes error which is good\n        XCTAssertThrowsError(try channel.writeInbound(ByteBuffer(string: \"POST /echo HTTP/1.1\\r\\n\\r\\n\")))\n        XCTAssertEqual(channel.isActive, false)\n        try XCTAssertContains(channel.readOutbound(as: ByteBuffer.self)?.string, \"HTTP/1.1 200 OK\")\n        try XCTAssertEqual(channel.readOutbound(as: ByteBuffer.self)?.string, \"a\")\n        try XCTAssertNil(channel.readOutbound(as: ByteBuffer.self)?.string)\n    }\n    \n    func testInvalidHttp() throws {\n        let app = Application(.testing)\n        defer { app.shutdown() }\n\n        let channel = EmbeddedChannel()\n        try channel.connect(to: .init(unixDomainSocketPath: \"/foo\")).wait()\n        try channel.pipeline.addVaporHTTP1Handlers(\n            application: app,\n            responder: app.responder,\n            configuration: app.http.server.configuration\n        ).wait()\n\n        XCTAssertEqual(channel.isActive, true)\n        let request = ByteBuffer(string: \"POST /echo/\u00fe HTTP/1.1\\r\\n\\r\\n\")\n        XCTAssertThrowsError(try channel.writeInbound(request)) { error in\n            if let error = error as? HTTPParserError {\n                XCTAssertEqual(error, HTTPParserError.invalidURL)\n            } else {\n                XCTFail(\"Caught error \\\"\\(error)\\\"\")\n            }\n        }\n        XCTAssertEqual(channel.isActive, false)\n        try XCTAssertContains(channel.readOutbound(as: ByteBuffer.self)?.string, \"HTTP/1.1 400 Bad Request\")\n        try XCTAssertNil(channel.readOutbound(as: ByteBuffer.self)?.string)\n    }\n\n    override class func setUp() {\n        XCTAssert(isLoggingConfigured)\n    }\n}\n"], "fixing_code": ["import NIOCore\nimport NIOExtras\nimport NIOHTTP1\nimport NIOHTTP2\nimport NIOHTTPCompression\nimport NIOSSL\nimport Logging\nimport NIOPosix\nimport NIOConcurrencyHelpers\n\npublic enum HTTPVersionMajor: Equatable, Hashable, Sendable {\n    case one\n    case two\n}\n\npublic final class HTTPServer: Server, Sendable {\n    /// Engine server config struct.\n    ///\n    ///     let serverConfig = HTTPServerConfig.default(port: 8123)\n    ///     services.register(serverConfig)\n    ///\n    public struct Configuration: Sendable {\n        public static let defaultHostname = \"127.0.0.1\"\n        public static let defaultPort = 8080\n        \n        /// Address the server will bind to. Configuring an address using a hostname with a nil host or port will use the default hostname or port respectively.\n        public var address: BindAddress\n        \n        /// Host name the server will bind to.\n        public var hostname: String {\n            get {\n                switch address {\n                case .hostname(let hostname, _):\n                    return hostname ?? Self.defaultHostname\n                default:\n                    return Self.defaultHostname\n                }\n            }\n            set {\n                switch address {\n                case .hostname(_, let port):\n                    address = .hostname(newValue, port: port)\n                default:\n                    address = .hostname(newValue, port: nil)\n                }\n            }\n        }\n        \n        /// Port the server will bind to.\n        public var port: Int {\n           get {\n               switch address {\n               case .hostname(_, let port):\n                   return port ?? Self.defaultPort\n               default:\n                   return Self.defaultPort\n               }\n           }\n           set {\n               switch address {\n               case .hostname(let hostname, _):\n                   address = .hostname(hostname, port: newValue)\n               default:\n                   address = .hostname(nil, port: newValue)\n               }\n           }\n       }\n        \n        /// Listen backlog.\n        public var backlog: Int\n        \n        /// When `true`, can prevent errors re-binding to a socket after successive server restarts.\n        public var reuseAddress: Bool\n        \n        /// When `true`, OS will attempt to minimize TCP packet delay.\n        public var tcpNoDelay: Bool\n\n        /// Response compression configuration.\n        public var responseCompression: CompressionConfiguration\n\n        /// Supported HTTP compression options.\n        public struct CompressionConfiguration: Sendable {\n            /// Disables compression. This is the default.\n            public static var disabled: Self {\n                .init(storage: .disabled)\n            }\n\n            /// Enables compression with default configuration.\n            public static var enabled: Self {\n                .enabled(initialByteBufferCapacity: 1024)\n            }\n\n            /// Enables compression with custom configuration.\n            public static func enabled(\n                initialByteBufferCapacity: Int\n            ) -> Self {\n                .init(storage: .enabled(\n                    initialByteBufferCapacity: initialByteBufferCapacity\n                ))\n            }\n\n            enum Storage {\n                case disabled\n                case enabled(initialByteBufferCapacity: Int)\n            }\n\n            var storage: Storage\n        }\n\n        /// Request decompression configuration.\n        public var requestDecompression: DecompressionConfiguration\n\n        /// Supported HTTP decompression options.\n        public struct DecompressionConfiguration: Sendable {\n            /// Disables decompression. This is the default option.\n            public static var disabled: Self {\n                .init(storage: .disabled)\n            }\n\n            /// Enables decompression with default configuration.\n            public static var enabled: Self {\n                .enabled(limit: .ratio(10))\n            }\n\n            /// Enables decompression with custom configuration.\n            public static func enabled(\n                limit: NIOHTTPDecompression.DecompressionLimit\n            ) -> Self {\n                .init(storage: .enabled(limit: limit))\n            }\n\n            enum Storage {\n                case disabled\n                case enabled(limit: NIOHTTPDecompression.DecompressionLimit)\n            }\n\n            var storage: Storage\n        }\n        \n        /// When `true`, HTTP server will support pipelined requests.\n        public var supportPipelining: Bool\n        \n        public var supportVersions: Set<HTTPVersionMajor>\n        \n        public var tlsConfiguration: TLSConfiguration?\n        \n        /// If set, this name will be serialized as the `Server` header in outgoing responses.\n        public var serverName: String?\n\n        /// When `true`, report http metrics through `swift-metrics`\n        public var reportMetrics: Bool\n\n        /// Any uncaught server or responder errors will go here.\n        public var logger: Logger\n\n        /// A time limit to complete a graceful shutdown\n        public var shutdownTimeout: TimeAmount\n\n        /// An optional callback that will be called instead of using swift-nio-ssl's regular certificate verification logic.\n        /// This is the same as `NIOSSLCustomVerificationCallback` but just marked as `Sendable`\n        @preconcurrency\n        public var customCertificateVerifyCallback: (@Sendable ([NIOSSLCertificate], EventLoopPromise<NIOSSLVerificationResult>) -> Void)?\n\n        public init(\n            hostname: String = Self.defaultHostname,\n            port: Int = Self.defaultPort,\n            backlog: Int = 256,\n            reuseAddress: Bool = true,\n            tcpNoDelay: Bool = true,\n            responseCompression: CompressionConfiguration = .disabled,\n            requestDecompression: DecompressionConfiguration = .disabled,\n            supportPipelining: Bool = true,\n            supportVersions: Set<HTTPVersionMajor>? = nil,\n            tlsConfiguration: TLSConfiguration? = nil,\n            serverName: String? = nil,\n            reportMetrics: Bool = true,\n            logger: Logger? = nil,\n            shutdownTimeout: TimeAmount = .seconds(10)\n        ) {\n            self.init(\n                address: .hostname(hostname, port: port),\n                backlog: backlog,\n                reuseAddress: reuseAddress,\n                tcpNoDelay: tcpNoDelay,\n                responseCompression: responseCompression,\n                requestDecompression: requestDecompression,\n                supportPipelining: supportPipelining,\n                supportVersions: supportVersions,\n                tlsConfiguration: tlsConfiguration,\n                serverName: serverName,\n                reportMetrics: reportMetrics,\n                logger: logger,\n                shutdownTimeout: shutdownTimeout\n            )\n        }\n        \n        public init(\n            address: BindAddress,\n            backlog: Int = 256,\n            reuseAddress: Bool = true,\n            tcpNoDelay: Bool = true,\n            responseCompression: CompressionConfiguration = .disabled,\n            requestDecompression: DecompressionConfiguration = .disabled,\n            supportPipelining: Bool = true,\n            supportVersions: Set<HTTPVersionMajor>? = nil,\n            tlsConfiguration: TLSConfiguration? = nil,\n            serverName: String? = nil,\n            reportMetrics: Bool = true,\n            logger: Logger? = nil,\n            shutdownTimeout: TimeAmount = .seconds(10)\n        ) {\n            self.address = address\n            self.backlog = backlog\n            self.reuseAddress = reuseAddress\n            self.tcpNoDelay = tcpNoDelay\n            self.responseCompression = responseCompression\n            self.requestDecompression = requestDecompression\n            self.supportPipelining = supportPipelining\n            if let supportVersions = supportVersions {\n                self.supportVersions = supportVersions\n            } else {\n                self.supportVersions = tlsConfiguration == nil ? [.one] : [.one, .two]\n            }\n            self.tlsConfiguration = tlsConfiguration\n            self.serverName = serverName\n            self.reportMetrics = reportMetrics\n            self.logger = logger ?? Logger(label: \"codes.vapor.http-server\")\n            self.shutdownTimeout = shutdownTimeout\n            self.customCertificateVerifyCallback = nil\n        }\n    }\n    \n    public var onShutdown: EventLoopFuture<Void> {\n        guard let connection = self.connection.withLockedValue({ $0 }) else {\n            fatalError(\"Server has not started yet\")\n        }\n        return connection.channel.closeFuture\n    }\n\n    public var configuration: Configuration {\n        get { _configuration.withLockedValue { $0 } }\n        set {\n            guard !didStart.withLockedValue({ $0 }) else {\n                _configuration.withLockedValue({ $0 }).logger.warning(\"Cannot modify server configuration after server has been started.\")\n                return\n            }\n            self.application.storage[Application.HTTP.Server.ConfigurationKey.self] = newValue\n            _configuration.withLockedValue { $0 = newValue }\n        }\n    }\n\n    private let responder: Responder\n    private let _configuration: NIOLockedValueBox<Configuration>\n    private let eventLoopGroup: EventLoopGroup\n    private let connection: NIOLockedValueBox<HTTPServerConnection?>\n    private let didShutdown: NIOLockedValueBox<Bool>\n    private let didStart: NIOLockedValueBox<Bool>\n    private let application: Application\n    \n    public init(\n        application: Application,\n        responder: Responder,\n        configuration: Configuration,\n        on eventLoopGroup: EventLoopGroup\n    ) {\n        self.application = application\n        self.responder = responder\n        self._configuration = .init(configuration)\n        self.eventLoopGroup = eventLoopGroup\n        self.didStart = .init(false)\n        self.didShutdown = .init(false)\n        self.connection = .init(nil)\n    }\n    \n    public func start(address: BindAddress?) throws {\n        var configuration = self.configuration\n        \n        switch address {\n        case .none: // use the configuration as is\n            break\n        case .hostname(let hostname, let port): // override the hostname, port, neither, or both\n            configuration.address = .hostname(hostname ?? configuration.hostname, port: port ?? configuration.port)\n        case .unixDomainSocket: // override the socket path\n            configuration.address = address!\n        }\n        \n        // print starting message\n        let scheme = configuration.tlsConfiguration == nil ? \"http\" : \"https\"\n        let addressDescription: String\n        switch configuration.address {\n        case .hostname(let hostname, let port):\n            addressDescription = \"\\(scheme)://\\(hostname ?? configuration.hostname):\\(port ?? configuration.port)\"\n        case .unixDomainSocket(let socketPath):\n            addressDescription = \"\\(scheme)+unix: \\(socketPath)\"\n        }\n        \n        self.configuration.logger.notice(\"Server starting on \\(addressDescription)\")\n\n        // start the actual HTTPServer\n        try self.connection.withLockedValue {\n            $0 = try HTTPServerConnection.start(\n                application: self.application,\n                responder: self.responder,\n                configuration: configuration,\n                on: self.eventLoopGroup\n            ).wait()\n        }\n\n        self.configuration = configuration\n        self.didStart.withLockedValue { $0 = true }\n    }\n    \n    public func shutdown() {\n        guard let connection = self.connection.withLockedValue({ $0 }) else {\n            return\n        }\n        self.configuration.logger.debug(\"Requesting HTTP server shutdown\")\n        do {\n            try connection.close(timeout: self.configuration.shutdownTimeout).wait()\n        } catch {\n            self.configuration.logger.error(\"Could not stop HTTP server: \\(error)\")\n        }\n        self.configuration.logger.debug(\"HTTP server shutting down\")\n        self.didShutdown.withLockedValue { $0 = true }\n    }\n\n    public var localAddress: SocketAddress? {\n        return self.connection.withLockedValue({ $0 })?.channel.localAddress\n    }\n    \n    deinit {\n        let started = self.didStart.withLockedValue { $0 }\n        let shutdown = self.didShutdown.withLockedValue { $0 }\n        assert(!started || shutdown, \"HTTPServer did not shutdown before deinitializing\")\n    }\n}\n\nprivate final class HTTPServerConnection: Sendable {\n    let channel: Channel\n    let quiesce: ServerQuiescingHelper\n    \n    static func start(\n        application: Application,\n        responder: Responder,\n        configuration: HTTPServer.Configuration,\n        on eventLoopGroup: EventLoopGroup\n    ) -> EventLoopFuture<HTTPServerConnection> {\n        let quiesce = ServerQuiescingHelper(group: eventLoopGroup)\n        let bootstrap = ServerBootstrap(group: eventLoopGroup)\n            // Specify backlog and enable SO_REUSEADDR for the server itself\n            .serverChannelOption(ChannelOptions.backlog, value: Int32(configuration.backlog))\n            .serverChannelOption(ChannelOptions.socket(SocketOptionLevel(SOL_SOCKET), SO_REUSEADDR), value: configuration.reuseAddress ? SocketOptionValue(1) : SocketOptionValue(0))\n            \n            // Set handlers that are applied to the Server's channel\n            .serverChannelInitializer { channel in\n                channel.pipeline.addHandler(quiesce.makeServerChannelHandler(channel: channel))\n            }\n            \n            // Set the handlers that are applied to the accepted Channels\n            .childChannelInitializer { [unowned application] channel in\n                // add TLS handlers if configured\n                if var tlsConfiguration = configuration.tlsConfiguration {\n                    // prioritize http/2\n                    if configuration.supportVersions.contains(.two) {\n                        tlsConfiguration.applicationProtocols.append(\"h2\")\n                    }\n                    if configuration.supportVersions.contains(.one) {\n                        tlsConfiguration.applicationProtocols.append(\"http/1.1\")\n                    }\n                    let sslContext: NIOSSLContext\n                    let tlsHandler: NIOSSLServerHandler\n                    do {\n                        sslContext = try NIOSSLContext(configuration: tlsConfiguration)\n                        tlsHandler = NIOSSLServerHandler(context: sslContext, customVerifyCallback: configuration.customCertificateVerifyCallback)\n                    } catch {\n                        configuration.logger.error(\"Could not configure TLS: \\(error)\")\n                        return channel.close(mode: .all)\n                    }\n                    return channel.pipeline.addHandler(tlsHandler).flatMap { _ in\n                        channel.configureHTTP2SecureUpgrade(h2ChannelConfigurator: { channel in\n                            channel.configureHTTP2Pipeline(\n                                mode: .server,\n                                inboundStreamInitializer: { channel in\n                                    return channel.pipeline.addVaporHTTP2Handlers(\n                                        application: application,\n                                        responder: responder,\n                                        configuration: configuration\n                                    )\n                                }\n                            ).map { _ in }\n                        }, http1ChannelConfigurator: { channel in\n                            return channel.pipeline.addVaporHTTP1Handlers(\n                                application: application,\n                                responder: responder,\n                                configuration: configuration\n                            )\n                        })\n                    }\n                } else {\n                    guard !configuration.supportVersions.contains(.two) else {\n                        fatalError(\"Plaintext HTTP/2 (h2c) not yet supported.\")\n                    }\n                    return channel.pipeline.addVaporHTTP1Handlers(\n                        application: application,\n                        responder: responder,\n                        configuration: configuration\n                    )\n                }\n            }\n            \n            // Enable TCP_NODELAY and SO_REUSEADDR for the accepted Channels\n            .childChannelOption(ChannelOptions.socket(IPPROTO_TCP, TCP_NODELAY), value: configuration.tcpNoDelay ? SocketOptionValue(1) : SocketOptionValue(0))\n            .childChannelOption(ChannelOptions.socket(SocketOptionLevel(SOL_SOCKET), SO_REUSEADDR), value: configuration.reuseAddress ? SocketOptionValue(1) : SocketOptionValue(0))\n            .childChannelOption(ChannelOptions.maxMessagesPerRead, value: 1)\n        \n        let channel: EventLoopFuture<Channel>\n        switch configuration.address {\n        case .hostname:\n            channel = bootstrap.bind(host: configuration.hostname, port: configuration.port)\n        case .unixDomainSocket(let socketPath):\n            channel = bootstrap.bind(unixDomainSocketPath: socketPath)\n        }\n        \n        return channel.map { channel in\n            return .init(channel: channel, quiesce: quiesce)\n        }.flatMapErrorThrowing { error -> HTTPServerConnection in\n            quiesce.initiateShutdown(promise: nil)\n            throw error\n        }\n    }\n    \n    init(channel: Channel, quiesce: ServerQuiescingHelper) {\n        self.channel = channel\n        self.quiesce = quiesce\n    }\n    \n    func close(timeout: TimeAmount) -> EventLoopFuture<Void> {\n        let promise = self.channel.eventLoop.makePromise(of: Void.self)\n        self.channel.eventLoop.scheduleTask(in: timeout) {\n            promise.fail(Abort(.internalServerError, reason: \"Server stop took too long.\"))\n        }\n        self.quiesce.initiateShutdown(promise: promise)\n        return promise.futureResult\n    }\n    \n    var onClose: EventLoopFuture<Void> {\n        self.channel.closeFuture\n    }\n    \n    deinit {\n        assert(!self.channel.isActive, \"HTTPServerConnection deinitialized without calling shutdown()\")\n    }\n}\n\nextension HTTPResponseHead {\n    /// Determines if the head is purely informational. If a head is informational another head will follow this\n    /// head eventually.\n    /// \n    /// This is also from SwiftNIO\n    var isInformational: Bool {\n        100 <= self.status.code && self.status.code < 200 && self.status.code != 101\n    }\n}\n\nextension ChannelPipeline {\n    func addVaporHTTP2Handlers(\n        application: Application,\n        responder: Responder,\n        configuration: HTTPServer.Configuration\n    ) -> EventLoopFuture<Void> {\n        // create server pipeline array\n        var handlers: [ChannelHandler] = []\n        \n        let http2 = HTTP2FramePayloadToHTTP1ServerCodec()\n        handlers.append(http2)\n        \n        // add NIO -> HTTP request decoder\n        let serverReqDecoder = HTTPServerRequestDecoder(\n            application: application\n        )\n        handlers.append(serverReqDecoder)\n        \n        // add NIO -> HTTP response encoder\n        let serverResEncoder = HTTPServerResponseEncoder(\n            serverHeader: configuration.serverName,\n            dateCache: .eventLoop(self.eventLoop)\n        )\n        handlers.append(serverResEncoder)\n        \n        // add server request -> response delegate\n        let handler = HTTPServerHandler(responder: responder, logger: application.logger)\n        handlers.append(handler)\n        \n        return self.addHandlers(handlers).flatMap {\n            // close the connection in case of any errors\n            self.addHandler(NIOCloseOnErrorHandler())\n        }\n    }\n    \n    func addVaporHTTP1Handlers(\n        application: Application,\n        responder: Responder,\n        configuration: HTTPServer.Configuration\n    ) -> EventLoopFuture<Void> {\n        // create server pipeline array\n        var handlers: [RemovableChannelHandler] = []\n        \n        // configure HTTP/1\n        // add http parsing and serializing\n        let httpResEncoder = HTTPResponseEncoder()\n        let httpReqDecoder = ByteToMessageHandler(HTTPRequestDecoder(\n            leftOverBytesStrategy: .forwardBytes\n        ))\n        handlers += [httpResEncoder, httpReqDecoder]\n        \n        // add pipelining support if configured\n        if configuration.supportPipelining {\n            let pipelineHandler = HTTPServerPipelineHandler()\n            handlers.append(pipelineHandler)\n        }\n        \n        // add response compressor if configured\n        switch configuration.responseCompression.storage {\n        case .enabled(let initialByteBufferCapacity):\n            let responseCompressionHandler = HTTPResponseCompressor(\n                initialByteBufferCapacity: initialByteBufferCapacity\n            )\n            handlers.append(responseCompressionHandler)\n        case .disabled:\n            break\n        }\n\n        // add request decompressor if configured\n        switch configuration.requestDecompression.storage {\n        case .enabled(let limit):\n            let requestDecompressionHandler = NIOHTTPRequestDecompressor(\n                limit: limit\n            )\n            handlers.append(requestDecompressionHandler)\n        case .disabled:\n            break\n        }\n\n        // add NIO -> HTTP response encoder\n        let serverResEncoder = HTTPServerResponseEncoder(\n            serverHeader: configuration.serverName,\n            dateCache: .eventLoop(self.eventLoop)\n        )\n        handlers.append(serverResEncoder)\n        \n        // add NIO -> HTTP request decoder\n        let serverReqDecoder = HTTPServerRequestDecoder(\n            application: application\n        )\n        handlers.append(serverReqDecoder)\n        // add server request -> response delegate\n        let handler = HTTPServerHandler(responder: responder, logger: application.logger)\n\n        // add HTTP upgrade handler\n        let upgrader = HTTPServerUpgradeHandler(\n            httpRequestDecoder: httpReqDecoder,\n            httpHandlers: handlers + [handler]\n        )\n\n        handlers.append(upgrader)\n        handlers.append(handler)\n        \n        return self.addHandlers(handlers).flatMap {\n            // close the connection in case of any errors\n            self.addHandler(NIOCloseOnErrorHandler())\n        }\n    }\n}\n\n// MARK: Helper function for constructing NIOSSLServerHandler.\nextension NIOSSLServerHandler {\n    convenience init(context: NIOSSLContext, customVerifyCallback: NIOSSLCustomVerificationCallback?) {\n        if let callback = customVerifyCallback {\n            self.init(context: context, customVerificationCallback: callback)\n        } else {\n            self.init(context: context)\n        }\n    }\n}\n", "import NIOCore\nimport Logging\n\nfinal class HTTPServerHandler: ChannelInboundHandler, RemovableChannelHandler {\n    typealias InboundIn = Request\n    typealias OutboundOut = Response\n    \n    let responder: Responder\n    let logger: Logger\n    var isShuttingDown: Bool\n    \n    init(responder: Responder, logger: Logger) {\n        self.responder = responder\n        self.logger = logger\n        self.isShuttingDown = false\n    }\n    \n    func channelRead(context: ChannelHandlerContext, data: NIOAny) {\n        let box = NIOLoopBound((context, self), eventLoop: context.eventLoop)\n        let request = self.unwrapInboundIn(data)\n        self.responder.respond(to: request).whenComplete { response in\n            let (context, handler) = box.value\n            handler.serialize(response, for: request, context: context)\n        }\n    }\n    \n    func serialize(_ response: Result<Response, Error>, for request: Request, context: ChannelHandlerContext) {\n        switch response {\n        case .failure(let error):\n            self.errorCaught(context: context, error: error)\n        case .success(let response):\n            if request.method == .HEAD {\n                response.forHeadRequest = true\n            }\n            self.serialize(response, for: request, context: context)\n        }\n    }\n    \n    func serialize(_ response: Response, for request: Request, context: ChannelHandlerContext) {\n        switch request.version.major {\n        case 2:\n            context.write(self.wrapOutboundOut(response), promise: nil)\n        default:\n            let keepAlive = !self.isShuttingDown && request.isKeepAlive\n            if self.isShuttingDown {\n                self.logger.debug(\"In-flight request has completed\")\n            }\n            response.headers.add(name: .connection, value: keepAlive ? \"keep-alive\" : \"close\")\n            let done = context.write(self.wrapOutboundOut(response))\n            let box = NIOLoopBound((context, self), eventLoop: context.eventLoop)\n            done.whenComplete { result in\n                let (context, handler) = box.value\n                switch result {\n                case .success:\n                    if !keepAlive {\n                        context.close(mode: .output, promise: nil)\n                    }\n                case .failure(let error):\n                    if case .stream(let stream) = response.body.storage {\n                        stream.callback(ErrorBodyStreamWriter(eventLoop: request.eventLoop, error: error))\n                    }\n                    handler.errorCaught(context: context, error: error)\n                }\n            }\n        }\n    }\n    \n    func userInboundEventTriggered(context: ChannelHandlerContext, event: Any) {\n        switch event {\n        case is ChannelShouldQuiesceEvent:\n            self.logger.trace(\"HTTP handler will no longer respect keep-alive\")\n            self.isShuttingDown = true\n        default:\n            context.fireUserInboundEventTriggered(event)\n        }\n    }\n}\n\nstruct ErrorBodyStreamWriter: BodyStreamWriter {\n    var eventLoop: EventLoop\n    var error: Error\n    func write(_ result: BodyStreamResult, promise: EventLoopPromise<Void>?) {\n        promise?.fail(error)\n    }\n}\n", "import Logging\nimport NIOCore\nimport NIOHTTP1\nimport Foundation\n\nfinal class HTTPServerRequestDecoder: ChannelDuplexHandler, RemovableChannelHandler {\n    typealias InboundIn = HTTPServerRequestPart\n    typealias InboundOut = Request\n    typealias OutboundIn = Never\n\n    enum RequestState {\n        case ready\n        case awaitingBody(Request)\n        case awaitingEnd(Request, ByteBuffer)\n        case streamingBody(Request.BodyStream)\n        case skipping\n    }\n\n    var requestState: RequestState\n    var bodyStreamState: HTTPBodyStreamState\n\n    var logger: Logger {\n        self.application.logger\n    }\n    var application: Application\n    \n    init(application: Application) {\n        self.application = application\n        self.requestState = .ready\n        self.bodyStreamState = .init()\n    }\n    \n    func channelRead(context: ChannelHandlerContext, data: NIOAny) {\n        assert(context.channel.eventLoop.inEventLoop)\n        let part = self.unwrapInboundIn(data)\n        self.logger.trace(\"Decoded HTTP part: \\(part)\")\n        switch part {\n        case .head(let head):\n            switch self.requestState {\n            case .ready:\n                let request = Request(\n                    application: self.application,\n                    method: head.method,\n                    url: .init(string: head.uri),\n                    version: head.version,\n                    headersNoUpdate: head.headers,\n                    remoteAddress: context.channel.remoteAddress,\n                    logger: self.application.logger,\n                    byteBufferAllocator: context.channel.allocator,\n                    on: context.channel.eventLoop\n                )\n                switch head.version.major {\n                case 2:\n                    request.isKeepAlive = true\n                default:\n                    request.isKeepAlive = head.isKeepAlive\n                }\n                self.requestState = .awaitingBody(request)\n            default: assertionFailure(\"Unexpected state: \\(self.requestState)\")\n            }\n        case .body(let buffer):\n            switch self.requestState {\n            case .ready, .awaitingEnd:\n                assertionFailure(\"Unexpected state: \\(self.requestState)\")\n            case .awaitingBody(let request):\n                // We cannot assume that a request's content-length represents the length of all of the body\n                // because when a request is g-zipped, content-length refers to the gzipped length.\n                // Therefore, we can receive data after our expected end-of-request\n                // When decompressing data, more bytes come out than came in, so content-length does not represent the maximum length\n                if request.headers.first(name: .contentLength) == buffer.readableBytes.description {\n                    self.requestState = .awaitingEnd(request, buffer)\n                } else {\n                    let stream = Request.BodyStream(on: context.eventLoop, byteBufferAllocator: context.channel.allocator)\n                    request.bodyStorage = .stream(stream)\n                    self.requestState = .streamingBody(stream)\n                    context.fireChannelRead(self.wrapInboundOut(request))\n                    self.handleBodyStreamStateResult(\n                        context: context,\n                        self.bodyStreamState.didReadBytes(buffer),\n                        stream: stream\n                    )\n                }\n            case .streamingBody(let stream):\n                self.handleBodyStreamStateResult(\n                    context: context,\n                    self.bodyStreamState.didReadBytes(buffer),\n                    stream: stream\n                )\n            case .skipping: break\n            }\n        case .end(let tailHeaders):\n            assert(tailHeaders == nil, \"Tail headers are not supported.\")\n            switch self.requestState {\n            case .ready: assertionFailure(\"Unexpected state: \\(self.requestState)\")\n            case .awaitingBody(let request):\n                context.fireChannelRead(self.wrapInboundOut(request))\n            case .awaitingEnd(let request, let buffer):\n                request.bodyStorage = .collected(buffer)\n                context.fireChannelRead(self.wrapInboundOut(request))\n            case .streamingBody(let stream):\n                self.handleBodyStreamStateResult(\n                    context: context,\n                    self.bodyStreamState.didEnd(),\n                    stream: stream\n                )\n            case .skipping: break\n            }\n            self.requestState = .ready\n        }\n    }\n\n    func read(context: ChannelHandlerContext) {\n        switch self.requestState {\n        case .streamingBody(let stream):\n            self.handleBodyStreamStateResult(\n                context: context,\n                self.bodyStreamState.didReceiveReadRequest(),\n                stream: stream\n            )\n        default:\n            context.read()\n        }\n    }\n\n    func errorCaught(context: ChannelHandlerContext, error: Error) {\n        switch self.requestState {\n        case .streamingBody(let stream):\n            self.handleBodyStreamStateResult(\n                context: context,\n                self.bodyStreamState.didError(error),\n                stream: stream\n            )\n        default:\n            break\n        }\n\n        if error is HTTPParserError {\n            self.logger.debug(\"Invalid HTTP request, will close connection: \\(String(reflecting: error))\")\n        }\n        context.fireErrorCaught(error)\n    }\n\n    func channelInactive(context: ChannelHandlerContext) {\n        switch self.requestState {\n        case .streamingBody(let stream):\n            self.handleBodyStreamStateResult(\n                context: context,\n                self.bodyStreamState.didEnd(),\n                stream: stream\n            )\n        default:\n            break\n        }\n        context.fireChannelInactive()\n    }\n\n    func handleBodyStreamStateResult(\n        context: ChannelHandlerContext,\n        _ result: HTTPBodyStreamState.Result,\n        stream: Request.BodyStream\n    ) {\n        switch result.action {\n        case .nothing: break\n        case .write(let buffer):\n            let box = NIOLoopBound((context, self), eventLoop: context.eventLoop)\n            stream.write(.buffer(buffer)).whenComplete { writeResult in\n                let (context, handler) = box.value\n                switch writeResult {\n                case .failure(let error):\n                    handler.handleBodyStreamStateResult(\n                        context: context,\n                        handler.bodyStreamState.didError(error),\n                        stream: stream\n                    )\n                case .success: break\n                }\n                handler.handleBodyStreamStateResult(\n                    context: context,\n                    handler.bodyStreamState.didWrite(),\n                    stream: stream\n                )\n            }\n        case .close(let maybeError):\n            if let error = maybeError {\n                stream.write(.error(error), promise: nil)\n            } else {\n                stream.write(.end, promise: nil)\n            }\n        }\n        if result.callRead {\n            context.read()\n        }\n    }\n\n    func userInboundEventTriggered(context: ChannelHandlerContext, event: Any) {\n        switch event {\n        case is HTTPServerResponseEncoder.ResponseEndSentEvent:\n            switch self.requestState {\n            case .streamingBody(let bodyStream):\n                // Response ended during request stream.\n                if !bodyStream.isBeingRead {\n                    self.logger.trace(\"Response already sent, draining unhandled request stream.\")\n                    bodyStream.read { _, promise in\n                        promise?.succeed(())\n                    }\n                }\n            case .awaitingBody, .awaitingEnd:\n                // Response ended before request started streaming.\n                self.logger.trace(\"Response already sent, skipping request body.\")\n                self.requestState = .skipping\n            case .ready, .skipping:\n                // Response ended after request had been read.\n                break\n            }\n        case is ChannelShouldQuiesceEvent:\n            switch self.requestState {\n            case .ready:\n                self.logger.trace(\"Closing keep-alive HTTP connection since server is going away\")\n                context.channel.close(mode: .all, promise: nil)\n            default:\n                self.logger.debug(\"A request is currently in-flight\")\n                context.fireUserInboundEventTriggered(event)\n            }\n        default:\n            context.fireUserInboundEventTriggered(event)\n        }\n    }\n}\n\nextension HTTPPart: CustomStringConvertible {\n    public var description: String {\n        switch self {\n        case .head(let head):\n            return \"head: \\(head)\"\n        case .body(let body):\n            return \"body: \\(body)\"\n        case .end(let headers):\n            if let headers = headers {\n                return \"end: \\(headers)\"\n            } else {\n                return \"end\"\n            }\n        }\n    }\n}\n\nstruct HTTPBodyStreamState: CustomStringConvertible {\n    struct Result {\n        enum Action {\n            case nothing\n            case write(ByteBuffer)\n            case close(Error?)\n        }\n        let action: Action\n        let callRead: Bool\n    }\n\n    private struct BufferState {\n        var bufferedWrites: CircularBuffer<ByteBuffer>\n        var heldUpRead: Bool\n        var hasClosed: Bool\n\n        mutating func append(_ buffer: ByteBuffer) {\n            self.bufferedWrites.append(buffer)\n        }\n\n        var isEmpty: Bool {\n            return self.bufferedWrites.isEmpty\n        }\n\n        mutating func removeFirst() -> ByteBuffer {\n            return self.bufferedWrites.removeFirst()\n        }\n    }\n\n    private enum State {\n        case idle\n        case writing(BufferState)\n        case error(Error)\n    }\n\n    private var state: State\n\n    var description: String {\n        \"\\(self.state)\"\n    }\n\n    init() {\n        self.state = .idle\n    }\n\n    mutating func didReadBytes(_ buffer: ByteBuffer) -> Result {\n        switch self.state {\n        case .idle:\n            self.state = .writing(.init(\n                bufferedWrites: .init(),\n                heldUpRead: false,\n                hasClosed: false\n            ))\n            return .init(action: .write(buffer), callRead: false)\n        case .writing(var buffers):\n            buffers.append(buffer)\n            self.state = .writing(buffers)\n            return .init(action: .nothing, callRead: false)\n        case .error:\n            return .init(action: .nothing, callRead: false)\n        }\n    }\n\n    mutating func didReceiveReadRequest() -> Result {\n        switch self.state {\n        case .idle:\n            return .init(action: .nothing, callRead: true)\n        case .writing(var buffers):\n            buffers.heldUpRead = true\n            self.state = .writing(buffers)\n            return .init(action: .nothing, callRead: false)\n        case .error:\n            return .init(action: .nothing, callRead: false)\n        }\n    }\n\n    mutating func didEnd() -> Result {\n        switch self.state {\n        case .idle:\n            return .init(action: .close(nil), callRead: false)\n        case .writing(var buffers):\n            buffers.hasClosed = true\n            self.state = .writing(buffers)\n            return .init(action: .nothing, callRead: false)\n        case .error:\n            return .init(action: .nothing, callRead: false)\n        }\n    }\n\n    mutating func didError(_ error: Error) -> Result {\n        switch self.state {\n        case .idle:\n            self.state = .error(error)\n            return .init(action: .close(error), callRead: false)\n        case .writing:\n            self.state = .error(error)\n            return .init(action: .nothing, callRead: false)\n        case .error:\n            return .init(action: .nothing, callRead: false)\n        }\n    }\n\n    mutating func didWrite() -> Result {\n        switch self.state {\n        case .idle:\n            self.illegalTransition()\n        case .writing(var buffers):\n            if buffers.isEmpty {\n                self.state = .idle\n                return .init(\n                    action: buffers.hasClosed ? .close(nil) : .nothing,\n                    callRead: buffers.heldUpRead\n                )\n            } else {\n                let first = buffers.removeFirst()\n                self.state = .writing(buffers)\n                return .init(action: .write(first), callRead: false)\n            }\n        case .error(let error):\n            return .init(action: .close(error), callRead: false)\n        }\n    }\n\n    private func illegalTransition(_ function: String = #function) -> Never {\n        preconditionFailure(\"illegal transition \\(function) in \\(self)\")\n    }\n}\n", "@testable import Vapor\nimport enum NIOHTTP1.HTTPParserError\nimport XCTest\nimport NIOEmbedded\nimport NIOCore\n\nfinal class PipelineTests: XCTestCase {\n    func testEchoHandlers() throws {\n        let app = Application(.testing)\n        defer { app.shutdown() }\n\n        app.on(.POST, \"echo\", body: .stream) { request -> Response in\n            Response(body: .init(stream: { writer in\n                request.body.drain { body in\n                    switch body {\n                    case .buffer(let buffer):\n                        return writer.write(.buffer(buffer))\n                    case .error(let error):\n                        return writer.write(.error(error))\n                    case .end:\n                        return writer.write(.end)\n                    }\n                }\n            }))\n        }\n\n        let channel = EmbeddedChannel()\n        try channel.pipeline.addVaporHTTP1Handlers(\n            application: app,\n            responder: app.responder,\n            configuration: app.http.server.configuration\n        ).wait()\n\n        try channel.writeInbound(ByteBuffer(string: \"POST /echo HTTP/1.1\\r\\ntransfer-encoding: chunked\\r\\n\\r\\n1\\r\\na\\r\\n\"))\n        let chunk = try channel.readOutbound(as: ByteBuffer.self)?.string\n        XCTAssertContains(chunk, \"HTTP/1.1 200 OK\")\n        XCTAssertContains(chunk, \"connection: keep-alive\")\n        XCTAssertContains(chunk, \"transfer-encoding: chunked\")\n        try XCTAssertEqual(channel.readOutbound(as: ByteBuffer.self)?.string, \"1\\r\\n\")\n        try XCTAssertEqual(channel.readOutbound(as: ByteBuffer.self)?.string, \"a\")\n        try XCTAssertEqual(channel.readOutbound(as: ByteBuffer.self)?.string, \"\\r\\n\")\n        try XCTAssertNil(channel.readOutbound(as: ByteBuffer.self)?.string)\n\n        try channel.writeInbound(ByteBuffer(string: \"1\\r\\nb\\r\\n\"))\n        try XCTAssertEqual(channel.readOutbound(as: ByteBuffer.self)?.string, \"1\\r\\n\")\n        try XCTAssertEqual(channel.readOutbound(as: ByteBuffer.self)?.string, \"b\")\n        try XCTAssertEqual(channel.readOutbound(as: ByteBuffer.self)?.string, \"\\r\\n\")\n        try XCTAssertNil(channel.readOutbound(as: ByteBuffer.self)?.string)\n\n        try channel.writeInbound(ByteBuffer(string: \"1\\r\\nc\\r\\n\"))\n        try XCTAssertEqual(channel.readOutbound(as: ByteBuffer.self)?.string, \"1\\r\\n\")\n        try XCTAssertEqual(channel.readOutbound(as: ByteBuffer.self)?.string, \"c\")\n        try XCTAssertEqual(channel.readOutbound(as: ByteBuffer.self)?.string, \"\\r\\n\")\n        try XCTAssertNil(channel.readOutbound(as: ByteBuffer.self)?.string)\n\n        try channel.writeInbound(ByteBuffer(string: \"0\\r\\n\\r\\n\"))\n        try XCTAssertEqual(channel.readOutbound(as: ByteBuffer.self)?.string, \"0\\r\\n\\r\\n\")\n        try XCTAssertNil(channel.readOutbound(as: ByteBuffer.self)?.string)\n    }\n\n    func testEOFFraming() throws {\n        let app = Application(.testing)\n        defer { app.shutdown() }\n\n        app.on(.POST, \"echo\", body: .stream) { request -> Response in\n            Response(body: .init(stream: { writer in\n                request.body.drain { body in\n                    switch body {\n                    case .buffer(let buffer):\n                        return writer.write(.buffer(buffer))\n                    case .error(let error):\n                        return writer.write(.error(error))\n                    case .end:\n                        return writer.write(.end)\n                    }\n                }\n            }))\n        }\n\n        let channel = EmbeddedChannel()\n        try channel.pipeline.addVaporHTTP1Handlers(\n            application: app,\n            responder: app.responder,\n            configuration: app.http.server.configuration\n        ).wait()\n\n        try channel.writeInbound(ByteBuffer(string: \"POST /echo HTTP/1.1\\r\\n\\r\\n\"))\n        try XCTAssertContains(channel.readOutbound(as: ByteBuffer.self)?.string, \"HTTP/1.1 200 OK\")\n    }\n\n    func testBadStreamLength() throws {\n        let app = Application(.testing)\n        defer { app.shutdown() }\n\n        app.on(.POST, \"echo\", body: .stream) { request -> Response in\n            Response(body: .init(stream: { writer in\n                writer.write(.buffer(.init(string: \"a\")), promise: nil)\n                writer.write(.end, promise: nil)\n            }, count: 2))\n        }\n\n        let channel = EmbeddedChannel()\n        try channel.connect(to: .init(unixDomainSocketPath: \"/foo\")).wait()\n        try channel.pipeline.addVaporHTTP1Handlers(\n            application: app,\n            responder: app.responder,\n            configuration: app.http.server.configuration\n        ).wait()\n\n        XCTAssertEqual(channel.isActive, true)\n        // throws a notEnoughBytes error which is good\n        XCTAssertThrowsError(try channel.writeInbound(ByteBuffer(string: \"POST /echo HTTP/1.1\\r\\n\\r\\n\")))\n        XCTAssertEqual(channel.isActive, false)\n        try XCTAssertContains(channel.readOutbound(as: ByteBuffer.self)?.string, \"HTTP/1.1 200 OK\")\n        try XCTAssertEqual(channel.readOutbound(as: ByteBuffer.self)?.string, \"a\")\n        try XCTAssertNil(channel.readOutbound(as: ByteBuffer.self)?.string)\n    }\n    \n    func testInvalidHttp() throws {\n        let app = Application(.testing)\n        defer { app.shutdown() }\n\n        let channel = EmbeddedChannel()\n        try channel.connect(to: .init(unixDomainSocketPath: \"/foo\")).wait()\n        try channel.pipeline.addVaporHTTP1Handlers(\n            application: app,\n            responder: app.responder,\n            configuration: app.http.server.configuration\n        ).wait()\n\n        XCTAssertEqual(channel.isActive, true)\n        let request = ByteBuffer(string: \"POST /echo/\u00fe HTTP/1.1\\r\\n\\r\\n\")\n        XCTAssertThrowsError(try channel.writeInbound(request)) { error in\n            if let error = error as? HTTPParserError {\n                XCTAssertEqual(error, HTTPParserError.invalidURL)\n            } else {\n                XCTFail(\"Caught error \\\"\\(error)\\\"\")\n            }\n        }\n        XCTAssertEqual(channel.isActive, false)\n        try XCTAssertNil(channel.readOutbound(as: ByteBuffer.self)?.string)\n    }\n\n    override class func setUp() {\n        XCTAssert(isLoggingConfigured)\n    }\n}\n"], "filenames": ["Sources/Vapor/HTTP/Server/HTTPServer.swift", "Sources/Vapor/HTTP/Server/HTTPServerHandler.swift", "Sources/Vapor/HTTP/Server/HTTPServerRequestDecoder.swift", "Tests/VaporTests/PipelineTests.swift"], "buggy_code_start_loc": [455, 74, 135, 141], "buggy_code_end_loc": [614, 75, 222, 142], "fixing_code_start_loc": [454, 74, 136, 140], "fixing_code_end_loc": [543, 75, 226, 140], "type": "CWE-231", "message": "Vapor is an HTTP web framework for Swift. There is a denial of service vulnerability impacting all users of affected versions of Vapor. The HTTP1 error handler closed connections when HTTP parse errors occur instead of passing them on. The issue is fixed as of Vapor release 4.84.2.", "other": {"cve": {"id": "CVE-2023-44386", "sourceIdentifier": "security-advisories@github.com", "published": "2023-10-05T18:15:12.667", "lastModified": "2023-10-11T17:47:30.137", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Vapor is an HTTP web framework for Swift. There is a denial of service vulnerability impacting all users of affected versions of Vapor. The HTTP1 error handler closed connections when HTTP parse errors occur instead of passing them on. The issue is fixed as of Vapor release 4.84.2."}, {"lang": "es", "value": "Vapor es un framework web HTTP para Swift. Existe una vulnerabilidad de denegaci\u00f3n de servicio que afecta a todos los usuarios de las versiones afectadas de Vapor. El controlador de errores HTTP1 cerraba las conexiones cuando se produc\u00edan errores de an\u00e1lisis HTTP en lugar de transmitirlos. El problema se solucion\u00f3 a partir de la versi\u00f3n 4.84.2 de Vapor."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-231"}, {"lang": "en", "value": "CWE-617"}, {"lang": "en", "value": "CWE-696"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vapor:vapor:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.83.2", "versionEndExcluding": "4.84.2", "matchCriteriaId": "E52303C2-AF9E-4F61-86C3-EDD76AD0BB43"}]}]}], "references": [{"url": "https://github.com/vapor/vapor/commit/090464a654b03148b139a81f8f5ac63b0856f6f3", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/vapor/vapor/releases/tag/4.84.2", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/vapor/vapor/security/advisories/GHSA-3mwq-h3g6-ffhm", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/vapor/vapor/commit/090464a654b03148b139a81f8f5ac63b0856f6f3"}}