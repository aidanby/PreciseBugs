{"buggy_code": ["/*****************************************************************************/\n/*  LibreDWG - free implementation of the DWG file format                    */\n/*                                                                           */\n/*  Copyright (C) 2009-2010,2018-2019 Free Software Foundation, Inc.         */\n/*                                                                           */\n/*  This library is free software, licensed under the terms of the GNU       */\n/*  General Public License as published by the Free Software Foundation,     */\n/*  either version 3 of the License, or (at your option) any later version.  */\n/*  You should have received a copy of the GNU General Public License        */\n/*  along with this program.  If not, see <http://www.gnu.org/licenses/>.    */\n/*****************************************************************************/\n\n/*\n * dwg.h: main public header file (the other variant is dwg_api.h)\n *\n * written by Felipe Castro\n * modified by Felipe Corr\u00eaa da Silva Sances\n * modified by Rodrigo Rodrigues da Silva\n * modified by Till Heuschmann\n * modified by Reini Urban\n */\n\n#ifndef DWG_H\n#define DWG_H\n\n/* for uint64_t, but not in swig */\n#ifndef SWIGIMPORTED\n#  include <stdint.h>\n#  include <inttypes.h>\n\n/* wchar for R2007+ support\n * But we need the win32 UTF-16 variant, not UTF-32.\n * i.e. only on Windows, AIX, Solaris\n */\n# if defined(HAVE_WCHAR_H) && defined(SIZEOF_WCHAR_T) && SIZEOF_WCHAR_T == 2\n#  include <wchar.h>\n#  define HAVE_NATIVE_WCHAR2\n#  define DWGCHAR wchar_t\n#  define dwg_wchar_t wchar_t\n# endif\n#endif\n\n#ifndef EXPORT\n# ifdef SWIG\n#  define EXPORT extern\n# elif defined(_WIN32) && defined(ENABLE_SHARED)\n#  ifdef DLL_EXPORT\n#    define EXPORT  __declspec(dllexport)\n#  else\n#    define EXPORT  __declspec(dllimport)\n#  endif\n# elif defined(__clang__) || defined(__clang) || \\\n        (defined( __GNUC__) && ((__GNUC__ * 100) + __GNUC_MINOR__) >= 303)\n#  define EXPORT __attribute__((visibility(\"default\")))\n# else\n#  define EXPORT\n# endif\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#define BITCODE_DOUBLE double\n\n/* The FORMAT_* are for logging only */\ntypedef unsigned char BITCODE_RC;\n#ifdef _WIN32\n# define FORMAT_RC \"0x%2x\"\n#else\n# define FORMAT_RC \"0x%hhx\"\n#endif\n#define FORMAT_RCd \"%d\"\n#define FORMAT_RCu \"%u\"\ntypedef signed char BITCODE_RCd;\ntypedef unsigned char BITCODE_RCu;\ntypedef unsigned char BITCODE_B;\n#define FORMAT_B \"%d\"\ntypedef unsigned char BITCODE_BB;\n#define FORMAT_BB \"%u\"\n/* Since R24 */\ntypedef unsigned char BITCODE_3B;\n#define FORMAT_3B \"%u\"\n//#ifdef HAVE_STDINT_H\n//#define BITCODE_BS uint16_t\n//#define BITCODE_RS uint16_t\n//#define BITCODE_BL uint32_t\n//#define BITCODE_RL uint32_t\n//#define BITCODE_BLd int32_t\n//#define BITCODE_RLd int32_t\ntypedef uint16_t BITCODE_BS;\ntypedef int16_t BITCODE_BSd;\ntypedef uint16_t BITCODE_RS;\ntypedef uint16_t BITCODE_RSx;\ntypedef uint32_t BITCODE_BL;\ntypedef uint32_t BITCODE_BLx;\ntypedef int32_t BITCODE_BLd;\ntypedef uint32_t BITCODE_RL;\ntypedef uint32_t BITCODE_RLx;\ntypedef int32_t BITCODE_RLd;\n/* e.g. old cygwin 64 vs 32 */\n/*#else\n# if defined(__WORDSIZE) && __WORDSIZE == 64\n  typedef unsigned short int BITCODE_BS;\n  typedef unsigned short int BITCODE_RS;\n  typedef unsigned int BITCODE_BL;\n  typedef unsigned int BITCODE_RL;\n  typedef int BITCODE_BLd;\n  typedef int BITCODE_RLd;\n# else\n  typedef unsigned short int BITCODE_BS;\n  typedef unsigned short int BITCODE_RS;\n  typedef unsigned long BITCODE_BL;\n  typedef unsigned long BITCODE_RL;\n  typedef long BITCODE_BLd;\n  typedef long BITCODE_RLd;\n# endif\n#endif\n*/\n//#ifdef HAVE_INTTYPES_H\n#define FORMAT_BS \"%\" PRIu16\n#define FORMAT_BSd \"%\" PRId16\n#define FORMAT_RS \"%\" PRIu16\n#define FORMAT_RSx \"0x%\" PRIx16\n#define FORMAT_BL \"%\" PRIu32\n#define FORMAT_RL \"%\" PRIu32\n#define FORMAT_BLd \"%\" PRId32\n#define FORMAT_RLd \"%\" PRId32\n#define FORMAT_RLx \"0x%\" PRIx32\n#define FORMAT_BLX \"%\" PRIX32\n#define FORMAT_BLx \"0x%\" PRIx32\n/*#else\n# define FORMAT_BS \"%hu\"\n# define FORMAT_RS \"%hu\"\n# define FORMAT_BL \"%u\"\n# define FORMAT_RL \"%u\"\n# define FORMAT_BLd \"%d\"\n# define FORMAT_RLd \"%d\"\n# define FORMAT_BLX \"%X\"\n# define FORMAT_BLx \"%x\"\n#endif\n*/\ntypedef long BITCODE_MC;\n#define FORMAT_MC  \"%ld\"\ntypedef unsigned long BITCODE_UMC;\n#define FORMAT_UMC \"%lu\"\ntypedef BITCODE_BL BITCODE_MS;\n#define FORMAT_MS FORMAT_BL\ntypedef BITCODE_DOUBLE BITCODE_RD;\n#define FORMAT_RD \"%f\"\n/* Since R2004 */\ntypedef uint64_t BITCODE_RLL;\ntypedef uint64_t BITCODE_BLL;\n#define FORMAT_RLL \"0x%\" PRIx64\n#define FORMAT_BLL \"0x%\" PRIx64\n#ifndef HAVE_NATIVE_WCHAR2\n  typedef BITCODE_RS dwg_wchar_t;\n# define DWGCHAR dwg_wchar_t\n#endif\ntypedef char* BITCODE_TF;\n#define FORMAT_TF \"\\\"%s\\\"\"\ntypedef char* BITCODE_TV;\n#define FORMAT_TV \"\\\"%s\\\"\"\ntypedef BITCODE_DOUBLE BITCODE_BT;\n#define FORMAT_BT \"%f\"\ntypedef BITCODE_DOUBLE BITCODE_DD;\n#define FORMAT_DD \"%f\"\ntypedef BITCODE_DOUBLE BITCODE_BD;\n#define FORMAT_BD \"%f\"\ntypedef BITCODE_RC BITCODE_4BITS;\n#define FORMAT_4BITS \"%1x\"\n\n/* TODO: implement version dependent string parsing */\n/* encode codepages/utf8 */\n#define BITCODE_T  BITCODE_TV\n#ifdef HAVE_NATIVE_WCHAR2\n  typedef dwg_wchar_t* BITCODE_TU; /* native UCS-2 wchar_t */\n# define FORMAT_TU \"\\\"%ls\\\"\"\n#else\n  typedef BITCODE_RS* BITCODE_TU;  /* UCS-2 unicode text */\n# define FORMAT_TU \"\\\"%hn\\\"\"       /* will print garbage */\n#endif\n\ntypedef struct _dwg_time_bll\n{\n  BITCODE_BL days;\n  BITCODE_BL ms;\n  BITCODE_BD value;\n} Dwg_Bitcode_TimeBLL;\n\ntypedef struct _dwg_bitcode_2rd\n{\n  BITCODE_RD x;\n  BITCODE_RD y;\n} Dwg_Bitcode_2RD;\n\ntypedef struct _dwg_bitcode_2bd\n{\n  BITCODE_BD x;\n  BITCODE_BD y;\n} Dwg_Bitcode_2BD;\n\ntypedef struct _dwg_bitcode_3rd\n{\n  BITCODE_RD x;\n  BITCODE_RD y;\n  BITCODE_RD z;\n} Dwg_Bitcode_3RD;\n\ntypedef struct _dwg_bitcode_3bd\n{\n  BITCODE_BD x;\n  BITCODE_BD y;\n  BITCODE_BD z;\n} Dwg_Bitcode_3BD;\n\ntypedef Dwg_Bitcode_TimeBLL BITCODE_TIMEBLL;\ntypedef Dwg_Bitcode_TimeBLL BITCODE_TIMERLL;\n/* #define FORMAT_TIMEBLL FORMAT_BL \".\" FORMAT_BL */\ntypedef Dwg_Bitcode_2RD  BITCODE_2RD;\ntypedef Dwg_Bitcode_2BD  BITCODE_2BD;\ntypedef Dwg_Bitcode_2BD  BITCODE_2DPOINT;\ntypedef Dwg_Bitcode_2BD  BITCODE_2BD_1;\ntypedef Dwg_Bitcode_3RD  BITCODE_3RD;\ntypedef Dwg_Bitcode_3BD  BITCODE_3BD;\ntypedef Dwg_Bitcode_3BD  BITCODE_3DPOINT;\ntypedef Dwg_Bitcode_3BD  BITCODE_3BD_1;\ntypedef Dwg_Bitcode_3BD  BITCODE_BE;\n#define BITCODE_3DVECTOR BITCODE_3BD_1\n\ntypedef enum DWG_VERSION_TYPE\n{\n  R_INVALID,\n  R_1_1,\t/* MC0.0  MicroCAD Release 1.1 */\n  R_1_2,\t/* AC1.2  AutoCAD Release 1.2 */\n  R_1_4,\t/* AC1.4  AutoCAD Release 1.4 */\n  R_2_0,\t/* AC1.50 AutoCAD Release 2.0 */\n  R_2_1,\t/* AC2.10 AutoCAD Release 2.10 */\n  R_2_5,\t/* AC1002 AutoCAD Release 2.5 */\n  R_2_6,\t/* AC1003 AutoCAD Release 2.6 */\n  R_9,\t\t/* AC1004 AutoCAD Release 9 */\n  R_10,\t\t/* AC1006 AutoCAD Release 10 */\n  R_11,\t\t/* AC1009 AutoCAD Release 11/12 (LT R1/R2) */\n  R_13,\t\t/* AC1012 AutoCAD Release 13 */\n  R_14,\t\t/* AC1014 AutoCAD Release 14 */\n  R_2000,\t/* AC1015 AutoCAD Release 2000 */\n  R_2004,\t/* AC1018 AutoCAD Release 2004 */\n  R_2007,\t/* AC1021 AutoCAD Release 2007 */\n  R_2010,\t/* AC1024 AutoCAD Release 2010 */\n  R_2013,\t/* AC1027 AutoCAD Release 2013 */\n  R_2018,\t/* AC1032 AutoCAD Release 2018 */\n  R_AFTER\n} Dwg_Version_Type;\n#define DWG_VERSIONS (int)(R_AFTER+1)\n\n/**\n Object supertypes that exist in dwg-files.\n */\ntypedef enum DWG_OBJECT_SUPERTYPE\n{\n  DWG_SUPERTYPE_UNKNOWN, DWG_SUPERTYPE_ENTITY, DWG_SUPERTYPE_OBJECT\n} Dwg_Object_Supertype;\n\n/**\n Object and Entity types that exist in dwg-files.\n */\ntypedef enum DWG_OBJECT_TYPE\n{\n  DWG_TYPE_UNUSED = 0x00,\n  DWG_TYPE_TEXT = 0x01,\n  DWG_TYPE_ATTRIB = 0x02,\n  DWG_TYPE_ATTDEF = 0x03,\n  DWG_TYPE_BLOCK = 0x04,\n  DWG_TYPE_ENDBLK = 0x05,\n  DWG_TYPE_SEQEND = 0x06,\n  DWG_TYPE_INSERT = 0x07,\n  DWG_TYPE_MINSERT = 0x08,\n  /* DWG_TYPE_<UNKNOWN> = 0x09, */\n  DWG_TYPE_VERTEX_2D = 0x0a,\n  DWG_TYPE_VERTEX_3D = 0x0b,\n  DWG_TYPE_VERTEX_MESH = 0x0c,\n  DWG_TYPE_VERTEX_PFACE = 0x0d,\n  DWG_TYPE_VERTEX_PFACE_FACE = 0x0e,\n  DWG_TYPE_POLYLINE_2D = 0x0f,\n  DWG_TYPE_POLYLINE_3D = 0x10,\n  DWG_TYPE_ARC = 0x11,\n  DWG_TYPE_CIRCLE = 0x12,\n  DWG_TYPE_LINE = 0x13,\n  DWG_TYPE_DIMENSION_ORDINATE = 0x14,\n  DWG_TYPE_DIMENSION_LINEAR = 0x15,\n  DWG_TYPE_DIMENSION_ALIGNED = 0x16,\n  DWG_TYPE_DIMENSION_ANG3PT = 0x17,\n  DWG_TYPE_DIMENSION_ANG2LN = 0x18,\n  DWG_TYPE_DIMENSION_RADIUS = 0x19,\n  DWG_TYPE_DIMENSION_DIAMETER = 0x1A,\n  DWG_TYPE_POINT = 0x1b,\n  DWG_TYPE__3DFACE = 0x1c,\n  DWG_TYPE_POLYLINE_PFACE = 0x1d,\n  DWG_TYPE_POLYLINE_MESH = 0x1e,\n  DWG_TYPE_SOLID = 0x1f,\n  DWG_TYPE_TRACE = 0x20,\n  DWG_TYPE_SHAPE = 0x21,\n  DWG_TYPE_VIEWPORT = 0x22,\n  DWG_TYPE_ELLIPSE = 0x23,\n  DWG_TYPE_SPLINE = 0x24,\n  DWG_TYPE_REGION = 0x25,\n  DWG_TYPE__3DSOLID = 0x26,\n  DWG_TYPE_BODY = 0x27,\n  DWG_TYPE_RAY = 0x28,\n  DWG_TYPE_XLINE = 0x29,\n  DWG_TYPE_DICTIONARY = 0x2a,\n  DWG_TYPE_OLEFRAME = 0x2b,\n  DWG_TYPE_MTEXT = 0x2c,\n  DWG_TYPE_LEADER = 0x2d,\n  DWG_TYPE_TOLERANCE = 0x2e,\n  DWG_TYPE_MLINE = 0x2f,\n  DWG_TYPE_BLOCK_CONTROL = 0x30,\n  DWG_TYPE_BLOCK_HEADER = 0x31,\n  DWG_TYPE_LAYER_CONTROL = 0x32,\n  DWG_TYPE_LAYER = 0x33,\n  DWG_TYPE_STYLE_CONTROL = 0x34,\n  DWG_TYPE_STYLE = 0x35,\n  /* DWG_TYPE_<UNKNOWN> = 0x36, */\n  /* DWG_TYPE_<UNKNOWN> = 0x37, */\n  DWG_TYPE_LTYPE_CONTROL = 0x38,\n  DWG_TYPE_LTYPE = 0x39,\n  /* DWG_TYPE_<UNKNOWN> = 0x3a, */\n  /* DWG_TYPE_<UNKNOWN> = 0x3b, */\n  DWG_TYPE_VIEW_CONTROL = 0x3c,\n  DWG_TYPE_VIEW = 0x3d,\n  DWG_TYPE_UCS_CONTROL = 0x3e,\n  DWG_TYPE_UCS = 0x3f,\n  DWG_TYPE_VPORT_CONTROL = 0x40,\n  DWG_TYPE_VPORT = 0x41,\n  DWG_TYPE_APPID_CONTROL = 0x42,\n  DWG_TYPE_APPID = 0x43,\n  DWG_TYPE_DIMSTYLE_CONTROL = 0x44,\n  DWG_TYPE_DIMSTYLE = 0x45,\n  DWG_TYPE_VPORT_ENTITY_CONTROL = 0x46,\n  DWG_TYPE_VPORT_ENTITY_HEADER = 0x47,\n  DWG_TYPE_GROUP = 0x48,\n  DWG_TYPE_MLINESTYLE = 0x49,\n  DWG_TYPE_OLE2FRAME = 0x4a,\n  DWG_TYPE_DUMMY = 0x4b,\n  DWG_TYPE_LONG_TRANSACTION = 0x4c,\n  DWG_TYPE_LWPOLYLINE = 0x4d, /* ?? */\n  DWG_TYPE_HATCH = 0x4e,\n  DWG_TYPE_XRECORD = 0x4f,\n  DWG_TYPE_PLACEHOLDER = 0x50,\n  DWG_TYPE_VBA_PROJECT = 0x51,\n  DWG_TYPE_LAYOUT = 0x52,\n\n  DWG_TYPE_PROXY_ENTITY = 0x1f2, /* 498 */\n  DWG_TYPE_PROXY_OBJECT = 0x1f3, /* 499 */\n\n  /* non-fixed types > 500. not stored as type, but as fixedtype */\n\n  DWG_TYPE_ACSH_HISTORY_CLASS = 0x1ff + 1,\n  DWG_TYPE_ACSH_SWEEP_CLASS,\n  DWG_TYPE_ANNOTSCALEOBJECTCONTEXTDATA,\n  DWG_TYPE_ARCALIGNEDTEXT,\n  DWG_TYPE_ARC_DIMENSION,\n  DWG_TYPE_ASSOC2DCONSTRAINTGROUP,\n  DWG_TYPE_ASSOCACTION,\n  DWG_TYPE_ASSOCALIGNEDDIMACTIONBODY,\n  DWG_TYPE_ASSOCDEPENDENCY,\n  DWG_TYPE_ASSOCGEOMDEPENDENCY,\n  DWG_TYPE_ASSOCNETWORK,\n  DWG_TYPE_ASSOCOSNAPPOINTREFACTIONPARAM,\n  DWG_TYPE_ASSOCPERSSUBENTMANAGER,\n  DWG_TYPE_ASSOCPLANESURFACEACTIONBODY,\n  DWG_TYPE_ASSOCVERTEXACTIONPARAM,\n  DWG_TYPE_CAMERA,\n  DWG_TYPE_CELLSTYLEMAP,\n  DWG_TYPE_DATATABLE,\n  DWG_TYPE_DBCOLOR,\n  DWG_TYPE_DETAILVIEWSTYLE,\n  DWG_TYPE_DICTIONARYVAR,\n  DWG_TYPE_DICTIONARYWDFLT,\n  DWG_TYPE_DIMASSOC,\n  DWG_TYPE_DOCUMENTOPTIONS,\n  DWG_TYPE_DYNAMICBLOCKPURGEPREVENTER,\n  DWG_TYPE_EVALUATION_GRAPH,\n  DWG_TYPE_FIELD,\n  DWG_TYPE_FIELDLIST,\n  DWG_TYPE_GEODATA,\n  DWG_TYPE_GEOMAPIMAGE,\n  DWG_TYPE_GEOPOSITIONMARKER,\n  DWG_TYPE_HELIX,\n  DWG_TYPE_IDBUFFER,\n  DWG_TYPE_IMAGE,\n  DWG_TYPE_IMAGEDEF,\n  DWG_TYPE_IMAGEDEF_REACTOR,\n  DWG_TYPE_LAYER_FILTER,\n  DWG_TYPE_LAYER_INDEX,\n  DWG_TYPE_LAYOUTPRINTCONFIG,\n  DWG_TYPE_LIGHT,\n  DWG_TYPE_LIGHTLIST,\n  DWG_TYPE_MATERIAL,\n  DWG_TYPE_MESH,\n  DWG_TYPE_MLEADERSTYLE,\n  DWG_TYPE_MULTILEADER,\n  DWG_TYPE_NAVISWORKSMODELDEF,\n  DWG_TYPE_NPOCOLLECTION,\n  DWG_TYPE_OBJECTCONTEXTDATA,\n  DWG_TYPE_OBJECT_PTR,\n  DWG_TYPE_PERSSUBENTMANAGER,\n  DWG_TYPE_PLOTSETTINGS,\n  DWG_TYPE_POINTCLOUD,\n  DWG_TYPE_RASTERVARIABLES,\n  DWG_TYPE_RENDERENVIRONMENT,\n  DWG_TYPE_RENDERGLOBAL,\n  DWG_TYPE_MENTALRAYRENDERSETTINGS,\n  DWG_TYPE_RAPIDRTRENDERENVIRONMENT,\n  DWG_TYPE_RAPIDRTRENDERSETTINGS,\n  DWG_TYPE_RTEXT,\n  DWG_TYPE_SCALE,\n  DWG_TYPE_SECTIONVIEWSTYLE,\n  DWG_TYPE_SORTENTSTABLE,\n  DWG_TYPE_SPATIAL_FILTER,\n  DWG_TYPE_SPATIAL_INDEX,\n  DWG_TYPE_SUN,\n  DWG_TYPE_SUNSTUDY,\n  DWG_TYPE_PLANESURFACE,\n  DWG_TYPE_EXTRUDEDSURFACE,\n  DWG_TYPE_LOFTEDSURFACE,\n  DWG_TYPE_REVOLVEDSURFACE,\n  DWG_TYPE_SWEPTSURFACE,\n  DWG_TYPE_TABLE,\n  DWG_TYPE_TABLECONTENT,\n  DWG_TYPE_TABLEGEOMETRY,\n  DWG_TYPE_TABLESTYLE,\n  DWG_TYPE_UNDERLAY, /* not separate DGN,DWF,PDF types */\n  DWG_TYPE_UNDERLAYDEFINITION, /* not separate DGN,DWF,PDF types */\n  DWG_TYPE_VISUALSTYLE,\n  DWG_TYPE_WIPEOUT,\n  DWG_TYPE_WIPEOUTVARIABLES,\n  DWG_TYPE_XREFPANELOBJECT,\n  // after 1.0 add new types here for binary compat\n\n  DWG_TYPE_FREED       = 0xfffd,\n  DWG_TYPE_UNKNOWN_ENT = 0xfffe,\n  DWG_TYPE_UNKNOWN_OBJ = 0xffff,\n} Dwg_Object_Type;\n\n/**\n Error codes returned.\n */\ntypedef enum DWG_ERROR\n{\n  DWG_NOERR = 0,\n  /* sorted by severity */\n  DWG_ERR_WRONGCRC         = 1,\n  DWG_ERR_NOTYETSUPPORTED  = 1 << 1, /* 2 */\n  DWG_ERR_UNHANDLEDCLASS   = 1 << 2, /* 4 */\n  DWG_ERR_INVALIDTYPE      = 1 << 3, /* 8 */\n  DWG_ERR_INVALIDHANDLE    = 1 << 4, /* 16 */\n  DWG_ERR_INVALIDEED       = 1 << 5, /* 32 */\n  DWG_ERR_VALUEOUTOFBOUNDS = 1 << 6, /* 64 */\n  /* -------- critical errors ------- */\n  DWG_ERR_CLASSESNOTFOUND  = 1 << 7, /* 128 */\n  DWG_ERR_SECTIONNOTFOUND  = 1 << 8, /* 256 */\n  DWG_ERR_PAGENOTFOUND     = 1 << 9, /* 512 */\n  DWG_ERR_INTERNALERROR    = 1 << 10,/* 1024 */\n  DWG_ERR_INVALIDDWG       = 1 << 11,/* 2048 */\n  DWG_ERR_IOERROR          = 1 << 12,/* 4096 */\n  DWG_ERR_OUTOFMEM         = 1 << 13,/* 8192 */\n\n} Dwg_Error;\n#define DWG_ERR_CRITICAL DWG_ERR_CLASSESNOTFOUND\n\n/**\n   handles resolve absolute or relative indices to objects.\n\n   code 2-5: represents the type of the relation: hard/soft, owner/id.\n\n   code TYPEDOBJHANDLE:\n    2 Soft owner,\n    3 Hard owner,\n    4 Soft pointer,\n    5 Hard pointer\n\n   code > 6: the handle is stored as an offset from some other handle.\n\n   code OFFSETOBJHANDLE for soft owners or pointers:\n    6 ref + 1,\n    8 ref - 1,\n    a ref + offset,\n    c ref - offset\n\n  See \\ref Dwg_Handle\n */\ntypedef struct _dwg_handle\n{\n  BITCODE_RC code; /*!< OFFSETOBJHANDLE if > 6 */\n  BITCODE_RC size;\n  unsigned long value;\n} Dwg_Handle;\n\n#define FORMAT_H \"%u.%u.%lX\"\n#define ARGS_H(hdl) (hdl).code, (hdl).size, (hdl).value\n#define FORMAT_REF \"(%u.%u.%lX) abs:%lX\"\n#define ARGS_REF(ref) (ref)->handleref.code, (ref)->handleref.size, \\\n    (ref)->handleref.value, (ref)->absolute_ref\n\n/**\nobject references: obj is resolved by handleref (e.g. via\ndwg_resolve_handleref) when reading a DWG to the respective \\ref\nDwg_Object, and absolute_ref is resolved to the global\n_dwg_struct::object_ref index. It is the same as the hex number in the\nDXF handles.\n\nUsed as \\ref Dwg_Object_Ref\n*/\ntypedef struct _dwg_object_ref\n{\n  struct _dwg_object* obj;\n  Dwg_Handle handleref;\n  unsigned long absolute_ref;\n} Dwg_Object_Ref;\n\ntypedef Dwg_Object_Ref* BITCODE_H;\n\n/**\n CMC or ENC colors: color index or rgb value. layers are off when the index\n is negative.\n Used as \\ref Dwg_Color\n */\ntypedef struct _dwg_color /* CmColor: R15 and earlier */\n{\n  BITCODE_BSd index;  /* <0: turned off. 0: BYBLOCK, 256: BYLAYER */\n  BITCODE_BS flag;    /* 1: name follows, 2: book name follows, ... */\n  BITCODE_BL rgb;     /* DXF 420 */\n  BITCODE_H  handle;\n  BITCODE_T  name;    /* DXF 430 */\n  BITCODE_T  book_name;\n  BITCODE_BB alpha_type; /* 0 BYLAYER, 1 BYBLOCK, 3 alpha */\n  BITCODE_RC alpha;      /* DXF 440. 0-255 */\n} Dwg_Color;\n\ntypedef Dwg_Color BITCODE_CMC;\ntypedef Dwg_Color BITCODE_ENC;\n\n/**\n ASCII or Unicode text in xdata \\ref Dwg_Resbuf\n */\nstruct _dwg_binary_chunk\n{\n  short size;\n  int  codepage;\n  union {\n    char *data;\n    DWGCHAR *wdata;\n  } u;\n};\n\n/**\n result buffers: xdata linked list of dxf group - value pairs.\n Used as \\ref Dwg_Resbuf\n */\ntypedef struct _dwg_resbuf\n{\n  short type;\n  union\n  {\n    double  pt[3];\n    char    i8;\n    short   i16;\n    int     i32;\n    BITCODE_BLL i64;\n    double  dbl;\n    unsigned char hdl[8];\n    Dwg_Handle h;\n    struct _dwg_binary_chunk str;\n  } value;\n  struct _dwg_resbuf *next; /* FIXME: this is a perl keyword */\n} Dwg_Resbuf;\n\n/**\n \\struct Dwg_Header_Variables\n DWG header variables for all versions.\n If uppercase related to the DXF HEADER $ name.\n\n \\ref _dwg_header_variables\n */\ntypedef struct _dwg_header_variables {\n  BITCODE_RL size;\n  BITCODE_RL bitsize_hi;   /*!< r2010+ */\n  BITCODE_RL bitsize;\n  BITCODE_RC ACADMAINTVER; /*!< r13+ */\n  BITCODE_BLL REQUIREDVERSIONS; /*!< r2013+ */\n  BITCODE_TV DWGCODEPAGE;  /*!< r10+ */\n  BITCODE_BD unknown_0; /* 412148564080.0 */\n  BITCODE_BD unknown_1; /* 1.0 */\n  BITCODE_BD unknown_2; /* 1.0 */\n  BITCODE_BD unknown_3; /* 1.0 */\n  BITCODE_TV unknown_text1; /* \"\" 4x pre 2007... */\n  BITCODE_TV unknown_text2; /* \"\" */\n  BITCODE_TV unknown_text3; /* \"\" */\n  BITCODE_TV unknown_text4; /* \"\" */\n  BITCODE_BL unknown_8; /* 24L */\n  BITCODE_BL unknown_9; /* 0L */\n  BITCODE_BS unknown_10; /* 0 r13-r14 */\n  BITCODE_H VPORT_ENTITY_HEADER; /*!< r11-r2000 */\n  BITCODE_B DIMASO;\n  BITCODE_B DIMSHO;\n  BITCODE_B DIMSAV; /* undocumented */\n  BITCODE_B PLINEGEN;\n  BITCODE_B ORTHOMODE;\n  BITCODE_B REGENMODE;\n  BITCODE_B FILLMODE;\n  BITCODE_B QTEXTMODE;\n  BITCODE_B PSLTSCALE;\n  BITCODE_B LIMCHECK;\n  BITCODE_B BLIPMODE;\n  BITCODE_B unknown_11;\n  BITCODE_B USRTIMER;\n  BITCODE_B SKPOLY;\n  BITCODE_B ANGDIR;\n  BITCODE_B SPLFRAME;\n  BITCODE_B ATTREQ;\n  BITCODE_B ATTDIA;\n  BITCODE_B MIRRTEXT;\n  BITCODE_B WORLDVIEW;\n  BITCODE_B WIREFRAME; /* Undocumented */\n  BITCODE_B TILEMODE;\n  BITCODE_B PLIMCHECK;\n  BITCODE_B VISRETAIN;\n  BITCODE_B DELOBJ;\n  BITCODE_B DISPSILH;\n  BITCODE_B PELLIPSE;\n  BITCODE_BS SAVEIMAGES; //some r13 only\n  BITCODE_BS PROXYGRAPHICS;\n  BITCODE_BS MEASUREMENT; /* 0 English, 1 Metric. Stored as Section 4 */\n  BITCODE_BS DRAGMODE;\n  BITCODE_BS TREEDEPTH;\n  BITCODE_BS LUNITS;\n  BITCODE_BS LUPREC;\n  BITCODE_BS AUNITS;\n  BITCODE_BS AUPREC;\n  BITCODE_BS OSMODE;\n  BITCODE_BS ATTMODE;\n  BITCODE_BS COORDS;\n  BITCODE_BS PDMODE;\n  BITCODE_BS PICKSTYLE;\n  BITCODE_BL unknown_12;\n  BITCODE_BL unknown_13;\n  BITCODE_BL unknown_14;\n  BITCODE_BS USERI1;\n  BITCODE_BS USERI2;\n  BITCODE_BS USERI3;\n  BITCODE_BS USERI4;\n  BITCODE_BS USERI5;\n  BITCODE_BS SPLINESEGS;\n  BITCODE_BS SURFU;\n  BITCODE_BS SURFV;\n  BITCODE_BS SURFTYPE;\n  BITCODE_BS SURFTAB1;\n  BITCODE_BS SURFTAB2;\n  BITCODE_BS SPLINETYPE;\n  BITCODE_BS SHADEDGE;\n  BITCODE_BS SHADEDIF;\n  BITCODE_BS UNITMODE;\n  BITCODE_BS MAXACTVP;\n  BITCODE_BS ISOLINES;\n  BITCODE_BS CMLJUST;\n  BITCODE_BS TEXTQLTY;\n  BITCODE_BL unknown_14b;\n  BITCODE_BD LTSCALE;\n  BITCODE_BD TEXTSIZE;\n  BITCODE_BD TRACEWID;\n  BITCODE_BD SKETCHINC;\n  BITCODE_BD FILLETRAD;\n  BITCODE_BD THICKNESS;\n  BITCODE_BD ANGBASE;\n  BITCODE_BD PDSIZE;\n  BITCODE_BD PLINEWID;\n  BITCODE_BD USERR1;\n  BITCODE_BD USERR2;\n  BITCODE_BD USERR3;\n  BITCODE_BD USERR4;\n  BITCODE_BD USERR5;\n  BITCODE_BD CHAMFERA;\n  BITCODE_BD CHAMFERB;\n  BITCODE_BD CHAMFERC;\n  BITCODE_BD CHAMFERD;\n  BITCODE_BD FACETRES;\n  BITCODE_BD CMLSCALE;\n  BITCODE_BD CELTSCALE;\n  BITCODE_TV MENU;\n  BITCODE_TIMEBLL TDCREATE;\n  BITCODE_TIMEBLL TDUPDATE;\n  BITCODE_TIMEBLL TDUCREATE;\n  BITCODE_TIMEBLL TDUUPDATE;\n  BITCODE_BL unknown_15;\n  BITCODE_BL unknown_16;\n  BITCODE_BL unknown_17;\n  BITCODE_TIMEBLL TDINDWG;\n  BITCODE_TIMEBLL TDUSRTIMER;\n  BITCODE_CMC CECOLOR;\n  //BITCODE_RS CECOLOR_idx; /* <r13 */\n  BITCODE_BS HANDLING; /* <r14: default 1 */\n  //BITCODE_RS HANDSEED_R11;\n  BITCODE_H HANDSEED;\n  BITCODE_H CLAYER;\n  BITCODE_H TEXTSTYLE;\n  BITCODE_H CELTYPE;\n  BITCODE_H CMATERIAL;\n  BITCODE_H DIMSTYLE;\n  BITCODE_H CMLSTYLE;\n  BITCODE_BD PSVPSCALE;\n  BITCODE_3BD PINSBASE;\n  BITCODE_3BD PEXTMIN;\n  BITCODE_3BD PEXTMAX;\n  BITCODE_2RD PLIMMIN;\n  BITCODE_2RD PLIMMAX;\n  BITCODE_BD  PELEVATION;\n  BITCODE_3BD PUCSORG;\n  BITCODE_3BD PUCSXDIR;\n  BITCODE_3BD PUCSYDIR;\n  BITCODE_H PUCSNAME;\n  BITCODE_H PUCSBASE;\n  BITCODE_H PUCSORTHOREF;\n  BITCODE_BS PUCSORTHOVIEW;\n  BITCODE_3BD PUCSORGTOP;\n  BITCODE_3BD PUCSORGBOTTOM;\n  BITCODE_3BD PUCSORGLEFT;\n  BITCODE_3BD PUCSORGRIGHT;\n  BITCODE_3BD PUCSORGFRONT;\n  BITCODE_3BD PUCSORGBACK;\n  BITCODE_3BD INSBASE;\n  BITCODE_3BD EXTMIN;\n  BITCODE_3BD EXTMAX;\n  BITCODE_2RD LIMMIN;\n  BITCODE_2RD LIMMAX;\n  BITCODE_2RD VIEWCTR;  /* -r11 */\n  BITCODE_BD ELEVATION;\n  BITCODE_RD VIEWSIZE;  /* -r11 */\n  BITCODE_RS SNAPMODE;  /* -r11 */\n  BITCODE_2RD SNAPUNIT; /* -r11 */\n  BITCODE_2RD SNAPBASE; /* -r11 */\n  BITCODE_RD SNAPANG;   /* -r11 */\n  BITCODE_RS SNAPSTYL;  /* -r11 */\n  BITCODE_RS SNAPISOPAIR; /* -r11 */\n  BITCODE_RS GRIDMODE;  /* -r11 */\n  BITCODE_2RD GRIDUNIT; /* -r11 */\n  BITCODE_3BD UCSORG;\n  BITCODE_3BD UCSXDIR;\n  BITCODE_3BD UCSYDIR;\n  BITCODE_H UCSNAME;\n  BITCODE_H UCSBASE;\n  BITCODE_BS UCSORTHOVIEW;\n  BITCODE_H UCSORTHOREF;\n  BITCODE_3BD UCSORGTOP;\n  BITCODE_3BD UCSORGBOTTOM;\n  BITCODE_3BD UCSORGLEFT;\n  BITCODE_3BD UCSORGRIGHT;\n  BITCODE_3BD UCSORGFRONT;\n  BITCODE_3BD UCSORGBACK;\n  BITCODE_TV DIMPOST;\n  BITCODE_TV DIMAPOST;\n  BITCODE_B DIMTOL;\n  BITCODE_B DIMLIM;\n  BITCODE_B DIMTIH;\n  BITCODE_B DIMTOH;\n  BITCODE_B DIMSE1;\n  BITCODE_B DIMSE2;\n  BITCODE_B DIMALT;\n  BITCODE_B DIMTOFL;\n  BITCODE_B DIMSAH;\n  BITCODE_B DIMTIX;\n  BITCODE_B DIMSOXD;\n  BITCODE_BS DIMALTD;   /*!< r13-r14 only RC */\n  BITCODE_BS DIMZIN;    /*!< r13-r14 only RC */\n  BITCODE_B DIMSD1;\n  BITCODE_B DIMSD2;\n  BITCODE_BS DIMTOLJ;   /*!< r13-r14 only RC */\n  BITCODE_BS DIMJUST;   /*!< r13-r14 only RC */\n  BITCODE_BS DIMFIT;    /*!< r13-r14 only RC */\n  BITCODE_B DIMUPT;\n  BITCODE_BS DIMTZIN;   /*!< r13-r14 only RC */\n  BITCODE_BS DIMMALTZ;  /*!< r13-r14 only RC */\n  BITCODE_BS DIMMALTTZ; /*!< r13-r14 only RC */\n  BITCODE_BS DIMTAD;    /*!< r13-r14 only RC */\n  BITCODE_BS DIMUNIT;\n  BITCODE_BS DIMAUNIT;\n  BITCODE_BS DIMDEC;\n  BITCODE_BS DIMTDEC;\n  BITCODE_BS DIMALTU;\n  BITCODE_BS DIMALTTD;\n  BITCODE_H DIMTXSTY;\n  BITCODE_BD DIMSCALE;\n  BITCODE_BD DIMASZ;\n  BITCODE_BD DIMEXO;\n  BITCODE_BD DIMDLI;\n  BITCODE_BD DIMEXE;\n  BITCODE_BD DIMRND;\n  BITCODE_BD DIMDLE;\n  BITCODE_BD DIMTP;\n  BITCODE_BD DIMTM;\n  BITCODE_BD DIMFXL;\n  BITCODE_BD DIMJOGANG;\n  BITCODE_BS DIMTFILL;\n  BITCODE_CMC DIMTFILLCLR;\n  BITCODE_BS DIMAZIN;\n  BITCODE_BS DIMARCSYM;\n  BITCODE_BD DIMTXT;\n  BITCODE_BD DIMCEN;\n  BITCODE_BD DIMTSZ;\n  BITCODE_BD DIMALTF;\n  BITCODE_BD DIMLFAC;\n  BITCODE_BD DIMTVP;\n  BITCODE_BD DIMTFAC;\n  BITCODE_BD DIMGAP;\n  BITCODE_T DIMPOST_T; /* preR13 => handle */\n  BITCODE_T DIMAPOST_T;\n  BITCODE_T DIMBLK_T;\n  BITCODE_T DIMBLK1_T;\n  BITCODE_T DIMBLK2_T;\n  BITCODE_BD DIMALTRND;\n  BITCODE_RS DIMCLRD_C; /* preR13 => CMC */\n  BITCODE_RS DIMCLRE_C;\n  BITCODE_RS DIMCLRT_C;\n  BITCODE_CMC DIMCLRD;\n  BITCODE_CMC DIMCLRE;\n  BITCODE_CMC DIMCLRT;\n  BITCODE_BS DIMADEC;   /*!< r2000+ ... */\n  BITCODE_BS DIMFRAC;\n  BITCODE_BS DIMLUNIT;\n  BITCODE_BS DIMDSEP;\n  BITCODE_BS DIMTMOVE;\n  BITCODE_BS DIMALTZ;\n  BITCODE_BS DIMALTTZ;\n  BITCODE_BS DIMATFIT;\n  BITCODE_B  DIMFXLON;  /*!< r2007+ */\n  BITCODE_B  DIMTXTDIRECTION; /*!< r2010+ */\n  BITCODE_BD DIMALTMZF; /*!< r2010+ */\n  BITCODE_T  DIMALTMZS; /*!< r2010+ */\n  BITCODE_BD DIMMZF;    /*!< r2010+ */\n  BITCODE_T  DIMMZS;    /*!< r2010+ */\n  /*BITCODE_H DIMTXSTY;*/  /*!< r2000+ */\n  BITCODE_H DIMLDRBLK;  /*!< r2000+ */\n  BITCODE_H DIMBLK;     /*!< r2000+ */\n  BITCODE_H DIMBLK1;    /*!< r2000+ */\n  BITCODE_H DIMBLK2;    /*!< r2000+ */\n  BITCODE_H DIMLTYPE; /*!< r2007+ */\n  BITCODE_H DIMLTEX1; /*!< r2007+ */\n  BITCODE_H DIMLTEX2; /*!< r2007+ */\n  BITCODE_BSd DIMLWD;  /*!< r2000+ */\n  BITCODE_BSd DIMLWE;  /*!< r2000+ */\n  BITCODE_H BLOCK_CONTROL_OBJECT;\n  BITCODE_H LAYER_CONTROL_OBJECT;\n  BITCODE_H STYLE_CONTROL_OBJECT;\n  BITCODE_H LTYPE_CONTROL_OBJECT;\n  BITCODE_H VIEW_CONTROL_OBJECT;\n  BITCODE_H UCS_CONTROL_OBJECT;\n  BITCODE_H VPORT_CONTROL_OBJECT;\n  BITCODE_H APPID_CONTROL_OBJECT;\n  BITCODE_H DIMSTYLE_CONTROL_OBJECT;\n  BITCODE_H VPORT_ENTITY_CONTROL_OBJECT; /*!< r11-r2000 */\n  BITCODE_H DICTIONARY_ACAD_GROUP;\n  BITCODE_H DICTIONARY_ACAD_MLINESTYLE;\n  BITCODE_H DICTIONARY_NAMED_OBJECT;\n  BITCODE_BS TSTACKALIGN;           /*!< r2000+ */\n  BITCODE_BS TSTACKSIZE;            /*!< r2000+ */\n  BITCODE_TV HYPERLINKBASE;         /*!< r2000+ */\n  BITCODE_TV STYLESHEET;            /*!< r2000+ */\n  BITCODE_H DICTIONARY_LAYOUT;      /*!< r2000+ */\n  BITCODE_H DICTIONARY_PLOTSETTINGS;   /*!< r2000+ */\n  BITCODE_H DICTIONARY_PLOTSTYLENAME;  /*!< r2000+ */\n  BITCODE_H DICTIONARY_MATERIAL;    /*!< r2004+ */\n  BITCODE_H DICTIONARY_COLOR;       /*!< r2004+ */\n  BITCODE_H DICTIONARY_VISUALSTYLE; /*!< r2007+ */\n  BITCODE_H DICTIONARY_LIGHTLIST;   /*!< r2010+ ?? */\n  BITCODE_H unknown_20;             /*!< r2013+ */\n  BITCODE_BL FLAGS;\n  BITCODE_BSd CELWEIGHT; /* = FLAGS & 0x1f, see dxf_cvt_lweight() DXF 370 (int16) */\n  BITCODE_B  ENDCAPS;   /* = FLAGS & 0x60 */\n  BITCODE_B  JOINSTYLE; /* = FLAGS & 0x180 */\n  BITCODE_B  LWDISPLAY; /* = !(FLAGS & 0x200) */\n  BITCODE_B  XEDIT;     /* = !(FLAGS & 0x400) */\n  BITCODE_B  EXTNAMES;  /* = FLAGS & 0x800 */\n  BITCODE_B  PSTYLEMODE; /* = FLAGS & 0x2000 */\n  BITCODE_B  OLESTARTUP; /* = FLAGS & 0x4000 */\n  BITCODE_BS INSUNITS;\n  BITCODE_BS CEPSNTYPE;\n  BITCODE_H CPSNID;\n  BITCODE_TV FINGERPRINTGUID;\n  BITCODE_TV VERSIONGUID;\n  BITCODE_RC SORTENTS;\n  BITCODE_RC INDEXCTL;\n  BITCODE_RC HIDETEXT;\n  BITCODE_RC XCLIPFRAME;\n  BITCODE_RC DIMASSOC;\n  BITCODE_RC HALOGAP;\n  BITCODE_BS OBSCOLOR;\n  BITCODE_BS INTERSECTIONCOLOR;\n  BITCODE_RC OBSLTYPE;\n  BITCODE_RC INTERSECTIONDISPLAY;\n  BITCODE_TV PROJECTNAME;\n  BITCODE_H BLOCK_RECORD_PSPACE;\n  BITCODE_H BLOCK_RECORD_MSPACE;\n  BITCODE_H LTYPE_BYLAYER;\n  BITCODE_H LTYPE_BYBLOCK;\n  BITCODE_H LTYPE_CONTINUOUS;\n  BITCODE_B CAMERADISPLAY; /*!< r2007+ ... */\n  BITCODE_BL unknown_21;\n  BITCODE_BL unknown_22;\n  BITCODE_BD unknown_23;\n  BITCODE_BD STEPSPERSEC;\n  BITCODE_BD STEPSIZE;\n  BITCODE_BD _3DDWFPREC;\n  BITCODE_BD LENSLENGTH;\n  BITCODE_BD CAMERAHEIGHT;\n  BITCODE_RC SOLIDHIST;\n  BITCODE_RC SHOWHIST;\n  BITCODE_BD PSOLWIDTH;\n  BITCODE_BD PSOLHEIGHT;\n  BITCODE_BD LOFTANG1;\n  BITCODE_BD LOFTANG2;\n  BITCODE_BD LOFTMAG1;\n  BITCODE_BD LOFTMAG2;\n  BITCODE_BS LOFTPARAM;\n  BITCODE_RC LOFTNORMALS;\n  BITCODE_BD LATITUDE;\n  BITCODE_BD LONGITUDE;\n  BITCODE_BD NORTHDIRECTION;\n  BITCODE_BL TIMEZONE;\n  BITCODE_RC LIGHTGLYPHDISPLAY;\n  BITCODE_RC TILEMODELIGHTSYNCH;\n  BITCODE_RC DWFFRAME;\n  BITCODE_RC DGNFRAME;\n  BITCODE_B REALWORLDSCALE;\n  BITCODE_CMC INTERFERECOLOR;\n  BITCODE_H INTERFEREOBJVS;\n  BITCODE_H INTERFEREVPVS;\n  BITCODE_H DRAGVS;\n  BITCODE_RC CSHADOW;\n  BITCODE_BD SHADOWPLANELOCATION;\n  BITCODE_BS unknown_54; /*!< r14+ ... optional */\n  BITCODE_BS unknown_55;\n  BITCODE_BS unknown_56;\n  BITCODE_BS unknown_57;\n} Dwg_Header_Variables;\n\n/* OBJECTS *******************************************************************/\n/**\n UNUSED (0) entity. Unknown entities are stored as blob\n */\ntypedef int Dwg_Entity_UNUSED;\n\n/** \\ref Dwg_Entity_TEXT\n TEXT (1) entity\n */\ntypedef struct _dwg_entity_TEXT\n{\n  struct _dwg_object_entity *parent;\n\n  BITCODE_RC dataflags;        /*!< r2000+ */\n  BITCODE_RD elevation;        /*!< DXF 30 (z coord of 10), when dataflags & 1 */\n  BITCODE_2DPOINT insertion_pt; /*!< DXF 10 */\n  BITCODE_2DPOINT alignment_pt; /*!< DXF 11. optional, when dataflags & 2, i.e 72/73 != 0 */\n  BITCODE_BE extrusion;       /*!< DXF 210. Default 0,0,1 */\n  BITCODE_RD thickness;       /*!< DXF 39 */\n  BITCODE_RD oblique_ang;     /*!< DXF 51 */\n  BITCODE_RD rotation;        /*!< DXF 50 */\n  BITCODE_RD height;          /*!< DXF 40 */\n  BITCODE_RD width_factor;    /*!< DXF 41 */\n  BITCODE_TV text_value;      /*!< DXF 1 */\n  BITCODE_BS generation;      /*!< DXF 71 */\n  BITCODE_BS horiz_alignment; /*!< DXF 72. options 0-5:\n                                 0 = Left; 1= Center; 2 = Right; 3 = Aligned;\n                                 4 = Middle; 5 = Fit */\n  BITCODE_BS vert_alignment;  /*!< DXF 73. options 0-3:\n                                 0 = Baseline; 1 = Bottom; 2 = Middle; 3 = Top */\n  BITCODE_H style;\n} Dwg_Entity_TEXT;\n\n/** \\ref Dwg_Entity_ATTRIB\n ATTRIB (2) entity\n */\ntypedef struct _dwg_entity_ATTRIB\n{\n  struct _dwg_object_entity *parent;\n\n  BITCODE_BD elevation;\n  BITCODE_2DPOINT insertion_pt;\n  BITCODE_2DPOINT alignment_pt;\n  BITCODE_BE extrusion;\n  BITCODE_RD thickness;\n  BITCODE_RD oblique_ang;\n  BITCODE_RD rotation;\n  BITCODE_RD height;\n  BITCODE_RD width_factor;\n  BITCODE_TV text_value;\n  BITCODE_BS generation;\n  BITCODE_BS horiz_alignment;\n  BITCODE_BS vert_alignment;\n  BITCODE_RC dataflags;\n  BITCODE_RC class_version; /* R2010+ */\n  BITCODE_RC type;    /* R2018+ */\n  BITCODE_TV tag;\n  BITCODE_BS field_length; /* DXF 73 but unused */\n  BITCODE_RC flags;\n  BITCODE_B lock_position_flag;\n  BITCODE_H style;\n  BITCODE_H mtext_handles; /* R2018+ TODO */\n  BITCODE_BS annotative_data_size; /* R2018+ */\n  BITCODE_RC annotative_data_bytes;\n  BITCODE_H  annotative_app;\n  BITCODE_BS annotative_short;\n} Dwg_Entity_ATTRIB;\n\n/** \\ref Dwg_Entity_ATTDEF\n ATTDEF (3) entity\n */\ntypedef struct _dwg_entity_ATTDEF\n{\n  struct _dwg_object_entity *parent;\n\n  BITCODE_BD elevation;\n  BITCODE_2DPOINT insertion_pt;\n  BITCODE_2DPOINT alignment_pt;\n  BITCODE_BE extrusion;\n  BITCODE_RD thickness;\n  BITCODE_RD oblique_ang;\n  BITCODE_RD rotation;\n  BITCODE_RD height;\n  BITCODE_RD width_factor;\n  BITCODE_TV default_value;\n  BITCODE_BS generation;\n  BITCODE_BS horiz_alignment;\n  BITCODE_BS vert_alignment;\n  BITCODE_RC dataflags;\n  BITCODE_RC class_version; /* R2010+ */\n  BITCODE_RC type;    /* R2018+ */\n  BITCODE_TV tag;\n  BITCODE_BS field_length;\n  BITCODE_RC flags;\n  BITCODE_B lock_position_flag;\n  BITCODE_H style;\n  BITCODE_H mtext_handles; /* R2018+ TODO */\n  BITCODE_BS annotative_data_size; /* R2018+ */\n  BITCODE_RC annotative_data_bytes;\n  BITCODE_H  annotative_app;\n  BITCODE_BS annotative_short;\n\n  BITCODE_RC attdef_class_version; /* R2010+ */\n  BITCODE_TV prompt;\n} Dwg_Entity_ATTDEF;\n\n/**\n BLOCK (4) entity\n */\ntypedef struct _dwg_entity_BLOCK\n{\n  struct _dwg_object_entity *parent;\n\n  BITCODE_TV name;\n} Dwg_Entity_BLOCK;\n\n/**\n ENDBLK (5) entity\n */\ntypedef struct _dwg_entity_ENDBLK\n{\n  struct _dwg_object_entity *parent;\n} Dwg_Entity_ENDBLK;\n\n/**\n SEQEND (6) entity\n */\ntypedef struct _dwg_entity_SEQEND\n{\n  struct _dwg_object_entity *parent;\n} Dwg_Entity_SEQEND;\n\n/**\n INSERT (7) entity\n */\ntypedef struct _dwg_entity_INSERT\n{\n  struct _dwg_object_entity *parent;\n\n  BITCODE_3DPOINT   ins_pt;\n  BITCODE_BB        scale_flag;\n  BITCODE_3DPOINT   scale;\n  BITCODE_BD        rotation;\n  BITCODE_BE        extrusion;\n  BITCODE_B         has_attribs;\n  BITCODE_BL        num_owned;\n\n  BITCODE_H   block_header;\n  BITCODE_H   first_attrib;\n  BITCODE_H   last_attrib;\n  BITCODE_H*  attrib_handles;\n  BITCODE_H   seqend;\n} Dwg_Entity_INSERT;\n\n/**\n MINSERT (8) entity\n */\ntypedef struct _dwg_entity_MINSERT\n{\n  struct _dwg_object_entity *parent;\n\n  BITCODE_3DPOINT   ins_pt;\n  BITCODE_BB        scale_flag;\n  BITCODE_3DPOINT   scale;\n  BITCODE_BD        rotation;\n  BITCODE_BE        extrusion;\n  BITCODE_B         has_attribs;\n  BITCODE_BL        num_owned;\n\n  BITCODE_BS        num_cols;\n  BITCODE_BS        num_rows;\n  BITCODE_BD        col_spacing;\n  BITCODE_BD        row_spacing;\n\n  BITCODE_H   block_header;\n  BITCODE_H   first_attrib;\n  BITCODE_H   last_attrib;\n  BITCODE_H*  attrib_handles;\n  BITCODE_H   seqend;\n} Dwg_Entity_MINSERT;\n\n/**\n VERTEX_2D (10) entity\n */\ntypedef struct _dwg_entity_VERTEX_2D\n{\n  struct _dwg_object_entity *parent;\n\n  BITCODE_RC flag;\n  BITCODE_3BD point;\n  BITCODE_BD start_width;\n  BITCODE_BD end_width;\n  BITCODE_BL id; /* R2010+ */\n  BITCODE_BD bulge;\n  BITCODE_BD tangent_dir;\n} Dwg_Entity_VERTEX_2D;\n\n/**\n VERTEX_3D (11) entity\n */\ntypedef struct _dwg_entity_VERTEX_3D\n{\n  struct _dwg_object_entity *parent;\n\n  BITCODE_RC flag;\n  BITCODE_3BD point;\n} Dwg_Entity_VERTEX_3D;\n\n/**\n VERTEX_MESH (12) - same as VERTEX_3D entity\n */\ntypedef Dwg_Entity_VERTEX_3D Dwg_Entity_VERTEX_MESH;\n\n/**\n VERTEX_PFACE (13) - same as VERTEX_3D entity\n */\ntypedef Dwg_Entity_VERTEX_3D Dwg_Entity_VERTEX_PFACE;\n\n/**\n VERTEX_PFACE_FACE (14) entity\n */\ntypedef struct _dwg_entity_VERTEX_PFACE_FACE\n{\n  struct _dwg_object_entity *parent;\n\n  BITCODE_RC flag;\n  BITCODE_BS vertind[4];\n} Dwg_Entity_VERTEX_PFACE_FACE;\n\n#define COMMON_ENTITY_POLYLINE \\\n  struct _dwg_object_entity *parent; \\\n  BITCODE_B has_vertex; \\\n  BITCODE_BL num_owned; \\\n  BITCODE_H first_vertex; \\\n  BITCODE_H last_vertex; \\\n  BITCODE_H* vertex; \\\n  BITCODE_H seqend\n\n/**\n 2D POLYLINE (15) entity\n */\ntypedef struct _dwg_entity_POLYLINE_2D\n{\n  COMMON_ENTITY_POLYLINE;\n\n  BITCODE_BS flag;\n  BITCODE_BS curve_type;\n  BITCODE_BD start_width;\n  BITCODE_BD end_width;\n  BITCODE_BT thickness;\n  BITCODE_BD elevation;\n  BITCODE_BE extrusion;\n} Dwg_Entity_POLYLINE_2D;\n\n/**\n 3D POLYLINE (16) entity\n */\ntypedef struct _dwg_entity_POLYLINE_3D\n{\n  COMMON_ENTITY_POLYLINE;\n\n  BITCODE_RC curve_type;\n  BITCODE_RC flag;\n} Dwg_Entity_POLYLINE_3D;\n\n/**\n ARC (17) entity\n */\ntypedef struct _dwg_entity_ARC\n{\n  struct _dwg_object_entity *parent;\n\n  BITCODE_3BD center;\n  BITCODE_BD radius;\n  BITCODE_BT thickness;\n  BITCODE_BE extrusion;\n  BITCODE_BD start_angle;\n  BITCODE_BD end_angle;\n} Dwg_Entity_ARC;\n\n/**\n CIRCLE (18) entity\n */\ntypedef struct _dwg_entity_CIRCLE\n{\n  struct _dwg_object_entity *parent;\n\n  BITCODE_3BD center;\n  BITCODE_BD radius;\n  BITCODE_BT thickness;\n  BITCODE_BE extrusion;\n} Dwg_Entity_CIRCLE;\n\n/**\n LINE (19) entity\n */\ntypedef struct _dwg_entity_LINE\n{\n  struct _dwg_object_entity *parent;\n\n  BITCODE_RC z_is_zero;\n  BITCODE_3BD start;\n  BITCODE_3BD end;\n  BITCODE_BT thickness;\n  BITCODE_BE extrusion;\n} Dwg_Entity_LINE;\n\n/**\n * Macro for common DIMENSION declaration\n */\n#define DIMENSION_COMMON \\\n    struct _dwg_object_entity *parent; \\\n    BITCODE_RC class_version; /* R2010+ */ \\\n    BITCODE_TV blockname; \\\n    BITCODE_BE extrusion; \\\n    BITCODE_3BD def_pt; \\\n    BITCODE_2RD text_midpt; \\\n    BITCODE_BD elevation; \\\n    BITCODE_RC flag; /* calculated, DXF only */ \\\n    BITCODE_RC flag1; \\\n    BITCODE_TV user_text; \\\n    BITCODE_BD text_rotation; \\\n    BITCODE_BD horiz_dir; \\\n    BITCODE_3BD ins_scale; \\\n    BITCODE_BD ins_rotation; \\\n    BITCODE_BS attachment; \\\n    BITCODE_BS lspace_style; \\\n    BITCODE_BD lspace_factor; \\\n    BITCODE_BD act_measurement; \\\n    BITCODE_B unknown; \\\n    BITCODE_B flip_arrow1; \\\n    BITCODE_B flip_arrow2; \\\n    BITCODE_2RD clone_ins_pt;\n\ntypedef struct _dwg_DIMENSION_common\n{\n  DIMENSION_COMMON\n} Dwg_DIMENSION_common;\n\n/**\n ordinate dimension - DIMENSION_ORDINATE (20) entity\n */\ntypedef struct _dwg_entity_DIMENSION_ORDINATE\n{\n  DIMENSION_COMMON\n  BITCODE_3BD feature_location_pt;\n  BITCODE_3BD leader_endpt;\n  BITCODE_RC flag2;\n  BITCODE_H dimstyle;\n  BITCODE_H block;\n} Dwg_Entity_DIMENSION_ORDINATE;\n\n/**\n linear dimension - DIMENSION_LINEAR (21) entity\n */\ntypedef struct _dwg_entity_DIMENSION_LINEAR\n{\n  DIMENSION_COMMON\n  BITCODE_3BD _13_pt;\n  BITCODE_3BD _14_pt;\n  BITCODE_BD ext_line_rotation;\n  BITCODE_BD dim_rotation;\n  BITCODE_H dimstyle;\n  BITCODE_H block;\n} Dwg_Entity_DIMENSION_LINEAR;\n\n/**\n aligned dimension - DIMENSION_ALIGNED (22) entity\n */\ntypedef struct _dwg_entity_DIMENSION_ALIGNED\n{\n  DIMENSION_COMMON\n  BITCODE_3BD _13_pt;\n  BITCODE_3BD _14_pt;\n  BITCODE_BD ext_line_rotation;\n  BITCODE_H dimstyle;\n  BITCODE_H block;\n} Dwg_Entity_DIMENSION_ALIGNED;\n\n/**\n angular 3pt dimension - DIMENSION_ANG3PT (23) entity\n */\ntypedef struct _dwg_entity_DIMENSION_ANG3PT\n{\n  DIMENSION_COMMON\n  BITCODE_3BD _13_pt;\n  BITCODE_3BD _14_pt;\n  BITCODE_3BD first_arc_pt;\n  BITCODE_H dimstyle;\n  BITCODE_H block;\n} Dwg_Entity_DIMENSION_ANG3PT;\n\n/**\n angular 2 line dimension - DIMENSION_ANG2LN (24) entity\n */\ntypedef struct _dwg_entity_DIMENSION_ANG2LN\n{\n  DIMENSION_COMMON\n  BITCODE_2RD _16_pt;\n  BITCODE_3BD _13_pt;\n  BITCODE_3BD _14_pt;\n  BITCODE_3BD first_arc_pt;\n  BITCODE_H dimstyle;\n  BITCODE_H block;\n} Dwg_Entity_DIMENSION_ANG2LN;\n\n/**\n radius dimension - DIMENSION_RADIUS (25) entity\n */\ntypedef struct _dwg_entity_DIMENSION_RADIUS\n{\n  DIMENSION_COMMON\n  BITCODE_3BD first_arc_pt; /*!< DXF 15 */\n  BITCODE_BD leader_len;    /*!< DXF 40 */\n  BITCODE_H dimstyle;\n  BITCODE_H block;\n} Dwg_Entity_DIMENSION_RADIUS;\n\n/**\n diameter dimension - DIMENSION_DIAMETER (26) entity\n */\ntypedef struct _dwg_entity_DIMENSION_DIAMETER\n{\n  DIMENSION_COMMON\n  BITCODE_3BD first_arc_pt; /*!< DXF 15 */\n  BITCODE_BD leader_len;    /*!< DXF 40 */\n  BITCODE_H dimstyle;\n  BITCODE_H block;\n} Dwg_Entity_DIMENSION_DIAMETER;\n\n/**\n arc dimension - ARC_DIMENSION (varies) entity\n */\ntypedef struct _dwg_entity_ARC_DIMENSION\n{\n  DIMENSION_COMMON\n  BITCODE_3BD _13_pt;\n  BITCODE_3BD _14_pt;\n  BITCODE_3BD _15_pt;\n  BITCODE_3BD unknown_pt;\n  BITCODE_3BD _16_pt;\n  BITCODE_3BD _17_pt;\n  BITCODE_BD leader_len;    /*!< DXF 40 */\n  BITCODE_RC flag2;\n  BITCODE_H dimstyle;\n  BITCODE_H block;\n} Dwg_Entity_ARC_DIMENSION;\n\n/**\n Struct for:  POINT (27)\n */\ntypedef struct _dwg_entity_POINT\n{\n  struct _dwg_object_entity *parent;\n\n  BITCODE_BD x;\n  BITCODE_BD y;\n  BITCODE_BD z;\n  BITCODE_BT thickness;\n  BITCODE_BE extrusion;\n  BITCODE_BD x_ang;\n} Dwg_Entity_POINT;\n\n/**\n Struct for:  3D FACE (28)\n */\ntypedef struct _dwg_entity_3DFACE\n{\n  struct _dwg_object_entity *parent;\n\n  BITCODE_B has_no_flags;\n  BITCODE_B z_is_zero;\n  BITCODE_3BD corner1;\n  BITCODE_3BD corner2;\n  BITCODE_3BD corner3;\n  BITCODE_3BD corner4;\n  BITCODE_BS invis_flags;\n} Dwg_Entity__3DFACE;\n\n/**\n Struct for:  POLYLINE (PFACE) (29)\n */\ntypedef struct _dwg_entity_POLYLINE_PFACE\n{\n  COMMON_ENTITY_POLYLINE;\n\n  BITCODE_BS numverts;\n  BITCODE_BS numfaces;\n} Dwg_Entity_POLYLINE_PFACE;\n\n/**\n Struct for:  POLYLINE (MESH) (30)\n */\ntypedef struct _dwg_entity_POLYLINE_MESH\n{\n  COMMON_ENTITY_POLYLINE;\n\n  BITCODE_BS flag;\n  BITCODE_BS curve_type;\n  BITCODE_BS num_m_verts;\n  BITCODE_BS num_n_verts;\n  BITCODE_BS m_density;\n  BITCODE_BS n_density;\n} Dwg_Entity_POLYLINE_MESH;\n\n/**\n Struct for:  SOLID (31)\n */\n\ntypedef struct _dwg_entity_SOLID\n{\n  struct _dwg_object_entity *parent;\n\n  BITCODE_BT thickness;\n  BITCODE_BD elevation;\n  BITCODE_2RD corner1;\n  BITCODE_2RD corner2;\n  BITCODE_2RD corner3;\n  BITCODE_2RD corner4;\n  BITCODE_BE extrusion;\n} Dwg_Entity_SOLID;\n\n/**\n Struct for:  TRACE (32)\n */\n\ntypedef struct _dwg_entity_TRACE\n{\n  struct _dwg_object_entity *parent;\n\n  BITCODE_BT thickness;\n  BITCODE_BD elevation;\n  BITCODE_2RD corner1;\n  BITCODE_2RD corner2;\n  BITCODE_2RD corner3;\n  BITCODE_2RD corner4;\n  BITCODE_BE extrusion;\n} Dwg_Entity_TRACE;\n\n/**\n Struct for:  SHAPE (33)\n */\n\ntypedef struct _dwg_entity_SHAPE\n{\n  struct _dwg_object_entity *parent;\n\n  BITCODE_3BD ins_pt;\n  BITCODE_BD scale;\n  BITCODE_BD rotation;\n  BITCODE_BD width_factor;\n  BITCODE_BD oblique;\n  BITCODE_BD thickness;\n  BITCODE_BS style_id;\n  BITCODE_BE extrusion;\n  BITCODE_H style;\n} Dwg_Entity_SHAPE;\n\n/**\n Struct for:  VIEWPORT ENTITY (34)\n */\n\ntypedef struct _dwg_entity_VIEWPORT\n{\n  struct _dwg_object_entity *parent;\n\n  BITCODE_3BD center;\n  BITCODE_BD width;\n  BITCODE_BD height;\n  BITCODE_RS on_off; /* DXF 68, -1 should be accepted also */\n  BITCODE_RS id;     /* DXF 69 */\n  BITCODE_3BD view_target;\n  BITCODE_3BD view_direction;\n  BITCODE_BD view_twist;\n  BITCODE_BD view_height;\n  BITCODE_BD lens_length;\n  BITCODE_BD front_clip_z;\n  BITCODE_BD back_clip_z;\n  BITCODE_BD snap_angle;\n  BITCODE_2RD view_center;\n  BITCODE_2RD snap_base;\n  BITCODE_2RD snap_spacing;\n  BITCODE_2RD grid_spacing;\n  BITCODE_BS circle_zoom;\n  BITCODE_BS grid_major;\n  BITCODE_BL num_frozen_layers;\n  BITCODE_BL status_flag;\n  BITCODE_TV style_sheet;\n  BITCODE_RC render_mode;\n  BITCODE_B ucs_at_origin;\n  BITCODE_B ucs_per_viewport;\n  BITCODE_3BD ucs_origin;\n  BITCODE_3BD ucs_x_axis;\n  BITCODE_3BD ucs_y_axis;\n  BITCODE_BD ucs_elevation;\n  BITCODE_BS ucs_ortho_view_type;\n  BITCODE_BS shadeplot_mode;\n  BITCODE_B use_default_lights;\n  BITCODE_RC default_lighting_type;\n  BITCODE_BD brightness;\n  BITCODE_BD contrast;\n  BITCODE_CMC ambient_color;\n} Dwg_Entity_VIEWPORT;\n\n/**\n ELLIPSE (35) entity\n */\ntypedef struct _dwg_entity_ELLIPSE\n{\n  struct _dwg_object_entity *parent;\n\n  BITCODE_3BD center;\n  BITCODE_3BD sm_axis;\n  BITCODE_BE extrusion;\n  BITCODE_BD axis_ratio;\n  BITCODE_BD start_angle;\n  BITCODE_BD end_angle;\n} Dwg_Entity_ELLIPSE;\n\n/**\n spline - SPLINE (36) entity\n */\ntypedef struct _dwg_SPLINE_point\n{\n  struct _dwg_entity_SPLINE *parent;\n\n  double x;\n  double y;\n  double z;\n} Dwg_SPLINE_point;\n\ntypedef struct _dwg_SPLINE_control_point\n{\n  struct _dwg_entity_SPLINE *parent;\n\n  double x;\n  double y;\n  double z;\n  double w;\n} Dwg_SPLINE_control_point;\n\ntypedef struct _dwg_entity_SPLINE\n{\n  struct _dwg_object_entity *parent;\n\n  BITCODE_RS flag; /* computed */\n  BITCODE_BS scenario; /* 1 spline, 2 bezier */\n  BITCODE_BS degree;\n  BITCODE_BL splineflags1; /* 2013+: method fit points = 1, CV frame show = 2, closed = 4 */\n  BITCODE_BL knotparam;    /* 2013+: Chord = 0, Square root = 1, Uniform = 2, Custom = 15 */\n  BITCODE_BD fit_tol;\n  BITCODE_3BD beg_tan_vec;\n  BITCODE_3BD end_tan_vec;\n  BITCODE_B closed_b; /* bit 1 of 70 */\n  BITCODE_B periodic; /* bit 2 of 70 */\n  BITCODE_B rational; /* bit 3 of 70 */\n  BITCODE_B weighted; /* bit 4 of 70 */\n  BITCODE_BD knot_tol;\n  BITCODE_BD ctrl_tol;\n  BITCODE_BS num_fit_pts;\n  Dwg_SPLINE_point* fit_pts;\n  BITCODE_BL num_knots;\n  BITCODE_BD* knots;\n  BITCODE_BL num_ctrl_pts;\n  Dwg_SPLINE_control_point* ctrl_pts;\n} Dwg_Entity_SPLINE;\n\n/**\n 3DSOLID (38) entity\n */\n#define Dwg_Entity_3DSOLID Dwg_Entity__3DSOLID\ntypedef struct _dwg_3DSOLID_wire\n{\n  struct _dwg_entity_3DSOLID *parent;\n  BITCODE_RC type;\n  BITCODE_BL selection_marker;\n  BITCODE_BS color;\n  BITCODE_BL acis_index;\n  BITCODE_BL num_points;\n  BITCODE_3BD* points;\n  BITCODE_B transform_present;\n  BITCODE_3BD axis_x;\n  BITCODE_3BD axis_y;\n  BITCODE_3BD axis_z;\n  BITCODE_3BD translation;\n  BITCODE_BD scale;\n  BITCODE_B has_rotation;\n  BITCODE_B has_reflection;\n  BITCODE_B has_shear;\n} Dwg_3DSOLID_wire;\n\ntypedef struct _dwg_3DSOLID_silhouette\n{\n  struct _dwg_entity_3DSOLID *parent;\n  BITCODE_BL vp_id;\n  BITCODE_3BD vp_target;\n  BITCODE_3BD vp_dir_from_target;\n  BITCODE_3BD vp_up_dir;\n  BITCODE_B vp_perspective;\n  BITCODE_BL num_wires;\n  Dwg_3DSOLID_wire * wires;\n} Dwg_3DSOLID_silhouette;\n\n#define _3DSOLID_FIELDS \\\n  BITCODE_B acis_empty; \\\n  BITCODE_B unknown; \\\n  BITCODE_BS version; \\\n  BITCODE_BL num_blocks; \\\n  BITCODE_BL* block_size; \\\n  char     ** encr_sat_data; \\\n  BITCODE_RC* acis_data; \\\n  BITCODE_B wireframe_data_present; \\\n  BITCODE_B point_present; \\\n  BITCODE_3BD point; \\\n  BITCODE_BL num_isolines; \\\n  BITCODE_B isoline_present; \\\n  BITCODE_BL num_wires; \\\n  Dwg_3DSOLID_wire * wires; \\\n  BITCODE_BL num_silhouettes; \\\n  Dwg_3DSOLID_silhouette * silhouettes; \\\n  BITCODE_B acis_empty2; \\\n  struct _dwg_entity_3DSOLID* extra_acis_data; \\\n  BITCODE_BL unknown_2007; \\\n  BITCODE_H history_id; \\\n  BITCODE_B acis_empty_bit\n\ntypedef struct _dwg_entity_3DSOLID\n{\n  struct _dwg_object_entity *parent;\n  _3DSOLID_FIELDS;\n#if 0\n  BITCODE_B acis_empty;  /*!< no DXF */\n  BITCODE_B unknown;\n  BITCODE_BS version;    /*!< DXF 70 Modeler format version =1*/\n  BITCODE_BL num_blocks;\n  BITCODE_BL* block_size;\n  BITCODE_RC** encr_sat_data; /*!< DXF 1, the encrypted SAT data */\n  BITCODE_RC*  acis_data;     /*!< decrypted SAT data */\n  BITCODE_B wireframe_data_present;\n  BITCODE_B point_present;\n  BITCODE_3BD point;\n  BITCODE_BL num_isolines;\n  BITCODE_B isoline_present;\n  BITCODE_BL num_wires;\n  Dwg_3DSOLID_wire * wires;\n  BITCODE_BL num_silhouettes;\n  Dwg_3DSOLID_silhouette * silhouettes;\n  BITCODE_B acis_empty2;\n  struct _dwg_entity_3DSOLID* extra_acis_data;/* is it the best approach? */\n  BITCODE_BL unknown_2007;\n  BITCODE_H history_id;\n  BITCODE_B acis_empty_bit;\n#endif\n} Dwg_Entity__3DSOLID;\n\n/**\n REGION (37) entity\n */\ntypedef Dwg_Entity__3DSOLID Dwg_Entity_REGION;\n\n/**\n BODY (39) entity\n */\ntypedef Dwg_Entity__3DSOLID Dwg_Entity_BODY;\n\n/**\n ray - RAY (40) entity\n */\ntypedef struct _dwg_entity_RAY\n{\n  struct _dwg_object_entity *parent;\n\n  BITCODE_3BD point;   /*!< DXF 10 */\n  BITCODE_3BD vector;  /*!< DXF 11 */\n} Dwg_Entity_RAY;\n\n/**\n XLINE (41) entity\n */\ntypedef Dwg_Entity_RAY Dwg_Entity_XLINE;\n\n/**\n DICTIONARY (42)\n This structure is used for all the new tables.\n Beware: Keep same offsets as DICTIONARYWDFLT\n */\ntypedef struct _dwg_object_DICTIONARY\n{\n  struct _dwg_object_object *parent;\n\n  BITCODE_BL numitems;    /*!< no DXF */\n  BITCODE_BS cloning;     /*!< DXF 281 */\n  BITCODE_RC hard_owner;  /*!< DXF 330 */\n  BITCODE_TV* texts;      /*!< DXF 3 */\n  BITCODE_H* itemhandles; /*!< DXF 350/360, pairwise with texts */\n\n  BITCODE_RC cloning_r14; /*!< r14 only */\n} Dwg_Object_DICTIONARY;\n\n/**\n OLEFRAME (43) entity\n (replaced by OLE2FRAME (74) later)\n */\ntypedef struct _dwg_entity_OLEFRAME\n{\n  struct _dwg_object_entity *parent;\n\n  BITCODE_BS flag;\n  BITCODE_BS mode;\n  BITCODE_BL data_length;\n  char     * data;\n} Dwg_Entity_OLEFRAME;\n\n/**\n MTEXT (44) entity\n */\ntypedef struct _dwg_entity_MTEXT\n{\n  struct _dwg_object_entity *parent;\n\n  BITCODE_3BD insertion_pt;/*!< DXF 10 */\n  BITCODE_BE extrusion;   /*!< DXF 210 */\n  BITCODE_3BD x_axis_dir;  /*!< DXF 1 */\n  BITCODE_BD rect_height;  /*!< no DXF */\n  BITCODE_BD rect_width;   /*!< DXF 41 */\n  BITCODE_BD text_height;  /*!< DXF 40 */\n  BITCODE_BS attachment;   /*!< DXF 71.\n                             1 = Top left, 2 = Top center, 3 = Top\n                             right, 4 = Middle left, 5 = Middle\n                             center, 6 = Middle right, 7 = Bottom\n                             left, 8 = Bottom center, 9 = Bottom\n                             right */\n  BITCODE_BS drawing_dir;  /*!< DXF 72.\n                            1 = Left to right, 3 = Top to bottom,\n                            5 = By style (the flow direction is inherited\n                            from the associated text style) */\n  BITCODE_BD extents_height; /*!< DXF 42 */\n  BITCODE_BD extents_width;  /*!< DXF 43 */\n  BITCODE_TV text;           /*!< DXF 1 */\n  BITCODE_H style;           /*!< DXF 7 */\n  BITCODE_BS linespace_style; /*!< DXF 73. r2000+ */\n  BITCODE_BD linespace_factor;/*!< DXF 44. r2000+. Mtext line spacing factor (optional):\n                               Percentage of default (3-on-5) line spacing to\n                               be applied. Valid values range from 0.25 to 4.00 */\n  BITCODE_B unknown_bit;\n  BITCODE_BL bg_fill_flag;   /*!< DXF 90. r2004+\n                               0 = Background fill off,\n                               1 = Use background fill color,\n                               2 = Use drawing window color as background fill color. */\n  BITCODE_BL bg_fill_scale;  /*!< DXF 45. r2004+\n                               margin around the text. */\n  BITCODE_CMC bg_fill_color; /*!< DXF 63. r2004+. on bg_fill_flag==1 */\n  BITCODE_BL bg_fill_trans;  /*!< DXF 441. r2004+. unused */\n  BITCODE_B annotative;      /*!< r2018+: */\n  BITCODE_BS class_version;\n  BITCODE_B default_flag;\n  BITCODE_H appid;\n  BITCODE_BL column_type;    /*!< DXF 75 */\n  BITCODE_BD column_width;   /*!< DXF 48 */\n  BITCODE_BD gutter;         /*!< DXF 49 */\n  BITCODE_B auto_height;     /*!< DXF 79 */\n  BITCODE_B flow_reversed;   /*!< DXF 74 */\n  BITCODE_BL num_column_heights;/*!< DXF 76 */\n  BITCODE_BD *column_heights;/*!< DXF 50 */\n} Dwg_Entity_MTEXT;\n\n/**\n LEADER (45) entity\n */\ntypedef struct _dwg_entity_LEADER\n{\n  struct _dwg_object_entity *parent;\n\n  BITCODE_B unknown_bit_1;  /* always seems to be zero */\n  BITCODE_BS path_type;     /*< DXF(72) 0: line, 1: spline (oda bug) */\n  BITCODE_BS annot_type;    /*< DXF(73) 0: text, 1: tol, 2: insert, 3 (def): none */\n  BITCODE_BL num_points;    /*< DXF(76) */\n  BITCODE_3DPOINT* points;\n  BITCODE_3DPOINT origin;\n  BITCODE_BE extrusion;\n  BITCODE_3DPOINT x_direction;\n  BITCODE_3DPOINT offset_to_block_ins_pt;\n  BITCODE_3DPOINT endptproj; /* R_14-R_2007 ? */\n  BITCODE_BD dimgap;         /* R_13-R_14 only */\n  BITCODE_BD box_height;\n  BITCODE_BD box_width;\n  BITCODE_B hookline_dir;\n  BITCODE_B arrowhead_on;\n  BITCODE_BS arrowhead_type;\n  BITCODE_BD dimasz;\n  BITCODE_B unknown_bit_2;\n  BITCODE_B unknown_bit_3;\n  BITCODE_BS unknown_short_1;\n  BITCODE_BS byblock_color;\n  BITCODE_B hookline_on;\n  BITCODE_B unknown_bit_5;\n  BITCODE_H associated_annotation; /* DXF 340 Hard reference to associated annotation (mtext, tolerance, or insert entity) */\n  BITCODE_H dimstyle;\n} Dwg_Entity_LEADER;\n\n/**\n TOLERANCE (46) entity\n */\ntypedef struct _dwg_entity_TOLERANCE\n{\n  struct _dwg_object_entity *parent;\n\n  BITCODE_BS unknown_short;\n  BITCODE_BD height;\n  BITCODE_BD dimgap;\n  BITCODE_3BD ins_pt;\n  BITCODE_3BD x_direction;\n  BITCODE_BE extrusion;\n  BITCODE_TV text_string;\n  BITCODE_H dimstyle;\n} Dwg_Entity_TOLERANCE;\n\n/**\n MLINE (47) entity\n */\ntypedef struct _dwg_MLINE_line\n{\n  struct _dwg_MLINE_vertex *parent;\n  BITCODE_BS num_segparms;\n  BITCODE_BD * segparms;\n  BITCODE_BS num_areafillparms;\n  BITCODE_BD* areafillparms;\n} Dwg_MLINE_line;\n\ntypedef struct _dwg_MLINE_vertex\n{\n  struct _dwg_entity_MLINE *parent;\n  BITCODE_3BD vertex;\n  BITCODE_3BD vertex_direction;\n  BITCODE_3BD miter_direction;\n  BITCODE_RC num_lines;\n  Dwg_MLINE_line* lines;\n} Dwg_MLINE_vertex;\n\ntypedef struct _dwg_entity_MLINE\n{\n  struct _dwg_object_entity *parent;\n\n  BITCODE_BD scale;\n  BITCODE_RC justification;\n  BITCODE_3BD base_point;\n  BITCODE_BE extrusion;\n  BITCODE_BS flags;\n  BITCODE_RC num_lines; /* Linesinstyle */\n  BITCODE_BS num_verts;\n  Dwg_MLINE_vertex* verts;\n  BITCODE_H mlinestyle;\n} Dwg_Entity_MLINE;\n\n#define COMMON_TABLE_CONTROL_FIELDS \\\n  struct _dwg_object_object *parent; \\\n  BITCODE_BS num_entries; \\\n  BITCODE_H* entries; \\\n  BITCODE_BL objid\n\n// not for LAYER!\n#define COMMON_TABLE_FIELDS() \\\n  struct _dwg_object_object *parent; \\\n  BITCODE_RC flag; \\\n  BITCODE_TV name; \\\n  BITCODE_RS used; \\\n  BITCODE_B xrefref; \\\n  BITCODE_BS xrefindex_plus1; \\\n  BITCODE_B xrefdep\n\n/**\n BLOCK_CONTROL (48) object, table header\n */\ntypedef struct _dwg_object_BLOCK_CONTROL\n{\n  COMMON_TABLE_CONTROL_FIELDS;\n  BITCODE_H model_space;\n  BITCODE_H paper_space;\n} Dwg_Object_BLOCK_CONTROL;\n\n/**\n BLOCK_HEADER (49) object, table entry\n */\ntypedef struct _dwg_object_BLOCK_HEADER\n{\n  COMMON_TABLE_FIELDS();\n  BITCODE_BL __iterator;\n  BITCODE_RC flag2; /* preR13 */\n  BITCODE_RS flag3; /* preR13 */\n  BITCODE_B anonymous;    /* flag 70 bit 1 */\n  BITCODE_B hasattrs;     /* flag 70 bit 2 */\n  BITCODE_B blkisxref;    /* flag 70 bit 3 */\n  BITCODE_B xrefoverlaid; /* flag 70 bit 4 */\n  BITCODE_B loaded_bit;   /* flag 70 bit 6 */\n  BITCODE_BL num_owned;\n  BITCODE_3DPOINT base_pt;\n  BITCODE_TV xref_pname;\n  BITCODE_RL num_inserts;\n  BITCODE_TV description;\n  BITCODE_BL preview_data_size; /* no DXF, BLL? */\n  char     * preview_data;      /* DXF 310 */\n  BITCODE_BS insert_units;\n  BITCODE_B explodable;\n  BITCODE_RC block_scaling;\n  BITCODE_H null_handle;\n  BITCODE_H block_entity;\n  BITCODE_H first_entity;\n  BITCODE_H last_entity;\n  BITCODE_H* entities;\n  BITCODE_H endblk_entity;\n  BITCODE_H* inserts;\n  BITCODE_H layout;\n} Dwg_Object_BLOCK_HEADER;\n\n/**\n LAYER_CONTROL (50) object, table header\n */\ntypedef struct _dwg_object_LAYER_CONTROL\n{\n  COMMON_TABLE_CONTROL_FIELDS;\n} Dwg_Object_LAYER_CONTROL;\n\n/**\n LAYER (51) object, table entry\n */\ntypedef struct _dwg_object_LAYER\n{\n  struct _dwg_object_object *parent;\n  BITCODE_BS flag;\n  BITCODE_TV name;\n  BITCODE_RS used; /* preR13 */\n  BITCODE_B xrefref;\n  BITCODE_BS xrefindex_plus1;\n  BITCODE_B xrefdep;\n\n  BITCODE_B frozen;\n  BITCODE_B on;\n  BITCODE_B frozen_in_new;\n  BITCODE_B locked;\n  BITCODE_B plotflag;\n  BITCODE_RC linewt;\n  //BITCODE_BS flag_s;\n  BITCODE_CMC color;\n  short      color_rs;    /* preR13, needs to be signed */\n  BITCODE_RS ltype_rs;    /* preR13 */\n  BITCODE_H xref;\n  BITCODE_H plotstyle;\n  BITCODE_H material;\n  BITCODE_H ltype;\n} Dwg_Object_LAYER;\n\n/**\n STYLE_CONTROL (52) object, table header\n */\ntypedef struct _dwg_object_STYLE_CONTROL\n{\n  COMMON_TABLE_CONTROL_FIELDS;\n} Dwg_Object_STYLE_CONTROL;\n\n/**\n STYLE (53) object, table entry.\n Textstyle. Some call it SHAPEFILE.\n */\ntypedef struct _dwg_object_STYLE\n{\n  COMMON_TABLE_FIELDS();\n  BITCODE_B vertical;\n  BITCODE_B shape_file;\n  BITCODE_BD fixed_height;\n  BITCODE_BD width_factor;\n  BITCODE_BD oblique_ang;\n  BITCODE_RC generation;\n  BITCODE_BD last_height;\n  BITCODE_TV font_name;\n  BITCODE_TV bigfont_name;\n  BITCODE_H extref;\n} Dwg_Object_STYLE;\n\n/* 54 and 55 are UNKNOWN OBJECTS */\n\n/**\n LTYPE_CONTROL (56) object, table header\n */\ntypedef struct _dwg_object_LTYPE_CONTROL\n{\n  COMMON_TABLE_CONTROL_FIELDS;\n  BITCODE_H bylayer;\n  BITCODE_H byblock;\n} Dwg_Object_LTYPE_CONTROL;\n\n/**\n LTYPE (57) object, table entry\n */\n\ntypedef struct _dwg_LTYPE_dash {\n  struct _dwg_object_LTYPE *parent;\n  BITCODE_BD length;\n  BITCODE_BS complex_shapecode;\n  BITCODE_RD x_offset;\n  BITCODE_RD y_offset;\n  BITCODE_BD scale;\n  BITCODE_BD rotation;\n  BITCODE_BS shape_flag;\n} Dwg_LTYPE_dash;\n\ntypedef struct _dwg_object_LTYPE\n{\n  COMMON_TABLE_FIELDS();\n  BITCODE_TV description;\n  BITCODE_BD pattern_len;\n  BITCODE_RC alignment;\n  BITCODE_RC num_dashes;\n  Dwg_LTYPE_dash* dashes;\n  BITCODE_RD* dashes_r11;\n  BITCODE_B text_area_is_present; /* if some shape_flag & 2 */\n  char    * strings_area;\n  BITCODE_H extref_handle;\n  BITCODE_H* styles;\n} Dwg_Object_LTYPE;\n\n/* 58 and 59 are UNKNOWN OBJECTS */\n\n/**\n VIEW_CONTROL (60) object, table header\n */\ntypedef struct _dwg_object_VIEW_CONTROL\n{\n  COMMON_TABLE_CONTROL_FIELDS;\n} Dwg_Object_VIEW_CONTROL;\n\n/**\n VIEW (61) object, table entry\n */\ntypedef struct _dwg_object_VIEW\n{\n  COMMON_TABLE_FIELDS();\n  BITCODE_BD height;\n  BITCODE_BD width;\n  BITCODE_2RD center;\n  BITCODE_3BD target;\n  BITCODE_3BD direction;\n  BITCODE_BD twist_angle;\n  BITCODE_BD lens_length;\n  BITCODE_BD front_clip;\n  BITCODE_BD back_clip;\n  BITCODE_4BITS VIEWMODE;\n  BITCODE_RC render_mode;\n  BITCODE_B use_default_lights;\n  BITCODE_RC default_lightning_type;\n  BITCODE_BD brightness;\n  BITCODE_BD contrast;\n  BITCODE_CMC ambient_color;\n  BITCODE_B pspace_flag;\n  BITCODE_B associated_ucs;\n  BITCODE_3BD origin;\n  BITCODE_3BD x_direction;\n  BITCODE_3BD y_direction;\n  BITCODE_BD elevation;\n  BITCODE_BS orthographic_view_type;\n  BITCODE_B camera_plottable;\n  BITCODE_H null_handle;\n  BITCODE_H background;\n  BITCODE_H visualstyle;\n  BITCODE_H sun;\n  BITCODE_H base_ucs;\n  BITCODE_H named_ucs;\n  BITCODE_H livesection;\n} Dwg_Object_VIEW;\n\n/**\n UCS_CONTROL (62) object, table header\n */\ntypedef struct _dwg_object_UCS_CONTROL\n{\n  COMMON_TABLE_CONTROL_FIELDS;\n} Dwg_Object_UCS_CONTROL;\n\n/**\n UCS (63) object, table entry\n */\ntypedef struct _dwg_object_UCS\n{\n  COMMON_TABLE_FIELDS();\n  BITCODE_3BD origin;\n  BITCODE_3BD x_direction;\n  BITCODE_3BD y_direction;\n  BITCODE_BD elevation;\n  BITCODE_BS orthographic_view_type;\n  BITCODE_BS orthographic_type;\n  BITCODE_H null_handle;\n  BITCODE_H base_ucs;  /*! DXF 346 */\n  BITCODE_H named_ucs; /*! DXF 345 */\n} Dwg_Object_UCS;\n\n/**\n VPORT_CONTROL (64) object, table header\n */\ntypedef struct _dwg_object_VPORT_CONTROL\n{\n  COMMON_TABLE_CONTROL_FIELDS;\n} Dwg_Object_VPORT_CONTROL;\n\n/**\n VPORT (65) object, table entry\n */\ntypedef struct _dwg_object_VPORT\n{\n  COMMON_TABLE_FIELDS();\n  BITCODE_BD VIEWSIZE;  // really the view height\n  BITCODE_BD viewwidth; // in DWG r13+, needed to calc. aspect_ratio\n  BITCODE_BD aspect_ratio; // DXF 41 = viewwidth / VIEWSIZE\n  BITCODE_2RD VIEWCTR;\n  BITCODE_3BD view_target;\n  BITCODE_3BD VIEWDIR;\n  BITCODE_BD view_twist;\n  BITCODE_BD lens_length;\n  BITCODE_BD front_clip;\n  BITCODE_BD back_clip;\n  BITCODE_4BITS VIEWMODE;\n  BITCODE_RC render_mode;\n  BITCODE_B use_default_lights;\n  BITCODE_RC default_lightning_type;\n  BITCODE_BD brightness;\n  BITCODE_BD contrast;\n  BITCODE_CMC ambient_color;\n  BITCODE_2RD lower_left;\n  BITCODE_2RD upper_right;\n  BITCODE_B UCSFOLLOW;\n  BITCODE_BS circle_zoom; /* circle sides: nr of tesselations */\n  BITCODE_B FASTZOOM;\n  BITCODE_RC UCSICON;\n  BITCODE_B GRIDMODE;\n  BITCODE_2RD GRIDUNIT;\n  BITCODE_B SNAPMODE;\n  BITCODE_B SNAPSTYLE;\n  BITCODE_BS SNAPISOPAIR;\n  BITCODE_BD SNAPANG;\n  BITCODE_2RD SNAPBASE;\n  BITCODE_2RD SNAPUNIT;\n  BITCODE_B unknown;\n  BITCODE_B UCSVP;          /*!< DXF 65 */\n  BITCODE_3BD ucs_origin;\n  BITCODE_3BD ucs_x_axis;\n  BITCODE_3BD ucs_y_axis;\n  BITCODE_BD ucs_elevation;\n  BITCODE_BS ucs_orthografic_type;\n  BITCODE_BS grid_flags;\n  BITCODE_BS grid_major;\n  BITCODE_H null_handle;\n  BITCODE_H background;\n  BITCODE_H visualstyle;\n  BITCODE_H sun;\n  BITCODE_H named_ucs;\n  BITCODE_H base_ucs;\n} Dwg_Object_VPORT;\n\n/**\n APPID_CONTROL (66) object\n The table header of all registered applications\n */\ntypedef struct _dwg_object_APPID_CONTROL\n{\n  COMMON_TABLE_CONTROL_FIELDS;\n} Dwg_Object_APPID_CONTROL;\n\n/**\n APPID (67) object\n The table entry of a registered application\n */\ntypedef struct _dwg_object_APPID\n{\n  COMMON_TABLE_FIELDS();\n  BITCODE_RC unknown;\n  BITCODE_H null_handle;\n} Dwg_Object_APPID;\n\n/**\n DIMSTYLE_CONTROL (68) object\n The table header of all dimension styles\n */\ntypedef struct _dwg_object_DIMSTYLE_CONTROL\n{\n  COMMON_TABLE_CONTROL_FIELDS;\n  BITCODE_RC num_morehandles; /* DXF 71 undocumented */\n  BITCODE_H* morehandles;     /* DXF 340 */\n} Dwg_Object_DIMSTYLE_CONTROL;\n\n/**\n DIMSTYLE (69) object, table entry\n */\ntypedef struct _dwg_object_DIMSTYLE\n{\n  COMMON_TABLE_FIELDS();\n  BITCODE_B DIMTOL;\n  BITCODE_B DIMLIM;\n  BITCODE_B DIMTIH;\n  BITCODE_B DIMTOH;\n  BITCODE_B DIMSE1;\n  BITCODE_B DIMSE2;\n  BITCODE_B DIMALT;\n  BITCODE_B DIMTOFL;\n  BITCODE_B DIMSAH;\n  BITCODE_B DIMTIX;\n  BITCODE_B DIMSOXD;\n  BITCODE_BS DIMALTD;   /*!< r13-r14 only RC */\n  BITCODE_BS DIMZIN;    /*!< r13-r14 only RC */\n  BITCODE_B DIMSD1;\n  BITCODE_B DIMSD2;\n  BITCODE_BS DIMTOLJ;   /*!< r13-r14 only RC */\n  BITCODE_BS DIMJUST;   /*!< r13-r14 only RC */\n  BITCODE_BS DIMFIT;    /*!< r13-r14 only RC */\n  BITCODE_B DIMUPT;\n  BITCODE_BS DIMTZIN;   /*!< r13-r14 only RC */\n  BITCODE_BS DIMMALTZ;  /*!< r13-r14 only RC */\n  BITCODE_BS DIMMALTTZ; /*!< r13-r14 only RC */\n  BITCODE_BS DIMTAD;    /*!< r13-r14 only RC */\n  BITCODE_BS DIMUNIT;\n  BITCODE_BS DIMAUNIT;\n  BITCODE_BS DIMDEC;\n  BITCODE_BS DIMTDEC;\n  BITCODE_BS DIMALTU;\n  BITCODE_BS DIMALTTD;\n  /* BITCODE_H DIMTXSTY; */\n  BITCODE_BD DIMSCALE;\n  BITCODE_BD DIMASZ;\n  BITCODE_BD DIMEXO;\n  BITCODE_BD DIMDLI;\n  BITCODE_BD DIMEXE;\n  BITCODE_BD DIMRND;\n  BITCODE_BD DIMDLE;\n  BITCODE_BD DIMTP;\n  BITCODE_BD DIMTM;\n  BITCODE_BD DIMFXL;\n  BITCODE_BD DIMJOGANG;\n  BITCODE_BS DIMTFILL;\n  BITCODE_CMC DIMTFILLCLR;\n  BITCODE_BS DIMAZIN;\n  BITCODE_BS DIMARCSYM;\n  BITCODE_BD DIMTXT;\n  BITCODE_BD DIMCEN;\n  BITCODE_BD DIMTSZ;\n  BITCODE_BD DIMALTF;\n  BITCODE_BD DIMLFAC;\n  BITCODE_BD DIMTVP;\n  BITCODE_BD DIMTFAC;\n  BITCODE_BD DIMGAP;\n  BITCODE_T DIMPOST;\n  BITCODE_T DIMAPOST;\n  BITCODE_T DIMBLK_T;\n  BITCODE_T DIMBLK1_T;\n  BITCODE_T DIMBLK2_T;\n  BITCODE_BD DIMALTRND;\n  BITCODE_RS DIMCLRD_N; /* preR13 */\n  BITCODE_RS DIMCLRE_N; /* preR13 */\n  BITCODE_RS DIMCLRT_N; /* preR13 */\n  BITCODE_CMC DIMCLRD;\n  BITCODE_CMC DIMCLRE;\n  BITCODE_CMC DIMCLRT;\n  BITCODE_BS DIMADEC;\n  BITCODE_BS DIMFRAC;\n  BITCODE_BS DIMLUNIT;\n  BITCODE_BS DIMDSEP;\n  BITCODE_BS DIMTMOVE;\n  BITCODE_BS DIMALTZ;\n  BITCODE_BS DIMALTTZ;\n  BITCODE_BS DIMATFIT;\n  BITCODE_B DIMFXLON;   /*!< r2007+ */\n  BITCODE_B  DIMTXTDIRECTION; /*!< r2010+ */\n  BITCODE_BD DIMALTMZF; /*!< r2010+ */\n  BITCODE_T  DIMALTMZS; /*!< r2010+ */\n  BITCODE_BD DIMMZF;    /*!< r2010+ */\n  BITCODE_T  DIMMZS;    /*!< r2010+ */\n  BITCODE_BSd DIMLWD;\n  BITCODE_BSd DIMLWE;\n\n  BITCODE_H extref_handle;\n  BITCODE_H DIMTXSTY;\n\n  BITCODE_H DIMLDRBLK;\n  BITCODE_H DIMBLK;\n  BITCODE_H DIMBLK1;\n  BITCODE_H DIMBLK2;\n\n  BITCODE_H DIMLTYPE;\n  BITCODE_H DIMLTEX1;\n  BITCODE_H DIMLTEX2;\n} Dwg_Object_DIMSTYLE;\n\n/**\n VPORT_ENTITY_CONTROL (70) table object (r11-r2000)\n The table header of all vport entities (unused in newer versions)\n */\ntypedef struct _dwg_object_VPORT_ENTITY_CONTROL\n{\n  COMMON_TABLE_CONTROL_FIELDS;\n} Dwg_Object_VPORT_ENTITY_CONTROL;\n\n/**\n VPORT_ENTITY_HEADER (71) table object (r11-r2000)\n */\ntypedef struct _dwg_object_VPORT_ENTITY_HEADER\n{\n  COMMON_TABLE_FIELDS();\n  BITCODE_B flag1;\n  BITCODE_H xref_handle;\n  BITCODE_H vport_entity;\n} Dwg_Object_VPORT_ENTITY_HEADER;\n\n/**\n GROUP (72) object\n */\ntypedef struct _dwg_object_GROUP\n{\n  struct _dwg_object_object *parent;\n  BITCODE_TV name;\n  BITCODE_BS unnamed;\n  BITCODE_BS selectable;\n  BITCODE_BL num_groups;\n  BITCODE_H* groups;\n} Dwg_Object_GROUP;\n\n/**\n MLINESTYLE (73) object\n */\ntypedef struct _dwg_MLINESTYLE_line\n{\n  struct _dwg_object_MLINESTYLE *parent;\n  BITCODE_BD offset;\n  BITCODE_CMC color;\n  union {\n    BITCODE_BSd index;   /* until 2018 */\n    BITCODE_H ltype;     /* since 2018 */\n  } lt;\n} Dwg_MLINESTYLE_line;\n\ntypedef struct _dwg_object_MLINESTYLE\n{\n  struct _dwg_object_object *parent;\n  BITCODE_TV name;\n  BITCODE_TV desc;\n  BITCODE_BS flag;\n  BITCODE_CMC fill_color;\n  BITCODE_BD start_angle;\n  BITCODE_BD end_angle;\n  BITCODE_RC num_lines;\n  Dwg_MLINESTYLE_line* lines;\n} Dwg_Object_MLINESTYLE;\n\n/**\n OLE2FRAME (74 + varies) object\n */\ntypedef struct _dwg_entity_OLE2FRAME\n{\n  struct _dwg_object_entity *parent;\n\n  BITCODE_BS type;         /*!< DXF 71, 1: Link, 2: Embedded, 3: Static */\n  BITCODE_BS mode;         /*!< r2000+ DXF 72, tile_mode, 0: mspace, 1: pspace */\n  BITCODE_RC lock_aspect;  /*!< r2000+ DXF 73, 0 or 1 (locked) */\n  BITCODE_BL data_length;  /*!< DXF 90 */\n  char     * data;         /*!< DXF 310, the binary object data */\n  // embedded into data, not yet decoded:\n  // the MS-CFB (ole2 stream) starts at 0x80 in data\n  // before is probably:\n  BITCODE_BS oleversion;   /*!< DXF 70, always 2 */\n  char     * oleclient;    /*!< DXF 3, e.g. OLE or Paintbrush Picture */\n  BITCODE_3BD pt1;         /*!< DXF 10, upper left corner */\n  BITCODE_3BD pt2;         /*!< DXF 11, lower right corner */\n} Dwg_Entity_OLE2FRAME;\n\n/**\n DUMMY (75) object\n */\ntypedef struct _dwg_object_DUMMY\n{\n  struct _dwg_object_object *parent;\n  /* ??? not seen */\n} Dwg_Object_DUMMY;\n\n/**\n LONG_TRANSACTION (76) object\n */\ntypedef struct _dwg_object_LONG_TRANSACTION\n{\n  struct _dwg_object_object *parent;\n  /* ??? not seen */\n} Dwg_Object_LONG_TRANSACTION;\n\n/* NOT SURE ABOUT THIS ONE (IS IT OBJECT OR ENTITY?): */\n/**\n subtype PROXY_LWPOLYLINE (33) in a PROXY object\n Not a LWPOLYLINE (77? + varies)\n */\ntypedef struct _dwg_LWPOLYLINE_width\n{\n  BITCODE_BD start; /* 40 */\n  BITCODE_BD end;   /* 41 */\n} Dwg_LWPOLYLINE_width;\n\ntypedef struct _dwg_entity_PROXY_LWPOLYLINE\n{\n  struct _dwg_object_entity *parent;\n\n  BITCODE_RL size; /* from flags to *widths */\n  BITCODE_BS flags;\n  BITCODE_BD const_width;\n  BITCODE_BD elevation;\n  BITCODE_BD thickness;\n  BITCODE_BE extrusion;\n  BITCODE_BL num_points;\n  BITCODE_2RD* points;\n  BITCODE_BL num_bulges;\n  BITCODE_BD* bulges;\n  BITCODE_BL num_widths;\n  Dwg_LWPOLYLINE_width* widths;\n  BITCODE_RC unknown_1;\n  BITCODE_RC unknown_2;\n  BITCODE_RC unknown_3;\n} Dwg_Entity_PROXY_LWPOLYLINE;\n\n/**\n PROXY_ENTITY (498, 0x1f2) object\n */\ntypedef struct _dwg_entity_PROXY_ENTITY\n{\n  struct _dwg_object_entity *parent;\n\n  BITCODE_BL class_id;      /*!< DXF 91 */\n  BITCODE_BL version;       /*!< DXF 95 <r2018, 71 r2018+ */\n  BITCODE_BL maint_version; /*!< DXF 97 r2018+ */\n  BITCODE_B from_dxf;       /*!< DXF 70 */\n  char    * data;\n  BITCODE_H* objid_object_handles;\n  BITCODE_MS size;\n} Dwg_Entity_PROXY_ENTITY;\n\n/**\n PROXY OBJECT (499, 0x1f3) object\n */\ntypedef struct _dwg_object_PROXY_OBJECT\n{\n  struct _dwg_object_object *parent;\n\n  BITCODE_BL class_id;\n  BITCODE_BL version;\n  BITCODE_BL maint_version;\n  BITCODE_B from_dxf;\n  char    * data;\n  BITCODE_H* objid_object_handles;\n} Dwg_Object_PROXY_OBJECT;\n\n/**\n * types which are fixed and non-fixed:\n * also OLE2FRAME above\n */\n\n/**\n Structs for HATCH (78 + varies)\n */\ntypedef struct _dwg_HATCH_Color\n{\n  struct _dwg_entity_HATCH *parent;\n  BITCODE_BD shift_value; //0.0 non-shifted, 1.0 shifted\n  BITCODE_CMC color;\n} Dwg_HATCH_Color;\n\ntypedef struct _dwg_HATCH_ControlPoint\n{\n  struct _dwg_HATCH_PathSeg *parent;\n  BITCODE_2RD point;\n  BITCODE_BD weight;\n} Dwg_HATCH_ControlPoint;\n\ntypedef struct _dwg_HATCH_PathSeg\n{\n  struct _dwg_HATCH_Path *parent;\n  BITCODE_RC type_status;\n  /* LINE */\n  BITCODE_2RD first_endpoint;\n  BITCODE_2RD second_endpoint;\n  /* CIRCULAR ARC */\n  BITCODE_2RD center;\n  BITCODE_BD radius;\n  BITCODE_BD start_angle;\n  BITCODE_BD end_angle;\n  BITCODE_B is_ccw;\n  /* ELLIPTICAL ARC */\n  /* BITCODE_2RD center */\n  BITCODE_2RD endpoint;\n  BITCODE_BD minor_major_ratio;\n  /* BITCODE_BD start_angle; */\n  /* BITCODE_BD end_angle; */\n  /* BITCODE_B is_ccw; */\n  /* SPLINE */\n  BITCODE_BL degree;\n  BITCODE_B is_rational;\n  BITCODE_B is_periodic;\n  BITCODE_BL num_knots;\n  BITCODE_BL num_control_points;\n  BITCODE_BD* knots;\n  Dwg_HATCH_ControlPoint* control_points;\n  BITCODE_BL num_fitpts;\n  BITCODE_2RD *fitpts;\n  BITCODE_2RD start_tangent;\n  BITCODE_2RD end_tangent;\n} Dwg_HATCH_PathSeg;\n\ntypedef struct _dwg_HATCH_PolylinePath\n{\n  struct _dwg_HATCH_Path *parent;\n  BITCODE_2RD point;\n  BITCODE_BD bulge;\n} Dwg_HATCH_PolylinePath;\n\ntypedef struct _dwg_HATCH_Path\n{\n  struct _dwg_entity_HATCH *parent;\n  /* Segment path */\n  BITCODE_BL flag;\n  BITCODE_BL num_segs_or_paths;\n  Dwg_HATCH_PathSeg* segs;\n\n  /* Polyline path */\n  BITCODE_B bulges_present;\n  BITCODE_B closed;\n  Dwg_HATCH_PolylinePath* polyline_paths;\n\n  BITCODE_BL num_boundary_handles;\n} Dwg_HATCH_Path;\n\ntypedef struct _dwg_HATCH_DefLine\n{\n  struct _dwg_entity_HATCH *parent;\n  BITCODE_BD  angle;\n  BITCODE_2BD pt0;\n  BITCODE_2BD offset;\n  BITCODE_BS  num_dashes;\n  BITCODE_BD * dashes;\n} Dwg_HATCH_DefLine;\n\ntypedef struct _dwg_entity_HATCH\n{\n  struct _dwg_object_entity *parent;\n\n  BITCODE_BL is_gradient_fill;\n  BITCODE_BL reserved;\n  BITCODE_BD gradient_angle;\n  BITCODE_BD gradient_shift;\n  BITCODE_BL single_color_gradient;\n  BITCODE_BD gradient_tint;\n  BITCODE_BL num_colors;\n  Dwg_HATCH_Color* colors;\n  BITCODE_TV gradient_name;\n  BITCODE_BD elevation;\n  BITCODE_BE extrusion;\n  BITCODE_TV name;\n  BITCODE_B solid_fill;\n  BITCODE_B associative;\n  BITCODE_BL num_paths;\n  Dwg_HATCH_Path* paths;\n  BITCODE_BS style;\n  BITCODE_BS pattern_type;\n  BITCODE_BD angle;\n  BITCODE_BD scale_spacing;\n  BITCODE_B double_flag;\n  BITCODE_BS num_deflines;\n  Dwg_HATCH_DefLine * deflines;\n  BITCODE_B has_derived;\n  BITCODE_BD pixel_size;\n  BITCODE_BL num_seeds;\n  BITCODE_2RD * seeds;\n  BITCODE_BL num_boundary_handles;\n  BITCODE_H* boundary_handles;\n} Dwg_Entity_HATCH;\n\n/**\n XRECORD (79 + varies) object\n */\ntypedef struct _dwg_object_XRECORD\n{\n  struct _dwg_object_object *parent;\n\n  BITCODE_BL num_databytes;\n  BITCODE_BS cloning_flags;\n  BITCODE_BL num_xdata; /* computed */\n  Dwg_Resbuf* xdata;\n  BITCODE_BL num_objid_handles;\n  BITCODE_H* objid_handles;\n} Dwg_Object_XRECORD;\n\n/**\n PLACEHOLDER (80 + varies) object\n ACDBPLACEHOLDER\n */\ntypedef struct _dwg_object_PLACEHOLDER\n{\n  struct _dwg_object_object *parent;\n} Dwg_Object_PLACEHOLDER;\n\n/**\n * Entity MULTILEADER (varies)\n * R2000+ in work\n */\n\ntypedef struct _dwg_LEADER_Break\n{\n  struct _dwg_LEADER_Line *parent;\n  BITCODE_3BD start;         /*!< DXF 12 */\n  BITCODE_3BD end;           /*!< DXF 13 */\n} Dwg_LEADER_Break;\n\ntypedef struct _dwg_LEADER_Line // as documented by DXF\n{\n  struct _dwg_LEADER_Node *parent;\n  BITCODE_BL num_points;\n  BITCODE_3DPOINT* points;         /*!< DXF 10 */\n  BITCODE_BL num_breaks;\n  Dwg_LEADER_Break * breaks;       /*!< DXF 12, 13 */\n  BITCODE_BL  line_index;          /*!< DXF 91 */\n\n  /*!< r2010+: */\n  BITCODE_BS type; // 0 = invisible leader, 1 = straight leader, 2 = spline leader\n  BITCODE_CMC color;\n  BITCODE_H ltype; // 5 340\n  BITCODE_BLd linewt;\n  BITCODE_BD arrow_size;\n  BITCODE_H  arrow_handle; // 5 341\n  BITCODE_BL flags; // 1 = leader type, 2 = line color, 4 = line type, 8 = line weight,\n                    // 16 = arrow size, 32 = arrow symbol (handle)\n} Dwg_LEADER_Line;\n\ntypedef struct _dwg_ODALeader_Line //// as documented by ODA\n{\n  struct _dwg_Leader *parent;\n  BITCODE_BL num_points;\n  BITCODE_3BD * points;\n  BITCODE_BL num_breaks;\n  Dwg_LEADER_Break * breaks;\n  BITCODE_BL segment_index;\n  BITCODE_BL index;\n\n  BITCODE_BS type; // 0 = invisible leader, 1 = straight leader, 2 = spline leader\n  BITCODE_CMC color;\n  BITCODE_H ltype;\n  BITCODE_BLd linewt;\n  BITCODE_BD arrow_size;\n  BITCODE_H arrow_handle;\n  BITCODE_BL flags;\n} Dwg_ODALeader_Line;\n\ntypedef struct _dwg_LEADER_ArrowHead\n{\n  struct _dwg_entity_MULTILEADER *parent;\n  BITCODE_BL is_default;\n  BITCODE_H arrowhead;\n} Dwg_LEADER_ArrowHead;\n\ntypedef struct _dwg_LEADER_BlockLabel\n{\n  struct _dwg_entity_MULTILEADER *parent;\n  BITCODE_H attdef;\n  BITCODE_TV label_text;\n  BITCODE_BS ui_index;\n  BITCODE_BD width;\n} Dwg_LEADER_BlockLabel;\n\n/* as documented in ODA, but contradicting DXF docs, and\n   the reverse-engineered format */\ntypedef struct _dwg_ODALeader\n{\n  struct _dwg_entity_MULTILEADER *parent;\n  BITCODE_B is_valid;\n  BITCODE_B unknown;\n  BITCODE_3BD connection;\n  BITCODE_3BD direction;\n  BITCODE_BL num_breaks;\n  Dwg_LEADER_Break * breaks;\n  BITCODE_BL num_lines;\n  Dwg_LEADER_Line * lines;\n  BITCODE_BL index;\n  BITCODE_BD landing_distance;\n  /* ... */\n  BITCODE_BS attach_dir;\n} Dwg_ODALeader;\n\ntypedef struct _dwg_LEADER_Node\n{\n  struct _dwg_entity_MULTILEADER *parent;\n  BITCODE_B has_lastleaderlinepoint;    /*!< DXF 290 */\n  BITCODE_B has_dogleg;                 /*!< DXF 291 */\n  BITCODE_3BD lastleaderlinepoint;      /*!< DXF 10 */\n  BITCODE_3BD dogleg_vector;            /*!< DXF 11 */\n  BITCODE_BL branch_index;              /*!< DXF 90 */\n  BITCODE_BD dogleg_length;             /*!< DXF 40 */\n  BITCODE_BL num_lines;\n  Dwg_LEADER_Line *lines;               /*!< DXF 10 */\n  BITCODE_BL num_breaks;\n  Dwg_LEADER_Break * breaks;            /*!< DXF 12, 13 */\n\n  BITCODE_BS attach_dir; //2010+ 271\n} Dwg_LEADER_Node;\n\ntypedef union _dwg_MLEADER_Content\n{\n  struct _content_mtext\n    {\n      BITCODE_T default_text;\n      BITCODE_3BD normal; // 11\n      BITCODE_H style;\n      BITCODE_3BD location;\n      BITCODE_3BD direction;\n      BITCODE_BD rotation;\n      BITCODE_BD width;\n      BITCODE_BD height;\n      BITCODE_BD line_spacing_factor;\n      BITCODE_BS line_spacing_style;\n      BITCODE_CMC color;\n      BITCODE_BS alignment;\n      BITCODE_BS flow;\n      BITCODE_CMC bg_color;\n      BITCODE_BD bg_scale;\n      BITCODE_BL bg_transparency;\n      BITCODE_B is_bg_fill;\n      BITCODE_B is_bg_mask_fill;\n      BITCODE_BS col_type;\n      BITCODE_B is_height_auto;\n      BITCODE_BD col_width;\n      BITCODE_BD col_gutter;\n      BITCODE_B is_col_flow_reversed;\n      BITCODE_BL num_col_sizes;\n      BITCODE_BD *col_sizes;\n      BITCODE_B word_break;\n      BITCODE_B unknown;\n    } txt;\n  struct _content_block\n    {\n      BITCODE_H block_table;\n      BITCODE_3BD normal; // 14\n      BITCODE_3BD location;\n      BITCODE_3BD scale;\n      BITCODE_BD rotation;\n      BITCODE_CMC color;\n      BITCODE_BD *transform;\n    } blk;\n} Dwg_MLEADER_Content;\n\n/* The MLeaderAnnotContext object (par 20.4.86), embedded into an MLEADER */\ntypedef struct _dwg_MLEADER_AnnotContext\n{\n  //AcDbObjectContextData:\n  BITCODE_BS class_version;  /*!< r2010+ DXF 70 */\n  BITCODE_B has_xdic_file;   /*!< r2010+ default true */\n  BITCODE_B is_default;      /*!< r2010+ DXF 290 */\n\n  // AcDbAnnotScaleObjectContextData:\n  BITCODE_H scale_handle;      /*!< DXF 340 hard ptr to AcDbScale */\n\n  BITCODE_BL num_leaders;\n  Dwg_LEADER_Node * leaders;\n\n  BITCODE_BS attach_dir;\n\n  BITCODE_BD scale;\n  BITCODE_3BD content_base;\n  BITCODE_BD text_height;\n  BITCODE_BD arrow_size;\n  BITCODE_BD landing_gap;\n  BITCODE_BS text_left;\n  BITCODE_BS text_right;\n  BITCODE_BS text_alignment;\n  BITCODE_BS attach_type;\n\n  BITCODE_B has_content_txt;\n  BITCODE_B has_content_blk;\n  Dwg_MLEADER_Content content; // union txt/blk\n\n  BITCODE_3BD base;\n  BITCODE_3BD base_dir;\n  BITCODE_3BD base_vert;\n  BITCODE_B is_normal_reversed;\n\n  BITCODE_BS text_top;\n  BITCODE_BS text_bottom;\n\n} Dwg_MLEADER_AnnotContext;\n\n// dbmleader.h\ntypedef struct _dwg_entity_MULTILEADER\n{\n  struct _dwg_object_entity *parent;\n\n  BITCODE_BS class_version; /*!< r2010+ =2 */\n  Dwg_MLEADER_AnnotContext ctx;\n  BITCODE_H mleaderstyle;\n  BITCODE_BL flags; /* override */\n  BITCODE_BS type;\n  BITCODE_CMC color;\n  BITCODE_H ltype;\n  BITCODE_BLd linewt;\n  BITCODE_B has_landing;\n  BITCODE_B has_dogleg;\n  BITCODE_BD landing_dist;\n  BITCODE_H arrow_handle;\n  BITCODE_BD arrow_size; /* the default */\n  BITCODE_BS style_content;\n  BITCODE_H text_style;\n  BITCODE_BS text_left;\n  BITCODE_BS text_right;\n  BITCODE_BS text_angletype;\n  BITCODE_BS attach_type;\n  BITCODE_CMC text_color;\n  BITCODE_B has_text_frame;\n  BITCODE_H block_style;\n  BITCODE_CMC block_color;\n  BITCODE_3BD block_scale;\n  BITCODE_BD block_rotation;\n  BITCODE_BS style_attachment; // 0 = center extents, 1 = insertion point\n  BITCODE_B is_annotative;\n\n  /* until r2007: */\n  BITCODE_BL num_arrowheads;\n  Dwg_LEADER_ArrowHead *arrowheads;\n  BITCODE_BL num_blocklabels;\n  Dwg_LEADER_BlockLabel *blocklabels;\n  BITCODE_B neg_textdir;\n  BITCODE_BS ipe_alignment;\n  BITCODE_BS justification;\n  BITCODE_BD scale_factor;\n\n  BITCODE_BS attach_dir;    /*!< r2010+ (0 = horizontal, 1 = vertical) */\n  BITCODE_BS attach_top;    /*!< r2010+ */\n  BITCODE_BS attach_bottom; /*!< r2010+ */\n\n  BITCODE_B text_extended;  /*!< r2013+ */\n} Dwg_Entity_MULTILEADER;\n\n/**\n * Object MLEADERSTYLE (varies)\n * R2000+\n */\ntypedef struct _dwg_object_MLEADERSTYLE\n{\n  struct _dwg_object_object *parent;\n\n  BITCODE_BS class_version; /*!< r2010+ =2 */\n  BITCODE_BS content_type;\n  BITCODE_BS mleader_order;\n  BITCODE_BS leader_order;\n  BITCODE_BL max_points;\n  BITCODE_BD first_seg_angle;\n  BITCODE_BD second_seg_angle;\n  BITCODE_BS type;\n  BITCODE_CMC line_color;\n  BITCODE_H line_type;\n  BITCODE_BLd linewt;\n  BITCODE_B has_landing;\n  BITCODE_B has_dogleg;\n  BITCODE_BD landing_gap;\n  BITCODE_BD landing_dist;\n  BITCODE_TV description;\n  BITCODE_H arrow_head;\n  BITCODE_BD arrow_head_size;\n  BITCODE_TV text_default;\n  BITCODE_H text_style;\n  BITCODE_BS attach_left;\n  BITCODE_BS attach_right;\n  BITCODE_BS text_angle_type;\n  BITCODE_BS text_align_type;\n  BITCODE_CMC text_color;\n  BITCODE_BD text_height;\n  BITCODE_B text_frame;\n  BITCODE_B is_new_format; /* computed */\n  BITCODE_B text_always_left;\n  BITCODE_BD align_space;\n  BITCODE_H block;\n  BITCODE_CMC block_color;\n  BITCODE_3BD block_scale;\n  BITCODE_B use_block_scale;\n  BITCODE_BD block_rotation;\n  BITCODE_B use_block_rotation;\n  BITCODE_BS block_connection;\n  BITCODE_BD scale;\n  BITCODE_B changed;\n  BITCODE_B is_annotative;\n  BITCODE_BD break_size;\n\n  BITCODE_BS attach_dir;    /*!< r2010+ (0 = horizontal, 1 = vertical) */\n  BITCODE_BS attach_top;    /*!< r2010+ */\n  BITCODE_BS attach_bottom; /*!< r2010+ */\n\n  BITCODE_B text_extended;   /*!< r2013+ */\n} Dwg_Object_MLEADERSTYLE;\n\n/**\n VBA_PROJECT (81 + varies) object\n Has its own optional section? section[5]?\n */\ntypedef struct _dwg_object_VBA_PROJECT\n{\n  struct _dwg_object_object *parent;\n\n  BITCODE_RL num_bytes;\n  BITCODE_TF bytes;\n} Dwg_Object_VBA_PROJECT;\n\n\n/**\n LAYOUT (82 + varies) object\n */\ntypedef struct _dwg_object_LAYOUT\n{\n  struct _dwg_object_object *parent;\n\n  // AcDbPlotSettings:\n  BITCODE_TV page_setup_name;\n  BITCODE_TV printer_or_config;\n  BITCODE_BS plot_layout_flags;\n  BITCODE_BD left_margin;\n  BITCODE_BD bottom_margin;\n  BITCODE_BD right_margin;\n  BITCODE_BD top_margin;\n  BITCODE_BD paper_width;\n  BITCODE_BD paper_height;\n  BITCODE_TV paper_size;\n  BITCODE_2BD_1 plot_origin;\n  BITCODE_BS paper_units;\n  BITCODE_BS plot_rotation;\n  BITCODE_BS plot_type;\n  BITCODE_2BD_1 window_min;\n  BITCODE_2BD_1 window_max;\n  BITCODE_TV plot_view_name;\n  BITCODE_BD real_world_units;\n  BITCODE_BD drawing_units;\n  BITCODE_TV current_style_sheet;\n  BITCODE_BS scale_type;\n  BITCODE_BD scale_factor;\n  BITCODE_2BD_1 paper_image_origin;\n  BITCODE_BS shade_plot_mode;\n  BITCODE_BS shade_plot_res_level;\n  BITCODE_BS shade_plot_custom_dpi;\n\n  // AcDbLayout:\n  BITCODE_TV layout_name;\n  BITCODE_BS tab_order;\n  BITCODE_BS flag;\n  BITCODE_3DPOINT ucs_origin;\n  BITCODE_2DPOINT minimum_limits;\n  BITCODE_2DPOINT maximum_limits;\n  BITCODE_3DPOINT ins_point;\n  BITCODE_3DPOINT ucs_x_axis;\n  BITCODE_3DPOINT ucs_y_axis;\n  BITCODE_BD elevation;\n  BITCODE_BS orthoview_type;\n  BITCODE_3DPOINT extent_min;\n  BITCODE_3DPOINT extent_max;\n  BITCODE_H plot_view; \t\t// r2004+\n  BITCODE_H visualstyle; \t// r2007+\n  BITCODE_H block_header;\n  BITCODE_H active_viewport;\n  BITCODE_H base_ucs;\n  BITCODE_H named_ucs;\n  BITCODE_BL num_viewports; \t// r2004+\n  BITCODE_H* viewports;     \t// r2004+\n} Dwg_Object_LAYOUT;\n\n/**\n * And the non-fixed types, classes, only\n */\n\n/**\n Class DICTIONARYVAR (varies)\n */\ntypedef struct _dwg_object_DICTIONARYVAR\n{\n  struct _dwg_object_object *parent;\n\n  BITCODE_RC intval;\n  BITCODE_TV str;\n} Dwg_Object_DICTIONARYVAR;\n\n/**\n Class DICTIONARYWDFLT (varies)\n */\ntypedef struct _dwg_object_DICTIONARYWDFLT\n{\n  struct _dwg_object_object *parent;\n\n  BITCODE_BL numitems;    /*!< no DXF */\n  BITCODE_BS cloning;     /*!< DXF 281 */\n  BITCODE_RC hard_owner;  /*!< DXF 330 */\n  BITCODE_TV* texts;      /*!< DXF 3 */\n  BITCODE_H* itemhandles; /*!< DXF 350/360, pairwise with texts */\n\n  BITCODE_RL cloning_r14; /*!< r14 only */\n  BITCODE_H defaultid;\n} Dwg_Object_DICTIONARYWDFLT;\n\n/**\n Class TABLE (varies)\n */\n\n// 20.4.99. also for FIELD\ntypedef struct _dwg_TABLE_value\n{\n  BITCODE_BL flags;\n  BITCODE_BL data_type;\n  BITCODE_BL data_size;\n  BITCODE_BL data_long;\n  BITCODE_BD data_double;\n  BITCODE_TV data_string;\n  char     * data_date;\n  BITCODE_2RD data_point;\n  BITCODE_3RD data_3dpoint;\n  BITCODE_BL unit_type;\n  BITCODE_TV format_string;\n  BITCODE_TV value_string;\n} Dwg_TABLE_value;\n\n// 20.4.100 Custom data collection for table cells, cols, rows\ntypedef struct _dwg_TABLE_CustomDataItem\n{\n  BITCODE_TV name;\n  Dwg_TABLE_value value;\n\n  struct _dwg_TableCell *cell_parent;\n  struct _dwg_TableRow *row_parent;\n} Dwg_TABLE_CustomDataItem;\n\ntypedef struct _dwg_TABLE_Cell\n{\n  BITCODE_BS type;\n  BITCODE_RC flags;\n  BITCODE_B merged_value;\n  BITCODE_B autofit_flag;\n  BITCODE_BL merged_width_flag;\n  BITCODE_BL merged_height_flag;\n  BITCODE_BD rotation_value;\n  BITCODE_TV text_string;\n  BITCODE_BD block_scale;\n  BITCODE_B additional_data_flag;\n  BITCODE_BS attr_def_index;\n  BITCODE_TV attr_def_text;\n  BITCODE_B additional_data_flag2;\n  BITCODE_BL cell_flag_override;\n  BITCODE_RC virtual_edge_flag;\n  BITCODE_RS cell_alignment;\n  BITCODE_B background_fill_none;\n  BITCODE_CMC background_color;\n  BITCODE_CMC content_color;\n  BITCODE_H text_style;\n  BITCODE_BD text_height;\n  BITCODE_CMC top_grid_color;\n  BITCODE_BS top_grid_linewt;\n  BITCODE_BS top_visibility;\n  BITCODE_CMC right_grid_color;\n  BITCODE_BS right_grid_linewt;\n  BITCODE_BS right_visibility;\n  BITCODE_CMC bottom_grid_color;\n  BITCODE_BS bottom_grid_linewt;\n  BITCODE_BS bottom_visibility;\n  BITCODE_CMC left_grid_color;\n  BITCODE_BS left_grid_linewt;\n  BITCODE_BS left_visibility;\n  BITCODE_BL unknown;\n  Dwg_TABLE_value value;\n  BITCODE_H cell_handle;\n  BITCODE_BS num_attr_defs;\n  BITCODE_H* attr_def_id;\n  BITCODE_H text_style_override;\n\n  struct _dwg_entity_TABLE *parent;\n} Dwg_TABLE_Cell;\n\ntypedef struct _dwg_TABLE_BreakHeight\n{\n  BITCODE_3BD position;\n  BITCODE_BD height;\n  BITCODE_BL flag;\n\n  struct _dwg_entity_TABLE *parent;\n} Dwg_TABLE_BreakHeight;\n\ntypedef struct _dwg_TABLE_BreakRow\n{\n  BITCODE_3BD position;\n  BITCODE_BL start;\n  BITCODE_BL end;\n\n  struct _dwg_entity_TABLE *parent;\n} Dwg_TABLE_BreakRow;\n\ntypedef struct _dwg_LinkedData\n{\n  BITCODE_TV name;\n  BITCODE_TV desc;\n} Dwg_LinkedData;\n\ntypedef struct _dwg_TableCellContent_Attr\n{\n  BITCODE_H attdef;\n  BITCODE_TV value;\n  BITCODE_BL index;\n\n  struct _dwg_TableCellContent *parent;\n} Dwg_TableCellContent_Attr;\n\n// Content format 20.4.101.3\ntypedef struct _dwg_ContentFormat\n{\n  BITCODE_BL property_override_flags;\n  BITCODE_BL property_flags;\n  BITCODE_BL value_data_type; /* see 20.4.98 */\n  BITCODE_BL value_unit_type; /* see 20.4.98 */\n  BITCODE_TV value_format_string;\n  BITCODE_BD rotation;\n  BITCODE_BD block_scale;\n  BITCODE_BL cell_alignment;\n  BITCODE_CMC content_color;\n  BITCODE_H text_style;\n  BITCODE_BD text_height;\n} Dwg_ContentFormat;\n\ntypedef struct _dwg_TableCellContent\n{\n  BITCODE_BL type;\n  Dwg_TABLE_value value; // 20.4.99 Value\n  BITCODE_H handle;\n  BITCODE_BL num_attrs;\n  Dwg_TableCellContent_Attr *attrs;\n  BITCODE_BS has_content_format_overrides;\n  Dwg_ContentFormat content_format;\n\n  struct _dwg_TableCell *parent;\n} Dwg_TableCellContent;\n\n// 20.4.98\ntypedef struct _dwg_CellContentGeometry\n{\n  BITCODE_3BD dist_top_left;\n  BITCODE_3BD dist_center;\n  BITCODE_BD content_width;\n  BITCODE_BD content_height;\n  BITCODE_BD width;\n  BITCODE_BD height;\n  BITCODE_BD unknown;\n\n  struct _dwg_TableCell *cell_parent;\n  struct _dwg_TABLEGEOMETRY_Cell *geom_parent;\n} Dwg_CellContentGeometry;\n\ntypedef struct _dwg_TableCell\n{\n  BITCODE_BL flag;\n  BITCODE_TV tooltip;\n  BITCODE_BL customdata;\n  BITCODE_BL num_customdata_items;\n  Dwg_TABLE_CustomDataItem *customdata_items;\n  BITCODE_BL has_linked_data;\n  BITCODE_H  data_link;\n  BITCODE_BL num_rows;\n  BITCODE_BL num_cols;\n  BITCODE_BL unknown;\n  BITCODE_BL num_cell_contents;\n  Dwg_TableCellContent *cell_contents;\n  BITCODE_BL style_id;\n  BITCODE_BL has_geom_data;\n  BITCODE_BL geom_data_flag;\n  BITCODE_BD unknown_d40;\n  BITCODE_BD unknown_d41;\n  BITCODE_BL has_cell_geom;\n  BITCODE_H cell_geom_handle;\n  Dwg_CellContentGeometry *geom_data;\n\n  struct _dwg_CellStyle *style_parent;\n  struct _dwg_TableRow *row_parent;\n} Dwg_TableCell;\n\ntypedef struct _dwg_BorderStyle\n{\n  BITCODE_BL edge_flags;\n  BITCODE_BL border_property_overrides_flag;\n  BITCODE_BL border_type;\n  BITCODE_CMC color;\n  BITCODE_BLd linewt;\n  BITCODE_H line_type;\n  BITCODE_B invisible;\n  BITCODE_BD double_line_spacing;\n\n  struct _dwg_CellStyle *parent;\n} Dwg_BorderStyle;\n\n/**\n  Cell style 20.4.101.4\n  for TABLE, TABLECONTENT, CELLSTYLEMAP\n*/\ntypedef struct _dwg_CellStyle\n{\n  BITCODE_BL type; /* 1 cell, 2 row, 3 col, 4 fmt data, 5 table */\n  BITCODE_BS data_flags;\n  BITCODE_BL property_override_flags;\n  BITCODE_BL merge_flags;\n  BITCODE_CMC background_color;\n  BITCODE_BL content_layout;\n  Dwg_ContentFormat content_format;\n  BITCODE_BS margin_override_flags;\n  BITCODE_BD vert_margin;\n  BITCODE_BD horiz_margin;\n  BITCODE_BD bottom_margin;\n  BITCODE_BD right_margin;\n  BITCODE_BD margin_horiz_spacing;\n  BITCODE_BD margin_vert_spacing;\n  BITCODE_BL num_borders; /* 0-6 */\n  Dwg_BorderStyle *border;\n\n  struct _dwg_TableRow *tablerow_parent;\n  struct _dwg_TableDataColumn *tabledatacolumn_parent;\n} Dwg_CellStyle;\n\ntypedef struct _dwg_TableRow\n{\n  BITCODE_BL num_cells;\n  Dwg_TableCell *cells;\n  BITCODE_BL custom_data;\n  BITCODE_BL num_customdata_items;\n  Dwg_TABLE_CustomDataItem *customdata_items;\n  Dwg_CellStyle cellstyle;\n  BITCODE_BL style_id;\n  BITCODE_BL height;\n\n  struct _dwg_LinkedTableData *parent;\n} Dwg_TableRow;\n\ntypedef struct _dwg_TableDataColumn\n{\n  BITCODE_TV name;\n  BITCODE_BL custom_data;\n  //BITCODE_TV data;\n  Dwg_CellStyle cellstyle;\n  BITCODE_BL cellstyle_id;\n  BITCODE_BL width;\n\n  struct _dwg_LinkedTableData *parent;\n} Dwg_TableDataColumn;\n\ntypedef struct _dwg_LinkedTableData\n{\n  BITCODE_BL num_cols;\n  Dwg_TableDataColumn *cols;\n  BITCODE_BL num_rows;\n  Dwg_TableRow *rows;\n  BITCODE_BL num_field_refs;\n  BITCODE_H *field_refs;\n} Dwg_LinkedTableData;\n\ntypedef struct _dwg_FormattedTableMerged\n{\n  BITCODE_BL top_row;\n  BITCODE_BL left_col;\n  BITCODE_BL bottom_row;\n  BITCODE_BL right_col;\n\n  struct _dwg_FormattedTableData *parent;\n} Dwg_FormattedTableMerged;\n\ntypedef struct _dwg_FormattedTableData\n{\n  Dwg_CellStyle cellstyle;\n  BITCODE_BL num_merged_cells;\n  Dwg_FormattedTableMerged *merged_cells;\n\n  struct _dwg_object_TABLECONTENT *parent;\n} Dwg_FormattedTableData;\n\n#define TABLECONTENT_fields                                                   \\\n  Dwg_LinkedData ldata;                                                       \\\n  Dwg_LinkedTableData tdata;                                                  \\\n  Dwg_FormattedTableData fdata;                                               \\\n  BITCODE_H table_style\n\ntypedef struct _dwg_object_TABLECONTENT\n{\n  struct _dwg_object_object *parent;\n  TABLECONTENT_fields;\n} Dwg_Object_TABLECONTENT;\n\ntypedef struct _dwg_entity_TABLE\n{\n  struct _dwg_object_entity *parent;\n  //r2010+ TABLECONTENT:\n  TABLECONTENT_fields;\n\n  BITCODE_RC unknown_rc;\n  BITCODE_H unknown_h;\n  BITCODE_BL unknown_bl;\n  BITCODE_B unknown_b;\n  BITCODE_BL unknown_bl1;\n  BITCODE_3BD insertion_point; /*!< DXF 10 */\n  BITCODE_3BD scale;        /*!< DXF 41 */\n  BITCODE_BB data_flags;\n  BITCODE_BD rotation;      /*!< DXF 50 */\n  BITCODE_BE extrusion;    /*!< DXF 210 */\n  BITCODE_B has_attribs;    /*!< DXF 66 */\n  BITCODE_BL num_owned;\n  BITCODE_BS flag_for_table_value; /*!< DXF 90.\n                                     Bit flags, 0x06 (0x02 + 0x04): has block,\n                                     0x10: table direction, 0 = up, 1 = down,\n                                     0x20: title suppressed.\n                                     Normally 0x06 is always set. */\n  BITCODE_3BD horiz_direction; /*!< DXF 11 */\n  BITCODE_BL num_cols;     /*!< DXF 90 */\n  BITCODE_BL num_rows;     /*!< DXF 91 */\n  unsigned long num_cells; /*!< computed */\n  BITCODE_BD* col_widths;  /*!< DXF 142 */\n  BITCODE_BD* row_heights; /*!< DXF 141 */\n  Dwg_TABLE_Cell* cells;\n  BITCODE_B has_table_overrides;\n  BITCODE_BL table_flag_override; /*!< DXF 93 */\n  BITCODE_B title_suppressed;     /*!< DXF 280 */\n  BITCODE_B header_suppressed;    /*!< DXF 281 */\n  BITCODE_BS flow_direction;      /*!< DXF 70 */\n  BITCODE_BD horiz_cell_margin;   /*!< DXF 40 */\n  BITCODE_BD vert_cell_margin;    /*!< DXF 41 */\n  BITCODE_CMC title_row_color;    /*!< DXF 64 */\n  BITCODE_CMC header_row_color;   /*!< DXF 64 */\n  BITCODE_CMC data_row_color;     /*!< DXF 64 */\n  BITCODE_B title_row_fill_none;  /*!< DXF 283 */\n  BITCODE_B header_row_fill_none; /*!< DXF 283 */\n  BITCODE_B data_row_fill_none;   /*!< DXF 283 */\n  BITCODE_CMC title_row_fill_color;  /*!< DXF 63 */\n  BITCODE_CMC header_row_fill_color; /*!< DXF 63 */\n  BITCODE_CMC data_row_fill_color;   /*!< DXF 63 */\n  BITCODE_BS title_row_alignment;   /*!< DXF 170 */\n  BITCODE_BS header_row_alignment;  /*!< DXF 170 */\n  BITCODE_BS data_row_alignment;    /*!< DXF 170 */\n  BITCODE_H title_text_style;   /*!< DXF 7 */\n  BITCODE_H header_text_style;  /*!< DXF 7 */\n  BITCODE_H data_text_style;    /*!< DXF 7 */\n  BITCODE_BD title_row_height;  /*!< DXF 140 */\n  BITCODE_BD header_row_height; /*!< DXF 140 */\n  BITCODE_BD data_row_height;   /*!< DXF 140 */\n\n  BITCODE_B has_border_color_overrides;   /*!< if DXF 94 > 0 */\n  BITCODE_BL border_color_overrides_flag; /*!< DXF 94 */\n  BITCODE_CMC title_horiz_top_color;      /*!< DXF 64 if DXF 94 & 0x1 */\n  BITCODE_CMC title_horiz_ins_color;      /*!< DXF 65 if DXF 94 & 0x2 */\n  BITCODE_CMC title_horiz_bottom_color;   /*!< DXF 66 if DXF 94 & 0x4 */\n  BITCODE_CMC title_vert_left_color;      /*!< DXF 63 if DXF 94 & 0x8 */\n  BITCODE_CMC title_vert_ins_color;       /*!< DXF 68 if DXF 94 & 0x10 */\n  BITCODE_CMC title_vert_right_color;     /*!< DXF 69 if DXF 94 & 0x20 */\n  BITCODE_CMC header_horiz_top_color;     /*!< DXF 64 if DXF 94 & 0x40 */\n  BITCODE_CMC header_horiz_ins_color;     /*!< DXF 65 */\n  BITCODE_CMC header_horiz_bottom_color;  /*!< DXF 66 */\n  BITCODE_CMC header_vert_left_color;     /*!< DXF 63 */\n  BITCODE_CMC header_vert_ins_color;      /*!< DXF 68 */\n  BITCODE_CMC header_vert_right_color;    /*!< DXF 69 */\n  BITCODE_CMC data_horiz_top_color;       /*!< DXF 64 */\n  BITCODE_CMC data_horiz_ins_color;       /*!< DXF 65 */\n  BITCODE_CMC data_horiz_bottom_color;    /*!< DXF 66 */\n  BITCODE_CMC data_vert_left_color;       /*!< DXF 63 */\n  BITCODE_CMC data_vert_ins_color;        /*!< DXF 68 */\n  BITCODE_CMC data_vert_right_color;      /*!< DXF 69 */\n\n  BITCODE_B has_border_lineweight_overrides;   /*!< if DXF 95 > 0 */\n  BITCODE_BL border_lineweight_overrides_flag; /*!< DXF 95 */\n  BITCODE_BS title_horiz_top_linewt;\n  BITCODE_BS title_horiz_ins_linewt;\n  BITCODE_BS title_horiz_bottom_linewt;\n  BITCODE_BS title_vert_left_linewt;\n  BITCODE_BS title_vert_ins_linewt;\n  BITCODE_BS title_vert_right_linewt;\n  BITCODE_BS header_horiz_top_linewt;\n  BITCODE_BS header_horiz_ins_linewt;\n  BITCODE_BS header_horiz_bottom_linewt;\n  BITCODE_BS header_vert_left_linewt;\n  BITCODE_BS header_vert_ins_linewt;\n  BITCODE_BS header_vert_right_linewt;\n  BITCODE_BS data_horiz_top_linewt;\n  BITCODE_BS data_horiz_ins_linewt;\n  BITCODE_BS data_horiz_bottom_linewt;\n  BITCODE_BS data_vert_left_linewt;\n  BITCODE_BS data_vert_ins_linewt;\n  BITCODE_BS data_vert_right_linewt;\n\n  BITCODE_B has_border_visibility_overrides;\n  BITCODE_BL border_visibility_overrides_flag; /*!< DXF 96 */\n  BITCODE_BS title_horiz_top_visibility;\n  BITCODE_BS title_horiz_ins_visibility;\n  BITCODE_BS title_horiz_bottom_visibility;\n  BITCODE_BS title_vert_left_visibility;\n  BITCODE_BS title_vert_ins_visibility;\n  BITCODE_BS title_vert_right_visibility;\n  BITCODE_BS header_horiz_top_visibility;\n  BITCODE_BS header_horiz_ins_visibility;\n  BITCODE_BS header_horiz_bottom_visibility;\n  BITCODE_BS header_vert_left_visibility;\n  BITCODE_BS header_vert_ins_visibility;\n  BITCODE_BS header_vert_right_visibility;\n  BITCODE_BS data_horiz_top_visibility;\n  BITCODE_BS data_horiz_ins_visibility;\n  BITCODE_BS data_horiz_bottom_visibility;\n  BITCODE_BS data_vert_left_visibility;\n  BITCODE_BS data_vert_ins_visibility;\n  BITCODE_BS data_vert_right_visibility;\n\n  BITCODE_H block_header;\n  BITCODE_H first_attrib;\n  BITCODE_H last_attrib;\n  BITCODE_H* attrib_handles;\n  BITCODE_H seqend;\n  BITCODE_H title_row_style_override;\n  BITCODE_H header_row_style_override;\n  BITCODE_H data_row_style_override;\n\n  BITCODE_BS unknown_bs;\n  BITCODE_3BD hor_dir;\n  BITCODE_BL has_break_data;\n  BITCODE_BL break_flag;\n  BITCODE_BL break_flow_direction;\n  BITCODE_BD break_spacing;\n  BITCODE_BL break_unknown1;\n  BITCODE_BL break_unknown2;\n  BITCODE_BL num_break_heights;\n  Dwg_TABLE_BreakHeight *break_heights;\n  BITCODE_BL num_break_rows;\n  Dwg_TABLE_BreakRow *break_rows;\n\n} Dwg_Entity_TABLE;\n\n#undef TABLECONTENT_fields\n\n/**\n Class TABLESTYLE (varies)\n R2010+ TODO\n */\n\ntypedef struct _dwg_TABLESTYLE_Cell\n{\n  Dwg_TABLE_Cell cell;\n  BITCODE_BL id;   /* 1=title, 2=header, 3=data, 4=table.\n                      ref TABLESTYLE. custom IDs > 100 */\n  BITCODE_BL type; /* 1=data, 2=label */\n  BITCODE_TV name;\n\n  struct _dwg_object_TABLESTYLE *parent;\n} Dwg_TABLESTYLE_Cell;\n\ntypedef struct _dwg_TABLESTYLE_border\n{\n  BITCODE_BSd linewt;\n  BITCODE_B visible;\n  BITCODE_CMC color;\n\n  struct _dwg_TABLESTYLE_rowstyles *parent;\n} Dwg_TABLESTYLE_border;\n\ntypedef struct _dwg_TABLESTYLE_rowstyles\n{\n  BITCODE_H text_style;\n  BITCODE_BD text_height;\n  BITCODE_BS text_alignment;\n  BITCODE_CMC text_color;\n  BITCODE_CMC fill_color;\n  BITCODE_B has_bgcolor;\n\n  //6: top, horizontal inside, bottom, left, vertical inside, right\n  BITCODE_BL num_borders; // always 6\n  Dwg_TABLESTYLE_border *borders;\n\n  BITCODE_BL data_type;  // r2007+\n  BITCODE_BL unit_type;\n  BITCODE_TU format_string;\n\n  struct _dwg_object_TABLESTYLE *parent;\n} Dwg_TABLESTYLE_rowstyles;\n\ntypedef struct _dwg_object_TABLESTYLE\n{\n  struct _dwg_object_object *parent;\n\n  BITCODE_BS class_version;\n  BITCODE_TV name;\n  BITCODE_BS flags;\n  BITCODE_BS flow_direction;\n  BITCODE_BD horiz_cell_margin;\n  BITCODE_BD vert_cell_margin;\n  BITCODE_B title_suppressed;\n  BITCODE_B header_suppressed;\n\n  // 0: data, 1: title, 2: header\n  BITCODE_BL num_rowstyles; // always 3\n  Dwg_TABLESTYLE_rowstyles *rowstyles;\n\n  BITCODE_BL num_cells;   // r2010+ nyi\n  Dwg_TABLESTYLE_Cell* cells;\n} Dwg_Object_TABLESTYLE;\n\n/**\n Class CELLSTYLEMAP (varies)\n R2008+ TABLESTYLE extension class\n */\n\ntypedef struct _dwg_CELLSTYLEMAP_Cell\n{\n  Dwg_CellStyle style;\n  BITCODE_BL id;   /* 1=title, 2=header, 3=data, 4=table.\n                      ref TABLESTYLE. custom IDs > 100 */\n  BITCODE_BL type; /* 1=data, 2=label */\n  BITCODE_TV name;\n\n  struct _dwg_object_CELLSTYLEMAP *parent;\n} Dwg_CELLSTYLEMAP_Cell;\n\ntypedef struct _dwg_object_CELLSTYLEMAP\n{\n  struct _dwg_object_object *parent;\n\n  BITCODE_BL num_cells;\n  Dwg_CELLSTYLEMAP_Cell* cells;\n} Dwg_Object_CELLSTYLEMAP;\n\n/* 20.4.103 TABLEGEOMETRY\n r2008+ optional, == 20.4.98\n */\n\ntypedef struct _dwg_TABLEGEOMETRY_Cell\n{\n  BITCODE_BL flag;\n  BITCODE_BD width_w_gap;\n  BITCODE_BD height_w_gap;\n  BITCODE_H unknown;\n  BITCODE_BL num_geom_data;\n  Dwg_CellContentGeometry *geom_data;\n\n  struct _dwg_object_TABLEGEOMETRY *parent;\n} Dwg_TABLEGEOMETRY_Cell;\n\ntypedef struct _dwg_object_TABLEGEOMETRY\n{\n  struct _dwg_object_object *parent;\n  BITCODE_BL num_rows;\n  BITCODE_BL num_cols;\n  BITCODE_BL num_cells; /* = num_rows * num_cols */\n  Dwg_TABLEGEOMETRY_Cell *cells;\n} Dwg_Object_TABLEGEOMETRY;\n\n\n/**\n Class UNDERLAYDEFINITION (varies)\n in DXF as {PDF,DGN,DWF}DEFINITION\n */\ntypedef struct _dwg_object_UNDERLAYDEFINITION\n{\n  struct _dwg_object_object *parent;\n\n  BITCODE_TV filename; /*!< DXF 1, relative or absolute path to the image file */\n  BITCODE_TV name;     /*!< DXF 2, pdf: page number, dgn: default, dwf: ? */\n} Dwg_Object_UNDERLAYDEFINITION;\n\ntypedef struct _dwg_object_UNDERLAYDEFINITION Dwg_Object_PDFDEFINITION;\ntypedef struct _dwg_object_UNDERLAYDEFINITION Dwg_Object_DGNDEFINITION;\ntypedef struct _dwg_object_UNDERLAYDEFINITION Dwg_Object_DWFDEFINITION;\n\n/**\n Entity UNDERLAY, the reference (varies)\n As IMAGE but snappable.\n in DXF as{PDF,DGN,DWF}UNDERLAY\n */\ntypedef struct _dwg_entity_UNDERLAY\n{\n  struct _dwg_object_entity *parent;\n\n  BITCODE_BE extrusion; /*!< DXF 210 normal */\n  BITCODE_3BD insertion_pt; /*!< DXF 10 */\n  BITCODE_3BD scale;   /*!< DXF 41 */\n  BITCODE_BD angle;    /*!< DXF 50 */\n  BITCODE_RC flag;     /*!< DXF 280: 1 is_clipped, 2 is_on, 4 is_monochrome,\n                            8 is_adjusted_for_background, 16 is_clip_inverted,\n                            ? is_frame_visible, ? is_frame_plottable */\n  BITCODE_RC contrast; /*!< DXF 281 20-100, def: 100 */\n  BITCODE_RC fade;     /*!< DXF 282 0-80, def: 0*/\n  BITCODE_BL num_clip_verts;\n  BITCODE_2RD *clip_verts; /*!< DXF 11: if 2 rectangle, > polygon */\n\n  BITCODE_H underlay_layer;\n  BITCODE_H definition_id; /*!< DXF 340 */\n\n} Dwg_Entity_UNDERLAY;\n\ntypedef struct _dwg_entity_UNDERLAY Dwg_Entity_PDFUNDERLAY;\ntypedef struct _dwg_entity_UNDERLAY Dwg_Entity_DGNUNDERLAY;\ntypedef struct _dwg_entity_UNDERLAY Dwg_Entity_DWFUNDERLAY;\n\n/**\n Class DBCOLOR (varies)\n */\ntypedef struct _dwg_object_DBCOLOR\n{\n  struct _dwg_object_object *parent;\n\n  BITCODE_BL class_version; // 0\n  BITCODE_BB unknown1; //  0  masked off first byte of rgb\n  BITCODE_RL rgb;      //420: 0xXXRRGGBB\n  BITCODE_RC unknown2; //     256\n  BITCODE_T name;      //430: DIC 6\n  BITCODE_T catalog;   //430: DIC COLOR GUIDE(R)\n  BITCODE_CMC color;   //62: 253 color index only as EED\n  //...\n} Dwg_Object_DBCOLOR;\n\n/**\n Class FIELDLIST AcDbField (varies)\n R2018+\n */\ntypedef struct _dwg_FIELD_ChildValue\n{\n  BITCODE_TV key;   /*!< DXF 6 */\n  Dwg_TABLE_value value;\n  struct _dwg_object_FIELD *parent;\n} Dwg_FIELD_ChildValue;\n\ntypedef struct _dwg_object_FIELD\n{\n  struct _dwg_object_object *parent;\n                    /* dxf group code */\n  BITCODE_TV id;           /* 1 */\n  BITCODE_TV code;         /* 2,3 */\n  BITCODE_BL num_childs;   /* 90 */\n  BITCODE_H *childs;       /* code:3, 360 */\n  BITCODE_BL num_objects;  /* 97 */\n  BITCODE_H *objects;      /* code:5, 331 */\n  BITCODE_TV format;       /* 4, until r2004 only */\n  BITCODE_BL evaluation_option; /* 91 */\n  BITCODE_BL filing_option;     /* 92 */\n  BITCODE_BL field_state;       /* 94 */\n  BITCODE_BL evaluation_status; /* 95 */\n  BITCODE_BL evaluation_error_code; /* 96 */\n  BITCODE_TV evaluation_error_msg;  /* 300 */\n  Dwg_TABLE_value value;\n  BITCODE_TV value_string;        /* 301,9 */\n  BITCODE_BL value_string_length; /* 98 ODA bug: TV */\n  BITCODE_BL num_childval;      /* 93 */\n  Dwg_FIELD_ChildValue *childval;\n} Dwg_Object_FIELD;\n\n/**\n * Object FIELDLIST (varies)\n */\ntypedef struct _dwg_object_FIELDLIST\n{\n  struct _dwg_object_object *parent;\n\n  BITCODE_BL num_fields;\n  BITCODE_B unknown;\n  BITCODE_H *fields;\n} Dwg_Object_FIELDLIST;\n\n/**\n Class GEODATA (varies)\n R2009+\n */\ntypedef struct _dwg_GEODATA_meshpt\n{\n  BITCODE_2RD source_pt;\n  BITCODE_2RD dest_pt;\n} Dwg_GEODATA_meshpt;\n\ntypedef struct _dwg_GEODATA_meshface\n{\n  BITCODE_BL face1;\n  BITCODE_BL face2;\n  BITCODE_BL face3;\n  BITCODE_BL face4;\n} Dwg_GEODATA_meshface;\n\ntypedef struct _dwg_object_GEODATA\n{                   /* dxf group code */\n  struct _dwg_object_object *parent;\n\n  BITCODE_BL class_version;\n  BITCODE_H host_block;\n  BITCODE_BS coord_type; /* 0 unknown, 1 local grid, 2 projected grid,\n                            3 geographic defined by latitude/longitude) */\n  BITCODE_3BD design_pt;\n  BITCODE_3BD ref_pt;\n  BITCODE_3BD obs_pt;\n  BITCODE_BD unit_scale_horiz;\n  BITCODE_BL units_value_horiz;\n  BITCODE_BD unit_scale_vert;\n  BITCODE_BL units_value_vert;\n  BITCODE_3BD up_dir;\n  BITCODE_3BD north_dir;\n  BITCODE_BL scale_est; /* None = 1, User specified scale factor = 2,\n                           Grid scale at reference point = 3, Prismodial = 4 */\n  BITCODE_BD user_scale_factor;\n  BITCODE_B sea_level_corr;\n  BITCODE_BD sea_level_elev;\n  BITCODE_BD coord_proj_radius;\n  BITCODE_T coord_system_def;\n  BITCODE_T geo_rss_tag;\n  BITCODE_T coord_system_datum; /* obsolete */\n  BITCODE_T coord_system_wkt; /* obsolete */\n\n  BITCODE_T observation_from_tag;\n  BITCODE_T observation_to_tag;\n  BITCODE_T observation_coverage_tag;\n  BITCODE_BL num_geomesh_pts;\n  Dwg_GEODATA_meshpt *geomesh_pts;\n  BITCODE_BL num_geomesh_faces;\n  Dwg_GEODATA_meshface *geomesh_faces;\n\n  BITCODE_B has_civil_data;\n  BITCODE_B obsolete_false;\n  BITCODE_BD north_dir_angle_deg;\n  BITCODE_BD north_dir_angle_rad;\n} Dwg_Object_GEODATA;\n\n/**\n Class IDBUFFER (varies)\n */\ntypedef struct _dwg_object_IDBUFFER\n{\n  struct _dwg_object_object *parent;\n\n  BITCODE_RC unknown;\n  BITCODE_BL num_obj_ids;\n  BITCODE_H* obj_ids;\n} Dwg_Object_IDBUFFER;\n\n/**\n Classes for IMAGE (varies)\n */\n\ntypedef struct _dwg_entity_IMAGE\n{\n  struct _dwg_object_entity *parent;\n\n  BITCODE_BL class_version;\n  BITCODE_3BD pt0;\n  BITCODE_3BD uvec;\n  BITCODE_3BD vvec;\n  BITCODE_2RD size; /*!< DXF 13/23; width, height in pixel */\n  BITCODE_BS display_props;\n  BITCODE_B clipping;\n  BITCODE_RC brightness;\n  BITCODE_RC contrast;\n  BITCODE_RC fade;\n  BITCODE_B clip_mode;\n  BITCODE_BS clip_boundary_type;\n  BITCODE_BL num_clip_verts;\n  BITCODE_2RD* clip_verts;\n  BITCODE_H imagedef;\n  BITCODE_H imagedefreactor;\n} Dwg_Entity_IMAGE;\n\n/**\n Class IMAGEDEF (varies)\n */\ntypedef struct _dwg_object_IMAGEDEF\n{\n  struct _dwg_object_object *parent;\n\n  BITCODE_BL class_version;\n  BITCODE_2RD image_size;\n  BITCODE_TV file_path;\n  BITCODE_B is_loaded;\n  BITCODE_RC resunits;\n  BITCODE_2RD pixel_size;\n  //BITCODE_H xrefctrl;    /*!< r2010+ */\n} Dwg_Object_IMAGEDEF;\n\n/**\n Class IMAGEDEF_REACTOR (varies)\n */\ntypedef struct _dwg_object_IMAGEDEF_REACTOR\n{\n  struct _dwg_object_object *parent;\n\n  BITCODE_BL class_version;\n} Dwg_Object_IMAGEDEF_REACTOR;\n\n/**\n Classes for LAYER_INDEX (varies)\n */\ntypedef struct _dwg_LAYER_entry\n{\n  BITCODE_BL idxlong;\n  BITCODE_T layername;\n\n  struct _dwg_object_LAYER_INDEX *parent;\n} Dwg_LAYER_entry;\n\ntypedef struct _dwg_object_LAYER_INDEX\n{\n  struct _dwg_object_object *parent;\n\n  BITCODE_BL timestamp1;\n  BITCODE_BL timestamp2;\n  BITCODE_BL num_entries;\n  // TODO: merge\n  Dwg_LAYER_entry* entries;\n  BITCODE_H* layer_entries;\n} Dwg_Object_LAYER_INDEX;\n\n/**\n Classes for LWPOLYLINE (77 + varies)\n */\ntypedef struct _dwg_entity_LWPOLYLINE\n{\n  struct _dwg_object_entity *parent;\n\n  BITCODE_BS flag;              /*!< DXF 70 */\n  BITCODE_BD const_width;       /*!< DXF 43 */\n  BITCODE_BD elevation;         /*!< DXF 38 */\n  BITCODE_BD thickness;         /*!< DXF 39 */\n  BITCODE_BE extrusion;        /*!< DXF 210 */\n  BITCODE_BL num_points;        /*!< DXF 90 */\n  BITCODE_2RD* points;          /*!< DXF 10,20 */\n  BITCODE_BL num_bulges;\n  BITCODE_BD* bulges;           /*!< DXF 42 */\n  BITCODE_BL num_vertexids;     /*!< r2010+, same as num_points */\n  BITCODE_BL* vertexids;        /*!< r2010+ DXF 91 */\n  BITCODE_BL num_widths;\n  Dwg_LWPOLYLINE_width* widths; /*!< DXF 40,41 */\n} Dwg_Entity_LWPOLYLINE;\n\n/**\n * 20.4.89 Class AcDbObjectContextData (varies)\n * R2010+\n */\ntypedef struct _dwg_object_OBJECTCONTEXTDATA\n{\n  struct _dwg_object_object *parent;\n\n  BITCODE_BS class_version; /*!< r2010+ =3 */\n  BITCODE_B has_file;\n  BITCODE_B defaultflag;\n} Dwg_Object_OBJECTCONTEXTDATA;\n\n/**\n Class RASTERVARIABLES (varies)\n (used in conjunction with IMAGE entities)\n */\ntypedef struct _dwg_object_RASTERVARIABLES\n{\n  struct _dwg_object_object *parent;\n\n  BITCODE_BL class_version;\n  BITCODE_BS display_frame;\n  BITCODE_BS display_quality;\n  BITCODE_BS units;\n} Dwg_Object_RASTERVARIABLES;\n\n/**\n Object SCALE (varies)\n */\ntypedef struct _dwg_object_SCALE\n{\n  struct _dwg_object_object *parent;\n\n  BITCODE_BS flag;\n  BITCODE_TV name;\n  BITCODE_BD paper_units;\n  BITCODE_BD drawing_units;\n  BITCODE_B has_unit_scale;\n} Dwg_Object_SCALE;\n\n/**\n Class SORTENTSTABLE (varies)\n */\ntypedef struct _dwg_object_SORTENTSTABLE\n{\n  struct _dwg_object_object *parent;\n\n  BITCODE_BL num_ents;\n  BITCODE_H* sort_ents;\n  BITCODE_H dictionary;\n  BITCODE_H* ents;\n} Dwg_Object_SORTENTSTABLE;\n\n/**\n Class SPATIAL_FILTER (varies)\n */\ntypedef struct _dwg_object_SPATIAL_FILTER\n{\n  struct _dwg_object_object *parent;\n\n  BITCODE_BS num_points;\n  BITCODE_2RD* points;\n  BITCODE_BE extrusion;\n  BITCODE_3BD clip_bound_origin;\n  BITCODE_BS display_boundary;\n  BITCODE_BS front_clip_on;\n  BITCODE_BD front_clip_dist;\n  BITCODE_BS back_clip_on;\n  BITCODE_BD back_clip_dist;\n  BITCODE_BD* inverse_block_transform;\n  BITCODE_BD* clip_bound_transform;\n} Dwg_Object_SPATIAL_FILTER;\n\n/**\n Class SPATIAL_INDEX (varies)\n */\ntypedef struct _dwg_object_SPATIAL_INDEX\n{\n  struct _dwg_object_object *parent;\n\n  BITCODE_BL timestamp1;\n  BITCODE_BL timestamp2;\n  char     * unknown;\n} Dwg_Object_SPATIAL_INDEX;\n\n/**\n WIPEOUT (varies, 504)\n R2000+, undocumented = IMAGE layover\n */\ntypedef struct _dwg_entity_WIPEOUT\n{\n  struct _dwg_object_entity *parent;\n\n  BITCODE_BL class_version;\n  BITCODE_3BD pt0;\n  BITCODE_3BD uvec;\n  BITCODE_3BD vvec;\n  BITCODE_2RD size;\n  BITCODE_BS display_props;\n  BITCODE_B clipping;\n  BITCODE_RC brightness;\n  BITCODE_RC contrast;\n  BITCODE_RC fade;\n  BITCODE_B clip_mode;\n  BITCODE_BS clip_boundary_type;\n  BITCODE_BL num_clip_verts;\n  BITCODE_2RD* clip_verts;\n  BITCODE_H imagedef;\n  BITCODE_H imagedefreactor;\n} Dwg_Entity_WIPEOUT;\n\n/**\n Class WIPEOUTVARIABLES (varies, 505)\n R2000+, Object bitsize: 96\n */\ntypedef struct _dwg_object_WIPEOUTVARIABLES\n{\n  struct _dwg_object_object *parent;\n  //BITCODE_BL class_version;  /*!< DXF 90 NY */\n  BITCODE_BS display_frame;    /*!< DXF 70  */\n} Dwg_Object_WIPEOUTVARIABLES;\n\n/**\n Class VISUALSTYLE (varies)\n R2007+\n */\ntypedef struct _dwg_object_VISUALSTYLE\n{\n  struct _dwg_object_object *parent;\n  BITCODE_T desc;       /*!< DXF 2  */\n  BITCODE_BS type;      /*!< DXF 70  */\n  BITCODE_BS face_lighting_model;  /*!< DXF 71 0:Invisible 1:Visible 2:Phong 3:Gooch */\n  BITCODE_BS face_lighting_quality;/*!< DXF 72 0:No lighting 1:Per face 2:Per vertex */\n  BITCODE_BS face_color_mode;   /*!< DXF 73 0 = No color\n                                  1 = Object color\n                                  2 = Background color\n                                  3 = Custom color\n                                  4 = Mono color\n                                  5 = Tinted\n                                  6 = Desaturated */\n  BITCODE_BD face_opacity;      /*!< DXF 40  */\n  BITCODE_BD face_specular;     /*!< DXF 41  */\n  BITCODE_BS face_modifier;     /*!< DXF 90 0:No modifiers 1:Opacity 2:Specular */\n  BITCODE_CMC color;                    /*!< DXF 62  */\n  BITCODE_CMC face_mono_color;          /*!< DXF 63 + 421 */\n  BITCODE_BS edge_model;                /*!< DXF 74 0:No edges 1:Isolines 2:Facet edges */\n  BITCODE_BL edge_style;                /*!< DXF 91  */\n  BITCODE_CMC edge_intersection_color;  /*!< DXF 64  */\n  BITCODE_CMC edge_obscured_color;      /*!< DXF 65  */\n  BITCODE_BS edge_obscured_line_pattern;        /*!< DXF 75   */\n  BITCODE_BS edge_intersection_line_pattern;    /*!< DXF 175  */\n  BITCODE_BD edge_crease_angle;         /*!< DXF 42  */\n  BITCODE_BS edge_modifier;             /*!< DXF 92  */\n  BITCODE_CMC edge_color;               /*!< DXF 66  */\n  BITCODE_BD edge_opacity;              /*!< DXF 43  */\n  BITCODE_BS edge_width;                /*!< DXF 76  */\n  BITCODE_BS edge_overhang;             /*!< DXF 77  */\n  BITCODE_BS edge_jitter;               /*!< DXF 78  */\n  BITCODE_CMC edge_silhouette_color;    /*!< DXF 67  */\n  BITCODE_BS edge_silhouette_width;     /*!< DXF 79  */\n  BITCODE_BS edge_halo_gap;             /*!< DXF 170  */\n  BITCODE_BS num_edge_isolines;         /*!< DXF 171  */\n  BITCODE_BS edge_hide_precision_flag;  /*!< DXF 290  */\n  BITCODE_BS edge_style_apply_flag;     /*!< DXF 174  */\n  BITCODE_BS display_style;             /*!< DXF 93  */\n  BITCODE_BD display_brightness;        /*!< DXF 44  */\n  BITCODE_BS display_shadow_type;       /*!< DXF 173  */\n  BITCODE_BS is_internal_use_only;      /*!< DXF 291  */\n  BITCODE_BS unknown_float45;           /*!< DXF 45  */\n\n  //BITCODE_H dictionary; /* (hard-pointer to DICTIONARY_VISUALSTYLE or reverse?) */\n} Dwg_Object_VISUALSTYLE;\n\n/**\n Object LIGHTLIST (varies)\n R2010+\n */\ntypedef struct _dwg_object_LIGHTLIST\n{\n  struct _dwg_object_object *parent;\n\n  BITCODE_H dictionary; /* (hard-pointer to ACAD_LIGHT dictionary entry) */\n  /* TODO */\n  BITCODE_BS class_version;\n  BITCODE_BS num_lights;\n  BITCODE_H*  lights_handles; /* one for each light */\n  BITCODE_TV* lights_names;   /* one for each light */\n} Dwg_Object_LIGHTLIST;\n\n/**\n Object MATERIAL (varies) UNKNOWN FIELDS\n R2007+ yet unused\n\nAcad Naming: e.g. Materials/assetlibrary_base.fbm/shaders/AdskShaders.mi\n                  Materials/assetlibrary_base.fbm/Mats/SolidGlass/Generic.xml\nTODO: maybe separate into the various map structs\n */\ntypedef struct _dwg_object_MATERIAL\n{\n  struct _dwg_object_object *parent;\n\n  BITCODE_T name; /*!< DXF 1 */\n  BITCODE_T desc; /*!< DXF 2 optional */\n\n  BITCODE_BS ambient_color_flag;    /*!< DXF 70 0 Use current color, 1 Override */\n  BITCODE_BD ambient_color_factor;  /*!< DXF 40 0.0 - 1.0 */\n  BITCODE_CMC ambient_color;        /*!< DXF 90 */\n\n  BITCODE_BS diffuse_color_flag;    /*!< DXF 71 0 Use current color, 1 Override */\n  BITCODE_BD diffuse_color_factor;  /*!< DXF 41 0.0 - 1.0 */\n  BITCODE_CMC diffuse_color;        /*!< DXF 91 */\n  BITCODE_BS diffusemap_source;     /*!< DXF 72 0 current, 1 image file (def) */\n  BITCODE_T diffusemap_filename;   /*!< DXF 3 if NULL no diffuse map */\n  BITCODE_BD diffusemap_blendfactor;/*!< DXF 42 def: 1.0 */\n  BITCODE_BS diffusemap_projection; /*!< DXF 73 1 Planar (def), 2 Box, 3 Cylinder, 4 Sphere */\n  BITCODE_BS diffusemap_tiling;     /*!< DXF 74 */ // 1 = Tile (def), 2 = Crop, 3 = Clamp\n  BITCODE_BS diffusemap_autotransform; /*!< DXF 75 */ // 1 no, 2: scale to curr ent,\n                                                      // 4: w/ current block transform\n  BITCODE_BD* diffusemap_transmatrix;  /*!< DXF 43: 16x BD */\n\n  BITCODE_BD specular_gloss_factor; /*!< DXF 44 def: 0.5 */\n  BITCODE_BS specular_color_flag;   /*!< DXF 76 0 Use current color, 1 Override */\n  BITCODE_BD specular_color_factor; /*!< DXF 45 0.0 - 1.0 */\n  BITCODE_CMC specular_color;       /*!< DXF 92 */\n\n  BITCODE_BS specularmap_source;     /*!< DXF 77 0 current, 1 image file (def) */\n  BITCODE_T specularmap_filename;   /*!< DXF 4 if NULL no specular map */\n  BITCODE_BD specularmap_blendfactor;/*!< DXF 46 def: 1.0 */\n  BITCODE_BS specularmap_projection; /*!< DXF 78 1 Planar (def), 2 Box, 3 Cylinder, 4 Sphere */\n  BITCODE_BS specularmap_tiling;       /*!< DXF 79 1 Tile (def), 2 Crop, 3 Clamp */\n  BITCODE_BS specularmap_autotransform;/*!< DXF 170 1 no, 2: scale to curr ent,\n                                                    4: w/ current block transform */\n  BITCODE_BD* specularmap_transmatrix; /*!< DXF 47: 16x BD */\n\n  //?? BD reflection_depth\n  //reflection_glossy_samples\n  BITCODE_BS reflectionmap_source;     /*!< DXF 171 0 current, 1 image file (default) */\n  BITCODE_T reflectionmap_filename;   /*!< DXF 6 if NULL no reflectionmap map */\n  BITCODE_BD reflectionmap_blendfactor;/*!< DXF 48 1.0 */\n  BITCODE_BS reflectionmap_projection; /*!< DXF 172 1 Planar (def), 2 Box, 3 Cylinder, 4 = Sphere */\n  BITCODE_BS reflectionmap_tiling;     /*!< DXF 173 1 Tile (def), 2 Crop, 3 Clamp */\n  BITCODE_BS reflectionmap_autotransform;/*!< DXF 174 */ // 1 no, 2: scale to curr ent,\n                                                         // 4: w/ current block transform\n  BITCODE_BD* reflectionmap_transmatrix; /*!< DXF 49: 16x BD */\n\n  BITCODE_BD opacity_percent;        /*!< DXF 140 def: 1.0 */\n  BITCODE_BS opacitymap_source;      /*!< DXF 175 0 current, 1 image file (def) */\n  BITCODE_T opacitymap_filename;    /*!< DXF 7 */ // if NULL no specular map\n  BITCODE_BD opacitymap_blendfactor; /*!< DXF 141 def: 1.0 */\n  BITCODE_BS opacitymap_projection;  /*!< DXF 176 1 Planar (def), 2 Box, 3 Cylinder, 4 Sphere */\n  BITCODE_BS opacitymap_tiling;        /*!< DXF 177 1 Tile (def), 2 Crop, 3 Clamp */\n  BITCODE_BS opacitymap_autotransform; /*!< DXF 178 */ // 1 no, 2: scale to curr ent,\n                                                       // 4: w/ current block transform\n  BITCODE_BD* opacitymap_transmatrix; /*!< DXF 142: 16x BD */\n\n  //BITCODE_B bump_enable\n  //?BD bump_amount\n  BITCODE_BS bumpmap_source;      /*!< DXF 179 0 current, 1 image file (def) */\n  BITCODE_T bumpmap_filename;    /*!< DXF 8 if NULL no bumpmap (called asset_name) */\n  BITCODE_BD bumpmap_blendfactor; /*!< DXF 143 def: 1.0 */\n  BITCODE_BS bumpmap_projection;  /*!< DXF 270 1 Planar (def), 2 Box, 3 Cylinder, 4 Sphere */\n  BITCODE_BS bumpmap_tiling;        /*!< DXF 271 1 Tile (def), 2 Crop, 3 Clamp */\n  BITCODE_BS bumpmap_autotransform; /*!< DXF 272 */ // 1 no, 2: scale to curr ent,\n                                                    // 4: w/ current block transform\n  BITCODE_BD* bumpmap_transmatrix;  /*!< DXF 144: 16x BD */\n\n  BITCODE_BD refraction_index;       /*!< DXF 145 def: 1.0 */\n  //?? BD refraction_depth\n  //?? BD refraction_translucency_weight\n  //?? refraction_glossy_samples\n  BITCODE_BS refractionmap_source;   /*!< DXF 273 0 current, 1 image file (def) */\n  BITCODE_T refractionmap_filename;  /*!< DXF 9 if NULL no refractionmap */\n  BITCODE_BD refractionmap_blendfactor;/*!< DXF 146 def: 1.0 */\n  BITCODE_BS refractionmap_projection; /*!< DXF 274 1 Planar (def), 2 Box, 3 Cylinder, 4 Sphere */\n  BITCODE_BS refractionmap_tiling;       /*!< DXF 275 1 Tile (def), 2 Crop, 3 Clamp */\n  BITCODE_BS refractionmap_autotransform;/*!< DXF 276 */ // 1 no, 2: scale to curr ent,\n                                                         // 4: w/ current block transform\n  BITCODE_BD* refractionmap_transmatrix; /*!< DXF 147: 16x BD */\n\n  BITCODE_BD color_bleed_scale;    /*!< DXF 460 */\n  BITCODE_BD indirect_dump_scale;  /*!< DXF 461 */\n  BITCODE_BD reflectance_scale;    /*!< DXF 462 */\n  BITCODE_BD transmittance_scale;  /*!< DXF 463 */\n  BITCODE_B two_sided_material;    /*!< DXF 290 */\n  BITCODE_BD luminance;            /*!< DXF 464 */\n  BITCODE_BS luminance_mode;       /*!< DXF 270 */\n  BITCODE_BS normalmap_method;     /*!< DXF 271 */\n  BITCODE_BD normalmap_strength;   /*!< DXF 465 def: 1.0 */\n  BITCODE_BS normalmap_source;     /*!< DXF 72 0 current, 1 image file (default) */\n  BITCODE_T normalmap_filename;   /*!< DXF 3 if NULL no normal map */\n  BITCODE_BD normalmap_blendfactor;/*!< DXF 42 def: 1.0 */\n  BITCODE_BS normalmap_projection; /*!< DXF 73 1 = Planar (def), 2 = Box, 3 = Cylinder, 4 = Sphere */\n  BITCODE_BS normalmap_tiling;     /*!< DXF 74 1 = Tile (def), 2 = Crop, 3 = Clamp */\n  BITCODE_BS normalmap_autotransform; /*!< DXF 75 1 no, 2: scale to curr ent,\n                                                  4: w/ current block transform */\n  BITCODE_BD* normalmap_transmatrix; /*!< DXF 43: 16x BD */\n  BITCODE_B materials_anonymous;     /*!< DXF 293 */\n  BITCODE_BS global_illumination_mode;/*!< DXF 272 */\n  BITCODE_BS final_gather_mode; /*!< DXF 273 */\n  BITCODE_T genprocname;        /*!< DXF 300 */\n  BITCODE_B genprocvalbool;     /*!< DXF 291 */\n  BITCODE_BS genprocvalint;     /*!< DXF 271 */\n  BITCODE_BD genprocvalreal;    /*!< DXF 469 */\n  BITCODE_T genprocvaltext;     /*!< DXF 301 */\n  BITCODE_B genproctableend;    /*!< DXF 292 */\n  BITCODE_CMC genprocvalcolorindex;/*!< DXF 62 */\n  BITCODE_BS genprocvalcolorrgb;/*!< DXF 420 */\n  BITCODE_T genprocvalcolorname;/*!< DXF 430 */\n  BITCODE_BS map_utile;         /*!< DXF 270 */\n  BITCODE_BD translucence;      /*!< DXF 148 */\n  BITCODE_BL self_illumination; /*!< DXF 90 */\n  BITCODE_BD reflectivity;      /*!< DXF 468 */\n  BITCODE_BL illumination_model;/*!< DXF 93 */\n  BITCODE_BL channel_flags;     /*!< DXF 94 */\n  //? BD backface_cull\n  //? BD self_illum_luminance\n  //? BD self_illum_color_temperature\n} Dwg_Object_MATERIAL;\n\n/**\n Object PLOTSETTINGS (varies) UNKNOWN FIELDS\n yet unsorted, and unused. See LAYOUT.\n */\ntypedef struct _dwg_object_PLOTSETTINGS\n{\n  struct _dwg_object_object *parent;\n\n  BITCODE_T page_setup_name;  /*!< DXF 1 */\n  BITCODE_T printer_cfg_file; /*!< DXF 2 */\n  BITCODE_T paper_size;       /*!< DXF 4 */\n  BITCODE_H plotview;         /*!< DXF 6 */\n  BITCODE_BD left_margin;     /*!< DXF 40, margins in mm */\n  BITCODE_BD bottom_margin;   /*!< DXF 42 */\n  BITCODE_BD right_margin;    /*!< DXF 43 */\n  BITCODE_BD top_margin;      /*!< DXF 44 */\n  BITCODE_BD paper_width;     /*!< DXF 44, in mm */\n  BITCODE_BD paper_height;    /*!< DXF 45, in mm */\n  BITCODE_2BD_1 plot_origin;         /*!< DXF 46 */ // + 47\n  BITCODE_2BD_1 plot_window_ll;      /*!< DXF 48 */ // + 49\n  BITCODE_2BD_1 plot_window_ur;      /*!< DXF 140 */ // + 141\n  BITCODE_BD num_custom_print_scale; /*!< DXF 142 */ // in paper units\n  BITCODE_BD den_custom_print_scale; /*!< DXF 143 */ // in drawing units\n  BITCODE_BS plot_layout;    /*!< DXF 70\n                                1 = PlotViewportBorders\n                                2 = ShowPlotStyles\n                                4 = PlotCentered\n                                8 = PlotHidden\n                                16 = UseStandardScale\n                                32 = PlotPlotStyles\n                                64 = ScaleLineweights\n                                128 = PrintLineweights\n                                512 = DrawViewportsFirst\n                                1024 = ModelType\n                                2048 = UpdatePaper\n                                4096 = ZoomToPaperOnUpdate\n                                8192 = Initializing\n                                16384 = PrevPlotInit */\n  BITCODE_BS plot_paper_units; /*!< DXF 72,  0 inches, 1 mm, 2 pixel */\n  BITCODE_BS plot_rotation;    /*!< DXF 73,  0 normal, 1 90, 2 180, 3 270 deg */\n  BITCODE_BS plot_type;        /*!< DXF 74,  0 display, 1 extents, 2 limits, 3 view (see DXF 6),\n                                             4 window (see 48-140), 5 layout */\n  BITCODE_H stylesheet;        /*!< DXF 7 */\n  BITCODE_B use_std_scale;     /*!< DXF 0 */\n  BITCODE_BS std_scale_type; /*!< DXF 75, 0 = scaled to fit,\n                                   1 = 1/128\"=1', 2 = 1/64\"=1', 3 = 1/32\"=1'\n                                   4 = 1/16\"=1', 5 = 3/32\"=1', 6 = 1/8\"=1'\n                                   7 = 3/16\"=1', 8 = 1/4\"=1', 9 = 3/8\"=1'\n                                   10 = 1/2\"=1', 11 = 3/4\"=1', 12 = 1\"=1'\n                                   13 = 3\"=1', 14 = 6\"=1', 15 = 1'=1'\n                                   16 = 1:1, 17= 1:2, 18 = 1:4 19 = 1:8, 20 = 1:10, 21= 1:16\n                                   22 = 1:20, 23 = 1:30, 24 = 1:40, 25 = 1:50, 26 = 1:100\n                                   27 = 2:1, 28 = 4:1, 29 = 8:1, 30 = 10:1, 31 = 100:1, 32 = 1000:1\n                               */\n  BITCODE_BD std_scale_factor; /*!< DXF 147, value of 75 */\n  BITCODE_BS shade_plot_mode;  /*!< DXF 76, 0 display, 1 wireframe, 2 hidden, 3 rendered,\n                                            4 visualstyle, 5 renderPreset */\n  BITCODE_BS shade_plot_res_level; /*!< DXF 77, 0 draft, 1 preview, 2 nomal,\n                                                3 presentation, 4 maximum, 5 custom */\n  BITCODE_BS  shade_plot_custom_dpi; /*!< DXF 78, 100-32767 */\n  BITCODE_2BD_1 paper_image_origin;  /*!< DXF 148 + 149 */\n  BITCODE_H   shade_plot_id;         /*!< DXF 333  optional */\n} Dwg_Object_PLOTSETTINGS;\n\n/**\n Object OBJECT_PTR (varies) UNKNOWN FIELDS\n yet unsorted, and unused.\n */\ntypedef struct _dwg_object_OBJECT_PTR\n{\n  struct _dwg_object_object *parent;\n} Dwg_Object_OBJECT_PTR;\n\n/**\n Entity LIGHT (varies)\n UNSTABLE, almost complete\n */\ntypedef struct _dwg_entity_LIGHT\n{\n  struct _dwg_object_entity *parent;\n\n  BITCODE_BL class_version; /*!< DXF 90 */\n  BITCODE_T name;       /*!< DXF 1 */\n  BITCODE_BS type;      /*!< DXF 70, distant = 1; point = 2; spot = 3 */\n  BITCODE_B status;     /*!< DXF 290, on or off */\n  BITCODE_CMC color;    /*!< DXF 63 + 421 */\n  BITCODE_B plot_glyph; /*!< DXF 291 */\n  BITCODE_BD intensity; /*!< DXF 40 */\n  BITCODE_3BD position; /*!< DXF 10 */\n  BITCODE_3BD target;   /*!< DXF 11 */\n  BITCODE_BS attenuation_type;        /*!< DXF 72 0 = None, 1 = Inverse Linear,\n                                        2 = Inverse Square */\n  BITCODE_B use_attenuation_limits;   /*!< DXF 292 */\n  BITCODE_BD attenuation_start_limit; /*!< DXF 41 */\n  BITCODE_BD attenuation_end_limit;   /*!< DXF 42 */\n  BITCODE_BD hotspot_angle; /*!< DXF 50 */\n  BITCODE_BD falloff_angle; /*!< DXF 51, always stored, used with type=spot only */\n  BITCODE_B cast_shadows;   /*!< DXF 293 */\n  BITCODE_BS shadow_type;   /*!< DXF 73, 0 or 1 */\n  BITCODE_BS shadow_map_size;     /*!< DXF 91 */\n  BITCODE_RC shadow_map_softness; /*!< DXF 280 */\n  BITCODE_H lights_layer;\n#ifdef DEBUG_CLASSES\n  /* yet unknown: */\n  BITCODE_BS lamp_color_type;     /*!< /0: in kelvin, 1: as preset */\n  BITCODE_BD lamp_color_temp;     /*!< Temperature in Kelvin */\n  BITCODE_BS lamp_color_preset;   /*!< 0: D65White, 1: Fluorescent, ... */\n  BITCODE_BL lamp_color_rgb;      /*!< if lamp_color_preset is Custom */\n  BITCODE_TV web_file;            /*!< IES file */\n  BITCODE_3BD web_rotation;       /*!< rotation offset in XYZ Euler angles */\n  BITCODE_B has_target_grip;      /*!< if the light displays a target grip for orienting\n                                       the light */\n  BITCODE_BS glyph_display_type;  /*!< 0:auto, 1:on, 2:off */\n  BITCODE_BS physical_intensity_method; /*!< ? */\n  BITCODE_BS drawable_type;       /*!< ? */\n#endif\n} Dwg_Entity_LIGHT;\n\n/**\n Entity CAMERA (varies) UNKNOWN FIELDS\n not DWG persistent. yet unsorted, and unused.\n */\ntypedef struct _dwg_entity_CAMERA\n{\n  struct _dwg_object_entity *parent;\n  BITCODE_H view;\n} Dwg_Entity_CAMERA;\n\n/**\n Entity GEOPOSITIONMARKER (varies) UNKNOWN FIELDS\n yet unsorted, and unused.\n*/\ntypedef struct _dwg_entity_GEOPOSITIONMARKER\n{\n  struct _dwg_object_entity *parent;\n  BITCODE_BS type;        /*!< point, lat_lon, mylocation */\n  BITCODE_3BD position;   /*!< DXF 10 */\n  BITCODE_BE extrusion;   /*!< DXF 210 */\n  BITCODE_BD radius;      /*!< DXF 40 */\n  BITCODE_BD landing_gap; /*!< DXF 41 */\n  BITCODE_T text;         /*!< DXF 1 */\n  BITCODE_BS text_alignment; /*!< DXF 70  0 left, 1 center, 2 right */\n  BITCODE_B mtext_visible;/*!< DXF ? */\n  BITCODE_B enable_frame_text; /*!< DXF ? */\n  BITCODE_T notes;        /*!< DXF 3 */\n  BITCODE_H mtext_handle; /*!< DXF ? */\n  BITCODE_H text_style;   /*!< DXF 7 */\n} Dwg_Entity_GEOPOSITIONMARKER;\n\n/**\n Object GEOMAPIMAGE (varies), LiveMap image overlay.\n yet unsorted, and unused.\n*/\ntypedef struct _dwg_object_GEOMAPIMAGE\n{\n  struct _dwg_object_object *parent;\n  BITCODE_BL class_version; // 90\n  BITCODE_3BD pt0; // 10\n  BITCODE_2RD size; // 13\n  BITCODE_BS display_props; // 70\n  BITCODE_B clipping; // 280 i.e. clipping_enabled\n  BITCODE_RC brightness; // 281\n  BITCODE_RC contrast; // 282\n  BITCODE_RC fade; // 283\n  BITCODE_BD rotation;\n  //?\n  //BITCODE_3BD origin;\n  BITCODE_BD image_width;\n  BITCODE_BD image_height;\n  BITCODE_T name;\n  BITCODE_BD image_file;\n  BITCODE_BD image_visibility;\n  BITCODE_BS transparency;\n  BITCODE_BD height;\n  BITCODE_BD width;\n  BITCODE_B show_rotation;\n  BITCODE_BD scale_factor;\n  BITCODE_BS geoimage_brightness;\n  BITCODE_BS geoimage_contrast;\n  BITCODE_BS geoimage_fade;\n  BITCODE_BS geoimage_position;\n  BITCODE_BS geoimage_width;\n  BITCODE_BS geoimage_height;\n} Dwg_Object_GEOMAPIMAGE;\n\n/**\n Entity HELIX (varies) UNSTABLE\n subclass of SPLINE\n*/\ntypedef struct _dwg_entity_HELIX\n{\n  struct _dwg_object_entity *parent;\n\n  BITCODE_BS flag; /* computed */\n  BITCODE_BS scenario; /* 1 spline, 2 bezier */\n  BITCODE_BS degree;\n  BITCODE_BL splineflags1; /* 2013+: method fit points = 1, CV frame show = 2, closed = 4 */\n  BITCODE_BL knotparam;    /* 2013+: Chord = 0, Square root = 1, Uniform = 2, Custom = 15 */\n  BITCODE_BD fit_tol;\n  BITCODE_3BD beg_tan_vec;\n  BITCODE_3BD end_tan_vec;\n  BITCODE_B rational;\n  BITCODE_B closed_b;\n  BITCODE_B periodic;\n  BITCODE_B weighted; /* bit 4 of 70 */\n  BITCODE_BD knot_tol;\n  BITCODE_BD ctrl_tol;\n  BITCODE_BS num_fit_pts;\n  Dwg_SPLINE_point* fit_pts;\n  BITCODE_BL num_knots;\n  BITCODE_BD* knots;\n  BITCODE_BL num_ctrl_pts;\n  Dwg_SPLINE_control_point* ctrl_pts;\n\n  BITCODE_BS major_version; //90\n  BITCODE_BS maint_version; //91\n  BITCODE_3BD axis_base_pt; //10\n  BITCODE_3BD start_pt;     //11\n  BITCODE_3BD axis_vector;  //12\n  BITCODE_BD radius;        //40\n  BITCODE_BD num_turns;     //41\n  BITCODE_BD turn_height;   //42\n  BITCODE_B handedness;     //290\n  BITCODE_BS constraint_type; //280\n\n} Dwg_Entity_HELIX;\n\n/**\n Entity EXTRUDEDSURFACE (varies)\n in DXF encrypted.\n*/\ntypedef struct _dwg_entity_EXTRUDEDSURFACE\n{\n  struct _dwg_object_entity *parent;\n  _3DSOLID_FIELDS;\n  //? sweep_profile, taper_angle\n  BITCODE_BS modeler_format_version; /*!< DXF 70 */\n  BITCODE_BL size_bindata; // 90\n  BITCODE_TF bindata; // 310|1\n  BITCODE_BS u_isolines;         /*!< DXF 71 */\n  BITCODE_BS v_isolines;         /*!< DXF 72 */\n  BITCODE_BL class_version; /*!< DXF 90 */\n  //sweep_options?\n  BITCODE_BD height;\n  BITCODE_3BD sweep_vector; /*!< DXF 10 */\n  BITCODE_BD* sweep_transmatrix; /*!< DXF 40: 16x BD */\n  BITCODE_BD draft_angle;   /*!< DXF 42 */\n  BITCODE_BD draft_start_distance; /*!< DXF 43 */\n  BITCODE_BD draft_end_distance;   /*!< DXF 44 */\n  BITCODE_BD twist_angle;   /*!< DXF 45 */\n  BITCODE_BD scale_factor;  /*!< DXF 48 */\n  BITCODE_BD align_angle;   /*!< DXF 49 */\n  BITCODE_BD* sweep_entity_transmatrix; /*!< DXF 46: 16x BD */\n  BITCODE_BD* path_entity_transmatrix;  /*!< DXF 47: 16x BD */\n  BITCODE_B solid;          /*!< DXF 290 */\n  BITCODE_BS sweep_alignment_flags; /*!< DXF 290.\n                                      0=No alignment, 1=Align sweep entity to path,\n                                      2=Translate sweep entity to path,\n                                      3=Translate path to sweep entity */\n  BITCODE_B align_start;                        /*!< DXF 292 */\n  BITCODE_B bank;                               /*!< DXF 293 */\n  BITCODE_B base_point_set;                     /*!< DXF 294 */\n  BITCODE_B sweep_entity_transform_computed;    /*!< DXF 295 */\n  BITCODE_B path_entity_transform_computed;     /*!< DXF 296 */\n  BITCODE_3BD reference_vector_for_controlling_twist; /*!< DXF 11 */\n  BITCODE_H sweep_entity;\n  BITCODE_H path_entity;\n} Dwg_Entity_EXTRUDEDSURFACE;\n\n/**\n Entity LOFTEDSURFACE (varies)\n*/\ntypedef struct _dwg_entity_LOFTEDSURFACE\n{\n  struct _dwg_object_entity *parent;\n  _3DSOLID_FIELDS;\n  BITCODE_BS modeler_format_version; /*!< DXF 70 */\n  BITCODE_BS u_isolines;         /*!< DXF 71 */\n  BITCODE_BS v_isolines;         /*!< DXF 72 */\n  //BITCODE_BL class_version;      /*!< DXF 90 */\n  BITCODE_BD* loft_entity_transmatrix; /*!< DXF 40: 16x BD */\n  BITCODE_BL plane_normal_lofting_type; /*!< DXF 70 */\n  BITCODE_BD start_draft_angle;     /*!< DXF 41 */\n  BITCODE_BD end_draft_angle;       /*!< DXF 42 */\n  BITCODE_BD start_draft_magnitude; /*!< DXF 43 */\n  BITCODE_BD end_draft_magnitude;   /*!< DXF 44 */\n  BITCODE_B arc_length_parameterization; // 290\n  BITCODE_B no_twist; // 291\n  BITCODE_B align_direction; // 292\n  BITCODE_B simple_surfaces; // 293\n  BITCODE_B closed_surfaces; // 294\n  BITCODE_B solid; // 295\n  BITCODE_B ruled_surface; // 296\n  BITCODE_B virtual_guide; // 297\n\n  BITCODE_BS num_cross_sections;\n  BITCODE_BS num_guide_curves;\n  BITCODE_H *cross_sections;\n  BITCODE_H *guide_curves;\n  BITCODE_H path_curve;\n} Dwg_Entity_LOFTEDSURFACE;\n\n/**\n Entity PLANESURFACE (varies)\n*/\ntypedef struct _dwg_entity_PLANESURFACE\n{\n  struct _dwg_object_entity *parent;\n  _3DSOLID_FIELDS;\n  BITCODE_BS modeler_format_version; /*!< DXF 70 */\n  BITCODE_BS u_isolines;         /*!< DXF 71 */\n  BITCODE_BS v_isolines;         /*!< DXF 72 */\n  BITCODE_BL class_version;      /*!< DXF 90 */\n\n} Dwg_Entity_PLANESURFACE;\n\n/**\n Entity REVOLVEDSURFACE (varies)\n*/\ntypedef struct _dwg_entity_REVOLVEDSURFACE\n{\n  struct _dwg_object_entity *parent;\n  _3DSOLID_FIELDS;\n  BITCODE_BS modeler_format_version; /*!< DXF 70 */\n  BITCODE_BS u_isolines;         /*!< DXF 71 */\n  BITCODE_BS v_isolines;         /*!< DXF 72 */\n  BITCODE_BL class_version; /*!< DXF 90 */\n\n  BITCODE_BL id; // 90\n  BITCODE_3BD axis_point; // 10\n  BITCODE_3BD axis_vector; // 11\n  BITCODE_BD revolve_angle; // 40\n  BITCODE_BD start_angle; // 41\n  BITCODE_BD* revolved_entity_transmatrix; // 42\n  BITCODE_BD draft_angle; // 43\n  BITCODE_BD draft_start_distance; // 44\n  BITCODE_BD draft_end_distance; // 45\n  BITCODE_BD twist_angle; // 46\n  BITCODE_B solid; // 290\n  BITCODE_B close_to_axis; // 291\n\n} Dwg_Entity_REVOLVEDSURFACE;\n\n/**\n Entity SWEPTSURFACE (varies)\n*/\ntypedef struct _dwg_entity_SWEPTSURFACE\n{\n  struct _dwg_object_entity *parent;\n  _3DSOLID_FIELDS;\n  BITCODE_BS modeler_format_version; /*!< DXF 70 */\n  BITCODE_BS u_isolines;         /*!< DXF 71 */\n  BITCODE_BS v_isolines;         /*!< DXF 72 */\n  BITCODE_BL class_version; /*!< DXF 90 */\n\n  BITCODE_BL sweep_entity_id; // 90\n  BITCODE_BL size_sweepdata; // 90\n  BITCODE_TF sweepdata; // 310\n  BITCODE_BL path_entity_id; // 90\n  BITCODE_BL size_pathdata; // 90\n  BITCODE_TF pathdata; // 310\n  BITCODE_BD* sweep_entity_transmatrix; // 40\n  BITCODE_BD* path_entity_transmatrix; // 41\n  BITCODE_BD draft_angle; // 42\n  BITCODE_BD draft_start_distance; // 43\n  BITCODE_BD draft_end_distance; // 44\n  BITCODE_BD twist_angle; // 45\n  BITCODE_BD* sweep_entity_transmatrix1; // 46\n  BITCODE_BD* path_entity_transmatrix1; // 47\n  BITCODE_BD scale_factor; // 48\n  BITCODE_BD align_angle; // 49\n  BITCODE_B solid; // 290\n  BITCODE_RC sweep_alignment; // 70\n  BITCODE_B align_start; // 292\n  BITCODE_B bank; // 293\n  BITCODE_B base_point_set; // 294\n  BITCODE_B sweep_entity_transform_computed; // 295\n  BITCODE_B path_entity_transform_computed; // 296\n  BITCODE_3BD reference_vector_for_controlling_twist; // 11\n\n} Dwg_Entity_SWEPTSURFACE;\n\n/**\n Entity MESH (varies)\n Types: Sphere|Cylinder|Cone|Torus|Box|Wedge|Pyramid\n --enable-debug only, unknown fields\n*/\ntypedef struct _dwg_MESH_edge\n{\n  struct _dwg_entity_MESH *parent;\n  BITCODE_BL from;\n  BITCODE_BL to;\n} Dwg_MESH_edge;\n\ntypedef struct _dwg_entity_MESH\n{\n  struct _dwg_object_entity *parent;\n  //_3DSOLID_FIELDS;\n  BITCODE_BL class_version;\t/*!< DXF 90 */\n\n  BITCODE_RC dlevel; \t\t/*!< DXF 71 (2) */\n  BITCODE_RC is_watertight; \t/*!< DXF 72 (0) */\n  BITCODE_BL num_subdiv_vertex; /*!< DXF 91 ?? */\n  BITCODE_3BD* subdiv_vertex; \t/*!< DXF 10 ?? */\n  BITCODE_BL num_vertex;  \t/*!< DXF 92 */\n  BITCODE_3BD* vertex; \t\t/*!< DXF 10 */\n  BITCODE_BL num_faces;  \t/*!< DXF 93 */\n  BITCODE_BL* faces;  \t        /*!< DXF 90 */\n  BITCODE_BL num_edges;  \t/*!< DXF 94 */\n  Dwg_MESH_edge* edges;   \t/*!< DXF 90 */\n  BITCODE_BL num_crease;  \t/*!< DXF 95 */\n  BITCODE_BD* crease;   \t/*!< DXF 140 */\n\n} Dwg_Entity_MESH;\n\n/**\n Object SUN (varies) UNKNOWN FIELDS\n wrongly documented by ACAD DXF as entity\n --enable-debug only, unknown fields\n */\ntypedef struct _dwg_object_SUN\n{\n  struct _dwg_object_object *parent;\n\n  BITCODE_BL class_version; //90\n  BITCODE_B is_on;   // 290\n  BITCODE_BS unknown; //421\n  BITCODE_CMC color; // 60\n  BITCODE_BD intensity; // 40\n  //BITCODE_3BD direction; //calculated?\n  //BITCODE_BD altitude;   //calculated?\n  //BITCODE_BD azimuth;    //calculated?\n  BITCODE_BL julian_day; //91\n  BITCODE_BL time;       //92\n  BITCODE_B  is_dst;     //292\n  BITCODE_B has_shadow;  //291\n  BITCODE_BS shadow_type;     //70\n  BITCODE_BS shadow_mapsize;  //71\n  BITCODE_BS shadow_softness; //280\n\n  // 11.3 bytes missing, from UNKNOWN_OBJ\n  BITCODE_H skyparams;\n} Dwg_Object_SUN;\n\ntypedef struct _dwg_SUNSTUDY_Dates\n{\n  BITCODE_BL julian_day;\n  BITCODE_BL time; //seconds past midnight\n} Dwg_SUNSTUDY_Dates;\n\n/**\n Object SUNSTUDY (varies) UNKNOWN FIELDS\n --enable-debug only\n */\ntypedef struct _dwg_object_SUNSTUDY\n{\n  struct _dwg_object_object *parent;\n\n  BITCODE_BL class_version;    //90\n  BITCODE_T setup_name;        //1\n  BITCODE_T desc;              //2\n  BITCODE_BL output_type;      //70\n  BITCODE_T sheet_set_name;    //3\n  BITCODE_B use_subset;        //290\n  BITCODE_T sheet_subset_name; //3\n  BITCODE_B select_dates_from_calendar; //291\n  BITCODE_BL num_dates;   //91\n  Dwg_SUNSTUDY_Dates* dates; //90+90[]\n  BITCODE_B select_range_of_dates; //292\n  BITCODE_BL start_time;  //93\n  BITCODE_BL end_time;    //94\n  BITCODE_BL interval;    //95\n  BITCODE_BL num_hours;   //73\n  BITCODE_B* hours;       //290\n  BITCODE_BL shade_plot_type;  //74\n  BITCODE_BL numvports;        //75\n  BITCODE_BL numrows;        //76\n  BITCODE_BL numcols;        //77\n  BITCODE_BD spacing;        //40\n  BITCODE_B  lock_viewports; //293\n  BITCODE_B  label_viewports; //294\n\n  BITCODE_H  page_setup_wizard; //5. 340\n  BITCODE_H  view;         //341\n  BITCODE_H  visualstyle;  //342\n  BITCODE_H  text_style;   //343\n} Dwg_Object_SUNSTUDY;\n\n/**\n Object DATATABLE (varies) UNKNOWN FIELDS\n --enable-debug only\n */\ntypedef struct _dwg_object_DATATABLE\n{\n  struct _dwg_object_object *parent;\n  //...\n} Dwg_Object_DATATABLE;\n\n/**\n Object DIMASSOC (varies) DEBUGGING\n --enable-debug only\n */\ntypedef struct _dwg_DIMASSOC_ref\n{\n  struct _dwg_object_DIMASSOC *parent;\n  BITCODE_BS rotated_type;    /*!< DXF 71 */\n  BITCODE_RC osnap_type;      /*!< DXF 72 */\n  BITCODE_TV classname;       /*!< DXF 1 */\n  BITCODE_BS main_subent_type; /*!< DXF 73 */\n  BITCODE_BS intsect_subent_type; /*!< DXF 74 */\n  BITCODE_BL main_gsmarker;   /*!< DXF 91 */\n  BITCODE_BD osnap_dist;      /*!< DXF 40 */\n  BITCODE_3BD osnap_pt;       /*!< DXF 10 */\n  BITCODE_B has_lastpt_ref;   /*!< DXF 75 */\n  BITCODE_H mainobj;          /*!< DXF 331 the geometry object */\n  BITCODE_H intsectobj;       /*!< DXF 332 the intersection object */\n} Dwg_DIMASSOC_Ref;\n\ntypedef struct _dwg_object_DIMASSOC\n{\n  struct _dwg_object_object *parent;\n  BITCODE_BL associativity;   /*!< DXF 90 */\n  BITCODE_RC trans_space_flag;/*!< DXF 70 */\n  Dwg_DIMASSOC_Ref *ref;       /* 1-4x, with possible holes,\n                                  depend. on associativity bitmask */\n  BITCODE_BL intsect_gsmarker; /*!< DXF 92 */\n  //BITCODE_H dimensionobj;     /*!< DXF 330 */\n  //BITCODE_H xrefobj;          /*!< DXF 301 */\n  //BITCODE_H intsectxrefobj;   /*!< DXF 302 */\n} Dwg_Object_DIMASSOC;\n\ntypedef struct _dwg_ACTIONBODY\n{\n  struct _dwg_object_ASSOCNETWORK *parent;\n  BITCODE_T  evaluatorid;\n  BITCODE_T  expression;\n  BITCODE_BL value; //resbuf\n} Dwg_ACTIONBODY;\n\n#define ASSOCACTION_fields \\\n  BITCODE_BL solution_status; /* 90 */ \\\n  BITCODE_BL geometry_status; /* 90 */ \\\n  BITCODE_H readdep;          /* 330 */ \\\n  BITCODE_H writedep;         /* 360 */ \\\n  BITCODE_BL constraint_status; /* 90 */ \\\n  BITCODE_BL dof;               /* 90 */ \\\n  BITCODE_B  is_body_a_proxy    /* 90 */\n\ntypedef struct _dwg_object_ASSOCACTION\n{\n  struct _dwg_object_object *parent;\n  ASSOCACTION_fields;\n\n  BITCODE_BL num_deps;    /* 90 */\n  //BITCODE_B is_actionevaluation_in_progress; // 90\n  Dwg_ACTIONBODY body;\n  BITCODE_BL status;\n  BITCODE_H  actionbody;\n  BITCODE_H  callback;\n  BITCODE_H  owningnetwork;\n} Dwg_Object_ASSOCACTION;\n\ntypedef struct _dwg_object_ASSOCDEPENDENCY\n{\n  struct _dwg_object_object *parent;\n  BITCODE_BL class_version; // 90\n  BITCODE_BL status; // 90\n  BITCODE_B isread_dep; // 290\n  BITCODE_B iswrite_dep; // 290\n  BITCODE_B isobjectstate_dep; // 290\n  BITCODE_B unknown_b4; // 290\n  BITCODE_BL order; // 90 -2147483648\n  BITCODE_B unknown_b5; // 290\n  BITCODE_BL depbodyid; // 90\n\n  BITCODE_H  owner; // 330\n  BITCODE_H  readdep; // 330\n  BITCODE_H  writedep; // 360\n  BITCODE_H  node; // 330\n} Dwg_Object_ASSOCDEPENDENCY;\n\ntypedef struct _dwg_object_ASSOCALIGNEDDIMACTIONBODY\n{\n  struct _dwg_object_object *parent;\n  BITCODE_BL aab_status; // 90\n  BITCODE_BL pab_status; // 90:0\n  BITCODE_BL pab_l2; // 90:0\n  BITCODE_BL pab_l3; // 90:1\n  BITCODE_H  writedep; // 360\n  BITCODE_BL pab_l4; // 90:0\n  BITCODE_BL pab_l5; // 90:0\n  BITCODE_BL pab_l6; // 90:0\n  BITCODE_H  readdep; // 330\n  BITCODE_BL dcm_status; // 90:0\n  BITCODE_H  d_node; // 330\n  BITCODE_H  r_node; // 330\n} Dwg_Object_ASSOCALIGNEDDIMACTIONBODY;\n\n/**\n Object ASSOCNETWORK (varies) UNKNOWN FIELDS\n subclass of AcDbAssocAction\n Object1 --ReadDep--> Action1 --WriteDep1--> Object2 --ReadDep--> Action2 ...\n */\ntypedef struct _dwg_object_ASSOCNETWORK\n{\n  struct _dwg_object_object *parent;\n  ASSOCACTION_fields;\n  //BITCODE_H assocaction;\n  //or inlined:\n  //90:2 90:0 330:0 360:0 7x90:0\n  //BITCODE_BL num_deps; // 90\n\n  BITCODE_BL unknown_assoc; // 90\n  //90, 90, [90, 330], 90\n  BITCODE_BL unknown_n1; // 90 0\n  BITCODE_BL unknown_n2; // 90 1\n  BITCODE_BL num_actions;// 90 1\n  BITCODE_H* actions;    // 360\n  //BITCODE_BL unknown_n3; // 90 0\n} Dwg_Object_ASSOCNETWORK;\n\n/**\n Object ASSOCOSNAPPOINTREFACTIONPARAM (varies) UNKNOWN FIELDS\n Action parameter that owns other AcDbAssocActionParameters,\n allowing the representation of hierarchical structures of action parameters.\n */\ntypedef struct _dwg_object_ASSOCOSNAPPOINTREFACTIONPARAM\n{\n  struct _dwg_object_object *parent;\n  // AcDbAssocActionParam\n  BITCODE_RC unknown;  // 01010101\n  BITCODE_B unknown1;  //\n  BITCODE_BS status;   // 90: 0 uptodate, 1 changed_directly, 2 changed_transitive,\n                       // 3 ChangedNoDifference, 4 FailedToEvaluate, 5 Erased, 6 Suppressed\n                       // 7 Unresolved\n  BITCODE_T  name;     // 1 \"\"\n  BITCODE_RS flags;    // 90 0\n  // AcDbAssocCompoundActionParam\n  BITCODE_BD unknown3; // 40 -1.0\n  BITCODE_BS num_params; // 90 1\n  BITCODE_H actionparam;  // 330\n  BITCODE_H writedep; // 360\n} Dwg_Object_ASSOCOSNAPPOINTREFACTIONPARAM;\n\ntypedef struct _dwg_object_ASSOC2DCONSTRAINTGROUP\n{\n  struct _dwg_object_object *parent;\n  ASSOCACTION_fields;\n\n  BITCODE_BL l5; //90 1\n  BITCODE_B  b1; //70 0\n  BITCODE_3BD workplane[3]; //3x10 workplane\n  // 360\n  BITCODE_BL l6; //90 2\n  // 360 360\n  BITCODE_BL l7; //90 9\n  BITCODE_BL l8; //90 9\n\n  BITCODE_BL cl1; //90 1\n  BITCODE_RC cs1; //70 1\n  BITCODE_BL cl2; //90 1\n  BITCODE_BL cl3; //90 3\n  BITCODE_BL cl4; //90 0\n  BITCODE_3BD c1; //10 @134\n  BITCODE_3BD c2; //10\n  BITCODE_3BD c3; //10\n  BITCODE_BD w1; //40\n  BITCODE_BD w2; //40\n  BITCODE_BD w3; //40\n} Dwg_Object_ASSOC2DCONSTRAINTGROUP;\n\n/* or maybe the nodes are laid out like this */\ntypedef struct _dwg_EVAL_Node\n{\n  struct _dwg_object_EVALUATION_GRAPH *parent;\n  BITCODE_BL  edge[4];   // 4x 92, def: 4x -1\n  //BITCODE_H   evalexpr;   // 360\n} Dwg_EVAL_Node;\n\ntypedef struct _dwg_object_EVALUATION_GRAPH\n{\n  struct _dwg_object_object *parent;\n  BITCODE_BL has_graph;   // 96\n  BITCODE_BL unknown1;    // 97\n  BITCODE_BL unknown2;\n  BITCODE_BL nodeid;      // 91\n  BITCODE_BL edge_flags;  // 93\n  BITCODE_BL num_evalexpr;// 95\n  BITCODE_BL node_edge1;  // 92\n  BITCODE_BL node_edge2;  // 92\n  BITCODE_BL node_edge3;  // 92\n  BITCODE_BL node_edge4;  // 92\n  BITCODE_H  *evalexpr;    //360\n} Dwg_Object_EVALUATION_GRAPH;\n\n// UNSTABLE\ntypedef struct _dwg_object_DYNAMICBLOCKPURGEPREVENTER\n{\n  struct _dwg_object_object *parent;\n  BITCODE_BS flag;         /*!< DXF 70 0 */\n  BITCODE_RS unknown_rs1;\n} Dwg_Object_DYNAMICBLOCKPURGEPREVENTER;\n\ntypedef struct _dwg_object_PERSSUBENTMANAGER\n{\n  struct _dwg_object_object *parent;\n  BITCODE_BL class_version; /*!< DXF 90 2 */\n  BITCODE_BL unknown_bl1;   /*!< DXF 90 0 */\n  BITCODE_BL unknown_bl2;   /*!< DXF 90 2 */\n  BITCODE_BL unknown_bl3;   /*!< DXF 90 3 */\n  BITCODE_BL unknown_bl4;   /*!< DXF 90 0 */\n  BITCODE_BL unknown_bl5;   /*!< DXF 90 1 */\n  BITCODE_BL unknown_bl6;   /*!< DXF 90 1 */\n} Dwg_Object_PERSSUBENTMANAGER;\n\ntypedef struct _dwg_object_ASSOCPERSSUBENTMANAGER\n{\n  struct _dwg_object_object *parent;\n  BITCODE_BL class_version; /*!< DXF 90 1 */\n  BITCODE_BL unknown_bl1;   /*!< DXF 90 3 */\n  BITCODE_BL unknown_bl2;   /*!< DXF 90 0 */\n  BITCODE_BL unknown_bl3;   /*!< DXF 90 2 */\n  BITCODE_BL unknown_bl4;   /*!< DXF 90 3 */\n  BITCODE_BL unknown_bl5;   /*!< DXF 90 1 */\n  BITCODE_BL unknown_bl6;   /*!< DXF 90 5 */\n  BITCODE_BL unknown_bl6a;  /*!< DXF 90 0 */\n  BITCODE_BL unknown_bl7a;  /*!< DXF 90 3 */\n  BITCODE_BL unknown_bl7;   /*!< DXF 90 2 */\n  BITCODE_BL unknown_bl8;   /*!< DXF 90 2 */\n  BITCODE_BL unknown_bl9;   /*!< DXF 90 2 */\n  BITCODE_BL unknown_bl10;  /*!< DXF 90 21 */\n  BITCODE_BL unknown_bl11;  /*!< DXF 90 0 */\n  BITCODE_BL unknown_bl12;  /*!< DXF 90 0 */\n  BITCODE_BL unknown_bl13;  /*!< DXF 90 0 */\n  BITCODE_BL unknown_bl14;  /*!< DXF 90 0 */\n  BITCODE_BL unknown_bl15;  /*!< DXF 90 1 */\n  BITCODE_BL unknown_bl16;  /*!< DXF 90 3 */\n  BITCODE_BL unknown_bl17;  /*!< DXF 90 1 */\n  BITCODE_BL unknown_bl18;  /*!< DXF 90 1000000000 */\n  BITCODE_BL unknown_bl19;  /*!< DXF 90 1001 */\n  BITCODE_BL unknown_bl20;  /*!< DXF 90 1 */\n  BITCODE_BL unknown_bl21;  /*!< DXF 90 1000000000 */\n  BITCODE_BL unknown_bl22;  /*!< DXF 90 51001 */\n  BITCODE_BL unknown_bl23;  /*!< DXF 90 1 */\n  BITCODE_BL unknown_bl24;  /*!< DXF 90 1000000000 */\n  BITCODE_BL unknown_bl25;  /*!< DXF 90 351001 */\n  BITCODE_BL unknown_bl26;  /*!< DXF 90 0 */\n  BITCODE_BL unknown_bl27;  /*!< DXF 90 0 */\n  BITCODE_BL unknown_bl28;  /*!< DXF 90 0 */\n  BITCODE_BL unknown_bl29;  /*!< DXF 90 900 */\n  BITCODE_BL unknown_bl30;  /*!< DXF 90 0 */\n  BITCODE_BL unknown_bl31;  /*!< DXF 90 900 */\n  BITCODE_BL unknown_bl32;  /*!< DXF 90 0 */\n  BITCODE_BL unknown_bl33;  /*!< DXF 90 2 */\n  BITCODE_BL unknown_bl34;  /*!< DXF 90 2 */\n  BITCODE_BL unknown_bl35;  /*!< DXF 90 3 0100000011 */\n  BITCODE_BL unknown_bl36;  /*!< DXF 90 0 */\n  BITCODE_B  unknown_b37;   /*!< DXF 290 0 */\n} Dwg_Object_ASSOCPERSSUBENTMANAGER;\n\ntypedef struct _dwg_object_ASSOCPLANESURFACEACTIONBODY\n{\n  struct _dwg_object_object *parent;\n  // AcDbAssocActionBody\n  BITCODE_BL aab_status; // 90\n  // AcDbAssocParamBasedActionBody\n  BITCODE_BL pab_status; // 90:0\n  BITCODE_BL pab_l2; // 90:0\n  BITCODE_BL pab_l3; // 90:1\n  BITCODE_H  writedep; // 360\n  BITCODE_BL pab_l4; // 90:0\n  BITCODE_BL pab_l5; // 90:0\n  BITCODE_H  readdep; // 330\n  // AcDbAssocSurfaceActionBody\n  BITCODE_BL sab_status;/*!< DXF 90  */\n  BITCODE_B sab_b1;     /*!< DXF 290  */\n  BITCODE_BL sab_l2;    /*!< DXF 90  */\n  BITCODE_B sab_b2;     /*!< DXF 290  */\n  BITCODE_BS sab_s1;    /*!< DXF 70  */\n  // AcDbAssocPathBasedSurfaceActionBody\n  BITCODE_BL pbsab_status;      /*!< DXF 90  */\n  // AcDbAssocPlaneSurfaceActionBody\n  BITCODE_BL psab_status;       /*!< DXF 90  */\n\n} Dwg_Object_ASSOCPLANESURFACEACTIONBODY;\n\ntypedef struct _dwg_object_ACSH_SWEEP_CLASS\n{\n  struct _dwg_object_object *parent;\n  // AcDbEvalExpr\n  BITCODE_BL class_version; // 90\n  BITCODE_BL ee_bl98; //98\n  BITCODE_BL ee_bl99; //99\n  // AcDbShHistoryNode\n  BITCODE_BL shhn_bl98; //98\n  BITCODE_BL shhn_bl99; //99\n  BITCODE_BD* shhn_pts; //last 16x nums 40-55\n  BITCODE_CMC color; /*!< DXF 62 */\n  BITCODE_B  shhn_b92; /*!< DXF 92 */\n  BITCODE_BL shhn_bl347; /*!< DXF 347 */\n\n  // AcDbShPrimitive\n  // AcDbShSweepBase\n  BITCODE_BL shsw_bl90;       /*!< DXF 90 */\n  BITCODE_BL shsw_bl91;       /*!< DXF 91 */\n  BITCODE_3BD basept;         /*!< DXF 10 */\n  BITCODE_BL shsw_bl92;       /*!< DXF 92 */\n  BITCODE_BL shsw_size_text;  /*!< DXF 90 */\n  BITCODE_TF shsw_text;       /*!< DXF 310 */\n  BITCODE_BL shsw_bl93;       /*!< DXF 93 */\n  BITCODE_BL shsw_size_text2; /*!< DXF 90 */\n  BITCODE_TF shsw_text2;      /*!< DXF 310 */\n  BITCODE_BD draft_angle;       /*!< DXF 42 0.0 */\n  BITCODE_BD start_draft_dist;  /*!< DXF 43 0.0 */\n  BITCODE_BD end_draft_dist;    /*!< DXF 44 0.0 */\n  BITCODE_BD scale_factor;      /*!< DXF 45 1.0 */\n  BITCODE_BD twist_angle;       /*!< DXF 48 0.0 */\n  BITCODE_BD align_angle;       /*!< DXF 49 0.0 */\n  BITCODE_BD* sweepentity_transform; /*!< DXF 46 16x */\n  BITCODE_BD* pathentity_transform;  /*!< DXF 47 16x */\n  BITCODE_RC align_option;      /*!< DXF 70 2 */\n  BITCODE_RC miter_option;      /*!< DXF 71 2 */\n  BITCODE_B has_align_start;    /*!< DXF 290 1 */\n  BITCODE_B bank;       /*!< DXF 292 1 */\n  BITCODE_B check_intersections; /*!< DXF 293 0 */\n  BITCODE_B shsw_b294;  /*!< DXF 294  1 */\n  BITCODE_B shsw_b295;  /*!< DXF 295  1 */\n  BITCODE_B shsw_b296;  /*!< DXF 296  1 */\n  BITCODE_3BD pt2;      /*!< DXF 11 0,0,0 */\n\n  // AcDbShSweep\n\n} Dwg_Object_ACSH_SWEEP_CLASS;\n\ntypedef struct _dwg_object_NAVISWORKSMODELDEF\n{\n  struct _dwg_object_object *parent;\n\n  // AcDbNavisworksModelDef\n  BITCODE_T path;       /*!< DXF 1 */\n  BITCODE_B status;     /*!< DXF 290 */\n  BITCODE_3BD min_extent; /*!< DXF 10 */\n  BITCODE_3BD max_extent; /*!< DXF 11 */\n  BITCODE_B host_drawing_visibility; /*!< DXF 290 */\n\n} Dwg_Object_NAVISWORKSMODELDEF;\n\n/**\n Class RENDERENVIRONMENT (varies)\n */\ntypedef struct _dwg_object_RENDERENVIRONMENT\n{\n  struct _dwg_object_object *parent;\n\n  BITCODE_BL class_version;     /*!< DXF 90, default: 1 */\n  BITCODE_B fog_enabled;        /*!< DXF 290 */\n  BITCODE_B fog_background_enabled;  /*!< DXF 290 */\n  BITCODE_CMC fog_color;        /*!< DXF 280 */\n  BITCODE_BD fog_density_near;  /*!< DXF 40 */\n  BITCODE_BD fog_density_far;   /*!< DXF 40 */\n  BITCODE_BD fog_distance_near;     /*!< DXF 40 */\n  BITCODE_BD fog_distance_far;      /*!< DXF 40 */\n  BITCODE_B environ_image_enabled;  /*!< DXF 290 */\n  BITCODE_T environ_image_filename; /*!< DXF 1 */\n} Dwg_Object_RENDERENVIRONMENT;\n\n/**\n Class RENDERENVIRONMENT (varies)\n */\ntypedef struct _dwg_object_RENDERGLOBAL\n{\n  struct _dwg_object_object *parent;\n\n  BITCODE_BL class_version;    /*!< DXF 90 */\n  BITCODE_BL procedure;        /*!< DXF 90 */\n  BITCODE_BL destination;      /*!< DXF 90 */\n  BITCODE_B save_enabled;      /*!< DXF 290 */\n  BITCODE_T save_filename;     /*!< DXF 1 */\n  BITCODE_BL image_width;      /*!< DXF 90 */\n  BITCODE_BL image_height;     /*!< DXF 90 */\n  BITCODE_B predef_presets_first; /*!< DXF 290 */\n  BITCODE_B highlevel_info;    /*!< DXF 290 */\n} Dwg_Object_RENDERGLOBAL;\n\n/**\n * Class AcDbAnnotScaleObjectContextData (varies)\n * for MTEXT, MLEADER, LEADER, BLKREF, ALDIM (AlignedDimension), ...\n * R2010+\n */\ntypedef struct _dwg_object_ANNOTSCALEOBJECTCONTEXTDATA\n{\n  struct _dwg_object_object *parent;\n\n  BITCODE_BS class_version; /*!< r2010+ =3 */\n  BITCODE_B has_file;\n  BITCODE_B defaultflag;\n  BITCODE_H scale; /* DXF 340 */\n  // 70\n  // 10\n  // 11\n  // 40\n  // 41\n  // 42\n  // 43\n  // 71\n  // 72\n  // 44\n  // 45\n  // 73\n  // 74\n  // 46\n} Dwg_Object_ANNOTSCALEOBJECTCONTEXTDATA;\n\n/**\n -----------------------------------\n */\n\n/**\n Unknown Class entity, a blob\n */\ntypedef struct _dwg_entity_UNKNOWN_ENT\n{\n  struct _dwg_object_entity *parent;\n} Dwg_Entity_UNKNOWN_ENT;\n\n/**\n Unknown Class object, a blob\n */\ntypedef struct _dwg_object_UNKNOWN_OBJ\n{\n  struct _dwg_object_object *parent;\n} Dwg_Object_UNKNOWN_OBJ;\n\n/* OBJECTS - END ************************************************************/\n\n/**\n Extended entity data: dxf group - value pairs, similar to xdata\n */\n#pragma pack(1)\ntypedef struct _dwg_entity_eed_data\n{\n  BITCODE_RC code;\n  union eed_data_t {\n    struct { /* 0 (1000) string */\n      BITCODE_RC length;\n      BITCODE_RS codepage;\n      char string[1];      /* inlined */\n    } eed_0;\n    struct { /* R2007+ 0 (1000) string */\n      BITCODE_RS length;\n      DWGCHAR string[1]; /* inlined */\n    } eed_0_r2007;\n    struct { /* 1 (1001) invalid */\n      char invalid[1]; // set the eed[0].handle to the used APPID instead\n    } eed_1;\n    struct { /* 2 (1002) { or } */\n      BITCODE_RC byte;\n    } eed_2;\n    struct { /* 3 (1003) layer */\n      BITCODE_RL layer;\n    } eed_3;\n    struct { /* 4 (1004) binary */\n      BITCODE_RC length;\n      char data[1];\n    } eed_4;\n    struct { /* 5 (1005) entity */\n      BITCODE_RLL entity;\n    } eed_5;\n    struct { /* 10-13 point */\n      BITCODE_3RD point;\n    } eed_10;\n    struct { /* 40-42 real */\n      BITCODE_RD real;\n    } eed_40;\n    struct { /* 70 short int */\n      BITCODE_RS rs;\n    } eed_70;\n    struct { /* 71 long int */\n      BITCODE_RL rl;\n    } eed_71;\n  } u;\n} Dwg_Eed_Data;\n#pragma pack()\n\n/**\n Extended entity data\n */\ntypedef struct _dwg_entity_eed\n{\n  BITCODE_BS size;\n  Dwg_Handle handle;\n  Dwg_Eed_Data *data;\n  char* raw; /* a copy of data */\n} Dwg_Eed;\n\n/**\n Common entity attributes\n */\ntypedef struct _dwg_object_entity\n{\n  BITCODE_BL objid; /*<! link to the parent */\n  union\n  {\n    Dwg_Entity_UNUSED *UNUSED;\n    Dwg_Entity_TEXT *TEXT;\n    Dwg_Entity_ATTRIB *ATTRIB;\n    Dwg_Entity_ATTDEF *ATTDEF;\n    Dwg_Entity_BLOCK *BLOCK;\n    Dwg_Entity_ENDBLK *ENDBLK;\n    Dwg_Entity_SEQEND *SEQEND;\n    Dwg_Entity_INSERT *INSERT;\n    Dwg_Entity_MINSERT *MINSERT;\n    Dwg_Entity_VERTEX_2D *VERTEX_2D;\n    Dwg_Entity_VERTEX_3D *VERTEX_3D;\n    Dwg_Entity_VERTEX_MESH *VERTEX_MESH;\n    Dwg_Entity_VERTEX_PFACE *VERTEX_PFACE;\n    Dwg_Entity_VERTEX_PFACE_FACE *VERTEX_PFACE_FACE;\n    Dwg_Entity_POLYLINE_2D *POLYLINE_2D;\n    Dwg_Entity_POLYLINE_3D *POLYLINE_3D;\n    Dwg_Entity_ARC *ARC;\n    Dwg_Entity_CIRCLE *CIRCLE;\n    Dwg_Entity_LINE *LINE;\n    Dwg_DIMENSION_common *DIMENSION_common;\n    Dwg_Entity_DIMENSION_ORDINATE *DIMENSION_ORDINATE;\n    Dwg_Entity_DIMENSION_LINEAR *DIMENSION_LINEAR;\n    Dwg_Entity_DIMENSION_ALIGNED *DIMENSION_ALIGNED;\n    Dwg_Entity_DIMENSION_ANG3PT *DIMENSION_ANG3PT;\n    Dwg_Entity_DIMENSION_ANG2LN *DIMENSION_ANG2LN;\n    Dwg_Entity_DIMENSION_RADIUS *DIMENSION_RADIUS;\n    Dwg_Entity_DIMENSION_DIAMETER *DIMENSION_DIAMETER;\n    Dwg_Entity_POINT *POINT;\n    Dwg_Entity__3DFACE *_3DFACE;\n    Dwg_Entity_POLYLINE_PFACE *POLYLINE_PFACE;\n    Dwg_Entity_POLYLINE_MESH *POLYLINE_MESH;\n    Dwg_Entity_SOLID *SOLID;\n    Dwg_Entity_TRACE *TRACE;\n    Dwg_Entity_SHAPE *SHAPE;\n    Dwg_Entity_VIEWPORT *VIEWPORT;\n    Dwg_Entity_ELLIPSE *ELLIPSE;\n    Dwg_Entity_SPLINE *SPLINE;\n    Dwg_Entity_3DSOLID *_3DSOLID;\n    Dwg_Entity_REGION *REGION;\n    Dwg_Entity_BODY *BODY;\n    Dwg_Entity_RAY *RAY;\n    Dwg_Entity_XLINE *XLINE;\n    Dwg_Entity_OLEFRAME *OLEFRAME;\n    Dwg_Entity_MTEXT *MTEXT;\n    Dwg_Entity_LEADER *LEADER;\n    Dwg_Entity_TOLERANCE *TOLERANCE;\n    Dwg_Entity_MLINE *MLINE;\n    Dwg_Entity_OLE2FRAME *OLE2FRAME;\n    Dwg_Entity_HATCH *HATCH;\n\n    Dwg_Entity_CAMERA *CAMERA;\n    Dwg_Entity_GEOPOSITIONMARKER *GEOPOSITIONMARKER;\n    Dwg_Entity_HELIX *HELIX;\n    Dwg_Entity_IMAGE *IMAGE;\n    Dwg_Entity_LIGHT *LIGHT;\n    Dwg_Entity_LWPOLYLINE *LWPOLYLINE;\n    Dwg_Entity_MULTILEADER *MULTILEADER;\n    Dwg_Entity_PROXY_ENTITY *PROXY_ENTITY;\n    Dwg_Entity_PROXY_LWPOLYLINE *PROXY_LWPOLYLINE;\n    Dwg_Entity_PLANESURFACE *PLANESURFACE;\n    Dwg_Entity_EXTRUDEDSURFACE *EXTRUDEDSURFACE;\n    Dwg_Entity_LOFTEDSURFACE *LOFTEDSURFACE;\n    Dwg_Entity_REVOLVEDSURFACE *REVOLVEDSURFACE;\n    Dwg_Entity_SWEPTSURFACE *SWEPTSURFACE;\n    Dwg_Entity_TABLE *TABLE;\n    Dwg_Entity_UNDERLAY *UNDERLAY;\n    Dwg_Entity_WIPEOUT *WIPEOUT;\n    Dwg_Entity_ARC_DIMENSION *ARC_DIMENSION;\n    Dwg_Entity_MESH *MESH;\n\n    Dwg_Entity_UNKNOWN_ENT *UNKNOWN_ENT;\n  } tio;\n\n  struct _dwg_struct *dwg;\n  BITCODE_BL num_eed;\n  Dwg_Eed *eed; /* see also Dwg_Resbuf* xdata */\n\n  /* Common Entity Data */\n  BITCODE_B   preview_exists;\n  BITCODE_BLL preview_size;     /*!< DXF 160 for bitmaps, DXF 92 for PROXY vector data.\n                                  e.g. INSERT, MULTILEADER */\n  char       *preview;          /*!< DXF 310 */\n  BITCODE_BB entmode;           /*!< has no owner handle:\n                                  0 has no ownerhandle, 1 is PSPACE, 2 is MSPACE\n                                  3 has ownerhandle. */\n  BITCODE_BL num_reactors;\n  BITCODE_B xdic_missing_flag;  /*!< r2004+ */\n  BITCODE_B isbylayerlt;        /*!< r13-r14 */\n  BITCODE_B nolinks;            /*!< r13-r2000 */\n  BITCODE_B has_ds_binary_data; /*!< r2013+ */\n  BITCODE_CMC color;\n  BITCODE_BD ltype_scale;\n  BITCODE_BB ltype_flags;       /*!< r2000+ */\n  BITCODE_BB plotstyle_flags;   /*!< r2000+ */\n  BITCODE_BB material_flags;    /*!< r2007+ */\n  BITCODE_RC shadow_flags;      /*!< r2007+: 0 both, 1 casts, 2, receives,\n                                  3 has handle. DXF 284 */\n  BITCODE_B has_full_visualstyle; /*!< r2010+ */\n  BITCODE_B has_face_visualstyle; /*!< r2010+ */\n  BITCODE_B has_edge_visualstyle; /*!< r2010+ */\n  BITCODE_BS invisible;\n  BITCODE_RC linewt;              /*!< r2000+, see dxf_cvt_lweight() */\n\n  /* preR13 entity fields: */\n  BITCODE_RC flag_r11;\n  BITCODE_RS kind_r11;\n  BITCODE_RS opts_r11;\n  BITCODE_RC extra_r11;\n  BITCODE_RS layer_r11;\n  BITCODE_RC color_r11;\n  BITCODE_RS ltype_r11;\n  BITCODE_RD elevation_r11;\n  BITCODE_RD thickness_r11;\n  BITCODE_RS paper_r11;\n  /* preR13 in the obj: eed, elevation/pt.z, thickness, paper */\n\n  /* Common Entity Handle Data */\n  BITCODE_BL __iterator;\n  BITCODE_H ownerhandle; /*!< mspace, pspace or owner of subentity */\n  BITCODE_H* reactors;\n  BITCODE_H xdicobjhandle;\n  BITCODE_H prev_entity;  /*!< r13-r2000 */\n  BITCODE_H next_entity;  /*!< r13-r2000 */\n  BITCODE_H layer;\n  BITCODE_H ltype;\n  BITCODE_H material;     /*!< r2007+ */\n  BITCODE_H shadow;       /*!< r2007+ */\n  BITCODE_H plotstyle;    /*!< r2000+ */\n  BITCODE_H full_visualstyle; /*!< r2010+ */\n  BITCODE_H face_visualstyle;\n  BITCODE_H edge_visualstyle;\n} Dwg_Object_Entity;\n\n/**\n Ordinary object attributes\n */\ntypedef struct _dwg_object_object\n{\n  BITCODE_BL objid; /*<! link to the parent */\n  union\n  {\n    Dwg_Object_BLOCK_CONTROL *BLOCK_CONTROL;\n    Dwg_Object_BLOCK_HEADER *BLOCK_HEADER;\n    Dwg_Object_LAYER_CONTROL *LAYER_CONTROL;\n    Dwg_Object_LAYER *LAYER;\n    Dwg_Object_STYLE_CONTROL *STYLE_CONTROL;\n    Dwg_Object_STYLE *STYLE;\n    Dwg_Object_LTYPE_CONTROL *LTYPE_CONTROL;\n    Dwg_Object_LTYPE *LTYPE;\n    Dwg_Object_VIEW_CONTROL *VIEW_CONTROL;\n    Dwg_Object_VIEW *VIEW;\n    Dwg_Object_UCS_CONTROL *UCS_CONTROL;\n    Dwg_Object_UCS *UCS;\n    Dwg_Object_VPORT_CONTROL *VPORT_CONTROL;\n    Dwg_Object_VPORT *VPORT;\n    Dwg_Object_APPID_CONTROL *APPID_CONTROL;\n    Dwg_Object_APPID *APPID;\n    Dwg_Object_DIMSTYLE_CONTROL *DIMSTYLE_CONTROL;\n    Dwg_Object_DIMSTYLE *DIMSTYLE;\n    Dwg_Object_VPORT_ENTITY_CONTROL *VPORT_ENTITY_CONTROL;\n    Dwg_Object_VPORT_ENTITY_HEADER *VPORT_ENTITY_HEADER;\n\n    //TODO Dwg_Object_ACSH_HISTORY_CLASS *ACSH_HISTORY_CLASS;\n    Dwg_Object_ACSH_SWEEP_CLASS *ACSH_SWEEP_CLASS;\n    //Dwg_Object_ARCALIGNEDTEXT *ARCALIGNEDTEXT;\n    Dwg_Object_ANNOTSCALEOBJECTCONTEXTDATA *ANNOTSCALEOBJECTCONTEXTDATA;\n    Dwg_Object_ASSOC2DCONSTRAINTGROUP *ASSOC2DCONSTRAINTGROUP;\n    Dwg_Object_ASSOCACTION *ASSOCACTION;\n    Dwg_Object_ASSOCALIGNEDDIMACTIONBODY *ASSOCALIGNEDDIMACTIONBODY;\n    Dwg_Object_ASSOCDEPENDENCY *ASSOCDEPENDENCY;\n    //Dwg_Object_ASSOCGEOMDEPENDENCY *ASSOCGEOMDEPENDENCY;\n    Dwg_Object_ASSOCNETWORK *ASSOCNETWORK;\n    Dwg_Object_ASSOCOSNAPPOINTREFACTIONPARAM *ASSOCOSNAPPOINTREFACTIONPARAM;\n    Dwg_Object_ASSOCPERSSUBENTMANAGER *ASSOCPERSSUBENTMANAGER;\n    Dwg_Object_ASSOCPLANESURFACEACTIONBODY *ASSOCPLANESURFACEACTIONBODY;\n    Dwg_Object_CELLSTYLEMAP *CELLSTYLEMAP;\n    Dwg_Object_DATATABLE *DATATABLE;\n    Dwg_Object_DBCOLOR *DBCOLOR;\n    //Dwg_Object_DETAILVIEWSTYLE *DETAILVIEWSTYLE;\n    Dwg_Object_DICTIONARY *DICTIONARY;\n    Dwg_Object_DICTIONARYVAR *DICTIONARYVAR;\n    Dwg_Object_DICTIONARYWDFLT *DICTIONARYWDFLT;\n    Dwg_Object_DIMASSOC *DIMASSOC;\n    //Dwg_Object_DOCUMENTOPTIONS *DOCUMENTOPTIONS;\n    Dwg_Object_DYNAMICBLOCKPURGEPREVENTER *DYNAMICBLOCKPURGEPREVENTER;\n    Dwg_Object_DUMMY *DUMMY;\n    Dwg_Object_EVALUATION_GRAPH *EVALUATION_GRAPH;\n    Dwg_Object_FIELD *FIELD;\n    Dwg_Object_FIELDLIST *FIELDLIST;\n    Dwg_Object_GEODATA *GEODATA;\n    Dwg_Object_GEOMAPIMAGE *GEOMAPIMAGE;\n    Dwg_Object_GROUP *GROUP;\n    Dwg_Object_IDBUFFER *IDBUFFER;\n    Dwg_Object_IMAGEDEF *IMAGEDEF;\n    Dwg_Object_IMAGEDEF_REACTOR *IMAGEDEF_REACTOR;\n    Dwg_Object_LAYER_INDEX *LAYER_INDEX;\n    Dwg_Object_LAYOUT *LAYOUT;\n    Dwg_Object_LIGHTLIST *LIGHTLIST;\n    Dwg_Object_LONG_TRANSACTION *LONG_TRANSACTION;\n    Dwg_Object_MATERIAL *MATERIAL;\n    Dwg_Object_MLEADERSTYLE *MLEADERSTYLE;\n    Dwg_Object_MLINESTYLE *MLINESTYLE;\n    Dwg_Object_NAVISWORKSMODELDEF *NAVISWORKSMODELDEF;\n    //TODO Dwg_Object_NPOCOLLECTION *NPOCOLLECTION;\n    Dwg_Object_OBJECT_PTR *OBJECT_PTR;\n    Dwg_Object_OBJECTCONTEXTDATA *OBJECTCONTEXTDATA;\n    Dwg_Object_PERSSUBENTMANAGER *PERSSUBENTMANAGER;\n    Dwg_Object_PLACEHOLDER *PLACEHOLDER;\n    Dwg_Object_PLOTSETTINGS *PLOTSETTINGS;\n    Dwg_Object_PROXY_OBJECT *PROXY_OBJECT;\n    Dwg_Object_RASTERVARIABLES *RASTERVARIABLES;\n    Dwg_Object_RENDERENVIRONMENT *RENDERENVIRONMENT;\n    Dwg_Object_RENDERGLOBAL *RENDERGLOBAL;\n    //TODO Dwg_Object_RTEXT *RTEXT;\n    Dwg_Object_SCALE *SCALE;\n    //Dwg_Object_SECTIONVIEWSTYLE *SECTIONVIEWSTYLE;\n    Dwg_Object_SORTENTSTABLE *SORTENTSTABLE;\n    Dwg_Object_SPATIAL_FILTER *SPATIAL_FILTER;\n    Dwg_Object_SPATIAL_INDEX *SPATIAL_INDEX;\n    Dwg_Object_SUN *SUN;\n    Dwg_Object_SUNSTUDY *SUNSTUDY;\n    Dwg_Object_TABLECONTENT *TABLECONTENT;\n    Dwg_Object_TABLEGEOMETRY *TABLEGEOMETRY;\n    Dwg_Object_TABLESTYLE *TABLESTYLE;\n    Dwg_Object_VBA_PROJECT *VBA_PROJECT;\n    Dwg_Object_UNDERLAYDEFINITION *UNDERLAYDEFINITION;\n    Dwg_Object_VISUALSTYLE *VISUALSTYLE;\n    Dwg_Object_WIPEOUTVARIABLES *WIPEOUTVARIABLES;\n    Dwg_Object_XRECORD *XRECORD;\n    //TODO Dwg_Object_XREFPANELOBJECT *XREFPANELOBJECT;\n    Dwg_Object_UNKNOWN_OBJ *UNKNOWN_OBJ;\n  } tio;\n\n  struct _dwg_struct *dwg;\n  BITCODE_BL num_eed;\n  Dwg_Eed *eed;\n\n  BITCODE_H ownerhandle;        /*!< DXF 330 */\n  BITCODE_BL num_reactors;\n  BITCODE_H* reactors;\n  BITCODE_H xdicobjhandle;\n  BITCODE_B xdic_missing_flag;  /*!< r2004+ */\n  BITCODE_B has_ds_binary_data; /*!< r2013+ */\n\n  /*unsigned int num_handles;*/\n  Dwg_Handle *handleref; //??\n} Dwg_Object_Object;\n\n/**\n General DWG object with link to either entity or object, and as parent the DWG\n */\ntypedef struct _dwg_object\n{\n  BITCODE_RL size;       /*!< in bytes */\n  unsigned long address; /*!< byte offset in the file */\n  unsigned int type;     /*!< fixed or variable (class - 500) */\n  BITCODE_RL index;      /*!< into dwg->object[] */\n  enum DWG_OBJECT_TYPE fixedtype; /*!< into a global list */\n  char *name;            /*!< our public entity/object name */\n  char *dxfname;         /*!< the internal dxf classname, often with a ACDB prefix */\n\n  Dwg_Object_Supertype supertype;\n  union\n  {\n    Dwg_Object_Entity *entity;\n    Dwg_Object_Object *object;\n    char *unknown; /* i.e. unhandled class as raw bits */\n  } tio;\n\n  Dwg_Handle handle;\n  struct _dwg_struct *parent;\n\n  BITCODE_RL bitsize;        /* common + object fields, but no handles */\n  unsigned long bitsize_pos; /* bitsize offset in bits: r13-2007 */\n  unsigned long hdlpos;      /* relative offset, in bits */\n  BITCODE_B  has_strings;        /*!< r2007+ */\n  BITCODE_RL stringstream_size;  /*!< r2007+ in bits, unused */\n  BITCODE_UMC handlestream_size; /*!< r2010+ in bits */\n  unsigned long common_size; /* relative offset from type ... end common_entity_data */\n\n  unsigned long num_unknown_bits;\n  char *unknown_bits;\n\n} Dwg_Object;\n\n/**\n Classes\n */\ntypedef struct _dwg_class\n{\n  BITCODE_BS number; /*!< starting with 500 */\n  /* see http://images.autodesk.com/adsk/files/autocad_2012_pdf_dxf-reference_enu.pdf */\n  BITCODE_BS proxyflag; /*!<\n      erase allowed = 1,\n      transform allowed = 2,\n      color change allowed = 4,\n      layer change allowed = 8,\n      line type change allowed = 16,\n      line type scale change allowed = 32,\n      visibility change allowed = 64,\n      cloning allowed = 128,\n      Lineweight change allowed = 256,\n      Plot Style Name change allowed = 512,\n      Disables proxy warning dialog = 1024,\n      is R13 format proxy= 32768 */\n  char *appname;\n  char *cppname;\n  char *dxfname; /*!< ASCII or UTF-8 */\n  BITCODE_TU dxfname_u; /* r2007+, always transformed to dxfname as UTF-8 */\n  BITCODE_B  wasazombie; /*!< really Was-a-proxy flag */\n  BITCODE_BS item_class_id; /* Is-an-entity. 1f2 for entities, 1f3 for objects */\n  BITCODE_BL num_instances; /* 91 Instance count for a custom class */\n  BITCODE_BL dwg_version;\n  BITCODE_BL maint_version;\n  BITCODE_BL unknown_1; /*!< def: 0L */\n  BITCODE_BL unknown_2; /*!< def: 0L */\n} Dwg_Class;\n\n/**\n Dwg_Chain similar to Bit_Chain in \"bits.h\". Used only for the Thumbnail thumbnail\n */\ntypedef struct _dwg_chain\n{\n  unsigned char *chain;\n  long unsigned int size;\n  long unsigned int byte;\n  unsigned char bit;\n} Dwg_Chain;\n\ntypedef enum DWG_SECTION_TYPE /* since r2004+ */\n{\n  SECTION_HEADER = 1,                   /* AcDb:Header */\n  SECTION_AUXHEADER = 2,                /* AcDb:AuxHeader */\n  SECTION_CLASSES = 3,                  /* AcDb:Classes */\n  SECTION_HANDLES = 4,                  /* AcDb:Handles */\n  SECTION_TEMPLATE = 5,                 /* AcDb:Template */\n  SECTION_OBJFREESPACE = 6,             /* AcDb:ObjFreeSpace */\n  SECTION_OBJECTS = 7,                  /* AcDb:AcDbObjects */\n  SECTION_REVHISTORY = 8,               /* AcDb:RevHistory */\n  SECTION_SUMMARYINFO = 9,              /* AcDb:SummaryInfo */\n  SECTION_PREVIEW = 10,                 /* AcDb:Preview */\n  SECTION_APPINFO = 11,                 /* AcDb:AppInfo */\n  SECTION_APPINFOHISTORY = 12,          /* AcDb:AppInfoHistory */\n  SECTION_FILEDEPLIST = 13,             /* AcDb:FileDepList */\n  SECTION_SECURITY,                     /* AcDb:Security, if stored with a password */\n  SECTION_VBAPROJECT,                   /* AcDb:VBAProject */\n  SECTION_SIGNATURE,                    /* AcDb:Signature */\n  SECTION_PROTOTYPE,                    /* AcDb:AcDsPrototype_1b */\n  SECTION_UNKNOWN,\n} Dwg_Section_Type;\n\ntypedef enum DWG_SECTION_TYPE_R13\n{\n  SECTION_HEADER_R13 = 0,\n  SECTION_CLASSES_R13 = 1,\n  SECTION_HANDLES_R13 = 2,\n  SECTION_2NDHEADER_R13 = 3,\n  SECTION_MEASUREMENT_R13 = 4,\n  SECTION_AUXHEADER_R2000 = 5,\n} Dwg_Section_Type_R13;\n\ntypedef enum DWG_SECTION_TYPE_R11 /* tables */\n{\n  SECTION_HEADER_R11 = 0,\n  SECTION_BLOCK = 1,\n  SECTION_LAYER = 2,\n  SECTION_STYLE = 3,\n  SECTION_LTYPE = 5,\n  SECTION_VIEW  = 6,\n  SECTION_UCS   = 7,\n  SECTION_VPORT = 8,\n  SECTION_APPID = 9,\n  SECTION_DIMSTYLE = 10,\n  SECTION_VPORT_ENTITY = 11,\n} Dwg_Section_Type_r11;\n\ntypedef struct _dwg_section\n{\n  int32_t    number; /* preR13: count of entries, r2007: id */\n  BITCODE_RL size;   /* now unsigned */\n  uint64_t   address;\n  BITCODE_RL parent;\n  BITCODE_RL left;\n  BITCODE_RL right;\n  BITCODE_RL x00;\n  Dwg_Section_Type type; /* to be casted to Dwg_Section_Type_r11 preR13 */\n  /* => section_info? */\n  char name[64];\n  /*!< r2004 section fields: */\n  BITCODE_RL section_type;\n  BITCODE_RL decomp_data_size;\n  BITCODE_RL comp_data_size;\n  BITCODE_RL compression_type;\n  BITCODE_RL checksum;\n} Dwg_Section;\n\n/* Dwg_R2007_Section:\n  int64_t  data_size;    // max size of page\n  int64_t  max_size;\n  int64_t  encrypted;\n  int64_t  hashcode;\n  int64_t  name_length;  // 0x22\n  int64_t  unknown;      // 0x00\n  int64_t  encoded;\n  int64_t  num_pages;\n  DWGCHAR *name;\n  r2007_section_page **pages;\n  struct _r2007_section *next;\n */\n\n// ODA 4.5\ntypedef struct\n{\n  BITCODE_RL num_desc;\n  BITCODE_RL compressed; /* Compressed (1 = no, 2 = yes, normally 2) */\n  BITCODE_RL max_size;\n  BITCODE_RL encrypted; /* (0 = no, 1 = yes, 2 = unknown) */\n  BITCODE_RL num_desc2;\n} Dwg_Section_InfoHdr;\n\ntypedef struct\n{\n  int64_t    size;\n  BITCODE_RL num_sections;\n  BITCODE_RL max_decomp_size;\n  BITCODE_RL unknown;\n  BITCODE_RL compressed; /* Compressed (1 = no, 2 = yes, normally 2) */\n  BITCODE_RL type;\n  BITCODE_RL encrypted; /* (0 = no, 1 = yes, 2 = unknown) */\n  char name[64];\n  Dwg_Section **sections;\n} Dwg_Section_Info;\n\n\ntypedef struct _dwg_SummaryInfo_Property\n{\n  BITCODE_T key;\n  BITCODE_T value;\n} Dwg_SummaryInfo_Property;\n\n/**\n Main DWG struct\n */\ntypedef struct _dwg_struct\n{\n  struct Dwg_Header\n  {\n    Dwg_Version_Type version;          /* calculated from the header magic */\n    Dwg_Version_Type from_version;     /* option. set by --as (convert from) */\n    BITCODE_RC   zero_5[5];\n    BITCODE_RC   is_maint;\n    BITCODE_RC   zero_one_or_three;\n    BITCODE_RS   unknown_s[3];         /* <R13 */\n    BITCODE_RL   thumbnail_address;    /* THUMBNAIL or AdDb:Preview */\n    BITCODE_RC   dwg_version;\n    BITCODE_RC   maint_version;\n    BITCODE_RS   codepage;\n    BITCODE_RC   unknown_0;            /* R2004+ */\n    BITCODE_RC   app_dwg_version;      /* R2004+ */\n    BITCODE_RC   app_maint_version;    /* R2004+ */\n    BITCODE_RL   security_type;        /* R2004+ */\n    BITCODE_RL   rl_1c_address;        /* R2004+ mostly 0 */\n    BITCODE_RL   summaryinfo_address;  /* R2004+ */\n    BITCODE_RL   vbaproj_address;      /* R2004+ */\n    BITCODE_RL   rl_28_80;             /* R2004+ */\n    BITCODE_RL   num_sections;\n    Dwg_Section* section;\n    Dwg_Section_InfoHdr section_infohdr; /* R2004+ */\n    Dwg_Section_Info* section_info;\n  } header;\n\n  struct Dwg_R2004_Header /* encrypted */\n    {\n      BITCODE_RC file_ID_string[12];\n      BITCODE_RLx header_address;\n      BITCODE_RL header_size;\n      BITCODE_RL x04;\n      BITCODE_RLd root_tree_node_gap;\n      BITCODE_RLd lowermost_left_tree_node_gap;\n      BITCODE_RLd lowermost_right_tree_node_gap;\n      BITCODE_RL unknown_long;\n      BITCODE_RL last_section_id;\n      BITCODE_RLL last_section_address;\n      BITCODE_RLL second_header_address;\n      BITCODE_RL num_gaps;\n      BITCODE_RL num_sections;\n      BITCODE_RL x20;\n      BITCODE_RL x80;\n      BITCODE_RL x40;\n      BITCODE_RL section_map_id;\n      BITCODE_RLL section_map_address;\n      BITCODE_RL section_info_id;\n      BITCODE_RL section_array_size;\n      BITCODE_RL gap_array_size;\n      BITCODE_RLx crc32; /* p 2.14.2 32bit CRC 2004+ */\n      BITCODE_RC padding[12];\n      /* System Section: Section Page Map */\n      BITCODE_RL section_type; /* 0x4163043b */\n      BITCODE_RL decomp_data_size;\n      BITCODE_RL comp_data_size;\n      BITCODE_RL compression_type;\n      BITCODE_RLx checksum;\n  } r2004_header;\n\n  /* #define DWG_AUXHEADER_SIZE 123 */\n  struct Dwg_AuxHeader\n  {\n    BITCODE_RC   aux_intro[3]; /* ff 77 01 */\n    BITCODE_RS   dwg_version;\n    BITCODE_RS   maint_version;\n    BITCODE_RL   num_saves;\n    BITCODE_RL   minus_1;\n    BITCODE_RS   num_saves_1;\n    BITCODE_RS   num_saves_2;\n    BITCODE_RL   zero;\n    BITCODE_RS   dwg_version_1;\n    BITCODE_RS   maint_version_1;\n    BITCODE_RS   dwg_version_2;\n    BITCODE_RS   maint_version_2;\n    BITCODE_RS   unknown_rs[6];\n    BITCODE_RC   unknown_rc[20]; /* some vars */\n    BITCODE_RD   TDCREATE; /* ?? format TD */\n    BITCODE_RD   TDUPDATE;\n    BITCODE_RL   HANDSEED;\n    BITCODE_RL   plot_stamp;\n    BITCODE_RS   zero_1;\n    BITCODE_RS   num_saves_3;\n    BITCODE_RL   zero_2;\n    BITCODE_RL   zero_3;\n    BITCODE_RL   zero_4;\n    BITCODE_RL   num_saves_4;\n    BITCODE_RL   zero_5;\n    BITCODE_RL   zero_6;\n    BITCODE_RL   zero_7;\n    BITCODE_RL   zero_8; /* ?? */\n    BITCODE_RS   zero_18[3]; /* R2018+ */\n  } auxheader;\n\n  struct Dwg_SummaryInfo\n  {\n    BITCODE_T    TITLE;\n    BITCODE_T    SUBJECT;\n    BITCODE_T    AUTHOR;\n    BITCODE_T    KEYWORDS;\n    BITCODE_T    COMMENTS;\n    BITCODE_T    LASTSAVEDBY;\n    BITCODE_T    REVISIONNUMBER;\n    BITCODE_T    HYPERLINKBASE;\n    BITCODE_TIMERLL  TDINDWG; /* days + ms, fixed size! */\n    BITCODE_TIMERLL  TDCREATE;\n    BITCODE_TIMERLL  TDUPDATE;\n    BITCODE_RS   num_props;\n    Dwg_SummaryInfo_Property *props;\n    BITCODE_RL   unknown1;\n    BITCODE_RL   unknown2;\n  } summaryinfo;\n  \n  Dwg_Chain thumbnail;\n\n  Dwg_Header_Variables header_vars;\n  \n  BITCODE_BS num_classes;    /*!< size of dwg_class */\n  Dwg_Class * dwg_class;     /*!< list of all classes */\n\n  BITCODE_BL num_objects;    /*!< size of object */\n  Dwg_Object * object;       /*!< list of all objects and entities */\n\n  BITCODE_BL num_entities;       /*!< number of entities in object */\n  BITCODE_BL num_object_refs;    /*!< number of object_ref's (resolved handles) */\n  Dwg_Object_Ref **object_ref;   /*!< array of all handles */\n  struct _inthash *object_map;   /*!< map of all handles */\n  int dirty_refs; /* 1 if we added an entity, and invalidated all the internal ref->obj's */\n \n  Dwg_Object *mspace_block;\n  Dwg_Object *pspace_block;\n  /* Those TABLES might be empty with num_entries=0 */\n  Dwg_Object_BLOCK_CONTROL      block_control;\n  Dwg_Object_LAYER_CONTROL      layer_control;\n  Dwg_Object_STYLE_CONTROL      style_control;\n  Dwg_Object_LTYPE_CONTROL      ltype_control;\n  Dwg_Object_VIEW_CONTROL       view_control;\n  Dwg_Object_UCS_CONTROL        ucs_control;\n  Dwg_Object_VPORT_CONTROL      vport_control;\n  Dwg_Object_APPID_CONTROL      appid_control;\n  Dwg_Object_DIMSTYLE_CONTROL   dimstyle_control;\n  Dwg_Object_VPORT_ENTITY_CONTROL  vport_entity_control;\n\n  struct _dwg_second_header {\n    BITCODE_RL size;\n    BITCODE_RL address;\n    BITCODE_RC version[12];\n    BITCODE_B null_b[4];\n    BITCODE_RC unknown_10;\n    BITCODE_RC unknown_rc4[4];\n    BITCODE_RC num_sections;\n    struct _sections\n    {\n      BITCODE_RC nr;\n      BITCODE_BL address;\n      BITCODE_BL size;\n    } section[6];\n    BITCODE_BS num_handlers;\n    struct _handler\n    {\n      BITCODE_RC size;\n      BITCODE_RC nr;\n      BITCODE_RC *data;\n    } handlers[16];\n    BITCODE_RL junk_r14_1; /*!< r14 only */\n    BITCODE_RL junk_r14_2; /*!< r14 only */\n  } second_header;\n\n  unsigned int layout_type;\n  unsigned int opts; /* See DWG_OPTS_* below */\n} Dwg_Data;\n\n#define DWG_OPTS_LOGLEVEL 0xf\n#define DWG_OPTS_MINIMAL  0x10\n#define DWG_OPTS_INDXF    0x20\n#define DWG_OPTS_DXFB     0x40\n\n/*--------------------------------------------------\n * Exported Functions\n */\n\nEXPORT int dwg_read_file (const char *restrict filename,\n                          Dwg_Data *restrict dwg);\nEXPORT int dxf_read_file (const char *restrict filename,\n                          Dwg_Data *restrict dwg);\n\n#ifdef USE_WRITE\nEXPORT int dwg_write_file (const char *restrict filename,\n                           const Dwg_Data *restrict dwg);\n#endif\n\nEXPORT unsigned char *dwg_bmp (const Dwg_Data *restrict, BITCODE_RL *restrict);\n\n/** Converts the internal enum RC into 100th mm lineweight, with\n *  -1 BYLAYER, -2 BYBLOCK, -3 BYLWDEFAULT.\n */\nEXPORT int dxf_cvt_lweight (const BITCODE_BSd value);\n\n/** Converts the 100th mm lineweight, with -1 BYLAYER, -2 BYBLOCK, -3 BYLWDEFAULT,\n    into the internal enum RC.\n */\nEXPORT BITCODE_BSd dxf_revcvt_lweight (const int lw);\n\n/* Search for the name in the associated table, and return its handle. Search\n * is case-insensitive */\nEXPORT BITCODE_H dwg_find_tablehandle (Dwg_Data *restrict dwg,\n                                       const char *restrict name,\n                                       const char *restrict table);\n\n/** Not checking the header_vars entry, only searching the objects\n *  Returning a hardowner or hardpointer (DICTIONARY) ref (code 3 or 5)\n *  to it, as stored in header_vars. table must contain the \"_CONTROL\" suffix.\n */\nEXPORT BITCODE_H dwg_find_table_control (Dwg_Data *restrict dwg,\n                                         const char *restrict table);\n\n/** Searching for a dictionary ref.\n *  Returning a hardpointer ref (5) to it, as stored in header_vars. */\nEXPORT BITCODE_H dwg_find_dictionary (Dwg_Data *restrict dwg,\n                                      const char *restrict name);\n/** Searching for a named dictionary entry in the given dict. Search is\n * case-insensitive */\nEXPORT BITCODE_H dwg_find_dicthandle (Dwg_Data *restrict dwg, BITCODE_H dict,\n                                      const char *restrict name);\n/* Search for a table EXTNAME */\nEXPORT char *dwg_find_table_extname (Dwg_Data *restrict dwg,\n                                     Dwg_Object *restrict obj);\n\nEXPORT double dwg_model_x_min (const Dwg_Data *restrict);\nEXPORT double dwg_model_x_max (const Dwg_Data *restrict);\nEXPORT double dwg_model_y_min (const Dwg_Data *restrict);\nEXPORT double dwg_model_y_max (const Dwg_Data *restrict);\nEXPORT double dwg_model_z_min (const Dwg_Data *restrict);\nEXPORT double dwg_model_z_max (const Dwg_Data *restrict);\nEXPORT double dwg_page_x_min (const Dwg_Data *restrict);\nEXPORT double dwg_page_x_max (const Dwg_Data *restrict);\nEXPORT double dwg_page_y_min (const Dwg_Data *restrict);\nEXPORT double dwg_page_y_max (const Dwg_Data *restrict);\n\nEXPORT Dwg_Object_BLOCK_CONTROL * dwg_block_control (Dwg_Data *restrict dwg);\n\nEXPORT Dwg_Object_Ref * dwg_model_space_ref (Dwg_Data *restrict dwg);\nEXPORT Dwg_Object_Ref * dwg_paper_space_ref (Dwg_Data *restrict dwg);\nEXPORT Dwg_Object * dwg_model_space_object (Dwg_Data *restrict dwg);\n\nEXPORT unsigned int dwg_get_layer_count (const Dwg_Data *restrict dwg);\n\nEXPORT Dwg_Object_LAYER ** dwg_get_layers (const Dwg_Data *restrict dwg);\n\nEXPORT BITCODE_BL dwg_get_num_objects (const Dwg_Data *restrict dwg);\n\nEXPORT BITCODE_BL dwg_get_object_num_objects (const Dwg_Data *restrict dwg);\n\nEXPORT int dwg_class_is_entity (const Dwg_Class *restrict klass);\n\nEXPORT int dwg_obj_is_control (const Dwg_Object *restrict obj);\n\nEXPORT int dwg_obj_is_table (const Dwg_Object *restrict obj);\n\nEXPORT int dwg_obj_is_subentity (const Dwg_Object *restrict obj);\n\nEXPORT int dwg_obj_has_subentity (const Dwg_Object *restrict obj);\n\nEXPORT BITCODE_BL dwg_get_num_entities (const Dwg_Data *restrict);\n\nEXPORT Dwg_Object_Entity **dwg_get_entities (const Dwg_Data *restrict);\n\nEXPORT Dwg_Object_LAYER *\ndwg_get_entity_layer (const Dwg_Object_Entity *restrict);\n\nEXPORT Dwg_Object *dwg_next_object (const Dwg_Object *obj);\n\nEXPORT Dwg_Object *dwg_ref_object (const Dwg_Data *restrict dwg,\n                                   Dwg_Object_Ref *restrict ref);\n\nEXPORT Dwg_Object *dwg_ref_object_relative (const Dwg_Data *restrict dwg,\n                                            Dwg_Object_Ref *restrict ref,\n                                            const Dwg_Object *restrict obj);\nEXPORT Dwg_Object *dwg_ref_object_silent (const Dwg_Data *restrict dwg,\n                                          Dwg_Object_Ref *restrict ref);\n\nEXPORT Dwg_Object *get_first_owned_entity (const Dwg_Object *restrict hdr);\nEXPORT Dwg_Object *get_next_owned_entity (const Dwg_Object *restrict hdr,\n                                          const Dwg_Object *restrict current);\nEXPORT Dwg_Object *get_first_owned_subentity (const Dwg_Object *restrict owner);\nEXPORT Dwg_Object *get_next_owned_subentity (const Dwg_Object *restrict owner,\n                                             const Dwg_Object *restrict current);\nEXPORT Dwg_Object *get_first_owned_block (const Dwg_Object *hdr);\nEXPORT Dwg_Object *get_last_owned_block (const Dwg_Object *hdr);\nEXPORT Dwg_Object *get_next_owned_block (const Dwg_Object *restrict hdr,\n                                         const Dwg_Object *restrict current);\n\nEXPORT Dwg_Object *dwg_resolve_handle (const Dwg_Data *restrict dwg,\n                                       const unsigned long absref);\nEXPORT Dwg_Object *dwg_resolve_handle_silent (const Dwg_Data *restrict dwg,\n                                              const BITCODE_BL absref);\nEXPORT int dwg_resolve_handleref (Dwg_Object_Ref *restrict ref,\n                                  const Dwg_Object *restrict obj);\n\nEXPORT Dwg_Section_Type dwg_section_type (const DWGCHAR *restrict wname);\n\n/** Free the whole DWG. all tables, sections, objects, ...\n*/\nEXPORT void dwg_free (Dwg_Data *restrict dwg);\n\n/** Free the object (all three structs and its fields)\n*/\nEXPORT void dwg_free_object (Dwg_Object *restrict obj);\n\n/** Add the empty ref to the DWG (freshly malloc'ed), or NULL.\n*/\nEXPORT Dwg_Object_Ref * dwg_new_ref (Dwg_Data *restrict dwg);\n\n/** For encode:\n *  May need obj to shorten the code to a relative offset, but not in header_vars.\n *  There obj is NULL.\n */\nEXPORT int\ndwg_add_handle (Dwg_Handle *restrict hdl, BITCODE_RC code, unsigned long value,\n                Dwg_Object *restrict obj);\n\n/** Returns an existing ref with the same ownership (hard/soft, owner/pointer)\n    or creates it. With obj non-NULL it may return a relative offset, otherwise\n    always absolute.\n*/\nEXPORT Dwg_Object_Ref *\ndwg_add_handleref (Dwg_Data *restrict dwg, BITCODE_RC code, unsigned long value,\n                   Dwg_Object *restrict obj);\n\n/** Add the empty object to the DWG.\n    Returns DWG_ERR_OUTOFMEM, -1 for realloced or 0 if not.\n*/\nEXPORT int dwg_add_object (Dwg_Data *restrict dwg);\n\n/** Initialize the empty entity or object with its three structs.\n    All fields are zero'd, some are initialized with default values, as\n    defined in dwg.spec.\n    Returns 0 or DWG_ERR_OUTOFMEM.\n*/\nEXPORT int dwg_add_TEXT (Dwg_Object *obj);\nEXPORT int dwg_add_ATTRIB (Dwg_Object *obj);\nEXPORT int dwg_add_ATTDEF (Dwg_Object *obj);\nEXPORT int dwg_add_BLOCK (Dwg_Object *obj);\nEXPORT int dwg_add_ENDBLK (Dwg_Object *obj);\nEXPORT int dwg_add_SEQEND (Dwg_Object *obj);\nEXPORT int dwg_add_INSERT (Dwg_Object *obj);\nEXPORT int dwg_add_MINSERT (Dwg_Object *obj);\nEXPORT int dwg_add_VERTEX_2D (Dwg_Object *obj);\nEXPORT int dwg_add_VERTEX_3D (Dwg_Object *obj);\nEXPORT int dwg_add_VERTEX_MESH (Dwg_Object *obj);\nEXPORT int dwg_add_VERTEX_PFACE (Dwg_Object *obj);\nEXPORT int dwg_add_VERTEX_PFACE_FACE (Dwg_Object *obj);\nEXPORT int dwg_add_POLYLINE_2D (Dwg_Object *obj);\nEXPORT int dwg_add_POLYLINE_3D (Dwg_Object *obj);\nEXPORT int dwg_add_ARC (Dwg_Object *obj);\nEXPORT int dwg_add_CIRCLE (Dwg_Object *obj);\nEXPORT int dwg_add_LINE (Dwg_Object *obj);\nEXPORT int dwg_add_DIMENSION_ORDINATE (Dwg_Object *obj);\nEXPORT int dwg_add_DIMENSION_LINEAR (Dwg_Object *obj);\nEXPORT int dwg_add_DIMENSION_ALIGNED (Dwg_Object *obj);\nEXPORT int dwg_add_DIMENSION_ANG3PT (Dwg_Object *obj);\nEXPORT int dwg_add_DIMENSION_ANG2LN (Dwg_Object *obj);\nEXPORT int dwg_add_DIMENSION_RADIUS (Dwg_Object *obj);\nEXPORT int dwg_add_DIMENSION_DIAMETER (Dwg_Object *obj);\nEXPORT int dwg_add_POINT (Dwg_Object *obj);\nEXPORT int dwg_add__3DFACE (Dwg_Object *obj);\nEXPORT int dwg_add__3DSOLID (Dwg_Object *obj);\nEXPORT int dwg_add_POLYLINE_PFACE (Dwg_Object *obj);\nEXPORT int dwg_add_POLYLINE_MESH (Dwg_Object *obj);\nEXPORT int dwg_add_SOLID (Dwg_Object *obj);\nEXPORT int dwg_add_TRACE (Dwg_Object *obj);\nEXPORT int dwg_add_SHAPE (Dwg_Object *obj);\nEXPORT int dwg_add_VIEWPORT (Dwg_Object *obj);\nEXPORT int dwg_add_ELLIPSE (Dwg_Object *obj);\nEXPORT int dwg_add_SPLINE (Dwg_Object *obj);\nEXPORT int dwg_add_REGION (Dwg_Object *obj);\nEXPORT int dwg_add_BODY (Dwg_Object *obj);\nEXPORT int dwg_add_RAY (Dwg_Object *obj);\nEXPORT int dwg_add_XLINE (Dwg_Object *obj);\nEXPORT int dwg_add_DICTIONARY (Dwg_Object *obj);\nEXPORT int dwg_add_OLEFRAME (Dwg_Object *obj);\nEXPORT int dwg_add_MTEXT (Dwg_Object *obj);\nEXPORT int dwg_add_LEADER (Dwg_Object *obj);\nEXPORT int dwg_add_TOLERANCE (Dwg_Object *obj);\nEXPORT int dwg_add_MLINE (Dwg_Object *obj);\nEXPORT int dwg_add_BLOCK_CONTROL (Dwg_Object *obj);\nEXPORT int dwg_add_BLOCK_HEADER (Dwg_Object *obj);\nEXPORT int dwg_add_LAYER_CONTROL (Dwg_Object *obj);\nEXPORT int dwg_add_LAYER (Dwg_Object *obj);\nEXPORT int dwg_add_STYLE_CONTROL (Dwg_Object *obj);\nEXPORT int dwg_add_STYLE (Dwg_Object *obj);\nEXPORT int dwg_add_LTYPE_CONTROL (Dwg_Object *obj);\nEXPORT int dwg_add_LTYPE (Dwg_Object *obj);\nEXPORT int dwg_add_VIEW_CONTROL (Dwg_Object *obj);\nEXPORT int dwg_add_VIEW (Dwg_Object *obj);\nEXPORT int dwg_add_UCS_CONTROL (Dwg_Object *obj);\nEXPORT int dwg_add_UCS (Dwg_Object *obj);\nEXPORT int dwg_add_VPORT_CONTROL (Dwg_Object *obj);\nEXPORT int dwg_add_VPORT (Dwg_Object *obj);\nEXPORT int dwg_add_APPID_CONTROL (Dwg_Object *obj);\nEXPORT int dwg_add_APPID (Dwg_Object *obj);\nEXPORT int dwg_add_DIMSTYLE_CONTROL (Dwg_Object *obj);\nEXPORT int dwg_add_DIMSTYLE (Dwg_Object *obj);\nEXPORT int dwg_add_VPORT_ENTITY_CONTROL (Dwg_Object *obj);\nEXPORT int dwg_add_VPORT_ENTITY_HEADER (Dwg_Object *obj);\nEXPORT int dwg_add_GROUP (Dwg_Object *obj);\nEXPORT int dwg_add_MLINESTYLE (Dwg_Object *obj);\nEXPORT int dwg_add_OLE2FRAME (Dwg_Object *obj);\nEXPORT int dwg_add_DUMMY (Dwg_Object *obj);\nEXPORT int dwg_add_LONG_TRANSACTION (Dwg_Object *obj);\nEXPORT int dwg_add_LWPOLYLINE (Dwg_Object *obj);\nEXPORT int dwg_add_HATCH (Dwg_Object *obj);\nEXPORT int dwg_add_XRECORD (Dwg_Object *obj);\nEXPORT int dwg_add_PLACEHOLDER (Dwg_Object *obj);\nEXPORT int dwg_add_LAYOUT (Dwg_Object *obj);\nEXPORT int dwg_add_PROXY_ENTITY (Dwg_Object *obj);\nEXPORT int dwg_add_PROXY_OBJECT (Dwg_Object *obj);\nEXPORT int dwg_add_UNKNOWN_ENT (Dwg_Object *obj);\nEXPORT int dwg_add_UNKNOWN_OBJ (Dwg_Object *obj);\n\n/* STABLE: */\nEXPORT int dwg_add_DICTIONARYVAR (Dwg_Object *obj);\nEXPORT int dwg_add_DICTIONARYWDFLT (Dwg_Object *obj);\nEXPORT int dwg_add_FIELD (Dwg_Object *obj);\nEXPORT int dwg_add_FIELDLIST (Dwg_Object *obj);\nEXPORT int dwg_add_IDBUFFER (Dwg_Object *obj);\nEXPORT int dwg_add_IMAGE (Dwg_Object *obj);\nEXPORT int dwg_add_IMAGEDEF (Dwg_Object *obj);\nEXPORT int dwg_add_IMAGEDEF_REACTOR (Dwg_Object *obj);\nEXPORT int dwg_add_LAYER_INDEX (Dwg_Object *obj);\nEXPORT int dwg_add_MLEADERSTYLE (Dwg_Object *obj);\nEXPORT int dwg_add_OBJECTCONTEXTDATA (Dwg_Object *obj);\nEXPORT int dwg_add_RASTERVARIABLES (Dwg_Object *obj);\nEXPORT int dwg_add_SCALE (Dwg_Object *obj);\nEXPORT int dwg_add_SORTENTSTABLE (Dwg_Object *obj);\nEXPORT int dwg_add_SPATIAL_FILTER (Dwg_Object *obj);\nEXPORT int dwg_add_SPATIAL_INDEX (Dwg_Object *obj);\nEXPORT int dwg_add_WIPEOUTVARIABLES (Dwg_Object *obj);\nEXPORT int dwg_add_WIPEOUT (Dwg_Object *obj);\n\n/* UNSTABLE: */\nEXPORT int dwg_add_ASSOCDEPENDENCY (Dwg_Object *obj);\nEXPORT int dwg_add_ASSOCPLANESURFACEACTIONBODY (Dwg_Object *obj);\nEXPORT int dwg_add_CAMERA (Dwg_Object *obj);\nEXPORT int dwg_add_DIMASSOC (Dwg_Object *obj);\nEXPORT int dwg_add_DBCOLOR (Dwg_Object *obj);\nEXPORT int dwg_add_DYNAMICBLOCKPURGEPREVENTER (Dwg_Object *obj);\nEXPORT int dwg_add_GEODATA (Dwg_Object *obj);\nEXPORT int dwg_add_HELIX (Dwg_Object *obj);\nEXPORT int dwg_add_LIGHT (Dwg_Object *obj);\nEXPORT int dwg_add_MULTILEADER (Dwg_Object *obj);\nEXPORT int dwg_add_OBJECT_PTR (Dwg_Object *obj);\nEXPORT int dwg_add_PERSSUBENTMANAGER (Dwg_Object *obj);\nEXPORT int dwg_add_TABLESTYLE (Dwg_Object *obj);\nEXPORT int dwg_add_UNDERLAY (Dwg_Object *obj);\nEXPORT int dwg_add_UNDERLAYDEFINITION (Dwg_Object *obj);\nEXPORT int dwg_add_VISUALSTYLE (Dwg_Object *obj);\n\n#ifdef DEBUG_CLASSES\n\n/* DEBUGGING and UNHANDLED: */\nEXPORT int dwg_add_VBA_PROJECT (Dwg_Object *obj);\nEXPORT int dwg_add_ASSOC2DCONSTRAINTGROUP (Dwg_Object *obj);\nEXPORT int dwg_add_ASSOCACTION (Dwg_Object *obj);\nEXPORT int dwg_add_ASSOCALIGNEDDIMACTIONBODY (Dwg_Object *obj);\nEXPORT int dwg_add_ASSOCNETWORK (Dwg_Object *obj);\nEXPORT int dwg_add_NAVISWORKSMODELDEF (Dwg_Object *obj);\n//EXPORT int dwg_add_ACSH_HISTORY_CLASS (Dwg_Object *obj);\nEXPORT int dwg_add_ACSH_SWEEP_CLASS (Dwg_Object *obj);\n//EXPORT int dwg_add_ARCALIGNEDTEXT (Dwg_Object *obj);\nEXPORT int dwg_add_ARC_DIMENSION (Dwg_Object *obj);\nEXPORT int dwg_add_ANNOTSCALEOBJECTCONTEXTDATA (Dwg_Object *obj);\n//EXPORT int dwg_add_ASSOCGEOMDEPENDENCY (Dwg_Object *obj);\nEXPORT int dwg_add_ASSOCOSNAPPOINTREFACTIONPARAM (Dwg_Object *obj);\nEXPORT int dwg_add_ASSOCPERSSUBENTMANAGER (Dwg_Object *obj);\n//EXPORT int dwg_add_ASSOCVERTEXACTIONPARAM (Dwg_Object *obj);\nEXPORT int dwg_add_DATATABLE (Dwg_Object *obj);\n//EXPORT int dwg_add_DETAILVIEWSTYLE (Dwg_Object *obj);\nEXPORT int dwg_add_EVALUATION_GRAPH (Dwg_Object *obj);\nEXPORT int dwg_add_GEOMAPIMAGE (Dwg_Object *obj);\nEXPORT int dwg_add_GEOPOSITIONMARKER (Dwg_Object *obj);\n//EXPORT int dwg_add_LAYER_FILTER (Dwg_Object *obj);\n//EXPORT int dwg_add_LAYOUTPRINTCONFIG (Dwg_Object *obj);\nEXPORT int dwg_add_LIGHTLIST (Dwg_Object *obj);\nEXPORT int dwg_add_MATERIAL (Dwg_Object *obj);\nEXPORT int dwg_add_MESH (Dwg_Object *obj);\n//EXPORT int dwg_add_NPOCOLLECTION (Dwg_Object *obj);\nEXPORT int dwg_add_PLOTSETTINGS (Dwg_Object *obj);\n//EXPORT int dwg_add_POINTCLOUD (Dwg_Object *obj);\n//EXPORT int dwg_add_SECTIONVIEWSTYLE (Dwg_Object *obj);\nEXPORT int dwg_add_CELLSTYLEMAP (Dwg_Object *obj);\n//EXPORT int dwg_add_DOCUMENTOPTIONS (Dwg_Object *obj);\nEXPORT int dwg_add_RENDERENVIRONMENT (Dwg_Object *obj);\nEXPORT int dwg_add_RENDERGLOBAL (Dwg_Object *obj);\n//EXPORT int dwg_add_RTEXT (Dwg_Object *obj);\nEXPORT int dwg_add_PLANESURFACE (Dwg_Object *obj);\nEXPORT int dwg_add_EXTRUDEDSURFACE (Dwg_Object *obj);\nEXPORT int dwg_add_LOFTEDSURFACE (Dwg_Object *obj);\nEXPORT int dwg_add_REVOLVEDSURFACE (Dwg_Object *obj);\nEXPORT int dwg_add_SWEPTSURFACE (Dwg_Object *obj);\nEXPORT int dwg_add_SUN (Dwg_Object *obj);\nEXPORT int dwg_add_SUNSTUDY (Dwg_Object *obj);\nEXPORT int dwg_add_TABLE (Dwg_Object *obj);\nEXPORT int dwg_add_TABLECONTENT (Dwg_Object *obj);\nEXPORT int dwg_add_TABLEGEOMETRY (Dwg_Object *obj);\n//EXPORT int dwg_add_XREFPANELOBJECT (Dwg_Object *obj);\n\n#endif /* DEBUG_CLASSES */\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n", "/*****************************************************************************/\n/*  LibreDWG - free implementation of the DWG file format                    */\n/*                                                                           */\n/*  Copyright (C) 2009-2010,2018-2019 Free Software Foundation, Inc.         */\n/*                                                                           */\n/*  This library is free software, licensed under the terms of the GNU       */\n/*  General Public License as published by the Free Software Foundation,     */\n/*  either version 3 of the License, or (at your option) any later version.  */\n/*  You should have received a copy of the GNU General Public License        */\n/*  along with this program.  If not, see <http://www.gnu.org/licenses/>.    */\n/*****************************************************************************/\n\n/*\n * decode.c: decoding functions\n * written by Felipe Castro\n * modified by Felipe Corr\u00eaa da Silva Sances\n * modified by Rodrigo Rodrigues da Silva\n * modified by Till Heuschmann\n * modified by Reini Urban\n * modified by Denis Pruchkovsky\n */\n\n#include \"config.h\"\n#ifdef __STDC_ALLOC_LIB__\n#  define __STDC_WANT_LIB_EXT2__ 1 /* for strdup */\n#else\n#  define _USE_BSD 1\n#endif\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <assert.h>\n#ifdef HAVE_WCHAR_H\n#  include <wchar.h>\n#endif\n\n#include \"common.h\"\n#include \"bits.h\"\n#include \"dwg.h\"\n#include \"hash.h\"\n#include \"decode.h\"\n#include \"print.h\"\n#include \"free.h\"\n#include \"dynapi.h\"\n\n/* The logging level for the read (decode) path.  */\nstatic unsigned int loglevel;\n/* the current version per spec block */\nstatic int cur_ver = 0;\nstatic BITCODE_BL rcount1 = 0, rcount2 = 0;\n\n#ifdef USE_TRACING\n/* This flag means we have checked the environment variable\n   LIBREDWG_TRACE and set `loglevel' appropriately.  */\nstatic bool env_var_checked_p;\n#endif /* USE_TRACING */\n#define DWG_LOGLEVEL loglevel\n\n#include \"logging.h\"\n#include \"dec_macros.h\"\n\n#define REFS_PER_REALLOC 128\n\n#define MAX(X, Y) ((X) > (Y) ? (X) : (Y))\n#define MIN(X, Y) ((X) < (Y) ? (X) : (Y))\n\n/*------------------------------------------------------------------------------\n * Private functions\n */\n\nstatic int resolve_objectref_vector (Bit_Chain *restrict dat,\n                                     Dwg_Data *restrict dwg);\n\nstatic void decode_preR13_section_ptr (const char *restrict name,\n                                       Dwg_Section_Type_r11 id,\n                                       Bit_Chain *restrict dat,\n                                       Dwg_Data *restrict dwg);\nstatic void decode_preR13_section_chk (Dwg_Section_Type_r11 id,\n                                       Bit_Chain *restrict dat,\n                                       Dwg_Data *restrict dwg);\nstatic int decode_preR13_section (Dwg_Section_Type_r11 id,\n                                  Bit_Chain *restrict dat,\n                                  Dwg_Data *restrict dwg);\nstatic int decode_preR13_entities (unsigned long start, unsigned long end,\n                                   unsigned long offset, Bit_Chain *dat,\n                                   Dwg_Data *restrict dwg);\n\nstatic int decode_preR13 (Bit_Chain *restrict dat, Dwg_Data *restrict dwg);\nstatic int decode_R13_R2000 (Bit_Chain *restrict dat, Dwg_Data *restrict dwg);\nstatic int decode_R2004 (Bit_Chain *restrict dat, Dwg_Data *restrict dwg);\nstatic int decode_R2007 (Bit_Chain *restrict dat, Dwg_Data *restrict dwg);\n\nstatic Dwg_Resbuf *dwg_decode_xdata (Bit_Chain *restrict dat,\n                                     Dwg_Object_XRECORD *restrict obj,\n                                     BITCODE_BL size);\n\nstatic int dwg_decode_eed (Bit_Chain *restrict dat,\n                           Dwg_Object_Object *restrict obj);\nstatic int dwg_decode_ole2 (Dwg_Entity_OLE2FRAME *restrict _obj);\n\nstatic int dwg_decode_object (Bit_Chain *dat, Bit_Chain *hdl_dat,\n                              Bit_Chain *str_dat,\n                              Dwg_Object_Object *restrict obj);\n\nstatic int dwg_decode_entity (Bit_Chain *dat, Bit_Chain *hdl_dat,\n                              Bit_Chain *str_dat,\n                              Dwg_Object_Entity *restrict ent);\nstatic int dwg_decode_common_entity_handle_data (Bit_Chain *dat,\n                                                 Bit_Chain *hdl_dat,\n                                                 Dwg_Object *restrict obj);\n\nstatic const char *dwg_ref_objname (const Dwg_Data *restrict dwg,\n                                    Dwg_Object_Ref *restrict ref);\nstatic const char *dwg_ref_tblname (const Dwg_Data *restrict dwg,\n                                    Dwg_Object_Ref *restrict ref);\n\n/*----------------------------------------------------------------------------\n * Public variables\n */\n// long unsigned int ktl_lastaddress;\n\n/*----------------------------------------------------------------------------\n * Public function definitions\n */\n\n/** dwg_decode\n * returns 0 on success.\n *\n * everything in dwg is cleared\n * and then either read from dat, or set to a default.\n */\nint\ndwg_decode (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)\n{\n  int i;\n  char version[7];\n\n  dwg->num_object_refs = 0;\n  // dwg->num_layers = 0; // see now dwg->layer_control->num_entries\n  dwg->num_entities = 0;\n  dwg->num_objects = 0;\n  dwg->num_classes = 0;\n  dwg->thumbnail.size = 0;\n  dwg->thumbnail.chain = NULL;\n  dwg->header.num_sections = 0;\n  dwg->header.section_infohdr.num_desc = 0;\n  dwg->dwg_class = NULL;\n  dwg->object_ref = NULL;\n  dwg->object = NULL;\n  dwg->object_map = hash_new (dat->size / 1000);\n  if (!dwg->object_map)\n    {\n      // whatever, we are obviously on a tiny system\n      dwg->object_map = hash_new (1024);\n      if (!dwg->object_map)\n        {\n          LOG_ERROR (\"Out of memory\");\n          return DWG_ERR_OUTOFMEM;\n        }\n    }\n  dwg->dirty_refs = 1;\n\n  // memset (&dwg->header, 0, sizeof (dwg->header)); // nope. needed for\n  // version\n  memset (&dwg->header_vars, 0, sizeof (dwg->header_vars));\n  memset (&dwg->summaryinfo, 0, sizeof (dwg->summaryinfo));\n  memset (&dwg->r2004_header.file_ID_string[0], 0, sizeof (dwg->r2004_header));\n  memset (&dwg->auxheader.aux_intro[0], 0, sizeof (dwg->auxheader));\n  memset (&dwg->second_header, 0, sizeof (dwg->second_header));\n\n  if (dwg->opts)\n    {\n      loglevel = dwg->opts & DWG_OPTS_LOGLEVEL;\n      dat->opts = dwg->opts;\n    }\n\n#ifdef USE_TRACING\n  /* Before starting, set the logging level, but only do so once.  */\n  if (!env_var_checked_p)\n    {\n      char *probe = getenv (\"LIBREDWG_TRACE\");\n      if (probe)\n        loglevel = atoi (probe);\n      env_var_checked_p = true;\n    }\n#endif /* USE_TRACING */\n\n  /* Version */\n  dat->byte = 0;\n  dat->bit = 0;\n  if (!dat->chain || dat->size < 58)\n    {\n      LOG_ERROR (\"dwg too small: %lu bytes\", dat->size);\n      return DWG_ERR_INVALIDDWG;\n    }\n  strncpy (version, (const char *)dat->chain, 6);\n  version[6] = '\\0';\n\n  dwg->header.version = 0;\n  for (i = 0; i < R_AFTER; i++)\n    {\n      if (strEQ (version, version_codes[(Dwg_Version_Type)i]))\n        {\n          dwg->header.version = (Dwg_Version_Type)i;\n          break;\n        }\n    }\n  if (!dwg->header.version)\n    {\n      if (strncmp (version, \"AC\", 2)) // let's ignore MC0.0 for now\n        {\n          LOG_ERROR (\"Invalid DWG, magic: %s\", version);\n        }\n      else\n        {\n          LOG_ERROR (\"Invalid or unimplemented DWG version code %s\", version);\n        }\n      return DWG_ERR_INVALIDDWG;\n    }\n  dat->version = dwg->header.version;\n  dwg->header.from_version = dat->version;\n  dat->from_version = dat->version;\n  LOG_INFO (\"This file's version code is: %s (%s)\\n\", version,\n            dwg_version_type(dat->version))\n\n#define WE_CAN                                                                \\\n  \"This version of LibreDWG is only capable of decoding \"                     \\\n  \"version R13-R2018 (code: AC1012-AC1032) DWG files.\\n\"\n\n  PRE (R_13)\n  {\n    LOG_ERROR (WE_CAN \"We don't decode many entities and no blocks yet.\")\n#ifndef IS_RELEASE\n    return decode_preR13 (dat, dwg);\n#endif\n  }\n\n  VERSIONS (R_13, R_2000) { return decode_R13_R2000 (dat, dwg); }\n  VERSION (R_2004) { return decode_R2004 (dat, dwg); }\n  VERSION (R_2007) { return decode_R2007 (dat, dwg); }\n  SINCE (R_2010)\n  {\n    read_r2007_init (dwg);\n    return decode_R2004 (dat, dwg);\n  }\n\n  // This line should not be reached\n  LOG_ERROR (\"LibreDWG does not support this version: %s.\", version)\n  return DWG_ERR_INVALIDDWG;\n}\n\n// We put the 3x 10 table fields into sections.\n// number is the number of elements in the table. >=r13 it is the id.\nstatic void\ndecode_preR13_section_ptr (const char *restrict name, Dwg_Section_Type_r11 id,\n                           Bit_Chain *restrict dat, Dwg_Data *restrict dwg)\n{\n  Dwg_Section *tbl = &dwg->header.section[id];\n  tbl->size = bit_read_RS (dat);\n  tbl->number = bit_read_RL (dat);\n  tbl->address = bit_read_RL (dat);\n  strncpy (tbl->name, name, 63);\n  LOG_TRACE (\"ptr table %-8s [%2d]: size:%-4u nr:%-2ld (0x%lx-0x%lx)\\n\",\n             tbl->name, id, tbl->size, (long)tbl->number, (unsigned long)tbl->address,\n             (unsigned long)(tbl->address + (unsigned long)(tbl->number * tbl->size)))\n}\n\nstatic void\ndecode_preR13_section_chk (Dwg_Section_Type_r11 id, Bit_Chain *restrict dat,\n                           Dwg_Data *restrict dwg)\n{\n  Dwg_Section *tbl = &dwg->header.section[id];\n\n#define CMP(f, type)                                                          \\\n  if (tbl->f != f)                                                            \\\n  LOG_ERROR (\"decode_preR13_section_chk %s %s\", tbl->name, #f)\n\n  // LOG_ERROR(name \"->\" #f \" \" FORMAT_##type \" != \" #f \" \" FORMAT_##type)\n  BITCODE_RS id1, size;\n  BITCODE_RL address;\n  BITCODE_RLd number;\n  id1 = bit_read_RS (dat);\n  size = bit_read_RS (dat);\n  CMP (size, RS);\n  number = (BITCODE_RLd)bit_read_RS (dat);\n  CMP (number, RL);\n  address = bit_read_RL (dat);\n  CMP (address, RL)\n#undef CMP\n  LOG_TRACE (\"chk table %-8s [%2d]: size:%-4u nr:%-3ld (0x%x)\\n\", tbl->name,\n             id, size, (long)tbl->number, address)\n}\n\nGCC30_DIAG_IGNORE (-Wformat-nonliteral)\n// TABLES really\nstatic int\ndecode_preR13_section (Dwg_Section_Type_r11 id, Bit_Chain *restrict dat,\n                       Dwg_Data *restrict dwg)\n{\n  Dwg_Section *tbl = &dwg->header.section[id];\n  int i;\n  BITCODE_BL vcount;\n  int error = 0;\n  long unsigned int num = dwg->num_objects;\n  long unsigned int old_size = num * sizeof (Dwg_Object);\n  long unsigned int size = tbl->number * sizeof (Dwg_Object);\n  long unsigned int pos;\n\n  if ((unsigned)tbl->number > 100000 || size > dat->size)\n    {\n      LOG_ERROR (\"Invalid table number %ld for %-8s [%2d]\", (long)tbl->number, tbl->name, id);\n      return DWG_ERR_INVALIDDWG;\n    }\n  LOG_TRACE (\"\\ncontents table %-8s [%2d]: size:%-4u nr:%-3ld (0x%lx-0x%lx)\\n\",\n             tbl->name, id, tbl->size, (long)tbl->number, (unsigned long)tbl->address,\n             (unsigned long)(tbl->address + ((unsigned long long)tbl->number * tbl->size)))\n  dat->byte = tbl->address;\n  if ((unsigned long)(tbl->number * tbl->size) > dat->size - dat->byte)\n    {\n      LOG_ERROR (\"Invalid table number %ld or size %ld for %-8s [%2d]\", (long)tbl->number, (long)tbl->size,\n                 tbl->name, id);\n      return DWG_ERR_INVALIDDWG;\n    }\n  if (dwg->num_objects % REFS_PER_REALLOC == 0)\n    dwg->object = realloc (dwg->object, old_size + size + REFS_PER_REALLOC);\n\n    // TODO: move to a spec dwg_r11.spec, and dwg_decode_r11_NAME\n#define PREP_TABLE(token)                                                     \\\n  Dwg_Object *obj = &dwg->object[num + i];                                    \\\n  Dwg_Object_##token *_obj = calloc (1, sizeof (Dwg_Object_##token));         \\\n  if (dat->byte > dat->size)                                                  \\\n    {                                                                         \\\n      free (_obj);                                                            \\\n      return DWG_ERR_INVALIDDWG;                                              \\\n    }                                                                         \\\n  obj->index = num + i;                                                       \\\n  obj->tio.object = calloc (1, sizeof (Dwg_Object_Object));                   \\\n  if (!_obj || !obj->tio.object)                                              \\\n    if (_obj) free (_obj);                                                    \\\n    return DWG_ERR_OUTOFMEM;                                                  \\\n  obj->tio.object->tio.token = _obj;                                          \\\n  obj->tio.object->objid = obj->index;                                        \\\n  obj->supertype = DWG_SUPERTYPE_OBJECT;                                      \\\n  obj->parent = dwg;                                                          \\\n  obj->name = obj->dxfname = (char *)#token;                                  \\\n  obj->type = obj->fixedtype = DWG_TYPE_##token;                              \\\n  _obj->parent = obj->tio.object;                                             \\\n  obj->tio.object->dwg = obj->parent;                                         \\\n  obj->tio.object->objid = obj->index; /* obj ptr itself might move */        \\\n  LOG_TRACE (\"\\n-- table entry \" #token \" [%d]:\\n\", i)\n\n#define CHK_ENDPOS                                                            \\\n  pos = tbl->address + ((long)(i + 1) * tbl->size);                           \\\n  if ((long)(pos - dat->byte) != 2)                                           \\\n    {                                                                         \\\n      LOG_WARN (\"offset %ld\", pos - dat->byte);                               \\\n    }                                                                         \\\n  dat->byte = pos\n\n  switch (id)\n    {\n\n    case SECTION_BLOCK:\n      for (i = 0; i < tbl->number; i++)\n        {\n          PREP_TABLE (BLOCK_HEADER);\n          // TODO DXF 8: layer name\n          FIELD_RC (flag, 70);\n          FIELD_TF (name, 32, 2);\n          FIELD_RS (used, 0);\n\n          // TODO RD elevation 30, 2RD base_pt 10: 24\n          FIELD_RC (block_scaling, 0);\n          FIELD_CAST (num_owned, RS, BL, 0);\n          FIELD_RC (flag2, 0);\n          FIELD_CAST (num_inserts, RS, RL, 0);\n          FIELD_RS (flag3, 0);\n          CHK_ENDPOS;\n        }\n      break;\n\n    case SECTION_LAYER:\n      for (i = 0; i < tbl->number; i++)\n        {\n          PREP_TABLE (LAYER);\n\n          FIELD_CAST (flag, RC, RS, 70); // 860\n          FIELD_TF (name, 32, 2);\n          FIELD_RS (used, 0);\n\n          FIELD_RS (color_rs, 62); // color, off if negative\n          FIELD_RS (ltype_rs, 6);  // style\n          // FIELD_RS (crc, 0);\n          CHK_ENDPOS;\n        }\n      break;\n\n    // was a text STYLE table, became a STYLE object\n    case SECTION_STYLE:\n      for (i = 0; i < tbl->number; i++)\n        {\n          PREP_TABLE (STYLE);\n\n          FIELD_RC (flag, 70);\n          FIELD_TF (name, 32, 2);\n          FIELD_RS (used, 0);\n\n          FIELD_RD (fixed_height, 40); // ok\n          FIELD_RD (width_factor, 41);\n          FIELD_RD (oblique_ang, 50);\n          FIELD_RC (generation, 71);\n          FIELD_RD (last_height, 42);\n          FIELD_TF (font_name, 64, 3);    // 8ed\n          FIELD_TF (bigfont_name, 64, 4); // 92d\n          CHK_ENDPOS;\n        }\n      break;\n\n    case SECTION_LTYPE:\n      for (i = 0; i < tbl->number; i++)\n        {\n          PREP_TABLE (LTYPE);\n\n          FIELD_RC (flag, 70);\n          FIELD_TF (name, 32, 2);\n          FIELD_RS (used, 0);\n          FIELD_TF (description, 48, 3);\n          FIELD_RC (alignment, 72);\n          FIELD_RC (num_dashes, 73);\n          FIELD_VECTOR (dashes_r11, RD, num_dashes, 340);\n          // ... 106 byte\n          // 3, 40, 49, 74, 75, 340, 46, 50, 44, 45, 9\n\n          CHK_ENDPOS;\n        }\n      break;\n\n    case SECTION_VIEW:\n      for (i = 0; i < tbl->number; i++)\n        {\n          PREP_TABLE (VIEW);\n\n          FIELD_RC (flag, 70);\n          FIELD_TF (name, 32, 2);\n          FIELD_RS (used, 0);\n\n          FIELD_RD (height, 40);\n          FIELD_2RD (center, 10);\n          FIELD_RD (width, 41);\n          FIELD_3RD (target, 12);\n          FIELD_3RD (direction, 11);\n          FIELD_CAST (VIEWMODE, RS, 4BITS, 71);\n          FIELD_RD (lens_length, 42);\n          FIELD_RD (front_clip, 43);\n          FIELD_RD (back_clip, 44);\n          FIELD_RD (twist_angle, 50);\n          CHK_ENDPOS;\n        }\n      break;\n\n    case SECTION_UCS:\n      for (i = 0; i < tbl->number; i++)\n        {\n          PREP_TABLE (UCS);\n\n          FIELD_RC (flag, 70);\n          FIELD_TF (name, 32, 2);\n          FIELD_RS (used, 0);\n          FIELD_2RD (origin, 10);\n          FIELD_2RD (x_direction, 11);\n          FIELD_2RD (y_direction, 12);\n\n          CHK_ENDPOS;\n        }\n      break;\n\n    case SECTION_VPORT:\n      for (i = 0; i < tbl->number; i++)\n        {\n          PREP_TABLE (VPORT);\n\n          FIELD_RC (flag, 70);\n          FIELD_TF (name, 32, 2);\n          FIELD_RS (used, 0);\n\n          FIELD_RD (VIEWSIZE, 40);\n          FIELD_RD (aspect_ratio, 41);\n          FIELD_2RD (VIEWCTR, 12);\n          FIELD_3RD (view_target, 17);\n          FIELD_3RD (VIEWDIR, 16);\n          FIELD_RD (view_twist, 50);\n          FIELD_RD (lens_length, 42);\n          FIELD_RD (front_clip, 43);\n          FIELD_RD (back_clip, 33);\n          FIELD_CAST (VIEWMODE, RS, 4BITS, 71);\n\n          FIELD_2RD (lower_left, 10);\n          FIELD_2RD (upper_right, 11);\n          FIELD_RC (UCSFOLLOW, 71);\n          FIELD_RS (circle_zoom, 72);\n          FIELD_RC (FASTZOOM, 73);\n          FIELD_RC (UCSICON, 74);\n          FIELD_RC (GRIDMODE, 76);\n          FIELD_2RD (GRIDUNIT, 15);\n          FIELD_CAST (SNAPMODE, RS, B, 70); // 75\n          FIELD_RC (SNAPSTYLE, 70);         // 77\n          FIELD_RS (SNAPISOPAIR, 78);\n          FIELD_RD (SNAPANG, 50);\n          FIELD_2RD (SNAPBASE, 13);\n          FIELD_2RD (SNAPUNIT, 14);\n          // ... 74 byte\n\n          CHK_ENDPOS;\n        }\n      break;\n\n    case SECTION_APPID:\n      for (i = 0; i < tbl->number; i++)\n        {\n          PREP_TABLE (APPID);\n\n          FIELD_RC (flag, 70);\n          FIELD_TF (name, 32, 2);\n          FIELD_RS (used, 0);\n          CHK_ENDPOS;\n        }\n      break;\n\n    case SECTION_DIMSTYLE:\n      for (i = 0; i < tbl->number; i++)\n        {\n          // unsigned long off;\n          PREP_TABLE (DIMSTYLE); // d1f\n\n          FIELD_RC (flag, 70);\n          FIELD_TF (name, 32, 2);\n          // off = dat->byte;\n          FIELD_RS (used, 0);      // d40\n          FIELD_RD (DIMSCALE, 40); // d42\n          FIELD_RD (DIMASZ, 41);\n          FIELD_RD (DIMEXO, 42);\n          FIELD_RD (DIMDLI, 43);\n          FIELD_RD (DIMEXE, 44);\n          FIELD_RD (DIMRND, 45);\n          FIELD_RD (DIMDLE, 46);\n          FIELD_RD (DIMTP, 47);\n          FIELD_RD (DIMTM, 48); // ok\n          FIELD_RD (DIMTXT, 140);\n          FIELD_RD (DIMCEN, 141); // ok\n          FIELD_RD (DIMTSZ, 142);\n          FIELD_RD (DIMALTF, 143);\n          FIELD_RD (DIMLFAC, 144);\n          FIELD_RD (DIMTVP, 145); // db2\n          FIELD_RC (DIMTOL, 71);  // dba\n          FIELD_RC (DIMLIM, 72);  // dbb\n          FIELD_RC (DIMTIH, 73);\n          FIELD_RC (DIMTOH, 74);\n          FIELD_RC (DIMSE1, 75);\n          FIELD_RC (DIMSE2, 76);\n          FIELD_CAST (DIMTAD, RC, RS, 77); // ok\n          FIELD_CAST (DIMZIN, RC, BS, 78); // dc1\n          FIELD_RC (DIMALT, 170);\n          FIELD_CAST (DIMALTD, RC, BS, 171); // ok\n          FIELD_RC (DIMTOFL, 172);           // ok\n          FIELD_RC (DIMSAH, 173);            // ok\n          FIELD_RC (DIMTIX, 174);            // ok\n          FIELD_RC (DIMSOXD, 175);           // ok\n          FIELD_TF (DIMPOST, 16, 3);         // ok dc8\n          FIELD_TF (DIMAPOST, 16, 4);        // dd8\n          FIELD_TF (DIMBLK_T, 16, 5);        //?? unsupported by ODA\n          FIELD_TF (DIMBLK1_T, 16, 6);       //?? unsupported by ODA\n          FIELD_TF (DIMBLK2_T, 66, 7);       //?? unsupported by ODA\n          // DEBUG_HERE; //e18\n          // dat->byte += 50; //unknown: DIMSHO, DIMASO (global)\n          FIELD_RS (DIMCLRD_N, 176); // e4a\n          FIELD_RS (DIMCLRE_N, 177);\n          FIELD_RS (DIMCLRT_N, 178); // e4e\n          FIELD_RC (DIMUPT, 0);      //??\n          FIELD_RD (DIMTFAC, 146);   // e51\n          FIELD_RD (DIMGAP, 147);    // e59\n          CHK_ENDPOS;                //-e63\n        }\n      break;\n\n    case SECTION_VPORT_ENTITY:\n      if (tbl->number)\n        {\n          LOG_WARN (\"VPORT_ENTITY table\");\n        }\n      break;\n\n    case SECTION_HEADER_R11:\n    default:\n      LOG_ERROR (\"Invalid table id %d\", id);\n      tbl->number = 0;\n      break;\n    }\n  dwg->num_objects += tbl->number;\n  dat->byte = tbl->address + (tbl->number * tbl->size);\n  return error;\n}\n\nstatic int\ndecode_entity_preR13 (Bit_Chain *restrict dat, Dwg_Object *restrict obj,\n                      Dwg_Object_Entity *ent)\n{\n  Dwg_Object_Entity *_obj = ent;\n\n  obj->type = bit_read_RC (dat);\n  _obj->flag_r11 = bit_read_RC (dat); // dxf 70\n  obj->size = bit_read_RS (dat);\n  LOG_INFO (\"\\n===========================\\n\"\n            \"Entity number: %d, Type: %d, Size: %d\\n\",\n            obj->index, obj->type, obj->size);\n  LOG_TRACE (\"flag_r11: \" FORMAT_RC \"\\n\", _obj->flag_r11);\n  FIELD_RS (layer_r11, 8);\n  FIELD_RS (opts_r11, 0);\n  // LOG_TRACE(\"Layer: %d, Opts: 0x%x\\n\", ent->layer_r11, ent->opts_r11)\n  if (ent->flag_r11 & 1)\n    {\n      FIELD_RC (color_r11, 0);\n    }\n  if (ent->flag_r11 & 0x40)\n    {\n      FIELD_RC (extra_r11, 0);\n    }\n  /* Common entity preR13 header: */\n  if (ent->extra_r11 & 2)\n    {\n      int error = dwg_decode_eed (dat, (Dwg_Object_Object *)ent);\n      if (error & (DWG_ERR_INVALIDEED | DWG_ERR_VALUEOUTOFBOUNDS))\n        return error;\n    }\n  if (FIELD_VALUE (flag_r11) & 2)\n    FIELD_RS (kind_r11, 0);\n\n  return 0;\n}\n\nstatic int\ndecode_preR13 (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)\n{\n  BITCODE_RL entities_start, entities_end, blocks_start, blocks_end;\n  BITCODE_RL rl1, rl2;\n  BITCODE_RS rs2;\n  Dwg_Object *obj = NULL;\n  int tbl_id;\n  int error = 0;\n\n  {\n    int i;\n    struct Dwg_Header *_obj = &dwg->header;\n    Bit_Chain *hdl_dat = dat;\n    dat->byte = 0x06;\n    // clang-format off\n    #include \"header.spec\"\n    // clang-format on\n  }\n  LOG_TRACE (\"@0x%lx\\n\", dat->byte); // 0x14\n\n  // tables really\n  dwg->header.num_sections = 12;\n  dwg->header.section = (Dwg_Section *)calloc (\n      1, sizeof (Dwg_Section) * dwg->header.num_sections);\n  if (!dwg->header.section)\n    {\n      LOG_ERROR (\"Out of memory\");\n      return DWG_ERR_OUTOFMEM;\n    }\n\n  entities_start = bit_read_RL (dat);\n  entities_end = bit_read_RL (dat);\n  LOG_TRACE (\"entities 0x%x - 0x%x\\n\", entities_start, entities_end);\n  blocks_start = bit_read_RL (dat);\n  rl1 = bit_read_RL (dat); // 0x40\n  blocks_end = bit_read_RL (dat);\n  rl2 = bit_read_RL (dat); // 0x80\n  LOG_TRACE (\"blocks   0x%x (0x%x) - 0x%x (0x%x)\\n\", blocks_start, rl1,\n             blocks_end, rl2);\n\n  tbl_id = 0;\n  dwg->header.section[0].number = 0;\n  dwg->header.section[0].type = (Dwg_Section_Type)SECTION_HEADER_R11;\n  strcpy (dwg->header.section[0].name, \"HEADER\");\n\n  decode_preR13_section_ptr (\"BLOCK\", SECTION_BLOCK, dat, dwg);\n  decode_preR13_section_ptr (\"LAYER\", SECTION_LAYER, dat, dwg);\n  decode_preR13_section_ptr (\"STYLE\", SECTION_STYLE, dat, dwg);\n  // skip one\n  decode_preR13_section_ptr (\"LTYPE\", SECTION_LTYPE, dat, dwg);\n  decode_preR13_section_ptr (\"VIEW\", SECTION_VIEW, dat, dwg);\n\n  if (dwg->header.section[SECTION_BLOCK].size > dat->size)\n    {\n      LOG_ERROR (\"BLOCK.size overflow\")\n      return DWG_ERR_INVALIDDWG;\n    }\n  LOG_TRACE (\"@0x%lx\\n\", dat->byte); // 0x5e\n  {\n    Dwg_Header_Variables *_obj = &dwg->header_vars;\n    Bit_Chain *hdl_dat = dat;\n    // clang-format off\n    #include \"header_variables_r11.spec\"\n    // clang-format on\n  }\n  LOG_TRACE (\"@0x%lx\\n\", dat->byte); // 0x23a\n\n  dat->byte = 0x3ef;\n  LOG_TRACE (\"@0x%lx\\n\", dat->byte);\n  decode_preR13_section_ptr (\"UCS\", SECTION_UCS, dat, dwg);\n  // skip: 0x500 - dat->bytes\n  dat->byte = 0x500;\n  LOG_TRACE (\"@0x%lx\\n\", dat->byte); // 0x23a\n  decode_preR13_section_ptr (\"VPORT\", SECTION_VPORT, dat, dwg);\n  rl1 = bit_read_RL (dat);\n  rl2 = bit_read_RL (dat);\n  LOG_TRACE (\"?2 long: 0x%x 0x%x\\n\", rl1, rl2);\n  decode_preR13_section_ptr (\"APPID\", SECTION_APPID, dat, dwg);\n  rl1 = bit_read_RL (dat);\n  rs2 = bit_read_RS (dat);\n  LOG_TRACE (\"?long+short: 0x%x 0x%x\\n\", rl1, (unsigned)rs2);\n  decode_preR13_section_ptr (\"DIMSTYLE\", SECTION_DIMSTYLE, dat, dwg);\n  // skip: 0x69f - dat->bytes\n  dat->byte = 0x69f;\n  decode_preR13_section_ptr (\"VPORT_ENTITY\", SECTION_VPORT_ENTITY, dat, dwg);\n  dat->byte += 38;\n  // entities\n  error |= decode_preR13_entities (entities_start, entities_end, 0, dat, dwg);\n  if (error >= DWG_ERR_CRITICAL)\n    return error;\n  dat->byte += 19; /* crc + sentinel? */\n  error |= decode_preR13_section (SECTION_BLOCK, dat, dwg);\n  error |= decode_preR13_section (SECTION_LAYER, dat, dwg);\n  error |= decode_preR13_section (SECTION_STYLE, dat, dwg);\n  error |= decode_preR13_section (SECTION_LTYPE, dat, dwg);\n  error |= decode_preR13_section (SECTION_VIEW, dat, dwg);\n  error |= decode_preR13_section (SECTION_UCS, dat, dwg);\n  error |= decode_preR13_section (SECTION_VPORT, dat, dwg);\n  error |= decode_preR13_section (SECTION_APPID, dat, dwg);\n  error |= decode_preR13_section (SECTION_DIMSTYLE, dat, dwg);\n  error |= decode_preR13_section (SECTION_VPORT_ENTITY, dat, dwg);\n  if (error >= DWG_ERR_CRITICAL)\n    return error;\n  // blocks\n  error |= decode_preR13_entities (blocks_start, blocks_end, blocks_start - 0x40000000,\n                          dat, dwg);\n  if (error >= DWG_ERR_CRITICAL)\n    return error;\n  LOG_TRACE (\"@0x%lx\\n\", dat->byte);\n  // 36 byte: 9x long\n  rl1 = bit_read_RL (dat);\n  rl2 = bit_read_RL (dat);\n  LOG_TRACE (\"?2long: 0x%x 0x%x %f\\n\", rl1, rl2,\n             (double)dat->chain[dat->byte - 8]);\n  rl1 = bit_read_RL (dat);\n  rl2 = bit_read_RL (dat);\n  LOG_TRACE (\"?2long: 0x%x 0x%x %f\\n\", rl1, rl2,\n             (double)dat->chain[dat->byte - 8]);\n  rl1 = bit_read_RL (dat);\n  rl2 = bit_read_RL (dat);\n  LOG_TRACE (\"?2long: 0x%x 0x%x %f\\n\", rl1, rl2,\n             (double)dat->chain[dat->byte - 8]);\n  rl1 = bit_read_RL (dat);\n  rl2 = bit_read_RL (dat);\n  LOG_TRACE (\"?2long: 0x%x 0x%x %f\\n\", rl1, rl2,\n             (double)dat->chain[dat->byte - 8]);\n  rl1 = bit_read_RL (dat);\n  LOG_TRACE (\"?1long: 0x%x\\n\", rl1);\n\n  LOG_TRACE (\"@0x%lx: 4 block ptrs chk\\n\", dat->byte);\n  if ((rl1 = bit_read_RL (dat)) != entities_start)\n    {\n      LOG_WARN (\"entities_start %x/%x\", rl1, entities_start);\n    }\n  if ((rl1 = bit_read_RL (dat)) != entities_end)\n    {\n      LOG_WARN (\"entities_end %x/%x\", rl1, entities_end);\n    }\n  if ((rl1 = bit_read_RL (dat)) != blocks_start)\n    {\n      LOG_WARN (\"blocks_start %x/%x\", rl1, blocks_start);\n    }\n  if ((rl1 = bit_read_RL (dat)) != blocks_end)\n    {\n      LOG_WARN (\"blocks_end %x/%x\", rl1, blocks_end);\n    }\n  // 12 byte\n  LOG_TRACE (\"@0x%lx\\n\", dat->byte);\n  rl1 = bit_read_RL (dat);\n  rl2 = bit_read_RL (dat);\n  LOG_TRACE (\"?2long: 0x%x 0x%x\\n\", rl1, rl2);\n  rl1 = bit_read_RL (dat);\n  LOG_TRACE (\"?1long: 0x%x\\n\", rl1);\n\n  dat->byte = blocks_end + 36 + 4 * 4 + 12;\n  LOG_TRACE (\"@0x%lx\\n\", dat->byte);\n  decode_preR13_section_chk (SECTION_BLOCK, dat, dwg);\n  decode_preR13_section_chk (SECTION_LAYER, dat, dwg);\n  decode_preR13_section_chk (SECTION_STYLE, dat, dwg);\n  decode_preR13_section_chk (SECTION_LTYPE, dat, dwg);\n  decode_preR13_section_chk (SECTION_VIEW, dat, dwg);\n  decode_preR13_section_chk (SECTION_UCS, dat, dwg);\n  decode_preR13_section_chk (SECTION_VPORT, dat, dwg);\n  decode_preR13_section_chk (SECTION_APPID, dat, dwg);\n  decode_preR13_section_chk (SECTION_DIMSTYLE, dat, dwg);\n  decode_preR13_section_chk (SECTION_VPORT_ENTITY, dat, dwg);\n  rl1 = bit_read_RL (dat);\n  LOG_TRACE (\"long 0x%x\\n\", rl1); // address\n\n  return 0;\n}\n\n/* ODA 3.2.6 SECTION-LOCATOR RECORDS: p.21\n   This is an ODA calculation mistake, it's not needed at all.\n\nstatic BITCODE_RS\nxor_section_CRC (BITCODE_RL num_sections, BITCODE_RS crc)\n{\n  switch (num_sections)\n    {\n    case 3:\n      crc ^= 0xA598;\n      break;\n    case 4:\n      crc ^= 0x8101;\n      break;\n    case 5:\n      crc ^= 0x3CC4;\n      break;\n    case 6:\n      crc ^= 0x8461;\n      break;\n    default:\n      LOG_WARN (\"Unknown num_sections \" FORMAT_RL \", wrong Section CRC\",\n                num_sections);\n    }\n  return crc;\n}\n*/\n\nstatic int\ndecode_R13_R2000 (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)\n{\n  Dwg_Object *obj = NULL;\n  unsigned int section_size = 0;\n  unsigned char sgdc[2];\n  unsigned int crc, crc2;\n  long unsigned int size;\n  long unsigned int lasta;\n  long unsigned int lastmap;\n  long unsigned int startpos;\n  long unsigned int object_begin;\n  long unsigned int object_end;\n  long unsigned int pvz;\n  BITCODE_BL j, k;\n  int error = 0;\n  const char *section_names[]\n      = { \"AcDb:Header\", \"AcDb:Classes\", \"AcDb:Handles\",\n          \"2NDHEADER\",   \"MEASUREMENT\",  \"AcDb:AuxHeader\" };\n\n  {\n    int i;\n    struct Dwg_Header *_obj = &dwg->header;\n    Bit_Chain *hdl_dat = dat;\n    dat->byte = 0x06;\n    // clang-format off\n    #include \"header.spec\"\n    // clang-format on\n  }\n\n  /* Section Locator Records 0x15 */\n  assert (dat->byte == 0x15);\n  dwg->header.num_sections = bit_read_RL (dat);\n  LOG_TRACE (\"\\nnum_sections: \" FORMAT_RL \" [RL]\\n\", dwg->header.num_sections)\n  if (!dwg->header.num_sections) // ODA writes zeros.\n    dwg->header.num_sections = 6;\n  if (dwg->header.num_sections < 3)\n    {\n      LOG_ERROR (\"Not enough sections: \" FORMAT_RL, dwg->header.num_sections);\n      return DWG_ERR_INVALIDDWG;\n    }\n  if (dwg->header.num_sections > 10)\n    {\n      LOG_ERROR (\"Too many sections: \" FORMAT_RL, dwg->header.num_sections);\n      return DWG_ERR_INVALIDDWG;\n    }\n\n  // So far seen 3-6 sections. Most emit only 3-5 sections.\n  dwg->header.section = (Dwg_Section *)calloc (\n      1, sizeof (Dwg_Section) * dwg->header.num_sections);\n  if (!dwg->header.section)\n    {\n      LOG_ERROR (\"Out of memory\");\n      return DWG_ERR_OUTOFMEM;\n    }\n  /* section 0: header vars\n   *         1: class section\n   *         2: object map\n   *         3: (R13 c3 and later): 2nd header (special table, no sentinels)\n   *         4: optional: MEASUREMENT\n   *         5: optional: AuxHeader (no sentinels)\n   */\n  for (j = 0; j < dwg->header.num_sections; j++)\n    {\n      dwg->header.section[j].number = bit_read_RC (dat);\n      dwg->header.section[j].address = bit_read_RL (dat);\n      dwg->header.section[j].size = bit_read_RL (dat);\n      if (j < 6)\n        strcpy (dwg->header.section[j].name, section_names[j]);\n      LOG_TRACE (\"section[%u].number:  %4d [RC] %s\\n\", j,\n                 (int)dwg->header.section[j].number, dwg->header.section[j].name)\n      LOG_TRACE (\"section[%u].address: %4u [RL]\\n\", j,\n                 (unsigned)dwg->header.section[j].address)\n      LOG_TRACE (\"section[%u].size:    %4u [RL]\\n\", j,\n                 (unsigned)dwg->header.section[j].size);\n      if (dwg->header.section[j].address + dwg->header.section[j].size > dat->size)\n        {\n          LOG_ERROR (\"section[%u] address or size overflow\", j);\n          return DWG_ERR_INVALIDDWG;\n        }\n    }\n\n  // Check CRC up to now (note: ODA has a bug here)\n  crc2 = bit_calc_CRC (0xC0C1, &dat->chain[0], dat->byte); // from 0 to now\n  crc = bit_read_RS (dat);\n  LOG_TRACE (\"crc: %04X [RSx] from 0-%lu\\n\", crc, dat->byte - 2);\n  if (crc != crc2)\n    {\n      LOG_ERROR (\"Header CRC mismatch %04X <=> %04X\", crc, crc2);\n      error |= DWG_ERR_WRONGCRC;\n    }\n\n  if (bit_search_sentinel (dat, dwg_sentinel (DWG_SENTINEL_HEADER_END)))\n    LOG_TRACE (\"         HEADER (end):    %4u\\n\", (unsigned)dat->byte)\n\n  /*-------------------------------------------------------------------------\n   * Section 5 AuxHeader\n   * R2000+, mostly redundant file header information\n   */\n\n  if (dwg->header.num_sections == 6 && dwg->header.version >= R_2000)\n    {\n      int i;\n      struct Dwg_AuxHeader *_obj = &dwg->auxheader;\n      Bit_Chain *hdl_dat = dat;\n      BITCODE_BL end_address\n          = dwg->header.section[SECTION_AUXHEADER_R2000].address\n            + dwg->header.section[SECTION_AUXHEADER_R2000].size;\n\n      obj = NULL;\n      dat->byte = dwg->header.section[SECTION_AUXHEADER_R2000].address;\n      LOG_TRACE (\"\\n\"\n                 \"=======> AuxHeader:       %4u\\n\", (unsigned)dat->byte)\n      LOG_TRACE (\"         AuxHeader (end): %4u\\n\", (unsigned)end_address)\n      if (dat->size < end_address)\n        {\n          LOG_ERROR (\"Invalid AuxHeader size: buffer overflow\")\n          error |= DWG_ERR_SECTIONNOTFOUND;\n        }\n      else\n        {\n          BITCODE_BL old_size = dat->size;\n          dat->size = end_address;\n          // clang-format off\n          #include \"auxheader.spec\"\n          // clang-format on\n          dat->size = old_size;\n        }\n    }\n\n  /*-------------------------------------------------------------------------\n   * Picture (Pre-R13C3?)\n   */\n\n  if (bit_search_sentinel (dat, dwg_sentinel (DWG_SENTINEL_THUMBNAIL_BEGIN)))\n    {\n      unsigned long int start_address;\n\n      dat->bit = 0;\n      start_address = dat->byte;\n      LOG_TRACE (\"\\n=======> Thumbnail:       %4u\\n\", (unsigned int)start_address - 16);\n      if (dwg->header.thumbnail_address\n          && dwg->header.thumbnail_address != dat->byte - 16)\n        LOG_WARN (\"Illegal HEADER.thumbnail_address: %i != %lu\",\n                  dwg->header.thumbnail_address, dat->byte - 16)\n      dwg->header.thumbnail_address = dat->byte - 16;\n      if (bit_search_sentinel (dat, dwg_sentinel (DWG_SENTINEL_THUMBNAIL_END)))\n        {\n          BITCODE_RL bmpsize;\n          LOG_TRACE (\"         Thumbnail (end): %4u\\n\",\n                     (unsigned int)dat->byte)\n          dwg->thumbnail.size = (dat->byte - 16) - start_address;\n          dwg->thumbnail.chain\n              = (unsigned char *)calloc (dwg->thumbnail.size, 1);\n          if (!dwg->thumbnail.chain)\n            {\n              LOG_ERROR (\"Out of memory\");\n              return DWG_ERR_OUTOFMEM;\n            }\n          memcpy (dwg->thumbnail.chain, &dat->chain[start_address],\n                  dwg->thumbnail.size);\n          dat->byte += dwg->thumbnail.size;\n\n          dwg_bmp (dwg, &bmpsize);\n          if (bmpsize > dwg->thumbnail.size)\n            LOG_ERROR (\"BMP size overflow: %i > %lu\\n\", bmpsize, dwg->thumbnail.size)\n        }\n    }\n\n  /*-------------------------------------------------------------------------\n   * Header Variables, section 0\n   */\n\n  LOG_INFO (\"\\n\"\n            \"=======> Header Variables:         %4u\\n\",\n            (unsigned int)dwg->header.section[SECTION_HEADER_R13].address)\n  LOG_INFO (\"         Header Variables   (end): %4u\\n\",\n            (unsigned int)(dwg->header.section[SECTION_HEADER_R13].address\n                           + dwg->header.section[SECTION_HEADER_R13].size))\n  if (dwg->header.section[SECTION_HEADER_R13].address < 58\n      || dwg->header.section[SECTION_HEADER_R13].address\n                 + dwg->header.section[SECTION_HEADER_R13].size\n             > dat->size)\n    {\n      LOG_ERROR (\"Invalid Header section, skipped\")\n      error |= DWG_ERR_SECTIONNOTFOUND;\n      goto classes_section;\n    }\n  // after sentinel\n  dat->byte = pvz = dwg->header.section[SECTION_HEADER_R13].address + 16;\n  // LOG_HANDLE (\"@ 0x%lx.%lu\\n\", bit_position (dat)/8, bit_position (dat)%8);\n  dwg->header_vars.size = bit_read_RL (dat);\n  LOG_TRACE (\"         Length: \" FORMAT_RL \" [RL]\\n\", dwg->header_vars.size)\n  dat->bit = 0;\n\n  dwg_decode_header_variables (dat, dat, dat, dwg);\n\n  // LOG_HANDLE (\"@ 0x%lx.%lu\\n\", bit_position (dat)/8, bit_position (dat)%8);\n  // check slack\n  if (dat->bit || dat->byte != pvz + dwg->header_vars.size + 4)\n    {\n      unsigned char r = 8 - dat->bit;\n      LOG_HANDLE (\" padding: %ld byte, %d bits\\n\",\n                  pvz + dwg->header_vars.size + 4 - dat->byte, r);\n    }\n  // Check CRC, hardcoded to 2 before end sentinel\n  LOG_HANDLE (\" crc pos: %lu\\n\", pvz + dwg->header_vars.size + 4);\n  bit_set_position (dat, (pvz + dwg->header_vars.size + 4) * 8);\n  crc = bit_read_RS (dat);\n  LOG_TRACE (\"crc: %04X [RSx] from %lu-%lu=%ld\\n\", crc, pvz, dat->byte - 2,\n             dat->byte - 2 - pvz);\n  crc2 = 0;\n  // LOG_HANDLE (\"@ 0x%lx\\n\", bit_position (dat)/8);\n  // LOG_HANDLE (\"HEADER_R13.address of size 0x%lx\\n\", pvz);\n  // LOG_HANDLE (\"HEADER_R13.size %d\\n\",\n  // dwg->header.section[SECTION_HEADER_R13].size);\n  // typical sizes: 400-599\n  if (dwg->header.section[SECTION_HEADER_R13].size > 34\n      && dwg->header.section[SECTION_HEADER_R13].size < 0xfff\n      && pvz < dat->byte\n      && pvz + dwg->header.section[SECTION_HEADER_R13].size < dat->size)\n    {\n      // not dwg->header_vars.size, rather -4 (minus the section_size).\n      // section_size + data, i.e. minus the 2x sentinel (32) + crc itself (2)\n      // if we would include the crc we would always get 0000\n      BITCODE_RL crc_size = dwg->header.section[SECTION_HEADER_R13].size - 34;\n      LOG_HANDLE (\" calc Header crc size: \" FORMAT_RL \"\\n\", crc_size);\n      crc2 = bit_calc_CRC (0xC0C1, &dat->chain[pvz], crc_size);\n    }\n  if (crc != crc2)\n    {\n      LOG_WARN (\"Header Section[%ld] CRC mismatch %04X <=> %04X\",\n                (long)dwg->header.section[SECTION_HEADER_R13].number, crc,\n                crc2);\n      error |= DWG_ERR_WRONGCRC;\n    }\n\n  /*-------------------------------------------------------------------------\n   * Classes, section 1\n   */\nclasses_section:\n  LOG_INFO (\"\\n\"\n            \"=======> CLASS (start): %4lu\\n\",\n            (long)dwg->header.section[SECTION_CLASSES_R13].address)\n  LOG_INFO (\"         CLASS (end)  : %4lu\\n\",\n            (long)(dwg->header.section[SECTION_CLASSES_R13].address\n                   + dwg->header.section[SECTION_CLASSES_R13].size))\n  dat->byte = dwg->header.section[SECTION_CLASSES_R13].address + 16;\n  dat->bit = 0;\n\n  size = bit_read_RL (dat);\n  lasta = dat->byte + size;\n  LOG_TRACE (\"         Length: %lu [RL]\\n\", size);\n\n  /* Read the classes\n   */\n  dwg->layout_type = 0;\n  dwg->num_classes = 0;\n  do\n    {\n      BITCODE_BS i;\n      Dwg_Class *klass;\n\n      i = dwg->num_classes;\n      if (i == 0)\n        dwg->dwg_class = malloc (sizeof (Dwg_Class));\n      else\n        dwg->dwg_class\n            = realloc (dwg->dwg_class, (i + 1) * sizeof (Dwg_Class));\n      if (!dwg->dwg_class)\n        {\n          LOG_ERROR (\"Out of memory\");\n          return DWG_ERR_OUTOFMEM;\n        }\n      klass = &dwg->dwg_class[i];\n      memset (klass, 0, sizeof (Dwg_Class));\n      klass->number = bit_read_BS (dat);\n      klass->proxyflag = bit_read_BS (dat);\n      klass->appname = bit_read_TV (dat);\n      klass->cppname = bit_read_TV (dat);\n      klass->dxfname = bit_read_TV (dat);\n      klass->wasazombie = bit_read_B (dat);\n      // 1f2 for entities, 1f3 for objects\n      klass->item_class_id = bit_read_BS (dat);\n      LOG_TRACE (\"Class %d 0x%x %s\\n\"\n                 \" %s \\\"%s\\\" %d 0x%x\\n\",\n                 klass->number, klass->proxyflag, klass->dxfname,\n                 klass->cppname, klass->appname, klass->wasazombie,\n                 klass->item_class_id)\n\n#if 0\n      SINCE (R_2007) //? dead code it seems. see read_2004_section_classes()\n      {\n        klass->num_instances = bit_read_BL (dat);\n        klass->dwg_version = bit_read_BL (dat);\n        klass->maint_version = bit_read_BL (dat);\n        klass->unknown_1 = bit_read_BL (dat);\n        klass->unknown_2 = bit_read_BL (dat);\n        LOG_TRACE (\n            \" num_instances: %d, dwg/maint version: %d/%d, unk: %d/%d\\n\",\n            klass->num_instances, klass->dwg_version, klass->maint_version,\n            klass->unknown_1, klass->unknown_2);\n      }\n#endif\n\n      if (klass->dxfname && strEQc ((const char *)klass->dxfname, \"LAYOUT\"))\n        dwg->layout_type = klass->number;\n\n      dwg->num_classes++;\n      if (dwg->num_classes > 500)\n        {\n          LOG_ERROR (\"number of classes is greater than 500\");\n          break;\n        }\n    }\n  while (dat->byte < (lasta - 1));\n\n  // Check Section CRC\n  dat->byte = dwg->header.section[SECTION_CLASSES_R13].address\n              + dwg->header.section[SECTION_CLASSES_R13].size - 18;\n  dat->bit = 0;\n  pvz = dwg->header.section[SECTION_CLASSES_R13].address + 16;\n  if (!bit_check_CRC (dat, pvz, 0xC0C1))\n    error |= DWG_ERR_WRONGCRC;\n\n  dat->byte += 16; //sentinel\n  pvz = bit_read_RL (dat); // Unknown bitlong inter class and object\n  LOG_TRACE (\"unknown: 0x%04lx [RL] @%lu\\n\", pvz, dat->byte - 4)\n  LOG_INFO (\"Number of classes read: %u\\n\", dwg->num_classes)\n\n  /*-------------------------------------------------------------------------\n   * Object-map, section 2\n   */\n\n  dat->byte = dwg->header.section[SECTION_HANDLES_R13].address;\n  dat->bit = 0;\n\n  lastmap = dat->byte + dwg->header.section[SECTION_HANDLES_R13].size; // 4\n  dwg->num_objects = 0;\n  object_begin = dat->size;\n  object_end = 0;\n  LOG_INFO (\"\\n\"\n            \"=======> Handles (start) : %8u\\n\",\n            (unsigned int)dwg->header.section[SECTION_HANDLES_R13].address)\n  LOG_INFO (\"         Handles (end)   : %8u\\n\",\n            (unsigned int)(dwg->header.section[SECTION_HANDLES_R13].address\n                           + dwg->header.section[SECTION_HANDLES_R13].size))\n  LOG_INFO (\"         Length: %u\\n\",\n            (unsigned int)dwg->header.section[SECTION_HANDLES_R13].size)\n\n  do\n    {\n      long unsigned int last_offset = 0;\n      long unsigned int last_handle = 0;\n      long unsigned int oldpos = 0;\n      long unsigned int maxh = (unsigned long)dwg->header.section[SECTION_HANDLES_R13].size << 1;\n      BITCODE_BL max_handles = maxh < INT32_MAX ? (BITCODE_BL)maxh\n        : dwg->header.section[SECTION_HANDLES_R13].size;\n      int added;\n\n      startpos = dat->byte;\n      section_size = bit_read_RS_LE (dat);\n      LOG_TRACE (\"Handles page size: %u [RS_LE] @%lu\\n\", section_size, startpos);\n      if (section_size > 2040)\n        {\n          LOG_ERROR (\"Object-map section size greater than 2040!\")\n          return DWG_ERR_VALUEOUTOFBOUNDS;\n        }\n\n      while (dat->byte - startpos < section_size)\n        {\n          BITCODE_UMC handleoff;\n          BITCODE_MC offset;\n          //BITCODE_BL last_handle = dwg->num_objects\n          //  ? dwg->object[dwg->num_objects - 1].handle.value : 0;\n\n          oldpos = dat->byte;\n          // the offset from the previous handle. default: 1, unsigned\n          handleoff = bit_read_UMC (dat);\n          // the offset from the previous address. default: obj->size, signed\n          offset = bit_read_MC (dat);\n          if (!handleoff || handleoff > max_handles - last_handle)\n            {\n              BITCODE_MC prevsize = dwg->num_objects\n                ? dwg->object[dwg->num_objects - 1].size + 4 : 0L;\n              LOG_WARN (\"Ignore invalid handleoff (@%lu)\", oldpos);\n              if (offset == 1 ||\n                  (offset > 0 && offset < prevsize && prevsize > 0) ||\n                  (offset < 0 && labs((long)offset) < prevsize && prevsize > 0))\n                {\n                  if (offset != prevsize)\n                    LOG_ERROR (\"Invalid offset: %ld [MC]\", offset);\n                  offset = prevsize;\n                  LOG_WARN (\"Recover invalid offset to %ld\", offset);\n                }\n            }\n          last_offset += offset;\n          LOG_TRACE (\"\\nNext object: %lu \", (unsigned long)dwg->num_objects)\n          LOG_TRACE (\"Handleoff: %lX [UMC] \"\n                     \"Offset: \" FORMAT_MC \" [MC] @%lu\\n\",\n                     handleoff, offset, last_offset)\n\n          if (dat->byte == oldpos)\n            break;\n\n          if (object_end < last_offset)\n            object_end = last_offset;\n          if (object_begin > last_offset)\n            object_begin = last_offset;\n\n          added = dwg_decode_add_object (dwg, dat, dat, last_offset);\n          if (added > 0)\n            error |= added; // else not added (skipped) or -1 for re-allocated\n          last_handle = dwg->object[dwg->num_objects - 1].handle.value;\n          // LOG_HANDLE (\"dat: @%lu.%u\\n\", dat->byte, dat->bit);\n        }\n      if (dat->byte == oldpos)\n        break;\n\n      // CRC on\n      if (dat->bit > 0)\n        {\n          dat->byte += 1;\n          dat->bit = 0;\n        }\n\n      crc = bit_read_RS_LE (dat);\n      LOG_TRACE (\"\\nHandles page crc: %04X [RS_LE] (%lu-%lu = %u)\\n\", crc,\n                 startpos, startpos + section_size, section_size);\n      crc2 = bit_calc_CRC (0xC0C1, dat->chain + startpos, section_size);\n      if (crc != crc2)\n        {\n          LOG_ERROR (\"Handles Section[%ld] page CRC mismatch %04X <=> %04X\",\n                     (long)dwg->header.section[SECTION_HANDLES_R13].number,\n                     crc, crc2);\n          // fails with r14\n          // if (dwg->header.version == R_2000)\n          //  return DWG_ERR_WRONGCRC;\n          if (dat->version != R_14)\n            error |= DWG_ERR_WRONGCRC;\n        }\n      if (dat->byte >= lastmap)\n        break;\n    }\n  while (section_size > 2);\n\n  LOG_INFO (\"Num objects: %lu\\n\", (unsigned long)dwg->num_objects)\n  LOG_INFO (\"\\n\"\n            \"=======> Last Object      : %8lu\\n\",\n            (unsigned long)object_begin)\n  dat->byte = object_end;\n  object_begin = bit_read_MS (dat);\n  LOG_TRACE (\"last object size: %lu [MS] (@%lu)\\n\", object_begin, object_end)\n  LOG_INFO (\"         Last Object (end): %8lu\\n\",\n            (unsigned long)(object_end + object_begin + 2))\n\n  /*\n   // TODO: if the previous Handleoff got corrupted somehow, read this handle map \n   // and try again.\n\n   dat->byte = dwg->header.section[SECTION_HANDLES_R13].address - 2;\n   // Unknown bitdouble inter object data and object map\n   antcrc = bit_read_CRC (dat);\n   LOG_TRACE(\"Address: %08u / Content: 0x%04X\", dat->byte - 2, antcrc)\n\n   // check CRC-on\n   antcrc = 0xC0C1;\n   do\n   {\n     startpos = dat->byte;\n     sgdc[0] = bit_read_RC (dat);\n     sgdc[1] = bit_read_RC (dat);\n     section_size = (sgdc[0] << 8) | sgdc[1];\n     section_size -= 2;\n     dat->byte += section_size;\n     crc = bit_read_CRC (dat);\n     dat->byte -= 2;\n     bit_write_CRC (dat, startpos, antcrc);\n     dat->byte -= 2;\n     crc2 = bit_read_CRC (dat);\n     if (loglevel) fprintf (stderr, \"Read: %X\\nCreated: %X\\t SEMO: %X\\n\",\n                            crc, crc2, antcrc);\n     //antcrc = crc;\n   } while (section_size > 0);\n   */\n\n  /*-------------------------------------------------------------------------\n   * Second header, section 3. R13-R2000 only.\n   * But partially also since r2004.\n   */\n\n  if (bit_search_sentinel (dat,\n                           dwg_sentinel (DWG_SENTINEL_SECOND_HEADER_BEGIN)))\n    {\n      BITCODE_RL i;\n      BITCODE_RC sig, sig2;\n      BITCODE_BL vcount;\n      long unsigned int pvzadr;\n      struct _dwg_second_header *_obj = &dwg->second_header;\n      obj = NULL;\n\n      LOG_INFO (\"\\n\"\n                \"=======> Second Header 3 (start): %8u\\n\",\n                (unsigned int)dat->byte - 16)\n      pvzadr = dat->byte;\n      LOG_TRACE (\"pvzadr: %lx\\n\", pvzadr)\n\n      FIELD_RL (size, 0);\n      FIELD_BLx (address, 0);\n\n      if (dwg->header.num_sections <= SECTION_2NDHEADER_R13)\n        {\n          LOG_WARN (\"Only %d num_sections, but 2ndheader found, extending to 4\",\n                    dwg->header.num_sections);\n          dwg->header.num_sections = SECTION_2NDHEADER_R13 + 1; /* 4 */\n          dwg->header.section\n              = realloc (dwg->header.section,\n                         dwg->header.num_sections * sizeof (Dwg_Section));\n          memset (&dwg->header.section[SECTION_2NDHEADER_R13], 0,\n                  sizeof (Dwg_Section));\n        }\n      if (!dwg->header.section[SECTION_2NDHEADER_R13].address)\n        {\n          dwg->header.section[SECTION_2NDHEADER_R13].address\n              = dwg->second_header.address;\n          dwg->header.section[SECTION_2NDHEADER_R13].size\n              = dwg->second_header.size;\n        }\n\n      // AC1012, AC1014 or AC1015. This is a char[11], zero padded.\n      // with \\n at 12.\n      bit_read_fixed (dat, _obj->version, 12);\n      LOG_TRACE (\"version: %s [TFF 12]\\n\", _obj->version)\n      for (i = 0; i < 4; i++)\n        FIELD_B (null_b[i], 0);\n      // DEBUG_HERE;\n      // documented as 0x18,0x78,0x01,0x04 for R13, 0x18,0x78,0x01,0x05 for R14\n      // r14:      7d f4 78 01\n      // r2000:    14 64 78 01\n      FIELD_RC (unknown_10, 0); // 0x10\n      for (i = 0; i < 4; i++)\n        FIELD_RC (unknown_rc4[i], 0);\n\n      if (dat->version < R_2000 && FIELD_VALUE (unknown_10) == 0x18\n          && FIELD_VALUE (unknown_rc4[0]) == 0x78)\n        dat->byte -= 2;\n      UNTIL (R_2000)\n      {\n        FIELD_RC (num_sections, 0); // r14: 5, r2000: 6\n        for (i = 0; i < MIN (6, FIELD_VALUE (num_sections)); i++)\n          {\n            // address+sizes of sections 0-2 is correct, 3+4 is empty\n            FIELD_RC (section[i].nr, 0);\n            FIELD_BLx (section[i].address, 0);\n            FIELD_BL (section[i].size, 0);\n          }\n        if (DWG_LOGLEVEL >= DWG_LOGLEVEL_HANDLE)\n          {\n            LOG_HANDLE (\"1st header was:\\n\");\n            for (i = 0; i < dwg->header.num_sections; i++)\n              {\n                LOG_HANDLE (\"section[\" FORMAT_RL \"] \" FORMAT_RLd \" \" FORMAT_RLL\n                            \" \" FORMAT_RL \" \\n\",\n                            i, dwg->header.section[i].number,\n                            dwg->header.section[i].address,\n                            dwg->header.section[i].size);\n              }\n            LOG_HANDLE (\"start 3: %lu\\n\", pvzadr - 16);\n          }\n\n        FIELD_BS (num_handlers, 0); // 14, resp. 16 in r14\n        if (FIELD_VALUE (num_handlers) > 16)\n          {\n            LOG_ERROR (\"Second header num_handlers > 16: %d\\n\",\n                       FIELD_VALUE (num_handlers));\n            FIELD_VALUE (num_handlers) = 14;\n          }\n        for (i = 0; i < FIELD_VALUE (num_handlers); i++)\n          {\n            FIELD_RC (handlers[i].size, 0);\n            FIELD_RC (handlers[i].nr, 0);\n            FIELD_VECTOR (handlers[i].data, RC, handlers[i].size, 0);\n          }\n\n        // TODO: CRC check\n        crc = bit_read_CRC (dat);\n        LOG_TRACE (\"crc: %04X\\n\", crc);\n\n        VERSION (R_14)\n        {\n          FIELD_RL (junk_r14_1, 0);\n          FIELD_RL (junk_r14_2, 0);\n        }\n      }\n\n      if (bit_search_sentinel (dat,\n                               dwg_sentinel (DWG_SENTINEL_SECOND_HEADER_END)))\n        LOG_INFO (\"         Second Header 3 (end)  : %8u\\n\",\n                  (unsigned int)dat->byte)\n    }\n\n  /*-------------------------------------------------------------------------\n   * Section 4: MEASUREMENT\n   */\n\n  if (dwg->header.num_sections > 4)\n    {\n      LOG_INFO (\"\\n\"\n                \"=======> MEASUREMENT 4 (start)  : %8u\\n\",\n                (unsigned int)dwg->header.section[4].address)\n      LOG_INFO (\"         MEASUREMENT 4 (end)    : %8u\\n\",\n                (unsigned int)(dwg->header.section[4].address\n                               + dwg->header.section[4].size))\n      dat->byte = dwg->header.section[4].address;\n      dat->bit = 0;\n      dwg->header_vars.MEASUREMENT = (BITCODE_BS)bit_read_RL (dat);\n      LOG_TRACE (\"MEASUREMENT: \" FORMAT_BS \" [RL] (0 English/1 Metric)\\n\",\n                 dwg->header_vars.MEASUREMENT)\n\n      //LOG_TRACE (\"         Size bytes :\\t%lu\\n\", dat->size)\n    }\n\n  // step II of handles parsing: resolve pointers from handle value\n  // XXX: move this somewhere else\n  LOG_INFO (\"\\nnum_objects: %lu\\n\", (unsigned long)dwg->num_objects)\n  LOG_TRACE (\"num_object_refs: %lu\\n\", (unsigned long)dwg->num_object_refs)\n  LOG_TRACE (\"Resolving pointers from ObjectRef vector:\\n\")\n  error |= resolve_objectref_vector (dat, dwg);\n  return error;\n}\n\nstatic int\nresolve_objectref_vector (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)\n{\n  BITCODE_BL i;\n  Dwg_Object *obj;\n\n  dwg->dirty_refs = 0;\n  for (i = 0; i < dwg->num_object_refs; i++)\n    {\n      Dwg_Object_Ref *ref = dwg->object_ref[i];\n      LOG_INSANE (\"==========\\n\")\n      LOG_TRACE (\"-objref[%3ld]: HANDLE\" FORMAT_REF \"\\n\", (long)i,\n                 ARGS_REF (ref))\n\n      // search the handle in all objects\n      obj = dwg_resolve_handle (dwg, ref->absolute_ref);\n      if (obj)\n        {\n          LOG_TRACE (\"-found:     HANDLE(\" FORMAT_H \") => [%u]\\n\",\n                     ARGS_H (obj->handle), obj->index)\n        }\n      // assign found pointer to objectref vector\n      ref->obj = obj;\n\n      if (DWG_LOGLEVEL >= DWG_LOGLEVEL_INSANE)\n        {\n          if (obj)\n            dwg_print_object (dat, obj);\n          else\n            LOG_TRACE (\"Null object pointer: object_ref[%ld]\\n\", (long)i)\n        }\n    }\n  return dwg->num_object_refs ? 0 : DWG_ERR_VALUEOUTOFBOUNDS;\n}\n\n/* Find the BITCODE_H for an object */\nDwg_Object_Ref *\ndwg_find_objectref (const Dwg_Data *restrict dwg,\n                    const Dwg_Object *restrict obj)\n{\n  for (BITCODE_BL i = 0; i < dwg->num_object_refs; i++)\n    {\n      Dwg_Object_Ref *ref = dwg->object_ref[i];\n      Dwg_Object *found = dwg_resolve_handle_silent (dwg, ref->absolute_ref);\n      if (found == obj)\n        return ref;\n    }\n  return NULL;\n}\n\nvoid\ndwg_resolve_objectrefs_silent (Dwg_Data *restrict dwg)\n{\n  BITCODE_BL i;\n  Dwg_Object *restrict obj;\n  int oldloglevel = loglevel;\n\n  loglevel = 0;\n  // Dwg_Object_Ref->obj are stored all over. dirty it to update dynamically.\n  // TODO: this is now forever. find a way to resolve all objs also.\n  dwg->dirty_refs = 1;\n  for (i = 0; i < dwg->num_object_refs; i++)\n    {\n      // scan num_objects for the id (absolute_ref)\n      obj = dwg_resolve_handle (dwg, dwg->object_ref[i]->absolute_ref);\n      dwg->object_ref[i]->obj = obj;\n    }\n  // TODO: scan dwg->num_objects also to update it's handlerefs\n  loglevel = oldloglevel;\n}\n\n/* endian specific */\nvoid\nbfr_read (void *restrict dst, BITCODE_RC *restrict *restrict src, size_t size)\n{\n  memcpy (dst, *src, size);\n  *src += size;\n}\n\n/* R2004 Literal Length\n */\nstatic unsigned int\nread_literal_length (Bit_Chain *restrict dat, unsigned char *restrict opcode)\n{\n  unsigned int total = 0;\n  BITCODE_RC byte = bit_read_RC (dat);\n\n  *opcode = 0x00;\n\n  if (byte >= 0x01 && byte <= 0x0F)\n    return byte + 3;\n  else if (byte == 0)\n    {\n      total = 0x0F;\n      while ((byte = bit_read_RC (dat)) == 0 && dat->size - dat->byte > 1)\n        {\n          total += 0xFF;\n        }\n      return total + byte + 3;\n    }\n  else if (byte & 0xF0)\n    *opcode = byte;\n\n  return 0;\n}\n\n/* R2004 Long Compression Offset\n */\nstatic int\nread_long_compression_offset (Bit_Chain *dat)\n{\n  int total = 0;\n  BITCODE_RC byte = bit_read_RC (dat);\n  if (byte == 0)\n    {\n      total = 0xFF;\n      while ((byte = bit_read_RC (dat)) == 0 && dat->size - dat->byte > 1)\n        total += 0xFF;\n    }\n  return total + byte;\n}\n\n/* R2004 Two Byte Offset\n */\nstatic int\nread_two_byte_offset (Bit_Chain *restrict dat, unsigned int *restrict lit_length)\n{\n  int offset;\n  BITCODE_RC firstByte = bit_read_RC (dat);\n  BITCODE_RC secondByte = bit_read_RC (dat);\n  offset = (firstByte >> 2) | (secondByte << 6);\n  *lit_length = (firstByte & 0x03);\n  return offset;\n}\n\n/* Decompresses a system section of a 2004+ DWG file\n */\nstatic int\ndecompress_R2004_section (Bit_Chain *restrict dat, BITCODE_RC *restrict decomp,\n                          uint32_t decomp_data_size, uint32_t comp_data_size)\n{\n  unsigned int i, lit_length;\n  uint32_t comp_offset, comp_bytes, bytes_left;\n  unsigned char opcode1 = 0, opcode2;\n  long unsigned int start_byte = dat->byte;\n  BITCODE_RC *src, *dst = decomp;\n  BITCODE_RC *maxdst = decomp + decomp_data_size;\n\n  bytes_left = decomp_data_size;               // to write to\n  if (comp_data_size > dat->size - start_byte) // bytes left to read from\n    {\n      LOG_WARN (\"Invalid comp_data_size %lu > %lu bytes left\",\n                (unsigned long)bytes_left, dat->size - dat->byte)\n      return DWG_ERR_VALUEOUTOFBOUNDS;\n    }\n  // length of the first sequence of uncompressed or literal data.\n  lit_length = read_literal_length (dat, &opcode1);\n  if (lit_length > bytes_left)\n    {\n      LOG_ERROR (\"Invalid literal_length %u > %u bytes left\",\n                 lit_length, (unsigned)decomp_data_size)\n      return DWG_ERR_VALUEOUTOFBOUNDS;\n    }\n  bit_read_fixed (dat, decomp, lit_length);\n  dst += lit_length;\n  bytes_left -= lit_length;\n\n  opcode1 = 0x00;\n  while (dat->byte - start_byte < comp_data_size)\n    {\n      LOG_INSANE (\"-O %x \", opcode1)\n      if (opcode1 == 0x00)\n        {\n          opcode1 = bit_read_RC (dat);\n          LOG_INSANE (\"<O %x \", opcode1)\n        }\n\n      if (opcode1 >= 0x40)\n        {\n          comp_bytes = ((opcode1 & 0xF0) >> 4) - 1;\n          opcode2 = bit_read_RC (dat);\n          LOG_INSANE (\"<O %x \", opcode2)\n          comp_offset = (opcode2 << 2) | ((opcode1 & 0x0C) >> 2);\n\n          if (opcode1 & 0x03)\n            {\n              lit_length = (opcode1 & 0x03);\n              opcode1 = 0x00;\n            }\n          else\n            lit_length = read_literal_length (dat, &opcode1);\n        }\n      else if (opcode1 >= 0x21\n               && opcode1 <= 0x3F) // lgtm [cpp/constant-comparison]\n        {\n          comp_bytes = opcode1 - 0x1E;\n          comp_offset = read_two_byte_offset (dat, &lit_length);\n\n          if (lit_length != 0)\n            opcode1 = 0x00;\n          else\n            lit_length = read_literal_length (dat, &opcode1);\n        }\n      else if (opcode1 == 0x20)\n        {\n          comp_bytes = read_long_compression_offset (dat) + 0x21;\n          comp_offset = read_two_byte_offset (dat, &lit_length);\n\n          if (lit_length != 0)\n            opcode1 = 0x00;\n          else\n            lit_length = read_literal_length (dat, &opcode1);\n        }\n      else if (opcode1 >= 0x12 && opcode1 <= 0x1F)\n        {\n          comp_bytes = (opcode1 & 0x0F) + 2;\n          comp_offset = read_two_byte_offset (dat, &lit_length) + 0x3FFF;\n\n          if (lit_length != 0)\n            opcode1 = 0x00;\n          else\n            lit_length = read_literal_length (dat, &opcode1);\n        }\n      else if (opcode1 == 0x10)\n        {\n          comp_bytes = read_long_compression_offset (dat) + 9;\n          comp_offset = read_two_byte_offset (dat, &lit_length) + 0x3FFF;\n\n          if (lit_length != 0)\n            opcode1 = 0x00;\n          else\n            lit_length = read_literal_length (dat, &opcode1);\n        }\n      else if (opcode1 == 0x11)\n        break; // Terminates the input stream, everything is ok\n      else\n        {\n          LOG_ERROR (\"Invalid opcode 0x%x in input stream at pos %lu\", opcode1,\n                     dat->byte);\n          return DWG_ERR_INTERNALERROR; // error in input stream\n        }\n\n      src = dst - comp_offset - 1;\n      if (src < decomp) // was assert (src >= decomp);\n        {\n          LOG_ERROR (\"decompress_R2004_section: src offset underflow\");\n          return DWG_ERR_INTERNALERROR;\n        }\n      if (comp_bytes)\n        {\n          LOG_INSANE (\"<C %d \", comp_bytes)\n          // copy \"compressed data\"\n          if ((uint32_t)comp_bytes > bytes_left || // bytes left to write\n              dst + comp_bytes > maxdst)\n            {\n              LOG_ERROR (\"Invalid comp_bytes %lu > %lu bytes left\",\n                         (unsigned long)comp_bytes, (unsigned long)bytes_left)\n              return DWG_ERR_VALUEOUTOFBOUNDS;\n            }\n          for (i = 0; i < comp_bytes; ++i)\n            *dst++ = *src++;\n          bytes_left -= comp_bytes;\n        }\n      // copy \"literal data\"\n      LOG_INSANE (\"<L %d\\n\", lit_length)\n      if (lit_length)\n        {\n          if ((lit_length > bytes_left) // bytes left to write\n              || dst + lit_length > maxdst)       // dst overflow\n            {\n              LOG_ERROR (\"Invalid lit_length %u > %lu bytes left\",\n                         lit_length, (unsigned long)bytes_left)\n              return DWG_ERR_VALUEOUTOFBOUNDS;\n            }\n          for (i = 0; i < lit_length; ++i)\n            *dst++ = bit_read_RC (dat);\n        }\n    }\n\n  return 0; // Success\n}\n\n// index is the Section Number in the section map\nstatic Dwg_Section *\nfind_section (Dwg_Data *dwg, unsigned long int idx)\n{\n  BITCODE_BL i;\n  if (dwg->header.section == 0 || idx == 0)\n    return 0;\n  for (i = 0; i < dwg->header.num_sections; ++i)\n    {\n      if ((unsigned long int)dwg->header.section[i].number == idx)\n        return &dwg->header.section[i];\n    }\n  return NULL;\n}\n\nstatic int\nadd_section (Dwg_Data *dwg)\n{\n  if (dwg->header.num_sections == 0)\n    dwg->header.section = calloc (1, sizeof (Dwg_Section));\n  else\n    {\n      dwg->header.section\n          = realloc (dwg->header.section,\n                     sizeof (Dwg_Section) * (dwg->header.num_sections + 1));\n      memset (&dwg->header.section[dwg->header.num_sections], 0,\n              sizeof (Dwg_Section));\n    }\n  if (!dwg->header.section)\n    {\n      LOG_ERROR (\"Out of memory\");\n      return DWG_ERR_OUTOFMEM;\n    }\n  dwg->header.num_sections++;\n  return 0;\n}\n\n/* Read R2004, 2010+ Section Map\n * The Section Map is a vector of number, size, and address(offset) triples\n * used to locate the sections in the file.\n */\nstatic int\nread_R2004_section_map (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)\n{\n  BITCODE_RC *decomp, *ptr;\n  int i, error = 0, found_section_map_id = 0;\n  uint64_t section_address;\n  int64_t bytes_remaining;\n  const uint32_t comp_data_size = dwg->r2004_header.comp_data_size;\n  const uint32_t decomp_data_size = dwg->r2004_header.decomp_data_size;\n  const int32_t section_array_size = (int32_t)dwg->r2004_header.section_array_size;\n  const uint64_t section_map_address = dwg->r2004_header.section_map_address + 0x100;\n  const BITCODE_RL section_map_id = dwg->r2004_header.section_map_id;\n  int max_id = 0;\n\n  dwg->header.num_sections = 0;\n  dwg->header.section = 0;\n\n  // decompressed data\n  decomp = (BITCODE_RC *)calloc (decomp_data_size + 1024, sizeof (BITCODE_RC));\n  if (!decomp)\n    {\n      LOG_ERROR (\"Out of memory\");\n      return DWG_ERR_OUTOFMEM;\n    }\n\n  error = decompress_R2004_section (dat, decomp, decomp_data_size + 1024,\n                                    comp_data_size);\n  if (error > DWG_ERR_CRITICAL || error == DWG_ERR_VALUEOUTOFBOUNDS)\n    {\n      free (decomp);\n      return error;\n    }\n  LOG_TRACE (\"\\n#### Read 2004 Section Page Map ####\\n\")\n\n  section_address = 0x100; // starting address\n  i = 0;\n  bytes_remaining = (int64_t)decomp_data_size;\n  ptr = decomp;\n  dwg->header.num_sections = 0;\n\n  while (bytes_remaining >= 8)\n    {\n      error |= add_section (dwg);\n      if (error > DWG_ERR_CRITICAL)\n        return error;\n\n      /* endian specific code: */\n      bfr_read (&dwg->header.section[i], &ptr, 8);\n      bytes_remaining -= 8;\n      LOG_TRACE (\"Section[%2d]=%2d,\", i, (int)dwg->header.section[i].number)\n      LOG_TRACE (\" size: %5u,\", dwg->header.section[i].size)\n      dwg->header.section[i].address = section_address;\n      if (dwg->header.section[i].number <= section_array_size) // GH #144\n        {\n          section_address += dwg->header.section[i].size;\n          LOG_TRACE (\" address: 0x%04lx\\n\",\n                     (unsigned long)dwg->header.section[i].address)\n        }\n      else\n        LOG_TRACE (\" (ignored > %d section_array_size)\\n\",\n                   (int)section_array_size);\n      if (dwg->header.section[i].number > max_id)\n        max_id = dwg->header.section[i].number;\n\n      // repair section_map_id.address from section_map_address\n      if ((BITCODE_RL)dwg->header.section[i].number == section_map_id)\n        {\n          found_section_map_id++;\n          if (dwg->header.section[i].address != section_map_address)\n            {\n              LOG_WARN (\"Repair invalid section_map_address: %\" PRIx64 \" != %\" PRIx64,\n                        dwg->header.section[i].address, section_map_address);\n              error |= DWG_ERR_VALUEOUTOFBOUNDS;\n              dwg->header.section[i].address = section_map_address;\n            }\n        }\n      if (i >= (int)section_array_size)\n        {\n          error |= DWG_ERR_VALUEOUTOFBOUNDS;\n          LOG_WARN (\"Overflow section_array_size: %d >= %d\",\n                    i, (int)section_array_size);\n          if (i > 1000)\n            return error;\n        }\n\n      if (bytes_remaining >= 16\n          && dwg->header.section[i].number < 0) // negative: gap/unused data\n        //|| dwg->header.section[i].number > section_array_size))\n        {\n          /* endian specific code: */\n          bfr_read (&dwg->header.section[i].parent, &ptr, 16);\n          bytes_remaining -= 16;\n          LOG_TRACE (\"  Parent: %d, \", dwg->header.section[i].parent)\n          LOG_TRACE (\"Left:   %d, \", dwg->header.section[i].left)\n          LOG_TRACE (\"Right:  %d, \", dwg->header.section[i].right)\n          LOG_TRACE (\"0x00:   %d\\n\", dwg->header.section[i].x00)\n        }\n\n      i++;\n    }\n  i--;\n  free (decomp);\n\n  if (max_id != (int32_t)section_array_size)\n    {\n      LOG_WARN (\"Invalid section_array_size: [%d].%d != %d\",\n                i, max_id, (int)section_array_size);\n    }\n  if (section_address\n      != (uint64_t)dwg->r2004_header.last_section_address + 0x100)\n    {\n      error |= DWG_ERR_VALUEOUTOFBOUNDS;\n      LOG_WARN (\"Invalid last_section_address: %\" PRIx64 \" != %\" PRIx64,\n                section_address, dwg->r2004_header.last_section_address);\n    }\n  if (dwg->header.num_sections\n      != dwg->r2004_header.num_gaps + dwg->r2004_header.num_sections)\n    {\n      error |= DWG_ERR_VALUEOUTOFBOUNDS;\n      LOG_WARN (\"Invalid num_sections: %d != gaps: \" FORMAT_RL\n                \" + sects: \" FORMAT_RL,\n                dwg->header.num_sections, dwg->r2004_header.num_gaps,\n                dwg->r2004_header.num_sections);\n    }\n  if (!found_section_map_id)\n    {\n      BITCODE_RLx section_type;\n      Dwg_Section *info;\n      LOG_WARN (\"section_map_id \" FORMAT_RL \" not found\", section_map_id);\n      info = find_section (dwg, section_map_id);\n      if (!info)\n        {\n          i = dwg->header.num_sections;\n          add_section (dwg);\n          LOG_WARN (\"Add section_map_id [%d] %d => address 0x%\" PRIx64, i,\n                    section_map_id, section_map_address);\n          error |= DWG_ERR_VALUEOUTOFBOUNDS;\n          dwg->header.section[i].number = section_map_id;\n          dwg->header.section[i].address = section_map_address;\n          if (i > 0)\n            dwg->header.section[i].size\n              = section_map_address - dwg->header.section[i - 1].address;\n        }\n      info = find_section (dwg, dwg->r2004_header.section_info_id);\n      if (!info)\n        goto repair_info_id;\n      dat->bit = 0;\n      dat->byte = info->address;\n      section_type = bit_read_RL (dat);\n      if (section_type != 0x4163003b)\n        {\n        repair_info_id:\n          LOG_WARN (\"Repair invalid section_info_id [%d]: => %u\",\n                    i-1, dwg->r2004_header.section_info_id);\n          error |= DWG_ERR_VALUEOUTOFBOUNDS;\n          for (i = 0; i < (int)dwg->header.num_sections; ++i)\n            {\n              dat->bit = 0;\n              dat->byte = dwg->header.section[i].address;\n              if (dat->byte > dat->size)\n                break;\n              section_type = bit_read_RL (dat);\n              if (section_type == 0x4163003b)\n                {\n                  LOG_WARN (\"Fixed section_info_id [%d]: => %u @\" FORMAT_RLL,\n                            i, dwg->r2004_header.section_info_id,\n                            dwg->header.section[i].address);\n                  if (!info)\n                    info = &dwg->header.section[i];\n                  info->address = dwg->header.section[i].address;\n                  info->size = dwg->header.section[i].size;\n                  info->number = dwg->r2004_header.section_info_id;\n                }\n            }\n          if (!info || info->number != (int)dwg->r2004_header.section_info_id)\n            {\n              i = dwg->header.num_sections;\n              add_section (dwg);\n              error |= DWG_ERR_VALUEOUTOFBOUNDS;\n              dwg->header.section[i].number = dwg->r2004_header.section_info_id;\n              dwg->header.section[i].address = dwg->header.section[i-1].address +\n                dwg->header.section[i-1].size;\n              LOG_WARN (\"Add section_info_id [%d] %u => address 0x%\" PRIx64, i,\n                        dwg->r2004_header.section_info_id,\n                        dwg->header.section[i].address);\n            }\n        }\n    }\n  if (found_section_map_id > 1)\n    {\n      error |= DWG_ERR_VALUEOUTOFBOUNDS;\n      LOG_WARN (\"Illegal 2004 Section Page Map. Found %d section_map_id sections\",\n                found_section_map_id)\n    }\n\n  return error;\n}\n\n/* Read R2004, 2010+ Section Info, aka 2004 Data section map\n */\nstatic int\nread_R2004_section_info (Bit_Chain *restrict dat, Dwg_Data *restrict dwg,\n                         uint32_t comp_data_size, uint32_t decomp_data_size)\n{\n  BITCODE_RC *decomp, *ptr, *decomp_end;\n  BITCODE_BL i, j;\n  int32_t section_number = 0;\n  uint32_t data_size, maxsize;\n  uint64_t offset;\n  int error;\n\n  decomp = (BITCODE_RC *)calloc (decomp_data_size + 1024, sizeof (BITCODE_RC));\n  if (!decomp)\n    {\n      LOG_ERROR (\"Out of memory\");\n      return DWG_ERR_OUTOFMEM;\n    }\n\n  error = decompress_R2004_section (dat, decomp, decomp_data_size + 1024,\n                                    comp_data_size);\n  if (error > DWG_ERR_CRITICAL || error == DWG_ERR_VALUEOUTOFBOUNDS)\n    {\n      free (decomp);\n      return error;\n    }\n\n  ptr = decomp;\n  bfr_read (&dwg->header.section_infohdr, &ptr, 20);\n  LOG_TRACE (\"\\n#### Read 2004 section_infohdr ####\\n\")\n  LOG_TRACE (\"num_desc:   %d\\n\", dwg->header.section_infohdr.num_desc)\n  LOG_TRACE (\"compressed: %d\\n\", dwg->header.section_infohdr.compressed)\n  LOG_TRACE (\"max_size:   0x%x\\n\", dwg->header.section_infohdr.max_size)\n  LOG_TRACE (\"encrypted:  %d\\n\", dwg->header.section_infohdr.encrypted)\n  LOG_TRACE (\"num_desc2:  %d/0x%x\\n\", dwg->header.section_infohdr.num_desc2,\n             dwg->header.section_infohdr.num_desc2)\n  if (dwg->header.section_infohdr.num_desc > 0xf000000)\n    {\n      LOG_ERROR (\"Illegal num_desc2\");\n      free (decomp);\n      dwg->header.section_infohdr.num_desc = 0;\n      dwg->header.section_infohdr.num_desc2 = 0;\n      return error | DWG_ERR_INVALIDDWG;\n    }\n  dwg->header.section_info = (Dwg_Section_Info *)calloc (\n      dwg->header.section_infohdr.num_desc, sizeof (Dwg_Section_Info));\n  if (!dwg->header.section_info)\n    {\n      LOG_ERROR (\"Out of memory\");\n      return error | DWG_ERR_OUTOFMEM;\n    }\n  decomp_end = decomp + decomp_data_size + 1024;\n  for (i = 0; i < dwg->header.section_infohdr.num_desc; ++i)\n    {\n      Dwg_Section_Info *info;\n      uint64_t sum_decomp = 0;\n      uint64_t prev_address = 0;\n\n      if (ptr + 64 >= decomp_end)\n        {\n          free (decomp);\n          dwg->header.section_infohdr.num_desc = i;\n          LOG_ERROR (\"read_R2004_section_info out of range\");\n          return DWG_ERR_INVALIDDWG;\n        }\n      info = &dwg->header.section_info[i];\n      /* endian specific code */\n      bfr_read (info, &ptr, 32 + 64);\n\n      LOG_TRACE (\"\\nsection_info[%d] fields:\\n\", i)\n      LOG_TRACE (\"size:            %ld\\n\", (long)info->size)\n      LOG_TRACE (\"num_sections:    %u\\n\", info->num_sections)\n      LOG_TRACE (\"max_decomp_size: %u / 0x%x\\n\", // normally 0x7400\n                 info->max_decomp_size, info->max_decomp_size)\n      LOG_TRACE (\"unknown:         %u\\n\", info->unknown)\n      LOG_TRACE (\"compressed:      %u (1=no, 2=yes)\\n\", info->compressed)\n      LOG_TRACE (\"type:            0x%x\\n\", (unsigned)info->type)\n      LOG_TRACE (\"encrypted:       %d (0=no, 1=yes, 2=unknown)\\n\",\n                 info->encrypted)\n      LOG_TRACE (\"name:            %s\\n\\n\", info->name)\n\n      if (ptr + (16 * info->num_sections) >= decomp_end)\n        {\n          info->name[0] = '\\0';\n          info->num_sections = 0;\n          info->sections = NULL;\n          dwg->header.section_infohdr.num_desc = i;\n          free (decomp);\n          LOG_ERROR (\"read_R2004_section_info out of range\");\n          return DWG_ERR_INVALIDDWG;\n        }\n\n      if (info->num_sections < 1000000)\n        {\n          int32_t old_section_number = 0;\n          LOG_INFO (\"Page count %u in area %d\\n\", info->num_sections, i);\n          info->sections = calloc (info->num_sections, sizeof (Dwg_Section *));\n          if (!info->sections)\n            {\n              free (decomp);\n              LOG_ERROR (\"Out of memory with %u sections\", info->num_sections);\n              return error | DWG_ERR_OUTOFMEM;\n            }\n          prev_address = 0;\n\n          for (j = 0; j < info->num_sections; j++)\n            {\n              struct _section_page\n              { /* unused */\n                int32_t number;\n                uint32_t size;\n                uint64_t address;\n              } page;\n              /* endian specific code: */\n              bfr_read (&page, &ptr, 16);\n#if 0\n              section_number = *((int32_t*)ptr);     // Index into SectionMap\n              data_size      = *((uint32_t*)ptr + 1);\n              address        = *((uint64_t*)ptr + 2); // TODO avoid alignment ubsan\n              //address   = *((uint32_t*)ptr + 2);\n              //address <<= 32;\n              //address  += *((uint32_t*)ptr + 3);\n              ptr += 16; /* 4*4 */\n#endif\n              sum_decomp += page.size; /* TODO: uncompressed size */\n#if 0\n              if (page.address < sum_decomp)\n                {\n                  /* ODA: \"If the start offset is smaller than the sum of the decompressed\n                   * size of all previous pages, then this page is to be preceded by\n                   * zero pages until this condition is met. */\n                  LOG_WARN(\"address %lu < sum_decomp %lu\", page.address, sum_decomp)\n                }\n#endif\n              info->sections[j] = find_section (dwg, page.number);\n\n              if (page.number < 0)\n                { // gap/unused data\n                  LOG_TRACE (\"Page: %4\" PRId32 \" (-)\", page.number)\n                  info->num_sections++;\n                  info->sections\n                      = realloc (info->sections,\n                                 info->num_sections * sizeof (Dwg_Section *));\n                  info->sections[info->num_sections - 1] = NULL;\n                }\n              else if (page.address < prev_address)\n                {\n                  LOG_TRACE (\"Page: %4\" PRId32 \" (a)\", page.number)\n                }\n              else if (info->sections[0]\n                       && page.number > (int32_t) (\n                              info->num_sections + info->sections[0]->number))\n                {\n                  // for [7] ptr+160 seems to be AcDb:ObjFreeSpace\n                  LOG_INFO (\"Page: %4\" PRId32 \" (n)\", page.number)\n                }\n              else if (!info->sections[j]\n                       && page.number != old_section_number + 1)\n                {\n                  LOG_INFO (\"Page: %4\" PRId32 \" (b)\", page.number)\n                  LOG_TRACE (\" size: %5\" PRIu32, page.size) // compressed\n                  LOG_TRACE (\" address: 0x%\" PRIx64, page.address)\n                  if (info->sections[j])\n                    LOG_TRACE (\" info: 0x%\" PRIx64, info->sections[j]->address);\n                  LOG_TRACE (\"\\n\")\n                  ptr -= 16;\n                  break;\n                }\n              else\n                {\n                  LOG_TRACE (\"Page: %4\" PRId32 \"    \", page.number)\n                  old_section_number = page.number;\n                  prev_address = page.address;\n                }\n              LOG_TRACE (\" size: %5\" PRIu32, page.size) // compressed\n              LOG_TRACE (\" address: 0x%\" PRIx64, page.address)\n              if (info->sections[j])\n                LOG_TRACE (\" info: 0x%\" PRIx64, info->sections[j]->address);\n              LOG_TRACE (\"\\n\")\n            }\n        }\n      else\n        {\n          LOG_ERROR (\"Section count %u in area %d too high! Skipping\",\n                     info->num_sections, i);\n          info->num_sections = 0;\n          free (decomp);\n          return error | DWG_ERR_VALUEOUTOFBOUNDS;\n        }\n    }\n  free (decomp);\n  return error;\n}\n\n/* Encrypted Section Header */\n#pragma pack(1)\ntypedef union _encrypted_section_header\n{\n  uint32_t long_data[8];\n  unsigned char char_data[32];\n  struct\n  {\n    uint32_t tag;\n    uint32_t section_type;\n    uint32_t data_size;\n    uint32_t section_size;\n    uint32_t address;\n    uint32_t unknown;\n    uint32_t checksum_1;\n    uint32_t checksum_2;\n  } fields;\n} encrypted_section_header;\n\nstatic int\nread_2004_compressed_section (Bit_Chain *dat, Dwg_Data *restrict dwg,\n                              Bit_Chain *sec_dat, BITCODE_RL section_type)\n{\n  uint32_t address, sec_mask, initial_address;\n  uint32_t max_decomp_size;\n  Dwg_Section_Info *info = NULL;\n  encrypted_section_header es;\n  BITCODE_RC *decomp;\n  BITCODE_BL i, j;\n  int error = 0;\n\n  for (i = 0; i < dwg->header.section_infohdr.num_desc && !info; ++i)\n    {\n      if (dwg->header.section_info[i].type == section_type)\n        {\n          info = &dwg->header.section_info[i];\n          break;\n        }\n    }\n  sec_dat->chain = NULL; // fixes double-free\n  if (!info)\n    {\n      LOG_WARN (\"Failed to find section_info[\" FORMAT_BL \"] with type 0x%x\", i,\n                section_type);\n      return DWG_ERR_SECTIONNOTFOUND;\n    }\n  else\n    {\n      LOG_TRACE (\"\\nFound section_info[\" FORMAT_BL\n                 \"] %s type 0x%x with %d sections (%scompressed):\\n\",\n                 i, info->name, section_type, info->num_sections,\n                 info->compressed == 2 ? \"\" : \"un\");\n    }\n\n  max_decomp_size = info->num_sections * info->max_decomp_size;\n  if (max_decomp_size == 0)\n    {\n      LOG_ERROR (\"Section %s count or max decompression size is zero. \"\n                 \"Sections: %u, Max size: %u\",\n                 info->name, info->num_sections, info->max_decomp_size);\n      return DWG_ERR_INVALIDDWG;\n    }\n  decomp = (BITCODE_RC *)calloc (max_decomp_size, sizeof (BITCODE_RC));\n  if (!decomp)\n    {\n      LOG_ERROR (\"Out of memory with %u sections\", info->num_sections);\n      return DWG_ERR_OUTOFMEM;\n    }\n  initial_address = info->sections[0] ? info->sections[0]->address : 0;\n  sec_dat->bit = 0;\n  sec_dat->byte = 0;\n  sec_dat->version = dat->version;\n  sec_dat->from_version = dat->from_version;\n  sec_dat->chain = decomp;\n\n  for (i = 0; i < info->num_sections; ++i)\n    {\n      if (!info->sections[i])\n        {\n          LOG_WARN (\"Skip empty section %u %s\", i, info->name);\n          continue;\n        }\n      address = info->sections[i]->address;\n      dat->byte = address;\n      bit_read_fixed (dat, es.char_data, 32);\n\n      //? if encrypted properties: security_type & 2 ??\n      sec_mask = 0x4164536b ^ address;\n      for (j = 0; j < 8; ++j)\n        es.long_data[j] ^= sec_mask;\n\n      LOG_INFO (\"=== Section %s (%u) @%u ===\\n\", info->name, i, address)\n      if (es.fields.tag != 0x4163043b)\n        {\n          LOG_WARN (\"Section Tag:      0x%x  (should be 0x4163043b)\",\n                    (unsigned)es.fields.tag);\n        }\n      else\n        {\n          LOG_INFO (\"Section Tag:      0x%x\\n\", (unsigned)es.fields.tag);\n        }\n      LOG_INFO (\"Section Type:     %u\\n\", (unsigned)es.fields.section_type)\n      // this is the number of bytes that is read in decompress_R2004_section\n      // (+ 2bytes)\n      LOG_INFO (\"Data size:        0x%x/%u\\n\", (unsigned)es.fields.data_size,\n                (unsigned)es.fields.data_size)\n      LOG_INFO (\"Comp data size:   0x%x\\n\", (unsigned)es.fields.section_size)\n      LOG_TRACE (\"StartOffset:      0x%x\\n\", (unsigned)es.fields.address)\n      LOG_HANDLE (\"Unknown:          0x%x\\n\", (unsigned)es.fields.unknown)\n      LOG_HANDLE (\"Checksum1:        0x%x\\n\", (unsigned)es.fields.checksum_1)\n      LOG_HANDLE (\"Checksum2:        0x%x\\n\", (unsigned)es.fields.checksum_2)\n      LOG_TRACE (\"Section start:    %lu\\n\\n\", dat->byte);\n\n      // GH #126 part 4\n      // LOG_INSANE (\"i:                     %u\\n\", i)\n      // LOG_INSANE (\"decomp:                %p\\n\", decomp)\n      // LOG_INSANE (\"info->max_decomp_size: %u\\n\", info->max_decomp_size)\n      // LOG_INSANE (\"max_decomp_size:       %u\\n\", max_decomp_size)\n      // LOG_INSANE (\"bytes_left:            %d\\n\",\n      //            max_decomp_size - (i * info->max_decomp_size))\n\n      // check if compressed at all\n      if (info->compressed == 2)\n        {\n          error = decompress_R2004_section (\n              dat, &decomp[i * info->max_decomp_size],       // offset\n              max_decomp_size - (i * info->max_decomp_size), // bytes left\n              es.fields.data_size);\n          if (error > DWG_ERR_CRITICAL)\n            {\n              sec_dat->chain = NULL; // fix double-free\n              free (decomp);\n              return error;\n            }\n          sec_dat->size = max_decomp_size;\n        }\n      else\n        {\n          if (!(info->size <= max_decomp_size)\n              || !((unsigned long)(address + es.fields.address + 32\n                                   + info->size)\n                   <= dat->size))\n            {\n              sec_dat->chain = NULL;\n              free (decomp);\n              return DWG_ERR_INVALIDDWG;\n            }\n          memcpy (&decomp[i * info->size],\n                  &dat->chain[address + es.fields.address + 32], info->size);\n          sec_dat->size = info->size;\n        }\n    }\n\n  return error;\n}\n\n/* R2004, 2010+ Class Section\n */\nstatic int\nread_2004_section_classes (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)\n{\n  BITCODE_RL size;\n  BITCODE_BS max_num, i;\n  unsigned long int num_objects, dwg_version, maint_version, unknown;\n  char c;\n  int error;\n  Bit_Chain sec_dat = { 0 }, str_dat = { 0 };\n\n  error = read_2004_compressed_section (dat, dwg, &sec_dat, SECTION_CLASSES);\n  if (error >= DWG_ERR_CRITICAL)\n    {\n      LOG_ERROR (\"Failed to read compressed %s section\", \"Classes\");\n      if (sec_dat.chain)\n        free (sec_dat.chain);\n      return error;\n    }\n\n  if (bit_search_sentinel (&sec_dat, dwg_sentinel (DWG_SENTINEL_CLASS_BEGIN)))\n    {\n      BITCODE_RL bitsize = 0;\n      LOG_TRACE (\"\\nClasses\\n-------------------\\n\")\n      size = bit_read_RL (&sec_dat); // size of class data area\n      LOG_TRACE (\"size: \" FORMAT_RL \" [RL]\\n\", size)\n      if ((dat->version >= R_2010 && dwg->header.maint_version > 3)\n          || dat->version >= R_2018)\n        {\n          BITCODE_RL hsize = bit_read_RL (&sec_dat);\n          LOG_TRACE (\"hsize: \" FORMAT_RL \" [RL]\\n\", hsize)\n        }\n      if (dat->version >= R_2007)\n        {\n          bitsize = bit_read_RL (&sec_dat);\n          LOG_TRACE (\"bitsize: \" FORMAT_RL \" [RL]\\n\", bitsize)\n        }\n      max_num = bit_read_BS (&sec_dat); // Maximum class number\n      LOG_TRACE (\"max_num: \" FORMAT_BS \" [BS]\\n\", max_num)\n      c = bit_read_RC (&sec_dat); // 0x00\n      LOG_HANDLE (\"c: \" FORMAT_RC \" [RC]\\n\", c)\n      c = bit_read_RC (&sec_dat); // 0x00\n      LOG_HANDLE (\"c: \" FORMAT_RC \" [RC]\\n\", c)\n      c = bit_read_B (&sec_dat); // 1\n      LOG_HANDLE (\"c: \" FORMAT_B \" [B]\\n\", c)\n\n      dwg->layout_type = 0;\n      dwg->num_classes = max_num - 499;\n      if (max_num < 500\n          || dwg->num_classes > 100 + (size / sizeof (Dwg_Class)))\n        {\n          LOG_ERROR (\"Invalid max class number %d\", max_num)\n          dwg->num_classes = 0;\n          return DWG_ERR_VALUEOUTOFBOUNDS;\n        }\n      assert (max_num >= 500);\n      // assert (max_num < 5000);\n\n      if (dat->version >= R_2007)\n        section_string_stream (&sec_dat, bitsize, &str_dat);\n\n      dwg->dwg_class\n          = (Dwg_Class *)calloc (dwg->num_classes, sizeof (Dwg_Class));\n      if (!dwg->dwg_class)\n        {\n          LOG_ERROR (\"Out of memory\");\n          if (sec_dat.chain)\n            free (sec_dat.chain);\n          return DWG_ERR_OUTOFMEM;\n        }\n\n      for (i = 0; i < dwg->num_classes; i++)\n        {\n          dwg->dwg_class[i].number = bit_read_BS (&sec_dat);\n          dwg->dwg_class[i].proxyflag = bit_read_BS (&sec_dat);\n          LOG_TRACE (\"-------------------\\n\")\n          LOG_TRACE (\"Number:           %d [BS]\\n\", dwg->dwg_class[i].number)\n          LOG_TRACE (\"Proxyflag:        %x [BS]\\n\", dwg->dwg_class[i].proxyflag)\n          if (dwg->header.version >= R_2007)\n            {\n              dwg->dwg_class[i].appname = (char *)bit_read_TU (&str_dat);\n              dwg->dwg_class[i].cppname = (char *)bit_read_TU (&str_dat);\n              dwg->dwg_class[i].dxfname_u = bit_read_TU (&str_dat);\n              dwg->dwg_class[i].dxfname\n                  = bit_convert_TU (dwg->dwg_class[i].dxfname_u);\n              if (DWG_LOGLEVEL >= DWG_LOGLEVEL_TRACE)\n                {\n                  char *appu8 = bit_convert_TU ((BITCODE_TU)dwg->dwg_class[i].appname);\n                  LOG_TRACE (\"Application name: \\\"%s\\\" [TU 0 (as utf-8)]\\n\", appu8);\n                  //LOG_TRACE_TU (\"Application name\", dwg->dwg_class[i].appname, 0)\n                  LOG_TRACE_TU (\"C++ class name  \", dwg->dwg_class[i].cppname, 0)\n                  LOG_TRACE_TU (\"DXF record name \", dwg->dwg_class[i].dxfname_u, 0)\n                  free (appu8);\n                }\n            }\n          else\n            {\n              dwg->dwg_class[i].appname = bit_read_TV (&sec_dat);\n              dwg->dwg_class[i].cppname = bit_read_TV (&sec_dat);\n              dwg->dwg_class[i].dxfname = bit_read_TV (&sec_dat);\n              LOG_TRACE (\"Application name: %s [TV]\\n\", dwg->dwg_class[i].appname)\n              LOG_TRACE (\"C++ class name:   %s [TV]\\n\", dwg->dwg_class[i].cppname)\n              LOG_TRACE (\"DXF record name:  %s [TV]\\n\", dwg->dwg_class[i].dxfname)\n            }\n          dwg->dwg_class[i].wasazombie = bit_read_B (&sec_dat);\n          dwg->dwg_class[i].item_class_id = bit_read_BS (&sec_dat);\n          LOG_TRACE (\"Class ID:         0x%x [BS] \"\n                     \"(0x1f3 for object, 0x1f2 for entity)\\n\",\n                     dwg->dwg_class[i].item_class_id)\n\n          dwg->dwg_class[i].num_instances = bit_read_BL (&sec_dat);\n          dwg->dwg_class[i].dwg_version = bit_read_BS (&sec_dat);\n          dwg->dwg_class[i].maint_version = bit_read_BS (&sec_dat);\n          dwg->dwg_class[i].unknown_1 = bit_read_BL (&sec_dat);\n          dwg->dwg_class[i].unknown_1 = bit_read_BL (&sec_dat);\n          LOG_TRACE (\"num_instances:    %u\\n\", dwg->dwg_class[i].num_instances)\n          LOG_HANDLE (\"dwg version:      %u (%u)\\n\",\n                      dwg->dwg_class[i].dwg_version,\n                      dwg->dwg_class[i].maint_version)\n          LOG_HANDLE (\"unknown:          %u %u\\n\", dwg->dwg_class[i].unknown_1,\n                      dwg->dwg_class[i].unknown_2)\n\n          if (dwg->dwg_class[i].dxfname\n              && strEQ (dwg->dwg_class[i].dxfname, \"LAYOUT\"))\n            dwg->layout_type = dwg->dwg_class[i].number;\n        }\n    }\n  else\n    {\n      LOG_ERROR (\"Failed to find class section sentinel\");\n      free (sec_dat.chain);\n      return DWG_ERR_CLASSESNOTFOUND;\n    }\n\n  // then RS: CRC\n  // dwg_sentinel(DWG_SENTINEL_CLASS_END)\n  // SINCE(R_2004) 8 unknown bytes\n\n  free (sec_dat.chain);\n  return 0;\n}\n\n/* R2004, 2010+ Header Section\n */\nstatic int\nread_2004_section_header (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)\n{\n  int error;\n  Bit_Chain sec_dat = { 0 };\n\n  sec_dat.opts = dwg->opts & DWG_OPTS_LOGLEVEL;\n  error = read_2004_compressed_section (dat, dwg, &sec_dat, SECTION_HEADER);\n  if (error >= DWG_ERR_CRITICAL)\n    {\n      LOG_ERROR (\"Failed to read compressed %s section\", \"Header\");\n      if (sec_dat.chain)\n        free (sec_dat.chain);\n      return error;\n    }\n\n  if (bit_search_sentinel (&sec_dat,\n                           dwg_sentinel (DWG_SENTINEL_VARIABLE_BEGIN)))\n    {\n      LOG_TRACE (\"\\nHeader\\n-------------------\\n\")\n      dwg->header_vars.size = bit_read_RL (&sec_dat);\n      LOG_TRACE (\"size: \" FORMAT_RL \" [RL]\\n\", dwg->header_vars.size);\n      PRE (R_2007)\n      {\n        error\n            |= dwg_decode_header_variables (&sec_dat, &sec_dat, &sec_dat, dwg);\n      }\n      else\n      {\n        Bit_Chain hdl_dat, str_dat;\n        BITCODE_RL endbits = 160; // start bit: 16 sentinel + 4 size\n        hdl_dat = sec_dat;\n        str_dat = sec_dat;\n        if (dwg->header.maint_version > 3 || dat->version >= R_2018)\n          {\n            dwg->header_vars.bitsize_hi = bit_read_RL (&sec_dat);\n            LOG_TRACE (\"bitsize_hi: \" FORMAT_RL \" [RL]\\n\",\n                       dwg->header_vars.bitsize_hi)\n            endbits += 32; // 192\n          }\n        dwg->header_vars.bitsize = bit_read_RL (&sec_dat);\n        LOG_TRACE (\"bitsize: \" FORMAT_RL \" [RL]\\n\", dwg->header_vars.bitsize)\n        endbits += dwg->header_vars.bitsize;\n        bit_set_position (&hdl_dat, endbits);\n        section_string_stream (&sec_dat, dwg->header_vars.bitsize, &str_dat);\n        error\n            |= dwg_decode_header_variables (&sec_dat, &hdl_dat, &str_dat, dwg);\n      }\n    }\n  free (sec_dat.chain);\n  return error;\n}\n\n/* R2004, 2010+ Handles Section\n */\nstatic int\nread_2004_section_handles (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)\n{\n  Bit_Chain obj_dat = { NULL }, hdl_dat = { NULL };\n  BITCODE_RS section_size = 0;\n  long unsigned int endpos;\n  int error;\n\n  obj_dat.opts = hdl_dat.opts = dwg->opts & DWG_OPTS_LOGLEVEL;\n  error = read_2004_compressed_section (dat, dwg, &obj_dat, SECTION_OBJECTS);\n  if (error >= DWG_ERR_CRITICAL || !obj_dat.chain)\n    {\n      LOG_ERROR (\"Failed to read compressed %s section\", \"AcDbObjects\");\n      if (obj_dat.chain)\n        free (obj_dat.chain);\n      return error;\n    }\n\n  error = read_2004_compressed_section (dat, dwg, &hdl_dat, SECTION_HANDLES);\n  if (error >= DWG_ERR_CRITICAL || !hdl_dat.chain)\n    {\n      LOG_ERROR (\"Failed to read compressed %s section\", \"Handles\");\n      free (obj_dat.chain);\n      if (hdl_dat.chain)\n        free (hdl_dat.chain);\n      return error;\n    }\n\n  endpos = hdl_dat.byte + hdl_dat.size;\n  dwg->num_objects = 0;\n\n  do\n    {\n      long unsigned int last_offset;\n      // long unsigned int last_handle;\n      long unsigned int oldpos = 0;\n      long unsigned int startpos = hdl_dat.byte;\n      BITCODE_BL max_handles = hdl_dat.size * 2;\n      uint16_t crc1, crc2;\n\n      section_size = bit_read_RS_LE (&hdl_dat);\n      LOG_TRACE (\"\\nHandles page size: %u [RS_LE]\\n\", section_size);\n      /* ***********************************************\n       * ODA p. 251 \"Note that each section is cut off at a maximum length of\n       * 2032.\" BUT in fact files exist with 2036 section size */\n      if (section_size > 2040)\n        {\n          LOG_ERROR (\"Object-map/handles page size greater than 2040!\");\n          free (hdl_dat.chain);\n          free (obj_dat.chain);\n          return DWG_ERR_VALUEOUTOFBOUNDS;\n        }\n\n      last_offset = 0;\n      while ((long)(hdl_dat.byte - startpos) < (long)section_size)\n        {\n          int added;\n          BITCODE_UMC handleoff;\n          BITCODE_MC offset;\n          BITCODE_BL last_handle = dwg->num_objects\n            ? dwg->object[dwg->num_objects - 1].handle.value : 0;\n\n          oldpos = hdl_dat.byte;\n          // the offset from the previous handle. default: 1, unsigned\n          handleoff = bit_read_UMC (&hdl_dat);\n          // the offset from the previous address. default: obj->size\n          offset = bit_read_MC (&hdl_dat);\n          if (!handleoff || handleoff > max_handles - last_handle)\n            {\n              BITCODE_MC prevsize = dwg->num_objects\n                ? dwg->object[dwg->num_objects - 1].size + 4 : 0;\n              LOG_WARN (\"Ignore invalid handleoff (@%lu)\", oldpos)\n              if (offset == 1 ||\n                  (offset > 0 && offset < prevsize && prevsize > 0) ||\n                  (offset < 0 && labs((long)offset) < prevsize && prevsize > 0))\n                {\n                  if (offset != prevsize)\n                    LOG_ERROR (\"Invalid offset: %ld [MC]\", offset);\n                  offset = prevsize;\n                  LOG_WARN (\"Recover invalid offset to %ld\", offset);\n                }\n            }\n          last_offset += offset;\n          LOG_TRACE (\"\\n< Next object: %lu \", (unsigned long)dwg->num_objects)\n          LOG_HANDLE (\"Handleoff: %lX [UMC] \"\n                      \"Offset: \" FORMAT_MC \" [MC] @%lu\\n\",\n                      handleoff, offset, last_offset);\n\n          if (hdl_dat.byte == oldpos) // ?? completely unrelated\n            break;\n\n          added = dwg_decode_add_object (dwg, &obj_dat, &obj_dat, last_offset);\n          if (added > 0)\n            error |= added;\n          // else re-allocated\n          // we don't stop encoding on single errors, but we sum them all up\n          // as combined bitmask\n        }\n\n      if (hdl_dat.byte == oldpos)\n        break;\n#if 0\n      if (!bit_check_CRC(&hdl_dat, startpos, 0xC0C1))\n        error |= DWG_ERR_WRONGCRC;\n      //LOG_WARN(\"Handles section CRC mismatch at offset %lx\", startpos);\n#else\n      crc1 = bit_calc_CRC (0xC0C1, &(hdl_dat.chain[startpos]),\n                           hdl_dat.byte - startpos);\n      crc2 = bit_read_RS_LE (&hdl_dat);\n      LOG_TRACE (\"Handles page crc: %04X [RS_LE]\\n\", crc2);\n      if (crc1 == crc2)\n        {\n          LOG_INSANE (\"Handles page CRC: %04X from %lu-%lu=%ld\\n\", crc2,\n                      startpos, hdl_dat.byte - 2, hdl_dat.byte - startpos - 2);\n        }\n      else\n        {\n          LOG_WARN (\n              \"Handles page CRC: %04X vs calc. %04X from %lu-%lu=%ld\\n\",\n              crc2, crc1, startpos, hdl_dat.byte - 2, hdl_dat.byte - startpos - 2);\n          error |= DWG_ERR_WRONGCRC;\n        }\n#endif\n\n      if (hdl_dat.byte >= endpos)\n        break;\n    }\n  while (section_size > 2);\n\n  free (hdl_dat.chain);\n  free (obj_dat.chain);\n  return error;\n}\n\n// may return OUTOFBOUNDS, needs to free the chain then\nstatic int\nsummaryinfo_private (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)\n{\n  Bit_Chain *str_dat = dat;\n  struct Dwg_SummaryInfo *_obj = &dwg->summaryinfo;\n  Dwg_Object *obj = NULL;\n  int error = 0;\n\n  // clang-format off\n  #include \"summaryinfo.spec\"\n  // clang-format on\n\n  return error;\n}\n\n/* R2004, 2010+ SummaryInfo Section\n */\nstatic int\nread_2004_section_summary (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)\n{\n  Bit_Chain old_dat, sec_dat = { 0 };\n  int error = 0;\n\n  // not compressed, page size: 0x100\n  error\n      = read_2004_compressed_section (dat, dwg, &sec_dat, SECTION_SUMMARYINFO);\n  if (error >= DWG_ERR_CRITICAL)\n    {\n      LOG_ERROR (\"Failed to read uncompressed %s section\", \"SummaryInfo\");\n      return error;\n    }\n  if (dwg->header.summaryinfo_address != (BITCODE_RL)dat->byte)\n    LOG_WARN (\"summaryinfo_address mismatch: \" FORMAT_RL \" != %lu\",\n              dwg->header.summaryinfo_address, dat->byte);\n  LOG_TRACE (\"SummaryInfo\\n-------------------\\n\")\n  old_dat = *dat;\n  dat = &sec_dat; // restrict in size\n\n  error = summaryinfo_private (dat, dwg);\n\n  if (sec_dat.chain)\n    free (sec_dat.chain);\n  *dat = old_dat; // unrestrict\n  return error;\n}\n\nstatic int\nread_2004_section_preview (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)\n{\n  Bit_Chain sec_dat = { 0 };\n  int error = 0;\n  BITCODE_RL size;\n  unsigned char *sentinel;\n\n  // not compressed, num_sections: 1\n  error = read_2004_compressed_section (dat, dwg, &sec_dat, SECTION_PREVIEW);\n  if (error >= DWG_ERR_CRITICAL)\n    {\n      LOG_ERROR (\"Failed to read uncompressed %s section\", \"Preview\");\n      if (sec_dat.chain)\n        free (sec_dat.chain);\n      return error;\n    }\n\n  if (dwg->header.thumbnail_address != (BITCODE_RL)dat->byte)\n    LOG_WARN (\"thumbnail_address mismatch: \" FORMAT_RL \" != %lu\",\n              dwg->header.thumbnail_address, dat->byte);\n  LOG_TRACE (\"Preview\\n-------------------\\n\");\n  if (!sec_dat.chain || sec_dat.size < 16)\n    {\n      LOG_WARN (\"Empty thumbnail\");\n      if (sec_dat.chain)\n        free (sec_dat.chain);\n      return error;\n    }\n  sentinel = dwg_sentinel (DWG_SENTINEL_THUMBNAIL_BEGIN);\n  if (memcmp (sentinel, sec_dat.chain, 16))\n    {\n      LOG_WARN (\"thumbnail sentinel mismatch\");\n      free (sec_dat.chain);\n      return error;\n    }\n\n  dwg->thumbnail.size = sec_dat.size - 32; // 2x sentinel\n  dwg->thumbnail.chain = sec_dat.chain;\n  dwg->thumbnail.byte = 16; // sentinel\n\n  dwg_bmp (dwg, &size);\n  if (abs ((int)((long)size - (long)dwg->thumbnail.size))\n      > 200) // various headers\n    LOG_WARN (\"thumbnail.size mismatch: %lu != \" FORMAT_RL,\n              dwg->thumbnail.size, size);\n\n  dat->byte += dwg->thumbnail.size;\n\n  return error;\n}\n\n// static int read_2004_section_vbaproject (dat, dwg)\n// static int read_2004_section_appinfo (dat, dwg)\n// static int read_2004_section_filedeplist (dat, dwg)\n// static int read_2004_section_security (dat, dwg)\n// static int read_2004_section_revhistory (dat, dwg)\n\nstatic void\ndecrypt_R2004_header (Bit_Chain *restrict dat, BITCODE_RC *restrict decrypted,\n                      unsigned long size, Dwg_Data *restrict dwg)\n{\n  unsigned int rseed = 1;\n  unsigned i;\n\n  /* Decrypt */\n  for (i = 0; i < size; i++)\n    {\n      rseed *= 0x343fd;\n      rseed += 0x269ec3;\n      decrypted[i] = bit_read_RC (dat) ^ (rseed >> 0x10);\n    }\n}\n\nGCC30_DIAG_IGNORE (-Wformat-nonliteral)\nstatic int\ndecode_R2004_header (Bit_Chain *restrict file_dat, Dwg_Data *restrict dwg)\n{\n  int error = 0;\n  Dwg_Object *obj = NULL;\n  struct Dwg_R2004_Header *_obj = &dwg->r2004_header;\n  Bit_Chain *hdl_dat = file_dat;\n\n  {\n    const unsigned long size = sizeof (struct Dwg_R2004_Header);\n    BITCODE_RC decrypted_data[size];\n    Bit_Chain decrypted_header_dat = *file_dat;\n    Bit_Chain *dat;\n\n    decrypted_header_dat.size = size;\n    decrypted_header_dat.chain = decrypted_data;\n    decrypted_header_dat.byte = decrypted_header_dat.bit = 0;\n\n    file_dat->byte = 0x80;\n    file_dat->bit = 0;\n    decrypt_R2004_header (file_dat, decrypted_data, size, dwg);\n\n    dat = &decrypted_header_dat;\n    dat->bit = dat->byte = 0;\n    LOG_TRACE (\"\\n#### 2004 File Header ####\\n\");\n    // clang-format off\n    #include \"r2004_file_header.spec\"\n    // clang-format on\n  }\n\n  /*-------------------------------------------------------------------------\n   * Section Page Map\n   */\n  {\n    Bit_Chain *dat = file_dat;\n    dat->byte = dwg->r2004_header.section_map_address + 0x100;\n\n    LOG_TRACE (\"\\n=== Read System Section (Section Page Map) ===\\n\\n\")\n    FIELD_RLx (section_type, 0);\n    if (FIELD_VALUE (section_type) != 0x41630e3b)\n      {\n        LOG_ERROR (\"Invalid System Section Page Map type 0x%x != 0x41630e3b\",\n                   FIELD_VALUE (section_type));\n        return DWG_ERR_SECTIONNOTFOUND;\n      }\n    FIELD_RL (decomp_data_size, 0);\n    FIELD_RL (comp_data_size, 0);\n    FIELD_RL (compression_type, 0);\n    FIELD_RLx (checksum, 0); // see dwg_section_page_checksum()\n  }\n\n  return error;\n}\n\n/* for 2004 and 2010+ */\nstatic int\ndecode_R2004 (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)\n{\n  int j, error = 0;\n  Dwg_Section *section;\n\n  {\n    struct Dwg_Header *_obj = &dwg->header;\n    Dwg_Object *obj = NULL;\n    Bit_Chain *hdl_dat = dat;\n    int i;\n\n    dat->byte = 0x06;\n    // clang-format off\n    #include \"header.spec\"\n    // clang-format on\n  }\n\n  error |= decode_R2004_header (dat, dwg);\n  if (error > DWG_ERR_CRITICAL)\n    return error;\n\n  error |= read_R2004_section_map (dat, dwg);\n  if (!dwg->header.section || error >= DWG_ERR_CRITICAL)\n    {\n      LOG_ERROR (\"Failed to read R2004 Section Page Map.\")\n      return error | DWG_ERR_INTERNALERROR;\n    }\n\n  /*-------------------------------------------------------------------------\n   * Section Info\n   */\n  section = find_section (dwg, dwg->r2004_header.section_info_id);\n  if (section)\n    {\n      Dwg_Object *obj = NULL;\n      Dwg_Section *_obj = section;\n      LOG_TRACE (\"\\n=== Data Section (Section Info %d) @%lx ===\\n\",\n                 dwg->r2004_header.section_info_id, (unsigned long)section->address)\n      dat->byte = section->address;\n\n      FIELD_RLx (section_type, 0);\n      if (FIELD_VALUE (section_type) != 0x4163003b)\n        {\n          LOG_ERROR (\"Invalid Data Section Page Map type 0x%x != 0x4163003b\",\n                     FIELD_VALUE (section_type));\n          return DWG_ERR_SECTIONNOTFOUND;\n        }\n      FIELD_RL (decomp_data_size, 0);\n      FIELD_RL (comp_data_size, 0);\n      FIELD_RL (compression_type, 0);\n      FIELD_RLx (checksum, 0);\n\n      // Data section map, par 4.5\n      error |= read_R2004_section_info (dat, dwg, _obj->comp_data_size,\n                                        _obj->decomp_data_size);\n    }\n  else\n    error |= DWG_ERR_SECTIONNOTFOUND;\n\n  error |= read_2004_section_header (dat, dwg);\n  if (dwg->header.summaryinfo_address)\n    error |= read_2004_section_summary (dat, dwg);\n  error |= read_2004_section_classes (dat, dwg);\n  error |= read_2004_section_handles (dat, dwg);\n  if (dwg->header.thumbnail_address)\n    error |= read_2004_section_preview (dat, dwg);\n  // TODO:\n  // if (dwg->header.vbaproj_address)\n  //  error |= read_2004_section_vbaproject (dat, dwg);\n  // error |= read_2004_section_appinfo (dat, dwg);\n  // error |= read_2004_section_filedeplist (dat, dwg);\n  // error |= read_2004_section_security (dat, dwg);\n  // error |= read_2004_section_revhistory (dat, dwg);\n\n  /* Clean up. XXX? Need this to write the sections, at least the name and\n   * type\n   */\n#if 0\n  if (dwg->header.section_info != NULL)\n    {\n      unsigned u;\n      for (u = 0; u < dwg->header.num_infos; ++u)\n        if (dwg->header.section_info[u].sections != 0)\n          free(dwg->header.section_info[u].sections);\n\n      free(dwg->header.section_info);\n      dwg->header.num_infos = 0;\n    }\n#endif\n\n  LOG_INFO (\"\\nnum_objects: %lu\\n\", (unsigned long)dwg->num_objects)\n  LOG_TRACE (\"num_object_refs: %lu\\n\", (unsigned long)dwg->num_object_refs)\n  LOG_TRACE (\"Resolving pointers from ObjectRef vector:\\n\")\n  error |= resolve_objectref_vector (dat, dwg);\n  return error;\n}\n\nstatic int\ndecode_R2007 (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)\n{\n  Bit_Chain hdl_dat = { 0 };\n  int error;\n\n  hdl_dat = *dat;\n  {\n    int i;\n    struct Dwg_Header *_obj = &dwg->header;\n    Dwg_Object *obj = NULL;\n\n    dat->byte = 0x06;\n    // clang-format off\n    #include \"header.spec\"\n    // clang-format on\n  }\n\n  // this includes classes, header, handles + objects\n  error = read_r2007_meta_data (dat, &hdl_dat, dwg);\n\n  LOG_INFO (\"\\nnum_objects: %lu\\n\", (unsigned long)dwg->num_objects)\n  LOG_TRACE (\"num_object_refs: %lu\\n\", (unsigned long)dwg->num_object_refs)\n  if (error >= DWG_ERR_CRITICAL)\n    {\n      LOG_ERROR (\"Failed to read 2007 meta data\")\n      return error;\n    }\n\n  LOG_TRACE (\"Resolving pointers from ObjectRef vector:\\n\")\n  return error | resolve_objectref_vector (dat, dwg);\n}\n\n/*--------------------------------------------------------------------------------\n * Private functions\n *\n * EED \"Extended Entity Data\":\n * There's an array of obj->num_eed obj->eed[] entries.\n * Each eed member has size, handle, the raw[size] buffer and the decoded data.\n * Each obj->eed[].data member is further seperated into DXF+1000 codes, for\n * strings, numbers, points, ...\n * Those subgroups have an empty raw, size, and the prev. handle.\n */\n\nstatic int\need_need_size (BITCODE_BS need, BITCODE_BS have)\n{\n  if (need > have)\n    {\n      LOG_ERROR (\"Invalid EED size %d > %d\", (int)need, (int)have);\n      return 1;\n    }\n  return 0;\n}\n\n#define LOG_POS\n// LOG_INSANE (\" @%lu.%u\\n\", dat->byte, dat->bit)\n\nstatic int\ndwg_decode_eed_data (Bit_Chain *restrict dat, Dwg_Eed_Data *restrict data,\n                     unsigned long int end, BITCODE_BS size)\n{\n  int lenc;\n  BITCODE_BS j;\n  BITCODE_RS lens;\n\n  data->code = bit_read_RC (dat);\n  LOG_TRACE (\"code: %d [RC], \", (int)data->code);\n  switch (data->code)\n    {\n    case 0:\n      PRE (R_2007)\n      {\n        if (eed_need_size (3, size))\n          return DWG_ERR_INVALIDEED;\n        data->u.eed_0.length = lenc = bit_read_RC (dat);\n        data->u.eed_0.codepage = bit_read_RS_LE (dat);\n        if ((long)lenc > size - 4)\n          {\n            LOG_ERROR (\"Invalid EED string len %d, max %d\", lenc,\n                       (int)size - 4)\n            dat->byte = end;\n            break;\n#if 0\n            obj->num_eed = 0;\n            if (obj->eed[idx].size)\n              free(obj->eed[idx].raw);\n            free(obj->eed[idx].data);\n            free(obj->eed);\n            obj->eed = NULL;\n            dat->byte = end;\n            return DWG_ERR_INVALIDEED; /* may not continue */\n#endif\n          }\n        /* code:1 + len:1 + cp:2 */\n        if (eed_need_size (lenc + 3, size))\n          return DWG_ERR_INVALIDEED;\n        bit_read_fixed (dat, (BITCODE_RC *)data->u.eed_0.string, lenc);\n        data->u.eed_0.string[lenc] = '\\0';\n        LOG_TRACE (\"string: len=%d [RC] cp=%d [RS_LE] \\\"%s\\\" [TF]\\n\", (int)lenc,\n                   (int)data->u.eed_0.codepage, data->u.eed_0.string);\n      }\n      LATER_VERSIONS\n      {\n        if (eed_need_size (2, size))\n          return DWG_ERR_INVALIDEED;\n        data->u.eed_0_r2007.length = lens = bit_read_RS (dat);\n        if (eed_need_size ((lens * 2) + 2, size))\n          return DWG_ERR_INVALIDEED;\n        /* code:1 + len:2 NUL? */\n        for (j = 0; j < MIN (lens, (size - 3) / 2); j++)\n          data->u.eed_0_r2007.string[j] = bit_read_RS_LE (dat);\n          // data->u.eed_0_r2007.string[j] = 0; //already calloc'ed\n#ifdef _WIN32\n        LOG_TRACE (\"wstring: len=%d [RS] \\\"\" FORMAT_TU \"\\\" [TU]\\n\",\n                   (int)lens, data->u.eed_0_r2007.string);\n#else\n        if (DWG_LOGLEVEL >= DWG_LOGLEVEL_TRACE)\n          {\n            char *u8 = bit_convert_TU (data->u.eed_0_r2007.string);\n            LOG_TRACE (\"wstring: len=%d [RS] \\\"%s\\\" [TU]\\n\",\n                       (int)lens, u8);\n            free (u8);\n          }\n#endif\n      }\n      break;\n    case 2:\n      if (eed_need_size (1, size))\n        return DWG_ERR_INVALIDEED;\n      data->u.eed_2.byte = bit_read_RC (dat);\n      LOG_TRACE (\"byte: \" FORMAT_RC \" [RC]\\n\", data->u.eed_2.byte);\n      break;\n    case 3:\n      if (eed_need_size (4, size))\n        return DWG_ERR_INVALIDEED;\n      data->u.eed_3.layer = bit_read_RL (dat);\n      LOG_TRACE (\"layer: \" FORMAT_RL \" [RL]\\n\", data->u.eed_3.layer);\n      break;\n    case 4:\n      if (eed_need_size (1, size))\n        return DWG_ERR_INVALIDEED;\n      data->u.eed_4.length = lenc = bit_read_RC (dat);\n      if (eed_need_size (lenc + 1, size))\n        return DWG_ERR_INVALIDEED;\n      /* code:1 + len:1 */\n      for (j = 0; j < MIN (lenc, size - 2); j++)\n        data->u.eed_4.data[j] = bit_read_RC (dat);\n      LOG_TRACE (\"binary[%d] \\\"%s\\\" [TF]\\n\", j-1, data->u.eed_4.data);\n      break;\n    case 5:\n      if (eed_need_size (8, size))\n        return DWG_ERR_INVALIDEED;\n      data->u.eed_5.entity = bit_read_RLL (dat);\n      LOG_TRACE (\"entity: 0x%\" PRIx64 \" [RLL]\\n\", data->u.eed_5.entity);\n      break;\n    case 10:\n    case 11:\n    case 12:\n    case 13:\n    case 14:\n    case 15:\n      if (eed_need_size (3 * 8, size))\n        return DWG_ERR_INVALIDEED;\n      data->u.eed_10.point.x = bit_read_RD (dat);\n      data->u.eed_10.point.y = bit_read_RD (dat);\n      data->u.eed_10.point.z = bit_read_RD (dat);\n      LOG_TRACE (\"3dpoint: (%f, %f, %f) [3RD]\\n\", data->u.eed_10.point.x,\n                 data->u.eed_10.point.y, data->u.eed_10.point.z);\n      break;\n    case 40:\n    case 41:\n    case 42: /*case 43: case 44: case 45: case 46:\ncase 51: case 54:*/\n      if (eed_need_size (8, size))\n        return DWG_ERR_INVALIDEED;\n      data->u.eed_40.real = bit_read_RD (dat);\n      LOG_TRACE (\"real: %f [RD]\\n\", data->u.eed_40.real);\n      break;\n    case 70:\n      if (eed_need_size (2, size))\n        return DWG_ERR_INVALIDEED;\n      data->u.eed_70.rs = bit_read_RS (dat);\n      LOG_TRACE (\"short: \" FORMAT_RS \" [RS]\\n\", data->u.eed_70.rs);\n      break;\n    case 71:\n      if (eed_need_size (4, size))\n        return DWG_ERR_INVALIDEED;\n      data->u.eed_71.rl = bit_read_RL (dat);\n      LOG_TRACE (\"long: \" FORMAT_RL \" [RL]\\n\", data->u.eed_71.rl);\n      break;\n    default:\n      LOG_ERROR (\"unknown EED code %d\", data->code);\n      LOG_POS\n      dat->byte = end;\n      LOG_POS\n      return DWG_ERR_INVALIDEED; /* may continue */\n    }\n  LOG_POS\n\n#ifdef DEBUG\n  // sanity checks\n  if (obj->eed[idx].code == 0 || obj->eed[idx].code == 4)\n    assert (obj->eed[idx].data->u.eed_0.length <= size - 1);\n  if (obj->eed[idx].code == 10) // 3 double\n    assert (size >= 1 + 3 * 8);\n#endif\n\n  return 0;\n}\n\n/* for objects and entities */\nstatic int\ndwg_decode_eed (Bit_Chain *restrict dat, Dwg_Object_Object *restrict obj)\n{\n  BITCODE_BS size;\n  int error = 0;\n  unsigned int idx = 0;\n  Dwg_Data *dwg = obj->dwg;\n  Dwg_Object *_obj;\n  long unsigned int sav_byte = dat->byte;\n\n  if (!dwg)\n    return DWG_ERR_INVALIDEED;\n  _obj = &dwg->object[obj->objid]; /* Note that obj->objid may be 0 */\n  obj->num_eed = 0;\n  while ((size = bit_read_BS (dat)))\n    {\n      int i;\n      BITCODE_BS j;\n      long unsigned int end, offset;\n\n      LOG_TRACE (\"EED[%u] size: \" FORMAT_BS \" [BS]\\n\", idx, size);\n      LOG_POS\n      if (size > _obj->size || dat->byte == sav_byte)\n        {\n          LOG_ERROR (\"Invalid EED size \" FORMAT_BS \" > %u\", size, _obj->size);\n          obj->num_eed = idx;\n          dwg_free_eed (_obj);\n          return DWG_ERR_INVALIDEED; /* may not continue */\n        }\n\n      obj->num_eed = idx + 1;\n      if (idx) /* just extend by one. not in chunks for now */\n        {\n          obj->eed\n              = (Dwg_Eed *)realloc (obj->eed, obj->num_eed * sizeof (Dwg_Eed));\n          memset (&obj->eed[idx], 0, sizeof (Dwg_Eed));\n        }\n      else\n        {\n          obj->eed = (Dwg_Eed *)calloc (1, sizeof (Dwg_Eed));\n        }\n      obj->eed[idx].size = size;\n      error |= bit_read_H (dat, &obj->eed[idx].handle);\n      end = dat->byte + size;\n      if (error)\n        {\n          LOG_ERROR (\"No EED[%d].handle\", idx);\n          obj->eed[idx].size = 0;\n          obj->num_eed--;\n          dat->byte = end; // skip eed\n          continue;        // continue for size = bit_read_BS(dat)\n        }\n      else\n        {\n          LOG_TRACE (\"EED[%u] handle: \" FORMAT_H \"\\n\", idx,\n                     ARGS_H (obj->eed[idx].handle));\n          LOG_POS;\n          if (dat->byte >= dat->size)\n            end = dat->byte;\n          if (_obj->supertype == DWG_SUPERTYPE_OBJECT && _obj->dxfname\n              && strEQc (_obj->dxfname, \"MLEADERSTYLE\"))\n            { // check for is_new_format: has extended data for APPID\n              // \u201cACAD_MLEADERVER\u201d\n              Dwg_Object_Ref ref;\n              ref.obj = NULL;\n              ref.handleref = obj->eed[idx].handle;\n              ref.absolute_ref = 0L;\n              if (dwg_resolve_handleref (&ref, _obj))\n                {\n                  Dwg_Object_APPID_CONTROL *appid = &dwg->appid_control;\n                  // search absref in APPID_CONTROL apps[]\n                  for (j = 0; j < appid->num_entries; j++)\n                    {\n                      if (appid->entries[j]\n                          && appid->entries[j]->absolute_ref\n                                 == ref.absolute_ref)\n                        {\n                          Dwg_Object_MLEADERSTYLE *this\n                              = obj->tio.MLEADERSTYLE;\n                          this->is_new_format = 1;\n                          LOG_TRACE (\n                              \"EED found ACAD_MLEADERVER %lX: new format\\n\",\n                              ref.absolute_ref);\n                        }\n                    }\n                }\n            }\n        }\n\n      sav_byte = dat->byte;\n      obj->eed[idx].raw = bit_read_TF (dat, size);\n      if (DWG_LOGLEVEL < DWG_LOGLEVEL_INSANE)\n        LOG_TRACE (\"EED[0] raw: %d\\n\", size)\n      else\n        LOG_INSANE_TF (obj->eed[idx].raw, size);\n      dat->byte = sav_byte;\n      LOG_POS\n\n      while (dat->byte < end)\n        {\n          obj->eed[idx].data = (Dwg_Eed_Data *)calloc (size + 8, 1);\n          //LOG_TRACE (\"EED[%u] \", idx);\n          error |= dwg_decode_eed_data (dat, obj->eed[idx].data, end, size);\n          // overflow or no advance\n          if (dat->byte >= dat->size || dat->byte == sav_byte)\n            error |= DWG_ERR_INVALIDEED;\n          if (error & DWG_ERR_INVALIDEED)\n            {\n              free (obj->eed[idx].data);\n              LOG_HANDLE (\"        invalid eed[%d]: skip\\n\", idx);\n              LOG_POS\n              obj->eed[idx].data = NULL;\n              obj->num_eed--;\n              dat->byte = end; // skip eed\n              continue;        // continue for next size = bit_read_BS(dat)\n            }\n\n          if (dat->byte < end - 1)\n            {\n              idx++;\n              obj->num_eed = idx + 1;\n              size = (long)(end - dat->byte + 1);\n              LOG_HANDLE (\"        size remaining: %ld\\n\", (long)size);\n              LOG_POS\n\n              obj->eed = (Dwg_Eed *)realloc (obj->eed,\n                                             obj->num_eed * sizeof (Dwg_Eed));\n              obj->eed[idx].handle = obj->eed[idx - 1].handle;\n              obj->eed[idx].size = 0;\n              obj->eed[idx].raw = NULL;\n              sav_byte = dat->byte;\n            }\n          else\n            {\n              break;\n            }\n        }\n      if (obj->eed[idx].raw)\n        dat->byte = end;\n      //LOG_POS\n      idx++;\n    }\n  LOG_HANDLE (\"EED[%u] size: \" FORMAT_BS \" [BS] (end)\\n\", idx, size);\n  LOG_POS\n  return error;\n}\n\n#undef LOG_POS\n\n/** OL2FRAME.data potentially contains as 128 byte of custom specific data:\n  BITCODE_BS oleversion;   DXF 70, always 2\n  char     * oleclient;    DXF 3, e.g. OLE or Paintbrush Picture\n  BITCODE_3RD pt1;         DXF 10, upper left corner\n  BITCODE_3RD pt2;         DXF 11, lower right corner\n\nplus eventually:\n  T link_name; like C:\\My Documents\\excel.xls!Sheet1!R5C3:R8C3\n  RC output_quality;\n  BD rotation\n  BD width;\n  BD height;\n  BD scale_width;\n  BD scale_height;\n\n  The rest of data (&data[128]) contains the MS-CFB, see\n  https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-cfb/53989ce4-7b05-4f8d-829b-d08d6148375b\n  e.g. decodable via py-oletools\n*/\nstatic int\ndwg_decode_ole2 (Dwg_Entity_OLE2FRAME *restrict _obj)\n{\n  Bit_Chain bdat;\n  Bit_Chain *dat = &bdat;\n\n  dat->bit = 0;\n  dat->byte = 0;\n  dat->size = 0x80;\n  dat->chain = (unsigned char *)&_obj->data[0];\n  dat->version = _obj->parent->dwg->header.version;\n\n  // TODO decode the unknowns\n  /* Sample data from TS1.dwg:\n00000000: 8055 40f9 3284 d222 3e40 7436 e0d9 23fd  .U@.2..\">@t6..#.\n00000010: 32c0 0000 0000 0000 0000 d879 8900 cda2  2..........y....\n00000020: 4140 7436 e0d9 23fd 32c0 0000 0000 0000  A@t6..#.2.......\n00000030: 0000 d879 8900 cda2 4140 1420 d4f3 b864  ...y....A@. ...d\n00000040: 36c0 0000 0000 0000 0000 40f9 3284 d222  6.........@.2..\"\n00000050: 3e40 1420 d4f3 b864 36c0 0000 0000 0000  >@. ...d6.......\n00000060: 0000 021f 9114 0100 0000 0001 0000 0100  ................\n00000070: 0000 0100 0000 0000 0100 0000 0090 0500  ................\n=> from the DXF\noleversion 2 [70]\noleclient  \"OLE\" [3] (but the cfb contains PBrush.9)\npt1        (30.13602472538446, -18.98882829402869, 0.0) [10]\npt2        (35.27188116753285, -22.39344715050545, 0.0) [11]\n   */\n  // FIXME decode the fields\n  // FIELD_BS (oleversion, 70);\n  // FIELD_TV (oleclient, 3);\n  // FIELD_2BD (pt1, 10);\n  // FIELD_2BD (pt2, 11);\n  _obj->oleversion = 2;\n  _obj->oleclient = (char *)\"OLE\";\n  _obj->pt1.x = 30.13602472538446;\n  _obj->pt1.y = -18.98882829402869;\n  _obj->pt2.x = 35.27188116753285;\n  _obj->pt2.y = -22.39344715050545;\n\n  // next, see the MS-CFB format\n  dat->bit = 0;\n  dat->byte = 0;\n  dat->size = _obj->data_length;\n  dat->chain = (unsigned char *)&_obj->data[0x80];\n  // TODO\n\n  return 0;\n}\n\n// if to check for the has_strings bit after bitsize\nstatic int\nobj_has_strings (unsigned int type)\n{\n  switch (type)\n    {\n    case DWG_TYPE_TEXT:\n    case DWG_TYPE_ATTRIB:\n    case DWG_TYPE_ATTDEF:\n    case DWG_TYPE_BLOCK:\n      return 1;\n    case DWG_TYPE_ENDBLK:\n    case DWG_TYPE_SEQEND:\n    case DWG_TYPE_INSERT:\n    case DWG_TYPE_MINSERT:\n    case DWG_TYPE_VERTEX_2D:\n    case DWG_TYPE_VERTEX_3D:\n    case DWG_TYPE_VERTEX_MESH:\n    case DWG_TYPE_VERTEX_PFACE:\n    case DWG_TYPE_VERTEX_PFACE_FACE:\n    case DWG_TYPE_POLYLINE_2D:\n    case DWG_TYPE_POLYLINE_3D:\n    case DWG_TYPE_ARC:\n    case DWG_TYPE_CIRCLE:\n    case DWG_TYPE_LINE:\n      return 0;\n    case DWG_TYPE_DIMENSION_ORDINATE:\n    case DWG_TYPE_DIMENSION_LINEAR:\n    case DWG_TYPE_DIMENSION_ALIGNED:\n    case DWG_TYPE_DIMENSION_ANG3PT:\n    case DWG_TYPE_DIMENSION_ANG2LN:\n    case DWG_TYPE_DIMENSION_RADIUS:\n    case DWG_TYPE_DIMENSION_DIAMETER:\n      return 1;\n    case DWG_TYPE_POINT:\n    case DWG_TYPE__3DFACE:\n    case DWG_TYPE_POLYLINE_PFACE:\n    case DWG_TYPE_POLYLINE_MESH:\n    case DWG_TYPE_SOLID:\n    case DWG_TYPE_TRACE:\n    case DWG_TYPE_SHAPE:\n      return 0;\n    case DWG_TYPE_VIEWPORT:\n      return 1;\n    case DWG_TYPE_ELLIPSE:\n    case DWG_TYPE_SPLINE:\n      return 0;\n    case DWG_TYPE_REGION:\n    case DWG_TYPE__3DSOLID:\n    case DWG_TYPE_BODY:\n      return 1;\n    case DWG_TYPE_RAY:\n    case DWG_TYPE_XLINE:\n      return 0;\n    case DWG_TYPE_DICTIONARY:\n    case DWG_TYPE_OLEFRAME:\n    case DWG_TYPE_MTEXT:\n    case DWG_TYPE_LEADER:\n      return 1;\n    case DWG_TYPE_TOLERANCE:\n    case DWG_TYPE_MLINE:\n      return 0;\n    case DWG_TYPE_BLOCK_CONTROL:\n    case DWG_TYPE_LAYER_CONTROL:\n    case DWG_TYPE_STYLE_CONTROL:\n    case DWG_TYPE_LTYPE_CONTROL:\n    case DWG_TYPE_VIEW_CONTROL:\n    case DWG_TYPE_UCS_CONTROL:\n    case DWG_TYPE_VPORT_CONTROL:\n    case DWG_TYPE_APPID_CONTROL:\n    case DWG_TYPE_DIMSTYLE_CONTROL:\n    case DWG_TYPE_VPORT_ENTITY_CONTROL:\n      return 0;\n    case DWG_TYPE_BLOCK_HEADER:\n    case DWG_TYPE_LAYER:\n    case DWG_TYPE_STYLE:\n    case DWG_TYPE_LTYPE:\n    case DWG_TYPE_VIEW:\n    case DWG_TYPE_UCS:\n    case DWG_TYPE_VPORT:\n    case DWG_TYPE_APPID:\n    case DWG_TYPE_DIMSTYLE:\n    case DWG_TYPE_VPORT_ENTITY_HEADER:\n      return 1;\n    case DWG_TYPE_GROUP:\n    case DWG_TYPE_MLINESTYLE:\n    case DWG_TYPE_OLE2FRAME:\n      return 1;\n    case DWG_TYPE_DUMMY:\n    case DWG_TYPE_LONG_TRANSACTION:\n    case DWG_TYPE_LWPOLYLINE:\n      return 0;\n    case DWG_TYPE_HATCH:\n    case DWG_TYPE_XRECORD:\n      return 1;\n    case DWG_TYPE_PLACEHOLDER:\n      return 0;\n    case DWG_TYPE_VBA_PROJECT:\n    case DWG_TYPE_LAYOUT:\n    case DWG_TYPE_PROXY_ENTITY:\n    case DWG_TYPE_PROXY_OBJECT:\n    default:\n      return 1;\n    }\n}\n\n/* The first common part of every entity.\n\n   The last common part is common_entity_handle_data.spec\n   called by COMMON_ENTITY_HANDLE_DATA in dwg.spec\n\n   For EED check page 269, par 28 (Extended Object Data)\n */\nstatic int\ndwg_decode_entity (Bit_Chain *dat, Bit_Chain *hdl_dat, Bit_Chain *str_dat,\n                   Dwg_Object_Entity *restrict ent)\n{\n  unsigned int i;\n  int error = 0;\n  Dwg_Data *dwg = ent->dwg;\n  Dwg_Object *obj = &dwg->object[ent->objid];\n  Dwg_Object_Entity *_obj = ent;\n  unsigned long objectpos = bit_position (dat);\n\n  // obj->dat_address = dat->byte; // the data stream offset\n  obj->bitsize_pos = objectpos; // absolute. needed for encode\n  PRE (R_13)\n  {\n    if (FIELD_VALUE (flag_r11) & 4 && FIELD_VALUE (kind_r11) > 2\n        && FIELD_VALUE (kind_r11) != 22)\n      FIELD_RD (elevation_r11, 30);\n    if (FIELD_VALUE (flag_r11) & 8)\n      FIELD_RD (thickness_r11, 39);\n    if (FIELD_VALUE (flag_r11) & 0x20)\n      {\n        Dwg_Object_Ref *hdl\n            = dwg_decode_handleref_with_code (dat, obj, dwg, 0);\n        if (hdl)\n          obj->handle = hdl->handleref;\n      }\n    if (FIELD_VALUE (extra_r11) & 4)\n      FIELD_RS (paper_r11, 0);\n  }\n\n  VERSIONS (R_2000, R_2007)\n  {\n    obj->bitsize = bit_read_RL (dat); // until the handles\n    LOG_TRACE (\"bitsize: \" FORMAT_RL \" [RL] @%lu.%u\\n\", obj->bitsize,\n               dat->byte-2, dat->bit);\n    if (obj->bitsize > obj->size * 8)\n      {\n        LOG_ERROR (\"Invalid bitsize \" FORMAT_RL \" => \" FORMAT_RL, obj->bitsize,\n                   obj->size * 8);\n        obj->bitsize = obj->size * 8;\n        error |= DWG_ERR_VALUEOUTOFBOUNDS;\n      }\n  }\n  SINCE (R_2007)\n  {\n    SINCE (R_2010)\n      LOG_HANDLE (\" bitsize: \" FORMAT_RL \",\", obj->bitsize);\n    // restrict the hdl_dat stream\n    error |= obj_handle_stream (dat, obj, hdl_dat);\n    // and set the string stream (restricted to size)\n    // skip for all types without strings\n    if (obj->type >= 500 || obj_has_strings (obj->type))\n      error |= obj_string_stream (dat, obj, str_dat);\n    else\n      {\n        str_dat->chain += str_dat->byte;\n        str_dat->byte = 0;\n        str_dat->bit = 0;\n        str_dat->size = 0;\n        bit_advance_position (str_dat, obj->bitsize - 1 - 8);\n      }\n  }\n\n  error |= bit_read_H (dat, &(obj->handle));\n  if (error & DWG_ERR_INVALIDHANDLE)\n    {\n      LOG_WARN (\"dwg_decode_entity handle @%lu.%u\", dat->byte, dat->bit);\n      obj->bitsize = 0;\n      ent->num_eed = 0;\n      ent->preview_exists = 0;\n      return error;\n    }\n  LOG_TRACE (\"handle: \" FORMAT_H \" [H 5]\\n\", ARGS_H (obj->handle))\n\n  PRE (R_13) { return DWG_ERR_NOTYETSUPPORTED; }\n\n  error |= dwg_decode_eed (dat, (Dwg_Object_Object *)ent);\n  if (error & (DWG_ERR_INVALIDEED | DWG_ERR_VALUEOUTOFBOUNDS))\n    return error;\n\n  // clang-format off\n  #include \"common_entity_data.spec\"\n  // clang-format on\n\n  SINCE (R_2007) {\n    dwg_decode_common_entity_handle_data (dat, hdl_dat, obj);\n  }\n\n  // elsewhere: object data, handles, padding bits, crc\n  obj->common_size = bit_position (dat) - objectpos;\n  LOG_HANDLE (\"--common_size: %lu\\n\", obj->common_size); // needed for unknown\n\n  return error;\n}\n\n/* The first common part of every object.\n\n   There is no COMMON_ENTITY_DATA for objects.\n   Check page 269, par 28 (Extended Object Data)\n */\nstatic int\ndwg_decode_object (Bit_Chain *dat, Bit_Chain *hdl_dat, Bit_Chain *str_dat,\n                   Dwg_Object_Object *restrict _obj)\n{\n  unsigned int i;\n  int error = 0;\n  Dwg_Data *dwg = _obj->dwg;\n  Dwg_Object *obj = &dwg->object[_obj->objid];\n  unsigned long objectpos = bit_position (dat);\n\n  // obj->dat_address = dat->byte; // the data stream offset\n  obj->bitsize_pos = objectpos; // absolute. needed for encode\n  VERSIONS (R_2000, R_2007)\n  {\n    obj->bitsize = bit_read_RL (dat);\n    LOG_TRACE (\"bitsize: \" FORMAT_RL \" [RL] @%lu.%u\\n\", obj->bitsize,\n               dat->byte - 2, dat->bit)\n    if (obj->bitsize > obj->size * 8)\n      {\n        LOG_ERROR (\"Invalid bitsize \" FORMAT_RL \" => \" FORMAT_RL, obj->bitsize,\n                   obj->size * 8);\n        obj->bitsize = obj->size * 8;\n        error |= DWG_ERR_VALUEOUTOFBOUNDS;\n      }\n  }\n  SINCE (R_2007)\n  {\n    SINCE (R_2010)\n      LOG_HANDLE (\" bitsize: \" FORMAT_RL \",\", obj->bitsize);\n    // restrict the hdl_dat stream\n    error |= obj_handle_stream (dat, obj, hdl_dat);\n\n    // and set the string stream (restricted to size)\n    if (obj->type >= 500 || obj_has_strings (obj->type))\n      error |= obj_string_stream (dat, obj, str_dat);\n    else\n      {\n        str_dat->chain += str_dat->byte;\n        str_dat->byte = 0;\n        str_dat->bit = 0;\n        str_dat->size = 0;\n        bit_advance_position (str_dat, obj->bitsize - 1 - 8);\n      }\n  }\n\n  error |= bit_read_H (dat, &obj->handle);\n  if (error & DWG_ERR_INVALIDHANDLE)\n    {\n      LOG_ERROR (\"Wrong object handle at pos 0x%0lx\", dat->byte)\n      return error;\n    }\n  LOG_TRACE (\"handle: \" FORMAT_H \" [H 5]\\n\", ARGS_H (obj->handle))\n\n  error |= dwg_decode_eed (dat, _obj);\n  if (error & (DWG_ERR_INVALIDEED | DWG_ERR_VALUEOUTOFBOUNDS))\n    return error;\n\n  VERSIONS (R_13, R_14)\n  {\n    obj->bitsize = bit_read_RL (dat);\n    LOG_TRACE (\"bitsize: %u [RL]\\n\", obj->bitsize);\n    if (obj->bitsize > obj->size * 8)\n      {\n        LOG_ERROR (\"Invalid bitsize \" FORMAT_RL \" => \" FORMAT_RL, obj->bitsize,\n                   obj->size * 8);\n        obj->bitsize = obj->size * 8;\n        error |= DWG_ERR_VALUEOUTOFBOUNDS;\n      }\n  }\n  // documentation bug, same BL type as with entity\n  FIELD_BL (num_reactors, 0);\n  SINCE (R_2010)\n  {\n    if (_obj->num_reactors > 0x1000)\n      {\n        LOG_WARN (\"Invalid num_reactors %ld\", (long)_obj->num_reactors)\n        _obj->num_reactors = 0;\n      }\n  }\n  SINCE (R_2004) { FIELD_B (xdic_missing_flag, 0); }\n  SINCE (R_2013) { FIELD_B (has_ds_binary_data, 0); }\n  obj->common_size = bit_position (dat) - objectpos;\n  LOG_HANDLE (\"--common_size: %lu\\n\", obj->common_size); // needed for unknown\n\n  return error;\n}\n\nstatic int\ndwg_decode_add_object_ref (Dwg_Data *restrict dwg, Dwg_Object_Ref *ref)\n{\n  Dwg_Object_Ref **object_ref_old = dwg->object_ref;\n\n  // Reserve memory space for object references\n  if (!dwg->num_object_refs)\n    dwg->object_ref = calloc (REFS_PER_REALLOC, sizeof (Dwg_Object_Ref *));\n  else if (dwg->num_object_refs % REFS_PER_REALLOC == 0)\n    dwg->object_ref\n        = realloc (dwg->object_ref, (dwg->num_object_refs + REFS_PER_REALLOC)\n                                        * sizeof (Dwg_Object_Ref *));\n  if (!dwg->object_ref)\n    {\n      LOG_ERROR (\"Out of memory\");\n      dwg->object_ref = object_ref_old;\n      return DWG_ERR_OUTOFMEM;\n    }\n  dwg->object_ref[dwg->num_object_refs++] = ref;\n  return 0;\n}\n\n/* Returns a freshly allocated ref */\nDwg_Object_Ref *\ndwg_new_ref (Dwg_Data *restrict dwg)\n{\n  Dwg_Object_Ref *ref = (Dwg_Object_Ref *)calloc (1, sizeof (Dwg_Object_Ref));\n  if (!ref)\n    {\n      LOG_ERROR (\"Out of memory\");\n      return NULL;\n    }\n  if (dwg_decode_add_object_ref (dwg, ref))\n    {\n      free (ref);\n      return NULL;\n    }\n  return ref;\n}\n\n/* Store an object reference in a separate dwg->object_ref array\n   which is the id for handles, i.e. DXF 5, 330. */\nDwg_Object_Ref *\ndwg_decode_handleref (Bit_Chain *restrict dat, Dwg_Object *restrict obj,\n                      Dwg_Data *restrict dwg)\n{\n  // Welcome to the house of evil code\n  Dwg_Object_Ref *ref = (Dwg_Object_Ref *)calloc (1, sizeof (Dwg_Object_Ref));\n  if (!ref)\n    {\n      LOG_ERROR (\"Out of memory\");\n      return NULL;\n    }\n\n  if (bit_read_H (dat, &ref->handleref))\n    {\n      LOG_WARN (\"Invalid handleref: \" FORMAT_REF, ARGS_REF (ref))\n      free (ref);\n      return NULL;\n    }\n\n  // If the handle size is 0 and not a relative handle, it is probably a null\n  // handle. It shouldn't be placed in the object ref vector.\n  if (ref->handleref.size || (obj && ref->handleref.code > 5))\n    {\n      if (dwg_decode_add_object_ref (dwg, ref))\n        {\n          free (ref);\n          return NULL;\n        }\n    }\n  else if (!ref->handleref.value)\n    {\n      if (obj)\n        {\n          free (ref);\n          return NULL;\n        }\n      ref->absolute_ref = 0;\n      ref->obj = NULL;\n      return ref;\n    }\n\n  // We receive a null obj when we are reading\n  // handles in the header variables section\n  if (!obj)\n    {\n      if (ref->handleref.value)\n        {\n          ref->absolute_ref = ref->handleref.value;\n          ref->obj = NULL;\n          return ref;\n        }\n      if (ref->handleref.code >= 6)\n        {\n          LOG_ERROR (\"Empty obj argument for handleref code %d\",\n                     ref->handleref.code);\n          ref->obj = NULL;\n          return NULL;\n        }\n    }\n\n  /*\n   * With TYPEDOBJHANDLE 2-5 the code indicates the type of ownership.\n   * With OFFSETOBJHANDLE >5 the handle is stored as an offset from some other\n   * handle.\n   */\n  switch (ref->handleref.code)\n    {\n    case 0x06:\n      ref->absolute_ref = (obj->handle.value + 1);\n      break;\n    case 0x08:\n      ref->absolute_ref = (obj->handle.value - 1);\n      break;\n    case 0x0A:\n      ref->absolute_ref = (obj->handle.value + ref->handleref.value);\n      break;\n    case 0x0C:\n      ref->absolute_ref = (obj->handle.value - ref->handleref.value);\n      break;\n    case 0x0E: // eg 2007 REGION.history_id (some very high number)\n      ref->absolute_ref = obj->handle.value;\n      break;\n    case 2:\n    case 3:\n    case 4:\n    case 5:\n      ref->absolute_ref = ref->handleref.value;\n      break;\n    case 0: // ignore?\n      ref->absolute_ref = ref->handleref.value;\n      break;\n    default:\n      // dwg->object_ref[dwg->num_object_refs-1] = NULL;\n      // dwg->num_object_refs--;\n      ref->absolute_ref = 0;\n      ref->obj = NULL;\n      LOG_WARN (\"Invalid handle pointer code %d\", ref->handleref.code);\n      break;\n    }\n  return ref;\n}\n\n/**\n * code:\n *  TYPEDOBJHANDLE:\n *   2 Soft owner\n *   3 Hard owner\n *   4 Soft pointer\n *   5 Hard pointer\n *  OFFSETOBJHANDLE for soft owners or pointers:\n *   6 ref + 1\n *   8 ref - 1\n *   a ref + offset\n *   c ref - offset\n *   e ??\n */\nDwg_Object_Ref *\ndwg_decode_handleref_with_code (Bit_Chain *restrict dat,\n                                Dwg_Object *restrict obj,\n                                Dwg_Data *restrict dwg, unsigned int code)\n{\n  int err;\n  Dwg_Object_Ref *ref = (Dwg_Object_Ref *)calloc (1, sizeof (Dwg_Object_Ref));\n  if (!ref)\n    {\n      LOG_ERROR (\"Out of memory\");\n      return NULL;\n    }\n\n  err = bit_read_H (dat, &ref->handleref);\n  if (err)\n    {\n      /*\n      LOG_WARN (\"Invalid handleref error: 0x%x. Wanted code %d, got (\" FORMAT_H\n      \")\", err, code, ARGS_H(ref->handleref))\n      */\n      free (ref);\n      return NULL;\n    }\n\n  /* If the handle size is 0 and not a relative handle, it is probably\n     a null handle.\n     It shouldn't be placed in the object ref vector,\n     just with indxf the NULL HDL is. */\n  if (ref->handleref.size || (obj && ref->handleref.code > 5))\n    {\n      if (dwg_decode_add_object_ref (dwg, ref))\n        {\n          free (ref);\n          return NULL;\n        }\n    }\n  else if (!ref->handleref.value)\n    {\n      /*if (obj)\n        {\n          free (ref);\n          return NULL;\n        }\n      */\n      ref->absolute_ref = 0;\n      ref->obj = NULL;\n      return ref;\n    }\n\n  // We receive a null obj when we are reading\n  // handles in the header variables section\n  if (!obj)\n    {\n      ref->absolute_ref = ref->handleref.value;\n      ref->obj = NULL;\n      return ref;\n    }\n\n  /*\n   * With TYPEDOBJHANDLE 2-5 the code indicates the type of ownership.\n   * With OFFSETOBJHANDLE >5 the handle is stored as an offset from some other\n   * handle.\n   */\n  switch (ref->handleref.code)\n    {\n    case 0x06:\n      ref->absolute_ref = (obj->handle.value + 1);\n      break;\n    case 0x08:\n      ref->absolute_ref = (obj->handle.value - 1);\n      break;\n    case 0x0A:\n      ref->absolute_ref = (obj->handle.value + ref->handleref.value);\n      break;\n    case 0x0C:\n      ref->absolute_ref = (obj->handle.value - ref->handleref.value);\n      break;\n    case 0x0E: // eg 2007 REGION.history_id (some very high number)\n      ref->absolute_ref = obj->handle.value;\n      break;\n    case 2:\n    case 3:\n    case 4:\n    case 5:\n      ref->absolute_ref = ref->handleref.value;\n      break;\n    case 0: // ignore?\n      ref->absolute_ref = ref->handleref.value;\n      break;\n    default:\n      // dwg->object_ref[dwg->num_object_refs-1] = NULL;\n      // dwg->num_object_refs--;\n      ref->absolute_ref = 0;\n      ref->obj = NULL;\n      LOG_WARN (\"Invalid handle pointer code %d\", ref->handleref.code);\n      break;\n    }\n  return ref;\n}\n\nint\ndwg_decode_header_variables (Bit_Chain *dat, Bit_Chain *hdl_dat,\n                             Bit_Chain *str_dat, Dwg_Data *restrict dwg)\n{\n  Dwg_Header_Variables *_obj = &dwg->header_vars;\n  Dwg_Object *obj = NULL;\n  int error = 0;\n\n  // clang-format off\n  #include \"header_variables.spec\"\n  // clang-format on\n\n  return error;\n}\n\nstatic int\ndwg_decode_common_entity_handle_data (Bit_Chain *dat, Bit_Chain *hdl_dat,\n                                      Dwg_Object *restrict obj)\n{\n\n  Dwg_Data *dwg = obj->parent;\n  Dwg_Object_Entity *_obj, *_ent;\n  BITCODE_BL vcount;\n  int error = 0;\n\n  _obj = _ent = obj->tio.entity;\n\n  // deferred from common_entity_data, which has no hdl_dat\n  if (dat->version >= R_2007 && _ent->color.flag & 0x40)\n    FIELD_HANDLE (color.handle, 0, 430);\n\n    // clang-format off\n  #include \"common_entity_handle_data.spec\"\n  // clang-format on\n\n  return error;\n}\n\nenum RES_BUF_VALUE_TYPE\nget_base_value_type (short gc)\n{\n  if (gc >= 300)\n    {\n      if (gc >= 440)\n        {\n          if (gc >= 1000) // 1000-1071\n            {\n              if (gc == 1004)\n                return VT_BINARY;\n              if (gc <= 1009)\n                return VT_STRING;\n              if (gc <= 1059)\n                return VT_REAL;\n              if (gc <= 1070)\n                return VT_INT16;\n              if (gc == 1071)\n                return VT_INT32;\n            }\n          else // 440-999\n            {\n              if (gc <= 459)\n                return VT_INT32;\n              if (gc <= 469)\n                return VT_REAL;\n              if (gc <= 479)\n                return VT_STRING;\n              if (gc <= 998)\n                return VT_INVALID;\n              if (gc == 999)\n                return VT_STRING; // lgtm [cpp/constant-comparison]\n            }\n        }\n      else // <440\n        {\n          if (gc >= 390) // 390-439\n            {\n              if (gc <= 399)\n                return VT_HANDLE;\n              if (gc <= 409)\n                return VT_INT16;\n              if (gc <= 419)\n                return VT_STRING;\n              if (gc <= 429)\n                return VT_INT32;\n              if (gc <= 439)\n                return VT_STRING; // lgtm [cpp/constant-comparison]\n            }\n          else // 330-389\n            {\n              if (gc <= 309)\n                return VT_STRING;\n              if (gc <= 319)\n                return VT_BINARY;\n              if (gc <= 329)\n                return VT_HANDLE;\n              if (gc <= 369)\n                return VT_OBJECTID;\n              if (gc <= 389)\n                return VT_INT16; // lgtm [cpp/constant-comparison]\n            }\n        }\n    }\n  else if (gc >= 105)\n    {\n      if (gc >= 210) // 210-299\n        {\n          if (gc <= 239)\n            return VT_REAL;\n          if (gc <= 269)\n            return VT_INVALID;\n          if (gc <= 279)\n            return VT_INT16;\n          if (gc <= 289)\n            return VT_INT8;\n          if (gc <= 299)\n            return VT_BOOL; // lgtm [cpp/constant-comparison]\n        }\n      else // 105-209\n        {\n          if (gc == 105)\n            return VT_HANDLE;\n          if (gc <= 109)\n            return VT_INVALID;\n          if (gc <= 149)\n            return VT_REAL;\n          if (gc <= 169) // e.g. REQUIREDVERSIONS 160 r2013+\n            return VT_INT64;\n          if (gc <= 179)\n            return VT_INT16;\n          if (gc <= 209)\n            return VT_INVALID; // lgtm [cpp/constant-comparison]\n        }\n    }\n  else // <105\n    {\n      if (gc >= 38) // 38-102\n        {\n          if (gc <= 59)\n            return VT_REAL;\n          if (gc <= 79)\n            return VT_INT16;\n          if (gc <= 99)\n            return VT_INT32;\n          if (gc <= 101)\n            return VT_STRING;\n          if (gc == 102)\n            return VT_STRING;\n        }\n      else // 0-37\n        {\n          if (gc < 0)\n            return VT_HANDLE;\n          if (gc <= 4)\n            return VT_STRING;\n          if (gc == 5)\n            return VT_HANDLE;\n          if (gc <= 9)\n            return VT_STRING; // but 9 never TU\n          if (gc <= 37)\n            return VT_POINT3D; // lgtm [cpp/constant-comparison]\n        }\n    }\n  return VT_INVALID;\n}\n\nvoid\ndwg_free_xdata_resbuf (Dwg_Resbuf *rbuf)\n{\n  while (rbuf)\n    {\n      Dwg_Resbuf *next = rbuf->next;\n      short type = get_base_value_type (rbuf->type);\n      if (type == VT_STRING || type == VT_BINARY)\n        free (rbuf->value.str.u.data);\n      free (rbuf);\n      rbuf = next;\n    }\n}\n\n// TODO: unify with eed[], use an array not linked list.\nstatic Dwg_Resbuf *\ndwg_decode_xdata (Bit_Chain *restrict dat, Dwg_Object_XRECORD *restrict obj,\n                  BITCODE_BL size)\n{\n  Dwg_Resbuf *rbuf, *root = NULL, *curr = NULL;\n  unsigned char codepage;\n  long unsigned int end_address, curr_address;\n  BITCODE_BL i, num_xdata = 0;\n  BITCODE_RS length;\n  int error;\n\n  static int cnt = 0;\n  cnt++;\n\n  end_address = dat->byte + (unsigned long int)size;\n  if (obj->parent && obj->parent->objid)\n    {\n      Dwg_Data *dwg = obj->parent->dwg;\n      Dwg_Object *o = &dwg->object[obj->parent->objid];\n      if (size > o->size)\n        {\n          LOG_ERROR (\"Invalid XRECORD.num_databytes \" FORMAT_BL, size);\n          obj->num_databytes = 0;\n          return NULL;\n        }\n    }\n  LOG_INSANE (\"xdata:\\n\");\n  LOG_INSANE_TF (&dat->chain[dat->byte], (int)size);\n  curr_address = dat->byte;\n\n  while (dat->byte < end_address)\n    {\n      enum RES_BUF_VALUE_TYPE vtype;\n      rbuf = (Dwg_Resbuf *)calloc (1, sizeof (Dwg_Resbuf));\n      if (!rbuf)\n        {\n          LOG_ERROR (\"Out of memory\");\n          dwg_free_xdata_resbuf (root);\n          return NULL;\n        }\n      rbuf->next = NULL;\n      rbuf->type = bit_read_RS (dat);\n      if (dat->byte == curr_address)\n        {\n          // no advance, by dat overflow\n          dat->byte = end_address;\n          break;\n        }\n      if (rbuf->type < 0 || rbuf->type >= 2000)\n        {\n          LOG_ERROR (\"Invalid xdata type %d [RS]\", rbuf->type);\n          dat->byte = end_address;\n          break;\n        }\n      vtype = get_base_value_type (rbuf->type);\n      switch (vtype)\n        {\n        case VT_STRING:\n          PRE (R_2007)\n          {\n            length = rbuf->value.str.size = bit_read_RS (dat);\n            rbuf->value.str.codepage = bit_read_RC (dat);\n            if (length > size)\n              break;\n            rbuf->value.str.u.data = bit_read_TF (dat, length);\n            LOG_TRACE (\"xdata[%d]: \\\"%s\\\" [TF %d %d]\\n\", num_xdata,\n                       rbuf->value.str.u.data, length, rbuf->type);\n          }\n          LATER_VERSIONS\n          {\n            length = rbuf->value.str.size = bit_read_RS (dat);\n            if (length > 0 && length < size)\n              {\n                rbuf->value.str.u.wdata = calloc (length + 1, 2);\n                if (!rbuf->value.str.u.wdata)\n                  {\n                    LOG_ERROR (\"Out of memory\");\n                    if (root)\n                      {\n                        dwg_free_xdata_resbuf (root);\n                        if (rbuf)\n                          free (rbuf);\n                      }\n                    else\n                      dwg_free_xdata_resbuf (rbuf);\n                    return NULL;\n                  }\n                for (i = 0; i < length; i++)\n                  rbuf->value.str.u.wdata[i] = bit_read_RS (dat);\n                rbuf->value.str.u.wdata[i] = '\\0';\n                LOG_TRACE_TU (\"xdata\", rbuf->value.str.u.wdata, rbuf->type);\n              }\n          }\n          break;\n        case VT_REAL:\n          rbuf->value.dbl = bit_read_RD (dat);\n          LOG_TRACE (\"xdata[%d]: %f [RD %d]\\n\", num_xdata, rbuf->value.dbl,\n                     rbuf->type);\n          break;\n        case VT_BOOL:\n        case VT_INT8:\n          rbuf->value.i8 = bit_read_RC (dat);\n          LOG_TRACE (\"xdata[%d]: %d [RC %d]\\n\", num_xdata, (int)rbuf->value.i8,\n                     rbuf->type);\n          break;\n        case VT_INT16:\n          rbuf->value.i16 = bit_read_RS (dat);\n          LOG_TRACE (\"xdata[%d]: %d [RS %d]\\n\", num_xdata,\n                     (int)rbuf->value.i16, rbuf->type);\n          break;\n        case VT_INT32:\n          rbuf->value.i32 = bit_read_RL (dat);\n          LOG_TRACE (\"xdata[%d]: %d [RL %d]\\n\", num_xdata,\n                     (int)rbuf->value.i32, rbuf->type);\n          break;\n        case VT_INT64:\n          rbuf->value.i64 = bit_read_BLL (dat);\n          LOG_TRACE (\"xdata[%d]: \" FORMAT_BLL \" [BLL %d]\\n\", num_xdata,\n                     rbuf->value.i64, rbuf->type);\n          break;\n        case VT_POINT3D:\n          rbuf->value.pt[0] = bit_read_RD (dat);\n          rbuf->value.pt[1] = bit_read_RD (dat);\n          rbuf->value.pt[2] = bit_read_RD (dat);\n          LOG_TRACE (\"xdata[%d]: %f,%f,%f [3RD %d]\\n\", num_xdata,\n                     rbuf->value.pt[0], rbuf->value.pt[1], rbuf->value.pt[2],\n                     rbuf->type);\n          break;\n        case VT_BINARY:\n          rbuf->value.str.size = bit_read_RC (dat);\n          rbuf->value.str.u.data = bit_read_TF (dat, rbuf->value.str.size);\n          LOG_TRACE (\"xdata[%d]: [TF %d %d]\", num_xdata, rbuf->value.str.size,\n                     rbuf->type);\n          LOG_TRACE_TF (rbuf->value.str.u.data, rbuf->value.str.size);\n          break;\n        case VT_HANDLE:\n        case VT_OBJECTID:\n          bit_read_fixed (dat, rbuf->value.hdl, 8);\n          LOG_TRACE (\"xdata[%d]: %X [H %d]\\n\", num_xdata,\n                     (unsigned)*(uint64_t *)rbuf->value.hdl, rbuf->type);\n          break;\n        case VT_INVALID:\n        default:\n          LOG_ERROR (\"Invalid group code in xdata[%d]: %d\", num_xdata,\n                     rbuf->type)\n          dwg_free_xdata_resbuf (rbuf);\n          dat->byte = end_address;\n          obj->num_xdata = num_xdata;\n          return root;\n        }\n      num_xdata++;\n\n      if (!curr)\n        {\n          curr = root = rbuf;\n        }\n      else\n        {\n          curr->next = rbuf;\n          curr = rbuf;\n        }\n      curr_address = dat->byte;\n    }\n  obj->num_xdata = num_xdata;\n  return root;\n}\n\n/* OBJECTS *******************************************************************/\n\n#include \"dwg.spec\"\n\n/*--------------------------------------------------------------------------------\n * Private functions which depend on the preceding\n */\n\n/* check the types of all referenced handles.\n   r2010+ often mix up the hdlstream offset:\n   layer,vertex*,seqend. check the types then also.\n */\nstatic void\ncheck_POLYLINE_handles (Dwg_Object *obj)\n{\n  /* We ensured the common fields structure is shared with all 4 types */\n  Dwg_Entity_POLYLINE_2D *_obj = obj->tio.entity->tio.POLYLINE_2D;\n  Dwg_Data *dwg = obj->parent;\n\n  if (dwg->header.version >= R_2004)\n    {\n      BITCODE_BL i = 0;\n      Dwg_Object_Ref *layer = obj->tio.entity->layer;\n      Dwg_Object_Ref *seqend = _obj->seqend;\n\n      // resolve prev. object\n      if (layer && !layer->obj)\n        layer->obj = dwg_ref_object_relative (dwg, layer, obj);\n      if (!layer || !layer->obj)\n        { // maybe a reactor pointing forwards or vertex\n          LOG_WARN (\"Wrong POLYLINE.layer %lX\",\n                    layer ? layer->handleref.value : 0L);\n          if (_obj->num_owned > 0 && _obj->vertex)\n            {\n              Dwg_Object_Ref *vertex = _obj->vertex[0];\n              if (vertex && !vertex->obj)\n                vertex->obj = dwg_ref_object_relative (dwg, vertex, obj);\n              if (vertex && vertex->obj /* pointing backwards */\n                  && vertex->obj->fixedtype == DWG_TYPE_LAYER)\n                {\n                  Dwg_Object *seq;\n                  obj->tio.entity->layer = layer = vertex;\n                  LOG_WARN (\n                      \"POLYLINE.layer is vertex[0] %lX, shift em, NULL seqend\",\n                      layer->handleref.value);\n                  /* shift vertices one back */\n                  for (i = 0; i < _obj->num_owned - 1; i++)\n                    {\n                      _obj->vertex[i] = _obj->vertex[i + 1];\n                    }\n                  _obj->vertex[_obj->num_owned - 1] = seqend;\n                  _obj->seqend = NULL;\n                  /* now just seqend is empty.\n                     either 1+ last_vertex, or one before the first.\n                     Here the next object might not be read yet. */\n                  seq = dwg_next_object (obj);\n                  if (seq && seq->type == DWG_TYPE_SEQEND)\n                    {\n                      LOG_WARN (\"POLYLINE.seqend = POLYLINE+1 %lX\",\n                                seq->handle.value);\n                      seqend = _obj->seqend = dwg_find_objectref (dwg, seq);\n                    }\n                  else\n                    {\n                      seq = dwg_next_object (seqend->obj);\n                      if (seq && seq->type == DWG_TYPE_SEQEND)\n                        {\n                          LOG_WARN (\"POLYLINE.seqend = VERTEX+1 %lX\",\n                                    seq->handle.value);\n                          seqend = _obj->seqend\n                              = dwg_find_objectref (dwg, seq);\n                        }\n                    }\n                }\n            }\n        }\n      else if (layer->obj->fixedtype != DWG_TYPE_LAYER\n               && layer->obj->fixedtype != DWG_TYPE_DICTIONARY)\n        { // a vertex would be after, a reactor before\n          LOG_WARN (\"Wrong POLYLINE.layer %s\", layer->obj->dxfname)\n        }\n      // a SEQEND is always after the polyline, so it cannot be resolved yet\n      if (!seqend || !seqend->handleref.value)\n        {\n          LOG_WARN (\"Empty POLYLINE.seqend\")\n        }\n      else if (seqend->obj && seqend->obj->fixedtype != DWG_TYPE_SEQEND)\n        { // most likely a vertex, off by one\n          LOG_WARN (\"Wrong POLYLINE.seqend %s\", seqend->obj->dxfname)\n        }\n      if (!_obj->vertex)\n        return;\n      for (; i < _obj->num_owned; i++)\n        {\n          Dwg_Object_Ref *v = _obj->vertex[i];\n          if (!v || !v->handleref.value)\n            {\n              LOG_WARN (\"Empty POLYLINE.vertex[%d]\", i);\n            }\n          else if (v->obj && v->obj->fixedtype != DWG_TYPE_VERTEX_2D\n                   && v->obj->fixedtype != DWG_TYPE_VERTEX_3D\n                   && v->obj->fixedtype != DWG_TYPE_VERTEX_MESH\n                   && v->obj->fixedtype != DWG_TYPE_VERTEX_PFACE\n                   && v->obj->fixedtype != DWG_TYPE_VERTEX_PFACE_FACE)\n            {\n              LOG_WARN (\"Wrong POLYLINE.vertex[%d] %lX %s\", i,\n                        v->handleref.value, v->obj->dxfname)\n            }\n        }\n    }\n}\n\nstatic int\ndecode_preR13_entities (unsigned long start, unsigned long end,\n                        unsigned long offset, Bit_Chain *restrict dat,\n                        Dwg_Data *restrict dwg)\n{\n  int error = 0;\n  BITCODE_BL num = dwg->num_objects;\n  dat->bit = 0;\n  LOG_TRACE (\"entities: (0x%lx-0x%lx, offset 0x%lx) TODO\\n\", start, end,\n             offset)\n  while (dat->byte < end)\n    {\n      Dwg_Object *obj;\n      Dwg_Object_Entity *ent;\n      BITCODE_RS crc;\n\n      if (!num)\n        dwg->object\n            = (Dwg_Object *)malloc (REFS_PER_REALLOC * sizeof (Dwg_Object));\n      else if (num % REFS_PER_REALLOC == 0)\n        dwg->object = realloc (dwg->object,\n                               (num + REFS_PER_REALLOC) * sizeof (Dwg_Object));\n      if (!dwg->object)\n        {\n          LOG_ERROR (\"Out of memory\");\n          return DWG_ERR_OUTOFMEM;\n        }\n      obj = &dwg->object[num];\n      memset (obj, 0, sizeof (Dwg_Object));\n      dwg->num_objects++;\n      obj->index = num;\n      obj->parent = dwg;\n      obj->address = dat->byte;\n\n      DEBUG_HERE;\n\n      switch (obj->type)\n        {\n        case 1:\n          error |= dwg_decode_LINE (dat, obj);\n          break;\n        case 2:\n          error |= dwg_decode_POINT (dat, obj);\n          break;\n        case 3:\n          error |= dwg_decode_CIRCLE (dat, obj);\n          break;\n        case 4:\n          error |= dwg_decode_SHAPE (dat, obj);\n          break;\n        case 7:\n          error |= dwg_decode_TEXT (dat, obj);\n          break;\n        case 8:\n          error |= dwg_decode_ARC (dat, obj);\n          break;\n        case 9:\n          error |= dwg_decode_TRACE (dat, obj);\n          break;\n        case 11:\n          error |= dwg_decode_SOLID (dat, obj);\n          break;\n        case 12:\n          error |= dwg_decode_BLOCK (dat, obj);\n          break;\n        case 13:\n          error |= dwg_decode_ENDBLK (dat, obj);\n          break;\n        case 14:\n          error |= dwg_decode_INSERT (dat, obj);\n          break;\n        case 15:\n          error |= dwg_decode_ATTDEF (dat, obj);\n          break;\n        case 16:\n          error |= dwg_decode_ATTRIB (dat, obj);\n          break;\n        case 17:\n          error |= dwg_decode_SEQEND (dat, obj);\n          break;\n        case 19:\n          error |= dwg_decode_POLYLINE_2D (dat, obj);\n          break;\n        case 20:\n          error |= dwg_decode_VERTEX_2D (dat, obj);\n          break;\n        case 22:\n          error |= dwg_decode__3DFACE (dat, obj);\n          break;\n        case 23:\n          // TODO check opts for the type of dimension\n          error |= dwg_decode_DIMENSION_LINEAR (dat, obj);\n          break;\n        case 24:\n          error |= dwg_decode_VPORT (dat, obj);\n          break;\n        default:\n          LOG_ERROR (\"Unknown object type %d\", obj->type)\n          break;\n        }\n\n      bit_set_position (dat, obj->address + obj->size - 2);\n      crc = bit_read_RS (dat);\n      LOG_TRACE (\"crc: %04X [RSx]\\n\", crc);\n      num++;\n\n      if (obj->size < 2 || obj->size > 0x1000) // FIXME\n        dat->byte = end;\n    }\n\n  dat->byte = end;\n  return error;\n}\n\n/** dwg_decode_variable_type\n * decode object by class name, not type. if type > 500.\n * returns 0 on success\n */\nstatic int\ndwg_decode_variable_type (Dwg_Data *restrict dwg, Bit_Chain *dat,\n                          Bit_Chain *hdl_dat, Dwg_Object *restrict obj)\n{\n  Dwg_Class *klass;\n  int i;\n  int is_entity;\n\n  i = obj->type - 500;\n  if (i < 0 || i >= dwg->num_classes)\n    {\n      LOG_ERROR (\"Invalid object type %d, only %u classes\", obj->type,\n                 dwg->num_classes);\n      return DWG_ERR_INVALIDTYPE;\n    }\n\n  klass = &dwg->dwg_class[i];\n  if (!klass || !klass->dxfname)\n    return DWG_ERR_INTERNALERROR;\n  obj->dxfname = klass->dxfname;\n  // almost always false\n  is_entity = dwg_class_is_entity (klass);\n\n  // clang-format off\n  // global class dispatcher\n  #include \"classes.inc\"\n  // clang-format on\n\n  LOG_WARN (\"Unknown Class %s %d %s (0x%x%s)\", is_entity ? \"entity\" : \"object\",\n            klass->number, klass->dxfname, klass->proxyflag,\n            klass->wasazombie ? \" was proxy\" : \"\")\n\n  return DWG_ERR_UNHANDLEDCLASS;\n}\n\n/** Adds a new empty obj to the dwg->object[] array.\n    The new object is at &dwg->object[dwg->num_objects-1].\n\n    Returns 0 or some error codes on success.\n    Returns -1 if the dwg->object pool was re-alloced, i.e. pointers within\n    are invalidated.\n    Returns DWG_ERR_OUTOFMEM otherwise.\n */\nEXPORT int\ndwg_add_object (Dwg_Data *restrict dwg)\n{\n  Dwg_Object *restrict obj;\n  BITCODE_BL num = dwg->num_objects;\n  int realloced = 0;\n  if (!num)\n    dwg->object = calloc (REFS_PER_REALLOC, sizeof (Dwg_Object));\n  else if (num % REFS_PER_REALLOC == 0)\n    {\n      Dwg_Object *restrict old = dwg->object;\n      dwg->object = realloc (dwg->object,\n                             (num + REFS_PER_REALLOC) * sizeof (Dwg_Object));\n      realloced = old != dwg->object;\n    }\n  if (!dwg->object)\n    return DWG_ERR_OUTOFMEM;\n\n  obj = &dwg->object[num];\n  memset (obj, 0, sizeof (Dwg_Object));\n  obj->index = num;\n  dwg->num_objects++;\n  obj->parent = dwg;\n  return realloced ? -1 : 0;\n}\n\n/** Adds an object to the DWG (i.e. dwg->object[dwg->num_objects])\n    Returns 0 or some error codes on success.\n    Returns -1 if the dwg->object pool was re-alloced.\n    Returns some DWG_ERR_* otherwise.\n */\nint\ndwg_decode_add_object (Dwg_Data *restrict dwg, Bit_Chain *dat,\n                       Bit_Chain *hdl_dat, long unsigned int address)\n{\n  long unsigned int objpos, restartpos;\n  Bit_Chain abs_dat = { NULL };\n  unsigned char previous_bit;\n  Dwg_Object *restrict obj;\n  BITCODE_BL num = dwg->num_objects;\n  int error = 0;\n  int realloced = 0;\n\n  /* Keep the previous full chain  */\n  abs_dat = *dat;\n\n  /* Use the indicated address for the object\n   */\n  dat->byte = address;\n  dat->bit = 0;\n\n  // DEBUG_HERE;\n  /*\n   * Reserve memory space for objects. A realloc violates all internal\n   * pointers.\n   */\n  realloced = dwg_add_object (dwg);\n  if (realloced > 0)\n    {\n      *dat = abs_dat;\n      return realloced; // i.e. DWG_ERR_OUTOFMEM\n    }\n  obj = &dwg->object[num];\n  LOG_INFO (\"==========================================\\n\"\n            \"Object number: %lu/%lX\",\n            (unsigned long)num, (unsigned long)num)\n\n  obj->size = bit_read_MS (dat);\n  LOG_INFO (\", Size: %d [MS]\", obj->size)\n  SINCE (R_2010)\n  {\n    /* This is not counted in the object size */\n    obj->handlestream_size = bit_read_UMC (dat);\n    LOG_INFO (\", Hdlsize: \" FORMAT_UMC \" [UMC] \", obj->handlestream_size);\n    obj->bitsize = obj->size * 8 - obj->handlestream_size;\n    // TODO boundscheck\n  }\n\n  objpos = bit_position (dat); // absolute\n  obj->address = dat->byte;\n\n  /* Until here dat is absolute. now restrict it */\n  bit_reset_chain (dat);\n  if (obj->size > dat->size)\n    {\n      LOG_ERROR (\"\\nInvalid object size. Would overflow\");\n      *dat = abs_dat;\n      return DWG_ERR_VALUEOUTOFBOUNDS;\n    }\n  dat->size = obj->size;\n\n  SINCE (R_2010) { obj->type = bit_read_BOT (dat); }\n  else { obj->type = bit_read_BS (dat); }\n  LOG_INFO (\", Type: %d [%s]\\n\", obj->type, dat->version >= R_2010 ? \"BOT\" : \"BS\");\n  restartpos = bit_position (dat); // relative\n\n  /* Check the type of the object\n   */\n  switch (obj->type)\n    {\n    case DWG_TYPE_TEXT:\n      error = dwg_decode_TEXT (dat, obj);\n      break;\n    case DWG_TYPE_ATTRIB:\n      error = dwg_decode_ATTRIB (dat, obj);\n      break;\n    case DWG_TYPE_ATTDEF:\n      error = dwg_decode_ATTDEF (dat, obj);\n      break;\n    case DWG_TYPE_BLOCK:\n      error = dwg_decode_BLOCK (dat, obj);\n      break;\n    case DWG_TYPE_ENDBLK:\n      error = dwg_decode_ENDBLK (dat, obj);\n      break;\n    case DWG_TYPE_SEQEND:\n      error = dwg_decode_SEQEND (dat, obj);\n      if (dat->version >= R_13 && obj->tio.entity->ownerhandle)\n        {\n          Dwg_Object *restrict owner = dwg_resolve_handle (\n              dwg, obj->tio.entity->ownerhandle->absolute_ref);\n          if (!owner)\n            {\n              LOG_WARN (\"no SEQEND.ownerhandle\")\n            }\n          else if (owner->fixedtype == DWG_TYPE_INSERT\n                   || owner->fixedtype == DWG_TYPE_MINSERT)\n            {\n              /* SEQEND handle for the owner needed in validate_INSERT */\n              hash_set (dwg->object_map, obj->handle.value, (uint32_t)num);\n              (void)dwg_validate_INSERT (owner);\n            }\n          else if (owner->fixedtype == DWG_TYPE_POLYLINE_2D\n                   || owner->fixedtype == DWG_TYPE_POLYLINE_3D\n                   || owner->fixedtype == DWG_TYPE_POLYLINE_PFACE\n                   || owner->fixedtype == DWG_TYPE_POLYLINE_MESH)\n            {\n              Dwg_Entity_POLYLINE_2D *restrict _obj\n                  = owner->tio.entity->tio.POLYLINE_2D;\n              if (!_obj->seqend)\n                /* SEQEND handle for the owner needed in validate_POLYLINE */\n                hash_set (dwg->object_map, obj->handle.value, (uint32_t)num);\n              (void)dwg_validate_POLYLINE (owner);\n            }\n        }\n      break;\n    case DWG_TYPE_INSERT:\n      error = dwg_decode_INSERT (dat, obj);\n      break;\n    case DWG_TYPE_MINSERT:\n      error = dwg_decode_MINSERT (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_2D:\n      error = dwg_decode_VERTEX_2D (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_3D:\n      error = dwg_decode_VERTEX_3D (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_MESH:\n      error = dwg_decode_VERTEX_MESH (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_PFACE:\n      error = dwg_decode_VERTEX_PFACE (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_PFACE_FACE:\n      error = dwg_decode_VERTEX_PFACE_FACE (dat, obj);\n      break;\n    case DWG_TYPE_POLYLINE_2D:\n      error = dwg_decode_POLYLINE_2D (dat, obj);\n      if (dat->version >= R_2010)\n        check_POLYLINE_handles (obj);\n      break;\n    case DWG_TYPE_POLYLINE_3D:\n      error = dwg_decode_POLYLINE_3D (dat, obj);\n      if (dat->version >= R_2010)\n        check_POLYLINE_handles (obj);\n      break;\n    case DWG_TYPE_ARC:\n      error = dwg_decode_ARC (dat, obj);\n      break;\n    case DWG_TYPE_CIRCLE:\n      error = dwg_decode_CIRCLE (dat, obj);\n      break;\n    case DWG_TYPE_LINE:\n      error = dwg_decode_LINE (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_ORDINATE:\n      error = dwg_decode_DIMENSION_ORDINATE (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_LINEAR:\n      error = dwg_decode_DIMENSION_LINEAR (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_ALIGNED:\n      error = dwg_decode_DIMENSION_ALIGNED (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_ANG3PT:\n      error = dwg_decode_DIMENSION_ANG3PT (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_ANG2LN:\n      error = dwg_decode_DIMENSION_ANG2LN (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_RADIUS:\n      error = dwg_decode_DIMENSION_RADIUS (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_DIAMETER:\n      error = dwg_decode_DIMENSION_DIAMETER (dat, obj);\n      break;\n    case DWG_TYPE_POINT:\n      error = dwg_decode_POINT (dat, obj);\n      break;\n    case DWG_TYPE__3DFACE:\n      error = dwg_decode__3DFACE (dat, obj);\n      break;\n    case DWG_TYPE_POLYLINE_PFACE:\n      error = dwg_decode_POLYLINE_PFACE (dat, obj);\n      if (dat->version >= R_2010)\n        check_POLYLINE_handles (obj);\n      break;\n    case DWG_TYPE_POLYLINE_MESH:\n      error = dwg_decode_POLYLINE_MESH (dat, obj);\n      if (dat->version >= R_2010)\n        check_POLYLINE_handles (obj);\n      break;\n    case DWG_TYPE_SOLID:\n      error = dwg_decode_SOLID (dat, obj);\n      break;\n    case DWG_TYPE_TRACE:\n      error = dwg_decode_TRACE (dat, obj);\n      break;\n    case DWG_TYPE_SHAPE:\n      error = dwg_decode_SHAPE (dat, obj);\n      break;\n    case DWG_TYPE_VIEWPORT:\n      error = dwg_decode_VIEWPORT (dat, obj);\n      break;\n    case DWG_TYPE_ELLIPSE:\n      error = dwg_decode_ELLIPSE (dat, obj);\n      break;\n    case DWG_TYPE_SPLINE:\n      error = dwg_decode_SPLINE (dat, obj);\n      break;\n    case DWG_TYPE_REGION:\n      error = dwg_decode_REGION (dat, obj);\n      break;\n    case DWG_TYPE__3DSOLID:\n      error = dwg_decode__3DSOLID (dat, obj);\n      break;\n    case DWG_TYPE_BODY:\n      error = dwg_decode_BODY (dat, obj);\n      break;\n    case DWG_TYPE_RAY:\n      error = dwg_decode_RAY (dat, obj);\n      break;\n    case DWG_TYPE_XLINE:\n      error = dwg_decode_XLINE (dat, obj);\n      break;\n    case DWG_TYPE_DICTIONARY:\n      error = dwg_decode_DICTIONARY (dat, obj);\n      break;\n    case DWG_TYPE_MTEXT:\n      error = dwg_decode_MTEXT (dat, obj);\n      break;\n    case DWG_TYPE_LEADER:\n      error = dwg_decode_LEADER (dat, obj);\n      break;\n    case DWG_TYPE_TOLERANCE:\n      error = dwg_decode_TOLERANCE (dat, obj);\n      break;\n    case DWG_TYPE_MLINE:\n      error = dwg_decode_MLINE (dat, obj);\n      break;\n    case DWG_TYPE_BLOCK_CONTROL:\n      error = dwg_decode_BLOCK_CONTROL (dat, obj);\n      if (!error && obj->tio.object->tio.BLOCK_CONTROL)\n        {\n          obj->tio.object->tio.BLOCK_CONTROL->objid = num;\n          if (!dwg->block_control.parent) // only once\n            dwg->block_control = *obj->tio.object->tio.BLOCK_CONTROL;\n          else\n            LOG_WARN (\"Second BLOCK_CONTROL object ignored\");\n        }\n      break;\n    case DWG_TYPE_BLOCK_HEADER:\n      error = dwg_decode_BLOCK_HEADER (dat, obj);\n      /*\n       * We cannot cache dwg->*space_block here as dwg->objects might get\n       * realloc'ed. See dwg_model_space_object() and dwg_paper_space_object()\n       * instead.\n       */\n      break;\n    case DWG_TYPE_LAYER_CONTROL:\n      error = dwg_decode_LAYER_CONTROL (dat, obj);\n      if (!error && obj->tio.object->tio.LAYER_CONTROL)\n        {\n          obj->tio.object->tio.LAYER_CONTROL->objid = num;\n          dwg->layer_control = *obj->tio.object->tio.LAYER_CONTROL;\n        }\n      break;\n    case DWG_TYPE_LAYER:\n      error = dwg_decode_LAYER (dat, obj);\n      break;\n    case DWG_TYPE_STYLE_CONTROL:\n      error = dwg_decode_STYLE_CONTROL (dat, obj);\n      if (!error && obj->tio.object->tio.STYLE_CONTROL)\n        {\n          obj->tio.object->tio.STYLE_CONTROL->objid = num;\n          dwg->style_control = *obj->tio.object->tio.STYLE_CONTROL;\n        }\n      break;\n    case DWG_TYPE_STYLE:\n      error = dwg_decode_STYLE (dat, obj);\n      break;\n    case DWG_TYPE_LTYPE_CONTROL:\n      error = dwg_decode_LTYPE_CONTROL (dat, obj);\n      if (!error && obj->tio.object->tio.LTYPE_CONTROL)\n        {\n          obj->tio.object->tio.LTYPE_CONTROL->objid = num;\n          dwg->ltype_control = *obj->tio.object->tio.LTYPE_CONTROL;\n        }\n      break;\n    case DWG_TYPE_LTYPE:\n      error = dwg_decode_LTYPE (dat, obj);\n      break;\n    case DWG_TYPE_VIEW_CONTROL:\n      error = dwg_decode_VIEW_CONTROL (dat, obj);\n      if (!error && obj->tio.object->tio.VIEW_CONTROL)\n        {\n          obj->tio.object->tio.VIEW_CONTROL->objid = num;\n          dwg->view_control = *obj->tio.object->tio.VIEW_CONTROL;\n        }\n      break;\n    case DWG_TYPE_VIEW:\n      error = dwg_decode_VIEW (dat, obj);\n      break;\n    case DWG_TYPE_UCS_CONTROL:\n      error = dwg_decode_UCS_CONTROL (dat, obj);\n      if (!error && obj->tio.object->tio.UCS_CONTROL)\n        {\n          obj->tio.object->tio.UCS_CONTROL->objid = num;\n          dwg->ucs_control = *obj->tio.object->tio.UCS_CONTROL;\n        }\n      break;\n    case DWG_TYPE_UCS:\n      error = dwg_decode_UCS (dat, obj);\n      break;\n    case DWG_TYPE_VPORT_CONTROL:\n      error = dwg_decode_VPORT_CONTROL (dat, obj);\n      if (!error && obj->tio.object->tio.VPORT_CONTROL)\n        {\n          obj->tio.object->tio.VPORT_CONTROL->objid = num;\n          dwg->vport_control = *obj->tio.object->tio.VPORT_CONTROL;\n        }\n      break;\n    case DWG_TYPE_VPORT:\n      error = dwg_decode_VPORT (dat, obj);\n      break;\n    case DWG_TYPE_APPID_CONTROL:\n      error = dwg_decode_APPID_CONTROL (dat, obj);\n      if (!error && obj->tio.object->tio.APPID_CONTROL)\n        {\n          obj->tio.object->tio.APPID_CONTROL->objid = num;\n          dwg->appid_control = *obj->tio.object->tio.APPID_CONTROL;\n        }\n      break;\n    case DWG_TYPE_APPID:\n      error = dwg_decode_APPID (dat, obj);\n      break;\n    case DWG_TYPE_DIMSTYLE_CONTROL:\n      error = dwg_decode_DIMSTYLE_CONTROL (dat, obj);\n      if (!error && obj->tio.object->tio.DIMSTYLE_CONTROL)\n        {\n          obj->tio.object->tio.DIMSTYLE_CONTROL->objid = num;\n          dwg->dimstyle_control = *obj->tio.object->tio.DIMSTYLE_CONTROL;\n        }\n      break;\n    case DWG_TYPE_DIMSTYLE:\n      error = dwg_decode_DIMSTYLE (dat, obj);\n      break;\n    case DWG_TYPE_VPORT_ENTITY_CONTROL:\n      error = dwg_decode_VPORT_ENTITY_CONTROL (dat, obj);\n      if (!error && obj->tio.object->tio.VPORT_ENTITY_CONTROL)\n        {\n          obj->tio.object->tio.VPORT_ENTITY_CONTROL->objid = num;\n          dwg->vport_entity_control\n              = *obj->tio.object->tio.VPORT_ENTITY_CONTROL;\n        }\n      break;\n    case DWG_TYPE_VPORT_ENTITY_HEADER:\n      error = dwg_decode_VPORT_ENTITY_HEADER (dat, obj);\n      break;\n    case DWG_TYPE_GROUP:\n      error = dwg_decode_GROUP (dat, obj);\n      break;\n    case DWG_TYPE_MLINESTYLE:\n      error = dwg_decode_MLINESTYLE (dat, obj);\n      break;\n    case DWG_TYPE_OLE2FRAME:\n      error = dwg_decode_OLE2FRAME (dat, obj);\n      break;\n    case DWG_TYPE_DUMMY:\n      error = dwg_decode_DUMMY (dat, obj);\n      break;\n    case DWG_TYPE_LONG_TRANSACTION:\n      error = dwg_decode_LONG_TRANSACTION (dat, obj);\n      break;\n    case DWG_TYPE_LWPOLYLINE:\n      error = dwg_decode_LWPOLYLINE (dat, obj);\n      break;\n    case DWG_TYPE_HATCH:\n      error = dwg_decode_HATCH (dat, obj);\n      break;\n    case DWG_TYPE_XRECORD:\n      error = dwg_decode_XRECORD (dat, obj);\n      break;\n    case DWG_TYPE_PLACEHOLDER:\n      error = dwg_decode_PLACEHOLDER (dat, obj);\n      break;\n    case DWG_TYPE_OLEFRAME:\n      error = dwg_decode_OLEFRAME (dat, obj);\n      break;\n    case DWG_TYPE_VBA_PROJECT:\n      LOG_ERROR (\"Unhandled Object VBA_PROJECT. Has its own section\");\n      // dwg_decode_VBA_PROJECT(dat, obj);\n      error = DWG_ERR_UNHANDLEDCLASS;\n      break;\n    case DWG_TYPE_LAYOUT:\n      error = dwg_decode_LAYOUT (dat, obj);\n      break;\n    case DWG_TYPE_PROXY_ENTITY:\n      error = dwg_decode_PROXY_ENTITY (dat, obj);\n      break;\n    case DWG_TYPE_PROXY_OBJECT:\n      error = dwg_decode_PROXY_OBJECT (dat, obj);\n      break;\n    default:\n      if (obj->type == dwg->layout_type)\n        error = dwg_decode_LAYOUT (dat, obj);\n      /* > 500 */\n      else if ((error = dwg_decode_variable_type (dwg, dat, hdl_dat, obj))\n               & DWG_ERR_UNHANDLEDCLASS)\n        {\n          int is_entity = 0;\n          int i = obj->type - 500;\n          Dwg_Class *klass = NULL;\n\n          /* restart and read into the UNKNOWN_OBJ object */\n          /* the relative offset from type after common_entity_data */\n          // obj->common_size = bit_position(dat) - restartpos;\n          // LOG_HANDLE(\"common_size: %lu\\n\", obj->common_size); // needed for\n          // unknown\n          bit_set_position (dat, restartpos);\n\n          // obj->unknown_off = obj->unknown_pos - restartpos;\n          // LOG_TRACE(\"Unknown pos %lu, offset %lu\\n\", obj->unknown_pos,\n          // obj->unknown_off);\n\n          if (i >= 0 && i < (int)dwg->num_classes)\n            {\n              klass = &dwg->dwg_class[i];\n              is_entity = dwg_class_is_entity (klass);\n            }\n          else\n            {\n              if (i < 0)\n                {\n                  LOG_ERROR (\"Invalid class index %d <0\", i);\n                }\n              else\n                {\n                  LOG_ERROR (\"Invalid class index %d >%d\", i,\n                             (int)dwg->num_classes);\n                }\n              obj->supertype = DWG_SUPERTYPE_UNKNOWN;\n              obj->type = 0;\n              *dat = abs_dat;\n              return error | DWG_ERR_VALUEOUTOFBOUNDS;\n            }\n          // properly dwg_decode_object/_entity for eed, reactors, xdic\n          if (klass && !is_entity)\n            {\n              int err = dwg_decode_UNKNOWN_OBJ (dat, obj);\n              error |= err;\n              obj->supertype = DWG_SUPERTYPE_UNKNOWN;\n              if (!dat)\n                return error;\n              if (err >= DWG_ERR_CRITICAL)\n                *dat = abs_dat;\n            }\n          else if (klass) // is_entity\n            {\n              int err;\n#if 0 && !defined(IS_RELEASE)\n              if (strEQc(klass->dxfname, \"MULTILEADER\")) { //debug CED\n                char *mleader = bit_read_TF(dat, obj->size);\n                LOG_INSANE_TF(mleader, (int)obj->size)\n                bit_set_position(dat, restartpos);\n                free (mleader);\n              }\n#endif\n              err = dwg_decode_UNKNOWN_ENT (dat, obj);\n              error |= err;\n              obj->supertype = DWG_SUPERTYPE_UNKNOWN;\n              if (!dat)\n                return error;\n              if (err >= DWG_ERR_CRITICAL)\n                *dat = abs_dat;\n            }\n          else // not a class\n            {\n              LOG_WARN (\"Unknown object, skipping eed/reactors/xdic\");\n              SINCE (R_2000)\n              {\n                obj->bitsize = bit_read_RL (dat);\n                LOG_TRACE (\"bitsize: \" FORMAT_RL \" [RL] @%lu.%u\\n\",\n                           obj->bitsize, dat->byte-2, dat->bit);\n                if (obj->bitsize > obj->size * 8)\n                  {\n                    LOG_ERROR (\"Invalid bitsize \" FORMAT_RL \" => \" FORMAT_RL,\n                               obj->bitsize, obj->size * 8);\n                    obj->bitsize = obj->size * 8;\n                    error |= DWG_ERR_VALUEOUTOFBOUNDS;\n                  }\n              }\n              if (!bit_read_H (dat, &obj->handle))\n                {\n                  LOG_TRACE (\"handle: \" FORMAT_H \" [H 5]\\n\",\n                             ARGS_H (obj->handle));\n                }\n              restartpos = dat->byte;\n              obj->supertype = DWG_SUPERTYPE_UNKNOWN;\n              obj->tio.unknown = bit_read_TF (dat, obj->size);\n              dat->byte = restartpos;\n            }\n        }\n    }\n\n  if (obj->handle.value)\n    { // empty only with UNKNOWN\n      LOG_HANDLE (\" object_map{%lX} = %lu\\n\", obj->handle.value,\n                  (unsigned long)num);\n      hash_set (dwg->object_map, obj->handle.value, (uint32_t)num);\n    }\n\n  if (dat->byte > 8 * dat->size)\n    {\n      LOG_ERROR (\"Invalid object address (overflow): %lu > %lu\", dat->byte,\n                 8 * dat->size);\n      *dat = abs_dat;\n      return error | DWG_ERR_INVALIDDWG;\n    }\n\n  /* Restore the old absolute chain.\n     CRC needs to be calculated from address, which is before our 0 position.\n   */\n  restartpos = bit_position (dat);\n  *dat = abs_dat;\n  bit_set_position (dat, objpos + restartpos);\n\n  /* Now 1 padding bits until next byte, and then a RS CRC */\n  if (dat->bit)\n    {\n      unsigned char r = 8 - dat->bit;\n      LOG_HANDLE (\" padding: %X/%X (%d bits)\\n\", dat->chain[dat->byte],\n                  dat->chain[dat->byte] & ((1 << r) - 1), r);\n      bit_advance_position (dat, r);\n    }\n  bit_set_position (dat, (obj->address + obj->size) * 8 - 2);\n  if (!bit_check_CRC (dat, address, 0xC0C1))\n    error |= DWG_ERR_WRONGCRC;\n\n  /* Reset to previous addresses for return */\n  *dat = abs_dat;\n\n  return realloced ? -1 : error; // re-alloced or not\n}\n\n/** dwg_decode_unknown\n   Container to hold a unknown class entity, see classes.inc\n   Every DEBUGGING class holds a bits array, a bitsize, and the handle\n   and string stream offsets.\n   It starts after the common_entity|object_data until and goes until the end\n   of final padding, to the CRC.\n   (obj->common_size/8 .. obj->size)\n */\nint\ndwg_decode_unknown (Bit_Chain *restrict dat, Dwg_Object *restrict obj)\n{\n  // bitsize does not include the handles size\n  int num_bytes;\n  unsigned long pos = bit_position (dat);\n  long num_bits = (8 * obj->size) - pos;\n  if (num_bits < 0)\n    return DWG_ERR_VALUEOUTOFBOUNDS;\n\n  //*pre_bits = pos % 8;\n  obj->num_unknown_bits = num_bits;\n  num_bytes = num_bits / 8;\n  if (num_bits % 8)\n    {\n      num_bytes++;\n      dat->size++; // allow overshoot by one byte (for missing bits)\n    }\n\n  obj->unknown_bits = bit_read_TF (dat, num_bytes);\n  // [num_bits (commonsize, hdlpos, strsize)]\n  LOG_TRACE (\"unknown_bits [%ld (%lu,%ld,%d) TF]: \", num_bits,\n             obj->common_size, obj->bitsize - obj->common_size,\n             (int)obj->stringstream_size);\n  LOG_TRACE_TF (obj->unknown_bits, num_bytes);\n  bit_set_position (dat, pos);\n  if (num_bits % 8)\n    dat->size--;\n  return 0;\n}\n\n/* A dimension is immediately followed by BLOCK_HEADER - BLOCK.name - ENDBLK */\n/* sometimes also by a layer */\nchar *\ndwg_dim_blockname (Dwg_Data *restrict dwg, const Dwg_Object *restrict obj)\n{\n  BITCODE_BL id = obj->tio.entity->objid;\n  Dwg_Object *restrict hdr = &dwg->object[id + 1];\n  Dwg_Object *restrict blk = &dwg->object[id + 2];\n\n  if ((hdr->type == DWG_TYPE_LAYER || hdr->type == DWG_TYPE_DICTIONARY)\n      && blk->type == DWG_TYPE_BLOCK_HEADER)\n    {\n      hdr = blk;\n      blk = &dwg->object[id + 3];\n    }\n  if (hdr->type == DWG_TYPE_BLOCK_HEADER && blk->type == DWG_TYPE_BLOCK)\n    {\n      Dwg_Entity_BLOCK *restrict _blk = blk->tio.entity->tio.BLOCK;\n      return _blk->name;\n    }\n  return NULL;\n}\n\n/* Ensure that the given refs have rising objid's/indices (when read in natural\n * order) */\nstatic inline int\nref_after (const Dwg_Object_Ref *restrict r1,\n           const Dwg_Object_Ref *restrict r2)\n{\n  if (!r1 || !r2 || !r1->obj || !r2->obj)\n    return 0;\n  return r1->obj->index >= r2->obj->index ? 1 : 0;\n}\n\n/* just look at the next object, if it's a SEQEND (i.e ENDBLK) */\nint\ndwg_validate_INSERT (Dwg_Object *restrict obj)\n{\n  Dwg_Object *restrict next = dwg_next_object (obj);\n\n  if (obj->fixedtype == DWG_TYPE_INSERT)\n    {\n      Dwg_Entity_INSERT *restrict _obj = obj->tio.entity->tio.INSERT;\n      Dwg_Object_Ref *restrict seqend = _obj->seqend;\n      if (!_obj->has_attribs)\n        return 1;\n      if (!seqend || next == seqend->obj)\n        {\n          LOG_TRACE (\"unsorted INSERT %lX SEQEND %lX ATTRIB\\n\",\n                     obj->handle.value,\n                     seqend && seqend->obj ? seqend->obj->handle.value : 0L)\n          return 0;\n        }\n    }\n  else if (obj->fixedtype == DWG_TYPE_MINSERT)\n    {\n      Dwg_Entity_MINSERT *restrict _obj = obj->tio.entity->tio.MINSERT;\n      Dwg_Object_Ref *restrict seqend = _obj->seqend;\n      if (!_obj->has_attribs)\n        return 1;\n      if (!seqend || next == seqend->obj)\n        {\n          LOG_TRACE (\"unsorted INSERT %lX SEQEND %lX ATTRIB\\n\",\n                     obj->handle.value,\n                     seqend && seqend->obj ? seqend->obj->handle.value : 0L)\n          return 0;\n        }\n    }\n  return 1;\n}\n\nint\ndwg_validate_POLYLINE (Dwg_Object *restrict obj)\n{\n  /* We ensured the common fields structure is shared with all 4 types */\n  Dwg_Entity_POLYLINE_2D *restrict _obj = obj->tio.entity->tio.POLYLINE_2D;\n  Dwg_Data *restrict dwg = obj->parent;\n\n  if (dwg->header.version > R_11)\n    {\n      Dwg_Object_Ref *restrict seqend = _obj->seqend;\n      /* if shifted in check_POLYLINE_handles() seqend might be empty */\n      if (!seqend)\n        { /* either the first or last */\n          Dwg_Object *restrict next = dwg_next_object (obj);\n          if (next && next->fixedtype == DWG_TYPE_SEQEND)\n            {\n              seqend = dwg_find_objectref (\n                  dwg, next); // usually not found, even with set hash\n              if (seqend == NULL)\n                {\n                  seqend\n                      = (Dwg_Object_Ref *)calloc (1, sizeof (Dwg_Object_Ref));\n                  seqend->obj = next;\n                  seqend->handleref = next->handle;\n                  seqend->absolute_ref = next->handle.value;\n                  dwg_decode_add_object_ref (dwg, seqend);\n                }\n              _obj->seqend = seqend;\n              LOG_WARN (\"fixed empty POLYLINE.seqend with +1 obj\")\n            }\n          else if (_obj->vertex)\n            {\n              Dwg_Object_Ref *restrict ref = _obj->vertex[_obj->num_owned - 1];\n              if (ref && ref->obj)\n                {\n                  next = dwg_next_object (ref->obj);\n                  if (next && next->fixedtype == DWG_TYPE_SEQEND)\n                    {\n                      seqend = dwg_find_objectref (dwg, next);\n                      if (seqend == NULL)\n                        {\n                          seqend = (Dwg_Object_Ref *)calloc (\n                              1, sizeof (Dwg_Object_Ref));\n                          seqend->obj = next;\n                          seqend->handleref = next->handle;\n                          seqend->absolute_ref = next->handle.value;\n                          dwg_decode_add_object_ref (dwg, seqend);\n                        }\n                      _obj->seqend = seqend;\n                      LOG_WARN (\n                          \"fixed empty POLYLINE.seqend with last vertex +1\")\n                    }\n                }\n            }\n        }\n    }\n  if (dwg->header.version > R_11 && dwg->header.version <= R_2000)\n    {\n      Dwg_Object_Ref *restrict first_vertex = _obj->first_vertex;\n      Dwg_Object_Ref *restrict last_vertex = _obj->last_vertex;\n      Dwg_Object_Ref *restrict seqend = _obj->seqend;\n      if (ref_after (first_vertex, last_vertex)\n          || ref_after (last_vertex, seqend))\n        {\n          LOG_TRACE (\"unsorted POLYLINE VERTEX SEQEND\\n\")\n          return 0;\n        }\n    }\n  else if (dwg->header.version >= R_2004 && _obj->vertex)\n    {\n      BITCODE_BL i = 1;\n      Dwg_Object_Ref *restrict first_vertex = _obj->vertex[0];\n      Dwg_Object_Ref *restrict seqend = _obj->seqend;\n      if (ref_after (first_vertex, seqend))\n        {\n          /* r2010+ often mix up the hdlstream offset:\n             layer,vertex*,seqend. check the types then also */\n          if (first_vertex->obj->index < obj->index)\n            {\n              LOG_WARN (\"skip wrong POLYLINE.vertex[0] handle %lX < %lX\\n\",\n                        first_vertex->obj->handle.value, obj->handle.value);\n              if (_obj->num_owned > 1)\n                first_vertex = _obj->vertex[1];\n              i = 2;\n            }\n          else\n            {\n              LOG_TRACE (\"unsorted POLYLINE VERTEX SEQEND\\n\")\n              return 0;\n            }\n        }\n      for (; i < _obj->num_owned; i++)\n        {\n          if (ref_after (first_vertex, _obj->vertex[i])\n              || ref_after (_obj->vertex[i], seqend))\n            {\n              LOG_TRACE (\"unsorted POLYLINE VERTEX SEQEND\\n\")\n              return 0;\n            }\n        }\n    }\n  return 1;\n}\n\nstatic const char *\ndwg_ref_objname (const Dwg_Data *restrict dwg, Dwg_Object_Ref *restrict ref)\n{\n  Dwg_Object *restrict obj = dwg_ref_object_silent (dwg, ref);\n  return obj ? obj->name : \"\";\n}\n\n// supports tables entries and everything with a name.\n// r2007 names are returned as malloc'ed utf-8\nstatic const char *\ndwg_ref_tblname (const Dwg_Data *restrict dwg, Dwg_Object_Ref *restrict ref)\n{\n  const char *restrict name = dwg_dynapi_handle_name (dwg, ref);\n  return name ? name : \"\";\n}\n\n#undef IS_DECODER\n", "/*****************************************************************************/\n/*  LibreDWG - free implementation of the DWG file format                    */\n/*                                                                           */\n/*  Copyright (C) 2009-2010,2018-2019 Free Software Foundation, Inc.         */\n/*  Copyright (C) 2010 Thien-Thi Nguyen                                      */\n/*                                                                           */\n/*  This library is free software, licensed under the terms of the GNU       */\n/*  General Public License as published by the Free Software Foundation,     */\n/*  either version 3 of the License, or (at your option) any later version.  */\n/*  You should have received a copy of the GNU General Public License        */\n/*  along with this program.  If not, see <http://www.gnu.org/licenses/>.    */\n/*****************************************************************************/\n\n/*\n * encode.c: encoding functions to write a DWG\n * written by Felipe Castro\n * modified by Felipe Corr\u00eaa da Silva Sances\n * modified by Rodrigo Rodrigues da Silva\n * modified by Thien-Thi Nguyen\n * modified by Till Heuschmann\n * modified by Anderson Pierre Cardoso\n * modified by Reini Urban\n */\n\n#include \"config.h\"\n#ifdef __STDC_ALLOC_LIB__\n#  define __STDC_WANT_LIB_EXT2__ 1 /* for strdup */\n#else\n#  define _USE_BSD 1\n#endif\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <string.h>\n#include <assert.h>\n\n#include \"common.h\"\n#include \"bits.h\"\n#include \"dwg.h\"\n#include \"encode.h\"\n#include \"decode.h\"\n\n/* The logging level for the write (encode) path.  */\nstatic unsigned int loglevel;\n/* the current version per spec block */\nstatic unsigned int cur_ver = 0;\n\n#ifdef USE_TRACING\n/* This flag means we have checked the environment variable\n   LIBREDWG_TRACE and set `loglevel' appropriately.  */\nstatic bool env_var_checked_p;\n#endif /* USE_TRACING */\n#define DWG_LOGLEVEL loglevel\n\n#include \"logging.h\"\n\n/*--------------------------------------------------------------------------------\n * spec MACROS\n */\n\n#define ACTION encode\n#define IS_ENCODER\n\n#define ANYCODE -1\n#define REFS_PER_REALLOC 100\n\n#define VALUE(value, type, dxf)                                               \\\n  {                                                                           \\\n    bit_write_##type (dat, value);                                            \\\n    LOG_TRACE (FORMAT_##type \" [\" #type \" %d]\\n\", value, dxf);                \\\n  }\n#define VALUE_RC(value, dxf) VALUE (value, RC, dxf)\n#define VALUE_RS(value, dxf) VALUE (value, RS, dxf)\n#define VALUE_RL(value, dxf) VALUE (value, RL, dxf)\n#define VALUE_RD(value, dxf) VALUE (value, RD, dxf)\n\n#define FIELD(nam, type)                                                      \\\n  {                                                                           \\\n    bit_write_##type (dat, _obj->nam);                                        \\\n    FIELD_TRACE (nam, type);                                                  \\\n  }\n#define FIELDG(nam, type, dxf)                                                \\\n  {                                                                           \\\n    bit_write_##type (dat, _obj->nam);                                        \\\n    FIELD_G_TRACE (nam, type, dxf);                                           \\\n  }\n#define FIELD_TRACE(nam, type)                                                \\\n  LOG_TRACE (#nam \": \" FORMAT_##type \"\\n\", _obj->nam)\n#define FIELD_G_TRACE(nam, type, dxfgroup)                                    \\\n  LOG_TRACE (#nam \": \" FORMAT_##type \" [\" #type \" \" #dxfgroup \"]\\n\", _obj->nam)\n#define FIELD_CAST(nam, type, cast, dxf)                                      \\\n  {                                                                           \\\n    bit_write_##type (dat, (BITCODE_##type)_obj->nam);                        \\\n    FIELD_G_TRACE (nam, cast, dxf);                                           \\\n  }\n#define SUB_FIELD(o, nam, type, dxf) FIELD (o.nam, type)\n\n#define FIELD_VALUE(nam) _obj->nam\n\n#define FIELD_B(nam, dxf)    FIELDG (nam, B, dxf)\n#define FIELD_BB(nam, dxf)   FIELDG (nam, BB, dxf)\n#define FIELD_3B(nam, dxf)   FIELDG (nam, 3B, dxf)\n#define FIELD_BS(nam, dxf)   FIELDG (nam, BS, dxf)\n#define FIELD_BSd(nam, dxf)  FIELD_CAST(nam, BS, BSd, dxf)\n#define FIELD_RSx(nam, dxf)  FIELD_CAST(nam, RS, RSx, dxf)\n#define FIELD_RLx(nam, dxf)  FIELD_CAST(nam, RL, RLx, dxf)\n#define FIELD_BLx(nam, dxf)  FIELD_CAST(nam, BL, BLx, dxf)\n#define FIELD_BLd(nam, dxf)  FIELD_CAST(nam, BL, BLd, dxf)\n#define FIELD_RLd(nam, dxf)  FIELD_CAST(nam, RL, RLd, dxf)\n#define FIELD_BL(nam, dxf)   FIELDG (nam, BL, dxf)\n#define FIELD_BLL(nam, dxf)  FIELDG (nam, BLL, dxf)\n#define FIELD_BD(nam, dxf) FIELDG (nam, BD, dxf)\n#define FIELD_RC(nam, dxf) FIELDG (nam, RC, dxf)\n#define FIELD_RS(nam, dxf) FIELDG (nam, RS, dxf)\n#define FIELD_RD(nam, dxf) FIELDG (nam, RD, dxf)\n#define FIELD_RL(nam, dxf) FIELDG (nam, RL, dxf)\n#define FIELD_RLL(nam, dxf) FIELDG (nam, RLL, dxf)\n#define FIELD_MC(nam, dxf) FIELDG (nam, MC, dxf)\n#define FIELD_MS(nam, dxf) FIELDG (nam, MS, dxf)\n#define FIELD_TV(nam, dxf)                                                    \\\n  {                                                                           \\\n    IF_ENCODE_FROM_EARLIER { if (!_obj->nam) _obj->nam = strdup (\"\"); }       \\\n    FIELDG (nam, TV, dxf);                                                    \\\n  }\n#define FIELD_T(nam, dxf)                                                     \\\n  {                                                                           \\\n    if (dat->version < R_2007)                                                \\\n      {                                                                       \\\n        FIELD_TV (nam, dxf)                                                   \\\n      }                                                                       \\\n    else                                                                      \\\n      {                                                                       \\\n        if (!obj || obj->has_strings)                                         \\\n          {                                                                   \\\n            FIELD_TU (nam, dxf)                                               \\\n          }                                                                   \\\n        else                                                                  \\\n          {                                                                   \\\n            LOG_TRACE_TU (#nam, L\"\", dxf);                                    \\\n          }                                                                   \\\n      }                                                                       \\\n  }\n#define FIELD_TF(nam, len, dxf)                                               \\\n  {                                                                           \\\n    if (len > 0)                                                              \\\n      {                                                                       \\\n        if (!_obj->nam)                                                       \\\n          { /* empty field, write zeros */                                    \\\n            for (int _i = 0; _i < (int)(len); _i++)                           \\\n              bit_write_RC (dat, 0);                                          \\\n          }                                                                   \\\n        else                                                                  \\\n          bit_write_TF (dat, (BITCODE_TF)_obj->nam, len);                     \\\n      }                                                                       \\\n    FIELD_G_TRACE (nam, TF, dxf);                                             \\\n  }\n#define FIELD_TFF(nam, len, dxf)  FIELD_TF(nam, len, dxf)\n#define FIELD_TU(nam, dxf)                                                    \\\n  {                                                                           \\\n    if (_obj->nam)                                                            \\\n      bit_write_TU (dat, (BITCODE_TU)_obj->nam);                              \\\n    LOG_TRACE_TU (#nam, (BITCODE_TU)_obj->nam, dxf);                          \\\n  }\n#define FIELD_BT(nam, dxf) FIELDG (nam, BT, dxf);\n\n#define _FIELD_DD(nam, _default, dxf)                                         \\\n  bit_write_DD (dat, FIELD_VALUE (nam), _default);\n#define FIELD_DD(nam, _default, dxf)                                          \\\n  _FIELD_DD(nam, _default, dxf);                                              \\\n  LOG_TRACE (#nam \": %f [DD %d]\\n\", _obj->nam, dxf)\n#define FIELD_2DD(nam, d1, d2, dxf)                                           \\\n  {                                                                           \\\n    _FIELD_DD (nam.x, d1, dxf);                                               \\\n    _FIELD_DD (nam.y, d2, dxf + 10);                                          \\\n    LOG_TRACE (#nam \": (%f, %f) [2DD %d]\\n\", _obj->nam.x, _obj->nam.y, dxf)   \\\n  }\n#define FIELD_3DD(nam, def, dxf)                                              \\\n  {                                                                           \\\n    _FIELD_DD (nam.x, FIELD_VALUE (def.x), dxf);                              \\\n    _FIELD_DD (nam.y, FIELD_VALUE (def.y), dxf + 10);                         \\\n    _FIELD_DD (nam.z, FIELD_VALUE (def.z), dxf + 20);                         \\\n    LOG_TRACE (#nam \": (%f, %f, %f) [3DD %d]\\n\", _obj->nam.x, _obj->nam.y,    \\\n               _obj->nam.z, dxf)                                              \\\n  }\n#define FIELD_2RD(nam, dxf)                                                   \\\n  {                                                                           \\\n    bit_write_RD (dat, _obj->nam.x);                                          \\\n    bit_write_RD (dat, _obj->nam.y);                                          \\\n    LOG_TRACE (#nam \": (%f, %f) [3RD %d]\\n\", _obj->nam.x, _obj->nam.y, dxf)   \\\n  }\n#define FIELD_2BD(nam, dxf)                                                   \\\n  {                                                                           \\\n    bit_write_BD (dat, _obj->nam.x);                                          \\\n    bit_write_BD (dat, _obj->nam.y);                                          \\\n    LOG_TRACE (#nam \": (%f, %f) [3BD %d]\\n\", _obj->nam.x, _obj->nam.y, dxf)   \\\n  }\n#define FIELD_2BD_1(nam, dxf) FIELD_2BD(nam, dxf)\n#define FIELD_3RD(nam, dxf)                                                   \\\n  {                                                                           \\\n    bit_write_RD (dat, _obj->nam.x);                                          \\\n    bit_write_RD (dat, _obj->nam.y);                                          \\\n    bit_write_RD (dat, _obj->nam.z);                                          \\\n    LOG_TRACE (#nam \": (%f, %f, %f) [3RD %d]\\n\", _obj->nam.x, _obj->nam.y,    \\\n               _obj->nam.z, dxf)                                              \\\n  }\n#define FIELD_3BD(nam, dxf)                                                   \\\n  {                                                                           \\\n    bit_write_BD (dat, _obj->nam.x);                                          \\\n    bit_write_BD (dat, _obj->nam.y);                                          \\\n    bit_write_BD (dat, _obj->nam.z);                                          \\\n    LOG_TRACE (#nam \": (%f, %f, %f) [3BD %d]\\n\", _obj->nam.x, _obj->nam.y,    \\\n               _obj->nam.z, dxf)                                              \\\n  }\n#define FIELD_3BD_1(nam, dxf)   FIELD_3BD(nam, dxf)\n#define FIELD_3DPOINT(nam, dxf) FIELD_3BD (nam, dxf)\n#define FIELD_4BITS(nam, dxf)                                                 \\\n  {                                                                           \\\n    unsigned char _b = (unsigned char)_obj->nam;                              \\\n    bit_write_4BITS (dat, _b);                                                \\\n    LOG_TRACE (#nam \": b%d%d%d%d [4BITS %d]\\n\", _b & 8, _b & 4, _b & 2,       \\\n               _b & 1, dxf);                                                  \\\n  }\n#define FIELD_TIMEBLL(nam, dxf)                                               \\\n  {                                                                           \\\n    bit_write_TIMEBLL (dat, (BITCODE_TIMEBLL)_obj->nam);                      \\\n    LOG_TRACE (#nam \": \" FORMAT_BL \".\" FORMAT_BL \"\\n\", _obj->nam.days,        \\\n               _obj->nam.ms);                                                 \\\n  }\n\n#define FIELD_CMC(color, dxf1, dxf2)                                          \\\n  {                                                                           \\\n    bit_write_CMC (dat, &_obj->color);                                        \\\n    LOG_TRACE (#color \".index: %d [CMC.BS %d]\\n\", _obj->color.index, dxf1);   \\\n    if (dat->version >= R_2004)                                               \\\n      {                                                                       \\\n        LOG_TRACE (#color \".rgb: 0x%06x [CMC.BL %d]\\n\",                       \\\n                   (unsigned)_obj->color.rgb, dxf2);                          \\\n        LOG_TRACE (#color \".flag: 0x%x [CMC.RC]\\n\",                           \\\n                   (unsigned)_obj->color.flag);                               \\\n        if (_obj->color.flag & 1)                                             \\\n          LOG_TRACE (#color \".name: %s [CMC.TV]\\n\", _obj->color.name);        \\\n        if (_obj->color.flag & 2)                                             \\\n          LOG_TRACE (#color \".bookname: %s [CMC.TV]\\n\",                       \\\n                     _obj->color.book_name);                                  \\\n      }                                                                       \\\n  }\n\n#define SUB_FIELD_CMC(o, nam, dxf1, dxf2) bit_write_CMC (dat, &_obj->o.nam)\n\n#define FIELD_BE(nam, dxf)                                                    \\\n  bit_write_BE (dat, FIELD_VALUE (nam.x), FIELD_VALUE (nam.y),                \\\n                FIELD_VALUE (nam.z));\n\n// No overflow check with IS_RELEASE\n#ifdef IS_RELEASE\n#  define OVERFLOW_CHECK(nam, size)\n#  define OVERFLOW_CHECK_LV(nam, size)\n#else\n#  define OVERFLOW_CHECK(nam, size)                                           \\\n    if ((long)(size) > 0xff00L)                                               \\\n      {                                                                       \\\n        LOG_ERROR (\"Invalid \" #nam \" %ld\", (long)size);                       \\\n        return DWG_ERR_VALUEOUTOFBOUNDS;                                      \\\n      }\n#  define OVERFLOW_CHECK_LV(nam, size)                                        \\\n    if ((long)(size) > 0xff00L)                                               \\\n      {                                                                       \\\n        LOG_ERROR (\"Invalid \" #nam \" %ld, set to 0\", (long)size);             \\\n        size = 0;                                                             \\\n        return DWG_ERR_VALUEOUTOFBOUNDS;                                      \\\n      }\n#endif\n\n#define FIELD_2RD_VECTOR(nam, size, dxf)                                      \\\n  OVERFLOW_CHECK_LV (nam, _obj->size)                                         \\\n  for (vcount = 0; vcount < (BITCODE_BL)_obj->size; vcount++)                 \\\n    {                                                                         \\\n      FIELD_2RD (nam[vcount], dxf);                                           \\\n    }\n\n#define FIELD_2DD_VECTOR(nam, size, dxf)                                      \\\n  OVERFLOW_CHECK (nam, _obj->size)                                            \\\n  if (_obj->size)                                                             \\\n    FIELD_2RD (nam[0], dxf);                                                  \\\n  for (vcount = 1; vcount < (BITCODE_BL)_obj->size; vcount++)                 \\\n    {                                                                         \\\n      FIELD_2DD (nam[vcount], FIELD_VALUE (nam[vcount - 1].x),                \\\n                 FIELD_VALUE (nam[vcount - 1].y), dxf);                       \\\n    }\n\n#define FIELD_3DPOINT_VECTOR(nam, size, dxf)                                  \\\n  OVERFLOW_CHECK_LV (nam, _obj->size)                                         \\\n  for (vcount = 0; vcount < (BITCODE_BL)_obj->size; vcount++)                 \\\n    {                                                                         \\\n      FIELD_3DPOINT (nam[vcount], dxf);                                       \\\n    }\n\n#define REACTORS(code)                                                        \\\n  if (obj->tio.object->reactors)                                              \\\n    {                                                                         \\\n      OVERFLOW_CHECK_LV (nam, obj->tio.object->num_reactors)                  \\\n      SINCE (R_13)                                                            \\\n      {                                                                       \\\n        for (vcount = 0; vcount < (BITCODE_BL)obj->tio.object->num_reactors;  \\\n             vcount++)                                                        \\\n          {                                                                   \\\n            VALUE_HANDLE (obj->tio.object->reactors[vcount], reactors, code,  \\\n                          330);                                               \\\n          }                                                                   \\\n      }                                                                       \\\n    }\n\n#define XDICOBJHANDLE(code)                                                   \\\n  RESET_VER                                                                   \\\n  SINCE (R_2004)                                                              \\\n  {                                                                           \\\n    if (!obj->tio.object->xdic_missing_flag)                                  \\\n      {                                                                       \\\n        VALUE_HANDLE (obj->tio.object->xdicobjhandle, xdicobjhandle, code,    \\\n                      360);                                                   \\\n      }                                                                       \\\n  }                                                                           \\\n  else                                                                        \\\n  {                                                                           \\\n    SINCE (R_13)                                                              \\\n    {                                                                         \\\n      VALUE_HANDLE (obj->tio.object->xdicobjhandle, xdicobjhandle, code,      \\\n                    360);                                                     \\\n    }                                                                         \\\n  }                                                                           \\\n  RESET_VER\n\n#define ENT_XDICOBJHANDLE(code)                                               \\\n  RESET_VER                                                                   \\\n  SINCE (R_2004)                                                              \\\n  {                                                                           \\\n    if (!obj->tio.entity->xdic_missing_flag)                                  \\\n      {                                                                       \\\n        VALUE_HANDLE (obj->tio.entity->xdicobjhandle, xdicobjhandle, code,    \\\n                      360);                                                   \\\n      }                                                                       \\\n  }                                                                           \\\n  else                                                                        \\\n  {                                                                           \\\n    SINCE (R_13)                                                              \\\n    {                                                                         \\\n      VALUE_HANDLE (obj->tio.entity->xdicobjhandle, xdicobjhandle, code,      \\\n                    360);                                                     \\\n    }                                                                         \\\n  }                                                                           \\\n  RESET_VER\n\n// FIELD_VECTOR_N(nam, type, size, dxf):\n// writes a 'size' elements vector of data of the type indicated by 'type'\n#define FIELD_VECTOR_N(nam, type, size, dxf)                                  \\\n  if (size > 0 && _obj->nam)                                                  \\\n    {                                                                         \\\n      OVERFLOW_CHECK (nam, size)                                              \\\n      for (vcount = 0; vcount < (BITCODE_BL)size; vcount++)                   \\\n        {                                                                     \\\n          bit_write_##type (dat, _obj->nam[vcount]);                          \\\n          LOG_TRACE (#nam \"[%ld]: \" FORMAT_##type \"\\n\", (long)vcount,         \\\n                     _obj->nam[vcount])                                       \\\n        }                                                                     \\\n    }\n#define FIELD_VECTOR_T(nam, size, dxf)                                        \\\n  if (_obj->size > 0 && _obj->nam)                                            \\\n    {                                                                         \\\n      OVERFLOW_CHECK_LV (nam, _obj->size)                                     \\\n      for (vcount = 0; vcount < (BITCODE_BL)_obj->size; vcount++)             \\\n        {                                                                     \\\n          PRE (R_2007)                                                        \\\n          {                                                                   \\\n            bit_write_TV (dat, _obj->nam[vcount]);                            \\\n            LOG_TRACE (#nam \"[%d]: %s\\n\", (int)vcount, _obj->nam[vcount])     \\\n          }                                                                   \\\n          else                                                                \\\n          {                                                                   \\\n            bit_write_TU (dat, (BITCODE_TU)_obj->nam[vcount]);                \\\n            LOG_TRACE_TU (#nam, _obj->nam[vcount], dxf)                       \\\n          }                                                                   \\\n        }                                                                     \\\n      RESET_VER                                                               \\\n    }\n\n#define FIELD_VECTOR(nam, type, size, dxf)                                    \\\n  FIELD_VECTOR_N (nam, type, _obj->size, dxf)\n\n#define VALUE_HANDLE(hdlptr, nam, handle_code, dxf)                           \\\n  IF_ENCODE_SINCE_R13                                                         \\\n  {                                                                           \\\n    RESET_VER                                                                 \\\n    if (!hdlptr)                                                              \\\n      {                                                                       \\\n        Dwg_Handle null_handle = { 0, 0, 0 };                                 \\\n        null_handle.code = handle_code;                                       \\\n        bit_write_H (hdl_dat, &null_handle);                                  \\\n        LOG_TRACE (#nam \": (%d.0.0) abs:0 [H %d]\\n\", handle_code, dxf)        \\\n      }                                                                       \\\n    else                                                                      \\\n      {                                                                       \\\n        if (handle_code != ANYCODE && hdlptr->handleref.code != handle_code   \\\n            && (handle_code == 4 && hdlptr->handleref.code < 6))              \\\n          {                                                                   \\\n            LOG_WARN (\"Expected a CODE %d handle, got a %d\", handle_code,     \\\n                      hdlptr->handleref.code);                                \\\n          }                                                                   \\\n        bit_write_H (hdl_dat, &hdlptr->handleref);                            \\\n        LOG_TRACE (#nam \": \" FORMAT_REF \" [H %d]\\n\", ARGS_REF (hdlptr), dxf)  \\\n      }                                                                       \\\n  }\n\n#define FIELD_HANDLE(nam, handle_code, dxf)                                   \\\n  VALUE_HANDLE (_obj->nam, nam, handle_code, dxf)\n#define SUB_FIELD_HANDLE(o, nam, handle_code, dxf)                            \\\n  VALUE_HANDLE (_obj->o.nam, nam, handle_code, dxf)\n#define FIELD_DATAHANDLE(nam, handle_code, dxf)                               \\\n  {                                                                           \\\n    bit_write_H (dat, _obj->nam ? &_obj->nam->handleref : NULL);              \\\n  }\n\n#define FIELD_HANDLE_N(nam, vcount, handle_code, dxf)                         \\\n  IF_ENCODE_SINCE_R13                                                         \\\n  {                                                                           \\\n    RESET_VER                                                                 \\\n    if (!_obj->nam)                                                           \\\n      {                                                                       \\\n        bit_write_H (hdl_dat, NULL);                                          \\\n        LOG_TRACE (#nam \"[%d]: NULL %d [H* %d]\\n\", (int)vcount, handle_code,  \\\n                   dxf)                                                       \\\n      }                                                                       \\\n    else                                                                      \\\n      {                                                                       \\\n        if (handle_code != ANYCODE                                            \\\n            && _obj->nam->handleref.code != handle_code                       \\\n            && (handle_code == 4 && _obj->nam->handleref.code < 6))           \\\n          {                                                                   \\\n            LOG_WARN (\"Expected a CODE %x handle, got a %x\", handle_code,     \\\n                      _obj->nam->handleref.code);                             \\\n          }                                                                   \\\n        bit_write_H (hdl_dat, &_obj->nam->handleref);                         \\\n        LOG_TRACE (#nam \"[%d]: \" FORMAT_REF \" [H* %d]\\n\", (int)vcount,        \\\n                   ARGS_REF (_obj->nam), dxf)                                 \\\n      }                                                                       \\\n  }\n\n#define HANDLE_VECTOR_N(nam, size, code, dxf)                                 \\\n  if (size > 0 && _obj->nam)                                                  \\\n    {                                                                         \\\n      OVERFLOW_CHECK (nam, size)                                              \\\n      for (vcount = 0; vcount < (BITCODE_BL)size; vcount++)                   \\\n        {                                                                     \\\n          if (_obj->nam[vcount])                                              \\\n            {                                                                 \\\n              FIELD_HANDLE_N (nam[vcount], vcount, code, dxf);                \\\n            }                                                                 \\\n        }                                                                     \\\n    }\n\n#define FIELD_NUM_INSERTS(num_inserts, type, dxf)                             \\\n  for (vcount = 0; vcount < FIELD_VALUE (num_inserts); vcount++)              \\\n    {                                                                         \\\n      bit_write_RC (dat, 1);                                                  \\\n    }                                                                         \\\n  bit_write_RC (dat, 0);                                                      \\\n  LOG_TRACE (\"num_inserts: %d [RC* 0]\\n\", FIELD_VALUE (num_inserts))\n\n#define HANDLE_VECTOR(nam, sizefield, code, dxf)                              \\\n  HANDLE_VECTOR_N (nam, FIELD_VALUE (sizefield), code, dxf)\n\n#define FIELD_XDATA(nam, size)                                                \\\n  error |= dwg_encode_xdata (dat, _obj, _obj->size)\n\n#define COMMON_ENTITY_HANDLE_DATA                                             \\\n  SINCE (R_13)                                                                \\\n  {                                                                           \\\n    START_HANDLE_STREAM;                                                      \\\n    PRE (R_2007)                                                              \\\n    {                                                                         \\\n      error |= dwg_encode_common_entity_handle_data (dat, hdl_dat, obj);      \\\n    }                                                                         \\\n  }                                                                           \\\n  RESET_VER\n\n#define SECTION_STRING_STREAM                                                 \\\n  {                                                                           \\\n    Bit_Chain sav_dat = *dat;                                                 \\\n    dat = str_dat;\n\n/* TODO: dump all TU strings here */\n#define START_STRING_STREAM                                                   \\\n  bit_write_B (dat, obj->has_strings);                                        \\\n  RESET_VER                                                                   \\\n  if (obj->has_strings)                                                       \\\n    {                                                                         \\\n      Bit_Chain sav_dat = *dat;                                               \\\n      obj_string_stream (dat, obj, dat);\n\n#define END_STRING_STREAM                                                     \\\n  *dat = sav_dat;                                                             \\\n  }\n#define START_HANDLE_STREAM                                                   \\\n  *hdl_dat = *dat;                                                            \\\n  if (dat->version >= R_2007 && obj->bitsize)                                 \\\n    bit_set_position (hdl_dat, obj->hdlpos);                                  \\\n  if (!obj->bitsize)                                                          \\\n    {                                                                         \\\n      LOG_TRACE (\"-bitsize calc from HANDLE_STREAM @%lu.%u (%lu)\\n\",          \\\n                 dat->byte, dat->bit, obj->address);                          \\\n      obj->bitsize = bit_position (dat) - (obj->address * 8);                 \\\n    }                                                                         \\\n  RESET_VER\n\n#if 0\n/** See dec_macro.h instead.\n   Returns -1 if not added, else returns the new objid.\n   Does a complete handleref rescan to invalidate and resolve\n   all internal obj pointers after a object[] realloc.\n*/\nEXPORT long dwg_add_##token (Dwg_Data * dwg)    \\\n{                                               \\\n  Bit_Chain dat = { 0 };                        \\\n  BITCODE_BL num_objs  = dwg->num_objects;      \\\n  int error = 0;                                \\\n  dat.size = sizeof(Dwg_Entity_##token) + 40;   \\\n  LOG_INFO (\"Add entity \" #token \" \")           \\\n  dat.chain = calloc (dat.size, 1);             \\\n  dat.version = dwg->header.version;            \\\n  dat.from_version = dwg->header.from_version;  \\\n  bit_write_MS (&dat, dat.size);                \\\n  if (dat.version >= R_2010) {                  \\\n    /* FIXME: should be UMC handlestream_size */\\\n    bit_write_UMC (&dat, 8*sizeof(Dwg_Entity_##token)); \\\n    bit_write_BOT &dat, DWG_TYPE_##token);      \\\n  } else {                                      \\\n    bit_write_BS (&dat, DWG_TYPE_##token);      \\\n  }                                             \\\n  bit_set_position (&dat, 0);                   \\\n  error = dwg_decode_add_object (dwg, &dat, &dat, 0);\\\n  if (-1 == error)                              \\\n    dwg_resolve_objectrefs_silent (dwg);        \\\n  if (num_objs == dwg->num_objects)             \\\n    return -1;                                  \\\n  else                                          \\\n    return (long)dwg->num_objects;              \\\n}\n\nEXPORT long dwg_add_##token (Dwg_Data * dwg)     \\\n{                                                \\\n  Bit_Chain dat = { 0 };                         \\\n  int error = 0; \\\n  BITCODE_BL num_objs  = dwg->num_objects;       \\\n  dat.size = sizeof(Dwg_Object_##token) + 40;    \\\n  LOG_INFO (\"Add object \" #token \" \")            \\\n  dat.chain = calloc (dat.size, 1);              \\\n  dat.version = dwg->header.version;             \\\n  dat.from_version = dwg->header.from_version;   \\\n  bit_write_MS (&dat, dat.size);                 \\\n  if (dat.version >= R_2010) {                   \\\n    /* FIXME: should be UMC handlestream_size */ \\\n    bit_write_UMC (&dat, 8*sizeof(Dwg_Object_##token)); \\\n    bit_write_BOT (&dat, DWG_TYPE_##token);      \\\n  } else {                                       \\\n    bit_write_BS (&dat, DWG_TYPE_##token);       \\\n  }                                              \\\n  bit_set_position(&dat, 0);                     \\\n  error = dwg_decode_add_object(dwg, &dat, &dat, 0);\\\n  if (-1 ==  error) \\\n    dwg_resolve_objectrefs_silent(dwg);          \\\n  if (num_objs == dwg->num_objects)              \\\n    return -1;                                   \\\n  else                                           \\\n    return (long)dwg->num_objects;               \\\n}\n\n#endif\n\n#define DWG_ENTITY(token)                                                     \\\n  static int dwg_encode_##token (Bit_Chain *restrict dat,                     \\\n                                 Dwg_Object *restrict obj)                    \\\n  {                                                                           \\\n    BITCODE_BL vcount, rcount1, rcount2, rcount3, rcount4;                    \\\n    Dwg_Object_Entity *_ent = obj->tio.entity;                                \\\n    Dwg_Entity_##token *_obj = _ent->tio.token;                               \\\n    int error;                                                                \\\n    Bit_Chain *hdl_dat = dat;                                                 \\\n    Bit_Chain *str_dat = dat;                                                 \\\n    Dwg_Data *dwg = obj->parent;                                              \\\n    LOG_INFO (\"Encode entity \" #token \"\\n\")                                   \\\n    error = dwg_encode_entity (obj, dat, hdl_dat, str_dat);                   \\\n    if (error)                                                                \\\n      return error;\n\n#define DWG_ENTITY_END                                                        \\\n  return error;                                                               \\\n  }\n\n/** Returns -1 if not added, else returns the new objid.\n   Does a complete handleref rescan to invalidate and resolve\n   all internal obj pointers after a object[] realloc.\n*/\n#define DWG_OBJECT(token)                                                     \\\n  static int dwg_encode_##token (Bit_Chain *restrict dat,                     \\\n                                 Dwg_Object *restrict obj)                    \\\n  {                                                                           \\\n    BITCODE_BL vcount, rcount1, rcount2, rcount3, rcount4;                    \\\n    int error;                                                                \\\n    Bit_Chain *hdl_dat = dat;                                                 \\\n    Bit_Chain *str_dat = dat;                                                 \\\n    Dwg_Data *dwg = obj->parent;                                              \\\n    Dwg_Object_##token *_obj = obj->tio.object->tio.token;                    \\\n    error = dwg_encode_object (obj, dat, hdl_dat, str_dat);                   \\\n    if (error)                                                                \\\n      return error;                                                           \\\n    LOG_INFO (\"Encode object \" #token \"\\n\")\n\n#define DWG_OBJECT_END                                                        \\\n  return error;                                                               \\\n  }\n\n#define ENT_REACTORS(code)                                                    \\\n  if (dat->version >= R_2000 && _obj->num_reactors > 0x1000)                  \\\n    {                                                                         \\\n      fprintf (stderr, \"Invalid num_reactors: %ld\\n\",                         \\\n               (long)_obj->num_reactors);                                     \\\n      return DWG_ERR_VALUEOUTOFBOUNDS;                                        \\\n    }                                                                         \\\n  SINCE (R_13)                                                                \\\n  {                                                                           \\\n    if (_obj->num_reactors && !_obj->reactors)                                \\\n      {                                                                       \\\n        LOG_ERROR (\"NULL entity.reactors\");                                   \\\n        return DWG_ERR_VALUEOUTOFBOUNDS;                                      \\\n      }                                                                       \\\n    for (vcount = 0; vcount < _obj->num_reactors; vcount++)                   \\\n      {                                                                       \\\n        FIELD_HANDLE_N (reactors[vcount], vcount, code, 330);                 \\\n      }                                                                       \\\n  }\n\n#undef DEBUG_POS\n#define DEBUG_POS                                                             \\\n  if (DWG_LOGLEVEL >= DWG_LOGLEVEL_TRACE)                                     \\\n    {                                                                         \\\n      LOG_TRACE (\"DEBUG_POS @%u.%u / 0x%x (%lu)\\n\", (unsigned int)dat->byte,  \\\n                 dat->bit, (unsigned int)dat->byte, bit_position (dat));      \\\n    }\n\n/*--------------------------------------------------------------------------------*/\ntypedef struct\n{\n  unsigned long handle;\n  long address;\n  BITCODE_BL index;\n} Object_Map;\n\n/*--------------------------------------------------------------------------------\n * Private functions prototypes\n */\nstatic int encode_preR13 (Dwg_Data *restrict dwg, Bit_Chain *restrict dat);\n\nstatic int dwg_encode_entity (Dwg_Object *restrict obj, Bit_Chain *dat,\n                              Bit_Chain *hdl_dat, Bit_Chain *str_dat);\nstatic int dwg_encode_object (Dwg_Object *restrict obj,\n                              Bit_Chain *str_dat, Bit_Chain *hdl_dat,\n                              Bit_Chain *dat);\nstatic int dwg_encode_common_entity_handle_data (Bit_Chain *dat,\n                                                 Bit_Chain *hdl_dat,\n                                                 Dwg_Object *restrict obj);\nstatic int dwg_encode_header_variables (Bit_Chain *dat, Bit_Chain *hdl_dat,\n                                        Bit_Chain *str_dat, Dwg_Data *restrict dwg);\nstatic int dwg_encode_variable_type (Dwg_Data *restrict dwg,\n                                     Bit_Chain *restrict dat,\n                                     Dwg_Object *restrict obj);\nvoid dwg_encode_handleref (Bit_Chain *hdl_dat, Dwg_Object *restrict obj,\n                           Dwg_Data *restrict dwg,\n                           Dwg_Object_Ref *restrict ref);\nvoid dwg_encode_handleref_with_code (Bit_Chain *hdl_dat, Dwg_Object *restrict obj,\n                                     Dwg_Data *restrict dwg,\n                                     Dwg_Object_Ref *restrict ref,\n                                     unsigned int code);\nint dwg_encode_add_object (Dwg_Object *restrict obj, Bit_Chain *restrict dat,\n                           unsigned long address);\n\nstatic int dwg_encode_xdata (Bit_Chain *restrict dat,\n                             Dwg_Object_XRECORD *restrict obj, int size);\n\n/*--------------------------------------------------------------------------------\n * Public functions\n */\n\nstatic BITCODE_RL\nencode_patch_RLsize (Bit_Chain *dat, long unsigned int pvzadr)\n{\n  unsigned long pos;\n  BITCODE_RL size;\n  if (dat->bit) // padding\n    {\n      dat->bit = 0;\n      dat->byte++;\n    }\n  size = dat->byte - pvzadr - 4; // minus the RL size\n  pos = bit_position (dat);\n  assert (pvzadr);\n  bit_set_position (dat, pvzadr * 8);\n  bit_write_RL (dat, size);\n  LOG_TRACE (\"size: \" FORMAT_RL \" [RL] @%lu\\n\", size, pvzadr);\n  bit_set_position (dat, pos);\n  return size;\n}\n\n/**\n * dwg_encode(): the current generic encoder entry point.\n *\n * TODO: preR13 tables, 2007 maps.\n * 2010+ uses the 2004 format.\n * Returns a summary bitmask of all errors.\n */\nint\ndwg_encode (Dwg_Data *restrict dwg, Bit_Chain *restrict dat)\n{\n  int ckr_missing = 1;\n  int error = 0;\n  BITCODE_BL i, j;\n  long unsigned int section_address;\n  unsigned char pvzbit;\n  long unsigned int pvzadr;\n  long unsigned int pvzadr_2;\n  unsigned int ckr;\n  unsigned int sec_size = 0;\n  long unsigned int last_offset;\n  BITCODE_BL last_handle;\n  Object_Map *omap;\n  Bit_Chain *hdl_dat;\n\n  if (dwg->opts)\n    loglevel = dwg->opts & DWG_OPTS_LOGLEVEL;\n#ifdef USE_TRACING\n  /* Before starting, set the logging level, but only do so once.  */\n  if (!env_var_checked_p)\n    {\n      char *probe = getenv (\"LIBREDWG_TRACE\");\n      if (probe)\n        loglevel = atoi (probe);\n      env_var_checked_p = true;\n    }\n#endif /* USE_TRACING */\n\n  bit_chain_alloc (dat);\n  hdl_dat = dat;\n\n  /*------------------------------------------------------------\n   * Header\n   */\n  strcpy ((char *)dat->chain,\n          version_codes[dwg->header.version]); // Chain version\n  if (dwg->header.version != dwg->header.from_version)\n    LOG_TRACE (\"Encode version %s from version %s\\n\",\n               version_codes[dwg->header.version],\n               version_codes[dwg->header.from_version])\n  else\n    LOG_TRACE (\"Encode version %s\\n\", version_codes[dwg->header.version])\n  dat->byte += 6;\n\n  {\n    struct Dwg_Header *_obj = &dwg->header;\n    Dwg_Object *obj = NULL;\n    if (!_obj->dwg_version)\n      {\n        _obj->is_maint = 0;\n        switch (dwg->header.version)\n          {\n          case R_9:\n            _obj->dwg_version = 0x11; // ?\n            break;\n          case R_10:\n            _obj->dwg_version = 0x12; // ?\n            break;\n          case R_11:\n            _obj->dwg_version = 0x13; // ?\n            break;\n          case R_13:\n            _obj->dwg_version = 0x15;\n            break;\n          case R_14:\n            _obj->dwg_version = 0x16;\n            break;\n          case R_2000:\n            _obj->dwg_version = 0x17;\n            _obj->is_maint = 0xf;\n            break;\n          case R_2004:\n            _obj->dwg_version = 0x19;\n            _obj->is_maint = 0x68;\n            break;\n          case R_2007:\n            _obj->dwg_version = 0x1b;\n            _obj->is_maint = 0x32;\n            break;\n          case R_2010:\n            _obj->dwg_version = 0x1d;\n            _obj->is_maint = 0x6d;\n            break;\n          case R_2013:\n            _obj->dwg_version = 0x1f;\n            _obj->is_maint = 0x7d;\n            break;\n          case R_2018:\n            _obj->dwg_version = 0x21;\n            _obj->is_maint = 0x4;\n            break;\n          case R_INVALID:\n          case R_AFTER:\n          case R_1_1:\n          case R_1_2:\n          case R_1_4:\n          case R_2_0:\n          case R_2_1:\n          case R_2_5:\n          case R_2_6:\n          default:\n            break;\n          }\n        if (!_obj->app_dwg_version)\n          _obj->app_dwg_version = _obj->dwg_version;\n      }\n    if (!_obj->codepage)\n      _obj->codepage = 30;\n\n    // clang-format off\n    #include \"header.spec\"\n    // clang-format on\n  }\n  section_address = dat->byte;\n\n#define WE_CAN                                                                \\\n  \"This version of LibreDWG is only capable of encoding \"                     \\\n  \"version R13-R2000 (code: AC1012-AC1015) DWG files.\\n\"\n\n  PRE (R_13)\n  {\n    // TODO: tables, entities, block entities\n    LOG_ERROR (WE_CAN \"We don't encode preR13 tables, entities, blocks yet\")\n#ifndef IS_RELEASE\n    return encode_preR13 (dwg, dat);\n#endif\n  }\n\n  PRE (R_2004)\n  {\n    /* section 0: header vars\n     *         1: class section\n     *         2: object map\n     *         3: (R13 c3 and later): 2nd header (special table no sentinels)\n     *         4: optional: MEASUREMENT\n     *         5: optional: AuxHeader\n     */\n    if (!dwg->header.num_sections) /* Usually 3-5, max 6 */\n      {\n        dwg->header.num_sections = dwg->header.version < R_2000 ? 5 : 6;\n        // minimal DXF:\n        if (!dwg->header_vars.HANDSEED || !dwg->header_vars.TDCREATE.days)\n          {\n            dwg->header.num_sections = 5;\n            dat->from_version = R_11; // to trigger IF_ENCODE_FROM_EARLIER defaults\n            if (dat->version <= dat->from_version)\n              dat->from_version = dat->version - 1;\n          }\n      }\n    LOG_TRACE (\"num_sections: \" FORMAT_RL \" [RL]\\n\", dwg->header.num_sections);\n    bit_write_RL (dat, dwg->header.num_sections);\n    if (!dwg->header.section)\n      dwg->header.section\n          = calloc (dwg->header.num_sections, sizeof (Dwg_Section));\n    section_address = dat->byte;                 // save section address\n    dat->byte += (dwg->header.num_sections * 9); /* RC + 2*RL */\n    bit_write_CRC (dat, 0, 0xC0C1);\n    bit_write_sentinel (dat, dwg_sentinel (DWG_SENTINEL_HEADER_END));\n\n    /*------------------------------------------------------------\n     * AuxHeader section 5\n     * R2000+, mostly redundant file header information\n     */\n    if (dwg->header.num_sections > 5)\n      {\n        struct Dwg_AuxHeader *_obj = &dwg->auxheader;\n        Dwg_Object *obj = NULL;\n        assert (!dat->bit);\n        LOG_INFO (\"\\n=======> AuxHeader: %8u\\n\",\n                  (unsigned)dat->byte); // size: 123\n\n        dwg->header.section[SECTION_AUXHEADER_R2000].number = 5;\n        dwg->header.section[SECTION_AUXHEADER_R2000].address = dat->byte;\n\n        if (!_obj->dwg_version)\n          {\n            BITCODE_RS tmpunknown[] = { 4, 0x565, 0, 0, 2, 1 };\n            LOG_TRACE (\"Use AuxHeader defaults...\\n\");\n            FIELD_VALUE (aux_intro[0]) = 0xff;\n            FIELD_VALUE (aux_intro[1]) = 0x77;\n            FIELD_VALUE (aux_intro[2]) = 0x01;\n            FIELD_VALUE (minus_1) = -1;\n            FIELD_VALUE (dwg_version) = dwg->header.dwg_version;\n            FIELD_VALUE (maint_version) = dwg->header.maint_version;\n            FIELD_VALUE (dwg_version_1) = dwg->header.dwg_version;\n            FIELD_VALUE (dwg_version_2) = dwg->header.dwg_version;\n            FIELD_VALUE (maint_version_1) = dwg->header.maint_version;\n            FIELD_VALUE (maint_version_2) = dwg->header.maint_version;\n            memcpy (FIELD_VALUE (unknown_rs), tmpunknown, sizeof (tmpunknown));\n            FIELD_VALUE (TDCREATE) = dwg->header_vars.TDCREATE.value;\n            FIELD_VALUE (TDUPDATE) = dwg->header_vars.TDUPDATE.value;\n            if (dwg->header_vars.HANDSEED)\n              FIELD_VALUE (HANDSEED) = dwg->header_vars.HANDSEED->absolute_ref;\n          }\n\n          // clang-format off\n        #include \"auxheader.spec\"\n        // clang-format on\n\n        assert (!dat->bit);\n        dwg->header.section[SECTION_AUXHEADER_R2000].size\n            = dat->byte - dwg->header.section[SECTION_AUXHEADER_R2000].address;\n      }\n  }\n\n  VERSION (R_2007)\n  {\n    LOG_ERROR (WE_CAN \"We don't encode R2007 sections yet\")\n    return DWG_ERR_NOTYETSUPPORTED;\n  }\n\n  /* r2004 file header (compressed + encrypted) */\n  SINCE (R_2004)\n  {\n    /* System Section */\n    typedef union _system_section\n    {\n      unsigned char data[0x14]; // 20byte: 5*4\n      struct\n      {\n        uint32_t section_type; /* 0x4163043b */\n        uint32_t decomp_data_size;\n        uint32_t comp_data_size;\n        uint32_t compression_type;\n        uint32_t checksum; // see section_page_checksum\n      } fields;\n    } system_section;\n\n    system_section ss;\n    Dwg_Section *section;\n\n    Dwg_Object *obj = NULL;\n    struct Dwg_R2004_Header *_obj = &dwg->r2004_header;\n    const int size = sizeof (struct Dwg_R2004_Header);\n    char encrypted_data[size];\n    unsigned int rseed = 1;\n    uint32_t checksum;\n\n    LOG_ERROR (WE_CAN \"We don't encode the R2004_section_map yet\")\n\n    if (dwg->header.section_infohdr.num_desc && !dwg->header.section_info)\n      dwg->header.section_info = calloc (dwg->header.section_infohdr.num_desc,\n                                         sizeof (Dwg_Section_Info));\n\n    dat->byte = 0x80;\n    for (i = 0; i < (BITCODE_BL)size; i++)\n      {\n        rseed *= 0x343fd;\n        rseed += 0x269ec3;\n        encrypted_data[i] = bit_read_RC (dat) ^ (rseed >> 0x10);\n      }\n    LOG_TRACE (\"\\n#### Write 2004 File Header ####\\n\");\n    dat->byte = 0x80;\n    if (dat->byte + 0x80 >= dat->size - 1)\n      {\n        dat->size = dat->byte + 0x80;\n        bit_chain_alloc (dat);\n      }\n    memcpy (&dat->chain[0x80], encrypted_data, size);\n    LOG_INFO (\"@0x%lx\\n\", dat->byte);\n\n    // clang-format off\n    #include \"r2004_file_header.spec\"\n    // clang-format on\n\n    dwg->r2004_header.checksum = 0;\n    dwg->r2004_header.checksum = dwg_section_page_checksum (0, dat, size);\n\n    /*-------------------------------------------------------------------------\n     * Section Page Map\n     */\n    dat->byte = dwg->r2004_header.section_map_address + 0x100;\n\n    LOG_TRACE (\"\\n=== Write System Section (Section Page Map) ===\\n\");\n#ifndef HAVE_COMPRESS_R2004_SECTION\n    dwg->r2004_header.comp_data_size = dwg->r2004_header.decomp_data_size;\n    dwg->r2004_header.compression_type = 0;\n#endif\n    FIELD_RL (section_type, 0); // should be 0x4163043b\n    FIELD_RL (decomp_data_size, 0);\n    FIELD_RL (comp_data_size, 0);\n    FIELD_RL (compression_type, 0);\n    dwg_section_page_checksum (dwg->r2004_header.checksum, dat, size);\n    FIELD_RL (checksum, 0);\n    LOG_TRACE (\"\\n\")\n\n    LOG_WARN (\"TODO write_R2004_section_map(dat, dwg)\")\n    LOG_TRACE (\"\\n\")\n\n    return DWG_ERR_NOTYETSUPPORTED;\n  }\n\n  /*------------------------------------------------------------\n   * THUMBNAIL preview pictures\n   */\n  if (!dwg->header.thumbnail_address)\n    dwg->header.thumbnail_address = dat->byte;\n  dat->bit = 0;\n  LOG_TRACE (\"\\n=======> Thumbnail:       %4u\\n\", (unsigned)dat->byte);\n  // dwg->thumbnail.size = 0; // to disable\n  bit_write_sentinel (dat, dwg_sentinel (DWG_SENTINEL_THUMBNAIL_BEGIN));\n  if (dwg->thumbnail.size == 0)\n    {\n      bit_write_RL (dat, 5); // overall size\n      LOG_TRACE (\"Thumbnail size: 5 [RL]\\n\");\n      bit_write_RC (dat, 0); // num_pictures\n      LOG_TRACE (\"Thumbnail num_pictures: 0 [RC]\\n\");\n    }\n  else\n    {\n      bit_write_TF (dat, (char *)dwg->thumbnail.chain, dwg->thumbnail.size);\n    }\n  bit_write_sentinel (dat, dwg_sentinel (DWG_SENTINEL_THUMBNAIL_END));\n\n  {\n    BITCODE_RL size;\n    dwg_bmp (dwg, &size);\n    if (size > dwg->thumbnail.size)\n      LOG_ERROR (\"BMP size overflow: %i > %lu\\n\", size, dwg->thumbnail.size);\n  }\n  LOG_TRACE (\"         Thumbnail (end): %4u\\n\", (unsigned)dat->byte);\n\n  /*------------------------------------------------------------\n   * Header Variables\n   */\n  assert (!dat->bit);\n  LOG_INFO (\"\\n=======> Header Variables:   %4u\\n\", (unsigned)dat->byte);\n  dwg->header.section[0].number = 0;\n  dwg->header.section[0].address = dat->byte;\n  bit_write_sentinel (dat, dwg_sentinel (DWG_SENTINEL_VARIABLE_BEGIN));\n\n  pvzadr = dat->byte;      // Size position\n  bit_write_RL (dat, 540); // Size placeholder\n  // if (dat->version >= R_2007)\n  //  str_dat = dat;\n  dwg_encode_header_variables (dat, hdl_dat, dat, dwg);\n  encode_patch_RLsize (dat, pvzadr);\n  bit_write_CRC (dat, pvzadr, 0xC0C1);\n\n  // XXX trying to fix CRC 2-byte overflow. Must find actual reason\n  // dat->byte -= 2;\n  bit_write_sentinel (dat, dwg_sentinel (DWG_SENTINEL_VARIABLE_END));\n  assert ((long)dat->byte > (long)dwg->header.section[0].address);\n  dwg->header.section[0].size\n      = (BITCODE_RL) ((long)dat->byte - (long)dwg->header.section[0].address);\n  LOG_TRACE (\"         Header Variables (end): %4u\\n\", (unsigned)dat->byte);\n\n  /*------------------------------------------------------------\n   * Classes\n   */\n  LOG_INFO (\"\\n=======> Classes: %4u (%d)\\n\", (unsigned)dat->byte, dwg->num_classes);\n  dwg->header.section[SECTION_CLASSES_R13].number = 1;\n  dwg->header.section[SECTION_CLASSES_R13].address = dat->byte;\n  bit_write_sentinel (dat, dwg_sentinel (DWG_SENTINEL_CLASS_BEGIN));\n  pvzadr = dat->byte;    // Size position\n  bit_write_RL (dat, 0); // Size placeholder\n\n  for (j = 0; j < dwg->num_classes; j++)\n    {\n      Dwg_Class *klass;\n      klass = &dwg->dwg_class[j];\n      bit_write_BS (dat, klass->number);\n      bit_write_BS (dat, klass->proxyflag);\n      bit_write_TV (dat, klass->appname);\n      bit_write_TV (dat, klass->cppname);\n      bit_write_TV (dat, klass->dxfname);\n      bit_write_B (dat, klass->wasazombie);\n      bit_write_BS (dat, klass->item_class_id);\n      LOG_TRACE (\"Class %d 0x%x %s\\n\"\n                 \" %s \\\"%s\\\" %d 0x%x\\n\",\n                 klass->number, klass->proxyflag, klass->dxfname,\n                 klass->cppname, klass->appname, klass->wasazombie,\n                 klass->item_class_id)\n\n      SINCE (R_2007)\n      {\n        bit_write_BL (dat, klass->num_instances);\n        bit_write_BL (dat, klass->dwg_version);\n        bit_write_BL (dat, klass->maint_version);\n        bit_write_BL (dat, klass->unknown_1);\n        bit_write_BL (dat, klass->unknown_2);\n        LOG_TRACE (\" %d %d\\n\", (int)klass->num_instances,\n                   (int)klass->dwg_version);\n      }\n    }\n\n  /* Write the size of the section at its beginning\n   */\n  assert (pvzadr);\n  encode_patch_RLsize (dat, pvzadr);\n  bit_write_CRC (dat, pvzadr, 0xC0C1);\n  bit_write_sentinel (dat, dwg_sentinel (DWG_SENTINEL_CLASS_END));\n  dwg->header.section[SECTION_CLASSES_R13].size\n      = dat->byte - dwg->header.section[SECTION_CLASSES_R13].address;\n  LOG_TRACE (\"       Classes (end): %4u\\n\", (unsigned)dat->byte);\n\n  bit_write_RL (dat, 0x0DCA); // 0xDCA Unknown bitlong inter class and objects\n  LOG_TRACE (\"unknown: %04X [RL]\\n\", 0x0DCA);\n\n  /*------------------------------------------------------------\n   * Objects\n   */\n\n  LOG_INFO (\"\\n=======> Objects: %4u\\n\", (unsigned)dat->byte);\n  pvzadr = dat->byte;\n\n  /* Sort object-map by ascending handles\n   */\n  LOG_TRACE (\"num_objects: %i\\n\", dwg->num_objects);\n  LOG_TRACE (\"num_object_refs: %i\\n\", dwg->num_object_refs);\n  omap = (Object_Map *)calloc (dwg->num_objects, sizeof (Object_Map));\n  if (!omap)\n    {\n      LOG_ERROR (\"Out of memory\");\n      return DWG_ERR_OUTOFMEM;\n    }\n  if (DWG_LOGLEVEL >= DWG_LOGLEVEL_HANDLE)\n    {\n      LOG_HANDLE (\"\\nSorting objects...\\n\");\n      for (i = 0; i < dwg->num_objects; i++)\n        fprintf (OUTPUT, \"Object(%3i): %4lX / idx: %u\\n\", i,\n                 dwg->object[i].handle.value, dwg->object[i].index);\n    }\n  // init unsorted\n  for (i = 0; i < dwg->num_objects; i++)\n    {\n      omap[i].index = i; // i.e. dwg->object[j].index\n      omap[i].handle = dwg->object[i].handle.value;\n    }\n  // insertion sort\n  for (i = 0; i < dwg->num_objects; i++)\n    {\n      Object_Map tmap;\n      j = i;\n      tmap = omap[i];\n      while (j > 0 && omap[j - 1].handle > tmap.handle)\n        {\n          omap[j] = omap[j - 1];\n          j--;\n        }\n      omap[j] = tmap;\n    }\n  if (DWG_LOGLEVEL >= DWG_LOGLEVEL_HANDLE)\n    {\n      LOG_HANDLE (\"\\nSorted handles:\\n\");\n      for (i = 0; i < dwg->num_objects; i++)\n        fprintf (OUTPUT, \"Handle(%3i): %4lX / idx: %u\\n\", i, omap[i].handle,\n                 omap[i].index);\n    }\n\n  /* Write the sorted objects\n   */\n  for (i = 0; i < dwg->num_objects; i++)\n    {\n      Dwg_Object *obj;\n      BITCODE_BL index = omap[i].index;\n      unsigned long hdloff = omap[i].handle - (i ? omap[i - 1].handle : 0);\n      int off = dat->byte - (i ? omap[i - 1].address : 0);\n      unsigned long address, end_address;\n      LOG_TRACE (\"\\n> Next object: \" FORMAT_BL\n                 \" Handleoff: %lX [UMC] Offset: %d [MC] @%lu\\n\"\n                 \"==========================================\\n\",\n                 i, hdloff, off, dat->byte);\n      omap[i].address = dat->byte;\n      if (index > dwg->num_objects)\n        {\n          LOG_ERROR (\"Invalid object map index \" FORMAT_BL \", max \" FORMAT_BL\n                     \". Skipping\",\n                     index, dwg->num_objects)\n          error |= DWG_ERR_VALUEOUTOFBOUNDS;\n          continue;\n        }\n      obj = &dwg->object[index];\n      // change the address to the linearly sorted one\n      assert (dat->byte);\n      error |= dwg_encode_add_object (obj, dat, dat->byte);\n\n#ifndef NDEBUG\n      // check if this object overwrote at address 0\n      if (dwg->header.version >= R_1_2)\n        {\n          assert (dat->chain[0] == 'A');\n          assert (dat->chain[1] == 'C');\n        }\n#endif\n      end_address = omap[i].address + (unsigned long)obj->size; // from RL\n      if (end_address > dat->size)\n        {\n          dat->size = end_address;\n          bit_chain_alloc (dat);\n        }\n    }\n\n  if (DWG_LOGLEVEL >= DWG_LOGLEVEL_HANDLE)\n    {\n      LOG_HANDLE (\"\\nSorted objects:\\n\");\n      for (i = 0; i < dwg->num_objects; i++)\n        LOG_HANDLE (\"Object(%d): %lX / Address: %ld / Idx: %d\\n\", i,\n                    omap[i].handle, omap[i].address, omap[i].index);\n    }\n\n  /* Unknown CRC between objects and object map\n   */\n  bit_write_RS (dat, 0);\n  LOG_TRACE (\"unknown crc?: %04X [RS]\\n\", 0);\n\n  /*------------------------------------------------------------\n   * Object-map\n   * split into chunks of max. 2030\n   */\n  LOG_INFO (\"\\n=======> Object Map: %4u\\n\", (unsigned)dat->byte);\n  dwg->header.section[SECTION_HANDLES_R13].number = 2;\n  dwg->header.section[SECTION_HANDLES_R13].address = dat->byte;\n\n  sec_size = 0;\n  pvzadr = dat->byte; // Correct value of section size must be written later\n  dat->byte += 2;\n  last_offset = 0;\n  last_handle = 0;\n  for (i = 0; i < dwg->num_objects; i++)\n    {\n      BITCODE_BL index;\n      BITCODE_UMC handleoff;\n      BITCODE_MC offset;\n\n      index = omap[i].index;\n      handleoff = omap[i].handle - last_handle;\n      bit_write_UMC (dat, handleoff);\n      LOG_HANDLE (\"Handleoff(%3i): %4lX [UMC] (%4lX), \", index, handleoff,\n                  omap[i].handle)\n      last_handle = omap[i].handle;\n\n      offset = omap[i].address - last_offset;\n      bit_write_MC (dat, offset);\n      last_offset = omap[i].address;\n      LOG_HANDLE (\"Offset: %8d [MC] @%lu\\n\", (int)offset, last_offset);\n\n      ckr_missing = 1;\n      if (dat->byte - pvzadr > 2030) // 2029\n        {\n          ckr_missing = 0;\n          sec_size = dat->byte - pvzadr;\n          assert (pvzadr);\n          // i.e. encode_patch_RS_LE_size\n          dat->chain[pvzadr] = sec_size >> 8;\n          dat->chain[pvzadr + 1] = sec_size & 0xFF;\n          LOG_TRACE (\"Handles page size: %u [RS_LE] @%lu\\n\", sec_size, pvzadr);\n          bit_write_CRC_LE (dat, pvzadr, 0xC0C1);\n\n          pvzadr = dat->byte;\n          dat->byte += 2;\n          last_offset = 0;\n          last_handle = 0;\n        }\n    }\n  // printf (\"Obj size: %u\\n\", i);\n  if (ckr_missing)\n    {\n      sec_size = dat->byte - pvzadr;\n      assert (pvzadr);\n      // i.e. encode_patch_RS_LE_size\n      dat->chain[pvzadr] = sec_size >> 8;\n      dat->chain[pvzadr + 1] = sec_size & 0xFF;\n      LOG_TRACE (\"Handles page size: %u [RS_LE] @%lu\\n\", sec_size, pvzadr);\n      bit_write_CRC_LE (dat, pvzadr, 0xC0C1);\n    }\n  if (dwg->header.version >= R_1_2)\n    {\n      assert (dat->chain[0] == 'A');\n      assert (dat->chain[1] == 'C');\n    }\n  pvzadr = dat->byte;\n  assert (pvzadr);\n  bit_write_RS_LE (dat, 2); // last section_size 2\n  LOG_TRACE (\"Handles page size: %u [RS_LE] @%lu\\n\", 2, pvzadr);\n  bit_write_CRC_LE (dat, pvzadr, 0xC0C1);\n\n  /* Calculate and write the size of the object map\n   */\n  dwg->header.section[SECTION_HANDLES_R13].size\n      = dat->byte - dwg->header.section[SECTION_HANDLES_R13].address;\n  free (omap);\n\n  /*------------------------------------------------------------\n   * Second header, section 3. R13-R2000 only.\n   * But partially also since r2004.\n   */\n  if (dwg->header.version >= R_13 && dwg->second_header.num_sections > 3)\n    {\n      struct _dwg_second_header *_obj = &dwg->second_header;\n      Dwg_Object *obj = NULL;\n      BITCODE_BL vcount;\n\n      assert (dat->byte);\n      if (!_obj->address)\n        _obj->address = dat->byte;\n      dwg->header.section[SECTION_2NDHEADER_R13].number = 3;\n      dwg->header.section[SECTION_2NDHEADER_R13].address = _obj->address;\n      dwg->header.section[SECTION_2NDHEADER_R13].size = _obj->size;\n      LOG_INFO (\"\\n=======> Second Header: %4u\\n\", (unsigned)dat->byte);\n      bit_write_sentinel (dat, dwg_sentinel (DWG_SENTINEL_SECOND_HEADER_BEGIN));\n\n      pvzadr = dat->byte; // Keep the first address of the section to write its\n                          // size later\n      LOG_TRACE (\"pvzadr: %lx\\n\", pvzadr);\n      if (!_obj->size && !_obj->num_sections)\n        {\n          LOG_TRACE (\"Use second_header defaults...\\n\");\n          strcpy ((char *)&_obj->version[0],\n                  &version_codes[dwg->header.version][0]);\n          memset (&_obj->version[7], 0, 4);\n          _obj->version[11] = '\\n';\n          _obj->unknown_10 = 0x10;\n          _obj->unknown_rc4[0] = 0x84;\n          _obj->unknown_rc4[1] = 0x74;\n          _obj->unknown_rc4[2] = 0x78;\n          _obj->unknown_rc4[3] = 0x1;\n          if (dwg->header.version <= R_2000)\n            {\n              _obj->num_sections = dwg->header.num_sections;\n              for (i = 0; i < _obj->num_sections; i++)\n                {\n                  _obj->section[i].nr = dwg->header.section[i].number;\n                  _obj->section[i].address = dwg->header.section[i].address;\n                  _obj->section[i].size = dwg->header.section[i].size;\n                }\n              // TODO handlers\n            }\n          _obj->junk_r14_1 = 1957593121; //?\n          _obj->junk_r14_2 = 2559919056; //?\n        }\n\n      FIELD_RL (size, 0);\n      if (FIELD_VALUE (address) != (BITCODE_RL) (pvzadr - 16))\n        {\n          LOG_WARN (\"second_header->address %x != %x\", FIELD_VALUE (address),\n                    (unsigned)(pvzadr - 16));\n          FIELD_VALUE (address) = pvzadr - 16;\n        }\n      FIELD_BLx (address, 0);\n\n      // AC1012, AC1014 or AC1015. This is a char[11], zero padded.\n      // with \\n at 12.\n      bit_write_TF (dat, (char *)_obj->version, 12);\n      LOG_TRACE (\"version: %s [TFF 12]\\n\", _obj->version)\n\n      for (i = 0; i < 4; i++)\n        FIELD_B (null_b[i], 0);\n      FIELD_RC (unknown_10, 0); // 0x10\n      for (i = 0; i < 4; i++)\n        FIELD_RC (unknown_rc4[i], 0);\n\n      UNTIL (R_2000)\n      {\n        FIELD_RC (num_sections, 0); // r14: 5, r2000: 6 (auxheader)\n        for (i = 0; i < FIELD_VALUE (num_sections); i++)\n          {\n            FIELD_RC (section[i].nr, 0);\n            FIELD_BLx (section[i].address, 0);\n            FIELD_BLd (section[i].size, 0);\n          }\n\n        FIELD_BS (num_handlers, 0); // 14, resp. 16 in r14\n        if (FIELD_VALUE (num_handlers) > 16)\n          {\n            LOG_ERROR (\"Second header num_handlers > 16: %d\\n\",\n                       FIELD_VALUE (num_handlers));\n            FIELD_VALUE (num_handlers) = 14;\n          }\n        for (i = 0; i < FIELD_VALUE (num_handlers); i++)\n          {\n            FIELD_RC (handlers[i].size, 0);\n            FIELD_RC (handlers[i].nr, 0);\n            FIELD_VECTOR (handlers[i].data, RC, handlers[i].size, 0);\n          }\n\n        _obj->size = encode_patch_RLsize (dat, pvzadr);\n        bit_write_CRC (dat, pvzadr, 0xC0C1);\n\n        VERSION (R_14)\n        {\n          FIELD_RL (junk_r14_1, 0);\n          FIELD_RL (junk_r14_2, 0);\n        }\n      }\n      bit_write_sentinel (dat, dwg_sentinel (DWG_SENTINEL_SECOND_HEADER_END));\n      dwg->header.section[SECTION_2NDHEADER_R13].size\n          = dat->byte - _obj->address;\n    }\n  else if (dwg->header.num_sections > SECTION_2NDHEADER_R13)\n    {\n      dwg->header.section[SECTION_2NDHEADER_R13].number = 3;\n      dwg->header.section[SECTION_2NDHEADER_R13].address = 0;\n      dwg->header.section[SECTION_2NDHEADER_R13].size = 0;\n    }\n\n  /*------------------------------------------------------------\n   * MEASUREMENT Section 4\n   * In a DXF under header_vars\n   */\n  if (dwg->header.num_sections > SECTION_MEASUREMENT_R13)\n    {\n      LOG_INFO (\"\\n=======> MEASUREMENT: %4u\\n\", (unsigned)dat->byte);\n      dwg->header.section[SECTION_MEASUREMENT_R13].number = 4;\n      dwg->header.section[SECTION_MEASUREMENT_R13].address = dat->byte;\n      dwg->header.section[SECTION_MEASUREMENT_R13].size = 4;\n      // 0 - English, 1- Metric\n      bit_write_RL (dat, (BITCODE_RL)dwg->header_vars.MEASUREMENT);\n      LOG_TRACE (\"HEADER.MEASUREMENT: %d [RL]\\n\", dwg->header_vars.MEASUREMENT);\n    }\n\n  /* End of the file\n   */\n  dat->size = dat->byte;\n\n  /* Write section addresses\n   */\n  assert (section_address);\n  dat->byte = section_address;\n  dat->bit = 0;\n  LOG_INFO (\"\\n=======> section addresses: %4u\\n\", (unsigned)dat->byte);\n  for (j = 0; j < dwg->header.num_sections; j++)\n    {\n      bit_write_RC (dat, dwg->header.section[j].number);\n      bit_write_RL (dat, dwg->header.section[j].address);\n      bit_write_RL (dat, dwg->header.section[j].size);\n      LOG_TRACE (\"section[%u].number: %2d [RC]\\n\", j,\n                 (int)dwg->header.section[j].number)\n      LOG_TRACE (\"section[%u].offset: 0x%x [RLx]\\n\", j,\n                 (unsigned)dwg->header.section[j].address)\n      LOG_TRACE (\"section[%u].size: %4d [RL]\\n\", j,\n                 (int)dwg->header.section[j].size)\n    }\n\n  /* Write CRC's\n   */\n  bit_write_CRC (dat, 0, 0);\n  dat->byte -= 2;\n  ckr = bit_read_CRC (dat);\n  dat->byte -= 2;\n  switch (dwg->header.num_sections)\n    {\n    case 3:\n      ckr ^= 0xA598;\n      break;\n    case 4:\n      ckr ^= 0x8101;\n      break;\n    case 5:\n      ckr ^= 0x3CC4;\n      break;\n    case 6:\n      ckr ^= 0x8461;\n      break;\n    default:\n      break;\n    }\n  bit_write_RS (dat, ckr);\n  LOG_TRACE (\"crc: %04X (from 0)\\n\", ckr);\n\n  return 0;\n}\n\nstatic int\nencode_preR13 (Dwg_Data *restrict dwg, Bit_Chain *restrict dat)\n{\n  return DWG_ERR_NOTYETSUPPORTED;\n}\n\n// needed for r2004+ encode and decode (check-only) (unused)\n// p 4.3: first calc with seed 0, then compress, then recalc with prev.\n// checksum\nuint32_t\ndwg_section_page_checksum (const uint32_t seed, Bit_Chain *restrict dat, uint32_t size)\n{\n  uint32_t sum1 = seed & 0xffff;\n  uint32_t sum2 = seed >> 0x10;\n  unsigned char *data = &(dat->chain[dat->byte]);\n\n  while (size)\n    {\n      uint32_t i;\n      uint32_t chunksize = size < 0x15b0 ? size : 0x15b0;\n      size -= chunksize;\n      for (i = 0; i < chunksize; i++)\n        {\n          sum1 += *data++;\n          sum2 += sum1;\n        }\n      sum1 %= 0xFFF1;\n      sum2 %= 0xFFF1;\n    }\n  return (sum2 << 0x10) | (sum1 & 0xffff);\n}\n\n#include \"dwg.spec\"\n\n// expand aliases: name => CLASSES.dxfname\nstatic const char *\ndxf_encode_alias (char *restrict name)\n{\n  if (strEQc (name, \"DICTIONARYWDFLT\"))\n    return \"ACDBDICTIONARYWDFLT\";\n  else if (strEQc (name, \"SECTIONVIEWSTYLE\"))\n    return \"ACDBSECTIONVIEWSTYLE\";\n  else if (strEQc (name, \"PLACEHOLDER\"))\n    return \"ACDBPLACEHOLDER\";\n  else if (strEQc (name, \"DETAILVIEWSTYLE\"))\n    return \"ACDBDETAILVIEWSTYLE\";\n  else if (strEQc (name, \"ASSOCPERSSUBENTMANAGER\"))\n    return \"ACDBASSOCPERSSUBENTMANAGER\";\n  else if (strEQc (name, \"EVALUATION_GRAPH\"))\n    return \"ACAD_EVALUATION_GRAPH\";\n  else if (strEQc (name, \"ASSOCACTION\"))\n    return \"ACDBASSOCACTION\";\n  else if (strEQc (name, \"ASSOCALIGNEDDIMACTIONBODY\"))\n    return \"ACDBASSOCALIGNEDDIMACTIONBODY\";\n  else if (strEQc (name, \"ASSOCOSNAPPOINTREFACTIONPARAM\"))\n    return \"ACDBASSOCOSNAPPOINTREFACTIONPARAM\";\n  else if (strEQc (name, \"ASSOCVERTEXACTIONPARAM\"))\n    return \"ACDBASSOCVERTEXACTIONPARAM\";\n  else if (strEQc (name, \"ASSOCGEOMDEPENDENCY\"))\n    return \"ACDBASSOCGEOMDEPENDENCY\";\n  else if (strEQc (name, \"ASSOCDEPENDENCY\"))\n    return \"ACDBASSOCDEPENDENCY\";\n  else if (strEQc (name, \"TABLE\"))\n    return \"ACAD_TABLE\";\n  else\n    return NULL;\n}\n\nDwg_Class *\ndwg_encode_get_class (Dwg_Data *dwg, Dwg_Object *obj)\n{\n  int i;\n  Dwg_Class *klass = NULL;\n  // indxf has a different class order\n  if (obj->dxfname) // search class by name, not offset\n    {\n      int invalid_klass = 0;\n      for (i = 0; i < dwg->num_classes; i++)\n        {\n          klass = &dwg->dwg_class[i];\n          if (!klass->dxfname)\n            {\n              invalid_klass++;\n              continue;\n            }\n          if (strEQ (obj->dxfname, klass->dxfname))\n            {\n              obj->type = 500 + i;\n              break;\n            }\n          else\n            {\n              // alias DICTIONARYWDFLT => ACDBDICTIONARYWDFLT\n              const char *alias = dxf_encode_alias (obj->dxfname);\n              if (alias && klass->dxfname && strEQ (alias, klass->dxfname))\n                {\n                  obj->dxfname = (char *)alias;\n                  obj->type = 500 + i;\n                  break;\n                }\n              klass = NULL; // inefficient\n\n              if (invalid_klass > 2 && !(dwg->opts & DWG_OPTS_INDXF))\n                goto search_by_index;\n            }\n        }\n    }\n  else // search by index\n    {\n    search_by_index:\n      i = obj->type - 500;\n      if (i < 0 || i >= (int)dwg->num_classes)\n        {\n          LOG_WARN (\"Invalid object type %d, only %u classes\", obj->type,\n                    dwg->num_classes);\n          return NULL;\n        }\n\n      klass = &dwg->dwg_class[i];\n      if (!klass || !klass->dxfname)\n        return NULL;\n      obj->dxfname = klass->dxfname;\n    }\n  return klass;\n}\n\n/** dwg_encode_variable_type\n * Encode object by class name, not type. if type > 500.\n * Returns 0 on success, else some Dwg_Error.\n */\nstatic int\ndwg_encode_variable_type (Dwg_Data *restrict dwg, Bit_Chain *restrict dat, Dwg_Object *restrict obj)\n{\n  int error = 0;\n  int is_entity;\n  unsigned long pos;\n  Dwg_Class *klass = dwg_encode_get_class (dwg, obj);\n\n  if (!klass)\n    return DWG_ERR_INTERNALERROR;\n  is_entity = dwg_class_is_entity (klass);\n\n  if (dwg->opts & DWG_OPTS_INDXF) // DXF import\n    {\n      pos = bit_position (dat);\n      dat->byte = obj->address;\n      dat->bit = 0;\n      LOG_TRACE (\"fixup Type: %d [BS] @%lu\\n\", obj->type, obj->address);\n      bit_write_BS (dat, obj->type); // fixup wrong type\n      bit_set_position (dat, pos);\n    }\n\n  // clang-format off\n  #include \"classes.inc\"\n  // clang-format on\n\n  LOG_WARN (\"Unknown Class %s %d %s (0x%x%s)\", is_entity ? \"entity\" : \"object\",\n            klass->number, klass->dxfname, klass->proxyflag,\n            klass->wasazombie ? \" was proxy\" : \"\")\n\n#undef WARN_UNHANDLED_CLASS\n#undef WARN_UNSTABLE_CLASS\n\n  return DWG_ERR_UNHANDLEDCLASS;\n}\n\nint\ndwg_encode_add_object (Dwg_Object *restrict obj, Bit_Chain *restrict dat,\n                       unsigned long address)\n{\n  int error = 0;\n  unsigned long oldpos;\n  unsigned long end_address = address + obj->size;\n\n  oldpos = bit_position (dat);\n  assert (address);\n  dat->byte = address;\n  dat->bit = 0;\n\n  LOG_INFO (\"Object number: %lu\", (unsigned long)obj->index);\n  if (obj->size > 0x100000)\n    {\n      LOG_ERROR (\"Object size %u overflow\", obj->size);\n      return DWG_ERR_VALUEOUTOFBOUNDS;\n    }\n  while (dat->byte + obj->size >= dat->size)\n    bit_chain_alloc (dat);\n\n  // TODO: calculate size from the fields. either <0x7fff or more\n  // patch it afterwards and check old<>new size if enough space allocated.\n  bit_write_MS (dat, obj->size);\n  obj->address = dat->byte;\n  PRE (R_2010) {\n    bit_write_BS (dat, obj->type);\n    LOG_INFO (\", Size: %d [MS], Type: %d [BS]\\n\", obj->size, obj->type)\n  }\n  LATER_VERSIONS\n  {\n    if (!obj->handlestream_size && obj->bitsize)\n      obj->handlestream_size = obj->size * 8 - obj->bitsize;\n    bit_write_UMC (dat, obj->handlestream_size);\n    obj->address = dat->byte;\n    bit_write_BOT (dat, obj->type);\n    LOG_INFO (\", Size: %d [MS], Hdlsize: %lu [UMC], Type: %d [BOT]\\n\",\n              obj->size, (unsigned long)obj->handlestream_size, obj->type)\n  }\n\n  /* Write the specific type to dat */\n  switch (obj->type)\n    {\n    case DWG_TYPE_TEXT:\n      error = dwg_encode_TEXT (dat, obj);\n      break;\n    case DWG_TYPE_ATTRIB:\n      error = dwg_encode_ATTRIB (dat, obj);\n      break;\n    case DWG_TYPE_ATTDEF:\n      error = dwg_encode_ATTDEF (dat, obj);\n      break;\n    case DWG_TYPE_BLOCK:\n      error = dwg_encode_BLOCK (dat, obj);\n      break;\n    case DWG_TYPE_ENDBLK:\n      error = dwg_encode_ENDBLK (dat, obj);\n      break;\n    case DWG_TYPE_SEQEND:\n      error = dwg_encode_SEQEND (dat, obj);\n      break;\n    case DWG_TYPE_INSERT:\n      error = dwg_encode_INSERT (dat, obj);\n      break;\n    case DWG_TYPE_MINSERT:\n      error = dwg_encode_MINSERT (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_2D:\n      error = dwg_encode_VERTEX_2D (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_3D:\n      error = dwg_encode_VERTEX_3D (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_MESH:\n      error = dwg_encode_VERTEX_MESH (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_PFACE:\n      error = dwg_encode_VERTEX_PFACE (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_PFACE_FACE:\n      error = dwg_encode_VERTEX_PFACE_FACE (dat, obj);\n      break;\n    case DWG_TYPE_POLYLINE_2D:\n      error = dwg_encode_POLYLINE_2D (dat, obj);\n      break;\n    case DWG_TYPE_POLYLINE_3D:\n      error = dwg_encode_POLYLINE_3D (dat, obj);\n      break;\n    case DWG_TYPE_ARC:\n      error = dwg_encode_ARC (dat, obj);\n      break;\n    case DWG_TYPE_CIRCLE:\n      error = dwg_encode_CIRCLE (dat, obj);\n      break;\n    case DWG_TYPE_LINE:\n      error = dwg_encode_LINE (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_ORDINATE:\n      error = dwg_encode_DIMENSION_ORDINATE (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_LINEAR:\n      error = dwg_encode_DIMENSION_LINEAR (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_ALIGNED:\n      error = dwg_encode_DIMENSION_ALIGNED (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_ANG3PT:\n      error = dwg_encode_DIMENSION_ANG3PT (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_ANG2LN:\n      error = dwg_encode_DIMENSION_ANG2LN (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_RADIUS:\n      error = dwg_encode_DIMENSION_RADIUS (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_DIAMETER:\n      error = dwg_encode_DIMENSION_DIAMETER (dat, obj);\n      break;\n    case DWG_TYPE_POINT:\n      error = dwg_encode_POINT (dat, obj);\n      break;\n    case DWG_TYPE__3DFACE:\n      error = dwg_encode__3DFACE (dat, obj);\n      break;\n    case DWG_TYPE_POLYLINE_PFACE:\n      error = dwg_encode_POLYLINE_PFACE (dat, obj);\n      break;\n    case DWG_TYPE_POLYLINE_MESH:\n      error = dwg_encode_POLYLINE_MESH (dat, obj);\n      break;\n    case DWG_TYPE_SOLID:\n      error = dwg_encode_SOLID (dat, obj);\n      break;\n    case DWG_TYPE_TRACE:\n      error = dwg_encode_TRACE (dat, obj);\n      break;\n    case DWG_TYPE_SHAPE:\n      error = dwg_encode_SHAPE (dat, obj);\n      break;\n    case DWG_TYPE_VIEWPORT:\n      error = dwg_encode_VIEWPORT (dat, obj);\n      break;\n    case DWG_TYPE_ELLIPSE:\n      error = dwg_encode_ELLIPSE (dat, obj);\n      break;\n    case DWG_TYPE_SPLINE:\n      error = dwg_encode_SPLINE (dat, obj);\n      break;\n    case DWG_TYPE_REGION:\n      error = dwg_encode_REGION (dat, obj);\n      break;\n    case DWG_TYPE__3DSOLID:\n      error = dwg_encode__3DSOLID (dat, obj);\n      break;\n    case DWG_TYPE_BODY:\n      error = dwg_encode_BODY (dat, obj);\n      break;\n    case DWG_TYPE_RAY:\n      error = dwg_encode_RAY (dat, obj);\n      break;\n    case DWG_TYPE_XLINE:\n      error = dwg_encode_XLINE (dat, obj);\n      break;\n    case DWG_TYPE_DICTIONARY:\n      error = dwg_encode_DICTIONARY (dat, obj);\n      break;\n    case DWG_TYPE_MTEXT:\n      error = dwg_encode_MTEXT (dat, obj);\n      break;\n    case DWG_TYPE_LEADER:\n      error = dwg_encode_LEADER (dat, obj);\n      break;\n    case DWG_TYPE_TOLERANCE:\n      error = dwg_encode_TOLERANCE (dat, obj);\n      break;\n    case DWG_TYPE_MLINE:\n      error = dwg_encode_MLINE (dat, obj);\n      break;\n    case DWG_TYPE_BLOCK_CONTROL:\n      error = dwg_encode_BLOCK_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_BLOCK_HEADER:\n      error = dwg_encode_BLOCK_HEADER (dat, obj);\n      break;\n    case DWG_TYPE_LAYER_CONTROL:\n      error = dwg_encode_LAYER_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_LAYER:\n      error = dwg_encode_LAYER (dat, obj);\n      break;\n    case DWG_TYPE_STYLE_CONTROL:\n      error = dwg_encode_STYLE_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_STYLE:\n      error = dwg_encode_STYLE (dat, obj);\n      break;\n    case DWG_TYPE_LTYPE_CONTROL:\n      error = dwg_encode_LTYPE_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_LTYPE:\n      error = dwg_encode_LTYPE (dat, obj);\n      break;\n    case DWG_TYPE_VIEW_CONTROL:\n      error = dwg_encode_VIEW_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_VIEW:\n      error = dwg_encode_VIEW (dat, obj);\n      break;\n    case DWG_TYPE_UCS_CONTROL:\n      error = dwg_encode_UCS_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_UCS:\n      error = dwg_encode_UCS (dat, obj);\n      break;\n    case DWG_TYPE_VPORT_CONTROL:\n      error = dwg_encode_VPORT_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_VPORT:\n      error = dwg_encode_VPORT (dat, obj);\n      break;\n    case DWG_TYPE_APPID_CONTROL:\n      error = dwg_encode_APPID_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_APPID:\n      error = dwg_encode_APPID (dat, obj);\n      break;\n    case DWG_TYPE_DIMSTYLE_CONTROL:\n      error = dwg_encode_DIMSTYLE_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_DIMSTYLE:\n      error = dwg_encode_DIMSTYLE (dat, obj);\n      break;\n    case DWG_TYPE_VPORT_ENTITY_CONTROL:\n      error = dwg_encode_VPORT_ENTITY_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_VPORT_ENTITY_HEADER:\n      error = dwg_encode_VPORT_ENTITY_HEADER (dat, obj);\n      break;\n    case DWG_TYPE_GROUP:\n      error = dwg_encode_GROUP (dat, obj);\n      break;\n    case DWG_TYPE_MLINESTYLE:\n      error = dwg_encode_MLINESTYLE (dat, obj);\n      (void)dwg_encode_get_class (obj->parent, obj);\n      break;\n    case DWG_TYPE_OLE2FRAME:\n      error = dwg_encode_OLE2FRAME (dat, obj);\n      (void)dwg_encode_get_class (obj->parent, obj);\n      break;\n    case DWG_TYPE_DUMMY:\n      error = dwg_encode_DUMMY (dat, obj);\n      break;\n    case DWG_TYPE_LONG_TRANSACTION:\n      error = dwg_encode_LONG_TRANSACTION (dat, obj);\n      break;\n    case DWG_TYPE_LWPOLYLINE:\n      error = dwg_encode_LWPOLYLINE (dat, obj);\n      (void)dwg_encode_get_class (obj->parent, obj);\n      break;\n    case DWG_TYPE_HATCH:\n      error = dwg_encode_HATCH (dat, obj);\n      (void)dwg_encode_get_class (obj->parent, obj);\n      break;\n    case DWG_TYPE_XRECORD:\n      error = dwg_encode_XRECORD (dat, obj);\n      (void)dwg_encode_get_class (obj->parent, obj);\n      break;\n    case DWG_TYPE_PLACEHOLDER:\n      error = dwg_encode_PLACEHOLDER (dat, obj);\n      (void)dwg_encode_get_class (obj->parent, obj);\n      break;\n    case DWG_TYPE_OLEFRAME:\n      error = dwg_encode_OLEFRAME (dat, obj);\n      (void)dwg_encode_get_class (obj->parent, obj);\n      break;\n    case DWG_TYPE_VBA_PROJECT:\n      LOG_ERROR (\"Unhandled Object VBA_PROJECT. Has its own section\");\n      // dwg_encode_VBA_PROJECT(dat, obj);\n      break;\n    case DWG_TYPE_LAYOUT:\n      error |= dwg_encode_LAYOUT (dat, obj);\n      (void)dwg_encode_get_class (obj->parent, obj);\n      break;\n    case DWG_TYPE_PROXY_ENTITY:\n      error = dwg_encode_PROXY_ENTITY (dat, obj);\n      break;\n    case DWG_TYPE_PROXY_OBJECT:\n      error = dwg_encode_PROXY_OBJECT (dat, obj);\n      break;\n    default:\n      if (obj->type == obj->parent->layout_type\n          && obj->fixedtype == DWG_TYPE_LAYOUT)\n        {\n          error = dwg_encode_LAYOUT (dat, obj);\n          (void)dwg_encode_get_class (obj->parent, obj);\n        }\n      else if ((error = dwg_encode_variable_type (obj->parent, dat, obj))\n               & DWG_ERR_UNHANDLEDCLASS)\n        {\n          Dwg_Data *dwg = obj->parent;\n          int is_entity;\n          int i = obj->type - 500;\n          Dwg_Class *klass = dwg_encode_get_class (dwg, obj);\n\n          assert (address);\n          dat->byte = address; // restart and write into the UNKNOWN_OBJ object\n          dat->bit = 0;\n          bit_write_MS (dat, obj->size); // unknown blobs have a known size\n          if (dat->version >= R_2010)\n            {\n              bit_write_UMC (dat, obj->handlestream_size);\n              bit_write_BOT (dat, obj->type);\n            }\n          else\n            bit_write_BS (dat, obj->type);\n\n          if (klass && obj->supertype == DWG_SUPERTYPE_UNKNOWN)\n            is_entity = dwg_class_is_entity (klass);\n          else\n            is_entity = obj->supertype == DWG_SUPERTYPE_ENTITY;\n          // properly dwg_decode_object/_entity for eed, reactors, xdic\n          if (klass && !is_entity)\n            error = dwg_encode_UNKNOWN_OBJ (dat, obj);\n          else if (klass)\n            error = dwg_encode_UNKNOWN_ENT (dat, obj);\n          else // not a class\n            {\n              LOG_WARN (\"Unknown object, skipping eed/reactors/xdic\");\n              error = DWG_ERR_UNHANDLEDCLASS;\n              SINCE (R_2000)\n              {\n                bit_write_RL (dat, obj->bitsize);\n                LOG_INFO (\"bitsize: \" FORMAT_RL \" [RL] (@%lu.%u)\\n\", obj->bitsize,\n                          dat->byte - 4, dat->bit);\n              }\n              bit_write_H (dat, &obj->handle);\n              LOG_INFO (\"handle: \" FORMAT_H \" [H 5]\\n\", ARGS_H (obj->handle));\n              // write obj->size bytes, excl. bitsize and handle.\n              // overshoot the bitsize and handle size.\n              bit_write_TF (dat, obj->tio.unknown, obj->size);\n            }\n        }\n    }\n\n  /* DXF: patchup size and bitsize */\n  if (!obj->size)\n    {\n      BITCODE_BL pos = bit_position (dat);\n      assert (address);\n      obj->size = dat->byte - address - 2; // excludes the CRC\n      if (dat->bit)\n        obj->size++;\n      //assert (obj->bitsize); // on errors\n      if (!obj->bitsize)\n        {\n          LOG_TRACE (\"-bitsize calc from address (no handle) @%lu.%u\\n\",\n                     dat->byte, dat->bit);\n          obj->bitsize = pos - (obj->address * 8);\n        }\n      bit_set_position (dat, address * 8);\n      if (obj->size > 0x7fff)\n        // TODO: with overlarge sizes >0x7fff memmove dat\n        LOG_ERROR (\"Unhandled size %u > 0x7fff\", (unsigned)obj->size);\n      bit_write_MS (dat, obj->size);\n      LOG_TRACE (\"-size: %u [MS] @%lu\\n\", obj->size, address);\n      SINCE (R_2013)\n      {\n        if (!obj->handlestream_size && obj->bitsize)\n          obj->handlestream_size = obj->size * 8 - obj->bitsize;\n        bit_write_UMC (dat, obj->handlestream_size);\n        LOG_TRACE (\"-handlestream_size: %lu [UMC]\\n\", obj->handlestream_size);\n      }\n      SINCE (R_2000)\n      {\n        if (obj->bitsize_pos && obj->bitsize)\n          {\n            bit_set_position (dat, obj->bitsize_pos);\n            bit_write_RL (dat, obj->bitsize);\n            LOG_TRACE (\"-bitsize: %u [RL] @%lu.%lu\\n\", obj->bitsize,\n                       obj->bitsize_pos / 8, obj->bitsize_pos % 8);\n          }\n      }\n      bit_set_position (dat, pos);\n    }\n\n  /*\n   if (obj->supertype != DWG_SUPERTYPE_UNKNOWN)\n   {\n     fprintf (stderr, \"Begin address:\\t%10lu\\n\", address);\n     fprintf (stderr, \"Last address:\\t%10lu\\tSize: %10lu\\n\", dat->byte,\n   obj->size); fprintf (stderr, \"End address:\\t%10lu (calculated)\\n\", address +\n   2 + obj->size);\n   }\n   */\n\n  /* Now 1 padding bits until next byte, and then a RS CRC */\n  if (dat->bit)\n    LOG_TRACE (\"padding: +%d [*B]\\n\", 8 - dat->bit)\n  while (dat->bit)\n    bit_write_B (dat, 1);\n  end_address = obj->address + obj->size;\n  if (end_address != dat->byte)\n    {\n      if (obj->size)\n        LOG_WARN (\"Wrong object size: %lu + %u = %lu != %lu: %ld off\", obj->address,\n                  obj->size, end_address, dat->byte, (long)(end_address - dat->byte));\n      dat->byte = end_address;\n    }\n  assert (!dat->bit);\n  bit_write_CRC (dat, address, 0xC0C1);\n  return error;\n}\n\n/** writes the data part, if there's no raw.\n */\nstatic int\ndwg_encode_eed_data (Bit_Chain *restrict dat, Dwg_Eed_Data *restrict data,\n                     const int size, const int i)\n{\n  bit_write_RC (dat, data->code);\n  LOG_TRACE (\"EED[%d] code: %d [RC] \", i, data->code);\n  switch (data->code)\n    {\n    case 0:\n      {\n        PRE (R_2007)\n        {\n          if (data->u.eed_0.length + 3 <= size)\n            {\n              if (!data->u.eed_0.string)\n                data->u.eed_0.length = 0;\n              bit_write_RC (dat, data->u.eed_0.length);\n              bit_write_RS_LE (dat, data->u.eed_0.codepage);\n              if (data->u.eed_0.string)\n                bit_write_TF (dat, data->u.eed_0.string, data->u.eed_0.length);\n              else\n                bit_write_TF (dat, (char*)\"\", 0);\n            }\n          LOG_TRACE (\"string: len=%d [RC] cp=%d [RS_LE] \\\"%s\\\" [TF]\\n\",\n                     data->u.eed_0.length, data->u.eed_0.codepage, data->u.eed_0.string);\n        }\n        LATER_VERSIONS\n        {\n          BITCODE_RS *s = (BITCODE_RS *)&data->u.eed_0_r2007.string;\n          if (data->u.eed_0_r2007.string && data->u.eed_0.length * 2 + 2 <= size)\n            {\n              bit_write_RS (dat, data->u.eed_0_r2007.length);\n              for (int j = 0; j < data->u.eed_0_r2007.length; j++)\n                bit_write_RS (dat, *s++);\n            }\n          else\n            bit_write_RS (dat, 0);\n#ifdef _WIN32\n          LOG_TRACE (\"wstring: len=%d [RS] \\\"\" FORMAT_TU \"\\\" [TU]\\n\",\n                     (int)data->u.eed_0_r2007.length, data->u.eed_0_r2007.string);\n#else\n          if (DWG_LOGLEVEL >= DWG_LOGLEVEL_TRACE)\n            {\n              char *u8 = bit_convert_TU (data->u.eed_0_r2007.string);\n              LOG_TRACE (\"wstring: len=%d [RS] \\\"%s\\\" [TU]\\n\",\n                         (int)data->u.eed_0_r2007.length, u8);\n              free (u8);\n            }\n#endif\n        }\n      }\n      break;\n    case 2:\n      if (1 <= size)\n        bit_write_RC (dat, data->u.eed_2.byte);\n      LOG_TRACE (\"byte: %d [RC]\\n\", (int)data->u.eed_2.byte);\n      break;\n    case 3:\n      if (4 <= size)\n        bit_write_RL (dat, data->u.eed_3.layer);\n      LOG_TRACE (\"layer: %d [RL]\\n\", (int)data->u.eed_3.layer);\n      break;\n    case 4:\n      if (data->u.eed_0.length + 1 <= size)\n        {\n          bit_write_RC (dat, data->u.eed_4.length);\n          bit_write_TF (dat, data->u.eed_4.data, data->u.eed_4.length);\n        }\n      LOG_TRACE (\"binary: \\\"%s\\\" [TF %d]\\n\", data->u.eed_4.data,\n                 data->u.eed_4.length);\n      break;\n    case 5:\n      if (8 <= size)\n        bit_write_RLL (dat, data->u.eed_5.entity);\n      LOG_TRACE (\"entity: 0x\\\"%lX\\\" [RLL]\\n\", (unsigned long)data->u.eed_5.entity);\n      break;\n    case 10:\n    case 11:\n    case 12:\n    case 13:\n    case 14:\n    case 15:\n      if (24 <= size)\n        {\n          bit_write_RD (dat, data->u.eed_10.point.x);\n          bit_write_RD (dat, data->u.eed_10.point.y);\n          bit_write_RD (dat, data->u.eed_10.point.z);\n        }\n      LOG_TRACE (\"3dpoint: (%f, %f, %f) [3RD]\\n\", data->u.eed_10.point.x,\n                 data->u.eed_10.point.y, data->u.eed_10.point.z);\n      break;\n    case 40:\n    case 41:\n    case 42:\n      if (8 <= size)\n        bit_write_RD (dat, data->u.eed_40.real);\n      LOG_TRACE (\"real: %f [RD]\\n\", data->u.eed_40.real);\n      break;\n    case 70:\n      if (2 <= size)\n        bit_write_RS (dat, data->u.eed_70.rs);\n      LOG_TRACE (\"short: \" FORMAT_RS \" [RS]\\n\", data->u.eed_70.rs);\n      break;\n    case 71:\n      if (4 <= size)\n        bit_write_RL (dat, data->u.eed_71.rl);\n      LOG_TRACE (\"long: \" FORMAT_RL \" [RL]\\n\", data->u.eed_71.rl);\n      break;\n    default:\n      LOG_ERROR (\"unknown EED code %d\", data->code);\n    }\n  return 0;\n}\n\n/** Either writes the raw part.\n    Only members with size have raw and a handle.\n    Otherwise (indxf) defer to dwg_encode_eed_data.\n */\nstatic int\ndwg_encode_eed (Bit_Chain *restrict dat, Dwg_Object *restrict obj)\n{\n  unsigned long off = obj->address;\n\n#define LOG_POS\n  // LOG_INSANE (\" @%lu.%u\\n\", dat->byte - off, dat->bit)\n\n  int i, num_eed = obj->tio.object->num_eed;\n  for (i = 0; i < num_eed; i++)\n    {\n      Dwg_Eed *eed = &obj->tio.object->eed[i];\n      BITCODE_BS size = eed->size;\n      if (size)\n        {\n          bit_write_BS (dat, size);\n          LOG_TRACE (\"EED[%d] size: \" FORMAT_BS \" [BS]\\n\", i, size);\n          LOG_POS\n          bit_write_H (dat, &eed->handle);\n          LOG_TRACE (\"EED[%d] handle: \" FORMAT_H \" [H]\\n\", i,\n                     ARGS_H (eed->handle));\n          LOG_POS\n          if (eed->raw)\n            {\n              LOG_TRACE (\"EED[%d] raw [TF %d]\\n\", i, size);\n              bit_write_TF (dat, eed->raw, size);\n            }\n        }\n      if (!eed->raw && eed->data) // indxf\n        {\n          dwg_encode_eed_data (dat, eed->data, size, i);\n          LOG_POS\n        }\n    }\n  bit_write_BS (dat, 0);\n  if (i)\n    LOG_TRACE (\"EED[%d] size: 0 [BS] (end)\\n\", i);\n  LOG_POS\n#undef LOG_POS\n    return 0;\n}\n\n/* The first common part of every entity.\n\n   The last common part is common_entity_handle_data.spec\n   which is read from the hdl stream.\n   See DWG_SUPERTYPE_ENTITY in dwg_encode().\n */\nstatic int\ndwg_encode_entity (Dwg_Object *restrict obj, Bit_Chain *hdl_dat, Bit_Chain *str_dat,\n                   Bit_Chain *dat)\n{\n  int error = 0;\n  Dwg_Object_Entity *ent = obj->tio.entity;\n  Dwg_Object_Entity *_obj = ent;\n  Dwg_Data *dwg = ent->dwg;\n\n  if (!obj || !dat)\n    return DWG_ERR_INVALIDDWG;\n  PRE (R_13)\n  {\n\n    if (FIELD_VALUE (flag_r11) & 4 && FIELD_VALUE (kind_r11) > 2\n        && FIELD_VALUE (kind_r11) != 22)\n      FIELD_RD (elevation_r11, 30);\n    if (FIELD_VALUE (flag_r11) & 8)\n      FIELD_RD (thickness_r11, 39);\n    if (FIELD_VALUE (flag_r11) & 0x20)\n      {\n        Dwg_Object_Ref *hdl\n            = dwg_decode_handleref_with_code (dat, obj, dwg, 0);\n        if (hdl)\n          obj->handle = hdl->handleref;\n      }\n    if (FIELD_VALUE (extra_r11) & 4)\n      FIELD_RS (paper_r11, 0);\n  }\n\n  SINCE (R_2007) { *str_dat = *dat; }\n  VERSIONS (R_2000, R_2007)\n  {\n    obj->bitsize_pos = bit_position (dat);\n    bit_write_RL (dat, obj->bitsize);\n    LOG_TRACE (\"bitsize: %u [RL] (@%lu.%lu)\\n\", obj->bitsize,\n               obj->bitsize_pos / 8, obj->bitsize_pos % 8);\n  }\n  if (obj->bitsize)\n    obj->hdlpos = obj->address * 8 + obj->bitsize;\n  SINCE (R_2007)\n  {\n    // The handle stream offset, i.e. end of the object, right after\n    // the has_strings bit.\n    SINCE (R_2010)\n    {\n      if (obj->bitsize)\n        {\n          obj->hdlpos += 8;\n          // LOG_HANDLE (\"(bitsize: \" FORMAT_RL \", \", obj->bitsize);\n          LOG_HANDLE (\"hdlpos: %lu\\n\", obj->hdlpos);\n        }\n    }\n    // and set the string stream (restricted to size)\n    error |= obj_string_stream (dat, obj, str_dat);\n  }\n\n  bit_write_H (dat, &obj->handle);\n  LOG_TRACE (\"handle: \" FORMAT_H \" [H 5]\\n\", ARGS_H (obj->handle))\n  PRE (R_13) { return DWG_ERR_NOTYETSUPPORTED; }\n\n  error |= dwg_encode_eed (dat, obj);\n  // if (error & (DWG_ERR_INVALIDTYPE|DWG_ERR_VALUEOUTOFBOUNDS))\n  //  return error;\n\n  // clang-format off\n  #include \"common_entity_data.spec\"\n  // clang-format on\n\n  return error;\n}\n\nstatic int\ndwg_encode_common_entity_handle_data (Bit_Chain *dat, Bit_Chain *hdl_dat,\n                                      Dwg_Object *restrict obj)\n{\n  Dwg_Object_Entity *ent;\n  // Dwg_Data *dwg = obj->parent;\n  Dwg_Object_Entity *_obj;\n  BITCODE_BL vcount;\n  int error = 0;\n  ent = obj->tio.entity;\n  _obj = ent;\n\n  // clang-format off\n  #include \"common_entity_handle_data.spec\"\n  // clang-format on\n\n  return error;\n}\n\nvoid\ndwg_encode_handleref (Bit_Chain *hdl_dat, Dwg_Object *restrict obj, Dwg_Data *restrict dwg,\n                      Dwg_Object_Ref *restrict ref)\n{\n  // this function should receive a Object_Ref without an abs_ref, calculate it\n  // and return a Dwg_Handle this should be a higher level function not sure if\n  // the prototype is correct\n  assert (obj);\n}\n\n/**\n * code:\n *  TYPEDOBJHANDLE:\n *   2 Soft owner\n *   3 Hard owner\n *   4 Soft pointer\n *   5 Hard pointer\n *  OFFSETOBJHANDLE for soft owners or pointers:\n *   6 ref + 1\n *   8 ref - 1\n *   a ref + offset\n *   c ref - offset\n */\nvoid\ndwg_encode_handleref_with_code (Bit_Chain *hdl_dat, Dwg_Object *restrict obj,\n                                Dwg_Data *restrict dwg, Dwg_Object_Ref *restrict ref,\n                                unsigned int code)\n{\n  // XXX fixme. create the handle, then check the code. allow relative handle\n  // soft codes.\n  dwg_encode_handleref (hdl_dat, obj, dwg, ref);\n  if (ref->absolute_ref == 0 && ref->handleref.code != code)\n    {\n      /*\n       * With TYPEDOBJHANDLE 2-5 the code indicates the type of ownership.\n       * With OFFSETOBJHANDLE >5 the handle is stored as an offset from some\n       * other handle.\n       */\n      switch (ref->handleref.code)\n        {\n        case 0x06:\n          ref->absolute_ref = (obj->handle.value + 1);\n          break;\n        case 0x08:\n          ref->absolute_ref = (obj->handle.value - 1);\n          break;\n        case 0x0A:\n          ref->absolute_ref = (obj->handle.value + ref->handleref.value);\n          break;\n        case 0x0C:\n          ref->absolute_ref = (obj->handle.value - ref->handleref.value);\n          break;\n        case 2:\n        case 3:\n        case 4:\n        case 5:\n          ref->absolute_ref = ref->handleref.value;\n          break;\n        case 0: // ignore (ANYCODE)\n          ref->absolute_ref = ref->handleref.value;\n          break;\n        default:\n          LOG_WARN (\"Invalid handle pointer code %d\", ref->handleref.code);\n          break;\n        }\n    }\n}\n\n/* The first common part of every object.\n\n   There is no COMMON_ENTITY_HANDLE_DATA for objects.\n   See DWG_SUPERTYPE_OBJECT in dwg_encode().\n*/\nstatic int\ndwg_encode_object (Dwg_Object *restrict obj, Bit_Chain *hdl_dat, Bit_Chain *str_dat,\n                   Bit_Chain *dat)\n{\n  int error = 0;\n  Dwg_Object_Object *ord = obj->tio.object;\n\n  VERSIONS (R_2000, R_2007)\n  {\n    obj->bitsize_pos = bit_position (dat);\n    bit_write_RL (dat, obj->bitsize);\n    LOG_INFO (\"bitsize: \" FORMAT_RL \" [RL] (@%lu.%u)\\n\", obj->bitsize,\n              dat->byte - 4, dat->bit);\n  }\n  if (obj->bitsize)\n    obj->hdlpos = bit_position (dat) + obj->bitsize; // the handle stream offset\n  SINCE (R_2007) { obj_string_stream (dat, obj, str_dat); }\n\n  bit_write_H (dat, &obj->handle);\n  LOG_TRACE (\"handle: \" FORMAT_H \" [H 5]\\n\", ARGS_H (obj->handle));\n  error |= dwg_encode_eed (dat, obj);\n\n  VERSIONS (R_13, R_14)\n  {\n    obj->bitsize_pos = bit_position (dat);\n    bit_write_RL (dat, obj->bitsize);\n    LOG_INFO (\"bitsize: \" FORMAT_RL \" [RL] (@%lu.%u)\\n\", obj->bitsize,\n              dat->byte - 4, dat->bit);\n  }\n\n  bit_write_BL (dat, ord->num_reactors);\n  LOG_TRACE (\"num_reactors: \" FORMAT_BL \" [BL]\\n\", ord->num_reactors);\n  SINCE (R_2004)\n  {\n    bit_write_B (dat, ord->xdic_missing_flag);\n    LOG_TRACE (\"xdic_missing_flag: \" FORMAT_B \" [B]\\n\",\n               ord->xdic_missing_flag);\n  }\n  SINCE (R_2013)\n  {\n    bit_write_B (dat, ord->has_ds_binary_data);\n    LOG_TRACE (\"has_ds_binary_data: \" FORMAT_B \" [B]\\n\",\n               ord->has_ds_binary_data);\n  }\n  return error;\n}\n\nstatic int\ndwg_encode_header_variables (Bit_Chain *dat, Bit_Chain *hdl_dat,\n                             Bit_Chain *str_dat, Dwg_Data *restrict dwg)\n{\n  Dwg_Header_Variables *_obj = &dwg->header_vars;\n  Dwg_Object *obj = NULL;\n  int old_from = (int)dat->from_version;\n\n  if (!_obj->HANDSEED) // minimal or broken DXF\n    {\n      dwg->opts |= DWG_OPTS_MINIMAL;\n      dat->from_version = dat->version - 1;\n      LOG_TRACE (\"encode from minimal DXF\\n\");\n      _obj->HANDSEED = calloc(1, sizeof(Dwg_Object_Ref));\n      _obj->HANDSEED->absolute_ref = 0x72E;\n    }\n\n  // clang-format off\n  #include \"header_variables.spec\"\n  // clang-format on\n\n  dat->from_version = old_from;\n  return 0;\n}\n\nstatic int\ndwg_encode_xdata (Bit_Chain *restrict dat, Dwg_Object_XRECORD *restrict obj, int size)\n{\n  Dwg_Resbuf *rbuf = obj->xdata;\n  enum RES_BUF_VALUE_TYPE type;\n  int i, j = 0;\n\n  while (rbuf)\n    {\n      bit_write_RS (dat, rbuf->type);\n      type = get_base_value_type (rbuf->type);\n      switch (type)\n        {\n        case VT_STRING:\n          UNTIL (R_2007)\n          {\n            bit_write_RS (dat, rbuf->value.str.size);\n            bit_write_RC (dat, rbuf->value.str.codepage);\n            if (rbuf->value.str.u.data)\n              bit_write_TF (dat, rbuf->value.str.u.data, rbuf->value.str.size);\n            else\n              bit_write_TF (dat, (char*)\"\", 0);\n            LOG_TRACE (\"xdata[%d]: \\\"%s\\\" [TF %d %d]\\n\", j,\n                       rbuf->value.str.u.data, rbuf->value.str.size,\n                       rbuf->type);\n          }\n          LATER_VERSIONS\n          {\n            bit_write_RS (dat, rbuf->value.str.size);\n            for (i = 0; i < rbuf->value.str.size; i++)\n              bit_write_RS (dat, rbuf->value.str.u.wdata[i]);\n          }\n          break;\n        case VT_REAL:\n          bit_write_RD (dat, rbuf->value.dbl);\n          LOG_TRACE (\"xdata[%d]: %f [RD %d]\\n\", j, rbuf->value.dbl,\n                     rbuf->type);\n          break;\n        case VT_BOOL:\n        case VT_INT8:\n          bit_write_RC (dat, rbuf->value.i8);\n          LOG_TRACE (\"xdata[%d]: %d [RC %d]\\n\", j, (int)rbuf->value.i8,\n                     rbuf->type);\n          break;\n        case VT_INT16:\n          bit_write_RS (dat, rbuf->value.i16);\n          LOG_TRACE (\"xdata[%d]: %d [RS %d]\\n\", j, (int)rbuf->value.i16,\n                     rbuf->type);\n          break;\n        case VT_INT32:\n          bit_write_RL (dat, rbuf->value.i32);\n          LOG_TRACE (\"xdata[%d]: %ld [RL %d]\\n\", j, (long)rbuf->value.i32,\n                     rbuf->type);\n          break;\n        case VT_INT64:\n          bit_write_BLL (dat, rbuf->value.i64);\n          LOG_TRACE (\"xdata[%d]: \" FORMAT_BLL \" [BLL %d]\\n\", j,\n                     rbuf->value.i64, rbuf->type);\n          break;\n        case VT_POINT3D:\n          bit_write_RD (dat, rbuf->value.pt[0]);\n          bit_write_RD (dat, rbuf->value.pt[1]);\n          bit_write_RD (dat, rbuf->value.pt[2]);\n          LOG_TRACE (\"xdata[%d]: (%f,%f,%f) [3RD %d]\\n\", j, rbuf->value.pt[0],\n                     rbuf->value.pt[1], rbuf->value.pt[2], rbuf->type);\n          break;\n        case VT_BINARY:\n          bit_write_RC (dat, rbuf->value.str.size);\n          bit_write_TF (dat, rbuf->value.str.u.data, rbuf->value.str.size);\n          LOG_TRACE (\"xdata[%d]: [TF %d %d] \", j, rbuf->value.str.size,\n                     rbuf->type);\n          LOG_TRACE_TF (rbuf->value.str.u.data, rbuf->value.str.size);\n          break;\n        case VT_HANDLE:\n        case VT_OBJECTID:\n          for (i = 0; i < 8; i++)\n            bit_write_RC (dat, rbuf->value.hdl[i]);\n          LOG_TRACE (\"xdata[%d]: \" FORMAT_H \" [H %d]\\n\", j,\n                     ARGS_H (rbuf->value.h), rbuf->type);\n          break;\n        case VT_INVALID:\n        default:\n          LOG_ERROR (\"Invalid group code in xdata: %d\", rbuf->type)\n          return DWG_ERR_INVALIDEED;\n        }\n      rbuf = rbuf->next;\n      j++;\n    }\n  return 0;\n}\n\nchar *encrypt_sat1 (BITCODE_BL blocksize, BITCODE_RC *acis_data, int *idx)\n{\n  char *encr_sat_data = calloc (blocksize, 1);\n  int i = *idx;\n  int j;\n  for (j = 0; j < (int)blocksize; j++)\n    {\n      if (acis_data[j] <= 32)\n        encr_sat_data[i++] = acis_data[j];\n      else\n        encr_sat_data[i++] = acis_data[j] - 159;\n      /* TODO reversion of:\n      if (encr_sat_data[j] <= 32)\n        acis_data[i++] = encr_sat_data[j];\n      else\n        acis_data[i++] = 159 - encr_sat_data[j];\n      */\n    }\n  *idx = i;\n  return encr_sat_data;\n}\n\n#undef IS_ENCODER\n", "/*****************************************************************************/\n/*  LibreDWG - free implementation of the DWG file format                    */\n/*                                                                           */\n/*  Copyright (C) 2018-2019 Free Software Foundation, Inc.                   */\n/*                                                                           */\n/*  This library is free software, licensed under the terms of the GNU       */\n/*  General Public License as published by the Free Software Foundation,     */\n/*  either version 3 of the License, or (at your option) any later version.  */\n/*  You should have received a copy of the GNU General Public License        */\n/*  along with this program.  If not, see <http://www.gnu.org/licenses/>.    */\n/*****************************************************************************/\n\n/*\n * free.c: helper functions to free all spec fields\n * written by Reini Urban\n * modified by Denis Pruchkovsky\n */\n\n#include \"config.h\"\n#ifdef __STDC_ALLOC_LIB__\n#  define __STDC_WANT_LIB_EXT2__ 1 /* for strdup */\n#else\n#  define _USE_BSD 1\n#endif\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\n#include \"common.h\"\n#include \"bits.h\"\n#include \"dwg.h\"\n#include \"decode.h\"\n#include \"free.h\"\n#include \"hash.h\"\n\nstatic unsigned int loglevel;\n#ifdef USE_TRACING\nstatic int env_var_checked_p;\n#endif\n#define DWG_LOGLEVEL loglevel\n#include \"logging.h\"\n\n/* the current version per spec block */\nstatic unsigned int cur_ver = 0;\nstatic Bit_Chain pdat = { NULL, 0, 0, 0, 0, 0 };\n\n/*--------------------------------------------------------------------------------\n * MACROS\n */\n\n#define ACTION free\n#define IS_FREE\n\n#define FREE_IF(ptr)                                                          \\\n  {                                                                           \\\n    if (ptr)                                                                  \\\n      free (ptr);                                                             \\\n    ptr = NULL;                                                               \\\n  }\n\n#define VALUE(value, type, dxf)\n#define VALUE_RC(value, dxf) VALUE (value, RC, dxf)\n#define VALUE_RS(value, dxf) VALUE (value, RS, dxf)\n#define VALUE_RL(value, dxf) VALUE (value, RL, dxf)\n#define VALUE_RD(value, dxf) VALUE (value, RD, dxf)\n\n#define FIELD(name, type)                                                     \\\n  {                                                                           \\\n  }\n#define FIELD_TRACE(name, type)                                               \\\n  LOG_TRACE (#name \": \" FORMAT_##type \"\\n\", _obj->name)\n#define FIELD_G_TRACE(name, type, dxfgroup)                                   \\\n  LOG_TRACE (#name \": \" FORMAT_##type \" [\" #type \" %d]\\n\", _obj->name,        \\\n             dxfgroup)\n#define FIELD_CAST(name, type, cast, dxf)                                     \\\n  {                                                                           \\\n  }\n#define FIELD_VALUE(name) _obj->name\n#define SUB_FIELD(o, nam, type, dxf) FIELD (_obj->o.nam, type)\n\n#define ANYCODE -1\n#define FIELD_HANDLE(nam, code, dxf) VALUE_HANDLE (_obj->nam, nam, code, dxf)\n#define SUB_FIELD_HANDLE(o, nam, code, dxf)                                   \\\n  VALUE_HANDLE (_obj->o.nam, nam, code, dxf)\n// compare to dwg_decode_handleref_with_code: not all refs are stored in the\n// object_ref vector, like relative ptrs and NULL.\n// But indxf skip the NULL HDL, it is global and shared there.\n// obj is the relative base object here and there.\n#define VALUE_HANDLE(ref, nam, _code, dxf)                                    \\\n  if (ref                                                                     \\\n      && !(dat->opts & DWG_OPTS_INDXF && ref->handleref.size == 0             \\\n           && ref->absolute_ref == 0 && !ref->obj)                            \\\n      && !(ref->handleref.size || (obj && ref->handleref.code > 5)))          \\\n    {                                                                         \\\n      free (ref);                                                             \\\n      ref = NULL;                                                             \\\n    } /* else freed globally */\n#define FIELD_DATAHANDLE(name, code, dxf) FIELD_HANDLE (name, code, dxf)\n#define FIELD_HANDLE_N(name, vcount, code, dxf) FIELD_HANDLE (name, code, dxf)\n\n#define FIELD_B(name, dxf) FIELD (name, B)\n#define FIELD_BB(name, dxf) FIELD (name, BB)\n#define FIELD_3B(name, dxf) FIELD (name, 3B)\n#define FIELD_BS(name, dxf) FIELD (name, BS)\n#define FIELD_BL(name, dxf) FIELD (name, BL)\n#define FIELD_BLL(name, dxf) FIELD (name, BLL)\n#define FIELD_BD(name, dxf) FIELD (name, BD)\n#define FIELD_RC(name, dxf) FIELD (name, RC)\n#define FIELD_RS(name, dxf) FIELD (name, RS)\n#define FIELD_RD(name, dxf) FIELD (name, RD)\n#define FIELD_RL(name, dxf) FIELD (name, RL)\n#define FIELD_RLL(name, dxf) FIELD (name, RLL)\n#define FIELD_MC(name, dxf) FIELD (name, MC)\n#define FIELD_MS(name, dxf) FIELD (name, MS)\n#define FIELD_TV(name, dxf) FREE_IF (FIELD_VALUE (name))\n#define VALUE_TV(value, dxf) FREE_IF (value)\n#define VALUE_TF(value, dxf) FREE_IF (value)\n#define VALUE_TFF(value, dxf)\n#define FIELD_TU(name, dxf) FIELD_TV (name, dxf)\n#define FIELD_TF(name, len, dxf) FIELD_TV (name, dxf)\n#define FIELD_TFF(name, len, dxf)                                             \\\n  {                                                                           \\\n  }\n#define FIELD_T(name, dxf) FIELD_TV (name, dxf)\n#define FIELD_BINARY(name, len, dxf) FIELD_TV (name, dxf)\n#define FIELD_BT(name, dxf) FIELD (name, BT);\n#define FIELD_4BITS(name, dxf)                                                \\\n  {                                                                           \\\n  }\n#define FIELD_BE(name, dxf)                                                   \\\n  {                                                                           \\\n  }\n#define FIELD_DD(name, _default, dxf)                                         \\\n  {                                                                           \\\n  }\n#define FIELD_2DD(name, d1, d2, dxf)                                          \\\n  {                                                                           \\\n  }\n#define FIELD_3DD(name, def, dxf)                                             \\\n  {                                                                           \\\n  }\n#define FIELD_2RD(name, dxf)                                                  \\\n  {                                                                           \\\n  }\n#define FIELD_2BD(name, dxf)                                                  \\\n  {                                                                           \\\n  }\n#define FIELD_2BD_1(name, dxf)                                                \\\n  {                                                                           \\\n  }\n#define FIELD_3RD(name, dxf)                                                  \\\n  {                                                                           \\\n  }\n#define FIELD_3BD(name, dxf)                                                  \\\n  {                                                                           \\\n  }\n#define FIELD_3BD_1(name, dxf)                                                \\\n  {                                                                           \\\n  }\n#define FIELD_3DPOINT(name, dxf)                                              \\\n  {                                                                           \\\n  }\n#define FIELD_TIMEBLL(name, dxf)\n#define FIELD_TIMERLL(name, dxf)\n// indxf does not assign names yet\n#define FIELD_CMC(color, dxf1, dxf2)                                          \\\n  if (!(dat->opts & DWG_OPTS_INDXF)) {                                        \\\n    FIELD_T (color.name, 0);                                                  \\\n    FIELD_T (color.book_name, 0);                                             \\\n  }\n#define SUB_FIELD_CMC(o, color, dxf1, dxf2)                                   \\\n  if (!(dat->opts & DWG_OPTS_INDXF)) {                                        \\\n    VALUE_TV (_obj->o.color.name, 0);                                         \\\n    VALUE_TV (_obj->o.color.book_name, 0);                                    \\\n  }\n\n// FIELD_VECTOR_N(name, type, size):\n// reads data of the type indicated by 'type' 'size' times and stores\n// it all in the vector called 'name'.\n#define FIELD_VECTOR_N(nam, type, size, dxf)                                  \\\n  if ((size) && _obj->nam)                                                    \\\n    {                                                                         \\\n      for (vcount = 0; vcount < (BITCODE_BL) (size); vcount++)                \\\n        FIELD_##type (nam[vcount], dxf);                                      \\\n    }                                                                         \\\n  FIELD_TV (nam, dxf);\n#define FIELD_VECTOR_T(name, size, dxf)                                       \\\n  FIELD_VECTOR_N (name, TV, _obj->size, dxf)\n#define FIELD_VECTOR(name, type, size, dxf)                                   \\\n  FIELD_VECTOR_N (name, type, _obj->size, dxf)\n#define FIELD_2RD_VECTOR(name, size, dxf) FIELD_TV (name, dxf)\n#define FIELD_2DD_VECTOR(name, size, dxf) FIELD_TV (name, dxf)\n#define FIELD_3DPOINT_VECTOR(name, size, dxf) FIELD_TV (name, dxf)\n#define HANDLE_VECTOR_N(name, size, code, dxf)                                \\\n  if (_obj->name)                                                             \\\n    {                                                                         \\\n      for (vcount = 0; vcount < (BITCODE_BL)size; vcount++)                   \\\n        {                                                                     \\\n          FIELD_HANDLE_N (name[vcount], vcount, code, dxf);                   \\\n        }                                                                     \\\n      if (size)                                                               \\\n        {                                                                     \\\n          FIELD_TV (name, dxf)                                                \\\n        }                                                                     \\\n    }\n#define HANDLE_VECTOR(name, sizefield, code, dxf)                             \\\n  HANDLE_VECTOR_N (name, FIELD_VALUE (sizefield), code, dxf)\n\n#define FIELD_NUM_INSERTS(num_inserts, type, dxf)\n#define FIELD_XDATA(name, size) dwg_free_xdata (_obj, _obj->size)\n\n#define REACTORS(code)                                                        \\\n  if (obj->tio.object->reactors)                                              \\\n    {                                                                         \\\n      for (vcount = 0; vcount < obj->tio.object->num_reactors; vcount++)      \\\n        VALUE_HANDLE (obj->tio.object->reactors[vcount], reactors, code,      \\\n                      330);                                                   \\\n      VALUE_TV (obj->tio.object->reactors, 0);                                \\\n    }\n#define ENT_REACTORS(code)                                                    \\\n  if (ent->reactors)                                                          \\\n    {                                                                         \\\n      for (vcount = 0; vcount < ent->num_reactors; vcount++)                  \\\n        VALUE_HANDLE (ent->reactors[vcount], reactors, code, 330);            \\\n      VALUE_TV (ent->reactors, 0);                                            \\\n    }\n#define XDICOBJHANDLE(code)                                                   \\\n  SINCE (R_2004)                                                              \\\n  {                                                                           \\\n    if (!obj->tio.object->xdic_missing_flag)                                  \\\n      {                                                                       \\\n        VALUE_HANDLE (obj->tio.object->xdicobjhandle, xdicobjhandle, code,    \\\n                      0);                                                     \\\n      }                                                                       \\\n  }                                                                           \\\n  PRIOR_VERSIONS                                                              \\\n  {                                                                           \\\n    VALUE_HANDLE (obj->tio.object->xdicobjhandle, xdicobjhandle, code, 0);    \\\n  }\n#define ENT_XDICOBJHANDLE(code)                                               \\\n  SINCE (R_2004)                                                              \\\n  {                                                                           \\\n    if (!ent->xdic_missing_flag)                                              \\\n      {                                                                       \\\n        VALUE_HANDLE (ent->xdicobjhandle, xdicobjhandle, code, 0);            \\\n      }                                                                       \\\n  }                                                                           \\\n  PRIOR_VERSIONS { VALUE_HANDLE (ent->xdicobjhandle, xdicobjhandle, code, 0); }\n\n#define END_REPEAT(field) FIELD_TV (field, 0)\n\n#define COMMON_ENTITY_HANDLE_DATA\n#define SECTION_STRING_STREAM\n#define START_STRING_STREAM\n#define END_STRING_STREAM\n#define START_HANDLE_STREAM\n\nstatic int dwg_free_UNKNOWN_ENT (Bit_Chain *restrict dat,\n                                 Dwg_Object *restrict obj);\nstatic int dwg_free_UNKNOWN_OBJ (Bit_Chain *restrict dat,\n                                 Dwg_Object *restrict obj);\n\n#define DWG_ENTITY(token)                                                     \\\n  static int dwg_free_##token##_private (Bit_Chain *restrict dat,             \\\n                                         Dwg_Object *restrict obj);           \\\n                                                                              \\\n  static int dwg_free_##token (Bit_Chain *restrict dat,                       \\\n                               Dwg_Object *restrict obj)                      \\\n  {                                                                           \\\n    int error = 0;                                                            \\\n    if (obj->tio.entity)                                                      \\\n      {                                                                       \\\n        LOG_HANDLE (\"Free entity \" #token \" [%d]\\n\", obj->index)              \\\n        if (obj->tio.entity->tio.token)                                       \\\n          error = dwg_free_##token##_private (dat, obj);                      \\\n                                                                              \\\n        dwg_free_common_entity_data (obj);                                    \\\n        dwg_free_eed (obj);                                                   \\\n        if (obj->tio.entity)                                                  \\\n          {                                                                   \\\n            FREE_IF (obj->tio.entity->tio.token);                             \\\n            FREE_IF (obj->tio.entity);                                        \\\n          }                                                                   \\\n      }                                                                       \\\n    obj->parent = NULL;                                                       \\\n    return error;                                                             \\\n  }                                                                           \\\n  static int dwg_free_##token##_private (Bit_Chain *restrict dat,             \\\n                                         Dwg_Object *restrict obj)            \\\n  {                                                                           \\\n    BITCODE_BL vcount, rcount1, rcount2, rcount3, rcount4;                    \\\n    Dwg_Entity_##token *ent, *_obj;                                           \\\n    Dwg_Object_Entity *_ent;                                                  \\\n    Bit_Chain *hdl_dat = dat;                                                 \\\n    Bit_Chain *str_dat = dat;                                                 \\\n    Dwg_Data *dwg = obj->parent;                                              \\\n    int error = 0;                                                            \\\n    _ent = obj->tio.entity;                                                   \\\n    _obj = ent = _ent->tio.token;\n\n#define DWG_ENTITY_END                                                        \\\n  return error;                                                               \\\n  }\n\n#define DWG_OBJECT(token)                                                     \\\n  static int dwg_free_##token##_private (Bit_Chain *restrict dat,             \\\n                                         Dwg_Object *restrict obj);           \\\n                                                                              \\\n  static int dwg_free_##token (Bit_Chain *restrict dat,                       \\\n                               Dwg_Object *restrict obj)                      \\\n  {                                                                           \\\n    int error = 0;                                                            \\\n    Dwg_Object_##token *_obj = NULL;                                          \\\n    if (obj->tio.object)                                                      \\\n      {                                                                       \\\n        _obj = obj->tio.object->tio.token;                                    \\\n        LOG_HANDLE (\"Free object \" #token \" [%d]\\n\", obj->index)              \\\n        if (strcmp (#token, \"UNKNOWN_OBJ\")                                    \\\n            && obj->supertype == DWG_SUPERTYPE_UNKNOWN)                       \\\n          {                                                                   \\\n            _obj = NULL;                                                      \\\n            error = dwg_free_UNKNOWN_OBJ (dat, obj);                          \\\n          }                                                                   \\\n        else                                                                  \\\n          {                                                                   \\\n            error = dwg_free_##token##_private (dat, obj);                    \\\n          }                                                                   \\\n        dwg_free_eed (obj);                                                   \\\n        FREE_IF (_obj);                                                       \\\n        FREE_IF (obj->tio.object);                                            \\\n      }                                                                       \\\n    obj->parent = NULL;                                                       \\\n    return error;                                                             \\\n  }                                                                           \\\n                                                                              \\\n  static int dwg_free_##token##_private (Bit_Chain *restrict dat,             \\\n                                         Dwg_Object *restrict obj)            \\\n  {                                                                           \\\n    BITCODE_BL vcount, rcount1, rcount2, rcount3, rcount4;                    \\\n    Dwg_Object_##token *_obj;                                                 \\\n    Bit_Chain *hdl_dat = dat;                                                 \\\n    Bit_Chain *str_dat = dat;                                                 \\\n    Dwg_Data *dwg = obj->parent;                                              \\\n    int error = 0;                                                            \\\n    if (!obj->tio.object)                                                     \\\n      return 0;                                                               \\\n    _obj = obj->tio.object->tio.token;\n\n/* obj itself is allocated via dwg->object[], dxfname is klass->dxfname or\n * static */\n#define DWG_OBJECT_END                                                        \\\n  return error;                                                               \\\n  }\n\nstatic void\ndwg_free_common_entity_data (Dwg_Object *obj)\n{\n\n  Dwg_Data *dwg = obj->parent;\n  Bit_Chain *dat = &pdat;\n  Bit_Chain *hdl_dat = &pdat;\n  Dwg_Object_Entity *_obj;\n  Dwg_Object_Entity *ent;\n  BITCODE_BL vcount;\n  int error = 0;\n\n  ent = obj->tio.entity;\n  if (!ent)\n    return;\n  _obj = ent;\n\n  FREE_IF (ent->preview);\n\n  // clang-format off\n  #include \"common_entity_data.spec\"\n  SINCE (R_13) {\n  #include \"common_entity_handle_data.spec\"\n  }\n  // clang-format on\n}\n\nstatic void\ndwg_free_xdata (Dwg_Object_XRECORD *obj, int size)\n{\n  dwg_free_xdata_resbuf (obj->xdata);\n  obj->xdata = NULL;\n}\n\nEXPORT void\ndwg_free_eed (Dwg_Object *obj)\n{\n  BITCODE_BL i;\n  if (obj->supertype == DWG_SUPERTYPE_ENTITY)\n    {\n      Dwg_Object_Entity *_obj = obj->tio.entity;\n      for (i = 0; i < _obj->num_eed; i++)\n        {\n          FREE_IF (_obj->eed[i].raw);\n          FREE_IF (_obj->eed[i].data);\n        }\n      FREE_IF (_obj->eed);\n      _obj->num_eed = 0;\n    }\n  else\n    {\n      Dwg_Object_Object *_obj = obj->tio.object;\n      if (!_obj || !_obj->eed)\n        return;\n      for (i = 0; i < _obj->num_eed; i++)\n        {\n          FREE_IF (_obj->eed[i].raw);\n          FREE_IF (_obj->eed[i].data);\n        }\n      FREE_IF (_obj->eed);\n      _obj->num_eed = 0;\n    }\n}\n\n#include \"dwg.spec\"\n\n/* returns 1 if object could be freed and 0 otherwise\n */\nstatic int\ndwg_free_variable_type (Dwg_Data *restrict dwg, Dwg_Object *restrict obj)\n{\n  const int i = obj->type - 500;\n  Dwg_Class *klass;\n  Bit_Chain *dat = &pdat;\n\n  if (i < 0 || i >= (int)dwg->num_classes)\n    return DWG_ERR_INVALIDTYPE;\n\n  klass = &dwg->dwg_class[i];\n  if (!klass || !klass->dxfname)\n    return DWG_ERR_INTERNALERROR;\n\n  if (strNE (obj->dxfname, klass->dxfname))\n    {\n      LOG_ERROR (\"Wrong %s.type %d for obj [%d]: != %s\",  obj->dxfname, obj->type,\n                 obj->index, klass->dxfname);\n      return DWG_ERR_INVALIDTYPE;\n    }\n\n  // global class dispatcher:\n  // with indxf even DEBUGGING objects, such as TABLE are created.\n  // usually not written/encoded though.\n\n  // clang-format off\n  #include \"classes.inc\"\n\n  #undef WARN_UNHANDLED_CLASS\n  #undef WARN_UNSTABLE_CLASS\n  // clang-format on\n\n  return DWG_ERR_UNHANDLEDCLASS;\n}\n\n// using the global dat\nvoid\ndwg_free_object (Dwg_Object *obj)\n{\n  int error = 0;\n  long unsigned int j;\n  Dwg_Data *dwg;\n  Bit_Chain *dat = &pdat;\n\n  if (obj && obj->parent)\n    {\n      dwg = obj->parent;\n      dat->version = dwg->header.version;\n    }\n  else\n    return;\n  if (obj->type == DWG_TYPE_FREED || obj->tio.object == NULL)\n    return;\n  dat->from_version = dat->version;\n  if (obj->supertype == DWG_SUPERTYPE_UNKNOWN)\n    goto unhandled;\n\n  switch (obj->type)\n    {\n    case DWG_TYPE_TEXT:\n      dwg_free_TEXT (dat, obj);\n      break;\n    case DWG_TYPE_ATTRIB:\n      dwg_free_ATTRIB (dat, obj);\n      break;\n    case DWG_TYPE_ATTDEF:\n      dwg_free_ATTDEF (dat, obj);\n      break;\n    case DWG_TYPE_BLOCK:\n      dwg_free_BLOCK (dat, obj);\n      break;\n    case DWG_TYPE_ENDBLK:\n      dwg_free_ENDBLK (dat, obj);\n      break;\n    case DWG_TYPE_SEQEND:\n      dwg_free_SEQEND (dat, obj);\n      break;\n    case DWG_TYPE_INSERT:\n      dwg_free_INSERT (dat, obj);\n      break;\n    case DWG_TYPE_MINSERT:\n      dwg_free_MINSERT (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_2D:\n      dwg_free_VERTEX_2D (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_3D:\n      dwg_free_VERTEX_3D (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_MESH:\n      dwg_free_VERTEX_MESH (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_PFACE:\n      dwg_free_VERTEX_PFACE (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_PFACE_FACE:\n      dwg_free_VERTEX_PFACE_FACE (dat, obj);\n      break;\n    case DWG_TYPE_POLYLINE_2D:\n      dwg_free_POLYLINE_2D (dat, obj);\n      break;\n    case DWG_TYPE_POLYLINE_3D:\n      dwg_free_POLYLINE_3D (dat, obj);\n      break;\n    case DWG_TYPE_ARC:\n      dwg_free_ARC (dat, obj);\n      break;\n    case DWG_TYPE_CIRCLE:\n      dwg_free_CIRCLE (dat, obj);\n      break;\n    case DWG_TYPE_LINE:\n      dwg_free_LINE (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_ORDINATE:\n      dwg_free_DIMENSION_ORDINATE (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_LINEAR:\n      dwg_free_DIMENSION_LINEAR (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_ALIGNED:\n      dwg_free_DIMENSION_ALIGNED (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_ANG3PT:\n      dwg_free_DIMENSION_ANG3PT (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_ANG2LN:\n      dwg_free_DIMENSION_ANG2LN (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_RADIUS:\n      dwg_free_DIMENSION_RADIUS (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_DIAMETER:\n      dwg_free_DIMENSION_DIAMETER (dat, obj);\n      break;\n    case DWG_TYPE_POINT:\n      dwg_free_POINT (dat, obj);\n      break;\n    case DWG_TYPE__3DFACE:\n      dwg_free__3DFACE (dat, obj);\n      break;\n    case DWG_TYPE_POLYLINE_PFACE:\n      dwg_free_POLYLINE_PFACE (dat, obj);\n      break;\n    case DWG_TYPE_POLYLINE_MESH:\n      dwg_free_POLYLINE_MESH (dat, obj);\n      break;\n    case DWG_TYPE_SOLID:\n      dwg_free_SOLID (dat, obj);\n      break;\n    case DWG_TYPE_TRACE:\n      dwg_free_TRACE (dat, obj);\n      break;\n    case DWG_TYPE_SHAPE:\n      dwg_free_SHAPE (dat, obj);\n      break;\n    case DWG_TYPE_VIEWPORT:\n      dwg_free_VIEWPORT (dat, obj);\n      break;\n    case DWG_TYPE_ELLIPSE:\n      dwg_free_ELLIPSE (dat, obj);\n      break;\n    case DWG_TYPE_SPLINE:\n      dwg_free_SPLINE (dat, obj);\n      break;\n    case DWG_TYPE_REGION:\n      dwg_free_REGION (dat, obj);\n      break;\n    case DWG_TYPE__3DSOLID:\n      dwg_free__3DSOLID (dat, obj);\n      break; /* Check the type of the object */\n    case DWG_TYPE_BODY:\n      dwg_free_BODY (dat, obj);\n      break;\n    case DWG_TYPE_RAY:\n      dwg_free_RAY (dat, obj);\n      break;\n    case DWG_TYPE_XLINE:\n      dwg_free_XLINE (dat, obj);\n      break;\n    case DWG_TYPE_DICTIONARY:\n      dwg_free_DICTIONARY (dat, obj);\n      break;\n    case DWG_TYPE_MTEXT:\n      dwg_free_MTEXT (dat, obj);\n      break;\n    case DWG_TYPE_LEADER:\n      dwg_free_LEADER (dat, obj);\n      break;\n    case DWG_TYPE_TOLERANCE:\n      dwg_free_TOLERANCE (dat, obj);\n      break;\n    case DWG_TYPE_MLINE:\n      dwg_free_MLINE (dat, obj);\n      break;\n    case DWG_TYPE_BLOCK_CONTROL:\n      dwg_free_BLOCK_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_BLOCK_HEADER:\n      dwg_free_BLOCK_HEADER (dat, obj);\n      break;\n    case DWG_TYPE_LAYER_CONTROL:\n      dwg_free_LAYER_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_LAYER:\n      dwg_free_LAYER (dat, obj);\n      break;\n    case DWG_TYPE_STYLE_CONTROL:\n      dwg_free_STYLE_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_STYLE:\n      dwg_free_STYLE (dat, obj);\n      break;\n    case DWG_TYPE_LTYPE_CONTROL:\n      dwg_free_LTYPE_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_LTYPE:\n      dwg_free_LTYPE (dat, obj);\n      break;\n    case DWG_TYPE_VIEW_CONTROL:\n      dwg_free_VIEW_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_VIEW:\n      dwg_free_VIEW (dat, obj);\n      break;\n    case DWG_TYPE_UCS_CONTROL:\n      dwg_free_UCS_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_UCS:\n      dwg_free_UCS (dat, obj);\n      break;\n    case DWG_TYPE_VPORT_CONTROL:\n      dwg_free_VPORT_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_VPORT:\n      dwg_free_VPORT (dat, obj);\n      break;\n    case DWG_TYPE_APPID_CONTROL:\n      dwg_free_APPID_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_APPID:\n      dwg_free_APPID (dat, obj);\n      break;\n    case DWG_TYPE_DIMSTYLE_CONTROL:\n      dwg_free_DIMSTYLE_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_DIMSTYLE:\n      dwg_free_DIMSTYLE (dat, obj);\n      break;\n    case DWG_TYPE_VPORT_ENTITY_CONTROL:\n      dwg_free_VPORT_ENTITY_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_VPORT_ENTITY_HEADER:\n      dwg_free_VPORT_ENTITY_HEADER (dat, obj);\n      break;\n    case DWG_TYPE_GROUP:\n      dwg_free_GROUP (dat, obj);\n      break;\n    case DWG_TYPE_MLINESTYLE:\n      dwg_free_MLINESTYLE (dat, obj);\n      break;\n    case DWG_TYPE_OLE2FRAME:\n      dwg_free_OLE2FRAME (dat, obj);\n      break;\n    case DWG_TYPE_DUMMY:\n      dwg_free_DUMMY (dat, obj);\n      break;\n    case DWG_TYPE_LONG_TRANSACTION:\n      dwg_free_LONG_TRANSACTION (dat, obj);\n      break;\n    case DWG_TYPE_LWPOLYLINE:\n      dwg_free_LWPOLYLINE (dat, obj);\n      break;\n    case DWG_TYPE_HATCH:\n      dwg_free_HATCH (dat, obj);\n      break;\n    case DWG_TYPE_XRECORD:\n      dwg_free_XRECORD (dat, obj);\n      break;\n    case DWG_TYPE_PLACEHOLDER:\n      dwg_free_PLACEHOLDER (dat, obj);\n      break;\n    case DWG_TYPE_OLEFRAME:\n      dwg_free_OLEFRAME (dat, obj);\n      break;\n#ifdef DEBUG_VBA_PROJECT\n    case DWG_TYPE_VBA_PROJECT:\n      dwg_free_VBA_PROJECT (dat, obj);\n      break;\n#endif\n    case DWG_TYPE_LAYOUT:\n      dwg_free_LAYOUT (dat, obj);\n      break;\n    case DWG_TYPE_PROXY_ENTITY:\n      dwg_free_PROXY_ENTITY (dat, obj);\n      break;\n    case DWG_TYPE_PROXY_OBJECT:\n      dwg_free_PROXY_OBJECT (dat, obj);\n      break;\n    default:\n      if (obj->type == obj->parent->layout_type)\n        {\n          SINCE (R_13)\n          {\n            dwg_free_LAYOUT (dat, obj); // XXX avoid double-free, esp. in eed\n          }\n        }\n\n      else if ((error = dwg_free_variable_type (obj->parent, obj))\n               & DWG_ERR_UNHANDLEDCLASS)\n        {\n          int is_entity;\n          int i;\n          Dwg_Class *klass;\n\n        unhandled:\n          is_entity = 0;\n          i = obj->type - 500;\n          klass = NULL;\n\n          dwg = obj->parent;\n          if (dwg->dwg_class && i >= 0 && i < (int)dwg->num_classes)\n            {\n              klass = &dwg->dwg_class[i];\n              is_entity = klass ? dwg_class_is_entity (klass) : 0;\n            }\n          // indxf (and later injson) already creates some DEBUGGING classes\n          if (obj->fixedtype == DWG_TYPE_TABLE)\n            {\n              // just the preview, i.e. common. plus some colors: leak\n              dwg_free_UNKNOWN_ENT (dat, obj);\n            }\n          else if (obj->fixedtype == DWG_TYPE_DATATABLE)\n            {\n              dwg_free_UNKNOWN_OBJ (dat, obj);\n            }\n          else if (klass && !is_entity)\n            {\n              dwg_free_UNKNOWN_OBJ (dat, obj);\n            }\n          else if (klass && is_entity)\n            {\n              dwg_free_UNKNOWN_ENT (dat, obj);\n            }\n          else // not a class\n            {\n              FREE_IF (obj->tio.unknown);\n            }\n        }\n    }\n  /* With this importer the dxfname is dynamic, just the name is const */\n  if (dwg->opts & DWG_OPTS_INDXF)\n    FREE_IF (obj->dxfname);\n  obj->type = DWG_TYPE_FREED;\n}\n\nstatic int\ndwg_free_header_vars (Dwg_Data *dwg)\n{\n  Dwg_Header_Variables *_obj = &dwg->header_vars;\n  Dwg_Object *obj = NULL;\n  Bit_Chain *dat = &pdat;\n  // clang-format off\n  #include \"header_variables.spec\"\n  // clang-format on\n  return 0;\n}\n\nstatic int\ndwg_free_summaryinfo (Dwg_Data *dwg)\n{\n  struct Dwg_SummaryInfo *_obj = &dwg->summaryinfo;\n  Dwg_Object *obj = NULL;\n  Bit_Chain *dat = &pdat;\n  BITCODE_RL rcount1, rcount2;\n  // clang-format off\n  #include \"summaryinfo.spec\"\n  // clang-format on\n  return 0;\n}\n\nvoid\ndwg_free (Dwg_Data *dwg)\n{\n  BITCODE_BL i;\n  if (dwg)\n    {\n      pdat.version = dwg->header.version;\n      pdat.from_version = dwg->header.version;\n      if (dwg->opts)\n        {\n          loglevel = dwg->opts & DWG_OPTS_LOGLEVEL;\n          pdat.opts = dwg->opts;\n        }\n#ifdef USE_TRACING\n      /* Before starting, set the logging level, but only do so once.  */\n      if (!env_var_checked_p)\n        {\n          char *probe = getenv (\"LIBREDWG_TRACE\");\n          if (probe)\n            loglevel = atoi (probe);\n          env_var_checked_p = 1;\n        }\n#endif /* USE_TRACING */\n      LOG_INFO (\"\\n============\\ndwg_free\\n\")\n      // copied table fields have duplicate pointers, but are freed only once\n      for (i = 0; i < dwg->num_objects; ++i)\n        {\n          if (!dwg_obj_is_control (&dwg->object[i]))\n            dwg_free_object (&dwg->object[i]);\n        }\n      FREE_IF (dwg->header.section);\n      dwg_free_header_vars (dwg);\n      dwg_free_summaryinfo (dwg);\n      FREE_IF (dwg->thumbnail.chain);\n      if (dwg->header.section_infohdr.num_desc)\n        {\n          for (i = 0; i < dwg->header.section_infohdr.num_desc; ++i)\n            FREE_IF (dwg->header.section_info[i].sections);\n          FREE_IF (dwg->header.section_info);\n        }\n      for (i = 0; i < dwg->second_header.num_handlers; i++)\n        FREE_IF (dwg->second_header.handlers[i].data);\n      // auxheader has no strings\n      for (i = 0; i < dwg->num_objects; ++i)\n        {\n          if (dwg_obj_is_control (&dwg->object[i]))\n            dwg_free_object (&dwg->object[i]);\n        }\n      if (dwg->num_classes && dwg->dwg_class)\n        {\n          for (i = 0; i < dwg->num_classes; ++i)\n            {\n              FREE_IF (dwg->dwg_class[i].appname);\n              FREE_IF (dwg->dwg_class[i].cppname);\n              FREE_IF (dwg->dwg_class[i].dxfname);\n              if (dwg->header.version >= R_2007)\n                FREE_IF (dwg->dwg_class[i].dxfname_u);\n            }\n          FREE_IF (dwg->dwg_class);\n        }\n      if (dwg->object_ref)\n        {\n          LOG_HANDLE (\"free %d global refs\\n\", dwg->num_object_refs)\n          for (i = 0; i < dwg->num_object_refs; ++i)\n            {\n              //LOG_HANDLE (\"free ref %d\\n\", i)\n              FREE_IF (dwg->object_ref[i]);\n            }\n        }\n      FREE_IF (dwg->object_ref);\n      FREE_IF (dwg->object);\n      if (dwg->object_map)\n        hash_free (dwg->object_map);\n#undef FREE_IF\n    }\n}\n\n#undef IS_FREE\n"], "fixing_code": ["/*****************************************************************************/\n/*  LibreDWG - free implementation of the DWG file format                    */\n/*                                                                           */\n/*  Copyright (C) 2009-2010,2018-2019 Free Software Foundation, Inc.         */\n/*                                                                           */\n/*  This library is free software, licensed under the terms of the GNU       */\n/*  General Public License as published by the Free Software Foundation,     */\n/*  either version 3 of the License, or (at your option) any later version.  */\n/*  You should have received a copy of the GNU General Public License        */\n/*  along with this program.  If not, see <http://www.gnu.org/licenses/>.    */\n/*****************************************************************************/\n\n/*\n * dwg.h: main public header file (the other variant is dwg_api.h)\n *\n * written by Felipe Castro\n * modified by Felipe Corr\u00eaa da Silva Sances\n * modified by Rodrigo Rodrigues da Silva\n * modified by Till Heuschmann\n * modified by Reini Urban\n */\n\n#ifndef DWG_H\n#define DWG_H\n\n/* for uint64_t, but not in swig */\n#ifndef SWIGIMPORTED\n#  include <stdint.h>\n#  include <inttypes.h>\n\n/* wchar for R2007+ support\n * But we need the win32 UTF-16 variant, not UTF-32.\n * i.e. only on Windows, AIX, Solaris\n */\n# if defined(HAVE_WCHAR_H) && defined(SIZEOF_WCHAR_T) && SIZEOF_WCHAR_T == 2\n#  include <wchar.h>\n#  define HAVE_NATIVE_WCHAR2\n#  define DWGCHAR wchar_t\n#  define dwg_wchar_t wchar_t\n# endif\n#endif\n\n#ifndef EXPORT\n# ifdef SWIG\n#  define EXPORT extern\n# elif defined(_WIN32) && defined(ENABLE_SHARED)\n#  ifdef DLL_EXPORT\n#    define EXPORT  __declspec(dllexport)\n#  else\n#    define EXPORT  __declspec(dllimport)\n#  endif\n# elif defined(__clang__) || defined(__clang) || \\\n        (defined( __GNUC__) && ((__GNUC__ * 100) + __GNUC_MINOR__) >= 303)\n#  define EXPORT __attribute__((visibility(\"default\")))\n# else\n#  define EXPORT\n# endif\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#define BITCODE_DOUBLE double\n\n/* The FORMAT_* are for logging only */\ntypedef unsigned char BITCODE_RC;\n#ifdef _WIN32\n# define FORMAT_RC \"0x%2x\"\n#else\n# define FORMAT_RC \"0x%hhx\"\n#endif\n#define FORMAT_RCd \"%d\"\n#define FORMAT_RCu \"%u\"\ntypedef signed char BITCODE_RCd;\ntypedef unsigned char BITCODE_RCu;\ntypedef unsigned char BITCODE_B;\n#define FORMAT_B \"%d\"\ntypedef unsigned char BITCODE_BB;\n#define FORMAT_BB \"%u\"\n/* Since R24 */\ntypedef unsigned char BITCODE_3B;\n#define FORMAT_3B \"%u\"\n//#ifdef HAVE_STDINT_H\n//#define BITCODE_BS uint16_t\n//#define BITCODE_RS uint16_t\n//#define BITCODE_BL uint32_t\n//#define BITCODE_RL uint32_t\n//#define BITCODE_BLd int32_t\n//#define BITCODE_RLd int32_t\ntypedef uint16_t BITCODE_BS;\ntypedef int16_t BITCODE_BSd;\ntypedef uint16_t BITCODE_RS;\ntypedef uint16_t BITCODE_RSx;\ntypedef uint32_t BITCODE_BL;\ntypedef uint32_t BITCODE_BLx;\ntypedef int32_t BITCODE_BLd;\ntypedef uint32_t BITCODE_RL;\ntypedef uint32_t BITCODE_RLx;\ntypedef int32_t BITCODE_RLd;\n/* e.g. old cygwin 64 vs 32 */\n/*#else\n# if defined(__WORDSIZE) && __WORDSIZE == 64\n  typedef unsigned short int BITCODE_BS;\n  typedef unsigned short int BITCODE_RS;\n  typedef unsigned int BITCODE_BL;\n  typedef unsigned int BITCODE_RL;\n  typedef int BITCODE_BLd;\n  typedef int BITCODE_RLd;\n# else\n  typedef unsigned short int BITCODE_BS;\n  typedef unsigned short int BITCODE_RS;\n  typedef unsigned long BITCODE_BL;\n  typedef unsigned long BITCODE_RL;\n  typedef long BITCODE_BLd;\n  typedef long BITCODE_RLd;\n# endif\n#endif\n*/\n//#ifdef HAVE_INTTYPES_H\n#define FORMAT_BS \"%\" PRIu16\n#define FORMAT_BSd \"%\" PRId16\n#define FORMAT_RS \"%\" PRIu16\n#define FORMAT_RSx \"0x%\" PRIx16\n#define FORMAT_BL \"%\" PRIu32\n#define FORMAT_RL \"%\" PRIu32\n#define FORMAT_BLd \"%\" PRId32\n#define FORMAT_RLd \"%\" PRId32\n#define FORMAT_RLx \"0x%\" PRIx32\n#define FORMAT_BLX \"%\" PRIX32\n#define FORMAT_BLx \"0x%\" PRIx32\n/*#else\n# define FORMAT_BS \"%hu\"\n# define FORMAT_RS \"%hu\"\n# define FORMAT_BL \"%u\"\n# define FORMAT_RL \"%u\"\n# define FORMAT_BLd \"%d\"\n# define FORMAT_RLd \"%d\"\n# define FORMAT_BLX \"%X\"\n# define FORMAT_BLx \"%x\"\n#endif\n*/\ntypedef long BITCODE_MC;\n#define FORMAT_MC  \"%ld\"\ntypedef unsigned long BITCODE_UMC;\n#define FORMAT_UMC \"%lu\"\ntypedef BITCODE_BL BITCODE_MS;\n#define FORMAT_MS FORMAT_BL\ntypedef BITCODE_DOUBLE BITCODE_RD;\n#define FORMAT_RD \"%f\"\n/* Since R2004 */\ntypedef uint64_t BITCODE_RLL;\ntypedef uint64_t BITCODE_BLL;\n#define FORMAT_RLL \"0x%\" PRIx64\n#define FORMAT_BLL \"0x%\" PRIx64\n#ifndef HAVE_NATIVE_WCHAR2\n  typedef BITCODE_RS dwg_wchar_t;\n# define DWGCHAR dwg_wchar_t\n#endif\ntypedef char* BITCODE_TF;\n#define FORMAT_TF \"\\\"%s\\\"\"\ntypedef char* BITCODE_TV;\n#define FORMAT_TV \"\\\"%s\\\"\"\ntypedef BITCODE_DOUBLE BITCODE_BT;\n#define FORMAT_BT \"%f\"\ntypedef BITCODE_DOUBLE BITCODE_DD;\n#define FORMAT_DD \"%f\"\ntypedef BITCODE_DOUBLE BITCODE_BD;\n#define FORMAT_BD \"%f\"\ntypedef BITCODE_RC BITCODE_4BITS;\n#define FORMAT_4BITS \"%1x\"\n\n/* TODO: implement version dependent string parsing */\n/* encode codepages/utf8 */\n#define BITCODE_T  BITCODE_TV\n#ifdef HAVE_NATIVE_WCHAR2\n  typedef dwg_wchar_t* BITCODE_TU; /* native UCS-2 wchar_t */\n# define FORMAT_TU \"\\\"%ls\\\"\"\n#else\n  typedef BITCODE_RS* BITCODE_TU;  /* UCS-2 unicode text */\n# define FORMAT_TU \"\\\"%hn\\\"\"       /* will print garbage */\n#endif\n\ntypedef struct _dwg_time_bll\n{\n  BITCODE_BL days;\n  BITCODE_BL ms;\n  BITCODE_BD value;\n} Dwg_Bitcode_TimeBLL;\n\ntypedef struct _dwg_bitcode_2rd\n{\n  BITCODE_RD x;\n  BITCODE_RD y;\n} Dwg_Bitcode_2RD;\n\ntypedef struct _dwg_bitcode_2bd\n{\n  BITCODE_BD x;\n  BITCODE_BD y;\n} Dwg_Bitcode_2BD;\n\ntypedef struct _dwg_bitcode_3rd\n{\n  BITCODE_RD x;\n  BITCODE_RD y;\n  BITCODE_RD z;\n} Dwg_Bitcode_3RD;\n\ntypedef struct _dwg_bitcode_3bd\n{\n  BITCODE_BD x;\n  BITCODE_BD y;\n  BITCODE_BD z;\n} Dwg_Bitcode_3BD;\n\ntypedef Dwg_Bitcode_TimeBLL BITCODE_TIMEBLL;\ntypedef Dwg_Bitcode_TimeBLL BITCODE_TIMERLL;\n/* #define FORMAT_TIMEBLL FORMAT_BL \".\" FORMAT_BL */\ntypedef Dwg_Bitcode_2RD  BITCODE_2RD;\ntypedef Dwg_Bitcode_2BD  BITCODE_2BD;\ntypedef Dwg_Bitcode_2BD  BITCODE_2DPOINT;\ntypedef Dwg_Bitcode_2BD  BITCODE_2BD_1;\ntypedef Dwg_Bitcode_3RD  BITCODE_3RD;\ntypedef Dwg_Bitcode_3BD  BITCODE_3BD;\ntypedef Dwg_Bitcode_3BD  BITCODE_3DPOINT;\ntypedef Dwg_Bitcode_3BD  BITCODE_3BD_1;\ntypedef Dwg_Bitcode_3BD  BITCODE_BE;\n#define BITCODE_3DVECTOR BITCODE_3BD_1\n\ntypedef enum DWG_VERSION_TYPE\n{\n  R_INVALID,\n  R_1_1,\t/* MC0.0  MicroCAD Release 1.1 */\n  R_1_2,\t/* AC1.2  AutoCAD Release 1.2 */\n  R_1_4,\t/* AC1.4  AutoCAD Release 1.4 */\n  R_2_0,\t/* AC1.50 AutoCAD Release 2.0 */\n  R_2_1,\t/* AC2.10 AutoCAD Release 2.10 */\n  R_2_5,\t/* AC1002 AutoCAD Release 2.5 */\n  R_2_6,\t/* AC1003 AutoCAD Release 2.6 */\n  R_9,\t\t/* AC1004 AutoCAD Release 9 */\n  R_10,\t\t/* AC1006 AutoCAD Release 10 */\n  R_11,\t\t/* AC1009 AutoCAD Release 11/12 (LT R1/R2) */\n  R_13,\t\t/* AC1012 AutoCAD Release 13 */\n  R_14,\t\t/* AC1014 AutoCAD Release 14 */\n  R_2000,\t/* AC1015 AutoCAD Release 2000 */\n  R_2004,\t/* AC1018 AutoCAD Release 2004 */\n  R_2007,\t/* AC1021 AutoCAD Release 2007 */\n  R_2010,\t/* AC1024 AutoCAD Release 2010 */\n  R_2013,\t/* AC1027 AutoCAD Release 2013 */\n  R_2018,\t/* AC1032 AutoCAD Release 2018 */\n  R_AFTER\n} Dwg_Version_Type;\n#define DWG_VERSIONS (int)(R_AFTER+1)\n\n/**\n Object supertypes that exist in dwg-files.\n */\ntypedef enum DWG_OBJECT_SUPERTYPE\n{\n  DWG_SUPERTYPE_UNKNOWN, DWG_SUPERTYPE_ENTITY, DWG_SUPERTYPE_OBJECT\n} Dwg_Object_Supertype;\n\n/**\n Object and Entity types that exist in dwg-files.\n */\ntypedef enum DWG_OBJECT_TYPE\n{\n  DWG_TYPE_UNUSED = 0x00,\n  DWG_TYPE_TEXT = 0x01,\n  DWG_TYPE_ATTRIB = 0x02,\n  DWG_TYPE_ATTDEF = 0x03,\n  DWG_TYPE_BLOCK = 0x04,\n  DWG_TYPE_ENDBLK = 0x05,\n  DWG_TYPE_SEQEND = 0x06,\n  DWG_TYPE_INSERT = 0x07,\n  DWG_TYPE_MINSERT = 0x08,\n  /* DWG_TYPE_<UNKNOWN> = 0x09, */\n  DWG_TYPE_VERTEX_2D = 0x0a,\n  DWG_TYPE_VERTEX_3D = 0x0b,\n  DWG_TYPE_VERTEX_MESH = 0x0c,\n  DWG_TYPE_VERTEX_PFACE = 0x0d,\n  DWG_TYPE_VERTEX_PFACE_FACE = 0x0e,\n  DWG_TYPE_POLYLINE_2D = 0x0f,\n  DWG_TYPE_POLYLINE_3D = 0x10,\n  DWG_TYPE_ARC = 0x11,\n  DWG_TYPE_CIRCLE = 0x12,\n  DWG_TYPE_LINE = 0x13,\n  DWG_TYPE_DIMENSION_ORDINATE = 0x14,\n  DWG_TYPE_DIMENSION_LINEAR = 0x15,\n  DWG_TYPE_DIMENSION_ALIGNED = 0x16,\n  DWG_TYPE_DIMENSION_ANG3PT = 0x17,\n  DWG_TYPE_DIMENSION_ANG2LN = 0x18,\n  DWG_TYPE_DIMENSION_RADIUS = 0x19,\n  DWG_TYPE_DIMENSION_DIAMETER = 0x1A,\n  DWG_TYPE_POINT = 0x1b,\n  DWG_TYPE__3DFACE = 0x1c,\n  DWG_TYPE_POLYLINE_PFACE = 0x1d,\n  DWG_TYPE_POLYLINE_MESH = 0x1e,\n  DWG_TYPE_SOLID = 0x1f,\n  DWG_TYPE_TRACE = 0x20,\n  DWG_TYPE_SHAPE = 0x21,\n  DWG_TYPE_VIEWPORT = 0x22,\n  DWG_TYPE_ELLIPSE = 0x23,\n  DWG_TYPE_SPLINE = 0x24,\n  DWG_TYPE_REGION = 0x25,\n  DWG_TYPE__3DSOLID = 0x26,\n  DWG_TYPE_BODY = 0x27,\n  DWG_TYPE_RAY = 0x28,\n  DWG_TYPE_XLINE = 0x29,\n  DWG_TYPE_DICTIONARY = 0x2a,\n  DWG_TYPE_OLEFRAME = 0x2b,\n  DWG_TYPE_MTEXT = 0x2c,\n  DWG_TYPE_LEADER = 0x2d,\n  DWG_TYPE_TOLERANCE = 0x2e,\n  DWG_TYPE_MLINE = 0x2f,\n  DWG_TYPE_BLOCK_CONTROL = 0x30,\n  DWG_TYPE_BLOCK_HEADER = 0x31,\n  DWG_TYPE_LAYER_CONTROL = 0x32,\n  DWG_TYPE_LAYER = 0x33,\n  DWG_TYPE_STYLE_CONTROL = 0x34,\n  DWG_TYPE_STYLE = 0x35,\n  /* DWG_TYPE_<UNKNOWN> = 0x36, */\n  /* DWG_TYPE_<UNKNOWN> = 0x37, */\n  DWG_TYPE_LTYPE_CONTROL = 0x38,\n  DWG_TYPE_LTYPE = 0x39,\n  /* DWG_TYPE_<UNKNOWN> = 0x3a, */\n  /* DWG_TYPE_<UNKNOWN> = 0x3b, */\n  DWG_TYPE_VIEW_CONTROL = 0x3c,\n  DWG_TYPE_VIEW = 0x3d,\n  DWG_TYPE_UCS_CONTROL = 0x3e,\n  DWG_TYPE_UCS = 0x3f,\n  DWG_TYPE_VPORT_CONTROL = 0x40,\n  DWG_TYPE_VPORT = 0x41,\n  DWG_TYPE_APPID_CONTROL = 0x42,\n  DWG_TYPE_APPID = 0x43,\n  DWG_TYPE_DIMSTYLE_CONTROL = 0x44,\n  DWG_TYPE_DIMSTYLE = 0x45,\n  DWG_TYPE_VPORT_ENTITY_CONTROL = 0x46,\n  DWG_TYPE_VPORT_ENTITY_HEADER = 0x47,\n  DWG_TYPE_GROUP = 0x48,\n  DWG_TYPE_MLINESTYLE = 0x49,\n  DWG_TYPE_OLE2FRAME = 0x4a,\n  DWG_TYPE_DUMMY = 0x4b,\n  DWG_TYPE_LONG_TRANSACTION = 0x4c,\n  DWG_TYPE_LWPOLYLINE = 0x4d, /* ?? */\n  DWG_TYPE_HATCH = 0x4e,\n  DWG_TYPE_XRECORD = 0x4f,\n  DWG_TYPE_PLACEHOLDER = 0x50,\n  DWG_TYPE_VBA_PROJECT = 0x51,\n  DWG_TYPE_LAYOUT = 0x52,\n\n  DWG_TYPE_PROXY_ENTITY = 0x1f2, /* 498 */\n  DWG_TYPE_PROXY_OBJECT = 0x1f3, /* 499 */\n\n  /* non-fixed types > 500. not stored as type, but as fixedtype */\n\n  DWG_TYPE_ACSH_HISTORY_CLASS = 0x1ff + 1,\n  DWG_TYPE_ACSH_SWEEP_CLASS,\n  DWG_TYPE_ANNOTSCALEOBJECTCONTEXTDATA,\n  DWG_TYPE_ARCALIGNEDTEXT,\n  DWG_TYPE_ARC_DIMENSION,\n  DWG_TYPE_ASSOC2DCONSTRAINTGROUP,\n  DWG_TYPE_ASSOCACTION,\n  DWG_TYPE_ASSOCALIGNEDDIMACTIONBODY,\n  DWG_TYPE_ASSOCDEPENDENCY,\n  DWG_TYPE_ASSOCGEOMDEPENDENCY,\n  DWG_TYPE_ASSOCNETWORK,\n  DWG_TYPE_ASSOCOSNAPPOINTREFACTIONPARAM,\n  DWG_TYPE_ASSOCPERSSUBENTMANAGER,\n  DWG_TYPE_ASSOCPLANESURFACEACTIONBODY,\n  DWG_TYPE_ASSOCVERTEXACTIONPARAM,\n  DWG_TYPE_CAMERA,\n  DWG_TYPE_CELLSTYLEMAP,\n  DWG_TYPE_DATATABLE,\n  DWG_TYPE_DBCOLOR,\n  DWG_TYPE_DETAILVIEWSTYLE,\n  DWG_TYPE_DICTIONARYVAR,\n  DWG_TYPE_DICTIONARYWDFLT,\n  DWG_TYPE_DIMASSOC,\n  DWG_TYPE_DOCUMENTOPTIONS,\n  DWG_TYPE_DYNAMICBLOCKPURGEPREVENTER,\n  DWG_TYPE_EVALUATION_GRAPH,\n  DWG_TYPE_FIELD,\n  DWG_TYPE_FIELDLIST,\n  DWG_TYPE_GEODATA,\n  DWG_TYPE_GEOMAPIMAGE,\n  DWG_TYPE_GEOPOSITIONMARKER,\n  DWG_TYPE_HELIX,\n  DWG_TYPE_IDBUFFER,\n  DWG_TYPE_IMAGE,\n  DWG_TYPE_IMAGEDEF,\n  DWG_TYPE_IMAGEDEF_REACTOR,\n  DWG_TYPE_LAYER_FILTER,\n  DWG_TYPE_LAYER_INDEX,\n  DWG_TYPE_LAYOUTPRINTCONFIG,\n  DWG_TYPE_LIGHT,\n  DWG_TYPE_LIGHTLIST,\n  DWG_TYPE_MATERIAL,\n  DWG_TYPE_MESH,\n  DWG_TYPE_MLEADERSTYLE,\n  DWG_TYPE_MULTILEADER,\n  DWG_TYPE_NAVISWORKSMODELDEF,\n  DWG_TYPE_NPOCOLLECTION,\n  DWG_TYPE_OBJECTCONTEXTDATA,\n  DWG_TYPE_OBJECT_PTR,\n  DWG_TYPE_PERSSUBENTMANAGER,\n  DWG_TYPE_PLOTSETTINGS,\n  DWG_TYPE_POINTCLOUD,\n  DWG_TYPE_RASTERVARIABLES,\n  DWG_TYPE_RENDERENVIRONMENT,\n  DWG_TYPE_RENDERGLOBAL,\n  DWG_TYPE_MENTALRAYRENDERSETTINGS,\n  DWG_TYPE_RAPIDRTRENDERENVIRONMENT,\n  DWG_TYPE_RAPIDRTRENDERSETTINGS,\n  DWG_TYPE_RTEXT,\n  DWG_TYPE_SCALE,\n  DWG_TYPE_SECTIONVIEWSTYLE,\n  DWG_TYPE_SORTENTSTABLE,\n  DWG_TYPE_SPATIAL_FILTER,\n  DWG_TYPE_SPATIAL_INDEX,\n  DWG_TYPE_SUN,\n  DWG_TYPE_SUNSTUDY,\n  DWG_TYPE_PLANESURFACE,\n  DWG_TYPE_EXTRUDEDSURFACE,\n  DWG_TYPE_LOFTEDSURFACE,\n  DWG_TYPE_REVOLVEDSURFACE,\n  DWG_TYPE_SWEPTSURFACE,\n  DWG_TYPE_TABLE,\n  DWG_TYPE_TABLECONTENT,\n  DWG_TYPE_TABLEGEOMETRY,\n  DWG_TYPE_TABLESTYLE,\n  DWG_TYPE_UNDERLAY, /* not separate DGN,DWF,PDF types */\n  DWG_TYPE_UNDERLAYDEFINITION, /* not separate DGN,DWF,PDF types */\n  DWG_TYPE_VISUALSTYLE,\n  DWG_TYPE_WIPEOUT,\n  DWG_TYPE_WIPEOUTVARIABLES,\n  DWG_TYPE_XREFPANELOBJECT,\n  // after 1.0 add new types here for binary compat\n\n  DWG_TYPE_FREED       = 0xfffd,\n  DWG_TYPE_UNKNOWN_ENT = 0xfffe,\n  DWG_TYPE_UNKNOWN_OBJ = 0xffff,\n} Dwg_Object_Type;\n\n/**\n Error codes returned.\n */\ntypedef enum DWG_ERROR\n{\n  DWG_NOERR = 0,\n  /* sorted by severity */\n  DWG_ERR_WRONGCRC         = 1,\n  DWG_ERR_NOTYETSUPPORTED  = 1 << 1, /* 2 */\n  DWG_ERR_UNHANDLEDCLASS   = 1 << 2, /* 4 */\n  DWG_ERR_INVALIDTYPE      = 1 << 3, /* 8 */\n  DWG_ERR_INVALIDHANDLE    = 1 << 4, /* 16 */\n  DWG_ERR_INVALIDEED       = 1 << 5, /* 32 */\n  DWG_ERR_VALUEOUTOFBOUNDS = 1 << 6, /* 64 */\n  /* -------- critical errors ------- */\n  DWG_ERR_CLASSESNOTFOUND  = 1 << 7, /* 128 */\n  DWG_ERR_SECTIONNOTFOUND  = 1 << 8, /* 256 */\n  DWG_ERR_PAGENOTFOUND     = 1 << 9, /* 512 */\n  DWG_ERR_INTERNALERROR    = 1 << 10,/* 1024 */\n  DWG_ERR_INVALIDDWG       = 1 << 11,/* 2048 */\n  DWG_ERR_IOERROR          = 1 << 12,/* 4096 */\n  DWG_ERR_OUTOFMEM         = 1 << 13,/* 8192 */\n\n} Dwg_Error;\n#define DWG_ERR_CRITICAL DWG_ERR_CLASSESNOTFOUND\n\n/**\n   handles resolve absolute or relative indices to objects.\n\n   code 2-5: represents the type of the relation: hard/soft, owner/id.\n\n   code TYPEDOBJHANDLE:\n    2 Soft owner,\n    3 Hard owner,\n    4 Soft pointer,\n    5 Hard pointer\n\n   code > 6: the handle is stored as an offset from some other handle.\n\n   code OFFSETOBJHANDLE for soft owners or pointers:\n    6 ref + 1,\n    8 ref - 1,\n    a ref + offset,\n    c ref - offset\n\n  See \\ref Dwg_Handle\n */\ntypedef struct _dwg_handle\n{\n  BITCODE_RC code; /*!< OFFSETOBJHANDLE if > 6 */\n  BITCODE_RC size;\n  unsigned long value;\n} Dwg_Handle;\n\n#define FORMAT_H \"%u.%u.%lX\"\n#define ARGS_H(hdl) (hdl).code, (hdl).size, (hdl).value\n#define FORMAT_REF \"(%u.%u.%lX) abs:%lX\"\n#define ARGS_REF(ref) (ref)->handleref.code, (ref)->handleref.size, \\\n    (ref)->handleref.value, (ref)->absolute_ref\n\n/**\nobject references: obj is resolved by handleref (e.g. via\ndwg_resolve_handleref) when reading a DWG to the respective \\ref\nDwg_Object, and absolute_ref is resolved to the global\n_dwg_struct::object_ref index. It is the same as the hex number in the\nDXF handles.\n\nUsed as \\ref Dwg_Object_Ref\n*/\ntypedef struct _dwg_object_ref\n{\n  struct _dwg_object* obj;\n  Dwg_Handle handleref;\n  unsigned long absolute_ref;\n} Dwg_Object_Ref;\n\ntypedef Dwg_Object_Ref* BITCODE_H;\n\n/**\n CMC or ENC colors: color index or rgb value. layers are off when the index\n is negative.\n Used as \\ref Dwg_Color\n */\ntypedef struct _dwg_color /* CmColor: R15 and earlier */\n{\n  BITCODE_BSd index;  /* <0: turned off. 0: BYBLOCK, 256: BYLAYER */\n  BITCODE_BS flag;    /* 1: name follows, 2: book name follows, ... */\n  BITCODE_BL rgb;     /* DXF 420 */\n  BITCODE_H  handle;\n  BITCODE_T  name;    /* DXF 430 */\n  BITCODE_T  book_name;\n  BITCODE_BB alpha_type; /* 0 BYLAYER, 1 BYBLOCK, 3 alpha */\n  BITCODE_RC alpha;      /* DXF 440. 0-255 */\n} Dwg_Color;\n\ntypedef Dwg_Color BITCODE_CMC;\ntypedef Dwg_Color BITCODE_ENC;\n\n/**\n ASCII or Unicode text in xdata \\ref Dwg_Resbuf\n */\nstruct _dwg_binary_chunk\n{\n  short size;\n  int  codepage;\n  union {\n    char *data;\n    DWGCHAR *wdata;\n  } u;\n};\n\n/**\n result buffers: xdata linked list of dxf group - value pairs.\n Used as \\ref Dwg_Resbuf\n */\ntypedef struct _dwg_resbuf\n{\n  short type;\n  union\n  {\n    double  pt[3];\n    char    i8;\n    short   i16;\n    int     i32;\n    BITCODE_BLL i64;\n    double  dbl;\n    unsigned char hdl[8];\n    Dwg_Handle h;\n    struct _dwg_binary_chunk str;\n  } value;\n  struct _dwg_resbuf *next; /* FIXME: this is a perl keyword */\n} Dwg_Resbuf;\n\n/**\n \\struct Dwg_Header_Variables\n DWG header variables for all versions.\n If uppercase related to the DXF HEADER $ name.\n\n \\ref _dwg_header_variables\n */\ntypedef struct _dwg_header_variables {\n  BITCODE_RL size;\n  BITCODE_RL bitsize_hi;   /*!< r2010+ */\n  BITCODE_RL bitsize;\n  BITCODE_RC ACADMAINTVER; /*!< r13+ */\n  BITCODE_BLL REQUIREDVERSIONS; /*!< r2013+ */\n  BITCODE_TV DWGCODEPAGE;  /*!< r10+ */\n  BITCODE_BD unknown_0; /* 412148564080.0 */\n  BITCODE_BD unknown_1; /* 1.0 */\n  BITCODE_BD unknown_2; /* 1.0 */\n  BITCODE_BD unknown_3; /* 1.0 */\n  BITCODE_TV unknown_text1; /* \"\" 4x pre 2007... */\n  BITCODE_TV unknown_text2; /* \"\" */\n  BITCODE_TV unknown_text3; /* \"\" */\n  BITCODE_TV unknown_text4; /* \"\" */\n  BITCODE_BL unknown_8; /* 24L */\n  BITCODE_BL unknown_9; /* 0L */\n  BITCODE_BS unknown_10; /* 0 r13-r14 */\n  BITCODE_H VPORT_ENTITY_HEADER; /*!< r11-r2000 */\n  BITCODE_B DIMASO;\n  BITCODE_B DIMSHO;\n  BITCODE_B DIMSAV; /* undocumented */\n  BITCODE_B PLINEGEN;\n  BITCODE_B ORTHOMODE;\n  BITCODE_B REGENMODE;\n  BITCODE_B FILLMODE;\n  BITCODE_B QTEXTMODE;\n  BITCODE_B PSLTSCALE;\n  BITCODE_B LIMCHECK;\n  BITCODE_B BLIPMODE;\n  BITCODE_B unknown_11;\n  BITCODE_B USRTIMER;\n  BITCODE_B SKPOLY;\n  BITCODE_B ANGDIR;\n  BITCODE_B SPLFRAME;\n  BITCODE_B ATTREQ;\n  BITCODE_B ATTDIA;\n  BITCODE_B MIRRTEXT;\n  BITCODE_B WORLDVIEW;\n  BITCODE_B WIREFRAME; /* Undocumented */\n  BITCODE_B TILEMODE;\n  BITCODE_B PLIMCHECK;\n  BITCODE_B VISRETAIN;\n  BITCODE_B DELOBJ;\n  BITCODE_B DISPSILH;\n  BITCODE_B PELLIPSE;\n  BITCODE_BS SAVEIMAGES; //some r13 only\n  BITCODE_BS PROXYGRAPHICS;\n  BITCODE_BS MEASUREMENT; /* 0 English, 1 Metric. Stored as Section 4 */\n  BITCODE_BS DRAGMODE;\n  BITCODE_BS TREEDEPTH;\n  BITCODE_BS LUNITS;\n  BITCODE_BS LUPREC;\n  BITCODE_BS AUNITS;\n  BITCODE_BS AUPREC;\n  BITCODE_BS OSMODE;\n  BITCODE_BS ATTMODE;\n  BITCODE_BS COORDS;\n  BITCODE_BS PDMODE;\n  BITCODE_BS PICKSTYLE;\n  BITCODE_BL unknown_12;\n  BITCODE_BL unknown_13;\n  BITCODE_BL unknown_14;\n  BITCODE_BS USERI1;\n  BITCODE_BS USERI2;\n  BITCODE_BS USERI3;\n  BITCODE_BS USERI4;\n  BITCODE_BS USERI5;\n  BITCODE_BS SPLINESEGS;\n  BITCODE_BS SURFU;\n  BITCODE_BS SURFV;\n  BITCODE_BS SURFTYPE;\n  BITCODE_BS SURFTAB1;\n  BITCODE_BS SURFTAB2;\n  BITCODE_BS SPLINETYPE;\n  BITCODE_BS SHADEDGE;\n  BITCODE_BS SHADEDIF;\n  BITCODE_BS UNITMODE;\n  BITCODE_BS MAXACTVP;\n  BITCODE_BS ISOLINES;\n  BITCODE_BS CMLJUST;\n  BITCODE_BS TEXTQLTY;\n  BITCODE_BL unknown_14b;\n  BITCODE_BD LTSCALE;\n  BITCODE_BD TEXTSIZE;\n  BITCODE_BD TRACEWID;\n  BITCODE_BD SKETCHINC;\n  BITCODE_BD FILLETRAD;\n  BITCODE_BD THICKNESS;\n  BITCODE_BD ANGBASE;\n  BITCODE_BD PDSIZE;\n  BITCODE_BD PLINEWID;\n  BITCODE_BD USERR1;\n  BITCODE_BD USERR2;\n  BITCODE_BD USERR3;\n  BITCODE_BD USERR4;\n  BITCODE_BD USERR5;\n  BITCODE_BD CHAMFERA;\n  BITCODE_BD CHAMFERB;\n  BITCODE_BD CHAMFERC;\n  BITCODE_BD CHAMFERD;\n  BITCODE_BD FACETRES;\n  BITCODE_BD CMLSCALE;\n  BITCODE_BD CELTSCALE;\n  BITCODE_TV MENU;\n  BITCODE_TIMEBLL TDCREATE;\n  BITCODE_TIMEBLL TDUPDATE;\n  BITCODE_TIMEBLL TDUCREATE;\n  BITCODE_TIMEBLL TDUUPDATE;\n  BITCODE_BL unknown_15;\n  BITCODE_BL unknown_16;\n  BITCODE_BL unknown_17;\n  BITCODE_TIMEBLL TDINDWG;\n  BITCODE_TIMEBLL TDUSRTIMER;\n  BITCODE_CMC CECOLOR;\n  //BITCODE_RS CECOLOR_idx; /* <r13 */\n  BITCODE_BS HANDLING; /* <r14: default 1 */\n  //BITCODE_RS HANDSEED_R11;\n  BITCODE_H HANDSEED;\n  BITCODE_H CLAYER;\n  BITCODE_H TEXTSTYLE;\n  BITCODE_H CELTYPE;\n  BITCODE_H CMATERIAL;\n  BITCODE_H DIMSTYLE;\n  BITCODE_H CMLSTYLE;\n  BITCODE_BD PSVPSCALE;\n  BITCODE_3BD PINSBASE;\n  BITCODE_3BD PEXTMIN;\n  BITCODE_3BD PEXTMAX;\n  BITCODE_2RD PLIMMIN;\n  BITCODE_2RD PLIMMAX;\n  BITCODE_BD  PELEVATION;\n  BITCODE_3BD PUCSORG;\n  BITCODE_3BD PUCSXDIR;\n  BITCODE_3BD PUCSYDIR;\n  BITCODE_H PUCSNAME;\n  BITCODE_H PUCSBASE;\n  BITCODE_H PUCSORTHOREF;\n  BITCODE_BS PUCSORTHOVIEW;\n  BITCODE_3BD PUCSORGTOP;\n  BITCODE_3BD PUCSORGBOTTOM;\n  BITCODE_3BD PUCSORGLEFT;\n  BITCODE_3BD PUCSORGRIGHT;\n  BITCODE_3BD PUCSORGFRONT;\n  BITCODE_3BD PUCSORGBACK;\n  BITCODE_3BD INSBASE;\n  BITCODE_3BD EXTMIN;\n  BITCODE_3BD EXTMAX;\n  BITCODE_2RD LIMMIN;\n  BITCODE_2RD LIMMAX;\n  BITCODE_2RD VIEWCTR;  /* -r11 */\n  BITCODE_BD ELEVATION;\n  BITCODE_RD VIEWSIZE;  /* -r11 */\n  BITCODE_RS SNAPMODE;  /* -r11 */\n  BITCODE_2RD SNAPUNIT; /* -r11 */\n  BITCODE_2RD SNAPBASE; /* -r11 */\n  BITCODE_RD SNAPANG;   /* -r11 */\n  BITCODE_RS SNAPSTYL;  /* -r11 */\n  BITCODE_RS SNAPISOPAIR; /* -r11 */\n  BITCODE_RS GRIDMODE;  /* -r11 */\n  BITCODE_2RD GRIDUNIT; /* -r11 */\n  BITCODE_3BD UCSORG;\n  BITCODE_3BD UCSXDIR;\n  BITCODE_3BD UCSYDIR;\n  BITCODE_H UCSNAME;\n  BITCODE_H UCSBASE;\n  BITCODE_BS UCSORTHOVIEW;\n  BITCODE_H UCSORTHOREF;\n  BITCODE_3BD UCSORGTOP;\n  BITCODE_3BD UCSORGBOTTOM;\n  BITCODE_3BD UCSORGLEFT;\n  BITCODE_3BD UCSORGRIGHT;\n  BITCODE_3BD UCSORGFRONT;\n  BITCODE_3BD UCSORGBACK;\n  BITCODE_TV DIMPOST;\n  BITCODE_TV DIMAPOST;\n  BITCODE_B DIMTOL;\n  BITCODE_B DIMLIM;\n  BITCODE_B DIMTIH;\n  BITCODE_B DIMTOH;\n  BITCODE_B DIMSE1;\n  BITCODE_B DIMSE2;\n  BITCODE_B DIMALT;\n  BITCODE_B DIMTOFL;\n  BITCODE_B DIMSAH;\n  BITCODE_B DIMTIX;\n  BITCODE_B DIMSOXD;\n  BITCODE_BS DIMALTD;   /*!< r13-r14 only RC */\n  BITCODE_BS DIMZIN;    /*!< r13-r14 only RC */\n  BITCODE_B DIMSD1;\n  BITCODE_B DIMSD2;\n  BITCODE_BS DIMTOLJ;   /*!< r13-r14 only RC */\n  BITCODE_BS DIMJUST;   /*!< r13-r14 only RC */\n  BITCODE_BS DIMFIT;    /*!< r13-r14 only RC */\n  BITCODE_B DIMUPT;\n  BITCODE_BS DIMTZIN;   /*!< r13-r14 only RC */\n  BITCODE_BS DIMMALTZ;  /*!< r13-r14 only RC */\n  BITCODE_BS DIMMALTTZ; /*!< r13-r14 only RC */\n  BITCODE_BS DIMTAD;    /*!< r13-r14 only RC */\n  BITCODE_BS DIMUNIT;\n  BITCODE_BS DIMAUNIT;\n  BITCODE_BS DIMDEC;\n  BITCODE_BS DIMTDEC;\n  BITCODE_BS DIMALTU;\n  BITCODE_BS DIMALTTD;\n  BITCODE_H DIMTXSTY;\n  BITCODE_BD DIMSCALE;\n  BITCODE_BD DIMASZ;\n  BITCODE_BD DIMEXO;\n  BITCODE_BD DIMDLI;\n  BITCODE_BD DIMEXE;\n  BITCODE_BD DIMRND;\n  BITCODE_BD DIMDLE;\n  BITCODE_BD DIMTP;\n  BITCODE_BD DIMTM;\n  BITCODE_BD DIMFXL;\n  BITCODE_BD DIMJOGANG;\n  BITCODE_BS DIMTFILL;\n  BITCODE_CMC DIMTFILLCLR;\n  BITCODE_BS DIMAZIN;\n  BITCODE_BS DIMARCSYM;\n  BITCODE_BD DIMTXT;\n  BITCODE_BD DIMCEN;\n  BITCODE_BD DIMTSZ;\n  BITCODE_BD DIMALTF;\n  BITCODE_BD DIMLFAC;\n  BITCODE_BD DIMTVP;\n  BITCODE_BD DIMTFAC;\n  BITCODE_BD DIMGAP;\n  BITCODE_T DIMPOST_T; /* preR13 => handle */\n  BITCODE_T DIMAPOST_T;\n  BITCODE_T DIMBLK_T;\n  BITCODE_T DIMBLK1_T;\n  BITCODE_T DIMBLK2_T;\n  BITCODE_BD DIMALTRND;\n  BITCODE_RS DIMCLRD_C; /* preR13 => CMC */\n  BITCODE_RS DIMCLRE_C;\n  BITCODE_RS DIMCLRT_C;\n  BITCODE_CMC DIMCLRD;\n  BITCODE_CMC DIMCLRE;\n  BITCODE_CMC DIMCLRT;\n  BITCODE_BS DIMADEC;   /*!< r2000+ ... */\n  BITCODE_BS DIMFRAC;\n  BITCODE_BS DIMLUNIT;\n  BITCODE_BS DIMDSEP;\n  BITCODE_BS DIMTMOVE;\n  BITCODE_BS DIMALTZ;\n  BITCODE_BS DIMALTTZ;\n  BITCODE_BS DIMATFIT;\n  BITCODE_B  DIMFXLON;  /*!< r2007+ */\n  BITCODE_B  DIMTXTDIRECTION; /*!< r2010+ */\n  BITCODE_BD DIMALTMZF; /*!< r2010+ */\n  BITCODE_T  DIMALTMZS; /*!< r2010+ */\n  BITCODE_BD DIMMZF;    /*!< r2010+ */\n  BITCODE_T  DIMMZS;    /*!< r2010+ */\n  /*BITCODE_H DIMTXSTY;*/  /*!< r2000+ */\n  BITCODE_H DIMLDRBLK;  /*!< r2000+ */\n  BITCODE_H DIMBLK;     /*!< r2000+ */\n  BITCODE_H DIMBLK1;    /*!< r2000+ */\n  BITCODE_H DIMBLK2;    /*!< r2000+ */\n  BITCODE_H DIMLTYPE; /*!< r2007+ */\n  BITCODE_H DIMLTEX1; /*!< r2007+ */\n  BITCODE_H DIMLTEX2; /*!< r2007+ */\n  BITCODE_BSd DIMLWD;  /*!< r2000+ */\n  BITCODE_BSd DIMLWE;  /*!< r2000+ */\n  BITCODE_H BLOCK_CONTROL_OBJECT;\n  BITCODE_H LAYER_CONTROL_OBJECT;\n  BITCODE_H STYLE_CONTROL_OBJECT;\n  BITCODE_H LTYPE_CONTROL_OBJECT;\n  BITCODE_H VIEW_CONTROL_OBJECT;\n  BITCODE_H UCS_CONTROL_OBJECT;\n  BITCODE_H VPORT_CONTROL_OBJECT;\n  BITCODE_H APPID_CONTROL_OBJECT;\n  BITCODE_H DIMSTYLE_CONTROL_OBJECT;\n  BITCODE_H VPORT_ENTITY_CONTROL_OBJECT; /*!< r11-r2000 */\n  BITCODE_H DICTIONARY_ACAD_GROUP;\n  BITCODE_H DICTIONARY_ACAD_MLINESTYLE;\n  BITCODE_H DICTIONARY_NAMED_OBJECT;\n  BITCODE_BS TSTACKALIGN;           /*!< r2000+ */\n  BITCODE_BS TSTACKSIZE;            /*!< r2000+ */\n  BITCODE_TV HYPERLINKBASE;         /*!< r2000+ */\n  BITCODE_TV STYLESHEET;            /*!< r2000+ */\n  BITCODE_H DICTIONARY_LAYOUT;      /*!< r2000+ */\n  BITCODE_H DICTIONARY_PLOTSETTINGS;   /*!< r2000+ */\n  BITCODE_H DICTIONARY_PLOTSTYLENAME;  /*!< r2000+ */\n  BITCODE_H DICTIONARY_MATERIAL;    /*!< r2004+ */\n  BITCODE_H DICTIONARY_COLOR;       /*!< r2004+ */\n  BITCODE_H DICTIONARY_VISUALSTYLE; /*!< r2007+ */\n  BITCODE_H DICTIONARY_LIGHTLIST;   /*!< r2010+ ?? */\n  BITCODE_H unknown_20;             /*!< r2013+ */\n  BITCODE_BL FLAGS;\n  BITCODE_BSd CELWEIGHT; /* = FLAGS & 0x1f, see dxf_cvt_lweight() DXF 370 (int16) */\n  BITCODE_B  ENDCAPS;   /* = FLAGS & 0x60 */\n  BITCODE_B  JOINSTYLE; /* = FLAGS & 0x180 */\n  BITCODE_B  LWDISPLAY; /* = !(FLAGS & 0x200) */\n  BITCODE_B  XEDIT;     /* = !(FLAGS & 0x400) */\n  BITCODE_B  EXTNAMES;  /* = FLAGS & 0x800 */\n  BITCODE_B  PSTYLEMODE; /* = FLAGS & 0x2000 */\n  BITCODE_B  OLESTARTUP; /* = FLAGS & 0x4000 */\n  BITCODE_BS INSUNITS;\n  BITCODE_BS CEPSNTYPE;\n  BITCODE_H CPSNID;\n  BITCODE_TV FINGERPRINTGUID;\n  BITCODE_TV VERSIONGUID;\n  BITCODE_RC SORTENTS;\n  BITCODE_RC INDEXCTL;\n  BITCODE_RC HIDETEXT;\n  BITCODE_RC XCLIPFRAME;\n  BITCODE_RC DIMASSOC;\n  BITCODE_RC HALOGAP;\n  BITCODE_BS OBSCOLOR;\n  BITCODE_BS INTERSECTIONCOLOR;\n  BITCODE_RC OBSLTYPE;\n  BITCODE_RC INTERSECTIONDISPLAY;\n  BITCODE_TV PROJECTNAME;\n  BITCODE_H BLOCK_RECORD_PSPACE;\n  BITCODE_H BLOCK_RECORD_MSPACE;\n  BITCODE_H LTYPE_BYLAYER;\n  BITCODE_H LTYPE_BYBLOCK;\n  BITCODE_H LTYPE_CONTINUOUS;\n  BITCODE_B CAMERADISPLAY; /*!< r2007+ ... */\n  BITCODE_BL unknown_21;\n  BITCODE_BL unknown_22;\n  BITCODE_BD unknown_23;\n  BITCODE_BD STEPSPERSEC;\n  BITCODE_BD STEPSIZE;\n  BITCODE_BD _3DDWFPREC;\n  BITCODE_BD LENSLENGTH;\n  BITCODE_BD CAMERAHEIGHT;\n  BITCODE_RC SOLIDHIST;\n  BITCODE_RC SHOWHIST;\n  BITCODE_BD PSOLWIDTH;\n  BITCODE_BD PSOLHEIGHT;\n  BITCODE_BD LOFTANG1;\n  BITCODE_BD LOFTANG2;\n  BITCODE_BD LOFTMAG1;\n  BITCODE_BD LOFTMAG2;\n  BITCODE_BS LOFTPARAM;\n  BITCODE_RC LOFTNORMALS;\n  BITCODE_BD LATITUDE;\n  BITCODE_BD LONGITUDE;\n  BITCODE_BD NORTHDIRECTION;\n  BITCODE_BL TIMEZONE;\n  BITCODE_RC LIGHTGLYPHDISPLAY;\n  BITCODE_RC TILEMODELIGHTSYNCH;\n  BITCODE_RC DWFFRAME;\n  BITCODE_RC DGNFRAME;\n  BITCODE_B REALWORLDSCALE;\n  BITCODE_CMC INTERFERECOLOR;\n  BITCODE_H INTERFEREOBJVS;\n  BITCODE_H INTERFEREVPVS;\n  BITCODE_H DRAGVS;\n  BITCODE_RC CSHADOW;\n  BITCODE_BD SHADOWPLANELOCATION;\n  BITCODE_BS unknown_54; /*!< r14+ ... optional */\n  BITCODE_BS unknown_55;\n  BITCODE_BS unknown_56;\n  BITCODE_BS unknown_57;\n} Dwg_Header_Variables;\n\n/* OBJECTS *******************************************************************/\n/**\n UNUSED (0) entity. Unknown entities are stored as blob\n */\ntypedef int Dwg_Entity_UNUSED;\n\n/** \\ref Dwg_Entity_TEXT\n TEXT (1) entity\n */\ntypedef struct _dwg_entity_TEXT\n{\n  struct _dwg_object_entity *parent;\n\n  BITCODE_RC dataflags;        /*!< r2000+ */\n  BITCODE_RD elevation;        /*!< DXF 30 (z coord of 10), when dataflags & 1 */\n  BITCODE_2DPOINT insertion_pt; /*!< DXF 10 */\n  BITCODE_2DPOINT alignment_pt; /*!< DXF 11. optional, when dataflags & 2, i.e 72/73 != 0 */\n  BITCODE_BE extrusion;       /*!< DXF 210. Default 0,0,1 */\n  BITCODE_RD thickness;       /*!< DXF 39 */\n  BITCODE_RD oblique_ang;     /*!< DXF 51 */\n  BITCODE_RD rotation;        /*!< DXF 50 */\n  BITCODE_RD height;          /*!< DXF 40 */\n  BITCODE_RD width_factor;    /*!< DXF 41 */\n  BITCODE_TV text_value;      /*!< DXF 1 */\n  BITCODE_BS generation;      /*!< DXF 71 */\n  BITCODE_BS horiz_alignment; /*!< DXF 72. options 0-5:\n                                 0 = Left; 1= Center; 2 = Right; 3 = Aligned;\n                                 4 = Middle; 5 = Fit */\n  BITCODE_BS vert_alignment;  /*!< DXF 73. options 0-3:\n                                 0 = Baseline; 1 = Bottom; 2 = Middle; 3 = Top */\n  BITCODE_H style;\n} Dwg_Entity_TEXT;\n\n/** \\ref Dwg_Entity_ATTRIB\n ATTRIB (2) entity\n */\ntypedef struct _dwg_entity_ATTRIB\n{\n  struct _dwg_object_entity *parent;\n\n  BITCODE_BD elevation;\n  BITCODE_2DPOINT insertion_pt;\n  BITCODE_2DPOINT alignment_pt;\n  BITCODE_BE extrusion;\n  BITCODE_RD thickness;\n  BITCODE_RD oblique_ang;\n  BITCODE_RD rotation;\n  BITCODE_RD height;\n  BITCODE_RD width_factor;\n  BITCODE_TV text_value;\n  BITCODE_BS generation;\n  BITCODE_BS horiz_alignment;\n  BITCODE_BS vert_alignment;\n  BITCODE_RC dataflags;\n  BITCODE_RC class_version; /* R2010+ */\n  BITCODE_RC type;    /* R2018+ */\n  BITCODE_TV tag;\n  BITCODE_BS field_length; /* DXF 73 but unused */\n  BITCODE_RC flags;\n  BITCODE_B lock_position_flag;\n  BITCODE_H style;\n  BITCODE_H mtext_handles; /* R2018+ TODO */\n  BITCODE_BS annotative_data_size; /* R2018+ */\n  BITCODE_RC annotative_data_bytes;\n  BITCODE_H  annotative_app;\n  BITCODE_BS annotative_short;\n} Dwg_Entity_ATTRIB;\n\n/** \\ref Dwg_Entity_ATTDEF\n ATTDEF (3) entity\n */\ntypedef struct _dwg_entity_ATTDEF\n{\n  struct _dwg_object_entity *parent;\n\n  BITCODE_BD elevation;\n  BITCODE_2DPOINT insertion_pt;\n  BITCODE_2DPOINT alignment_pt;\n  BITCODE_BE extrusion;\n  BITCODE_RD thickness;\n  BITCODE_RD oblique_ang;\n  BITCODE_RD rotation;\n  BITCODE_RD height;\n  BITCODE_RD width_factor;\n  BITCODE_TV default_value;\n  BITCODE_BS generation;\n  BITCODE_BS horiz_alignment;\n  BITCODE_BS vert_alignment;\n  BITCODE_RC dataflags;\n  BITCODE_RC class_version; /* R2010+ */\n  BITCODE_RC type;    /* R2018+ */\n  BITCODE_TV tag;\n  BITCODE_BS field_length;\n  BITCODE_RC flags;\n  BITCODE_B lock_position_flag;\n  BITCODE_H style;\n  BITCODE_H mtext_handles; /* R2018+ TODO */\n  BITCODE_BS annotative_data_size; /* R2018+ */\n  BITCODE_RC annotative_data_bytes;\n  BITCODE_H  annotative_app;\n  BITCODE_BS annotative_short;\n\n  BITCODE_RC attdef_class_version; /* R2010+ */\n  BITCODE_TV prompt;\n} Dwg_Entity_ATTDEF;\n\n/**\n BLOCK (4) entity\n */\ntypedef struct _dwg_entity_BLOCK\n{\n  struct _dwg_object_entity *parent;\n\n  BITCODE_TV name;\n} Dwg_Entity_BLOCK;\n\n/**\n ENDBLK (5) entity\n */\ntypedef struct _dwg_entity_ENDBLK\n{\n  struct _dwg_object_entity *parent;\n} Dwg_Entity_ENDBLK;\n\n/**\n SEQEND (6) entity\n */\ntypedef struct _dwg_entity_SEQEND\n{\n  struct _dwg_object_entity *parent;\n} Dwg_Entity_SEQEND;\n\n/**\n INSERT (7) entity\n */\ntypedef struct _dwg_entity_INSERT\n{\n  struct _dwg_object_entity *parent;\n\n  BITCODE_3DPOINT   ins_pt;\n  BITCODE_BB        scale_flag;\n  BITCODE_3DPOINT   scale;\n  BITCODE_BD        rotation;\n  BITCODE_BE        extrusion;\n  BITCODE_B         has_attribs;\n  BITCODE_BL        num_owned;\n\n  BITCODE_H   block_header;\n  BITCODE_H   first_attrib;\n  BITCODE_H   last_attrib;\n  BITCODE_H*  attrib_handles;\n  BITCODE_H   seqend;\n} Dwg_Entity_INSERT;\n\n/**\n MINSERT (8) entity\n */\ntypedef struct _dwg_entity_MINSERT\n{\n  struct _dwg_object_entity *parent;\n\n  BITCODE_3DPOINT   ins_pt;\n  BITCODE_BB        scale_flag;\n  BITCODE_3DPOINT   scale;\n  BITCODE_BD        rotation;\n  BITCODE_BE        extrusion;\n  BITCODE_B         has_attribs;\n  BITCODE_BL        num_owned;\n\n  BITCODE_BS        num_cols;\n  BITCODE_BS        num_rows;\n  BITCODE_BD        col_spacing;\n  BITCODE_BD        row_spacing;\n\n  BITCODE_H   block_header;\n  BITCODE_H   first_attrib;\n  BITCODE_H   last_attrib;\n  BITCODE_H*  attrib_handles;\n  BITCODE_H   seqend;\n} Dwg_Entity_MINSERT;\n\n/**\n VERTEX_2D (10) entity\n */\ntypedef struct _dwg_entity_VERTEX_2D\n{\n  struct _dwg_object_entity *parent;\n\n  BITCODE_RC flag;\n  BITCODE_3BD point;\n  BITCODE_BD start_width;\n  BITCODE_BD end_width;\n  BITCODE_BL id; /* R2010+ */\n  BITCODE_BD bulge;\n  BITCODE_BD tangent_dir;\n} Dwg_Entity_VERTEX_2D;\n\n/**\n VERTEX_3D (11) entity\n */\ntypedef struct _dwg_entity_VERTEX_3D\n{\n  struct _dwg_object_entity *parent;\n\n  BITCODE_RC flag;\n  BITCODE_3BD point;\n} Dwg_Entity_VERTEX_3D;\n\n/**\n VERTEX_MESH (12) - same as VERTEX_3D entity\n */\ntypedef Dwg_Entity_VERTEX_3D Dwg_Entity_VERTEX_MESH;\n\n/**\n VERTEX_PFACE (13) - same as VERTEX_3D entity\n */\ntypedef Dwg_Entity_VERTEX_3D Dwg_Entity_VERTEX_PFACE;\n\n/**\n VERTEX_PFACE_FACE (14) entity\n */\ntypedef struct _dwg_entity_VERTEX_PFACE_FACE\n{\n  struct _dwg_object_entity *parent;\n\n  BITCODE_RC flag;\n  BITCODE_BS vertind[4];\n} Dwg_Entity_VERTEX_PFACE_FACE;\n\n#define COMMON_ENTITY_POLYLINE \\\n  struct _dwg_object_entity *parent; \\\n  BITCODE_B has_vertex; \\\n  BITCODE_BL num_owned; \\\n  BITCODE_H first_vertex; \\\n  BITCODE_H last_vertex; \\\n  BITCODE_H* vertex; \\\n  BITCODE_H seqend\n\n/**\n 2D POLYLINE (15) entity\n */\ntypedef struct _dwg_entity_POLYLINE_2D\n{\n  COMMON_ENTITY_POLYLINE;\n\n  BITCODE_BS flag;\n  BITCODE_BS curve_type;\n  BITCODE_BD start_width;\n  BITCODE_BD end_width;\n  BITCODE_BT thickness;\n  BITCODE_BD elevation;\n  BITCODE_BE extrusion;\n} Dwg_Entity_POLYLINE_2D;\n\n/**\n 3D POLYLINE (16) entity\n */\ntypedef struct _dwg_entity_POLYLINE_3D\n{\n  COMMON_ENTITY_POLYLINE;\n\n  BITCODE_RC curve_type;\n  BITCODE_RC flag;\n} Dwg_Entity_POLYLINE_3D;\n\n/**\n ARC (17) entity\n */\ntypedef struct _dwg_entity_ARC\n{\n  struct _dwg_object_entity *parent;\n\n  BITCODE_3BD center;\n  BITCODE_BD radius;\n  BITCODE_BT thickness;\n  BITCODE_BE extrusion;\n  BITCODE_BD start_angle;\n  BITCODE_BD end_angle;\n} Dwg_Entity_ARC;\n\n/**\n CIRCLE (18) entity\n */\ntypedef struct _dwg_entity_CIRCLE\n{\n  struct _dwg_object_entity *parent;\n\n  BITCODE_3BD center;\n  BITCODE_BD radius;\n  BITCODE_BT thickness;\n  BITCODE_BE extrusion;\n} Dwg_Entity_CIRCLE;\n\n/**\n LINE (19) entity\n */\ntypedef struct _dwg_entity_LINE\n{\n  struct _dwg_object_entity *parent;\n\n  BITCODE_RC z_is_zero;\n  BITCODE_3BD start;\n  BITCODE_3BD end;\n  BITCODE_BT thickness;\n  BITCODE_BE extrusion;\n} Dwg_Entity_LINE;\n\n/**\n * Macro for common DIMENSION declaration\n */\n#define DIMENSION_COMMON \\\n    struct _dwg_object_entity *parent; \\\n    BITCODE_RC class_version; /* R2010+ */ \\\n    BITCODE_TV blockname; \\\n    BITCODE_BE extrusion; \\\n    BITCODE_3BD def_pt; \\\n    BITCODE_2RD text_midpt; \\\n    BITCODE_BD elevation; \\\n    BITCODE_RC flag; /* calculated, DXF only */ \\\n    BITCODE_RC flag1; \\\n    BITCODE_TV user_text; \\\n    BITCODE_BD text_rotation; \\\n    BITCODE_BD horiz_dir; \\\n    BITCODE_3BD ins_scale; \\\n    BITCODE_BD ins_rotation; \\\n    BITCODE_BS attachment; \\\n    BITCODE_BS lspace_style; \\\n    BITCODE_BD lspace_factor; \\\n    BITCODE_BD act_measurement; \\\n    BITCODE_B unknown; \\\n    BITCODE_B flip_arrow1; \\\n    BITCODE_B flip_arrow2; \\\n    BITCODE_2RD clone_ins_pt;\n\ntypedef struct _dwg_DIMENSION_common\n{\n  DIMENSION_COMMON\n} Dwg_DIMENSION_common;\n\n/**\n ordinate dimension - DIMENSION_ORDINATE (20) entity\n */\ntypedef struct _dwg_entity_DIMENSION_ORDINATE\n{\n  DIMENSION_COMMON\n  BITCODE_3BD feature_location_pt;\n  BITCODE_3BD leader_endpt;\n  BITCODE_RC flag2;\n  BITCODE_H dimstyle;\n  BITCODE_H block;\n} Dwg_Entity_DIMENSION_ORDINATE;\n\n/**\n linear dimension - DIMENSION_LINEAR (21) entity\n */\ntypedef struct _dwg_entity_DIMENSION_LINEAR\n{\n  DIMENSION_COMMON\n  BITCODE_3BD _13_pt;\n  BITCODE_3BD _14_pt;\n  BITCODE_BD ext_line_rotation;\n  BITCODE_BD dim_rotation;\n  BITCODE_H dimstyle;\n  BITCODE_H block;\n} Dwg_Entity_DIMENSION_LINEAR;\n\n/**\n aligned dimension - DIMENSION_ALIGNED (22) entity\n */\ntypedef struct _dwg_entity_DIMENSION_ALIGNED\n{\n  DIMENSION_COMMON\n  BITCODE_3BD _13_pt;\n  BITCODE_3BD _14_pt;\n  BITCODE_BD ext_line_rotation;\n  BITCODE_H dimstyle;\n  BITCODE_H block;\n} Dwg_Entity_DIMENSION_ALIGNED;\n\n/**\n angular 3pt dimension - DIMENSION_ANG3PT (23) entity\n */\ntypedef struct _dwg_entity_DIMENSION_ANG3PT\n{\n  DIMENSION_COMMON\n  BITCODE_3BD _13_pt;\n  BITCODE_3BD _14_pt;\n  BITCODE_3BD first_arc_pt;\n  BITCODE_H dimstyle;\n  BITCODE_H block;\n} Dwg_Entity_DIMENSION_ANG3PT;\n\n/**\n angular 2 line dimension - DIMENSION_ANG2LN (24) entity\n */\ntypedef struct _dwg_entity_DIMENSION_ANG2LN\n{\n  DIMENSION_COMMON\n  BITCODE_2RD _16_pt;\n  BITCODE_3BD _13_pt;\n  BITCODE_3BD _14_pt;\n  BITCODE_3BD first_arc_pt;\n  BITCODE_H dimstyle;\n  BITCODE_H block;\n} Dwg_Entity_DIMENSION_ANG2LN;\n\n/**\n radius dimension - DIMENSION_RADIUS (25) entity\n */\ntypedef struct _dwg_entity_DIMENSION_RADIUS\n{\n  DIMENSION_COMMON\n  BITCODE_3BD first_arc_pt; /*!< DXF 15 */\n  BITCODE_BD leader_len;    /*!< DXF 40 */\n  BITCODE_H dimstyle;\n  BITCODE_H block;\n} Dwg_Entity_DIMENSION_RADIUS;\n\n/**\n diameter dimension - DIMENSION_DIAMETER (26) entity\n */\ntypedef struct _dwg_entity_DIMENSION_DIAMETER\n{\n  DIMENSION_COMMON\n  BITCODE_3BD first_arc_pt; /*!< DXF 15 */\n  BITCODE_BD leader_len;    /*!< DXF 40 */\n  BITCODE_H dimstyle;\n  BITCODE_H block;\n} Dwg_Entity_DIMENSION_DIAMETER;\n\n/**\n arc dimension - ARC_DIMENSION (varies) entity\n */\ntypedef struct _dwg_entity_ARC_DIMENSION\n{\n  DIMENSION_COMMON\n  BITCODE_3BD _13_pt;\n  BITCODE_3BD _14_pt;\n  BITCODE_3BD _15_pt;\n  BITCODE_3BD unknown_pt;\n  BITCODE_3BD _16_pt;\n  BITCODE_3BD _17_pt;\n  BITCODE_BD leader_len;    /*!< DXF 40 */\n  BITCODE_RC flag2;\n  BITCODE_H dimstyle;\n  BITCODE_H block;\n} Dwg_Entity_ARC_DIMENSION;\n\n/**\n Struct for:  POINT (27)\n */\ntypedef struct _dwg_entity_POINT\n{\n  struct _dwg_object_entity *parent;\n\n  BITCODE_BD x;\n  BITCODE_BD y;\n  BITCODE_BD z;\n  BITCODE_BT thickness;\n  BITCODE_BE extrusion;\n  BITCODE_BD x_ang;\n} Dwg_Entity_POINT;\n\n/**\n Struct for:  3D FACE (28)\n */\ntypedef struct _dwg_entity_3DFACE\n{\n  struct _dwg_object_entity *parent;\n\n  BITCODE_B has_no_flags;\n  BITCODE_B z_is_zero;\n  BITCODE_3BD corner1;\n  BITCODE_3BD corner2;\n  BITCODE_3BD corner3;\n  BITCODE_3BD corner4;\n  BITCODE_BS invis_flags;\n} Dwg_Entity__3DFACE;\n\n/**\n Struct for:  POLYLINE (PFACE) (29)\n */\ntypedef struct _dwg_entity_POLYLINE_PFACE\n{\n  COMMON_ENTITY_POLYLINE;\n\n  BITCODE_BS numverts;\n  BITCODE_BS numfaces;\n} Dwg_Entity_POLYLINE_PFACE;\n\n/**\n Struct for:  POLYLINE (MESH) (30)\n */\ntypedef struct _dwg_entity_POLYLINE_MESH\n{\n  COMMON_ENTITY_POLYLINE;\n\n  BITCODE_BS flag;\n  BITCODE_BS curve_type;\n  BITCODE_BS num_m_verts;\n  BITCODE_BS num_n_verts;\n  BITCODE_BS m_density;\n  BITCODE_BS n_density;\n} Dwg_Entity_POLYLINE_MESH;\n\n/**\n Struct for:  SOLID (31)\n */\n\ntypedef struct _dwg_entity_SOLID\n{\n  struct _dwg_object_entity *parent;\n\n  BITCODE_BT thickness;\n  BITCODE_BD elevation;\n  BITCODE_2RD corner1;\n  BITCODE_2RD corner2;\n  BITCODE_2RD corner3;\n  BITCODE_2RD corner4;\n  BITCODE_BE extrusion;\n} Dwg_Entity_SOLID;\n\n/**\n Struct for:  TRACE (32)\n */\n\ntypedef struct _dwg_entity_TRACE\n{\n  struct _dwg_object_entity *parent;\n\n  BITCODE_BT thickness;\n  BITCODE_BD elevation;\n  BITCODE_2RD corner1;\n  BITCODE_2RD corner2;\n  BITCODE_2RD corner3;\n  BITCODE_2RD corner4;\n  BITCODE_BE extrusion;\n} Dwg_Entity_TRACE;\n\n/**\n Struct for:  SHAPE (33)\n */\n\ntypedef struct _dwg_entity_SHAPE\n{\n  struct _dwg_object_entity *parent;\n\n  BITCODE_3BD ins_pt;\n  BITCODE_BD scale;\n  BITCODE_BD rotation;\n  BITCODE_BD width_factor;\n  BITCODE_BD oblique;\n  BITCODE_BD thickness;\n  BITCODE_BS style_id;\n  BITCODE_BE extrusion;\n  BITCODE_H style;\n} Dwg_Entity_SHAPE;\n\n/**\n Struct for:  VIEWPORT ENTITY (34)\n */\n\ntypedef struct _dwg_entity_VIEWPORT\n{\n  struct _dwg_object_entity *parent;\n\n  BITCODE_3BD center;\n  BITCODE_BD width;\n  BITCODE_BD height;\n  BITCODE_RS on_off; /* DXF 68, -1 should be accepted also */\n  BITCODE_RS id;     /* DXF 69 */\n  BITCODE_3BD view_target;\n  BITCODE_3BD view_direction;\n  BITCODE_BD view_twist;\n  BITCODE_BD view_height;\n  BITCODE_BD lens_length;\n  BITCODE_BD front_clip_z;\n  BITCODE_BD back_clip_z;\n  BITCODE_BD snap_angle;\n  BITCODE_2RD view_center;\n  BITCODE_2RD snap_base;\n  BITCODE_2RD snap_spacing;\n  BITCODE_2RD grid_spacing;\n  BITCODE_BS circle_zoom;\n  BITCODE_BS grid_major;\n  BITCODE_BL num_frozen_layers;\n  BITCODE_BL status_flag;\n  BITCODE_TV style_sheet;\n  BITCODE_RC render_mode;\n  BITCODE_B ucs_at_origin;\n  BITCODE_B ucs_per_viewport;\n  BITCODE_3BD ucs_origin;\n  BITCODE_3BD ucs_x_axis;\n  BITCODE_3BD ucs_y_axis;\n  BITCODE_BD ucs_elevation;\n  BITCODE_BS ucs_ortho_view_type;\n  BITCODE_BS shadeplot_mode;\n  BITCODE_B use_default_lights;\n  BITCODE_RC default_lighting_type;\n  BITCODE_BD brightness;\n  BITCODE_BD contrast;\n  BITCODE_CMC ambient_color;\n} Dwg_Entity_VIEWPORT;\n\n/**\n ELLIPSE (35) entity\n */\ntypedef struct _dwg_entity_ELLIPSE\n{\n  struct _dwg_object_entity *parent;\n\n  BITCODE_3BD center;\n  BITCODE_3BD sm_axis;\n  BITCODE_BE extrusion;\n  BITCODE_BD axis_ratio;\n  BITCODE_BD start_angle;\n  BITCODE_BD end_angle;\n} Dwg_Entity_ELLIPSE;\n\n/**\n spline - SPLINE (36) entity\n */\ntypedef struct _dwg_SPLINE_point\n{\n  struct _dwg_entity_SPLINE *parent;\n\n  double x;\n  double y;\n  double z;\n} Dwg_SPLINE_point;\n\ntypedef struct _dwg_SPLINE_control_point\n{\n  struct _dwg_entity_SPLINE *parent;\n\n  double x;\n  double y;\n  double z;\n  double w;\n} Dwg_SPLINE_control_point;\n\ntypedef struct _dwg_entity_SPLINE\n{\n  struct _dwg_object_entity *parent;\n\n  BITCODE_RS flag; /* computed */\n  BITCODE_BS scenario; /* 1 spline, 2 bezier */\n  BITCODE_BS degree;\n  BITCODE_BL splineflags1; /* 2013+: method fit points = 1, CV frame show = 2, closed = 4 */\n  BITCODE_BL knotparam;    /* 2013+: Chord = 0, Square root = 1, Uniform = 2, Custom = 15 */\n  BITCODE_BD fit_tol;\n  BITCODE_3BD beg_tan_vec;\n  BITCODE_3BD end_tan_vec;\n  BITCODE_B closed_b; /* bit 1 of 70 */\n  BITCODE_B periodic; /* bit 2 of 70 */\n  BITCODE_B rational; /* bit 3 of 70 */\n  BITCODE_B weighted; /* bit 4 of 70 */\n  BITCODE_BD knot_tol;\n  BITCODE_BD ctrl_tol;\n  BITCODE_BS num_fit_pts;\n  Dwg_SPLINE_point* fit_pts;\n  BITCODE_BL num_knots;\n  BITCODE_BD* knots;\n  BITCODE_BL num_ctrl_pts;\n  Dwg_SPLINE_control_point* ctrl_pts;\n} Dwg_Entity_SPLINE;\n\n/**\n 3DSOLID (38) entity\n */\n#define Dwg_Entity_3DSOLID Dwg_Entity__3DSOLID\ntypedef struct _dwg_3DSOLID_wire\n{\n  struct _dwg_entity_3DSOLID *parent;\n  BITCODE_RC type;\n  BITCODE_BL selection_marker;\n  BITCODE_BS color;\n  BITCODE_BL acis_index;\n  BITCODE_BL num_points;\n  BITCODE_3BD* points;\n  BITCODE_B transform_present;\n  BITCODE_3BD axis_x;\n  BITCODE_3BD axis_y;\n  BITCODE_3BD axis_z;\n  BITCODE_3BD translation;\n  BITCODE_BD scale;\n  BITCODE_B has_rotation;\n  BITCODE_B has_reflection;\n  BITCODE_B has_shear;\n} Dwg_3DSOLID_wire;\n\ntypedef struct _dwg_3DSOLID_silhouette\n{\n  struct _dwg_entity_3DSOLID *parent;\n  BITCODE_BL vp_id;\n  BITCODE_3BD vp_target;\n  BITCODE_3BD vp_dir_from_target;\n  BITCODE_3BD vp_up_dir;\n  BITCODE_B vp_perspective;\n  BITCODE_BL num_wires;\n  Dwg_3DSOLID_wire * wires;\n} Dwg_3DSOLID_silhouette;\n\n#define _3DSOLID_FIELDS \\\n  BITCODE_B acis_empty; \\\n  BITCODE_B unknown; \\\n  BITCODE_BS version; \\\n  BITCODE_BL num_blocks; \\\n  BITCODE_BL* block_size; \\\n  char     ** encr_sat_data; \\\n  BITCODE_RC* acis_data; \\\n  BITCODE_B wireframe_data_present; \\\n  BITCODE_B point_present; \\\n  BITCODE_3BD point; \\\n  BITCODE_BL num_isolines; \\\n  BITCODE_B isoline_present; \\\n  BITCODE_BL num_wires; \\\n  Dwg_3DSOLID_wire * wires; \\\n  BITCODE_BL num_silhouettes; \\\n  Dwg_3DSOLID_silhouette * silhouettes; \\\n  BITCODE_B acis_empty2; \\\n  struct _dwg_entity_3DSOLID* extra_acis_data; \\\n  BITCODE_BL unknown_2007; \\\n  BITCODE_H history_id; \\\n  BITCODE_B acis_empty_bit\n\ntypedef struct _dwg_entity_3DSOLID\n{\n  struct _dwg_object_entity *parent;\n  _3DSOLID_FIELDS;\n#if 0\n  BITCODE_B acis_empty;  /*!< no DXF */\n  BITCODE_B unknown;\n  BITCODE_BS version;    /*!< DXF 70 Modeler format version =1*/\n  BITCODE_BL num_blocks;\n  BITCODE_BL* block_size;\n  BITCODE_RC** encr_sat_data; /*!< DXF 1, the encrypted SAT data */\n  BITCODE_RC*  acis_data;     /*!< decrypted SAT data */\n  BITCODE_B wireframe_data_present;\n  BITCODE_B point_present;\n  BITCODE_3BD point;\n  BITCODE_BL num_isolines;\n  BITCODE_B isoline_present;\n  BITCODE_BL num_wires;\n  Dwg_3DSOLID_wire * wires;\n  BITCODE_BL num_silhouettes;\n  Dwg_3DSOLID_silhouette * silhouettes;\n  BITCODE_B acis_empty2;\n  struct _dwg_entity_3DSOLID* extra_acis_data;/* is it the best approach? */\n  BITCODE_BL unknown_2007;\n  BITCODE_H history_id;\n  BITCODE_B acis_empty_bit;\n#endif\n} Dwg_Entity__3DSOLID;\n\n/**\n REGION (37) entity\n */\ntypedef Dwg_Entity__3DSOLID Dwg_Entity_REGION;\n\n/**\n BODY (39) entity\n */\ntypedef Dwg_Entity__3DSOLID Dwg_Entity_BODY;\n\n/**\n ray - RAY (40) entity\n */\ntypedef struct _dwg_entity_RAY\n{\n  struct _dwg_object_entity *parent;\n\n  BITCODE_3BD point;   /*!< DXF 10 */\n  BITCODE_3BD vector;  /*!< DXF 11 */\n} Dwg_Entity_RAY;\n\n/**\n XLINE (41) entity\n */\ntypedef Dwg_Entity_RAY Dwg_Entity_XLINE;\n\n/**\n DICTIONARY (42)\n This structure is used for all the new tables.\n Beware: Keep same offsets as DICTIONARYWDFLT\n */\ntypedef struct _dwg_object_DICTIONARY\n{\n  struct _dwg_object_object *parent;\n\n  BITCODE_BL numitems;    /*!< no DXF */\n  BITCODE_BS cloning;     /*!< DXF 281 */\n  BITCODE_RC hard_owner;  /*!< DXF 330 */\n  BITCODE_TV* texts;      /*!< DXF 3 */\n  BITCODE_H* itemhandles; /*!< DXF 350/360, pairwise with texts */\n\n  BITCODE_RC cloning_r14; /*!< r14 only */\n} Dwg_Object_DICTIONARY;\n\n/**\n OLEFRAME (43) entity\n (replaced by OLE2FRAME (74) later)\n */\ntypedef struct _dwg_entity_OLEFRAME\n{\n  struct _dwg_object_entity *parent;\n\n  BITCODE_BS flag;\n  BITCODE_BS mode;\n  BITCODE_BL data_length;\n  char     * data;\n} Dwg_Entity_OLEFRAME;\n\n/**\n MTEXT (44) entity\n */\ntypedef struct _dwg_entity_MTEXT\n{\n  struct _dwg_object_entity *parent;\n\n  BITCODE_3BD insertion_pt;/*!< DXF 10 */\n  BITCODE_BE extrusion;   /*!< DXF 210 */\n  BITCODE_3BD x_axis_dir;  /*!< DXF 1 */\n  BITCODE_BD rect_height;  /*!< no DXF */\n  BITCODE_BD rect_width;   /*!< DXF 41 */\n  BITCODE_BD text_height;  /*!< DXF 40 */\n  BITCODE_BS attachment;   /*!< DXF 71.\n                             1 = Top left, 2 = Top center, 3 = Top\n                             right, 4 = Middle left, 5 = Middle\n                             center, 6 = Middle right, 7 = Bottom\n                             left, 8 = Bottom center, 9 = Bottom\n                             right */\n  BITCODE_BS drawing_dir;  /*!< DXF 72.\n                            1 = Left to right, 3 = Top to bottom,\n                            5 = By style (the flow direction is inherited\n                            from the associated text style) */\n  BITCODE_BD extents_height; /*!< DXF 42 */\n  BITCODE_BD extents_width;  /*!< DXF 43 */\n  BITCODE_TV text;           /*!< DXF 1 */\n  BITCODE_H style;           /*!< DXF 7 */\n  BITCODE_BS linespace_style; /*!< DXF 73. r2000+ */\n  BITCODE_BD linespace_factor;/*!< DXF 44. r2000+. Mtext line spacing factor (optional):\n                               Percentage of default (3-on-5) line spacing to\n                               be applied. Valid values range from 0.25 to 4.00 */\n  BITCODE_B unknown_bit;\n  BITCODE_BL bg_fill_flag;   /*!< DXF 90. r2004+\n                               0 = Background fill off,\n                               1 = Use background fill color,\n                               2 = Use drawing window color as background fill color. */\n  BITCODE_BL bg_fill_scale;  /*!< DXF 45. r2004+\n                               margin around the text. */\n  BITCODE_CMC bg_fill_color; /*!< DXF 63. r2004+. on bg_fill_flag==1 */\n  BITCODE_BL bg_fill_trans;  /*!< DXF 441. r2004+. unused */\n  BITCODE_B annotative;      /*!< r2018+: */\n  BITCODE_BS class_version;\n  BITCODE_B default_flag;\n  BITCODE_H appid;\n  BITCODE_BL column_type;    /*!< DXF 75 */\n  BITCODE_BD column_width;   /*!< DXF 48 */\n  BITCODE_BD gutter;         /*!< DXF 49 */\n  BITCODE_B auto_height;     /*!< DXF 79 */\n  BITCODE_B flow_reversed;   /*!< DXF 74 */\n  BITCODE_BL num_column_heights;/*!< DXF 76 */\n  BITCODE_BD *column_heights;/*!< DXF 50 */\n} Dwg_Entity_MTEXT;\n\n/**\n LEADER (45) entity\n */\ntypedef struct _dwg_entity_LEADER\n{\n  struct _dwg_object_entity *parent;\n\n  BITCODE_B unknown_bit_1;  /* always seems to be zero */\n  BITCODE_BS path_type;     /*< DXF(72) 0: line, 1: spline (oda bug) */\n  BITCODE_BS annot_type;    /*< DXF(73) 0: text, 1: tol, 2: insert, 3 (def): none */\n  BITCODE_BL num_points;    /*< DXF(76) */\n  BITCODE_3DPOINT* points;\n  BITCODE_3DPOINT origin;\n  BITCODE_BE extrusion;\n  BITCODE_3DPOINT x_direction;\n  BITCODE_3DPOINT offset_to_block_ins_pt;\n  BITCODE_3DPOINT endptproj; /* R_14-R_2007 ? */\n  BITCODE_BD dimgap;         /* R_13-R_14 only */\n  BITCODE_BD box_height;\n  BITCODE_BD box_width;\n  BITCODE_B hookline_dir;\n  BITCODE_B arrowhead_on;\n  BITCODE_BS arrowhead_type;\n  BITCODE_BD dimasz;\n  BITCODE_B unknown_bit_2;\n  BITCODE_B unknown_bit_3;\n  BITCODE_BS unknown_short_1;\n  BITCODE_BS byblock_color;\n  BITCODE_B hookline_on;\n  BITCODE_B unknown_bit_5;\n  BITCODE_H associated_annotation; /* DXF 340 Hard reference to associated annotation (mtext, tolerance, or insert entity) */\n  BITCODE_H dimstyle;\n} Dwg_Entity_LEADER;\n\n/**\n TOLERANCE (46) entity\n */\ntypedef struct _dwg_entity_TOLERANCE\n{\n  struct _dwg_object_entity *parent;\n\n  BITCODE_BS unknown_short;\n  BITCODE_BD height;\n  BITCODE_BD dimgap;\n  BITCODE_3BD ins_pt;\n  BITCODE_3BD x_direction;\n  BITCODE_BE extrusion;\n  BITCODE_TV text_string;\n  BITCODE_H dimstyle;\n} Dwg_Entity_TOLERANCE;\n\n/**\n MLINE (47) entity\n */\ntypedef struct _dwg_MLINE_line\n{\n  struct _dwg_MLINE_vertex *parent;\n  BITCODE_BS num_segparms;\n  BITCODE_BD * segparms;\n  BITCODE_BS num_areafillparms;\n  BITCODE_BD* areafillparms;\n} Dwg_MLINE_line;\n\ntypedef struct _dwg_MLINE_vertex\n{\n  struct _dwg_entity_MLINE *parent;\n  BITCODE_3BD vertex;\n  BITCODE_3BD vertex_direction;\n  BITCODE_3BD miter_direction;\n  BITCODE_RC num_lines;\n  Dwg_MLINE_line* lines;\n} Dwg_MLINE_vertex;\n\ntypedef struct _dwg_entity_MLINE\n{\n  struct _dwg_object_entity *parent;\n\n  BITCODE_BD scale;\n  BITCODE_RC justification;\n  BITCODE_3BD base_point;\n  BITCODE_BE extrusion;\n  BITCODE_BS flags;\n  BITCODE_RC num_lines; /* Linesinstyle */\n  BITCODE_BS num_verts;\n  Dwg_MLINE_vertex* verts;\n  BITCODE_H mlinestyle;\n} Dwg_Entity_MLINE;\n\n#define COMMON_TABLE_CONTROL_FIELDS \\\n  struct _dwg_object_object *parent; \\\n  BITCODE_BS num_entries; \\\n  BITCODE_H* entries; \\\n  BITCODE_BL objid\n\n// not for LAYER!\n#define COMMON_TABLE_FIELDS() \\\n  struct _dwg_object_object *parent; \\\n  BITCODE_RC flag; \\\n  BITCODE_TV name; \\\n  BITCODE_RS used; \\\n  BITCODE_B xrefref; \\\n  BITCODE_BS xrefindex_plus1; \\\n  BITCODE_B xrefdep\n\n/**\n BLOCK_CONTROL (48) object, table header\n */\ntypedef struct _dwg_object_BLOCK_CONTROL\n{\n  COMMON_TABLE_CONTROL_FIELDS;\n  BITCODE_H model_space;\n  BITCODE_H paper_space;\n} Dwg_Object_BLOCK_CONTROL;\n\n/**\n BLOCK_HEADER (49) object, table entry\n */\ntypedef struct _dwg_object_BLOCK_HEADER\n{\n  COMMON_TABLE_FIELDS();\n  BITCODE_BL __iterator;\n  BITCODE_RC flag2; /* preR13 */\n  BITCODE_RS flag3; /* preR13 */\n  BITCODE_B anonymous;    /* flag 70 bit 1 */\n  BITCODE_B hasattrs;     /* flag 70 bit 2 */\n  BITCODE_B blkisxref;    /* flag 70 bit 3 */\n  BITCODE_B xrefoverlaid; /* flag 70 bit 4 */\n  BITCODE_B loaded_bit;   /* flag 70 bit 6 */\n  BITCODE_BL num_owned;\n  BITCODE_3DPOINT base_pt;\n  BITCODE_TV xref_pname;\n  BITCODE_RL num_inserts;\n  BITCODE_TV description;\n  BITCODE_BL preview_data_size; /* no DXF, BLL? */\n  char     * preview_data;      /* DXF 310 */\n  BITCODE_BS insert_units;\n  BITCODE_B explodable;\n  BITCODE_RC block_scaling;\n  BITCODE_H null_handle;\n  BITCODE_H block_entity;\n  BITCODE_H first_entity;\n  BITCODE_H last_entity;\n  BITCODE_H* entities;\n  BITCODE_H endblk_entity;\n  BITCODE_H* inserts;\n  BITCODE_H layout;\n} Dwg_Object_BLOCK_HEADER;\n\n/**\n LAYER_CONTROL (50) object, table header\n */\ntypedef struct _dwg_object_LAYER_CONTROL\n{\n  COMMON_TABLE_CONTROL_FIELDS;\n} Dwg_Object_LAYER_CONTROL;\n\n/**\n LAYER (51) object, table entry\n */\ntypedef struct _dwg_object_LAYER\n{\n  struct _dwg_object_object *parent;\n  BITCODE_BS flag;\n  BITCODE_TV name;\n  BITCODE_RS used; /* preR13 */\n  BITCODE_B xrefref;\n  BITCODE_BS xrefindex_plus1;\n  BITCODE_B xrefdep;\n\n  BITCODE_B frozen;\n  BITCODE_B on;\n  BITCODE_B frozen_in_new;\n  BITCODE_B locked;\n  BITCODE_B plotflag;\n  BITCODE_RC linewt;\n  //BITCODE_BS flag_s;\n  BITCODE_CMC color;\n  short      color_rs;    /* preR13, needs to be signed */\n  BITCODE_RS ltype_rs;    /* preR13 */\n  BITCODE_H xref;\n  BITCODE_H plotstyle;\n  BITCODE_H material;\n  BITCODE_H ltype;\n} Dwg_Object_LAYER;\n\n/**\n STYLE_CONTROL (52) object, table header\n */\ntypedef struct _dwg_object_STYLE_CONTROL\n{\n  COMMON_TABLE_CONTROL_FIELDS;\n} Dwg_Object_STYLE_CONTROL;\n\n/**\n STYLE (53) object, table entry.\n Textstyle. Some call it SHAPEFILE.\n */\ntypedef struct _dwg_object_STYLE\n{\n  COMMON_TABLE_FIELDS();\n  BITCODE_B vertical;\n  BITCODE_B shape_file;\n  BITCODE_BD fixed_height;\n  BITCODE_BD width_factor;\n  BITCODE_BD oblique_ang;\n  BITCODE_RC generation;\n  BITCODE_BD last_height;\n  BITCODE_TV font_name;\n  BITCODE_TV bigfont_name;\n  BITCODE_H extref;\n} Dwg_Object_STYLE;\n\n/* 54 and 55 are UNKNOWN OBJECTS */\n\n/**\n LTYPE_CONTROL (56) object, table header\n */\ntypedef struct _dwg_object_LTYPE_CONTROL\n{\n  COMMON_TABLE_CONTROL_FIELDS;\n  BITCODE_H bylayer;\n  BITCODE_H byblock;\n} Dwg_Object_LTYPE_CONTROL;\n\n/**\n LTYPE (57) object, table entry\n */\n\ntypedef struct _dwg_LTYPE_dash {\n  struct _dwg_object_LTYPE *parent;\n  BITCODE_BD length;\n  BITCODE_BS complex_shapecode;\n  BITCODE_RD x_offset;\n  BITCODE_RD y_offset;\n  BITCODE_BD scale;\n  BITCODE_BD rotation;\n  BITCODE_BS shape_flag;\n} Dwg_LTYPE_dash;\n\ntypedef struct _dwg_object_LTYPE\n{\n  COMMON_TABLE_FIELDS();\n  BITCODE_TV description;\n  BITCODE_BD pattern_len;\n  BITCODE_RC alignment;\n  BITCODE_RC num_dashes;\n  Dwg_LTYPE_dash* dashes;\n  BITCODE_RD* dashes_r11;\n  BITCODE_B text_area_is_present; /* if some shape_flag & 2 */\n  char    * strings_area;\n  BITCODE_H extref_handle;\n  BITCODE_H* styles;\n} Dwg_Object_LTYPE;\n\n/* 58 and 59 are UNKNOWN OBJECTS */\n\n/**\n VIEW_CONTROL (60) object, table header\n */\ntypedef struct _dwg_object_VIEW_CONTROL\n{\n  COMMON_TABLE_CONTROL_FIELDS;\n} Dwg_Object_VIEW_CONTROL;\n\n/**\n VIEW (61) object, table entry\n */\ntypedef struct _dwg_object_VIEW\n{\n  COMMON_TABLE_FIELDS();\n  BITCODE_BD height;\n  BITCODE_BD width;\n  BITCODE_2RD center;\n  BITCODE_3BD target;\n  BITCODE_3BD direction;\n  BITCODE_BD twist_angle;\n  BITCODE_BD lens_length;\n  BITCODE_BD front_clip;\n  BITCODE_BD back_clip;\n  BITCODE_4BITS VIEWMODE;\n  BITCODE_RC render_mode;\n  BITCODE_B use_default_lights;\n  BITCODE_RC default_lightning_type;\n  BITCODE_BD brightness;\n  BITCODE_BD contrast;\n  BITCODE_CMC ambient_color;\n  BITCODE_B pspace_flag;\n  BITCODE_B associated_ucs;\n  BITCODE_3BD origin;\n  BITCODE_3BD x_direction;\n  BITCODE_3BD y_direction;\n  BITCODE_BD elevation;\n  BITCODE_BS orthographic_view_type;\n  BITCODE_B camera_plottable;\n  BITCODE_H null_handle;\n  BITCODE_H background;\n  BITCODE_H visualstyle;\n  BITCODE_H sun;\n  BITCODE_H base_ucs;\n  BITCODE_H named_ucs;\n  BITCODE_H livesection;\n} Dwg_Object_VIEW;\n\n/**\n UCS_CONTROL (62) object, table header\n */\ntypedef struct _dwg_object_UCS_CONTROL\n{\n  COMMON_TABLE_CONTROL_FIELDS;\n} Dwg_Object_UCS_CONTROL;\n\n/**\n UCS (63) object, table entry\n */\ntypedef struct _dwg_object_UCS\n{\n  COMMON_TABLE_FIELDS();\n  BITCODE_3BD origin;\n  BITCODE_3BD x_direction;\n  BITCODE_3BD y_direction;\n  BITCODE_BD elevation;\n  BITCODE_BS orthographic_view_type;\n  BITCODE_BS orthographic_type;\n  BITCODE_H null_handle;\n  BITCODE_H base_ucs;  /*! DXF 346 */\n  BITCODE_H named_ucs; /*! DXF 345 */\n} Dwg_Object_UCS;\n\n/**\n VPORT_CONTROL (64) object, table header\n */\ntypedef struct _dwg_object_VPORT_CONTROL\n{\n  COMMON_TABLE_CONTROL_FIELDS;\n} Dwg_Object_VPORT_CONTROL;\n\n/**\n VPORT (65) object, table entry\n */\ntypedef struct _dwg_object_VPORT\n{\n  COMMON_TABLE_FIELDS();\n  BITCODE_BD VIEWSIZE;  // really the view height\n  BITCODE_BD viewwidth; // in DWG r13+, needed to calc. aspect_ratio\n  BITCODE_BD aspect_ratio; // DXF 41 = viewwidth / VIEWSIZE\n  BITCODE_2RD VIEWCTR;\n  BITCODE_3BD view_target;\n  BITCODE_3BD VIEWDIR;\n  BITCODE_BD view_twist;\n  BITCODE_BD lens_length;\n  BITCODE_BD front_clip;\n  BITCODE_BD back_clip;\n  BITCODE_4BITS VIEWMODE;\n  BITCODE_RC render_mode;\n  BITCODE_B use_default_lights;\n  BITCODE_RC default_lightning_type;\n  BITCODE_BD brightness;\n  BITCODE_BD contrast;\n  BITCODE_CMC ambient_color;\n  BITCODE_2RD lower_left;\n  BITCODE_2RD upper_right;\n  BITCODE_B UCSFOLLOW;\n  BITCODE_BS circle_zoom; /* circle sides: nr of tesselations */\n  BITCODE_B FASTZOOM;\n  BITCODE_RC UCSICON;\n  BITCODE_B GRIDMODE;\n  BITCODE_2RD GRIDUNIT;\n  BITCODE_B SNAPMODE;\n  BITCODE_B SNAPSTYLE;\n  BITCODE_BS SNAPISOPAIR;\n  BITCODE_BD SNAPANG;\n  BITCODE_2RD SNAPBASE;\n  BITCODE_2RD SNAPUNIT;\n  BITCODE_B unknown;\n  BITCODE_B UCSVP;          /*!< DXF 65 */\n  BITCODE_3BD ucs_origin;\n  BITCODE_3BD ucs_x_axis;\n  BITCODE_3BD ucs_y_axis;\n  BITCODE_BD ucs_elevation;\n  BITCODE_BS ucs_orthografic_type;\n  BITCODE_BS grid_flags;\n  BITCODE_BS grid_major;\n  BITCODE_H null_handle;\n  BITCODE_H background;\n  BITCODE_H visualstyle;\n  BITCODE_H sun;\n  BITCODE_H named_ucs;\n  BITCODE_H base_ucs;\n} Dwg_Object_VPORT;\n\n/**\n APPID_CONTROL (66) object\n The table header of all registered applications\n */\ntypedef struct _dwg_object_APPID_CONTROL\n{\n  COMMON_TABLE_CONTROL_FIELDS;\n} Dwg_Object_APPID_CONTROL;\n\n/**\n APPID (67) object\n The table entry of a registered application\n */\ntypedef struct _dwg_object_APPID\n{\n  COMMON_TABLE_FIELDS();\n  BITCODE_RC unknown;\n  BITCODE_H null_handle;\n} Dwg_Object_APPID;\n\n/**\n DIMSTYLE_CONTROL (68) object\n The table header of all dimension styles\n */\ntypedef struct _dwg_object_DIMSTYLE_CONTROL\n{\n  COMMON_TABLE_CONTROL_FIELDS;\n  BITCODE_RC num_morehandles; /* DXF 71 undocumented */\n  BITCODE_H* morehandles;     /* DXF 340 */\n} Dwg_Object_DIMSTYLE_CONTROL;\n\n/**\n DIMSTYLE (69) object, table entry\n */\ntypedef struct _dwg_object_DIMSTYLE\n{\n  COMMON_TABLE_FIELDS();\n  BITCODE_B DIMTOL;\n  BITCODE_B DIMLIM;\n  BITCODE_B DIMTIH;\n  BITCODE_B DIMTOH;\n  BITCODE_B DIMSE1;\n  BITCODE_B DIMSE2;\n  BITCODE_B DIMALT;\n  BITCODE_B DIMTOFL;\n  BITCODE_B DIMSAH;\n  BITCODE_B DIMTIX;\n  BITCODE_B DIMSOXD;\n  BITCODE_BS DIMALTD;   /*!< r13-r14 only RC */\n  BITCODE_BS DIMZIN;    /*!< r13-r14 only RC */\n  BITCODE_B DIMSD1;\n  BITCODE_B DIMSD2;\n  BITCODE_BS DIMTOLJ;   /*!< r13-r14 only RC */\n  BITCODE_BS DIMJUST;   /*!< r13-r14 only RC */\n  BITCODE_BS DIMFIT;    /*!< r13-r14 only RC */\n  BITCODE_B DIMUPT;\n  BITCODE_BS DIMTZIN;   /*!< r13-r14 only RC */\n  BITCODE_BS DIMMALTZ;  /*!< r13-r14 only RC */\n  BITCODE_BS DIMMALTTZ; /*!< r13-r14 only RC */\n  BITCODE_BS DIMTAD;    /*!< r13-r14 only RC */\n  BITCODE_BS DIMUNIT;\n  BITCODE_BS DIMAUNIT;\n  BITCODE_BS DIMDEC;\n  BITCODE_BS DIMTDEC;\n  BITCODE_BS DIMALTU;\n  BITCODE_BS DIMALTTD;\n  /* BITCODE_H DIMTXSTY; */\n  BITCODE_BD DIMSCALE;\n  BITCODE_BD DIMASZ;\n  BITCODE_BD DIMEXO;\n  BITCODE_BD DIMDLI;\n  BITCODE_BD DIMEXE;\n  BITCODE_BD DIMRND;\n  BITCODE_BD DIMDLE;\n  BITCODE_BD DIMTP;\n  BITCODE_BD DIMTM;\n  BITCODE_BD DIMFXL;\n  BITCODE_BD DIMJOGANG;\n  BITCODE_BS DIMTFILL;\n  BITCODE_CMC DIMTFILLCLR;\n  BITCODE_BS DIMAZIN;\n  BITCODE_BS DIMARCSYM;\n  BITCODE_BD DIMTXT;\n  BITCODE_BD DIMCEN;\n  BITCODE_BD DIMTSZ;\n  BITCODE_BD DIMALTF;\n  BITCODE_BD DIMLFAC;\n  BITCODE_BD DIMTVP;\n  BITCODE_BD DIMTFAC;\n  BITCODE_BD DIMGAP;\n  BITCODE_T DIMPOST;\n  BITCODE_T DIMAPOST;\n  BITCODE_T DIMBLK_T;\n  BITCODE_T DIMBLK1_T;\n  BITCODE_T DIMBLK2_T;\n  BITCODE_BD DIMALTRND;\n  BITCODE_RS DIMCLRD_N; /* preR13 */\n  BITCODE_RS DIMCLRE_N; /* preR13 */\n  BITCODE_RS DIMCLRT_N; /* preR13 */\n  BITCODE_CMC DIMCLRD;\n  BITCODE_CMC DIMCLRE;\n  BITCODE_CMC DIMCLRT;\n  BITCODE_BS DIMADEC;\n  BITCODE_BS DIMFRAC;\n  BITCODE_BS DIMLUNIT;\n  BITCODE_BS DIMDSEP;\n  BITCODE_BS DIMTMOVE;\n  BITCODE_BS DIMALTZ;\n  BITCODE_BS DIMALTTZ;\n  BITCODE_BS DIMATFIT;\n  BITCODE_B DIMFXLON;   /*!< r2007+ */\n  BITCODE_B  DIMTXTDIRECTION; /*!< r2010+ */\n  BITCODE_BD DIMALTMZF; /*!< r2010+ */\n  BITCODE_T  DIMALTMZS; /*!< r2010+ */\n  BITCODE_BD DIMMZF;    /*!< r2010+ */\n  BITCODE_T  DIMMZS;    /*!< r2010+ */\n  BITCODE_BSd DIMLWD;\n  BITCODE_BSd DIMLWE;\n\n  BITCODE_H extref_handle;\n  BITCODE_H DIMTXSTY;\n\n  BITCODE_H DIMLDRBLK;\n  BITCODE_H DIMBLK;\n  BITCODE_H DIMBLK1;\n  BITCODE_H DIMBLK2;\n\n  BITCODE_H DIMLTYPE;\n  BITCODE_H DIMLTEX1;\n  BITCODE_H DIMLTEX2;\n} Dwg_Object_DIMSTYLE;\n\n/**\n VPORT_ENTITY_CONTROL (70) table object (r11-r2000)\n The table header of all vport entities (unused in newer versions)\n */\ntypedef struct _dwg_object_VPORT_ENTITY_CONTROL\n{\n  COMMON_TABLE_CONTROL_FIELDS;\n} Dwg_Object_VPORT_ENTITY_CONTROL;\n\n/**\n VPORT_ENTITY_HEADER (71) table object (r11-r2000)\n */\ntypedef struct _dwg_object_VPORT_ENTITY_HEADER\n{\n  COMMON_TABLE_FIELDS();\n  BITCODE_B flag1;\n  BITCODE_H xref_handle;\n  BITCODE_H vport_entity;\n} Dwg_Object_VPORT_ENTITY_HEADER;\n\n/**\n GROUP (72) object\n */\ntypedef struct _dwg_object_GROUP\n{\n  struct _dwg_object_object *parent;\n  BITCODE_TV name;\n  BITCODE_BS unnamed;\n  BITCODE_BS selectable;\n  BITCODE_BL num_groups;\n  BITCODE_H* groups;\n} Dwg_Object_GROUP;\n\n/**\n MLINESTYLE (73) object\n */\ntypedef struct _dwg_MLINESTYLE_line\n{\n  struct _dwg_object_MLINESTYLE *parent;\n  BITCODE_BD offset;\n  BITCODE_CMC color;\n  union {\n    BITCODE_BSd index;   /* until 2018 */\n    BITCODE_H ltype;     /* since 2018 */\n  } lt;\n} Dwg_MLINESTYLE_line;\n\ntypedef struct _dwg_object_MLINESTYLE\n{\n  struct _dwg_object_object *parent;\n  BITCODE_TV name;\n  BITCODE_TV desc;\n  BITCODE_BS flag;\n  BITCODE_CMC fill_color;\n  BITCODE_BD start_angle;\n  BITCODE_BD end_angle;\n  BITCODE_RC num_lines;\n  Dwg_MLINESTYLE_line* lines;\n} Dwg_Object_MLINESTYLE;\n\n/**\n OLE2FRAME (74 + varies) object\n */\ntypedef struct _dwg_entity_OLE2FRAME\n{\n  struct _dwg_object_entity *parent;\n\n  BITCODE_BS type;         /*!< DXF 71, 1: Link, 2: Embedded, 3: Static */\n  BITCODE_BS mode;         /*!< r2000+ DXF 72, tile_mode, 0: mspace, 1: pspace */\n  BITCODE_RC lock_aspect;  /*!< r2000+ DXF 73, 0 or 1 (locked) */\n  BITCODE_BL data_length;  /*!< DXF 90 */\n  char     * data;         /*!< DXF 310, the binary object data */\n  // embedded into data, not yet decoded:\n  // the MS-CFB (ole2 stream) starts at 0x80 in data\n  // before is probably:\n  BITCODE_BS oleversion;   /*!< DXF 70, always 2 */\n  char     * oleclient;    /*!< DXF 3, e.g. OLE or Paintbrush Picture */\n  BITCODE_3BD pt1;         /*!< DXF 10, upper left corner */\n  BITCODE_3BD pt2;         /*!< DXF 11, lower right corner */\n} Dwg_Entity_OLE2FRAME;\n\n/**\n DUMMY (75) object\n */\ntypedef struct _dwg_object_DUMMY\n{\n  struct _dwg_object_object *parent;\n  /* ??? not seen */\n} Dwg_Object_DUMMY;\n\n/**\n LONG_TRANSACTION (76) object\n */\ntypedef struct _dwg_object_LONG_TRANSACTION\n{\n  struct _dwg_object_object *parent;\n  /* ??? not seen */\n} Dwg_Object_LONG_TRANSACTION;\n\n/* NOT SURE ABOUT THIS ONE (IS IT OBJECT OR ENTITY?): */\n/**\n subtype PROXY_LWPOLYLINE (33) in a PROXY object\n Not a LWPOLYLINE (77? + varies)\n */\ntypedef struct _dwg_LWPOLYLINE_width\n{\n  BITCODE_BD start; /* 40 */\n  BITCODE_BD end;   /* 41 */\n} Dwg_LWPOLYLINE_width;\n\ntypedef struct _dwg_entity_PROXY_LWPOLYLINE\n{\n  struct _dwg_object_entity *parent;\n\n  BITCODE_RL size; /* from flags to *widths */\n  BITCODE_BS flags;\n  BITCODE_BD const_width;\n  BITCODE_BD elevation;\n  BITCODE_BD thickness;\n  BITCODE_BE extrusion;\n  BITCODE_BL num_points;\n  BITCODE_2RD* points;\n  BITCODE_BL num_bulges;\n  BITCODE_BD* bulges;\n  BITCODE_BL num_widths;\n  Dwg_LWPOLYLINE_width* widths;\n  BITCODE_RC unknown_1;\n  BITCODE_RC unknown_2;\n  BITCODE_RC unknown_3;\n} Dwg_Entity_PROXY_LWPOLYLINE;\n\n/**\n PROXY_ENTITY (498, 0x1f2) object\n */\ntypedef struct _dwg_entity_PROXY_ENTITY\n{\n  struct _dwg_object_entity *parent;\n\n  BITCODE_BL class_id;      /*!< DXF 91 */\n  BITCODE_BL version;       /*!< DXF 95 <r2018, 71 r2018+ */\n  BITCODE_BL maint_version; /*!< DXF 97 r2018+ */\n  BITCODE_B from_dxf;       /*!< DXF 70 */\n  char    * data;\n  BITCODE_H* objid_object_handles;\n  BITCODE_MS size;\n} Dwg_Entity_PROXY_ENTITY;\n\n/**\n PROXY OBJECT (499, 0x1f3) object\n */\ntypedef struct _dwg_object_PROXY_OBJECT\n{\n  struct _dwg_object_object *parent;\n\n  BITCODE_BL class_id;\n  BITCODE_BL version;\n  BITCODE_BL maint_version;\n  BITCODE_B from_dxf;\n  char    * data;\n  BITCODE_H* objid_object_handles;\n} Dwg_Object_PROXY_OBJECT;\n\n/**\n * types which are fixed and non-fixed:\n * also OLE2FRAME above\n */\n\n/**\n Structs for HATCH (78 + varies)\n */\ntypedef struct _dwg_HATCH_Color\n{\n  struct _dwg_entity_HATCH *parent;\n  BITCODE_BD shift_value; //0.0 non-shifted, 1.0 shifted\n  BITCODE_CMC color;\n} Dwg_HATCH_Color;\n\ntypedef struct _dwg_HATCH_ControlPoint\n{\n  struct _dwg_HATCH_PathSeg *parent;\n  BITCODE_2RD point;\n  BITCODE_BD weight;\n} Dwg_HATCH_ControlPoint;\n\ntypedef struct _dwg_HATCH_PathSeg\n{\n  struct _dwg_HATCH_Path *parent;\n  BITCODE_RC type_status;\n  /* LINE */\n  BITCODE_2RD first_endpoint;\n  BITCODE_2RD second_endpoint;\n  /* CIRCULAR ARC */\n  BITCODE_2RD center;\n  BITCODE_BD radius;\n  BITCODE_BD start_angle;\n  BITCODE_BD end_angle;\n  BITCODE_B is_ccw;\n  /* ELLIPTICAL ARC */\n  /* BITCODE_2RD center */\n  BITCODE_2RD endpoint;\n  BITCODE_BD minor_major_ratio;\n  /* BITCODE_BD start_angle; */\n  /* BITCODE_BD end_angle; */\n  /* BITCODE_B is_ccw; */\n  /* SPLINE */\n  BITCODE_BL degree;\n  BITCODE_B is_rational;\n  BITCODE_B is_periodic;\n  BITCODE_BL num_knots;\n  BITCODE_BL num_control_points;\n  BITCODE_BD* knots;\n  Dwg_HATCH_ControlPoint* control_points;\n  BITCODE_BL num_fitpts;\n  BITCODE_2RD *fitpts;\n  BITCODE_2RD start_tangent;\n  BITCODE_2RD end_tangent;\n} Dwg_HATCH_PathSeg;\n\ntypedef struct _dwg_HATCH_PolylinePath\n{\n  struct _dwg_HATCH_Path *parent;\n  BITCODE_2RD point;\n  BITCODE_BD bulge;\n} Dwg_HATCH_PolylinePath;\n\ntypedef struct _dwg_HATCH_Path\n{\n  struct _dwg_entity_HATCH *parent;\n  /* Segment path */\n  BITCODE_BL flag;\n  BITCODE_BL num_segs_or_paths;\n  Dwg_HATCH_PathSeg* segs;\n\n  /* Polyline path */\n  BITCODE_B bulges_present;\n  BITCODE_B closed;\n  Dwg_HATCH_PolylinePath* polyline_paths;\n\n  BITCODE_BL num_boundary_handles;\n} Dwg_HATCH_Path;\n\ntypedef struct _dwg_HATCH_DefLine\n{\n  struct _dwg_entity_HATCH *parent;\n  BITCODE_BD  angle;\n  BITCODE_2BD pt0;\n  BITCODE_2BD offset;\n  BITCODE_BS  num_dashes;\n  BITCODE_BD * dashes;\n} Dwg_HATCH_DefLine;\n\ntypedef struct _dwg_entity_HATCH\n{\n  struct _dwg_object_entity *parent;\n\n  BITCODE_BL is_gradient_fill;\n  BITCODE_BL reserved;\n  BITCODE_BD gradient_angle;\n  BITCODE_BD gradient_shift;\n  BITCODE_BL single_color_gradient;\n  BITCODE_BD gradient_tint;\n  BITCODE_BL num_colors;\n  Dwg_HATCH_Color* colors;\n  BITCODE_TV gradient_name;\n  BITCODE_BD elevation;\n  BITCODE_BE extrusion;\n  BITCODE_TV name;\n  BITCODE_B solid_fill;\n  BITCODE_B associative;\n  BITCODE_BL num_paths;\n  Dwg_HATCH_Path* paths;\n  BITCODE_BS style;\n  BITCODE_BS pattern_type;\n  BITCODE_BD angle;\n  BITCODE_BD scale_spacing;\n  BITCODE_B double_flag;\n  BITCODE_BS num_deflines;\n  Dwg_HATCH_DefLine * deflines;\n  BITCODE_B has_derived;\n  BITCODE_BD pixel_size;\n  BITCODE_BL num_seeds;\n  BITCODE_2RD * seeds;\n  BITCODE_BL num_boundary_handles;\n  BITCODE_H* boundary_handles;\n} Dwg_Entity_HATCH;\n\n/**\n XRECORD (79 + varies) object\n */\ntypedef struct _dwg_object_XRECORD\n{\n  struct _dwg_object_object *parent;\n\n  BITCODE_BL num_databytes;\n  BITCODE_BS cloning_flags;\n  BITCODE_BL num_xdata; /* computed */\n  Dwg_Resbuf* xdata;\n  BITCODE_BL num_objid_handles;\n  BITCODE_H* objid_handles;\n} Dwg_Object_XRECORD;\n\n/**\n PLACEHOLDER (80 + varies) object\n ACDBPLACEHOLDER\n */\ntypedef struct _dwg_object_PLACEHOLDER\n{\n  struct _dwg_object_object *parent;\n} Dwg_Object_PLACEHOLDER;\n\n/**\n * Entity MULTILEADER (varies)\n * R2000+ in work\n */\n\ntypedef struct _dwg_LEADER_Break\n{\n  struct _dwg_LEADER_Line *parent;\n  BITCODE_3BD start;         /*!< DXF 12 */\n  BITCODE_3BD end;           /*!< DXF 13 */\n} Dwg_LEADER_Break;\n\ntypedef struct _dwg_LEADER_Line // as documented by DXF\n{\n  struct _dwg_LEADER_Node *parent;\n  BITCODE_BL num_points;\n  BITCODE_3DPOINT* points;         /*!< DXF 10 */\n  BITCODE_BL num_breaks;\n  Dwg_LEADER_Break * breaks;       /*!< DXF 12, 13 */\n  BITCODE_BL  line_index;          /*!< DXF 91 */\n\n  /*!< r2010+: */\n  BITCODE_BS type; // 0 = invisible leader, 1 = straight leader, 2 = spline leader\n  BITCODE_CMC color;\n  BITCODE_H ltype; // 5 340\n  BITCODE_BLd linewt;\n  BITCODE_BD arrow_size;\n  BITCODE_H  arrow_handle; // 5 341\n  BITCODE_BL flags; // 1 = leader type, 2 = line color, 4 = line type, 8 = line weight,\n                    // 16 = arrow size, 32 = arrow symbol (handle)\n} Dwg_LEADER_Line;\n\ntypedef struct _dwg_ODALeader_Line //// as documented by ODA\n{\n  struct _dwg_Leader *parent;\n  BITCODE_BL num_points;\n  BITCODE_3BD * points;\n  BITCODE_BL num_breaks;\n  Dwg_LEADER_Break * breaks;\n  BITCODE_BL segment_index;\n  BITCODE_BL index;\n\n  BITCODE_BS type; // 0 = invisible leader, 1 = straight leader, 2 = spline leader\n  BITCODE_CMC color;\n  BITCODE_H ltype;\n  BITCODE_BLd linewt;\n  BITCODE_BD arrow_size;\n  BITCODE_H arrow_handle;\n  BITCODE_BL flags;\n} Dwg_ODALeader_Line;\n\ntypedef struct _dwg_LEADER_ArrowHead\n{\n  struct _dwg_entity_MULTILEADER *parent;\n  BITCODE_BL is_default;\n  BITCODE_H arrowhead;\n} Dwg_LEADER_ArrowHead;\n\ntypedef struct _dwg_LEADER_BlockLabel\n{\n  struct _dwg_entity_MULTILEADER *parent;\n  BITCODE_H attdef;\n  BITCODE_TV label_text;\n  BITCODE_BS ui_index;\n  BITCODE_BD width;\n} Dwg_LEADER_BlockLabel;\n\n/* as documented in ODA, but contradicting DXF docs, and\n   the reverse-engineered format */\ntypedef struct _dwg_ODALeader\n{\n  struct _dwg_entity_MULTILEADER *parent;\n  BITCODE_B is_valid;\n  BITCODE_B unknown;\n  BITCODE_3BD connection;\n  BITCODE_3BD direction;\n  BITCODE_BL num_breaks;\n  Dwg_LEADER_Break * breaks;\n  BITCODE_BL num_lines;\n  Dwg_LEADER_Line * lines;\n  BITCODE_BL index;\n  BITCODE_BD landing_distance;\n  /* ... */\n  BITCODE_BS attach_dir;\n} Dwg_ODALeader;\n\ntypedef struct _dwg_LEADER_Node\n{\n  struct _dwg_entity_MULTILEADER *parent;\n  BITCODE_B has_lastleaderlinepoint;    /*!< DXF 290 */\n  BITCODE_B has_dogleg;                 /*!< DXF 291 */\n  BITCODE_3BD lastleaderlinepoint;      /*!< DXF 10 */\n  BITCODE_3BD dogleg_vector;            /*!< DXF 11 */\n  BITCODE_BL branch_index;              /*!< DXF 90 */\n  BITCODE_BD dogleg_length;             /*!< DXF 40 */\n  BITCODE_BL num_lines;\n  Dwg_LEADER_Line *lines;               /*!< DXF 10 */\n  BITCODE_BL num_breaks;\n  Dwg_LEADER_Break * breaks;            /*!< DXF 12, 13 */\n\n  BITCODE_BS attach_dir; //2010+ 271\n} Dwg_LEADER_Node;\n\ntypedef union _dwg_MLEADER_Content\n{\n  struct _content_mtext\n    {\n      BITCODE_T default_text;\n      BITCODE_3BD normal; // 11\n      BITCODE_H style;\n      BITCODE_3BD location;\n      BITCODE_3BD direction;\n      BITCODE_BD rotation;\n      BITCODE_BD width;\n      BITCODE_BD height;\n      BITCODE_BD line_spacing_factor;\n      BITCODE_BS line_spacing_style;\n      BITCODE_CMC color;\n      BITCODE_BS alignment;\n      BITCODE_BS flow;\n      BITCODE_CMC bg_color;\n      BITCODE_BD bg_scale;\n      BITCODE_BL bg_transparency;\n      BITCODE_B is_bg_fill;\n      BITCODE_B is_bg_mask_fill;\n      BITCODE_BS col_type;\n      BITCODE_B is_height_auto;\n      BITCODE_BD col_width;\n      BITCODE_BD col_gutter;\n      BITCODE_B is_col_flow_reversed;\n      BITCODE_BL num_col_sizes;\n      BITCODE_BD *col_sizes;\n      BITCODE_B word_break;\n      BITCODE_B unknown;\n    } txt;\n  struct _content_block\n    {\n      BITCODE_H block_table;\n      BITCODE_3BD normal; // 14\n      BITCODE_3BD location;\n      BITCODE_3BD scale;\n      BITCODE_BD rotation;\n      BITCODE_CMC color;\n      BITCODE_BD *transform;\n    } blk;\n} Dwg_MLEADER_Content;\n\n/* The MLeaderAnnotContext object (par 20.4.86), embedded into an MLEADER */\ntypedef struct _dwg_MLEADER_AnnotContext\n{\n  //AcDbObjectContextData:\n  BITCODE_BS class_version;  /*!< r2010+ DXF 70 */\n  BITCODE_B has_xdic_file;   /*!< r2010+ default true */\n  BITCODE_B is_default;      /*!< r2010+ DXF 290 */\n\n  // AcDbAnnotScaleObjectContextData:\n  BITCODE_H scale_handle;      /*!< DXF 340 hard ptr to AcDbScale */\n\n  BITCODE_BL num_leaders;\n  Dwg_LEADER_Node * leaders;\n\n  BITCODE_BS attach_dir;\n\n  BITCODE_BD scale;\n  BITCODE_3BD content_base;\n  BITCODE_BD text_height;\n  BITCODE_BD arrow_size;\n  BITCODE_BD landing_gap;\n  BITCODE_BS text_left;\n  BITCODE_BS text_right;\n  BITCODE_BS text_alignment;\n  BITCODE_BS attach_type;\n\n  BITCODE_B has_content_txt;\n  BITCODE_B has_content_blk;\n  Dwg_MLEADER_Content content; // union txt/blk\n\n  BITCODE_3BD base;\n  BITCODE_3BD base_dir;\n  BITCODE_3BD base_vert;\n  BITCODE_B is_normal_reversed;\n\n  BITCODE_BS text_top;\n  BITCODE_BS text_bottom;\n\n} Dwg_MLEADER_AnnotContext;\n\n// dbmleader.h\ntypedef struct _dwg_entity_MULTILEADER\n{\n  struct _dwg_object_entity *parent;\n\n  BITCODE_BS class_version; /*!< r2010+ =2 */\n  Dwg_MLEADER_AnnotContext ctx;\n  BITCODE_H mleaderstyle;\n  BITCODE_BL flags; /* override */\n  BITCODE_BS type;\n  BITCODE_CMC color;\n  BITCODE_H ltype;\n  BITCODE_BLd linewt;\n  BITCODE_B has_landing;\n  BITCODE_B has_dogleg;\n  BITCODE_BD landing_dist;\n  BITCODE_H arrow_handle;\n  BITCODE_BD arrow_size; /* the default */\n  BITCODE_BS style_content;\n  BITCODE_H text_style;\n  BITCODE_BS text_left;\n  BITCODE_BS text_right;\n  BITCODE_BS text_angletype;\n  BITCODE_BS attach_type;\n  BITCODE_CMC text_color;\n  BITCODE_B has_text_frame;\n  BITCODE_H block_style;\n  BITCODE_CMC block_color;\n  BITCODE_3BD block_scale;\n  BITCODE_BD block_rotation;\n  BITCODE_BS style_attachment; // 0 = center extents, 1 = insertion point\n  BITCODE_B is_annotative;\n\n  /* until r2007: */\n  BITCODE_BL num_arrowheads;\n  Dwg_LEADER_ArrowHead *arrowheads;\n  BITCODE_BL num_blocklabels;\n  Dwg_LEADER_BlockLabel *blocklabels;\n  BITCODE_B neg_textdir;\n  BITCODE_BS ipe_alignment;\n  BITCODE_BS justification;\n  BITCODE_BD scale_factor;\n\n  BITCODE_BS attach_dir;    /*!< r2010+ (0 = horizontal, 1 = vertical) */\n  BITCODE_BS attach_top;    /*!< r2010+ */\n  BITCODE_BS attach_bottom; /*!< r2010+ */\n\n  BITCODE_B text_extended;  /*!< r2013+ */\n} Dwg_Entity_MULTILEADER;\n\n/**\n * Object MLEADERSTYLE (varies)\n * R2000+\n */\ntypedef struct _dwg_object_MLEADERSTYLE\n{\n  struct _dwg_object_object *parent;\n\n  BITCODE_BS class_version; /*!< r2010+ =2 */\n  BITCODE_BS content_type;\n  BITCODE_BS mleader_order;\n  BITCODE_BS leader_order;\n  BITCODE_BL max_points;\n  BITCODE_BD first_seg_angle;\n  BITCODE_BD second_seg_angle;\n  BITCODE_BS type;\n  BITCODE_CMC line_color;\n  BITCODE_H line_type;\n  BITCODE_BLd linewt;\n  BITCODE_B has_landing;\n  BITCODE_B has_dogleg;\n  BITCODE_BD landing_gap;\n  BITCODE_BD landing_dist;\n  BITCODE_TV description;\n  BITCODE_H arrow_head;\n  BITCODE_BD arrow_head_size;\n  BITCODE_TV text_default;\n  BITCODE_H text_style;\n  BITCODE_BS attach_left;\n  BITCODE_BS attach_right;\n  BITCODE_BS text_angle_type;\n  BITCODE_BS text_align_type;\n  BITCODE_CMC text_color;\n  BITCODE_BD text_height;\n  BITCODE_B text_frame;\n  BITCODE_B is_new_format; /* computed */\n  BITCODE_B text_always_left;\n  BITCODE_BD align_space;\n  BITCODE_H block;\n  BITCODE_CMC block_color;\n  BITCODE_3BD block_scale;\n  BITCODE_B use_block_scale;\n  BITCODE_BD block_rotation;\n  BITCODE_B use_block_rotation;\n  BITCODE_BS block_connection;\n  BITCODE_BD scale;\n  BITCODE_B changed;\n  BITCODE_B is_annotative;\n  BITCODE_BD break_size;\n\n  BITCODE_BS attach_dir;    /*!< r2010+ (0 = horizontal, 1 = vertical) */\n  BITCODE_BS attach_top;    /*!< r2010+ */\n  BITCODE_BS attach_bottom; /*!< r2010+ */\n\n  BITCODE_B text_extended;   /*!< r2013+ */\n} Dwg_Object_MLEADERSTYLE;\n\n/**\n VBA_PROJECT (81 + varies) object\n Has its own optional section? section[5]?\n */\ntypedef struct _dwg_object_VBA_PROJECT\n{\n  struct _dwg_object_object *parent;\n\n  BITCODE_RL num_bytes;\n  BITCODE_TF bytes;\n} Dwg_Object_VBA_PROJECT;\n\n\n/**\n LAYOUT (82 + varies) object\n */\ntypedef struct _dwg_object_LAYOUT\n{\n  struct _dwg_object_object *parent;\n\n  // AcDbPlotSettings:\n  BITCODE_TV page_setup_name;\n  BITCODE_TV printer_or_config;\n  BITCODE_BS plot_layout_flags;\n  BITCODE_BD left_margin;\n  BITCODE_BD bottom_margin;\n  BITCODE_BD right_margin;\n  BITCODE_BD top_margin;\n  BITCODE_BD paper_width;\n  BITCODE_BD paper_height;\n  BITCODE_TV paper_size;\n  BITCODE_2BD_1 plot_origin;\n  BITCODE_BS paper_units;\n  BITCODE_BS plot_rotation;\n  BITCODE_BS plot_type;\n  BITCODE_2BD_1 window_min;\n  BITCODE_2BD_1 window_max;\n  BITCODE_TV plot_view_name;\n  BITCODE_BD real_world_units;\n  BITCODE_BD drawing_units;\n  BITCODE_TV current_style_sheet;\n  BITCODE_BS scale_type;\n  BITCODE_BD scale_factor;\n  BITCODE_2BD_1 paper_image_origin;\n  BITCODE_BS shade_plot_mode;\n  BITCODE_BS shade_plot_res_level;\n  BITCODE_BS shade_plot_custom_dpi;\n\n  // AcDbLayout:\n  BITCODE_TV layout_name;\n  BITCODE_BS tab_order;\n  BITCODE_BS flag;\n  BITCODE_3DPOINT ucs_origin;\n  BITCODE_2DPOINT minimum_limits;\n  BITCODE_2DPOINT maximum_limits;\n  BITCODE_3DPOINT ins_point;\n  BITCODE_3DPOINT ucs_x_axis;\n  BITCODE_3DPOINT ucs_y_axis;\n  BITCODE_BD elevation;\n  BITCODE_BS orthoview_type;\n  BITCODE_3DPOINT extent_min;\n  BITCODE_3DPOINT extent_max;\n  BITCODE_H plot_view; \t\t// r2004+\n  BITCODE_H visualstyle; \t// r2007+\n  BITCODE_H block_header;\n  BITCODE_H active_viewport;\n  BITCODE_H base_ucs;\n  BITCODE_H named_ucs;\n  BITCODE_BL num_viewports; \t// r2004+\n  BITCODE_H* viewports;     \t// r2004+\n} Dwg_Object_LAYOUT;\n\n/**\n * And the non-fixed types, classes, only\n */\n\n/**\n Class DICTIONARYVAR (varies)\n */\ntypedef struct _dwg_object_DICTIONARYVAR\n{\n  struct _dwg_object_object *parent;\n\n  BITCODE_RC intval;\n  BITCODE_TV str;\n} Dwg_Object_DICTIONARYVAR;\n\n/**\n Class DICTIONARYWDFLT (varies)\n */\ntypedef struct _dwg_object_DICTIONARYWDFLT\n{\n  struct _dwg_object_object *parent;\n\n  BITCODE_BL numitems;    /*!< no DXF */\n  BITCODE_BS cloning;     /*!< DXF 281 */\n  BITCODE_RC hard_owner;  /*!< DXF 330 */\n  BITCODE_TV* texts;      /*!< DXF 3 */\n  BITCODE_H* itemhandles; /*!< DXF 350/360, pairwise with texts */\n\n  BITCODE_RL cloning_r14; /*!< r14 only */\n  BITCODE_H defaultid;\n} Dwg_Object_DICTIONARYWDFLT;\n\n/**\n Class TABLE (varies)\n */\n\n// 20.4.99. also for FIELD\ntypedef struct _dwg_TABLE_value\n{\n  BITCODE_BL flags;\n  BITCODE_BL data_type;\n  BITCODE_BL data_size;\n  BITCODE_BL data_long;\n  BITCODE_BD data_double;\n  BITCODE_TV data_string;\n  char     * data_date;\n  BITCODE_2RD data_point;\n  BITCODE_3RD data_3dpoint;\n  BITCODE_BL unit_type;\n  BITCODE_TV format_string;\n  BITCODE_TV value_string;\n} Dwg_TABLE_value;\n\n// 20.4.100 Custom data collection for table cells, cols, rows\ntypedef struct _dwg_TABLE_CustomDataItem\n{\n  BITCODE_TV name;\n  Dwg_TABLE_value value;\n\n  struct _dwg_TableCell *cell_parent;\n  struct _dwg_TableRow *row_parent;\n} Dwg_TABLE_CustomDataItem;\n\ntypedef struct _dwg_TABLE_Cell\n{\n  BITCODE_BS type;\n  BITCODE_RC flags;\n  BITCODE_B merged_value;\n  BITCODE_B autofit_flag;\n  BITCODE_BL merged_width_flag;\n  BITCODE_BL merged_height_flag;\n  BITCODE_BD rotation_value;\n  BITCODE_TV text_string;\n  BITCODE_BD block_scale;\n  BITCODE_B additional_data_flag;\n  BITCODE_BS attr_def_index;\n  BITCODE_TV attr_def_text;\n  BITCODE_B additional_data_flag2;\n  BITCODE_BL cell_flag_override;\n  BITCODE_RC virtual_edge_flag;\n  BITCODE_RS cell_alignment;\n  BITCODE_B background_fill_none;\n  BITCODE_CMC background_color;\n  BITCODE_CMC content_color;\n  BITCODE_H text_style;\n  BITCODE_BD text_height;\n  BITCODE_CMC top_grid_color;\n  BITCODE_BS top_grid_linewt;\n  BITCODE_BS top_visibility;\n  BITCODE_CMC right_grid_color;\n  BITCODE_BS right_grid_linewt;\n  BITCODE_BS right_visibility;\n  BITCODE_CMC bottom_grid_color;\n  BITCODE_BS bottom_grid_linewt;\n  BITCODE_BS bottom_visibility;\n  BITCODE_CMC left_grid_color;\n  BITCODE_BS left_grid_linewt;\n  BITCODE_BS left_visibility;\n  BITCODE_BL unknown;\n  Dwg_TABLE_value value;\n  BITCODE_H cell_handle;\n  BITCODE_BS num_attr_defs;\n  BITCODE_H* attr_def_id;\n  BITCODE_H text_style_override;\n\n  struct _dwg_entity_TABLE *parent;\n} Dwg_TABLE_Cell;\n\ntypedef struct _dwg_TABLE_BreakHeight\n{\n  BITCODE_3BD position;\n  BITCODE_BD height;\n  BITCODE_BL flag;\n\n  struct _dwg_entity_TABLE *parent;\n} Dwg_TABLE_BreakHeight;\n\ntypedef struct _dwg_TABLE_BreakRow\n{\n  BITCODE_3BD position;\n  BITCODE_BL start;\n  BITCODE_BL end;\n\n  struct _dwg_entity_TABLE *parent;\n} Dwg_TABLE_BreakRow;\n\ntypedef struct _dwg_LinkedData\n{\n  BITCODE_TV name;\n  BITCODE_TV desc;\n} Dwg_LinkedData;\n\ntypedef struct _dwg_TableCellContent_Attr\n{\n  BITCODE_H attdef;\n  BITCODE_TV value;\n  BITCODE_BL index;\n\n  struct _dwg_TableCellContent *parent;\n} Dwg_TableCellContent_Attr;\n\n// Content format 20.4.101.3\ntypedef struct _dwg_ContentFormat\n{\n  BITCODE_BL property_override_flags;\n  BITCODE_BL property_flags;\n  BITCODE_BL value_data_type; /* see 20.4.98 */\n  BITCODE_BL value_unit_type; /* see 20.4.98 */\n  BITCODE_TV value_format_string;\n  BITCODE_BD rotation;\n  BITCODE_BD block_scale;\n  BITCODE_BL cell_alignment;\n  BITCODE_CMC content_color;\n  BITCODE_H text_style;\n  BITCODE_BD text_height;\n} Dwg_ContentFormat;\n\ntypedef struct _dwg_TableCellContent\n{\n  BITCODE_BL type;\n  Dwg_TABLE_value value; // 20.4.99 Value\n  BITCODE_H handle;\n  BITCODE_BL num_attrs;\n  Dwg_TableCellContent_Attr *attrs;\n  BITCODE_BS has_content_format_overrides;\n  Dwg_ContentFormat content_format;\n\n  struct _dwg_TableCell *parent;\n} Dwg_TableCellContent;\n\n// 20.4.98\ntypedef struct _dwg_CellContentGeometry\n{\n  BITCODE_3BD dist_top_left;\n  BITCODE_3BD dist_center;\n  BITCODE_BD content_width;\n  BITCODE_BD content_height;\n  BITCODE_BD width;\n  BITCODE_BD height;\n  BITCODE_BD unknown;\n\n  struct _dwg_TableCell *cell_parent;\n  struct _dwg_TABLEGEOMETRY_Cell *geom_parent;\n} Dwg_CellContentGeometry;\n\ntypedef struct _dwg_TableCell\n{\n  BITCODE_BL flag;\n  BITCODE_TV tooltip;\n  BITCODE_BL customdata;\n  BITCODE_BL num_customdata_items;\n  Dwg_TABLE_CustomDataItem *customdata_items;\n  BITCODE_BL has_linked_data;\n  BITCODE_H  data_link;\n  BITCODE_BL num_rows;\n  BITCODE_BL num_cols;\n  BITCODE_BL unknown;\n  BITCODE_BL num_cell_contents;\n  Dwg_TableCellContent *cell_contents;\n  BITCODE_BL style_id;\n  BITCODE_BL has_geom_data;\n  BITCODE_BL geom_data_flag;\n  BITCODE_BD unknown_d40;\n  BITCODE_BD unknown_d41;\n  BITCODE_BL has_cell_geom;\n  BITCODE_H cell_geom_handle;\n  Dwg_CellContentGeometry *geom_data;\n\n  struct _dwg_CellStyle *style_parent;\n  struct _dwg_TableRow *row_parent;\n} Dwg_TableCell;\n\ntypedef struct _dwg_BorderStyle\n{\n  BITCODE_BL edge_flags;\n  BITCODE_BL border_property_overrides_flag;\n  BITCODE_BL border_type;\n  BITCODE_CMC color;\n  BITCODE_BLd linewt;\n  BITCODE_H line_type;\n  BITCODE_B invisible;\n  BITCODE_BD double_line_spacing;\n\n  struct _dwg_CellStyle *parent;\n} Dwg_BorderStyle;\n\n/**\n  Cell style 20.4.101.4\n  for TABLE, TABLECONTENT, CELLSTYLEMAP\n*/\ntypedef struct _dwg_CellStyle\n{\n  BITCODE_BL type; /* 1 cell, 2 row, 3 col, 4 fmt data, 5 table */\n  BITCODE_BS data_flags;\n  BITCODE_BL property_override_flags;\n  BITCODE_BL merge_flags;\n  BITCODE_CMC background_color;\n  BITCODE_BL content_layout;\n  Dwg_ContentFormat content_format;\n  BITCODE_BS margin_override_flags;\n  BITCODE_BD vert_margin;\n  BITCODE_BD horiz_margin;\n  BITCODE_BD bottom_margin;\n  BITCODE_BD right_margin;\n  BITCODE_BD margin_horiz_spacing;\n  BITCODE_BD margin_vert_spacing;\n  BITCODE_BL num_borders; /* 0-6 */\n  Dwg_BorderStyle *border;\n\n  struct _dwg_TableRow *tablerow_parent;\n  struct _dwg_TableDataColumn *tabledatacolumn_parent;\n} Dwg_CellStyle;\n\ntypedef struct _dwg_TableRow\n{\n  BITCODE_BL num_cells;\n  Dwg_TableCell *cells;\n  BITCODE_BL custom_data;\n  BITCODE_BL num_customdata_items;\n  Dwg_TABLE_CustomDataItem *customdata_items;\n  Dwg_CellStyle cellstyle;\n  BITCODE_BL style_id;\n  BITCODE_BL height;\n\n  struct _dwg_LinkedTableData *parent;\n} Dwg_TableRow;\n\ntypedef struct _dwg_TableDataColumn\n{\n  BITCODE_TV name;\n  BITCODE_BL custom_data;\n  //BITCODE_TV data;\n  Dwg_CellStyle cellstyle;\n  BITCODE_BL cellstyle_id;\n  BITCODE_BL width;\n\n  struct _dwg_LinkedTableData *parent;\n} Dwg_TableDataColumn;\n\ntypedef struct _dwg_LinkedTableData\n{\n  BITCODE_BL num_cols;\n  Dwg_TableDataColumn *cols;\n  BITCODE_BL num_rows;\n  Dwg_TableRow *rows;\n  BITCODE_BL num_field_refs;\n  BITCODE_H *field_refs;\n} Dwg_LinkedTableData;\n\ntypedef struct _dwg_FormattedTableMerged\n{\n  BITCODE_BL top_row;\n  BITCODE_BL left_col;\n  BITCODE_BL bottom_row;\n  BITCODE_BL right_col;\n\n  struct _dwg_FormattedTableData *parent;\n} Dwg_FormattedTableMerged;\n\ntypedef struct _dwg_FormattedTableData\n{\n  Dwg_CellStyle cellstyle;\n  BITCODE_BL num_merged_cells;\n  Dwg_FormattedTableMerged *merged_cells;\n\n  struct _dwg_object_TABLECONTENT *parent;\n} Dwg_FormattedTableData;\n\n#define TABLECONTENT_fields                                                   \\\n  Dwg_LinkedData ldata;                                                       \\\n  Dwg_LinkedTableData tdata;                                                  \\\n  Dwg_FormattedTableData fdata;                                               \\\n  BITCODE_H table_style\n\ntypedef struct _dwg_object_TABLECONTENT\n{\n  struct _dwg_object_object *parent;\n  TABLECONTENT_fields;\n} Dwg_Object_TABLECONTENT;\n\ntypedef struct _dwg_entity_TABLE\n{\n  struct _dwg_object_entity *parent;\n  //r2010+ TABLECONTENT:\n  TABLECONTENT_fields;\n\n  BITCODE_RC unknown_rc;\n  BITCODE_H unknown_h;\n  BITCODE_BL unknown_bl;\n  BITCODE_B unknown_b;\n  BITCODE_BL unknown_bl1;\n  BITCODE_3BD insertion_point; /*!< DXF 10 */\n  BITCODE_3BD scale;        /*!< DXF 41 */\n  BITCODE_BB data_flags;\n  BITCODE_BD rotation;      /*!< DXF 50 */\n  BITCODE_BE extrusion;    /*!< DXF 210 */\n  BITCODE_B has_attribs;    /*!< DXF 66 */\n  BITCODE_BL num_owned;\n  BITCODE_BS flag_for_table_value; /*!< DXF 90.\n                                     Bit flags, 0x06 (0x02 + 0x04): has block,\n                                     0x10: table direction, 0 = up, 1 = down,\n                                     0x20: title suppressed.\n                                     Normally 0x06 is always set. */\n  BITCODE_3BD horiz_direction; /*!< DXF 11 */\n  BITCODE_BL num_cols;     /*!< DXF 90 */\n  BITCODE_BL num_rows;     /*!< DXF 91 */\n  unsigned long num_cells; /*!< computed */\n  BITCODE_BD* col_widths;  /*!< DXF 142 */\n  BITCODE_BD* row_heights; /*!< DXF 141 */\n  Dwg_TABLE_Cell* cells;\n  BITCODE_B has_table_overrides;\n  BITCODE_BL table_flag_override; /*!< DXF 93 */\n  BITCODE_B title_suppressed;     /*!< DXF 280 */\n  BITCODE_B header_suppressed;    /*!< DXF 281 */\n  BITCODE_BS flow_direction;      /*!< DXF 70 */\n  BITCODE_BD horiz_cell_margin;   /*!< DXF 40 */\n  BITCODE_BD vert_cell_margin;    /*!< DXF 41 */\n  BITCODE_CMC title_row_color;    /*!< DXF 64 */\n  BITCODE_CMC header_row_color;   /*!< DXF 64 */\n  BITCODE_CMC data_row_color;     /*!< DXF 64 */\n  BITCODE_B title_row_fill_none;  /*!< DXF 283 */\n  BITCODE_B header_row_fill_none; /*!< DXF 283 */\n  BITCODE_B data_row_fill_none;   /*!< DXF 283 */\n  BITCODE_CMC title_row_fill_color;  /*!< DXF 63 */\n  BITCODE_CMC header_row_fill_color; /*!< DXF 63 */\n  BITCODE_CMC data_row_fill_color;   /*!< DXF 63 */\n  BITCODE_BS title_row_alignment;   /*!< DXF 170 */\n  BITCODE_BS header_row_alignment;  /*!< DXF 170 */\n  BITCODE_BS data_row_alignment;    /*!< DXF 170 */\n  BITCODE_H title_text_style;   /*!< DXF 7 */\n  BITCODE_H header_text_style;  /*!< DXF 7 */\n  BITCODE_H data_text_style;    /*!< DXF 7 */\n  BITCODE_BD title_row_height;  /*!< DXF 140 */\n  BITCODE_BD header_row_height; /*!< DXF 140 */\n  BITCODE_BD data_row_height;   /*!< DXF 140 */\n\n  BITCODE_B has_border_color_overrides;   /*!< if DXF 94 > 0 */\n  BITCODE_BL border_color_overrides_flag; /*!< DXF 94 */\n  BITCODE_CMC title_horiz_top_color;      /*!< DXF 64 if DXF 94 & 0x1 */\n  BITCODE_CMC title_horiz_ins_color;      /*!< DXF 65 if DXF 94 & 0x2 */\n  BITCODE_CMC title_horiz_bottom_color;   /*!< DXF 66 if DXF 94 & 0x4 */\n  BITCODE_CMC title_vert_left_color;      /*!< DXF 63 if DXF 94 & 0x8 */\n  BITCODE_CMC title_vert_ins_color;       /*!< DXF 68 if DXF 94 & 0x10 */\n  BITCODE_CMC title_vert_right_color;     /*!< DXF 69 if DXF 94 & 0x20 */\n  BITCODE_CMC header_horiz_top_color;     /*!< DXF 64 if DXF 94 & 0x40 */\n  BITCODE_CMC header_horiz_ins_color;     /*!< DXF 65 */\n  BITCODE_CMC header_horiz_bottom_color;  /*!< DXF 66 */\n  BITCODE_CMC header_vert_left_color;     /*!< DXF 63 */\n  BITCODE_CMC header_vert_ins_color;      /*!< DXF 68 */\n  BITCODE_CMC header_vert_right_color;    /*!< DXF 69 */\n  BITCODE_CMC data_horiz_top_color;       /*!< DXF 64 */\n  BITCODE_CMC data_horiz_ins_color;       /*!< DXF 65 */\n  BITCODE_CMC data_horiz_bottom_color;    /*!< DXF 66 */\n  BITCODE_CMC data_vert_left_color;       /*!< DXF 63 */\n  BITCODE_CMC data_vert_ins_color;        /*!< DXF 68 */\n  BITCODE_CMC data_vert_right_color;      /*!< DXF 69 */\n\n  BITCODE_B has_border_lineweight_overrides;   /*!< if DXF 95 > 0 */\n  BITCODE_BL border_lineweight_overrides_flag; /*!< DXF 95 */\n  BITCODE_BS title_horiz_top_linewt;\n  BITCODE_BS title_horiz_ins_linewt;\n  BITCODE_BS title_horiz_bottom_linewt;\n  BITCODE_BS title_vert_left_linewt;\n  BITCODE_BS title_vert_ins_linewt;\n  BITCODE_BS title_vert_right_linewt;\n  BITCODE_BS header_horiz_top_linewt;\n  BITCODE_BS header_horiz_ins_linewt;\n  BITCODE_BS header_horiz_bottom_linewt;\n  BITCODE_BS header_vert_left_linewt;\n  BITCODE_BS header_vert_ins_linewt;\n  BITCODE_BS header_vert_right_linewt;\n  BITCODE_BS data_horiz_top_linewt;\n  BITCODE_BS data_horiz_ins_linewt;\n  BITCODE_BS data_horiz_bottom_linewt;\n  BITCODE_BS data_vert_left_linewt;\n  BITCODE_BS data_vert_ins_linewt;\n  BITCODE_BS data_vert_right_linewt;\n\n  BITCODE_B has_border_visibility_overrides;\n  BITCODE_BL border_visibility_overrides_flag; /*!< DXF 96 */\n  BITCODE_BS title_horiz_top_visibility;\n  BITCODE_BS title_horiz_ins_visibility;\n  BITCODE_BS title_horiz_bottom_visibility;\n  BITCODE_BS title_vert_left_visibility;\n  BITCODE_BS title_vert_ins_visibility;\n  BITCODE_BS title_vert_right_visibility;\n  BITCODE_BS header_horiz_top_visibility;\n  BITCODE_BS header_horiz_ins_visibility;\n  BITCODE_BS header_horiz_bottom_visibility;\n  BITCODE_BS header_vert_left_visibility;\n  BITCODE_BS header_vert_ins_visibility;\n  BITCODE_BS header_vert_right_visibility;\n  BITCODE_BS data_horiz_top_visibility;\n  BITCODE_BS data_horiz_ins_visibility;\n  BITCODE_BS data_horiz_bottom_visibility;\n  BITCODE_BS data_vert_left_visibility;\n  BITCODE_BS data_vert_ins_visibility;\n  BITCODE_BS data_vert_right_visibility;\n\n  BITCODE_H block_header;\n  BITCODE_H first_attrib;\n  BITCODE_H last_attrib;\n  BITCODE_H* attrib_handles;\n  BITCODE_H seqend;\n  BITCODE_H title_row_style_override;\n  BITCODE_H header_row_style_override;\n  BITCODE_H data_row_style_override;\n\n  BITCODE_BS unknown_bs;\n  BITCODE_3BD hor_dir;\n  BITCODE_BL has_break_data;\n  BITCODE_BL break_flag;\n  BITCODE_BL break_flow_direction;\n  BITCODE_BD break_spacing;\n  BITCODE_BL break_unknown1;\n  BITCODE_BL break_unknown2;\n  BITCODE_BL num_break_heights;\n  Dwg_TABLE_BreakHeight *break_heights;\n  BITCODE_BL num_break_rows;\n  Dwg_TABLE_BreakRow *break_rows;\n\n} Dwg_Entity_TABLE;\n\n#undef TABLECONTENT_fields\n\n/**\n Class TABLESTYLE (varies)\n R2010+ TODO\n */\n\ntypedef struct _dwg_TABLESTYLE_Cell\n{\n  Dwg_TABLE_Cell cell;\n  BITCODE_BL id;   /* 1=title, 2=header, 3=data, 4=table.\n                      ref TABLESTYLE. custom IDs > 100 */\n  BITCODE_BL type; /* 1=data, 2=label */\n  BITCODE_TV name;\n\n  struct _dwg_object_TABLESTYLE *parent;\n} Dwg_TABLESTYLE_Cell;\n\ntypedef struct _dwg_TABLESTYLE_border\n{\n  BITCODE_BSd linewt;\n  BITCODE_B visible;\n  BITCODE_CMC color;\n\n  struct _dwg_TABLESTYLE_rowstyles *parent;\n} Dwg_TABLESTYLE_border;\n\ntypedef struct _dwg_TABLESTYLE_rowstyles\n{\n  BITCODE_H text_style;\n  BITCODE_BD text_height;\n  BITCODE_BS text_alignment;\n  BITCODE_CMC text_color;\n  BITCODE_CMC fill_color;\n  BITCODE_B has_bgcolor;\n\n  //6: top, horizontal inside, bottom, left, vertical inside, right\n  BITCODE_BL num_borders; // always 6\n  Dwg_TABLESTYLE_border *borders;\n\n  BITCODE_BL data_type;  // r2007+\n  BITCODE_BL unit_type;\n  BITCODE_TU format_string;\n\n  struct _dwg_object_TABLESTYLE *parent;\n} Dwg_TABLESTYLE_rowstyles;\n\ntypedef struct _dwg_object_TABLESTYLE\n{\n  struct _dwg_object_object *parent;\n\n  BITCODE_BS class_version;\n  BITCODE_TV name;\n  BITCODE_BS flags;\n  BITCODE_BS flow_direction;\n  BITCODE_BD horiz_cell_margin;\n  BITCODE_BD vert_cell_margin;\n  BITCODE_B title_suppressed;\n  BITCODE_B header_suppressed;\n\n  // 0: data, 1: title, 2: header\n  BITCODE_BL num_rowstyles; // always 3\n  Dwg_TABLESTYLE_rowstyles *rowstyles;\n\n  BITCODE_BL num_cells;   // r2010+ nyi\n  Dwg_TABLESTYLE_Cell* cells;\n} Dwg_Object_TABLESTYLE;\n\n/**\n Class CELLSTYLEMAP (varies)\n R2008+ TABLESTYLE extension class\n */\n\ntypedef struct _dwg_CELLSTYLEMAP_Cell\n{\n  Dwg_CellStyle style;\n  BITCODE_BL id;   /* 1=title, 2=header, 3=data, 4=table.\n                      ref TABLESTYLE. custom IDs > 100 */\n  BITCODE_BL type; /* 1=data, 2=label */\n  BITCODE_TV name;\n\n  struct _dwg_object_CELLSTYLEMAP *parent;\n} Dwg_CELLSTYLEMAP_Cell;\n\ntypedef struct _dwg_object_CELLSTYLEMAP\n{\n  struct _dwg_object_object *parent;\n\n  BITCODE_BL num_cells;\n  Dwg_CELLSTYLEMAP_Cell* cells;\n} Dwg_Object_CELLSTYLEMAP;\n\n/* 20.4.103 TABLEGEOMETRY\n r2008+ optional, == 20.4.98\n */\n\ntypedef struct _dwg_TABLEGEOMETRY_Cell\n{\n  BITCODE_BL flag;\n  BITCODE_BD width_w_gap;\n  BITCODE_BD height_w_gap;\n  BITCODE_H unknown;\n  BITCODE_BL num_geom_data;\n  Dwg_CellContentGeometry *geom_data;\n\n  struct _dwg_object_TABLEGEOMETRY *parent;\n} Dwg_TABLEGEOMETRY_Cell;\n\ntypedef struct _dwg_object_TABLEGEOMETRY\n{\n  struct _dwg_object_object *parent;\n  BITCODE_BL num_rows;\n  BITCODE_BL num_cols;\n  BITCODE_BL num_cells; /* = num_rows * num_cols */\n  Dwg_TABLEGEOMETRY_Cell *cells;\n} Dwg_Object_TABLEGEOMETRY;\n\n\n/**\n Class UNDERLAYDEFINITION (varies)\n in DXF as {PDF,DGN,DWF}DEFINITION\n */\ntypedef struct _dwg_object_UNDERLAYDEFINITION\n{\n  struct _dwg_object_object *parent;\n\n  BITCODE_TV filename; /*!< DXF 1, relative or absolute path to the image file */\n  BITCODE_TV name;     /*!< DXF 2, pdf: page number, dgn: default, dwf: ? */\n} Dwg_Object_UNDERLAYDEFINITION;\n\ntypedef struct _dwg_object_UNDERLAYDEFINITION Dwg_Object_PDFDEFINITION;\ntypedef struct _dwg_object_UNDERLAYDEFINITION Dwg_Object_DGNDEFINITION;\ntypedef struct _dwg_object_UNDERLAYDEFINITION Dwg_Object_DWFDEFINITION;\n\n/**\n Entity UNDERLAY, the reference (varies)\n As IMAGE but snappable.\n in DXF as{PDF,DGN,DWF}UNDERLAY\n */\ntypedef struct _dwg_entity_UNDERLAY\n{\n  struct _dwg_object_entity *parent;\n\n  BITCODE_BE extrusion; /*!< DXF 210 normal */\n  BITCODE_3BD insertion_pt; /*!< DXF 10 */\n  BITCODE_3BD scale;   /*!< DXF 41 */\n  BITCODE_BD angle;    /*!< DXF 50 */\n  BITCODE_RC flag;     /*!< DXF 280: 1 is_clipped, 2 is_on, 4 is_monochrome,\n                            8 is_adjusted_for_background, 16 is_clip_inverted,\n                            ? is_frame_visible, ? is_frame_plottable */\n  BITCODE_RC contrast; /*!< DXF 281 20-100, def: 100 */\n  BITCODE_RC fade;     /*!< DXF 282 0-80, def: 0*/\n  BITCODE_BL num_clip_verts;\n  BITCODE_2RD *clip_verts; /*!< DXF 11: if 2 rectangle, > polygon */\n\n  BITCODE_H underlay_layer;\n  BITCODE_H definition_id; /*!< DXF 340 */\n\n} Dwg_Entity_UNDERLAY;\n\ntypedef struct _dwg_entity_UNDERLAY Dwg_Entity_PDFUNDERLAY;\ntypedef struct _dwg_entity_UNDERLAY Dwg_Entity_DGNUNDERLAY;\ntypedef struct _dwg_entity_UNDERLAY Dwg_Entity_DWFUNDERLAY;\n\n/**\n Class DBCOLOR (varies)\n */\ntypedef struct _dwg_object_DBCOLOR\n{\n  struct _dwg_object_object *parent;\n\n  BITCODE_BL class_version; // 0\n  BITCODE_BB unknown1; //  0  masked off first byte of rgb\n  BITCODE_RL rgb;      //420: 0xXXRRGGBB\n  BITCODE_RC unknown2; //     256\n  BITCODE_T name;      //430: DIC 6\n  BITCODE_T catalog;   //430: DIC COLOR GUIDE(R)\n  BITCODE_CMC color;   //62: 253 color index only as EED\n  //...\n} Dwg_Object_DBCOLOR;\n\n/**\n Class FIELDLIST AcDbField (varies)\n R2018+\n */\ntypedef struct _dwg_FIELD_ChildValue\n{\n  BITCODE_TV key;   /*!< DXF 6 */\n  Dwg_TABLE_value value;\n  struct _dwg_object_FIELD *parent;\n} Dwg_FIELD_ChildValue;\n\ntypedef struct _dwg_object_FIELD\n{\n  struct _dwg_object_object *parent;\n                    /* dxf group code */\n  BITCODE_TV id;           /* 1 */\n  BITCODE_TV code;         /* 2,3 */\n  BITCODE_BL num_childs;   /* 90 */\n  BITCODE_H *childs;       /* code:3, 360 */\n  BITCODE_BL num_objects;  /* 97 */\n  BITCODE_H *objects;      /* code:5, 331 */\n  BITCODE_TV format;       /* 4, until r2004 only */\n  BITCODE_BL evaluation_option; /* 91 */\n  BITCODE_BL filing_option;     /* 92 */\n  BITCODE_BL field_state;       /* 94 */\n  BITCODE_BL evaluation_status; /* 95 */\n  BITCODE_BL evaluation_error_code; /* 96 */\n  BITCODE_TV evaluation_error_msg;  /* 300 */\n  Dwg_TABLE_value value;\n  BITCODE_TV value_string;        /* 301,9 */\n  BITCODE_BL value_string_length; /* 98 ODA bug: TV */\n  BITCODE_BL num_childval;      /* 93 */\n  Dwg_FIELD_ChildValue *childval;\n} Dwg_Object_FIELD;\n\n/**\n * Object FIELDLIST (varies)\n */\ntypedef struct _dwg_object_FIELDLIST\n{\n  struct _dwg_object_object *parent;\n\n  BITCODE_BL num_fields;\n  BITCODE_B unknown;\n  BITCODE_H *fields;\n} Dwg_Object_FIELDLIST;\n\n/**\n Class GEODATA (varies)\n R2009+\n */\ntypedef struct _dwg_GEODATA_meshpt\n{\n  BITCODE_2RD source_pt;\n  BITCODE_2RD dest_pt;\n} Dwg_GEODATA_meshpt;\n\ntypedef struct _dwg_GEODATA_meshface\n{\n  BITCODE_BL face1;\n  BITCODE_BL face2;\n  BITCODE_BL face3;\n  BITCODE_BL face4;\n} Dwg_GEODATA_meshface;\n\ntypedef struct _dwg_object_GEODATA\n{                   /* dxf group code */\n  struct _dwg_object_object *parent;\n\n  BITCODE_BL class_version;\n  BITCODE_H host_block;\n  BITCODE_BS coord_type; /* 0 unknown, 1 local grid, 2 projected grid,\n                            3 geographic defined by latitude/longitude) */\n  BITCODE_3BD design_pt;\n  BITCODE_3BD ref_pt;\n  BITCODE_3BD obs_pt;\n  BITCODE_BD unit_scale_horiz;\n  BITCODE_BL units_value_horiz;\n  BITCODE_BD unit_scale_vert;\n  BITCODE_BL units_value_vert;\n  BITCODE_3BD up_dir;\n  BITCODE_3BD north_dir;\n  BITCODE_BL scale_est; /* None = 1, User specified scale factor = 2,\n                           Grid scale at reference point = 3, Prismodial = 4 */\n  BITCODE_BD user_scale_factor;\n  BITCODE_B sea_level_corr;\n  BITCODE_BD sea_level_elev;\n  BITCODE_BD coord_proj_radius;\n  BITCODE_T coord_system_def;\n  BITCODE_T geo_rss_tag;\n  BITCODE_T coord_system_datum; /* obsolete */\n  BITCODE_T coord_system_wkt; /* obsolete */\n\n  BITCODE_T observation_from_tag;\n  BITCODE_T observation_to_tag;\n  BITCODE_T observation_coverage_tag;\n  BITCODE_BL num_geomesh_pts;\n  Dwg_GEODATA_meshpt *geomesh_pts;\n  BITCODE_BL num_geomesh_faces;\n  Dwg_GEODATA_meshface *geomesh_faces;\n\n  BITCODE_B has_civil_data;\n  BITCODE_B obsolete_false;\n  BITCODE_BD north_dir_angle_deg;\n  BITCODE_BD north_dir_angle_rad;\n} Dwg_Object_GEODATA;\n\n/**\n Class IDBUFFER (varies)\n */\ntypedef struct _dwg_object_IDBUFFER\n{\n  struct _dwg_object_object *parent;\n\n  BITCODE_RC unknown;\n  BITCODE_BL num_obj_ids;\n  BITCODE_H* obj_ids;\n} Dwg_Object_IDBUFFER;\n\n/**\n Classes for IMAGE (varies)\n */\n\ntypedef struct _dwg_entity_IMAGE\n{\n  struct _dwg_object_entity *parent;\n\n  BITCODE_BL class_version;\n  BITCODE_3BD pt0;\n  BITCODE_3BD uvec;\n  BITCODE_3BD vvec;\n  BITCODE_2RD size; /*!< DXF 13/23; width, height in pixel */\n  BITCODE_BS display_props;\n  BITCODE_B clipping;\n  BITCODE_RC brightness;\n  BITCODE_RC contrast;\n  BITCODE_RC fade;\n  BITCODE_B clip_mode;\n  BITCODE_BS clip_boundary_type;\n  BITCODE_BL num_clip_verts;\n  BITCODE_2RD* clip_verts;\n  BITCODE_H imagedef;\n  BITCODE_H imagedefreactor;\n} Dwg_Entity_IMAGE;\n\n/**\n Class IMAGEDEF (varies)\n */\ntypedef struct _dwg_object_IMAGEDEF\n{\n  struct _dwg_object_object *parent;\n\n  BITCODE_BL class_version;\n  BITCODE_2RD image_size;\n  BITCODE_TV file_path;\n  BITCODE_B is_loaded;\n  BITCODE_RC resunits;\n  BITCODE_2RD pixel_size;\n  //BITCODE_H xrefctrl;    /*!< r2010+ */\n} Dwg_Object_IMAGEDEF;\n\n/**\n Class IMAGEDEF_REACTOR (varies)\n */\ntypedef struct _dwg_object_IMAGEDEF_REACTOR\n{\n  struct _dwg_object_object *parent;\n\n  BITCODE_BL class_version;\n} Dwg_Object_IMAGEDEF_REACTOR;\n\n/**\n Classes for LAYER_INDEX (varies)\n */\ntypedef struct _dwg_LAYER_entry\n{\n  BITCODE_BL idxlong;\n  BITCODE_T layername;\n\n  struct _dwg_object_LAYER_INDEX *parent;\n} Dwg_LAYER_entry;\n\ntypedef struct _dwg_object_LAYER_INDEX\n{\n  struct _dwg_object_object *parent;\n\n  BITCODE_BL timestamp1;\n  BITCODE_BL timestamp2;\n  BITCODE_BL num_entries;\n  // TODO: merge\n  Dwg_LAYER_entry* entries;\n  BITCODE_H* layer_entries;\n} Dwg_Object_LAYER_INDEX;\n\n/**\n Classes for LWPOLYLINE (77 + varies)\n */\ntypedef struct _dwg_entity_LWPOLYLINE\n{\n  struct _dwg_object_entity *parent;\n\n  BITCODE_BS flag;              /*!< DXF 70 */\n  BITCODE_BD const_width;       /*!< DXF 43 */\n  BITCODE_BD elevation;         /*!< DXF 38 */\n  BITCODE_BD thickness;         /*!< DXF 39 */\n  BITCODE_BE extrusion;        /*!< DXF 210 */\n  BITCODE_BL num_points;        /*!< DXF 90 */\n  BITCODE_2RD* points;          /*!< DXF 10,20 */\n  BITCODE_BL num_bulges;\n  BITCODE_BD* bulges;           /*!< DXF 42 */\n  BITCODE_BL num_vertexids;     /*!< r2010+, same as num_points */\n  BITCODE_BL* vertexids;        /*!< r2010+ DXF 91 */\n  BITCODE_BL num_widths;\n  Dwg_LWPOLYLINE_width* widths; /*!< DXF 40,41 */\n} Dwg_Entity_LWPOLYLINE;\n\n/**\n * 20.4.89 Class AcDbObjectContextData (varies)\n * R2010+\n */\ntypedef struct _dwg_object_OBJECTCONTEXTDATA\n{\n  struct _dwg_object_object *parent;\n\n  BITCODE_BS class_version; /*!< r2010+ =3 */\n  BITCODE_B has_file;\n  BITCODE_B defaultflag;\n} Dwg_Object_OBJECTCONTEXTDATA;\n\n/**\n Class RASTERVARIABLES (varies)\n (used in conjunction with IMAGE entities)\n */\ntypedef struct _dwg_object_RASTERVARIABLES\n{\n  struct _dwg_object_object *parent;\n\n  BITCODE_BL class_version;\n  BITCODE_BS display_frame;\n  BITCODE_BS display_quality;\n  BITCODE_BS units;\n} Dwg_Object_RASTERVARIABLES;\n\n/**\n Object SCALE (varies)\n */\ntypedef struct _dwg_object_SCALE\n{\n  struct _dwg_object_object *parent;\n\n  BITCODE_BS flag;\n  BITCODE_TV name;\n  BITCODE_BD paper_units;\n  BITCODE_BD drawing_units;\n  BITCODE_B has_unit_scale;\n} Dwg_Object_SCALE;\n\n/**\n Class SORTENTSTABLE (varies)\n */\ntypedef struct _dwg_object_SORTENTSTABLE\n{\n  struct _dwg_object_object *parent;\n\n  BITCODE_BL num_ents;\n  BITCODE_H* sort_ents;\n  BITCODE_H dictionary;\n  BITCODE_H* ents;\n} Dwg_Object_SORTENTSTABLE;\n\n/**\n Class SPATIAL_FILTER (varies)\n */\ntypedef struct _dwg_object_SPATIAL_FILTER\n{\n  struct _dwg_object_object *parent;\n\n  BITCODE_BS num_points;\n  BITCODE_2RD* points;\n  BITCODE_BE extrusion;\n  BITCODE_3BD clip_bound_origin;\n  BITCODE_BS display_boundary;\n  BITCODE_BS front_clip_on;\n  BITCODE_BD front_clip_dist;\n  BITCODE_BS back_clip_on;\n  BITCODE_BD back_clip_dist;\n  BITCODE_BD* inverse_block_transform;\n  BITCODE_BD* clip_bound_transform;\n} Dwg_Object_SPATIAL_FILTER;\n\n/**\n Class SPATIAL_INDEX (varies)\n */\ntypedef struct _dwg_object_SPATIAL_INDEX\n{\n  struct _dwg_object_object *parent;\n\n  BITCODE_BL timestamp1;\n  BITCODE_BL timestamp2;\n  char     * unknown;\n} Dwg_Object_SPATIAL_INDEX;\n\n/**\n WIPEOUT (varies, 504)\n R2000+, undocumented = IMAGE layover\n */\ntypedef struct _dwg_entity_WIPEOUT\n{\n  struct _dwg_object_entity *parent;\n\n  BITCODE_BL class_version;\n  BITCODE_3BD pt0;\n  BITCODE_3BD uvec;\n  BITCODE_3BD vvec;\n  BITCODE_2RD size;\n  BITCODE_BS display_props;\n  BITCODE_B clipping;\n  BITCODE_RC brightness;\n  BITCODE_RC contrast;\n  BITCODE_RC fade;\n  BITCODE_B clip_mode;\n  BITCODE_BS clip_boundary_type;\n  BITCODE_BL num_clip_verts;\n  BITCODE_2RD* clip_verts;\n  BITCODE_H imagedef;\n  BITCODE_H imagedefreactor;\n} Dwg_Entity_WIPEOUT;\n\n/**\n Class WIPEOUTVARIABLES (varies, 505)\n R2000+, Object bitsize: 96\n */\ntypedef struct _dwg_object_WIPEOUTVARIABLES\n{\n  struct _dwg_object_object *parent;\n  //BITCODE_BL class_version;  /*!< DXF 90 NY */\n  BITCODE_BS display_frame;    /*!< DXF 70  */\n} Dwg_Object_WIPEOUTVARIABLES;\n\n/**\n Class VISUALSTYLE (varies)\n R2007+\n */\ntypedef struct _dwg_object_VISUALSTYLE\n{\n  struct _dwg_object_object *parent;\n  BITCODE_T desc;       /*!< DXF 2  */\n  BITCODE_BS type;      /*!< DXF 70  */\n  BITCODE_BS face_lighting_model;  /*!< DXF 71 0:Invisible 1:Visible 2:Phong 3:Gooch */\n  BITCODE_BS face_lighting_quality;/*!< DXF 72 0:No lighting 1:Per face 2:Per vertex */\n  BITCODE_BS face_color_mode;   /*!< DXF 73 0 = No color\n                                  1 = Object color\n                                  2 = Background color\n                                  3 = Custom color\n                                  4 = Mono color\n                                  5 = Tinted\n                                  6 = Desaturated */\n  BITCODE_BD face_opacity;      /*!< DXF 40  */\n  BITCODE_BD face_specular;     /*!< DXF 41  */\n  BITCODE_BS face_modifier;     /*!< DXF 90 0:No modifiers 1:Opacity 2:Specular */\n  BITCODE_CMC color;                    /*!< DXF 62  */\n  BITCODE_CMC face_mono_color;          /*!< DXF 63 + 421 */\n  BITCODE_BS edge_model;                /*!< DXF 74 0:No edges 1:Isolines 2:Facet edges */\n  BITCODE_BL edge_style;                /*!< DXF 91  */\n  BITCODE_CMC edge_intersection_color;  /*!< DXF 64  */\n  BITCODE_CMC edge_obscured_color;      /*!< DXF 65  */\n  BITCODE_BS edge_obscured_line_pattern;        /*!< DXF 75   */\n  BITCODE_BS edge_intersection_line_pattern;    /*!< DXF 175  */\n  BITCODE_BD edge_crease_angle;         /*!< DXF 42  */\n  BITCODE_BS edge_modifier;             /*!< DXF 92  */\n  BITCODE_CMC edge_color;               /*!< DXF 66  */\n  BITCODE_BD edge_opacity;              /*!< DXF 43  */\n  BITCODE_BS edge_width;                /*!< DXF 76  */\n  BITCODE_BS edge_overhang;             /*!< DXF 77  */\n  BITCODE_BS edge_jitter;               /*!< DXF 78  */\n  BITCODE_CMC edge_silhouette_color;    /*!< DXF 67  */\n  BITCODE_BS edge_silhouette_width;     /*!< DXF 79  */\n  BITCODE_BS edge_halo_gap;             /*!< DXF 170  */\n  BITCODE_BS num_edge_isolines;         /*!< DXF 171  */\n  BITCODE_BS edge_hide_precision_flag;  /*!< DXF 290  */\n  BITCODE_BS edge_style_apply_flag;     /*!< DXF 174  */\n  BITCODE_BS display_style;             /*!< DXF 93  */\n  BITCODE_BD display_brightness;        /*!< DXF 44  */\n  BITCODE_BS display_shadow_type;       /*!< DXF 173  */\n  BITCODE_BS is_internal_use_only;      /*!< DXF 291  */\n  BITCODE_BS unknown_float45;           /*!< DXF 45  */\n\n  //BITCODE_H dictionary; /* (hard-pointer to DICTIONARY_VISUALSTYLE or reverse?) */\n} Dwg_Object_VISUALSTYLE;\n\n/**\n Object LIGHTLIST (varies)\n R2010+\n */\ntypedef struct _dwg_object_LIGHTLIST\n{\n  struct _dwg_object_object *parent;\n\n  BITCODE_H dictionary; /* (hard-pointer to ACAD_LIGHT dictionary entry) */\n  /* TODO */\n  BITCODE_BS class_version;\n  BITCODE_BS num_lights;\n  BITCODE_H*  lights_handles; /* one for each light */\n  BITCODE_TV* lights_names;   /* one for each light */\n} Dwg_Object_LIGHTLIST;\n\n/**\n Object MATERIAL (varies) UNKNOWN FIELDS\n R2007+ yet unused\n\nAcad Naming: e.g. Materials/assetlibrary_base.fbm/shaders/AdskShaders.mi\n                  Materials/assetlibrary_base.fbm/Mats/SolidGlass/Generic.xml\nTODO: maybe separate into the various map structs\n */\ntypedef struct _dwg_object_MATERIAL\n{\n  struct _dwg_object_object *parent;\n\n  BITCODE_T name; /*!< DXF 1 */\n  BITCODE_T desc; /*!< DXF 2 optional */\n\n  BITCODE_BS ambient_color_flag;    /*!< DXF 70 0 Use current color, 1 Override */\n  BITCODE_BD ambient_color_factor;  /*!< DXF 40 0.0 - 1.0 */\n  BITCODE_CMC ambient_color;        /*!< DXF 90 */\n\n  BITCODE_BS diffuse_color_flag;    /*!< DXF 71 0 Use current color, 1 Override */\n  BITCODE_BD diffuse_color_factor;  /*!< DXF 41 0.0 - 1.0 */\n  BITCODE_CMC diffuse_color;        /*!< DXF 91 */\n  BITCODE_BS diffusemap_source;     /*!< DXF 72 0 current, 1 image file (def) */\n  BITCODE_T diffusemap_filename;   /*!< DXF 3 if NULL no diffuse map */\n  BITCODE_BD diffusemap_blendfactor;/*!< DXF 42 def: 1.0 */\n  BITCODE_BS diffusemap_projection; /*!< DXF 73 1 Planar (def), 2 Box, 3 Cylinder, 4 Sphere */\n  BITCODE_BS diffusemap_tiling;     /*!< DXF 74 */ // 1 = Tile (def), 2 = Crop, 3 = Clamp\n  BITCODE_BS diffusemap_autotransform; /*!< DXF 75 */ // 1 no, 2: scale to curr ent,\n                                                      // 4: w/ current block transform\n  BITCODE_BD* diffusemap_transmatrix;  /*!< DXF 43: 16x BD */\n\n  BITCODE_BD specular_gloss_factor; /*!< DXF 44 def: 0.5 */\n  BITCODE_BS specular_color_flag;   /*!< DXF 76 0 Use current color, 1 Override */\n  BITCODE_BD specular_color_factor; /*!< DXF 45 0.0 - 1.0 */\n  BITCODE_CMC specular_color;       /*!< DXF 92 */\n\n  BITCODE_BS specularmap_source;     /*!< DXF 77 0 current, 1 image file (def) */\n  BITCODE_T specularmap_filename;   /*!< DXF 4 if NULL no specular map */\n  BITCODE_BD specularmap_blendfactor;/*!< DXF 46 def: 1.0 */\n  BITCODE_BS specularmap_projection; /*!< DXF 78 1 Planar (def), 2 Box, 3 Cylinder, 4 Sphere */\n  BITCODE_BS specularmap_tiling;       /*!< DXF 79 1 Tile (def), 2 Crop, 3 Clamp */\n  BITCODE_BS specularmap_autotransform;/*!< DXF 170 1 no, 2: scale to curr ent,\n                                                    4: w/ current block transform */\n  BITCODE_BD* specularmap_transmatrix; /*!< DXF 47: 16x BD */\n\n  //?? BD reflection_depth\n  //reflection_glossy_samples\n  BITCODE_BS reflectionmap_source;     /*!< DXF 171 0 current, 1 image file (default) */\n  BITCODE_T reflectionmap_filename;   /*!< DXF 6 if NULL no reflectionmap map */\n  BITCODE_BD reflectionmap_blendfactor;/*!< DXF 48 1.0 */\n  BITCODE_BS reflectionmap_projection; /*!< DXF 172 1 Planar (def), 2 Box, 3 Cylinder, 4 = Sphere */\n  BITCODE_BS reflectionmap_tiling;     /*!< DXF 173 1 Tile (def), 2 Crop, 3 Clamp */\n  BITCODE_BS reflectionmap_autotransform;/*!< DXF 174 */ // 1 no, 2: scale to curr ent,\n                                                         // 4: w/ current block transform\n  BITCODE_BD* reflectionmap_transmatrix; /*!< DXF 49: 16x BD */\n\n  BITCODE_BD opacity_percent;        /*!< DXF 140 def: 1.0 */\n  BITCODE_BS opacitymap_source;      /*!< DXF 175 0 current, 1 image file (def) */\n  BITCODE_T opacitymap_filename;    /*!< DXF 7 */ // if NULL no specular map\n  BITCODE_BD opacitymap_blendfactor; /*!< DXF 141 def: 1.0 */\n  BITCODE_BS opacitymap_projection;  /*!< DXF 176 1 Planar (def), 2 Box, 3 Cylinder, 4 Sphere */\n  BITCODE_BS opacitymap_tiling;        /*!< DXF 177 1 Tile (def), 2 Crop, 3 Clamp */\n  BITCODE_BS opacitymap_autotransform; /*!< DXF 178 */ // 1 no, 2: scale to curr ent,\n                                                       // 4: w/ current block transform\n  BITCODE_BD* opacitymap_transmatrix; /*!< DXF 142: 16x BD */\n\n  //BITCODE_B bump_enable\n  //?BD bump_amount\n  BITCODE_BS bumpmap_source;      /*!< DXF 179 0 current, 1 image file (def) */\n  BITCODE_T bumpmap_filename;    /*!< DXF 8 if NULL no bumpmap (called asset_name) */\n  BITCODE_BD bumpmap_blendfactor; /*!< DXF 143 def: 1.0 */\n  BITCODE_BS bumpmap_projection;  /*!< DXF 270 1 Planar (def), 2 Box, 3 Cylinder, 4 Sphere */\n  BITCODE_BS bumpmap_tiling;        /*!< DXF 271 1 Tile (def), 2 Crop, 3 Clamp */\n  BITCODE_BS bumpmap_autotransform; /*!< DXF 272 */ // 1 no, 2: scale to curr ent,\n                                                    // 4: w/ current block transform\n  BITCODE_BD* bumpmap_transmatrix;  /*!< DXF 144: 16x BD */\n\n  BITCODE_BD refraction_index;       /*!< DXF 145 def: 1.0 */\n  //?? BD refraction_depth\n  //?? BD refraction_translucency_weight\n  //?? refraction_glossy_samples\n  BITCODE_BS refractionmap_source;   /*!< DXF 273 0 current, 1 image file (def) */\n  BITCODE_T refractionmap_filename;  /*!< DXF 9 if NULL no refractionmap */\n  BITCODE_BD refractionmap_blendfactor;/*!< DXF 146 def: 1.0 */\n  BITCODE_BS refractionmap_projection; /*!< DXF 274 1 Planar (def), 2 Box, 3 Cylinder, 4 Sphere */\n  BITCODE_BS refractionmap_tiling;       /*!< DXF 275 1 Tile (def), 2 Crop, 3 Clamp */\n  BITCODE_BS refractionmap_autotransform;/*!< DXF 276 */ // 1 no, 2: scale to curr ent,\n                                                         // 4: w/ current block transform\n  BITCODE_BD* refractionmap_transmatrix; /*!< DXF 147: 16x BD */\n\n  BITCODE_BD color_bleed_scale;    /*!< DXF 460 */\n  BITCODE_BD indirect_dump_scale;  /*!< DXF 461 */\n  BITCODE_BD reflectance_scale;    /*!< DXF 462 */\n  BITCODE_BD transmittance_scale;  /*!< DXF 463 */\n  BITCODE_B two_sided_material;    /*!< DXF 290 */\n  BITCODE_BD luminance;            /*!< DXF 464 */\n  BITCODE_BS luminance_mode;       /*!< DXF 270 */\n  BITCODE_BS normalmap_method;     /*!< DXF 271 */\n  BITCODE_BD normalmap_strength;   /*!< DXF 465 def: 1.0 */\n  BITCODE_BS normalmap_source;     /*!< DXF 72 0 current, 1 image file (default) */\n  BITCODE_T normalmap_filename;   /*!< DXF 3 if NULL no normal map */\n  BITCODE_BD normalmap_blendfactor;/*!< DXF 42 def: 1.0 */\n  BITCODE_BS normalmap_projection; /*!< DXF 73 1 = Planar (def), 2 = Box, 3 = Cylinder, 4 = Sphere */\n  BITCODE_BS normalmap_tiling;     /*!< DXF 74 1 = Tile (def), 2 = Crop, 3 = Clamp */\n  BITCODE_BS normalmap_autotransform; /*!< DXF 75 1 no, 2: scale to curr ent,\n                                                  4: w/ current block transform */\n  BITCODE_BD* normalmap_transmatrix; /*!< DXF 43: 16x BD */\n  BITCODE_B materials_anonymous;     /*!< DXF 293 */\n  BITCODE_BS global_illumination_mode;/*!< DXF 272 */\n  BITCODE_BS final_gather_mode; /*!< DXF 273 */\n  BITCODE_T genprocname;        /*!< DXF 300 */\n  BITCODE_B genprocvalbool;     /*!< DXF 291 */\n  BITCODE_BS genprocvalint;     /*!< DXF 271 */\n  BITCODE_BD genprocvalreal;    /*!< DXF 469 */\n  BITCODE_T genprocvaltext;     /*!< DXF 301 */\n  BITCODE_B genproctableend;    /*!< DXF 292 */\n  BITCODE_CMC genprocvalcolorindex;/*!< DXF 62 */\n  BITCODE_BS genprocvalcolorrgb;/*!< DXF 420 */\n  BITCODE_T genprocvalcolorname;/*!< DXF 430 */\n  BITCODE_BS map_utile;         /*!< DXF 270 */\n  BITCODE_BD translucence;      /*!< DXF 148 */\n  BITCODE_BL self_illumination; /*!< DXF 90 */\n  BITCODE_BD reflectivity;      /*!< DXF 468 */\n  BITCODE_BL illumination_model;/*!< DXF 93 */\n  BITCODE_BL channel_flags;     /*!< DXF 94 */\n  //? BD backface_cull\n  //? BD self_illum_luminance\n  //? BD self_illum_color_temperature\n} Dwg_Object_MATERIAL;\n\n/**\n Object PLOTSETTINGS (varies) UNKNOWN FIELDS\n yet unsorted, and unused. See LAYOUT.\n */\ntypedef struct _dwg_object_PLOTSETTINGS\n{\n  struct _dwg_object_object *parent;\n\n  BITCODE_T page_setup_name;  /*!< DXF 1 */\n  BITCODE_T printer_cfg_file; /*!< DXF 2 */\n  BITCODE_T paper_size;       /*!< DXF 4 */\n  BITCODE_H plotview;         /*!< DXF 6 */\n  BITCODE_BD left_margin;     /*!< DXF 40, margins in mm */\n  BITCODE_BD bottom_margin;   /*!< DXF 42 */\n  BITCODE_BD right_margin;    /*!< DXF 43 */\n  BITCODE_BD top_margin;      /*!< DXF 44 */\n  BITCODE_BD paper_width;     /*!< DXF 44, in mm */\n  BITCODE_BD paper_height;    /*!< DXF 45, in mm */\n  BITCODE_2BD_1 plot_origin;         /*!< DXF 46 */ // + 47\n  BITCODE_2BD_1 plot_window_ll;      /*!< DXF 48 */ // + 49\n  BITCODE_2BD_1 plot_window_ur;      /*!< DXF 140 */ // + 141\n  BITCODE_BD num_custom_print_scale; /*!< DXF 142 */ // in paper units\n  BITCODE_BD den_custom_print_scale; /*!< DXF 143 */ // in drawing units\n  BITCODE_BS plot_layout;    /*!< DXF 70\n                                1 = PlotViewportBorders\n                                2 = ShowPlotStyles\n                                4 = PlotCentered\n                                8 = PlotHidden\n                                16 = UseStandardScale\n                                32 = PlotPlotStyles\n                                64 = ScaleLineweights\n                                128 = PrintLineweights\n                                512 = DrawViewportsFirst\n                                1024 = ModelType\n                                2048 = UpdatePaper\n                                4096 = ZoomToPaperOnUpdate\n                                8192 = Initializing\n                                16384 = PrevPlotInit */\n  BITCODE_BS plot_paper_units; /*!< DXF 72,  0 inches, 1 mm, 2 pixel */\n  BITCODE_BS plot_rotation;    /*!< DXF 73,  0 normal, 1 90, 2 180, 3 270 deg */\n  BITCODE_BS plot_type;        /*!< DXF 74,  0 display, 1 extents, 2 limits, 3 view (see DXF 6),\n                                             4 window (see 48-140), 5 layout */\n  BITCODE_H stylesheet;        /*!< DXF 7 */\n  BITCODE_B use_std_scale;     /*!< DXF 0 */\n  BITCODE_BS std_scale_type; /*!< DXF 75, 0 = scaled to fit,\n                                   1 = 1/128\"=1', 2 = 1/64\"=1', 3 = 1/32\"=1'\n                                   4 = 1/16\"=1', 5 = 3/32\"=1', 6 = 1/8\"=1'\n                                   7 = 3/16\"=1', 8 = 1/4\"=1', 9 = 3/8\"=1'\n                                   10 = 1/2\"=1', 11 = 3/4\"=1', 12 = 1\"=1'\n                                   13 = 3\"=1', 14 = 6\"=1', 15 = 1'=1'\n                                   16 = 1:1, 17= 1:2, 18 = 1:4 19 = 1:8, 20 = 1:10, 21= 1:16\n                                   22 = 1:20, 23 = 1:30, 24 = 1:40, 25 = 1:50, 26 = 1:100\n                                   27 = 2:1, 28 = 4:1, 29 = 8:1, 30 = 10:1, 31 = 100:1, 32 = 1000:1\n                               */\n  BITCODE_BD std_scale_factor; /*!< DXF 147, value of 75 */\n  BITCODE_BS shade_plot_mode;  /*!< DXF 76, 0 display, 1 wireframe, 2 hidden, 3 rendered,\n                                            4 visualstyle, 5 renderPreset */\n  BITCODE_BS shade_plot_res_level; /*!< DXF 77, 0 draft, 1 preview, 2 nomal,\n                                                3 presentation, 4 maximum, 5 custom */\n  BITCODE_BS  shade_plot_custom_dpi; /*!< DXF 78, 100-32767 */\n  BITCODE_2BD_1 paper_image_origin;  /*!< DXF 148 + 149 */\n  BITCODE_H   shade_plot_id;         /*!< DXF 333  optional */\n} Dwg_Object_PLOTSETTINGS;\n\n/**\n Object OBJECT_PTR (varies) UNKNOWN FIELDS\n yet unsorted, and unused.\n */\ntypedef struct _dwg_object_OBJECT_PTR\n{\n  struct _dwg_object_object *parent;\n} Dwg_Object_OBJECT_PTR;\n\n/**\n Entity LIGHT (varies)\n UNSTABLE, almost complete\n */\ntypedef struct _dwg_entity_LIGHT\n{\n  struct _dwg_object_entity *parent;\n\n  BITCODE_BL class_version; /*!< DXF 90 */\n  BITCODE_T name;       /*!< DXF 1 */\n  BITCODE_BS type;      /*!< DXF 70, distant = 1; point = 2; spot = 3 */\n  BITCODE_B status;     /*!< DXF 290, on or off */\n  BITCODE_CMC color;    /*!< DXF 63 + 421 */\n  BITCODE_B plot_glyph; /*!< DXF 291 */\n  BITCODE_BD intensity; /*!< DXF 40 */\n  BITCODE_3BD position; /*!< DXF 10 */\n  BITCODE_3BD target;   /*!< DXF 11 */\n  BITCODE_BS attenuation_type;        /*!< DXF 72 0 = None, 1 = Inverse Linear,\n                                        2 = Inverse Square */\n  BITCODE_B use_attenuation_limits;   /*!< DXF 292 */\n  BITCODE_BD attenuation_start_limit; /*!< DXF 41 */\n  BITCODE_BD attenuation_end_limit;   /*!< DXF 42 */\n  BITCODE_BD hotspot_angle; /*!< DXF 50 */\n  BITCODE_BD falloff_angle; /*!< DXF 51, always stored, used with type=spot only */\n  BITCODE_B cast_shadows;   /*!< DXF 293 */\n  BITCODE_BS shadow_type;   /*!< DXF 73, 0 or 1 */\n  BITCODE_BS shadow_map_size;     /*!< DXF 91 */\n  BITCODE_RC shadow_map_softness; /*!< DXF 280 */\n  BITCODE_H lights_layer;\n#ifdef DEBUG_CLASSES\n  /* yet unknown: */\n  BITCODE_BS lamp_color_type;     /*!< /0: in kelvin, 1: as preset */\n  BITCODE_BD lamp_color_temp;     /*!< Temperature in Kelvin */\n  BITCODE_BS lamp_color_preset;   /*!< 0: D65White, 1: Fluorescent, ... */\n  BITCODE_BL lamp_color_rgb;      /*!< if lamp_color_preset is Custom */\n  BITCODE_TV web_file;            /*!< IES file */\n  BITCODE_3BD web_rotation;       /*!< rotation offset in XYZ Euler angles */\n  BITCODE_B has_target_grip;      /*!< if the light displays a target grip for orienting\n                                       the light */\n  BITCODE_BS glyph_display_type;  /*!< 0:auto, 1:on, 2:off */\n  BITCODE_BS physical_intensity_method; /*!< ? */\n  BITCODE_BS drawable_type;       /*!< ? */\n#endif\n} Dwg_Entity_LIGHT;\n\n/**\n Entity CAMERA (varies) UNKNOWN FIELDS\n not DWG persistent. yet unsorted, and unused.\n */\ntypedef struct _dwg_entity_CAMERA\n{\n  struct _dwg_object_entity *parent;\n  BITCODE_H view;\n} Dwg_Entity_CAMERA;\n\n/**\n Entity GEOPOSITIONMARKER (varies) UNKNOWN FIELDS\n yet unsorted, and unused.\n*/\ntypedef struct _dwg_entity_GEOPOSITIONMARKER\n{\n  struct _dwg_object_entity *parent;\n  BITCODE_BS type;        /*!< point, lat_lon, mylocation */\n  BITCODE_3BD position;   /*!< DXF 10 */\n  BITCODE_BE extrusion;   /*!< DXF 210 */\n  BITCODE_BD radius;      /*!< DXF 40 */\n  BITCODE_BD landing_gap; /*!< DXF 41 */\n  BITCODE_T text;         /*!< DXF 1 */\n  BITCODE_BS text_alignment; /*!< DXF 70  0 left, 1 center, 2 right */\n  BITCODE_B mtext_visible;/*!< DXF ? */\n  BITCODE_B enable_frame_text; /*!< DXF ? */\n  BITCODE_T notes;        /*!< DXF 3 */\n  BITCODE_H mtext_handle; /*!< DXF ? */\n  BITCODE_H text_style;   /*!< DXF 7 */\n} Dwg_Entity_GEOPOSITIONMARKER;\n\n/**\n Object GEOMAPIMAGE (varies), LiveMap image overlay.\n yet unsorted, and unused.\n*/\ntypedef struct _dwg_object_GEOMAPIMAGE\n{\n  struct _dwg_object_object *parent;\n  BITCODE_BL class_version; // 90\n  BITCODE_3BD pt0; // 10\n  BITCODE_2RD size; // 13\n  BITCODE_BS display_props; // 70\n  BITCODE_B clipping; // 280 i.e. clipping_enabled\n  BITCODE_RC brightness; // 281\n  BITCODE_RC contrast; // 282\n  BITCODE_RC fade; // 283\n  BITCODE_BD rotation;\n  //?\n  //BITCODE_3BD origin;\n  BITCODE_BD image_width;\n  BITCODE_BD image_height;\n  BITCODE_T name;\n  BITCODE_BD image_file;\n  BITCODE_BD image_visibility;\n  BITCODE_BS transparency;\n  BITCODE_BD height;\n  BITCODE_BD width;\n  BITCODE_B show_rotation;\n  BITCODE_BD scale_factor;\n  BITCODE_BS geoimage_brightness;\n  BITCODE_BS geoimage_contrast;\n  BITCODE_BS geoimage_fade;\n  BITCODE_BS geoimage_position;\n  BITCODE_BS geoimage_width;\n  BITCODE_BS geoimage_height;\n} Dwg_Object_GEOMAPIMAGE;\n\n/**\n Entity HELIX (varies) UNSTABLE\n subclass of SPLINE\n*/\ntypedef struct _dwg_entity_HELIX\n{\n  struct _dwg_object_entity *parent;\n\n  BITCODE_BS flag; /* computed */\n  BITCODE_BS scenario; /* 1 spline, 2 bezier */\n  BITCODE_BS degree;\n  BITCODE_BL splineflags1; /* 2013+: method fit points = 1, CV frame show = 2, closed = 4 */\n  BITCODE_BL knotparam;    /* 2013+: Chord = 0, Square root = 1, Uniform = 2, Custom = 15 */\n  BITCODE_BD fit_tol;\n  BITCODE_3BD beg_tan_vec;\n  BITCODE_3BD end_tan_vec;\n  BITCODE_B rational;\n  BITCODE_B closed_b;\n  BITCODE_B periodic;\n  BITCODE_B weighted; /* bit 4 of 70 */\n  BITCODE_BD knot_tol;\n  BITCODE_BD ctrl_tol;\n  BITCODE_BS num_fit_pts;\n  Dwg_SPLINE_point* fit_pts;\n  BITCODE_BL num_knots;\n  BITCODE_BD* knots;\n  BITCODE_BL num_ctrl_pts;\n  Dwg_SPLINE_control_point* ctrl_pts;\n\n  BITCODE_BS major_version; //90\n  BITCODE_BS maint_version; //91\n  BITCODE_3BD axis_base_pt; //10\n  BITCODE_3BD start_pt;     //11\n  BITCODE_3BD axis_vector;  //12\n  BITCODE_BD radius;        //40\n  BITCODE_BD num_turns;     //41\n  BITCODE_BD turn_height;   //42\n  BITCODE_B handedness;     //290\n  BITCODE_BS constraint_type; //280\n\n} Dwg_Entity_HELIX;\n\n/**\n Entity EXTRUDEDSURFACE (varies)\n in DXF encrypted.\n*/\ntypedef struct _dwg_entity_EXTRUDEDSURFACE\n{\n  struct _dwg_object_entity *parent;\n  _3DSOLID_FIELDS;\n  //? sweep_profile, taper_angle\n  BITCODE_BS modeler_format_version; /*!< DXF 70 */\n  BITCODE_BL size_bindata; // 90\n  BITCODE_TF bindata; // 310|1\n  BITCODE_BS u_isolines;         /*!< DXF 71 */\n  BITCODE_BS v_isolines;         /*!< DXF 72 */\n  BITCODE_BL class_version; /*!< DXF 90 */\n  //sweep_options?\n  BITCODE_BD height;\n  BITCODE_3BD sweep_vector; /*!< DXF 10 */\n  BITCODE_BD* sweep_transmatrix; /*!< DXF 40: 16x BD */\n  BITCODE_BD draft_angle;   /*!< DXF 42 */\n  BITCODE_BD draft_start_distance; /*!< DXF 43 */\n  BITCODE_BD draft_end_distance;   /*!< DXF 44 */\n  BITCODE_BD twist_angle;   /*!< DXF 45 */\n  BITCODE_BD scale_factor;  /*!< DXF 48 */\n  BITCODE_BD align_angle;   /*!< DXF 49 */\n  BITCODE_BD* sweep_entity_transmatrix; /*!< DXF 46: 16x BD */\n  BITCODE_BD* path_entity_transmatrix;  /*!< DXF 47: 16x BD */\n  BITCODE_B solid;          /*!< DXF 290 */\n  BITCODE_BS sweep_alignment_flags; /*!< DXF 290.\n                                      0=No alignment, 1=Align sweep entity to path,\n                                      2=Translate sweep entity to path,\n                                      3=Translate path to sweep entity */\n  BITCODE_B align_start;                        /*!< DXF 292 */\n  BITCODE_B bank;                               /*!< DXF 293 */\n  BITCODE_B base_point_set;                     /*!< DXF 294 */\n  BITCODE_B sweep_entity_transform_computed;    /*!< DXF 295 */\n  BITCODE_B path_entity_transform_computed;     /*!< DXF 296 */\n  BITCODE_3BD reference_vector_for_controlling_twist; /*!< DXF 11 */\n  BITCODE_H sweep_entity;\n  BITCODE_H path_entity;\n} Dwg_Entity_EXTRUDEDSURFACE;\n\n/**\n Entity LOFTEDSURFACE (varies)\n*/\ntypedef struct _dwg_entity_LOFTEDSURFACE\n{\n  struct _dwg_object_entity *parent;\n  _3DSOLID_FIELDS;\n  BITCODE_BS modeler_format_version; /*!< DXF 70 */\n  BITCODE_BS u_isolines;         /*!< DXF 71 */\n  BITCODE_BS v_isolines;         /*!< DXF 72 */\n  //BITCODE_BL class_version;      /*!< DXF 90 */\n  BITCODE_BD* loft_entity_transmatrix; /*!< DXF 40: 16x BD */\n  BITCODE_BL plane_normal_lofting_type; /*!< DXF 70 */\n  BITCODE_BD start_draft_angle;     /*!< DXF 41 */\n  BITCODE_BD end_draft_angle;       /*!< DXF 42 */\n  BITCODE_BD start_draft_magnitude; /*!< DXF 43 */\n  BITCODE_BD end_draft_magnitude;   /*!< DXF 44 */\n  BITCODE_B arc_length_parameterization; // 290\n  BITCODE_B no_twist; // 291\n  BITCODE_B align_direction; // 292\n  BITCODE_B simple_surfaces; // 293\n  BITCODE_B closed_surfaces; // 294\n  BITCODE_B solid; // 295\n  BITCODE_B ruled_surface; // 296\n  BITCODE_B virtual_guide; // 297\n\n  BITCODE_BS num_cross_sections;\n  BITCODE_BS num_guide_curves;\n  BITCODE_H *cross_sections;\n  BITCODE_H *guide_curves;\n  BITCODE_H path_curve;\n} Dwg_Entity_LOFTEDSURFACE;\n\n/**\n Entity PLANESURFACE (varies)\n*/\ntypedef struct _dwg_entity_PLANESURFACE\n{\n  struct _dwg_object_entity *parent;\n  _3DSOLID_FIELDS;\n  BITCODE_BS modeler_format_version; /*!< DXF 70 */\n  BITCODE_BS u_isolines;         /*!< DXF 71 */\n  BITCODE_BS v_isolines;         /*!< DXF 72 */\n  BITCODE_BL class_version;      /*!< DXF 90 */\n\n} Dwg_Entity_PLANESURFACE;\n\n/**\n Entity REVOLVEDSURFACE (varies)\n*/\ntypedef struct _dwg_entity_REVOLVEDSURFACE\n{\n  struct _dwg_object_entity *parent;\n  _3DSOLID_FIELDS;\n  BITCODE_BS modeler_format_version; /*!< DXF 70 */\n  BITCODE_BS u_isolines;         /*!< DXF 71 */\n  BITCODE_BS v_isolines;         /*!< DXF 72 */\n  BITCODE_BL class_version; /*!< DXF 90 */\n\n  BITCODE_BL id; // 90\n  BITCODE_3BD axis_point; // 10\n  BITCODE_3BD axis_vector; // 11\n  BITCODE_BD revolve_angle; // 40\n  BITCODE_BD start_angle; // 41\n  BITCODE_BD* revolved_entity_transmatrix; // 42\n  BITCODE_BD draft_angle; // 43\n  BITCODE_BD draft_start_distance; // 44\n  BITCODE_BD draft_end_distance; // 45\n  BITCODE_BD twist_angle; // 46\n  BITCODE_B solid; // 290\n  BITCODE_B close_to_axis; // 291\n\n} Dwg_Entity_REVOLVEDSURFACE;\n\n/**\n Entity SWEPTSURFACE (varies)\n*/\ntypedef struct _dwg_entity_SWEPTSURFACE\n{\n  struct _dwg_object_entity *parent;\n  _3DSOLID_FIELDS;\n  BITCODE_BS modeler_format_version; /*!< DXF 70 */\n  BITCODE_BS u_isolines;         /*!< DXF 71 */\n  BITCODE_BS v_isolines;         /*!< DXF 72 */\n  BITCODE_BL class_version; /*!< DXF 90 */\n\n  BITCODE_BL sweep_entity_id; // 90\n  BITCODE_BL size_sweepdata; // 90\n  BITCODE_TF sweepdata; // 310\n  BITCODE_BL path_entity_id; // 90\n  BITCODE_BL size_pathdata; // 90\n  BITCODE_TF pathdata; // 310\n  BITCODE_BD* sweep_entity_transmatrix; // 40\n  BITCODE_BD* path_entity_transmatrix; // 41\n  BITCODE_BD draft_angle; // 42\n  BITCODE_BD draft_start_distance; // 43\n  BITCODE_BD draft_end_distance; // 44\n  BITCODE_BD twist_angle; // 45\n  BITCODE_BD* sweep_entity_transmatrix1; // 46\n  BITCODE_BD* path_entity_transmatrix1; // 47\n  BITCODE_BD scale_factor; // 48\n  BITCODE_BD align_angle; // 49\n  BITCODE_B solid; // 290\n  BITCODE_RC sweep_alignment; // 70\n  BITCODE_B align_start; // 292\n  BITCODE_B bank; // 293\n  BITCODE_B base_point_set; // 294\n  BITCODE_B sweep_entity_transform_computed; // 295\n  BITCODE_B path_entity_transform_computed; // 296\n  BITCODE_3BD reference_vector_for_controlling_twist; // 11\n\n} Dwg_Entity_SWEPTSURFACE;\n\n/**\n Entity MESH (varies)\n Types: Sphere|Cylinder|Cone|Torus|Box|Wedge|Pyramid\n --enable-debug only, unknown fields\n*/\ntypedef struct _dwg_MESH_edge\n{\n  struct _dwg_entity_MESH *parent;\n  BITCODE_BL from;\n  BITCODE_BL to;\n} Dwg_MESH_edge;\n\ntypedef struct _dwg_entity_MESH\n{\n  struct _dwg_object_entity *parent;\n  //_3DSOLID_FIELDS;\n  BITCODE_BL class_version;\t/*!< DXF 90 */\n\n  BITCODE_RC dlevel; \t\t/*!< DXF 71 (2) */\n  BITCODE_RC is_watertight; \t/*!< DXF 72 (0) */\n  BITCODE_BL num_subdiv_vertex; /*!< DXF 91 ?? */\n  BITCODE_3BD* subdiv_vertex; \t/*!< DXF 10 ?? */\n  BITCODE_BL num_vertex;  \t/*!< DXF 92 */\n  BITCODE_3BD* vertex; \t\t/*!< DXF 10 */\n  BITCODE_BL num_faces;  \t/*!< DXF 93 */\n  BITCODE_BL* faces;  \t        /*!< DXF 90 */\n  BITCODE_BL num_edges;  \t/*!< DXF 94 */\n  Dwg_MESH_edge* edges;   \t/*!< DXF 90 */\n  BITCODE_BL num_crease;  \t/*!< DXF 95 */\n  BITCODE_BD* crease;   \t/*!< DXF 140 */\n\n} Dwg_Entity_MESH;\n\n/**\n Object SUN (varies) UNKNOWN FIELDS\n wrongly documented by ACAD DXF as entity\n --enable-debug only, unknown fields\n */\ntypedef struct _dwg_object_SUN\n{\n  struct _dwg_object_object *parent;\n\n  BITCODE_BL class_version; //90\n  BITCODE_B is_on;   // 290\n  BITCODE_BS unknown; //421\n  BITCODE_CMC color; // 60\n  BITCODE_BD intensity; // 40\n  //BITCODE_3BD direction; //calculated?\n  //BITCODE_BD altitude;   //calculated?\n  //BITCODE_BD azimuth;    //calculated?\n  BITCODE_BL julian_day; //91\n  BITCODE_BL time;       //92\n  BITCODE_B  is_dst;     //292\n  BITCODE_B has_shadow;  //291\n  BITCODE_BS shadow_type;     //70\n  BITCODE_BS shadow_mapsize;  //71\n  BITCODE_BS shadow_softness; //280\n\n  // 11.3 bytes missing, from UNKNOWN_OBJ\n  BITCODE_H skyparams;\n} Dwg_Object_SUN;\n\ntypedef struct _dwg_SUNSTUDY_Dates\n{\n  BITCODE_BL julian_day;\n  BITCODE_BL time; //seconds past midnight\n} Dwg_SUNSTUDY_Dates;\n\n/**\n Object SUNSTUDY (varies) UNKNOWN FIELDS\n --enable-debug only\n */\ntypedef struct _dwg_object_SUNSTUDY\n{\n  struct _dwg_object_object *parent;\n\n  BITCODE_BL class_version;    //90\n  BITCODE_T setup_name;        //1\n  BITCODE_T desc;              //2\n  BITCODE_BL output_type;      //70\n  BITCODE_T sheet_set_name;    //3\n  BITCODE_B use_subset;        //290\n  BITCODE_T sheet_subset_name; //3\n  BITCODE_B select_dates_from_calendar; //291\n  BITCODE_BL num_dates;   //91\n  Dwg_SUNSTUDY_Dates* dates; //90+90[]\n  BITCODE_B select_range_of_dates; //292\n  BITCODE_BL start_time;  //93\n  BITCODE_BL end_time;    //94\n  BITCODE_BL interval;    //95\n  BITCODE_BL num_hours;   //73\n  BITCODE_B* hours;       //290\n  BITCODE_BL shade_plot_type;  //74\n  BITCODE_BL numvports;        //75\n  BITCODE_BL numrows;        //76\n  BITCODE_BL numcols;        //77\n  BITCODE_BD spacing;        //40\n  BITCODE_B  lock_viewports; //293\n  BITCODE_B  label_viewports; //294\n\n  BITCODE_H  page_setup_wizard; //5. 340\n  BITCODE_H  view;         //341\n  BITCODE_H  visualstyle;  //342\n  BITCODE_H  text_style;   //343\n} Dwg_Object_SUNSTUDY;\n\n/**\n Object DATATABLE (varies) UNKNOWN FIELDS\n --enable-debug only\n */\ntypedef struct _dwg_object_DATATABLE\n{\n  struct _dwg_object_object *parent;\n  //...\n} Dwg_Object_DATATABLE;\n\n/**\n Object DIMASSOC (varies) DEBUGGING\n --enable-debug only\n */\ntypedef struct _dwg_DIMASSOC_ref\n{\n  struct _dwg_object_DIMASSOC *parent;\n  BITCODE_BS rotated_type;    /*!< DXF 71 */\n  BITCODE_RC osnap_type;      /*!< DXF 72 */\n  BITCODE_TV classname;       /*!< DXF 1 */\n  BITCODE_BS main_subent_type; /*!< DXF 73 */\n  BITCODE_BS intsect_subent_type; /*!< DXF 74 */\n  BITCODE_BL main_gsmarker;   /*!< DXF 91 */\n  BITCODE_BD osnap_dist;      /*!< DXF 40 */\n  BITCODE_3BD osnap_pt;       /*!< DXF 10 */\n  BITCODE_B has_lastpt_ref;   /*!< DXF 75 */\n  BITCODE_H mainobj;          /*!< DXF 331 the geometry object */\n  BITCODE_H intsectobj;       /*!< DXF 332 the intersection object */\n} Dwg_DIMASSOC_Ref;\n\ntypedef struct _dwg_object_DIMASSOC\n{\n  struct _dwg_object_object *parent;\n  BITCODE_BL associativity;   /*!< DXF 90 */\n  BITCODE_RC trans_space_flag;/*!< DXF 70 */\n  Dwg_DIMASSOC_Ref *ref;       /* 1-4x, with possible holes,\n                                  depend. on associativity bitmask */\n  BITCODE_BL intsect_gsmarker; /*!< DXF 92 */\n  //BITCODE_H dimensionobj;     /*!< DXF 330 */\n  //BITCODE_H xrefobj;          /*!< DXF 301 */\n  //BITCODE_H intsectxrefobj;   /*!< DXF 302 */\n} Dwg_Object_DIMASSOC;\n\ntypedef struct _dwg_ACTIONBODY\n{\n  struct _dwg_object_ASSOCNETWORK *parent;\n  BITCODE_T  evaluatorid;\n  BITCODE_T  expression;\n  BITCODE_BL value; //resbuf\n} Dwg_ACTIONBODY;\n\n#define ASSOCACTION_fields \\\n  BITCODE_BL solution_status; /* 90 */ \\\n  BITCODE_BL geometry_status; /* 90 */ \\\n  BITCODE_H readdep;          /* 330 */ \\\n  BITCODE_H writedep;         /* 360 */ \\\n  BITCODE_BL constraint_status; /* 90 */ \\\n  BITCODE_BL dof;               /* 90 */ \\\n  BITCODE_B  is_body_a_proxy    /* 90 */\n\ntypedef struct _dwg_object_ASSOCACTION\n{\n  struct _dwg_object_object *parent;\n  ASSOCACTION_fields;\n\n  BITCODE_BL num_deps;    /* 90 */\n  //BITCODE_B is_actionevaluation_in_progress; // 90\n  Dwg_ACTIONBODY body;\n  BITCODE_BL status;\n  BITCODE_H  actionbody;\n  BITCODE_H  callback;\n  BITCODE_H  owningnetwork;\n} Dwg_Object_ASSOCACTION;\n\ntypedef struct _dwg_object_ASSOCDEPENDENCY\n{\n  struct _dwg_object_object *parent;\n  BITCODE_BL class_version; // 90\n  BITCODE_BL status; // 90\n  BITCODE_B isread_dep; // 290\n  BITCODE_B iswrite_dep; // 290\n  BITCODE_B isobjectstate_dep; // 290\n  BITCODE_B unknown_b4; // 290\n  BITCODE_BL order; // 90 -2147483648\n  BITCODE_B unknown_b5; // 290\n  BITCODE_BL depbodyid; // 90\n\n  BITCODE_H  owner; // 330\n  BITCODE_H  readdep; // 330\n  BITCODE_H  writedep; // 360\n  BITCODE_H  node; // 330\n} Dwg_Object_ASSOCDEPENDENCY;\n\ntypedef struct _dwg_object_ASSOCALIGNEDDIMACTIONBODY\n{\n  struct _dwg_object_object *parent;\n  BITCODE_BL aab_status; // 90\n  BITCODE_BL pab_status; // 90:0\n  BITCODE_BL pab_l2; // 90:0\n  BITCODE_BL pab_l3; // 90:1\n  BITCODE_H  writedep; // 360\n  BITCODE_BL pab_l4; // 90:0\n  BITCODE_BL pab_l5; // 90:0\n  BITCODE_BL pab_l6; // 90:0\n  BITCODE_H  readdep; // 330\n  BITCODE_BL dcm_status; // 90:0\n  BITCODE_H  d_node; // 330\n  BITCODE_H  r_node; // 330\n} Dwg_Object_ASSOCALIGNEDDIMACTIONBODY;\n\n/**\n Object ASSOCNETWORK (varies) UNKNOWN FIELDS\n subclass of AcDbAssocAction\n Object1 --ReadDep--> Action1 --WriteDep1--> Object2 --ReadDep--> Action2 ...\n */\ntypedef struct _dwg_object_ASSOCNETWORK\n{\n  struct _dwg_object_object *parent;\n  ASSOCACTION_fields;\n  //BITCODE_H assocaction;\n  //or inlined:\n  //90:2 90:0 330:0 360:0 7x90:0\n  //BITCODE_BL num_deps; // 90\n\n  BITCODE_BL unknown_assoc; // 90\n  //90, 90, [90, 330], 90\n  BITCODE_BL unknown_n1; // 90 0\n  BITCODE_BL unknown_n2; // 90 1\n  BITCODE_BL num_actions;// 90 1\n  BITCODE_H* actions;    // 360\n  //BITCODE_BL unknown_n3; // 90 0\n} Dwg_Object_ASSOCNETWORK;\n\n/**\n Object ASSOCOSNAPPOINTREFACTIONPARAM (varies) UNKNOWN FIELDS\n Action parameter that owns other AcDbAssocActionParameters,\n allowing the representation of hierarchical structures of action parameters.\n */\ntypedef struct _dwg_object_ASSOCOSNAPPOINTREFACTIONPARAM\n{\n  struct _dwg_object_object *parent;\n  // AcDbAssocActionParam\n  BITCODE_RC unknown;  // 01010101\n  BITCODE_B unknown1;  //\n  BITCODE_BS status;   // 90: 0 uptodate, 1 changed_directly, 2 changed_transitive,\n                       // 3 ChangedNoDifference, 4 FailedToEvaluate, 5 Erased, 6 Suppressed\n                       // 7 Unresolved\n  BITCODE_T  name;     // 1 \"\"\n  BITCODE_RS flags;    // 90 0\n  // AcDbAssocCompoundActionParam\n  BITCODE_BD unknown3; // 40 -1.0\n  BITCODE_BS num_params; // 90 1\n  BITCODE_H actionparam;  // 330\n  BITCODE_H writedep; // 360\n} Dwg_Object_ASSOCOSNAPPOINTREFACTIONPARAM;\n\ntypedef struct _dwg_object_ASSOC2DCONSTRAINTGROUP\n{\n  struct _dwg_object_object *parent;\n  ASSOCACTION_fields;\n\n  BITCODE_BL l5; //90 1\n  BITCODE_B  b1; //70 0\n  BITCODE_3BD workplane[3]; //3x10 workplane\n  // 360\n  BITCODE_BL l6; //90 2\n  // 360 360\n  BITCODE_BL l7; //90 9\n  BITCODE_BL l8; //90 9\n\n  BITCODE_BL cl1; //90 1\n  BITCODE_RC cs1; //70 1\n  BITCODE_BL cl2; //90 1\n  BITCODE_BL cl3; //90 3\n  BITCODE_BL cl4; //90 0\n  BITCODE_3BD c1; //10 @134\n  BITCODE_3BD c2; //10\n  BITCODE_3BD c3; //10\n  BITCODE_BD w1; //40\n  BITCODE_BD w2; //40\n  BITCODE_BD w3; //40\n} Dwg_Object_ASSOC2DCONSTRAINTGROUP;\n\n/* or maybe the nodes are laid out like this */\ntypedef struct _dwg_EVAL_Node\n{\n  struct _dwg_object_EVALUATION_GRAPH *parent;\n  BITCODE_BL  edge[4];   // 4x 92, def: 4x -1\n  //BITCODE_H   evalexpr;   // 360\n} Dwg_EVAL_Node;\n\ntypedef struct _dwg_object_EVALUATION_GRAPH\n{\n  struct _dwg_object_object *parent;\n  BITCODE_BL has_graph;   // 96\n  BITCODE_BL unknown1;    // 97\n  BITCODE_BL unknown2;\n  BITCODE_BL nodeid;      // 91\n  BITCODE_BL edge_flags;  // 93\n  BITCODE_BL num_evalexpr;// 95\n  BITCODE_BL node_edge1;  // 92\n  BITCODE_BL node_edge2;  // 92\n  BITCODE_BL node_edge3;  // 92\n  BITCODE_BL node_edge4;  // 92\n  BITCODE_H  *evalexpr;    //360\n} Dwg_Object_EVALUATION_GRAPH;\n\n// UNSTABLE\ntypedef struct _dwg_object_DYNAMICBLOCKPURGEPREVENTER\n{\n  struct _dwg_object_object *parent;\n  BITCODE_BS flag;         /*!< DXF 70 0 */\n  BITCODE_RS unknown_rs1;\n} Dwg_Object_DYNAMICBLOCKPURGEPREVENTER;\n\ntypedef struct _dwg_object_PERSSUBENTMANAGER\n{\n  struct _dwg_object_object *parent;\n  BITCODE_BL class_version; /*!< DXF 90 2 */\n  BITCODE_BL unknown_bl1;   /*!< DXF 90 0 */\n  BITCODE_BL unknown_bl2;   /*!< DXF 90 2 */\n  BITCODE_BL unknown_bl3;   /*!< DXF 90 3 */\n  BITCODE_BL unknown_bl4;   /*!< DXF 90 0 */\n  BITCODE_BL unknown_bl5;   /*!< DXF 90 1 */\n  BITCODE_BL unknown_bl6;   /*!< DXF 90 1 */\n} Dwg_Object_PERSSUBENTMANAGER;\n\ntypedef struct _dwg_object_ASSOCPERSSUBENTMANAGER\n{\n  struct _dwg_object_object *parent;\n  BITCODE_BL class_version; /*!< DXF 90 1 */\n  BITCODE_BL unknown_bl1;   /*!< DXF 90 3 */\n  BITCODE_BL unknown_bl2;   /*!< DXF 90 0 */\n  BITCODE_BL unknown_bl3;   /*!< DXF 90 2 */\n  BITCODE_BL unknown_bl4;   /*!< DXF 90 3 */\n  BITCODE_BL unknown_bl5;   /*!< DXF 90 1 */\n  BITCODE_BL unknown_bl6;   /*!< DXF 90 5 */\n  BITCODE_BL unknown_bl6a;  /*!< DXF 90 0 */\n  BITCODE_BL unknown_bl7a;  /*!< DXF 90 3 */\n  BITCODE_BL unknown_bl7;   /*!< DXF 90 2 */\n  BITCODE_BL unknown_bl8;   /*!< DXF 90 2 */\n  BITCODE_BL unknown_bl9;   /*!< DXF 90 2 */\n  BITCODE_BL unknown_bl10;  /*!< DXF 90 21 */\n  BITCODE_BL unknown_bl11;  /*!< DXF 90 0 */\n  BITCODE_BL unknown_bl12;  /*!< DXF 90 0 */\n  BITCODE_BL unknown_bl13;  /*!< DXF 90 0 */\n  BITCODE_BL unknown_bl14;  /*!< DXF 90 0 */\n  BITCODE_BL unknown_bl15;  /*!< DXF 90 1 */\n  BITCODE_BL unknown_bl16;  /*!< DXF 90 3 */\n  BITCODE_BL unknown_bl17;  /*!< DXF 90 1 */\n  BITCODE_BL unknown_bl18;  /*!< DXF 90 1000000000 */\n  BITCODE_BL unknown_bl19;  /*!< DXF 90 1001 */\n  BITCODE_BL unknown_bl20;  /*!< DXF 90 1 */\n  BITCODE_BL unknown_bl21;  /*!< DXF 90 1000000000 */\n  BITCODE_BL unknown_bl22;  /*!< DXF 90 51001 */\n  BITCODE_BL unknown_bl23;  /*!< DXF 90 1 */\n  BITCODE_BL unknown_bl24;  /*!< DXF 90 1000000000 */\n  BITCODE_BL unknown_bl25;  /*!< DXF 90 351001 */\n  BITCODE_BL unknown_bl26;  /*!< DXF 90 0 */\n  BITCODE_BL unknown_bl27;  /*!< DXF 90 0 */\n  BITCODE_BL unknown_bl28;  /*!< DXF 90 0 */\n  BITCODE_BL unknown_bl29;  /*!< DXF 90 900 */\n  BITCODE_BL unknown_bl30;  /*!< DXF 90 0 */\n  BITCODE_BL unknown_bl31;  /*!< DXF 90 900 */\n  BITCODE_BL unknown_bl32;  /*!< DXF 90 0 */\n  BITCODE_BL unknown_bl33;  /*!< DXF 90 2 */\n  BITCODE_BL unknown_bl34;  /*!< DXF 90 2 */\n  BITCODE_BL unknown_bl35;  /*!< DXF 90 3 0100000011 */\n  BITCODE_BL unknown_bl36;  /*!< DXF 90 0 */\n  BITCODE_B  unknown_b37;   /*!< DXF 290 0 */\n} Dwg_Object_ASSOCPERSSUBENTMANAGER;\n\ntypedef struct _dwg_object_ASSOCPLANESURFACEACTIONBODY\n{\n  struct _dwg_object_object *parent;\n  // AcDbAssocActionBody\n  BITCODE_BL aab_status; // 90\n  // AcDbAssocParamBasedActionBody\n  BITCODE_BL pab_status; // 90:0\n  BITCODE_BL pab_l2; // 90:0\n  BITCODE_BL pab_l3; // 90:1\n  BITCODE_H  writedep; // 360\n  BITCODE_BL pab_l4; // 90:0\n  BITCODE_BL pab_l5; // 90:0\n  BITCODE_H  readdep; // 330\n  // AcDbAssocSurfaceActionBody\n  BITCODE_BL sab_status;/*!< DXF 90  */\n  BITCODE_B sab_b1;     /*!< DXF 290  */\n  BITCODE_BL sab_l2;    /*!< DXF 90  */\n  BITCODE_B sab_b2;     /*!< DXF 290  */\n  BITCODE_BS sab_s1;    /*!< DXF 70  */\n  // AcDbAssocPathBasedSurfaceActionBody\n  BITCODE_BL pbsab_status;      /*!< DXF 90  */\n  // AcDbAssocPlaneSurfaceActionBody\n  BITCODE_BL psab_status;       /*!< DXF 90  */\n\n} Dwg_Object_ASSOCPLANESURFACEACTIONBODY;\n\ntypedef struct _dwg_object_ACSH_SWEEP_CLASS\n{\n  struct _dwg_object_object *parent;\n  // AcDbEvalExpr\n  BITCODE_BL class_version; // 90\n  BITCODE_BL ee_bl98; //98\n  BITCODE_BL ee_bl99; //99\n  // AcDbShHistoryNode\n  BITCODE_BL shhn_bl98; //98\n  BITCODE_BL shhn_bl99; //99\n  BITCODE_BD* shhn_pts; //last 16x nums 40-55\n  BITCODE_CMC color; /*!< DXF 62 */\n  BITCODE_B  shhn_b92; /*!< DXF 92 */\n  BITCODE_BL shhn_bl347; /*!< DXF 347 */\n\n  // AcDbShPrimitive\n  // AcDbShSweepBase\n  BITCODE_BL shsw_bl90;       /*!< DXF 90 */\n  BITCODE_BL shsw_bl91;       /*!< DXF 91 */\n  BITCODE_3BD basept;         /*!< DXF 10 */\n  BITCODE_BL shsw_bl92;       /*!< DXF 92 */\n  BITCODE_BL shsw_size_text;  /*!< DXF 90 */\n  BITCODE_TF shsw_text;       /*!< DXF 310 */\n  BITCODE_BL shsw_bl93;       /*!< DXF 93 */\n  BITCODE_BL shsw_size_text2; /*!< DXF 90 */\n  BITCODE_TF shsw_text2;      /*!< DXF 310 */\n  BITCODE_BD draft_angle;       /*!< DXF 42 0.0 */\n  BITCODE_BD start_draft_dist;  /*!< DXF 43 0.0 */\n  BITCODE_BD end_draft_dist;    /*!< DXF 44 0.0 */\n  BITCODE_BD scale_factor;      /*!< DXF 45 1.0 */\n  BITCODE_BD twist_angle;       /*!< DXF 48 0.0 */\n  BITCODE_BD align_angle;       /*!< DXF 49 0.0 */\n  BITCODE_BD* sweepentity_transform; /*!< DXF 46 16x */\n  BITCODE_BD* pathentity_transform;  /*!< DXF 47 16x */\n  BITCODE_RC align_option;      /*!< DXF 70 2 */\n  BITCODE_RC miter_option;      /*!< DXF 71 2 */\n  BITCODE_B has_align_start;    /*!< DXF 290 1 */\n  BITCODE_B bank;       /*!< DXF 292 1 */\n  BITCODE_B check_intersections; /*!< DXF 293 0 */\n  BITCODE_B shsw_b294;  /*!< DXF 294  1 */\n  BITCODE_B shsw_b295;  /*!< DXF 295  1 */\n  BITCODE_B shsw_b296;  /*!< DXF 296  1 */\n  BITCODE_3BD pt2;      /*!< DXF 11 0,0,0 */\n\n  // AcDbShSweep\n\n} Dwg_Object_ACSH_SWEEP_CLASS;\n\ntypedef struct _dwg_object_NAVISWORKSMODELDEF\n{\n  struct _dwg_object_object *parent;\n\n  // AcDbNavisworksModelDef\n  BITCODE_T path;       /*!< DXF 1 */\n  BITCODE_B status;     /*!< DXF 290 */\n  BITCODE_3BD min_extent; /*!< DXF 10 */\n  BITCODE_3BD max_extent; /*!< DXF 11 */\n  BITCODE_B host_drawing_visibility; /*!< DXF 290 */\n\n} Dwg_Object_NAVISWORKSMODELDEF;\n\n/**\n Class RENDERENVIRONMENT (varies)\n */\ntypedef struct _dwg_object_RENDERENVIRONMENT\n{\n  struct _dwg_object_object *parent;\n\n  BITCODE_BL class_version;     /*!< DXF 90, default: 1 */\n  BITCODE_B fog_enabled;        /*!< DXF 290 */\n  BITCODE_B fog_background_enabled;  /*!< DXF 290 */\n  BITCODE_CMC fog_color;        /*!< DXF 280 */\n  BITCODE_BD fog_density_near;  /*!< DXF 40 */\n  BITCODE_BD fog_density_far;   /*!< DXF 40 */\n  BITCODE_BD fog_distance_near;     /*!< DXF 40 */\n  BITCODE_BD fog_distance_far;      /*!< DXF 40 */\n  BITCODE_B environ_image_enabled;  /*!< DXF 290 */\n  BITCODE_T environ_image_filename; /*!< DXF 1 */\n} Dwg_Object_RENDERENVIRONMENT;\n\n/**\n Class RENDERENVIRONMENT (varies)\n */\ntypedef struct _dwg_object_RENDERGLOBAL\n{\n  struct _dwg_object_object *parent;\n\n  BITCODE_BL class_version;    /*!< DXF 90 */\n  BITCODE_BL procedure;        /*!< DXF 90 */\n  BITCODE_BL destination;      /*!< DXF 90 */\n  BITCODE_B save_enabled;      /*!< DXF 290 */\n  BITCODE_T save_filename;     /*!< DXF 1 */\n  BITCODE_BL image_width;      /*!< DXF 90 */\n  BITCODE_BL image_height;     /*!< DXF 90 */\n  BITCODE_B predef_presets_first; /*!< DXF 290 */\n  BITCODE_B highlevel_info;    /*!< DXF 290 */\n} Dwg_Object_RENDERGLOBAL;\n\n/**\n * Class AcDbAnnotScaleObjectContextData (varies)\n * for MTEXT, MLEADER, LEADER, BLKREF, ALDIM (AlignedDimension), ...\n * R2010+\n */\ntypedef struct _dwg_object_ANNOTSCALEOBJECTCONTEXTDATA\n{\n  struct _dwg_object_object *parent;\n\n  BITCODE_BS class_version; /*!< r2010+ =3 */\n  BITCODE_B has_file;\n  BITCODE_B defaultflag;\n  BITCODE_H scale; /* DXF 340 */\n  // 70\n  // 10\n  // 11\n  // 40\n  // 41\n  // 42\n  // 43\n  // 71\n  // 72\n  // 44\n  // 45\n  // 73\n  // 74\n  // 46\n} Dwg_Object_ANNOTSCALEOBJECTCONTEXTDATA;\n\n/**\n -----------------------------------\n */\n\n/**\n Unknown Class entity, a blob\n */\ntypedef struct _dwg_entity_UNKNOWN_ENT\n{\n  struct _dwg_object_entity *parent;\n} Dwg_Entity_UNKNOWN_ENT;\n\n/**\n Unknown Class object, a blob\n */\ntypedef struct _dwg_object_UNKNOWN_OBJ\n{\n  struct _dwg_object_object *parent;\n} Dwg_Object_UNKNOWN_OBJ;\n\n/* OBJECTS - END ************************************************************/\n\n/**\n Extended entity data: dxf group - value pairs, similar to xdata\n */\n#pragma pack(1)\ntypedef struct _dwg_entity_eed_data\n{\n  BITCODE_RC code;\n  union eed_data_t {\n    struct { /* 0 (1000) string */\n      BITCODE_RC length;\n      BITCODE_RS codepage;\n      char string[1];      /* inlined */\n    } eed_0;\n    struct { /* R2007+ 0 (1000) string */\n      BITCODE_RS length;\n      DWGCHAR string[1]; /* inlined */\n    } eed_0_r2007;\n    struct { /* 1 (1001) invalid */\n      char invalid[1]; // set the eed[0].handle to the used APPID instead\n    } eed_1;\n    struct { /* 2 (1002) { or } */\n      BITCODE_RC byte;\n    } eed_2;\n    struct { /* 3 (1003) layer */\n      BITCODE_RL layer;\n    } eed_3;\n    struct { /* 4 (1004) binary */\n      BITCODE_RC length;\n      char data[1];\n    } eed_4;\n    struct { /* 5 (1005) entity */\n      BITCODE_RLL entity;\n    } eed_5;\n    struct { /* 10-13 point */\n      BITCODE_3RD point;\n    } eed_10;\n    struct { /* 40-42 real */\n      BITCODE_RD real;\n    } eed_40;\n    struct { /* 70 short int */\n      BITCODE_RS rs;\n    } eed_70;\n    struct { /* 71 long int */\n      BITCODE_RL rl;\n    } eed_71;\n  } u;\n} Dwg_Eed_Data;\n#pragma pack()\n\n/**\n Extended entity data\n */\ntypedef struct _dwg_entity_eed\n{\n  BITCODE_BS size;\n  Dwg_Handle handle;\n  Dwg_Eed_Data *data;\n  char* raw; /* a copy of data */\n} Dwg_Eed;\n\n/**\n Common entity attributes\n */\ntypedef struct _dwg_object_entity\n{\n  BITCODE_BL objid; /*<! link to the parent */\n  union\n  {\n    Dwg_Entity_UNUSED *UNUSED;\n    Dwg_Entity_TEXT *TEXT;\n    Dwg_Entity_ATTRIB *ATTRIB;\n    Dwg_Entity_ATTDEF *ATTDEF;\n    Dwg_Entity_BLOCK *BLOCK;\n    Dwg_Entity_ENDBLK *ENDBLK;\n    Dwg_Entity_SEQEND *SEQEND;\n    Dwg_Entity_INSERT *INSERT;\n    Dwg_Entity_MINSERT *MINSERT;\n    Dwg_Entity_VERTEX_2D *VERTEX_2D;\n    Dwg_Entity_VERTEX_3D *VERTEX_3D;\n    Dwg_Entity_VERTEX_MESH *VERTEX_MESH;\n    Dwg_Entity_VERTEX_PFACE *VERTEX_PFACE;\n    Dwg_Entity_VERTEX_PFACE_FACE *VERTEX_PFACE_FACE;\n    Dwg_Entity_POLYLINE_2D *POLYLINE_2D;\n    Dwg_Entity_POLYLINE_3D *POLYLINE_3D;\n    Dwg_Entity_ARC *ARC;\n    Dwg_Entity_CIRCLE *CIRCLE;\n    Dwg_Entity_LINE *LINE;\n    Dwg_DIMENSION_common *DIMENSION_common;\n    Dwg_Entity_DIMENSION_ORDINATE *DIMENSION_ORDINATE;\n    Dwg_Entity_DIMENSION_LINEAR *DIMENSION_LINEAR;\n    Dwg_Entity_DIMENSION_ALIGNED *DIMENSION_ALIGNED;\n    Dwg_Entity_DIMENSION_ANG3PT *DIMENSION_ANG3PT;\n    Dwg_Entity_DIMENSION_ANG2LN *DIMENSION_ANG2LN;\n    Dwg_Entity_DIMENSION_RADIUS *DIMENSION_RADIUS;\n    Dwg_Entity_DIMENSION_DIAMETER *DIMENSION_DIAMETER;\n    Dwg_Entity_POINT *POINT;\n    Dwg_Entity__3DFACE *_3DFACE;\n    Dwg_Entity_POLYLINE_PFACE *POLYLINE_PFACE;\n    Dwg_Entity_POLYLINE_MESH *POLYLINE_MESH;\n    Dwg_Entity_SOLID *SOLID;\n    Dwg_Entity_TRACE *TRACE;\n    Dwg_Entity_SHAPE *SHAPE;\n    Dwg_Entity_VIEWPORT *VIEWPORT;\n    Dwg_Entity_ELLIPSE *ELLIPSE;\n    Dwg_Entity_SPLINE *SPLINE;\n    Dwg_Entity_3DSOLID *_3DSOLID;\n    Dwg_Entity_REGION *REGION;\n    Dwg_Entity_BODY *BODY;\n    Dwg_Entity_RAY *RAY;\n    Dwg_Entity_XLINE *XLINE;\n    Dwg_Entity_OLEFRAME *OLEFRAME;\n    Dwg_Entity_MTEXT *MTEXT;\n    Dwg_Entity_LEADER *LEADER;\n    Dwg_Entity_TOLERANCE *TOLERANCE;\n    Dwg_Entity_MLINE *MLINE;\n    Dwg_Entity_OLE2FRAME *OLE2FRAME;\n    Dwg_Entity_HATCH *HATCH;\n\n    Dwg_Entity_CAMERA *CAMERA;\n    Dwg_Entity_GEOPOSITIONMARKER *GEOPOSITIONMARKER;\n    Dwg_Entity_HELIX *HELIX;\n    Dwg_Entity_IMAGE *IMAGE;\n    Dwg_Entity_LIGHT *LIGHT;\n    Dwg_Entity_LWPOLYLINE *LWPOLYLINE;\n    Dwg_Entity_MULTILEADER *MULTILEADER;\n    Dwg_Entity_PROXY_ENTITY *PROXY_ENTITY;\n    Dwg_Entity_PROXY_LWPOLYLINE *PROXY_LWPOLYLINE;\n    Dwg_Entity_PLANESURFACE *PLANESURFACE;\n    Dwg_Entity_EXTRUDEDSURFACE *EXTRUDEDSURFACE;\n    Dwg_Entity_LOFTEDSURFACE *LOFTEDSURFACE;\n    Dwg_Entity_REVOLVEDSURFACE *REVOLVEDSURFACE;\n    Dwg_Entity_SWEPTSURFACE *SWEPTSURFACE;\n    Dwg_Entity_TABLE *TABLE;\n    Dwg_Entity_UNDERLAY *UNDERLAY;\n    Dwg_Entity_WIPEOUT *WIPEOUT;\n    Dwg_Entity_ARC_DIMENSION *ARC_DIMENSION;\n    Dwg_Entity_MESH *MESH;\n\n    Dwg_Entity_UNKNOWN_ENT *UNKNOWN_ENT;\n  } tio;\n\n  struct _dwg_struct *dwg;\n  BITCODE_BL num_eed;\n  Dwg_Eed *eed; /* see also Dwg_Resbuf* xdata */\n\n  /* Common Entity Data */\n  BITCODE_B   preview_exists;\n  BITCODE_BLL preview_size;     /*!< DXF 160 for bitmaps, DXF 92 for PROXY vector data.\n                                  e.g. INSERT, MULTILEADER */\n  char       *preview;          /*!< DXF 310 */\n  BITCODE_BB entmode;           /*!< has no owner handle:\n                                  0 has no ownerhandle, 1 is PSPACE, 2 is MSPACE\n                                  3 has ownerhandle. */\n  BITCODE_BL num_reactors;\n  BITCODE_B xdic_missing_flag;  /*!< r2004+ */\n  BITCODE_B isbylayerlt;        /*!< r13-r14 */\n  BITCODE_B nolinks;            /*!< r13-r2000 */\n  BITCODE_B has_ds_binary_data; /*!< r2013+ */\n  BITCODE_CMC color;\n  BITCODE_BD ltype_scale;\n  BITCODE_BB ltype_flags;       /*!< r2000+ */\n  BITCODE_BB plotstyle_flags;   /*!< r2000+ */\n  BITCODE_BB material_flags;    /*!< r2007+ */\n  BITCODE_RC shadow_flags;      /*!< r2007+: 0 both, 1 casts, 2, receives,\n                                  3 has handle. DXF 284 */\n  BITCODE_B has_full_visualstyle; /*!< r2010+ */\n  BITCODE_B has_face_visualstyle; /*!< r2010+ */\n  BITCODE_B has_edge_visualstyle; /*!< r2010+ */\n  BITCODE_BS invisible;\n  BITCODE_RC linewt;              /*!< r2000+, see dxf_cvt_lweight() */\n\n  /* preR13 entity fields: */\n  BITCODE_RC flag_r11;\n  BITCODE_RS kind_r11;\n  BITCODE_RS opts_r11;\n  BITCODE_RC extra_r11;\n  BITCODE_RS layer_r11;\n  BITCODE_RC color_r11;\n  BITCODE_RS ltype_r11;\n  BITCODE_RD elevation_r11;\n  BITCODE_RD thickness_r11;\n  BITCODE_RS paper_r11;\n  /* preR13 in the obj: eed, elevation/pt.z, thickness, paper */\n\n  /* Common Entity Handle Data */\n  BITCODE_BL __iterator;\n  BITCODE_H ownerhandle; /*!< mspace, pspace or owner of subentity */\n  BITCODE_H* reactors;\n  BITCODE_H xdicobjhandle;\n  BITCODE_H prev_entity;  /*!< r13-r2000 */\n  BITCODE_H next_entity;  /*!< r13-r2000 */\n  BITCODE_H layer;\n  BITCODE_H ltype;\n  BITCODE_H material;     /*!< r2007+ */\n  BITCODE_H shadow;       /*!< r2007+ */\n  BITCODE_H plotstyle;    /*!< r2000+ */\n  BITCODE_H full_visualstyle; /*!< r2010+ */\n  BITCODE_H face_visualstyle;\n  BITCODE_H edge_visualstyle;\n} Dwg_Object_Entity;\n\n/**\n Ordinary object attributes\n */\ntypedef struct _dwg_object_object\n{\n  BITCODE_BL objid; /*<! link to the parent */\n  union\n  {\n    Dwg_Object_BLOCK_CONTROL *BLOCK_CONTROL;\n    Dwg_Object_BLOCK_HEADER *BLOCK_HEADER;\n    Dwg_Object_LAYER_CONTROL *LAYER_CONTROL;\n    Dwg_Object_LAYER *LAYER;\n    Dwg_Object_STYLE_CONTROL *STYLE_CONTROL;\n    Dwg_Object_STYLE *STYLE;\n    Dwg_Object_LTYPE_CONTROL *LTYPE_CONTROL;\n    Dwg_Object_LTYPE *LTYPE;\n    Dwg_Object_VIEW_CONTROL *VIEW_CONTROL;\n    Dwg_Object_VIEW *VIEW;\n    Dwg_Object_UCS_CONTROL *UCS_CONTROL;\n    Dwg_Object_UCS *UCS;\n    Dwg_Object_VPORT_CONTROL *VPORT_CONTROL;\n    Dwg_Object_VPORT *VPORT;\n    Dwg_Object_APPID_CONTROL *APPID_CONTROL;\n    Dwg_Object_APPID *APPID;\n    Dwg_Object_DIMSTYLE_CONTROL *DIMSTYLE_CONTROL;\n    Dwg_Object_DIMSTYLE *DIMSTYLE;\n    Dwg_Object_VPORT_ENTITY_CONTROL *VPORT_ENTITY_CONTROL;\n    Dwg_Object_VPORT_ENTITY_HEADER *VPORT_ENTITY_HEADER;\n\n    //TODO Dwg_Object_ACSH_HISTORY_CLASS *ACSH_HISTORY_CLASS;\n    Dwg_Object_ACSH_SWEEP_CLASS *ACSH_SWEEP_CLASS;\n    //Dwg_Object_ARCALIGNEDTEXT *ARCALIGNEDTEXT;\n    Dwg_Object_ANNOTSCALEOBJECTCONTEXTDATA *ANNOTSCALEOBJECTCONTEXTDATA;\n    Dwg_Object_ASSOC2DCONSTRAINTGROUP *ASSOC2DCONSTRAINTGROUP;\n    Dwg_Object_ASSOCACTION *ASSOCACTION;\n    Dwg_Object_ASSOCALIGNEDDIMACTIONBODY *ASSOCALIGNEDDIMACTIONBODY;\n    Dwg_Object_ASSOCDEPENDENCY *ASSOCDEPENDENCY;\n    //Dwg_Object_ASSOCGEOMDEPENDENCY *ASSOCGEOMDEPENDENCY;\n    Dwg_Object_ASSOCNETWORK *ASSOCNETWORK;\n    Dwg_Object_ASSOCOSNAPPOINTREFACTIONPARAM *ASSOCOSNAPPOINTREFACTIONPARAM;\n    Dwg_Object_ASSOCPERSSUBENTMANAGER *ASSOCPERSSUBENTMANAGER;\n    Dwg_Object_ASSOCPLANESURFACEACTIONBODY *ASSOCPLANESURFACEACTIONBODY;\n    Dwg_Object_CELLSTYLEMAP *CELLSTYLEMAP;\n    Dwg_Object_DATATABLE *DATATABLE;\n    Dwg_Object_DBCOLOR *DBCOLOR;\n    //Dwg_Object_DETAILVIEWSTYLE *DETAILVIEWSTYLE;\n    Dwg_Object_DICTIONARY *DICTIONARY;\n    Dwg_Object_DICTIONARYVAR *DICTIONARYVAR;\n    Dwg_Object_DICTIONARYWDFLT *DICTIONARYWDFLT;\n    Dwg_Object_DIMASSOC *DIMASSOC;\n    //Dwg_Object_DOCUMENTOPTIONS *DOCUMENTOPTIONS;\n    Dwg_Object_DYNAMICBLOCKPURGEPREVENTER *DYNAMICBLOCKPURGEPREVENTER;\n    Dwg_Object_DUMMY *DUMMY;\n    Dwg_Object_EVALUATION_GRAPH *EVALUATION_GRAPH;\n    Dwg_Object_FIELD *FIELD;\n    Dwg_Object_FIELDLIST *FIELDLIST;\n    Dwg_Object_GEODATA *GEODATA;\n    Dwg_Object_GEOMAPIMAGE *GEOMAPIMAGE;\n    Dwg_Object_GROUP *GROUP;\n    Dwg_Object_IDBUFFER *IDBUFFER;\n    Dwg_Object_IMAGEDEF *IMAGEDEF;\n    Dwg_Object_IMAGEDEF_REACTOR *IMAGEDEF_REACTOR;\n    Dwg_Object_LAYER_INDEX *LAYER_INDEX;\n    Dwg_Object_LAYOUT *LAYOUT;\n    Dwg_Object_LIGHTLIST *LIGHTLIST;\n    Dwg_Object_LONG_TRANSACTION *LONG_TRANSACTION;\n    Dwg_Object_MATERIAL *MATERIAL;\n    Dwg_Object_MLEADERSTYLE *MLEADERSTYLE;\n    Dwg_Object_MLINESTYLE *MLINESTYLE;\n    Dwg_Object_NAVISWORKSMODELDEF *NAVISWORKSMODELDEF;\n    //TODO Dwg_Object_NPOCOLLECTION *NPOCOLLECTION;\n    Dwg_Object_OBJECT_PTR *OBJECT_PTR;\n    Dwg_Object_OBJECTCONTEXTDATA *OBJECTCONTEXTDATA;\n    Dwg_Object_PERSSUBENTMANAGER *PERSSUBENTMANAGER;\n    Dwg_Object_PLACEHOLDER *PLACEHOLDER;\n    Dwg_Object_PLOTSETTINGS *PLOTSETTINGS;\n    Dwg_Object_PROXY_OBJECT *PROXY_OBJECT;\n    Dwg_Object_RASTERVARIABLES *RASTERVARIABLES;\n    Dwg_Object_RENDERENVIRONMENT *RENDERENVIRONMENT;\n    Dwg_Object_RENDERGLOBAL *RENDERGLOBAL;\n    //TODO Dwg_Object_RTEXT *RTEXT;\n    Dwg_Object_SCALE *SCALE;\n    //Dwg_Object_SECTIONVIEWSTYLE *SECTIONVIEWSTYLE;\n    Dwg_Object_SORTENTSTABLE *SORTENTSTABLE;\n    Dwg_Object_SPATIAL_FILTER *SPATIAL_FILTER;\n    Dwg_Object_SPATIAL_INDEX *SPATIAL_INDEX;\n    Dwg_Object_SUN *SUN;\n    Dwg_Object_SUNSTUDY *SUNSTUDY;\n    Dwg_Object_TABLECONTENT *TABLECONTENT;\n    Dwg_Object_TABLEGEOMETRY *TABLEGEOMETRY;\n    Dwg_Object_TABLESTYLE *TABLESTYLE;\n    Dwg_Object_VBA_PROJECT *VBA_PROJECT;\n    Dwg_Object_UNDERLAYDEFINITION *UNDERLAYDEFINITION;\n    Dwg_Object_VISUALSTYLE *VISUALSTYLE;\n    Dwg_Object_WIPEOUTVARIABLES *WIPEOUTVARIABLES;\n    Dwg_Object_XRECORD *XRECORD;\n    //TODO Dwg_Object_XREFPANELOBJECT *XREFPANELOBJECT;\n    Dwg_Object_UNKNOWN_OBJ *UNKNOWN_OBJ;\n  } tio;\n\n  struct _dwg_struct *dwg;\n  BITCODE_BL num_eed;\n  Dwg_Eed *eed;\n\n  BITCODE_H ownerhandle;        /*!< DXF 330 */\n  BITCODE_BL num_reactors;\n  BITCODE_H* reactors;\n  BITCODE_H xdicobjhandle;\n  BITCODE_B xdic_missing_flag;  /*!< r2004+ */\n  BITCODE_B has_ds_binary_data; /*!< r2013+ */\n\n  /*unsigned int num_handles;*/\n  Dwg_Handle *handleref; //??\n} Dwg_Object_Object;\n\n/**\n General DWG object with link to either entity or object, and as parent the DWG\n */\ntypedef struct _dwg_object\n{\n  BITCODE_RL size;       /*!< in bytes */\n  unsigned long address; /*!< byte offset in the file */\n  unsigned int type;     /*!< fixed or variable (class - 500) */\n  BITCODE_RL index;      /*!< into dwg->object[] */\n  enum DWG_OBJECT_TYPE fixedtype; /*!< into a global list */\n  char *name;            /*!< our public entity/object name */\n  char *dxfname;         /*!< the internal dxf classname, often with a ACDB prefix */\n\n  Dwg_Object_Supertype supertype;\n  union\n  {\n    Dwg_Object_Entity *entity;\n    Dwg_Object_Object *object;\n  } tio;\n\n  Dwg_Handle handle;\n  struct _dwg_struct *parent;\n\n  BITCODE_RL bitsize;        /* common + object fields, but no handles */\n  unsigned long bitsize_pos; /* bitsize offset in bits: r13-2007 */\n  unsigned long hdlpos;      /* relative offset, in bits */\n  BITCODE_B  has_strings;        /*!< r2007+ */\n  BITCODE_RL stringstream_size;  /*!< r2007+ in bits, unused */\n  BITCODE_UMC handlestream_size; /*!< r2010+ in bits */\n  unsigned long common_size; /* relative offset from type ... end common_entity_data */\n\n  unsigned long num_unknown_bits;\n  char *unknown_bits;\n\n} Dwg_Object;\n\n/**\n Classes\n */\ntypedef struct _dwg_class\n{\n  BITCODE_BS number; /*!< starting with 500 */\n  /* see http://images.autodesk.com/adsk/files/autocad_2012_pdf_dxf-reference_enu.pdf */\n  BITCODE_BS proxyflag; /*!<\n      erase allowed = 1,\n      transform allowed = 2,\n      color change allowed = 4,\n      layer change allowed = 8,\n      line type change allowed = 16,\n      line type scale change allowed = 32,\n      visibility change allowed = 64,\n      cloning allowed = 128,\n      Lineweight change allowed = 256,\n      Plot Style Name change allowed = 512,\n      Disables proxy warning dialog = 1024,\n      is R13 format proxy= 32768 */\n  char *appname;\n  char *cppname;\n  char *dxfname; /*!< ASCII or UTF-8 */\n  BITCODE_TU dxfname_u; /* r2007+, always transformed to dxfname as UTF-8 */\n  BITCODE_B  wasazombie; /*!< really Was-a-proxy flag */\n  BITCODE_BS item_class_id; /* Is-an-entity. 1f2 for entities, 1f3 for objects */\n  BITCODE_BL num_instances; /* 91 Instance count for a custom class */\n  BITCODE_BL dwg_version;\n  BITCODE_BL maint_version;\n  BITCODE_BL unknown_1; /*!< def: 0L */\n  BITCODE_BL unknown_2; /*!< def: 0L */\n} Dwg_Class;\n\n/**\n Dwg_Chain similar to Bit_Chain in \"bits.h\". Used only for the Thumbnail thumbnail\n */\ntypedef struct _dwg_chain\n{\n  unsigned char *chain;\n  long unsigned int size;\n  long unsigned int byte;\n  unsigned char bit;\n} Dwg_Chain;\n\ntypedef enum DWG_SECTION_TYPE /* since r2004+ */\n{\n  SECTION_HEADER = 1,                   /* AcDb:Header */\n  SECTION_AUXHEADER = 2,                /* AcDb:AuxHeader */\n  SECTION_CLASSES = 3,                  /* AcDb:Classes */\n  SECTION_HANDLES = 4,                  /* AcDb:Handles */\n  SECTION_TEMPLATE = 5,                 /* AcDb:Template */\n  SECTION_OBJFREESPACE = 6,             /* AcDb:ObjFreeSpace */\n  SECTION_OBJECTS = 7,                  /* AcDb:AcDbObjects */\n  SECTION_REVHISTORY = 8,               /* AcDb:RevHistory */\n  SECTION_SUMMARYINFO = 9,              /* AcDb:SummaryInfo */\n  SECTION_PREVIEW = 10,                 /* AcDb:Preview */\n  SECTION_APPINFO = 11,                 /* AcDb:AppInfo */\n  SECTION_APPINFOHISTORY = 12,          /* AcDb:AppInfoHistory */\n  SECTION_FILEDEPLIST = 13,             /* AcDb:FileDepList */\n  SECTION_SECURITY,                     /* AcDb:Security, if stored with a password */\n  SECTION_VBAPROJECT,                   /* AcDb:VBAProject */\n  SECTION_SIGNATURE,                    /* AcDb:Signature */\n  SECTION_PROTOTYPE,                    /* AcDb:AcDsPrototype_1b */\n  SECTION_UNKNOWN,\n} Dwg_Section_Type;\n\ntypedef enum DWG_SECTION_TYPE_R13\n{\n  SECTION_HEADER_R13 = 0,\n  SECTION_CLASSES_R13 = 1,\n  SECTION_HANDLES_R13 = 2,\n  SECTION_2NDHEADER_R13 = 3,\n  SECTION_MEASUREMENT_R13 = 4,\n  SECTION_AUXHEADER_R2000 = 5,\n} Dwg_Section_Type_R13;\n\ntypedef enum DWG_SECTION_TYPE_R11 /* tables */\n{\n  SECTION_HEADER_R11 = 0,\n  SECTION_BLOCK = 1,\n  SECTION_LAYER = 2,\n  SECTION_STYLE = 3,\n  SECTION_LTYPE = 5,\n  SECTION_VIEW  = 6,\n  SECTION_UCS   = 7,\n  SECTION_VPORT = 8,\n  SECTION_APPID = 9,\n  SECTION_DIMSTYLE = 10,\n  SECTION_VPORT_ENTITY = 11,\n} Dwg_Section_Type_r11;\n\ntypedef struct _dwg_section\n{\n  int32_t    number; /* preR13: count of entries, r2007: id */\n  BITCODE_RL size;   /* now unsigned */\n  uint64_t   address;\n  BITCODE_RL parent;\n  BITCODE_RL left;\n  BITCODE_RL right;\n  BITCODE_RL x00;\n  Dwg_Section_Type type; /* to be casted to Dwg_Section_Type_r11 preR13 */\n  /* => section_info? */\n  char name[64];\n  /*!< r2004 section fields: */\n  BITCODE_RL section_type;\n  BITCODE_RL decomp_data_size;\n  BITCODE_RL comp_data_size;\n  BITCODE_RL compression_type;\n  BITCODE_RL checksum;\n} Dwg_Section;\n\n/* Dwg_R2007_Section:\n  int64_t  data_size;    // max size of page\n  int64_t  max_size;\n  int64_t  encrypted;\n  int64_t  hashcode;\n  int64_t  name_length;  // 0x22\n  int64_t  unknown;      // 0x00\n  int64_t  encoded;\n  int64_t  num_pages;\n  DWGCHAR *name;\n  r2007_section_page **pages;\n  struct _r2007_section *next;\n */\n\n// ODA 4.5\ntypedef struct\n{\n  BITCODE_RL num_desc;\n  BITCODE_RL compressed; /* Compressed (1 = no, 2 = yes, normally 2) */\n  BITCODE_RL max_size;\n  BITCODE_RL encrypted; /* (0 = no, 1 = yes, 2 = unknown) */\n  BITCODE_RL num_desc2;\n} Dwg_Section_InfoHdr;\n\ntypedef struct\n{\n  int64_t    size;\n  BITCODE_RL num_sections;\n  BITCODE_RL max_decomp_size;\n  BITCODE_RL unknown;\n  BITCODE_RL compressed; /* Compressed (1 = no, 2 = yes, normally 2) */\n  BITCODE_RL type;\n  BITCODE_RL encrypted; /* (0 = no, 1 = yes, 2 = unknown) */\n  char name[64];\n  Dwg_Section **sections;\n} Dwg_Section_Info;\n\n\ntypedef struct _dwg_SummaryInfo_Property\n{\n  BITCODE_T key;\n  BITCODE_T value;\n} Dwg_SummaryInfo_Property;\n\n/**\n Main DWG struct\n */\ntypedef struct _dwg_struct\n{\n  struct Dwg_Header\n  {\n    Dwg_Version_Type version;          /* calculated from the header magic */\n    Dwg_Version_Type from_version;     /* option. set by --as (convert from) */\n    BITCODE_RC   zero_5[5];\n    BITCODE_RC   is_maint;\n    BITCODE_RC   zero_one_or_three;\n    BITCODE_RS   unknown_s[3];         /* <R13 */\n    BITCODE_RL   thumbnail_address;    /* THUMBNAIL or AdDb:Preview */\n    BITCODE_RC   dwg_version;\n    BITCODE_RC   maint_version;\n    BITCODE_RS   codepage;\n    BITCODE_RC   unknown_0;            /* R2004+ */\n    BITCODE_RC   app_dwg_version;      /* R2004+ */\n    BITCODE_RC   app_maint_version;    /* R2004+ */\n    BITCODE_RL   security_type;        /* R2004+ */\n    BITCODE_RL   rl_1c_address;        /* R2004+ mostly 0 */\n    BITCODE_RL   summaryinfo_address;  /* R2004+ */\n    BITCODE_RL   vbaproj_address;      /* R2004+ */\n    BITCODE_RL   rl_28_80;             /* R2004+ */\n    BITCODE_RL   num_sections;\n    Dwg_Section* section;\n    Dwg_Section_InfoHdr section_infohdr; /* R2004+ */\n    Dwg_Section_Info* section_info;\n  } header;\n\n  struct Dwg_R2004_Header /* encrypted */\n    {\n      BITCODE_RC file_ID_string[12];\n      BITCODE_RLx header_address;\n      BITCODE_RL header_size;\n      BITCODE_RL x04;\n      BITCODE_RLd root_tree_node_gap;\n      BITCODE_RLd lowermost_left_tree_node_gap;\n      BITCODE_RLd lowermost_right_tree_node_gap;\n      BITCODE_RL unknown_long;\n      BITCODE_RL last_section_id;\n      BITCODE_RLL last_section_address;\n      BITCODE_RLL second_header_address;\n      BITCODE_RL num_gaps;\n      BITCODE_RL num_sections;\n      BITCODE_RL x20;\n      BITCODE_RL x80;\n      BITCODE_RL x40;\n      BITCODE_RL section_map_id;\n      BITCODE_RLL section_map_address;\n      BITCODE_RL section_info_id;\n      BITCODE_RL section_array_size;\n      BITCODE_RL gap_array_size;\n      BITCODE_RLx crc32; /* p 2.14.2 32bit CRC 2004+ */\n      BITCODE_RC padding[12];\n      /* System Section: Section Page Map */\n      BITCODE_RL section_type; /* 0x4163043b */\n      BITCODE_RL decomp_data_size;\n      BITCODE_RL comp_data_size;\n      BITCODE_RL compression_type;\n      BITCODE_RLx checksum;\n  } r2004_header;\n\n  /* #define DWG_AUXHEADER_SIZE 123 */\n  struct Dwg_AuxHeader\n  {\n    BITCODE_RC   aux_intro[3]; /* ff 77 01 */\n    BITCODE_RS   dwg_version;\n    BITCODE_RS   maint_version;\n    BITCODE_RL   num_saves;\n    BITCODE_RL   minus_1;\n    BITCODE_RS   num_saves_1;\n    BITCODE_RS   num_saves_2;\n    BITCODE_RL   zero;\n    BITCODE_RS   dwg_version_1;\n    BITCODE_RS   maint_version_1;\n    BITCODE_RS   dwg_version_2;\n    BITCODE_RS   maint_version_2;\n    BITCODE_RS   unknown_rs[6];\n    BITCODE_RC   unknown_rc[20]; /* some vars */\n    BITCODE_RD   TDCREATE; /* ?? format TD */\n    BITCODE_RD   TDUPDATE;\n    BITCODE_RL   HANDSEED;\n    BITCODE_RL   plot_stamp;\n    BITCODE_RS   zero_1;\n    BITCODE_RS   num_saves_3;\n    BITCODE_RL   zero_2;\n    BITCODE_RL   zero_3;\n    BITCODE_RL   zero_4;\n    BITCODE_RL   num_saves_4;\n    BITCODE_RL   zero_5;\n    BITCODE_RL   zero_6;\n    BITCODE_RL   zero_7;\n    BITCODE_RL   zero_8; /* ?? */\n    BITCODE_RS   zero_18[3]; /* R2018+ */\n  } auxheader;\n\n  struct Dwg_SummaryInfo\n  {\n    BITCODE_T    TITLE;\n    BITCODE_T    SUBJECT;\n    BITCODE_T    AUTHOR;\n    BITCODE_T    KEYWORDS;\n    BITCODE_T    COMMENTS;\n    BITCODE_T    LASTSAVEDBY;\n    BITCODE_T    REVISIONNUMBER;\n    BITCODE_T    HYPERLINKBASE;\n    BITCODE_TIMERLL  TDINDWG; /* days + ms, fixed size! */\n    BITCODE_TIMERLL  TDCREATE;\n    BITCODE_TIMERLL  TDUPDATE;\n    BITCODE_RS   num_props;\n    Dwg_SummaryInfo_Property *props;\n    BITCODE_RL   unknown1;\n    BITCODE_RL   unknown2;\n  } summaryinfo;\n  \n  Dwg_Chain thumbnail;\n\n  Dwg_Header_Variables header_vars;\n  \n  BITCODE_BS num_classes;    /*!< size of dwg_class */\n  Dwg_Class * dwg_class;     /*!< list of all classes */\n\n  BITCODE_BL num_objects;    /*!< size of object */\n  Dwg_Object * object;       /*!< list of all objects and entities */\n\n  BITCODE_BL num_entities;       /*!< number of entities in object */\n  BITCODE_BL num_object_refs;    /*!< number of object_ref's (resolved handles) */\n  Dwg_Object_Ref **object_ref;   /*!< array of all handles */\n  struct _inthash *object_map;   /*!< map of all handles */\n  int dirty_refs; /* 1 if we added an entity, and invalidated all the internal ref->obj's */\n \n  Dwg_Object *mspace_block;\n  Dwg_Object *pspace_block;\n  /* Those TABLES might be empty with num_entries=0 */\n  Dwg_Object_BLOCK_CONTROL      block_control;\n  Dwg_Object_LAYER_CONTROL      layer_control;\n  Dwg_Object_STYLE_CONTROL      style_control;\n  Dwg_Object_LTYPE_CONTROL      ltype_control;\n  Dwg_Object_VIEW_CONTROL       view_control;\n  Dwg_Object_UCS_CONTROL        ucs_control;\n  Dwg_Object_VPORT_CONTROL      vport_control;\n  Dwg_Object_APPID_CONTROL      appid_control;\n  Dwg_Object_DIMSTYLE_CONTROL   dimstyle_control;\n  Dwg_Object_VPORT_ENTITY_CONTROL  vport_entity_control;\n\n  struct _dwg_second_header {\n    BITCODE_RL size;\n    BITCODE_RL address;\n    BITCODE_RC version[12];\n    BITCODE_B null_b[4];\n    BITCODE_RC unknown_10;\n    BITCODE_RC unknown_rc4[4];\n    BITCODE_RC num_sections;\n    struct _sections\n    {\n      BITCODE_RC nr;\n      BITCODE_BL address;\n      BITCODE_BL size;\n    } section[6];\n    BITCODE_BS num_handlers;\n    struct _handler\n    {\n      BITCODE_RC size;\n      BITCODE_RC nr;\n      BITCODE_RC *data;\n    } handlers[16];\n    BITCODE_RL junk_r14_1; /*!< r14 only */\n    BITCODE_RL junk_r14_2; /*!< r14 only */\n  } second_header;\n\n  unsigned int layout_type;\n  unsigned int opts; /* See DWG_OPTS_* below */\n} Dwg_Data;\n\n#define DWG_OPTS_LOGLEVEL 0xf\n#define DWG_OPTS_MINIMAL  0x10\n#define DWG_OPTS_INDXF    0x20\n#define DWG_OPTS_DXFB     0x40\n\n/*--------------------------------------------------\n * Exported Functions\n */\n\nEXPORT int dwg_read_file (const char *restrict filename,\n                          Dwg_Data *restrict dwg);\nEXPORT int dxf_read_file (const char *restrict filename,\n                          Dwg_Data *restrict dwg);\n\n#ifdef USE_WRITE\nEXPORT int dwg_write_file (const char *restrict filename,\n                           const Dwg_Data *restrict dwg);\n#endif\n\nEXPORT unsigned char *dwg_bmp (const Dwg_Data *restrict, BITCODE_RL *restrict);\n\n/** Converts the internal enum RC into 100th mm lineweight, with\n *  -1 BYLAYER, -2 BYBLOCK, -3 BYLWDEFAULT.\n */\nEXPORT int dxf_cvt_lweight (const BITCODE_BSd value);\n\n/** Converts the 100th mm lineweight, with -1 BYLAYER, -2 BYBLOCK, -3 BYLWDEFAULT,\n    into the internal enum RC.\n */\nEXPORT BITCODE_BSd dxf_revcvt_lweight (const int lw);\n\n/* Search for the name in the associated table, and return its handle. Search\n * is case-insensitive */\nEXPORT BITCODE_H dwg_find_tablehandle (Dwg_Data *restrict dwg,\n                                       const char *restrict name,\n                                       const char *restrict table);\n\n/** Not checking the header_vars entry, only searching the objects\n *  Returning a hardowner or hardpointer (DICTIONARY) ref (code 3 or 5)\n *  to it, as stored in header_vars. table must contain the \"_CONTROL\" suffix.\n */\nEXPORT BITCODE_H dwg_find_table_control (Dwg_Data *restrict dwg,\n                                         const char *restrict table);\n\n/** Searching for a dictionary ref.\n *  Returning a hardpointer ref (5) to it, as stored in header_vars. */\nEXPORT BITCODE_H dwg_find_dictionary (Dwg_Data *restrict dwg,\n                                      const char *restrict name);\n/** Searching for a named dictionary entry in the given dict. Search is\n * case-insensitive */\nEXPORT BITCODE_H dwg_find_dicthandle (Dwg_Data *restrict dwg, BITCODE_H dict,\n                                      const char *restrict name);\n/* Search for a table EXTNAME */\nEXPORT char *dwg_find_table_extname (Dwg_Data *restrict dwg,\n                                     Dwg_Object *restrict obj);\n\nEXPORT double dwg_model_x_min (const Dwg_Data *restrict);\nEXPORT double dwg_model_x_max (const Dwg_Data *restrict);\nEXPORT double dwg_model_y_min (const Dwg_Data *restrict);\nEXPORT double dwg_model_y_max (const Dwg_Data *restrict);\nEXPORT double dwg_model_z_min (const Dwg_Data *restrict);\nEXPORT double dwg_model_z_max (const Dwg_Data *restrict);\nEXPORT double dwg_page_x_min (const Dwg_Data *restrict);\nEXPORT double dwg_page_x_max (const Dwg_Data *restrict);\nEXPORT double dwg_page_y_min (const Dwg_Data *restrict);\nEXPORT double dwg_page_y_max (const Dwg_Data *restrict);\n\nEXPORT Dwg_Object_BLOCK_CONTROL * dwg_block_control (Dwg_Data *restrict dwg);\n\nEXPORT Dwg_Object_Ref * dwg_model_space_ref (Dwg_Data *restrict dwg);\nEXPORT Dwg_Object_Ref * dwg_paper_space_ref (Dwg_Data *restrict dwg);\nEXPORT Dwg_Object * dwg_model_space_object (Dwg_Data *restrict dwg);\n\nEXPORT unsigned int dwg_get_layer_count (const Dwg_Data *restrict dwg);\n\nEXPORT Dwg_Object_LAYER ** dwg_get_layers (const Dwg_Data *restrict dwg);\n\nEXPORT BITCODE_BL dwg_get_num_objects (const Dwg_Data *restrict dwg);\n\nEXPORT BITCODE_BL dwg_get_object_num_objects (const Dwg_Data *restrict dwg);\n\nEXPORT int dwg_class_is_entity (const Dwg_Class *restrict klass);\n\nEXPORT int dwg_obj_is_control (const Dwg_Object *restrict obj);\n\nEXPORT int dwg_obj_is_table (const Dwg_Object *restrict obj);\n\nEXPORT int dwg_obj_is_subentity (const Dwg_Object *restrict obj);\n\nEXPORT int dwg_obj_has_subentity (const Dwg_Object *restrict obj);\n\nEXPORT BITCODE_BL dwg_get_num_entities (const Dwg_Data *restrict);\n\nEXPORT Dwg_Object_Entity **dwg_get_entities (const Dwg_Data *restrict);\n\nEXPORT Dwg_Object_LAYER *\ndwg_get_entity_layer (const Dwg_Object_Entity *restrict);\n\nEXPORT Dwg_Object *dwg_next_object (const Dwg_Object *obj);\n\nEXPORT Dwg_Object *dwg_ref_object (const Dwg_Data *restrict dwg,\n                                   Dwg_Object_Ref *restrict ref);\n\nEXPORT Dwg_Object *dwg_ref_object_relative (const Dwg_Data *restrict dwg,\n                                            Dwg_Object_Ref *restrict ref,\n                                            const Dwg_Object *restrict obj);\nEXPORT Dwg_Object *dwg_ref_object_silent (const Dwg_Data *restrict dwg,\n                                          Dwg_Object_Ref *restrict ref);\n\nEXPORT Dwg_Object *get_first_owned_entity (const Dwg_Object *restrict hdr);\nEXPORT Dwg_Object *get_next_owned_entity (const Dwg_Object *restrict hdr,\n                                          const Dwg_Object *restrict current);\nEXPORT Dwg_Object *get_first_owned_subentity (const Dwg_Object *restrict owner);\nEXPORT Dwg_Object *get_next_owned_subentity (const Dwg_Object *restrict owner,\n                                             const Dwg_Object *restrict current);\nEXPORT Dwg_Object *get_first_owned_block (const Dwg_Object *hdr);\nEXPORT Dwg_Object *get_last_owned_block (const Dwg_Object *hdr);\nEXPORT Dwg_Object *get_next_owned_block (const Dwg_Object *restrict hdr,\n                                         const Dwg_Object *restrict current);\n\nEXPORT Dwg_Object *dwg_resolve_handle (const Dwg_Data *restrict dwg,\n                                       const unsigned long absref);\nEXPORT Dwg_Object *dwg_resolve_handle_silent (const Dwg_Data *restrict dwg,\n                                              const BITCODE_BL absref);\nEXPORT int dwg_resolve_handleref (Dwg_Object_Ref *restrict ref,\n                                  const Dwg_Object *restrict obj);\n\nEXPORT Dwg_Section_Type dwg_section_type (const DWGCHAR *restrict wname);\n\n/** Free the whole DWG. all tables, sections, objects, ...\n*/\nEXPORT void dwg_free (Dwg_Data *restrict dwg);\n\n/** Free the object (all three structs and its fields)\n*/\nEXPORT void dwg_free_object (Dwg_Object *restrict obj);\n\n/** Add the empty ref to the DWG (freshly malloc'ed), or NULL.\n*/\nEXPORT Dwg_Object_Ref * dwg_new_ref (Dwg_Data *restrict dwg);\n\n/** For encode:\n *  May need obj to shorten the code to a relative offset, but not in header_vars.\n *  There obj is NULL.\n */\nEXPORT int\ndwg_add_handle (Dwg_Handle *restrict hdl, BITCODE_RC code, unsigned long value,\n                Dwg_Object *restrict obj);\n\n/** Returns an existing ref with the same ownership (hard/soft, owner/pointer)\n    or creates it. With obj non-NULL it may return a relative offset, otherwise\n    always absolute.\n*/\nEXPORT Dwg_Object_Ref *\ndwg_add_handleref (Dwg_Data *restrict dwg, BITCODE_RC code, unsigned long value,\n                   Dwg_Object *restrict obj);\n\n/** Add the empty object to the DWG.\n    Returns DWG_ERR_OUTOFMEM, -1 for realloced or 0 if not.\n*/\nEXPORT int dwg_add_object (Dwg_Data *restrict dwg);\n\n/** Initialize the empty entity or object with its three structs.\n    All fields are zero'd, some are initialized with default values, as\n    defined in dwg.spec.\n    Returns 0 or DWG_ERR_OUTOFMEM.\n*/\nEXPORT int dwg_add_TEXT (Dwg_Object *obj);\nEXPORT int dwg_add_ATTRIB (Dwg_Object *obj);\nEXPORT int dwg_add_ATTDEF (Dwg_Object *obj);\nEXPORT int dwg_add_BLOCK (Dwg_Object *obj);\nEXPORT int dwg_add_ENDBLK (Dwg_Object *obj);\nEXPORT int dwg_add_SEQEND (Dwg_Object *obj);\nEXPORT int dwg_add_INSERT (Dwg_Object *obj);\nEXPORT int dwg_add_MINSERT (Dwg_Object *obj);\nEXPORT int dwg_add_VERTEX_2D (Dwg_Object *obj);\nEXPORT int dwg_add_VERTEX_3D (Dwg_Object *obj);\nEXPORT int dwg_add_VERTEX_MESH (Dwg_Object *obj);\nEXPORT int dwg_add_VERTEX_PFACE (Dwg_Object *obj);\nEXPORT int dwg_add_VERTEX_PFACE_FACE (Dwg_Object *obj);\nEXPORT int dwg_add_POLYLINE_2D (Dwg_Object *obj);\nEXPORT int dwg_add_POLYLINE_3D (Dwg_Object *obj);\nEXPORT int dwg_add_ARC (Dwg_Object *obj);\nEXPORT int dwg_add_CIRCLE (Dwg_Object *obj);\nEXPORT int dwg_add_LINE (Dwg_Object *obj);\nEXPORT int dwg_add_DIMENSION_ORDINATE (Dwg_Object *obj);\nEXPORT int dwg_add_DIMENSION_LINEAR (Dwg_Object *obj);\nEXPORT int dwg_add_DIMENSION_ALIGNED (Dwg_Object *obj);\nEXPORT int dwg_add_DIMENSION_ANG3PT (Dwg_Object *obj);\nEXPORT int dwg_add_DIMENSION_ANG2LN (Dwg_Object *obj);\nEXPORT int dwg_add_DIMENSION_RADIUS (Dwg_Object *obj);\nEXPORT int dwg_add_DIMENSION_DIAMETER (Dwg_Object *obj);\nEXPORT int dwg_add_POINT (Dwg_Object *obj);\nEXPORT int dwg_add__3DFACE (Dwg_Object *obj);\nEXPORT int dwg_add__3DSOLID (Dwg_Object *obj);\nEXPORT int dwg_add_POLYLINE_PFACE (Dwg_Object *obj);\nEXPORT int dwg_add_POLYLINE_MESH (Dwg_Object *obj);\nEXPORT int dwg_add_SOLID (Dwg_Object *obj);\nEXPORT int dwg_add_TRACE (Dwg_Object *obj);\nEXPORT int dwg_add_SHAPE (Dwg_Object *obj);\nEXPORT int dwg_add_VIEWPORT (Dwg_Object *obj);\nEXPORT int dwg_add_ELLIPSE (Dwg_Object *obj);\nEXPORT int dwg_add_SPLINE (Dwg_Object *obj);\nEXPORT int dwg_add_REGION (Dwg_Object *obj);\nEXPORT int dwg_add_BODY (Dwg_Object *obj);\nEXPORT int dwg_add_RAY (Dwg_Object *obj);\nEXPORT int dwg_add_XLINE (Dwg_Object *obj);\nEXPORT int dwg_add_DICTIONARY (Dwg_Object *obj);\nEXPORT int dwg_add_OLEFRAME (Dwg_Object *obj);\nEXPORT int dwg_add_MTEXT (Dwg_Object *obj);\nEXPORT int dwg_add_LEADER (Dwg_Object *obj);\nEXPORT int dwg_add_TOLERANCE (Dwg_Object *obj);\nEXPORT int dwg_add_MLINE (Dwg_Object *obj);\nEXPORT int dwg_add_BLOCK_CONTROL (Dwg_Object *obj);\nEXPORT int dwg_add_BLOCK_HEADER (Dwg_Object *obj);\nEXPORT int dwg_add_LAYER_CONTROL (Dwg_Object *obj);\nEXPORT int dwg_add_LAYER (Dwg_Object *obj);\nEXPORT int dwg_add_STYLE_CONTROL (Dwg_Object *obj);\nEXPORT int dwg_add_STYLE (Dwg_Object *obj);\nEXPORT int dwg_add_LTYPE_CONTROL (Dwg_Object *obj);\nEXPORT int dwg_add_LTYPE (Dwg_Object *obj);\nEXPORT int dwg_add_VIEW_CONTROL (Dwg_Object *obj);\nEXPORT int dwg_add_VIEW (Dwg_Object *obj);\nEXPORT int dwg_add_UCS_CONTROL (Dwg_Object *obj);\nEXPORT int dwg_add_UCS (Dwg_Object *obj);\nEXPORT int dwg_add_VPORT_CONTROL (Dwg_Object *obj);\nEXPORT int dwg_add_VPORT (Dwg_Object *obj);\nEXPORT int dwg_add_APPID_CONTROL (Dwg_Object *obj);\nEXPORT int dwg_add_APPID (Dwg_Object *obj);\nEXPORT int dwg_add_DIMSTYLE_CONTROL (Dwg_Object *obj);\nEXPORT int dwg_add_DIMSTYLE (Dwg_Object *obj);\nEXPORT int dwg_add_VPORT_ENTITY_CONTROL (Dwg_Object *obj);\nEXPORT int dwg_add_VPORT_ENTITY_HEADER (Dwg_Object *obj);\nEXPORT int dwg_add_GROUP (Dwg_Object *obj);\nEXPORT int dwg_add_MLINESTYLE (Dwg_Object *obj);\nEXPORT int dwg_add_OLE2FRAME (Dwg_Object *obj);\nEXPORT int dwg_add_DUMMY (Dwg_Object *obj);\nEXPORT int dwg_add_LONG_TRANSACTION (Dwg_Object *obj);\nEXPORT int dwg_add_LWPOLYLINE (Dwg_Object *obj);\nEXPORT int dwg_add_HATCH (Dwg_Object *obj);\nEXPORT int dwg_add_XRECORD (Dwg_Object *obj);\nEXPORT int dwg_add_PLACEHOLDER (Dwg_Object *obj);\nEXPORT int dwg_add_LAYOUT (Dwg_Object *obj);\nEXPORT int dwg_add_PROXY_ENTITY (Dwg_Object *obj);\nEXPORT int dwg_add_PROXY_OBJECT (Dwg_Object *obj);\nEXPORT int dwg_add_UNKNOWN_ENT (Dwg_Object *obj);\nEXPORT int dwg_add_UNKNOWN_OBJ (Dwg_Object *obj);\n\n/* STABLE: */\nEXPORT int dwg_add_DICTIONARYVAR (Dwg_Object *obj);\nEXPORT int dwg_add_DICTIONARYWDFLT (Dwg_Object *obj);\nEXPORT int dwg_add_FIELD (Dwg_Object *obj);\nEXPORT int dwg_add_FIELDLIST (Dwg_Object *obj);\nEXPORT int dwg_add_IDBUFFER (Dwg_Object *obj);\nEXPORT int dwg_add_IMAGE (Dwg_Object *obj);\nEXPORT int dwg_add_IMAGEDEF (Dwg_Object *obj);\nEXPORT int dwg_add_IMAGEDEF_REACTOR (Dwg_Object *obj);\nEXPORT int dwg_add_LAYER_INDEX (Dwg_Object *obj);\nEXPORT int dwg_add_MLEADERSTYLE (Dwg_Object *obj);\nEXPORT int dwg_add_OBJECTCONTEXTDATA (Dwg_Object *obj);\nEXPORT int dwg_add_RASTERVARIABLES (Dwg_Object *obj);\nEXPORT int dwg_add_SCALE (Dwg_Object *obj);\nEXPORT int dwg_add_SORTENTSTABLE (Dwg_Object *obj);\nEXPORT int dwg_add_SPATIAL_FILTER (Dwg_Object *obj);\nEXPORT int dwg_add_SPATIAL_INDEX (Dwg_Object *obj);\nEXPORT int dwg_add_WIPEOUTVARIABLES (Dwg_Object *obj);\nEXPORT int dwg_add_WIPEOUT (Dwg_Object *obj);\n\n/* UNSTABLE: */\nEXPORT int dwg_add_ASSOCDEPENDENCY (Dwg_Object *obj);\nEXPORT int dwg_add_ASSOCPLANESURFACEACTIONBODY (Dwg_Object *obj);\nEXPORT int dwg_add_CAMERA (Dwg_Object *obj);\nEXPORT int dwg_add_DIMASSOC (Dwg_Object *obj);\nEXPORT int dwg_add_DBCOLOR (Dwg_Object *obj);\nEXPORT int dwg_add_DYNAMICBLOCKPURGEPREVENTER (Dwg_Object *obj);\nEXPORT int dwg_add_GEODATA (Dwg_Object *obj);\nEXPORT int dwg_add_HELIX (Dwg_Object *obj);\nEXPORT int dwg_add_LIGHT (Dwg_Object *obj);\nEXPORT int dwg_add_MULTILEADER (Dwg_Object *obj);\nEXPORT int dwg_add_OBJECT_PTR (Dwg_Object *obj);\nEXPORT int dwg_add_PERSSUBENTMANAGER (Dwg_Object *obj);\nEXPORT int dwg_add_TABLESTYLE (Dwg_Object *obj);\nEXPORT int dwg_add_UNDERLAY (Dwg_Object *obj);\nEXPORT int dwg_add_UNDERLAYDEFINITION (Dwg_Object *obj);\nEXPORT int dwg_add_VISUALSTYLE (Dwg_Object *obj);\n\n#ifdef DEBUG_CLASSES\n\n/* DEBUGGING and UNHANDLED: */\nEXPORT int dwg_add_VBA_PROJECT (Dwg_Object *obj);\nEXPORT int dwg_add_ASSOC2DCONSTRAINTGROUP (Dwg_Object *obj);\nEXPORT int dwg_add_ASSOCACTION (Dwg_Object *obj);\nEXPORT int dwg_add_ASSOCALIGNEDDIMACTIONBODY (Dwg_Object *obj);\nEXPORT int dwg_add_ASSOCNETWORK (Dwg_Object *obj);\nEXPORT int dwg_add_NAVISWORKSMODELDEF (Dwg_Object *obj);\n//EXPORT int dwg_add_ACSH_HISTORY_CLASS (Dwg_Object *obj);\nEXPORT int dwg_add_ACSH_SWEEP_CLASS (Dwg_Object *obj);\n//EXPORT int dwg_add_ARCALIGNEDTEXT (Dwg_Object *obj);\nEXPORT int dwg_add_ARC_DIMENSION (Dwg_Object *obj);\nEXPORT int dwg_add_ANNOTSCALEOBJECTCONTEXTDATA (Dwg_Object *obj);\n//EXPORT int dwg_add_ASSOCGEOMDEPENDENCY (Dwg_Object *obj);\nEXPORT int dwg_add_ASSOCOSNAPPOINTREFACTIONPARAM (Dwg_Object *obj);\nEXPORT int dwg_add_ASSOCPERSSUBENTMANAGER (Dwg_Object *obj);\n//EXPORT int dwg_add_ASSOCVERTEXACTIONPARAM (Dwg_Object *obj);\nEXPORT int dwg_add_DATATABLE (Dwg_Object *obj);\n//EXPORT int dwg_add_DETAILVIEWSTYLE (Dwg_Object *obj);\nEXPORT int dwg_add_EVALUATION_GRAPH (Dwg_Object *obj);\nEXPORT int dwg_add_GEOMAPIMAGE (Dwg_Object *obj);\nEXPORT int dwg_add_GEOPOSITIONMARKER (Dwg_Object *obj);\n//EXPORT int dwg_add_LAYER_FILTER (Dwg_Object *obj);\n//EXPORT int dwg_add_LAYOUTPRINTCONFIG (Dwg_Object *obj);\nEXPORT int dwg_add_LIGHTLIST (Dwg_Object *obj);\nEXPORT int dwg_add_MATERIAL (Dwg_Object *obj);\nEXPORT int dwg_add_MESH (Dwg_Object *obj);\n//EXPORT int dwg_add_NPOCOLLECTION (Dwg_Object *obj);\nEXPORT int dwg_add_PLOTSETTINGS (Dwg_Object *obj);\n//EXPORT int dwg_add_POINTCLOUD (Dwg_Object *obj);\n//EXPORT int dwg_add_SECTIONVIEWSTYLE (Dwg_Object *obj);\nEXPORT int dwg_add_CELLSTYLEMAP (Dwg_Object *obj);\n//EXPORT int dwg_add_DOCUMENTOPTIONS (Dwg_Object *obj);\nEXPORT int dwg_add_RENDERENVIRONMENT (Dwg_Object *obj);\nEXPORT int dwg_add_RENDERGLOBAL (Dwg_Object *obj);\n//EXPORT int dwg_add_RTEXT (Dwg_Object *obj);\nEXPORT int dwg_add_PLANESURFACE (Dwg_Object *obj);\nEXPORT int dwg_add_EXTRUDEDSURFACE (Dwg_Object *obj);\nEXPORT int dwg_add_LOFTEDSURFACE (Dwg_Object *obj);\nEXPORT int dwg_add_REVOLVEDSURFACE (Dwg_Object *obj);\nEXPORT int dwg_add_SWEPTSURFACE (Dwg_Object *obj);\nEXPORT int dwg_add_SUN (Dwg_Object *obj);\nEXPORT int dwg_add_SUNSTUDY (Dwg_Object *obj);\nEXPORT int dwg_add_TABLE (Dwg_Object *obj);\nEXPORT int dwg_add_TABLECONTENT (Dwg_Object *obj);\nEXPORT int dwg_add_TABLEGEOMETRY (Dwg_Object *obj);\n//EXPORT int dwg_add_XREFPANELOBJECT (Dwg_Object *obj);\n\n#endif /* DEBUG_CLASSES */\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n", "/*****************************************************************************/\n/*  LibreDWG - free implementation of the DWG file format                    */\n/*                                                                           */\n/*  Copyright (C) 2009-2010,2018-2019 Free Software Foundation, Inc.         */\n/*                                                                           */\n/*  This library is free software, licensed under the terms of the GNU       */\n/*  General Public License as published by the Free Software Foundation,     */\n/*  either version 3 of the License, or (at your option) any later version.  */\n/*  You should have received a copy of the GNU General Public License        */\n/*  along with this program.  If not, see <http://www.gnu.org/licenses/>.    */\n/*****************************************************************************/\n\n/*\n * decode.c: decoding functions\n * written by Felipe Castro\n * modified by Felipe Corr\u00eaa da Silva Sances\n * modified by Rodrigo Rodrigues da Silva\n * modified by Till Heuschmann\n * modified by Reini Urban\n * modified by Denis Pruchkovsky\n */\n\n#include \"config.h\"\n#ifdef __STDC_ALLOC_LIB__\n#  define __STDC_WANT_LIB_EXT2__ 1 /* for strdup */\n#else\n#  define _USE_BSD 1\n#endif\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <assert.h>\n#ifdef HAVE_WCHAR_H\n#  include <wchar.h>\n#endif\n\n#include \"common.h\"\n#include \"bits.h\"\n#include \"dwg.h\"\n#include \"hash.h\"\n#include \"decode.h\"\n#include \"print.h\"\n#include \"free.h\"\n#include \"dynapi.h\"\n\n/* The logging level for the read (decode) path.  */\nstatic unsigned int loglevel;\n/* the current version per spec block */\nstatic int cur_ver = 0;\nstatic BITCODE_BL rcount1 = 0, rcount2 = 0;\n\n#ifdef USE_TRACING\n/* This flag means we have checked the environment variable\n   LIBREDWG_TRACE and set `loglevel' appropriately.  */\nstatic bool env_var_checked_p;\n#endif /* USE_TRACING */\n#define DWG_LOGLEVEL loglevel\n\n#include \"logging.h\"\n#include \"dec_macros.h\"\n\n#define REFS_PER_REALLOC 128\n\n#define MAX(X, Y) ((X) > (Y) ? (X) : (Y))\n#define MIN(X, Y) ((X) < (Y) ? (X) : (Y))\n\n/*------------------------------------------------------------------------------\n * Private functions\n */\n\nstatic int resolve_objectref_vector (Bit_Chain *restrict dat,\n                                     Dwg_Data *restrict dwg);\n\nstatic void decode_preR13_section_ptr (const char *restrict name,\n                                       Dwg_Section_Type_r11 id,\n                                       Bit_Chain *restrict dat,\n                                       Dwg_Data *restrict dwg);\nstatic void decode_preR13_section_chk (Dwg_Section_Type_r11 id,\n                                       Bit_Chain *restrict dat,\n                                       Dwg_Data *restrict dwg);\nstatic int decode_preR13_section (Dwg_Section_Type_r11 id,\n                                  Bit_Chain *restrict dat,\n                                  Dwg_Data *restrict dwg);\nstatic int decode_preR13_entities (unsigned long start, unsigned long end,\n                                   unsigned long offset, Bit_Chain *dat,\n                                   Dwg_Data *restrict dwg);\n\nstatic int decode_preR13 (Bit_Chain *restrict dat, Dwg_Data *restrict dwg);\nstatic int decode_R13_R2000 (Bit_Chain *restrict dat, Dwg_Data *restrict dwg);\nstatic int decode_R2004 (Bit_Chain *restrict dat, Dwg_Data *restrict dwg);\nstatic int decode_R2007 (Bit_Chain *restrict dat, Dwg_Data *restrict dwg);\n\nstatic Dwg_Resbuf *dwg_decode_xdata (Bit_Chain *restrict dat,\n                                     Dwg_Object_XRECORD *restrict obj,\n                                     BITCODE_BL size);\n\nstatic int dwg_decode_eed (Bit_Chain *restrict dat,\n                           Dwg_Object_Object *restrict obj);\nstatic int dwg_decode_ole2 (Dwg_Entity_OLE2FRAME *restrict _obj);\n\nstatic int dwg_decode_object (Bit_Chain *dat, Bit_Chain *hdl_dat,\n                              Bit_Chain *str_dat,\n                              Dwg_Object_Object *restrict obj);\n\nstatic int dwg_decode_entity (Bit_Chain *dat, Bit_Chain *hdl_dat,\n                              Bit_Chain *str_dat,\n                              Dwg_Object_Entity *restrict ent);\nstatic int dwg_decode_common_entity_handle_data (Bit_Chain *dat,\n                                                 Bit_Chain *hdl_dat,\n                                                 Dwg_Object *restrict obj);\n\nstatic const char *dwg_ref_objname (const Dwg_Data *restrict dwg,\n                                    Dwg_Object_Ref *restrict ref);\nstatic const char *dwg_ref_tblname (const Dwg_Data *restrict dwg,\n                                    Dwg_Object_Ref *restrict ref);\n\n/*----------------------------------------------------------------------------\n * Public variables\n */\n// long unsigned int ktl_lastaddress;\n\n/*----------------------------------------------------------------------------\n * Public function definitions\n */\n\n/** dwg_decode\n * returns 0 on success.\n *\n * everything in dwg is cleared\n * and then either read from dat, or set to a default.\n */\nint\ndwg_decode (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)\n{\n  int i;\n  char version[7];\n\n  dwg->num_object_refs = 0;\n  // dwg->num_layers = 0; // see now dwg->layer_control->num_entries\n  dwg->num_entities = 0;\n  dwg->num_objects = 0;\n  dwg->num_classes = 0;\n  dwg->thumbnail.size = 0;\n  dwg->thumbnail.chain = NULL;\n  dwg->header.num_sections = 0;\n  dwg->header.section_infohdr.num_desc = 0;\n  dwg->dwg_class = NULL;\n  dwg->object_ref = NULL;\n  dwg->object = NULL;\n  dwg->object_map = hash_new (dat->size / 1000);\n  if (!dwg->object_map)\n    {\n      // whatever, we are obviously on a tiny system\n      dwg->object_map = hash_new (1024);\n      if (!dwg->object_map)\n        {\n          LOG_ERROR (\"Out of memory\");\n          return DWG_ERR_OUTOFMEM;\n        }\n    }\n  dwg->dirty_refs = 1;\n\n  // memset (&dwg->header, 0, sizeof (dwg->header)); // nope. needed for\n  // version\n  memset (&dwg->header_vars, 0, sizeof (dwg->header_vars));\n  memset (&dwg->summaryinfo, 0, sizeof (dwg->summaryinfo));\n  memset (&dwg->r2004_header.file_ID_string[0], 0, sizeof (dwg->r2004_header));\n  memset (&dwg->auxheader.aux_intro[0], 0, sizeof (dwg->auxheader));\n  memset (&dwg->second_header, 0, sizeof (dwg->second_header));\n\n  if (dwg->opts)\n    {\n      loglevel = dwg->opts & DWG_OPTS_LOGLEVEL;\n      dat->opts = dwg->opts;\n    }\n\n#ifdef USE_TRACING\n  /* Before starting, set the logging level, but only do so once.  */\n  if (!env_var_checked_p)\n    {\n      char *probe = getenv (\"LIBREDWG_TRACE\");\n      if (probe)\n        loglevel = atoi (probe);\n      env_var_checked_p = true;\n    }\n#endif /* USE_TRACING */\n\n  /* Version */\n  dat->byte = 0;\n  dat->bit = 0;\n  if (!dat->chain || dat->size < 58)\n    {\n      LOG_ERROR (\"dwg too small: %lu bytes\", dat->size);\n      return DWG_ERR_INVALIDDWG;\n    }\n  strncpy (version, (const char *)dat->chain, 6);\n  version[6] = '\\0';\n\n  dwg->header.version = 0;\n  for (i = 0; i < R_AFTER; i++)\n    {\n      if (strEQ (version, version_codes[(Dwg_Version_Type)i]))\n        {\n          dwg->header.version = (Dwg_Version_Type)i;\n          break;\n        }\n    }\n  if (!dwg->header.version)\n    {\n      if (strncmp (version, \"AC\", 2)) // let's ignore MC0.0 for now\n        {\n          LOG_ERROR (\"Invalid DWG, magic: %s\", version);\n        }\n      else\n        {\n          LOG_ERROR (\"Invalid or unimplemented DWG version code %s\", version);\n        }\n      return DWG_ERR_INVALIDDWG;\n    }\n  dat->version = dwg->header.version;\n  dwg->header.from_version = dat->version;\n  dat->from_version = dat->version;\n  LOG_INFO (\"This file's version code is: %s (%s)\\n\", version,\n            dwg_version_type(dat->version))\n\n#define WE_CAN                                                                \\\n  \"This version of LibreDWG is only capable of decoding \"                     \\\n  \"version R13-R2018 (code: AC1012-AC1032) DWG files.\\n\"\n\n  PRE (R_13)\n  {\n    LOG_ERROR (WE_CAN \"We don't decode many entities and no blocks yet.\")\n#ifndef IS_RELEASE\n    return decode_preR13 (dat, dwg);\n#endif\n  }\n\n  VERSIONS (R_13, R_2000) { return decode_R13_R2000 (dat, dwg); }\n  VERSION (R_2004) { return decode_R2004 (dat, dwg); }\n  VERSION (R_2007) { return decode_R2007 (dat, dwg); }\n  SINCE (R_2010)\n  {\n    read_r2007_init (dwg);\n    return decode_R2004 (dat, dwg);\n  }\n\n  // This line should not be reached\n  LOG_ERROR (\"LibreDWG does not support this version: %s.\", version)\n  return DWG_ERR_INVALIDDWG;\n}\n\n// We put the 3x 10 table fields into sections.\n// number is the number of elements in the table. >=r13 it is the id.\nstatic void\ndecode_preR13_section_ptr (const char *restrict name, Dwg_Section_Type_r11 id,\n                           Bit_Chain *restrict dat, Dwg_Data *restrict dwg)\n{\n  Dwg_Section *tbl = &dwg->header.section[id];\n  tbl->size = bit_read_RS (dat);\n  tbl->number = bit_read_RL (dat);\n  tbl->address = bit_read_RL (dat);\n  strncpy (tbl->name, name, 63);\n  LOG_TRACE (\"ptr table %-8s [%2d]: size:%-4u nr:%-2ld (0x%lx-0x%lx)\\n\",\n             tbl->name, id, tbl->size, (long)tbl->number, (unsigned long)tbl->address,\n             (unsigned long)(tbl->address + (unsigned long)(tbl->number * tbl->size)))\n}\n\nstatic void\ndecode_preR13_section_chk (Dwg_Section_Type_r11 id, Bit_Chain *restrict dat,\n                           Dwg_Data *restrict dwg)\n{\n  Dwg_Section *tbl = &dwg->header.section[id];\n\n#define CMP(f, type)                                                          \\\n  if (tbl->f != f)                                                            \\\n  LOG_ERROR (\"decode_preR13_section_chk %s %s\", tbl->name, #f)\n\n  // LOG_ERROR(name \"->\" #f \" \" FORMAT_##type \" != \" #f \" \" FORMAT_##type)\n  BITCODE_RS id1, size;\n  BITCODE_RL address;\n  BITCODE_RLd number;\n  id1 = bit_read_RS (dat);\n  size = bit_read_RS (dat);\n  CMP (size, RS);\n  number = (BITCODE_RLd)bit_read_RS (dat);\n  CMP (number, RL);\n  address = bit_read_RL (dat);\n  CMP (address, RL)\n#undef CMP\n  LOG_TRACE (\"chk table %-8s [%2d]: size:%-4u nr:%-3ld (0x%x)\\n\", tbl->name,\n             id, size, (long)tbl->number, address)\n}\n\nGCC30_DIAG_IGNORE (-Wformat-nonliteral)\n// TABLES really\nstatic int\ndecode_preR13_section (Dwg_Section_Type_r11 id, Bit_Chain *restrict dat,\n                       Dwg_Data *restrict dwg)\n{\n  Dwg_Section *tbl = &dwg->header.section[id];\n  int i;\n  BITCODE_BL vcount;\n  int error = 0;\n  long unsigned int num = dwg->num_objects;\n  long unsigned int old_size = num * sizeof (Dwg_Object);\n  long unsigned int size = tbl->number * sizeof (Dwg_Object);\n  long unsigned int pos;\n\n  if ((unsigned)tbl->number > 100000 || size > dat->size)\n    {\n      LOG_ERROR (\"Invalid table number %ld for %-8s [%2d]\", (long)tbl->number, tbl->name, id);\n      return DWG_ERR_INVALIDDWG;\n    }\n  LOG_TRACE (\"\\ncontents table %-8s [%2d]: size:%-4u nr:%-3ld (0x%lx-0x%lx)\\n\",\n             tbl->name, id, tbl->size, (long)tbl->number, (unsigned long)tbl->address,\n             (unsigned long)(tbl->address + ((unsigned long long)tbl->number * tbl->size)))\n  dat->byte = tbl->address;\n  if ((unsigned long)(tbl->number * tbl->size) > dat->size - dat->byte)\n    {\n      LOG_ERROR (\"Invalid table number %ld or size %ld for %-8s [%2d]\", (long)tbl->number, (long)tbl->size,\n                 tbl->name, id);\n      return DWG_ERR_INVALIDDWG;\n    }\n  if (dwg->num_objects % REFS_PER_REALLOC == 0)\n    dwg->object = realloc (dwg->object, old_size + size + REFS_PER_REALLOC);\n\n    // TODO: move to a spec dwg_r11.spec, and dwg_decode_r11_NAME\n#define PREP_TABLE(token)                                                     \\\n  Dwg_Object *obj = &dwg->object[num + i];                                    \\\n  Dwg_Object_##token *_obj = calloc (1, sizeof (Dwg_Object_##token));         \\\n  if (dat->byte > dat->size)                                                  \\\n    {                                                                         \\\n      free (_obj);                                                            \\\n      return DWG_ERR_INVALIDDWG;                                              \\\n    }                                                                         \\\n  obj->index = num + i;                                                       \\\n  obj->tio.object = calloc (1, sizeof (Dwg_Object_Object));                   \\\n  if (!_obj || !obj->tio.object)                                              \\\n    if (_obj) free (_obj);                                                    \\\n    return DWG_ERR_OUTOFMEM;                                                  \\\n  obj->tio.object->tio.token = _obj;                                          \\\n  obj->tio.object->objid = obj->index;                                        \\\n  obj->supertype = DWG_SUPERTYPE_OBJECT;                                      \\\n  obj->parent = dwg;                                                          \\\n  obj->name = obj->dxfname = (char *)#token;                                  \\\n  obj->type = obj->fixedtype = DWG_TYPE_##token;                              \\\n  _obj->parent = obj->tio.object;                                             \\\n  obj->tio.object->dwg = obj->parent;                                         \\\n  obj->tio.object->objid = obj->index; /* obj ptr itself might move */        \\\n  LOG_TRACE (\"\\n-- table entry \" #token \" [%d]:\\n\", i)\n\n#define CHK_ENDPOS                                                            \\\n  pos = tbl->address + ((long)(i + 1) * tbl->size);                           \\\n  if ((long)(pos - dat->byte) != 2)                                           \\\n    {                                                                         \\\n      LOG_WARN (\"offset %ld\", pos - dat->byte);                               \\\n    }                                                                         \\\n  dat->byte = pos\n\n  switch (id)\n    {\n\n    case SECTION_BLOCK:\n      for (i = 0; i < tbl->number; i++)\n        {\n          PREP_TABLE (BLOCK_HEADER);\n          // TODO DXF 8: layer name\n          FIELD_RC (flag, 70);\n          FIELD_TF (name, 32, 2);\n          FIELD_RS (used, 0);\n\n          // TODO RD elevation 30, 2RD base_pt 10: 24\n          FIELD_RC (block_scaling, 0);\n          FIELD_CAST (num_owned, RS, BL, 0);\n          FIELD_RC (flag2, 0);\n          FIELD_CAST (num_inserts, RS, RL, 0);\n          FIELD_RS (flag3, 0);\n          CHK_ENDPOS;\n        }\n      break;\n\n    case SECTION_LAYER:\n      for (i = 0; i < tbl->number; i++)\n        {\n          PREP_TABLE (LAYER);\n\n          FIELD_CAST (flag, RC, RS, 70); // 860\n          FIELD_TF (name, 32, 2);\n          FIELD_RS (used, 0);\n\n          FIELD_RS (color_rs, 62); // color, off if negative\n          FIELD_RS (ltype_rs, 6);  // style\n          // FIELD_RS (crc, 0);\n          CHK_ENDPOS;\n        }\n      break;\n\n    // was a text STYLE table, became a STYLE object\n    case SECTION_STYLE:\n      for (i = 0; i < tbl->number; i++)\n        {\n          PREP_TABLE (STYLE);\n\n          FIELD_RC (flag, 70);\n          FIELD_TF (name, 32, 2);\n          FIELD_RS (used, 0);\n\n          FIELD_RD (fixed_height, 40); // ok\n          FIELD_RD (width_factor, 41);\n          FIELD_RD (oblique_ang, 50);\n          FIELD_RC (generation, 71);\n          FIELD_RD (last_height, 42);\n          FIELD_TF (font_name, 64, 3);    // 8ed\n          FIELD_TF (bigfont_name, 64, 4); // 92d\n          CHK_ENDPOS;\n        }\n      break;\n\n    case SECTION_LTYPE:\n      for (i = 0; i < tbl->number; i++)\n        {\n          PREP_TABLE (LTYPE);\n\n          FIELD_RC (flag, 70);\n          FIELD_TF (name, 32, 2);\n          FIELD_RS (used, 0);\n          FIELD_TF (description, 48, 3);\n          FIELD_RC (alignment, 72);\n          FIELD_RC (num_dashes, 73);\n          FIELD_VECTOR (dashes_r11, RD, num_dashes, 340);\n          // ... 106 byte\n          // 3, 40, 49, 74, 75, 340, 46, 50, 44, 45, 9\n\n          CHK_ENDPOS;\n        }\n      break;\n\n    case SECTION_VIEW:\n      for (i = 0; i < tbl->number; i++)\n        {\n          PREP_TABLE (VIEW);\n\n          FIELD_RC (flag, 70);\n          FIELD_TF (name, 32, 2);\n          FIELD_RS (used, 0);\n\n          FIELD_RD (height, 40);\n          FIELD_2RD (center, 10);\n          FIELD_RD (width, 41);\n          FIELD_3RD (target, 12);\n          FIELD_3RD (direction, 11);\n          FIELD_CAST (VIEWMODE, RS, 4BITS, 71);\n          FIELD_RD (lens_length, 42);\n          FIELD_RD (front_clip, 43);\n          FIELD_RD (back_clip, 44);\n          FIELD_RD (twist_angle, 50);\n          CHK_ENDPOS;\n        }\n      break;\n\n    case SECTION_UCS:\n      for (i = 0; i < tbl->number; i++)\n        {\n          PREP_TABLE (UCS);\n\n          FIELD_RC (flag, 70);\n          FIELD_TF (name, 32, 2);\n          FIELD_RS (used, 0);\n          FIELD_2RD (origin, 10);\n          FIELD_2RD (x_direction, 11);\n          FIELD_2RD (y_direction, 12);\n\n          CHK_ENDPOS;\n        }\n      break;\n\n    case SECTION_VPORT:\n      for (i = 0; i < tbl->number; i++)\n        {\n          PREP_TABLE (VPORT);\n\n          FIELD_RC (flag, 70);\n          FIELD_TF (name, 32, 2);\n          FIELD_RS (used, 0);\n\n          FIELD_RD (VIEWSIZE, 40);\n          FIELD_RD (aspect_ratio, 41);\n          FIELD_2RD (VIEWCTR, 12);\n          FIELD_3RD (view_target, 17);\n          FIELD_3RD (VIEWDIR, 16);\n          FIELD_RD (view_twist, 50);\n          FIELD_RD (lens_length, 42);\n          FIELD_RD (front_clip, 43);\n          FIELD_RD (back_clip, 33);\n          FIELD_CAST (VIEWMODE, RS, 4BITS, 71);\n\n          FIELD_2RD (lower_left, 10);\n          FIELD_2RD (upper_right, 11);\n          FIELD_RC (UCSFOLLOW, 71);\n          FIELD_RS (circle_zoom, 72);\n          FIELD_RC (FASTZOOM, 73);\n          FIELD_RC (UCSICON, 74);\n          FIELD_RC (GRIDMODE, 76);\n          FIELD_2RD (GRIDUNIT, 15);\n          FIELD_CAST (SNAPMODE, RS, B, 70); // 75\n          FIELD_RC (SNAPSTYLE, 70);         // 77\n          FIELD_RS (SNAPISOPAIR, 78);\n          FIELD_RD (SNAPANG, 50);\n          FIELD_2RD (SNAPBASE, 13);\n          FIELD_2RD (SNAPUNIT, 14);\n          // ... 74 byte\n\n          CHK_ENDPOS;\n        }\n      break;\n\n    case SECTION_APPID:\n      for (i = 0; i < tbl->number; i++)\n        {\n          PREP_TABLE (APPID);\n\n          FIELD_RC (flag, 70);\n          FIELD_TF (name, 32, 2);\n          FIELD_RS (used, 0);\n          CHK_ENDPOS;\n        }\n      break;\n\n    case SECTION_DIMSTYLE:\n      for (i = 0; i < tbl->number; i++)\n        {\n          // unsigned long off;\n          PREP_TABLE (DIMSTYLE); // d1f\n\n          FIELD_RC (flag, 70);\n          FIELD_TF (name, 32, 2);\n          // off = dat->byte;\n          FIELD_RS (used, 0);      // d40\n          FIELD_RD (DIMSCALE, 40); // d42\n          FIELD_RD (DIMASZ, 41);\n          FIELD_RD (DIMEXO, 42);\n          FIELD_RD (DIMDLI, 43);\n          FIELD_RD (DIMEXE, 44);\n          FIELD_RD (DIMRND, 45);\n          FIELD_RD (DIMDLE, 46);\n          FIELD_RD (DIMTP, 47);\n          FIELD_RD (DIMTM, 48); // ok\n          FIELD_RD (DIMTXT, 140);\n          FIELD_RD (DIMCEN, 141); // ok\n          FIELD_RD (DIMTSZ, 142);\n          FIELD_RD (DIMALTF, 143);\n          FIELD_RD (DIMLFAC, 144);\n          FIELD_RD (DIMTVP, 145); // db2\n          FIELD_RC (DIMTOL, 71);  // dba\n          FIELD_RC (DIMLIM, 72);  // dbb\n          FIELD_RC (DIMTIH, 73);\n          FIELD_RC (DIMTOH, 74);\n          FIELD_RC (DIMSE1, 75);\n          FIELD_RC (DIMSE2, 76);\n          FIELD_CAST (DIMTAD, RC, RS, 77); // ok\n          FIELD_CAST (DIMZIN, RC, BS, 78); // dc1\n          FIELD_RC (DIMALT, 170);\n          FIELD_CAST (DIMALTD, RC, BS, 171); // ok\n          FIELD_RC (DIMTOFL, 172);           // ok\n          FIELD_RC (DIMSAH, 173);            // ok\n          FIELD_RC (DIMTIX, 174);            // ok\n          FIELD_RC (DIMSOXD, 175);           // ok\n          FIELD_TF (DIMPOST, 16, 3);         // ok dc8\n          FIELD_TF (DIMAPOST, 16, 4);        // dd8\n          FIELD_TF (DIMBLK_T, 16, 5);        //?? unsupported by ODA\n          FIELD_TF (DIMBLK1_T, 16, 6);       //?? unsupported by ODA\n          FIELD_TF (DIMBLK2_T, 66, 7);       //?? unsupported by ODA\n          // DEBUG_HERE; //e18\n          // dat->byte += 50; //unknown: DIMSHO, DIMASO (global)\n          FIELD_RS (DIMCLRD_N, 176); // e4a\n          FIELD_RS (DIMCLRE_N, 177);\n          FIELD_RS (DIMCLRT_N, 178); // e4e\n          FIELD_RC (DIMUPT, 0);      //??\n          FIELD_RD (DIMTFAC, 146);   // e51\n          FIELD_RD (DIMGAP, 147);    // e59\n          CHK_ENDPOS;                //-e63\n        }\n      break;\n\n    case SECTION_VPORT_ENTITY:\n      if (tbl->number)\n        {\n          LOG_WARN (\"VPORT_ENTITY table\");\n        }\n      break;\n\n    case SECTION_HEADER_R11:\n    default:\n      LOG_ERROR (\"Invalid table id %d\", id);\n      tbl->number = 0;\n      break;\n    }\n  dwg->num_objects += tbl->number;\n  dat->byte = tbl->address + (tbl->number * tbl->size);\n  return error;\n}\n\nstatic int\ndecode_entity_preR13 (Bit_Chain *restrict dat, Dwg_Object *restrict obj,\n                      Dwg_Object_Entity *ent)\n{\n  Dwg_Object_Entity *_obj = ent;\n\n  obj->type = bit_read_RC (dat);\n  _obj->flag_r11 = bit_read_RC (dat); // dxf 70\n  obj->size = bit_read_RS (dat);\n  LOG_INFO (\"\\n===========================\\n\"\n            \"Entity number: %d, Type: %d, Size: %d\\n\",\n            obj->index, obj->type, obj->size);\n  LOG_TRACE (\"flag_r11: \" FORMAT_RC \"\\n\", _obj->flag_r11);\n  FIELD_RS (layer_r11, 8);\n  FIELD_RS (opts_r11, 0);\n  // LOG_TRACE(\"Layer: %d, Opts: 0x%x\\n\", ent->layer_r11, ent->opts_r11)\n  if (ent->flag_r11 & 1)\n    {\n      FIELD_RC (color_r11, 0);\n    }\n  if (ent->flag_r11 & 0x40)\n    {\n      FIELD_RC (extra_r11, 0);\n    }\n  /* Common entity preR13 header: */\n  if (ent->extra_r11 & 2)\n    {\n      int error = dwg_decode_eed (dat, (Dwg_Object_Object *)ent);\n      if (error & (DWG_ERR_INVALIDEED | DWG_ERR_VALUEOUTOFBOUNDS))\n        return error;\n    }\n  if (FIELD_VALUE (flag_r11) & 2)\n    FIELD_RS (kind_r11, 0);\n\n  return 0;\n}\n\nstatic int\ndecode_preR13 (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)\n{\n  BITCODE_RL entities_start, entities_end, blocks_start, blocks_end;\n  BITCODE_RL rl1, rl2;\n  BITCODE_RS rs2;\n  Dwg_Object *obj = NULL;\n  int tbl_id;\n  int error = 0;\n\n  {\n    int i;\n    struct Dwg_Header *_obj = &dwg->header;\n    Bit_Chain *hdl_dat = dat;\n    dat->byte = 0x06;\n    // clang-format off\n    #include \"header.spec\"\n    // clang-format on\n  }\n  LOG_TRACE (\"@0x%lx\\n\", dat->byte); // 0x14\n\n  // tables really\n  dwg->header.num_sections = 12;\n  dwg->header.section = (Dwg_Section *)calloc (\n      1, sizeof (Dwg_Section) * dwg->header.num_sections);\n  if (!dwg->header.section)\n    {\n      LOG_ERROR (\"Out of memory\");\n      return DWG_ERR_OUTOFMEM;\n    }\n\n  entities_start = bit_read_RL (dat);\n  entities_end = bit_read_RL (dat);\n  LOG_TRACE (\"entities 0x%x - 0x%x\\n\", entities_start, entities_end);\n  blocks_start = bit_read_RL (dat);\n  rl1 = bit_read_RL (dat); // 0x40\n  blocks_end = bit_read_RL (dat);\n  rl2 = bit_read_RL (dat); // 0x80\n  LOG_TRACE (\"blocks   0x%x (0x%x) - 0x%x (0x%x)\\n\", blocks_start, rl1,\n             blocks_end, rl2);\n\n  tbl_id = 0;\n  dwg->header.section[0].number = 0;\n  dwg->header.section[0].type = (Dwg_Section_Type)SECTION_HEADER_R11;\n  strcpy (dwg->header.section[0].name, \"HEADER\");\n\n  decode_preR13_section_ptr (\"BLOCK\", SECTION_BLOCK, dat, dwg);\n  decode_preR13_section_ptr (\"LAYER\", SECTION_LAYER, dat, dwg);\n  decode_preR13_section_ptr (\"STYLE\", SECTION_STYLE, dat, dwg);\n  // skip one\n  decode_preR13_section_ptr (\"LTYPE\", SECTION_LTYPE, dat, dwg);\n  decode_preR13_section_ptr (\"VIEW\", SECTION_VIEW, dat, dwg);\n\n  if (dwg->header.section[SECTION_BLOCK].size > dat->size)\n    {\n      LOG_ERROR (\"BLOCK.size overflow\")\n      return DWG_ERR_INVALIDDWG;\n    }\n  LOG_TRACE (\"@0x%lx\\n\", dat->byte); // 0x5e\n  {\n    Dwg_Header_Variables *_obj = &dwg->header_vars;\n    Bit_Chain *hdl_dat = dat;\n    // clang-format off\n    #include \"header_variables_r11.spec\"\n    // clang-format on\n  }\n  LOG_TRACE (\"@0x%lx\\n\", dat->byte); // 0x23a\n\n  dat->byte = 0x3ef;\n  LOG_TRACE (\"@0x%lx\\n\", dat->byte);\n  decode_preR13_section_ptr (\"UCS\", SECTION_UCS, dat, dwg);\n  // skip: 0x500 - dat->bytes\n  dat->byte = 0x500;\n  LOG_TRACE (\"@0x%lx\\n\", dat->byte); // 0x23a\n  decode_preR13_section_ptr (\"VPORT\", SECTION_VPORT, dat, dwg);\n  rl1 = bit_read_RL (dat);\n  rl2 = bit_read_RL (dat);\n  LOG_TRACE (\"?2 long: 0x%x 0x%x\\n\", rl1, rl2);\n  decode_preR13_section_ptr (\"APPID\", SECTION_APPID, dat, dwg);\n  rl1 = bit_read_RL (dat);\n  rs2 = bit_read_RS (dat);\n  LOG_TRACE (\"?long+short: 0x%x 0x%x\\n\", rl1, (unsigned)rs2);\n  decode_preR13_section_ptr (\"DIMSTYLE\", SECTION_DIMSTYLE, dat, dwg);\n  // skip: 0x69f - dat->bytes\n  dat->byte = 0x69f;\n  decode_preR13_section_ptr (\"VPORT_ENTITY\", SECTION_VPORT_ENTITY, dat, dwg);\n  dat->byte += 38;\n  // entities\n  error |= decode_preR13_entities (entities_start, entities_end, 0, dat, dwg);\n  if (error >= DWG_ERR_CRITICAL)\n    return error;\n  dat->byte += 19; /* crc + sentinel? */\n  error |= decode_preR13_section (SECTION_BLOCK, dat, dwg);\n  error |= decode_preR13_section (SECTION_LAYER, dat, dwg);\n  error |= decode_preR13_section (SECTION_STYLE, dat, dwg);\n  error |= decode_preR13_section (SECTION_LTYPE, dat, dwg);\n  error |= decode_preR13_section (SECTION_VIEW, dat, dwg);\n  error |= decode_preR13_section (SECTION_UCS, dat, dwg);\n  error |= decode_preR13_section (SECTION_VPORT, dat, dwg);\n  error |= decode_preR13_section (SECTION_APPID, dat, dwg);\n  error |= decode_preR13_section (SECTION_DIMSTYLE, dat, dwg);\n  error |= decode_preR13_section (SECTION_VPORT_ENTITY, dat, dwg);\n  if (error >= DWG_ERR_CRITICAL)\n    return error;\n  // blocks\n  error |= decode_preR13_entities (blocks_start, blocks_end, blocks_start - 0x40000000,\n                          dat, dwg);\n  if (error >= DWG_ERR_CRITICAL)\n    return error;\n  LOG_TRACE (\"@0x%lx\\n\", dat->byte);\n  // 36 byte: 9x long\n  rl1 = bit_read_RL (dat);\n  rl2 = bit_read_RL (dat);\n  LOG_TRACE (\"?2long: 0x%x 0x%x %f\\n\", rl1, rl2,\n             (double)dat->chain[dat->byte - 8]);\n  rl1 = bit_read_RL (dat);\n  rl2 = bit_read_RL (dat);\n  LOG_TRACE (\"?2long: 0x%x 0x%x %f\\n\", rl1, rl2,\n             (double)dat->chain[dat->byte - 8]);\n  rl1 = bit_read_RL (dat);\n  rl2 = bit_read_RL (dat);\n  LOG_TRACE (\"?2long: 0x%x 0x%x %f\\n\", rl1, rl2,\n             (double)dat->chain[dat->byte - 8]);\n  rl1 = bit_read_RL (dat);\n  rl2 = bit_read_RL (dat);\n  LOG_TRACE (\"?2long: 0x%x 0x%x %f\\n\", rl1, rl2,\n             (double)dat->chain[dat->byte - 8]);\n  rl1 = bit_read_RL (dat);\n  LOG_TRACE (\"?1long: 0x%x\\n\", rl1);\n\n  LOG_TRACE (\"@0x%lx: 4 block ptrs chk\\n\", dat->byte);\n  if ((rl1 = bit_read_RL (dat)) != entities_start)\n    {\n      LOG_WARN (\"entities_start %x/%x\", rl1, entities_start);\n    }\n  if ((rl1 = bit_read_RL (dat)) != entities_end)\n    {\n      LOG_WARN (\"entities_end %x/%x\", rl1, entities_end);\n    }\n  if ((rl1 = bit_read_RL (dat)) != blocks_start)\n    {\n      LOG_WARN (\"blocks_start %x/%x\", rl1, blocks_start);\n    }\n  if ((rl1 = bit_read_RL (dat)) != blocks_end)\n    {\n      LOG_WARN (\"blocks_end %x/%x\", rl1, blocks_end);\n    }\n  // 12 byte\n  LOG_TRACE (\"@0x%lx\\n\", dat->byte);\n  rl1 = bit_read_RL (dat);\n  rl2 = bit_read_RL (dat);\n  LOG_TRACE (\"?2long: 0x%x 0x%x\\n\", rl1, rl2);\n  rl1 = bit_read_RL (dat);\n  LOG_TRACE (\"?1long: 0x%x\\n\", rl1);\n\n  dat->byte = blocks_end + 36 + 4 * 4 + 12;\n  LOG_TRACE (\"@0x%lx\\n\", dat->byte);\n  decode_preR13_section_chk (SECTION_BLOCK, dat, dwg);\n  decode_preR13_section_chk (SECTION_LAYER, dat, dwg);\n  decode_preR13_section_chk (SECTION_STYLE, dat, dwg);\n  decode_preR13_section_chk (SECTION_LTYPE, dat, dwg);\n  decode_preR13_section_chk (SECTION_VIEW, dat, dwg);\n  decode_preR13_section_chk (SECTION_UCS, dat, dwg);\n  decode_preR13_section_chk (SECTION_VPORT, dat, dwg);\n  decode_preR13_section_chk (SECTION_APPID, dat, dwg);\n  decode_preR13_section_chk (SECTION_DIMSTYLE, dat, dwg);\n  decode_preR13_section_chk (SECTION_VPORT_ENTITY, dat, dwg);\n  rl1 = bit_read_RL (dat);\n  LOG_TRACE (\"long 0x%x\\n\", rl1); // address\n\n  return 0;\n}\n\n/* ODA 3.2.6 SECTION-LOCATOR RECORDS: p.21\n   This is an ODA calculation mistake, it's not needed at all.\n\nstatic BITCODE_RS\nxor_section_CRC (BITCODE_RL num_sections, BITCODE_RS crc)\n{\n  switch (num_sections)\n    {\n    case 3:\n      crc ^= 0xA598;\n      break;\n    case 4:\n      crc ^= 0x8101;\n      break;\n    case 5:\n      crc ^= 0x3CC4;\n      break;\n    case 6:\n      crc ^= 0x8461;\n      break;\n    default:\n      LOG_WARN (\"Unknown num_sections \" FORMAT_RL \", wrong Section CRC\",\n                num_sections);\n    }\n  return crc;\n}\n*/\n\nstatic int\ndecode_R13_R2000 (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)\n{\n  Dwg_Object *obj = NULL;\n  unsigned int section_size = 0;\n  unsigned char sgdc[2];\n  unsigned int crc, crc2;\n  long unsigned int size;\n  long unsigned int lasta;\n  long unsigned int lastmap;\n  long unsigned int startpos;\n  long unsigned int object_begin;\n  long unsigned int object_end;\n  long unsigned int pvz;\n  BITCODE_BL j, k;\n  int error = 0;\n  const char *section_names[]\n      = { \"AcDb:Header\", \"AcDb:Classes\", \"AcDb:Handles\",\n          \"2NDHEADER\",   \"MEASUREMENT\",  \"AcDb:AuxHeader\" };\n\n  {\n    int i;\n    struct Dwg_Header *_obj = &dwg->header;\n    Bit_Chain *hdl_dat = dat;\n    dat->byte = 0x06;\n    // clang-format off\n    #include \"header.spec\"\n    // clang-format on\n  }\n\n  /* Section Locator Records 0x15 */\n  assert (dat->byte == 0x15);\n  dwg->header.num_sections = bit_read_RL (dat);\n  LOG_TRACE (\"\\nnum_sections: \" FORMAT_RL \" [RL]\\n\", dwg->header.num_sections)\n  if (!dwg->header.num_sections) // ODA writes zeros.\n    dwg->header.num_sections = 6;\n  if (dwg->header.num_sections < 3)\n    {\n      LOG_ERROR (\"Not enough sections: \" FORMAT_RL, dwg->header.num_sections);\n      return DWG_ERR_INVALIDDWG;\n    }\n  if (dwg->header.num_sections > 10)\n    {\n      LOG_ERROR (\"Too many sections: \" FORMAT_RL, dwg->header.num_sections);\n      return DWG_ERR_INVALIDDWG;\n    }\n\n  // So far seen 3-6 sections. Most emit only 3-5 sections.\n  dwg->header.section = (Dwg_Section *)calloc (\n      1, sizeof (Dwg_Section) * dwg->header.num_sections);\n  if (!dwg->header.section)\n    {\n      LOG_ERROR (\"Out of memory\");\n      return DWG_ERR_OUTOFMEM;\n    }\n  /* section 0: header vars\n   *         1: class section\n   *         2: object map\n   *         3: (R13 c3 and later): 2nd header (special table, no sentinels)\n   *         4: optional: MEASUREMENT\n   *         5: optional: AuxHeader (no sentinels)\n   */\n  for (j = 0; j < dwg->header.num_sections; j++)\n    {\n      dwg->header.section[j].number = bit_read_RC (dat);\n      dwg->header.section[j].address = bit_read_RL (dat);\n      dwg->header.section[j].size = bit_read_RL (dat);\n      if (j < 6)\n        strcpy (dwg->header.section[j].name, section_names[j]);\n      LOG_TRACE (\"section[%u].number:  %4d [RC] %s\\n\", j,\n                 (int)dwg->header.section[j].number, dwg->header.section[j].name)\n      LOG_TRACE (\"section[%u].address: %4u [RL]\\n\", j,\n                 (unsigned)dwg->header.section[j].address)\n      LOG_TRACE (\"section[%u].size:    %4u [RL]\\n\", j,\n                 (unsigned)dwg->header.section[j].size);\n      if (dwg->header.section[j].address + dwg->header.section[j].size > dat->size)\n        {\n          LOG_ERROR (\"section[%u] address or size overflow\", j);\n          return DWG_ERR_INVALIDDWG;\n        }\n    }\n\n  // Check CRC up to now (note: ODA has a bug here)\n  crc2 = bit_calc_CRC (0xC0C1, &dat->chain[0], dat->byte); // from 0 to now\n  crc = bit_read_RS (dat);\n  LOG_TRACE (\"crc: %04X [RSx] from 0-%lu\\n\", crc, dat->byte - 2);\n  if (crc != crc2)\n    {\n      LOG_ERROR (\"Header CRC mismatch %04X <=> %04X\", crc, crc2);\n      error |= DWG_ERR_WRONGCRC;\n    }\n\n  if (bit_search_sentinel (dat, dwg_sentinel (DWG_SENTINEL_HEADER_END)))\n    LOG_TRACE (\"         HEADER (end):    %4u\\n\", (unsigned)dat->byte)\n\n  /*-------------------------------------------------------------------------\n   * Section 5 AuxHeader\n   * R2000+, mostly redundant file header information\n   */\n\n  if (dwg->header.num_sections == 6 && dwg->header.version >= R_2000)\n    {\n      int i;\n      struct Dwg_AuxHeader *_obj = &dwg->auxheader;\n      Bit_Chain *hdl_dat = dat;\n      BITCODE_BL end_address\n          = dwg->header.section[SECTION_AUXHEADER_R2000].address\n            + dwg->header.section[SECTION_AUXHEADER_R2000].size;\n\n      obj = NULL;\n      dat->byte = dwg->header.section[SECTION_AUXHEADER_R2000].address;\n      LOG_TRACE (\"\\n\"\n                 \"=======> AuxHeader:       %4u\\n\", (unsigned)dat->byte)\n      LOG_TRACE (\"         AuxHeader (end): %4u\\n\", (unsigned)end_address)\n      if (dat->size < end_address)\n        {\n          LOG_ERROR (\"Invalid AuxHeader size: buffer overflow\")\n          error |= DWG_ERR_SECTIONNOTFOUND;\n        }\n      else\n        {\n          BITCODE_BL old_size = dat->size;\n          dat->size = end_address;\n          // clang-format off\n          #include \"auxheader.spec\"\n          // clang-format on\n          dat->size = old_size;\n        }\n    }\n\n  /*-------------------------------------------------------------------------\n   * Picture (Pre-R13C3?)\n   */\n\n  if (bit_search_sentinel (dat, dwg_sentinel (DWG_SENTINEL_THUMBNAIL_BEGIN)))\n    {\n      unsigned long int start_address;\n\n      dat->bit = 0;\n      start_address = dat->byte;\n      LOG_TRACE (\"\\n=======> Thumbnail:       %4u\\n\", (unsigned int)start_address - 16);\n      if (dwg->header.thumbnail_address\n          && dwg->header.thumbnail_address != dat->byte - 16)\n        LOG_WARN (\"Illegal HEADER.thumbnail_address: %i != %lu\",\n                  dwg->header.thumbnail_address, dat->byte - 16)\n      dwg->header.thumbnail_address = dat->byte - 16;\n      if (bit_search_sentinel (dat, dwg_sentinel (DWG_SENTINEL_THUMBNAIL_END)))\n        {\n          BITCODE_RL bmpsize;\n          LOG_TRACE (\"         Thumbnail (end): %4u\\n\",\n                     (unsigned int)dat->byte)\n          dwg->thumbnail.size = (dat->byte - 16) - start_address;\n          dwg->thumbnail.chain\n              = (unsigned char *)calloc (dwg->thumbnail.size, 1);\n          if (!dwg->thumbnail.chain)\n            {\n              LOG_ERROR (\"Out of memory\");\n              return DWG_ERR_OUTOFMEM;\n            }\n          memcpy (dwg->thumbnail.chain, &dat->chain[start_address],\n                  dwg->thumbnail.size);\n          dat->byte += dwg->thumbnail.size;\n\n          dwg_bmp (dwg, &bmpsize);\n          if (bmpsize > dwg->thumbnail.size)\n            LOG_ERROR (\"BMP size overflow: %i > %lu\\n\", bmpsize, dwg->thumbnail.size)\n        }\n    }\n\n  /*-------------------------------------------------------------------------\n   * Header Variables, section 0\n   */\n\n  LOG_INFO (\"\\n\"\n            \"=======> Header Variables:         %4u\\n\",\n            (unsigned int)dwg->header.section[SECTION_HEADER_R13].address)\n  LOG_INFO (\"         Header Variables   (end): %4u\\n\",\n            (unsigned int)(dwg->header.section[SECTION_HEADER_R13].address\n                           + dwg->header.section[SECTION_HEADER_R13].size))\n  if (dwg->header.section[SECTION_HEADER_R13].address < 58\n      || dwg->header.section[SECTION_HEADER_R13].address\n                 + dwg->header.section[SECTION_HEADER_R13].size\n             > dat->size)\n    {\n      LOG_ERROR (\"Invalid Header section, skipped\")\n      error |= DWG_ERR_SECTIONNOTFOUND;\n      goto classes_section;\n    }\n  // after sentinel\n  dat->byte = pvz = dwg->header.section[SECTION_HEADER_R13].address + 16;\n  // LOG_HANDLE (\"@ 0x%lx.%lu\\n\", bit_position (dat)/8, bit_position (dat)%8);\n  dwg->header_vars.size = bit_read_RL (dat);\n  LOG_TRACE (\"         Length: \" FORMAT_RL \" [RL]\\n\", dwg->header_vars.size)\n  dat->bit = 0;\n\n  dwg_decode_header_variables (dat, dat, dat, dwg);\n\n  // LOG_HANDLE (\"@ 0x%lx.%lu\\n\", bit_position (dat)/8, bit_position (dat)%8);\n  // check slack\n  if (dat->bit || dat->byte != pvz + dwg->header_vars.size + 4)\n    {\n      unsigned char r = 8 - dat->bit;\n      LOG_HANDLE (\" padding: %ld byte, %d bits\\n\",\n                  pvz + dwg->header_vars.size + 4 - dat->byte, r);\n    }\n  // Check CRC, hardcoded to 2 before end sentinel\n  LOG_HANDLE (\" crc pos: %lu\\n\", pvz + dwg->header_vars.size + 4);\n  bit_set_position (dat, (pvz + dwg->header_vars.size + 4) * 8);\n  crc = bit_read_RS (dat);\n  LOG_TRACE (\"crc: %04X [RSx] from %lu-%lu=%ld\\n\", crc, pvz, dat->byte - 2,\n             dat->byte - 2 - pvz);\n  crc2 = 0;\n  // LOG_HANDLE (\"@ 0x%lx\\n\", bit_position (dat)/8);\n  // LOG_HANDLE (\"HEADER_R13.address of size 0x%lx\\n\", pvz);\n  // LOG_HANDLE (\"HEADER_R13.size %d\\n\",\n  // dwg->header.section[SECTION_HEADER_R13].size);\n  // typical sizes: 400-599\n  if (dwg->header.section[SECTION_HEADER_R13].size > 34\n      && dwg->header.section[SECTION_HEADER_R13].size < 0xfff\n      && pvz < dat->byte\n      && pvz + dwg->header.section[SECTION_HEADER_R13].size < dat->size)\n    {\n      // not dwg->header_vars.size, rather -4 (minus the section_size).\n      // section_size + data, i.e. minus the 2x sentinel (32) + crc itself (2)\n      // if we would include the crc we would always get 0000\n      BITCODE_RL crc_size = dwg->header.section[SECTION_HEADER_R13].size - 34;\n      LOG_HANDLE (\" calc Header crc size: \" FORMAT_RL \"\\n\", crc_size);\n      crc2 = bit_calc_CRC (0xC0C1, &dat->chain[pvz], crc_size);\n    }\n  if (crc != crc2)\n    {\n      LOG_WARN (\"Header Section[%ld] CRC mismatch %04X <=> %04X\",\n                (long)dwg->header.section[SECTION_HEADER_R13].number, crc,\n                crc2);\n      error |= DWG_ERR_WRONGCRC;\n    }\n\n  /*-------------------------------------------------------------------------\n   * Classes, section 1\n   */\nclasses_section:\n  LOG_INFO (\"\\n\"\n            \"=======> CLASS (start): %4lu\\n\",\n            (long)dwg->header.section[SECTION_CLASSES_R13].address)\n  LOG_INFO (\"         CLASS (end)  : %4lu\\n\",\n            (long)(dwg->header.section[SECTION_CLASSES_R13].address\n                   + dwg->header.section[SECTION_CLASSES_R13].size))\n  dat->byte = dwg->header.section[SECTION_CLASSES_R13].address + 16;\n  dat->bit = 0;\n\n  size = bit_read_RL (dat);\n  lasta = dat->byte + size;\n  LOG_TRACE (\"         Length: %lu [RL]\\n\", size);\n\n  /* Read the classes\n   */\n  dwg->layout_type = 0;\n  dwg->num_classes = 0;\n  do\n    {\n      BITCODE_BS i;\n      Dwg_Class *klass;\n\n      i = dwg->num_classes;\n      if (i == 0)\n        dwg->dwg_class = malloc (sizeof (Dwg_Class));\n      else\n        dwg->dwg_class\n            = realloc (dwg->dwg_class, (i + 1) * sizeof (Dwg_Class));\n      if (!dwg->dwg_class)\n        {\n          LOG_ERROR (\"Out of memory\");\n          return DWG_ERR_OUTOFMEM;\n        }\n      klass = &dwg->dwg_class[i];\n      memset (klass, 0, sizeof (Dwg_Class));\n      klass->number = bit_read_BS (dat);\n      klass->proxyflag = bit_read_BS (dat);\n      klass->appname = bit_read_TV (dat);\n      klass->cppname = bit_read_TV (dat);\n      klass->dxfname = bit_read_TV (dat);\n      klass->wasazombie = bit_read_B (dat);\n      // 1f2 for entities, 1f3 for objects\n      klass->item_class_id = bit_read_BS (dat);\n      LOG_TRACE (\"Class %d 0x%x %s\\n\"\n                 \" %s \\\"%s\\\" %d 0x%x\\n\",\n                 klass->number, klass->proxyflag, klass->dxfname,\n                 klass->cppname, klass->appname, klass->wasazombie,\n                 klass->item_class_id)\n\n#if 0\n      SINCE (R_2007) //? dead code it seems. see read_2004_section_classes()\n      {\n        klass->num_instances = bit_read_BL (dat);\n        klass->dwg_version = bit_read_BL (dat);\n        klass->maint_version = bit_read_BL (dat);\n        klass->unknown_1 = bit_read_BL (dat);\n        klass->unknown_2 = bit_read_BL (dat);\n        LOG_TRACE (\n            \" num_instances: %d, dwg/maint version: %d/%d, unk: %d/%d\\n\",\n            klass->num_instances, klass->dwg_version, klass->maint_version,\n            klass->unknown_1, klass->unknown_2);\n      }\n#endif\n\n      if (klass->dxfname && strEQc ((const char *)klass->dxfname, \"LAYOUT\"))\n        dwg->layout_type = klass->number;\n\n      dwg->num_classes++;\n      if (dwg->num_classes > 500)\n        {\n          LOG_ERROR (\"number of classes is greater than 500\");\n          break;\n        }\n    }\n  while (dat->byte < (lasta - 1));\n\n  // Check Section CRC\n  dat->byte = dwg->header.section[SECTION_CLASSES_R13].address\n              + dwg->header.section[SECTION_CLASSES_R13].size - 18;\n  dat->bit = 0;\n  pvz = dwg->header.section[SECTION_CLASSES_R13].address + 16;\n  if (!bit_check_CRC (dat, pvz, 0xC0C1))\n    error |= DWG_ERR_WRONGCRC;\n\n  dat->byte += 16; //sentinel\n  pvz = bit_read_RL (dat); // Unknown bitlong inter class and object\n  LOG_TRACE (\"unknown: 0x%04lx [RL] @%lu\\n\", pvz, dat->byte - 4)\n  LOG_INFO (\"Number of classes read: %u\\n\", dwg->num_classes)\n\n  /*-------------------------------------------------------------------------\n   * Object-map, section 2\n   */\n\n  dat->byte = dwg->header.section[SECTION_HANDLES_R13].address;\n  dat->bit = 0;\n\n  lastmap = dat->byte + dwg->header.section[SECTION_HANDLES_R13].size; // 4\n  dwg->num_objects = 0;\n  object_begin = dat->size;\n  object_end = 0;\n  LOG_INFO (\"\\n\"\n            \"=======> Handles (start) : %8u\\n\",\n            (unsigned int)dwg->header.section[SECTION_HANDLES_R13].address)\n  LOG_INFO (\"         Handles (end)   : %8u\\n\",\n            (unsigned int)(dwg->header.section[SECTION_HANDLES_R13].address\n                           + dwg->header.section[SECTION_HANDLES_R13].size))\n  LOG_INFO (\"         Length: %u\\n\",\n            (unsigned int)dwg->header.section[SECTION_HANDLES_R13].size)\n\n  do\n    {\n      long unsigned int last_offset = 0;\n      long unsigned int last_handle = 0;\n      long unsigned int oldpos = 0;\n      long unsigned int maxh = (unsigned long)dwg->header.section[SECTION_HANDLES_R13].size << 1;\n      BITCODE_BL max_handles = maxh < INT32_MAX ? (BITCODE_BL)maxh\n        : dwg->header.section[SECTION_HANDLES_R13].size;\n      int added;\n\n      startpos = dat->byte;\n      section_size = bit_read_RS_LE (dat);\n      LOG_TRACE (\"Handles page size: %u [RS_LE] @%lu\\n\", section_size, startpos);\n      if (section_size > 2040)\n        {\n          LOG_ERROR (\"Object-map section size greater than 2040!\")\n          return DWG_ERR_VALUEOUTOFBOUNDS;\n        }\n\n      while (dat->byte - startpos < section_size)\n        {\n          BITCODE_UMC handleoff;\n          BITCODE_MC offset;\n          //BITCODE_BL last_handle = dwg->num_objects\n          //  ? dwg->object[dwg->num_objects - 1].handle.value : 0;\n\n          oldpos = dat->byte;\n          // the offset from the previous handle. default: 1, unsigned\n          handleoff = bit_read_UMC (dat);\n          // the offset from the previous address. default: obj->size, signed\n          offset = bit_read_MC (dat);\n          if (!handleoff || handleoff > max_handles - last_handle)\n            {\n              BITCODE_MC prevsize = dwg->num_objects\n                ? dwg->object[dwg->num_objects - 1].size + 4 : 0L;\n              LOG_WARN (\"Ignore invalid handleoff (@%lu)\", oldpos);\n              if (offset == 1 ||\n                  (offset > 0 && offset < prevsize && prevsize > 0) ||\n                  (offset < 0 && labs((long)offset) < prevsize && prevsize > 0))\n                {\n                  if (offset != prevsize)\n                    LOG_ERROR (\"Invalid offset: %ld [MC]\", offset);\n                  offset = prevsize;\n                  LOG_WARN (\"Recover invalid offset to %ld\", offset);\n                }\n            }\n          last_offset += offset;\n          LOG_TRACE (\"\\nNext object: %lu \", (unsigned long)dwg->num_objects)\n          LOG_TRACE (\"Handleoff: %lX [UMC] \"\n                     \"Offset: \" FORMAT_MC \" [MC] @%lu\\n\",\n                     handleoff, offset, last_offset)\n\n          if (dat->byte == oldpos)\n            break;\n\n          if (object_end < last_offset)\n            object_end = last_offset;\n          if (object_begin > last_offset)\n            object_begin = last_offset;\n\n          added = dwg_decode_add_object (dwg, dat, dat, last_offset);\n          if (added > 0)\n            error |= added; // else not added (skipped) or -1 for re-allocated\n          last_handle = dwg->object[dwg->num_objects - 1].handle.value;\n          // LOG_HANDLE (\"dat: @%lu.%u\\n\", dat->byte, dat->bit);\n        }\n      if (dat->byte == oldpos)\n        break;\n\n      // CRC on\n      if (dat->bit > 0)\n        {\n          dat->byte += 1;\n          dat->bit = 0;\n        }\n\n      crc = bit_read_RS_LE (dat);\n      LOG_TRACE (\"\\nHandles page crc: %04X [RS_LE] (%lu-%lu = %u)\\n\", crc,\n                 startpos, startpos + section_size, section_size);\n      crc2 = bit_calc_CRC (0xC0C1, dat->chain + startpos, section_size);\n      if (crc != crc2)\n        {\n          LOG_ERROR (\"Handles Section[%ld] page CRC mismatch %04X <=> %04X\",\n                     (long)dwg->header.section[SECTION_HANDLES_R13].number,\n                     crc, crc2);\n          // fails with r14\n          // if (dwg->header.version == R_2000)\n          //  return DWG_ERR_WRONGCRC;\n          if (dat->version != R_14)\n            error |= DWG_ERR_WRONGCRC;\n        }\n      if (dat->byte >= lastmap)\n        break;\n    }\n  while (section_size > 2);\n\n  LOG_INFO (\"Num objects: %lu\\n\", (unsigned long)dwg->num_objects)\n  LOG_INFO (\"\\n\"\n            \"=======> Last Object      : %8lu\\n\",\n            (unsigned long)object_begin)\n  dat->byte = object_end;\n  object_begin = bit_read_MS (dat);\n  LOG_TRACE (\"last object size: %lu [MS] (@%lu)\\n\", object_begin, object_end)\n  LOG_INFO (\"         Last Object (end): %8lu\\n\",\n            (unsigned long)(object_end + object_begin + 2))\n\n  /*\n   // TODO: if the previous Handleoff got corrupted somehow, read this handle map \n   // and try again.\n\n   dat->byte = dwg->header.section[SECTION_HANDLES_R13].address - 2;\n   // Unknown bitdouble inter object data and object map\n   antcrc = bit_read_CRC (dat);\n   LOG_TRACE(\"Address: %08u / Content: 0x%04X\", dat->byte - 2, antcrc)\n\n   // check CRC-on\n   antcrc = 0xC0C1;\n   do\n   {\n     startpos = dat->byte;\n     sgdc[0] = bit_read_RC (dat);\n     sgdc[1] = bit_read_RC (dat);\n     section_size = (sgdc[0] << 8) | sgdc[1];\n     section_size -= 2;\n     dat->byte += section_size;\n     crc = bit_read_CRC (dat);\n     dat->byte -= 2;\n     bit_write_CRC (dat, startpos, antcrc);\n     dat->byte -= 2;\n     crc2 = bit_read_CRC (dat);\n     if (loglevel) fprintf (stderr, \"Read: %X\\nCreated: %X\\t SEMO: %X\\n\",\n                            crc, crc2, antcrc);\n     //antcrc = crc;\n   } while (section_size > 0);\n   */\n\n  /*-------------------------------------------------------------------------\n   * Second header, section 3. R13-R2000 only.\n   * But partially also since r2004.\n   */\n\n  if (bit_search_sentinel (dat,\n                           dwg_sentinel (DWG_SENTINEL_SECOND_HEADER_BEGIN)))\n    {\n      BITCODE_RL i;\n      BITCODE_RC sig, sig2;\n      BITCODE_BL vcount;\n      long unsigned int pvzadr;\n      struct _dwg_second_header *_obj = &dwg->second_header;\n      obj = NULL;\n\n      LOG_INFO (\"\\n\"\n                \"=======> Second Header 3 (start): %8u\\n\",\n                (unsigned int)dat->byte - 16)\n      pvzadr = dat->byte;\n      LOG_TRACE (\"pvzadr: %lx\\n\", pvzadr)\n\n      FIELD_RL (size, 0);\n      FIELD_BLx (address, 0);\n\n      if (dwg->header.num_sections <= SECTION_2NDHEADER_R13)\n        {\n          LOG_WARN (\"Only %d num_sections, but 2ndheader found, extending to 4\",\n                    dwg->header.num_sections);\n          dwg->header.num_sections = SECTION_2NDHEADER_R13 + 1; /* 4 */\n          dwg->header.section\n              = realloc (dwg->header.section,\n                         dwg->header.num_sections * sizeof (Dwg_Section));\n          memset (&dwg->header.section[SECTION_2NDHEADER_R13], 0,\n                  sizeof (Dwg_Section));\n        }\n      if (!dwg->header.section[SECTION_2NDHEADER_R13].address)\n        {\n          dwg->header.section[SECTION_2NDHEADER_R13].address\n              = dwg->second_header.address;\n          dwg->header.section[SECTION_2NDHEADER_R13].size\n              = dwg->second_header.size;\n        }\n\n      // AC1012, AC1014 or AC1015. This is a char[11], zero padded.\n      // with \\n at 12.\n      bit_read_fixed (dat, _obj->version, 12);\n      LOG_TRACE (\"version: %s [TFF 12]\\n\", _obj->version)\n      for (i = 0; i < 4; i++)\n        FIELD_B (null_b[i], 0);\n      // DEBUG_HERE;\n      // documented as 0x18,0x78,0x01,0x04 for R13, 0x18,0x78,0x01,0x05 for R14\n      // r14:      7d f4 78 01\n      // r2000:    14 64 78 01\n      FIELD_RC (unknown_10, 0); // 0x10\n      for (i = 0; i < 4; i++)\n        FIELD_RC (unknown_rc4[i], 0);\n\n      if (dat->version < R_2000 && FIELD_VALUE (unknown_10) == 0x18\n          && FIELD_VALUE (unknown_rc4[0]) == 0x78)\n        dat->byte -= 2;\n      UNTIL (R_2000)\n      {\n        FIELD_RC (num_sections, 0); // r14: 5, r2000: 6\n        for (i = 0; i < MIN (6, FIELD_VALUE (num_sections)); i++)\n          {\n            // address+sizes of sections 0-2 is correct, 3+4 is empty\n            FIELD_RC (section[i].nr, 0);\n            FIELD_BLx (section[i].address, 0);\n            FIELD_BL (section[i].size, 0);\n          }\n        if (DWG_LOGLEVEL >= DWG_LOGLEVEL_HANDLE)\n          {\n            LOG_HANDLE (\"1st header was:\\n\");\n            for (i = 0; i < dwg->header.num_sections; i++)\n              {\n                LOG_HANDLE (\"section[\" FORMAT_RL \"] \" FORMAT_RLd \" \" FORMAT_RLL\n                            \" \" FORMAT_RL \" \\n\",\n                            i, dwg->header.section[i].number,\n                            dwg->header.section[i].address,\n                            dwg->header.section[i].size);\n              }\n            LOG_HANDLE (\"start 3: %lu\\n\", pvzadr - 16);\n          }\n\n        FIELD_BS (num_handlers, 0); // 14, resp. 16 in r14\n        if (FIELD_VALUE (num_handlers) > 16)\n          {\n            LOG_ERROR (\"Second header num_handlers > 16: %d\\n\",\n                       FIELD_VALUE (num_handlers));\n            FIELD_VALUE (num_handlers) = 14;\n          }\n        for (i = 0; i < FIELD_VALUE (num_handlers); i++)\n          {\n            FIELD_RC (handlers[i].size, 0);\n            FIELD_RC (handlers[i].nr, 0);\n            FIELD_VECTOR (handlers[i].data, RC, handlers[i].size, 0);\n          }\n\n        // TODO: CRC check\n        crc = bit_read_CRC (dat);\n        LOG_TRACE (\"crc: %04X\\n\", crc);\n\n        VERSION (R_14)\n        {\n          FIELD_RL (junk_r14_1, 0);\n          FIELD_RL (junk_r14_2, 0);\n        }\n      }\n\n      if (bit_search_sentinel (dat,\n                               dwg_sentinel (DWG_SENTINEL_SECOND_HEADER_END)))\n        LOG_INFO (\"         Second Header 3 (end)  : %8u\\n\",\n                  (unsigned int)dat->byte)\n    }\n\n  /*-------------------------------------------------------------------------\n   * Section 4: MEASUREMENT\n   */\n\n  if (dwg->header.num_sections > 4)\n    {\n      LOG_INFO (\"\\n\"\n                \"=======> MEASUREMENT 4 (start)  : %8u\\n\",\n                (unsigned int)dwg->header.section[4].address)\n      LOG_INFO (\"         MEASUREMENT 4 (end)    : %8u\\n\",\n                (unsigned int)(dwg->header.section[4].address\n                               + dwg->header.section[4].size))\n      dat->byte = dwg->header.section[4].address;\n      dat->bit = 0;\n      dwg->header_vars.MEASUREMENT = (BITCODE_BS)bit_read_RL (dat);\n      LOG_TRACE (\"MEASUREMENT: \" FORMAT_BS \" [RL] (0 English/1 Metric)\\n\",\n                 dwg->header_vars.MEASUREMENT)\n\n      //LOG_TRACE (\"         Size bytes :\\t%lu\\n\", dat->size)\n    }\n\n  // step II of handles parsing: resolve pointers from handle value\n  // XXX: move this somewhere else\n  LOG_INFO (\"\\nnum_objects: %lu\\n\", (unsigned long)dwg->num_objects)\n  LOG_TRACE (\"num_object_refs: %lu\\n\", (unsigned long)dwg->num_object_refs)\n  LOG_TRACE (\"Resolving pointers from ObjectRef vector:\\n\")\n  error |= resolve_objectref_vector (dat, dwg);\n  return error;\n}\n\nstatic int\nresolve_objectref_vector (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)\n{\n  BITCODE_BL i;\n  Dwg_Object *obj;\n\n  dwg->dirty_refs = 0;\n  for (i = 0; i < dwg->num_object_refs; i++)\n    {\n      Dwg_Object_Ref *ref = dwg->object_ref[i];\n      LOG_INSANE (\"==========\\n\")\n      LOG_TRACE (\"-objref[%3ld]: HANDLE\" FORMAT_REF \"\\n\", (long)i,\n                 ARGS_REF (ref))\n\n      // search the handle in all objects\n      obj = dwg_resolve_handle (dwg, ref->absolute_ref);\n      if (obj)\n        {\n          LOG_TRACE (\"-found:     HANDLE(\" FORMAT_H \") => [%u]\\n\",\n                     ARGS_H (obj->handle), obj->index)\n        }\n      // assign found pointer to objectref vector\n      ref->obj = obj;\n\n      if (DWG_LOGLEVEL >= DWG_LOGLEVEL_INSANE)\n        {\n          if (obj)\n            dwg_print_object (dat, obj);\n          else\n            LOG_TRACE (\"Null object pointer: object_ref[%ld]\\n\", (long)i)\n        }\n    }\n  return dwg->num_object_refs ? 0 : DWG_ERR_VALUEOUTOFBOUNDS;\n}\n\n/* Find the BITCODE_H for an object */\nDwg_Object_Ref *\ndwg_find_objectref (const Dwg_Data *restrict dwg,\n                    const Dwg_Object *restrict obj)\n{\n  for (BITCODE_BL i = 0; i < dwg->num_object_refs; i++)\n    {\n      Dwg_Object_Ref *ref = dwg->object_ref[i];\n      Dwg_Object *found = dwg_resolve_handle_silent (dwg, ref->absolute_ref);\n      if (found == obj)\n        return ref;\n    }\n  return NULL;\n}\n\nvoid\ndwg_resolve_objectrefs_silent (Dwg_Data *restrict dwg)\n{\n  BITCODE_BL i;\n  Dwg_Object *restrict obj;\n  int oldloglevel = loglevel;\n\n  loglevel = 0;\n  // Dwg_Object_Ref->obj are stored all over. dirty it to update dynamically.\n  // TODO: this is now forever. find a way to resolve all objs also.\n  dwg->dirty_refs = 1;\n  for (i = 0; i < dwg->num_object_refs; i++)\n    {\n      // scan num_objects for the id (absolute_ref)\n      obj = dwg_resolve_handle (dwg, dwg->object_ref[i]->absolute_ref);\n      dwg->object_ref[i]->obj = obj;\n    }\n  // TODO: scan dwg->num_objects also to update it's handlerefs\n  loglevel = oldloglevel;\n}\n\n/* endian specific */\nvoid\nbfr_read (void *restrict dst, BITCODE_RC *restrict *restrict src, size_t size)\n{\n  memcpy (dst, *src, size);\n  *src += size;\n}\n\n/* R2004 Literal Length\n */\nstatic unsigned int\nread_literal_length (Bit_Chain *restrict dat, unsigned char *restrict opcode)\n{\n  unsigned int total = 0;\n  BITCODE_RC byte = bit_read_RC (dat);\n\n  *opcode = 0x00;\n\n  if (byte >= 0x01 && byte <= 0x0F)\n    return byte + 3;\n  else if (byte == 0)\n    {\n      total = 0x0F;\n      while ((byte = bit_read_RC (dat)) == 0 && dat->size - dat->byte > 1)\n        {\n          total += 0xFF;\n        }\n      return total + byte + 3;\n    }\n  else if (byte & 0xF0)\n    *opcode = byte;\n\n  return 0;\n}\n\n/* R2004 Long Compression Offset\n */\nstatic int\nread_long_compression_offset (Bit_Chain *dat)\n{\n  int total = 0;\n  BITCODE_RC byte = bit_read_RC (dat);\n  if (byte == 0)\n    {\n      total = 0xFF;\n      while ((byte = bit_read_RC (dat)) == 0 && dat->size - dat->byte > 1)\n        total += 0xFF;\n    }\n  return total + byte;\n}\n\n/* R2004 Two Byte Offset\n */\nstatic int\nread_two_byte_offset (Bit_Chain *restrict dat, unsigned int *restrict lit_length)\n{\n  int offset;\n  BITCODE_RC firstByte = bit_read_RC (dat);\n  BITCODE_RC secondByte = bit_read_RC (dat);\n  offset = (firstByte >> 2) | (secondByte << 6);\n  *lit_length = (firstByte & 0x03);\n  return offset;\n}\n\n/* Decompresses a system section of a 2004+ DWG file\n */\nstatic int\ndecompress_R2004_section (Bit_Chain *restrict dat, BITCODE_RC *restrict decomp,\n                          uint32_t decomp_data_size, uint32_t comp_data_size)\n{\n  unsigned int i, lit_length;\n  uint32_t comp_offset, comp_bytes, bytes_left;\n  unsigned char opcode1 = 0, opcode2;\n  long unsigned int start_byte = dat->byte;\n  BITCODE_RC *src, *dst = decomp;\n  BITCODE_RC *maxdst = decomp + decomp_data_size;\n\n  bytes_left = decomp_data_size;               // to write to\n  if (comp_data_size > dat->size - start_byte) // bytes left to read from\n    {\n      LOG_WARN (\"Invalid comp_data_size %lu > %lu bytes left\",\n                (unsigned long)bytes_left, dat->size - dat->byte)\n      return DWG_ERR_VALUEOUTOFBOUNDS;\n    }\n  // length of the first sequence of uncompressed or literal data.\n  lit_length = read_literal_length (dat, &opcode1);\n  if (lit_length > bytes_left)\n    {\n      LOG_ERROR (\"Invalid literal_length %u > %u bytes left\",\n                 lit_length, (unsigned)decomp_data_size)\n      return DWG_ERR_VALUEOUTOFBOUNDS;\n    }\n  bit_read_fixed (dat, decomp, lit_length);\n  dst += lit_length;\n  bytes_left -= lit_length;\n\n  opcode1 = 0x00;\n  while (dat->byte - start_byte < comp_data_size)\n    {\n      LOG_INSANE (\"-O %x \", opcode1)\n      if (opcode1 == 0x00)\n        {\n          opcode1 = bit_read_RC (dat);\n          LOG_INSANE (\"<O %x \", opcode1)\n        }\n\n      if (opcode1 >= 0x40)\n        {\n          comp_bytes = ((opcode1 & 0xF0) >> 4) - 1;\n          opcode2 = bit_read_RC (dat);\n          LOG_INSANE (\"<O %x \", opcode2)\n          comp_offset = (opcode2 << 2) | ((opcode1 & 0x0C) >> 2);\n\n          if (opcode1 & 0x03)\n            {\n              lit_length = (opcode1 & 0x03);\n              opcode1 = 0x00;\n            }\n          else\n            lit_length = read_literal_length (dat, &opcode1);\n        }\n      else if (opcode1 >= 0x21\n               && opcode1 <= 0x3F) // lgtm [cpp/constant-comparison]\n        {\n          comp_bytes = opcode1 - 0x1E;\n          comp_offset = read_two_byte_offset (dat, &lit_length);\n\n          if (lit_length != 0)\n            opcode1 = 0x00;\n          else\n            lit_length = read_literal_length (dat, &opcode1);\n        }\n      else if (opcode1 == 0x20)\n        {\n          comp_bytes = read_long_compression_offset (dat) + 0x21;\n          comp_offset = read_two_byte_offset (dat, &lit_length);\n\n          if (lit_length != 0)\n            opcode1 = 0x00;\n          else\n            lit_length = read_literal_length (dat, &opcode1);\n        }\n      else if (opcode1 >= 0x12 && opcode1 <= 0x1F)\n        {\n          comp_bytes = (opcode1 & 0x0F) + 2;\n          comp_offset = read_two_byte_offset (dat, &lit_length) + 0x3FFF;\n\n          if (lit_length != 0)\n            opcode1 = 0x00;\n          else\n            lit_length = read_literal_length (dat, &opcode1);\n        }\n      else if (opcode1 == 0x10)\n        {\n          comp_bytes = read_long_compression_offset (dat) + 9;\n          comp_offset = read_two_byte_offset (dat, &lit_length) + 0x3FFF;\n\n          if (lit_length != 0)\n            opcode1 = 0x00;\n          else\n            lit_length = read_literal_length (dat, &opcode1);\n        }\n      else if (opcode1 == 0x11)\n        break; // Terminates the input stream, everything is ok\n      else\n        {\n          LOG_ERROR (\"Invalid opcode 0x%x in input stream at pos %lu\", opcode1,\n                     dat->byte);\n          return DWG_ERR_INTERNALERROR; // error in input stream\n        }\n\n      src = dst - comp_offset - 1;\n      if (src < decomp) // was assert (src >= decomp);\n        {\n          LOG_ERROR (\"decompress_R2004_section: src offset underflow\");\n          return DWG_ERR_INTERNALERROR;\n        }\n      if (comp_bytes)\n        {\n          LOG_INSANE (\"<C %d \", comp_bytes)\n          // copy \"compressed data\"\n          if ((uint32_t)comp_bytes > bytes_left || // bytes left to write\n              dst + comp_bytes > maxdst)\n            {\n              LOG_ERROR (\"Invalid comp_bytes %lu > %lu bytes left\",\n                         (unsigned long)comp_bytes, (unsigned long)bytes_left)\n              return DWG_ERR_VALUEOUTOFBOUNDS;\n            }\n          for (i = 0; i < comp_bytes; ++i)\n            *dst++ = *src++;\n          bytes_left -= comp_bytes;\n        }\n      // copy \"literal data\"\n      LOG_INSANE (\"<L %d\\n\", lit_length)\n      if (lit_length)\n        {\n          if ((lit_length > bytes_left) // bytes left to write\n              || dst + lit_length > maxdst)       // dst overflow\n            {\n              LOG_ERROR (\"Invalid lit_length %u > %lu bytes left\",\n                         lit_length, (unsigned long)bytes_left)\n              return DWG_ERR_VALUEOUTOFBOUNDS;\n            }\n          for (i = 0; i < lit_length; ++i)\n            *dst++ = bit_read_RC (dat);\n        }\n    }\n\n  return 0; // Success\n}\n\n// index is the Section Number in the section map\nstatic Dwg_Section *\nfind_section (Dwg_Data *dwg, unsigned long int idx)\n{\n  BITCODE_BL i;\n  if (dwg->header.section == 0 || idx == 0)\n    return 0;\n  for (i = 0; i < dwg->header.num_sections; ++i)\n    {\n      if ((unsigned long int)dwg->header.section[i].number == idx)\n        return &dwg->header.section[i];\n    }\n  return NULL;\n}\n\nstatic int\nadd_section (Dwg_Data *dwg)\n{\n  if (dwg->header.num_sections == 0)\n    dwg->header.section = calloc (1, sizeof (Dwg_Section));\n  else\n    {\n      dwg->header.section\n          = realloc (dwg->header.section,\n                     sizeof (Dwg_Section) * (dwg->header.num_sections + 1));\n      memset (&dwg->header.section[dwg->header.num_sections], 0,\n              sizeof (Dwg_Section));\n    }\n  if (!dwg->header.section)\n    {\n      LOG_ERROR (\"Out of memory\");\n      return DWG_ERR_OUTOFMEM;\n    }\n  dwg->header.num_sections++;\n  return 0;\n}\n\n/* Read R2004, 2010+ Section Map\n * The Section Map is a vector of number, size, and address(offset) triples\n * used to locate the sections in the file.\n */\nstatic int\nread_R2004_section_map (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)\n{\n  BITCODE_RC *decomp, *ptr;\n  int i, error = 0, found_section_map_id = 0;\n  uint64_t section_address;\n  int64_t bytes_remaining;\n  const uint32_t comp_data_size = dwg->r2004_header.comp_data_size;\n  const uint32_t decomp_data_size = dwg->r2004_header.decomp_data_size;\n  const int32_t section_array_size = (int32_t)dwg->r2004_header.section_array_size;\n  const uint64_t section_map_address = dwg->r2004_header.section_map_address + 0x100;\n  const BITCODE_RL section_map_id = dwg->r2004_header.section_map_id;\n  int max_id = 0;\n\n  dwg->header.num_sections = 0;\n  dwg->header.section = 0;\n\n  // decompressed data\n  decomp = (BITCODE_RC *)calloc (decomp_data_size + 1024, sizeof (BITCODE_RC));\n  if (!decomp)\n    {\n      LOG_ERROR (\"Out of memory\");\n      return DWG_ERR_OUTOFMEM;\n    }\n\n  error = decompress_R2004_section (dat, decomp, decomp_data_size + 1024,\n                                    comp_data_size);\n  if (error > DWG_ERR_CRITICAL || error == DWG_ERR_VALUEOUTOFBOUNDS)\n    {\n      free (decomp);\n      return error;\n    }\n  LOG_TRACE (\"\\n#### Read 2004 Section Page Map ####\\n\")\n\n  section_address = 0x100; // starting address\n  i = 0;\n  bytes_remaining = (int64_t)decomp_data_size;\n  ptr = decomp;\n  dwg->header.num_sections = 0;\n\n  while (bytes_remaining >= 8)\n    {\n      error |= add_section (dwg);\n      if (error > DWG_ERR_CRITICAL)\n        return error;\n\n      /* endian specific code: */\n      bfr_read (&dwg->header.section[i], &ptr, 8);\n      bytes_remaining -= 8;\n      LOG_TRACE (\"Section[%2d]=%2d,\", i, (int)dwg->header.section[i].number)\n      LOG_TRACE (\" size: %5u,\", dwg->header.section[i].size)\n      dwg->header.section[i].address = section_address;\n      if (dwg->header.section[i].number <= section_array_size) // GH #144\n        {\n          section_address += dwg->header.section[i].size;\n          LOG_TRACE (\" address: 0x%04lx\\n\",\n                     (unsigned long)dwg->header.section[i].address)\n        }\n      else\n        LOG_TRACE (\" (ignored > %d section_array_size)\\n\",\n                   (int)section_array_size);\n      if (dwg->header.section[i].number > max_id)\n        max_id = dwg->header.section[i].number;\n\n      // repair section_map_id.address from section_map_address\n      if ((BITCODE_RL)dwg->header.section[i].number == section_map_id)\n        {\n          found_section_map_id++;\n          if (dwg->header.section[i].address != section_map_address)\n            {\n              LOG_WARN (\"Repair invalid section_map_address: %\" PRIx64 \" != %\" PRIx64,\n                        dwg->header.section[i].address, section_map_address);\n              error |= DWG_ERR_VALUEOUTOFBOUNDS;\n              dwg->header.section[i].address = section_map_address;\n            }\n        }\n      if (i >= (int)section_array_size)\n        {\n          error |= DWG_ERR_VALUEOUTOFBOUNDS;\n          LOG_WARN (\"Overflow section_array_size: %d >= %d\",\n                    i, (int)section_array_size);\n          if (i > 1000)\n            return error;\n        }\n\n      if (bytes_remaining >= 16\n          && dwg->header.section[i].number < 0) // negative: gap/unused data\n        //|| dwg->header.section[i].number > section_array_size))\n        {\n          /* endian specific code: */\n          bfr_read (&dwg->header.section[i].parent, &ptr, 16);\n          bytes_remaining -= 16;\n          LOG_TRACE (\"  Parent: %d, \", dwg->header.section[i].parent)\n          LOG_TRACE (\"Left:   %d, \", dwg->header.section[i].left)\n          LOG_TRACE (\"Right:  %d, \", dwg->header.section[i].right)\n          LOG_TRACE (\"0x00:   %d\\n\", dwg->header.section[i].x00)\n        }\n\n      i++;\n    }\n  i--;\n  free (decomp);\n\n  if (max_id != (int32_t)section_array_size)\n    {\n      LOG_WARN (\"Invalid section_array_size: [%d].%d != %d\",\n                i, max_id, (int)section_array_size);\n    }\n  if (section_address\n      != (uint64_t)dwg->r2004_header.last_section_address + 0x100)\n    {\n      error |= DWG_ERR_VALUEOUTOFBOUNDS;\n      LOG_WARN (\"Invalid last_section_address: %\" PRIx64 \" != %\" PRIx64,\n                section_address, dwg->r2004_header.last_section_address);\n    }\n  if (dwg->header.num_sections\n      != dwg->r2004_header.num_gaps + dwg->r2004_header.num_sections)\n    {\n      error |= DWG_ERR_VALUEOUTOFBOUNDS;\n      LOG_WARN (\"Invalid num_sections: %d != gaps: \" FORMAT_RL\n                \" + sects: \" FORMAT_RL,\n                dwg->header.num_sections, dwg->r2004_header.num_gaps,\n                dwg->r2004_header.num_sections);\n    }\n  if (!found_section_map_id)\n    {\n      BITCODE_RLx section_type;\n      Dwg_Section *info;\n      LOG_WARN (\"section_map_id \" FORMAT_RL \" not found\", section_map_id);\n      info = find_section (dwg, section_map_id);\n      if (!info)\n        {\n          i = dwg->header.num_sections;\n          add_section (dwg);\n          LOG_WARN (\"Add section_map_id [%d] %d => address 0x%\" PRIx64, i,\n                    section_map_id, section_map_address);\n          error |= DWG_ERR_VALUEOUTOFBOUNDS;\n          dwg->header.section[i].number = section_map_id;\n          dwg->header.section[i].address = section_map_address;\n          if (i > 0)\n            dwg->header.section[i].size\n              = section_map_address - dwg->header.section[i - 1].address;\n        }\n      info = find_section (dwg, dwg->r2004_header.section_info_id);\n      if (!info)\n        goto repair_info_id;\n      dat->bit = 0;\n      dat->byte = info->address;\n      section_type = bit_read_RL (dat);\n      if (section_type != 0x4163003b)\n        {\n        repair_info_id:\n          LOG_WARN (\"Repair invalid section_info_id [%d]: => %u\",\n                    i-1, dwg->r2004_header.section_info_id);\n          error |= DWG_ERR_VALUEOUTOFBOUNDS;\n          for (i = 0; i < (int)dwg->header.num_sections; ++i)\n            {\n              dat->bit = 0;\n              dat->byte = dwg->header.section[i].address;\n              if (dat->byte > dat->size)\n                break;\n              section_type = bit_read_RL (dat);\n              if (section_type == 0x4163003b)\n                {\n                  LOG_WARN (\"Fixed section_info_id [%d]: => %u @\" FORMAT_RLL,\n                            i, dwg->r2004_header.section_info_id,\n                            dwg->header.section[i].address);\n                  if (!info)\n                    info = &dwg->header.section[i];\n                  info->address = dwg->header.section[i].address;\n                  info->size = dwg->header.section[i].size;\n                  info->number = dwg->r2004_header.section_info_id;\n                }\n            }\n          if (!info || info->number != (int)dwg->r2004_header.section_info_id)\n            {\n              i = dwg->header.num_sections;\n              add_section (dwg);\n              error |= DWG_ERR_VALUEOUTOFBOUNDS;\n              dwg->header.section[i].number = dwg->r2004_header.section_info_id;\n              dwg->header.section[i].address = dwg->header.section[i-1].address +\n                dwg->header.section[i-1].size;\n              LOG_WARN (\"Add section_info_id [%d] %u => address 0x%\" PRIx64, i,\n                        dwg->r2004_header.section_info_id,\n                        dwg->header.section[i].address);\n            }\n        }\n    }\n  if (found_section_map_id > 1)\n    {\n      error |= DWG_ERR_VALUEOUTOFBOUNDS;\n      LOG_WARN (\"Illegal 2004 Section Page Map. Found %d section_map_id sections\",\n                found_section_map_id)\n    }\n\n  return error;\n}\n\n/* Read R2004, 2010+ Section Info, aka 2004 Data section map\n */\nstatic int\nread_R2004_section_info (Bit_Chain *restrict dat, Dwg_Data *restrict dwg,\n                         uint32_t comp_data_size, uint32_t decomp_data_size)\n{\n  BITCODE_RC *decomp, *ptr, *decomp_end;\n  BITCODE_BL i, j;\n  int32_t section_number = 0;\n  uint32_t data_size, maxsize;\n  uint64_t offset;\n  int error;\n\n  decomp = (BITCODE_RC *)calloc (decomp_data_size + 1024, sizeof (BITCODE_RC));\n  if (!decomp)\n    {\n      LOG_ERROR (\"Out of memory\");\n      return DWG_ERR_OUTOFMEM;\n    }\n\n  error = decompress_R2004_section (dat, decomp, decomp_data_size + 1024,\n                                    comp_data_size);\n  if (error > DWG_ERR_CRITICAL || error == DWG_ERR_VALUEOUTOFBOUNDS)\n    {\n      free (decomp);\n      return error;\n    }\n\n  ptr = decomp;\n  bfr_read (&dwg->header.section_infohdr, &ptr, 20);\n  LOG_TRACE (\"\\n#### Read 2004 section_infohdr ####\\n\")\n  LOG_TRACE (\"num_desc:   %d\\n\", dwg->header.section_infohdr.num_desc)\n  LOG_TRACE (\"compressed: %d\\n\", dwg->header.section_infohdr.compressed)\n  LOG_TRACE (\"max_size:   0x%x\\n\", dwg->header.section_infohdr.max_size)\n  LOG_TRACE (\"encrypted:  %d\\n\", dwg->header.section_infohdr.encrypted)\n  LOG_TRACE (\"num_desc2:  %d/0x%x\\n\", dwg->header.section_infohdr.num_desc2,\n             dwg->header.section_infohdr.num_desc2)\n  if (dwg->header.section_infohdr.num_desc > 0xf000000)\n    {\n      LOG_ERROR (\"Illegal num_desc2\");\n      free (decomp);\n      dwg->header.section_infohdr.num_desc = 0;\n      dwg->header.section_infohdr.num_desc2 = 0;\n      return error | DWG_ERR_INVALIDDWG;\n    }\n  dwg->header.section_info = (Dwg_Section_Info *)calloc (\n      dwg->header.section_infohdr.num_desc, sizeof (Dwg_Section_Info));\n  if (!dwg->header.section_info)\n    {\n      LOG_ERROR (\"Out of memory\");\n      return error | DWG_ERR_OUTOFMEM;\n    }\n  decomp_end = decomp + decomp_data_size + 1024;\n  for (i = 0; i < dwg->header.section_infohdr.num_desc; ++i)\n    {\n      Dwg_Section_Info *info;\n      uint64_t sum_decomp = 0;\n      uint64_t prev_address = 0;\n\n      if (ptr + 64 >= decomp_end)\n        {\n          free (decomp);\n          dwg->header.section_infohdr.num_desc = i;\n          LOG_ERROR (\"read_R2004_section_info out of range\");\n          return DWG_ERR_INVALIDDWG;\n        }\n      info = &dwg->header.section_info[i];\n      /* endian specific code */\n      bfr_read (info, &ptr, 32 + 64);\n\n      LOG_TRACE (\"\\nsection_info[%d] fields:\\n\", i)\n      LOG_TRACE (\"size:            %ld\\n\", (long)info->size)\n      LOG_TRACE (\"num_sections:    %u\\n\", info->num_sections)\n      LOG_TRACE (\"max_decomp_size: %u / 0x%x\\n\", // normally 0x7400\n                 info->max_decomp_size, info->max_decomp_size)\n      LOG_TRACE (\"unknown:         %u\\n\", info->unknown)\n      LOG_TRACE (\"compressed:      %u (1=no, 2=yes)\\n\", info->compressed)\n      LOG_TRACE (\"type:            0x%x\\n\", (unsigned)info->type)\n      LOG_TRACE (\"encrypted:       %d (0=no, 1=yes, 2=unknown)\\n\",\n                 info->encrypted)\n      LOG_TRACE (\"name:            %s\\n\\n\", info->name)\n\n      if (ptr + (16 * info->num_sections) >= decomp_end)\n        {\n          info->name[0] = '\\0';\n          info->num_sections = 0;\n          info->sections = NULL;\n          dwg->header.section_infohdr.num_desc = i;\n          free (decomp);\n          LOG_ERROR (\"read_R2004_section_info out of range\");\n          return DWG_ERR_INVALIDDWG;\n        }\n\n      if (info->num_sections < 1000000)\n        {\n          int32_t old_section_number = 0;\n          LOG_INFO (\"Page count %u in area %d\\n\", info->num_sections, i);\n          info->sections = calloc (info->num_sections, sizeof (Dwg_Section *));\n          if (!info->sections)\n            {\n              free (decomp);\n              LOG_ERROR (\"Out of memory with %u sections\", info->num_sections);\n              return error | DWG_ERR_OUTOFMEM;\n            }\n          prev_address = 0;\n\n          for (j = 0; j < info->num_sections; j++)\n            {\n              struct _section_page\n              { /* unused */\n                int32_t number;\n                uint32_t size;\n                uint64_t address;\n              } page;\n              /* endian specific code: */\n              bfr_read (&page, &ptr, 16);\n#if 0\n              section_number = *((int32_t*)ptr);     // Index into SectionMap\n              data_size      = *((uint32_t*)ptr + 1);\n              address        = *((uint64_t*)ptr + 2); // TODO avoid alignment ubsan\n              //address   = *((uint32_t*)ptr + 2);\n              //address <<= 32;\n              //address  += *((uint32_t*)ptr + 3);\n              ptr += 16; /* 4*4 */\n#endif\n              sum_decomp += page.size; /* TODO: uncompressed size */\n#if 0\n              if (page.address < sum_decomp)\n                {\n                  /* ODA: \"If the start offset is smaller than the sum of the decompressed\n                   * size of all previous pages, then this page is to be preceded by\n                   * zero pages until this condition is met. */\n                  LOG_WARN(\"address %lu < sum_decomp %lu\", page.address, sum_decomp)\n                }\n#endif\n              info->sections[j] = find_section (dwg, page.number);\n\n              if (page.number < 0)\n                { // gap/unused data\n                  LOG_TRACE (\"Page: %4\" PRId32 \" (-)\", page.number)\n                  info->num_sections++;\n                  info->sections\n                      = realloc (info->sections,\n                                 info->num_sections * sizeof (Dwg_Section *));\n                  info->sections[info->num_sections - 1] = NULL;\n                }\n              else if (page.address < prev_address)\n                {\n                  LOG_TRACE (\"Page: %4\" PRId32 \" (a)\", page.number)\n                }\n              else if (info->sections[0]\n                       && page.number > (int32_t) (\n                              info->num_sections + info->sections[0]->number))\n                {\n                  // for [7] ptr+160 seems to be AcDb:ObjFreeSpace\n                  LOG_INFO (\"Page: %4\" PRId32 \" (n)\", page.number)\n                }\n              else if (!info->sections[j]\n                       && page.number != old_section_number + 1)\n                {\n                  LOG_INFO (\"Page: %4\" PRId32 \" (b)\", page.number)\n                  LOG_TRACE (\" size: %5\" PRIu32, page.size) // compressed\n                  LOG_TRACE (\" address: 0x%\" PRIx64, page.address)\n                  if (info->sections[j])\n                    LOG_TRACE (\" info: 0x%\" PRIx64, info->sections[j]->address);\n                  LOG_TRACE (\"\\n\")\n                  ptr -= 16;\n                  break;\n                }\n              else\n                {\n                  LOG_TRACE (\"Page: %4\" PRId32 \"    \", page.number)\n                  old_section_number = page.number;\n                  prev_address = page.address;\n                }\n              LOG_TRACE (\" size: %5\" PRIu32, page.size) // compressed\n              LOG_TRACE (\" address: 0x%\" PRIx64, page.address)\n              if (info->sections[j])\n                LOG_TRACE (\" info: 0x%\" PRIx64, info->sections[j]->address);\n              LOG_TRACE (\"\\n\")\n            }\n        }\n      else\n        {\n          LOG_ERROR (\"Section count %u in area %d too high! Skipping\",\n                     info->num_sections, i);\n          info->num_sections = 0;\n          free (decomp);\n          return error | DWG_ERR_VALUEOUTOFBOUNDS;\n        }\n    }\n  free (decomp);\n  return error;\n}\n\n/* Encrypted Section Header */\n#pragma pack(1)\ntypedef union _encrypted_section_header\n{\n  uint32_t long_data[8];\n  unsigned char char_data[32];\n  struct\n  {\n    uint32_t tag;\n    uint32_t section_type;\n    uint32_t data_size;\n    uint32_t section_size;\n    uint32_t address;\n    uint32_t unknown;\n    uint32_t checksum_1;\n    uint32_t checksum_2;\n  } fields;\n} encrypted_section_header;\n\nstatic int\nread_2004_compressed_section (Bit_Chain *dat, Dwg_Data *restrict dwg,\n                              Bit_Chain *sec_dat, BITCODE_RL section_type)\n{\n  uint32_t address, sec_mask, initial_address;\n  uint32_t max_decomp_size;\n  Dwg_Section_Info *info = NULL;\n  encrypted_section_header es;\n  BITCODE_RC *decomp;\n  BITCODE_BL i, j;\n  int error = 0;\n\n  for (i = 0; i < dwg->header.section_infohdr.num_desc && !info; ++i)\n    {\n      if (dwg->header.section_info[i].type == section_type)\n        {\n          info = &dwg->header.section_info[i];\n          break;\n        }\n    }\n  sec_dat->chain = NULL; // fixes double-free\n  if (!info)\n    {\n      LOG_WARN (\"Failed to find section_info[\" FORMAT_BL \"] with type 0x%x\", i,\n                section_type);\n      return DWG_ERR_SECTIONNOTFOUND;\n    }\n  else\n    {\n      LOG_TRACE (\"\\nFound section_info[\" FORMAT_BL\n                 \"] %s type 0x%x with %d sections (%scompressed):\\n\",\n                 i, info->name, section_type, info->num_sections,\n                 info->compressed == 2 ? \"\" : \"un\");\n    }\n\n  max_decomp_size = info->num_sections * info->max_decomp_size;\n  if (max_decomp_size == 0)\n    {\n      LOG_ERROR (\"Section %s count or max decompression size is zero. \"\n                 \"Sections: %u, Max size: %u\",\n                 info->name, info->num_sections, info->max_decomp_size);\n      return DWG_ERR_INVALIDDWG;\n    }\n  decomp = (BITCODE_RC *)calloc (max_decomp_size, sizeof (BITCODE_RC));\n  if (!decomp)\n    {\n      LOG_ERROR (\"Out of memory with %u sections\", info->num_sections);\n      return DWG_ERR_OUTOFMEM;\n    }\n  initial_address = info->sections[0] ? info->sections[0]->address : 0;\n  sec_dat->bit = 0;\n  sec_dat->byte = 0;\n  sec_dat->version = dat->version;\n  sec_dat->from_version = dat->from_version;\n  sec_dat->chain = decomp;\n\n  for (i = 0; i < info->num_sections; ++i)\n    {\n      if (!info->sections[i])\n        {\n          LOG_WARN (\"Skip empty section %u %s\", i, info->name);\n          continue;\n        }\n      address = info->sections[i]->address;\n      dat->byte = address;\n      bit_read_fixed (dat, es.char_data, 32);\n\n      //? if encrypted properties: security_type & 2 ??\n      sec_mask = 0x4164536b ^ address;\n      for (j = 0; j < 8; ++j)\n        es.long_data[j] ^= sec_mask;\n\n      LOG_INFO (\"=== Section %s (%u) @%u ===\\n\", info->name, i, address)\n      if (es.fields.tag != 0x4163043b)\n        {\n          LOG_WARN (\"Section Tag:      0x%x  (should be 0x4163043b)\",\n                    (unsigned)es.fields.tag);\n        }\n      else\n        {\n          LOG_INFO (\"Section Tag:      0x%x\\n\", (unsigned)es.fields.tag);\n        }\n      LOG_INFO (\"Section Type:     %u\\n\", (unsigned)es.fields.section_type)\n      // this is the number of bytes that is read in decompress_R2004_section\n      // (+ 2bytes)\n      LOG_INFO (\"Data size:        0x%x/%u\\n\", (unsigned)es.fields.data_size,\n                (unsigned)es.fields.data_size)\n      LOG_INFO (\"Comp data size:   0x%x\\n\", (unsigned)es.fields.section_size)\n      LOG_TRACE (\"StartOffset:      0x%x\\n\", (unsigned)es.fields.address)\n      LOG_HANDLE (\"Unknown:          0x%x\\n\", (unsigned)es.fields.unknown)\n      LOG_HANDLE (\"Checksum1:        0x%x\\n\", (unsigned)es.fields.checksum_1)\n      LOG_HANDLE (\"Checksum2:        0x%x\\n\", (unsigned)es.fields.checksum_2)\n      LOG_TRACE (\"Section start:    %lu\\n\\n\", dat->byte);\n\n      // GH #126 part 4\n      // LOG_INSANE (\"i:                     %u\\n\", i)\n      // LOG_INSANE (\"decomp:                %p\\n\", decomp)\n      // LOG_INSANE (\"info->max_decomp_size: %u\\n\", info->max_decomp_size)\n      // LOG_INSANE (\"max_decomp_size:       %u\\n\", max_decomp_size)\n      // LOG_INSANE (\"bytes_left:            %d\\n\",\n      //            max_decomp_size - (i * info->max_decomp_size))\n\n      // check if compressed at all\n      if (info->compressed == 2)\n        {\n          error = decompress_R2004_section (\n              dat, &decomp[i * info->max_decomp_size],       // offset\n              max_decomp_size - (i * info->max_decomp_size), // bytes left\n              es.fields.data_size);\n          if (error > DWG_ERR_CRITICAL)\n            {\n              sec_dat->chain = NULL; // fix double-free\n              free (decomp);\n              return error;\n            }\n          sec_dat->size = max_decomp_size;\n        }\n      else\n        {\n          if (!(info->size <= max_decomp_size)\n              || !((unsigned long)(address + es.fields.address + 32\n                                   + info->size)\n                   <= dat->size))\n            {\n              sec_dat->chain = NULL;\n              free (decomp);\n              return DWG_ERR_INVALIDDWG;\n            }\n          memcpy (&decomp[i * info->size],\n                  &dat->chain[address + es.fields.address + 32], info->size);\n          sec_dat->size = info->size;\n        }\n    }\n\n  return error;\n}\n\n/* R2004, 2010+ Class Section\n */\nstatic int\nread_2004_section_classes (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)\n{\n  BITCODE_RL size;\n  BITCODE_BS max_num, i;\n  unsigned long int num_objects, dwg_version, maint_version, unknown;\n  char c;\n  int error;\n  Bit_Chain sec_dat = { 0 }, str_dat = { 0 };\n\n  error = read_2004_compressed_section (dat, dwg, &sec_dat, SECTION_CLASSES);\n  if (error >= DWG_ERR_CRITICAL)\n    {\n      LOG_ERROR (\"Failed to read compressed %s section\", \"Classes\");\n      if (sec_dat.chain)\n        free (sec_dat.chain);\n      return error;\n    }\n\n  if (bit_search_sentinel (&sec_dat, dwg_sentinel (DWG_SENTINEL_CLASS_BEGIN)))\n    {\n      BITCODE_RL bitsize = 0;\n      LOG_TRACE (\"\\nClasses\\n-------------------\\n\")\n      size = bit_read_RL (&sec_dat); // size of class data area\n      LOG_TRACE (\"size: \" FORMAT_RL \" [RL]\\n\", size)\n      if ((dat->version >= R_2010 && dwg->header.maint_version > 3)\n          || dat->version >= R_2018)\n        {\n          BITCODE_RL hsize = bit_read_RL (&sec_dat);\n          LOG_TRACE (\"hsize: \" FORMAT_RL \" [RL]\\n\", hsize)\n        }\n      if (dat->version >= R_2007)\n        {\n          bitsize = bit_read_RL (&sec_dat);\n          LOG_TRACE (\"bitsize: \" FORMAT_RL \" [RL]\\n\", bitsize)\n        }\n      max_num = bit_read_BS (&sec_dat); // Maximum class number\n      LOG_TRACE (\"max_num: \" FORMAT_BS \" [BS]\\n\", max_num)\n      c = bit_read_RC (&sec_dat); // 0x00\n      LOG_HANDLE (\"c: \" FORMAT_RC \" [RC]\\n\", c)\n      c = bit_read_RC (&sec_dat); // 0x00\n      LOG_HANDLE (\"c: \" FORMAT_RC \" [RC]\\n\", c)\n      c = bit_read_B (&sec_dat); // 1\n      LOG_HANDLE (\"c: \" FORMAT_B \" [B]\\n\", c)\n\n      dwg->layout_type = 0;\n      dwg->num_classes = max_num - 499;\n      if (max_num < 500\n          || dwg->num_classes > 100 + (size / sizeof (Dwg_Class)))\n        {\n          LOG_ERROR (\"Invalid max class number %d\", max_num)\n          dwg->num_classes = 0;\n          return DWG_ERR_VALUEOUTOFBOUNDS;\n        }\n      assert (max_num >= 500);\n      // assert (max_num < 5000);\n\n      if (dat->version >= R_2007)\n        section_string_stream (&sec_dat, bitsize, &str_dat);\n\n      dwg->dwg_class\n          = (Dwg_Class *)calloc (dwg->num_classes, sizeof (Dwg_Class));\n      if (!dwg->dwg_class)\n        {\n          LOG_ERROR (\"Out of memory\");\n          if (sec_dat.chain)\n            free (sec_dat.chain);\n          return DWG_ERR_OUTOFMEM;\n        }\n\n      for (i = 0; i < dwg->num_classes; i++)\n        {\n          dwg->dwg_class[i].number = bit_read_BS (&sec_dat);\n          dwg->dwg_class[i].proxyflag = bit_read_BS (&sec_dat);\n          LOG_TRACE (\"-------------------\\n\")\n          LOG_TRACE (\"Number:           %d [BS]\\n\", dwg->dwg_class[i].number)\n          LOG_TRACE (\"Proxyflag:        %x [BS]\\n\", dwg->dwg_class[i].proxyflag)\n          if (dwg->header.version >= R_2007)\n            {\n              dwg->dwg_class[i].appname = (char *)bit_read_TU (&str_dat);\n              dwg->dwg_class[i].cppname = (char *)bit_read_TU (&str_dat);\n              dwg->dwg_class[i].dxfname_u = bit_read_TU (&str_dat);\n              dwg->dwg_class[i].dxfname\n                  = bit_convert_TU (dwg->dwg_class[i].dxfname_u);\n              if (DWG_LOGLEVEL >= DWG_LOGLEVEL_TRACE)\n                {\n                  char *appu8 = bit_convert_TU ((BITCODE_TU)dwg->dwg_class[i].appname);\n                  LOG_TRACE (\"Application name: \\\"%s\\\" [TU 0 (as utf-8)]\\n\", appu8);\n                  //LOG_TRACE_TU (\"Application name\", dwg->dwg_class[i].appname, 0)\n                  LOG_TRACE_TU (\"C++ class name  \", dwg->dwg_class[i].cppname, 0)\n                  LOG_TRACE_TU (\"DXF record name \", dwg->dwg_class[i].dxfname_u, 0)\n                  free (appu8);\n                }\n            }\n          else\n            {\n              dwg->dwg_class[i].appname = bit_read_TV (&sec_dat);\n              dwg->dwg_class[i].cppname = bit_read_TV (&sec_dat);\n              dwg->dwg_class[i].dxfname = bit_read_TV (&sec_dat);\n              LOG_TRACE (\"Application name: %s [TV]\\n\", dwg->dwg_class[i].appname)\n              LOG_TRACE (\"C++ class name:   %s [TV]\\n\", dwg->dwg_class[i].cppname)\n              LOG_TRACE (\"DXF record name:  %s [TV]\\n\", dwg->dwg_class[i].dxfname)\n            }\n          dwg->dwg_class[i].wasazombie = bit_read_B (&sec_dat);\n          dwg->dwg_class[i].item_class_id = bit_read_BS (&sec_dat);\n          LOG_TRACE (\"Class ID:         0x%x [BS] \"\n                     \"(0x1f3 for object, 0x1f2 for entity)\\n\",\n                     dwg->dwg_class[i].item_class_id)\n\n          dwg->dwg_class[i].num_instances = bit_read_BL (&sec_dat);\n          dwg->dwg_class[i].dwg_version = bit_read_BS (&sec_dat);\n          dwg->dwg_class[i].maint_version = bit_read_BS (&sec_dat);\n          dwg->dwg_class[i].unknown_1 = bit_read_BL (&sec_dat);\n          dwg->dwg_class[i].unknown_1 = bit_read_BL (&sec_dat);\n          LOG_TRACE (\"num_instances:    %u\\n\", dwg->dwg_class[i].num_instances)\n          LOG_HANDLE (\"dwg version:      %u (%u)\\n\",\n                      dwg->dwg_class[i].dwg_version,\n                      dwg->dwg_class[i].maint_version)\n          LOG_HANDLE (\"unknown:          %u %u\\n\", dwg->dwg_class[i].unknown_1,\n                      dwg->dwg_class[i].unknown_2)\n\n          if (dwg->dwg_class[i].dxfname\n              && strEQ (dwg->dwg_class[i].dxfname, \"LAYOUT\"))\n            dwg->layout_type = dwg->dwg_class[i].number;\n        }\n    }\n  else\n    {\n      LOG_ERROR (\"Failed to find class section sentinel\");\n      free (sec_dat.chain);\n      return DWG_ERR_CLASSESNOTFOUND;\n    }\n\n  // then RS: CRC\n  // dwg_sentinel(DWG_SENTINEL_CLASS_END)\n  // SINCE(R_2004) 8 unknown bytes\n\n  free (sec_dat.chain);\n  return 0;\n}\n\n/* R2004, 2010+ Header Section\n */\nstatic int\nread_2004_section_header (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)\n{\n  int error;\n  Bit_Chain sec_dat = { 0 };\n\n  sec_dat.opts = dwg->opts & DWG_OPTS_LOGLEVEL;\n  error = read_2004_compressed_section (dat, dwg, &sec_dat, SECTION_HEADER);\n  if (error >= DWG_ERR_CRITICAL)\n    {\n      LOG_ERROR (\"Failed to read compressed %s section\", \"Header\");\n      if (sec_dat.chain)\n        free (sec_dat.chain);\n      return error;\n    }\n\n  if (bit_search_sentinel (&sec_dat,\n                           dwg_sentinel (DWG_SENTINEL_VARIABLE_BEGIN)))\n    {\n      LOG_TRACE (\"\\nHeader\\n-------------------\\n\")\n      dwg->header_vars.size = bit_read_RL (&sec_dat);\n      LOG_TRACE (\"size: \" FORMAT_RL \" [RL]\\n\", dwg->header_vars.size);\n      PRE (R_2007)\n      {\n        error\n            |= dwg_decode_header_variables (&sec_dat, &sec_dat, &sec_dat, dwg);\n      }\n      else\n      {\n        Bit_Chain hdl_dat, str_dat;\n        BITCODE_RL endbits = 160; // start bit: 16 sentinel + 4 size\n        hdl_dat = sec_dat;\n        str_dat = sec_dat;\n        if (dwg->header.maint_version > 3 || dat->version >= R_2018)\n          {\n            dwg->header_vars.bitsize_hi = bit_read_RL (&sec_dat);\n            LOG_TRACE (\"bitsize_hi: \" FORMAT_RL \" [RL]\\n\",\n                       dwg->header_vars.bitsize_hi)\n            endbits += 32; // 192\n          }\n        dwg->header_vars.bitsize = bit_read_RL (&sec_dat);\n        LOG_TRACE (\"bitsize: \" FORMAT_RL \" [RL]\\n\", dwg->header_vars.bitsize)\n        endbits += dwg->header_vars.bitsize;\n        bit_set_position (&hdl_dat, endbits);\n        section_string_stream (&sec_dat, dwg->header_vars.bitsize, &str_dat);\n        error\n            |= dwg_decode_header_variables (&sec_dat, &hdl_dat, &str_dat, dwg);\n      }\n    }\n  free (sec_dat.chain);\n  return error;\n}\n\n/* R2004, 2010+ Handles Section\n */\nstatic int\nread_2004_section_handles (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)\n{\n  Bit_Chain obj_dat = { NULL }, hdl_dat = { NULL };\n  BITCODE_RS section_size = 0;\n  long unsigned int endpos;\n  int error;\n\n  obj_dat.opts = hdl_dat.opts = dwg->opts & DWG_OPTS_LOGLEVEL;\n  error = read_2004_compressed_section (dat, dwg, &obj_dat, SECTION_OBJECTS);\n  if (error >= DWG_ERR_CRITICAL || !obj_dat.chain)\n    {\n      LOG_ERROR (\"Failed to read compressed %s section\", \"AcDbObjects\");\n      if (obj_dat.chain)\n        free (obj_dat.chain);\n      return error;\n    }\n\n  error = read_2004_compressed_section (dat, dwg, &hdl_dat, SECTION_HANDLES);\n  if (error >= DWG_ERR_CRITICAL || !hdl_dat.chain)\n    {\n      LOG_ERROR (\"Failed to read compressed %s section\", \"Handles\");\n      free (obj_dat.chain);\n      if (hdl_dat.chain)\n        free (hdl_dat.chain);\n      return error;\n    }\n\n  endpos = hdl_dat.byte + hdl_dat.size;\n  dwg->num_objects = 0;\n\n  do\n    {\n      long unsigned int last_offset;\n      // long unsigned int last_handle;\n      long unsigned int oldpos = 0;\n      long unsigned int startpos = hdl_dat.byte;\n      BITCODE_BL max_handles = hdl_dat.size * 2;\n      uint16_t crc1, crc2;\n\n      section_size = bit_read_RS_LE (&hdl_dat);\n      LOG_TRACE (\"\\nHandles page size: %u [RS_LE]\\n\", section_size);\n      /* ***********************************************\n       * ODA p. 251 \"Note that each section is cut off at a maximum length of\n       * 2032.\" BUT in fact files exist with 2036 section size */\n      if (section_size > 2040)\n        {\n          LOG_ERROR (\"Object-map/handles page size greater than 2040!\");\n          free (hdl_dat.chain);\n          free (obj_dat.chain);\n          return DWG_ERR_VALUEOUTOFBOUNDS;\n        }\n\n      last_offset = 0;\n      while ((long)(hdl_dat.byte - startpos) < (long)section_size)\n        {\n          int added;\n          BITCODE_UMC handleoff;\n          BITCODE_MC offset;\n          BITCODE_BL last_handle = dwg->num_objects\n            ? dwg->object[dwg->num_objects - 1].handle.value : 0;\n\n          oldpos = hdl_dat.byte;\n          // the offset from the previous handle. default: 1, unsigned\n          handleoff = bit_read_UMC (&hdl_dat);\n          // the offset from the previous address. default: obj->size\n          offset = bit_read_MC (&hdl_dat);\n          if (!handleoff || handleoff > max_handles - last_handle)\n            {\n              BITCODE_MC prevsize = dwg->num_objects\n                ? dwg->object[dwg->num_objects - 1].size + 4 : 0;\n              LOG_WARN (\"Ignore invalid handleoff (@%lu)\", oldpos)\n              if (offset == 1 ||\n                  (offset > 0 && offset < prevsize && prevsize > 0) ||\n                  (offset < 0 && labs((long)offset) < prevsize && prevsize > 0))\n                {\n                  if (offset != prevsize)\n                    LOG_ERROR (\"Invalid offset: %ld [MC]\", offset);\n                  offset = prevsize;\n                  LOG_WARN (\"Recover invalid offset to %ld\", offset);\n                }\n            }\n          last_offset += offset;\n          LOG_TRACE (\"\\n< Next object: %lu \", (unsigned long)dwg->num_objects)\n          LOG_HANDLE (\"Handleoff: %lX [UMC] \"\n                      \"Offset: \" FORMAT_MC \" [MC] @%lu\\n\",\n                      handleoff, offset, last_offset);\n\n          if (hdl_dat.byte == oldpos) // ?? completely unrelated\n            break;\n\n          added = dwg_decode_add_object (dwg, &obj_dat, &obj_dat, last_offset);\n          if (added > 0)\n            error |= added;\n          // else re-allocated\n          // we don't stop encoding on single errors, but we sum them all up\n          // as combined bitmask\n        }\n\n      if (hdl_dat.byte == oldpos)\n        break;\n#if 0\n      if (!bit_check_CRC(&hdl_dat, startpos, 0xC0C1))\n        error |= DWG_ERR_WRONGCRC;\n      //LOG_WARN(\"Handles section CRC mismatch at offset %lx\", startpos);\n#else\n      crc1 = bit_calc_CRC (0xC0C1, &(hdl_dat.chain[startpos]),\n                           hdl_dat.byte - startpos);\n      crc2 = bit_read_RS_LE (&hdl_dat);\n      LOG_TRACE (\"Handles page crc: %04X [RS_LE]\\n\", crc2);\n      if (crc1 == crc2)\n        {\n          LOG_INSANE (\"Handles page CRC: %04X from %lu-%lu=%ld\\n\", crc2,\n                      startpos, hdl_dat.byte - 2, hdl_dat.byte - startpos - 2);\n        }\n      else\n        {\n          LOG_WARN (\n              \"Handles page CRC: %04X vs calc. %04X from %lu-%lu=%ld\\n\",\n              crc2, crc1, startpos, hdl_dat.byte - 2, hdl_dat.byte - startpos - 2);\n          error |= DWG_ERR_WRONGCRC;\n        }\n#endif\n\n      if (hdl_dat.byte >= endpos)\n        break;\n    }\n  while (section_size > 2);\n\n  free (hdl_dat.chain);\n  free (obj_dat.chain);\n  return error;\n}\n\n// may return OUTOFBOUNDS, needs to free the chain then\nstatic int\nsummaryinfo_private (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)\n{\n  Bit_Chain *str_dat = dat;\n  struct Dwg_SummaryInfo *_obj = &dwg->summaryinfo;\n  Dwg_Object *obj = NULL;\n  int error = 0;\n\n  // clang-format off\n  #include \"summaryinfo.spec\"\n  // clang-format on\n\n  return error;\n}\n\n/* R2004, 2010+ SummaryInfo Section\n */\nstatic int\nread_2004_section_summary (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)\n{\n  Bit_Chain old_dat, sec_dat = { 0 };\n  int error = 0;\n\n  // not compressed, page size: 0x100\n  error\n      = read_2004_compressed_section (dat, dwg, &sec_dat, SECTION_SUMMARYINFO);\n  if (error >= DWG_ERR_CRITICAL)\n    {\n      LOG_ERROR (\"Failed to read uncompressed %s section\", \"SummaryInfo\");\n      return error;\n    }\n  if (dwg->header.summaryinfo_address != (BITCODE_RL)dat->byte)\n    LOG_WARN (\"summaryinfo_address mismatch: \" FORMAT_RL \" != %lu\",\n              dwg->header.summaryinfo_address, dat->byte);\n  LOG_TRACE (\"SummaryInfo\\n-------------------\\n\")\n  old_dat = *dat;\n  dat = &sec_dat; // restrict in size\n\n  error = summaryinfo_private (dat, dwg);\n\n  if (sec_dat.chain)\n    free (sec_dat.chain);\n  *dat = old_dat; // unrestrict\n  return error;\n}\n\nstatic int\nread_2004_section_preview (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)\n{\n  Bit_Chain sec_dat = { 0 };\n  int error = 0;\n  BITCODE_RL size;\n  unsigned char *sentinel;\n\n  // not compressed, num_sections: 1\n  error = read_2004_compressed_section (dat, dwg, &sec_dat, SECTION_PREVIEW);\n  if (error >= DWG_ERR_CRITICAL)\n    {\n      LOG_ERROR (\"Failed to read uncompressed %s section\", \"Preview\");\n      if (sec_dat.chain)\n        free (sec_dat.chain);\n      return error;\n    }\n\n  if (dwg->header.thumbnail_address != (BITCODE_RL)dat->byte)\n    LOG_WARN (\"thumbnail_address mismatch: \" FORMAT_RL \" != %lu\",\n              dwg->header.thumbnail_address, dat->byte);\n  LOG_TRACE (\"Preview\\n-------------------\\n\");\n  if (!sec_dat.chain || sec_dat.size < 16)\n    {\n      LOG_WARN (\"Empty thumbnail\");\n      if (sec_dat.chain)\n        free (sec_dat.chain);\n      return error;\n    }\n  sentinel = dwg_sentinel (DWG_SENTINEL_THUMBNAIL_BEGIN);\n  if (memcmp (sentinel, sec_dat.chain, 16))\n    {\n      LOG_WARN (\"thumbnail sentinel mismatch\");\n      free (sec_dat.chain);\n      return error;\n    }\n\n  dwg->thumbnail.size = sec_dat.size - 32; // 2x sentinel\n  dwg->thumbnail.chain = sec_dat.chain;\n  dwg->thumbnail.byte = 16; // sentinel\n\n  dwg_bmp (dwg, &size);\n  if (abs ((int)((long)size - (long)dwg->thumbnail.size))\n      > 200) // various headers\n    LOG_WARN (\"thumbnail.size mismatch: %lu != \" FORMAT_RL,\n              dwg->thumbnail.size, size);\n\n  dat->byte += dwg->thumbnail.size;\n\n  return error;\n}\n\n// static int read_2004_section_vbaproject (dat, dwg)\n// static int read_2004_section_appinfo (dat, dwg)\n// static int read_2004_section_filedeplist (dat, dwg)\n// static int read_2004_section_security (dat, dwg)\n// static int read_2004_section_revhistory (dat, dwg)\n\nstatic void\ndecrypt_R2004_header (Bit_Chain *restrict dat, BITCODE_RC *restrict decrypted,\n                      unsigned long size, Dwg_Data *restrict dwg)\n{\n  unsigned int rseed = 1;\n  unsigned i;\n\n  /* Decrypt */\n  for (i = 0; i < size; i++)\n    {\n      rseed *= 0x343fd;\n      rseed += 0x269ec3;\n      decrypted[i] = bit_read_RC (dat) ^ (rseed >> 0x10);\n    }\n}\n\nGCC30_DIAG_IGNORE (-Wformat-nonliteral)\nstatic int\ndecode_R2004_header (Bit_Chain *restrict file_dat, Dwg_Data *restrict dwg)\n{\n  int error = 0;\n  Dwg_Object *obj = NULL;\n  struct Dwg_R2004_Header *_obj = &dwg->r2004_header;\n  Bit_Chain *hdl_dat = file_dat;\n\n  {\n    const unsigned long size = sizeof (struct Dwg_R2004_Header);\n    BITCODE_RC decrypted_data[size];\n    Bit_Chain decrypted_header_dat = *file_dat;\n    Bit_Chain *dat;\n\n    decrypted_header_dat.size = size;\n    decrypted_header_dat.chain = decrypted_data;\n    decrypted_header_dat.byte = decrypted_header_dat.bit = 0;\n\n    file_dat->byte = 0x80;\n    file_dat->bit = 0;\n    decrypt_R2004_header (file_dat, decrypted_data, size, dwg);\n\n    dat = &decrypted_header_dat;\n    dat->bit = dat->byte = 0;\n    LOG_TRACE (\"\\n#### 2004 File Header ####\\n\");\n    // clang-format off\n    #include \"r2004_file_header.spec\"\n    // clang-format on\n  }\n\n  /*-------------------------------------------------------------------------\n   * Section Page Map\n   */\n  {\n    Bit_Chain *dat = file_dat;\n    dat->byte = dwg->r2004_header.section_map_address + 0x100;\n\n    LOG_TRACE (\"\\n=== Read System Section (Section Page Map) ===\\n\\n\")\n    FIELD_RLx (section_type, 0);\n    if (FIELD_VALUE (section_type) != 0x41630e3b)\n      {\n        LOG_ERROR (\"Invalid System Section Page Map type 0x%x != 0x41630e3b\",\n                   FIELD_VALUE (section_type));\n        return DWG_ERR_SECTIONNOTFOUND;\n      }\n    FIELD_RL (decomp_data_size, 0);\n    FIELD_RL (comp_data_size, 0);\n    FIELD_RL (compression_type, 0);\n    FIELD_RLx (checksum, 0); // see dwg_section_page_checksum()\n  }\n\n  return error;\n}\n\n/* for 2004 and 2010+ */\nstatic int\ndecode_R2004 (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)\n{\n  int j, error = 0;\n  Dwg_Section *section;\n\n  {\n    struct Dwg_Header *_obj = &dwg->header;\n    Dwg_Object *obj = NULL;\n    Bit_Chain *hdl_dat = dat;\n    int i;\n\n    dat->byte = 0x06;\n    // clang-format off\n    #include \"header.spec\"\n    // clang-format on\n  }\n\n  error |= decode_R2004_header (dat, dwg);\n  if (error > DWG_ERR_CRITICAL)\n    return error;\n\n  error |= read_R2004_section_map (dat, dwg);\n  if (!dwg->header.section || error >= DWG_ERR_CRITICAL)\n    {\n      LOG_ERROR (\"Failed to read R2004 Section Page Map.\")\n      return error | DWG_ERR_INTERNALERROR;\n    }\n\n  /*-------------------------------------------------------------------------\n   * Section Info\n   */\n  section = find_section (dwg, dwg->r2004_header.section_info_id);\n  if (section)\n    {\n      Dwg_Object *obj = NULL;\n      Dwg_Section *_obj = section;\n      LOG_TRACE (\"\\n=== Data Section (Section Info %d) @%lx ===\\n\",\n                 dwg->r2004_header.section_info_id, (unsigned long)section->address)\n      dat->byte = section->address;\n\n      FIELD_RLx (section_type, 0);\n      if (FIELD_VALUE (section_type) != 0x4163003b)\n        {\n          LOG_ERROR (\"Invalid Data Section Page Map type 0x%x != 0x4163003b\",\n                     FIELD_VALUE (section_type));\n          return DWG_ERR_SECTIONNOTFOUND;\n        }\n      FIELD_RL (decomp_data_size, 0);\n      FIELD_RL (comp_data_size, 0);\n      FIELD_RL (compression_type, 0);\n      FIELD_RLx (checksum, 0);\n\n      // Data section map, par 4.5\n      error |= read_R2004_section_info (dat, dwg, _obj->comp_data_size,\n                                        _obj->decomp_data_size);\n    }\n  else\n    error |= DWG_ERR_SECTIONNOTFOUND;\n\n  error |= read_2004_section_header (dat, dwg);\n  if (dwg->header.summaryinfo_address)\n    error |= read_2004_section_summary (dat, dwg);\n  error |= read_2004_section_classes (dat, dwg);\n  error |= read_2004_section_handles (dat, dwg);\n  if (dwg->header.thumbnail_address)\n    error |= read_2004_section_preview (dat, dwg);\n  // TODO:\n  // if (dwg->header.vbaproj_address)\n  //  error |= read_2004_section_vbaproject (dat, dwg);\n  // error |= read_2004_section_appinfo (dat, dwg);\n  // error |= read_2004_section_filedeplist (dat, dwg);\n  // error |= read_2004_section_security (dat, dwg);\n  // error |= read_2004_section_revhistory (dat, dwg);\n\n  /* Clean up. XXX? Need this to write the sections, at least the name and\n   * type\n   */\n#if 0\n  if (dwg->header.section_info != NULL)\n    {\n      unsigned u;\n      for (u = 0; u < dwg->header.num_infos; ++u)\n        if (dwg->header.section_info[u].sections != 0)\n          free(dwg->header.section_info[u].sections);\n\n      free(dwg->header.section_info);\n      dwg->header.num_infos = 0;\n    }\n#endif\n\n  LOG_INFO (\"\\nnum_objects: %lu\\n\", (unsigned long)dwg->num_objects)\n  LOG_TRACE (\"num_object_refs: %lu\\n\", (unsigned long)dwg->num_object_refs)\n  LOG_TRACE (\"Resolving pointers from ObjectRef vector:\\n\")\n  error |= resolve_objectref_vector (dat, dwg);\n  return error;\n}\n\nstatic int\ndecode_R2007 (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)\n{\n  Bit_Chain hdl_dat = { 0 };\n  int error;\n\n  hdl_dat = *dat;\n  {\n    int i;\n    struct Dwg_Header *_obj = &dwg->header;\n    Dwg_Object *obj = NULL;\n\n    dat->byte = 0x06;\n    // clang-format off\n    #include \"header.spec\"\n    // clang-format on\n  }\n\n  // this includes classes, header, handles + objects\n  error = read_r2007_meta_data (dat, &hdl_dat, dwg);\n\n  LOG_INFO (\"\\nnum_objects: %lu\\n\", (unsigned long)dwg->num_objects)\n  LOG_TRACE (\"num_object_refs: %lu\\n\", (unsigned long)dwg->num_object_refs)\n  if (error >= DWG_ERR_CRITICAL)\n    {\n      LOG_ERROR (\"Failed to read 2007 meta data\")\n      return error;\n    }\n\n  LOG_TRACE (\"Resolving pointers from ObjectRef vector:\\n\")\n  return error | resolve_objectref_vector (dat, dwg);\n}\n\n/*--------------------------------------------------------------------------------\n * Private functions\n *\n * EED \"Extended Entity Data\":\n * There's an array of obj->num_eed obj->eed[] entries.\n * Each eed member has size, handle, the raw[size] buffer and the decoded data.\n * Each obj->eed[].data member is further seperated into DXF+1000 codes, for\n * strings, numbers, points, ...\n * Those subgroups have an empty raw, size, and the prev. handle.\n */\n\nstatic int\need_need_size (BITCODE_BS need, BITCODE_BS have)\n{\n  if (need > have)\n    {\n      LOG_ERROR (\"Invalid EED size %d > %d\", (int)need, (int)have);\n      return 1;\n    }\n  return 0;\n}\n\n#define LOG_POS\n// LOG_INSANE (\" @%lu.%u\\n\", dat->byte, dat->bit)\n\nstatic int\ndwg_decode_eed_data (Bit_Chain *restrict dat, Dwg_Eed_Data *restrict data,\n                     unsigned long int end, BITCODE_BS size)\n{\n  int lenc;\n  BITCODE_BS j;\n  BITCODE_RS lens;\n\n  data->code = bit_read_RC (dat);\n  LOG_TRACE (\"code: %d [RC], \", (int)data->code);\n  switch (data->code)\n    {\n    case 0:\n      PRE (R_2007)\n      {\n        if (eed_need_size (3, size))\n          return DWG_ERR_INVALIDEED;\n        data->u.eed_0.length = lenc = bit_read_RC (dat);\n        data->u.eed_0.codepage = bit_read_RS_LE (dat);\n        if ((long)lenc > size - 4)\n          {\n            LOG_ERROR (\"Invalid EED string len %d, max %d\", lenc,\n                       (int)size - 4)\n            dat->byte = end;\n            break;\n#if 0\n            obj->num_eed = 0;\n            if (obj->eed[idx].size)\n              free(obj->eed[idx].raw);\n            free(obj->eed[idx].data);\n            free(obj->eed);\n            obj->eed = NULL;\n            dat->byte = end;\n            return DWG_ERR_INVALIDEED; /* may not continue */\n#endif\n          }\n        /* code:1 + len:1 + cp:2 */\n        if (eed_need_size (lenc + 3, size))\n          return DWG_ERR_INVALIDEED;\n        bit_read_fixed (dat, (BITCODE_RC *)data->u.eed_0.string, lenc);\n        data->u.eed_0.string[lenc] = '\\0';\n        LOG_TRACE (\"string: len=%d [RC] cp=%d [RS_LE] \\\"%s\\\" [TF]\\n\", (int)lenc,\n                   (int)data->u.eed_0.codepage, data->u.eed_0.string);\n      }\n      LATER_VERSIONS\n      {\n        if (eed_need_size (2, size))\n          return DWG_ERR_INVALIDEED;\n        data->u.eed_0_r2007.length = lens = bit_read_RS (dat);\n        if (eed_need_size ((lens * 2) + 2, size))\n          return DWG_ERR_INVALIDEED;\n        /* code:1 + len:2 NUL? */\n        for (j = 0; j < MIN (lens, (size - 3) / 2); j++)\n          data->u.eed_0_r2007.string[j] = bit_read_RS_LE (dat);\n          // data->u.eed_0_r2007.string[j] = 0; //already calloc'ed\n#ifdef _WIN32\n        LOG_TRACE (\"wstring: len=%d [RS] \\\"\" FORMAT_TU \"\\\" [TU]\\n\",\n                   (int)lens, data->u.eed_0_r2007.string);\n#else\n        if (DWG_LOGLEVEL >= DWG_LOGLEVEL_TRACE)\n          {\n            char *u8 = bit_convert_TU (data->u.eed_0_r2007.string);\n            LOG_TRACE (\"wstring: len=%d [RS] \\\"%s\\\" [TU]\\n\",\n                       (int)lens, u8);\n            free (u8);\n          }\n#endif\n      }\n      break;\n    case 2:\n      if (eed_need_size (1, size))\n        return DWG_ERR_INVALIDEED;\n      data->u.eed_2.byte = bit_read_RC (dat);\n      LOG_TRACE (\"byte: \" FORMAT_RC \" [RC]\\n\", data->u.eed_2.byte);\n      break;\n    case 3:\n      if (eed_need_size (4, size))\n        return DWG_ERR_INVALIDEED;\n      data->u.eed_3.layer = bit_read_RL (dat);\n      LOG_TRACE (\"layer: \" FORMAT_RL \" [RL]\\n\", data->u.eed_3.layer);\n      break;\n    case 4:\n      if (eed_need_size (1, size))\n        return DWG_ERR_INVALIDEED;\n      data->u.eed_4.length = lenc = bit_read_RC (dat);\n      if (eed_need_size (lenc + 1, size))\n        return DWG_ERR_INVALIDEED;\n      /* code:1 + len:1 */\n      for (j = 0; j < MIN (lenc, size - 2); j++)\n        data->u.eed_4.data[j] = bit_read_RC (dat);\n      LOG_TRACE (\"binary[%d] \\\"%s\\\" [TF]\\n\", j-1, data->u.eed_4.data);\n      break;\n    case 5:\n      if (eed_need_size (8, size))\n        return DWG_ERR_INVALIDEED;\n      data->u.eed_5.entity = bit_read_RLL (dat);\n      LOG_TRACE (\"entity: 0x%\" PRIx64 \" [RLL]\\n\", data->u.eed_5.entity);\n      break;\n    case 10:\n    case 11:\n    case 12:\n    case 13:\n    case 14:\n    case 15:\n      if (eed_need_size (3 * 8, size))\n        return DWG_ERR_INVALIDEED;\n      data->u.eed_10.point.x = bit_read_RD (dat);\n      data->u.eed_10.point.y = bit_read_RD (dat);\n      data->u.eed_10.point.z = bit_read_RD (dat);\n      LOG_TRACE (\"3dpoint: (%f, %f, %f) [3RD]\\n\", data->u.eed_10.point.x,\n                 data->u.eed_10.point.y, data->u.eed_10.point.z);\n      break;\n    case 40:\n    case 41:\n    case 42: /*case 43: case 44: case 45: case 46:\ncase 51: case 54:*/\n      if (eed_need_size (8, size))\n        return DWG_ERR_INVALIDEED;\n      data->u.eed_40.real = bit_read_RD (dat);\n      LOG_TRACE (\"real: %f [RD]\\n\", data->u.eed_40.real);\n      break;\n    case 70:\n      if (eed_need_size (2, size))\n        return DWG_ERR_INVALIDEED;\n      data->u.eed_70.rs = bit_read_RS (dat);\n      LOG_TRACE (\"short: \" FORMAT_RS \" [RS]\\n\", data->u.eed_70.rs);\n      break;\n    case 71:\n      if (eed_need_size (4, size))\n        return DWG_ERR_INVALIDEED;\n      data->u.eed_71.rl = bit_read_RL (dat);\n      LOG_TRACE (\"long: \" FORMAT_RL \" [RL]\\n\", data->u.eed_71.rl);\n      break;\n    default:\n      LOG_ERROR (\"unknown EED code %d\", data->code);\n      LOG_POS\n      dat->byte = end;\n      LOG_POS\n      return DWG_ERR_INVALIDEED; /* may continue */\n    }\n  LOG_POS\n\n#ifdef DEBUG\n  // sanity checks\n  if (obj->eed[idx].code == 0 || obj->eed[idx].code == 4)\n    assert (obj->eed[idx].data->u.eed_0.length <= size - 1);\n  if (obj->eed[idx].code == 10) // 3 double\n    assert (size >= 1 + 3 * 8);\n#endif\n\n  return 0;\n}\n\n/* for objects and entities */\nstatic int\ndwg_decode_eed (Bit_Chain *restrict dat, Dwg_Object_Object *restrict obj)\n{\n  BITCODE_BS size;\n  int error = 0;\n  unsigned int idx = 0;\n  Dwg_Data *dwg = obj->dwg;\n  Dwg_Object *_obj;\n  long unsigned int sav_byte = dat->byte;\n\n  if (!dwg)\n    return DWG_ERR_INVALIDEED;\n  _obj = &dwg->object[obj->objid]; /* Note that obj->objid may be 0 */\n  obj->num_eed = 0;\n  while ((size = bit_read_BS (dat)))\n    {\n      int i;\n      BITCODE_BS j;\n      long unsigned int end, offset;\n\n      LOG_TRACE (\"EED[%u] size: \" FORMAT_BS \" [BS]\\n\", idx, size);\n      LOG_POS\n      if (size > _obj->size || dat->byte == sav_byte)\n        {\n          LOG_ERROR (\"Invalid EED size \" FORMAT_BS \" > %u\", size, _obj->size);\n          obj->num_eed = idx;\n          dwg_free_eed (_obj);\n          return DWG_ERR_INVALIDEED; /* may not continue */\n        }\n\n      obj->num_eed = idx + 1;\n      if (idx) /* just extend by one. not in chunks for now */\n        {\n          obj->eed\n              = (Dwg_Eed *)realloc (obj->eed, obj->num_eed * sizeof (Dwg_Eed));\n          memset (&obj->eed[idx], 0, sizeof (Dwg_Eed));\n        }\n      else\n        {\n          obj->eed = (Dwg_Eed *)calloc (1, sizeof (Dwg_Eed));\n        }\n      obj->eed[idx].size = size;\n      error |= bit_read_H (dat, &obj->eed[idx].handle);\n      end = dat->byte + size;\n      if (error)\n        {\n          LOG_ERROR (\"No EED[%d].handle\", idx);\n          obj->eed[idx].size = 0;\n          obj->num_eed--;\n          dat->byte = end; // skip eed\n          continue;        // continue for size = bit_read_BS(dat)\n        }\n      else\n        {\n          LOG_TRACE (\"EED[%u] handle: \" FORMAT_H \"\\n\", idx,\n                     ARGS_H (obj->eed[idx].handle));\n          LOG_POS;\n          if (dat->byte >= dat->size)\n            end = dat->byte;\n          if (_obj->supertype == DWG_SUPERTYPE_OBJECT && _obj->dxfname\n              && strEQc (_obj->dxfname, \"MLEADERSTYLE\"))\n            { // check for is_new_format: has extended data for APPID\n              // \u201cACAD_MLEADERVER\u201d\n              Dwg_Object_Ref ref;\n              ref.obj = NULL;\n              ref.handleref = obj->eed[idx].handle;\n              ref.absolute_ref = 0L;\n              if (dwg_resolve_handleref (&ref, _obj))\n                {\n                  Dwg_Object_APPID_CONTROL *appid = &dwg->appid_control;\n                  // search absref in APPID_CONTROL apps[]\n                  for (j = 0; j < appid->num_entries; j++)\n                    {\n                      if (appid->entries[j]\n                          && appid->entries[j]->absolute_ref\n                                 == ref.absolute_ref)\n                        {\n                          Dwg_Object_MLEADERSTYLE *this\n                              = obj->tio.MLEADERSTYLE;\n                          this->is_new_format = 1;\n                          LOG_TRACE (\n                              \"EED found ACAD_MLEADERVER %lX: new format\\n\",\n                              ref.absolute_ref);\n                        }\n                    }\n                }\n            }\n        }\n\n      sav_byte = dat->byte;\n      obj->eed[idx].raw = bit_read_TF (dat, size);\n      if (DWG_LOGLEVEL < DWG_LOGLEVEL_INSANE)\n        LOG_TRACE (\"EED[0] raw: %d\\n\", size)\n      else\n        LOG_INSANE_TF (obj->eed[idx].raw, size);\n      dat->byte = sav_byte;\n      LOG_POS\n\n      while (dat->byte < end)\n        {\n          obj->eed[idx].data = (Dwg_Eed_Data *)calloc (size + 8, 1);\n          //LOG_TRACE (\"EED[%u] \", idx);\n          error |= dwg_decode_eed_data (dat, obj->eed[idx].data, end, size);\n          // overflow or no advance\n          if (dat->byte >= dat->size || dat->byte == sav_byte)\n            error |= DWG_ERR_INVALIDEED;\n          if (error & DWG_ERR_INVALIDEED)\n            {\n              free (obj->eed[idx].data);\n              LOG_HANDLE (\"        invalid eed[%d]: skip\\n\", idx);\n              LOG_POS\n              obj->eed[idx].data = NULL;\n              obj->num_eed--;\n              dat->byte = end; // skip eed\n              continue;        // continue for next size = bit_read_BS(dat)\n            }\n\n          if (dat->byte < end - 1)\n            {\n              idx++;\n              obj->num_eed = idx + 1;\n              size = (long)(end - dat->byte + 1);\n              LOG_HANDLE (\"        size remaining: %ld\\n\", (long)size);\n              LOG_POS\n\n              obj->eed = (Dwg_Eed *)realloc (obj->eed,\n                                             obj->num_eed * sizeof (Dwg_Eed));\n              obj->eed[idx].handle = obj->eed[idx - 1].handle;\n              obj->eed[idx].size = 0;\n              obj->eed[idx].raw = NULL;\n              sav_byte = dat->byte;\n            }\n          else\n            {\n              break;\n            }\n        }\n      if (obj->eed[idx].raw)\n        dat->byte = end;\n      //LOG_POS\n      idx++;\n    }\n  LOG_HANDLE (\"EED[%u] size: \" FORMAT_BS \" [BS] (end)\\n\", idx, size);\n  LOG_POS\n  return error;\n}\n\n#undef LOG_POS\n\n/** OL2FRAME.data potentially contains as 128 byte of custom specific data:\n  BITCODE_BS oleversion;   DXF 70, always 2\n  char     * oleclient;    DXF 3, e.g. OLE or Paintbrush Picture\n  BITCODE_3RD pt1;         DXF 10, upper left corner\n  BITCODE_3RD pt2;         DXF 11, lower right corner\n\nplus eventually:\n  T link_name; like C:\\My Documents\\excel.xls!Sheet1!R5C3:R8C3\n  RC output_quality;\n  BD rotation\n  BD width;\n  BD height;\n  BD scale_width;\n  BD scale_height;\n\n  The rest of data (&data[128]) contains the MS-CFB, see\n  https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-cfb/53989ce4-7b05-4f8d-829b-d08d6148375b\n  e.g. decodable via py-oletools\n*/\nstatic int\ndwg_decode_ole2 (Dwg_Entity_OLE2FRAME *restrict _obj)\n{\n  Bit_Chain bdat;\n  Bit_Chain *dat = &bdat;\n\n  dat->bit = 0;\n  dat->byte = 0;\n  dat->size = 0x80;\n  dat->chain = (unsigned char *)&_obj->data[0];\n  dat->version = _obj->parent->dwg->header.version;\n\n  // TODO decode the unknowns\n  /* Sample data from TS1.dwg:\n00000000: 8055 40f9 3284 d222 3e40 7436 e0d9 23fd  .U@.2..\">@t6..#.\n00000010: 32c0 0000 0000 0000 0000 d879 8900 cda2  2..........y....\n00000020: 4140 7436 e0d9 23fd 32c0 0000 0000 0000  A@t6..#.2.......\n00000030: 0000 d879 8900 cda2 4140 1420 d4f3 b864  ...y....A@. ...d\n00000040: 36c0 0000 0000 0000 0000 40f9 3284 d222  6.........@.2..\"\n00000050: 3e40 1420 d4f3 b864 36c0 0000 0000 0000  >@. ...d6.......\n00000060: 0000 021f 9114 0100 0000 0001 0000 0100  ................\n00000070: 0000 0100 0000 0000 0100 0000 0090 0500  ................\n=> from the DXF\noleversion 2 [70]\noleclient  \"OLE\" [3] (but the cfb contains PBrush.9)\npt1        (30.13602472538446, -18.98882829402869, 0.0) [10]\npt2        (35.27188116753285, -22.39344715050545, 0.0) [11]\n   */\n  // FIXME decode the fields\n  // FIELD_BS (oleversion, 70);\n  // FIELD_TV (oleclient, 3);\n  // FIELD_2BD (pt1, 10);\n  // FIELD_2BD (pt2, 11);\n  _obj->oleversion = 2;\n  _obj->oleclient = (char *)\"OLE\";\n  _obj->pt1.x = 30.13602472538446;\n  _obj->pt1.y = -18.98882829402869;\n  _obj->pt2.x = 35.27188116753285;\n  _obj->pt2.y = -22.39344715050545;\n\n  // next, see the MS-CFB format\n  dat->bit = 0;\n  dat->byte = 0;\n  dat->size = _obj->data_length;\n  dat->chain = (unsigned char *)&_obj->data[0x80];\n  // TODO\n\n  return 0;\n}\n\n// if to check for the has_strings bit after bitsize\nstatic int\nobj_has_strings (unsigned int type)\n{\n  switch (type)\n    {\n    case DWG_TYPE_TEXT:\n    case DWG_TYPE_ATTRIB:\n    case DWG_TYPE_ATTDEF:\n    case DWG_TYPE_BLOCK:\n      return 1;\n    case DWG_TYPE_ENDBLK:\n    case DWG_TYPE_SEQEND:\n    case DWG_TYPE_INSERT:\n    case DWG_TYPE_MINSERT:\n    case DWG_TYPE_VERTEX_2D:\n    case DWG_TYPE_VERTEX_3D:\n    case DWG_TYPE_VERTEX_MESH:\n    case DWG_TYPE_VERTEX_PFACE:\n    case DWG_TYPE_VERTEX_PFACE_FACE:\n    case DWG_TYPE_POLYLINE_2D:\n    case DWG_TYPE_POLYLINE_3D:\n    case DWG_TYPE_ARC:\n    case DWG_TYPE_CIRCLE:\n    case DWG_TYPE_LINE:\n      return 0;\n    case DWG_TYPE_DIMENSION_ORDINATE:\n    case DWG_TYPE_DIMENSION_LINEAR:\n    case DWG_TYPE_DIMENSION_ALIGNED:\n    case DWG_TYPE_DIMENSION_ANG3PT:\n    case DWG_TYPE_DIMENSION_ANG2LN:\n    case DWG_TYPE_DIMENSION_RADIUS:\n    case DWG_TYPE_DIMENSION_DIAMETER:\n      return 1;\n    case DWG_TYPE_POINT:\n    case DWG_TYPE__3DFACE:\n    case DWG_TYPE_POLYLINE_PFACE:\n    case DWG_TYPE_POLYLINE_MESH:\n    case DWG_TYPE_SOLID:\n    case DWG_TYPE_TRACE:\n    case DWG_TYPE_SHAPE:\n      return 0;\n    case DWG_TYPE_VIEWPORT:\n      return 1;\n    case DWG_TYPE_ELLIPSE:\n    case DWG_TYPE_SPLINE:\n      return 0;\n    case DWG_TYPE_REGION:\n    case DWG_TYPE__3DSOLID:\n    case DWG_TYPE_BODY:\n      return 1;\n    case DWG_TYPE_RAY:\n    case DWG_TYPE_XLINE:\n      return 0;\n    case DWG_TYPE_DICTIONARY:\n    case DWG_TYPE_OLEFRAME:\n    case DWG_TYPE_MTEXT:\n    case DWG_TYPE_LEADER:\n      return 1;\n    case DWG_TYPE_TOLERANCE:\n    case DWG_TYPE_MLINE:\n      return 0;\n    case DWG_TYPE_BLOCK_CONTROL:\n    case DWG_TYPE_LAYER_CONTROL:\n    case DWG_TYPE_STYLE_CONTROL:\n    case DWG_TYPE_LTYPE_CONTROL:\n    case DWG_TYPE_VIEW_CONTROL:\n    case DWG_TYPE_UCS_CONTROL:\n    case DWG_TYPE_VPORT_CONTROL:\n    case DWG_TYPE_APPID_CONTROL:\n    case DWG_TYPE_DIMSTYLE_CONTROL:\n    case DWG_TYPE_VPORT_ENTITY_CONTROL:\n      return 0;\n    case DWG_TYPE_BLOCK_HEADER:\n    case DWG_TYPE_LAYER:\n    case DWG_TYPE_STYLE:\n    case DWG_TYPE_LTYPE:\n    case DWG_TYPE_VIEW:\n    case DWG_TYPE_UCS:\n    case DWG_TYPE_VPORT:\n    case DWG_TYPE_APPID:\n    case DWG_TYPE_DIMSTYLE:\n    case DWG_TYPE_VPORT_ENTITY_HEADER:\n      return 1;\n    case DWG_TYPE_GROUP:\n    case DWG_TYPE_MLINESTYLE:\n    case DWG_TYPE_OLE2FRAME:\n      return 1;\n    case DWG_TYPE_DUMMY:\n    case DWG_TYPE_LONG_TRANSACTION:\n    case DWG_TYPE_LWPOLYLINE:\n      return 0;\n    case DWG_TYPE_HATCH:\n    case DWG_TYPE_XRECORD:\n      return 1;\n    case DWG_TYPE_PLACEHOLDER:\n      return 0;\n    case DWG_TYPE_VBA_PROJECT:\n    case DWG_TYPE_LAYOUT:\n    case DWG_TYPE_PROXY_ENTITY:\n    case DWG_TYPE_PROXY_OBJECT:\n    default:\n      return 1;\n    }\n}\n\n/* The first common part of every entity.\n\n   The last common part is common_entity_handle_data.spec\n   called by COMMON_ENTITY_HANDLE_DATA in dwg.spec\n\n   For EED check page 269, par 28 (Extended Object Data)\n */\nstatic int\ndwg_decode_entity (Bit_Chain *dat, Bit_Chain *hdl_dat, Bit_Chain *str_dat,\n                   Dwg_Object_Entity *restrict ent)\n{\n  unsigned int i;\n  int error = 0;\n  Dwg_Data *dwg = ent->dwg;\n  Dwg_Object *obj = &dwg->object[ent->objid];\n  Dwg_Object_Entity *_obj = ent;\n  unsigned long objectpos = bit_position (dat);\n\n  // obj->dat_address = dat->byte; // the data stream offset\n  obj->bitsize_pos = objectpos; // absolute. needed for encode\n  PRE (R_13)\n  {\n    if (FIELD_VALUE (flag_r11) & 4 && FIELD_VALUE (kind_r11) > 2\n        && FIELD_VALUE (kind_r11) != 22)\n      FIELD_RD (elevation_r11, 30);\n    if (FIELD_VALUE (flag_r11) & 8)\n      FIELD_RD (thickness_r11, 39);\n    if (FIELD_VALUE (flag_r11) & 0x20)\n      {\n        Dwg_Object_Ref *hdl\n            = dwg_decode_handleref_with_code (dat, obj, dwg, 0);\n        if (hdl)\n          obj->handle = hdl->handleref;\n      }\n    if (FIELD_VALUE (extra_r11) & 4)\n      FIELD_RS (paper_r11, 0);\n  }\n\n  VERSIONS (R_2000, R_2007)\n  {\n    obj->bitsize = bit_read_RL (dat); // until the handles\n    LOG_TRACE (\"bitsize: \" FORMAT_RL \" [RL] @%lu.%u\\n\", obj->bitsize,\n               dat->byte-2, dat->bit);\n    if (obj->bitsize > obj->size * 8)\n      {\n        LOG_ERROR (\"Invalid bitsize \" FORMAT_RL \" => \" FORMAT_RL, obj->bitsize,\n                   obj->size * 8);\n        obj->bitsize = obj->size * 8;\n        error |= DWG_ERR_VALUEOUTOFBOUNDS;\n      }\n  }\n  SINCE (R_2007)\n  {\n    SINCE (R_2010)\n      LOG_HANDLE (\" bitsize: \" FORMAT_RL \",\", obj->bitsize);\n    // restrict the hdl_dat stream\n    error |= obj_handle_stream (dat, obj, hdl_dat);\n    // and set the string stream (restricted to size)\n    // skip for all types without strings\n    if (obj->type >= 500 || obj_has_strings (obj->type))\n      error |= obj_string_stream (dat, obj, str_dat);\n    else\n      {\n        str_dat->chain += str_dat->byte;\n        str_dat->byte = 0;\n        str_dat->bit = 0;\n        str_dat->size = 0;\n        bit_advance_position (str_dat, obj->bitsize - 1 - 8);\n      }\n  }\n\n  error |= bit_read_H (dat, &(obj->handle));\n  if (error & DWG_ERR_INVALIDHANDLE)\n    {\n      LOG_WARN (\"dwg_decode_entity handle @%lu.%u\", dat->byte, dat->bit);\n      obj->bitsize = 0;\n      ent->num_eed = 0;\n      ent->preview_exists = 0;\n      return error;\n    }\n  LOG_TRACE (\"handle: \" FORMAT_H \" [H 5]\\n\", ARGS_H (obj->handle))\n\n  PRE (R_13) { return DWG_ERR_NOTYETSUPPORTED; }\n\n  error |= dwg_decode_eed (dat, (Dwg_Object_Object *)ent);\n  if (error & (DWG_ERR_INVALIDEED | DWG_ERR_VALUEOUTOFBOUNDS))\n    return error;\n\n  // clang-format off\n  #include \"common_entity_data.spec\"\n  // clang-format on\n\n  SINCE (R_2007) {\n    dwg_decode_common_entity_handle_data (dat, hdl_dat, obj);\n  }\n\n  // elsewhere: object data, handles, padding bits, crc\n  obj->common_size = bit_position (dat) - objectpos;\n  LOG_HANDLE (\"--common_size: %lu\\n\", obj->common_size); // needed for unknown\n\n  return error;\n}\n\n/* The first common part of every object.\n\n   There is no COMMON_ENTITY_DATA for objects.\n   Check page 269, par 28 (Extended Object Data)\n */\nstatic int\ndwg_decode_object (Bit_Chain *dat, Bit_Chain *hdl_dat, Bit_Chain *str_dat,\n                   Dwg_Object_Object *restrict _obj)\n{\n  unsigned int i;\n  int error = 0;\n  Dwg_Data *dwg = _obj->dwg;\n  Dwg_Object *obj = &dwg->object[_obj->objid];\n  unsigned long objectpos = bit_position (dat);\n\n  // obj->dat_address = dat->byte; // the data stream offset\n  obj->bitsize_pos = objectpos; // absolute. needed for encode\n  VERSIONS (R_2000, R_2007)\n  {\n    obj->bitsize = bit_read_RL (dat);\n    LOG_TRACE (\"bitsize: \" FORMAT_RL \" [RL] @%lu.%u\\n\", obj->bitsize,\n               dat->byte - 2, dat->bit)\n    if (obj->bitsize > obj->size * 8)\n      {\n        LOG_ERROR (\"Invalid bitsize \" FORMAT_RL \" => \" FORMAT_RL, obj->bitsize,\n                   obj->size * 8);\n        obj->bitsize = obj->size * 8;\n        error |= DWG_ERR_VALUEOUTOFBOUNDS;\n      }\n  }\n  SINCE (R_2007)\n  {\n    SINCE (R_2010)\n      LOG_HANDLE (\" bitsize: \" FORMAT_RL \",\", obj->bitsize);\n    // restrict the hdl_dat stream\n    error |= obj_handle_stream (dat, obj, hdl_dat);\n\n    // and set the string stream (restricted to size)\n    if (obj->type >= 500 || obj_has_strings (obj->type))\n      error |= obj_string_stream (dat, obj, str_dat);\n    else\n      {\n        str_dat->chain += str_dat->byte;\n        str_dat->byte = 0;\n        str_dat->bit = 0;\n        str_dat->size = 0;\n        bit_advance_position (str_dat, obj->bitsize - 1 - 8);\n      }\n  }\n\n  error |= bit_read_H (dat, &obj->handle);\n  if (error & DWG_ERR_INVALIDHANDLE)\n    {\n      LOG_ERROR (\"Wrong object handle at pos 0x%0lx\", dat->byte)\n      return error;\n    }\n  LOG_TRACE (\"handle: \" FORMAT_H \" [H 5]\\n\", ARGS_H (obj->handle))\n\n  error |= dwg_decode_eed (dat, _obj);\n  if (error & (DWG_ERR_INVALIDEED | DWG_ERR_VALUEOUTOFBOUNDS))\n    return error;\n\n  VERSIONS (R_13, R_14)\n  {\n    obj->bitsize = bit_read_RL (dat);\n    LOG_TRACE (\"bitsize: %u [RL]\\n\", obj->bitsize);\n    if (obj->bitsize > obj->size * 8)\n      {\n        LOG_ERROR (\"Invalid bitsize \" FORMAT_RL \" => \" FORMAT_RL, obj->bitsize,\n                   obj->size * 8);\n        obj->bitsize = obj->size * 8;\n        error |= DWG_ERR_VALUEOUTOFBOUNDS;\n      }\n  }\n  // documentation bug, same BL type as with entity\n  FIELD_BL (num_reactors, 0);\n  SINCE (R_2010)\n  {\n    if (_obj->num_reactors > 0x1000)\n      {\n        LOG_WARN (\"Invalid num_reactors %ld\", (long)_obj->num_reactors)\n        _obj->num_reactors = 0;\n      }\n  }\n  SINCE (R_2004) { FIELD_B (xdic_missing_flag, 0); }\n  SINCE (R_2013) { FIELD_B (has_ds_binary_data, 0); }\n  obj->common_size = bit_position (dat) - objectpos;\n  LOG_HANDLE (\"--common_size: %lu\\n\", obj->common_size); // needed for unknown\n\n  return error;\n}\n\nstatic int\ndwg_decode_add_object_ref (Dwg_Data *restrict dwg, Dwg_Object_Ref *ref)\n{\n  Dwg_Object_Ref **object_ref_old = dwg->object_ref;\n\n  // Reserve memory space for object references\n  if (!dwg->num_object_refs)\n    dwg->object_ref = calloc (REFS_PER_REALLOC, sizeof (Dwg_Object_Ref *));\n  else if (dwg->num_object_refs % REFS_PER_REALLOC == 0)\n    dwg->object_ref\n        = realloc (dwg->object_ref, (dwg->num_object_refs + REFS_PER_REALLOC)\n                                        * sizeof (Dwg_Object_Ref *));\n  if (!dwg->object_ref)\n    {\n      LOG_ERROR (\"Out of memory\");\n      dwg->object_ref = object_ref_old;\n      return DWG_ERR_OUTOFMEM;\n    }\n  dwg->object_ref[dwg->num_object_refs++] = ref;\n  return 0;\n}\n\n/* Returns a freshly allocated ref */\nDwg_Object_Ref *\ndwg_new_ref (Dwg_Data *restrict dwg)\n{\n  Dwg_Object_Ref *ref = (Dwg_Object_Ref *)calloc (1, sizeof (Dwg_Object_Ref));\n  if (!ref)\n    {\n      LOG_ERROR (\"Out of memory\");\n      return NULL;\n    }\n  if (dwg_decode_add_object_ref (dwg, ref))\n    {\n      free (ref);\n      return NULL;\n    }\n  return ref;\n}\n\n/* Store an object reference in a separate dwg->object_ref array\n   which is the id for handles, i.e. DXF 5, 330. */\nDwg_Object_Ref *\ndwg_decode_handleref (Bit_Chain *restrict dat, Dwg_Object *restrict obj,\n                      Dwg_Data *restrict dwg)\n{\n  // Welcome to the house of evil code\n  Dwg_Object_Ref *ref = (Dwg_Object_Ref *)calloc (1, sizeof (Dwg_Object_Ref));\n  if (!ref)\n    {\n      LOG_ERROR (\"Out of memory\");\n      return NULL;\n    }\n\n  if (bit_read_H (dat, &ref->handleref))\n    {\n      LOG_WARN (\"Invalid handleref: \" FORMAT_REF, ARGS_REF (ref))\n      free (ref);\n      return NULL;\n    }\n\n  // If the handle size is 0 and not a relative handle, it is probably a null\n  // handle. It shouldn't be placed in the object ref vector.\n  if (ref->handleref.size || (obj && ref->handleref.code > 5))\n    {\n      if (dwg_decode_add_object_ref (dwg, ref))\n        {\n          free (ref);\n          return NULL;\n        }\n    }\n  else if (!ref->handleref.value)\n    {\n      if (obj)\n        {\n          free (ref);\n          return NULL;\n        }\n      ref->absolute_ref = 0;\n      ref->obj = NULL;\n      return ref;\n    }\n\n  // We receive a null obj when we are reading\n  // handles in the header variables section\n  if (!obj)\n    {\n      if (ref->handleref.value)\n        {\n          ref->absolute_ref = ref->handleref.value;\n          ref->obj = NULL;\n          return ref;\n        }\n      if (ref->handleref.code >= 6)\n        {\n          LOG_ERROR (\"Empty obj argument for handleref code %d\",\n                     ref->handleref.code);\n          ref->obj = NULL;\n          return NULL;\n        }\n    }\n\n  /*\n   * With TYPEDOBJHANDLE 2-5 the code indicates the type of ownership.\n   * With OFFSETOBJHANDLE >5 the handle is stored as an offset from some other\n   * handle.\n   */\n  switch (ref->handleref.code)\n    {\n    case 0x06:\n      ref->absolute_ref = (obj->handle.value + 1);\n      break;\n    case 0x08:\n      ref->absolute_ref = (obj->handle.value - 1);\n      break;\n    case 0x0A:\n      ref->absolute_ref = (obj->handle.value + ref->handleref.value);\n      break;\n    case 0x0C:\n      ref->absolute_ref = (obj->handle.value - ref->handleref.value);\n      break;\n    case 0x0E: // eg 2007 REGION.history_id (some very high number)\n      ref->absolute_ref = obj->handle.value;\n      break;\n    case 2:\n    case 3:\n    case 4:\n    case 5:\n      ref->absolute_ref = ref->handleref.value;\n      break;\n    case 0: // ignore?\n      ref->absolute_ref = ref->handleref.value;\n      break;\n    default:\n      // dwg->object_ref[dwg->num_object_refs-1] = NULL;\n      // dwg->num_object_refs--;\n      ref->absolute_ref = 0;\n      ref->obj = NULL;\n      LOG_WARN (\"Invalid handle pointer code %d\", ref->handleref.code);\n      break;\n    }\n  return ref;\n}\n\n/**\n * code:\n *  TYPEDOBJHANDLE:\n *   2 Soft owner\n *   3 Hard owner\n *   4 Soft pointer\n *   5 Hard pointer\n *  OFFSETOBJHANDLE for soft owners or pointers:\n *   6 ref + 1\n *   8 ref - 1\n *   a ref + offset\n *   c ref - offset\n *   e ??\n */\nDwg_Object_Ref *\ndwg_decode_handleref_with_code (Bit_Chain *restrict dat,\n                                Dwg_Object *restrict obj,\n                                Dwg_Data *restrict dwg, unsigned int code)\n{\n  int err;\n  Dwg_Object_Ref *ref = (Dwg_Object_Ref *)calloc (1, sizeof (Dwg_Object_Ref));\n  if (!ref)\n    {\n      LOG_ERROR (\"Out of memory\");\n      return NULL;\n    }\n\n  err = bit_read_H (dat, &ref->handleref);\n  if (err)\n    {\n      /*\n      LOG_WARN (\"Invalid handleref error: 0x%x. Wanted code %d, got (\" FORMAT_H\n      \")\", err, code, ARGS_H(ref->handleref))\n      */\n      free (ref);\n      return NULL;\n    }\n\n  /* If the handle size is 0 and not a relative handle, it is probably\n     a null handle.\n     It shouldn't be placed in the object ref vector,\n     just with indxf the NULL HDL is. */\n  if (ref->handleref.size || (obj && ref->handleref.code > 5))\n    {\n      if (dwg_decode_add_object_ref (dwg, ref))\n        {\n          free (ref);\n          return NULL;\n        }\n    }\n  else if (!ref->handleref.value)\n    {\n      /*if (obj)\n        {\n          free (ref);\n          return NULL;\n        }\n      */\n      ref->absolute_ref = 0;\n      ref->obj = NULL;\n      return ref;\n    }\n\n  // We receive a null obj when we are reading\n  // handles in the header variables section\n  if (!obj)\n    {\n      ref->absolute_ref = ref->handleref.value;\n      ref->obj = NULL;\n      return ref;\n    }\n\n  /*\n   * With TYPEDOBJHANDLE 2-5 the code indicates the type of ownership.\n   * With OFFSETOBJHANDLE >5 the handle is stored as an offset from some other\n   * handle.\n   */\n  switch (ref->handleref.code)\n    {\n    case 0x06:\n      ref->absolute_ref = (obj->handle.value + 1);\n      break;\n    case 0x08:\n      ref->absolute_ref = (obj->handle.value - 1);\n      break;\n    case 0x0A:\n      ref->absolute_ref = (obj->handle.value + ref->handleref.value);\n      break;\n    case 0x0C:\n      ref->absolute_ref = (obj->handle.value - ref->handleref.value);\n      break;\n    case 0x0E: // eg 2007 REGION.history_id (some very high number)\n      ref->absolute_ref = obj->handle.value;\n      break;\n    case 2:\n    case 3:\n    case 4:\n    case 5:\n      ref->absolute_ref = ref->handleref.value;\n      break;\n    case 0: // ignore?\n      ref->absolute_ref = ref->handleref.value;\n      break;\n    default:\n      // dwg->object_ref[dwg->num_object_refs-1] = NULL;\n      // dwg->num_object_refs--;\n      ref->absolute_ref = 0;\n      ref->obj = NULL;\n      LOG_WARN (\"Invalid handle pointer code %d\", ref->handleref.code);\n      break;\n    }\n  return ref;\n}\n\nint\ndwg_decode_header_variables (Bit_Chain *dat, Bit_Chain *hdl_dat,\n                             Bit_Chain *str_dat, Dwg_Data *restrict dwg)\n{\n  Dwg_Header_Variables *_obj = &dwg->header_vars;\n  Dwg_Object *obj = NULL;\n  int error = 0;\n\n  // clang-format off\n  #include \"header_variables.spec\"\n  // clang-format on\n\n  return error;\n}\n\nstatic int\ndwg_decode_common_entity_handle_data (Bit_Chain *dat, Bit_Chain *hdl_dat,\n                                      Dwg_Object *restrict obj)\n{\n\n  Dwg_Data *dwg = obj->parent;\n  Dwg_Object_Entity *_obj, *_ent;\n  BITCODE_BL vcount;\n  int error = 0;\n\n  _obj = _ent = obj->tio.entity;\n\n  // deferred from common_entity_data, which has no hdl_dat\n  if (dat->version >= R_2007 && _ent->color.flag & 0x40)\n    FIELD_HANDLE (color.handle, 0, 430);\n\n    // clang-format off\n  #include \"common_entity_handle_data.spec\"\n  // clang-format on\n\n  return error;\n}\n\nenum RES_BUF_VALUE_TYPE\nget_base_value_type (short gc)\n{\n  if (gc >= 300)\n    {\n      if (gc >= 440)\n        {\n          if (gc >= 1000) // 1000-1071\n            {\n              if (gc == 1004)\n                return VT_BINARY;\n              if (gc <= 1009)\n                return VT_STRING;\n              if (gc <= 1059)\n                return VT_REAL;\n              if (gc <= 1070)\n                return VT_INT16;\n              if (gc == 1071)\n                return VT_INT32;\n            }\n          else // 440-999\n            {\n              if (gc <= 459)\n                return VT_INT32;\n              if (gc <= 469)\n                return VT_REAL;\n              if (gc <= 479)\n                return VT_STRING;\n              if (gc <= 998)\n                return VT_INVALID;\n              if (gc == 999)\n                return VT_STRING; // lgtm [cpp/constant-comparison]\n            }\n        }\n      else // <440\n        {\n          if (gc >= 390) // 390-439\n            {\n              if (gc <= 399)\n                return VT_HANDLE;\n              if (gc <= 409)\n                return VT_INT16;\n              if (gc <= 419)\n                return VT_STRING;\n              if (gc <= 429)\n                return VT_INT32;\n              if (gc <= 439)\n                return VT_STRING; // lgtm [cpp/constant-comparison]\n            }\n          else // 330-389\n            {\n              if (gc <= 309)\n                return VT_STRING;\n              if (gc <= 319)\n                return VT_BINARY;\n              if (gc <= 329)\n                return VT_HANDLE;\n              if (gc <= 369)\n                return VT_OBJECTID;\n              if (gc <= 389)\n                return VT_INT16; // lgtm [cpp/constant-comparison]\n            }\n        }\n    }\n  else if (gc >= 105)\n    {\n      if (gc >= 210) // 210-299\n        {\n          if (gc <= 239)\n            return VT_REAL;\n          if (gc <= 269)\n            return VT_INVALID;\n          if (gc <= 279)\n            return VT_INT16;\n          if (gc <= 289)\n            return VT_INT8;\n          if (gc <= 299)\n            return VT_BOOL; // lgtm [cpp/constant-comparison]\n        }\n      else // 105-209\n        {\n          if (gc == 105)\n            return VT_HANDLE;\n          if (gc <= 109)\n            return VT_INVALID;\n          if (gc <= 149)\n            return VT_REAL;\n          if (gc <= 169) // e.g. REQUIREDVERSIONS 160 r2013+\n            return VT_INT64;\n          if (gc <= 179)\n            return VT_INT16;\n          if (gc <= 209)\n            return VT_INVALID; // lgtm [cpp/constant-comparison]\n        }\n    }\n  else // <105\n    {\n      if (gc >= 38) // 38-102\n        {\n          if (gc <= 59)\n            return VT_REAL;\n          if (gc <= 79)\n            return VT_INT16;\n          if (gc <= 99)\n            return VT_INT32;\n          if (gc <= 101)\n            return VT_STRING;\n          if (gc == 102)\n            return VT_STRING;\n        }\n      else // 0-37\n        {\n          if (gc < 0)\n            return VT_HANDLE;\n          if (gc <= 4)\n            return VT_STRING;\n          if (gc == 5)\n            return VT_HANDLE;\n          if (gc <= 9)\n            return VT_STRING; // but 9 never TU\n          if (gc <= 37)\n            return VT_POINT3D; // lgtm [cpp/constant-comparison]\n        }\n    }\n  return VT_INVALID;\n}\n\nvoid\ndwg_free_xdata_resbuf (Dwg_Resbuf *rbuf)\n{\n  while (rbuf)\n    {\n      Dwg_Resbuf *next = rbuf->next;\n      short type = get_base_value_type (rbuf->type);\n      if (type == VT_STRING || type == VT_BINARY)\n        free (rbuf->value.str.u.data);\n      free (rbuf);\n      rbuf = next;\n    }\n}\n\n// TODO: unify with eed[], use an array not linked list.\nstatic Dwg_Resbuf *\ndwg_decode_xdata (Bit_Chain *restrict dat, Dwg_Object_XRECORD *restrict obj,\n                  BITCODE_BL size)\n{\n  Dwg_Resbuf *rbuf, *root = NULL, *curr = NULL;\n  unsigned char codepage;\n  long unsigned int end_address, curr_address;\n  BITCODE_BL i, num_xdata = 0;\n  BITCODE_RS length;\n  int error;\n\n  static int cnt = 0;\n  cnt++;\n\n  end_address = dat->byte + (unsigned long int)size;\n  if (obj->parent && obj->parent->objid)\n    {\n      Dwg_Data *dwg = obj->parent->dwg;\n      Dwg_Object *o = &dwg->object[obj->parent->objid];\n      if (size > o->size)\n        {\n          LOG_ERROR (\"Invalid XRECORD.num_databytes \" FORMAT_BL, size);\n          obj->num_databytes = 0;\n          return NULL;\n        }\n    }\n  LOG_INSANE (\"xdata:\\n\");\n  LOG_INSANE_TF (&dat->chain[dat->byte], (int)size);\n  curr_address = dat->byte;\n\n  while (dat->byte < end_address)\n    {\n      enum RES_BUF_VALUE_TYPE vtype;\n      rbuf = (Dwg_Resbuf *)calloc (1, sizeof (Dwg_Resbuf));\n      if (!rbuf)\n        {\n          LOG_ERROR (\"Out of memory\");\n          dwg_free_xdata_resbuf (root);\n          return NULL;\n        }\n      rbuf->next = NULL;\n      rbuf->type = bit_read_RS (dat);\n      if (dat->byte == curr_address)\n        {\n          // no advance, by dat overflow\n          dat->byte = end_address;\n          break;\n        }\n      if (rbuf->type < 0 || rbuf->type >= 2000)\n        {\n          LOG_ERROR (\"Invalid xdata type %d [RS]\", rbuf->type);\n          dat->byte = end_address;\n          break;\n        }\n      vtype = get_base_value_type (rbuf->type);\n      switch (vtype)\n        {\n        case VT_STRING:\n          PRE (R_2007)\n          {\n            length = rbuf->value.str.size = bit_read_RS (dat);\n            rbuf->value.str.codepage = bit_read_RC (dat);\n            if (length > size)\n              break;\n            rbuf->value.str.u.data = bit_read_TF (dat, length);\n            LOG_TRACE (\"xdata[%d]: \\\"%s\\\" [TF %d %d]\\n\", num_xdata,\n                       rbuf->value.str.u.data, length, rbuf->type);\n          }\n          LATER_VERSIONS\n          {\n            length = rbuf->value.str.size = bit_read_RS (dat);\n            if (length > 0 && length < size)\n              {\n                rbuf->value.str.u.wdata = calloc (length + 1, 2);\n                if (!rbuf->value.str.u.wdata)\n                  {\n                    LOG_ERROR (\"Out of memory\");\n                    if (root)\n                      {\n                        dwg_free_xdata_resbuf (root);\n                        if (rbuf)\n                          free (rbuf);\n                      }\n                    else\n                      dwg_free_xdata_resbuf (rbuf);\n                    return NULL;\n                  }\n                for (i = 0; i < length; i++)\n                  rbuf->value.str.u.wdata[i] = bit_read_RS (dat);\n                rbuf->value.str.u.wdata[i] = '\\0';\n                LOG_TRACE_TU (\"xdata\", rbuf->value.str.u.wdata, rbuf->type);\n              }\n          }\n          break;\n        case VT_REAL:\n          rbuf->value.dbl = bit_read_RD (dat);\n          LOG_TRACE (\"xdata[%d]: %f [RD %d]\\n\", num_xdata, rbuf->value.dbl,\n                     rbuf->type);\n          break;\n        case VT_BOOL:\n        case VT_INT8:\n          rbuf->value.i8 = bit_read_RC (dat);\n          LOG_TRACE (\"xdata[%d]: %d [RC %d]\\n\", num_xdata, (int)rbuf->value.i8,\n                     rbuf->type);\n          break;\n        case VT_INT16:\n          rbuf->value.i16 = bit_read_RS (dat);\n          LOG_TRACE (\"xdata[%d]: %d [RS %d]\\n\", num_xdata,\n                     (int)rbuf->value.i16, rbuf->type);\n          break;\n        case VT_INT32:\n          rbuf->value.i32 = bit_read_RL (dat);\n          LOG_TRACE (\"xdata[%d]: %d [RL %d]\\n\", num_xdata,\n                     (int)rbuf->value.i32, rbuf->type);\n          break;\n        case VT_INT64:\n          rbuf->value.i64 = bit_read_BLL (dat);\n          LOG_TRACE (\"xdata[%d]: \" FORMAT_BLL \" [BLL %d]\\n\", num_xdata,\n                     rbuf->value.i64, rbuf->type);\n          break;\n        case VT_POINT3D:\n          rbuf->value.pt[0] = bit_read_RD (dat);\n          rbuf->value.pt[1] = bit_read_RD (dat);\n          rbuf->value.pt[2] = bit_read_RD (dat);\n          LOG_TRACE (\"xdata[%d]: %f,%f,%f [3RD %d]\\n\", num_xdata,\n                     rbuf->value.pt[0], rbuf->value.pt[1], rbuf->value.pt[2],\n                     rbuf->type);\n          break;\n        case VT_BINARY:\n          rbuf->value.str.size = bit_read_RC (dat);\n          rbuf->value.str.u.data = bit_read_TF (dat, rbuf->value.str.size);\n          LOG_TRACE (\"xdata[%d]: [TF %d %d]\", num_xdata, rbuf->value.str.size,\n                     rbuf->type);\n          LOG_TRACE_TF (rbuf->value.str.u.data, rbuf->value.str.size);\n          break;\n        case VT_HANDLE:\n        case VT_OBJECTID:\n          bit_read_fixed (dat, rbuf->value.hdl, 8);\n          LOG_TRACE (\"xdata[%d]: %X [H %d]\\n\", num_xdata,\n                     (unsigned)*(uint64_t *)rbuf->value.hdl, rbuf->type);\n          break;\n        case VT_INVALID:\n        default:\n          LOG_ERROR (\"Invalid group code in xdata[%d]: %d\", num_xdata,\n                     rbuf->type)\n          dwg_free_xdata_resbuf (rbuf);\n          dat->byte = end_address;\n          obj->num_xdata = num_xdata;\n          return root;\n        }\n      num_xdata++;\n\n      if (!curr)\n        {\n          curr = root = rbuf;\n        }\n      else\n        {\n          curr->next = rbuf;\n          curr = rbuf;\n        }\n      curr_address = dat->byte;\n    }\n  obj->num_xdata = num_xdata;\n  return root;\n}\n\n/* OBJECTS *******************************************************************/\n\n#include \"dwg.spec\"\n\n/*--------------------------------------------------------------------------------\n * Private functions which depend on the preceding\n */\n\n/* check the types of all referenced handles.\n   r2010+ often mix up the hdlstream offset:\n   layer,vertex*,seqend. check the types then also.\n */\nstatic void\ncheck_POLYLINE_handles (Dwg_Object *obj)\n{\n  /* We ensured the common fields structure is shared with all 4 types */\n  Dwg_Entity_POLYLINE_2D *_obj = obj->tio.entity->tio.POLYLINE_2D;\n  Dwg_Data *dwg = obj->parent;\n\n  if (dwg->header.version >= R_2004)\n    {\n      BITCODE_BL i = 0;\n      Dwg_Object_Ref *layer = obj->tio.entity->layer;\n      Dwg_Object_Ref *seqend = _obj->seqend;\n\n      // resolve prev. object\n      if (layer && !layer->obj)\n        layer->obj = dwg_ref_object_relative (dwg, layer, obj);\n      if (!layer || !layer->obj)\n        { // maybe a reactor pointing forwards or vertex\n          LOG_WARN (\"Wrong POLYLINE.layer %lX\",\n                    layer ? layer->handleref.value : 0L);\n          if (_obj->num_owned > 0 && _obj->vertex)\n            {\n              Dwg_Object_Ref *vertex = _obj->vertex[0];\n              if (vertex && !vertex->obj)\n                vertex->obj = dwg_ref_object_relative (dwg, vertex, obj);\n              if (vertex && vertex->obj /* pointing backwards */\n                  && vertex->obj->fixedtype == DWG_TYPE_LAYER)\n                {\n                  Dwg_Object *seq;\n                  obj->tio.entity->layer = layer = vertex;\n                  LOG_WARN (\n                      \"POLYLINE.layer is vertex[0] %lX, shift em, NULL seqend\",\n                      layer->handleref.value);\n                  /* shift vertices one back */\n                  for (i = 0; i < _obj->num_owned - 1; i++)\n                    {\n                      _obj->vertex[i] = _obj->vertex[i + 1];\n                    }\n                  _obj->vertex[_obj->num_owned - 1] = seqend;\n                  _obj->seqend = NULL;\n                  /* now just seqend is empty.\n                     either 1+ last_vertex, or one before the first.\n                     Here the next object might not be read yet. */\n                  seq = dwg_next_object (obj);\n                  if (seq && seq->type == DWG_TYPE_SEQEND)\n                    {\n                      LOG_WARN (\"POLYLINE.seqend = POLYLINE+1 %lX\",\n                                seq->handle.value);\n                      seqend = _obj->seqend = dwg_find_objectref (dwg, seq);\n                    }\n                  else\n                    {\n                      seq = dwg_next_object (seqend->obj);\n                      if (seq && seq->type == DWG_TYPE_SEQEND)\n                        {\n                          LOG_WARN (\"POLYLINE.seqend = VERTEX+1 %lX\",\n                                    seq->handle.value);\n                          seqend = _obj->seqend\n                              = dwg_find_objectref (dwg, seq);\n                        }\n                    }\n                }\n            }\n        }\n      else if (layer->obj->fixedtype != DWG_TYPE_LAYER\n               && layer->obj->fixedtype != DWG_TYPE_DICTIONARY)\n        { // a vertex would be after, a reactor before\n          LOG_WARN (\"Wrong POLYLINE.layer %s\", layer->obj->dxfname)\n        }\n      // a SEQEND is always after the polyline, so it cannot be resolved yet\n      if (!seqend || !seqend->handleref.value)\n        {\n          LOG_WARN (\"Empty POLYLINE.seqend\")\n        }\n      else if (seqend->obj && seqend->obj->fixedtype != DWG_TYPE_SEQEND)\n        { // most likely a vertex, off by one\n          LOG_WARN (\"Wrong POLYLINE.seqend %s\", seqend->obj->dxfname)\n        }\n      if (!_obj->vertex)\n        return;\n      for (; i < _obj->num_owned; i++)\n        {\n          Dwg_Object_Ref *v = _obj->vertex[i];\n          if (!v || !v->handleref.value)\n            {\n              LOG_WARN (\"Empty POLYLINE.vertex[%d]\", i);\n            }\n          else if (v->obj && v->obj->fixedtype != DWG_TYPE_VERTEX_2D\n                   && v->obj->fixedtype != DWG_TYPE_VERTEX_3D\n                   && v->obj->fixedtype != DWG_TYPE_VERTEX_MESH\n                   && v->obj->fixedtype != DWG_TYPE_VERTEX_PFACE\n                   && v->obj->fixedtype != DWG_TYPE_VERTEX_PFACE_FACE)\n            {\n              LOG_WARN (\"Wrong POLYLINE.vertex[%d] %lX %s\", i,\n                        v->handleref.value, v->obj->dxfname)\n            }\n        }\n    }\n}\n\nstatic int\ndecode_preR13_entities (unsigned long start, unsigned long end,\n                        unsigned long offset, Bit_Chain *restrict dat,\n                        Dwg_Data *restrict dwg)\n{\n  int error = 0;\n  BITCODE_BL num = dwg->num_objects;\n  dat->bit = 0;\n  LOG_TRACE (\"entities: (0x%lx-0x%lx, offset 0x%lx) TODO\\n\", start, end,\n             offset)\n  while (dat->byte < end)\n    {\n      Dwg_Object *obj;\n      Dwg_Object_Entity *ent;\n      BITCODE_RS crc;\n\n      if (!num)\n        dwg->object\n            = (Dwg_Object *)malloc (REFS_PER_REALLOC * sizeof (Dwg_Object));\n      else if (num % REFS_PER_REALLOC == 0)\n        dwg->object = realloc (dwg->object,\n                               (num + REFS_PER_REALLOC) * sizeof (Dwg_Object));\n      if (!dwg->object)\n        {\n          LOG_ERROR (\"Out of memory\");\n          return DWG_ERR_OUTOFMEM;\n        }\n      obj = &dwg->object[num];\n      memset (obj, 0, sizeof (Dwg_Object));\n      dwg->num_objects++;\n      obj->index = num;\n      obj->parent = dwg;\n      obj->address = dat->byte;\n\n      DEBUG_HERE;\n\n      switch (obj->type)\n        {\n        case 1:\n          error |= dwg_decode_LINE (dat, obj);\n          break;\n        case 2:\n          error |= dwg_decode_POINT (dat, obj);\n          break;\n        case 3:\n          error |= dwg_decode_CIRCLE (dat, obj);\n          break;\n        case 4:\n          error |= dwg_decode_SHAPE (dat, obj);\n          break;\n        case 7:\n          error |= dwg_decode_TEXT (dat, obj);\n          break;\n        case 8:\n          error |= dwg_decode_ARC (dat, obj);\n          break;\n        case 9:\n          error |= dwg_decode_TRACE (dat, obj);\n          break;\n        case 11:\n          error |= dwg_decode_SOLID (dat, obj);\n          break;\n        case 12:\n          error |= dwg_decode_BLOCK (dat, obj);\n          break;\n        case 13:\n          error |= dwg_decode_ENDBLK (dat, obj);\n          break;\n        case 14:\n          error |= dwg_decode_INSERT (dat, obj);\n          break;\n        case 15:\n          error |= dwg_decode_ATTDEF (dat, obj);\n          break;\n        case 16:\n          error |= dwg_decode_ATTRIB (dat, obj);\n          break;\n        case 17:\n          error |= dwg_decode_SEQEND (dat, obj);\n          break;\n        case 19:\n          error |= dwg_decode_POLYLINE_2D (dat, obj);\n          break;\n        case 20:\n          error |= dwg_decode_VERTEX_2D (dat, obj);\n          break;\n        case 22:\n          error |= dwg_decode__3DFACE (dat, obj);\n          break;\n        case 23:\n          // TODO check opts for the type of dimension\n          error |= dwg_decode_DIMENSION_LINEAR (dat, obj);\n          break;\n        case 24:\n          error |= dwg_decode_VPORT (dat, obj);\n          break;\n        default:\n          LOG_ERROR (\"Unknown object type %d\", obj->type)\n          break;\n        }\n\n      bit_set_position (dat, obj->address + obj->size - 2);\n      crc = bit_read_RS (dat);\n      LOG_TRACE (\"crc: %04X [RSx]\\n\", crc);\n      num++;\n\n      if (obj->size < 2 || obj->size > 0x1000) // FIXME\n        dat->byte = end;\n    }\n\n  dat->byte = end;\n  return error;\n}\n\n/** dwg_decode_variable_type\n * decode object by class name, not type. if type > 500.\n * returns 0 on success\n */\nstatic int\ndwg_decode_variable_type (Dwg_Data *restrict dwg, Bit_Chain *dat,\n                          Bit_Chain *hdl_dat, Dwg_Object *restrict obj)\n{\n  Dwg_Class *klass;\n  int i;\n  int is_entity;\n\n  i = obj->type - 500;\n  if (i < 0 || i >= dwg->num_classes)\n    {\n      LOG_ERROR (\"Invalid object type %d, only %u classes\", obj->type,\n                 dwg->num_classes);\n      return DWG_ERR_INVALIDTYPE;\n    }\n\n  klass = &dwg->dwg_class[i];\n  if (!klass || !klass->dxfname)\n    return DWG_ERR_INTERNALERROR;\n  obj->dxfname = klass->dxfname;\n  // almost always false\n  is_entity = dwg_class_is_entity (klass);\n\n  // clang-format off\n  // global class dispatcher\n  #include \"classes.inc\"\n  // clang-format on\n\n  LOG_WARN (\"Unknown Class %s %d %s (0x%x%s)\", is_entity ? \"entity\" : \"object\",\n            klass->number, klass->dxfname, klass->proxyflag,\n            klass->wasazombie ? \" was proxy\" : \"\")\n\n  return DWG_ERR_UNHANDLEDCLASS;\n}\n\n/** Adds a new empty obj to the dwg->object[] array.\n    The new object is at &dwg->object[dwg->num_objects-1].\n\n    Returns 0 or some error codes on success.\n    Returns -1 if the dwg->object pool was re-alloced, i.e. pointers within\n    are invalidated.\n    Returns DWG_ERR_OUTOFMEM otherwise.\n */\nEXPORT int\ndwg_add_object (Dwg_Data *restrict dwg)\n{\n  Dwg_Object *restrict obj;\n  BITCODE_BL num = dwg->num_objects;\n  int realloced = 0;\n  if (!num)\n    dwg->object = calloc (REFS_PER_REALLOC, sizeof (Dwg_Object));\n  else if (num % REFS_PER_REALLOC == 0)\n    {\n      Dwg_Object *restrict old = dwg->object;\n      dwg->object = realloc (dwg->object,\n                             (num + REFS_PER_REALLOC) * sizeof (Dwg_Object));\n      realloced = old != dwg->object;\n    }\n  if (!dwg->object)\n    return DWG_ERR_OUTOFMEM;\n\n  obj = &dwg->object[num];\n  memset (obj, 0, sizeof (Dwg_Object));\n  obj->index = num;\n  dwg->num_objects++;\n  obj->parent = dwg;\n  return realloced ? -1 : 0;\n}\n\n/** Adds an object to the DWG (i.e. dwg->object[dwg->num_objects])\n    Returns 0 or some error codes on success.\n    Returns -1 if the dwg->object pool was re-alloced.\n    Returns some DWG_ERR_* otherwise.\n */\nint\ndwg_decode_add_object (Dwg_Data *restrict dwg, Bit_Chain *dat,\n                       Bit_Chain *hdl_dat, long unsigned int address)\n{\n  long unsigned int objpos, restartpos;\n  Bit_Chain abs_dat = { NULL };\n  unsigned char previous_bit;\n  Dwg_Object *restrict obj;\n  BITCODE_BL num = dwg->num_objects;\n  int error = 0;\n  int realloced = 0;\n\n  /* Keep the previous full chain  */\n  abs_dat = *dat;\n\n  /* Use the indicated address for the object\n   */\n  dat->byte = address;\n  dat->bit = 0;\n\n  // DEBUG_HERE;\n  /*\n   * Reserve memory space for objects. A realloc violates all internal\n   * pointers.\n   */\n  realloced = dwg_add_object (dwg);\n  if (realloced > 0)\n    {\n      *dat = abs_dat;\n      return realloced; // i.e. DWG_ERR_OUTOFMEM\n    }\n  obj = &dwg->object[num];\n  LOG_INFO (\"==========================================\\n\"\n            \"Object number: %lu/%lX\",\n            (unsigned long)num, (unsigned long)num)\n\n  obj->size = bit_read_MS (dat);\n  LOG_INFO (\", Size: %d [MS]\", obj->size)\n  SINCE (R_2010)\n  {\n    /* This is not counted in the object size */\n    obj->handlestream_size = bit_read_UMC (dat);\n    LOG_INFO (\", Hdlsize: \" FORMAT_UMC \" [UMC] \", obj->handlestream_size);\n    obj->bitsize = obj->size * 8 - obj->handlestream_size;\n    // TODO boundscheck\n  }\n\n  objpos = bit_position (dat); // absolute\n  obj->address = dat->byte;\n\n  /* Until here dat is absolute. now restrict it */\n  bit_reset_chain (dat);\n  if (obj->size > dat->size)\n    {\n      LOG_ERROR (\"\\nInvalid object size. Would overflow\");\n      *dat = abs_dat;\n      return DWG_ERR_VALUEOUTOFBOUNDS;\n    }\n  dat->size = obj->size;\n\n  SINCE (R_2010) { obj->type = bit_read_BOT (dat); }\n  else { obj->type = bit_read_BS (dat); }\n  LOG_INFO (\", Type: %d [%s]\\n\", obj->type, dat->version >= R_2010 ? \"BOT\" : \"BS\");\n  restartpos = bit_position (dat); // relative\n\n  /* Check the type of the object\n   */\n  switch (obj->type)\n    {\n    case DWG_TYPE_TEXT:\n      error = dwg_decode_TEXT (dat, obj);\n      break;\n    case DWG_TYPE_ATTRIB:\n      error = dwg_decode_ATTRIB (dat, obj);\n      break;\n    case DWG_TYPE_ATTDEF:\n      error = dwg_decode_ATTDEF (dat, obj);\n      break;\n    case DWG_TYPE_BLOCK:\n      error = dwg_decode_BLOCK (dat, obj);\n      break;\n    case DWG_TYPE_ENDBLK:\n      error = dwg_decode_ENDBLK (dat, obj);\n      break;\n    case DWG_TYPE_SEQEND:\n      error = dwg_decode_SEQEND (dat, obj);\n      if (dat->version >= R_13 && obj->tio.entity->ownerhandle)\n        {\n          Dwg_Object *restrict owner = dwg_resolve_handle (\n              dwg, obj->tio.entity->ownerhandle->absolute_ref);\n          if (!owner)\n            {\n              LOG_WARN (\"no SEQEND.ownerhandle\")\n            }\n          else if (owner->fixedtype == DWG_TYPE_INSERT\n                   || owner->fixedtype == DWG_TYPE_MINSERT)\n            {\n              /* SEQEND handle for the owner needed in validate_INSERT */\n              hash_set (dwg->object_map, obj->handle.value, (uint32_t)num);\n              (void)dwg_validate_INSERT (owner);\n            }\n          else if (owner->fixedtype == DWG_TYPE_POLYLINE_2D\n                   || owner->fixedtype == DWG_TYPE_POLYLINE_3D\n                   || owner->fixedtype == DWG_TYPE_POLYLINE_PFACE\n                   || owner->fixedtype == DWG_TYPE_POLYLINE_MESH)\n            {\n              Dwg_Entity_POLYLINE_2D *restrict _obj\n                  = owner->tio.entity->tio.POLYLINE_2D;\n              if (!_obj->seqend)\n                /* SEQEND handle for the owner needed in validate_POLYLINE */\n                hash_set (dwg->object_map, obj->handle.value, (uint32_t)num);\n              (void)dwg_validate_POLYLINE (owner);\n            }\n        }\n      break;\n    case DWG_TYPE_INSERT:\n      error = dwg_decode_INSERT (dat, obj);\n      break;\n    case DWG_TYPE_MINSERT:\n      error = dwg_decode_MINSERT (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_2D:\n      error = dwg_decode_VERTEX_2D (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_3D:\n      error = dwg_decode_VERTEX_3D (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_MESH:\n      error = dwg_decode_VERTEX_MESH (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_PFACE:\n      error = dwg_decode_VERTEX_PFACE (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_PFACE_FACE:\n      error = dwg_decode_VERTEX_PFACE_FACE (dat, obj);\n      break;\n    case DWG_TYPE_POLYLINE_2D:\n      error = dwg_decode_POLYLINE_2D (dat, obj);\n      if (dat->version >= R_2010)\n        check_POLYLINE_handles (obj);\n      break;\n    case DWG_TYPE_POLYLINE_3D:\n      error = dwg_decode_POLYLINE_3D (dat, obj);\n      if (dat->version >= R_2010)\n        check_POLYLINE_handles (obj);\n      break;\n    case DWG_TYPE_ARC:\n      error = dwg_decode_ARC (dat, obj);\n      break;\n    case DWG_TYPE_CIRCLE:\n      error = dwg_decode_CIRCLE (dat, obj);\n      break;\n    case DWG_TYPE_LINE:\n      error = dwg_decode_LINE (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_ORDINATE:\n      error = dwg_decode_DIMENSION_ORDINATE (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_LINEAR:\n      error = dwg_decode_DIMENSION_LINEAR (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_ALIGNED:\n      error = dwg_decode_DIMENSION_ALIGNED (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_ANG3PT:\n      error = dwg_decode_DIMENSION_ANG3PT (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_ANG2LN:\n      error = dwg_decode_DIMENSION_ANG2LN (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_RADIUS:\n      error = dwg_decode_DIMENSION_RADIUS (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_DIAMETER:\n      error = dwg_decode_DIMENSION_DIAMETER (dat, obj);\n      break;\n    case DWG_TYPE_POINT:\n      error = dwg_decode_POINT (dat, obj);\n      break;\n    case DWG_TYPE__3DFACE:\n      error = dwg_decode__3DFACE (dat, obj);\n      break;\n    case DWG_TYPE_POLYLINE_PFACE:\n      error = dwg_decode_POLYLINE_PFACE (dat, obj);\n      if (dat->version >= R_2010)\n        check_POLYLINE_handles (obj);\n      break;\n    case DWG_TYPE_POLYLINE_MESH:\n      error = dwg_decode_POLYLINE_MESH (dat, obj);\n      if (dat->version >= R_2010)\n        check_POLYLINE_handles (obj);\n      break;\n    case DWG_TYPE_SOLID:\n      error = dwg_decode_SOLID (dat, obj);\n      break;\n    case DWG_TYPE_TRACE:\n      error = dwg_decode_TRACE (dat, obj);\n      break;\n    case DWG_TYPE_SHAPE:\n      error = dwg_decode_SHAPE (dat, obj);\n      break;\n    case DWG_TYPE_VIEWPORT:\n      error = dwg_decode_VIEWPORT (dat, obj);\n      break;\n    case DWG_TYPE_ELLIPSE:\n      error = dwg_decode_ELLIPSE (dat, obj);\n      break;\n    case DWG_TYPE_SPLINE:\n      error = dwg_decode_SPLINE (dat, obj);\n      break;\n    case DWG_TYPE_REGION:\n      error = dwg_decode_REGION (dat, obj);\n      break;\n    case DWG_TYPE__3DSOLID:\n      error = dwg_decode__3DSOLID (dat, obj);\n      break;\n    case DWG_TYPE_BODY:\n      error = dwg_decode_BODY (dat, obj);\n      break;\n    case DWG_TYPE_RAY:\n      error = dwg_decode_RAY (dat, obj);\n      break;\n    case DWG_TYPE_XLINE:\n      error = dwg_decode_XLINE (dat, obj);\n      break;\n    case DWG_TYPE_DICTIONARY:\n      error = dwg_decode_DICTIONARY (dat, obj);\n      break;\n    case DWG_TYPE_MTEXT:\n      error = dwg_decode_MTEXT (dat, obj);\n      break;\n    case DWG_TYPE_LEADER:\n      error = dwg_decode_LEADER (dat, obj);\n      break;\n    case DWG_TYPE_TOLERANCE:\n      error = dwg_decode_TOLERANCE (dat, obj);\n      break;\n    case DWG_TYPE_MLINE:\n      error = dwg_decode_MLINE (dat, obj);\n      break;\n    case DWG_TYPE_BLOCK_CONTROL:\n      error = dwg_decode_BLOCK_CONTROL (dat, obj);\n      if (!error && obj->tio.object->tio.BLOCK_CONTROL)\n        {\n          obj->tio.object->tio.BLOCK_CONTROL->objid = num;\n          if (!dwg->block_control.parent) // only once\n            dwg->block_control = *obj->tio.object->tio.BLOCK_CONTROL;\n          else\n            LOG_WARN (\"Second BLOCK_CONTROL object ignored\");\n        }\n      break;\n    case DWG_TYPE_BLOCK_HEADER:\n      error = dwg_decode_BLOCK_HEADER (dat, obj);\n      /*\n       * We cannot cache dwg->*space_block here as dwg->objects might get\n       * realloc'ed. See dwg_model_space_object() and dwg_paper_space_object()\n       * instead.\n       */\n      break;\n    case DWG_TYPE_LAYER_CONTROL:\n      error = dwg_decode_LAYER_CONTROL (dat, obj);\n      if (!error && obj->tio.object->tio.LAYER_CONTROL)\n        {\n          obj->tio.object->tio.LAYER_CONTROL->objid = num;\n          dwg->layer_control = *obj->tio.object->tio.LAYER_CONTROL;\n        }\n      break;\n    case DWG_TYPE_LAYER:\n      error = dwg_decode_LAYER (dat, obj);\n      break;\n    case DWG_TYPE_STYLE_CONTROL:\n      error = dwg_decode_STYLE_CONTROL (dat, obj);\n      if (!error && obj->tio.object->tio.STYLE_CONTROL)\n        {\n          obj->tio.object->tio.STYLE_CONTROL->objid = num;\n          dwg->style_control = *obj->tio.object->tio.STYLE_CONTROL;\n        }\n      break;\n    case DWG_TYPE_STYLE:\n      error = dwg_decode_STYLE (dat, obj);\n      break;\n    case DWG_TYPE_LTYPE_CONTROL:\n      error = dwg_decode_LTYPE_CONTROL (dat, obj);\n      if (!error && obj->tio.object->tio.LTYPE_CONTROL)\n        {\n          obj->tio.object->tio.LTYPE_CONTROL->objid = num;\n          dwg->ltype_control = *obj->tio.object->tio.LTYPE_CONTROL;\n        }\n      break;\n    case DWG_TYPE_LTYPE:\n      error = dwg_decode_LTYPE (dat, obj);\n      break;\n    case DWG_TYPE_VIEW_CONTROL:\n      error = dwg_decode_VIEW_CONTROL (dat, obj);\n      if (!error && obj->tio.object->tio.VIEW_CONTROL)\n        {\n          obj->tio.object->tio.VIEW_CONTROL->objid = num;\n          dwg->view_control = *obj->tio.object->tio.VIEW_CONTROL;\n        }\n      break;\n    case DWG_TYPE_VIEW:\n      error = dwg_decode_VIEW (dat, obj);\n      break;\n    case DWG_TYPE_UCS_CONTROL:\n      error = dwg_decode_UCS_CONTROL (dat, obj);\n      if (!error && obj->tio.object->tio.UCS_CONTROL)\n        {\n          obj->tio.object->tio.UCS_CONTROL->objid = num;\n          dwg->ucs_control = *obj->tio.object->tio.UCS_CONTROL;\n        }\n      break;\n    case DWG_TYPE_UCS:\n      error = dwg_decode_UCS (dat, obj);\n      break;\n    case DWG_TYPE_VPORT_CONTROL:\n      error = dwg_decode_VPORT_CONTROL (dat, obj);\n      if (!error && obj->tio.object->tio.VPORT_CONTROL)\n        {\n          obj->tio.object->tio.VPORT_CONTROL->objid = num;\n          dwg->vport_control = *obj->tio.object->tio.VPORT_CONTROL;\n        }\n      break;\n    case DWG_TYPE_VPORT:\n      error = dwg_decode_VPORT (dat, obj);\n      break;\n    case DWG_TYPE_APPID_CONTROL:\n      error = dwg_decode_APPID_CONTROL (dat, obj);\n      if (!error && obj->tio.object->tio.APPID_CONTROL)\n        {\n          obj->tio.object->tio.APPID_CONTROL->objid = num;\n          dwg->appid_control = *obj->tio.object->tio.APPID_CONTROL;\n        }\n      break;\n    case DWG_TYPE_APPID:\n      error = dwg_decode_APPID (dat, obj);\n      break;\n    case DWG_TYPE_DIMSTYLE_CONTROL:\n      error = dwg_decode_DIMSTYLE_CONTROL (dat, obj);\n      if (!error && obj->tio.object->tio.DIMSTYLE_CONTROL)\n        {\n          obj->tio.object->tio.DIMSTYLE_CONTROL->objid = num;\n          dwg->dimstyle_control = *obj->tio.object->tio.DIMSTYLE_CONTROL;\n        }\n      break;\n    case DWG_TYPE_DIMSTYLE:\n      error = dwg_decode_DIMSTYLE (dat, obj);\n      break;\n    case DWG_TYPE_VPORT_ENTITY_CONTROL:\n      error = dwg_decode_VPORT_ENTITY_CONTROL (dat, obj);\n      if (!error && obj->tio.object->tio.VPORT_ENTITY_CONTROL)\n        {\n          obj->tio.object->tio.VPORT_ENTITY_CONTROL->objid = num;\n          dwg->vport_entity_control\n              = *obj->tio.object->tio.VPORT_ENTITY_CONTROL;\n        }\n      break;\n    case DWG_TYPE_VPORT_ENTITY_HEADER:\n      error = dwg_decode_VPORT_ENTITY_HEADER (dat, obj);\n      break;\n    case DWG_TYPE_GROUP:\n      error = dwg_decode_GROUP (dat, obj);\n      break;\n    case DWG_TYPE_MLINESTYLE:\n      error = dwg_decode_MLINESTYLE (dat, obj);\n      break;\n    case DWG_TYPE_OLE2FRAME:\n      error = dwg_decode_OLE2FRAME (dat, obj);\n      break;\n    case DWG_TYPE_DUMMY:\n      error = dwg_decode_DUMMY (dat, obj);\n      break;\n    case DWG_TYPE_LONG_TRANSACTION:\n      error = dwg_decode_LONG_TRANSACTION (dat, obj);\n      break;\n    case DWG_TYPE_LWPOLYLINE:\n      error = dwg_decode_LWPOLYLINE (dat, obj);\n      break;\n    case DWG_TYPE_HATCH:\n      error = dwg_decode_HATCH (dat, obj);\n      break;\n    case DWG_TYPE_XRECORD:\n      error = dwg_decode_XRECORD (dat, obj);\n      break;\n    case DWG_TYPE_PLACEHOLDER:\n      error = dwg_decode_PLACEHOLDER (dat, obj);\n      break;\n    case DWG_TYPE_OLEFRAME:\n      error = dwg_decode_OLEFRAME (dat, obj);\n      break;\n    case DWG_TYPE_VBA_PROJECT:\n      LOG_ERROR (\"Unhandled Object VBA_PROJECT. Has its own section\");\n      // dwg_decode_VBA_PROJECT(dat, obj);\n      error = DWG_ERR_UNHANDLEDCLASS;\n      break;\n    case DWG_TYPE_LAYOUT:\n      error = dwg_decode_LAYOUT (dat, obj);\n      break;\n    case DWG_TYPE_PROXY_ENTITY:\n      error = dwg_decode_PROXY_ENTITY (dat, obj);\n      break;\n    case DWG_TYPE_PROXY_OBJECT:\n      error = dwg_decode_PROXY_OBJECT (dat, obj);\n      break;\n    default:\n      if (obj->type == dwg->layout_type)\n        error = dwg_decode_LAYOUT (dat, obj);\n      /* > 500 */\n      else if ((error = dwg_decode_variable_type (dwg, dat, hdl_dat, obj))\n               & DWG_ERR_UNHANDLEDCLASS)\n        {\n          int is_entity = 0;\n          int i = obj->type - 500;\n          Dwg_Class *klass = NULL;\n\n          /* restart and read into the UNKNOWN_OBJ object */\n          /* the relative offset from type after common_entity_data */\n          // obj->common_size = bit_position(dat) - restartpos;\n          // LOG_HANDLE(\"common_size: %lu\\n\", obj->common_size); // needed for\n          // unknown\n          bit_set_position (dat, restartpos);\n          obj->supertype = DWG_SUPERTYPE_UNKNOWN;\n\n          if (i >= 0 && i < (int)dwg->num_classes)\n            {\n              klass = &dwg->dwg_class[i];\n              is_entity = dwg_class_is_entity (klass);\n            }\n          else\n            {\n              if (i < 0)\n                {\n                  LOG_ERROR (\"Invalid class index %d <0\", i);\n                }\n              else\n                {\n                  LOG_ERROR (\"Invalid class index %d >%d\", i,\n                             (int)dwg->num_classes);\n                }\n              obj->type = 0;\n              *dat = abs_dat;\n              return error | DWG_ERR_VALUEOUTOFBOUNDS;\n            }\n          // properly dwg_decode_object/_entity for eed, reactors, xdic\n          if (is_entity)\n              error |= dwg_decode_UNKNOWN_ENT (dat, obj);\n          else\n              error |= dwg_decode_UNKNOWN_OBJ (dat, obj);\n\n          if (!dat)\n            return error;\n          if (error >= DWG_ERR_CRITICAL)\n            *dat = abs_dat;\n        }\n    }\n\n  if (obj->handle.value)\n    { // empty only with UNKNOWN\n      LOG_HANDLE (\" object_map{%lX} = %lu\\n\", obj->handle.value,\n                  (unsigned long)num);\n      hash_set (dwg->object_map, obj->handle.value, (uint32_t)num);\n    }\n\n  if (dat->byte > 8 * dat->size)\n    {\n      LOG_ERROR (\"Invalid object address (overflow): %lu > %lu\", dat->byte,\n                 8 * dat->size);\n      *dat = abs_dat;\n      return error | DWG_ERR_INVALIDDWG;\n    }\n\n  /* Restore the old absolute chain.\n     CRC needs to be calculated from address, which is before our 0 position.\n   */\n  restartpos = bit_position (dat);\n  *dat = abs_dat;\n  bit_set_position (dat, objpos + restartpos);\n\n  /* Now 1 padding bits until next byte, and then a RS CRC */\n  if (dat->bit)\n    {\n      unsigned char r = 8 - dat->bit;\n      LOG_HANDLE (\" padding: %X/%X (%d bits)\\n\", dat->chain[dat->byte],\n                  dat->chain[dat->byte] & ((1 << r) - 1), r);\n      bit_advance_position (dat, r);\n    }\n  bit_set_position (dat, (obj->address + obj->size) * 8 - 2);\n  if (!bit_check_CRC (dat, address, 0xC0C1))\n    error |= DWG_ERR_WRONGCRC;\n\n  /* Reset to previous addresses for return */\n  *dat = abs_dat;\n\n  return realloced ? -1 : error; // re-alloced or not\n}\n\n/** dwg_decode_unknown\n   Container to hold a unknown class entity, see classes.inc\n   Every DEBUGGING class holds a bits array, a bitsize, and the handle\n   and string stream offsets.\n   It starts after the common_entity|object_data until and goes until the end\n   of final padding, to the CRC.\n   (obj->common_size/8 .. obj->size)\n */\nint\ndwg_decode_unknown (Bit_Chain *restrict dat, Dwg_Object *restrict obj)\n{\n  // bitsize does not include the handles size\n  int num_bytes;\n  unsigned long pos = bit_position (dat);\n  long num_bits = (8 * obj->size) - pos;\n  if (num_bits < 0)\n    return DWG_ERR_VALUEOUTOFBOUNDS;\n\n  //*pre_bits = pos % 8;\n  obj->num_unknown_bits = num_bits;\n  num_bytes = num_bits / 8;\n  if (num_bits % 8)\n    {\n      num_bytes++;\n      dat->size++; // allow overshoot by one byte (for missing bits)\n    }\n\n  obj->unknown_bits = bit_read_TF (dat, num_bytes);\n  // [num_bits (commonsize, hdlpos, strsize)]\n  LOG_TRACE (\"unknown_bits [%ld (%lu,%ld,%d) TF]: \", num_bits,\n             obj->common_size, obj->bitsize - obj->common_size,\n             (int)obj->stringstream_size);\n  LOG_TRACE_TF (obj->unknown_bits, num_bytes);\n  bit_set_position (dat, pos);\n  if (num_bits % 8)\n    dat->size--;\n  return 0;\n}\n\n/* A dimension is immediately followed by BLOCK_HEADER - BLOCK.name - ENDBLK */\n/* sometimes also by a layer */\nchar *\ndwg_dim_blockname (Dwg_Data *restrict dwg, const Dwg_Object *restrict obj)\n{\n  BITCODE_BL id = obj->tio.entity->objid;\n  Dwg_Object *restrict hdr = &dwg->object[id + 1];\n  Dwg_Object *restrict blk = &dwg->object[id + 2];\n\n  if ((hdr->type == DWG_TYPE_LAYER || hdr->type == DWG_TYPE_DICTIONARY)\n      && blk->type == DWG_TYPE_BLOCK_HEADER)\n    {\n      hdr = blk;\n      blk = &dwg->object[id + 3];\n    }\n  if (hdr->type == DWG_TYPE_BLOCK_HEADER && blk->type == DWG_TYPE_BLOCK)\n    {\n      Dwg_Entity_BLOCK *restrict _blk = blk->tio.entity->tio.BLOCK;\n      return _blk->name;\n    }\n  return NULL;\n}\n\n/* Ensure that the given refs have rising objid's/indices (when read in natural\n * order) */\nstatic inline int\nref_after (const Dwg_Object_Ref *restrict r1,\n           const Dwg_Object_Ref *restrict r2)\n{\n  if (!r1 || !r2 || !r1->obj || !r2->obj)\n    return 0;\n  return r1->obj->index >= r2->obj->index ? 1 : 0;\n}\n\n/* just look at the next object, if it's a SEQEND (i.e ENDBLK) */\nint\ndwg_validate_INSERT (Dwg_Object *restrict obj)\n{\n  Dwg_Object *restrict next = dwg_next_object (obj);\n\n  if (obj->fixedtype == DWG_TYPE_INSERT)\n    {\n      Dwg_Entity_INSERT *restrict _obj = obj->tio.entity->tio.INSERT;\n      Dwg_Object_Ref *restrict seqend = _obj->seqend;\n      if (!_obj->has_attribs)\n        return 1;\n      if (!seqend || next == seqend->obj)\n        {\n          LOG_TRACE (\"unsorted INSERT %lX SEQEND %lX ATTRIB\\n\",\n                     obj->handle.value,\n                     seqend && seqend->obj ? seqend->obj->handle.value : 0L)\n          return 0;\n        }\n    }\n  else if (obj->fixedtype == DWG_TYPE_MINSERT)\n    {\n      Dwg_Entity_MINSERT *restrict _obj = obj->tio.entity->tio.MINSERT;\n      Dwg_Object_Ref *restrict seqend = _obj->seqend;\n      if (!_obj->has_attribs)\n        return 1;\n      if (!seqend || next == seqend->obj)\n        {\n          LOG_TRACE (\"unsorted INSERT %lX SEQEND %lX ATTRIB\\n\",\n                     obj->handle.value,\n                     seqend && seqend->obj ? seqend->obj->handle.value : 0L)\n          return 0;\n        }\n    }\n  return 1;\n}\n\nint\ndwg_validate_POLYLINE (Dwg_Object *restrict obj)\n{\n  /* We ensured the common fields structure is shared with all 4 types */\n  Dwg_Entity_POLYLINE_2D *restrict _obj = obj->tio.entity->tio.POLYLINE_2D;\n  Dwg_Data *restrict dwg = obj->parent;\n\n  if (dwg->header.version > R_11)\n    {\n      Dwg_Object_Ref *restrict seqend = _obj->seqend;\n      /* if shifted in check_POLYLINE_handles() seqend might be empty */\n      if (!seqend)\n        { /* either the first or last */\n          Dwg_Object *restrict next = dwg_next_object (obj);\n          if (next && next->fixedtype == DWG_TYPE_SEQEND)\n            {\n              seqend = dwg_find_objectref (\n                  dwg, next); // usually not found, even with set hash\n              if (seqend == NULL)\n                {\n                  seqend\n                      = (Dwg_Object_Ref *)calloc (1, sizeof (Dwg_Object_Ref));\n                  seqend->obj = next;\n                  seqend->handleref = next->handle;\n                  seqend->absolute_ref = next->handle.value;\n                  dwg_decode_add_object_ref (dwg, seqend);\n                }\n              _obj->seqend = seqend;\n              LOG_WARN (\"fixed empty POLYLINE.seqend with +1 obj\")\n            }\n          else if (_obj->vertex)\n            {\n              Dwg_Object_Ref *restrict ref = _obj->vertex[_obj->num_owned - 1];\n              if (ref && ref->obj)\n                {\n                  next = dwg_next_object (ref->obj);\n                  if (next && next->fixedtype == DWG_TYPE_SEQEND)\n                    {\n                      seqend = dwg_find_objectref (dwg, next);\n                      if (seqend == NULL)\n                        {\n                          seqend = (Dwg_Object_Ref *)calloc (\n                              1, sizeof (Dwg_Object_Ref));\n                          seqend->obj = next;\n                          seqend->handleref = next->handle;\n                          seqend->absolute_ref = next->handle.value;\n                          dwg_decode_add_object_ref (dwg, seqend);\n                        }\n                      _obj->seqend = seqend;\n                      LOG_WARN (\n                          \"fixed empty POLYLINE.seqend with last vertex +1\")\n                    }\n                }\n            }\n        }\n    }\n  if (dwg->header.version > R_11 && dwg->header.version <= R_2000)\n    {\n      Dwg_Object_Ref *restrict first_vertex = _obj->first_vertex;\n      Dwg_Object_Ref *restrict last_vertex = _obj->last_vertex;\n      Dwg_Object_Ref *restrict seqend = _obj->seqend;\n      if (ref_after (first_vertex, last_vertex)\n          || ref_after (last_vertex, seqend))\n        {\n          LOG_TRACE (\"unsorted POLYLINE VERTEX SEQEND\\n\")\n          return 0;\n        }\n    }\n  else if (dwg->header.version >= R_2004 && _obj->vertex)\n    {\n      BITCODE_BL i = 1;\n      Dwg_Object_Ref *restrict first_vertex = _obj->vertex[0];\n      Dwg_Object_Ref *restrict seqend = _obj->seqend;\n      if (ref_after (first_vertex, seqend))\n        {\n          /* r2010+ often mix up the hdlstream offset:\n             layer,vertex*,seqend. check the types then also */\n          if (first_vertex->obj->index < obj->index)\n            {\n              LOG_WARN (\"skip wrong POLYLINE.vertex[0] handle %lX < %lX\\n\",\n                        first_vertex->obj->handle.value, obj->handle.value);\n              if (_obj->num_owned > 1)\n                first_vertex = _obj->vertex[1];\n              i = 2;\n            }\n          else\n            {\n              LOG_TRACE (\"unsorted POLYLINE VERTEX SEQEND\\n\")\n              return 0;\n            }\n        }\n      for (; i < _obj->num_owned; i++)\n        {\n          if (ref_after (first_vertex, _obj->vertex[i])\n              || ref_after (_obj->vertex[i], seqend))\n            {\n              LOG_TRACE (\"unsorted POLYLINE VERTEX SEQEND\\n\")\n              return 0;\n            }\n        }\n    }\n  return 1;\n}\n\nstatic const char *\ndwg_ref_objname (const Dwg_Data *restrict dwg, Dwg_Object_Ref *restrict ref)\n{\n  Dwg_Object *restrict obj = dwg_ref_object_silent (dwg, ref);\n  return obj ? obj->name : \"\";\n}\n\n// supports tables entries and everything with a name.\n// r2007 names are returned as malloc'ed utf-8\nstatic const char *\ndwg_ref_tblname (const Dwg_Data *restrict dwg, Dwg_Object_Ref *restrict ref)\n{\n  const char *restrict name = dwg_dynapi_handle_name (dwg, ref);\n  return name ? name : \"\";\n}\n\n#undef IS_DECODER\n", "/*****************************************************************************/\n/*  LibreDWG - free implementation of the DWG file format                    */\n/*                                                                           */\n/*  Copyright (C) 2009-2010,2018-2019 Free Software Foundation, Inc.         */\n/*  Copyright (C) 2010 Thien-Thi Nguyen                                      */\n/*                                                                           */\n/*  This library is free software, licensed under the terms of the GNU       */\n/*  General Public License as published by the Free Software Foundation,     */\n/*  either version 3 of the License, or (at your option) any later version.  */\n/*  You should have received a copy of the GNU General Public License        */\n/*  along with this program.  If not, see <http://www.gnu.org/licenses/>.    */\n/*****************************************************************************/\n\n/*\n * encode.c: encoding functions to write a DWG\n * written by Felipe Castro\n * modified by Felipe Corr\u00eaa da Silva Sances\n * modified by Rodrigo Rodrigues da Silva\n * modified by Thien-Thi Nguyen\n * modified by Till Heuschmann\n * modified by Anderson Pierre Cardoso\n * modified by Reini Urban\n */\n\n#include \"config.h\"\n#ifdef __STDC_ALLOC_LIB__\n#  define __STDC_WANT_LIB_EXT2__ 1 /* for strdup */\n#else\n#  define _USE_BSD 1\n#endif\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <string.h>\n#include <assert.h>\n\n#include \"common.h\"\n#include \"bits.h\"\n#include \"dwg.h\"\n#include \"encode.h\"\n#include \"decode.h\"\n\n/* The logging level for the write (encode) path.  */\nstatic unsigned int loglevel;\n/* the current version per spec block */\nstatic unsigned int cur_ver = 0;\n\n#ifdef USE_TRACING\n/* This flag means we have checked the environment variable\n   LIBREDWG_TRACE and set `loglevel' appropriately.  */\nstatic bool env_var_checked_p;\n#endif /* USE_TRACING */\n#define DWG_LOGLEVEL loglevel\n\n#include \"logging.h\"\n\n/*--------------------------------------------------------------------------------\n * spec MACROS\n */\n\n#define ACTION encode\n#define IS_ENCODER\n\n#define ANYCODE -1\n#define REFS_PER_REALLOC 100\n\n#define VALUE(value, type, dxf)                                               \\\n  {                                                                           \\\n    bit_write_##type (dat, value);                                            \\\n    LOG_TRACE (FORMAT_##type \" [\" #type \" %d]\\n\", value, dxf);                \\\n  }\n#define VALUE_RC(value, dxf) VALUE (value, RC, dxf)\n#define VALUE_RS(value, dxf) VALUE (value, RS, dxf)\n#define VALUE_RL(value, dxf) VALUE (value, RL, dxf)\n#define VALUE_RD(value, dxf) VALUE (value, RD, dxf)\n\n#define FIELD(nam, type)                                                      \\\n  {                                                                           \\\n    bit_write_##type (dat, _obj->nam);                                        \\\n    FIELD_TRACE (nam, type);                                                  \\\n  }\n#define FIELDG(nam, type, dxf)                                                \\\n  {                                                                           \\\n    bit_write_##type (dat, _obj->nam);                                        \\\n    FIELD_G_TRACE (nam, type, dxf);                                           \\\n  }\n#define FIELD_TRACE(nam, type)                                                \\\n  LOG_TRACE (#nam \": \" FORMAT_##type \"\\n\", _obj->nam)\n#define FIELD_G_TRACE(nam, type, dxfgroup)                                    \\\n  LOG_TRACE (#nam \": \" FORMAT_##type \" [\" #type \" \" #dxfgroup \"]\\n\", _obj->nam)\n#define FIELD_CAST(nam, type, cast, dxf)                                      \\\n  {                                                                           \\\n    bit_write_##type (dat, (BITCODE_##type)_obj->nam);                        \\\n    FIELD_G_TRACE (nam, cast, dxf);                                           \\\n  }\n#define SUB_FIELD(o, nam, type, dxf) FIELD (o.nam, type)\n\n#define FIELD_VALUE(nam) _obj->nam\n\n#define FIELD_B(nam, dxf)    FIELDG (nam, B, dxf)\n#define FIELD_BB(nam, dxf)   FIELDG (nam, BB, dxf)\n#define FIELD_3B(nam, dxf)   FIELDG (nam, 3B, dxf)\n#define FIELD_BS(nam, dxf)   FIELDG (nam, BS, dxf)\n#define FIELD_BSd(nam, dxf)  FIELD_CAST(nam, BS, BSd, dxf)\n#define FIELD_RSx(nam, dxf)  FIELD_CAST(nam, RS, RSx, dxf)\n#define FIELD_RLx(nam, dxf)  FIELD_CAST(nam, RL, RLx, dxf)\n#define FIELD_BLx(nam, dxf)  FIELD_CAST(nam, BL, BLx, dxf)\n#define FIELD_BLd(nam, dxf)  FIELD_CAST(nam, BL, BLd, dxf)\n#define FIELD_RLd(nam, dxf)  FIELD_CAST(nam, RL, RLd, dxf)\n#define FIELD_BL(nam, dxf)   FIELDG (nam, BL, dxf)\n#define FIELD_BLL(nam, dxf)  FIELDG (nam, BLL, dxf)\n#define FIELD_BD(nam, dxf) FIELDG (nam, BD, dxf)\n#define FIELD_RC(nam, dxf) FIELDG (nam, RC, dxf)\n#define FIELD_RS(nam, dxf) FIELDG (nam, RS, dxf)\n#define FIELD_RD(nam, dxf) FIELDG (nam, RD, dxf)\n#define FIELD_RL(nam, dxf) FIELDG (nam, RL, dxf)\n#define FIELD_RLL(nam, dxf) FIELDG (nam, RLL, dxf)\n#define FIELD_MC(nam, dxf) FIELDG (nam, MC, dxf)\n#define FIELD_MS(nam, dxf) FIELDG (nam, MS, dxf)\n#define FIELD_TV(nam, dxf)                                                    \\\n  {                                                                           \\\n    IF_ENCODE_FROM_EARLIER { if (!_obj->nam) _obj->nam = strdup (\"\"); }       \\\n    FIELDG (nam, TV, dxf);                                                    \\\n  }\n#define FIELD_T(nam, dxf)                                                     \\\n  {                                                                           \\\n    if (dat->version < R_2007)                                                \\\n      {                                                                       \\\n        FIELD_TV (nam, dxf)                                                   \\\n      }                                                                       \\\n    else                                                                      \\\n      {                                                                       \\\n        if (!obj || obj->has_strings)                                         \\\n          {                                                                   \\\n            FIELD_TU (nam, dxf)                                               \\\n          }                                                                   \\\n        else                                                                  \\\n          {                                                                   \\\n            LOG_TRACE_TU (#nam, L\"\", dxf);                                    \\\n          }                                                                   \\\n      }                                                                       \\\n  }\n#define FIELD_TF(nam, len, dxf)                                               \\\n  {                                                                           \\\n    if (len > 0)                                                              \\\n      {                                                                       \\\n        if (!_obj->nam)                                                       \\\n          { /* empty field, write zeros */                                    \\\n            for (int _i = 0; _i < (int)(len); _i++)                           \\\n              bit_write_RC (dat, 0);                                          \\\n          }                                                                   \\\n        else                                                                  \\\n          bit_write_TF (dat, (BITCODE_TF)_obj->nam, len);                     \\\n      }                                                                       \\\n    FIELD_G_TRACE (nam, TF, dxf);                                             \\\n  }\n#define FIELD_TFF(nam, len, dxf)  FIELD_TF(nam, len, dxf)\n#define FIELD_TU(nam, dxf)                                                    \\\n  {                                                                           \\\n    if (_obj->nam)                                                            \\\n      bit_write_TU (dat, (BITCODE_TU)_obj->nam);                              \\\n    LOG_TRACE_TU (#nam, (BITCODE_TU)_obj->nam, dxf);                          \\\n  }\n#define FIELD_BT(nam, dxf) FIELDG (nam, BT, dxf);\n\n#define _FIELD_DD(nam, _default, dxf)                                         \\\n  bit_write_DD (dat, FIELD_VALUE (nam), _default);\n#define FIELD_DD(nam, _default, dxf)                                          \\\n  _FIELD_DD(nam, _default, dxf);                                              \\\n  LOG_TRACE (#nam \": %f [DD %d]\\n\", _obj->nam, dxf)\n#define FIELD_2DD(nam, d1, d2, dxf)                                           \\\n  {                                                                           \\\n    _FIELD_DD (nam.x, d1, dxf);                                               \\\n    _FIELD_DD (nam.y, d2, dxf + 10);                                          \\\n    LOG_TRACE (#nam \": (%f, %f) [2DD %d]\\n\", _obj->nam.x, _obj->nam.y, dxf)   \\\n  }\n#define FIELD_3DD(nam, def, dxf)                                              \\\n  {                                                                           \\\n    _FIELD_DD (nam.x, FIELD_VALUE (def.x), dxf);                              \\\n    _FIELD_DD (nam.y, FIELD_VALUE (def.y), dxf + 10);                         \\\n    _FIELD_DD (nam.z, FIELD_VALUE (def.z), dxf + 20);                         \\\n    LOG_TRACE (#nam \": (%f, %f, %f) [3DD %d]\\n\", _obj->nam.x, _obj->nam.y,    \\\n               _obj->nam.z, dxf)                                              \\\n  }\n#define FIELD_2RD(nam, dxf)                                                   \\\n  {                                                                           \\\n    bit_write_RD (dat, _obj->nam.x);                                          \\\n    bit_write_RD (dat, _obj->nam.y);                                          \\\n    LOG_TRACE (#nam \": (%f, %f) [3RD %d]\\n\", _obj->nam.x, _obj->nam.y, dxf)   \\\n  }\n#define FIELD_2BD(nam, dxf)                                                   \\\n  {                                                                           \\\n    bit_write_BD (dat, _obj->nam.x);                                          \\\n    bit_write_BD (dat, _obj->nam.y);                                          \\\n    LOG_TRACE (#nam \": (%f, %f) [3BD %d]\\n\", _obj->nam.x, _obj->nam.y, dxf)   \\\n  }\n#define FIELD_2BD_1(nam, dxf) FIELD_2BD(nam, dxf)\n#define FIELD_3RD(nam, dxf)                                                   \\\n  {                                                                           \\\n    bit_write_RD (dat, _obj->nam.x);                                          \\\n    bit_write_RD (dat, _obj->nam.y);                                          \\\n    bit_write_RD (dat, _obj->nam.z);                                          \\\n    LOG_TRACE (#nam \": (%f, %f, %f) [3RD %d]\\n\", _obj->nam.x, _obj->nam.y,    \\\n               _obj->nam.z, dxf)                                              \\\n  }\n#define FIELD_3BD(nam, dxf)                                                   \\\n  {                                                                           \\\n    bit_write_BD (dat, _obj->nam.x);                                          \\\n    bit_write_BD (dat, _obj->nam.y);                                          \\\n    bit_write_BD (dat, _obj->nam.z);                                          \\\n    LOG_TRACE (#nam \": (%f, %f, %f) [3BD %d]\\n\", _obj->nam.x, _obj->nam.y,    \\\n               _obj->nam.z, dxf)                                              \\\n  }\n#define FIELD_3BD_1(nam, dxf)   FIELD_3BD(nam, dxf)\n#define FIELD_3DPOINT(nam, dxf) FIELD_3BD (nam, dxf)\n#define FIELD_4BITS(nam, dxf)                                                 \\\n  {                                                                           \\\n    unsigned char _b = (unsigned char)_obj->nam;                              \\\n    bit_write_4BITS (dat, _b);                                                \\\n    LOG_TRACE (#nam \": b%d%d%d%d [4BITS %d]\\n\", _b & 8, _b & 4, _b & 2,       \\\n               _b & 1, dxf);                                                  \\\n  }\n#define FIELD_TIMEBLL(nam, dxf)                                               \\\n  {                                                                           \\\n    bit_write_TIMEBLL (dat, (BITCODE_TIMEBLL)_obj->nam);                      \\\n    LOG_TRACE (#nam \": \" FORMAT_BL \".\" FORMAT_BL \"\\n\", _obj->nam.days,        \\\n               _obj->nam.ms);                                                 \\\n  }\n\n#define FIELD_CMC(color, dxf1, dxf2)                                          \\\n  {                                                                           \\\n    bit_write_CMC (dat, &_obj->color);                                        \\\n    LOG_TRACE (#color \".index: %d [CMC.BS %d]\\n\", _obj->color.index, dxf1);   \\\n    if (dat->version >= R_2004)                                               \\\n      {                                                                       \\\n        LOG_TRACE (#color \".rgb: 0x%06x [CMC.BL %d]\\n\",                       \\\n                   (unsigned)_obj->color.rgb, dxf2);                          \\\n        LOG_TRACE (#color \".flag: 0x%x [CMC.RC]\\n\",                           \\\n                   (unsigned)_obj->color.flag);                               \\\n        if (_obj->color.flag & 1)                                             \\\n          LOG_TRACE (#color \".name: %s [CMC.TV]\\n\", _obj->color.name);        \\\n        if (_obj->color.flag & 2)                                             \\\n          LOG_TRACE (#color \".bookname: %s [CMC.TV]\\n\",                       \\\n                     _obj->color.book_name);                                  \\\n      }                                                                       \\\n  }\n\n#define SUB_FIELD_CMC(o, nam, dxf1, dxf2) bit_write_CMC (dat, &_obj->o.nam)\n\n#define FIELD_BE(nam, dxf)                                                    \\\n  bit_write_BE (dat, FIELD_VALUE (nam.x), FIELD_VALUE (nam.y),                \\\n                FIELD_VALUE (nam.z));\n\n// No overflow check with IS_RELEASE\n#ifdef IS_RELEASE\n#  define OVERFLOW_CHECK(nam, size)\n#  define OVERFLOW_CHECK_LV(nam, size)\n#else\n#  define OVERFLOW_CHECK(nam, size)                                           \\\n    if ((long)(size) > 0xff00L)                                               \\\n      {                                                                       \\\n        LOG_ERROR (\"Invalid \" #nam \" %ld\", (long)size);                       \\\n        return DWG_ERR_VALUEOUTOFBOUNDS;                                      \\\n      }\n#  define OVERFLOW_CHECK_LV(nam, size)                                        \\\n    if ((long)(size) > 0xff00L)                                               \\\n      {                                                                       \\\n        LOG_ERROR (\"Invalid \" #nam \" %ld, set to 0\", (long)size);             \\\n        size = 0;                                                             \\\n        return DWG_ERR_VALUEOUTOFBOUNDS;                                      \\\n      }\n#endif\n\n#define FIELD_2RD_VECTOR(nam, size, dxf)                                      \\\n  OVERFLOW_CHECK_LV (nam, _obj->size)                                         \\\n  for (vcount = 0; vcount < (BITCODE_BL)_obj->size; vcount++)                 \\\n    {                                                                         \\\n      FIELD_2RD (nam[vcount], dxf);                                           \\\n    }\n\n#define FIELD_2DD_VECTOR(nam, size, dxf)                                      \\\n  OVERFLOW_CHECK (nam, _obj->size)                                            \\\n  if (_obj->size)                                                             \\\n    FIELD_2RD (nam[0], dxf);                                                  \\\n  for (vcount = 1; vcount < (BITCODE_BL)_obj->size; vcount++)                 \\\n    {                                                                         \\\n      FIELD_2DD (nam[vcount], FIELD_VALUE (nam[vcount - 1].x),                \\\n                 FIELD_VALUE (nam[vcount - 1].y), dxf);                       \\\n    }\n\n#define FIELD_3DPOINT_VECTOR(nam, size, dxf)                                  \\\n  OVERFLOW_CHECK_LV (nam, _obj->size)                                         \\\n  for (vcount = 0; vcount < (BITCODE_BL)_obj->size; vcount++)                 \\\n    {                                                                         \\\n      FIELD_3DPOINT (nam[vcount], dxf);                                       \\\n    }\n\n#define REACTORS(code)                                                        \\\n  if (obj->tio.object->reactors)                                              \\\n    {                                                                         \\\n      OVERFLOW_CHECK_LV (nam, obj->tio.object->num_reactors)                  \\\n      SINCE (R_13)                                                            \\\n      {                                                                       \\\n        for (vcount = 0; vcount < (BITCODE_BL)obj->tio.object->num_reactors;  \\\n             vcount++)                                                        \\\n          {                                                                   \\\n            VALUE_HANDLE (obj->tio.object->reactors[vcount], reactors, code,  \\\n                          330);                                               \\\n          }                                                                   \\\n      }                                                                       \\\n    }\n\n#define XDICOBJHANDLE(code)                                                   \\\n  RESET_VER                                                                   \\\n  SINCE (R_2004)                                                              \\\n  {                                                                           \\\n    if (!obj->tio.object->xdic_missing_flag)                                  \\\n      {                                                                       \\\n        VALUE_HANDLE (obj->tio.object->xdicobjhandle, xdicobjhandle, code,    \\\n                      360);                                                   \\\n      }                                                                       \\\n  }                                                                           \\\n  else                                                                        \\\n  {                                                                           \\\n    SINCE (R_13)                                                              \\\n    {                                                                         \\\n      VALUE_HANDLE (obj->tio.object->xdicobjhandle, xdicobjhandle, code,      \\\n                    360);                                                     \\\n    }                                                                         \\\n  }                                                                           \\\n  RESET_VER\n\n#define ENT_XDICOBJHANDLE(code)                                               \\\n  RESET_VER                                                                   \\\n  SINCE (R_2004)                                                              \\\n  {                                                                           \\\n    if (!obj->tio.entity->xdic_missing_flag)                                  \\\n      {                                                                       \\\n        VALUE_HANDLE (obj->tio.entity->xdicobjhandle, xdicobjhandle, code,    \\\n                      360);                                                   \\\n      }                                                                       \\\n  }                                                                           \\\n  else                                                                        \\\n  {                                                                           \\\n    SINCE (R_13)                                                              \\\n    {                                                                         \\\n      VALUE_HANDLE (obj->tio.entity->xdicobjhandle, xdicobjhandle, code,      \\\n                    360);                                                     \\\n    }                                                                         \\\n  }                                                                           \\\n  RESET_VER\n\n// FIELD_VECTOR_N(nam, type, size, dxf):\n// writes a 'size' elements vector of data of the type indicated by 'type'\n#define FIELD_VECTOR_N(nam, type, size, dxf)                                  \\\n  if (size > 0 && _obj->nam)                                                  \\\n    {                                                                         \\\n      OVERFLOW_CHECK (nam, size)                                              \\\n      for (vcount = 0; vcount < (BITCODE_BL)size; vcount++)                   \\\n        {                                                                     \\\n          bit_write_##type (dat, _obj->nam[vcount]);                          \\\n          LOG_TRACE (#nam \"[%ld]: \" FORMAT_##type \"\\n\", (long)vcount,         \\\n                     _obj->nam[vcount])                                       \\\n        }                                                                     \\\n    }\n#define FIELD_VECTOR_T(nam, size, dxf)                                        \\\n  if (_obj->size > 0 && _obj->nam)                                            \\\n    {                                                                         \\\n      OVERFLOW_CHECK_LV (nam, _obj->size)                                     \\\n      for (vcount = 0; vcount < (BITCODE_BL)_obj->size; vcount++)             \\\n        {                                                                     \\\n          PRE (R_2007)                                                        \\\n          {                                                                   \\\n            bit_write_TV (dat, _obj->nam[vcount]);                            \\\n            LOG_TRACE (#nam \"[%d]: %s\\n\", (int)vcount, _obj->nam[vcount])     \\\n          }                                                                   \\\n          else                                                                \\\n          {                                                                   \\\n            bit_write_TU (dat, (BITCODE_TU)_obj->nam[vcount]);                \\\n            LOG_TRACE_TU (#nam, _obj->nam[vcount], dxf)                       \\\n          }                                                                   \\\n        }                                                                     \\\n      RESET_VER                                                               \\\n    }\n\n#define FIELD_VECTOR(nam, type, size, dxf)                                    \\\n  FIELD_VECTOR_N (nam, type, _obj->size, dxf)\n\n#define VALUE_HANDLE(hdlptr, nam, handle_code, dxf)                           \\\n  IF_ENCODE_SINCE_R13                                                         \\\n  {                                                                           \\\n    RESET_VER                                                                 \\\n    if (!hdlptr)                                                              \\\n      {                                                                       \\\n        Dwg_Handle null_handle = { 0, 0, 0 };                                 \\\n        null_handle.code = handle_code;                                       \\\n        bit_write_H (hdl_dat, &null_handle);                                  \\\n        LOG_TRACE (#nam \": (%d.0.0) abs:0 [H %d]\\n\", handle_code, dxf)        \\\n      }                                                                       \\\n    else                                                                      \\\n      {                                                                       \\\n        if (handle_code != ANYCODE && hdlptr->handleref.code != handle_code   \\\n            && (handle_code == 4 && hdlptr->handleref.code < 6))              \\\n          {                                                                   \\\n            LOG_WARN (\"Expected a CODE %d handle, got a %d\", handle_code,     \\\n                      hdlptr->handleref.code);                                \\\n          }                                                                   \\\n        bit_write_H (hdl_dat, &hdlptr->handleref);                            \\\n        LOG_TRACE (#nam \": \" FORMAT_REF \" [H %d]\\n\", ARGS_REF (hdlptr), dxf)  \\\n      }                                                                       \\\n  }\n\n#define FIELD_HANDLE(nam, handle_code, dxf)                                   \\\n  VALUE_HANDLE (_obj->nam, nam, handle_code, dxf)\n#define SUB_FIELD_HANDLE(o, nam, handle_code, dxf)                            \\\n  VALUE_HANDLE (_obj->o.nam, nam, handle_code, dxf)\n#define FIELD_DATAHANDLE(nam, handle_code, dxf)                               \\\n  {                                                                           \\\n    bit_write_H (dat, _obj->nam ? &_obj->nam->handleref : NULL);              \\\n  }\n\n#define FIELD_HANDLE_N(nam, vcount, handle_code, dxf)                         \\\n  IF_ENCODE_SINCE_R13                                                         \\\n  {                                                                           \\\n    RESET_VER                                                                 \\\n    if (!_obj->nam)                                                           \\\n      {                                                                       \\\n        bit_write_H (hdl_dat, NULL);                                          \\\n        LOG_TRACE (#nam \"[%d]: NULL %d [H* %d]\\n\", (int)vcount, handle_code,  \\\n                   dxf)                                                       \\\n      }                                                                       \\\n    else                                                                      \\\n      {                                                                       \\\n        if (handle_code != ANYCODE                                            \\\n            && _obj->nam->handleref.code != handle_code                       \\\n            && (handle_code == 4 && _obj->nam->handleref.code < 6))           \\\n          {                                                                   \\\n            LOG_WARN (\"Expected a CODE %x handle, got a %x\", handle_code,     \\\n                      _obj->nam->handleref.code);                             \\\n          }                                                                   \\\n        bit_write_H (hdl_dat, &_obj->nam->handleref);                         \\\n        LOG_TRACE (#nam \"[%d]: \" FORMAT_REF \" [H* %d]\\n\", (int)vcount,        \\\n                   ARGS_REF (_obj->nam), dxf)                                 \\\n      }                                                                       \\\n  }\n\n#define HANDLE_VECTOR_N(nam, size, code, dxf)                                 \\\n  if (size > 0 && _obj->nam)                                                  \\\n    {                                                                         \\\n      OVERFLOW_CHECK (nam, size)                                              \\\n      for (vcount = 0; vcount < (BITCODE_BL)size; vcount++)                   \\\n        {                                                                     \\\n          if (_obj->nam[vcount])                                              \\\n            {                                                                 \\\n              FIELD_HANDLE_N (nam[vcount], vcount, code, dxf);                \\\n            }                                                                 \\\n        }                                                                     \\\n    }\n\n#define FIELD_NUM_INSERTS(num_inserts, type, dxf)                             \\\n  for (vcount = 0; vcount < FIELD_VALUE (num_inserts); vcount++)              \\\n    {                                                                         \\\n      bit_write_RC (dat, 1);                                                  \\\n    }                                                                         \\\n  bit_write_RC (dat, 0);                                                      \\\n  LOG_TRACE (\"num_inserts: %d [RC* 0]\\n\", FIELD_VALUE (num_inserts))\n\n#define HANDLE_VECTOR(nam, sizefield, code, dxf)                              \\\n  HANDLE_VECTOR_N (nam, FIELD_VALUE (sizefield), code, dxf)\n\n#define FIELD_XDATA(nam, size)                                                \\\n  error |= dwg_encode_xdata (dat, _obj, _obj->size)\n\n#define COMMON_ENTITY_HANDLE_DATA                                             \\\n  SINCE (R_13)                                                                \\\n  {                                                                           \\\n    START_HANDLE_STREAM;                                                      \\\n    PRE (R_2007)                                                              \\\n    {                                                                         \\\n      error |= dwg_encode_common_entity_handle_data (dat, hdl_dat, obj);      \\\n    }                                                                         \\\n  }                                                                           \\\n  RESET_VER\n\n#define SECTION_STRING_STREAM                                                 \\\n  {                                                                           \\\n    Bit_Chain sav_dat = *dat;                                                 \\\n    dat = str_dat;\n\n/* TODO: dump all TU strings here */\n#define START_STRING_STREAM                                                   \\\n  bit_write_B (dat, obj->has_strings);                                        \\\n  RESET_VER                                                                   \\\n  if (obj->has_strings)                                                       \\\n    {                                                                         \\\n      Bit_Chain sav_dat = *dat;                                               \\\n      obj_string_stream (dat, obj, dat);\n\n#define END_STRING_STREAM                                                     \\\n  *dat = sav_dat;                                                             \\\n  }\n#define START_HANDLE_STREAM                                                   \\\n  *hdl_dat = *dat;                                                            \\\n  if (dat->version >= R_2007 && obj->bitsize)                                 \\\n    bit_set_position (hdl_dat, obj->hdlpos);                                  \\\n  if (!obj->bitsize)                                                          \\\n    {                                                                         \\\n      LOG_TRACE (\"-bitsize calc from HANDLE_STREAM @%lu.%u (%lu)\\n\",          \\\n                 dat->byte, dat->bit, obj->address);                          \\\n      obj->bitsize = bit_position (dat) - (obj->address * 8);                 \\\n    }                                                                         \\\n  RESET_VER\n\n#if 0\n/** See dec_macro.h instead.\n   Returns -1 if not added, else returns the new objid.\n   Does a complete handleref rescan to invalidate and resolve\n   all internal obj pointers after a object[] realloc.\n*/\nEXPORT long dwg_add_##token (Dwg_Data * dwg)    \\\n{                                               \\\n  Bit_Chain dat = { 0 };                        \\\n  BITCODE_BL num_objs  = dwg->num_objects;      \\\n  int error = 0;                                \\\n  dat.size = sizeof(Dwg_Entity_##token) + 40;   \\\n  LOG_INFO (\"Add entity \" #token \" \")           \\\n  dat.chain = calloc (dat.size, 1);             \\\n  dat.version = dwg->header.version;            \\\n  dat.from_version = dwg->header.from_version;  \\\n  bit_write_MS (&dat, dat.size);                \\\n  if (dat.version >= R_2010) {                  \\\n    /* FIXME: should be UMC handlestream_size */\\\n    bit_write_UMC (&dat, 8*sizeof(Dwg_Entity_##token)); \\\n    bit_write_BOT &dat, DWG_TYPE_##token);      \\\n  } else {                                      \\\n    bit_write_BS (&dat, DWG_TYPE_##token);      \\\n  }                                             \\\n  bit_set_position (&dat, 0);                   \\\n  error = dwg_decode_add_object (dwg, &dat, &dat, 0);\\\n  if (-1 == error)                              \\\n    dwg_resolve_objectrefs_silent (dwg);        \\\n  if (num_objs == dwg->num_objects)             \\\n    return -1;                                  \\\n  else                                          \\\n    return (long)dwg->num_objects;              \\\n}\n\nEXPORT long dwg_add_##token (Dwg_Data * dwg)     \\\n{                                                \\\n  Bit_Chain dat = { 0 };                         \\\n  int error = 0; \\\n  BITCODE_BL num_objs  = dwg->num_objects;       \\\n  dat.size = sizeof(Dwg_Object_##token) + 40;    \\\n  LOG_INFO (\"Add object \" #token \" \")            \\\n  dat.chain = calloc (dat.size, 1);              \\\n  dat.version = dwg->header.version;             \\\n  dat.from_version = dwg->header.from_version;   \\\n  bit_write_MS (&dat, dat.size);                 \\\n  if (dat.version >= R_2010) {                   \\\n    /* FIXME: should be UMC handlestream_size */ \\\n    bit_write_UMC (&dat, 8*sizeof(Dwg_Object_##token)); \\\n    bit_write_BOT (&dat, DWG_TYPE_##token);      \\\n  } else {                                       \\\n    bit_write_BS (&dat, DWG_TYPE_##token);       \\\n  }                                              \\\n  bit_set_position(&dat, 0);                     \\\n  error = dwg_decode_add_object(dwg, &dat, &dat, 0);\\\n  if (-1 ==  error) \\\n    dwg_resolve_objectrefs_silent(dwg);          \\\n  if (num_objs == dwg->num_objects)              \\\n    return -1;                                   \\\n  else                                           \\\n    return (long)dwg->num_objects;               \\\n}\n\n#endif\n\n#define DWG_ENTITY(token)                                                     \\\n  static int dwg_encode_##token (Bit_Chain *restrict dat,                     \\\n                                 Dwg_Object *restrict obj)                    \\\n  {                                                                           \\\n    BITCODE_BL vcount, rcount1, rcount2, rcount3, rcount4;                    \\\n    Dwg_Object_Entity *_ent = obj->tio.entity;                                \\\n    Dwg_Entity_##token *_obj = _ent->tio.token;                               \\\n    int error;                                                                \\\n    Bit_Chain *hdl_dat = dat;                                                 \\\n    Bit_Chain *str_dat = dat;                                                 \\\n    Dwg_Data *dwg = obj->parent;                                              \\\n    LOG_INFO (\"Encode entity \" #token \"\\n\")                                   \\\n    error = dwg_encode_entity (obj, dat, hdl_dat, str_dat);                   \\\n    if (error)                                                                \\\n      return error;\n\n#define DWG_ENTITY_END                                                        \\\n  return error;                                                               \\\n  }\n\n/** Returns -1 if not added, else returns the new objid.\n   Does a complete handleref rescan to invalidate and resolve\n   all internal obj pointers after a object[] realloc.\n*/\n#define DWG_OBJECT(token)                                                     \\\n  static int dwg_encode_##token (Bit_Chain *restrict dat,                     \\\n                                 Dwg_Object *restrict obj)                    \\\n  {                                                                           \\\n    BITCODE_BL vcount, rcount1, rcount2, rcount3, rcount4;                    \\\n    int error;                                                                \\\n    Bit_Chain *hdl_dat = dat;                                                 \\\n    Bit_Chain *str_dat = dat;                                                 \\\n    Dwg_Data *dwg = obj->parent;                                              \\\n    Dwg_Object_##token *_obj = obj->tio.object->tio.token;                    \\\n    error = dwg_encode_object (obj, dat, hdl_dat, str_dat);                   \\\n    if (error)                                                                \\\n      return error;                                                           \\\n    LOG_INFO (\"Encode object \" #token \"\\n\")\n\n#define DWG_OBJECT_END                                                        \\\n  return error;                                                               \\\n  }\n\n#define ENT_REACTORS(code)                                                    \\\n  if (dat->version >= R_2000 && _obj->num_reactors > 0x1000)                  \\\n    {                                                                         \\\n      fprintf (stderr, \"Invalid num_reactors: %ld\\n\",                         \\\n               (long)_obj->num_reactors);                                     \\\n      return DWG_ERR_VALUEOUTOFBOUNDS;                                        \\\n    }                                                                         \\\n  SINCE (R_13)                                                                \\\n  {                                                                           \\\n    if (_obj->num_reactors && !_obj->reactors)                                \\\n      {                                                                       \\\n        LOG_ERROR (\"NULL entity.reactors\");                                   \\\n        return DWG_ERR_VALUEOUTOFBOUNDS;                                      \\\n      }                                                                       \\\n    for (vcount = 0; vcount < _obj->num_reactors; vcount++)                   \\\n      {                                                                       \\\n        FIELD_HANDLE_N (reactors[vcount], vcount, code, 330);                 \\\n      }                                                                       \\\n  }\n\n#undef DEBUG_POS\n#define DEBUG_POS                                                             \\\n  if (DWG_LOGLEVEL >= DWG_LOGLEVEL_TRACE)                                     \\\n    {                                                                         \\\n      LOG_TRACE (\"DEBUG_POS @%u.%u / 0x%x (%lu)\\n\", (unsigned int)dat->byte,  \\\n                 dat->bit, (unsigned int)dat->byte, bit_position (dat));      \\\n    }\n\n/*--------------------------------------------------------------------------------*/\ntypedef struct\n{\n  unsigned long handle;\n  long address;\n  BITCODE_BL index;\n} Object_Map;\n\n/*--------------------------------------------------------------------------------\n * Private functions prototypes\n */\nstatic int encode_preR13 (Dwg_Data *restrict dwg, Bit_Chain *restrict dat);\n\nstatic int dwg_encode_entity (Dwg_Object *restrict obj, Bit_Chain *dat,\n                              Bit_Chain *hdl_dat, Bit_Chain *str_dat);\nstatic int dwg_encode_object (Dwg_Object *restrict obj,\n                              Bit_Chain *str_dat, Bit_Chain *hdl_dat,\n                              Bit_Chain *dat);\nstatic int dwg_encode_common_entity_handle_data (Bit_Chain *dat,\n                                                 Bit_Chain *hdl_dat,\n                                                 Dwg_Object *restrict obj);\nstatic int dwg_encode_header_variables (Bit_Chain *dat, Bit_Chain *hdl_dat,\n                                        Bit_Chain *str_dat, Dwg_Data *restrict dwg);\nstatic int dwg_encode_variable_type (Dwg_Data *restrict dwg,\n                                     Bit_Chain *restrict dat,\n                                     Dwg_Object *restrict obj);\nvoid dwg_encode_handleref (Bit_Chain *hdl_dat, Dwg_Object *restrict obj,\n                           Dwg_Data *restrict dwg,\n                           Dwg_Object_Ref *restrict ref);\nvoid dwg_encode_handleref_with_code (Bit_Chain *hdl_dat, Dwg_Object *restrict obj,\n                                     Dwg_Data *restrict dwg,\n                                     Dwg_Object_Ref *restrict ref,\n                                     unsigned int code);\nint dwg_encode_add_object (Dwg_Object *restrict obj, Bit_Chain *restrict dat,\n                           unsigned long address);\n\nstatic int dwg_encode_xdata (Bit_Chain *restrict dat,\n                             Dwg_Object_XRECORD *restrict obj, int size);\n\n/*--------------------------------------------------------------------------------\n * Public functions\n */\n\nstatic BITCODE_RL\nencode_patch_RLsize (Bit_Chain *dat, long unsigned int pvzadr)\n{\n  unsigned long pos;\n  BITCODE_RL size;\n  if (dat->bit) // padding\n    {\n      dat->bit = 0;\n      dat->byte++;\n    }\n  size = dat->byte - pvzadr - 4; // minus the RL size\n  pos = bit_position (dat);\n  assert (pvzadr);\n  bit_set_position (dat, pvzadr * 8);\n  bit_write_RL (dat, size);\n  LOG_TRACE (\"size: \" FORMAT_RL \" [RL] @%lu\\n\", size, pvzadr);\n  bit_set_position (dat, pos);\n  return size;\n}\n\n/**\n * dwg_encode(): the current generic encoder entry point.\n *\n * TODO: preR13 tables, 2007 maps.\n * 2010+ uses the 2004 format.\n * Returns a summary bitmask of all errors.\n */\nint\ndwg_encode (Dwg_Data *restrict dwg, Bit_Chain *restrict dat)\n{\n  int ckr_missing = 1;\n  int error = 0;\n  BITCODE_BL i, j;\n  long unsigned int section_address;\n  unsigned char pvzbit;\n  long unsigned int pvzadr;\n  long unsigned int pvzadr_2;\n  unsigned int ckr;\n  unsigned int sec_size = 0;\n  long unsigned int last_offset;\n  BITCODE_BL last_handle;\n  Object_Map *omap;\n  Bit_Chain *hdl_dat;\n\n  if (dwg->opts)\n    loglevel = dwg->opts & DWG_OPTS_LOGLEVEL;\n#ifdef USE_TRACING\n  /* Before starting, set the logging level, but only do so once.  */\n  if (!env_var_checked_p)\n    {\n      char *probe = getenv (\"LIBREDWG_TRACE\");\n      if (probe)\n        loglevel = atoi (probe);\n      env_var_checked_p = true;\n    }\n#endif /* USE_TRACING */\n\n  bit_chain_alloc (dat);\n  hdl_dat = dat;\n\n  /*------------------------------------------------------------\n   * Header\n   */\n  strcpy ((char *)dat->chain,\n          version_codes[dwg->header.version]); // Chain version\n  if (dwg->header.version != dwg->header.from_version)\n    LOG_TRACE (\"Encode version %s from version %s\\n\",\n               version_codes[dwg->header.version],\n               version_codes[dwg->header.from_version])\n  else\n    LOG_TRACE (\"Encode version %s\\n\", version_codes[dwg->header.version])\n  dat->byte += 6;\n\n  {\n    struct Dwg_Header *_obj = &dwg->header;\n    Dwg_Object *obj = NULL;\n    if (!_obj->dwg_version)\n      {\n        _obj->is_maint = 0;\n        switch (dwg->header.version)\n          {\n          case R_9:\n            _obj->dwg_version = 0x11; // ?\n            break;\n          case R_10:\n            _obj->dwg_version = 0x12; // ?\n            break;\n          case R_11:\n            _obj->dwg_version = 0x13; // ?\n            break;\n          case R_13:\n            _obj->dwg_version = 0x15;\n            break;\n          case R_14:\n            _obj->dwg_version = 0x16;\n            break;\n          case R_2000:\n            _obj->dwg_version = 0x17;\n            _obj->is_maint = 0xf;\n            break;\n          case R_2004:\n            _obj->dwg_version = 0x19;\n            _obj->is_maint = 0x68;\n            break;\n          case R_2007:\n            _obj->dwg_version = 0x1b;\n            _obj->is_maint = 0x32;\n            break;\n          case R_2010:\n            _obj->dwg_version = 0x1d;\n            _obj->is_maint = 0x6d;\n            break;\n          case R_2013:\n            _obj->dwg_version = 0x1f;\n            _obj->is_maint = 0x7d;\n            break;\n          case R_2018:\n            _obj->dwg_version = 0x21;\n            _obj->is_maint = 0x4;\n            break;\n          case R_INVALID:\n          case R_AFTER:\n          case R_1_1:\n          case R_1_2:\n          case R_1_4:\n          case R_2_0:\n          case R_2_1:\n          case R_2_5:\n          case R_2_6:\n          default:\n            break;\n          }\n        if (!_obj->app_dwg_version)\n          _obj->app_dwg_version = _obj->dwg_version;\n      }\n    if (!_obj->codepage)\n      _obj->codepage = 30;\n\n    // clang-format off\n    #include \"header.spec\"\n    // clang-format on\n  }\n  section_address = dat->byte;\n\n#define WE_CAN                                                                \\\n  \"This version of LibreDWG is only capable of encoding \"                     \\\n  \"version R13-R2000 (code: AC1012-AC1015) DWG files.\\n\"\n\n  PRE (R_13)\n  {\n    // TODO: tables, entities, block entities\n    LOG_ERROR (WE_CAN \"We don't encode preR13 tables, entities, blocks yet\")\n#ifndef IS_RELEASE\n    return encode_preR13 (dwg, dat);\n#endif\n  }\n\n  PRE (R_2004)\n  {\n    /* section 0: header vars\n     *         1: class section\n     *         2: object map\n     *         3: (R13 c3 and later): 2nd header (special table no sentinels)\n     *         4: optional: MEASUREMENT\n     *         5: optional: AuxHeader\n     */\n    if (!dwg->header.num_sections) /* Usually 3-5, max 6 */\n      {\n        dwg->header.num_sections = dwg->header.version < R_2000 ? 5 : 6;\n        // minimal DXF:\n        if (!dwg->header_vars.HANDSEED || !dwg->header_vars.TDCREATE.days)\n          {\n            dwg->header.num_sections = 5;\n            dat->from_version = R_11; // to trigger IF_ENCODE_FROM_EARLIER defaults\n            if (dat->version <= dat->from_version)\n              dat->from_version = dat->version - 1;\n          }\n      }\n    LOG_TRACE (\"num_sections: \" FORMAT_RL \" [RL]\\n\", dwg->header.num_sections);\n    bit_write_RL (dat, dwg->header.num_sections);\n    if (!dwg->header.section)\n      dwg->header.section\n          = calloc (dwg->header.num_sections, sizeof (Dwg_Section));\n    section_address = dat->byte;                 // save section address\n    dat->byte += (dwg->header.num_sections * 9); /* RC + 2*RL */\n    bit_write_CRC (dat, 0, 0xC0C1);\n    bit_write_sentinel (dat, dwg_sentinel (DWG_SENTINEL_HEADER_END));\n\n    /*------------------------------------------------------------\n     * AuxHeader section 5\n     * R2000+, mostly redundant file header information\n     */\n    if (dwg->header.num_sections > 5)\n      {\n        struct Dwg_AuxHeader *_obj = &dwg->auxheader;\n        Dwg_Object *obj = NULL;\n        assert (!dat->bit);\n        LOG_INFO (\"\\n=======> AuxHeader: %8u\\n\",\n                  (unsigned)dat->byte); // size: 123\n\n        dwg->header.section[SECTION_AUXHEADER_R2000].number = 5;\n        dwg->header.section[SECTION_AUXHEADER_R2000].address = dat->byte;\n\n        if (!_obj->dwg_version)\n          {\n            BITCODE_RS tmpunknown[] = { 4, 0x565, 0, 0, 2, 1 };\n            LOG_TRACE (\"Use AuxHeader defaults...\\n\");\n            FIELD_VALUE (aux_intro[0]) = 0xff;\n            FIELD_VALUE (aux_intro[1]) = 0x77;\n            FIELD_VALUE (aux_intro[2]) = 0x01;\n            FIELD_VALUE (minus_1) = -1;\n            FIELD_VALUE (dwg_version) = dwg->header.dwg_version;\n            FIELD_VALUE (maint_version) = dwg->header.maint_version;\n            FIELD_VALUE (dwg_version_1) = dwg->header.dwg_version;\n            FIELD_VALUE (dwg_version_2) = dwg->header.dwg_version;\n            FIELD_VALUE (maint_version_1) = dwg->header.maint_version;\n            FIELD_VALUE (maint_version_2) = dwg->header.maint_version;\n            memcpy (FIELD_VALUE (unknown_rs), tmpunknown, sizeof (tmpunknown));\n            FIELD_VALUE (TDCREATE) = dwg->header_vars.TDCREATE.value;\n            FIELD_VALUE (TDUPDATE) = dwg->header_vars.TDUPDATE.value;\n            if (dwg->header_vars.HANDSEED)\n              FIELD_VALUE (HANDSEED) = dwg->header_vars.HANDSEED->absolute_ref;\n          }\n\n          // clang-format off\n        #include \"auxheader.spec\"\n        // clang-format on\n\n        assert (!dat->bit);\n        dwg->header.section[SECTION_AUXHEADER_R2000].size\n            = dat->byte - dwg->header.section[SECTION_AUXHEADER_R2000].address;\n      }\n  }\n\n  VERSION (R_2007)\n  {\n    LOG_ERROR (WE_CAN \"We don't encode R2007 sections yet\")\n    return DWG_ERR_NOTYETSUPPORTED;\n  }\n\n  /* r2004 file header (compressed + encrypted) */\n  SINCE (R_2004)\n  {\n    /* System Section */\n    typedef union _system_section\n    {\n      unsigned char data[0x14]; // 20byte: 5*4\n      struct\n      {\n        uint32_t section_type; /* 0x4163043b */\n        uint32_t decomp_data_size;\n        uint32_t comp_data_size;\n        uint32_t compression_type;\n        uint32_t checksum; // see section_page_checksum\n      } fields;\n    } system_section;\n\n    system_section ss;\n    Dwg_Section *section;\n\n    Dwg_Object *obj = NULL;\n    struct Dwg_R2004_Header *_obj = &dwg->r2004_header;\n    const int size = sizeof (struct Dwg_R2004_Header);\n    char encrypted_data[size];\n    unsigned int rseed = 1;\n    uint32_t checksum;\n\n    LOG_ERROR (WE_CAN \"We don't encode the R2004_section_map yet\")\n\n    if (dwg->header.section_infohdr.num_desc && !dwg->header.section_info)\n      dwg->header.section_info = calloc (dwg->header.section_infohdr.num_desc,\n                                         sizeof (Dwg_Section_Info));\n\n    dat->byte = 0x80;\n    for (i = 0; i < (BITCODE_BL)size; i++)\n      {\n        rseed *= 0x343fd;\n        rseed += 0x269ec3;\n        encrypted_data[i] = bit_read_RC (dat) ^ (rseed >> 0x10);\n      }\n    LOG_TRACE (\"\\n#### Write 2004 File Header ####\\n\");\n    dat->byte = 0x80;\n    if (dat->byte + 0x80 >= dat->size - 1)\n      {\n        dat->size = dat->byte + 0x80;\n        bit_chain_alloc (dat);\n      }\n    memcpy (&dat->chain[0x80], encrypted_data, size);\n    LOG_INFO (\"@0x%lx\\n\", dat->byte);\n\n    // clang-format off\n    #include \"r2004_file_header.spec\"\n    // clang-format on\n\n    dwg->r2004_header.checksum = 0;\n    dwg->r2004_header.checksum = dwg_section_page_checksum (0, dat, size);\n\n    /*-------------------------------------------------------------------------\n     * Section Page Map\n     */\n    dat->byte = dwg->r2004_header.section_map_address + 0x100;\n\n    LOG_TRACE (\"\\n=== Write System Section (Section Page Map) ===\\n\");\n#ifndef HAVE_COMPRESS_R2004_SECTION\n    dwg->r2004_header.comp_data_size = dwg->r2004_header.decomp_data_size;\n    dwg->r2004_header.compression_type = 0;\n#endif\n    FIELD_RL (section_type, 0); // should be 0x4163043b\n    FIELD_RL (decomp_data_size, 0);\n    FIELD_RL (comp_data_size, 0);\n    FIELD_RL (compression_type, 0);\n    dwg_section_page_checksum (dwg->r2004_header.checksum, dat, size);\n    FIELD_RL (checksum, 0);\n    LOG_TRACE (\"\\n\")\n\n    LOG_WARN (\"TODO write_R2004_section_map(dat, dwg)\")\n    LOG_TRACE (\"\\n\")\n\n    return DWG_ERR_NOTYETSUPPORTED;\n  }\n\n  /*------------------------------------------------------------\n   * THUMBNAIL preview pictures\n   */\n  if (!dwg->header.thumbnail_address)\n    dwg->header.thumbnail_address = dat->byte;\n  dat->bit = 0;\n  LOG_TRACE (\"\\n=======> Thumbnail:       %4u\\n\", (unsigned)dat->byte);\n  // dwg->thumbnail.size = 0; // to disable\n  bit_write_sentinel (dat, dwg_sentinel (DWG_SENTINEL_THUMBNAIL_BEGIN));\n  if (dwg->thumbnail.size == 0)\n    {\n      bit_write_RL (dat, 5); // overall size\n      LOG_TRACE (\"Thumbnail size: 5 [RL]\\n\");\n      bit_write_RC (dat, 0); // num_pictures\n      LOG_TRACE (\"Thumbnail num_pictures: 0 [RC]\\n\");\n    }\n  else\n    {\n      bit_write_TF (dat, (char *)dwg->thumbnail.chain, dwg->thumbnail.size);\n    }\n  bit_write_sentinel (dat, dwg_sentinel (DWG_SENTINEL_THUMBNAIL_END));\n\n  {\n    BITCODE_RL size;\n    dwg_bmp (dwg, &size);\n    if (size > dwg->thumbnail.size)\n      LOG_ERROR (\"BMP size overflow: %i > %lu\\n\", size, dwg->thumbnail.size);\n  }\n  LOG_TRACE (\"         Thumbnail (end): %4u\\n\", (unsigned)dat->byte);\n\n  /*------------------------------------------------------------\n   * Header Variables\n   */\n  assert (!dat->bit);\n  LOG_INFO (\"\\n=======> Header Variables:   %4u\\n\", (unsigned)dat->byte);\n  dwg->header.section[0].number = 0;\n  dwg->header.section[0].address = dat->byte;\n  bit_write_sentinel (dat, dwg_sentinel (DWG_SENTINEL_VARIABLE_BEGIN));\n\n  pvzadr = dat->byte;      // Size position\n  bit_write_RL (dat, 540); // Size placeholder\n  // if (dat->version >= R_2007)\n  //  str_dat = dat;\n  dwg_encode_header_variables (dat, hdl_dat, dat, dwg);\n  encode_patch_RLsize (dat, pvzadr);\n  bit_write_CRC (dat, pvzadr, 0xC0C1);\n\n  // XXX trying to fix CRC 2-byte overflow. Must find actual reason\n  // dat->byte -= 2;\n  bit_write_sentinel (dat, dwg_sentinel (DWG_SENTINEL_VARIABLE_END));\n  assert ((long)dat->byte > (long)dwg->header.section[0].address);\n  dwg->header.section[0].size\n      = (BITCODE_RL) ((long)dat->byte - (long)dwg->header.section[0].address);\n  LOG_TRACE (\"         Header Variables (end): %4u\\n\", (unsigned)dat->byte);\n\n  /*------------------------------------------------------------\n   * Classes\n   */\n  LOG_INFO (\"\\n=======> Classes: %4u (%d)\\n\", (unsigned)dat->byte, dwg->num_classes);\n  dwg->header.section[SECTION_CLASSES_R13].number = 1;\n  dwg->header.section[SECTION_CLASSES_R13].address = dat->byte;\n  bit_write_sentinel (dat, dwg_sentinel (DWG_SENTINEL_CLASS_BEGIN));\n  pvzadr = dat->byte;    // Size position\n  bit_write_RL (dat, 0); // Size placeholder\n\n  for (j = 0; j < dwg->num_classes; j++)\n    {\n      Dwg_Class *klass;\n      klass = &dwg->dwg_class[j];\n      bit_write_BS (dat, klass->number);\n      bit_write_BS (dat, klass->proxyflag);\n      bit_write_TV (dat, klass->appname);\n      bit_write_TV (dat, klass->cppname);\n      bit_write_TV (dat, klass->dxfname);\n      bit_write_B (dat, klass->wasazombie);\n      bit_write_BS (dat, klass->item_class_id);\n      LOG_TRACE (\"Class %d 0x%x %s\\n\"\n                 \" %s \\\"%s\\\" %d 0x%x\\n\",\n                 klass->number, klass->proxyflag, klass->dxfname,\n                 klass->cppname, klass->appname, klass->wasazombie,\n                 klass->item_class_id)\n\n      SINCE (R_2007)\n      {\n        bit_write_BL (dat, klass->num_instances);\n        bit_write_BL (dat, klass->dwg_version);\n        bit_write_BL (dat, klass->maint_version);\n        bit_write_BL (dat, klass->unknown_1);\n        bit_write_BL (dat, klass->unknown_2);\n        LOG_TRACE (\" %d %d\\n\", (int)klass->num_instances,\n                   (int)klass->dwg_version);\n      }\n    }\n\n  /* Write the size of the section at its beginning\n   */\n  assert (pvzadr);\n  encode_patch_RLsize (dat, pvzadr);\n  bit_write_CRC (dat, pvzadr, 0xC0C1);\n  bit_write_sentinel (dat, dwg_sentinel (DWG_SENTINEL_CLASS_END));\n  dwg->header.section[SECTION_CLASSES_R13].size\n      = dat->byte - dwg->header.section[SECTION_CLASSES_R13].address;\n  LOG_TRACE (\"       Classes (end): %4u\\n\", (unsigned)dat->byte);\n\n  bit_write_RL (dat, 0x0DCA); // 0xDCA Unknown bitlong inter class and objects\n  LOG_TRACE (\"unknown: %04X [RL]\\n\", 0x0DCA);\n\n  /*------------------------------------------------------------\n   * Objects\n   */\n\n  LOG_INFO (\"\\n=======> Objects: %4u\\n\", (unsigned)dat->byte);\n  pvzadr = dat->byte;\n\n  /* Sort object-map by ascending handles\n   */\n  LOG_TRACE (\"num_objects: %i\\n\", dwg->num_objects);\n  LOG_TRACE (\"num_object_refs: %i\\n\", dwg->num_object_refs);\n  omap = (Object_Map *)calloc (dwg->num_objects, sizeof (Object_Map));\n  if (!omap)\n    {\n      LOG_ERROR (\"Out of memory\");\n      return DWG_ERR_OUTOFMEM;\n    }\n  if (DWG_LOGLEVEL >= DWG_LOGLEVEL_HANDLE)\n    {\n      LOG_HANDLE (\"\\nSorting objects...\\n\");\n      for (i = 0; i < dwg->num_objects; i++)\n        fprintf (OUTPUT, \"Object(%3i): %4lX / idx: %u\\n\", i,\n                 dwg->object[i].handle.value, dwg->object[i].index);\n    }\n  // init unsorted\n  for (i = 0; i < dwg->num_objects; i++)\n    {\n      omap[i].index = i; // i.e. dwg->object[j].index\n      omap[i].handle = dwg->object[i].handle.value;\n    }\n  // insertion sort\n  for (i = 0; i < dwg->num_objects; i++)\n    {\n      Object_Map tmap;\n      j = i;\n      tmap = omap[i];\n      while (j > 0 && omap[j - 1].handle > tmap.handle)\n        {\n          omap[j] = omap[j - 1];\n          j--;\n        }\n      omap[j] = tmap;\n    }\n  if (DWG_LOGLEVEL >= DWG_LOGLEVEL_HANDLE)\n    {\n      LOG_HANDLE (\"\\nSorted handles:\\n\");\n      for (i = 0; i < dwg->num_objects; i++)\n        fprintf (OUTPUT, \"Handle(%3i): %4lX / idx: %u\\n\", i, omap[i].handle,\n                 omap[i].index);\n    }\n\n  /* Write the sorted objects\n   */\n  for (i = 0; i < dwg->num_objects; i++)\n    {\n      Dwg_Object *obj;\n      BITCODE_BL index = omap[i].index;\n      unsigned long hdloff = omap[i].handle - (i ? omap[i - 1].handle : 0);\n      int off = dat->byte - (i ? omap[i - 1].address : 0);\n      unsigned long address, end_address;\n      LOG_TRACE (\"\\n> Next object: \" FORMAT_BL\n                 \" Handleoff: %lX [UMC] Offset: %d [MC] @%lu\\n\"\n                 \"==========================================\\n\",\n                 i, hdloff, off, dat->byte);\n      omap[i].address = dat->byte;\n      if (index > dwg->num_objects)\n        {\n          LOG_ERROR (\"Invalid object map index \" FORMAT_BL \", max \" FORMAT_BL\n                     \". Skipping\",\n                     index, dwg->num_objects)\n          error |= DWG_ERR_VALUEOUTOFBOUNDS;\n          continue;\n        }\n      obj = &dwg->object[index];\n      // change the address to the linearly sorted one\n      assert (dat->byte);\n      error |= dwg_encode_add_object (obj, dat, dat->byte);\n\n#ifndef NDEBUG\n      // check if this object overwrote at address 0\n      if (dwg->header.version >= R_1_2)\n        {\n          assert (dat->chain[0] == 'A');\n          assert (dat->chain[1] == 'C');\n        }\n#endif\n      end_address = omap[i].address + (unsigned long)obj->size; // from RL\n      if (end_address > dat->size)\n        {\n          dat->size = end_address;\n          bit_chain_alloc (dat);\n        }\n    }\n\n  if (DWG_LOGLEVEL >= DWG_LOGLEVEL_HANDLE)\n    {\n      LOG_HANDLE (\"\\nSorted objects:\\n\");\n      for (i = 0; i < dwg->num_objects; i++)\n        LOG_HANDLE (\"Object(%d): %lX / Address: %ld / Idx: %d\\n\", i,\n                    omap[i].handle, omap[i].address, omap[i].index);\n    }\n\n  /* Unknown CRC between objects and object map\n   */\n  bit_write_RS (dat, 0);\n  LOG_TRACE (\"unknown crc?: %04X [RS]\\n\", 0);\n\n  /*------------------------------------------------------------\n   * Object-map\n   * split into chunks of max. 2030\n   */\n  LOG_INFO (\"\\n=======> Object Map: %4u\\n\", (unsigned)dat->byte);\n  dwg->header.section[SECTION_HANDLES_R13].number = 2;\n  dwg->header.section[SECTION_HANDLES_R13].address = dat->byte;\n\n  sec_size = 0;\n  pvzadr = dat->byte; // Correct value of section size must be written later\n  dat->byte += 2;\n  last_offset = 0;\n  last_handle = 0;\n  for (i = 0; i < dwg->num_objects; i++)\n    {\n      BITCODE_BL index;\n      BITCODE_UMC handleoff;\n      BITCODE_MC offset;\n\n      index = omap[i].index;\n      handleoff = omap[i].handle - last_handle;\n      bit_write_UMC (dat, handleoff);\n      LOG_HANDLE (\"Handleoff(%3i): %4lX [UMC] (%4lX), \", index, handleoff,\n                  omap[i].handle)\n      last_handle = omap[i].handle;\n\n      offset = omap[i].address - last_offset;\n      bit_write_MC (dat, offset);\n      last_offset = omap[i].address;\n      LOG_HANDLE (\"Offset: %8d [MC] @%lu\\n\", (int)offset, last_offset);\n\n      ckr_missing = 1;\n      if (dat->byte - pvzadr > 2030) // 2029\n        {\n          ckr_missing = 0;\n          sec_size = dat->byte - pvzadr;\n          assert (pvzadr);\n          // i.e. encode_patch_RS_LE_size\n          dat->chain[pvzadr] = sec_size >> 8;\n          dat->chain[pvzadr + 1] = sec_size & 0xFF;\n          LOG_TRACE (\"Handles page size: %u [RS_LE] @%lu\\n\", sec_size, pvzadr);\n          bit_write_CRC_LE (dat, pvzadr, 0xC0C1);\n\n          pvzadr = dat->byte;\n          dat->byte += 2;\n          last_offset = 0;\n          last_handle = 0;\n        }\n    }\n  // printf (\"Obj size: %u\\n\", i);\n  if (ckr_missing)\n    {\n      sec_size = dat->byte - pvzadr;\n      assert (pvzadr);\n      // i.e. encode_patch_RS_LE_size\n      dat->chain[pvzadr] = sec_size >> 8;\n      dat->chain[pvzadr + 1] = sec_size & 0xFF;\n      LOG_TRACE (\"Handles page size: %u [RS_LE] @%lu\\n\", sec_size, pvzadr);\n      bit_write_CRC_LE (dat, pvzadr, 0xC0C1);\n    }\n  if (dwg->header.version >= R_1_2)\n    {\n      assert (dat->chain[0] == 'A');\n      assert (dat->chain[1] == 'C');\n    }\n  pvzadr = dat->byte;\n  assert (pvzadr);\n  bit_write_RS_LE (dat, 2); // last section_size 2\n  LOG_TRACE (\"Handles page size: %u [RS_LE] @%lu\\n\", 2, pvzadr);\n  bit_write_CRC_LE (dat, pvzadr, 0xC0C1);\n\n  /* Calculate and write the size of the object map\n   */\n  dwg->header.section[SECTION_HANDLES_R13].size\n      = dat->byte - dwg->header.section[SECTION_HANDLES_R13].address;\n  free (omap);\n\n  /*------------------------------------------------------------\n   * Second header, section 3. R13-R2000 only.\n   * But partially also since r2004.\n   */\n  if (dwg->header.version >= R_13 && dwg->second_header.num_sections > 3)\n    {\n      struct _dwg_second_header *_obj = &dwg->second_header;\n      Dwg_Object *obj = NULL;\n      BITCODE_BL vcount;\n\n      assert (dat->byte);\n      if (!_obj->address)\n        _obj->address = dat->byte;\n      dwg->header.section[SECTION_2NDHEADER_R13].number = 3;\n      dwg->header.section[SECTION_2NDHEADER_R13].address = _obj->address;\n      dwg->header.section[SECTION_2NDHEADER_R13].size = _obj->size;\n      LOG_INFO (\"\\n=======> Second Header: %4u\\n\", (unsigned)dat->byte);\n      bit_write_sentinel (dat, dwg_sentinel (DWG_SENTINEL_SECOND_HEADER_BEGIN));\n\n      pvzadr = dat->byte; // Keep the first address of the section to write its\n                          // size later\n      LOG_TRACE (\"pvzadr: %lx\\n\", pvzadr);\n      if (!_obj->size && !_obj->num_sections)\n        {\n          LOG_TRACE (\"Use second_header defaults...\\n\");\n          strcpy ((char *)&_obj->version[0],\n                  &version_codes[dwg->header.version][0]);\n          memset (&_obj->version[7], 0, 4);\n          _obj->version[11] = '\\n';\n          _obj->unknown_10 = 0x10;\n          _obj->unknown_rc4[0] = 0x84;\n          _obj->unknown_rc4[1] = 0x74;\n          _obj->unknown_rc4[2] = 0x78;\n          _obj->unknown_rc4[3] = 0x1;\n          if (dwg->header.version <= R_2000)\n            {\n              _obj->num_sections = dwg->header.num_sections;\n              for (i = 0; i < _obj->num_sections; i++)\n                {\n                  _obj->section[i].nr = dwg->header.section[i].number;\n                  _obj->section[i].address = dwg->header.section[i].address;\n                  _obj->section[i].size = dwg->header.section[i].size;\n                }\n              // TODO handlers\n            }\n          _obj->junk_r14_1 = 1957593121; //?\n          _obj->junk_r14_2 = 2559919056; //?\n        }\n\n      FIELD_RL (size, 0);\n      if (FIELD_VALUE (address) != (BITCODE_RL) (pvzadr - 16))\n        {\n          LOG_WARN (\"second_header->address %x != %x\", FIELD_VALUE (address),\n                    (unsigned)(pvzadr - 16));\n          FIELD_VALUE (address) = pvzadr - 16;\n        }\n      FIELD_BLx (address, 0);\n\n      // AC1012, AC1014 or AC1015. This is a char[11], zero padded.\n      // with \\n at 12.\n      bit_write_TF (dat, (char *)_obj->version, 12);\n      LOG_TRACE (\"version: %s [TFF 12]\\n\", _obj->version)\n\n      for (i = 0; i < 4; i++)\n        FIELD_B (null_b[i], 0);\n      FIELD_RC (unknown_10, 0); // 0x10\n      for (i = 0; i < 4; i++)\n        FIELD_RC (unknown_rc4[i], 0);\n\n      UNTIL (R_2000)\n      {\n        FIELD_RC (num_sections, 0); // r14: 5, r2000: 6 (auxheader)\n        for (i = 0; i < FIELD_VALUE (num_sections); i++)\n          {\n            FIELD_RC (section[i].nr, 0);\n            FIELD_BLx (section[i].address, 0);\n            FIELD_BLd (section[i].size, 0);\n          }\n\n        FIELD_BS (num_handlers, 0); // 14, resp. 16 in r14\n        if (FIELD_VALUE (num_handlers) > 16)\n          {\n            LOG_ERROR (\"Second header num_handlers > 16: %d\\n\",\n                       FIELD_VALUE (num_handlers));\n            FIELD_VALUE (num_handlers) = 14;\n          }\n        for (i = 0; i < FIELD_VALUE (num_handlers); i++)\n          {\n            FIELD_RC (handlers[i].size, 0);\n            FIELD_RC (handlers[i].nr, 0);\n            FIELD_VECTOR (handlers[i].data, RC, handlers[i].size, 0);\n          }\n\n        _obj->size = encode_patch_RLsize (dat, pvzadr);\n        bit_write_CRC (dat, pvzadr, 0xC0C1);\n\n        VERSION (R_14)\n        {\n          FIELD_RL (junk_r14_1, 0);\n          FIELD_RL (junk_r14_2, 0);\n        }\n      }\n      bit_write_sentinel (dat, dwg_sentinel (DWG_SENTINEL_SECOND_HEADER_END));\n      dwg->header.section[SECTION_2NDHEADER_R13].size\n          = dat->byte - _obj->address;\n    }\n  else if (dwg->header.num_sections > SECTION_2NDHEADER_R13)\n    {\n      dwg->header.section[SECTION_2NDHEADER_R13].number = 3;\n      dwg->header.section[SECTION_2NDHEADER_R13].address = 0;\n      dwg->header.section[SECTION_2NDHEADER_R13].size = 0;\n    }\n\n  /*------------------------------------------------------------\n   * MEASUREMENT Section 4\n   * In a DXF under header_vars\n   */\n  if (dwg->header.num_sections > SECTION_MEASUREMENT_R13)\n    {\n      LOG_INFO (\"\\n=======> MEASUREMENT: %4u\\n\", (unsigned)dat->byte);\n      dwg->header.section[SECTION_MEASUREMENT_R13].number = 4;\n      dwg->header.section[SECTION_MEASUREMENT_R13].address = dat->byte;\n      dwg->header.section[SECTION_MEASUREMENT_R13].size = 4;\n      // 0 - English, 1- Metric\n      bit_write_RL (dat, (BITCODE_RL)dwg->header_vars.MEASUREMENT);\n      LOG_TRACE (\"HEADER.MEASUREMENT: %d [RL]\\n\", dwg->header_vars.MEASUREMENT);\n    }\n\n  /* End of the file\n   */\n  dat->size = dat->byte;\n\n  /* Write section addresses\n   */\n  assert (section_address);\n  dat->byte = section_address;\n  dat->bit = 0;\n  LOG_INFO (\"\\n=======> section addresses: %4u\\n\", (unsigned)dat->byte);\n  for (j = 0; j < dwg->header.num_sections; j++)\n    {\n      bit_write_RC (dat, dwg->header.section[j].number);\n      bit_write_RL (dat, dwg->header.section[j].address);\n      bit_write_RL (dat, dwg->header.section[j].size);\n      LOG_TRACE (\"section[%u].number: %2d [RC]\\n\", j,\n                 (int)dwg->header.section[j].number)\n      LOG_TRACE (\"section[%u].offset: 0x%x [RLx]\\n\", j,\n                 (unsigned)dwg->header.section[j].address)\n      LOG_TRACE (\"section[%u].size: %4d [RL]\\n\", j,\n                 (int)dwg->header.section[j].size)\n    }\n\n  /* Write CRC's\n   */\n  bit_write_CRC (dat, 0, 0);\n  dat->byte -= 2;\n  ckr = bit_read_CRC (dat);\n  dat->byte -= 2;\n  switch (dwg->header.num_sections)\n    {\n    case 3:\n      ckr ^= 0xA598;\n      break;\n    case 4:\n      ckr ^= 0x8101;\n      break;\n    case 5:\n      ckr ^= 0x3CC4;\n      break;\n    case 6:\n      ckr ^= 0x8461;\n      break;\n    default:\n      break;\n    }\n  bit_write_RS (dat, ckr);\n  LOG_TRACE (\"crc: %04X (from 0)\\n\", ckr);\n\n  return 0;\n}\n\nstatic int\nencode_preR13 (Dwg_Data *restrict dwg, Bit_Chain *restrict dat)\n{\n  return DWG_ERR_NOTYETSUPPORTED;\n}\n\n// needed for r2004+ encode and decode (check-only) (unused)\n// p 4.3: first calc with seed 0, then compress, then recalc with prev.\n// checksum\nuint32_t\ndwg_section_page_checksum (const uint32_t seed, Bit_Chain *restrict dat, uint32_t size)\n{\n  uint32_t sum1 = seed & 0xffff;\n  uint32_t sum2 = seed >> 0x10;\n  unsigned char *data = &(dat->chain[dat->byte]);\n\n  while (size)\n    {\n      uint32_t i;\n      uint32_t chunksize = size < 0x15b0 ? size : 0x15b0;\n      size -= chunksize;\n      for (i = 0; i < chunksize; i++)\n        {\n          sum1 += *data++;\n          sum2 += sum1;\n        }\n      sum1 %= 0xFFF1;\n      sum2 %= 0xFFF1;\n    }\n  return (sum2 << 0x10) | (sum1 & 0xffff);\n}\n\n#include \"dwg.spec\"\n\n// expand aliases: name => CLASSES.dxfname\nstatic const char *\ndxf_encode_alias (char *restrict name)\n{\n  if (strEQc (name, \"DICTIONARYWDFLT\"))\n    return \"ACDBDICTIONARYWDFLT\";\n  else if (strEQc (name, \"SECTIONVIEWSTYLE\"))\n    return \"ACDBSECTIONVIEWSTYLE\";\n  else if (strEQc (name, \"PLACEHOLDER\"))\n    return \"ACDBPLACEHOLDER\";\n  else if (strEQc (name, \"DETAILVIEWSTYLE\"))\n    return \"ACDBDETAILVIEWSTYLE\";\n  else if (strEQc (name, \"ASSOCPERSSUBENTMANAGER\"))\n    return \"ACDBASSOCPERSSUBENTMANAGER\";\n  else if (strEQc (name, \"EVALUATION_GRAPH\"))\n    return \"ACAD_EVALUATION_GRAPH\";\n  else if (strEQc (name, \"ASSOCACTION\"))\n    return \"ACDBASSOCACTION\";\n  else if (strEQc (name, \"ASSOCALIGNEDDIMACTIONBODY\"))\n    return \"ACDBASSOCALIGNEDDIMACTIONBODY\";\n  else if (strEQc (name, \"ASSOCOSNAPPOINTREFACTIONPARAM\"))\n    return \"ACDBASSOCOSNAPPOINTREFACTIONPARAM\";\n  else if (strEQc (name, \"ASSOCVERTEXACTIONPARAM\"))\n    return \"ACDBASSOCVERTEXACTIONPARAM\";\n  else if (strEQc (name, \"ASSOCGEOMDEPENDENCY\"))\n    return \"ACDBASSOCGEOMDEPENDENCY\";\n  else if (strEQc (name, \"ASSOCDEPENDENCY\"))\n    return \"ACDBASSOCDEPENDENCY\";\n  else if (strEQc (name, \"TABLE\"))\n    return \"ACAD_TABLE\";\n  else\n    return NULL;\n}\n\nDwg_Class *\ndwg_encode_get_class (Dwg_Data *dwg, Dwg_Object *obj)\n{\n  int i;\n  Dwg_Class *klass = NULL;\n  // indxf has a different class order\n  if (obj->dxfname) // search class by name, not offset\n    {\n      int invalid_klass = 0;\n      for (i = 0; i < dwg->num_classes; i++)\n        {\n          klass = &dwg->dwg_class[i];\n          if (!klass->dxfname)\n            {\n              invalid_klass++;\n              continue;\n            }\n          if (strEQ (obj->dxfname, klass->dxfname))\n            {\n              obj->type = 500 + i;\n              break;\n            }\n          else\n            {\n              // alias DICTIONARYWDFLT => ACDBDICTIONARYWDFLT\n              const char *alias = dxf_encode_alias (obj->dxfname);\n              if (alias && klass->dxfname && strEQ (alias, klass->dxfname))\n                {\n                  obj->dxfname = (char *)alias;\n                  obj->type = 500 + i;\n                  break;\n                }\n              klass = NULL; // inefficient\n\n              if (invalid_klass > 2 && !(dwg->opts & DWG_OPTS_INDXF))\n                goto search_by_index;\n            }\n        }\n    }\n  else // search by index\n    {\n    search_by_index:\n      i = obj->type - 500;\n      if (i < 0 || i >= (int)dwg->num_classes)\n        {\n          LOG_WARN (\"Invalid object type %d, only %u classes\", obj->type,\n                    dwg->num_classes);\n          return NULL;\n        }\n\n      klass = &dwg->dwg_class[i];\n      if (!klass || !klass->dxfname)\n        return NULL;\n      obj->dxfname = klass->dxfname;\n    }\n  return klass;\n}\n\n/** dwg_encode_variable_type\n * Encode object by class name, not type. if type > 500.\n * Returns 0 on success, else some Dwg_Error.\n */\nstatic int\ndwg_encode_variable_type (Dwg_Data *restrict dwg, Bit_Chain *restrict dat, Dwg_Object *restrict obj)\n{\n  int error = 0;\n  int is_entity;\n  unsigned long pos;\n  Dwg_Class *klass = dwg_encode_get_class (dwg, obj);\n\n  if (!klass)\n    return DWG_ERR_INTERNALERROR;\n  is_entity = dwg_class_is_entity (klass);\n\n  if (dwg->opts & DWG_OPTS_INDXF) // DXF import\n    {\n      pos = bit_position (dat);\n      dat->byte = obj->address;\n      dat->bit = 0;\n      LOG_TRACE (\"fixup Type: %d [BS] @%lu\\n\", obj->type, obj->address);\n      bit_write_BS (dat, obj->type); // fixup wrong type\n      bit_set_position (dat, pos);\n    }\n\n  // clang-format off\n  #include \"classes.inc\"\n  // clang-format on\n\n  LOG_WARN (\"Unknown Class %s %d %s (0x%x%s)\", is_entity ? \"entity\" : \"object\",\n            klass->number, klass->dxfname, klass->proxyflag,\n            klass->wasazombie ? \" was proxy\" : \"\")\n\n#undef WARN_UNHANDLED_CLASS\n#undef WARN_UNSTABLE_CLASS\n\n  return DWG_ERR_UNHANDLEDCLASS;\n}\n\nint\ndwg_encode_add_object (Dwg_Object *restrict obj, Bit_Chain *restrict dat,\n                       unsigned long address)\n{\n  int error = 0;\n  unsigned long oldpos;\n  unsigned long end_address = address + obj->size;\n\n  oldpos = bit_position (dat);\n  assert (address);\n  dat->byte = address;\n  dat->bit = 0;\n\n  LOG_INFO (\"Object number: %lu\", (unsigned long)obj->index);\n  if (obj->size > 0x100000)\n    {\n      LOG_ERROR (\"Object size %u overflow\", obj->size);\n      return DWG_ERR_VALUEOUTOFBOUNDS;\n    }\n  while (dat->byte + obj->size >= dat->size)\n    bit_chain_alloc (dat);\n\n  // TODO: calculate size from the fields. either <0x7fff or more\n  // patch it afterwards and check old<>new size if enough space allocated.\n  bit_write_MS (dat, obj->size);\n  obj->address = dat->byte;\n  PRE (R_2010) {\n    bit_write_BS (dat, obj->type);\n    LOG_INFO (\", Size: %d [MS], Type: %d [BS]\\n\", obj->size, obj->type)\n  }\n  LATER_VERSIONS\n  {\n    if (!obj->handlestream_size && obj->bitsize)\n      obj->handlestream_size = obj->size * 8 - obj->bitsize;\n    bit_write_UMC (dat, obj->handlestream_size);\n    obj->address = dat->byte;\n    bit_write_BOT (dat, obj->type);\n    LOG_INFO (\", Size: %d [MS], Hdlsize: %lu [UMC], Type: %d [BOT]\\n\",\n              obj->size, (unsigned long)obj->handlestream_size, obj->type)\n  }\n\n  /* Write the specific type to dat */\n  switch (obj->type)\n    {\n    case DWG_TYPE_TEXT:\n      error = dwg_encode_TEXT (dat, obj);\n      break;\n    case DWG_TYPE_ATTRIB:\n      error = dwg_encode_ATTRIB (dat, obj);\n      break;\n    case DWG_TYPE_ATTDEF:\n      error = dwg_encode_ATTDEF (dat, obj);\n      break;\n    case DWG_TYPE_BLOCK:\n      error = dwg_encode_BLOCK (dat, obj);\n      break;\n    case DWG_TYPE_ENDBLK:\n      error = dwg_encode_ENDBLK (dat, obj);\n      break;\n    case DWG_TYPE_SEQEND:\n      error = dwg_encode_SEQEND (dat, obj);\n      break;\n    case DWG_TYPE_INSERT:\n      error = dwg_encode_INSERT (dat, obj);\n      break;\n    case DWG_TYPE_MINSERT:\n      error = dwg_encode_MINSERT (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_2D:\n      error = dwg_encode_VERTEX_2D (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_3D:\n      error = dwg_encode_VERTEX_3D (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_MESH:\n      error = dwg_encode_VERTEX_MESH (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_PFACE:\n      error = dwg_encode_VERTEX_PFACE (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_PFACE_FACE:\n      error = dwg_encode_VERTEX_PFACE_FACE (dat, obj);\n      break;\n    case DWG_TYPE_POLYLINE_2D:\n      error = dwg_encode_POLYLINE_2D (dat, obj);\n      break;\n    case DWG_TYPE_POLYLINE_3D:\n      error = dwg_encode_POLYLINE_3D (dat, obj);\n      break;\n    case DWG_TYPE_ARC:\n      error = dwg_encode_ARC (dat, obj);\n      break;\n    case DWG_TYPE_CIRCLE:\n      error = dwg_encode_CIRCLE (dat, obj);\n      break;\n    case DWG_TYPE_LINE:\n      error = dwg_encode_LINE (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_ORDINATE:\n      error = dwg_encode_DIMENSION_ORDINATE (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_LINEAR:\n      error = dwg_encode_DIMENSION_LINEAR (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_ALIGNED:\n      error = dwg_encode_DIMENSION_ALIGNED (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_ANG3PT:\n      error = dwg_encode_DIMENSION_ANG3PT (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_ANG2LN:\n      error = dwg_encode_DIMENSION_ANG2LN (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_RADIUS:\n      error = dwg_encode_DIMENSION_RADIUS (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_DIAMETER:\n      error = dwg_encode_DIMENSION_DIAMETER (dat, obj);\n      break;\n    case DWG_TYPE_POINT:\n      error = dwg_encode_POINT (dat, obj);\n      break;\n    case DWG_TYPE__3DFACE:\n      error = dwg_encode__3DFACE (dat, obj);\n      break;\n    case DWG_TYPE_POLYLINE_PFACE:\n      error = dwg_encode_POLYLINE_PFACE (dat, obj);\n      break;\n    case DWG_TYPE_POLYLINE_MESH:\n      error = dwg_encode_POLYLINE_MESH (dat, obj);\n      break;\n    case DWG_TYPE_SOLID:\n      error = dwg_encode_SOLID (dat, obj);\n      break;\n    case DWG_TYPE_TRACE:\n      error = dwg_encode_TRACE (dat, obj);\n      break;\n    case DWG_TYPE_SHAPE:\n      error = dwg_encode_SHAPE (dat, obj);\n      break;\n    case DWG_TYPE_VIEWPORT:\n      error = dwg_encode_VIEWPORT (dat, obj);\n      break;\n    case DWG_TYPE_ELLIPSE:\n      error = dwg_encode_ELLIPSE (dat, obj);\n      break;\n    case DWG_TYPE_SPLINE:\n      error = dwg_encode_SPLINE (dat, obj);\n      break;\n    case DWG_TYPE_REGION:\n      error = dwg_encode_REGION (dat, obj);\n      break;\n    case DWG_TYPE__3DSOLID:\n      error = dwg_encode__3DSOLID (dat, obj);\n      break;\n    case DWG_TYPE_BODY:\n      error = dwg_encode_BODY (dat, obj);\n      break;\n    case DWG_TYPE_RAY:\n      error = dwg_encode_RAY (dat, obj);\n      break;\n    case DWG_TYPE_XLINE:\n      error = dwg_encode_XLINE (dat, obj);\n      break;\n    case DWG_TYPE_DICTIONARY:\n      error = dwg_encode_DICTIONARY (dat, obj);\n      break;\n    case DWG_TYPE_MTEXT:\n      error = dwg_encode_MTEXT (dat, obj);\n      break;\n    case DWG_TYPE_LEADER:\n      error = dwg_encode_LEADER (dat, obj);\n      break;\n    case DWG_TYPE_TOLERANCE:\n      error = dwg_encode_TOLERANCE (dat, obj);\n      break;\n    case DWG_TYPE_MLINE:\n      error = dwg_encode_MLINE (dat, obj);\n      break;\n    case DWG_TYPE_BLOCK_CONTROL:\n      error = dwg_encode_BLOCK_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_BLOCK_HEADER:\n      error = dwg_encode_BLOCK_HEADER (dat, obj);\n      break;\n    case DWG_TYPE_LAYER_CONTROL:\n      error = dwg_encode_LAYER_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_LAYER:\n      error = dwg_encode_LAYER (dat, obj);\n      break;\n    case DWG_TYPE_STYLE_CONTROL:\n      error = dwg_encode_STYLE_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_STYLE:\n      error = dwg_encode_STYLE (dat, obj);\n      break;\n    case DWG_TYPE_LTYPE_CONTROL:\n      error = dwg_encode_LTYPE_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_LTYPE:\n      error = dwg_encode_LTYPE (dat, obj);\n      break;\n    case DWG_TYPE_VIEW_CONTROL:\n      error = dwg_encode_VIEW_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_VIEW:\n      error = dwg_encode_VIEW (dat, obj);\n      break;\n    case DWG_TYPE_UCS_CONTROL:\n      error = dwg_encode_UCS_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_UCS:\n      error = dwg_encode_UCS (dat, obj);\n      break;\n    case DWG_TYPE_VPORT_CONTROL:\n      error = dwg_encode_VPORT_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_VPORT:\n      error = dwg_encode_VPORT (dat, obj);\n      break;\n    case DWG_TYPE_APPID_CONTROL:\n      error = dwg_encode_APPID_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_APPID:\n      error = dwg_encode_APPID (dat, obj);\n      break;\n    case DWG_TYPE_DIMSTYLE_CONTROL:\n      error = dwg_encode_DIMSTYLE_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_DIMSTYLE:\n      error = dwg_encode_DIMSTYLE (dat, obj);\n      break;\n    case DWG_TYPE_VPORT_ENTITY_CONTROL:\n      error = dwg_encode_VPORT_ENTITY_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_VPORT_ENTITY_HEADER:\n      error = dwg_encode_VPORT_ENTITY_HEADER (dat, obj);\n      break;\n    case DWG_TYPE_GROUP:\n      error = dwg_encode_GROUP (dat, obj);\n      break;\n    case DWG_TYPE_MLINESTYLE:\n      error = dwg_encode_MLINESTYLE (dat, obj);\n      (void)dwg_encode_get_class (obj->parent, obj);\n      break;\n    case DWG_TYPE_OLE2FRAME:\n      error = dwg_encode_OLE2FRAME (dat, obj);\n      (void)dwg_encode_get_class (obj->parent, obj);\n      break;\n    case DWG_TYPE_DUMMY:\n      error = dwg_encode_DUMMY (dat, obj);\n      break;\n    case DWG_TYPE_LONG_TRANSACTION:\n      error = dwg_encode_LONG_TRANSACTION (dat, obj);\n      break;\n    case DWG_TYPE_LWPOLYLINE:\n      error = dwg_encode_LWPOLYLINE (dat, obj);\n      (void)dwg_encode_get_class (obj->parent, obj);\n      break;\n    case DWG_TYPE_HATCH:\n      error = dwg_encode_HATCH (dat, obj);\n      (void)dwg_encode_get_class (obj->parent, obj);\n      break;\n    case DWG_TYPE_XRECORD:\n      error = dwg_encode_XRECORD (dat, obj);\n      (void)dwg_encode_get_class (obj->parent, obj);\n      break;\n    case DWG_TYPE_PLACEHOLDER:\n      error = dwg_encode_PLACEHOLDER (dat, obj);\n      (void)dwg_encode_get_class (obj->parent, obj);\n      break;\n    case DWG_TYPE_OLEFRAME:\n      error = dwg_encode_OLEFRAME (dat, obj);\n      (void)dwg_encode_get_class (obj->parent, obj);\n      break;\n    case DWG_TYPE_VBA_PROJECT:\n      LOG_ERROR (\"Unhandled Object VBA_PROJECT. Has its own section\");\n      // dwg_encode_VBA_PROJECT(dat, obj);\n      break;\n    case DWG_TYPE_LAYOUT:\n      error |= dwg_encode_LAYOUT (dat, obj);\n      (void)dwg_encode_get_class (obj->parent, obj);\n      break;\n    case DWG_TYPE_PROXY_ENTITY:\n      error = dwg_encode_PROXY_ENTITY (dat, obj);\n      break;\n    case DWG_TYPE_PROXY_OBJECT:\n      error = dwg_encode_PROXY_OBJECT (dat, obj);\n      break;\n    default:\n      if (obj->type == obj->parent->layout_type\n          && obj->fixedtype == DWG_TYPE_LAYOUT)\n        {\n          error = dwg_encode_LAYOUT (dat, obj);\n          (void)dwg_encode_get_class (obj->parent, obj);\n        }\n      else if ((error = dwg_encode_variable_type (obj->parent, dat, obj))\n               & DWG_ERR_UNHANDLEDCLASS)\n        {\n          Dwg_Data *dwg = obj->parent;\n          int is_entity;\n          int i = obj->type - 500;\n          Dwg_Class *klass = dwg_encode_get_class (dwg, obj);\n\n          assert (address);\n          dat->byte = address; // restart and write into the UNKNOWN_OBJ object\n          dat->bit = 0;\n          bit_write_MS (dat, obj->size); // unknown blobs have a known size\n          if (dat->version >= R_2010)\n            {\n              bit_write_UMC (dat, obj->handlestream_size);\n              bit_write_BOT (dat, obj->type);\n            }\n          else\n            bit_write_BS (dat, obj->type);\n\n          if (klass && obj->supertype == DWG_SUPERTYPE_UNKNOWN)\n            is_entity = dwg_class_is_entity (klass);\n          else\n            is_entity = obj->supertype == DWG_SUPERTYPE_ENTITY;\n          // properly dwg_decode_object/_entity for eed, reactors, xdic\n          if (is_entity)\n            error = dwg_encode_UNKNOWN_ENT (dat, obj);\n          else\n            error = dwg_encode_UNKNOWN_OBJ (dat, obj);\n        }\n    }\n\n  /* DXF: patchup size and bitsize */\n  if (!obj->size)\n    {\n      BITCODE_BL pos = bit_position (dat);\n      assert (address);\n      obj->size = dat->byte - address - 2; // excludes the CRC\n      if (dat->bit)\n        obj->size++;\n      //assert (obj->bitsize); // on errors\n      if (!obj->bitsize)\n        {\n          LOG_TRACE (\"-bitsize calc from address (no handle) @%lu.%u\\n\",\n                     dat->byte, dat->bit);\n          obj->bitsize = pos - (obj->address * 8);\n        }\n      bit_set_position (dat, address * 8);\n      if (obj->size > 0x7fff)\n        // TODO: with overlarge sizes >0x7fff memmove dat\n        LOG_ERROR (\"Unhandled size %u > 0x7fff\", (unsigned)obj->size);\n      bit_write_MS (dat, obj->size);\n      LOG_TRACE (\"-size: %u [MS] @%lu\\n\", obj->size, address);\n      SINCE (R_2013)\n      {\n        if (!obj->handlestream_size && obj->bitsize)\n          obj->handlestream_size = obj->size * 8 - obj->bitsize;\n        bit_write_UMC (dat, obj->handlestream_size);\n        LOG_TRACE (\"-handlestream_size: %lu [UMC]\\n\", obj->handlestream_size);\n      }\n      SINCE (R_2000)\n      {\n        if (obj->bitsize_pos && obj->bitsize)\n          {\n            bit_set_position (dat, obj->bitsize_pos);\n            bit_write_RL (dat, obj->bitsize);\n            LOG_TRACE (\"-bitsize: %u [RL] @%lu.%lu\\n\", obj->bitsize,\n                       obj->bitsize_pos / 8, obj->bitsize_pos % 8);\n          }\n      }\n      bit_set_position (dat, pos);\n    }\n\n  /*\n   if (obj->supertype != DWG_SUPERTYPE_UNKNOWN)\n   {\n     fprintf (stderr, \"Begin address:\\t%10lu\\n\", address);\n     fprintf (stderr, \"Last address:\\t%10lu\\tSize: %10lu\\n\", dat->byte,\n   obj->size); fprintf (stderr, \"End address:\\t%10lu (calculated)\\n\", address +\n   2 + obj->size);\n   }\n   */\n\n  /* Now 1 padding bits until next byte, and then a RS CRC */\n  if (dat->bit)\n    LOG_TRACE (\"padding: +%d [*B]\\n\", 8 - dat->bit)\n  while (dat->bit)\n    bit_write_B (dat, 1);\n  end_address = obj->address + obj->size;\n  if (end_address != dat->byte)\n    {\n      if (obj->size)\n        LOG_WARN (\"Wrong object size: %lu + %u = %lu != %lu: %ld off\", obj->address,\n                  obj->size, end_address, dat->byte, (long)(end_address - dat->byte));\n      dat->byte = end_address;\n    }\n  assert (!dat->bit);\n  bit_write_CRC (dat, address, 0xC0C1);\n  return error;\n}\n\n/** writes the data part, if there's no raw.\n */\nstatic int\ndwg_encode_eed_data (Bit_Chain *restrict dat, Dwg_Eed_Data *restrict data,\n                     const int size, const int i)\n{\n  bit_write_RC (dat, data->code);\n  LOG_TRACE (\"EED[%d] code: %d [RC] \", i, data->code);\n  switch (data->code)\n    {\n    case 0:\n      {\n        PRE (R_2007)\n        {\n          if (data->u.eed_0.length + 3 <= size)\n            {\n              if (!data->u.eed_0.string)\n                data->u.eed_0.length = 0;\n              bit_write_RC (dat, data->u.eed_0.length);\n              bit_write_RS_LE (dat, data->u.eed_0.codepage);\n              if (data->u.eed_0.string)\n                bit_write_TF (dat, data->u.eed_0.string, data->u.eed_0.length);\n              else\n                bit_write_TF (dat, (char*)\"\", 0);\n            }\n          LOG_TRACE (\"string: len=%d [RC] cp=%d [RS_LE] \\\"%s\\\" [TF]\\n\",\n                     data->u.eed_0.length, data->u.eed_0.codepage, data->u.eed_0.string);\n        }\n        LATER_VERSIONS\n        {\n          BITCODE_RS *s = (BITCODE_RS *)&data->u.eed_0_r2007.string;\n          if (data->u.eed_0_r2007.string && data->u.eed_0.length * 2 + 2 <= size)\n            {\n              bit_write_RS (dat, data->u.eed_0_r2007.length);\n              for (int j = 0; j < data->u.eed_0_r2007.length; j++)\n                bit_write_RS (dat, *s++);\n            }\n          else\n            bit_write_RS (dat, 0);\n#ifdef _WIN32\n          LOG_TRACE (\"wstring: len=%d [RS] \\\"\" FORMAT_TU \"\\\" [TU]\\n\",\n                     (int)data->u.eed_0_r2007.length, data->u.eed_0_r2007.string);\n#else\n          if (DWG_LOGLEVEL >= DWG_LOGLEVEL_TRACE)\n            {\n              char *u8 = bit_convert_TU (data->u.eed_0_r2007.string);\n              LOG_TRACE (\"wstring: len=%d [RS] \\\"%s\\\" [TU]\\n\",\n                         (int)data->u.eed_0_r2007.length, u8);\n              free (u8);\n            }\n#endif\n        }\n      }\n      break;\n    case 2:\n      if (1 <= size)\n        bit_write_RC (dat, data->u.eed_2.byte);\n      LOG_TRACE (\"byte: %d [RC]\\n\", (int)data->u.eed_2.byte);\n      break;\n    case 3:\n      if (4 <= size)\n        bit_write_RL (dat, data->u.eed_3.layer);\n      LOG_TRACE (\"layer: %d [RL]\\n\", (int)data->u.eed_3.layer);\n      break;\n    case 4:\n      if (data->u.eed_0.length + 1 <= size)\n        {\n          bit_write_RC (dat, data->u.eed_4.length);\n          bit_write_TF (dat, data->u.eed_4.data, data->u.eed_4.length);\n        }\n      LOG_TRACE (\"binary: \\\"%s\\\" [TF %d]\\n\", data->u.eed_4.data,\n                 data->u.eed_4.length);\n      break;\n    case 5:\n      if (8 <= size)\n        bit_write_RLL (dat, data->u.eed_5.entity);\n      LOG_TRACE (\"entity: 0x\\\"%lX\\\" [RLL]\\n\", (unsigned long)data->u.eed_5.entity);\n      break;\n    case 10:\n    case 11:\n    case 12:\n    case 13:\n    case 14:\n    case 15:\n      if (24 <= size)\n        {\n          bit_write_RD (dat, data->u.eed_10.point.x);\n          bit_write_RD (dat, data->u.eed_10.point.y);\n          bit_write_RD (dat, data->u.eed_10.point.z);\n        }\n      LOG_TRACE (\"3dpoint: (%f, %f, %f) [3RD]\\n\", data->u.eed_10.point.x,\n                 data->u.eed_10.point.y, data->u.eed_10.point.z);\n      break;\n    case 40:\n    case 41:\n    case 42:\n      if (8 <= size)\n        bit_write_RD (dat, data->u.eed_40.real);\n      LOG_TRACE (\"real: %f [RD]\\n\", data->u.eed_40.real);\n      break;\n    case 70:\n      if (2 <= size)\n        bit_write_RS (dat, data->u.eed_70.rs);\n      LOG_TRACE (\"short: \" FORMAT_RS \" [RS]\\n\", data->u.eed_70.rs);\n      break;\n    case 71:\n      if (4 <= size)\n        bit_write_RL (dat, data->u.eed_71.rl);\n      LOG_TRACE (\"long: \" FORMAT_RL \" [RL]\\n\", data->u.eed_71.rl);\n      break;\n    default:\n      LOG_ERROR (\"unknown EED code %d\", data->code);\n    }\n  return 0;\n}\n\n/** Either writes the raw part.\n    Only members with size have raw and a handle.\n    Otherwise (indxf) defer to dwg_encode_eed_data.\n */\nstatic int\ndwg_encode_eed (Bit_Chain *restrict dat, Dwg_Object *restrict obj)\n{\n  unsigned long off = obj->address;\n\n#define LOG_POS\n  // LOG_INSANE (\" @%lu.%u\\n\", dat->byte - off, dat->bit)\n\n  int i, num_eed = obj->tio.object->num_eed;\n  for (i = 0; i < num_eed; i++)\n    {\n      Dwg_Eed *eed = &obj->tio.object->eed[i];\n      BITCODE_BS size = eed->size;\n      if (size)\n        {\n          bit_write_BS (dat, size);\n          LOG_TRACE (\"EED[%d] size: \" FORMAT_BS \" [BS]\\n\", i, size);\n          LOG_POS\n          bit_write_H (dat, &eed->handle);\n          LOG_TRACE (\"EED[%d] handle: \" FORMAT_H \" [H]\\n\", i,\n                     ARGS_H (eed->handle));\n          LOG_POS\n          if (eed->raw)\n            {\n              LOG_TRACE (\"EED[%d] raw [TF %d]\\n\", i, size);\n              bit_write_TF (dat, eed->raw, size);\n            }\n        }\n      if (!eed->raw && eed->data) // indxf\n        {\n          dwg_encode_eed_data (dat, eed->data, size, i);\n          LOG_POS\n        }\n    }\n  bit_write_BS (dat, 0);\n  if (i)\n    LOG_TRACE (\"EED[%d] size: 0 [BS] (end)\\n\", i);\n  LOG_POS\n#undef LOG_POS\n    return 0;\n}\n\n/* The first common part of every entity.\n\n   The last common part is common_entity_handle_data.spec\n   which is read from the hdl stream.\n   See DWG_SUPERTYPE_ENTITY in dwg_encode().\n */\nstatic int\ndwg_encode_entity (Dwg_Object *restrict obj, Bit_Chain *hdl_dat, Bit_Chain *str_dat,\n                   Bit_Chain *dat)\n{\n  int error = 0;\n  Dwg_Object_Entity *ent = obj->tio.entity;\n  Dwg_Object_Entity *_obj = ent;\n  Dwg_Data *dwg = ent->dwg;\n\n  if (!obj || !dat)\n    return DWG_ERR_INVALIDDWG;\n  PRE (R_13)\n  {\n\n    if (FIELD_VALUE (flag_r11) & 4 && FIELD_VALUE (kind_r11) > 2\n        && FIELD_VALUE (kind_r11) != 22)\n      FIELD_RD (elevation_r11, 30);\n    if (FIELD_VALUE (flag_r11) & 8)\n      FIELD_RD (thickness_r11, 39);\n    if (FIELD_VALUE (flag_r11) & 0x20)\n      {\n        Dwg_Object_Ref *hdl\n            = dwg_decode_handleref_with_code (dat, obj, dwg, 0);\n        if (hdl)\n          obj->handle = hdl->handleref;\n      }\n    if (FIELD_VALUE (extra_r11) & 4)\n      FIELD_RS (paper_r11, 0);\n  }\n\n  SINCE (R_2007) { *str_dat = *dat; }\n  VERSIONS (R_2000, R_2007)\n  {\n    obj->bitsize_pos = bit_position (dat);\n    bit_write_RL (dat, obj->bitsize);\n    LOG_TRACE (\"bitsize: %u [RL] (@%lu.%lu)\\n\", obj->bitsize,\n               obj->bitsize_pos / 8, obj->bitsize_pos % 8);\n  }\n  if (obj->bitsize)\n    obj->hdlpos = obj->address * 8 + obj->bitsize;\n  SINCE (R_2007)\n  {\n    // The handle stream offset, i.e. end of the object, right after\n    // the has_strings bit.\n    SINCE (R_2010)\n    {\n      if (obj->bitsize)\n        {\n          obj->hdlpos += 8;\n          // LOG_HANDLE (\"(bitsize: \" FORMAT_RL \", \", obj->bitsize);\n          LOG_HANDLE (\"hdlpos: %lu\\n\", obj->hdlpos);\n        }\n    }\n    // and set the string stream (restricted to size)\n    error |= obj_string_stream (dat, obj, str_dat);\n  }\n\n  bit_write_H (dat, &obj->handle);\n  LOG_TRACE (\"handle: \" FORMAT_H \" [H 5]\\n\", ARGS_H (obj->handle))\n  PRE (R_13) { return DWG_ERR_NOTYETSUPPORTED; }\n\n  error |= dwg_encode_eed (dat, obj);\n  // if (error & (DWG_ERR_INVALIDTYPE|DWG_ERR_VALUEOUTOFBOUNDS))\n  //  return error;\n\n  // clang-format off\n  #include \"common_entity_data.spec\"\n  // clang-format on\n\n  return error;\n}\n\nstatic int\ndwg_encode_common_entity_handle_data (Bit_Chain *dat, Bit_Chain *hdl_dat,\n                                      Dwg_Object *restrict obj)\n{\n  Dwg_Object_Entity *ent;\n  // Dwg_Data *dwg = obj->parent;\n  Dwg_Object_Entity *_obj;\n  BITCODE_BL vcount;\n  int error = 0;\n  ent = obj->tio.entity;\n  _obj = ent;\n\n  // clang-format off\n  #include \"common_entity_handle_data.spec\"\n  // clang-format on\n\n  return error;\n}\n\nvoid\ndwg_encode_handleref (Bit_Chain *hdl_dat, Dwg_Object *restrict obj, Dwg_Data *restrict dwg,\n                      Dwg_Object_Ref *restrict ref)\n{\n  // this function should receive a Object_Ref without an abs_ref, calculate it\n  // and return a Dwg_Handle this should be a higher level function not sure if\n  // the prototype is correct\n  assert (obj);\n}\n\n/**\n * code:\n *  TYPEDOBJHANDLE:\n *   2 Soft owner\n *   3 Hard owner\n *   4 Soft pointer\n *   5 Hard pointer\n *  OFFSETOBJHANDLE for soft owners or pointers:\n *   6 ref + 1\n *   8 ref - 1\n *   a ref + offset\n *   c ref - offset\n */\nvoid\ndwg_encode_handleref_with_code (Bit_Chain *hdl_dat, Dwg_Object *restrict obj,\n                                Dwg_Data *restrict dwg, Dwg_Object_Ref *restrict ref,\n                                unsigned int code)\n{\n  // XXX fixme. create the handle, then check the code. allow relative handle\n  // soft codes.\n  dwg_encode_handleref (hdl_dat, obj, dwg, ref);\n  if (ref->absolute_ref == 0 && ref->handleref.code != code)\n    {\n      /*\n       * With TYPEDOBJHANDLE 2-5 the code indicates the type of ownership.\n       * With OFFSETOBJHANDLE >5 the handle is stored as an offset from some\n       * other handle.\n       */\n      switch (ref->handleref.code)\n        {\n        case 0x06:\n          ref->absolute_ref = (obj->handle.value + 1);\n          break;\n        case 0x08:\n          ref->absolute_ref = (obj->handle.value - 1);\n          break;\n        case 0x0A:\n          ref->absolute_ref = (obj->handle.value + ref->handleref.value);\n          break;\n        case 0x0C:\n          ref->absolute_ref = (obj->handle.value - ref->handleref.value);\n          break;\n        case 2:\n        case 3:\n        case 4:\n        case 5:\n          ref->absolute_ref = ref->handleref.value;\n          break;\n        case 0: // ignore (ANYCODE)\n          ref->absolute_ref = ref->handleref.value;\n          break;\n        default:\n          LOG_WARN (\"Invalid handle pointer code %d\", ref->handleref.code);\n          break;\n        }\n    }\n}\n\n/* The first common part of every object.\n\n   There is no COMMON_ENTITY_HANDLE_DATA for objects.\n   See DWG_SUPERTYPE_OBJECT in dwg_encode().\n*/\nstatic int\ndwg_encode_object (Dwg_Object *restrict obj, Bit_Chain *hdl_dat, Bit_Chain *str_dat,\n                   Bit_Chain *dat)\n{\n  int error = 0;\n  Dwg_Object_Object *ord = obj->tio.object;\n\n  VERSIONS (R_2000, R_2007)\n  {\n    obj->bitsize_pos = bit_position (dat);\n    bit_write_RL (dat, obj->bitsize);\n    LOG_INFO (\"bitsize: \" FORMAT_RL \" [RL] (@%lu.%u)\\n\", obj->bitsize,\n              dat->byte - 4, dat->bit);\n  }\n  if (obj->bitsize)\n    obj->hdlpos = bit_position (dat) + obj->bitsize; // the handle stream offset\n  SINCE (R_2007) { obj_string_stream (dat, obj, str_dat); }\n\n  bit_write_H (dat, &obj->handle);\n  LOG_TRACE (\"handle: \" FORMAT_H \" [H 5]\\n\", ARGS_H (obj->handle));\n  error |= dwg_encode_eed (dat, obj);\n\n  VERSIONS (R_13, R_14)\n  {\n    obj->bitsize_pos = bit_position (dat);\n    bit_write_RL (dat, obj->bitsize);\n    LOG_INFO (\"bitsize: \" FORMAT_RL \" [RL] (@%lu.%u)\\n\", obj->bitsize,\n              dat->byte - 4, dat->bit);\n  }\n\n  bit_write_BL (dat, ord->num_reactors);\n  LOG_TRACE (\"num_reactors: \" FORMAT_BL \" [BL]\\n\", ord->num_reactors);\n  SINCE (R_2004)\n  {\n    bit_write_B (dat, ord->xdic_missing_flag);\n    LOG_TRACE (\"xdic_missing_flag: \" FORMAT_B \" [B]\\n\",\n               ord->xdic_missing_flag);\n  }\n  SINCE (R_2013)\n  {\n    bit_write_B (dat, ord->has_ds_binary_data);\n    LOG_TRACE (\"has_ds_binary_data: \" FORMAT_B \" [B]\\n\",\n               ord->has_ds_binary_data);\n  }\n  return error;\n}\n\nstatic int\ndwg_encode_header_variables (Bit_Chain *dat, Bit_Chain *hdl_dat,\n                             Bit_Chain *str_dat, Dwg_Data *restrict dwg)\n{\n  Dwg_Header_Variables *_obj = &dwg->header_vars;\n  Dwg_Object *obj = NULL;\n  int old_from = (int)dat->from_version;\n\n  if (!_obj->HANDSEED) // minimal or broken DXF\n    {\n      dwg->opts |= DWG_OPTS_MINIMAL;\n      dat->from_version = dat->version - 1;\n      LOG_TRACE (\"encode from minimal DXF\\n\");\n      _obj->HANDSEED = calloc(1, sizeof(Dwg_Object_Ref));\n      _obj->HANDSEED->absolute_ref = 0x72E;\n    }\n\n  // clang-format off\n  #include \"header_variables.spec\"\n  // clang-format on\n\n  dat->from_version = old_from;\n  return 0;\n}\n\nstatic int\ndwg_encode_xdata (Bit_Chain *restrict dat, Dwg_Object_XRECORD *restrict obj, int size)\n{\n  Dwg_Resbuf *rbuf = obj->xdata;\n  enum RES_BUF_VALUE_TYPE type;\n  int i, j = 0;\n\n  while (rbuf)\n    {\n      bit_write_RS (dat, rbuf->type);\n      type = get_base_value_type (rbuf->type);\n      switch (type)\n        {\n        case VT_STRING:\n          UNTIL (R_2007)\n          {\n            bit_write_RS (dat, rbuf->value.str.size);\n            bit_write_RC (dat, rbuf->value.str.codepage);\n            if (rbuf->value.str.u.data)\n              bit_write_TF (dat, rbuf->value.str.u.data, rbuf->value.str.size);\n            else\n              bit_write_TF (dat, (char*)\"\", 0);\n            LOG_TRACE (\"xdata[%d]: \\\"%s\\\" [TF %d %d]\\n\", j,\n                       rbuf->value.str.u.data, rbuf->value.str.size,\n                       rbuf->type);\n          }\n          LATER_VERSIONS\n          {\n            bit_write_RS (dat, rbuf->value.str.size);\n            for (i = 0; i < rbuf->value.str.size; i++)\n              bit_write_RS (dat, rbuf->value.str.u.wdata[i]);\n          }\n          break;\n        case VT_REAL:\n          bit_write_RD (dat, rbuf->value.dbl);\n          LOG_TRACE (\"xdata[%d]: %f [RD %d]\\n\", j, rbuf->value.dbl,\n                     rbuf->type);\n          break;\n        case VT_BOOL:\n        case VT_INT8:\n          bit_write_RC (dat, rbuf->value.i8);\n          LOG_TRACE (\"xdata[%d]: %d [RC %d]\\n\", j, (int)rbuf->value.i8,\n                     rbuf->type);\n          break;\n        case VT_INT16:\n          bit_write_RS (dat, rbuf->value.i16);\n          LOG_TRACE (\"xdata[%d]: %d [RS %d]\\n\", j, (int)rbuf->value.i16,\n                     rbuf->type);\n          break;\n        case VT_INT32:\n          bit_write_RL (dat, rbuf->value.i32);\n          LOG_TRACE (\"xdata[%d]: %ld [RL %d]\\n\", j, (long)rbuf->value.i32,\n                     rbuf->type);\n          break;\n        case VT_INT64:\n          bit_write_BLL (dat, rbuf->value.i64);\n          LOG_TRACE (\"xdata[%d]: \" FORMAT_BLL \" [BLL %d]\\n\", j,\n                     rbuf->value.i64, rbuf->type);\n          break;\n        case VT_POINT3D:\n          bit_write_RD (dat, rbuf->value.pt[0]);\n          bit_write_RD (dat, rbuf->value.pt[1]);\n          bit_write_RD (dat, rbuf->value.pt[2]);\n          LOG_TRACE (\"xdata[%d]: (%f,%f,%f) [3RD %d]\\n\", j, rbuf->value.pt[0],\n                     rbuf->value.pt[1], rbuf->value.pt[2], rbuf->type);\n          break;\n        case VT_BINARY:\n          bit_write_RC (dat, rbuf->value.str.size);\n          bit_write_TF (dat, rbuf->value.str.u.data, rbuf->value.str.size);\n          LOG_TRACE (\"xdata[%d]: [TF %d %d] \", j, rbuf->value.str.size,\n                     rbuf->type);\n          LOG_TRACE_TF (rbuf->value.str.u.data, rbuf->value.str.size);\n          break;\n        case VT_HANDLE:\n        case VT_OBJECTID:\n          for (i = 0; i < 8; i++)\n            bit_write_RC (dat, rbuf->value.hdl[i]);\n          LOG_TRACE (\"xdata[%d]: \" FORMAT_H \" [H %d]\\n\", j,\n                     ARGS_H (rbuf->value.h), rbuf->type);\n          break;\n        case VT_INVALID:\n        default:\n          LOG_ERROR (\"Invalid group code in xdata: %d\", rbuf->type)\n          return DWG_ERR_INVALIDEED;\n        }\n      rbuf = rbuf->next;\n      j++;\n    }\n  return 0;\n}\n\nchar *encrypt_sat1 (BITCODE_BL blocksize, BITCODE_RC *acis_data, int *idx)\n{\n  char *encr_sat_data = calloc (blocksize, 1);\n  int i = *idx;\n  int j;\n  for (j = 0; j < (int)blocksize; j++)\n    {\n      if (acis_data[j] <= 32)\n        encr_sat_data[i++] = acis_data[j];\n      else\n        encr_sat_data[i++] = acis_data[j] - 159;\n      /* TODO reversion of:\n      if (encr_sat_data[j] <= 32)\n        acis_data[i++] = encr_sat_data[j];\n      else\n        acis_data[i++] = 159 - encr_sat_data[j];\n      */\n    }\n  *idx = i;\n  return encr_sat_data;\n}\n\n#undef IS_ENCODER\n", "/*****************************************************************************/\n/*  LibreDWG - free implementation of the DWG file format                    */\n/*                                                                           */\n/*  Copyright (C) 2018-2019 Free Software Foundation, Inc.                   */\n/*                                                                           */\n/*  This library is free software, licensed under the terms of the GNU       */\n/*  General Public License as published by the Free Software Foundation,     */\n/*  either version 3 of the License, or (at your option) any later version.  */\n/*  You should have received a copy of the GNU General Public License        */\n/*  along with this program.  If not, see <http://www.gnu.org/licenses/>.    */\n/*****************************************************************************/\n\n/*\n * free.c: helper functions to free all spec fields\n * written by Reini Urban\n * modified by Denis Pruchkovsky\n */\n\n#include \"config.h\"\n#ifdef __STDC_ALLOC_LIB__\n#  define __STDC_WANT_LIB_EXT2__ 1 /* for strdup */\n#else\n#  define _USE_BSD 1\n#endif\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\n#include \"common.h\"\n#include \"bits.h\"\n#include \"dwg.h\"\n#include \"decode.h\"\n#include \"free.h\"\n#include \"hash.h\"\n\nstatic unsigned int loglevel;\n#ifdef USE_TRACING\nstatic int env_var_checked_p;\n#endif\n#define DWG_LOGLEVEL loglevel\n#include \"logging.h\"\n\n/* the current version per spec block */\nstatic unsigned int cur_ver = 0;\nstatic Bit_Chain pdat = { NULL, 0, 0, 0, 0, 0 };\n\n/*--------------------------------------------------------------------------------\n * MACROS\n */\n\n#define ACTION free\n#define IS_FREE\n\n#define FREE_IF(ptr)                                                          \\\n  {                                                                           \\\n    if (ptr)                                                                  \\\n      free (ptr);                                                             \\\n    ptr = NULL;                                                               \\\n  }\n\n#define VALUE(value, type, dxf)\n#define VALUE_RC(value, dxf) VALUE (value, RC, dxf)\n#define VALUE_RS(value, dxf) VALUE (value, RS, dxf)\n#define VALUE_RL(value, dxf) VALUE (value, RL, dxf)\n#define VALUE_RD(value, dxf) VALUE (value, RD, dxf)\n\n#define FIELD(name, type)                                                     \\\n  {                                                                           \\\n  }\n#define FIELD_TRACE(name, type)                                               \\\n  LOG_TRACE (#name \": \" FORMAT_##type \"\\n\", _obj->name)\n#define FIELD_G_TRACE(name, type, dxfgroup)                                   \\\n  LOG_TRACE (#name \": \" FORMAT_##type \" [\" #type \" %d]\\n\", _obj->name,        \\\n             dxfgroup)\n#define FIELD_CAST(name, type, cast, dxf)                                     \\\n  {                                                                           \\\n  }\n#define FIELD_VALUE(name) _obj->name\n#define SUB_FIELD(o, nam, type, dxf) FIELD (_obj->o.nam, type)\n\n#define ANYCODE -1\n#define FIELD_HANDLE(nam, code, dxf) VALUE_HANDLE (_obj->nam, nam, code, dxf)\n#define SUB_FIELD_HANDLE(o, nam, code, dxf)                                   \\\n  VALUE_HANDLE (_obj->o.nam, nam, code, dxf)\n// compare to dwg_decode_handleref_with_code: not all refs are stored in the\n// object_ref vector, like relative ptrs and NULL.\n// But indxf skip the NULL HDL, it is global and shared there.\n// obj is the relative base object here and there.\n#define VALUE_HANDLE(ref, nam, _code, dxf)                                    \\\n  if (ref                                                                     \\\n      && !(dat->opts & DWG_OPTS_INDXF && ref->handleref.size == 0             \\\n           && ref->absolute_ref == 0 && !ref->obj)                            \\\n      && !(ref->handleref.size || (obj && ref->handleref.code > 5)))          \\\n    {                                                                         \\\n      free (ref);                                                             \\\n      ref = NULL;                                                             \\\n    } /* else freed globally */\n#define FIELD_DATAHANDLE(name, code, dxf) FIELD_HANDLE (name, code, dxf)\n#define FIELD_HANDLE_N(name, vcount, code, dxf) FIELD_HANDLE (name, code, dxf)\n\n#define FIELD_B(name, dxf) FIELD (name, B)\n#define FIELD_BB(name, dxf) FIELD (name, BB)\n#define FIELD_3B(name, dxf) FIELD (name, 3B)\n#define FIELD_BS(name, dxf) FIELD (name, BS)\n#define FIELD_BL(name, dxf) FIELD (name, BL)\n#define FIELD_BLL(name, dxf) FIELD (name, BLL)\n#define FIELD_BD(name, dxf) FIELD (name, BD)\n#define FIELD_RC(name, dxf) FIELD (name, RC)\n#define FIELD_RS(name, dxf) FIELD (name, RS)\n#define FIELD_RD(name, dxf) FIELD (name, RD)\n#define FIELD_RL(name, dxf) FIELD (name, RL)\n#define FIELD_RLL(name, dxf) FIELD (name, RLL)\n#define FIELD_MC(name, dxf) FIELD (name, MC)\n#define FIELD_MS(name, dxf) FIELD (name, MS)\n#define FIELD_TV(name, dxf) FREE_IF (FIELD_VALUE (name))\n#define VALUE_TV(value, dxf) FREE_IF (value)\n#define VALUE_TF(value, dxf) FREE_IF (value)\n#define VALUE_TFF(value, dxf)\n#define FIELD_TU(name, dxf) FIELD_TV (name, dxf)\n#define FIELD_TF(name, len, dxf) FIELD_TV (name, dxf)\n#define FIELD_TFF(name, len, dxf)                                             \\\n  {                                                                           \\\n  }\n#define FIELD_T(name, dxf) FIELD_TV (name, dxf)\n#define FIELD_BINARY(name, len, dxf) FIELD_TV (name, dxf)\n#define FIELD_BT(name, dxf) FIELD (name, BT);\n#define FIELD_4BITS(name, dxf)                                                \\\n  {                                                                           \\\n  }\n#define FIELD_BE(name, dxf)                                                   \\\n  {                                                                           \\\n  }\n#define FIELD_DD(name, _default, dxf)                                         \\\n  {                                                                           \\\n  }\n#define FIELD_2DD(name, d1, d2, dxf)                                          \\\n  {                                                                           \\\n  }\n#define FIELD_3DD(name, def, dxf)                                             \\\n  {                                                                           \\\n  }\n#define FIELD_2RD(name, dxf)                                                  \\\n  {                                                                           \\\n  }\n#define FIELD_2BD(name, dxf)                                                  \\\n  {                                                                           \\\n  }\n#define FIELD_2BD_1(name, dxf)                                                \\\n  {                                                                           \\\n  }\n#define FIELD_3RD(name, dxf)                                                  \\\n  {                                                                           \\\n  }\n#define FIELD_3BD(name, dxf)                                                  \\\n  {                                                                           \\\n  }\n#define FIELD_3BD_1(name, dxf)                                                \\\n  {                                                                           \\\n  }\n#define FIELD_3DPOINT(name, dxf)                                              \\\n  {                                                                           \\\n  }\n#define FIELD_TIMEBLL(name, dxf)\n#define FIELD_TIMERLL(name, dxf)\n// indxf does not assign names yet\n#define FIELD_CMC(color, dxf1, dxf2)                                          \\\n  if (!(dat->opts & DWG_OPTS_INDXF)) {                                        \\\n    FIELD_T (color.name, 0);                                                  \\\n    FIELD_T (color.book_name, 0);                                             \\\n  }\n#define SUB_FIELD_CMC(o, color, dxf1, dxf2)                                   \\\n  if (!(dat->opts & DWG_OPTS_INDXF)) {                                        \\\n    VALUE_TV (_obj->o.color.name, 0);                                         \\\n    VALUE_TV (_obj->o.color.book_name, 0);                                    \\\n  }\n\n// FIELD_VECTOR_N(name, type, size):\n// reads data of the type indicated by 'type' 'size' times and stores\n// it all in the vector called 'name'.\n#define FIELD_VECTOR_N(nam, type, size, dxf)                                  \\\n  if ((size) && _obj->nam)                                                    \\\n    {                                                                         \\\n      for (vcount = 0; vcount < (BITCODE_BL) (size); vcount++)                \\\n        FIELD_##type (nam[vcount], dxf);                                      \\\n    }                                                                         \\\n  FIELD_TV (nam, dxf);\n#define FIELD_VECTOR_T(name, size, dxf)                                       \\\n  FIELD_VECTOR_N (name, TV, _obj->size, dxf)\n#define FIELD_VECTOR(name, type, size, dxf)                                   \\\n  FIELD_VECTOR_N (name, type, _obj->size, dxf)\n#define FIELD_2RD_VECTOR(name, size, dxf) FIELD_TV (name, dxf)\n#define FIELD_2DD_VECTOR(name, size, dxf) FIELD_TV (name, dxf)\n#define FIELD_3DPOINT_VECTOR(name, size, dxf) FIELD_TV (name, dxf)\n#define HANDLE_VECTOR_N(name, size, code, dxf)                                \\\n  if (_obj->name)                                                             \\\n    {                                                                         \\\n      for (vcount = 0; vcount < (BITCODE_BL)size; vcount++)                   \\\n        {                                                                     \\\n          FIELD_HANDLE_N (name[vcount], vcount, code, dxf);                   \\\n        }                                                                     \\\n      if (size)                                                               \\\n        {                                                                     \\\n          FIELD_TV (name, dxf)                                                \\\n        }                                                                     \\\n    }\n#define HANDLE_VECTOR(name, sizefield, code, dxf)                             \\\n  HANDLE_VECTOR_N (name, FIELD_VALUE (sizefield), code, dxf)\n\n#define FIELD_NUM_INSERTS(num_inserts, type, dxf)\n#define FIELD_XDATA(name, size) dwg_free_xdata (_obj, _obj->size)\n\n#define REACTORS(code)                                                        \\\n  if (obj->tio.object->reactors)                                              \\\n    {                                                                         \\\n      for (vcount = 0; vcount < obj->tio.object->num_reactors; vcount++)      \\\n        VALUE_HANDLE (obj->tio.object->reactors[vcount], reactors, code,      \\\n                      330);                                                   \\\n      VALUE_TV (obj->tio.object->reactors, 0);                                \\\n    }\n#define ENT_REACTORS(code)                                                    \\\n  if (ent->reactors)                                                          \\\n    {                                                                         \\\n      for (vcount = 0; vcount < ent->num_reactors; vcount++)                  \\\n        VALUE_HANDLE (ent->reactors[vcount], reactors, code, 330);            \\\n      VALUE_TV (ent->reactors, 0);                                            \\\n    }\n#define XDICOBJHANDLE(code)                                                   \\\n  SINCE (R_2004)                                                              \\\n  {                                                                           \\\n    if (!obj->tio.object->xdic_missing_flag)                                  \\\n      {                                                                       \\\n        VALUE_HANDLE (obj->tio.object->xdicobjhandle, xdicobjhandle, code,    \\\n                      0);                                                     \\\n      }                                                                       \\\n  }                                                                           \\\n  PRIOR_VERSIONS                                                              \\\n  {                                                                           \\\n    VALUE_HANDLE (obj->tio.object->xdicobjhandle, xdicobjhandle, code, 0);    \\\n  }\n#define ENT_XDICOBJHANDLE(code)                                               \\\n  SINCE (R_2004)                                                              \\\n  {                                                                           \\\n    if (!ent->xdic_missing_flag)                                              \\\n      {                                                                       \\\n        VALUE_HANDLE (ent->xdicobjhandle, xdicobjhandle, code, 0);            \\\n      }                                                                       \\\n  }                                                                           \\\n  PRIOR_VERSIONS { VALUE_HANDLE (ent->xdicobjhandle, xdicobjhandle, code, 0); }\n\n#define END_REPEAT(field) FIELD_TV (field, 0)\n\n#define COMMON_ENTITY_HANDLE_DATA\n#define SECTION_STRING_STREAM\n#define START_STRING_STREAM\n#define END_STRING_STREAM\n#define START_HANDLE_STREAM\n\nstatic int dwg_free_UNKNOWN_ENT (Bit_Chain *restrict dat,\n                                 Dwg_Object *restrict obj);\nstatic int dwg_free_UNKNOWN_OBJ (Bit_Chain *restrict dat,\n                                 Dwg_Object *restrict obj);\n\n#define DWG_ENTITY(token)                                                     \\\n  static int dwg_free_##token##_private (Bit_Chain *restrict dat,             \\\n                                         Dwg_Object *restrict obj);           \\\n                                                                              \\\n  static int dwg_free_##token (Bit_Chain *restrict dat,                       \\\n                               Dwg_Object *restrict obj)                      \\\n  {                                                                           \\\n    int error = 0;                                                            \\\n    if (obj->tio.entity)                                                      \\\n      {                                                                       \\\n        LOG_HANDLE (\"Free entity \" #token \" [%d]\\n\", obj->index)              \\\n        if (obj->tio.entity->tio.token)                                       \\\n          error = dwg_free_##token##_private (dat, obj);                      \\\n                                                                              \\\n        dwg_free_common_entity_data (obj);                                    \\\n        dwg_free_eed (obj);                                                   \\\n        if (obj->tio.entity)                                                  \\\n          {                                                                   \\\n            FREE_IF (obj->tio.entity->tio.token);                             \\\n            FREE_IF (obj->tio.entity);                                        \\\n          }                                                                   \\\n      }                                                                       \\\n    obj->parent = NULL;                                                       \\\n    return error;                                                             \\\n  }                                                                           \\\n  static int dwg_free_##token##_private (Bit_Chain *restrict dat,             \\\n                                         Dwg_Object *restrict obj)            \\\n  {                                                                           \\\n    BITCODE_BL vcount, rcount1, rcount2, rcount3, rcount4;                    \\\n    Dwg_Entity_##token *ent, *_obj;                                           \\\n    Dwg_Object_Entity *_ent;                                                  \\\n    Bit_Chain *hdl_dat = dat;                                                 \\\n    Bit_Chain *str_dat = dat;                                                 \\\n    Dwg_Data *dwg = obj->parent;                                              \\\n    int error = 0;                                                            \\\n    _ent = obj->tio.entity;                                                   \\\n    _obj = ent = _ent->tio.token;\n\n#define DWG_ENTITY_END                                                        \\\n  return error;                                                               \\\n  }\n\n#define DWG_OBJECT(token)                                                     \\\n  static int dwg_free_##token##_private (Bit_Chain *restrict dat,             \\\n                                         Dwg_Object *restrict obj);           \\\n                                                                              \\\n  static int dwg_free_##token (Bit_Chain *restrict dat,                       \\\n                               Dwg_Object *restrict obj)                      \\\n  {                                                                           \\\n    int error = 0;                                                            \\\n    Dwg_Object_##token *_obj = NULL;                                          \\\n    if (obj->tio.object)                                                      \\\n      {                                                                       \\\n        _obj = obj->tio.object->tio.token;                                    \\\n        LOG_HANDLE (\"Free object \" #token \" [%d]\\n\", obj->index)              \\\n        if (strcmp (#token, \"UNKNOWN_OBJ\")                                    \\\n            && obj->supertype == DWG_SUPERTYPE_UNKNOWN)                       \\\n          {                                                                   \\\n            _obj = NULL;                                                      \\\n            error = dwg_free_UNKNOWN_OBJ (dat, obj);                          \\\n          }                                                                   \\\n        else                                                                  \\\n          {                                                                   \\\n            error = dwg_free_##token##_private (dat, obj);                    \\\n          }                                                                   \\\n        dwg_free_eed (obj);                                                   \\\n        FREE_IF (_obj);                                                       \\\n        FREE_IF (obj->tio.object);                                            \\\n      }                                                                       \\\n    obj->parent = NULL;                                                       \\\n    return error;                                                             \\\n  }                                                                           \\\n                                                                              \\\n  static int dwg_free_##token##_private (Bit_Chain *restrict dat,             \\\n                                         Dwg_Object *restrict obj)            \\\n  {                                                                           \\\n    BITCODE_BL vcount, rcount1, rcount2, rcount3, rcount4;                    \\\n    Dwg_Object_##token *_obj;                                                 \\\n    Bit_Chain *hdl_dat = dat;                                                 \\\n    Bit_Chain *str_dat = dat;                                                 \\\n    Dwg_Data *dwg = obj->parent;                                              \\\n    int error = 0;                                                            \\\n    if (!obj->tio.object)                                                     \\\n      return 0;                                                               \\\n    _obj = obj->tio.object->tio.token;\n\n/* obj itself is allocated via dwg->object[], dxfname is klass->dxfname or\n * static */\n#define DWG_OBJECT_END                                                        \\\n  return error;                                                               \\\n  }\n\nstatic void\ndwg_free_common_entity_data (Dwg_Object *obj)\n{\n\n  Dwg_Data *dwg = obj->parent;\n  Bit_Chain *dat = &pdat;\n  Bit_Chain *hdl_dat = &pdat;\n  Dwg_Object_Entity *_obj;\n  Dwg_Object_Entity *ent;\n  BITCODE_BL vcount;\n  int error = 0;\n\n  ent = obj->tio.entity;\n  if (!ent)\n    return;\n  _obj = ent;\n\n  FREE_IF (ent->preview);\n\n  // clang-format off\n  #include \"common_entity_data.spec\"\n  SINCE (R_13) {\n  #include \"common_entity_handle_data.spec\"\n  }\n  // clang-format on\n}\n\nstatic void\ndwg_free_xdata (Dwg_Object_XRECORD *obj, int size)\n{\n  dwg_free_xdata_resbuf (obj->xdata);\n  obj->xdata = NULL;\n}\n\nEXPORT void\ndwg_free_eed (Dwg_Object *obj)\n{\n  BITCODE_BL i;\n  if (obj->supertype == DWG_SUPERTYPE_ENTITY)\n    {\n      Dwg_Object_Entity *_obj = obj->tio.entity;\n      for (i = 0; i < _obj->num_eed; i++)\n        {\n          FREE_IF (_obj->eed[i].raw);\n          FREE_IF (_obj->eed[i].data);\n        }\n      FREE_IF (_obj->eed);\n      _obj->num_eed = 0;\n    }\n  else\n    {\n      Dwg_Object_Object *_obj = obj->tio.object;\n      if (!_obj || !_obj->eed)\n        return;\n      for (i = 0; i < _obj->num_eed; i++)\n        {\n          FREE_IF (_obj->eed[i].raw);\n          FREE_IF (_obj->eed[i].data);\n        }\n      FREE_IF (_obj->eed);\n      _obj->num_eed = 0;\n    }\n}\n\n#include \"dwg.spec\"\n\n/* returns 1 if object could be freed and 0 otherwise\n */\nstatic int\ndwg_free_variable_type (Dwg_Data *restrict dwg, Dwg_Object *restrict obj)\n{\n  const int i = obj->type - 500;\n  Dwg_Class *klass;\n  Bit_Chain *dat = &pdat;\n\n  if (i < 0 || i >= (int)dwg->num_classes)\n    return DWG_ERR_INVALIDTYPE;\n\n  klass = &dwg->dwg_class[i];\n  if (!klass || !klass->dxfname)\n    return DWG_ERR_INTERNALERROR;\n\n  if (strNE (obj->dxfname, klass->dxfname))\n    {\n      LOG_ERROR (\"Wrong %s.type %d for obj [%d]: != %s\",  obj->dxfname, obj->type,\n                 obj->index, klass->dxfname);\n      return DWG_ERR_INVALIDTYPE;\n    }\n\n  // global class dispatcher:\n  // with indxf even DEBUGGING objects, such as TABLE are created.\n  // usually not written/encoded though.\n\n  // clang-format off\n  #include \"classes.inc\"\n\n  #undef WARN_UNHANDLED_CLASS\n  #undef WARN_UNSTABLE_CLASS\n  // clang-format on\n\n  return DWG_ERR_UNHANDLEDCLASS;\n}\n\n// using the global dat\nvoid\ndwg_free_object (Dwg_Object *obj)\n{\n  int error = 0;\n  long unsigned int j;\n  Dwg_Data *dwg;\n  Bit_Chain *dat = &pdat;\n\n  if (obj && obj->parent)\n    {\n      dwg = obj->parent;\n      dat->version = dwg->header.version;\n    }\n  else\n    return;\n  if (obj->type == DWG_TYPE_FREED || obj->tio.object == NULL)\n    return;\n  dat->from_version = dat->version;\n  if (obj->supertype == DWG_SUPERTYPE_UNKNOWN)\n    goto unhandled;\n\n  switch (obj->type)\n    {\n    case DWG_TYPE_TEXT:\n      dwg_free_TEXT (dat, obj);\n      break;\n    case DWG_TYPE_ATTRIB:\n      dwg_free_ATTRIB (dat, obj);\n      break;\n    case DWG_TYPE_ATTDEF:\n      dwg_free_ATTDEF (dat, obj);\n      break;\n    case DWG_TYPE_BLOCK:\n      dwg_free_BLOCK (dat, obj);\n      break;\n    case DWG_TYPE_ENDBLK:\n      dwg_free_ENDBLK (dat, obj);\n      break;\n    case DWG_TYPE_SEQEND:\n      dwg_free_SEQEND (dat, obj);\n      break;\n    case DWG_TYPE_INSERT:\n      dwg_free_INSERT (dat, obj);\n      break;\n    case DWG_TYPE_MINSERT:\n      dwg_free_MINSERT (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_2D:\n      dwg_free_VERTEX_2D (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_3D:\n      dwg_free_VERTEX_3D (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_MESH:\n      dwg_free_VERTEX_MESH (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_PFACE:\n      dwg_free_VERTEX_PFACE (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_PFACE_FACE:\n      dwg_free_VERTEX_PFACE_FACE (dat, obj);\n      break;\n    case DWG_TYPE_POLYLINE_2D:\n      dwg_free_POLYLINE_2D (dat, obj);\n      break;\n    case DWG_TYPE_POLYLINE_3D:\n      dwg_free_POLYLINE_3D (dat, obj);\n      break;\n    case DWG_TYPE_ARC:\n      dwg_free_ARC (dat, obj);\n      break;\n    case DWG_TYPE_CIRCLE:\n      dwg_free_CIRCLE (dat, obj);\n      break;\n    case DWG_TYPE_LINE:\n      dwg_free_LINE (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_ORDINATE:\n      dwg_free_DIMENSION_ORDINATE (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_LINEAR:\n      dwg_free_DIMENSION_LINEAR (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_ALIGNED:\n      dwg_free_DIMENSION_ALIGNED (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_ANG3PT:\n      dwg_free_DIMENSION_ANG3PT (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_ANG2LN:\n      dwg_free_DIMENSION_ANG2LN (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_RADIUS:\n      dwg_free_DIMENSION_RADIUS (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_DIAMETER:\n      dwg_free_DIMENSION_DIAMETER (dat, obj);\n      break;\n    case DWG_TYPE_POINT:\n      dwg_free_POINT (dat, obj);\n      break;\n    case DWG_TYPE__3DFACE:\n      dwg_free__3DFACE (dat, obj);\n      break;\n    case DWG_TYPE_POLYLINE_PFACE:\n      dwg_free_POLYLINE_PFACE (dat, obj);\n      break;\n    case DWG_TYPE_POLYLINE_MESH:\n      dwg_free_POLYLINE_MESH (dat, obj);\n      break;\n    case DWG_TYPE_SOLID:\n      dwg_free_SOLID (dat, obj);\n      break;\n    case DWG_TYPE_TRACE:\n      dwg_free_TRACE (dat, obj);\n      break;\n    case DWG_TYPE_SHAPE:\n      dwg_free_SHAPE (dat, obj);\n      break;\n    case DWG_TYPE_VIEWPORT:\n      dwg_free_VIEWPORT (dat, obj);\n      break;\n    case DWG_TYPE_ELLIPSE:\n      dwg_free_ELLIPSE (dat, obj);\n      break;\n    case DWG_TYPE_SPLINE:\n      dwg_free_SPLINE (dat, obj);\n      break;\n    case DWG_TYPE_REGION:\n      dwg_free_REGION (dat, obj);\n      break;\n    case DWG_TYPE__3DSOLID:\n      dwg_free__3DSOLID (dat, obj);\n      break; /* Check the type of the object */\n    case DWG_TYPE_BODY:\n      dwg_free_BODY (dat, obj);\n      break;\n    case DWG_TYPE_RAY:\n      dwg_free_RAY (dat, obj);\n      break;\n    case DWG_TYPE_XLINE:\n      dwg_free_XLINE (dat, obj);\n      break;\n    case DWG_TYPE_DICTIONARY:\n      dwg_free_DICTIONARY (dat, obj);\n      break;\n    case DWG_TYPE_MTEXT:\n      dwg_free_MTEXT (dat, obj);\n      break;\n    case DWG_TYPE_LEADER:\n      dwg_free_LEADER (dat, obj);\n      break;\n    case DWG_TYPE_TOLERANCE:\n      dwg_free_TOLERANCE (dat, obj);\n      break;\n    case DWG_TYPE_MLINE:\n      dwg_free_MLINE (dat, obj);\n      break;\n    case DWG_TYPE_BLOCK_CONTROL:\n      dwg_free_BLOCK_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_BLOCK_HEADER:\n      dwg_free_BLOCK_HEADER (dat, obj);\n      break;\n    case DWG_TYPE_LAYER_CONTROL:\n      dwg_free_LAYER_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_LAYER:\n      dwg_free_LAYER (dat, obj);\n      break;\n    case DWG_TYPE_STYLE_CONTROL:\n      dwg_free_STYLE_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_STYLE:\n      dwg_free_STYLE (dat, obj);\n      break;\n    case DWG_TYPE_LTYPE_CONTROL:\n      dwg_free_LTYPE_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_LTYPE:\n      dwg_free_LTYPE (dat, obj);\n      break;\n    case DWG_TYPE_VIEW_CONTROL:\n      dwg_free_VIEW_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_VIEW:\n      dwg_free_VIEW (dat, obj);\n      break;\n    case DWG_TYPE_UCS_CONTROL:\n      dwg_free_UCS_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_UCS:\n      dwg_free_UCS (dat, obj);\n      break;\n    case DWG_TYPE_VPORT_CONTROL:\n      dwg_free_VPORT_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_VPORT:\n      dwg_free_VPORT (dat, obj);\n      break;\n    case DWG_TYPE_APPID_CONTROL:\n      dwg_free_APPID_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_APPID:\n      dwg_free_APPID (dat, obj);\n      break;\n    case DWG_TYPE_DIMSTYLE_CONTROL:\n      dwg_free_DIMSTYLE_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_DIMSTYLE:\n      dwg_free_DIMSTYLE (dat, obj);\n      break;\n    case DWG_TYPE_VPORT_ENTITY_CONTROL:\n      dwg_free_VPORT_ENTITY_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_VPORT_ENTITY_HEADER:\n      dwg_free_VPORT_ENTITY_HEADER (dat, obj);\n      break;\n    case DWG_TYPE_GROUP:\n      dwg_free_GROUP (dat, obj);\n      break;\n    case DWG_TYPE_MLINESTYLE:\n      dwg_free_MLINESTYLE (dat, obj);\n      break;\n    case DWG_TYPE_OLE2FRAME:\n      dwg_free_OLE2FRAME (dat, obj);\n      break;\n    case DWG_TYPE_DUMMY:\n      dwg_free_DUMMY (dat, obj);\n      break;\n    case DWG_TYPE_LONG_TRANSACTION:\n      dwg_free_LONG_TRANSACTION (dat, obj);\n      break;\n    case DWG_TYPE_LWPOLYLINE:\n      dwg_free_LWPOLYLINE (dat, obj);\n      break;\n    case DWG_TYPE_HATCH:\n      dwg_free_HATCH (dat, obj);\n      break;\n    case DWG_TYPE_XRECORD:\n      dwg_free_XRECORD (dat, obj);\n      break;\n    case DWG_TYPE_PLACEHOLDER:\n      dwg_free_PLACEHOLDER (dat, obj);\n      break;\n    case DWG_TYPE_OLEFRAME:\n      dwg_free_OLEFRAME (dat, obj);\n      break;\n#ifdef DEBUG_VBA_PROJECT\n    case DWG_TYPE_VBA_PROJECT:\n      dwg_free_VBA_PROJECT (dat, obj);\n      break;\n#endif\n    case DWG_TYPE_LAYOUT:\n      dwg_free_LAYOUT (dat, obj);\n      break;\n    case DWG_TYPE_PROXY_ENTITY:\n      dwg_free_PROXY_ENTITY (dat, obj);\n      break;\n    case DWG_TYPE_PROXY_OBJECT:\n      dwg_free_PROXY_OBJECT (dat, obj);\n      break;\n    default:\n      if (obj->type == obj->parent->layout_type)\n        {\n          SINCE (R_13)\n          {\n            dwg_free_LAYOUT (dat, obj); // XXX avoid double-free, esp. in eed\n          }\n        }\n\n      else if ((error = dwg_free_variable_type (obj->parent, obj))\n               & DWG_ERR_UNHANDLEDCLASS)\n        {\n        unhandled:\n          if (obj->fixedtype == DWG_TYPE_UNKNOWN_ENT)\n              dwg_free_UNKNOWN_ENT (dat, obj);\n          else if (obj->fixedtype == DWG_TYPE_UNKNOWN_OBJ)\n              dwg_free_UNKNOWN_OBJ (dat, obj);\n        }\n    }\n  /* With this importer the dxfname is dynamic, just the name is const */\n  if (dwg->opts & DWG_OPTS_INDXF)\n    FREE_IF (obj->dxfname);\n  obj->type = DWG_TYPE_FREED;\n}\n\nstatic int\ndwg_free_header_vars (Dwg_Data *dwg)\n{\n  Dwg_Header_Variables *_obj = &dwg->header_vars;\n  Dwg_Object *obj = NULL;\n  Bit_Chain *dat = &pdat;\n  // clang-format off\n  #include \"header_variables.spec\"\n  // clang-format on\n  return 0;\n}\n\nstatic int\ndwg_free_summaryinfo (Dwg_Data *dwg)\n{\n  struct Dwg_SummaryInfo *_obj = &dwg->summaryinfo;\n  Dwg_Object *obj = NULL;\n  Bit_Chain *dat = &pdat;\n  BITCODE_RL rcount1, rcount2;\n  // clang-format off\n  #include \"summaryinfo.spec\"\n  // clang-format on\n  return 0;\n}\n\nvoid\ndwg_free (Dwg_Data *dwg)\n{\n  BITCODE_BL i;\n  if (dwg)\n    {\n      pdat.version = dwg->header.version;\n      pdat.from_version = dwg->header.version;\n      if (dwg->opts)\n        {\n          loglevel = dwg->opts & DWG_OPTS_LOGLEVEL;\n          pdat.opts = dwg->opts;\n        }\n#ifdef USE_TRACING\n      /* Before starting, set the logging level, but only do so once.  */\n      if (!env_var_checked_p)\n        {\n          char *probe = getenv (\"LIBREDWG_TRACE\");\n          if (probe)\n            loglevel = atoi (probe);\n          env_var_checked_p = 1;\n        }\n#endif /* USE_TRACING */\n      LOG_INFO (\"\\n============\\ndwg_free\\n\")\n      // copied table fields have duplicate pointers, but are freed only once\n      for (i = 0; i < dwg->num_objects; ++i)\n        {\n          if (!dwg_obj_is_control (&dwg->object[i]))\n            dwg_free_object (&dwg->object[i]);\n        }\n      FREE_IF (dwg->header.section);\n      dwg_free_header_vars (dwg);\n      dwg_free_summaryinfo (dwg);\n      FREE_IF (dwg->thumbnail.chain);\n      if (dwg->header.section_infohdr.num_desc)\n        {\n          for (i = 0; i < dwg->header.section_infohdr.num_desc; ++i)\n            FREE_IF (dwg->header.section_info[i].sections);\n          FREE_IF (dwg->header.section_info);\n        }\n      for (i = 0; i < dwg->second_header.num_handlers; i++)\n        FREE_IF (dwg->second_header.handlers[i].data);\n      // auxheader has no strings\n      for (i = 0; i < dwg->num_objects; ++i)\n        {\n          if (dwg_obj_is_control (&dwg->object[i]))\n            dwg_free_object (&dwg->object[i]);\n        }\n      if (dwg->num_classes && dwg->dwg_class)\n        {\n          for (i = 0; i < dwg->num_classes; ++i)\n            {\n              FREE_IF (dwg->dwg_class[i].appname);\n              FREE_IF (dwg->dwg_class[i].cppname);\n              FREE_IF (dwg->dwg_class[i].dxfname);\n              if (dwg->header.version >= R_2007)\n                FREE_IF (dwg->dwg_class[i].dxfname_u);\n            }\n          FREE_IF (dwg->dwg_class);\n        }\n      if (dwg->object_ref)\n        {\n          LOG_HANDLE (\"free %d global refs\\n\", dwg->num_object_refs)\n          for (i = 0; i < dwg->num_object_refs; ++i)\n            {\n              //LOG_HANDLE (\"free ref %d\\n\", i)\n              FREE_IF (dwg->object_ref[i]);\n            }\n        }\n      FREE_IF (dwg->object_ref);\n      FREE_IF (dwg->object);\n      if (dwg->object_map)\n        hash_free (dwg->object_map);\n#undef FREE_IF\n    }\n}\n\n#undef IS_FREE\n"], "filenames": ["include/dwg.h", "src/decode.c", "src/encode.c", "src/free.c"], "buggy_code_start_loc": [5459, 5014, 1973, 734], "buggy_code_end_loc": [5460, 5096, 1993, 771], "fixing_code_start_loc": [5458, 5014, 1973, 733], "fixing_code_end_loc": [5458, 5046, 1976, 738], "type": "CWE-835", "message": "An issue was discovered in GNU LibreDWG through 0.9.3. Crafted input will lead to denial of service in bit_calc_CRC in bits.c, related to a for loop.", "other": {"cve": {"id": "CVE-2019-20911", "sourceIdentifier": "cve@mitre.org", "published": "2020-07-16T18:15:13.300", "lastModified": "2020-07-22T17:59:41.157", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in GNU LibreDWG through 0.9.3. Crafted input will lead to denial of service in bit_calc_CRC in bits.c, related to a for loop."}, {"lang": "es", "value": "Se detect\u00f3 un problema en GNU LibreDWG versiones hasta 0.9.3. Una entrada dise\u00f1ada conllevar\u00e1 a una denegaci\u00f3n de servicio en la funci\u00f3n bit_calc_CRC en el archivo bits.c, relacionado con un bucle for"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-835"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gnu:libredwg:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.9.3", "matchCriteriaId": "28E3A7DE-65A0-4A6B-BF63-00F627CF17CB"}]}]}], "references": [{"url": "https://github.com/LibreDWG/libredwg/commit/c6f6668b82bfe595899cc820279ac37bb9ef16f5", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/LibreDWG/libredwg/issues/178", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/LibreDWG/libredwg/commit/c6f6668b82bfe595899cc820279ac37bb9ef16f5"}}