{"buggy_code": ["/*====================================================================*\n -  Copyright (C) 2001 Leptonica.  All rights reserved.\n -\n -  Redistribution and use in source and binary forms, with or without\n -  modification, are permitted provided that the following conditions\n -  are met:\n -  1. Redistributions of source code must retain the above copyright\n -     notice, this list of conditions and the following disclaimer.\n -  2. Redistributions in binary form must reproduce the above\n -     copyright notice, this list of conditions and the following\n -     disclaimer in the documentation and/or other materials\n -     provided with the distribution.\n -\n -  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n -  ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n -  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n -  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL ANY\n -  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n -  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n -  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n -  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n -  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n -  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n -  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *====================================================================*/\n\n/*!\n * \\file convolve.c\n * <pre>\n *\n *      Top level grayscale or color block convolution\n *          PIX          *pixBlockconv()\n *\n *      Grayscale block convolution\n *          PIX          *pixBlockconvGray()\n *          static void   blockconvLow()\n *\n *      Accumulator for 1, 8 and 32 bpp convolution\n *          PIX          *pixBlockconvAccum()\n *          static void   blockconvAccumLow()\n *\n *      Un-normalized grayscale block convolution\n *          PIX          *pixBlockconvGrayUnnormalized()\n *\n *      Tiled grayscale or color block convolution\n *          PIX          *pixBlockconvTiled()\n *          PIX          *pixBlockconvGrayTile()\n *\n *      Convolution for mean, mean square, variance and rms deviation\n *      in specified window\n *          l_int32       pixWindowedStats()\n *          PIX          *pixWindowedMean()\n *          PIX          *pixWindowedMeanSquare()\n *          l_int32       pixWindowedVariance()\n *          DPIX         *pixMeanSquareAccum()\n *\n *      Binary block sum and rank filter\n *          PIX          *pixBlockrank()\n *          PIX          *pixBlocksum()\n *          static void   blocksumLow()\n *\n *      Census transform\n *          PIX          *pixCensusTransform()\n *\n *      Generic convolution (with Pix)\n *          PIX          *pixConvolve()\n *          PIX          *pixConvolveSep()\n *          PIX          *pixConvolveRGB()\n *          PIX          *pixConvolveRGBSep()\n *\n *      Generic convolution (with float arrays)\n *          FPIX         *fpixConvolve()\n *          FPIX         *fpixConvolveSep()\n *\n *      Convolution with bias (for non-negative output)\n *          PIX          *pixConvolveWithBias()\n *\n *      Set parameter for convolution subsampling\n *          void          l_setConvolveSampling()\n *\n *      Additive gaussian noise\n *          PIX          *pixAddGaussNoise()\n *          l_float32     gaussDistribSampling()\n * </pre>\n */\n\n#ifdef HAVE_CONFIG_H\n#include <config_auto.h>\n#endif  /* HAVE_CONFIG_H */\n\n#include <math.h>\n#include \"allheaders.h\"\n\n    /* These globals determine the subsampling factors for\n     * generic convolution of pix and fpix.  Declare extern to use.\n     * To change the values, use l_setConvolveSampling(). */\nLEPT_DLL l_int32  ConvolveSamplingFactX = 1;\nLEPT_DLL l_int32  ConvolveSamplingFactY = 1;\n\n    /* Low-level static functions */\nstatic void blockconvLow(l_uint32 *data, l_int32 w, l_int32 h, l_int32 wpl,\n                         l_uint32 *dataa, l_int32 wpla, l_int32 wc,\n                         l_int32 hc);\nstatic void blockconvAccumLow(l_uint32 *datad, l_int32 w, l_int32 h,\n                              l_int32 wpld, l_uint32 *datas, l_int32 d,\n                              l_int32 wpls);\nstatic void blocksumLow(l_uint32 *datad, l_int32 w, l_int32 h, l_int32 wpl,\n                        l_uint32 *dataa, l_int32 wpla, l_int32 wc, l_int32 hc);\n\n\n/*----------------------------------------------------------------------*\n *             Top-level grayscale or color block convolution           *\n *----------------------------------------------------------------------*/\n/*!\n * \\brief   pixBlockconv()\n *\n * \\param[in]    pix 8    or 32 bpp; or 2, 4 or 8 bpp with colormap\n * \\param[in]    wc, hc   half width/height of convolution kernel\n * \\return  pixd, or NULL on error\n *\n * <pre>\n * Notes:\n *      (1) The full width and height of the convolution kernel\n *          are (2 * wc + 1) and (2 * hc + 1)\n *      (2) Returns a copy if both wc and hc are 0\n *      (3) Require that w >= 2 * wc + 1 and h >= 2 * hc + 1,\n *          where (w,h) are the dimensions of pixs.\n * </pre>\n */\nPIX  *\npixBlockconv(PIX     *pix,\n             l_int32  wc,\n             l_int32  hc)\n{\nl_int32  w, h, d;\nPIX     *pixs, *pixd, *pixr, *pixrc, *pixg, *pixgc, *pixb, *pixbc;\n\n    PROCNAME(\"pixBlockconv\");\n\n    if (!pix)\n        return (PIX *)ERROR_PTR(\"pix not defined\", procName, NULL);\n    if (wc < 0) wc = 0;\n    if (hc < 0) hc = 0;\n    pixGetDimensions(pix, &w, &h, &d);\n    if (w < 2 * wc + 1 || h < 2 * hc + 1) {\n        wc = L_MIN(wc, (w - 1) / 2);\n        hc = L_MIN(hc, (h - 1) / 2);\n        L_WARNING(\"kernel too large; reducing!\\n\", procName);\n        L_INFO(\"wc = %d, hc = %d\\n\", procName, wc, hc);\n    }\n    if (wc == 0 && hc == 0)   /* no-op */\n        return pixCopy(NULL, pix);\n\n        /* Remove colormap if necessary */\n    if ((d == 2 || d == 4 || d == 8) && pixGetColormap(pix)) {\n        L_WARNING(\"pix has colormap; removing\\n\", procName);\n        pixs = pixRemoveColormap(pix, REMOVE_CMAP_BASED_ON_SRC);\n        d = pixGetDepth(pixs);\n    } else {\n        pixs = pixClone(pix);\n    }\n\n    if (d != 8 && d != 32) {\n        pixDestroy(&pixs);\n        return (PIX *)ERROR_PTR(\"depth not 8 or 32 bpp\", procName, NULL);\n    }\n\n    if (d == 8) {\n        pixd = pixBlockconvGray(pixs, NULL, wc, hc);\n    } else { /* d == 32 */\n        pixr = pixGetRGBComponent(pixs, COLOR_RED);\n        pixrc = pixBlockconvGray(pixr, NULL, wc, hc);\n        pixDestroy(&pixr);\n        pixg = pixGetRGBComponent(pixs, COLOR_GREEN);\n        pixgc = pixBlockconvGray(pixg, NULL, wc, hc);\n        pixDestroy(&pixg);\n        pixb = pixGetRGBComponent(pixs, COLOR_BLUE);\n        pixbc = pixBlockconvGray(pixb, NULL, wc, hc);\n        pixDestroy(&pixb);\n        pixd = pixCreateRGBImage(pixrc, pixgc, pixbc);\n        pixDestroy(&pixrc);\n        pixDestroy(&pixgc);\n        pixDestroy(&pixbc);\n    }\n\n    pixDestroy(&pixs);\n    return pixd;\n}\n\n\n/*----------------------------------------------------------------------*\n *                     Grayscale block convolution                      *\n *----------------------------------------------------------------------*/\n/*!\n * \\brief   pixBlockconvGray()\n *\n * \\param[in]    pixs     8 bpp\n * \\param[in]    pixacc   pix 32 bpp; can be null\n * \\param[in]    wc, hc   half width/height of convolution kernel\n * \\return  pix 8 bpp, or NULL on error\n *\n * <pre>\n * Notes:\n *      (1) If accum pix is null, make one and destroy it before\n *          returning; otherwise, just use the input accum pix.\n *      (2) The full width and height of the convolution kernel\n *          are (2 * wc + 1) and (2 * hc + 1).\n *      (3) Returns a copy if both wc and hc are 0.\n *      (4) Require that w >= 2 * wc + 1 and h >= 2 * hc + 1,\n *          where (w,h) are the dimensions of pixs.\n * </pre>\n */\nPIX *\npixBlockconvGray(PIX     *pixs,\n                 PIX     *pixacc,\n                 l_int32  wc,\n                 l_int32  hc)\n{\nl_int32    w, h, d, wpl, wpla;\nl_uint32  *datad, *dataa;\nPIX       *pixd, *pixt;\n\n    PROCNAME(\"pixBlockconvGray\");\n\n    if (!pixs)\n        return (PIX *)ERROR_PTR(\"pixs not defined\", procName, NULL);\n    pixGetDimensions(pixs, &w, &h, &d);\n    if (d != 8)\n        return (PIX *)ERROR_PTR(\"pixs not 8 bpp\", procName, NULL);\n    if (wc < 0) wc = 0;\n    if (hc < 0) hc = 0;\n    if (wc == 0 && hc == 0)   /* no-op */\n        return pixCopy(NULL, pixs);\n    if (w < 2 * wc + 1 || h < 2 * hc + 1) {\n        L_WARNING(\"kernel too large; returning a copy\\n\", procName);\n        L_INFO(\"w = %d, wc = %d, h = %d, hc = %d\\n\", procName, w, wc, h, hc);\n        return pixCopy(NULL, pixs);\n    }\n\n    if (pixacc) {\n        if (pixGetDepth(pixacc) == 32) {\n            pixt = pixClone(pixacc);\n        } else {\n            L_WARNING(\"pixacc not 32 bpp; making new one\\n\", procName);\n            if ((pixt = pixBlockconvAccum(pixs)) == NULL)\n                return (PIX *)ERROR_PTR(\"pixt not made\", procName, NULL);\n        }\n    } else {\n        if ((pixt = pixBlockconvAccum(pixs)) == NULL)\n            return (PIX *)ERROR_PTR(\"pixt not made\", procName, NULL);\n    }\n\n    if ((pixd = pixCreateTemplate(pixs)) == NULL) {\n        pixDestroy(&pixt);\n        return (PIX *)ERROR_PTR(\"pixd not made\", procName, NULL);\n    }\n\n    pixSetPadBits(pixt, 0);\n    wpl = pixGetWpl(pixd);\n    wpla = pixGetWpl(pixt);\n    datad = pixGetData(pixd);\n    dataa = pixGetData(pixt);\n    blockconvLow(datad, w, h, wpl, dataa, wpla, wc, hc);\n\n    pixDestroy(&pixt);\n    return pixd;\n}\n\n\n/*!\n * \\brief   blockconvLow()\n *\n * \\param[in]    data      data of input image, to be convolved\n * \\param[in]    w, h, wpl\n * \\param[in]    dataa     data of 32 bpp accumulator\n * \\param[in]    wpla      accumulator\n * \\param[in]    wc        convolution \"half-width\"\n * \\param[in]    hc        convolution \"half-height\"\n * \\return  void\n *\n * <pre>\n * Notes:\n *      (1) The full width and height of the convolution kernel\n *          are (2 * wc + 1) and (2 * hc + 1).\n *      (2) The lack of symmetry between the handling of the\n *          first (hc + 1) lines and the last (hc) lines,\n *          and similarly with the columns, is due to fact that\n *          for the pixel at (x,y), the accumulator values are\n *          taken at (x + wc, y + hc), (x - wc - 1, y + hc),\n *          (x + wc, y - hc - 1) and (x - wc - 1, y - hc - 1).\n *      (3) We compute sums, normalized as if there were no reduced\n *          area at the boundary.  This under-estimates the value\n *          of the boundary pixels, so we multiply them by another\n *          normalization factor that is greater than 1.\n *      (4) This second normalization is done first for the first\n *          hc + 1 lines; then for the last hc lines; and finally\n *          for the first wc + 1 and last wc columns in the intermediate\n *          lines.\n *      (5) The caller should verify that wc < w and hc < h.\n *          Under those conditions, illegal reads and writes can occur.\n *      (6) Implementation note: to get the same results in the interior\n *          between this function and pixConvolve(), it is necessary to\n *          add 0.5 for roundoff in the main loop that runs over all pixels.\n *          However, if we do that and have white (255) pixels near the\n *          image boundary, some overflow occurs for pixels very close\n *          to the boundary.  We can't fix this by subtracting from the\n *          normalized values for the boundary pixels, because this results\n *          in underflow if the boundary pixels are black (0).  Empirically,\n *          adding 0.25 (instead of 0.5) before truncating in the main\n *          loop will not cause overflow, but this gives some\n *          off-by-1-level errors in interior pixel values.  So we add\n *          0.5 for roundoff in the main loop, and for pixels within a\n *          half filter width of the boundary, use a L_MIN of the\n *          computed value and 255 to avoid overflow during normalization.\n * </pre>\n */\nstatic void\nblockconvLow(l_uint32  *data,\n             l_int32    w,\n             l_int32    h,\n             l_int32    wpl,\n             l_uint32  *dataa,\n             l_int32    wpla,\n             l_int32    wc,\n             l_int32    hc)\n{\nl_int32    i, j, imax, imin, jmax, jmin;\nl_int32    wn, hn, fwc, fhc, wmwc, hmhc;\nl_float32  norm, normh, normw;\nl_uint32   val;\nl_uint32  *linemina, *linemaxa, *line;\n\n    PROCNAME(\"blockconvLow\");\n\n    wmwc = w - wc;\n    hmhc = h - hc;\n    if (wmwc <= 0 || hmhc <= 0) {\n        L_ERROR(\"wc >= w || hc >=h\\n\", procName);\n        return;\n    }\n    fwc = 2 * wc + 1;\n    fhc = 2 * hc + 1;\n    norm = 1.0 / ((l_float32)(fwc) * fhc);\n\n        /*------------------------------------------------------------*\n         *  Compute, using b.c. only to set limits on the accum image *\n         *------------------------------------------------------------*/\n    for (i = 0; i < h; i++) {\n        imin = L_MAX(i - 1 - hc, 0);\n        imax = L_MIN(i + hc, h - 1);\n        line = data + wpl * i;\n        linemina = dataa + wpla * imin;\n        linemaxa = dataa + wpla * imax;\n        for (j = 0; j < w; j++) {\n            jmin = L_MAX(j - 1 - wc, 0);\n            jmax = L_MIN(j + wc, w - 1);\n            val = linemaxa[jmax] - linemaxa[jmin]\n                  + linemina[jmin] - linemina[jmax];\n            val = (l_uint8)(norm * val + 0.5);  /* see comment above */\n            SET_DATA_BYTE(line, j, val);\n        }\n    }\n\n        /*------------------------------------------------------------*\n         *             Fix normalization for boundary pixels          *\n         *------------------------------------------------------------*/\n    for (i = 0; i <= hc; i++) {    /* first hc + 1 lines */\n        hn = L_MAX(1, hc + i);\n        normh = (l_float32)fhc / (l_float32)hn;   /* >= 1 */\n        line = data + wpl * i;\n        for (j = 0; j <= wc; j++) {\n            wn = L_MAX(1, wc + j);\n            normw = (l_float32)fwc / (l_float32)wn;   /* >= 1 */\n            val = GET_DATA_BYTE(line, j);\n            val = (l_uint8)L_MIN(val * normh * normw, 255);\n            SET_DATA_BYTE(line, j, val);\n        }\n        for (j = wc + 1; j < wmwc; j++) {\n            val = GET_DATA_BYTE(line, j);\n            val = (l_uint8)L_MIN(val * normh, 255);\n            SET_DATA_BYTE(line, j, val);\n        }\n        for (j = wmwc; j < w; j++) {\n            wn = wc + w - j;\n            normw = (l_float32)fwc / (l_float32)wn;   /* > 1 */\n            val = GET_DATA_BYTE(line, j);\n            val = (l_uint8)L_MIN(val * normh * normw, 255);\n            SET_DATA_BYTE(line, j, val);\n        }\n    }\n\n    for (i = hmhc; i < h; i++) {  /* last hc lines */\n        hn = hc + h - i;\n        normh = (l_float32)fhc / (l_float32)hn;   /* > 1 */\n        line = data + wpl * i;\n        for (j = 0; j <= wc; j++) {\n            wn = wc + j;\n            normw = (l_float32)fwc / (l_float32)wn;   /* > 1 */\n            val = GET_DATA_BYTE(line, j);\n            val = (l_uint8)L_MIN(val * normh * normw, 255);\n            SET_DATA_BYTE(line, j, val);\n        }\n        for (j = wc + 1; j < wmwc; j++) {\n            val = GET_DATA_BYTE(line, j);\n            val = (l_uint8)L_MIN(val * normh, 255);\n            SET_DATA_BYTE(line, j, val);\n        }\n        for (j = wmwc; j < w; j++) {\n            wn = wc + w - j;\n            normw = (l_float32)fwc / (l_float32)wn;   /* > 1 */\n            val = GET_DATA_BYTE(line, j);\n            val = (l_uint8)L_MIN(val * normh * normw, 255);\n            SET_DATA_BYTE(line, j, val);\n        }\n    }\n\n    for (i = hc + 1; i < hmhc; i++) {    /* intermediate lines */\n        line = data + wpl * i;\n        for (j = 0; j <= wc; j++) {   /* first wc + 1 columns */\n            wn = wc + j;\n            normw = (l_float32)fwc / (l_float32)wn;   /* > 1 */\n            val = GET_DATA_BYTE(line, j);\n            val = (l_uint8)L_MIN(val * normw, 255);\n            SET_DATA_BYTE(line, j, val);\n        }\n        for (j = wmwc; j < w; j++) {   /* last wc columns */\n            wn = wc + w - j;\n            normw = (l_float32)fwc / (l_float32)wn;   /* > 1 */\n            val = GET_DATA_BYTE(line, j);\n            val = (l_uint8)L_MIN(val * normw, 255);\n            SET_DATA_BYTE(line, j, val);\n        }\n    }\n}\n\n\n/*----------------------------------------------------------------------*\n *              Accumulator for 1, 8 and 32 bpp convolution             *\n *----------------------------------------------------------------------*/\n/*!\n * \\brief   pixBlockconvAccum()\n *\n * \\param[in]    pixs    1, 8 or 32 bpp\n * \\return  accum pix 32 bpp, or NULL on error.\n *\n * <pre>\n * Notes:\n *      (1) The general recursion relation is\n *            a(i,j) = v(i,j) + a(i-1, j) + a(i, j-1) - a(i-1, j-1)\n *          For the first line, this reduces to the special case\n *            a(i,j) = v(i,j) + a(i, j-1)\n *          For the first column, the special case is\n *            a(i,j) = v(i,j) + a(i-1, j)\n * </pre>\n */\nPIX *\npixBlockconvAccum(PIX  *pixs)\n{\nl_int32    w, h, d, wpls, wpld;\nl_uint32  *datas, *datad;\nPIX       *pixd;\n\n    PROCNAME(\"pixBlockconvAccum\");\n\n    if (!pixs)\n        return (PIX *)ERROR_PTR(\"pixs not defined\", procName, NULL);\n\n    pixGetDimensions(pixs, &w, &h, &d);\n    if (d != 1 && d != 8 && d != 32)\n        return (PIX *)ERROR_PTR(\"pixs not 1, 8 or 32 bpp\", procName, NULL);\n    if ((pixd = pixCreate(w, h, 32)) == NULL)\n        return (PIX *)ERROR_PTR(\"pixd not made\", procName, NULL);\n\n    datas = pixGetData(pixs);\n    datad = pixGetData(pixd);\n    wpls = pixGetWpl(pixs);\n    wpld = pixGetWpl(pixd);\n    blockconvAccumLow(datad, w, h, wpld, datas, d, wpls);\n\n    return pixd;\n}\n\n\n/*\n * \\brief   blockconvAccumLow()\n *\n * \\param[in]    datad         32 bpp dest\n * \\param[in]    w, h, wpld    of 32 bpp dest\n * \\param[in]    datas         1, 8 or 32 bpp src\n * \\param[in]    d             bpp of src\n * \\param[in]    wpls          of src\n * \\return   void\n *\n * <pre>\n * Notes:\n *      (1) The general recursion relation is\n *             a(i,j) = v(i,j) + a(i-1, j) + a(i, j-1) - a(i-1, j-1)\n *          For the first line, this reduces to the special case\n *             a(0,j) = v(0,j) + a(0, j-1), j > 0\n *          For the first column, the special case is\n *             a(i,0) = v(i,0) + a(i-1, 0), i > 0\n * </pre>\n */\nstatic void\nblockconvAccumLow(l_uint32  *datad,\n                  l_int32    w,\n                  l_int32    h,\n                  l_int32    wpld,\n                  l_uint32  *datas,\n                  l_int32    d,\n                  l_int32    wpls)\n{\nl_uint8    val;\nl_int32    i, j;\nl_uint32   val32;\nl_uint32  *lines, *lined, *linedp;\n\n    PROCNAME(\"blockconvAccumLow\");\n\n    lines = datas;\n    lined = datad;\n\n    if (d == 1) {\n            /* Do the first line */\n        for (j = 0; j < w; j++) {\n            val = GET_DATA_BIT(lines, j);\n            if (j == 0)\n                lined[0] = val;\n            else\n                lined[j] = lined[j - 1] + val;\n        }\n\n            /* Do the other lines */\n        for (i = 1; i < h; i++) {\n            lines = datas + i * wpls;\n            lined = datad + i * wpld;  /* curr dest line */\n            linedp = lined - wpld;   /* prev dest line */\n            for (j = 0; j < w; j++) {\n                val = GET_DATA_BIT(lines, j);\n                if (j == 0)\n                    lined[0] = val + linedp[0];\n                else\n                    lined[j] = val + lined[j - 1] + linedp[j] - linedp[j - 1];\n            }\n        }\n    } else if (d == 8) {\n            /* Do the first line */\n        for (j = 0; j < w; j++) {\n            val = GET_DATA_BYTE(lines, j);\n            if (j == 0)\n                lined[0] = val;\n            else\n                lined[j] = lined[j - 1] + val;\n        }\n\n            /* Do the other lines */\n        for (i = 1; i < h; i++) {\n            lines = datas + i * wpls;\n            lined = datad + i * wpld;  /* curr dest line */\n            linedp = lined - wpld;   /* prev dest line */\n            for (j = 0; j < w; j++) {\n                val = GET_DATA_BYTE(lines, j);\n                if (j == 0)\n                    lined[0] = val + linedp[0];\n                else\n                    lined[j] = val + lined[j - 1] + linedp[j] - linedp[j - 1];\n            }\n        }\n    } else if (d == 32) {\n            /* Do the first line */\n        for (j = 0; j < w; j++) {\n            val32 = lines[j];\n            if (j == 0)\n                lined[0] = val32;\n            else\n                lined[j] = lined[j - 1] + val32;\n        }\n\n            /* Do the other lines */\n        for (i = 1; i < h; i++) {\n            lines = datas + i * wpls;\n            lined = datad + i * wpld;  /* curr dest line */\n            linedp = lined - wpld;   /* prev dest line */\n            for (j = 0; j < w; j++) {\n                val32 = lines[j];\n                if (j == 0)\n                    lined[0] = val32 + linedp[0];\n                else\n                    lined[j] = val32 + lined[j - 1] + linedp[j] - linedp[j - 1];\n            }\n        }\n    } else {\n        L_ERROR(\"depth not 1, 8 or 32 bpp\\n\", procName);\n    }\n}\n\n\n/*----------------------------------------------------------------------*\n *               Un-normalized grayscale block convolution              *\n *----------------------------------------------------------------------*/\n/*!\n * \\brief   pixBlockconvGrayUnnormalized()\n *\n * \\param[in]    pixs     8 bpp\n * \\param[in]    wc, hc   half width/height of convolution kernel\n * \\return  pix 32 bpp; containing the convolution without normalizing\n *                   for the window size, or NULL on error\n *\n * <pre>\n * Notes:\n *      (1) The full width and height of the convolution kernel\n *          are (2 * wc + 1) and (2 * hc + 1).\n *      (2) Require that w >= 2 * wc + 1 and h >= 2 * hc + 1,\n *          where (w,h) are the dimensions of pixs.\n *      (3) Returns a copy if both wc and hc are 0.\n *      (3) Adds mirrored border to avoid treating the boundary pixels\n *          specially.  Note that we add wc + 1 pixels to the left\n *          and wc to the right.  The added width is 2 * wc + 1 pixels,\n *          and the particular choice simplifies the indexing in the loop.\n *          Likewise, add hc + 1 pixels to the top and hc to the bottom.\n *      (4) To get the normalized result, divide by the area of the\n *          convolution kernel: (2 * wc + 1) * (2 * hc + 1)\n *          Specifically, do this:\n *               pixc = pixBlockconvGrayUnnormalized(pixs, wc, hc);\n *               fract = 1. / ((2 * wc + 1) * (2 * hc + 1));\n *               pixMultConstantGray(pixc, fract);\n *               pixd = pixGetRGBComponent(pixc, L_ALPHA_CHANNEL);\n *      (5) Unlike pixBlockconvGray(), this always computes the accumulation\n *          pix because its size is tied to wc and hc.\n *      (6) Compare this implementation with pixBlockconvGray(), where\n *          most of the code in blockconvLow() is special casing for\n *          efficiently handling the boundary.  Here, the use of\n *          mirrored borders and destination indexing makes the\n *          implementation very simple.\n * </pre>\n */\nPIX *\npixBlockconvGrayUnnormalized(PIX     *pixs,\n                             l_int32  wc,\n                             l_int32  hc)\n{\nl_int32    i, j, w, h, d, wpla, wpld, jmax;\nl_uint32  *linemina, *linemaxa, *lined, *dataa, *datad;\nPIX       *pixsb, *pixacc, *pixd;\n\n    PROCNAME(\"pixBlockconvGrayUnnormalized\");\n\n    if (!pixs)\n        return (PIX *)ERROR_PTR(\"pixs not defined\", procName, NULL);\n    pixGetDimensions(pixs, &w, &h, &d);\n    if (d != 8)\n        return (PIX *)ERROR_PTR(\"pixs not 8 bpp\", procName, NULL);\n    if (wc < 0) wc = 0;\n    if (hc < 0) hc = 0;\n    if (w < 2 * wc + 1 || h < 2 * hc + 1) {\n        wc = L_MIN(wc, (w - 1) / 2);\n        hc = L_MIN(hc, (h - 1) / 2);\n        L_WARNING(\"kernel too large; reducing!\\n\", procName);\n        L_INFO(\"wc = %d, hc = %d\\n\", procName, wc, hc);\n    }\n    if (wc == 0 && hc == 0)   /* no-op */\n        return pixCopy(NULL, pixs);\n\n    if ((pixsb = pixAddMirroredBorder(pixs, wc + 1, wc, hc + 1, hc)) == NULL)\n        return (PIX *)ERROR_PTR(\"pixsb not made\", procName, NULL);\n    pixacc = pixBlockconvAccum(pixsb);\n    pixDestroy(&pixsb);\n    if (!pixacc)\n        return (PIX *)ERROR_PTR(\"pixacc not made\", procName, NULL);\n    if ((pixd = pixCreate(w, h, 32)) == NULL) {\n        pixDestroy(&pixacc);\n        return (PIX *)ERROR_PTR(\"pixd not made\", procName, NULL);\n    }\n\n    wpla = pixGetWpl(pixacc);\n    wpld = pixGetWpl(pixd);\n    datad = pixGetData(pixd);\n    dataa = pixGetData(pixacc);\n    for (i = 0; i < h; i++) {\n        lined = datad + i * wpld;\n        linemina = dataa + i * wpla;\n        linemaxa = dataa + (i + 2 * hc + 1) * wpla;\n        for (j = 0; j < w; j++) {\n            jmax = j + 2 * wc + 1;\n            lined[j] = linemaxa[jmax] - linemaxa[j] -\n                       linemina[jmax] + linemina[j];\n        }\n    }\n\n    pixDestroy(&pixacc);\n    return pixd;\n}\n\n\n/*----------------------------------------------------------------------*\n *               Tiled grayscale or color block convolution             *\n *----------------------------------------------------------------------*/\n/*!\n * \\brief   pixBlockconvTiled()\n *\n * \\param[in]    pix      8 or 32 bpp; or 2, 4 or 8 bpp with colormap\n * \\param[in]    wc, hc   half width/height of convolution kernel\n * \\param[in]    nx, ny   subdivision into tiles\n * \\return  pixd, or NULL on error\n *\n * <pre>\n * Notes:\n *      (1) The full width and height of the convolution kernel\n *          are (2 * wc + 1) and (2 * hc + 1)\n *      (2) Returns a copy if both wc and hc are 0\n *      (3) Require that w >= 2 * wc + 1 and h >= 2 * hc + 1,\n *          where (w,h) are the dimensions of pixs.\n *      (4) For nx == ny == 1, this defaults to pixBlockconv(), which\n *          is typically about twice as fast, and gives nearly\n *          identical results as pixBlockconvGrayTile().\n *      (5) If the tiles are too small, nx and/or ny are reduced\n *          a minimum amount so that the tiles are expanded to the\n *          smallest workable size in the problematic direction(s).\n *      (6) Why a tiled version?  Three reasons:\n *          (a) Because the accumulator is a uint32, overflow can occur\n *              for an image with more than 16M pixels.\n *          (b) The accumulator array for 16M pixels is 64 MB; using\n *              tiles reduces the size of this array.\n *          (c) Each tile can be processed independently, in parallel,\n *              on a multicore processor.\n * </pre>\n */\nPIX *\npixBlockconvTiled(PIX     *pix,\n                  l_int32  wc,\n                  l_int32  hc,\n                  l_int32  nx,\n                  l_int32  ny)\n{\nl_int32     i, j, w, h, d, xrat, yrat;\nPIX        *pixs, *pixd, *pixc, *pixt;\nPIX        *pixr, *pixrc, *pixg, *pixgc, *pixb, *pixbc;\nPIXTILING  *pt;\n\n    PROCNAME(\"pixBlockconvTiled\");\n\n    if (!pix)\n        return (PIX *)ERROR_PTR(\"pix not defined\", procName, NULL);\n    if (wc < 0) wc = 0;\n    if (hc < 0) hc = 0;\n    pixGetDimensions(pix, &w, &h, &d);\n    if (w < 2 * wc + 3 || h < 2 * hc + 3) {\n        wc = L_MAX(0, L_MIN(wc, (w - 3) / 2));\n        hc = L_MAX(0, L_MIN(hc, (h - 3) / 2));\n        L_WARNING(\"kernel too large; reducing!\\n\", procName);\n        L_INFO(\"wc = %d, hc = %d\\n\", procName, wc, hc);\n    }\n    if (wc == 0 && hc == 0)   /* no-op */\n        return pixCopy(NULL, pix);\n    if (nx <= 1 && ny <= 1)\n        return pixBlockconv(pix, wc, hc);\n\n        /* Test to see if the tiles are too small.  The required\n         * condition is that the tile dimensions must be at least\n         * (wc + 2) x (hc + 2). */\n    xrat = w / nx;\n    yrat = h / ny;\n    if (xrat < wc + 2) {\n        nx = w / (wc + 2);\n        L_WARNING(\"tile width too small; nx reduced to %d\\n\", procName, nx);\n    }\n    if (yrat < hc + 2) {\n        ny = h / (hc + 2);\n        L_WARNING(\"tile height too small; ny reduced to %d\\n\", procName, ny);\n    }\n\n        /* Remove colormap if necessary */\n    if ((d == 2 || d == 4 || d == 8) && pixGetColormap(pix)) {\n        L_WARNING(\"pix has colormap; removing\\n\", procName);\n        pixs = pixRemoveColormap(pix, REMOVE_CMAP_BASED_ON_SRC);\n        d = pixGetDepth(pixs);\n    } else {\n        pixs = pixClone(pix);\n    }\n\n    if (d != 8 && d != 32) {\n        pixDestroy(&pixs);\n        return (PIX *)ERROR_PTR(\"depth not 8 or 32 bpp\", procName, NULL);\n    }\n\n       /* Note that the overlaps in the width and height that\n        * are added to the tile are (wc + 2) and (hc + 2).\n        * These overlaps are removed by pixTilingPaintTile().\n        * They are larger than the extent of the filter because\n        * although the filter is symmetric with respect to its origin,\n        * the implementation is asymmetric -- see the implementation in\n        * pixBlockconvGrayTile(). */\n    if ((pixd = pixCreateTemplate(pixs)) == NULL) {\n        pixDestroy(&pixs);\n        return (PIX *)ERROR_PTR(\"pixd not made\", procName, NULL);\n    }\n    pt = pixTilingCreate(pixs, nx, ny, 0, 0, wc + 2, hc + 2);\n    for (i = 0; i < ny; i++) {\n        for (j = 0; j < nx; j++) {\n            pixt = pixTilingGetTile(pt, i, j);\n\n                /* Convolve over the tile */\n            if (d == 8) {\n                pixc = pixBlockconvGrayTile(pixt, NULL, wc, hc);\n            } else { /* d == 32 */\n                pixr = pixGetRGBComponent(pixt, COLOR_RED);\n                pixrc = pixBlockconvGrayTile(pixr, NULL, wc, hc);\n                pixDestroy(&pixr);\n                pixg = pixGetRGBComponent(pixt, COLOR_GREEN);\n                pixgc = pixBlockconvGrayTile(pixg, NULL, wc, hc);\n                pixDestroy(&pixg);\n                pixb = pixGetRGBComponent(pixt, COLOR_BLUE);\n                pixbc = pixBlockconvGrayTile(pixb, NULL, wc, hc);\n                pixDestroy(&pixb);\n                pixc = pixCreateRGBImage(pixrc, pixgc, pixbc);\n                pixDestroy(&pixrc);\n                pixDestroy(&pixgc);\n                pixDestroy(&pixbc);\n            }\n\n            pixTilingPaintTile(pixd, i, j, pixc, pt);\n            pixDestroy(&pixt);\n            pixDestroy(&pixc);\n        }\n    }\n\n    pixDestroy(&pixs);\n    pixTilingDestroy(&pt);\n    return pixd;\n}\n\n\n/*!\n * \\brief   pixBlockconvGrayTile()\n *\n * \\param[in]    pixs     8 bpp gray\n * \\param[in]    pixacc   32 bpp accum pix\n * \\param[in]    wc, hc   half width/height of convolution kernel\n * \\return  pixd, or NULL on error\n *\n * <pre>\n * Notes:\n *      (1) The full width and height of the convolution kernel\n *          are (2 * wc + 1) and (2 * hc + 1)\n *      (2) Assumes that the input pixs is padded with (wc + 1) pixels on\n *          left and right, and with (hc + 1) pixels on top and bottom.\n *          The returned pix has these stripped off; they are only used\n *          for computation.\n *      (3) Returns a copy if both wc and hc are 0\n *      (4) Require that w > 2 * wc + 1 and h > 2 * hc + 1,\n *          where (w,h) are the dimensions of pixs.\n * </pre>\n */\nPIX *\npixBlockconvGrayTile(PIX     *pixs,\n                     PIX     *pixacc,\n                     l_int32  wc,\n                     l_int32  hc)\n{\nl_int32    w, h, d, wd, hd, i, j, imin, imax, jmin, jmax, wplt, wpld;\nl_float32  norm;\nl_uint32   val;\nl_uint32  *datat, *datad, *lined, *linemint, *linemaxt;\nPIX       *pixt, *pixd;\n\n    PROCNAME(\"pixBlockconvGrayTile\");\n\n    if (!pixs)\n        return (PIX *)ERROR_PTR(\"pix not defined\", procName, NULL);\n    pixGetDimensions(pixs, &w, &h, &d);\n    if (d != 8)\n        return (PIX *)ERROR_PTR(\"pixs not 8 bpp\", procName, NULL);\n    if (wc < 0) wc = 0;\n    if (hc < 0) hc = 0;\n    if (w < 2 * wc + 3 || h < 2 * hc + 3) {\n        wc = L_MAX(0, L_MIN(wc, (w - 3) / 2));\n        hc = L_MAX(0, L_MIN(hc, (h - 3) / 2));\n        L_WARNING(\"kernel too large; reducing!\\n\", procName);\n        L_INFO(\"wc = %d, hc = %d\\n\", procName, wc, hc);\n    }\n    if (wc == 0 && hc == 0)\n        return pixCopy(NULL, pixs);\n    wd = w - 2 * wc;\n    hd = h - 2 * hc;\n\n    if (pixacc) {\n        if (pixGetDepth(pixacc) == 32) {\n            pixt = pixClone(pixacc);\n        } else {\n            L_WARNING(\"pixacc not 32 bpp; making new one\\n\", procName);\n            if ((pixt = pixBlockconvAccum(pixs)) == NULL)\n                return (PIX *)ERROR_PTR(\"pixt not made\", procName, NULL);\n        }\n    } else {\n        if ((pixt = pixBlockconvAccum(pixs)) == NULL)\n            return (PIX *)ERROR_PTR(\"pixt not made\", procName, NULL);\n    }\n\n    if ((pixd = pixCreateTemplate(pixs)) == NULL) {\n        pixDestroy(&pixt);\n        return (PIX *)ERROR_PTR(\"pixd not made\", procName, NULL);\n    }\n    datat = pixGetData(pixt);\n    wplt = pixGetWpl(pixt);\n    datad = pixGetData(pixd);\n    wpld = pixGetWpl(pixd);\n    norm = 1. / (l_float32)((2 * wc + 1) * (2 * hc + 1));\n\n        /* Do the convolution over the subregion of size (wd - 2, hd - 2),\n         * which exactly corresponds to the size of the subregion that\n         * will be extracted by pixTilingPaintTile().  Note that the\n         * region in which points are computed is not symmetric about\n         * the center of the images; instead the computation in\n         * the accumulator image is shifted up and to the left by 1,\n         * relative to the center, because the 4 accumulator sampling\n         * points are taken at the LL corner of the filter and at 3 other\n         * points that are shifted -wc and -hc to the left and above.  */\n    for (i = hc; i < hc + hd - 2; i++) {\n        imin = L_MAX(i - hc - 1, 0);\n        imax = L_MIN(i + hc, h - 1);\n        lined = datad + i * wpld;\n        linemint = datat + imin * wplt;\n        linemaxt = datat + imax * wplt;\n        for (j = wc; j < wc + wd - 2; j++) {\n            jmin = L_MAX(j - wc - 1, 0);\n            jmax = L_MIN(j + wc, w - 1);\n            val = linemaxt[jmax] - linemaxt[jmin]\n                  + linemint[jmin] - linemint[jmax];\n            val = (l_uint8)(norm * val + 0.5);\n            SET_DATA_BYTE(lined, j, val);\n        }\n    }\n\n    pixDestroy(&pixt);\n    return pixd;\n}\n\n\n/*----------------------------------------------------------------------*\n *     Convolution for mean, mean square, variance and rms deviation    *\n *----------------------------------------------------------------------*/\n/*!\n * \\brief   pixWindowedStats()\n *\n * \\param[in]    pixs        8 bpp grayscale\n * \\param[in]    wc, hc      half width/height of convolution kernel\n * \\param[in]    hasborder   use 1 if it already has (wc + 1 border pixels\n *                           on left and right, and hc + 1 on top and bottom;\n *                           use 0 to add kernel-dependent border)\n * \\param[out]   ppixm       [optional] 8 bpp mean value in window\n * \\param[out]   ppixms      [optional] 32 bpp mean square value in window\n * \\param[out]   pfpixv      [optional] float variance in window\n * \\param[out]   pfpixrv     [optional] float rms deviation from the mean\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *      (1) This is a high-level convenience function for calculating\n *          any or all of these derived images.\n *      (2) If %hasborder = 0, a border is added and the result is\n *          computed over all pixels in pixs.  Otherwise, no border is\n *          added and the border pixels are removed from the output images.\n *      (3) These statistical measures over the pixels in the\n *          rectangular window are:\n *            ~ average value: <p>  (pixm)\n *            ~ average squared value: <p*p> (pixms)\n *            ~ variance: <(p - <p>)*(p - <p>)> = <p*p> - <p>*<p>  (pixv)\n *            ~ square-root of variance: (pixrv)\n *          where the brackets < .. > indicate that the average value is\n *          to be taken over the window.\n *      (4) Note that the variance is just the mean square difference from\n *          the mean value; and the square root of the variance is the\n *          root mean square difference from the mean, sometimes also\n *          called the 'standard deviation'.\n *      (5) The added border, along with the use of an accumulator array,\n *          allows computation without special treatment of pixels near\n *          the image boundary, and runs in a time that is independent\n *          of the size of the convolution kernel.\n * </pre>\n */\nl_ok\npixWindowedStats(PIX     *pixs,\n                 l_int32  wc,\n                 l_int32  hc,\n                 l_int32  hasborder,\n                 PIX    **ppixm,\n                 PIX    **ppixms,\n                 FPIX   **pfpixv,\n                 FPIX   **pfpixrv)\n{\nPIX  *pixb, *pixm, *pixms;\n\n    PROCNAME(\"pixWindowedStats\");\n\n    if (!ppixm && !ppixms && !pfpixv && !pfpixrv)\n        return ERROR_INT(\"no output requested\", procName, 1);\n    if (ppixm) *ppixm = NULL;\n    if (ppixms) *ppixms = NULL;\n    if (pfpixv) *pfpixv = NULL;\n    if (pfpixrv) *pfpixrv = NULL;\n    if (!pixs || pixGetDepth(pixs) != 8)\n        return ERROR_INT(\"pixs not defined or not 8 bpp\", procName, 1);\n    if (wc < 2 || hc < 2)\n        return ERROR_INT(\"wc and hc not >= 2\", procName, 1);\n\n        /* Add border if requested */\n    if (!hasborder)\n        pixb = pixAddBorderGeneral(pixs, wc + 1, wc + 1, hc + 1, hc + 1, 0);\n    else\n        pixb = pixClone(pixs);\n\n    if (!pfpixv && !pfpixrv) {\n        if (ppixm) *ppixm = pixWindowedMean(pixb, wc, hc, 1, 1);\n        if (ppixms) *ppixms = pixWindowedMeanSquare(pixb, wc, hc, 1);\n        pixDestroy(&pixb);\n        return 0;\n    }\n\n    pixm = pixWindowedMean(pixb, wc, hc, 1, 1);\n    pixms = pixWindowedMeanSquare(pixb, wc, hc, 1);\n    pixWindowedVariance(pixm, pixms, pfpixv, pfpixrv);\n    if (ppixm)\n        *ppixm = pixm;\n    else\n        pixDestroy(&pixm);\n    if (ppixms)\n        *ppixms = pixms;\n    else\n        pixDestroy(&pixms);\n    pixDestroy(&pixb);\n    return 0;\n}\n\n\n/*!\n * \\brief   pixWindowedMean()\n *\n * \\param[in]    pixs        8 or 32 bpp grayscale\n * \\param[in]    wc, hc      half width/height of convolution kernel\n * \\param[in]    hasborder   use 1 if it already has (wc + 1 border pixels\n *                           on left and right, and hc + 1 on top and bottom;\n *                           use 0 to add kernel-dependent border)\n * \\param[in]    normflag    1 for normalization to get average in window;\n *                           0 for the sum in the window (un-normalized)\n * \\return  pixd 8 or 32 bpp, average over kernel window\n *\n * <pre>\n * Notes:\n *      (1) The input and output depths are the same.\n *      (2) A set of border pixels of width (wc + 1) on left and right,\n *          and of height (hc + 1) on top and bottom, must be on the\n *          pix before the accumulator is found.  The output pixd\n *          (after convolution) has this border removed.\n *          If %hasborder = 0, the required border is added.\n *      (3) Typically, %normflag == 1.  However, if you want the sum\n *          within the window, rather than a normalized convolution,\n *          use %normflag == 0.\n *      (4) This builds a block accumulator pix, uses it here, and\n *          destroys it.\n *      (5) The added border, along with the use of an accumulator array,\n *          allows computation without special treatment of pixels near\n *          the image boundary, and runs in a time that is independent\n *          of the size of the convolution kernel.\n * </pre>\n */\nPIX *\npixWindowedMean(PIX     *pixs,\n                l_int32  wc,\n                l_int32  hc,\n                l_int32  hasborder,\n                l_int32  normflag)\n{\nl_int32    i, j, w, h, d, wd, hd, wplc, wpld, wincr, hincr;\nl_uint32   val;\nl_uint32  *datac, *datad, *linec1, *linec2, *lined;\nl_float32  norm;\nPIX       *pixb, *pixc, *pixd;\n\n    PROCNAME(\"pixWindowedMean\");\n\n    if (!pixs)\n        return (PIX *)ERROR_PTR(\"pixs not defined\", procName, NULL);\n    d = pixGetDepth(pixs);\n    if (d != 8 && d != 32)\n        return (PIX *)ERROR_PTR(\"pixs not 8 or 32 bpp\", procName, NULL);\n    if (wc < 2 || hc < 2)\n        return (PIX *)ERROR_PTR(\"wc and hc not >= 2\", procName, NULL);\n\n    pixb = pixc = pixd = NULL;\n\n        /* Add border if requested */\n    if (!hasborder)\n        pixb = pixAddBorderGeneral(pixs, wc + 1, wc + 1, hc + 1, hc + 1, 0);\n    else\n        pixb = pixClone(pixs);\n\n        /* Make the accumulator pix from pixb */\n    if ((pixc = pixBlockconvAccum(pixb)) == NULL) {\n        L_ERROR(\"pixc not made\\n\", procName);\n        goto cleanup;\n    }\n    wplc = pixGetWpl(pixc);\n    datac = pixGetData(pixc);\n\n        /* The output has wc + 1 border pixels stripped from each side\n         * of pixb, and hc + 1 border pixels stripped from top and bottom. */\n    pixGetDimensions(pixb, &w, &h, NULL);\n    wd = w - 2 * (wc + 1);\n    hd = h - 2 * (hc + 1);\n    if (wd < 2 || hd < 2) {\n        L_ERROR(\"w or h is too small for the kernel\\n\", procName);\n        goto cleanup;\n    }\n    if ((pixd = pixCreate(wd, hd, d)) == NULL) {\n        L_ERROR(\"pixd not made\\n\", procName);\n        goto cleanup;\n    }\n    wpld = pixGetWpl(pixd);\n    datad = pixGetData(pixd);\n\n    wincr = 2 * wc + 1;\n    hincr = 2 * hc + 1;\n    norm = 1.0;  /* use this for sum-in-window */\n    if (normflag)\n        norm = 1.0 / ((l_float32)(wincr) * hincr);\n    for (i = 0; i < hd; i++) {\n        linec1 = datac + i * wplc;\n        linec2 = datac + (i + hincr) * wplc;\n        lined = datad + i * wpld;\n        for (j = 0; j < wd; j++) {\n            val = linec2[j + wincr] - linec2[j] - linec1[j + wincr] + linec1[j];\n            if (d == 8) {\n                val = (l_uint8)(norm * val);\n                SET_DATA_BYTE(lined, j, val);\n            } else {  /* d == 32 */\n                val = (l_uint32)(norm * val);\n                lined[j] = val;\n            }\n        }\n    }\n\ncleanup:\n    pixDestroy(&pixb);\n    pixDestroy(&pixc);\n    return pixd;\n}\n\n\n/*!\n * \\brief   pixWindowedMeanSquare()\n *\n * \\param[in]    pixs        8 bpp grayscale\n * \\param[in]    wc, hc      half width/height of convolution kernel\n * \\param[in]    hasborder   use 1 if it already has (wc + 1 border pixels\n *                           on left and right, and hc + 1 on top and bottom;\n *                           use 0 to add kernel-dependent border)\n * \\return  pixd    32 bpp, average over rectangular window of\n *                  width = 2 * wc + 1 and height = 2 * hc + 1\n *\n * <pre>\n * Notes:\n *      (1) A set of border pixels of width (wc + 1) on left and right,\n *          and of height (hc + 1) on top and bottom, must be on the\n *          pix before the accumulator is found.  The output pixd\n *          (after convolution) has this border removed.\n *          If %hasborder = 0, the required border is added.\n *      (2) The advantage is that we are unaffected by the boundary, and\n *          it is not necessary to treat pixels within %wc and %hc of the\n *          border differently.  This is because processing for pixd\n *          only takes place for pixels in pixs for which the\n *          kernel is entirely contained in pixs.\n *      (3) Why do we have an added border of width (%wc + 1) and\n *          height (%hc + 1), when we only need %wc and %hc pixels\n *          to satisfy this condition?  Answer: the accumulators\n *          are asymmetric, requiring an extra row and column of\n *          pixels at top and left to work accurately.\n *      (4) The added border, along with the use of an accumulator array,\n *          allows computation without special treatment of pixels near\n *          the image boundary, and runs in a time that is independent\n *          of the size of the convolution kernel.\n * </pre>\n */\nPIX *\npixWindowedMeanSquare(PIX     *pixs,\n                      l_int32  wc,\n                      l_int32  hc,\n                      l_int32  hasborder)\n{\nl_int32     i, j, w, h, wd, hd, wpl, wpld, wincr, hincr;\nl_uint32    ival;\nl_uint32   *datad, *lined;\nl_float64   norm;\nl_float64   val;\nl_float64  *data, *line1, *line2;\nDPIX       *dpix;\nPIX        *pixb, *pixd;\n\n    PROCNAME(\"pixWindowedMeanSquare\");\n\n    if (!pixs || (pixGetDepth(pixs) != 8))\n        return (PIX *)ERROR_PTR(\"pixs undefined or not 8 bpp\", procName, NULL);\n    if (wc < 2 || hc < 2)\n        return (PIX *)ERROR_PTR(\"wc and hc not >= 2\", procName, NULL);\n\n    pixd = NULL;\n\n        /* Add border if requested */\n    if (!hasborder)\n        pixb = pixAddBorderGeneral(pixs, wc + 1, wc + 1, hc + 1, hc + 1, 0);\n    else\n        pixb = pixClone(pixs);\n\n    if ((dpix = pixMeanSquareAccum(pixb)) == NULL) {\n        L_ERROR(\"dpix not made\\n\", procName);\n        goto cleanup;\n    }\n    wpl = dpixGetWpl(dpix);\n    data = dpixGetData(dpix);\n\n        /* The output has wc + 1 border pixels stripped from each side\n         * of pixb, and hc + 1 border pixels stripped from top and bottom. */\n    pixGetDimensions(pixb, &w, &h, NULL);\n    wd = w - 2 * (wc + 1);\n    hd = h - 2 * (hc + 1);\n    if (wd < 2 || hd < 2) {\n        L_ERROR(\"w or h too small for kernel\\n\", procName);\n        goto cleanup;\n    }\n    if ((pixd = pixCreate(wd, hd, 32)) == NULL) {\n        L_ERROR(\"pixd not made\\n\", procName);\n        goto cleanup;\n    }\n    wpld = pixGetWpl(pixd);\n    datad = pixGetData(pixd);\n\n    wincr = 2 * wc + 1;\n    hincr = 2 * hc + 1;\n    norm = 1.0 / ((l_float32)(wincr) * hincr);\n    for (i = 0; i < hd; i++) {\n        line1 = data + i * wpl;\n        line2 = data + (i + hincr) * wpl;\n        lined = datad + i * wpld;\n        for (j = 0; j < wd; j++) {\n            val = line2[j + wincr] - line2[j] - line1[j + wincr] + line1[j];\n            ival = (l_uint32)(norm * val + 0.5);  /* to round up */\n            lined[j] = ival;\n        }\n    }\n\ncleanup:\n    dpixDestroy(&dpix);\n    pixDestroy(&pixb);\n    return pixd;\n}\n\n\n/*!\n * \\brief   pixWindowedVariance()\n *\n * \\param[in]    pixm      mean over window; 8 or 32 bpp grayscale\n * \\param[in]    pixms     mean square over window; 32 bpp\n * \\param[out]   pfpixv    [optional] float variance -- the ms deviation\n *                         from the mean\n * \\param[out]   pfpixrv   [optional] float rms deviation from the mean\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *      (1) The mean and mean square values are precomputed, using\n *          pixWindowedMean() and pixWindowedMeanSquare().\n *      (2) Either or both of the variance and square-root of variance\n *          are returned as an fpix, where the variance is the\n *          average over the window of the mean square difference of\n *          the pixel value from the mean:\n *                <(p - <p>)*(p - <p>)> = <p*p> - <p>*<p>\n *      (3) To visualize the results:\n *            ~ for both, use fpixDisplayMaxDynamicRange().\n *            ~ for rms deviation, simply convert the output fpix to pix,\n * </pre>\n */\nl_ok\npixWindowedVariance(PIX    *pixm,\n                    PIX    *pixms,\n                    FPIX  **pfpixv,\n                    FPIX  **pfpixrv)\n{\nl_int32     i, j, w, h, ws, hs, ds, wplm, wplms, wplv, wplrv, valm, valms;\nl_float32   var;\nl_uint32   *linem, *linems, *datam, *datams;\nl_float32  *linev, *linerv, *datav, *datarv;\nFPIX       *fpixv, *fpixrv;  /* variance and square root of variance */\n\n    PROCNAME(\"pixWindowedVariance\");\n\n    if (!pfpixv && !pfpixrv)\n        return ERROR_INT(\"no output requested\", procName, 1);\n    if (pfpixv) *pfpixv = NULL;\n    if (pfpixrv) *pfpixrv = NULL;\n    if (!pixm || pixGetDepth(pixm) != 8)\n        return ERROR_INT(\"pixm undefined or not 8 bpp\", procName, 1);\n    if (!pixms || pixGetDepth(pixms) != 32)\n        return ERROR_INT(\"pixms undefined or not 32 bpp\", procName, 1);\n    pixGetDimensions(pixm, &w, &h, NULL);\n    pixGetDimensions(pixms, &ws, &hs, &ds);\n    if (w != ws || h != hs)\n        return ERROR_INT(\"pixm and pixms sizes differ\", procName, 1);\n\n    if (pfpixv) {\n        fpixv = fpixCreate(w, h);\n        *pfpixv = fpixv;\n        wplv = fpixGetWpl(fpixv);\n        datav = fpixGetData(fpixv);\n    }\n    if (pfpixrv) {\n        fpixrv = fpixCreate(w, h);\n        *pfpixrv = fpixrv;\n        wplrv = fpixGetWpl(fpixrv);\n        datarv = fpixGetData(fpixrv);\n    }\n\n    wplm = pixGetWpl(pixm);\n    wplms = pixGetWpl(pixms);\n    datam = pixGetData(pixm);\n    datams = pixGetData(pixms);\n    for (i = 0; i < h; i++) {\n        linem = datam + i * wplm;\n        linems = datams + i * wplms;\n        if (pfpixv)\n            linev = datav + i * wplv;\n        if (pfpixrv)\n            linerv = datarv + i * wplrv;\n        for (j = 0; j < w; j++) {\n            valm = GET_DATA_BYTE(linem, j);\n            if (ds == 8)\n                valms = GET_DATA_BYTE(linems, j);\n            else  /* ds == 32 */\n                valms = (l_int32)linems[j];\n            var = (l_float32)valms - (l_float32)valm * valm;\n            if (pfpixv)\n                linev[j] = var;\n            if (pfpixrv)\n                linerv[j] = (l_float32)sqrt(var);\n        }\n    }\n\n    return 0;\n}\n\n\n/*!\n * \\brief   pixMeanSquareAccum()\n *\n * \\param[in]    pixs    8 bpp grayscale\n * \\return  dpix   64 bit array, or NULL on error\n *\n * <pre>\n * Notes:\n *      (1) Similar to pixBlockconvAccum(), this computes the\n *          sum of the squares of the pixel values in such a way\n *          that the value at (i,j) is the sum of all squares in\n *          the rectangle from the origin to (i,j).\n *      (2) The general recursion relation (v are squared pixel values) is\n *            a(i,j) = v(i,j) + a(i-1, j) + a(i, j-1) - a(i-1, j-1)\n *          For the first line, this reduces to the special case\n *            a(i,j) = v(i,j) + a(i, j-1)\n *          For the first column, the special case is\n *            a(i,j) = v(i,j) + a(i-1, j)\n * </pre>\n */\nDPIX *\npixMeanSquareAccum(PIX  *pixs)\n{\nl_int32     i, j, w, h, wpl, wpls, val;\nl_uint32   *datas, *lines;\nl_float64  *data, *line, *linep;\nDPIX       *dpix;\n\n    PROCNAME(\"pixMeanSquareAccum\");\n\n\n    if (!pixs || (pixGetDepth(pixs) != 8))\n        return (DPIX *)ERROR_PTR(\"pixs undefined or not 8 bpp\", procName, NULL);\n    pixGetDimensions(pixs, &w, &h, NULL);\n    if ((dpix = dpixCreate(w, h)) ==  NULL)\n        return (DPIX *)ERROR_PTR(\"dpix not made\", procName, NULL);\n\n    datas = pixGetData(pixs);\n    wpls = pixGetWpl(pixs);\n    data = dpixGetData(dpix);\n    wpl = dpixGetWpl(dpix);\n\n    lines = datas;\n    line = data;\n    for (j = 0; j < w; j++) {   /* first line */\n        val = GET_DATA_BYTE(lines, j);\n        if (j == 0)\n            line[0] = (l_float64)(val) * val;\n        else\n            line[j] = line[j - 1] + (l_float64)(val) * val;\n    }\n\n        /* Do the other lines */\n    for (i = 1; i < h; i++) {\n        lines = datas + i * wpls;\n        line = data + i * wpl;  /* current dest line */\n        linep = line - wpl;;  /* prev dest line */\n        for (j = 0; j < w; j++) {\n            val = GET_DATA_BYTE(lines, j);\n            if (j == 0)\n                line[0] = linep[0] + (l_float64)(val) * val;\n            else\n                line[j] = line[j - 1] + linep[j] - linep[j - 1]\n                        + (l_float64)(val) * val;\n        }\n    }\n\n    return dpix;\n}\n\n\n/*----------------------------------------------------------------------*\n *                        Binary block sum/rank                         *\n *----------------------------------------------------------------------*/\n/*!\n * \\brief   pixBlockrank()\n *\n * \\param[in]    pixs     1 bpp\n * \\param[in]    pixacc   pix [optional] 32 bpp\n * \\param[in]    wc, hc   half width/height of block sum/rank kernel\n * \\param[in]    rank     between 0.0 and 1.0; 0.5 is median filter\n * \\return  pixd 1 bpp\n *\n * <pre>\n * Notes:\n *      (1) The full width and height of the convolution kernel\n *          are (2 * wc + 1) and (2 * hc + 1)\n *      (2) This returns a pixd where each pixel is a 1 if the\n *          neighborhood (2 * wc + 1) x (2 * hc + 1)) pixels\n *          contains the rank fraction of 1 pixels.  Otherwise,\n *          the returned pixel is 0.  Note that the special case\n *          of rank = 0.0 is always satisfied, so the returned\n *          pixd has all pixels with value 1.\n *      (3) If accum pix is null, make one, use it, and destroy it\n *          before returning; otherwise, just use the input accum pix\n *      (4) If both wc and hc are 0, returns a copy unless rank == 0.0,\n *          in which case this returns an all-ones image.\n *      (5) Require that w >= 2 * wc + 1 and h >= 2 * hc + 1,\n *          where (w,h) are the dimensions of pixs.\n * </pre>\n */\nPIX *\npixBlockrank(PIX       *pixs,\n             PIX       *pixacc,\n             l_int32    wc,\n             l_int32    hc,\n             l_float32  rank)\n{\nl_int32  w, h, d, thresh;\nPIX     *pixt, *pixd;\n\n    PROCNAME(\"pixBlockrank\");\n\n    if (!pixs)\n        return (PIX *)ERROR_PTR(\"pixs not defined\", procName, NULL);\n    pixGetDimensions(pixs, &w, &h, &d);\n    if (d != 1)\n        return (PIX *)ERROR_PTR(\"pixs not 1 bpp\", procName, NULL);\n    if (rank < 0.0 || rank > 1.0)\n        return (PIX *)ERROR_PTR(\"rank must be in [0.0, 1.0]\", procName, NULL);\n\n    if (rank == 0.0) {\n        pixd = pixCreateTemplate(pixs);\n        pixSetAll(pixd);\n        return pixd;\n    }\n\n    if (wc < 0) wc = 0;\n    if (hc < 0) hc = 0;\n    if (w < 2 * wc + 1 || h < 2 * hc + 1) {\n        wc = L_MIN(wc, (w - 1) / 2);\n        hc = L_MIN(hc, (h - 1) / 2);\n        L_WARNING(\"kernel too large; reducing!\\n\", procName);\n        L_INFO(\"wc = %d, hc = %d\\n\", procName, wc, hc);\n    }\n    if (wc == 0 && hc == 0)\n        return pixCopy(NULL, pixs);\n\n    if ((pixt = pixBlocksum(pixs, pixacc, wc, hc)) == NULL)\n        return (PIX *)ERROR_PTR(\"pixt not made\", procName, NULL);\n\n        /* 1 bpp block rank filter output.\n         * Must invert because threshold gives 1 for values < thresh,\n         * but we need a 1 if the value is >= thresh. */\n    thresh = (l_int32)(255. * rank);\n    pixd = pixThresholdToBinary(pixt, thresh);\n    pixInvert(pixd, pixd);\n    pixDestroy(&pixt);\n    return pixd;\n}\n\n\n/*!\n * \\brief   pixBlocksum()\n *\n * \\param[in]    pixs     1 bpp\n * \\param[in]    pixacc   pix [optional] 32 bpp\n * \\param[in]    wc, hc   half width/height of block sum/rank kernel\n * \\return  pixd 8 bpp\n *\n * <pre>\n * Notes:\n *      (1) If accum pix is null, make one and destroy it before\n *          returning; otherwise, just use the input accum pix\n *      (2) The full width and height of the convolution kernel\n *          are (2 * wc + 1) and (2 * hc + 1)\n *      (3) Use of wc = hc = 1, followed by pixInvert() on the\n *          8 bpp result, gives a nice anti-aliased, and somewhat\n *          darkened, result on text.\n *      (4) Require that w >= 2 * wc + 1 and h >= 2 * hc + 1,\n *          where (w,h) are the dimensions of pixs.\n *      (5) Returns in each dest pixel the sum of all src pixels\n *          that are within a block of size of the kernel, centered\n *          on the dest pixel.  This sum is the number of src ON\n *          pixels in the block at each location, normalized to 255\n *          for a block containing all ON pixels.  For pixels near\n *          the boundary, where the block is not entirely contained\n *          within the image, we then multiply by a second normalization\n *          factor that is greater than one, so that all results\n *          are normalized by the number of participating pixels\n *          within the block.\n * </pre>\n */\nPIX *\npixBlocksum(PIX     *pixs,\n            PIX     *pixacc,\n            l_int32  wc,\n            l_int32  hc)\n{\nl_int32    w, h, d, wplt, wpld;\nl_uint32  *datat, *datad;\nPIX       *pixt, *pixd;\n\n    PROCNAME(\"pixBlocksum\");\n\n    if (!pixs)\n        return (PIX *)ERROR_PTR(\"pixs not defined\", procName, NULL);\n    pixGetDimensions(pixs, &w, &h, &d);\n    if (d != 1)\n        return (PIX *)ERROR_PTR(\"pixs not 1 bpp\", procName, NULL);\n    if (wc < 0) wc = 0;\n    if (hc < 0) hc = 0;\n    if (w < 2 * wc + 1 || h < 2 * hc + 1) {\n        wc = L_MIN(wc, (w - 1) / 2);\n        hc = L_MIN(hc, (h - 1) / 2);\n        L_WARNING(\"kernel too large; reducing!\\n\", procName);\n        L_INFO(\"wc = %d, hc = %d\\n\", procName, wc, hc);\n    }\n    if (wc == 0 && hc == 0)\n        return pixCopy(NULL, pixs);\n\n    if (pixacc) {\n        if (pixGetDepth(pixacc) != 32)\n            return (PIX *)ERROR_PTR(\"pixacc not 32 bpp\", procName, NULL);\n        pixt = pixClone(pixacc);\n    } else {\n        if ((pixt = pixBlockconvAccum(pixs)) == NULL)\n            return (PIX *)ERROR_PTR(\"pixt not made\", procName, NULL);\n    }\n\n        /* 8 bpp block sum output */\n    if ((pixd = pixCreate(w, h, 8)) == NULL) {\n        pixDestroy(&pixt);\n        return (PIX *)ERROR_PTR(\"pixd not made\", procName, NULL);\n    }\n    pixCopyResolution(pixd, pixs);\n\n    wpld = pixGetWpl(pixd);\n    wplt = pixGetWpl(pixt);\n    datad = pixGetData(pixd);\n    datat = pixGetData(pixt);\n    blocksumLow(datad, w, h, wpld, datat, wplt, wc, hc);\n\n    pixDestroy(&pixt);\n    return pixd;\n}\n\n\n/*!\n * \\brief   blocksumLow()\n *\n * \\param[in]    datad        of 8 bpp dest\n * \\param[in]    w, h, wpl    of 8 bpp dest\n * \\param[in]    dataa        of 32 bpp accum\n * \\param[in]    wpla         of 32 bpp accum\n * \\param[in]    wc, hc       convolution \"half-width\" and \"half-height\"\n * \\return  void\n *\n * <pre>\n * Notes:\n *      (1) The full width and height of the convolution kernel\n *          are (2 * wc + 1) and (2 * hc + 1).\n *      (2) The lack of symmetry between the handling of the\n *          first (hc + 1) lines and the last (hc) lines,\n *          and similarly with the columns, is due to fact that\n *          for the pixel at (x,y), the accumulator values are\n *          taken at (x + wc, y + hc), (x - wc - 1, y + hc),\n *          (x + wc, y - hc - 1) and (x - wc - 1, y - hc - 1).\n *      (3) Compute sums of ON pixels within the block filter size,\n *          normalized between 0 and 255, as if there were no reduced\n *          area at the boundary.  This under-estimates the value\n *          of the boundary pixels, so we multiply them by another\n *          normalization factor that is greater than 1.\n *      (4) This second normalization is done first for the first\n *          hc + 1 lines; then for the last hc lines; and finally\n *          for the first wc + 1 and last wc columns in the intermediate\n *          lines.\n *      (5) Required constraints are: wc < w and hc < h.\n * </pre>\n */\nstatic void\nblocksumLow(l_uint32  *datad,\n            l_int32    w,\n            l_int32    h,\n            l_int32    wpl,\n            l_uint32  *dataa,\n            l_int32    wpla,\n            l_int32    wc,\n            l_int32    hc)\n{\nl_int32    i, j, imax, imin, jmax, jmin;\nl_int32    wn, hn, fwc, fhc, wmwc, hmhc;\nl_float32  norm, normh, normw;\nl_uint32   val;\nl_uint32  *linemina, *linemaxa, *lined;\n\n    PROCNAME(\"blocksumLow\");\n\n    wmwc = w - wc;\n    hmhc = h - hc;\n    if (wmwc <= 0 || hmhc <= 0) {\n        L_ERROR(\"wc >= w || hc >=h\\n\", procName);\n        return;\n    }\n    fwc = 2 * wc + 1;\n    fhc = 2 * hc + 1;\n    norm = 255. / ((l_float32)(fwc) * fhc);\n\n        /*------------------------------------------------------------*\n         *  Compute, using b.c. only to set limits on the accum image *\n         *------------------------------------------------------------*/\n    for (i = 0; i < h; i++) {\n        imin = L_MAX(i - 1 - hc, 0);\n        imax = L_MIN(i + hc, h - 1);\n        lined = datad + wpl * i;\n        linemina = dataa + wpla * imin;\n        linemaxa = dataa + wpla * imax;\n        for (j = 0; j < w; j++) {\n            jmin = L_MAX(j - 1 - wc, 0);\n            jmax = L_MIN(j + wc, w - 1);\n            val = linemaxa[jmax] - linemaxa[jmin]\n                  - linemina[jmax] + linemina[jmin];\n            val = (l_uint8)(norm * val);\n            SET_DATA_BYTE(lined, j, val);\n        }\n    }\n\n        /*------------------------------------------------------------*\n         *             Fix normalization for boundary pixels          *\n         *------------------------------------------------------------*/\n    for (i = 0; i <= hc; i++) {    /* first hc + 1 lines */\n        hn = hc + i;\n        normh = (l_float32)fhc / (l_float32)hn;   /* > 1 */\n        lined = datad + wpl * i;\n        for (j = 0; j <= wc; j++) {\n            wn = wc + j;\n            normw = (l_float32)fwc / (l_float32)wn;   /* > 1 */\n            val = GET_DATA_BYTE(lined, j);\n            val = (l_uint8)(val * normh * normw);\n            SET_DATA_BYTE(lined, j, val);\n        }\n        for (j = wc + 1; j < wmwc; j++) {\n            val = GET_DATA_BYTE(lined, j);\n            val = (l_uint8)(val * normh);\n            SET_DATA_BYTE(lined, j, val);\n        }\n        for (j = wmwc; j < w; j++) {\n            wn = wc + w - j;\n            normw = (l_float32)fwc / (l_float32)wn;   /* > 1 */\n            val = GET_DATA_BYTE(lined, j);\n            val = (l_uint8)(val * normh * normw);\n            SET_DATA_BYTE(lined, j, val);\n        }\n    }\n\n    for (i = hmhc; i < h; i++) {  /* last hc lines */\n        hn = hc + h - i;\n        normh = (l_float32)fhc / (l_float32)hn;   /* > 1 */\n        lined = datad + wpl * i;\n        for (j = 0; j <= wc; j++) {\n            wn = wc + j;\n            normw = (l_float32)fwc / (l_float32)wn;   /* > 1 */\n            val = GET_DATA_BYTE(lined, j);\n            val = (l_uint8)(val * normh * normw);\n            SET_DATA_BYTE(lined, j, val);\n        }\n        for (j = wc + 1; j < wmwc; j++) {\n            val = GET_DATA_BYTE(lined, j);\n            val = (l_uint8)(val * normh);\n            SET_DATA_BYTE(lined, j, val);\n        }\n        for (j = wmwc; j < w; j++) {\n            wn = wc + w - j;\n            normw = (l_float32)fwc / (l_float32)wn;   /* > 1 */\n            val = GET_DATA_BYTE(lined, j);\n            val = (l_uint8)(val * normh * normw);\n            SET_DATA_BYTE(lined, j, val);\n        }\n    }\n\n    for (i = hc + 1; i < hmhc; i++) {    /* intermediate lines */\n        lined = datad + wpl * i;\n        for (j = 0; j <= wc; j++) {   /* first wc + 1 columns */\n            wn = wc + j;\n            normw = (l_float32)fwc / (l_float32)wn;   /* > 1 */\n            val = GET_DATA_BYTE(lined, j);\n            val = (l_uint8)(val * normw);\n            SET_DATA_BYTE(lined, j, val);\n        }\n        for (j = wmwc; j < w; j++) {   /* last wc columns */\n            wn = wc + w - j;\n            normw = (l_float32)fwc / (l_float32)wn;   /* > 1 */\n            val = GET_DATA_BYTE(lined, j);\n            val = (l_uint8)(val * normw);\n            SET_DATA_BYTE(lined, j, val);\n        }\n    }\n}\n\n\n/*----------------------------------------------------------------------*\n *                          Census transform                            *\n *----------------------------------------------------------------------*/\n/*!\n * \\brief   pixCensusTransform()\n *\n * \\param[in]    pixs       8 bpp\n * \\param[in]    halfsize   of square over which neighbors are averaged\n * \\param[in]    pixacc     [optional] 32 bpp pix\n * \\return  pixd 1 bpp\n *\n * <pre>\n * Notes:\n *      (1) The Census transform was invented by Ramin Zabih and John Woodfill\n *          (\"Non-parametric local transforms for computing visual\n *          correspondence\", Third European Conference on Computer Vision,\n *          Stockholm, Sweden, May 1994); see publications at\n *             http://www.cs.cornell.edu/~rdz/index.htm\n *          This compares each pixel against the average of its neighbors,\n *          in a square of odd dimension centered on the pixel.\n *          If the pixel is greater than the average of its neighbors,\n *          the output pixel value is 1; otherwise it is 0.\n *      (2) This can be used as an encoding for an image that is\n *          fairly robust against slow illumination changes, with\n *          applications in image comparison and mosaicing.\n *      (3) The size of the convolution kernel is (2 * halfsize + 1)\n *          on a side.  The halfsize parameter must be >= 1.\n *      (4) If accum pix is null, make one, use it, and destroy it\n *          before returning; otherwise, just use the input accum pix\n * </pre>\n */\nPIX *\npixCensusTransform(PIX     *pixs,\n                   l_int32  halfsize,\n                   PIX     *pixacc)\n{\nl_int32    i, j, w, h, wpls, wplv, wpld;\nl_int32    vals, valv;\nl_uint32  *datas, *datav, *datad, *lines, *linev, *lined;\nPIX       *pixav, *pixd;\n\n    PROCNAME(\"pixCensusTransform\");\n\n    if (!pixs)\n        return (PIX *)ERROR_PTR(\"pixs not defined\", procName, NULL);\n    if (pixGetDepth(pixs) != 8)\n        return (PIX *)ERROR_PTR(\"pixs not 8 bpp\", procName, NULL);\n    if (halfsize < 1)\n        return (PIX *)ERROR_PTR(\"halfsize must be >= 1\", procName, NULL);\n\n        /* Get the average of each pixel with its neighbors */\n    if ((pixav = pixBlockconvGray(pixs, pixacc, halfsize, halfsize))\n          == NULL)\n        return (PIX *)ERROR_PTR(\"pixav not made\", procName, NULL);\n\n        /* Subtract the pixel from the average, and then compare\n         * the pixel value with the remaining average */\n    pixGetDimensions(pixs, &w, &h, NULL);\n    if ((pixd = pixCreate(w, h, 1)) == NULL) {\n        pixDestroy(&pixav);\n        return (PIX *)ERROR_PTR(\"pixd not made\", procName, NULL);\n    }\n    datas = pixGetData(pixs);\n    datav = pixGetData(pixav);\n    datad = pixGetData(pixd);\n    wpls = pixGetWpl(pixs);\n    wplv = pixGetWpl(pixav);\n    wpld = pixGetWpl(pixd);\n    for (i = 0; i < h; i++) {\n        lines = datas + i * wpls;\n        linev = datav + i * wplv;\n        lined = datad + i * wpld;\n        for (j = 0; j < w; j++) {\n            vals = GET_DATA_BYTE(lines, j);\n            valv = GET_DATA_BYTE(linev, j);\n            if (vals > valv)\n                SET_DATA_BIT(lined, j);\n        }\n    }\n\n    pixDestroy(&pixav);\n    return pixd;\n}\n\n\n/*----------------------------------------------------------------------*\n *                         Generic convolution                          *\n *----------------------------------------------------------------------*/\n/*!\n * \\brief   pixConvolve()\n *\n * \\param[in]    pixs       8, 16, 32 bpp; no colormap\n * \\param[in]    kel        kernel\n * \\param[in]    outdepth   of pixd: 8, 16 or 32\n * \\param[in]    normflag   1 to normalize kernel to unit sum; 0 otherwise\n * \\return  pixd 8, 16 or 32 bpp\n *\n * <pre>\n * Notes:\n *      (1) This gives a convolution with an arbitrary kernel.\n *      (2) The input pixs must have only one sample/pixel.\n *          To do a convolution on an RGB image, use pixConvolveRGB().\n *      (3) The parameter %outdepth determines the depth of the result.\n *          If the kernel is normalized to unit sum, the output values\n *          can never exceed 255, so an output depth of 8 bpp is sufficient.\n *          If the kernel is not normalized, it may be necessary to use\n *          16 or 32 bpp output to avoid overflow.\n *      (4) If normflag == 1, the result is normalized by scaling all\n *          kernel values for a unit sum.  If the sum of kernel values\n *          is very close to zero, the kernel can not be normalized and\n *          the convolution will not be performed.  A warning is issued.\n *      (5) The kernel values can be positive or negative, but the\n *          result for the convolution can only be stored as a positive\n *          number.  Consequently, if it goes negative, the choices are\n *          to clip to 0 or take the absolute value.  We're choosing\n *          to take the absolute value.  (Another possibility would be\n *          to output a second unsigned image for the negative values.)\n *          If you want to get a clipped result, or to keep the negative\n *          values in the result, use fpixConvolve(), with the\n *          converters in fpix2.c between pix and fpix.\n *      (6) This uses a mirrored border to avoid special casing on\n *          the boundaries.\n *      (7) To get a subsampled output, call l_setConvolveSampling().\n *          The time to make a subsampled output is reduced by the\n *          product of the sampling factors.\n *      (8) The function is slow, running at about 12 machine cycles for\n *          each pixel-op in the convolution.  For example, with a 3 GHz\n *          cpu, a 1 Mpixel grayscale image, and a kernel with\n *          (sx * sy) = 25 elements, the convolution takes about 100 msec.\n * </pre>\n */\nPIX *\npixConvolve(PIX       *pixs,\n            L_KERNEL  *kel,\n            l_int32    outdepth,\n            l_int32    normflag)\n{\nl_int32    i, j, id, jd, k, m, w, h, d, wd, hd, sx, sy, cx, cy, wplt, wpld;\nl_int32    val;\nl_uint32  *datat, *datad, *linet, *lined;\nl_float32  sum;\nL_KERNEL  *keli, *keln;\nPIX       *pixt, *pixd;\n\n    PROCNAME(\"pixConvolve\");\n\n    if (!pixs)\n        return (PIX *)ERROR_PTR(\"pixs not defined\", procName, NULL);\n    if (pixGetColormap(pixs))\n        return (PIX *)ERROR_PTR(\"pixs has colormap\", procName, NULL);\n    pixGetDimensions(pixs, &w, &h, &d);\n    if (d != 8 && d != 16 && d != 32)\n        return (PIX *)ERROR_PTR(\"pixs not 8, 16, or 32 bpp\", procName, NULL);\n    if (!kel)\n        return (PIX *)ERROR_PTR(\"kel not defined\", procName, NULL);\n\n    pixd = NULL;\n\n    keli = kernelInvert(kel);\n    kernelGetParameters(keli, &sy, &sx, &cy, &cx);\n    if (normflag)\n        keln = kernelNormalize(keli, 1.0);\n    else\n        keln = kernelCopy(keli);\n\n    if ((pixt = pixAddMirroredBorder(pixs, cx, sx - cx, cy, sy - cy)) == NULL) {\n        L_ERROR(\"pixt not made\\n\", procName);\n        goto cleanup;\n    }\n\n    wd = (w + ConvolveSamplingFactX - 1) / ConvolveSamplingFactX;\n    hd = (h + ConvolveSamplingFactY - 1) / ConvolveSamplingFactY;\n    pixd = pixCreate(wd, hd, outdepth);\n    datat = pixGetData(pixt);\n    datad = pixGetData(pixd);\n    wplt = pixGetWpl(pixt);\n    wpld = pixGetWpl(pixd);\n    for (i = 0, id = 0; id < hd; i += ConvolveSamplingFactY, id++) {\n        lined = datad + id * wpld;\n        for (j = 0, jd = 0; jd < wd; j += ConvolveSamplingFactX, jd++) {\n            sum = 0.0;\n            for (k = 0; k < sy; k++) {\n                linet = datat + (i + k) * wplt;\n                if (d == 8) {\n                    for (m = 0; m < sx; m++) {\n                        val = GET_DATA_BYTE(linet, j + m);\n                        sum += val * keln->data[k][m];\n                    }\n                } else if (d == 16) {\n                    for (m = 0; m < sx; m++) {\n                        val = GET_DATA_TWO_BYTES(linet, j + m);\n                        sum += val * keln->data[k][m];\n                    }\n                } else {  /* d == 32 */\n                    for (m = 0; m < sx; m++) {\n                        val = *(linet + j + m);\n                        sum += val * keln->data[k][m];\n                    }\n                }\n            }\n            if (sum < 0.0) sum = -sum;  /* make it non-negative */\n            if (outdepth == 8)\n                SET_DATA_BYTE(lined, jd, (l_int32)(sum + 0.5));\n            else if (outdepth == 16)\n                SET_DATA_TWO_BYTES(lined, jd, (l_int32)(sum + 0.5));\n            else  /* outdepth == 32 */\n                *(lined + jd) = (l_uint32)(sum + 0.5);\n        }\n    }\n\ncleanup:\n    kernelDestroy(&keli);\n    kernelDestroy(&keln);\n    pixDestroy(&pixt);\n    return pixd;\n}\n\n\n/*!\n * \\brief   pixConvolveSep()\n *\n * \\param[in]    pixs       8, 16, 32 bpp; no colormap\n * \\param[in]    kelx       x-dependent kernel\n * \\param[in]    kely       y-dependent kernel\n * \\param[in]    outdepth   of pixd: 8, 16 or 32\n * \\param[in]    normflag   1 to normalize kernel to unit sum; 0 otherwise\n * \\return  pixd    8, 16 or 32 bpp\n *\n * <pre>\n * Notes:\n *      (1) This does a convolution with a separable kernel that is\n *          is a sequence of convolutions in x and y.  The two\n *          one-dimensional kernel components must be input separately;\n *          the full kernel is the product of these components.\n *          The support for the full kernel is thus a rectangular region.\n *      (2) The input pixs must have only one sample/pixel.\n *          To do a convolution on an RGB image, use pixConvolveSepRGB().\n *      (3) The parameter %outdepth determines the depth of the result.\n *          If the kernel is normalized to unit sum, the output values\n *          can never exceed 255, so an output depth of 8 bpp is sufficient.\n *          If the kernel is not normalized, it may be necessary to use\n *          16 or 32 bpp output to avoid overflow.\n *      (2) The %normflag parameter is used as in pixConvolve().\n *      (4) The kernel values can be positive or negative, but the\n *          result for the convolution can only be stored as a positive\n *          number.  Consequently, if it goes negative, the choices are\n *          to clip to 0 or take the absolute value.  We're choosing\n *          the former for now.  Another possibility would be to output\n *          a second unsigned image for the negative values.\n *      (5) Warning: if you use l_setConvolveSampling() to get a\n *          subsampled output, and the sampling factor is larger than\n *          the kernel half-width, it is faster to use the non-separable\n *          version pixConvolve().  This is because the first convolution\n *          here must be done on every raster line, regardless of the\n *          vertical sampling factor.  If the sampling factor is smaller\n *          than kernel half-width, it's faster to use the separable\n *          convolution.\n *      (6) This uses mirrored borders to avoid special casing on\n *          the boundaries.\n * </pre>\n */\nPIX *\npixConvolveSep(PIX       *pixs,\n               L_KERNEL  *kelx,\n               L_KERNEL  *kely,\n               l_int32    outdepth,\n               l_int32    normflag)\n{\nl_int32    d, xfact, yfact;\nL_KERNEL  *kelxn, *kelyn;\nPIX       *pixt, *pixd;\n\n    PROCNAME(\"pixConvolveSep\");\n\n    if (!pixs)\n        return (PIX *)ERROR_PTR(\"pixs not defined\", procName, NULL);\n    d = pixGetDepth(pixs);\n    if (d != 8 && d != 16 && d != 32)\n        return (PIX *)ERROR_PTR(\"pixs not 8, 16, or 32 bpp\", procName, NULL);\n    if (!kelx)\n        return (PIX *)ERROR_PTR(\"kelx not defined\", procName, NULL);\n    if (!kely)\n        return (PIX *)ERROR_PTR(\"kely not defined\", procName, NULL);\n\n    xfact = ConvolveSamplingFactX;\n    yfact = ConvolveSamplingFactY;\n    if (normflag) {\n        kelxn = kernelNormalize(kelx, 1000.0);\n        kelyn = kernelNormalize(kely, 0.001);\n        l_setConvolveSampling(xfact, 1);\n        pixt = pixConvolve(pixs, kelxn, 32, 0);\n        l_setConvolveSampling(1, yfact);\n        pixd = pixConvolve(pixt, kelyn, outdepth, 0);\n        l_setConvolveSampling(xfact, yfact);  /* restore */\n        kernelDestroy(&kelxn);\n        kernelDestroy(&kelyn);\n    } else {  /* don't normalize */\n        l_setConvolveSampling(xfact, 1);\n        pixt = pixConvolve(pixs, kelx, 32, 0);\n        l_setConvolveSampling(1, yfact);\n        pixd = pixConvolve(pixt, kely, outdepth, 0);\n        l_setConvolveSampling(xfact, yfact);\n    }\n\n    pixDestroy(&pixt);\n    return pixd;\n}\n\n\n/*!\n * \\brief   pixConvolveRGB()\n *\n * \\param[in]    pixs   32 bpp rgb\n * \\param[in]    kel    kernel\n * \\return  pixd   32 bpp rgb\n *\n * <pre>\n * Notes:\n *      (1) This gives a convolution on an RGB image using an\n *          arbitrary kernel (which we normalize to keep each\n *          component within the range [0 ... 255].\n *      (2) The input pixs must be RGB.\n *      (3) The kernel values can be positive or negative, but the\n *          result for the convolution can only be stored as a positive\n *          number.  Consequently, if it goes negative, we clip the\n *          result to 0.\n *      (4) To get a subsampled output, call l_setConvolveSampling().\n *          The time to make a subsampled output is reduced by the\n *          product of the sampling factors.\n *      (5) This uses a mirrored border to avoid special casing on\n *          the boundaries.\n * </pre>\n */\nPIX *\npixConvolveRGB(PIX       *pixs,\n               L_KERNEL  *kel)\n{\nPIX  *pixt, *pixr, *pixg, *pixb, *pixd;\n\n    PROCNAME(\"pixConvolveRGB\");\n\n    if (!pixs)\n        return (PIX *)ERROR_PTR(\"pixs not defined\", procName, NULL);\n    if (pixGetDepth(pixs) != 32)\n        return (PIX *)ERROR_PTR(\"pixs is not 32 bpp\", procName, NULL);\n    if (!kel)\n        return (PIX *)ERROR_PTR(\"kel not defined\", procName, NULL);\n\n    pixt = pixGetRGBComponent(pixs, COLOR_RED);\n    pixr = pixConvolve(pixt, kel, 8, 1);\n    pixDestroy(&pixt);\n    pixt = pixGetRGBComponent(pixs, COLOR_GREEN);\n    pixg = pixConvolve(pixt, kel, 8, 1);\n    pixDestroy(&pixt);\n    pixt = pixGetRGBComponent(pixs, COLOR_BLUE);\n    pixb = pixConvolve(pixt, kel, 8, 1);\n    pixDestroy(&pixt);\n    pixd = pixCreateRGBImage(pixr, pixg, pixb);\n\n    pixDestroy(&pixr);\n    pixDestroy(&pixg);\n    pixDestroy(&pixb);\n    return pixd;\n}\n\n\n/*!\n * \\brief   pixConvolveRGBSep()\n *\n * \\param[in]    pixs   32 bpp rgb\n * \\param[in]    kelx   x-dependent kernel\n * \\param[in]    kely   y-dependent kernel\n * \\return  pixd 32 bpp rgb\n *\n * <pre>\n * Notes:\n *      (1) This does a convolution on an RGB image using a separable\n *          kernel that is a sequence of convolutions in x and y.  The two\n *          one-dimensional kernel components must be input separately;\n *          the full kernel is the product of these components.\n *          The support for the full kernel is thus a rectangular region.\n *      (2) The kernel values can be positive or negative, but the\n *          result for the convolution can only be stored as a positive\n *          number.  Consequently, if it goes negative, we clip the\n *          result to 0.\n *      (3) To get a subsampled output, call l_setConvolveSampling().\n *          The time to make a subsampled output is reduced by the\n *          product of the sampling factors.\n *      (4) This uses a mirrored border to avoid special casing on\n *          the boundaries.\n * </pre>\n */\nPIX *\npixConvolveRGBSep(PIX       *pixs,\n                  L_KERNEL  *kelx,\n                  L_KERNEL  *kely)\n{\nPIX  *pixt, *pixr, *pixg, *pixb, *pixd;\n\n    PROCNAME(\"pixConvolveRGBSep\");\n\n    if (!pixs)\n        return (PIX *)ERROR_PTR(\"pixs not defined\", procName, NULL);\n    if (pixGetDepth(pixs) != 32)\n        return (PIX *)ERROR_PTR(\"pixs is not 32 bpp\", procName, NULL);\n    if (!kelx || !kely)\n        return (PIX *)ERROR_PTR(\"kelx, kely not both defined\", procName, NULL);\n\n    pixt = pixGetRGBComponent(pixs, COLOR_RED);\n    pixr = pixConvolveSep(pixt, kelx, kely, 8, 1);\n    pixDestroy(&pixt);\n    pixt = pixGetRGBComponent(pixs, COLOR_GREEN);\n    pixg = pixConvolveSep(pixt, kelx, kely, 8, 1);\n    pixDestroy(&pixt);\n    pixt = pixGetRGBComponent(pixs, COLOR_BLUE);\n    pixb = pixConvolveSep(pixt, kelx, kely, 8, 1);\n    pixDestroy(&pixt);\n    pixd = pixCreateRGBImage(pixr, pixg, pixb);\n\n    pixDestroy(&pixr);\n    pixDestroy(&pixg);\n    pixDestroy(&pixb);\n    return pixd;\n}\n\n\n/*----------------------------------------------------------------------*\n *                  Generic convolution with float array                *\n *----------------------------------------------------------------------*/\n/*!\n * \\brief   fpixConvolve()\n *\n * \\param[in]    fpixs      32 bit float array\n * \\param[in]    kel        kernel\n * \\param[in]    normflag   1 to normalize kernel to unit sum; 0 otherwise\n * \\return  fpixd 32 bit float array\n *\n * <pre>\n * Notes:\n *      (1) This gives a float convolution with an arbitrary kernel.\n *      (2) If normflag == 1, the result is normalized by scaling all\n *          kernel values for a unit sum.  If the sum of kernel values\n *          is very close to zero, the kernel can not be normalized and\n *          the convolution will not be performed.  A warning is issued.\n *      (3) With the FPix, there are no issues about negative\n *          array or kernel values.  The convolution is performed\n *          with single precision arithmetic.\n *      (4) To get a subsampled output, call l_setConvolveSampling().\n *          The time to make a subsampled output is reduced by the\n *          product of the sampling factors.\n *      (5) This uses a mirrored border to avoid special casing on\n *          the boundaries.\n * </pre>\n */\nFPIX *\nfpixConvolve(FPIX      *fpixs,\n             L_KERNEL  *kel,\n             l_int32    normflag)\n{\nl_int32     i, j, id, jd, k, m, w, h, wd, hd, sx, sy, cx, cy, wplt, wpld;\nl_float32   val;\nl_float32  *datat, *datad, *linet, *lined;\nl_float32   sum;\nL_KERNEL   *keli, *keln;\nFPIX       *fpixt, *fpixd;\n\n    PROCNAME(\"fpixConvolve\");\n\n    if (!fpixs)\n        return (FPIX *)ERROR_PTR(\"fpixs not defined\", procName, NULL);\n    if (!kel)\n        return (FPIX *)ERROR_PTR(\"kel not defined\", procName, NULL);\n\n    fpixd = NULL;\n\n    keli = kernelInvert(kel);\n    kernelGetParameters(keli, &sy, &sx, &cy, &cx);\n    if (normflag)\n        keln = kernelNormalize(keli, 1.0);\n    else\n        keln = kernelCopy(keli);\n\n    fpixGetDimensions(fpixs, &w, &h);\n    fpixt = fpixAddMirroredBorder(fpixs, cx, sx - cx, cy, sy - cy);\n    if (!fpixt) {\n        L_ERROR(\"fpixt not made\\n\", procName);\n        goto cleanup;\n    }\n\n    wd = (w + ConvolveSamplingFactX - 1) / ConvolveSamplingFactX;\n    hd = (h + ConvolveSamplingFactY - 1) / ConvolveSamplingFactY;\n    fpixd = fpixCreate(wd, hd);\n    datat = fpixGetData(fpixt);\n    datad = fpixGetData(fpixd);\n    wplt = fpixGetWpl(fpixt);\n    wpld = fpixGetWpl(fpixd);\n    for (i = 0, id = 0; id < hd; i += ConvolveSamplingFactY, id++) {\n        lined = datad + id * wpld;\n        for (j = 0, jd = 0; jd < wd; j += ConvolveSamplingFactX, jd++) {\n            sum = 0.0;\n            for (k = 0; k < sy; k++) {\n                linet = datat + (i + k) * wplt;\n                for (m = 0; m < sx; m++) {\n                    val = *(linet + j + m);\n                    sum += val * keln->data[k][m];\n                }\n            }\n            *(lined + jd) = sum;\n        }\n    }\n\ncleanup:\n    kernelDestroy(&keli);\n    kernelDestroy(&keln);\n    fpixDestroy(&fpixt);\n    return fpixd;\n}\n\n\n/*!\n * \\brief   fpixConvolveSep()\n *\n * \\param[in]    fpixs      32 bit float array\n * \\param[in]    kelx       x-dependent kernel\n * \\param[in]    kely       y-dependent kernel\n * \\param[in]    normflag   1 to normalize kernel to unit sum; 0 otherwise\n * \\return  fpixd    32 bit float array\n *\n * <pre>\n * Notes:\n *      (1) This does a convolution with a separable kernel that is\n *          is a sequence of convolutions in x and y.  The two\n *          one-dimensional kernel components must be input separately;\n *          the full kernel is the product of these components.\n *          The support for the full kernel is thus a rectangular region.\n *      (2) The normflag parameter is used as in fpixConvolve().\n *      (3) Warning: if you use l_setConvolveSampling() to get a\n *          subsampled output, and the sampling factor is larger than\n *          the kernel half-width, it is faster to use the non-separable\n *          version pixConvolve().  This is because the first convolution\n *          here must be done on every raster line, regardless of the\n *          vertical sampling factor.  If the sampling factor is smaller\n *          than kernel half-width, it's faster to use the separable\n *          convolution.\n *      (4) This uses mirrored borders to avoid special casing on\n *          the boundaries.\n * </pre>\n */\nFPIX *\nfpixConvolveSep(FPIX      *fpixs,\n                L_KERNEL  *kelx,\n                L_KERNEL  *kely,\n                l_int32    normflag)\n{\nl_int32    xfact, yfact;\nL_KERNEL  *kelxn, *kelyn;\nFPIX      *fpixt, *fpixd;\n\n    PROCNAME(\"fpixConvolveSep\");\n\n    if (!fpixs)\n        return (FPIX *)ERROR_PTR(\"pixs not defined\", procName, NULL);\n    if (!kelx)\n        return (FPIX *)ERROR_PTR(\"kelx not defined\", procName, NULL);\n    if (!kely)\n        return (FPIX *)ERROR_PTR(\"kely not defined\", procName, NULL);\n\n    xfact = ConvolveSamplingFactX;\n    yfact = ConvolveSamplingFactY;\n    if (normflag) {\n        kelxn = kernelNormalize(kelx, 1.0);\n        kelyn = kernelNormalize(kely, 1.0);\n        l_setConvolveSampling(xfact, 1);\n        fpixt = fpixConvolve(fpixs, kelxn, 0);\n        l_setConvolveSampling(1, yfact);\n        fpixd = fpixConvolve(fpixt, kelyn, 0);\n        l_setConvolveSampling(xfact, yfact);  /* restore */\n        kernelDestroy(&kelxn);\n        kernelDestroy(&kelyn);\n    } else {  /* don't normalize */\n        l_setConvolveSampling(xfact, 1);\n        fpixt = fpixConvolve(fpixs, kelx, 0);\n        l_setConvolveSampling(1, yfact);\n        fpixd = fpixConvolve(fpixt, kely, 0);\n        l_setConvolveSampling(xfact, yfact);\n    }\n\n    fpixDestroy(&fpixt);\n    return fpixd;\n}\n\n\n/*------------------------------------------------------------------------*\n *              Convolution with bias (for non-negative output)           *\n *------------------------------------------------------------------------*/\n/*!\n * \\brief   pixConvolveWithBias()\n *\n * \\param[in]    pixs     8 bpp; no colormap\n * \\param[in]    kel1\n * \\param[in]    kel2     can be null; use if separable\n * \\param[in]    force8   if 1, force output to 8 bpp; otherwise, determine\n *                        output depth by the dynamic range of pixel values\n * \\param[out]   pbias    applied bias\n * \\return  pixd 8 or 16 bpp\n *\n * <pre>\n * Notes:\n *      (1) This does a convolution with either a single kernel or\n *          a pair of separable kernels, and automatically applies whatever\n *          bias (shift) is required so that the resulting pixel values\n *          are non-negative.\n *      (2) The kernel is always normalized.  If there are no negative\n *          values in the kernel, a standard normalized convolution is\n *          performed, with 8 bpp output.  If the sum of kernel values is\n *          very close to zero, the kernel can not be normalized and\n *          the convolution will not be performed.  An error message results.\n *      (3) If there are negative values in the kernel, the pix is\n *          converted to an fpix, the convolution is done on the fpix, and\n *          a bias (shift) may need to be applied.\n *      (4) If force8 == TRUE and the range of values after the convolution\n *          is > 255, the output values will be scaled to fit in [0 ... 255].\n *          If force8 == FALSE, the output will be either 8 or 16 bpp,\n *          to accommodate the dynamic range of output values without scaling.\n * </pre>\n */\nPIX *\npixConvolveWithBias(PIX       *pixs,\n                    L_KERNEL  *kel1,\n                    L_KERNEL  *kel2,\n                    l_int32    force8,\n                    l_int32   *pbias)\n{\nl_int32    outdepth;\nl_float32  min1, min2, min, minval, maxval, range;\nFPIX      *fpix1, *fpix2;\nPIX       *pixd;\n\n    PROCNAME(\"pixConvolveWithBias\");\n\n    if (!pbias)\n        return (PIX *)ERROR_PTR(\"&bias not defined\", procName, NULL);\n    *pbias = 0;\n    if (!pixs || pixGetDepth(pixs) != 8)\n        return (PIX *)ERROR_PTR(\"pixs undefined or not 8 bpp\", procName, NULL);\n    if (pixGetColormap(pixs))\n        return (PIX *)ERROR_PTR(\"pixs has colormap\", procName, NULL);\n    if (!kel1)\n        return (PIX *)ERROR_PTR(\"kel1 not defined\", procName, NULL);\n\n        /* Determine if negative values can be produced in the convolution */\n    kernelGetMinMax(kel1, &min1, NULL);\n    min2 = 0.0;\n    if (kel2)\n        kernelGetMinMax(kel2, &min2, NULL);\n    min = L_MIN(min1, min2);\n\n    if (min >= 0.0) {\n        if (!kel2)\n            return pixConvolve(pixs, kel1, 8, 1);\n        else\n            return pixConvolveSep(pixs, kel1, kel2, 8, 1);\n    }\n\n        /* Bias may need to be applied; convert to fpix and convolve */\n    fpix1 = pixConvertToFPix(pixs, 1);\n    if (!kel2)\n        fpix2 = fpixConvolve(fpix1, kel1, 1);\n    else\n        fpix2 = fpixConvolveSep(fpix1, kel1, kel2, 1);\n    fpixDestroy(&fpix1);\n\n        /* Determine the bias and the dynamic range.\n         * If the dynamic range is <= 255, just shift the values by the\n         * bias, if any.\n         * If the dynamic range is > 255, there are two cases:\n         *    (1) the output depth is not forced to 8 bpp\n         *           ==> apply the bias without scaling; outdepth = 16\n         *    (2) the output depth is forced to 8\n         *           ==> linearly map the pixel values to [0 ... 255].  */\n    fpixGetMin(fpix2, &minval, NULL, NULL);\n    fpixGetMax(fpix2, &maxval, NULL, NULL);\n    range = maxval - minval;\n    *pbias = (minval < 0.0) ? -minval : 0.0;\n    fpixAddMultConstant(fpix2, *pbias, 1.0);  /* shift: min val ==> 0 */\n    if (range <= 255 || !force8) {  /* no scaling of output values */\n        outdepth = (range > 255) ? 16 : 8;\n    } else {  /* scale output values to fit in 8 bpp */\n        fpixAddMultConstant(fpix2, 0.0, (255.0 / range));\n        outdepth = 8;\n    }\n\n        /* Convert back to pix; it won't do any clipping */\n    pixd = fpixConvertToPix(fpix2, outdepth, L_CLIP_TO_ZERO, 0);\n    fpixDestroy(&fpix2);\n\n    return pixd;\n}\n\n\n/*------------------------------------------------------------------------*\n *                Set parameter for convolution subsampling               *\n *------------------------------------------------------------------------*/\n/*!\n * \\brief   l_setConvolveSampling()\n\n *\n * \\param[in]    xfact, yfact     integer >= 1\n * \\return  void\n *\n * <pre>\n * Notes:\n *      (1) This sets the x and y output subsampling factors for generic pix\n *          and fpix convolution.  The default values are 1 (no subsampling).\n * </pre>\n */\nvoid\nl_setConvolveSampling(l_int32  xfact,\n                      l_int32  yfact)\n{\n    if (xfact < 1) xfact = 1;\n    if (yfact < 1) yfact = 1;\n    ConvolveSamplingFactX = xfact;\n    ConvolveSamplingFactY = yfact;\n}\n\n\n/*------------------------------------------------------------------------*\n *                          Additive gaussian noise                       *\n *------------------------------------------------------------------------*/\n/*!\n * \\brief   pixAddGaussianNoise()\n *\n * \\param[in]    pixs     8 bpp gray or 32 bpp rgb; no colormap\n * \\param[in]    stdev    of noise\n * \\return  pixd    8 or 32 bpp, or NULL on error\n *\n * <pre>\n * Notes:\n *      (1) This adds noise to each pixel, taken from a normal\n *          distribution with zero mean and specified standard deviation.\n * </pre>\n */\nPIX *\npixAddGaussianNoise(PIX       *pixs,\n                    l_float32  stdev)\n{\nl_int32    i, j, w, h, d, wpls, wpld, val, rval, gval, bval;\nl_uint32   pixel;\nl_uint32  *datas, *datad, *lines, *lined;\nPIX       *pixd;\n\n    PROCNAME(\"pixAddGaussianNoise\");\n\n    if (!pixs)\n        return (PIX *)ERROR_PTR(\"pixs not defined\", procName, NULL);\n    if (pixGetColormap(pixs))\n        return (PIX *)ERROR_PTR(\"pixs has colormap\", procName, NULL);\n    pixGetDimensions(pixs, &w, &h, &d);\n    if (d != 8 && d != 32)\n        return (PIX *)ERROR_PTR(\"pixs not 8 or 32 bpp\", procName, NULL);\n\n    pixd = pixCreateTemplateNoInit(pixs);\n    datas = pixGetData(pixs);\n    datad = pixGetData(pixd);\n    wpls = pixGetWpl(pixs);\n    wpld = pixGetWpl(pixd);\n    for (i = 0; i < h; i++) {\n        lines = datas + i * wpls;\n        lined = datad + i * wpld;\n        for (j = 0; j < w; j++) {\n            if (d == 8) {\n                val = GET_DATA_BYTE(lines, j);\n                val += (l_int32)(stdev * gaussDistribSampling() + 0.5);\n                val = L_MIN(255, L_MAX(0, val));\n                SET_DATA_BYTE(lined, j, val);\n            } else {  /* d = 32 */\n                pixel = *(lines + j);\n                extractRGBValues(pixel, &rval, &gval, &bval);\n                rval += (l_int32)(stdev * gaussDistribSampling() + 0.5);\n                rval = L_MIN(255, L_MAX(0, rval));\n                gval += (l_int32)(stdev * gaussDistribSampling() + 0.5);\n                gval = L_MIN(255, L_MAX(0, gval));\n                bval += (l_int32)(stdev * gaussDistribSampling() + 0.5);\n                bval = L_MIN(255, L_MAX(0, bval));\n                composeRGBPixel(rval, gval, bval, lined + j);\n            }\n        }\n    }\n    return pixd;\n}\n\n\n/*!\n * \\brief   gaussDistribSampling()\n *\n * \\return   gaussian distributed variable with zero mean and unit stdev\n *\n * <pre>\n * Notes:\n *      (1) For an explanation of the Box-Muller method for generating\n *          a normally distributed random variable with zero mean and\n *          unit standard deviation, see Numerical Recipes in C,\n *          2nd edition, p. 288ff.\n *      (2) This can be called sequentially to get samples that can be\n *          used for adding noise to each pixel of an image, for example.\n * </pre>\n */\nl_float32\ngaussDistribSampling(void)\n{\nstatic l_int32    select = 0;  /* flips between 0 and 1 on successive calls */\nstatic l_float32  saveval;\nl_float32         frand, xval, yval, rsq, factor;\n\n    if (select == 0) {\n        while (1) {  /* choose a point in a 2x2 square, centered at origin */\n            frand = (l_float32)rand() / (l_float32)RAND_MAX;\n            xval = 2.0 * frand - 1.0;\n            frand = (l_float32)rand() / (l_float32)RAND_MAX;\n            yval = 2.0 * frand - 1.0;\n            rsq = xval * xval + yval * yval;\n            if (rsq > 0.0 && rsq < 1.0)  /* point is inside the unit circle */\n                break;\n        }\n        factor = sqrt(-2.0 * log(rsq) / rsq);\n        saveval = xval * factor;\n        select = 1;\n        return yval * factor;\n    }\n    else {\n        select = 0;\n        return saveval;\n    }\n}\n"], "fixing_code": ["/*====================================================================*\n -  Copyright (C) 2001 Leptonica.  All rights reserved.\n -\n -  Redistribution and use in source and binary forms, with or without\n -  modification, are permitted provided that the following conditions\n -  are met:\n -  1. Redistributions of source code must retain the above copyright\n -     notice, this list of conditions and the following disclaimer.\n -  2. Redistributions in binary form must reproduce the above\n -     copyright notice, this list of conditions and the following\n -     disclaimer in the documentation and/or other materials\n -     provided with the distribution.\n -\n -  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n -  ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n -  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n -  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL ANY\n -  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n -  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n -  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n -  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n -  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n -  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n -  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *====================================================================*/\n\n/*!\n * \\file convolve.c\n * <pre>\n *\n *      Top level grayscale or color block convolution\n *          PIX          *pixBlockconv()\n *\n *      Grayscale block convolution\n *          PIX          *pixBlockconvGray()\n *          static void   blockconvLow()\n *\n *      Accumulator for 1, 8 and 32 bpp convolution\n *          PIX          *pixBlockconvAccum()\n *          static void   blockconvAccumLow()\n *\n *      Un-normalized grayscale block convolution\n *          PIX          *pixBlockconvGrayUnnormalized()\n *\n *      Tiled grayscale or color block convolution\n *          PIX          *pixBlockconvTiled()\n *          PIX          *pixBlockconvGrayTile()\n *\n *      Convolution for mean, mean square, variance and rms deviation\n *      in specified window\n *          l_int32       pixWindowedStats()\n *          PIX          *pixWindowedMean()\n *          PIX          *pixWindowedMeanSquare()\n *          l_int32       pixWindowedVariance()\n *          DPIX         *pixMeanSquareAccum()\n *\n *      Binary block sum and rank filter\n *          PIX          *pixBlockrank()\n *          PIX          *pixBlocksum()\n *          static void   blocksumLow()\n *\n *      Census transform\n *          PIX          *pixCensusTransform()\n *\n *      Generic convolution (with Pix)\n *          PIX          *pixConvolve()\n *          PIX          *pixConvolveSep()\n *          PIX          *pixConvolveRGB()\n *          PIX          *pixConvolveRGBSep()\n *\n *      Generic convolution (with float arrays)\n *          FPIX         *fpixConvolve()\n *          FPIX         *fpixConvolveSep()\n *\n *      Convolution with bias (for non-negative output)\n *          PIX          *pixConvolveWithBias()\n *\n *      Set parameter for convolution subsampling\n *          void          l_setConvolveSampling()\n *\n *      Additive gaussian noise\n *          PIX          *pixAddGaussNoise()\n *          l_float32     gaussDistribSampling()\n * </pre>\n */\n\n#ifdef HAVE_CONFIG_H\n#include <config_auto.h>\n#endif  /* HAVE_CONFIG_H */\n\n#include <math.h>\n#include \"allheaders.h\"\n\n    /* These globals determine the subsampling factors for\n     * generic convolution of pix and fpix.  Declare extern to use.\n     * To change the values, use l_setConvolveSampling(). */\nLEPT_DLL l_int32  ConvolveSamplingFactX = 1;\nLEPT_DLL l_int32  ConvolveSamplingFactY = 1;\n\n    /* Low-level static functions */\nstatic void blockconvLow(l_uint32 *data, l_int32 w, l_int32 h, l_int32 wpl,\n                         l_uint32 *dataa, l_int32 wpla, l_int32 wc,\n                         l_int32 hc);\nstatic void blockconvAccumLow(l_uint32 *datad, l_int32 w, l_int32 h,\n                              l_int32 wpld, l_uint32 *datas, l_int32 d,\n                              l_int32 wpls);\nstatic void blocksumLow(l_uint32 *datad, l_int32 w, l_int32 h, l_int32 wpl,\n                        l_uint32 *dataa, l_int32 wpla, l_int32 wc, l_int32 hc);\n\n\n/*----------------------------------------------------------------------*\n *             Top-level grayscale or color block convolution           *\n *----------------------------------------------------------------------*/\n/*!\n * \\brief   pixBlockconv()\n *\n * \\param[in]    pix      8 or 32 bpp; or 2, 4 or 8 bpp with colormap\n * \\param[in]    wc, hc   half width/height of convolution kernel\n * \\return  pixd, or NULL on error\n *\n * <pre>\n * Notes:\n *      (1) The full width and height of the convolution kernel\n *          are (2 * wc + 1) and (2 * hc + 1)\n *      (2) Returns a copy if either wc or hc are 0\n *      (3) Require that w >= 2 * wc + 1 and h >= 2 * hc + 1,\n *          where (w,h) are the dimensions of pixs.  Otherwise,\n *          return a copy.\n * </pre>\n */\nPIX  *\npixBlockconv(PIX     *pix,\n             l_int32  wc,\n             l_int32  hc)\n{\nl_int32  w, h, d;\nPIX     *pixs, *pixd, *pixr, *pixrc, *pixg, *pixgc, *pixb, *pixbc;\n\n    PROCNAME(\"pixBlockconv\");\n\n    if (!pix)\n        return (PIX *)ERROR_PTR(\"pix not defined\", procName, NULL);\n    if (wc <= 0 || hc <= 0)\n        return pixCopy(NULL, pix);\n    pixGetDimensions(pix, &w, &h, &d);\n    if (w < 2 * wc + 1 || h < 2 * hc + 1) {\n        L_ERROR(\"kernel is too large: w = %d, wc = %d, h = %d, hc = %d\\n\",\n                procName, w, wc, h, hc);\n        return pixCopy(NULL, pix);  /* no-op */\n    }\n\n        /* Remove colormap if necessary */\n    if ((d == 2 || d == 4 || d == 8) && pixGetColormap(pix)) {\n        L_WARNING(\"pix has colormap; removing\\n\", procName);\n        pixs = pixRemoveColormap(pix, REMOVE_CMAP_BASED_ON_SRC);\n        d = pixGetDepth(pixs);\n    } else {\n        pixs = pixClone(pix);\n    }\n\n    if (d != 8 && d != 32) {\n        pixDestroy(&pixs);\n        return (PIX *)ERROR_PTR(\"depth not 8 or 32 bpp\", procName, NULL);\n    }\n\n    if (d == 8) {\n        pixd = pixBlockconvGray(pixs, NULL, wc, hc);\n    } else { /* d == 32 */\n        pixr = pixGetRGBComponent(pixs, COLOR_RED);\n        pixrc = pixBlockconvGray(pixr, NULL, wc, hc);\n        pixDestroy(&pixr);\n        pixg = pixGetRGBComponent(pixs, COLOR_GREEN);\n        pixgc = pixBlockconvGray(pixg, NULL, wc, hc);\n        pixDestroy(&pixg);\n        pixb = pixGetRGBComponent(pixs, COLOR_BLUE);\n        pixbc = pixBlockconvGray(pixb, NULL, wc, hc);\n        pixDestroy(&pixb);\n        pixd = pixCreateRGBImage(pixrc, pixgc, pixbc);\n        pixDestroy(&pixrc);\n        pixDestroy(&pixgc);\n        pixDestroy(&pixbc);\n    }\n\n    pixDestroy(&pixs);\n    return pixd;\n}\n\n\n/*----------------------------------------------------------------------*\n *                     Grayscale block convolution                      *\n *----------------------------------------------------------------------*/\n/*!\n * \\brief   pixBlockconvGray()\n *\n * \\param[in]    pixs     8 bpp\n * \\param[in]    pixacc   pix 32 bpp; can be null\n * \\param[in]    wc, hc   half width/height of convolution kernel\n * \\return  pix 8 bpp, or NULL on error\n *\n * <pre>\n * Notes:\n *      (1) If accum pix is null, make one and destroy it before\n *          returning; otherwise, just use the input accum pix.\n *      (2) The full width and height of the convolution kernel\n *          are (2 * wc + 1) and (2 * hc + 1).\n *      (3) Returns a copy if either wc or hc are 0\n *      (4) Require that w >= 2 * wc + 1 and h >= 2 * hc + 1,\n *          where (w,h) are the dimensions of pixs.  Otherwise,\n *          return a copy.\n * </pre>\n */\nPIX *\npixBlockconvGray(PIX     *pixs,\n                 PIX     *pixacc,\n                 l_int32  wc,\n                 l_int32  hc)\n{\nl_int32    w, h, d, wpl, wpla;\nl_uint32  *datad, *dataa;\nPIX       *pixd, *pixt;\n\n    PROCNAME(\"pixBlockconvGray\");\n\n    if (!pixs)\n        return (PIX *)ERROR_PTR(\"pixs not defined\", procName, NULL);\n    pixGetDimensions(pixs, &w, &h, &d);\n    if (d != 8)\n        return (PIX *)ERROR_PTR(\"pixs not 8 bpp\", procName, NULL);\n    if (wc <= 0 || hc <= 0)   /* no-op */\n        return pixCopy(NULL, pixs);\n    if (w < 2 * wc + 1 || h < 2 * hc + 1) {\n        L_ERROR(\"kernel is too large: w = %d, wc = %d, h = %d, hc = %d\\n\",\n                procName, w, wc, h, hc);\n        return pixCopy(NULL, pixs);\n    }\n\n    if (pixacc) {\n        if (pixGetDepth(pixacc) == 32) {\n            pixt = pixClone(pixacc);\n        } else {\n            L_WARNING(\"pixacc not 32 bpp; making new one\\n\", procName);\n            if ((pixt = pixBlockconvAccum(pixs)) == NULL)\n                return (PIX *)ERROR_PTR(\"pixt not made\", procName, NULL);\n        }\n    } else {\n        if ((pixt = pixBlockconvAccum(pixs)) == NULL)\n            return (PIX *)ERROR_PTR(\"pixt not made\", procName, NULL);\n    }\n\n    if ((pixd = pixCreateTemplate(pixs)) == NULL) {\n        pixDestroy(&pixt);\n        return (PIX *)ERROR_PTR(\"pixd not made\", procName, NULL);\n    }\n\n    pixSetPadBits(pixt, 0);\n    wpl = pixGetWpl(pixd);\n    wpla = pixGetWpl(pixt);\n    datad = pixGetData(pixd);\n    dataa = pixGetData(pixt);\n    blockconvLow(datad, w, h, wpl, dataa, wpla, wc, hc);\n\n    pixDestroy(&pixt);\n    return pixd;\n}\n\n\n/*!\n * \\brief   blockconvLow()\n *\n * \\param[in]    data      data of input image, to be convolved\n * \\param[in]    w, h, wpl\n * \\param[in]    dataa     data of 32 bpp accumulator\n * \\param[in]    wpla      accumulator\n * \\param[in]    wc        convolution \"half-width\"\n * \\param[in]    hc        convolution \"half-height\"\n * \\return  void\n *\n * <pre>\n * Notes:\n *      (1) The full width and height of the convolution kernel\n *          are (2 * wc + 1) and (2 * hc + 1).\n *      (2) The lack of symmetry between the handling of the\n *          first (hc + 1) lines and the last (hc) lines,\n *          and similarly with the columns, is due to fact that\n *          for the pixel at (x,y), the accumulator values are\n *          taken at (x + wc, y + hc), (x - wc - 1, y + hc),\n *          (x + wc, y - hc - 1) and (x - wc - 1, y - hc - 1).\n *      (3) We compute sums, normalized as if there were no reduced\n *          area at the boundary.  This under-estimates the value\n *          of the boundary pixels, so we multiply them by another\n *          normalization factor that is greater than 1.\n *      (4) This second normalization is done first for the first\n *          hc + 1 lines; then for the last hc lines; and finally\n *          for the first wc + 1 and last wc columns in the intermediate\n *          lines.\n *      (5) The caller should verify that wc < w and hc < h.\n *          Under those conditions, illegal reads and writes can occur.\n *      (6) Implementation note: to get the same results in the interior\n *          between this function and pixConvolve(), it is necessary to\n *          add 0.5 for roundoff in the main loop that runs over all pixels.\n *          However, if we do that and have white (255) pixels near the\n *          image boundary, some overflow occurs for pixels very close\n *          to the boundary.  We can't fix this by subtracting from the\n *          normalized values for the boundary pixels, because this results\n *          in underflow if the boundary pixels are black (0).  Empirically,\n *          adding 0.25 (instead of 0.5) before truncating in the main\n *          loop will not cause overflow, but this gives some\n *          off-by-1-level errors in interior pixel values.  So we add\n *          0.5 for roundoff in the main loop, and for pixels within a\n *          half filter width of the boundary, use a L_MIN of the\n *          computed value and 255 to avoid overflow during normalization.\n * </pre>\n */\nstatic void\nblockconvLow(l_uint32  *data,\n             l_int32    w,\n             l_int32    h,\n             l_int32    wpl,\n             l_uint32  *dataa,\n             l_int32    wpla,\n             l_int32    wc,\n             l_int32    hc)\n{\nl_int32    i, j, imax, imin, jmax, jmin;\nl_int32    wn, hn, fwc, fhc, wmwc, hmhc;\nl_float32  norm, normh, normw;\nl_uint32   val;\nl_uint32  *linemina, *linemaxa, *line;\n\n    PROCNAME(\"blockconvLow\");\n\n    wmwc = w - wc;\n    hmhc = h - hc;\n    if (wmwc <= 0 || hmhc <= 0) {\n        L_ERROR(\"wc >= w || hc >=h\\n\", procName);\n        return;\n    }\n    fwc = 2 * wc + 1;\n    fhc = 2 * hc + 1;\n    norm = 1.0 / ((l_float32)(fwc) * fhc);\n\n        /*------------------------------------------------------------*\n         *  Compute, using b.c. only to set limits on the accum image *\n         *------------------------------------------------------------*/\n    for (i = 0; i < h; i++) {\n        imin = L_MAX(i - 1 - hc, 0);\n        imax = L_MIN(i + hc, h - 1);\n        line = data + wpl * i;\n        linemina = dataa + wpla * imin;\n        linemaxa = dataa + wpla * imax;\n        for (j = 0; j < w; j++) {\n            jmin = L_MAX(j - 1 - wc, 0);\n            jmax = L_MIN(j + wc, w - 1);\n            val = linemaxa[jmax] - linemaxa[jmin]\n                  + linemina[jmin] - linemina[jmax];\n            val = (l_uint8)(norm * val + 0.5);  /* see comment above */\n            SET_DATA_BYTE(line, j, val);\n        }\n    }\n\n        /*------------------------------------------------------------*\n         *             Fix normalization for boundary pixels          *\n         *------------------------------------------------------------*/\n    for (i = 0; i <= hc; i++) {    /* first hc + 1 lines */\n        hn = L_MAX(1, hc + i);\n        normh = (l_float32)fhc / (l_float32)hn;   /* >= 1 */\n        line = data + wpl * i;\n        for (j = 0; j <= wc; j++) {\n            wn = L_MAX(1, wc + j);\n            normw = (l_float32)fwc / (l_float32)wn;   /* >= 1 */\n            val = GET_DATA_BYTE(line, j);\n            val = (l_uint8)L_MIN(val * normh * normw, 255);\n            SET_DATA_BYTE(line, j, val);\n        }\n        for (j = wc + 1; j < wmwc; j++) {\n            val = GET_DATA_BYTE(line, j);\n            val = (l_uint8)L_MIN(val * normh, 255);\n            SET_DATA_BYTE(line, j, val);\n        }\n        for (j = wmwc; j < w; j++) {\n            wn = wc + w - j;\n            normw = (l_float32)fwc / (l_float32)wn;   /* > 1 */\n            val = GET_DATA_BYTE(line, j);\n            val = (l_uint8)L_MIN(val * normh * normw, 255);\n            SET_DATA_BYTE(line, j, val);\n        }\n    }\n\n    for (i = hmhc; i < h; i++) {  /* last hc lines */\n        hn = hc + h - i;\n        normh = (l_float32)fhc / (l_float32)hn;   /* > 1 */\n        line = data + wpl * i;\n        for (j = 0; j <= wc; j++) {\n            wn = wc + j;\n            normw = (l_float32)fwc / (l_float32)wn;   /* > 1 */\n            val = GET_DATA_BYTE(line, j);\n            val = (l_uint8)L_MIN(val * normh * normw, 255);\n            SET_DATA_BYTE(line, j, val);\n        }\n        for (j = wc + 1; j < wmwc; j++) {\n            val = GET_DATA_BYTE(line, j);\n            val = (l_uint8)L_MIN(val * normh, 255);\n            SET_DATA_BYTE(line, j, val);\n        }\n        for (j = wmwc; j < w; j++) {\n            wn = wc + w - j;\n            normw = (l_float32)fwc / (l_float32)wn;   /* > 1 */\n            val = GET_DATA_BYTE(line, j);\n            val = (l_uint8)L_MIN(val * normh * normw, 255);\n            SET_DATA_BYTE(line, j, val);\n        }\n    }\n\n    for (i = hc + 1; i < hmhc; i++) {    /* intermediate lines */\n        line = data + wpl * i;\n        for (j = 0; j <= wc; j++) {   /* first wc + 1 columns */\n            wn = wc + j;\n            normw = (l_float32)fwc / (l_float32)wn;   /* > 1 */\n            val = GET_DATA_BYTE(line, j);\n            val = (l_uint8)L_MIN(val * normw, 255);\n            SET_DATA_BYTE(line, j, val);\n        }\n        for (j = wmwc; j < w; j++) {   /* last wc columns */\n            wn = wc + w - j;\n            normw = (l_float32)fwc / (l_float32)wn;   /* > 1 */\n            val = GET_DATA_BYTE(line, j);\n            val = (l_uint8)L_MIN(val * normw, 255);\n            SET_DATA_BYTE(line, j, val);\n        }\n    }\n}\n\n\n/*----------------------------------------------------------------------*\n *              Accumulator for 1, 8 and 32 bpp convolution             *\n *----------------------------------------------------------------------*/\n/*!\n * \\brief   pixBlockconvAccum()\n *\n * \\param[in]    pixs    1, 8 or 32 bpp\n * \\return  accum pix 32 bpp, or NULL on error.\n *\n * <pre>\n * Notes:\n *      (1) The general recursion relation is\n *            a(i,j) = v(i,j) + a(i-1, j) + a(i, j-1) - a(i-1, j-1)\n *          For the first line, this reduces to the special case\n *            a(i,j) = v(i,j) + a(i, j-1)\n *          For the first column, the special case is\n *            a(i,j) = v(i,j) + a(i-1, j)\n * </pre>\n */\nPIX *\npixBlockconvAccum(PIX  *pixs)\n{\nl_int32    w, h, d, wpls, wpld;\nl_uint32  *datas, *datad;\nPIX       *pixd;\n\n    PROCNAME(\"pixBlockconvAccum\");\n\n    if (!pixs)\n        return (PIX *)ERROR_PTR(\"pixs not defined\", procName, NULL);\n\n    pixGetDimensions(pixs, &w, &h, &d);\n    if (d != 1 && d != 8 && d != 32)\n        return (PIX *)ERROR_PTR(\"pixs not 1, 8 or 32 bpp\", procName, NULL);\n    if ((pixd = pixCreate(w, h, 32)) == NULL)\n        return (PIX *)ERROR_PTR(\"pixd not made\", procName, NULL);\n\n    datas = pixGetData(pixs);\n    datad = pixGetData(pixd);\n    wpls = pixGetWpl(pixs);\n    wpld = pixGetWpl(pixd);\n    blockconvAccumLow(datad, w, h, wpld, datas, d, wpls);\n\n    return pixd;\n}\n\n\n/*\n * \\brief   blockconvAccumLow()\n *\n * \\param[in]    datad         32 bpp dest\n * \\param[in]    w, h, wpld    of 32 bpp dest\n * \\param[in]    datas         1, 8 or 32 bpp src\n * \\param[in]    d             bpp of src\n * \\param[in]    wpls          of src\n * \\return   void\n *\n * <pre>\n * Notes:\n *      (1) The general recursion relation is\n *             a(i,j) = v(i,j) + a(i-1, j) + a(i, j-1) - a(i-1, j-1)\n *          For the first line, this reduces to the special case\n *             a(0,j) = v(0,j) + a(0, j-1), j > 0\n *          For the first column, the special case is\n *             a(i,0) = v(i,0) + a(i-1, 0), i > 0\n * </pre>\n */\nstatic void\nblockconvAccumLow(l_uint32  *datad,\n                  l_int32    w,\n                  l_int32    h,\n                  l_int32    wpld,\n                  l_uint32  *datas,\n                  l_int32    d,\n                  l_int32    wpls)\n{\nl_uint8    val;\nl_int32    i, j;\nl_uint32   val32;\nl_uint32  *lines, *lined, *linedp;\n\n    PROCNAME(\"blockconvAccumLow\");\n\n    lines = datas;\n    lined = datad;\n\n    if (d == 1) {\n            /* Do the first line */\n        for (j = 0; j < w; j++) {\n            val = GET_DATA_BIT(lines, j);\n            if (j == 0)\n                lined[0] = val;\n            else\n                lined[j] = lined[j - 1] + val;\n        }\n\n            /* Do the other lines */\n        for (i = 1; i < h; i++) {\n            lines = datas + i * wpls;\n            lined = datad + i * wpld;  /* curr dest line */\n            linedp = lined - wpld;   /* prev dest line */\n            for (j = 0; j < w; j++) {\n                val = GET_DATA_BIT(lines, j);\n                if (j == 0)\n                    lined[0] = val + linedp[0];\n                else\n                    lined[j] = val + lined[j - 1] + linedp[j] - linedp[j - 1];\n            }\n        }\n    } else if (d == 8) {\n            /* Do the first line */\n        for (j = 0; j < w; j++) {\n            val = GET_DATA_BYTE(lines, j);\n            if (j == 0)\n                lined[0] = val;\n            else\n                lined[j] = lined[j - 1] + val;\n        }\n\n            /* Do the other lines */\n        for (i = 1; i < h; i++) {\n            lines = datas + i * wpls;\n            lined = datad + i * wpld;  /* curr dest line */\n            linedp = lined - wpld;   /* prev dest line */\n            for (j = 0; j < w; j++) {\n                val = GET_DATA_BYTE(lines, j);\n                if (j == 0)\n                    lined[0] = val + linedp[0];\n                else\n                    lined[j] = val + lined[j - 1] + linedp[j] - linedp[j - 1];\n            }\n        }\n    } else if (d == 32) {\n            /* Do the first line */\n        for (j = 0; j < w; j++) {\n            val32 = lines[j];\n            if (j == 0)\n                lined[0] = val32;\n            else\n                lined[j] = lined[j - 1] + val32;\n        }\n\n            /* Do the other lines */\n        for (i = 1; i < h; i++) {\n            lines = datas + i * wpls;\n            lined = datad + i * wpld;  /* curr dest line */\n            linedp = lined - wpld;   /* prev dest line */\n            for (j = 0; j < w; j++) {\n                val32 = lines[j];\n                if (j == 0)\n                    lined[0] = val32 + linedp[0];\n                else\n                    lined[j] = val32 + lined[j - 1] + linedp[j] - linedp[j - 1];\n            }\n        }\n    } else {\n        L_ERROR(\"depth not 1, 8 or 32 bpp\\n\", procName);\n    }\n}\n\n\n/*----------------------------------------------------------------------*\n *               Un-normalized grayscale block convolution              *\n *----------------------------------------------------------------------*/\n/*!\n * \\brief   pixBlockconvGrayUnnormalized()\n *\n * \\param[in]    pixs     8 bpp\n * \\param[in]    wc, hc   half width/height of convolution kernel\n * \\return  pix 32 bpp; containing the convolution without normalizing\n *                   for the window size, or NULL on error\n *\n * <pre>\n * Notes:\n *      (1) The full width and height of the convolution kernel\n *          are (2 * wc + 1) and (2 * hc + 1).\n *      (2) Require that w >= 2 * wc + 1 and h >= 2 * hc + 1,\n *          where (w,h) are the dimensions of pixs.\n *      (3) Returns a copy if either wc or hc are 0.\n *      (3) Adds mirrored border to avoid treating the boundary pixels\n *          specially.  Note that we add wc + 1 pixels to the left\n *          and wc to the right.  The added width is 2 * wc + 1 pixels,\n *          and the particular choice simplifies the indexing in the loop.\n *          Likewise, add hc + 1 pixels to the top and hc to the bottom.\n *      (4) To get the normalized result, divide by the area of the\n *          convolution kernel: (2 * wc + 1) * (2 * hc + 1)\n *          Specifically, do this:\n *               pixc = pixBlockconvGrayUnnormalized(pixs, wc, hc);\n *               fract = 1. / ((2 * wc + 1) * (2 * hc + 1));\n *               pixMultConstantGray(pixc, fract);\n *               pixd = pixGetRGBComponent(pixc, L_ALPHA_CHANNEL);\n *      (5) Unlike pixBlockconvGray(), this always computes the accumulation\n *          pix because its size is tied to wc and hc.\n *      (6) Compare this implementation with pixBlockconvGray(), where\n *          most of the code in blockconvLow() is special casing for\n *          efficiently handling the boundary.  Here, the use of\n *          mirrored borders and destination indexing makes the\n *          implementation very simple.\n * </pre>\n */\nPIX *\npixBlockconvGrayUnnormalized(PIX     *pixs,\n                             l_int32  wc,\n                             l_int32  hc)\n{\nl_int32    i, j, w, h, d, wpla, wpld, jmax;\nl_uint32  *linemina, *linemaxa, *lined, *dataa, *datad;\nPIX       *pixsb, *pixacc, *pixd;\n\n    PROCNAME(\"pixBlockconvGrayUnnormalized\");\n\n    if (!pixs)\n        return (PIX *)ERROR_PTR(\"pixs not defined\", procName, NULL);\n    pixGetDimensions(pixs, &w, &h, &d);\n    if (d != 8)\n        return (PIX *)ERROR_PTR(\"pixs not 8 bpp\", procName, NULL);\n    if (wc <= 0 || hc <= 0)  /* no-op */\n        return pixCopy(NULL, pixs);\n    if (w < 2 * wc + 1 || h < 2 * hc + 1) {\n        L_ERROR(\"kernel is too large: w = %d, wc = %d, h = %d, hc = %d\\n\",\n                procName, w, wc, h, hc);\n        return pixCopy(NULL, pixs);\n    }\n\n    if ((pixsb = pixAddMirroredBorder(pixs, wc + 1, wc, hc + 1, hc)) == NULL)\n        return (PIX *)ERROR_PTR(\"pixsb not made\", procName, NULL);\n    pixacc = pixBlockconvAccum(pixsb);\n    pixDestroy(&pixsb);\n    if (!pixacc)\n        return (PIX *)ERROR_PTR(\"pixacc not made\", procName, NULL);\n    if ((pixd = pixCreate(w, h, 32)) == NULL) {\n        pixDestroy(&pixacc);\n        return (PIX *)ERROR_PTR(\"pixd not made\", procName, NULL);\n    }\n\n    wpla = pixGetWpl(pixacc);\n    wpld = pixGetWpl(pixd);\n    datad = pixGetData(pixd);\n    dataa = pixGetData(pixacc);\n    for (i = 0; i < h; i++) {\n        lined = datad + i * wpld;\n        linemina = dataa + i * wpla;\n        linemaxa = dataa + (i + 2 * hc + 1) * wpla;\n        for (j = 0; j < w; j++) {\n            jmax = j + 2 * wc + 1;\n            lined[j] = linemaxa[jmax] - linemaxa[j] -\n                       linemina[jmax] + linemina[j];\n        }\n    }\n\n    pixDestroy(&pixacc);\n    return pixd;\n}\n\n\n/*----------------------------------------------------------------------*\n *               Tiled grayscale or color block convolution             *\n *----------------------------------------------------------------------*/\n/*!\n * \\brief   pixBlockconvTiled()\n *\n * \\param[in]    pix      8 or 32 bpp; or 2, 4 or 8 bpp with colormap\n * \\param[in]    wc, hc   half width/height of convolution kernel\n * \\param[in]    nx, ny   subdivision into tiles\n * \\return  pixd, or NULL on error\n *\n * <pre>\n * Notes:\n *      (1) The full width and height of the convolution kernel\n *          are (2 * wc + 1) and (2 * hc + 1)\n *      (2) Returns a copy if either wc or hc are 0.\n *      (3) Require that w >= 2 * wc + 1 and h >= 2 * hc + 1,\n *          where (w,h) are the dimensions of pixs.  Otherwise,\n *          return a copy.\n *      (4) For nx == ny == 1, this defaults to pixBlockconv(), which\n *          is typically about twice as fast, and gives nearly\n *          identical results as pixBlockconvGrayTile().\n *      (5) If the tiles are too small, nx and/or ny are reduced\n *          a minimum amount so that the tiles are expanded to the\n *          smallest workable size in the problematic direction(s).\n *      (6) Why a tiled version?  Three reasons:\n *          (a) Because the accumulator is a uint32, overflow can occur\n *              for an image with more than 16M pixels.\n *          (b) The accumulator array for 16M pixels is 64 MB; using\n *              tiles reduces the size of this array.\n *          (c) Each tile can be processed independently, in parallel,\n *              on a multicore processor.\n * </pre>\n */\nPIX *\npixBlockconvTiled(PIX     *pix,\n                  l_int32  wc,\n                  l_int32  hc,\n                  l_int32  nx,\n                  l_int32  ny)\n{\nl_int32     i, j, w, h, d, xrat, yrat;\nPIX        *pixs, *pixd, *pixc, *pixt;\nPIX        *pixr, *pixrc, *pixg, *pixgc, *pixb, *pixbc;\nPIXTILING  *pt;\n\n    PROCNAME(\"pixBlockconvTiled\");\n\n    if (!pix)\n        return (PIX *)ERROR_PTR(\"pix not defined\", procName, NULL);\n    if (wc <= 0 || hc <= 0)   /* no-op */\n        return pixCopy(NULL, pix);\n    if (nx <= 1 && ny <= 1)\n        return pixBlockconv(pix, wc, hc);\n    pixGetDimensions(pix, &w, &h, &d);\n    if (w < 2 * wc + 3 || h < 2 * hc + 3) {\n        L_ERROR(\"kernel is too large: w = %d, wc = %d, h = %d, hc = %d\\n\",\n                procName, w, wc, h, hc);\n        return pixCopy(NULL, pix);\n    }\n\n        /* Test to see if the tiles are too small.  The required\n         * condition is that the tile dimensions must be at least\n         * (wc + 2) x (hc + 2). */\n    xrat = w / nx;\n    yrat = h / ny;\n    if (xrat < wc + 2) {\n        nx = w / (wc + 2);\n        L_WARNING(\"tile width too small; nx reduced to %d\\n\", procName, nx);\n    }\n    if (yrat < hc + 2) {\n        ny = h / (hc + 2);\n        L_WARNING(\"tile height too small; ny reduced to %d\\n\", procName, ny);\n    }\n\n        /* Remove colormap if necessary */\n    if ((d == 2 || d == 4 || d == 8) && pixGetColormap(pix)) {\n        L_WARNING(\"pix has colormap; removing\\n\", procName);\n        pixs = pixRemoveColormap(pix, REMOVE_CMAP_BASED_ON_SRC);\n        d = pixGetDepth(pixs);\n    } else {\n        pixs = pixClone(pix);\n    }\n\n    if (d != 8 && d != 32) {\n        pixDestroy(&pixs);\n        return (PIX *)ERROR_PTR(\"depth not 8 or 32 bpp\", procName, NULL);\n    }\n\n       /* Note that the overlaps in the width and height that\n        * are added to the tile are (wc + 2) and (hc + 2).\n        * These overlaps are removed by pixTilingPaintTile().\n        * They are larger than the extent of the filter because\n        * although the filter is symmetric with respect to its origin,\n        * the implementation is asymmetric -- see the implementation in\n        * pixBlockconvGrayTile(). */\n    if ((pixd = pixCreateTemplate(pixs)) == NULL) {\n        pixDestroy(&pixs);\n        return (PIX *)ERROR_PTR(\"pixd not made\", procName, NULL);\n    }\n    pt = pixTilingCreate(pixs, nx, ny, 0, 0, wc + 2, hc + 2);\n    for (i = 0; i < ny; i++) {\n        for (j = 0; j < nx; j++) {\n            pixt = pixTilingGetTile(pt, i, j);\n\n                /* Convolve over the tile */\n            if (d == 8) {\n                pixc = pixBlockconvGrayTile(pixt, NULL, wc, hc);\n            } else { /* d == 32 */\n                pixr = pixGetRGBComponent(pixt, COLOR_RED);\n                pixrc = pixBlockconvGrayTile(pixr, NULL, wc, hc);\n                pixDestroy(&pixr);\n                pixg = pixGetRGBComponent(pixt, COLOR_GREEN);\n                pixgc = pixBlockconvGrayTile(pixg, NULL, wc, hc);\n                pixDestroy(&pixg);\n                pixb = pixGetRGBComponent(pixt, COLOR_BLUE);\n                pixbc = pixBlockconvGrayTile(pixb, NULL, wc, hc);\n                pixDestroy(&pixb);\n                pixc = pixCreateRGBImage(pixrc, pixgc, pixbc);\n                pixDestroy(&pixrc);\n                pixDestroy(&pixgc);\n                pixDestroy(&pixbc);\n            }\n\n            pixTilingPaintTile(pixd, i, j, pixc, pt);\n            pixDestroy(&pixt);\n            pixDestroy(&pixc);\n        }\n    }\n\n    pixDestroy(&pixs);\n    pixTilingDestroy(&pt);\n    return pixd;\n}\n\n\n/*!\n * \\brief   pixBlockconvGrayTile()\n *\n * \\param[in]    pixs     8 bpp gray\n * \\param[in]    pixacc   32 bpp accum pix\n * \\param[in]    wc, hc   half width/height of convolution kernel\n * \\return  pixd, or NULL on error\n *\n * <pre>\n * Notes:\n *      (1) The full width and height of the convolution kernel\n *          are (2 * wc + 1) and (2 * hc + 1)\n *      (2) Assumes that the input pixs is padded with (wc + 1) pixels on\n *          left and right, and with (hc + 1) pixels on top and bottom.\n *          The returned pix has these stripped off; they are only used\n *          for computation.\n *      (3) Returns a copy if either wc or hc are 0.\n *      (4) Require that w > 2 * wc + 3 and h > 2 * hc + 3,\n *          where (w,h) are the dimensions of pixs.  Otherwise,\n *          return a copy.\n * </pre>\n */\nPIX *\npixBlockconvGrayTile(PIX     *pixs,\n                     PIX     *pixacc,\n                     l_int32  wc,\n                     l_int32  hc)\n{\nl_int32    w, h, d, wd, hd, i, j, imin, imax, jmin, jmax, wplt, wpld;\nl_float32  norm;\nl_uint32   val;\nl_uint32  *datat, *datad, *lined, *linemint, *linemaxt;\nPIX       *pixt, *pixd;\n\n    PROCNAME(\"pixBlockconvGrayTile\");\n\n    if (!pixs)\n        return (PIX *)ERROR_PTR(\"pix not defined\", procName, NULL);\n    pixGetDimensions(pixs, &w, &h, &d);\n    if (d != 8)\n        return (PIX *)ERROR_PTR(\"pixs not 8 bpp\", procName, NULL);\n    if (wc <= 0 || hc <= 0)  /* no-op */\n        return pixCopy(NULL, pixs);\n    if (w < 2 * wc + 3 || h < 2 * hc + 3) {\n        L_ERROR(\"kernel is too large: w = %d, wc = %d, h = %d, hc = %d\\n\",\n                procName, w, wc, h, hc);\n        return pixCopy(NULL, pixs);\n    }\n    wd = w - 2 * wc;\n    hd = h - 2 * hc;\n\n    if (pixacc) {\n        if (pixGetDepth(pixacc) == 32) {\n            pixt = pixClone(pixacc);\n        } else {\n            L_WARNING(\"pixacc not 32 bpp; making new one\\n\", procName);\n            if ((pixt = pixBlockconvAccum(pixs)) == NULL)\n                return (PIX *)ERROR_PTR(\"pixt not made\", procName, NULL);\n        }\n    } else {\n        if ((pixt = pixBlockconvAccum(pixs)) == NULL)\n            return (PIX *)ERROR_PTR(\"pixt not made\", procName, NULL);\n    }\n\n    if ((pixd = pixCreateTemplate(pixs)) == NULL) {\n        pixDestroy(&pixt);\n        return (PIX *)ERROR_PTR(\"pixd not made\", procName, NULL);\n    }\n    datat = pixGetData(pixt);\n    wplt = pixGetWpl(pixt);\n    datad = pixGetData(pixd);\n    wpld = pixGetWpl(pixd);\n    norm = 1. / (l_float32)((2 * wc + 1) * (2 * hc + 1));\n\n        /* Do the convolution over the subregion of size (wd - 2, hd - 2),\n         * which exactly corresponds to the size of the subregion that\n         * will be extracted by pixTilingPaintTile().  Note that the\n         * region in which points are computed is not symmetric about\n         * the center of the images; instead the computation in\n         * the accumulator image is shifted up and to the left by 1,\n         * relative to the center, because the 4 accumulator sampling\n         * points are taken at the LL corner of the filter and at 3 other\n         * points that are shifted -wc and -hc to the left and above.  */\n    for (i = hc; i < hc + hd - 2; i++) {\n        imin = L_MAX(i - hc - 1, 0);\n        imax = L_MIN(i + hc, h - 1);\n        lined = datad + i * wpld;\n        linemint = datat + imin * wplt;\n        linemaxt = datat + imax * wplt;\n        for (j = wc; j < wc + wd - 2; j++) {\n            jmin = L_MAX(j - wc - 1, 0);\n            jmax = L_MIN(j + wc, w - 1);\n            val = linemaxt[jmax] - linemaxt[jmin]\n                  + linemint[jmin] - linemint[jmax];\n            val = (l_uint8)(norm * val + 0.5);\n            SET_DATA_BYTE(lined, j, val);\n        }\n    }\n\n    pixDestroy(&pixt);\n    return pixd;\n}\n\n\n/*----------------------------------------------------------------------*\n *     Convolution for mean, mean square, variance and rms deviation    *\n *----------------------------------------------------------------------*/\n/*!\n * \\brief   pixWindowedStats()\n *\n * \\param[in]    pixs        8 bpp grayscale\n * \\param[in]    wc, hc      half width/height of convolution kernel\n * \\param[in]    hasborder   use 1 if it already has (wc + 1 border pixels\n *                           on left and right, and hc + 1 on top and bottom;\n *                           use 0 to add kernel-dependent border)\n * \\param[out]   ppixm       [optional] 8 bpp mean value in window\n * \\param[out]   ppixms      [optional] 32 bpp mean square value in window\n * \\param[out]   pfpixv      [optional] float variance in window\n * \\param[out]   pfpixrv     [optional] float rms deviation from the mean\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *      (1) This is a high-level convenience function for calculating\n *          any or all of these derived images.\n *      (2) If %hasborder = 0, a border is added and the result is\n *          computed over all pixels in pixs.  Otherwise, no border is\n *          added and the border pixels are removed from the output images.\n *      (3) These statistical measures over the pixels in the\n *          rectangular window are:\n *            ~ average value: <p>  (pixm)\n *            ~ average squared value: <p*p> (pixms)\n *            ~ variance: <(p - <p>)*(p - <p>)> = <p*p> - <p>*<p>  (pixv)\n *            ~ square-root of variance: (pixrv)\n *          where the brackets < .. > indicate that the average value is\n *          to be taken over the window.\n *      (4) Note that the variance is just the mean square difference from\n *          the mean value; and the square root of the variance is the\n *          root mean square difference from the mean, sometimes also\n *          called the 'standard deviation'.\n *      (5) The added border, along with the use of an accumulator array,\n *          allows computation without special treatment of pixels near\n *          the image boundary, and runs in a time that is independent\n *          of the size of the convolution kernel.\n * </pre>\n */\nl_ok\npixWindowedStats(PIX     *pixs,\n                 l_int32  wc,\n                 l_int32  hc,\n                 l_int32  hasborder,\n                 PIX    **ppixm,\n                 PIX    **ppixms,\n                 FPIX   **pfpixv,\n                 FPIX   **pfpixrv)\n{\nPIX  *pixb, *pixm, *pixms;\n\n    PROCNAME(\"pixWindowedStats\");\n\n    if (!ppixm && !ppixms && !pfpixv && !pfpixrv)\n        return ERROR_INT(\"no output requested\", procName, 1);\n    if (ppixm) *ppixm = NULL;\n    if (ppixms) *ppixms = NULL;\n    if (pfpixv) *pfpixv = NULL;\n    if (pfpixrv) *pfpixrv = NULL;\n    if (!pixs || pixGetDepth(pixs) != 8)\n        return ERROR_INT(\"pixs not defined or not 8 bpp\", procName, 1);\n    if (wc < 2 || hc < 2)\n        return ERROR_INT(\"wc and hc not >= 2\", procName, 1);\n\n        /* Add border if requested */\n    if (!hasborder)\n        pixb = pixAddBorderGeneral(pixs, wc + 1, wc + 1, hc + 1, hc + 1, 0);\n    else\n        pixb = pixClone(pixs);\n\n    if (!pfpixv && !pfpixrv) {\n        if (ppixm) *ppixm = pixWindowedMean(pixb, wc, hc, 1, 1);\n        if (ppixms) *ppixms = pixWindowedMeanSquare(pixb, wc, hc, 1);\n        pixDestroy(&pixb);\n        return 0;\n    }\n\n    pixm = pixWindowedMean(pixb, wc, hc, 1, 1);\n    pixms = pixWindowedMeanSquare(pixb, wc, hc, 1);\n    pixWindowedVariance(pixm, pixms, pfpixv, pfpixrv);\n    if (ppixm)\n        *ppixm = pixm;\n    else\n        pixDestroy(&pixm);\n    if (ppixms)\n        *ppixms = pixms;\n    else\n        pixDestroy(&pixms);\n    pixDestroy(&pixb);\n    return 0;\n}\n\n\n/*!\n * \\brief   pixWindowedMean()\n *\n * \\param[in]    pixs        8 or 32 bpp grayscale\n * \\param[in]    wc, hc      half width/height of convolution kernel\n * \\param[in]    hasborder   use 1 if it already has (wc + 1 border pixels\n *                           on left and right, and hc + 1 on top and bottom;\n *                           use 0 to add kernel-dependent border)\n * \\param[in]    normflag    1 for normalization to get average in window;\n *                           0 for the sum in the window (un-normalized)\n * \\return  pixd 8 or 32 bpp, average over kernel window\n *\n * <pre>\n * Notes:\n *      (1) The input and output depths are the same.\n *      (2) A set of border pixels of width (wc + 1) on left and right,\n *          and of height (hc + 1) on top and bottom, must be on the\n *          pix before the accumulator is found.  The output pixd\n *          (after convolution) has this border removed.\n *          If %hasborder = 0, the required border is added.\n *      (3) Typically, %normflag == 1.  However, if you want the sum\n *          within the window, rather than a normalized convolution,\n *          use %normflag == 0.\n *      (4) This builds a block accumulator pix, uses it here, and\n *          destroys it.\n *      (5) The added border, along with the use of an accumulator array,\n *          allows computation without special treatment of pixels near\n *          the image boundary, and runs in a time that is independent\n *          of the size of the convolution kernel.\n * </pre>\n */\nPIX *\npixWindowedMean(PIX     *pixs,\n                l_int32  wc,\n                l_int32  hc,\n                l_int32  hasborder,\n                l_int32  normflag)\n{\nl_int32    i, j, w, h, d, wd, hd, wplc, wpld, wincr, hincr;\nl_uint32   val;\nl_uint32  *datac, *datad, *linec1, *linec2, *lined;\nl_float32  norm;\nPIX       *pixb, *pixc, *pixd;\n\n    PROCNAME(\"pixWindowedMean\");\n\n    if (!pixs)\n        return (PIX *)ERROR_PTR(\"pixs not defined\", procName, NULL);\n    d = pixGetDepth(pixs);\n    if (d != 8 && d != 32)\n        return (PIX *)ERROR_PTR(\"pixs not 8 or 32 bpp\", procName, NULL);\n    if (wc < 2 || hc < 2)\n        return (PIX *)ERROR_PTR(\"wc and hc not >= 2\", procName, NULL);\n\n    pixb = pixc = pixd = NULL;\n\n        /* Add border if requested */\n    if (!hasborder)\n        pixb = pixAddBorderGeneral(pixs, wc + 1, wc + 1, hc + 1, hc + 1, 0);\n    else\n        pixb = pixClone(pixs);\n\n        /* Make the accumulator pix from pixb */\n    if ((pixc = pixBlockconvAccum(pixb)) == NULL) {\n        L_ERROR(\"pixc not made\\n\", procName);\n        goto cleanup;\n    }\n    wplc = pixGetWpl(pixc);\n    datac = pixGetData(pixc);\n\n        /* The output has wc + 1 border pixels stripped from each side\n         * of pixb, and hc + 1 border pixels stripped from top and bottom. */\n    pixGetDimensions(pixb, &w, &h, NULL);\n    wd = w - 2 * (wc + 1);\n    hd = h - 2 * (hc + 1);\n    if (wd < 2 || hd < 2) {\n        L_ERROR(\"w or h is too small for the kernel\\n\", procName);\n        goto cleanup;\n    }\n    if ((pixd = pixCreate(wd, hd, d)) == NULL) {\n        L_ERROR(\"pixd not made\\n\", procName);\n        goto cleanup;\n    }\n    wpld = pixGetWpl(pixd);\n    datad = pixGetData(pixd);\n\n    wincr = 2 * wc + 1;\n    hincr = 2 * hc + 1;\n    norm = 1.0;  /* use this for sum-in-window */\n    if (normflag)\n        norm = 1.0 / ((l_float32)(wincr) * hincr);\n    for (i = 0; i < hd; i++) {\n        linec1 = datac + i * wplc;\n        linec2 = datac + (i + hincr) * wplc;\n        lined = datad + i * wpld;\n        for (j = 0; j < wd; j++) {\n            val = linec2[j + wincr] - linec2[j] - linec1[j + wincr] + linec1[j];\n            if (d == 8) {\n                val = (l_uint8)(norm * val);\n                SET_DATA_BYTE(lined, j, val);\n            } else {  /* d == 32 */\n                val = (l_uint32)(norm * val);\n                lined[j] = val;\n            }\n        }\n    }\n\ncleanup:\n    pixDestroy(&pixb);\n    pixDestroy(&pixc);\n    return pixd;\n}\n\n\n/*!\n * \\brief   pixWindowedMeanSquare()\n *\n * \\param[in]    pixs        8 bpp grayscale\n * \\param[in]    wc, hc      half width/height of convolution kernel\n * \\param[in]    hasborder   use 1 if it already has (wc + 1 border pixels\n *                           on left and right, and hc + 1 on top and bottom;\n *                           use 0 to add kernel-dependent border)\n * \\return  pixd    32 bpp, average over rectangular window of\n *                  width = 2 * wc + 1 and height = 2 * hc + 1\n *\n * <pre>\n * Notes:\n *      (1) A set of border pixels of width (wc + 1) on left and right,\n *          and of height (hc + 1) on top and bottom, must be on the\n *          pix before the accumulator is found.  The output pixd\n *          (after convolution) has this border removed.\n *          If %hasborder = 0, the required border is added.\n *      (2) The advantage is that we are unaffected by the boundary, and\n *          it is not necessary to treat pixels within %wc and %hc of the\n *          border differently.  This is because processing for pixd\n *          only takes place for pixels in pixs for which the\n *          kernel is entirely contained in pixs.\n *      (3) Why do we have an added border of width (%wc + 1) and\n *          height (%hc + 1), when we only need %wc and %hc pixels\n *          to satisfy this condition?  Answer: the accumulators\n *          are asymmetric, requiring an extra row and column of\n *          pixels at top and left to work accurately.\n *      (4) The added border, along with the use of an accumulator array,\n *          allows computation without special treatment of pixels near\n *          the image boundary, and runs in a time that is independent\n *          of the size of the convolution kernel.\n * </pre>\n */\nPIX *\npixWindowedMeanSquare(PIX     *pixs,\n                      l_int32  wc,\n                      l_int32  hc,\n                      l_int32  hasborder)\n{\nl_int32     i, j, w, h, wd, hd, wpl, wpld, wincr, hincr;\nl_uint32    ival;\nl_uint32   *datad, *lined;\nl_float64   norm;\nl_float64   val;\nl_float64  *data, *line1, *line2;\nDPIX       *dpix;\nPIX        *pixb, *pixd;\n\n    PROCNAME(\"pixWindowedMeanSquare\");\n\n    if (!pixs || (pixGetDepth(pixs) != 8))\n        return (PIX *)ERROR_PTR(\"pixs undefined or not 8 bpp\", procName, NULL);\n    if (wc < 2 || hc < 2)\n        return (PIX *)ERROR_PTR(\"wc and hc not >= 2\", procName, NULL);\n\n    pixd = NULL;\n\n        /* Add border if requested */\n    if (!hasborder)\n        pixb = pixAddBorderGeneral(pixs, wc + 1, wc + 1, hc + 1, hc + 1, 0);\n    else\n        pixb = pixClone(pixs);\n\n    if ((dpix = pixMeanSquareAccum(pixb)) == NULL) {\n        L_ERROR(\"dpix not made\\n\", procName);\n        goto cleanup;\n    }\n    wpl = dpixGetWpl(dpix);\n    data = dpixGetData(dpix);\n\n        /* The output has wc + 1 border pixels stripped from each side\n         * of pixb, and hc + 1 border pixels stripped from top and bottom. */\n    pixGetDimensions(pixb, &w, &h, NULL);\n    wd = w - 2 * (wc + 1);\n    hd = h - 2 * (hc + 1);\n    if (wd < 2 || hd < 2) {\n        L_ERROR(\"w or h too small for kernel\\n\", procName);\n        goto cleanup;\n    }\n    if ((pixd = pixCreate(wd, hd, 32)) == NULL) {\n        L_ERROR(\"pixd not made\\n\", procName);\n        goto cleanup;\n    }\n    wpld = pixGetWpl(pixd);\n    datad = pixGetData(pixd);\n\n    wincr = 2 * wc + 1;\n    hincr = 2 * hc + 1;\n    norm = 1.0 / ((l_float32)(wincr) * hincr);\n    for (i = 0; i < hd; i++) {\n        line1 = data + i * wpl;\n        line2 = data + (i + hincr) * wpl;\n        lined = datad + i * wpld;\n        for (j = 0; j < wd; j++) {\n            val = line2[j + wincr] - line2[j] - line1[j + wincr] + line1[j];\n            ival = (l_uint32)(norm * val + 0.5);  /* to round up */\n            lined[j] = ival;\n        }\n    }\n\ncleanup:\n    dpixDestroy(&dpix);\n    pixDestroy(&pixb);\n    return pixd;\n}\n\n\n/*!\n * \\brief   pixWindowedVariance()\n *\n * \\param[in]    pixm      mean over window; 8 or 32 bpp grayscale\n * \\param[in]    pixms     mean square over window; 32 bpp\n * \\param[out]   pfpixv    [optional] float variance -- the ms deviation\n *                         from the mean\n * \\param[out]   pfpixrv   [optional] float rms deviation from the mean\n * \\return  0 if OK, 1 on error\n *\n * <pre>\n * Notes:\n *      (1) The mean and mean square values are precomputed, using\n *          pixWindowedMean() and pixWindowedMeanSquare().\n *      (2) Either or both of the variance and square-root of variance\n *          are returned as an fpix, where the variance is the\n *          average over the window of the mean square difference of\n *          the pixel value from the mean:\n *                <(p - <p>)*(p - <p>)> = <p*p> - <p>*<p>\n *      (3) To visualize the results:\n *            ~ for both, use fpixDisplayMaxDynamicRange().\n *            ~ for rms deviation, simply convert the output fpix to pix,\n * </pre>\n */\nl_ok\npixWindowedVariance(PIX    *pixm,\n                    PIX    *pixms,\n                    FPIX  **pfpixv,\n                    FPIX  **pfpixrv)\n{\nl_int32     i, j, w, h, ws, hs, ds, wplm, wplms, wplv, wplrv, valm, valms;\nl_float32   var;\nl_uint32   *linem, *linems, *datam, *datams;\nl_float32  *linev, *linerv, *datav, *datarv;\nFPIX       *fpixv, *fpixrv;  /* variance and square root of variance */\n\n    PROCNAME(\"pixWindowedVariance\");\n\n    if (!pfpixv && !pfpixrv)\n        return ERROR_INT(\"no output requested\", procName, 1);\n    if (pfpixv) *pfpixv = NULL;\n    if (pfpixrv) *pfpixrv = NULL;\n    if (!pixm || pixGetDepth(pixm) != 8)\n        return ERROR_INT(\"pixm undefined or not 8 bpp\", procName, 1);\n    if (!pixms || pixGetDepth(pixms) != 32)\n        return ERROR_INT(\"pixms undefined or not 32 bpp\", procName, 1);\n    pixGetDimensions(pixm, &w, &h, NULL);\n    pixGetDimensions(pixms, &ws, &hs, &ds);\n    if (w != ws || h != hs)\n        return ERROR_INT(\"pixm and pixms sizes differ\", procName, 1);\n\n    if (pfpixv) {\n        fpixv = fpixCreate(w, h);\n        *pfpixv = fpixv;\n        wplv = fpixGetWpl(fpixv);\n        datav = fpixGetData(fpixv);\n    }\n    if (pfpixrv) {\n        fpixrv = fpixCreate(w, h);\n        *pfpixrv = fpixrv;\n        wplrv = fpixGetWpl(fpixrv);\n        datarv = fpixGetData(fpixrv);\n    }\n\n    wplm = pixGetWpl(pixm);\n    wplms = pixGetWpl(pixms);\n    datam = pixGetData(pixm);\n    datams = pixGetData(pixms);\n    for (i = 0; i < h; i++) {\n        linem = datam + i * wplm;\n        linems = datams + i * wplms;\n        if (pfpixv)\n            linev = datav + i * wplv;\n        if (pfpixrv)\n            linerv = datarv + i * wplrv;\n        for (j = 0; j < w; j++) {\n            valm = GET_DATA_BYTE(linem, j);\n            if (ds == 8)\n                valms = GET_DATA_BYTE(linems, j);\n            else  /* ds == 32 */\n                valms = (l_int32)linems[j];\n            var = (l_float32)valms - (l_float32)valm * valm;\n            if (pfpixv)\n                linev[j] = var;\n            if (pfpixrv)\n                linerv[j] = (l_float32)sqrt(var);\n        }\n    }\n\n    return 0;\n}\n\n\n/*!\n * \\brief   pixMeanSquareAccum()\n *\n * \\param[in]    pixs    8 bpp grayscale\n * \\return  dpix   64 bit array, or NULL on error\n *\n * <pre>\n * Notes:\n *      (1) Similar to pixBlockconvAccum(), this computes the\n *          sum of the squares of the pixel values in such a way\n *          that the value at (i,j) is the sum of all squares in\n *          the rectangle from the origin to (i,j).\n *      (2) The general recursion relation (v are squared pixel values) is\n *            a(i,j) = v(i,j) + a(i-1, j) + a(i, j-1) - a(i-1, j-1)\n *          For the first line, this reduces to the special case\n *            a(i,j) = v(i,j) + a(i, j-1)\n *          For the first column, the special case is\n *            a(i,j) = v(i,j) + a(i-1, j)\n * </pre>\n */\nDPIX *\npixMeanSquareAccum(PIX  *pixs)\n{\nl_int32     i, j, w, h, wpl, wpls, val;\nl_uint32   *datas, *lines;\nl_float64  *data, *line, *linep;\nDPIX       *dpix;\n\n    PROCNAME(\"pixMeanSquareAccum\");\n\n\n    if (!pixs || (pixGetDepth(pixs) != 8))\n        return (DPIX *)ERROR_PTR(\"pixs undefined or not 8 bpp\", procName, NULL);\n    pixGetDimensions(pixs, &w, &h, NULL);\n    if ((dpix = dpixCreate(w, h)) ==  NULL)\n        return (DPIX *)ERROR_PTR(\"dpix not made\", procName, NULL);\n\n    datas = pixGetData(pixs);\n    wpls = pixGetWpl(pixs);\n    data = dpixGetData(dpix);\n    wpl = dpixGetWpl(dpix);\n\n    lines = datas;\n    line = data;\n    for (j = 0; j < w; j++) {   /* first line */\n        val = GET_DATA_BYTE(lines, j);\n        if (j == 0)\n            line[0] = (l_float64)(val) * val;\n        else\n            line[j] = line[j - 1] + (l_float64)(val) * val;\n    }\n\n        /* Do the other lines */\n    for (i = 1; i < h; i++) {\n        lines = datas + i * wpls;\n        line = data + i * wpl;  /* current dest line */\n        linep = line - wpl;;  /* prev dest line */\n        for (j = 0; j < w; j++) {\n            val = GET_DATA_BYTE(lines, j);\n            if (j == 0)\n                line[0] = linep[0] + (l_float64)(val) * val;\n            else\n                line[j] = line[j - 1] + linep[j] - linep[j - 1]\n                        + (l_float64)(val) * val;\n        }\n    }\n\n    return dpix;\n}\n\n\n/*----------------------------------------------------------------------*\n *                        Binary block sum/rank                         *\n *----------------------------------------------------------------------*/\n/*!\n * \\brief   pixBlockrank()\n *\n * \\param[in]    pixs     1 bpp\n * \\param[in]    pixacc   pix [optional] 32 bpp\n * \\param[in]    wc, hc   half width/height of block sum/rank kernel\n * \\param[in]    rank     between 0.0 and 1.0; 0.5 is median filter\n * \\return  pixd 1 bpp\n *\n * <pre>\n * Notes:\n *      (1) The full width and height of the convolution kernel\n *          are (2 * wc + 1) and (2 * hc + 1)\n *      (2) This returns a pixd where each pixel is a 1 if the\n *          neighborhood (2 * wc + 1) x (2 * hc + 1)) pixels\n *          contains the rank fraction of 1 pixels.  Otherwise,\n *          the returned pixel is 0.  Note that the special case\n *          of rank = 0.0 is always satisfied, so the returned\n *          pixd has all pixels with value 1.\n *      (3) If accum pix is null, make one, use it, and destroy it\n *          before returning; otherwise, just use the input accum pix\n *      (4) If both wc and hc are 0, returns a copy unless rank == 0.0,\n *          in which case this returns an all-ones image.\n *      (5) Require that w >= 2 * wc + 1 and h >= 2 * hc + 1,\n *          where (w,h) are the dimensions of pixs.\n * </pre>\n */\nPIX *\npixBlockrank(PIX       *pixs,\n             PIX       *pixacc,\n             l_int32    wc,\n             l_int32    hc,\n             l_float32  rank)\n{\nl_int32  w, h, d, thresh;\nPIX     *pixt, *pixd;\n\n    PROCNAME(\"pixBlockrank\");\n\n    if (!pixs)\n        return (PIX *)ERROR_PTR(\"pixs not defined\", procName, NULL);\n    pixGetDimensions(pixs, &w, &h, &d);\n    if (d != 1)\n        return (PIX *)ERROR_PTR(\"pixs not 1 bpp\", procName, NULL);\n    if (rank < 0.0 || rank > 1.0)\n        return (PIX *)ERROR_PTR(\"rank must be in [0.0, 1.0]\", procName, NULL);\n\n    if (rank == 0.0) {\n        pixd = pixCreateTemplate(pixs);\n        pixSetAll(pixd);\n        return pixd;\n    }\n\n    if (wc < 0) wc = 0;\n    if (hc < 0) hc = 0;\n    if (w < 2 * wc + 1 || h < 2 * hc + 1) {\n        wc = L_MIN(wc, (w - 1) / 2);\n        hc = L_MIN(hc, (h - 1) / 2);\n        L_WARNING(\"kernel too large; reducing!\\n\", procName);\n        L_INFO(\"wc = %d, hc = %d\\n\", procName, wc, hc);\n    }\n    if (wc == 0 && hc == 0)\n        return pixCopy(NULL, pixs);\n\n    if ((pixt = pixBlocksum(pixs, pixacc, wc, hc)) == NULL)\n        return (PIX *)ERROR_PTR(\"pixt not made\", procName, NULL);\n\n        /* 1 bpp block rank filter output.\n         * Must invert because threshold gives 1 for values < thresh,\n         * but we need a 1 if the value is >= thresh. */\n    thresh = (l_int32)(255. * rank);\n    pixd = pixThresholdToBinary(pixt, thresh);\n    pixInvert(pixd, pixd);\n    pixDestroy(&pixt);\n    return pixd;\n}\n\n\n/*!\n * \\brief   pixBlocksum()\n *\n * \\param[in]    pixs     1 bpp\n * \\param[in]    pixacc   pix [optional] 32 bpp\n * \\param[in]    wc, hc   half width/height of block sum/rank kernel\n * \\return  pixd 8 bpp\n *\n * <pre>\n * Notes:\n *      (1) If accum pix is null, make one and destroy it before\n *          returning; otherwise, just use the input accum pix\n *      (2) The full width and height of the convolution kernel\n *          are (2 * wc + 1) and (2 * hc + 1)\n *      (3) Use of wc = hc = 1, followed by pixInvert() on the\n *          8 bpp result, gives a nice anti-aliased, and somewhat\n *          darkened, result on text.\n *      (4) Require that w >= 2 * wc + 1 and h >= 2 * hc + 1,\n *          where (w,h) are the dimensions of pixs.\n *      (5) Returns in each dest pixel the sum of all src pixels\n *          that are within a block of size of the kernel, centered\n *          on the dest pixel.  This sum is the number of src ON\n *          pixels in the block at each location, normalized to 255\n *          for a block containing all ON pixels.  For pixels near\n *          the boundary, where the block is not entirely contained\n *          within the image, we then multiply by a second normalization\n *          factor that is greater than one, so that all results\n *          are normalized by the number of participating pixels\n *          within the block.\n * </pre>\n */\nPIX *\npixBlocksum(PIX     *pixs,\n            PIX     *pixacc,\n            l_int32  wc,\n            l_int32  hc)\n{\nl_int32    w, h, d, wplt, wpld;\nl_uint32  *datat, *datad;\nPIX       *pixt, *pixd;\n\n    PROCNAME(\"pixBlocksum\");\n\n    if (!pixs)\n        return (PIX *)ERROR_PTR(\"pixs not defined\", procName, NULL);\n    pixGetDimensions(pixs, &w, &h, &d);\n    if (d != 1)\n        return (PIX *)ERROR_PTR(\"pixs not 1 bpp\", procName, NULL);\n    if (wc < 0) wc = 0;\n    if (hc < 0) hc = 0;\n    if (w < 2 * wc + 1 || h < 2 * hc + 1) {\n        wc = L_MIN(wc, (w - 1) / 2);\n        hc = L_MIN(hc, (h - 1) / 2);\n        L_WARNING(\"kernel too large; reducing!\\n\", procName);\n        L_INFO(\"wc = %d, hc = %d\\n\", procName, wc, hc);\n    }\n    if (wc == 0 && hc == 0)\n        return pixCopy(NULL, pixs);\n\n    if (pixacc) {\n        if (pixGetDepth(pixacc) != 32)\n            return (PIX *)ERROR_PTR(\"pixacc not 32 bpp\", procName, NULL);\n        pixt = pixClone(pixacc);\n    } else {\n        if ((pixt = pixBlockconvAccum(pixs)) == NULL)\n            return (PIX *)ERROR_PTR(\"pixt not made\", procName, NULL);\n    }\n\n        /* 8 bpp block sum output */\n    if ((pixd = pixCreate(w, h, 8)) == NULL) {\n        pixDestroy(&pixt);\n        return (PIX *)ERROR_PTR(\"pixd not made\", procName, NULL);\n    }\n    pixCopyResolution(pixd, pixs);\n\n    wpld = pixGetWpl(pixd);\n    wplt = pixGetWpl(pixt);\n    datad = pixGetData(pixd);\n    datat = pixGetData(pixt);\n    blocksumLow(datad, w, h, wpld, datat, wplt, wc, hc);\n\n    pixDestroy(&pixt);\n    return pixd;\n}\n\n\n/*!\n * \\brief   blocksumLow()\n *\n * \\param[in]    datad        of 8 bpp dest\n * \\param[in]    w, h, wpl    of 8 bpp dest\n * \\param[in]    dataa        of 32 bpp accum\n * \\param[in]    wpla         of 32 bpp accum\n * \\param[in]    wc, hc       convolution \"half-width\" and \"half-height\"\n * \\return  void\n *\n * <pre>\n * Notes:\n *      (1) The full width and height of the convolution kernel\n *          are (2 * wc + 1) and (2 * hc + 1).\n *      (2) The lack of symmetry between the handling of the\n *          first (hc + 1) lines and the last (hc) lines,\n *          and similarly with the columns, is due to fact that\n *          for the pixel at (x,y), the accumulator values are\n *          taken at (x + wc, y + hc), (x - wc - 1, y + hc),\n *          (x + wc, y - hc - 1) and (x - wc - 1, y - hc - 1).\n *      (3) Compute sums of ON pixels within the block filter size,\n *          normalized between 0 and 255, as if there were no reduced\n *          area at the boundary.  This under-estimates the value\n *          of the boundary pixels, so we multiply them by another\n *          normalization factor that is greater than 1.\n *      (4) This second normalization is done first for the first\n *          hc + 1 lines; then for the last hc lines; and finally\n *          for the first wc + 1 and last wc columns in the intermediate\n *          lines.\n *      (5) Required constraints are: wc < w and hc < h.\n * </pre>\n */\nstatic void\nblocksumLow(l_uint32  *datad,\n            l_int32    w,\n            l_int32    h,\n            l_int32    wpl,\n            l_uint32  *dataa,\n            l_int32    wpla,\n            l_int32    wc,\n            l_int32    hc)\n{\nl_int32    i, j, imax, imin, jmax, jmin;\nl_int32    wn, hn, fwc, fhc, wmwc, hmhc;\nl_float32  norm, normh, normw;\nl_uint32   val;\nl_uint32  *linemina, *linemaxa, *lined;\n\n    PROCNAME(\"blocksumLow\");\n\n    wmwc = w - wc;\n    hmhc = h - hc;\n    if (wmwc <= 0 || hmhc <= 0) {\n        L_ERROR(\"wc >= w || hc >=h\\n\", procName);\n        return;\n    }\n    fwc = 2 * wc + 1;\n    fhc = 2 * hc + 1;\n    norm = 255. / ((l_float32)(fwc) * fhc);\n\n        /*------------------------------------------------------------*\n         *  Compute, using b.c. only to set limits on the accum image *\n         *------------------------------------------------------------*/\n    for (i = 0; i < h; i++) {\n        imin = L_MAX(i - 1 - hc, 0);\n        imax = L_MIN(i + hc, h - 1);\n        lined = datad + wpl * i;\n        linemina = dataa + wpla * imin;\n        linemaxa = dataa + wpla * imax;\n        for (j = 0; j < w; j++) {\n            jmin = L_MAX(j - 1 - wc, 0);\n            jmax = L_MIN(j + wc, w - 1);\n            val = linemaxa[jmax] - linemaxa[jmin]\n                  - linemina[jmax] + linemina[jmin];\n            val = (l_uint8)(norm * val);\n            SET_DATA_BYTE(lined, j, val);\n        }\n    }\n\n        /*------------------------------------------------------------*\n         *             Fix normalization for boundary pixels          *\n         *------------------------------------------------------------*/\n    for (i = 0; i <= hc; i++) {    /* first hc + 1 lines */\n        hn = hc + i;\n        normh = (l_float32)fhc / (l_float32)hn;   /* > 1 */\n        lined = datad + wpl * i;\n        for (j = 0; j <= wc; j++) {\n            wn = wc + j;\n            normw = (l_float32)fwc / (l_float32)wn;   /* > 1 */\n            val = GET_DATA_BYTE(lined, j);\n            val = (l_uint8)(val * normh * normw);\n            SET_DATA_BYTE(lined, j, val);\n        }\n        for (j = wc + 1; j < wmwc; j++) {\n            val = GET_DATA_BYTE(lined, j);\n            val = (l_uint8)(val * normh);\n            SET_DATA_BYTE(lined, j, val);\n        }\n        for (j = wmwc; j < w; j++) {\n            wn = wc + w - j;\n            normw = (l_float32)fwc / (l_float32)wn;   /* > 1 */\n            val = GET_DATA_BYTE(lined, j);\n            val = (l_uint8)(val * normh * normw);\n            SET_DATA_BYTE(lined, j, val);\n        }\n    }\n\n    for (i = hmhc; i < h; i++) {  /* last hc lines */\n        hn = hc + h - i;\n        normh = (l_float32)fhc / (l_float32)hn;   /* > 1 */\n        lined = datad + wpl * i;\n        for (j = 0; j <= wc; j++) {\n            wn = wc + j;\n            normw = (l_float32)fwc / (l_float32)wn;   /* > 1 */\n            val = GET_DATA_BYTE(lined, j);\n            val = (l_uint8)(val * normh * normw);\n            SET_DATA_BYTE(lined, j, val);\n        }\n        for (j = wc + 1; j < wmwc; j++) {\n            val = GET_DATA_BYTE(lined, j);\n            val = (l_uint8)(val * normh);\n            SET_DATA_BYTE(lined, j, val);\n        }\n        for (j = wmwc; j < w; j++) {\n            wn = wc + w - j;\n            normw = (l_float32)fwc / (l_float32)wn;   /* > 1 */\n            val = GET_DATA_BYTE(lined, j);\n            val = (l_uint8)(val * normh * normw);\n            SET_DATA_BYTE(lined, j, val);\n        }\n    }\n\n    for (i = hc + 1; i < hmhc; i++) {    /* intermediate lines */\n        lined = datad + wpl * i;\n        for (j = 0; j <= wc; j++) {   /* first wc + 1 columns */\n            wn = wc + j;\n            normw = (l_float32)fwc / (l_float32)wn;   /* > 1 */\n            val = GET_DATA_BYTE(lined, j);\n            val = (l_uint8)(val * normw);\n            SET_DATA_BYTE(lined, j, val);\n        }\n        for (j = wmwc; j < w; j++) {   /* last wc columns */\n            wn = wc + w - j;\n            normw = (l_float32)fwc / (l_float32)wn;   /* > 1 */\n            val = GET_DATA_BYTE(lined, j);\n            val = (l_uint8)(val * normw);\n            SET_DATA_BYTE(lined, j, val);\n        }\n    }\n}\n\n\n/*----------------------------------------------------------------------*\n *                          Census transform                            *\n *----------------------------------------------------------------------*/\n/*!\n * \\brief   pixCensusTransform()\n *\n * \\param[in]    pixs       8 bpp\n * \\param[in]    halfsize   of square over which neighbors are averaged\n * \\param[in]    pixacc     [optional] 32 bpp pix\n * \\return  pixd 1 bpp\n *\n * <pre>\n * Notes:\n *      (1) The Census transform was invented by Ramin Zabih and John Woodfill\n *          (\"Non-parametric local transforms for computing visual\n *          correspondence\", Third European Conference on Computer Vision,\n *          Stockholm, Sweden, May 1994); see publications at\n *             http://www.cs.cornell.edu/~rdz/index.htm\n *          This compares each pixel against the average of its neighbors,\n *          in a square of odd dimension centered on the pixel.\n *          If the pixel is greater than the average of its neighbors,\n *          the output pixel value is 1; otherwise it is 0.\n *      (2) This can be used as an encoding for an image that is\n *          fairly robust against slow illumination changes, with\n *          applications in image comparison and mosaicing.\n *      (3) The size of the convolution kernel is (2 * halfsize + 1)\n *          on a side.  The halfsize parameter must be >= 1.\n *      (4) If accum pix is null, make one, use it, and destroy it\n *          before returning; otherwise, just use the input accum pix\n * </pre>\n */\nPIX *\npixCensusTransform(PIX     *pixs,\n                   l_int32  halfsize,\n                   PIX     *pixacc)\n{\nl_int32    i, j, w, h, wpls, wplv, wpld;\nl_int32    vals, valv;\nl_uint32  *datas, *datav, *datad, *lines, *linev, *lined;\nPIX       *pixav, *pixd;\n\n    PROCNAME(\"pixCensusTransform\");\n\n    if (!pixs)\n        return (PIX *)ERROR_PTR(\"pixs not defined\", procName, NULL);\n    if (pixGetDepth(pixs) != 8)\n        return (PIX *)ERROR_PTR(\"pixs not 8 bpp\", procName, NULL);\n    if (halfsize < 1)\n        return (PIX *)ERROR_PTR(\"halfsize must be >= 1\", procName, NULL);\n\n        /* Get the average of each pixel with its neighbors */\n    if ((pixav = pixBlockconvGray(pixs, pixacc, halfsize, halfsize))\n          == NULL)\n        return (PIX *)ERROR_PTR(\"pixav not made\", procName, NULL);\n\n        /* Subtract the pixel from the average, and then compare\n         * the pixel value with the remaining average */\n    pixGetDimensions(pixs, &w, &h, NULL);\n    if ((pixd = pixCreate(w, h, 1)) == NULL) {\n        pixDestroy(&pixav);\n        return (PIX *)ERROR_PTR(\"pixd not made\", procName, NULL);\n    }\n    datas = pixGetData(pixs);\n    datav = pixGetData(pixav);\n    datad = pixGetData(pixd);\n    wpls = pixGetWpl(pixs);\n    wplv = pixGetWpl(pixav);\n    wpld = pixGetWpl(pixd);\n    for (i = 0; i < h; i++) {\n        lines = datas + i * wpls;\n        linev = datav + i * wplv;\n        lined = datad + i * wpld;\n        for (j = 0; j < w; j++) {\n            vals = GET_DATA_BYTE(lines, j);\n            valv = GET_DATA_BYTE(linev, j);\n            if (vals > valv)\n                SET_DATA_BIT(lined, j);\n        }\n    }\n\n    pixDestroy(&pixav);\n    return pixd;\n}\n\n\n/*----------------------------------------------------------------------*\n *                         Generic convolution                          *\n *----------------------------------------------------------------------*/\n/*!\n * \\brief   pixConvolve()\n *\n * \\param[in]    pixs       8, 16, 32 bpp; no colormap\n * \\param[in]    kel        kernel\n * \\param[in]    outdepth   of pixd: 8, 16 or 32\n * \\param[in]    normflag   1 to normalize kernel to unit sum; 0 otherwise\n * \\return  pixd 8, 16 or 32 bpp\n *\n * <pre>\n * Notes:\n *      (1) This gives a convolution with an arbitrary kernel.\n *      (2) The input pixs must have only one sample/pixel.\n *          To do a convolution on an RGB image, use pixConvolveRGB().\n *      (3) The parameter %outdepth determines the depth of the result.\n *          If the kernel is normalized to unit sum, the output values\n *          can never exceed 255, so an output depth of 8 bpp is sufficient.\n *          If the kernel is not normalized, it may be necessary to use\n *          16 or 32 bpp output to avoid overflow.\n *      (4) If normflag == 1, the result is normalized by scaling all\n *          kernel values for a unit sum.  If the sum of kernel values\n *          is very close to zero, the kernel can not be normalized and\n *          the convolution will not be performed.  A warning is issued.\n *      (5) The kernel values can be positive or negative, but the\n *          result for the convolution can only be stored as a positive\n *          number.  Consequently, if it goes negative, the choices are\n *          to clip to 0 or take the absolute value.  We're choosing\n *          to take the absolute value.  (Another possibility would be\n *          to output a second unsigned image for the negative values.)\n *          If you want to get a clipped result, or to keep the negative\n *          values in the result, use fpixConvolve(), with the\n *          converters in fpix2.c between pix and fpix.\n *      (6) This uses a mirrored border to avoid special casing on\n *          the boundaries.\n *      (7) To get a subsampled output, call l_setConvolveSampling().\n *          The time to make a subsampled output is reduced by the\n *          product of the sampling factors.\n *      (8) The function is slow, running at about 12 machine cycles for\n *          each pixel-op in the convolution.  For example, with a 3 GHz\n *          cpu, a 1 Mpixel grayscale image, and a kernel with\n *          (sx * sy) = 25 elements, the convolution takes about 100 msec.\n * </pre>\n */\nPIX *\npixConvolve(PIX       *pixs,\n            L_KERNEL  *kel,\n            l_int32    outdepth,\n            l_int32    normflag)\n{\nl_int32    i, j, id, jd, k, m, w, h, d, wd, hd, sx, sy, cx, cy, wplt, wpld;\nl_int32    val;\nl_uint32  *datat, *datad, *linet, *lined;\nl_float32  sum;\nL_KERNEL  *keli, *keln;\nPIX       *pixt, *pixd;\n\n    PROCNAME(\"pixConvolve\");\n\n    if (!pixs)\n        return (PIX *)ERROR_PTR(\"pixs not defined\", procName, NULL);\n    if (pixGetColormap(pixs))\n        return (PIX *)ERROR_PTR(\"pixs has colormap\", procName, NULL);\n    pixGetDimensions(pixs, &w, &h, &d);\n    if (d != 8 && d != 16 && d != 32)\n        return (PIX *)ERROR_PTR(\"pixs not 8, 16, or 32 bpp\", procName, NULL);\n    if (!kel)\n        return (PIX *)ERROR_PTR(\"kel not defined\", procName, NULL);\n\n    pixd = NULL;\n\n    keli = kernelInvert(kel);\n    kernelGetParameters(keli, &sy, &sx, &cy, &cx);\n    if (normflag)\n        keln = kernelNormalize(keli, 1.0);\n    else\n        keln = kernelCopy(keli);\n\n    if ((pixt = pixAddMirroredBorder(pixs, cx, sx - cx, cy, sy - cy)) == NULL) {\n        L_ERROR(\"pixt not made\\n\", procName);\n        goto cleanup;\n    }\n\n    wd = (w + ConvolveSamplingFactX - 1) / ConvolveSamplingFactX;\n    hd = (h + ConvolveSamplingFactY - 1) / ConvolveSamplingFactY;\n    pixd = pixCreate(wd, hd, outdepth);\n    datat = pixGetData(pixt);\n    datad = pixGetData(pixd);\n    wplt = pixGetWpl(pixt);\n    wpld = pixGetWpl(pixd);\n    for (i = 0, id = 0; id < hd; i += ConvolveSamplingFactY, id++) {\n        lined = datad + id * wpld;\n        for (j = 0, jd = 0; jd < wd; j += ConvolveSamplingFactX, jd++) {\n            sum = 0.0;\n            for (k = 0; k < sy; k++) {\n                linet = datat + (i + k) * wplt;\n                if (d == 8) {\n                    for (m = 0; m < sx; m++) {\n                        val = GET_DATA_BYTE(linet, j + m);\n                        sum += val * keln->data[k][m];\n                    }\n                } else if (d == 16) {\n                    for (m = 0; m < sx; m++) {\n                        val = GET_DATA_TWO_BYTES(linet, j + m);\n                        sum += val * keln->data[k][m];\n                    }\n                } else {  /* d == 32 */\n                    for (m = 0; m < sx; m++) {\n                        val = *(linet + j + m);\n                        sum += val * keln->data[k][m];\n                    }\n                }\n            }\n            if (sum < 0.0) sum = -sum;  /* make it non-negative */\n            if (outdepth == 8)\n                SET_DATA_BYTE(lined, jd, (l_int32)(sum + 0.5));\n            else if (outdepth == 16)\n                SET_DATA_TWO_BYTES(lined, jd, (l_int32)(sum + 0.5));\n            else  /* outdepth == 32 */\n                *(lined + jd) = (l_uint32)(sum + 0.5);\n        }\n    }\n\ncleanup:\n    kernelDestroy(&keli);\n    kernelDestroy(&keln);\n    pixDestroy(&pixt);\n    return pixd;\n}\n\n\n/*!\n * \\brief   pixConvolveSep()\n *\n * \\param[in]    pixs       8, 16, 32 bpp; no colormap\n * \\param[in]    kelx       x-dependent kernel\n * \\param[in]    kely       y-dependent kernel\n * \\param[in]    outdepth   of pixd: 8, 16 or 32\n * \\param[in]    normflag   1 to normalize kernel to unit sum; 0 otherwise\n * \\return  pixd    8, 16 or 32 bpp\n *\n * <pre>\n * Notes:\n *      (1) This does a convolution with a separable kernel that is\n *          is a sequence of convolutions in x and y.  The two\n *          one-dimensional kernel components must be input separately;\n *          the full kernel is the product of these components.\n *          The support for the full kernel is thus a rectangular region.\n *      (2) The input pixs must have only one sample/pixel.\n *          To do a convolution on an RGB image, use pixConvolveSepRGB().\n *      (3) The parameter %outdepth determines the depth of the result.\n *          If the kernel is normalized to unit sum, the output values\n *          can never exceed 255, so an output depth of 8 bpp is sufficient.\n *          If the kernel is not normalized, it may be necessary to use\n *          16 or 32 bpp output to avoid overflow.\n *      (2) The %normflag parameter is used as in pixConvolve().\n *      (4) The kernel values can be positive or negative, but the\n *          result for the convolution can only be stored as a positive\n *          number.  Consequently, if it goes negative, the choices are\n *          to clip to 0 or take the absolute value.  We're choosing\n *          the former for now.  Another possibility would be to output\n *          a second unsigned image for the negative values.\n *      (5) Warning: if you use l_setConvolveSampling() to get a\n *          subsampled output, and the sampling factor is larger than\n *          the kernel half-width, it is faster to use the non-separable\n *          version pixConvolve().  This is because the first convolution\n *          here must be done on every raster line, regardless of the\n *          vertical sampling factor.  If the sampling factor is smaller\n *          than kernel half-width, it's faster to use the separable\n *          convolution.\n *      (6) This uses mirrored borders to avoid special casing on\n *          the boundaries.\n * </pre>\n */\nPIX *\npixConvolveSep(PIX       *pixs,\n               L_KERNEL  *kelx,\n               L_KERNEL  *kely,\n               l_int32    outdepth,\n               l_int32    normflag)\n{\nl_int32    d, xfact, yfact;\nL_KERNEL  *kelxn, *kelyn;\nPIX       *pixt, *pixd;\n\n    PROCNAME(\"pixConvolveSep\");\n\n    if (!pixs)\n        return (PIX *)ERROR_PTR(\"pixs not defined\", procName, NULL);\n    d = pixGetDepth(pixs);\n    if (d != 8 && d != 16 && d != 32)\n        return (PIX *)ERROR_PTR(\"pixs not 8, 16, or 32 bpp\", procName, NULL);\n    if (!kelx)\n        return (PIX *)ERROR_PTR(\"kelx not defined\", procName, NULL);\n    if (!kely)\n        return (PIX *)ERROR_PTR(\"kely not defined\", procName, NULL);\n\n    xfact = ConvolveSamplingFactX;\n    yfact = ConvolveSamplingFactY;\n    if (normflag) {\n        kelxn = kernelNormalize(kelx, 1000.0);\n        kelyn = kernelNormalize(kely, 0.001);\n        l_setConvolveSampling(xfact, 1);\n        pixt = pixConvolve(pixs, kelxn, 32, 0);\n        l_setConvolveSampling(1, yfact);\n        pixd = pixConvolve(pixt, kelyn, outdepth, 0);\n        l_setConvolveSampling(xfact, yfact);  /* restore */\n        kernelDestroy(&kelxn);\n        kernelDestroy(&kelyn);\n    } else {  /* don't normalize */\n        l_setConvolveSampling(xfact, 1);\n        pixt = pixConvolve(pixs, kelx, 32, 0);\n        l_setConvolveSampling(1, yfact);\n        pixd = pixConvolve(pixt, kely, outdepth, 0);\n        l_setConvolveSampling(xfact, yfact);\n    }\n\n    pixDestroy(&pixt);\n    return pixd;\n}\n\n\n/*!\n * \\brief   pixConvolveRGB()\n *\n * \\param[in]    pixs   32 bpp rgb\n * \\param[in]    kel    kernel\n * \\return  pixd   32 bpp rgb\n *\n * <pre>\n * Notes:\n *      (1) This gives a convolution on an RGB image using an\n *          arbitrary kernel (which we normalize to keep each\n *          component within the range [0 ... 255].\n *      (2) The input pixs must be RGB.\n *      (3) The kernel values can be positive or negative, but the\n *          result for the convolution can only be stored as a positive\n *          number.  Consequently, if it goes negative, we clip the\n *          result to 0.\n *      (4) To get a subsampled output, call l_setConvolveSampling().\n *          The time to make a subsampled output is reduced by the\n *          product of the sampling factors.\n *      (5) This uses a mirrored border to avoid special casing on\n *          the boundaries.\n * </pre>\n */\nPIX *\npixConvolveRGB(PIX       *pixs,\n               L_KERNEL  *kel)\n{\nPIX  *pixt, *pixr, *pixg, *pixb, *pixd;\n\n    PROCNAME(\"pixConvolveRGB\");\n\n    if (!pixs)\n        return (PIX *)ERROR_PTR(\"pixs not defined\", procName, NULL);\n    if (pixGetDepth(pixs) != 32)\n        return (PIX *)ERROR_PTR(\"pixs is not 32 bpp\", procName, NULL);\n    if (!kel)\n        return (PIX *)ERROR_PTR(\"kel not defined\", procName, NULL);\n\n    pixt = pixGetRGBComponent(pixs, COLOR_RED);\n    pixr = pixConvolve(pixt, kel, 8, 1);\n    pixDestroy(&pixt);\n    pixt = pixGetRGBComponent(pixs, COLOR_GREEN);\n    pixg = pixConvolve(pixt, kel, 8, 1);\n    pixDestroy(&pixt);\n    pixt = pixGetRGBComponent(pixs, COLOR_BLUE);\n    pixb = pixConvolve(pixt, kel, 8, 1);\n    pixDestroy(&pixt);\n    pixd = pixCreateRGBImage(pixr, pixg, pixb);\n\n    pixDestroy(&pixr);\n    pixDestroy(&pixg);\n    pixDestroy(&pixb);\n    return pixd;\n}\n\n\n/*!\n * \\brief   pixConvolveRGBSep()\n *\n * \\param[in]    pixs   32 bpp rgb\n * \\param[in]    kelx   x-dependent kernel\n * \\param[in]    kely   y-dependent kernel\n * \\return  pixd 32 bpp rgb\n *\n * <pre>\n * Notes:\n *      (1) This does a convolution on an RGB image using a separable\n *          kernel that is a sequence of convolutions in x and y.  The two\n *          one-dimensional kernel components must be input separately;\n *          the full kernel is the product of these components.\n *          The support for the full kernel is thus a rectangular region.\n *      (2) The kernel values can be positive or negative, but the\n *          result for the convolution can only be stored as a positive\n *          number.  Consequently, if it goes negative, we clip the\n *          result to 0.\n *      (3) To get a subsampled output, call l_setConvolveSampling().\n *          The time to make a subsampled output is reduced by the\n *          product of the sampling factors.\n *      (4) This uses a mirrored border to avoid special casing on\n *          the boundaries.\n * </pre>\n */\nPIX *\npixConvolveRGBSep(PIX       *pixs,\n                  L_KERNEL  *kelx,\n                  L_KERNEL  *kely)\n{\nPIX  *pixt, *pixr, *pixg, *pixb, *pixd;\n\n    PROCNAME(\"pixConvolveRGBSep\");\n\n    if (!pixs)\n        return (PIX *)ERROR_PTR(\"pixs not defined\", procName, NULL);\n    if (pixGetDepth(pixs) != 32)\n        return (PIX *)ERROR_PTR(\"pixs is not 32 bpp\", procName, NULL);\n    if (!kelx || !kely)\n        return (PIX *)ERROR_PTR(\"kelx, kely not both defined\", procName, NULL);\n\n    pixt = pixGetRGBComponent(pixs, COLOR_RED);\n    pixr = pixConvolveSep(pixt, kelx, kely, 8, 1);\n    pixDestroy(&pixt);\n    pixt = pixGetRGBComponent(pixs, COLOR_GREEN);\n    pixg = pixConvolveSep(pixt, kelx, kely, 8, 1);\n    pixDestroy(&pixt);\n    pixt = pixGetRGBComponent(pixs, COLOR_BLUE);\n    pixb = pixConvolveSep(pixt, kelx, kely, 8, 1);\n    pixDestroy(&pixt);\n    pixd = pixCreateRGBImage(pixr, pixg, pixb);\n\n    pixDestroy(&pixr);\n    pixDestroy(&pixg);\n    pixDestroy(&pixb);\n    return pixd;\n}\n\n\n/*----------------------------------------------------------------------*\n *                  Generic convolution with float array                *\n *----------------------------------------------------------------------*/\n/*!\n * \\brief   fpixConvolve()\n *\n * \\param[in]    fpixs      32 bit float array\n * \\param[in]    kel        kernel\n * \\param[in]    normflag   1 to normalize kernel to unit sum; 0 otherwise\n * \\return  fpixd 32 bit float array\n *\n * <pre>\n * Notes:\n *      (1) This gives a float convolution with an arbitrary kernel.\n *      (2) If normflag == 1, the result is normalized by scaling all\n *          kernel values for a unit sum.  If the sum of kernel values\n *          is very close to zero, the kernel can not be normalized and\n *          the convolution will not be performed.  A warning is issued.\n *      (3) With the FPix, there are no issues about negative\n *          array or kernel values.  The convolution is performed\n *          with single precision arithmetic.\n *      (4) To get a subsampled output, call l_setConvolveSampling().\n *          The time to make a subsampled output is reduced by the\n *          product of the sampling factors.\n *      (5) This uses a mirrored border to avoid special casing on\n *          the boundaries.\n * </pre>\n */\nFPIX *\nfpixConvolve(FPIX      *fpixs,\n             L_KERNEL  *kel,\n             l_int32    normflag)\n{\nl_int32     i, j, id, jd, k, m, w, h, wd, hd, sx, sy, cx, cy, wplt, wpld;\nl_float32   val;\nl_float32  *datat, *datad, *linet, *lined;\nl_float32   sum;\nL_KERNEL   *keli, *keln;\nFPIX       *fpixt, *fpixd;\n\n    PROCNAME(\"fpixConvolve\");\n\n    if (!fpixs)\n        return (FPIX *)ERROR_PTR(\"fpixs not defined\", procName, NULL);\n    if (!kel)\n        return (FPIX *)ERROR_PTR(\"kel not defined\", procName, NULL);\n\n    fpixd = NULL;\n\n    keli = kernelInvert(kel);\n    kernelGetParameters(keli, &sy, &sx, &cy, &cx);\n    if (normflag)\n        keln = kernelNormalize(keli, 1.0);\n    else\n        keln = kernelCopy(keli);\n\n    fpixGetDimensions(fpixs, &w, &h);\n    fpixt = fpixAddMirroredBorder(fpixs, cx, sx - cx, cy, sy - cy);\n    if (!fpixt) {\n        L_ERROR(\"fpixt not made\\n\", procName);\n        goto cleanup;\n    }\n\n    wd = (w + ConvolveSamplingFactX - 1) / ConvolveSamplingFactX;\n    hd = (h + ConvolveSamplingFactY - 1) / ConvolveSamplingFactY;\n    fpixd = fpixCreate(wd, hd);\n    datat = fpixGetData(fpixt);\n    datad = fpixGetData(fpixd);\n    wplt = fpixGetWpl(fpixt);\n    wpld = fpixGetWpl(fpixd);\n    for (i = 0, id = 0; id < hd; i += ConvolveSamplingFactY, id++) {\n        lined = datad + id * wpld;\n        for (j = 0, jd = 0; jd < wd; j += ConvolveSamplingFactX, jd++) {\n            sum = 0.0;\n            for (k = 0; k < sy; k++) {\n                linet = datat + (i + k) * wplt;\n                for (m = 0; m < sx; m++) {\n                    val = *(linet + j + m);\n                    sum += val * keln->data[k][m];\n                }\n            }\n            *(lined + jd) = sum;\n        }\n    }\n\ncleanup:\n    kernelDestroy(&keli);\n    kernelDestroy(&keln);\n    fpixDestroy(&fpixt);\n    return fpixd;\n}\n\n\n/*!\n * \\brief   fpixConvolveSep()\n *\n * \\param[in]    fpixs      32 bit float array\n * \\param[in]    kelx       x-dependent kernel\n * \\param[in]    kely       y-dependent kernel\n * \\param[in]    normflag   1 to normalize kernel to unit sum; 0 otherwise\n * \\return  fpixd    32 bit float array\n *\n * <pre>\n * Notes:\n *      (1) This does a convolution with a separable kernel that is\n *          is a sequence of convolutions in x and y.  The two\n *          one-dimensional kernel components must be input separately;\n *          the full kernel is the product of these components.\n *          The support for the full kernel is thus a rectangular region.\n *      (2) The normflag parameter is used as in fpixConvolve().\n *      (3) Warning: if you use l_setConvolveSampling() to get a\n *          subsampled output, and the sampling factor is larger than\n *          the kernel half-width, it is faster to use the non-separable\n *          version pixConvolve().  This is because the first convolution\n *          here must be done on every raster line, regardless of the\n *          vertical sampling factor.  If the sampling factor is smaller\n *          than kernel half-width, it's faster to use the separable\n *          convolution.\n *      (4) This uses mirrored borders to avoid special casing on\n *          the boundaries.\n * </pre>\n */\nFPIX *\nfpixConvolveSep(FPIX      *fpixs,\n                L_KERNEL  *kelx,\n                L_KERNEL  *kely,\n                l_int32    normflag)\n{\nl_int32    xfact, yfact;\nL_KERNEL  *kelxn, *kelyn;\nFPIX      *fpixt, *fpixd;\n\n    PROCNAME(\"fpixConvolveSep\");\n\n    if (!fpixs)\n        return (FPIX *)ERROR_PTR(\"pixs not defined\", procName, NULL);\n    if (!kelx)\n        return (FPIX *)ERROR_PTR(\"kelx not defined\", procName, NULL);\n    if (!kely)\n        return (FPIX *)ERROR_PTR(\"kely not defined\", procName, NULL);\n\n    xfact = ConvolveSamplingFactX;\n    yfact = ConvolveSamplingFactY;\n    if (normflag) {\n        kelxn = kernelNormalize(kelx, 1.0);\n        kelyn = kernelNormalize(kely, 1.0);\n        l_setConvolveSampling(xfact, 1);\n        fpixt = fpixConvolve(fpixs, kelxn, 0);\n        l_setConvolveSampling(1, yfact);\n        fpixd = fpixConvolve(fpixt, kelyn, 0);\n        l_setConvolveSampling(xfact, yfact);  /* restore */\n        kernelDestroy(&kelxn);\n        kernelDestroy(&kelyn);\n    } else {  /* don't normalize */\n        l_setConvolveSampling(xfact, 1);\n        fpixt = fpixConvolve(fpixs, kelx, 0);\n        l_setConvolveSampling(1, yfact);\n        fpixd = fpixConvolve(fpixt, kely, 0);\n        l_setConvolveSampling(xfact, yfact);\n    }\n\n    fpixDestroy(&fpixt);\n    return fpixd;\n}\n\n\n/*------------------------------------------------------------------------*\n *              Convolution with bias (for non-negative output)           *\n *------------------------------------------------------------------------*/\n/*!\n * \\brief   pixConvolveWithBias()\n *\n * \\param[in]    pixs     8 bpp; no colormap\n * \\param[in]    kel1\n * \\param[in]    kel2     can be null; use if separable\n * \\param[in]    force8   if 1, force output to 8 bpp; otherwise, determine\n *                        output depth by the dynamic range of pixel values\n * \\param[out]   pbias    applied bias\n * \\return  pixd 8 or 16 bpp\n *\n * <pre>\n * Notes:\n *      (1) This does a convolution with either a single kernel or\n *          a pair of separable kernels, and automatically applies whatever\n *          bias (shift) is required so that the resulting pixel values\n *          are non-negative.\n *      (2) The kernel is always normalized.  If there are no negative\n *          values in the kernel, a standard normalized convolution is\n *          performed, with 8 bpp output.  If the sum of kernel values is\n *          very close to zero, the kernel can not be normalized and\n *          the convolution will not be performed.  An error message results.\n *      (3) If there are negative values in the kernel, the pix is\n *          converted to an fpix, the convolution is done on the fpix, and\n *          a bias (shift) may need to be applied.\n *      (4) If force8 == TRUE and the range of values after the convolution\n *          is > 255, the output values will be scaled to fit in [0 ... 255].\n *          If force8 == FALSE, the output will be either 8 or 16 bpp,\n *          to accommodate the dynamic range of output values without scaling.\n * </pre>\n */\nPIX *\npixConvolveWithBias(PIX       *pixs,\n                    L_KERNEL  *kel1,\n                    L_KERNEL  *kel2,\n                    l_int32    force8,\n                    l_int32   *pbias)\n{\nl_int32    outdepth;\nl_float32  min1, min2, min, minval, maxval, range;\nFPIX      *fpix1, *fpix2;\nPIX       *pixd;\n\n    PROCNAME(\"pixConvolveWithBias\");\n\n    if (!pbias)\n        return (PIX *)ERROR_PTR(\"&bias not defined\", procName, NULL);\n    *pbias = 0;\n    if (!pixs || pixGetDepth(pixs) != 8)\n        return (PIX *)ERROR_PTR(\"pixs undefined or not 8 bpp\", procName, NULL);\n    if (pixGetColormap(pixs))\n        return (PIX *)ERROR_PTR(\"pixs has colormap\", procName, NULL);\n    if (!kel1)\n        return (PIX *)ERROR_PTR(\"kel1 not defined\", procName, NULL);\n\n        /* Determine if negative values can be produced in the convolution */\n    kernelGetMinMax(kel1, &min1, NULL);\n    min2 = 0.0;\n    if (kel2)\n        kernelGetMinMax(kel2, &min2, NULL);\n    min = L_MIN(min1, min2);\n\n    if (min >= 0.0) {\n        if (!kel2)\n            return pixConvolve(pixs, kel1, 8, 1);\n        else\n            return pixConvolveSep(pixs, kel1, kel2, 8, 1);\n    }\n\n        /* Bias may need to be applied; convert to fpix and convolve */\n    fpix1 = pixConvertToFPix(pixs, 1);\n    if (!kel2)\n        fpix2 = fpixConvolve(fpix1, kel1, 1);\n    else\n        fpix2 = fpixConvolveSep(fpix1, kel1, kel2, 1);\n    fpixDestroy(&fpix1);\n\n        /* Determine the bias and the dynamic range.\n         * If the dynamic range is <= 255, just shift the values by the\n         * bias, if any.\n         * If the dynamic range is > 255, there are two cases:\n         *    (1) the output depth is not forced to 8 bpp\n         *           ==> apply the bias without scaling; outdepth = 16\n         *    (2) the output depth is forced to 8\n         *           ==> linearly map the pixel values to [0 ... 255].  */\n    fpixGetMin(fpix2, &minval, NULL, NULL);\n    fpixGetMax(fpix2, &maxval, NULL, NULL);\n    range = maxval - minval;\n    *pbias = (minval < 0.0) ? -minval : 0.0;\n    fpixAddMultConstant(fpix2, *pbias, 1.0);  /* shift: min val ==> 0 */\n    if (range <= 255 || !force8) {  /* no scaling of output values */\n        outdepth = (range > 255) ? 16 : 8;\n    } else {  /* scale output values to fit in 8 bpp */\n        fpixAddMultConstant(fpix2, 0.0, (255.0 / range));\n        outdepth = 8;\n    }\n\n        /* Convert back to pix; it won't do any clipping */\n    pixd = fpixConvertToPix(fpix2, outdepth, L_CLIP_TO_ZERO, 0);\n    fpixDestroy(&fpix2);\n\n    return pixd;\n}\n\n\n/*------------------------------------------------------------------------*\n *                Set parameter for convolution subsampling               *\n *------------------------------------------------------------------------*/\n/*!\n * \\brief   l_setConvolveSampling()\n\n *\n * \\param[in]    xfact, yfact     integer >= 1\n * \\return  void\n *\n * <pre>\n * Notes:\n *      (1) This sets the x and y output subsampling factors for generic pix\n *          and fpix convolution.  The default values are 1 (no subsampling).\n * </pre>\n */\nvoid\nl_setConvolveSampling(l_int32  xfact,\n                      l_int32  yfact)\n{\n    if (xfact < 1) xfact = 1;\n    if (yfact < 1) yfact = 1;\n    ConvolveSamplingFactX = xfact;\n    ConvolveSamplingFactY = yfact;\n}\n\n\n/*------------------------------------------------------------------------*\n *                          Additive gaussian noise                       *\n *------------------------------------------------------------------------*/\n/*!\n * \\brief   pixAddGaussianNoise()\n *\n * \\param[in]    pixs     8 bpp gray or 32 bpp rgb; no colormap\n * \\param[in]    stdev    of noise\n * \\return  pixd    8 or 32 bpp, or NULL on error\n *\n * <pre>\n * Notes:\n *      (1) This adds noise to each pixel, taken from a normal\n *          distribution with zero mean and specified standard deviation.\n * </pre>\n */\nPIX *\npixAddGaussianNoise(PIX       *pixs,\n                    l_float32  stdev)\n{\nl_int32    i, j, w, h, d, wpls, wpld, val, rval, gval, bval;\nl_uint32   pixel;\nl_uint32  *datas, *datad, *lines, *lined;\nPIX       *pixd;\n\n    PROCNAME(\"pixAddGaussianNoise\");\n\n    if (!pixs)\n        return (PIX *)ERROR_PTR(\"pixs not defined\", procName, NULL);\n    if (pixGetColormap(pixs))\n        return (PIX *)ERROR_PTR(\"pixs has colormap\", procName, NULL);\n    pixGetDimensions(pixs, &w, &h, &d);\n    if (d != 8 && d != 32)\n        return (PIX *)ERROR_PTR(\"pixs not 8 or 32 bpp\", procName, NULL);\n\n    pixd = pixCreateTemplateNoInit(pixs);\n    datas = pixGetData(pixs);\n    datad = pixGetData(pixd);\n    wpls = pixGetWpl(pixs);\n    wpld = pixGetWpl(pixd);\n    for (i = 0; i < h; i++) {\n        lines = datas + i * wpls;\n        lined = datad + i * wpld;\n        for (j = 0; j < w; j++) {\n            if (d == 8) {\n                val = GET_DATA_BYTE(lines, j);\n                val += (l_int32)(stdev * gaussDistribSampling() + 0.5);\n                val = L_MIN(255, L_MAX(0, val));\n                SET_DATA_BYTE(lined, j, val);\n            } else {  /* d = 32 */\n                pixel = *(lines + j);\n                extractRGBValues(pixel, &rval, &gval, &bval);\n                rval += (l_int32)(stdev * gaussDistribSampling() + 0.5);\n                rval = L_MIN(255, L_MAX(0, rval));\n                gval += (l_int32)(stdev * gaussDistribSampling() + 0.5);\n                gval = L_MIN(255, L_MAX(0, gval));\n                bval += (l_int32)(stdev * gaussDistribSampling() + 0.5);\n                bval = L_MIN(255, L_MAX(0, bval));\n                composeRGBPixel(rval, gval, bval, lined + j);\n            }\n        }\n    }\n    return pixd;\n}\n\n\n/*!\n * \\brief   gaussDistribSampling()\n *\n * \\return   gaussian distributed variable with zero mean and unit stdev\n *\n * <pre>\n * Notes:\n *      (1) For an explanation of the Box-Muller method for generating\n *          a normally distributed random variable with zero mean and\n *          unit standard deviation, see Numerical Recipes in C,\n *          2nd edition, p. 288ff.\n *      (2) This can be called sequentially to get samples that can be\n *          used for adding noise to each pixel of an image, for example.\n * </pre>\n */\nl_float32\ngaussDistribSampling(void)\n{\nstatic l_int32    select = 0;  /* flips between 0 and 1 on successive calls */\nstatic l_float32  saveval;\nl_float32         frand, xval, yval, rsq, factor;\n\n    if (select == 0) {\n        while (1) {  /* choose a point in a 2x2 square, centered at origin */\n            frand = (l_float32)rand() / (l_float32)RAND_MAX;\n            xval = 2.0 * frand - 1.0;\n            frand = (l_float32)rand() / (l_float32)RAND_MAX;\n            yval = 2.0 * frand - 1.0;\n            rsq = xval * xval + yval * yval;\n            if (rsq > 0.0 && rsq < 1.0)  /* point is inside the unit circle */\n                break;\n        }\n        factor = sqrt(-2.0 * log(rsq) / rsq);\n        saveval = xval * factor;\n        select = 1;\n        return yval * factor;\n    }\n    else {\n        select = 0;\n        return saveval;\n    }\n}\n"], "filenames": ["src/convolve.c"], "buggy_code_start_loc": [117], "buggy_code_end_loc": [882], "fixing_code_start_loc": [117], "fixing_code_end_loc": [873], "type": "CWE-369", "message": "An issue in the Leptonica linked library (v1.79.0) allows attackers to cause an arithmetic exception leading to a Denial of Service (DoS) via a crafted JPEG file.", "other": {"cve": {"id": "CVE-2022-38266", "sourceIdentifier": "cve@mitre.org", "published": "2022-09-09T22:15:08.830", "lastModified": "2023-01-31T20:59:51.247", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue in the Leptonica linked library (v1.79.0) allows attackers to cause an arithmetic exception leading to a Denial of Service (DoS) via a crafted JPEG file."}, {"lang": "es", "value": "Un problema en la biblioteca enlazada Leptonica (v1.79.0) permite a los atacantes provocar una excepci\u00f3n aritm\u00e9tica que conduce a una denegaci\u00f3n de servicio (DoS) a trav\u00e9s de un archivo JPEG manipulado"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-369"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:tesseract_project:tesseract:5.0.0:alpha-20210401:*:*:*:*:*:*", "matchCriteriaId": "D83B1B84-78AE-4CFD-B425-509B29AF243B"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:leptonica:leptonica:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.80.0", "matchCriteriaId": "1616069D-AF01-4FED-83F7-80566DF507D7"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "https://github.com/DanBloomberg/leptonica/commit/f062b42c0ea8dddebdc6a152fd16152de215d614", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/tesseract-ocr/tesseract/issues/3498", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/12/msg00018.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/DanBloomberg/leptonica/commit/f062b42c0ea8dddebdc6a152fd16152de215d614"}}