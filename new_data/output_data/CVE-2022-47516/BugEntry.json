{"buggy_code": ["/*\n * This file is part of the Sofia-SIP package\n *\n * Copyright (C) 2005 Nokia Corporation.\n *\n * Contact: Pekka Pessi <pekka.pessi@nokia.com>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public License\n * as published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA\n *\n */\n\n/**@CFILE tport.c Transport interface implementation.\n *\n * See tport.docs for more detailed description of tport interface.\n *\n * @author Pekka Pessi <Pekka.Pessi@nokia.com>\n * @author Ismo Puustinen <Ismo.H.Puustinen@nokia.com>\n * @author Tat Chan <Tat.Chan@nokia.com>\n * @author Kai Vehmanen <kai.vehmanen@nokia.com>\n * @author Martti Mela <Martti.Mela@nokia.com>\n *\n * @date Created: Thu Jul 20 12:54:32 2000 ppessi\n */\n\n#include \"config.h\"\n\n#include <sofia-sip/su_string.h>\n#include <sofia-sip/su.h>\n#include <sofia-sip/su_errno.h>\n#include <sofia-sip/su_alloc.h>\n#include <sofia-sip/su_tagarg.h>\n#include <sofia-sip/su_localinfo.h>\n\ntypedef struct tport_nat_s tport_nat_t;\n\n#define SU_WAKEUP_ARG_T         struct tport_s\n#define SU_TIMER_ARG_T          struct tport_s\n#define SU_MSG_ARG_T            union tport_su_msg_arg\n\n#include <sofia-sip/su_wait.h>\n\n#include <sofia-sip/msg.h>\n#include <sofia-sip/msg_addr.h>\n#include <sofia-sip/hostdomain.h>\n\n#include <stdlib.h>\n#include <time.h>\n#include <assert.h>\n#include <errno.h>\n#include <limits.h>\n\n#ifndef IPPROTO_SCTP\n#define IPPROTO_SCTP (132)\n#endif\n\n#include \"sofia-sip/tport.h\"\n#include \"sofia-sip/su_uniqueid.h\"\n#include <sofia-sip/rbtree.h>\n\n#include \"tport_internal.h\"\n\n#if HAVE_FUNC\n#elif HAVE_FUNCTION\n#define __func__ __FUNCTION__\n#else\nstatic char const __func__[] = \"tport\";\n#endif\n\n#define STACK_RECV(tp, msg, now)\t\t       \\\n  (tp)->tp_master->mr_tpac->tpac_recv((tp)->tp_master->mr_stack, (tp), \\\n\t\t\t\t      (msg), (tp)->tp_magic, (now))\n\n#define STACK_ERROR(tp, errcode, dstname) \\\n  (tp)->tp_master->mr_tpac->tpac_error((tp)->tp_master->mr_stack, (tp), \\\n\t\t\t\t       (errcode), (dstname))\n\n#define STACK_ADDRESS(tp)\t\t       \\\n  (tp)->tp_master->mr_tpac->tpac_address((tp)->tp_master->mr_stack, (tp))\n\n#define TP_STACK   tp_master->mr_stack\n\n/* Define macros for rbtree implementation */\n#define TP_LEFT(tp) ((tp)->tp_left)\n#define TP_RIGHT(tp) ((tp)->tp_right)\n#define TP_PARENT(tp) ((tp)->tp_dad)\n#define TP_SET_RED(tp) ((tp)->tp_black = 0)\n#define TP_SET_BLACK(tp) ((tp)->tp_black = 1)\n#define TP_IS_RED(tp) ((tp) && (tp)->tp_black == 0)\n#define TP_IS_BLACK(tp) (!(tp) || (tp)->tp_black == 1)\n#define TP_COPY_COLOR(dst, src) ((dst)->tp_black = (src)->tp_black)\n#define TP_INSERT(tp) ((void)0)\n#define TP_REMOVE(tp) ((tp)->tp_left = (tp)->tp_right = (tp)->tp_dad = NULL)\n\nsu_inline int tp_cmp(tport_t const *a, tport_t const *b)\n{\n  if (a == b)\n    return 0;\n\n  if (a->tp_addrlen != b->tp_addrlen)\n    return (int)(a->tp_addrlen - b->tp_addrlen);\n\n  return memcmp(a->tp_addr, b->tp_addr, a->tp_addrlen);\n}\n\n#ifdef __clang__\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wunused-function\"\n#endif\n\nRBTREE_PROTOS(su_inline, tprb, tport_t);\n\nRBTREE_BODIES(su_inline, tprb, tport_t,\n\t      TP_LEFT, TP_RIGHT, TP_PARENT,\n\t      TP_IS_RED, TP_SET_RED, TP_IS_BLACK, TP_SET_BLACK, TP_COPY_COLOR,\n\t      tp_cmp, TP_INSERT, TP_REMOVE);\n\n#ifdef __clang__\n#pragma clang diagnostic pop\n#endif\n\nstatic int wssCount = 0;\nstatic int tcpCount = 0;\nvoid incrementSecondaryCount(tport_t* self) {\n  if (self && 0 == strncmp(self->tp_name->tpn_proto, \"ws\", 2)) wssCount++;\n  else if (self && 0 == strcmp(self->tp_name->tpn_proto, \"tcp\")) tcpCount++;\n}\nvoid decrementSecondaryCount(tport_t* self) {\n  if (self && 0 == strncmp(self->tp_name->tpn_proto, \"ws\", 2)) wssCount--;\n  else if (self && 0 == strcmp(self->tp_name->tpn_proto, \"tcp\")) tcpCount--;\n}\n\nstatic void tplist_insert(tport_t **list, tport_t *tp)\n{\n  if (*list == NULL)\n    *list = tp;\n  else\n    tp->tp_right = *list, (*list)->tp_left = tp, *list = tp;\n\n  for (tp = *list; tp; tp = tp->tp_right) {\n    assert(tp->tp_left == NULL || tp == tp->tp_left->tp_right);\n    assert(tp->tp_right == NULL || tp == tp->tp_right->tp_left);\n  }\n}\n\nstatic void tplist_remove(tport_t **list, tport_t *tp)\n{\n  if (*list == tp) {\n    *list = tp->tp_right; assert(tp->tp_left == NULL);\n  }\n  else if (tp->tp_left) {\n    tp->tp_left->tp_right = tp->tp_right;\n  }\n  if (tp->tp_right) {\n    tp->tp_right->tp_left = tp->tp_left;\n  }\n  TP_REMOVE(tp);\n}\n\nenum {\n  /** Default per-thread read queue length */\n  THRP_PENDING = 8\n};\n\nstruct tport_pending_s {\n  /* tport_pending_t       *p_left, *p_right, *p_parent; */\n  void               *p_client;\n  tport_pending_error_f *p_callback;\n  msg_t              *p_msg;\n  unsigned short      p_reported;\n  unsigned short      p_on_success;\n};\n\n/** Return true if transport is master. */\nint tport_is_master(tport_t const *self)\n{\n  return\n    self &&\n    self->tp_master->mr_master == self;\n}\n\n/** Return true if transport is primary. */\nint tport_is_primary(tport_t const *self)\n{\n  return\n    self &&\n    self->tp_pri->pri_primary == self;\n}\n\n/** Return true if transport is secondary. */\nint tport_is_secondary(tport_t const *self)\n{\n  return\n    self &&\n    self->tp_master->mr_master != self &&\n    self->tp_pri->pri_primary != self;\n}\n\n/** Test if transport has been registered to su_root_t */\nint tport_is_registered(tport_t const *self)\n{\n  return self && self->tp_index != 0;\n}\n\n/** Test if transport is stream. */\nint tport_is_stream(tport_t const *self)\n{\n\treturn self && !self->tp_pre_framed && self->tp_addrinfo->ai_socktype == SOCK_STREAM;\n}\n\n/** Test if transport is dgram. */\nint tport_is_dgram(tport_t const *self)\n{\n  return self && self->tp_addrinfo->ai_socktype == SOCK_DGRAM;\n}\n\n/** Test if transport is udp. */\nint tport_is_udp(tport_t const *self)\n{\n  return self && self->tp_addrinfo->ai_protocol == IPPROTO_UDP;\n}\n\n/** Test if transport is tcp. */\nint tport_is_tcp(tport_t const *self)\n{\n  return self && self->tp_addrinfo->ai_protocol == IPPROTO_TCP;\n}\n\n/** Return 1 if transport is reliable, 0 otherwise.\n *\n * (Note that this is part of external API).\n */\nint tport_is_reliable(tport_t const *self)\n{\n  return self != NULL &&\n    (self->tp_addrinfo->ai_socktype == SOCK_STREAM ||\n     self->tp_addrinfo->ai_socktype == SOCK_SEQPACKET);\n}\n\n/** Return 0 if self is local, nonzero otherwise.\n *\n * The return valu is the tport_via enum.\n *\n * @sa TPTAG_PUBLIC(), enum tport_via.\n */\nint tport_is_public(tport_t const *self)\n{\n  return self && self->tp_pri->pri_public;\n}\n\n/** Return true if transport supports IPv4 */\nint tport_has_ip4(tport_t const *self)\n{\n  return self &&\n    (self->tp_addrinfo->ai_family == 0 ||\n     self->tp_addrinfo->ai_family == AF_INET);\n}\n\n\n#if SU_HAVE_IN6\n/** Return true if transport supports IPv6 */\nint tport_has_ip6(tport_t const *self)\n{\n  return self &&\n    (self->tp_addrinfo->ai_family == 0 ||\n     self->tp_addrinfo->ai_family == AF_INET6);\n}\n#endif\n\n/** Return true if transport supports TLS. */\nint tport_has_tls(tport_t const *self)\n{\n  return self && self->tp_pri->pri_has_tls;\n}\n\n/** Return true if transport certificate verified successfully */\nint tport_is_verified(tport_t const *self)\n{\n  return tport_has_tls(self) && self->tp_is_connected && self->tp_verified;\n}\n\n/** Return true if transport is being updated. */\nint tport_is_updating(tport_t const *self)\n{\n  tport_primary_t *pri;\n\n  if (tport_is_master(self)) {\n    for (pri = self->tp_master->mr_primaries; pri; pri = pri->pri_next)\n      if (pri->pri_updating)\n\treturn 1;\n  }\n  else if (tport_is_primary(self)) {\n    return self->tp_pri->pri_updating;\n  }\n\n  return 0;\n}\n\n/** Test if transport has been closed.\n *\n * @since New in @VERSION_1_12_4\n */\ninline int tport_is_closed(tport_t const *self)\n{\n  return self->tp_closed;\n}\n\n/** Test if transport has been shut down.\n *\n * @since New in @VERSION_1_12_4\n */\ninline int tport_is_shutdown(tport_t const *self)\n{\n  return self->tp_closed || self->tp_send_close || self->tp_recv_close;\n}\n\n/** Test if transport connection has been established. @NEW_1_12_5. */\nint tport_is_connected(tport_t const *self)\n{\n  return self->tp_is_connected;\n}\n\n/** Test if transport can be used to send message. @NEW_1_12_7. */\nint tport_is_clear_to_send(tport_t const *self)\n{\n  return\n    tport_is_master(self) ||\n    tport_is_primary(self) ||\n    (tport_is_secondary(self) &&\n     tport_is_registered(self) &&\n     self->tp_reusable &&\n     !self->tp_closed &&\n     !self->tp_send_close);\n}\n\n/** Return true if transport has message in send queue. @NEW_1_12_7. */\nint tport_has_queued(tport_t const *self)\n{\n  return self && self->tp_queue && self->tp_queue[self->tp_qhead];\n}\n\n/** Flush queued messages  */\nint tport_flush_queued(tport_t const *self) \n{\n    /* Zap the queued messages */\n  int num = 0 ;\n  if (tport_has_queued(self)) {\n    unsigned short i, N = self->tp_params->tpp_qsize;\n    for (i = 0; i < N; i++) {\n      if (self->tp_queue[i]) {\n        msg_ref_destroy(self->tp_queue[i]) ; \n        self->tp_queue[i] = NULL;\n        num++;\n      }\n    }\n  }\n  return num;\n}\n\n/** MTU for transport  */\nsu_inline unsigned tport_mtu(tport_t const *self)\n{\n  return self->tp_params->tpp_mtu;\n}\n\n/** Set IP TOS for socket */\nvoid tport_set_tos(su_socket_t socket, su_addrinfo_t *ai, int tos)\n{\n  if (tos >= 0 &&\n      ai->ai_family == AF_INET &&\n      setsockopt(socket, IPPROTO_IP, IP_TOS, (const void*)&tos, sizeof(tos)) < 0) {\n    SU_DEBUG_3((\"tport: setsockopt(IP_TOS): %s\\n\",\n\t\tsu_strerror(su_errno())));\n  }\n}\n\nstatic\ntport_t *tport_connect(tport_primary_t *pri, su_addrinfo_t *ai,\n\t\t       tp_name_t const *tpn);\n\nstatic int bind6only_check(tport_master_t *mr);\n\nstatic\nint tport_server_addrinfo(tport_master_t *mr,\n\t\t\t  char const *canon,\n\t\t\t  int family,\n\t\t\t  char const *host,\n\t\t\t  char const *service,\n\t\t\t  char const *protocol,\n\t\t\t  char const * const transports[],\n\t\t\t  su_addrinfo_t **res);\n\nstatic int tport_get_local_addrinfo(tport_master_t *mr,\n\t\t\t\t    char const *port,\n\t\t\t\t    su_addrinfo_t const *hints,\n\t\t\t\t    su_addrinfo_t **return_ai);\n\nint tport_getaddrinfo(char const *node, char const *service,\n\t\t      su_addrinfo_t const *hints,\n\t\t      su_addrinfo_t **res);\n\nstatic void tport_freeaddrinfo(su_addrinfo_t *ai);\n\nstatic\nint tport_addrinfo_copy(su_addrinfo_t *dst, void *addr, socklen_t addrlen,\n\t\t\tsu_addrinfo_t const *src);\n\nstatic int\n  tport_bind_client(tport_master_t *self, tp_name_t const *tpn,\n\t\t    char const * const transports[], enum tport_via public,\n\t\t    tagi_t *tags),\n  tport_bind_server(tport_master_t *, tp_name_t const *tpn,\n\t\t    char const * const transports[],  enum tport_via public,\n\t\t    tagi_t *tags),\n\n  tport_wakeup_pri(su_root_magic_t *m, su_wait_t *w, tport_t *self),\n  tport_base_wakeup(tport_t *self, int events),\n  tport_connected(su_root_magic_t *m, su_wait_t *w, tport_t *self),\n  tport_resolve(tport_t *self, msg_t *msg, tp_name_t const *tpn),\n  tport_send_error(tport_t *, msg_t *, tp_name_t const *, char const *who),\n  tport_send_fatal(tport_t *, msg_t *, tp_name_t const *, char const *who),\n  tport_queue(tport_t *self, msg_t *msg),\n  tport_queue_rest(tport_t *self, msg_t *msg, msg_iovec_t iov[], size_t iovused),\n  tport_pending_error(tport_t *self, su_sockaddr_t const *dst, int error),\n  tport_pending_errmsg(tport_t *self, msg_t *msg, int error);\n\nstatic ssize_t tport_vsend(tport_t *self, msg_t *msg, tp_name_t const *tpn,\n\t\t\t   msg_iovec_t iov[], size_t iovused,\n\t\t\t   struct sigcomp_compartment *cc);\n\ntport_t *tport_by_addrinfo(tport_primary_t const *pri,\n\t\t\t   su_addrinfo_t const *ai,\n\t\t\t   tp_name_t const *tpn);\n\nvoid tport_peer_address(tport_t *self, msg_t *msg);\n\nstatic void tport_parse(tport_t *self, int complete, su_time_t now);\n\nstatic tport_primary_t *tport_alloc_primary(tport_master_t *mr,\n\t\t\t\t\t    tport_vtable_t const *vtable,\n\t\t\t\t\t    tp_name_t tpn[1],\n\t\t\t\t\t    su_addrinfo_t *ai,\n\t\t\t\t\t    tagi_t const *tags,\n\t\t\t\t\t    char const **return_culprit);\n\nstatic tport_primary_t *tport_listen(tport_master_t *mr,\n\t\t\t\t     tport_vtable_t const *vtable,\n\t\t\t\t     tp_name_t tpn[1],\n\t\t\t\t     su_addrinfo_t *ai,\n\t\t\t\t     tagi_t *tags);\nstatic void tport_zap_primary(tport_primary_t *);\n\nstatic char *localipname(int pf, char *buf, size_t bufsiz);\nstatic int getprotohints(su_addrinfo_t *hints,\n\t\t\t char const *proto, int flags);\n\n\n/* Stack class used when transports are being destroyed */\nstatic\nvoid tport_destroy_recv(tp_stack_t *stack, tport_t *tp,\n\t\t\tmsg_t *msg, tp_magic_t *magic,\n\t\t\tsu_time_t received)\n{\n  msg_destroy(msg);\n}\n\nstatic\nvoid tport_destroy_error(tp_stack_t *stack, tport_t *tp,\n\t\t\t int errcode, char const *remote)\n{\n}\n\nstatic\nmsg_t *tport_destroy_alloc(tp_stack_t *stack, int flags,\n\t\t\t   char const data[], usize_t len,\n\t\t\t   tport_t const *tp,\n\t\t\t   tp_client_t *tpc)\n{\n  return NULL;\n}\n\n/** Name for \"any\" transport. @internal */\nstatic char const tpn_any[] = \"*\";\n\n/** Create the master transport.\n *\n * Master transport object is used to bind the protocol using transport with\n * actual transport objects corresponding to TCP, UDP, etc.\n *\n * @sa tport_tbind()\n *\n * @TAGS\n * TPTAG_LOG(), TPTAG_DUMP(), tags used with tport_set_params(), especially\n * TPTAG_QUEUESIZE().\n */\ntport_t *tport_tcreate(tp_stack_t *stack,\n\t\t       tp_stack_class_t const *tpac,\n\t\t       su_root_t *root,\n\t\t       tag_type_t tag, tag_value_t value, ...)\n{\n  tport_master_t *mr;\n  tp_name_t *tpn;\n  tport_params_t *tpp;\n  ta_list ta;\n\n  if (!stack || !tpac || !root) {\n    su_seterrno(EINVAL);\n    return NULL;\n  }\n\n  mr = su_home_clone(NULL, sizeof *mr);\n  if (!mr)\n    return NULL;\n\n  SU_DEBUG_7((\"%s(): %p\\n\", \"tport_create\", (void *)mr));\n\n  mr->mr_stack = stack;\n  mr->mr_tpac = tpac;\n  mr->mr_root = root;\n\n  mr->mr_master->tp_master = mr;\n  mr->mr_master->tp_params = tpp = mr->mr_params;\n\n  mr->mr_master->tp_reusable = 1;\n  tpp->tpp_mtu = UINT_MAX;\n  tpp->tpp_thrprqsize = THRP_PENDING;\n  tpp->tpp_qsize = TPORT_QUEUESIZE;\n  tpp->tpp_sdwn_error = 1;\n  tpp->tpp_idle = UINT_MAX;\n  tpp->tpp_timeout = UINT_MAX;\n  tpp->tpp_sigcomp_lifetime = UINT_MAX;\n  tpp->tpp_socket_keepalive = 30;\n  tpp->tpp_keepalive = 0;\n  tpp->tpp_pingpong = 0;\n  tpp->tpp_pong2ping = 0;\n  tpp->tpp_stun_server = 1;\n  tpp->tpp_tos = -1;                  /* set invalid, valid values are 0-255 */\n\n  tpn = mr->mr_master->tp_name;\n  tpn->tpn_proto = \"*\";\n  tpn->tpn_host = \"*\";\n  tpn->tpn_canon = \"*\";\n  tpn->tpn_port = \"*\";\n\n  ta_start(ta, tag, value);\n\n  tport_set_params(mr->mr_master, ta_tags(ta));\n\n#if HAVE_SOFIA_STUN\n  tport_init_stun_server(mr, ta_args(ta));\n#endif\n\n  ta_end(ta);\n\n  return mr->mr_master;\n}\n\n/** Destroy the master transport. */\nvoid tport_destroy(tport_t *self)\n{\n  tport_master_t *mr;\n\n  static tp_stack_class_t tport_destroy_tpac[1] =\n    {{\n\tsizeof tport_destroy_tpac,\n\t/* tpac_recv */ tport_destroy_recv,\n\t/* tpac_error */ tport_destroy_error,\n\t/* tpac_alloc */ tport_destroy_alloc,\n\t/* tpac_address */ NULL\n      }};\n\n  SU_DEBUG_7((\"%s(%p)\\n\", __func__, (void *)self));\n\n  if (self == NULL)\n    return;\n\n  assert(tport_is_master(self));\n  if (!tport_is_master(self))\n    return;\n\n  mr = (tport_master_t *)self;\n  mr->mr_tpac = tport_destroy_tpac;\n\n  while (mr->mr_primaries)\n    tport_zap_primary(mr->mr_primaries);\n\n#if HAVE_SOFIA_STUN\n  tport_deinit_stun_server(mr);\n#endif\n\n  if (mr->mr_dump_file)\n    fclose(mr->mr_dump_file), mr->mr_dump_file = NULL;\n\n  if (mr->mr_timer)\n    su_timer_destroy(mr->mr_timer), mr->mr_timer = NULL;\n\n  su_home_zap(mr->mr_home);\n}\n\n\n/** Allocate a primary transport */\nstatic\ntport_primary_t *tport_alloc_primary(tport_master_t *mr,\n\t\t\t\t     tport_vtable_t const *vtable,\n\t\t\t\t     tp_name_t tpn[1],\n\t\t\t\t     su_addrinfo_t *ai,\n\t\t\t\t     tagi_t const *tags,\n\t\t\t\t     char const **return_culprit)\n{\n  tport_primary_t *pri, **next;\n  tport_t *tp;\n  int save_errno;\n\n  for (next = &mr->mr_primaries; *next; next = &(*next)->pri_next)\n    ;\n\n  assert(vtable->vtp_pri_size >= sizeof *pri);\n\n  if ((pri = su_home_clone(mr->mr_home, vtable->vtp_pri_size))) {\n    tport_t *tp = pri->pri_primary;\n    pri->pri_vtable = vtable;\n    pri->pri_public = vtable->vtp_public;\n\n    tp->tp_master = mr;\n    tp->tp_pri = pri;\n    tp->tp_socket = INVALID_SOCKET;\n\n    tp->tp_magic = mr->mr_master->tp_magic;\n\n    tp->tp_params = pri->pri_params;\n    memcpy(tp->tp_params, mr->mr_params, sizeof (*tp->tp_params));\n    tp->tp_reusable = mr->mr_master->tp_reusable;\n\n    if (!pri->pri_public)\n      tp->tp_addrinfo->ai_addr = &tp->tp_addr->su_sa;\n\n    SU_DEBUG_5((\"%s(%p): new primary tport %p\\n\", __func__, (void *)mr,\n\t\t(void *)pri));\n  }\n\n  *next = pri;\n  tp = pri->pri_primary;\n\n  if (!tp)\n    *return_culprit = \"alloc\";\n  else if (tport_set_params(tp, TAG_NEXT(tags)) < 0)\n    *return_culprit = \"tport_set_params\";\n  else if (vtable->vtp_init_primary &&\n\t   vtable->vtp_init_primary(pri, tpn, ai, tags, return_culprit) < 0)\n    ;\n  else if (tport_setname(tp, vtable->vtp_name, ai, tpn->tpn_canon) == -1)\n    *return_culprit = \"tport_setname\";\n  else if (tpn->tpn_ident &&\n\t   !(tp->tp_name->tpn_ident = su_strdup(tp->tp_home, tpn->tpn_ident)))\n    *return_culprit = \"alloc ident\";\n  else\n    return pri;\t\t\t/* Success */\n\n  save_errno = su_errno();\n  tport_zap_primary(pri);\n  su_seterrno(save_errno);\n\n  return NULL;\n}\n\n\n/** Destroy a primary transport and its secondary transports. @internal */\nstatic\nvoid tport_zap_primary(tport_primary_t *pri)\n{\n  tport_primary_t **prip;\n\n  if (pri == NULL)\n    return;\n\n  assert(tport_is_primary(pri->pri_primary));\n\n  if (pri->pri_vtable->vtp_deinit_primary)\n    pri->pri_vtable->vtp_deinit_primary(pri);\n\n  while (pri->pri_open)\n    tport_zap_secondary(pri->pri_open);\n  while (pri->pri_closed)\n    tport_zap_secondary(pri->pri_closed);\n\n  /* We have just a single-linked list for primary transports */\n  for (prip = &pri->pri_master->mr_primaries;\n       *prip != pri;\n       prip = &(*prip)->pri_next)\n    assert(*prip);\n\n  *prip = pri->pri_next;\n\n  tport_zap_secondary((tport_t *)pri);\n}\n\n/**Create a primary transport object with socket.\n *\n * Creates a primary transport object with a server socket, and then\n * registers the socket with suitable events to the root.\n *\n * @param dad   parent (master or primary) transport object\n * @param ai    pointer to addrinfo structure\n * @param canon canonical name of node\n * @param protoname name of the protocol\n */\nstatic\ntport_primary_t *tport_listen(tport_master_t *mr,\n\t\t\t      tport_vtable_t const *vtable,\n\t\t\t      tp_name_t tpn[1],\n\t\t\t      su_addrinfo_t *ai,\n\t\t\t      tagi_t *tags)\n{\n  tport_primary_t *pri = NULL;\n\n  int err;\n  int errlevel = 3;\n  char buf[TPORT_HOSTPORTSIZE];\n\n  char const *protoname = vtable->vtp_name;\n  char const *culprit = \"unknown\";\n\n  su_sockaddr_t *su = (void *)ai->ai_addr;\n\n  /* Log an error, return error */\n#define TPORT_LISTEN_ERROR(errno, what)\t\t\t\t     \\\n  ((void)(err = errno,\t\t\t\t\t\t     \\\n\t  ((err == EADDRINUSE || err == EAFNOSUPPORT ||\t\t     \\\n\t    err == ESOCKTNOSUPPORT || err == EPROTONOSUPPORT ||\t     \\\n\t    err == ENOPROTOOPT ? 7 : 3) < SU_LOG_LEVEL ?\t     \\\n\t     su_llog(tport_log, errlevel,\t\t\t     \\\n\t\t     \"%s(%p): %s(pf=%d %s/%s): %s\\n\",\t\t     \\\n\t\t     __func__, pri ? (void *)pri : (void *)mr, what, \\\n\t\t     ai->ai_family, protoname,\t\t\t     \\\n\t\t     tport_hostport(buf, sizeof(buf), su, 2),\t     \\\n\t\t     su_strerror(err)) : (void)0),\t\t     \\\n\t    tport_zap_primary(pri),\t\t                     \\\n\t    su_seterrno(err)),\t\t\t\t\t     \\\n     (void *)NULL)\n\n  /* Create a primary transport object for another transport. */\n  pri = tport_alloc_primary(mr, vtable, tpn, ai, tags, &culprit);\n  if (pri == NULL)\n    return TPORT_LISTEN_ERROR(su_errno(), culprit);\n\n  if (pri->pri_primary->tp_socket != INVALID_SOCKET) {\n    int index = 0;\n    tport_t *tp = pri->pri_primary;\n    su_wait_t wait[1] = { SU_WAIT_INIT };\n\n    if (su_wait_create(wait, tp->tp_socket, tp->tp_events) == -1)\n      return TPORT_LISTEN_ERROR(su_errno(), \"su_wait_create\");\n\n    /* Register receiving or accepting function with events specified above */\n    index = su_root_register(mr->mr_root, wait, tport_wakeup_pri, tp, 0);\n    if (index == -1) {\n      su_wait_destroy(wait);\n      return TPORT_LISTEN_ERROR(su_errno(), \"su_root_register\");\n    }\n\n    tp->tp_index = index;\n  }\n\n  pri->pri_primary->tp_has_connection = 0;\n\n  SU_DEBUG_5((\"%s(%p): %s \" TPN_FORMAT \"\\n\",\n\t      __func__, (void *)pri, \"listening at\",\n\t      TPN_ARGS(pri->pri_primary->tp_name)));\n\n  return pri;\n}\n\nint tport_bind_socket(int socket,\n\t\t      su_addrinfo_t *ai,\n\t\t      char const **return_culprit)\n{\n  su_sockaddr_t *su = (su_sockaddr_t *)ai->ai_addr;\n  socklen_t sulen = (socklen_t)(ai->ai_addrlen);\n\n  if (bind(socket, ai->ai_addr, sulen) == -1) {\n    return *return_culprit = \"bind\", -1;\n  }\n\n  if (getsockname(socket, &su->su_sa, &sulen) == SOCKET_ERROR) {\n    return *return_culprit = \"getsockname\", -1;\n  }\n\n  ai->ai_addrlen = sulen;\n\n#if defined (__linux__) && defined (SU_HAVE_IN6)\n  if (ai->ai_family == AF_INET6) {\n    if (!SU_SOCKADDR_INADDR_ANY(su) &&\n\t(IN6_IS_ADDR_V4MAPPED(&su->su_sin6.sin6_addr) ||\n\t IN6_IS_ADDR_V4COMPAT(&su->su_sin6.sin6_addr))) {\n      su_sockaddr_t su0[1];\n\n      memcpy(su0, su, sizeof su0);\n\n      memset(su, 0, ai->ai_addrlen = sizeof su->su_sin);\n      su->su_family = ai->ai_family = AF_INET;\n      su->su_port = su0->su_port;\n\n#ifndef IN6_V4MAPPED_TO_INADDR\n#define IN6_V4MAPPED_TO_INADDR(in6, in4) \\\n      memcpy((in4), 12 + (uint8_t *)(in6), sizeof(struct in_addr))\n#endif\n      IN6_V4MAPPED_TO_INADDR(&su0->su_sin6.sin6_addr, &su->su_sin.sin_addr);\n    }\n  }\n#endif\n\n  return 0;\n}\n\n\n/** Indicate stack that a transport has been updated */\nvoid tport_has_been_updated(tport_t *self)\n{\n  self->tp_pri->pri_updating = 0;\n\n  if (self->tp_master->mr_tpac->tpac_address)\n    self->tp_master->mr_tpac->tpac_address(self->tp_master->mr_stack, self);\n}\n\n\nstatic\nint tport_set_events(tport_t *self, int set, int clear)\n{\n  int events;\n\n  if (self == NULL)\n    return -1;\n\n  events = (self->tp_events | set) & ~clear;\n  self->tp_events = events;\n\n  if (self->tp_pri->pri_vtable->vtp_set_events)\n    return self->tp_pri->pri_vtable->vtp_set_events(self);\n\n  SU_DEBUG_7((\"tport_set_events(%p): events%s%s%s\\n\", (void *)self,\n\t      (events & SU_WAIT_IN) ? \" IN\" : \"\",\n\t      (events & SU_WAIT_OUT) ? \" OUT\" : \"\",\n\t      SU_WAIT_CONNECT != SU_WAIT_OUT &&\n\t      (events & SU_WAIT_CONNECT) ? \" CONNECT\" : \"\"));\n\n  return\n    su_root_eventmask(self->tp_master->mr_root,\n\t\t      self->tp_index,\n\t\t      self->tp_socket,\n\t\t      self->tp_events = events);\n}\n\n/**Allocate a secondary transport. @internal\n *\n * Create a secondary transport object. The new transport initally shares\n * parameters structure with the original transport.\n *\n * @param pri    primary transport\n * @param socket socket for transport\n * @parma accepted true if the socket was accepted from server socket\n *\n * @return\n * Pointer to the newly created transport, or NULL upon an error.\n *\n * @note The socket is always closed upon error.\n */\ntport_t *tport_alloc_secondary(tport_primary_t *pri,\n\t\t\t       int socket,\n\t\t\t       int accepted,\n\t\t\t       char const **return_reason)\n{\n  tport_master_t *mr = pri->pri_master;\n  tport_t *self;\n\n  self = su_home_clone(mr->mr_home, pri->pri_vtable->vtp_secondary_size);\n\n  if (self) {\n    self->tp_refs = -1;\t\t\t/* Freshly allocated  */\n    self->tp_master = mr;\n    self->tp_pri = pri;\n    self->tp_params = pri->pri_params;\n    self->tp_accepted = accepted != 0;\n    self->tp_reusable = pri->pri_primary->tp_reusable;\n\n    self->tp_magic = pri->pri_primary->tp_magic;\n\n    self->tp_addrinfo->ai_addr = (void *)self->tp_addr;\n\n    self->tp_socket = socket;\n\n    self->tp_timer = su_timer_create(su_root_task(mr->mr_root), 0);\n    self->tp_stime = self->tp_ktime = self->tp_rtime = su_now();\n\n    if (pri->pri_vtable->vtp_init_secondary &&\n\n\t\tpri->pri_vtable->vtp_init_secondary(self, socket, accepted, return_reason) < 0) {\n      if (pri->pri_vtable->vtp_deinit_secondary) {\n        pri->pri_vtable->vtp_deinit_secondary(self);\n      }\n      su_timer_destroy(self->tp_timer);\n      su_home_zap(self->tp_home);\n\n      return NULL;\n    }\n\n    /* Set IP TOS if it is set in primary */\n    tport_set_tos(socket,\n\t\t  pri->pri_primary->tp_addrinfo,\n\t\t  pri->pri_params->tpp_tos);\n  }\n  else {\n    *return_reason = \"malloc\";\n  }\n  return self;\n}\n\n\n/** Create a connected transport object with socket.\n *\n * The function tport_connect() creates a secondary transport with a\n * connected socket. It registers the socket with suitable events to the\n * root.\n *\n * @param pri   primary transport object\n * @param ai    pointer to addrinfo structure\n * @param tpn   canonical name of node\n */\nstatic\ntport_t *tport_connect(tport_primary_t *pri,\n\t\t       su_addrinfo_t *ai,\n\t\t       tp_name_t const *tpn)\n{\n  tport_t *tp;\n\n  if (ai == NULL || ai->ai_addrlen > sizeof (pri->pri_primary->tp_addr))\n    return NULL;\n\n  if (pri->pri_vtable->vtp_connect)\n    return pri->pri_vtable->vtp_connect(pri, ai, tpn);\n\n  tp = tport_base_connect(pri, ai, ai, tpn);\n  if (tp)\n    tport_set_secondary_timer(tp);\n  return tp;\n}\n\n/**Create a connected transport object with socket.\n *\n * The function tport_connect() creates a secondary transport with a\n * connected socket. It registers the socket with suitable events to the\n * root.\n *\n * @param pri   primary transport object\n * @param ai    pointer to addrinfo structure describing socket\n * @param real_ai  pointer to addrinfo structure describing real target\n * @param tpn   canonical name of node\n */\ntport_t *tport_base_connect(tport_primary_t *pri,\n\t\t\t    su_addrinfo_t *ai,\n\t\t\t    su_addrinfo_t *real_ai,\n\t\t\t    tp_name_t const *tpn)\n{\n  tport_t *self = NULL;\n\n  su_socket_t s, server_socket;\n  su_wakeup_f wakeup = tport_wakeup;\n  int events = SU_WAIT_IN | SU_WAIT_ERR;\n\n  int err;\n  unsigned errlevel = 3;\n  char buf[TPORT_HOSTPORTSIZE];\n  char const *what;\n\n  /* Log an error, return error */\n#define TPORT_CONNECT_ERROR(errno, what)\t\t\t     \\\n  return\t\t\t\t\t\t\t     \\\n    ((void)(err = errno,\t\t\t\t\t     \\\n\t    (SU_LOG_LEVEL >= errlevel ?\t\t\t\t     \\\n\t     su_llog(tport_log, errlevel,\t\t\t     \\\n\t\t     \"%s(%p): %s(pf=%d %s/%s): %s\\n\",\t\t\t\\\n\t\t\t\t __func__, (void *)pri, #what, ai->ai_family,\t\\\n\t\t     tpn->tpn_proto,\t\t\t\t     \\\n\t\t     tport_hostport(buf, sizeof(buf),\t\t     \\\n\t\t\t\t    (void *)ai->ai_addr, 2),\t     \\\n\t\t     su_strerror(err)) : (void)0),\t\t     \\\n\t    tport_zap_secondary(self),\t\t\t\t     \\\n\t    su_seterrno(err)),\t\t\t\t\t     \\\n     (void *)NULL)\n\n  s = su_socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);\n  if (s == INVALID_SOCKET)\n    TPORT_CONNECT_ERROR(su_errno(), \"socket\");\n\n  what = \"tport_alloc_secondary\";\n  if ((self = tport_alloc_secondary(pri, s, 0, &what)) == NULL)\n    TPORT_CONNECT_ERROR(su_errno(), what);\n\n  self->tp_conn_orient = 1;\n\n  if ((server_socket = pri->pri_primary->tp_socket) != INVALID_SOCKET) {\n    su_sockaddr_t susa;\n    socklen_t susalen = sizeof(susa);\n\n    /* Bind this socket to same IP address as the primary server socket */\n    if (getsockname(server_socket, &susa.su_sa, &susalen) < 0) {\n      SU_DEBUG_3((\"%s(%p): getsockname(): %s\\n\",\n\t\t  __func__, (void *)self, su_strerror(su_errno())));\n    }\n    else {\n      susa.su_port = 0;\n      if (bind(s, &susa.su_sa, susalen) < 0) {\n\tSU_DEBUG_3((\"%s(%p): bind(local-ip): %s\\n\",\n\t\t    __func__, (void *)self, su_strerror(su_errno())));\n      }\n    }\n  }\n\n  /* Set sockname for the tport */\n  if (tport_setname(self, tpn->tpn_proto, real_ai, tpn->tpn_canon) == -1)\n    TPORT_CONNECT_ERROR(su_errno(), tport_setname);\n\n  /* Try to have a non-blocking connect().\n   * The tport_register_secondary() below makes the socket non-blocking anyway. */\n  su_setblocking(s, 0);\n\n  if (connect(s, ai->ai_addr, (socklen_t)(ai->ai_addrlen)) == SOCKET_ERROR) {\n    err = su_errno();\n    if (!su_is_blocking(err))\n      TPORT_CONNECT_ERROR(err, connect);\n    events = SU_WAIT_CONNECT | SU_WAIT_ERR;\n    wakeup = tport_connected;\n    what = \"connecting\";\n  }\n  else {\n    what = \"connected\";\n    self->tp_is_connected = 1;\n  }\n\n  if (tport_register_secondary(self, wakeup, events) == -1)\n    TPORT_CONNECT_ERROR(su_errno(), tport_register_secondary);\n\n  if (ai == real_ai) {\n    SU_DEBUG_5((\"%s(%p): %s to \" TPN_FORMAT \"\\n\",\n\t\t__func__, (void *)self, what, TPN_ARGS(self->tp_name)));\n  }\n  else {\n    SU_DEBUG_5((\"%s(%p): %s via %s to \" TPN_FORMAT \"\\n\",\n\t\t__func__, (void *)self, what,\n\t\ttport_hostport(buf, sizeof(buf), (void *)ai->ai_addr, 2),\n\t\tTPN_ARGS(self->tp_name)));\n  }\n\n  return self;\n}\n\n/** Register a new secondary transport. @internal */\nint tport_register_secondary(tport_t *self, su_wakeup_f wakeup, int events)\n{\n  int i;\n  su_root_t *root = tport_is_secondary(self) ? self->tp_master->mr_root : NULL;\n  su_wait_t wait[1] = { SU_WAIT_INIT };\n\n  if (root != NULL\n      /* Create wait object with appropriate events. */\n      &&\n      su_wait_create(wait, self->tp_socket, events) != -1\n      /* Register socket to root */\n      &&\n      (i = su_root_register(root, wait, wakeup, self, 0)) != -1) {\n\n    self->tp_index = i;\n    self->tp_events = events;\n\n    tprb_append(&self->tp_pri->pri_open, self);\n\n    SU_DEBUG_4((\"%s(%p): register secondary tport %p from \" TPN_FORMAT \", count(wss) is %d, count(tcp) is %d\\n\", \n      __func__, (void *)self->tp_pri, (void *)self, TPN_ARGS(self->tp_name), wssCount, tcpCount));\n\n    return 0;\n  }\n\n  su_wait_destroy(wait);\n  return -1;\n}\n\n/** Destroy a secondary transport. @internal */\nvoid tport_zap_secondary(tport_t *self)\n{\n  tport_master_t *mr;\n\n  if (self == NULL)\n    return;\n\n  /* Remove from rbtree */\n  if (!tport_is_closed(self))\n    tprb_remove(&self->tp_pri->pri_open, self);\n  else\n    tplist_remove(&self->tp_pri->pri_closed, self);\n\n  if (self->tp_timer)\n    su_timer_destroy(self->tp_timer), self->tp_timer = NULL;\n\n  /* Do not deinit primary as secondary! */\n  if (tport_is_secondary(self) && self->tp_pri->pri_vtable->vtp_deinit_secondary) {\n    self->tp_pri->pri_vtable->vtp_deinit_secondary(self);\n  }\n\n  if (self->tp_msg) {\n    msg_destroy(self->tp_msg), self->tp_msg = NULL;\n    SU_DEBUG_3((\"%s(%p): zapped partially received message\\n\",\n\t\t__func__, (void *)self));\n  }\n\n  if (tport_has_queued(self)) {\n    size_t n = 0, i, N = self->tp_params->tpp_qsize;\n    for (i = self->tp_qhead; self->tp_queue[i]; i = (i + 1) % N) {\n      msg_destroy(self->tp_queue[i]), self->tp_queue[i] = NULL;\n      n++;\n    }\n    SU_DEBUG_3((\"%s(%p): zapped %lu queued messages\\n\",\n\t\t__func__, (void *)self, (LU)n));\n  }\n\n  if (self->tp_pused) {\n    SU_DEBUG_3((\"%s(%p): zapped while pending\\n\",\n\t\t__func__, (void *)self));\n  }\n\n  mr = self->tp_master;\n\n#if HAVE_SOFIA_STUN\n  tport_stun_server_remove_socket(self);\n#endif\n\n  if (self->tp_index)\n    su_root_deregister(mr->mr_root, self->tp_index);\n  self->tp_index = 0;\n  if (self->tp_socket != INVALID_SOCKET)\n    su_close(self->tp_socket);\n  self->tp_socket = INVALID_SOCKET;\n\n  decrementSecondaryCount(self);\n  SU_DEBUG_4((\"%s(%p): zap tport %p from \" TPN_FORMAT \", count(wss) is %d, count(tcp) is %d\\n\", \n    __func__, (void *)self->tp_pri, (void *)self, TPN_ARGS(self->tp_name), wssCount, tcpCount));\n\n  su_home_zap(self->tp_home);\n}\n\n/** Create a new reference to a transport object. */\ntport_t *tport_ref(tport_t *tp)\n{\n  if (tp) {\n    if (tp->tp_refs >= 0) {\n      tp->tp_refs++;\n    }\n    else if (tp->tp_refs == -1) {\n      tp->tp_refs = 1;\n    }\n    SU_DEBUG_9((\"%s(%p): refcount is now %ld\\n\", __func__, (void *)tp, tp->tp_refs));\n\n  }\n  return tp;\n}\n\n/** Destroy reference to a transport object. */\nvoid tport_unref(tport_t *tp)\n{\n  if (tp == NULL || tp->tp_refs <= 0)\n    return;\n\n  tp->tp_refs--;\n  if (tp->tp_refs <= 1) {\n    SU_DEBUG_5((\"%s(%p): \" TPN_FORMAT \" refcount from is now %ld\\n\", \n    __func__, (void *)tp, TPN_ARGS(tp->tp_name), tp->tp_refs));\n  }\n  else SU_DEBUG_9((\"%s(%p): refcount is now %ld\\n\", __func__, (void *)tp, tp->tp_refs));\n\n  if (tp->tp_refs > 0)\n    return;\n\n  if (!tport_is_secondary(tp))\n    return;\n\n  if (tp->tp_params->tpp_idle == 0) {\n    SU_DEBUG_4((\"%s(%p): \" TPN_FORMAT \" refcount is 0 and its idle, so we can close it\\n\", \n      __func__, (void *)tp, TPN_ARGS(tp->tp_name)));\n    tport_close(tp);\n  }\n\n  tport_set_secondary_timer(tp);\n}\n\n/** Create a new reference to transport object. */\ntport_t *tport_incref(tport_t *tp)\n{\n  return tport_ref(tp);\n}\n\n/** Destroy a transport reference. */\nvoid tport_decref(tport_t **ttp)\n{\n  assert(ttp);\n\n  if (*ttp) {\n    tport_unref(*ttp);\n    *ttp = NULL;\n  }\n}\n\n/** Get transport parameters.\n *\n * @param self          pointer to a transport object\n * @param tag,value,... list of tags\n *\n * @TAGS\n * TPTAG_MTU_REF(), TPTAG_QUEUESIZE_REF(), TPTAG_IDLE_REF(),\n * TPTAG_TIMEOUT_REF(), TPTAG_KEEPALIVE_REF(), TPTAG_PINGPONG_REF(),\n * TPTAG_PONG2PING_REF(), TPTAG_DEBUG_DROP_REF(), TPTAG_THRPSIZE_REF(),\n * TPTAG_THRPRQSIZE_REF(), TPTAG_SIGCOMP_LIFETIME_REF(),\n * TPTAG_CONNECT_REF(), TPTAG_SDWN_ERROR_REF(), TPTAG_REUSE_REF(),\n * TPTAG_STUN_SERVER_REF(), TPTAG_PUBLIC_REF() and TPTAG_TOS_REF().\n */\nint tport_get_params(tport_t const *self,\n\t\t     tag_type_t tag, tag_value_t value, ...)\n{\n  ta_list ta;\n  int n;\n  tport_params_t const *tpp;\n  int connect;\n  tport_master_t *mr = self->tp_master;\n\n  if (self == NULL)\n    return su_seterrno(EINVAL);\n\n  tpp = self->tp_params;\n  ta_start(ta, tag, value);\n\n  connect = tpp->tpp_conn_orient\n    /* Only dgram primary is *not* connection-oriented */\n    || !tport_is_primary(self) || !tport_is_dgram(self);\n\n  n = tl_tgets(ta_args(ta),\n\t       TPTAG_MTU((usize_t)tpp->tpp_mtu),\n\t       TPTAG_REUSE(self->tp_reusable),\n\t       TPTAG_CONNECT(connect),\n\t       TPTAG_QUEUESIZE(tpp->tpp_qsize),\n\t       TPTAG_IDLE(tpp->tpp_idle),\n\t       TPTAG_TIMEOUT(tpp->tpp_timeout),\n\t       TPTAG_SOCKET_KEEPALIVE(tpp->tpp_socket_keepalive),\n\t       TPTAG_KEEPALIVE(tpp->tpp_keepalive),\n\t       TPTAG_PINGPONG(tpp->tpp_pingpong),\n\t       TPTAG_PONG2PING(tpp->tpp_pong2ping),\n\t       TPTAG_SDWN_ERROR(tpp->tpp_sdwn_error),\n\t       TPTAG_DEBUG_DROP(tpp->tpp_drop),\n\t       TPTAG_THRPSIZE(tpp->tpp_thrpsize),\n\t       TPTAG_THRPRQSIZE(tpp->tpp_thrprqsize),\n\t       TPTAG_SIGCOMP_LIFETIME(tpp->tpp_sigcomp_lifetime),\n\t       TPTAG_STUN_SERVER(tpp->tpp_stun_server),\n\t       TAG_IF(self->tp_pri,\n\t\t      TPTAG_PUBLIC(self->tp_pri ?\n\t\t\t\t   self->tp_pri->pri_public : 0)),\n\t       TPTAG_TOS(tpp->tpp_tos),\n\t       TAG_IF((void *)self == (void *)mr,\n\t\t      TPTAG_LOG(mr->mr_log != 0)),\n\t       TAG_IF((void *)self == (void *)mr,\n\t\t      TPTAG_DUMP(mr->mr_dump)),\n\t       TAG_END());\n\n  ta_end(ta);\n\n  return n;\n}\n\n/** Set transport parameters.\n *\n * @param self          pointer to a transport object\n * @param tag,value,... list of tags\n *\n * @TAGS\n * TPTAG_MTU(), TPTAG_QUEUESIZE(), TPTAG_IDLE(), TPTAG_TIMEOUT(),\n * TPTAG_KEEPALIVE(), TPTAG_PINGPONG(), TPTAG_PONG2PING(),\n * TPTAG_DEBUG_DROP(), TPTAG_THRPSIZE(), TPTAG_THRPRQSIZE(),\n * TPTAG_SIGCOMP_LIFETIME(), TPTAG_CONNECT(), TPTAG_SDWN_ERROR(),\n * TPTAG_REUSE(), TPTAG_STUN_SERVER(), and TPTAG_TOS().\n */\nint tport_set_params(tport_t *self,\n\t\t     tag_type_t tag, tag_value_t value, ...)\n{\n  ta_list ta;\n  int n, m = 0;\n  tport_params_t tpp[1], *tpp0;\n\n  usize_t mtu;\n  int connect, sdwn_error, reusable, stun_server, pong2ping;\n\n  if (self == NULL)\n    return su_seterrno(EINVAL);\n\n  memcpy(tpp, tpp0 = self->tp_params, sizeof tpp);\n\n  mtu = tpp->tpp_mtu;\n  connect = tpp->tpp_conn_orient;\n  sdwn_error = tpp->tpp_sdwn_error;\n  reusable = self->tp_reusable;\n  stun_server = tpp->tpp_stun_server;\n  pong2ping = tpp->tpp_pong2ping;\n\n  ta_start(ta, tag, value);\n\n  n = tl_gets(ta_args(ta),\n\t      TPTAG_MTU_REF(mtu),\n\t      TAG_IF(!self->tp_queue, TPTAG_QUEUESIZE_REF(tpp->tpp_qsize)),\n\t      TPTAG_IDLE_REF(tpp->tpp_idle),\n\t      TPTAG_TIMEOUT_REF(tpp->tpp_timeout),\n\t      TPTAG_SOCKET_KEEPALIVE_REF(tpp->tpp_socket_keepalive),\n\t      TPTAG_KEEPALIVE_REF(tpp->tpp_keepalive),\n\t      TPTAG_PINGPONG_REF(tpp->tpp_pingpong),\n\t      TPTAG_PONG2PING_REF(pong2ping),\n\t      TPTAG_DEBUG_DROP_REF(tpp->tpp_drop),\n\t      TPTAG_THRPSIZE_REF(tpp->tpp_thrpsize),\n\t      TPTAG_THRPRQSIZE_REF(tpp->tpp_thrprqsize),\n\t      TPTAG_SIGCOMP_LIFETIME_REF(tpp->tpp_sigcomp_lifetime),\n\t      TPTAG_CONNECT_REF(connect),\n\t      TPTAG_SDWN_ERROR_REF(sdwn_error),\n\t      TPTAG_REUSE_REF(reusable),\n\t      TPTAG_STUN_SERVER_REF(stun_server),\n\t      TPTAG_TOS_REF(tpp->tpp_tos),\n\t      TAG_END());\n\n  if (self == (tport_t *)self->tp_master)\n    m = tport_open_log(self->tp_master, ta_args(ta));\n\n  ta_end(ta);\n\n  if (n == 0)\n    return m;\n\n  if (tpp->tpp_idle > 0 && tpp->tpp_idle < 100)\n    tpp->tpp_idle = 100;\n  if (tpp->tpp_timeout < 100)\n    tpp->tpp_timeout = 100;\n  if (tpp->tpp_drop > 1000)\n    tpp->tpp_drop = 1000;\n  if (tpp->tpp_thrprqsize > 0)\n    tpp->tpp_thrprqsize = tpp0->tpp_thrprqsize;\n  if (tpp->tpp_sigcomp_lifetime != 0 && tpp->tpp_sigcomp_lifetime < 30)\n    tpp->tpp_sigcomp_lifetime = 30;\n  if (tpp->tpp_qsize >= 1000)\n    tpp->tpp_qsize = 1000;\n\n  if (mtu > UINT_MAX)\n    mtu = UINT_MAX;\n  tpp->tpp_mtu = (unsigned)mtu;\n  /* Currently only primary UDP transport can *not* be connection oriented */\n  tpp->tpp_conn_orient = connect;\n  tpp->tpp_sdwn_error = sdwn_error;\n  self->tp_reusable = reusable;\n  tpp->tpp_stun_server = stun_server;\n  tpp->tpp_pong2ping = pong2ping;\n\n  if (memcmp(tpp0, tpp, sizeof tpp) == 0)\n    return n + m;\n\n  if (tport_is_secondary(self) &&\n      self->tp_params == self->tp_pri->pri_primary->tp_params) {\n    tpp0 = su_zalloc(self->tp_home, sizeof *tpp0); if (!tpp0) return -1;\n    self->tp_params = tpp0;\n  }\n\n  memcpy(tpp0, tpp, sizeof tpp);\n\n  if (tport_is_secondary(self))\n    tport_set_secondary_timer(self);\n\n  return n + m;\n}\n\nextern tport_vtable_t const tport_udp_vtable;\nextern tport_vtable_t const tport_tcp_vtable;\nextern tport_vtable_t const tport_tls_vtable;\nextern tport_vtable_t const tport_ws_vtable;\nextern tport_vtable_t const tport_wss_vtable;\nextern tport_vtable_t const tport_sctp_vtable;\nextern tport_vtable_t const tport_udp_client_vtable;\nextern tport_vtable_t const tport_tcp_client_vtable;\nextern tport_vtable_t const tport_sctp_client_vtable;\nextern tport_vtable_t const tport_ws_client_vtable;\nextern tport_vtable_t const tport_wss_client_vtable;\nextern tport_vtable_t const tport_tls_client_vtable;\nextern tport_vtable_t const tport_http_connect_vtable;\nextern tport_vtable_t const tport_threadpool_vtable;\n\n#define TPORT_NUMBER_OF_TYPES 64\n\ntport_vtable_t const *tport_vtables[TPORT_NUMBER_OF_TYPES + 1] =\n{\n#if HAVE_SOFIA_NTH\n  &tport_http_connect_vtable,\n  &tport_ws_client_vtable,\n  &tport_ws_vtable,\n  &tport_wss_client_vtable,\n  &tport_wss_vtable,\n#endif\n#if HAVE_TLS\n  &tport_tls_client_vtable,\n  &tport_tls_vtable,\n#endif\n#if HAVE_SCTP\t\t/* SCTP is broken */\n  &tport_sctp_client_vtable,\n  &tport_sctp_vtable,\n#endif\n  &tport_tcp_client_vtable,\n  &tport_tcp_vtable,\n  &tport_udp_client_vtable,\n  &tport_udp_vtable,\n#if 0\n  &tport_threadpool_vtable,\n#endif\n#if HAVE_SOFIA_STUN\n  &tport_stun_vtable,\n#endif\n};\n\n/** Register new transport vtable */\nint tport_register_type(tport_vtable_t const *vtp)\n{\n  int i;\n\n  for (i = TPORT_NUMBER_OF_TYPES; i >= 0; i--) {\n    if (tport_vtables[i] == NULL) {\n      tport_vtables[i] = vtp;\n      return 0;\n    }\n  }\n\n  su_seterrno(ENOMEM);\n  return -1;\n}\n\n/**Get a vtable for given protocol */\ntport_vtable_t const *tport_vtable_by_name(char const *protoname,\n\t\t\t\t\t   enum tport_via public)\n{\n  int i;\n\n  for (i = TPORT_NUMBER_OF_TYPES; i >= 0; i--) {\n    tport_vtable_t const *vtable = tport_vtables[i];\n\n    if (vtable == NULL)\n      continue;\n    if (vtable->vtp_public != public)\n      continue;\n    if (!su_casematch(protoname, vtable->vtp_name))\n      continue;\n\n    assert(vtable->vtp_pri_size >= sizeof (tport_primary_t));\n    assert(vtable->vtp_secondary_size >= sizeof (tport_t));\n\n    return vtable;\n  }\n\n  return NULL;\n}\n\n#if 0\ntport_set_f const *tport_set_methods[TPORT_NUMBER_OF_TYPES + 1] =\n  {\n    tport_server_bind_set,\n    tport_client_bind_set,\n    tport_threadpool_set,\n#if HAVE_SOFIA_NTH\n    tport_http_connect_set,\n#endif\n#if HAVE_TLS\n    tport_tls_set,\n#endif\n    NULL\n  };\n\nint tport_bind_set(tport_master_t *mr,\n\t\t   tp_name_t const *tpn,\n\t\t   char const * const transports[],\n\t\t   tagi_t const *taglist,\n\t\t   tport_set_t **return_set,\n\t\t   int set_size)\n{\n  int i;\n\n  for (i = TPORT_NUMBER_OF_TYPES; i >= 0; i--) {\n    tport_set_f const *perhaps = tport_vtables[i];\n    int result;\n\n    if (perhaps == NULL)\n      continue;\n\n    result = perhaps(mr, tpn, transports, taglist, return_set, set_size);\n    if (result != 0)\n      return result;\n  }\n\n  return 0;\n}\n#endif\n\n/** Bind transport objects.\n *\n * @param self        pointer to a transport object\n * @param tpn         desired transport address\n * @param transports  list of protocol names supported by stack\n * @param tag,value,... tagged argument list\n *\n * @TAGS\n * TPTAG_SERVER(), TPTAG_PUBLIC(), TPTAG_IDENT(), TPTAG_HTTP_CONNECT(),\n * TPTAG_CERTIFICATE(), TPTAG_TLS_VERSION(), TPTAG_TLS_VERIFY_POLICY, and \n * tags used with tport_set_params(), especially TPTAG_QUEUESIZE().\n */\nint tport_tbind(tport_t *self,\n\t\ttp_name_t const *tpn,\n\t\tchar const * const transports[],\n\t\ttag_type_t tag, tag_value_t value, ...)\n{\n  ta_list ta;\n  int server = 1, retval, public = 0;\n  tp_name_t mytpn[1];\n  tport_master_t *mr;\n  char const *http_connect = NULL;\n\n  if (self == NULL || tport_is_secondary(self) ||\n      tpn == NULL || transports == NULL) {\n    su_seterrno(EINVAL);\n    return -1;\n  }\n\n  *mytpn = *tpn;\n\n  if (mytpn->tpn_ident == NULL)\n    mytpn->tpn_ident = self->tp_ident;\n\n  ta_start(ta, tag, value);\n\n  tl_gets(ta_args(ta),\n\t  TPTAG_SERVER_REF(server),\n\t  TPTAG_PUBLIC_REF(public),\n\t  TPTAG_IDENT_REF(mytpn->tpn_ident),\n\t  TPTAG_HTTP_CONNECT_REF(http_connect),\n\t  TAG_END());\n\n  mr = self->tp_master; assert(mr);\n\n  if (http_connect && public == 0)\n    public = tport_type_connect;\n\n  if (public && public != tport_type_stun)\n    server = 0;\n\n  if (server)\n    retval = tport_bind_server(mr, mytpn, transports, (enum tport_via)public, ta_args(ta));\n  else\n    retval = tport_bind_client(mr, mytpn, transports, (enum tport_via)public, ta_args(ta));\n\n  ta_end(ta);\n\n  return retval;\n}\n\n\n/** Bind primary transport objects used by a client-only application.\n * @internal\n */\nint tport_bind_client(tport_master_t *mr,\n                      tp_name_t const *tpn,\n                      char const * const transports[],\n\t\t      enum tport_via public,\n\t\t      tagi_t *tags)\n{\n  int i;\n  tport_primary_t *pri = NULL, **tbf;\n  tp_name_t tpn0[1] = {{ \"*\", \"*\", \"*\", \"*\", NULL, NULL }};\n  char const *why = \"unknown\";\n\n  tport_vtable_t const *vtable;\n\n  if (public == tport_type_local)\n    public = tport_type_client;\n\n  SU_DEBUG_5((\"%s(%p) to \" TPN_FORMAT \"\\n\",\n\t      __func__, (void *)mr, TPN_ARGS(tpn)));\n\n  memset(tpn0, 0, sizeof(tpn0));\n\n  for (tbf = &mr->mr_primaries; *tbf; tbf = &(*tbf)->pri_next)\n    ;\n\n  for (i = 0; transports[i]; i++) {\n    su_addrinfo_t hints[1];\n    char const *proto = transports[i];\n\n    if (strcmp(proto, tpn->tpn_proto) != 0 &&\n        strcmp(tpn->tpn_proto, tpn_any) != 0)\n      continue;\n\n    vtable = tport_vtable_by_name(proto, public);\n    if (!vtable)\n      continue;\n\n    /* Resolve protocol, skip unknown transport protocols */\n    if (getprotohints(hints, proto, AI_PASSIVE) < 0)\n      continue;\n\n    tpn0->tpn_proto = proto;\n    tpn0->tpn_comp = tpn->tpn_comp;\n    tpn0->tpn_ident = tpn->tpn_ident;\n\n    hints->ai_canonname = \"*\";\n\n    if (!(pri = tport_alloc_primary(mr, vtable, tpn0, hints, tags, &why)))\n      break;\n\n    pri->pri_public = tport_type_client; /* XXX */\n  }\n\n  if (!pri) {\n    SU_DEBUG_3((\"tport_alloc_primary: %s failed\\n\", why));\n    tport_zap_primary(*tbf);\n  }\n\n  return pri ? 0 : -1;\n}\n\n/** Bind primary transport objects used by a server application. */\nint tport_bind_server(tport_master_t *mr,\n                      tp_name_t const *tpn,\n                      char const * const transports[],\n\t\t      enum tport_via public,\n\t\t      tagi_t *tags)\n{\n  char hostname[TPORT_HOSTPORTSIZE];\n  char const *canon = NULL, *host, *service;\n  int error = 0, family = 0;\n  tport_primary_t *pri = NULL, **tbf;\n  su_addrinfo_t *ai, *res = NULL;\n  unsigned port, port0, port1, old;\n  unsigned short step = 0;\n\n  bind6only_check(mr);\n\n  (void)hostname;\n\n  SU_DEBUG_5((\"%s(%p) to \" TPN_FORMAT \"\\n\",\n\t      __func__, (void *)mr, TPN_ARGS(tpn)));\n\n  if (tpn->tpn_host == NULL || strcmp(tpn->tpn_host, tpn_any) == 0) {\n    /* Use a local IP address */\n    host = NULL;\n  }\n#ifdef SU_HAVE_IN6\n  else if (host_is_ip6_reference(tpn->tpn_host)) {\n    /* Remove [] around IPv6 addresses. */\n    size_t len = strlen(tpn->tpn_host);\n    assert(len < sizeof hostname);\n    host = memcpy(hostname, tpn->tpn_host + 1, len - 2);\n    hostname[len - 2] = '\\0';\n  }\n#endif\n  else\n    host = tpn->tpn_host;\n\n  if (tpn->tpn_port != NULL && strlen(tpn->tpn_port) > 0 &&\n      strcmp(tpn->tpn_port, tpn_any) != 0)\n    service = tpn->tpn_port;\n  else\n    service = \"\";\n\n  if (host && (strcmp(host, \"0.0.0.0\") == 0 || strcmp(host, \"0\") == 0))\n    host = NULL, family = AF_INET;\n#if SU_HAVE_IN6\n  else if (host && strcmp(host, \"::\") == 0)\n    host = NULL, family = AF_INET6;\n#endif\n\n  if (tpn->tpn_canon && strcmp(tpn->tpn_canon, tpn_any) &&\n      (host || tpn->tpn_canon != tpn->tpn_host))\n    canon = tpn->tpn_canon;\n\n  if (tport_server_addrinfo(mr, canon, family,\n\t\t\t    host, service, tpn->tpn_proto,\n\t\t\t    transports, &res) < 0)\n    return -1;\n\n  for (tbf = &mr->mr_primaries; *tbf; tbf = &(*tbf)->pri_next)\n    ;\n\n  port = port0 = port1 = ntohs(((su_sockaddr_t *)res->ai_addr)->su_port);\n  error = EPROTONOSUPPORT;\n\n  /*\n   * Loop until we can bind all the transports requested\n   * by the transport user to the same port.\n   */\n  for (;;) {\n    for (ai = res; ai; ai = ai->ai_next) {\n      tp_name_t tpname[1];\n      su_addrinfo_t ainfo[1];\n      su_sockaddr_t su[1];\n      tport_vtable_t const *vtable;\n\n      vtable = tport_vtable_by_name(ai->ai_canonname, public);\n      if (!vtable)\n\tcontinue;\n\n      tport_addrinfo_copy(ainfo, su, sizeof su, ai);\n      ainfo->ai_canonname = (char *)canon;\n      su->su_port = htons(port);\n\n      memcpy(tpname, tpn, sizeof tpname);\n      tpname->tpn_canon = canon;\n      tpname->tpn_host = host;\n\n      SU_DEBUG_9((\"%s(%p): calling tport_listen for %s\\n\",\n\t\t  __func__, (void *)mr, ai->ai_canonname));\n\n      pri = tport_listen(mr, vtable, tpname, ainfo, tags);\n      if (!pri) {\n\tswitch (error = su_errno()) {\n\tcase EADDRNOTAVAIL:\t/* Not our address */\n\tcase ENOPROTOOPT:\t/* Protocol not supported */\n\tcase ESOCKTNOSUPPORT:\t/* Socket type not supported */\n\t  continue;\n\tdefault:\n\t  break;\n\t}\n\tbreak;\n      }\n\n      if (port0 == 0 && port == 0) {\n\tport = port1 = ntohs(su->su_port);\n\tassert(public != tport_type_server || port != 0);\n      }\n    }\n\n    if (ai == NULL)\n      break;\n\n    while (*tbf)\n      tport_zap_primary(*tbf);\n\n    if (error != EADDRINUSE || port0 != 0 || port == 0)\n      break;\n\n    while (step == 0) {\n      /* step should be relative prime to 65536 - 1024 */\n      /* 65536 - 1024 = 7 * 3 * 3 * 1024 */\n      step = su_randint(1, 65535 - 1024 - 1) | 1;\n      if (step % 3 == 0)\n\tstep = (step + 2) % (65536 - 1024);\n      if (step % 7 == 0)\n\tstep = (step + 2) % (65536 - 1024);\n    }\n    old = port; port += step; if (port >= 65536) port -= (65536 - 1024);\n\n    if (port == port1)\t\t/* All ports in use! */\n      break;\n\n    SU_DEBUG_3((\"%s(%p): cannot bind all transports to port %u, trying %u\\n\",\n\t\t__func__, (void *)mr, old, port));\n  }\n\n  tport_freeaddrinfo(res);\n\n  if (!*tbf) {\n    su_seterrno(error);\n    return -1;\n  }\n\n  return 0;\n}\n\n\n/** Check if we can bind to IPv6 separately from IPv4 bind */\nstatic\nint bind6only_check(tport_master_t *mr)\n{\n  int retval = 0;\n#if SU_HAVE_IN6\n  su_sockaddr_t su[1], su4[1];\n  socklen_t sulen, su4len;\n  int s6, s4;\n\n  if (mr->mr_boundserver)\n    return 0;\n\n  s4 = su_socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);\n  s6 = su_socket(AF_INET6, SOCK_DGRAM, IPPROTO_UDP);\n\n  memset(su, 0, sizeof *su);\n  su->su_len = sulen = (sizeof su->su_sin6);\n  su->su_family = AF_INET6;\n\n  memset(su4, 0, sizeof *su4);\n  su4->su_len = su4len = (sizeof su->su_sin);\n  su4->su_family = AF_INET;\n\n  if (bind(s6, &su->su_sa, sulen) < 0)\n    ;\n  else if (getsockname(s6, &su->su_sa, &sulen) < 0)\n    ;\n  else if ((su4->su_port = su->su_port) != 0 &&\n\t   bind(s4, &su4->su_sa, su4len) == 0)\n    retval = 1;\n\n  su_close(s6), su_close(s4);\n\n  mr->mr_bindv6only = retval;\n  mr->mr_boundserver = 1;\n#endif\n\n  return retval;\n}\n\n/* Number of supported transports */\n#define TPORT_N (8)\n\n/** Return list of addrinfo structures matching to\n * canon/host/service/protocol\n */\nstatic\nint tport_server_addrinfo(tport_master_t *mr,\n\t\t\t  char const *canon,\n\t\t\t  int family,\n\t\t\t  char const *host,\n\t\t\t  char const *service,\n\t\t\t  char const *protocol,\n\t\t\t  char const * const transports[],\n\t\t\t  su_addrinfo_t **return_addrinfo)\n{\n  int i, N;\n  su_addrinfo_t hints[TPORT_N + 1];\n\n  *return_addrinfo = NULL;\n\n  /*\n   * Resolve all the transports requested by the protocol\n   */\n  for (i = 0, N = 0; transports[i] && N < TPORT_N; i++) {\n    su_addrinfo_t *ai = &hints[N];\n\n    if (!su_casematch(protocol, transports[i]) && !su_strmatch(protocol, \"*\"))\n      continue;\n\n    /* Resolve protocol, skip unknown transport protocols. */\n    if (getprotohints(ai, transports[i], AI_PASSIVE) < 0)\n      continue;\n\n    ai->ai_family = family;\n    ai->ai_next = &hints[++N];\n  }\n\n  if (N == 0)\n    return su_seterrno(EPROTONOSUPPORT);\n  if (transports[i] /* Too many protocols */)\n    return su_seterrno(ENOMEM);\n\n  hints[N - 1].ai_next = NULL;\n\n  if (host) {\n    int error = tport_getaddrinfo(host, service, hints, return_addrinfo);\n    if (error || !*return_addrinfo) {\n      SU_DEBUG_3((\"%s(%p): su_getaddrinfo(%s, %s) for %s: %s\\n\",\n\t\t  __func__, (void *)mr,\n\t\t  host ? host : \"\\\"\\\"\", service, protocol,\n\t\t  su_gai_strerror(error)));\n      return su_seterrno(error != EAI_MEMORY ? ENOENT : ENOMEM);\n    }\n    return 0;\n  }\n\n  return tport_get_local_addrinfo(mr, service, hints, return_addrinfo);\n}\n\n/** Convert localinfo into addrinfo */\nstatic\nint\ntport_get_local_addrinfo(tport_master_t *mr,\n\t\t\t char const *port,\n\t\t\t su_addrinfo_t const *hints,\n\t\t\t su_addrinfo_t **return_ai)\n{\n  int error, family;\n  su_localinfo_t lihints[1] = {{ 0 }};\n  su_localinfo_t *li, *li_result;\n  su_addrinfo_t const *h;\n  su_addrinfo_t *ai, **prev;\n  su_sockaddr_t *su;\n  unsigned long lport = 0;\n  char *rest;\n\n  prev = return_ai, *prev = NULL;\n\n  if (port) {\n    lport = strtoul(port, &rest, 10);\n    if (lport >= 65536) {\n      su_seterrno(EINVAL);\n      return -1;\n    }\n  }\n\n  family = hints->ai_family;\n\n  for (h = hints->ai_next; h && family; h = h->ai_next)\n    if (h->ai_family != family)\n      family = 0;\n\n  lihints->li_flags = 0;\n  lihints->li_family = family;\n  lihints->li_scope = LI_SCOPE_GLOBAL | LI_SCOPE_SITE | LI_SCOPE_HOST;\n\n  error = su_getlocalinfo(lihints, &li_result);\n  if (error) {\n#if SU_HAVE_IN6\n    SU_DEBUG_3((\"%s(%p): su_getlocalinfo() for %s address: %s\\n\",\n\t\t__func__, (void *)mr,\n\t\tfamily == AF_INET6 ? \"ip6\"\n\t\t: family == AF_INET ? \"ip4\" : \"ip\",\n\t\tsu_gli_strerror(error)));\n#else\n    SU_DEBUG_3((\"%s(%p): su_getlocalinfo() for %s address: %s\\n\",\n\t\t__func__, (void *)mr,\n\t\tfamily == AF_INET ? \"ip4\" : \"ip\",\n\t\tsu_gli_strerror(error)));\n#endif\n    su_seterrno(ENOENT);\n    return -1;\n  }\n\n  for (li = li_result; li; li = li->li_next) {\n    for (h = hints; h; h = h->ai_next) {\n      if (h->ai_family && h->ai_family != li->li_family)\n\tcontinue;\n\n      ai = calloc(1, sizeof *ai + li->li_addrlen);\n      if (ai == NULL)\n\tbreak;\n\n      *prev = ai, prev = &ai->ai_next;\n\n      ai->ai_flags = AI_PASSIVE | TP_AI_ANY;\n      ai->ai_family = li->li_family;\n      ai->ai_socktype = h->ai_socktype;\n      ai->ai_protocol = h->ai_protocol;\n      ai->ai_canonname = h->ai_canonname;\n      ai->ai_addr = memcpy(ai + 1, li->li_addr,\n\t\t\t   ai->ai_addrlen = li->li_addrlen);\n      su = (void *)ai->ai_addr;\n      su->su_port = htons(lport);\n    }\n  }\n\n  su_freelocalinfo(li_result);\n\n  if (li) {\n    tport_freeaddrinfo(*return_ai);\n    su_seterrno(ENOMEM);\n    return -1;\n  }\n\n  if (*return_ai == NULL) {\n    su_seterrno(ENOENT);\n    return -1;\n  }\n\n  return 0;\n}\n\nsu_inline su_addrinfo_t *get_next_addrinfo(su_addrinfo_t **all);\n\n/** Translate address and service.\n *\n * This is a getaddrinfo() supporting multiple hints in a list.\n */\nint tport_getaddrinfo(char const *node, char const *service,\n\t\t      su_addrinfo_t const *hints,\n\t\t      su_addrinfo_t **res)\n{\n  su_addrinfo_t const *h0;\n  su_addrinfo_t *tbf, **prev;\n  int error = EAI_SOCKTYPE;\n  int i, N;\n  su_addrinfo_t *all[TPORT_N + 1]; /* Lists for all supported transports */\n  su_addrinfo_t *results[TPORT_N + 1];\n  void *addr;\n  int addrlen;\n\n  *res = NULL;\n\n  for (N = 0, h0 = hints; h0; h0 = h0->ai_next) {\n    su_addrinfo_t h[1];\n\n    *h = *h0, h->ai_next = NULL, h->ai_canonname = NULL;\n\n    error = su_getaddrinfo(node, service, h, &all[N]);\n    results[N] = all[N];\n    if (error == EAI_SOCKTYPE) {\n      SU_DEBUG_7((\"%s(): su_getaddrinfo(%s, %s) for %s: %s\\n\",\n\t\t  __func__, node ? node : \"\\\"\\\"\", service,\n\t\t  h0->ai_canonname, su_gai_strerror(error)));\n      continue;\n    }\n\n    if (error || !all[N])\n      break;\n    N++;\n  }\n\n  if (h0)\n    for (i = 0; i < N; i++)\n      su_freeaddrinfo(all[i]);\n  if (error)\n    return error;\n\n  /* Combine all the valid addrinfo structures to a single list */\n  prev = &tbf, tbf = NULL;\n\n  for (;;) {\n    su_addrinfo_t *ai = NULL, *ai0;\n\n    for (i = 0, h0 = hints; i < N; i++, h0 = h0->ai_next) {\n      if ((ai = get_next_addrinfo(&results[i])))\n\tbreak;\n    }\n    if (i == N)\n      break;\n\n    assert(ai);\n    addr = SU_ADDR((su_sockaddr_t *)ai->ai_addr);\n    addrlen = SU_ADDRLEN((su_sockaddr_t *)ai->ai_addr);\n\n    /* Copy all the addrinfo structures with same address to the list */\n    for (; i < N; i++, h0 = h0->ai_next) {\n      while ((ai0 = get_next_addrinfo(&results[i]))) {\n\tvoid *a = SU_ADDR((su_sockaddr_t *)ai0->ai_addr);\n\n\tif (memcmp(addr, a, addrlen)) /* Different address */\n\t  break;\n\n\tresults[i] = ai0->ai_next;\n\n\tai = calloc(1, sizeof *ai + ai0->ai_addrlen);\n\tif (ai == NULL)\n\t  goto error;\n\t*prev = memcpy(ai, ai0, sizeof *ai); prev = &ai->ai_next; *prev = NULL;\n\tai->ai_addr = memcpy(ai + 1, ai0->ai_addr, ai0->ai_addrlen);\n\tai->ai_canonname = h0->ai_canonname;\n      }\n    }\n  }\n\n  for (i = 0; i < N; i++)\n    su_freeaddrinfo(all[i]);\n\n  *res = tbf;\n  return 0;\n\n error:\n  for (i = 0; i < N; i++)\n    su_freeaddrinfo(all[i]);\n  tport_freeaddrinfo(tbf);\n  return EAI_MEMORY;\n}\n\nsu_inline\nsu_addrinfo_t *get_next_addrinfo(su_addrinfo_t **all)\n{\n  su_addrinfo_t *ai;\n\n  while ((ai = *all)) {\n    if (ai->ai_family == AF_INET)\n      return ai;\n#if SU_HAVE_IN6\n    if (ai->ai_family == AF_INET6)\n      return ai;\n#endif\n    *all = ai->ai_next;\n  }\n  return ai;\n}\n\nstatic\nvoid tport_freeaddrinfo(su_addrinfo_t *ai)\n{\n  su_addrinfo_t *ai_next;\n\n  while (ai) {\n    ai_next = ai->ai_next;\n    free(ai);\n    ai = ai_next;\n  }\n}\n\nstatic\nint tport_addrinfo_copy(su_addrinfo_t *dst, void *addr, socklen_t addrlen,\n\t\t\tsu_addrinfo_t const *src)\n{\n  if (addrlen < src->ai_addrlen)\n    return -1;\n\n  memcpy(dst, src, sizeof *dst);\n\n  if (src->ai_addrlen < addrlen)\n    memset(addr, 0, addrlen);\n\n  dst->ai_addr = memcpy(addr, src->ai_addr, src->ai_addrlen);\n  dst->ai_next = NULL;\n\n  return 0;\n}\n\n/** Close a transport.\n *\n * Close the socket associated with a transport object. Report an error to\n * all pending clients, if required. Set/reset timer, too.\n */\nvoid tport_close(tport_t *self)\n{\n  SU_DEBUG_4((\"%s(%p): \" TPN_FORMAT \"\\n\",\n\t      __func__, (void *)self, TPN_ARGS(self->tp_name)));\n\n  if (self->tp_refs == -1) {\n\t  self->tp_refs = 0;\n  }\n\n  if (self->tp_closed || !tport_is_secondary(self))\n    return;\n\n  tprb_remove(&self->tp_pri->pri_open, self);\n  tplist_insert(&self->tp_pri->pri_closed, self);\n\n  self->tp_closed = 1;\n  self->tp_send_close = 3;\n  self->tp_recv_close = 3;\n\n  if (self->tp_params->tpp_sdwn_error && self->tp_pused)\n    tport_error_report(self, -1, NULL);\n\n  if (self->tp_pri->pri_vtable->vtp_shutdown)\n    self->tp_pri->pri_vtable->vtp_shutdown(self, 2);\n  else if (self->tp_socket != -1)\n    shutdown(self->tp_socket, 2);\n\n  if (self->tp_index)\n    su_root_deregister(self->tp_master->mr_root, self->tp_index);\n  self->tp_index = 0;\n#if SU_HAVE_BSDSOCK\n  if (self->tp_socket != -1)\n    su_close(self->tp_socket);\n  self->tp_socket = -1;\n#endif\n\n  /* Zap the queued messages */\n  if (self->tp_queue) {\n    unsigned short i, N = self->tp_params->tpp_qsize;\n    for (i = 0; i < N; i++) {\n      if (self->tp_queue[i])\n\tmsg_ref_destroy(self->tp_queue[i]), self->tp_queue[i] = NULL;\n    }\n  }\n\n  self->tp_index = 0;\n  self->tp_events = 0;\n}\n\n/** Shutdown a transport.\n *\n * The tport_shutdown() shuts down a full-duplex transport connection\n * partially or completely. If @a how is 0, the further incoming data is\n * shut down. If @a how is 1, further outgoing data is shut down. If @a how\n * is 2, both incoming and outgoing traffic is shut down.\n *\n */\nint tport_shutdown(tport_t *self, int how)\n{\n  int retval;\n  if (!tport_is_secondary(self))\n    return -1;\n  retval = tport_shutdown0(self, how);\n  tport_set_secondary_timer(self);\n  return retval;\n}\n\n/** Internal shutdown function */\nint tport_shutdown0(tport_t *self, int how)\n{\n  SU_DEBUG_4((\"%s(%p, %d) \" TPN_FORMAT \"\\n\", __func__, (void *)self, how, TPN_ARGS(self->tp_name)));\n\n  if (!tport_is_tcp(self) ||\n      how < 0 || how >= 2 ||\n      (how == 0 && self->tp_send_close) ||\n      (how == 1 && self->tp_recv_close > 1)) {\n    tport_close(self);\n    return 1;\n  }\n\n  if (self->tp_pri->pri_vtable->vtp_shutdown)\n    self->tp_pri->pri_vtable->vtp_shutdown(self, how);\n  else\n    shutdown(self->tp_socket, how);\n\n  if (how == 0) {\n    self->tp_recv_close = 2;\n    tport_set_events(self, 0, SU_WAIT_IN);\n    if (self->tp_params->tpp_sdwn_error && self->tp_pused)\n      tport_error_report(self, -1, NULL);\n  }\n  else if (how == 1) {\n    self->tp_send_close = 2;\n    tport_set_events(self, 0, SU_WAIT_OUT);\n    if (tport_has_queued(self)) {\n      unsigned short i, N = self->tp_params->tpp_qsize;\n      for (i = 0; i < N; i++) {\n\tif (self->tp_queue[i]) {\n\t  tport_pending_errmsg(self, self->tp_queue[i], EPIPE);\n\t  msg_ref_destroy(self->tp_queue[i]), self->tp_queue[i] = NULL;\n\t}\n      }\n    }\n  }\n\n  return 0;\n}\n\nstatic void tport_secondary_timer(su_root_magic_t *magic,\n\t\t\t\t  su_timer_t *t,\n\t\t\t\t  tport_t *self)\n{\n  su_time_t now;\n\n  if (tport_is_closed(self)) {\n    if (self->tp_refs == 0)\n      tport_zap_secondary(self);\n    return;\n  }\n\n  now = /* su_timer_expired(t); */ su_now();\n\n  if (self->tp_pri->pri_vtable->vtp_secondary_timer)\n    self->tp_pri->pri_vtable->vtp_secondary_timer(self, now);\n  else\n    tport_base_timer(self, now);\n}\n\n/** Base timer for secondary transports.\n *\n * Closes and zaps unused transports.  Sets the timer again.\n */\nvoid tport_base_timer(tport_t *self, su_time_t now)\n{\n  unsigned timeout = self->tp_params->tpp_idle;\n\n  if (timeout != UINT_MAX) {\n    if (self->tp_refs == 0 &&\n\tself->tp_msg == NULL &&\n\t!tport_has_queued(self) &&\n\tsu_time_cmp(su_time_add(self->tp_rtime, timeout), now) < 0 &&\n\tsu_time_cmp(su_time_add(self->tp_stime, timeout), now) < 0) {\n      SU_DEBUG_7((\"%s(%p): unused for %d ms,%s zapping\\n\",\n\t\t  __func__, (void *)self,\n\t\t  timeout, tport_is_closed(self) ? \"\" : \" closing and\"));\n      if (!tport_is_closed(self))\n\ttport_close(self);\n      tport_zap_secondary(self);\n      return;\n    }\n  }\n\n  tport_set_secondary_timer(self);\n}\n\n/** Set timer for a secondary transport.\n *\n * This function should be called after any network activity:\n * tport_base_connect(), tport_send_msg(), tport_send_queue(),\n * tport_recv_data(), tport_shutdown0(), tport_close(),\n *\n * @retval 0 always\n */\nint tport_set_secondary_timer(tport_t *self)\n{\n  su_time_t const infinity = { ULONG_MAX, 999999 };\n  su_time_t target = infinity;\n  char const *why = \"not specified\";\n  su_timer_f timer = tport_secondary_timer;\n\n  if (!tport_is_secondary(self))\n    return 0;\n\n  if (tport_is_closed(self)) {\n    if (self->tp_refs == 0) {\n      SU_DEBUG_7((\"tport(%p): set timer at %u ms because %s\\n\",\n\t\t\t\t  (void *)self, 0, \"zap\"));\n      su_timer_set_interval(self->tp_timer, timer, self, 0);\n    }\n    else\n      su_timer_reset(self->tp_timer);\n\n    return 0;\n  }\n\n  if (self->tp_params->tpp_idle != UINT_MAX) {\n    if (self->tp_refs == 0 &&\n\tself->tp_msg == NULL && !tport_has_queued(self)) {\n      if (su_time_cmp(self->tp_stime, self->tp_rtime) < 0) {\n\ttarget = su_time_add(self->tp_rtime, self->tp_params->tpp_idle);\n\twhy = \"idle since recv\";\n      }\n      else {\n\ttarget = su_time_add(self->tp_stime, self->tp_params->tpp_idle);\n\twhy = \"idle since send\";\n      }\n    }\n  }\n\n  if (self->tp_pri->pri_vtable->vtp_next_secondary_timer)\n    self->tp_pri->pri_vtable->\n      vtp_next_secondary_timer(self, &target, &why);\n\n  if (su_time_cmp(target, infinity)) {\n    SU_DEBUG_7((\"tport(%p): set timer at %ld ms because %s\\n\",\n\t\t(void *)self, su_duration(target, su_now()), why));\n    su_timer_set_at(self->tp_timer, timer, self, target);\n  }\n  else {\n    SU_DEBUG_9((\"tport(%p): reset timer\\n\", (void *)self));\n    su_timer_reset(self->tp_timer);\n  }\n\n  return 0;\n}\n\n\n/** Flush idle connections. */\nint tport_flush(tport_t *tp)\n{\n  tport_t *tp_next;\n  tport_primary_t *pri;\n\n  if (tp == NULL)\n    return -1;\n\n  pri = tp->tp_pri;\n\n  while (pri->pri_closed)\n    tport_zap_secondary(pri->pri_closed);\n\n  /* Go through all secondary transports, zap idle ones */\n  for (tp = tprb_first(tp->tp_pri->pri_open); tp; tp = tp_next) {\n    tp_next = tprb_succ(tp);\n\n    if (tp->tp_refs != 0)\n      continue;\n\n    SU_DEBUG_1((\"tport_flush(%p): %szapping\\n\",\n\t\t(void *)tp, tport_is_closed(tp) ? \"\" : \"closing and \"));\n\n    tport_close(tp);\n    tport_zap_secondary(tp);\n  }\n\n  return 0;\n}\n\n/**Convert sockaddr_t to a transport name.\n *\n * @retval 0 when successful\n * @retval -1 upon an error\n */\nint tport_convert_addr(su_home_t *home,\n\t\t       tp_name_t *tpn,\n\t\t       char const *protoname,\n\t\t       char const *canon,\n\t\t       su_sockaddr_t const *su)\n{\n  tp_name_t name[1] = {{ NULL }};\n  char const *host;\n  char buf[TPORT_HOSTPORTSIZE];\n  char port[8];\n  size_t canonlen = canon ? strlen(canon) : 0;\n\n  if (su == NULL)\n    host = \"*\";\n  else if (!SU_SOCKADDR_INADDR_ANY(su))\n    host = tport_hostport(buf, sizeof(buf), su, 0);\n  else if (canonlen && su->su_family == AF_INET &&\n\t   strspn(canon, \"0123456789.\") == canonlen)\n    host = canon;\n#if SU_HAVE_IN6\n  else if (canonlen && su->su_family == AF_INET6 &&\n\t   strspn(canon, \"0123456789abcdefABCDEF:.\") == canonlen)\n    host = canon;\n#endif\n  else\n    host = localipname(su->su_family, buf, sizeof(buf));\n\n  if (host == NULL)\n    return -1;\n\n  if (su == NULL)\n    strcpy(port, \"*\");\n  else\n    snprintf(port, sizeof(port), \"%u\", ntohs(su->su_port));\n\n  name->tpn_proto = protoname;\n  name->tpn_host = host;\n  name->tpn_canon = canon ? canon : host;\n  name->tpn_port = port;\n\n  return tport_name_dup(home, tpn, name);\n}\n\n/** Set transport object name. @internal\n */\nint tport_setname(tport_t *self,\n\t\t  char const *protoname,\n\t\t  su_addrinfo_t const *ai,\n\t\t  char const *canon)\n{\n  su_addrinfo_t *selfai = self->tp_addrinfo;\n\n  if (tport_convert_addr(self->tp_home, self->tp_name,\n\t\t\t protoname, canon,\n\t\t\t (su_sockaddr_t *)ai->ai_addr) < 0)\n    return -1;\n\n  if (tport_is_secondary(self))\n    self->tp_ident = self->tp_pri->pri_primary->tp_ident;\n\n  selfai->ai_flags = ai->ai_flags & TP_AI_MASK;\n\n  selfai->ai_family = ai->ai_family;\n  selfai->ai_socktype = ai->ai_socktype;\n  selfai->ai_protocol = ai->ai_protocol;\n  selfai->ai_canonname = (char *)self->tp_name->tpn_canon;\n\n  if (ai->ai_addr) {\n    assert(ai->ai_family), assert(ai->ai_socktype), assert(ai->ai_protocol);\n    memcpy(self->tp_addr, ai->ai_addr, selfai->ai_addrlen = ai->ai_addrlen);\n  }\n\n  if (tport_is_secondary(self)) incrementSecondaryCount(self);\n\n  return 0;\n}\n\n/**Resolve protocol name.\n *\n * Convert a protocol name to IP protocol number and socket type used by\n * su_getaddrinfo().\n *\n * @param hints hints with the protocol number and socktype [OUT]\n * @param proto protocol name [IN]\n * @param flags hint flags\n */\nstatic\nint getprotohints(su_addrinfo_t *hints,\n\t\t  char const *proto,\n\t\t  int flags)\n{\n  memset(hints, 0, sizeof *hints);\n\n  hints->ai_flags = flags;\n  hints->ai_canonname = (char *)proto;\n\n#if HAVE_TLS\n  if (su_casematch(proto, \"tls\"))\n    proto = \"tcp\";\n#endif\n\n#if HAVE_SOFIA_NTH\n  if (su_casematch(proto, \"ws\"))\n    proto = \"tcp\";\n  if (su_casematch(proto, \"wss\"))\n    proto = \"tcp\";\n#endif\n\n#if HAVE_SCTP\n  if (su_casematch(proto, \"sctp\")) {\n    hints->ai_protocol = IPPROTO_SCTP;\n    hints->ai_socktype = SOCK_STREAM;\n    return 0;\n  }\n#endif\n\n  if (su_casematch(proto, \"udp\")) {\n    hints->ai_protocol = IPPROTO_UDP;\n    hints->ai_socktype = SOCK_DGRAM;\n    return 0;\n  }\n\n  if (su_casematch(proto, \"tcp\")) {\n    hints->ai_protocol = IPPROTO_TCP;\n    hints->ai_socktype = SOCK_STREAM;\n    return 0;\n  }\n\n  return -1;\n}\n\n/** Get local IP.\n *\n * Get primary local IP address in URI format (IPv6 address will be\n * []-quoted).\n */\nstatic\nchar *localipname(int pf, char *buf, size_t bufsiz)\n{\n  su_localinfo_t *li = NULL, hints[1] = {{ LI_NUMERIC | LI_CANONNAME }};\n  size_t n;\n  int error;\n\n  hints->li_family = pf;\n\n#if SU_HAVE_IN6\n  if (pf == AF_INET6) {\n    /* Link-local addresses are not usable on IPv6 */\n    hints->li_scope = LI_SCOPE_GLOBAL | LI_SCOPE_SITE /* | LI_SCOPE_HOST */;\n  }\n#endif\n\n  if ((error = su_getlocalinfo(hints, &li))) {\n#if SU_HAVE_IN6\n    if (error == ELI_NOADDRESS && pf == AF_INET6) {\n      hints->li_family = AF_INET;\n      error = su_getlocalinfo(hints, &li);\n      if (error == ELI_NOADDRESS) {\n\thints->li_family = AF_INET6; hints->li_scope |= LI_SCOPE_HOST;\n\terror = su_getlocalinfo(hints, &li);\n      }\n      if (error == ELI_NOADDRESS) {\n\thints->li_family = AF_INET;\n\terror = su_getlocalinfo(hints, &li);\n      }\n    }\n#endif\n    if (error) {\n      SU_DEBUG_1((\"tport: su_getlocalinfo: %s\\n\", su_gli_strerror(error)));\n      return NULL;\n    }\n  }\n\n  assert(li); assert(li->li_canonname);\n\n  n = strlen(li->li_canonname);\n\n  if (li->li_family == AF_INET) {\n    if (n >= bufsiz)\n      return NULL;\n\n    memcpy(buf, li->li_canonname, n + 1);\n  }\n  else {\n    if (n + 2 >= bufsiz)\n      return NULL;\n\n    memcpy(buf + 1, li->li_canonname, n);\n    buf[0] = '['; buf[++n] = ']'; buf[++n] = '\\0';\n  }\n\n  su_freelocalinfo(li);\n\n  return buf;\n}\n\n/** Process errors from transport. */\nvoid tport_error_report(tport_t *self, int errcode,\n\t\t\tsu_sockaddr_t const *addr)\n{\n  char const *errmsg;\n\n  if (errcode == 0)\n    return;\n  else if (errcode > 0)\n    errmsg = su_strerror(errcode);\n  else\n    /* Should be something  like ENOTCONN */\n    errcode = 0, errmsg = \"stream closed\";\n\n  if (addr && addr->su_family == AF_UNSPEC)\n    addr = NULL;\n\n  /* Mark this connection as unusable */\n  if (errcode > 0 && tport_has_connection(self))\n    self->tp_reusable = 0;\n\n  /* Report error */\n  if (addr && tport_pending_error(self, addr, errcode))\n    ;\n  else if (tport_is_secondary(self) &&\n\t   tport_pending_error(self, NULL, errcode) > 0)\n    ;\n  else if (self->tp_master->mr_tpac->tpac_error) {\n    char *dstname = NULL;\n    char hp[TPORT_HOSTPORTSIZE];\n\n    if (addr)\n      dstname = tport_hostport(hp, sizeof hp, addr, 1);\n\n    STACK_ERROR(self, errcode, dstname);\n  }\n  else {\n    if (tport_is_primary(self))\n      SU_DEBUG_3((\"%s(%p): %s (with %s)\\n\", __func__, (void *)self,\n\t\t  errmsg, self->tp_protoname));\n    else\n      SU_DEBUG_3((\"%s(%p): %s (with %s/%s:%s)\\n\", __func__, (void *)self,\n\t\t  errmsg, self->tp_protoname, self->tp_host, self->tp_port));\n  }\n\n  /* Close connection */\n  if (!self->tp_closed && errcode > 0 && tport_has_connection(self)) {\n    if (tport_is_secondary(self)) {\n      SU_DEBUG_4((\"%s(%p) \" TPN_FORMAT \" calling tport_shutdown0 due to error on secondary transport\\n\",\n        __func__, (void *)self, TPN_ARGS(self->tp_name)));\n      tport_shutdown0(self, 2);\n      tport_set_secondary_timer(self);\n    }\n    else {\n      SU_DEBUG_9((\"%s(%p): \" TPN_FORMAT \" calling tport_close\\n\", __func__, (void *)self, TPN_ARGS(self->tp_name)));\n      tport_close(self);\n    }\n  }\n}\n\n/** Accept a new connection.\n *\n * The function tport_accept() accepts a new connection and creates a\n * secondary transport object for the new socket.\n */\nint tport_accept(tport_primary_t *pri, int events)\n{\n  tport_t *self;\n  su_addrinfo_t ai[1];\n  su_sockaddr_t su[1];\n  socklen_t sulen = sizeof su;\n  su_socket_t s = INVALID_SOCKET, l = pri->pri_primary->tp_socket;\n  char const *reason = \"accept\";\n\n  if (events & SU_WAIT_ERR)\n    tport_error_event(pri->pri_primary);\n\n  if (!(events & SU_WAIT_ACCEPT))\n    return 0;\n\n  memcpy(ai, pri->pri_primary->tp_addrinfo, sizeof ai);\n  ai->ai_canonname = NULL;\n\n  s = accept(l, &su->su_sa, &sulen);\n\n  if (s < 0) {\n    tport_error_report(pri->pri_primary, su_errno(), NULL);\n    return 0;\n  }\n\n  ai->ai_addr = &su->su_sa, ai->ai_addrlen = sulen;\n\n  /* Alloc a new transport object, then register socket events with it */\n  if ((self = tport_alloc_secondary(pri, s, 1, &reason)) == NULL) {\n    SU_DEBUG_3((\"%s(%p): incoming secondary on \"TPN_FORMAT\n                \" failed. reason = %s\\n\", __func__, (void *)pri, \n                TPN_ARGS(pri->pri_primary->tp_name), reason));\n\tshutdown(s, 2);\n\tsu_close(s);\n    return 0;\n  }\n  else {\n    int events = SU_WAIT_IN|SU_WAIT_ERR|SU_WAIT_HUP;\n\n    SU_CANONIZE_SOCKADDR(su);\n\n    if (/* Name this transport */\n        tport_setname(self, pri->pri_protoname, ai, NULL) != -1 \n\t/* Register this secondary */ \n\t&&\n\ttport_register_secondary(self, tport_wakeup, events) != -1) {\n\n      self->tp_conn_orient = 1;\n      self->tp_is_connected = 1;\n\n      SU_DEBUG_4((\"%s(%p): new connection from \" TPN_FORMAT \"\\n\",\n                  __func__,  (void *)self, TPN_ARGS(self->tp_name)));\n\n      return 0;\n    }\n\n    /* Failure: shutdown socket,  */\n    tport_close(self);\n    tport_zap_secondary(self);\n    self = NULL;\n  }\n\n  return 0;\n}\n\n/** Allocate a new message object */\nmsg_t *tport_msg_alloc(tport_t const *self, usize_t size)\n{\n  if (self) {\n    tport_master_t *mr = self->tp_master;\n    msg_t *msg = mr->mr_tpac->tpac_alloc(mr->mr_stack, mr->mr_log,\n\t\t\t\t\t NULL, size, self, NULL);\n    if (msg) {\n      su_addrinfo_t *mai = msg_addrinfo(msg);\n      su_addrinfo_t const *tai = self->tp_addrinfo;\n\n      mai->ai_family =   tai->ai_family;\n      mai->ai_protocol = tai->ai_protocol;\n      mai->ai_socktype = tai->ai_socktype;\n    }\n\n    return msg;\n  }\n  else {\n    return NULL;\n  }\n}\n\n/** Process events for socket waiting to be connected\n */\nstatic int tport_connected(su_root_magic_t *magic, su_wait_t *w, tport_t *self)\n{\n  int events = su_wait_events(w, self->tp_socket);\n  tport_master_t *mr = self->tp_master;\n  su_wait_t wait[1] =  { SU_WAIT_INIT };\n  int su_wait_create_ret;\n\n  int error;\n\n  SU_DEBUG_7((\"tport_connected(%p): events%s%s\\n\", (void *)self,\n\t      events & SU_WAIT_CONNECT ? \" CONNECTED\" : \"\",\n\t      events & SU_WAIT_ERR ? \" ERR\" : \"\"));\n\n#if HAVE_POLL\n  assert(w->fd == self->tp_socket);\n#endif\n\n  if (events & SU_WAIT_ERR)\n    tport_error_event(self);\n\n  if (!(events & SU_WAIT_CONNECT) || self->tp_closed) {\n    return 0;\n  }\n\n  error = su_soerror(self->tp_socket);\n  if (error) {\n    tport_error_report(self, error, NULL);\n    return 0;\n  }\n\n  self->tp_is_connected = 1;\n\n  su_root_deregister(mr->mr_root, self->tp_index);\n  self->tp_index = -1;\n  self->tp_events = SU_WAIT_IN | SU_WAIT_ERR | SU_WAIT_HUP;\n\n  if ((su_wait_create_ret = su_wait_create(wait, self->tp_socket, self->tp_events)) == -1 ||\n      (self->tp_index = su_root_register(mr->mr_root,\n\t\t\t\t\t wait, tport_wakeup, self, 0))\n      == -1) {\n    if (su_wait_create_ret == 0) {\n      su_wait_destroy(wait);\n    }\n    tport_close(self);\n    tport_set_secondary_timer(self);\n    return 0;\n  }\n\n  if (tport_has_queued(self))\n    tport_send_event(self);\n  else\n    tport_set_secondary_timer(self);\n\n  return 0;\n}\n\n/** Process events for primary socket  */\nstatic int tport_wakeup_pri(su_root_magic_t *m, su_wait_t *w, tport_t *self)\n{\n  tport_primary_t *pri = self->tp_pri;\n  int events = su_wait_events(w, self->tp_socket);\n\n#if HAVE_POLL\n  assert(w->fd == self->tp_socket);\n#endif\n\n  SU_DEBUG_7((\"%s(%p): events%s%s%s%s%s%s\\n\",\n\t      \"tport_wakeup_pri\", (void *)self,\n\t      events & SU_WAIT_IN ? \" IN\" : \"\",\n\t      SU_WAIT_ACCEPT != SU_WAIT_IN &&\n\t      (events & SU_WAIT_ACCEPT) ? \" ACCEPT\" : \"\",\n\t      events & SU_WAIT_OUT ? \" OUT\" : \"\",\n\t      events & SU_WAIT_HUP ? \" HUP\" : \"\",\n\t      events & SU_WAIT_ERR ? \" ERR\" : \"\",\n\t      self->tp_closed ? \" (closed)\" : \"\"));\n\n\n  if (pri->pri_vtable->vtp_wakeup_pri)\n    return pri->pri_vtable->vtp_wakeup_pri(pri, events);\n  else\n    return tport_base_wakeup(self, events);\n}\n\n/** Process events for connected socket  */\nint tport_wakeup(su_root_magic_t *magic, su_wait_t *w, tport_t *self)\n{\n  int events = su_wait_events(w, self->tp_socket);\n\n#if HAVE_POLL\n  assert(w->fd == self->tp_socket);\n#endif\n\n  SU_DEBUG_7((\"%s(%p): events%s%s%s%s%s\\n\",\n\t      \"tport_wakeup\", (void *)self,\n\t      events & SU_WAIT_IN ? \" IN\" : \"\",\n\t      events & SU_WAIT_OUT ? \" OUT\" : \"\",\n\t      events & SU_WAIT_HUP ? \" HUP\" : \"\",\n\t      events & SU_WAIT_ERR ? \" ERR\" : \"\",\n\t      self->tp_closed ? \" (closed)\" : \"\"));\n\n  if (self->tp_pri->pri_vtable->vtp_wakeup)\n    return self->tp_pri->pri_vtable->vtp_wakeup(self, events);\n  else\n    return tport_base_wakeup(self, events);\n}\n\nstatic int tport_base_wakeup(tport_t *self, int events)\n{\n  int error = 0;\n\n  if (events & SU_WAIT_ERR)\n    error = tport_error_event(self);\n\n  if ((events & SU_WAIT_OUT) && !self->tp_closed)\n    tport_send_event(self);\n\n  if ((events & SU_WAIT_IN) && !self->tp_closed)\n    tport_recv_event(self);\n\n  if ((events & SU_WAIT_HUP) && !self->tp_closed)\n    tport_hup_event(self);\n\n  if (error) {\n    if (self->tp_closed && error == EPIPE)\n      return 0;\n\n    tport_error_report(self, error, NULL);\n  }\n\n  return 0;\n}\n\n/** Stop reading from socket until tport_continue() is called. */\nint tport_stall(tport_t *self)\n{\n  return tport_set_events(self, 0, SU_WAIT_IN);\n}\n\n/** Continue reading from socket. */\nint tport_continue(tport_t *self)\n{\n  if (self == NULL || self->tp_recv_close)\n    return -1;\n  return tport_set_events(self, SU_WAIT_IN, 0);\n}\n\n/** Process \"hangup\" event.\n *\n */\nvoid tport_hup_event(tport_t *self)\n{\n  SU_DEBUG_4((\"%s(%p) \" TPN_FORMAT \"\\n\", __func__, (void *)self, TPN_ARGS(self->tp_name)));\n\n  if (self->tp_msg) {\n    su_time_t now = su_now();\n    msg_recv_commit(self->tp_msg, 0, 1);\n    tport_parse(self, 1, now);\n  }\n\n  if (!tport_is_secondary(self))\n    return;\n\n  /* Shutdown completely if there are no queued messages */\n  /* Problem reported by Arsen Chaloyan */\n  tport_shutdown0(self, tport_has_queued(self) ? 0 : 2);\n  tport_set_secondary_timer(self);\n}\n\n/** Receive data available on the socket.\n *\n * @retval -1 error\n * @retval 0  end-of-stream\n * @retval 1  normal receive\n * @retval 2  incomplete recv, recv again\n * @retval 3  STUN keepalive, ignore\n */\nsu_inline\nint tport_recv_data(tport_t *self)\n{\n  return self->tp_pri->pri_vtable->vtp_recv(self);\n}\n\n/** Process \"ready to receive\" event.\n *\n */\nvoid tport_recv_event(tport_t *self)\n{\n  int again;\n\n  SU_DEBUG_7((\"%s(%p)\\n\", \"tport_recv_event\", (void *)self));\n\n  do {\n    /* Receive data from socket */\n    again = tport_recv_data(self);\n\n    su_time(&self->tp_rtime);\n\n#if HAVE_SOFIA_STUN\n    if (again == 3) /* STUN keepalive */\n      return;\n#endif\n\n    if (again < 0) {\n      int error = su_errno();\n\n      if (!su_is_blocking(error)) {\n\ttport_error_report(self, error, NULL);\n\treturn;\n      }\n      else {\n\tSU_DEBUG_3((\"%s: recvfrom(): %s (%d)\\n\", __func__,\n\t\t    su_strerror(EAGAIN), EAGAIN));\n      }\n    }\n\n    if (again >= 0)\n      tport_parse(self, self->tp_pre_framed ? 1 : !again, self->tp_rtime);\n  }\n  while (again > 1);\n\n  if (!tport_is_secondary(self))\n    return;\n\n  if (again == 0 && !tport_is_dgram(self)) {\n    /* End of stream */\n    SU_DEBUG_4((\"%s(%p): end of stream from \" TPN_FORMAT \"\\n\",\n\t\t  __func__, (void *)self, TPN_ARGS(self->tp_name)));\n\n    if (!self->tp_closed) {\n      /* Don't shutdown completely if there are queued messages */\n      tport_shutdown0(self, tport_has_queued(self) ? 0 : 2);\n    }\n  }\n\n  tport_set_secondary_timer(self);\n}\n\n/*\n * Parse the data and feed complete messages to the stack\n */\nstatic void tport_parse(tport_t *self, int complete, su_time_t now)\n{\n  msg_t *msg, *next = NULL;\n  int n, streaming, stall = 0;\n\n  for (msg = self->tp_msg; msg; msg = next) {\n    n = msg_extract(msg);\t/* Parse message */\n\n    streaming = 0;\n\n    if (n == 0) {\n      if (complete)\n\tmsg_mark_as_complete(msg, MSG_FLG_ERROR), n = -1;\n      else if (!(streaming = msg_is_streaming(msg))) {\n\ttport_sigcomp_accept_incomplete(self, msg);\n\tbreak;\n      }\n    }\n\n    if (msg_get_flags(msg, MSG_FLG_TOOLARGE))\n      SU_DEBUG_3((\"%s(%p): too large message from \" TPN_FORMAT \"\\n\",\n\t\t  __func__, (void *)self, TPN_ARGS(self->tp_name)));\n\n    /* Do not try to read anymore from this connection? */\n    if (tport_is_stream(self) &&\n\tmsg_get_flags(msg, MSG_FLG_TOOLARGE | MSG_FLG_ERROR))\n      self->tp_recv_close = stall = 1;\n\n    if (n == -1)\n      next = NULL;\n    else if (streaming)\n      msg_ref_create(msg);\t/* Keep a reference */\n    else if (tport_is_stream(self))\n      next = msg_next(msg);\n    else\n      next = NULL;\n\n    tport_deliver(self, msg, next, self->tp_comp, now);\n\n    if (streaming && next == NULL)\n      break;\n  }\n\n  if (stall)\n    tport_stall(self);\n\n  if (self->tp_rlogged != msg)\n    self->tp_rlogged = NULL;\n\n  self->tp_msg = msg;\n}\n\n/** Deliver message to the protocol stack */\nvoid tport_deliver(tport_t *self,\n\t\t   msg_t *msg,\n\t\t   msg_t *next,\n\t\t   tport_compressor_t *sc,\n\t\t   su_time_t now)\n{\n  tport_t *ref;\n  int error;\n  struct tport_delivery *d;\n  char ipaddr[SU_ADDRSIZE + 2];\n\n  assert(msg);\n\n  d = self->tp_master->mr_delivery;\n\n  d->d_tport = self;\n  d->d_msg = msg;\n  *d->d_from = *self->tp_name;\n\n  if (tport_is_primary(self)) {\n    su_sockaddr_t const *su = msg_addr(msg);\n\n#if SU_HAVE_IN6\n    if (su->su_family == AF_INET6) {\n      ipaddr[0] = '[';\n      su_inet_ntop(su->su_family, SU_ADDR(su), ipaddr + 1, SU_ADDRSIZE);\n      strcat(ipaddr, \"]\");\n    }\n    else {\n      su_inet_ntop(su->su_family, SU_ADDR(su), ipaddr, sizeof(ipaddr));\n    }\n#else\n    su_inet_ntop(su->su_family, SU_ADDR(su), ipaddr, sizeof(ipaddr));\n#endif\n\n    d->d_from->tpn_canon = ipaddr;\n    d->d_from->tpn_host = ipaddr;\n  }\n\n  d->d_comp = sc;\n  if (!sc)\n    d->d_from->tpn_comp = NULL;\n\n  error = msg_has_error(msg);\n\n  if (error && !*msg_chain_head(msg)) {\n    /* This is badly damaged packet */\n  }\n  else if (self->tp_master->mr_log && msg != self->tp_rlogged) {\n    char const *via = \"recv\";\n    tport_log_msg(self, msg, via, \"from\", now);\n    self->tp_rlogged = msg;\n  }\n\n  SU_DEBUG_7((\"%s(%p): %smsg %p (\"MOD_ZU\" bytes)\"\n\t      \" from \" TPN_FORMAT \" next=%p\\n\",\n\t      __func__, (void *)self, error ? \"bad \" : \"\",\n\t      (void *)msg, (size_t)msg_size(msg),\n\t      TPN_ARGS(d->d_from), (void *)next));\n\n  ref = tport_incref(self);\n\n  if (self->tp_pri->pri_vtable->vtp_deliver) {\n    self->tp_pri->pri_vtable->vtp_deliver(self, msg, now);\n  }\n  else\n    tport_base_deliver(self, msg, now);\n\n  memset(d->d_from, 0, sizeof d->d_from);\n  d->d_msg = NULL;\n\n  tport_decref(&ref);\n}\n\n/** Pass message to the protocol stack */\nvoid\ntport_base_deliver(tport_t *self, msg_t *msg, su_time_t now)\n{\n  STACK_RECV(self, msg, now);\n}\n\n/** Return source transport object for delivered message */\ntport_t *tport_delivered_by(tport_t const *tp, msg_t const *msg)\n{\n  if (tp && msg && msg == tp->tp_master->mr_delivery->d_msg)\n    return tp->tp_master->mr_delivery->d_tport;\n  else\n    return NULL;\n}\n\n\n/** Return source transport name for delivered message */\nint tport_delivered_from(tport_t *tp, msg_t const *msg, tp_name_t name[1])\n{\n  if (name == NULL)\n    return -1;\n\n  if (tp == NULL || msg == NULL || msg != tp->tp_master->mr_delivery->d_msg) {\n    memset(name, 0, sizeof *name);\n    return -1;\n  }\n  else {\n    *name = *tp->tp_master->mr_delivery->d_from;\n    return 0;\n  }\n}\n\n/** Return TLS Subjects provided by the source transport */\nsu_strlst_t const *tport_delivered_from_subjects(tport_t *tp, msg_t const *msg)\n{\n  if (tp && msg && msg == tp->tp_master->mr_delivery->d_msg) {\n    tport_t *tp_sec = tp->tp_master->mr_delivery->d_tport;\n    return (tp_sec) ? tp_sec->tp_subjects : NULL;\n  }\n  else\n    return NULL;\n}\n\n/** Return UDVM used to decompress the message. */\nint\ntport_delivered_with_comp(tport_t *tp, msg_t const *msg,\n\t\t\t  tport_compressor_t **return_compressor)\n{\n  if (tp == NULL || msg == NULL || msg != tp->tp_master->mr_delivery->d_msg)\n    return -1;\n\n  if (return_compressor)\n    *return_compressor = tp->tp_master->mr_delivery->d_comp;\n\n  return 0;\n}\n\n/** Search for subject in list of TLS Certificate subjects */\nint\ntport_subject_search(char const *subject, su_strlst_t const *lst)\n{\n  usize_t idx, ilen;\n  const char *subjuri;\n\n  if (!subject || su_strmatch(tpn_any, subject))\n    return 1;\n\n  if (!lst)\n    return 0;\n\n  /* Check if subject is a URI */\n  if (su_casenmatch(subject,\"sip:\",4) || su_casenmatch(subject,\"sips:\",5))\n    subjuri = subject + su_strncspn(subject,5,\":\") + 1;\n  else\n    subjuri = NULL;\n\n  ilen = su_strlst_len(lst);\n\n  for (idx = 0; idx < ilen; idx++) {\n    const char *lsturi, *lststr;\n\n    lststr = su_strlst_item(lst, idx);\n\n    /* check if lststr is a URI (sips URI is an unacceptable cert subject) */\n    if (su_casenmatch(lststr,\"sip:\",4))\n      lsturi = lststr + su_strncspn(lststr,4,\":\") + 1;\n    else\n      lsturi = NULL;\n\n\n    /* Match two SIP Server Identities */\n    if (host_cmp(subjuri ? subjuri : subject, lsturi ? lsturi : lststr) == 0)\n      return 1;\n#if 0\n    /* XXX - IETF drafts forbid wildcard certs */\n    if (!subjuri && !lsturi && su_strnmatch(\"*.\", lststr, 2)) {\n      size_t urioffset = su_strncspn(subject, 64, \".\");\n      if (urioffset) {\n        if (su_casematch(subject + urioffset, lststr+1))\n          return 1;\n      }\n    }\n#endif\n  }\n\n  return 0;\n}\n\n/** Allocate message for N bytes,\n *  return message buffer as a iovec\n */\nssize_t tport_recv_iovec(tport_t const *self,\n\t\t\t msg_t **in_out_msg,\n\t\t\t msg_iovec_t iovec[msg_n_fragments],\n\t\t\t size_t N,\n\t\t\t int exact)\n{\n  msg_t *msg = *in_out_msg;\n  ssize_t i, veclen;\n  int fresh;\n\n  if (N == 0)\n    return 0;\n\n  fresh = !msg;\n\n  /*\n   * Allocate a new message if needed\n   */\n  if (!msg) {\n    if (!(*in_out_msg = msg = tport_msg_alloc(self, N))) {\n      SU_DEBUG_7((\"%s(%p): cannot allocate msg for \"MOD_ZU\" bytes \"\n\t\t  \"from (%s/%s:%s)\\n\",\n\t\t  __func__, (void *)self, N,\n\t\t  self->tp_protoname, self->tp_host, self->tp_port));\n      return -1;\n    }\n  }\n\n  /*\n   * Get enough buffer space for the incoming data\n   */\n  veclen = msg_recv_iovec(msg, iovec, msg_n_fragments, N, exact);\n  if (veclen < 0) {\n    int err = su_errno();\n    if (fresh && err == ENOBUFS && msg_get_flags(msg, MSG_FLG_TOOLARGE))\n      veclen = msg_recv_iovec(msg, iovec, msg_n_fragments, 4096, 1);\n  }\n  if (veclen < 0) {\n    int err = su_errno();\n    SU_DEBUG_7((\"%s(%p): cannot get msg %p buffer for \"MOD_ZU\" bytes \"\n\t\t\"from (%s/%s:%s): %s\\n\",\n\t\t__func__, (void *)self, (void *)msg, N,\n\t\tself->tp_protoname, self->tp_host, self->tp_port,\n\t\tsu_strerror(err)));\n    su_seterrno(err);\n    return veclen;\n  }\n\n  assert(veclen <= msg_n_fragments);\n\n  SU_DEBUG_7((\"%s(%p) msg %p from (%s/%s:%s) has \"MOD_ZU\" bytes, \"\n\t      \"veclen = \"MOD_ZD\"\\n\",\n              __func__, (void *)self,\n\t      (void *)msg, self->tp_protoname, self->tp_host, self->tp_port,\n\t      N, veclen));\n\n  for (i = 0; veclen > 1 && i < veclen; i++) {\n    SU_DEBUG_7((\"\\tiovec[%lu] = %lu bytes\\n\", (LU)i, (LU)iovec[i].mv_len));\n  }\n\n  return veclen;\n}\n\nint tport_recv_error_report(tport_t *self)\n{\n  if (su_is_blocking(su_errno()))\n    return 1;\n\n  /* Report error */\n  tport_error_report(self, su_errno(), NULL);\n\n  return -1;\n}\n\n/** Send a message.\n *\n * The function tport_tsend() sends a message using the transport @a self.\n *\n * @TAGS\n * TPTAG_MTU(), TPTAG_REUSE(), TPTAG_CLOSE_AFTER(), TPTAG_SDWN_AFTER(),\n * TPTAG_FRESH(), TPTAG_COMPARTMENT(), TPTAG_X509_SUBJECT()\n */\ntport_t *tport_tsend(tport_t *self,\n\t\t     msg_t *msg,\n\t\t     tp_name_t const *_tpn,\n\t\t     tag_type_t tag, tag_value_t value, ...)\n{\n  ta_list ta;\n  tagi_t const *t;\n  int reuse, sdwn_after, close_after, resolved = 0, fresh;\n  unsigned mtu;\n  su_addrinfo_t *ai;\n  tport_primary_t *primary;\n  tp_name_t tpn[1];\n  struct sigcomp_compartment *cc;\n\n  assert(self);\n\n  if (!self || !msg || !_tpn) {\n    msg_set_errno(msg, EINVAL);\n    return NULL;\n  }\n\n  *tpn = *_tpn;\n\n  SU_DEBUG_7((\"tport_tsend(%p) tpn = \" TPN_FORMAT \"\\n\",\n\t      (void *)self, TPN_ARGS(tpn)));\n\n  if (tport_is_master(self)) {\n    primary = (tport_primary_t *)tport_primary_by_name(self, tpn);\n    if (!primary) {\n      msg_set_errno(msg, EPROTONOSUPPORT);\n      return NULL;\n    }\n  }\n  else {\n    primary = self->tp_pri;\n  }\n\n  ta_start(ta, tag, value);\n\n  reuse = primary->pri_primary->tp_reusable && self->tp_reusable;\n  fresh = 0;\n  sdwn_after = 0;\n  close_after = 0;\n  mtu = 0;\n  cc = NULL;\n\n  /* tl_gets() is a bit too slow here... */\n  for (t = ta_args(ta); t; t = tl_next(t)) {\n    tag_type_t tt = t->t_tag;\n\n    if (tptag_reuse == tt)\n      reuse = t->t_value != 0;\n    else if (tptag_mtu == tt)\n      mtu = t->t_value;\n    else if (tptag_sdwn_after == tt)\n      sdwn_after = t->t_value != 0;\n    else if (tptag_close_after == tt)\n      close_after = t->t_value != 0;\n    else if (tptag_fresh == tt)\n      fresh = t->t_value != 0;\n    else if (tptag_compartment == tt)\n      cc = (struct sigcomp_compartment *)t->t_value;\n  }\n\n  ta_end(ta);\n\n  fresh = fresh || !reuse;\n\n  ai = msg_addrinfo(msg);\n\n  ai->ai_flags = 0;\n\n  tpn->tpn_comp = tport_canonize_comp(tpn->tpn_comp);\n  if (tpn->tpn_comp) {\n    ai->ai_flags |= TP_AI_COMPRESSED;\n    SU_DEBUG_9((\"%s: compressed msg(%p) with %s\\n\",\n\t\t__func__, (void *)msg, tpn->tpn_comp));\n  }\n\n  if (!tpn->tpn_comp || cc == NONE)\n    cc = NULL;\n\n  if (sdwn_after)\n    ai->ai_flags |= TP_AI_SHUTDOWN;\n  if (close_after)\n    ai->ai_flags |= TP_AI_CLOSE;\n\n  if (fresh) {\n    /* Select a primary protocol, make a fresh connection */\n    self = primary->pri_primary;\n  }\n  else if (tport_is_secondary(self) && tport_is_clear_to_send(self)) {\n\t/* self = self; */\n\t;\n  }\n  /*\n   * Try to find an already open connection to the destination,\n   * or get a primary protocol\n   */\n  \n  else {\n    /* If primary, resolve the destination address, store it in the msg */\n    if (tport_resolve(primary->pri_primary, msg, tpn) < 0) {\n      return NULL;\n    }\n    resolved = 1;\n\n\n    // DCH: iterate through all primaries\n    tport_t* secondary = NULL ;\n    tport_t* tp = tport_primaries( self ) ;\n    if (tp) {\n      do {\n        secondary = tport_by_addrinfo((tport_primary_t *)tp, msg_addrinfo(msg), tpn);\n        if (secondary) break;\n      } while(NULL != (tp = tport_next(tp)));\n    }\n\n    if( secondary ) {\n      self = secondary ;\n    }\n    else {\n      self = primary->pri_primary;      \n    }\n  }\n\n  if (tport_is_primary(self)) {\n    /* If primary, resolve the destination address, store it in the msg */\n    if (!resolved && tport_resolve(self, msg, tpn) < 0) {\n      return NULL;\n    }\n\n    if (tport_is_connection_oriented(self)\n\t|| self->tp_params->tpp_conn_orient) {\n#if 0 && HAVE_UPNP /* We do not want to use UPnP with secondary transports! */\n      if (upnp_register_upnp_client(1) != 0) {\n\tupnp_check_for_nat();\n      }\n#endif\n\n      tpn->tpn_proto = self->tp_protoname;\n\n      if (!cc)\n\ttpn->tpn_comp = NULL;\n\n      /* Create a secondary transport which is connected to the destination */\n      self = tport_connect(primary, msg_addrinfo(msg), tpn);\n\n#if 0 && HAVE_UPNP /* We do not want to use UPnP with secondary transports! */\n      upnp_deregister_upnp_client(0, 0);\n#endif\n\n      if (!self) {\n\tmsg_set_errno(msg, su_errno());\n        SU_DEBUG_9((\"tport_socket failed in tsend\\n\" VA_NONE));\n\treturn NULL;\n      }\n\n      if (cc)\n\ttport_sigcomp_assign(self, cc);\n    }\n  }\n  else if (tport_is_secondary(self)) {\n    cc = tport_sigcomp_assign_if_needed(self, cc);\n  }\n\n  if (cc == NULL)\n    tpn->tpn_comp = NULL;\n\n  if (tport_is_secondary(self)) {\n    /* Set the peer address to msg */\n    tport_peer_address(self, msg);\n    if (sdwn_after || close_after)\n      self->tp_reusable = 0;\n  }\n\n  if (self->tp_pri->pri_vtable->vtp_prepare\n      ? self->tp_pri->pri_vtable->vtp_prepare(self, msg, tpn, cc, mtu) < 0\n      : tport_prepare_and_send(self, msg, tpn, cc, mtu) < 0)\n    return NULL;\n  else\n    return self;\n}\n\nint tport_prepare_and_send(tport_t *self, msg_t *msg,\n\t\t\t   tp_name_t const *tpn,\n\t\t\t   struct sigcomp_compartment *cc,\n\t\t\t   unsigned mtu)\n{\n  int retval;\n\n  /* Prepare message for sending - i.e., encode it */\n  if (msg_prepare(msg) < 0) {\n    msg_set_errno(msg, errno);\t/* msg parser uses plain errno. Hmph. */\n    return -1;\n  }\n\n  if (msg_size(msg) > (usize_t)(mtu ? mtu : tport_mtu(self))) {\n    msg_set_errno(msg, EMSGSIZE);\n    return -1;\n  }\n\n  /*\n   * If there is already an queued message,\n   * put this message straight in the queue\n   */\n  if ((self->tp_queue && self->tp_queue[self->tp_qhead]) ||\n      /* ...or we are connecting */\n      (self->tp_events & (SU_WAIT_CONNECT | SU_WAIT_OUT))) {\n    if (tport_queue(self, msg) < 0) {\n      SU_DEBUG_9((\"tport_queue failed in tsend\\n\" VA_NONE));\n      return -1;\n    }\n    return 0;\n  }\n\n  retval = tport_send_msg(self, msg, tpn, cc);\n\n  tport_set_secondary_timer(self);\n\n  return retval;\n}\n\n\n/** Send a message.\n *\n * @retval 0 when succesful\n * @retval -1 upon an error\n */\nint tport_send_msg(tport_t *self, msg_t *msg,\n\t\t   tp_name_t const *tpn,\n\t\t   struct sigcomp_compartment *cc)\n{\n  msg_iovec_t *iov, auto_iov[40];\n  size_t iovlen, iovused, i, total;\n  size_t n;\n  ssize_t nerror;\n  int sdwn_after, close_after;\n  su_time_t now;\n  su_addrinfo_t *ai;\n\n  assert(self->tp_queue == NULL ||\n\t self->tp_queue[self->tp_qhead] == NULL ||\n\t self->tp_queue[self->tp_qhead] == msg);\n\n  if (self->tp_iov)\n    /* Use the heap-allocated I/O vector */\n    iov = self->tp_iov, iovlen = self->tp_iovlen;\n  else\n    /* Use the stack I/O vector */\n    iov = auto_iov, iovlen = sizeof(auto_iov)/sizeof(auto_iov[0]);\n\n  /* Get a iovec for message contents */\n  for (;;) {\n    iovused = msg_iovec(msg, iov, iovlen);\n    if (iovused <= iovlen)\n      break;\n\n    iov = su_realloc(self->tp_home, self->tp_iov, sizeof(*iov) * iovused);\n\n    if (iov == NULL) {\n      msg_set_errno(msg, errno);\n      return -1;\n    }\n\n    self->tp_iov = iov, self->tp_iovlen = iovlen = iovused;\n  }\n\n  assert(iovused > 0);\n\n  self->tp_stime = self->tp_ktime = now = su_now();\n\n  nerror = tport_vsend(self, msg, tpn, iov, iovused, cc);\n  SU_DEBUG_9((\"tport_vsend returned \"MOD_ZD\"\\n\", nerror));\n\n  if (nerror == -1)\n    return -1;\n\n  n = (size_t)nerror;\n\n  self->tp_unsent = NULL, self->tp_unsentlen = 0;\n\n  if (n > 0 && self->tp_master->mr_log && self->tp_slogged != msg) {\n    tport_log_msg(self, msg, \"send\", \"to\", now);\n    self->tp_slogged = msg;\n  }\n\n  for (i = 0, total = 0; i < iovused; i++) {\n    if (total + (size_t)iov[i].mv_len > n) {\n      if (tport_is_connection_oriented(self)) {\n\tiov[i].mv_len -= (su_ioveclen_t)(n - total);\n\tiov[i].mv_base = (char *)iov[i].mv_base + (n - total);\n\tif (tport_queue_rest(self, msg, &iov[i], iovused - i) < 0)\n\t  return tport_send_fatal(self, msg, tpn, \"tport_queue_rest\");\n\telse\n\t  return 0;\n      }\n      else {\n\tchar const *comp = tpn->tpn_comp;\n\n\tSU_DEBUG_1((\"%s(%p): send truncated for %s/%s:%s%s%s\\n\",\n\t\t    \"tport_vsend\", (void *)self, tpn->tpn_proto, tpn->tpn_host, tpn->tpn_port,\n\t\t    comp ? \";comp=\" : \"\", comp ? comp : \"\"));\n\n\tmsg_set_errno(msg, EIO);\n\treturn /* tport_send_fatal(self, msg, tpn, \"tport_send\") */ -1;\n      }\n    }\n\n    total += iov[i].mv_len;\n  }\n\n  /* We have sent a complete message */\n  tport_sent_message(self, msg, 0);\n\n  if (!tport_is_secondary(self))\n    return 0;\n\n  ai = msg_addrinfo(msg); assert(ai);\n  close_after = (ai->ai_flags & TP_AI_CLOSE) == TP_AI_CLOSE;\n  sdwn_after = (ai->ai_flags & TP_AI_SHUTDOWN) == TP_AI_SHUTDOWN ||\n    self->tp_send_close;\n\n  if (close_after || sdwn_after)\n    tport_shutdown0(self, close_after ? 2 : 1);\n\n  return 0;\n}\n\nstatic\nssize_t tport_vsend(tport_t *self,\n\t\t    msg_t *msg,\n\t\t    tp_name_t const *tpn,\n\t\t    msg_iovec_t iov[],\n\t\t    size_t iovused,\n\t\t    struct sigcomp_compartment *cc)\n{\n  ssize_t n;\n  su_addrinfo_t *ai = msg_addrinfo(msg);\n\n  if (cc) {\n    n = tport_send_comp(self, msg, iov, iovused, cc, self->tp_comp);\n  }\n  else {\n    ai->ai_flags &= ~TP_AI_COMPRESSED;\n    n = self->tp_pri->pri_vtable->vtp_send(self, msg, iov, iovused);\n  }\n\n  if (n == 0)\n    return 0;\n\n  if (n == -1)\n    return tport_send_error(self, msg, tpn, \"tport_vsend\");\n\n  tport_sent_bytes(self, n, n);\t/* Sigcomp will decrease on_line accodingly */\n\n  if (n > 0 && self->tp_master->mr_dump_file)\n    tport_dump_iovec(self, msg, n, iov, iovused, \"sent\", \"to\");\n    \n  if (n > 0 && self->tp_master->mr_capt_sock)\n      tport_capt_msg(self, msg, n, iov, iovused, \"sent\");\n              \n\n  if (tport_log->log_level >= 7) {\n    size_t i, m = 0;\n\n    for (i = 0; i < iovused; i++)\n      m += iov[i].mv_len;\n\n    if (tpn == NULL || tport_is_connection_oriented(self))\n      tpn = self->tp_name;\n\n    SU_DEBUG_7((\"%s(%p): \"MOD_ZU\" bytes of \"MOD_ZU\" to %s/%s:%s%s\\n\",\n\t\t\"tport_vsend\", (void *)self, n, m,\n\t\tself->tp_name->tpn_proto, tpn->tpn_host, tpn->tpn_port,\n\t\t(ai->ai_flags & TP_AI_COMPRESSED) ? \";comp=sigcomp\" : \"\"));\n  }\n\n  return n;\n}\n\nstatic\nint tport_send_error(tport_t *self, msg_t *msg, tp_name_t const *tpn,\n\t\t     char const *who)\n{\n  int error = su_errno();\n\n  if (error == EPIPE) {\n    /*Xyzzy*/\n  }\n\n  if (su_is_blocking(error)) {\n    su_addrinfo_t *ai = msg_addrinfo(msg);\n    char const *comp = (ai->ai_flags & TP_AI_COMPRESSED) ? \";comp=sigcomp\" : \"\";\n    SU_DEBUG_5((\"%s(%p): %s with (s=%d %s/%s:%s%s)\\n\",\n\t\twho, (void *)self, \"EAGAIN\", (int)self->tp_socket,\n\t\ttpn->tpn_proto, tpn->tpn_host, tpn->tpn_port, comp));\n    return 0;\n  }\n\n  msg_set_errno(msg, error);\n\n  return tport_send_fatal(self, msg, tpn, who);\n}\n\nstatic\nint tport_send_fatal(tport_t *self, msg_t *msg, tp_name_t const *tpn,\n\t\t     char const *who)\n{\n  su_addrinfo_t *ai = msg_addrinfo(msg);\n  char const *comp = (ai->ai_flags & TP_AI_COMPRESSED) ? \";comp=sigcomp\" : \"\";\n\n  int error = msg_errno(msg);\n\n  if (self->tp_addrinfo->ai_family == AF_INET) {\n    SU_DEBUG_3((\"%s(%p): %s with (s=%d %s/%s:%s%s)\\n\",\n\t\twho, (void *)self, su_strerror(error), (int)self->tp_socket,\n\t\ttpn->tpn_proto, tpn->tpn_host, tpn->tpn_port, comp));\n  }\n#if SU_HAVE_IN6\n  else if (self->tp_addrinfo->ai_family == AF_INET6) {\n    su_sockaddr_t const *su = (su_sockaddr_t const *)ai->ai_addr;\n    SU_DEBUG_3((\"%s(%p): %s with (s=%d, IP6=%s/%s:%s%s\"\n\t\t\" (scope=%i) addrlen=%u)\\n\",\n\t\twho, (void *)self, su_strerror(error), (int)self->tp_socket,\n\t\ttpn->tpn_proto, tpn->tpn_host, tpn->tpn_port, comp,\n\t\tsu->su_scope_id, (unsigned)ai->ai_addrlen));\n  }\n#endif\n  else {\n    SU_DEBUG_3((\"%s(%p): %s with (s=%d, AF=%u addrlen=%u)%s\\n\",\n\t\twho, (void *)self, su_strerror(error),\n\t\t(int)self->tp_socket, ai->ai_family, (unsigned)ai->ai_addrlen, comp));\n  }\n\n#if 0\n  int i;\n  for (i = 0; i < iovused; i++)\n    SU_DEBUG_7((\"\\t\\tiov[%d] = { %d bytes @ %p }\\n\",\n\t\ti, iov[i].siv_len, (void *)iov[i].siv_base));\n#endif\n\n  if (tport_is_connection_oriented(self)) {\n    tport_error_report(self, error, NULL);\n    if (tport_has_connection(self))\n      tport_close(self);\n  }\n\n  return -1;\n}\n\n\nstatic\nint tport_queue_rest(tport_t *self,\n\t\t     msg_t *msg,\n\t\t     msg_iovec_t iov[],\n\t\t     size_t iovused)\n{\n  size_t iovlen = self->tp_iovlen;\n\n  assert(tport_is_connection_oriented(self));\n  assert(self->tp_queue == NULL ||\n\t self->tp_queue[self->tp_qhead] == NULL ||\n\t self->tp_queue[self->tp_qhead] == msg);\n\n  if (tport_queue(self, msg) < 0)\n    return -1;\n\n  assert(self->tp_queue[self->tp_qhead] == msg);\n\n  if (self->tp_iov == NULL) {\n    if (iovlen < 40) iovlen = 40;\n    if (iovlen < iovused) iovlen = iovused;\n    self->tp_iov = su_alloc(self->tp_home, iovlen * sizeof(iov[0]));\n    self->tp_iovlen = iovlen;\n\n    if (!self->tp_iov) {\n      msg_set_errno(msg, errno);\n      return -1;\n    }\n\n    memcpy(self->tp_iov, iov, iovused * sizeof(iov[0]));\n\n    iov = self->tp_iov;\n  }\n\n  self->tp_unsent = iov;\n  self->tp_unsentlen = iovused;\n\n  /* the POLLOUT event is far too unreliable with SCTP */\n  if (self->tp_addrinfo->ai_protocol == IPPROTO_SCTP)\n    return 0;\n\n  /* Ask for a send event */\n  tport_set_events(self, SU_WAIT_OUT, 0);\n\n  return 0;\n}\n\n/** Queue a message to transport.\n *\n * The tport_tqueue() function queues a message in the send queue. It is\n * used by an (server) application that is required to send (response)\n * messages in certain order. For example, a HTTP server or proxy may\n * receive multiple requests from a single TCP connection. The server is\n * required to answer to the requests in same order as they are received.\n * The responses are, however, sometimes generated asynchronously, that is,\n * a response to a later request may be ready earlier. For that purpose, the\n * HTTP protocol stack queues an empty response message immediately upon\n * receiving a request. Other messages cannot be sent before the queued one.\n *\n * The function tport_tqsend() is used to send the completed response message.\n *\n * @param self pointer to transport object\n * @param msg  message to be inserted into queue\n * @param tag,value,... tagged argument list\n *\n * @TAGS\n * @par Currently none.\n *\n * @retval 0 when successful\n * @retval -1 upon an error\n\n * @ERRORS\n * @ERROR EINVAL  Invalid argument(s).\n * @ERROR ENOMEM  Memory was exhausted.\n * @ERROR ENOBUFS The transport object queue was full.\n *\n * @deprecated Alternative interface will be provided in near future.\n *\n * @sa tport_tqsend()\n */\nint tport_tqueue(tport_t *self, msg_t *msg,\n\t\t tag_type_t tag, tag_value_t value, ...)\n{\n  msg_unprepare(msg);\n\n  return tport_queue(self, msg);\n}\n\n/** Return number of queued messages. */\nisize_t tport_queuelen(tport_t const *self)\n{\n  isize_t retval = 0;\n\n  if (self && self->tp_queue) {\n    unsigned short i, N = self->tp_params->tpp_qsize;\n\n    for (i = self->tp_qhead; self->tp_queue[i] && retval < N; i = (i + 1) % N)\n      retval++;\n  }\n\n  return retval;\n}\n\nstatic\nint tport_queue(tport_t *self, msg_t *msg)\n{\n  unsigned short qhead = self->tp_qhead;\n  unsigned short N = self->tp_params->tpp_qsize;\n\n  SU_DEBUG_7((\"tport_queue(%p): queueing %p for %s/%s:%s\\n\",\n\t      (void *)self, (void *)msg,\n\t      self->tp_protoname, self->tp_host, self->tp_port));\n\n  if (self->tp_queue == NULL) {\n    assert(N > 0);\n    assert(qhead == 0);\n    self->tp_queue = su_zalloc(self->tp_home, N * sizeof(msg));\n    if (!self->tp_queue) {\n      msg_set_errno(msg, errno);\n      return -1;\n    }\n  }\n\n  if (self->tp_queue[qhead] == msg)\n    return 0;\n\n  while (self->tp_queue[qhead]) {\n    qhead = (qhead + 1) % N;\n    if (qhead == self->tp_qhead) {\n      msg_set_errno(msg, ENOBUFS);\n      return -1;\n    }\n  }\n\n  self->tp_queue[qhead] = msg_ref_create(msg);\n\n  return 0;\n}\n\n/** Send a queued message (and queue another, if required).\n *\n * The function tport_tqsend() sends a message to the transport.\n *\n * @deprecated Alternative interface will be provided in near future.\n */\nint tport_tqsend(tport_t *self, msg_t *msg, msg_t *next,\n\t\t tag_type_t tag, tag_value_t value, ...)\n{\n  unsigned short qhead;\n  ta_list ta;\n  int reuse, sdwn_after, close_after;\n  unsigned short N;\n  su_addrinfo_t *ai;\n\n  if (self == NULL)\n    return -1;\n\n  qhead = self->tp_qhead;\n  N = self->tp_params->tpp_qsize;\n  reuse = self->tp_reusable;\n  sdwn_after = 0;\n  close_after = 0;\n\n  ta_start(ta, tag, value);\n\n  tl_gets(ta_args(ta),\n\t  TPTAG_REUSE_REF(reuse),\n\t  TPTAG_SDWN_AFTER_REF(sdwn_after),\n\t  TPTAG_CLOSE_AFTER_REF(close_after),\n\t  TAG_END());\n\n  ta_end(ta);\n\n  /* If \"next\", make sure we can queue it */\n  if (next && self->tp_queue[qhead == 0 ? N - 1 : qhead - 1]) {\n    msg_set_errno(next, ENOBUFS);\n    return -1;\n  }\n\n  /* Prepare message for sending - i.e., encode it */\n  if (msg_prepare(msg) < 0) {\n    msg_set_errno(msg, errno);\n    return -1;\n  }\n\n  tport_peer_address(self, msg);  /* Set addrinfo */\n  if (next == NULL) {\n    ai = msg_addrinfo(msg);\n\n    if (sdwn_after)\n      ai->ai_flags |= TP_AI_SHUTDOWN;\n    if (close_after)\n      ai->ai_flags |= TP_AI_CLOSE;\n\n    if (self->tp_queue[qhead] == msg) {\n      tport_send_queue(self);\n      tport_set_secondary_timer(self);\n    }\n    return 0;\n  }\n\n  ai = msg_addrinfo(next);\n\n  if (sdwn_after)\n    ai->ai_flags |= TP_AI_SHUTDOWN;\n  if (close_after)\n    ai->ai_flags |= TP_AI_CLOSE;\n\n  if (self->tp_queue[qhead] == msg) {\n    /* XXX - what about errors? */\n    tport_send_msg(self, msg, self->tp_name, NULL);\n    tport_set_secondary_timer(self);\n    if (!self->tp_unsent) {\n      msg_destroy(self->tp_queue[qhead]);\n      if ((self->tp_queue[qhead] = msg_ref_create(next)))\n\tmsg_unprepare(next);\n      return 0;\n    }\n  }\n\n  while (self->tp_queue[qhead] && self->tp_queue[qhead] != msg) {\n    qhead = (qhead + 1) % N;\n    if (qhead == self->tp_qhead)\n      break;\n  }\n\n  if (self->tp_queue[qhead] != msg) {\n    msg_set_errno(next, EINVAL);\n    return -1;\n  }\n\n  msg = msg_ref_create(next);\n\n  do {\n    qhead = (qhead + 1) % N;\n    next = self->tp_queue[qhead]; self->tp_queue[qhead] = msg; msg = next;\n    /* Above we made sure that there is an empty slot */\n    assert(!next || qhead != self->tp_qhead);\n  } while (next);\n\n  return 0;\n}\n\n/** Send event.\n *\n * Process SU_WAIT_OUT event.\n */\nvoid tport_send_event(tport_t *self)\n{\n  assert(tport_is_connection_oriented(self));\n\n  SU_DEBUG_7((\"tport_send_event(%p) - ready to send to (%s/%s:%s)\\n\",\n\t      (void *)self, self->tp_protoname, self->tp_host, self->tp_port));\n  tport_send_queue(self);\n  tport_set_secondary_timer(self);\n}\n\n/** Send queued messages */\nvoid tport_send_queue(tport_t *self)\n{\n  msg_t *msg;\n  msg_iovec_t *iov;\n  size_t i, iovused, n, total;\n  unsigned short qhead = self->tp_qhead, N = self->tp_params->tpp_qsize;\n\n  assert(self->tp_queue && self->tp_queue[qhead]);\n\n  msg = self->tp_queue[qhead];\n\n  iov = self->tp_unsent, self->tp_unsent = NULL;\n  iovused = self->tp_unsentlen, self->tp_unsentlen = 0;\n\n  if (iov && iovused) {\n    ssize_t e;\n\n    self->tp_stime = self->tp_ktime = su_now();\n\n    e = tport_vsend(self, msg, self->tp_name, iov, iovused, NULL);\n\n    if (e == -1)\t\t\t\t/* XXX */\n      return;\n\n    n = (size_t)e;\n\n    if (n > 0 && self->tp_master->mr_log && self->tp_slogged != msg) {\n      tport_log_msg(self, msg, \"send\", \"to\", self->tp_stime);\n      self->tp_slogged = msg;\n    }\n\n    for (i = 0, total = 0; i < iovused; i++) {\n      if (total + (size_t)iov[i].mv_len > n) {\n\tiov[i].mv_len -= (su_ioveclen_t)(n - total);\n\tiov[i].mv_base = (char *)iov[i].mv_base + (n - total);\n\n\tself->tp_unsent = iov + i;\n\tself->tp_unsentlen = iovused - i;\n\n\treturn;\n      }\n      total += iov[i].mv_len;\n    }\n    assert(total == n);\n\n    /* We have sent a complete message */\n\n    self->tp_queue[qhead] = NULL;\n    tport_sent_message(self, msg, 0);\n    msg_destroy(msg);\n\n    qhead = (qhead + 1) % N;\n  }\n\n  while (msg_is_prepared(msg = self->tp_queue[self->tp_qhead = qhead])) {\n    /* XXX - what about errors? */\n    tport_send_msg(self, msg, self->tp_name, NULL);\n    if (self->tp_unsent)\n      return;\n\n    msg = self->tp_queue[qhead]; /* tport_send_msg() may flush queue! */\n    self->tp_queue[qhead] = NULL;\n    msg_destroy(msg);\n    qhead = (qhead + 1) % N;\n  }\n\n  /* No more send event(s)? */\n  tport_set_events(self, 0, SU_WAIT_OUT);\n}\n\nstatic int msg_select_addrinfo(msg_t *msg, su_addrinfo_t *res);\n\nstatic int\ntport_resolve(tport_t *self, msg_t *msg, tp_name_t const *tpn)\n{\n  int error;\n  char ipaddr[TPORT_HOSTPORTSIZE];\n  su_addrinfo_t *res, hints[1] = {{ 0 }};\n  char const *host;\n  su_sockaddr_t *su;\n\n  hints->ai_socktype = self->tp_addrinfo->ai_socktype;\n  hints->ai_protocol = self->tp_addrinfo->ai_protocol;\n\n  if (host_is_ip6_reference(tpn->tpn_host)) {\n    /* Remove [] around IPv6 address */\n    size_t len = strlen(tpn->tpn_host);\n    assert(len < sizeof ipaddr);\n    host = memcpy(ipaddr, tpn->tpn_host + 1, len - 2);\n    ipaddr[len - 2] = '\\0';\n    hints->ai_flags |= AI_NUMERICHOST;\n  }\n  else {\n#if HAVE_OPEN_C\n    if (host_is_ip_address(tpn->tpn_host))\n      hints->ai_flags |= AI_NUMERICHOST;\n#endif\n    host = tpn->tpn_host;\n  }\n\n  if ((error = su_getaddrinfo(host, tpn->tpn_port, hints, &res))) {\n    SU_DEBUG_3((\"tport_resolve: getaddrinfo(\\\"%s\\\":%s): %s\\n\",\n\t\ttpn->tpn_host, tpn->tpn_port,\n\t\tsu_gai_strerror(error)));\n    msg_set_errno(msg, ENXIO);\n    return -1;\n  }\n\n  error = msg_select_addrinfo(msg, res);\n\n  su = (su_sockaddr_t *) msg_addrinfo(msg)->ai_addr;\n\n#if SU_HAVE_IN6\n  SU_DEBUG_9((\"tport_resolve addrinfo = %s%s%s:%d\\n\",\n\t      su->su_family == AF_INET6 ? \"[\" : \"\",\n              su_inet_ntop(su->su_family, SU_ADDR(su), ipaddr, sizeof(ipaddr)),\n\t      su->su_family == AF_INET6 ? \"]\" : \"\",\n              htons(su->su_port)));\n#else\n  SU_DEBUG_9((\"tport_resolve addrinfo = %s%s%s:%d\\n\",\n\t      \"\",\n              su_inet_ntop(su->su_family, SU_ADDR(su), ipaddr, sizeof(ipaddr)),\n\t      \"\",\n              htons(su->su_port)));\n#endif\n\n  su_freeaddrinfo(res);\n\n  return error;\n}\n\nstatic int\nmsg_select_addrinfo(msg_t *msg, su_addrinfo_t *res)\n{\n  su_addrinfo_t *ai, *mai = msg_addrinfo(msg);\n  su_sockaddr_t *su = (su_sockaddr_t *)mai->ai_addr;\n\n  for (ai = res; ai; ai = ai->ai_next) {\n#if SU_HAVE_IN6\n    if (ai->ai_family != AF_INET && ai->ai_family != AF_INET6)\n      continue;\n#else\n    if (ai->ai_family != AF_INET)\n      continue;\n#endif\n\n    if (ai->ai_protocol == 0)\n      continue;\n    if (ai->ai_addrlen > sizeof(su_sockaddr_t))\n      continue;\n\n    mai->ai_family = ai->ai_family;\n    mai->ai_socktype = ai->ai_socktype;\n    mai->ai_protocol = ai->ai_protocol;\n\n    if (ai->ai_addrlen < sizeof(su_sockaddr_t))\n      memset(su, 0, sizeof(su_sockaddr_t));\n    memcpy(su, ai->ai_addr, ai->ai_addrlen);\n    if (su_sockaddr_size(su))\n      mai->ai_addrlen = su_sockaddr_size(su);\n    else\n      mai->ai_addrlen = ai->ai_addrlen;\n    return 0;\n  }\n\n  msg_set_errno(msg, EAFNOSUPPORT);\n\n  return -1;\n}\n\n/** Copy peer address to msg */\nvoid\ntport_peer_address(tport_t *self, msg_t *msg)\n{\n  su_addrinfo_t *mai = msg_addrinfo(msg);\n  su_addrinfo_t const *tai = self->tp_addrinfo;\n  void *maddr = mai->ai_addr;\n  int flags = mai->ai_flags;\n\n  memcpy(mai, tai, sizeof *mai);\n  mai->ai_addr = memcpy(maddr, tai->ai_addr, tai->ai_addrlen);\n  mai->ai_flags = flags;\n}\n\n/** Process error event.\n *\n * Return events that can be processed afterwards.\n */\nint tport_error_event(tport_t *self)\n{\n  int errcode;\n  su_sockaddr_t name[1] = {{ 0 }};\n\n  name->su_family = AF_UNSPEC; /* 0 */\n\n  if (tport_is_udp(self)) {\n    errcode = tport_udp_error(self, name);\n  }\n  else {\n    /* Process error event for basic transport. */\n    errcode = su_soerror(self->tp_socket);\n  }\n\n  if (errcode == 0 || errcode == EPIPE)\n    return errcode;\n\n  tport_error_report(self, errcode, name);\n\n  return 0;\n}\n\n/** Mark message as waiting for a response.\n *\n * @return Positive integer, or -1 upon an error.\n */\nint tport_pend(tport_t *self,\n\t       msg_t *msg,\n\t       tport_pending_error_f *callback,\n\t       tp_client_t *client)\n{\n  tport_pending_t *pending;\n\n  if (self == NULL || callback == NULL)\n    return -1;\n\n  if (msg == NULL && tport_is_primary(self))\n    return -1;\n\n  SU_DEBUG_7((\"tport_pend(%p): pending %p for %s/%s:%s (already %u)\\n\",\n\t      (void *)self, (void *)msg,\n\t      self->tp_protoname, self->tp_host, self->tp_port,\n\t      self->tp_pused));\n\n  if (self->tp_released == NULL) {\n    unsigned i, len = 8;\n    if (self->tp_plen)\n      len = 2 * self->tp_plen;\n    pending = su_realloc(self->tp_home,\n\t\t\t self->tp_pending, len * sizeof(*pending));\n    if (!pending) {\n      msg_set_errno(msg, errno);\n      return -1;\n    }\n\n    memset(pending + self->tp_plen, 0, (len - self->tp_plen) * sizeof(*pending));\n\n    for (i = self->tp_plen; i + 1 < len; i++)\n      pending[i].p_client = pending + i + 1;\n\n    self->tp_released = pending + self->tp_plen;\n    self->tp_pending = pending;\n    self->tp_plen = len;\n  }\n\n  pending = self->tp_released;\n  self->tp_released = pending->p_client;\n\n  pending->p_callback = callback;\n  pending->p_client = client;\n  pending->p_msg = msg;\n  pending->p_reported = self->tp_reported;\n\n  self->tp_pused++;\n\n  return (pending - self->tp_pending) + 1;\n}\n\n/** Mark message as no more pending */\nint tport_release(tport_t *self,\n\t\t  int pendd,\n\t\t  msg_t *msg,\n\t\t  msg_t *reply,\n\t\t  tp_client_t *client,\n\t\t  int still_pending)\n{\n  tport_pending_t *pending;\n\n  if (self == NULL || pendd <= 0 || pendd > (int)self->tp_plen)\n    return su_seterrno(EINVAL), -1;\n\n  pending = self->tp_pending + (pendd - 1);\n\n  if (pending->p_client != client ||\n      pending->p_msg != msg) {\n\t  SU_DEBUG_1((\"%s(%p): %u %p by %p not pending\\n\",\n\t\t      __func__, (void *)self,\n\t\t      pendd, (void *)msg, (void *)client));\n    return su_seterrno(EINVAL), -1;\n  }\n\n  SU_DEBUG_7((\"%s(%p): %p by %p with %p%s\\n\",\n\t      __func__, (void *)self,\n\t      (void *)msg, (void *)client, (void *)reply,\n\t      still_pending ? \" (preliminary)\" : \"\"));\n\n  /* sigcomp can here associate request (msg) with response (reply) */\n\n  if (still_pending)\n    return 0;\n\n  /* Just to make sure nobody uses stale data */\n  memset(pending, 0, sizeof(*pending));\n  pending->p_client = self->tp_released;\n  self->tp_released = pending;\n  self->tp_pused--;\n  return 0;\n}\n\n/** Report error to pending messages with destination */\nint\ntport_pending_error(tport_t *self, su_sockaddr_t const *dst, int error)\n{\n  unsigned i, reported, callbacks;\n  tport_pending_t *pending;\n  msg_t *msg;\n  su_addrinfo_t const *ai;\n\n  assert(self);\n\n  callbacks = 0;\n  reported = ++self->tp_reported;\n\n  if (self->tp_pused == 0)\n    return 0;\n\n  for (i = 0; i < self->tp_plen; i++) {\n    pending = self->tp_pending + i;\n\n    if (!pending->p_callback)\n      continue;\n\n    if (pending->p_reported == reported)\n      continue;\n\n    msg = pending->p_msg;\n\n    if (dst && msg) {\n      ai = msg_addrinfo(msg);\n\n      if (su_cmp_sockaddr(dst, (su_sockaddr_t *)ai->ai_addr) != 0)\n\tcontinue;\n    }\n\n    msg_set_errno(msg, error);\n\n    pending->p_reported = reported;\n\n    pending->p_callback(self->TP_STACK, pending->p_client, self, msg, error);\n\n    callbacks++;\n  }\n\n  return callbacks;\n}\n\n\n/** Report error via pending message */\nint\ntport_pending_errmsg(tport_t *self, msg_t *msg, int error)\n{\n  unsigned i, reported, callbacks;\n  tport_pending_t *pending;\n\n  assert(self); assert(msg);\n\n  callbacks = 0;\n  reported = ++self->tp_reported;\n\n  msg_set_errno(msg, error);\n\n  if (self->tp_pused == 0)\n    return 0;\n\n  for (i = 0; i < self->tp_plen; i++) {\n    pending = self->tp_pending + i;\n\n    if (!pending->p_client ||\n\tpending->p_msg != msg ||\n\tpending->p_reported == reported)\n      continue;\n\n    pending->p_reported = reported;\n\n    pending->p_callback(self->TP_STACK, pending->p_client, self, msg, error);\n\n    callbacks++;\n  }\n\n  return callbacks;\n}\n\n\n/** Set transport magic. */\nvoid tport_set_magic(tport_t *self, tp_magic_t *magic)\n{\n  self->tp_magic = magic;\n}\n\n/** Get transport magic. */\ntp_magic_t *tport_magic(tport_t const *self)\n{\n  return self ? self->tp_magic : NULL;\n}\n\n/** Get primary transport (or self, if primary) */\ntport_t *tport_parent(tport_t const *self)\n{\n  return self ? self->tp_pri->pri_primary : NULL;\n}\n\n/** Get list of primary transports */\ntport_t *tport_primaries(tport_t const *self)\n{\n  if (self)\n    return self->tp_master->mr_primaries->pri_primary;\n  else\n    return NULL;\n}\n\n/** Get next transport */\ntport_t *tport_next(tport_t const *self)\n{\n  if (self == NULL)\n    return NULL;\n  else if (tport_is_master(self))\n    return ((tport_master_t *)self)->mr_primaries->pri_primary;\n\n  else if (tport_is_primary(self))\n    return ((tport_primary_t *)self)->pri_next->pri_primary;\n  else\n    return tprb_succ(self);\n}\n\n/** Get secondary transports. */\ntport_t *tport_secondary(tport_t const *self)\n{\n  if (tport_is_primary(self))\n    return self->tp_pri->pri_open;\n  else\n    return NULL;\n}\n\n#if 0\nvoid tport_hints(tport_t const *self, su_addrinfo_t *hints)\n{\n  hints->ai_protocol = self->tp_addrinfo->ai_protocol;\n  hints->ai_socktype = self->tp_addrinfo->ai_socktype;\n}\n#endif\n\n/** Get transport address list. */\nsu_addrinfo_t const *tport_get_address(tport_t const *self)\n{\n  return self ? self->tp_addrinfo : NULL;\n}\n\n/** Get transport name. */\ntp_name_t const *tport_name(tport_t const *self)\n{\n  return self->tp_name;\n}\n\n/** Get transport identifier. */\nchar const *tport_ident(tport_t const *self)\n{\n  return self ? self->tp_ident : NULL;\n}\n\n/** Get transport by protocol name. */\ntport_t *tport_by_protocol(tport_t const *self, char const *proto)\n{\n  if (proto && strcmp(proto, tpn_any) != 0) {\n    for (; self; self = tport_next(self))\n      if (su_casematch(proto, self->tp_protoname))\n\tbreak;\n  }\n\n  return (tport_t *)self;\n}\n#ifdef SOFIA_TPORT_DEBUG_TRACE\nvoid tport_debug( tport_t const *tp ) {\n  tport_primary_t const *self = tp->tp_master->mr_primaries ;\n  int i = 0 ;\n  for (; self; self = self->pri_next, i++) {\n    tp = self->pri_primary;\n    SU_DEBUG_9((\"tport_debug: loop %d \\n\", i));\n    SU_DEBUG_9((\"tport_primary_by_name: tp %ld \\n\", (unsigned long) (void *)tp));\n    SU_DEBUG_9((\"tport_primary_by_name: ai_family %d \\n\", tp->tp_addrinfo->ai_family));\n  }\n}\n#endif\n/** Get transport by protocol name. */\ntport_t *tport_primary_by_name(tport_t const *tp, tp_name_t const *tpn)\n{\n  char const *ident = tpn->tpn_ident;\n  char const *proto = tpn->tpn_proto;\n  char const *comp = tpn->tpn_comp;\n  int family = 0;\n  const tport_t* tport_default = NULL;\n  tport_t* tport_best_match = NULL;\n  int octet_count = 0;\n\n  tport_primary_t const *self, *nocomp = NULL;\n\n  self = tp ? tp->tp_master->mr_primaries : NULL;\n\n  if (ident && strcmp(ident, tpn_any) == 0)\n    ident = NULL;\n\n  if (tpn->tpn_host == NULL)\n    family = 0;\n#if SU_HAVE_IN6\n  else if (host_is_ip6_address(tpn->tpn_host))\n    family = AF_INET6;\n#endif\n  else if (host_is_ip4_address(tpn->tpn_host))\n    family = AF_INET;\n  else\n    family = 0;\n\n  if (proto && strcmp(proto, tpn_any) == 0)\n    proto = NULL;\n\n  if (!ident && !proto && !family && !comp)\n    return (tport_t *)self;   /* Anything goes */\n\n  comp = tport_canonize_comp(comp);\n\n  for (; self; self = self->pri_next) {\n    const tport_t* current = (tport_t *) self;\n    char szRemote[64];\n    char szLocal[64];\n\n    tp = self->pri_primary;\n\n    if (ident && strcmp(ident, tp->tp_ident))\n      continue;\n    if (family) {\n      if (family == AF_INET && !tport_has_ip4(tp)) \n  continue;\n#if SU_HAVE_IN6\n      if (family == AF_INET6 && !tport_has_ip6(tp))\n  continue;\n#endif\n    }\n    if (proto && !su_casematch(proto, tp->tp_protoname))\n      continue;\n\n    if (comp && comp != tp->tp_name->tpn_comp) {\n      if (tp->tp_name->tpn_comp == NULL && nocomp == NULL)\n  nocomp = self;\n      continue;\n    }\n\n    //break;\n    if (!tport_default) tport_default = tp ;\n\n    strncpy(szRemote, tpn->tpn_host, 64);\n    strncpy(szLocal, current->tp_name->tpn_host, 64);\n\n    char *pLocal[4] = {0,0,0,0};\n    char *pRemote[4] = {0,0,0,0};\n\n    int i = 0;\n    char* rest = szLocal;\n    char* token ;\n    while (NULL != (token = strtok_r(rest, \".\", &rest)) && i < 4) {\n       pLocal[i++] = token;\n    }\n\n    i = 0;\n    rest = szRemote;\n    while (NULL != (token = strtok_r(rest, \".\", &rest)) && i < 4) {\n       pRemote[i++] = token;\n    }\n\n    int count = 0;\n    int j = 0;\n    for (j = 0; j < 4; j++) {\n      if (NULL == pLocal[j] || NULL == pRemote[j]) break;\n      if (0 != strcmp(pLocal[j], pRemote[j])) break;\n      count++;\n    }\n\n    if (count > octet_count) {\n      octet_count = count;\n      tport_best_match = (tport_t *) current;\n    }\n  }\n\n  if (tport_best_match) return (tport_t *) tport_best_match;\n  if (tport_default) return (tport_t *) tport_default;\n\n  return (tport_t *)nocomp;\n}\n\n\n/** Get transport by name. */\ntport_t *tport_by_name(tport_t const *self, tp_name_t const *tpn)\n{\n  tport_t const *sub, *next;\n  char const *canon, *host, *port, *comp;\n#if SU_HAVE_IN6\n  char *end, ipaddr[TPORT_HOSTPORTSIZE];\n#endif\n\n  assert(self); assert(tpn);\n\n  assert(tpn->tpn_proto); assert(tpn->tpn_host); assert(tpn->tpn_port);\n  assert(tpn->tpn_canon);\n\n  if (!tport_is_primary(self))\n    self = tport_primary_by_name(self, tpn);\n\n  host = strcmp(tpn->tpn_host, tpn_any) ? tpn->tpn_host : NULL;\n  port = strcmp(tpn->tpn_port, tpn_any) ? tpn->tpn_port : NULL;\n  canon = tpn->tpn_canon;\n  comp = tport_canonize_comp(tpn->tpn_comp);\n\n  if (self && host && port) {\n    int resolved = 0, cmp;\n    socklen_t sulen;\n    su_sockaddr_t su[1];\n\n    sub = self->tp_pri->pri_open;\n\n    memset(su, 0, sizeof su);\n\n#if SU_HAVE_IN6\n    if (host_is_ip6_reference(host)) {\n      /* Remove [] around IPv6 address */\n      host = strncpy(ipaddr, host +  1, sizeof(ipaddr) - 1);\n      ipaddr[sizeof(ipaddr) - 1] = '\\0';\n      if ((end = strchr(host, ']')))\n\t*end = 0;\n      su->su_len = sulen = (socklen_t) sizeof (struct sockaddr_in6);\n      su->su_family = AF_INET6;\n    }\n    else if (host_is_ip6_address(host)) {\n      su->su_len = sulen = (socklen_t) sizeof (struct sockaddr_in6);\n      su->su_family = AF_INET6;\n    }\n    else\n#endif\n    {\n      su->su_len = sulen = (socklen_t) sizeof (struct sockaddr_in);\n      su->su_family = AF_INET;\n    }\n\n    su->su_port = htons(strtoul(port, NULL, 10));\n\n    if (su_inet_pton(su->su_family, host, SU_ADDR(su)) > 0) {\n      resolved = 1;\n      next = NULL;\n\n      /* Depth-first search */\n      while (sub) {\n\tcmp = (int)((size_t)sub->tp_addrlen - (size_t)sulen);\n\n\tif (cmp == 0)\n\t  cmp = memcmp(sub->tp_addr, su, sulen);\n\n\tif (cmp == 0) {\n\t  if (sub->tp_left) {\n\t    next = sub;\n\t    sub = sub->tp_left;\n\t    continue;\n\t  }\n\t  break;\n\t}\n\telse if (next) {\n\t  sub = next;\n\t  break;\n\t}\n\telse if (cmp > 0) {\n\t  sub = sub->tp_left;\n\t  continue;\n\t}\n\telse /* if (cmp < 0) */ {\n\t  sub = sub->tp_right;\n\t  continue;\n\t}\n      }\n    }\n    else {\n      SU_DEBUG_7((\"tport(%p): EXPENSIVE unresolved \" TPN_FORMAT \"\\n\",\n\t\t  (void *)self, TPN_ARGS(tpn)));\n\n      sub = tprb_first(sub);\n    }\n\n    for (; sub; sub = tprb_succ(sub)) {\n      if (!sub->tp_reusable)\n\tcontinue;\n      if (!tport_is_registered(sub))\n\tcontinue;\n      if (tport_is_shutdown(sub))\n\tcontinue;\n\n      if (comp != sub->tp_name->tpn_comp)\n\tcontinue;\n\n      if (resolved) {\n\tif ((socklen_t)sub->tp_addrlen != sulen ||\n\t    memcmp(sub->tp_addr, su, sulen)) {\n\t  //SU_DEBUG_7((\"tport(%p): not found by name \" TPN_FORMAT \"\\n\",\n\t\t//      (void *)self, TPN_ARGS(tpn)));\n\t  break;\n\t}\n\tSU_DEBUG_7((\"tport(%p): found %p by name \" TPN_FORMAT \"\\n\",\n\t\t    (void *)self, (void *)sub, TPN_ARGS(tpn)));\n      }\n      else if (!su_casematch(port, sub->tp_port))\n\tcontinue;\n      else if (!su_casematch(canon, sub->tp_canon) &&\n\t       !su_casematch(host, sub->tp_host))\n\tcontinue;\n\n      return (tport_t *)sub;\n    }\n  }\n\n  return (tport_t *)self;\n}\n\n/** Get transport from primary by addrinfo. */\ntport_t *tport_by_addrinfo(tport_primary_t const *pri,\n\t\t\t   su_addrinfo_t const *ai,\n\t\t\t   tp_name_t const *tpn)\n{\n  tport_t const *sub, *maybe;\n  struct sockaddr const *sa;\n  int cmp;\n  char const *comp;\n\n  assert(pri); assert(ai);\n\n  sa = ai->ai_addr;\n\n  sub = pri->pri_open, maybe = NULL;\n\n  comp = tport_canonize_comp(tpn->tpn_comp);\n\n  /* Find leftmost (prevmost) matching tport */\n  while (sub) {\n    cmp = (int)(sub->tp_addrlen - ai->ai_addrlen);\n    if (cmp == 0)\n      cmp = memcmp(sub->tp_addr, sa, ai->ai_addrlen);\n\n    if (cmp == 0) {\n      if (sub->tp_left) {\n\tmaybe = sub;\n\tsub = sub->tp_left;\n\tcontinue;\n      }\n      break;\n    }\n    else if (maybe) {\n      sub = maybe;\n      break;\n    }\n    else if (cmp > 0) {\n      sub = sub->tp_left;\n      continue;\n    }\n    else /* if (cmp < 0) */ {\n      sub = sub->tp_right;\n      continue;\n    }\n  }\n\n  for (; sub; sub = tprb_succ(sub)) {\n    if (!sub->tp_reusable)\n      continue;\n    if (!tport_is_registered(sub))\n      continue;\n    if (tport_is_shutdown(sub))\n      continue;\n\n    if (tport_has_tls(sub) && !su_casematch(tpn->tpn_canon, sub->tp_name->tpn_canon)) {\n      if (!tport_is_verified(sub))\n        continue;\n      if (!tport_subject_search(tpn->tpn_canon, sub->tp_subjects))\n        continue;\n    }\n\n    if (comp != sub->tp_name->tpn_comp)\n      continue;\n\n    if (sub->tp_addrlen != ai->ai_addrlen\n\t|| memcmp(sub->tp_addr, sa, ai->ai_addrlen)) {\n      sub = NULL;\n      break;\n    }\n    break;\n  }\n\n  if (sub) {\n    SU_DEBUG_9((\"%s(%p): found %p by name \" TPN_FORMAT \"\\n\",\n\t\t__func__, (void *)pri, (void *)sub, TPN_ARGS(tpn)));\n  }\n  else {\n    SU_DEBUG_9((\"%s(%p): not found by name \" TPN_FORMAT \"\\n\",\n\t\t__func__, (void *)pri, TPN_ARGS(tpn)));\n  }\n  return (tport_t *)sub;\n}\n\n\n/** Get transport name from URL. */\nint tport_name_by_url(su_home_t *home,\n\t\t      tp_name_t *tpn,\n\t\t      url_string_t const *us)\n{\n  size_t n;\n  url_t url[1];\n  char *b;\n\n  n = url_xtra(us->us_url);\n  b = su_alloc(home, n);\n\n  if (b == NULL || url_dup(b, n, url, us->us_url) < 0) {\n    su_free(home, b);\n    return -1;\n  }\n\n  tpn->tpn_proto = url_tport_default((enum url_type_e)url->url_type);\n  tpn->tpn_canon = url->url_host;\n  tpn->tpn_host = url->url_host;\n  tpn->tpn_port = url_port(url);\n\n  if (tpn->tpn_host == NULL || tpn->tpn_host[0] == '\\0' ||\n      tpn->tpn_port == NULL || tpn->tpn_port[0] == '\\0') {\n    su_free(home, b);\n    return -1;\n  }\n\n  if (url->url_params) {\n    for (b = (char *)url->url_params; b[0]; b += n) {\n      n = strcspn(b, \";\");\n\n      if (n > 10 && su_casenmatch(b, \"transport=\", 10))\n\ttpn->tpn_proto = b + 10;\n      else if (n > 6 && su_casenmatch(b, \"maddr=\", 6))\n\ttpn->tpn_host = b + 6;\n\n      if (b[n])\n\tb[n++] = '\\0';\n    }\n  }\n\n  return 0;\n}\n\n/** Check if transport named is already resolved */\nint tport_name_is_resolved(tp_name_t const *tpn)\n{\n  if (!tpn->tpn_host)\n    return 0;\n\n  return host_is_ip_address(tpn->tpn_host);\n}\n\n/** Duplicate name.\n *\n * The tport_name_dup() function copies strings belonging to the transport\n * name. It returns the copied strings via the @a dst transport name\n * structure. The memory block required for copies is allocated from the\n * memory @a home. Please note that only one memory block is allocated, so\n * the memory can be reclainmed only by deinitializing the memory home\n * itself.\n *\n * @retval 0 when successful\n * @retval -1 upon an error\n */\nint tport_name_dup(su_home_t *home,\n\t\t   tp_name_t *dst,\n\t\t   tp_name_t const *src)\n{\n  size_t n_proto, n_host, n_port, n_canon, n_comp = 0;\n  char *s;\n\n  if (!src->tpn_proto || !src->tpn_host || !src->tpn_port || !src->tpn_canon)\n    return -1;\n\n  if (strcmp(src->tpn_proto, tpn_any))\n    n_proto = strlen(src->tpn_proto) + 1;\n  else\n    n_proto = 0;\n\n  n_host = strlen(src->tpn_host) + 1;\n\n  n_port = strlen(src->tpn_port) + 1;\n\n  if (src->tpn_comp != NULL)\n    n_comp = strlen(src->tpn_comp) + 1;\n\n  if (src->tpn_canon != src->tpn_host &&\n      strcmp(src->tpn_canon, src->tpn_host))\n    n_canon = strlen(src->tpn_canon) + 1;\n  else\n    n_canon = 0;\n\n  s = su_alloc(home, n_proto + n_canon + n_host + n_port + n_comp);\n  if (s == NULL)\n    return -1;\n\n  if (n_proto)\n    dst->tpn_proto = memcpy(s, src->tpn_proto, n_proto), s += n_proto;\n  else\n    dst->tpn_proto = tpn_any;\n\n  dst->tpn_host = memcpy(s, src->tpn_host, n_host), s += n_host;\n  dst->tpn_port = memcpy(s, src->tpn_port, n_port), s += n_port;\n\n  if (n_canon)\n    dst->tpn_canon = memcpy(s, src->tpn_canon, n_canon), s += n_canon;\n  else\n    dst->tpn_canon = dst->tpn_host;\n\n  if (n_comp)\n    dst->tpn_comp = memcpy(s, src->tpn_comp, n_comp), s += n_comp;\n  else\n    dst->tpn_comp = NULL;\n\n  return 0;\n}\n\n/** Convert a sockaddr structure into printable form. */\nchar *tport_hostport(char buf[], isize_t bufsize,\n\t\t     su_sockaddr_t const *su,\n\t\t     int with_port_and_brackets)\n{\n  char *b = buf;\n  size_t n;\n\n#if SU_HAVE_IN6\n  if (with_port_and_brackets > 1 || su->su_family == AF_INET6) {\n    *b++ = '['; bufsize--;\n  }\n#endif\n\n  if (su_inet_ntop(su->su_family, SU_ADDR(su), b, bufsize) == NULL)\n    return NULL;\n  n = strlen(b);\n  if (bufsize < n + 2)\n    return NULL;\n\n  bufsize -= n; b += n;\n\n#if SU_HAVE_IN6\n  if (with_port_and_brackets > 1 || su->su_family == AF_INET6) {\n    *b++ = ']'; bufsize--;\n  }\n  if (with_port_and_brackets) {\n    unsigned short port = ntohs(su->su_port);\n    if (port != 0) {\n      n = snprintf(b, bufsize, \":%u\", port);\n      if (n <= 0)\n        return NULL;\n      b += n;\n      if (bufsize > n)\n        bufsize -= n;\n      else\n        bufsize = 0;\n    }\n  }\n#endif\n\n  if (bufsize)\n    *b++ = 0;\n\n  return buf;\n}\n\n/** @internal Update receive statistics. */\nvoid tport_recv_bytes(tport_t *self, ssize_t bytes, ssize_t on_line)\n{\n  self->tp_stats.recv_bytes += bytes;\n  self->tp_stats.recv_on_line += on_line;\n\n  if (self != self->tp_pri->pri_primary) {\n    self = self->tp_pri->pri_primary;\n    self->tp_stats.recv_bytes += bytes;\n    self->tp_stats.recv_on_line += on_line;\n  }\n  self = self->tp_master->mr_master;\n  self->tp_stats.recv_bytes += bytes;\n  self->tp_stats.recv_on_line += on_line;\n}\n\n/** @internal Update message-based receive statistics. */\nvoid tport_recv_message(tport_t *self, msg_t *msg, int error)\n{\n  error = error != 0;\n\n  self->tp_stats.recv_msgs++;\n  self->tp_stats.recv_errors += error;\n\n  if (self != self->tp_pri->pri_primary) {\n    self = self->tp_pri->pri_primary;\n    self->tp_stats.recv_msgs++;\n    self->tp_stats.recv_errors += error;\n  }\n\n  self = self->tp_master->mr_master;\n\n  self->tp_stats.recv_msgs++;\n  self->tp_stats.recv_errors += error;\n}\n\n/** @internal Update send statistics. */\nvoid tport_sent_bytes(tport_t *self, ssize_t bytes, ssize_t on_line)\n{\n  self->tp_stats.sent_bytes += bytes;\n  self->tp_stats.sent_on_line += on_line;\n\n  if (self != self->tp_pri->pri_primary) {\n    self = self->tp_pri->pri_primary;\n    self->tp_stats.sent_bytes += bytes;\n    self->tp_stats.sent_on_line += on_line;\n  }\n\n  self = self->tp_master->mr_master;\n  self->tp_stats.sent_bytes += bytes;\n  self->tp_stats.sent_on_line += on_line;\n}\n\n/** @internal Update message-based send statistics. */\nvoid tport_sent_message(tport_t *self, msg_t *msg, int error)\n{\n  self->tp_slogged = NULL;\n\n  error = error != 0;\n\n  self->tp_stats.sent_msgs++;\n  self->tp_stats.sent_errors += error;\n\n  if (self != self->tp_pri->pri_primary) {\n    self = self->tp_pri->pri_primary;\n    self->tp_stats.sent_msgs++;\n    self->tp_stats.sent_errors += error;\n  }\n\n  self = self->tp_master->mr_master;\n\n  self->tp_stats.sent_msgs++;\n  self->tp_stats.sent_errors += error;\n\n}\n"], "fixing_code": ["/*\n * This file is part of the Sofia-SIP package\n *\n * Copyright (C) 2005 Nokia Corporation.\n *\n * Contact: Pekka Pessi <pekka.pessi@nokia.com>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public License\n * as published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA\n *\n */\n\n/**@CFILE tport.c Transport interface implementation.\n *\n * See tport.docs for more detailed description of tport interface.\n *\n * @author Pekka Pessi <Pekka.Pessi@nokia.com>\n * @author Ismo Puustinen <Ismo.H.Puustinen@nokia.com>\n * @author Tat Chan <Tat.Chan@nokia.com>\n * @author Kai Vehmanen <kai.vehmanen@nokia.com>\n * @author Martti Mela <Martti.Mela@nokia.com>\n *\n * @date Created: Thu Jul 20 12:54:32 2000 ppessi\n */\n\n#include \"config.h\"\n\n#include <sofia-sip/su_string.h>\n#include <sofia-sip/su.h>\n#include <sofia-sip/su_errno.h>\n#include <sofia-sip/su_alloc.h>\n#include <sofia-sip/su_tagarg.h>\n#include <sofia-sip/su_localinfo.h>\n\ntypedef struct tport_nat_s tport_nat_t;\n\n#define SU_WAKEUP_ARG_T         struct tport_s\n#define SU_TIMER_ARG_T          struct tport_s\n#define SU_MSG_ARG_T            union tport_su_msg_arg\n\n#include <sofia-sip/su_wait.h>\n\n#include <sofia-sip/msg.h>\n#include <sofia-sip/msg_addr.h>\n#include <sofia-sip/hostdomain.h>\n\n#include <stdlib.h>\n#include <time.h>\n#include <assert.h>\n#include <errno.h>\n#include <limits.h>\n\n#ifndef IPPROTO_SCTP\n#define IPPROTO_SCTP (132)\n#endif\n\n#include \"sofia-sip/tport.h\"\n#include \"sofia-sip/su_uniqueid.h\"\n#include <sofia-sip/rbtree.h>\n\n#include \"tport_internal.h\"\n\n#if HAVE_FUNC\n#elif HAVE_FUNCTION\n#define __func__ __FUNCTION__\n#else\nstatic char const __func__[] = \"tport\";\n#endif\n\n#define STACK_RECV(tp, msg, now)\t\t       \\\n  (tp)->tp_master->mr_tpac->tpac_recv((tp)->tp_master->mr_stack, (tp), \\\n\t\t\t\t      (msg), (tp)->tp_magic, (now))\n\n#define STACK_ERROR(tp, errcode, dstname) \\\n  (tp)->tp_master->mr_tpac->tpac_error((tp)->tp_master->mr_stack, (tp), \\\n\t\t\t\t       (errcode), (dstname))\n\n#define STACK_ADDRESS(tp)\t\t       \\\n  (tp)->tp_master->mr_tpac->tpac_address((tp)->tp_master->mr_stack, (tp))\n\n#define TP_STACK   tp_master->mr_stack\n\n/* Define macros for rbtree implementation */\n#define TP_LEFT(tp) ((tp)->tp_left)\n#define TP_RIGHT(tp) ((tp)->tp_right)\n#define TP_PARENT(tp) ((tp)->tp_dad)\n#define TP_SET_RED(tp) ((tp)->tp_black = 0)\n#define TP_SET_BLACK(tp) ((tp)->tp_black = 1)\n#define TP_IS_RED(tp) ((tp) && (tp)->tp_black == 0)\n#define TP_IS_BLACK(tp) (!(tp) || (tp)->tp_black == 1)\n#define TP_COPY_COLOR(dst, src) ((dst)->tp_black = (src)->tp_black)\n#define TP_INSERT(tp) ((void)0)\n#define TP_REMOVE(tp) ((tp)->tp_left = (tp)->tp_right = (tp)->tp_dad = NULL)\n\nsu_inline int tp_cmp(tport_t const *a, tport_t const *b)\n{\n  if (a == b)\n    return 0;\n\n  if (a->tp_addrlen != b->tp_addrlen)\n    return (int)(a->tp_addrlen - b->tp_addrlen);\n\n  return memcmp(a->tp_addr, b->tp_addr, a->tp_addrlen);\n}\n\n#ifdef __clang__\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wunused-function\"\n#endif\n\nRBTREE_PROTOS(su_inline, tprb, tport_t);\n\nRBTREE_BODIES(su_inline, tprb, tport_t,\n\t      TP_LEFT, TP_RIGHT, TP_PARENT,\n\t      TP_IS_RED, TP_SET_RED, TP_IS_BLACK, TP_SET_BLACK, TP_COPY_COLOR,\n\t      tp_cmp, TP_INSERT, TP_REMOVE);\n\n#ifdef __clang__\n#pragma clang diagnostic pop\n#endif\n\nstatic int wssCount = 0;\nstatic int tcpCount = 0;\nvoid incrementSecondaryCount(tport_t* self) {\n  if (self && 0 == strncmp(self->tp_name->tpn_proto, \"ws\", 2)) wssCount++;\n  else if (self && 0 == strcmp(self->tp_name->tpn_proto, \"tcp\")) tcpCount++;\n}\nvoid decrementSecondaryCount(tport_t* self) {\n  if (self && 0 == strncmp(self->tp_name->tpn_proto, \"ws\", 2)) wssCount--;\n  else if (self && 0 == strcmp(self->tp_name->tpn_proto, \"tcp\")) tcpCount--;\n}\n\nstatic void tplist_insert(tport_t **list, tport_t *tp)\n{\n  if (*list == NULL)\n    *list = tp;\n  else\n    tp->tp_right = *list, (*list)->tp_left = tp, *list = tp;\n\n  for (tp = *list; tp; tp = tp->tp_right) {\n    assert(tp->tp_left == NULL || tp == tp->tp_left->tp_right);\n    assert(tp->tp_right == NULL || tp == tp->tp_right->tp_left);\n  }\n}\n\nstatic void tplist_remove(tport_t **list, tport_t *tp)\n{\n  if (*list == tp) {\n    *list = tp->tp_right; assert(tp->tp_left == NULL);\n  }\n  else if (tp->tp_left) {\n    tp->tp_left->tp_right = tp->tp_right;\n  }\n  if (tp->tp_right) {\n    tp->tp_right->tp_left = tp->tp_left;\n  }\n  TP_REMOVE(tp);\n}\n\nenum {\n  /** Default per-thread read queue length */\n  THRP_PENDING = 8\n};\n\nstruct tport_pending_s {\n  /* tport_pending_t       *p_left, *p_right, *p_parent; */\n  void               *p_client;\n  tport_pending_error_f *p_callback;\n  msg_t              *p_msg;\n  unsigned short      p_reported;\n  unsigned short      p_on_success;\n};\n\n/** Return true if transport is master. */\nint tport_is_master(tport_t const *self)\n{\n  return\n    self &&\n    self->tp_master->mr_master == self;\n}\n\n/** Return true if transport is primary. */\nint tport_is_primary(tport_t const *self)\n{\n  return\n    self &&\n    self->tp_pri->pri_primary == self;\n}\n\n/** Return true if transport is secondary. */\nint tport_is_secondary(tport_t const *self)\n{\n  return\n    self &&\n    self->tp_master->mr_master != self &&\n    self->tp_pri->pri_primary != self;\n}\n\n/** Test if transport has been registered to su_root_t */\nint tport_is_registered(tport_t const *self)\n{\n  return self && self->tp_index != 0;\n}\n\n/** Test if transport is stream. */\nint tport_is_stream(tport_t const *self)\n{\n\treturn self && !self->tp_pre_framed && self->tp_addrinfo->ai_socktype == SOCK_STREAM;\n}\n\n/** Test if transport is dgram. */\nint tport_is_dgram(tport_t const *self)\n{\n  return self && self->tp_addrinfo->ai_socktype == SOCK_DGRAM;\n}\n\n/** Test if transport is udp. */\nint tport_is_udp(tport_t const *self)\n{\n  return self && self->tp_addrinfo->ai_protocol == IPPROTO_UDP;\n}\n\n/** Test if transport is tcp. */\nint tport_is_tcp(tport_t const *self)\n{\n  return self && self->tp_addrinfo->ai_protocol == IPPROTO_TCP;\n}\n\n/** Return 1 if transport is reliable, 0 otherwise.\n *\n * (Note that this is part of external API).\n */\nint tport_is_reliable(tport_t const *self)\n{\n  return self != NULL &&\n    (self->tp_addrinfo->ai_socktype == SOCK_STREAM ||\n     self->tp_addrinfo->ai_socktype == SOCK_SEQPACKET);\n}\n\n/** Return 0 if self is local, nonzero otherwise.\n *\n * The return valu is the tport_via enum.\n *\n * @sa TPTAG_PUBLIC(), enum tport_via.\n */\nint tport_is_public(tport_t const *self)\n{\n  return self && self->tp_pri->pri_public;\n}\n\n/** Return true if transport supports IPv4 */\nint tport_has_ip4(tport_t const *self)\n{\n  return self &&\n    (self->tp_addrinfo->ai_family == 0 ||\n     self->tp_addrinfo->ai_family == AF_INET);\n}\n\n\n#if SU_HAVE_IN6\n/** Return true if transport supports IPv6 */\nint tport_has_ip6(tport_t const *self)\n{\n  return self &&\n    (self->tp_addrinfo->ai_family == 0 ||\n     self->tp_addrinfo->ai_family == AF_INET6);\n}\n#endif\n\n/** Return true if transport supports TLS. */\nint tport_has_tls(tport_t const *self)\n{\n  return self && self->tp_pri->pri_has_tls;\n}\n\n/** Return true if transport certificate verified successfully */\nint tport_is_verified(tport_t const *self)\n{\n  return tport_has_tls(self) && self->tp_is_connected && self->tp_verified;\n}\n\n/** Return true if transport is being updated. */\nint tport_is_updating(tport_t const *self)\n{\n  tport_primary_t *pri;\n\n  if (tport_is_master(self)) {\n    for (pri = self->tp_master->mr_primaries; pri; pri = pri->pri_next)\n      if (pri->pri_updating)\n\treturn 1;\n  }\n  else if (tport_is_primary(self)) {\n    return self->tp_pri->pri_updating;\n  }\n\n  return 0;\n}\n\n/** Test if transport has been closed.\n *\n * @since New in @VERSION_1_12_4\n */\ninline int tport_is_closed(tport_t const *self)\n{\n  return self->tp_closed;\n}\n\n/** Test if transport has been shut down.\n *\n * @since New in @VERSION_1_12_4\n */\ninline int tport_is_shutdown(tport_t const *self)\n{\n  return self->tp_closed || self->tp_send_close || self->tp_recv_close;\n}\n\n/** Test if transport connection has been established. @NEW_1_12_5. */\nint tport_is_connected(tport_t const *self)\n{\n  return self->tp_is_connected;\n}\n\n/** Test if transport can be used to send message. @NEW_1_12_7. */\nint tport_is_clear_to_send(tport_t const *self)\n{\n  return\n    tport_is_master(self) ||\n    tport_is_primary(self) ||\n    (tport_is_secondary(self) &&\n     tport_is_registered(self) &&\n     self->tp_reusable &&\n     !self->tp_closed &&\n     !self->tp_send_close);\n}\n\n/** Return true if transport has message in send queue. @NEW_1_12_7. */\nint tport_has_queued(tport_t const *self)\n{\n  return self && self->tp_queue && self->tp_queue[self->tp_qhead];\n}\n\n/** Flush queued messages  */\nint tport_flush_queued(tport_t const *self) \n{\n    /* Zap the queued messages */\n  int num = 0 ;\n  if (tport_has_queued(self)) {\n    unsigned short i, N = self->tp_params->tpp_qsize;\n    for (i = 0; i < N; i++) {\n      if (self->tp_queue[i]) {\n        msg_ref_destroy(self->tp_queue[i]) ; \n        self->tp_queue[i] = NULL;\n        num++;\n      }\n    }\n  }\n  return num;\n}\n\n/** MTU for transport  */\nsu_inline unsigned tport_mtu(tport_t const *self)\n{\n  return self->tp_params->tpp_mtu;\n}\n\n/** Set IP TOS for socket */\nvoid tport_set_tos(su_socket_t socket, su_addrinfo_t *ai, int tos)\n{\n  if (tos >= 0 &&\n      ai->ai_family == AF_INET &&\n      setsockopt(socket, IPPROTO_IP, IP_TOS, (const void*)&tos, sizeof(tos)) < 0) {\n    SU_DEBUG_3((\"tport: setsockopt(IP_TOS): %s\\n\",\n\t\tsu_strerror(su_errno())));\n  }\n}\n\nstatic\ntport_t *tport_connect(tport_primary_t *pri, su_addrinfo_t *ai,\n\t\t       tp_name_t const *tpn);\n\nstatic int bind6only_check(tport_master_t *mr);\n\nstatic\nint tport_server_addrinfo(tport_master_t *mr,\n\t\t\t  char const *canon,\n\t\t\t  int family,\n\t\t\t  char const *host,\n\t\t\t  char const *service,\n\t\t\t  char const *protocol,\n\t\t\t  char const * const transports[],\n\t\t\t  su_addrinfo_t **res);\n\nstatic int tport_get_local_addrinfo(tport_master_t *mr,\n\t\t\t\t    char const *port,\n\t\t\t\t    su_addrinfo_t const *hints,\n\t\t\t\t    su_addrinfo_t **return_ai);\n\nint tport_getaddrinfo(char const *node, char const *service,\n\t\t      su_addrinfo_t const *hints,\n\t\t      su_addrinfo_t **res);\n\nstatic void tport_freeaddrinfo(su_addrinfo_t *ai);\n\nstatic\nint tport_addrinfo_copy(su_addrinfo_t *dst, void *addr, socklen_t addrlen,\n\t\t\tsu_addrinfo_t const *src);\n\nstatic int\n  tport_bind_client(tport_master_t *self, tp_name_t const *tpn,\n\t\t    char const * const transports[], enum tport_via public,\n\t\t    tagi_t *tags),\n  tport_bind_server(tport_master_t *, tp_name_t const *tpn,\n\t\t    char const * const transports[],  enum tport_via public,\n\t\t    tagi_t *tags),\n\n  tport_wakeup_pri(su_root_magic_t *m, su_wait_t *w, tport_t *self),\n  tport_base_wakeup(tport_t *self, int events),\n  tport_connected(su_root_magic_t *m, su_wait_t *w, tport_t *self),\n  tport_resolve(tport_t *self, msg_t *msg, tp_name_t const *tpn),\n  tport_send_error(tport_t *, msg_t *, tp_name_t const *, char const *who),\n  tport_send_fatal(tport_t *, msg_t *, tp_name_t const *, char const *who),\n  tport_queue(tport_t *self, msg_t *msg),\n  tport_queue_rest(tport_t *self, msg_t *msg, msg_iovec_t iov[], size_t iovused),\n  tport_pending_error(tport_t *self, su_sockaddr_t const *dst, int error),\n  tport_pending_errmsg(tport_t *self, msg_t *msg, int error);\n\nstatic ssize_t tport_vsend(tport_t *self, msg_t *msg, tp_name_t const *tpn,\n\t\t\t   msg_iovec_t iov[], size_t iovused,\n\t\t\t   struct sigcomp_compartment *cc);\n\ntport_t *tport_by_addrinfo(tport_primary_t const *pri,\n\t\t\t   su_addrinfo_t const *ai,\n\t\t\t   tp_name_t const *tpn);\n\nvoid tport_peer_address(tport_t *self, msg_t *msg);\n\nstatic void tport_parse(tport_t *self, int complete, su_time_t now);\n\nstatic tport_primary_t *tport_alloc_primary(tport_master_t *mr,\n\t\t\t\t\t    tport_vtable_t const *vtable,\n\t\t\t\t\t    tp_name_t tpn[1],\n\t\t\t\t\t    su_addrinfo_t *ai,\n\t\t\t\t\t    tagi_t const *tags,\n\t\t\t\t\t    char const **return_culprit);\n\nstatic tport_primary_t *tport_listen(tport_master_t *mr,\n\t\t\t\t     tport_vtable_t const *vtable,\n\t\t\t\t     tp_name_t tpn[1],\n\t\t\t\t     su_addrinfo_t *ai,\n\t\t\t\t     tagi_t *tags);\nstatic void tport_zap_primary(tport_primary_t *);\n\nstatic char *localipname(int pf, char *buf, size_t bufsiz);\nstatic int getprotohints(su_addrinfo_t *hints,\n\t\t\t char const *proto, int flags);\n\n\n/* Stack class used when transports are being destroyed */\nstatic\nvoid tport_destroy_recv(tp_stack_t *stack, tport_t *tp,\n\t\t\tmsg_t *msg, tp_magic_t *magic,\n\t\t\tsu_time_t received)\n{\n  msg_destroy(msg);\n}\n\nstatic\nvoid tport_destroy_error(tp_stack_t *stack, tport_t *tp,\n\t\t\t int errcode, char const *remote)\n{\n}\n\nstatic\nmsg_t *tport_destroy_alloc(tp_stack_t *stack, int flags,\n\t\t\t   char const data[], usize_t len,\n\t\t\t   tport_t const *tp,\n\t\t\t   tp_client_t *tpc)\n{\n  return NULL;\n}\n\n/** Name for \"any\" transport. @internal */\nstatic char const tpn_any[] = \"*\";\n\n/** Create the master transport.\n *\n * Master transport object is used to bind the protocol using transport with\n * actual transport objects corresponding to TCP, UDP, etc.\n *\n * @sa tport_tbind()\n *\n * @TAGS\n * TPTAG_LOG(), TPTAG_DUMP(), tags used with tport_set_params(), especially\n * TPTAG_QUEUESIZE().\n */\ntport_t *tport_tcreate(tp_stack_t *stack,\n\t\t       tp_stack_class_t const *tpac,\n\t\t       su_root_t *root,\n\t\t       tag_type_t tag, tag_value_t value, ...)\n{\n  tport_master_t *mr;\n  tp_name_t *tpn;\n  tport_params_t *tpp;\n  ta_list ta;\n\n  if (!stack || !tpac || !root) {\n    su_seterrno(EINVAL);\n    return NULL;\n  }\n\n  mr = su_home_clone(NULL, sizeof *mr);\n  if (!mr)\n    return NULL;\n\n  SU_DEBUG_7((\"%s(): %p\\n\", \"tport_create\", (void *)mr));\n\n  mr->mr_stack = stack;\n  mr->mr_tpac = tpac;\n  mr->mr_root = root;\n\n  mr->mr_master->tp_master = mr;\n  mr->mr_master->tp_params = tpp = mr->mr_params;\n\n  mr->mr_master->tp_reusable = 1;\n  tpp->tpp_mtu = UINT_MAX;\n  tpp->tpp_thrprqsize = THRP_PENDING;\n  tpp->tpp_qsize = TPORT_QUEUESIZE;\n  tpp->tpp_sdwn_error = 1;\n  tpp->tpp_idle = UINT_MAX;\n  tpp->tpp_timeout = UINT_MAX;\n  tpp->tpp_sigcomp_lifetime = UINT_MAX;\n  tpp->tpp_socket_keepalive = 30;\n  tpp->tpp_keepalive = 0;\n  tpp->tpp_pingpong = 0;\n  tpp->tpp_pong2ping = 0;\n  tpp->tpp_stun_server = 1;\n  tpp->tpp_tos = -1;                  /* set invalid, valid values are 0-255 */\n\n  tpn = mr->mr_master->tp_name;\n  tpn->tpn_proto = \"*\";\n  tpn->tpn_host = \"*\";\n  tpn->tpn_canon = \"*\";\n  tpn->tpn_port = \"*\";\n\n  ta_start(ta, tag, value);\n\n  tport_set_params(mr->mr_master, ta_tags(ta));\n\n#if HAVE_SOFIA_STUN\n  tport_init_stun_server(mr, ta_args(ta));\n#endif\n\n  ta_end(ta);\n\n  return mr->mr_master;\n}\n\n/** Destroy the master transport. */\nvoid tport_destroy(tport_t *self)\n{\n  tport_master_t *mr;\n\n  static tp_stack_class_t tport_destroy_tpac[1] =\n    {{\n\tsizeof tport_destroy_tpac,\n\t/* tpac_recv */ tport_destroy_recv,\n\t/* tpac_error */ tport_destroy_error,\n\t/* tpac_alloc */ tport_destroy_alloc,\n\t/* tpac_address */ NULL\n      }};\n\n  SU_DEBUG_7((\"%s(%p)\\n\", __func__, (void *)self));\n\n  if (self == NULL)\n    return;\n\n  assert(tport_is_master(self));\n  if (!tport_is_master(self))\n    return;\n\n  mr = (tport_master_t *)self;\n  mr->mr_tpac = tport_destroy_tpac;\n\n  while (mr->mr_primaries)\n    tport_zap_primary(mr->mr_primaries);\n\n#if HAVE_SOFIA_STUN\n  tport_deinit_stun_server(mr);\n#endif\n\n  if (mr->mr_dump_file)\n    fclose(mr->mr_dump_file), mr->mr_dump_file = NULL;\n\n  if (mr->mr_timer)\n    su_timer_destroy(mr->mr_timer), mr->mr_timer = NULL;\n\n  su_home_zap(mr->mr_home);\n}\n\n\n/** Allocate a primary transport */\nstatic\ntport_primary_t *tport_alloc_primary(tport_master_t *mr,\n\t\t\t\t     tport_vtable_t const *vtable,\n\t\t\t\t     tp_name_t tpn[1],\n\t\t\t\t     su_addrinfo_t *ai,\n\t\t\t\t     tagi_t const *tags,\n\t\t\t\t     char const **return_culprit)\n{\n  tport_primary_t *pri, **next;\n  tport_t *tp;\n  int save_errno;\n\n  for (next = &mr->mr_primaries; *next; next = &(*next)->pri_next)\n    ;\n\n  assert(vtable->vtp_pri_size >= sizeof *pri);\n\n  if ((pri = su_home_clone(mr->mr_home, vtable->vtp_pri_size))) {\n    tport_t *tp = pri->pri_primary;\n    pri->pri_vtable = vtable;\n    pri->pri_public = vtable->vtp_public;\n\n    tp->tp_master = mr;\n    tp->tp_pri = pri;\n    tp->tp_socket = INVALID_SOCKET;\n\n    tp->tp_magic = mr->mr_master->tp_magic;\n\n    tp->tp_params = pri->pri_params;\n    memcpy(tp->tp_params, mr->mr_params, sizeof (*tp->tp_params));\n    tp->tp_reusable = mr->mr_master->tp_reusable;\n\n    if (!pri->pri_public)\n      tp->tp_addrinfo->ai_addr = &tp->tp_addr->su_sa;\n\n    SU_DEBUG_5((\"%s(%p): new primary tport %p\\n\", __func__, (void *)mr,\n\t\t(void *)pri));\n  }\n\n  *next = pri;\n  tp = pri->pri_primary;\n\n  if (!tp)\n    *return_culprit = \"alloc\";\n  else if (tport_set_params(tp, TAG_NEXT(tags)) < 0)\n    *return_culprit = \"tport_set_params\";\n  else if (vtable->vtp_init_primary &&\n\t   vtable->vtp_init_primary(pri, tpn, ai, tags, return_culprit) < 0)\n    ;\n  else if (tport_setname(tp, vtable->vtp_name, ai, tpn->tpn_canon) == -1)\n    *return_culprit = \"tport_setname\";\n  else if (tpn->tpn_ident &&\n\t   !(tp->tp_name->tpn_ident = su_strdup(tp->tp_home, tpn->tpn_ident)))\n    *return_culprit = \"alloc ident\";\n  else\n    return pri;\t\t\t/* Success */\n\n  save_errno = su_errno();\n  tport_zap_primary(pri);\n  su_seterrno(save_errno);\n\n  return NULL;\n}\n\n\n/** Destroy a primary transport and its secondary transports. @internal */\nstatic\nvoid tport_zap_primary(tport_primary_t *pri)\n{\n  tport_primary_t **prip;\n\n  if (pri == NULL)\n    return;\n\n  assert(tport_is_primary(pri->pri_primary));\n\n  if (pri->pri_vtable->vtp_deinit_primary)\n    pri->pri_vtable->vtp_deinit_primary(pri);\n\n  while (pri->pri_open)\n    tport_zap_secondary(pri->pri_open);\n  while (pri->pri_closed)\n    tport_zap_secondary(pri->pri_closed);\n\n  /* We have just a single-linked list for primary transports */\n  for (prip = &pri->pri_master->mr_primaries;\n       *prip != pri;\n       prip = &(*prip)->pri_next)\n    assert(*prip);\n\n  *prip = pri->pri_next;\n\n  tport_zap_secondary((tport_t *)pri);\n}\n\n/**Create a primary transport object with socket.\n *\n * Creates a primary transport object with a server socket, and then\n * registers the socket with suitable events to the root.\n *\n * @param dad   parent (master or primary) transport object\n * @param ai    pointer to addrinfo structure\n * @param canon canonical name of node\n * @param protoname name of the protocol\n */\nstatic\ntport_primary_t *tport_listen(tport_master_t *mr,\n\t\t\t      tport_vtable_t const *vtable,\n\t\t\t      tp_name_t tpn[1],\n\t\t\t      su_addrinfo_t *ai,\n\t\t\t      tagi_t *tags)\n{\n  tport_primary_t *pri = NULL;\n\n  int err;\n  int errlevel = 3;\n  char buf[TPORT_HOSTPORTSIZE];\n\n  char const *protoname = vtable->vtp_name;\n  char const *culprit = \"unknown\";\n\n  su_sockaddr_t *su = (void *)ai->ai_addr;\n\n  /* Log an error, return error */\n#define TPORT_LISTEN_ERROR(errno, what)\t\t\t\t     \\\n  ((void)(err = errno,\t\t\t\t\t\t     \\\n\t  ((err == EADDRINUSE || err == EAFNOSUPPORT ||\t\t     \\\n\t    err == ESOCKTNOSUPPORT || err == EPROTONOSUPPORT ||\t     \\\n\t    err == ENOPROTOOPT ? 7 : 3) < SU_LOG_LEVEL ?\t     \\\n\t     su_llog(tport_log, errlevel,\t\t\t     \\\n\t\t     \"%s(%p): %s(pf=%d %s/%s): %s\\n\",\t\t     \\\n\t\t     __func__, pri ? (void *)pri : (void *)mr, what, \\\n\t\t     ai->ai_family, protoname,\t\t\t     \\\n\t\t     tport_hostport(buf, sizeof(buf), su, 2),\t     \\\n\t\t     su_strerror(err)) : (void)0),\t\t     \\\n\t    tport_zap_primary(pri),\t\t                     \\\n\t    su_seterrno(err)),\t\t\t\t\t     \\\n     (void *)NULL)\n\n  /* Create a primary transport object for another transport. */\n  pri = tport_alloc_primary(mr, vtable, tpn, ai, tags, &culprit);\n  if (pri == NULL)\n    return TPORT_LISTEN_ERROR(su_errno(), culprit);\n\n  if (pri->pri_primary->tp_socket != INVALID_SOCKET) {\n    int index = 0;\n    tport_t *tp = pri->pri_primary;\n    su_wait_t wait[1] = { SU_WAIT_INIT };\n\n    if (su_wait_create(wait, tp->tp_socket, tp->tp_events) == -1)\n      return TPORT_LISTEN_ERROR(su_errno(), \"su_wait_create\");\n\n    /* Register receiving or accepting function with events specified above */\n    index = su_root_register(mr->mr_root, wait, tport_wakeup_pri, tp, 0);\n    if (index == -1) {\n      su_wait_destroy(wait);\n      return TPORT_LISTEN_ERROR(su_errno(), \"su_root_register\");\n    }\n\n    tp->tp_index = index;\n  }\n\n  pri->pri_primary->tp_has_connection = 0;\n\n  SU_DEBUG_5((\"%s(%p): %s \" TPN_FORMAT \"\\n\",\n\t      __func__, (void *)pri, \"listening at\",\n\t      TPN_ARGS(pri->pri_primary->tp_name)));\n\n  return pri;\n}\n\nint tport_bind_socket(int socket,\n\t\t      su_addrinfo_t *ai,\n\t\t      char const **return_culprit)\n{\n  su_sockaddr_t *su = (su_sockaddr_t *)ai->ai_addr;\n  socklen_t sulen = (socklen_t)(ai->ai_addrlen);\n\n  if (bind(socket, ai->ai_addr, sulen) == -1) {\n    return *return_culprit = \"bind\", -1;\n  }\n\n  if (getsockname(socket, &su->su_sa, &sulen) == SOCKET_ERROR) {\n    return *return_culprit = \"getsockname\", -1;\n  }\n\n  ai->ai_addrlen = sulen;\n\n#if defined (__linux__) && defined (SU_HAVE_IN6)\n  if (ai->ai_family == AF_INET6) {\n    if (!SU_SOCKADDR_INADDR_ANY(su) &&\n\t(IN6_IS_ADDR_V4MAPPED(&su->su_sin6.sin6_addr) ||\n\t IN6_IS_ADDR_V4COMPAT(&su->su_sin6.sin6_addr))) {\n      su_sockaddr_t su0[1];\n\n      memcpy(su0, su, sizeof su0);\n\n      memset(su, 0, ai->ai_addrlen = sizeof su->su_sin);\n      su->su_family = ai->ai_family = AF_INET;\n      su->su_port = su0->su_port;\n\n#ifndef IN6_V4MAPPED_TO_INADDR\n#define IN6_V4MAPPED_TO_INADDR(in6, in4) \\\n      memcpy((in4), 12 + (uint8_t *)(in6), sizeof(struct in_addr))\n#endif\n      IN6_V4MAPPED_TO_INADDR(&su0->su_sin6.sin6_addr, &su->su_sin.sin_addr);\n    }\n  }\n#endif\n\n  return 0;\n}\n\n\n/** Indicate stack that a transport has been updated */\nvoid tport_has_been_updated(tport_t *self)\n{\n  self->tp_pri->pri_updating = 0;\n\n  if (self->tp_master->mr_tpac->tpac_address)\n    self->tp_master->mr_tpac->tpac_address(self->tp_master->mr_stack, self);\n}\n\n\nstatic\nint tport_set_events(tport_t *self, int set, int clear)\n{\n  int events;\n\n  if (self == NULL)\n    return -1;\n\n  events = (self->tp_events | set) & ~clear;\n  self->tp_events = events;\n\n  if (self->tp_pri->pri_vtable->vtp_set_events)\n    return self->tp_pri->pri_vtable->vtp_set_events(self);\n\n  SU_DEBUG_7((\"tport_set_events(%p): events%s%s%s\\n\", (void *)self,\n\t      (events & SU_WAIT_IN) ? \" IN\" : \"\",\n\t      (events & SU_WAIT_OUT) ? \" OUT\" : \"\",\n\t      SU_WAIT_CONNECT != SU_WAIT_OUT &&\n\t      (events & SU_WAIT_CONNECT) ? \" CONNECT\" : \"\"));\n\n  return\n    su_root_eventmask(self->tp_master->mr_root,\n\t\t      self->tp_index,\n\t\t      self->tp_socket,\n\t\t      self->tp_events = events);\n}\n\n/**Allocate a secondary transport. @internal\n *\n * Create a secondary transport object. The new transport initally shares\n * parameters structure with the original transport.\n *\n * @param pri    primary transport\n * @param socket socket for transport\n * @parma accepted true if the socket was accepted from server socket\n *\n * @return\n * Pointer to the newly created transport, or NULL upon an error.\n *\n * @note The socket is always closed upon error.\n */\ntport_t *tport_alloc_secondary(tport_primary_t *pri,\n\t\t\t       int socket,\n\t\t\t       int accepted,\n\t\t\t       char const **return_reason)\n{\n  tport_master_t *mr = pri->pri_master;\n  tport_t *self;\n\n  self = su_home_clone(mr->mr_home, pri->pri_vtable->vtp_secondary_size);\n\n  if (self) {\n    self->tp_refs = -1;\t\t\t/* Freshly allocated  */\n    self->tp_master = mr;\n    self->tp_pri = pri;\n    self->tp_params = pri->pri_params;\n    self->tp_accepted = accepted != 0;\n    self->tp_reusable = pri->pri_primary->tp_reusable;\n\n    self->tp_magic = pri->pri_primary->tp_magic;\n\n    self->tp_addrinfo->ai_addr = (void *)self->tp_addr;\n\n    self->tp_socket = socket;\n\n    self->tp_timer = su_timer_create(su_root_task(mr->mr_root), 0);\n    self->tp_stime = self->tp_ktime = self->tp_rtime = su_now();\n\n    if (pri->pri_vtable->vtp_init_secondary &&\n\n\t\tpri->pri_vtable->vtp_init_secondary(self, socket, accepted, return_reason) < 0) {\n      if (pri->pri_vtable->vtp_deinit_secondary) {\n        pri->pri_vtable->vtp_deinit_secondary(self);\n      }\n      su_timer_destroy(self->tp_timer);\n      su_home_zap(self->tp_home);\n\n      return NULL;\n    }\n\n    /* Set IP TOS if it is set in primary */\n    tport_set_tos(socket,\n\t\t  pri->pri_primary->tp_addrinfo,\n\t\t  pri->pri_params->tpp_tos);\n  }\n  else {\n    *return_reason = \"malloc\";\n  }\n  return self;\n}\n\n\n/** Create a connected transport object with socket.\n *\n * The function tport_connect() creates a secondary transport with a\n * connected socket. It registers the socket with suitable events to the\n * root.\n *\n * @param pri   primary transport object\n * @param ai    pointer to addrinfo structure\n * @param tpn   canonical name of node\n */\nstatic\ntport_t *tport_connect(tport_primary_t *pri,\n\t\t       su_addrinfo_t *ai,\n\t\t       tp_name_t const *tpn)\n{\n  tport_t *tp;\n\n  if (ai == NULL || ai->ai_addrlen > sizeof (pri->pri_primary->tp_addr))\n    return NULL;\n\n  if (pri->pri_vtable->vtp_connect)\n    return pri->pri_vtable->vtp_connect(pri, ai, tpn);\n\n  tp = tport_base_connect(pri, ai, ai, tpn);\n  if (tp)\n    tport_set_secondary_timer(tp);\n  return tp;\n}\n\n/**Create a connected transport object with socket.\n *\n * The function tport_connect() creates a secondary transport with a\n * connected socket. It registers the socket with suitable events to the\n * root.\n *\n * @param pri   primary transport object\n * @param ai    pointer to addrinfo structure describing socket\n * @param real_ai  pointer to addrinfo structure describing real target\n * @param tpn   canonical name of node\n */\ntport_t *tport_base_connect(tport_primary_t *pri,\n\t\t\t    su_addrinfo_t *ai,\n\t\t\t    su_addrinfo_t *real_ai,\n\t\t\t    tp_name_t const *tpn)\n{\n  tport_t *self = NULL;\n\n  su_socket_t s, server_socket;\n  su_wakeup_f wakeup = tport_wakeup;\n  int events = SU_WAIT_IN | SU_WAIT_ERR;\n\n  int err;\n  unsigned errlevel = 3;\n  char buf[TPORT_HOSTPORTSIZE];\n  char const *what;\n\n  /* Log an error, return error */\n#define TPORT_CONNECT_ERROR(errno, what)\t\t\t     \\\n  return\t\t\t\t\t\t\t     \\\n    ((void)(err = errno,\t\t\t\t\t     \\\n\t    (SU_LOG_LEVEL >= errlevel ?\t\t\t\t     \\\n\t     su_llog(tport_log, errlevel,\t\t\t     \\\n\t\t     \"%s(%p): %s(pf=%d %s/%s): %s\\n\",\t\t\t\\\n\t\t\t\t __func__, (void *)pri, #what, ai->ai_family,\t\\\n\t\t     tpn->tpn_proto,\t\t\t\t     \\\n\t\t     tport_hostport(buf, sizeof(buf),\t\t     \\\n\t\t\t\t    (void *)ai->ai_addr, 2),\t     \\\n\t\t     su_strerror(err)) : (void)0),\t\t     \\\n\t    tport_zap_secondary(self),\t\t\t\t     \\\n\t    su_seterrno(err)),\t\t\t\t\t     \\\n     (void *)NULL)\n\n  s = su_socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);\n  if (s == INVALID_SOCKET)\n    TPORT_CONNECT_ERROR(su_errno(), \"socket\");\n\n  what = \"tport_alloc_secondary\";\n  if ((self = tport_alloc_secondary(pri, s, 0, &what)) == NULL)\n    TPORT_CONNECT_ERROR(su_errno(), what);\n\n  self->tp_conn_orient = 1;\n\n  if ((server_socket = pri->pri_primary->tp_socket) != INVALID_SOCKET) {\n    su_sockaddr_t susa;\n    socklen_t susalen = sizeof(susa);\n\n    /* Bind this socket to same IP address as the primary server socket */\n    if (getsockname(server_socket, &susa.su_sa, &susalen) < 0) {\n      SU_DEBUG_3((\"%s(%p): getsockname(): %s\\n\",\n\t\t  __func__, (void *)self, su_strerror(su_errno())));\n    }\n    else {\n      susa.su_port = 0;\n      if (bind(s, &susa.su_sa, susalen) < 0) {\n\tSU_DEBUG_3((\"%s(%p): bind(local-ip): %s\\n\",\n\t\t    __func__, (void *)self, su_strerror(su_errno())));\n      }\n    }\n  }\n\n  /* Set sockname for the tport */\n  if (tport_setname(self, tpn->tpn_proto, real_ai, tpn->tpn_canon) == -1)\n    TPORT_CONNECT_ERROR(su_errno(), tport_setname);\n\n  /* Try to have a non-blocking connect().\n   * The tport_register_secondary() below makes the socket non-blocking anyway. */\n  su_setblocking(s, 0);\n\n  if (connect(s, ai->ai_addr, (socklen_t)(ai->ai_addrlen)) == SOCKET_ERROR) {\n    err = su_errno();\n    if (!su_is_blocking(err))\n      TPORT_CONNECT_ERROR(err, connect);\n    events = SU_WAIT_CONNECT | SU_WAIT_ERR;\n    wakeup = tport_connected;\n    what = \"connecting\";\n  }\n  else {\n    what = \"connected\";\n    self->tp_is_connected = 1;\n  }\n\n  if (tport_register_secondary(self, wakeup, events) == -1)\n    TPORT_CONNECT_ERROR(su_errno(), tport_register_secondary);\n\n  if (ai == real_ai) {\n    SU_DEBUG_5((\"%s(%p): %s to \" TPN_FORMAT \"\\n\",\n\t\t__func__, (void *)self, what, TPN_ARGS(self->tp_name)));\n  }\n  else {\n    SU_DEBUG_5((\"%s(%p): %s via %s to \" TPN_FORMAT \"\\n\",\n\t\t__func__, (void *)self, what,\n\t\ttport_hostport(buf, sizeof(buf), (void *)ai->ai_addr, 2),\n\t\tTPN_ARGS(self->tp_name)));\n  }\n\n  return self;\n}\n\n/** Register a new secondary transport. @internal */\nint tport_register_secondary(tport_t *self, su_wakeup_f wakeup, int events)\n{\n  int i;\n  su_root_t *root = tport_is_secondary(self) ? self->tp_master->mr_root : NULL;\n  su_wait_t wait[1] = { SU_WAIT_INIT };\n\n  if (root != NULL\n      /* Create wait object with appropriate events. */\n      &&\n      su_wait_create(wait, self->tp_socket, events) != -1\n      /* Register socket to root */\n      &&\n      (i = su_root_register(root, wait, wakeup, self, 0)) != -1) {\n\n    self->tp_index = i;\n    self->tp_events = events;\n\n    tprb_append(&self->tp_pri->pri_open, self);\n\n    SU_DEBUG_4((\"%s(%p): register secondary tport %p from \" TPN_FORMAT \", count(wss) is %d, count(tcp) is %d\\n\", \n      __func__, (void *)self->tp_pri, (void *)self, TPN_ARGS(self->tp_name), wssCount, tcpCount));\n\n    return 0;\n  }\n\n  su_wait_destroy(wait);\n  return -1;\n}\n\n/** Destroy a secondary transport. @internal */\nvoid tport_zap_secondary(tport_t *self)\n{\n  tport_master_t *mr;\n\n  if (self == NULL)\n    return;\n\n  /* Remove from rbtree */\n  if (!tport_is_closed(self))\n    tprb_remove(&self->tp_pri->pri_open, self);\n  else\n    tplist_remove(&self->tp_pri->pri_closed, self);\n\n  if (self->tp_timer)\n    su_timer_destroy(self->tp_timer), self->tp_timer = NULL;\n\n  /* Do not deinit primary as secondary! */\n  if (tport_is_secondary(self) && self->tp_pri->pri_vtable->vtp_deinit_secondary) {\n    self->tp_pri->pri_vtable->vtp_deinit_secondary(self);\n  }\n\n  if (self->tp_msg) {\n    msg_destroy(self->tp_msg), self->tp_msg = NULL;\n    SU_DEBUG_3((\"%s(%p): zapped partially received message\\n\",\n\t\t__func__, (void *)self));\n  }\n\n  if (tport_has_queued(self)) {\n    size_t n = 0, i, N = self->tp_params->tpp_qsize;\n    for (i = self->tp_qhead; self->tp_queue[i]; i = (i + 1) % N) {\n      msg_destroy(self->tp_queue[i]), self->tp_queue[i] = NULL;\n      n++;\n    }\n    SU_DEBUG_3((\"%s(%p): zapped %lu queued messages\\n\",\n\t\t__func__, (void *)self, (LU)n));\n  }\n\n  if (self->tp_pused) {\n    SU_DEBUG_3((\"%s(%p): zapped while pending\\n\",\n\t\t__func__, (void *)self));\n  }\n\n  mr = self->tp_master;\n\n#if HAVE_SOFIA_STUN\n  tport_stun_server_remove_socket(self);\n#endif\n\n  if (self->tp_index)\n    su_root_deregister(mr->mr_root, self->tp_index);\n  self->tp_index = 0;\n  if (self->tp_socket != INVALID_SOCKET)\n    su_close(self->tp_socket);\n  self->tp_socket = INVALID_SOCKET;\n\n  decrementSecondaryCount(self);\n  SU_DEBUG_4((\"%s(%p): zap tport %p from \" TPN_FORMAT \", count(wss) is %d, count(tcp) is %d\\n\", \n    __func__, (void *)self->tp_pri, (void *)self, TPN_ARGS(self->tp_name), wssCount, tcpCount));\n\n  su_home_zap(self->tp_home);\n}\n\n/** Create a new reference to a transport object. */\ntport_t *tport_ref(tport_t *tp)\n{\n  if (tp) {\n    if (tp->tp_refs >= 0) {\n      tp->tp_refs++;\n    }\n    else if (tp->tp_refs == -1) {\n      tp->tp_refs = 1;\n    }\n    SU_DEBUG_9((\"%s(%p): refcount is now %ld\\n\", __func__, (void *)tp, tp->tp_refs));\n\n  }\n  return tp;\n}\n\n/** Destroy reference to a transport object. */\nvoid tport_unref(tport_t *tp)\n{\n  if (tp == NULL || tp->tp_refs <= 0)\n    return;\n\n  tp->tp_refs--;\n  if (tp->tp_refs <= 1) {\n    SU_DEBUG_5((\"%s(%p): \" TPN_FORMAT \" refcount from is now %ld\\n\", \n    __func__, (void *)tp, TPN_ARGS(tp->tp_name), tp->tp_refs));\n  }\n  else SU_DEBUG_9((\"%s(%p): refcount is now %ld\\n\", __func__, (void *)tp, tp->tp_refs));\n\n  if (tp->tp_refs > 0)\n    return;\n\n  if (!tport_is_secondary(tp))\n    return;\n\n  if (tp->tp_params->tpp_idle == 0) {\n    SU_DEBUG_4((\"%s(%p): \" TPN_FORMAT \" refcount is 0 and its idle, so we can close it\\n\", \n      __func__, (void *)tp, TPN_ARGS(tp->tp_name)));\n    tport_close(tp);\n  }\n\n  tport_set_secondary_timer(tp);\n}\n\n/** Create a new reference to transport object. */\ntport_t *tport_incref(tport_t *tp)\n{\n  return tport_ref(tp);\n}\n\n/** Destroy a transport reference. */\nvoid tport_decref(tport_t **ttp)\n{\n  assert(ttp);\n\n  if (*ttp) {\n    tport_unref(*ttp);\n    *ttp = NULL;\n  }\n}\n\n/** Get transport parameters.\n *\n * @param self          pointer to a transport object\n * @param tag,value,... list of tags\n *\n * @TAGS\n * TPTAG_MTU_REF(), TPTAG_QUEUESIZE_REF(), TPTAG_IDLE_REF(),\n * TPTAG_TIMEOUT_REF(), TPTAG_KEEPALIVE_REF(), TPTAG_PINGPONG_REF(),\n * TPTAG_PONG2PING_REF(), TPTAG_DEBUG_DROP_REF(), TPTAG_THRPSIZE_REF(),\n * TPTAG_THRPRQSIZE_REF(), TPTAG_SIGCOMP_LIFETIME_REF(),\n * TPTAG_CONNECT_REF(), TPTAG_SDWN_ERROR_REF(), TPTAG_REUSE_REF(),\n * TPTAG_STUN_SERVER_REF(), TPTAG_PUBLIC_REF() and TPTAG_TOS_REF().\n */\nint tport_get_params(tport_t const *self,\n\t\t     tag_type_t tag, tag_value_t value, ...)\n{\n  ta_list ta;\n  int n;\n  tport_params_t const *tpp;\n  int connect;\n  tport_master_t *mr = self->tp_master;\n\n  if (self == NULL)\n    return su_seterrno(EINVAL);\n\n  tpp = self->tp_params;\n  ta_start(ta, tag, value);\n\n  connect = tpp->tpp_conn_orient\n    /* Only dgram primary is *not* connection-oriented */\n    || !tport_is_primary(self) || !tport_is_dgram(self);\n\n  n = tl_tgets(ta_args(ta),\n\t       TPTAG_MTU((usize_t)tpp->tpp_mtu),\n\t       TPTAG_REUSE(self->tp_reusable),\n\t       TPTAG_CONNECT(connect),\n\t       TPTAG_QUEUESIZE(tpp->tpp_qsize),\n\t       TPTAG_IDLE(tpp->tpp_idle),\n\t       TPTAG_TIMEOUT(tpp->tpp_timeout),\n\t       TPTAG_SOCKET_KEEPALIVE(tpp->tpp_socket_keepalive),\n\t       TPTAG_KEEPALIVE(tpp->tpp_keepalive),\n\t       TPTAG_PINGPONG(tpp->tpp_pingpong),\n\t       TPTAG_PONG2PING(tpp->tpp_pong2ping),\n\t       TPTAG_SDWN_ERROR(tpp->tpp_sdwn_error),\n\t       TPTAG_DEBUG_DROP(tpp->tpp_drop),\n\t       TPTAG_THRPSIZE(tpp->tpp_thrpsize),\n\t       TPTAG_THRPRQSIZE(tpp->tpp_thrprqsize),\n\t       TPTAG_SIGCOMP_LIFETIME(tpp->tpp_sigcomp_lifetime),\n\t       TPTAG_STUN_SERVER(tpp->tpp_stun_server),\n\t       TAG_IF(self->tp_pri,\n\t\t      TPTAG_PUBLIC(self->tp_pri ?\n\t\t\t\t   self->tp_pri->pri_public : 0)),\n\t       TPTAG_TOS(tpp->tpp_tos),\n\t       TAG_IF((void *)self == (void *)mr,\n\t\t      TPTAG_LOG(mr->mr_log != 0)),\n\t       TAG_IF((void *)self == (void *)mr,\n\t\t      TPTAG_DUMP(mr->mr_dump)),\n\t       TAG_END());\n\n  ta_end(ta);\n\n  return n;\n}\n\n/** Set transport parameters.\n *\n * @param self          pointer to a transport object\n * @param tag,value,... list of tags\n *\n * @TAGS\n * TPTAG_MTU(), TPTAG_QUEUESIZE(), TPTAG_IDLE(), TPTAG_TIMEOUT(),\n * TPTAG_KEEPALIVE(), TPTAG_PINGPONG(), TPTAG_PONG2PING(),\n * TPTAG_DEBUG_DROP(), TPTAG_THRPSIZE(), TPTAG_THRPRQSIZE(),\n * TPTAG_SIGCOMP_LIFETIME(), TPTAG_CONNECT(), TPTAG_SDWN_ERROR(),\n * TPTAG_REUSE(), TPTAG_STUN_SERVER(), and TPTAG_TOS().\n */\nint tport_set_params(tport_t *self,\n\t\t     tag_type_t tag, tag_value_t value, ...)\n{\n  ta_list ta;\n  int n, m = 0;\n  tport_params_t tpp[1], *tpp0;\n\n  usize_t mtu;\n  int connect, sdwn_error, reusable, stun_server, pong2ping;\n\n  if (self == NULL)\n    return su_seterrno(EINVAL);\n\n  memcpy(tpp, tpp0 = self->tp_params, sizeof tpp);\n\n  mtu = tpp->tpp_mtu;\n  connect = tpp->tpp_conn_orient;\n  sdwn_error = tpp->tpp_sdwn_error;\n  reusable = self->tp_reusable;\n  stun_server = tpp->tpp_stun_server;\n  pong2ping = tpp->tpp_pong2ping;\n\n  ta_start(ta, tag, value);\n\n  n = tl_gets(ta_args(ta),\n\t      TPTAG_MTU_REF(mtu),\n\t      TAG_IF(!self->tp_queue, TPTAG_QUEUESIZE_REF(tpp->tpp_qsize)),\n\t      TPTAG_IDLE_REF(tpp->tpp_idle),\n\t      TPTAG_TIMEOUT_REF(tpp->tpp_timeout),\n\t      TPTAG_SOCKET_KEEPALIVE_REF(tpp->tpp_socket_keepalive),\n\t      TPTAG_KEEPALIVE_REF(tpp->tpp_keepalive),\n\t      TPTAG_PINGPONG_REF(tpp->tpp_pingpong),\n\t      TPTAG_PONG2PING_REF(pong2ping),\n\t      TPTAG_DEBUG_DROP_REF(tpp->tpp_drop),\n\t      TPTAG_THRPSIZE_REF(tpp->tpp_thrpsize),\n\t      TPTAG_THRPRQSIZE_REF(tpp->tpp_thrprqsize),\n\t      TPTAG_SIGCOMP_LIFETIME_REF(tpp->tpp_sigcomp_lifetime),\n\t      TPTAG_CONNECT_REF(connect),\n\t      TPTAG_SDWN_ERROR_REF(sdwn_error),\n\t      TPTAG_REUSE_REF(reusable),\n\t      TPTAG_STUN_SERVER_REF(stun_server),\n\t      TPTAG_TOS_REF(tpp->tpp_tos),\n\t      TAG_END());\n\n  if (self == (tport_t *)self->tp_master)\n    m = tport_open_log(self->tp_master, ta_args(ta));\n\n  ta_end(ta);\n\n  if (n == 0)\n    return m;\n\n  if (tpp->tpp_idle > 0 && tpp->tpp_idle < 100)\n    tpp->tpp_idle = 100;\n  if (tpp->tpp_timeout < 100)\n    tpp->tpp_timeout = 100;\n  if (tpp->tpp_drop > 1000)\n    tpp->tpp_drop = 1000;\n  if (tpp->tpp_thrprqsize > 0)\n    tpp->tpp_thrprqsize = tpp0->tpp_thrprqsize;\n  if (tpp->tpp_sigcomp_lifetime != 0 && tpp->tpp_sigcomp_lifetime < 30)\n    tpp->tpp_sigcomp_lifetime = 30;\n  if (tpp->tpp_qsize >= 1000)\n    tpp->tpp_qsize = 1000;\n\n  if (mtu > UINT_MAX)\n    mtu = UINT_MAX;\n  tpp->tpp_mtu = (unsigned)mtu;\n  /* Currently only primary UDP transport can *not* be connection oriented */\n  tpp->tpp_conn_orient = connect;\n  tpp->tpp_sdwn_error = sdwn_error;\n  self->tp_reusable = reusable;\n  tpp->tpp_stun_server = stun_server;\n  tpp->tpp_pong2ping = pong2ping;\n\n  if (memcmp(tpp0, tpp, sizeof tpp) == 0)\n    return n + m;\n\n  if (tport_is_secondary(self) &&\n      self->tp_params == self->tp_pri->pri_primary->tp_params) {\n    tpp0 = su_zalloc(self->tp_home, sizeof *tpp0); if (!tpp0) return -1;\n    self->tp_params = tpp0;\n  }\n\n  memcpy(tpp0, tpp, sizeof tpp);\n\n  if (tport_is_secondary(self))\n    tport_set_secondary_timer(self);\n\n  return n + m;\n}\n\nextern tport_vtable_t const tport_udp_vtable;\nextern tport_vtable_t const tport_tcp_vtable;\nextern tport_vtable_t const tport_tls_vtable;\nextern tport_vtable_t const tport_ws_vtable;\nextern tport_vtable_t const tport_wss_vtable;\nextern tport_vtable_t const tport_sctp_vtable;\nextern tport_vtable_t const tport_udp_client_vtable;\nextern tport_vtable_t const tport_tcp_client_vtable;\nextern tport_vtable_t const tport_sctp_client_vtable;\nextern tport_vtable_t const tport_ws_client_vtable;\nextern tport_vtable_t const tport_wss_client_vtable;\nextern tport_vtable_t const tport_tls_client_vtable;\nextern tport_vtable_t const tport_http_connect_vtable;\nextern tport_vtable_t const tport_threadpool_vtable;\n\n#define TPORT_NUMBER_OF_TYPES 64\n\ntport_vtable_t const *tport_vtables[TPORT_NUMBER_OF_TYPES + 1] =\n{\n#if HAVE_SOFIA_NTH\n  &tport_http_connect_vtable,\n  &tport_ws_client_vtable,\n  &tport_ws_vtable,\n  &tport_wss_client_vtable,\n  &tport_wss_vtable,\n#endif\n#if HAVE_TLS\n  &tport_tls_client_vtable,\n  &tport_tls_vtable,\n#endif\n#if HAVE_SCTP\t\t/* SCTP is broken */\n  &tport_sctp_client_vtable,\n  &tport_sctp_vtable,\n#endif\n  &tport_tcp_client_vtable,\n  &tport_tcp_vtable,\n  &tport_udp_client_vtable,\n  &tport_udp_vtable,\n#if 0\n  &tport_threadpool_vtable,\n#endif\n#if HAVE_SOFIA_STUN\n  &tport_stun_vtable,\n#endif\n};\n\n/** Register new transport vtable */\nint tport_register_type(tport_vtable_t const *vtp)\n{\n  int i;\n\n  for (i = TPORT_NUMBER_OF_TYPES; i >= 0; i--) {\n    if (tport_vtables[i] == NULL) {\n      tport_vtables[i] = vtp;\n      return 0;\n    }\n  }\n\n  su_seterrno(ENOMEM);\n  return -1;\n}\n\n/**Get a vtable for given protocol */\ntport_vtable_t const *tport_vtable_by_name(char const *protoname,\n\t\t\t\t\t   enum tport_via public)\n{\n  int i;\n\n  for (i = TPORT_NUMBER_OF_TYPES; i >= 0; i--) {\n    tport_vtable_t const *vtable = tport_vtables[i];\n\n    if (vtable == NULL)\n      continue;\n    if (vtable->vtp_public != public)\n      continue;\n    if (!su_casematch(protoname, vtable->vtp_name))\n      continue;\n\n    assert(vtable->vtp_pri_size >= sizeof (tport_primary_t));\n    assert(vtable->vtp_secondary_size >= sizeof (tport_t));\n\n    return vtable;\n  }\n\n  return NULL;\n}\n\n#if 0\ntport_set_f const *tport_set_methods[TPORT_NUMBER_OF_TYPES + 1] =\n  {\n    tport_server_bind_set,\n    tport_client_bind_set,\n    tport_threadpool_set,\n#if HAVE_SOFIA_NTH\n    tport_http_connect_set,\n#endif\n#if HAVE_TLS\n    tport_tls_set,\n#endif\n    NULL\n  };\n\nint tport_bind_set(tport_master_t *mr,\n\t\t   tp_name_t const *tpn,\n\t\t   char const * const transports[],\n\t\t   tagi_t const *taglist,\n\t\t   tport_set_t **return_set,\n\t\t   int set_size)\n{\n  int i;\n\n  for (i = TPORT_NUMBER_OF_TYPES; i >= 0; i--) {\n    tport_set_f const *perhaps = tport_vtables[i];\n    int result;\n\n    if (perhaps == NULL)\n      continue;\n\n    result = perhaps(mr, tpn, transports, taglist, return_set, set_size);\n    if (result != 0)\n      return result;\n  }\n\n  return 0;\n}\n#endif\n\n/** Bind transport objects.\n *\n * @param self        pointer to a transport object\n * @param tpn         desired transport address\n * @param transports  list of protocol names supported by stack\n * @param tag,value,... tagged argument list\n *\n * @TAGS\n * TPTAG_SERVER(), TPTAG_PUBLIC(), TPTAG_IDENT(), TPTAG_HTTP_CONNECT(),\n * TPTAG_CERTIFICATE(), TPTAG_TLS_VERSION(), TPTAG_TLS_VERIFY_POLICY, and \n * tags used with tport_set_params(), especially TPTAG_QUEUESIZE().\n */\nint tport_tbind(tport_t *self,\n\t\ttp_name_t const *tpn,\n\t\tchar const * const transports[],\n\t\ttag_type_t tag, tag_value_t value, ...)\n{\n  ta_list ta;\n  int server = 1, retval, public = 0;\n  tp_name_t mytpn[1];\n  tport_master_t *mr;\n  char const *http_connect = NULL;\n\n  if (self == NULL || tport_is_secondary(self) ||\n      tpn == NULL || transports == NULL) {\n    su_seterrno(EINVAL);\n    return -1;\n  }\n\n  *mytpn = *tpn;\n\n  if (mytpn->tpn_ident == NULL)\n    mytpn->tpn_ident = self->tp_ident;\n\n  ta_start(ta, tag, value);\n\n  tl_gets(ta_args(ta),\n\t  TPTAG_SERVER_REF(server),\n\t  TPTAG_PUBLIC_REF(public),\n\t  TPTAG_IDENT_REF(mytpn->tpn_ident),\n\t  TPTAG_HTTP_CONNECT_REF(http_connect),\n\t  TAG_END());\n\n  mr = self->tp_master; assert(mr);\n\n  if (http_connect && public == 0)\n    public = tport_type_connect;\n\n  if (public && public != tport_type_stun)\n    server = 0;\n\n  if (server)\n    retval = tport_bind_server(mr, mytpn, transports, (enum tport_via)public, ta_args(ta));\n  else\n    retval = tport_bind_client(mr, mytpn, transports, (enum tport_via)public, ta_args(ta));\n\n  ta_end(ta);\n\n  return retval;\n}\n\n\n/** Bind primary transport objects used by a client-only application.\n * @internal\n */\nint tport_bind_client(tport_master_t *mr,\n                      tp_name_t const *tpn,\n                      char const * const transports[],\n\t\t      enum tport_via public,\n\t\t      tagi_t *tags)\n{\n  int i;\n  tport_primary_t *pri = NULL, **tbf;\n  tp_name_t tpn0[1] = {{ \"*\", \"*\", \"*\", \"*\", NULL, NULL }};\n  char const *why = \"unknown\";\n\n  tport_vtable_t const *vtable;\n\n  if (public == tport_type_local)\n    public = tport_type_client;\n\n  SU_DEBUG_5((\"%s(%p) to \" TPN_FORMAT \"\\n\",\n\t      __func__, (void *)mr, TPN_ARGS(tpn)));\n\n  memset(tpn0, 0, sizeof(tpn0));\n\n  for (tbf = &mr->mr_primaries; *tbf; tbf = &(*tbf)->pri_next)\n    ;\n\n  for (i = 0; transports[i]; i++) {\n    su_addrinfo_t hints[1];\n    char const *proto = transports[i];\n\n    if (strcmp(proto, tpn->tpn_proto) != 0 &&\n        strcmp(tpn->tpn_proto, tpn_any) != 0)\n      continue;\n\n    vtable = tport_vtable_by_name(proto, public);\n    if (!vtable)\n      continue;\n\n    /* Resolve protocol, skip unknown transport protocols */\n    if (getprotohints(hints, proto, AI_PASSIVE) < 0)\n      continue;\n\n    tpn0->tpn_proto = proto;\n    tpn0->tpn_comp = tpn->tpn_comp;\n    tpn0->tpn_ident = tpn->tpn_ident;\n\n    hints->ai_canonname = \"*\";\n\n    if (!(pri = tport_alloc_primary(mr, vtable, tpn0, hints, tags, &why)))\n      break;\n\n    pri->pri_public = tport_type_client; /* XXX */\n  }\n\n  if (!pri) {\n    SU_DEBUG_3((\"tport_alloc_primary: %s failed\\n\", why));\n    tport_zap_primary(*tbf);\n  }\n\n  return pri ? 0 : -1;\n}\n\n/** Bind primary transport objects used by a server application. */\nint tport_bind_server(tport_master_t *mr,\n                      tp_name_t const *tpn,\n                      char const * const transports[],\n\t\t      enum tport_via public,\n\t\t      tagi_t *tags)\n{\n  char hostname[TPORT_HOSTPORTSIZE];\n  char const *canon = NULL, *host, *service;\n  int error = 0, family = 0;\n  tport_primary_t *pri = NULL, **tbf;\n  su_addrinfo_t *ai, *res = NULL;\n  unsigned port, port0, port1, old;\n  unsigned short step = 0;\n\n  bind6only_check(mr);\n\n  (void)hostname;\n\n  SU_DEBUG_5((\"%s(%p) to \" TPN_FORMAT \"\\n\",\n\t      __func__, (void *)mr, TPN_ARGS(tpn)));\n\n  if (tpn->tpn_host == NULL || strcmp(tpn->tpn_host, tpn_any) == 0) {\n    /* Use a local IP address */\n    host = NULL;\n  }\n#ifdef SU_HAVE_IN6\n  else if (host_is_ip6_reference(tpn->tpn_host)) {\n    /* Remove [] around IPv6 addresses. */\n    size_t len = strlen(tpn->tpn_host);\n    assert(len < sizeof hostname);\n    host = memcpy(hostname, tpn->tpn_host + 1, len - 2);\n    hostname[len - 2] = '\\0';\n  }\n#endif\n  else\n    host = tpn->tpn_host;\n\n  if (tpn->tpn_port != NULL && strlen(tpn->tpn_port) > 0 &&\n      strcmp(tpn->tpn_port, tpn_any) != 0)\n    service = tpn->tpn_port;\n  else\n    service = \"\";\n\n  if (host && (strcmp(host, \"0.0.0.0\") == 0 || strcmp(host, \"0\") == 0))\n    host = NULL, family = AF_INET;\n#if SU_HAVE_IN6\n  else if (host && strcmp(host, \"::\") == 0)\n    host = NULL, family = AF_INET6;\n#endif\n\n  if (tpn->tpn_canon && strcmp(tpn->tpn_canon, tpn_any) &&\n      (host || tpn->tpn_canon != tpn->tpn_host))\n    canon = tpn->tpn_canon;\n\n  if (tport_server_addrinfo(mr, canon, family,\n\t\t\t    host, service, tpn->tpn_proto,\n\t\t\t    transports, &res) < 0)\n    return -1;\n\n  for (tbf = &mr->mr_primaries; *tbf; tbf = &(*tbf)->pri_next)\n    ;\n\n  port = port0 = port1 = ntohs(((su_sockaddr_t *)res->ai_addr)->su_port);\n  error = EPROTONOSUPPORT;\n\n  /*\n   * Loop until we can bind all the transports requested\n   * by the transport user to the same port.\n   */\n  for (;;) {\n    for (ai = res; ai; ai = ai->ai_next) {\n      tp_name_t tpname[1];\n      su_addrinfo_t ainfo[1];\n      su_sockaddr_t su[1];\n      tport_vtable_t const *vtable;\n\n      vtable = tport_vtable_by_name(ai->ai_canonname, public);\n      if (!vtable)\n\tcontinue;\n\n      tport_addrinfo_copy(ainfo, su, sizeof su, ai);\n      ainfo->ai_canonname = (char *)canon;\n      su->su_port = htons(port);\n\n      memcpy(tpname, tpn, sizeof tpname);\n      tpname->tpn_canon = canon;\n      tpname->tpn_host = host;\n\n      SU_DEBUG_9((\"%s(%p): calling tport_listen for %s\\n\",\n\t\t  __func__, (void *)mr, ai->ai_canonname));\n\n      pri = tport_listen(mr, vtable, tpname, ainfo, tags);\n      if (!pri) {\n\tswitch (error = su_errno()) {\n\tcase EADDRNOTAVAIL:\t/* Not our address */\n\tcase ENOPROTOOPT:\t/* Protocol not supported */\n\tcase ESOCKTNOSUPPORT:\t/* Socket type not supported */\n\t  continue;\n\tdefault:\n\t  break;\n\t}\n\tbreak;\n      }\n\n      if (port0 == 0 && port == 0) {\n\tport = port1 = ntohs(su->su_port);\n\tassert(public != tport_type_server || port != 0);\n      }\n    }\n\n    if (ai == NULL)\n      break;\n\n    while (*tbf)\n      tport_zap_primary(*tbf);\n\n    if (error != EADDRINUSE || port0 != 0 || port == 0)\n      break;\n\n    while (step == 0) {\n      /* step should be relative prime to 65536 - 1024 */\n      /* 65536 - 1024 = 7 * 3 * 3 * 1024 */\n      step = su_randint(1, 65535 - 1024 - 1) | 1;\n      if (step % 3 == 0)\n\tstep = (step + 2) % (65536 - 1024);\n      if (step % 7 == 0)\n\tstep = (step + 2) % (65536 - 1024);\n    }\n    old = port; port += step; if (port >= 65536) port -= (65536 - 1024);\n\n    if (port == port1)\t\t/* All ports in use! */\n      break;\n\n    SU_DEBUG_3((\"%s(%p): cannot bind all transports to port %u, trying %u\\n\",\n\t\t__func__, (void *)mr, old, port));\n  }\n\n  tport_freeaddrinfo(res);\n\n  if (!*tbf) {\n    su_seterrno(error);\n    return -1;\n  }\n\n  return 0;\n}\n\n\n/** Check if we can bind to IPv6 separately from IPv4 bind */\nstatic\nint bind6only_check(tport_master_t *mr)\n{\n  int retval = 0;\n#if SU_HAVE_IN6\n  su_sockaddr_t su[1], su4[1];\n  socklen_t sulen, su4len;\n  int s6, s4;\n\n  if (mr->mr_boundserver)\n    return 0;\n\n  s4 = su_socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);\n  s6 = su_socket(AF_INET6, SOCK_DGRAM, IPPROTO_UDP);\n\n  memset(su, 0, sizeof *su);\n  su->su_len = sulen = (sizeof su->su_sin6);\n  su->su_family = AF_INET6;\n\n  memset(su4, 0, sizeof *su4);\n  su4->su_len = su4len = (sizeof su->su_sin);\n  su4->su_family = AF_INET;\n\n  if (bind(s6, &su->su_sa, sulen) < 0)\n    ;\n  else if (getsockname(s6, &su->su_sa, &sulen) < 0)\n    ;\n  else if ((su4->su_port = su->su_port) != 0 &&\n\t   bind(s4, &su4->su_sa, su4len) == 0)\n    retval = 1;\n\n  su_close(s6), su_close(s4);\n\n  mr->mr_bindv6only = retval;\n  mr->mr_boundserver = 1;\n#endif\n\n  return retval;\n}\n\n/* Number of supported transports */\n#define TPORT_N (8)\n\n/** Return list of addrinfo structures matching to\n * canon/host/service/protocol\n */\nstatic\nint tport_server_addrinfo(tport_master_t *mr,\n\t\t\t  char const *canon,\n\t\t\t  int family,\n\t\t\t  char const *host,\n\t\t\t  char const *service,\n\t\t\t  char const *protocol,\n\t\t\t  char const * const transports[],\n\t\t\t  su_addrinfo_t **return_addrinfo)\n{\n  int i, N;\n  su_addrinfo_t hints[TPORT_N + 1];\n\n  *return_addrinfo = NULL;\n\n  /*\n   * Resolve all the transports requested by the protocol\n   */\n  for (i = 0, N = 0; transports[i] && N < TPORT_N; i++) {\n    su_addrinfo_t *ai = &hints[N];\n\n    if (!su_casematch(protocol, transports[i]) && !su_strmatch(protocol, \"*\"))\n      continue;\n\n    /* Resolve protocol, skip unknown transport protocols. */\n    if (getprotohints(ai, transports[i], AI_PASSIVE) < 0)\n      continue;\n\n    ai->ai_family = family;\n    ai->ai_next = &hints[++N];\n  }\n\n  if (N == 0)\n    return su_seterrno(EPROTONOSUPPORT);\n  if (transports[i] /* Too many protocols */)\n    return su_seterrno(ENOMEM);\n\n  hints[N - 1].ai_next = NULL;\n\n  if (host) {\n    int error = tport_getaddrinfo(host, service, hints, return_addrinfo);\n    if (error || !*return_addrinfo) {\n      SU_DEBUG_3((\"%s(%p): su_getaddrinfo(%s, %s) for %s: %s\\n\",\n\t\t  __func__, (void *)mr,\n\t\t  host ? host : \"\\\"\\\"\", service, protocol,\n\t\t  su_gai_strerror(error)));\n      return su_seterrno(error != EAI_MEMORY ? ENOENT : ENOMEM);\n    }\n    return 0;\n  }\n\n  return tport_get_local_addrinfo(mr, service, hints, return_addrinfo);\n}\n\n/** Convert localinfo into addrinfo */\nstatic\nint\ntport_get_local_addrinfo(tport_master_t *mr,\n\t\t\t char const *port,\n\t\t\t su_addrinfo_t const *hints,\n\t\t\t su_addrinfo_t **return_ai)\n{\n  int error, family;\n  su_localinfo_t lihints[1] = {{ 0 }};\n  su_localinfo_t *li, *li_result;\n  su_addrinfo_t const *h;\n  su_addrinfo_t *ai, **prev;\n  su_sockaddr_t *su;\n  unsigned long lport = 0;\n  char *rest;\n\n  prev = return_ai, *prev = NULL;\n\n  if (port) {\n    lport = strtoul(port, &rest, 10);\n    if (lport >= 65536) {\n      su_seterrno(EINVAL);\n      return -1;\n    }\n  }\n\n  family = hints->ai_family;\n\n  for (h = hints->ai_next; h && family; h = h->ai_next)\n    if (h->ai_family != family)\n      family = 0;\n\n  lihints->li_flags = 0;\n  lihints->li_family = family;\n  lihints->li_scope = LI_SCOPE_GLOBAL | LI_SCOPE_SITE | LI_SCOPE_HOST;\n\n  error = su_getlocalinfo(lihints, &li_result);\n  if (error) {\n#if SU_HAVE_IN6\n    SU_DEBUG_3((\"%s(%p): su_getlocalinfo() for %s address: %s\\n\",\n\t\t__func__, (void *)mr,\n\t\tfamily == AF_INET6 ? \"ip6\"\n\t\t: family == AF_INET ? \"ip4\" : \"ip\",\n\t\tsu_gli_strerror(error)));\n#else\n    SU_DEBUG_3((\"%s(%p): su_getlocalinfo() for %s address: %s\\n\",\n\t\t__func__, (void *)mr,\n\t\tfamily == AF_INET ? \"ip4\" : \"ip\",\n\t\tsu_gli_strerror(error)));\n#endif\n    su_seterrno(ENOENT);\n    return -1;\n  }\n\n  for (li = li_result; li; li = li->li_next) {\n    for (h = hints; h; h = h->ai_next) {\n      if (h->ai_family && h->ai_family != li->li_family)\n\tcontinue;\n\n      ai = calloc(1, sizeof *ai + li->li_addrlen);\n      if (ai == NULL)\n\tbreak;\n\n      *prev = ai, prev = &ai->ai_next;\n\n      ai->ai_flags = AI_PASSIVE | TP_AI_ANY;\n      ai->ai_family = li->li_family;\n      ai->ai_socktype = h->ai_socktype;\n      ai->ai_protocol = h->ai_protocol;\n      ai->ai_canonname = h->ai_canonname;\n      ai->ai_addr = memcpy(ai + 1, li->li_addr,\n\t\t\t   ai->ai_addrlen = li->li_addrlen);\n      su = (void *)ai->ai_addr;\n      su->su_port = htons(lport);\n    }\n  }\n\n  su_freelocalinfo(li_result);\n\n  if (li) {\n    tport_freeaddrinfo(*return_ai);\n    su_seterrno(ENOMEM);\n    return -1;\n  }\n\n  if (*return_ai == NULL) {\n    su_seterrno(ENOENT);\n    return -1;\n  }\n\n  return 0;\n}\n\nsu_inline su_addrinfo_t *get_next_addrinfo(su_addrinfo_t **all);\n\n/** Translate address and service.\n *\n * This is a getaddrinfo() supporting multiple hints in a list.\n */\nint tport_getaddrinfo(char const *node, char const *service,\n\t\t      su_addrinfo_t const *hints,\n\t\t      su_addrinfo_t **res)\n{\n  su_addrinfo_t const *h0;\n  su_addrinfo_t *tbf, **prev;\n  int error = EAI_SOCKTYPE;\n  int i, N;\n  su_addrinfo_t *all[TPORT_N + 1]; /* Lists for all supported transports */\n  su_addrinfo_t *results[TPORT_N + 1];\n  void *addr;\n  int addrlen;\n\n  *res = NULL;\n\n  for (N = 0, h0 = hints; h0; h0 = h0->ai_next) {\n    su_addrinfo_t h[1];\n\n    *h = *h0, h->ai_next = NULL, h->ai_canonname = NULL;\n\n    error = su_getaddrinfo(node, service, h, &all[N]);\n    results[N] = all[N];\n    if (error == EAI_SOCKTYPE) {\n      SU_DEBUG_7((\"%s(): su_getaddrinfo(%s, %s) for %s: %s\\n\",\n\t\t  __func__, node ? node : \"\\\"\\\"\", service,\n\t\t  h0->ai_canonname, su_gai_strerror(error)));\n      continue;\n    }\n\n    if (error || !all[N])\n      break;\n    N++;\n  }\n\n  if (h0)\n    for (i = 0; i < N; i++)\n      su_freeaddrinfo(all[i]);\n  if (error)\n    return error;\n\n  /* Combine all the valid addrinfo structures to a single list */\n  prev = &tbf, tbf = NULL;\n\n  for (;;) {\n    su_addrinfo_t *ai = NULL, *ai0;\n\n    for (i = 0, h0 = hints; i < N; i++, h0 = h0->ai_next) {\n      if ((ai = get_next_addrinfo(&results[i])))\n\tbreak;\n    }\n    if (i == N)\n      break;\n\n    assert(ai);\n    addr = SU_ADDR((su_sockaddr_t *)ai->ai_addr);\n    addrlen = SU_ADDRLEN((su_sockaddr_t *)ai->ai_addr);\n\n    /* Copy all the addrinfo structures with same address to the list */\n    for (; i < N; i++, h0 = h0->ai_next) {\n      while ((ai0 = get_next_addrinfo(&results[i]))) {\n\tvoid *a = SU_ADDR((su_sockaddr_t *)ai0->ai_addr);\n\n\tif (memcmp(addr, a, addrlen)) /* Different address */\n\t  break;\n\n\tresults[i] = ai0->ai_next;\n\n\tai = calloc(1, sizeof *ai + ai0->ai_addrlen);\n\tif (ai == NULL)\n\t  goto error;\n\t*prev = memcpy(ai, ai0, sizeof *ai); prev = &ai->ai_next; *prev = NULL;\n\tai->ai_addr = memcpy(ai + 1, ai0->ai_addr, ai0->ai_addrlen);\n\tai->ai_canonname = h0->ai_canonname;\n      }\n    }\n  }\n\n  for (i = 0; i < N; i++)\n    su_freeaddrinfo(all[i]);\n\n  *res = tbf;\n  return 0;\n\n error:\n  for (i = 0; i < N; i++)\n    su_freeaddrinfo(all[i]);\n  tport_freeaddrinfo(tbf);\n  return EAI_MEMORY;\n}\n\nsu_inline\nsu_addrinfo_t *get_next_addrinfo(su_addrinfo_t **all)\n{\n  su_addrinfo_t *ai;\n\n  while ((ai = *all)) {\n    if (ai->ai_family == AF_INET)\n      return ai;\n#if SU_HAVE_IN6\n    if (ai->ai_family == AF_INET6)\n      return ai;\n#endif\n    *all = ai->ai_next;\n  }\n  return ai;\n}\n\nstatic\nvoid tport_freeaddrinfo(su_addrinfo_t *ai)\n{\n  su_addrinfo_t *ai_next;\n\n  while (ai) {\n    ai_next = ai->ai_next;\n    free(ai);\n    ai = ai_next;\n  }\n}\n\nstatic\nint tport_addrinfo_copy(su_addrinfo_t *dst, void *addr, socklen_t addrlen,\n\t\t\tsu_addrinfo_t const *src)\n{\n  if (addrlen < src->ai_addrlen)\n    return -1;\n\n  memcpy(dst, src, sizeof *dst);\n\n  if (src->ai_addrlen < addrlen)\n    memset(addr, 0, addrlen);\n\n  dst->ai_addr = memcpy(addr, src->ai_addr, src->ai_addrlen);\n  dst->ai_next = NULL;\n\n  return 0;\n}\n\n/** Close a transport.\n *\n * Close the socket associated with a transport object. Report an error to\n * all pending clients, if required. Set/reset timer, too.\n */\nvoid tport_close(tport_t *self)\n{\n  SU_DEBUG_4((\"%s(%p): \" TPN_FORMAT \"\\n\",\n\t      __func__, (void *)self, TPN_ARGS(self->tp_name)));\n\n  if (self->tp_refs == -1) {\n\t  self->tp_refs = 0;\n  }\n\n  if (self->tp_closed || !tport_is_secondary(self))\n    return;\n\n  tprb_remove(&self->tp_pri->pri_open, self);\n  tplist_insert(&self->tp_pri->pri_closed, self);\n\n  self->tp_closed = 1;\n  self->tp_send_close = 3;\n  self->tp_recv_close = 3;\n\n  if (self->tp_params->tpp_sdwn_error && self->tp_pused)\n    tport_error_report(self, -1, NULL);\n\n  if (self->tp_pri->pri_vtable->vtp_shutdown)\n    self->tp_pri->pri_vtable->vtp_shutdown(self, 2);\n  else if (self->tp_socket != -1)\n    shutdown(self->tp_socket, 2);\n\n  if (self->tp_index)\n    su_root_deregister(self->tp_master->mr_root, self->tp_index);\n  self->tp_index = 0;\n#if SU_HAVE_BSDSOCK\n  if (self->tp_socket != -1)\n    su_close(self->tp_socket);\n  self->tp_socket = -1;\n#endif\n\n  /* Zap the queued messages */\n  if (self->tp_queue) {\n    unsigned short i, N = self->tp_params->tpp_qsize;\n    for (i = 0; i < N; i++) {\n      if (self->tp_queue[i])\n\tmsg_ref_destroy(self->tp_queue[i]), self->tp_queue[i] = NULL;\n    }\n  }\n\n  self->tp_index = 0;\n  self->tp_events = 0;\n}\n\n/** Shutdown a transport.\n *\n * The tport_shutdown() shuts down a full-duplex transport connection\n * partially or completely. If @a how is 0, the further incoming data is\n * shut down. If @a how is 1, further outgoing data is shut down. If @a how\n * is 2, both incoming and outgoing traffic is shut down.\n *\n */\nint tport_shutdown(tport_t *self, int how)\n{\n  int retval;\n  if (!tport_is_secondary(self))\n    return -1;\n  retval = tport_shutdown0(self, how);\n  tport_set_secondary_timer(self);\n  return retval;\n}\n\n/** Internal shutdown function */\nint tport_shutdown0(tport_t *self, int how)\n{\n  SU_DEBUG_4((\"%s(%p, %d) \" TPN_FORMAT \"\\n\", __func__, (void *)self, how, TPN_ARGS(self->tp_name)));\n\n  if (!tport_is_tcp(self) ||\n      how < 0 || how >= 2 ||\n      (how == 0 && self->tp_send_close) ||\n      (how == 1 && self->tp_recv_close > 1)) {\n    tport_close(self);\n    return 1;\n  }\n\n  if (self->tp_pri->pri_vtable->vtp_shutdown)\n    self->tp_pri->pri_vtable->vtp_shutdown(self, how);\n  else\n    shutdown(self->tp_socket, how);\n\n  if (how == 0) {\n    self->tp_recv_close = 2;\n    tport_set_events(self, 0, SU_WAIT_IN);\n    if (self->tp_params->tpp_sdwn_error && self->tp_pused)\n      tport_error_report(self, -1, NULL);\n  }\n  else if (how == 1) {\n    self->tp_send_close = 2;\n    tport_set_events(self, 0, SU_WAIT_OUT);\n    if (tport_has_queued(self)) {\n      unsigned short i, N = self->tp_params->tpp_qsize;\n      for (i = 0; i < N; i++) {\n\tif (self->tp_queue[i]) {\n\t  tport_pending_errmsg(self, self->tp_queue[i], EPIPE);\n\t  msg_ref_destroy(self->tp_queue[i]), self->tp_queue[i] = NULL;\n\t}\n      }\n    }\n  }\n\n  return 0;\n}\n\nstatic void tport_secondary_timer(su_root_magic_t *magic,\n\t\t\t\t  su_timer_t *t,\n\t\t\t\t  tport_t *self)\n{\n  su_time_t now;\n\n  if (tport_is_closed(self)) {\n    if (self->tp_refs == 0)\n      tport_zap_secondary(self);\n    return;\n  }\n\n  now = /* su_timer_expired(t); */ su_now();\n\n  if (self->tp_pri->pri_vtable->vtp_secondary_timer)\n    self->tp_pri->pri_vtable->vtp_secondary_timer(self, now);\n  else\n    tport_base_timer(self, now);\n}\n\n/** Base timer for secondary transports.\n *\n * Closes and zaps unused transports.  Sets the timer again.\n */\nvoid tport_base_timer(tport_t *self, su_time_t now)\n{\n  unsigned timeout = self->tp_params->tpp_idle;\n\n  if (timeout != UINT_MAX) {\n    if (self->tp_refs == 0 &&\n\tself->tp_msg == NULL &&\n\t!tport_has_queued(self) &&\n\tsu_time_cmp(su_time_add(self->tp_rtime, timeout), now) < 0 &&\n\tsu_time_cmp(su_time_add(self->tp_stime, timeout), now) < 0) {\n      SU_DEBUG_7((\"%s(%p): unused for %d ms,%s zapping\\n\",\n\t\t  __func__, (void *)self,\n\t\t  timeout, tport_is_closed(self) ? \"\" : \" closing and\"));\n      if (!tport_is_closed(self))\n\ttport_close(self);\n      tport_zap_secondary(self);\n      return;\n    }\n  }\n\n  tport_set_secondary_timer(self);\n}\n\n/** Set timer for a secondary transport.\n *\n * This function should be called after any network activity:\n * tport_base_connect(), tport_send_msg(), tport_send_queue(),\n * tport_recv_data(), tport_shutdown0(), tport_close(),\n *\n * @retval 0 always\n */\nint tport_set_secondary_timer(tport_t *self)\n{\n  su_time_t const infinity = { ULONG_MAX, 999999 };\n  su_time_t target = infinity;\n  char const *why = \"not specified\";\n  su_timer_f timer = tport_secondary_timer;\n\n  if (!tport_is_secondary(self))\n    return 0;\n\n  if (tport_is_closed(self)) {\n    if (self->tp_refs == 0) {\n      SU_DEBUG_7((\"tport(%p): set timer at %u ms because %s\\n\",\n\t\t\t\t  (void *)self, 0, \"zap\"));\n      su_timer_set_interval(self->tp_timer, timer, self, 0);\n    }\n    else\n      su_timer_reset(self->tp_timer);\n\n    return 0;\n  }\n\n  if (self->tp_params->tpp_idle != UINT_MAX) {\n    if (self->tp_refs == 0 &&\n\tself->tp_msg == NULL && !tport_has_queued(self)) {\n      if (su_time_cmp(self->tp_stime, self->tp_rtime) < 0) {\n\ttarget = su_time_add(self->tp_rtime, self->tp_params->tpp_idle);\n\twhy = \"idle since recv\";\n      }\n      else {\n\ttarget = su_time_add(self->tp_stime, self->tp_params->tpp_idle);\n\twhy = \"idle since send\";\n      }\n    }\n  }\n\n  if (self->tp_pri->pri_vtable->vtp_next_secondary_timer)\n    self->tp_pri->pri_vtable->\n      vtp_next_secondary_timer(self, &target, &why);\n\n  if (su_time_cmp(target, infinity)) {\n    SU_DEBUG_7((\"tport(%p): set timer at %ld ms because %s\\n\",\n\t\t(void *)self, su_duration(target, su_now()), why));\n    su_timer_set_at(self->tp_timer, timer, self, target);\n  }\n  else {\n    SU_DEBUG_9((\"tport(%p): reset timer\\n\", (void *)self));\n    su_timer_reset(self->tp_timer);\n  }\n\n  return 0;\n}\n\n\n/** Flush idle connections. */\nint tport_flush(tport_t *tp)\n{\n  tport_t *tp_next;\n  tport_primary_t *pri;\n\n  if (tp == NULL)\n    return -1;\n\n  pri = tp->tp_pri;\n\n  while (pri->pri_closed)\n    tport_zap_secondary(pri->pri_closed);\n\n  /* Go through all secondary transports, zap idle ones */\n  for (tp = tprb_first(tp->tp_pri->pri_open); tp; tp = tp_next) {\n    tp_next = tprb_succ(tp);\n\n    if (tp->tp_refs != 0)\n      continue;\n\n    SU_DEBUG_1((\"tport_flush(%p): %szapping\\n\",\n\t\t(void *)tp, tport_is_closed(tp) ? \"\" : \"closing and \"));\n\n    tport_close(tp);\n    tport_zap_secondary(tp);\n  }\n\n  return 0;\n}\n\n/**Convert sockaddr_t to a transport name.\n *\n * @retval 0 when successful\n * @retval -1 upon an error\n */\nint tport_convert_addr(su_home_t *home,\n\t\t       tp_name_t *tpn,\n\t\t       char const *protoname,\n\t\t       char const *canon,\n\t\t       su_sockaddr_t const *su)\n{\n  tp_name_t name[1] = {{ NULL }};\n  char const *host;\n  char buf[TPORT_HOSTPORTSIZE];\n  char port[8];\n  size_t canonlen = canon ? strlen(canon) : 0;\n\n  if (su == NULL)\n    host = \"*\";\n  else if (!SU_SOCKADDR_INADDR_ANY(su))\n    host = tport_hostport(buf, sizeof(buf), su, 0);\n  else if (canonlen && su->su_family == AF_INET &&\n\t   strspn(canon, \"0123456789.\") == canonlen)\n    host = canon;\n#if SU_HAVE_IN6\n  else if (canonlen && su->su_family == AF_INET6 &&\n\t   strspn(canon, \"0123456789abcdefABCDEF:.\") == canonlen)\n    host = canon;\n#endif\n  else\n    host = localipname(su->su_family, buf, sizeof(buf));\n\n  if (host == NULL)\n    return -1;\n\n  if (su == NULL)\n    strcpy(port, \"*\");\n  else\n    snprintf(port, sizeof(port), \"%u\", ntohs(su->su_port));\n\n  name->tpn_proto = protoname;\n  name->tpn_host = host;\n  name->tpn_canon = canon ? canon : host;\n  name->tpn_port = port;\n\n  return tport_name_dup(home, tpn, name);\n}\n\n/** Set transport object name. @internal\n */\nint tport_setname(tport_t *self,\n\t\t  char const *protoname,\n\t\t  su_addrinfo_t const *ai,\n\t\t  char const *canon)\n{\n  su_addrinfo_t *selfai = self->tp_addrinfo;\n\n  if (tport_convert_addr(self->tp_home, self->tp_name,\n\t\t\t protoname, canon,\n\t\t\t (su_sockaddr_t *)ai->ai_addr) < 0)\n    return -1;\n\n  if (tport_is_secondary(self))\n    self->tp_ident = self->tp_pri->pri_primary->tp_ident;\n\n  selfai->ai_flags = ai->ai_flags & TP_AI_MASK;\n\n  selfai->ai_family = ai->ai_family;\n  selfai->ai_socktype = ai->ai_socktype;\n  selfai->ai_protocol = ai->ai_protocol;\n  selfai->ai_canonname = (char *)self->tp_name->tpn_canon;\n\n  if (ai->ai_addr) {\n    assert(ai->ai_family), assert(ai->ai_socktype), assert(ai->ai_protocol);\n    memcpy(self->tp_addr, ai->ai_addr, selfai->ai_addrlen = ai->ai_addrlen);\n  }\n\n  if (tport_is_secondary(self)) incrementSecondaryCount(self);\n\n  return 0;\n}\n\n/**Resolve protocol name.\n *\n * Convert a protocol name to IP protocol number and socket type used by\n * su_getaddrinfo().\n *\n * @param hints hints with the protocol number and socktype [OUT]\n * @param proto protocol name [IN]\n * @param flags hint flags\n */\nstatic\nint getprotohints(su_addrinfo_t *hints,\n\t\t  char const *proto,\n\t\t  int flags)\n{\n  memset(hints, 0, sizeof *hints);\n\n  hints->ai_flags = flags;\n  hints->ai_canonname = (char *)proto;\n\n#if HAVE_TLS\n  if (su_casematch(proto, \"tls\"))\n    proto = \"tcp\";\n#endif\n\n#if HAVE_SOFIA_NTH\n  if (su_casematch(proto, \"ws\"))\n    proto = \"tcp\";\n  if (su_casematch(proto, \"wss\"))\n    proto = \"tcp\";\n#endif\n\n#if HAVE_SCTP\n  if (su_casematch(proto, \"sctp\")) {\n    hints->ai_protocol = IPPROTO_SCTP;\n    hints->ai_socktype = SOCK_STREAM;\n    return 0;\n  }\n#endif\n\n  if (su_casematch(proto, \"udp\")) {\n    hints->ai_protocol = IPPROTO_UDP;\n    hints->ai_socktype = SOCK_DGRAM;\n    return 0;\n  }\n\n  if (su_casematch(proto, \"tcp\")) {\n    hints->ai_protocol = IPPROTO_TCP;\n    hints->ai_socktype = SOCK_STREAM;\n    return 0;\n  }\n\n  return -1;\n}\n\n/** Get local IP.\n *\n * Get primary local IP address in URI format (IPv6 address will be\n * []-quoted).\n */\nstatic\nchar *localipname(int pf, char *buf, size_t bufsiz)\n{\n  su_localinfo_t *li = NULL, hints[1] = {{ LI_NUMERIC | LI_CANONNAME }};\n  size_t n;\n  int error;\n\n  hints->li_family = pf;\n\n#if SU_HAVE_IN6\n  if (pf == AF_INET6) {\n    /* Link-local addresses are not usable on IPv6 */\n    hints->li_scope = LI_SCOPE_GLOBAL | LI_SCOPE_SITE /* | LI_SCOPE_HOST */;\n  }\n#endif\n\n  if ((error = su_getlocalinfo(hints, &li))) {\n#if SU_HAVE_IN6\n    if (error == ELI_NOADDRESS && pf == AF_INET6) {\n      hints->li_family = AF_INET;\n      error = su_getlocalinfo(hints, &li);\n      if (error == ELI_NOADDRESS) {\n\thints->li_family = AF_INET6; hints->li_scope |= LI_SCOPE_HOST;\n\terror = su_getlocalinfo(hints, &li);\n      }\n      if (error == ELI_NOADDRESS) {\n\thints->li_family = AF_INET;\n\terror = su_getlocalinfo(hints, &li);\n      }\n    }\n#endif\n    if (error) {\n      SU_DEBUG_1((\"tport: su_getlocalinfo: %s\\n\", su_gli_strerror(error)));\n      return NULL;\n    }\n  }\n\n  assert(li); assert(li->li_canonname);\n\n  n = strlen(li->li_canonname);\n\n  if (li->li_family == AF_INET) {\n    if (n >= bufsiz)\n      return NULL;\n\n    memcpy(buf, li->li_canonname, n + 1);\n  }\n  else {\n    if (n + 2 >= bufsiz)\n      return NULL;\n\n    memcpy(buf + 1, li->li_canonname, n);\n    buf[0] = '['; buf[++n] = ']'; buf[++n] = '\\0';\n  }\n\n  su_freelocalinfo(li);\n\n  return buf;\n}\n\n/** Process errors from transport. */\nvoid tport_error_report(tport_t *self, int errcode,\n\t\t\tsu_sockaddr_t const *addr)\n{\n  char const *errmsg;\n\n  if (errcode == 0)\n    return;\n  else if (errcode > 0)\n    errmsg = su_strerror(errcode);\n  else\n    /* Should be something  like ENOTCONN */\n    errcode = 0, errmsg = \"stream closed\";\n\n  if (addr && addr->su_family == AF_UNSPEC)\n    addr = NULL;\n\n  /* Mark this connection as unusable */\n  if (errcode > 0 && tport_has_connection(self))\n    self->tp_reusable = 0;\n\n  /* Report error */\n  if (addr && tport_pending_error(self, addr, errcode))\n    ;\n  else if (tport_is_secondary(self) &&\n\t   tport_pending_error(self, NULL, errcode) > 0)\n    ;\n  else if (self->tp_master->mr_tpac->tpac_error) {\n    char *dstname = NULL;\n    char hp[TPORT_HOSTPORTSIZE];\n\n    if (addr)\n      dstname = tport_hostport(hp, sizeof hp, addr, 1);\n\n    STACK_ERROR(self, errcode, dstname);\n  }\n  else {\n    if (tport_is_primary(self))\n      SU_DEBUG_3((\"%s(%p): %s (with %s)\\n\", __func__, (void *)self,\n\t\t  errmsg, self->tp_protoname));\n    else\n      SU_DEBUG_3((\"%s(%p): %s (with %s/%s:%s)\\n\", __func__, (void *)self,\n\t\t  errmsg, self->tp_protoname, self->tp_host, self->tp_port));\n  }\n\n  /* Close connection */\n  if (!self->tp_closed && errcode > 0 && tport_has_connection(self)) {\n    if (tport_is_secondary(self)) {\n      SU_DEBUG_4((\"%s(%p) \" TPN_FORMAT \" calling tport_shutdown0 due to error on secondary transport\\n\",\n        __func__, (void *)self, TPN_ARGS(self->tp_name)));\n      tport_shutdown0(self, 2);\n      tport_set_secondary_timer(self);\n    }\n    else {\n      SU_DEBUG_9((\"%s(%p): \" TPN_FORMAT \" calling tport_close\\n\", __func__, (void *)self, TPN_ARGS(self->tp_name)));\n      tport_close(self);\n    }\n  }\n}\n\n/** Accept a new connection.\n *\n * The function tport_accept() accepts a new connection and creates a\n * secondary transport object for the new socket.\n */\nint tport_accept(tport_primary_t *pri, int events)\n{\n  tport_t *self;\n  su_addrinfo_t ai[1];\n  su_sockaddr_t su[1];\n  socklen_t sulen = sizeof su;\n  su_socket_t s = INVALID_SOCKET, l = pri->pri_primary->tp_socket;\n  char const *reason = \"accept\";\n\n  if (events & SU_WAIT_ERR)\n    tport_error_event(pri->pri_primary);\n\n  if (!(events & SU_WAIT_ACCEPT))\n    return 0;\n\n  memcpy(ai, pri->pri_primary->tp_addrinfo, sizeof ai);\n  ai->ai_canonname = NULL;\n\n  s = accept(l, &su->su_sa, &sulen);\n\n  if (s < 0) {\n    tport_error_report(pri->pri_primary, su_errno(), NULL);\n    return 0;\n  }\n\n  ai->ai_addr = &su->su_sa, ai->ai_addrlen = sulen;\n\n  /* Alloc a new transport object, then register socket events with it */\n  if ((self = tport_alloc_secondary(pri, s, 1, &reason)) == NULL) {\n    SU_DEBUG_3((\"%s(%p): incoming secondary on \"TPN_FORMAT\n                \" failed. reason = %s\\n\", __func__, (void *)pri, \n                TPN_ARGS(pri->pri_primary->tp_name), reason));\n\tshutdown(s, 2);\n\tsu_close(s);\n    return 0;\n  }\n  else {\n    int events = SU_WAIT_IN|SU_WAIT_ERR|SU_WAIT_HUP;\n\n    SU_CANONIZE_SOCKADDR(su);\n\n    if (/* Name this transport */\n        tport_setname(self, pri->pri_protoname, ai, NULL) != -1 \n\t/* Register this secondary */ \n\t&&\n\ttport_register_secondary(self, tport_wakeup, events) != -1) {\n\n      self->tp_conn_orient = 1;\n      self->tp_is_connected = 1;\n\n      SU_DEBUG_4((\"%s(%p): new connection from \" TPN_FORMAT \"\\n\",\n                  __func__,  (void *)self, TPN_ARGS(self->tp_name)));\n\n      return 0;\n    }\n\n    /* Failure: shutdown socket,  */\n    tport_close(self);\n    tport_zap_secondary(self);\n    self = NULL;\n  }\n\n  return 0;\n}\n\n/** Allocate a new message object */\nmsg_t *tport_msg_alloc(tport_t const *self, usize_t size)\n{\n  if (self) {\n    tport_master_t *mr = self->tp_master;\n    msg_t *msg = mr->mr_tpac->tpac_alloc(mr->mr_stack, mr->mr_log,\n\t\t\t\t\t NULL, size, self, NULL);\n    if (msg) {\n      su_addrinfo_t *mai = msg_addrinfo(msg);\n      su_addrinfo_t const *tai = self->tp_addrinfo;\n\n      mai->ai_family =   tai->ai_family;\n      mai->ai_protocol = tai->ai_protocol;\n      mai->ai_socktype = tai->ai_socktype;\n    }\n\n    return msg;\n  }\n  else {\n    return NULL;\n  }\n}\n\n/** Process events for socket waiting to be connected\n */\nstatic int tport_connected(su_root_magic_t *magic, su_wait_t *w, tport_t *self)\n{\n  int events = su_wait_events(w, self->tp_socket);\n  tport_master_t *mr = self->tp_master;\n  su_wait_t wait[1] =  { SU_WAIT_INIT };\n  int su_wait_create_ret;\n\n  int error;\n\n  SU_DEBUG_7((\"tport_connected(%p): events%s%s\\n\", (void *)self,\n\t      events & SU_WAIT_CONNECT ? \" CONNECTED\" : \"\",\n\t      events & SU_WAIT_ERR ? \" ERR\" : \"\"));\n\n#if HAVE_POLL\n  assert(w->fd == self->tp_socket);\n#endif\n\n  if (events & SU_WAIT_ERR)\n    tport_error_event(self);\n\n  if (!(events & SU_WAIT_CONNECT) || self->tp_closed) {\n    return 0;\n  }\n\n  error = su_soerror(self->tp_socket);\n  if (error) {\n    tport_error_report(self, error, NULL);\n    return 0;\n  }\n\n  self->tp_is_connected = 1;\n\n  su_root_deregister(mr->mr_root, self->tp_index);\n  self->tp_index = -1;\n  self->tp_events = SU_WAIT_IN | SU_WAIT_ERR | SU_WAIT_HUP;\n\n  if ((su_wait_create_ret = su_wait_create(wait, self->tp_socket, self->tp_events)) == -1 ||\n      (self->tp_index = su_root_register(mr->mr_root,\n\t\t\t\t\t wait, tport_wakeup, self, 0))\n      == -1) {\n    if (su_wait_create_ret == 0) {\n      su_wait_destroy(wait);\n    }\n    tport_close(self);\n    tport_set_secondary_timer(self);\n    return 0;\n  }\n\n  if (tport_has_queued(self))\n    tport_send_event(self);\n  else\n    tport_set_secondary_timer(self);\n\n  return 0;\n}\n\n/** Process events for primary socket  */\nstatic int tport_wakeup_pri(su_root_magic_t *m, su_wait_t *w, tport_t *self)\n{\n  tport_primary_t *pri = self->tp_pri;\n  int events = su_wait_events(w, self->tp_socket);\n\n#if HAVE_POLL\n  assert(w->fd == self->tp_socket);\n#endif\n\n  SU_DEBUG_7((\"%s(%p): events%s%s%s%s%s%s\\n\",\n\t      \"tport_wakeup_pri\", (void *)self,\n\t      events & SU_WAIT_IN ? \" IN\" : \"\",\n\t      SU_WAIT_ACCEPT != SU_WAIT_IN &&\n\t      (events & SU_WAIT_ACCEPT) ? \" ACCEPT\" : \"\",\n\t      events & SU_WAIT_OUT ? \" OUT\" : \"\",\n\t      events & SU_WAIT_HUP ? \" HUP\" : \"\",\n\t      events & SU_WAIT_ERR ? \" ERR\" : \"\",\n\t      self->tp_closed ? \" (closed)\" : \"\"));\n\n\n  if (pri->pri_vtable->vtp_wakeup_pri)\n    return pri->pri_vtable->vtp_wakeup_pri(pri, events);\n  else\n    return tport_base_wakeup(self, events);\n}\n\n/** Process events for connected socket  */\nint tport_wakeup(su_root_magic_t *magic, su_wait_t *w, tport_t *self)\n{\n  int events = su_wait_events(w, self->tp_socket);\n\n#if HAVE_POLL\n  assert(w->fd == self->tp_socket);\n#endif\n\n  SU_DEBUG_7((\"%s(%p): events%s%s%s%s%s\\n\",\n\t      \"tport_wakeup\", (void *)self,\n\t      events & SU_WAIT_IN ? \" IN\" : \"\",\n\t      events & SU_WAIT_OUT ? \" OUT\" : \"\",\n\t      events & SU_WAIT_HUP ? \" HUP\" : \"\",\n\t      events & SU_WAIT_ERR ? \" ERR\" : \"\",\n\t      self->tp_closed ? \" (closed)\" : \"\"));\n\n  if (self->tp_pri->pri_vtable->vtp_wakeup)\n    return self->tp_pri->pri_vtable->vtp_wakeup(self, events);\n  else\n    return tport_base_wakeup(self, events);\n}\n\nstatic int tport_base_wakeup(tport_t *self, int events)\n{\n  int error = 0;\n\n  if (events & SU_WAIT_ERR)\n    error = tport_error_event(self);\n\n  if ((events & SU_WAIT_OUT) && !self->tp_closed)\n    tport_send_event(self);\n\n  if ((events & SU_WAIT_IN) && !self->tp_closed)\n    tport_recv_event(self);\n\n  if ((events & SU_WAIT_HUP) && !self->tp_closed)\n    tport_hup_event(self);\n\n  if (error) {\n    if (self->tp_closed && error == EPIPE)\n      return 0;\n\n    tport_error_report(self, error, NULL);\n  }\n\n  return 0;\n}\n\n/** Stop reading from socket until tport_continue() is called. */\nint tport_stall(tport_t *self)\n{\n  return tport_set_events(self, 0, SU_WAIT_IN);\n}\n\n/** Continue reading from socket. */\nint tport_continue(tport_t *self)\n{\n  if (self == NULL || self->tp_recv_close)\n    return -1;\n  return tport_set_events(self, SU_WAIT_IN, 0);\n}\n\n/** Process \"hangup\" event.\n *\n */\nvoid tport_hup_event(tport_t *self)\n{\n  SU_DEBUG_4((\"%s(%p) \" TPN_FORMAT \"\\n\", __func__, (void *)self, TPN_ARGS(self->tp_name)));\n\n  if (self->tp_msg) {\n    su_time_t now = su_now();\n    msg_recv_commit(self->tp_msg, 0, 1);\n    tport_parse(self, 1, now);\n  }\n\n  if (!tport_is_secondary(self))\n    return;\n\n  /* Shutdown completely if there are no queued messages */\n  /* Problem reported by Arsen Chaloyan */\n  tport_shutdown0(self, tport_has_queued(self) ? 0 : 2);\n  tport_set_secondary_timer(self);\n}\n\n/** Receive data available on the socket.\n *\n * @retval -1 error\n * @retval 0  end-of-stream\n * @retval 1  normal receive\n * @retval 2  incomplete recv, recv again\n * @retval 3  STUN keepalive, ignore\n */\nsu_inline\nint tport_recv_data(tport_t *self)\n{\n  return self->tp_pri->pri_vtable->vtp_recv(self);\n}\n\n/** Process \"ready to receive\" event.\n *\n */\nvoid tport_recv_event(tport_t *self)\n{\n  int again;\n\n  SU_DEBUG_7((\"%s(%p)\\n\", \"tport_recv_event\", (void *)self));\n\n  do {\n    /* Receive data from socket */\n    again = tport_recv_data(self);\n\n    su_time(&self->tp_rtime);\n\n#if HAVE_SOFIA_STUN\n    if (again == 3) /* STUN keepalive */\n      return;\n#endif\n\n    if (again < 0) {\n      int error = su_errno();\n\n      if (!su_is_blocking(error)) {\n\ttport_error_report(self, error, NULL);\n\treturn;\n      }\n      else {\n\tSU_DEBUG_3((\"%s: recvfrom(): %s (%d)\\n\", __func__,\n\t\t    su_strerror(EAGAIN), EAGAIN));\n      }\n    }\n\n    if (again >= 0)\n      tport_parse(self, self->tp_pre_framed ? 1 : !again, self->tp_rtime);\n  }\n  while (again > 1);\n\n  if (!tport_is_secondary(self))\n    return;\n\n  if (again == 0 && !tport_is_dgram(self)) {\n    /* End of stream */\n    SU_DEBUG_4((\"%s(%p): end of stream from \" TPN_FORMAT \"\\n\",\n\t\t  __func__, (void *)self, TPN_ARGS(self->tp_name)));\n\n    if (!self->tp_closed) {\n      /* Don't shutdown completely if there are queued messages */\n      tport_shutdown0(self, tport_has_queued(self) ? 0 : 2);\n    }\n  }\n\n  tport_set_secondary_timer(self);\n}\n\n/*\n * Parse the data and feed complete messages to the stack\n */\nstatic void tport_parse(tport_t *self, int complete, su_time_t now)\n{\n  msg_t *msg, *next = NULL;\n  int n, streaming, stall = 0;\n\n  for (msg = self->tp_msg; msg; msg = next) {\n    n = msg_extract(msg);\t/* Parse message */\n\n    streaming = 0;\n\n    if (n == 0) {\n      if (complete)\n\tmsg_mark_as_complete(msg, MSG_FLG_ERROR), n = -1;\n      else if (!(streaming = msg_is_streaming(msg))) {\n\ttport_sigcomp_accept_incomplete(self, msg);\n\tbreak;\n      }\n    }\n\n    if (msg_get_flags(msg, MSG_FLG_TOOLARGE))\n      SU_DEBUG_3((\"%s(%p): too large message from \" TPN_FORMAT \"\\n\",\n\t\t  __func__, (void *)self, TPN_ARGS(self->tp_name)));\n\n    /* Do not try to read anymore from this connection? */\n    if (tport_is_stream(self) &&\n\tmsg_get_flags(msg, MSG_FLG_TOOLARGE | MSG_FLG_ERROR))\n      self->tp_recv_close = stall = 1;\n\n    if (n == -1)\n      next = NULL;\n    else if (streaming)\n      msg_ref_create(msg);\t/* Keep a reference */\n    else if (tport_is_stream(self))\n      next = msg_next(msg);\n    else\n      next = NULL;\n\n    tport_deliver(self, msg, next, self->tp_comp, now);\n\n    if (streaming && next == NULL)\n      break;\n  }\n\n  if (stall)\n    tport_stall(self);\n\n  if (self->tp_rlogged != msg)\n    self->tp_rlogged = NULL;\n\n  self->tp_msg = msg;\n}\n\n/** Deliver message to the protocol stack */\nvoid tport_deliver(tport_t *self,\n\t\t   msg_t *msg,\n\t\t   msg_t *next,\n\t\t   tport_compressor_t *sc,\n\t\t   su_time_t now)\n{\n  tport_t *ref;\n  int error;\n  struct tport_delivery *d;\n  char ipaddr[SU_ADDRSIZE + 2];\n\n  assert(msg);\n\n  d = self->tp_master->mr_delivery;\n\n  d->d_tport = self;\n  d->d_msg = msg;\n  *d->d_from = *self->tp_name;\n\n  if (tport_is_primary(self)) {\n    su_sockaddr_t const *su = msg_addr(msg);\n\n#if SU_HAVE_IN6\n    if (su->su_family == AF_INET6) {\n      ipaddr[0] = '[';\n      su_inet_ntop(su->su_family, SU_ADDR(su), ipaddr + 1, SU_ADDRSIZE);\n      strcat(ipaddr, \"]\");\n    }\n    else {\n      su_inet_ntop(su->su_family, SU_ADDR(su), ipaddr, sizeof(ipaddr));\n    }\n#else\n    su_inet_ntop(su->su_family, SU_ADDR(su), ipaddr, sizeof(ipaddr));\n#endif\n\n    d->d_from->tpn_canon = ipaddr;\n    d->d_from->tpn_host = ipaddr;\n  }\n\n  d->d_comp = sc;\n  if (!sc)\n    d->d_from->tpn_comp = NULL;\n\n  error = msg_has_error(msg);\n\n  if (error && !*msg_chain_head(msg)) {\n    /* This is badly damaged packet */\n  }\n  else if (self->tp_master->mr_log && msg != self->tp_rlogged) {\n    char const *via = \"recv\";\n    tport_log_msg(self, msg, via, \"from\", now);\n    self->tp_rlogged = msg;\n  }\n\n  SU_DEBUG_7((\"%s(%p): %smsg %p (\"MOD_ZU\" bytes)\"\n\t      \" from \" TPN_FORMAT \" next=%p\\n\",\n\t      __func__, (void *)self, error ? \"bad \" : \"\",\n\t      (void *)msg, (size_t)msg_size(msg),\n\t      TPN_ARGS(d->d_from), (void *)next));\n\n  ref = tport_incref(self);\n\n  if (self->tp_pri->pri_vtable->vtp_deliver) {\n    self->tp_pri->pri_vtable->vtp_deliver(self, msg, now);\n  }\n  else\n    tport_base_deliver(self, msg, now);\n\n  memset(d->d_from, 0, sizeof d->d_from);\n  d->d_msg = NULL;\n\n  tport_decref(&ref);\n}\n\n/** Pass message to the protocol stack */\nvoid\ntport_base_deliver(tport_t *self, msg_t *msg, su_time_t now)\n{\n  STACK_RECV(self, msg, now);\n}\n\n/** Return source transport object for delivered message */\ntport_t *tport_delivered_by(tport_t const *tp, msg_t const *msg)\n{\n  if (tp && msg && msg == tp->tp_master->mr_delivery->d_msg)\n    return tp->tp_master->mr_delivery->d_tport;\n  else\n    return NULL;\n}\n\n\n/** Return source transport name for delivered message */\nint tport_delivered_from(tport_t *tp, msg_t const *msg, tp_name_t name[1])\n{\n  if (name == NULL)\n    return -1;\n\n  if (tp == NULL || msg == NULL || msg != tp->tp_master->mr_delivery->d_msg) {\n    memset(name, 0, sizeof *name);\n    return -1;\n  }\n  else {\n    *name = *tp->tp_master->mr_delivery->d_from;\n    return 0;\n  }\n}\n\n/** Return TLS Subjects provided by the source transport */\nsu_strlst_t const *tport_delivered_from_subjects(tport_t *tp, msg_t const *msg)\n{\n  if (tp && msg && msg == tp->tp_master->mr_delivery->d_msg) {\n    tport_t *tp_sec = tp->tp_master->mr_delivery->d_tport;\n    return (tp_sec) ? tp_sec->tp_subjects : NULL;\n  }\n  else\n    return NULL;\n}\n\n/** Return UDVM used to decompress the message. */\nint\ntport_delivered_with_comp(tport_t *tp, msg_t const *msg,\n\t\t\t  tport_compressor_t **return_compressor)\n{\n  if (tp == NULL || msg == NULL || msg != tp->tp_master->mr_delivery->d_msg)\n    return -1;\n\n  if (return_compressor)\n    *return_compressor = tp->tp_master->mr_delivery->d_comp;\n\n  return 0;\n}\n\n/** Search for subject in list of TLS Certificate subjects */\nint\ntport_subject_search(char const *subject, su_strlst_t const *lst)\n{\n  usize_t idx, ilen;\n  const char *subjuri;\n\n  if (!subject || su_strmatch(tpn_any, subject))\n    return 1;\n\n  if (!lst)\n    return 0;\n\n  /* Check if subject is a URI */\n  if (su_casenmatch(subject,\"sip:\",4) || su_casenmatch(subject,\"sips:\",5))\n    subjuri = subject + su_strncspn(subject,5,\":\") + 1;\n  else\n    subjuri = NULL;\n\n  ilen = su_strlst_len(lst);\n\n  for (idx = 0; idx < ilen; idx++) {\n    const char *lsturi, *lststr;\n\n    lststr = su_strlst_item(lst, idx);\n\n    /* check if lststr is a URI (sips URI is an unacceptable cert subject) */\n    if (su_casenmatch(lststr,\"sip:\",4))\n      lsturi = lststr + su_strncspn(lststr,4,\":\") + 1;\n    else\n      lsturi = NULL;\n\n\n    /* Match two SIP Server Identities */\n    if (host_cmp(subjuri ? subjuri : subject, lsturi ? lsturi : lststr) == 0)\n      return 1;\n#if 0\n    /* XXX - IETF drafts forbid wildcard certs */\n    if (!subjuri && !lsturi && su_strnmatch(\"*.\", lststr, 2)) {\n      size_t urioffset = su_strncspn(subject, 64, \".\");\n      if (urioffset) {\n        if (su_casematch(subject + urioffset, lststr+1))\n          return 1;\n      }\n    }\n#endif\n  }\n\n  return 0;\n}\n\n/** Allocate message for N bytes,\n *  return message buffer as a iovec\n */\nssize_t tport_recv_iovec(tport_t const *self,\n\t\t\t msg_t **in_out_msg,\n\t\t\t msg_iovec_t iovec[msg_n_fragments],\n\t\t\t size_t N,\n\t\t\t int exact)\n{\n  msg_t *msg = *in_out_msg;\n  ssize_t i, veclen;\n  int fresh;\n\n  if (N == 0)\n    return 0;\n\n  fresh = !msg;\n\n  /*\n   * Allocate a new message if needed\n   */\n  if (!msg) {\n    if (!(*in_out_msg = msg = tport_msg_alloc(self, N))) {\n      SU_DEBUG_7((\"%s(%p): cannot allocate msg for \"MOD_ZU\" bytes \"\n\t\t  \"from (%s/%s:%s)\\n\",\n\t\t  __func__, (void *)self, N,\n\t\t  self->tp_protoname, self->tp_host, self->tp_port));\n      return -1;\n    }\n  }\n\n  /*\n   * Get enough buffer space for the incoming data\n   */\n  veclen = msg_recv_iovec(msg, iovec, msg_n_fragments, N, exact);\n  if (veclen < 0) {\n    int err = su_errno();\n    if (fresh && err == ENOBUFS && msg_get_flags(msg, MSG_FLG_TOOLARGE))\n      veclen = msg_recv_iovec(msg, iovec, msg_n_fragments, 4096, 1);\n  }\n  if (veclen < 0) {\n    int err = su_errno();\n    SU_DEBUG_7((\"%s(%p): cannot get msg %p buffer for \"MOD_ZU\" bytes \"\n\t\t\"from (%s/%s:%s): %s\\n\",\n\t\t__func__, (void *)self, (void *)msg, N,\n\t\tself->tp_protoname, self->tp_host, self->tp_port,\n\t\tsu_strerror(err)));\n    su_seterrno(err);\n    return veclen;\n  }\n\n  assert(veclen <= msg_n_fragments);\n\n  SU_DEBUG_7((\"%s(%p) msg %p from (%s/%s:%s) has \"MOD_ZU\" bytes, \"\n\t      \"veclen = \"MOD_ZD\"\\n\",\n              __func__, (void *)self,\n\t      (void *)msg, self->tp_protoname, self->tp_host, self->tp_port,\n\t      N, veclen));\n\n  for (i = 0; veclen > 1 && i < veclen; i++) {\n    SU_DEBUG_7((\"\\tiovec[%lu] = %lu bytes\\n\", (LU)i, (LU)iovec[i].mv_len));\n  }\n\n  return veclen;\n}\n\nint tport_recv_error_report(tport_t *self)\n{\n  if (su_is_blocking(su_errno()))\n    return 1;\n\n  /* Report error */\n  tport_error_report(self, su_errno(), NULL);\n\n  return -1;\n}\n\n/** Send a message.\n *\n * The function tport_tsend() sends a message using the transport @a self.\n *\n * @TAGS\n * TPTAG_MTU(), TPTAG_REUSE(), TPTAG_CLOSE_AFTER(), TPTAG_SDWN_AFTER(),\n * TPTAG_FRESH(), TPTAG_COMPARTMENT(), TPTAG_X509_SUBJECT()\n */\ntport_t *tport_tsend(tport_t *self,\n\t\t     msg_t *msg,\n\t\t     tp_name_t const *_tpn,\n\t\t     tag_type_t tag, tag_value_t value, ...)\n{\n  ta_list ta;\n  tagi_t const *t;\n  int reuse, sdwn_after, close_after, resolved = 0, fresh;\n  unsigned mtu;\n  su_addrinfo_t *ai;\n  tport_primary_t *primary;\n  tp_name_t tpn[1];\n  struct sigcomp_compartment *cc;\n\n  if (!self || !msg || !_tpn) {\n    msg_set_errno(msg, EINVAL);\n    return NULL;\n  }\n\n  *tpn = *_tpn;\n\n  SU_DEBUG_7((\"tport_tsend(%p) tpn = \" TPN_FORMAT \"\\n\",\n\t      (void *)self, TPN_ARGS(tpn)));\n\n  if (tport_is_master(self)) {\n    primary = (tport_primary_t *)tport_primary_by_name(self, tpn);\n    if (!primary) {\n      msg_set_errno(msg, EPROTONOSUPPORT);\n      return NULL;\n    }\n  }\n  else {\n    primary = self->tp_pri;\n  }\n\n  ta_start(ta, tag, value);\n\n  reuse = primary->pri_primary->tp_reusable && self->tp_reusable;\n  fresh = 0;\n  sdwn_after = 0;\n  close_after = 0;\n  mtu = 0;\n  cc = NULL;\n\n  /* tl_gets() is a bit too slow here... */\n  for (t = ta_args(ta); t; t = tl_next(t)) {\n    tag_type_t tt = t->t_tag;\n\n    if (tptag_reuse == tt)\n      reuse = t->t_value != 0;\n    else if (tptag_mtu == tt)\n      mtu = t->t_value;\n    else if (tptag_sdwn_after == tt)\n      sdwn_after = t->t_value != 0;\n    else if (tptag_close_after == tt)\n      close_after = t->t_value != 0;\n    else if (tptag_fresh == tt)\n      fresh = t->t_value != 0;\n    else if (tptag_compartment == tt)\n      cc = (struct sigcomp_compartment *)t->t_value;\n  }\n\n  ta_end(ta);\n\n  fresh = fresh || !reuse;\n\n  ai = msg_addrinfo(msg);\n\n  ai->ai_flags = 0;\n\n  tpn->tpn_comp = tport_canonize_comp(tpn->tpn_comp);\n  if (tpn->tpn_comp) {\n    ai->ai_flags |= TP_AI_COMPRESSED;\n    SU_DEBUG_9((\"%s: compressed msg(%p) with %s\\n\",\n\t\t__func__, (void *)msg, tpn->tpn_comp));\n  }\n\n  if (!tpn->tpn_comp || cc == NONE)\n    cc = NULL;\n\n  if (sdwn_after)\n    ai->ai_flags |= TP_AI_SHUTDOWN;\n  if (close_after)\n    ai->ai_flags |= TP_AI_CLOSE;\n\n  if (fresh) {\n    /* Select a primary protocol, make a fresh connection */\n    self = primary->pri_primary;\n  }\n  else if (tport_is_secondary(self) && tport_is_clear_to_send(self)) {\n\t/* self = self; */\n\t;\n  }\n  /*\n   * Try to find an already open connection to the destination,\n   * or get a primary protocol\n   */\n  \n  else {\n    /* If primary, resolve the destination address, store it in the msg */\n    if (tport_resolve(primary->pri_primary, msg, tpn) < 0) {\n      return NULL;\n    }\n    resolved = 1;\n\n\n    // DCH: iterate through all primaries\n    tport_t* secondary = NULL ;\n    tport_t* tp = tport_primaries( self ) ;\n    if (tp) {\n      do {\n        secondary = tport_by_addrinfo((tport_primary_t *)tp, msg_addrinfo(msg), tpn);\n        if (secondary) break;\n      } while(NULL != (tp = tport_next(tp)));\n    }\n\n    if( secondary ) {\n      self = secondary ;\n    }\n    else {\n      self = primary->pri_primary;      \n    }\n  }\n\n  if (tport_is_primary(self)) {\n    /* If primary, resolve the destination address, store it in the msg */\n    if (!resolved && tport_resolve(self, msg, tpn) < 0) {\n      return NULL;\n    }\n\n    if (tport_is_connection_oriented(self)\n\t|| self->tp_params->tpp_conn_orient) {\n#if 0 && HAVE_UPNP /* We do not want to use UPnP with secondary transports! */\n      if (upnp_register_upnp_client(1) != 0) {\n\tupnp_check_for_nat();\n      }\n#endif\n\n      tpn->tpn_proto = self->tp_protoname;\n\n      if (!cc)\n\ttpn->tpn_comp = NULL;\n\n      /* Create a secondary transport which is connected to the destination */\n      self = tport_connect(primary, msg_addrinfo(msg), tpn);\n\n#if 0 && HAVE_UPNP /* We do not want to use UPnP with secondary transports! */\n      upnp_deregister_upnp_client(0, 0);\n#endif\n\n      if (!self) {\n\tmsg_set_errno(msg, su_errno());\n        SU_DEBUG_9((\"tport_socket failed in tsend\\n\" VA_NONE));\n\treturn NULL;\n      }\n\n      if (cc)\n\ttport_sigcomp_assign(self, cc);\n    }\n  }\n  else if (tport_is_secondary(self)) {\n    cc = tport_sigcomp_assign_if_needed(self, cc);\n  }\n\n  if (cc == NULL)\n    tpn->tpn_comp = NULL;\n\n  if (tport_is_secondary(self)) {\n    /* Set the peer address to msg */\n    tport_peer_address(self, msg);\n    if (sdwn_after || close_after)\n      self->tp_reusable = 0;\n  }\n\n  if (self->tp_pri->pri_vtable->vtp_prepare\n      ? self->tp_pri->pri_vtable->vtp_prepare(self, msg, tpn, cc, mtu) < 0\n      : tport_prepare_and_send(self, msg, tpn, cc, mtu) < 0)\n    return NULL;\n  else\n    return self;\n}\n\nint tport_prepare_and_send(tport_t *self, msg_t *msg,\n\t\t\t   tp_name_t const *tpn,\n\t\t\t   struct sigcomp_compartment *cc,\n\t\t\t   unsigned mtu)\n{\n  int retval;\n\n  /* Prepare message for sending - i.e., encode it */\n  if (msg_prepare(msg) < 0) {\n    msg_set_errno(msg, errno);\t/* msg parser uses plain errno. Hmph. */\n    return -1;\n  }\n\n  if (msg_size(msg) > (usize_t)(mtu ? mtu : tport_mtu(self))) {\n    msg_set_errno(msg, EMSGSIZE);\n    return -1;\n  }\n\n  /*\n   * If there is already an queued message,\n   * put this message straight in the queue\n   */\n  if ((self->tp_queue && self->tp_queue[self->tp_qhead]) ||\n      /* ...or we are connecting */\n      (self->tp_events & (SU_WAIT_CONNECT | SU_WAIT_OUT))) {\n    if (tport_queue(self, msg) < 0) {\n      SU_DEBUG_9((\"tport_queue failed in tsend\\n\" VA_NONE));\n      return -1;\n    }\n    return 0;\n  }\n\n  retval = tport_send_msg(self, msg, tpn, cc);\n\n  tport_set_secondary_timer(self);\n\n  return retval;\n}\n\n\n/** Send a message.\n *\n * @retval 0 when succesful\n * @retval -1 upon an error\n */\nint tport_send_msg(tport_t *self, msg_t *msg,\n\t\t   tp_name_t const *tpn,\n\t\t   struct sigcomp_compartment *cc)\n{\n  msg_iovec_t *iov, auto_iov[40];\n  size_t iovlen, iovused, i, total;\n  size_t n;\n  ssize_t nerror;\n  int sdwn_after, close_after;\n  su_time_t now;\n  su_addrinfo_t *ai;\n\n  assert(self->tp_queue == NULL ||\n\t self->tp_queue[self->tp_qhead] == NULL ||\n\t self->tp_queue[self->tp_qhead] == msg);\n\n  if (self->tp_iov)\n    /* Use the heap-allocated I/O vector */\n    iov = self->tp_iov, iovlen = self->tp_iovlen;\n  else\n    /* Use the stack I/O vector */\n    iov = auto_iov, iovlen = sizeof(auto_iov)/sizeof(auto_iov[0]);\n\n  /* Get a iovec for message contents */\n  for (;;) {\n    iovused = msg_iovec(msg, iov, iovlen);\n    if (iovused <= iovlen)\n      break;\n\n    iov = su_realloc(self->tp_home, self->tp_iov, sizeof(*iov) * iovused);\n\n    if (iov == NULL) {\n      msg_set_errno(msg, errno);\n      return -1;\n    }\n\n    self->tp_iov = iov, self->tp_iovlen = iovlen = iovused;\n  }\n\n  assert(iovused > 0);\n\n  self->tp_stime = self->tp_ktime = now = su_now();\n\n  nerror = tport_vsend(self, msg, tpn, iov, iovused, cc);\n  SU_DEBUG_9((\"tport_vsend returned \"MOD_ZD\"\\n\", nerror));\n\n  if (nerror == -1)\n    return -1;\n\n  n = (size_t)nerror;\n\n  self->tp_unsent = NULL, self->tp_unsentlen = 0;\n\n  if (n > 0 && self->tp_master->mr_log && self->tp_slogged != msg) {\n    tport_log_msg(self, msg, \"send\", \"to\", now);\n    self->tp_slogged = msg;\n  }\n\n  for (i = 0, total = 0; i < iovused; i++) {\n    if (total + (size_t)iov[i].mv_len > n) {\n      if (tport_is_connection_oriented(self)) {\n\tiov[i].mv_len -= (su_ioveclen_t)(n - total);\n\tiov[i].mv_base = (char *)iov[i].mv_base + (n - total);\n\tif (tport_queue_rest(self, msg, &iov[i], iovused - i) < 0)\n\t  return tport_send_fatal(self, msg, tpn, \"tport_queue_rest\");\n\telse\n\t  return 0;\n      }\n      else {\n\tchar const *comp = tpn->tpn_comp;\n\n\tSU_DEBUG_1((\"%s(%p): send truncated for %s/%s:%s%s%s\\n\",\n\t\t    \"tport_vsend\", (void *)self, tpn->tpn_proto, tpn->tpn_host, tpn->tpn_port,\n\t\t    comp ? \";comp=\" : \"\", comp ? comp : \"\"));\n\n\tmsg_set_errno(msg, EIO);\n\treturn /* tport_send_fatal(self, msg, tpn, \"tport_send\") */ -1;\n      }\n    }\n\n    total += iov[i].mv_len;\n  }\n\n  /* We have sent a complete message */\n  tport_sent_message(self, msg, 0);\n\n  if (!tport_is_secondary(self))\n    return 0;\n\n  ai = msg_addrinfo(msg); assert(ai);\n  close_after = (ai->ai_flags & TP_AI_CLOSE) == TP_AI_CLOSE;\n  sdwn_after = (ai->ai_flags & TP_AI_SHUTDOWN) == TP_AI_SHUTDOWN ||\n    self->tp_send_close;\n\n  if (close_after || sdwn_after)\n    tport_shutdown0(self, close_after ? 2 : 1);\n\n  return 0;\n}\n\nstatic\nssize_t tport_vsend(tport_t *self,\n\t\t    msg_t *msg,\n\t\t    tp_name_t const *tpn,\n\t\t    msg_iovec_t iov[],\n\t\t    size_t iovused,\n\t\t    struct sigcomp_compartment *cc)\n{\n  ssize_t n;\n  su_addrinfo_t *ai = msg_addrinfo(msg);\n\n  if (cc) {\n    n = tport_send_comp(self, msg, iov, iovused, cc, self->tp_comp);\n  }\n  else {\n    ai->ai_flags &= ~TP_AI_COMPRESSED;\n    n = self->tp_pri->pri_vtable->vtp_send(self, msg, iov, iovused);\n  }\n\n  if (n == 0)\n    return 0;\n\n  if (n == -1)\n    return tport_send_error(self, msg, tpn, \"tport_vsend\");\n\n  tport_sent_bytes(self, n, n);\t/* Sigcomp will decrease on_line accodingly */\n\n  if (n > 0 && self->tp_master->mr_dump_file)\n    tport_dump_iovec(self, msg, n, iov, iovused, \"sent\", \"to\");\n    \n  if (n > 0 && self->tp_master->mr_capt_sock)\n      tport_capt_msg(self, msg, n, iov, iovused, \"sent\");\n              \n\n  if (tport_log->log_level >= 7) {\n    size_t i, m = 0;\n\n    for (i = 0; i < iovused; i++)\n      m += iov[i].mv_len;\n\n    if (tpn == NULL || tport_is_connection_oriented(self))\n      tpn = self->tp_name;\n\n    SU_DEBUG_7((\"%s(%p): \"MOD_ZU\" bytes of \"MOD_ZU\" to %s/%s:%s%s\\n\",\n\t\t\"tport_vsend\", (void *)self, n, m,\n\t\tself->tp_name->tpn_proto, tpn->tpn_host, tpn->tpn_port,\n\t\t(ai->ai_flags & TP_AI_COMPRESSED) ? \";comp=sigcomp\" : \"\"));\n  }\n\n  return n;\n}\n\nstatic\nint tport_send_error(tport_t *self, msg_t *msg, tp_name_t const *tpn,\n\t\t     char const *who)\n{\n  int error = su_errno();\n\n  if (error == EPIPE) {\n    /*Xyzzy*/\n  }\n\n  if (su_is_blocking(error)) {\n    su_addrinfo_t *ai = msg_addrinfo(msg);\n    char const *comp = (ai->ai_flags & TP_AI_COMPRESSED) ? \";comp=sigcomp\" : \"\";\n    SU_DEBUG_5((\"%s(%p): %s with (s=%d %s/%s:%s%s)\\n\",\n\t\twho, (void *)self, \"EAGAIN\", (int)self->tp_socket,\n\t\ttpn->tpn_proto, tpn->tpn_host, tpn->tpn_port, comp));\n    return 0;\n  }\n\n  msg_set_errno(msg, error);\n\n  return tport_send_fatal(self, msg, tpn, who);\n}\n\nstatic\nint tport_send_fatal(tport_t *self, msg_t *msg, tp_name_t const *tpn,\n\t\t     char const *who)\n{\n  su_addrinfo_t *ai = msg_addrinfo(msg);\n  char const *comp = (ai->ai_flags & TP_AI_COMPRESSED) ? \";comp=sigcomp\" : \"\";\n\n  int error = msg_errno(msg);\n\n  if (self->tp_addrinfo->ai_family == AF_INET) {\n    SU_DEBUG_3((\"%s(%p): %s with (s=%d %s/%s:%s%s)\\n\",\n\t\twho, (void *)self, su_strerror(error), (int)self->tp_socket,\n\t\ttpn->tpn_proto, tpn->tpn_host, tpn->tpn_port, comp));\n  }\n#if SU_HAVE_IN6\n  else if (self->tp_addrinfo->ai_family == AF_INET6) {\n    su_sockaddr_t const *su = (su_sockaddr_t const *)ai->ai_addr;\n    SU_DEBUG_3((\"%s(%p): %s with (s=%d, IP6=%s/%s:%s%s\"\n\t\t\" (scope=%i) addrlen=%u)\\n\",\n\t\twho, (void *)self, su_strerror(error), (int)self->tp_socket,\n\t\ttpn->tpn_proto, tpn->tpn_host, tpn->tpn_port, comp,\n\t\tsu->su_scope_id, (unsigned)ai->ai_addrlen));\n  }\n#endif\n  else {\n    SU_DEBUG_3((\"%s(%p): %s with (s=%d, AF=%u addrlen=%u)%s\\n\",\n\t\twho, (void *)self, su_strerror(error),\n\t\t(int)self->tp_socket, ai->ai_family, (unsigned)ai->ai_addrlen, comp));\n  }\n\n#if 0\n  int i;\n  for (i = 0; i < iovused; i++)\n    SU_DEBUG_7((\"\\t\\tiov[%d] = { %d bytes @ %p }\\n\",\n\t\ti, iov[i].siv_len, (void *)iov[i].siv_base));\n#endif\n\n  if (tport_is_connection_oriented(self)) {\n    tport_error_report(self, error, NULL);\n    if (tport_has_connection(self))\n      tport_close(self);\n  }\n\n  return -1;\n}\n\n\nstatic\nint tport_queue_rest(tport_t *self,\n\t\t     msg_t *msg,\n\t\t     msg_iovec_t iov[],\n\t\t     size_t iovused)\n{\n  size_t iovlen = self->tp_iovlen;\n\n  assert(tport_is_connection_oriented(self));\n  assert(self->tp_queue == NULL ||\n\t self->tp_queue[self->tp_qhead] == NULL ||\n\t self->tp_queue[self->tp_qhead] == msg);\n\n  if (tport_queue(self, msg) < 0)\n    return -1;\n\n  assert(self->tp_queue[self->tp_qhead] == msg);\n\n  if (self->tp_iov == NULL) {\n    if (iovlen < 40) iovlen = 40;\n    if (iovlen < iovused) iovlen = iovused;\n    self->tp_iov = su_alloc(self->tp_home, iovlen * sizeof(iov[0]));\n    self->tp_iovlen = iovlen;\n\n    if (!self->tp_iov) {\n      msg_set_errno(msg, errno);\n      return -1;\n    }\n\n    memcpy(self->tp_iov, iov, iovused * sizeof(iov[0]));\n\n    iov = self->tp_iov;\n  }\n\n  self->tp_unsent = iov;\n  self->tp_unsentlen = iovused;\n\n  /* the POLLOUT event is far too unreliable with SCTP */\n  if (self->tp_addrinfo->ai_protocol == IPPROTO_SCTP)\n    return 0;\n\n  /* Ask for a send event */\n  tport_set_events(self, SU_WAIT_OUT, 0);\n\n  return 0;\n}\n\n/** Queue a message to transport.\n *\n * The tport_tqueue() function queues a message in the send queue. It is\n * used by an (server) application that is required to send (response)\n * messages in certain order. For example, a HTTP server or proxy may\n * receive multiple requests from a single TCP connection. The server is\n * required to answer to the requests in same order as they are received.\n * The responses are, however, sometimes generated asynchronously, that is,\n * a response to a later request may be ready earlier. For that purpose, the\n * HTTP protocol stack queues an empty response message immediately upon\n * receiving a request. Other messages cannot be sent before the queued one.\n *\n * The function tport_tqsend() is used to send the completed response message.\n *\n * @param self pointer to transport object\n * @param msg  message to be inserted into queue\n * @param tag,value,... tagged argument list\n *\n * @TAGS\n * @par Currently none.\n *\n * @retval 0 when successful\n * @retval -1 upon an error\n\n * @ERRORS\n * @ERROR EINVAL  Invalid argument(s).\n * @ERROR ENOMEM  Memory was exhausted.\n * @ERROR ENOBUFS The transport object queue was full.\n *\n * @deprecated Alternative interface will be provided in near future.\n *\n * @sa tport_tqsend()\n */\nint tport_tqueue(tport_t *self, msg_t *msg,\n\t\t tag_type_t tag, tag_value_t value, ...)\n{\n  msg_unprepare(msg);\n\n  return tport_queue(self, msg);\n}\n\n/** Return number of queued messages. */\nisize_t tport_queuelen(tport_t const *self)\n{\n  isize_t retval = 0;\n\n  if (self && self->tp_queue) {\n    unsigned short i, N = self->tp_params->tpp_qsize;\n\n    for (i = self->tp_qhead; self->tp_queue[i] && retval < N; i = (i + 1) % N)\n      retval++;\n  }\n\n  return retval;\n}\n\nstatic\nint tport_queue(tport_t *self, msg_t *msg)\n{\n  unsigned short qhead = self->tp_qhead;\n  unsigned short N = self->tp_params->tpp_qsize;\n\n  SU_DEBUG_7((\"tport_queue(%p): queueing %p for %s/%s:%s\\n\",\n\t      (void *)self, (void *)msg,\n\t      self->tp_protoname, self->tp_host, self->tp_port));\n\n  if (self->tp_queue == NULL) {\n    assert(N > 0);\n    assert(qhead == 0);\n    self->tp_queue = su_zalloc(self->tp_home, N * sizeof(msg));\n    if (!self->tp_queue) {\n      msg_set_errno(msg, errno);\n      return -1;\n    }\n  }\n\n  if (self->tp_queue[qhead] == msg)\n    return 0;\n\n  while (self->tp_queue[qhead]) {\n    qhead = (qhead + 1) % N;\n    if (qhead == self->tp_qhead) {\n      msg_set_errno(msg, ENOBUFS);\n      return -1;\n    }\n  }\n\n  self->tp_queue[qhead] = msg_ref_create(msg);\n\n  return 0;\n}\n\n/** Send a queued message (and queue another, if required).\n *\n * The function tport_tqsend() sends a message to the transport.\n *\n * @deprecated Alternative interface will be provided in near future.\n */\nint tport_tqsend(tport_t *self, msg_t *msg, msg_t *next,\n\t\t tag_type_t tag, tag_value_t value, ...)\n{\n  unsigned short qhead;\n  ta_list ta;\n  int reuse, sdwn_after, close_after;\n  unsigned short N;\n  su_addrinfo_t *ai;\n\n  if (self == NULL)\n    return -1;\n\n  qhead = self->tp_qhead;\n  N = self->tp_params->tpp_qsize;\n  reuse = self->tp_reusable;\n  sdwn_after = 0;\n  close_after = 0;\n\n  ta_start(ta, tag, value);\n\n  tl_gets(ta_args(ta),\n\t  TPTAG_REUSE_REF(reuse),\n\t  TPTAG_SDWN_AFTER_REF(sdwn_after),\n\t  TPTAG_CLOSE_AFTER_REF(close_after),\n\t  TAG_END());\n\n  ta_end(ta);\n\n  /* If \"next\", make sure we can queue it */\n  if (next && self->tp_queue[qhead == 0 ? N - 1 : qhead - 1]) {\n    msg_set_errno(next, ENOBUFS);\n    return -1;\n  }\n\n  /* Prepare message for sending - i.e., encode it */\n  if (msg_prepare(msg) < 0) {\n    msg_set_errno(msg, errno);\n    return -1;\n  }\n\n  tport_peer_address(self, msg);  /* Set addrinfo */\n  if (next == NULL) {\n    ai = msg_addrinfo(msg);\n\n    if (sdwn_after)\n      ai->ai_flags |= TP_AI_SHUTDOWN;\n    if (close_after)\n      ai->ai_flags |= TP_AI_CLOSE;\n\n    if (self->tp_queue[qhead] == msg) {\n      tport_send_queue(self);\n      tport_set_secondary_timer(self);\n    }\n    return 0;\n  }\n\n  ai = msg_addrinfo(next);\n\n  if (sdwn_after)\n    ai->ai_flags |= TP_AI_SHUTDOWN;\n  if (close_after)\n    ai->ai_flags |= TP_AI_CLOSE;\n\n  if (self->tp_queue[qhead] == msg) {\n    /* XXX - what about errors? */\n    tport_send_msg(self, msg, self->tp_name, NULL);\n    tport_set_secondary_timer(self);\n    if (!self->tp_unsent) {\n      msg_destroy(self->tp_queue[qhead]);\n      if ((self->tp_queue[qhead] = msg_ref_create(next)))\n\tmsg_unprepare(next);\n      return 0;\n    }\n  }\n\n  while (self->tp_queue[qhead] && self->tp_queue[qhead] != msg) {\n    qhead = (qhead + 1) % N;\n    if (qhead == self->tp_qhead)\n      break;\n  }\n\n  if (self->tp_queue[qhead] != msg) {\n    msg_set_errno(next, EINVAL);\n    return -1;\n  }\n\n  msg = msg_ref_create(next);\n\n  do {\n    qhead = (qhead + 1) % N;\n    next = self->tp_queue[qhead]; self->tp_queue[qhead] = msg; msg = next;\n    /* Above we made sure that there is an empty slot */\n    assert(!next || qhead != self->tp_qhead);\n  } while (next);\n\n  return 0;\n}\n\n/** Send event.\n *\n * Process SU_WAIT_OUT event.\n */\nvoid tport_send_event(tport_t *self)\n{\n  assert(tport_is_connection_oriented(self));\n\n  SU_DEBUG_7((\"tport_send_event(%p) - ready to send to (%s/%s:%s)\\n\",\n\t      (void *)self, self->tp_protoname, self->tp_host, self->tp_port));\n  tport_send_queue(self);\n  tport_set_secondary_timer(self);\n}\n\n/** Send queued messages */\nvoid tport_send_queue(tport_t *self)\n{\n  msg_t *msg;\n  msg_iovec_t *iov;\n  size_t i, iovused, n, total;\n  unsigned short qhead = self->tp_qhead, N = self->tp_params->tpp_qsize;\n\n  assert(self->tp_queue && self->tp_queue[qhead]);\n\n  msg = self->tp_queue[qhead];\n\n  iov = self->tp_unsent, self->tp_unsent = NULL;\n  iovused = self->tp_unsentlen, self->tp_unsentlen = 0;\n\n  if (iov && iovused) {\n    ssize_t e;\n\n    self->tp_stime = self->tp_ktime = su_now();\n\n    e = tport_vsend(self, msg, self->tp_name, iov, iovused, NULL);\n\n    if (e == -1)\t\t\t\t/* XXX */\n      return;\n\n    n = (size_t)e;\n\n    if (n > 0 && self->tp_master->mr_log && self->tp_slogged != msg) {\n      tport_log_msg(self, msg, \"send\", \"to\", self->tp_stime);\n      self->tp_slogged = msg;\n    }\n\n    for (i = 0, total = 0; i < iovused; i++) {\n      if (total + (size_t)iov[i].mv_len > n) {\n\tiov[i].mv_len -= (su_ioveclen_t)(n - total);\n\tiov[i].mv_base = (char *)iov[i].mv_base + (n - total);\n\n\tself->tp_unsent = iov + i;\n\tself->tp_unsentlen = iovused - i;\n\n\treturn;\n      }\n      total += iov[i].mv_len;\n    }\n    assert(total == n);\n\n    /* We have sent a complete message */\n\n    self->tp_queue[qhead] = NULL;\n    tport_sent_message(self, msg, 0);\n    msg_destroy(msg);\n\n    qhead = (qhead + 1) % N;\n  }\n\n  while (msg_is_prepared(msg = self->tp_queue[self->tp_qhead = qhead])) {\n    /* XXX - what about errors? */\n    tport_send_msg(self, msg, self->tp_name, NULL);\n    if (self->tp_unsent)\n      return;\n\n    msg = self->tp_queue[qhead]; /* tport_send_msg() may flush queue! */\n    self->tp_queue[qhead] = NULL;\n    msg_destroy(msg);\n    qhead = (qhead + 1) % N;\n  }\n\n  /* No more send event(s)? */\n  tport_set_events(self, 0, SU_WAIT_OUT);\n}\n\nstatic int msg_select_addrinfo(msg_t *msg, su_addrinfo_t *res);\n\nstatic int\ntport_resolve(tport_t *self, msg_t *msg, tp_name_t const *tpn)\n{\n  int error;\n  char ipaddr[TPORT_HOSTPORTSIZE];\n  su_addrinfo_t *res, hints[1] = {{ 0 }};\n  char const *host;\n  su_sockaddr_t *su;\n\n  hints->ai_socktype = self->tp_addrinfo->ai_socktype;\n  hints->ai_protocol = self->tp_addrinfo->ai_protocol;\n\n  if (host_is_ip6_reference(tpn->tpn_host)) {\n    /* Remove [] around IPv6 address */\n    size_t len = strlen(tpn->tpn_host);\n    assert(len < sizeof ipaddr);\n    host = memcpy(ipaddr, tpn->tpn_host + 1, len - 2);\n    ipaddr[len - 2] = '\\0';\n    hints->ai_flags |= AI_NUMERICHOST;\n  }\n  else {\n#if HAVE_OPEN_C\n    if (host_is_ip_address(tpn->tpn_host))\n      hints->ai_flags |= AI_NUMERICHOST;\n#endif\n    host = tpn->tpn_host;\n  }\n\n  if ((error = su_getaddrinfo(host, tpn->tpn_port, hints, &res))) {\n    SU_DEBUG_3((\"tport_resolve: getaddrinfo(\\\"%s\\\":%s): %s\\n\",\n\t\ttpn->tpn_host, tpn->tpn_port,\n\t\tsu_gai_strerror(error)));\n    msg_set_errno(msg, ENXIO);\n    return -1;\n  }\n\n  error = msg_select_addrinfo(msg, res);\n\n  su = (su_sockaddr_t *) msg_addrinfo(msg)->ai_addr;\n\n#if SU_HAVE_IN6\n  SU_DEBUG_9((\"tport_resolve addrinfo = %s%s%s:%d\\n\",\n\t      su->su_family == AF_INET6 ? \"[\" : \"\",\n              su_inet_ntop(su->su_family, SU_ADDR(su), ipaddr, sizeof(ipaddr)),\n\t      su->su_family == AF_INET6 ? \"]\" : \"\",\n              htons(su->su_port)));\n#else\n  SU_DEBUG_9((\"tport_resolve addrinfo = %s%s%s:%d\\n\",\n\t      \"\",\n              su_inet_ntop(su->su_family, SU_ADDR(su), ipaddr, sizeof(ipaddr)),\n\t      \"\",\n              htons(su->su_port)));\n#endif\n\n  su_freeaddrinfo(res);\n\n  return error;\n}\n\nstatic int\nmsg_select_addrinfo(msg_t *msg, su_addrinfo_t *res)\n{\n  su_addrinfo_t *ai, *mai = msg_addrinfo(msg);\n  su_sockaddr_t *su = (su_sockaddr_t *)mai->ai_addr;\n\n  for (ai = res; ai; ai = ai->ai_next) {\n#if SU_HAVE_IN6\n    if (ai->ai_family != AF_INET && ai->ai_family != AF_INET6)\n      continue;\n#else\n    if (ai->ai_family != AF_INET)\n      continue;\n#endif\n\n    if (ai->ai_protocol == 0)\n      continue;\n    if (ai->ai_addrlen > sizeof(su_sockaddr_t))\n      continue;\n\n    mai->ai_family = ai->ai_family;\n    mai->ai_socktype = ai->ai_socktype;\n    mai->ai_protocol = ai->ai_protocol;\n\n    if (ai->ai_addrlen < sizeof(su_sockaddr_t))\n      memset(su, 0, sizeof(su_sockaddr_t));\n    memcpy(su, ai->ai_addr, ai->ai_addrlen);\n    if (su_sockaddr_size(su))\n      mai->ai_addrlen = su_sockaddr_size(su);\n    else\n      mai->ai_addrlen = ai->ai_addrlen;\n    return 0;\n  }\n\n  msg_set_errno(msg, EAFNOSUPPORT);\n\n  return -1;\n}\n\n/** Copy peer address to msg */\nvoid\ntport_peer_address(tport_t *self, msg_t *msg)\n{\n  su_addrinfo_t *mai = msg_addrinfo(msg);\n  su_addrinfo_t const *tai = self->tp_addrinfo;\n  void *maddr = mai->ai_addr;\n  int flags = mai->ai_flags;\n\n  memcpy(mai, tai, sizeof *mai);\n  mai->ai_addr = memcpy(maddr, tai->ai_addr, tai->ai_addrlen);\n  mai->ai_flags = flags;\n}\n\n/** Process error event.\n *\n * Return events that can be processed afterwards.\n */\nint tport_error_event(tport_t *self)\n{\n  int errcode;\n  su_sockaddr_t name[1] = {{ 0 }};\n\n  name->su_family = AF_UNSPEC; /* 0 */\n\n  if (tport_is_udp(self)) {\n    errcode = tport_udp_error(self, name);\n  }\n  else {\n    /* Process error event for basic transport. */\n    errcode = su_soerror(self->tp_socket);\n  }\n\n  if (errcode == 0 || errcode == EPIPE)\n    return errcode;\n\n  tport_error_report(self, errcode, name);\n\n  return 0;\n}\n\n/** Mark message as waiting for a response.\n *\n * @return Positive integer, or -1 upon an error.\n */\nint tport_pend(tport_t *self,\n\t       msg_t *msg,\n\t       tport_pending_error_f *callback,\n\t       tp_client_t *client)\n{\n  tport_pending_t *pending;\n\n  if (self == NULL || callback == NULL)\n    return -1;\n\n  if (msg == NULL && tport_is_primary(self))\n    return -1;\n\n  SU_DEBUG_7((\"tport_pend(%p): pending %p for %s/%s:%s (already %u)\\n\",\n\t      (void *)self, (void *)msg,\n\t      self->tp_protoname, self->tp_host, self->tp_port,\n\t      self->tp_pused));\n\n  if (self->tp_released == NULL) {\n    unsigned i, len = 8;\n    if (self->tp_plen)\n      len = 2 * self->tp_plen;\n    pending = su_realloc(self->tp_home,\n\t\t\t self->tp_pending, len * sizeof(*pending));\n    if (!pending) {\n      msg_set_errno(msg, errno);\n      return -1;\n    }\n\n    memset(pending + self->tp_plen, 0, (len - self->tp_plen) * sizeof(*pending));\n\n    for (i = self->tp_plen; i + 1 < len; i++)\n      pending[i].p_client = pending + i + 1;\n\n    self->tp_released = pending + self->tp_plen;\n    self->tp_pending = pending;\n    self->tp_plen = len;\n  }\n\n  pending = self->tp_released;\n  self->tp_released = pending->p_client;\n\n  pending->p_callback = callback;\n  pending->p_client = client;\n  pending->p_msg = msg;\n  pending->p_reported = self->tp_reported;\n\n  self->tp_pused++;\n\n  return (pending - self->tp_pending) + 1;\n}\n\n/** Mark message as no more pending */\nint tport_release(tport_t *self,\n\t\t  int pendd,\n\t\t  msg_t *msg,\n\t\t  msg_t *reply,\n\t\t  tp_client_t *client,\n\t\t  int still_pending)\n{\n  tport_pending_t *pending;\n\n  if (self == NULL || pendd <= 0 || pendd > (int)self->tp_plen)\n    return su_seterrno(EINVAL), -1;\n\n  pending = self->tp_pending + (pendd - 1);\n\n  if (pending->p_client != client ||\n      pending->p_msg != msg) {\n\t  SU_DEBUG_1((\"%s(%p): %u %p by %p not pending\\n\",\n\t\t      __func__, (void *)self,\n\t\t      pendd, (void *)msg, (void *)client));\n    return su_seterrno(EINVAL), -1;\n  }\n\n  SU_DEBUG_7((\"%s(%p): %p by %p with %p%s\\n\",\n\t      __func__, (void *)self,\n\t      (void *)msg, (void *)client, (void *)reply,\n\t      still_pending ? \" (preliminary)\" : \"\"));\n\n  /* sigcomp can here associate request (msg) with response (reply) */\n\n  if (still_pending)\n    return 0;\n\n  /* Just to make sure nobody uses stale data */\n  memset(pending, 0, sizeof(*pending));\n  pending->p_client = self->tp_released;\n  self->tp_released = pending;\n  self->tp_pused--;\n  return 0;\n}\n\n/** Report error to pending messages with destination */\nint\ntport_pending_error(tport_t *self, su_sockaddr_t const *dst, int error)\n{\n  unsigned i, reported, callbacks;\n  tport_pending_t *pending;\n  msg_t *msg;\n  su_addrinfo_t const *ai;\n\n  assert(self);\n\n  callbacks = 0;\n  reported = ++self->tp_reported;\n\n  if (self->tp_pused == 0)\n    return 0;\n\n  for (i = 0; i < self->tp_plen; i++) {\n    pending = self->tp_pending + i;\n\n    if (!pending->p_callback)\n      continue;\n\n    if (pending->p_reported == reported)\n      continue;\n\n    msg = pending->p_msg;\n\n    if (dst && msg) {\n      ai = msg_addrinfo(msg);\n\n      if (su_cmp_sockaddr(dst, (su_sockaddr_t *)ai->ai_addr) != 0)\n\tcontinue;\n    }\n\n    msg_set_errno(msg, error);\n\n    pending->p_reported = reported;\n\n    pending->p_callback(self->TP_STACK, pending->p_client, self, msg, error);\n\n    callbacks++;\n  }\n\n  return callbacks;\n}\n\n\n/** Report error via pending message */\nint\ntport_pending_errmsg(tport_t *self, msg_t *msg, int error)\n{\n  unsigned i, reported, callbacks;\n  tport_pending_t *pending;\n\n  assert(self); assert(msg);\n\n  callbacks = 0;\n  reported = ++self->tp_reported;\n\n  msg_set_errno(msg, error);\n\n  if (self->tp_pused == 0)\n    return 0;\n\n  for (i = 0; i < self->tp_plen; i++) {\n    pending = self->tp_pending + i;\n\n    if (!pending->p_client ||\n\tpending->p_msg != msg ||\n\tpending->p_reported == reported)\n      continue;\n\n    pending->p_reported = reported;\n\n    pending->p_callback(self->TP_STACK, pending->p_client, self, msg, error);\n\n    callbacks++;\n  }\n\n  return callbacks;\n}\n\n\n/** Set transport magic. */\nvoid tport_set_magic(tport_t *self, tp_magic_t *magic)\n{\n  self->tp_magic = magic;\n}\n\n/** Get transport magic. */\ntp_magic_t *tport_magic(tport_t const *self)\n{\n  return self ? self->tp_magic : NULL;\n}\n\n/** Get primary transport (or self, if primary) */\ntport_t *tport_parent(tport_t const *self)\n{\n  return self ? self->tp_pri->pri_primary : NULL;\n}\n\n/** Get list of primary transports */\ntport_t *tport_primaries(tport_t const *self)\n{\n  if (self)\n    return self->tp_master->mr_primaries->pri_primary;\n  else\n    return NULL;\n}\n\n/** Get next transport */\ntport_t *tport_next(tport_t const *self)\n{\n  if (self == NULL)\n    return NULL;\n  else if (tport_is_master(self))\n    return ((tport_master_t *)self)->mr_primaries->pri_primary;\n\n  else if (tport_is_primary(self))\n    return ((tport_primary_t *)self)->pri_next->pri_primary;\n  else\n    return tprb_succ(self);\n}\n\n/** Get secondary transports. */\ntport_t *tport_secondary(tport_t const *self)\n{\n  if (tport_is_primary(self))\n    return self->tp_pri->pri_open;\n  else\n    return NULL;\n}\n\n#if 0\nvoid tport_hints(tport_t const *self, su_addrinfo_t *hints)\n{\n  hints->ai_protocol = self->tp_addrinfo->ai_protocol;\n  hints->ai_socktype = self->tp_addrinfo->ai_socktype;\n}\n#endif\n\n/** Get transport address list. */\nsu_addrinfo_t const *tport_get_address(tport_t const *self)\n{\n  return self ? self->tp_addrinfo : NULL;\n}\n\n/** Get transport name. */\ntp_name_t const *tport_name(tport_t const *self)\n{\n  return self->tp_name;\n}\n\n/** Get transport identifier. */\nchar const *tport_ident(tport_t const *self)\n{\n  return self ? self->tp_ident : NULL;\n}\n\n/** Get transport by protocol name. */\ntport_t *tport_by_protocol(tport_t const *self, char const *proto)\n{\n  if (proto && strcmp(proto, tpn_any) != 0) {\n    for (; self; self = tport_next(self))\n      if (su_casematch(proto, self->tp_protoname))\n\tbreak;\n  }\n\n  return (tport_t *)self;\n}\n#ifdef SOFIA_TPORT_DEBUG_TRACE\nvoid tport_debug( tport_t const *tp ) {\n  tport_primary_t const *self = tp->tp_master->mr_primaries ;\n  int i = 0 ;\n  for (; self; self = self->pri_next, i++) {\n    tp = self->pri_primary;\n    SU_DEBUG_9((\"tport_debug: loop %d \\n\", i));\n    SU_DEBUG_9((\"tport_primary_by_name: tp %ld \\n\", (unsigned long) (void *)tp));\n    SU_DEBUG_9((\"tport_primary_by_name: ai_family %d \\n\", tp->tp_addrinfo->ai_family));\n  }\n}\n#endif\n/** Get transport by protocol name. */\ntport_t *tport_primary_by_name(tport_t const *tp, tp_name_t const *tpn)\n{\n  char const *ident = tpn->tpn_ident;\n  char const *proto = tpn->tpn_proto;\n  char const *comp = tpn->tpn_comp;\n  int family = 0;\n  const tport_t* tport_default = NULL;\n  tport_t* tport_best_match = NULL;\n  int octet_count = 0;\n\n  tport_primary_t const *self, *nocomp = NULL;\n\n  self = tp ? tp->tp_master->mr_primaries : NULL;\n\n  if (ident && strcmp(ident, tpn_any) == 0)\n    ident = NULL;\n\n  if (tpn->tpn_host == NULL)\n    family = 0;\n#if SU_HAVE_IN6\n  else if (host_is_ip6_address(tpn->tpn_host))\n    family = AF_INET6;\n#endif\n  else if (host_is_ip4_address(tpn->tpn_host))\n    family = AF_INET;\n  else\n    family = 0;\n\n  if (proto && strcmp(proto, tpn_any) == 0)\n    proto = NULL;\n\n  if (!ident && !proto && !family && !comp)\n    return (tport_t *)self;   /* Anything goes */\n\n  comp = tport_canonize_comp(comp);\n\n  for (; self; self = self->pri_next) {\n    const tport_t* current = (tport_t *) self;\n    char szRemote[64];\n    char szLocal[64];\n\n    tp = self->pri_primary;\n\n    if (ident && strcmp(ident, tp->tp_ident))\n      continue;\n    if (family) {\n      if (family == AF_INET && !tport_has_ip4(tp)) \n  continue;\n#if SU_HAVE_IN6\n      if (family == AF_INET6 && !tport_has_ip6(tp))\n  continue;\n#endif\n    }\n    if (proto && !su_casematch(proto, tp->tp_protoname))\n      continue;\n\n    if (comp && comp != tp->tp_name->tpn_comp) {\n      if (tp->tp_name->tpn_comp == NULL && nocomp == NULL)\n  nocomp = self;\n      continue;\n    }\n\n    //break;\n    if (!tport_default) tport_default = tp ;\n\n    strncpy(szRemote, tpn->tpn_host, 64);\n    strncpy(szLocal, current->tp_name->tpn_host, 64);\n\n    char *pLocal[4] = {0,0,0,0};\n    char *pRemote[4] = {0,0,0,0};\n\n    int i = 0;\n    char* rest = szLocal;\n    char* token ;\n    while (NULL != (token = strtok_r(rest, \".\", &rest)) && i < 4) {\n       pLocal[i++] = token;\n    }\n\n    i = 0;\n    rest = szRemote;\n    while (NULL != (token = strtok_r(rest, \".\", &rest)) && i < 4) {\n       pRemote[i++] = token;\n    }\n\n    int count = 0;\n    int j = 0;\n    for (j = 0; j < 4; j++) {\n      if (NULL == pLocal[j] || NULL == pRemote[j]) break;\n      if (0 != strcmp(pLocal[j], pRemote[j])) break;\n      count++;\n    }\n\n    if (count > octet_count) {\n      octet_count = count;\n      tport_best_match = (tport_t *) current;\n    }\n  }\n\n  if (tport_best_match) return (tport_t *) tport_best_match;\n  if (tport_default) return (tport_t *) tport_default;\n\n  return (tport_t *)nocomp;\n}\n\n\n/** Get transport by name. */\ntport_t *tport_by_name(tport_t const *self, tp_name_t const *tpn)\n{\n  tport_t const *sub, *next;\n  char const *canon, *host, *port, *comp;\n#if SU_HAVE_IN6\n  char *end, ipaddr[TPORT_HOSTPORTSIZE];\n#endif\n\n  assert(self); assert(tpn);\n\n  assert(tpn->tpn_proto); assert(tpn->tpn_host); assert(tpn->tpn_port);\n  assert(tpn->tpn_canon);\n\n  if (!tport_is_primary(self))\n    self = tport_primary_by_name(self, tpn);\n\n  host = strcmp(tpn->tpn_host, tpn_any) ? tpn->tpn_host : NULL;\n  port = strcmp(tpn->tpn_port, tpn_any) ? tpn->tpn_port : NULL;\n  canon = tpn->tpn_canon;\n  comp = tport_canonize_comp(tpn->tpn_comp);\n\n  if (self && host && port) {\n    int resolved = 0, cmp;\n    socklen_t sulen;\n    su_sockaddr_t su[1];\n\n    sub = self->tp_pri->pri_open;\n\n    memset(su, 0, sizeof su);\n\n#if SU_HAVE_IN6\n    if (host_is_ip6_reference(host)) {\n      /* Remove [] around IPv6 address */\n      host = strncpy(ipaddr, host +  1, sizeof(ipaddr) - 1);\n      ipaddr[sizeof(ipaddr) - 1] = '\\0';\n      if ((end = strchr(host, ']')))\n\t*end = 0;\n      su->su_len = sulen = (socklen_t) sizeof (struct sockaddr_in6);\n      su->su_family = AF_INET6;\n    }\n    else if (host_is_ip6_address(host)) {\n      su->su_len = sulen = (socklen_t) sizeof (struct sockaddr_in6);\n      su->su_family = AF_INET6;\n    }\n    else\n#endif\n    {\n      su->su_len = sulen = (socklen_t) sizeof (struct sockaddr_in);\n      su->su_family = AF_INET;\n    }\n\n    su->su_port = htons(strtoul(port, NULL, 10));\n\n    if (su_inet_pton(su->su_family, host, SU_ADDR(su)) > 0) {\n      resolved = 1;\n      next = NULL;\n\n      /* Depth-first search */\n      while (sub) {\n\tcmp = (int)((size_t)sub->tp_addrlen - (size_t)sulen);\n\n\tif (cmp == 0)\n\t  cmp = memcmp(sub->tp_addr, su, sulen);\n\n\tif (cmp == 0) {\n\t  if (sub->tp_left) {\n\t    next = sub;\n\t    sub = sub->tp_left;\n\t    continue;\n\t  }\n\t  break;\n\t}\n\telse if (next) {\n\t  sub = next;\n\t  break;\n\t}\n\telse if (cmp > 0) {\n\t  sub = sub->tp_left;\n\t  continue;\n\t}\n\telse /* if (cmp < 0) */ {\n\t  sub = sub->tp_right;\n\t  continue;\n\t}\n      }\n    }\n    else {\n      SU_DEBUG_7((\"tport(%p): EXPENSIVE unresolved \" TPN_FORMAT \"\\n\",\n\t\t  (void *)self, TPN_ARGS(tpn)));\n\n      sub = tprb_first(sub);\n    }\n\n    for (; sub; sub = tprb_succ(sub)) {\n      if (!sub->tp_reusable)\n\tcontinue;\n      if (!tport_is_registered(sub))\n\tcontinue;\n      if (tport_is_shutdown(sub))\n\tcontinue;\n\n      if (comp != sub->tp_name->tpn_comp)\n\tcontinue;\n\n      if (resolved) {\n\tif ((socklen_t)sub->tp_addrlen != sulen ||\n\t    memcmp(sub->tp_addr, su, sulen)) {\n\t  //SU_DEBUG_7((\"tport(%p): not found by name \" TPN_FORMAT \"\\n\",\n\t\t//      (void *)self, TPN_ARGS(tpn)));\n\t  break;\n\t}\n\tSU_DEBUG_7((\"tport(%p): found %p by name \" TPN_FORMAT \"\\n\",\n\t\t    (void *)self, (void *)sub, TPN_ARGS(tpn)));\n      }\n      else if (!su_casematch(port, sub->tp_port))\n\tcontinue;\n      else if (!su_casematch(canon, sub->tp_canon) &&\n\t       !su_casematch(host, sub->tp_host))\n\tcontinue;\n\n      return (tport_t *)sub;\n    }\n  }\n\n  return (tport_t *)self;\n}\n\n/** Get transport from primary by addrinfo. */\ntport_t *tport_by_addrinfo(tport_primary_t const *pri,\n\t\t\t   su_addrinfo_t const *ai,\n\t\t\t   tp_name_t const *tpn)\n{\n  tport_t const *sub, *maybe;\n  struct sockaddr const *sa;\n  int cmp;\n  char const *comp;\n\n  assert(pri); assert(ai);\n\n  sa = ai->ai_addr;\n\n  sub = pri->pri_open, maybe = NULL;\n\n  comp = tport_canonize_comp(tpn->tpn_comp);\n\n  /* Find leftmost (prevmost) matching tport */\n  while (sub) {\n    cmp = (int)(sub->tp_addrlen - ai->ai_addrlen);\n    if (cmp == 0)\n      cmp = memcmp(sub->tp_addr, sa, ai->ai_addrlen);\n\n    if (cmp == 0) {\n      if (sub->tp_left) {\n\tmaybe = sub;\n\tsub = sub->tp_left;\n\tcontinue;\n      }\n      break;\n    }\n    else if (maybe) {\n      sub = maybe;\n      break;\n    }\n    else if (cmp > 0) {\n      sub = sub->tp_left;\n      continue;\n    }\n    else /* if (cmp < 0) */ {\n      sub = sub->tp_right;\n      continue;\n    }\n  }\n\n  for (; sub; sub = tprb_succ(sub)) {\n    if (!sub->tp_reusable)\n      continue;\n    if (!tport_is_registered(sub))\n      continue;\n    if (tport_is_shutdown(sub))\n      continue;\n\n    if (tport_has_tls(sub) && !su_casematch(tpn->tpn_canon, sub->tp_name->tpn_canon)) {\n      if (!tport_is_verified(sub))\n        continue;\n      if (!tport_subject_search(tpn->tpn_canon, sub->tp_subjects))\n        continue;\n    }\n\n    if (comp != sub->tp_name->tpn_comp)\n      continue;\n\n    if (sub->tp_addrlen != ai->ai_addrlen\n\t|| memcmp(sub->tp_addr, sa, ai->ai_addrlen)) {\n      sub = NULL;\n      break;\n    }\n    break;\n  }\n\n  if (sub) {\n    SU_DEBUG_9((\"%s(%p): found %p by name \" TPN_FORMAT \"\\n\",\n\t\t__func__, (void *)pri, (void *)sub, TPN_ARGS(tpn)));\n  }\n  else {\n    SU_DEBUG_9((\"%s(%p): not found by name \" TPN_FORMAT \"\\n\",\n\t\t__func__, (void *)pri, TPN_ARGS(tpn)));\n  }\n  return (tport_t *)sub;\n}\n\n\n/** Get transport name from URL. */\nint tport_name_by_url(su_home_t *home,\n\t\t      tp_name_t *tpn,\n\t\t      url_string_t const *us)\n{\n  size_t n;\n  url_t url[1];\n  char *b;\n\n  n = url_xtra(us->us_url);\n  b = su_alloc(home, n);\n\n  if (b == NULL || url_dup(b, n, url, us->us_url) < 0) {\n    su_free(home, b);\n    return -1;\n  }\n\n  tpn->tpn_proto = url_tport_default((enum url_type_e)url->url_type);\n  tpn->tpn_canon = url->url_host;\n  tpn->tpn_host = url->url_host;\n  tpn->tpn_port = url_port(url);\n\n  if (tpn->tpn_host == NULL || tpn->tpn_host[0] == '\\0' ||\n      tpn->tpn_port == NULL || tpn->tpn_port[0] == '\\0') {\n    su_free(home, b);\n    return -1;\n  }\n\n  if (url->url_params) {\n    for (b = (char *)url->url_params; b[0]; b += n) {\n      n = strcspn(b, \";\");\n\n      if (n > 10 && su_casenmatch(b, \"transport=\", 10))\n\ttpn->tpn_proto = b + 10;\n      else if (n > 6 && su_casenmatch(b, \"maddr=\", 6))\n\ttpn->tpn_host = b + 6;\n\n      if (b[n])\n\tb[n++] = '\\0';\n    }\n  }\n\n  return 0;\n}\n\n/** Check if transport named is already resolved */\nint tport_name_is_resolved(tp_name_t const *tpn)\n{\n  if (!tpn->tpn_host)\n    return 0;\n\n  return host_is_ip_address(tpn->tpn_host);\n}\n\n/** Duplicate name.\n *\n * The tport_name_dup() function copies strings belonging to the transport\n * name. It returns the copied strings via the @a dst transport name\n * structure. The memory block required for copies is allocated from the\n * memory @a home. Please note that only one memory block is allocated, so\n * the memory can be reclainmed only by deinitializing the memory home\n * itself.\n *\n * @retval 0 when successful\n * @retval -1 upon an error\n */\nint tport_name_dup(su_home_t *home,\n\t\t   tp_name_t *dst,\n\t\t   tp_name_t const *src)\n{\n  size_t n_proto, n_host, n_port, n_canon, n_comp = 0;\n  char *s;\n\n  if (!src->tpn_proto || !src->tpn_host || !src->tpn_port || !src->tpn_canon)\n    return -1;\n\n  if (strcmp(src->tpn_proto, tpn_any))\n    n_proto = strlen(src->tpn_proto) + 1;\n  else\n    n_proto = 0;\n\n  n_host = strlen(src->tpn_host) + 1;\n\n  n_port = strlen(src->tpn_port) + 1;\n\n  if (src->tpn_comp != NULL)\n    n_comp = strlen(src->tpn_comp) + 1;\n\n  if (src->tpn_canon != src->tpn_host &&\n      strcmp(src->tpn_canon, src->tpn_host))\n    n_canon = strlen(src->tpn_canon) + 1;\n  else\n    n_canon = 0;\n\n  s = su_alloc(home, n_proto + n_canon + n_host + n_port + n_comp);\n  if (s == NULL)\n    return -1;\n\n  if (n_proto)\n    dst->tpn_proto = memcpy(s, src->tpn_proto, n_proto), s += n_proto;\n  else\n    dst->tpn_proto = tpn_any;\n\n  dst->tpn_host = memcpy(s, src->tpn_host, n_host), s += n_host;\n  dst->tpn_port = memcpy(s, src->tpn_port, n_port), s += n_port;\n\n  if (n_canon)\n    dst->tpn_canon = memcpy(s, src->tpn_canon, n_canon), s += n_canon;\n  else\n    dst->tpn_canon = dst->tpn_host;\n\n  if (n_comp)\n    dst->tpn_comp = memcpy(s, src->tpn_comp, n_comp), s += n_comp;\n  else\n    dst->tpn_comp = NULL;\n\n  return 0;\n}\n\n/** Convert a sockaddr structure into printable form. */\nchar *tport_hostport(char buf[], isize_t bufsize,\n\t\t     su_sockaddr_t const *su,\n\t\t     int with_port_and_brackets)\n{\n  char *b = buf;\n  size_t n;\n\n#if SU_HAVE_IN6\n  if (with_port_and_brackets > 1 || su->su_family == AF_INET6) {\n    *b++ = '['; bufsize--;\n  }\n#endif\n\n  if (su_inet_ntop(su->su_family, SU_ADDR(su), b, bufsize) == NULL)\n    return NULL;\n  n = strlen(b);\n  if (bufsize < n + 2)\n    return NULL;\n\n  bufsize -= n; b += n;\n\n#if SU_HAVE_IN6\n  if (with_port_and_brackets > 1 || su->su_family == AF_INET6) {\n    *b++ = ']'; bufsize--;\n  }\n  if (with_port_and_brackets) {\n    unsigned short port = ntohs(su->su_port);\n    if (port != 0) {\n      n = snprintf(b, bufsize, \":%u\", port);\n      if (n <= 0)\n        return NULL;\n      b += n;\n      if (bufsize > n)\n        bufsize -= n;\n      else\n        bufsize = 0;\n    }\n  }\n#endif\n\n  if (bufsize)\n    *b++ = 0;\n\n  return buf;\n}\n\n/** @internal Update receive statistics. */\nvoid tport_recv_bytes(tport_t *self, ssize_t bytes, ssize_t on_line)\n{\n  self->tp_stats.recv_bytes += bytes;\n  self->tp_stats.recv_on_line += on_line;\n\n  if (self != self->tp_pri->pri_primary) {\n    self = self->tp_pri->pri_primary;\n    self->tp_stats.recv_bytes += bytes;\n    self->tp_stats.recv_on_line += on_line;\n  }\n  self = self->tp_master->mr_master;\n  self->tp_stats.recv_bytes += bytes;\n  self->tp_stats.recv_on_line += on_line;\n}\n\n/** @internal Update message-based receive statistics. */\nvoid tport_recv_message(tport_t *self, msg_t *msg, int error)\n{\n  error = error != 0;\n\n  self->tp_stats.recv_msgs++;\n  self->tp_stats.recv_errors += error;\n\n  if (self != self->tp_pri->pri_primary) {\n    self = self->tp_pri->pri_primary;\n    self->tp_stats.recv_msgs++;\n    self->tp_stats.recv_errors += error;\n  }\n\n  self = self->tp_master->mr_master;\n\n  self->tp_stats.recv_msgs++;\n  self->tp_stats.recv_errors += error;\n}\n\n/** @internal Update send statistics. */\nvoid tport_sent_bytes(tport_t *self, ssize_t bytes, ssize_t on_line)\n{\n  self->tp_stats.sent_bytes += bytes;\n  self->tp_stats.sent_on_line += on_line;\n\n  if (self != self->tp_pri->pri_primary) {\n    self = self->tp_pri->pri_primary;\n    self->tp_stats.sent_bytes += bytes;\n    self->tp_stats.sent_on_line += on_line;\n  }\n\n  self = self->tp_master->mr_master;\n  self->tp_stats.sent_bytes += bytes;\n  self->tp_stats.sent_on_line += on_line;\n}\n\n/** @internal Update message-based send statistics. */\nvoid tport_sent_message(tport_t *self, msg_t *msg, int error)\n{\n  self->tp_slogged = NULL;\n\n  error = error != 0;\n\n  self->tp_stats.sent_msgs++;\n  self->tp_stats.sent_errors += error;\n\n  if (self != self->tp_pri->pri_primary) {\n    self = self->tp_pri->pri_primary;\n    self->tp_stats.sent_msgs++;\n    self->tp_stats.sent_errors += error;\n  }\n\n  self = self->tp_master->mr_master;\n\n  self->tp_stats.sent_msgs++;\n  self->tp_stats.sent_errors += error;\n\n}\n"], "filenames": ["libsofia-sip-ua/tport/tport.c"], "buggy_code_start_loc": [3313], "buggy_code_end_loc": [3315], "fixing_code_start_loc": [3312], "fixing_code_end_loc": [3312], "type": "CWE-617", "message": "An issue was discovered in the libsofia-sip fork in drachtio-server before 0.8.20. It allows remote attackers to cause a denial of service (daemon crash) via a crafted UDP message that leads to a failure of the libsofia-sip-ua/tport/tport.c self assertion.", "other": {"cve": {"id": "CVE-2022-47516", "sourceIdentifier": "cve@mitre.org", "published": "2022-12-18T05:15:11.200", "lastModified": "2023-05-24T21:15:11.037", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "An issue was discovered in the libsofia-sip fork in drachtio-server before 0.8.20. It allows remote attackers to cause a denial of service (daemon crash) via a crafted UDP message that leads to a failure of the libsofia-sip-ua/tport/tport.c self assertion."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-617"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:drachtio:drachtio-server:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.8.20", "matchCriteriaId": "BE06DCDE-7FE0-4BAB-9130-985502E95875"}]}]}], "references": [{"url": "https://github.com/davehorton/sofia-sip/commit/13b2a135287caa2d67ac6cd5155626821e25b377", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/drachtio/drachtio-server/issues/244", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2023/02/msg00028.html", "source": "cve@mitre.org"}, {"url": "https://www.debian.org/security/2023/dsa-5410", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/davehorton/sofia-sip/commit/13b2a135287caa2d67ac6cd5155626821e25b377"}}