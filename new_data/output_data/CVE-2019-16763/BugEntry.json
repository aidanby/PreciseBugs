{"buggy_code": ["/*\n * Pannellum - An HTML5 based Panorama Viewer\n * Copyright (c) 2011-2019 Matthew Petroff\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\nwindow.pannellum = (function(window, document, undefined) {\n\n'use strict';\n\n/**\n * Creates a new panorama viewer.\n * @constructor\n * @param {HTMLElement|string} container - The container (div) element for the\n *      viewer, or its ID.\n * @param {Object} initialConfig - Inital configuration for viewer.\n */\nfunction Viewer(container, initialConfig) {\n\nvar _this = this;\n\n// Declare variables\nvar config,\n    renderer,\n    preview,\n    isUserInteracting = false,\n    latestInteraction = Date.now(),\n    onPointerDownPointerX = 0,\n    onPointerDownPointerY = 0,\n    onPointerDownPointerDist = -1,\n    onPointerDownYaw = 0,\n    onPointerDownPitch = 0,\n    keysDown = new Array(10),\n    fullscreenActive = false,\n    loaded,\n    error = false,\n    isTimedOut = false,\n    listenersAdded = false,\n    panoImage,\n    prevTime,\n    speed = {'yaw': 0, 'pitch': 0, 'hfov': 0},\n    animating = false,\n    orientation = false,\n    orientationYawOffset = 0,\n    autoRotateStart,\n    autoRotateSpeed = 0,\n    origHfov,\n    origPitch,\n    animatedMove = {},\n    externalEventListeners = {},\n    specifiedPhotoSphereExcludes = [],\n    update = false, // Should we update when still to render dynamic content\n    eps = 1e-6,\n    hotspotsCreated = false,\n    destroyed = false;\n\nvar defaultConfig = {\n    hfov: 100,\n    minHfov: 50,\n    multiResMinHfov: false,\n    maxHfov: 120,\n    pitch: 0,\n    minPitch: undefined,\n    maxPitch: undefined,\n    yaw: 0,\n    minYaw: -180,\n    maxYaw: 180,\n    roll: 0,\n    haov: 360,\n    vaov: 180,\n    vOffset: 0,\n    autoRotate: false,\n    autoRotateInactivityDelay: -1,\n    autoRotateStopDelay: undefined,\n    type: 'equirectangular',\n    northOffset: 0,\n    showFullscreenCtrl: true,\n    dynamic: false,\n    dynamicUpdate: false,\n    doubleClickZoom: true,\n    keyboardZoom: true,\n    mouseZoom: true,\n    showZoomCtrl: true,\n    autoLoad: false,\n    showControls: true,\n    orientationOnByDefault: false,\n    hotSpotDebug: false,\n    backgroundColor: [0, 0, 0],\n    avoidShowingBackground: false,\n    animationTimingFunction: timingFunction,\n    draggable: true,\n    disableKeyboardCtrl: false,\n    crossOrigin: 'anonymous',\n    touchPanSpeedCoeffFactor: 1,\n    capturedKeyNumbers: [16, 17, 27, 37, 38, 39, 40, 61, 65, 68, 83, 87, 107, 109, 173, 187, 189],\n    friction: 0.15\n};\n\n// Translatable / configurable strings\n// Some strings contain '%s', which is a placeholder for inserted values\n// When setting strings in external configuration, `\\n` should be used instead of `<br>` to insert line breaks\ndefaultConfig.strings = {\n    // Labels\n    loadButtonLabel: 'Click to<br>Load<br>Panorama',\n    loadingLabel: 'Loading...',\n    bylineLabel: 'by %s',    // One substitution: author\n\n    // Errors\n    noPanoramaError: 'No panorama image was specified.',\n    fileAccessError: 'The file %s could not be accessed.',  // One substitution: file URL\n    malformedURLError: 'There is something wrong with the panorama URL.',\n    iOS8WebGLError: \"Due to iOS 8's broken WebGL implementation, only \" +\n                    \"progressive encoded JPEGs work for your device (this \" +\n                    \"panorama uses standard encoding).\",\n    genericWebGLError: 'Your browser does not have the necessary WebGL support to display this panorama.',\n    textureSizeError: 'This panorama is too big for your device! It\\'s ' +\n                '%spx wide, but your device only supports images up to ' +\n                '%spx wide. Try another device.' +\n                ' (If you\\'re the author, try scaling down the image.)',    // Two substitutions: image width, max image width\n    unknownError: 'Unknown error. Check developer console.',\n};\n\n// Initialize container\ncontainer = typeof container === 'string' ? document.getElementById(container) : container;\ncontainer.classList.add('pnlm-container');\ncontainer.tabIndex = 0;\n\n// Create container for ui\nvar uiContainer = document.createElement('div');\nuiContainer.className = 'pnlm-ui';\ncontainer.appendChild(uiContainer);\n\n// Create container for renderer\nvar renderContainer = document.createElement('div');\nrenderContainer.className = 'pnlm-render-container';\ncontainer.appendChild(renderContainer);\nvar dragFix = document.createElement('div');\ndragFix.className = 'pnlm-dragfix';\nuiContainer.appendChild(dragFix);\n\n// Display about information on right click\nvar aboutMsg = document.createElement('span');\naboutMsg.className = 'pnlm-about-msg';\naboutMsg.innerHTML = '<a href=\"https://pannellum.org/\" target=\"_blank\">Pannellum</a>';\nuiContainer.appendChild(aboutMsg);\ndragFix.addEventListener('contextmenu', aboutMessage);\n\n// Create info display\nvar infoDisplay = {};\n\n// Hot spot debug indicator\nvar hotSpotDebugIndicator = document.createElement('div');\nhotSpotDebugIndicator.className = 'pnlm-sprite pnlm-hot-spot-debug-indicator';\nuiContainer.appendChild(hotSpotDebugIndicator);\n\n// Panorama info\ninfoDisplay.container = document.createElement('div');\ninfoDisplay.container.className = 'pnlm-panorama-info';\ninfoDisplay.title = document.createElement('div');\ninfoDisplay.title.className = 'pnlm-title-box';\ninfoDisplay.container.appendChild(infoDisplay.title);\ninfoDisplay.author = document.createElement('div');\ninfoDisplay.author.className = 'pnlm-author-box';\ninfoDisplay.container.appendChild(infoDisplay.author);\nuiContainer.appendChild(infoDisplay.container);\n\n// Load box\ninfoDisplay.load = {};\ninfoDisplay.load.box = document.createElement('div');\ninfoDisplay.load.box.className = 'pnlm-load-box';\ninfoDisplay.load.boxp = document.createElement('p');\ninfoDisplay.load.box.appendChild(infoDisplay.load.boxp);\ninfoDisplay.load.lbox = document.createElement('div');\ninfoDisplay.load.lbox.className = 'pnlm-lbox';\ninfoDisplay.load.lbox.innerHTML = '<div class=\"pnlm-loading\"></div>';\ninfoDisplay.load.box.appendChild(infoDisplay.load.lbox);\ninfoDisplay.load.lbar = document.createElement('div');\ninfoDisplay.load.lbar.className = 'pnlm-lbar';\ninfoDisplay.load.lbarFill = document.createElement('div');\ninfoDisplay.load.lbarFill.className = 'pnlm-lbar-fill';\ninfoDisplay.load.lbar.appendChild(infoDisplay.load.lbarFill);\ninfoDisplay.load.box.appendChild(infoDisplay.load.lbar);\ninfoDisplay.load.msg = document.createElement('p');\ninfoDisplay.load.msg.className = 'pnlm-lmsg';\ninfoDisplay.load.box.appendChild(infoDisplay.load.msg);\nuiContainer.appendChild(infoDisplay.load.box);\n\n// Error message\ninfoDisplay.errorMsg = document.createElement('div');\ninfoDisplay.errorMsg.className = 'pnlm-error-msg pnlm-info-box';\nuiContainer.appendChild(infoDisplay.errorMsg);\n\n// Create controls\nvar controls = {};\ncontrols.container = document.createElement('div');\ncontrols.container.className = 'pnlm-controls-container';\nuiContainer.appendChild(controls.container);\n\n// Load button\ncontrols.load = document.createElement('div');\ncontrols.load.className = 'pnlm-load-button';\ncontrols.load.addEventListener('click', function() {\n    processOptions();\n    load();\n});\nuiContainer.appendChild(controls.load);\n\n// Zoom controls\ncontrols.zoom = document.createElement('div');\ncontrols.zoom.className = 'pnlm-zoom-controls pnlm-controls';\ncontrols.zoomIn = document.createElement('div');\ncontrols.zoomIn.className = 'pnlm-zoom-in pnlm-sprite pnlm-control';\ncontrols.zoomIn.addEventListener('click', zoomIn);\ncontrols.zoom.appendChild(controls.zoomIn);\ncontrols.zoomOut = document.createElement('div');\ncontrols.zoomOut.className = 'pnlm-zoom-out pnlm-sprite pnlm-control';\ncontrols.zoomOut.addEventListener('click', zoomOut);\ncontrols.zoom.appendChild(controls.zoomOut);\ncontrols.container.appendChild(controls.zoom);\n\n// Fullscreen toggle\ncontrols.fullscreen = document.createElement('div');\ncontrols.fullscreen.addEventListener('click', toggleFullscreen);\ncontrols.fullscreen.className = 'pnlm-fullscreen-toggle-button pnlm-sprite pnlm-fullscreen-toggle-button-inactive pnlm-controls pnlm-control';\nif (document.fullscreenEnabled || document.mozFullScreenEnabled || document.webkitFullscreenEnabled || document.msFullscreenEnabled)\n    controls.container.appendChild(controls.fullscreen);\n\n// Device orientation toggle\ncontrols.orientation = document.createElement('div');\ncontrols.orientation.addEventListener('click', function(e) {\n    if (orientation)\n        stopOrientation();\n    else\n        startOrientation();\n});\ncontrols.orientation.addEventListener('mousedown', function(e) {e.stopPropagation();});\ncontrols.orientation.addEventListener('touchstart', function(e) {e.stopPropagation();});\ncontrols.orientation.addEventListener('pointerdown', function(e) {e.stopPropagation();});\ncontrols.orientation.className = 'pnlm-orientation-button pnlm-orientation-button-inactive pnlm-sprite pnlm-controls pnlm-control';\nvar orientationSupport = false;\nif (window.DeviceOrientationEvent && location.protocol == 'https:' &&\n    navigator.userAgent.toLowerCase().indexOf('mobi') >= 0) {\n    // This user agent check is here because there's no way to check if a\n    // device has an inertia measurement unit. We used to be able to check if a\n    // DeviceOrientationEvent had non-null values, but with iOS 13 requiring a\n    // permission prompt to access such events, this is no longer possible.\n    controls.container.appendChild(controls.orientation);\n    orientationSupport = true;\n}\n\n// Compass\nvar compass = document.createElement('div');\ncompass.className = 'pnlm-compass pnlm-controls pnlm-control';\nuiContainer.appendChild(compass);\n\n// Load and process configuration\nif (initialConfig.firstScene) {\n    // Activate first scene if specified in URL\n    mergeConfig(initialConfig.firstScene);\n} else if (initialConfig.default && initialConfig.default.firstScene) {\n    // Activate first scene if specified in file\n    mergeConfig(initialConfig.default.firstScene);\n} else {\n    mergeConfig(null);\n}\nprocessOptions(true);\n\n/**\n * Initializes viewer.\n * @private\n */\nfunction init() {\n    // Display an error for IE 9 as it doesn't work but also doesn't otherwise\n    // show an error (older versions don't work at all)\n    // Based on: http://stackoverflow.com/a/10965203\n    var div = document.createElement(\"div\");\n    div.innerHTML = \"<!--[if lte IE 9]><i></i><![endif]-->\";\n    if (div.getElementsByTagName(\"i\").length == 1) {\n        anError();\n        return;\n    }\n\n    origHfov = config.hfov;\n    origPitch = config.pitch;\n\n    var i, p;\n    \n    if (config.type == 'cubemap') {\n        panoImage = [];\n        for (i = 0; i < 6; i++) {\n            panoImage.push(new Image());\n            panoImage[i].crossOrigin = config.crossOrigin;\n        }\n        infoDisplay.load.lbox.style.display = 'block';\n        infoDisplay.load.lbar.style.display = 'none';\n    } else if (config.type == 'multires') {\n        var c = JSON.parse(JSON.stringify(config.multiRes));    // Deep copy\n        // Avoid \"undefined\" in path, check (optional) multiRes.basePath, too\n        // Use only multiRes.basePath if it's an absolute URL\n        if (config.basePath && config.multiRes.basePath &&\n            !(/^(?:[a-z]+:)?\\/\\//i.test(config.multiRes.basePath))) {\n            c.basePath = config.basePath + config.multiRes.basePath;\n        } else if (config.multiRes.basePath) {\n            c.basePath = config.multiRes.basePath;\n        } else if(config.basePath) {\n            c.basePath = config.basePath;\n        }\n        panoImage = c;\n    } else {\n        if (config.dynamic === true) {\n            panoImage = config.panorama;\n        } else {\n            if (config.panorama === undefined) {\n                anError(config.strings.noPanoramaError);\n                return;\n            }\n            panoImage = new Image();\n        }\n    }\n\n    // Configure image loading\n    if (config.type == 'cubemap') {\n        // Quick loading counter for synchronous loading\n        var itemsToLoad = 6;\n        \n        var onLoad = function() {\n            itemsToLoad--;\n            if (itemsToLoad === 0) {\n                onImageLoad();\n            }\n        };\n        \n        var onError = function(e) {\n            var a = document.createElement('a');\n            a.href = e.target.src;\n            a.textContent = a.href;\n            anError(config.strings.fileAccessError.replace('%s', a.outerHTML));\n        };\n        \n        for (i = 0; i < panoImage.length; i++) {\n            p = config.cubeMap[i];\n            if (p == \"null\") { // support partial cubemap image with explicitly empty faces\n                console.log('Will use background instead of missing cubemap face ' + i);\n                onLoad();\n            } else {\n                if (config.basePath && !absoluteURL(p)) {\n                    p = config.basePath + p;\n                }\n                panoImage[i].onload = onLoad;\n                panoImage[i].onerror = onError;\n                panoImage[i].src = sanitizeURL(p);\n            }\n        }\n    } else if (config.type == 'multires') {\n        onImageLoad();\n    } else {\n        p = '';\n        if (config.basePath) {\n            p = config.basePath;\n        }\n        \n        if (config.dynamic !== true) {\n            // Still image\n            p = absoluteURL(config.panorama) ? config.panorama : p + config.panorama;\n            \n            panoImage.onload = function() {\n                window.URL.revokeObjectURL(this.src);  // Clean up\n                onImageLoad();\n            };\n            \n            var xhr = new XMLHttpRequest();\n            xhr.onloadend = function() {\n                if (xhr.status != 200) {\n                    // Display error if image can't be loaded\n                    var a = document.createElement('a');\n                    a.href = p;\n                    a.textContent = a.href;\n                    anError(config.strings.fileAccessError.replace('%s', a.outerHTML));\n                }\n                var img = this.response;\n                parseGPanoXMP(img);\n                infoDisplay.load.msg.innerHTML = '';\n            };\n            xhr.onprogress = function(e) {\n                if (e.lengthComputable) {\n                    // Display progress\n                    var percent = e.loaded / e.total * 100;\n                    infoDisplay.load.lbarFill.style.width = percent + '%';\n                    var unit, numerator, denominator;\n                    if (e.total > 1e6) {\n                        unit = 'MB';\n                        numerator = (e.loaded / 1e6).toFixed(2);\n                        denominator = (e.total / 1e6).toFixed(2);\n                    } else if (e.total > 1e3) {\n                        unit = 'kB';\n                        numerator = (e.loaded / 1e3).toFixed(1);\n                        denominator = (e.total / 1e3).toFixed(1);\n                    } else {\n                        unit = 'B';\n                        numerator = e.loaded;\n                        denominator = e.total;\n                    }\n                    infoDisplay.load.msg.innerHTML = numerator + ' / ' + denominator + ' ' + unit;\n                } else {\n                    // Display loading spinner\n                    infoDisplay.load.lbox.style.display = 'block';\n                    infoDisplay.load.lbar.style.display = 'none';\n                }\n            };\n            try {\n                xhr.open('GET', p, true);\n            } catch (e) {\n                // Malformed URL\n                anError(config.strings.malformedURLError);\n            }\n            xhr.responseType = 'blob';\n            xhr.setRequestHeader('Accept', 'image/*,*/*;q=0.9');\n            xhr.withCredentials = config.crossOrigin === 'use-credentials';\n            xhr.send();\n        }\n    }\n    \n    if (config.draggable)\n        uiContainer.classList.add('pnlm-grab');\n    uiContainer.classList.remove('pnlm-grabbing');\n\n    // Properly handle switching to dynamic scenes\n    update = config.dynamicUpdate === true;\n    if (config.dynamic && update) {\n        panoImage = config.panorama;\n        onImageLoad();\n    }\n}\n\n/**\n * Test if URL is absolute or relative.\n * @private\n * @param {string} url - URL to test\n * @returns {boolean} True if absolute, else false\n */\nfunction absoluteURL(url) {\n    // From http://stackoverflow.com/a/19709846\n    return new RegExp('^(?:[a-z]+:)?//', 'i').test(url) || url[0] == '/' || url.slice(0, 5) == 'blob:';\n}\n\n/**\n * Create renderer and initialize event listeners once image is loaded.\n * @private\n */\nfunction onImageLoad() {\n    if (!renderer)\n        renderer = new libpannellum.renderer(renderContainer);\n\n    // Only add event listeners once\n    if (!listenersAdded) {\n        listenersAdded = true;\n        dragFix.addEventListener('mousedown', onDocumentMouseDown, false);\n        document.addEventListener('mousemove', onDocumentMouseMove, false);\n        document.addEventListener('mouseup', onDocumentMouseUp, false);\n        if (config.mouseZoom) {\n            uiContainer.addEventListener('mousewheel', onDocumentMouseWheel, false);\n            uiContainer.addEventListener('DOMMouseScroll', onDocumentMouseWheel, false);\n        }\n        if (config.doubleClickZoom) {\n            dragFix.addEventListener('dblclick', onDocumentDoubleClick, false);\n        }\n        container.addEventListener('mozfullscreenchange', onFullScreenChange, false);\n        container.addEventListener('webkitfullscreenchange', onFullScreenChange, false);\n        container.addEventListener('msfullscreenchange', onFullScreenChange, false);\n        container.addEventListener('fullscreenchange', onFullScreenChange, false);\n        window.addEventListener('resize', onDocumentResize, false);\n        window.addEventListener('orientationchange', onDocumentResize, false);\n        if (!config.disableKeyboardCtrl) {\n            container.addEventListener('keydown', onDocumentKeyPress, false);\n            container.addEventListener('keyup', onDocumentKeyUp, false);\n            container.addEventListener('blur', clearKeys, false);\n        }\n        document.addEventListener('mouseleave', onDocumentMouseUp, false);\n        if (document.documentElement.style.pointerAction === '' &&\n            document.documentElement.style.touchAction === '') {\n            dragFix.addEventListener('pointerdown', onDocumentPointerDown, false);\n            dragFix.addEventListener('pointermove', onDocumentPointerMove, false);\n            dragFix.addEventListener('pointerup', onDocumentPointerUp, false);\n            dragFix.addEventListener('pointerleave', onDocumentPointerUp, false);\n        } else {\n            dragFix.addEventListener('touchstart', onDocumentTouchStart, false);\n            dragFix.addEventListener('touchmove', onDocumentTouchMove, false);\n            dragFix.addEventListener('touchend', onDocumentTouchEnd, false);\n        }\n\n        // Deal with MS pointer events\n        if (window.navigator.pointerEnabled)\n            container.style.touchAction = 'none';\n    }\n\n    renderInit();\n    setHfov(config.hfov); // possibly adapt hfov after configuration and canvas is complete; prevents empty space on top or bottom by zomming out too much\n    setTimeout(function(){isTimedOut = true;}, 500);\n}\n\n/**\n * Parses Google Photo Sphere XMP Metadata.\n * https://developers.google.com/photo-sphere/metadata/\n * @private\n * @param {Image} image - Image to read XMP metadata from.\n */\nfunction parseGPanoXMP(image) {\n    var reader = new FileReader();\n    reader.addEventListener('loadend', function() {\n        var img = reader.result;\n\n        // This awful browser specific test exists because iOS 8 does not work\n        // with non-progressive encoded JPEGs.\n        if (navigator.userAgent.toLowerCase().match(/(iphone|ipod|ipad).* os 8_/)) {\n            var flagIndex = img.indexOf('\\xff\\xc2');\n            if (flagIndex < 0 || flagIndex > 65536)\n                anError(config.strings.iOS8WebGLError);\n        }\n\n        var start = img.indexOf('<x:xmpmeta');\n        if (start > -1 && config.ignoreGPanoXMP !== true) {\n            var xmpData = img.substring(start, img.indexOf('</x:xmpmeta>') + 12);\n            \n            // Extract the requested tag from the XMP data\n            var getTag = function(tag) {\n                var result;\n                if (xmpData.indexOf(tag + '=\"') >= 0) {\n                    result = xmpData.substring(xmpData.indexOf(tag + '=\"') + tag.length + 2);\n                    result = result.substring(0, result.indexOf('\"'));\n                } else if (xmpData.indexOf(tag + '>') >= 0) {\n                    result = xmpData.substring(xmpData.indexOf(tag + '>') + tag.length + 1);\n                    result = result.substring(0, result.indexOf('<'));\n                }\n                if (result !== undefined) {\n                    return Number(result);\n                }\n                return null;\n            };\n            \n            // Relevant XMP data\n            var xmp = {\n                fullWidth: getTag('GPano:FullPanoWidthPixels'),\n                croppedWidth: getTag('GPano:CroppedAreaImageWidthPixels'),\n                fullHeight: getTag('GPano:FullPanoHeightPixels'),\n                croppedHeight: getTag('GPano:CroppedAreaImageHeightPixels'),\n                topPixels: getTag('GPano:CroppedAreaTopPixels'),\n                heading: getTag('GPano:PoseHeadingDegrees'),\n                horizonPitch: getTag('GPano:PosePitchDegrees'),\n                horizonRoll: getTag('GPano:PoseRollDegrees')\n            };\n            \n            if (xmp.fullWidth !== null && xmp.croppedWidth !== null &&\n                xmp.fullHeight !== null && xmp.croppedHeight !== null &&\n                xmp.topPixels !== null) {\n                \n                // Set up viewer using GPano XMP data\n                if (specifiedPhotoSphereExcludes.indexOf('haov') < 0)\n                    config.haov = xmp.croppedWidth / xmp.fullWidth * 360;\n                if (specifiedPhotoSphereExcludes.indexOf('vaov') < 0)\n                    config.vaov = xmp.croppedHeight / xmp.fullHeight * 180;\n                if (specifiedPhotoSphereExcludes.indexOf('vOffset') < 0)\n                    config.vOffset = ((xmp.topPixels + xmp.croppedHeight / 2) / xmp.fullHeight - 0.5) * -180;\n                if (xmp.heading !== null && specifiedPhotoSphereExcludes.indexOf('northOffset') < 0) {\n                    // TODO: make sure this works correctly for partial panoramas\n                    config.northOffset = xmp.heading;\n                    if (config.compass !== false) {\n                        config.compass = true;\n                    }\n                }\n                if (xmp.horizonPitch !== null && xmp.horizonRoll !== null) {\n                    if (specifiedPhotoSphereExcludes.indexOf('horizonPitch') < 0)\n                        config.horizonPitch = xmp.horizonPitch;\n                    if (specifiedPhotoSphereExcludes.indexOf('horizonRoll') < 0)\n                        config.horizonRoll = xmp.horizonRoll;\n                }\n                \n                // TODO: add support for initial view settings\n            }\n        }\n        \n        // Load panorama\n        panoImage.src = window.URL.createObjectURL(image);\n    });\n    if (reader.readAsBinaryString !== undefined)\n        reader.readAsBinaryString(image);\n    else\n        reader.readAsText(image);\n}\n\n/**\n * Displays an error message.\n * @private\n * @param {string} errorMsg - Error message to display. If not specified, a\n *      generic WebGL error is displayed.\n */\nfunction anError(errorMsg) {\n    if (errorMsg === undefined)\n        errorMsg = config.strings.genericWebGLError;\n    infoDisplay.errorMsg.innerHTML = '<p>' + errorMsg + '</p>';\n    controls.load.style.display = 'none';\n    infoDisplay.load.box.style.display = 'none';\n    infoDisplay.errorMsg.style.display = 'table';\n    error = true;\n    loaded = undefined;\n    renderContainer.style.display = 'none';\n    fireEvent('error', errorMsg);\n}\n\n/**\n * Hides error message display.\n * @private\n */\nfunction clearError() {\n    if (error) {\n        infoDisplay.load.box.style.display = 'none';\n        infoDisplay.errorMsg.style.display = 'none';\n        error = false;\n        renderContainer.style.display = 'block';\n        fireEvent('errorcleared');\n    }\n}\n\n/**\n * Displays about message.\n * @private\n * @param {MouseEvent} event - Right click location\n */\nfunction aboutMessage(event) {\n    var pos = mousePosition(event);\n    aboutMsg.style.left = pos.x + 'px';\n    aboutMsg.style.top = pos.y + 'px';\n    clearTimeout(aboutMessage.t1);\n    clearTimeout(aboutMessage.t2);\n    aboutMsg.style.display = 'block';\n    aboutMsg.style.opacity = 1;\n    aboutMessage.t1 = setTimeout(function() {aboutMsg.style.opacity = 0;}, 2000);\n    aboutMessage.t2 = setTimeout(function() {aboutMsg.style.display = 'none';}, 2500);\n    event.preventDefault();\n}\n\n/**\n * Calculate mouse position relative to top left of viewer container.\n * @private\n * @param {MouseEvent} event - Mouse event to use in calculation\n * @returns {Object} Calculated X and Y coordinates\n */\nfunction mousePosition(event) {\n    var bounds = container.getBoundingClientRect();\n    var pos = {};\n    // pageX / pageY needed for iOS\n    pos.x = (event.clientX || event.pageX) - bounds.left;\n    pos.y = (event.clientY || event.pageY) - bounds.top;\n    return pos;\n}\n\n/**\n * Event handler for mouse clicks. Initializes panning. Prints center and click\n * location coordinates when hot spot debugging is enabled.\n * @private\n * @param {MouseEvent} event - Document mouse down event.\n */\nfunction onDocumentMouseDown(event) {\n    // Override default action\n    event.preventDefault();\n    // But not all of it\n    container.focus();\n    \n    // Only do something if the panorama is loaded\n    if (!loaded || !config.draggable) {\n        return;\n    }\n    \n    // Calculate mouse position relative to top left of viewer container\n    var pos = mousePosition(event);\n\n    // Log pitch / yaw of mouse click when debugging / placing hot spots\n    if (config.hotSpotDebug) {\n        var coords = mouseEventToCoords(event);\n        console.log('Pitch: ' + coords[0] + ', Yaw: ' + coords[1] + ', Center Pitch: ' +\n            config.pitch + ', Center Yaw: ' + config.yaw + ', HFOV: ' + config.hfov);\n    }\n    \n    // Turn off auto-rotation if enabled\n    stopAnimation();\n\n    stopOrientation();\n    config.roll = 0;\n\n    speed.hfov = 0;\n\n    isUserInteracting = true;\n    latestInteraction = Date.now();\n    \n    onPointerDownPointerX = pos.x;\n    onPointerDownPointerY = pos.y;\n    \n    onPointerDownYaw = config.yaw;\n    onPointerDownPitch = config.pitch;\n    \n    uiContainer.classList.add('pnlm-grabbing');\n    uiContainer.classList.remove('pnlm-grab');\n    \n    fireEvent('mousedown', event);\n    animateInit();\n}\n\n/**\n * Event handler for double clicks. Zooms in at clicked location\n * @private\n * @param {MouseEvent} event - Document mouse down event.\n */\nfunction onDocumentDoubleClick(event) {\n    if (config.minHfov === config.hfov) {\n        _this.setHfov(origHfov, 1000);\n    } else {\n        var coords = mouseEventToCoords(event);\n        _this.lookAt(coords[0], coords[1], config.minHfov, 1000);\n    }\n}\n\n/**\n * Calculate panorama pitch and yaw from location of mouse event.\n * @private\n * @param {MouseEvent} event - Document mouse down event.\n * @returns {number[]} [pitch, yaw]\n */\nfunction mouseEventToCoords(event) {\n    var pos = mousePosition(event);\n    var canvas = renderer.getCanvas();\n    var canvasWidth = canvas.clientWidth,\n        canvasHeight = canvas.clientHeight;\n    var x = pos.x / canvasWidth * 2 - 1;\n    var y = (1 - pos.y / canvasHeight * 2) * canvasHeight / canvasWidth;\n    var focal = 1 / Math.tan(config.hfov * Math.PI / 360);\n    var s = Math.sin(config.pitch * Math.PI / 180);\n    var c = Math.cos(config.pitch * Math.PI / 180);\n    var a = focal * c - y * s;\n    var root = Math.sqrt(x*x + a*a);\n    var pitch = Math.atan((y * c + focal * s) / root) * 180 / Math.PI;\n    var yaw = Math.atan2(x / root, a / root) * 180 / Math.PI + config.yaw;\n    if (yaw < -180)\n        yaw += 360;\n    if (yaw > 180)\n        yaw -= 360;\n    return [pitch, yaw];\n}\n\n/**\n * Event handler for mouse moves. Pans center of view.\n * @private\n * @param {MouseEvent} event - Document mouse move event.\n */\nfunction onDocumentMouseMove(event) {\n    if (isUserInteracting && loaded) {\n        latestInteraction = Date.now();\n        var canvas = renderer.getCanvas();\n        var canvasWidth = canvas.clientWidth,\n            canvasHeight = canvas.clientHeight;\n        var pos = mousePosition(event);\n        //TODO: This still isn't quite right\n        var yaw = ((Math.atan(onPointerDownPointerX / canvasWidth * 2 - 1) - Math.atan(pos.x / canvasWidth * 2 - 1)) * 180 / Math.PI * config.hfov / 90) + onPointerDownYaw;\n        speed.yaw = (yaw - config.yaw) % 360 * 0.2;\n        config.yaw = yaw;\n        \n        var vfov = 2 * Math.atan(Math.tan(config.hfov/360*Math.PI) * canvasHeight / canvasWidth) * 180 / Math.PI;\n        \n        var pitch = ((Math.atan(pos.y / canvasHeight * 2 - 1) - Math.atan(onPointerDownPointerY / canvasHeight * 2 - 1)) * 180 / Math.PI * vfov / 90) + onPointerDownPitch;\n        speed.pitch = (pitch - config.pitch) * 0.2;\n        config.pitch = pitch;\n    }\n}\n\n/**\n * Event handler for mouse up events. Stops panning.\n * @private\n */\nfunction onDocumentMouseUp(event) {\n    if (!isUserInteracting) {\n        return;\n    }\n    isUserInteracting = false;\n    if (Date.now() - latestInteraction > 15) {\n        // Prevents jump when user rapidly moves mouse, stops, and then\n        // releases the mouse button\n        speed.pitch = speed.yaw = 0;\n    }\n    uiContainer.classList.add('pnlm-grab');\n    uiContainer.classList.remove('pnlm-grabbing');\n    latestInteraction = Date.now();\n\n    fireEvent('mouseup', event);\n}\n\n/**\n * Event handler for touches. Initializes panning if one touch or zooming if\n * two touches.\n * @private\n * @param {TouchEvent} event - Document touch start event.\n */\nfunction onDocumentTouchStart(event) {\n    // Only do something if the panorama is loaded\n    if (!loaded || !config.draggable) {\n        return;\n    }\n\n    // Turn off auto-rotation if enabled\n    stopAnimation();\n\n    stopOrientation();\n    config.roll = 0;\n\n    speed.hfov = 0;\n\n    // Calculate touch position relative to top left of viewer container\n    var pos0 = mousePosition(event.targetTouches[0]);\n\n    onPointerDownPointerX = pos0.x;\n    onPointerDownPointerY = pos0.y;\n    \n    if (event.targetTouches.length == 2) {\n        // Down pointer is the center of the two fingers\n        var pos1 = mousePosition(event.targetTouches[1]);\n        onPointerDownPointerX += (pos1.x - pos0.x) * 0.5;\n        onPointerDownPointerY += (pos1.y - pos0.y) * 0.5;\n        onPointerDownPointerDist = Math.sqrt((pos0.x - pos1.x) * (pos0.x - pos1.x) +\n                                             (pos0.y - pos1.y) * (pos0.y - pos1.y));\n    }\n    isUserInteracting = true;\n    latestInteraction = Date.now();\n    \n    onPointerDownYaw = config.yaw;\n    onPointerDownPitch = config.pitch;\n\n    fireEvent('touchstart', event);\n    animateInit();\n}\n\n/**\n * Event handler for touch movements. Pans center of view if one touch or\n * adjusts zoom if two touches.\n * @private\n * @param {TouchEvent} event - Document touch move event.\n */\nfunction onDocumentTouchMove(event) {\n    if (!config.draggable) {\n        return;\n    }\n\n    // Override default action\n    event.preventDefault();\n    if (loaded) {\n        latestInteraction = Date.now();\n    }\n    if (isUserInteracting && loaded) {\n        var pos0 = mousePosition(event.targetTouches[0]);\n        var clientX = pos0.x;\n        var clientY = pos0.y;\n        \n        if (event.targetTouches.length == 2 && onPointerDownPointerDist != -1) {\n            var pos1 = mousePosition(event.targetTouches[1]);\n            clientX += (pos1.x - pos0.x) * 0.5;\n            clientY += (pos1.y - pos0.y) * 0.5;\n            var clientDist = Math.sqrt((pos0.x - pos1.x) * (pos0.x - pos1.x) +\n                                       (pos0.y - pos1.y) * (pos0.y - pos1.y));\n            setHfov(config.hfov + (onPointerDownPointerDist - clientDist) * 0.1);\n            onPointerDownPointerDist = clientDist;\n        }\n\n        // The smaller the config.hfov value (the more zoomed-in the user is), the faster\n        // yaw/pitch are perceived to change on one-finger touchmove (panning) events and vice versa.\n        // To improve usability at both small and large zoom levels (config.hfov values)\n        // we introduce a dynamic pan speed coefficient.\n        //\n        // Currently this seems to *roughly* keep initial drag/pan start position close to\n        // the user's finger while panning regardless of zoom level / config.hfov value.\n        var touchmovePanSpeedCoeff = (config.hfov / 360) * config.touchPanSpeedCoeffFactor;\n\n        var yaw = (onPointerDownPointerX - clientX) * touchmovePanSpeedCoeff + onPointerDownYaw;\n        speed.yaw = (yaw - config.yaw) % 360 * 0.2;\n        config.yaw = yaw;\n\n        var pitch = (clientY - onPointerDownPointerY) * touchmovePanSpeedCoeff + onPointerDownPitch;\n        speed.pitch = (pitch - config.pitch) * 0.2;\n        config.pitch = pitch;\n    }\n}\n\n/**\n * Event handler for end of touches. Stops panning and/or zooming.\n * @private\n */\nfunction onDocumentTouchEnd() {\n    isUserInteracting = false;\n    if (Date.now() - latestInteraction > 150) {\n        speed.pitch = speed.yaw = 0;\n    }\n    onPointerDownPointerDist = -1;\n    latestInteraction = Date.now();\n\n    fireEvent('touchend', event);\n}\n\nvar pointerIDs = [],\n    pointerCoordinates = [];\n/**\n * Event handler for touch starts in IE / Edge.\n * @private\n * @param {PointerEvent} event - Document pointer down event.\n */\nfunction onDocumentPointerDown(event) {\n    if (event.pointerType == 'touch') {\n        // Only do something if the panorama is loaded\n        if (!loaded || !config.draggable)\n            return;\n        pointerIDs.push(event.pointerId);\n        pointerCoordinates.push({clientX: event.clientX, clientY: event.clientY});\n        event.targetTouches = pointerCoordinates;\n        onDocumentTouchStart(event);\n        event.preventDefault();\n    }\n}\n\n/**\n * Event handler for touch moves in IE / Edge.\n * @private\n * @param {PointerEvent} event - Document pointer move event.\n */\nfunction onDocumentPointerMove(event) {\n    if (event.pointerType == 'touch') {\n        if (!config.draggable)\n            return;\n        for (var i = 0; i < pointerIDs.length; i++) {\n            if (event.pointerId == pointerIDs[i]) {\n                pointerCoordinates[i].clientX = event.clientX;\n                pointerCoordinates[i].clientY = event.clientY;\n                event.targetTouches = pointerCoordinates;\n                onDocumentTouchMove(event);\n                event.preventDefault();\n                return;\n            }\n        }\n    }\n}\n\n/**\n * Event handler for touch ends in IE / Edge.\n * @private\n * @param {PointerEvent} event - Document pointer up event.\n */\nfunction onDocumentPointerUp(event) {\n    if (event.pointerType == 'touch') {\n        var defined = false;\n        for (var i = 0; i < pointerIDs.length; i++) {\n            if (event.pointerId == pointerIDs[i])\n                pointerIDs[i] = undefined;\n            if (pointerIDs[i])\n                defined = true;\n        }\n        if (!defined) {\n            pointerIDs = [];\n            pointerCoordinates = [];\n            onDocumentTouchEnd();\n        }\n        event.preventDefault();\n    }\n}\n\n/**\n * Event handler for mouse wheel. Changes zoom.\n * @private\n * @param {WheelEvent} event - Document mouse wheel event.\n */\nfunction onDocumentMouseWheel(event) {\n    // Only do something if the panorama is loaded and mouse wheel zoom is enabled\n    if (!loaded || (config.mouseZoom == 'fullscreenonly' && !fullscreenActive)) {\n        return;\n    }\n\n    event.preventDefault();\n\n    // Turn off auto-rotation if enabled\n    stopAnimation();\n    latestInteraction = Date.now();\n\n    if (event.wheelDeltaY) {\n        // WebKit\n        setHfov(config.hfov - event.wheelDeltaY * 0.05);\n        speed.hfov = event.wheelDelta < 0 ? 1 : -1;\n    } else if (event.wheelDelta) {\n        // Opera / Explorer 9\n        setHfov(config.hfov - event.wheelDelta * 0.05);\n        speed.hfov = event.wheelDelta < 0 ? 1 : -1;\n    } else if (event.detail) {\n        // Firefox\n        setHfov(config.hfov + event.detail * 1.5);\n        speed.hfov = event.detail > 0 ? 1 : -1;\n    }\n    animateInit();\n}\n\n/**\n * Event handler for key presses. Updates list of currently pressed keys.\n * @private\n * @param {KeyboardEvent} event - Document key press event.\n */\nfunction onDocumentKeyPress(event) {\n    // Turn off auto-rotation if enabled\n    stopAnimation();\n    latestInteraction = Date.now();\n\n    stopOrientation();\n    config.roll = 0;\n\n    // Record key pressed\n    var keynumber = event.which || event.keycode;\n\n    // Override default action for keys that are used\n    if (config.capturedKeyNumbers.indexOf(keynumber) < 0)\n        return;\n    event.preventDefault();\n    \n    // If escape key is pressed\n    if (keynumber == 27) {\n        // If in fullscreen mode\n        if (fullscreenActive) {\n            toggleFullscreen();\n        }\n    } else {\n        // Change key\n        changeKey(keynumber, true);\n    }\n}\n\n/**\n * Clears list of currently pressed keys.\n * @private\n */\nfunction clearKeys() {\n    for (var i = 0; i < 10; i++) {\n        keysDown[i] = false;\n    }\n}\n\n/**\n * Event handler for key releases. Updates list of currently pressed keys.\n * @private\n * @param {KeyboardEvent} event - Document key up event.\n */\nfunction onDocumentKeyUp(event) {\n    // Record key pressed\n    var keynumber = event.which || event.keycode;\n    \n    // Override default action for keys that are used\n    if (config.capturedKeyNumbers.indexOf(keynumber) < 0)\n        return;\n    event.preventDefault();\n    \n    // Change key\n    changeKey(keynumber, false);\n}\n\n/**\n * Updates list of currently pressed keys.\n * @private\n * @param {number} keynumber - Key number.\n * @param {boolean} value - Whether or not key is pressed.\n */\nfunction changeKey(keynumber, value) {\n    var keyChanged = false;\n    switch(keynumber) {\n        // If minus key is released\n        case 109: case 189: case 17: case 173:\n            if (keysDown[0] != value) { keyChanged = true; }\n            keysDown[0] = value; break;\n        \n        // If plus key is released\n        case 107: case 187: case 16: case 61:\n            if (keysDown[1] != value) { keyChanged = true; }\n            keysDown[1] = value; break;\n        \n        // If up arrow is released\n        case 38:\n            if (keysDown[2] != value) { keyChanged = true; }\n            keysDown[2] = value; break;\n        \n        // If \"w\" is released\n        case 87:\n            if (keysDown[6] != value) { keyChanged = true; }\n            keysDown[6] = value; break;\n        \n        // If down arrow is released\n        case 40:\n            if (keysDown[3] != value) { keyChanged = true; }\n            keysDown[3] = value; break;\n        \n        // If \"s\" is released\n        case 83:\n            if (keysDown[7] != value) { keyChanged = true; }\n            keysDown[7] = value; break;\n        \n        // If left arrow is released\n        case 37:\n            if (keysDown[4] != value) { keyChanged = true; }\n            keysDown[4] = value; break;\n        \n        // If \"a\" is released\n        case 65:\n            if (keysDown[8] != value) { keyChanged = true; }\n            keysDown[8] = value; break;\n        \n        // If right arrow is released\n        case 39:\n            if (keysDown[5] != value) { keyChanged = true; }\n            keysDown[5] = value; break;\n        \n        // If \"d\" is released\n        case 68:\n            if (keysDown[9] != value) { keyChanged = true; }\n            keysDown[9] = value;\n    }\n    \n    if (keyChanged && value) {\n        if (typeof performance !== 'undefined' && performance.now()) {\n            prevTime = performance.now();\n        } else {\n            prevTime = Date.now();\n        }\n        animateInit();\n    }\n}\n\n/**\n * Pans and/or zooms panorama based on currently pressed keys. Also handles\n * panorama \"inertia\" and auto rotation.\n * @private\n */\nfunction keyRepeat() {\n    // Only do something if the panorama is loaded\n    if (!loaded) {\n        return;\n    }\n\n    var isKeyDown = false;\n\n    var prevPitch = config.pitch;\n    var prevYaw = config.yaw;\n    var prevZoom = config.hfov;\n    \n    var newTime;\n    if (typeof performance !== 'undefined' && performance.now()) {\n        newTime = performance.now();\n    } else {\n        newTime = Date.now();\n    }\n    if (prevTime === undefined) {\n        prevTime = newTime;\n    }\n    var diff = (newTime - prevTime) * config.hfov / 1700;\n    diff = Math.min(diff, 1.0);\n    \n    // If minus key is down\n    if (keysDown[0] && config.keyboardZoom === true) {\n        setHfov(config.hfov + (speed.hfov * 0.8 + 0.5) * diff);\n        isKeyDown = true;\n    }\n    \n    // If plus key is down\n    if (keysDown[1] && config.keyboardZoom === true) {\n        setHfov(config.hfov + (speed.hfov * 0.8 - 0.2) * diff);\n        isKeyDown = true;\n    }\n    \n    // If up arrow or \"w\" is down\n    if (keysDown[2] || keysDown[6]) {\n        // Pan up\n        config.pitch += (speed.pitch * 0.8 + 0.2) * diff;\n        isKeyDown = true;\n    }\n    \n    // If down arrow or \"s\" is down\n    if (keysDown[3] || keysDown[7]) {\n        // Pan down\n        config.pitch += (speed.pitch * 0.8 - 0.2) * diff;\n        isKeyDown = true;\n    }\n    \n    // If left arrow or \"a\" is down\n    if (keysDown[4] || keysDown[8]) {\n        // Pan left\n        config.yaw += (speed.yaw * 0.8 - 0.2) * diff;\n        isKeyDown = true;\n    }\n    \n    // If right arrow or \"d\" is down\n    if (keysDown[5] || keysDown[9]) {\n        // Pan right\n        config.yaw += (speed.yaw * 0.8 + 0.2) * diff;\n        isKeyDown = true;\n    }\n\n    if (isKeyDown)\n        latestInteraction = Date.now();\n\n    // If auto-rotate\n    if (config.autoRotate) {\n        // Pan\n        if (newTime - prevTime > 0.001) {\n            var timeDiff = (newTime - prevTime) / 1000;\n            var yawDiff = (speed.yaw / timeDiff * diff - config.autoRotate * 0.2) * timeDiff;\n            yawDiff = (-config.autoRotate > 0 ? 1 : -1) * Math.min(Math.abs(config.autoRotate * timeDiff), Math.abs(yawDiff));\n            config.yaw += yawDiff;\n        }\n        \n        // Deal with stopping auto rotation after a set delay\n        if (config.autoRotateStopDelay) {\n            config.autoRotateStopDelay -= newTime - prevTime;\n            if (config.autoRotateStopDelay <= 0) {\n                config.autoRotateStopDelay = false;\n                autoRotateSpeed = config.autoRotate;\n                config.autoRotate = 0;\n            }\n        }\n    }\n\n    // Animated moves\n    if (animatedMove.pitch) {\n        animateMove('pitch');\n        prevPitch = config.pitch;\n    }\n    if (animatedMove.yaw) {\n        animateMove('yaw');\n        prevYaw = config.yaw;\n    }\n    if (animatedMove.hfov) {\n        animateMove('hfov');\n        prevZoom = config.hfov;\n    }\n\n    // \"Inertia\"\n    if (diff > 0 && !config.autoRotate) {\n        // \"Friction\"\n        var slowDownFactor = 1 - config.friction;\n\n        // Yaw\n        if (!keysDown[4] && !keysDown[5] && !keysDown[8] && !keysDown[9] && !animatedMove.yaw) {\n            config.yaw += speed.yaw * diff * slowDownFactor;\n        }\n        // Pitch\n        if (!keysDown[2] && !keysDown[3] && !keysDown[6] && !keysDown[7] && !animatedMove.pitch) {\n            config.pitch += speed.pitch * diff * slowDownFactor;\n        }\n        // Zoom\n        if (!keysDown[0] && !keysDown[1] && !animatedMove.hfov) {\n            setHfov(config.hfov + speed.hfov * diff * slowDownFactor);\n        }\n    }\n\n    prevTime = newTime;\n    if (diff > 0) {\n        speed.yaw = speed.yaw * 0.8 + (config.yaw - prevYaw) / diff * 0.2;\n        speed.pitch = speed.pitch * 0.8 + (config.pitch - prevPitch) / diff * 0.2;\n        speed.hfov = speed.hfov * 0.8 + (config.hfov - prevZoom) / diff * 0.2;\n        \n        // Limit speed\n        var maxSpeed = config.autoRotate ? Math.abs(config.autoRotate) : 5;\n        speed.yaw = Math.min(maxSpeed, Math.max(speed.yaw, -maxSpeed));\n        speed.pitch = Math.min(maxSpeed, Math.max(speed.pitch, -maxSpeed));\n        speed.hfov = Math.min(maxSpeed, Math.max(speed.hfov, -maxSpeed));\n    }\n    \n    // Stop movement if opposite controls are pressed\n    if (keysDown[0] && keysDown[1]) {\n        speed.hfov = 0;\n    }\n    if ((keysDown[2] || keysDown[6]) && (keysDown[3] || keysDown[7])) {\n        speed.pitch = 0;\n    }\n    if ((keysDown[4] || keysDown[8]) && (keysDown[5] || keysDown[9])) {\n        speed.yaw = 0;\n    }\n}\n\n/**\n * Animates moves.\n * @param {string} axis - Axis to animate\n * @private\n */\nfunction animateMove(axis) {\n    var t = animatedMove[axis];\n    var normTime = Math.min(1, Math.max((Date.now() - t.startTime) / 1000 / (t.duration / 1000), 0));\n    var result = t.startPosition + config.animationTimingFunction(normTime) * (t.endPosition - t.startPosition);\n    if ((t.endPosition > t.startPosition && result >= t.endPosition) ||\n        (t.endPosition < t.startPosition && result <= t.endPosition) ||\n        t.endPosition === t.startPosition) {\n        result = t.endPosition;\n        speed[axis] = 0;\n        delete animatedMove[axis];\n    }\n    config[axis] = result;\n}\n\n/**\n * @param {number} t - Normalized time in animation\n * @return {number} Position in animation\n * @private\n */\nfunction timingFunction(t) {\n    // easeInOutQuad from https://gist.github.com/gre/1650294\n    return t < 0.5 ? 2*t*t : -1+(4-2*t)*t;\n}\n\n/**\n * Event handler for document resizes. Updates viewer size and rerenders view.\n * @private\n */\nfunction onDocumentResize() {\n    // Resize panorama renderer (moved to onFullScreenChange)\n    //renderer.resize();\n    //animateInit();\n\n    // Kludge to deal with WebKit regression: https://bugs.webkit.org/show_bug.cgi?id=93525\n    onFullScreenChange('resize');\n}\n\n/**\n * Initializes animation.\n * @private\n */\nfunction animateInit() {\n    if (animating) {\n        return;\n    }\n    animating = true;\n    animate();\n}\n\n/**\n * Animates view, using requestAnimationFrame to trigger rendering.\n * @private\n */\nfunction animate() {\n    if (destroyed) {\n        return;\n    }\n\n    render();\n    if (autoRotateStart)\n        clearTimeout(autoRotateStart);\n    if (isUserInteracting || orientation === true) {\n        requestAnimationFrame(animate);\n    } else if (keysDown[0] || keysDown[1] || keysDown[2] || keysDown[3] ||\n        keysDown[4] || keysDown[5] || keysDown[6] || keysDown[7] ||\n        keysDown[8] || keysDown[9] || config.autoRotate ||\n        animatedMove.pitch || animatedMove.yaw || animatedMove.hfov ||\n        Math.abs(speed.yaw) > 0.01 || Math.abs(speed.pitch) > 0.01 ||\n        Math.abs(speed.hfov) > 0.01) {\n\n        keyRepeat();\n        if (config.autoRotateInactivityDelay >= 0 && autoRotateSpeed &&\n            Date.now() - latestInteraction > config.autoRotateInactivityDelay &&\n            !config.autoRotate) {\n            config.autoRotate = autoRotateSpeed;\n            _this.lookAt(origPitch, undefined, origHfov, 3000);\n        }\n        requestAnimationFrame(animate);\n    } else if (renderer && (renderer.isLoading() || (config.dynamic === true && update))) {\n        requestAnimationFrame(animate);\n    } else {\n        fireEvent('animatefinished', {pitch: _this.getPitch(), yaw: _this.getYaw(), hfov: _this.getHfov()});\n        animating = false;\n        prevTime = undefined;\n        var autoRotateStartTime = config.autoRotateInactivityDelay -\n            (Date.now() - latestInteraction);\n        if (autoRotateStartTime > 0) {\n            autoRotateStart = setTimeout(function() {\n                config.autoRotate = autoRotateSpeed;\n                _this.lookAt(origPitch, undefined, origHfov, 3000);\n                animateInit();\n            }, autoRotateStartTime);\n        } else if (config.autoRotateInactivityDelay >= 0 && autoRotateSpeed) {\n            config.autoRotate = autoRotateSpeed;\n            _this.lookAt(origPitch, undefined, origHfov, 3000);\n            animateInit();\n        }\n    }\n}\n\n/**\n * Renders panorama view.\n * @private\n */\nfunction render() {\n    var tmpyaw;\n\n    if (loaded) {\n        var canvas = renderer.getCanvas();\n\n        if (config.autoRotate !== false) {\n            // When auto-rotating this check needs to happen first (see issue #764)\n            if (config.yaw > 360) {\n                config.yaw -= 360;\n            } else if (config.yaw < -360) {\n                config.yaw += 360;\n            }\n        }\n\n        // Keep a tmp value of yaw for autoRotate comparison later\n        tmpyaw = config.yaw;\n\n        // Optionally avoid showing background (empty space) on left or right by adapting min/max yaw\n        var hoffcut = 0,\n            voffcut = 0;\n        if (config.avoidShowingBackground) {\n            var hfov2 = config.hfov / 2,\n                vfov2 = Math.atan2(Math.tan(hfov2 / 180 * Math.PI), (canvas.width / canvas.height)) * 180 / Math.PI,\n                transposed = config.vaov > config.haov;\n            if (transposed) {\n                voffcut = vfov2 * (1 - Math.min(Math.cos((config.pitch - hfov2) / 180 * Math.PI),\n                                                Math.cos((config.pitch + hfov2) / 180 * Math.PI)));\n            } else {\n                hoffcut = hfov2 * (1 - Math.min(Math.cos((config.pitch - vfov2) / 180 * Math.PI),\n                                                Math.cos((config.pitch + vfov2) / 180 * Math.PI)));\n            }\n        }\n\n        // Ensure the yaw is within min and max allowed\n        var yawRange = config.maxYaw - config.minYaw,\n            minYaw = -180,\n            maxYaw = 180;\n        if (yawRange < 360) {\n            minYaw = config.minYaw + config.hfov / 2 + hoffcut;\n            maxYaw = config.maxYaw - config.hfov / 2 - hoffcut;\n            if (yawRange < config.hfov) {\n                // Lock yaw to average of min and max yaw when both can be seen at once\n                minYaw = maxYaw = (minYaw + maxYaw) / 2;\n            }\n            config.yaw = Math.max(minYaw, Math.min(maxYaw, config.yaw));\n        }\n        \n        if (!(config.autoRotate !== false)) {\n            // When not auto-rotating, this check needs to happen after the\n            // previous check (see issue #698)\n            if (config.yaw > 360) {\n                config.yaw -= 360;\n            } else if (config.yaw < -360) {\n                config.yaw += 360;\n            }\n        }\n\n        // Check if we autoRotate in a limited by min and max yaw\n        // If so reverse direction\n        if (config.autoRotate !== false && tmpyaw != config.yaw &&\n            prevTime !== undefined) { // this condition prevents changing the direction initially\n            config.autoRotate *= -1;\n        }\n\n        // Ensure the calculated pitch is within min and max allowed\n        var vfov = 2 * Math.atan(Math.tan(config.hfov / 180 * Math.PI * 0.5) /\n            (canvas.width / canvas.height)) / Math.PI * 180;\n        var minPitch = config.minPitch + vfov / 2,\n            maxPitch = config.maxPitch - vfov / 2;\n        var pitchRange = config.maxPitch - config.minPitch;\n        if (pitchRange < vfov) {\n            // Lock pitch to average of min and max pitch when both can be seen at once\n            minPitch = maxPitch = (minPitch + maxPitch) / 2;\n        }\n        if (isNaN(minPitch))\n            minPitch = -90;\n        if (isNaN(maxPitch))\n            maxPitch = 90;\n        config.pitch = Math.max(minPitch, Math.min(maxPitch, config.pitch));\n        \n        renderer.render(config.pitch * Math.PI / 180, config.yaw * Math.PI / 180, config.hfov * Math.PI / 180, {roll: config.roll * Math.PI / 180});\n        \n        renderHotSpots();\n        \n        // Update compass\n        if (config.compass) {\n            compass.style.transform = 'rotate(' + (-config.yaw - config.northOffset) + 'deg)';\n            compass.style.webkitTransform = 'rotate(' + (-config.yaw - config.northOffset) + 'deg)';\n        }\n    }\n}\n\n/**\n * Creates a new quaternion.\n * @private\n * @constructor\n * @param {Number} w - W value\n * @param {Number} x - X value\n * @param {Number} y - Y value\n * @param {Number} z - Z value\n */\nfunction Quaternion(w, x, y, z) {\n    this.w = w;\n    this.x = x;\n    this.y = y;\n    this.z = z;\n}\n\n/**\n * Multiplies quaternions.\n * @private\n * @param {Quaternion} q - Quaternion to multiply\n * @returns {Quaternion} Result of multiplication\n */\nQuaternion.prototype.multiply = function(q) {\n    return new Quaternion(this.w*q.w - this.x*q.x - this.y*q.y - this.z*q.z,\n                          this.x*q.w + this.w*q.x + this.y*q.z - this.z*q.y,\n                          this.y*q.w + this.w*q.y + this.z*q.x - this.x*q.z,\n                          this.z*q.w + this.w*q.z + this.x*q.y - this.y*q.x);\n};\n\n/**\n * Converts quaternion to Euler angles.\n * @private\n * @returns {Number[]} [phi angle, theta angle, psi angle]\n */\nQuaternion.prototype.toEulerAngles = function() {\n    var phi = Math.atan2(2 * (this.w * this.x + this.y * this.z),\n                         1 - 2 * (this.x * this.x + this.y * this.y)),\n        theta = Math.asin(2 * (this.w * this.y - this.z * this.x)),\n        psi = Math.atan2(2 * (this.w * this.z + this.x * this.y),\n                         1 - 2 * (this.y * this.y + this.z * this.z));\n    return [phi, theta, psi];\n};\n\n/**\n * Converts device orientation API Tait-Bryan angles to a quaternion.\n * @private\n * @param {Number} alpha - Alpha angle (in degrees)\n * @param {Number} beta - Beta angle (in degrees)\n * @param {Number} gamma - Gamma angle (in degrees)\n * @returns {Quaternion} Orientation quaternion\n */\nfunction taitBryanToQuaternion(alpha, beta, gamma) {\n    var r = [beta ? beta * Math.PI / 180 / 2 : 0,\n             gamma ? gamma * Math.PI / 180 / 2 : 0,\n             alpha ? alpha * Math.PI / 180 / 2 : 0];\n    var c = [Math.cos(r[0]), Math.cos(r[1]), Math.cos(r[2])],\n        s = [Math.sin(r[0]), Math.sin(r[1]), Math.sin(r[2])];\n\n    return new Quaternion(c[0]*c[1]*c[2] - s[0]*s[1]*s[2],\n                          s[0]*c[1]*c[2] - c[0]*s[1]*s[2],\n                          c[0]*s[1]*c[2] + s[0]*c[1]*s[2],\n                          c[0]*c[1]*s[2] + s[0]*s[1]*c[2]);\n}\n\n/**\n * Computes current device orientation quaternion from device orientation API\n * Tait-Bryan angles.\n * @private\n * @param {Number} alpha - Alpha angle (in degrees)\n * @param {Number} beta - Beta angle (in degrees)\n * @param {Number} gamma - Gamma angle (in degrees)\n * @returns {Quaternion} Orientation quaternion\n */\nfunction computeQuaternion(alpha, beta, gamma) {\n    // Convert Tait-Bryan angles to quaternion\n    var quaternion = taitBryanToQuaternion(alpha, beta, gamma);\n    // Apply world transform\n    quaternion = quaternion.multiply(new Quaternion(Math.sqrt(0.5), -Math.sqrt(0.5), 0, 0));\n    // Apply screen transform\n    var angle = window.orientation ? -window.orientation * Math.PI / 180 / 2 : 0;\n    return quaternion.multiply(new Quaternion(Math.cos(angle), 0, -Math.sin(angle), 0));\n}\n\n/**\n * Event handler for device orientation API. Controls pointing.\n * @private\n * @param {DeviceOrientationEvent} event - Device orientation event.\n */\nfunction orientationListener(e) {\n    var q = computeQuaternion(e.alpha, e.beta, e.gamma).toEulerAngles();\n    if (typeof(orientation) == 'number' && orientation < 10) {\n        // This kludge is necessary because iOS sometimes provides a few stale\n        // device orientation events when the listener is removed and then\n        // readded. Thus, we skip the first 10 events to prevent this from\n        // causing problems.\n        orientation += 1;\n    } else if (orientation === 10) {\n        // Record starting yaw to prevent jumping\n        orientationYawOffset = q[2] / Math.PI * 180 + config.yaw;\n        orientation = true;\n        requestAnimationFrame(animate);\n    } else {\n        config.pitch = q[0] / Math.PI * 180;\n        config.roll = -q[1] / Math.PI * 180;\n        config.yaw = -q[2] / Math.PI * 180 + orientationYawOffset;\n    }\n}\n\n/**\n * Initializes renderer.\n * @private\n */\nfunction renderInit() {\n    try {\n        var params = {};\n        if (config.horizonPitch !== undefined)\n            params.horizonPitch = config.horizonPitch * Math.PI / 180;\n        if (config.horizonRoll !== undefined)\n            params.horizonRoll = config.horizonRoll * Math.PI / 180;\n        if (config.backgroundColor !== undefined)\n            params.backgroundColor = config.backgroundColor;\n        renderer.init(panoImage, config.type, config.dynamic, config.haov * Math.PI / 180, config.vaov * Math.PI / 180, config.vOffset * Math.PI / 180, renderInitCallback, params);\n        if (config.dynamic !== true) {\n            // Allow image to be garbage collected\n            panoImage = undefined;\n        }\n    } catch(event) {\n        // Panorama not loaded\n        \n        // Display error if there is a bad texture\n        if (event.type == 'webgl error' || event.type == 'no webgl') {\n            anError();\n        } else if (event.type == 'webgl size error') {\n            anError(config.strings.textureSizeError.replace('%s', event.width).replace('%s', event.maxWidth));\n        } else {\n            anError(config.strings.unknownError);\n            throw event;\n        }\n    }\n}\n\n/**\n * Triggered when render initialization finishes. Handles fading between\n * scenes as well as showing the compass and hotspots and hiding the loading\n * display.\n * @private\n */\nfunction renderInitCallback() {\n    // Fade if specified\n    if (config.sceneFadeDuration && renderer.fadeImg !== undefined) {\n        renderer.fadeImg.style.opacity = 0;\n        // Remove image\n        var fadeImg = renderer.fadeImg;\n        delete renderer.fadeImg;\n        setTimeout(function() {\n            renderContainer.removeChild(fadeImg);\n            fireEvent('scenechangefadedone');\n        }, config.sceneFadeDuration);\n    }\n    \n    // Show compass if applicable\n    if (config.compass) {\n        compass.style.display = 'inline';\n    } else {\n        compass.style.display = 'none';\n    }\n    \n    // Show hotspots\n    createHotSpots();\n    \n    // Hide loading display\n    infoDisplay.load.box.style.display = 'none';\n    if (preview !== undefined) {\n        renderContainer.removeChild(preview);\n        preview = undefined;\n    }\n    loaded = true;\n    \n    animateInit();\n\n    fireEvent('load');\n}\n\n/**\n * Creates hot spot element for the current scene.\n * @private\n * @param {Object} hs - The configuration for the hotspot\n */\nfunction createHotSpot(hs) {\n    // Make sure hot spot pitch and yaw are numbers\n    hs.pitch = Number(hs.pitch) || 0;\n    hs.yaw = Number(hs.yaw) || 0;\n\n    var div = document.createElement('div');\n    div.className = 'pnlm-hotspot-base';\n    if (hs.cssClass)\n        div.className += ' ' + hs.cssClass;\n    else\n        div.className += ' pnlm-hotspot pnlm-sprite pnlm-' + escapeHTML(hs.type);\n\n    var span = document.createElement('span');\n    if (hs.text)\n        span.innerHTML = escapeHTML(hs.text);\n\n    var a;\n    if (hs.video) {\n        var video = document.createElement('video'),\n            vidp = hs.video;\n        if (config.basePath && !absoluteURL(vidp))\n            vidp = config.basePath + vidp;\n        video.src = sanitizeURL(vidp);\n        video.controls = true;\n        video.style.width = hs.width + 'px';\n        renderContainer.appendChild(div);\n        span.appendChild(video);\n    } else if (hs.image) {\n        var imgp = hs.image;\n        if (config.basePath && !absoluteURL(imgp))\n            imgp = config.basePath + imgp;\n        a = document.createElement('a');\n        a.href = sanitizeURL(hs.URL ? hs.URL : imgp);\n        a.target = '_blank';\n        span.appendChild(a);\n        var image = document.createElement('img');\n        image.src = sanitizeURL(imgp);\n        image.style.width = hs.width + 'px';\n        image.style.paddingTop = '5px';\n        renderContainer.appendChild(div);\n        a.appendChild(image);\n        span.style.maxWidth = 'initial';\n    } else if (hs.URL) {\n        a = document.createElement('a');\n        a.href = sanitizeURL(hs.URL);\n        if (hs.attributes) {\n            for (var key in hs.attributes) {\n                a.setAttribute(key, hs.attributes[key]);\n            }\n        } else {\n            a.target = '_blank';\n        }\n        renderContainer.appendChild(a);\n        div.className += ' pnlm-pointer';\n        span.className += ' pnlm-pointer';\n        a.appendChild(div);\n    } else {\n        if (hs.sceneId) {\n            div.onclick = div.ontouchend = function() {\n                if (!div.clicked) {\n                    div.clicked = true;\n                    loadScene(hs.sceneId, hs.targetPitch, hs.targetYaw, hs.targetHfov);\n                }\n                return false;\n            };\n            div.className += ' pnlm-pointer';\n            span.className += ' pnlm-pointer';\n        }\n        renderContainer.appendChild(div);\n    }\n\n    if (hs.createTooltipFunc) {\n        hs.createTooltipFunc(div, hs.createTooltipArgs);\n    } else if (hs.text || hs.video || hs.image) {\n        div.classList.add('pnlm-tooltip');\n        div.appendChild(span);\n        span.style.width = span.scrollWidth - 20 + 'px';\n        span.style.marginLeft = -(span.scrollWidth - div.offsetWidth) / 2 + 'px';\n        span.style.marginTop = -span.scrollHeight - 12 + 'px';\n    }\n    if (hs.clickHandlerFunc) {\n        div.addEventListener('click', function(e) {\n            hs.clickHandlerFunc(e, hs.clickHandlerArgs);\n        }, 'false');\n        div.className += ' pnlm-pointer';\n        span.className += ' pnlm-pointer';\n    }\n    hs.div = div;\n}\n\n/**\n * Creates hot spot elements for the current scene.\n * @private\n */\nfunction createHotSpots() {\n    if (hotspotsCreated) return;\n\n    if (!config.hotSpots) {\n        config.hotSpots = [];\n    } else {\n        // Sort by pitch so tooltip is never obscured by another hot spot\n        config.hotSpots = config.hotSpots.sort(function(a, b) {\n            return a.pitch < b.pitch;\n        });\n        config.hotSpots.forEach(createHotSpot);\n    }\n    hotspotsCreated = true;\n    renderHotSpots();\n}\n\n/**\n * Destroys currently created hot spot elements.\n * @private\n */\nfunction destroyHotSpots() {\n    var hs = config.hotSpots;\n    hotspotsCreated = false;\n    delete config.hotSpots;\n    if (hs) {\n        for (var i = 0; i < hs.length; i++) {\n            var current = hs[i].div;\n            if (current) {\n                while (current.parentNode && current.parentNode != renderContainer) {\n                    current = current.parentNode;\n                }\n                renderContainer.removeChild(current);\n            }\n            delete hs[i].div;\n        }\n    }\n}\n\n/**\n * Renders hot spot, updating its position and visibility.\n * @private\n */\nfunction renderHotSpot(hs) {\n    var hsPitchSin = Math.sin(hs.pitch * Math.PI / 180),\n        hsPitchCos = Math.cos(hs.pitch * Math.PI / 180),\n        configPitchSin = Math.sin(config.pitch * Math.PI / 180),\n        configPitchCos = Math.cos(config.pitch * Math.PI / 180),\n        yawCos = Math.cos((-hs.yaw + config.yaw) * Math.PI / 180);\n    var z = hsPitchSin * configPitchSin + hsPitchCos * yawCos * configPitchCos;\n    if ((hs.yaw <= 90 && hs.yaw > -90 && z <= 0) ||\n      ((hs.yaw > 90 || hs.yaw <= -90) && z <= 0)) {\n        hs.div.style.visibility = 'hidden';\n    } else {\n        var yawSin = Math.sin((-hs.yaw + config.yaw) * Math.PI / 180),\n            hfovTan = Math.tan(config.hfov * Math.PI / 360);\n        hs.div.style.visibility = 'visible';\n        // Subpixel rendering doesn't work in Firefox\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=739176\n        var canvas = renderer.getCanvas(),\n            canvasWidth = canvas.clientWidth,\n            canvasHeight = canvas.clientHeight;\n        var coord = [-canvasWidth / hfovTan * yawSin * hsPitchCos / z / 2,\n            -canvasWidth / hfovTan * (hsPitchSin * configPitchCos -\n            hsPitchCos * yawCos * configPitchSin) / z / 2];\n        // Apply roll\n        var rollSin = Math.sin(config.roll * Math.PI / 180),\n            rollCos = Math.cos(config.roll * Math.PI / 180);\n        coord = [coord[0] * rollCos - coord[1] * rollSin,\n                 coord[0] * rollSin + coord[1] * rollCos];\n        // Apply transform\n        coord[0] += (canvasWidth - hs.div.offsetWidth) / 2;\n        coord[1] += (canvasHeight - hs.div.offsetHeight) / 2;\n        var transform = 'translate(' + coord[0] + 'px, ' + coord[1] +\n            'px) translateZ(9999px) rotate(' + config.roll + 'deg)';\n        if (hs.scale) {\n            transform += ' scale(' + (origHfov/config.hfov) / z + ')';\n        }\n        hs.div.style.webkitTransform = transform;\n        hs.div.style.MozTransform = transform;\n        hs.div.style.transform = transform;\n    }\n}\n\n/**\n * Renders hot spots, updating their positions and visibility.\n * @private\n */\nfunction renderHotSpots() {\n    config.hotSpots.forEach(renderHotSpot);\n}\n\n/**\n * Merges a scene configuration into the current configuration.\n * @private\n * @param {string} sceneId - Identifier of scene configuration to merge in.\n */\nfunction mergeConfig(sceneId) {\n    config = {};\n    var k, s;\n    var photoSphereExcludes = ['haov', 'vaov', 'vOffset', 'northOffset', 'horizonPitch', 'horizonRoll'];\n    specifiedPhotoSphereExcludes = [];\n    \n    // Merge default config\n    for (k in defaultConfig) {\n        if (defaultConfig.hasOwnProperty(k)) {\n            config[k] = defaultConfig[k];\n        }\n    }\n    \n    // Merge default scene config\n    for (k in initialConfig.default) {\n        if (initialConfig.default.hasOwnProperty(k)) {\n            if (k == 'strings') {\n                for (s in initialConfig.default.strings) {\n                    if (initialConfig.default.strings.hasOwnProperty(s)) {\n                        config.strings[s] = escapeHTML(initialConfig.default.strings[s]);\n                    }\n                }\n            } else {\n                config[k] = initialConfig.default[k];\n                if (photoSphereExcludes.indexOf(k) >= 0) {\n                    specifiedPhotoSphereExcludes.push(k);\n                }\n            }\n        }\n    }\n    \n    // Merge current scene config\n    if ((sceneId !== null) && (sceneId !== '') && (initialConfig.scenes) && (initialConfig.scenes[sceneId])) {\n        var scene = initialConfig.scenes[sceneId];\n        for (k in scene) {\n            if (scene.hasOwnProperty(k)) {\n                if (k == 'strings') {\n                    for (s in scene.strings) {\n                        if (scene.strings.hasOwnProperty(s)) {\n                            config.strings[s] = escapeHTML(scene.strings[s]);\n                        }\n                    }\n                } else {\n                    config[k] = scene[k];\n                    if (photoSphereExcludes.indexOf(k) >= 0) {\n                        specifiedPhotoSphereExcludes.push(k);\n                    }\n                }\n            }\n        }\n        config.scene = sceneId;\n    }\n    \n    // Merge initial config\n    for (k in initialConfig) {\n        if (initialConfig.hasOwnProperty(k)) {\n            if (k == 'strings') {\n                for (s in initialConfig.strings) {\n                    if (initialConfig.strings.hasOwnProperty(s)) {\n                        config.strings[s] = escapeHTML(initialConfig.strings[s]);\n                    }\n                }\n            } else {\n                config[k] = initialConfig[k];\n                if (photoSphereExcludes.indexOf(k) >= 0) {\n                    specifiedPhotoSphereExcludes.push(k);\n                }\n            }\n        }\n    }\n}\n\n/**\n * Processes configuration options.\n * @param {boolean} [isPreview] - Whether or not the preview is being displayed\n * @private\n */\nfunction processOptions(isPreview) {\n    isPreview = isPreview ? isPreview : false;\n\n    // Process preview first so it always loads before the browser hits its\n    // maximum number of connections to a server as can happen with cubic\n    // panoramas\n    if (isPreview && 'preview' in config) {\n        var p = config.preview;\n        if (config.basePath && !absoluteURL(p))\n            p = config.basePath + p;\n        preview = document.createElement('div');\n        preview.className = 'pnlm-preview-img';\n        preview.style.backgroundImage = \"url('\" + sanitizeURLForCss(p) + \"')\";\n        renderContainer.appendChild(preview);\n    }\n\n    // Handle different preview values\n    var title = config.title,\n        author = config.author;\n    if (isPreview) {\n        if ('previewTitle' in config)\n            config.title = config.previewTitle;\n        if ('previewAuthor' in config)\n            config.author = config.previewAuthor;\n    }\n\n    // Reset title / author display\n    if (!config.hasOwnProperty('title'))\n        infoDisplay.title.innerHTML = '';\n    if (!config.hasOwnProperty('author'))\n        infoDisplay.author.innerHTML = '';\n    if (!config.hasOwnProperty('title') && !config.hasOwnProperty('author'))\n        infoDisplay.container.style.display = 'none';\n\n    // Fill in load button label and loading box text\n    controls.load.innerHTML = '<p>' + config.strings.loadButtonLabel + '</p>';\n    infoDisplay.load.boxp.innerHTML = config.strings.loadingLabel;\n\n    // Process other options\n    for (var key in config) {\n      if (config.hasOwnProperty(key)) {\n        switch(key) {\n            case 'title':\n                infoDisplay.title.innerHTML = escapeHTML(config[key]);\n                infoDisplay.container.style.display = 'inline';\n                break;\n            \n            case 'author':\n                var authorText = escapeHTML(config[key]);\n                if (config.authorURL) {\n                    var authorLink = document.createElement('a');\n                    authorLink.href = sanitizeURL(config['authorURL']);\n                    authorLink.target = '_blank';\n                    authorLink.innerHTML = escapeHTML(config[key]);\n                    authorText = authorLink.outerHTML;\n                }\n                infoDisplay.author.innerHTML = config.strings.bylineLabel.replace('%s', authorText);\n                infoDisplay.container.style.display = 'inline';\n                break;\n            \n            case 'fallback':\n                var link = document.createElement('a');\n                link.href = sanitizeURL(config[key]);\n                link.target = '_blank';\n                link.textContent = 'Click here to view this panorama in an alternative viewer.';\n                var message = document.createElement('p');\n                message.textContent = 'Your browser does not support WebGL.';\n                message.appendChild(document.createElement('br'));\n                message.appendChild(link);\n                infoDisplay.errorMsg.innerHTML = ''; // Removes all children nodes\n                infoDisplay.errorMsg.appendChild(message);\n                break;\n            \n            case 'hfov':\n                setHfov(Number(config[key]));\n                break;\n            \n            case 'autoLoad':\n                if (config[key] === true && renderer === undefined) {\n                    // Show loading box\n                    infoDisplay.load.box.style.display = 'inline';\n                    // Hide load button\n                    controls.load.style.display = 'none';\n                    // Initialize\n                    init();\n                }\n                break;\n            \n            case 'showZoomCtrl':\n                if (config[key] && config.showControls != false) {\n                    // Show zoom controls\n                    controls.zoom.style.display = 'block';\n                } else {\n                    // Hide zoom controls\n                    controls.zoom.style.display = 'none';\n                }\n                break;\n\n            case 'showFullscreenCtrl':\n                if (config[key] && config.showControls != false && ('fullscreen' in document || 'mozFullScreen' in document ||\n                    'webkitIsFullScreen' in document || 'msFullscreenElement' in document)) {\n                    \n                    // Show fullscreen control\n                    controls.fullscreen.style.display = 'block';\n                } else {\n                    // Hide fullscreen control\n                    controls.fullscreen.style.display = 'none';\n                }\n                break;\n\n            case 'hotSpotDebug':\n                if (config[key])\n                    hotSpotDebugIndicator.style.display = 'block';\n                else\n                    hotSpotDebugIndicator.style.display = 'none';\n                break;\n\n            case 'showControls':\n                if (!config[key]) {\n                    controls.orientation.style.display = 'none';\n                    controls.zoom.style.display = 'none';\n                    controls.fullscreen.style.display = 'none';\n                }\n                break;\n\n            case 'orientationOnByDefault':\n                if (config[key])\n                    startOrientation();\n                break;\n        }\n      }\n    }\n\n    if (isPreview) {\n        // Restore original values if changed for preview\n        if (title)\n            config.title = title;\n        else\n            delete config.title;\n        if (author)\n            config.author = author;\n        else\n            delete config.author;\n    }\n}\n\n/**\n * Toggles fullscreen mode.\n * @private\n */\nfunction toggleFullscreen() {\n    if (loaded && !error) {\n        if (!fullscreenActive) {\n            try {\n                if (container.requestFullscreen) {\n                    container.requestFullscreen();\n                } else if (container.mozRequestFullScreen) {\n                    container.mozRequestFullScreen();\n                } else if (container.msRequestFullscreen) {\n                    container.msRequestFullscreen();\n                } else {\n                    container.webkitRequestFullScreen();\n                }\n            } catch(event) {\n                // Fullscreen doesn't work\n            }\n        } else {\n            if (document.exitFullscreen) {\n                document.exitFullscreen();\n            } else if (document.mozCancelFullScreen) {\n                document.mozCancelFullScreen();\n            } else if (document.webkitCancelFullScreen) {\n                document.webkitCancelFullScreen();\n            } else if (document.msExitFullscreen) {\n                document.msExitFullscreen();\n            }\n        }\n    }\n}\n\n/**\n * Event handler for fullscreen changes.\n * @private\n */\nfunction onFullScreenChange(resize) {\n    if (document.fullscreenElement || document.fullscreen || document.mozFullScreen || document.webkitIsFullScreen || document.msFullscreenElement) {\n        controls.fullscreen.classList.add('pnlm-fullscreen-toggle-button-active');\n        fullscreenActive = true;\n    } else {\n        controls.fullscreen.classList.remove('pnlm-fullscreen-toggle-button-active');\n        fullscreenActive = false;\n    }\n    if (resize !== 'resize')\n        fireEvent('fullscreenchange', fullscreenActive);\n    // Resize renderer (deal with browser quirks and fixes #155)\n    renderer.resize();\n    setHfov(config.hfov);\n    animateInit();\n}\n\n/**\n * Increases panorama zoom. For use with zoom button.\n * @private\n */\nfunction zoomIn() {\n    if (loaded) {\n        setHfov(config.hfov - 5);\n        animateInit();\n    }\n}\n\n/**\n * Decreases panorama zoom. For use with zoom button.\n * @private\n */\nfunction zoomOut() {\n    if (loaded) {\n        setHfov(config.hfov + 5);\n        animateInit();\n    }\n}\n\n/**\n * Clamps horzontal field of view to viewer's limits.\n * @private\n * @param {number} hfov - Input horizontal field of view (in degrees)\n * @return {number} - Clamped horizontal field of view (in degrees)\n */\nfunction constrainHfov(hfov) {\n    // Keep field of view within bounds\n    var minHfov = config.minHfov;\n    if (config.type == 'multires' && renderer && !config.multiResMinHfov) {\n        minHfov = Math.min(minHfov, renderer.getCanvas().width / (config.multiRes.cubeResolution / 90 * 0.9));\n    }\n    if (minHfov > config.maxHfov) {\n        // Don't change view if bounds don't make sense\n        console.log('HFOV bounds do not make sense (minHfov > maxHfov).');\n        return config.hfov;\n    }\n    var newHfov = config.hfov;\n    if (hfov < minHfov) {\n        newHfov = minHfov;\n    } else if (hfov > config.maxHfov) {\n        newHfov = config.maxHfov;\n    } else {\n        newHfov = hfov;\n    }\n    // Optionally avoid showing background (empty space) on top or bottom by adapting newHfov\n    if (config.avoidShowingBackground && renderer) {\n        var canvas = renderer.getCanvas();\n        newHfov = Math.min(newHfov,\n                           Math.atan(Math.tan((config.maxPitch - config.minPitch) / 360 * Math.PI) /\n                                     canvas.height * canvas.width) * 360 / Math.PI);\n    }\n    return newHfov;\n}\n\n/**\n * Sets viewer's horizontal field of view.\n * @private\n * @param {number} hfov - Desired horizontal field of view in degrees.\n */\nfunction setHfov(hfov) {\n    config.hfov = constrainHfov(hfov);\n    fireEvent('zoomchange', config.hfov);\n}\n\n/**\n * Stops auto rotation and animated moves.\n * @private\n */\nfunction stopAnimation() {\n    animatedMove = {};\n    autoRotateSpeed = config.autoRotate ? config.autoRotate : autoRotateSpeed;\n    config.autoRotate = false;\n}\n\n/**\n * Loads panorama.\n * @private\n */\nfunction load() {\n    // Since WebGL error handling is very general, first we clear any error box\n    // since it is a new scene and the error from previous maybe because of lacking\n    // memory etc and not because of a lack of WebGL support etc\n    clearError();\n    loaded = false;\n\n    controls.load.style.display = 'none';\n    infoDisplay.load.box.style.display = 'inline';\n    init();\n}\n\n/**\n * Loads scene.\n * @private\n * @param {string} sceneId - Identifier of scene configuration to merge in.\n * @param {number} targetPitch - Pitch viewer should be centered on once scene loads.\n * @param {number} targetYaw - Yaw viewer should be centered on once scene loads.\n * @param {number} targetHfov - HFOV viewer should use once scene loads.\n * @param {boolean} [fadeDone] - If `true`, fade setup is skipped.\n */\nfunction loadScene(sceneId, targetPitch, targetYaw, targetHfov, fadeDone) {\n    if (!loaded)\n        fadeDone = true;    // Don't try to fade when there isn't a scene loaded\n    loaded = false;\n    animatedMove = {};\n    \n    // Set up fade if specified\n    var fadeImg, workingPitch, workingYaw, workingHfov;\n    if (config.sceneFadeDuration && !fadeDone) {\n        var data = renderer.render(config.pitch * Math.PI / 180, config.yaw * Math.PI / 180, config.hfov * Math.PI / 180, {returnImage: true});\n        if (data !== undefined) {\n            fadeImg = new Image();\n            fadeImg.className = 'pnlm-fade-img';\n            fadeImg.style.transition = 'opacity ' + (config.sceneFadeDuration / 1000) + 's';\n            fadeImg.style.width = '100%';\n            fadeImg.style.height = '100%';\n            fadeImg.onload = function() {\n                loadScene(sceneId, targetPitch, targetYaw, targetHfov, true);\n            };\n            fadeImg.src = data;\n            renderContainer.appendChild(fadeImg);\n            renderer.fadeImg = fadeImg;\n            return;\n        }\n    }\n    \n    // Set new pointing\n    if (targetPitch === 'same') {\n        workingPitch = config.pitch;\n    } else {\n        workingPitch = targetPitch;\n    }\n    if (targetYaw === 'same') {\n        workingYaw = config.yaw;\n    } else if (targetYaw === 'sameAzimuth') {\n        workingYaw = config.yaw + (config.northOffset || 0) - (initialConfig.scenes[sceneId].northOffset || 0);\n    } else {\n        workingYaw = targetYaw;\n    }\n    if (targetHfov === 'same') {\n        workingHfov = config.hfov;\n    } else {\n        workingHfov = targetHfov;\n    }\n    \n    // Destroy hot spots from previous scene\n    destroyHotSpots();\n    \n    // Create the new config for the scene\n    mergeConfig(sceneId);\n\n    // Stop motion\n    speed.yaw = speed.pitch = speed.hfov = 0;\n\n    // Reload scene\n    processOptions();\n    if (workingPitch !== undefined) {\n        config.pitch = workingPitch;\n    }\n    if (workingYaw !== undefined) {\n        config.yaw = workingYaw;\n    }\n    if (workingHfov !== undefined) {\n        config.hfov = workingHfov;\n    }\n    fireEvent('scenechange', sceneId);\n    load();\n}\n\n/**\n * Stop using device orientation.\n * @private\n */\nfunction stopOrientation() {\n    window.removeEventListener('deviceorientation', orientationListener);\n    controls.orientation.classList.remove('pnlm-orientation-button-active');\n    orientation = false;\n}\n\n/**\n * Start using device orientation.\n * @private\n */\nfunction startOrientation() {\n    if (typeof DeviceMotionEvent.requestPermission === 'function') {\n        DeviceOrientationEvent.requestPermission().then(response => {\n            if (response == 'granted') {\n                orientation = 1;\n                window.addEventListener('deviceorientation', orientationListener);\n                controls.orientation.classList.add('pnlm-orientation-button-active');\n            }\n        });\n    } else {\n        orientation = 1;\n        window.addEventListener('deviceorientation', orientationListener);\n        controls.orientation.classList.add('pnlm-orientation-button-active');\n    }\n}\n\n/**\n * Escapes HTML string (to mitigate possible DOM XSS attacks).\n * @private\n * @param {string} s - String to escape\n * @returns {string} Escaped string\n */\nfunction escapeHTML(s) {\n    if (!initialConfig.escapeHTML)\n        return String(s).split('\\n').join('<br>');\n    return String(s).split(/&/g).join('&amp;')\n        .split('\"').join('&quot;')\n        .split(\"'\").join('&#39;')\n        .split('<').join('&lt;')\n        .split('>').join('&gt;')\n        .split('/').join('&#x2f;')\n        .split('\\n').join('<br>');  // Allow line breaks\n}\n\n/**\n * Removes possibility of XSS attacks with URLs.\n * The URL cannot be of protocol 'javascript'.\n * @private\n * @param {string} url - URL to sanitize\n * @returns {string} Sanitized URL\n */\nfunction sanitizeURL(url) {\n    if (url.trim().toLowerCase().indexOf('javascript:') === 0) {\n        return 'about:blank';\n    }\n    return url;\n}\n\n/**\n * Removes possibility of XSS atacks with URLs for CSS.\n * The URL will be sanitized with `sanitizeURL()` and single quotes\n * and double quotes escaped.\n * @private\n * @param {string} url - URL to sanitize\n * @returns {string} Sanitized URL\n */\nfunction sanitizeURLForCss(url) {\n    return sanitizeURL(url)\n        .replace(/\"/g, '%22')\n        .replace(/'/g, '%27');\n}\n\n/**\n * Checks whether or not a panorama is loaded.\n * @memberof Viewer\n * @instance\n * @returns {boolean} `true` if a panorama is loaded, else `false`\n */\nthis.isLoaded = function() {\n    return Boolean(loaded);\n};\n\n/**\n * Returns the pitch of the center of the view.\n * @memberof Viewer\n * @instance\n * @returns {number} Pitch in degrees\n */\nthis.getPitch = function() {\n    return config.pitch;\n};\n\n/**\n * Sets the pitch of the center of the view.\n * @memberof Viewer\n * @instance\n * @param {number} pitch - Pitch in degrees\n * @param {boolean|number} [animated=1000] - Animation duration in milliseconds or false for no animation\n * @param {function} [callback] - Function to call when animation finishes\n * @param {object} [callbackArgs] - Arguments to pass to callback function\n * @returns {Viewer} `this`\n */\nthis.setPitch = function(pitch, animated, callback, callbackArgs) {\n    latestInteraction = Date.now();\n    if (Math.abs(pitch - config.pitch) <= eps) {\n        if (typeof callback == 'function')\n            callback(callbackArgs);\n        return this;\n    }\n    animated = animated == undefined ? 1000: Number(animated);\n    if (animated) {\n        animatedMove.pitch = {\n            'startTime': Date.now(),\n            'startPosition': config.pitch,\n            'endPosition': pitch,\n            'duration': animated\n        };\n        if (typeof callback == 'function')\n            setTimeout(function(){callback(callbackArgs);}, animated);\n    } else {\n        config.pitch = pitch;\n    }\n    animateInit();\n    return this;\n};\n\n/**\n * Returns the minimum and maximum allowed pitches (in degrees).\n * @memberof Viewer\n * @instance\n * @returns {number[]} [minimum pitch, maximum pitch]\n */\nthis.getPitchBounds = function() {\n    return [config.minPitch, config.maxPitch];\n};\n\n/**\n * Set the minimum and maximum allowed pitches (in degrees).\n * @memberof Viewer\n * @instance\n * @param {number[]} bounds - [minimum pitch, maximum pitch]\n * @returns {Viewer} `this`\n */\nthis.setPitchBounds = function(bounds) {\n    config.minPitch = Math.max(-90, Math.min(bounds[0], 90));\n    config.maxPitch = Math.max(-90, Math.min(bounds[1], 90));\n    return this;\n};\n\n/**\n * Returns the yaw of the center of the view.\n * @memberof Viewer\n * @instance\n * @returns {number} Yaw in degrees\n */\nthis.getYaw = function() {\n    return (config.yaw + 540) % 360 - 180;\n};\n\n/**\n * Sets the yaw of the center of the view.\n * @memberof Viewer\n * @instance\n * @param {number} yaw - Yaw in degrees [-180, 180]\n * @param {boolean|number} [animated=1000] - Animation duration in milliseconds or false for no animation\n * @param {function} [callback] - Function to call when animation finishes\n * @param {object} [callbackArgs] - Arguments to pass to callback function\n * @returns {Viewer} `this`\n */\nthis.setYaw = function(yaw, animated, callback, callbackArgs) {\n    latestInteraction = Date.now();\n    if (Math.abs(yaw - config.yaw) <= eps) {\n        if (typeof callback == 'function')\n            callback(callbackArgs);\n        return this;\n    }\n    animated = animated == undefined ? 1000: Number(animated);\n    yaw = ((yaw + 180) % 360) - 180; // Keep in bounds\n    if (animated) {\n        // Animate in shortest direction\n        if (config.yaw - yaw > 180)\n            yaw += 360;\n        else if (yaw - config.yaw > 180)\n            yaw -= 360;\n\n        animatedMove.yaw = {\n            'startTime': Date.now(),\n            'startPosition': config.yaw,\n            'endPosition': yaw,\n            'duration': animated\n        };\n        if (typeof callback == 'function')\n            setTimeout(function(){callback(callbackArgs);}, animated);\n    } else {\n        config.yaw = yaw;\n    }\n    animateInit();\n    return this;\n};\n\n/**\n * Returns the minimum and maximum allowed pitches (in degrees).\n * @memberof Viewer\n * @instance\n * @returns {number[]} [yaw pitch, maximum yaw]\n */\nthis.getYawBounds = function() {\n    return [config.minYaw, config.maxYaw];\n};\n\n/**\n * Set the minimum and maximum allowed yaws (in degrees [-360, 360]).\n * @memberof Viewer\n * @instance\n * @param {number[]} bounds - [minimum yaw, maximum yaw]\n * @returns {Viewer} `this`\n */\nthis.setYawBounds = function(bounds) {\n    config.minYaw = Math.max(-360, Math.min(bounds[0], 360));\n    config.maxYaw = Math.max(-360, Math.min(bounds[1], 360));\n    return this;\n};\n\n/**\n * Returns the horizontal field of view.\n * @memberof Viewer\n * @instance\n * @returns {number} Horizontal field of view in degrees\n */\nthis.getHfov = function() {\n    return config.hfov;\n};\n\n/**\n * Sets the horizontal field of view.\n * @memberof Viewer\n * @instance\n * @param {number} hfov - Horizontal field of view in degrees\n * @param {boolean|number} [animated=1000] - Animation duration in milliseconds or false for no animation\n * @param {function} [callback] - Function to call when animation finishes\n * @param {object} [callbackArgs] - Arguments to pass to callback function\n * @returns {Viewer} `this`\n */\nthis.setHfov = function(hfov, animated, callback, callbackArgs) {\n    latestInteraction = Date.now();\n    if (Math.abs(hfov - config.hfov) <= eps) {\n        if (typeof callback == 'function')\n            callback(callbackArgs);\n        return this;\n    }\n    animated = animated == undefined ? 1000: Number(animated);\n    if (animated) {\n        animatedMove.hfov = {\n            'startTime': Date.now(),\n            'startPosition': config.hfov,\n            'endPosition': constrainHfov(hfov),\n            'duration': animated\n        };\n        if (typeof callback == 'function')\n            setTimeout(function(){callback(callbackArgs);}, animated);\n    } else {\n        setHfov(hfov);\n    }\n    animateInit();\n    return this;\n};\n\n/**\n * Returns the minimum and maximum allowed horizontal fields of view\n * (in degrees).\n * @memberof Viewer\n * @instance\n * @returns {number[]} [minimum hfov, maximum hfov]\n */\nthis.getHfovBounds = function() {\n    return [config.minHfov, config.maxHfov];\n};\n\n/**\n * Set the minimum and maximum allowed horizontal fields of view (in degrees).\n * @memberof Viewer\n * @instance\n * @param {number[]} bounds - [minimum hfov, maximum hfov]\n * @returns {Viewer} `this`\n */\nthis.setHfovBounds = function(bounds) {\n    config.minHfov = Math.max(0, bounds[0]);\n    config.maxHfov = Math.max(0, bounds[1]);\n    return this;\n};\n\n/**\n * Set a new view. Any parameters not specified remain the same.\n * @memberof Viewer\n * @instance\n * @param {number} [pitch] - Target pitch\n * @param {number} [yaw] - Target yaw\n * @param {number} [hfov] - Target hfov\n * @param {boolean|number} [animated=1000] - Animation duration in milliseconds or false for no animation\n * @param {function} [callback] - Function to call when animation finishes\n * @param {object} [callbackArgs] - Arguments to pass to callback function\n * @returns {Viewer} `this`\n */\nthis.lookAt = function(pitch, yaw, hfov, animated, callback, callbackArgs) {\n    animated = animated == undefined ? 1000: Number(animated);\n    if (pitch !== undefined && Math.abs(pitch - config.pitch) > eps) {\n        this.setPitch(pitch, animated, callback, callbackArgs);\n        callback = undefined;\n    }\n    if (yaw !== undefined && Math.abs(yaw - config.yaw) > eps) {\n        this.setYaw(yaw, animated, callback, callbackArgs);\n        callback = undefined;\n    }\n    if (hfov !== undefined && Math.abs(hfov - config.hfov) > eps) {\n        this.setHfov(hfov, animated, callback, callbackArgs);\n        callback = undefined;\n    }\n    if (typeof callback == 'function')\n        callback(callbackArgs);\n    return this;\n};\n\n/**\n * Returns the panorama's north offset.\n * @memberof Viewer\n * @instance\n * @returns {number} North offset in degrees\n */\nthis.getNorthOffset = function() {\n    return config.northOffset;\n};\n\n/**\n * Sets the panorama's north offset.\n * @memberof Viewer\n * @instance\n * @param {number} heading - North offset in degrees\n * @returns {Viewer} `this`\n */\nthis.setNorthOffset = function(heading) {\n    config.northOffset = Math.min(360, Math.max(0, heading));\n    animateInit();\n    return this;\n};\n\n/**\n * Returns the panorama's horizon roll.\n * @memberof Viewer\n * @instance\n * @returns {number} Horizon roll in degrees\n */\nthis.getHorizonRoll = function() {\n    return config.horizonRoll;\n};\n\n/**\n * Sets the panorama's horizon roll.\n * @memberof Viewer\n * @instance\n * @param {number} roll - Horizon roll in degrees [-90, 90]\n * @returns {Viewer} `this`\n */\nthis.setHorizonRoll = function(roll) {\n    config.horizonRoll = Math.min(90, Math.max(-90, roll));\n    renderer.setPose(config.horizonPitch * Math.PI / 180, config.horizonRoll * Math.PI / 180);\n    animateInit();\n    return this;\n};\n\n/**\n * Returns the panorama's horizon pitch.\n * @memberof Viewer\n * @instance\n * @returns {number} Horizon pitch in degrees\n */\nthis.getHorizonPitch = function() {\n    return config.horizonPitch;\n};\n\n/**\n * Sets the panorama's horizon pitch.\n * @memberof Viewer\n * @instance\n * @param {number} pitch - Horizon pitch in degrees [-90, 90]\n * @returns {Viewer} `this`\n */\nthis.setHorizonPitch = function(pitch) {\n    config.horizonPitch = Math.min(90, Math.max(-90, pitch));\n    renderer.setPose(config.horizonPitch * Math.PI / 180, config.horizonRoll * Math.PI / 180);\n    animateInit();\n    return this;\n};\n\n/**\n * Start auto rotation.\n *\n * Before starting rotation, the viewer is panned to `pitch`.\n * @memberof Viewer\n * @instance\n * @param {number} [speed] - Auto rotation speed / direction. If not specified, previous value is used.\n * @param {number} [pitch] - The pitch to rotate at. If not specified, inital pitch is used.\n * @returns {Viewer} `this`\n */\nthis.startAutoRotate = function(speed, pitch) {\n    speed = speed || autoRotateSpeed || 1;\n    pitch = pitch === undefined ? origPitch : pitch;\n    config.autoRotate = speed;\n    _this.lookAt(pitch, undefined, origHfov, 3000);\n    animateInit();\n    return this;\n};\n\n/**\n * Stop auto rotation.\n * @memberof Viewer\n * @instance\n * @returns {Viewer} `this`\n */\nthis.stopAutoRotate = function() {\n    autoRotateSpeed = config.autoRotate ? config.autoRotate : autoRotateSpeed;\n    config.autoRotate = false;\n    config.autoRotateInactivityDelay = -1;\n    return this;\n};\n\n/**\n * Stops all movement.\n * @memberof Viewer\n * @instance\n */\nthis.stopMovement = function() {\n    stopAnimation();\n    speed = {'yaw': 0, 'pitch': 0, 'hfov': 0};\n};\n\n/**\n * Returns the panorama renderer.\n * @memberof Viewer\n * @instance\n * @returns {Renderer}\n */\nthis.getRenderer = function() {\n    return renderer;\n};\n\n/**\n * Sets update flag for dynamic content.\n * @memberof Viewer\n * @instance\n * @param {boolean} bool - Whether or not viewer should update even when still\n * @returns {Viewer} `this`\n */\nthis.setUpdate = function(bool) {\n    update = bool === true;\n    if (renderer === undefined)\n        onImageLoad();\n    else\n        animateInit();\n    return this;\n};\n\n/**\n * Calculate panorama pitch and yaw from location of mouse event.\n * @memberof Viewer\n * @instance\n * @param {MouseEvent} event - Document mouse down event.\n * @returns {number[]} [pitch, yaw]\n */\nthis.mouseEventToCoords = function(event) {\n    return mouseEventToCoords(event);\n};\n\n/**\n * Change scene being viewed.\n * @memberof Viewer\n * @instance\n * @param {string} sceneId - Identifier of scene to switch to.\n * @param {number} [pitch] - Pitch to use with new scene\n * @param {number} [yaw] - Yaw to use with new scene\n * @param {number} [hfov] - HFOV to use with new scene\n * @returns {Viewer} `this`\n */\nthis.loadScene = function(sceneId, pitch, yaw, hfov) {\n    if (loaded !== false)\n        loadScene(sceneId, pitch, yaw, hfov);\n    return this;\n};\n\n/**\n * Get ID of current scene.\n * @memberof Viewer\n * @instance\n * @returns {string} ID of current scene\n */\nthis.getScene = function() {\n    return config.scene;\n};\n\n/**\n * Add a new scene.\n * @memberof Viewer\n * @instance\n * @param {string} sceneId - The ID of the new scene\n * @param {string} config - The configuration of the new scene\n * @returns {Viewer} `this`\n */\nthis.addScene = function(sceneId, config) {\n    initialConfig.scenes[sceneId] = config;\n    return this;\n};\n\n/**\n * Remove a scene.\n * @memberof Viewer\n * @instance\n * @param {string} sceneId - The ID of the scene\n * @returns {boolean} False if the scene is the current scene or if the scene doesn't exists, else true\n */\nthis.removeScene = function(sceneId) {\n    if (config.scene === sceneId || !initialConfig.scenes.hasOwnProperty(sceneId))\n        return false;\n    delete initialConfig.scenes[sceneId];\n    return true;\n};\n\n/**\n * Toggle fullscreen.\n * @memberof Viewer\n * @instance\n * @returns {Viewer} `this`\n */\nthis.toggleFullscreen = function() {\n    toggleFullscreen();\n    return this;\n};\n\n/**\n * Get configuration of current scene.\n * @memberof Viewer\n * @instance\n * @returns {Object} Configuration of current scene\n */\nthis.getConfig = function() {\n    return config;\n};\n\n/**\n * Get viewer's container element.\n * @memberof Viewer\n * @instance\n * @returns {HTMLElement} Container `div` element\n */\nthis.getContainer = function() {\n    return container;\n};\n\n/**\n * Add a new hot spot.\n * @memberof Viewer\n * @instance\n * @param {Object} hs - The configuration for the hot spot\n * @param {string} [sceneId] - Adds hot spot to specified scene if provided, else to current scene\n * @returns {Viewer} `this`\n * @throws Throws an error if the scene ID is provided but invalid\n */\nthis.addHotSpot = function(hs, sceneId) {\n    if (sceneId === undefined && config.scene === undefined) {\n        // Not a tour\n        config.hotSpots.push(hs);\n    } else {\n        // Tour\n        var id = sceneId !== undefined ? sceneId : config.scene;\n        if (initialConfig.scenes.hasOwnProperty(id)) {\n            if (!initialConfig.scenes[id].hasOwnProperty('hotSpots')) {\n                initialConfig.scenes[id].hotSpots = []; // Create hot spots array if needed\n                if (id == config.scene)\n                    config.hotSpots = initialConfig.scenes[id].hotSpots;    // Link to current config\n            }\n            initialConfig.scenes[id].hotSpots.push(hs); // Add hot spot to config\n        } else {\n            throw 'Invalid scene ID!';\n        }\n    }\n    if (sceneId === undefined || config.scene == sceneId) {\n        // Add to current scene\n        createHotSpot(hs);\n        if (loaded)\n            renderHotSpot(hs);\n    }\n    return this;\n};\n\n/**\n * Remove a hot spot.\n * @memberof Viewer\n * @instance\n * @param {string} hotSpotId - The ID of the hot spot\n * @param {string} [sceneId] - Removes hot spot from specified scene if provided, else from current scene\n * @returns {boolean} True if deletion is successful, else false\n */\nthis.removeHotSpot = function(hotSpotId, sceneId) {\n    if (sceneId === undefined || config.scene == sceneId) {\n        if (!config.hotSpots)\n            return false;\n        for (var i = 0; i < config.hotSpots.length; i++) {\n            if (config.hotSpots[i].hasOwnProperty('id') &&\n                config.hotSpots[i].id === hotSpotId) {\n                // Delete hot spot DOM elements\n                var current = config.hotSpots[i].div;\n                while (current.parentNode != renderContainer)\n                    current = current.parentNode;\n                renderContainer.removeChild(current);\n                delete config.hotSpots[i].div;\n                // Remove hot spot from configuration\n                config.hotSpots.splice(i, 1);\n                return true;\n            }\n        }\n    } else {\n        if (initialConfig.scenes.hasOwnProperty(sceneId)) {\n            if (!initialConfig.scenes[sceneId].hasOwnProperty('hotSpots'))\n                return false;\n            for (var j = 0; j < initialConfig.scenes[sceneId].hotSpots.length; j++) {\n                if (initialConfig.scenes[sceneId].hotSpots[j].hasOwnProperty('id') &&\n                    initialConfig.scenes[sceneId].hotSpots[j].id === hotSpotId) {\n                    // Remove hot spot from configuration\n                    initialConfig.scenes[sceneId].hotSpots.splice(j, 1);\n                    return true;\n                }\n            }\n        } else {\n            return false;\n        }\n    }\n};\n\n/**\n * This method should be called if the viewer's container is resized.\n * @memberof Viewer\n * @instance\n */\nthis.resize = function() {\n    if (renderer)\n        onDocumentResize();\n};\n\n/**\n * Check if a panorama is loaded.\n * @memberof Viewer\n * @instance\n * @returns {boolean} True if a panorama is loaded, else false\n */\nthis.isLoaded = function() {\n    return loaded;\n};\n\n/**\n * Check if device orientation control is supported.\n * @memberof Viewer\n * @instance\n * @returns {boolean} True if supported, else false\n */\nthis.isOrientationSupported = function() {\n    return orientationSupport || false;\n};\n\n/**\n * Stop using device orientation.\n * @memberof Viewer\n * @instance\n */\nthis.stopOrientation = function() {\n    stopOrientation();\n};\n\n/**\n * Start using device orientation (does nothing if not supported).\n * @memberof Viewer\n * @instance\n */\nthis.startOrientation = function() {\n    if (orientationSupport)\n        startOrientation();\n};\n\n/**\n * Check if device orientation control is currently activated.\n * @memberof Viewer\n * @instance\n * @returns {boolean} True if active, else false\n */\nthis.isOrientationActive = function() {\n    return Boolean(orientation);\n};\n\n/**\n * Subscribe listener to specified event.\n * @memberof Viewer\n * @instance\n * @param {string} type - Type of event to subscribe to.\n * @param {Function} listener - Listener function to subscribe to event.\n * @returns {Viewer} `this`\n */\nthis.on = function(type, listener) {\n    externalEventListeners[type] = externalEventListeners[type] || [];\n    externalEventListeners[type].push(listener);\n    return this;\n};\n\n/**\n * Remove an event listener (or listeners).\n * @memberof Viewer\n * @param {string} [type] - Type of event to remove listeners from. If not specified, all listeners are removed.\n * @param {Function} [listener] - Listener function to remove. If not specified, all listeners of specified type are removed.\n * @returns {Viewer} `this`\n */\nthis.off = function(type, listener) {\n    if (!type) {\n        // Remove all listeners if type isn't specified\n        externalEventListeners = {};\n        return this;\n    }\n    if (listener) {\n        var i = externalEventListeners[type].indexOf(listener);\n        if (i >= 0) {\n            // Remove listener if found\n            externalEventListeners[type].splice(i, 1);\n        }\n        if (externalEventListeners[type].length == 0) {\n            // Remove category if empty\n            delete externalEventListeners[type];\n        }\n    } else {\n        // Remove category of listeners if listener isn't specified\n        delete externalEventListeners[type];\n    }\n    return this;\n};\n\n/**\n * Fire listeners attached to specified event.\n * @private\n * @param {string} [type] - Type of event to fire listeners for.\n */\nfunction fireEvent(type) {\n    if (type in externalEventListeners) {\n        // Reverse iteration is useful, if event listener is removed inside its definition\n        for (var i = externalEventListeners[type].length; i > 0; i--) {\n            externalEventListeners[type][externalEventListeners[type].length - i].apply(null, [].slice.call(arguments, 1));\n        }\n    }\n}\n\n/**\n * Destructor.\n * @instance\n * @memberof Viewer\n */\nthis.destroy = function() {\n    destroyed = true;\n    clearTimeout(autoRotateStart);\n\n    if (renderer)\n        renderer.destroy();\n    if (listenersAdded) {\n        document.removeEventListener('mousemove', onDocumentMouseMove, false);\n        document.removeEventListener('mouseup', onDocumentMouseUp, false);\n        container.removeEventListener('mozfullscreenchange', onFullScreenChange, false);\n        container.removeEventListener('webkitfullscreenchange', onFullScreenChange, false);\n        container.removeEventListener('msfullscreenchange', onFullScreenChange, false);\n        container.removeEventListener('fullscreenchange', onFullScreenChange, false);\n        window.removeEventListener('resize', onDocumentResize, false);\n        window.removeEventListener('orientationchange', onDocumentResize, false);\n        container.removeEventListener('keydown', onDocumentKeyPress, false);\n        container.removeEventListener('keyup', onDocumentKeyUp, false);\n        container.removeEventListener('blur', clearKeys, false);\n        document.removeEventListener('mouseleave', onDocumentMouseUp, false);\n    }\n    container.innerHTML = '';\n    container.classList.remove('pnlm-container');\n};\n\n}\n\nreturn {\n    viewer: function(container, config) {\n        return new Viewer(container, config);\n    }\n};\n\n})(window, document);\n"], "fixing_code": ["/*\n * Pannellum - An HTML5 based Panorama Viewer\n * Copyright (c) 2011-2019 Matthew Petroff\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\nwindow.pannellum = (function(window, document, undefined) {\n\n'use strict';\n\n/**\n * Creates a new panorama viewer.\n * @constructor\n * @param {HTMLElement|string} container - The container (div) element for the\n *      viewer, or its ID.\n * @param {Object} initialConfig - Inital configuration for viewer.\n */\nfunction Viewer(container, initialConfig) {\n\nvar _this = this;\n\n// Declare variables\nvar config,\n    renderer,\n    preview,\n    isUserInteracting = false,\n    latestInteraction = Date.now(),\n    onPointerDownPointerX = 0,\n    onPointerDownPointerY = 0,\n    onPointerDownPointerDist = -1,\n    onPointerDownYaw = 0,\n    onPointerDownPitch = 0,\n    keysDown = new Array(10),\n    fullscreenActive = false,\n    loaded,\n    error = false,\n    isTimedOut = false,\n    listenersAdded = false,\n    panoImage,\n    prevTime,\n    speed = {'yaw': 0, 'pitch': 0, 'hfov': 0},\n    animating = false,\n    orientation = false,\n    orientationYawOffset = 0,\n    autoRotateStart,\n    autoRotateSpeed = 0,\n    origHfov,\n    origPitch,\n    animatedMove = {},\n    externalEventListeners = {},\n    specifiedPhotoSphereExcludes = [],\n    update = false, // Should we update when still to render dynamic content\n    eps = 1e-6,\n    hotspotsCreated = false,\n    destroyed = false;\n\nvar defaultConfig = {\n    hfov: 100,\n    minHfov: 50,\n    multiResMinHfov: false,\n    maxHfov: 120,\n    pitch: 0,\n    minPitch: undefined,\n    maxPitch: undefined,\n    yaw: 0,\n    minYaw: -180,\n    maxYaw: 180,\n    roll: 0,\n    haov: 360,\n    vaov: 180,\n    vOffset: 0,\n    autoRotate: false,\n    autoRotateInactivityDelay: -1,\n    autoRotateStopDelay: undefined,\n    type: 'equirectangular',\n    northOffset: 0,\n    showFullscreenCtrl: true,\n    dynamic: false,\n    dynamicUpdate: false,\n    doubleClickZoom: true,\n    keyboardZoom: true,\n    mouseZoom: true,\n    showZoomCtrl: true,\n    autoLoad: false,\n    showControls: true,\n    orientationOnByDefault: false,\n    hotSpotDebug: false,\n    backgroundColor: [0, 0, 0],\n    avoidShowingBackground: false,\n    animationTimingFunction: timingFunction,\n    draggable: true,\n    disableKeyboardCtrl: false,\n    crossOrigin: 'anonymous',\n    touchPanSpeedCoeffFactor: 1,\n    capturedKeyNumbers: [16, 17, 27, 37, 38, 39, 40, 61, 65, 68, 83, 87, 107, 109, 173, 187, 189],\n    friction: 0.15\n};\n\n// Translatable / configurable strings\n// Some strings contain '%s', which is a placeholder for inserted values\n// When setting strings in external configuration, `\\n` should be used instead of `<br>` to insert line breaks\ndefaultConfig.strings = {\n    // Labels\n    loadButtonLabel: 'Click to<br>Load<br>Panorama',\n    loadingLabel: 'Loading...',\n    bylineLabel: 'by %s',    // One substitution: author\n\n    // Errors\n    noPanoramaError: 'No panorama image was specified.',\n    fileAccessError: 'The file %s could not be accessed.',  // One substitution: file URL\n    malformedURLError: 'There is something wrong with the panorama URL.',\n    iOS8WebGLError: \"Due to iOS 8's broken WebGL implementation, only \" +\n                    \"progressive encoded JPEGs work for your device (this \" +\n                    \"panorama uses standard encoding).\",\n    genericWebGLError: 'Your browser does not have the necessary WebGL support to display this panorama.',\n    textureSizeError: 'This panorama is too big for your device! It\\'s ' +\n                '%spx wide, but your device only supports images up to ' +\n                '%spx wide. Try another device.' +\n                ' (If you\\'re the author, try scaling down the image.)',    // Two substitutions: image width, max image width\n    unknownError: 'Unknown error. Check developer console.',\n};\n\n// Initialize container\ncontainer = typeof container === 'string' ? document.getElementById(container) : container;\ncontainer.classList.add('pnlm-container');\ncontainer.tabIndex = 0;\n\n// Create container for ui\nvar uiContainer = document.createElement('div');\nuiContainer.className = 'pnlm-ui';\ncontainer.appendChild(uiContainer);\n\n// Create container for renderer\nvar renderContainer = document.createElement('div');\nrenderContainer.className = 'pnlm-render-container';\ncontainer.appendChild(renderContainer);\nvar dragFix = document.createElement('div');\ndragFix.className = 'pnlm-dragfix';\nuiContainer.appendChild(dragFix);\n\n// Display about information on right click\nvar aboutMsg = document.createElement('span');\naboutMsg.className = 'pnlm-about-msg';\naboutMsg.innerHTML = '<a href=\"https://pannellum.org/\" target=\"_blank\">Pannellum</a>';\nuiContainer.appendChild(aboutMsg);\ndragFix.addEventListener('contextmenu', aboutMessage);\n\n// Create info display\nvar infoDisplay = {};\n\n// Hot spot debug indicator\nvar hotSpotDebugIndicator = document.createElement('div');\nhotSpotDebugIndicator.className = 'pnlm-sprite pnlm-hot-spot-debug-indicator';\nuiContainer.appendChild(hotSpotDebugIndicator);\n\n// Panorama info\ninfoDisplay.container = document.createElement('div');\ninfoDisplay.container.className = 'pnlm-panorama-info';\ninfoDisplay.title = document.createElement('div');\ninfoDisplay.title.className = 'pnlm-title-box';\ninfoDisplay.container.appendChild(infoDisplay.title);\ninfoDisplay.author = document.createElement('div');\ninfoDisplay.author.className = 'pnlm-author-box';\ninfoDisplay.container.appendChild(infoDisplay.author);\nuiContainer.appendChild(infoDisplay.container);\n\n// Load box\ninfoDisplay.load = {};\ninfoDisplay.load.box = document.createElement('div');\ninfoDisplay.load.box.className = 'pnlm-load-box';\ninfoDisplay.load.boxp = document.createElement('p');\ninfoDisplay.load.box.appendChild(infoDisplay.load.boxp);\ninfoDisplay.load.lbox = document.createElement('div');\ninfoDisplay.load.lbox.className = 'pnlm-lbox';\ninfoDisplay.load.lbox.innerHTML = '<div class=\"pnlm-loading\"></div>';\ninfoDisplay.load.box.appendChild(infoDisplay.load.lbox);\ninfoDisplay.load.lbar = document.createElement('div');\ninfoDisplay.load.lbar.className = 'pnlm-lbar';\ninfoDisplay.load.lbarFill = document.createElement('div');\ninfoDisplay.load.lbarFill.className = 'pnlm-lbar-fill';\ninfoDisplay.load.lbar.appendChild(infoDisplay.load.lbarFill);\ninfoDisplay.load.box.appendChild(infoDisplay.load.lbar);\ninfoDisplay.load.msg = document.createElement('p');\ninfoDisplay.load.msg.className = 'pnlm-lmsg';\ninfoDisplay.load.box.appendChild(infoDisplay.load.msg);\nuiContainer.appendChild(infoDisplay.load.box);\n\n// Error message\ninfoDisplay.errorMsg = document.createElement('div');\ninfoDisplay.errorMsg.className = 'pnlm-error-msg pnlm-info-box';\nuiContainer.appendChild(infoDisplay.errorMsg);\n\n// Create controls\nvar controls = {};\ncontrols.container = document.createElement('div');\ncontrols.container.className = 'pnlm-controls-container';\nuiContainer.appendChild(controls.container);\n\n// Load button\ncontrols.load = document.createElement('div');\ncontrols.load.className = 'pnlm-load-button';\ncontrols.load.addEventListener('click', function() {\n    processOptions();\n    load();\n});\nuiContainer.appendChild(controls.load);\n\n// Zoom controls\ncontrols.zoom = document.createElement('div');\ncontrols.zoom.className = 'pnlm-zoom-controls pnlm-controls';\ncontrols.zoomIn = document.createElement('div');\ncontrols.zoomIn.className = 'pnlm-zoom-in pnlm-sprite pnlm-control';\ncontrols.zoomIn.addEventListener('click', zoomIn);\ncontrols.zoom.appendChild(controls.zoomIn);\ncontrols.zoomOut = document.createElement('div');\ncontrols.zoomOut.className = 'pnlm-zoom-out pnlm-sprite pnlm-control';\ncontrols.zoomOut.addEventListener('click', zoomOut);\ncontrols.zoom.appendChild(controls.zoomOut);\ncontrols.container.appendChild(controls.zoom);\n\n// Fullscreen toggle\ncontrols.fullscreen = document.createElement('div');\ncontrols.fullscreen.addEventListener('click', toggleFullscreen);\ncontrols.fullscreen.className = 'pnlm-fullscreen-toggle-button pnlm-sprite pnlm-fullscreen-toggle-button-inactive pnlm-controls pnlm-control';\nif (document.fullscreenEnabled || document.mozFullScreenEnabled || document.webkitFullscreenEnabled || document.msFullscreenEnabled)\n    controls.container.appendChild(controls.fullscreen);\n\n// Device orientation toggle\ncontrols.orientation = document.createElement('div');\ncontrols.orientation.addEventListener('click', function(e) {\n    if (orientation)\n        stopOrientation();\n    else\n        startOrientation();\n});\ncontrols.orientation.addEventListener('mousedown', function(e) {e.stopPropagation();});\ncontrols.orientation.addEventListener('touchstart', function(e) {e.stopPropagation();});\ncontrols.orientation.addEventListener('pointerdown', function(e) {e.stopPropagation();});\ncontrols.orientation.className = 'pnlm-orientation-button pnlm-orientation-button-inactive pnlm-sprite pnlm-controls pnlm-control';\nvar orientationSupport = false;\nif (window.DeviceOrientationEvent && location.protocol == 'https:' &&\n    navigator.userAgent.toLowerCase().indexOf('mobi') >= 0) {\n    // This user agent check is here because there's no way to check if a\n    // device has an inertia measurement unit. We used to be able to check if a\n    // DeviceOrientationEvent had non-null values, but with iOS 13 requiring a\n    // permission prompt to access such events, this is no longer possible.\n    controls.container.appendChild(controls.orientation);\n    orientationSupport = true;\n}\n\n// Compass\nvar compass = document.createElement('div');\ncompass.className = 'pnlm-compass pnlm-controls pnlm-control';\nuiContainer.appendChild(compass);\n\n// Load and process configuration\nif (initialConfig.firstScene) {\n    // Activate first scene if specified in URL\n    mergeConfig(initialConfig.firstScene);\n} else if (initialConfig.default && initialConfig.default.firstScene) {\n    // Activate first scene if specified in file\n    mergeConfig(initialConfig.default.firstScene);\n} else {\n    mergeConfig(null);\n}\nprocessOptions(true);\n\n/**\n * Initializes viewer.\n * @private\n */\nfunction init() {\n    // Display an error for IE 9 as it doesn't work but also doesn't otherwise\n    // show an error (older versions don't work at all)\n    // Based on: http://stackoverflow.com/a/10965203\n    var div = document.createElement(\"div\");\n    div.innerHTML = \"<!--[if lte IE 9]><i></i><![endif]-->\";\n    if (div.getElementsByTagName(\"i\").length == 1) {\n        anError();\n        return;\n    }\n\n    origHfov = config.hfov;\n    origPitch = config.pitch;\n\n    var i, p;\n    \n    if (config.type == 'cubemap') {\n        panoImage = [];\n        for (i = 0; i < 6; i++) {\n            panoImage.push(new Image());\n            panoImage[i].crossOrigin = config.crossOrigin;\n        }\n        infoDisplay.load.lbox.style.display = 'block';\n        infoDisplay.load.lbar.style.display = 'none';\n    } else if (config.type == 'multires') {\n        var c = JSON.parse(JSON.stringify(config.multiRes));    // Deep copy\n        // Avoid \"undefined\" in path, check (optional) multiRes.basePath, too\n        // Use only multiRes.basePath if it's an absolute URL\n        if (config.basePath && config.multiRes.basePath &&\n            !(/^(?:[a-z]+:)?\\/\\//i.test(config.multiRes.basePath))) {\n            c.basePath = config.basePath + config.multiRes.basePath;\n        } else if (config.multiRes.basePath) {\n            c.basePath = config.multiRes.basePath;\n        } else if(config.basePath) {\n            c.basePath = config.basePath;\n        }\n        panoImage = c;\n    } else {\n        if (config.dynamic === true) {\n            panoImage = config.panorama;\n        } else {\n            if (config.panorama === undefined) {\n                anError(config.strings.noPanoramaError);\n                return;\n            }\n            panoImage = new Image();\n        }\n    }\n\n    // Configure image loading\n    if (config.type == 'cubemap') {\n        // Quick loading counter for synchronous loading\n        var itemsToLoad = 6;\n        \n        var onLoad = function() {\n            itemsToLoad--;\n            if (itemsToLoad === 0) {\n                onImageLoad();\n            }\n        };\n        \n        var onError = function(e) {\n            var a = document.createElement('a');\n            a.href = e.target.src;\n            a.textContent = a.href;\n            anError(config.strings.fileAccessError.replace('%s', a.outerHTML));\n        };\n        \n        for (i = 0; i < panoImage.length; i++) {\n            p = config.cubeMap[i];\n            if (p == \"null\") { // support partial cubemap image with explicitly empty faces\n                console.log('Will use background instead of missing cubemap face ' + i);\n                onLoad();\n            } else {\n                if (config.basePath && !absoluteURL(p)) {\n                    p = config.basePath + p;\n                }\n                panoImage[i].onload = onLoad;\n                panoImage[i].onerror = onError;\n                panoImage[i].src = sanitizeURL(p);\n            }\n        }\n    } else if (config.type == 'multires') {\n        onImageLoad();\n    } else {\n        p = '';\n        if (config.basePath) {\n            p = config.basePath;\n        }\n        \n        if (config.dynamic !== true) {\n            // Still image\n            p = absoluteURL(config.panorama) ? config.panorama : p + config.panorama;\n            \n            panoImage.onload = function() {\n                window.URL.revokeObjectURL(this.src);  // Clean up\n                onImageLoad();\n            };\n            \n            var xhr = new XMLHttpRequest();\n            xhr.onloadend = function() {\n                if (xhr.status != 200) {\n                    // Display error if image can't be loaded\n                    var a = document.createElement('a');\n                    a.href = p;\n                    a.textContent = a.href;\n                    anError(config.strings.fileAccessError.replace('%s', a.outerHTML));\n                }\n                var img = this.response;\n                parseGPanoXMP(img);\n                infoDisplay.load.msg.innerHTML = '';\n            };\n            xhr.onprogress = function(e) {\n                if (e.lengthComputable) {\n                    // Display progress\n                    var percent = e.loaded / e.total * 100;\n                    infoDisplay.load.lbarFill.style.width = percent + '%';\n                    var unit, numerator, denominator;\n                    if (e.total > 1e6) {\n                        unit = 'MB';\n                        numerator = (e.loaded / 1e6).toFixed(2);\n                        denominator = (e.total / 1e6).toFixed(2);\n                    } else if (e.total > 1e3) {\n                        unit = 'kB';\n                        numerator = (e.loaded / 1e3).toFixed(1);\n                        denominator = (e.total / 1e3).toFixed(1);\n                    } else {\n                        unit = 'B';\n                        numerator = e.loaded;\n                        denominator = e.total;\n                    }\n                    infoDisplay.load.msg.innerHTML = numerator + ' / ' + denominator + ' ' + unit;\n                } else {\n                    // Display loading spinner\n                    infoDisplay.load.lbox.style.display = 'block';\n                    infoDisplay.load.lbar.style.display = 'none';\n                }\n            };\n            try {\n                xhr.open('GET', p, true);\n            } catch (e) {\n                // Malformed URL\n                anError(config.strings.malformedURLError);\n            }\n            xhr.responseType = 'blob';\n            xhr.setRequestHeader('Accept', 'image/*,*/*;q=0.9');\n            xhr.withCredentials = config.crossOrigin === 'use-credentials';\n            xhr.send();\n        }\n    }\n    \n    if (config.draggable)\n        uiContainer.classList.add('pnlm-grab');\n    uiContainer.classList.remove('pnlm-grabbing');\n\n    // Properly handle switching to dynamic scenes\n    update = config.dynamicUpdate === true;\n    if (config.dynamic && update) {\n        panoImage = config.panorama;\n        onImageLoad();\n    }\n}\n\n/**\n * Test if URL is absolute or relative.\n * @private\n * @param {string} url - URL to test\n * @returns {boolean} True if absolute, else false\n */\nfunction absoluteURL(url) {\n    // From http://stackoverflow.com/a/19709846\n    return new RegExp('^(?:[a-z]+:)?//', 'i').test(url) || url[0] == '/' || url.slice(0, 5) == 'blob:';\n}\n\n/**\n * Create renderer and initialize event listeners once image is loaded.\n * @private\n */\nfunction onImageLoad() {\n    if (!renderer)\n        renderer = new libpannellum.renderer(renderContainer);\n\n    // Only add event listeners once\n    if (!listenersAdded) {\n        listenersAdded = true;\n        dragFix.addEventListener('mousedown', onDocumentMouseDown, false);\n        document.addEventListener('mousemove', onDocumentMouseMove, false);\n        document.addEventListener('mouseup', onDocumentMouseUp, false);\n        if (config.mouseZoom) {\n            uiContainer.addEventListener('mousewheel', onDocumentMouseWheel, false);\n            uiContainer.addEventListener('DOMMouseScroll', onDocumentMouseWheel, false);\n        }\n        if (config.doubleClickZoom) {\n            dragFix.addEventListener('dblclick', onDocumentDoubleClick, false);\n        }\n        container.addEventListener('mozfullscreenchange', onFullScreenChange, false);\n        container.addEventListener('webkitfullscreenchange', onFullScreenChange, false);\n        container.addEventListener('msfullscreenchange', onFullScreenChange, false);\n        container.addEventListener('fullscreenchange', onFullScreenChange, false);\n        window.addEventListener('resize', onDocumentResize, false);\n        window.addEventListener('orientationchange', onDocumentResize, false);\n        if (!config.disableKeyboardCtrl) {\n            container.addEventListener('keydown', onDocumentKeyPress, false);\n            container.addEventListener('keyup', onDocumentKeyUp, false);\n            container.addEventListener('blur', clearKeys, false);\n        }\n        document.addEventListener('mouseleave', onDocumentMouseUp, false);\n        if (document.documentElement.style.pointerAction === '' &&\n            document.documentElement.style.touchAction === '') {\n            dragFix.addEventListener('pointerdown', onDocumentPointerDown, false);\n            dragFix.addEventListener('pointermove', onDocumentPointerMove, false);\n            dragFix.addEventListener('pointerup', onDocumentPointerUp, false);\n            dragFix.addEventListener('pointerleave', onDocumentPointerUp, false);\n        } else {\n            dragFix.addEventListener('touchstart', onDocumentTouchStart, false);\n            dragFix.addEventListener('touchmove', onDocumentTouchMove, false);\n            dragFix.addEventListener('touchend', onDocumentTouchEnd, false);\n        }\n\n        // Deal with MS pointer events\n        if (window.navigator.pointerEnabled)\n            container.style.touchAction = 'none';\n    }\n\n    renderInit();\n    setHfov(config.hfov); // possibly adapt hfov after configuration and canvas is complete; prevents empty space on top or bottom by zomming out too much\n    setTimeout(function(){isTimedOut = true;}, 500);\n}\n\n/**\n * Parses Google Photo Sphere XMP Metadata.\n * https://developers.google.com/photo-sphere/metadata/\n * @private\n * @param {Image} image - Image to read XMP metadata from.\n */\nfunction parseGPanoXMP(image) {\n    var reader = new FileReader();\n    reader.addEventListener('loadend', function() {\n        var img = reader.result;\n\n        // This awful browser specific test exists because iOS 8 does not work\n        // with non-progressive encoded JPEGs.\n        if (navigator.userAgent.toLowerCase().match(/(iphone|ipod|ipad).* os 8_/)) {\n            var flagIndex = img.indexOf('\\xff\\xc2');\n            if (flagIndex < 0 || flagIndex > 65536)\n                anError(config.strings.iOS8WebGLError);\n        }\n\n        var start = img.indexOf('<x:xmpmeta');\n        if (start > -1 && config.ignoreGPanoXMP !== true) {\n            var xmpData = img.substring(start, img.indexOf('</x:xmpmeta>') + 12);\n            \n            // Extract the requested tag from the XMP data\n            var getTag = function(tag) {\n                var result;\n                if (xmpData.indexOf(tag + '=\"') >= 0) {\n                    result = xmpData.substring(xmpData.indexOf(tag + '=\"') + tag.length + 2);\n                    result = result.substring(0, result.indexOf('\"'));\n                } else if (xmpData.indexOf(tag + '>') >= 0) {\n                    result = xmpData.substring(xmpData.indexOf(tag + '>') + tag.length + 1);\n                    result = result.substring(0, result.indexOf('<'));\n                }\n                if (result !== undefined) {\n                    return Number(result);\n                }\n                return null;\n            };\n            \n            // Relevant XMP data\n            var xmp = {\n                fullWidth: getTag('GPano:FullPanoWidthPixels'),\n                croppedWidth: getTag('GPano:CroppedAreaImageWidthPixels'),\n                fullHeight: getTag('GPano:FullPanoHeightPixels'),\n                croppedHeight: getTag('GPano:CroppedAreaImageHeightPixels'),\n                topPixels: getTag('GPano:CroppedAreaTopPixels'),\n                heading: getTag('GPano:PoseHeadingDegrees'),\n                horizonPitch: getTag('GPano:PosePitchDegrees'),\n                horizonRoll: getTag('GPano:PoseRollDegrees')\n            };\n            \n            if (xmp.fullWidth !== null && xmp.croppedWidth !== null &&\n                xmp.fullHeight !== null && xmp.croppedHeight !== null &&\n                xmp.topPixels !== null) {\n                \n                // Set up viewer using GPano XMP data\n                if (specifiedPhotoSphereExcludes.indexOf('haov') < 0)\n                    config.haov = xmp.croppedWidth / xmp.fullWidth * 360;\n                if (specifiedPhotoSphereExcludes.indexOf('vaov') < 0)\n                    config.vaov = xmp.croppedHeight / xmp.fullHeight * 180;\n                if (specifiedPhotoSphereExcludes.indexOf('vOffset') < 0)\n                    config.vOffset = ((xmp.topPixels + xmp.croppedHeight / 2) / xmp.fullHeight - 0.5) * -180;\n                if (xmp.heading !== null && specifiedPhotoSphereExcludes.indexOf('northOffset') < 0) {\n                    // TODO: make sure this works correctly for partial panoramas\n                    config.northOffset = xmp.heading;\n                    if (config.compass !== false) {\n                        config.compass = true;\n                    }\n                }\n                if (xmp.horizonPitch !== null && xmp.horizonRoll !== null) {\n                    if (specifiedPhotoSphereExcludes.indexOf('horizonPitch') < 0)\n                        config.horizonPitch = xmp.horizonPitch;\n                    if (specifiedPhotoSphereExcludes.indexOf('horizonRoll') < 0)\n                        config.horizonRoll = xmp.horizonRoll;\n                }\n                \n                // TODO: add support for initial view settings\n            }\n        }\n        \n        // Load panorama\n        panoImage.src = window.URL.createObjectURL(image);\n    });\n    if (reader.readAsBinaryString !== undefined)\n        reader.readAsBinaryString(image);\n    else\n        reader.readAsText(image);\n}\n\n/**\n * Displays an error message.\n * @private\n * @param {string} errorMsg - Error message to display. If not specified, a\n *      generic WebGL error is displayed.\n */\nfunction anError(errorMsg) {\n    if (errorMsg === undefined)\n        errorMsg = config.strings.genericWebGLError;\n    infoDisplay.errorMsg.innerHTML = '<p>' + errorMsg + '</p>';\n    controls.load.style.display = 'none';\n    infoDisplay.load.box.style.display = 'none';\n    infoDisplay.errorMsg.style.display = 'table';\n    error = true;\n    loaded = undefined;\n    renderContainer.style.display = 'none';\n    fireEvent('error', errorMsg);\n}\n\n/**\n * Hides error message display.\n * @private\n */\nfunction clearError() {\n    if (error) {\n        infoDisplay.load.box.style.display = 'none';\n        infoDisplay.errorMsg.style.display = 'none';\n        error = false;\n        renderContainer.style.display = 'block';\n        fireEvent('errorcleared');\n    }\n}\n\n/**\n * Displays about message.\n * @private\n * @param {MouseEvent} event - Right click location\n */\nfunction aboutMessage(event) {\n    var pos = mousePosition(event);\n    aboutMsg.style.left = pos.x + 'px';\n    aboutMsg.style.top = pos.y + 'px';\n    clearTimeout(aboutMessage.t1);\n    clearTimeout(aboutMessage.t2);\n    aboutMsg.style.display = 'block';\n    aboutMsg.style.opacity = 1;\n    aboutMessage.t1 = setTimeout(function() {aboutMsg.style.opacity = 0;}, 2000);\n    aboutMessage.t2 = setTimeout(function() {aboutMsg.style.display = 'none';}, 2500);\n    event.preventDefault();\n}\n\n/**\n * Calculate mouse position relative to top left of viewer container.\n * @private\n * @param {MouseEvent} event - Mouse event to use in calculation\n * @returns {Object} Calculated X and Y coordinates\n */\nfunction mousePosition(event) {\n    var bounds = container.getBoundingClientRect();\n    var pos = {};\n    // pageX / pageY needed for iOS\n    pos.x = (event.clientX || event.pageX) - bounds.left;\n    pos.y = (event.clientY || event.pageY) - bounds.top;\n    return pos;\n}\n\n/**\n * Event handler for mouse clicks. Initializes panning. Prints center and click\n * location coordinates when hot spot debugging is enabled.\n * @private\n * @param {MouseEvent} event - Document mouse down event.\n */\nfunction onDocumentMouseDown(event) {\n    // Override default action\n    event.preventDefault();\n    // But not all of it\n    container.focus();\n    \n    // Only do something if the panorama is loaded\n    if (!loaded || !config.draggable) {\n        return;\n    }\n    \n    // Calculate mouse position relative to top left of viewer container\n    var pos = mousePosition(event);\n\n    // Log pitch / yaw of mouse click when debugging / placing hot spots\n    if (config.hotSpotDebug) {\n        var coords = mouseEventToCoords(event);\n        console.log('Pitch: ' + coords[0] + ', Yaw: ' + coords[1] + ', Center Pitch: ' +\n            config.pitch + ', Center Yaw: ' + config.yaw + ', HFOV: ' + config.hfov);\n    }\n    \n    // Turn off auto-rotation if enabled\n    stopAnimation();\n\n    stopOrientation();\n    config.roll = 0;\n\n    speed.hfov = 0;\n\n    isUserInteracting = true;\n    latestInteraction = Date.now();\n    \n    onPointerDownPointerX = pos.x;\n    onPointerDownPointerY = pos.y;\n    \n    onPointerDownYaw = config.yaw;\n    onPointerDownPitch = config.pitch;\n    \n    uiContainer.classList.add('pnlm-grabbing');\n    uiContainer.classList.remove('pnlm-grab');\n    \n    fireEvent('mousedown', event);\n    animateInit();\n}\n\n/**\n * Event handler for double clicks. Zooms in at clicked location\n * @private\n * @param {MouseEvent} event - Document mouse down event.\n */\nfunction onDocumentDoubleClick(event) {\n    if (config.minHfov === config.hfov) {\n        _this.setHfov(origHfov, 1000);\n    } else {\n        var coords = mouseEventToCoords(event);\n        _this.lookAt(coords[0], coords[1], config.minHfov, 1000);\n    }\n}\n\n/**\n * Calculate panorama pitch and yaw from location of mouse event.\n * @private\n * @param {MouseEvent} event - Document mouse down event.\n * @returns {number[]} [pitch, yaw]\n */\nfunction mouseEventToCoords(event) {\n    var pos = mousePosition(event);\n    var canvas = renderer.getCanvas();\n    var canvasWidth = canvas.clientWidth,\n        canvasHeight = canvas.clientHeight;\n    var x = pos.x / canvasWidth * 2 - 1;\n    var y = (1 - pos.y / canvasHeight * 2) * canvasHeight / canvasWidth;\n    var focal = 1 / Math.tan(config.hfov * Math.PI / 360);\n    var s = Math.sin(config.pitch * Math.PI / 180);\n    var c = Math.cos(config.pitch * Math.PI / 180);\n    var a = focal * c - y * s;\n    var root = Math.sqrt(x*x + a*a);\n    var pitch = Math.atan((y * c + focal * s) / root) * 180 / Math.PI;\n    var yaw = Math.atan2(x / root, a / root) * 180 / Math.PI + config.yaw;\n    if (yaw < -180)\n        yaw += 360;\n    if (yaw > 180)\n        yaw -= 360;\n    return [pitch, yaw];\n}\n\n/**\n * Event handler for mouse moves. Pans center of view.\n * @private\n * @param {MouseEvent} event - Document mouse move event.\n */\nfunction onDocumentMouseMove(event) {\n    if (isUserInteracting && loaded) {\n        latestInteraction = Date.now();\n        var canvas = renderer.getCanvas();\n        var canvasWidth = canvas.clientWidth,\n            canvasHeight = canvas.clientHeight;\n        var pos = mousePosition(event);\n        //TODO: This still isn't quite right\n        var yaw = ((Math.atan(onPointerDownPointerX / canvasWidth * 2 - 1) - Math.atan(pos.x / canvasWidth * 2 - 1)) * 180 / Math.PI * config.hfov / 90) + onPointerDownYaw;\n        speed.yaw = (yaw - config.yaw) % 360 * 0.2;\n        config.yaw = yaw;\n        \n        var vfov = 2 * Math.atan(Math.tan(config.hfov/360*Math.PI) * canvasHeight / canvasWidth) * 180 / Math.PI;\n        \n        var pitch = ((Math.atan(pos.y / canvasHeight * 2 - 1) - Math.atan(onPointerDownPointerY / canvasHeight * 2 - 1)) * 180 / Math.PI * vfov / 90) + onPointerDownPitch;\n        speed.pitch = (pitch - config.pitch) * 0.2;\n        config.pitch = pitch;\n    }\n}\n\n/**\n * Event handler for mouse up events. Stops panning.\n * @private\n */\nfunction onDocumentMouseUp(event) {\n    if (!isUserInteracting) {\n        return;\n    }\n    isUserInteracting = false;\n    if (Date.now() - latestInteraction > 15) {\n        // Prevents jump when user rapidly moves mouse, stops, and then\n        // releases the mouse button\n        speed.pitch = speed.yaw = 0;\n    }\n    uiContainer.classList.add('pnlm-grab');\n    uiContainer.classList.remove('pnlm-grabbing');\n    latestInteraction = Date.now();\n\n    fireEvent('mouseup', event);\n}\n\n/**\n * Event handler for touches. Initializes panning if one touch or zooming if\n * two touches.\n * @private\n * @param {TouchEvent} event - Document touch start event.\n */\nfunction onDocumentTouchStart(event) {\n    // Only do something if the panorama is loaded\n    if (!loaded || !config.draggable) {\n        return;\n    }\n\n    // Turn off auto-rotation if enabled\n    stopAnimation();\n\n    stopOrientation();\n    config.roll = 0;\n\n    speed.hfov = 0;\n\n    // Calculate touch position relative to top left of viewer container\n    var pos0 = mousePosition(event.targetTouches[0]);\n\n    onPointerDownPointerX = pos0.x;\n    onPointerDownPointerY = pos0.y;\n    \n    if (event.targetTouches.length == 2) {\n        // Down pointer is the center of the two fingers\n        var pos1 = mousePosition(event.targetTouches[1]);\n        onPointerDownPointerX += (pos1.x - pos0.x) * 0.5;\n        onPointerDownPointerY += (pos1.y - pos0.y) * 0.5;\n        onPointerDownPointerDist = Math.sqrt((pos0.x - pos1.x) * (pos0.x - pos1.x) +\n                                             (pos0.y - pos1.y) * (pos0.y - pos1.y));\n    }\n    isUserInteracting = true;\n    latestInteraction = Date.now();\n    \n    onPointerDownYaw = config.yaw;\n    onPointerDownPitch = config.pitch;\n\n    fireEvent('touchstart', event);\n    animateInit();\n}\n\n/**\n * Event handler for touch movements. Pans center of view if one touch or\n * adjusts zoom if two touches.\n * @private\n * @param {TouchEvent} event - Document touch move event.\n */\nfunction onDocumentTouchMove(event) {\n    if (!config.draggable) {\n        return;\n    }\n\n    // Override default action\n    event.preventDefault();\n    if (loaded) {\n        latestInteraction = Date.now();\n    }\n    if (isUserInteracting && loaded) {\n        var pos0 = mousePosition(event.targetTouches[0]);\n        var clientX = pos0.x;\n        var clientY = pos0.y;\n        \n        if (event.targetTouches.length == 2 && onPointerDownPointerDist != -1) {\n            var pos1 = mousePosition(event.targetTouches[1]);\n            clientX += (pos1.x - pos0.x) * 0.5;\n            clientY += (pos1.y - pos0.y) * 0.5;\n            var clientDist = Math.sqrt((pos0.x - pos1.x) * (pos0.x - pos1.x) +\n                                       (pos0.y - pos1.y) * (pos0.y - pos1.y));\n            setHfov(config.hfov + (onPointerDownPointerDist - clientDist) * 0.1);\n            onPointerDownPointerDist = clientDist;\n        }\n\n        // The smaller the config.hfov value (the more zoomed-in the user is), the faster\n        // yaw/pitch are perceived to change on one-finger touchmove (panning) events and vice versa.\n        // To improve usability at both small and large zoom levels (config.hfov values)\n        // we introduce a dynamic pan speed coefficient.\n        //\n        // Currently this seems to *roughly* keep initial drag/pan start position close to\n        // the user's finger while panning regardless of zoom level / config.hfov value.\n        var touchmovePanSpeedCoeff = (config.hfov / 360) * config.touchPanSpeedCoeffFactor;\n\n        var yaw = (onPointerDownPointerX - clientX) * touchmovePanSpeedCoeff + onPointerDownYaw;\n        speed.yaw = (yaw - config.yaw) % 360 * 0.2;\n        config.yaw = yaw;\n\n        var pitch = (clientY - onPointerDownPointerY) * touchmovePanSpeedCoeff + onPointerDownPitch;\n        speed.pitch = (pitch - config.pitch) * 0.2;\n        config.pitch = pitch;\n    }\n}\n\n/**\n * Event handler for end of touches. Stops panning and/or zooming.\n * @private\n */\nfunction onDocumentTouchEnd() {\n    isUserInteracting = false;\n    if (Date.now() - latestInteraction > 150) {\n        speed.pitch = speed.yaw = 0;\n    }\n    onPointerDownPointerDist = -1;\n    latestInteraction = Date.now();\n\n    fireEvent('touchend', event);\n}\n\nvar pointerIDs = [],\n    pointerCoordinates = [];\n/**\n * Event handler for touch starts in IE / Edge.\n * @private\n * @param {PointerEvent} event - Document pointer down event.\n */\nfunction onDocumentPointerDown(event) {\n    if (event.pointerType == 'touch') {\n        // Only do something if the panorama is loaded\n        if (!loaded || !config.draggable)\n            return;\n        pointerIDs.push(event.pointerId);\n        pointerCoordinates.push({clientX: event.clientX, clientY: event.clientY});\n        event.targetTouches = pointerCoordinates;\n        onDocumentTouchStart(event);\n        event.preventDefault();\n    }\n}\n\n/**\n * Event handler for touch moves in IE / Edge.\n * @private\n * @param {PointerEvent} event - Document pointer move event.\n */\nfunction onDocumentPointerMove(event) {\n    if (event.pointerType == 'touch') {\n        if (!config.draggable)\n            return;\n        for (var i = 0; i < pointerIDs.length; i++) {\n            if (event.pointerId == pointerIDs[i]) {\n                pointerCoordinates[i].clientX = event.clientX;\n                pointerCoordinates[i].clientY = event.clientY;\n                event.targetTouches = pointerCoordinates;\n                onDocumentTouchMove(event);\n                event.preventDefault();\n                return;\n            }\n        }\n    }\n}\n\n/**\n * Event handler for touch ends in IE / Edge.\n * @private\n * @param {PointerEvent} event - Document pointer up event.\n */\nfunction onDocumentPointerUp(event) {\n    if (event.pointerType == 'touch') {\n        var defined = false;\n        for (var i = 0; i < pointerIDs.length; i++) {\n            if (event.pointerId == pointerIDs[i])\n                pointerIDs[i] = undefined;\n            if (pointerIDs[i])\n                defined = true;\n        }\n        if (!defined) {\n            pointerIDs = [];\n            pointerCoordinates = [];\n            onDocumentTouchEnd();\n        }\n        event.preventDefault();\n    }\n}\n\n/**\n * Event handler for mouse wheel. Changes zoom.\n * @private\n * @param {WheelEvent} event - Document mouse wheel event.\n */\nfunction onDocumentMouseWheel(event) {\n    // Only do something if the panorama is loaded and mouse wheel zoom is enabled\n    if (!loaded || (config.mouseZoom == 'fullscreenonly' && !fullscreenActive)) {\n        return;\n    }\n\n    event.preventDefault();\n\n    // Turn off auto-rotation if enabled\n    stopAnimation();\n    latestInteraction = Date.now();\n\n    if (event.wheelDeltaY) {\n        // WebKit\n        setHfov(config.hfov - event.wheelDeltaY * 0.05);\n        speed.hfov = event.wheelDelta < 0 ? 1 : -1;\n    } else if (event.wheelDelta) {\n        // Opera / Explorer 9\n        setHfov(config.hfov - event.wheelDelta * 0.05);\n        speed.hfov = event.wheelDelta < 0 ? 1 : -1;\n    } else if (event.detail) {\n        // Firefox\n        setHfov(config.hfov + event.detail * 1.5);\n        speed.hfov = event.detail > 0 ? 1 : -1;\n    }\n    animateInit();\n}\n\n/**\n * Event handler for key presses. Updates list of currently pressed keys.\n * @private\n * @param {KeyboardEvent} event - Document key press event.\n */\nfunction onDocumentKeyPress(event) {\n    // Turn off auto-rotation if enabled\n    stopAnimation();\n    latestInteraction = Date.now();\n\n    stopOrientation();\n    config.roll = 0;\n\n    // Record key pressed\n    var keynumber = event.which || event.keycode;\n\n    // Override default action for keys that are used\n    if (config.capturedKeyNumbers.indexOf(keynumber) < 0)\n        return;\n    event.preventDefault();\n    \n    // If escape key is pressed\n    if (keynumber == 27) {\n        // If in fullscreen mode\n        if (fullscreenActive) {\n            toggleFullscreen();\n        }\n    } else {\n        // Change key\n        changeKey(keynumber, true);\n    }\n}\n\n/**\n * Clears list of currently pressed keys.\n * @private\n */\nfunction clearKeys() {\n    for (var i = 0; i < 10; i++) {\n        keysDown[i] = false;\n    }\n}\n\n/**\n * Event handler for key releases. Updates list of currently pressed keys.\n * @private\n * @param {KeyboardEvent} event - Document key up event.\n */\nfunction onDocumentKeyUp(event) {\n    // Record key pressed\n    var keynumber = event.which || event.keycode;\n    \n    // Override default action for keys that are used\n    if (config.capturedKeyNumbers.indexOf(keynumber) < 0)\n        return;\n    event.preventDefault();\n    \n    // Change key\n    changeKey(keynumber, false);\n}\n\n/**\n * Updates list of currently pressed keys.\n * @private\n * @param {number} keynumber - Key number.\n * @param {boolean} value - Whether or not key is pressed.\n */\nfunction changeKey(keynumber, value) {\n    var keyChanged = false;\n    switch(keynumber) {\n        // If minus key is released\n        case 109: case 189: case 17: case 173:\n            if (keysDown[0] != value) { keyChanged = true; }\n            keysDown[0] = value; break;\n        \n        // If plus key is released\n        case 107: case 187: case 16: case 61:\n            if (keysDown[1] != value) { keyChanged = true; }\n            keysDown[1] = value; break;\n        \n        // If up arrow is released\n        case 38:\n            if (keysDown[2] != value) { keyChanged = true; }\n            keysDown[2] = value; break;\n        \n        // If \"w\" is released\n        case 87:\n            if (keysDown[6] != value) { keyChanged = true; }\n            keysDown[6] = value; break;\n        \n        // If down arrow is released\n        case 40:\n            if (keysDown[3] != value) { keyChanged = true; }\n            keysDown[3] = value; break;\n        \n        // If \"s\" is released\n        case 83:\n            if (keysDown[7] != value) { keyChanged = true; }\n            keysDown[7] = value; break;\n        \n        // If left arrow is released\n        case 37:\n            if (keysDown[4] != value) { keyChanged = true; }\n            keysDown[4] = value; break;\n        \n        // If \"a\" is released\n        case 65:\n            if (keysDown[8] != value) { keyChanged = true; }\n            keysDown[8] = value; break;\n        \n        // If right arrow is released\n        case 39:\n            if (keysDown[5] != value) { keyChanged = true; }\n            keysDown[5] = value; break;\n        \n        // If \"d\" is released\n        case 68:\n            if (keysDown[9] != value) { keyChanged = true; }\n            keysDown[9] = value;\n    }\n    \n    if (keyChanged && value) {\n        if (typeof performance !== 'undefined' && performance.now()) {\n            prevTime = performance.now();\n        } else {\n            prevTime = Date.now();\n        }\n        animateInit();\n    }\n}\n\n/**\n * Pans and/or zooms panorama based on currently pressed keys. Also handles\n * panorama \"inertia\" and auto rotation.\n * @private\n */\nfunction keyRepeat() {\n    // Only do something if the panorama is loaded\n    if (!loaded) {\n        return;\n    }\n\n    var isKeyDown = false;\n\n    var prevPitch = config.pitch;\n    var prevYaw = config.yaw;\n    var prevZoom = config.hfov;\n    \n    var newTime;\n    if (typeof performance !== 'undefined' && performance.now()) {\n        newTime = performance.now();\n    } else {\n        newTime = Date.now();\n    }\n    if (prevTime === undefined) {\n        prevTime = newTime;\n    }\n    var diff = (newTime - prevTime) * config.hfov / 1700;\n    diff = Math.min(diff, 1.0);\n    \n    // If minus key is down\n    if (keysDown[0] && config.keyboardZoom === true) {\n        setHfov(config.hfov + (speed.hfov * 0.8 + 0.5) * diff);\n        isKeyDown = true;\n    }\n    \n    // If plus key is down\n    if (keysDown[1] && config.keyboardZoom === true) {\n        setHfov(config.hfov + (speed.hfov * 0.8 - 0.2) * diff);\n        isKeyDown = true;\n    }\n    \n    // If up arrow or \"w\" is down\n    if (keysDown[2] || keysDown[6]) {\n        // Pan up\n        config.pitch += (speed.pitch * 0.8 + 0.2) * diff;\n        isKeyDown = true;\n    }\n    \n    // If down arrow or \"s\" is down\n    if (keysDown[3] || keysDown[7]) {\n        // Pan down\n        config.pitch += (speed.pitch * 0.8 - 0.2) * diff;\n        isKeyDown = true;\n    }\n    \n    // If left arrow or \"a\" is down\n    if (keysDown[4] || keysDown[8]) {\n        // Pan left\n        config.yaw += (speed.yaw * 0.8 - 0.2) * diff;\n        isKeyDown = true;\n    }\n    \n    // If right arrow or \"d\" is down\n    if (keysDown[5] || keysDown[9]) {\n        // Pan right\n        config.yaw += (speed.yaw * 0.8 + 0.2) * diff;\n        isKeyDown = true;\n    }\n\n    if (isKeyDown)\n        latestInteraction = Date.now();\n\n    // If auto-rotate\n    if (config.autoRotate) {\n        // Pan\n        if (newTime - prevTime > 0.001) {\n            var timeDiff = (newTime - prevTime) / 1000;\n            var yawDiff = (speed.yaw / timeDiff * diff - config.autoRotate * 0.2) * timeDiff;\n            yawDiff = (-config.autoRotate > 0 ? 1 : -1) * Math.min(Math.abs(config.autoRotate * timeDiff), Math.abs(yawDiff));\n            config.yaw += yawDiff;\n        }\n        \n        // Deal with stopping auto rotation after a set delay\n        if (config.autoRotateStopDelay) {\n            config.autoRotateStopDelay -= newTime - prevTime;\n            if (config.autoRotateStopDelay <= 0) {\n                config.autoRotateStopDelay = false;\n                autoRotateSpeed = config.autoRotate;\n                config.autoRotate = 0;\n            }\n        }\n    }\n\n    // Animated moves\n    if (animatedMove.pitch) {\n        animateMove('pitch');\n        prevPitch = config.pitch;\n    }\n    if (animatedMove.yaw) {\n        animateMove('yaw');\n        prevYaw = config.yaw;\n    }\n    if (animatedMove.hfov) {\n        animateMove('hfov');\n        prevZoom = config.hfov;\n    }\n\n    // \"Inertia\"\n    if (diff > 0 && !config.autoRotate) {\n        // \"Friction\"\n        var slowDownFactor = 1 - config.friction;\n\n        // Yaw\n        if (!keysDown[4] && !keysDown[5] && !keysDown[8] && !keysDown[9] && !animatedMove.yaw) {\n            config.yaw += speed.yaw * diff * slowDownFactor;\n        }\n        // Pitch\n        if (!keysDown[2] && !keysDown[3] && !keysDown[6] && !keysDown[7] && !animatedMove.pitch) {\n            config.pitch += speed.pitch * diff * slowDownFactor;\n        }\n        // Zoom\n        if (!keysDown[0] && !keysDown[1] && !animatedMove.hfov) {\n            setHfov(config.hfov + speed.hfov * diff * slowDownFactor);\n        }\n    }\n\n    prevTime = newTime;\n    if (diff > 0) {\n        speed.yaw = speed.yaw * 0.8 + (config.yaw - prevYaw) / diff * 0.2;\n        speed.pitch = speed.pitch * 0.8 + (config.pitch - prevPitch) / diff * 0.2;\n        speed.hfov = speed.hfov * 0.8 + (config.hfov - prevZoom) / diff * 0.2;\n        \n        // Limit speed\n        var maxSpeed = config.autoRotate ? Math.abs(config.autoRotate) : 5;\n        speed.yaw = Math.min(maxSpeed, Math.max(speed.yaw, -maxSpeed));\n        speed.pitch = Math.min(maxSpeed, Math.max(speed.pitch, -maxSpeed));\n        speed.hfov = Math.min(maxSpeed, Math.max(speed.hfov, -maxSpeed));\n    }\n    \n    // Stop movement if opposite controls are pressed\n    if (keysDown[0] && keysDown[1]) {\n        speed.hfov = 0;\n    }\n    if ((keysDown[2] || keysDown[6]) && (keysDown[3] || keysDown[7])) {\n        speed.pitch = 0;\n    }\n    if ((keysDown[4] || keysDown[8]) && (keysDown[5] || keysDown[9])) {\n        speed.yaw = 0;\n    }\n}\n\n/**\n * Animates moves.\n * @param {string} axis - Axis to animate\n * @private\n */\nfunction animateMove(axis) {\n    var t = animatedMove[axis];\n    var normTime = Math.min(1, Math.max((Date.now() - t.startTime) / 1000 / (t.duration / 1000), 0));\n    var result = t.startPosition + config.animationTimingFunction(normTime) * (t.endPosition - t.startPosition);\n    if ((t.endPosition > t.startPosition && result >= t.endPosition) ||\n        (t.endPosition < t.startPosition && result <= t.endPosition) ||\n        t.endPosition === t.startPosition) {\n        result = t.endPosition;\n        speed[axis] = 0;\n        delete animatedMove[axis];\n    }\n    config[axis] = result;\n}\n\n/**\n * @param {number} t - Normalized time in animation\n * @return {number} Position in animation\n * @private\n */\nfunction timingFunction(t) {\n    // easeInOutQuad from https://gist.github.com/gre/1650294\n    return t < 0.5 ? 2*t*t : -1+(4-2*t)*t;\n}\n\n/**\n * Event handler for document resizes. Updates viewer size and rerenders view.\n * @private\n */\nfunction onDocumentResize() {\n    // Resize panorama renderer (moved to onFullScreenChange)\n    //renderer.resize();\n    //animateInit();\n\n    // Kludge to deal with WebKit regression: https://bugs.webkit.org/show_bug.cgi?id=93525\n    onFullScreenChange('resize');\n}\n\n/**\n * Initializes animation.\n * @private\n */\nfunction animateInit() {\n    if (animating) {\n        return;\n    }\n    animating = true;\n    animate();\n}\n\n/**\n * Animates view, using requestAnimationFrame to trigger rendering.\n * @private\n */\nfunction animate() {\n    if (destroyed) {\n        return;\n    }\n\n    render();\n    if (autoRotateStart)\n        clearTimeout(autoRotateStart);\n    if (isUserInteracting || orientation === true) {\n        requestAnimationFrame(animate);\n    } else if (keysDown[0] || keysDown[1] || keysDown[2] || keysDown[3] ||\n        keysDown[4] || keysDown[5] || keysDown[6] || keysDown[7] ||\n        keysDown[8] || keysDown[9] || config.autoRotate ||\n        animatedMove.pitch || animatedMove.yaw || animatedMove.hfov ||\n        Math.abs(speed.yaw) > 0.01 || Math.abs(speed.pitch) > 0.01 ||\n        Math.abs(speed.hfov) > 0.01) {\n\n        keyRepeat();\n        if (config.autoRotateInactivityDelay >= 0 && autoRotateSpeed &&\n            Date.now() - latestInteraction > config.autoRotateInactivityDelay &&\n            !config.autoRotate) {\n            config.autoRotate = autoRotateSpeed;\n            _this.lookAt(origPitch, undefined, origHfov, 3000);\n        }\n        requestAnimationFrame(animate);\n    } else if (renderer && (renderer.isLoading() || (config.dynamic === true && update))) {\n        requestAnimationFrame(animate);\n    } else {\n        fireEvent('animatefinished', {pitch: _this.getPitch(), yaw: _this.getYaw(), hfov: _this.getHfov()});\n        animating = false;\n        prevTime = undefined;\n        var autoRotateStartTime = config.autoRotateInactivityDelay -\n            (Date.now() - latestInteraction);\n        if (autoRotateStartTime > 0) {\n            autoRotateStart = setTimeout(function() {\n                config.autoRotate = autoRotateSpeed;\n                _this.lookAt(origPitch, undefined, origHfov, 3000);\n                animateInit();\n            }, autoRotateStartTime);\n        } else if (config.autoRotateInactivityDelay >= 0 && autoRotateSpeed) {\n            config.autoRotate = autoRotateSpeed;\n            _this.lookAt(origPitch, undefined, origHfov, 3000);\n            animateInit();\n        }\n    }\n}\n\n/**\n * Renders panorama view.\n * @private\n */\nfunction render() {\n    var tmpyaw;\n\n    if (loaded) {\n        var canvas = renderer.getCanvas();\n\n        if (config.autoRotate !== false) {\n            // When auto-rotating this check needs to happen first (see issue #764)\n            if (config.yaw > 360) {\n                config.yaw -= 360;\n            } else if (config.yaw < -360) {\n                config.yaw += 360;\n            }\n        }\n\n        // Keep a tmp value of yaw for autoRotate comparison later\n        tmpyaw = config.yaw;\n\n        // Optionally avoid showing background (empty space) on left or right by adapting min/max yaw\n        var hoffcut = 0,\n            voffcut = 0;\n        if (config.avoidShowingBackground) {\n            var hfov2 = config.hfov / 2,\n                vfov2 = Math.atan2(Math.tan(hfov2 / 180 * Math.PI), (canvas.width / canvas.height)) * 180 / Math.PI,\n                transposed = config.vaov > config.haov;\n            if (transposed) {\n                voffcut = vfov2 * (1 - Math.min(Math.cos((config.pitch - hfov2) / 180 * Math.PI),\n                                                Math.cos((config.pitch + hfov2) / 180 * Math.PI)));\n            } else {\n                hoffcut = hfov2 * (1 - Math.min(Math.cos((config.pitch - vfov2) / 180 * Math.PI),\n                                                Math.cos((config.pitch + vfov2) / 180 * Math.PI)));\n            }\n        }\n\n        // Ensure the yaw is within min and max allowed\n        var yawRange = config.maxYaw - config.minYaw,\n            minYaw = -180,\n            maxYaw = 180;\n        if (yawRange < 360) {\n            minYaw = config.minYaw + config.hfov / 2 + hoffcut;\n            maxYaw = config.maxYaw - config.hfov / 2 - hoffcut;\n            if (yawRange < config.hfov) {\n                // Lock yaw to average of min and max yaw when both can be seen at once\n                minYaw = maxYaw = (minYaw + maxYaw) / 2;\n            }\n            config.yaw = Math.max(minYaw, Math.min(maxYaw, config.yaw));\n        }\n        \n        if (!(config.autoRotate !== false)) {\n            // When not auto-rotating, this check needs to happen after the\n            // previous check (see issue #698)\n            if (config.yaw > 360) {\n                config.yaw -= 360;\n            } else if (config.yaw < -360) {\n                config.yaw += 360;\n            }\n        }\n\n        // Check if we autoRotate in a limited by min and max yaw\n        // If so reverse direction\n        if (config.autoRotate !== false && tmpyaw != config.yaw &&\n            prevTime !== undefined) { // this condition prevents changing the direction initially\n            config.autoRotate *= -1;\n        }\n\n        // Ensure the calculated pitch is within min and max allowed\n        var vfov = 2 * Math.atan(Math.tan(config.hfov / 180 * Math.PI * 0.5) /\n            (canvas.width / canvas.height)) / Math.PI * 180;\n        var minPitch = config.minPitch + vfov / 2,\n            maxPitch = config.maxPitch - vfov / 2;\n        var pitchRange = config.maxPitch - config.minPitch;\n        if (pitchRange < vfov) {\n            // Lock pitch to average of min and max pitch when both can be seen at once\n            minPitch = maxPitch = (minPitch + maxPitch) / 2;\n        }\n        if (isNaN(minPitch))\n            minPitch = -90;\n        if (isNaN(maxPitch))\n            maxPitch = 90;\n        config.pitch = Math.max(minPitch, Math.min(maxPitch, config.pitch));\n        \n        renderer.render(config.pitch * Math.PI / 180, config.yaw * Math.PI / 180, config.hfov * Math.PI / 180, {roll: config.roll * Math.PI / 180});\n        \n        renderHotSpots();\n        \n        // Update compass\n        if (config.compass) {\n            compass.style.transform = 'rotate(' + (-config.yaw - config.northOffset) + 'deg)';\n            compass.style.webkitTransform = 'rotate(' + (-config.yaw - config.northOffset) + 'deg)';\n        }\n    }\n}\n\n/**\n * Creates a new quaternion.\n * @private\n * @constructor\n * @param {Number} w - W value\n * @param {Number} x - X value\n * @param {Number} y - Y value\n * @param {Number} z - Z value\n */\nfunction Quaternion(w, x, y, z) {\n    this.w = w;\n    this.x = x;\n    this.y = y;\n    this.z = z;\n}\n\n/**\n * Multiplies quaternions.\n * @private\n * @param {Quaternion} q - Quaternion to multiply\n * @returns {Quaternion} Result of multiplication\n */\nQuaternion.prototype.multiply = function(q) {\n    return new Quaternion(this.w*q.w - this.x*q.x - this.y*q.y - this.z*q.z,\n                          this.x*q.w + this.w*q.x + this.y*q.z - this.z*q.y,\n                          this.y*q.w + this.w*q.y + this.z*q.x - this.x*q.z,\n                          this.z*q.w + this.w*q.z + this.x*q.y - this.y*q.x);\n};\n\n/**\n * Converts quaternion to Euler angles.\n * @private\n * @returns {Number[]} [phi angle, theta angle, psi angle]\n */\nQuaternion.prototype.toEulerAngles = function() {\n    var phi = Math.atan2(2 * (this.w * this.x + this.y * this.z),\n                         1 - 2 * (this.x * this.x + this.y * this.y)),\n        theta = Math.asin(2 * (this.w * this.y - this.z * this.x)),\n        psi = Math.atan2(2 * (this.w * this.z + this.x * this.y),\n                         1 - 2 * (this.y * this.y + this.z * this.z));\n    return [phi, theta, psi];\n};\n\n/**\n * Converts device orientation API Tait-Bryan angles to a quaternion.\n * @private\n * @param {Number} alpha - Alpha angle (in degrees)\n * @param {Number} beta - Beta angle (in degrees)\n * @param {Number} gamma - Gamma angle (in degrees)\n * @returns {Quaternion} Orientation quaternion\n */\nfunction taitBryanToQuaternion(alpha, beta, gamma) {\n    var r = [beta ? beta * Math.PI / 180 / 2 : 0,\n             gamma ? gamma * Math.PI / 180 / 2 : 0,\n             alpha ? alpha * Math.PI / 180 / 2 : 0];\n    var c = [Math.cos(r[0]), Math.cos(r[1]), Math.cos(r[2])],\n        s = [Math.sin(r[0]), Math.sin(r[1]), Math.sin(r[2])];\n\n    return new Quaternion(c[0]*c[1]*c[2] - s[0]*s[1]*s[2],\n                          s[0]*c[1]*c[2] - c[0]*s[1]*s[2],\n                          c[0]*s[1]*c[2] + s[0]*c[1]*s[2],\n                          c[0]*c[1]*s[2] + s[0]*s[1]*c[2]);\n}\n\n/**\n * Computes current device orientation quaternion from device orientation API\n * Tait-Bryan angles.\n * @private\n * @param {Number} alpha - Alpha angle (in degrees)\n * @param {Number} beta - Beta angle (in degrees)\n * @param {Number} gamma - Gamma angle (in degrees)\n * @returns {Quaternion} Orientation quaternion\n */\nfunction computeQuaternion(alpha, beta, gamma) {\n    // Convert Tait-Bryan angles to quaternion\n    var quaternion = taitBryanToQuaternion(alpha, beta, gamma);\n    // Apply world transform\n    quaternion = quaternion.multiply(new Quaternion(Math.sqrt(0.5), -Math.sqrt(0.5), 0, 0));\n    // Apply screen transform\n    var angle = window.orientation ? -window.orientation * Math.PI / 180 / 2 : 0;\n    return quaternion.multiply(new Quaternion(Math.cos(angle), 0, -Math.sin(angle), 0));\n}\n\n/**\n * Event handler for device orientation API. Controls pointing.\n * @private\n * @param {DeviceOrientationEvent} event - Device orientation event.\n */\nfunction orientationListener(e) {\n    var q = computeQuaternion(e.alpha, e.beta, e.gamma).toEulerAngles();\n    if (typeof(orientation) == 'number' && orientation < 10) {\n        // This kludge is necessary because iOS sometimes provides a few stale\n        // device orientation events when the listener is removed and then\n        // readded. Thus, we skip the first 10 events to prevent this from\n        // causing problems.\n        orientation += 1;\n    } else if (orientation === 10) {\n        // Record starting yaw to prevent jumping\n        orientationYawOffset = q[2] / Math.PI * 180 + config.yaw;\n        orientation = true;\n        requestAnimationFrame(animate);\n    } else {\n        config.pitch = q[0] / Math.PI * 180;\n        config.roll = -q[1] / Math.PI * 180;\n        config.yaw = -q[2] / Math.PI * 180 + orientationYawOffset;\n    }\n}\n\n/**\n * Initializes renderer.\n * @private\n */\nfunction renderInit() {\n    try {\n        var params = {};\n        if (config.horizonPitch !== undefined)\n            params.horizonPitch = config.horizonPitch * Math.PI / 180;\n        if (config.horizonRoll !== undefined)\n            params.horizonRoll = config.horizonRoll * Math.PI / 180;\n        if (config.backgroundColor !== undefined)\n            params.backgroundColor = config.backgroundColor;\n        renderer.init(panoImage, config.type, config.dynamic, config.haov * Math.PI / 180, config.vaov * Math.PI / 180, config.vOffset * Math.PI / 180, renderInitCallback, params);\n        if (config.dynamic !== true) {\n            // Allow image to be garbage collected\n            panoImage = undefined;\n        }\n    } catch(event) {\n        // Panorama not loaded\n        \n        // Display error if there is a bad texture\n        if (event.type == 'webgl error' || event.type == 'no webgl') {\n            anError();\n        } else if (event.type == 'webgl size error') {\n            anError(config.strings.textureSizeError.replace('%s', event.width).replace('%s', event.maxWidth));\n        } else {\n            anError(config.strings.unknownError);\n            throw event;\n        }\n    }\n}\n\n/**\n * Triggered when render initialization finishes. Handles fading between\n * scenes as well as showing the compass and hotspots and hiding the loading\n * display.\n * @private\n */\nfunction renderInitCallback() {\n    // Fade if specified\n    if (config.sceneFadeDuration && renderer.fadeImg !== undefined) {\n        renderer.fadeImg.style.opacity = 0;\n        // Remove image\n        var fadeImg = renderer.fadeImg;\n        delete renderer.fadeImg;\n        setTimeout(function() {\n            renderContainer.removeChild(fadeImg);\n            fireEvent('scenechangefadedone');\n        }, config.sceneFadeDuration);\n    }\n    \n    // Show compass if applicable\n    if (config.compass) {\n        compass.style.display = 'inline';\n    } else {\n        compass.style.display = 'none';\n    }\n    \n    // Show hotspots\n    createHotSpots();\n    \n    // Hide loading display\n    infoDisplay.load.box.style.display = 'none';\n    if (preview !== undefined) {\n        renderContainer.removeChild(preview);\n        preview = undefined;\n    }\n    loaded = true;\n    \n    animateInit();\n\n    fireEvent('load');\n}\n\n/**\n * Creates hot spot element for the current scene.\n * @private\n * @param {Object} hs - The configuration for the hotspot\n */\nfunction createHotSpot(hs) {\n    // Make sure hot spot pitch and yaw are numbers\n    hs.pitch = Number(hs.pitch) || 0;\n    hs.yaw = Number(hs.yaw) || 0;\n\n    var div = document.createElement('div');\n    div.className = 'pnlm-hotspot-base';\n    if (hs.cssClass)\n        div.className += ' ' + hs.cssClass;\n    else\n        div.className += ' pnlm-hotspot pnlm-sprite pnlm-' + escapeHTML(hs.type);\n\n    var span = document.createElement('span');\n    if (hs.text)\n        span.innerHTML = escapeHTML(hs.text);\n\n    var a;\n    if (hs.video) {\n        var video = document.createElement('video'),\n            vidp = hs.video;\n        if (config.basePath && !absoluteURL(vidp))\n            vidp = config.basePath + vidp;\n        video.src = sanitizeURL(vidp);\n        video.controls = true;\n        video.style.width = hs.width + 'px';\n        renderContainer.appendChild(div);\n        span.appendChild(video);\n    } else if (hs.image) {\n        var imgp = hs.image;\n        if (config.basePath && !absoluteURL(imgp))\n            imgp = config.basePath + imgp;\n        a = document.createElement('a');\n        a.href = sanitizeURL(hs.URL ? hs.URL : imgp, true);\n        a.target = '_blank';\n        span.appendChild(a);\n        var image = document.createElement('img');\n        image.src = sanitizeURL(imgp);\n        image.style.width = hs.width + 'px';\n        image.style.paddingTop = '5px';\n        renderContainer.appendChild(div);\n        a.appendChild(image);\n        span.style.maxWidth = 'initial';\n    } else if (hs.URL) {\n        a = document.createElement('a');\n        a.href = sanitizeURL(hs.URL, true);\n        if (hs.attributes) {\n            for (var key in hs.attributes) {\n                a.setAttribute(key, hs.attributes[key]);\n            }\n        } else {\n            a.target = '_blank';\n        }\n        renderContainer.appendChild(a);\n        div.className += ' pnlm-pointer';\n        span.className += ' pnlm-pointer';\n        a.appendChild(div);\n    } else {\n        if (hs.sceneId) {\n            div.onclick = div.ontouchend = function() {\n                if (!div.clicked) {\n                    div.clicked = true;\n                    loadScene(hs.sceneId, hs.targetPitch, hs.targetYaw, hs.targetHfov);\n                }\n                return false;\n            };\n            div.className += ' pnlm-pointer';\n            span.className += ' pnlm-pointer';\n        }\n        renderContainer.appendChild(div);\n    }\n\n    if (hs.createTooltipFunc) {\n        hs.createTooltipFunc(div, hs.createTooltipArgs);\n    } else if (hs.text || hs.video || hs.image) {\n        div.classList.add('pnlm-tooltip');\n        div.appendChild(span);\n        span.style.width = span.scrollWidth - 20 + 'px';\n        span.style.marginLeft = -(span.scrollWidth - div.offsetWidth) / 2 + 'px';\n        span.style.marginTop = -span.scrollHeight - 12 + 'px';\n    }\n    if (hs.clickHandlerFunc) {\n        div.addEventListener('click', function(e) {\n            hs.clickHandlerFunc(e, hs.clickHandlerArgs);\n        }, 'false');\n        div.className += ' pnlm-pointer';\n        span.className += ' pnlm-pointer';\n    }\n    hs.div = div;\n}\n\n/**\n * Creates hot spot elements for the current scene.\n * @private\n */\nfunction createHotSpots() {\n    if (hotspotsCreated) return;\n\n    if (!config.hotSpots) {\n        config.hotSpots = [];\n    } else {\n        // Sort by pitch so tooltip is never obscured by another hot spot\n        config.hotSpots = config.hotSpots.sort(function(a, b) {\n            return a.pitch < b.pitch;\n        });\n        config.hotSpots.forEach(createHotSpot);\n    }\n    hotspotsCreated = true;\n    renderHotSpots();\n}\n\n/**\n * Destroys currently created hot spot elements.\n * @private\n */\nfunction destroyHotSpots() {\n    var hs = config.hotSpots;\n    hotspotsCreated = false;\n    delete config.hotSpots;\n    if (hs) {\n        for (var i = 0; i < hs.length; i++) {\n            var current = hs[i].div;\n            if (current) {\n                while (current.parentNode && current.parentNode != renderContainer) {\n                    current = current.parentNode;\n                }\n                renderContainer.removeChild(current);\n            }\n            delete hs[i].div;\n        }\n    }\n}\n\n/**\n * Renders hot spot, updating its position and visibility.\n * @private\n */\nfunction renderHotSpot(hs) {\n    var hsPitchSin = Math.sin(hs.pitch * Math.PI / 180),\n        hsPitchCos = Math.cos(hs.pitch * Math.PI / 180),\n        configPitchSin = Math.sin(config.pitch * Math.PI / 180),\n        configPitchCos = Math.cos(config.pitch * Math.PI / 180),\n        yawCos = Math.cos((-hs.yaw + config.yaw) * Math.PI / 180);\n    var z = hsPitchSin * configPitchSin + hsPitchCos * yawCos * configPitchCos;\n    if ((hs.yaw <= 90 && hs.yaw > -90 && z <= 0) ||\n      ((hs.yaw > 90 || hs.yaw <= -90) && z <= 0)) {\n        hs.div.style.visibility = 'hidden';\n    } else {\n        var yawSin = Math.sin((-hs.yaw + config.yaw) * Math.PI / 180),\n            hfovTan = Math.tan(config.hfov * Math.PI / 360);\n        hs.div.style.visibility = 'visible';\n        // Subpixel rendering doesn't work in Firefox\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=739176\n        var canvas = renderer.getCanvas(),\n            canvasWidth = canvas.clientWidth,\n            canvasHeight = canvas.clientHeight;\n        var coord = [-canvasWidth / hfovTan * yawSin * hsPitchCos / z / 2,\n            -canvasWidth / hfovTan * (hsPitchSin * configPitchCos -\n            hsPitchCos * yawCos * configPitchSin) / z / 2];\n        // Apply roll\n        var rollSin = Math.sin(config.roll * Math.PI / 180),\n            rollCos = Math.cos(config.roll * Math.PI / 180);\n        coord = [coord[0] * rollCos - coord[1] * rollSin,\n                 coord[0] * rollSin + coord[1] * rollCos];\n        // Apply transform\n        coord[0] += (canvasWidth - hs.div.offsetWidth) / 2;\n        coord[1] += (canvasHeight - hs.div.offsetHeight) / 2;\n        var transform = 'translate(' + coord[0] + 'px, ' + coord[1] +\n            'px) translateZ(9999px) rotate(' + config.roll + 'deg)';\n        if (hs.scale) {\n            transform += ' scale(' + (origHfov/config.hfov) / z + ')';\n        }\n        hs.div.style.webkitTransform = transform;\n        hs.div.style.MozTransform = transform;\n        hs.div.style.transform = transform;\n    }\n}\n\n/**\n * Renders hot spots, updating their positions and visibility.\n * @private\n */\nfunction renderHotSpots() {\n    config.hotSpots.forEach(renderHotSpot);\n}\n\n/**\n * Merges a scene configuration into the current configuration.\n * @private\n * @param {string} sceneId - Identifier of scene configuration to merge in.\n */\nfunction mergeConfig(sceneId) {\n    config = {};\n    var k, s;\n    var photoSphereExcludes = ['haov', 'vaov', 'vOffset', 'northOffset', 'horizonPitch', 'horizonRoll'];\n    specifiedPhotoSphereExcludes = [];\n    \n    // Merge default config\n    for (k in defaultConfig) {\n        if (defaultConfig.hasOwnProperty(k)) {\n            config[k] = defaultConfig[k];\n        }\n    }\n    \n    // Merge default scene config\n    for (k in initialConfig.default) {\n        if (initialConfig.default.hasOwnProperty(k)) {\n            if (k == 'strings') {\n                for (s in initialConfig.default.strings) {\n                    if (initialConfig.default.strings.hasOwnProperty(s)) {\n                        config.strings[s] = escapeHTML(initialConfig.default.strings[s]);\n                    }\n                }\n            } else {\n                config[k] = initialConfig.default[k];\n                if (photoSphereExcludes.indexOf(k) >= 0) {\n                    specifiedPhotoSphereExcludes.push(k);\n                }\n            }\n        }\n    }\n    \n    // Merge current scene config\n    if ((sceneId !== null) && (sceneId !== '') && (initialConfig.scenes) && (initialConfig.scenes[sceneId])) {\n        var scene = initialConfig.scenes[sceneId];\n        for (k in scene) {\n            if (scene.hasOwnProperty(k)) {\n                if (k == 'strings') {\n                    for (s in scene.strings) {\n                        if (scene.strings.hasOwnProperty(s)) {\n                            config.strings[s] = escapeHTML(scene.strings[s]);\n                        }\n                    }\n                } else {\n                    config[k] = scene[k];\n                    if (photoSphereExcludes.indexOf(k) >= 0) {\n                        specifiedPhotoSphereExcludes.push(k);\n                    }\n                }\n            }\n        }\n        config.scene = sceneId;\n    }\n    \n    // Merge initial config\n    for (k in initialConfig) {\n        if (initialConfig.hasOwnProperty(k)) {\n            if (k == 'strings') {\n                for (s in initialConfig.strings) {\n                    if (initialConfig.strings.hasOwnProperty(s)) {\n                        config.strings[s] = escapeHTML(initialConfig.strings[s]);\n                    }\n                }\n            } else {\n                config[k] = initialConfig[k];\n                if (photoSphereExcludes.indexOf(k) >= 0) {\n                    specifiedPhotoSphereExcludes.push(k);\n                }\n            }\n        }\n    }\n}\n\n/**\n * Processes configuration options.\n * @param {boolean} [isPreview] - Whether or not the preview is being displayed\n * @private\n */\nfunction processOptions(isPreview) {\n    isPreview = isPreview ? isPreview : false;\n\n    // Process preview first so it always loads before the browser hits its\n    // maximum number of connections to a server as can happen with cubic\n    // panoramas\n    if (isPreview && 'preview' in config) {\n        var p = config.preview;\n        if (config.basePath && !absoluteURL(p))\n            p = config.basePath + p;\n        preview = document.createElement('div');\n        preview.className = 'pnlm-preview-img';\n        preview.style.backgroundImage = \"url('\" + sanitizeURLForCss(p) + \"')\";\n        renderContainer.appendChild(preview);\n    }\n\n    // Handle different preview values\n    var title = config.title,\n        author = config.author;\n    if (isPreview) {\n        if ('previewTitle' in config)\n            config.title = config.previewTitle;\n        if ('previewAuthor' in config)\n            config.author = config.previewAuthor;\n    }\n\n    // Reset title / author display\n    if (!config.hasOwnProperty('title'))\n        infoDisplay.title.innerHTML = '';\n    if (!config.hasOwnProperty('author'))\n        infoDisplay.author.innerHTML = '';\n    if (!config.hasOwnProperty('title') && !config.hasOwnProperty('author'))\n        infoDisplay.container.style.display = 'none';\n\n    // Fill in load button label and loading box text\n    controls.load.innerHTML = '<p>' + config.strings.loadButtonLabel + '</p>';\n    infoDisplay.load.boxp.innerHTML = config.strings.loadingLabel;\n\n    // Process other options\n    for (var key in config) {\n      if (config.hasOwnProperty(key)) {\n        switch(key) {\n            case 'title':\n                infoDisplay.title.innerHTML = escapeHTML(config[key]);\n                infoDisplay.container.style.display = 'inline';\n                break;\n            \n            case 'author':\n                var authorText = escapeHTML(config[key]);\n                if (config.authorURL) {\n                    var authorLink = document.createElement('a');\n                    authorLink.href = sanitizeURL(config['authorURL'], true);\n                    authorLink.target = '_blank';\n                    authorLink.innerHTML = escapeHTML(config[key]);\n                    authorText = authorLink.outerHTML;\n                }\n                infoDisplay.author.innerHTML = config.strings.bylineLabel.replace('%s', authorText);\n                infoDisplay.container.style.display = 'inline';\n                break;\n            \n            case 'fallback':\n                var link = document.createElement('a');\n                link.href = sanitizeURL(config[key], true);\n                link.target = '_blank';\n                link.textContent = 'Click here to view this panorama in an alternative viewer.';\n                var message = document.createElement('p');\n                message.textContent = 'Your browser does not support WebGL.';\n                message.appendChild(document.createElement('br'));\n                message.appendChild(link);\n                infoDisplay.errorMsg.innerHTML = ''; // Removes all children nodes\n                infoDisplay.errorMsg.appendChild(message);\n                break;\n            \n            case 'hfov':\n                setHfov(Number(config[key]));\n                break;\n            \n            case 'autoLoad':\n                if (config[key] === true && renderer === undefined) {\n                    // Show loading box\n                    infoDisplay.load.box.style.display = 'inline';\n                    // Hide load button\n                    controls.load.style.display = 'none';\n                    // Initialize\n                    init();\n                }\n                break;\n            \n            case 'showZoomCtrl':\n                if (config[key] && config.showControls != false) {\n                    // Show zoom controls\n                    controls.zoom.style.display = 'block';\n                } else {\n                    // Hide zoom controls\n                    controls.zoom.style.display = 'none';\n                }\n                break;\n\n            case 'showFullscreenCtrl':\n                if (config[key] && config.showControls != false && ('fullscreen' in document || 'mozFullScreen' in document ||\n                    'webkitIsFullScreen' in document || 'msFullscreenElement' in document)) {\n                    \n                    // Show fullscreen control\n                    controls.fullscreen.style.display = 'block';\n                } else {\n                    // Hide fullscreen control\n                    controls.fullscreen.style.display = 'none';\n                }\n                break;\n\n            case 'hotSpotDebug':\n                if (config[key])\n                    hotSpotDebugIndicator.style.display = 'block';\n                else\n                    hotSpotDebugIndicator.style.display = 'none';\n                break;\n\n            case 'showControls':\n                if (!config[key]) {\n                    controls.orientation.style.display = 'none';\n                    controls.zoom.style.display = 'none';\n                    controls.fullscreen.style.display = 'none';\n                }\n                break;\n\n            case 'orientationOnByDefault':\n                if (config[key])\n                    startOrientation();\n                break;\n        }\n      }\n    }\n\n    if (isPreview) {\n        // Restore original values if changed for preview\n        if (title)\n            config.title = title;\n        else\n            delete config.title;\n        if (author)\n            config.author = author;\n        else\n            delete config.author;\n    }\n}\n\n/**\n * Toggles fullscreen mode.\n * @private\n */\nfunction toggleFullscreen() {\n    if (loaded && !error) {\n        if (!fullscreenActive) {\n            try {\n                if (container.requestFullscreen) {\n                    container.requestFullscreen();\n                } else if (container.mozRequestFullScreen) {\n                    container.mozRequestFullScreen();\n                } else if (container.msRequestFullscreen) {\n                    container.msRequestFullscreen();\n                } else {\n                    container.webkitRequestFullScreen();\n                }\n            } catch(event) {\n                // Fullscreen doesn't work\n            }\n        } else {\n            if (document.exitFullscreen) {\n                document.exitFullscreen();\n            } else if (document.mozCancelFullScreen) {\n                document.mozCancelFullScreen();\n            } else if (document.webkitCancelFullScreen) {\n                document.webkitCancelFullScreen();\n            } else if (document.msExitFullscreen) {\n                document.msExitFullscreen();\n            }\n        }\n    }\n}\n\n/**\n * Event handler for fullscreen changes.\n * @private\n */\nfunction onFullScreenChange(resize) {\n    if (document.fullscreenElement || document.fullscreen || document.mozFullScreen || document.webkitIsFullScreen || document.msFullscreenElement) {\n        controls.fullscreen.classList.add('pnlm-fullscreen-toggle-button-active');\n        fullscreenActive = true;\n    } else {\n        controls.fullscreen.classList.remove('pnlm-fullscreen-toggle-button-active');\n        fullscreenActive = false;\n    }\n    if (resize !== 'resize')\n        fireEvent('fullscreenchange', fullscreenActive);\n    // Resize renderer (deal with browser quirks and fixes #155)\n    renderer.resize();\n    setHfov(config.hfov);\n    animateInit();\n}\n\n/**\n * Increases panorama zoom. For use with zoom button.\n * @private\n */\nfunction zoomIn() {\n    if (loaded) {\n        setHfov(config.hfov - 5);\n        animateInit();\n    }\n}\n\n/**\n * Decreases panorama zoom. For use with zoom button.\n * @private\n */\nfunction zoomOut() {\n    if (loaded) {\n        setHfov(config.hfov + 5);\n        animateInit();\n    }\n}\n\n/**\n * Clamps horzontal field of view to viewer's limits.\n * @private\n * @param {number} hfov - Input horizontal field of view (in degrees)\n * @return {number} - Clamped horizontal field of view (in degrees)\n */\nfunction constrainHfov(hfov) {\n    // Keep field of view within bounds\n    var minHfov = config.minHfov;\n    if (config.type == 'multires' && renderer && !config.multiResMinHfov) {\n        minHfov = Math.min(minHfov, renderer.getCanvas().width / (config.multiRes.cubeResolution / 90 * 0.9));\n    }\n    if (minHfov > config.maxHfov) {\n        // Don't change view if bounds don't make sense\n        console.log('HFOV bounds do not make sense (minHfov > maxHfov).');\n        return config.hfov;\n    }\n    var newHfov = config.hfov;\n    if (hfov < minHfov) {\n        newHfov = minHfov;\n    } else if (hfov > config.maxHfov) {\n        newHfov = config.maxHfov;\n    } else {\n        newHfov = hfov;\n    }\n    // Optionally avoid showing background (empty space) on top or bottom by adapting newHfov\n    if (config.avoidShowingBackground && renderer) {\n        var canvas = renderer.getCanvas();\n        newHfov = Math.min(newHfov,\n                           Math.atan(Math.tan((config.maxPitch - config.minPitch) / 360 * Math.PI) /\n                                     canvas.height * canvas.width) * 360 / Math.PI);\n    }\n    return newHfov;\n}\n\n/**\n * Sets viewer's horizontal field of view.\n * @private\n * @param {number} hfov - Desired horizontal field of view in degrees.\n */\nfunction setHfov(hfov) {\n    config.hfov = constrainHfov(hfov);\n    fireEvent('zoomchange', config.hfov);\n}\n\n/**\n * Stops auto rotation and animated moves.\n * @private\n */\nfunction stopAnimation() {\n    animatedMove = {};\n    autoRotateSpeed = config.autoRotate ? config.autoRotate : autoRotateSpeed;\n    config.autoRotate = false;\n}\n\n/**\n * Loads panorama.\n * @private\n */\nfunction load() {\n    // Since WebGL error handling is very general, first we clear any error box\n    // since it is a new scene and the error from previous maybe because of lacking\n    // memory etc and not because of a lack of WebGL support etc\n    clearError();\n    loaded = false;\n\n    controls.load.style.display = 'none';\n    infoDisplay.load.box.style.display = 'inline';\n    init();\n}\n\n/**\n * Loads scene.\n * @private\n * @param {string} sceneId - Identifier of scene configuration to merge in.\n * @param {number} targetPitch - Pitch viewer should be centered on once scene loads.\n * @param {number} targetYaw - Yaw viewer should be centered on once scene loads.\n * @param {number} targetHfov - HFOV viewer should use once scene loads.\n * @param {boolean} [fadeDone] - If `true`, fade setup is skipped.\n */\nfunction loadScene(sceneId, targetPitch, targetYaw, targetHfov, fadeDone) {\n    if (!loaded)\n        fadeDone = true;    // Don't try to fade when there isn't a scene loaded\n    loaded = false;\n    animatedMove = {};\n    \n    // Set up fade if specified\n    var fadeImg, workingPitch, workingYaw, workingHfov;\n    if (config.sceneFadeDuration && !fadeDone) {\n        var data = renderer.render(config.pitch * Math.PI / 180, config.yaw * Math.PI / 180, config.hfov * Math.PI / 180, {returnImage: true});\n        if (data !== undefined) {\n            fadeImg = new Image();\n            fadeImg.className = 'pnlm-fade-img';\n            fadeImg.style.transition = 'opacity ' + (config.sceneFadeDuration / 1000) + 's';\n            fadeImg.style.width = '100%';\n            fadeImg.style.height = '100%';\n            fadeImg.onload = function() {\n                loadScene(sceneId, targetPitch, targetYaw, targetHfov, true);\n            };\n            fadeImg.src = data;\n            renderContainer.appendChild(fadeImg);\n            renderer.fadeImg = fadeImg;\n            return;\n        }\n    }\n    \n    // Set new pointing\n    if (targetPitch === 'same') {\n        workingPitch = config.pitch;\n    } else {\n        workingPitch = targetPitch;\n    }\n    if (targetYaw === 'same') {\n        workingYaw = config.yaw;\n    } else if (targetYaw === 'sameAzimuth') {\n        workingYaw = config.yaw + (config.northOffset || 0) - (initialConfig.scenes[sceneId].northOffset || 0);\n    } else {\n        workingYaw = targetYaw;\n    }\n    if (targetHfov === 'same') {\n        workingHfov = config.hfov;\n    } else {\n        workingHfov = targetHfov;\n    }\n    \n    // Destroy hot spots from previous scene\n    destroyHotSpots();\n    \n    // Create the new config for the scene\n    mergeConfig(sceneId);\n\n    // Stop motion\n    speed.yaw = speed.pitch = speed.hfov = 0;\n\n    // Reload scene\n    processOptions();\n    if (workingPitch !== undefined) {\n        config.pitch = workingPitch;\n    }\n    if (workingYaw !== undefined) {\n        config.yaw = workingYaw;\n    }\n    if (workingHfov !== undefined) {\n        config.hfov = workingHfov;\n    }\n    fireEvent('scenechange', sceneId);\n    load();\n}\n\n/**\n * Stop using device orientation.\n * @private\n */\nfunction stopOrientation() {\n    window.removeEventListener('deviceorientation', orientationListener);\n    controls.orientation.classList.remove('pnlm-orientation-button-active');\n    orientation = false;\n}\n\n/**\n * Start using device orientation.\n * @private\n */\nfunction startOrientation() {\n    if (typeof DeviceMotionEvent.requestPermission === 'function') {\n        DeviceOrientationEvent.requestPermission().then(response => {\n            if (response == 'granted') {\n                orientation = 1;\n                window.addEventListener('deviceorientation', orientationListener);\n                controls.orientation.classList.add('pnlm-orientation-button-active');\n            }\n        });\n    } else {\n        orientation = 1;\n        window.addEventListener('deviceorientation', orientationListener);\n        controls.orientation.classList.add('pnlm-orientation-button-active');\n    }\n}\n\n/**\n * Escapes HTML string (to mitigate possible DOM XSS attacks).\n * @private\n * @param {string} s - String to escape\n * @returns {string} Escaped string\n */\nfunction escapeHTML(s) {\n    if (!initialConfig.escapeHTML)\n        return String(s).split('\\n').join('<br>');\n    return String(s).split(/&/g).join('&amp;')\n        .split('\"').join('&quot;')\n        .split(\"'\").join('&#39;')\n        .split('<').join('&lt;')\n        .split('>').join('&gt;')\n        .split('/').join('&#x2f;')\n        .split('\\n').join('<br>');  // Allow line breaks\n}\n\n/**\n * Removes possibility of XSS attacks with URLs.\n * The URL cannot be of protocol 'javascript'.\n * @private\n * @param {string} url - URL to sanitize\n * @param {boolean} href - True if URL is for link (blocks data URIs)\n * @returns {string} Sanitized URL\n */\nfunction sanitizeURL(url, href) {\n    if (url.trim().toLowerCase().indexOf('javascript:') === 0 ||\n        url.trim().toLowerCase().indexOf('vbscript:') === 0) {\n        console.log('Script URL removed.');\n        return 'about:blank';\n    }\n    if (href && url.trim().toLowerCase().indexOf('data:') === 0) {\n        console.log('Data URI removed from link.');\n        return 'about:blank';\n    }\n    return url;\n}\n\n/**\n * Removes possibility of XSS atacks with URLs for CSS.\n * The URL will be sanitized with `sanitizeURL()` and single quotes\n * and double quotes escaped.\n * @private\n * @param {string} url - URL to sanitize\n * @returns {string} Sanitized URL\n */\nfunction sanitizeURLForCss(url) {\n    return sanitizeURL(url)\n        .replace(/\"/g, '%22')\n        .replace(/'/g, '%27');\n}\n\n/**\n * Checks whether or not a panorama is loaded.\n * @memberof Viewer\n * @instance\n * @returns {boolean} `true` if a panorama is loaded, else `false`\n */\nthis.isLoaded = function() {\n    return Boolean(loaded);\n};\n\n/**\n * Returns the pitch of the center of the view.\n * @memberof Viewer\n * @instance\n * @returns {number} Pitch in degrees\n */\nthis.getPitch = function() {\n    return config.pitch;\n};\n\n/**\n * Sets the pitch of the center of the view.\n * @memberof Viewer\n * @instance\n * @param {number} pitch - Pitch in degrees\n * @param {boolean|number} [animated=1000] - Animation duration in milliseconds or false for no animation\n * @param {function} [callback] - Function to call when animation finishes\n * @param {object} [callbackArgs] - Arguments to pass to callback function\n * @returns {Viewer} `this`\n */\nthis.setPitch = function(pitch, animated, callback, callbackArgs) {\n    latestInteraction = Date.now();\n    if (Math.abs(pitch - config.pitch) <= eps) {\n        if (typeof callback == 'function')\n            callback(callbackArgs);\n        return this;\n    }\n    animated = animated == undefined ? 1000: Number(animated);\n    if (animated) {\n        animatedMove.pitch = {\n            'startTime': Date.now(),\n            'startPosition': config.pitch,\n            'endPosition': pitch,\n            'duration': animated\n        };\n        if (typeof callback == 'function')\n            setTimeout(function(){callback(callbackArgs);}, animated);\n    } else {\n        config.pitch = pitch;\n    }\n    animateInit();\n    return this;\n};\n\n/**\n * Returns the minimum and maximum allowed pitches (in degrees).\n * @memberof Viewer\n * @instance\n * @returns {number[]} [minimum pitch, maximum pitch]\n */\nthis.getPitchBounds = function() {\n    return [config.minPitch, config.maxPitch];\n};\n\n/**\n * Set the minimum and maximum allowed pitches (in degrees).\n * @memberof Viewer\n * @instance\n * @param {number[]} bounds - [minimum pitch, maximum pitch]\n * @returns {Viewer} `this`\n */\nthis.setPitchBounds = function(bounds) {\n    config.minPitch = Math.max(-90, Math.min(bounds[0], 90));\n    config.maxPitch = Math.max(-90, Math.min(bounds[1], 90));\n    return this;\n};\n\n/**\n * Returns the yaw of the center of the view.\n * @memberof Viewer\n * @instance\n * @returns {number} Yaw in degrees\n */\nthis.getYaw = function() {\n    return (config.yaw + 540) % 360 - 180;\n};\n\n/**\n * Sets the yaw of the center of the view.\n * @memberof Viewer\n * @instance\n * @param {number} yaw - Yaw in degrees [-180, 180]\n * @param {boolean|number} [animated=1000] - Animation duration in milliseconds or false for no animation\n * @param {function} [callback] - Function to call when animation finishes\n * @param {object} [callbackArgs] - Arguments to pass to callback function\n * @returns {Viewer} `this`\n */\nthis.setYaw = function(yaw, animated, callback, callbackArgs) {\n    latestInteraction = Date.now();\n    if (Math.abs(yaw - config.yaw) <= eps) {\n        if (typeof callback == 'function')\n            callback(callbackArgs);\n        return this;\n    }\n    animated = animated == undefined ? 1000: Number(animated);\n    yaw = ((yaw + 180) % 360) - 180; // Keep in bounds\n    if (animated) {\n        // Animate in shortest direction\n        if (config.yaw - yaw > 180)\n            yaw += 360;\n        else if (yaw - config.yaw > 180)\n            yaw -= 360;\n\n        animatedMove.yaw = {\n            'startTime': Date.now(),\n            'startPosition': config.yaw,\n            'endPosition': yaw,\n            'duration': animated\n        };\n        if (typeof callback == 'function')\n            setTimeout(function(){callback(callbackArgs);}, animated);\n    } else {\n        config.yaw = yaw;\n    }\n    animateInit();\n    return this;\n};\n\n/**\n * Returns the minimum and maximum allowed pitches (in degrees).\n * @memberof Viewer\n * @instance\n * @returns {number[]} [yaw pitch, maximum yaw]\n */\nthis.getYawBounds = function() {\n    return [config.minYaw, config.maxYaw];\n};\n\n/**\n * Set the minimum and maximum allowed yaws (in degrees [-360, 360]).\n * @memberof Viewer\n * @instance\n * @param {number[]} bounds - [minimum yaw, maximum yaw]\n * @returns {Viewer} `this`\n */\nthis.setYawBounds = function(bounds) {\n    config.minYaw = Math.max(-360, Math.min(bounds[0], 360));\n    config.maxYaw = Math.max(-360, Math.min(bounds[1], 360));\n    return this;\n};\n\n/**\n * Returns the horizontal field of view.\n * @memberof Viewer\n * @instance\n * @returns {number} Horizontal field of view in degrees\n */\nthis.getHfov = function() {\n    return config.hfov;\n};\n\n/**\n * Sets the horizontal field of view.\n * @memberof Viewer\n * @instance\n * @param {number} hfov - Horizontal field of view in degrees\n * @param {boolean|number} [animated=1000] - Animation duration in milliseconds or false for no animation\n * @param {function} [callback] - Function to call when animation finishes\n * @param {object} [callbackArgs] - Arguments to pass to callback function\n * @returns {Viewer} `this`\n */\nthis.setHfov = function(hfov, animated, callback, callbackArgs) {\n    latestInteraction = Date.now();\n    if (Math.abs(hfov - config.hfov) <= eps) {\n        if (typeof callback == 'function')\n            callback(callbackArgs);\n        return this;\n    }\n    animated = animated == undefined ? 1000: Number(animated);\n    if (animated) {\n        animatedMove.hfov = {\n            'startTime': Date.now(),\n            'startPosition': config.hfov,\n            'endPosition': constrainHfov(hfov),\n            'duration': animated\n        };\n        if (typeof callback == 'function')\n            setTimeout(function(){callback(callbackArgs);}, animated);\n    } else {\n        setHfov(hfov);\n    }\n    animateInit();\n    return this;\n};\n\n/**\n * Returns the minimum and maximum allowed horizontal fields of view\n * (in degrees).\n * @memberof Viewer\n * @instance\n * @returns {number[]} [minimum hfov, maximum hfov]\n */\nthis.getHfovBounds = function() {\n    return [config.minHfov, config.maxHfov];\n};\n\n/**\n * Set the minimum and maximum allowed horizontal fields of view (in degrees).\n * @memberof Viewer\n * @instance\n * @param {number[]} bounds - [minimum hfov, maximum hfov]\n * @returns {Viewer} `this`\n */\nthis.setHfovBounds = function(bounds) {\n    config.minHfov = Math.max(0, bounds[0]);\n    config.maxHfov = Math.max(0, bounds[1]);\n    return this;\n};\n\n/**\n * Set a new view. Any parameters not specified remain the same.\n * @memberof Viewer\n * @instance\n * @param {number} [pitch] - Target pitch\n * @param {number} [yaw] - Target yaw\n * @param {number} [hfov] - Target hfov\n * @param {boolean|number} [animated=1000] - Animation duration in milliseconds or false for no animation\n * @param {function} [callback] - Function to call when animation finishes\n * @param {object} [callbackArgs] - Arguments to pass to callback function\n * @returns {Viewer} `this`\n */\nthis.lookAt = function(pitch, yaw, hfov, animated, callback, callbackArgs) {\n    animated = animated == undefined ? 1000: Number(animated);\n    if (pitch !== undefined && Math.abs(pitch - config.pitch) > eps) {\n        this.setPitch(pitch, animated, callback, callbackArgs);\n        callback = undefined;\n    }\n    if (yaw !== undefined && Math.abs(yaw - config.yaw) > eps) {\n        this.setYaw(yaw, animated, callback, callbackArgs);\n        callback = undefined;\n    }\n    if (hfov !== undefined && Math.abs(hfov - config.hfov) > eps) {\n        this.setHfov(hfov, animated, callback, callbackArgs);\n        callback = undefined;\n    }\n    if (typeof callback == 'function')\n        callback(callbackArgs);\n    return this;\n};\n\n/**\n * Returns the panorama's north offset.\n * @memberof Viewer\n * @instance\n * @returns {number} North offset in degrees\n */\nthis.getNorthOffset = function() {\n    return config.northOffset;\n};\n\n/**\n * Sets the panorama's north offset.\n * @memberof Viewer\n * @instance\n * @param {number} heading - North offset in degrees\n * @returns {Viewer} `this`\n */\nthis.setNorthOffset = function(heading) {\n    config.northOffset = Math.min(360, Math.max(0, heading));\n    animateInit();\n    return this;\n};\n\n/**\n * Returns the panorama's horizon roll.\n * @memberof Viewer\n * @instance\n * @returns {number} Horizon roll in degrees\n */\nthis.getHorizonRoll = function() {\n    return config.horizonRoll;\n};\n\n/**\n * Sets the panorama's horizon roll.\n * @memberof Viewer\n * @instance\n * @param {number} roll - Horizon roll in degrees [-90, 90]\n * @returns {Viewer} `this`\n */\nthis.setHorizonRoll = function(roll) {\n    config.horizonRoll = Math.min(90, Math.max(-90, roll));\n    renderer.setPose(config.horizonPitch * Math.PI / 180, config.horizonRoll * Math.PI / 180);\n    animateInit();\n    return this;\n};\n\n/**\n * Returns the panorama's horizon pitch.\n * @memberof Viewer\n * @instance\n * @returns {number} Horizon pitch in degrees\n */\nthis.getHorizonPitch = function() {\n    return config.horizonPitch;\n};\n\n/**\n * Sets the panorama's horizon pitch.\n * @memberof Viewer\n * @instance\n * @param {number} pitch - Horizon pitch in degrees [-90, 90]\n * @returns {Viewer} `this`\n */\nthis.setHorizonPitch = function(pitch) {\n    config.horizonPitch = Math.min(90, Math.max(-90, pitch));\n    renderer.setPose(config.horizonPitch * Math.PI / 180, config.horizonRoll * Math.PI / 180);\n    animateInit();\n    return this;\n};\n\n/**\n * Start auto rotation.\n *\n * Before starting rotation, the viewer is panned to `pitch`.\n * @memberof Viewer\n * @instance\n * @param {number} [speed] - Auto rotation speed / direction. If not specified, previous value is used.\n * @param {number} [pitch] - The pitch to rotate at. If not specified, inital pitch is used.\n * @returns {Viewer} `this`\n */\nthis.startAutoRotate = function(speed, pitch) {\n    speed = speed || autoRotateSpeed || 1;\n    pitch = pitch === undefined ? origPitch : pitch;\n    config.autoRotate = speed;\n    _this.lookAt(pitch, undefined, origHfov, 3000);\n    animateInit();\n    return this;\n};\n\n/**\n * Stop auto rotation.\n * @memberof Viewer\n * @instance\n * @returns {Viewer} `this`\n */\nthis.stopAutoRotate = function() {\n    autoRotateSpeed = config.autoRotate ? config.autoRotate : autoRotateSpeed;\n    config.autoRotate = false;\n    config.autoRotateInactivityDelay = -1;\n    return this;\n};\n\n/**\n * Stops all movement.\n * @memberof Viewer\n * @instance\n */\nthis.stopMovement = function() {\n    stopAnimation();\n    speed = {'yaw': 0, 'pitch': 0, 'hfov': 0};\n};\n\n/**\n * Returns the panorama renderer.\n * @memberof Viewer\n * @instance\n * @returns {Renderer}\n */\nthis.getRenderer = function() {\n    return renderer;\n};\n\n/**\n * Sets update flag for dynamic content.\n * @memberof Viewer\n * @instance\n * @param {boolean} bool - Whether or not viewer should update even when still\n * @returns {Viewer} `this`\n */\nthis.setUpdate = function(bool) {\n    update = bool === true;\n    if (renderer === undefined)\n        onImageLoad();\n    else\n        animateInit();\n    return this;\n};\n\n/**\n * Calculate panorama pitch and yaw from location of mouse event.\n * @memberof Viewer\n * @instance\n * @param {MouseEvent} event - Document mouse down event.\n * @returns {number[]} [pitch, yaw]\n */\nthis.mouseEventToCoords = function(event) {\n    return mouseEventToCoords(event);\n};\n\n/**\n * Change scene being viewed.\n * @memberof Viewer\n * @instance\n * @param {string} sceneId - Identifier of scene to switch to.\n * @param {number} [pitch] - Pitch to use with new scene\n * @param {number} [yaw] - Yaw to use with new scene\n * @param {number} [hfov] - HFOV to use with new scene\n * @returns {Viewer} `this`\n */\nthis.loadScene = function(sceneId, pitch, yaw, hfov) {\n    if (loaded !== false)\n        loadScene(sceneId, pitch, yaw, hfov);\n    return this;\n};\n\n/**\n * Get ID of current scene.\n * @memberof Viewer\n * @instance\n * @returns {string} ID of current scene\n */\nthis.getScene = function() {\n    return config.scene;\n};\n\n/**\n * Add a new scene.\n * @memberof Viewer\n * @instance\n * @param {string} sceneId - The ID of the new scene\n * @param {string} config - The configuration of the new scene\n * @returns {Viewer} `this`\n */\nthis.addScene = function(sceneId, config) {\n    initialConfig.scenes[sceneId] = config;\n    return this;\n};\n\n/**\n * Remove a scene.\n * @memberof Viewer\n * @instance\n * @param {string} sceneId - The ID of the scene\n * @returns {boolean} False if the scene is the current scene or if the scene doesn't exists, else true\n */\nthis.removeScene = function(sceneId) {\n    if (config.scene === sceneId || !initialConfig.scenes.hasOwnProperty(sceneId))\n        return false;\n    delete initialConfig.scenes[sceneId];\n    return true;\n};\n\n/**\n * Toggle fullscreen.\n * @memberof Viewer\n * @instance\n * @returns {Viewer} `this`\n */\nthis.toggleFullscreen = function() {\n    toggleFullscreen();\n    return this;\n};\n\n/**\n * Get configuration of current scene.\n * @memberof Viewer\n * @instance\n * @returns {Object} Configuration of current scene\n */\nthis.getConfig = function() {\n    return config;\n};\n\n/**\n * Get viewer's container element.\n * @memberof Viewer\n * @instance\n * @returns {HTMLElement} Container `div` element\n */\nthis.getContainer = function() {\n    return container;\n};\n\n/**\n * Add a new hot spot.\n * @memberof Viewer\n * @instance\n * @param {Object} hs - The configuration for the hot spot\n * @param {string} [sceneId] - Adds hot spot to specified scene if provided, else to current scene\n * @returns {Viewer} `this`\n * @throws Throws an error if the scene ID is provided but invalid\n */\nthis.addHotSpot = function(hs, sceneId) {\n    if (sceneId === undefined && config.scene === undefined) {\n        // Not a tour\n        config.hotSpots.push(hs);\n    } else {\n        // Tour\n        var id = sceneId !== undefined ? sceneId : config.scene;\n        if (initialConfig.scenes.hasOwnProperty(id)) {\n            if (!initialConfig.scenes[id].hasOwnProperty('hotSpots')) {\n                initialConfig.scenes[id].hotSpots = []; // Create hot spots array if needed\n                if (id == config.scene)\n                    config.hotSpots = initialConfig.scenes[id].hotSpots;    // Link to current config\n            }\n            initialConfig.scenes[id].hotSpots.push(hs); // Add hot spot to config\n        } else {\n            throw 'Invalid scene ID!';\n        }\n    }\n    if (sceneId === undefined || config.scene == sceneId) {\n        // Add to current scene\n        createHotSpot(hs);\n        if (loaded)\n            renderHotSpot(hs);\n    }\n    return this;\n};\n\n/**\n * Remove a hot spot.\n * @memberof Viewer\n * @instance\n * @param {string} hotSpotId - The ID of the hot spot\n * @param {string} [sceneId] - Removes hot spot from specified scene if provided, else from current scene\n * @returns {boolean} True if deletion is successful, else false\n */\nthis.removeHotSpot = function(hotSpotId, sceneId) {\n    if (sceneId === undefined || config.scene == sceneId) {\n        if (!config.hotSpots)\n            return false;\n        for (var i = 0; i < config.hotSpots.length; i++) {\n            if (config.hotSpots[i].hasOwnProperty('id') &&\n                config.hotSpots[i].id === hotSpotId) {\n                // Delete hot spot DOM elements\n                var current = config.hotSpots[i].div;\n                while (current.parentNode != renderContainer)\n                    current = current.parentNode;\n                renderContainer.removeChild(current);\n                delete config.hotSpots[i].div;\n                // Remove hot spot from configuration\n                config.hotSpots.splice(i, 1);\n                return true;\n            }\n        }\n    } else {\n        if (initialConfig.scenes.hasOwnProperty(sceneId)) {\n            if (!initialConfig.scenes[sceneId].hasOwnProperty('hotSpots'))\n                return false;\n            for (var j = 0; j < initialConfig.scenes[sceneId].hotSpots.length; j++) {\n                if (initialConfig.scenes[sceneId].hotSpots[j].hasOwnProperty('id') &&\n                    initialConfig.scenes[sceneId].hotSpots[j].id === hotSpotId) {\n                    // Remove hot spot from configuration\n                    initialConfig.scenes[sceneId].hotSpots.splice(j, 1);\n                    return true;\n                }\n            }\n        } else {\n            return false;\n        }\n    }\n};\n\n/**\n * This method should be called if the viewer's container is resized.\n * @memberof Viewer\n * @instance\n */\nthis.resize = function() {\n    if (renderer)\n        onDocumentResize();\n};\n\n/**\n * Check if a panorama is loaded.\n * @memberof Viewer\n * @instance\n * @returns {boolean} True if a panorama is loaded, else false\n */\nthis.isLoaded = function() {\n    return loaded;\n};\n\n/**\n * Check if device orientation control is supported.\n * @memberof Viewer\n * @instance\n * @returns {boolean} True if supported, else false\n */\nthis.isOrientationSupported = function() {\n    return orientationSupport || false;\n};\n\n/**\n * Stop using device orientation.\n * @memberof Viewer\n * @instance\n */\nthis.stopOrientation = function() {\n    stopOrientation();\n};\n\n/**\n * Start using device orientation (does nothing if not supported).\n * @memberof Viewer\n * @instance\n */\nthis.startOrientation = function() {\n    if (orientationSupport)\n        startOrientation();\n};\n\n/**\n * Check if device orientation control is currently activated.\n * @memberof Viewer\n * @instance\n * @returns {boolean} True if active, else false\n */\nthis.isOrientationActive = function() {\n    return Boolean(orientation);\n};\n\n/**\n * Subscribe listener to specified event.\n * @memberof Viewer\n * @instance\n * @param {string} type - Type of event to subscribe to.\n * @param {Function} listener - Listener function to subscribe to event.\n * @returns {Viewer} `this`\n */\nthis.on = function(type, listener) {\n    externalEventListeners[type] = externalEventListeners[type] || [];\n    externalEventListeners[type].push(listener);\n    return this;\n};\n\n/**\n * Remove an event listener (or listeners).\n * @memberof Viewer\n * @param {string} [type] - Type of event to remove listeners from. If not specified, all listeners are removed.\n * @param {Function} [listener] - Listener function to remove. If not specified, all listeners of specified type are removed.\n * @returns {Viewer} `this`\n */\nthis.off = function(type, listener) {\n    if (!type) {\n        // Remove all listeners if type isn't specified\n        externalEventListeners = {};\n        return this;\n    }\n    if (listener) {\n        var i = externalEventListeners[type].indexOf(listener);\n        if (i >= 0) {\n            // Remove listener if found\n            externalEventListeners[type].splice(i, 1);\n        }\n        if (externalEventListeners[type].length == 0) {\n            // Remove category if empty\n            delete externalEventListeners[type];\n        }\n    } else {\n        // Remove category of listeners if listener isn't specified\n        delete externalEventListeners[type];\n    }\n    return this;\n};\n\n/**\n * Fire listeners attached to specified event.\n * @private\n * @param {string} [type] - Type of event to fire listeners for.\n */\nfunction fireEvent(type) {\n    if (type in externalEventListeners) {\n        // Reverse iteration is useful, if event listener is removed inside its definition\n        for (var i = externalEventListeners[type].length; i > 0; i--) {\n            externalEventListeners[type][externalEventListeners[type].length - i].apply(null, [].slice.call(arguments, 1));\n        }\n    }\n}\n\n/**\n * Destructor.\n * @instance\n * @memberof Viewer\n */\nthis.destroy = function() {\n    destroyed = true;\n    clearTimeout(autoRotateStart);\n\n    if (renderer)\n        renderer.destroy();\n    if (listenersAdded) {\n        document.removeEventListener('mousemove', onDocumentMouseMove, false);\n        document.removeEventListener('mouseup', onDocumentMouseUp, false);\n        container.removeEventListener('mozfullscreenchange', onFullScreenChange, false);\n        container.removeEventListener('webkitfullscreenchange', onFullScreenChange, false);\n        container.removeEventListener('msfullscreenchange', onFullScreenChange, false);\n        container.removeEventListener('fullscreenchange', onFullScreenChange, false);\n        window.removeEventListener('resize', onDocumentResize, false);\n        window.removeEventListener('orientationchange', onDocumentResize, false);\n        container.removeEventListener('keydown', onDocumentKeyPress, false);\n        container.removeEventListener('keyup', onDocumentKeyUp, false);\n        container.removeEventListener('blur', clearKeys, false);\n        document.removeEventListener('mouseleave', onDocumentMouseUp, false);\n    }\n    container.innerHTML = '';\n    container.classList.remove('pnlm-container');\n};\n\n}\n\nreturn {\n    viewer: function(container, config) {\n        return new Viewer(container, config);\n    }\n};\n\n})(window, document);\n"], "filenames": ["src/js/pannellum.js"], "buggy_code_start_loc": [1722], "buggy_code_end_loc": [2385], "fixing_code_start_loc": [1722], "fixing_code_end_loc": [2392], "type": "CWE-79", "message": "In Pannellum from 2.5.0 through 2.5.4 URLs were not sanitized for data URIs (or vbscript:), allowing for potential XSS attacks. Such an attack would require a user to click on a hot spot to execute and would require an attacker-provided configuration. The most plausible potential attack would be if pannellum.htm was hosted on a domain that shared cookies with the targeted site's user authentication; an &lt;iframe&gt; could then be embedded on the attacker's site using pannellum.htm from the targeted site, which would allow the attacker to potentially access information from the targeted site as the authenticated user (or worse if the targeted site did not have adequate CSRF protections) if the user clicked on a hot spot in the attacker's embedded panorama viewer. This was patched in version 2.5.5.", "other": {"cve": {"id": "CVE-2019-16763", "sourceIdentifier": "security-advisories@github.com", "published": "2019-11-22T19:15:12.560", "lastModified": "2019-12-04T17:20:46.237", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In Pannellum from 2.5.0 through 2.5.4 URLs were not sanitized for data URIs (or vbscript:), allowing for potential XSS attacks. Such an attack would require a user to click on a hot spot to execute and would require an attacker-provided configuration. The most plausible potential attack would be if pannellum.htm was hosted on a domain that shared cookies with the targeted site's user authentication; an &lt;iframe&gt; could then be embedded on the attacker's site using pannellum.htm from the targeted site, which would allow the attacker to potentially access information from the targeted site as the authenticated user (or worse if the targeted site did not have adequate CSRF protections) if the user clicked on a hot spot in the attacker's embedded panorama viewer. This was patched in version 2.5.5."}, {"lang": "es", "value": "En Pannellum versiones desde 2.5.0 hasta 2.5.4, las URL no fueron saneadas para URI de datos (o vbscript:), permitiendo posibles ataques de tipo XSS. Tal ataque requerir\u00eda que un usuario haga clic en un punto caliente para ejecutar y requerir\u00eda una configuraci\u00f3n proporcionada por el atacante. El ataque potencial m\u00e1s plausible ser\u00eda si el archivo pannellum.htm estuviera alojado en un dominio que compartiera cookies con la autenticaci\u00f3n de usuario del sitio objetivo; un &lt;iframe&gt; entonces podr\u00eda ser insertado en el sitio del atacante usando el archivo pannellum.htm del sitio objetivo, lo que permitir\u00eda al atacante acceder potencialmente a la informaci\u00f3n del sitio objetivo como usuario autenticado (o peor si el sitio objetivo no ten\u00eda protecciones CSRF adecuadas) si el usuario hizo clic en un punto caliente en el visor panor\u00e1mico insertado del atacante. Esto fue parcheado en la versi\u00f3n 2.5.5."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:H/UI:R/S:U/C:H/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "HIGH", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.5, "impactScore": 4.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pannellum:pannellum:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.5.0", "versionEndIncluding": "2.5.4", "matchCriteriaId": "AE5676BB-FE6A-453E-82B1-2DC3D537F77F"}]}]}], "references": [{"url": "https://github.com/mpetroff/pannellum/commit/cc2f3d99953de59db908e0c6efd1c2c17f7c6914", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/mpetroff/pannellum/security/advisories/GHSA-m52x-29pq-w3vv", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/mpetroff/pannellum/commit/cc2f3d99953de59db908e0c6efd1c2c17f7c6914"}}