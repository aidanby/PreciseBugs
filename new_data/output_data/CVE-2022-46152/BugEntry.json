{"buggy_code": ["// SPDX-License-Identifier: BSD-2-Clause\n/*\n * Copyright (c) 2015-2016, Linaro Limited\n * Copyright (c) 2014, STMicroelectronics International N.V.\n */\n\n#include <assert.h>\n#include <bench.h>\n#include <compiler.h>\n#include <initcall.h>\n#include <io.h>\n#include <kernel/linker.h>\n#include <kernel/msg_param.h>\n#include <kernel/notif.h>\n#include <kernel/panic.h>\n#include <kernel/tee_misc.h>\n#include <mm/core_memprot.h>\n#include <mm/core_mmu.h>\n#include <mm/mobj.h>\n#include <optee_msg.h>\n#include <string.h>\n#include <tee/entry_std.h>\n#include <tee/tee_cryp_utl.h>\n#include <tee/uuid.h>\n#include <util.h>\n\n#define SHM_CACHE_ATTRS\t\\\n\t(uint32_t)(core_mmu_is_shm_cached() ? \\\n\t\t   TEE_MATTR_MEM_TYPE_CACHED : TEE_MATTR_MEM_TYPE_DEV)\n\n/* Sessions opened from normal world */\nstatic struct tee_ta_session_head tee_open_sessions =\nTAILQ_HEAD_INITIALIZER(tee_open_sessions);\n\n#ifdef CFG_CORE_RESERVED_SHM\nstatic struct mobj *shm_mobj;\n#endif\n#ifdef CFG_SECURE_DATA_PATH\nstatic struct mobj **sdp_mem_mobjs;\n#endif\n\nstatic unsigned int session_pnum;\n\nstatic bool __maybe_unused param_mem_from_mobj(struct param_mem *mem,\n\t\t\t\t\t       struct mobj *mobj,\n\t\t\t\t\t       const paddr_t pa,\n\t\t\t\t\t       const size_t sz)\n{\n\tpaddr_t b;\n\n\tif (mobj_get_pa(mobj, 0, 0, &b) != TEE_SUCCESS)\n\t\tpanic(\"mobj_get_pa failed\");\n\n\tif (!core_is_buffer_inside(pa, MAX(sz, 1UL), b, mobj->size))\n\t\treturn false;\n\n\tmem->mobj = mobj_get(mobj);\n\tmem->offs = pa - b;\n\tmem->size = sz;\n\treturn true;\n}\n\n#ifdef CFG_CORE_FFA\nstatic TEE_Result set_fmem_param(const struct optee_msg_param_fmem *fmem,\n\t\t\t\t struct param_mem *mem)\n{\n\tsize_t req_size = 0;\n\tuint64_t global_id = READ_ONCE(fmem->global_id);\n\tsize_t sz = READ_ONCE(fmem->size);\n\n\tif (global_id == OPTEE_MSG_FMEM_INVALID_GLOBAL_ID && !sz) {\n\t\tmem->mobj = NULL;\n\t\tmem->offs = 0;\n\t\tmem->size = 0;\n\t\treturn TEE_SUCCESS;\n\t}\n\tmem->mobj = mobj_ffa_get_by_cookie(global_id,\n\t\t\t\t\t   READ_ONCE(fmem->internal_offs));\n\tif (!mem->mobj)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tmem->offs = reg_pair_to_64(READ_ONCE(fmem->offs_high),\n\t\t\t\t   READ_ONCE(fmem->offs_low));\n\tmem->size = sz;\n\n\t/*\n\t * Check that the supplied offset and size is covered by the\n\t * previously verified MOBJ.\n\t */\n\tif (ADD_OVERFLOW(mem->offs, mem->size, &req_size) ||\n\t    mem->mobj->size < req_size)\n\t\treturn TEE_ERROR_SECURITY;\n\n\treturn TEE_SUCCESS;\n}\n#else /*!CFG_CORE_FFA*/\n/* fill 'struct param_mem' structure if buffer matches a valid memory object */\nstatic TEE_Result set_tmem_param(const struct optee_msg_param_tmem *tmem,\n\t\t\t\t uint32_t attr, struct param_mem *mem)\n{\n\tstruct mobj __maybe_unused **mobj;\n\tpaddr_t pa = READ_ONCE(tmem->buf_ptr);\n\tsize_t sz = READ_ONCE(tmem->size);\n\n\t/*\n\t * Handle NULL memory reference\n\t */\n\tif (!pa) {\n\t\tmem->mobj = NULL;\n\t\tmem->offs = 0;\n\t\tmem->size = 0;\n\t\treturn TEE_SUCCESS;\n\t}\n\n\t/* Handle non-contiguous reference from a shared memory area */\n\tif (attr & OPTEE_MSG_ATTR_NONCONTIG) {\n\t\tuint64_t shm_ref = READ_ONCE(tmem->shm_ref);\n\n\t\tmem->mobj = msg_param_mobj_from_noncontig(pa, sz, shm_ref,\n\t\t\t\t\t\t\t  false);\n\t\tif (!mem->mobj)\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\tmem->offs = 0;\n\t\tmem->size = sz;\n\t\treturn TEE_SUCCESS;\n\t}\n\n#ifdef CFG_CORE_RESERVED_SHM\n\t/* Handle memory reference in the contiguous shared memory */\n\tif (param_mem_from_mobj(mem, shm_mobj, pa, sz))\n\t\treturn TEE_SUCCESS;\n#endif\n\n#ifdef CFG_SECURE_DATA_PATH\n\t/* Handle memory reference to Secure Data Path memory areas */\n\tfor (mobj = sdp_mem_mobjs; *mobj; mobj++)\n\t\tif (param_mem_from_mobj(mem, *mobj, pa, sz))\n\t\t\treturn TEE_SUCCESS;\n#endif\n\n\treturn TEE_ERROR_BAD_PARAMETERS;\n}\n\n#ifdef CFG_CORE_DYN_SHM\nstatic TEE_Result set_rmem_param(const struct optee_msg_param_rmem *rmem,\n\t\t\t\t struct param_mem *mem)\n{\n\tsize_t req_size = 0;\n\tuint64_t shm_ref = READ_ONCE(rmem->shm_ref);\n\tsize_t sz = READ_ONCE(rmem->size);\n\n\tmem->mobj = mobj_reg_shm_get_by_cookie(shm_ref);\n\tif (!mem->mobj)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tmem->offs = READ_ONCE(rmem->offs);\n\tmem->size = sz;\n\n\t/*\n\t * Check that the supplied offset and size is covered by the\n\t * previously verified MOBJ.\n\t */\n\tif (ADD_OVERFLOW(mem->offs, mem->size, &req_size) ||\n\t    mem->mobj->size < req_size)\n\t\treturn TEE_ERROR_SECURITY;\n\n\treturn TEE_SUCCESS;\n}\n#endif /*CFG_CORE_DYN_SHM*/\n#endif /*!CFG_CORE_FFA*/\n\nstatic TEE_Result copy_in_params(const struct optee_msg_param *params,\n\t\t\t\t uint32_t num_params,\n\t\t\t\t struct tee_ta_param *ta_param,\n\t\t\t\t uint64_t *saved_attr)\n{\n\tTEE_Result res;\n\tsize_t n;\n\tuint8_t pt[TEE_NUM_PARAMS] = { 0 };\n\n\tif (num_params > TEE_NUM_PARAMS)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tmemset(ta_param, 0, sizeof(*ta_param));\n\n\tfor (n = 0; n < num_params; n++) {\n\t\tuint32_t attr;\n\n\t\tsaved_attr[n] = READ_ONCE(params[n].attr);\n\n\t\tif (saved_attr[n] & OPTEE_MSG_ATTR_META)\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\t\tattr = saved_attr[n] & OPTEE_MSG_ATTR_TYPE_MASK;\n\t\tswitch (attr) {\n\t\tcase OPTEE_MSG_ATTR_TYPE_NONE:\n\t\t\tpt[n] = TEE_PARAM_TYPE_NONE;\n\t\t\tbreak;\n\t\tcase OPTEE_MSG_ATTR_TYPE_VALUE_INPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_VALUE_OUTPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_VALUE_INOUT:\n\t\t\tpt[n] = TEE_PARAM_TYPE_VALUE_INPUT + attr -\n\t\t\t\tOPTEE_MSG_ATTR_TYPE_VALUE_INPUT;\n\t\t\tta_param->u[n].val.a = READ_ONCE(params[n].u.value.a);\n\t\t\tta_param->u[n].val.b = READ_ONCE(params[n].u.value.b);\n\t\t\tbreak;\n#ifdef CFG_CORE_FFA\n\t\tcase OPTEE_MSG_ATTR_TYPE_FMEM_INPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_FMEM_OUTPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_FMEM_INOUT:\n\t\t\tres = set_fmem_param(&params[n].u.fmem,\n\t\t\t\t\t     &ta_param->u[n].mem);\n\t\t\tif (res)\n\t\t\t\treturn res;\n\t\t\tpt[n] = TEE_PARAM_TYPE_MEMREF_INPUT + attr -\n\t\t\t\tOPTEE_MSG_ATTR_TYPE_FMEM_INPUT;\n\t\t\tbreak;\n#else /*!CFG_CORE_FFA*/\n\t\tcase OPTEE_MSG_ATTR_TYPE_TMEM_INPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_TMEM_OUTPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_TMEM_INOUT:\n\t\t\tres = set_tmem_param(&params[n].u.tmem, saved_attr[n],\n\t\t\t\t\t     &ta_param->u[n].mem);\n\t\t\tif (res)\n\t\t\t\treturn res;\n\t\t\tpt[n] = TEE_PARAM_TYPE_MEMREF_INPUT + attr -\n\t\t\t\tOPTEE_MSG_ATTR_TYPE_TMEM_INPUT;\n\t\t\tbreak;\n#ifdef CFG_CORE_DYN_SHM\n\t\tcase OPTEE_MSG_ATTR_TYPE_RMEM_INPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_RMEM_OUTPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_RMEM_INOUT:\n\t\t\tres = set_rmem_param(&params[n].u.rmem,\n\t\t\t\t\t     &ta_param->u[n].mem);\n\t\t\tif (res)\n\t\t\t\treturn res;\n\t\t\tpt[n] = TEE_PARAM_TYPE_MEMREF_INPUT + attr -\n\t\t\t\tOPTEE_MSG_ATTR_TYPE_RMEM_INPUT;\n\t\t\tbreak;\n#endif /*CFG_CORE_DYN_SHM*/\n#endif /*!CFG_CORE_FFA*/\n\t\tdefault:\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\t}\n\t}\n\n\tta_param->types = TEE_PARAM_TYPES(pt[0], pt[1], pt[2], pt[3]);\n\n\treturn TEE_SUCCESS;\n}\n\nstatic void cleanup_shm_refs(const uint64_t *saved_attr,\n\t\t\t     struct tee_ta_param *param, uint32_t num_params)\n{\n\tsize_t n;\n\n\tfor (n = 0; n < num_params; n++) {\n\t\tswitch (saved_attr[n]) {\n\t\tcase OPTEE_MSG_ATTR_TYPE_TMEM_INPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_TMEM_OUTPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_TMEM_INOUT:\n#ifdef CFG_CORE_DYN_SHM\n\t\tcase OPTEE_MSG_ATTR_TYPE_RMEM_INPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_RMEM_OUTPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_RMEM_INOUT:\n#endif\n\t\t\tmobj_put(param->u[n].mem.mobj);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void copy_out_param(struct tee_ta_param *ta_param, uint32_t num_params,\n\t\t\t   struct optee_msg_param *params, uint64_t *saved_attr)\n{\n\tsize_t n;\n\n\tfor (n = 0; n < num_params; n++) {\n\t\tswitch (TEE_PARAM_TYPE_GET(ta_param->types, n)) {\n\t\tcase TEE_PARAM_TYPE_MEMREF_OUTPUT:\n\t\tcase TEE_PARAM_TYPE_MEMREF_INOUT:\n\t\t\tswitch (saved_attr[n] & OPTEE_MSG_ATTR_TYPE_MASK) {\n\t\t\tcase OPTEE_MSG_ATTR_TYPE_TMEM_OUTPUT:\n\t\t\tcase OPTEE_MSG_ATTR_TYPE_TMEM_INOUT:\n\t\t\t\tparams[n].u.tmem.size = ta_param->u[n].mem.size;\n\t\t\t\tbreak;\n\t\t\tcase OPTEE_MSG_ATTR_TYPE_RMEM_OUTPUT:\n\t\t\tcase OPTEE_MSG_ATTR_TYPE_RMEM_INOUT:\n\t\t\t\tparams[n].u.rmem.size = ta_param->u[n].mem.size;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TEE_PARAM_TYPE_VALUE_OUTPUT:\n\t\tcase TEE_PARAM_TYPE_VALUE_INOUT:\n\t\t\tparams[n].u.value.a = ta_param->u[n].val.a;\n\t\t\tparams[n].u.value.b = ta_param->u[n].val.b;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/*\n * Extracts mandatory parameter for open session.\n *\n * Returns\n * false : mandatory parameter wasn't found or malformatted\n * true  : paramater found and OK\n */\nstatic TEE_Result get_open_session_meta(size_t num_params,\n\t\t\t\t\tstruct optee_msg_param *params,\n\t\t\t\t\tsize_t *num_meta, TEE_UUID *uuid,\n\t\t\t\t\tTEE_Identity *clnt_id)\n{\n\tconst uint32_t req_attr = OPTEE_MSG_ATTR_META |\n\t\t\t\t  OPTEE_MSG_ATTR_TYPE_VALUE_INPUT;\n\n\tif (num_params < 2)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tif (params[0].attr != req_attr || params[1].attr != req_attr)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\ttee_uuid_from_octets(uuid, (void *)&params[0].u.value);\n\tclnt_id->login = params[1].u.value.c;\n\tswitch (clnt_id->login) {\n\tcase TEE_LOGIN_PUBLIC:\n\tcase TEE_LOGIN_REE_KERNEL:\n\t\tmemset(&clnt_id->uuid, 0, sizeof(clnt_id->uuid));\n\t\tbreak;\n\tcase TEE_LOGIN_USER:\n\tcase TEE_LOGIN_GROUP:\n\tcase TEE_LOGIN_APPLICATION:\n\tcase TEE_LOGIN_APPLICATION_USER:\n\tcase TEE_LOGIN_APPLICATION_GROUP:\n\t\ttee_uuid_from_octets(&clnt_id->uuid,\n\t\t\t\t     (void *)&params[1].u.value);\n\t\tbreak;\n\tdefault:\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\n\n\t*num_meta = 2;\n\treturn TEE_SUCCESS;\n}\n\nstatic void entry_open_session(struct optee_msg_arg *arg, uint32_t num_params)\n{\n\tTEE_Result res;\n\tTEE_ErrorOrigin err_orig = TEE_ORIGIN_TEE;\n\tstruct tee_ta_session *s = NULL;\n\tTEE_Identity clnt_id;\n\tTEE_UUID uuid;\n\tstruct tee_ta_param param;\n\tsize_t num_meta;\n\tuint64_t saved_attr[TEE_NUM_PARAMS] = { 0 };\n\n\tres = get_open_session_meta(num_params, arg->params, &num_meta, &uuid,\n\t\t\t\t    &clnt_id);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = copy_in_params(arg->params + num_meta, num_params - num_meta,\n\t\t\t     &param, saved_attr);\n\tif (res != TEE_SUCCESS)\n\t\tgoto cleanup_shm_refs;\n\n\tres = tee_ta_open_session(&err_orig, &s, &tee_open_sessions, &uuid,\n\t\t\t\t  &clnt_id, TEE_TIMEOUT_INFINITE, &param);\n\tif (res != TEE_SUCCESS)\n\t\ts = NULL;\n\tcopy_out_param(&param, num_params - num_meta, arg->params + num_meta,\n\t\t       saved_attr);\n\n\t/*\n\t * The occurrence of open/close session command is usually\n\t * un-predictable, using this property to increase randomness\n\t * of prng\n\t */\n\tplat_prng_add_jitter_entropy(CRYPTO_RNG_SRC_JITTER_SESSION,\n\t\t\t\t     &session_pnum);\n\ncleanup_shm_refs:\n\tcleanup_shm_refs(saved_attr, &param, num_params - num_meta);\n\nout:\n\tif (s)\n\t\targ->session = s->id;\n\telse\n\t\targ->session = 0;\n\targ->ret = res;\n\targ->ret_origin = err_orig;\n}\n\nstatic void entry_close_session(struct optee_msg_arg *arg, uint32_t num_params)\n{\n\tTEE_Result res;\n\tstruct tee_ta_session *s;\n\n\tif (num_params) {\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto out;\n\t}\n\n\tplat_prng_add_jitter_entropy(CRYPTO_RNG_SRC_JITTER_SESSION,\n\t\t\t\t     &session_pnum);\n\n\ts = tee_ta_find_session(arg->session, &tee_open_sessions);\n\tres = tee_ta_close_session(s, &tee_open_sessions, NSAPP_IDENTITY);\nout:\n\targ->ret = res;\n\targ->ret_origin = TEE_ORIGIN_TEE;\n}\n\nstatic void entry_invoke_command(struct optee_msg_arg *arg, uint32_t num_params)\n{\n\tTEE_Result res;\n\tTEE_ErrorOrigin err_orig = TEE_ORIGIN_TEE;\n\tstruct tee_ta_session *s;\n\tstruct tee_ta_param param = { 0 };\n\tuint64_t saved_attr[TEE_NUM_PARAMS] = { 0 };\n\n\tbm_timestamp();\n\n\tres = copy_in_params(arg->params, num_params, &param, saved_attr);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\ts = tee_ta_get_session(arg->session, true, &tee_open_sessions);\n\tif (!s) {\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto out;\n\t}\n\n\tres = tee_ta_invoke_command(&err_orig, s, NSAPP_IDENTITY,\n\t\t\t\t    TEE_TIMEOUT_INFINITE, arg->func, &param);\n\n\tbm_timestamp();\n\n\ttee_ta_put_session(s);\n\n\tcopy_out_param(&param, num_params, arg->params, saved_attr);\n\nout:\n\tcleanup_shm_refs(saved_attr, &param, num_params);\n\n\targ->ret = res;\n\targ->ret_origin = err_orig;\n}\n\nstatic void entry_cancel(struct optee_msg_arg *arg, uint32_t num_params)\n{\n\tTEE_Result res;\n\tTEE_ErrorOrigin err_orig = TEE_ORIGIN_TEE;\n\tstruct tee_ta_session *s;\n\n\tif (num_params) {\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto out;\n\t}\n\n\ts = tee_ta_get_session(arg->session, false, &tee_open_sessions);\n\tif (!s) {\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto out;\n\t}\n\n\tres = tee_ta_cancel_command(&err_orig, s, NSAPP_IDENTITY);\n\ttee_ta_put_session(s);\n\nout:\n\targ->ret = res;\n\targ->ret_origin = err_orig;\n}\n\n#ifndef CFG_CORE_FFA\n#ifdef CFG_CORE_DYN_SHM\nstatic void register_shm(struct optee_msg_arg *arg, uint32_t num_params)\n{\n\tstruct optee_msg_param_tmem *tmem = NULL;\n\tstruct mobj *mobj = NULL;\n\n\targ->ret = TEE_ERROR_BAD_PARAMETERS;\n\n\tif (num_params != 1 ||\n\t    (arg->params[0].attr !=\n\t     (OPTEE_MSG_ATTR_TYPE_TMEM_OUTPUT | OPTEE_MSG_ATTR_NONCONTIG)))\n\t\treturn;\n\n\ttmem = &arg->params[0].u.tmem;\n\tmobj = msg_param_mobj_from_noncontig(tmem->buf_ptr, tmem->size,\n\t\t\t\t\t     tmem->shm_ref, false);\n\n\tif (!mobj)\n\t\treturn;\n\n\tmobj_reg_shm_unguard(mobj);\n\targ->ret = TEE_SUCCESS;\n}\n\nstatic void unregister_shm(struct optee_msg_arg *arg, uint32_t num_params)\n{\n\tif (num_params == 1) {\n\t\tuint64_t cookie = arg->params[0].u.rmem.shm_ref;\n\t\tTEE_Result res = mobj_reg_shm_release_by_cookie(cookie);\n\n\t\tif (res)\n\t\t\tEMSG(\"Can't find mapping with given cookie\");\n\t\targ->ret = res;\n\t} else {\n\t\targ->ret = TEE_ERROR_BAD_PARAMETERS;\n\t\targ->ret_origin = TEE_ORIGIN_TEE;\n\t}\n}\n#endif /*CFG_CORE_DYN_SHM*/\n#endif\n\nvoid nsec_sessions_list_head(struct tee_ta_session_head **open_sessions)\n{\n\t*open_sessions = &tee_open_sessions;\n}\n\n/* Note: this function is weak to let platforms add special handling */\nTEE_Result __weak tee_entry_std(struct optee_msg_arg *arg, uint32_t num_params)\n{\n\treturn __tee_entry_std(arg, num_params);\n}\n\n/*\n * If tee_entry_std() is overridden, it's still supposed to call this\n * function.\n */\nTEE_Result __tee_entry_std(struct optee_msg_arg *arg, uint32_t num_params)\n{\n\tTEE_Result res = TEE_SUCCESS;\n\n\t/* Enable foreign interrupts for STD calls */\n\tthread_set_foreign_intr(true);\n\tswitch (arg->cmd) {\n\tcase OPTEE_MSG_CMD_OPEN_SESSION:\n\t\tentry_open_session(arg, num_params);\n\t\tbreak;\n\tcase OPTEE_MSG_CMD_CLOSE_SESSION:\n\t\tentry_close_session(arg, num_params);\n\t\tbreak;\n\tcase OPTEE_MSG_CMD_INVOKE_COMMAND:\n\t\tentry_invoke_command(arg, num_params);\n\t\tbreak;\n\tcase OPTEE_MSG_CMD_CANCEL:\n\t\tentry_cancel(arg, num_params);\n\t\tbreak;\n#ifndef CFG_CORE_FFA\n#ifdef CFG_CORE_DYN_SHM\n\tcase OPTEE_MSG_CMD_REGISTER_SHM:\n\t\tregister_shm(arg, num_params);\n\t\tbreak;\n\tcase OPTEE_MSG_CMD_UNREGISTER_SHM:\n\t\tunregister_shm(arg, num_params);\n\t\tbreak;\n#endif\n#endif\n\n\tcase OPTEE_MSG_CMD_DO_BOTTOM_HALF:\n\t\tif (IS_ENABLED(CFG_CORE_ASYNC_NOTIF))\n\t\t\tnotif_deliver_event(NOTIF_EVENT_DO_BOTTOM_HALF);\n\t\telse\n\t\t\tgoto err;\n\t\tbreak;\n\tcase OPTEE_MSG_CMD_STOP_ASYNC_NOTIF:\n\t\tif (IS_ENABLED(CFG_CORE_ASYNC_NOTIF))\n\t\t\tnotif_deliver_event(NOTIF_EVENT_STOPPED);\n\t\telse\n\t\t\tgoto err;\n\t\tbreak;\n\n\tdefault:\nerr:\n\t\tEMSG(\"Unknown cmd 0x%x\", arg->cmd);\n\t\tres = TEE_ERROR_NOT_IMPLEMENTED;\n\t}\n\n\treturn res;\n}\n\nstatic TEE_Result default_mobj_init(void)\n{\n#ifdef CFG_CORE_RESERVED_SHM\n\tshm_mobj = mobj_phys_alloc(default_nsec_shm_paddr,\n\t\t\t\t   default_nsec_shm_size, SHM_CACHE_ATTRS,\n\t\t\t\t   CORE_MEM_NSEC_SHM);\n\tif (!shm_mobj)\n\t\tpanic(\"Failed to register shared memory\");\n#endif\n\n#ifdef CFG_SECURE_DATA_PATH\n\tsdp_mem_mobjs = core_sdp_mem_create_mobjs();\n\tif (!sdp_mem_mobjs)\n\t\tpanic(\"Failed to register SDP memory\");\n#endif\n\n\treturn TEE_SUCCESS;\n}\n\ndriver_init_late(default_mobj_init);\n"], "fixing_code": ["// SPDX-License-Identifier: BSD-2-Clause\n/*\n * Copyright (c) 2015-2016, Linaro Limited\n * Copyright (c) 2014, STMicroelectronics International N.V.\n */\n\n#include <assert.h>\n#include <bench.h>\n#include <compiler.h>\n#include <initcall.h>\n#include <io.h>\n#include <kernel/linker.h>\n#include <kernel/msg_param.h>\n#include <kernel/notif.h>\n#include <kernel/panic.h>\n#include <kernel/tee_misc.h>\n#include <mm/core_memprot.h>\n#include <mm/core_mmu.h>\n#include <mm/mobj.h>\n#include <optee_msg.h>\n#include <string.h>\n#include <tee/entry_std.h>\n#include <tee/tee_cryp_utl.h>\n#include <tee/uuid.h>\n#include <util.h>\n\n#define SHM_CACHE_ATTRS\t\\\n\t(uint32_t)(core_mmu_is_shm_cached() ? \\\n\t\t   TEE_MATTR_MEM_TYPE_CACHED : TEE_MATTR_MEM_TYPE_DEV)\n\n/* Sessions opened from normal world */\nstatic struct tee_ta_session_head tee_open_sessions =\nTAILQ_HEAD_INITIALIZER(tee_open_sessions);\n\n#ifdef CFG_CORE_RESERVED_SHM\nstatic struct mobj *shm_mobj;\n#endif\n#ifdef CFG_SECURE_DATA_PATH\nstatic struct mobj **sdp_mem_mobjs;\n#endif\n\nstatic unsigned int session_pnum;\n\nstatic bool __maybe_unused param_mem_from_mobj(struct param_mem *mem,\n\t\t\t\t\t       struct mobj *mobj,\n\t\t\t\t\t       const paddr_t pa,\n\t\t\t\t\t       const size_t sz)\n{\n\tpaddr_t b;\n\n\tif (mobj_get_pa(mobj, 0, 0, &b) != TEE_SUCCESS)\n\t\tpanic(\"mobj_get_pa failed\");\n\n\tif (!core_is_buffer_inside(pa, MAX(sz, 1UL), b, mobj->size))\n\t\treturn false;\n\n\tmem->mobj = mobj_get(mobj);\n\tmem->offs = pa - b;\n\tmem->size = sz;\n\treturn true;\n}\n\n#ifdef CFG_CORE_FFA\nstatic TEE_Result set_fmem_param(const struct optee_msg_param_fmem *fmem,\n\t\t\t\t struct param_mem *mem)\n{\n\tsize_t req_size = 0;\n\tuint64_t global_id = READ_ONCE(fmem->global_id);\n\tsize_t sz = READ_ONCE(fmem->size);\n\n\tif (global_id == OPTEE_MSG_FMEM_INVALID_GLOBAL_ID && !sz) {\n\t\tmem->mobj = NULL;\n\t\tmem->offs = 0;\n\t\tmem->size = 0;\n\t\treturn TEE_SUCCESS;\n\t}\n\tmem->mobj = mobj_ffa_get_by_cookie(global_id,\n\t\t\t\t\t   READ_ONCE(fmem->internal_offs));\n\tif (!mem->mobj)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tmem->offs = reg_pair_to_64(READ_ONCE(fmem->offs_high),\n\t\t\t\t   READ_ONCE(fmem->offs_low));\n\tmem->size = sz;\n\n\t/*\n\t * Check that the supplied offset and size is covered by the\n\t * previously verified MOBJ.\n\t */\n\tif (ADD_OVERFLOW(mem->offs, mem->size, &req_size) ||\n\t    mem->mobj->size < req_size)\n\t\treturn TEE_ERROR_SECURITY;\n\n\treturn TEE_SUCCESS;\n}\n#else /*!CFG_CORE_FFA*/\n/* fill 'struct param_mem' structure if buffer matches a valid memory object */\nstatic TEE_Result set_tmem_param(const struct optee_msg_param_tmem *tmem,\n\t\t\t\t uint32_t attr, struct param_mem *mem)\n{\n\tstruct mobj __maybe_unused **mobj;\n\tpaddr_t pa = READ_ONCE(tmem->buf_ptr);\n\tsize_t sz = READ_ONCE(tmem->size);\n\n\t/*\n\t * Handle NULL memory reference\n\t */\n\tif (!pa) {\n\t\tmem->mobj = NULL;\n\t\tmem->offs = 0;\n\t\tmem->size = 0;\n\t\treturn TEE_SUCCESS;\n\t}\n\n\t/* Handle non-contiguous reference from a shared memory area */\n\tif (attr & OPTEE_MSG_ATTR_NONCONTIG) {\n\t\tuint64_t shm_ref = READ_ONCE(tmem->shm_ref);\n\n\t\tmem->mobj = msg_param_mobj_from_noncontig(pa, sz, shm_ref,\n\t\t\t\t\t\t\t  false);\n\t\tif (!mem->mobj)\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\tmem->offs = 0;\n\t\tmem->size = sz;\n\t\treturn TEE_SUCCESS;\n\t}\n\n#ifdef CFG_CORE_RESERVED_SHM\n\t/* Handle memory reference in the contiguous shared memory */\n\tif (param_mem_from_mobj(mem, shm_mobj, pa, sz))\n\t\treturn TEE_SUCCESS;\n#endif\n\n#ifdef CFG_SECURE_DATA_PATH\n\t/* Handle memory reference to Secure Data Path memory areas */\n\tfor (mobj = sdp_mem_mobjs; *mobj; mobj++)\n\t\tif (param_mem_from_mobj(mem, *mobj, pa, sz))\n\t\t\treturn TEE_SUCCESS;\n#endif\n\n\treturn TEE_ERROR_BAD_PARAMETERS;\n}\n\n#ifdef CFG_CORE_DYN_SHM\nstatic TEE_Result set_rmem_param(const struct optee_msg_param_rmem *rmem,\n\t\t\t\t struct param_mem *mem)\n{\n\tsize_t req_size = 0;\n\tuint64_t shm_ref = READ_ONCE(rmem->shm_ref);\n\tsize_t sz = READ_ONCE(rmem->size);\n\n\tmem->mobj = mobj_reg_shm_get_by_cookie(shm_ref);\n\tif (!mem->mobj)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tmem->offs = READ_ONCE(rmem->offs);\n\tmem->size = sz;\n\n\t/*\n\t * Check that the supplied offset and size is covered by the\n\t * previously verified MOBJ.\n\t */\n\tif (ADD_OVERFLOW(mem->offs, mem->size, &req_size) ||\n\t    mem->mobj->size < req_size)\n\t\treturn TEE_ERROR_SECURITY;\n\n\treturn TEE_SUCCESS;\n}\n#endif /*CFG_CORE_DYN_SHM*/\n#endif /*!CFG_CORE_FFA*/\n\nstatic TEE_Result copy_in_params(const struct optee_msg_param *params,\n\t\t\t\t uint32_t num_params,\n\t\t\t\t struct tee_ta_param *ta_param,\n\t\t\t\t uint64_t *saved_attr)\n{\n\tTEE_Result res;\n\tsize_t n;\n\tuint8_t pt[TEE_NUM_PARAMS] = { 0 };\n\n\tif (num_params > TEE_NUM_PARAMS)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tmemset(ta_param, 0, sizeof(*ta_param));\n\n\tfor (n = 0; n < num_params; n++) {\n\t\tuint32_t attr;\n\n\t\tsaved_attr[n] = READ_ONCE(params[n].attr);\n\n\t\tif (saved_attr[n] & OPTEE_MSG_ATTR_META)\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\t\tattr = saved_attr[n] & OPTEE_MSG_ATTR_TYPE_MASK;\n\t\tswitch (attr) {\n\t\tcase OPTEE_MSG_ATTR_TYPE_NONE:\n\t\t\tpt[n] = TEE_PARAM_TYPE_NONE;\n\t\t\tbreak;\n\t\tcase OPTEE_MSG_ATTR_TYPE_VALUE_INPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_VALUE_OUTPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_VALUE_INOUT:\n\t\t\tpt[n] = TEE_PARAM_TYPE_VALUE_INPUT + attr -\n\t\t\t\tOPTEE_MSG_ATTR_TYPE_VALUE_INPUT;\n\t\t\tta_param->u[n].val.a = READ_ONCE(params[n].u.value.a);\n\t\t\tta_param->u[n].val.b = READ_ONCE(params[n].u.value.b);\n\t\t\tbreak;\n#ifdef CFG_CORE_FFA\n\t\tcase OPTEE_MSG_ATTR_TYPE_FMEM_INPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_FMEM_OUTPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_FMEM_INOUT:\n\t\t\tres = set_fmem_param(&params[n].u.fmem,\n\t\t\t\t\t     &ta_param->u[n].mem);\n\t\t\tif (res)\n\t\t\t\treturn res;\n\t\t\tpt[n] = TEE_PARAM_TYPE_MEMREF_INPUT + attr -\n\t\t\t\tOPTEE_MSG_ATTR_TYPE_FMEM_INPUT;\n\t\t\tbreak;\n#else /*!CFG_CORE_FFA*/\n\t\tcase OPTEE_MSG_ATTR_TYPE_TMEM_INPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_TMEM_OUTPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_TMEM_INOUT:\n\t\t\tres = set_tmem_param(&params[n].u.tmem, saved_attr[n],\n\t\t\t\t\t     &ta_param->u[n].mem);\n\t\t\tif (res)\n\t\t\t\treturn res;\n\t\t\tpt[n] = TEE_PARAM_TYPE_MEMREF_INPUT + attr -\n\t\t\t\tOPTEE_MSG_ATTR_TYPE_TMEM_INPUT;\n\t\t\tbreak;\n#ifdef CFG_CORE_DYN_SHM\n\t\tcase OPTEE_MSG_ATTR_TYPE_RMEM_INPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_RMEM_OUTPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_RMEM_INOUT:\n\t\t\tres = set_rmem_param(&params[n].u.rmem,\n\t\t\t\t\t     &ta_param->u[n].mem);\n\t\t\tif (res)\n\t\t\t\treturn res;\n\t\t\tpt[n] = TEE_PARAM_TYPE_MEMREF_INPUT + attr -\n\t\t\t\tOPTEE_MSG_ATTR_TYPE_RMEM_INPUT;\n\t\t\tbreak;\n#endif /*CFG_CORE_DYN_SHM*/\n#endif /*!CFG_CORE_FFA*/\n\t\tdefault:\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\t}\n\t}\n\n\tta_param->types = TEE_PARAM_TYPES(pt[0], pt[1], pt[2], pt[3]);\n\n\treturn TEE_SUCCESS;\n}\n\nstatic void cleanup_shm_refs(const uint64_t *saved_attr,\n\t\t\t     struct tee_ta_param *param, uint32_t num_params)\n{\n\tsize_t n;\n\n\tfor (n = 0; n < MIN((unsigned int)TEE_NUM_PARAMS, num_params); n++) {\n\t\tswitch (saved_attr[n]) {\n\t\tcase OPTEE_MSG_ATTR_TYPE_TMEM_INPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_TMEM_OUTPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_TMEM_INOUT:\n#ifdef CFG_CORE_DYN_SHM\n\t\tcase OPTEE_MSG_ATTR_TYPE_RMEM_INPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_RMEM_OUTPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_RMEM_INOUT:\n#endif\n\t\t\tmobj_put(param->u[n].mem.mobj);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void copy_out_param(struct tee_ta_param *ta_param, uint32_t num_params,\n\t\t\t   struct optee_msg_param *params, uint64_t *saved_attr)\n{\n\tsize_t n;\n\n\tfor (n = 0; n < num_params; n++) {\n\t\tswitch (TEE_PARAM_TYPE_GET(ta_param->types, n)) {\n\t\tcase TEE_PARAM_TYPE_MEMREF_OUTPUT:\n\t\tcase TEE_PARAM_TYPE_MEMREF_INOUT:\n\t\t\tswitch (saved_attr[n] & OPTEE_MSG_ATTR_TYPE_MASK) {\n\t\t\tcase OPTEE_MSG_ATTR_TYPE_TMEM_OUTPUT:\n\t\t\tcase OPTEE_MSG_ATTR_TYPE_TMEM_INOUT:\n\t\t\t\tparams[n].u.tmem.size = ta_param->u[n].mem.size;\n\t\t\t\tbreak;\n\t\t\tcase OPTEE_MSG_ATTR_TYPE_RMEM_OUTPUT:\n\t\t\tcase OPTEE_MSG_ATTR_TYPE_RMEM_INOUT:\n\t\t\t\tparams[n].u.rmem.size = ta_param->u[n].mem.size;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TEE_PARAM_TYPE_VALUE_OUTPUT:\n\t\tcase TEE_PARAM_TYPE_VALUE_INOUT:\n\t\t\tparams[n].u.value.a = ta_param->u[n].val.a;\n\t\t\tparams[n].u.value.b = ta_param->u[n].val.b;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/*\n * Extracts mandatory parameter for open session.\n *\n * Returns\n * false : mandatory parameter wasn't found or malformatted\n * true  : paramater found and OK\n */\nstatic TEE_Result get_open_session_meta(size_t num_params,\n\t\t\t\t\tstruct optee_msg_param *params,\n\t\t\t\t\tsize_t *num_meta, TEE_UUID *uuid,\n\t\t\t\t\tTEE_Identity *clnt_id)\n{\n\tconst uint32_t req_attr = OPTEE_MSG_ATTR_META |\n\t\t\t\t  OPTEE_MSG_ATTR_TYPE_VALUE_INPUT;\n\n\tif (num_params < 2)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tif (params[0].attr != req_attr || params[1].attr != req_attr)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\ttee_uuid_from_octets(uuid, (void *)&params[0].u.value);\n\tclnt_id->login = params[1].u.value.c;\n\tswitch (clnt_id->login) {\n\tcase TEE_LOGIN_PUBLIC:\n\tcase TEE_LOGIN_REE_KERNEL:\n\t\tmemset(&clnt_id->uuid, 0, sizeof(clnt_id->uuid));\n\t\tbreak;\n\tcase TEE_LOGIN_USER:\n\tcase TEE_LOGIN_GROUP:\n\tcase TEE_LOGIN_APPLICATION:\n\tcase TEE_LOGIN_APPLICATION_USER:\n\tcase TEE_LOGIN_APPLICATION_GROUP:\n\t\ttee_uuid_from_octets(&clnt_id->uuid,\n\t\t\t\t     (void *)&params[1].u.value);\n\t\tbreak;\n\tdefault:\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\n\n\t*num_meta = 2;\n\treturn TEE_SUCCESS;\n}\n\nstatic void entry_open_session(struct optee_msg_arg *arg, uint32_t num_params)\n{\n\tTEE_Result res;\n\tTEE_ErrorOrigin err_orig = TEE_ORIGIN_TEE;\n\tstruct tee_ta_session *s = NULL;\n\tTEE_Identity clnt_id;\n\tTEE_UUID uuid;\n\tstruct tee_ta_param param;\n\tsize_t num_meta;\n\tuint64_t saved_attr[TEE_NUM_PARAMS] = { 0 };\n\n\tres = get_open_session_meta(num_params, arg->params, &num_meta, &uuid,\n\t\t\t\t    &clnt_id);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = copy_in_params(arg->params + num_meta, num_params - num_meta,\n\t\t\t     &param, saved_attr);\n\tif (res != TEE_SUCCESS)\n\t\tgoto cleanup_shm_refs;\n\n\tres = tee_ta_open_session(&err_orig, &s, &tee_open_sessions, &uuid,\n\t\t\t\t  &clnt_id, TEE_TIMEOUT_INFINITE, &param);\n\tif (res != TEE_SUCCESS)\n\t\ts = NULL;\n\tcopy_out_param(&param, num_params - num_meta, arg->params + num_meta,\n\t\t       saved_attr);\n\n\t/*\n\t * The occurrence of open/close session command is usually\n\t * un-predictable, using this property to increase randomness\n\t * of prng\n\t */\n\tplat_prng_add_jitter_entropy(CRYPTO_RNG_SRC_JITTER_SESSION,\n\t\t\t\t     &session_pnum);\n\ncleanup_shm_refs:\n\tcleanup_shm_refs(saved_attr, &param, num_params - num_meta);\n\nout:\n\tif (s)\n\t\targ->session = s->id;\n\telse\n\t\targ->session = 0;\n\targ->ret = res;\n\targ->ret_origin = err_orig;\n}\n\nstatic void entry_close_session(struct optee_msg_arg *arg, uint32_t num_params)\n{\n\tTEE_Result res;\n\tstruct tee_ta_session *s;\n\n\tif (num_params) {\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto out;\n\t}\n\n\tplat_prng_add_jitter_entropy(CRYPTO_RNG_SRC_JITTER_SESSION,\n\t\t\t\t     &session_pnum);\n\n\ts = tee_ta_find_session(arg->session, &tee_open_sessions);\n\tres = tee_ta_close_session(s, &tee_open_sessions, NSAPP_IDENTITY);\nout:\n\targ->ret = res;\n\targ->ret_origin = TEE_ORIGIN_TEE;\n}\n\nstatic void entry_invoke_command(struct optee_msg_arg *arg, uint32_t num_params)\n{\n\tTEE_Result res;\n\tTEE_ErrorOrigin err_orig = TEE_ORIGIN_TEE;\n\tstruct tee_ta_session *s;\n\tstruct tee_ta_param param = { 0 };\n\tuint64_t saved_attr[TEE_NUM_PARAMS] = { 0 };\n\n\tbm_timestamp();\n\n\tres = copy_in_params(arg->params, num_params, &param, saved_attr);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\ts = tee_ta_get_session(arg->session, true, &tee_open_sessions);\n\tif (!s) {\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto out;\n\t}\n\n\tres = tee_ta_invoke_command(&err_orig, s, NSAPP_IDENTITY,\n\t\t\t\t    TEE_TIMEOUT_INFINITE, arg->func, &param);\n\n\tbm_timestamp();\n\n\ttee_ta_put_session(s);\n\n\tcopy_out_param(&param, num_params, arg->params, saved_attr);\n\nout:\n\tcleanup_shm_refs(saved_attr, &param, num_params);\n\n\targ->ret = res;\n\targ->ret_origin = err_orig;\n}\n\nstatic void entry_cancel(struct optee_msg_arg *arg, uint32_t num_params)\n{\n\tTEE_Result res;\n\tTEE_ErrorOrigin err_orig = TEE_ORIGIN_TEE;\n\tstruct tee_ta_session *s;\n\n\tif (num_params) {\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto out;\n\t}\n\n\ts = tee_ta_get_session(arg->session, false, &tee_open_sessions);\n\tif (!s) {\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto out;\n\t}\n\n\tres = tee_ta_cancel_command(&err_orig, s, NSAPP_IDENTITY);\n\ttee_ta_put_session(s);\n\nout:\n\targ->ret = res;\n\targ->ret_origin = err_orig;\n}\n\n#ifndef CFG_CORE_FFA\n#ifdef CFG_CORE_DYN_SHM\nstatic void register_shm(struct optee_msg_arg *arg, uint32_t num_params)\n{\n\tstruct optee_msg_param_tmem *tmem = NULL;\n\tstruct mobj *mobj = NULL;\n\n\targ->ret = TEE_ERROR_BAD_PARAMETERS;\n\n\tif (num_params != 1 ||\n\t    (arg->params[0].attr !=\n\t     (OPTEE_MSG_ATTR_TYPE_TMEM_OUTPUT | OPTEE_MSG_ATTR_NONCONTIG)))\n\t\treturn;\n\n\ttmem = &arg->params[0].u.tmem;\n\tmobj = msg_param_mobj_from_noncontig(tmem->buf_ptr, tmem->size,\n\t\t\t\t\t     tmem->shm_ref, false);\n\n\tif (!mobj)\n\t\treturn;\n\n\tmobj_reg_shm_unguard(mobj);\n\targ->ret = TEE_SUCCESS;\n}\n\nstatic void unregister_shm(struct optee_msg_arg *arg, uint32_t num_params)\n{\n\tif (num_params == 1) {\n\t\tuint64_t cookie = arg->params[0].u.rmem.shm_ref;\n\t\tTEE_Result res = mobj_reg_shm_release_by_cookie(cookie);\n\n\t\tif (res)\n\t\t\tEMSG(\"Can't find mapping with given cookie\");\n\t\targ->ret = res;\n\t} else {\n\t\targ->ret = TEE_ERROR_BAD_PARAMETERS;\n\t\targ->ret_origin = TEE_ORIGIN_TEE;\n\t}\n}\n#endif /*CFG_CORE_DYN_SHM*/\n#endif\n\nvoid nsec_sessions_list_head(struct tee_ta_session_head **open_sessions)\n{\n\t*open_sessions = &tee_open_sessions;\n}\n\n/* Note: this function is weak to let platforms add special handling */\nTEE_Result __weak tee_entry_std(struct optee_msg_arg *arg, uint32_t num_params)\n{\n\treturn __tee_entry_std(arg, num_params);\n}\n\n/*\n * If tee_entry_std() is overridden, it's still supposed to call this\n * function.\n */\nTEE_Result __tee_entry_std(struct optee_msg_arg *arg, uint32_t num_params)\n{\n\tTEE_Result res = TEE_SUCCESS;\n\n\t/* Enable foreign interrupts for STD calls */\n\tthread_set_foreign_intr(true);\n\tswitch (arg->cmd) {\n\tcase OPTEE_MSG_CMD_OPEN_SESSION:\n\t\tentry_open_session(arg, num_params);\n\t\tbreak;\n\tcase OPTEE_MSG_CMD_CLOSE_SESSION:\n\t\tentry_close_session(arg, num_params);\n\t\tbreak;\n\tcase OPTEE_MSG_CMD_INVOKE_COMMAND:\n\t\tentry_invoke_command(arg, num_params);\n\t\tbreak;\n\tcase OPTEE_MSG_CMD_CANCEL:\n\t\tentry_cancel(arg, num_params);\n\t\tbreak;\n#ifndef CFG_CORE_FFA\n#ifdef CFG_CORE_DYN_SHM\n\tcase OPTEE_MSG_CMD_REGISTER_SHM:\n\t\tregister_shm(arg, num_params);\n\t\tbreak;\n\tcase OPTEE_MSG_CMD_UNREGISTER_SHM:\n\t\tunregister_shm(arg, num_params);\n\t\tbreak;\n#endif\n#endif\n\n\tcase OPTEE_MSG_CMD_DO_BOTTOM_HALF:\n\t\tif (IS_ENABLED(CFG_CORE_ASYNC_NOTIF))\n\t\t\tnotif_deliver_event(NOTIF_EVENT_DO_BOTTOM_HALF);\n\t\telse\n\t\t\tgoto err;\n\t\tbreak;\n\tcase OPTEE_MSG_CMD_STOP_ASYNC_NOTIF:\n\t\tif (IS_ENABLED(CFG_CORE_ASYNC_NOTIF))\n\t\t\tnotif_deliver_event(NOTIF_EVENT_STOPPED);\n\t\telse\n\t\t\tgoto err;\n\t\tbreak;\n\n\tdefault:\nerr:\n\t\tEMSG(\"Unknown cmd 0x%x\", arg->cmd);\n\t\tres = TEE_ERROR_NOT_IMPLEMENTED;\n\t}\n\n\treturn res;\n}\n\nstatic TEE_Result default_mobj_init(void)\n{\n#ifdef CFG_CORE_RESERVED_SHM\n\tshm_mobj = mobj_phys_alloc(default_nsec_shm_paddr,\n\t\t\t\t   default_nsec_shm_size, SHM_CACHE_ATTRS,\n\t\t\t\t   CORE_MEM_NSEC_SHM);\n\tif (!shm_mobj)\n\t\tpanic(\"Failed to register shared memory\");\n#endif\n\n#ifdef CFG_SECURE_DATA_PATH\n\tsdp_mem_mobjs = core_sdp_mem_create_mobjs();\n\tif (!sdp_mem_mobjs)\n\t\tpanic(\"Failed to register SDP memory\");\n#endif\n\n\treturn TEE_SUCCESS;\n}\n\ndriver_init_late(default_mobj_init);\n"], "filenames": ["core/tee/entry_std.c"], "buggy_code_start_loc": [257], "buggy_code_end_loc": [258], "fixing_code_start_loc": [257], "fixing_code_end_loc": [258], "type": "CWE-129", "message": "OP-TEE Trusted OS is the secure side implementation of OP-TEE project, a Trusted Execution Environment. Versions prior to 3.19.0, contain an Improper Validation of Array Index vulnerability. The function `cleanup_shm_refs()` is called by both `entry_invoke_command()` and `entry_open_session()`. The commands `OPTEE_MSG_CMD_OPEN_SESSION` and `OPTEE_MSG_CMD_INVOKE_COMMAND` can be executed from the normal world via an OP-TEE SMC. This function is not validating the `num_params` argument, which is only limited to `OPTEE_MSG_MAX_NUM_PARAMS` (127) in the function `get_cmd_buffer()`. Therefore, an attacker in the normal world can craft an SMC call that will cause out-of-bounds reading in `cleanup_shm_refs` and potentially freeing of fake-objects in the function `mobj_put()`. A normal-world attacker with permission to execute SMC instructions may exploit this flaw. Maintainers believe this problem permits local privilege escalation from the normal world to the secure world. Version 3.19.0 contains a fix for this issue. There are no known workarounds.", "other": {"cve": {"id": "CVE-2022-46152", "sourceIdentifier": "security-advisories@github.com", "published": "2022-11-29T17:15:11.453", "lastModified": "2022-12-02T18:45:48.457", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "OP-TEE Trusted OS is the secure side implementation of OP-TEE project, a Trusted Execution Environment. Versions prior to 3.19.0, contain an Improper Validation of Array Index vulnerability. The function `cleanup_shm_refs()` is called by both `entry_invoke_command()` and `entry_open_session()`. The commands `OPTEE_MSG_CMD_OPEN_SESSION` and `OPTEE_MSG_CMD_INVOKE_COMMAND` can be executed from the normal world via an OP-TEE SMC. This function is not validating the `num_params` argument, which is only limited to `OPTEE_MSG_MAX_NUM_PARAMS` (127) in the function `get_cmd_buffer()`. Therefore, an attacker in the normal world can craft an SMC call that will cause out-of-bounds reading in `cleanup_shm_refs` and potentially freeing of fake-objects in the function `mobj_put()`. A normal-world attacker with permission to execute SMC instructions may exploit this flaw. Maintainers believe this problem permits local privilege escalation from the normal world to the secure world. Version 3.19.0 contains a fix for this issue. There are no known workarounds."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.0, "impactScore": 6.0}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:C/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.5, "impactScore": 6.0}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-129"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-129"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:op-tee:op-tee_os:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.19.0", "matchCriteriaId": "288DA9A9-AD20-429C-AD07-621EBC52B729"}]}]}], "references": [{"url": "https://github.com/OP-TEE/optee_os/blob/c2d449482de098f1c894b94f338440e5a327813d/core/tee/entry_std.c#L257", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/OP-TEE/optee_os/commit/728616b28df659cf0bdde6e58a471f6ef25d023c", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/OP-TEE/optee_os/security/advisories/GHSA-65w8-6mrg-52g7", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://nvd.nist.gov/vuln-metrics/cvss/v3-calculator?vector=AV:L/AC:L/PR:H/UI:N/S:C/C:H/I:H/A:H/E:U/RL:X/RC:X/CR:M/IR:M/AR:M/MAV:L/MAC:L/MPR:H/MUI:N/MS:C/MC:H/MI:H/MA:H&version=3.1", "source": "security-advisories@github.com", "tags": ["Third Party Advisory", "US Government Resource"]}]}, "github_commit_url": "https://github.com/OP-TEE/optee_os/commit/728616b28df659cf0bdde6e58a471f6ef25d023c"}}