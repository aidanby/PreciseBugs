{"buggy_code": ["/*\r\n  ==============================================================================\r\n\r\n   This file is part of the JUCE library.\r\n   Copyright (c) 2020 - Raw Material Software Limited\r\n\r\n   JUCE is an open source library subject to commercial or open-source\r\n   licensing.\r\n\r\n   The code included in this file is provided under the terms of the ISC license\r\n   http://www.isc.org/downloads/software-support-policy/isc-license. Permission\r\n   To use, copy, modify, and/or distribute this software for any purpose with or\r\n   without fee is hereby granted provided that the above copyright notice and\r\n   this permission notice appear in all copies.\r\n\r\n   JUCE IS PROVIDED \"AS IS\" WITHOUT ANY WARRANTY, AND ALL WARRANTIES, WHETHER\r\n   EXPRESSED OR IMPLIED, INCLUDING MERCHANTABILITY AND FITNESS FOR PURPOSE, ARE\r\n   DISCLAIMED.\r\n\r\n  ==============================================================================\r\n*/\r\n\r\nnamespace juce\r\n{\r\n\r\nstatic File createTempFile (const File& parentDirectory, String name,\r\n                            const String& suffix, int optionFlags)\r\n{\r\n    if ((optionFlags & TemporaryFile::useHiddenFile) != 0)\r\n        name = \".\" + name;\r\n\r\n    return parentDirectory.getNonexistentChildFile (name, suffix, (optionFlags & TemporaryFile::putNumbersInBrackets) != 0);\r\n}\r\n\r\nTemporaryFile::TemporaryFile (const String& suffix, const int optionFlags)\r\n    : temporaryFile (createTempFile (File::getSpecialLocation (File::tempDirectory),\r\n                                     \"temp_\" + String::toHexString (Random::getSystemRandom().nextInt()),\r\n                                     suffix, optionFlags)),\r\n      targetFile()\r\n{\r\n}\r\n\r\nTemporaryFile::TemporaryFile (const File& target, const int optionFlags)\r\n    : temporaryFile (createTempFile (target.getParentDirectory(),\r\n                                     target.getFileNameWithoutExtension()\r\n                                       + \"_temp\" + String::toHexString (Random::getSystemRandom().nextInt()),\r\n                                     target.getFileExtension(), optionFlags)),\r\n      targetFile (target)\r\n{\r\n    // If you use this constructor, you need to give it a valid target file!\r\n    jassert (targetFile != File());\r\n}\r\n\r\nTemporaryFile::TemporaryFile (const File& target, const File& temporary)\r\n    : temporaryFile (temporary), targetFile (target)\r\n{\r\n}\r\n\r\nTemporaryFile::~TemporaryFile()\r\n{\r\n    if (! deleteTemporaryFile())\r\n    {\r\n        /* Failed to delete our temporary file! The most likely reason for this would be\r\n           that you've not closed an output stream that was being used to write to file.\r\n\r\n           If you find that something beyond your control is changing permissions on\r\n           your temporary files and preventing them from being deleted, you may want to\r\n           call TemporaryFile::deleteTemporaryFile() to detect those error cases and\r\n           handle them appropriately.\r\n        */\r\n        jassertfalse;\r\n    }\r\n}\r\n\r\n//==============================================================================\r\nbool TemporaryFile::overwriteTargetFileWithTemporary() const\r\n{\r\n    // This method only works if you created this object with the constructor\r\n    // that takes a target file!\r\n    jassert (targetFile != File());\r\n\r\n    if (temporaryFile.exists())\r\n    {\r\n        // Have a few attempts at overwriting the file before giving up..\r\n        for (int i = 5; --i >= 0;)\r\n        {\r\n            if (temporaryFile.replaceFileIn (targetFile))\r\n                return true;\r\n\r\n            Thread::sleep (100);\r\n        }\r\n    }\r\n    else\r\n    {\r\n        // There's no temporary file to use. If your write failed, you should\r\n        // probably check, and not bother calling this method.\r\n        jassertfalse;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nbool TemporaryFile::deleteTemporaryFile() const\r\n{\r\n    // Have a few attempts at deleting the file before giving up..\r\n    for (int i = 5; --i >= 0;)\r\n    {\r\n        if (temporaryFile.deleteFile())\r\n            return true;\r\n\r\n        Thread::sleep (50);\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n} // namespace juce\r\n", "/*\r\n  ==============================================================================\r\n\r\n   This file is part of the JUCE library.\r\n   Copyright (c) 2020 - Raw Material Software Limited\r\n\r\n   JUCE is an open source library subject to commercial or open-source\r\n   licensing.\r\n\r\n   The code included in this file is provided under the terms of the ISC license\r\n   http://www.isc.org/downloads/software-support-policy/isc-license. Permission\r\n   To use, copy, modify, and/or distribute this software for any purpose with or\r\n   without fee is hereby granted provided that the above copyright notice and\r\n   this permission notice appear in all copies.\r\n\r\n   JUCE IS PROVIDED \"AS IS\" WITHOUT ANY WARRANTY, AND ALL WARRANTIES, WHETHER\r\n   EXPRESSED OR IMPLIED, INCLUDING MERCHANTABILITY AND FITNESS FOR PURPOSE, ARE\r\n   DISCLAIMED.\r\n\r\n  ==============================================================================\r\n*/\r\n\r\nnamespace juce\r\n{\r\n\r\ninline uint16 readUnalignedLittleEndianShort (const void* buffer)\r\n{\r\n    auto data = readUnaligned<uint16> (buffer);\r\n    return ByteOrder::littleEndianShort (&data);\r\n}\r\n\r\ninline uint32 readUnalignedLittleEndianInt (const void* buffer)\r\n{\r\n    auto data = readUnaligned<uint32> (buffer);\r\n    return ByteOrder::littleEndianInt (&data);\r\n}\r\n\r\nstruct ZipFile::ZipEntryHolder\r\n{\r\n    ZipEntryHolder (const char* buffer, int fileNameLen)\r\n    {\r\n        isCompressed           = readUnalignedLittleEndianShort (buffer + 10) != 0;\r\n        entry.fileTime         = parseFileTime (readUnalignedLittleEndianShort (buffer + 12),\r\n                                                readUnalignedLittleEndianShort (buffer + 14));\r\n        compressedSize         = (int64) readUnalignedLittleEndianInt (buffer + 20);\r\n        entry.uncompressedSize = (int64) readUnalignedLittleEndianInt (buffer + 24);\r\n        streamOffset           = (int64) readUnalignedLittleEndianInt (buffer + 42);\r\n\r\n        entry.externalFileAttributes = readUnalignedLittleEndianInt (buffer + 38);\r\n        auto fileType = (entry.externalFileAttributes >> 28) & 0xf;\r\n        entry.isSymbolicLink = (fileType == 0xA);\r\n\r\n        entry.filename = String::fromUTF8 (buffer + 46, fileNameLen);\r\n    }\r\n\r\n    static Time parseFileTime (uint32 time, uint32 date) noexcept\r\n    {\r\n        auto year      = (int) (1980 + (date >> 9));\r\n        auto month     = (int) (((date >> 5) & 15) - 1);\r\n        auto day       = (int) (date & 31);\r\n        auto hours     = (int) time >> 11;\r\n        auto minutes   = (int) ((time >> 5) & 63);\r\n        auto seconds   = (int) ((time & 31) << 1);\r\n\r\n        return { year, month, day, hours, minutes, seconds };\r\n    }\r\n\r\n    ZipEntry entry;\r\n    int64 streamOffset, compressedSize;\r\n    bool isCompressed;\r\n};\r\n\r\n//==============================================================================\r\nstatic int64 findCentralDirectoryFileHeader (InputStream& input, int& numEntries)\r\n{\r\n    BufferedInputStream in (input, 8192);\r\n\r\n    in.setPosition (in.getTotalLength());\r\n    auto pos = in.getPosition();\r\n    auto lowestPos = jmax ((int64) 0, pos - 1048576);\r\n    char buffer[32] = {};\r\n\r\n    while (pos > lowestPos)\r\n    {\r\n        in.setPosition (pos - 22);\r\n        pos = in.getPosition();\r\n        memcpy (buffer + 22, buffer, 4);\r\n\r\n        if (in.read (buffer, 22) != 22)\r\n            return 0;\r\n\r\n        for (int i = 0; i < 22; ++i)\r\n        {\r\n            if (readUnalignedLittleEndianInt (buffer + i) == 0x06054b50)\r\n            {\r\n                in.setPosition (pos + i);\r\n                in.read (buffer, 22);\r\n                numEntries = readUnalignedLittleEndianShort (buffer + 10);\r\n                auto offset = (int64) readUnalignedLittleEndianInt (buffer + 16);\r\n\r\n                if (offset >= 4)\r\n                {\r\n                    in.setPosition (offset);\r\n\r\n                    // This is a workaround for some zip files which seem to contain the\r\n                    // wrong offset for the central directory - instead of including the\r\n                    // header, they point to the byte immediately after it.\r\n                    if (in.readInt() != 0x02014b50)\r\n                    {\r\n                        in.setPosition (offset - 4);\r\n\r\n                        if (in.readInt() == 0x02014b50)\r\n                            offset -= 4;\r\n                    }\r\n                }\r\n\r\n                return offset;\r\n            }\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\n//==============================================================================\r\nstruct ZipFile::ZipInputStream  : public InputStream\r\n{\r\n    ZipInputStream (ZipFile& zf, const ZipFile::ZipEntryHolder& zei)\r\n        : file (zf),\r\n          zipEntryHolder (zei),\r\n          inputStream (zf.inputStream)\r\n    {\r\n        if (zf.inputSource != nullptr)\r\n        {\r\n            streamToDelete.reset (file.inputSource->createInputStream());\r\n            inputStream = streamToDelete.get();\r\n        }\r\n        else\r\n        {\r\n           #if JUCE_DEBUG\r\n            zf.streamCounter.numOpenStreams++;\r\n           #endif\r\n        }\r\n\r\n        char buffer[30];\r\n\r\n        if (inputStream != nullptr\r\n             && inputStream->setPosition (zei.streamOffset)\r\n             && inputStream->read (buffer, 30) == 30\r\n             && ByteOrder::littleEndianInt (buffer) == 0x04034b50)\r\n        {\r\n            headerSize = 30 + ByteOrder::littleEndianShort (buffer + 26)\r\n                            + ByteOrder::littleEndianShort (buffer + 28);\r\n        }\r\n    }\r\n\r\n    ~ZipInputStream() override\r\n    {\r\n       #if JUCE_DEBUG\r\n        if (inputStream != nullptr && inputStream == file.inputStream)\r\n            file.streamCounter.numOpenStreams--;\r\n       #endif\r\n    }\r\n\r\n    int64 getTotalLength() override\r\n    {\r\n        return zipEntryHolder.compressedSize;\r\n    }\r\n\r\n    int read (void* buffer, int howMany) override\r\n    {\r\n        if (headerSize <= 0)\r\n            return 0;\r\n\r\n        howMany = (int) jmin ((int64) howMany, zipEntryHolder.compressedSize - pos);\r\n\r\n        if (inputStream == nullptr)\r\n            return 0;\r\n\r\n        int num;\r\n\r\n        if (inputStream == file.inputStream)\r\n        {\r\n            const ScopedLock sl (file.lock);\r\n            inputStream->setPosition (pos + zipEntryHolder.streamOffset + headerSize);\r\n            num = inputStream->read (buffer, howMany);\r\n        }\r\n        else\r\n        {\r\n            inputStream->setPosition (pos + zipEntryHolder.streamOffset + headerSize);\r\n            num = inputStream->read (buffer, howMany);\r\n        }\r\n\r\n        pos += num;\r\n        return num;\r\n    }\r\n\r\n    bool isExhausted() override\r\n    {\r\n        return headerSize <= 0 || pos >= zipEntryHolder.compressedSize;\r\n    }\r\n\r\n    int64 getPosition() override\r\n    {\r\n        return pos;\r\n    }\r\n\r\n    bool setPosition (int64 newPos) override\r\n    {\r\n        pos = jlimit ((int64) 0, zipEntryHolder.compressedSize, newPos);\r\n        return true;\r\n    }\r\n\r\nprivate:\r\n    ZipFile& file;\r\n    ZipEntryHolder zipEntryHolder;\r\n    int64 pos = 0;\r\n    int headerSize = 0;\r\n    InputStream* inputStream;\r\n    std::unique_ptr<InputStream> streamToDelete;\r\n\r\n    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ZipInputStream)\r\n};\r\n\r\n\r\n//==============================================================================\r\nZipFile::ZipFile (InputStream* stream, bool deleteStreamWhenDestroyed)\r\n   : inputStream (stream)\r\n{\r\n    if (deleteStreamWhenDestroyed)\r\n        streamToDelete.reset (inputStream);\r\n\r\n    init();\r\n}\r\n\r\nZipFile::ZipFile (InputStream& stream)  : inputStream (&stream)\r\n{\r\n    init();\r\n}\r\n\r\nZipFile::ZipFile (const File& file)  : inputSource (new FileInputSource (file))\r\n{\r\n    init();\r\n}\r\n\r\nZipFile::ZipFile (InputSource* source)  : inputSource (source)\r\n{\r\n    init();\r\n}\r\n\r\nZipFile::~ZipFile()\r\n{\r\n    entries.clear();\r\n}\r\n\r\n#if JUCE_DEBUG\r\nZipFile::OpenStreamCounter::~OpenStreamCounter()\r\n{\r\n    /* If you hit this assertion, it means you've created a stream to read one of the items in the\r\n       zipfile, but you've forgotten to delete that stream object before deleting the file..\r\n       Streams can't be kept open after the file is deleted because they need to share the input\r\n       stream that is managed by the ZipFile object.\r\n    */\r\n    jassert (numOpenStreams == 0);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\nint ZipFile::getNumEntries() const noexcept\r\n{\r\n    return entries.size();\r\n}\r\n\r\nconst ZipFile::ZipEntry* ZipFile::getEntry (const int index) const noexcept\r\n{\r\n    if (auto* zei = entries[index])\r\n        return &(zei->entry);\r\n\r\n    return nullptr;\r\n}\r\n\r\nint ZipFile::getIndexOfFileName (const String& fileName, bool ignoreCase) const noexcept\r\n{\r\n    for (int i = 0; i < entries.size(); ++i)\r\n    {\r\n        auto& entryFilename = entries.getUnchecked (i)->entry.filename;\r\n\r\n        if (ignoreCase ? entryFilename.equalsIgnoreCase (fileName)\r\n                       : entryFilename == fileName)\r\n            return i;\r\n    }\r\n\r\n    return -1;\r\n}\r\n\r\nconst ZipFile::ZipEntry* ZipFile::getEntry (const String& fileName, bool ignoreCase) const noexcept\r\n{\r\n    return getEntry (getIndexOfFileName (fileName, ignoreCase));\r\n}\r\n\r\nInputStream* ZipFile::createStreamForEntry (const int index)\r\n{\r\n    InputStream* stream = nullptr;\r\n\r\n    if (auto* zei = entries[index])\r\n    {\r\n        stream = new ZipInputStream (*this, *zei);\r\n\r\n        if (zei->isCompressed)\r\n        {\r\n            stream = new GZIPDecompressorInputStream (stream, true,\r\n                                                      GZIPDecompressorInputStream::deflateFormat,\r\n                                                      zei->entry.uncompressedSize);\r\n\r\n            // (much faster to unzip in big blocks using a buffer..)\r\n            stream = new BufferedInputStream (stream, 32768, true);\r\n        }\r\n    }\r\n\r\n    return stream;\r\n}\r\n\r\nInputStream* ZipFile::createStreamForEntry (const ZipEntry& entry)\r\n{\r\n    for (int i = 0; i < entries.size(); ++i)\r\n        if (&entries.getUnchecked (i)->entry == &entry)\r\n            return createStreamForEntry (i);\r\n\r\n    return nullptr;\r\n}\r\n\r\nvoid ZipFile::sortEntriesByFilename()\r\n{\r\n    std::sort (entries.begin(), entries.end(),\r\n               [] (const ZipEntryHolder* e1, const ZipEntryHolder* e2) { return e1->entry.filename < e2->entry.filename; });\r\n}\r\n\r\n//==============================================================================\r\nvoid ZipFile::init()\r\n{\r\n    std::unique_ptr<InputStream> toDelete;\r\n    InputStream* in = inputStream;\r\n\r\n    if (inputSource != nullptr)\r\n    {\r\n        in = inputSource->createInputStream();\r\n        toDelete.reset (in);\r\n    }\r\n\r\n    if (in != nullptr)\r\n    {\r\n        int numEntries = 0;\r\n        auto centralDirectoryPos = findCentralDirectoryFileHeader (*in, numEntries);\r\n\r\n        if (centralDirectoryPos >= 0 && centralDirectoryPos < in->getTotalLength())\r\n        {\r\n            auto size = (size_t) (in->getTotalLength() - centralDirectoryPos);\r\n\r\n            in->setPosition (centralDirectoryPos);\r\n            MemoryBlock headerData;\r\n\r\n            if (in->readIntoMemoryBlock (headerData, (ssize_t) size) == size)\r\n            {\r\n                size_t pos = 0;\r\n\r\n                for (int i = 0; i < numEntries; ++i)\r\n                {\r\n                    if (pos + 46 > size)\r\n                        break;\r\n\r\n                    auto* buffer = static_cast<const char*> (headerData.getData()) + pos;\r\n                    auto fileNameLen = readUnalignedLittleEndianShort (buffer + 28u);\r\n\r\n                    if (pos + 46 + fileNameLen > size)\r\n                        break;\r\n\r\n                    entries.add (new ZipEntryHolder (buffer, fileNameLen));\r\n\r\n                    pos += 46u + fileNameLen\r\n                            + readUnalignedLittleEndianShort (buffer + 30u)\r\n                            + readUnalignedLittleEndianShort (buffer + 32u);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nResult ZipFile::uncompressTo (const File& targetDirectory,\r\n                              const bool shouldOverwriteFiles)\r\n{\r\n    for (int i = 0; i < entries.size(); ++i)\r\n    {\r\n        auto result = uncompressEntry (i, targetDirectory, shouldOverwriteFiles);\r\n\r\n        if (result.failed())\r\n            return result;\r\n    }\r\n\r\n    return Result::ok();\r\n}\r\n\r\nResult ZipFile::uncompressEntry (int index, const File& targetDirectory, bool shouldOverwriteFiles)\r\n{\r\n    auto* zei = entries.getUnchecked (index);\r\n\r\n   #if JUCE_WINDOWS\r\n    auto entryPath = zei->entry.filename;\r\n   #else\r\n    auto entryPath = zei->entry.filename.replaceCharacter ('\\\\', '/');\r\n   #endif\r\n\r\n    if (entryPath.isEmpty())\r\n        return Result::ok();\r\n\r\n    auto targetFile = targetDirectory.getChildFile (entryPath);\r\n\r\n    if (entryPath.endsWithChar ('/') || entryPath.endsWithChar ('\\\\'))\r\n        return targetFile.createDirectory(); // (entry is a directory, not a file)\r\n\r\n    std::unique_ptr<InputStream> in (createStreamForEntry (index));\r\n\r\n    if (in == nullptr)\r\n        return Result::fail (\"Failed to open the zip file for reading\");\r\n\r\n    if (targetFile.exists())\r\n    {\r\n        if (! shouldOverwriteFiles)\r\n            return Result::ok();\r\n\r\n        if (! targetFile.deleteFile())\r\n            return Result::fail (\"Failed to write to target file: \" + targetFile.getFullPathName());\r\n    }\r\n\r\n    if (! targetFile.getParentDirectory().createDirectory())\r\n        return Result::fail (\"Failed to create target folder: \" + targetFile.getParentDirectory().getFullPathName());\r\n\r\n    if (zei->entry.isSymbolicLink)\r\n    {\r\n        String originalFilePath (in->readEntireStreamAsString()\r\n                                    .replaceCharacter (L'/', File::getSeparatorChar()));\r\n\r\n        if (! File::createSymbolicLink (targetFile, originalFilePath, true))\r\n            return Result::fail (\"Failed to create symbolic link: \" + originalFilePath);\r\n    }\r\n    else\r\n    {\r\n        FileOutputStream out (targetFile);\r\n\r\n        if (out.failedToOpen())\r\n            return Result::fail (\"Failed to write to target file: \" + targetFile.getFullPathName());\r\n\r\n        out << *in;\r\n    }\r\n\r\n    targetFile.setCreationTime (zei->entry.fileTime);\r\n    targetFile.setLastModificationTime (zei->entry.fileTime);\r\n    targetFile.setLastAccessTime (zei->entry.fileTime);\r\n\r\n    return Result::ok();\r\n}\r\n\r\n\r\n//==============================================================================\r\nstruct ZipFile::Builder::Item\r\n{\r\n    Item (const File& f, InputStream* s, int compression, const String& storedPath, Time time)\r\n        : file (f), stream (s), storedPathname (storedPath), fileTime (time), compressionLevel (compression)\r\n    {\r\n        symbolicLink = (file.exists() && file.isSymbolicLink());\r\n    }\r\n\r\n    bool writeData (OutputStream& target, const int64 overallStartPosition)\r\n    {\r\n        MemoryOutputStream compressedData ((size_t) file.getSize());\r\n\r\n        if (symbolicLink)\r\n        {\r\n            auto relativePath = file.getNativeLinkedTarget().replaceCharacter (File::getSeparatorChar(), L'/');\r\n\r\n            uncompressedSize = relativePath.length();\r\n\r\n            checksum = zlibNamespace::crc32 (0, (uint8_t*) relativePath.toRawUTF8(), (unsigned int) uncompressedSize);\r\n            compressedData << relativePath;\r\n        }\r\n        else if (compressionLevel > 0)\r\n        {\r\n            GZIPCompressorOutputStream compressor (compressedData, compressionLevel,\r\n                                                   GZIPCompressorOutputStream::windowBitsRaw);\r\n            if (! writeSource (compressor))\r\n                return false;\r\n        }\r\n        else\r\n        {\r\n            if (! writeSource (compressedData))\r\n                return false;\r\n        }\r\n\r\n        compressedSize = (int64) compressedData.getDataSize();\r\n        headerStart = target.getPosition() - overallStartPosition;\r\n\r\n        target.writeInt (0x04034b50);\r\n        writeFlagsAndSizes (target);\r\n        target << storedPathname\r\n               << compressedData;\r\n\r\n        return true;\r\n    }\r\n\r\n    bool writeDirectoryEntry (OutputStream& target)\r\n    {\r\n        target.writeInt (0x02014b50);\r\n        target.writeShort (symbolicLink ? 0x0314 : 0x0014);\r\n        writeFlagsAndSizes (target);\r\n        target.writeShort (0); // comment length\r\n        target.writeShort (0); // start disk num\r\n        target.writeShort (0); // internal attributes\r\n        target.writeInt ((int) (symbolicLink ? 0xA1ED0000 : 0)); // external attributes\r\n        target.writeInt ((int) (uint32) headerStart);\r\n        target << storedPathname;\r\n\r\n        return true;\r\n    }\r\n\r\nprivate:\r\n    const File file;\r\n    std::unique_ptr<InputStream> stream;\r\n    String storedPathname;\r\n    Time fileTime;\r\n    int64 compressedSize = 0, uncompressedSize = 0, headerStart = 0;\r\n    int compressionLevel = 0;\r\n    unsigned long checksum = 0;\r\n    bool symbolicLink = false;\r\n\r\n    static void writeTimeAndDate (OutputStream& target, Time t)\r\n    {\r\n        target.writeShort ((short) (t.getSeconds() + (t.getMinutes() << 5) + (t.getHours() << 11)));\r\n        target.writeShort ((short) (t.getDayOfMonth() + ((t.getMonth() + 1) << 5) + ((t.getYear() - 1980) << 9)));\r\n    }\r\n\r\n    bool writeSource (OutputStream& target)\r\n    {\r\n        if (stream == nullptr)\r\n        {\r\n            stream = file.createInputStream();\r\n\r\n            if (stream == nullptr)\r\n                return false;\r\n        }\r\n\r\n        checksum = 0;\r\n        uncompressedSize = 0;\r\n        const int bufferSize = 4096;\r\n        HeapBlock<unsigned char> buffer (bufferSize);\r\n\r\n        while (! stream->isExhausted())\r\n        {\r\n            auto bytesRead = stream->read (buffer, bufferSize);\r\n\r\n            if (bytesRead < 0)\r\n                return false;\r\n\r\n            checksum = zlibNamespace::crc32 (checksum, buffer, (unsigned int) bytesRead);\r\n            target.write (buffer, (size_t) bytesRead);\r\n            uncompressedSize += bytesRead;\r\n        }\r\n\r\n        stream.reset();\r\n        return true;\r\n    }\r\n\r\n    void writeFlagsAndSizes (OutputStream& target) const\r\n    {\r\n        target.writeShort (10); // version needed\r\n        target.writeShort ((short) (1 << 11)); // this flag indicates UTF-8 filename encoding\r\n        target.writeShort ((! symbolicLink && compressionLevel > 0) ? (short) 8 : (short) 0); //symlink target path is not compressed\r\n        writeTimeAndDate (target, fileTime);\r\n        target.writeInt ((int) checksum);\r\n        target.writeInt ((int) (uint32) compressedSize);\r\n        target.writeInt ((int) (uint32) uncompressedSize);\r\n        target.writeShort (static_cast<short> (storedPathname.toUTF8().sizeInBytes() - 1));\r\n        target.writeShort (0); // extra field length\r\n    }\r\n\r\n    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (Item)\r\n};\r\n\r\n//==============================================================================\r\nZipFile::Builder::Builder() {}\r\nZipFile::Builder::~Builder() {}\r\n\r\nvoid ZipFile::Builder::addFile (const File& file, int compression, const String& path)\r\n{\r\n    items.add (new Item (file, nullptr, compression,\r\n                         path.isEmpty() ? file.getFileName() : path,\r\n                         file.getLastModificationTime()));\r\n}\r\n\r\nvoid ZipFile::Builder::addEntry (InputStream* stream, int compression, const String& path, Time time)\r\n{\r\n    jassert (stream != nullptr); // must not be null!\r\n    jassert (path.isNotEmpty());\r\n    items.add (new Item ({}, stream, compression, path, time));\r\n}\r\n\r\nbool ZipFile::Builder::writeToStream (OutputStream& target, double* const progress) const\r\n{\r\n    auto fileStart = target.getPosition();\r\n\r\n    for (int i = 0; i < items.size(); ++i)\r\n    {\r\n        if (progress != nullptr)\r\n            *progress = (i + 0.5) / items.size();\r\n\r\n        if (! items.getUnchecked (i)->writeData (target, fileStart))\r\n            return false;\r\n    }\r\n\r\n    auto directoryStart = target.getPosition();\r\n\r\n    for (auto* item : items)\r\n        if (! item->writeDirectoryEntry (target))\r\n            return false;\r\n\r\n    auto directoryEnd = target.getPosition();\r\n\r\n    target.writeInt (0x06054b50);\r\n    target.writeShort (0);\r\n    target.writeShort (0);\r\n    target.writeShort ((short) items.size());\r\n    target.writeShort ((short) items.size());\r\n    target.writeInt ((int) (directoryEnd - directoryStart));\r\n    target.writeInt ((int) (directoryStart - fileStart));\r\n    target.writeShort (0);\r\n\r\n    if (progress != nullptr)\r\n        *progress = 1.0;\r\n\r\n    return true;\r\n}\r\n\r\n\r\n//==============================================================================\r\n//==============================================================================\r\n#if JUCE_UNIT_TESTS\r\n\r\nstruct ZIPTests   : public UnitTest\r\n{\r\n    ZIPTests()\r\n        : UnitTest (\"ZIP\", UnitTestCategories::compression)\r\n    {}\r\n\r\n    void runTest() override\r\n    {\r\n        beginTest (\"ZIP\");\r\n\r\n        ZipFile::Builder builder;\r\n        StringArray entryNames { \"first\", \"second\", \"third\" };\r\n        HashMap<String, MemoryBlock> blocks;\r\n\r\n        for (auto& entryName : entryNames)\r\n        {\r\n            auto& block = blocks.getReference (entryName);\r\n            MemoryOutputStream mo (block, false);\r\n            mo << entryName;\r\n            mo.flush();\r\n            builder.addEntry (new MemoryInputStream (block, false), 9, entryName, Time::getCurrentTime());\r\n        }\r\n\r\n        MemoryBlock data;\r\n        MemoryOutputStream mo (data, false);\r\n        builder.writeToStream (mo, nullptr);\r\n        MemoryInputStream mi (data, false);\r\n\r\n        ZipFile zip (mi);\r\n\r\n        expectEquals (zip.getNumEntries(), entryNames.size());\r\n\r\n        for (auto& entryName : entryNames)\r\n        {\r\n            auto* entry = zip.getEntry (entryName);\r\n            std::unique_ptr<InputStream> input (zip.createStreamForEntry (*entry));\r\n            expectEquals (input->readEntireStreamAsString(), entryName);\r\n        }\r\n    }\r\n};\r\n\r\nstatic ZIPTests zipTests;\r\n\r\n#endif\r\n\r\n} // namespace juce\r\n", "/*\r\n  ==============================================================================\r\n\r\n   This file is part of the JUCE library.\r\n   Copyright (c) 2020 - Raw Material Software Limited\r\n\r\n   JUCE is an open source library subject to commercial or open-source\r\n   licensing.\r\n\r\n   The code included in this file is provided under the terms of the ISC license\r\n   http://www.isc.org/downloads/software-support-policy/isc-license. Permission\r\n   To use, copy, modify, and/or distribute this software for any purpose with or\r\n   without fee is hereby granted provided that the above copyright notice and\r\n   this permission notice appear in all copies.\r\n\r\n   JUCE IS PROVIDED \"AS IS\" WITHOUT ANY WARRANTY, AND ALL WARRANTIES, WHETHER\r\n   EXPRESSED OR IMPLIED, INCLUDING MERCHANTABILITY AND FITNESS FOR PURPOSE, ARE\r\n   DISCLAIMED.\r\n\r\n  ==============================================================================\r\n*/\r\n\r\nnamespace juce\r\n{\r\n\r\n//==============================================================================\r\n/**\r\n    Decodes a ZIP file from a stream.\r\n\r\n    This can enumerate the items in a ZIP file and can create suitable stream objects\r\n    to read each one.\r\n\r\n    @tags{Core}\r\n*/\r\nclass JUCE_API  ZipFile\r\n{\r\npublic:\r\n    /** Creates a ZipFile to read a specific file. */\r\n    explicit ZipFile (const File& file);\r\n\r\n    //==============================================================================\r\n    /** Creates a ZipFile for a given stream.\r\n\r\n        @param inputStream                  the stream to read from\r\n        @param deleteStreamWhenDestroyed    if set to true, the object passed-in\r\n                                            will be deleted when this ZipFile object is deleted\r\n    */\r\n    ZipFile (InputStream* inputStream, bool deleteStreamWhenDestroyed);\r\n\r\n    /** Creates a ZipFile for a given stream.\r\n        The stream will not be owned or deleted by this class - if you want the ZipFile to\r\n        manage the stream's lifetime, use the other constructor.\r\n    */\r\n    explicit ZipFile (InputStream& inputStream);\r\n\r\n    /** Creates a ZipFile for an input source.\r\n\r\n        The inputSource object will be owned by the zip file, which will delete\r\n        it later when not needed.\r\n    */\r\n    explicit ZipFile (InputSource* inputSource);\r\n\r\n    /** Destructor. */\r\n    ~ZipFile();\r\n\r\n    //==============================================================================\r\n    /**\r\n        Contains information about one of the entries in a ZipFile.\r\n\r\n        @see ZipFile::getEntry\r\n    */\r\n    struct ZipEntry\r\n    {\r\n        /** The name of the file, which may also include a partial pathname. */\r\n        String filename;\r\n\r\n        /** The file's original size. */\r\n        int64 uncompressedSize;\r\n\r\n        /** The last time the file was modified. */\r\n        Time fileTime;\r\n\r\n        /** True if the zip entry is a symbolic link. */\r\n        bool isSymbolicLink;\r\n\r\n        /** Platform specific data. Depending on how the zip file was created this\r\n            may contain macOS and Linux file types, permissions and\r\n            setuid/setgid/sticky bits.\r\n        */\r\n        uint32 externalFileAttributes;\r\n    };\r\n\r\n    //==============================================================================\r\n    /** Returns the number of items in the zip file. */\r\n    int getNumEntries() const noexcept;\r\n\r\n    /** Returns a structure that describes one of the entries in the zip file.\r\n        This may return a nullptr if the index is out of range.\r\n        @see ZipFile::ZipEntry\r\n    */\r\n    const ZipEntry* getEntry (int index) const noexcept;\r\n\r\n    /** Returns the index of the first entry with a given filename.\r\n        This uses a case-sensitive comparison to look for a filename in the\r\n        list of entries. It might return -1 if no match is found.\r\n\r\n        @see ZipFile::ZipEntry\r\n    */\r\n    int getIndexOfFileName (const String& fileName, bool ignoreCase = false) const noexcept;\r\n\r\n    /** Returns a structure that describes one of the entries in the zip file.\r\n\r\n        This uses a case-sensitive comparison to look for a filename in the\r\n        list of entries. It might return 0 if no match is found.\r\n\r\n        @see ZipFile::ZipEntry\r\n    */\r\n    const ZipEntry* getEntry (const String& fileName, bool ignoreCase = false) const noexcept;\r\n\r\n    /** Sorts the list of entries, based on the filename. */\r\n    void sortEntriesByFilename();\r\n\r\n    //==============================================================================\r\n    /** Creates a stream that can read from one of the zip file's entries.\r\n\r\n        The stream that is returned must be deleted by the caller (and\r\n        a nullptr might be returned if a stream can't be opened for some reason).\r\n\r\n        The stream must not be used after the ZipFile object that created\r\n        has been deleted.\r\n\r\n        Note that if the ZipFile was created with a user-supplied InputStream object,\r\n        then all the streams which are created by this method will by trying to share\r\n        the same source stream, so cannot be safely used on  multiple threads! (But if\r\n        you create the ZipFile from a File or InputSource, then it is safe to do this).\r\n    */\r\n    InputStream* createStreamForEntry (int index);\r\n\r\n    /** Creates a stream that can read from one of the zip file's entries.\r\n\r\n        The stream that is returned must be deleted by the caller (and\r\n        a nullptr might be returned if a stream can't be opened for some reason).\r\n\r\n        The stream must not be used after the ZipFile object that created\r\n        has been deleted.\r\n\r\n        Note that if the ZipFile was created with a user-supplied InputStream object,\r\n        then all the streams which are created by this method will by trying to share\r\n        the same source stream, so cannot be safely used on  multiple threads! (But if\r\n        you create the ZipFile from a File or InputSource, then it is safe to do this).\r\n    */\r\n    InputStream* createStreamForEntry (const ZipEntry& entry);\r\n\r\n    //==============================================================================\r\n    /** Uncompresses all of the files in the zip file.\r\n\r\n        This will expand all the entries into a target directory. The relative\r\n        paths of the entries are used.\r\n\r\n        @param targetDirectory      the root folder to uncompress to\r\n        @param shouldOverwriteFiles whether to overwrite existing files with similarly-named ones\r\n        @returns success if the file is successfully unzipped\r\n    */\r\n    Result uncompressTo (const File& targetDirectory,\r\n                         bool shouldOverwriteFiles = true);\r\n\r\n    /** Uncompresses one of the entries from the zip file.\r\n\r\n        This will expand the entry and write it in a target directory. The entry's path is used to\r\n        determine which subfolder of the target should contain the new file.\r\n\r\n        @param index                the index of the entry to uncompress - this must be a valid index\r\n                                    between 0 and (getNumEntries() - 1).\r\n        @param targetDirectory      the root folder to uncompress into\r\n        @param shouldOverwriteFiles whether to overwrite existing files with similarly-named ones\r\n        @returns success if all the files are successfully unzipped\r\n    */\r\n    Result uncompressEntry (int index,\r\n                            const File& targetDirectory,\r\n                            bool shouldOverwriteFiles = true);\r\n\r\n\r\n    //==============================================================================\r\n    /** Used to create a new zip file.\r\n\r\n        Create a ZipFile::Builder object, and call its addFile() method to add some files,\r\n        then you can write it to a stream with write().\r\n    */\r\n    class JUCE_API  Builder\r\n    {\r\n    public:\r\n        /** Creates an empty builder object. */\r\n        Builder();\r\n\r\n        /** Destructor. */\r\n        ~Builder();\r\n\r\n        /** Adds a file to the list of items which will be added to the archive.\r\n            The file isn't read immediately: the files will be read later when the writeToStream()\r\n            method is called.\r\n\r\n            The compressionLevel can be between 0 (no compression), and 9 (maximum compression).\r\n            If the storedPathName parameter is specified, you can customise the partial pathname that\r\n            will be stored for this file.\r\n        */\r\n        void addFile (const File& fileToAdd, int compressionLevel,\r\n                      const String& storedPathName = String());\r\n\r\n        /** Adds a stream to the list of items which will be added to the archive.\r\n\r\n            @param streamToRead this stream isn't read immediately - a pointer to the stream is\r\n                                stored, then used later when the writeToStream() method is called, and\r\n                                deleted by the Builder object when no longer needed, so be very careful\r\n                                about its lifetime and the lifetime of any objects on which it depends!\r\n                                This must not be null.\r\n            @param compressionLevel     this can be between 0 (no compression), and 9 (maximum compression).\r\n            @param storedPathName       the partial pathname that will be stored for this file\r\n            @param fileModificationTime the timestamp that will be stored as the last modification time\r\n                                        of this entry\r\n        */\r\n        void addEntry (InputStream* streamToRead, int compressionLevel,\r\n                       const String& storedPathName, Time fileModificationTime);\r\n\r\n        /** Generates the zip file, writing it to the specified stream.\r\n            If the progress parameter is non-null, it will be updated with an approximate\r\n            progress status between 0 and 1.0\r\n        */\r\n        bool writeToStream (OutputStream& target, double* progress) const;\r\n\r\n        //==============================================================================\r\n    private:\r\n        struct Item;\r\n        OwnedArray<Item> items;\r\n\r\n        JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (Builder)\r\n    };\r\n\r\nprivate:\r\n    //==============================================================================\r\n    struct ZipInputStream;\r\n    struct ZipEntryHolder;\r\n\r\n    OwnedArray<ZipEntryHolder> entries;\r\n    CriticalSection lock;\r\n    InputStream* inputStream = nullptr;\r\n    std::unique_ptr<InputStream> streamToDelete;\r\n    std::unique_ptr<InputSource> inputSource;\r\n\r\n   #if JUCE_DEBUG\r\n    struct OpenStreamCounter\r\n    {\r\n        OpenStreamCounter() = default;\r\n        ~OpenStreamCounter();\r\n\r\n        int numOpenStreams = 0;\r\n    };\r\n\r\n    OpenStreamCounter streamCounter;\r\n   #endif\r\n\r\n    void init();\r\n\r\n    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ZipFile)\r\n};\r\n\r\n} // namespace juce\r\n"], "fixing_code": ["/*\r\n  ==============================================================================\r\n\r\n   This file is part of the JUCE library.\r\n   Copyright (c) 2020 - Raw Material Software Limited\r\n\r\n   JUCE is an open source library subject to commercial or open-source\r\n   licensing.\r\n\r\n   The code included in this file is provided under the terms of the ISC license\r\n   http://www.isc.org/downloads/software-support-policy/isc-license. Permission\r\n   To use, copy, modify, and/or distribute this software for any purpose with or\r\n   without fee is hereby granted provided that the above copyright notice and\r\n   this permission notice appear in all copies.\r\n\r\n   JUCE IS PROVIDED \"AS IS\" WITHOUT ANY WARRANTY, AND ALL WARRANTIES, WHETHER\r\n   EXPRESSED OR IMPLIED, INCLUDING MERCHANTABILITY AND FITNESS FOR PURPOSE, ARE\r\n   DISCLAIMED.\r\n\r\n  ==============================================================================\r\n*/\r\n\r\nnamespace juce\r\n{\r\n\r\nstatic File createTempFile (const File& parentDirectory, String name,\r\n                            const String& suffix, int optionFlags)\r\n{\r\n    if ((optionFlags & TemporaryFile::useHiddenFile) != 0)\r\n        name = \".\" + name;\r\n\r\n    return parentDirectory.getNonexistentChildFile (name, suffix, (optionFlags & TemporaryFile::putNumbersInBrackets) != 0);\r\n}\r\n\r\nTemporaryFile::TemporaryFile (const String& suffix, const int optionFlags)\r\n    : temporaryFile (createTempFile (File::getSpecialLocation (File::tempDirectory),\r\n                                     \"temp_\" + String::toHexString (Random::getSystemRandom().nextInt()),\r\n                                     suffix, optionFlags)),\r\n      targetFile()\r\n{\r\n}\r\n\r\nTemporaryFile::TemporaryFile (const File& target, const int optionFlags)\r\n    : temporaryFile (createTempFile (target.getParentDirectory(),\r\n                                     target.getFileNameWithoutExtension()\r\n                                       + \"_temp\" + String::toHexString (Random::getSystemRandom().nextInt()),\r\n                                     target.getFileExtension(), optionFlags)),\r\n      targetFile (target)\r\n{\r\n    // If you use this constructor, you need to give it a valid target file!\r\n    jassert (targetFile != File());\r\n}\r\n\r\nTemporaryFile::TemporaryFile (const File& target, const File& temporary)\r\n    : temporaryFile (temporary), targetFile (target)\r\n{\r\n}\r\n\r\nTemporaryFile::~TemporaryFile()\r\n{\r\n    if (! deleteTemporaryFile())\r\n    {\r\n        /* Failed to delete our temporary file! The most likely reason for this would be\r\n           that you've not closed an output stream that was being used to write to file.\r\n\r\n           If you find that something beyond your control is changing permissions on\r\n           your temporary files and preventing them from being deleted, you may want to\r\n           call TemporaryFile::deleteTemporaryFile() to detect those error cases and\r\n           handle them appropriately.\r\n        */\r\n        jassertfalse;\r\n    }\r\n}\r\n\r\n//==============================================================================\r\nbool TemporaryFile::overwriteTargetFileWithTemporary() const\r\n{\r\n    // This method only works if you created this object with the constructor\r\n    // that takes a target file!\r\n    jassert (targetFile != File());\r\n\r\n    if (temporaryFile.exists())\r\n    {\r\n        // Have a few attempts at overwriting the file before giving up..\r\n        for (int i = 5; --i >= 0;)\r\n        {\r\n            if (temporaryFile.replaceFileIn (targetFile))\r\n                return true;\r\n\r\n            Thread::sleep (100);\r\n        }\r\n    }\r\n    else\r\n    {\r\n        // There's no temporary file to use. If your write failed, you should\r\n        // probably check, and not bother calling this method.\r\n        jassertfalse;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nbool TemporaryFile::deleteTemporaryFile() const\r\n{\r\n    // Have a few attempts at deleting the file before giving up..\r\n    for (int i = 5; --i >= 0;)\r\n    {\r\n        if (temporaryFile.isDirectory() ? temporaryFile.deleteRecursively() : temporaryFile.deleteFile())\r\n            return true;\r\n\r\n        Thread::sleep (50);\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n} // namespace juce\r\n", "/*\r\n  ==============================================================================\r\n\r\n   This file is part of the JUCE library.\r\n   Copyright (c) 2020 - Raw Material Software Limited\r\n\r\n   JUCE is an open source library subject to commercial or open-source\r\n   licensing.\r\n\r\n   The code included in this file is provided under the terms of the ISC license\r\n   http://www.isc.org/downloads/software-support-policy/isc-license. Permission\r\n   To use, copy, modify, and/or distribute this software for any purpose with or\r\n   without fee is hereby granted provided that the above copyright notice and\r\n   this permission notice appear in all copies.\r\n\r\n   JUCE IS PROVIDED \"AS IS\" WITHOUT ANY WARRANTY, AND ALL WARRANTIES, WHETHER\r\n   EXPRESSED OR IMPLIED, INCLUDING MERCHANTABILITY AND FITNESS FOR PURPOSE, ARE\r\n   DISCLAIMED.\r\n\r\n  ==============================================================================\r\n*/\r\n\r\nnamespace juce\r\n{\r\n\r\ninline uint16 readUnalignedLittleEndianShort (const void* buffer)\r\n{\r\n    auto data = readUnaligned<uint16> (buffer);\r\n    return ByteOrder::littleEndianShort (&data);\r\n}\r\n\r\ninline uint32 readUnalignedLittleEndianInt (const void* buffer)\r\n{\r\n    auto data = readUnaligned<uint32> (buffer);\r\n    return ByteOrder::littleEndianInt (&data);\r\n}\r\n\r\nstruct ZipFile::ZipEntryHolder\r\n{\r\n    ZipEntryHolder (const char* buffer, int fileNameLen)\r\n    {\r\n        isCompressed           = readUnalignedLittleEndianShort (buffer + 10) != 0;\r\n        entry.fileTime         = parseFileTime (readUnalignedLittleEndianShort (buffer + 12),\r\n                                                readUnalignedLittleEndianShort (buffer + 14));\r\n        compressedSize         = (int64) readUnalignedLittleEndianInt (buffer + 20);\r\n        entry.uncompressedSize = (int64) readUnalignedLittleEndianInt (buffer + 24);\r\n        streamOffset           = (int64) readUnalignedLittleEndianInt (buffer + 42);\r\n\r\n        entry.externalFileAttributes = readUnalignedLittleEndianInt (buffer + 38);\r\n        auto fileType = (entry.externalFileAttributes >> 28) & 0xf;\r\n        entry.isSymbolicLink = (fileType == 0xA);\r\n\r\n        entry.filename = String::fromUTF8 (buffer + 46, fileNameLen);\r\n    }\r\n\r\n    static Time parseFileTime (uint32 time, uint32 date) noexcept\r\n    {\r\n        auto year      = (int) (1980 + (date >> 9));\r\n        auto month     = (int) (((date >> 5) & 15) - 1);\r\n        auto day       = (int) (date & 31);\r\n        auto hours     = (int) time >> 11;\r\n        auto minutes   = (int) ((time >> 5) & 63);\r\n        auto seconds   = (int) ((time & 31) << 1);\r\n\r\n        return { year, month, day, hours, minutes, seconds };\r\n    }\r\n\r\n    ZipEntry entry;\r\n    int64 streamOffset, compressedSize;\r\n    bool isCompressed;\r\n};\r\n\r\n//==============================================================================\r\nstatic int64 findCentralDirectoryFileHeader (InputStream& input, int& numEntries)\r\n{\r\n    BufferedInputStream in (input, 8192);\r\n\r\n    in.setPosition (in.getTotalLength());\r\n    auto pos = in.getPosition();\r\n    auto lowestPos = jmax ((int64) 0, pos - 1048576);\r\n    char buffer[32] = {};\r\n\r\n    while (pos > lowestPos)\r\n    {\r\n        in.setPosition (pos - 22);\r\n        pos = in.getPosition();\r\n        memcpy (buffer + 22, buffer, 4);\r\n\r\n        if (in.read (buffer, 22) != 22)\r\n            return 0;\r\n\r\n        for (int i = 0; i < 22; ++i)\r\n        {\r\n            if (readUnalignedLittleEndianInt (buffer + i) == 0x06054b50)\r\n            {\r\n                in.setPosition (pos + i);\r\n                in.read (buffer, 22);\r\n                numEntries = readUnalignedLittleEndianShort (buffer + 10);\r\n                auto offset = (int64) readUnalignedLittleEndianInt (buffer + 16);\r\n\r\n                if (offset >= 4)\r\n                {\r\n                    in.setPosition (offset);\r\n\r\n                    // This is a workaround for some zip files which seem to contain the\r\n                    // wrong offset for the central directory - instead of including the\r\n                    // header, they point to the byte immediately after it.\r\n                    if (in.readInt() != 0x02014b50)\r\n                    {\r\n                        in.setPosition (offset - 4);\r\n\r\n                        if (in.readInt() == 0x02014b50)\r\n                            offset -= 4;\r\n                    }\r\n                }\r\n\r\n                return offset;\r\n            }\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\nstatic bool hasSymbolicPart (const File& root, const File& f)\r\n{\r\n    jassert (root == f || f.isAChildOf (root));\r\n\r\n    for (auto p = f; p != root; p = p.getParentDirectory())\r\n    {\r\n        if (p.isSymbolicLink())\r\n            return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n//==============================================================================\r\nstruct ZipFile::ZipInputStream  : public InputStream\r\n{\r\n    ZipInputStream (ZipFile& zf, const ZipFile::ZipEntryHolder& zei)\r\n        : file (zf),\r\n          zipEntryHolder (zei),\r\n          inputStream (zf.inputStream)\r\n    {\r\n        if (zf.inputSource != nullptr)\r\n        {\r\n            streamToDelete.reset (file.inputSource->createInputStream());\r\n            inputStream = streamToDelete.get();\r\n        }\r\n        else\r\n        {\r\n           #if JUCE_DEBUG\r\n            zf.streamCounter.numOpenStreams++;\r\n           #endif\r\n        }\r\n\r\n        char buffer[30];\r\n\r\n        if (inputStream != nullptr\r\n             && inputStream->setPosition (zei.streamOffset)\r\n             && inputStream->read (buffer, 30) == 30\r\n             && ByteOrder::littleEndianInt (buffer) == 0x04034b50)\r\n        {\r\n            headerSize = 30 + ByteOrder::littleEndianShort (buffer + 26)\r\n                            + ByteOrder::littleEndianShort (buffer + 28);\r\n        }\r\n    }\r\n\r\n    ~ZipInputStream() override\r\n    {\r\n       #if JUCE_DEBUG\r\n        if (inputStream != nullptr && inputStream == file.inputStream)\r\n            file.streamCounter.numOpenStreams--;\r\n       #endif\r\n    }\r\n\r\n    int64 getTotalLength() override\r\n    {\r\n        return zipEntryHolder.compressedSize;\r\n    }\r\n\r\n    int read (void* buffer, int howMany) override\r\n    {\r\n        if (headerSize <= 0)\r\n            return 0;\r\n\r\n        howMany = (int) jmin ((int64) howMany, zipEntryHolder.compressedSize - pos);\r\n\r\n        if (inputStream == nullptr)\r\n            return 0;\r\n\r\n        int num;\r\n\r\n        if (inputStream == file.inputStream)\r\n        {\r\n            const ScopedLock sl (file.lock);\r\n            inputStream->setPosition (pos + zipEntryHolder.streamOffset + headerSize);\r\n            num = inputStream->read (buffer, howMany);\r\n        }\r\n        else\r\n        {\r\n            inputStream->setPosition (pos + zipEntryHolder.streamOffset + headerSize);\r\n            num = inputStream->read (buffer, howMany);\r\n        }\r\n\r\n        pos += num;\r\n        return num;\r\n    }\r\n\r\n    bool isExhausted() override\r\n    {\r\n        return headerSize <= 0 || pos >= zipEntryHolder.compressedSize;\r\n    }\r\n\r\n    int64 getPosition() override\r\n    {\r\n        return pos;\r\n    }\r\n\r\n    bool setPosition (int64 newPos) override\r\n    {\r\n        pos = jlimit ((int64) 0, zipEntryHolder.compressedSize, newPos);\r\n        return true;\r\n    }\r\n\r\nprivate:\r\n    ZipFile& file;\r\n    ZipEntryHolder zipEntryHolder;\r\n    int64 pos = 0;\r\n    int headerSize = 0;\r\n    InputStream* inputStream;\r\n    std::unique_ptr<InputStream> streamToDelete;\r\n\r\n    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ZipInputStream)\r\n};\r\n\r\n\r\n//==============================================================================\r\nZipFile::ZipFile (InputStream* stream, bool deleteStreamWhenDestroyed)\r\n   : inputStream (stream)\r\n{\r\n    if (deleteStreamWhenDestroyed)\r\n        streamToDelete.reset (inputStream);\r\n\r\n    init();\r\n}\r\n\r\nZipFile::ZipFile (InputStream& stream)  : inputStream (&stream)\r\n{\r\n    init();\r\n}\r\n\r\nZipFile::ZipFile (const File& file)  : inputSource (new FileInputSource (file))\r\n{\r\n    init();\r\n}\r\n\r\nZipFile::ZipFile (InputSource* source)  : inputSource (source)\r\n{\r\n    init();\r\n}\r\n\r\nZipFile::~ZipFile()\r\n{\r\n    entries.clear();\r\n}\r\n\r\n#if JUCE_DEBUG\r\nZipFile::OpenStreamCounter::~OpenStreamCounter()\r\n{\r\n    /* If you hit this assertion, it means you've created a stream to read one of the items in the\r\n       zipfile, but you've forgotten to delete that stream object before deleting the file..\r\n       Streams can't be kept open after the file is deleted because they need to share the input\r\n       stream that is managed by the ZipFile object.\r\n    */\r\n    jassert (numOpenStreams == 0);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\nint ZipFile::getNumEntries() const noexcept\r\n{\r\n    return entries.size();\r\n}\r\n\r\nconst ZipFile::ZipEntry* ZipFile::getEntry (const int index) const noexcept\r\n{\r\n    if (auto* zei = entries[index])\r\n        return &(zei->entry);\r\n\r\n    return nullptr;\r\n}\r\n\r\nint ZipFile::getIndexOfFileName (const String& fileName, bool ignoreCase) const noexcept\r\n{\r\n    for (int i = 0; i < entries.size(); ++i)\r\n    {\r\n        auto& entryFilename = entries.getUnchecked (i)->entry.filename;\r\n\r\n        if (ignoreCase ? entryFilename.equalsIgnoreCase (fileName)\r\n                       : entryFilename == fileName)\r\n            return i;\r\n    }\r\n\r\n    return -1;\r\n}\r\n\r\nconst ZipFile::ZipEntry* ZipFile::getEntry (const String& fileName, bool ignoreCase) const noexcept\r\n{\r\n    return getEntry (getIndexOfFileName (fileName, ignoreCase));\r\n}\r\n\r\nInputStream* ZipFile::createStreamForEntry (const int index)\r\n{\r\n    InputStream* stream = nullptr;\r\n\r\n    if (auto* zei = entries[index])\r\n    {\r\n        stream = new ZipInputStream (*this, *zei);\r\n\r\n        if (zei->isCompressed)\r\n        {\r\n            stream = new GZIPDecompressorInputStream (stream, true,\r\n                                                      GZIPDecompressorInputStream::deflateFormat,\r\n                                                      zei->entry.uncompressedSize);\r\n\r\n            // (much faster to unzip in big blocks using a buffer..)\r\n            stream = new BufferedInputStream (stream, 32768, true);\r\n        }\r\n    }\r\n\r\n    return stream;\r\n}\r\n\r\nInputStream* ZipFile::createStreamForEntry (const ZipEntry& entry)\r\n{\r\n    for (int i = 0; i < entries.size(); ++i)\r\n        if (&entries.getUnchecked (i)->entry == &entry)\r\n            return createStreamForEntry (i);\r\n\r\n    return nullptr;\r\n}\r\n\r\nvoid ZipFile::sortEntriesByFilename()\r\n{\r\n    std::sort (entries.begin(), entries.end(),\r\n               [] (const ZipEntryHolder* e1, const ZipEntryHolder* e2) { return e1->entry.filename < e2->entry.filename; });\r\n}\r\n\r\n//==============================================================================\r\nvoid ZipFile::init()\r\n{\r\n    std::unique_ptr<InputStream> toDelete;\r\n    InputStream* in = inputStream;\r\n\r\n    if (inputSource != nullptr)\r\n    {\r\n        in = inputSource->createInputStream();\r\n        toDelete.reset (in);\r\n    }\r\n\r\n    if (in != nullptr)\r\n    {\r\n        int numEntries = 0;\r\n        auto centralDirectoryPos = findCentralDirectoryFileHeader (*in, numEntries);\r\n\r\n        if (centralDirectoryPos >= 0 && centralDirectoryPos < in->getTotalLength())\r\n        {\r\n            auto size = (size_t) (in->getTotalLength() - centralDirectoryPos);\r\n\r\n            in->setPosition (centralDirectoryPos);\r\n            MemoryBlock headerData;\r\n\r\n            if (in->readIntoMemoryBlock (headerData, (ssize_t) size) == size)\r\n            {\r\n                size_t pos = 0;\r\n\r\n                for (int i = 0; i < numEntries; ++i)\r\n                {\r\n                    if (pos + 46 > size)\r\n                        break;\r\n\r\n                    auto* buffer = static_cast<const char*> (headerData.getData()) + pos;\r\n                    auto fileNameLen = readUnalignedLittleEndianShort (buffer + 28u);\r\n\r\n                    if (pos + 46 + fileNameLen > size)\r\n                        break;\r\n\r\n                    entries.add (new ZipEntryHolder (buffer, fileNameLen));\r\n\r\n                    pos += 46u + fileNameLen\r\n                            + readUnalignedLittleEndianShort (buffer + 30u)\r\n                            + readUnalignedLittleEndianShort (buffer + 32u);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nResult ZipFile::uncompressTo (const File& targetDirectory,\r\n                              const bool shouldOverwriteFiles)\r\n{\r\n    for (int i = 0; i < entries.size(); ++i)\r\n    {\r\n        auto result = uncompressEntry (i, targetDirectory, shouldOverwriteFiles);\r\n\r\n        if (result.failed())\r\n            return result;\r\n    }\r\n\r\n    return Result::ok();\r\n}\r\n\r\nResult ZipFile::uncompressEntry (int index, const File& targetDirectory, bool shouldOverwriteFiles)\r\n{\r\n    return uncompressEntry (index,\r\n                            targetDirectory,\r\n                            shouldOverwriteFiles ? OverwriteFiles::yes : OverwriteFiles::no,\r\n                            FollowSymlinks::no);\r\n}\r\n\r\nResult ZipFile::uncompressEntry (int index, const File& targetDirectory, OverwriteFiles overwriteFiles, FollowSymlinks followSymlinks)\r\n{\r\n    auto* zei = entries.getUnchecked (index);\r\n\r\n   #if JUCE_WINDOWS\r\n    auto entryPath = zei->entry.filename;\r\n   #else\r\n    auto entryPath = zei->entry.filename.replaceCharacter ('\\\\', '/');\r\n   #endif\r\n\r\n    if (entryPath.isEmpty())\r\n        return Result::ok();\r\n\r\n    auto targetFile = targetDirectory.getChildFile (entryPath);\r\n\r\n    if (! targetFile.isAChildOf (targetDirectory))\r\n        return Result::fail (\"Entry \" + entryPath + \" is outside the target directory\");\r\n\r\n    if (entryPath.endsWithChar ('/') || entryPath.endsWithChar ('\\\\'))\r\n        return targetFile.createDirectory(); // (entry is a directory, not a file)\r\n\r\n    std::unique_ptr<InputStream> in (createStreamForEntry (index));\r\n\r\n    if (in == nullptr)\r\n        return Result::fail (\"Failed to open the zip file for reading\");\r\n\r\n    if (targetFile.exists())\r\n    {\r\n        if (overwriteFiles == OverwriteFiles::no)\r\n            return Result::ok();\r\n\r\n        if (! targetFile.deleteFile())\r\n            return Result::fail (\"Failed to write to target file: \" + targetFile.getFullPathName());\r\n    }\r\n\r\n    if (followSymlinks == FollowSymlinks::no && hasSymbolicPart (targetDirectory, targetFile.getParentDirectory()))\r\n        return Result::fail (\"Parent directory leads through symlink for target file: \" + targetFile.getFullPathName());\r\n\r\n    if (! targetFile.getParentDirectory().createDirectory())\r\n        return Result::fail (\"Failed to create target folder: \" + targetFile.getParentDirectory().getFullPathName());\r\n\r\n    if (zei->entry.isSymbolicLink)\r\n    {\r\n        String originalFilePath (in->readEntireStreamAsString()\r\n                                    .replaceCharacter (L'/', File::getSeparatorChar()));\r\n\r\n        if (! File::createSymbolicLink (targetFile, originalFilePath, true))\r\n            return Result::fail (\"Failed to create symbolic link: \" + originalFilePath);\r\n    }\r\n    else\r\n    {\r\n        FileOutputStream out (targetFile);\r\n\r\n        if (out.failedToOpen())\r\n            return Result::fail (\"Failed to write to target file: \" + targetFile.getFullPathName());\r\n\r\n        out << *in;\r\n    }\r\n\r\n    targetFile.setCreationTime (zei->entry.fileTime);\r\n    targetFile.setLastModificationTime (zei->entry.fileTime);\r\n    targetFile.setLastAccessTime (zei->entry.fileTime);\r\n\r\n    return Result::ok();\r\n}\r\n\r\n\r\n//==============================================================================\r\nstruct ZipFile::Builder::Item\r\n{\r\n    Item (const File& f, InputStream* s, int compression, const String& storedPath, Time time)\r\n        : file (f), stream (s), storedPathname (storedPath), fileTime (time), compressionLevel (compression)\r\n    {\r\n        symbolicLink = (file.exists() && file.isSymbolicLink());\r\n    }\r\n\r\n    bool writeData (OutputStream& target, const int64 overallStartPosition)\r\n    {\r\n        MemoryOutputStream compressedData ((size_t) file.getSize());\r\n\r\n        if (symbolicLink)\r\n        {\r\n            auto relativePath = file.getNativeLinkedTarget().replaceCharacter (File::getSeparatorChar(), L'/');\r\n\r\n            uncompressedSize = relativePath.length();\r\n\r\n            checksum = zlibNamespace::crc32 (0, (uint8_t*) relativePath.toRawUTF8(), (unsigned int) uncompressedSize);\r\n            compressedData << relativePath;\r\n        }\r\n        else if (compressionLevel > 0)\r\n        {\r\n            GZIPCompressorOutputStream compressor (compressedData, compressionLevel,\r\n                                                   GZIPCompressorOutputStream::windowBitsRaw);\r\n            if (! writeSource (compressor))\r\n                return false;\r\n        }\r\n        else\r\n        {\r\n            if (! writeSource (compressedData))\r\n                return false;\r\n        }\r\n\r\n        compressedSize = (int64) compressedData.getDataSize();\r\n        headerStart = target.getPosition() - overallStartPosition;\r\n\r\n        target.writeInt (0x04034b50);\r\n        writeFlagsAndSizes (target);\r\n        target << storedPathname\r\n               << compressedData;\r\n\r\n        return true;\r\n    }\r\n\r\n    bool writeDirectoryEntry (OutputStream& target)\r\n    {\r\n        target.writeInt (0x02014b50);\r\n        target.writeShort (symbolicLink ? 0x0314 : 0x0014);\r\n        writeFlagsAndSizes (target);\r\n        target.writeShort (0); // comment length\r\n        target.writeShort (0); // start disk num\r\n        target.writeShort (0); // internal attributes\r\n        target.writeInt ((int) (symbolicLink ? 0xA1ED0000 : 0)); // external attributes\r\n        target.writeInt ((int) (uint32) headerStart);\r\n        target << storedPathname;\r\n\r\n        return true;\r\n    }\r\n\r\nprivate:\r\n    const File file;\r\n    std::unique_ptr<InputStream> stream;\r\n    String storedPathname;\r\n    Time fileTime;\r\n    int64 compressedSize = 0, uncompressedSize = 0, headerStart = 0;\r\n    int compressionLevel = 0;\r\n    unsigned long checksum = 0;\r\n    bool symbolicLink = false;\r\n\r\n    static void writeTimeAndDate (OutputStream& target, Time t)\r\n    {\r\n        target.writeShort ((short) (t.getSeconds() + (t.getMinutes() << 5) + (t.getHours() << 11)));\r\n        target.writeShort ((short) (t.getDayOfMonth() + ((t.getMonth() + 1) << 5) + ((t.getYear() - 1980) << 9)));\r\n    }\r\n\r\n    bool writeSource (OutputStream& target)\r\n    {\r\n        if (stream == nullptr)\r\n        {\r\n            stream = file.createInputStream();\r\n\r\n            if (stream == nullptr)\r\n                return false;\r\n        }\r\n\r\n        checksum = 0;\r\n        uncompressedSize = 0;\r\n        const int bufferSize = 4096;\r\n        HeapBlock<unsigned char> buffer (bufferSize);\r\n\r\n        while (! stream->isExhausted())\r\n        {\r\n            auto bytesRead = stream->read (buffer, bufferSize);\r\n\r\n            if (bytesRead < 0)\r\n                return false;\r\n\r\n            checksum = zlibNamespace::crc32 (checksum, buffer, (unsigned int) bytesRead);\r\n            target.write (buffer, (size_t) bytesRead);\r\n            uncompressedSize += bytesRead;\r\n        }\r\n\r\n        stream.reset();\r\n        return true;\r\n    }\r\n\r\n    void writeFlagsAndSizes (OutputStream& target) const\r\n    {\r\n        target.writeShort (10); // version needed\r\n        target.writeShort ((short) (1 << 11)); // this flag indicates UTF-8 filename encoding\r\n        target.writeShort ((! symbolicLink && compressionLevel > 0) ? (short) 8 : (short) 0); //symlink target path is not compressed\r\n        writeTimeAndDate (target, fileTime);\r\n        target.writeInt ((int) checksum);\r\n        target.writeInt ((int) (uint32) compressedSize);\r\n        target.writeInt ((int) (uint32) uncompressedSize);\r\n        target.writeShort (static_cast<short> (storedPathname.toUTF8().sizeInBytes() - 1));\r\n        target.writeShort (0); // extra field length\r\n    }\r\n\r\n    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (Item)\r\n};\r\n\r\n//==============================================================================\r\nZipFile::Builder::Builder() {}\r\nZipFile::Builder::~Builder() {}\r\n\r\nvoid ZipFile::Builder::addFile (const File& file, int compression, const String& path)\r\n{\r\n    items.add (new Item (file, nullptr, compression,\r\n                         path.isEmpty() ? file.getFileName() : path,\r\n                         file.getLastModificationTime()));\r\n}\r\n\r\nvoid ZipFile::Builder::addEntry (InputStream* stream, int compression, const String& path, Time time)\r\n{\r\n    jassert (stream != nullptr); // must not be null!\r\n    jassert (path.isNotEmpty());\r\n    items.add (new Item ({}, stream, compression, path, time));\r\n}\r\n\r\nbool ZipFile::Builder::writeToStream (OutputStream& target, double* const progress) const\r\n{\r\n    auto fileStart = target.getPosition();\r\n\r\n    for (int i = 0; i < items.size(); ++i)\r\n    {\r\n        if (progress != nullptr)\r\n            *progress = (i + 0.5) / items.size();\r\n\r\n        if (! items.getUnchecked (i)->writeData (target, fileStart))\r\n            return false;\r\n    }\r\n\r\n    auto directoryStart = target.getPosition();\r\n\r\n    for (auto* item : items)\r\n        if (! item->writeDirectoryEntry (target))\r\n            return false;\r\n\r\n    auto directoryEnd = target.getPosition();\r\n\r\n    target.writeInt (0x06054b50);\r\n    target.writeShort (0);\r\n    target.writeShort (0);\r\n    target.writeShort ((short) items.size());\r\n    target.writeShort ((short) items.size());\r\n    target.writeInt ((int) (directoryEnd - directoryStart));\r\n    target.writeInt ((int) (directoryStart - fileStart));\r\n    target.writeShort (0);\r\n\r\n    if (progress != nullptr)\r\n        *progress = 1.0;\r\n\r\n    return true;\r\n}\r\n\r\n\r\n//==============================================================================\r\n//==============================================================================\r\n#if JUCE_UNIT_TESTS\r\n\r\nstruct ZIPTests   : public UnitTest\r\n{\r\n    ZIPTests()\r\n        : UnitTest (\"ZIP\", UnitTestCategories::compression)\r\n    {}\r\n\r\n    static MemoryBlock createZipMemoryBlock (const StringArray& entryNames)\r\n    {\r\n        ZipFile::Builder builder;\r\n        HashMap<String, MemoryBlock> blocks;\r\n\r\n        for (auto& entryName : entryNames)\r\n        {\r\n            auto& block = blocks.getReference (entryName);\r\n            MemoryOutputStream mo (block, false);\r\n            mo << entryName;\r\n            mo.flush();\r\n            builder.addEntry (new MemoryInputStream (block, false), 9, entryName, Time::getCurrentTime());\r\n        }\r\n\r\n        MemoryBlock data;\r\n        MemoryOutputStream mo (data, false);\r\n        builder.writeToStream (mo, nullptr);\r\n\r\n        return data;\r\n    }\r\n\r\n    void runZipSlipTest()\r\n    {\r\n        const std::map<String, bool> testCases = { { \"a\",                    true  },\r\n#if JUCE_WINDOWS\r\n                                                   { \"C:/b\",                 false },\r\n#else\r\n                                                   { \"/b\",                   false },\r\n#endif\r\n                                                   { \"c/d\",                  true  },\r\n                                                   { \"../e/f\",               false },\r\n                                                   { \"../../g/h\",            false },\r\n                                                   { \"i/../j\",               true  },\r\n                                                   { \"k/l/../\",              true  },\r\n                                                   { \"m/n/../../\",           false },\r\n                                                   { \"o/p/../../../\",        false } };\r\n\r\n        StringArray entryNames;\r\n\r\n        for (const auto& testCase : testCases)\r\n            entryNames.add (testCase.first);\r\n\r\n        TemporaryFile tmpDir;\r\n        tmpDir.getFile().createDirectory();\r\n        auto data = createZipMemoryBlock (entryNames);\r\n        MemoryInputStream mi (data, false);\r\n        ZipFile zip (mi);\r\n\r\n        for (int i = 0; i < zip.getNumEntries(); ++i)\r\n        {\r\n            const auto result = zip.uncompressEntry (i, tmpDir.getFile());\r\n            const auto caseIt = testCases.find (zip.getEntry (i)->filename);\r\n\r\n            if (caseIt != testCases.end())\r\n            {\r\n                expect (result.wasOk() == caseIt->second,\r\n                        zip.getEntry (i)->filename + \" was unexpectedly \" + (result.wasOk() ? \"OK\" : \"not OK\"));\r\n            }\r\n            else\r\n            {\r\n                expect (false);\r\n            }\r\n        }\r\n    }\r\n\r\n    void runTest() override\r\n    {\r\n        beginTest (\"ZIP\");\r\n\r\n        StringArray entryNames { \"first\", \"second\", \"third\" };\r\n        auto data = createZipMemoryBlock (entryNames);\r\n        MemoryInputStream mi (data, false);\r\n        ZipFile zip (mi);\r\n\r\n        expectEquals (zip.getNumEntries(), entryNames.size());\r\n\r\n        for (auto& entryName : entryNames)\r\n        {\r\n            auto* entry = zip.getEntry (entryName);\r\n            std::unique_ptr<InputStream> input (zip.createStreamForEntry (*entry));\r\n            expectEquals (input->readEntireStreamAsString(), entryName);\r\n        }\r\n\r\n        beginTest (\"ZipSlip\");\r\n        runZipSlipTest();\r\n    }\r\n};\r\n\r\nstatic ZIPTests zipTests;\r\n\r\n#endif\r\n\r\n} // namespace juce\r\n", "/*\r\n  ==============================================================================\r\n\r\n   This file is part of the JUCE library.\r\n   Copyright (c) 2020 - Raw Material Software Limited\r\n\r\n   JUCE is an open source library subject to commercial or open-source\r\n   licensing.\r\n\r\n   The code included in this file is provided under the terms of the ISC license\r\n   http://www.isc.org/downloads/software-support-policy/isc-license. Permission\r\n   To use, copy, modify, and/or distribute this software for any purpose with or\r\n   without fee is hereby granted provided that the above copyright notice and\r\n   this permission notice appear in all copies.\r\n\r\n   JUCE IS PROVIDED \"AS IS\" WITHOUT ANY WARRANTY, AND ALL WARRANTIES, WHETHER\r\n   EXPRESSED OR IMPLIED, INCLUDING MERCHANTABILITY AND FITNESS FOR PURPOSE, ARE\r\n   DISCLAIMED.\r\n\r\n  ==============================================================================\r\n*/\r\n\r\nnamespace juce\r\n{\r\n\r\n//==============================================================================\r\n/**\r\n    Decodes a ZIP file from a stream.\r\n\r\n    This can enumerate the items in a ZIP file and can create suitable stream objects\r\n    to read each one.\r\n\r\n    @tags{Core}\r\n*/\r\nclass JUCE_API  ZipFile\r\n{\r\npublic:\r\n    /** Creates a ZipFile to read a specific file. */\r\n    explicit ZipFile (const File& file);\r\n\r\n    //==============================================================================\r\n    /** Creates a ZipFile for a given stream.\r\n\r\n        @param inputStream                  the stream to read from\r\n        @param deleteStreamWhenDestroyed    if set to true, the object passed-in\r\n                                            will be deleted when this ZipFile object is deleted\r\n    */\r\n    ZipFile (InputStream* inputStream, bool deleteStreamWhenDestroyed);\r\n\r\n    /** Creates a ZipFile for a given stream.\r\n        The stream will not be owned or deleted by this class - if you want the ZipFile to\r\n        manage the stream's lifetime, use the other constructor.\r\n    */\r\n    explicit ZipFile (InputStream& inputStream);\r\n\r\n    /** Creates a ZipFile for an input source.\r\n\r\n        The inputSource object will be owned by the zip file, which will delete\r\n        it later when not needed.\r\n    */\r\n    explicit ZipFile (InputSource* inputSource);\r\n\r\n    /** Destructor. */\r\n    ~ZipFile();\r\n\r\n    //==============================================================================\r\n    /**\r\n        Contains information about one of the entries in a ZipFile.\r\n\r\n        @see ZipFile::getEntry\r\n    */\r\n    struct ZipEntry\r\n    {\r\n        /** The name of the file, which may also include a partial pathname. */\r\n        String filename;\r\n\r\n        /** The file's original size. */\r\n        int64 uncompressedSize;\r\n\r\n        /** The last time the file was modified. */\r\n        Time fileTime;\r\n\r\n        /** True if the zip entry is a symbolic link. */\r\n        bool isSymbolicLink;\r\n\r\n        /** Platform specific data. Depending on how the zip file was created this\r\n            may contain macOS and Linux file types, permissions and\r\n            setuid/setgid/sticky bits.\r\n        */\r\n        uint32 externalFileAttributes;\r\n    };\r\n\r\n    //==============================================================================\r\n    /** Returns the number of items in the zip file. */\r\n    int getNumEntries() const noexcept;\r\n\r\n    /** Returns a structure that describes one of the entries in the zip file.\r\n        This may return a nullptr if the index is out of range.\r\n        @see ZipFile::ZipEntry\r\n    */\r\n    const ZipEntry* getEntry (int index) const noexcept;\r\n\r\n    /** Returns the index of the first entry with a given filename.\r\n        This uses a case-sensitive comparison to look for a filename in the\r\n        list of entries. It might return -1 if no match is found.\r\n\r\n        @see ZipFile::ZipEntry\r\n    */\r\n    int getIndexOfFileName (const String& fileName, bool ignoreCase = false) const noexcept;\r\n\r\n    /** Returns a structure that describes one of the entries in the zip file.\r\n\r\n        This uses a case-sensitive comparison to look for a filename in the\r\n        list of entries. It might return 0 if no match is found.\r\n\r\n        @see ZipFile::ZipEntry\r\n    */\r\n    const ZipEntry* getEntry (const String& fileName, bool ignoreCase = false) const noexcept;\r\n\r\n    /** Sorts the list of entries, based on the filename. */\r\n    void sortEntriesByFilename();\r\n\r\n    //==============================================================================\r\n    /** Creates a stream that can read from one of the zip file's entries.\r\n\r\n        The stream that is returned must be deleted by the caller (and\r\n        a nullptr might be returned if a stream can't be opened for some reason).\r\n\r\n        The stream must not be used after the ZipFile object that created\r\n        has been deleted.\r\n\r\n        Note that if the ZipFile was created with a user-supplied InputStream object,\r\n        then all the streams which are created by this method will by trying to share\r\n        the same source stream, so cannot be safely used on  multiple threads! (But if\r\n        you create the ZipFile from a File or InputSource, then it is safe to do this).\r\n    */\r\n    InputStream* createStreamForEntry (int index);\r\n\r\n    /** Creates a stream that can read from one of the zip file's entries.\r\n\r\n        The stream that is returned must be deleted by the caller (and\r\n        a nullptr might be returned if a stream can't be opened for some reason).\r\n\r\n        The stream must not be used after the ZipFile object that created\r\n        has been deleted.\r\n\r\n        Note that if the ZipFile was created with a user-supplied InputStream object,\r\n        then all the streams which are created by this method will by trying to share\r\n        the same source stream, so cannot be safely used on  multiple threads! (But if\r\n        you create the ZipFile from a File or InputSource, then it is safe to do this).\r\n    */\r\n    InputStream* createStreamForEntry (const ZipEntry& entry);\r\n\r\n    //==============================================================================\r\n    /** Uncompresses all of the files in the zip file.\r\n\r\n        This will expand all the entries into a target directory. The relative\r\n        paths of the entries are used.\r\n\r\n        @param targetDirectory      the root folder to uncompress to\r\n        @param shouldOverwriteFiles whether to overwrite existing files with similarly-named ones\r\n        @returns success if the file is successfully unzipped\r\n    */\r\n    Result uncompressTo (const File& targetDirectory,\r\n                         bool shouldOverwriteFiles = true);\r\n\r\n    /** Uncompresses one of the entries from the zip file.\r\n\r\n        This will expand the entry and write it in a target directory. The entry's path is used to\r\n        determine which subfolder of the target should contain the new file.\r\n\r\n        @param index                the index of the entry to uncompress - this must be a valid index\r\n                                    between 0 and (getNumEntries() - 1).\r\n        @param targetDirectory      the root folder to uncompress into\r\n        @param shouldOverwriteFiles whether to overwrite existing files with similarly-named ones\r\n        @returns success if all the files are successfully unzipped\r\n    */\r\n    Result uncompressEntry (int index,\r\n                            const File& targetDirectory,\r\n                            bool shouldOverwriteFiles = true);\r\n\r\n    enum class OverwriteFiles { no, yes };\r\n    enum class FollowSymlinks { no, yes };\r\n\r\n    /** Uncompresses one of the entries from the zip file.\r\n\r\n        This will expand the entry and write it in a target directory. The entry's path is used to\r\n        determine which subfolder of the target should contain the new file.\r\n\r\n        @param index                the index of the entry to uncompress - this must be a valid index\r\n                                    between 0 and (getNumEntries() - 1).\r\n        @param targetDirectory      the root folder to uncompress into\r\n        @param overwriteFiles       whether to overwrite existing files with similarly-named ones\r\n        @param followSymlinks       whether to follow symlinks inside the target directory\r\n        @returns success if all the files are successfully unzipped\r\n    */\r\n    Result uncompressEntry (int index,\r\n                            const File& targetDirectory,\r\n                            OverwriteFiles overwriteFiles,\r\n                            FollowSymlinks followSymlinks);\r\n\r\n    //==============================================================================\r\n    /** Used to create a new zip file.\r\n\r\n        Create a ZipFile::Builder object, and call its addFile() method to add some files,\r\n        then you can write it to a stream with write().\r\n    */\r\n    class JUCE_API  Builder\r\n    {\r\n    public:\r\n        /** Creates an empty builder object. */\r\n        Builder();\r\n\r\n        /** Destructor. */\r\n        ~Builder();\r\n\r\n        /** Adds a file to the list of items which will be added to the archive.\r\n            The file isn't read immediately: the files will be read later when the writeToStream()\r\n            method is called.\r\n\r\n            The compressionLevel can be between 0 (no compression), and 9 (maximum compression).\r\n            If the storedPathName parameter is specified, you can customise the partial pathname that\r\n            will be stored for this file.\r\n        */\r\n        void addFile (const File& fileToAdd, int compressionLevel,\r\n                      const String& storedPathName = String());\r\n\r\n        /** Adds a stream to the list of items which will be added to the archive.\r\n\r\n            @param streamToRead this stream isn't read immediately - a pointer to the stream is\r\n                                stored, then used later when the writeToStream() method is called, and\r\n                                deleted by the Builder object when no longer needed, so be very careful\r\n                                about its lifetime and the lifetime of any objects on which it depends!\r\n                                This must not be null.\r\n            @param compressionLevel     this can be between 0 (no compression), and 9 (maximum compression).\r\n            @param storedPathName       the partial pathname that will be stored for this file\r\n            @param fileModificationTime the timestamp that will be stored as the last modification time\r\n                                        of this entry\r\n        */\r\n        void addEntry (InputStream* streamToRead, int compressionLevel,\r\n                       const String& storedPathName, Time fileModificationTime);\r\n\r\n        /** Generates the zip file, writing it to the specified stream.\r\n            If the progress parameter is non-null, it will be updated with an approximate\r\n            progress status between 0 and 1.0\r\n        */\r\n        bool writeToStream (OutputStream& target, double* progress) const;\r\n\r\n        //==============================================================================\r\n    private:\r\n        struct Item;\r\n        OwnedArray<Item> items;\r\n\r\n        JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (Builder)\r\n    };\r\n\r\nprivate:\r\n    //==============================================================================\r\n    struct ZipInputStream;\r\n    struct ZipEntryHolder;\r\n\r\n    OwnedArray<ZipEntryHolder> entries;\r\n    CriticalSection lock;\r\n    InputStream* inputStream = nullptr;\r\n    std::unique_ptr<InputStream> streamToDelete;\r\n    std::unique_ptr<InputSource> inputSource;\r\n\r\n   #if JUCE_DEBUG\r\n    struct OpenStreamCounter\r\n    {\r\n        OpenStreamCounter() = default;\r\n        ~OpenStreamCounter();\r\n\r\n        int numOpenStreams = 0;\r\n    };\r\n\r\n    OpenStreamCounter streamCounter;\r\n   #endif\r\n\r\n    void init();\r\n\r\n    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ZipFile)\r\n};\r\n\r\n} // namespace juce\r\n"], "filenames": ["modules/juce_core/files/juce_TemporaryFile.cpp", "modules/juce_core/zip/juce_ZipFile.cpp", "modules/juce_core/zip/juce_ZipFile.h"], "buggy_code_start_loc": [108, 122, 181], "buggy_code_end_loc": [109, 683, 181], "fixing_code_start_loc": [108, 123, 182], "fixing_code_end_loc": [109, 764, 201], "type": "CWE-22", "message": "The package juce-framework/juce before 6.1.5 are vulnerable to Arbitrary File Write via Archive Extraction (Zip Slip) via the ZipFile::uncompressEntry function in juce_ZipFile.cpp. This vulnerability is triggered when the archive is extracted upon calling uncompressTo() on a ZipFile object.", "other": {"cve": {"id": "CVE-2021-23520", "sourceIdentifier": "report@snyk.io", "published": "2022-01-31T11:15:07.820", "lastModified": "2022-02-04T20:33:06.223", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The package juce-framework/juce before 6.1.5 are vulnerable to Arbitrary File Write via Archive Extraction (Zip Slip) via the ZipFile::uncompressEntry function in juce_ZipFile.cpp. This vulnerability is triggered when the archive is extracted upon calling uncompressTo() on a ZipFile object."}, {"lang": "es", "value": "El paquete juce-framework/juce versiones anteriores a 6.1.5, es vulnerable a una escritura arbitraria de archivos por medio de la extracci\u00f3n de archivos (Zip Slip) por medio de la funci\u00f3n ZipFile::uncompressEntry en el archivo juce_ZipFile.cpp. Esta vulnerabilidad es desencadenada cuando es extra\u00eddo el archivo al llamar a uncompressTo() en un objeto ZipFile"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:H/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:juce:juce:*:*:*:*:*:*:*:*", "versionEndExcluding": "6.1.5", "matchCriteriaId": "4F84CF05-0ECE-487B-8D76-61D92E46A891"}]}]}], "references": [{"url": "https://github.com/juce-framework/JUCE/commit/2e874e80cba0152201aff6a4d0dc407997d10a7f", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://snyk.io/research/zip-slip-vulnerability", "source": "report@snyk.io", "tags": ["Exploit", "Technical Description", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-UNMANAGED-JUCEFRAMEWORKJUCE-2388607", "source": "report@snyk.io", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/juce-framework/JUCE/commit/2e874e80cba0152201aff6a4d0dc407997d10a7f"}}