{"buggy_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * Handling of regular expressions: vim_regcomp(), vim_regexec(), vim_regsub()\n */\n\n// By default: do not create debugging logs or files related to regular\n// expressions, even when compiling with -DDEBUG.\n// Uncomment the second line to get the regexp debugging.\n#undef DEBUG\n// #define DEBUG\n\n#include \"vim.h\"\n\n#ifdef DEBUG\n// show/save debugging data when BT engine is used\n# define BT_REGEXP_DUMP\n// save the debugging data to a file instead of displaying it\n# define BT_REGEXP_LOG\n# define BT_REGEXP_DEBUG_LOG\n# define BT_REGEXP_DEBUG_LOG_NAME\t\"bt_regexp_debug.log\"\n#endif\n\n/*\n * Magic characters have a special meaning, they don't match literally.\n * Magic characters are negative.  This separates them from literal characters\n * (possibly multi-byte).  Only ASCII characters can be Magic.\n */\n#define Magic(x)\t((int)(x) - 256)\n#define un_Magic(x)\t((x) + 256)\n#define is_Magic(x)\t((x) < 0)\n\n    static int\nno_Magic(int x)\n{\n    if (is_Magic(x))\n\treturn un_Magic(x);\n    return x;\n}\n\n    static int\ntoggle_Magic(int x)\n{\n    if (is_Magic(x))\n\treturn un_Magic(x);\n    return Magic(x);\n}\n\n/*\n * The first byte of the BT regexp internal \"program\" is actually this magic\n * number; the start node begins in the second byte.  It's used to catch the\n * most severe mutilation of the program by the caller.\n */\n\n#define REGMAGIC\t0234\n\n/*\n * Utility definitions.\n */\n#define UCHARAT(p)\t((int)*(char_u *)(p))\n\n// Used for an error (down from) vim_regcomp(): give the error message, set\n// rc_did_emsg and return NULL\n#define EMSG_RET_NULL(m) return (emsg((m)), rc_did_emsg = TRUE, (void *)NULL)\n#define IEMSG_RET_NULL(m) return (iemsg((m)), rc_did_emsg = TRUE, (void *)NULL)\n#define EMSG_RET_FAIL(m) return (emsg((m)), rc_did_emsg = TRUE, FAIL)\n#define EMSG2_RET_NULL(m, c) return (semsg((const char *)(m), (c) ? \"\" : \"\\\\\"), rc_did_emsg = TRUE, (void *)NULL)\n#define EMSG3_RET_NULL(m, c, a) return (semsg((const char *)(m), (c) ? \"\" : \"\\\\\", (a)), rc_did_emsg = TRUE, (void *)NULL)\n#define EMSG2_RET_FAIL(m, c) return (semsg((const char *)(m), (c) ? \"\" : \"\\\\\"), rc_did_emsg = TRUE, FAIL)\n#define EMSG_ONE_RET_NULL EMSG2_RET_NULL(_(\"E369: invalid item in %s%%[]\"), reg_magic == MAGIC_ALL)\n\n\n#define MAX_LIMIT\t(32767L << 16L)\n\nstatic char_u e_missingbracket[] = N_(\"E769: Missing ] after %s[\");\nstatic char_u e_reverse_range[] = N_(\"E944: Reverse range in character class\");\nstatic char_u e_large_class[] = N_(\"E945: Range too large in character class\");\n#ifdef FEAT_SYN_HL\nstatic char_u e_z_not_allowed[] = N_(\"E66: \\\\z( not allowed here\");\nstatic char_u e_z1_not_allowed[] = N_(\"E67: \\\\z1 - \\\\z9 not allowed here\");\n#endif\nstatic char_u e_missing_sb[] = N_(\"E69: Missing ] after %s%%[\");\nstatic char_u e_empty_sb[]  = N_(\"E70: Empty %s%%[]\");\nstatic char_u e_recursive[]  = N_(\"E956: Cannot use pattern recursively\");\n\n#define NOT_MULTI\t0\n#define MULTI_ONE\t1\n#define MULTI_MULT\t2\n\n// return values for regmatch()\n#define RA_FAIL\t\t1\t// something failed, abort\n#define RA_CONT\t\t2\t// continue in inner loop\n#define RA_BREAK\t3\t// break inner loop\n#define RA_MATCH\t4\t// successful match\n#define RA_NOMATCH\t5\t// didn't match\n\n/*\n * Return NOT_MULTI if c is not a \"multi\" operator.\n * Return MULTI_ONE if c is a single \"multi\" operator.\n * Return MULTI_MULT if c is a multi \"multi\" operator.\n */\n    static int\nre_multi_type(int c)\n{\n    if (c == Magic('@') || c == Magic('=') || c == Magic('?'))\n\treturn MULTI_ONE;\n    if (c == Magic('*') || c == Magic('+') || c == Magic('{'))\n\treturn MULTI_MULT;\n    return NOT_MULTI;\n}\n\nstatic char_u\t\t*reg_prev_sub = NULL;\n\n/*\n * REGEXP_INRANGE contains all characters which are always special in a []\n * range after '\\'.\n * REGEXP_ABBR contains all characters which act as abbreviations after '\\'.\n * These are:\n *  \\n\t- New line (NL).\n *  \\r\t- Carriage Return (CR).\n *  \\t\t- Tab (TAB).\n *  \\e\t- Escape (ESC).\n *  \\b\t- Backspace (Ctrl_H).\n *  \\d  - Character code in decimal, eg \\d123\n *  \\o\t- Character code in octal, eg \\o80\n *  \\x\t- Character code in hex, eg \\x4a\n *  \\u\t- Multibyte character code, eg \\u20ac\n *  \\U\t- Long multibyte character code, eg \\U12345678\n */\nstatic char_u REGEXP_INRANGE[] = \"]^-n\\\\\";\nstatic char_u REGEXP_ABBR[] = \"nrtebdoxuU\";\n\n/*\n * Translate '\\x' to its control character, except \"\\n\", which is Magic.\n */\n    static int\nbackslash_trans(int c)\n{\n    switch (c)\n    {\n\tcase 'r':   return CAR;\n\tcase 't':   return TAB;\n\tcase 'e':   return ESC;\n\tcase 'b':   return BS;\n    }\n    return c;\n}\n\n/*\n * Check for a character class name \"[:name:]\".  \"pp\" points to the '['.\n * Returns one of the CLASS_ items. CLASS_NONE means that no item was\n * recognized.  Otherwise \"pp\" is advanced to after the item.\n */\n    static int\nget_char_class(char_u **pp)\n{\n    static const char *(class_names[]) =\n    {\n\t\"alnum:]\",\n#define CLASS_ALNUM 0\n\t\"alpha:]\",\n#define CLASS_ALPHA 1\n\t\"blank:]\",\n#define CLASS_BLANK 2\n\t\"cntrl:]\",\n#define CLASS_CNTRL 3\n\t\"digit:]\",\n#define CLASS_DIGIT 4\n\t\"graph:]\",\n#define CLASS_GRAPH 5\n\t\"lower:]\",\n#define CLASS_LOWER 6\n\t\"print:]\",\n#define CLASS_PRINT 7\n\t\"punct:]\",\n#define CLASS_PUNCT 8\n\t\"space:]\",\n#define CLASS_SPACE 9\n\t\"upper:]\",\n#define CLASS_UPPER 10\n\t\"xdigit:]\",\n#define CLASS_XDIGIT 11\n\t\"tab:]\",\n#define CLASS_TAB 12\n\t\"return:]\",\n#define CLASS_RETURN 13\n\t\"backspace:]\",\n#define CLASS_BACKSPACE 14\n\t\"escape:]\",\n#define CLASS_ESCAPE 15\n\t\"ident:]\",\n#define CLASS_IDENT 16\n\t\"keyword:]\",\n#define CLASS_KEYWORD 17\n\t\"fname:]\",\n#define CLASS_FNAME 18\n    };\n#define CLASS_NONE 99\n    int i;\n\n    if ((*pp)[1] == ':')\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(class_names); ++i)\n\t    if (STRNCMP(*pp + 2, class_names[i], STRLEN(class_names[i])) == 0)\n\t    {\n\t\t*pp += STRLEN(class_names[i]) + 2;\n\t\treturn i;\n\t    }\n    }\n    return CLASS_NONE;\n}\n\n/*\n * Specific version of character class functions.\n * Using a table to keep this fast.\n */\nstatic short\tclass_tab[256];\n\n#define\t    RI_DIGIT\t0x01\n#define\t    RI_HEX\t0x02\n#define\t    RI_OCTAL\t0x04\n#define\t    RI_WORD\t0x08\n#define\t    RI_HEAD\t0x10\n#define\t    RI_ALPHA\t0x20\n#define\t    RI_LOWER\t0x40\n#define\t    RI_UPPER\t0x80\n#define\t    RI_WHITE\t0x100\n\n    static void\ninit_class_tab(void)\n{\n    int\t\ti;\n    static int\tdone = FALSE;\n\n    if (done)\n\treturn;\n\n    for (i = 0; i < 256; ++i)\n    {\n\tif (i >= '0' && i <= '7')\n\t    class_tab[i] = RI_DIGIT + RI_HEX + RI_OCTAL + RI_WORD;\n\telse if (i >= '8' && i <= '9')\n\t    class_tab[i] = RI_DIGIT + RI_HEX + RI_WORD;\n\telse if (i >= 'a' && i <= 'f')\n\t    class_tab[i] = RI_HEX + RI_WORD + RI_HEAD + RI_ALPHA + RI_LOWER;\n#ifdef EBCDIC\n\telse if ((i >= 'g' && i <= 'i') || (i >= 'j' && i <= 'r')\n\t\t\t\t\t\t    || (i >= 's' && i <= 'z'))\n#else\n\telse if (i >= 'g' && i <= 'z')\n#endif\n\t    class_tab[i] = RI_WORD + RI_HEAD + RI_ALPHA + RI_LOWER;\n\telse if (i >= 'A' && i <= 'F')\n\t    class_tab[i] = RI_HEX + RI_WORD + RI_HEAD + RI_ALPHA + RI_UPPER;\n#ifdef EBCDIC\n\telse if ((i >= 'G' && i <= 'I') || ( i >= 'J' && i <= 'R')\n\t\t\t\t\t\t    || (i >= 'S' && i <= 'Z'))\n#else\n\telse if (i >= 'G' && i <= 'Z')\n#endif\n\t    class_tab[i] = RI_WORD + RI_HEAD + RI_ALPHA + RI_UPPER;\n\telse if (i == '_')\n\t    class_tab[i] = RI_WORD + RI_HEAD;\n\telse\n\t    class_tab[i] = 0;\n    }\n    class_tab[' '] |= RI_WHITE;\n    class_tab['\\t'] |= RI_WHITE;\n    done = TRUE;\n}\n\n#define ri_digit(c)\t(c < 0x100 && (class_tab[c] & RI_DIGIT))\n#define ri_hex(c)\t(c < 0x100 && (class_tab[c] & RI_HEX))\n#define ri_octal(c)\t(c < 0x100 && (class_tab[c] & RI_OCTAL))\n#define ri_word(c)\t(c < 0x100 && (class_tab[c] & RI_WORD))\n#define ri_head(c)\t(c < 0x100 && (class_tab[c] & RI_HEAD))\n#define ri_alpha(c)\t(c < 0x100 && (class_tab[c] & RI_ALPHA))\n#define ri_lower(c)\t(c < 0x100 && (class_tab[c] & RI_LOWER))\n#define ri_upper(c)\t(c < 0x100 && (class_tab[c] & RI_UPPER))\n#define ri_white(c)\t(c < 0x100 && (class_tab[c] & RI_WHITE))\n\n// flags for regflags\n#define RF_ICASE    1\t// ignore case\n#define RF_NOICASE  2\t// don't ignore case\n#define RF_HASNL    4\t// can match a NL\n#define RF_ICOMBINE 8\t// ignore combining characters\n#define RF_LOOKBH   16\t// uses \"\\@<=\" or \"\\@<!\"\n\n/*\n * Global work variables for vim_regcomp().\n */\n\nstatic char_u\t*regparse;\t// Input-scan pointer.\nstatic int\tregnpar;\t// () count.\nstatic int\twants_nfa;\t// regex should use NFA engine\n#ifdef FEAT_SYN_HL\nstatic int\tregnzpar;\t// \\z() count.\nstatic int\tre_has_z;\t// \\z item detected\n#endif\nstatic unsigned\tregflags;\t// RF_ flags for prog\n#if defined(FEAT_SYN_HL) || defined(PROTO)\nstatic int\thad_eol;\t// TRUE when EOL found by vim_regcomp()\n#endif\n\nstatic magic_T\treg_magic;\t// magicness of the pattern\n\nstatic int\treg_string;\t// matching with a string instead of a buffer\n\t\t\t\t// line\nstatic int\treg_strict;\t// \"[abc\" is illegal\n\n/*\n * META contains all characters that may be magic, except '^' and '$'.\n */\n\n#ifdef EBCDIC\nstatic char_u META[] = \"%&()*+.123456789<=>?@ACDFHIKLMOPSUVWX[_acdfhiklmnopsuvwxz{|~\";\n#else\n// META[] is used often enough to justify turning it into a table.\nstatic char_u META_flags[] = {\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n//\t\t   %  &     (  )  *  +\t      .\n    0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0,\n//     1  2  3\t4  5  6  7  8  9\t<  =  >  ?\n    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1,\n//  @  A     C\tD     F     H  I     K\tL  M\t O\n    1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1,\n//  P\t     S\t   U  V  W  X\t  Z  [\t\t _\n    1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1,\n//     a     c\td     f     h  i     k\tl  m  n  o\n    0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1,\n//  p\t     s\t   u  v  w  x\t  z  {\t|     ~\n    1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1\n};\n#endif\n\nstatic int\tcurchr;\t\t// currently parsed character\n// Previous character.  Note: prevchr is sometimes -1 when we are not at the\n// start, eg in /[ ^I]^ the pattern was never found even if it existed,\n// because ^ was taken to be magic -- webb\nstatic int\tprevchr;\nstatic int\tprevprevchr;\t// previous-previous character\nstatic int\tnextchr;\t// used for ungetchr()\n\n// arguments for reg()\n#define REG_NOPAREN\t0\t// toplevel reg()\n#define REG_PAREN\t1\t// \\(\\)\n#define REG_ZPAREN\t2\t// \\z(\\)\n#define REG_NPAREN\t3\t// \\%(\\)\n\ntypedef struct\n{\n     char_u\t*regparse;\n     int\tprevchr_len;\n     int\tcurchr;\n     int\tprevchr;\n     int\tprevprevchr;\n     int\tnextchr;\n     int\tat_start;\n     int\tprev_at_start;\n     int\tregnpar;\n} parse_state_T;\n\nstatic void\tinitchr(char_u *);\nstatic int\tgetchr(void);\nstatic void\tskipchr_keepstart(void);\nstatic int\tpeekchr(void);\nstatic void\tskipchr(void);\nstatic void\tungetchr(void);\nstatic long\tgethexchrs(int maxinputlen);\nstatic long\tgetoctchrs(void);\nstatic long\tgetdecchrs(void);\nstatic int\tcoll_get_char(void);\nstatic int\tprog_magic_wrong(void);\nstatic int\tcstrncmp(char_u *s1, char_u *s2, int *n);\nstatic char_u\t*cstrchr(char_u *, int);\nstatic int\tre_mult_next(char *what);\nstatic int\treg_iswordc(int);\n#ifdef FEAT_EVAL\nstatic void report_re_switch(char_u *pat);\n#endif\n\nstatic regengine_T bt_regengine;\nstatic regengine_T nfa_regengine;\n\n/*\n * Return TRUE if compiled regular expression \"prog\" can match a line break.\n */\n    int\nre_multiline(regprog_T *prog)\n{\n    return (prog->regflags & RF_HASNL);\n}\n\n/*\n * Check for an equivalence class name \"[=a=]\".  \"pp\" points to the '['.\n * Returns a character representing the class. Zero means that no item was\n * recognized.  Otherwise \"pp\" is advanced to after the item.\n */\n    static int\nget_equi_class(char_u **pp)\n{\n    int\t\tc;\n    int\t\tl = 1;\n    char_u\t*p = *pp;\n\n    if (p[1] == '=' && p[2] != NUL)\n    {\n\tif (has_mbyte)\n\t    l = (*mb_ptr2len)(p + 2);\n\tif (p[l + 2] == '=' && p[l + 3] == ']')\n\t{\n\t    if (has_mbyte)\n\t\tc = mb_ptr2char(p + 2);\n\t    else\n\t\tc = p[2];\n\t    *pp += l + 4;\n\t    return c;\n\t}\n    }\n    return 0;\n}\n\n#ifdef EBCDIC\n/*\n * Table for equivalence class \"c\". (IBM-1047)\n */\nstatic char *EQUIVAL_CLASS_C[16] = {\n    \"A\\x62\\x63\\x64\\x65\\x66\\x67\",\n    \"C\\x68\",\n    \"E\\x71\\x72\\x73\\x74\",\n    \"I\\x75\\x76\\x77\\x78\",\n    \"N\\x69\",\n    \"O\\xEB\\xEC\\xED\\xEE\\xEF\\x80\",\n    \"U\\xFB\\xFC\\xFD\\xFE\",\n    \"Y\\xBA\",\n    \"a\\x42\\x43\\x44\\x45\\x46\\x47\",\n    \"c\\x48\",\n    \"e\\x51\\x52\\x53\\x54\",\n    \"i\\x55\\x56\\x57\\x58\",\n    \"n\\x49\",\n    \"o\\xCB\\xCC\\xCD\\xCE\\xCF\\x70\",\n    \"u\\xDB\\xDC\\xDD\\xDE\",\n    \"y\\x8D\\xDF\",\n};\n#endif\n\n/*\n * Check for a collating element \"[.a.]\".  \"pp\" points to the '['.\n * Returns a character. Zero means that no item was recognized.  Otherwise\n * \"pp\" is advanced to after the item.\n * Currently only single characters are recognized!\n */\n    static int\nget_coll_element(char_u **pp)\n{\n    int\t\tc;\n    int\t\tl = 1;\n    char_u\t*p = *pp;\n\n    if (p[0] != NUL && p[1] == '.' && p[2] != NUL)\n    {\n\tif (has_mbyte)\n\t    l = (*mb_ptr2len)(p + 2);\n\tif (p[l + 2] == '.' && p[l + 3] == ']')\n\t{\n\t    if (has_mbyte)\n\t\tc = mb_ptr2char(p + 2);\n\t    else\n\t\tc = p[2];\n\t    *pp += l + 4;\n\t    return c;\n\t}\n    }\n    return 0;\n}\n\nstatic int reg_cpo_lit; // 'cpoptions' contains 'l' flag\nstatic int reg_cpo_bsl; // 'cpoptions' contains '\\' flag\n\n    static void\nget_cpo_flags(void)\n{\n    reg_cpo_lit = vim_strchr(p_cpo, CPO_LITERAL) != NULL;\n    reg_cpo_bsl = vim_strchr(p_cpo, CPO_BACKSL) != NULL;\n}\n\n/*\n * Skip over a \"[]\" range.\n * \"p\" must point to the character after the '['.\n * The returned pointer is on the matching ']', or the terminating NUL.\n */\n    static char_u *\nskip_anyof(char_u *p)\n{\n    int\t\tl;\n\n    if (*p == '^')\t// Complement of range.\n\t++p;\n    if (*p == ']' || *p == '-')\n\t++p;\n    while (*p != NUL && *p != ']')\n    {\n\tif (has_mbyte && (l = (*mb_ptr2len)(p)) > 1)\n\t    p += l;\n\telse\n\t    if (*p == '-')\n\t    {\n\t\t++p;\n\t\tif (*p != ']' && *p != NUL)\n\t\t    MB_PTR_ADV(p);\n\t    }\n\telse if (*p == '\\\\'\n\t\t&& !reg_cpo_bsl\n\t\t&& (vim_strchr(REGEXP_INRANGE, p[1]) != NULL\n\t\t    || (!reg_cpo_lit && vim_strchr(REGEXP_ABBR, p[1]) != NULL)))\n\t    p += 2;\n\telse if (*p == '[')\n\t{\n\t    if (get_char_class(&p) == CLASS_NONE\n\t\t    && get_equi_class(&p) == 0\n\t\t    && get_coll_element(&p) == 0\n\t\t    && *p != NUL)\n\t\t++p; // it is not a class name and not NUL\n\t}\n\telse\n\t    ++p;\n    }\n\n    return p;\n}\n\n/*\n * Skip past regular expression.\n * Stop at end of \"startp\" or where \"delim\" is found ('/', '?', etc).\n * Take care of characters with a backslash in front of it.\n * Skip strings inside [ and ].\n */\n    char_u *\nskip_regexp(\n    char_u\t*startp,\n    int\t\tdelim,\n    int\t\tmagic)\n{\n    return skip_regexp_ex(startp, delim, magic, NULL, NULL, NULL);\n}\n\n/*\n * Call skip_regexp() and when the delimiter does not match give an error and\n * return NULL.\n */\n    char_u *\nskip_regexp_err(\n    char_u\t*startp,\n    int\t\tdelim,\n    int\t\tmagic)\n{\n    char_u *p = skip_regexp(startp, delim, magic);\n\n    if (*p != delim)\n    {\n\tsemsg(_(\"E654: missing delimiter after search pattern: %s\"), startp);\n\treturn NULL;\n    }\n    return p;\n}\n\n/*\n * skip_regexp() with extra arguments:\n * When \"newp\" is not NULL and \"dirc\" is '?', make an allocated copy of the\n * expression and change \"\\?\" to \"?\".  If \"*newp\" is not NULL the expression\n * is changed in-place.\n * If a \"\\?\" is changed to \"?\" then \"dropped\" is incremented, unless NULL.\n * If \"magic_val\" is not NULL, returns the effective magicness of the pattern\n */\n    char_u *\nskip_regexp_ex(\n    char_u\t*startp,\n    int\t\tdirc,\n    int\t\tmagic,\n    char_u\t**newp,\n    int\t\t*dropped,\n    magic_T\t*magic_val)\n{\n    magic_T\tmymagic;\n    char_u\t*p = startp;\n\n    if (magic)\n\tmymagic = MAGIC_ON;\n    else\n\tmymagic = MAGIC_OFF;\n    get_cpo_flags();\n\n    for (; p[0] != NUL; MB_PTR_ADV(p))\n    {\n\tif (p[0] == dirc)\t// found end of regexp\n\t    break;\n\tif ((p[0] == '[' && mymagic >= MAGIC_ON)\n\t\t|| (p[0] == '\\\\' && p[1] == '[' && mymagic <= MAGIC_OFF))\n\t{\n\t    p = skip_anyof(p + 1);\n\t    if (p[0] == NUL)\n\t\tbreak;\n\t}\n\telse if (p[0] == '\\\\' && p[1] != NUL)\n\t{\n\t    if (dirc == '?' && newp != NULL && p[1] == '?')\n\t    {\n\t\t// change \"\\?\" to \"?\", make a copy first.\n\t\tif (*newp == NULL)\n\t\t{\n\t\t    *newp = vim_strsave(startp);\n\t\t    if (*newp != NULL)\n\t\t\tp = *newp + (p - startp);\n\t\t}\n\t\tif (dropped != NULL)\n\t\t    ++*dropped;\n\t\tif (*newp != NULL)\n\t\t    STRMOVE(p, p + 1);\n\t\telse\n\t\t    ++p;\n\t    }\n\t    else\n\t\t++p;    // skip next character\n\t    if (*p == 'v')\n\t\tmymagic = MAGIC_ALL;\n\t    else if (*p == 'V')\n\t\tmymagic = MAGIC_NONE;\n\t}\n    }\n    if (magic_val != NULL)\n\t*magic_val = mymagic;\n    return p;\n}\n\n/*\n * Functions for getting characters from the regexp input.\n */\nstatic int\tprevchr_len;\t// byte length of previous char\nstatic int\tat_start;\t// True when on the first character\nstatic int\tprev_at_start;  // True when on the second character\n\n/*\n * Start parsing at \"str\".\n */\n    static void\ninitchr(char_u *str)\n{\n    regparse = str;\n    prevchr_len = 0;\n    curchr = prevprevchr = prevchr = nextchr = -1;\n    at_start = TRUE;\n    prev_at_start = FALSE;\n}\n\n/*\n * Save the current parse state, so that it can be restored and parsing\n * starts in the same state again.\n */\n    static void\nsave_parse_state(parse_state_T *ps)\n{\n    ps->regparse = regparse;\n    ps->prevchr_len = prevchr_len;\n    ps->curchr = curchr;\n    ps->prevchr = prevchr;\n    ps->prevprevchr = prevprevchr;\n    ps->nextchr = nextchr;\n    ps->at_start = at_start;\n    ps->prev_at_start = prev_at_start;\n    ps->regnpar = regnpar;\n}\n\n/*\n * Restore a previously saved parse state.\n */\n    static void\nrestore_parse_state(parse_state_T *ps)\n{\n    regparse = ps->regparse;\n    prevchr_len = ps->prevchr_len;\n    curchr = ps->curchr;\n    prevchr = ps->prevchr;\n    prevprevchr = ps->prevprevchr;\n    nextchr = ps->nextchr;\n    at_start = ps->at_start;\n    prev_at_start = ps->prev_at_start;\n    regnpar = ps->regnpar;\n}\n\n\n/*\n * Get the next character without advancing.\n */\n    static int\npeekchr(void)\n{\n    static int\tafter_slash = FALSE;\n\n    if (curchr == -1)\n    {\n\tswitch (curchr = regparse[0])\n\t{\n\tcase '.':\n\tcase '[':\n\tcase '~':\n\t    // magic when 'magic' is on\n\t    if (reg_magic >= MAGIC_ON)\n\t\tcurchr = Magic(curchr);\n\t    break;\n\tcase '(':\n\tcase ')':\n\tcase '{':\n\tcase '%':\n\tcase '+':\n\tcase '=':\n\tcase '?':\n\tcase '@':\n\tcase '!':\n\tcase '&':\n\tcase '|':\n\tcase '<':\n\tcase '>':\n\tcase '#':\t// future ext.\n\tcase '\"':\t// future ext.\n\tcase '\\'':\t// future ext.\n\tcase ',':\t// future ext.\n\tcase '-':\t// future ext.\n\tcase ':':\t// future ext.\n\tcase ';':\t// future ext.\n\tcase '`':\t// future ext.\n\tcase '/':\t// Can't be used in / command\n\t    // magic only after \"\\v\"\n\t    if (reg_magic == MAGIC_ALL)\n\t\tcurchr = Magic(curchr);\n\t    break;\n\tcase '*':\n\t    // * is not magic as the very first character, eg \"?*ptr\", when\n\t    // after '^', eg \"/^*ptr\" and when after \"\\(\", \"\\|\", \"\\&\".  But\n\t    // \"\\(\\*\" is not magic, thus must be magic if \"after_slash\"\n\t    if (reg_magic >= MAGIC_ON\n\t\t    && !at_start\n\t\t    && !(prev_at_start && prevchr == Magic('^'))\n\t\t    && (after_slash\n\t\t\t|| (prevchr != Magic('(')\n\t\t\t    && prevchr != Magic('&')\n\t\t\t    && prevchr != Magic('|'))))\n\t\tcurchr = Magic('*');\n\t    break;\n\tcase '^':\n\t    // '^' is only magic as the very first character and if it's after\n\t    // \"\\(\", \"\\|\", \"\\&' or \"\\n\"\n\t    if (reg_magic >= MAGIC_OFF\n\t\t    && (at_start\n\t\t\t|| reg_magic == MAGIC_ALL\n\t\t\t|| prevchr == Magic('(')\n\t\t\t|| prevchr == Magic('|')\n\t\t\t|| prevchr == Magic('&')\n\t\t\t|| prevchr == Magic('n')\n\t\t\t|| (no_Magic(prevchr) == '('\n\t\t\t    && prevprevchr == Magic('%'))))\n\t    {\n\t\tcurchr = Magic('^');\n\t\tat_start = TRUE;\n\t\tprev_at_start = FALSE;\n\t    }\n\t    break;\n\tcase '$':\n\t    // '$' is only magic as the very last char and if it's in front of\n\t    // either \"\\|\", \"\\)\", \"\\&\", or \"\\n\"\n\t    if (reg_magic >= MAGIC_OFF)\n\t    {\n\t\tchar_u *p = regparse + 1;\n\t\tint is_magic_all = (reg_magic == MAGIC_ALL);\n\n\t\t// ignore \\c \\C \\m \\M \\v \\V and \\Z after '$'\n\t\twhile (p[0] == '\\\\' && (p[1] == 'c' || p[1] == 'C'\n\t\t\t\t|| p[1] == 'm' || p[1] == 'M'\n\t\t\t\t|| p[1] == 'v' || p[1] == 'V' || p[1] == 'Z'))\n\t\t{\n\t\t    if (p[1] == 'v')\n\t\t\tis_magic_all = TRUE;\n\t\t    else if (p[1] == 'm' || p[1] == 'M' || p[1] == 'V')\n\t\t\tis_magic_all = FALSE;\n\t\t    p += 2;\n\t\t}\n\t\tif (p[0] == NUL\n\t\t\t|| (p[0] == '\\\\'\n\t\t\t    && (p[1] == '|' || p[1] == '&' || p[1] == ')'\n\t\t\t\t|| p[1] == 'n'))\n\t\t\t|| (is_magic_all\n\t\t\t       && (p[0] == '|' || p[0] == '&' || p[0] == ')'))\n\t\t\t|| reg_magic == MAGIC_ALL)\n\t\t    curchr = Magic('$');\n\t    }\n\t    break;\n\tcase '\\\\':\n\t    {\n\t\tint c = regparse[1];\n\n\t\tif (c == NUL)\n\t\t    curchr = '\\\\';\t// trailing '\\'\n\t\telse if (\n#ifdef EBCDIC\n\t\t\tvim_strchr(META, c)\n#else\n\t\t\tc <= '~' && META_flags[c]\n#endif\n\t\t\t)\n\t\t{\n\t\t    /*\n\t\t     * META contains everything that may be magic sometimes,\n\t\t     * except ^ and $ (\"\\^\" and \"\\$\" are only magic after\n\t\t     * \"\\V\").  We now fetch the next character and toggle its\n\t\t     * magicness.  Therefore, \\ is so meta-magic that it is\n\t\t     * not in META.\n\t\t     */\n\t\t    curchr = -1;\n\t\t    prev_at_start = at_start;\n\t\t    at_start = FALSE;\t// be able to say \"/\\*ptr\"\n\t\t    ++regparse;\n\t\t    ++after_slash;\n\t\t    peekchr();\n\t\t    --regparse;\n\t\t    --after_slash;\n\t\t    curchr = toggle_Magic(curchr);\n\t\t}\n\t\telse if (vim_strchr(REGEXP_ABBR, c))\n\t\t{\n\t\t    /*\n\t\t     * Handle abbreviations, like \"\\t\" for TAB -- webb\n\t\t     */\n\t\t    curchr = backslash_trans(c);\n\t\t}\n\t\telse if (reg_magic == MAGIC_NONE && (c == '$' || c == '^'))\n\t\t    curchr = toggle_Magic(c);\n\t\telse\n\t\t{\n\t\t    /*\n\t\t     * Next character can never be (made) magic?\n\t\t     * Then backslashing it won't do anything.\n\t\t     */\n\t\t    if (has_mbyte)\n\t\t\tcurchr = (*mb_ptr2char)(regparse + 1);\n\t\t    else\n\t\t\tcurchr = c;\n\t\t}\n\t\tbreak;\n\t    }\n\n\tdefault:\n\t    if (has_mbyte)\n\t\tcurchr = (*mb_ptr2char)(regparse);\n\t}\n    }\n\n    return curchr;\n}\n\n/*\n * Eat one lexed character.  Do this in a way that we can undo it.\n */\n    static void\nskipchr(void)\n{\n    // peekchr() eats a backslash, do the same here\n    if (*regparse == '\\\\')\n\tprevchr_len = 1;\n    else\n\tprevchr_len = 0;\n    if (regparse[prevchr_len] != NUL)\n    {\n\tif (enc_utf8)\n\t    // exclude composing chars that mb_ptr2len does include\n\t    prevchr_len += utf_ptr2len(regparse + prevchr_len);\n\telse if (has_mbyte)\n\t    prevchr_len += (*mb_ptr2len)(regparse + prevchr_len);\n\telse\n\t    ++prevchr_len;\n    }\n    regparse += prevchr_len;\n    prev_at_start = at_start;\n    at_start = FALSE;\n    prevprevchr = prevchr;\n    prevchr = curchr;\n    curchr = nextchr;\t    // use previously unget char, or -1\n    nextchr = -1;\n}\n\n/*\n * Skip a character while keeping the value of prev_at_start for at_start.\n * prevchr and prevprevchr are also kept.\n */\n    static void\nskipchr_keepstart(void)\n{\n    int as = prev_at_start;\n    int pr = prevchr;\n    int prpr = prevprevchr;\n\n    skipchr();\n    at_start = as;\n    prevchr = pr;\n    prevprevchr = prpr;\n}\n\n/*\n * Get the next character from the pattern. We know about magic and such, so\n * therefore we need a lexical analyzer.\n */\n    static int\ngetchr(void)\n{\n    int chr = peekchr();\n\n    skipchr();\n    return chr;\n}\n\n/*\n * put character back.  Works only once!\n */\n    static void\nungetchr(void)\n{\n    nextchr = curchr;\n    curchr = prevchr;\n    prevchr = prevprevchr;\n    at_start = prev_at_start;\n    prev_at_start = FALSE;\n\n    // Backup regparse, so that it's at the same position as before the\n    // getchr().\n    regparse -= prevchr_len;\n}\n\n/*\n * Get and return the value of the hex string at the current position.\n * Return -1 if there is no valid hex number.\n * The position is updated:\n *     blahblah\\%x20asdf\n *\t   before-^ ^-after\n * The parameter controls the maximum number of input characters. This will be\n * 2 when reading a \\%x20 sequence and 4 when reading a \\%u20AC sequence.\n */\n    static long\ngethexchrs(int maxinputlen)\n{\n    long_u\tnr = 0;\n    int\t\tc;\n    int\t\ti;\n\n    for (i = 0; i < maxinputlen; ++i)\n    {\n\tc = regparse[0];\n\tif (!vim_isxdigit(c))\n\t    break;\n\tnr <<= 4;\n\tnr |= hex2nr(c);\n\t++regparse;\n    }\n\n    if (i == 0)\n\treturn -1;\n    return (long)nr;\n}\n\n/*\n * Get and return the value of the decimal string immediately after the\n * current position. Return -1 for invalid.  Consumes all digits.\n */\n    static long\ngetdecchrs(void)\n{\n    long_u\tnr = 0;\n    int\t\tc;\n    int\t\ti;\n\n    for (i = 0; ; ++i)\n    {\n\tc = regparse[0];\n\tif (c < '0' || c > '9')\n\t    break;\n\tnr *= 10;\n\tnr += c - '0';\n\t++regparse;\n\tcurchr = -1; // no longer valid\n    }\n\n    if (i == 0)\n\treturn -1;\n    return (long)nr;\n}\n\n/*\n * get and return the value of the octal string immediately after the current\n * position. Return -1 for invalid, or 0-255 for valid. Smart enough to handle\n * numbers > 377 correctly (for example, 400 is treated as 40) and doesn't\n * treat 8 or 9 as recognised characters. Position is updated:\n *     blahblah\\%o210asdf\n *\t   before-^  ^-after\n */\n    static long\ngetoctchrs(void)\n{\n    long_u\tnr = 0;\n    int\t\tc;\n    int\t\ti;\n\n    for (i = 0; i < 3 && nr < 040; ++i)\n    {\n\tc = regparse[0];\n\tif (c < '0' || c > '7')\n\t    break;\n\tnr <<= 3;\n\tnr |= hex2nr(c);\n\t++regparse;\n    }\n\n    if (i == 0)\n\treturn -1;\n    return (long)nr;\n}\n\n/*\n * read_limits - Read two integers to be taken as a minimum and maximum.\n * If the first character is '-', then the range is reversed.\n * Should end with 'end'.  If minval is missing, zero is default, if maxval is\n * missing, a very big number is the default.\n */\n    static int\nread_limits(long *minval, long *maxval)\n{\n    int\t\treverse = FALSE;\n    char_u\t*first_char;\n    long\ttmp;\n\n    if (*regparse == '-')\n    {\n\t// Starts with '-', so reverse the range later\n\tregparse++;\n\treverse = TRUE;\n    }\n    first_char = regparse;\n    *minval = getdigits(&regparse);\n    if (*regparse == ',')\t    // There is a comma\n    {\n\tif (vim_isdigit(*++regparse))\n\t    *maxval = getdigits(&regparse);\n\telse\n\t    *maxval = MAX_LIMIT;\n    }\n    else if (VIM_ISDIGIT(*first_char))\n\t*maxval = *minval;\t    // It was \\{n} or \\{-n}\n    else\n\t*maxval = MAX_LIMIT;\t    // It was \\{} or \\{-}\n    if (*regparse == '\\\\')\n\tregparse++;\t// Allow either \\{...} or \\{...\\}\n    if (*regparse != '}')\n\tEMSG2_RET_FAIL(_(\"E554: Syntax error in %s{...}\"),\n\t\t\t\t\t\t       reg_magic == MAGIC_ALL);\n\n    /*\n     * Reverse the range if there was a '-', or make sure it is in the right\n     * order otherwise.\n     */\n    if ((!reverse && *minval > *maxval) || (reverse && *minval < *maxval))\n    {\n\ttmp = *minval;\n\t*minval = *maxval;\n\t*maxval = tmp;\n    }\n    skipchr();\t\t// let's be friends with the lexer again\n    return OK;\n}\n\n/*\n * vim_regexec and friends\n */\n\n/*\n * Global work variables for vim_regexec().\n */\n\nstatic void\tcleanup_subexpr(void);\n#ifdef FEAT_SYN_HL\nstatic void\tcleanup_zsubexpr(void);\n#endif\nstatic void\treg_nextline(void);\nstatic int\tmatch_with_backref(linenr_T start_lnum, colnr_T start_col, linenr_T end_lnum, colnr_T end_col, int *bytelen);\n\n/*\n * Sometimes need to save a copy of a line.  Since alloc()/free() is very\n * slow, we keep one allocated piece of memory and only re-allocate it when\n * it's too small.  It's freed in bt_regexec_both() when finished.\n */\nstatic char_u\t*reg_tofree = NULL;\nstatic unsigned\treg_tofreelen;\n\n/*\n * Structure used to store the execution state of the regex engine.\n * Which ones are set depends on whether a single-line or multi-line match is\n * done:\n *\t\t\tsingle-line\t\tmulti-line\n * reg_match\t\t&regmatch_T\t\tNULL\n * reg_mmatch\t\tNULL\t\t\t&regmmatch_T\n * reg_startp\t\treg_match->startp\t<invalid>\n * reg_endp\t\treg_match->endp\t\t<invalid>\n * reg_startpos\t\t<invalid>\t\treg_mmatch->startpos\n * reg_endpos\t\t<invalid>\t\treg_mmatch->endpos\n * reg_win\t\tNULL\t\t\twindow in which to search\n * reg_buf\t\tcurbuf\t\t\tbuffer in which to search\n * reg_firstlnum\t<invalid>\t\tfirst line in which to search\n * reg_maxline\t\t0\t\t\tlast line nr\n * reg_line_lbr\t\tFALSE or TRUE\t\tFALSE\n */\ntypedef struct {\n    regmatch_T\t\t*reg_match;\n    regmmatch_T\t\t*reg_mmatch;\n    char_u\t\t**reg_startp;\n    char_u\t\t**reg_endp;\n    lpos_T\t\t*reg_startpos;\n    lpos_T\t\t*reg_endpos;\n    win_T\t\t*reg_win;\n    buf_T\t\t*reg_buf;\n    linenr_T\t\treg_firstlnum;\n    linenr_T\t\treg_maxline;\n    int\t\t\treg_line_lbr;\t// \"\\n\" in string is line break\n\n    // The current match-position is stord in these variables:\n    linenr_T\tlnum;\t\t// line number, relative to first line\n    char_u\t*line;\t\t// start of current line\n    char_u\t*input;\t\t// current input, points into \"regline\"\n\n    int\tneed_clear_subexpr;\t// subexpressions still need to be cleared\n#ifdef FEAT_SYN_HL\n    int\tneed_clear_zsubexpr;\t// extmatch subexpressions still need to be\n\t\t\t\t// cleared\n#endif\n\n    // Internal copy of 'ignorecase'.  It is set at each call to vim_regexec().\n    // Normally it gets the value of \"rm_ic\" or \"rmm_ic\", but when the pattern\n    // contains '\\c' or '\\C' the value is overruled.\n    int\t\t\treg_ic;\n\n    // Similar to \"reg_ic\", but only for 'combining' characters.  Set with \\Z\n    // flag in the regexp.  Defaults to false, always.\n    int\t\t\treg_icombine;\n\n    // Copy of \"rmm_maxcol\": maximum column to search for a match.  Zero when\n    // there is no maximum.\n    colnr_T\t\treg_maxcol;\n\n    // State for the NFA engine regexec.\n    int nfa_has_zend;\t    // NFA regexp \\ze operator encountered.\n    int nfa_has_backref;    // NFA regexp \\1 .. \\9 encountered.\n    int nfa_nsubexpr;\t    // Number of sub expressions actually being used\n\t\t\t    // during execution. 1 if only the whole match\n\t\t\t    // (subexpr 0) is used.\n    // listid is global, so that it increases on recursive calls to\n    // nfa_regmatch(), which means we don't have to clear the lastlist field of\n    // all the states.\n    int nfa_listid;\n    int nfa_alt_listid;\n\n#ifdef FEAT_SYN_HL\n    int nfa_has_zsubexpr;   // NFA regexp has \\z( ), set zsubexpr.\n#endif\n} regexec_T;\n\nstatic regexec_T\trex;\nstatic int\t\trex_in_use = FALSE;\n\n/*\n * Return TRUE if character 'c' is included in 'iskeyword' option for\n * \"reg_buf\" buffer.\n */\n    static int\nreg_iswordc(int c)\n{\n    return vim_iswordc_buf(c, rex.reg_buf);\n}\n\n/*\n * Get pointer to the line \"lnum\", which is relative to \"reg_firstlnum\".\n */\n    static char_u *\nreg_getline(linenr_T lnum)\n{\n    // when looking behind for a match/no-match lnum is negative.  But we\n    // can't go before line 1\n    if (rex.reg_firstlnum + lnum < 1)\n\treturn NULL;\n    if (lnum > rex.reg_maxline)\n\t// Must have matched the \"\\n\" in the last line.\n\treturn (char_u *)\"\";\n    return ml_get_buf(rex.reg_buf, rex.reg_firstlnum + lnum, FALSE);\n}\n\n#ifdef FEAT_SYN_HL\nstatic char_u\t*reg_startzp[NSUBEXP];\t// Workspace to mark beginning\nstatic char_u\t*reg_endzp[NSUBEXP];\t//   and end of \\z(...\\) matches\nstatic lpos_T\treg_startzpos[NSUBEXP];\t// idem, beginning pos\nstatic lpos_T\treg_endzpos[NSUBEXP];\t// idem, end pos\n#endif\n\n// TRUE if using multi-line regexp.\n#define REG_MULTI\t(rex.reg_match == NULL)\n\n#ifdef FEAT_SYN_HL\n/*\n * Create a new extmatch and mark it as referenced once.\n */\n    static reg_extmatch_T *\nmake_extmatch(void)\n{\n    reg_extmatch_T\t*em;\n\n    em = ALLOC_CLEAR_ONE(reg_extmatch_T);\n    if (em != NULL)\n\tem->refcnt = 1;\n    return em;\n}\n\n/*\n * Add a reference to an extmatch.\n */\n    reg_extmatch_T *\nref_extmatch(reg_extmatch_T *em)\n{\n    if (em != NULL)\n\tem->refcnt++;\n    return em;\n}\n\n/*\n * Remove a reference to an extmatch.  If there are no references left, free\n * the info.\n */\n    void\nunref_extmatch(reg_extmatch_T *em)\n{\n    int i;\n\n    if (em != NULL && --em->refcnt <= 0)\n    {\n\tfor (i = 0; i < NSUBEXP; ++i)\n\t    vim_free(em->matches[i]);\n\tvim_free(em);\n    }\n}\n#endif\n\n/*\n * Get class of previous character.\n */\n    static int\nreg_prev_class(void)\n{\n    if (rex.input > rex.line)\n\treturn mb_get_class_buf(rex.input - 1\n\t\t       - (*mb_head_off)(rex.line, rex.input - 1), rex.reg_buf);\n    return -1;\n}\n\n/*\n * Return TRUE if the current rex.input position matches the Visual area.\n */\n    static int\nreg_match_visual(void)\n{\n    pos_T\ttop, bot;\n    linenr_T    lnum;\n    colnr_T\tcol;\n    win_T\t*wp = rex.reg_win == NULL ? curwin : rex.reg_win;\n    int\t\tmode;\n    colnr_T\tstart, end;\n    colnr_T\tstart2, end2;\n    colnr_T\tcols;\n    colnr_T\tcurswant;\n\n    // Check if the buffer is the current buffer.\n    if (rex.reg_buf != curbuf || VIsual.lnum == 0)\n\treturn FALSE;\n\n    if (VIsual_active)\n    {\n\tif (LT_POS(VIsual, wp->w_cursor))\n\t{\n\t    top = VIsual;\n\t    bot = wp->w_cursor;\n\t}\n\telse\n\t{\n\t    top = wp->w_cursor;\n\t    bot = VIsual;\n\t}\n\tmode = VIsual_mode;\n\tcurswant = wp->w_curswant;\n    }\n    else\n    {\n\tif (LT_POS(curbuf->b_visual.vi_start, curbuf->b_visual.vi_end))\n\t{\n\t    top = curbuf->b_visual.vi_start;\n\t    bot = curbuf->b_visual.vi_end;\n\t}\n\telse\n\t{\n\t    top = curbuf->b_visual.vi_end;\n\t    bot = curbuf->b_visual.vi_start;\n\t}\n\tmode = curbuf->b_visual.vi_mode;\n\tcurswant = curbuf->b_visual.vi_curswant;\n    }\n    lnum = rex.lnum + rex.reg_firstlnum;\n    if (lnum < top.lnum || lnum > bot.lnum)\n\treturn FALSE;\n\n    if (mode == 'v')\n    {\n\tcol = (colnr_T)(rex.input - rex.line);\n\tif ((lnum == top.lnum && col < top.col)\n\t\t|| (lnum == bot.lnum && col >= bot.col + (*p_sel != 'e')))\n\t    return FALSE;\n    }\n    else if (mode == Ctrl_V)\n    {\n\tgetvvcol(wp, &top, &start, NULL, &end);\n\tgetvvcol(wp, &bot, &start2, NULL, &end2);\n\tif (start2 < start)\n\t    start = start2;\n\tif (end2 > end)\n\t    end = end2;\n\tif (top.col == MAXCOL || bot.col == MAXCOL || curswant == MAXCOL)\n\t    end = MAXCOL;\n\tcols = win_linetabsize(wp, rex.line, (colnr_T)(rex.input - rex.line));\n\tif (cols < start || cols > end - (*p_sel == 'e'))\n\t    return FALSE;\n    }\n    return TRUE;\n}\n\n/*\n * Check the regexp program for its magic number.\n * Return TRUE if it's wrong.\n */\n    static int\nprog_magic_wrong(void)\n{\n    regprog_T\t*prog;\n\n    prog = REG_MULTI ? rex.reg_mmatch->regprog : rex.reg_match->regprog;\n    if (prog->engine == &nfa_regengine)\n\t// For NFA matcher we don't check the magic\n\treturn FALSE;\n\n    if (UCHARAT(((bt_regprog_T *)prog)->program) != REGMAGIC)\n    {\n\temsg(_(e_corrupted_regexp_program));\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Cleanup the subexpressions, if this wasn't done yet.\n * This construction is used to clear the subexpressions only when they are\n * used (to increase speed).\n */\n    static void\ncleanup_subexpr(void)\n{\n    if (rex.need_clear_subexpr)\n    {\n\tif (REG_MULTI)\n\t{\n\t    // Use 0xff to set lnum to -1\n\t    vim_memset(rex.reg_startpos, 0xff, sizeof(lpos_T) * NSUBEXP);\n\t    vim_memset(rex.reg_endpos, 0xff, sizeof(lpos_T) * NSUBEXP);\n\t}\n\telse\n\t{\n\t    vim_memset(rex.reg_startp, 0, sizeof(char_u *) * NSUBEXP);\n\t    vim_memset(rex.reg_endp, 0, sizeof(char_u *) * NSUBEXP);\n\t}\n\trex.need_clear_subexpr = FALSE;\n    }\n}\n\n#ifdef FEAT_SYN_HL\n    static void\ncleanup_zsubexpr(void)\n{\n    if (rex.need_clear_zsubexpr)\n    {\n\tif (REG_MULTI)\n\t{\n\t    // Use 0xff to set lnum to -1\n\t    vim_memset(reg_startzpos, 0xff, sizeof(lpos_T) * NSUBEXP);\n\t    vim_memset(reg_endzpos, 0xff, sizeof(lpos_T) * NSUBEXP);\n\t}\n\telse\n\t{\n\t    vim_memset(reg_startzp, 0, sizeof(char_u *) * NSUBEXP);\n\t    vim_memset(reg_endzp, 0, sizeof(char_u *) * NSUBEXP);\n\t}\n\trex.need_clear_zsubexpr = FALSE;\n    }\n}\n#endif\n\n/*\n * Advance rex.lnum, rex.line and rex.input to the next line.\n */\n    static void\nreg_nextline(void)\n{\n    rex.line = reg_getline(++rex.lnum);\n    rex.input = rex.line;\n    fast_breakcheck();\n}\n\n/*\n * Check whether a backreference matches.\n * Returns RA_FAIL, RA_NOMATCH or RA_MATCH.\n * If \"bytelen\" is not NULL, it is set to the byte length of the match in the\n * last line.\n */\n    static int\nmatch_with_backref(\n    linenr_T start_lnum,\n    colnr_T  start_col,\n    linenr_T end_lnum,\n    colnr_T  end_col,\n    int\t     *bytelen)\n{\n    linenr_T\tclnum = start_lnum;\n    colnr_T\tccol = start_col;\n    int\t\tlen;\n    char_u\t*p;\n\n    if (bytelen != NULL)\n\t*bytelen = 0;\n    for (;;)\n    {\n\t// Since getting one line may invalidate the other, need to make copy.\n\t// Slow!\n\tif (rex.line != reg_tofree)\n\t{\n\t    len = (int)STRLEN(rex.line);\n\t    if (reg_tofree == NULL || len >= (int)reg_tofreelen)\n\t    {\n\t\tlen += 50;\t// get some extra\n\t\tvim_free(reg_tofree);\n\t\treg_tofree = alloc(len);\n\t\tif (reg_tofree == NULL)\n\t\t    return RA_FAIL; // out of memory!\n\t\treg_tofreelen = len;\n\t    }\n\t    STRCPY(reg_tofree, rex.line);\n\t    rex.input = reg_tofree + (rex.input - rex.line);\n\t    rex.line = reg_tofree;\n\t}\n\n\t// Get the line to compare with.\n\tp = reg_getline(clnum);\n\tif (clnum == end_lnum)\n\t    len = end_col - ccol;\n\telse\n\t    len = (int)STRLEN(p + ccol);\n\n\tif (cstrncmp(p + ccol, rex.input, &len) != 0)\n\t    return RA_NOMATCH;  // doesn't match\n\tif (bytelen != NULL)\n\t    *bytelen += len;\n\tif (clnum == end_lnum)\n\t    break;\t\t// match and at end!\n\tif (rex.lnum >= rex.reg_maxline)\n\t    return RA_NOMATCH;  // text too short\n\n\t// Advance to next line.\n\treg_nextline();\n\tif (bytelen != NULL)\n\t    *bytelen = 0;\n\t++clnum;\n\tccol = 0;\n\tif (got_int)\n\t    return RA_FAIL;\n    }\n\n    // found a match!  Note that rex.line may now point to a copy of the line,\n    // that should not matter.\n    return RA_MATCH;\n}\n\n/*\n * Used in a place where no * or \\+ can follow.\n */\n    static int\nre_mult_next(char *what)\n{\n    if (re_multi_type(peekchr()) == MULTI_MULT)\n    {\n       semsg(_(\"E888: (NFA regexp) cannot repeat %s\"), what);\n       rc_did_emsg = TRUE;\n       return FAIL;\n    }\n    return OK;\n}\n\ntypedef struct\n{\n    int a, b, c;\n} decomp_T;\n\n\n// 0xfb20 - 0xfb4f\nstatic decomp_T decomp_table[0xfb4f-0xfb20+1] =\n{\n    {0x5e2,0,0},\t\t// 0xfb20\talt ayin\n    {0x5d0,0,0},\t\t// 0xfb21\talt alef\n    {0x5d3,0,0},\t\t// 0xfb22\talt dalet\n    {0x5d4,0,0},\t\t// 0xfb23\talt he\n    {0x5db,0,0},\t\t// 0xfb24\talt kaf\n    {0x5dc,0,0},\t\t// 0xfb25\talt lamed\n    {0x5dd,0,0},\t\t// 0xfb26\talt mem-sofit\n    {0x5e8,0,0},\t\t// 0xfb27\talt resh\n    {0x5ea,0,0},\t\t// 0xfb28\talt tav\n    {'+', 0, 0},\t\t// 0xfb29\talt plus\n    {0x5e9, 0x5c1, 0},\t\t// 0xfb2a\tshin+shin-dot\n    {0x5e9, 0x5c2, 0},\t\t// 0xfb2b\tshin+sin-dot\n    {0x5e9, 0x5c1, 0x5bc},\t// 0xfb2c\tshin+shin-dot+dagesh\n    {0x5e9, 0x5c2, 0x5bc},\t// 0xfb2d\tshin+sin-dot+dagesh\n    {0x5d0, 0x5b7, 0},\t\t// 0xfb2e\talef+patah\n    {0x5d0, 0x5b8, 0},\t\t// 0xfb2f\talef+qamats\n    {0x5d0, 0x5b4, 0},\t\t// 0xfb30\talef+hiriq\n    {0x5d1, 0x5bc, 0},\t\t// 0xfb31\tbet+dagesh\n    {0x5d2, 0x5bc, 0},\t\t// 0xfb32\tgimel+dagesh\n    {0x5d3, 0x5bc, 0},\t\t// 0xfb33\tdalet+dagesh\n    {0x5d4, 0x5bc, 0},\t\t// 0xfb34\the+dagesh\n    {0x5d5, 0x5bc, 0},\t\t// 0xfb35\tvav+dagesh\n    {0x5d6, 0x5bc, 0},\t\t// 0xfb36\tzayin+dagesh\n    {0xfb37, 0, 0},\t\t// 0xfb37 -- UNUSED\n    {0x5d8, 0x5bc, 0},\t\t// 0xfb38\ttet+dagesh\n    {0x5d9, 0x5bc, 0},\t\t// 0xfb39\tyud+dagesh\n    {0x5da, 0x5bc, 0},\t\t// 0xfb3a\tkaf sofit+dagesh\n    {0x5db, 0x5bc, 0},\t\t// 0xfb3b\tkaf+dagesh\n    {0x5dc, 0x5bc, 0},\t\t// 0xfb3c\tlamed+dagesh\n    {0xfb3d, 0, 0},\t\t// 0xfb3d -- UNUSED\n    {0x5de, 0x5bc, 0},\t\t// 0xfb3e\tmem+dagesh\n    {0xfb3f, 0, 0},\t\t// 0xfb3f -- UNUSED\n    {0x5e0, 0x5bc, 0},\t\t// 0xfb40\tnun+dagesh\n    {0x5e1, 0x5bc, 0},\t\t// 0xfb41\tsamech+dagesh\n    {0xfb42, 0, 0},\t\t// 0xfb42 -- UNUSED\n    {0x5e3, 0x5bc, 0},\t\t// 0xfb43\tpe sofit+dagesh\n    {0x5e4, 0x5bc,0},\t\t// 0xfb44\tpe+dagesh\n    {0xfb45, 0, 0},\t\t// 0xfb45 -- UNUSED\n    {0x5e6, 0x5bc, 0},\t\t// 0xfb46\ttsadi+dagesh\n    {0x5e7, 0x5bc, 0},\t\t// 0xfb47\tqof+dagesh\n    {0x5e8, 0x5bc, 0},\t\t// 0xfb48\tresh+dagesh\n    {0x5e9, 0x5bc, 0},\t\t// 0xfb49\tshin+dagesh\n    {0x5ea, 0x5bc, 0},\t\t// 0xfb4a\ttav+dagesh\n    {0x5d5, 0x5b9, 0},\t\t// 0xfb4b\tvav+holam\n    {0x5d1, 0x5bf, 0},\t\t// 0xfb4c\tbet+rafe\n    {0x5db, 0x5bf, 0},\t\t// 0xfb4d\tkaf+rafe\n    {0x5e4, 0x5bf, 0},\t\t// 0xfb4e\tpe+rafe\n    {0x5d0, 0x5dc, 0}\t\t// 0xfb4f\talef-lamed\n};\n\n    static void\nmb_decompose(int c, int *c1, int *c2, int *c3)\n{\n    decomp_T d;\n\n    if (c >= 0xfb20 && c <= 0xfb4f)\n    {\n\td = decomp_table[c - 0xfb20];\n\t*c1 = d.a;\n\t*c2 = d.b;\n\t*c3 = d.c;\n    }\n    else\n    {\n\t*c1 = c;\n\t*c2 = *c3 = 0;\n    }\n}\n\n/*\n * Compare two strings, ignore case if rex.reg_ic set.\n * Return 0 if strings match, non-zero otherwise.\n * Correct the length \"*n\" when composing characters are ignored.\n */\n    static int\ncstrncmp(char_u *s1, char_u *s2, int *n)\n{\n    int\t\tresult;\n\n    if (!rex.reg_ic)\n\tresult = STRNCMP(s1, s2, *n);\n    else\n\tresult = MB_STRNICMP(s1, s2, *n);\n\n    // if it failed and it's utf8 and we want to combineignore:\n    if (result != 0 && enc_utf8 && rex.reg_icombine)\n    {\n\tchar_u\t*str1, *str2;\n\tint\tc1, c2, c11, c12;\n\tint\tjunk;\n\n\t// we have to handle the strcmp ourselves, since it is necessary to\n\t// deal with the composing characters by ignoring them:\n\tstr1 = s1;\n\tstr2 = s2;\n\tc1 = c2 = 0;\n\twhile ((int)(str1 - s1) < *n)\n\t{\n\t    c1 = mb_ptr2char_adv(&str1);\n\t    c2 = mb_ptr2char_adv(&str2);\n\n\t    // Decompose the character if necessary, into 'base' characters.\n\t    // Currently hard-coded for Hebrew, Arabic to be done...\n\t    if (c1 != c2 && (!rex.reg_ic || utf_fold(c1) != utf_fold(c2)))\n\t    {\n\t\t// decomposition necessary?\n\t\tmb_decompose(c1, &c11, &junk, &junk);\n\t\tmb_decompose(c2, &c12, &junk, &junk);\n\t\tc1 = c11;\n\t\tc2 = c12;\n\t\tif (c11 != c12\n\t\t\t    && (!rex.reg_ic || utf_fold(c11) != utf_fold(c12)))\n\t\t    break;\n\t    }\n\t}\n\tresult = c2 - c1;\n\tif (result == 0)\n\t    *n = (int)(str2 - s2);\n    }\n\n    return result;\n}\n\n/*\n * cstrchr: This function is used a lot for simple searches, keep it fast!\n */\n    static char_u *\ncstrchr(char_u *s, int c)\n{\n    char_u\t*p;\n    int\t\tcc;\n\n    if (!rex.reg_ic || (!enc_utf8 && mb_char2len(c) > 1))\n\treturn vim_strchr(s, c);\n\n    // tolower() and toupper() can be slow, comparing twice should be a lot\n    // faster (esp. when using MS Visual C++!).\n    // For UTF-8 need to use folded case.\n    if (enc_utf8 && c > 0x80)\n\tcc = utf_fold(c);\n    else\n\t if (MB_ISUPPER(c))\n\tcc = MB_TOLOWER(c);\n    else if (MB_ISLOWER(c))\n\tcc = MB_TOUPPER(c);\n    else\n\treturn vim_strchr(s, c);\n\n    if (has_mbyte)\n    {\n\tfor (p = s; *p != NUL; p += (*mb_ptr2len)(p))\n\t{\n\t    if (enc_utf8 && c > 0x80)\n\t    {\n\t\tif (utf_fold(utf_ptr2char(p)) == cc)\n\t\t    return p;\n\t    }\n\t    else if (*p == c || *p == cc)\n\t\treturn p;\n\t}\n    }\n    else\n\t// Faster version for when there are no multi-byte characters.\n\tfor (p = s; *p != NUL; ++p)\n\t    if (*p == c || *p == cc)\n\t\treturn p;\n\n    return NULL;\n}\n\n////////////////////////////////////////////////////////////////\n//\t\t      regsub stuff\t\t\t      //\n////////////////////////////////////////////////////////////////\n\n/*\n * We should define ftpr as a pointer to a function returning a pointer to\n * a function returning a pointer to a function ...\n * This is impossible, so we declare a pointer to a function returning a\n * void pointer. This should work for all compilers.\n */\ntypedef void (*(*fptr_T)(int *, int));\n\nstatic int vim_regsub_both(char_u *source, typval_T *expr, char_u *dest, int copy, int magic, int backslash);\n\n    static fptr_T\ndo_upper(int *d, int c)\n{\n    *d = MB_TOUPPER(c);\n\n    return (fptr_T)NULL;\n}\n\n    static fptr_T\ndo_Upper(int *d, int c)\n{\n    *d = MB_TOUPPER(c);\n\n    return (fptr_T)do_Upper;\n}\n\n    static fptr_T\ndo_lower(int *d, int c)\n{\n    *d = MB_TOLOWER(c);\n\n    return (fptr_T)NULL;\n}\n\n    static fptr_T\ndo_Lower(int *d, int c)\n{\n    *d = MB_TOLOWER(c);\n\n    return (fptr_T)do_Lower;\n}\n\n/*\n * regtilde(): Replace tildes in the pattern by the old pattern.\n *\n * Short explanation of the tilde: It stands for the previous replacement\n * pattern.  If that previous pattern also contains a ~ we should go back a\n * step further...  But we insert the previous pattern into the current one\n * and remember that.\n * This still does not handle the case where \"magic\" changes.  So require the\n * user to keep his hands off of \"magic\".\n *\n * The tildes are parsed once before the first call to vim_regsub().\n */\n    char_u *\nregtilde(char_u *source, int magic)\n{\n    char_u\t*newsub = source;\n    char_u\t*tmpsub;\n    char_u\t*p;\n    int\t\tlen;\n    int\t\tprevlen;\n\n    for (p = newsub; *p; ++p)\n    {\n\tif ((*p == '~' && magic) || (*p == '\\\\' && *(p + 1) == '~' && !magic))\n\t{\n\t    if (reg_prev_sub != NULL)\n\t    {\n\t\t// length = len(newsub) - 1 + len(prev_sub) + 1\n\t\tprevlen = (int)STRLEN(reg_prev_sub);\n\t\ttmpsub = alloc(STRLEN(newsub) + prevlen);\n\t\tif (tmpsub != NULL)\n\t\t{\n\t\t    // copy prefix\n\t\t    len = (int)(p - newsub);\t// not including ~\n\t\t    mch_memmove(tmpsub, newsub, (size_t)len);\n\t\t    // interpret tilde\n\t\t    mch_memmove(tmpsub + len, reg_prev_sub, (size_t)prevlen);\n\t\t    // copy postfix\n\t\t    if (!magic)\n\t\t\t++p;\t\t\t// back off backslash\n\t\t    STRCPY(tmpsub + len + prevlen, p + 1);\n\n\t\t    if (newsub != source)\t// already allocated newsub\n\t\t\tvim_free(newsub);\n\t\t    newsub = tmpsub;\n\t\t    p = newsub + len + prevlen;\n\t\t}\n\t    }\n\t    else if (magic)\n\t\tSTRMOVE(p, p + 1);\t// remove '~'\n\t    else\n\t\tSTRMOVE(p, p + 2);\t// remove '\\~'\n\t    --p;\n\t}\n\telse\n\t{\n\t    if (*p == '\\\\' && p[1])\t\t// skip escaped characters\n\t\t++p;\n\t    if (has_mbyte)\n\t\tp += (*mb_ptr2len)(p) - 1;\n\t}\n    }\n\n    vim_free(reg_prev_sub);\n    if (newsub != source)\t// newsub was allocated, just keep it\n\treg_prev_sub = newsub;\n    else\t\t\t// no ~ found, need to save newsub\n\treg_prev_sub = vim_strsave(newsub);\n    return newsub;\n}\n\n#ifdef FEAT_EVAL\nstatic int can_f_submatch = FALSE;\t// TRUE when submatch() can be used\n\n// These pointers are used for reg_submatch().  Needed for when the\n// substitution string is an expression that contains a call to substitute()\n// and submatch().\ntypedef struct {\n    regmatch_T\t*sm_match;\n    regmmatch_T\t*sm_mmatch;\n    linenr_T\tsm_firstlnum;\n    linenr_T\tsm_maxline;\n    int\t\tsm_line_lbr;\n} regsubmatch_T;\n\nstatic regsubmatch_T rsm;  // can only be used when can_f_submatch is TRUE\n#endif\n\n#ifdef FEAT_EVAL\n\n/*\n * Put the submatches in \"argv[argskip]\" which is a list passed into\n * call_func() by vim_regsub_both().\n */\n    static int\nfill_submatch_list(int argc UNUSED, typval_T *argv, int argskip, int argcount)\n{\n    listitem_T\t*li;\n    int\t\ti;\n    char_u\t*s;\n    typval_T\t*listarg = argv + argskip;\n\n    if (argcount == argskip)\n\t// called function doesn't take a submatches argument\n\treturn argskip;\n\n    // Relies on sl_list to be the first item in staticList10_T.\n    init_static_list((staticList10_T *)(listarg->vval.v_list));\n\n    // There are always 10 list items in staticList10_T.\n    li = listarg->vval.v_list->lv_first;\n    for (i = 0; i < 10; ++i)\n    {\n\ts = rsm.sm_match->startp[i];\n\tif (s == NULL || rsm.sm_match->endp[i] == NULL)\n\t    s = NULL;\n\telse\n\t    s = vim_strnsave(s, rsm.sm_match->endp[i] - s);\n\tli->li_tv.v_type = VAR_STRING;\n\tli->li_tv.vval.v_string = s;\n\tli = li->li_next;\n    }\n    return argskip + 1;\n}\n\n    static void\nclear_submatch_list(staticList10_T *sl)\n{\n    int i;\n\n    for (i = 0; i < 10; ++i)\n\tvim_free(sl->sl_items[i].li_tv.vval.v_string);\n}\n#endif\n\n/*\n * vim_regsub() - perform substitutions after a vim_regexec() or\n * vim_regexec_multi() match.\n *\n * If \"copy\" is TRUE really copy into \"dest\".\n * If \"copy\" is FALSE nothing is copied, this is just to find out the length\n * of the result.\n *\n * If \"backslash\" is TRUE, a backslash will be removed later, need to double\n * them to keep them, and insert a backslash before a CR to avoid it being\n * replaced with a line break later.\n *\n * Note: The matched text must not change between the call of\n * vim_regexec()/vim_regexec_multi() and vim_regsub()!  It would make the back\n * references invalid!\n *\n * Returns the size of the replacement, including terminating NUL.\n */\n    int\nvim_regsub(\n    regmatch_T\t*rmp,\n    char_u\t*source,\n    typval_T\t*expr,\n    char_u\t*dest,\n    int\t\tcopy,\n    int\t\tmagic,\n    int\t\tbackslash)\n{\n    int\t\tresult;\n    regexec_T\trex_save;\n    int\t\trex_in_use_save = rex_in_use;\n\n    if (rex_in_use)\n\t// Being called recursively, save the state.\n\trex_save = rex;\n    rex_in_use = TRUE;\n\n    rex.reg_match = rmp;\n    rex.reg_mmatch = NULL;\n    rex.reg_maxline = 0;\n    rex.reg_buf = curbuf;\n    rex.reg_line_lbr = TRUE;\n    result = vim_regsub_both(source, expr, dest, copy, magic, backslash);\n\n    rex_in_use = rex_in_use_save;\n    if (rex_in_use)\n\trex = rex_save;\n\n    return result;\n}\n\n    int\nvim_regsub_multi(\n    regmmatch_T\t*rmp,\n    linenr_T\tlnum,\n    char_u\t*source,\n    char_u\t*dest,\n    int\t\tcopy,\n    int\t\tmagic,\n    int\t\tbackslash)\n{\n    int\t\tresult;\n    regexec_T\trex_save;\n    int\t\trex_in_use_save = rex_in_use;\n\n    if (rex_in_use)\n\t// Being called recursively, save the state.\n\trex_save = rex;\n    rex_in_use = TRUE;\n\n    rex.reg_match = NULL;\n    rex.reg_mmatch = rmp;\n    rex.reg_buf = curbuf;\t// always works on the current buffer!\n    rex.reg_firstlnum = lnum;\n    rex.reg_maxline = curbuf->b_ml.ml_line_count - lnum;\n    rex.reg_line_lbr = FALSE;\n    result = vim_regsub_both(source, NULL, dest, copy, magic, backslash);\n\n    rex_in_use = rex_in_use_save;\n    if (rex_in_use)\n\trex = rex_save;\n\n    return result;\n}\n\n    static int\nvim_regsub_both(\n    char_u\t*source,\n    typval_T\t*expr,\n    char_u\t*dest,\n    int\t\tcopy,\n    int\t\tmagic,\n    int\t\tbackslash)\n{\n    char_u\t*src;\n    char_u\t*dst;\n    char_u\t*s;\n    int\t\tc;\n    int\t\tcc;\n    int\t\tno = -1;\n    fptr_T\tfunc_all = (fptr_T)NULL;\n    fptr_T\tfunc_one = (fptr_T)NULL;\n    linenr_T\tclnum = 0;\t// init for GCC\n    int\t\tlen = 0;\t// init for GCC\n#ifdef FEAT_EVAL\n    static char_u   *eval_result = NULL;\n#endif\n\n    // Be paranoid...\n    if ((source == NULL && expr == NULL) || dest == NULL)\n    {\n\temsg(_(e_null_argument));\n\treturn 0;\n    }\n    if (prog_magic_wrong())\n\treturn 0;\n    src = source;\n    dst = dest;\n\n    /*\n     * When the substitute part starts with \"\\=\" evaluate it as an expression.\n     */\n    if (expr != NULL || (source[0] == '\\\\' && source[1] == '='))\n    {\n#ifdef FEAT_EVAL\n\t// To make sure that the length doesn't change between checking the\n\t// length and copying the string, and to speed up things, the\n\t// resulting string is saved from the call with \"copy\" == FALSE to the\n\t// call with \"copy\" == TRUE.\n\tif (copy)\n\t{\n\t    if (eval_result != NULL)\n\t    {\n\t\tSTRCPY(dest, eval_result);\n\t\tdst += STRLEN(eval_result);\n\t\tVIM_CLEAR(eval_result);\n\t    }\n\t}\n\telse\n\t{\n\t    int\t\t    prev_can_f_submatch = can_f_submatch;\n\t    regsubmatch_T   rsm_save;\n\n\t    vim_free(eval_result);\n\n\t    // The expression may contain substitute(), which calls us\n\t    // recursively.  Make sure submatch() gets the text from the first\n\t    // level.\n\t    if (can_f_submatch)\n\t\trsm_save = rsm;\n\t    can_f_submatch = TRUE;\n\t    rsm.sm_match = rex.reg_match;\n\t    rsm.sm_mmatch = rex.reg_mmatch;\n\t    rsm.sm_firstlnum = rex.reg_firstlnum;\n\t    rsm.sm_maxline = rex.reg_maxline;\n\t    rsm.sm_line_lbr = rex.reg_line_lbr;\n\n\t    if (expr != NULL)\n\t    {\n\t\ttypval_T\targv[2];\n\t\tchar_u\t\tbuf[NUMBUFLEN];\n\t\ttypval_T\trettv;\n\t\tstaticList10_T\tmatchList;\n\t\tfuncexe_T\tfuncexe;\n\n\t\trettv.v_type = VAR_STRING;\n\t\trettv.vval.v_string = NULL;\n\t\targv[0].v_type = VAR_LIST;\n\t\targv[0].vval.v_list = &matchList.sl_list;\n\t\tmatchList.sl_list.lv_len = 0;\n\t\tCLEAR_FIELD(funcexe);\n\t\tfuncexe.argv_func = fill_submatch_list;\n\t\tfuncexe.evaluate = TRUE;\n\t\tif (expr->v_type == VAR_FUNC)\n\t\t{\n\t\t    s = expr->vval.v_string;\n\t\t    call_func(s, -1, &rettv, 1, argv, &funcexe);\n\t\t}\n\t\telse if (expr->v_type == VAR_PARTIAL)\n\t\t{\n\t\t    partial_T   *partial = expr->vval.v_partial;\n\n\t\t    s = partial_name(partial);\n\t\t    funcexe.partial = partial;\n\t\t    call_func(s, -1, &rettv, 1, argv, &funcexe);\n\t\t}\n\t\tif (matchList.sl_list.lv_len > 0)\n\t\t    // fill_submatch_list() was called\n\t\t    clear_submatch_list(&matchList);\n\n\t\tif (rettv.v_type == VAR_UNKNOWN)\n\t\t    // something failed, no need to report another error\n\t\t    eval_result = NULL;\n\t\telse\n\t\t{\n\t\t    eval_result = tv_get_string_buf_chk(&rettv, buf);\n\t\t    if (eval_result != NULL)\n\t\t\teval_result = vim_strsave(eval_result);\n\t\t}\n\t\tclear_tv(&rettv);\n\t    }\n\t    else if (substitute_instr != NULL)\n\t\t// Execute instructions from ISN_SUBSTITUTE.\n\t\teval_result = exe_substitute_instr();\n\t    else\n\t\teval_result = eval_to_string(source + 2, TRUE);\n\n\t    if (eval_result != NULL)\n\t    {\n\t\tint had_backslash = FALSE;\n\n\t\tfor (s = eval_result; *s != NUL; MB_PTR_ADV(s))\n\t\t{\n\t\t    // Change NL to CR, so that it becomes a line break,\n\t\t    // unless called from vim_regexec_nl().\n\t\t    // Skip over a backslashed character.\n\t\t    if (*s == NL && !rsm.sm_line_lbr)\n\t\t\t*s = CAR;\n\t\t    else if (*s == '\\\\' && s[1] != NUL)\n\t\t    {\n\t\t\t++s;\n\t\t\t/* Change NL to CR here too, so that this works:\n\t\t\t * :s/abc\\\\\\ndef/\\=\"aaa\\\\\\nbbb\"/  on text:\n\t\t\t *   abc\\\n\t\t\t *   def\n\t\t\t * Not when called from vim_regexec_nl().\n\t\t\t */\n\t\t\tif (*s == NL && !rsm.sm_line_lbr)\n\t\t\t    *s = CAR;\n\t\t\thad_backslash = TRUE;\n\t\t    }\n\t\t}\n\t\tif (had_backslash && backslash)\n\t\t{\n\t\t    // Backslashes will be consumed, need to double them.\n\t\t    s = vim_strsave_escaped(eval_result, (char_u *)\"\\\\\");\n\t\t    if (s != NULL)\n\t\t    {\n\t\t\tvim_free(eval_result);\n\t\t\teval_result = s;\n\t\t    }\n\t\t}\n\n\t\tdst += STRLEN(eval_result);\n\t    }\n\n\t    can_f_submatch = prev_can_f_submatch;\n\t    if (can_f_submatch)\n\t\trsm = rsm_save;\n\t}\n#endif\n    }\n    else\n      while ((c = *src++) != NUL)\n      {\n\tif (c == '&' && magic)\n\t    no = 0;\n\telse if (c == '\\\\' && *src != NUL)\n\t{\n\t    if (*src == '&' && !magic)\n\t    {\n\t\t++src;\n\t\tno = 0;\n\t    }\n\t    else if ('0' <= *src && *src <= '9')\n\t    {\n\t\tno = *src++ - '0';\n\t    }\n\t    else if (vim_strchr((char_u *)\"uUlLeE\", *src))\n\t    {\n\t\tswitch (*src++)\n\t\t{\n\t\tcase 'u':   func_one = (fptr_T)do_upper;\n\t\t\t    continue;\n\t\tcase 'U':   func_all = (fptr_T)do_Upper;\n\t\t\t    continue;\n\t\tcase 'l':   func_one = (fptr_T)do_lower;\n\t\t\t    continue;\n\t\tcase 'L':   func_all = (fptr_T)do_Lower;\n\t\t\t    continue;\n\t\tcase 'e':\n\t\tcase 'E':   func_one = func_all = (fptr_T)NULL;\n\t\t\t    continue;\n\t\t}\n\t    }\n\t}\n\tif (no < 0)\t      // Ordinary character.\n\t{\n\t    if (c == K_SPECIAL && src[0] != NUL && src[1] != NUL)\n\t    {\n\t\t// Copy a special key as-is.\n\t\tif (copy)\n\t\t{\n\t\t    *dst++ = c;\n\t\t    *dst++ = *src++;\n\t\t    *dst++ = *src++;\n\t\t}\n\t\telse\n\t\t{\n\t\t    dst += 3;\n\t\t    src += 2;\n\t\t}\n\t\tcontinue;\n\t    }\n\n\t    if (c == '\\\\' && *src != NUL)\n\t    {\n\t\t// Check for abbreviations -- webb\n\t\tswitch (*src)\n\t\t{\n\t\t    case 'r':\tc = CAR;\t++src;\tbreak;\n\t\t    case 'n':\tc = NL;\t\t++src;\tbreak;\n\t\t    case 't':\tc = TAB;\t++src;\tbreak;\n\t\t // Oh no!  \\e already has meaning in subst pat :-(\n\t\t // case 'e':   c = ESC;\t++src;\tbreak;\n\t\t    case 'b':\tc = Ctrl_H;\t++src;\tbreak;\n\n\t\t    // If \"backslash\" is TRUE the backslash will be removed\n\t\t    // later.  Used to insert a literal CR.\n\t\t    default:\tif (backslash)\n\t\t\t\t{\n\t\t\t\t    if (copy)\n\t\t\t\t\t*dst = '\\\\';\n\t\t\t\t    ++dst;\n\t\t\t\t}\n\t\t\t\tc = *src++;\n\t\t}\n\t    }\n\t    else if (has_mbyte)\n\t\tc = mb_ptr2char(src - 1);\n\n\t    // Write to buffer, if copy is set.\n\t    if (func_one != (fptr_T)NULL)\n\t\t// Turbo C complains without the typecast\n\t\tfunc_one = (fptr_T)(func_one(&cc, c));\n\t    else if (func_all != (fptr_T)NULL)\n\t\t// Turbo C complains without the typecast\n\t\tfunc_all = (fptr_T)(func_all(&cc, c));\n\t    else // just copy\n\t\tcc = c;\n\n\t    if (has_mbyte)\n\t    {\n\t\tint totlen = mb_ptr2len(src - 1);\n\n\t\tif (copy)\n\t\t    mb_char2bytes(cc, dst);\n\t\tdst += mb_char2len(cc) - 1;\n\t\tif (enc_utf8)\n\t\t{\n\t\t    int clen = utf_ptr2len(src - 1);\n\n\t\t    // If the character length is shorter than \"totlen\", there\n\t\t    // are composing characters; copy them as-is.\n\t\t    if (clen < totlen)\n\t\t    {\n\t\t\tif (copy)\n\t\t\t    mch_memmove(dst + 1, src - 1 + clen,\n\t\t\t\t\t\t     (size_t)(totlen - clen));\n\t\t\tdst += totlen - clen;\n\t\t    }\n\t\t}\n\t\tsrc += totlen - 1;\n\t    }\n\t    else if (copy)\n\t\t    *dst = cc;\n\t    dst++;\n\t}\n\telse\n\t{\n\t    if (REG_MULTI)\n\t    {\n\t\tclnum = rex.reg_mmatch->startpos[no].lnum;\n\t\tif (clnum < 0 || rex.reg_mmatch->endpos[no].lnum < 0)\n\t\t    s = NULL;\n\t\telse\n\t\t{\n\t\t    s = reg_getline(clnum) + rex.reg_mmatch->startpos[no].col;\n\t\t    if (rex.reg_mmatch->endpos[no].lnum == clnum)\n\t\t\tlen = rex.reg_mmatch->endpos[no].col\n\t\t\t\t\t    - rex.reg_mmatch->startpos[no].col;\n\t\t    else\n\t\t\tlen = (int)STRLEN(s);\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\ts = rex.reg_match->startp[no];\n\t\tif (rex.reg_match->endp[no] == NULL)\n\t\t    s = NULL;\n\t\telse\n\t\t    len = (int)(rex.reg_match->endp[no] - s);\n\t    }\n\t    if (s != NULL)\n\t    {\n\t\tfor (;;)\n\t\t{\n\t\t    if (len == 0)\n\t\t    {\n\t\t\tif (REG_MULTI)\n\t\t\t{\n\t\t\t    if (rex.reg_mmatch->endpos[no].lnum == clnum)\n\t\t\t\tbreak;\n\t\t\t    if (copy)\n\t\t\t\t*dst = CAR;\n\t\t\t    ++dst;\n\t\t\t    s = reg_getline(++clnum);\n\t\t\t    if (rex.reg_mmatch->endpos[no].lnum == clnum)\n\t\t\t\tlen = rex.reg_mmatch->endpos[no].col;\n\t\t\t    else\n\t\t\t\tlen = (int)STRLEN(s);\n\t\t\t}\n\t\t\telse\n\t\t\t    break;\n\t\t    }\n\t\t    else if (*s == NUL) // we hit NUL.\n\t\t    {\n\t\t\tif (copy)\n\t\t\t    iemsg(_(e_damaged_match_string));\n\t\t\tgoto exit;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (backslash && (*s == CAR || *s == '\\\\'))\n\t\t\t{\n\t\t\t    /*\n\t\t\t     * Insert a backslash in front of a CR, otherwise\n\t\t\t     * it will be replaced by a line break.\n\t\t\t     * Number of backslashes will be halved later,\n\t\t\t     * double them here.\n\t\t\t     */\n\t\t\t    if (copy)\n\t\t\t    {\n\t\t\t\tdst[0] = '\\\\';\n\t\t\t\tdst[1] = *s;\n\t\t\t    }\n\t\t\t    dst += 2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    if (has_mbyte)\n\t\t\t\tc = mb_ptr2char(s);\n\t\t\t    else\n\t\t\t\tc = *s;\n\n\t\t\t    if (func_one != (fptr_T)NULL)\n\t\t\t\t// Turbo C complains without the typecast\n\t\t\t\tfunc_one = (fptr_T)(func_one(&cc, c));\n\t\t\t    else if (func_all != (fptr_T)NULL)\n\t\t\t\t// Turbo C complains without the typecast\n\t\t\t\tfunc_all = (fptr_T)(func_all(&cc, c));\n\t\t\t    else // just copy\n\t\t\t\tcc = c;\n\n\t\t\t    if (has_mbyte)\n\t\t\t    {\n\t\t\t\tint l;\n\n\t\t\t\t// Copy composing characters separately, one\n\t\t\t\t// at a time.\n\t\t\t\tif (enc_utf8)\n\t\t\t\t    l = utf_ptr2len(s) - 1;\n\t\t\t\telse\n\t\t\t\t    l = mb_ptr2len(s) - 1;\n\n\t\t\t\ts += l;\n\t\t\t\tlen -= l;\n\t\t\t\tif (copy)\n\t\t\t\t    mb_char2bytes(cc, dst);\n\t\t\t\tdst += mb_char2len(cc) - 1;\n\t\t\t    }\n\t\t\t    else if (copy)\n\t\t\t\t    *dst = cc;\n\t\t\t    dst++;\n\t\t\t}\n\n\t\t\t++s;\n\t\t\t--len;\n\t\t    }\n\t\t}\n\t    }\n\t    no = -1;\n\t}\n      }\n    if (copy)\n\t*dst = NUL;\n\nexit:\n    return (int)((dst - dest) + 1);\n}\n\n#ifdef FEAT_EVAL\n/*\n * Call reg_getline() with the line numbers from the submatch.  If a\n * substitute() was used the reg_maxline and other values have been\n * overwritten.\n */\n    static char_u *\nreg_getline_submatch(linenr_T lnum)\n{\n    char_u *s;\n    linenr_T save_first = rex.reg_firstlnum;\n    linenr_T save_max = rex.reg_maxline;\n\n    rex.reg_firstlnum = rsm.sm_firstlnum;\n    rex.reg_maxline = rsm.sm_maxline;\n\n    s = reg_getline(lnum);\n\n    rex.reg_firstlnum = save_first;\n    rex.reg_maxline = save_max;\n    return s;\n}\n\n/*\n * Used for the submatch() function: get the string from the n'th submatch in\n * allocated memory.\n * Returns NULL when not in a \":s\" command and for a non-existing submatch.\n */\n    char_u *\nreg_submatch(int no)\n{\n    char_u\t*retval = NULL;\n    char_u\t*s;\n    int\t\tlen;\n    int\t\tround;\n    linenr_T\tlnum;\n\n    if (!can_f_submatch || no < 0)\n\treturn NULL;\n\n    if (rsm.sm_match == NULL)\n    {\n\t/*\n\t * First round: compute the length and allocate memory.\n\t * Second round: copy the text.\n\t */\n\tfor (round = 1; round <= 2; ++round)\n\t{\n\t    lnum = rsm.sm_mmatch->startpos[no].lnum;\n\t    if (lnum < 0 || rsm.sm_mmatch->endpos[no].lnum < 0)\n\t\treturn NULL;\n\n\t    s = reg_getline_submatch(lnum);\n\t    if (s == NULL)  // anti-crash check, cannot happen?\n\t\tbreak;\n\t    s += rsm.sm_mmatch->startpos[no].col;\n\t    if (rsm.sm_mmatch->endpos[no].lnum == lnum)\n\t    {\n\t\t// Within one line: take form start to end col.\n\t\tlen = rsm.sm_mmatch->endpos[no].col\n\t\t\t\t\t  - rsm.sm_mmatch->startpos[no].col;\n\t\tif (round == 2)\n\t\t    vim_strncpy(retval, s, len);\n\t\t++len;\n\t    }\n\t    else\n\t    {\n\t\t// Multiple lines: take start line from start col, middle\n\t\t// lines completely and end line up to end col.\n\t\tlen = (int)STRLEN(s);\n\t\tif (round == 2)\n\t\t{\n\t\t    STRCPY(retval, s);\n\t\t    retval[len] = '\\n';\n\t\t}\n\t\t++len;\n\t\t++lnum;\n\t\twhile (lnum < rsm.sm_mmatch->endpos[no].lnum)\n\t\t{\n\t\t    s = reg_getline_submatch(lnum++);\n\t\t    if (round == 2)\n\t\t\tSTRCPY(retval + len, s);\n\t\t    len += (int)STRLEN(s);\n\t\t    if (round == 2)\n\t\t\tretval[len] = '\\n';\n\t\t    ++len;\n\t\t}\n\t\tif (round == 2)\n\t\t    STRNCPY(retval + len, reg_getline_submatch(lnum),\n\t\t\t\t\t     rsm.sm_mmatch->endpos[no].col);\n\t\tlen += rsm.sm_mmatch->endpos[no].col;\n\t\tif (round == 2)\n\t\t    retval[len] = NUL;\n\t\t++len;\n\t    }\n\n\t    if (retval == NULL)\n\t    {\n\t\tretval = alloc(len);\n\t\tif (retval == NULL)\n\t\t    return NULL;\n\t    }\n\t}\n    }\n    else\n    {\n\ts = rsm.sm_match->startp[no];\n\tif (s == NULL || rsm.sm_match->endp[no] == NULL)\n\t    retval = NULL;\n\telse\n\t    retval = vim_strnsave(s, rsm.sm_match->endp[no] - s);\n    }\n\n    return retval;\n}\n\n/*\n * Used for the submatch() function with the optional non-zero argument: get\n * the list of strings from the n'th submatch in allocated memory with NULs\n * represented in NLs.\n * Returns a list of allocated strings.  Returns NULL when not in a \":s\"\n * command, for a non-existing submatch and for any error.\n */\n    list_T *\nreg_submatch_list(int no)\n{\n    char_u\t*s;\n    linenr_T\tslnum;\n    linenr_T\telnum;\n    colnr_T\tscol;\n    colnr_T\tecol;\n    int\t\ti;\n    list_T\t*list;\n    int\t\terror = FALSE;\n\n    if (!can_f_submatch || no < 0)\n\treturn NULL;\n\n    if (rsm.sm_match == NULL)\n    {\n\tslnum = rsm.sm_mmatch->startpos[no].lnum;\n\telnum = rsm.sm_mmatch->endpos[no].lnum;\n\tif (slnum < 0 || elnum < 0)\n\t    return NULL;\n\n\tscol = rsm.sm_mmatch->startpos[no].col;\n\tecol = rsm.sm_mmatch->endpos[no].col;\n\n\tlist = list_alloc();\n\tif (list == NULL)\n\t    return NULL;\n\n\ts = reg_getline_submatch(slnum) + scol;\n\tif (slnum == elnum)\n\t{\n\t    if (list_append_string(list, s, ecol - scol) == FAIL)\n\t\terror = TRUE;\n\t}\n\telse\n\t{\n\t    if (list_append_string(list, s, -1) == FAIL)\n\t\terror = TRUE;\n\t    for (i = 1; i < elnum - slnum; i++)\n\t    {\n\t\ts = reg_getline_submatch(slnum + i);\n\t\tif (list_append_string(list, s, -1) == FAIL)\n\t\t    error = TRUE;\n\t    }\n\t    s = reg_getline_submatch(elnum);\n\t    if (list_append_string(list, s, ecol) == FAIL)\n\t\terror = TRUE;\n\t}\n    }\n    else\n    {\n\ts = rsm.sm_match->startp[no];\n\tif (s == NULL || rsm.sm_match->endp[no] == NULL)\n\t    return NULL;\n\tlist = list_alloc();\n\tif (list == NULL)\n\t    return NULL;\n\tif (list_append_string(list, s,\n\t\t\t\t (int)(rsm.sm_match->endp[no] - s)) == FAIL)\n\t    error = TRUE;\n    }\n\n    if (error)\n    {\n\tlist_free(list);\n\treturn NULL;\n    }\n    ++list->lv_refcount;\n    return list;\n}\n#endif\n\n/*\n * Initialize the values used for matching against multiple lines\n */\n    static void\ninit_regexec_multi(\n\tregmmatch_T\t*rmp,\n\twin_T\t\t*win,\t// window in which to search or NULL\n\tbuf_T\t\t*buf,\t// buffer in which to search\n\tlinenr_T\tlnum)\t// nr of line to start looking for match\n{\n    rex.reg_match = NULL;\n    rex.reg_mmatch = rmp;\n    rex.reg_buf = buf;\n    rex.reg_win = win;\n    rex.reg_firstlnum = lnum;\n    rex.reg_maxline = rex.reg_buf->b_ml.ml_line_count - lnum;\n    rex.reg_line_lbr = FALSE;\n    rex.reg_ic = rmp->rmm_ic;\n    rex.reg_icombine = FALSE;\n    rex.reg_maxcol = rmp->rmm_maxcol;\n}\n\n#include \"regexp_bt.c\"\n\nstatic regengine_T bt_regengine =\n{\n    bt_regcomp,\n    bt_regfree,\n    bt_regexec_nl,\n    bt_regexec_multi,\n    (char_u *)\"\"\n};\n\n#include \"regexp_nfa.c\"\n\nstatic regengine_T nfa_regengine =\n{\n    nfa_regcomp,\n    nfa_regfree,\n    nfa_regexec_nl,\n    nfa_regexec_multi,\n    (char_u *)\"\"\n};\n\n// Which regexp engine to use? Needed for vim_regcomp().\n// Must match with 'regexpengine'.\nstatic int regexp_engine = 0;\n\n#ifdef DEBUG\nstatic char_u regname[][30] = {\n\t\t    \"AUTOMATIC Regexp Engine\",\n\t\t    \"BACKTRACKING Regexp Engine\",\n\t\t    \"NFA Regexp Engine\"\n\t\t\t    };\n#endif\n\n/*\n * Compile a regular expression into internal code.\n * Returns the program in allocated memory.\n * Use vim_regfree() to free the memory.\n * Returns NULL for an error.\n */\n    regprog_T *\nvim_regcomp(char_u *expr_arg, int re_flags)\n{\n    regprog_T   *prog = NULL;\n    char_u\t*expr = expr_arg;\n    int\t\tcalled_emsg_before;\n\n    regexp_engine = p_re;\n\n    // Check for prefix \"\\%#=\", that sets the regexp engine\n    if (STRNCMP(expr, \"\\\\%#=\", 4) == 0)\n    {\n\tint newengine = expr[4] - '0';\n\n\tif (newengine == AUTOMATIC_ENGINE\n\t    || newengine == BACKTRACKING_ENGINE\n\t    || newengine == NFA_ENGINE)\n\t{\n\t    regexp_engine = expr[4] - '0';\n\t    expr += 5;\n#ifdef DEBUG\n\t    smsg(\"New regexp mode selected (%d): %s\",\n\t\t\t\t\t   regexp_engine, regname[newengine]);\n#endif\n\t}\n\telse\n\t{\n\t    emsg(_(\"E864: \\\\%#= can only be followed by 0, 1, or 2. The automatic engine will be used \"));\n\t    regexp_engine = AUTOMATIC_ENGINE;\n\t}\n    }\n#ifdef DEBUG\n    bt_regengine.expr = expr;\n    nfa_regengine.expr = expr;\n#endif\n    // reg_iswordc() uses rex.reg_buf\n    rex.reg_buf = curbuf;\n\n    /*\n     * First try the NFA engine, unless backtracking was requested.\n     */\n    called_emsg_before = called_emsg;\n    if (regexp_engine != BACKTRACKING_ENGINE)\n\tprog = nfa_regengine.regcomp(expr,\n\t\tre_flags + (regexp_engine == AUTOMATIC_ENGINE ? RE_AUTO : 0));\n    else\n\tprog = bt_regengine.regcomp(expr, re_flags);\n\n    // Check for error compiling regexp with initial engine.\n    if (prog == NULL)\n    {\n#ifdef BT_REGEXP_DEBUG_LOG\n\tif (regexp_engine == BACKTRACKING_ENGINE)   // debugging log for BT engine\n\t{\n\t    FILE *f;\n\t    f = fopen(BT_REGEXP_DEBUG_LOG_NAME, \"a\");\n\t    if (f)\n\t    {\n\t\tfprintf(f, \"Syntax error in \\\"%s\\\"\\n\", expr);\n\t\tfclose(f);\n\t    }\n\t    else\n\t\tsemsg(\"(NFA) Could not open \\\"%s\\\" to write !!!\",\n\t\t\tBT_REGEXP_DEBUG_LOG_NAME);\n\t}\n#endif\n\t/*\n\t * If the NFA engine failed, try the backtracking engine.\n\t * The NFA engine also fails for patterns that it can't handle well\n\t * but are still valid patterns, thus a retry should work.\n\t * But don't try if an error message was given.\n\t */\n\tif (regexp_engine == AUTOMATIC_ENGINE\n\t\t\t\t\t  && called_emsg == called_emsg_before)\n\t{\n\t    regexp_engine = BACKTRACKING_ENGINE;\n#ifdef FEAT_EVAL\n\t    report_re_switch(expr);\n#endif\n\t    prog = bt_regengine.regcomp(expr, re_flags);\n\t}\n    }\n\n    if (prog != NULL)\n    {\n\t// Store the info needed to call regcomp() again when the engine turns\n\t// out to be very slow when executing it.\n\tprog->re_engine = regexp_engine;\n\tprog->re_flags  = re_flags;\n    }\n\n    return prog;\n}\n\n/*\n * Free a compiled regexp program, returned by vim_regcomp().\n */\n    void\nvim_regfree(regprog_T *prog)\n{\n    if (prog != NULL)\n\tprog->engine->regfree(prog);\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nfree_regexp_stuff(void)\n{\n    ga_clear(&regstack);\n    ga_clear(&backpos);\n    vim_free(reg_tofree);\n    vim_free(reg_prev_sub);\n}\n#endif\n\n#ifdef FEAT_EVAL\n    static void\nreport_re_switch(char_u *pat)\n{\n    if (p_verbose > 0)\n    {\n\tverbose_enter();\n\tmsg_puts(_(\"Switching to backtracking RE engine for pattern: \"));\n\tmsg_puts((char *)pat);\n\tverbose_leave();\n    }\n}\n#endif\n\n#if (defined(FEAT_X11) && (defined(FEAT_TITLE) || defined(FEAT_XCLIPBOARD))) \\\n\t|| defined(PROTO)\n/*\n * Return whether \"prog\" is currently being executed.\n */\n    int\nregprog_in_use(regprog_T *prog)\n{\n    return prog->re_in_use;\n}\n#endif\n\n/*\n * Match a regexp against a string.\n * \"rmp->regprog\" is a compiled regexp as returned by vim_regcomp().\n * Note: \"rmp->regprog\" may be freed and changed.\n * Uses curbuf for line count and 'iskeyword'.\n * When \"nl\" is TRUE consider a \"\\n\" in \"line\" to be a line break.\n *\n * Return TRUE if there is a match, FALSE if not.\n */\n    static int\nvim_regexec_string(\n    regmatch_T\t*rmp,\n    char_u\t*line,  // string to match against\n    colnr_T\tcol,    // column to start looking for match\n    int\t\tnl)\n{\n    int\t\tresult;\n    regexec_T\trex_save;\n    int\t\trex_in_use_save = rex_in_use;\n\n    // Cannot use the same prog recursively, it contains state.\n    if (rmp->regprog->re_in_use)\n    {\n\temsg(_(e_recursive));\n\treturn FALSE;\n    }\n    rmp->regprog->re_in_use = TRUE;\n\n    if (rex_in_use)\n\t// Being called recursively, save the state.\n\trex_save = rex;\n    rex_in_use = TRUE;\n\n    rex.reg_startp = NULL;\n    rex.reg_endp = NULL;\n    rex.reg_startpos = NULL;\n    rex.reg_endpos = NULL;\n\n    result = rmp->regprog->engine->regexec_nl(rmp, line, col, nl);\n    rmp->regprog->re_in_use = FALSE;\n\n    // NFA engine aborted because it's very slow.\n    if (rmp->regprog->re_engine == AUTOMATIC_ENGINE\n\t\t\t\t\t       && result == NFA_TOO_EXPENSIVE)\n    {\n\tint    save_p_re = p_re;\n\tint    re_flags = rmp->regprog->re_flags;\n\tchar_u *pat = vim_strsave(((nfa_regprog_T *)rmp->regprog)->pattern);\n\n\tp_re = BACKTRACKING_ENGINE;\n\tvim_regfree(rmp->regprog);\n\tif (pat != NULL)\n\t{\n#ifdef FEAT_EVAL\n\t    report_re_switch(pat);\n#endif\n\t    rmp->regprog = vim_regcomp(pat, re_flags);\n\t    if (rmp->regprog != NULL)\n\t    {\n\t\trmp->regprog->re_in_use = TRUE;\n\t\tresult = rmp->regprog->engine->regexec_nl(rmp, line, col, nl);\n\t\trmp->regprog->re_in_use = FALSE;\n\t    }\n\t    vim_free(pat);\n\t}\n\n\tp_re = save_p_re;\n    }\n\n    rex_in_use = rex_in_use_save;\n    if (rex_in_use)\n\trex = rex_save;\n\n    return result > 0;\n}\n\n/*\n * Note: \"*prog\" may be freed and changed.\n * Return TRUE if there is a match, FALSE if not.\n */\n    int\nvim_regexec_prog(\n    regprog_T\t**prog,\n    int\t\tignore_case,\n    char_u\t*line,\n    colnr_T\tcol)\n{\n    int\t\tr;\n    regmatch_T\tregmatch;\n\n    regmatch.regprog = *prog;\n    regmatch.rm_ic = ignore_case;\n    r = vim_regexec_string(&regmatch, line, col, FALSE);\n    *prog = regmatch.regprog;\n    return r;\n}\n\n/*\n * Note: \"rmp->regprog\" may be freed and changed.\n * Return TRUE if there is a match, FALSE if not.\n */\n    int\nvim_regexec(regmatch_T *rmp, char_u *line, colnr_T col)\n{\n    return vim_regexec_string(rmp, line, col, FALSE);\n}\n\n/*\n * Like vim_regexec(), but consider a \"\\n\" in \"line\" to be a line break.\n * Note: \"rmp->regprog\" may be freed and changed.\n * Return TRUE if there is a match, FALSE if not.\n */\n    int\nvim_regexec_nl(regmatch_T *rmp, char_u *line, colnr_T col)\n{\n    return vim_regexec_string(rmp, line, col, TRUE);\n}\n\n/*\n * Match a regexp against multiple lines.\n * \"rmp->regprog\" must be a compiled regexp as returned by vim_regcomp().\n * Note: \"rmp->regprog\" may be freed and changed, even set to NULL.\n * Uses curbuf for line count and 'iskeyword'.\n *\n * Return zero if there is no match.  Return number of lines contained in the\n * match otherwise.\n */\n    long\nvim_regexec_multi(\n    regmmatch_T *rmp,\n    win_T       *win,\t\t// window in which to search or NULL\n    buf_T       *buf,\t\t// buffer in which to search\n    linenr_T\tlnum,\t\t// nr of line to start looking for match\n    colnr_T\tcol,\t\t// column to start looking for match\n    proftime_T\t*tm,\t\t// timeout limit or NULL\n    int\t\t*timed_out)\t// flag is set when timeout limit reached\n{\n    int\t\tresult;\n    regexec_T\trex_save;\n    int\t\trex_in_use_save = rex_in_use;\n\n    // Cannot use the same prog recursively, it contains state.\n    if (rmp->regprog->re_in_use)\n    {\n\temsg(_(e_recursive));\n\treturn FALSE;\n    }\n    rmp->regprog->re_in_use = TRUE;\n\n    if (rex_in_use)\n\t// Being called recursively, save the state.\n\trex_save = rex;\n    rex_in_use = TRUE;\n\n    result = rmp->regprog->engine->regexec_multi(\n\t\t\t\t      rmp, win, buf, lnum, col, tm, timed_out);\n    rmp->regprog->re_in_use = FALSE;\n\n    // NFA engine aborted because it's very slow.\n    if (rmp->regprog->re_engine == AUTOMATIC_ENGINE\n\t\t\t\t\t       && result == NFA_TOO_EXPENSIVE)\n    {\n\tint    save_p_re = p_re;\n\tint    re_flags = rmp->regprog->re_flags;\n\tchar_u *pat = vim_strsave(((nfa_regprog_T *)rmp->regprog)->pattern);\n\n\tp_re = BACKTRACKING_ENGINE;\n\tvim_regfree(rmp->regprog);\n\tif (pat != NULL)\n\t{\n#ifdef FEAT_EVAL\n\t    report_re_switch(pat);\n#endif\n#ifdef FEAT_SYN_HL\n\t    // checking for \\z misuse was already done when compiling for NFA,\n\t    // allow all here\n\t    reg_do_extmatch = REX_ALL;\n#endif\n\t    rmp->regprog = vim_regcomp(pat, re_flags);\n#ifdef FEAT_SYN_HL\n\t    reg_do_extmatch = 0;\n#endif\n\n\t    if (rmp->regprog != NULL)\n\t    {\n\t\trmp->regprog->re_in_use = TRUE;\n\t\tresult = rmp->regprog->engine->regexec_multi(\n\t\t\t\t      rmp, win, buf, lnum, col, tm, timed_out);\n\t\trmp->regprog->re_in_use = FALSE;\n\t    }\n\t    vim_free(pat);\n\t}\n\tp_re = save_p_re;\n    }\n\n    rex_in_use = rex_in_use_save;\n    if (rex_in_use)\n\trex = rex_save;\n\n    return result <= 0 ? 0 : result;\n}\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * NFA regular expression implementation.\n *\n * This file is included in \"regexp.c\".\n */\n\n/*\n * Logging of NFA engine.\n *\n * The NFA engine can write four log files:\n * - Error log: Contains NFA engine's fatal errors.\n * - Dump log: Contains compiled NFA state machine's information.\n * - Run log: Contains information of matching procedure.\n * - Debug log: Contains detailed information of matching procedure. Can be\n *   disabled by undefining NFA_REGEXP_DEBUG_LOG.\n * The first one can also be used without debug mode.\n * The last three are enabled when compiled as debug mode and individually\n * disabled by commenting them out.\n * The log files can get quite big!\n * Do disable all of this when compiling Vim for debugging, undefine DEBUG in\n * regexp.c\n */\n#ifdef DEBUG\n# define NFA_REGEXP_ERROR_LOG\t\"nfa_regexp_error.log\"\n# define ENABLE_LOG\n# define NFA_REGEXP_DUMP_LOG\t\"nfa_regexp_dump.log\"\n# define NFA_REGEXP_RUN_LOG\t\"nfa_regexp_run.log\"\n# define NFA_REGEXP_DEBUG_LOG\t\"nfa_regexp_debug.log\"\n#endif\n\n// Added to NFA_ANY - NFA_NUPPER_IC to include a NL.\n#define NFA_ADD_NL\t\t31\n\nenum\n{\n    NFA_SPLIT = -1024,\n    NFA_MATCH,\n    NFA_EMPTY,\t\t\t    // matches 0-length\n\n    NFA_START_COLL,\t\t    // [abc] start\n    NFA_END_COLL,\t\t    // [abc] end\n    NFA_START_NEG_COLL,\t\t    // [^abc] start\n    NFA_END_NEG_COLL,\t\t    // [^abc] end (postfix only)\n    NFA_RANGE,\t\t\t    // range of the two previous items\n\t\t\t\t    // (postfix only)\n    NFA_RANGE_MIN,\t\t    // low end of a range\n    NFA_RANGE_MAX,\t\t    // high end of a range\n\n    NFA_CONCAT,\t\t\t    // concatenate two previous items (postfix\n\t\t\t\t    // only)\n    NFA_OR,\t\t\t    // \\| (postfix only)\n    NFA_STAR,\t\t\t    // greedy * (postfix only)\n    NFA_STAR_NONGREEDY,\t\t    // non-greedy * (postfix only)\n    NFA_QUEST,\t\t\t    // greedy \\? (postfix only)\n    NFA_QUEST_NONGREEDY,\t    // non-greedy \\? (postfix only)\n\n    NFA_BOL,\t\t\t    // ^    Begin line\n    NFA_EOL,\t\t\t    // $    End line\n    NFA_BOW,\t\t\t    // \\<   Begin word\n    NFA_EOW,\t\t\t    // \\>   End word\n    NFA_BOF,\t\t\t    // \\%^  Begin file\n    NFA_EOF,\t\t\t    // \\%$  End file\n    NFA_NEWL,\n    NFA_ZSTART,\t\t\t    // Used for \\zs\n    NFA_ZEND,\t\t\t    // Used for \\ze\n    NFA_NOPEN,\t\t\t    // Start of subexpression marked with \\%(\n    NFA_NCLOSE,\t\t\t    // End of subexpr. marked with \\%( ... \\)\n    NFA_START_INVISIBLE,\n    NFA_START_INVISIBLE_FIRST,\n    NFA_START_INVISIBLE_NEG,\n    NFA_START_INVISIBLE_NEG_FIRST,\n    NFA_START_INVISIBLE_BEFORE,\n    NFA_START_INVISIBLE_BEFORE_FIRST,\n    NFA_START_INVISIBLE_BEFORE_NEG,\n    NFA_START_INVISIBLE_BEFORE_NEG_FIRST,\n    NFA_START_PATTERN,\n    NFA_END_INVISIBLE,\n    NFA_END_INVISIBLE_NEG,\n    NFA_END_PATTERN,\n    NFA_COMPOSING,\t\t    // Next nodes in NFA are part of the\n\t\t\t\t    // composing multibyte char\n    NFA_END_COMPOSING,\t\t    // End of a composing char in the NFA\n    NFA_ANY_COMPOSING,\t\t    // \\%C: Any composing characters.\n    NFA_OPT_CHARS,\t\t    // \\%[abc]\n\n    // The following are used only in the postfix form, not in the NFA\n    NFA_PREV_ATOM_NO_WIDTH,\t    // Used for \\@=\n    NFA_PREV_ATOM_NO_WIDTH_NEG,\t    // Used for \\@!\n    NFA_PREV_ATOM_JUST_BEFORE,\t    // Used for \\@<=\n    NFA_PREV_ATOM_JUST_BEFORE_NEG,  // Used for \\@<!\n    NFA_PREV_ATOM_LIKE_PATTERN,\t    // Used for \\@>\n\n    NFA_BACKREF1,\t\t    // \\1\n    NFA_BACKREF2,\t\t    // \\2\n    NFA_BACKREF3,\t\t    // \\3\n    NFA_BACKREF4,\t\t    // \\4\n    NFA_BACKREF5,\t\t    // \\5\n    NFA_BACKREF6,\t\t    // \\6\n    NFA_BACKREF7,\t\t    // \\7\n    NFA_BACKREF8,\t\t    // \\8\n    NFA_BACKREF9,\t\t    // \\9\n#ifdef FEAT_SYN_HL\n    NFA_ZREF1,\t\t\t    // \\z1\n    NFA_ZREF2,\t\t\t    // \\z2\n    NFA_ZREF3,\t\t\t    // \\z3\n    NFA_ZREF4,\t\t\t    // \\z4\n    NFA_ZREF5,\t\t\t    // \\z5\n    NFA_ZREF6,\t\t\t    // \\z6\n    NFA_ZREF7,\t\t\t    // \\z7\n    NFA_ZREF8,\t\t\t    // \\z8\n    NFA_ZREF9,\t\t\t    // \\z9\n#endif\n    NFA_SKIP,\t\t\t    // Skip characters\n\n    NFA_MOPEN,\n    NFA_MOPEN1,\n    NFA_MOPEN2,\n    NFA_MOPEN3,\n    NFA_MOPEN4,\n    NFA_MOPEN5,\n    NFA_MOPEN6,\n    NFA_MOPEN7,\n    NFA_MOPEN8,\n    NFA_MOPEN9,\n\n    NFA_MCLOSE,\n    NFA_MCLOSE1,\n    NFA_MCLOSE2,\n    NFA_MCLOSE3,\n    NFA_MCLOSE4,\n    NFA_MCLOSE5,\n    NFA_MCLOSE6,\n    NFA_MCLOSE7,\n    NFA_MCLOSE8,\n    NFA_MCLOSE9,\n\n#ifdef FEAT_SYN_HL\n    NFA_ZOPEN,\n    NFA_ZOPEN1,\n    NFA_ZOPEN2,\n    NFA_ZOPEN3,\n    NFA_ZOPEN4,\n    NFA_ZOPEN5,\n    NFA_ZOPEN6,\n    NFA_ZOPEN7,\n    NFA_ZOPEN8,\n    NFA_ZOPEN9,\n\n    NFA_ZCLOSE,\n    NFA_ZCLOSE1,\n    NFA_ZCLOSE2,\n    NFA_ZCLOSE3,\n    NFA_ZCLOSE4,\n    NFA_ZCLOSE5,\n    NFA_ZCLOSE6,\n    NFA_ZCLOSE7,\n    NFA_ZCLOSE8,\n    NFA_ZCLOSE9,\n#endif\n\n    // NFA_FIRST_NL\n    NFA_ANY,\t\t//\tMatch any one character.\n    NFA_IDENT,\t\t//\tMatch identifier char\n    NFA_SIDENT,\t\t//\tMatch identifier char but no digit\n    NFA_KWORD,\t\t//\tMatch keyword char\n    NFA_SKWORD,\t\t//\tMatch word char but no digit\n    NFA_FNAME,\t\t//\tMatch file name char\n    NFA_SFNAME,\t\t//\tMatch file name char but no digit\n    NFA_PRINT,\t\t//\tMatch printable char\n    NFA_SPRINT,\t\t//\tMatch printable char but no digit\n    NFA_WHITE,\t\t//\tMatch whitespace char\n    NFA_NWHITE,\t\t//\tMatch non-whitespace char\n    NFA_DIGIT,\t\t//\tMatch digit char\n    NFA_NDIGIT,\t\t//\tMatch non-digit char\n    NFA_HEX,\t\t//\tMatch hex char\n    NFA_NHEX,\t\t//\tMatch non-hex char\n    NFA_OCTAL,\t\t//\tMatch octal char\n    NFA_NOCTAL,\t\t//\tMatch non-octal char\n    NFA_WORD,\t\t//\tMatch word char\n    NFA_NWORD,\t\t//\tMatch non-word char\n    NFA_HEAD,\t\t//\tMatch head char\n    NFA_NHEAD,\t\t//\tMatch non-head char\n    NFA_ALPHA,\t\t//\tMatch alpha char\n    NFA_NALPHA,\t\t//\tMatch non-alpha char\n    NFA_LOWER,\t\t//\tMatch lowercase char\n    NFA_NLOWER,\t\t//\tMatch non-lowercase char\n    NFA_UPPER,\t\t//\tMatch uppercase char\n    NFA_NUPPER,\t\t//\tMatch non-uppercase char\n    NFA_LOWER_IC,\t//\tMatch [a-z]\n    NFA_NLOWER_IC,\t//\tMatch [^a-z]\n    NFA_UPPER_IC,\t//\tMatch [A-Z]\n    NFA_NUPPER_IC,\t//\tMatch [^A-Z]\n\n    NFA_FIRST_NL = NFA_ANY + NFA_ADD_NL,\n    NFA_LAST_NL = NFA_NUPPER_IC + NFA_ADD_NL,\n\n    NFA_CURSOR,\t\t//\tMatch cursor pos\n    NFA_LNUM,\t\t//\tMatch line number\n    NFA_LNUM_GT,\t//\tMatch > line number\n    NFA_LNUM_LT,\t//\tMatch < line number\n    NFA_COL,\t\t//\tMatch cursor column\n    NFA_COL_GT,\t\t//\tMatch > cursor column\n    NFA_COL_LT,\t\t//\tMatch < cursor column\n    NFA_VCOL,\t\t//\tMatch cursor virtual column\n    NFA_VCOL_GT,\t//\tMatch > cursor virtual column\n    NFA_VCOL_LT,\t//\tMatch < cursor virtual column\n    NFA_MARK,\t\t//\tMatch mark\n    NFA_MARK_GT,\t//\tMatch > mark\n    NFA_MARK_LT,\t//\tMatch < mark\n    NFA_VISUAL,\t\t//\tMatch Visual area\n\n    // Character classes [:alnum:] etc\n    NFA_CLASS_ALNUM,\n    NFA_CLASS_ALPHA,\n    NFA_CLASS_BLANK,\n    NFA_CLASS_CNTRL,\n    NFA_CLASS_DIGIT,\n    NFA_CLASS_GRAPH,\n    NFA_CLASS_LOWER,\n    NFA_CLASS_PRINT,\n    NFA_CLASS_PUNCT,\n    NFA_CLASS_SPACE,\n    NFA_CLASS_UPPER,\n    NFA_CLASS_XDIGIT,\n    NFA_CLASS_TAB,\n    NFA_CLASS_RETURN,\n    NFA_CLASS_BACKSPACE,\n    NFA_CLASS_ESCAPE,\n    NFA_CLASS_IDENT,\n    NFA_CLASS_KEYWORD,\n    NFA_CLASS_FNAME\n};\n\n// Keep in sync with classchars.\nstatic int nfa_classcodes[] = {\n    NFA_ANY, NFA_IDENT, NFA_SIDENT, NFA_KWORD,NFA_SKWORD,\n    NFA_FNAME, NFA_SFNAME, NFA_PRINT, NFA_SPRINT,\n    NFA_WHITE, NFA_NWHITE, NFA_DIGIT, NFA_NDIGIT,\n    NFA_HEX, NFA_NHEX, NFA_OCTAL, NFA_NOCTAL,\n    NFA_WORD, NFA_NWORD, NFA_HEAD, NFA_NHEAD,\n    NFA_ALPHA, NFA_NALPHA, NFA_LOWER, NFA_NLOWER,\n    NFA_UPPER, NFA_NUPPER\n};\n\nstatic char_u e_nul_found[] = N_(\"E865: (NFA) Regexp end encountered prematurely\");\nstatic char_u e_misplaced[] = N_(\"E866: (NFA regexp) Misplaced %c\");\nstatic char_u e_ill_char_class[] = N_(\"E877: (NFA regexp) Invalid character class: %d\");\nstatic char_u e_value_too_large[] = N_(\"E951: \\\\% value too large\");\n\n// Variables only used in nfa_regcomp() and descendants.\nstatic int nfa_re_flags; // re_flags passed to nfa_regcomp()\nstatic int *post_start;  // holds the postfix form of r.e.\nstatic int *post_end;\nstatic int *post_ptr;\n\n// Set when the pattern should use the NFA engine.\n// E.g. [[:upper:]] only allows 8bit characters for BT engine,\n// while NFA engine handles multibyte characters correctly.\nstatic int wants_nfa;\n\nstatic int nstate;\t// Number of states in the NFA.\nstatic int istate;\t// Index in the state vector, used in alloc_state()\n\n// If not NULL match must end at this position\nstatic save_se_T *nfa_endp = NULL;\n\n// 0 for first call to nfa_regmatch(), 1 for recursive call.\nstatic int nfa_ll_index = 0;\n\nstatic int realloc_post_list(void);\nstatic int nfa_reg(int paren);\n#ifdef DEBUG\nstatic void nfa_print_state2(FILE *debugf, nfa_state_T *state, garray_T *indent);\n#endif\nstatic int match_follows(nfa_state_T *startstate, int depth);\nstatic int failure_chance(nfa_state_T *state, int depth);\n\n// helper functions used when doing re2post() ... regatom() parsing\n#define EMIT(c)\tdo {\t\t\t\t\\\n\t\t    if (post_ptr >= post_end && realloc_post_list() == FAIL) \\\n\t\t\treturn FAIL;\t\t\\\n\t\t    *post_ptr++ = c;\t\t\\\n\t\t} while (0)\n\n/*\n * Initialize internal variables before NFA compilation.\n * Return OK on success, FAIL otherwise.\n */\n    static int\nnfa_regcomp_start(\n    char_u\t*expr,\n    int\t\tre_flags)\t    // see vim_regcomp()\n{\n    size_t\tpostfix_size;\n    int\t\tnstate_max;\n\n    nstate = 0;\n    istate = 0;\n    // A reasonable estimation for maximum size\n    nstate_max = (int)(STRLEN(expr) + 1) * 25;\n\n    // Some items blow up in size, such as [A-z].  Add more space for that.\n    // When it is still not enough realloc_post_list() will be used.\n    nstate_max += 1000;\n\n    // Size for postfix representation of expr.\n    postfix_size = sizeof(int) * nstate_max;\n\n    post_start = alloc(postfix_size);\n    if (post_start == NULL)\n\treturn FAIL;\n    post_ptr = post_start;\n    post_end = post_start + nstate_max;\n    wants_nfa = FALSE;\n    rex.nfa_has_zend = FALSE;\n    rex.nfa_has_backref = FALSE;\n\n    // shared with BT engine\n    regcomp_start(expr, re_flags);\n\n    return OK;\n}\n\n/*\n * Figure out if the NFA state list starts with an anchor, must match at start\n * of the line.\n */\n    static int\nnfa_get_reganch(nfa_state_T *start, int depth)\n{\n    nfa_state_T *p = start;\n\n    if (depth > 4)\n\treturn 0;\n\n    while (p != NULL)\n    {\n\tswitch (p->c)\n\t{\n\t    case NFA_BOL:\n\t    case NFA_BOF:\n\t\treturn 1; // yes!\n\n\t    case NFA_ZSTART:\n\t    case NFA_ZEND:\n\t    case NFA_CURSOR:\n\t    case NFA_VISUAL:\n\n\t    case NFA_MOPEN:\n\t    case NFA_MOPEN1:\n\t    case NFA_MOPEN2:\n\t    case NFA_MOPEN3:\n\t    case NFA_MOPEN4:\n\t    case NFA_MOPEN5:\n\t    case NFA_MOPEN6:\n\t    case NFA_MOPEN7:\n\t    case NFA_MOPEN8:\n\t    case NFA_MOPEN9:\n\t    case NFA_NOPEN:\n#ifdef FEAT_SYN_HL\n\t    case NFA_ZOPEN:\n\t    case NFA_ZOPEN1:\n\t    case NFA_ZOPEN2:\n\t    case NFA_ZOPEN3:\n\t    case NFA_ZOPEN4:\n\t    case NFA_ZOPEN5:\n\t    case NFA_ZOPEN6:\n\t    case NFA_ZOPEN7:\n\t    case NFA_ZOPEN8:\n\t    case NFA_ZOPEN9:\n#endif\n\t\tp = p->out;\n\t\tbreak;\n\n\t    case NFA_SPLIT:\n\t\treturn nfa_get_reganch(p->out, depth + 1)\n\t\t\t\t       && nfa_get_reganch(p->out1, depth + 1);\n\n\t    default:\n\t\treturn 0; // noooo\n\t}\n    }\n    return 0;\n}\n\n/*\n * Figure out if the NFA state list starts with a character which must match\n * at start of the match.\n */\n    static int\nnfa_get_regstart(nfa_state_T *start, int depth)\n{\n    nfa_state_T *p = start;\n\n    if (depth > 4)\n\treturn 0;\n\n    while (p != NULL)\n    {\n\tswitch (p->c)\n\t{\n\t    // all kinds of zero-width matches\n\t    case NFA_BOL:\n\t    case NFA_BOF:\n\t    case NFA_BOW:\n\t    case NFA_EOW:\n\t    case NFA_ZSTART:\n\t    case NFA_ZEND:\n\t    case NFA_CURSOR:\n\t    case NFA_VISUAL:\n\t    case NFA_LNUM:\n\t    case NFA_LNUM_GT:\n\t    case NFA_LNUM_LT:\n\t    case NFA_COL:\n\t    case NFA_COL_GT:\n\t    case NFA_COL_LT:\n\t    case NFA_VCOL:\n\t    case NFA_VCOL_GT:\n\t    case NFA_VCOL_LT:\n\t    case NFA_MARK:\n\t    case NFA_MARK_GT:\n\t    case NFA_MARK_LT:\n\n\t    case NFA_MOPEN:\n\t    case NFA_MOPEN1:\n\t    case NFA_MOPEN2:\n\t    case NFA_MOPEN3:\n\t    case NFA_MOPEN4:\n\t    case NFA_MOPEN5:\n\t    case NFA_MOPEN6:\n\t    case NFA_MOPEN7:\n\t    case NFA_MOPEN8:\n\t    case NFA_MOPEN9:\n\t    case NFA_NOPEN:\n#ifdef FEAT_SYN_HL\n\t    case NFA_ZOPEN:\n\t    case NFA_ZOPEN1:\n\t    case NFA_ZOPEN2:\n\t    case NFA_ZOPEN3:\n\t    case NFA_ZOPEN4:\n\t    case NFA_ZOPEN5:\n\t    case NFA_ZOPEN6:\n\t    case NFA_ZOPEN7:\n\t    case NFA_ZOPEN8:\n\t    case NFA_ZOPEN9:\n#endif\n\t\tp = p->out;\n\t\tbreak;\n\n\t    case NFA_SPLIT:\n\t    {\n\t\tint c1 = nfa_get_regstart(p->out, depth + 1);\n\t\tint c2 = nfa_get_regstart(p->out1, depth + 1);\n\n\t\tif (c1 == c2)\n\t\t    return c1; // yes!\n\t\treturn 0;\n\t    }\n\n\t    default:\n\t\tif (p->c > 0)\n\t\t    return p->c; // yes!\n\t\treturn 0;\n\t}\n    }\n    return 0;\n}\n\n/*\n * Figure out if the NFA state list contains just literal text and nothing\n * else.  If so return a string in allocated memory with what must match after\n * regstart.  Otherwise return NULL.\n */\n    static char_u *\nnfa_get_match_text(nfa_state_T *start)\n{\n    nfa_state_T *p = start;\n    int\t\tlen = 0;\n    char_u\t*ret;\n    char_u\t*s;\n\n    if (p->c != NFA_MOPEN)\n\treturn NULL; // just in case\n    p = p->out;\n    while (p->c > 0)\n    {\n\tlen += MB_CHAR2LEN(p->c);\n\tp = p->out;\n    }\n    if (p->c != NFA_MCLOSE || p->out->c != NFA_MATCH)\n\treturn NULL;\n\n    ret = alloc(len);\n    if (ret != NULL)\n    {\n\tp = start->out->out; // skip first char, it goes into regstart\n\ts = ret;\n\twhile (p->c > 0)\n\t{\n\t    if (has_mbyte)\n\t\ts += (*mb_char2bytes)(p->c, s);\n\t    else\n\t\t*s++ = p->c;\n\t    p = p->out;\n\t}\n\t*s = NUL;\n    }\n    return ret;\n}\n\n/*\n * Allocate more space for post_start.  Called when\n * running above the estimated number of states.\n */\n    static int\nrealloc_post_list(void)\n{\n    int   nstate_max = (int)(post_end - post_start);\n    int   new_max;\n    int   *new_start;\n    int\t  *old_start;\n\n    // For weird patterns the number of states can be very high. Increasing by\n    // 50% seems a reasonable compromise between memory use and speed.\n    new_max = nstate_max * 3 / 2;\n    new_start = ALLOC_MULT(int, new_max);\n    if (new_start == NULL)\n\treturn FAIL;\n    mch_memmove(new_start, post_start, nstate_max * sizeof(int));\n    old_start = post_start;\n    post_start = new_start;\n    post_ptr = new_start + (post_ptr - old_start);\n    post_end = post_start + new_max;\n    vim_free(old_start);\n    return OK;\n}\n\n/*\n * Search between \"start\" and \"end\" and try to recognize a\n * character class in expanded form. For example [0-9].\n * On success, return the id the character class to be emitted.\n * On failure, return 0 (=FAIL)\n * Start points to the first char of the range, while end should point\n * to the closing brace.\n * Keep in mind that 'ignorecase' applies at execution time, thus [a-z] may\n * need to be interpreted as [a-zA-Z].\n */\n    static int\nnfa_recognize_char_class(char_u *start, char_u *end, int extra_newl)\n{\n#   define CLASS_not\t\t0x80\n#   define CLASS_af\t\t0x40\n#   define CLASS_AF\t\t0x20\n#   define CLASS_az\t\t0x10\n#   define CLASS_AZ\t\t0x08\n#   define CLASS_o7\t\t0x04\n#   define CLASS_o9\t\t0x02\n#   define CLASS_underscore\t0x01\n\n    int\t\tnewl = FALSE;\n    char_u\t*p;\n    int\t\tconfig = 0;\n\n    if (extra_newl == TRUE)\n\tnewl = TRUE;\n\n    if (*end != ']')\n\treturn FAIL;\n    p = start;\n    if (*p == '^')\n    {\n\tconfig |= CLASS_not;\n\tp++;\n    }\n\n    while (p < end)\n    {\n\tif (p + 2 < end && *(p + 1) == '-')\n\t{\n\t    switch (*p)\n\t    {\n\t\tcase '0':\n\t\t    if (*(p + 2) == '9')\n\t\t    {\n\t\t\tconfig |= CLASS_o9;\n\t\t\tbreak;\n\t\t    }\n\t\t    if (*(p + 2) == '7')\n\t\t    {\n\t\t\tconfig |= CLASS_o7;\n\t\t\tbreak;\n\t\t    }\n\t\t    return FAIL;\n\n\t\tcase 'a':\n\t\t    if (*(p + 2) == 'z')\n\t\t    {\n\t\t\tconfig |= CLASS_az;\n\t\t\tbreak;\n\t\t    }\n\t\t    if (*(p + 2) == 'f')\n\t\t    {\n\t\t\tconfig |= CLASS_af;\n\t\t\tbreak;\n\t\t    }\n\t\t    return FAIL;\n\n\t\tcase 'A':\n\t\t    if (*(p + 2) == 'Z')\n\t\t    {\n\t\t\tconfig |= CLASS_AZ;\n\t\t\tbreak;\n\t\t    }\n\t\t    if (*(p + 2) == 'F')\n\t\t    {\n\t\t\tconfig |= CLASS_AF;\n\t\t\tbreak;\n\t\t    }\n\t\t    return FAIL;\n\n\t\tdefault:\n\t\t    return FAIL;\n\t    }\n\t    p += 3;\n\t}\n\telse if (p + 1 < end && *p == '\\\\' && *(p + 1) == 'n')\n\t{\n\t    newl = TRUE;\n\t    p += 2;\n\t}\n\telse if (*p == '_')\n\t{\n\t    config |= CLASS_underscore;\n\t    p ++;\n\t}\n\telse if (*p == '\\n')\n\t{\n\t    newl = TRUE;\n\t    p ++;\n\t}\n\telse\n\t    return FAIL;\n    } // while (p < end)\n\n    if (p != end)\n\treturn FAIL;\n\n    if (newl == TRUE)\n\textra_newl = NFA_ADD_NL;\n\n    switch (config)\n    {\n\tcase CLASS_o9:\n\t    return extra_newl + NFA_DIGIT;\n\tcase CLASS_not |  CLASS_o9:\n\t    return extra_newl + NFA_NDIGIT;\n\tcase CLASS_af | CLASS_AF | CLASS_o9:\n\t    return extra_newl + NFA_HEX;\n\tcase CLASS_not | CLASS_af | CLASS_AF | CLASS_o9:\n\t    return extra_newl + NFA_NHEX;\n\tcase CLASS_o7:\n\t    return extra_newl + NFA_OCTAL;\n\tcase CLASS_not | CLASS_o7:\n\t    return extra_newl + NFA_NOCTAL;\n\tcase CLASS_az | CLASS_AZ | CLASS_o9 | CLASS_underscore:\n\t    return extra_newl + NFA_WORD;\n\tcase CLASS_not | CLASS_az | CLASS_AZ | CLASS_o9 | CLASS_underscore:\n\t    return extra_newl + NFA_NWORD;\n\tcase CLASS_az | CLASS_AZ | CLASS_underscore:\n\t    return extra_newl + NFA_HEAD;\n\tcase CLASS_not | CLASS_az | CLASS_AZ | CLASS_underscore:\n\t    return extra_newl + NFA_NHEAD;\n\tcase CLASS_az | CLASS_AZ:\n\t    return extra_newl + NFA_ALPHA;\n\tcase CLASS_not | CLASS_az | CLASS_AZ:\n\t    return extra_newl + NFA_NALPHA;\n\tcase CLASS_az:\n\t   return extra_newl + NFA_LOWER_IC;\n\tcase CLASS_not | CLASS_az:\n\t    return extra_newl + NFA_NLOWER_IC;\n\tcase CLASS_AZ:\n\t    return extra_newl + NFA_UPPER_IC;\n\tcase CLASS_not | CLASS_AZ:\n\t    return extra_newl + NFA_NUPPER_IC;\n    }\n    return FAIL;\n}\n\n/*\n * Produce the bytes for equivalence class \"c\".\n * Currently only handles latin1, latin9 and utf-8.\n * Emits bytes in postfix notation: 'a,b,NFA_OR,c,NFA_OR' is\n * equivalent to 'a OR b OR c'\n *\n * NOTE! When changing this function, also update reg_equi_class()\n */\n    static int\nnfa_emit_equi_class(int c)\n{\n#define EMIT2(c)    EMIT(c); EMIT(NFA_CONCAT);\n\n    if (enc_utf8 || STRCMP(p_enc, \"latin1\") == 0\n\t\t\t\t\t || STRCMP(p_enc, \"iso-8859-15\") == 0)\n    {\n#ifdef EBCDIC\n# define A_circumflex 0x62\n# define A_diaeresis 0x63\n# define A_grave 0x64\n# define A_acute 0x65\n# define A_virguilla 0x66\n# define A_ring 0x67\n# define C_cedilla 0x68\n# define E_acute 0x71\n# define E_circumflex 0x72\n# define E_diaeresis 0x73\n# define E_grave 0x74\n# define I_acute 0x75\n# define I_circumflex 0x76\n# define I_diaeresis 0x77\n# define I_grave 0x78\n# define N_virguilla 0x69\n# define O_circumflex 0xeb\n# define O_diaeresis 0xec\n# define O_grave 0xed\n# define O_acute 0xee\n# define O_virguilla 0xef\n# define O_slash 0x80\n# define U_circumflex 0xfb\n# define U_diaeresis 0xfc\n# define U_grave 0xfd\n# define U_acute 0xfe\n# define Y_acute 0xba\n# define a_grave 0x42\n# define a_acute 0x43\n# define a_circumflex 0x44\n# define a_virguilla 0x45\n# define a_diaeresis 0x46\n# define a_ring 0x47\n# define c_cedilla 0x48\n# define e_grave 0x51\n# define e_acute 0x52\n# define e_circumflex 0x53\n# define e_diaeresis 0x54\n# define i_grave 0x55\n# define i_acute 0x56\n# define i_circumflex 0x57\n# define i_diaeresis 0x58\n# define n_virguilla 0x49\n# define o_grave 0xcb\n# define o_acute 0xcc\n# define o_circumflex 0xcd\n# define o_virguilla 0xce\n# define o_diaeresis 0xcf\n# define o_slash 0x70\n# define u_grave 0xdb\n# define u_acute 0xdc\n# define u_circumflex 0xdd\n# define u_diaeresis 0xde\n# define y_acute 0x8d\n# define y_diaeresis 0xdf\n#else\n# define A_grave 0xc0\n# define A_acute 0xc1\n# define A_circumflex 0xc2\n# define A_virguilla 0xc3\n# define A_diaeresis 0xc4\n# define A_ring 0xc5\n# define C_cedilla 0xc7\n# define E_grave 0xc8\n# define E_acute 0xc9\n# define E_circumflex 0xca\n# define E_diaeresis 0xcb\n# define I_grave 0xcc\n# define I_acute 0xcd\n# define I_circumflex 0xce\n# define I_diaeresis 0xcf\n# define N_virguilla 0xd1\n# define O_grave 0xd2\n# define O_acute 0xd3\n# define O_circumflex 0xd4\n# define O_virguilla 0xd5\n# define O_diaeresis 0xd6\n# define O_slash 0xd8\n# define U_grave 0xd9\n# define U_acute 0xda\n# define U_circumflex 0xdb\n# define U_diaeresis 0xdc\n# define Y_acute 0xdd\n# define a_grave 0xe0\n# define a_acute 0xe1\n# define a_circumflex 0xe2\n# define a_virguilla 0xe3\n# define a_diaeresis 0xe4\n# define a_ring 0xe5\n# define c_cedilla 0xe7\n# define e_grave 0xe8\n# define e_acute 0xe9\n# define e_circumflex 0xea\n# define e_diaeresis 0xeb\n# define i_grave 0xec\n# define i_acute 0xed\n# define i_circumflex 0xee\n# define i_diaeresis 0xef\n# define n_virguilla 0xf1\n# define o_grave 0xf2\n# define o_acute 0xf3\n# define o_circumflex 0xf4\n# define o_virguilla 0xf5\n# define o_diaeresis 0xf6\n# define o_slash 0xf8\n# define u_grave 0xf9\n# define u_acute 0xfa\n# define u_circumflex 0xfb\n# define u_diaeresis 0xfc\n# define y_acute 0xfd\n# define y_diaeresis 0xff\n#endif\n\tswitch (c)\n\t{\n\t    case 'A': case A_grave: case A_acute: case A_circumflex:\n\t    case A_virguilla: case A_diaeresis: case A_ring:\n\t    case 0x100: case 0x102: case 0x104: case 0x1cd:\n\t    case 0x1de: case 0x1e0: case 0x1fa: case 0x200:\n\t    case 0x202: case 0x226: case 0x23a: case 0x1e00:\n\t    case 0x1ea0: case 0x1ea2: case 0x1ea4: case 0x1ea6:\n\t    case 0x1ea8: case 0x1eaa: case 0x1eac: case 0x1eae:\n\t    case 0x1eb0: case 0x1eb2: case 0x1eb4: case 0x1eb6:\n\t\t    EMIT2('A') EMIT2(A_grave) EMIT2(A_acute)\n\t\t    EMIT2(A_circumflex) EMIT2(A_virguilla)\n\t\t    EMIT2(A_diaeresis) EMIT2(A_ring)\n\t\t    EMIT2(0x100) EMIT2(0x102) EMIT2(0x104)\n\t\t    EMIT2(0x1cd) EMIT2(0x1de) EMIT2(0x1e0)\n\t\t    EMIT2(0x1fa) EMIT2(0x200) EMIT2(0x202)\n\t\t    EMIT2(0x226) EMIT2(0x23a) EMIT2(0x1e00)\n\t\t    EMIT2(0x1ea0) EMIT2(0x1ea2) EMIT2(0x1ea4)\n\t\t    EMIT2(0x1ea6) EMIT2(0x1ea8) EMIT2(0x1eaa)\n\t\t    EMIT2(0x1eac) EMIT2(0x1eae) EMIT2(0x1eb0)\n\t\t    EMIT2(0x1eb2) EMIT2(0x1eb6) EMIT2(0x1eb4)\n\t\t    return OK;\n\n\t    case 'B': case 0x181: case 0x243: case 0x1e02:\n\t    case 0x1e04: case 0x1e06:\n\t\t    EMIT2('B')\n\t\t    EMIT2(0x181) EMIT2(0x243) EMIT2(0x1e02)\n\t\t    EMIT2(0x1e04) EMIT2(0x1e06)\n\t\t    return OK;\n\n\t    case 'C': case C_cedilla: case 0x106: case 0x108:\n\t    case 0x10a: case 0x10c: case 0x187: case 0x23b:\n\t    case 0x1e08: case 0xa792:\n\t\t    EMIT2('C') EMIT2(C_cedilla)\n\t\t    EMIT2(0x106) EMIT2(0x108) EMIT2(0x10a)\n\t\t    EMIT2(0x10c) EMIT2(0x187) EMIT2(0x23b)\n\t\t    EMIT2(0x1e08) EMIT2(0xa792)\n\t\t    return OK;\n\n\t    case 'D': case 0x10e: case 0x110: case 0x18a:\n\t    case 0x1e0a: case 0x1e0c: case 0x1e0e: case 0x1e10:\n\t    case 0x1e12:\n\t\t    EMIT2('D') EMIT2(0x10e) EMIT2(0x110) EMIT2(0x18a)\n\t\t    EMIT2(0x1e0a) EMIT2(0x1e0c) EMIT2(0x1e0e)\n\t\t    EMIT2(0x1e10) EMIT2(0x1e12)\n\t\t    return OK;\n\n\t    case 'E': case E_grave: case E_acute: case E_circumflex:\n\t    case E_diaeresis: case 0x112: case 0x114: case 0x116:\n\t    case 0x118: case 0x11a: case 0x204: case 0x206:\n\t    case 0x228: case 0x246: case 0x1e14: case 0x1e16:\n\t    case 0x1e18: case 0x1e1a: case 0x1e1c: case 0x1eb8:\n\t    case 0x1eba: case 0x1ebc: case 0x1ebe: case 0x1ec0:\n\t    case 0x1ec2: case 0x1ec4: case 0x1ec6:\n\t\t    EMIT2('E') EMIT2(E_grave) EMIT2(E_acute)\n\t\t    EMIT2(E_circumflex) EMIT2(E_diaeresis)\n\t\t    EMIT2(0x112) EMIT2(0x114) EMIT2(0x116)\n\t\t    EMIT2(0x118) EMIT2(0x11a) EMIT2(0x204)\n\t\t    EMIT2(0x206) EMIT2(0x228) EMIT2(0x246)\n\t\t    EMIT2(0x1e14) EMIT2(0x1e16) EMIT2(0x1e18)\n\t\t    EMIT2(0x1e1a) EMIT2(0x1e1c) EMIT2(0x1eb8)\n\t\t    EMIT2(0x1eba) EMIT2(0x1ebc) EMIT2(0x1ebe)\n\t\t    EMIT2(0x1ec0) EMIT2(0x1ec2) EMIT2(0x1ec4)\n\t\t    EMIT2(0x1ec6)\n\t\t    return OK;\n\n\t    case 'F': case 0x191: case 0x1e1e: case 0xa798:\n\t\t    EMIT2('F') EMIT2(0x191) EMIT2(0x1e1e) EMIT2(0xa798)\n\t\t    return OK;\n\n\t    case 'G': case 0x11c: case 0x11e: case 0x120:\n\t    case 0x122: case 0x193: case 0x1e4: case 0x1e6:\n\t    case 0x1f4: case 0x1e20: case 0xa7a0:\n\t\t    EMIT2('G') EMIT2(0x11c) EMIT2(0x11e) EMIT2(0x120)\n\t\t    EMIT2(0x122) EMIT2(0x193) EMIT2(0x1e4)\n\t\t    EMIT2(0x1e6) EMIT2(0x1f4) EMIT2(0x1e20)\n\t\t    EMIT2(0xa7a0)\n\t\t    return OK;\n\n\t    case 'H': case 0x124: case 0x126: case 0x21e:\n\t    case 0x1e22: case 0x1e24: case 0x1e26: case 0x1e28:\n\t    case 0x1e2a: case 0x2c67:\n\t\t    EMIT2('H') EMIT2(0x124) EMIT2(0x126) EMIT2(0x21e)\n\t\t    EMIT2(0x1e22) EMIT2(0x1e24) EMIT2(0x1e26)\n\t\t    EMIT2(0x1e28) EMIT2(0x1e2a) EMIT2(0x2c67)\n\t\t    return OK;\n\n\t    case 'I': case I_grave: case I_acute: case I_circumflex:\n\t    case I_diaeresis: case 0x128: case 0x12a: case 0x12c:\n\t    case 0x12e: case 0x130: case 0x197: case 0x1cf:\n\t    case 0x208: case 0x20a: case 0x1e2c: case 0x1e2e:\n\t    case 0x1ec8: case 0x1eca:\n\t\t    EMIT2('I') EMIT2(I_grave) EMIT2(I_acute)\n\t\t    EMIT2(I_circumflex) EMIT2(I_diaeresis)\n\t\t    EMIT2(0x128) EMIT2(0x12a) EMIT2(0x12c)\n\t\t    EMIT2(0x12e) EMIT2(0x130) EMIT2(0x197)\n\t\t    EMIT2(0x1cf) EMIT2(0x208) EMIT2(0x20a)\n\t\t    EMIT2(0x1e2c) EMIT2(0x1e2e) EMIT2(0x1ec8)\n\t\t    EMIT2(0x1eca)\n\t\t    return OK;\n\n\t    case 'J': case 0x134: case 0x248:\n\t\t    EMIT2('J') EMIT2(0x134) EMIT2(0x248)\n\t\t    return OK;\n\n\t    case 'K': case 0x136: case 0x198: case 0x1e8: case 0x1e30:\n\t    case 0x1e32: case 0x1e34: case 0x2c69: case 0xa740:\n\t\t    EMIT2('K') EMIT2(0x136) EMIT2(0x198) EMIT2(0x1e8)\n\t\t    EMIT2(0x1e30) EMIT2(0x1e32) EMIT2(0x1e34)\n\t\t    EMIT2(0x2c69) EMIT2(0xa740)\n\t\t    return OK;\n\n\t    case 'L': case 0x139: case 0x13b: case 0x13d:\n\t    case 0x13f: case 0x141: case 0x23d: case 0x1e36:\n\t    case 0x1e38: case 0x1e3a: case 0x1e3c: case 0x2c60:\n\t\t    EMIT2('L') EMIT2(0x139) EMIT2(0x13b)\n\t\t    EMIT2(0x13d) EMIT2(0x13f) EMIT2(0x141)\n\t\t    EMIT2(0x23d) EMIT2(0x1e36) EMIT2(0x1e38)\n\t\t    EMIT2(0x1e3a) EMIT2(0x1e3c) EMIT2(0x2c60)\n\t\t    return OK;\n\n\t    case 'M': case 0x1e3e: case 0x1e40: case 0x1e42:\n\t\t    EMIT2('M') EMIT2(0x1e3e) EMIT2(0x1e40)\n\t\t    EMIT2(0x1e42)\n\t\t    return OK;\n\n\t    case 'N': case N_virguilla:\n\t    case 0x143: case 0x145: case 0x147: case 0x1f8:\n\t    case 0x1e44: case 0x1e46: case 0x1e48: case 0x1e4a:\n\t    case 0xa7a4:\n\t\t    EMIT2('N') EMIT2(N_virguilla)\n\t\t    EMIT2(0x143) EMIT2(0x145) EMIT2(0x147)\n\t\t    EMIT2(0x1f8) EMIT2(0x1e44) EMIT2(0x1e46)\n\t\t    EMIT2(0x1e48) EMIT2(0x1e4a) EMIT2(0xa7a4)\n\t\t    return OK;\n\n\t    case 'O': case O_grave: case O_acute: case O_circumflex:\n\t    case O_virguilla: case O_diaeresis: case O_slash:\n\t    case 0x14c: case 0x14e: case 0x150: case 0x19f:\n\t    case 0x1a0: case 0x1d1: case 0x1ea: case 0x1ec:\n\t    case 0x1fe: case 0x20c: case 0x20e: case 0x22a:\n\t    case 0x22c: case 0x22e: case 0x230: case 0x1e4c:\n\t    case 0x1e4e: case 0x1e50: case 0x1e52: case 0x1ecc:\n\t    case 0x1ece: case 0x1ed0: case 0x1ed2: case 0x1ed4:\n\t    case 0x1ed6: case 0x1ed8: case 0x1eda: case 0x1edc:\n\t    case 0x1ede: case 0x1ee0: case 0x1ee2:\n\t\t    EMIT2('O') EMIT2(O_grave) EMIT2(O_acute)\n\t\t    EMIT2(O_circumflex) EMIT2(O_virguilla)\n\t\t    EMIT2(O_diaeresis) EMIT2(O_slash)\n\t\t    EMIT2(0x14c) EMIT2(0x14e) EMIT2(0x150)\n\t\t    EMIT2(0x19f) EMIT2(0x1a0) EMIT2(0x1d1)\n\t\t    EMIT2(0x1ea) EMIT2(0x1ec) EMIT2(0x1fe)\n\t\t    EMIT2(0x20c) EMIT2(0x20e) EMIT2(0x22a)\n\t\t    EMIT2(0x22c) EMIT2(0x22e) EMIT2(0x230)\n\t\t    EMIT2(0x1e4c) EMIT2(0x1e4e) EMIT2(0x1e50)\n\t\t    EMIT2(0x1e52) EMIT2(0x1ecc) EMIT2(0x1ece)\n\t\t    EMIT2(0x1ed0) EMIT2(0x1ed2) EMIT2(0x1ed4)\n\t\t    EMIT2(0x1ed6) EMIT2(0x1ed8) EMIT2(0x1eda)\n\t\t    EMIT2(0x1edc) EMIT2(0x1ede) EMIT2(0x1ee0)\n\t\t    EMIT2(0x1ee2)\n\t\t    return OK;\n\n\t    case 'P': case 0x1a4: case 0x1e54: case 0x1e56: case 0x2c63:\n\t\t    EMIT2('P') EMIT2(0x1a4) EMIT2(0x1e54) EMIT2(0x1e56)\n\t\t    EMIT2(0x2c63)\n\t\t    return OK;\n\n\t    case 'Q': case 0x24a:\n\t\t    EMIT2('Q') EMIT2(0x24a)\n\t\t    return OK;\n\n\t    case 'R': case 0x154: case 0x156: case 0x158: case 0x210:\n\t    case 0x212: case 0x24c: case 0x1e58: case 0x1e5a:\n\t    case 0x1e5c: case 0x1e5e: case 0x2c64: case 0xa7a6:\n\t\t    EMIT2('R') EMIT2(0x154) EMIT2(0x156) EMIT2(0x158)\n\t\t    EMIT2(0x210) EMIT2(0x212) EMIT2(0x24c) EMIT2(0x1e58)\n\t\t    EMIT2(0x1e5a) EMIT2(0x1e5c) EMIT2(0x1e5e) EMIT2(0x2c64)\n\t\t    EMIT2(0xa7a6)\n\t\t    return OK;\n\n\t    case 'S': case 0x15a: case 0x15c: case 0x15e: case 0x160:\n\t    case 0x218: case 0x1e60: case 0x1e62: case 0x1e64:\n\t    case 0x1e66: case 0x1e68: case 0x2c7e: case 0xa7a8:\n\t\t    EMIT2('S') EMIT2(0x15a) EMIT2(0x15c) EMIT2(0x15e)\n\t\t    EMIT2(0x160) EMIT2(0x218) EMIT2(0x1e60) EMIT2(0x1e62)\n\t\t    EMIT2(0x1e64) EMIT2(0x1e66) EMIT2(0x1e68) EMIT2(0x2c7e)\n\t\t    EMIT2(0xa7a8)\n\t\t    return OK;\n\n\t    case 'T': case 0x162: case 0x164: case 0x166: case 0x1ac:\n\t    case 0x1ae: case 0x21a: case 0x23e: case 0x1e6a: case 0x1e6c:\n\t    case 0x1e6e: case 0x1e70:\n\t\t    EMIT2('T') EMIT2(0x162) EMIT2(0x164) EMIT2(0x166)\n\t\t    EMIT2(0x1ac) EMIT2(0x1ae) EMIT2(0x23e) EMIT2(0x21a)\n\t\t    EMIT2(0x1e6a) EMIT2(0x1e6c) EMIT2(0x1e6e) EMIT2(0x1e70)\n\t\t    return OK;\n\n\t    case 'U': case U_grave: case U_acute: case U_diaeresis:\n\t    case U_circumflex: case 0x168: case 0x16a: case 0x16c:\n\t    case 0x16e: case 0x170: case 0x172: case 0x1af:\n\t    case 0x1d3: case 0x1d5: case 0x1d7: case 0x1d9:\n\t    case 0x1db: case 0x214: case 0x216: case 0x244:\n\t    case 0x1e72: case 0x1e74: case 0x1e76: case 0x1e78:\n\t    case 0x1e7a: case 0x1ee4: case 0x1ee6: case 0x1ee8:\n\t    case 0x1eea: case 0x1eec: case 0x1eee: case 0x1ef0:\n\t\t    EMIT2('U') EMIT2(U_grave) EMIT2(U_acute)\n\t\t    EMIT2(U_diaeresis) EMIT2(U_circumflex)\n\t\t    EMIT2(0x168) EMIT2(0x16a)\n\t\t    EMIT2(0x16c) EMIT2(0x16e) EMIT2(0x170)\n\t\t    EMIT2(0x172) EMIT2(0x1af) EMIT2(0x1d3)\n\t\t    EMIT2(0x1d5) EMIT2(0x1d7) EMIT2(0x1d9)\n\t\t    EMIT2(0x1db) EMIT2(0x214) EMIT2(0x216)\n\t\t    EMIT2(0x244) EMIT2(0x1e72) EMIT2(0x1e74)\n\t\t    EMIT2(0x1e76) EMIT2(0x1e78) EMIT2(0x1e7a)\n\t\t    EMIT2(0x1ee4) EMIT2(0x1ee6) EMIT2(0x1ee8)\n\t\t    EMIT2(0x1eea) EMIT2(0x1eec) EMIT2(0x1eee)\n\t\t    EMIT2(0x1ef0)\n\t\t    return OK;\n\n\t    case 'V': case 0x1b2: case 0x1e7c: case 0x1e7e:\n\t\t    EMIT2('V') EMIT2(0x1b2) EMIT2(0x1e7c) EMIT2(0x1e7e)\n\t\t    return OK;\n\n\t    case 'W': case 0x174: case 0x1e80: case 0x1e82: case 0x1e84:\n\t    case 0x1e86: case 0x1e88:\n\t\t    EMIT2('W') EMIT2(0x174) EMIT2(0x1e80) EMIT2(0x1e82)\n\t\t    EMIT2(0x1e84) EMIT2(0x1e86) EMIT2(0x1e88)\n\t\t    return OK;\n\n\t    case 'X': case 0x1e8a: case 0x1e8c:\n\t\t    EMIT2('X') EMIT2(0x1e8a) EMIT2(0x1e8c)\n\t\t    return OK;\n\n\t    case 'Y': case Y_acute: case 0x176: case 0x178:\n\t    case 0x1b3: case 0x232: case 0x24e: case 0x1e8e:\n\t    case 0x1ef2: case 0x1ef4: case 0x1ef6: case 0x1ef8:\n\t\t    EMIT2('Y') EMIT2(Y_acute)\n\t\t    EMIT2(0x176) EMIT2(0x178) EMIT2(0x1b3)\n\t\t    EMIT2(0x232) EMIT2(0x24e) EMIT2(0x1e8e)\n\t\t    EMIT2(0x1ef2) EMIT2(0x1ef4) EMIT2(0x1ef6)\n\t\t    EMIT2(0x1ef8)\n\t\t    return OK;\n\n\t    case 'Z': case 0x179: case 0x17b: case 0x17d:\n\t    case 0x1b5: case 0x1e90: case 0x1e92: case 0x1e94:\n\t    case 0x2c6b:\n\t\t    EMIT2('Z') EMIT2(0x179) EMIT2(0x17b) EMIT2(0x17d)\n\t\t    EMIT2(0x1b5) EMIT2(0x1e90) EMIT2(0x1e92)\n\t\t    EMIT2(0x1e94) EMIT2(0x2c6b)\n\t\t    return OK;\n\n\t    case 'a': case a_grave: case a_acute: case a_circumflex:\n\t    case a_virguilla: case a_diaeresis: case a_ring:\n\t    case 0x101: case 0x103: case 0x105: case 0x1ce:\n\t    case 0x1df: case 0x1e1: case 0x1fb: case 0x201:\n\t    case 0x203: case 0x227: case 0x1d8f: case 0x1e01:\n\t    case 0x1e9a: case 0x1ea1: case 0x1ea3: case 0x1ea5:\n\t    case 0x1ea7: case 0x1ea9: case 0x1eab: case 0x1ead:\n\t    case 0x1eaf: case 0x1eb1: case 0x1eb3: case 0x1eb5:\n\t    case 0x1eb7: case 0x2c65:\n\t\t    EMIT2('a') EMIT2(a_grave) EMIT2(a_acute)\n\t\t    EMIT2(a_circumflex) EMIT2(a_virguilla)\n\t\t    EMIT2(a_diaeresis) EMIT2(a_ring)\n\t\t    EMIT2(0x101) EMIT2(0x103) EMIT2(0x105)\n\t\t    EMIT2(0x1ce) EMIT2(0x1df) EMIT2(0x1e1)\n\t\t    EMIT2(0x1fb) EMIT2(0x201) EMIT2(0x203)\n\t\t    EMIT2(0x227) EMIT2(0x1d8f) EMIT2(0x1e01)\n\t\t    EMIT2(0x1e9a) EMIT2(0x1ea1) EMIT2(0x1ea3)\n\t\t    EMIT2(0x1ea5) EMIT2(0x1ea7) EMIT2(0x1ea9)\n\t\t    EMIT2(0x1eab) EMIT2(0x1ead) EMIT2(0x1eaf)\n\t\t    EMIT2(0x1eb1) EMIT2(0x1eb3) EMIT2(0x1eb5)\n\t\t    EMIT2(0x1eb7) EMIT2(0x2c65)\n\t\t    return OK;\n\n\t    case 'b': case 0x180: case 0x253: case 0x1d6c: case 0x1d80:\n\t    case 0x1e03: case 0x1e05: case 0x1e07:\n\t\t    EMIT2('b') EMIT2(0x180) EMIT2(0x253) EMIT2(0x1d6c)\n\t\t    EMIT2(0x1d80) EMIT2(0x1e03) EMIT2(0x1e05) EMIT2(0x1e07)\n\t\t    return OK;\n\n\t    case 'c': case c_cedilla: case 0x107: case 0x109: case 0x10b:\n\t    case 0x10d: case 0x188: case 0x23c: case 0x1e09: case 0xa793:\n\t    case 0xa794:\n\t\t    EMIT2('c') EMIT2(c_cedilla)\n\t\t    EMIT2(0x107) EMIT2(0x109) EMIT2(0x10b)\n\t\t    EMIT2(0x10d) EMIT2(0x188) EMIT2(0x23c)\n\t\t    EMIT2(0x1e09) EMIT2(0xa793) EMIT2(0xa794)\n\t\t    return OK;\n\n\t    case 'd': case 0x10f: case 0x111: case 0x257: case 0x1d6d:\n\t    case 0x1d81: case 0x1d91: case 0x1e0b: case 0x1e0d: case 0x1e0f:\n\t    case 0x1e11: case 0x1e13:\n\t\t    EMIT2('d') EMIT2(0x10f) EMIT2(0x111)\n\t\t    EMIT2(0x257) EMIT2(0x1d6d) EMIT2(0x1d81)\n\t\t    EMIT2(0x1d91) EMIT2(0x1e0b) EMIT2(0x1e0d)\n\t\t    EMIT2(0x1e0f) EMIT2(0x1e11) EMIT2(0x1e13)\n\t\t    return OK;\n\n\t    case 'e': case e_grave: case e_acute: case e_circumflex:\n\t    case e_diaeresis: case 0x113: case 0x115: case 0x117:\n\t    case 0x119: case 0x11b: case 0x205: case 0x207:\n\t    case 0x229: case 0x247: case 0x1d92: case 0x1e15:\n\t    case 0x1e17: case 0x1e19: case 0x1e1b: case 0x1e1d:\n\t    case 0x1eb9: case 0x1ebb: case 0x1ebd: case 0x1ebf:\n\t    case 0x1ec1: case 0x1ec3: case 0x1ec5: case 0x1ec7:\n\t\t    EMIT2('e') EMIT2(e_grave) EMIT2(e_acute)\n\t\t    EMIT2(e_circumflex) EMIT2(e_diaeresis)\n\t\t    EMIT2(0x113) EMIT2(0x115)\n\t\t    EMIT2(0x117) EMIT2(0x119) EMIT2(0x11b)\n\t\t    EMIT2(0x205) EMIT2(0x207) EMIT2(0x229)\n\t\t    EMIT2(0x247) EMIT2(0x1d92) EMIT2(0x1e15)\n\t\t    EMIT2(0x1e17) EMIT2(0x1e19) EMIT2(0x1e1b)\n\t\t    EMIT2(0x1e1d) EMIT2(0x1eb9) EMIT2(0x1ebb)\n\t\t    EMIT2(0x1ebd) EMIT2(0x1ebf) EMIT2(0x1ec1)\n\t\t    EMIT2(0x1ec3) EMIT2(0x1ec5) EMIT2(0x1ec7)\n\t\t    return OK;\n\n\t    case 'f': case 0x192: case 0x1d6e: case 0x1d82:\n\t    case 0x1e1f: case 0xa799:\n\t\t    EMIT2('f') EMIT2(0x192) EMIT2(0x1d6e) EMIT2(0x1d82)\n\t\t    EMIT2(0x1e1f) EMIT2(0xa799)\n\t\t    return OK;\n\n\t    case 'g': case 0x11d: case 0x11f: case 0x121: case 0x123:\n\t    case 0x1e5: case 0x1e7: case 0x1f5: case 0x260: case 0x1d83:\n\t    case 0x1e21: case 0xa7a1:\n\t\t    EMIT2('g') EMIT2(0x11d) EMIT2(0x11f) EMIT2(0x121)\n\t\t    EMIT2(0x123) EMIT2(0x1e5) EMIT2(0x1e7)\n\t\t    EMIT2(0x1f5) EMIT2(0x260) EMIT2(0x1d83)\n\t\t    EMIT2(0x1e21) EMIT2(0xa7a1)\n\t\t    return OK;\n\n\t    case 'h': case 0x125: case 0x127: case 0x21f: case 0x1e23:\n\t    case 0x1e25: case 0x1e27: case 0x1e29: case 0x1e2b:\n\t    case 0x1e96: case 0x2c68: case 0xa795:\n\t\t    EMIT2('h') EMIT2(0x125) EMIT2(0x127) EMIT2(0x21f)\n\t\t    EMIT2(0x1e23) EMIT2(0x1e25) EMIT2(0x1e27)\n\t\t    EMIT2(0x1e29) EMIT2(0x1e2b) EMIT2(0x1e96)\n\t\t    EMIT2(0x2c68) EMIT2(0xa795)\n\t\t    return OK;\n\n\t    case 'i': case i_grave: case i_acute: case i_circumflex:\n\t    case i_diaeresis: case 0x129: case 0x12b: case 0x12d:\n\t    case 0x12f: case 0x1d0: case 0x209: case 0x20b:\n\t    case 0x268: case 0x1d96: case 0x1e2d: case 0x1e2f:\n\t    case 0x1ec9: case 0x1ecb:\n\t\t    EMIT2('i') EMIT2(i_grave) EMIT2(i_acute)\n\t\t    EMIT2(i_circumflex) EMIT2(i_diaeresis)\n\t\t    EMIT2(0x129) EMIT2(0x12b) EMIT2(0x12d)\n\t\t    EMIT2(0x12f) EMIT2(0x1d0) EMIT2(0x209)\n\t\t    EMIT2(0x20b) EMIT2(0x268) EMIT2(0x1d96)\n\t\t    EMIT2(0x1e2d) EMIT2(0x1e2f) EMIT2(0x1ec9)\n\t\t    EMIT2(0x1ecb) EMIT2(0x1ecb)\n\t\t    return OK;\n\n\t    case 'j': case 0x135: case 0x1f0: case 0x249:\n\t\t    EMIT2('j') EMIT2(0x135) EMIT2(0x1f0) EMIT2(0x249)\n\t\t    return OK;\n\n\t    case 'k': case 0x137: case 0x199: case 0x1e9: case 0x1d84:\n\t    case 0x1e31: case 0x1e33: case 0x1e35: case 0x2c6a: case 0xa741:\n\t\t    EMIT2('k') EMIT2(0x137) EMIT2(0x199) EMIT2(0x1e9)\n\t\t    EMIT2(0x1d84) EMIT2(0x1e31) EMIT2(0x1e33)\n\t\t    EMIT2(0x1e35) EMIT2(0x2c6a) EMIT2(0xa741)\n\t\t    return OK;\n\n\t    case 'l': case 0x13a: case 0x13c: case 0x13e: case 0x140:\n\t    case 0x142: case 0x19a: case 0x1e37: case 0x1e39: case 0x1e3b:\n\t    case 0x1e3d: case 0x2c61:\n\t\t    EMIT2('l') EMIT2(0x13a) EMIT2(0x13c)\n\t\t    EMIT2(0x13e) EMIT2(0x140) EMIT2(0x142)\n\t\t    EMIT2(0x19a) EMIT2(0x1e37) EMIT2(0x1e39)\n\t\t    EMIT2(0x1e3b) EMIT2(0x1e3d) EMIT2(0x2c61)\n\t\t    return OK;\n\n\t    case 'm': case 0x1d6f: case 0x1e3f: case 0x1e41: case 0x1e43:\n\t\t    EMIT2('m') EMIT2(0x1d6f) EMIT2(0x1e3f)\n\t\t    EMIT2(0x1e41) EMIT2(0x1e43)\n\t\t    return OK;\n\n\t    case 'n': case n_virguilla: case 0x144: case 0x146: case 0x148:\n\t    case 0x149: case 0x1f9: case 0x1d70: case 0x1d87: case 0x1e45:\n\t    case 0x1e47: case 0x1e49: case 0x1e4b: case 0xa7a5:\n\t\t    EMIT2('n') EMIT2(n_virguilla)\n\t\t    EMIT2(0x144) EMIT2(0x146) EMIT2(0x148)\n\t\t    EMIT2(0x149) EMIT2(0x1f9) EMIT2(0x1d70)\n\t\t    EMIT2(0x1d87) EMIT2(0x1e45) EMIT2(0x1e47)\n\t\t    EMIT2(0x1e49) EMIT2(0x1e4b) EMIT2(0xa7a5)\n\t\t    return OK;\n\n\t    case 'o': case o_grave: case o_acute: case o_circumflex:\n\t    case o_virguilla: case o_diaeresis: case o_slash:\n\t    case 0x14d: case 0x14f: case 0x151: case 0x1a1:\n\t    case 0x1d2: case 0x1eb: case 0x1ed: case 0x1ff:\n\t    case 0x20d: case 0x20f: case 0x22b: case 0x22d:\n\t    case 0x22f: case 0x231: case 0x275: case 0x1e4d:\n\t    case 0x1e4f: case 0x1e51: case 0x1e53: case 0x1ecd:\n\t    case 0x1ecf: case 0x1ed1: case 0x1ed3: case 0x1ed5:\n\t    case 0x1ed7: case 0x1ed9: case 0x1edb: case 0x1edd:\n\t    case 0x1edf: case 0x1ee1: case 0x1ee3:\n\t\t    EMIT2('o') EMIT2(o_grave) EMIT2(o_acute)\n\t\t    EMIT2(o_circumflex) EMIT2(o_virguilla)\n\t\t    EMIT2(o_diaeresis) EMIT2(o_slash)\n\t\t    EMIT2(0x14d) EMIT2(0x14f) EMIT2(0x151)\n\t\t    EMIT2(0x1a1) EMIT2(0x1d2) EMIT2(0x1eb)\n\t\t    EMIT2(0x1ed) EMIT2(0x1ff) EMIT2(0x20d)\n\t\t    EMIT2(0x20f) EMIT2(0x22b) EMIT2(0x22d)\n\t\t    EMIT2(0x22f) EMIT2(0x231) EMIT2(0x275)\n\t\t    EMIT2(0x1e4d) EMIT2(0x1e4f) EMIT2(0x1e51)\n\t\t    EMIT2(0x1e53) EMIT2(0x1ecd) EMIT2(0x1ecf)\n\t\t    EMIT2(0x1ed1) EMIT2(0x1ed3) EMIT2(0x1ed5)\n\t\t    EMIT2(0x1ed7) EMIT2(0x1ed9) EMIT2(0x1edb)\n\t\t    EMIT2(0x1edd) EMIT2(0x1edf) EMIT2(0x1ee1)\n\t\t    EMIT2(0x1ee3)\n\t\t    return OK;\n\n\t    case 'p': case 0x1a5: case 0x1d71: case 0x1d7d: case 0x1d88:\n\t    case 0x1e55: case 0x1e57:\n\t\t    EMIT2('p') EMIT2(0x1a5) EMIT2(0x1d71) EMIT2(0x1d7d)\n\t\t    EMIT2(0x1d88) EMIT2(0x1e55) EMIT2(0x1e57)\n\t\t    return OK;\n\n\t    case 'q': case 0x24b: case 0x2a0:\n\t\t    EMIT2('q') EMIT2(0x24b) EMIT2(0x2a0)\n\t\t    return OK;\n\n\t    case 'r': case 0x155: case 0x157: case 0x159: case 0x211:\n\t    case 0x213: case 0x24d: case 0x27d: case 0x1d72: case 0x1d73:\n\t    case 0x1d89: case 0x1e59: case 0x1e5b: case 0x1e5d: case 0x1e5f:\n\t    case 0xa7a7:\n\t\t    EMIT2('r') EMIT2(0x155) EMIT2(0x157) EMIT2(0x159)\n\t\t    EMIT2(0x211) EMIT2(0x213) EMIT2(0x24d) EMIT2(0x27d)\n\t\t    EMIT2(0x1d72) EMIT2(0x1d73) EMIT2(0x1d89) EMIT2(0x1e59)\n\t\t    EMIT2(0x1e5b) EMIT2(0x1e5d) EMIT2(0x1e5f) EMIT2(0xa7a7)\n\t\t    return OK;\n\n\t    case 's': case 0x15b: case 0x15d: case 0x15f: case 0x161:\n\t    case 0x219: case 0x23f: case 0x1d74: case 0x1d8a: case 0x1e61:\n\t    case 0x1e63: case 0x1e65: case 0x1e67: case 0x1e69: case 0xa7a9:\n\t\t    EMIT2('s') EMIT2(0x15b) EMIT2(0x15d) EMIT2(0x15f)\n\t\t    EMIT2(0x161) EMIT2(0x219) EMIT2(0x23f) EMIT2(0x1d74)\n\t\t    EMIT2(0x1d8a) EMIT2(0x1e61) EMIT2(0x1e63) EMIT2(0x1e65)\n\t\t    EMIT2(0x1e67) EMIT2(0x1e69) EMIT2(0xa7a9)\n\t\t    return OK;\n\n\t    case 't': case 0x163: case 0x165: case 0x167: case 0x1ab:\n\t    case 0x1ad: case 0x21b: case 0x288: case 0x1d75: case 0x1e6b:\n\t    case 0x1e6d: case 0x1e6f: case 0x1e71: case 0x1e97: case 0x2c66:\n\t\t    EMIT2('t') EMIT2(0x163) EMIT2(0x165) EMIT2(0x167)\n\t\t    EMIT2(0x1ab) EMIT2(0x1ad) EMIT2(0x21b) EMIT2(0x288)\n\t\t    EMIT2(0x1d75) EMIT2(0x1e6b) EMIT2(0x1e6d) EMIT2(0x1e6f)\n\t\t    EMIT2(0x1e71) EMIT2(0x1e97) EMIT2(0x2c66)\n\t\t    return OK;\n\n\t    case 'u': case u_grave: case u_acute: case u_circumflex:\n\t    case u_diaeresis: case 0x169: case 0x16b: case 0x16d:\n\t    case 0x16f: case 0x171: case 0x173: case 0x1b0: case 0x1d4:\n\t    case 0x1d6: case 0x1d8: case 0x1da: case 0x1dc: case 0x215:\n\t    case 0x217: case 0x289: case 0x1d7e: case 0x1d99: case 0x1e73:\n\t    case 0x1e75: case 0x1e77: case 0x1e79: case 0x1e7b:\n\t    case 0x1ee5: case 0x1ee7: case 0x1ee9: case 0x1eeb:\n\t    case 0x1eed: case 0x1eef: case 0x1ef1:\n\t\t    EMIT2('u') EMIT2(u_grave) EMIT2(u_acute)\n\t\t    EMIT2(u_circumflex) EMIT2(u_diaeresis)\n\t\t    EMIT2(0x169) EMIT2(0x16b)\n\t\t    EMIT2(0x16d) EMIT2(0x16f) EMIT2(0x171)\n\t\t    EMIT2(0x173) EMIT2(0x1d6) EMIT2(0x1d8)\n\t\t    EMIT2(0x215) EMIT2(0x217) EMIT2(0x1b0)\n\t\t    EMIT2(0x1d4) EMIT2(0x1da) EMIT2(0x1dc)\n\t\t    EMIT2(0x289) EMIT2(0x1e73) EMIT2(0x1d7e)\n\t\t    EMIT2(0x1d99) EMIT2(0x1e75) EMIT2(0x1e77)\n\t\t    EMIT2(0x1e79) EMIT2(0x1e7b) EMIT2(0x1ee5)\n\t\t    EMIT2(0x1ee7) EMIT2(0x1ee9) EMIT2(0x1eeb)\n\t\t    EMIT2(0x1eed) EMIT2(0x1eef) EMIT2(0x1ef1)\n\t\t    return OK;\n\n\t    case 'v': case 0x28b: case 0x1d8c: case 0x1e7d: case 0x1e7f:\n\t\t    EMIT2('v') EMIT2(0x28b) EMIT2(0x1d8c) EMIT2(0x1e7d)\n\t\t    EMIT2(0x1e7f)\n\t\t    return OK;\n\n\t    case 'w': case 0x175: case 0x1e81: case 0x1e83: case 0x1e85:\n\t    case 0x1e87: case 0x1e89: case 0x1e98:\n\t\t    EMIT2('w') EMIT2(0x175) EMIT2(0x1e81) EMIT2(0x1e83)\n\t\t    EMIT2(0x1e85) EMIT2(0x1e87) EMIT2(0x1e89) EMIT2(0x1e98)\n\t\t    return OK;\n\n\t    case 'x': case 0x1e8b: case 0x1e8d:\n\t\t    EMIT2('x') EMIT2(0x1e8b) EMIT2(0x1e8d)\n\t\t    return OK;\n\n\t    case 'y': case y_acute: case y_diaeresis: case 0x177:\n\t    case 0x1b4: case 0x233: case 0x24f: case 0x1e8f:\n\t    case 0x1e99: case 0x1ef3: case 0x1ef5: case 0x1ef7:\n\t    case 0x1ef9:\n\t\t    EMIT2('y') EMIT2(y_acute) EMIT2(y_diaeresis)\n\t\t    EMIT2(0x177) EMIT2(0x1b4) EMIT2(0x233) EMIT2(0x24f)\n\t\t    EMIT2(0x1e8f) EMIT2(0x1e99) EMIT2(0x1ef3)\n\t\t    EMIT2(0x1ef5) EMIT2(0x1ef7) EMIT2(0x1ef9)\n\t\t    return OK;\n\n\t    case 'z': case 0x17a: case 0x17c: case 0x17e: case 0x1b6:\n\t    case 0x1d76: case 0x1d8e: case 0x1e91: case 0x1e93:\n\t    case 0x1e95: case 0x2c6c:\n\t\t    EMIT2('z') EMIT2(0x17a) EMIT2(0x17c) EMIT2(0x17e)\n\t\t    EMIT2(0x1b6) EMIT2(0x1d76) EMIT2(0x1d8e) EMIT2(0x1e91)\n\t\t    EMIT2(0x1e93) EMIT2(0x1e95) EMIT2(0x2c6c)\n\t\t    return OK;\n\n\t    // default: character itself\n\t}\n    }\n\n    EMIT2(c);\n    return OK;\n#undef EMIT2\n#undef EMIT2\n}\n\n/*\n * Code to parse regular expression.\n *\n * We try to reuse parsing functions in regexp.c to\n * minimize surprise and keep the syntax consistent.\n */\n\n/*\n * Parse the lowest level.\n *\n * An atom can be one of a long list of items.  Many atoms match one character\n * in the text.  It is often an ordinary character or a character class.\n * Braces can be used to make a pattern into an atom.  The \"\\z(\\)\" construct\n * is only for syntax highlighting.\n *\n * atom    ::=     ordinary-atom\n *     or  \\( pattern \\)\n *     or  \\%( pattern \\)\n *     or  \\z( pattern \\)\n */\n    static int\nnfa_regatom(void)\n{\n    int\t\tc;\n    int\t\tcharclass;\n    int\t\tequiclass;\n    int\t\tcollclass;\n    int\t\tgot_coll_char;\n    char_u\t*p;\n    char_u\t*endp;\n    char_u\t*old_regparse = regparse;\n    int\t\textra = 0;\n    int\t\temit_range;\n    int\t\tnegated;\n    int\t\tresult;\n    int\t\tstartc = -1;\n    int\t\tsave_prev_at_start = prev_at_start;\n\n    c = getchr();\n    switch (c)\n    {\n\tcase NUL:\n\t    EMSG_RET_FAIL(_(e_nul_found));\n\n\tcase Magic('^'):\n\t    EMIT(NFA_BOL);\n\t    break;\n\n\tcase Magic('$'):\n\t    EMIT(NFA_EOL);\n#if defined(FEAT_SYN_HL) || defined(PROTO)\n\t    had_eol = TRUE;\n#endif\n\t    break;\n\n\tcase Magic('<'):\n\t    EMIT(NFA_BOW);\n\t    break;\n\n\tcase Magic('>'):\n\t    EMIT(NFA_EOW);\n\t    break;\n\n\tcase Magic('_'):\n\t    c = no_Magic(getchr());\n\t    if (c == NUL)\n\t\tEMSG_RET_FAIL(_(e_nul_found));\n\n\t    if (c == '^')\t// \"\\_^\" is start-of-line\n\t    {\n\t\tEMIT(NFA_BOL);\n\t\tbreak;\n\t    }\n\t    if (c == '$')\t// \"\\_$\" is end-of-line\n\t    {\n\t\tEMIT(NFA_EOL);\n#if defined(FEAT_SYN_HL) || defined(PROTO)\n\t\thad_eol = TRUE;\n#endif\n\t\tbreak;\n\t    }\n\n\t    extra = NFA_ADD_NL;\n\n\t    // \"\\_[\" is collection plus newline\n\t    if (c == '[')\n\t\tgoto collection;\n\n\t// \"\\_x\" is character class plus newline\n\t// FALLTHROUGH\n\n\t/*\n\t * Character classes.\n\t */\n\tcase Magic('.'):\n\tcase Magic('i'):\n\tcase Magic('I'):\n\tcase Magic('k'):\n\tcase Magic('K'):\n\tcase Magic('f'):\n\tcase Magic('F'):\n\tcase Magic('p'):\n\tcase Magic('P'):\n\tcase Magic('s'):\n\tcase Magic('S'):\n\tcase Magic('d'):\n\tcase Magic('D'):\n\tcase Magic('x'):\n\tcase Magic('X'):\n\tcase Magic('o'):\n\tcase Magic('O'):\n\tcase Magic('w'):\n\tcase Magic('W'):\n\tcase Magic('h'):\n\tcase Magic('H'):\n\tcase Magic('a'):\n\tcase Magic('A'):\n\tcase Magic('l'):\n\tcase Magic('L'):\n\tcase Magic('u'):\n\tcase Magic('U'):\n\t    p = vim_strchr(classchars, no_Magic(c));\n\t    if (p == NULL)\n\t    {\n\t\tif (extra == NFA_ADD_NL)\n\t\t{\n\t\t    semsg(_(e_ill_char_class), c);\n\t\t    rc_did_emsg = TRUE;\n\t\t    return FAIL;\n\t\t}\n\t\tsiemsg(\"INTERNAL: Unknown character class char: %d\", c);\n\t\treturn FAIL;\n\t    }\n\n\t    // When '.' is followed by a composing char ignore the dot, so that\n\t    // the composing char is matched here.\n\t    if (enc_utf8 && c == Magic('.') && utf_iscomposing(peekchr()))\n\t    {\n\t\told_regparse = regparse;\n\t\tc = getchr();\n\t\tgoto nfa_do_multibyte;\n\t    }\n\t    EMIT(nfa_classcodes[p - classchars]);\n\t    if (extra == NFA_ADD_NL)\n\t    {\n\t\tEMIT(NFA_NEWL);\n\t\tEMIT(NFA_OR);\n\t\tregflags |= RF_HASNL;\n\t    }\n\t    break;\n\n\tcase Magic('n'):\n\t    if (reg_string)\n\t\t// In a string \"\\n\" matches a newline character.\n\t\tEMIT(NL);\n\t    else\n\t    {\n\t\t// In buffer text \"\\n\" matches the end of a line.\n\t\tEMIT(NFA_NEWL);\n\t\tregflags |= RF_HASNL;\n\t    }\n\t    break;\n\n\tcase Magic('('):\n\t    if (nfa_reg(REG_PAREN) == FAIL)\n\t\treturn FAIL;\t    // cascaded error\n\t    break;\n\n\tcase Magic('|'):\n\tcase Magic('&'):\n\tcase Magic(')'):\n\t    semsg(_(e_misplaced), no_Magic(c));\n\t    return FAIL;\n\n\tcase Magic('='):\n\tcase Magic('?'):\n\tcase Magic('+'):\n\tcase Magic('@'):\n\tcase Magic('*'):\n\tcase Magic('{'):\n\t    // these should follow an atom, not form an atom\n\t    semsg(_(e_misplaced), no_Magic(c));\n\t    return FAIL;\n\n\tcase Magic('~'):\n\t    {\n\t\tchar_u\t    *lp;\n\n\t\t// Previous substitute pattern.\n\t\t// Generated as \"\\%(pattern\\)\".\n\t\tif (reg_prev_sub == NULL)\n\t\t{\n\t\t    emsg(_(e_no_previous_substitute_regular_expression));\n\t\t    return FAIL;\n\t\t}\n\t\tfor (lp = reg_prev_sub; *lp != NUL; MB_CPTR_ADV(lp))\n\t\t{\n\t\t    EMIT(PTR2CHAR(lp));\n\t\t    if (lp != reg_prev_sub)\n\t\t\tEMIT(NFA_CONCAT);\n\t\t}\n\t\tEMIT(NFA_NOPEN);\n\t\tbreak;\n\t    }\n\n\tcase Magic('1'):\n\tcase Magic('2'):\n\tcase Magic('3'):\n\tcase Magic('4'):\n\tcase Magic('5'):\n\tcase Magic('6'):\n\tcase Magic('7'):\n\tcase Magic('8'):\n\tcase Magic('9'):\n\t    {\n\t\tint refnum = no_Magic(c) - '1';\n\n\t\tif (!seen_endbrace(refnum + 1))\n\t\t    return FAIL;\n\t\tEMIT(NFA_BACKREF1 + refnum);\n\t\trex.nfa_has_backref = TRUE;\n\t    }\n\t    break;\n\n\tcase Magic('z'):\n\t    c = no_Magic(getchr());\n\t    switch (c)\n\t    {\n\t\tcase 's':\n\t\t    EMIT(NFA_ZSTART);\n\t\t    if (re_mult_next(\"\\\\zs\") == FAIL)\n\t\t\treturn FAIL;\n\t\t    break;\n\t\tcase 'e':\n\t\t    EMIT(NFA_ZEND);\n\t\t    rex.nfa_has_zend = TRUE;\n\t\t    if (re_mult_next(\"\\\\ze\") == FAIL)\n\t\t\treturn FAIL;\n\t\t    break;\n#ifdef FEAT_SYN_HL\n\t\tcase '1':\n\t\tcase '2':\n\t\tcase '3':\n\t\tcase '4':\n\t\tcase '5':\n\t\tcase '6':\n\t\tcase '7':\n\t\tcase '8':\n\t\tcase '9':\n\t\t    // \\z1...\\z9\n\t\t    if ((reg_do_extmatch & REX_USE) == 0)\n\t\t\tEMSG_RET_FAIL(_(e_z1_not_allowed));\n\t\t    EMIT(NFA_ZREF1 + (no_Magic(c) - '1'));\n\t\t    // No need to set rex.nfa_has_backref, the sub-matches don't\n\t\t    // change when \\z1 .. \\z9 matches or not.\n\t\t    re_has_z = REX_USE;\n\t\t    break;\n\t\tcase '(':\n\t\t    // \\z(\n\t\t    if ((reg_do_extmatch & REX_SET) == 0)\n\t\t\tEMSG_RET_FAIL(_(e_z_not_allowed));\n\t\t    if (nfa_reg(REG_ZPAREN) == FAIL)\n\t\t\treturn FAIL;\t    // cascaded error\n\t\t    re_has_z = REX_SET;\n\t\t    break;\n#endif\n\t\tdefault:\n\t\t    semsg(_(\"E867: (NFA) Unknown operator '\\\\z%c'\"),\n\t\t\t\t\t\t\t\t no_Magic(c));\n\t\t    return FAIL;\n\t    }\n\t    break;\n\n\tcase Magic('%'):\n\t    c = no_Magic(getchr());\n\t    switch (c)\n\t    {\n\t\t// () without a back reference\n\t\tcase '(':\n\t\t    if (nfa_reg(REG_NPAREN) == FAIL)\n\t\t\treturn FAIL;\n\t\t    EMIT(NFA_NOPEN);\n\t\t    break;\n\n\t\tcase 'd':   // %d123 decimal\n\t\tcase 'o':   // %o123 octal\n\t\tcase 'x':   // %xab hex 2\n\t\tcase 'u':   // %uabcd hex 4\n\t\tcase 'U':   // %U1234abcd hex 8\n\t\t    {\n\t\t\tlong nr;\n\n\t\t\tswitch (c)\n\t\t\t{\n\t\t\t    case 'd': nr = getdecchrs(); break;\n\t\t\t    case 'o': nr = getoctchrs(); break;\n\t\t\t    case 'x': nr = gethexchrs(2); break;\n\t\t\t    case 'u': nr = gethexchrs(4); break;\n\t\t\t    case 'U': nr = gethexchrs(8); break;\n\t\t\t    default:  nr = -1; break;\n\t\t\t}\n\n\t\t\tif (nr < 0 || nr > INT_MAX)\n\t\t\t    EMSG2_RET_FAIL(\n\t\t\t       _(\"E678: Invalid character after %s%%[dxouU]\"),\n\t\t\t\t    reg_magic == MAGIC_ALL);\n\t\t\t// A NUL is stored in the text as NL\n\t\t\t// TODO: what if a composing character follows?\n\t\t\tEMIT(nr == 0 ? 0x0a : nr);\n\t\t    }\n\t\t    break;\n\n\t\t// Catch \\%^ and \\%$ regardless of where they appear in the\n\t\t// pattern -- regardless of whether or not it makes sense.\n\t\tcase '^':\n\t\t    EMIT(NFA_BOF);\n\t\t    break;\n\n\t\tcase '$':\n\t\t    EMIT(NFA_EOF);\n\t\t    break;\n\n\t\tcase '#':\n\t\t    EMIT(NFA_CURSOR);\n\t\t    break;\n\n\t\tcase 'V':\n\t\t    EMIT(NFA_VISUAL);\n\t\t    break;\n\n\t\tcase 'C':\n\t\t    EMIT(NFA_ANY_COMPOSING);\n\t\t    break;\n\n\t\tcase '[':\n\t\t    {\n\t\t\tint\t    n;\n\n\t\t\t// \\%[abc]\n\t\t\tfor (n = 0; (c = peekchr()) != ']'; ++n)\n\t\t\t{\n\t\t\t    if (c == NUL)\n\t\t\t\tEMSG2_RET_FAIL(_(e_missing_sb),\n\t\t\t\t\t\t      reg_magic == MAGIC_ALL);\n\t\t\t    // recursive call!\n\t\t\t    if (nfa_regatom() == FAIL)\n\t\t\t\treturn FAIL;\n\t\t\t}\n\t\t\tgetchr();  // get the ]\n\t\t\tif (n == 0)\n\t\t\t    EMSG2_RET_FAIL(_(e_empty_sb),\n\t\t\t\t\t\t      reg_magic == MAGIC_ALL);\n\t\t\tEMIT(NFA_OPT_CHARS);\n\t\t\tEMIT(n);\n\n\t\t\t// Emit as \"\\%(\\%[abc]\\)\" to be able to handle\n\t\t\t// \"\\%[abc]*\" which would cause the empty string to be\n\t\t\t// matched an unlimited number of times. NFA_NOPEN is\n\t\t\t// added only once at a position, while NFA_SPLIT is\n\t\t\t// added multiple times.  This is more efficient than\n\t\t\t// not allowing NFA_SPLIT multiple times, it is used\n\t\t\t// a lot.\n\t\t\tEMIT(NFA_NOPEN);\n\t\t\tbreak;\n\t\t    }\n\n\t\tdefault:\n\t\t    {\n\t\t\tlong_u\tn = 0;\n\t\t\tint\tcmp = c;\n\t\t\tint\tcur = FALSE;\n\n\t\t\tif (c == '<' || c == '>')\n\t\t\t    c = getchr();\n\t\t\tif (no_Magic(c) == '.')\n\t\t\t{\n\t\t\t    cur = TRUE;\n\t\t\t    c = getchr();\n\t\t\t}\n\t\t\twhile (VIM_ISDIGIT(c))\n\t\t\t{\n\t\t\t    long_u tmp;\n\n\t\t\t    if (cur)\n\t\t\t\tsemsg(_(e_regexp_number_after_dot_pos_search),\n\t\t\t\t\t\t\t\t no_Magic(c));\n\t\t\t    tmp = n * 10 + (c - '0');\n\n\t\t\t    if (tmp < n)\n\t\t\t    {\n\t\t\t\t// overflow.\n\t\t\t\temsg(_(e_value_too_large));\n\t\t\t\treturn FAIL;\n\t\t\t    }\n\t\t\t    n = tmp;\n\t\t\t    c = getchr();\n\t\t\t}\n\t\t\tif (c == 'l' || c == 'c' || c == 'v')\n\t\t\t{\n\t\t\t    long_u limit = INT_MAX;\n\n\t\t\t    if (c == 'l')\n\t\t\t    {\n\t\t\t\tif (cur)\n\t\t\t\t    n = curwin->w_cursor.lnum;\n\t\t\t\t// \\%{n}l  \\%{n}<l  \\%{n}>l\n\t\t\t\tEMIT(cmp == '<' ? NFA_LNUM_LT :\n\t\t\t\t     cmp == '>' ? NFA_LNUM_GT : NFA_LNUM);\n\t\t\t\tif (save_prev_at_start)\n\t\t\t\t    at_start = TRUE;\n\t\t\t    }\n\t\t\t    else if (c == 'c')\n\t\t\t    {\n\t\t\t\tif (cur)\n\t\t\t\t{\n\t\t\t\t    n = curwin->w_cursor.col;\n\t\t\t\t    n++;\n\t\t\t\t}\n\t\t\t\t// \\%{n}c  \\%{n}<c  \\%{n}>c\n\t\t\t\tEMIT(cmp == '<' ? NFA_COL_LT :\n\t\t\t\t     cmp == '>' ? NFA_COL_GT : NFA_COL);\n\t\t\t    }\n\t\t\t    else\n\t\t\t    {\n\t\t\t\tif (cur)\n\t\t\t\t{\n\t\t\t\t    colnr_T vcol = 0;\n\n\t\t\t\t    getvvcol(curwin, &curwin->w_cursor,\n\t\t\t\t\t\t\t    NULL, NULL, &vcol);\n\t\t\t\t    n = ++vcol;\n\t\t\t\t}\n\t\t\t\t// \\%{n}v  \\%{n}<v  \\%{n}>v\n\t\t\t\tEMIT(cmp == '<' ? NFA_VCOL_LT :\n\t\t\t\t     cmp == '>' ? NFA_VCOL_GT : NFA_VCOL);\n\t\t\t\tlimit = INT_MAX / MB_MAXBYTES;\n\t\t\t    }\n\t\t\t    if (n >= limit)\n\t\t\t    {\n\t\t\t\temsg(_(e_value_too_large));\n\t\t\t\treturn FAIL;\n\t\t\t    }\n\t\t\t    EMIT((int)n);\n\t\t\t    break;\n\t\t\t}\n\t\t\telse if (c == '\\'' && n == 0)\n\t\t\t{\n\t\t\t    // \\%'m  \\%<'m  \\%>'m\n\t\t\t    EMIT(cmp == '<' ? NFA_MARK_LT :\n\t\t\t\t cmp == '>' ? NFA_MARK_GT : NFA_MARK);\n\t\t\t    EMIT(getchr());\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t    semsg(_(\"E867: (NFA) Unknown operator '\\\\%%%c'\"),\n\t\t\t\t\t\t\t\t no_Magic(c));\n\t\t    return FAIL;\n\t    }\n\t    break;\n\n\tcase Magic('['):\ncollection:\n\t    /*\n\t     * [abc]  uses NFA_START_COLL - NFA_END_COLL\n\t     * [^abc] uses NFA_START_NEG_COLL - NFA_END_NEG_COLL\n\t     * Each character is produced as a regular state, using\n\t     * NFA_CONCAT to bind them together.\n\t     * Besides normal characters there can be:\n\t     * - character classes  NFA_CLASS_*\n\t     * - ranges, two characters followed by NFA_RANGE.\n\t     */\n\n\t    p = regparse;\n\t    endp = skip_anyof(p);\n\t    if (*endp == ']')\n\t    {\n\t\t/*\n\t\t * Try to reverse engineer character classes. For example,\n\t\t * recognize that [0-9] stands for \\d and [A-Za-z_] for \\h,\n\t\t * and perform the necessary substitutions in the NFA.\n\t\t */\n\t\tresult = nfa_recognize_char_class(regparse, endp,\n\t\t\t\t\t\t\t extra == NFA_ADD_NL);\n\t\tif (result != FAIL)\n\t\t{\n\t\t    if (result >= NFA_FIRST_NL && result <= NFA_LAST_NL)\n\t\t    {\n\t\t\tEMIT(result - NFA_ADD_NL);\n\t\t\tEMIT(NFA_NEWL);\n\t\t\tEMIT(NFA_OR);\n\t\t    }\n\t\t    else\n\t\t\tEMIT(result);\n\t\t    regparse = endp;\n\t\t    MB_PTR_ADV(regparse);\n\t\t    return OK;\n\t\t}\n\t\t/*\n\t\t * Failed to recognize a character class. Use the simple\n\t\t * version that turns [abc] into 'a' OR 'b' OR 'c'\n\t\t */\n\t\tstartc = -1;\n\t\tnegated = FALSE;\n\t\tif (*regparse == '^')\t\t\t// negated range\n\t\t{\n\t\t    negated = TRUE;\n\t\t    MB_PTR_ADV(regparse);\n\t\t    EMIT(NFA_START_NEG_COLL);\n\t\t}\n\t\telse\n\t\t    EMIT(NFA_START_COLL);\n\t\tif (*regparse == '-')\n\t\t{\n\t\t    startc = '-';\n\t\t    EMIT(startc);\n\t\t    EMIT(NFA_CONCAT);\n\t\t    MB_PTR_ADV(regparse);\n\t\t}\n\t\t// Emit the OR branches for each character in the []\n\t\temit_range = FALSE;\n\t\twhile (regparse < endp)\n\t\t{\n\t\t    int\t    oldstartc = startc;\n\n\t\t    startc = -1;\n\t\t    got_coll_char = FALSE;\n\t\t    if (*regparse == '[')\n\t\t    {\n\t\t\t// Check for [: :], [= =], [. .]\n\t\t\tequiclass = collclass = 0;\n\t\t\tcharclass = get_char_class(&regparse);\n\t\t\tif (charclass == CLASS_NONE)\n\t\t\t{\n\t\t\t    equiclass = get_equi_class(&regparse);\n\t\t\t    if (equiclass == 0)\n\t\t\t\tcollclass = get_coll_element(&regparse);\n\t\t\t}\n\n\t\t\t// Character class like [:alpha:]\n\t\t\tif (charclass != CLASS_NONE)\n\t\t\t{\n\t\t\t    switch (charclass)\n\t\t\t    {\n\t\t\t\tcase CLASS_ALNUM:\n\t\t\t\t    EMIT(NFA_CLASS_ALNUM);\n\t\t\t\t    break;\n\t\t\t\tcase CLASS_ALPHA:\n\t\t\t\t    EMIT(NFA_CLASS_ALPHA);\n\t\t\t\t    break;\n\t\t\t\tcase CLASS_BLANK:\n\t\t\t\t    EMIT(NFA_CLASS_BLANK);\n\t\t\t\t    break;\n\t\t\t\tcase CLASS_CNTRL:\n\t\t\t\t    EMIT(NFA_CLASS_CNTRL);\n\t\t\t\t    break;\n\t\t\t\tcase CLASS_DIGIT:\n\t\t\t\t    EMIT(NFA_CLASS_DIGIT);\n\t\t\t\t    break;\n\t\t\t\tcase CLASS_GRAPH:\n\t\t\t\t    EMIT(NFA_CLASS_GRAPH);\n\t\t\t\t    break;\n\t\t\t\tcase CLASS_LOWER:\n\t\t\t\t    wants_nfa = TRUE;\n\t\t\t\t    EMIT(NFA_CLASS_LOWER);\n\t\t\t\t    break;\n\t\t\t\tcase CLASS_PRINT:\n\t\t\t\t    EMIT(NFA_CLASS_PRINT);\n\t\t\t\t    break;\n\t\t\t\tcase CLASS_PUNCT:\n\t\t\t\t    EMIT(NFA_CLASS_PUNCT);\n\t\t\t\t    break;\n\t\t\t\tcase CLASS_SPACE:\n\t\t\t\t    EMIT(NFA_CLASS_SPACE);\n\t\t\t\t    break;\n\t\t\t\tcase CLASS_UPPER:\n\t\t\t\t    wants_nfa = TRUE;\n\t\t\t\t    EMIT(NFA_CLASS_UPPER);\n\t\t\t\t    break;\n\t\t\t\tcase CLASS_XDIGIT:\n\t\t\t\t    EMIT(NFA_CLASS_XDIGIT);\n\t\t\t\t    break;\n\t\t\t\tcase CLASS_TAB:\n\t\t\t\t    EMIT(NFA_CLASS_TAB);\n\t\t\t\t    break;\n\t\t\t\tcase CLASS_RETURN:\n\t\t\t\t    EMIT(NFA_CLASS_RETURN);\n\t\t\t\t    break;\n\t\t\t\tcase CLASS_BACKSPACE:\n\t\t\t\t    EMIT(NFA_CLASS_BACKSPACE);\n\t\t\t\t    break;\n\t\t\t\tcase CLASS_ESCAPE:\n\t\t\t\t    EMIT(NFA_CLASS_ESCAPE);\n\t\t\t\t    break;\n\t\t\t\tcase CLASS_IDENT:\n\t\t\t\t    EMIT(NFA_CLASS_IDENT);\n\t\t\t\t    break;\n\t\t\t\tcase CLASS_KEYWORD:\n\t\t\t\t    EMIT(NFA_CLASS_KEYWORD);\n\t\t\t\t    break;\n\t\t\t\tcase CLASS_FNAME:\n\t\t\t\t    EMIT(NFA_CLASS_FNAME);\n\t\t\t\t    break;\n\t\t\t    }\n\t\t\t    EMIT(NFA_CONCAT);\n\t\t\t    continue;\n\t\t\t}\n\t\t\t// Try equivalence class [=a=] and the like\n\t\t\tif (equiclass != 0)\n\t\t\t{\n\t\t\t    result = nfa_emit_equi_class(equiclass);\n\t\t\t    if (result == FAIL)\n\t\t\t    {\n\t\t\t\t// should never happen\n\t\t\t\tEMSG_RET_FAIL(_(\"E868: Error building NFA with equivalence class!\"));\n\t\t\t    }\n\t\t\t    continue;\n\t\t\t}\n\t\t\t// Try collating class like [. .]\n\t\t\tif (collclass != 0)\n\t\t\t{\n\t\t\t    startc = collclass;\t // allow [.a.]-x as a range\n\t\t\t    // Will emit the proper atom at the end of the\n\t\t\t    // while loop.\n\t\t\t}\n\t\t    }\n\t\t    // Try a range like 'a-x' or '\\t-z'. Also allows '-' as a\n\t\t    // start character.\n\t\t    if (*regparse == '-' && oldstartc != -1)\n\t\t    {\n\t\t\temit_range = TRUE;\n\t\t\tstartc = oldstartc;\n\t\t\tMB_PTR_ADV(regparse);\n\t\t\tcontinue;\t    // reading the end of the range\n\t\t    }\n\n\t\t    // Now handle simple and escaped characters.\n\t\t    // Only \"\\]\", \"\\^\", \"\\]\" and \"\\\\\" are special in Vi.  Vim\n\t\t    // accepts \"\\t\", \"\\e\", etc., but only when the 'l' flag in\n\t\t    // 'cpoptions' is not included.\n\t\t    // Posix doesn't recognize backslash at all.\n\t\t    if (*regparse == '\\\\'\n\t\t\t    && !reg_cpo_bsl\n\t\t\t    && regparse + 1 <= endp\n\t\t\t    && (vim_strchr(REGEXP_INRANGE, regparse[1]) != NULL\n\t\t\t\t|| (!reg_cpo_lit\n\t\t\t\t    && vim_strchr(REGEXP_ABBR, regparse[1])\n\t\t\t\t\t\t\t\t      != NULL)\n\t\t\t    )\n\t\t\t)\n\t\t    {\n\t\t\tMB_PTR_ADV(regparse);\n\n\t\t\tif (*regparse == 'n')\n\t\t\t    startc = (reg_string || emit_range\n\t\t\t\t\t|| regparse[1] == '-') ? NL : NFA_NEWL;\n\t\t\telse if (*regparse == 'd'\n\t\t\t\t    || *regparse == 'o'\n\t\t\t\t    || *regparse == 'x'\n\t\t\t\t    || *regparse == 'u'\n\t\t\t\t    || *regparse == 'U'\n\t\t\t\t)\n\t\t\t    {\n\t\t\t\t// TODO(RE) This needs more testing\n\t\t\t\tstartc = coll_get_char();\n\t\t\t\tgot_coll_char = TRUE;\n\t\t\t\tMB_PTR_BACK(old_regparse, regparse);\n\t\t\t    }\n\t\t\t    else\n\t\t\t    {\n\t\t\t\t// \\r,\\t,\\e,\\b\n\t\t\t\tstartc = backslash_trans(*regparse);\n\t\t\t    }\n\t\t    }\n\n\t\t    // Normal printable char\n\t\t    if (startc == -1)\n\t\t\tstartc = PTR2CHAR(regparse);\n\n\t\t    // Previous char was '-', so this char is end of range.\n\t\t    if (emit_range)\n\t\t    {\n\t\t\tint\tendc = startc;\n\n\t\t\tstartc = oldstartc;\n\t\t\tif (startc > endc)\n\t\t\t    EMSG_RET_FAIL(_(e_reverse_range));\n\n\t\t\tif (endc > startc + 2)\n\t\t\t{\n\t\t\t    // Emit a range instead of the sequence of\n\t\t\t    // individual characters.\n\t\t\t    if (startc == 0)\n\t\t\t\t// \\x00 is translated to \\x0a, start at \\x01.\n\t\t\t\tEMIT(1);\n\t\t\t    else\n\t\t\t\t--post_ptr; // remove NFA_CONCAT\n\t\t\t    EMIT(endc);\n\t\t\t    EMIT(NFA_RANGE);\n\t\t\t    EMIT(NFA_CONCAT);\n\t\t\t}\n\t\t\telse if (has_mbyte && ((*mb_char2len)(startc) > 1\n\t\t\t\t    || (*mb_char2len)(endc) > 1))\n\t\t\t{\n\t\t\t    // Emit the characters in the range.\n\t\t\t    // \"startc\" was already emitted, so skip it.\n\t\t\t    //\n\t\t\t    for (c = startc + 1; c <= endc; c++)\n\t\t\t    {\n\t\t\t\tEMIT(c);\n\t\t\t\tEMIT(NFA_CONCAT);\n\t\t\t    }\n\t\t\t}\n\t\t\telse\n\t\t\t{\n#ifdef EBCDIC\n\t\t\t    int alpha_only = FALSE;\n\n\t\t\t    // for alphabetical range skip the gaps\n\t\t\t    // 'i'-'j', 'r'-'s', 'I'-'J' and 'R'-'S'.\n\t\t\t    if (isalpha(startc) && isalpha(endc))\n\t\t\t\talpha_only = TRUE;\n#endif\n\t\t\t    // Emit the range. \"startc\" was already emitted, so\n\t\t\t    // skip it.\n\t\t\t    for (c = startc + 1; c <= endc; c++)\n#ifdef EBCDIC\n\t\t\t\tif (!alpha_only || isalpha(startc))\n#endif\n\t\t\t\t{\n\t\t\t\t    EMIT(c);\n\t\t\t\t    EMIT(NFA_CONCAT);\n\t\t\t\t}\n\t\t\t}\n\t\t\temit_range = FALSE;\n\t\t\tstartc = -1;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// This char (startc) is not part of a range. Just\n\t\t\t// emit it.\n\t\t\t// Normally, simply emit startc. But if we get char\n\t\t\t// code=0 from a collating char, then replace it with\n\t\t\t// 0x0a.\n\t\t\t// This is needed to completely mimic the behaviour of\n\t\t\t// the backtracking engine.\n\t\t\tif (startc == NFA_NEWL)\n\t\t\t{\n\t\t\t    // Line break can't be matched as part of the\n\t\t\t    // collection, add an OR below. But not for negated\n\t\t\t    // range.\n\t\t\t    if (!negated)\n\t\t\t\textra = NFA_ADD_NL;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    if (got_coll_char == TRUE && startc == 0)\n\t\t\t\tEMIT(0x0a);\n\t\t\t    else\n\t\t\t\tEMIT(startc);\n\t\t\t    EMIT(NFA_CONCAT);\n\t\t\t}\n\t\t    }\n\n\t\t    MB_PTR_ADV(regparse);\n\t\t} // while (p < endp)\n\n\t\tMB_PTR_BACK(old_regparse, regparse);\n\t\tif (*regparse == '-')\t    // if last, '-' is just a char\n\t\t{\n\t\t    EMIT('-');\n\t\t    EMIT(NFA_CONCAT);\n\t\t}\n\n\t\t// skip the trailing ]\n\t\tregparse = endp;\n\t\tMB_PTR_ADV(regparse);\n\n\t\t// Mark end of the collection.\n\t\tif (negated == TRUE)\n\t\t    EMIT(NFA_END_NEG_COLL);\n\t\telse\n\t\t    EMIT(NFA_END_COLL);\n\n\t\t// \\_[] also matches \\n but it's not negated\n\t\tif (extra == NFA_ADD_NL)\n\t\t{\n\t\t    EMIT(reg_string ? NL : NFA_NEWL);\n\t\t    EMIT(NFA_OR);\n\t\t}\n\n\t\treturn OK;\n\t    } // if exists closing ]\n\n\t    if (reg_strict)\n\t\tEMSG_RET_FAIL(_(e_missingbracket));\n\t    // FALLTHROUGH\n\n\tdefault:\n\t    {\n\t\tint\tplen;\n\nnfa_do_multibyte:\n\t\t// plen is length of current char with composing chars\n\t\tif (enc_utf8 && ((*mb_char2len)(c)\n\t\t\t    != (plen = utfc_ptr2len(old_regparse))\n\t\t\t\t\t\t       || utf_iscomposing(c)))\n\t\t{\n\t\t    int i = 0;\n\n\t\t    // A base character plus composing characters, or just one\n\t\t    // or more composing characters.\n\t\t    // This requires creating a separate atom as if enclosing\n\t\t    // the characters in (), where NFA_COMPOSING is the ( and\n\t\t    // NFA_END_COMPOSING is the ). Note that right now we are\n\t\t    // building the postfix form, not the NFA itself;\n\t\t    // a composing char could be: a, b, c, NFA_COMPOSING\n\t\t    // where 'b' and 'c' are chars with codes > 256.\n\t\t    for (;;)\n\t\t    {\n\t\t\tEMIT(c);\n\t\t\tif (i > 0)\n\t\t\t    EMIT(NFA_CONCAT);\n\t\t\tif ((i += utf_char2len(c)) >= plen)\n\t\t\t    break;\n\t\t\tc = utf_ptr2char(old_regparse + i);\n\t\t    }\n\t\t    EMIT(NFA_COMPOSING);\n\t\t    regparse = old_regparse + plen;\n\t\t}\n\t\telse\n\t\t{\n\t\t    c = no_Magic(c);\n\t\t    EMIT(c);\n\t\t}\n\t\treturn OK;\n\t    }\n    }\n\n    return OK;\n}\n\n/*\n * Parse something followed by possible [*+=].\n *\n * A piece is an atom, possibly followed by a multi, an indication of how many\n * times the atom can be matched.  Example: \"a*\" matches any sequence of \"a\"\n * characters: \"\", \"a\", \"aa\", etc.\n *\n * piece   ::=\t    atom\n *\tor  atom  multi\n */\n    static int\nnfa_regpiece(void)\n{\n    int\t\ti;\n    int\t\top;\n    int\t\tret;\n    long\tminval, maxval;\n    int\t\tgreedy = TRUE;      // Braces are prefixed with '-' ?\n    parse_state_T old_state;\n    parse_state_T new_state;\n    long\tc2;\n    int\t\told_post_pos;\n    int\t\tmy_post_start;\n    int\t\tquest;\n\n    // Save the current parse state, so that we can use it if <atom>{m,n} is\n    // next.\n    save_parse_state(&old_state);\n\n    // store current pos in the postfix form, for \\{m,n} involving 0s\n    my_post_start = (int)(post_ptr - post_start);\n\n    ret = nfa_regatom();\n    if (ret == FAIL)\n\treturn FAIL;\t    // cascaded error\n\n    op = peekchr();\n    if (re_multi_type(op) == NOT_MULTI)\n\treturn OK;\n\n    skipchr();\n    switch (op)\n    {\n\tcase Magic('*'):\n\t    EMIT(NFA_STAR);\n\t    break;\n\n\tcase Magic('+'):\n\t    /*\n\t     * Trick: Normally, (a*)\\+ would match the whole input \"aaa\".  The\n\t     * first and only submatch would be \"aaa\". But the backtracking\n\t     * engine interprets the plus as \"try matching one more time\", and\n\t     * a* matches a second time at the end of the input, the empty\n\t     * string.\n\t     * The submatch will be the empty string.\n\t     *\n\t     * In order to be consistent with the old engine, we replace\n\t     * <atom>+ with <atom><atom>*\n\t     */\n\t    restore_parse_state(&old_state);\n\t    curchr = -1;\n\t    if (nfa_regatom() == FAIL)\n\t\treturn FAIL;\n\t    EMIT(NFA_STAR);\n\t    EMIT(NFA_CONCAT);\n\t    skipchr();\t\t// skip the \\+\n\t    break;\n\n\tcase Magic('@'):\n\t    c2 = getdecchrs();\n\t    op = no_Magic(getchr());\n\t    i = 0;\n\t    switch(op)\n\t    {\n\t\tcase '=':\n\t\t    // \\@=\n\t\t    i = NFA_PREV_ATOM_NO_WIDTH;\n\t\t    break;\n\t\tcase '!':\n\t\t    // \\@!\n\t\t    i = NFA_PREV_ATOM_NO_WIDTH_NEG;\n\t\t    break;\n\t\tcase '<':\n\t\t    op = no_Magic(getchr());\n\t\t    if (op == '=')\n\t\t\t// \\@<=\n\t\t\ti = NFA_PREV_ATOM_JUST_BEFORE;\n\t\t    else if (op == '!')\n\t\t\t// \\@<!\n\t\t\ti = NFA_PREV_ATOM_JUST_BEFORE_NEG;\n\t\t    break;\n\t\tcase '>':\n\t\t    // \\@>\n\t\t    i = NFA_PREV_ATOM_LIKE_PATTERN;\n\t\t    break;\n\t    }\n\t    if (i == 0)\n\t    {\n\t\tsemsg(_(\"E869: (NFA) Unknown operator '\\\\@%c'\"), op);\n\t\treturn FAIL;\n\t    }\n\t    EMIT(i);\n\t    if (i == NFA_PREV_ATOM_JUST_BEFORE\n\t\t\t\t\t|| i == NFA_PREV_ATOM_JUST_BEFORE_NEG)\n\t\tEMIT(c2);\n\t    break;\n\n\tcase Magic('?'):\n\tcase Magic('='):\n\t    EMIT(NFA_QUEST);\n\t    break;\n\n\tcase Magic('{'):\n\t    // a{2,5} will expand to 'aaa?a?a?'\n\t    // a{-1,3} will expand to 'aa??a??', where ?? is the nongreedy\n\t    // version of '?'\n\t    // \\v(ab){2,3} will expand to '(ab)(ab)(ab)?', where all the\n\t    // parenthesis have the same id\n\n\t    greedy = TRUE;\n\t    c2 = peekchr();\n\t    if (c2 == '-' || c2 == Magic('-'))\n\t    {\n\t\tskipchr();\n\t\tgreedy = FALSE;\n\t    }\n\t    if (!read_limits(&minval, &maxval))\n\t\tEMSG_RET_FAIL(_(\"E870: (NFA regexp) Error reading repetition limits\"));\n\n\t    //  <atom>{0,inf}, <atom>{0,} and <atom>{}  are equivalent to\n\t    //  <atom>*\n\t    if (minval == 0 && maxval == MAX_LIMIT)\n\t    {\n\t\tif (greedy)\t\t// { { (match the braces)\n\t\t    // \\{}, \\{0,}\n\t\t    EMIT(NFA_STAR);\n\t\telse\t\t\t// { { (match the braces)\n\t\t    // \\{-}, \\{-0,}\n\t\t    EMIT(NFA_STAR_NONGREEDY);\n\t\tbreak;\n\t    }\n\n\t    // Special case: x{0} or x{-0}\n\t    if (maxval == 0)\n\t    {\n\t\t// Ignore result of previous call to nfa_regatom()\n\t\tpost_ptr = post_start + my_post_start;\n\t\t// NFA_EMPTY is 0-length and works everywhere\n\t\tEMIT(NFA_EMPTY);\n\t\treturn OK;\n\t    }\n\n\t    // The engine is very inefficient (uses too many states) when the\n\t    // maximum is much larger than the minimum and when the maximum is\n\t    // large.  However, when maxval is MAX_LIMIT, it is okay, as this\n\t    // will emit NFA_STAR.\n\t    // Bail out if we can use the other engine, but only, when the\n\t    // pattern does not need the NFA engine like (e.g. [[:upper:]]\\{2,\\}\n\t    // does not work with with characters > 8 bit with the BT engine)\n\t    if ((nfa_re_flags & RE_AUTO)\n\t\t\t\t   && (maxval > 500 || maxval > minval + 200)\n\t\t\t\t   && (maxval != MAX_LIMIT && minval < 200)\n\t\t\t\t   && !wants_nfa)\n\t\treturn FAIL;\n\n\t    // Ignore previous call to nfa_regatom()\n\t    post_ptr = post_start + my_post_start;\n\t    // Save parse state after the repeated atom and the \\{}\n\t    save_parse_state(&new_state);\n\n\t    quest = (greedy == TRUE? NFA_QUEST : NFA_QUEST_NONGREEDY);\n\t    for (i = 0; i < maxval; i++)\n\t    {\n\t\t// Goto beginning of the repeated atom\n\t\trestore_parse_state(&old_state);\n\t\told_post_pos = (int)(post_ptr - post_start);\n\t\tif (nfa_regatom() == FAIL)\n\t\t    return FAIL;\n\t\t// after \"minval\" times, atoms are optional\n\t\tif (i + 1 > minval)\n\t\t{\n\t\t    if (maxval == MAX_LIMIT)\n\t\t    {\n\t\t\tif (greedy)\n\t\t\t    EMIT(NFA_STAR);\n\t\t\telse\n\t\t\t    EMIT(NFA_STAR_NONGREEDY);\n\t\t    }\n\t\t    else\n\t\t\tEMIT(quest);\n\t\t}\n\t\tif (old_post_pos != my_post_start)\n\t\t    EMIT(NFA_CONCAT);\n\t\tif (i + 1 > minval && maxval == MAX_LIMIT)\n\t\t    break;\n\t    }\n\n\t    // Go to just after the repeated atom and the \\{}\n\t    restore_parse_state(&new_state);\n\t    curchr = -1;\n\n\t    break;\n\n\n\tdefault:\n\t    break;\n    }\t// end switch\n\n    if (re_multi_type(peekchr()) != NOT_MULTI)\n\t// Can't have a multi follow a multi.\n\tEMSG_RET_FAIL(_(\"E871: (NFA regexp) Can't have a multi follow a multi\"));\n\n    return OK;\n}\n\n/*\n * Parse one or more pieces, concatenated.  It matches a match for the\n * first piece, followed by a match for the second piece, etc.  Example:\n * \"f[0-9]b\", first matches \"f\", then a digit and then \"b\".\n *\n * concat  ::=\t    piece\n *\tor  piece piece\n *\tor  piece piece piece\n *\tetc.\n */\n    static int\nnfa_regconcat(void)\n{\n    int\t\tcont = TRUE;\n    int\t\tfirst = TRUE;\n\n    while (cont)\n    {\n\tswitch (peekchr())\n\t{\n\t    case NUL:\n\t    case Magic('|'):\n\t    case Magic('&'):\n\t    case Magic(')'):\n\t\tcont = FALSE;\n\t\tbreak;\n\n\t    case Magic('Z'):\n\t\tregflags |= RF_ICOMBINE;\n\t\tskipchr_keepstart();\n\t\tbreak;\n\t    case Magic('c'):\n\t\tregflags |= RF_ICASE;\n\t\tskipchr_keepstart();\n\t\tbreak;\n\t    case Magic('C'):\n\t\tregflags |= RF_NOICASE;\n\t\tskipchr_keepstart();\n\t\tbreak;\n\t    case Magic('v'):\n\t\treg_magic = MAGIC_ALL;\n\t\tskipchr_keepstart();\n\t\tcurchr = -1;\n\t\tbreak;\n\t    case Magic('m'):\n\t\treg_magic = MAGIC_ON;\n\t\tskipchr_keepstart();\n\t\tcurchr = -1;\n\t\tbreak;\n\t    case Magic('M'):\n\t\treg_magic = MAGIC_OFF;\n\t\tskipchr_keepstart();\n\t\tcurchr = -1;\n\t\tbreak;\n\t    case Magic('V'):\n\t\treg_magic = MAGIC_NONE;\n\t\tskipchr_keepstart();\n\t\tcurchr = -1;\n\t\tbreak;\n\n\t    default:\n\t\tif (nfa_regpiece() == FAIL)\n\t\t    return FAIL;\n\t\tif (first == FALSE)\n\t\t    EMIT(NFA_CONCAT);\n\t\telse\n\t\t    first = FALSE;\n\t\tbreak;\n\t}\n    }\n\n    return OK;\n}\n\n/*\n * Parse a branch, one or more concats, separated by \"\\&\".  It matches the\n * last concat, but only if all the preceding concats also match at the same\n * position.  Examples:\n *      \"foobeep\\&...\" matches \"foo\" in \"foobeep\".\n *      \".*Peter\\&.*Bob\" matches in a line containing both \"Peter\" and \"Bob\"\n *\n * branch ::=\t    concat\n *\t\tor  concat \\& concat\n *\t\tor  concat \\& concat \\& concat\n *\t\tetc.\n */\n    static int\nnfa_regbranch(void)\n{\n    int\t\told_post_pos;\n\n    old_post_pos = (int)(post_ptr - post_start);\n\n    // First branch, possibly the only one\n    if (nfa_regconcat() == FAIL)\n\treturn FAIL;\n\n    // Try next concats\n    while (peekchr() == Magic('&'))\n    {\n\tskipchr();\n\t// if concat is empty do emit a node\n\tif (old_post_pos == (int)(post_ptr - post_start))\n\t    EMIT(NFA_EMPTY);\n\tEMIT(NFA_NOPEN);\n\tEMIT(NFA_PREV_ATOM_NO_WIDTH);\n\told_post_pos = (int)(post_ptr - post_start);\n\tif (nfa_regconcat() == FAIL)\n\t    return FAIL;\n\t// if concat is empty do emit a node\n\tif (old_post_pos == (int)(post_ptr - post_start))\n\t    EMIT(NFA_EMPTY);\n\tEMIT(NFA_CONCAT);\n    }\n\n    // if a branch is empty, emit one node for it\n    if (old_post_pos == (int)(post_ptr - post_start))\n\tEMIT(NFA_EMPTY);\n\n    return OK;\n}\n\n/*\n *  Parse a pattern, one or more branches, separated by \"\\|\".  It matches\n *  anything that matches one of the branches.  Example: \"foo\\|beep\" matches\n *  \"foo\" and matches \"beep\".  If more than one branch matches, the first one\n *  is used.\n *\n *  pattern ::=\t    branch\n *\tor  branch \\| branch\n *\tor  branch \\| branch \\| branch\n *\tetc.\n */\n    static int\nnfa_reg(\n    int\t\tparen)\t// REG_NOPAREN, REG_PAREN, REG_NPAREN or REG_ZPAREN\n{\n    int\t\tparno = 0;\n\n    if (paren == REG_PAREN)\n    {\n\tif (regnpar >= NSUBEXP) // Too many `('\n\t    EMSG_RET_FAIL(_(\"E872: (NFA regexp) Too many '('\"));\n\tparno = regnpar++;\n    }\n#ifdef FEAT_SYN_HL\n    else if (paren == REG_ZPAREN)\n    {\n\t// Make a ZOPEN node.\n\tif (regnzpar >= NSUBEXP)\n\t    EMSG_RET_FAIL(_(\"E879: (NFA regexp) Too many \\\\z(\"));\n\tparno = regnzpar++;\n    }\n#endif\n\n    if (nfa_regbranch() == FAIL)\n\treturn FAIL;\t    // cascaded error\n\n    while (peekchr() == Magic('|'))\n    {\n\tskipchr();\n\tif (nfa_regbranch() == FAIL)\n\t    return FAIL;    // cascaded error\n\tEMIT(NFA_OR);\n    }\n\n    // Check for proper termination.\n    if (paren != REG_NOPAREN && getchr() != Magic(')'))\n    {\n\tif (paren == REG_NPAREN)\n\t    EMSG2_RET_FAIL(_(e_unmatched_str_percent_open),\n\t\t\t\t\t\t       reg_magic == MAGIC_ALL);\n\telse\n\t    EMSG2_RET_FAIL(_(e_unmatched_str_open), reg_magic == MAGIC_ALL);\n    }\n    else if (paren == REG_NOPAREN && peekchr() != NUL)\n    {\n\tif (peekchr() == Magic(')'))\n\t    EMSG2_RET_FAIL(_(e_unmatched_str_close), reg_magic == MAGIC_ALL);\n\telse\n\t    EMSG_RET_FAIL(_(\"E873: (NFA regexp) proper termination error\"));\n    }\n    /*\n     * Here we set the flag allowing back references to this set of\n     * parentheses.\n     */\n    if (paren == REG_PAREN)\n    {\n\thad_endbrace[parno] = TRUE;     // have seen the close paren\n\tEMIT(NFA_MOPEN + parno);\n    }\n#ifdef FEAT_SYN_HL\n    else if (paren == REG_ZPAREN)\n\tEMIT(NFA_ZOPEN + parno);\n#endif\n\n    return OK;\n}\n\n#ifdef DEBUG\nstatic char_u code[50];\n\n    static void\nnfa_set_code(int c)\n{\n    int\t    addnl = FALSE;\n\n    if (c >= NFA_FIRST_NL && c <= NFA_LAST_NL)\n    {\n\taddnl = TRUE;\n\tc -= NFA_ADD_NL;\n    }\n\n    STRCPY(code, \"\");\n    switch (c)\n    {\n\tcase NFA_MATCH:\t    STRCPY(code, \"NFA_MATCH \"); break;\n\tcase NFA_SPLIT:\t    STRCPY(code, \"NFA_SPLIT \"); break;\n\tcase NFA_CONCAT:    STRCPY(code, \"NFA_CONCAT \"); break;\n\tcase NFA_NEWL:\t    STRCPY(code, \"NFA_NEWL \"); break;\n\tcase NFA_ZSTART:    STRCPY(code, \"NFA_ZSTART\"); break;\n\tcase NFA_ZEND:\t    STRCPY(code, \"NFA_ZEND\"); break;\n\n\tcase NFA_BACKREF1:  STRCPY(code, \"NFA_BACKREF1\"); break;\n\tcase NFA_BACKREF2:  STRCPY(code, \"NFA_BACKREF2\"); break;\n\tcase NFA_BACKREF3:  STRCPY(code, \"NFA_BACKREF3\"); break;\n\tcase NFA_BACKREF4:  STRCPY(code, \"NFA_BACKREF4\"); break;\n\tcase NFA_BACKREF5:  STRCPY(code, \"NFA_BACKREF5\"); break;\n\tcase NFA_BACKREF6:  STRCPY(code, \"NFA_BACKREF6\"); break;\n\tcase NFA_BACKREF7:  STRCPY(code, \"NFA_BACKREF7\"); break;\n\tcase NFA_BACKREF8:  STRCPY(code, \"NFA_BACKREF8\"); break;\n\tcase NFA_BACKREF9:  STRCPY(code, \"NFA_BACKREF9\"); break;\n#ifdef FEAT_SYN_HL\n\tcase NFA_ZREF1:\t    STRCPY(code, \"NFA_ZREF1\"); break;\n\tcase NFA_ZREF2:\t    STRCPY(code, \"NFA_ZREF2\"); break;\n\tcase NFA_ZREF3:\t    STRCPY(code, \"NFA_ZREF3\"); break;\n\tcase NFA_ZREF4:\t    STRCPY(code, \"NFA_ZREF4\"); break;\n\tcase NFA_ZREF5:\t    STRCPY(code, \"NFA_ZREF5\"); break;\n\tcase NFA_ZREF6:\t    STRCPY(code, \"NFA_ZREF6\"); break;\n\tcase NFA_ZREF7:\t    STRCPY(code, \"NFA_ZREF7\"); break;\n\tcase NFA_ZREF8:\t    STRCPY(code, \"NFA_ZREF8\"); break;\n\tcase NFA_ZREF9:\t    STRCPY(code, \"NFA_ZREF9\"); break;\n#endif\n\tcase NFA_SKIP:\t    STRCPY(code, \"NFA_SKIP\"); break;\n\n\tcase NFA_PREV_ATOM_NO_WIDTH:\n\t\t\t    STRCPY(code, \"NFA_PREV_ATOM_NO_WIDTH\"); break;\n\tcase NFA_PREV_ATOM_NO_WIDTH_NEG:\n\t\t\t    STRCPY(code, \"NFA_PREV_ATOM_NO_WIDTH_NEG\"); break;\n\tcase NFA_PREV_ATOM_JUST_BEFORE:\n\t\t\t    STRCPY(code, \"NFA_PREV_ATOM_JUST_BEFORE\"); break;\n\tcase NFA_PREV_ATOM_JUST_BEFORE_NEG:\n\t\t\t STRCPY(code, \"NFA_PREV_ATOM_JUST_BEFORE_NEG\"); break;\n\tcase NFA_PREV_ATOM_LIKE_PATTERN:\n\t\t\t    STRCPY(code, \"NFA_PREV_ATOM_LIKE_PATTERN\"); break;\n\n\tcase NFA_NOPEN:\t\t    STRCPY(code, \"NFA_NOPEN\"); break;\n\tcase NFA_NCLOSE:\t    STRCPY(code, \"NFA_NCLOSE\"); break;\n\tcase NFA_START_INVISIBLE:   STRCPY(code, \"NFA_START_INVISIBLE\"); break;\n\tcase NFA_START_INVISIBLE_FIRST:\n\t\t\t     STRCPY(code, \"NFA_START_INVISIBLE_FIRST\"); break;\n\tcase NFA_START_INVISIBLE_NEG:\n\t\t\t       STRCPY(code, \"NFA_START_INVISIBLE_NEG\"); break;\n\tcase NFA_START_INVISIBLE_NEG_FIRST:\n\t\t\t STRCPY(code, \"NFA_START_INVISIBLE_NEG_FIRST\"); break;\n\tcase NFA_START_INVISIBLE_BEFORE:\n\t\t\t    STRCPY(code, \"NFA_START_INVISIBLE_BEFORE\"); break;\n\tcase NFA_START_INVISIBLE_BEFORE_FIRST:\n\t\t      STRCPY(code, \"NFA_START_INVISIBLE_BEFORE_FIRST\"); break;\n\tcase NFA_START_INVISIBLE_BEFORE_NEG:\n\t\t\tSTRCPY(code, \"NFA_START_INVISIBLE_BEFORE_NEG\"); break;\n\tcase NFA_START_INVISIBLE_BEFORE_NEG_FIRST:\n\t\t  STRCPY(code, \"NFA_START_INVISIBLE_BEFORE_NEG_FIRST\"); break;\n\tcase NFA_START_PATTERN:   STRCPY(code, \"NFA_START_PATTERN\"); break;\n\tcase NFA_END_INVISIBLE:\t    STRCPY(code, \"NFA_END_INVISIBLE\"); break;\n\tcase NFA_END_INVISIBLE_NEG: STRCPY(code, \"NFA_END_INVISIBLE_NEG\"); break;\n\tcase NFA_END_PATTERN:\t    STRCPY(code, \"NFA_END_PATTERN\"); break;\n\n\tcase NFA_COMPOSING:\t    STRCPY(code, \"NFA_COMPOSING\"); break;\n\tcase NFA_END_COMPOSING:\t    STRCPY(code, \"NFA_END_COMPOSING\"); break;\n\tcase NFA_OPT_CHARS:\t    STRCPY(code, \"NFA_OPT_CHARS\"); break;\n\n\tcase NFA_MOPEN:\n\tcase NFA_MOPEN1:\n\tcase NFA_MOPEN2:\n\tcase NFA_MOPEN3:\n\tcase NFA_MOPEN4:\n\tcase NFA_MOPEN5:\n\tcase NFA_MOPEN6:\n\tcase NFA_MOPEN7:\n\tcase NFA_MOPEN8:\n\tcase NFA_MOPEN9:\n\t    STRCPY(code, \"NFA_MOPEN(x)\");\n\t    code[10] = c - NFA_MOPEN + '0';\n\t    break;\n\tcase NFA_MCLOSE:\n\tcase NFA_MCLOSE1:\n\tcase NFA_MCLOSE2:\n\tcase NFA_MCLOSE3:\n\tcase NFA_MCLOSE4:\n\tcase NFA_MCLOSE5:\n\tcase NFA_MCLOSE6:\n\tcase NFA_MCLOSE7:\n\tcase NFA_MCLOSE8:\n\tcase NFA_MCLOSE9:\n\t    STRCPY(code, \"NFA_MCLOSE(x)\");\n\t    code[11] = c - NFA_MCLOSE + '0';\n\t    break;\n#ifdef FEAT_SYN_HL\n\tcase NFA_ZOPEN:\n\tcase NFA_ZOPEN1:\n\tcase NFA_ZOPEN2:\n\tcase NFA_ZOPEN3:\n\tcase NFA_ZOPEN4:\n\tcase NFA_ZOPEN5:\n\tcase NFA_ZOPEN6:\n\tcase NFA_ZOPEN7:\n\tcase NFA_ZOPEN8:\n\tcase NFA_ZOPEN9:\n\t    STRCPY(code, \"NFA_ZOPEN(x)\");\n\t    code[10] = c - NFA_ZOPEN + '0';\n\t    break;\n\tcase NFA_ZCLOSE:\n\tcase NFA_ZCLOSE1:\n\tcase NFA_ZCLOSE2:\n\tcase NFA_ZCLOSE3:\n\tcase NFA_ZCLOSE4:\n\tcase NFA_ZCLOSE5:\n\tcase NFA_ZCLOSE6:\n\tcase NFA_ZCLOSE7:\n\tcase NFA_ZCLOSE8:\n\tcase NFA_ZCLOSE9:\n\t    STRCPY(code, \"NFA_ZCLOSE(x)\");\n\t    code[11] = c - NFA_ZCLOSE + '0';\n\t    break;\n#endif\n\tcase NFA_EOL:\t\tSTRCPY(code, \"NFA_EOL \"); break;\n\tcase NFA_BOL:\t\tSTRCPY(code, \"NFA_BOL \"); break;\n\tcase NFA_EOW:\t\tSTRCPY(code, \"NFA_EOW \"); break;\n\tcase NFA_BOW:\t\tSTRCPY(code, \"NFA_BOW \"); break;\n\tcase NFA_EOF:\t\tSTRCPY(code, \"NFA_EOF \"); break;\n\tcase NFA_BOF:\t\tSTRCPY(code, \"NFA_BOF \"); break;\n\tcase NFA_LNUM:\t\tSTRCPY(code, \"NFA_LNUM \"); break;\n\tcase NFA_LNUM_GT:\tSTRCPY(code, \"NFA_LNUM_GT \"); break;\n\tcase NFA_LNUM_LT:\tSTRCPY(code, \"NFA_LNUM_LT \"); break;\n\tcase NFA_COL:\t\tSTRCPY(code, \"NFA_COL \"); break;\n\tcase NFA_COL_GT:\tSTRCPY(code, \"NFA_COL_GT \"); break;\n\tcase NFA_COL_LT:\tSTRCPY(code, \"NFA_COL_LT \"); break;\n\tcase NFA_VCOL:\t\tSTRCPY(code, \"NFA_VCOL \"); break;\n\tcase NFA_VCOL_GT:\tSTRCPY(code, \"NFA_VCOL_GT \"); break;\n\tcase NFA_VCOL_LT:\tSTRCPY(code, \"NFA_VCOL_LT \"); break;\n\tcase NFA_MARK:\t\tSTRCPY(code, \"NFA_MARK \"); break;\n\tcase NFA_MARK_GT:\tSTRCPY(code, \"NFA_MARK_GT \"); break;\n\tcase NFA_MARK_LT:\tSTRCPY(code, \"NFA_MARK_LT \"); break;\n\tcase NFA_CURSOR:\tSTRCPY(code, \"NFA_CURSOR \"); break;\n\tcase NFA_VISUAL:\tSTRCPY(code, \"NFA_VISUAL \"); break;\n\tcase NFA_ANY_COMPOSING:\tSTRCPY(code, \"NFA_ANY_COMPOSING \"); break;\n\n\tcase NFA_STAR:\t\tSTRCPY(code, \"NFA_STAR \"); break;\n\tcase NFA_STAR_NONGREEDY: STRCPY(code, \"NFA_STAR_NONGREEDY \"); break;\n\tcase NFA_QUEST:\t\tSTRCPY(code, \"NFA_QUEST\"); break;\n\tcase NFA_QUEST_NONGREEDY: STRCPY(code, \"NFA_QUEST_NON_GREEDY\"); break;\n\tcase NFA_EMPTY:\t\tSTRCPY(code, \"NFA_EMPTY\"); break;\n\tcase NFA_OR:\t\tSTRCPY(code, \"NFA_OR\"); break;\n\n\tcase NFA_START_COLL:\tSTRCPY(code, \"NFA_START_COLL\"); break;\n\tcase NFA_END_COLL:\tSTRCPY(code, \"NFA_END_COLL\"); break;\n\tcase NFA_START_NEG_COLL: STRCPY(code, \"NFA_START_NEG_COLL\"); break;\n\tcase NFA_END_NEG_COLL:\tSTRCPY(code, \"NFA_END_NEG_COLL\"); break;\n\tcase NFA_RANGE:\t\tSTRCPY(code, \"NFA_RANGE\"); break;\n\tcase NFA_RANGE_MIN:\tSTRCPY(code, \"NFA_RANGE_MIN\"); break;\n\tcase NFA_RANGE_MAX:\tSTRCPY(code, \"NFA_RANGE_MAX\"); break;\n\n\tcase NFA_CLASS_ALNUM:\tSTRCPY(code, \"NFA_CLASS_ALNUM\"); break;\n\tcase NFA_CLASS_ALPHA:\tSTRCPY(code, \"NFA_CLASS_ALPHA\"); break;\n\tcase NFA_CLASS_BLANK:\tSTRCPY(code, \"NFA_CLASS_BLANK\"); break;\n\tcase NFA_CLASS_CNTRL:\tSTRCPY(code, \"NFA_CLASS_CNTRL\"); break;\n\tcase NFA_CLASS_DIGIT:\tSTRCPY(code, \"NFA_CLASS_DIGIT\"); break;\n\tcase NFA_CLASS_GRAPH:\tSTRCPY(code, \"NFA_CLASS_GRAPH\"); break;\n\tcase NFA_CLASS_LOWER:\tSTRCPY(code, \"NFA_CLASS_LOWER\"); break;\n\tcase NFA_CLASS_PRINT:\tSTRCPY(code, \"NFA_CLASS_PRINT\"); break;\n\tcase NFA_CLASS_PUNCT:\tSTRCPY(code, \"NFA_CLASS_PUNCT\"); break;\n\tcase NFA_CLASS_SPACE:\tSTRCPY(code, \"NFA_CLASS_SPACE\"); break;\n\tcase NFA_CLASS_UPPER:\tSTRCPY(code, \"NFA_CLASS_UPPER\"); break;\n\tcase NFA_CLASS_XDIGIT:\tSTRCPY(code, \"NFA_CLASS_XDIGIT\"); break;\n\tcase NFA_CLASS_TAB:\tSTRCPY(code, \"NFA_CLASS_TAB\"); break;\n\tcase NFA_CLASS_RETURN:\tSTRCPY(code, \"NFA_CLASS_RETURN\"); break;\n\tcase NFA_CLASS_BACKSPACE:   STRCPY(code, \"NFA_CLASS_BACKSPACE\"); break;\n\tcase NFA_CLASS_ESCAPE:\tSTRCPY(code, \"NFA_CLASS_ESCAPE\"); break;\n\tcase NFA_CLASS_IDENT:\tSTRCPY(code, \"NFA_CLASS_IDENT\"); break;\n\tcase NFA_CLASS_KEYWORD:\tSTRCPY(code, \"NFA_CLASS_KEYWORD\"); break;\n\tcase NFA_CLASS_FNAME:\tSTRCPY(code, \"NFA_CLASS_FNAME\"); break;\n\n\tcase NFA_ANY:\tSTRCPY(code, \"NFA_ANY\"); break;\n\tcase NFA_IDENT:\tSTRCPY(code, \"NFA_IDENT\"); break;\n\tcase NFA_SIDENT:STRCPY(code, \"NFA_SIDENT\"); break;\n\tcase NFA_KWORD:\tSTRCPY(code, \"NFA_KWORD\"); break;\n\tcase NFA_SKWORD:STRCPY(code, \"NFA_SKWORD\"); break;\n\tcase NFA_FNAME:\tSTRCPY(code, \"NFA_FNAME\"); break;\n\tcase NFA_SFNAME:STRCPY(code, \"NFA_SFNAME\"); break;\n\tcase NFA_PRINT:\tSTRCPY(code, \"NFA_PRINT\"); break;\n\tcase NFA_SPRINT:STRCPY(code, \"NFA_SPRINT\"); break;\n\tcase NFA_WHITE:\tSTRCPY(code, \"NFA_WHITE\"); break;\n\tcase NFA_NWHITE:STRCPY(code, \"NFA_NWHITE\"); break;\n\tcase NFA_DIGIT:\tSTRCPY(code, \"NFA_DIGIT\"); break;\n\tcase NFA_NDIGIT:STRCPY(code, \"NFA_NDIGIT\"); break;\n\tcase NFA_HEX:\tSTRCPY(code, \"NFA_HEX\"); break;\n\tcase NFA_NHEX:\tSTRCPY(code, \"NFA_NHEX\"); break;\n\tcase NFA_OCTAL:\tSTRCPY(code, \"NFA_OCTAL\"); break;\n\tcase NFA_NOCTAL:STRCPY(code, \"NFA_NOCTAL\"); break;\n\tcase NFA_WORD:\tSTRCPY(code, \"NFA_WORD\"); break;\n\tcase NFA_NWORD:\tSTRCPY(code, \"NFA_NWORD\"); break;\n\tcase NFA_HEAD:\tSTRCPY(code, \"NFA_HEAD\"); break;\n\tcase NFA_NHEAD:\tSTRCPY(code, \"NFA_NHEAD\"); break;\n\tcase NFA_ALPHA:\tSTRCPY(code, \"NFA_ALPHA\"); break;\n\tcase NFA_NALPHA:STRCPY(code, \"NFA_NALPHA\"); break;\n\tcase NFA_LOWER:\tSTRCPY(code, \"NFA_LOWER\"); break;\n\tcase NFA_NLOWER:STRCPY(code, \"NFA_NLOWER\"); break;\n\tcase NFA_UPPER:\tSTRCPY(code, \"NFA_UPPER\"); break;\n\tcase NFA_NUPPER:STRCPY(code, \"NFA_NUPPER\"); break;\n\tcase NFA_LOWER_IC:  STRCPY(code, \"NFA_LOWER_IC\"); break;\n\tcase NFA_NLOWER_IC: STRCPY(code, \"NFA_NLOWER_IC\"); break;\n\tcase NFA_UPPER_IC:  STRCPY(code, \"NFA_UPPER_IC\"); break;\n\tcase NFA_NUPPER_IC: STRCPY(code, \"NFA_NUPPER_IC\"); break;\n\n\tdefault:\n\t    STRCPY(code, \"CHAR(x)\");\n\t    code[5] = c;\n    }\n\n    if (addnl == TRUE)\n\tSTRCAT(code, \" + NEWLINE \");\n\n}\n\n#ifdef ENABLE_LOG\nstatic FILE *log_fd;\nstatic char_u e_log_open_failed[] = N_(\"Could not open temporary log file for writing, displaying on stderr... \");\n\n/*\n * Print the postfix notation of the current regexp.\n */\n    static void\nnfa_postfix_dump(char_u *expr, int retval)\n{\n    int *p;\n    FILE *f;\n\n    f = fopen(NFA_REGEXP_DUMP_LOG, \"a\");\n    if (f != NULL)\n    {\n\tfprintf(f, \"\\n-------------------------\\n\");\n\tif (retval == FAIL)\n\t    fprintf(f, \">>> NFA engine failed... \\n\");\n\telse if (retval == OK)\n\t    fprintf(f, \">>> NFA engine succeeded !\\n\");\n\tfprintf(f, \"Regexp: \\\"%s\\\"\\nPostfix notation (char): \\\"\", expr);\n\tfor (p = post_start; *p && p < post_ptr; p++)\n\t{\n\t    nfa_set_code(*p);\n\t    fprintf(f, \"%s, \", code);\n\t}\n\tfprintf(f, \"\\\"\\nPostfix notation (int): \");\n\tfor (p = post_start; *p && p < post_ptr; p++)\n\t\tfprintf(f, \"%d \", *p);\n\tfprintf(f, \"\\n\\n\");\n\tfclose(f);\n    }\n}\n\n/*\n * Print the NFA starting with a root node \"state\".\n */\n    static void\nnfa_print_state(FILE *debugf, nfa_state_T *state)\n{\n    garray_T indent;\n\n    ga_init2(&indent, 1, 64);\n    ga_append(&indent, '\\0');\n    nfa_print_state2(debugf, state, &indent);\n    ga_clear(&indent);\n}\n\n    static void\nnfa_print_state2(FILE *debugf, nfa_state_T *state, garray_T *indent)\n{\n    char_u  *p;\n\n    if (state == NULL)\n\treturn;\n\n    fprintf(debugf, \"(%2d)\", abs(state->id));\n\n    // Output indent\n    p = (char_u *)indent->ga_data;\n    if (indent->ga_len >= 3)\n    {\n\tint\tlast = indent->ga_len - 3;\n\tchar_u\tsave[2];\n\n\tSTRNCPY(save, &p[last], 2);\n\tSTRNCPY(&p[last], \"+-\", 2);\n\tfprintf(debugf, \" %s\", p);\n\tSTRNCPY(&p[last], save, 2);\n    }\n    else\n\tfprintf(debugf, \" %s\", p);\n\n    nfa_set_code(state->c);\n    fprintf(debugf, \"%s (%d) (id=%d) val=%d\\n\",\n\t\t code,\n\t\t state->c,\n\t\t abs(state->id),\n\t\t state->val);\n    if (state->id < 0)\n\treturn;\n\n    state->id = abs(state->id) * -1;\n\n    // grow indent for state->out\n    indent->ga_len -= 1;\n    if (state->out1)\n\tga_concat(indent, (char_u *)\"| \");\n    else\n\tga_concat(indent, (char_u *)\"  \");\n    ga_append(indent, '\\0');\n\n    nfa_print_state2(debugf, state->out, indent);\n\n    // replace last part of indent for state->out1\n    indent->ga_len -= 3;\n    ga_concat(indent, (char_u *)\"  \");\n    ga_append(indent, '\\0');\n\n    nfa_print_state2(debugf, state->out1, indent);\n\n    // shrink indent\n    indent->ga_len -= 3;\n    ga_append(indent, '\\0');\n}\n\n/*\n * Print the NFA state machine.\n */\n    static void\nnfa_dump(nfa_regprog_T *prog)\n{\n    FILE *debugf = fopen(NFA_REGEXP_DUMP_LOG, \"a\");\n\n    if (debugf != NULL)\n    {\n\tnfa_print_state(debugf, prog->start);\n\n\tif (prog->reganch)\n\t    fprintf(debugf, \"reganch: %d\\n\", prog->reganch);\n\tif (prog->regstart != NUL)\n\t    fprintf(debugf, \"regstart: %c (decimal: %d)\\n\",\n\t\t\t\t\t      prog->regstart, prog->regstart);\n\tif (prog->match_text != NULL)\n\t    fprintf(debugf, \"match_text: \\\"%s\\\"\\n\", prog->match_text);\n\n\tfclose(debugf);\n    }\n}\n#endif\t    // ENABLE_LOG\n#endif\t    // DEBUG\n\n/*\n * Parse r.e. @expr and convert it into postfix form.\n * Return the postfix string on success, NULL otherwise.\n */\n    static int *\nre2post(void)\n{\n    if (nfa_reg(REG_NOPAREN) == FAIL)\n\treturn NULL;\n    EMIT(NFA_MOPEN);\n    return post_start;\n}\n\n// NB. Some of the code below is inspired by Russ's.\n\n/*\n * Represents an NFA state plus zero or one or two arrows exiting.\n * if c == MATCH, no arrows out; matching state.\n * If c == SPLIT, unlabeled arrows to out and out1 (if != NULL).\n * If c < 256, labeled arrow with character c to out.\n */\n\nstatic nfa_state_T\t*state_ptr; // points to nfa_prog->state\n\n/*\n * Allocate and initialize nfa_state_T.\n */\n    static nfa_state_T *\nalloc_state(int c, nfa_state_T *out, nfa_state_T *out1)\n{\n    nfa_state_T *s;\n\n    if (istate >= nstate)\n\treturn NULL;\n\n    s = &state_ptr[istate++];\n\n    s->c    = c;\n    s->out  = out;\n    s->out1 = out1;\n    s->val  = 0;\n\n    s->id   = istate;\n    s->lastlist[0] = 0;\n    s->lastlist[1] = 0;\n\n    return s;\n}\n\n/*\n * A partially built NFA without the matching state filled in.\n * Frag_T.start points at the start state.\n * Frag_T.out is a list of places that need to be set to the\n * next state for this fragment.\n */\n\n// Since the out pointers in the list are always\n// uninitialized, we use the pointers themselves\n// as storage for the Ptrlists.\ntypedef union Ptrlist Ptrlist;\nunion Ptrlist\n{\n    Ptrlist\t*next;\n    nfa_state_T\t*s;\n};\n\nstruct Frag\n{\n    nfa_state_T *start;\n    Ptrlist\t*out;\n};\ntypedef struct Frag Frag_T;\n\n/*\n * Initialize a Frag_T struct and return it.\n */\n    static Frag_T\nfrag(nfa_state_T *start, Ptrlist *out)\n{\n    Frag_T n;\n\n    n.start = start;\n    n.out = out;\n    return n;\n}\n\n/*\n * Create singleton list containing just outp.\n */\n    static Ptrlist *\nlist1(\n    nfa_state_T\t**outp)\n{\n    Ptrlist *l;\n\n    l = (Ptrlist *)outp;\n    l->next = NULL;\n    return l;\n}\n\n/*\n * Patch the list of states at out to point to start.\n */\n    static void\npatch(Ptrlist *l, nfa_state_T *s)\n{\n    Ptrlist *next;\n\n    for (; l; l = next)\n    {\n\tnext = l->next;\n\tl->s = s;\n    }\n}\n\n\n/*\n * Join the two lists l1 and l2, returning the combination.\n */\n    static Ptrlist *\nappend(Ptrlist *l1, Ptrlist *l2)\n{\n    Ptrlist *oldl1;\n\n    oldl1 = l1;\n    while (l1->next)\n\tl1 = l1->next;\n    l1->next = l2;\n    return oldl1;\n}\n\n/*\n * Stack used for transforming postfix form into NFA.\n */\nstatic Frag_T empty;\n\n    static void\nst_error(int *postfix UNUSED, int *end UNUSED, int *p UNUSED)\n{\n#ifdef NFA_REGEXP_ERROR_LOG\n    FILE *df;\n    int *p2;\n\n    df = fopen(NFA_REGEXP_ERROR_LOG, \"a\");\n    if (df)\n    {\n\tfprintf(df, \"Error popping the stack!\\n\");\n# ifdef DEBUG\n\tfprintf(df, \"Current regexp is \\\"%s\\\"\\n\", nfa_regengine.expr);\n# endif\n\tfprintf(df, \"Postfix form is: \");\n# ifdef DEBUG\n\tfor (p2 = postfix; p2 < end; p2++)\n\t{\n\t    nfa_set_code(*p2);\n\t    fprintf(df, \"%s, \", code);\n\t}\n\tnfa_set_code(*p);\n\tfprintf(df, \"\\nCurrent position is: \");\n\tfor (p2 = postfix; p2 <= p; p2 ++)\n\t{\n\t    nfa_set_code(*p2);\n\t    fprintf(df, \"%s, \", code);\n\t}\n# else\n\tfor (p2 = postfix; p2 < end; p2++)\n\t    fprintf(df, \"%d, \", *p2);\n\tfprintf(df, \"\\nCurrent position is: \");\n\tfor (p2 = postfix; p2 <= p; p2 ++)\n\t    fprintf(df, \"%d, \", *p2);\n# endif\n\tfprintf(df, \"\\n--------------------------\\n\");\n\tfclose(df);\n    }\n#endif\n    emsg(_(\"E874: (NFA) Could not pop the stack!\"));\n}\n\n/*\n * Push an item onto the stack.\n */\n    static void\nst_push(Frag_T s, Frag_T **p, Frag_T *stack_end)\n{\n    Frag_T *stackp = *p;\n\n    if (stackp >= stack_end)\n\treturn;\n    *stackp = s;\n    *p = *p + 1;\n}\n\n/*\n * Pop an item from the stack.\n */\n    static Frag_T\nst_pop(Frag_T **p, Frag_T *stack)\n{\n    Frag_T *stackp;\n\n    *p = *p - 1;\n    stackp = *p;\n    if (stackp < stack)\n\treturn empty;\n    return **p;\n}\n\n/*\n * Estimate the maximum byte length of anything matching \"state\".\n * When unknown or unlimited return -1.\n */\n    static int\nnfa_max_width(nfa_state_T *startstate, int depth)\n{\n    int\t\t    l, r;\n    nfa_state_T\t    *state = startstate;\n    int\t\t    len = 0;\n\n    // detect looping in a NFA_SPLIT\n    if (depth > 4)\n\treturn -1;\n\n    while (state != NULL)\n    {\n\tswitch (state->c)\n\t{\n\t    case NFA_END_INVISIBLE:\n\t    case NFA_END_INVISIBLE_NEG:\n\t\t// the end, return what we have\n\t\treturn len;\n\n\t    case NFA_SPLIT:\n\t\t// two alternatives, use the maximum\n\t\tl = nfa_max_width(state->out, depth + 1);\n\t\tr = nfa_max_width(state->out1, depth + 1);\n\t\tif (l < 0 || r < 0)\n\t\t    return -1;\n\t\treturn len + (l > r ? l : r);\n\n\t    case NFA_ANY:\n\t    case NFA_START_COLL:\n\t    case NFA_START_NEG_COLL:\n\t\t// matches some character, including composing chars\n\t\tif (enc_utf8)\n\t\t    len += MB_MAXBYTES;\n\t\telse if (has_mbyte)\n\t\t    len += 2;\n\t\telse\n\t\t    ++len;\n\t\tif (state->c != NFA_ANY)\n\t\t{\n\t\t    // skip over the characters\n\t\t    state = state->out1->out;\n\t\t    continue;\n\t\t}\n\t\tbreak;\n\n\t    case NFA_DIGIT:\n\t    case NFA_WHITE:\n\t    case NFA_HEX:\n\t    case NFA_OCTAL:\n\t\t// ascii\n\t\t++len;\n\t\tbreak;\n\n\t    case NFA_IDENT:\n\t    case NFA_SIDENT:\n\t    case NFA_KWORD:\n\t    case NFA_SKWORD:\n\t    case NFA_FNAME:\n\t    case NFA_SFNAME:\n\t    case NFA_PRINT:\n\t    case NFA_SPRINT:\n\t    case NFA_NWHITE:\n\t    case NFA_NDIGIT:\n\t    case NFA_NHEX:\n\t    case NFA_NOCTAL:\n\t    case NFA_WORD:\n\t    case NFA_NWORD:\n\t    case NFA_HEAD:\n\t    case NFA_NHEAD:\n\t    case NFA_ALPHA:\n\t    case NFA_NALPHA:\n\t    case NFA_LOWER:\n\t    case NFA_NLOWER:\n\t    case NFA_UPPER:\n\t    case NFA_NUPPER:\n\t    case NFA_LOWER_IC:\n\t    case NFA_NLOWER_IC:\n\t    case NFA_UPPER_IC:\n\t    case NFA_NUPPER_IC:\n\t    case NFA_ANY_COMPOSING:\n\t\t// possibly non-ascii\n\t\tif (has_mbyte)\n\t\t    len += 3;\n\t\telse\n\t\t    ++len;\n\t\tbreak;\n\n\t    case NFA_START_INVISIBLE:\n\t    case NFA_START_INVISIBLE_NEG:\n\t    case NFA_START_INVISIBLE_BEFORE:\n\t    case NFA_START_INVISIBLE_BEFORE_NEG:\n\t\t// zero-width, out1 points to the END state\n\t\tstate = state->out1->out;\n\t\tcontinue;\n\n\t    case NFA_BACKREF1:\n\t    case NFA_BACKREF2:\n\t    case NFA_BACKREF3:\n\t    case NFA_BACKREF4:\n\t    case NFA_BACKREF5:\n\t    case NFA_BACKREF6:\n\t    case NFA_BACKREF7:\n\t    case NFA_BACKREF8:\n\t    case NFA_BACKREF9:\n#ifdef FEAT_SYN_HL\n\t    case NFA_ZREF1:\n\t    case NFA_ZREF2:\n\t    case NFA_ZREF3:\n\t    case NFA_ZREF4:\n\t    case NFA_ZREF5:\n\t    case NFA_ZREF6:\n\t    case NFA_ZREF7:\n\t    case NFA_ZREF8:\n\t    case NFA_ZREF9:\n#endif\n\t    case NFA_NEWL:\n\t    case NFA_SKIP:\n\t\t// unknown width\n\t\treturn -1;\n\n\t    case NFA_BOL:\n\t    case NFA_EOL:\n\t    case NFA_BOF:\n\t    case NFA_EOF:\n\t    case NFA_BOW:\n\t    case NFA_EOW:\n\t    case NFA_MOPEN:\n\t    case NFA_MOPEN1:\n\t    case NFA_MOPEN2:\n\t    case NFA_MOPEN3:\n\t    case NFA_MOPEN4:\n\t    case NFA_MOPEN5:\n\t    case NFA_MOPEN6:\n\t    case NFA_MOPEN7:\n\t    case NFA_MOPEN8:\n\t    case NFA_MOPEN9:\n#ifdef FEAT_SYN_HL\n\t    case NFA_ZOPEN:\n\t    case NFA_ZOPEN1:\n\t    case NFA_ZOPEN2:\n\t    case NFA_ZOPEN3:\n\t    case NFA_ZOPEN4:\n\t    case NFA_ZOPEN5:\n\t    case NFA_ZOPEN6:\n\t    case NFA_ZOPEN7:\n\t    case NFA_ZOPEN8:\n\t    case NFA_ZOPEN9:\n\t    case NFA_ZCLOSE:\n\t    case NFA_ZCLOSE1:\n\t    case NFA_ZCLOSE2:\n\t    case NFA_ZCLOSE3:\n\t    case NFA_ZCLOSE4:\n\t    case NFA_ZCLOSE5:\n\t    case NFA_ZCLOSE6:\n\t    case NFA_ZCLOSE7:\n\t    case NFA_ZCLOSE8:\n\t    case NFA_ZCLOSE9:\n#endif\n\t    case NFA_MCLOSE:\n\t    case NFA_MCLOSE1:\n\t    case NFA_MCLOSE2:\n\t    case NFA_MCLOSE3:\n\t    case NFA_MCLOSE4:\n\t    case NFA_MCLOSE5:\n\t    case NFA_MCLOSE6:\n\t    case NFA_MCLOSE7:\n\t    case NFA_MCLOSE8:\n\t    case NFA_MCLOSE9:\n\t    case NFA_NOPEN:\n\t    case NFA_NCLOSE:\n\n\t    case NFA_LNUM_GT:\n\t    case NFA_LNUM_LT:\n\t    case NFA_COL_GT:\n\t    case NFA_COL_LT:\n\t    case NFA_VCOL_GT:\n\t    case NFA_VCOL_LT:\n\t    case NFA_MARK_GT:\n\t    case NFA_MARK_LT:\n\t    case NFA_VISUAL:\n\t    case NFA_LNUM:\n\t    case NFA_CURSOR:\n\t    case NFA_COL:\n\t    case NFA_VCOL:\n\t    case NFA_MARK:\n\n\t    case NFA_ZSTART:\n\t    case NFA_ZEND:\n\t    case NFA_OPT_CHARS:\n\t    case NFA_EMPTY:\n\t    case NFA_START_PATTERN:\n\t    case NFA_END_PATTERN:\n\t    case NFA_COMPOSING:\n\t    case NFA_END_COMPOSING:\n\t\t// zero-width\n\t\tbreak;\n\n\t    default:\n\t\tif (state->c < 0)\n\t\t    // don't know what this is\n\t\t    return -1;\n\t\t// normal character\n\t\tlen += MB_CHAR2LEN(state->c);\n\t\tbreak;\n\t}\n\n\t// normal way to continue\n\tstate = state->out;\n    }\n\n    // unrecognized, \"cannot happen\"\n    return -1;\n}\n\n/*\n * Convert a postfix form into its equivalent NFA.\n * Return the NFA start state on success, NULL otherwise.\n */\n    static nfa_state_T *\npost2nfa(int *postfix, int *end, int nfa_calc_size)\n{\n    int\t\t*p;\n    int\t\tmopen;\n    int\t\tmclose;\n    Frag_T\t*stack = NULL;\n    Frag_T\t*stackp = NULL;\n    Frag_T\t*stack_end = NULL;\n    Frag_T\te1;\n    Frag_T\te2;\n    Frag_T\te;\n    nfa_state_T\t*s;\n    nfa_state_T\t*s1;\n    nfa_state_T\t*matchstate;\n    nfa_state_T\t*ret = NULL;\n\n    if (postfix == NULL)\n\treturn NULL;\n\n#define PUSH(s)\t    st_push((s), &stackp, stack_end)\n#define POP()\t    st_pop(&stackp, stack);\t\t\\\n\t\t    if (stackp < stack)\t\t\t\\\n\t\t    {\t\t\t\t\t\\\n\t\t\tst_error(postfix, end, p);\t\\\n\t\t\tvim_free(stack);\t\t\\\n\t\t\treturn NULL;\t\t\t\\\n\t\t    }\n\n    if (nfa_calc_size == FALSE)\n    {\n\t// Allocate space for the stack. Max states on the stack: \"nstate\".\n\tstack = ALLOC_MULT(Frag_T, nstate + 1);\n\tif (stack == NULL)\n\t    return NULL;\n\tstackp = stack;\n\tstack_end = stack + (nstate + 1);\n    }\n\n    for (p = postfix; p < end; ++p)\n    {\n\tswitch (*p)\n\t{\n\tcase NFA_CONCAT:\n\t    // Concatenation.\n\t    // Pay attention: this operator does not exist in the r.e. itself\n\t    // (it is implicit, really).  It is added when r.e. is translated\n\t    // to postfix form in re2post().\n\t    if (nfa_calc_size == TRUE)\n\t    {\n\t\t// nstate += 0;\n\t\tbreak;\n\t    }\n\t    e2 = POP();\n\t    e1 = POP();\n\t    patch(e1.out, e2.start);\n\t    PUSH(frag(e1.start, e2.out));\n\t    break;\n\n\tcase NFA_OR:\n\t    // Alternation\n\t    if (nfa_calc_size == TRUE)\n\t    {\n\t\tnstate++;\n\t\tbreak;\n\t    }\n\t    e2 = POP();\n\t    e1 = POP();\n\t    s = alloc_state(NFA_SPLIT, e1.start, e2.start);\n\t    if (s == NULL)\n\t\tgoto theend;\n\t    PUSH(frag(s, append(e1.out, e2.out)));\n\t    break;\n\n\tcase NFA_STAR:\n\t    // Zero or more, prefer more\n\t    if (nfa_calc_size == TRUE)\n\t    {\n\t\tnstate++;\n\t\tbreak;\n\t    }\n\t    e = POP();\n\t    s = alloc_state(NFA_SPLIT, e.start, NULL);\n\t    if (s == NULL)\n\t\tgoto theend;\n\t    patch(e.out, s);\n\t    PUSH(frag(s, list1(&s->out1)));\n\t    break;\n\n\tcase NFA_STAR_NONGREEDY:\n\t    // Zero or more, prefer zero\n\t    if (nfa_calc_size == TRUE)\n\t    {\n\t\tnstate++;\n\t\tbreak;\n\t    }\n\t    e = POP();\n\t    s = alloc_state(NFA_SPLIT, NULL, e.start);\n\t    if (s == NULL)\n\t\tgoto theend;\n\t    patch(e.out, s);\n\t    PUSH(frag(s, list1(&s->out)));\n\t    break;\n\n\tcase NFA_QUEST:\n\t    // one or zero atoms=> greedy match\n\t    if (nfa_calc_size == TRUE)\n\t    {\n\t\tnstate++;\n\t\tbreak;\n\t    }\n\t    e = POP();\n\t    s = alloc_state(NFA_SPLIT, e.start, NULL);\n\t    if (s == NULL)\n\t\tgoto theend;\n\t    PUSH(frag(s, append(e.out, list1(&s->out1))));\n\t    break;\n\n\tcase NFA_QUEST_NONGREEDY:\n\t    // zero or one atoms => non-greedy match\n\t    if (nfa_calc_size == TRUE)\n\t    {\n\t\tnstate++;\n\t\tbreak;\n\t    }\n\t    e = POP();\n\t    s = alloc_state(NFA_SPLIT, NULL, e.start);\n\t    if (s == NULL)\n\t\tgoto theend;\n\t    PUSH(frag(s, append(e.out, list1(&s->out))));\n\t    break;\n\n\tcase NFA_END_COLL:\n\tcase NFA_END_NEG_COLL:\n\t    // On the stack is the sequence starting with NFA_START_COLL or\n\t    // NFA_START_NEG_COLL and all possible characters. Patch it to\n\t    // add the output to the start.\n\t    if (nfa_calc_size == TRUE)\n\t    {\n\t\tnstate++;\n\t\tbreak;\n\t    }\n\t    e = POP();\n\t    s = alloc_state(NFA_END_COLL, NULL, NULL);\n\t    if (s == NULL)\n\t\tgoto theend;\n\t    patch(e.out, s);\n\t    e.start->out1 = s;\n\t    PUSH(frag(e.start, list1(&s->out)));\n\t    break;\n\n\tcase NFA_RANGE:\n\t    // Before this are two characters, the low and high end of a\n\t    // range.  Turn them into two states with MIN and MAX.\n\t    if (nfa_calc_size == TRUE)\n\t    {\n\t\t// nstate += 0;\n\t\tbreak;\n\t    }\n\t    e2 = POP();\n\t    e1 = POP();\n\t    e2.start->val = e2.start->c;\n\t    e2.start->c = NFA_RANGE_MAX;\n\t    e1.start->val = e1.start->c;\n\t    e1.start->c = NFA_RANGE_MIN;\n\t    patch(e1.out, e2.start);\n\t    PUSH(frag(e1.start, e2.out));\n\t    break;\n\n\tcase NFA_EMPTY:\n\t    // 0-length, used in a repetition with max/min count of 0\n\t    if (nfa_calc_size == TRUE)\n\t    {\n\t\tnstate++;\n\t\tbreak;\n\t    }\n\t    s = alloc_state(NFA_EMPTY, NULL, NULL);\n\t    if (s == NULL)\n\t\tgoto theend;\n\t    PUSH(frag(s, list1(&s->out)));\n\t    break;\n\n\tcase NFA_OPT_CHARS:\n\t  {\n\t    int    n;\n\n\t    // \\%[abc] implemented as:\n\t    //    NFA_SPLIT\n\t    //    +-CHAR(a)\n\t    //    | +-NFA_SPLIT\n\t    //    |   +-CHAR(b)\n\t    //    |   | +-NFA_SPLIT\n\t    //    |   |   +-CHAR(c)\n\t    //    |   |   | +-next\n\t    //    |   |   +- next\n\t    //    |   +- next\n\t    //    +- next\n\t    n = *++p; // get number of characters\n\t    if (nfa_calc_size == TRUE)\n\t    {\n\t\tnstate += n;\n\t\tbreak;\n\t    }\n\t    s = NULL; // avoid compiler warning\n\t    e1.out = NULL; // stores list with out1's\n\t    s1 = NULL; // previous NFA_SPLIT to connect to\n\t    while (n-- > 0)\n\t    {\n\t\te = POP(); // get character\n\t\ts = alloc_state(NFA_SPLIT, e.start, NULL);\n\t\tif (s == NULL)\n\t\t    goto theend;\n\t\tif (e1.out == NULL)\n\t\t    e1 = e;\n\t\tpatch(e.out, s1);\n\t\tappend(e1.out, list1(&s->out1));\n\t\ts1 = s;\n\t    }\n\t    PUSH(frag(s, e1.out));\n\t    break;\n\t  }\n\n\tcase NFA_PREV_ATOM_NO_WIDTH:\n\tcase NFA_PREV_ATOM_NO_WIDTH_NEG:\n\tcase NFA_PREV_ATOM_JUST_BEFORE:\n\tcase NFA_PREV_ATOM_JUST_BEFORE_NEG:\n\tcase NFA_PREV_ATOM_LIKE_PATTERN:\n\t  {\n\t    int before = (*p == NFA_PREV_ATOM_JUST_BEFORE\n\t\t\t\t      || *p == NFA_PREV_ATOM_JUST_BEFORE_NEG);\n\t    int pattern = (*p == NFA_PREV_ATOM_LIKE_PATTERN);\n\t    int start_state;\n\t    int end_state;\n\t    int n = 0;\n\t    nfa_state_T *zend;\n\t    nfa_state_T *skip;\n\n\t    switch (*p)\n\t    {\n\t\tcase NFA_PREV_ATOM_NO_WIDTH:\n\t\t    start_state = NFA_START_INVISIBLE;\n\t\t    end_state = NFA_END_INVISIBLE;\n\t\t    break;\n\t\tcase NFA_PREV_ATOM_NO_WIDTH_NEG:\n\t\t    start_state = NFA_START_INVISIBLE_NEG;\n\t\t    end_state = NFA_END_INVISIBLE_NEG;\n\t\t    break;\n\t\tcase NFA_PREV_ATOM_JUST_BEFORE:\n\t\t    start_state = NFA_START_INVISIBLE_BEFORE;\n\t\t    end_state = NFA_END_INVISIBLE;\n\t\t    break;\n\t\tcase NFA_PREV_ATOM_JUST_BEFORE_NEG:\n\t\t    start_state = NFA_START_INVISIBLE_BEFORE_NEG;\n\t\t    end_state = NFA_END_INVISIBLE_NEG;\n\t\t    break;\n\t\tdefault: // NFA_PREV_ATOM_LIKE_PATTERN:\n\t\t    start_state = NFA_START_PATTERN;\n\t\t    end_state = NFA_END_PATTERN;\n\t\t    break;\n\t    }\n\n\t    if (before)\n\t\tn = *++p; // get the count\n\n\t    // The \\@= operator: match the preceding atom with zero width.\n\t    // The \\@! operator: no match for the preceding atom.\n\t    // The \\@<= operator: match for the preceding atom.\n\t    // The \\@<! operator: no match for the preceding atom.\n\t    // Surrounds the preceding atom with START_INVISIBLE and\n\t    // END_INVISIBLE, similarly to MOPEN.\n\n\t    if (nfa_calc_size == TRUE)\n\t    {\n\t\tnstate += pattern ? 4 : 2;\n\t\tbreak;\n\t    }\n\t    e = POP();\n\t    s1 = alloc_state(end_state, NULL, NULL);\n\t    if (s1 == NULL)\n\t\tgoto theend;\n\n\t    s = alloc_state(start_state, e.start, s1);\n\t    if (s == NULL)\n\t\tgoto theend;\n\t    if (pattern)\n\t    {\n\t\t// NFA_ZEND -> NFA_END_PATTERN -> NFA_SKIP -> what follows.\n\t\tskip = alloc_state(NFA_SKIP, NULL, NULL);\n\t\tif (skip == NULL)\n\t\t    goto theend;\n\t\tzend = alloc_state(NFA_ZEND, s1, NULL);\n\t\tif (zend == NULL)\n\t\t    goto theend;\n\t\ts1->out= skip;\n\t\tpatch(e.out, zend);\n\t\tPUSH(frag(s, list1(&skip->out)));\n\t    }\n\t    else\n\t    {\n\t\tpatch(e.out, s1);\n\t\tPUSH(frag(s, list1(&s1->out)));\n\t\tif (before)\n\t\t{\n\t\t    if (n <= 0)\n\t\t\t// See if we can guess the maximum width, it avoids a\n\t\t\t// lot of pointless tries.\n\t\t\tn = nfa_max_width(e.start, 0);\n\t\t    s->val = n; // store the count\n\t\t}\n\t    }\n\t    break;\n\t  }\n\n\tcase NFA_COMPOSING:\t// char with composing char\n#if 0\n\t    // TODO\n\t    if (regflags & RF_ICOMBINE)\n\t    {\n\t\t// use the base character only\n\t    }\n#endif\n\t    // FALLTHROUGH\n\n\tcase NFA_MOPEN:\t// \\( \\) Submatch\n\tcase NFA_MOPEN1:\n\tcase NFA_MOPEN2:\n\tcase NFA_MOPEN3:\n\tcase NFA_MOPEN4:\n\tcase NFA_MOPEN5:\n\tcase NFA_MOPEN6:\n\tcase NFA_MOPEN7:\n\tcase NFA_MOPEN8:\n\tcase NFA_MOPEN9:\n#ifdef FEAT_SYN_HL\n\tcase NFA_ZOPEN:\t// \\z( \\) Submatch\n\tcase NFA_ZOPEN1:\n\tcase NFA_ZOPEN2:\n\tcase NFA_ZOPEN3:\n\tcase NFA_ZOPEN4:\n\tcase NFA_ZOPEN5:\n\tcase NFA_ZOPEN6:\n\tcase NFA_ZOPEN7:\n\tcase NFA_ZOPEN8:\n\tcase NFA_ZOPEN9:\n#endif\n\tcase NFA_NOPEN:\t// \\%( \\) \"Invisible Submatch\"\n\t    if (nfa_calc_size == TRUE)\n\t    {\n\t\tnstate += 2;\n\t\tbreak;\n\t    }\n\n\t    mopen = *p;\n\t    switch (*p)\n\t    {\n\t\tcase NFA_NOPEN: mclose = NFA_NCLOSE; break;\n#ifdef FEAT_SYN_HL\n\t\tcase NFA_ZOPEN: mclose = NFA_ZCLOSE; break;\n\t\tcase NFA_ZOPEN1: mclose = NFA_ZCLOSE1; break;\n\t\tcase NFA_ZOPEN2: mclose = NFA_ZCLOSE2; break;\n\t\tcase NFA_ZOPEN3: mclose = NFA_ZCLOSE3; break;\n\t\tcase NFA_ZOPEN4: mclose = NFA_ZCLOSE4; break;\n\t\tcase NFA_ZOPEN5: mclose = NFA_ZCLOSE5; break;\n\t\tcase NFA_ZOPEN6: mclose = NFA_ZCLOSE6; break;\n\t\tcase NFA_ZOPEN7: mclose = NFA_ZCLOSE7; break;\n\t\tcase NFA_ZOPEN8: mclose = NFA_ZCLOSE8; break;\n\t\tcase NFA_ZOPEN9: mclose = NFA_ZCLOSE9; break;\n#endif\n\t\tcase NFA_COMPOSING: mclose = NFA_END_COMPOSING; break;\n\t\tdefault:\n\t\t    // NFA_MOPEN, NFA_MOPEN1 .. NFA_MOPEN9\n\t\t    mclose = *p + NSUBEXP;\n\t\t    break;\n\t    }\n\n\t    // Allow \"NFA_MOPEN\" as a valid postfix representation for\n\t    // the empty regexp \"\". In this case, the NFA will be\n\t    // NFA_MOPEN -> NFA_MCLOSE. Note that this also allows\n\t    // empty groups of parenthesis, and empty mbyte chars\n\t    if (stackp == stack)\n\t    {\n\t\ts = alloc_state(mopen, NULL, NULL);\n\t\tif (s == NULL)\n\t\t    goto theend;\n\t\ts1 = alloc_state(mclose, NULL, NULL);\n\t\tif (s1 == NULL)\n\t\t    goto theend;\n\t\tpatch(list1(&s->out), s1);\n\t\tPUSH(frag(s, list1(&s1->out)));\n\t\tbreak;\n\t    }\n\n\t    // At least one node was emitted before NFA_MOPEN, so\n\t    // at least one node will be between NFA_MOPEN and NFA_MCLOSE\n\t    e = POP();\n\t    s = alloc_state(mopen, e.start, NULL);   // `('\n\t    if (s == NULL)\n\t\tgoto theend;\n\n\t    s1 = alloc_state(mclose, NULL, NULL);   // `)'\n\t    if (s1 == NULL)\n\t\tgoto theend;\n\t    patch(e.out, s1);\n\n\t    if (mopen == NFA_COMPOSING)\n\t\t// COMPOSING->out1 = END_COMPOSING\n\t\tpatch(list1(&s->out1), s1);\n\n\t    PUSH(frag(s, list1(&s1->out)));\n\t    break;\n\n\tcase NFA_BACKREF1:\n\tcase NFA_BACKREF2:\n\tcase NFA_BACKREF3:\n\tcase NFA_BACKREF4:\n\tcase NFA_BACKREF5:\n\tcase NFA_BACKREF6:\n\tcase NFA_BACKREF7:\n\tcase NFA_BACKREF8:\n\tcase NFA_BACKREF9:\n#ifdef FEAT_SYN_HL\n\tcase NFA_ZREF1:\n\tcase NFA_ZREF2:\n\tcase NFA_ZREF3:\n\tcase NFA_ZREF4:\n\tcase NFA_ZREF5:\n\tcase NFA_ZREF6:\n\tcase NFA_ZREF7:\n\tcase NFA_ZREF8:\n\tcase NFA_ZREF9:\n#endif\n\t    if (nfa_calc_size == TRUE)\n\t    {\n\t\tnstate += 2;\n\t\tbreak;\n\t    }\n\t    s = alloc_state(*p, NULL, NULL);\n\t    if (s == NULL)\n\t\tgoto theend;\n\t    s1 = alloc_state(NFA_SKIP, NULL, NULL);\n\t    if (s1 == NULL)\n\t\tgoto theend;\n\t    patch(list1(&s->out), s1);\n\t    PUSH(frag(s, list1(&s1->out)));\n\t    break;\n\n\tcase NFA_LNUM:\n\tcase NFA_LNUM_GT:\n\tcase NFA_LNUM_LT:\n\tcase NFA_VCOL:\n\tcase NFA_VCOL_GT:\n\tcase NFA_VCOL_LT:\n\tcase NFA_COL:\n\tcase NFA_COL_GT:\n\tcase NFA_COL_LT:\n\tcase NFA_MARK:\n\tcase NFA_MARK_GT:\n\tcase NFA_MARK_LT:\n\t  {\n\t    int n = *++p; // lnum, col or mark name\n\n\t    if (nfa_calc_size == TRUE)\n\t    {\n\t\tnstate += 1;\n\t\tbreak;\n\t    }\n\t    s = alloc_state(p[-1], NULL, NULL);\n\t    if (s == NULL)\n\t\tgoto theend;\n\t    s->val = n;\n\t    PUSH(frag(s, list1(&s->out)));\n\t    break;\n\t  }\n\n\tcase NFA_ZSTART:\n\tcase NFA_ZEND:\n\tdefault:\n\t    // Operands\n\t    if (nfa_calc_size == TRUE)\n\t    {\n\t\tnstate++;\n\t\tbreak;\n\t    }\n\t    s = alloc_state(*p, NULL, NULL);\n\t    if (s == NULL)\n\t\tgoto theend;\n\t    PUSH(frag(s, list1(&s->out)));\n\t    break;\n\n\t} // switch(*p)\n\n    } // for(p = postfix; *p; ++p)\n\n    if (nfa_calc_size == TRUE)\n    {\n\tnstate++;\n\tgoto theend;\t// Return value when counting size is ignored anyway\n    }\n\n    e = POP();\n    if (stackp != stack)\n    {\n\tvim_free(stack);\n\tEMSG_RET_NULL(_(\"E875: (NFA regexp) (While converting from postfix to NFA), too many states left on stack\"));\n    }\n\n    if (istate >= nstate)\n    {\n\tvim_free(stack);\n\tEMSG_RET_NULL(_(\"E876: (NFA regexp) Not enough space to store the whole NFA \"));\n    }\n\n    matchstate = &state_ptr[istate++]; // the match state\n    matchstate->c = NFA_MATCH;\n    matchstate->out = matchstate->out1 = NULL;\n    matchstate->id = 0;\n\n    patch(e.out, matchstate);\n    ret = e.start;\n\ntheend:\n    vim_free(stack);\n    return ret;\n\n#undef POP1\n#undef PUSH1\n#undef POP2\n#undef PUSH2\n#undef POP\n#undef PUSH\n}\n\n/*\n * After building the NFA program, inspect it to add optimization hints.\n */\n    static void\nnfa_postprocess(nfa_regprog_T *prog)\n{\n    int i;\n    int c;\n\n    for (i = 0; i < prog->nstate; ++i)\n    {\n\tc = prog->state[i].c;\n\tif (c == NFA_START_INVISIBLE\n\t\t|| c == NFA_START_INVISIBLE_NEG\n\t\t|| c == NFA_START_INVISIBLE_BEFORE\n\t\t|| c == NFA_START_INVISIBLE_BEFORE_NEG)\n\t{\n\t    int directly;\n\n\t    // Do it directly when what follows is possibly the end of the\n\t    // match.\n\t    if (match_follows(prog->state[i].out1->out, 0))\n\t\tdirectly = TRUE;\n\t    else\n\t    {\n\t\tint ch_invisible = failure_chance(prog->state[i].out, 0);\n\t\tint ch_follows = failure_chance(prog->state[i].out1->out, 0);\n\n\t\t// Postpone when the invisible match is expensive or has a\n\t\t// lower chance of failing.\n\t\tif (c == NFA_START_INVISIBLE_BEFORE\n\t\t     || c == NFA_START_INVISIBLE_BEFORE_NEG)\n\t\t{\n\t\t    // \"before\" matches are very expensive when\n\t\t    // unbounded, always prefer what follows then,\n\t\t    // unless what follows will always match.\n\t\t    // Otherwise strongly prefer what follows.\n\t\t    if (prog->state[i].val <= 0 && ch_follows > 0)\n\t\t\tdirectly = FALSE;\n\t\t    else\n\t\t\tdirectly = ch_follows * 10 < ch_invisible;\n\t\t}\n\t\telse\n\t\t{\n\t\t    // normal invisible, first do the one with the\n\t\t    // highest failure chance\n\t\t    directly = ch_follows < ch_invisible;\n\t\t}\n\t    }\n\t    if (directly)\n\t\t// switch to the _FIRST state\n\t\t++prog->state[i].c;\n\t}\n    }\n}\n\n/////////////////////////////////////////////////////////////////\n// NFA execution code.\n/////////////////////////////////////////////////////////////////\n\ntypedef struct\n{\n    int\t    in_use; // number of subexpr with useful info\n\n    // When REG_MULTI is TRUE list.multi is used, otherwise list.line.\n    union\n    {\n\tstruct multipos\n\t{\n\t    linenr_T\tstart_lnum;\n\t    linenr_T\tend_lnum;\n\t    colnr_T\tstart_col;\n\t    colnr_T\tend_col;\n\t} multi[NSUBEXP];\n\tstruct linepos\n\t{\n\t    char_u\t*start;\n\t    char_u\t*end;\n\t} line[NSUBEXP];\n    } list;\n} regsub_T;\n\ntypedef struct\n{\n    regsub_T\tnorm; // \\( .. \\) matches\n#ifdef FEAT_SYN_HL\n    regsub_T\tsynt; // \\z( .. \\) matches\n#endif\n} regsubs_T;\n\n// nfa_pim_T stores a Postponed Invisible Match.\ntypedef struct nfa_pim_S nfa_pim_T;\nstruct nfa_pim_S\n{\n    int\t\tresult;\t\t// NFA_PIM_*, see below\n    nfa_state_T\t*state;\t\t// the invisible match start state\n    regsubs_T\tsubs;\t\t// submatch info, only party used\n    union\n    {\n\tlpos_T\tpos;\n\tchar_u\t*ptr;\n    } end;\t\t\t// where the match must end\n};\n\n// Values for done in nfa_pim_T.\n#define NFA_PIM_UNUSED   0\t// pim not used\n#define NFA_PIM_TODO     1\t// pim not done yet\n#define NFA_PIM_MATCH    2\t// pim executed, matches\n#define NFA_PIM_NOMATCH  3\t// pim executed, no match\n\n\n// nfa_thread_T contains execution information of a NFA state\ntypedef struct\n{\n    nfa_state_T\t*state;\n    int\t\tcount;\n    nfa_pim_T\tpim;\t\t// if pim.result != NFA_PIM_UNUSED: postponed\n\t\t\t\t// invisible match\n    regsubs_T\tsubs;\t\t// submatch info, only party used\n} nfa_thread_T;\n\n// nfa_list_T contains the alternative NFA execution states.\ntypedef struct\n{\n    nfa_thread_T    *t;\t\t// allocated array of states\n    int\t\t    n;\t\t// nr of states currently in \"t\"\n    int\t\t    len;\t// max nr of states in \"t\"\n    int\t\t    id;\t\t// ID of the list\n    int\t\t    has_pim;\t// TRUE when any state has a PIM\n} nfa_list_T;\n\n#ifdef ENABLE_LOG\nstatic void log_subexpr(regsub_T *sub);\n\n    static void\nlog_subsexpr(regsubs_T *subs)\n{\n    log_subexpr(&subs->norm);\n# ifdef FEAT_SYN_HL\n    if (rex.nfa_has_zsubexpr)\n\tlog_subexpr(&subs->synt);\n# endif\n}\n\n    static void\nlog_subexpr(regsub_T *sub)\n{\n    int j;\n\n    for (j = 0; j < sub->in_use; j++)\n\tif (REG_MULTI)\n\t    fprintf(log_fd, \"*** group %d, start: c=%d, l=%d, end: c=%d, l=%d\\n\",\n\t\t    j,\n\t\t    sub->list.multi[j].start_col,\n\t\t    (int)sub->list.multi[j].start_lnum,\n\t\t    sub->list.multi[j].end_col,\n\t\t    (int)sub->list.multi[j].end_lnum);\n\telse\n\t{\n\t    char *s = (char *)sub->list.line[j].start;\n\t    char *e = (char *)sub->list.line[j].end;\n\n\t    fprintf(log_fd, \"*** group %d, start: \\\"%s\\\", end: \\\"%s\\\"\\n\",\n\t\t    j,\n\t\t    s == NULL ? \"NULL\" : s,\n\t\t    e == NULL ? \"NULL\" : e);\n\t}\n}\n\n    static char *\npim_info(nfa_pim_T *pim)\n{\n    static char buf[30];\n\n    if (pim == NULL || pim->result == NFA_PIM_UNUSED)\n\tbuf[0] = NUL;\n    else\n    {\n\tsprintf(buf, \" PIM col %d\", REG_MULTI ? (int)pim->end.pos.col\n\t\t: (int)(pim->end.ptr - rex.input));\n    }\n    return buf;\n}\n\n#endif\n\n// Used during execution: whether a match has been found.\nstatic int\t    nfa_match;\n#ifdef FEAT_RELTIME\nstatic proftime_T  *nfa_time_limit;\nstatic int\t   *nfa_timed_out;\nstatic int\t    nfa_time_count;\n#endif\n\nstatic void copy_sub(regsub_T *to, regsub_T *from);\nstatic int pim_equal(nfa_pim_T *one, nfa_pim_T *two);\n\n/*\n * Copy postponed invisible match info from \"from\" to \"to\".\n */\n    static void\ncopy_pim(nfa_pim_T *to, nfa_pim_T *from)\n{\n    to->result = from->result;\n    to->state = from->state;\n    copy_sub(&to->subs.norm, &from->subs.norm);\n#ifdef FEAT_SYN_HL\n    if (rex.nfa_has_zsubexpr)\n\tcopy_sub(&to->subs.synt, &from->subs.synt);\n#endif\n    to->end = from->end;\n}\n\n    static void\nclear_sub(regsub_T *sub)\n{\n    if (REG_MULTI)\n\t// Use 0xff to set lnum to -1\n\tvim_memset(sub->list.multi, 0xff,\n\t\t\t\t  sizeof(struct multipos) * rex.nfa_nsubexpr);\n    else\n\tvim_memset(sub->list.line, 0,\n\t\t\t\t   sizeof(struct linepos) * rex.nfa_nsubexpr);\n    sub->in_use = 0;\n}\n\n/*\n * Copy the submatches from \"from\" to \"to\".\n */\n    static void\ncopy_sub(regsub_T *to, regsub_T *from)\n{\n    to->in_use = from->in_use;\n    if (from->in_use > 0)\n    {\n\t// Copy the match start and end positions.\n\tif (REG_MULTI)\n\t    mch_memmove(&to->list.multi[0],\n\t\t\t&from->list.multi[0],\n\t\t\tsizeof(struct multipos) * from->in_use);\n\telse\n\t    mch_memmove(&to->list.line[0],\n\t\t\t&from->list.line[0],\n\t\t\tsizeof(struct linepos) * from->in_use);\n    }\n}\n\n/*\n * Like copy_sub() but exclude the main match.\n */\n    static void\ncopy_sub_off(regsub_T *to, regsub_T *from)\n{\n    if (to->in_use < from->in_use)\n\tto->in_use = from->in_use;\n    if (from->in_use > 1)\n    {\n\t// Copy the match start and end positions.\n\tif (REG_MULTI)\n\t    mch_memmove(&to->list.multi[1],\n\t\t\t&from->list.multi[1],\n\t\t\tsizeof(struct multipos) * (from->in_use - 1));\n\telse\n\t    mch_memmove(&to->list.line[1],\n\t\t\t&from->list.line[1],\n\t\t\tsizeof(struct linepos) * (from->in_use - 1));\n    }\n}\n\n/*\n * Like copy_sub() but only do the end of the main match if \\ze is present.\n */\n    static void\ncopy_ze_off(regsub_T *to, regsub_T *from)\n{\n    if (rex.nfa_has_zend)\n    {\n\tif (REG_MULTI)\n\t{\n\t    if (from->list.multi[0].end_lnum >= 0)\n\t    {\n\t\tto->list.multi[0].end_lnum = from->list.multi[0].end_lnum;\n\t\tto->list.multi[0].end_col = from->list.multi[0].end_col;\n\t    }\n\t}\n\telse\n\t{\n\t    if (from->list.line[0].end != NULL)\n\t\tto->list.line[0].end = from->list.line[0].end;\n\t}\n    }\n}\n\n/*\n * Return TRUE if \"sub1\" and \"sub2\" have the same start positions.\n * When using back-references also check the end position.\n */\n    static int\nsub_equal(regsub_T *sub1, regsub_T *sub2)\n{\n    int\t\ti;\n    int\t\ttodo;\n    linenr_T\ts1;\n    linenr_T\ts2;\n    char_u\t*sp1;\n    char_u\t*sp2;\n\n    todo = sub1->in_use > sub2->in_use ? sub1->in_use : sub2->in_use;\n    if (REG_MULTI)\n    {\n\tfor (i = 0; i < todo; ++i)\n\t{\n\t    if (i < sub1->in_use)\n\t\ts1 = sub1->list.multi[i].start_lnum;\n\t    else\n\t\ts1 = -1;\n\t    if (i < sub2->in_use)\n\t\ts2 = sub2->list.multi[i].start_lnum;\n\t    else\n\t\ts2 = -1;\n\t    if (s1 != s2)\n\t\treturn FALSE;\n\t    if (s1 != -1 && sub1->list.multi[i].start_col\n\t\t\t\t\t     != sub2->list.multi[i].start_col)\n\t\treturn FALSE;\n\n\t    if (rex.nfa_has_backref)\n\t    {\n\t\tif (i < sub1->in_use)\n\t\t    s1 = sub1->list.multi[i].end_lnum;\n\t\telse\n\t\t    s1 = -1;\n\t\tif (i < sub2->in_use)\n\t\t    s2 = sub2->list.multi[i].end_lnum;\n\t\telse\n\t\t    s2 = -1;\n\t\tif (s1 != s2)\n\t\t    return FALSE;\n\t\tif (s1 != -1 && sub1->list.multi[i].end_col\n\t\t\t\t\t       != sub2->list.multi[i].end_col)\n\t\treturn FALSE;\n\t    }\n\t}\n    }\n    else\n    {\n\tfor (i = 0; i < todo; ++i)\n\t{\n\t    if (i < sub1->in_use)\n\t\tsp1 = sub1->list.line[i].start;\n\t    else\n\t\tsp1 = NULL;\n\t    if (i < sub2->in_use)\n\t\tsp2 = sub2->list.line[i].start;\n\t    else\n\t\tsp2 = NULL;\n\t    if (sp1 != sp2)\n\t\treturn FALSE;\n\t    if (rex.nfa_has_backref)\n\t    {\n\t\tif (i < sub1->in_use)\n\t\t    sp1 = sub1->list.line[i].end;\n\t\telse\n\t\t    sp1 = NULL;\n\t\tif (i < sub2->in_use)\n\t\t    sp2 = sub2->list.line[i].end;\n\t\telse\n\t\t    sp2 = NULL;\n\t\tif (sp1 != sp2)\n\t\t    return FALSE;\n\t    }\n\t}\n    }\n\n    return TRUE;\n}\n\n#ifdef ENABLE_LOG\n    static void\nreport_state(char *action,\n\t     regsub_T *sub,\n\t     nfa_state_T *state,\n\t     int lid,\n\t     nfa_pim_T *pim)\n{\n    int col;\n\n    if (sub->in_use <= 0)\n\tcol = -1;\n    else if (REG_MULTI)\n\tcol = sub->list.multi[0].start_col;\n    else\n\tcol = (int)(sub->list.line[0].start - rex.line);\n    nfa_set_code(state->c);\n    fprintf(log_fd, \"> %s state %d to list %d. char %d: %s (start col %d)%s\\n\",\n\t    action, abs(state->id), lid, state->c, code, col,\n\t    pim_info(pim));\n}\n#endif\n\n/*\n * Return TRUE if the same state is already in list \"l\" with the same\n * positions as \"subs\".\n */\n    static int\nhas_state_with_pos(\n    nfa_list_T\t\t*l,\t// runtime state list\n    nfa_state_T\t\t*state,\t// state to update\n    regsubs_T\t\t*subs,\t// pointers to subexpressions\n    nfa_pim_T\t\t*pim)\t// postponed match or NULL\n{\n    nfa_thread_T\t*thread;\n    int\t\t\ti;\n\n    for (i = 0; i < l->n; ++i)\n    {\n\tthread = &l->t[i];\n\tif (thread->state->id == state->id\n\t\t&& sub_equal(&thread->subs.norm, &subs->norm)\n#ifdef FEAT_SYN_HL\n\t\t&& (!rex.nfa_has_zsubexpr\n\t\t\t\t|| sub_equal(&thread->subs.synt, &subs->synt))\n#endif\n\t\t&& pim_equal(&thread->pim, pim))\n\t    return TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Return TRUE if \"one\" and \"two\" are equal.  That includes when both are not\n * set.\n */\n    static int\npim_equal(nfa_pim_T *one, nfa_pim_T *two)\n{\n    int one_unused = (one == NULL || one->result == NFA_PIM_UNUSED);\n    int two_unused = (two == NULL || two->result == NFA_PIM_UNUSED);\n\n    if (one_unused)\n\t// one is unused: equal when two is also unused\n\treturn two_unused;\n    if (two_unused)\n\t// one is used and two is not: not equal\n\treturn FALSE;\n    // compare the state id\n    if (one->state->id != two->state->id)\n\treturn FALSE;\n    // compare the position\n    if (REG_MULTI)\n\treturn one->end.pos.lnum == two->end.pos.lnum\n\t    && one->end.pos.col == two->end.pos.col;\n    return one->end.ptr == two->end.ptr;\n}\n\n/*\n * Return TRUE if \"state\" leads to a NFA_MATCH without advancing the input.\n */\n    static int\nmatch_follows(nfa_state_T *startstate, int depth)\n{\n    nfa_state_T\t    *state = startstate;\n\n    // avoid too much recursion\n    if (depth > 10)\n\treturn FALSE;\n\n    while (state != NULL)\n    {\n\tswitch (state->c)\n\t{\n\t    case NFA_MATCH:\n\t    case NFA_MCLOSE:\n\t    case NFA_END_INVISIBLE:\n\t    case NFA_END_INVISIBLE_NEG:\n\t    case NFA_END_PATTERN:\n\t\treturn TRUE;\n\n\t    case NFA_SPLIT:\n\t\treturn match_follows(state->out, depth + 1)\n\t\t\t\t     || match_follows(state->out1, depth + 1);\n\n\t    case NFA_START_INVISIBLE:\n\t    case NFA_START_INVISIBLE_FIRST:\n\t    case NFA_START_INVISIBLE_BEFORE:\n\t    case NFA_START_INVISIBLE_BEFORE_FIRST:\n\t    case NFA_START_INVISIBLE_NEG:\n\t    case NFA_START_INVISIBLE_NEG_FIRST:\n\t    case NFA_START_INVISIBLE_BEFORE_NEG:\n\t    case NFA_START_INVISIBLE_BEFORE_NEG_FIRST:\n\t    case NFA_COMPOSING:\n\t\t// skip ahead to next state\n\t\tstate = state->out1->out;\n\t\tcontinue;\n\n\t    case NFA_ANY:\n\t    case NFA_ANY_COMPOSING:\n\t    case NFA_IDENT:\n\t    case NFA_SIDENT:\n\t    case NFA_KWORD:\n\t    case NFA_SKWORD:\n\t    case NFA_FNAME:\n\t    case NFA_SFNAME:\n\t    case NFA_PRINT:\n\t    case NFA_SPRINT:\n\t    case NFA_WHITE:\n\t    case NFA_NWHITE:\n\t    case NFA_DIGIT:\n\t    case NFA_NDIGIT:\n\t    case NFA_HEX:\n\t    case NFA_NHEX:\n\t    case NFA_OCTAL:\n\t    case NFA_NOCTAL:\n\t    case NFA_WORD:\n\t    case NFA_NWORD:\n\t    case NFA_HEAD:\n\t    case NFA_NHEAD:\n\t    case NFA_ALPHA:\n\t    case NFA_NALPHA:\n\t    case NFA_LOWER:\n\t    case NFA_NLOWER:\n\t    case NFA_UPPER:\n\t    case NFA_NUPPER:\n\t    case NFA_LOWER_IC:\n\t    case NFA_NLOWER_IC:\n\t    case NFA_UPPER_IC:\n\t    case NFA_NUPPER_IC:\n\t    case NFA_START_COLL:\n\t    case NFA_START_NEG_COLL:\n\t    case NFA_NEWL:\n\t\t// state will advance input\n\t\treturn FALSE;\n\n\t    default:\n\t\tif (state->c > 0)\n\t\t    // state will advance input\n\t\t    return FALSE;\n\n\t\t// Others: zero-width or possibly zero-width, might still find\n\t\t// a match at the same position, keep looking.\n\t\tbreak;\n\t}\n\tstate = state->out;\n    }\n    return FALSE;\n}\n\n\n/*\n * Return TRUE if \"state\" is already in list \"l\".\n */\n    static int\nstate_in_list(\n    nfa_list_T\t\t*l,\t// runtime state list\n    nfa_state_T\t\t*state,\t// state to update\n    regsubs_T\t\t*subs)\t// pointers to subexpressions\n{\n    if (state->lastlist[nfa_ll_index] == l->id)\n    {\n\tif (!rex.nfa_has_backref || has_state_with_pos(l, state, subs, NULL))\n\t    return TRUE;\n    }\n    return FALSE;\n}\n\n// Offset used for \"off\" by addstate_here().\n#define ADDSTATE_HERE_OFFSET 10\n\n/*\n * Add \"state\" and possibly what follows to state list \".\".\n * Returns \"subs_arg\", possibly copied into temp_subs.\n * Returns NULL when recursiveness is too deep.\n */\n    static regsubs_T *\naddstate(\n    nfa_list_T\t\t*l,\t    // runtime state list\n    nfa_state_T\t\t*state,\t    // state to update\n    regsubs_T\t\t*subs_arg,  // pointers to subexpressions\n    nfa_pim_T\t\t*pim,\t    // postponed look-behind match\n    int\t\t\toff_arg)    // byte offset, when -1 go to next line\n{\n    int\t\t\tsubidx;\n    int\t\t\toff = off_arg;\n    int\t\t\tadd_here = FALSE;\n    int\t\t\tlistindex = 0;\n    int\t\t\tk;\n    int\t\t\tfound = FALSE;\n    nfa_thread_T\t*thread;\n    struct multipos\tsave_multipos;\n    int\t\t\tsave_in_use;\n    char_u\t\t*save_ptr;\n    int\t\t\ti;\n    regsub_T\t\t*sub;\n    regsubs_T\t\t*subs = subs_arg;\n    static regsubs_T\ttemp_subs;\n#ifdef ENABLE_LOG\n    int\t\t\tdid_print = FALSE;\n#endif\n    static int\t\tdepth = 0;\n\n    // This function is called recursively.  When the depth is too much we run\n    // out of stack and crash, limit recursiveness here.\n    if (++depth >= 5000 || subs == NULL)\n    {\n\t--depth;\n\treturn NULL;\n    }\n\n    if (off_arg <= -ADDSTATE_HERE_OFFSET)\n    {\n\tadd_here = TRUE;\n\toff = 0;\n\tlistindex = -(off_arg + ADDSTATE_HERE_OFFSET);\n    }\n\n    switch (state->c)\n    {\n\tcase NFA_NCLOSE:\n\tcase NFA_MCLOSE:\n\tcase NFA_MCLOSE1:\n\tcase NFA_MCLOSE2:\n\tcase NFA_MCLOSE3:\n\tcase NFA_MCLOSE4:\n\tcase NFA_MCLOSE5:\n\tcase NFA_MCLOSE6:\n\tcase NFA_MCLOSE7:\n\tcase NFA_MCLOSE8:\n\tcase NFA_MCLOSE9:\n#ifdef FEAT_SYN_HL\n\tcase NFA_ZCLOSE:\n\tcase NFA_ZCLOSE1:\n\tcase NFA_ZCLOSE2:\n\tcase NFA_ZCLOSE3:\n\tcase NFA_ZCLOSE4:\n\tcase NFA_ZCLOSE5:\n\tcase NFA_ZCLOSE6:\n\tcase NFA_ZCLOSE7:\n\tcase NFA_ZCLOSE8:\n\tcase NFA_ZCLOSE9:\n#endif\n\tcase NFA_MOPEN:\n\tcase NFA_ZEND:\n\tcase NFA_SPLIT:\n\tcase NFA_EMPTY:\n\t    // These nodes are not added themselves but their \"out\" and/or\n\t    // \"out1\" may be added below.\n\t    break;\n\n\tcase NFA_BOL:\n\tcase NFA_BOF:\n\t    // \"^\" won't match past end-of-line, don't bother trying.\n\t    // Except when at the end of the line, or when we are going to the\n\t    // next line for a look-behind match.\n\t    if (rex.input > rex.line\n\t\t    && *rex.input != NUL\n\t\t    && (nfa_endp == NULL\n\t\t\t|| !REG_MULTI\n\t\t\t|| rex.lnum == nfa_endp->se_u.pos.lnum))\n\t\tgoto skip_add;\n\t    // FALLTHROUGH\n\n\tcase NFA_MOPEN1:\n\tcase NFA_MOPEN2:\n\tcase NFA_MOPEN3:\n\tcase NFA_MOPEN4:\n\tcase NFA_MOPEN5:\n\tcase NFA_MOPEN6:\n\tcase NFA_MOPEN7:\n\tcase NFA_MOPEN8:\n\tcase NFA_MOPEN9:\n#ifdef FEAT_SYN_HL\n\tcase NFA_ZOPEN:\n\tcase NFA_ZOPEN1:\n\tcase NFA_ZOPEN2:\n\tcase NFA_ZOPEN3:\n\tcase NFA_ZOPEN4:\n\tcase NFA_ZOPEN5:\n\tcase NFA_ZOPEN6:\n\tcase NFA_ZOPEN7:\n\tcase NFA_ZOPEN8:\n\tcase NFA_ZOPEN9:\n#endif\n\tcase NFA_NOPEN:\n\tcase NFA_ZSTART:\n\t    // These nodes need to be added so that we can bail out when it\n\t    // was added to this list before at the same position to avoid an\n\t    // endless loop for \"\\(\\)*\"\n\n\tdefault:\n\t    if (state->lastlist[nfa_ll_index] == l->id && state->c != NFA_SKIP)\n\t    {\n\t\t// This state is already in the list, don't add it again,\n\t\t// unless it is an MOPEN that is used for a backreference or\n\t\t// when there is a PIM. For NFA_MATCH check the position,\n\t\t// lower position is preferred.\n\t\tif (!rex.nfa_has_backref && pim == NULL && !l->has_pim\n\t\t\t\t\t\t     && state->c != NFA_MATCH)\n\t\t{\n\t\t    // When called from addstate_here() do insert before\n\t\t    // existing states.\n\t\t    if (add_here)\n\t\t    {\n\t\t\tfor (k = 0; k < l->n && k < listindex; ++k)\n\t\t\t    if (l->t[k].state->id == state->id)\n\t\t\t    {\n\t\t\t\tfound = TRUE;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t    }\n\t\t    if (!add_here || found)\n\t\t    {\nskip_add:\n#ifdef ENABLE_LOG\n\t\t\tnfa_set_code(state->c);\n\t\t\tfprintf(log_fd, \"> Not adding state %d to list %d. char %d: %s pim: %s has_pim: %d found: %d\\n\",\n\t\t\t    abs(state->id), l->id, state->c, code,\n\t\t\t    pim == NULL ? \"NULL\" : \"yes\", l->has_pim, found);\n#endif\n\t\t\t--depth;\n\t\t\treturn subs;\n\t\t    }\n\t\t}\n\n\t\t// Do not add the state again when it exists with the same\n\t\t// positions.\n\t\tif (has_state_with_pos(l, state, subs, pim))\n\t\t    goto skip_add;\n\t    }\n\n\t    // When there are backreferences or PIMs the number of states may\n\t    // be (a lot) bigger than anticipated.\n\t    if (l->n == l->len)\n\t    {\n\t\tint\t\tnewlen = l->len * 3 / 2 + 50;\n\t\tsize_t\t\tnewsize = newlen * sizeof(nfa_thread_T);\n\t\tnfa_thread_T\t*newt;\n\n\t\tif ((long)(newsize >> 10) >= p_mmp)\n\t\t{\n\t\t    emsg(_(e_maxmempat));\n\t\t    --depth;\n\t\t    return NULL;\n\t\t}\n\t\tif (subs != &temp_subs)\n\t\t{\n\t\t    // \"subs\" may point into the current array, need to make a\n\t\t    // copy before it becomes invalid.\n\t\t    copy_sub(&temp_subs.norm, &subs->norm);\n#ifdef FEAT_SYN_HL\n\t\t    if (rex.nfa_has_zsubexpr)\n\t\t\tcopy_sub(&temp_subs.synt, &subs->synt);\n#endif\n\t\t    subs = &temp_subs;\n\t\t}\n\n\t\tnewt = vim_realloc(l->t, newsize);\n\t\tif (newt == NULL)\n\t\t{\n\t\t    // out of memory\n\t\t    --depth;\n\t\t    return NULL;\n\t\t}\n\t\tl->t = newt;\n\t\tl->len = newlen;\n\t    }\n\n\t    // add the state to the list\n\t    state->lastlist[nfa_ll_index] = l->id;\n\t    thread = &l->t[l->n++];\n\t    thread->state = state;\n\t    if (pim == NULL)\n\t\tthread->pim.result = NFA_PIM_UNUSED;\n\t    else\n\t    {\n\t\tcopy_pim(&thread->pim, pim);\n\t\tl->has_pim = TRUE;\n\t    }\n\t    copy_sub(&thread->subs.norm, &subs->norm);\n#ifdef FEAT_SYN_HL\n\t    if (rex.nfa_has_zsubexpr)\n\t\tcopy_sub(&thread->subs.synt, &subs->synt);\n#endif\n#ifdef ENABLE_LOG\n\t    report_state(\"Adding\", &thread->subs.norm, state, l->id, pim);\n\t    did_print = TRUE;\n#endif\n    }\n\n#ifdef ENABLE_LOG\n    if (!did_print)\n\treport_state(\"Processing\", &subs->norm, state, l->id, pim);\n#endif\n    switch (state->c)\n    {\n\tcase NFA_MATCH:\n\t    break;\n\n\tcase NFA_SPLIT:\n\t    // order matters here\n\t    subs = addstate(l, state->out, subs, pim, off_arg);\n\t    subs = addstate(l, state->out1, subs, pim, off_arg);\n\t    break;\n\n\tcase NFA_EMPTY:\n\tcase NFA_NOPEN:\n\tcase NFA_NCLOSE:\n\t    subs = addstate(l, state->out, subs, pim, off_arg);\n\t    break;\n\n\tcase NFA_MOPEN:\n\tcase NFA_MOPEN1:\n\tcase NFA_MOPEN2:\n\tcase NFA_MOPEN3:\n\tcase NFA_MOPEN4:\n\tcase NFA_MOPEN5:\n\tcase NFA_MOPEN6:\n\tcase NFA_MOPEN7:\n\tcase NFA_MOPEN8:\n\tcase NFA_MOPEN9:\n#ifdef FEAT_SYN_HL\n\tcase NFA_ZOPEN:\n\tcase NFA_ZOPEN1:\n\tcase NFA_ZOPEN2:\n\tcase NFA_ZOPEN3:\n\tcase NFA_ZOPEN4:\n\tcase NFA_ZOPEN5:\n\tcase NFA_ZOPEN6:\n\tcase NFA_ZOPEN7:\n\tcase NFA_ZOPEN8:\n\tcase NFA_ZOPEN9:\n#endif\n\tcase NFA_ZSTART:\n\t    if (state->c == NFA_ZSTART)\n\t    {\n\t\tsubidx = 0;\n\t\tsub = &subs->norm;\n\t    }\n#ifdef FEAT_SYN_HL\n\t    else if (state->c >= NFA_ZOPEN && state->c <= NFA_ZOPEN9)\n\t    {\n\t\tsubidx = state->c - NFA_ZOPEN;\n\t\tsub = &subs->synt;\n\t    }\n#endif\n\t    else\n\t    {\n\t\tsubidx = state->c - NFA_MOPEN;\n\t\tsub = &subs->norm;\n\t    }\n\n\t    // avoid compiler warnings\n\t    save_ptr = NULL;\n\t    CLEAR_FIELD(save_multipos);\n\n\t    // Set the position (with \"off\" added) in the subexpression.  Save\n\t    // and restore it when it was in use.  Otherwise fill any gap.\n\t    if (REG_MULTI)\n\t    {\n\t\tif (subidx < sub->in_use)\n\t\t{\n\t\t    save_multipos = sub->list.multi[subidx];\n\t\t    save_in_use = -1;\n\t\t}\n\t\telse\n\t\t{\n\t\t    save_in_use = sub->in_use;\n\t\t    for (i = sub->in_use; i < subidx; ++i)\n\t\t    {\n\t\t\tsub->list.multi[i].start_lnum = -1;\n\t\t\tsub->list.multi[i].end_lnum = -1;\n\t\t    }\n\t\t    sub->in_use = subidx + 1;\n\t\t}\n\t\tif (off == -1)\n\t\t{\n\t\t    sub->list.multi[subidx].start_lnum = rex.lnum + 1;\n\t\t    sub->list.multi[subidx].start_col = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t    sub->list.multi[subidx].start_lnum = rex.lnum;\n\t\t    sub->list.multi[subidx].start_col =\n\t\t\t\t\t  (colnr_T)(rex.input - rex.line + off);\n\t\t}\n\t\tsub->list.multi[subidx].end_lnum = -1;\n\t    }\n\t    else\n\t    {\n\t\tif (subidx < sub->in_use)\n\t\t{\n\t\t    save_ptr = sub->list.line[subidx].start;\n\t\t    save_in_use = -1;\n\t\t}\n\t\telse\n\t\t{\n\t\t    save_in_use = sub->in_use;\n\t\t    for (i = sub->in_use; i < subidx; ++i)\n\t\t    {\n\t\t\tsub->list.line[i].start = NULL;\n\t\t\tsub->list.line[i].end = NULL;\n\t\t    }\n\t\t    sub->in_use = subidx + 1;\n\t\t}\n\t\tsub->list.line[subidx].start = rex.input + off;\n\t    }\n\n\t    subs = addstate(l, state->out, subs, pim, off_arg);\n\t    if (subs == NULL)\n\t\tbreak;\n\t    // \"subs\" may have changed, need to set \"sub\" again\n#ifdef FEAT_SYN_HL\n\t    if (state->c >= NFA_ZOPEN && state->c <= NFA_ZOPEN9)\n\t\tsub = &subs->synt;\n\t    else\n#endif\n\t\tsub = &subs->norm;\n\n\t    if (save_in_use == -1)\n\t    {\n\t\tif (REG_MULTI)\n\t\t    sub->list.multi[subidx] = save_multipos;\n\t\telse\n\t\t    sub->list.line[subidx].start = save_ptr;\n\t    }\n\t    else\n\t\tsub->in_use = save_in_use;\n\t    break;\n\n\tcase NFA_MCLOSE:\n\t    if (rex.nfa_has_zend && (REG_MULTI\n\t\t\t? subs->norm.list.multi[0].end_lnum >= 0\n\t\t\t: subs->norm.list.line[0].end != NULL))\n\t    {\n\t\t// Do not overwrite the position set by \\ze.\n\t\tsubs = addstate(l, state->out, subs, pim, off_arg);\n\t\tbreak;\n\t    }\n\t    // FALLTHROUGH\n\tcase NFA_MCLOSE1:\n\tcase NFA_MCLOSE2:\n\tcase NFA_MCLOSE3:\n\tcase NFA_MCLOSE4:\n\tcase NFA_MCLOSE5:\n\tcase NFA_MCLOSE6:\n\tcase NFA_MCLOSE7:\n\tcase NFA_MCLOSE8:\n\tcase NFA_MCLOSE9:\n#ifdef FEAT_SYN_HL\n\tcase NFA_ZCLOSE:\n\tcase NFA_ZCLOSE1:\n\tcase NFA_ZCLOSE2:\n\tcase NFA_ZCLOSE3:\n\tcase NFA_ZCLOSE4:\n\tcase NFA_ZCLOSE5:\n\tcase NFA_ZCLOSE6:\n\tcase NFA_ZCLOSE7:\n\tcase NFA_ZCLOSE8:\n\tcase NFA_ZCLOSE9:\n#endif\n\tcase NFA_ZEND:\n\t    if (state->c == NFA_ZEND)\n\t    {\n\t\tsubidx = 0;\n\t\tsub = &subs->norm;\n\t    }\n#ifdef FEAT_SYN_HL\n\t    else if (state->c >= NFA_ZCLOSE && state->c <= NFA_ZCLOSE9)\n\t    {\n\t\tsubidx = state->c - NFA_ZCLOSE;\n\t\tsub = &subs->synt;\n\t    }\n#endif\n\t    else\n\t    {\n\t\tsubidx = state->c - NFA_MCLOSE;\n\t\tsub = &subs->norm;\n\t    }\n\n\t    // We don't fill in gaps here, there must have been an MOPEN that\n\t    // has done that.\n\t    save_in_use = sub->in_use;\n\t    if (sub->in_use <= subidx)\n\t\tsub->in_use = subidx + 1;\n\t    if (REG_MULTI)\n\t    {\n\t\tsave_multipos = sub->list.multi[subidx];\n\t\tif (off == -1)\n\t\t{\n\t\t    sub->list.multi[subidx].end_lnum = rex.lnum + 1;\n\t\t    sub->list.multi[subidx].end_col = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t    sub->list.multi[subidx].end_lnum = rex.lnum;\n\t\t    sub->list.multi[subidx].end_col =\n\t\t\t\t\t  (colnr_T)(rex.input - rex.line + off);\n\t\t}\n\t\t// avoid compiler warnings\n\t\tsave_ptr = NULL;\n\t    }\n\t    else\n\t    {\n\t\tsave_ptr = sub->list.line[subidx].end;\n\t\tsub->list.line[subidx].end = rex.input + off;\n\t\t// avoid compiler warnings\n\t\tCLEAR_FIELD(save_multipos);\n\t    }\n\n\t    subs = addstate(l, state->out, subs, pim, off_arg);\n\t    if (subs == NULL)\n\t\tbreak;\n\t    // \"subs\" may have changed, need to set \"sub\" again\n#ifdef FEAT_SYN_HL\n\t    if (state->c >= NFA_ZCLOSE && state->c <= NFA_ZCLOSE9)\n\t\tsub = &subs->synt;\n\t    else\n#endif\n\t\tsub = &subs->norm;\n\n\t    if (REG_MULTI)\n\t\tsub->list.multi[subidx] = save_multipos;\n\t    else\n\t\tsub->list.line[subidx].end = save_ptr;\n\t    sub->in_use = save_in_use;\n\t    break;\n    }\n    --depth;\n    return subs;\n}\n\n/*\n * Like addstate(), but the new state(s) are put at position \"*ip\".\n * Used for zero-width matches, next state to use is the added one.\n * This makes sure the order of states to be tried does not change, which\n * matters for alternatives.\n */\n    static regsubs_T *\naddstate_here(\n    nfa_list_T\t\t*l,\t// runtime state list\n    nfa_state_T\t\t*state,\t// state to update\n    regsubs_T\t\t*subs,\t// pointers to subexpressions\n    nfa_pim_T\t\t*pim,   // postponed look-behind match\n    int\t\t\t*ip)\n{\n    int tlen = l->n;\n    int count;\n    int listidx = *ip;\n    regsubs_T *r;\n\n    // First add the state(s) at the end, so that we know how many there are.\n    // Pass the listidx as offset (avoids adding another argument to\n    // addstate().\n    r = addstate(l, state, subs, pim, -listidx - ADDSTATE_HERE_OFFSET);\n    if (r == NULL)\n\treturn NULL;\n\n    // when \"*ip\" was at the end of the list, nothing to do\n    if (listidx + 1 == tlen)\n\treturn r;\n\n    // re-order to put the new state at the current position\n    count = l->n - tlen;\n    if (count == 0)\n\treturn r; // no state got added\n    if (count == 1)\n    {\n\t// overwrite the current state\n\tl->t[listidx] = l->t[l->n - 1];\n    }\n    else if (count > 1)\n    {\n\tif (l->n + count - 1 >= l->len)\n\t{\n\t    // not enough space to move the new states, reallocate the list\n\t    // and move the states to the right position\n\t    int\t\t    newlen = l->len * 3 / 2 + 50;\n\t    size_t\t    newsize = newlen * sizeof(nfa_thread_T);\n\t    nfa_thread_T    *newl;\n\n\t    if ((long)(newsize >> 10) >= p_mmp)\n\t    {\n\t\temsg(_(e_maxmempat));\n\t\treturn NULL;\n\t    }\n\t    newl = alloc(newsize);\n\t    if (newl == NULL)\n\t\treturn NULL;\n\t    l->len = newlen;\n\t    mch_memmove(&(newl[0]),\n\t\t    &(l->t[0]),\n\t\t    sizeof(nfa_thread_T) * listidx);\n\t    mch_memmove(&(newl[listidx]),\n\t\t    &(l->t[l->n - count]),\n\t\t    sizeof(nfa_thread_T) * count);\n\t    mch_memmove(&(newl[listidx + count]),\n\t\t    &(l->t[listidx + 1]),\n\t\t    sizeof(nfa_thread_T) * (l->n - count - listidx - 1));\n\t    vim_free(l->t);\n\t    l->t = newl;\n\t}\n\telse\n\t{\n\t    // make space for new states, then move them from the\n\t    // end to the current position\n\t    mch_memmove(&(l->t[listidx + count]),\n\t\t    &(l->t[listidx + 1]),\n\t\t    sizeof(nfa_thread_T) * (l->n - listidx - 1));\n\t    mch_memmove(&(l->t[listidx]),\n\t\t    &(l->t[l->n - 1]),\n\t\t    sizeof(nfa_thread_T) * count);\n\t}\n    }\n    --l->n;\n    *ip = listidx - 1;\n\n    return r;\n}\n\n/*\n * Check character class \"class\" against current character c.\n */\n    static int\ncheck_char_class(int class, int c)\n{\n    switch (class)\n    {\n\tcase NFA_CLASS_ALNUM:\n\t    if (c >= 1 && c < 128 && isalnum(c))\n\t\treturn OK;\n\t    break;\n\tcase NFA_CLASS_ALPHA:\n\t    if (c >= 1 && c < 128 && isalpha(c))\n\t\treturn OK;\n\t    break;\n\tcase NFA_CLASS_BLANK:\n\t    if (c == ' ' || c == '\\t')\n\t\treturn OK;\n\t    break;\n\tcase NFA_CLASS_CNTRL:\n\t    if (c >= 1 && c <= 127 && iscntrl(c))\n\t\treturn OK;\n\t    break;\n\tcase NFA_CLASS_DIGIT:\n\t    if (VIM_ISDIGIT(c))\n\t\treturn OK;\n\t    break;\n\tcase NFA_CLASS_GRAPH:\n\t    if (c >= 1 && c <= 127 && isgraph(c))\n\t\treturn OK;\n\t    break;\n\tcase NFA_CLASS_LOWER:\n\t    if (MB_ISLOWER(c) && c != 170 && c != 186)\n\t\treturn OK;\n\t    break;\n\tcase NFA_CLASS_PRINT:\n\t    if (vim_isprintc(c))\n\t\treturn OK;\n\t    break;\n\tcase NFA_CLASS_PUNCT:\n\t    if (c >= 1 && c < 128 && ispunct(c))\n\t\treturn OK;\n\t    break;\n\tcase NFA_CLASS_SPACE:\n\t    if ((c >= 9 && c <= 13) || (c == ' '))\n\t\treturn OK;\n\t    break;\n\tcase NFA_CLASS_UPPER:\n\t    if (MB_ISUPPER(c))\n\t\treturn OK;\n\t    break;\n\tcase NFA_CLASS_XDIGIT:\n\t    if (vim_isxdigit(c))\n\t\treturn OK;\n\t    break;\n\tcase NFA_CLASS_TAB:\n\t    if (c == '\\t')\n\t\treturn OK;\n\t    break;\n\tcase NFA_CLASS_RETURN:\n\t    if (c == '\\r')\n\t\treturn OK;\n\t    break;\n\tcase NFA_CLASS_BACKSPACE:\n\t    if (c == '\\b')\n\t\treturn OK;\n\t    break;\n\tcase NFA_CLASS_ESCAPE:\n\t    if (c == '\\033')\n\t\treturn OK;\n\t    break;\n\tcase NFA_CLASS_IDENT:\n\t    if (vim_isIDc(c))\n\t\treturn OK;\n\t    break;\n\tcase NFA_CLASS_KEYWORD:\n\t    if (reg_iswordc(c))\n\t\treturn OK;\n\t    break;\n\tcase NFA_CLASS_FNAME:\n\t    if (vim_isfilec(c))\n\t\treturn OK;\n\t    break;\n\n\tdefault:\n\t    // should not be here :P\n\t    siemsg(_(e_ill_char_class), class);\n\t    return FAIL;\n    }\n    return FAIL;\n}\n\n/*\n * Check for a match with subexpression \"subidx\".\n * Return TRUE if it matches.\n */\n    static int\nmatch_backref(\n    regsub_T\t*sub,\t    // pointers to subexpressions\n    int\t\tsubidx,\n    int\t\t*bytelen)   // out: length of match in bytes\n{\n    int\t\tlen;\n\n    if (sub->in_use <= subidx)\n    {\nretempty:\n\t// backref was not set, match an empty string\n\t*bytelen = 0;\n\treturn TRUE;\n    }\n\n    if (REG_MULTI)\n    {\n\tif (sub->list.multi[subidx].start_lnum < 0\n\t\t\t\t       || sub->list.multi[subidx].end_lnum < 0)\n\t    goto retempty;\n\tif (sub->list.multi[subidx].start_lnum == rex.lnum\n\t\t\t       && sub->list.multi[subidx].end_lnum == rex.lnum)\n\t{\n\t    len = sub->list.multi[subidx].end_col\n\t\t\t\t\t  - sub->list.multi[subidx].start_col;\n\t    if (cstrncmp(rex.line + sub->list.multi[subidx].start_col,\n\t\t\t\t\t\t\t rex.input, &len) == 0)\n\t    {\n\t\t*bytelen = len;\n\t\treturn TRUE;\n\t    }\n\t}\n\telse\n\t{\n\t    if (match_with_backref(\n\t\t\tsub->list.multi[subidx].start_lnum,\n\t\t\tsub->list.multi[subidx].start_col,\n\t\t\tsub->list.multi[subidx].end_lnum,\n\t\t\tsub->list.multi[subidx].end_col,\n\t\t\tbytelen) == RA_MATCH)\n\t\treturn TRUE;\n\t}\n    }\n    else\n    {\n\tif (sub->list.line[subidx].start == NULL\n\t\t\t\t\t|| sub->list.line[subidx].end == NULL)\n\t    goto retempty;\n\tlen = (int)(sub->list.line[subidx].end - sub->list.line[subidx].start);\n\tif (cstrncmp(sub->list.line[subidx].start, rex.input, &len) == 0)\n\t{\n\t    *bytelen = len;\n\t    return TRUE;\n\t}\n    }\n    return FALSE;\n}\n\n#ifdef FEAT_SYN_HL\n\n/*\n * Check for a match with \\z subexpression \"subidx\".\n * Return TRUE if it matches.\n */\n    static int\nmatch_zref(\n    int\t\tsubidx,\n    int\t\t*bytelen)   // out: length of match in bytes\n{\n    int\t\tlen;\n\n    cleanup_zsubexpr();\n    if (re_extmatch_in == NULL || re_extmatch_in->matches[subidx] == NULL)\n    {\n\t// backref was not set, match an empty string\n\t*bytelen = 0;\n\treturn TRUE;\n    }\n\n    len = (int)STRLEN(re_extmatch_in->matches[subidx]);\n    if (cstrncmp(re_extmatch_in->matches[subidx], rex.input, &len) == 0)\n    {\n\t*bytelen = len;\n\treturn TRUE;\n    }\n    return FALSE;\n}\n#endif\n\n/*\n * Save list IDs for all NFA states of \"prog\" into \"list\".\n * Also reset the IDs to zero.\n * Only used for the recursive value lastlist[1].\n */\n    static void\nnfa_save_listids(nfa_regprog_T *prog, int *list)\n{\n    int\t\t    i;\n    nfa_state_T\t    *p;\n\n    // Order in the list is reverse, it's a bit faster that way.\n    p = &prog->state[0];\n    for (i = prog->nstate; --i >= 0; )\n    {\n\tlist[i] = p->lastlist[1];\n\tp->lastlist[1] = 0;\n\t++p;\n    }\n}\n\n/*\n * Restore list IDs from \"list\" to all NFA states.\n */\n    static void\nnfa_restore_listids(nfa_regprog_T *prog, int *list)\n{\n    int\t\t    i;\n    nfa_state_T\t    *p;\n\n    p = &prog->state[0];\n    for (i = prog->nstate; --i >= 0; )\n    {\n\tp->lastlist[1] = list[i];\n\t++p;\n    }\n}\n\n    static int\nnfa_re_num_cmp(long_u val, int op, long_u pos)\n{\n    if (op == 1) return pos > val;\n    if (op == 2) return pos < val;\n    return val == pos;\n}\n\nstatic int nfa_regmatch(nfa_regprog_T *prog, nfa_state_T *start, regsubs_T *submatch, regsubs_T *m);\n\n/*\n * Recursively call nfa_regmatch()\n * \"pim\" is NULL or contains info about a Postponed Invisible Match (start\n * position).\n */\n    static int\nrecursive_regmatch(\n    nfa_state_T\t    *state,\n    nfa_pim_T\t    *pim,\n    nfa_regprog_T   *prog,\n    regsubs_T\t    *submatch,\n    regsubs_T\t    *m,\n    int\t\t    **listids,\n    int\t\t    *listids_len)\n{\n    int\t\tsave_reginput_col = (int)(rex.input - rex.line);\n    int\t\tsave_reglnum = rex.lnum;\n    int\t\tsave_nfa_match = nfa_match;\n    int\t\tsave_nfa_listid = rex.nfa_listid;\n    save_se_T   *save_nfa_endp = nfa_endp;\n    save_se_T   endpos;\n    save_se_T   *endposp = NULL;\n    int\t\tresult;\n    int\t\tneed_restore = FALSE;\n\n    if (pim != NULL)\n    {\n\t// start at the position where the postponed match was\n\tif (REG_MULTI)\n\t    rex.input = rex.line + pim->end.pos.col;\n\telse\n\t    rex.input = pim->end.ptr;\n    }\n\n    if (state->c == NFA_START_INVISIBLE_BEFORE\n\t    || state->c == NFA_START_INVISIBLE_BEFORE_FIRST\n\t    || state->c == NFA_START_INVISIBLE_BEFORE_NEG\n\t    || state->c == NFA_START_INVISIBLE_BEFORE_NEG_FIRST)\n    {\n\t// The recursive match must end at the current position. When \"pim\" is\n\t// not NULL it specifies the current position.\n\tendposp = &endpos;\n\tif (REG_MULTI)\n\t{\n\t    if (pim == NULL)\n\t    {\n\t\tendpos.se_u.pos.col = (int)(rex.input - rex.line);\n\t\tendpos.se_u.pos.lnum = rex.lnum;\n\t    }\n\t    else\n\t\tendpos.se_u.pos = pim->end.pos;\n\t}\n\telse\n\t{\n\t    if (pim == NULL)\n\t\tendpos.se_u.ptr = rex.input;\n\t    else\n\t\tendpos.se_u.ptr = pim->end.ptr;\n\t}\n\n\t// Go back the specified number of bytes, or as far as the\n\t// start of the previous line, to try matching \"\\@<=\" or\n\t// not matching \"\\@<!\". This is very inefficient, limit the number of\n\t// bytes if possible.\n\tif (state->val <= 0)\n\t{\n\t    if (REG_MULTI)\n\t    {\n\t\trex.line = reg_getline(--rex.lnum);\n\t\tif (rex.line == NULL)\n\t\t    // can't go before the first line\n\t\t    rex.line = reg_getline(++rex.lnum);\n\t    }\n\t    rex.input = rex.line;\n\t}\n\telse\n\t{\n\t    if (REG_MULTI && (int)(rex.input - rex.line) < state->val)\n\t    {\n\t\t// Not enough bytes in this line, go to end of\n\t\t// previous line.\n\t\trex.line = reg_getline(--rex.lnum);\n\t\tif (rex.line == NULL)\n\t\t{\n\t\t    // can't go before the first line\n\t\t    rex.line = reg_getline(++rex.lnum);\n\t\t    rex.input = rex.line;\n\t\t}\n\t\telse\n\t\t    rex.input = rex.line + STRLEN(rex.line);\n\t    }\n\t    if ((int)(rex.input - rex.line) >= state->val)\n\t    {\n\t\trex.input -= state->val;\n\t\tif (has_mbyte)\n\t\t    rex.input -= mb_head_off(rex.line, rex.input);\n\t    }\n\t    else\n\t\trex.input = rex.line;\n\t}\n    }\n\n#ifdef ENABLE_LOG\n    if (log_fd != stderr)\n\tfclose(log_fd);\n    log_fd = NULL;\n#endif\n    // Have to clear the lastlist field of the NFA nodes, so that\n    // nfa_regmatch() and addstate() can run properly after recursion.\n    if (nfa_ll_index == 1)\n    {\n\t// Already calling nfa_regmatch() recursively.  Save the lastlist[1]\n\t// values and clear them.\n\tif (*listids == NULL || *listids_len < prog->nstate)\n\t{\n\t    vim_free(*listids);\n\t    *listids = ALLOC_MULT(int, prog->nstate);\n\t    if (*listids == NULL)\n\t    {\n\t\temsg(_(\"E878: (NFA) Could not allocate memory for branch traversal!\"));\n\t\treturn 0;\n\t    }\n\t    *listids_len = prog->nstate;\n\t}\n\tnfa_save_listids(prog, *listids);\n\tneed_restore = TRUE;\n\t// any value of rex.nfa_listid will do\n    }\n    else\n    {\n\t// First recursive nfa_regmatch() call, switch to the second lastlist\n\t// entry.  Make sure rex.nfa_listid is different from a previous\n\t// recursive call, because some states may still have this ID.\n\t++nfa_ll_index;\n\tif (rex.nfa_listid <= rex.nfa_alt_listid)\n\t    rex.nfa_listid = rex.nfa_alt_listid;\n    }\n\n    // Call nfa_regmatch() to check if the current concat matches at this\n    // position. The concat ends with the node NFA_END_INVISIBLE\n    nfa_endp = endposp;\n    result = nfa_regmatch(prog, state->out, submatch, m);\n\n    if (need_restore)\n\tnfa_restore_listids(prog, *listids);\n    else\n    {\n\t--nfa_ll_index;\n\trex.nfa_alt_listid = rex.nfa_listid;\n    }\n\n    // restore position in input text\n    rex.lnum = save_reglnum;\n    if (REG_MULTI)\n\trex.line = reg_getline(rex.lnum);\n    rex.input = rex.line + save_reginput_col;\n    if (result != NFA_TOO_EXPENSIVE)\n    {\n\tnfa_match = save_nfa_match;\n\trex.nfa_listid = save_nfa_listid;\n    }\n    nfa_endp = save_nfa_endp;\n\n#ifdef ENABLE_LOG\n    log_fd = fopen(NFA_REGEXP_RUN_LOG, \"a\");\n    if (log_fd != NULL)\n    {\n\tfprintf(log_fd, \"****************************\\n\");\n\tfprintf(log_fd, \"FINISHED RUNNING nfa_regmatch() recursively\\n\");\n\tfprintf(log_fd, \"MATCH = %s\\n\", result == TRUE ? \"OK\" : \"FALSE\");\n\tfprintf(log_fd, \"****************************\\n\");\n    }\n    else\n    {\n\temsg(_(e_log_open_failed));\n\tlog_fd = stderr;\n    }\n#endif\n\n    return result;\n}\n\n/*\n * Estimate the chance of a match with \"state\" failing.\n * empty match: 0\n * NFA_ANY: 1\n * specific character: 99\n */\n    static int\nfailure_chance(nfa_state_T *state, int depth)\n{\n    int c = state->c;\n    int l, r;\n\n    // detect looping\n    if (depth > 4)\n\treturn 1;\n\n    switch (c)\n    {\n\tcase NFA_SPLIT:\n\t    if (state->out->c == NFA_SPLIT || state->out1->c == NFA_SPLIT)\n\t\t// avoid recursive stuff\n\t\treturn 1;\n\t    // two alternatives, use the lowest failure chance\n\t    l = failure_chance(state->out, depth + 1);\n\t    r = failure_chance(state->out1, depth + 1);\n\t    return l < r ? l : r;\n\n\tcase NFA_ANY:\n\t    // matches anything, unlikely to fail\n\t    return 1;\n\n\tcase NFA_MATCH:\n\tcase NFA_MCLOSE:\n\tcase NFA_ANY_COMPOSING:\n\t    // empty match works always\n\t    return 0;\n\n\tcase NFA_START_INVISIBLE:\n\tcase NFA_START_INVISIBLE_FIRST:\n\tcase NFA_START_INVISIBLE_NEG:\n\tcase NFA_START_INVISIBLE_NEG_FIRST:\n\tcase NFA_START_INVISIBLE_BEFORE:\n\tcase NFA_START_INVISIBLE_BEFORE_FIRST:\n\tcase NFA_START_INVISIBLE_BEFORE_NEG:\n\tcase NFA_START_INVISIBLE_BEFORE_NEG_FIRST:\n\tcase NFA_START_PATTERN:\n\t    // recursive regmatch is expensive, use low failure chance\n\t    return 5;\n\n\tcase NFA_BOL:\n\tcase NFA_EOL:\n\tcase NFA_BOF:\n\tcase NFA_EOF:\n\tcase NFA_NEWL:\n\t    return 99;\n\n\tcase NFA_BOW:\n\tcase NFA_EOW:\n\t    return 90;\n\n\tcase NFA_MOPEN:\n\tcase NFA_MOPEN1:\n\tcase NFA_MOPEN2:\n\tcase NFA_MOPEN3:\n\tcase NFA_MOPEN4:\n\tcase NFA_MOPEN5:\n\tcase NFA_MOPEN6:\n\tcase NFA_MOPEN7:\n\tcase NFA_MOPEN8:\n\tcase NFA_MOPEN9:\n#ifdef FEAT_SYN_HL\n\tcase NFA_ZOPEN:\n\tcase NFA_ZOPEN1:\n\tcase NFA_ZOPEN2:\n\tcase NFA_ZOPEN3:\n\tcase NFA_ZOPEN4:\n\tcase NFA_ZOPEN5:\n\tcase NFA_ZOPEN6:\n\tcase NFA_ZOPEN7:\n\tcase NFA_ZOPEN8:\n\tcase NFA_ZOPEN9:\n\tcase NFA_ZCLOSE:\n\tcase NFA_ZCLOSE1:\n\tcase NFA_ZCLOSE2:\n\tcase NFA_ZCLOSE3:\n\tcase NFA_ZCLOSE4:\n\tcase NFA_ZCLOSE5:\n\tcase NFA_ZCLOSE6:\n\tcase NFA_ZCLOSE7:\n\tcase NFA_ZCLOSE8:\n\tcase NFA_ZCLOSE9:\n#endif\n\tcase NFA_NOPEN:\n\tcase NFA_MCLOSE1:\n\tcase NFA_MCLOSE2:\n\tcase NFA_MCLOSE3:\n\tcase NFA_MCLOSE4:\n\tcase NFA_MCLOSE5:\n\tcase NFA_MCLOSE6:\n\tcase NFA_MCLOSE7:\n\tcase NFA_MCLOSE8:\n\tcase NFA_MCLOSE9:\n\tcase NFA_NCLOSE:\n\t    return failure_chance(state->out, depth + 1);\n\n\tcase NFA_BACKREF1:\n\tcase NFA_BACKREF2:\n\tcase NFA_BACKREF3:\n\tcase NFA_BACKREF4:\n\tcase NFA_BACKREF5:\n\tcase NFA_BACKREF6:\n\tcase NFA_BACKREF7:\n\tcase NFA_BACKREF8:\n\tcase NFA_BACKREF9:\n#ifdef FEAT_SYN_HL\n\tcase NFA_ZREF1:\n\tcase NFA_ZREF2:\n\tcase NFA_ZREF3:\n\tcase NFA_ZREF4:\n\tcase NFA_ZREF5:\n\tcase NFA_ZREF6:\n\tcase NFA_ZREF7:\n\tcase NFA_ZREF8:\n\tcase NFA_ZREF9:\n#endif\n\t    // backreferences don't match in many places\n\t    return 94;\n\n\tcase NFA_LNUM_GT:\n\tcase NFA_LNUM_LT:\n\tcase NFA_COL_GT:\n\tcase NFA_COL_LT:\n\tcase NFA_VCOL_GT:\n\tcase NFA_VCOL_LT:\n\tcase NFA_MARK_GT:\n\tcase NFA_MARK_LT:\n\tcase NFA_VISUAL:\n\t    // before/after positions don't match very often\n\t    return 85;\n\n\tcase NFA_LNUM:\n\t    return 90;\n\n\tcase NFA_CURSOR:\n\tcase NFA_COL:\n\tcase NFA_VCOL:\n\tcase NFA_MARK:\n\t    // specific positions rarely match\n\t    return 98;\n\n\tcase NFA_COMPOSING:\n\t    return 95;\n\n\tdefault:\n\t    if (c > 0)\n\t\t// character match fails often\n\t\treturn 95;\n    }\n\n    // something else, includes character classes\n    return 50;\n}\n\n/*\n * Skip until the char \"c\" we know a match must start with.\n */\n    static int\nskip_to_start(int c, colnr_T *colp)\n{\n    char_u *s;\n\n    // Used often, do some work to avoid call overhead.\n    if (!rex.reg_ic && !has_mbyte)\n\ts = vim_strbyte(rex.line + *colp, c);\n    else\n\ts = cstrchr(rex.line + *colp, c);\n    if (s == NULL)\n\treturn FAIL;\n    *colp = (int)(s - rex.line);\n    return OK;\n}\n\n/*\n * Check for a match with match_text.\n * Called after skip_to_start() has found regstart.\n * Returns zero for no match, 1 for a match.\n */\n    static long\nfind_match_text(colnr_T startcol, int regstart, char_u *match_text)\n{\n    colnr_T col = startcol;\n    int\t    c1, c2;\n    int\t    len1, len2;\n    int\t    match;\n\n    for (;;)\n    {\n\tmatch = TRUE;\n\tlen2 = MB_CHAR2LEN(regstart); // skip regstart\n\tfor (len1 = 0; match_text[len1] != NUL; len1 += MB_CHAR2LEN(c1))\n\t{\n\t    c1 = PTR2CHAR(match_text + len1);\n\t    c2 = PTR2CHAR(rex.line + col + len2);\n\t    if (c1 != c2 && (!rex.reg_ic || MB_CASEFOLD(c1) != MB_CASEFOLD(c2)))\n\t    {\n\t\tmatch = FALSE;\n\t\tbreak;\n\t    }\n\t    len2 += enc_utf8 ? utf_ptr2len(rex.line + col + len2)\n\t\t\t\t\t\t\t     : MB_CHAR2LEN(c2);\n\t}\n\tif (match\n\t\t// check that no composing char follows\n\t\t&& !(enc_utf8\n\t\t\t  && utf_iscomposing(PTR2CHAR(rex.line + col + len2))))\n\t{\n\t    cleanup_subexpr();\n\t    if (REG_MULTI)\n\t    {\n\t\trex.reg_startpos[0].lnum = rex.lnum;\n\t\trex.reg_startpos[0].col = col;\n\t\trex.reg_endpos[0].lnum = rex.lnum;\n\t\trex.reg_endpos[0].col = col + len2;\n\t    }\n\t    else\n\t    {\n\t\trex.reg_startp[0] = rex.line + col;\n\t\trex.reg_endp[0] = rex.line + col + len2;\n\t    }\n\t    return 1L;\n\t}\n\n\t// Try finding regstart after the current match.\n\tcol += MB_CHAR2LEN(regstart); // skip regstart\n\tif (skip_to_start(regstart, &col) == FAIL)\n\t    break;\n    }\n    return 0L;\n}\n\n#ifdef FEAT_RELTIME\n    static int\nnfa_did_time_out()\n{\n    if (nfa_time_limit != NULL && profile_passed_limit(nfa_time_limit))\n    {\n\tif (nfa_timed_out != NULL)\n\t    *nfa_timed_out = TRUE;\n\treturn TRUE;\n    }\n    return FALSE;\n}\n#endif\n\n/*\n * Main matching routine.\n *\n * Run NFA to determine whether it matches rex.input.\n *\n * When \"nfa_endp\" is not NULL it is a required end-of-match position.\n *\n * Return TRUE if there is a match, FALSE if there is no match,\n * NFA_TOO_EXPENSIVE if we end up with too many states.\n * When there is a match \"submatch\" contains the positions.\n *\n * Note: Caller must ensure that: start != NULL.\n */\n    static int\nnfa_regmatch(\n    nfa_regprog_T\t*prog,\n    nfa_state_T\t\t*start,\n    regsubs_T\t\t*submatch,\n    regsubs_T\t\t*m)\n{\n    int\t\tresult = FALSE;\n    size_t\tsize = 0;\n    int\t\tflag = 0;\n    int\t\tgo_to_nextline = FALSE;\n    nfa_thread_T *t;\n    nfa_list_T\tlist[2];\n    int\t\tlistidx;\n    nfa_list_T\t*thislist;\n    nfa_list_T\t*nextlist;\n    int\t\t*listids = NULL;\n    int\t\tlistids_len = 0;\n    nfa_state_T *add_state;\n    int\t\tadd_here;\n    int\t\tadd_count;\n    int\t\tadd_off = 0;\n    int\t\ttoplevel = start->c == NFA_MOPEN;\n    regsubs_T\t*r;\n#ifdef NFA_REGEXP_DEBUG_LOG\n    FILE\t*debug;\n#endif\n\n    // Some patterns may take a long time to match, especially when using\n    // recursive_regmatch(). Allow interrupting them with CTRL-C.\n    fast_breakcheck();\n    if (got_int)\n\treturn FALSE;\n#ifdef FEAT_RELTIME\n    if (nfa_did_time_out())\n\treturn FALSE;\n#endif\n\n#ifdef NFA_REGEXP_DEBUG_LOG\n    debug = fopen(NFA_REGEXP_DEBUG_LOG, \"a\");\n    if (debug == NULL)\n    {\n\tsemsg(\"(NFA) COULD NOT OPEN %s!\", NFA_REGEXP_DEBUG_LOG);\n\treturn FALSE;\n    }\n#endif\n    nfa_match = FALSE;\n\n    // Allocate memory for the lists of nodes.\n    size = (prog->nstate + 1) * sizeof(nfa_thread_T);\n\n    list[0].t = alloc(size);\n    list[0].len = prog->nstate + 1;\n    list[1].t = alloc(size);\n    list[1].len = prog->nstate + 1;\n    if (list[0].t == NULL || list[1].t == NULL)\n\tgoto theend;\n\n#ifdef ENABLE_LOG\n    log_fd = fopen(NFA_REGEXP_RUN_LOG, \"a\");\n    if (log_fd != NULL)\n    {\n\tfprintf(log_fd, \"**********************************\\n\");\n\tnfa_set_code(start->c);\n\tfprintf(log_fd, \" RUNNING nfa_regmatch() starting with state %d, code %s\\n\",\n\tabs(start->id), code);\n\tfprintf(log_fd, \"**********************************\\n\");\n    }\n    else\n    {\n\temsg(_(e_log_open_failed));\n\tlog_fd = stderr;\n    }\n#endif\n\n    thislist = &list[0];\n    thislist->n = 0;\n    thislist->has_pim = FALSE;\n    nextlist = &list[1];\n    nextlist->n = 0;\n    nextlist->has_pim = FALSE;\n#ifdef ENABLE_LOG\n    fprintf(log_fd, \"(---) STARTSTATE first\\n\");\n#endif\n    thislist->id = rex.nfa_listid + 1;\n\n    // Inline optimized code for addstate(thislist, start, m, 0) if we know\n    // it's the first MOPEN.\n    if (toplevel)\n    {\n\tif (REG_MULTI)\n\t{\n\t    m->norm.list.multi[0].start_lnum = rex.lnum;\n\t    m->norm.list.multi[0].start_col = (colnr_T)(rex.input - rex.line);\n\t}\n\telse\n\t    m->norm.list.line[0].start = rex.input;\n\tm->norm.in_use = 1;\n\tr = addstate(thislist, start->out, m, NULL, 0);\n    }\n    else\n\tr = addstate(thislist, start, m, NULL, 0);\n    if (r == NULL)\n    {\n\tnfa_match = NFA_TOO_EXPENSIVE;\n\tgoto theend;\n    }\n\n#define\tADD_STATE_IF_MATCH(state)\t\t\t\\\n    if (result) {\t\t\t\t\t\\\n\tadd_state = state->out;\t\t\t\t\\\n\tadd_off = clen;\t\t\t\t\t\\\n    }\n\n    /*\n     * Run for each character.\n     */\n    for (;;)\n    {\n\tint\tcurc;\n\tint\tclen;\n\n\tif (has_mbyte)\n\t{\n\t    curc = (*mb_ptr2char)(rex.input);\n\t    clen = (*mb_ptr2len)(rex.input);\n\t}\n\telse\n\t{\n\t    curc = *rex.input;\n\t    clen = 1;\n\t}\n\tif (curc == NUL)\n\t{\n\t    clen = 0;\n\t    go_to_nextline = FALSE;\n\t}\n\n\t// swap lists\n\tthislist = &list[flag];\n\tnextlist = &list[flag ^= 1];\n\tnextlist->n = 0;\t    // clear nextlist\n\tnextlist->has_pim = FALSE;\n\t++rex.nfa_listid;\n\tif (prog->re_engine == AUTOMATIC_ENGINE\n\t\t&& (rex.nfa_listid >= NFA_MAX_STATES\n# ifdef FEAT_EVAL\n\t\t    || nfa_fail_for_testing\n# endif\n\t\t    ))\n\t{\n\t    // too many states, retry with old engine\n\t    nfa_match = NFA_TOO_EXPENSIVE;\n\t    goto theend;\n\t}\n\n\tthislist->id = rex.nfa_listid;\n\tnextlist->id = rex.nfa_listid + 1;\n\n#ifdef ENABLE_LOG\n\tfprintf(log_fd, \"------------------------------------------\\n\");\n\tfprintf(log_fd, \">>> Reginput is \\\"%s\\\"\\n\", rex.input);\n\tfprintf(log_fd, \">>> Advanced one character... Current char is %c (code %d) \\n\", curc, (int)curc);\n\tfprintf(log_fd, \">>> Thislist has %d states available: \", thislist->n);\n\t{\n\t    int i;\n\n\t    for (i = 0; i < thislist->n; i++)\n\t\tfprintf(log_fd, \"%d  \", abs(thislist->t[i].state->id));\n\t}\n\tfprintf(log_fd, \"\\n\");\n#endif\n\n#ifdef NFA_REGEXP_DEBUG_LOG\n\tfprintf(debug, \"\\n-------------------\\n\");\n#endif\n\t/*\n\t * If the state lists are empty we can stop.\n\t */\n\tif (thislist->n == 0)\n\t    break;\n\n\t// compute nextlist\n\tfor (listidx = 0; listidx < thislist->n; ++listidx)\n\t{\n\t    // If the list gets very long there probably is something wrong.\n\t    // At least allow interrupting with CTRL-C.\n\t    fast_breakcheck();\n\t    if (got_int)\n\t\tbreak;\n#ifdef FEAT_RELTIME\n\t    if (nfa_time_limit != NULL && ++nfa_time_count == 20)\n\t    {\n\t\tnfa_time_count = 0;\n\t\tif (nfa_did_time_out())\n\t\t    break;\n\t    }\n#endif\n\t    t = &thislist->t[listidx];\n\n#ifdef NFA_REGEXP_DEBUG_LOG\n\t    nfa_set_code(t->state->c);\n\t    fprintf(debug, \"%s, \", code);\n#endif\n#ifdef ENABLE_LOG\n\t    {\n\t\tint col;\n\n\t\tif (t->subs.norm.in_use <= 0)\n\t\t    col = -1;\n\t\telse if (REG_MULTI)\n\t\t    col = t->subs.norm.list.multi[0].start_col;\n\t\telse\n\t\t    col = (int)(t->subs.norm.list.line[0].start - rex.line);\n\t\tnfa_set_code(t->state->c);\n\t\tfprintf(log_fd, \"(%d) char %d %s (start col %d)%s... \\n\",\n\t\t\tabs(t->state->id), (int)t->state->c, code, col,\n\t\t\tpim_info(&t->pim));\n\t    }\n#endif\n\n\t    /*\n\t     * Handle the possible codes of the current state.\n\t     * The most important is NFA_MATCH.\n\t     */\n\t    add_state = NULL;\n\t    add_here = FALSE;\n\t    add_count = 0;\n\t    switch (t->state->c)\n\t    {\n\t    case NFA_MATCH:\n\t      {\n\t\t// If the match is not at the start of the line, ends before a\n\t\t// composing characters and rex.reg_icombine is not set, that\n\t\t// is not really a match.\n\t\tif (enc_utf8 && !rex.reg_icombine\n\t\t\t     && rex.input != rex.line && utf_iscomposing(curc))\n\t\t    break;\n\n\t\tnfa_match = TRUE;\n\t\tcopy_sub(&submatch->norm, &t->subs.norm);\n#ifdef FEAT_SYN_HL\n\t\tif (rex.nfa_has_zsubexpr)\n\t\t    copy_sub(&submatch->synt, &t->subs.synt);\n#endif\n#ifdef ENABLE_LOG\n\t\tlog_subsexpr(&t->subs);\n#endif\n\t\t// Found the left-most longest match, do not look at any other\n\t\t// states at this position.  When the list of states is going\n\t\t// to be empty quit without advancing, so that \"rex.input\" is\n\t\t// correct.\n\t\tif (nextlist->n == 0)\n\t\t    clen = 0;\n\t\tgoto nextchar;\n\t      }\n\n\t    case NFA_END_INVISIBLE:\n\t    case NFA_END_INVISIBLE_NEG:\n\t    case NFA_END_PATTERN:\n\t\t/*\n\t\t * This is only encountered after a NFA_START_INVISIBLE or\n\t\t * NFA_START_INVISIBLE_BEFORE node.\n\t\t * They surround a zero-width group, used with \"\\@=\", \"\\&\",\n\t\t * \"\\@!\", \"\\@<=\" and \"\\@<!\".\n\t\t * If we got here, it means that the current \"invisible\" group\n\t\t * finished successfully, so return control to the parent\n\t\t * nfa_regmatch().  For a look-behind match only when it ends\n\t\t * in the position in \"nfa_endp\".\n\t\t * Submatches are stored in *m, and used in the parent call.\n\t\t */\n#ifdef ENABLE_LOG\n\t\tif (nfa_endp != NULL)\n\t\t{\n\t\t    if (REG_MULTI)\n\t\t\tfprintf(log_fd, \"Current lnum: %d, endp lnum: %d; current col: %d, endp col: %d\\n\",\n\t\t\t\t(int)rex.lnum,\n\t\t\t\t(int)nfa_endp->se_u.pos.lnum,\n\t\t\t\t(int)(rex.input - rex.line),\n\t\t\t\tnfa_endp->se_u.pos.col);\n\t\t    else\n\t\t\tfprintf(log_fd, \"Current col: %d, endp col: %d\\n\",\n\t\t\t\t(int)(rex.input - rex.line),\n\t\t\t\t(int)(nfa_endp->se_u.ptr - rex.input));\n\t\t}\n#endif\n\t\t// If \"nfa_endp\" is set it's only a match if it ends at\n\t\t// \"nfa_endp\"\n\t\tif (nfa_endp != NULL && (REG_MULTI\n\t\t\t? (rex.lnum != nfa_endp->se_u.pos.lnum\n\t\t\t    || (int)(rex.input - rex.line)\n\t\t\t\t\t\t!= nfa_endp->se_u.pos.col)\n\t\t\t: rex.input != nfa_endp->se_u.ptr))\n\t\t    break;\n\n\t\t// do not set submatches for \\@!\n\t\tif (t->state->c != NFA_END_INVISIBLE_NEG)\n\t\t{\n\t\t    copy_sub(&m->norm, &t->subs.norm);\n#ifdef FEAT_SYN_HL\n\t\t    if (rex.nfa_has_zsubexpr)\n\t\t\tcopy_sub(&m->synt, &t->subs.synt);\n#endif\n\t\t}\n#ifdef ENABLE_LOG\n\t\tfprintf(log_fd, \"Match found:\\n\");\n\t\tlog_subsexpr(m);\n#endif\n\t\tnfa_match = TRUE;\n\t\t// See comment above at \"goto nextchar\".\n\t\tif (nextlist->n == 0)\n\t\t    clen = 0;\n\t\tgoto nextchar;\n\n\t    case NFA_START_INVISIBLE:\n\t    case NFA_START_INVISIBLE_FIRST:\n\t    case NFA_START_INVISIBLE_NEG:\n\t    case NFA_START_INVISIBLE_NEG_FIRST:\n\t    case NFA_START_INVISIBLE_BEFORE:\n\t    case NFA_START_INVISIBLE_BEFORE_FIRST:\n\t    case NFA_START_INVISIBLE_BEFORE_NEG:\n\t    case NFA_START_INVISIBLE_BEFORE_NEG_FIRST:\n\t\t{\n#ifdef ENABLE_LOG\n\t\t    fprintf(log_fd, \"Failure chance invisible: %d, what follows: %d\\n\",\n\t\t\t    failure_chance(t->state->out, 0),\n\t\t\t    failure_chance(t->state->out1->out, 0));\n#endif\n\t\t    // Do it directly if there already is a PIM or when\n\t\t    // nfa_postprocess() detected it will work better.\n\t\t    if (t->pim.result != NFA_PIM_UNUSED\n\t\t\t || t->state->c == NFA_START_INVISIBLE_FIRST\n\t\t\t || t->state->c == NFA_START_INVISIBLE_NEG_FIRST\n\t\t\t || t->state->c == NFA_START_INVISIBLE_BEFORE_FIRST\n\t\t\t || t->state->c == NFA_START_INVISIBLE_BEFORE_NEG_FIRST)\n\t\t    {\n\t\t\tint in_use = m->norm.in_use;\n\n\t\t\t// Copy submatch info for the recursive call, opposite\n\t\t\t// of what happens on success below.\n\t\t\tcopy_sub_off(&m->norm, &t->subs.norm);\n#ifdef FEAT_SYN_HL\n\t\t\tif (rex.nfa_has_zsubexpr)\n\t\t\t    copy_sub_off(&m->synt, &t->subs.synt);\n#endif\n\n\t\t\t/*\n\t\t\t * First try matching the invisible match, then what\n\t\t\t * follows.\n\t\t\t */\n\t\t\tresult = recursive_regmatch(t->state, NULL, prog,\n\t\t\t\t\t  submatch, m, &listids, &listids_len);\n\t\t\tif (result == NFA_TOO_EXPENSIVE)\n\t\t\t{\n\t\t\t    nfa_match = result;\n\t\t\t    goto theend;\n\t\t\t}\n\n\t\t\t// for \\@! and \\@<! it is a match when the result is\n\t\t\t// FALSE\n\t\t\tif (result != (t->state->c == NFA_START_INVISIBLE_NEG\n\t\t\t       || t->state->c == NFA_START_INVISIBLE_NEG_FIRST\n\t\t\t       || t->state->c\n\t\t\t\t\t   == NFA_START_INVISIBLE_BEFORE_NEG\n\t\t\t       || t->state->c\n\t\t\t\t     == NFA_START_INVISIBLE_BEFORE_NEG_FIRST))\n\t\t\t{\n\t\t\t    // Copy submatch info from the recursive call\n\t\t\t    copy_sub_off(&t->subs.norm, &m->norm);\n#ifdef FEAT_SYN_HL\n\t\t\t    if (rex.nfa_has_zsubexpr)\n\t\t\t\tcopy_sub_off(&t->subs.synt, &m->synt);\n#endif\n\t\t\t    // If the pattern has \\ze and it matched in the\n\t\t\t    // sub pattern, use it.\n\t\t\t    copy_ze_off(&t->subs.norm, &m->norm);\n\n\t\t\t    // t->state->out1 is the corresponding\n\t\t\t    // END_INVISIBLE node; Add its out to the current\n\t\t\t    // list (zero-width match).\n\t\t\t    add_here = TRUE;\n\t\t\t    add_state = t->state->out1->out;\n\t\t\t}\n\t\t\tm->norm.in_use = in_use;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tnfa_pim_T pim;\n\n\t\t\t/*\n\t\t\t * First try matching what follows.  Only if a match\n\t\t\t * is found verify the invisible match matches.  Add a\n\t\t\t * nfa_pim_T to the following states, it contains info\n\t\t\t * about the invisible match.\n\t\t\t */\n\t\t\tpim.state = t->state;\n\t\t\tpim.result = NFA_PIM_TODO;\n\t\t\tpim.subs.norm.in_use = 0;\n#ifdef FEAT_SYN_HL\n\t\t\tpim.subs.synt.in_use = 0;\n#endif\n\t\t\tif (REG_MULTI)\n\t\t\t{\n\t\t\t    pim.end.pos.col = (int)(rex.input - rex.line);\n\t\t\t    pim.end.pos.lnum = rex.lnum;\n\t\t\t}\n\t\t\telse\n\t\t\t    pim.end.ptr = rex.input;\n\n\t\t\t// t->state->out1 is the corresponding END_INVISIBLE\n\t\t\t// node; Add its out to the current list (zero-width\n\t\t\t// match).\n\t\t\tif (addstate_here(thislist, t->state->out1->out,\n\t\t\t\t\t     &t->subs, &pim, &listidx) == NULL)\n\t\t\t{\n\t\t\t    nfa_match = NFA_TOO_EXPENSIVE;\n\t\t\t    goto theend;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    case NFA_START_PATTERN:\n\t      {\n\t\tnfa_state_T *skip = NULL;\n#ifdef ENABLE_LOG\n\t\tint\t    skip_lid = 0;\n#endif\n\n\t\t// There is no point in trying to match the pattern if the\n\t\t// output state is not going to be added to the list.\n\t\tif (state_in_list(nextlist, t->state->out1->out, &t->subs))\n\t\t{\n\t\t    skip = t->state->out1->out;\n#ifdef ENABLE_LOG\n\t\t    skip_lid = nextlist->id;\n#endif\n\t\t}\n\t\telse if (state_in_list(nextlist,\n\t\t\t\t\t  t->state->out1->out->out, &t->subs))\n\t\t{\n\t\t    skip = t->state->out1->out->out;\n#ifdef ENABLE_LOG\n\t\t    skip_lid = nextlist->id;\n#endif\n\t\t}\n\t\telse if (state_in_list(thislist,\n\t\t\t\t\t  t->state->out1->out->out, &t->subs))\n\t\t{\n\t\t    skip = t->state->out1->out->out;\n#ifdef ENABLE_LOG\n\t\t    skip_lid = thislist->id;\n#endif\n\t\t}\n\t\tif (skip != NULL)\n\t\t{\n#ifdef ENABLE_LOG\n\t\t    nfa_set_code(skip->c);\n\t\t    fprintf(log_fd, \"> Not trying to match pattern, output state %d is already in list %d. char %d: %s\\n\",\n\t\t\t    abs(skip->id), skip_lid, skip->c, code);\n#endif\n\t\t    break;\n\t\t}\n\t\t// Copy submatch info to the recursive call, opposite of what\n\t\t// happens afterwards.\n\t\tcopy_sub_off(&m->norm, &t->subs.norm);\n#ifdef FEAT_SYN_HL\n\t\tif (rex.nfa_has_zsubexpr)\n\t\t    copy_sub_off(&m->synt, &t->subs.synt);\n#endif\n\n\t\t// First try matching the pattern.\n\t\tresult = recursive_regmatch(t->state, NULL, prog,\n\t\t\t\t\t  submatch, m, &listids, &listids_len);\n\t\tif (result == NFA_TOO_EXPENSIVE)\n\t\t{\n\t\t    nfa_match = result;\n\t\t    goto theend;\n\t\t}\n\t\tif (result)\n\t\t{\n\t\t    int bytelen;\n\n#ifdef ENABLE_LOG\n\t\t    fprintf(log_fd, \"NFA_START_PATTERN matches:\\n\");\n\t\t    log_subsexpr(m);\n#endif\n\t\t    // Copy submatch info from the recursive call\n\t\t    copy_sub_off(&t->subs.norm, &m->norm);\n#ifdef FEAT_SYN_HL\n\t\t    if (rex.nfa_has_zsubexpr)\n\t\t\tcopy_sub_off(&t->subs.synt, &m->synt);\n#endif\n\t\t    // Now we need to skip over the matched text and then\n\t\t    // continue with what follows.\n\t\t    if (REG_MULTI)\n\t\t\t// TODO: multi-line match\n\t\t\tbytelen = m->norm.list.multi[0].end_col\n\t\t\t\t\t\t  - (int)(rex.input - rex.line);\n\t\t    else\n\t\t\tbytelen = (int)(m->norm.list.line[0].end - rex.input);\n\n#ifdef ENABLE_LOG\n\t\t    fprintf(log_fd, \"NFA_START_PATTERN length: %d\\n\", bytelen);\n#endif\n\t\t    if (bytelen == 0)\n\t\t    {\n\t\t\t// empty match, output of corresponding\n\t\t\t// NFA_END_PATTERN/NFA_SKIP to be used at current\n\t\t\t// position\n\t\t\tadd_here = TRUE;\n\t\t\tadd_state = t->state->out1->out->out;\n\t\t    }\n\t\t    else if (bytelen <= clen)\n\t\t    {\n\t\t\t// match current character, output of corresponding\n\t\t\t// NFA_END_PATTERN to be used at next position.\n\t\t\tadd_state = t->state->out1->out->out;\n\t\t\tadd_off = clen;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// skip over the matched characters, set character\n\t\t\t// count in NFA_SKIP\n\t\t\tadd_state = t->state->out1->out;\n\t\t\tadd_off = bytelen;\n\t\t\tadd_count = bytelen - clen;\n\t\t    }\n\t\t}\n\t\tbreak;\n\t      }\n\n\t    case NFA_BOL:\n\t\tif (rex.input == rex.line)\n\t\t{\n\t\t    add_here = TRUE;\n\t\t    add_state = t->state->out;\n\t\t}\n\t\tbreak;\n\n\t    case NFA_EOL:\n\t\tif (curc == NUL)\n\t\t{\n\t\t    add_here = TRUE;\n\t\t    add_state = t->state->out;\n\t\t}\n\t\tbreak;\n\n\t    case NFA_BOW:\n\t\tresult = TRUE;\n\n\t\tif (curc == NUL)\n\t\t    result = FALSE;\n\t\telse if (has_mbyte)\n\t\t{\n\t\t    int this_class;\n\n\t\t    // Get class of current and previous char (if it exists).\n\t\t    this_class = mb_get_class_buf(rex.input, rex.reg_buf);\n\t\t    if (this_class <= 1)\n\t\t\tresult = FALSE;\n\t\t    else if (reg_prev_class() == this_class)\n\t\t\tresult = FALSE;\n\t\t}\n\t\telse if (!vim_iswordc_buf(curc, rex.reg_buf)\n\t\t\t   || (rex.input > rex.line\n\t\t\t\t&& vim_iswordc_buf(rex.input[-1], rex.reg_buf)))\n\t\t    result = FALSE;\n\t\tif (result)\n\t\t{\n\t\t    add_here = TRUE;\n\t\t    add_state = t->state->out;\n\t\t}\n\t\tbreak;\n\n\t    case NFA_EOW:\n\t\tresult = TRUE;\n\t\tif (rex.input == rex.line)\n\t\t    result = FALSE;\n\t\telse if (has_mbyte)\n\t\t{\n\t\t    int this_class, prev_class;\n\n\t\t    // Get class of current and previous char (if it exists).\n\t\t    this_class = mb_get_class_buf(rex.input, rex.reg_buf);\n\t\t    prev_class = reg_prev_class();\n\t\t    if (this_class == prev_class\n\t\t\t\t\t|| prev_class == 0 || prev_class == 1)\n\t\t\tresult = FALSE;\n\t\t}\n\t\telse if (!vim_iswordc_buf(rex.input[-1], rex.reg_buf)\n\t\t\t|| (rex.input[0] != NUL\n\t\t\t\t\t&& vim_iswordc_buf(curc, rex.reg_buf)))\n\t\t    result = FALSE;\n\t\tif (result)\n\t\t{\n\t\t    add_here = TRUE;\n\t\t    add_state = t->state->out;\n\t\t}\n\t\tbreak;\n\n\t    case NFA_BOF:\n\t\tif (rex.lnum == 0 && rex.input == rex.line\n\t\t\t\t     && (!REG_MULTI || rex.reg_firstlnum == 1))\n\t\t{\n\t\t    add_here = TRUE;\n\t\t    add_state = t->state->out;\n\t\t}\n\t\tbreak;\n\n\t    case NFA_EOF:\n\t\tif (rex.lnum == rex.reg_maxline && curc == NUL)\n\t\t{\n\t\t    add_here = TRUE;\n\t\t    add_state = t->state->out;\n\t\t}\n\t\tbreak;\n\n\t    case NFA_COMPOSING:\n\t    {\n\t\tint\t    mc = curc;\n\t\tint\t    len = 0;\n\t\tnfa_state_T *end;\n\t\tnfa_state_T *sta;\n\t\tint\t    cchars[MAX_MCO];\n\t\tint\t    ccount = 0;\n\t\tint\t    j;\n\n\t\tsta = t->state->out;\n\t\tlen = 0;\n\t\tif (utf_iscomposing(sta->c))\n\t\t{\n\t\t    // Only match composing character(s), ignore base\n\t\t    // character.  Used for \".{composing}\" and \"{composing}\"\n\t\t    // (no preceding character).\n\t\t    len += mb_char2len(mc);\n\t\t}\n\t\tif (rex.reg_icombine && len == 0)\n\t\t{\n\t\t    // If \\Z was present, then ignore composing characters.\n\t\t    // When ignoring the base character this always matches.\n\t\t    if (sta->c != curc)\n\t\t\tresult = FAIL;\n\t\t    else\n\t\t\tresult = OK;\n\t\t    while (sta->c != NFA_END_COMPOSING)\n\t\t\tsta = sta->out;\n\t\t}\n\n\t\t// Check base character matches first, unless ignored.\n\t\telse if (len > 0 || mc == sta->c)\n\t\t{\n\t\t    if (len == 0)\n\t\t    {\n\t\t\tlen += mb_char2len(mc);\n\t\t\tsta = sta->out;\n\t\t    }\n\n\t\t    // We don't care about the order of composing characters.\n\t\t    // Get them into cchars[] first.\n\t\t    while (len < clen)\n\t\t    {\n\t\t\tmc = mb_ptr2char(rex.input + len);\n\t\t\tcchars[ccount++] = mc;\n\t\t\tlen += mb_char2len(mc);\n\t\t\tif (ccount == MAX_MCO)\n\t\t\t    break;\n\t\t    }\n\n\t\t    // Check that each composing char in the pattern matches a\n\t\t    // composing char in the text.  We do not check if all\n\t\t    // composing chars are matched.\n\t\t    result = OK;\n\t\t    while (sta->c != NFA_END_COMPOSING)\n\t\t    {\n\t\t\tfor (j = 0; j < ccount; ++j)\n\t\t\t    if (cchars[j] == sta->c)\n\t\t\t\tbreak;\n\t\t\tif (j == ccount)\n\t\t\t{\n\t\t\t    result = FAIL;\n\t\t\t    break;\n\t\t\t}\n\t\t\tsta = sta->out;\n\t\t    }\n\t\t}\n\t\telse\n\t\t    result = FAIL;\n\n\t\tend = t->state->out1;\t    // NFA_END_COMPOSING\n\t\tADD_STATE_IF_MATCH(end);\n\t\tbreak;\n\t    }\n\n\t    case NFA_NEWL:\n\t\tif (curc == NUL && !rex.reg_line_lbr && REG_MULTI\n\t\t\t\t\t\t && rex.lnum <= rex.reg_maxline)\n\t\t{\n\t\t    go_to_nextline = TRUE;\n\t\t    // Pass -1 for the offset, which means taking the position\n\t\t    // at the start of the next line.\n\t\t    add_state = t->state->out;\n\t\t    add_off = -1;\n\t\t}\n\t\telse if (curc == '\\n' && rex.reg_line_lbr)\n\t\t{\n\t\t    // match \\n as if it is an ordinary character\n\t\t    add_state = t->state->out;\n\t\t    add_off = 1;\n\t\t}\n\t\tbreak;\n\n\t    case NFA_START_COLL:\n\t    case NFA_START_NEG_COLL:\n\t      {\n\t\t// What follows is a list of characters, until NFA_END_COLL.\n\t\t// One of them must match or none of them must match.\n\t\tnfa_state_T\t*state;\n\t\tint\t\tresult_if_matched;\n\t\tint\t\tc1, c2;\n\n\t\t// Never match EOL. If it's part of the collection it is added\n\t\t// as a separate state with an OR.\n\t\tif (curc == NUL)\n\t\t    break;\n\n\t\tstate = t->state->out;\n\t\tresult_if_matched = (t->state->c == NFA_START_COLL);\n\t\tfor (;;)\n\t\t{\n\t\t    if (state->c == NFA_END_COLL)\n\t\t    {\n\t\t\tresult = !result_if_matched;\n\t\t\tbreak;\n\t\t    }\n\t\t    if (state->c == NFA_RANGE_MIN)\n\t\t    {\n\t\t\tc1 = state->val;\n\t\t\tstate = state->out; // advance to NFA_RANGE_MAX\n\t\t\tc2 = state->val;\n#ifdef ENABLE_LOG\n\t\t\tfprintf(log_fd, \"NFA_RANGE_MIN curc=%d c1=%d c2=%d\\n\",\n\t\t\t\tcurc, c1, c2);\n#endif\n\t\t\tif (curc >= c1 && curc <= c2)\n\t\t\t{\n\t\t\t    result = result_if_matched;\n\t\t\t    break;\n\t\t\t}\n\t\t\tif (rex.reg_ic)\n\t\t\t{\n\t\t\t    int curc_low = MB_CASEFOLD(curc);\n\t\t\t    int done = FALSE;\n\n\t\t\t    for ( ; c1 <= c2; ++c1)\n\t\t\t\tif (MB_CASEFOLD(c1) == curc_low)\n\t\t\t\t{\n\t\t\t\t    result = result_if_matched;\n\t\t\t\t    done = TRUE;\n\t\t\t\t    break;\n\t\t\t\t}\n\t\t\t    if (done)\n\t\t\t\tbreak;\n\t\t\t}\n\t\t    }\n\t\t    else if (state->c < 0 ? check_char_class(state->c, curc)\n\t\t\t       : (curc == state->c\n\t\t\t\t   || (rex.reg_ic && MB_CASEFOLD(curc)\n\t\t\t\t\t\t    == MB_CASEFOLD(state->c))))\n\t\t    {\n\t\t\tresult = result_if_matched;\n\t\t\tbreak;\n\t\t    }\n\t\t    state = state->out;\n\t\t}\n\t\tif (result)\n\t\t{\n\t\t    // next state is in out of the NFA_END_COLL, out1 of\n\t\t    // START points to the END state\n\t\t    add_state = t->state->out1->out;\n\t\t    add_off = clen;\n\t\t}\n\t\tbreak;\n\t      }\n\n\t    case NFA_ANY:\n\t\t// Any char except '\\0', (end of input) does not match.\n\t\tif (curc > 0)\n\t\t{\n\t\t    add_state = t->state->out;\n\t\t    add_off = clen;\n\t\t}\n\t\tbreak;\n\n\t    case NFA_ANY_COMPOSING:\n\t\t// On a composing character skip over it.  Otherwise do\n\t\t// nothing.  Always matches.\n\t\tif (enc_utf8 && utf_iscomposing(curc))\n\t\t{\n\t\t    add_off = clen;\n\t\t}\n\t\telse\n\t\t{\n\t\t    add_here = TRUE;\n\t\t    add_off = 0;\n\t\t}\n\t\tadd_state = t->state->out;\n\t\tbreak;\n\n\t    /*\n\t     * Character classes like \\a for alpha, \\d for digit etc.\n\t     */\n\t    case NFA_IDENT:\t//  \\i\n\t\tresult = vim_isIDc(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_SIDENT:\t//  \\I\n\t\tresult = !VIM_ISDIGIT(curc) && vim_isIDc(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_KWORD:\t//  \\k\n\t\tresult = vim_iswordp_buf(rex.input, rex.reg_buf);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_SKWORD:\t//  \\K\n\t\tresult = !VIM_ISDIGIT(curc)\n\t\t\t\t     && vim_iswordp_buf(rex.input, rex.reg_buf);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_FNAME:\t//  \\f\n\t\tresult = vim_isfilec(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_SFNAME:\t//  \\F\n\t\tresult = !VIM_ISDIGIT(curc) && vim_isfilec(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_PRINT:\t//  \\p\n\t\tresult = vim_isprintc(PTR2CHAR(rex.input));\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_SPRINT:\t//  \\P\n\t\tresult = !VIM_ISDIGIT(curc) && vim_isprintc(PTR2CHAR(rex.input));\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_WHITE:\t//  \\s\n\t\tresult = VIM_ISWHITE(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_NWHITE:\t//  \\S\n\t\tresult = curc != NUL && !VIM_ISWHITE(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_DIGIT:\t//  \\d\n\t\tresult = ri_digit(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_NDIGIT:\t//  \\D\n\t\tresult = curc != NUL && !ri_digit(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_HEX:\t//  \\x\n\t\tresult = ri_hex(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_NHEX:\t//  \\X\n\t\tresult = curc != NUL && !ri_hex(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_OCTAL:\t//  \\o\n\t\tresult = ri_octal(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_NOCTAL:\t//  \\O\n\t\tresult = curc != NUL && !ri_octal(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_WORD:\t//  \\w\n\t\tresult = ri_word(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_NWORD:\t//  \\W\n\t\tresult = curc != NUL && !ri_word(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_HEAD:\t//  \\h\n\t\tresult = ri_head(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_NHEAD:\t//  \\H\n\t\tresult = curc != NUL && !ri_head(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_ALPHA:\t//  \\a\n\t\tresult = ri_alpha(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_NALPHA:\t//  \\A\n\t\tresult = curc != NUL && !ri_alpha(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_LOWER:\t//  \\l\n\t\tresult = ri_lower(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_NLOWER:\t//  \\L\n\t\tresult = curc != NUL && !ri_lower(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_UPPER:\t//  \\u\n\t\tresult = ri_upper(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_NUPPER:\t// \\U\n\t\tresult = curc != NUL && !ri_upper(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_LOWER_IC:\t// [a-z]\n\t\tresult = ri_lower(curc) || (rex.reg_ic && ri_upper(curc));\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_NLOWER_IC:\t// [^a-z]\n\t\tresult = curc != NUL\n\t\t\t&& !(ri_lower(curc) || (rex.reg_ic && ri_upper(curc)));\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_UPPER_IC:\t// [A-Z]\n\t\tresult = ri_upper(curc) || (rex.reg_ic && ri_lower(curc));\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_NUPPER_IC:\t// ^[A-Z]\n\t\tresult = curc != NUL\n\t\t\t&& !(ri_upper(curc) || (rex.reg_ic && ri_lower(curc)));\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_BACKREF1:\n\t    case NFA_BACKREF2:\n\t    case NFA_BACKREF3:\n\t    case NFA_BACKREF4:\n\t    case NFA_BACKREF5:\n\t    case NFA_BACKREF6:\n\t    case NFA_BACKREF7:\n\t    case NFA_BACKREF8:\n\t    case NFA_BACKREF9:\n#ifdef FEAT_SYN_HL\n\t    case NFA_ZREF1:\n\t    case NFA_ZREF2:\n\t    case NFA_ZREF3:\n\t    case NFA_ZREF4:\n\t    case NFA_ZREF5:\n\t    case NFA_ZREF6:\n\t    case NFA_ZREF7:\n\t    case NFA_ZREF8:\n\t    case NFA_ZREF9:\n#endif\n\t\t// \\1 .. \\9  \\z1 .. \\z9\n\t      {\n\t\tint subidx;\n\t\tint bytelen;\n\n\t\tif (t->state->c <= NFA_BACKREF9)\n\t\t{\n\t\t    subidx = t->state->c - NFA_BACKREF1 + 1;\n\t\t    result = match_backref(&t->subs.norm, subidx, &bytelen);\n\t\t}\n#ifdef FEAT_SYN_HL\n\t\telse\n\t\t{\n\t\t    subidx = t->state->c - NFA_ZREF1 + 1;\n\t\t    result = match_zref(subidx, &bytelen);\n\t\t}\n#endif\n\n\t\tif (result)\n\t\t{\n\t\t    if (bytelen == 0)\n\t\t    {\n\t\t\t// empty match always works, output of NFA_SKIP to be\n\t\t\t// used next\n\t\t\tadd_here = TRUE;\n\t\t\tadd_state = t->state->out->out;\n\t\t    }\n\t\t    else if (bytelen <= clen)\n\t\t    {\n\t\t\t// match current character, jump ahead to out of\n\t\t\t// NFA_SKIP\n\t\t\tadd_state = t->state->out->out;\n\t\t\tadd_off = clen;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// skip over the matched characters, set character\n\t\t\t// count in NFA_SKIP\n\t\t\tadd_state = t->state->out;\n\t\t\tadd_off = bytelen;\n\t\t\tadd_count = bytelen - clen;\n\t\t    }\n\t\t}\n\t\tbreak;\n\t      }\n\t    case NFA_SKIP:\n\t      // character of previous matching \\1 .. \\9  or \\@>\n\t      if (t->count - clen <= 0)\n\t      {\n\t\t  // end of match, go to what follows\n\t\t  add_state = t->state->out;\n\t\t  add_off = clen;\n\t      }\n\t      else\n\t      {\n\t\t  // add state again with decremented count\n\t\t  add_state = t->state;\n\t\t  add_off = 0;\n\t\t  add_count = t->count - clen;\n\t      }\n\t      break;\n\n\t    case NFA_LNUM:\n\t    case NFA_LNUM_GT:\n\t    case NFA_LNUM_LT:\n\t\tresult = (REG_MULTI &&\n\t\t\tnfa_re_num_cmp(t->state->val, t->state->c - NFA_LNUM,\n\t\t\t    (long_u)(rex.lnum + rex.reg_firstlnum)));\n\t\tif (result)\n\t\t{\n\t\t    add_here = TRUE;\n\t\t    add_state = t->state->out;\n\t\t}\n\t\tbreak;\n\n\t    case NFA_COL:\n\t    case NFA_COL_GT:\n\t    case NFA_COL_LT:\n\t\tresult = nfa_re_num_cmp(t->state->val, t->state->c - NFA_COL,\n\t\t\t(long_u)(rex.input - rex.line) + 1);\n\t\tif (result)\n\t\t{\n\t\t    add_here = TRUE;\n\t\t    add_state = t->state->out;\n\t\t}\n\t\tbreak;\n\n\t    case NFA_VCOL:\n\t    case NFA_VCOL_GT:\n\t    case NFA_VCOL_LT:\n\t\t{\n\t\t    int     op = t->state->c - NFA_VCOL;\n\t\t    colnr_T col = (colnr_T)(rex.input - rex.line);\n\t\t    win_T   *wp = rex.reg_win == NULL ? curwin : rex.reg_win;\n\n\t\t    // Bail out quickly when there can't be a match, avoid the\n\t\t    // overhead of win_linetabsize() on long lines.\n\t\t    if (op != 1 && col > t->state->val\n\t\t\t    * (has_mbyte ? MB_MAXBYTES : 1))\n\t\t\tbreak;\n\t\t    result = FALSE;\n\t\t    if (op == 1 && col - 1 > t->state->val && col > 100)\n\t\t    {\n\t\t\tint ts = wp->w_buffer->b_p_ts;\n\n\t\t\t// Guess that a character won't use more columns than\n\t\t\t// 'tabstop', with a minimum of 4.\n\t\t\tif (ts < 4)\n\t\t\t    ts = 4;\n\t\t\tresult = col > t->state->val * ts;\n\t\t    }\n\t\t    if (!result)\n\t\t\tresult = nfa_re_num_cmp(t->state->val, op,\n\t\t\t\t(long_u)win_linetabsize(wp, rex.line, col) + 1);\n\t\t    if (result)\n\t\t    {\n\t\t\tadd_here = TRUE;\n\t\t\tadd_state = t->state->out;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    case NFA_MARK:\n\t    case NFA_MARK_GT:\n\t    case NFA_MARK_LT:\n\t      {\n\t\tpos_T\t*pos = getmark_buf(rex.reg_buf, t->state->val, FALSE);\n\n\t\t// Compare the mark position to the match position, if the mark\n\t\t// exists and mark is set in reg_buf.\n\t\tif (pos != NULL && pos->lnum > 0)\n\t\t{\n\t\t    colnr_T pos_col = pos->lnum == rex.lnum + rex.reg_firstlnum\n\t\t\t\t\t\t\t  && pos->col == MAXCOL\n\t\t\t\t      ? (colnr_T)STRLEN(reg_getline(\n\t\t\t\t\t\tpos->lnum - rex.reg_firstlnum))\n\t\t\t\t      : pos->col;\n\n\t\t    result = (pos->lnum == rex.lnum + rex.reg_firstlnum\n\t\t\t\t? (pos_col == (colnr_T)(rex.input - rex.line)\n\t\t\t\t    ? t->state->c == NFA_MARK\n\t\t\t\t    : (pos_col < (colnr_T)(rex.input - rex.line)\n\t\t\t\t\t? t->state->c == NFA_MARK_GT\n\t\t\t\t\t: t->state->c == NFA_MARK_LT))\n\t\t\t\t: (pos->lnum < rex.lnum + rex.reg_firstlnum\n\t\t\t\t    ? t->state->c == NFA_MARK_GT\n\t\t\t\t    : t->state->c == NFA_MARK_LT));\n\t\t    if (result)\n\t\t    {\n\t\t\tadd_here = TRUE;\n\t\t\tadd_state = t->state->out;\n\t\t    }\n\t\t}\n\t\tbreak;\n\t      }\n\n\t    case NFA_CURSOR:\n\t\tresult = (rex.reg_win != NULL\n\t\t\t&& (rex.lnum + rex.reg_firstlnum\n\t\t\t\t\t\t == rex.reg_win->w_cursor.lnum)\n\t\t\t&& ((colnr_T)(rex.input - rex.line)\n\t\t\t\t\t\t== rex.reg_win->w_cursor.col));\n\t\tif (result)\n\t\t{\n\t\t    add_here = TRUE;\n\t\t    add_state = t->state->out;\n\t\t}\n\t\tbreak;\n\n\t    case NFA_VISUAL:\n\t\tresult = reg_match_visual();\n\t\tif (result)\n\t\t{\n\t\t    add_here = TRUE;\n\t\t    add_state = t->state->out;\n\t\t}\n\t\tbreak;\n\n\t    case NFA_MOPEN1:\n\t    case NFA_MOPEN2:\n\t    case NFA_MOPEN3:\n\t    case NFA_MOPEN4:\n\t    case NFA_MOPEN5:\n\t    case NFA_MOPEN6:\n\t    case NFA_MOPEN7:\n\t    case NFA_MOPEN8:\n\t    case NFA_MOPEN9:\n#ifdef FEAT_SYN_HL\n\t    case NFA_ZOPEN:\n\t    case NFA_ZOPEN1:\n\t    case NFA_ZOPEN2:\n\t    case NFA_ZOPEN3:\n\t    case NFA_ZOPEN4:\n\t    case NFA_ZOPEN5:\n\t    case NFA_ZOPEN6:\n\t    case NFA_ZOPEN7:\n\t    case NFA_ZOPEN8:\n\t    case NFA_ZOPEN9:\n#endif\n\t    case NFA_NOPEN:\n\t    case NFA_ZSTART:\n\t\t// These states are only added to be able to bail out when\n\t\t// they are added again, nothing is to be done.\n\t\tbreak;\n\n\t    default:\t// regular character\n\t      {\n\t\tint c = t->state->c;\n\n#ifdef DEBUG\n\t\tif (c < 0)\n\t\t    siemsg(\"INTERNAL: Negative state char: %ld\", c);\n#endif\n\t\tresult = (c == curc);\n\n\t\tif (!result && rex.reg_ic)\n\t\t    result = MB_CASEFOLD(c) == MB_CASEFOLD(curc);\n\t\t// If rex.reg_icombine is not set only skip over the character\n\t\t// itself.  When it is set skip over composing characters.\n\t\tif (result && enc_utf8 && !rex.reg_icombine)\n\t\t    clen = utf_ptr2len(rex.input);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\t      }\n\n\t    } // switch (t->state->c)\n\n\t    if (add_state != NULL)\n\t    {\n\t\tnfa_pim_T *pim;\n\t\tnfa_pim_T pim_copy;\n\n\t\tif (t->pim.result == NFA_PIM_UNUSED)\n\t\t    pim = NULL;\n\t\telse\n\t\t    pim = &t->pim;\n\n\t\t// Handle the postponed invisible match if the match might end\n\t\t// without advancing and before the end of the line.\n\t\tif (pim != NULL && (clen == 0 || match_follows(add_state, 0)))\n\t\t{\n\t\t    if (pim->result == NFA_PIM_TODO)\n\t\t    {\n#ifdef ENABLE_LOG\n\t\t\tfprintf(log_fd, \"\\n\");\n\t\t\tfprintf(log_fd, \"==================================\\n\");\n\t\t\tfprintf(log_fd, \"Postponed recursive nfa_regmatch()\\n\");\n\t\t\tfprintf(log_fd, \"\\n\");\n#endif\n\t\t\tresult = recursive_regmatch(pim->state, pim,\n\t\t\t\t    prog, submatch, m, &listids, &listids_len);\n\t\t\tpim->result = result ? NFA_PIM_MATCH : NFA_PIM_NOMATCH;\n\t\t\t// for \\@! and \\@<! it is a match when the result is\n\t\t\t// FALSE\n\t\t\tif (result != (pim->state->c == NFA_START_INVISIBLE_NEG\n\t\t\t     || pim->state->c == NFA_START_INVISIBLE_NEG_FIRST\n\t\t\t     || pim->state->c\n\t\t\t\t\t   == NFA_START_INVISIBLE_BEFORE_NEG\n\t\t\t     || pim->state->c\n\t\t\t\t     == NFA_START_INVISIBLE_BEFORE_NEG_FIRST))\n\t\t\t{\n\t\t\t    // Copy submatch info from the recursive call\n\t\t\t    copy_sub_off(&pim->subs.norm, &m->norm);\n#ifdef FEAT_SYN_HL\n\t\t\t    if (rex.nfa_has_zsubexpr)\n\t\t\t\tcopy_sub_off(&pim->subs.synt, &m->synt);\n#endif\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tresult = (pim->result == NFA_PIM_MATCH);\n#ifdef ENABLE_LOG\n\t\t\tfprintf(log_fd, \"\\n\");\n\t\t\tfprintf(log_fd, \"Using previous recursive nfa_regmatch() result, result == %d\\n\", pim->result);\n\t\t\tfprintf(log_fd, \"MATCH = %s\\n\", result == TRUE ? \"OK\" : \"FALSE\");\n\t\t\tfprintf(log_fd, \"\\n\");\n#endif\n\t\t    }\n\n\t\t    // for \\@! and \\@<! it is a match when result is FALSE\n\t\t    if (result != (pim->state->c == NFA_START_INVISIBLE_NEG\n\t\t\t     || pim->state->c == NFA_START_INVISIBLE_NEG_FIRST\n\t\t\t     || pim->state->c\n\t\t\t\t\t   == NFA_START_INVISIBLE_BEFORE_NEG\n\t\t\t     || pim->state->c\n\t\t\t\t     == NFA_START_INVISIBLE_BEFORE_NEG_FIRST))\n\t\t    {\n\t\t\t// Copy submatch info from the recursive call\n\t\t\tcopy_sub_off(&t->subs.norm, &pim->subs.norm);\n#ifdef FEAT_SYN_HL\n\t\t\tif (rex.nfa_has_zsubexpr)\n\t\t\t    copy_sub_off(&t->subs.synt, &pim->subs.synt);\n#endif\n\t\t    }\n\t\t    else\n\t\t\t// look-behind match failed, don't add the state\n\t\t\tcontinue;\n\n\t\t    // Postponed invisible match was handled, don't add it to\n\t\t    // following states.\n\t\t    pim = NULL;\n\t\t}\n\n\t\t// If \"pim\" points into l->t it will become invalid when\n\t\t// adding the state causes the list to be reallocated.  Make a\n\t\t// local copy to avoid that.\n\t\tif (pim == &t->pim)\n\t\t{\n\t\t    copy_pim(&pim_copy, pim);\n\t\t    pim = &pim_copy;\n\t\t}\n\n\t\tif (add_here)\n\t\t    r = addstate_here(thislist, add_state, &t->subs,\n\t\t\t\t\t\t\t\tpim, &listidx);\n\t\telse\n\t\t{\n\t\t    r = addstate(nextlist, add_state, &t->subs, pim, add_off);\n\t\t    if (add_count > 0)\n\t\t\tnextlist->t[nextlist->n - 1].count = add_count;\n\t\t}\n\t\tif (r == NULL)\n\t\t{\n\t\t    nfa_match = NFA_TOO_EXPENSIVE;\n\t\t    goto theend;\n\t\t}\n\t    }\n\n\t} // for (thislist = thislist; thislist->state; thislist++)\n\n\t// Look for the start of a match in the current position by adding the\n\t// start state to the list of states.\n\t// The first found match is the leftmost one, thus the order of states\n\t// matters!\n\t// Do not add the start state in recursive calls of nfa_regmatch(),\n\t// because recursive calls should only start in the first position.\n\t// Unless \"nfa_endp\" is not NULL, then we match the end position.\n\t// Also don't start a match past the first line.\n\tif (nfa_match == FALSE\n\t\t&& ((toplevel\n\t\t\t&& rex.lnum == 0\n\t\t\t&& clen != 0\n\t\t\t&& (rex.reg_maxcol == 0\n\t\t\t    || (colnr_T)(rex.input - rex.line) < rex.reg_maxcol))\n\t\t    || (nfa_endp != NULL\n\t\t\t&& (REG_MULTI\n\t\t\t    ? (rex.lnum < nfa_endp->se_u.pos.lnum\n\t\t\t       || (rex.lnum == nfa_endp->se_u.pos.lnum\n\t\t\t\t   && (int)(rex.input - rex.line)\n\t\t\t\t\t\t    < nfa_endp->se_u.pos.col))\n\t\t\t    : rex.input < nfa_endp->se_u.ptr))))\n\t{\n#ifdef ENABLE_LOG\n\t    fprintf(log_fd, \"(---) STARTSTATE\\n\");\n#endif\n\t    // Inline optimized code for addstate() if we know the state is\n\t    // the first MOPEN.\n\t    if (toplevel)\n\t    {\n\t\tint add = TRUE;\n\t\tint c;\n\n\t\tif (prog->regstart != NUL && clen != 0)\n\t\t{\n\t\t    if (nextlist->n == 0)\n\t\t    {\n\t\t\tcolnr_T col = (colnr_T)(rex.input - rex.line) + clen;\n\n\t\t\t// Nextlist is empty, we can skip ahead to the\n\t\t\t// character that must appear at the start.\n\t\t\tif (skip_to_start(prog->regstart, &col) == FAIL)\n\t\t\t    break;\n#ifdef ENABLE_LOG\n\t\t\tfprintf(log_fd, \"  Skipping ahead %d bytes to regstart\\n\",\n\t\t\t\tcol - ((colnr_T)(rex.input - rex.line) + clen));\n#endif\n\t\t\trex.input = rex.line + col - clen;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// Checking if the required start character matches is\n\t\t\t// cheaper than adding a state that won't match.\n\t\t\tc = PTR2CHAR(rex.input + clen);\n\t\t\tif (c != prog->regstart && (!rex.reg_ic\n\t\t\t     || MB_CASEFOLD(c) != MB_CASEFOLD(prog->regstart)))\n\t\t\t{\n#ifdef ENABLE_LOG\n\t\t\t    fprintf(log_fd, \"  Skipping start state, regstart does not match\\n\");\n#endif\n\t\t\t    add = FALSE;\n\t\t\t}\n\t\t    }\n\t\t}\n\n\t\tif (add)\n\t\t{\n\t\t    if (REG_MULTI)\n\t\t\tm->norm.list.multi[0].start_col =\n\t\t\t\t\t (colnr_T)(rex.input - rex.line) + clen;\n\t\t    else\n\t\t\tm->norm.list.line[0].start = rex.input + clen;\n\t\t    if (addstate(nextlist, start->out, m, NULL, clen) == NULL)\n\t\t    {\n\t\t\tnfa_match = NFA_TOO_EXPENSIVE;\n\t\t\tgoto theend;\n\t\t    }\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tif (addstate(nextlist, start, m, NULL, clen) == NULL)\n\t\t{\n\t\t    nfa_match = NFA_TOO_EXPENSIVE;\n\t\t    goto theend;\n\t\t}\n\t    }\n\t}\n\n#ifdef ENABLE_LOG\n\tfprintf(log_fd, \">>> Thislist had %d states available: \", thislist->n);\n\t{\n\t    int i;\n\n\t    for (i = 0; i < thislist->n; i++)\n\t\tfprintf(log_fd, \"%d  \", abs(thislist->t[i].state->id));\n\t}\n\tfprintf(log_fd, \"\\n\");\n#endif\n\nnextchar:\n\t// Advance to the next character, or advance to the next line, or\n\t// finish.\n\tif (clen != 0)\n\t    rex.input += clen;\n\telse if (go_to_nextline || (nfa_endp != NULL && REG_MULTI\n\t\t\t\t\t&& rex.lnum < nfa_endp->se_u.pos.lnum))\n\t    reg_nextline();\n\telse\n\t    break;\n\n\t// Allow interrupting with CTRL-C.\n\tline_breakcheck();\n\tif (got_int)\n\t    break;\n#ifdef FEAT_RELTIME\n\t// Check for timeout once in a twenty times to avoid overhead.\n\tif (nfa_time_limit != NULL && ++nfa_time_count == 20)\n\t{\n\t    nfa_time_count = 0;\n\t    if (nfa_did_time_out())\n\t\tbreak;\n\t}\n#endif\n    }\n\n#ifdef ENABLE_LOG\n    if (log_fd != stderr)\n\tfclose(log_fd);\n    log_fd = NULL;\n#endif\n\ntheend:\n    // Free memory\n    vim_free(list[0].t);\n    vim_free(list[1].t);\n    vim_free(listids);\n#undef ADD_STATE_IF_MATCH\n#ifdef NFA_REGEXP_DEBUG_LOG\n    fclose(debug);\n#endif\n\n    return nfa_match;\n}\n\n/*\n * Try match of \"prog\" with at rex.line[\"col\"].\n * Returns <= 0 for failure, number of lines contained in the match otherwise.\n */\n    static long\nnfa_regtry(\n    nfa_regprog_T   *prog,\n    colnr_T\t    col,\n    proftime_T\t    *tm UNUSED,\t// timeout limit or NULL\n    int\t\t    *timed_out UNUSED)\t// flag set on timeout or NULL\n{\n    int\t\ti;\n    regsubs_T\tsubs, m;\n    nfa_state_T\t*start = prog->start;\n    int\t\tresult;\n#ifdef ENABLE_LOG\n    FILE\t*f;\n#endif\n\n    rex.input = rex.line + col;\n#ifdef FEAT_RELTIME\n    nfa_time_limit = tm;\n    nfa_timed_out = timed_out;\n    nfa_time_count = 0;\n#endif\n\n#ifdef ENABLE_LOG\n    f = fopen(NFA_REGEXP_RUN_LOG, \"a\");\n    if (f != NULL)\n    {\n\tfprintf(f, \"\\n\\n\\t=======================================================\\n\");\n#ifdef DEBUG\n\tfprintf(f, \"\\tRegexp is \\\"%s\\\"\\n\", nfa_regengine.expr);\n#endif\n\tfprintf(f, \"\\tInput text is \\\"%s\\\" \\n\", rex.input);\n\tfprintf(f, \"\\t=======================================================\\n\\n\");\n\tnfa_print_state(f, start);\n\tfprintf(f, \"\\n\\n\");\n\tfclose(f);\n    }\n    else\n\temsg(\"Could not open temporary log file for writing\");\n#endif\n\n    clear_sub(&subs.norm);\n    clear_sub(&m.norm);\n#ifdef FEAT_SYN_HL\n    clear_sub(&subs.synt);\n    clear_sub(&m.synt);\n#endif\n\n    result = nfa_regmatch(prog, start, &subs, &m);\n    if (result == FALSE)\n\treturn 0;\n    else if (result == NFA_TOO_EXPENSIVE)\n\treturn result;\n\n    cleanup_subexpr();\n    if (REG_MULTI)\n    {\n\tfor (i = 0; i < subs.norm.in_use; i++)\n\t{\n\t    rex.reg_startpos[i].lnum = subs.norm.list.multi[i].start_lnum;\n\t    rex.reg_startpos[i].col = subs.norm.list.multi[i].start_col;\n\n\t    rex.reg_endpos[i].lnum = subs.norm.list.multi[i].end_lnum;\n\t    rex.reg_endpos[i].col = subs.norm.list.multi[i].end_col;\n\t}\n\n\tif (rex.reg_startpos[0].lnum < 0)\n\t{\n\t    rex.reg_startpos[0].lnum = 0;\n\t    rex.reg_startpos[0].col = col;\n\t}\n\tif (rex.reg_endpos[0].lnum < 0)\n\t{\n\t    // pattern has a \\ze but it didn't match, use current end\n\t    rex.reg_endpos[0].lnum = rex.lnum;\n\t    rex.reg_endpos[0].col = (int)(rex.input - rex.line);\n\t}\n\telse\n\t    // Use line number of \"\\ze\".\n\t    rex.lnum = rex.reg_endpos[0].lnum;\n    }\n    else\n    {\n\tfor (i = 0; i < subs.norm.in_use; i++)\n\t{\n\t    rex.reg_startp[i] = subs.norm.list.line[i].start;\n\t    rex.reg_endp[i] = subs.norm.list.line[i].end;\n\t}\n\n\tif (rex.reg_startp[0] == NULL)\n\t    rex.reg_startp[0] = rex.line + col;\n\tif (rex.reg_endp[0] == NULL)\n\t    rex.reg_endp[0] = rex.input;\n    }\n\n#ifdef FEAT_SYN_HL\n    // Package any found \\z(...\\) matches for export. Default is none.\n    unref_extmatch(re_extmatch_out);\n    re_extmatch_out = NULL;\n\n    if (prog->reghasz == REX_SET)\n    {\n\tcleanup_zsubexpr();\n\tre_extmatch_out = make_extmatch();\n\tif (re_extmatch_out == NULL)\n\t    return 0;\n\t// Loop over \\z1, \\z2, etc.  There is no \\z0.\n\tfor (i = 1; i < subs.synt.in_use; i++)\n\t{\n\t    if (REG_MULTI)\n\t    {\n\t\tstruct multipos *mpos = &subs.synt.list.multi[i];\n\n\t\t// Only accept single line matches that are valid.\n\t\tif (mpos->start_lnum >= 0\n\t\t\t&& mpos->start_lnum == mpos->end_lnum\n\t\t\t&& mpos->end_col >= mpos->start_col)\n\t\t    re_extmatch_out->matches[i] =\n\t\t\tvim_strnsave(reg_getline(mpos->start_lnum)\n\t\t\t\t\t\t\t    + mpos->start_col,\n\t\t\t\t\t     mpos->end_col - mpos->start_col);\n\t    }\n\t    else\n\t    {\n\t\tstruct linepos *lpos = &subs.synt.list.line[i];\n\n\t\tif (lpos->start != NULL && lpos->end != NULL)\n\t\t    re_extmatch_out->matches[i] =\n\t\t\t    vim_strnsave(lpos->start, lpos->end - lpos->start);\n\t    }\n\t}\n    }\n#endif\n\n    return 1 + rex.lnum;\n}\n\n/*\n * Match a regexp against a string (\"line\" points to the string) or multiple\n * lines (if \"line\" is NULL, use reg_getline()).\n *\n * Returns <= 0 for failure, number of lines contained in the match otherwise.\n */\n    static long\nnfa_regexec_both(\n    char_u\t*line,\n    colnr_T\tstartcol,\t// column to start looking for match\n    proftime_T\t*tm,\t\t// timeout limit or NULL\n    int\t\t*timed_out)\t// flag set on timeout or NULL\n{\n    nfa_regprog_T   *prog;\n    long\t    retval = 0L;\n    int\t\t    i;\n    colnr_T\t    col = startcol;\n\n    if (REG_MULTI)\n    {\n\tprog = (nfa_regprog_T *)rex.reg_mmatch->regprog;\n\tline = reg_getline((linenr_T)0);    // relative to the cursor\n\trex.reg_startpos = rex.reg_mmatch->startpos;\n\trex.reg_endpos = rex.reg_mmatch->endpos;\n    }\n    else\n    {\n\tprog = (nfa_regprog_T *)rex.reg_match->regprog;\n\trex.reg_startp = rex.reg_match->startp;\n\trex.reg_endp = rex.reg_match->endp;\n    }\n\n    // Be paranoid...\n    if (prog == NULL || line == NULL)\n    {\n\tiemsg(_(e_null_argument));\n\tgoto theend;\n    }\n\n    // If pattern contains \"\\c\" or \"\\C\": overrule value of rex.reg_ic\n    if (prog->regflags & RF_ICASE)\n\trex.reg_ic = TRUE;\n    else if (prog->regflags & RF_NOICASE)\n\trex.reg_ic = FALSE;\n\n    // If pattern contains \"\\Z\" overrule value of rex.reg_icombine\n    if (prog->regflags & RF_ICOMBINE)\n\trex.reg_icombine = TRUE;\n\n    rex.line = line;\n    rex.lnum = 0;    // relative to line\n\n    rex.nfa_has_zend = prog->has_zend;\n    rex.nfa_has_backref = prog->has_backref;\n    rex.nfa_nsubexpr = prog->nsubexp;\n    rex.nfa_listid = 1;\n    rex.nfa_alt_listid = 2;\n#ifdef DEBUG\n    nfa_regengine.expr = prog->pattern;\n#endif\n\n    if (prog->reganch && col > 0)\n\treturn 0L;\n\n    rex.need_clear_subexpr = TRUE;\n#ifdef FEAT_SYN_HL\n    // Clear the external match subpointers if necessary.\n    if (prog->reghasz == REX_SET)\n    {\n\trex.nfa_has_zsubexpr = TRUE;\n\trex.need_clear_zsubexpr = TRUE;\n    }\n    else\n    {\n\trex.nfa_has_zsubexpr = FALSE;\n\trex.need_clear_zsubexpr = FALSE;\n    }\n#endif\n\n    if (prog->regstart != NUL)\n    {\n\t// Skip ahead until a character we know the match must start with.\n\t// When there is none there is no match.\n\tif (skip_to_start(prog->regstart, &col) == FAIL)\n\t    return 0L;\n\n\t// If match_text is set it contains the full text that must match.\n\t// Nothing else to try. Doesn't handle combining chars well.\n\tif (prog->match_text != NULL && !rex.reg_icombine)\n\t    return find_match_text(col, prog->regstart, prog->match_text);\n    }\n\n    // If the start column is past the maximum column: no need to try.\n    if (rex.reg_maxcol > 0 && col >= rex.reg_maxcol)\n\tgoto theend;\n\n    // Set the \"nstate\" used by nfa_regcomp() to zero to trigger an error when\n    // it's accidentally used during execution.\n    nstate = 0;\n    for (i = 0; i < prog->nstate; ++i)\n    {\n\tprog->state[i].id = i;\n\tprog->state[i].lastlist[0] = 0;\n\tprog->state[i].lastlist[1] = 0;\n    }\n\n    retval = nfa_regtry(prog, col, tm, timed_out);\n\n#ifdef DEBUG\n    nfa_regengine.expr = NULL;\n#endif\n\ntheend:\n    if (retval > 0)\n    {\n\t// Make sure the end is never before the start.  Can happen when \\zs and\n\t// \\ze are used.\n\tif (REG_MULTI)\n\t{\n\t    lpos_T *start = &rex.reg_mmatch->startpos[0];\n\t    lpos_T *end = &rex.reg_mmatch->endpos[0];\n\n\t    if (end->lnum < start->lnum\n\t\t\t|| (end->lnum == start->lnum && end->col < start->col))\n\t\trex.reg_mmatch->endpos[0] = rex.reg_mmatch->startpos[0];\n\t}\n\telse\n\t{\n\t    if (rex.reg_match->endp[0] < rex.reg_match->startp[0])\n\t\trex.reg_match->endp[0] = rex.reg_match->startp[0];\n\t}\n    }\n\n    return retval;\n}\n\n/*\n * Compile a regular expression into internal code for the NFA matcher.\n * Returns the program in allocated space.  Returns NULL for an error.\n */\n    static regprog_T *\nnfa_regcomp(char_u *expr, int re_flags)\n{\n    nfa_regprog_T\t*prog = NULL;\n    size_t\t\tprog_size;\n    int\t\t\t*postfix;\n\n    if (expr == NULL)\n\treturn NULL;\n\n#ifdef DEBUG\n    nfa_regengine.expr = expr;\n#endif\n    nfa_re_flags = re_flags;\n\n    init_class_tab();\n\n    if (nfa_regcomp_start(expr, re_flags) == FAIL)\n\treturn NULL;\n\n    // Build postfix form of the regexp. Needed to build the NFA\n    // (and count its size).\n    postfix = re2post();\n    if (postfix == NULL)\n\tgoto fail;\t    // Cascaded (syntax?) error\n\n    /*\n     * In order to build the NFA, we parse the input regexp twice:\n     * 1. first pass to count size (so we can allocate space)\n     * 2. second to emit code\n     */\n#ifdef ENABLE_LOG\n    {\n\tFILE *f = fopen(NFA_REGEXP_RUN_LOG, \"a\");\n\n\tif (f != NULL)\n\t{\n\t    fprintf(f, \"\\n*****************************\\n\\n\\n\\n\\tCompiling regexp \\\"%s\\\"... hold on !\\n\", expr);\n\t    fclose(f);\n\t}\n    }\n#endif\n\n    /*\n     * PASS 1\n     * Count number of NFA states in \"nstate\". Do not build the NFA.\n     */\n    post2nfa(postfix, post_ptr, TRUE);\n\n    // allocate the regprog with space for the compiled regexp\n    prog_size = sizeof(nfa_regprog_T) + sizeof(nfa_state_T) * (nstate - 1);\n    prog = alloc(prog_size);\n    if (prog == NULL)\n\tgoto fail;\n    state_ptr = prog->state;\n    prog->re_in_use = FALSE;\n\n    /*\n     * PASS 2\n     * Build the NFA\n     */\n    prog->start = post2nfa(postfix, post_ptr, FALSE);\n    if (prog->start == NULL)\n\tgoto fail;\n\n    prog->regflags = regflags;\n    prog->engine = &nfa_regengine;\n    prog->nstate = nstate;\n    prog->has_zend = rex.nfa_has_zend;\n    prog->has_backref = rex.nfa_has_backref;\n    prog->nsubexp = regnpar;\n\n    nfa_postprocess(prog);\n\n    prog->reganch = nfa_get_reganch(prog->start, 0);\n    prog->regstart = nfa_get_regstart(prog->start, 0);\n    prog->match_text = nfa_get_match_text(prog->start);\n\n#ifdef ENABLE_LOG\n    nfa_postfix_dump(expr, OK);\n    nfa_dump(prog);\n#endif\n#ifdef FEAT_SYN_HL\n    // Remember whether this pattern has any \\z specials in it.\n    prog->reghasz = re_has_z;\n#endif\n    prog->pattern = vim_strsave(expr);\n#ifdef DEBUG\n    nfa_regengine.expr = NULL;\n#endif\n\nout:\n    VIM_CLEAR(post_start);\n    post_ptr = post_end = NULL;\n    state_ptr = NULL;\n    return (regprog_T *)prog;\n\nfail:\n    VIM_CLEAR(prog);\n#ifdef ENABLE_LOG\n    nfa_postfix_dump(expr, FAIL);\n#endif\n#ifdef DEBUG\n    nfa_regengine.expr = NULL;\n#endif\n    goto out;\n}\n\n/*\n * Free a compiled regexp program, returned by nfa_regcomp().\n */\n    static void\nnfa_regfree(regprog_T *prog)\n{\n    if (prog != NULL)\n    {\n\tvim_free(((nfa_regprog_T *)prog)->match_text);\n\tvim_free(((nfa_regprog_T *)prog)->pattern);\n\tvim_free(prog);\n    }\n}\n\n/*\n * Match a regexp against a string.\n * \"rmp->regprog\" is a compiled regexp as returned by nfa_regcomp().\n * Uses curbuf for line count and 'iskeyword'.\n * If \"line_lbr\" is TRUE consider a \"\\n\" in \"line\" to be a line break.\n *\n * Returns <= 0 for failure, number of lines contained in the match otherwise.\n */\n    static int\nnfa_regexec_nl(\n    regmatch_T\t*rmp,\n    char_u\t*line,\t// string to match against\n    colnr_T\tcol,\t// column to start looking for match\n    int\t\tline_lbr)\n{\n    rex.reg_match = rmp;\n    rex.reg_mmatch = NULL;\n    rex.reg_maxline = 0;\n    rex.reg_line_lbr = line_lbr;\n    rex.reg_buf = curbuf;\n    rex.reg_win = NULL;\n    rex.reg_ic = rmp->rm_ic;\n    rex.reg_icombine = FALSE;\n    rex.reg_maxcol = 0;\n    return nfa_regexec_both(line, col, NULL, NULL);\n}\n\n\n/*\n * Match a regexp against multiple lines.\n * \"rmp->regprog\" is a compiled regexp as returned by vim_regcomp().\n * Uses curbuf for line count and 'iskeyword'.\n *\n * Return <= 0 if there is no match.  Return number of lines contained in the\n * match otherwise.\n *\n * Note: the body is the same as bt_regexec() except for nfa_regexec_both()\n *\n * ! Also NOTE : match may actually be in another line. e.g.:\n * when r.e. is \\nc, cursor is at 'a' and the text buffer looks like\n *\n * +-------------------------+\n * |a                        |\n * |b                        |\n * |c                        |\n * |                         |\n * +-------------------------+\n *\n * then nfa_regexec_multi() returns 3. while the original\n * vim_regexec_multi() returns 0 and a second call at line 2 will return 2.\n *\n * FIXME if this behavior is not compatible.\n */\n    static long\nnfa_regexec_multi(\n    regmmatch_T\t*rmp,\n    win_T\t*win,\t\t// window in which to search or NULL\n    buf_T\t*buf,\t\t// buffer in which to search\n    linenr_T\tlnum,\t\t// nr of line to start looking for match\n    colnr_T\tcol,\t\t// column to start looking for match\n    proftime_T\t*tm,\t\t// timeout limit or NULL\n    int\t\t*timed_out)\t// flag set on timeout or NULL\n{\n    init_regexec_multi(rmp, win, buf, lnum);\n    return nfa_regexec_both(NULL, col, tm, timed_out);\n}\n\n#ifdef DEBUG\n# undef ENABLE_LOG\n#endif\n", "\" Tests for regexp in latin1 encoding\n\nset encoding=latin1\nscriptencoding latin1\n\nsource check.vim\n\nfunc s:equivalence_test()\n  let str = \"A\u00c0\u00c1\u00c2\u00c3\u00c4\u00c5 B C D E\u00c8\u00c9\u00ca\u00cb F G H I\u00cc\u00cd\u00ce\u00cf J K L M N\u00d1 O\u00d2\u00d3\u00d4\u00d5\u00d6\u00d8 P Q R S T U\u00d9\u00da\u00db\u00dc V W X Y\u00dd Z a\u00e0\u00e1\u00e2\u00e3\u00e4\u00e5 b c d e\u00e8\u00e9\u00ea\u00eb f g h i\u00ec\u00ed\u00ee\u00ef j k l m n\u00f1 o\u00f2\u00f3\u00f4\u00f5\u00f6\u00f8 p q r s t u\u00f9\u00fa\u00fb\u00fc v w x y\u00fd\u00ff z\"\n  let groups = split(str)\n  for group1 in groups\n      for c in split(group1, '\\zs')\n\t\" next statement confirms that equivalence class matches every\n\t\" character in group\n        call assert_match('^[[=' . c . '=]]*$', group1)\n        for group2 in groups\n          if group2 != group1\n\t    \" next statement converts that equivalence class doesn't match\n\t    \" a character in any other group\n            call assert_equal(-1, match(group2, '[[=' . c . '=]]'))\n          endif\n        endfor\n      endfor\n  endfor\nendfunc\n\nfunc Test_equivalence_re1()\n  set re=1\n  call s:equivalence_test()\nendfunc\n\nfunc Test_equivalence_re2()\n  set re=2\n  call s:equivalence_test()\nendfunc\n\nfunc Test_recursive_substitute()\n  new\n  s/^/\\=execute(\"s#^##gn\")\n  \" check we are now not in the sandbox\n  call setwinvar(1, 'myvar', 1)\n  bwipe!\nendfunc\n\nfunc Test_nested_backrefs()\n  \" Check example in change.txt.\n  new\n  for re in range(0, 2)\n    exe 'set re=' . re\n    call setline(1, 'aa ab x')\n    1s/\\(\\(a[a-d] \\)*\\)\\(x\\)/-\\1- -\\2- -\\3-/\n    call assert_equal('-aa ab - -ab - -x-', getline(1))\n\n    call assert_equal('-aa ab - -ab - -x-', substitute('aa ab x', '\\(\\(a[a-d] \\)*\\)\\(x\\)', '-\\1- -\\2- -\\3-', ''))\n  endfor\n  bwipe!\n  set re=0\nendfunc\n\nfunc Test_eow_with_optional()\n  let expected = ['abc def', 'abc', 'def', '', '', '', '', '', '', '']\n  for re in range(0, 2)\n    exe 'set re=' . re\n    let actual = matchlist('abc def', '\\(abc\\>\\)\\?\\s*\\(def\\)')\n    call assert_equal(expected, actual)\n  endfor\nendfunc\n\nfunc Test_backref()\n  new\n  call setline(1, ['one', 'two', 'three', 'four', 'five'])\n  call assert_equal(3, search('\\%#=1\\(e\\)\\1'))\n  call assert_equal(3, search('\\%#=2\\(e\\)\\1'))\n  call assert_fails('call search(\"\\\\%#=1\\\\(e\\\\1\\\\)\")', 'E65:')\n  call assert_fails('call search(\"\\\\%#=2\\\\(e\\\\1\\\\)\")', 'E65:')\n  bwipe!\nendfunc\n\nfunc Test_multi_failure()\n  set re=1\n  call assert_fails('/a**', 'E61:')\n  call assert_fails('/a*\\+', 'E62:')\n  call assert_fails('/a\\{a}', 'E554:')\n  set re=2\n  call assert_fails('/a**', 'E871:')\n  call assert_fails('/a*\\+', 'E871:')\n  call assert_fails('/a\\{a}', 'E554:')\n  set re=0\nendfunc\n\nfunc Test_recursive_addstate()\n  \" This will call addstate() recursively until it runs into the limit.\n  let lnum = search('\\v((){328}){389}')\n  call assert_equal(0, lnum)\nendfunc\n\nfunc Test_out_of_memory()\n  new\n  s/^/,n\n  \" This will be slow...\n  call assert_fails('call search(\"\\\\v((n||<)+);\")', 'E363:')\nendfunc\n\nfunc Test_get_equi_class()\n  new\n  \" Incomplete equivalence class caused invalid memory access\n  s/^/[[=\n  call assert_equal(1, search(getline(1)))\n  s/.*/[[.\n  call assert_equal(1, search(getline(1)))\nendfunc\n\nfunc Test_rex_init()\n  set noincsearch\n  set re=1\n  new\n  setlocal iskeyword=a-z\n  call setline(1, ['abc', 'ABC'])\n  call assert_equal(1, search('[[:keyword:]]'))\n  new\n  setlocal iskeyword=A-Z\n  call setline(1, ['abc', 'ABC'])\n  call assert_equal(2, search('[[:keyword:]]'))\n  bwipe!\n  bwipe!\n  set re=0\nendfunc\n\nfunc Test_range_with_newline()\n  new\n  call setline(1, \"a\")\n  call assert_equal(0, search(\"[ -*\\\\n- ]\"))\n  call assert_equal(0, search(\"[ -*\\\\t-\\\\n]\"))\n  bwipe!\nendfunc\n\nfunc Test_pattern_compile_speed()\n  CheckOption spellcapcheck\n  CheckFunction reltimefloat\n\n  let start = reltime()\n  \" this used to be very slow, not it should be about a second\n  set spc=\\\\v(((((Nxxxxxxx&&xxxx){179})+)+)+){179}\n  call assert_inrange(0.01, 10.0, reltimefloat(reltime(start)))\n  set spc=\nendfunc\n\n\" Tests for regexp patterns without multi-byte support.\nfunc Test_regexp_single_line_pat()\n  \" tl is a List of Lists with:\n  \"    regexp engines to test\n  \"       0 - test with 'regexpengine' values 0 and 1\n  \"       1 - test with 'regexpengine' values 0 and 2\n  \"       2 - test with 'regexpengine' values 0, 1 and 2\n  \"    regexp pattern\n  \"    text to test the pattern on\n  \"    expected match (optional)\n  \"    expected submatch 1 (optional)\n  \"    expected submatch 2 (optional)\n  \"    etc.\n  \"  When there is no match use only the first two items.\n  let tl = []\n\n  call add(tl, [2, 'ab', 'aab', 'ab'])\n  call add(tl, [2, 'b', 'abcdef', 'b'])\n  call add(tl, [2, 'bc*', 'abccccdef', 'bcccc'])\n  call add(tl, [2, 'bc\\{-}', 'abccccdef', 'b'])\n  call add(tl, [2, 'bc\\{-}\\(d\\)', 'abccccdef', 'bccccd', 'd'])\n  call add(tl, [2, 'bc*', 'abbdef', 'b'])\n  call add(tl, [2, 'c*', 'ccc', 'ccc'])\n  call add(tl, [2, 'bc*', 'abdef', 'b'])\n  call add(tl, [2, 'c*', 'abdef', ''])\n  call add(tl, [2, 'bc\\+', 'abccccdef', 'bcccc'])\n  call add(tl, [2, 'bc\\+', 'abdef']) \" no match\n  \" match escape character in a string\n  call add(tl, [2, '.\\e.', \"one\\<Esc>two\", \"e\\<Esc>t\"])\n  \" match backspace character in a string\n  call add(tl, [2, '.\\b.', \"one\\<C-H>two\", \"e\\<C-H>t\"])\n  \" match newline character in a string\n  call add(tl, [2, 'o\\nb', \"foo\\nbar\", \"o\\nb\"])\n\n  \" operator \\|\n  call add(tl, [2, 'a\\|ab', 'cabd', 'a']) \" alternation is ordered\n\n  call add(tl, [2, 'c\\?', 'ccb', 'c'])\n  call add(tl, [2, 'bc\\?', 'abd', 'b'])\n  call add(tl, [2, 'bc\\?', 'abccd', 'bc'])\n\n  call add(tl, [2, '\\va{1}', 'ab', 'a'])\n\n  call add(tl, [2, '\\va{2}', 'aa', 'aa'])\n  call add(tl, [2, '\\va{2}', 'caad', 'aa'])\n  call add(tl, [2, '\\va{2}', 'aba'])\n  call add(tl, [2, '\\va{2}', 'ab'])\n  call add(tl, [2, '\\va{2}', 'abaa', 'aa'])\n  call add(tl, [2, '\\va{2}', 'aaa', 'aa'])\n\n  call add(tl, [2, '\\vb{1}', 'abca', 'b'])\n  call add(tl, [2, '\\vba{2}', 'abaa', 'baa'])\n  call add(tl, [2, '\\vba{3}', 'aabaac'])\n\n  call add(tl, [2, '\\v(ab){1}', 'ab', 'ab', 'ab'])\n  call add(tl, [2, '\\v(ab){1}', 'dabc', 'ab', 'ab'])\n  call add(tl, [2, '\\v(ab){1}', 'acb'])\n\n  call add(tl, [2, '\\v(ab){0,2}', 'acb', \"\", \"\"])\n  call add(tl, [2, '\\v(ab){0,2}', 'ab', 'ab', 'ab'])\n  call add(tl, [2, '\\v(ab){1,2}', 'ab', 'ab', 'ab'])\n  call add(tl, [2, '\\v(ab){1,2}', 'ababc', 'abab', 'ab'])\n  call add(tl, [2, '\\v(ab){2,4}', 'ababcab', 'abab', 'ab'])\n  call add(tl, [2, '\\v(ab){2,4}', 'abcababa', 'abab', 'ab'])\n\n  call add(tl, [2, '\\v(ab){2}', 'abab', 'abab', 'ab'])\n  call add(tl, [2, '\\v(ab){2}', 'cdababe', 'abab', 'ab'])\n  call add(tl, [2, '\\v(ab){2}', 'abac'])\n  call add(tl, [2, '\\v(ab){2}', 'abacabab', 'abab', 'ab'])\n  call add(tl, [2, '\\v((ab){2}){2}', 'abababab', 'abababab', 'abab', 'ab'])\n  call add(tl, [2, '\\v((ab){2}){2}', 'abacabababab', 'abababab', 'abab', 'ab'])\n\n  call add(tl, [2, '\\v(a{1}){1}', 'a', 'a', 'a'])\n  call add(tl, [2, '\\v(a{2}){1}', 'aa', 'aa', 'aa'])\n  call add(tl, [2, '\\v(a{2}){1}', 'aaac', 'aa', 'aa'])\n  call add(tl, [2, '\\v(a{2}){1}', 'daaac', 'aa', 'aa'])\n  call add(tl, [2, '\\v(a{1}){2}', 'daaac', 'aa', 'a'])\n  call add(tl, [2, '\\v(a{1}){2}', 'aaa', 'aa', 'a'])\n  call add(tl, [2, '\\v(a{2})+', 'adaac', 'aa', 'aa'])\n  call add(tl, [2, '\\v(a{2})+', 'aa', 'aa', 'aa'])\n  call add(tl, [2, '\\v(a{2}){1}', 'aa', 'aa', 'aa'])\n  call add(tl, [2, '\\v(a{1}){2}', 'aa', 'aa', 'a'])\n  call add(tl, [2, '\\v(a{1}){1}', 'a', 'a', 'a'])\n  call add(tl, [2, '\\v(a{2}){2}', 'aaaa', 'aaaa', 'aa'])\n  call add(tl, [2, '\\v(a{2}){2}', 'aaabaaaa', 'aaaa', 'aa'])\n\n  call add(tl, [2, '\\v(a+){2}', 'dadaac', 'aa', 'a'])\n  call add(tl, [2, '\\v(a{3}){2}', 'aaaaaaa', 'aaaaaa', 'aaa'])\n\n  call add(tl, [2, '\\v(a{1,2}){2}', 'daaac', 'aaa', 'a'])\n  call add(tl, [2, '\\v(a{1,3}){2}', 'daaaac', 'aaaa', 'a'])\n  call add(tl, [2, '\\v(a{1,3}){2}', 'daaaaac', 'aaaaa', 'aa'])\n  call add(tl, [2, '\\v(a{1,3}){3}', 'daac'])\n  call add(tl, [2, '\\v(a{1,2}){2}', 'dac'])\n  call add(tl, [2, '\\v(a+)+', 'daac', 'aa', 'aa'])\n  call add(tl, [2, '\\v(a+)+', 'aaa', 'aaa', 'aaa'])\n  call add(tl, [2, '\\v(a+){1,2}', 'aaa', 'aaa', 'aaa'])\n  call add(tl, [2, '\\v(a+)(a+)', 'aaa', 'aaa', 'aa', 'a'])\n  call add(tl, [2, '\\v(a{3})+', 'daaaac', 'aaa', 'aaa'])\n  call add(tl, [2, '\\v(a|b|c)+', 'aacb', 'aacb', 'b'])\n  call add(tl, [2, '\\v(a|b|c){2}', 'abcb', 'ab', 'b'])\n  call add(tl, [2, '\\v(abc){2}', 'abcabd', ])\n  call add(tl, [2, '\\v(abc){2}', 'abdabcabc','abcabc', 'abc'])\n\n  call add(tl, [2, 'a*', 'cc', ''])\n  call add(tl, [2, '\\v(a*)+', 'cc', ''])\n  call add(tl, [2, '\\v((ab)+)+', 'ab', 'ab', 'ab', 'ab'])\n  call add(tl, [2, '\\v(((ab)+)+)+', 'ab', 'ab', 'ab', 'ab', 'ab'])\n  call add(tl, [2, '\\v(((ab)+)+)+', 'dababc', 'abab', 'abab', 'abab', 'ab'])\n  call add(tl, [2, '\\v(a{0,2})+', 'cc', ''])\n  call add(tl, [2, '\\v(a*)+', '', ''])\n  call add(tl, [2, '\\v((a*)+)+', '', ''])\n  call add(tl, [2, '\\v((ab)*)+', '', ''])\n  call add(tl, [2, '\\va{1,3}', 'aab', 'aa'])\n  call add(tl, [2, '\\va{2,3}', 'abaa', 'aa'])\n\n  call add(tl, [2, '\\v((ab)+|c*)+', 'abcccaba', 'abcccab', '', 'ab'])\n  call add(tl, [2, '\\v(a{2})|(b{3})', 'bbabbbb', 'bbb', '', 'bbb'])\n  call add(tl, [2, '\\va{2}|b{2}', 'abab'])\n  call add(tl, [2, '\\v(a)+|(c)+', 'bbacbaacbbb', 'a', 'a'])\n  call add(tl, [2, '\\vab{2,3}c', 'aabbccccccccccccc', 'abbc'])\n  call add(tl, [2, '\\vab{2,3}c', 'aabbbccccccccccccc', 'abbbc'])\n  call add(tl, [2, '\\vab{2,3}cd{2,3}e', 'aabbbcddee', 'abbbcdde'])\n  call add(tl, [2, '\\va(bc){2}d', 'aabcbfbc' ])\n  call add(tl, [2, '\\va*a{2}', 'a', ])\n  call add(tl, [2, '\\va*a{2}', 'aa', 'aa' ])\n  call add(tl, [2, '\\va*a{2}', 'aaa', 'aaa' ])\n  call add(tl, [2, '\\va*a{2}', 'bbbabcc', ])\n  call add(tl, [2, '\\va*b*|a*c*', 'a', 'a'])\n  call add(tl, [2, '\\va{1}b{1}|a{1}b{1}', ''])\n\n  \" submatches\n  call add(tl, [2, '\\v(a)', 'ab', 'a', 'a'])\n  call add(tl, [2, '\\v(a)(b)', 'ab', 'ab', 'a', 'b'])\n  call add(tl, [2, '\\v(ab)(b)(c)', 'abbc', 'abbc', 'ab', 'b', 'c'])\n  call add(tl, [2, '\\v((a)(b))', 'ab', 'ab', 'ab', 'a', 'b'])\n  call add(tl, [2, '\\v(a)|(b)', 'ab', 'a', 'a'])\n\n  call add(tl, [2, '\\v(a*)+', 'aaaa', 'aaaa', ''])\n  call add(tl, [2, 'x', 'abcdef'])\n\n  \"\n  \" Simple tests\n  \"\n\n  \" Search single groups\n  call add(tl, [2, 'ab', 'aab', 'ab'])\n  call add(tl, [2, 'ab', 'baced'])\n  call add(tl, [2, 'ab', '                    ab           ', 'ab'])\n\n  \" Search multi-modifiers\n  call add(tl, [2, 'x*', 'xcd', 'x'])\n  call add(tl, [2, 'x*', 'xxxxxxxxxxxxxxxxsofijiojgf', 'xxxxxxxxxxxxxxxx'])\n  \" empty match is good\n  call add(tl, [2, 'x*', 'abcdoij', ''])\n  \" no match here\n  call add(tl, [2, 'x\\+', 'abcdoin'])\n  call add(tl, [2, 'x\\+', 'abcdeoijdfxxiuhfij', 'xx'])\n  call add(tl, [2, 'x\\+', 'xxxxx', 'xxxxx'])\n  call add(tl, [2, 'x\\+', 'abc x siufhiush xxxxxxxxx', 'x'])\n  call add(tl, [2, 'x\\=', 'x sdfoij', 'x'])\n  call add(tl, [2, 'x\\=', 'abc sfoij', '']) \" empty match is good\n  call add(tl, [2, 'x\\=', 'xxxxxxxxx c', 'x'])\n  call add(tl, [2, 'x\\?', 'x sdfoij', 'x'])\n  \" empty match is good\n  call add(tl, [2, 'x\\?', 'abc sfoij', ''])\n  call add(tl, [2, 'x\\?', 'xxxxxxxxxx c', 'x'])\n\n  call add(tl, [2, 'a\\{0,0}', 'abcdfdoij', ''])\n  \" same thing as 'a?'\n  call add(tl, [2, 'a\\{0,1}', 'asiubid axxxaaa', 'a'])\n  \" same thing as 'a\\{0,1}'\n  call add(tl, [2, 'a\\{1,0}', 'asiubid axxxaaa', 'a'])\n  call add(tl, [2, 'a\\{3,6}', 'aa siofuh'])\n  call add(tl, [2, 'a\\{3,6}', 'aaaaa asfoij afaa', 'aaaaa'])\n  call add(tl, [2, 'a\\{3,6}', 'aaaaaaaa', 'aaaaaa'])\n  call add(tl, [2, 'a\\{0}', 'asoiuj', ''])\n  call add(tl, [2, 'a\\{2}', 'aaaa', 'aa'])\n  call add(tl, [2, 'a\\{2}', 'iuash fiusahfliusah fiushfilushfi uhsaifuh askfj nasfvius afg aaaa sfiuhuhiushf', 'aa'])\n  call add(tl, [2, 'a\\{2}', 'abcdefghijklmnopqrestuvwxyz1234567890'])\n  \" same thing as 'a*'\n  call add(tl, [2, 'a\\{0,}', 'oij sdigfusnf', ''])\n  call add(tl, [2, 'a\\{0,}', 'aaaaa aa', 'aaaaa'])\n  call add(tl, [2, 'a\\{2,}', 'sdfiougjdsafg'])\n  call add(tl, [2, 'a\\{2,}', 'aaaaasfoij ', 'aaaaa'])\n  call add(tl, [2, 'a\\{5,}', 'xxaaaaxxx '])\n  call add(tl, [2, 'a\\{5,}', 'xxaaaaaxxx ', 'aaaaa'])\n  call add(tl, [2, 'a\\{,0}', 'oidfguih iuhi hiu aaaa', ''])\n  call add(tl, [2, 'a\\{,5}', 'abcd', 'a'])\n  call add(tl, [2, 'a\\{,5}', 'aaaaaaaaaa', 'aaaaa'])\n  \" leading star as normal char when \\{} follows\n  call add(tl, [2, '^*\\{4,}$', '***'])\n  call add(tl, [2, '^*\\{4,}$', '****', '****'])\n  call add(tl, [2, '^*\\{4,}$', '*****', '*****'])\n  \" same thing as 'a*'\n  call add(tl, [2, 'a\\{}', 'bbbcddiuhfcd', ''])\n  call add(tl, [2, 'a\\{}', 'aaaaioudfh coisf jda', 'aaaa'])\n\n  call add(tl, [2, 'a\\{-0,0}', 'abcdfdoij', ''])\n  \" anti-greedy version of 'a?'\n  call add(tl, [2, 'a\\{-0,1}', 'asiubid axxxaaa', ''])\n  call add(tl, [2, 'a\\{-3,6}', 'aa siofuh'])\n  call add(tl, [2, 'a\\{-3,6}', 'aaaaa asfoij afaa', 'aaa'])\n  call add(tl, [2, 'a\\{-3,6}', 'aaaaaaaa', 'aaa'])\n  call add(tl, [2, 'a\\{-0}', 'asoiuj', ''])\n  call add(tl, [2, 'a\\{-2}', 'aaaa', 'aa'])\n  call add(tl, [2, 'a\\{-2}', 'abcdefghijklmnopqrestuvwxyz1234567890'])\n  call add(tl, [2, 'a\\{-0,}', 'oij sdigfusnf', ''])\n  call add(tl, [2, 'a\\{-0,}', 'aaaaa aa', ''])\n  call add(tl, [2, 'a\\{-2,}', 'sdfiougjdsafg'])\n  call add(tl, [2, 'a\\{-2,}', 'aaaaasfoij ', 'aa'])\n  call add(tl, [2, 'a\\{-,0}', 'oidfguih iuhi hiu aaaa', ''])\n  call add(tl, [2, 'a\\{-,5}', 'abcd', ''])\n  call add(tl, [2, 'a\\{-,5}', 'aaaaaaaaaa', ''])\n  \" anti-greedy version of 'a*'\n  call add(tl, [2, 'a\\{-}', 'bbbcddiuhfcd', ''])\n  call add(tl, [2, 'a\\{-}', 'aaaaioudfh coisf jda', ''])\n\n  \" Test groups of characters and submatches\n  call add(tl, [2, '\\(abc\\)*', 'abcabcabc', 'abcabcabc', 'abc'])\n  call add(tl, [2, '\\(ab\\)\\+', 'abababaaaaa', 'ababab', 'ab'])\n  call add(tl, [2, '\\(abaaaaa\\)*cd', 'cd', 'cd', ''])\n  call add(tl, [2, '\\(test1\\)\\? \\(test2\\)\\?', 'test1 test3', 'test1 ', 'test1', ''])\n  call add(tl, [2, '\\(test1\\)\\= \\(test2\\) \\(test4443\\)\\=', ' test2 test4443 yupiiiiiiiiiii', ' test2 test4443', '', 'test2', 'test4443'])\n  call add(tl, [2, '\\(\\(sub1\\) hello \\(sub 2\\)\\)', 'asterix sub1 hello sub 2 obelix', 'sub1 hello sub 2', 'sub1 hello sub 2', 'sub1', 'sub 2'])\n  call add(tl, [2, '\\(\\(\\(yyxxzz\\)\\)\\)', 'abcdddsfiusfyyzzxxyyxxzz', 'yyxxzz', 'yyxxzz', 'yyxxzz', 'yyxxzz'])\n  call add(tl, [2, '\\v((ab)+|c+)+', 'abcccaba', 'abcccab', 'ab', 'ab'])\n  call add(tl, [2, '\\v((ab)|c*)+', 'abcccaba', 'abcccab', '', 'ab'])\n  call add(tl, [2, '\\v(a(c*)+b)+', 'acbababaaa', 'acbabab', 'ab', ''])\n  call add(tl, [2, '\\v(a|b*)+', 'aaaa', 'aaaa', ''])\n  call add(tl, [2, '\\p*', 'a\u00e1 \t', 'a\u00e1 '])\n\n  \" Test greedy-ness and lazy-ness\n  call add(tl, [2, 'a\\{-2,7}','aaaaaaaaaaaaa', 'aa'])\n  call add(tl, [2, 'a\\{-2,7}x','aaaaaaaaax', 'aaaaaaax'])\n  call add(tl, [2, 'a\\{2,7}','aaaaaaaaaaaaaaaaaaaa', 'aaaaaaa'])\n  call add(tl, [2, 'a\\{2,7}x','aaaaaaaaax', 'aaaaaaax'])\n  call add(tl, [2, '\\vx(.{-,8})yz(.*)','xayxayzxayzxayz','xayxayzxayzxayz','ayxa','xayzxayz'])\n  call add(tl, [2, '\\vx(.*)yz(.*)','xayxayzxayzxayz','xayxayzxayzxayz', 'ayxayzxayzxa',''])\n  call add(tl, [2, '\\v(a{1,2}){-2,3}','aaaaaaa','aaaa','aa'])\n  call add(tl, [2, '\\v(a{-1,3})+', 'aa', 'aa', 'a'])\n  call add(tl, [2, '^\\s\\{-}\\zs\\( x\\|x$\\)', ' x', ' x', ' x'])\n  call add(tl, [2, '^\\s\\{-}\\zs\\(x\\| x$\\)', ' x', ' x', ' x'])\n  call add(tl, [2, '^\\s\\{-}\\ze\\(x\\| x$\\)', ' x', '', ' x'])\n  call add(tl, [2, '^\\(\\s\\{-}\\)\\(x\\| x$\\)', ' x', ' x', '', ' x'])\n\n  \" Test Character classes\n  call add(tl, [2, '\\d\\+e\\d\\d','test 10e23 fd','10e23'])\n\n  \" Test collections and character range []\n  call add(tl, [2, '\\v[a]', 'abcd', 'a'])\n  call add(tl, [2, 'a[bcd]', 'abcd', 'ab'])\n  call add(tl, [2, 'a[b-d]', 'acbd', 'ac'])\n  call add(tl, [2, '[a-d][e-f][x-x]d', 'cexdxx', 'cexd'])\n  call add(tl, [2, '\\v[[:alpha:]]+', 'abcdefghijklmnopqrstuvwxyz6','abcdefghijklmnopqrstuvwxyz'])\n  call add(tl, [2, '[[:alpha:]\\+]', '6x8','x'])\n  call add(tl, [2, '[^abc]\\+','abcabcabc'])\n  call add(tl, [2, '[^abc]','defghiasijvoinasoiunbvb','d'])\n  call add(tl, [2, '[^abc]\\+','ddddddda','ddddddd'])\n  call add(tl, [2, '[^a-d]\\+','aaaAAAZIHFNCddd','AAAZIHFNC'])\n  call add(tl, [2, '[a-f]*','iiiiiiii',''])\n  call add(tl, [2, '[a-f]*','abcdefgh','abcdef'])\n  call add(tl, [2, '[^a-f]\\+','abcdefgh','gh'])\n  call add(tl, [2, '[a-c]\\{-3,6}','abcabc','abc'])\n  call add(tl, [2, '[^[:alpha:]]\\+','abcccadfoij7787ysf287yrnccdu','7787'])\n  call add(tl, [2, '[-a]', '-', '-'])\n  call add(tl, [2, '[a-]', '-', '-'])\n  call add(tl, [2, '[a-f]*\\c','ABCDEFGH','ABCDEF'])\n  call add(tl, [2, '[abc][xyz]\\c','-af-AF-BY--','BY'])\n  \" filename regexp\n  call add(tl, [2, '[-./[:alnum:]_~]\\+', 'log13.file', 'log13.file'])\n  \" special chars\n  call add(tl, [2, '[\\]\\^\\-\\\\]\\+', '\\^\\\\\\-\\---^', '\\^\\\\\\-\\---^'])\n  \" collation elem\n  call add(tl, [2, '[[.a.]]\\+', 'aa', 'aa'])\n  \" middle of regexp\n  call add(tl, [2, 'abc[0-9]*ddd', 'siuhabc ii'])\n  call add(tl, [2, 'abc[0-9]*ddd', 'adf abc44482ddd oijs', 'abc44482ddd'])\n  call add(tl, [2, '\\_[0-9]\\+', 'asfi9888u', '9888'])\n  call add(tl, [2, '[0-9\\n]\\+', 'asfi9888u', '9888'])\n  call add(tl, [2, '\\_[0-9]\\+', \"asfi\\n9888u\", \"\\n9888\"])\n  call add(tl, [2, '\\_f', \"  \\na \", \"\\n\"])\n  call add(tl, [2, '\\_f\\+', \"  \\na \", \"\\na\"])\n  call add(tl, [2, '[0-9A-Za-z-_.]\\+', \" @0_a.A-{ \", \"0_a.A-\"])\n\n  \" Test start/end of line, start/end of file\n  call add(tl, [2, '^a.', \"a_\\nb \", \"a_\"])\n  call add(tl, [2, '^a.', \"b a \\na_\"])\n  call add(tl, [2, '.a$', \" a\\n \"])\n  call add(tl, [2, '.a$', \" a b\\n_a\", \"_a\"])\n  call add(tl, [2, '\\%^a.', \"a a\\na\", \"a \"])\n  call add(tl, [2, '\\%^a', \" a \\na \"])\n  call add(tl, [2, '.a\\%$', \" a\\n \"])\n  call add(tl, [2, '.a\\%$', \" a\\n_a\", \"_a\"])\n\n  \" Test recognition of character classes\n  call add(tl, [2, '[0-7]\\+', 'x0123456789x', '01234567'])\n  call add(tl, [2, '[^0-7]\\+', '0a;X+% 897', 'a;X+% 89'])\n  call add(tl, [2, '[0-9]\\+', 'x0123456789x', '0123456789'])\n  call add(tl, [2, '[^0-9]\\+', '0a;X+% 9', 'a;X+% '])\n  call add(tl, [2, '[0-9a-fA-F]\\+', 'x0189abcdefg', '0189abcdef'])\n  call add(tl, [2, '[^0-9A-Fa-f]\\+', '0189g;X+% ab', 'g;X+% '])\n  call add(tl, [2, '[a-z_A-Z0-9]\\+', ';+aso_SfOij ', 'aso_SfOij'])\n  call add(tl, [2, '[^a-z_A-Z0-9]\\+', 'aSo_;+% sfOij', ';+% '])\n  call add(tl, [2, '[a-z_A-Z]\\+', '0abyz_ABYZ;', 'abyz_ABYZ'])\n  call add(tl, [2, '[^a-z_A-Z]\\+', 'abAB_09;+% yzYZ', '09;+% '])\n  call add(tl, [2, '[a-z]\\+', '0abcxyz1', 'abcxyz'])\n  call add(tl, [2, '[a-z]\\+', 'AabxyzZ', 'abxyz'])\n  call add(tl, [2, '[^a-z]\\+', 'a;X09+% x', ';X09+% '])\n  call add(tl, [2, '[^a-z]\\+', 'abX0;%yz', 'X0;%'])\n  call add(tl, [2, '[a-zA-Z]\\+', '0abABxzXZ9', 'abABxzXZ'])\n  call add(tl, [2, '[^a-zA-Z]\\+', 'ab09_;+ XZ', '09_;+ '])\n  call add(tl, [2, '[A-Z]\\+', 'aABXYZz', 'ABXYZ'])\n  call add(tl, [2, '[^A-Z]\\+', 'ABx0;%YZ', 'x0;%'])\n  call add(tl, [2, '[a-z]\\+\\c', '0abxyzABXYZ;', 'abxyzABXYZ'])\n  call add(tl, [2, '[A-Z]\\+\\c', '0abABxzXZ9', 'abABxzXZ'])\n  call add(tl, [2, '\\c[^a-z]\\+', 'ab09_;+ XZ', '09_;+ '])\n  call add(tl, [2, '\\c[^A-Z]\\+', 'ab09_;+ XZ', '09_;+ '])\n  call add(tl, [2, '\\C[^A-Z]\\+', 'ABCOIJDEOIFNSD jsfoij sa', ' jsfoij sa'])\n\n  \" Tests for \\z features\n  \" match ends at \\ze\n  call add(tl, [2, 'xx \\ze test', 'xx '])\n  call add(tl, [2, 'abc\\zeend', 'oij abcend', 'abc'])\n  call add(tl, [2, 'aa\\zebb\\|aaxx', ' aabb ', 'aa'])\n  call add(tl, [2, 'aa\\zebb\\|aaxx', ' aaxx ', 'aaxx'])\n  call add(tl, [2, 'aabb\\|aa\\zebb', ' aabb ', 'aabb'])\n  call add(tl, [2, 'aa\\zebb\\|aaebb', ' aabb ', 'aa'])\n  \" match starts at \\zs\n  call add(tl, [2, 'abc\\zsdd', 'ddabcddxyzt', 'dd'])\n  call add(tl, [2, 'aa \\zsax', ' ax'])\n  call add(tl, [2, 'abc \\zsmatch\\ze abc', 'abc abc abc match abc abc', 'match'])\n  call add(tl, [2, '\\v(a \\zsif .*){2}', 'a if then a if last', 'if last', 'a if last'])\n  call add(tl, [2, '\\>\\zs.', 'aword. ', '.'])\n  call add(tl, [2, '\\s\\+\\ze\\[/\\|\\s\\zs\\s\\+', 'is   [a t', '  '])\n\n  \" Tests for \\@= and \\& features\n  call add(tl, [2, 'abc\\@=', 'abc', 'ab'])\n  call add(tl, [2, 'abc\\@=cd', 'abcd', 'abcd'])\n  call add(tl, [2, 'abc\\@=', 'ababc', 'ab'])\n  \" will never match, no matter the input text\n  call add(tl, [2, 'abcd\\@=e', 'abcd'])\n  \" will never match\n  call add(tl, [2, 'abcd\\@=e', 'any text in here ... '])\n  call add(tl, [2, '\\v(abc)@=..', 'xabcd', 'ab', 'abc'])\n  call add(tl, [2, '\\(.*John\\)\\@=.*Bob', 'here is John, and here is B'])\n  call add(tl, [2, '\\(John.*\\)\\@=.*Bob', 'John is Bobs friend', 'John is Bob', 'John is Bobs friend'])\n  call add(tl, [2, '\\<\\S\\+\\())\\)\\@=', '$((i=i+1))', 'i=i+1', '))'])\n  call add(tl, [2, '.*John\\&.*Bob', 'here is John, and here is B'])\n  call add(tl, [2, '.*John\\&.*Bob', 'John is Bobs friend', 'John is Bob'])\n  call add(tl, [2, '\\v(test1)@=.*yep', 'this is a test1, yep it is', 'test1, yep', 'test1'])\n  call add(tl, [2, 'foo\\(bar\\)\\@!', 'foobar'])\n  call add(tl, [2, 'foo\\(bar\\)\\@!', 'foo bar', 'foo'])\n  call add(tl, [2, 'if \\(\\(then\\)\\@!.\\)*$', ' if then else'])\n  call add(tl, [2, 'if \\(\\(then\\)\\@!.\\)*$', ' if else ', 'if else ', ' '])\n  call add(tl, [2, '\\(foo\\)\\@!bar', 'foobar', 'bar'])\n  call add(tl, [2, '\\(foo\\)\\@!...bar', 'foobar'])\n  call add(tl, [2, '^\\%(.*bar\\)\\@!.*\\zsfoo', ' bar foo '])\n  call add(tl, [2, '^\\%(.*bar\\)\\@!.*\\zsfoo', ' foo bar '])\n  call add(tl, [2, '^\\%(.*bar\\)\\@!.*\\zsfoo', ' foo xxx ', 'foo'])\n  call add(tl, [2, '[ ]\\@!\\p\\%([ ]\\@!\\p\\)*:', 'implicit mappings:', 'mappings:'])\n  call add(tl, [2, '[ ]\\@!\\p\\([ ]\\@!\\p\\)*:', 'implicit mappings:', 'mappings:', 's'])\n  call add(tl, [2, 'm\\k\\+_\\@=\\%(_\\@!\\k\\)\\@<=\\k\\+e', 'mx__xe', 'mx__xe'])\n  call add(tl, [2, '\\%(\\U\\@<=S\\k*\\|S\\l\\)R', 'SuR', 'SuR'])\n\n  \" Combining different tests and features\n  call add(tl, [2, '[[:alpha:]]\\{-2,6}', '787abcdiuhsasiuhb4', 'ab'])\n  call add(tl, [2, '', 'abcd', ''])\n  call add(tl, [2, '\\v(())', 'any possible text', ''])\n  call add(tl, [2, '\\v%(ab(xyz)c)', '   abxyzc ', 'abxyzc', 'xyz'])\n  call add(tl, [2, '\\v(test|)empty', 'tesempty', 'empty', ''])\n  call add(tl, [2, '\\v(a|aa)(a|aa)', 'aaa', 'aa', 'a', 'a'])\n\n  \" \\%u and friends\n  call add(tl, [2, '\\%d32', 'yes no', ' '])\n  call add(tl, [2, '\\%o40', 'yes no', ' '])\n  call add(tl, [2, '\\%x20', 'yes no', ' '])\n  call add(tl, [2, '\\%u0020', 'yes no', ' '])\n  call add(tl, [2, '\\%U00000020', 'yes no', ' '])\n  call add(tl, [2, '\\%d0', \"yes\\x0ano\", \"\\x0a\"])\n\n  \"\" \\%[abc]\n  call add(tl, [2, 'foo\\%[bar]', 'fobar'])\n  call add(tl, [2, 'foo\\%[bar]', 'foobar', 'foobar'])\n  call add(tl, [2, 'foo\\%[bar]', 'fooxx', 'foo'])\n  call add(tl, [2, 'foo\\%[bar]', 'foobxx', 'foob'])\n  call add(tl, [2, 'foo\\%[bar]', 'foobaxx', 'fooba'])\n  call add(tl, [2, 'foo\\%[bar]', 'foobarxx', 'foobar'])\n  call add(tl, [2, 'foo\\%[bar]x', 'foobxx', 'foobx'])\n  call add(tl, [2, 'foo\\%[bar]x', 'foobarxx', 'foobarx'])\n  call add(tl, [2, '\\%[bar]x', 'barxx', 'barx'])\n  call add(tl, [2, '\\%[bar]x', 'bxx', 'bx'])\n  call add(tl, [2, '\\%[bar]x', 'xxx', 'x'])\n  call add(tl, [2, 'b\\%[[ao]r]', 'bar bor', 'bar'])\n  call add(tl, [2, 'b\\%[[]]r]', 'b]r bor', 'b]r'])\n  call add(tl, [2, '@\\%[\\w\\-]*', '<http://john.net/pandoc/>[@pandoc]', '@pandoc'])\n\n  \" Alternatives, must use first longest match\n  call add(tl, [2, 'goo\\|go', 'google', 'goo'])\n  call add(tl, [2, '\\<goo\\|\\<go', 'google', 'goo'])\n  call add(tl, [2, '\\<goo\\|go', 'google', 'goo'])\n\n  \" Back references\n  call add(tl, [2, '\\(\\i\\+\\) \\1', ' abc abc', 'abc abc', 'abc'])\n  call add(tl, [2, '\\(\\i\\+\\) \\1', 'xgoo goox', 'goo goo', 'goo'])\n  call add(tl, [2, '\\(a\\)\\(b\\)\\(c\\)\\(dd\\)\\(e\\)\\(f\\)\\(g\\)\\(h\\)\\(i\\)\\1\\2\\3\\4\\5\\6\\7\\8\\9', 'xabcddefghiabcddefghix', 'abcddefghiabcddefghi', 'a', 'b', 'c', 'dd', 'e', 'f', 'g', 'h', 'i'])\n  call add(tl, [2, '\\(\\d*\\)a \\1b', ' a b ', 'a b', ''])\n  call add(tl, [2, '^.\\(.\\).\\_..\\1.', \"aaa\\naaa\\nb\", \"aaa\\naaa\", 'a'])\n  call add(tl, [2, '^.*\\.\\(.*\\)/.\\+\\(\\1\\)\\@<!$', 'foo.bat/foo.com', 'foo.bat/foo.com', 'bat'])\n  call add(tl, [2, '^.*\\.\\(.*\\)/.\\+\\(\\1\\)\\@<!$', 'foo.bat/foo.bat'])\n  call add(tl, [2, '^.*\\.\\(.*\\)/.\\+\\(\\1\\)\\@<=$', 'foo.bat/foo.bat', 'foo.bat/foo.bat', 'bat', 'bat'])\n  call add(tl, [2, '\\\\\\@<!\\${\\(\\d\\+\\%(:.\\{-}\\)\\?\\\\\\@<!\\)}', '2013-06-27${0}', '${0}', '0'])\n  call add(tl, [2, '^\\(a*\\)\\1$', 'aaaaaaaa', 'aaaaaaaa', 'aaaa'])\n  call add(tl, [2, '^\\(a\\{-2,}\\)\\1\\+$', 'aaaaaaaaa', 'aaaaaaaaa', 'aaa'])\n\n  \" Look-behind with limit\n  call add(tl, [2, '<\\@<=span.', 'xxspanxx<spanyyy', 'spany'])\n  call add(tl, [2, '<\\@1<=span.', 'xxspanxx<spanyyy', 'spany'])\n  call add(tl, [2, '<\\@2<=span.', 'xxspanxx<spanyyy', 'spany'])\n  call add(tl, [2, '\\(<<\\)\\@<=span.', 'xxspanxxxx<spanxx<<spanyyy', 'spany', '<<'])\n  call add(tl, [2, '\\(<<\\)\\@1<=span.', 'xxspanxxxx<spanxx<<spanyyy'])\n  call add(tl, [2, '\\(<<\\)\\@2<=span.', 'xxspanxxxx<spanxx<<spanyyy', 'spany', '<<'])\n  call add(tl, [2, '\\(foo\\)\\@<!bar.', 'xx foobar1 xbar2 xx', 'bar2'])\n\n  \" look-behind match in front of a zero-width item\n  call add(tl, [2, '\\v\\C%(<Last Changed:\\s+)@<=.*$', '\" test header'])\n  call add(tl, [2, '\\v\\C%(<Last Changed:\\s+)@<=.*$', '\" Last Changed: 1970', '1970'])\n  call add(tl, [2, '\\(foo\\)\\@<=\\>', 'foobar'])\n  call add(tl, [2, '\\(foo\\)\\@<=\\>', 'barfoo', '', 'foo'])\n  call add(tl, [2, '\\(foo\\)\\@<=.*', 'foobar', 'bar', 'foo'])\n\n  \" complicated look-behind match\n  call add(tl, [2, '\\(r\\@<=\\|\\w\\@<!\\)\\/', 'x = /word/;', '/'])\n  call add(tl, [2, '^[a-z]\\+\\ze \\&\\(asdf\\)\\@<!', 'foo bar', 'foo'])\n\n  \"\" \\@>\n  call add(tl, [2, '\\(a*\\)\\@>a', 'aaaa'])\n  call add(tl, [2, '\\(a*\\)\\@>b', 'aaab', 'aaab', 'aaa'])\n  call add(tl, [2, '^\\(.\\{-}b\\)\\@>.', '  abcbd', '  abc', '  ab'])\n  call add(tl, [2, '\\(.\\{-}\\)\\(\\)\\@>$', 'abc', 'abc', 'abc', ''])\n  \" TODO: BT engine does not restore submatch after failure\n  call add(tl, [1, '\\(a*\\)\\@>a\\|a\\+', 'aaaa', 'aaaa'])\n\n  \" \"\\_\" prepended negated collection matches EOL\n  call add(tl, [2, '\\_[^8-9]\\+', \"asfi\\n9888\", \"asfi\\n\"])\n  call add(tl, [2, '\\_[^a]\\+', \"asfi\\n9888\", \"sfi\\n9888\"])\n\n  \" Requiring lots of states.\n  call add(tl, [2, '[0-9a-zA-Z]\\{8}-\\([0-9a-zA-Z]\\{4}-\\)\\{3}[0-9a-zA-Z]\\{12}', \" 12345678-1234-1234-1234-123456789012 \", \"12345678-1234-1234-1234-123456789012\", \"1234-\"])\n\n  \" Skip adding state twice\n  call add(tl, [2, '^\\%(\\%(^\\s*#\\s*if\\>\\|#\\s*if\\)\\)\\(\\%>1c.*$\\)\\@=', \"#if FOO\", \"#if\", ' FOO'])\n\n  \" Test \\%V atom\n  call add(tl, [2, '\\%>70vGesamt', 'Jean-Michel Charlier & Victor Hubinon\\Gesamtausgabe [Salleck]    Buck Danny {Jean-Michel Charlier & Victor Hubinon}\\Gesamtausgabe', 'Gesamt'])\n\n  \" Test for ignoring case and matching repeated characters\n  call add(tl, [2, '\\cb\\+', 'aAbBbBcC', 'bBbB'])\n\n  \" Run the tests\n  for t in tl\n    let re = t[0]\n    let pat = t[1]\n    let text = t[2]\n    let matchidx = 3\n    for engine in [0, 1, 2]\n      if engine == 2 && re == 0 || engine == 1 && re == 1\n        continue\n      endif\n      let &regexpengine = engine\n      try\n        let l = matchlist(text, pat)\n      catch\n        call assert_report('Error ' . engine . ': pat: \\\"' . pat\n              \\ . '\\\", text: \\\"' . text . '\\\", caused an exception: \\\"'\n              \\ . v:exception . '\\\"')\n      endtry\n      \" check the match itself\n      if len(l) == 0 && len(t) > matchidx\n        call assert_report('Error ' . engine . ': pat: \\\"' . pat\n              \\ . '\\\", text: \\\"' . text . '\\\", did not match, expected: \\\"'\n              \\ . t[matchidx] . '\\\"')\n      elseif len(l) > 0 && len(t) == matchidx\n        call assert_report('Error ' . engine . ': pat: \\\"' . pat\n              \\ . '\\\", text: \\\"' . text . '\\\", match: \\\"' . l[0]\n              \\ . '\\\", expected no match')\n      elseif len(t) > matchidx && l[0] != t[matchidx]\n        call assert_report('Error ' . engine . ': pat: \\\"' . pat\n              \\ . '\\\", text: \\\"' . text . '\\\", match: \\\"' . l[0]\n              \\ . '\\\", expected: \\\"' . t[matchidx] . '\\\"')\n      else\n        \" Test passed\n      endif\n\n      \" check all the nine submatches\n      if len(l) > 0\n        for i in range(1, 9)\n          if len(t) <= matchidx + i\n            let e = ''\n          else\n            let e = t[matchidx + i]\n          endif\n          if l[i] != e\n            call assert_report('Error ' . engine . ': pat: \\\"' . pat\n                  \\ . '\\\", text: \\\"' . text . '\\\", submatch ' . i . ': \\\"'\n                  \\ . l[i] . '\\\", expected: \\\"' . e . '\\\"')\n          endif\n        endfor\n        unlet i\n      endif\n    endfor\n  endfor\n\n  unlet t tl e l\nendfunc\n\n\" Tests for multi-line regexp patterns without multi-byte support.\nfunc Test_regexp_multiline_pat()\n  \" tl is a List of Lists with:\n  \"    regexp engines to test\n  \"       0 - test with 'regexpengine' values 0 and 1\n  \"       1 - test with 'regexpengine' values 0 and 2\n  \"       2 - test with 'regexpengine' values 0, 1 and 2\n  \"    regexp pattern\n  \"    List with text to test the pattern on\n  \"    List with the expected match\n  let tl = []\n\n  \" back references\n  call add(tl, [2, '^.\\(.\\).\\_..\\1.', ['aaa', 'aaa', 'b'], ['XX', 'b']])\n  call add(tl, [2, '\\v.*\\/(.*)\\n.*\\/\\1$', ['./Dir1/Dir2/zyxwvuts.txt', './Dir1/Dir2/abcdefgh.bat', '', './Dir1/Dir2/file1.txt', './OtherDir1/OtherDir2/file1.txt'], ['./Dir1/Dir2/zyxwvuts.txt', './Dir1/Dir2/abcdefgh.bat', '', 'XX']])\n\n  \" line breaks\n  call add(tl, [2, '\\S.*\\nx', ['abc', 'def', 'ghi', 'xjk', 'lmn'], ['abc', 'def', 'XXjk', 'lmn']])\n\n  \" Any single character or end-of-line\n  call add(tl, [2, '\\_.\\+', ['a', 'b', 'c'], ['XX']])\n  \" Any identifier or end-of-line\n  call add(tl, [2, '\\_i\\+', ['a', 'b', ';', '2'], ['XX;XX']])\n  \" Any identifier but excluding digits or end-of-line\n  call add(tl, [2, '\\_I\\+', ['a', 'b', ';', '2'], ['XX;XX2XX']])\n  \" Any keyword or end-of-line\n  call add(tl, [2, '\\_k\\+', ['a', 'b', '=', '2'], ['XX=XX']])\n  \" Any keyword but excluding digits or end-of-line\n  call add(tl, [2, '\\_K\\+', ['a', 'b', '=', '2'], ['XX=XX2XX']])\n  \" Any filename character or end-of-line\n  call add(tl, [2, '\\_f\\+', ['a', 'b', '.', '5'], ['XX']])\n  \" Any filename character but excluding digits or end-of-line\n  call add(tl, [2, '\\_F\\+', ['a', 'b', '.', '5'], ['XX5XX']])\n  \" Any printable character or end-of-line\n  call add(tl, [2, '\\_p\\+', ['a', 'b', '=', '4'], ['XX']])\n  \" Any printable character excluding digits or end-of-line\n  call add(tl, [2, '\\_P\\+', ['a', 'b', '=', '4'], ['XX4XX']])\n  \" Any whitespace character or end-of-line\n  call add(tl, [2, '\\_s\\+', [' ', ' ', 'a', 'b'], ['XXaXXbXX']])\n  \" Any non-whitespace character or end-of-line\n  call add(tl, [2, '\\_S\\+', [' ', ' ', 'a', 'b'], [' XX XX']])\n  \" Any decimal digit or end-of-line\n  call add(tl, [2, '\\_d\\+', ['1', 'a', '2', 'b', '3'], ['XXaXXbXX']])\n  \" Any non-decimal digit or end-of-line\n  call add(tl, [2, '\\_D\\+', ['1', 'a', '2', 'b', '3'], ['1XX2XX3XX']])\n  \" Any hexadecimal digit or end-of-line\n  call add(tl, [2, '\\_x\\+', ['1', 'a', 'g', '9', '8'], ['XXgXX']])\n  \" Any non-hexadecimal digit or end-of-line\n  call add(tl, [2, '\\_X\\+', ['1', 'a', 'g', '9', '8'], ['1XXaXX9XX8XX']])\n  \" Any octal digit or end-of-line\n  call add(tl, [2, '\\_o\\+', ['0', '7', '8', '9', '0'], ['XX8XX9XX']])\n  \" Any non-octal digit or end-of-line\n  call add(tl, [2, '\\_O\\+', ['0', '7', '8', '9', '0'], ['0XX7XX0XX']])\n  \" Any word character or end-of-line\n  call add(tl, [2, '\\_w\\+', ['A', 'B', '=', 'C', 'D'], ['XX=XX']])\n  \" Any non-word character or end-of-line\n  call add(tl, [2, '\\_W\\+', ['A', 'B', '=', 'C', 'D'], ['AXXBXXCXXDXX']])\n  \" Any head-of-word character or end-of-line\n  call add(tl, [2, '\\_h\\+', ['a', '1', 'b', '2', 'c'], ['XX1XX2XX']])\n  \" Any non-head-of-word character or end-of-line\n  call add(tl, [2, '\\_H\\+', ['a', '1', 'b', '2', 'c'], ['aXXbXXcXX']])\n  \" Any alphabetic character or end-of-line\n  call add(tl, [2, '\\_a\\+', ['a', '1', 'b', '2', 'c'], ['XX1XX2XX']])\n  \" Any non-alphabetic character or end-of-line\n  call add(tl, [2, '\\_A\\+', ['a', '1', 'b', '2', 'c'], ['aXXbXXcXX']])\n  \" Any lowercase character or end-of-line\n  call add(tl, [2, '\\_l\\+', ['a', 'A', 'b', 'B'], ['XXAXXBXX']])\n  \" Any non-lowercase character or end-of-line\n  call add(tl, [2, '\\_L\\+', ['a', 'A', 'b', 'B'], ['aXXbXX']])\n  \" Any uppercase character or end-of-line\n  call add(tl, [2, '\\_u\\+', ['a', 'A', 'b', 'B'], ['aXXbXX']])\n  \" Any non-uppercase character or end-of-line\n  call add(tl, [2, '\\_U\\+', ['a', 'A', 'b', 'B'], ['XXAXXBXX']])\n  \" Collection or end-of-line\n  call add(tl, [2, '\\_[a-z]\\+', ['a', 'A', 'b', 'B'], ['XXAXXBXX']])\n  \" start of line anywhere in the text\n  call add(tl, [2, 'one\\zs\\_s*\\_^\\zetwo',\n        \\ ['', 'one', ' two', 'one', '', 'two'],\n        \\ ['', 'one', ' two', 'oneXXtwo']])\n  \" end of line anywhere in the text\n  call add(tl, [2, 'one\\zs\\_$\\_s*two',\n        \\ ['', 'one', ' two', 'one', '', 'two'], ['', 'oneXX', 'oneXX']])\n\n  \" Check that \\_[0-9] matching EOL does not break a following \\>\n  call add(tl, [2, '\\<\\(\\(25\\_[0-5]\\|2\\_[0-4]\\_[0-9]\\|\\_[01]\\?\\_[0-9]\\_[0-9]\\?\\)\\.\\)\\{3\\}\\(25\\_[0-5]\\|2\\_[0-4]\\_[0-9]\\|\\_[01]\\?\\_[0-9]\\_[0-9]\\?\\)\\>', ['', 'localnet/192.168.0.1', ''], ['', 'localnet/XX', '']])\n\n  \" Check a pattern with a line break and ^ and $\n  call add(tl, [2, 'a\\n^b$\\n^c', ['a', 'b', 'c'], ['XX']])\n\n  call add(tl, [2, '\\(^.\\+\\n\\)\\1', [' dog', ' dog', 'asdf'], ['XXasdf']])\n\n  \" Run the multi-line tests\n  for t in tl\n    let re = t[0]\n    let pat = t[1]\n    let before = t[2]\n    let after = t[3]\n    for engine in [0, 1, 2]\n      if engine == 2 && re == 0 || engine == 1 && re == 1\n        continue\n      endif\n      let &regexpengine = engine\n      new\n      call setline(1, before)\n      exe '%s/' . pat . '/XX/'\n      let result = getline(1, '$')\n      q!\n      if result != after\n        call assert_report('Error: pat: \\\"' . pat . '\\\", text: \\\"'\n              \\ . string(before) . '\\\", expected: \\\"' . string(after)\n              \\ . '\\\", got: \\\"' . string(result) . '\\\"')\n      else\n        \" Test passed\n      endif\n    endfor\n  endfor\n  unlet t tl\nendfunc\n\n\" Check that using a pattern on two lines doesn't get messed up by using\n\" matchstr() with \\ze in between.\nfunc Test_matchstr_with_ze()\n  new\n  call append(0, ['Substitute here:', '<T=\"\">Ta 5</Title>',\n        \\ '<T=\"\">Ac 7</Title>'])\n  call cursor(1, 1)\n  set re=0\n\n  .+1,.+2s/\"\"/\\='\"' . matchstr(getline(\".\"), '\\d\\+\\ze<') . '\"'\n  call assert_equal(['Substitute here:', '<T=\"5\">Ta 5</Title>',\n        \\ '<T=\"7\">Ac 7</Title>', ''], getline(1, '$'))\n\n  bwipe!\nendfunc\n\n\" Check a pattern with a look beind crossing a line boundary\nfunc Test_lookbehind_across_line()\n  new\n  call append(0, ['Behind:', 'asdfasd<yyy', 'xxstart1', 'asdfasd<yy',\n        \\ 'xxxstart2', 'asdfasd<yy', 'xxstart3'])\n  call cursor(1, 1)\n  call search('\\(<\\_[xy]\\+\\)\\@3<=start')\n  call assert_equal([0, 7, 3, 0], getpos('.'))\n  bwipe!\nendfunc\n\n\" Test for the \\%V atom (match inside the visual area)\nfunc Regex_Match_Visual_Area()\n  call append(0, ['Visual:', 'thexe the thexethe', 'andaxand andaxand',\n        \\ 'oooxofor foroxooo', 'oooxofor foroxooo'])\n  call cursor(1, 1)\n  exe \"normal jfxvfx:s/\\\\%Ve/E/g\\<CR>\"\n  exe \"normal jV:s/\\\\%Va/A/g\\<CR>\"\n  exe \"normal jfx\\<C-V>fxj:s/\\\\%Vo/O/g\\<CR>\"\n  call assert_equal(['Visual:', 'thexE thE thExethe', 'AndAxAnd AndAxAnd',\n        \\ 'oooxOfOr fOrOxooo', 'oooxOfOr fOrOxooo', ''], getline(1, '$'))\n  %d\nendfunc\n\n\" Check matching Visual area\nfunc Test_matching_visual_area()\n  new\n  set regexpengine=1\n  call Regex_Match_Visual_Area()\n  set regexpengine=2\n  call Regex_Match_Visual_Area()\n  set regexpengine&\n  bwipe!\nendfunc\n\n\" Check matching marks\nfunc Regex_Mark()\n  call append(0, ['', '', '', 'Marks:', 'asdfSasdfsadfEasdf', 'asdfSas',\n        \\ 'dfsadfEasdf', '', '', '', '', ''])\n  call cursor(4, 1)\n  exe \"normal jfSmsfEme:.-4,.+6s/.\\\\%>'s.*\\\\%<'e../here/\\<CR>\"\n  exe \"normal jfSmsj0fEme:.-4,.+6s/.\\\\%>'s\\\\_.*\\\\%<'e../again/\\<CR>\"\n  call assert_equal(['', '', '', 'Marks:', 'asdfhereasdf', 'asdfagainasdf',\n        \\ '', '', '', '', '', ''], getline(1, '$'))\n  %d\nendfunc\n\nfunc Test_matching_marks()\n  new\n  set regexpengine=1\n  call Regex_Mark()\n  set regexpengine=2\n  call Regex_Mark()\n  bwipe!\nendfunc\n\n\" Check patterns matching cursor position.\nfunc s:curpos_test()\n  new\n  call setline(1, ['ffooooo', 'boboooo', 'zoooooo', 'koooooo', 'moooooo',\n        \\ \"\\t\\t\\tfoo\", 'abababababababfoo', 'bababababababafoo', '********_',\n        \\ '        xxxxxxxxxxxx    xxxx xxxxxx xxxxxxx x xxxxxxxxx xx xxxxxx xxxxxx xxxxx xxxxxxx xx xxxx xxxxxxxx xxxx xxxxxxxxxxx xxx xxxxxxx xxxxxxxxx xx xxxxxx xx xxxxxxx xxxxxxxxxxxxxxxx xxxxxxxxx  xxx xxxxxxxx xxxxxxxxx xxxx xxx xxxx xxx xxx xxxxx xxxxxxxxxxxx xxxx xxxxxxxxx xxxxxxxxxxx xx xxxxx xxx xxxxxxxx xxxxxx xxx xxx xxxxxxxxx xxxxxxx x xxxxxxxxx xx xxxxxx xxxxxxx  xxxxxxxxxxxxxxxxxx xxxxxxx xxxxxxx xxx xxx xxxxxxxx xxxxxxx  xxxx xxx xxxxxx xxxxx xxxxx xx xxxxxx xxxxxxx xxx xxxxxxxxxxxx xxxx xxxxxxxxx xxxxxx xxxxxx xxxxx xxx xxxxxxx xxxxxxxxxxxxxxxx xxxxxxxxx  xxxxxxxxxx xxxx xx xxxxxxxx xxx xxxxxxxxxxx xxxxx'])\n  call setpos('.', [0, 1, 0, 0])\n  s/\\%>3c.//g\n  call setpos('.', [0, 2, 4, 0])\n  s/\\%#.*$//g\n  call setpos('.', [0, 3, 0, 0])\n  s/\\%<3c./_/g\n  %s/\\%4l\\%>5c./_/g\n  %s/\\%6l\\%>25v./_/g\n  %s/\\%>6l\\%3c./!/g\n  %s/\\%>7l\\%12c./?/g\n  %s/\\%>7l\\%<9l\\%>5v\\%<8v./#/g\n  $s/\\%(|\\u.*\\)\\@<=[^|\\t]\\+$//ge\n  call assert_equal(['ffo', 'bob', '__ooooo', 'koooo__', 'moooooo',\n        \\ '\t\t\tf__', 'ab!babababababfoo',\n        \\ 'ba!ab##abab?bafoo', '**!*****_',\n        \\ '  !     xxx?xxxxxxxx    xxxx xxxxxx xxxxxxx x xxxxxxxxx xx xxxxxx xxxxxx xxxxx xxxxxxx xx xxxx xxxxxxxx xxxx xxxxxxxxxxx xxx xxxxxxx xxxxxxxxx xx xxxxxx xx xxxxxxx xxxxxxxxxxxxxxxx xxxxxxxxx  xxx xxxxxxxx xxxxxxxxx xxxx xxx xxxx xxx xxx xxxxx xxxxxxxxxxxx xxxx xxxxxxxxx xxxxxxxxxxx xx xxxxx xxx xxxxxxxx xxxxxx xxx xxx xxxxxxxxx xxxxxxx x xxxxxxxxx xx xxxxxx xxxxxxx  xxxxxxxxxxxxxxxxxx xxxxxxx xxxxxxx xxx xxx xxxxxxxx xxxxxxx  xxxx xxx xxxxxx xxxxx xxxxx xx xxxxxx xxxxxxx xxx xxxxxxxxxxxx xxxx xxxxxxxxx xxxxxx xxxxxx xxxxx xxx xxxxxxx xxxxxxxxxxxxxxxx xxxxxxxxx  xxxxxxxxxx xxxx xx xxxxxxxx xxx xxxxxxxxxxx xxxxx'],\n        \\ getline(1, '$'))\n  bwipe!\nendfunc\n\nfunc Test_matching_curpos()\n  set re=0\n  call s:curpos_test()\n  set re=1\n  call s:curpos_test()\n  set re=2\n  call s:curpos_test()\n  set re&\nendfunc\n\n\" Test for matching the start and end of a buffer\nfunc Regex_start_end_buffer()\n  call setline(1, repeat(['vim edit'], 20))\n  /\\%^\n  call assert_equal([0, 1, 1, 0], getpos('.'))\n  exe \"normal 50%/\\\\%^..\\<CR>\"\n  call assert_equal([0, 1, 1, 0], getpos('.'))\n  exe \"normal 50%/\\\\%$\\<CR>\"\n  call assert_equal([0, 20, 8, 0], getpos('.'))\n  exe \"normal 6gg/..\\\\%$\\<CR>\"\n  call assert_equal([0, 20, 7, 0], getpos('.'))\n  %d\nendfunc\n\nfunc Test_start_end_of_buffer_match()\n  new\n  set regexpengine=1\n  call Regex_start_end_buffer()\n  set regexpengine=2\n  call Regex_start_end_buffer()\n  bwipe!\nendfunc\n\nfunc Test_ze_before_zs()\n  call assert_equal('', matchstr(' ', '\\%#=1\\ze \\zs'))\n  call assert_equal('', matchstr(' ', '\\%#=2\\ze \\zs'))\n  call assert_equal(repeat([''], 10), matchlist(' ', '\\%#=1\\ze \\zs'))\n  call assert_equal(repeat([''], 10), matchlist(' ', '\\%#=2\\ze \\zs'))\nendfunc\n\n\" Check for detecting error\nfunc Test_regexp_error()\n  call assert_fails(\"call matchlist('x x', '\\\\%#=1 \\\\zs*')\", 'E888:')\n  call assert_fails(\"call matchlist('x x', '\\\\%#=1 \\\\ze*')\", 'E888:')\n  call assert_fails(\"call matchlist('x x', '\\\\%#=2 \\\\zs*')\", 'E888:')\n  call assert_fails(\"call matchlist('x x', '\\\\%#=2 \\\\ze*')\", 'E888:')\n  call assert_fails(\"call matchstr('abcd', '\\\\%o841\\\\%o142')\", 'E678:')\n  call assert_fails(\"call matchstr('abcd', '\\\\%#=2\\\\%2147483647c')\", 'E951:')\n  call assert_fails(\"call matchstr('abcd', '\\\\%#=2\\\\%2147483647l')\", 'E951:')\n  call assert_fails(\"call matchstr('abcd', '\\\\%#=2\\\\%2147483647v')\", 'E951:')\n  call assert_fails('exe \"normal /\\\\%#=1\\\\%[x\\\\%[x]]\\<CR>\"',   'E369:')\n  call assert_fails('exe \"normal /\\\\%#=2\\\\%2147483647l\\<CR>\"', 'E951:')\n  call assert_fails('exe \"normal /\\\\%#=2\\\\%2147483647c\\<CR>\"', 'E951:')\n  call assert_fails('exe \"normal /\\\\%#=2\\\\%102261126v\\<CR>\"',  'E951:')\n  call assert_fails('exe \"normal /\\\\%#=2\\\\%2147483646l\\<CR>\"', 'E486:')\n  call assert_fails('exe \"normal /\\\\%#=2\\\\%2147483646c\\<CR>\"', 'E486:')\n  call assert_fails('exe \"normal /\\\\%#=2\\\\%102261125v\\<CR>\"',  'E486:')\n  call assert_equal('', matchstr('abcd', '\\%o181\\%o142'))\nendfunc\n\n\" Test for using the last substitute string pattern (~)\nfunc Test_regexp_last_subst_string()\n  new\n  s/bar/baz/e\n  call assert_equal(matchstr(\"foo\\nbaz\\nbar\", \"\\\\%#=1\\~\"), \"baz\")\n  call assert_equal(matchstr(\"foo\\nbaz\\nbar\", \"\\\\%#=2\\~\"), \"baz\")\n  close!\nendfunc\n\n\" Check patterns matching cursor position.\nfunc s:curpos_test2()\n  new\n  call setline(1, ['1', '2 foobar eins zwei drei vier f\u00fcnf sechse',\n        \\ '3 foobar eins zwei drei vier f\u00fcnf sechse',\n        \\ '4 foobar eins zwei drei vier f\u00fcnf sechse',\n        \\ '5\tfoobar eins zwei drei vier f\u00fcnf sechse',\n        \\ '6\tfoobar eins zwei drei vier f\u00fcnf sechse',\n        \\ '7\tfoobar eins zwei drei vier f\u00fcnf sechse'])\n  call setpos('.', [0, 2, 10, 0])\n  s/\\%.c.*//g\n  call setpos('.', [0, 3, 15, 0])\n  s/\\%.l.*//g\n  call setpos('.', [0, 5, 3, 0])\n  s/\\%.v.*/_/g\n  call assert_equal(['1',\n        \\ '2 foobar ',\n        \\ '',\n        \\ '4 foobar eins zwei drei vier f\u00fcnf sechse',\n        \\ '5\t_',\n        \\ '6\tfoobar eins zwei drei vier f\u00fcnf sechse',\n        \\ '7\tfoobar eins zwei drei vier f\u00fcnf sechse'],\n        \\ getline(1, '$'))\n  call assert_fails('call search(\"\\\\%.1l\")', 'E1204:')\n  call assert_fails('call search(\"\\\\%.1c\")', 'E1204:')\n  call assert_fails('call search(\"\\\\%.1v\")', 'E1204:')\n  bwipe!\nendfunc\n\n\" Check patterns matching before or after cursor position.\nfunc s:curpos_test3()\n  new\n  call setline(1, ['1', '2 foobar eins zwei drei vier f\u00fcnf sechse',\n        \\ '3 foobar eins zwei drei vier f\u00fcnf sechse',\n        \\ '4 foobar eins zwei drei vier f\u00fcnf sechse',\n        \\ '5\tfoobar eins zwei drei vier f\u00fcnf sechse',\n        \\ '6\tfoobar eins zwei drei vier f\u00fcnf sechse',\n        \\ '7\tfoobar eins zwei drei vier f\u00fcnf sechse'])\n  call setpos('.', [0, 2, 10, 0])\n  \" Note: This removes all columns, except for the column directly in front of\n  \" the cursor. Bug????\n  :s/^.*\\%<.c//\n  call setpos('.', [0, 3, 10, 0])\n  :s/\\%>.c.*$//\n  call setpos('.', [0, 5, 4, 0])\n  \" Note: This removes all columns, except for the column directly in front of\n  \" the cursor. Bug????\n  :s/^.*\\%<.v/_/\n  call setpos('.', [0, 6, 4, 0])\n  :s/\\%>.v.*$/_/\n  call assert_equal(['1',\n        \\ ' eins zwei drei vier f\u00fcnf sechse',\n        \\ '3 foobar e',\n        \\ '4 foobar eins zwei drei vier f\u00fcnf sechse',\n        \\ '_foobar eins zwei drei vier f\u00fcnf sechse',\n        \\ '6\tfo_',\n        \\ '7\tfoobar eins zwei drei vier f\u00fcnf sechse'],\n        \\ getline(1, '$'))\n  sil %d\n  call setline(1, ['1', '2 foobar eins zwei drei vier f\u00fcnf sechse',\n        \\ '3 foobar eins zwei drei vier f\u00fcnf sechse',\n        \\ '4 foobar eins zwei drei vier f\u00fcnf sechse',\n        \\ '5\tfoobar eins zwei drei vier f\u00fcnf sechse',\n        \\ '6\tfoobar eins zwei drei vier f\u00fcnf sechse',\n        \\ '7\tfoobar eins zwei drei vier f\u00fcnf sechse'])\n  call setpos('.', [0, 4, 4, 0])\n  %s/\\%<.l.*//\n  call setpos('.', [0, 5, 4, 0])\n  %s/\\%>.l.*//\n  call assert_equal(['', '', '',\n        \\ '4 foobar eins zwei drei vier f\u00fcnf sechse',\n        \\ '5\tfoobar eins zwei drei vier f\u00fcnf sechse',\n        \\ '', ''],\n        \\ getline(1, '$'))\n  bwipe!\nendfunc\n\n\" Test that matching below, at or after the\n\" cursor position work\nfunc Test_matching_pos()\n  for val in range(3)\n    exe \"set re=\" .. val\n    \" Match at cursor position\n    call s:curpos_test2()\n    \" Match before or after cursor position\n    call s:curpos_test3()\n  endfor\n  set re&\nendfunc\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n#ifdef FEAT_CINDENT\n\t\"+cindent\",\n#else\n\t\"-cindent\",\n#endif\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n#ifdef EBCDIC\n\t\"+ebcdic\",\n#else\n\t\"-ebcdic\",\n#endif\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n#ifdef FEAT_JUMPLIST\n\t\"+jumplist\",\n#else\n\t\"-jumplist\",\n#endif\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n#ifdef FEAT_LISP\n\t\"+lispindent\",\n#else\n\t\"-lispindent\",\n#endif\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n\t\"+mouse_gpm\",\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n#ifdef FEAT_SMARTINDENT\n\t\"+smartindent\",\n#else\n\t\"-smartindent\",\n#endif\n#ifdef FEAT_SODIUM\n\t\"+sodium\",\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n#ifdef FEAT_TAG_BINS\n\t\"+tag_binary\",\n#else\n\t\"-tag_binary\",\n#endif\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n#ifdef FEAT_TITLE\n\t\"+title\",\n#else\n\t\"-title\",\n#endif\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#ifdef MSWIN\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#else\n# ifdef HAVE_XPM\n\t\"+xpm\",\n# else\n\t\"-xpm\",\n# endif\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef USE_XSMP_INTERACT\n\t\"+xsmp_interact\",\n# else\n#  ifdef USE_XSMP\n\t\"+xsmp\",\n#  else\n\t\"-xsmp\",\n#  endif\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    3611,\n/**/\n    3610,\n/**/\n    3609,\n/**/\n    3608,\n/**/\n    3607,\n/**/\n    3606,\n/**/\n    3605,\n/**/\n    3604,\n/**/\n    3603,\n/**/\n    3602,\n/**/\n    3601,\n/**/\n    3600,\n/**/\n    3599,\n/**/\n    3598,\n/**/\n    3597,\n/**/\n    3596,\n/**/\n    3595,\n/**/\n    3594,\n/**/\n    3593,\n/**/\n    3592,\n/**/\n    3591,\n/**/\n    3590,\n/**/\n    3589,\n/**/\n    3588,\n/**/\n    3587,\n/**/\n    3586,\n/**/\n    3585,\n/**/\n    3584,\n/**/\n    3583,\n/**/\n    3582,\n/**/\n    3581,\n/**/\n    3580,\n/**/\n    3579,\n/**/\n    3578,\n/**/\n    3577,\n/**/\n    3576,\n/**/\n    3575,\n/**/\n    3574,\n/**/\n    3573,\n/**/\n    3572,\n/**/\n    3571,\n/**/\n    3570,\n/**/\n    3569,\n/**/\n    3568,\n/**/\n    3567,\n/**/\n    3566,\n/**/\n    3565,\n/**/\n    3564,\n/**/\n    3563,\n/**/\n    3562,\n/**/\n    3561,\n/**/\n    3560,\n/**/\n    3559,\n/**/\n    3558,\n/**/\n    3557,\n/**/\n    3556,\n/**/\n    3555,\n/**/\n    3554,\n/**/\n    3553,\n/**/\n    3552,\n/**/\n    3551,\n/**/\n    3550,\n/**/\n    3549,\n/**/\n    3548,\n/**/\n    3547,\n/**/\n    3546,\n/**/\n    3545,\n/**/\n    3544,\n/**/\n    3543,\n/**/\n    3542,\n/**/\n    3541,\n/**/\n    3540,\n/**/\n    3539,\n/**/\n    3538,\n/**/\n    3537,\n/**/\n    3536,\n/**/\n    3535,\n/**/\n    3534,\n/**/\n    3533,\n/**/\n    3532,\n/**/\n    3531,\n/**/\n    3530,\n/**/\n    3529,\n/**/\n    3528,\n/**/\n    3527,\n/**/\n    3526,\n/**/\n    3525,\n/**/\n    3524,\n/**/\n    3523,\n/**/\n    3522,\n/**/\n    3521,\n/**/\n    3520,\n/**/\n    3519,\n/**/\n    3518,\n/**/\n    3517,\n/**/\n    3516,\n/**/\n    3515,\n/**/\n    3514,\n/**/\n    3513,\n/**/\n    3512,\n/**/\n    3511,\n/**/\n    3510,\n/**/\n    3509,\n/**/\n    3508,\n/**/\n    3507,\n/**/\n    3506,\n/**/\n    3505,\n/**/\n    3504,\n/**/\n    3503,\n/**/\n    3502,\n/**/\n    3501,\n/**/\n    3500,\n/**/\n    3499,\n/**/\n    3498,\n/**/\n    3497,\n/**/\n    3496,\n/**/\n    3495,\n/**/\n    3494,\n/**/\n    3493,\n/**/\n    3492,\n/**/\n    3491,\n/**/\n    3490,\n/**/\n    3489,\n/**/\n    3488,\n/**/\n    3487,\n/**/\n    3486,\n/**/\n    3485,\n/**/\n    3484,\n/**/\n    3483,\n/**/\n    3482,\n/**/\n    3481,\n/**/\n    3480,\n/**/\n    3479,\n/**/\n    3478,\n/**/\n    3477,\n/**/\n    3476,\n/**/\n    3475,\n/**/\n    3474,\n/**/\n    3473,\n/**/\n    3472,\n/**/\n    3471,\n/**/\n    3470,\n/**/\n    3469,\n/**/\n    3468,\n/**/\n    3467,\n/**/\n    3466,\n/**/\n    3465,\n/**/\n    3464,\n/**/\n    3463,\n/**/\n    3462,\n/**/\n    3461,\n/**/\n    3460,\n/**/\n    3459,\n/**/\n    3458,\n/**/\n    3457,\n/**/\n    3456,\n/**/\n    3455,\n/**/\n    3454,\n/**/\n    3453,\n/**/\n    3452,\n/**/\n    3451,\n/**/\n    3450,\n/**/\n    3449,\n/**/\n    3448,\n/**/\n    3447,\n/**/\n    3446,\n/**/\n    3445,\n/**/\n    3444,\n/**/\n    3443,\n/**/\n    3442,\n/**/\n    3441,\n/**/\n    3440,\n/**/\n    3439,\n/**/\n    3438,\n/**/\n    3437,\n/**/\n    3436,\n/**/\n    3435,\n/**/\n    3434,\n/**/\n    3433,\n/**/\n    3432,\n/**/\n    3431,\n/**/\n    3430,\n/**/\n    3429,\n/**/\n    3428,\n/**/\n    3427,\n/**/\n    3426,\n/**/\n    3425,\n/**/\n    3424,\n/**/\n    3423,\n/**/\n    3422,\n/**/\n    3421,\n/**/\n    3420,\n/**/\n    3419,\n/**/\n    3418,\n/**/\n    3417,\n/**/\n    3416,\n/**/\n    3415,\n/**/\n    3414,\n/**/\n    3413,\n/**/\n    3412,\n/**/\n    3411,\n/**/\n    3410,\n/**/\n    3409,\n/**/\n    3408,\n/**/\n    3407,\n/**/\n    3406,\n/**/\n    3405,\n/**/\n    3404,\n/**/\n    3403,\n/**/\n    3402,\n/**/\n    3401,\n/**/\n    3400,\n/**/\n    3399,\n/**/\n    3398,\n/**/\n    3397,\n/**/\n    3396,\n/**/\n    3395,\n/**/\n    3394,\n/**/\n    3393,\n/**/\n    3392,\n/**/\n    3391,\n/**/\n    3390,\n/**/\n    3389,\n/**/\n    3388,\n/**/\n    3387,\n/**/\n    3386,\n/**/\n    3385,\n/**/\n    3384,\n/**/\n    3383,\n/**/\n    3382,\n/**/\n    3381,\n/**/\n    3380,\n/**/\n    3379,\n/**/\n    3378,\n/**/\n    3377,\n/**/\n    3376,\n/**/\n    3375,\n/**/\n    3374,\n/**/\n    3373,\n/**/\n    3372,\n/**/\n    3371,\n/**/\n    3370,\n/**/\n    3369,\n/**/\n    3368,\n/**/\n    3367,\n/**/\n    3366,\n/**/\n    3365,\n/**/\n    3364,\n/**/\n    3363,\n/**/\n    3362,\n/**/\n    3361,\n/**/\n    3360,\n/**/\n    3359,\n/**/\n    3358,\n/**/\n    3357,\n/**/\n    3356,\n/**/\n    3355,\n/**/\n    3354,\n/**/\n    3353,\n/**/\n    3352,\n/**/\n    3351,\n/**/\n    3350,\n/**/\n    3349,\n/**/\n    3348,\n/**/\n    3347,\n/**/\n    3346,\n/**/\n    3345,\n/**/\n    3344,\n/**/\n    3343,\n/**/\n    3342,\n/**/\n    3341,\n/**/\n    3340,\n/**/\n    3339,\n/**/\n    3338,\n/**/\n    3337,\n/**/\n    3336,\n/**/\n    3335,\n/**/\n    3334,\n/**/\n    3333,\n/**/\n    3332,\n/**/\n    3331,\n/**/\n    3330,\n/**/\n    3329,\n/**/\n    3328,\n/**/\n    3327,\n/**/\n    3326,\n/**/\n    3325,\n/**/\n    3324,\n/**/\n    3323,\n/**/\n    3322,\n/**/\n    3321,\n/**/\n    3320,\n/**/\n    3319,\n/**/\n    3318,\n/**/\n    3317,\n/**/\n    3316,\n/**/\n    3315,\n/**/\n    3314,\n/**/\n    3313,\n/**/\n    3312,\n/**/\n    3311,\n/**/\n    3310,\n/**/\n    3309,\n/**/\n    3308,\n/**/\n    3307,\n/**/\n    3306,\n/**/\n    3305,\n/**/\n    3304,\n/**/\n    3303,\n/**/\n    3302,\n/**/\n    3301,\n/**/\n    3300,\n/**/\n    3299,\n/**/\n    3298,\n/**/\n    3297,\n/**/\n    3296,\n/**/\n    3295,\n/**/\n    3294,\n/**/\n    3293,\n/**/\n    3292,\n/**/\n    3291,\n/**/\n    3290,\n/**/\n    3289,\n/**/\n    3288,\n/**/\n    3287,\n/**/\n    3286,\n/**/\n    3285,\n/**/\n    3284,\n/**/\n    3283,\n/**/\n    3282,\n/**/\n    3281,\n/**/\n    3280,\n/**/\n    3279,\n/**/\n    3278,\n/**/\n    3277,\n/**/\n    3276,\n/**/\n    3275,\n/**/\n    3274,\n/**/\n    3273,\n/**/\n    3272,\n/**/\n    3271,\n/**/\n    3270,\n/**/\n    3269,\n/**/\n    3268,\n/**/\n    3267,\n/**/\n    3266,\n/**/\n    3265,\n/**/\n    3264,\n/**/\n    3263,\n/**/\n    3262,\n/**/\n    3261,\n/**/\n    3260,\n/**/\n    3259,\n/**/\n    3258,\n/**/\n    3257,\n/**/\n    3256,\n/**/\n    3255,\n/**/\n    3254,\n/**/\n    3253,\n/**/\n    3252,\n/**/\n    3251,\n/**/\n    3250,\n/**/\n    3249,\n/**/\n    3248,\n/**/\n    3247,\n/**/\n    3246,\n/**/\n    3245,\n/**/\n    3244,\n/**/\n    3243,\n/**/\n    3242,\n/**/\n    3241,\n/**/\n    3240,\n/**/\n    3239,\n/**/\n    3238,\n/**/\n    3237,\n/**/\n    3236,\n/**/\n    3235,\n/**/\n    3234,\n/**/\n    3233,\n/**/\n    3232,\n/**/\n    3231,\n/**/\n    3230,\n/**/\n    3229,\n/**/\n    3228,\n/**/\n    3227,\n/**/\n    3226,\n/**/\n    3225,\n/**/\n    3224,\n/**/\n    3223,\n/**/\n    3222,\n/**/\n    3221,\n/**/\n    3220,\n/**/\n    3219,\n/**/\n    3218,\n/**/\n    3217,\n/**/\n    3216,\n/**/\n    3215,\n/**/\n    3214,\n/**/\n    3213,\n/**/\n    3212,\n/**/\n    3211,\n/**/\n    3210,\n/**/\n    3209,\n/**/\n    3208,\n/**/\n    3207,\n/**/\n    3206,\n/**/\n    3205,\n/**/\n    3204,\n/**/\n    3203,\n/**/\n    3202,\n/**/\n    3201,\n/**/\n    3200,\n/**/\n    3199,\n/**/\n    3198,\n/**/\n    3197,\n/**/\n    3196,\n/**/\n    3195,\n/**/\n    3194,\n/**/\n    3193,\n/**/\n    3192,\n/**/\n    3191,\n/**/\n    3190,\n/**/\n    3189,\n/**/\n    3188,\n/**/\n    3187,\n/**/\n    3186,\n/**/\n    3185,\n/**/\n    3184,\n/**/\n    3183,\n/**/\n    3182,\n/**/\n    3181,\n/**/\n    3180,\n/**/\n    3179,\n/**/\n    3178,\n/**/\n    3177,\n/**/\n    3176,\n/**/\n    3175,\n/**/\n    3174,\n/**/\n    3173,\n/**/\n    3172,\n/**/\n    3171,\n/**/\n    3170,\n/**/\n    3169,\n/**/\n    3168,\n/**/\n    3167,\n/**/\n    3166,\n/**/\n    3165,\n/**/\n    3164,\n/**/\n    3163,\n/**/\n    3162,\n/**/\n    3161,\n/**/\n    3160,\n/**/\n    3159,\n/**/\n    3158,\n/**/\n    3157,\n/**/\n    3156,\n/**/\n    3155,\n/**/\n    3154,\n/**/\n    3153,\n/**/\n    3152,\n/**/\n    3151,\n/**/\n    3150,\n/**/\n    3149,\n/**/\n    3148,\n/**/\n    3147,\n/**/\n    3146,\n/**/\n    3145,\n/**/\n    3144,\n/**/\n    3143,\n/**/\n    3142,\n/**/\n    3141,\n/**/\n    3140,\n/**/\n    3139,\n/**/\n    3138,\n/**/\n    3137,\n/**/\n    3136,\n/**/\n    3135,\n/**/\n    3134,\n/**/\n    3133,\n/**/\n    3132,\n/**/\n    3131,\n/**/\n    3130,\n/**/\n    3129,\n/**/\n    3128,\n/**/\n    3127,\n/**/\n    3126,\n/**/\n    3125,\n/**/\n    3124,\n/**/\n    3123,\n/**/\n    3122,\n/**/\n    3121,\n/**/\n    3120,\n/**/\n    3119,\n/**/\n    3118,\n/**/\n    3117,\n/**/\n    3116,\n/**/\n    3115,\n/**/\n    3114,\n/**/\n    3113,\n/**/\n    3112,\n/**/\n    3111,\n/**/\n    3110,\n/**/\n    3109,\n/**/\n    3108,\n/**/\n    3107,\n/**/\n    3106,\n/**/\n    3105,\n/**/\n    3104,\n/**/\n    3103,\n/**/\n    3102,\n/**/\n    3101,\n/**/\n    3100,\n/**/\n    3099,\n/**/\n    3098,\n/**/\n    3097,\n/**/\n    3096,\n/**/\n    3095,\n/**/\n    3094,\n/**/\n    3093,\n/**/\n    3092,\n/**/\n    3091,\n/**/\n    3090,\n/**/\n    3089,\n/**/\n    3088,\n/**/\n    3087,\n/**/\n    3086,\n/**/\n    3085,\n/**/\n    3084,\n/**/\n    3083,\n/**/\n    3082,\n/**/\n    3081,\n/**/\n    3080,\n/**/\n    3079,\n/**/\n    3078,\n/**/\n    3077,\n/**/\n    3076,\n/**/\n    3075,\n/**/\n    3074,\n/**/\n    3073,\n/**/\n    3072,\n/**/\n    3071,\n/**/\n    3070,\n/**/\n    3069,\n/**/\n    3068,\n/**/\n    3067,\n/**/\n    3066,\n/**/\n    3065,\n/**/\n    3064,\n/**/\n    3063,\n/**/\n    3062,\n/**/\n    3061,\n/**/\n    3060,\n/**/\n    3059,\n/**/\n    3058,\n/**/\n    3057,\n/**/\n    3056,\n/**/\n    3055,\n/**/\n    3054,\n/**/\n    3053,\n/**/\n    3052,\n/**/\n    3051,\n/**/\n    3050,\n/**/\n    3049,\n/**/\n    3048,\n/**/\n    3047,\n/**/\n    3046,\n/**/\n    3045,\n/**/\n    3044,\n/**/\n    3043,\n/**/\n    3042,\n/**/\n    3041,\n/**/\n    3040,\n/**/\n    3039,\n/**/\n    3038,\n/**/\n    3037,\n/**/\n    3036,\n/**/\n    3035,\n/**/\n    3034,\n/**/\n    3033,\n/**/\n    3032,\n/**/\n    3031,\n/**/\n    3030,\n/**/\n    3029,\n/**/\n    3028,\n/**/\n    3027,\n/**/\n    3026,\n/**/\n    3025,\n/**/\n    3024,\n/**/\n    3023,\n/**/\n    3022,\n/**/\n    3021,\n/**/\n    3020,\n/**/\n    3019,\n/**/\n    3018,\n/**/\n    3017,\n/**/\n    3016,\n/**/\n    3015,\n/**/\n    3014,\n/**/\n    3013,\n/**/\n    3012,\n/**/\n    3011,\n/**/\n    3010,\n/**/\n    3009,\n/**/\n    3008,\n/**/\n    3007,\n/**/\n    3006,\n/**/\n    3005,\n/**/\n    3004,\n/**/\n    3003,\n/**/\n    3002,\n/**/\n    3001,\n/**/\n    3000,\n/**/\n    2999,\n/**/\n    2998,\n/**/\n    2997,\n/**/\n    2996,\n/**/\n    2995,\n/**/\n    2994,\n/**/\n    2993,\n/**/\n    2992,\n/**/\n    2991,\n/**/\n    2990,\n/**/\n    2989,\n/**/\n    2988,\n/**/\n    2987,\n/**/\n    2986,\n/**/\n    2985,\n/**/\n    2984,\n/**/\n    2983,\n/**/\n    2982,\n/**/\n    2981,\n/**/\n    2980,\n/**/\n    2979,\n/**/\n    2978,\n/**/\n    2977,\n/**/\n    2976,\n/**/\n    2975,\n/**/\n    2974,\n/**/\n    2973,\n/**/\n    2972,\n/**/\n    2971,\n/**/\n    2970,\n/**/\n    2969,\n/**/\n    2968,\n/**/\n    2967,\n/**/\n    2966,\n/**/\n    2965,\n/**/\n    2964,\n/**/\n    2963,\n/**/\n    2962,\n/**/\n    2961,\n/**/\n    2960,\n/**/\n    2959,\n/**/\n    2958,\n/**/\n    2957,\n/**/\n    2956,\n/**/\n    2955,\n/**/\n    2954,\n/**/\n    2953,\n/**/\n    2952,\n/**/\n    2951,\n/**/\n    2950,\n/**/\n    2949,\n/**/\n    2948,\n/**/\n    2947,\n/**/\n    2946,\n/**/\n    2945,\n/**/\n    2944,\n/**/\n    2943,\n/**/\n    2942,\n/**/\n    2941,\n/**/\n    2940,\n/**/\n    2939,\n/**/\n    2938,\n/**/\n    2937,\n/**/\n    2936,\n/**/\n    2935,\n/**/\n    2934,\n/**/\n    2933,\n/**/\n    2932,\n/**/\n    2931,\n/**/\n    2930,\n/**/\n    2929,\n/**/\n    2928,\n/**/\n    2927,\n/**/\n    2926,\n/**/\n    2925,\n/**/\n    2924,\n/**/\n    2923,\n/**/\n    2922,\n/**/\n    2921,\n/**/\n    2920,\n/**/\n    2919,\n/**/\n    2918,\n/**/\n    2917,\n/**/\n    2916,\n/**/\n    2915,\n/**/\n    2914,\n/**/\n    2913,\n/**/\n    2912,\n/**/\n    2911,\n/**/\n    2910,\n/**/\n    2909,\n/**/\n    2908,\n/**/\n    2907,\n/**/\n    2906,\n/**/\n    2905,\n/**/\n    2904,\n/**/\n    2903,\n/**/\n    2902,\n/**/\n    2901,\n/**/\n    2900,\n/**/\n    2899,\n/**/\n    2898,\n/**/\n    2897,\n/**/\n    2896,\n/**/\n    2895,\n/**/\n    2894,\n/**/\n    2893,\n/**/\n    2892,\n/**/\n    2891,\n/**/\n    2890,\n/**/\n    2889,\n/**/\n    2888,\n/**/\n    2887,\n/**/\n    2886,\n/**/\n    2885,\n/**/\n    2884,\n/**/\n    2883,\n/**/\n    2882,\n/**/\n    2881,\n/**/\n    2880,\n/**/\n    2879,\n/**/\n    2878,\n/**/\n    2877,\n/**/\n    2876,\n/**/\n    2875,\n/**/\n    2874,\n/**/\n    2873,\n/**/\n    2872,\n/**/\n    2871,\n/**/\n    2870,\n/**/\n    2869,\n/**/\n    2868,\n/**/\n    2867,\n/**/\n    2866,\n/**/\n    2865,\n/**/\n    2864,\n/**/\n    2863,\n/**/\n    2862,\n/**/\n    2861,\n/**/\n    2860,\n/**/\n    2859,\n/**/\n    2858,\n/**/\n    2857,\n/**/\n    2856,\n/**/\n    2855,\n/**/\n    2854,\n/**/\n    2853,\n/**/\n    2852,\n/**/\n    2851,\n/**/\n    2850,\n/**/\n    2849,\n/**/\n    2848,\n/**/\n    2847,\n/**/\n    2846,\n/**/\n    2845,\n/**/\n    2844,\n/**/\n    2843,\n/**/\n    2842,\n/**/\n    2841,\n/**/\n    2840,\n/**/\n    2839,\n/**/\n    2838,\n/**/\n    2837,\n/**/\n    2836,\n/**/\n    2835,\n/**/\n    2834,\n/**/\n    2833,\n/**/\n    2832,\n/**/\n    2831,\n/**/\n    2830,\n/**/\n    2829,\n/**/\n    2828,\n/**/\n    2827,\n/**/\n    2826,\n/**/\n    2825,\n/**/\n    2824,\n/**/\n    2823,\n/**/\n    2822,\n/**/\n    2821,\n/**/\n    2820,\n/**/\n    2819,\n/**/\n    2818,\n/**/\n    2817,\n/**/\n    2816,\n/**/\n    2815,\n/**/\n    2814,\n/**/\n    2813,\n/**/\n    2812,\n/**/\n    2811,\n/**/\n    2810,\n/**/\n    2809,\n/**/\n    2808,\n/**/\n    2807,\n/**/\n    2806,\n/**/\n    2805,\n/**/\n    2804,\n/**/\n    2803,\n/**/\n    2802,\n/**/\n    2801,\n/**/\n    2800,\n/**/\n    2799,\n/**/\n    2798,\n/**/\n    2797,\n/**/\n    2796,\n/**/\n    2795,\n/**/\n    2794,\n/**/\n    2793,\n/**/\n    2792,\n/**/\n    2791,\n/**/\n    2790,\n/**/\n    2789,\n/**/\n    2788,\n/**/\n    2787,\n/**/\n    2786,\n/**/\n    2785,\n/**/\n    2784,\n/**/\n    2783,\n/**/\n    2782,\n/**/\n    2781,\n/**/\n    2780,\n/**/\n    2779,\n/**/\n    2778,\n/**/\n    2777,\n/**/\n    2776,\n/**/\n    2775,\n/**/\n    2774,\n/**/\n    2773,\n/**/\n    2772,\n/**/\n    2771,\n/**/\n    2770,\n/**/\n    2769,\n/**/\n    2768,\n/**/\n    2767,\n/**/\n    2766,\n/**/\n    2765,\n/**/\n    2764,\n/**/\n    2763,\n/**/\n    2762,\n/**/\n    2761,\n/**/\n    2760,\n/**/\n    2759,\n/**/\n    2758,\n/**/\n    2757,\n/**/\n    2756,\n/**/\n    2755,\n/**/\n    2754,\n/**/\n    2753,\n/**/\n    2752,\n/**/\n    2751,\n/**/\n    2750,\n/**/\n    2749,\n/**/\n    2748,\n/**/\n    2747,\n/**/\n    2746,\n/**/\n    2745,\n/**/\n    2744,\n/**/\n    2743,\n/**/\n    2742,\n/**/\n    2741,\n/**/\n    2740,\n/**/\n    2739,\n/**/\n    2738,\n/**/\n    2737,\n/**/\n    2736,\n/**/\n    2735,\n/**/\n    2734,\n/**/\n    2733,\n/**/\n    2732,\n/**/\n    2731,\n/**/\n    2730,\n/**/\n    2729,\n/**/\n    2728,\n/**/\n    2727,\n/**/\n    2726,\n/**/\n    2725,\n/**/\n    2724,\n/**/\n    2723,\n/**/\n    2722,\n/**/\n    2721,\n/**/\n    2720,\n/**/\n    2719,\n/**/\n    2718,\n/**/\n    2717,\n/**/\n    2716,\n/**/\n    2715,\n/**/\n    2714,\n/**/\n    2713,\n/**/\n    2712,\n/**/\n    2711,\n/**/\n    2710,\n/**/\n    2709,\n/**/\n    2708,\n/**/\n    2707,\n/**/\n    2706,\n/**/\n    2705,\n/**/\n    2704,\n/**/\n    2703,\n/**/\n    2702,\n/**/\n    2701,\n/**/\n    2700,\n/**/\n    2699,\n/**/\n    2698,\n/**/\n    2697,\n/**/\n    2696,\n/**/\n    2695,\n/**/\n    2694,\n/**/\n    2693,\n/**/\n    2692,\n/**/\n    2691,\n/**/\n    2690,\n/**/\n    2689,\n/**/\n    2688,\n/**/\n    2687,\n/**/\n    2686,\n/**/\n    2685,\n/**/\n    2684,\n/**/\n    2683,\n/**/\n    2682,\n/**/\n    2681,\n/**/\n    2680,\n/**/\n    2679,\n/**/\n    2678,\n/**/\n    2677,\n/**/\n    2676,\n/**/\n    2675,\n/**/\n    2674,\n/**/\n    2673,\n/**/\n    2672,\n/**/\n    2671,\n/**/\n    2670,\n/**/\n    2669,\n/**/\n    2668,\n/**/\n    2667,\n/**/\n    2666,\n/**/\n    2665,\n/**/\n    2664,\n/**/\n    2663,\n/**/\n    2662,\n/**/\n    2661,\n/**/\n    2660,\n/**/\n    2659,\n/**/\n    2658,\n/**/\n    2657,\n/**/\n    2656,\n/**/\n    2655,\n/**/\n    2654,\n/**/\n    2653,\n/**/\n    2652,\n/**/\n    2651,\n/**/\n    2650,\n/**/\n    2649,\n/**/\n    2648,\n/**/\n    2647,\n/**/\n    2646,\n/**/\n    2645,\n/**/\n    2644,\n/**/\n    2643,\n/**/\n    2642,\n/**/\n    2641,\n/**/\n    2640,\n/**/\n    2639,\n/**/\n    2638,\n/**/\n    2637,\n/**/\n    2636,\n/**/\n    2635,\n/**/\n    2634,\n/**/\n    2633,\n/**/\n    2632,\n/**/\n    2631,\n/**/\n    2630,\n/**/\n    2629,\n/**/\n    2628,\n/**/\n    2627,\n/**/\n    2626,\n/**/\n    2625,\n/**/\n    2624,\n/**/\n    2623,\n/**/\n    2622,\n/**/\n    2621,\n/**/\n    2620,\n/**/\n    2619,\n/**/\n    2618,\n/**/\n    2617,\n/**/\n    2616,\n/**/\n    2615,\n/**/\n    2614,\n/**/\n    2613,\n/**/\n    2612,\n/**/\n    2611,\n/**/\n    2610,\n/**/\n    2609,\n/**/\n    2608,\n/**/\n    2607,\n/**/\n    2606,\n/**/\n    2605,\n/**/\n    2604,\n/**/\n    2603,\n/**/\n    2602,\n/**/\n    2601,\n/**/\n    2600,\n/**/\n    2599,\n/**/\n    2598,\n/**/\n    2597,\n/**/\n    2596,\n/**/\n    2595,\n/**/\n    2594,\n/**/\n    2593,\n/**/\n    2592,\n/**/\n    2591,\n/**/\n    2590,\n/**/\n    2589,\n/**/\n    2588,\n/**/\n    2587,\n/**/\n    2586,\n/**/\n    2585,\n/**/\n    2584,\n/**/\n    2583,\n/**/\n    2582,\n/**/\n    2581,\n/**/\n    2580,\n/**/\n    2579,\n/**/\n    2578,\n/**/\n    2577,\n/**/\n    2576,\n/**/\n    2575,\n/**/\n    2574,\n/**/\n    2573,\n/**/\n    2572,\n/**/\n    2571,\n/**/\n    2570,\n/**/\n    2569,\n/**/\n    2568,\n/**/\n    2567,\n/**/\n    2566,\n/**/\n    2565,\n/**/\n    2564,\n/**/\n    2563,\n/**/\n    2562,\n/**/\n    2561,\n/**/\n    2560,\n/**/\n    2559,\n/**/\n    2558,\n/**/\n    2557,\n/**/\n    2556,\n/**/\n    2555,\n/**/\n    2554,\n/**/\n    2553,\n/**/\n    2552,\n/**/\n    2551,\n/**/\n    2550,\n/**/\n    2549,\n/**/\n    2548,\n/**/\n    2547,\n/**/\n    2546,\n/**/\n    2545,\n/**/\n    2544,\n/**/\n    2543,\n/**/\n    2542,\n/**/\n    2541,\n/**/\n    2540,\n/**/\n    2539,\n/**/\n    2538,\n/**/\n    2537,\n/**/\n    2536,\n/**/\n    2535,\n/**/\n    2534,\n/**/\n    2533,\n/**/\n    2532,\n/**/\n    2531,\n/**/\n    2530,\n/**/\n    2529,\n/**/\n    2528,\n/**/\n    2527,\n/**/\n    2526,\n/**/\n    2525,\n/**/\n    2524,\n/**/\n    2523,\n/**/\n    2522,\n/**/\n    2521,\n/**/\n    2520,\n/**/\n    2519,\n/**/\n    2518,\n/**/\n    2517,\n/**/\n    2516,\n/**/\n    2515,\n/**/\n    2514,\n/**/\n    2513,\n/**/\n    2512,\n/**/\n    2511,\n/**/\n    2510,\n/**/\n    2509,\n/**/\n    2508,\n/**/\n    2507,\n/**/\n    2506,\n/**/\n    2505,\n/**/\n    2504,\n/**/\n    2503,\n/**/\n    2502,\n/**/\n    2501,\n/**/\n    2500,\n/**/\n    2499,\n/**/\n    2498,\n/**/\n    2497,\n/**/\n    2496,\n/**/\n    2495,\n/**/\n    2494,\n/**/\n    2493,\n/**/\n    2492,\n/**/\n    2491,\n/**/\n    2490,\n/**/\n    2489,\n/**/\n    2488,\n/**/\n    2487,\n/**/\n    2486,\n/**/\n    2485,\n/**/\n    2484,\n/**/\n    2483,\n/**/\n    2482,\n/**/\n    2481,\n/**/\n    2480,\n/**/\n    2479,\n/**/\n    2478,\n/**/\n    2477,\n/**/\n    2476,\n/**/\n    2475,\n/**/\n    2474,\n/**/\n    2473,\n/**/\n    2472,\n/**/\n    2471,\n/**/\n    2470,\n/**/\n    2469,\n/**/\n    2468,\n/**/\n    2467,\n/**/\n    2466,\n/**/\n    2465,\n/**/\n    2464,\n/**/\n    2463,\n/**/\n    2462,\n/**/\n    2461,\n/**/\n    2460,\n/**/\n    2459,\n/**/\n    2458,\n/**/\n    2457,\n/**/\n    2456,\n/**/\n    2455,\n/**/\n    2454,\n/**/\n    2453,\n/**/\n    2452,\n/**/\n    2451,\n/**/\n    2450,\n/**/\n    2449,\n/**/\n    2448,\n/**/\n    2447,\n/**/\n    2446,\n/**/\n    2445,\n/**/\n    2444,\n/**/\n    2443,\n/**/\n    2442,\n/**/\n    2441,\n/**/\n    2440,\n/**/\n    2439,\n/**/\n    2438,\n/**/\n    2437,\n/**/\n    2436,\n/**/\n    2435,\n/**/\n    2434,\n/**/\n    2433,\n/**/\n    2432,\n/**/\n    2431,\n/**/\n    2430,\n/**/\n    2429,\n/**/\n    2428,\n/**/\n    2427,\n/**/\n    2426,\n/**/\n    2425,\n/**/\n    2424,\n/**/\n    2423,\n/**/\n    2422,\n/**/\n    2421,\n/**/\n    2420,\n/**/\n    2419,\n/**/\n    2418,\n/**/\n    2417,\n/**/\n    2416,\n/**/\n    2415,\n/**/\n    2414,\n/**/\n    2413,\n/**/\n    2412,\n/**/\n    2411,\n/**/\n    2410,\n/**/\n    2409,\n/**/\n    2408,\n/**/\n    2407,\n/**/\n    2406,\n/**/\n    2405,\n/**/\n    2404,\n/**/\n    2403,\n/**/\n    2402,\n/**/\n    2401,\n/**/\n    2400,\n/**/\n    2399,\n/**/\n    2398,\n/**/\n    2397,\n/**/\n    2396,\n/**/\n    2395,\n/**/\n    2394,\n/**/\n    2393,\n/**/\n    2392,\n/**/\n    2391,\n/**/\n    2390,\n/**/\n    2389,\n/**/\n    2388,\n/**/\n    2387,\n/**/\n    2386,\n/**/\n    2385,\n/**/\n    2384,\n/**/\n    2383,\n/**/\n    2382,\n/**/\n    2381,\n/**/\n    2380,\n/**/\n    2379,\n/**/\n    2378,\n/**/\n    2377,\n/**/\n    2376,\n/**/\n    2375,\n/**/\n    2374,\n/**/\n    2373,\n/**/\n    2372,\n/**/\n    2371,\n/**/\n    2370,\n/**/\n    2369,\n/**/\n    2368,\n/**/\n    2367,\n/**/\n    2366,\n/**/\n    2365,\n/**/\n    2364,\n/**/\n    2363,\n/**/\n    2362,\n/**/\n    2361,\n/**/\n    2360,\n/**/\n    2359,\n/**/\n    2358,\n/**/\n    2357,\n/**/\n    2356,\n/**/\n    2355,\n/**/\n    2354,\n/**/\n    2353,\n/**/\n    2352,\n/**/\n    2351,\n/**/\n    2350,\n/**/\n    2349,\n/**/\n    2348,\n/**/\n    2347,\n/**/\n    2346,\n/**/\n    2345,\n/**/\n    2344,\n/**/\n    2343,\n/**/\n    2342,\n/**/\n    2341,\n/**/\n    2340,\n/**/\n    2339,\n/**/\n    2338,\n/**/\n    2337,\n/**/\n    2336,\n/**/\n    2335,\n/**/\n    2334,\n/**/\n    2333,\n/**/\n    2332,\n/**/\n    2331,\n/**/\n    2330,\n/**/\n    2329,\n/**/\n    2328,\n/**/\n    2327,\n/**/\n    2326,\n/**/\n    2325,\n/**/\n    2324,\n/**/\n    2323,\n/**/\n    2322,\n/**/\n    2321,\n/**/\n    2320,\n/**/\n    2319,\n/**/\n    2318,\n/**/\n    2317,\n/**/\n    2316,\n/**/\n    2315,\n/**/\n    2314,\n/**/\n    2313,\n/**/\n    2312,\n/**/\n    2311,\n/**/\n    2310,\n/**/\n    2309,\n/**/\n    2308,\n/**/\n    2307,\n/**/\n    2306,\n/**/\n    2305,\n/**/\n    2304,\n/**/\n    2303,\n/**/\n    2302,\n/**/\n    2301,\n/**/\n    2300,\n/**/\n    2299,\n/**/\n    2298,\n/**/\n    2297,\n/**/\n    2296,\n/**/\n    2295,\n/**/\n    2294,\n/**/\n    2293,\n/**/\n    2292,\n/**/\n    2291,\n/**/\n    2290,\n/**/\n    2289,\n/**/\n    2288,\n/**/\n    2287,\n/**/\n    2286,\n/**/\n    2285,\n/**/\n    2284,\n/**/\n    2283,\n/**/\n    2282,\n/**/\n    2281,\n/**/\n    2280,\n/**/\n    2279,\n/**/\n    2278,\n/**/\n    2277,\n/**/\n    2276,\n/**/\n    2275,\n/**/\n    2274,\n/**/\n    2273,\n/**/\n    2272,\n/**/\n    2271,\n/**/\n    2270,\n/**/\n    2269,\n/**/\n    2268,\n/**/\n    2267,\n/**/\n    2266,\n/**/\n    2265,\n/**/\n    2264,\n/**/\n    2263,\n/**/\n    2262,\n/**/\n    2261,\n/**/\n    2260,\n/**/\n    2259,\n/**/\n    2258,\n/**/\n    2257,\n/**/\n    2256,\n/**/\n    2255,\n/**/\n    2254,\n/**/\n    2253,\n/**/\n    2252,\n/**/\n    2251,\n/**/\n    2250,\n/**/\n    2249,\n/**/\n    2248,\n/**/\n    2247,\n/**/\n    2246,\n/**/\n    2245,\n/**/\n    2244,\n/**/\n    2243,\n/**/\n    2242,\n/**/\n    2241,\n/**/\n    2240,\n/**/\n    2239,\n/**/\n    2238,\n/**/\n    2237,\n/**/\n    2236,\n/**/\n    2235,\n/**/\n    2234,\n/**/\n    2233,\n/**/\n    2232,\n/**/\n    2231,\n/**/\n    2230,\n/**/\n    2229,\n/**/\n    2228,\n/**/\n    2227,\n/**/\n    2226,\n/**/\n    2225,\n/**/\n    2224,\n/**/\n    2223,\n/**/\n    2222,\n/**/\n    2221,\n/**/\n    2220,\n/**/\n    2219,\n/**/\n    2218,\n/**/\n    2217,\n/**/\n    2216,\n/**/\n    2215,\n/**/\n    2214,\n/**/\n    2213,\n/**/\n    2212,\n/**/\n    2211,\n/**/\n    2210,\n/**/\n    2209,\n/**/\n    2208,\n/**/\n    2207,\n/**/\n    2206,\n/**/\n    2205,\n/**/\n    2204,\n/**/\n    2203,\n/**/\n    2202,\n/**/\n    2201,\n/**/\n    2200,\n/**/\n    2199,\n/**/\n    2198,\n/**/\n    2197,\n/**/\n    2196,\n/**/\n    2195,\n/**/\n    2194,\n/**/\n    2193,\n/**/\n    2192,\n/**/\n    2191,\n/**/\n    2190,\n/**/\n    2189,\n/**/\n    2188,\n/**/\n    2187,\n/**/\n    2186,\n/**/\n    2185,\n/**/\n    2184,\n/**/\n    2183,\n/**/\n    2182,\n/**/\n    2181,\n/**/\n    2180,\n/**/\n    2179,\n/**/\n    2178,\n/**/\n    2177,\n/**/\n    2176,\n/**/\n    2175,\n/**/\n    2174,\n/**/\n    2173,\n/**/\n    2172,\n/**/\n    2171,\n/**/\n    2170,\n/**/\n    2169,\n/**/\n    2168,\n/**/\n    2167,\n/**/\n    2166,\n/**/\n    2165,\n/**/\n    2164,\n/**/\n    2163,\n/**/\n    2162,\n/**/\n    2161,\n/**/\n    2160,\n/**/\n    2159,\n/**/\n    2158,\n/**/\n    2157,\n/**/\n    2156,\n/**/\n    2155,\n/**/\n    2154,\n/**/\n    2153,\n/**/\n    2152,\n/**/\n    2151,\n/**/\n    2150,\n/**/\n    2149,\n/**/\n    2148,\n/**/\n    2147,\n/**/\n    2146,\n/**/\n    2145,\n/**/\n    2144,\n/**/\n    2143,\n/**/\n    2142,\n/**/\n    2141,\n/**/\n    2140,\n/**/\n    2139,\n/**/\n    2138,\n/**/\n    2137,\n/**/\n    2136,\n/**/\n    2135,\n/**/\n    2134,\n/**/\n    2133,\n/**/\n    2132,\n/**/\n    2131,\n/**/\n    2130,\n/**/\n    2129,\n/**/\n    2128,\n/**/\n    2127,\n/**/\n    2126,\n/**/\n    2125,\n/**/\n    2124,\n/**/\n    2123,\n/**/\n    2122,\n/**/\n    2121,\n/**/\n    2120,\n/**/\n    2119,\n/**/\n    2118,\n/**/\n    2117,\n/**/\n    2116,\n/**/\n    2115,\n/**/\n    2114,\n/**/\n    2113,\n/**/\n    2112,\n/**/\n    2111,\n/**/\n    2110,\n/**/\n    2109,\n/**/\n    2108,\n/**/\n    2107,\n/**/\n    2106,\n/**/\n    2105,\n/**/\n    2104,\n/**/\n    2103,\n/**/\n    2102,\n/**/\n    2101,\n/**/\n    2100,\n/**/\n    2099,\n/**/\n    2098,\n/**/\n    2097,\n/**/\n    2096,\n/**/\n    2095,\n/**/\n    2094,\n/**/\n    2093,\n/**/\n    2092,\n/**/\n    2091,\n/**/\n    2090,\n/**/\n    2089,\n/**/\n    2088,\n/**/\n    2087,\n/**/\n    2086,\n/**/\n    2085,\n/**/\n    2084,\n/**/\n    2083,\n/**/\n    2082,\n/**/\n    2081,\n/**/\n    2080,\n/**/\n    2079,\n/**/\n    2078,\n/**/\n    2077,\n/**/\n    2076,\n/**/\n    2075,\n/**/\n    2074,\n/**/\n    2073,\n/**/\n    2072,\n/**/\n    2071,\n/**/\n    2070,\n/**/\n    2069,\n/**/\n    2068,\n/**/\n    2067,\n/**/\n    2066,\n/**/\n    2065,\n/**/\n    2064,\n/**/\n    2063,\n/**/\n    2062,\n/**/\n    2061,\n/**/\n    2060,\n/**/\n    2059,\n/**/\n    2058,\n/**/\n    2057,\n/**/\n    2056,\n/**/\n    2055,\n/**/\n    2054,\n/**/\n    2053,\n/**/\n    2052,\n/**/\n    2051,\n/**/\n    2050,\n/**/\n    2049,\n/**/\n    2048,\n/**/\n    2047,\n/**/\n    2046,\n/**/\n    2045,\n/**/\n    2044,\n/**/\n    2043,\n/**/\n    2042,\n/**/\n    2041,\n/**/\n    2040,\n/**/\n    2039,\n/**/\n    2038,\n/**/\n    2037,\n/**/\n    2036,\n/**/\n    2035,\n/**/\n    2034,\n/**/\n    2033,\n/**/\n    2032,\n/**/\n    2031,\n/**/\n    2030,\n/**/\n    2029,\n/**/\n    2028,\n/**/\n    2027,\n/**/\n    2026,\n/**/\n    2025,\n/**/\n    2024,\n/**/\n    2023,\n/**/\n    2022,\n/**/\n    2021,\n/**/\n    2020,\n/**/\n    2019,\n/**/\n    2018,\n/**/\n    2017,\n/**/\n    2016,\n/**/\n    2015,\n/**/\n    2014,\n/**/\n    2013,\n/**/\n    2012,\n/**/\n    2011,\n/**/\n    2010,\n/**/\n    2009,\n/**/\n    2008,\n/**/\n    2007,\n/**/\n    2006,\n/**/\n    2005,\n/**/\n    2004,\n/**/\n    2003,\n/**/\n    2002,\n/**/\n    2001,\n/**/\n    2000,\n/**/\n    1999,\n/**/\n    1998,\n/**/\n    1997,\n/**/\n    1996,\n/**/\n    1995,\n/**/\n    1994,\n/**/\n    1993,\n/**/\n    1992,\n/**/\n    1991,\n/**/\n    1990,\n/**/\n    1989,\n/**/\n    1988,\n/**/\n    1987,\n/**/\n    1986,\n/**/\n    1985,\n/**/\n    1984,\n/**/\n    1983,\n/**/\n    1982,\n/**/\n    1981,\n/**/\n    1980,\n/**/\n    1979,\n/**/\n    1978,\n/**/\n    1977,\n/**/\n    1976,\n/**/\n    1975,\n/**/\n    1974,\n/**/\n    1973,\n/**/\n    1972,\n/**/\n    1971,\n/**/\n    1970,\n/**/\n    1969,\n/**/\n    1968,\n/**/\n    1967,\n/**/\n    1966,\n/**/\n    1965,\n/**/\n    1964,\n/**/\n    1963,\n/**/\n    1962,\n/**/\n    1961,\n/**/\n    1960,\n/**/\n    1959,\n/**/\n    1958,\n/**/\n    1957,\n/**/\n    1956,\n/**/\n    1955,\n/**/\n    1954,\n/**/\n    1953,\n/**/\n    1952,\n/**/\n    1951,\n/**/\n    1950,\n/**/\n    1949,\n/**/\n    1948,\n/**/\n    1947,\n/**/\n    1946,\n/**/\n    1945,\n/**/\n    1944,\n/**/\n    1943,\n/**/\n    1942,\n/**/\n    1941,\n/**/\n    1940,\n/**/\n    1939,\n/**/\n    1938,\n/**/\n    1937,\n/**/\n    1936,\n/**/\n    1935,\n/**/\n    1934,\n/**/\n    1933,\n/**/\n    1932,\n/**/\n    1931,\n/**/\n    1930,\n/**/\n    1929,\n/**/\n    1928,\n/**/\n    1927,\n/**/\n    1926,\n/**/\n    1925,\n/**/\n    1924,\n/**/\n    1923,\n/**/\n    1922,\n/**/\n    1921,\n/**/\n    1920,\n/**/\n    1919,\n/**/\n    1918,\n/**/\n    1917,\n/**/\n    1916,\n/**/\n    1915,\n/**/\n    1914,\n/**/\n    1913,\n/**/\n    1912,\n/**/\n    1911,\n/**/\n    1910,\n/**/\n    1909,\n/**/\n    1908,\n/**/\n    1907,\n/**/\n    1906,\n/**/\n    1905,\n/**/\n    1904,\n/**/\n    1903,\n/**/\n    1902,\n/**/\n    1901,\n/**/\n    1900,\n/**/\n    1899,\n/**/\n    1898,\n/**/\n    1897,\n/**/\n    1896,\n/**/\n    1895,\n/**/\n    1894,\n/**/\n    1893,\n/**/\n    1892,\n/**/\n    1891,\n/**/\n    1890,\n/**/\n    1889,\n/**/\n    1888,\n/**/\n    1887,\n/**/\n    1886,\n/**/\n    1885,\n/**/\n    1884,\n/**/\n    1883,\n/**/\n    1882,\n/**/\n    1881,\n/**/\n    1880,\n/**/\n    1879,\n/**/\n    1878,\n/**/\n    1877,\n/**/\n    1876,\n/**/\n    1875,\n/**/\n    1874,\n/**/\n    1873,\n/**/\n    1872,\n/**/\n    1871,\n/**/\n    1870,\n/**/\n    1869,\n/**/\n    1868,\n/**/\n    1867,\n/**/\n    1866,\n/**/\n    1865,\n/**/\n    1864,\n/**/\n    1863,\n/**/\n    1862,\n/**/\n    1861,\n/**/\n    1860,\n/**/\n    1859,\n/**/\n    1858,\n/**/\n    1857,\n/**/\n    1856,\n/**/\n    1855,\n/**/\n    1854,\n/**/\n    1853,\n/**/\n    1852,\n/**/\n    1851,\n/**/\n    1850,\n/**/\n    1849,\n/**/\n    1848,\n/**/\n    1847,\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    while (l < h)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + (item_count % ncol ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#ifdef FEAT_HUGE\n    msg_puts(_(\"\\nHuge version \"));\n#else\n# ifdef FEAT_BIG\n    msg_puts(_(\"\\nBig version \"));\n# else\n#  ifdef FEAT_NORMAL\n    msg_puts(_(\"\\nNormal version \"));\n#  else\n#   ifdef FEAT_SMALL\n    msg_puts(_(\"\\nSmall version \"));\n#   else\n    msg_puts(_(\"\\nTiny version \"));\n#   endif\n#  endif\n# endif\n#endif\n#ifndef FEAT_GUI\n    msg_puts(_(\"without GUI.\"));\n#else\n# ifdef FEAT_GUI_GTK\n#  ifdef USE_GTK3\n    msg_puts(_(\"with GTK3 GUI.\"));\n#  else\n#   ifdef FEAT_GUI_GNOME\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n#   else\n     msg_puts(_(\"with GTK2 GUI.\"));\n#   endif\n# endif\n# else\n#  ifdef FEAT_GUI_MOTIF\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#  else\n#   ifdef FEAT_GUI_ATHENA\n#    ifdef FEAT_GUI_NEXTAW\n    msg_puts(_(\"with X11-neXtaw GUI.\"));\n#    else\n    msg_puts(_(\"with X11-Athena GUI.\"));\n#    endif\n#   else\n#    ifdef FEAT_GUI_HAIKU\n    msg_puts(_(\"with Haiku GUI.\"));\n#    else\n#     ifdef FEAT_GUI_PHOTON\n    msg_puts(_(\"with Photon GUI.\"));\n#     else\n#      if defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#      endif\n#     endif\n#    endif\n#   endif\n#  endif\n# endif\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version8<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "fixing_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * Handling of regular expressions: vim_regcomp(), vim_regexec(), vim_regsub()\n */\n\n// By default: do not create debugging logs or files related to regular\n// expressions, even when compiling with -DDEBUG.\n// Uncomment the second line to get the regexp debugging.\n#undef DEBUG\n// #define DEBUG\n\n#include \"vim.h\"\n\n#ifdef DEBUG\n// show/save debugging data when BT engine is used\n# define BT_REGEXP_DUMP\n// save the debugging data to a file instead of displaying it\n# define BT_REGEXP_LOG\n# define BT_REGEXP_DEBUG_LOG\n# define BT_REGEXP_DEBUG_LOG_NAME\t\"bt_regexp_debug.log\"\n#endif\n\n/*\n * Magic characters have a special meaning, they don't match literally.\n * Magic characters are negative.  This separates them from literal characters\n * (possibly multi-byte).  Only ASCII characters can be Magic.\n */\n#define Magic(x)\t((int)(x) - 256)\n#define un_Magic(x)\t((x) + 256)\n#define is_Magic(x)\t((x) < 0)\n\n    static int\nno_Magic(int x)\n{\n    if (is_Magic(x))\n\treturn un_Magic(x);\n    return x;\n}\n\n    static int\ntoggle_Magic(int x)\n{\n    if (is_Magic(x))\n\treturn un_Magic(x);\n    return Magic(x);\n}\n\n/*\n * The first byte of the BT regexp internal \"program\" is actually this magic\n * number; the start node begins in the second byte.  It's used to catch the\n * most severe mutilation of the program by the caller.\n */\n\n#define REGMAGIC\t0234\n\n/*\n * Utility definitions.\n */\n#define UCHARAT(p)\t((int)*(char_u *)(p))\n\n// Used for an error (down from) vim_regcomp(): give the error message, set\n// rc_did_emsg and return NULL\n#define EMSG_RET_NULL(m) return (emsg((m)), rc_did_emsg = TRUE, (void *)NULL)\n#define IEMSG_RET_NULL(m) return (iemsg((m)), rc_did_emsg = TRUE, (void *)NULL)\n#define EMSG_RET_FAIL(m) return (emsg((m)), rc_did_emsg = TRUE, FAIL)\n#define EMSG2_RET_NULL(m, c) return (semsg((const char *)(m), (c) ? \"\" : \"\\\\\"), rc_did_emsg = TRUE, (void *)NULL)\n#define EMSG3_RET_NULL(m, c, a) return (semsg((const char *)(m), (c) ? \"\" : \"\\\\\", (a)), rc_did_emsg = TRUE, (void *)NULL)\n#define EMSG2_RET_FAIL(m, c) return (semsg((const char *)(m), (c) ? \"\" : \"\\\\\"), rc_did_emsg = TRUE, FAIL)\n#define EMSG_ONE_RET_NULL EMSG2_RET_NULL(_(\"E369: invalid item in %s%%[]\"), reg_magic == MAGIC_ALL)\n\n\n#define MAX_LIMIT\t(32767L << 16L)\n\nstatic char_u e_missingbracket[] = N_(\"E769: Missing ] after %s[\");\nstatic char_u e_reverse_range[] = N_(\"E944: Reverse range in character class\");\nstatic char_u e_large_class[] = N_(\"E945: Range too large in character class\");\n#ifdef FEAT_SYN_HL\nstatic char_u e_z_not_allowed[] = N_(\"E66: \\\\z( not allowed here\");\nstatic char_u e_z1_not_allowed[] = N_(\"E67: \\\\z1 - \\\\z9 not allowed here\");\n#endif\nstatic char_u e_missing_sb[] = N_(\"E69: Missing ] after %s%%[\");\nstatic char_u e_empty_sb[]  = N_(\"E70: Empty %s%%[]\");\nstatic char_u e_recursive[]  = N_(\"E956: Cannot use pattern recursively\");\n\n#define NOT_MULTI\t0\n#define MULTI_ONE\t1\n#define MULTI_MULT\t2\n\n// return values for regmatch()\n#define RA_FAIL\t\t1\t// something failed, abort\n#define RA_CONT\t\t2\t// continue in inner loop\n#define RA_BREAK\t3\t// break inner loop\n#define RA_MATCH\t4\t// successful match\n#define RA_NOMATCH\t5\t// didn't match\n\n/*\n * Return NOT_MULTI if c is not a \"multi\" operator.\n * Return MULTI_ONE if c is a single \"multi\" operator.\n * Return MULTI_MULT if c is a multi \"multi\" operator.\n */\n    static int\nre_multi_type(int c)\n{\n    if (c == Magic('@') || c == Magic('=') || c == Magic('?'))\n\treturn MULTI_ONE;\n    if (c == Magic('*') || c == Magic('+') || c == Magic('{'))\n\treturn MULTI_MULT;\n    return NOT_MULTI;\n}\n\nstatic char_u\t\t*reg_prev_sub = NULL;\n\n/*\n * REGEXP_INRANGE contains all characters which are always special in a []\n * range after '\\'.\n * REGEXP_ABBR contains all characters which act as abbreviations after '\\'.\n * These are:\n *  \\n\t- New line (NL).\n *  \\r\t- Carriage Return (CR).\n *  \\t\t- Tab (TAB).\n *  \\e\t- Escape (ESC).\n *  \\b\t- Backspace (Ctrl_H).\n *  \\d  - Character code in decimal, eg \\d123\n *  \\o\t- Character code in octal, eg \\o80\n *  \\x\t- Character code in hex, eg \\x4a\n *  \\u\t- Multibyte character code, eg \\u20ac\n *  \\U\t- Long multibyte character code, eg \\U12345678\n */\nstatic char_u REGEXP_INRANGE[] = \"]^-n\\\\\";\nstatic char_u REGEXP_ABBR[] = \"nrtebdoxuU\";\n\n/*\n * Translate '\\x' to its control character, except \"\\n\", which is Magic.\n */\n    static int\nbackslash_trans(int c)\n{\n    switch (c)\n    {\n\tcase 'r':   return CAR;\n\tcase 't':   return TAB;\n\tcase 'e':   return ESC;\n\tcase 'b':   return BS;\n    }\n    return c;\n}\n\n/*\n * Check for a character class name \"[:name:]\".  \"pp\" points to the '['.\n * Returns one of the CLASS_ items. CLASS_NONE means that no item was\n * recognized.  Otherwise \"pp\" is advanced to after the item.\n */\n    static int\nget_char_class(char_u **pp)\n{\n    static const char *(class_names[]) =\n    {\n\t\"alnum:]\",\n#define CLASS_ALNUM 0\n\t\"alpha:]\",\n#define CLASS_ALPHA 1\n\t\"blank:]\",\n#define CLASS_BLANK 2\n\t\"cntrl:]\",\n#define CLASS_CNTRL 3\n\t\"digit:]\",\n#define CLASS_DIGIT 4\n\t\"graph:]\",\n#define CLASS_GRAPH 5\n\t\"lower:]\",\n#define CLASS_LOWER 6\n\t\"print:]\",\n#define CLASS_PRINT 7\n\t\"punct:]\",\n#define CLASS_PUNCT 8\n\t\"space:]\",\n#define CLASS_SPACE 9\n\t\"upper:]\",\n#define CLASS_UPPER 10\n\t\"xdigit:]\",\n#define CLASS_XDIGIT 11\n\t\"tab:]\",\n#define CLASS_TAB 12\n\t\"return:]\",\n#define CLASS_RETURN 13\n\t\"backspace:]\",\n#define CLASS_BACKSPACE 14\n\t\"escape:]\",\n#define CLASS_ESCAPE 15\n\t\"ident:]\",\n#define CLASS_IDENT 16\n\t\"keyword:]\",\n#define CLASS_KEYWORD 17\n\t\"fname:]\",\n#define CLASS_FNAME 18\n    };\n#define CLASS_NONE 99\n    int i;\n\n    if ((*pp)[1] == ':')\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(class_names); ++i)\n\t    if (STRNCMP(*pp + 2, class_names[i], STRLEN(class_names[i])) == 0)\n\t    {\n\t\t*pp += STRLEN(class_names[i]) + 2;\n\t\treturn i;\n\t    }\n    }\n    return CLASS_NONE;\n}\n\n/*\n * Specific version of character class functions.\n * Using a table to keep this fast.\n */\nstatic short\tclass_tab[256];\n\n#define\t    RI_DIGIT\t0x01\n#define\t    RI_HEX\t0x02\n#define\t    RI_OCTAL\t0x04\n#define\t    RI_WORD\t0x08\n#define\t    RI_HEAD\t0x10\n#define\t    RI_ALPHA\t0x20\n#define\t    RI_LOWER\t0x40\n#define\t    RI_UPPER\t0x80\n#define\t    RI_WHITE\t0x100\n\n    static void\ninit_class_tab(void)\n{\n    int\t\ti;\n    static int\tdone = FALSE;\n\n    if (done)\n\treturn;\n\n    for (i = 0; i < 256; ++i)\n    {\n\tif (i >= '0' && i <= '7')\n\t    class_tab[i] = RI_DIGIT + RI_HEX + RI_OCTAL + RI_WORD;\n\telse if (i >= '8' && i <= '9')\n\t    class_tab[i] = RI_DIGIT + RI_HEX + RI_WORD;\n\telse if (i >= 'a' && i <= 'f')\n\t    class_tab[i] = RI_HEX + RI_WORD + RI_HEAD + RI_ALPHA + RI_LOWER;\n#ifdef EBCDIC\n\telse if ((i >= 'g' && i <= 'i') || (i >= 'j' && i <= 'r')\n\t\t\t\t\t\t    || (i >= 's' && i <= 'z'))\n#else\n\telse if (i >= 'g' && i <= 'z')\n#endif\n\t    class_tab[i] = RI_WORD + RI_HEAD + RI_ALPHA + RI_LOWER;\n\telse if (i >= 'A' && i <= 'F')\n\t    class_tab[i] = RI_HEX + RI_WORD + RI_HEAD + RI_ALPHA + RI_UPPER;\n#ifdef EBCDIC\n\telse if ((i >= 'G' && i <= 'I') || ( i >= 'J' && i <= 'R')\n\t\t\t\t\t\t    || (i >= 'S' && i <= 'Z'))\n#else\n\telse if (i >= 'G' && i <= 'Z')\n#endif\n\t    class_tab[i] = RI_WORD + RI_HEAD + RI_ALPHA + RI_UPPER;\n\telse if (i == '_')\n\t    class_tab[i] = RI_WORD + RI_HEAD;\n\telse\n\t    class_tab[i] = 0;\n    }\n    class_tab[' '] |= RI_WHITE;\n    class_tab['\\t'] |= RI_WHITE;\n    done = TRUE;\n}\n\n#define ri_digit(c)\t(c < 0x100 && (class_tab[c] & RI_DIGIT))\n#define ri_hex(c)\t(c < 0x100 && (class_tab[c] & RI_HEX))\n#define ri_octal(c)\t(c < 0x100 && (class_tab[c] & RI_OCTAL))\n#define ri_word(c)\t(c < 0x100 && (class_tab[c] & RI_WORD))\n#define ri_head(c)\t(c < 0x100 && (class_tab[c] & RI_HEAD))\n#define ri_alpha(c)\t(c < 0x100 && (class_tab[c] & RI_ALPHA))\n#define ri_lower(c)\t(c < 0x100 && (class_tab[c] & RI_LOWER))\n#define ri_upper(c)\t(c < 0x100 && (class_tab[c] & RI_UPPER))\n#define ri_white(c)\t(c < 0x100 && (class_tab[c] & RI_WHITE))\n\n// flags for regflags\n#define RF_ICASE    1\t// ignore case\n#define RF_NOICASE  2\t// don't ignore case\n#define RF_HASNL    4\t// can match a NL\n#define RF_ICOMBINE 8\t// ignore combining characters\n#define RF_LOOKBH   16\t// uses \"\\@<=\" or \"\\@<!\"\n\n/*\n * Global work variables for vim_regcomp().\n */\n\nstatic char_u\t*regparse;\t// Input-scan pointer.\nstatic int\tregnpar;\t// () count.\nstatic int\twants_nfa;\t// regex should use NFA engine\n#ifdef FEAT_SYN_HL\nstatic int\tregnzpar;\t// \\z() count.\nstatic int\tre_has_z;\t// \\z item detected\n#endif\nstatic unsigned\tregflags;\t// RF_ flags for prog\n#if defined(FEAT_SYN_HL) || defined(PROTO)\nstatic int\thad_eol;\t// TRUE when EOL found by vim_regcomp()\n#endif\n\nstatic magic_T\treg_magic;\t// magicness of the pattern\n\nstatic int\treg_string;\t// matching with a string instead of a buffer\n\t\t\t\t// line\nstatic int\treg_strict;\t// \"[abc\" is illegal\n\n/*\n * META contains all characters that may be magic, except '^' and '$'.\n */\n\n#ifdef EBCDIC\nstatic char_u META[] = \"%&()*+.123456789<=>?@ACDFHIKLMOPSUVWX[_acdfhiklmnopsuvwxz{|~\";\n#else\n// META[] is used often enough to justify turning it into a table.\nstatic char_u META_flags[] = {\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n//\t\t   %  &     (  )  *  +\t      .\n    0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0,\n//     1  2  3\t4  5  6  7  8  9\t<  =  >  ?\n    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1,\n//  @  A     C\tD     F     H  I     K\tL  M\t O\n    1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1,\n//  P\t     S\t   U  V  W  X\t  Z  [\t\t _\n    1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1,\n//     a     c\td     f     h  i     k\tl  m  n  o\n    0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1,\n//  p\t     s\t   u  v  w  x\t  z  {\t|     ~\n    1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1\n};\n#endif\n\nstatic int\tcurchr;\t\t// currently parsed character\n// Previous character.  Note: prevchr is sometimes -1 when we are not at the\n// start, eg in /[ ^I]^ the pattern was never found even if it existed,\n// because ^ was taken to be magic -- webb\nstatic int\tprevchr;\nstatic int\tprevprevchr;\t// previous-previous character\nstatic int\tnextchr;\t// used for ungetchr()\n\n// arguments for reg()\n#define REG_NOPAREN\t0\t// toplevel reg()\n#define REG_PAREN\t1\t// \\(\\)\n#define REG_ZPAREN\t2\t// \\z(\\)\n#define REG_NPAREN\t3\t// \\%(\\)\n\ntypedef struct\n{\n     char_u\t*regparse;\n     int\tprevchr_len;\n     int\tcurchr;\n     int\tprevchr;\n     int\tprevprevchr;\n     int\tnextchr;\n     int\tat_start;\n     int\tprev_at_start;\n     int\tregnpar;\n} parse_state_T;\n\nstatic void\tinitchr(char_u *);\nstatic int\tgetchr(void);\nstatic void\tskipchr_keepstart(void);\nstatic int\tpeekchr(void);\nstatic void\tskipchr(void);\nstatic void\tungetchr(void);\nstatic long\tgethexchrs(int maxinputlen);\nstatic long\tgetoctchrs(void);\nstatic long\tgetdecchrs(void);\nstatic int\tcoll_get_char(void);\nstatic int\tprog_magic_wrong(void);\nstatic int\tcstrncmp(char_u *s1, char_u *s2, int *n);\nstatic char_u\t*cstrchr(char_u *, int);\nstatic int\tre_mult_next(char *what);\nstatic int\treg_iswordc(int);\n#ifdef FEAT_EVAL\nstatic void report_re_switch(char_u *pat);\n#endif\n\nstatic regengine_T bt_regengine;\nstatic regengine_T nfa_regengine;\n\n/*\n * Return TRUE if compiled regular expression \"prog\" can match a line break.\n */\n    int\nre_multiline(regprog_T *prog)\n{\n    return (prog->regflags & RF_HASNL);\n}\n\n/*\n * Check for an equivalence class name \"[=a=]\".  \"pp\" points to the '['.\n * Returns a character representing the class. Zero means that no item was\n * recognized.  Otherwise \"pp\" is advanced to after the item.\n */\n    static int\nget_equi_class(char_u **pp)\n{\n    int\t\tc;\n    int\t\tl = 1;\n    char_u\t*p = *pp;\n\n    if (p[1] == '=' && p[2] != NUL)\n    {\n\tif (has_mbyte)\n\t    l = (*mb_ptr2len)(p + 2);\n\tif (p[l + 2] == '=' && p[l + 3] == ']')\n\t{\n\t    if (has_mbyte)\n\t\tc = mb_ptr2char(p + 2);\n\t    else\n\t\tc = p[2];\n\t    *pp += l + 4;\n\t    return c;\n\t}\n    }\n    return 0;\n}\n\n#ifdef EBCDIC\n/*\n * Table for equivalence class \"c\". (IBM-1047)\n */\nstatic char *EQUIVAL_CLASS_C[16] = {\n    \"A\\x62\\x63\\x64\\x65\\x66\\x67\",\n    \"C\\x68\",\n    \"E\\x71\\x72\\x73\\x74\",\n    \"I\\x75\\x76\\x77\\x78\",\n    \"N\\x69\",\n    \"O\\xEB\\xEC\\xED\\xEE\\xEF\\x80\",\n    \"U\\xFB\\xFC\\xFD\\xFE\",\n    \"Y\\xBA\",\n    \"a\\x42\\x43\\x44\\x45\\x46\\x47\",\n    \"c\\x48\",\n    \"e\\x51\\x52\\x53\\x54\",\n    \"i\\x55\\x56\\x57\\x58\",\n    \"n\\x49\",\n    \"o\\xCB\\xCC\\xCD\\xCE\\xCF\\x70\",\n    \"u\\xDB\\xDC\\xDD\\xDE\",\n    \"y\\x8D\\xDF\",\n};\n#endif\n\n/*\n * Check for a collating element \"[.a.]\".  \"pp\" points to the '['.\n * Returns a character. Zero means that no item was recognized.  Otherwise\n * \"pp\" is advanced to after the item.\n * Currently only single characters are recognized!\n */\n    static int\nget_coll_element(char_u **pp)\n{\n    int\t\tc;\n    int\t\tl = 1;\n    char_u\t*p = *pp;\n\n    if (p[0] != NUL && p[1] == '.' && p[2] != NUL)\n    {\n\tif (has_mbyte)\n\t    l = (*mb_ptr2len)(p + 2);\n\tif (p[l + 2] == '.' && p[l + 3] == ']')\n\t{\n\t    if (has_mbyte)\n\t\tc = mb_ptr2char(p + 2);\n\t    else\n\t\tc = p[2];\n\t    *pp += l + 4;\n\t    return c;\n\t}\n    }\n    return 0;\n}\n\nstatic int reg_cpo_lit; // 'cpoptions' contains 'l' flag\nstatic int reg_cpo_bsl; // 'cpoptions' contains '\\' flag\n\n    static void\nget_cpo_flags(void)\n{\n    reg_cpo_lit = vim_strchr(p_cpo, CPO_LITERAL) != NULL;\n    reg_cpo_bsl = vim_strchr(p_cpo, CPO_BACKSL) != NULL;\n}\n\n/*\n * Skip over a \"[]\" range.\n * \"p\" must point to the character after the '['.\n * The returned pointer is on the matching ']', or the terminating NUL.\n */\n    static char_u *\nskip_anyof(char_u *p)\n{\n    int\t\tl;\n\n    if (*p == '^')\t// Complement of range.\n\t++p;\n    if (*p == ']' || *p == '-')\n\t++p;\n    while (*p != NUL && *p != ']')\n    {\n\tif (has_mbyte && (l = (*mb_ptr2len)(p)) > 1)\n\t    p += l;\n\telse\n\t    if (*p == '-')\n\t    {\n\t\t++p;\n\t\tif (*p != ']' && *p != NUL)\n\t\t    MB_PTR_ADV(p);\n\t    }\n\telse if (*p == '\\\\'\n\t\t&& !reg_cpo_bsl\n\t\t&& (vim_strchr(REGEXP_INRANGE, p[1]) != NULL\n\t\t    || (!reg_cpo_lit && vim_strchr(REGEXP_ABBR, p[1]) != NULL)))\n\t    p += 2;\n\telse if (*p == '[')\n\t{\n\t    if (get_char_class(&p) == CLASS_NONE\n\t\t    && get_equi_class(&p) == 0\n\t\t    && get_coll_element(&p) == 0\n\t\t    && *p != NUL)\n\t\t++p; // it is not a class name and not NUL\n\t}\n\telse\n\t    ++p;\n    }\n\n    return p;\n}\n\n/*\n * Skip past regular expression.\n * Stop at end of \"startp\" or where \"delim\" is found ('/', '?', etc).\n * Take care of characters with a backslash in front of it.\n * Skip strings inside [ and ].\n */\n    char_u *\nskip_regexp(\n    char_u\t*startp,\n    int\t\tdelim,\n    int\t\tmagic)\n{\n    return skip_regexp_ex(startp, delim, magic, NULL, NULL, NULL);\n}\n\n/*\n * Call skip_regexp() and when the delimiter does not match give an error and\n * return NULL.\n */\n    char_u *\nskip_regexp_err(\n    char_u\t*startp,\n    int\t\tdelim,\n    int\t\tmagic)\n{\n    char_u *p = skip_regexp(startp, delim, magic);\n\n    if (*p != delim)\n    {\n\tsemsg(_(\"E654: missing delimiter after search pattern: %s\"), startp);\n\treturn NULL;\n    }\n    return p;\n}\n\n/*\n * skip_regexp() with extra arguments:\n * When \"newp\" is not NULL and \"dirc\" is '?', make an allocated copy of the\n * expression and change \"\\?\" to \"?\".  If \"*newp\" is not NULL the expression\n * is changed in-place.\n * If a \"\\?\" is changed to \"?\" then \"dropped\" is incremented, unless NULL.\n * If \"magic_val\" is not NULL, returns the effective magicness of the pattern\n */\n    char_u *\nskip_regexp_ex(\n    char_u\t*startp,\n    int\t\tdirc,\n    int\t\tmagic,\n    char_u\t**newp,\n    int\t\t*dropped,\n    magic_T\t*magic_val)\n{\n    magic_T\tmymagic;\n    char_u\t*p = startp;\n\n    if (magic)\n\tmymagic = MAGIC_ON;\n    else\n\tmymagic = MAGIC_OFF;\n    get_cpo_flags();\n\n    for (; p[0] != NUL; MB_PTR_ADV(p))\n    {\n\tif (p[0] == dirc)\t// found end of regexp\n\t    break;\n\tif ((p[0] == '[' && mymagic >= MAGIC_ON)\n\t\t|| (p[0] == '\\\\' && p[1] == '[' && mymagic <= MAGIC_OFF))\n\t{\n\t    p = skip_anyof(p + 1);\n\t    if (p[0] == NUL)\n\t\tbreak;\n\t}\n\telse if (p[0] == '\\\\' && p[1] != NUL)\n\t{\n\t    if (dirc == '?' && newp != NULL && p[1] == '?')\n\t    {\n\t\t// change \"\\?\" to \"?\", make a copy first.\n\t\tif (*newp == NULL)\n\t\t{\n\t\t    *newp = vim_strsave(startp);\n\t\t    if (*newp != NULL)\n\t\t\tp = *newp + (p - startp);\n\t\t}\n\t\tif (dropped != NULL)\n\t\t    ++*dropped;\n\t\tif (*newp != NULL)\n\t\t    STRMOVE(p, p + 1);\n\t\telse\n\t\t    ++p;\n\t    }\n\t    else\n\t\t++p;    // skip next character\n\t    if (*p == 'v')\n\t\tmymagic = MAGIC_ALL;\n\t    else if (*p == 'V')\n\t\tmymagic = MAGIC_NONE;\n\t}\n    }\n    if (magic_val != NULL)\n\t*magic_val = mymagic;\n    return p;\n}\n\n/*\n * Functions for getting characters from the regexp input.\n */\nstatic int\tprevchr_len;\t// byte length of previous char\nstatic int\tat_start;\t// True when on the first character\nstatic int\tprev_at_start;  // True when on the second character\n\n/*\n * Start parsing at \"str\".\n */\n    static void\ninitchr(char_u *str)\n{\n    regparse = str;\n    prevchr_len = 0;\n    curchr = prevprevchr = prevchr = nextchr = -1;\n    at_start = TRUE;\n    prev_at_start = FALSE;\n}\n\n/*\n * Save the current parse state, so that it can be restored and parsing\n * starts in the same state again.\n */\n    static void\nsave_parse_state(parse_state_T *ps)\n{\n    ps->regparse = regparse;\n    ps->prevchr_len = prevchr_len;\n    ps->curchr = curchr;\n    ps->prevchr = prevchr;\n    ps->prevprevchr = prevprevchr;\n    ps->nextchr = nextchr;\n    ps->at_start = at_start;\n    ps->prev_at_start = prev_at_start;\n    ps->regnpar = regnpar;\n}\n\n/*\n * Restore a previously saved parse state.\n */\n    static void\nrestore_parse_state(parse_state_T *ps)\n{\n    regparse = ps->regparse;\n    prevchr_len = ps->prevchr_len;\n    curchr = ps->curchr;\n    prevchr = ps->prevchr;\n    prevprevchr = ps->prevprevchr;\n    nextchr = ps->nextchr;\n    at_start = ps->at_start;\n    prev_at_start = ps->prev_at_start;\n    regnpar = ps->regnpar;\n}\n\n\n/*\n * Get the next character without advancing.\n */\n    static int\npeekchr(void)\n{\n    static int\tafter_slash = FALSE;\n\n    if (curchr == -1)\n    {\n\tswitch (curchr = regparse[0])\n\t{\n\tcase '.':\n\tcase '[':\n\tcase '~':\n\t    // magic when 'magic' is on\n\t    if (reg_magic >= MAGIC_ON)\n\t\tcurchr = Magic(curchr);\n\t    break;\n\tcase '(':\n\tcase ')':\n\tcase '{':\n\tcase '%':\n\tcase '+':\n\tcase '=':\n\tcase '?':\n\tcase '@':\n\tcase '!':\n\tcase '&':\n\tcase '|':\n\tcase '<':\n\tcase '>':\n\tcase '#':\t// future ext.\n\tcase '\"':\t// future ext.\n\tcase '\\'':\t// future ext.\n\tcase ',':\t// future ext.\n\tcase '-':\t// future ext.\n\tcase ':':\t// future ext.\n\tcase ';':\t// future ext.\n\tcase '`':\t// future ext.\n\tcase '/':\t// Can't be used in / command\n\t    // magic only after \"\\v\"\n\t    if (reg_magic == MAGIC_ALL)\n\t\tcurchr = Magic(curchr);\n\t    break;\n\tcase '*':\n\t    // * is not magic as the very first character, eg \"?*ptr\", when\n\t    // after '^', eg \"/^*ptr\" and when after \"\\(\", \"\\|\", \"\\&\".  But\n\t    // \"\\(\\*\" is not magic, thus must be magic if \"after_slash\"\n\t    if (reg_magic >= MAGIC_ON\n\t\t    && !at_start\n\t\t    && !(prev_at_start && prevchr == Magic('^'))\n\t\t    && (after_slash\n\t\t\t|| (prevchr != Magic('(')\n\t\t\t    && prevchr != Magic('&')\n\t\t\t    && prevchr != Magic('|'))))\n\t\tcurchr = Magic('*');\n\t    break;\n\tcase '^':\n\t    // '^' is only magic as the very first character and if it's after\n\t    // \"\\(\", \"\\|\", \"\\&' or \"\\n\"\n\t    if (reg_magic >= MAGIC_OFF\n\t\t    && (at_start\n\t\t\t|| reg_magic == MAGIC_ALL\n\t\t\t|| prevchr == Magic('(')\n\t\t\t|| prevchr == Magic('|')\n\t\t\t|| prevchr == Magic('&')\n\t\t\t|| prevchr == Magic('n')\n\t\t\t|| (no_Magic(prevchr) == '('\n\t\t\t    && prevprevchr == Magic('%'))))\n\t    {\n\t\tcurchr = Magic('^');\n\t\tat_start = TRUE;\n\t\tprev_at_start = FALSE;\n\t    }\n\t    break;\n\tcase '$':\n\t    // '$' is only magic as the very last char and if it's in front of\n\t    // either \"\\|\", \"\\)\", \"\\&\", or \"\\n\"\n\t    if (reg_magic >= MAGIC_OFF)\n\t    {\n\t\tchar_u *p = regparse + 1;\n\t\tint is_magic_all = (reg_magic == MAGIC_ALL);\n\n\t\t// ignore \\c \\C \\m \\M \\v \\V and \\Z after '$'\n\t\twhile (p[0] == '\\\\' && (p[1] == 'c' || p[1] == 'C'\n\t\t\t\t|| p[1] == 'm' || p[1] == 'M'\n\t\t\t\t|| p[1] == 'v' || p[1] == 'V' || p[1] == 'Z'))\n\t\t{\n\t\t    if (p[1] == 'v')\n\t\t\tis_magic_all = TRUE;\n\t\t    else if (p[1] == 'm' || p[1] == 'M' || p[1] == 'V')\n\t\t\tis_magic_all = FALSE;\n\t\t    p += 2;\n\t\t}\n\t\tif (p[0] == NUL\n\t\t\t|| (p[0] == '\\\\'\n\t\t\t    && (p[1] == '|' || p[1] == '&' || p[1] == ')'\n\t\t\t\t|| p[1] == 'n'))\n\t\t\t|| (is_magic_all\n\t\t\t       && (p[0] == '|' || p[0] == '&' || p[0] == ')'))\n\t\t\t|| reg_magic == MAGIC_ALL)\n\t\t    curchr = Magic('$');\n\t    }\n\t    break;\n\tcase '\\\\':\n\t    {\n\t\tint c = regparse[1];\n\n\t\tif (c == NUL)\n\t\t    curchr = '\\\\';\t// trailing '\\'\n\t\telse if (\n#ifdef EBCDIC\n\t\t\tvim_strchr(META, c)\n#else\n\t\t\tc <= '~' && META_flags[c]\n#endif\n\t\t\t)\n\t\t{\n\t\t    /*\n\t\t     * META contains everything that may be magic sometimes,\n\t\t     * except ^ and $ (\"\\^\" and \"\\$\" are only magic after\n\t\t     * \"\\V\").  We now fetch the next character and toggle its\n\t\t     * magicness.  Therefore, \\ is so meta-magic that it is\n\t\t     * not in META.\n\t\t     */\n\t\t    curchr = -1;\n\t\t    prev_at_start = at_start;\n\t\t    at_start = FALSE;\t// be able to say \"/\\*ptr\"\n\t\t    ++regparse;\n\t\t    ++after_slash;\n\t\t    peekchr();\n\t\t    --regparse;\n\t\t    --after_slash;\n\t\t    curchr = toggle_Magic(curchr);\n\t\t}\n\t\telse if (vim_strchr(REGEXP_ABBR, c))\n\t\t{\n\t\t    /*\n\t\t     * Handle abbreviations, like \"\\t\" for TAB -- webb\n\t\t     */\n\t\t    curchr = backslash_trans(c);\n\t\t}\n\t\telse if (reg_magic == MAGIC_NONE && (c == '$' || c == '^'))\n\t\t    curchr = toggle_Magic(c);\n\t\telse\n\t\t{\n\t\t    /*\n\t\t     * Next character can never be (made) magic?\n\t\t     * Then backslashing it won't do anything.\n\t\t     */\n\t\t    if (has_mbyte)\n\t\t\tcurchr = (*mb_ptr2char)(regparse + 1);\n\t\t    else\n\t\t\tcurchr = c;\n\t\t}\n\t\tbreak;\n\t    }\n\n\tdefault:\n\t    if (has_mbyte)\n\t\tcurchr = (*mb_ptr2char)(regparse);\n\t}\n    }\n\n    return curchr;\n}\n\n/*\n * Eat one lexed character.  Do this in a way that we can undo it.\n */\n    static void\nskipchr(void)\n{\n    // peekchr() eats a backslash, do the same here\n    if (*regparse == '\\\\')\n\tprevchr_len = 1;\n    else\n\tprevchr_len = 0;\n    if (regparse[prevchr_len] != NUL)\n    {\n\tif (enc_utf8)\n\t    // exclude composing chars that mb_ptr2len does include\n\t    prevchr_len += utf_ptr2len(regparse + prevchr_len);\n\telse if (has_mbyte)\n\t    prevchr_len += (*mb_ptr2len)(regparse + prevchr_len);\n\telse\n\t    ++prevchr_len;\n    }\n    regparse += prevchr_len;\n    prev_at_start = at_start;\n    at_start = FALSE;\n    prevprevchr = prevchr;\n    prevchr = curchr;\n    curchr = nextchr;\t    // use previously unget char, or -1\n    nextchr = -1;\n}\n\n/*\n * Skip a character while keeping the value of prev_at_start for at_start.\n * prevchr and prevprevchr are also kept.\n */\n    static void\nskipchr_keepstart(void)\n{\n    int as = prev_at_start;\n    int pr = prevchr;\n    int prpr = prevprevchr;\n\n    skipchr();\n    at_start = as;\n    prevchr = pr;\n    prevprevchr = prpr;\n}\n\n/*\n * Get the next character from the pattern. We know about magic and such, so\n * therefore we need a lexical analyzer.\n */\n    static int\ngetchr(void)\n{\n    int chr = peekchr();\n\n    skipchr();\n    return chr;\n}\n\n/*\n * put character back.  Works only once!\n */\n    static void\nungetchr(void)\n{\n    nextchr = curchr;\n    curchr = prevchr;\n    prevchr = prevprevchr;\n    at_start = prev_at_start;\n    prev_at_start = FALSE;\n\n    // Backup regparse, so that it's at the same position as before the\n    // getchr().\n    regparse -= prevchr_len;\n}\n\n/*\n * Get and return the value of the hex string at the current position.\n * Return -1 if there is no valid hex number.\n * The position is updated:\n *     blahblah\\%x20asdf\n *\t   before-^ ^-after\n * The parameter controls the maximum number of input characters. This will be\n * 2 when reading a \\%x20 sequence and 4 when reading a \\%u20AC sequence.\n */\n    static long\ngethexchrs(int maxinputlen)\n{\n    long_u\tnr = 0;\n    int\t\tc;\n    int\t\ti;\n\n    for (i = 0; i < maxinputlen; ++i)\n    {\n\tc = regparse[0];\n\tif (!vim_isxdigit(c))\n\t    break;\n\tnr <<= 4;\n\tnr |= hex2nr(c);\n\t++regparse;\n    }\n\n    if (i == 0)\n\treturn -1;\n    return (long)nr;\n}\n\n/*\n * Get and return the value of the decimal string immediately after the\n * current position. Return -1 for invalid.  Consumes all digits.\n */\n    static long\ngetdecchrs(void)\n{\n    long_u\tnr = 0;\n    int\t\tc;\n    int\t\ti;\n\n    for (i = 0; ; ++i)\n    {\n\tc = regparse[0];\n\tif (c < '0' || c > '9')\n\t    break;\n\tnr *= 10;\n\tnr += c - '0';\n\t++regparse;\n\tcurchr = -1; // no longer valid\n    }\n\n    if (i == 0)\n\treturn -1;\n    return (long)nr;\n}\n\n/*\n * get and return the value of the octal string immediately after the current\n * position. Return -1 for invalid, or 0-255 for valid. Smart enough to handle\n * numbers > 377 correctly (for example, 400 is treated as 40) and doesn't\n * treat 8 or 9 as recognised characters. Position is updated:\n *     blahblah\\%o210asdf\n *\t   before-^  ^-after\n */\n    static long\ngetoctchrs(void)\n{\n    long_u\tnr = 0;\n    int\t\tc;\n    int\t\ti;\n\n    for (i = 0; i < 3 && nr < 040; ++i)\n    {\n\tc = regparse[0];\n\tif (c < '0' || c > '7')\n\t    break;\n\tnr <<= 3;\n\tnr |= hex2nr(c);\n\t++regparse;\n    }\n\n    if (i == 0)\n\treturn -1;\n    return (long)nr;\n}\n\n/*\n * read_limits - Read two integers to be taken as a minimum and maximum.\n * If the first character is '-', then the range is reversed.\n * Should end with 'end'.  If minval is missing, zero is default, if maxval is\n * missing, a very big number is the default.\n */\n    static int\nread_limits(long *minval, long *maxval)\n{\n    int\t\treverse = FALSE;\n    char_u\t*first_char;\n    long\ttmp;\n\n    if (*regparse == '-')\n    {\n\t// Starts with '-', so reverse the range later\n\tregparse++;\n\treverse = TRUE;\n    }\n    first_char = regparse;\n    *minval = getdigits(&regparse);\n    if (*regparse == ',')\t    // There is a comma\n    {\n\tif (vim_isdigit(*++regparse))\n\t    *maxval = getdigits(&regparse);\n\telse\n\t    *maxval = MAX_LIMIT;\n    }\n    else if (VIM_ISDIGIT(*first_char))\n\t*maxval = *minval;\t    // It was \\{n} or \\{-n}\n    else\n\t*maxval = MAX_LIMIT;\t    // It was \\{} or \\{-}\n    if (*regparse == '\\\\')\n\tregparse++;\t// Allow either \\{...} or \\{...\\}\n    if (*regparse != '}')\n\tEMSG2_RET_FAIL(_(\"E554: Syntax error in %s{...}\"),\n\t\t\t\t\t\t       reg_magic == MAGIC_ALL);\n\n    /*\n     * Reverse the range if there was a '-', or make sure it is in the right\n     * order otherwise.\n     */\n    if ((!reverse && *minval > *maxval) || (reverse && *minval < *maxval))\n    {\n\ttmp = *minval;\n\t*minval = *maxval;\n\t*maxval = tmp;\n    }\n    skipchr();\t\t// let's be friends with the lexer again\n    return OK;\n}\n\n/*\n * vim_regexec and friends\n */\n\n/*\n * Global work variables for vim_regexec().\n */\n\nstatic void\tcleanup_subexpr(void);\n#ifdef FEAT_SYN_HL\nstatic void\tcleanup_zsubexpr(void);\n#endif\nstatic void\treg_nextline(void);\nstatic int\tmatch_with_backref(linenr_T start_lnum, colnr_T start_col, linenr_T end_lnum, colnr_T end_col, int *bytelen);\n\n/*\n * Sometimes need to save a copy of a line.  Since alloc()/free() is very\n * slow, we keep one allocated piece of memory and only re-allocate it when\n * it's too small.  It's freed in bt_regexec_both() when finished.\n */\nstatic char_u\t*reg_tofree = NULL;\nstatic unsigned\treg_tofreelen;\n\n/*\n * Structure used to store the execution state of the regex engine.\n * Which ones are set depends on whether a single-line or multi-line match is\n * done:\n *\t\t\tsingle-line\t\tmulti-line\n * reg_match\t\t&regmatch_T\t\tNULL\n * reg_mmatch\t\tNULL\t\t\t&regmmatch_T\n * reg_startp\t\treg_match->startp\t<invalid>\n * reg_endp\t\treg_match->endp\t\t<invalid>\n * reg_startpos\t\t<invalid>\t\treg_mmatch->startpos\n * reg_endpos\t\t<invalid>\t\treg_mmatch->endpos\n * reg_win\t\tNULL\t\t\twindow in which to search\n * reg_buf\t\tcurbuf\t\t\tbuffer in which to search\n * reg_firstlnum\t<invalid>\t\tfirst line in which to search\n * reg_maxline\t\t0\t\t\tlast line nr\n * reg_line_lbr\t\tFALSE or TRUE\t\tFALSE\n */\ntypedef struct {\n    regmatch_T\t\t*reg_match;\n    regmmatch_T\t\t*reg_mmatch;\n    char_u\t\t**reg_startp;\n    char_u\t\t**reg_endp;\n    lpos_T\t\t*reg_startpos;\n    lpos_T\t\t*reg_endpos;\n    win_T\t\t*reg_win;\n    buf_T\t\t*reg_buf;\n    linenr_T\t\treg_firstlnum;\n    linenr_T\t\treg_maxline;\n    int\t\t\treg_line_lbr;\t// \"\\n\" in string is line break\n\n    // The current match-position is stord in these variables:\n    linenr_T\tlnum;\t\t// line number, relative to first line\n    char_u\t*line;\t\t// start of current line\n    char_u\t*input;\t\t// current input, points into \"line\"\n\n    int\tneed_clear_subexpr;\t// subexpressions still need to be cleared\n#ifdef FEAT_SYN_HL\n    int\tneed_clear_zsubexpr;\t// extmatch subexpressions still need to be\n\t\t\t\t// cleared\n#endif\n\n    // Internal copy of 'ignorecase'.  It is set at each call to vim_regexec().\n    // Normally it gets the value of \"rm_ic\" or \"rmm_ic\", but when the pattern\n    // contains '\\c' or '\\C' the value is overruled.\n    int\t\t\treg_ic;\n\n    // Similar to \"reg_ic\", but only for 'combining' characters.  Set with \\Z\n    // flag in the regexp.  Defaults to false, always.\n    int\t\t\treg_icombine;\n\n    // Copy of \"rmm_maxcol\": maximum column to search for a match.  Zero when\n    // there is no maximum.\n    colnr_T\t\treg_maxcol;\n\n    // State for the NFA engine regexec.\n    int nfa_has_zend;\t    // NFA regexp \\ze operator encountered.\n    int nfa_has_backref;    // NFA regexp \\1 .. \\9 encountered.\n    int nfa_nsubexpr;\t    // Number of sub expressions actually being used\n\t\t\t    // during execution. 1 if only the whole match\n\t\t\t    // (subexpr 0) is used.\n    // listid is global, so that it increases on recursive calls to\n    // nfa_regmatch(), which means we don't have to clear the lastlist field of\n    // all the states.\n    int nfa_listid;\n    int nfa_alt_listid;\n\n#ifdef FEAT_SYN_HL\n    int nfa_has_zsubexpr;   // NFA regexp has \\z( ), set zsubexpr.\n#endif\n} regexec_T;\n\nstatic regexec_T\trex;\nstatic int\t\trex_in_use = FALSE;\n\n/*\n * Return TRUE if character 'c' is included in 'iskeyword' option for\n * \"reg_buf\" buffer.\n */\n    static int\nreg_iswordc(int c)\n{\n    return vim_iswordc_buf(c, rex.reg_buf);\n}\n\n/*\n * Get pointer to the line \"lnum\", which is relative to \"reg_firstlnum\".\n */\n    static char_u *\nreg_getline(linenr_T lnum)\n{\n    // when looking behind for a match/no-match lnum is negative.  But we\n    // can't go before line 1\n    if (rex.reg_firstlnum + lnum < 1)\n\treturn NULL;\n    if (lnum > rex.reg_maxline)\n\t// Must have matched the \"\\n\" in the last line.\n\treturn (char_u *)\"\";\n    return ml_get_buf(rex.reg_buf, rex.reg_firstlnum + lnum, FALSE);\n}\n\n#ifdef FEAT_SYN_HL\nstatic char_u\t*reg_startzp[NSUBEXP];\t// Workspace to mark beginning\nstatic char_u\t*reg_endzp[NSUBEXP];\t//   and end of \\z(...\\) matches\nstatic lpos_T\treg_startzpos[NSUBEXP];\t// idem, beginning pos\nstatic lpos_T\treg_endzpos[NSUBEXP];\t// idem, end pos\n#endif\n\n// TRUE if using multi-line regexp.\n#define REG_MULTI\t(rex.reg_match == NULL)\n\n#ifdef FEAT_SYN_HL\n/*\n * Create a new extmatch and mark it as referenced once.\n */\n    static reg_extmatch_T *\nmake_extmatch(void)\n{\n    reg_extmatch_T\t*em;\n\n    em = ALLOC_CLEAR_ONE(reg_extmatch_T);\n    if (em != NULL)\n\tem->refcnt = 1;\n    return em;\n}\n\n/*\n * Add a reference to an extmatch.\n */\n    reg_extmatch_T *\nref_extmatch(reg_extmatch_T *em)\n{\n    if (em != NULL)\n\tem->refcnt++;\n    return em;\n}\n\n/*\n * Remove a reference to an extmatch.  If there are no references left, free\n * the info.\n */\n    void\nunref_extmatch(reg_extmatch_T *em)\n{\n    int i;\n\n    if (em != NULL && --em->refcnt <= 0)\n    {\n\tfor (i = 0; i < NSUBEXP; ++i)\n\t    vim_free(em->matches[i]);\n\tvim_free(em);\n    }\n}\n#endif\n\n/*\n * Get class of previous character.\n */\n    static int\nreg_prev_class(void)\n{\n    if (rex.input > rex.line)\n\treturn mb_get_class_buf(rex.input - 1\n\t\t       - (*mb_head_off)(rex.line, rex.input - 1), rex.reg_buf);\n    return -1;\n}\n\n/*\n * Return TRUE if the current rex.input position matches the Visual area.\n */\n    static int\nreg_match_visual(void)\n{\n    pos_T\ttop, bot;\n    linenr_T    lnum;\n    colnr_T\tcol;\n    win_T\t*wp = rex.reg_win == NULL ? curwin : rex.reg_win;\n    int\t\tmode;\n    colnr_T\tstart, end;\n    colnr_T\tstart2, end2;\n    colnr_T\tcols;\n    colnr_T\tcurswant;\n\n    // Check if the buffer is the current buffer.\n    if (rex.reg_buf != curbuf || VIsual.lnum == 0)\n\treturn FALSE;\n\n    if (VIsual_active)\n    {\n\tif (LT_POS(VIsual, wp->w_cursor))\n\t{\n\t    top = VIsual;\n\t    bot = wp->w_cursor;\n\t}\n\telse\n\t{\n\t    top = wp->w_cursor;\n\t    bot = VIsual;\n\t}\n\tmode = VIsual_mode;\n\tcurswant = wp->w_curswant;\n    }\n    else\n    {\n\tif (LT_POS(curbuf->b_visual.vi_start, curbuf->b_visual.vi_end))\n\t{\n\t    top = curbuf->b_visual.vi_start;\n\t    bot = curbuf->b_visual.vi_end;\n\t}\n\telse\n\t{\n\t    top = curbuf->b_visual.vi_end;\n\t    bot = curbuf->b_visual.vi_start;\n\t}\n\tmode = curbuf->b_visual.vi_mode;\n\tcurswant = curbuf->b_visual.vi_curswant;\n    }\n    lnum = rex.lnum + rex.reg_firstlnum;\n    if (lnum < top.lnum || lnum > bot.lnum)\n\treturn FALSE;\n\n    if (mode == 'v')\n    {\n\tcol = (colnr_T)(rex.input - rex.line);\n\tif ((lnum == top.lnum && col < top.col)\n\t\t|| (lnum == bot.lnum && col >= bot.col + (*p_sel != 'e')))\n\t    return FALSE;\n    }\n    else if (mode == Ctrl_V)\n    {\n\tgetvvcol(wp, &top, &start, NULL, &end);\n\tgetvvcol(wp, &bot, &start2, NULL, &end2);\n\tif (start2 < start)\n\t    start = start2;\n\tif (end2 > end)\n\t    end = end2;\n\tif (top.col == MAXCOL || bot.col == MAXCOL || curswant == MAXCOL)\n\t    end = MAXCOL;\n\tcols = win_linetabsize(wp, rex.line, (colnr_T)(rex.input - rex.line));\n\tif (cols < start || cols > end - (*p_sel == 'e'))\n\t    return FALSE;\n    }\n    return TRUE;\n}\n\n/*\n * Check the regexp program for its magic number.\n * Return TRUE if it's wrong.\n */\n    static int\nprog_magic_wrong(void)\n{\n    regprog_T\t*prog;\n\n    prog = REG_MULTI ? rex.reg_mmatch->regprog : rex.reg_match->regprog;\n    if (prog->engine == &nfa_regengine)\n\t// For NFA matcher we don't check the magic\n\treturn FALSE;\n\n    if (UCHARAT(((bt_regprog_T *)prog)->program) != REGMAGIC)\n    {\n\temsg(_(e_corrupted_regexp_program));\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Cleanup the subexpressions, if this wasn't done yet.\n * This construction is used to clear the subexpressions only when they are\n * used (to increase speed).\n */\n    static void\ncleanup_subexpr(void)\n{\n    if (rex.need_clear_subexpr)\n    {\n\tif (REG_MULTI)\n\t{\n\t    // Use 0xff to set lnum to -1\n\t    vim_memset(rex.reg_startpos, 0xff, sizeof(lpos_T) * NSUBEXP);\n\t    vim_memset(rex.reg_endpos, 0xff, sizeof(lpos_T) * NSUBEXP);\n\t}\n\telse\n\t{\n\t    vim_memset(rex.reg_startp, 0, sizeof(char_u *) * NSUBEXP);\n\t    vim_memset(rex.reg_endp, 0, sizeof(char_u *) * NSUBEXP);\n\t}\n\trex.need_clear_subexpr = FALSE;\n    }\n}\n\n#ifdef FEAT_SYN_HL\n    static void\ncleanup_zsubexpr(void)\n{\n    if (rex.need_clear_zsubexpr)\n    {\n\tif (REG_MULTI)\n\t{\n\t    // Use 0xff to set lnum to -1\n\t    vim_memset(reg_startzpos, 0xff, sizeof(lpos_T) * NSUBEXP);\n\t    vim_memset(reg_endzpos, 0xff, sizeof(lpos_T) * NSUBEXP);\n\t}\n\telse\n\t{\n\t    vim_memset(reg_startzp, 0, sizeof(char_u *) * NSUBEXP);\n\t    vim_memset(reg_endzp, 0, sizeof(char_u *) * NSUBEXP);\n\t}\n\trex.need_clear_zsubexpr = FALSE;\n    }\n}\n#endif\n\n/*\n * Advance rex.lnum, rex.line and rex.input to the next line.\n */\n    static void\nreg_nextline(void)\n{\n    rex.line = reg_getline(++rex.lnum);\n    rex.input = rex.line;\n    fast_breakcheck();\n}\n\n/*\n * Check whether a backreference matches.\n * Returns RA_FAIL, RA_NOMATCH or RA_MATCH.\n * If \"bytelen\" is not NULL, it is set to the byte length of the match in the\n * last line.\n */\n    static int\nmatch_with_backref(\n    linenr_T start_lnum,\n    colnr_T  start_col,\n    linenr_T end_lnum,\n    colnr_T  end_col,\n    int\t     *bytelen)\n{\n    linenr_T\tclnum = start_lnum;\n    colnr_T\tccol = start_col;\n    int\t\tlen;\n    char_u\t*p;\n\n    if (bytelen != NULL)\n\t*bytelen = 0;\n    for (;;)\n    {\n\t// Since getting one line may invalidate the other, need to make copy.\n\t// Slow!\n\tif (rex.line != reg_tofree)\n\t{\n\t    len = (int)STRLEN(rex.line);\n\t    if (reg_tofree == NULL || len >= (int)reg_tofreelen)\n\t    {\n\t\tlen += 50;\t// get some extra\n\t\tvim_free(reg_tofree);\n\t\treg_tofree = alloc(len);\n\t\tif (reg_tofree == NULL)\n\t\t    return RA_FAIL; // out of memory!\n\t\treg_tofreelen = len;\n\t    }\n\t    STRCPY(reg_tofree, rex.line);\n\t    rex.input = reg_tofree + (rex.input - rex.line);\n\t    rex.line = reg_tofree;\n\t}\n\n\t// Get the line to compare with.\n\tp = reg_getline(clnum);\n\tif (clnum == end_lnum)\n\t    len = end_col - ccol;\n\telse\n\t    len = (int)STRLEN(p + ccol);\n\n\tif (cstrncmp(p + ccol, rex.input, &len) != 0)\n\t    return RA_NOMATCH;  // doesn't match\n\tif (bytelen != NULL)\n\t    *bytelen += len;\n\tif (clnum == end_lnum)\n\t    break;\t\t// match and at end!\n\tif (rex.lnum >= rex.reg_maxline)\n\t    return RA_NOMATCH;  // text too short\n\n\t// Advance to next line.\n\treg_nextline();\n\tif (bytelen != NULL)\n\t    *bytelen = 0;\n\t++clnum;\n\tccol = 0;\n\tif (got_int)\n\t    return RA_FAIL;\n    }\n\n    // found a match!  Note that rex.line may now point to a copy of the line,\n    // that should not matter.\n    return RA_MATCH;\n}\n\n/*\n * Used in a place where no * or \\+ can follow.\n */\n    static int\nre_mult_next(char *what)\n{\n    if (re_multi_type(peekchr()) == MULTI_MULT)\n    {\n       semsg(_(\"E888: (NFA regexp) cannot repeat %s\"), what);\n       rc_did_emsg = TRUE;\n       return FAIL;\n    }\n    return OK;\n}\n\ntypedef struct\n{\n    int a, b, c;\n} decomp_T;\n\n\n// 0xfb20 - 0xfb4f\nstatic decomp_T decomp_table[0xfb4f-0xfb20+1] =\n{\n    {0x5e2,0,0},\t\t// 0xfb20\talt ayin\n    {0x5d0,0,0},\t\t// 0xfb21\talt alef\n    {0x5d3,0,0},\t\t// 0xfb22\talt dalet\n    {0x5d4,0,0},\t\t// 0xfb23\talt he\n    {0x5db,0,0},\t\t// 0xfb24\talt kaf\n    {0x5dc,0,0},\t\t// 0xfb25\talt lamed\n    {0x5dd,0,0},\t\t// 0xfb26\talt mem-sofit\n    {0x5e8,0,0},\t\t// 0xfb27\talt resh\n    {0x5ea,0,0},\t\t// 0xfb28\talt tav\n    {'+', 0, 0},\t\t// 0xfb29\talt plus\n    {0x5e9, 0x5c1, 0},\t\t// 0xfb2a\tshin+shin-dot\n    {0x5e9, 0x5c2, 0},\t\t// 0xfb2b\tshin+sin-dot\n    {0x5e9, 0x5c1, 0x5bc},\t// 0xfb2c\tshin+shin-dot+dagesh\n    {0x5e9, 0x5c2, 0x5bc},\t// 0xfb2d\tshin+sin-dot+dagesh\n    {0x5d0, 0x5b7, 0},\t\t// 0xfb2e\talef+patah\n    {0x5d0, 0x5b8, 0},\t\t// 0xfb2f\talef+qamats\n    {0x5d0, 0x5b4, 0},\t\t// 0xfb30\talef+hiriq\n    {0x5d1, 0x5bc, 0},\t\t// 0xfb31\tbet+dagesh\n    {0x5d2, 0x5bc, 0},\t\t// 0xfb32\tgimel+dagesh\n    {0x5d3, 0x5bc, 0},\t\t// 0xfb33\tdalet+dagesh\n    {0x5d4, 0x5bc, 0},\t\t// 0xfb34\the+dagesh\n    {0x5d5, 0x5bc, 0},\t\t// 0xfb35\tvav+dagesh\n    {0x5d6, 0x5bc, 0},\t\t// 0xfb36\tzayin+dagesh\n    {0xfb37, 0, 0},\t\t// 0xfb37 -- UNUSED\n    {0x5d8, 0x5bc, 0},\t\t// 0xfb38\ttet+dagesh\n    {0x5d9, 0x5bc, 0},\t\t// 0xfb39\tyud+dagesh\n    {0x5da, 0x5bc, 0},\t\t// 0xfb3a\tkaf sofit+dagesh\n    {0x5db, 0x5bc, 0},\t\t// 0xfb3b\tkaf+dagesh\n    {0x5dc, 0x5bc, 0},\t\t// 0xfb3c\tlamed+dagesh\n    {0xfb3d, 0, 0},\t\t// 0xfb3d -- UNUSED\n    {0x5de, 0x5bc, 0},\t\t// 0xfb3e\tmem+dagesh\n    {0xfb3f, 0, 0},\t\t// 0xfb3f -- UNUSED\n    {0x5e0, 0x5bc, 0},\t\t// 0xfb40\tnun+dagesh\n    {0x5e1, 0x5bc, 0},\t\t// 0xfb41\tsamech+dagesh\n    {0xfb42, 0, 0},\t\t// 0xfb42 -- UNUSED\n    {0x5e3, 0x5bc, 0},\t\t// 0xfb43\tpe sofit+dagesh\n    {0x5e4, 0x5bc,0},\t\t// 0xfb44\tpe+dagesh\n    {0xfb45, 0, 0},\t\t// 0xfb45 -- UNUSED\n    {0x5e6, 0x5bc, 0},\t\t// 0xfb46\ttsadi+dagesh\n    {0x5e7, 0x5bc, 0},\t\t// 0xfb47\tqof+dagesh\n    {0x5e8, 0x5bc, 0},\t\t// 0xfb48\tresh+dagesh\n    {0x5e9, 0x5bc, 0},\t\t// 0xfb49\tshin+dagesh\n    {0x5ea, 0x5bc, 0},\t\t// 0xfb4a\ttav+dagesh\n    {0x5d5, 0x5b9, 0},\t\t// 0xfb4b\tvav+holam\n    {0x5d1, 0x5bf, 0},\t\t// 0xfb4c\tbet+rafe\n    {0x5db, 0x5bf, 0},\t\t// 0xfb4d\tkaf+rafe\n    {0x5e4, 0x5bf, 0},\t\t// 0xfb4e\tpe+rafe\n    {0x5d0, 0x5dc, 0}\t\t// 0xfb4f\talef-lamed\n};\n\n    static void\nmb_decompose(int c, int *c1, int *c2, int *c3)\n{\n    decomp_T d;\n\n    if (c >= 0xfb20 && c <= 0xfb4f)\n    {\n\td = decomp_table[c - 0xfb20];\n\t*c1 = d.a;\n\t*c2 = d.b;\n\t*c3 = d.c;\n    }\n    else\n    {\n\t*c1 = c;\n\t*c2 = *c3 = 0;\n    }\n}\n\n/*\n * Compare two strings, ignore case if rex.reg_ic set.\n * Return 0 if strings match, non-zero otherwise.\n * Correct the length \"*n\" when composing characters are ignored.\n */\n    static int\ncstrncmp(char_u *s1, char_u *s2, int *n)\n{\n    int\t\tresult;\n\n    if (!rex.reg_ic)\n\tresult = STRNCMP(s1, s2, *n);\n    else\n\tresult = MB_STRNICMP(s1, s2, *n);\n\n    // if it failed and it's utf8 and we want to combineignore:\n    if (result != 0 && enc_utf8 && rex.reg_icombine)\n    {\n\tchar_u\t*str1, *str2;\n\tint\tc1, c2, c11, c12;\n\tint\tjunk;\n\n\t// we have to handle the strcmp ourselves, since it is necessary to\n\t// deal with the composing characters by ignoring them:\n\tstr1 = s1;\n\tstr2 = s2;\n\tc1 = c2 = 0;\n\twhile ((int)(str1 - s1) < *n)\n\t{\n\t    c1 = mb_ptr2char_adv(&str1);\n\t    c2 = mb_ptr2char_adv(&str2);\n\n\t    // Decompose the character if necessary, into 'base' characters.\n\t    // Currently hard-coded for Hebrew, Arabic to be done...\n\t    if (c1 != c2 && (!rex.reg_ic || utf_fold(c1) != utf_fold(c2)))\n\t    {\n\t\t// decomposition necessary?\n\t\tmb_decompose(c1, &c11, &junk, &junk);\n\t\tmb_decompose(c2, &c12, &junk, &junk);\n\t\tc1 = c11;\n\t\tc2 = c12;\n\t\tif (c11 != c12\n\t\t\t    && (!rex.reg_ic || utf_fold(c11) != utf_fold(c12)))\n\t\t    break;\n\t    }\n\t}\n\tresult = c2 - c1;\n\tif (result == 0)\n\t    *n = (int)(str2 - s2);\n    }\n\n    return result;\n}\n\n/*\n * cstrchr: This function is used a lot for simple searches, keep it fast!\n */\n    static char_u *\ncstrchr(char_u *s, int c)\n{\n    char_u\t*p;\n    int\t\tcc;\n\n    if (!rex.reg_ic || (!enc_utf8 && mb_char2len(c) > 1))\n\treturn vim_strchr(s, c);\n\n    // tolower() and toupper() can be slow, comparing twice should be a lot\n    // faster (esp. when using MS Visual C++!).\n    // For UTF-8 need to use folded case.\n    if (enc_utf8 && c > 0x80)\n\tcc = utf_fold(c);\n    else\n\t if (MB_ISUPPER(c))\n\tcc = MB_TOLOWER(c);\n    else if (MB_ISLOWER(c))\n\tcc = MB_TOUPPER(c);\n    else\n\treturn vim_strchr(s, c);\n\n    if (has_mbyte)\n    {\n\tfor (p = s; *p != NUL; p += (*mb_ptr2len)(p))\n\t{\n\t    if (enc_utf8 && c > 0x80)\n\t    {\n\t\tif (utf_fold(utf_ptr2char(p)) == cc)\n\t\t    return p;\n\t    }\n\t    else if (*p == c || *p == cc)\n\t\treturn p;\n\t}\n    }\n    else\n\t// Faster version for when there are no multi-byte characters.\n\tfor (p = s; *p != NUL; ++p)\n\t    if (*p == c || *p == cc)\n\t\treturn p;\n\n    return NULL;\n}\n\n////////////////////////////////////////////////////////////////\n//\t\t      regsub stuff\t\t\t      //\n////////////////////////////////////////////////////////////////\n\n/*\n * We should define ftpr as a pointer to a function returning a pointer to\n * a function returning a pointer to a function ...\n * This is impossible, so we declare a pointer to a function returning a\n * void pointer. This should work for all compilers.\n */\ntypedef void (*(*fptr_T)(int *, int));\n\nstatic int vim_regsub_both(char_u *source, typval_T *expr, char_u *dest, int copy, int magic, int backslash);\n\n    static fptr_T\ndo_upper(int *d, int c)\n{\n    *d = MB_TOUPPER(c);\n\n    return (fptr_T)NULL;\n}\n\n    static fptr_T\ndo_Upper(int *d, int c)\n{\n    *d = MB_TOUPPER(c);\n\n    return (fptr_T)do_Upper;\n}\n\n    static fptr_T\ndo_lower(int *d, int c)\n{\n    *d = MB_TOLOWER(c);\n\n    return (fptr_T)NULL;\n}\n\n    static fptr_T\ndo_Lower(int *d, int c)\n{\n    *d = MB_TOLOWER(c);\n\n    return (fptr_T)do_Lower;\n}\n\n/*\n * regtilde(): Replace tildes in the pattern by the old pattern.\n *\n * Short explanation of the tilde: It stands for the previous replacement\n * pattern.  If that previous pattern also contains a ~ we should go back a\n * step further...  But we insert the previous pattern into the current one\n * and remember that.\n * This still does not handle the case where \"magic\" changes.  So require the\n * user to keep his hands off of \"magic\".\n *\n * The tildes are parsed once before the first call to vim_regsub().\n */\n    char_u *\nregtilde(char_u *source, int magic)\n{\n    char_u\t*newsub = source;\n    char_u\t*tmpsub;\n    char_u\t*p;\n    int\t\tlen;\n    int\t\tprevlen;\n\n    for (p = newsub; *p; ++p)\n    {\n\tif ((*p == '~' && magic) || (*p == '\\\\' && *(p + 1) == '~' && !magic))\n\t{\n\t    if (reg_prev_sub != NULL)\n\t    {\n\t\t// length = len(newsub) - 1 + len(prev_sub) + 1\n\t\tprevlen = (int)STRLEN(reg_prev_sub);\n\t\ttmpsub = alloc(STRLEN(newsub) + prevlen);\n\t\tif (tmpsub != NULL)\n\t\t{\n\t\t    // copy prefix\n\t\t    len = (int)(p - newsub);\t// not including ~\n\t\t    mch_memmove(tmpsub, newsub, (size_t)len);\n\t\t    // interpret tilde\n\t\t    mch_memmove(tmpsub + len, reg_prev_sub, (size_t)prevlen);\n\t\t    // copy postfix\n\t\t    if (!magic)\n\t\t\t++p;\t\t\t// back off backslash\n\t\t    STRCPY(tmpsub + len + prevlen, p + 1);\n\n\t\t    if (newsub != source)\t// already allocated newsub\n\t\t\tvim_free(newsub);\n\t\t    newsub = tmpsub;\n\t\t    p = newsub + len + prevlen;\n\t\t}\n\t    }\n\t    else if (magic)\n\t\tSTRMOVE(p, p + 1);\t// remove '~'\n\t    else\n\t\tSTRMOVE(p, p + 2);\t// remove '\\~'\n\t    --p;\n\t}\n\telse\n\t{\n\t    if (*p == '\\\\' && p[1])\t\t// skip escaped characters\n\t\t++p;\n\t    if (has_mbyte)\n\t\tp += (*mb_ptr2len)(p) - 1;\n\t}\n    }\n\n    vim_free(reg_prev_sub);\n    if (newsub != source)\t// newsub was allocated, just keep it\n\treg_prev_sub = newsub;\n    else\t\t\t// no ~ found, need to save newsub\n\treg_prev_sub = vim_strsave(newsub);\n    return newsub;\n}\n\n#ifdef FEAT_EVAL\nstatic int can_f_submatch = FALSE;\t// TRUE when submatch() can be used\n\n// These pointers are used for reg_submatch().  Needed for when the\n// substitution string is an expression that contains a call to substitute()\n// and submatch().\ntypedef struct {\n    regmatch_T\t*sm_match;\n    regmmatch_T\t*sm_mmatch;\n    linenr_T\tsm_firstlnum;\n    linenr_T\tsm_maxline;\n    int\t\tsm_line_lbr;\n} regsubmatch_T;\n\nstatic regsubmatch_T rsm;  // can only be used when can_f_submatch is TRUE\n#endif\n\n#ifdef FEAT_EVAL\n\n/*\n * Put the submatches in \"argv[argskip]\" which is a list passed into\n * call_func() by vim_regsub_both().\n */\n    static int\nfill_submatch_list(int argc UNUSED, typval_T *argv, int argskip, int argcount)\n{\n    listitem_T\t*li;\n    int\t\ti;\n    char_u\t*s;\n    typval_T\t*listarg = argv + argskip;\n\n    if (argcount == argskip)\n\t// called function doesn't take a submatches argument\n\treturn argskip;\n\n    // Relies on sl_list to be the first item in staticList10_T.\n    init_static_list((staticList10_T *)(listarg->vval.v_list));\n\n    // There are always 10 list items in staticList10_T.\n    li = listarg->vval.v_list->lv_first;\n    for (i = 0; i < 10; ++i)\n    {\n\ts = rsm.sm_match->startp[i];\n\tif (s == NULL || rsm.sm_match->endp[i] == NULL)\n\t    s = NULL;\n\telse\n\t    s = vim_strnsave(s, rsm.sm_match->endp[i] - s);\n\tli->li_tv.v_type = VAR_STRING;\n\tli->li_tv.vval.v_string = s;\n\tli = li->li_next;\n    }\n    return argskip + 1;\n}\n\n    static void\nclear_submatch_list(staticList10_T *sl)\n{\n    int i;\n\n    for (i = 0; i < 10; ++i)\n\tvim_free(sl->sl_items[i].li_tv.vval.v_string);\n}\n#endif\n\n/*\n * vim_regsub() - perform substitutions after a vim_regexec() or\n * vim_regexec_multi() match.\n *\n * If \"copy\" is TRUE really copy into \"dest\".\n * If \"copy\" is FALSE nothing is copied, this is just to find out the length\n * of the result.\n *\n * If \"backslash\" is TRUE, a backslash will be removed later, need to double\n * them to keep them, and insert a backslash before a CR to avoid it being\n * replaced with a line break later.\n *\n * Note: The matched text must not change between the call of\n * vim_regexec()/vim_regexec_multi() and vim_regsub()!  It would make the back\n * references invalid!\n *\n * Returns the size of the replacement, including terminating NUL.\n */\n    int\nvim_regsub(\n    regmatch_T\t*rmp,\n    char_u\t*source,\n    typval_T\t*expr,\n    char_u\t*dest,\n    int\t\tcopy,\n    int\t\tmagic,\n    int\t\tbackslash)\n{\n    int\t\tresult;\n    regexec_T\trex_save;\n    int\t\trex_in_use_save = rex_in_use;\n\n    if (rex_in_use)\n\t// Being called recursively, save the state.\n\trex_save = rex;\n    rex_in_use = TRUE;\n\n    rex.reg_match = rmp;\n    rex.reg_mmatch = NULL;\n    rex.reg_maxline = 0;\n    rex.reg_buf = curbuf;\n    rex.reg_line_lbr = TRUE;\n    result = vim_regsub_both(source, expr, dest, copy, magic, backslash);\n\n    rex_in_use = rex_in_use_save;\n    if (rex_in_use)\n\trex = rex_save;\n\n    return result;\n}\n\n    int\nvim_regsub_multi(\n    regmmatch_T\t*rmp,\n    linenr_T\tlnum,\n    char_u\t*source,\n    char_u\t*dest,\n    int\t\tcopy,\n    int\t\tmagic,\n    int\t\tbackslash)\n{\n    int\t\tresult;\n    regexec_T\trex_save;\n    int\t\trex_in_use_save = rex_in_use;\n\n    if (rex_in_use)\n\t// Being called recursively, save the state.\n\trex_save = rex;\n    rex_in_use = TRUE;\n\n    rex.reg_match = NULL;\n    rex.reg_mmatch = rmp;\n    rex.reg_buf = curbuf;\t// always works on the current buffer!\n    rex.reg_firstlnum = lnum;\n    rex.reg_maxline = curbuf->b_ml.ml_line_count - lnum;\n    rex.reg_line_lbr = FALSE;\n    result = vim_regsub_both(source, NULL, dest, copy, magic, backslash);\n\n    rex_in_use = rex_in_use_save;\n    if (rex_in_use)\n\trex = rex_save;\n\n    return result;\n}\n\n    static int\nvim_regsub_both(\n    char_u\t*source,\n    typval_T\t*expr,\n    char_u\t*dest,\n    int\t\tcopy,\n    int\t\tmagic,\n    int\t\tbackslash)\n{\n    char_u\t*src;\n    char_u\t*dst;\n    char_u\t*s;\n    int\t\tc;\n    int\t\tcc;\n    int\t\tno = -1;\n    fptr_T\tfunc_all = (fptr_T)NULL;\n    fptr_T\tfunc_one = (fptr_T)NULL;\n    linenr_T\tclnum = 0;\t// init for GCC\n    int\t\tlen = 0;\t// init for GCC\n#ifdef FEAT_EVAL\n    static char_u   *eval_result = NULL;\n#endif\n\n    // Be paranoid...\n    if ((source == NULL && expr == NULL) || dest == NULL)\n    {\n\temsg(_(e_null_argument));\n\treturn 0;\n    }\n    if (prog_magic_wrong())\n\treturn 0;\n    src = source;\n    dst = dest;\n\n    /*\n     * When the substitute part starts with \"\\=\" evaluate it as an expression.\n     */\n    if (expr != NULL || (source[0] == '\\\\' && source[1] == '='))\n    {\n#ifdef FEAT_EVAL\n\t// To make sure that the length doesn't change between checking the\n\t// length and copying the string, and to speed up things, the\n\t// resulting string is saved from the call with \"copy\" == FALSE to the\n\t// call with \"copy\" == TRUE.\n\tif (copy)\n\t{\n\t    if (eval_result != NULL)\n\t    {\n\t\tSTRCPY(dest, eval_result);\n\t\tdst += STRLEN(eval_result);\n\t\tVIM_CLEAR(eval_result);\n\t    }\n\t}\n\telse\n\t{\n\t    int\t\t    prev_can_f_submatch = can_f_submatch;\n\t    regsubmatch_T   rsm_save;\n\n\t    vim_free(eval_result);\n\n\t    // The expression may contain substitute(), which calls us\n\t    // recursively.  Make sure submatch() gets the text from the first\n\t    // level.\n\t    if (can_f_submatch)\n\t\trsm_save = rsm;\n\t    can_f_submatch = TRUE;\n\t    rsm.sm_match = rex.reg_match;\n\t    rsm.sm_mmatch = rex.reg_mmatch;\n\t    rsm.sm_firstlnum = rex.reg_firstlnum;\n\t    rsm.sm_maxline = rex.reg_maxline;\n\t    rsm.sm_line_lbr = rex.reg_line_lbr;\n\n\t    if (expr != NULL)\n\t    {\n\t\ttypval_T\targv[2];\n\t\tchar_u\t\tbuf[NUMBUFLEN];\n\t\ttypval_T\trettv;\n\t\tstaticList10_T\tmatchList;\n\t\tfuncexe_T\tfuncexe;\n\n\t\trettv.v_type = VAR_STRING;\n\t\trettv.vval.v_string = NULL;\n\t\targv[0].v_type = VAR_LIST;\n\t\targv[0].vval.v_list = &matchList.sl_list;\n\t\tmatchList.sl_list.lv_len = 0;\n\t\tCLEAR_FIELD(funcexe);\n\t\tfuncexe.argv_func = fill_submatch_list;\n\t\tfuncexe.evaluate = TRUE;\n\t\tif (expr->v_type == VAR_FUNC)\n\t\t{\n\t\t    s = expr->vval.v_string;\n\t\t    call_func(s, -1, &rettv, 1, argv, &funcexe);\n\t\t}\n\t\telse if (expr->v_type == VAR_PARTIAL)\n\t\t{\n\t\t    partial_T   *partial = expr->vval.v_partial;\n\n\t\t    s = partial_name(partial);\n\t\t    funcexe.partial = partial;\n\t\t    call_func(s, -1, &rettv, 1, argv, &funcexe);\n\t\t}\n\t\tif (matchList.sl_list.lv_len > 0)\n\t\t    // fill_submatch_list() was called\n\t\t    clear_submatch_list(&matchList);\n\n\t\tif (rettv.v_type == VAR_UNKNOWN)\n\t\t    // something failed, no need to report another error\n\t\t    eval_result = NULL;\n\t\telse\n\t\t{\n\t\t    eval_result = tv_get_string_buf_chk(&rettv, buf);\n\t\t    if (eval_result != NULL)\n\t\t\teval_result = vim_strsave(eval_result);\n\t\t}\n\t\tclear_tv(&rettv);\n\t    }\n\t    else if (substitute_instr != NULL)\n\t\t// Execute instructions from ISN_SUBSTITUTE.\n\t\teval_result = exe_substitute_instr();\n\t    else\n\t\teval_result = eval_to_string(source + 2, TRUE);\n\n\t    if (eval_result != NULL)\n\t    {\n\t\tint had_backslash = FALSE;\n\n\t\tfor (s = eval_result; *s != NUL; MB_PTR_ADV(s))\n\t\t{\n\t\t    // Change NL to CR, so that it becomes a line break,\n\t\t    // unless called from vim_regexec_nl().\n\t\t    // Skip over a backslashed character.\n\t\t    if (*s == NL && !rsm.sm_line_lbr)\n\t\t\t*s = CAR;\n\t\t    else if (*s == '\\\\' && s[1] != NUL)\n\t\t    {\n\t\t\t++s;\n\t\t\t/* Change NL to CR here too, so that this works:\n\t\t\t * :s/abc\\\\\\ndef/\\=\"aaa\\\\\\nbbb\"/  on text:\n\t\t\t *   abc\\\n\t\t\t *   def\n\t\t\t * Not when called from vim_regexec_nl().\n\t\t\t */\n\t\t\tif (*s == NL && !rsm.sm_line_lbr)\n\t\t\t    *s = CAR;\n\t\t\thad_backslash = TRUE;\n\t\t    }\n\t\t}\n\t\tif (had_backslash && backslash)\n\t\t{\n\t\t    // Backslashes will be consumed, need to double them.\n\t\t    s = vim_strsave_escaped(eval_result, (char_u *)\"\\\\\");\n\t\t    if (s != NULL)\n\t\t    {\n\t\t\tvim_free(eval_result);\n\t\t\teval_result = s;\n\t\t    }\n\t\t}\n\n\t\tdst += STRLEN(eval_result);\n\t    }\n\n\t    can_f_submatch = prev_can_f_submatch;\n\t    if (can_f_submatch)\n\t\trsm = rsm_save;\n\t}\n#endif\n    }\n    else\n      while ((c = *src++) != NUL)\n      {\n\tif (c == '&' && magic)\n\t    no = 0;\n\telse if (c == '\\\\' && *src != NUL)\n\t{\n\t    if (*src == '&' && !magic)\n\t    {\n\t\t++src;\n\t\tno = 0;\n\t    }\n\t    else if ('0' <= *src && *src <= '9')\n\t    {\n\t\tno = *src++ - '0';\n\t    }\n\t    else if (vim_strchr((char_u *)\"uUlLeE\", *src))\n\t    {\n\t\tswitch (*src++)\n\t\t{\n\t\tcase 'u':   func_one = (fptr_T)do_upper;\n\t\t\t    continue;\n\t\tcase 'U':   func_all = (fptr_T)do_Upper;\n\t\t\t    continue;\n\t\tcase 'l':   func_one = (fptr_T)do_lower;\n\t\t\t    continue;\n\t\tcase 'L':   func_all = (fptr_T)do_Lower;\n\t\t\t    continue;\n\t\tcase 'e':\n\t\tcase 'E':   func_one = func_all = (fptr_T)NULL;\n\t\t\t    continue;\n\t\t}\n\t    }\n\t}\n\tif (no < 0)\t      // Ordinary character.\n\t{\n\t    if (c == K_SPECIAL && src[0] != NUL && src[1] != NUL)\n\t    {\n\t\t// Copy a special key as-is.\n\t\tif (copy)\n\t\t{\n\t\t    *dst++ = c;\n\t\t    *dst++ = *src++;\n\t\t    *dst++ = *src++;\n\t\t}\n\t\telse\n\t\t{\n\t\t    dst += 3;\n\t\t    src += 2;\n\t\t}\n\t\tcontinue;\n\t    }\n\n\t    if (c == '\\\\' && *src != NUL)\n\t    {\n\t\t// Check for abbreviations -- webb\n\t\tswitch (*src)\n\t\t{\n\t\t    case 'r':\tc = CAR;\t++src;\tbreak;\n\t\t    case 'n':\tc = NL;\t\t++src;\tbreak;\n\t\t    case 't':\tc = TAB;\t++src;\tbreak;\n\t\t // Oh no!  \\e already has meaning in subst pat :-(\n\t\t // case 'e':   c = ESC;\t++src;\tbreak;\n\t\t    case 'b':\tc = Ctrl_H;\t++src;\tbreak;\n\n\t\t    // If \"backslash\" is TRUE the backslash will be removed\n\t\t    // later.  Used to insert a literal CR.\n\t\t    default:\tif (backslash)\n\t\t\t\t{\n\t\t\t\t    if (copy)\n\t\t\t\t\t*dst = '\\\\';\n\t\t\t\t    ++dst;\n\t\t\t\t}\n\t\t\t\tc = *src++;\n\t\t}\n\t    }\n\t    else if (has_mbyte)\n\t\tc = mb_ptr2char(src - 1);\n\n\t    // Write to buffer, if copy is set.\n\t    if (func_one != (fptr_T)NULL)\n\t\t// Turbo C complains without the typecast\n\t\tfunc_one = (fptr_T)(func_one(&cc, c));\n\t    else if (func_all != (fptr_T)NULL)\n\t\t// Turbo C complains without the typecast\n\t\tfunc_all = (fptr_T)(func_all(&cc, c));\n\t    else // just copy\n\t\tcc = c;\n\n\t    if (has_mbyte)\n\t    {\n\t\tint totlen = mb_ptr2len(src - 1);\n\n\t\tif (copy)\n\t\t    mb_char2bytes(cc, dst);\n\t\tdst += mb_char2len(cc) - 1;\n\t\tif (enc_utf8)\n\t\t{\n\t\t    int clen = utf_ptr2len(src - 1);\n\n\t\t    // If the character length is shorter than \"totlen\", there\n\t\t    // are composing characters; copy them as-is.\n\t\t    if (clen < totlen)\n\t\t    {\n\t\t\tif (copy)\n\t\t\t    mch_memmove(dst + 1, src - 1 + clen,\n\t\t\t\t\t\t     (size_t)(totlen - clen));\n\t\t\tdst += totlen - clen;\n\t\t    }\n\t\t}\n\t\tsrc += totlen - 1;\n\t    }\n\t    else if (copy)\n\t\t    *dst = cc;\n\t    dst++;\n\t}\n\telse\n\t{\n\t    if (REG_MULTI)\n\t    {\n\t\tclnum = rex.reg_mmatch->startpos[no].lnum;\n\t\tif (clnum < 0 || rex.reg_mmatch->endpos[no].lnum < 0)\n\t\t    s = NULL;\n\t\telse\n\t\t{\n\t\t    s = reg_getline(clnum) + rex.reg_mmatch->startpos[no].col;\n\t\t    if (rex.reg_mmatch->endpos[no].lnum == clnum)\n\t\t\tlen = rex.reg_mmatch->endpos[no].col\n\t\t\t\t\t    - rex.reg_mmatch->startpos[no].col;\n\t\t    else\n\t\t\tlen = (int)STRLEN(s);\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\ts = rex.reg_match->startp[no];\n\t\tif (rex.reg_match->endp[no] == NULL)\n\t\t    s = NULL;\n\t\telse\n\t\t    len = (int)(rex.reg_match->endp[no] - s);\n\t    }\n\t    if (s != NULL)\n\t    {\n\t\tfor (;;)\n\t\t{\n\t\t    if (len == 0)\n\t\t    {\n\t\t\tif (REG_MULTI)\n\t\t\t{\n\t\t\t    if (rex.reg_mmatch->endpos[no].lnum == clnum)\n\t\t\t\tbreak;\n\t\t\t    if (copy)\n\t\t\t\t*dst = CAR;\n\t\t\t    ++dst;\n\t\t\t    s = reg_getline(++clnum);\n\t\t\t    if (rex.reg_mmatch->endpos[no].lnum == clnum)\n\t\t\t\tlen = rex.reg_mmatch->endpos[no].col;\n\t\t\t    else\n\t\t\t\tlen = (int)STRLEN(s);\n\t\t\t}\n\t\t\telse\n\t\t\t    break;\n\t\t    }\n\t\t    else if (*s == NUL) // we hit NUL.\n\t\t    {\n\t\t\tif (copy)\n\t\t\t    iemsg(_(e_damaged_match_string));\n\t\t\tgoto exit;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (backslash && (*s == CAR || *s == '\\\\'))\n\t\t\t{\n\t\t\t    /*\n\t\t\t     * Insert a backslash in front of a CR, otherwise\n\t\t\t     * it will be replaced by a line break.\n\t\t\t     * Number of backslashes will be halved later,\n\t\t\t     * double them here.\n\t\t\t     */\n\t\t\t    if (copy)\n\t\t\t    {\n\t\t\t\tdst[0] = '\\\\';\n\t\t\t\tdst[1] = *s;\n\t\t\t    }\n\t\t\t    dst += 2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    if (has_mbyte)\n\t\t\t\tc = mb_ptr2char(s);\n\t\t\t    else\n\t\t\t\tc = *s;\n\n\t\t\t    if (func_one != (fptr_T)NULL)\n\t\t\t\t// Turbo C complains without the typecast\n\t\t\t\tfunc_one = (fptr_T)(func_one(&cc, c));\n\t\t\t    else if (func_all != (fptr_T)NULL)\n\t\t\t\t// Turbo C complains without the typecast\n\t\t\t\tfunc_all = (fptr_T)(func_all(&cc, c));\n\t\t\t    else // just copy\n\t\t\t\tcc = c;\n\n\t\t\t    if (has_mbyte)\n\t\t\t    {\n\t\t\t\tint l;\n\n\t\t\t\t// Copy composing characters separately, one\n\t\t\t\t// at a time.\n\t\t\t\tif (enc_utf8)\n\t\t\t\t    l = utf_ptr2len(s) - 1;\n\t\t\t\telse\n\t\t\t\t    l = mb_ptr2len(s) - 1;\n\n\t\t\t\ts += l;\n\t\t\t\tlen -= l;\n\t\t\t\tif (copy)\n\t\t\t\t    mb_char2bytes(cc, dst);\n\t\t\t\tdst += mb_char2len(cc) - 1;\n\t\t\t    }\n\t\t\t    else if (copy)\n\t\t\t\t    *dst = cc;\n\t\t\t    dst++;\n\t\t\t}\n\n\t\t\t++s;\n\t\t\t--len;\n\t\t    }\n\t\t}\n\t    }\n\t    no = -1;\n\t}\n      }\n    if (copy)\n\t*dst = NUL;\n\nexit:\n    return (int)((dst - dest) + 1);\n}\n\n#ifdef FEAT_EVAL\n/*\n * Call reg_getline() with the line numbers from the submatch.  If a\n * substitute() was used the reg_maxline and other values have been\n * overwritten.\n */\n    static char_u *\nreg_getline_submatch(linenr_T lnum)\n{\n    char_u *s;\n    linenr_T save_first = rex.reg_firstlnum;\n    linenr_T save_max = rex.reg_maxline;\n\n    rex.reg_firstlnum = rsm.sm_firstlnum;\n    rex.reg_maxline = rsm.sm_maxline;\n\n    s = reg_getline(lnum);\n\n    rex.reg_firstlnum = save_first;\n    rex.reg_maxline = save_max;\n    return s;\n}\n\n/*\n * Used for the submatch() function: get the string from the n'th submatch in\n * allocated memory.\n * Returns NULL when not in a \":s\" command and for a non-existing submatch.\n */\n    char_u *\nreg_submatch(int no)\n{\n    char_u\t*retval = NULL;\n    char_u\t*s;\n    int\t\tlen;\n    int\t\tround;\n    linenr_T\tlnum;\n\n    if (!can_f_submatch || no < 0)\n\treturn NULL;\n\n    if (rsm.sm_match == NULL)\n    {\n\t/*\n\t * First round: compute the length and allocate memory.\n\t * Second round: copy the text.\n\t */\n\tfor (round = 1; round <= 2; ++round)\n\t{\n\t    lnum = rsm.sm_mmatch->startpos[no].lnum;\n\t    if (lnum < 0 || rsm.sm_mmatch->endpos[no].lnum < 0)\n\t\treturn NULL;\n\n\t    s = reg_getline_submatch(lnum);\n\t    if (s == NULL)  // anti-crash check, cannot happen?\n\t\tbreak;\n\t    s += rsm.sm_mmatch->startpos[no].col;\n\t    if (rsm.sm_mmatch->endpos[no].lnum == lnum)\n\t    {\n\t\t// Within one line: take form start to end col.\n\t\tlen = rsm.sm_mmatch->endpos[no].col\n\t\t\t\t\t  - rsm.sm_mmatch->startpos[no].col;\n\t\tif (round == 2)\n\t\t    vim_strncpy(retval, s, len);\n\t\t++len;\n\t    }\n\t    else\n\t    {\n\t\t// Multiple lines: take start line from start col, middle\n\t\t// lines completely and end line up to end col.\n\t\tlen = (int)STRLEN(s);\n\t\tif (round == 2)\n\t\t{\n\t\t    STRCPY(retval, s);\n\t\t    retval[len] = '\\n';\n\t\t}\n\t\t++len;\n\t\t++lnum;\n\t\twhile (lnum < rsm.sm_mmatch->endpos[no].lnum)\n\t\t{\n\t\t    s = reg_getline_submatch(lnum++);\n\t\t    if (round == 2)\n\t\t\tSTRCPY(retval + len, s);\n\t\t    len += (int)STRLEN(s);\n\t\t    if (round == 2)\n\t\t\tretval[len] = '\\n';\n\t\t    ++len;\n\t\t}\n\t\tif (round == 2)\n\t\t    STRNCPY(retval + len, reg_getline_submatch(lnum),\n\t\t\t\t\t     rsm.sm_mmatch->endpos[no].col);\n\t\tlen += rsm.sm_mmatch->endpos[no].col;\n\t\tif (round == 2)\n\t\t    retval[len] = NUL;\n\t\t++len;\n\t    }\n\n\t    if (retval == NULL)\n\t    {\n\t\tretval = alloc(len);\n\t\tif (retval == NULL)\n\t\t    return NULL;\n\t    }\n\t}\n    }\n    else\n    {\n\ts = rsm.sm_match->startp[no];\n\tif (s == NULL || rsm.sm_match->endp[no] == NULL)\n\t    retval = NULL;\n\telse\n\t    retval = vim_strnsave(s, rsm.sm_match->endp[no] - s);\n    }\n\n    return retval;\n}\n\n/*\n * Used for the submatch() function with the optional non-zero argument: get\n * the list of strings from the n'th submatch in allocated memory with NULs\n * represented in NLs.\n * Returns a list of allocated strings.  Returns NULL when not in a \":s\"\n * command, for a non-existing submatch and for any error.\n */\n    list_T *\nreg_submatch_list(int no)\n{\n    char_u\t*s;\n    linenr_T\tslnum;\n    linenr_T\telnum;\n    colnr_T\tscol;\n    colnr_T\tecol;\n    int\t\ti;\n    list_T\t*list;\n    int\t\terror = FALSE;\n\n    if (!can_f_submatch || no < 0)\n\treturn NULL;\n\n    if (rsm.sm_match == NULL)\n    {\n\tslnum = rsm.sm_mmatch->startpos[no].lnum;\n\telnum = rsm.sm_mmatch->endpos[no].lnum;\n\tif (slnum < 0 || elnum < 0)\n\t    return NULL;\n\n\tscol = rsm.sm_mmatch->startpos[no].col;\n\tecol = rsm.sm_mmatch->endpos[no].col;\n\n\tlist = list_alloc();\n\tif (list == NULL)\n\t    return NULL;\n\n\ts = reg_getline_submatch(slnum) + scol;\n\tif (slnum == elnum)\n\t{\n\t    if (list_append_string(list, s, ecol - scol) == FAIL)\n\t\terror = TRUE;\n\t}\n\telse\n\t{\n\t    if (list_append_string(list, s, -1) == FAIL)\n\t\terror = TRUE;\n\t    for (i = 1; i < elnum - slnum; i++)\n\t    {\n\t\ts = reg_getline_submatch(slnum + i);\n\t\tif (list_append_string(list, s, -1) == FAIL)\n\t\t    error = TRUE;\n\t    }\n\t    s = reg_getline_submatch(elnum);\n\t    if (list_append_string(list, s, ecol) == FAIL)\n\t\terror = TRUE;\n\t}\n    }\n    else\n    {\n\ts = rsm.sm_match->startp[no];\n\tif (s == NULL || rsm.sm_match->endp[no] == NULL)\n\t    return NULL;\n\tlist = list_alloc();\n\tif (list == NULL)\n\t    return NULL;\n\tif (list_append_string(list, s,\n\t\t\t\t (int)(rsm.sm_match->endp[no] - s)) == FAIL)\n\t    error = TRUE;\n    }\n\n    if (error)\n    {\n\tlist_free(list);\n\treturn NULL;\n    }\n    ++list->lv_refcount;\n    return list;\n}\n#endif\n\n/*\n * Initialize the values used for matching against multiple lines\n */\n    static void\ninit_regexec_multi(\n\tregmmatch_T\t*rmp,\n\twin_T\t\t*win,\t// window in which to search or NULL\n\tbuf_T\t\t*buf,\t// buffer in which to search\n\tlinenr_T\tlnum)\t// nr of line to start looking for match\n{\n    rex.reg_match = NULL;\n    rex.reg_mmatch = rmp;\n    rex.reg_buf = buf;\n    rex.reg_win = win;\n    rex.reg_firstlnum = lnum;\n    rex.reg_maxline = rex.reg_buf->b_ml.ml_line_count - lnum;\n    rex.reg_line_lbr = FALSE;\n    rex.reg_ic = rmp->rmm_ic;\n    rex.reg_icombine = FALSE;\n    rex.reg_maxcol = rmp->rmm_maxcol;\n}\n\n#include \"regexp_bt.c\"\n\nstatic regengine_T bt_regengine =\n{\n    bt_regcomp,\n    bt_regfree,\n    bt_regexec_nl,\n    bt_regexec_multi,\n    (char_u *)\"\"\n};\n\n#include \"regexp_nfa.c\"\n\nstatic regengine_T nfa_regengine =\n{\n    nfa_regcomp,\n    nfa_regfree,\n    nfa_regexec_nl,\n    nfa_regexec_multi,\n    (char_u *)\"\"\n};\n\n// Which regexp engine to use? Needed for vim_regcomp().\n// Must match with 'regexpengine'.\nstatic int regexp_engine = 0;\n\n#ifdef DEBUG\nstatic char_u regname[][30] = {\n\t\t    \"AUTOMATIC Regexp Engine\",\n\t\t    \"BACKTRACKING Regexp Engine\",\n\t\t    \"NFA Regexp Engine\"\n\t\t\t    };\n#endif\n\n/*\n * Compile a regular expression into internal code.\n * Returns the program in allocated memory.\n * Use vim_regfree() to free the memory.\n * Returns NULL for an error.\n */\n    regprog_T *\nvim_regcomp(char_u *expr_arg, int re_flags)\n{\n    regprog_T   *prog = NULL;\n    char_u\t*expr = expr_arg;\n    int\t\tcalled_emsg_before;\n\n    regexp_engine = p_re;\n\n    // Check for prefix \"\\%#=\", that sets the regexp engine\n    if (STRNCMP(expr, \"\\\\%#=\", 4) == 0)\n    {\n\tint newengine = expr[4] - '0';\n\n\tif (newengine == AUTOMATIC_ENGINE\n\t    || newengine == BACKTRACKING_ENGINE\n\t    || newengine == NFA_ENGINE)\n\t{\n\t    regexp_engine = expr[4] - '0';\n\t    expr += 5;\n#ifdef DEBUG\n\t    smsg(\"New regexp mode selected (%d): %s\",\n\t\t\t\t\t   regexp_engine, regname[newengine]);\n#endif\n\t}\n\telse\n\t{\n\t    emsg(_(\"E864: \\\\%#= can only be followed by 0, 1, or 2. The automatic engine will be used \"));\n\t    regexp_engine = AUTOMATIC_ENGINE;\n\t}\n    }\n#ifdef DEBUG\n    bt_regengine.expr = expr;\n    nfa_regengine.expr = expr;\n#endif\n    // reg_iswordc() uses rex.reg_buf\n    rex.reg_buf = curbuf;\n\n    /*\n     * First try the NFA engine, unless backtracking was requested.\n     */\n    called_emsg_before = called_emsg;\n    if (regexp_engine != BACKTRACKING_ENGINE)\n\tprog = nfa_regengine.regcomp(expr,\n\t\tre_flags + (regexp_engine == AUTOMATIC_ENGINE ? RE_AUTO : 0));\n    else\n\tprog = bt_regengine.regcomp(expr, re_flags);\n\n    // Check for error compiling regexp with initial engine.\n    if (prog == NULL)\n    {\n#ifdef BT_REGEXP_DEBUG_LOG\n\tif (regexp_engine == BACKTRACKING_ENGINE)   // debugging log for BT engine\n\t{\n\t    FILE *f;\n\t    f = fopen(BT_REGEXP_DEBUG_LOG_NAME, \"a\");\n\t    if (f)\n\t    {\n\t\tfprintf(f, \"Syntax error in \\\"%s\\\"\\n\", expr);\n\t\tfclose(f);\n\t    }\n\t    else\n\t\tsemsg(\"(NFA) Could not open \\\"%s\\\" to write !!!\",\n\t\t\tBT_REGEXP_DEBUG_LOG_NAME);\n\t}\n#endif\n\t/*\n\t * If the NFA engine failed, try the backtracking engine.\n\t * The NFA engine also fails for patterns that it can't handle well\n\t * but are still valid patterns, thus a retry should work.\n\t * But don't try if an error message was given.\n\t */\n\tif (regexp_engine == AUTOMATIC_ENGINE\n\t\t\t\t\t  && called_emsg == called_emsg_before)\n\t{\n\t    regexp_engine = BACKTRACKING_ENGINE;\n#ifdef FEAT_EVAL\n\t    report_re_switch(expr);\n#endif\n\t    prog = bt_regengine.regcomp(expr, re_flags);\n\t}\n    }\n\n    if (prog != NULL)\n    {\n\t// Store the info needed to call regcomp() again when the engine turns\n\t// out to be very slow when executing it.\n\tprog->re_engine = regexp_engine;\n\tprog->re_flags  = re_flags;\n    }\n\n    return prog;\n}\n\n/*\n * Free a compiled regexp program, returned by vim_regcomp().\n */\n    void\nvim_regfree(regprog_T *prog)\n{\n    if (prog != NULL)\n\tprog->engine->regfree(prog);\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nfree_regexp_stuff(void)\n{\n    ga_clear(&regstack);\n    ga_clear(&backpos);\n    vim_free(reg_tofree);\n    vim_free(reg_prev_sub);\n}\n#endif\n\n#ifdef FEAT_EVAL\n    static void\nreport_re_switch(char_u *pat)\n{\n    if (p_verbose > 0)\n    {\n\tverbose_enter();\n\tmsg_puts(_(\"Switching to backtracking RE engine for pattern: \"));\n\tmsg_puts((char *)pat);\n\tverbose_leave();\n    }\n}\n#endif\n\n#if (defined(FEAT_X11) && (defined(FEAT_TITLE) || defined(FEAT_XCLIPBOARD))) \\\n\t|| defined(PROTO)\n/*\n * Return whether \"prog\" is currently being executed.\n */\n    int\nregprog_in_use(regprog_T *prog)\n{\n    return prog->re_in_use;\n}\n#endif\n\n/*\n * Match a regexp against a string.\n * \"rmp->regprog\" is a compiled regexp as returned by vim_regcomp().\n * Note: \"rmp->regprog\" may be freed and changed.\n * Uses curbuf for line count and 'iskeyword'.\n * When \"nl\" is TRUE consider a \"\\n\" in \"line\" to be a line break.\n *\n * Return TRUE if there is a match, FALSE if not.\n */\n    static int\nvim_regexec_string(\n    regmatch_T\t*rmp,\n    char_u\t*line,  // string to match against\n    colnr_T\tcol,    // column to start looking for match\n    int\t\tnl)\n{\n    int\t\tresult;\n    regexec_T\trex_save;\n    int\t\trex_in_use_save = rex_in_use;\n\n    // Cannot use the same prog recursively, it contains state.\n    if (rmp->regprog->re_in_use)\n    {\n\temsg(_(e_recursive));\n\treturn FALSE;\n    }\n    rmp->regprog->re_in_use = TRUE;\n\n    if (rex_in_use)\n\t// Being called recursively, save the state.\n\trex_save = rex;\n    rex_in_use = TRUE;\n\n    rex.reg_startp = NULL;\n    rex.reg_endp = NULL;\n    rex.reg_startpos = NULL;\n    rex.reg_endpos = NULL;\n\n    result = rmp->regprog->engine->regexec_nl(rmp, line, col, nl);\n    rmp->regprog->re_in_use = FALSE;\n\n    // NFA engine aborted because it's very slow.\n    if (rmp->regprog->re_engine == AUTOMATIC_ENGINE\n\t\t\t\t\t       && result == NFA_TOO_EXPENSIVE)\n    {\n\tint    save_p_re = p_re;\n\tint    re_flags = rmp->regprog->re_flags;\n\tchar_u *pat = vim_strsave(((nfa_regprog_T *)rmp->regprog)->pattern);\n\n\tp_re = BACKTRACKING_ENGINE;\n\tvim_regfree(rmp->regprog);\n\tif (pat != NULL)\n\t{\n#ifdef FEAT_EVAL\n\t    report_re_switch(pat);\n#endif\n\t    rmp->regprog = vim_regcomp(pat, re_flags);\n\t    if (rmp->regprog != NULL)\n\t    {\n\t\trmp->regprog->re_in_use = TRUE;\n\t\tresult = rmp->regprog->engine->regexec_nl(rmp, line, col, nl);\n\t\trmp->regprog->re_in_use = FALSE;\n\t    }\n\t    vim_free(pat);\n\t}\n\n\tp_re = save_p_re;\n    }\n\n    rex_in_use = rex_in_use_save;\n    if (rex_in_use)\n\trex = rex_save;\n\n    return result > 0;\n}\n\n/*\n * Note: \"*prog\" may be freed and changed.\n * Return TRUE if there is a match, FALSE if not.\n */\n    int\nvim_regexec_prog(\n    regprog_T\t**prog,\n    int\t\tignore_case,\n    char_u\t*line,\n    colnr_T\tcol)\n{\n    int\t\tr;\n    regmatch_T\tregmatch;\n\n    regmatch.regprog = *prog;\n    regmatch.rm_ic = ignore_case;\n    r = vim_regexec_string(&regmatch, line, col, FALSE);\n    *prog = regmatch.regprog;\n    return r;\n}\n\n/*\n * Note: \"rmp->regprog\" may be freed and changed.\n * Return TRUE if there is a match, FALSE if not.\n */\n    int\nvim_regexec(regmatch_T *rmp, char_u *line, colnr_T col)\n{\n    return vim_regexec_string(rmp, line, col, FALSE);\n}\n\n/*\n * Like vim_regexec(), but consider a \"\\n\" in \"line\" to be a line break.\n * Note: \"rmp->regprog\" may be freed and changed.\n * Return TRUE if there is a match, FALSE if not.\n */\n    int\nvim_regexec_nl(regmatch_T *rmp, char_u *line, colnr_T col)\n{\n    return vim_regexec_string(rmp, line, col, TRUE);\n}\n\n/*\n * Match a regexp against multiple lines.\n * \"rmp->regprog\" must be a compiled regexp as returned by vim_regcomp().\n * Note: \"rmp->regprog\" may be freed and changed, even set to NULL.\n * Uses curbuf for line count and 'iskeyword'.\n *\n * Return zero if there is no match.  Return number of lines contained in the\n * match otherwise.\n */\n    long\nvim_regexec_multi(\n    regmmatch_T *rmp,\n    win_T       *win,\t\t// window in which to search or NULL\n    buf_T       *buf,\t\t// buffer in which to search\n    linenr_T\tlnum,\t\t// nr of line to start looking for match\n    colnr_T\tcol,\t\t// column to start looking for match\n    proftime_T\t*tm,\t\t// timeout limit or NULL\n    int\t\t*timed_out)\t// flag is set when timeout limit reached\n{\n    int\t\tresult;\n    regexec_T\trex_save;\n    int\t\trex_in_use_save = rex_in_use;\n\n    // Cannot use the same prog recursively, it contains state.\n    if (rmp->regprog->re_in_use)\n    {\n\temsg(_(e_recursive));\n\treturn FALSE;\n    }\n    rmp->regprog->re_in_use = TRUE;\n\n    if (rex_in_use)\n\t// Being called recursively, save the state.\n\trex_save = rex;\n    rex_in_use = TRUE;\n\n    result = rmp->regprog->engine->regexec_multi(\n\t\t\t\t      rmp, win, buf, lnum, col, tm, timed_out);\n    rmp->regprog->re_in_use = FALSE;\n\n    // NFA engine aborted because it's very slow.\n    if (rmp->regprog->re_engine == AUTOMATIC_ENGINE\n\t\t\t\t\t       && result == NFA_TOO_EXPENSIVE)\n    {\n\tint    save_p_re = p_re;\n\tint    re_flags = rmp->regprog->re_flags;\n\tchar_u *pat = vim_strsave(((nfa_regprog_T *)rmp->regprog)->pattern);\n\n\tp_re = BACKTRACKING_ENGINE;\n\tvim_regfree(rmp->regprog);\n\tif (pat != NULL)\n\t{\n#ifdef FEAT_EVAL\n\t    report_re_switch(pat);\n#endif\n#ifdef FEAT_SYN_HL\n\t    // checking for \\z misuse was already done when compiling for NFA,\n\t    // allow all here\n\t    reg_do_extmatch = REX_ALL;\n#endif\n\t    rmp->regprog = vim_regcomp(pat, re_flags);\n#ifdef FEAT_SYN_HL\n\t    reg_do_extmatch = 0;\n#endif\n\n\t    if (rmp->regprog != NULL)\n\t    {\n\t\trmp->regprog->re_in_use = TRUE;\n\t\tresult = rmp->regprog->engine->regexec_multi(\n\t\t\t\t      rmp, win, buf, lnum, col, tm, timed_out);\n\t\trmp->regprog->re_in_use = FALSE;\n\t    }\n\t    vim_free(pat);\n\t}\n\tp_re = save_p_re;\n    }\n\n    rex_in_use = rex_in_use_save;\n    if (rex_in_use)\n\trex = rex_save;\n\n    return result <= 0 ? 0 : result;\n}\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * NFA regular expression implementation.\n *\n * This file is included in \"regexp.c\".\n */\n\n/*\n * Logging of NFA engine.\n *\n * The NFA engine can write four log files:\n * - Error log: Contains NFA engine's fatal errors.\n * - Dump log: Contains compiled NFA state machine's information.\n * - Run log: Contains information of matching procedure.\n * - Debug log: Contains detailed information of matching procedure. Can be\n *   disabled by undefining NFA_REGEXP_DEBUG_LOG.\n * The first one can also be used without debug mode.\n * The last three are enabled when compiled as debug mode and individually\n * disabled by commenting them out.\n * The log files can get quite big!\n * Do disable all of this when compiling Vim for debugging, undefine DEBUG in\n * regexp.c\n */\n#ifdef DEBUG\n# define NFA_REGEXP_ERROR_LOG\t\"nfa_regexp_error.log\"\n# define ENABLE_LOG\n# define NFA_REGEXP_DUMP_LOG\t\"nfa_regexp_dump.log\"\n# define NFA_REGEXP_RUN_LOG\t\"nfa_regexp_run.log\"\n# define NFA_REGEXP_DEBUG_LOG\t\"nfa_regexp_debug.log\"\n#endif\n\n// Added to NFA_ANY - NFA_NUPPER_IC to include a NL.\n#define NFA_ADD_NL\t\t31\n\nenum\n{\n    NFA_SPLIT = -1024,\n    NFA_MATCH,\n    NFA_EMPTY,\t\t\t    // matches 0-length\n\n    NFA_START_COLL,\t\t    // [abc] start\n    NFA_END_COLL,\t\t    // [abc] end\n    NFA_START_NEG_COLL,\t\t    // [^abc] start\n    NFA_END_NEG_COLL,\t\t    // [^abc] end (postfix only)\n    NFA_RANGE,\t\t\t    // range of the two previous items\n\t\t\t\t    // (postfix only)\n    NFA_RANGE_MIN,\t\t    // low end of a range\n    NFA_RANGE_MAX,\t\t    // high end of a range\n\n    NFA_CONCAT,\t\t\t    // concatenate two previous items (postfix\n\t\t\t\t    // only)\n    NFA_OR,\t\t\t    // \\| (postfix only)\n    NFA_STAR,\t\t\t    // greedy * (postfix only)\n    NFA_STAR_NONGREEDY,\t\t    // non-greedy * (postfix only)\n    NFA_QUEST,\t\t\t    // greedy \\? (postfix only)\n    NFA_QUEST_NONGREEDY,\t    // non-greedy \\? (postfix only)\n\n    NFA_BOL,\t\t\t    // ^    Begin line\n    NFA_EOL,\t\t\t    // $    End line\n    NFA_BOW,\t\t\t    // \\<   Begin word\n    NFA_EOW,\t\t\t    // \\>   End word\n    NFA_BOF,\t\t\t    // \\%^  Begin file\n    NFA_EOF,\t\t\t    // \\%$  End file\n    NFA_NEWL,\n    NFA_ZSTART,\t\t\t    // Used for \\zs\n    NFA_ZEND,\t\t\t    // Used for \\ze\n    NFA_NOPEN,\t\t\t    // Start of subexpression marked with \\%(\n    NFA_NCLOSE,\t\t\t    // End of subexpr. marked with \\%( ... \\)\n    NFA_START_INVISIBLE,\n    NFA_START_INVISIBLE_FIRST,\n    NFA_START_INVISIBLE_NEG,\n    NFA_START_INVISIBLE_NEG_FIRST,\n    NFA_START_INVISIBLE_BEFORE,\n    NFA_START_INVISIBLE_BEFORE_FIRST,\n    NFA_START_INVISIBLE_BEFORE_NEG,\n    NFA_START_INVISIBLE_BEFORE_NEG_FIRST,\n    NFA_START_PATTERN,\n    NFA_END_INVISIBLE,\n    NFA_END_INVISIBLE_NEG,\n    NFA_END_PATTERN,\n    NFA_COMPOSING,\t\t    // Next nodes in NFA are part of the\n\t\t\t\t    // composing multibyte char\n    NFA_END_COMPOSING,\t\t    // End of a composing char in the NFA\n    NFA_ANY_COMPOSING,\t\t    // \\%C: Any composing characters.\n    NFA_OPT_CHARS,\t\t    // \\%[abc]\n\n    // The following are used only in the postfix form, not in the NFA\n    NFA_PREV_ATOM_NO_WIDTH,\t    // Used for \\@=\n    NFA_PREV_ATOM_NO_WIDTH_NEG,\t    // Used for \\@!\n    NFA_PREV_ATOM_JUST_BEFORE,\t    // Used for \\@<=\n    NFA_PREV_ATOM_JUST_BEFORE_NEG,  // Used for \\@<!\n    NFA_PREV_ATOM_LIKE_PATTERN,\t    // Used for \\@>\n\n    NFA_BACKREF1,\t\t    // \\1\n    NFA_BACKREF2,\t\t    // \\2\n    NFA_BACKREF3,\t\t    // \\3\n    NFA_BACKREF4,\t\t    // \\4\n    NFA_BACKREF5,\t\t    // \\5\n    NFA_BACKREF6,\t\t    // \\6\n    NFA_BACKREF7,\t\t    // \\7\n    NFA_BACKREF8,\t\t    // \\8\n    NFA_BACKREF9,\t\t    // \\9\n#ifdef FEAT_SYN_HL\n    NFA_ZREF1,\t\t\t    // \\z1\n    NFA_ZREF2,\t\t\t    // \\z2\n    NFA_ZREF3,\t\t\t    // \\z3\n    NFA_ZREF4,\t\t\t    // \\z4\n    NFA_ZREF5,\t\t\t    // \\z5\n    NFA_ZREF6,\t\t\t    // \\z6\n    NFA_ZREF7,\t\t\t    // \\z7\n    NFA_ZREF8,\t\t\t    // \\z8\n    NFA_ZREF9,\t\t\t    // \\z9\n#endif\n    NFA_SKIP,\t\t\t    // Skip characters\n\n    NFA_MOPEN,\n    NFA_MOPEN1,\n    NFA_MOPEN2,\n    NFA_MOPEN3,\n    NFA_MOPEN4,\n    NFA_MOPEN5,\n    NFA_MOPEN6,\n    NFA_MOPEN7,\n    NFA_MOPEN8,\n    NFA_MOPEN9,\n\n    NFA_MCLOSE,\n    NFA_MCLOSE1,\n    NFA_MCLOSE2,\n    NFA_MCLOSE3,\n    NFA_MCLOSE4,\n    NFA_MCLOSE5,\n    NFA_MCLOSE6,\n    NFA_MCLOSE7,\n    NFA_MCLOSE8,\n    NFA_MCLOSE9,\n\n#ifdef FEAT_SYN_HL\n    NFA_ZOPEN,\n    NFA_ZOPEN1,\n    NFA_ZOPEN2,\n    NFA_ZOPEN3,\n    NFA_ZOPEN4,\n    NFA_ZOPEN5,\n    NFA_ZOPEN6,\n    NFA_ZOPEN7,\n    NFA_ZOPEN8,\n    NFA_ZOPEN9,\n\n    NFA_ZCLOSE,\n    NFA_ZCLOSE1,\n    NFA_ZCLOSE2,\n    NFA_ZCLOSE3,\n    NFA_ZCLOSE4,\n    NFA_ZCLOSE5,\n    NFA_ZCLOSE6,\n    NFA_ZCLOSE7,\n    NFA_ZCLOSE8,\n    NFA_ZCLOSE9,\n#endif\n\n    // NFA_FIRST_NL\n    NFA_ANY,\t\t//\tMatch any one character.\n    NFA_IDENT,\t\t//\tMatch identifier char\n    NFA_SIDENT,\t\t//\tMatch identifier char but no digit\n    NFA_KWORD,\t\t//\tMatch keyword char\n    NFA_SKWORD,\t\t//\tMatch word char but no digit\n    NFA_FNAME,\t\t//\tMatch file name char\n    NFA_SFNAME,\t\t//\tMatch file name char but no digit\n    NFA_PRINT,\t\t//\tMatch printable char\n    NFA_SPRINT,\t\t//\tMatch printable char but no digit\n    NFA_WHITE,\t\t//\tMatch whitespace char\n    NFA_NWHITE,\t\t//\tMatch non-whitespace char\n    NFA_DIGIT,\t\t//\tMatch digit char\n    NFA_NDIGIT,\t\t//\tMatch non-digit char\n    NFA_HEX,\t\t//\tMatch hex char\n    NFA_NHEX,\t\t//\tMatch non-hex char\n    NFA_OCTAL,\t\t//\tMatch octal char\n    NFA_NOCTAL,\t\t//\tMatch non-octal char\n    NFA_WORD,\t\t//\tMatch word char\n    NFA_NWORD,\t\t//\tMatch non-word char\n    NFA_HEAD,\t\t//\tMatch head char\n    NFA_NHEAD,\t\t//\tMatch non-head char\n    NFA_ALPHA,\t\t//\tMatch alpha char\n    NFA_NALPHA,\t\t//\tMatch non-alpha char\n    NFA_LOWER,\t\t//\tMatch lowercase char\n    NFA_NLOWER,\t\t//\tMatch non-lowercase char\n    NFA_UPPER,\t\t//\tMatch uppercase char\n    NFA_NUPPER,\t\t//\tMatch non-uppercase char\n    NFA_LOWER_IC,\t//\tMatch [a-z]\n    NFA_NLOWER_IC,\t//\tMatch [^a-z]\n    NFA_UPPER_IC,\t//\tMatch [A-Z]\n    NFA_NUPPER_IC,\t//\tMatch [^A-Z]\n\n    NFA_FIRST_NL = NFA_ANY + NFA_ADD_NL,\n    NFA_LAST_NL = NFA_NUPPER_IC + NFA_ADD_NL,\n\n    NFA_CURSOR,\t\t//\tMatch cursor pos\n    NFA_LNUM,\t\t//\tMatch line number\n    NFA_LNUM_GT,\t//\tMatch > line number\n    NFA_LNUM_LT,\t//\tMatch < line number\n    NFA_COL,\t\t//\tMatch cursor column\n    NFA_COL_GT,\t\t//\tMatch > cursor column\n    NFA_COL_LT,\t\t//\tMatch < cursor column\n    NFA_VCOL,\t\t//\tMatch cursor virtual column\n    NFA_VCOL_GT,\t//\tMatch > cursor virtual column\n    NFA_VCOL_LT,\t//\tMatch < cursor virtual column\n    NFA_MARK,\t\t//\tMatch mark\n    NFA_MARK_GT,\t//\tMatch > mark\n    NFA_MARK_LT,\t//\tMatch < mark\n    NFA_VISUAL,\t\t//\tMatch Visual area\n\n    // Character classes [:alnum:] etc\n    NFA_CLASS_ALNUM,\n    NFA_CLASS_ALPHA,\n    NFA_CLASS_BLANK,\n    NFA_CLASS_CNTRL,\n    NFA_CLASS_DIGIT,\n    NFA_CLASS_GRAPH,\n    NFA_CLASS_LOWER,\n    NFA_CLASS_PRINT,\n    NFA_CLASS_PUNCT,\n    NFA_CLASS_SPACE,\n    NFA_CLASS_UPPER,\n    NFA_CLASS_XDIGIT,\n    NFA_CLASS_TAB,\n    NFA_CLASS_RETURN,\n    NFA_CLASS_BACKSPACE,\n    NFA_CLASS_ESCAPE,\n    NFA_CLASS_IDENT,\n    NFA_CLASS_KEYWORD,\n    NFA_CLASS_FNAME\n};\n\n// Keep in sync with classchars.\nstatic int nfa_classcodes[] = {\n    NFA_ANY, NFA_IDENT, NFA_SIDENT, NFA_KWORD,NFA_SKWORD,\n    NFA_FNAME, NFA_SFNAME, NFA_PRINT, NFA_SPRINT,\n    NFA_WHITE, NFA_NWHITE, NFA_DIGIT, NFA_NDIGIT,\n    NFA_HEX, NFA_NHEX, NFA_OCTAL, NFA_NOCTAL,\n    NFA_WORD, NFA_NWORD, NFA_HEAD, NFA_NHEAD,\n    NFA_ALPHA, NFA_NALPHA, NFA_LOWER, NFA_NLOWER,\n    NFA_UPPER, NFA_NUPPER\n};\n\nstatic char_u e_nul_found[] = N_(\"E865: (NFA) Regexp end encountered prematurely\");\nstatic char_u e_misplaced[] = N_(\"E866: (NFA regexp) Misplaced %c\");\nstatic char_u e_ill_char_class[] = N_(\"E877: (NFA regexp) Invalid character class: %d\");\nstatic char_u e_value_too_large[] = N_(\"E951: \\\\% value too large\");\n\n// Variables only used in nfa_regcomp() and descendants.\nstatic int nfa_re_flags; // re_flags passed to nfa_regcomp()\nstatic int *post_start;  // holds the postfix form of r.e.\nstatic int *post_end;\nstatic int *post_ptr;\n\n// Set when the pattern should use the NFA engine.\n// E.g. [[:upper:]] only allows 8bit characters for BT engine,\n// while NFA engine handles multibyte characters correctly.\nstatic int wants_nfa;\n\nstatic int nstate;\t// Number of states in the NFA.\nstatic int istate;\t// Index in the state vector, used in alloc_state()\n\n// If not NULL match must end at this position\nstatic save_se_T *nfa_endp = NULL;\n\n// 0 for first call to nfa_regmatch(), 1 for recursive call.\nstatic int nfa_ll_index = 0;\n\nstatic int realloc_post_list(void);\nstatic int nfa_reg(int paren);\n#ifdef DEBUG\nstatic void nfa_print_state2(FILE *debugf, nfa_state_T *state, garray_T *indent);\n#endif\nstatic int match_follows(nfa_state_T *startstate, int depth);\nstatic int failure_chance(nfa_state_T *state, int depth);\n\n// helper functions used when doing re2post() ... regatom() parsing\n#define EMIT(c)\tdo {\t\t\t\t\\\n\t\t    if (post_ptr >= post_end && realloc_post_list() == FAIL) \\\n\t\t\treturn FAIL;\t\t\\\n\t\t    *post_ptr++ = c;\t\t\\\n\t\t} while (0)\n\n/*\n * Initialize internal variables before NFA compilation.\n * Return OK on success, FAIL otherwise.\n */\n    static int\nnfa_regcomp_start(\n    char_u\t*expr,\n    int\t\tre_flags)\t    // see vim_regcomp()\n{\n    size_t\tpostfix_size;\n    int\t\tnstate_max;\n\n    nstate = 0;\n    istate = 0;\n    // A reasonable estimation for maximum size\n    nstate_max = (int)(STRLEN(expr) + 1) * 25;\n\n    // Some items blow up in size, such as [A-z].  Add more space for that.\n    // When it is still not enough realloc_post_list() will be used.\n    nstate_max += 1000;\n\n    // Size for postfix representation of expr.\n    postfix_size = sizeof(int) * nstate_max;\n\n    post_start = alloc(postfix_size);\n    if (post_start == NULL)\n\treturn FAIL;\n    post_ptr = post_start;\n    post_end = post_start + nstate_max;\n    wants_nfa = FALSE;\n    rex.nfa_has_zend = FALSE;\n    rex.nfa_has_backref = FALSE;\n\n    // shared with BT engine\n    regcomp_start(expr, re_flags);\n\n    return OK;\n}\n\n/*\n * Figure out if the NFA state list starts with an anchor, must match at start\n * of the line.\n */\n    static int\nnfa_get_reganch(nfa_state_T *start, int depth)\n{\n    nfa_state_T *p = start;\n\n    if (depth > 4)\n\treturn 0;\n\n    while (p != NULL)\n    {\n\tswitch (p->c)\n\t{\n\t    case NFA_BOL:\n\t    case NFA_BOF:\n\t\treturn 1; // yes!\n\n\t    case NFA_ZSTART:\n\t    case NFA_ZEND:\n\t    case NFA_CURSOR:\n\t    case NFA_VISUAL:\n\n\t    case NFA_MOPEN:\n\t    case NFA_MOPEN1:\n\t    case NFA_MOPEN2:\n\t    case NFA_MOPEN3:\n\t    case NFA_MOPEN4:\n\t    case NFA_MOPEN5:\n\t    case NFA_MOPEN6:\n\t    case NFA_MOPEN7:\n\t    case NFA_MOPEN8:\n\t    case NFA_MOPEN9:\n\t    case NFA_NOPEN:\n#ifdef FEAT_SYN_HL\n\t    case NFA_ZOPEN:\n\t    case NFA_ZOPEN1:\n\t    case NFA_ZOPEN2:\n\t    case NFA_ZOPEN3:\n\t    case NFA_ZOPEN4:\n\t    case NFA_ZOPEN5:\n\t    case NFA_ZOPEN6:\n\t    case NFA_ZOPEN7:\n\t    case NFA_ZOPEN8:\n\t    case NFA_ZOPEN9:\n#endif\n\t\tp = p->out;\n\t\tbreak;\n\n\t    case NFA_SPLIT:\n\t\treturn nfa_get_reganch(p->out, depth + 1)\n\t\t\t\t       && nfa_get_reganch(p->out1, depth + 1);\n\n\t    default:\n\t\treturn 0; // noooo\n\t}\n    }\n    return 0;\n}\n\n/*\n * Figure out if the NFA state list starts with a character which must match\n * at start of the match.\n */\n    static int\nnfa_get_regstart(nfa_state_T *start, int depth)\n{\n    nfa_state_T *p = start;\n\n    if (depth > 4)\n\treturn 0;\n\n    while (p != NULL)\n    {\n\tswitch (p->c)\n\t{\n\t    // all kinds of zero-width matches\n\t    case NFA_BOL:\n\t    case NFA_BOF:\n\t    case NFA_BOW:\n\t    case NFA_EOW:\n\t    case NFA_ZSTART:\n\t    case NFA_ZEND:\n\t    case NFA_CURSOR:\n\t    case NFA_VISUAL:\n\t    case NFA_LNUM:\n\t    case NFA_LNUM_GT:\n\t    case NFA_LNUM_LT:\n\t    case NFA_COL:\n\t    case NFA_COL_GT:\n\t    case NFA_COL_LT:\n\t    case NFA_VCOL:\n\t    case NFA_VCOL_GT:\n\t    case NFA_VCOL_LT:\n\t    case NFA_MARK:\n\t    case NFA_MARK_GT:\n\t    case NFA_MARK_LT:\n\n\t    case NFA_MOPEN:\n\t    case NFA_MOPEN1:\n\t    case NFA_MOPEN2:\n\t    case NFA_MOPEN3:\n\t    case NFA_MOPEN4:\n\t    case NFA_MOPEN5:\n\t    case NFA_MOPEN6:\n\t    case NFA_MOPEN7:\n\t    case NFA_MOPEN8:\n\t    case NFA_MOPEN9:\n\t    case NFA_NOPEN:\n#ifdef FEAT_SYN_HL\n\t    case NFA_ZOPEN:\n\t    case NFA_ZOPEN1:\n\t    case NFA_ZOPEN2:\n\t    case NFA_ZOPEN3:\n\t    case NFA_ZOPEN4:\n\t    case NFA_ZOPEN5:\n\t    case NFA_ZOPEN6:\n\t    case NFA_ZOPEN7:\n\t    case NFA_ZOPEN8:\n\t    case NFA_ZOPEN9:\n#endif\n\t\tp = p->out;\n\t\tbreak;\n\n\t    case NFA_SPLIT:\n\t    {\n\t\tint c1 = nfa_get_regstart(p->out, depth + 1);\n\t\tint c2 = nfa_get_regstart(p->out1, depth + 1);\n\n\t\tif (c1 == c2)\n\t\t    return c1; // yes!\n\t\treturn 0;\n\t    }\n\n\t    default:\n\t\tif (p->c > 0)\n\t\t    return p->c; // yes!\n\t\treturn 0;\n\t}\n    }\n    return 0;\n}\n\n/*\n * Figure out if the NFA state list contains just literal text and nothing\n * else.  If so return a string in allocated memory with what must match after\n * regstart.  Otherwise return NULL.\n */\n    static char_u *\nnfa_get_match_text(nfa_state_T *start)\n{\n    nfa_state_T *p = start;\n    int\t\tlen = 0;\n    char_u\t*ret;\n    char_u\t*s;\n\n    if (p->c != NFA_MOPEN)\n\treturn NULL; // just in case\n    p = p->out;\n    while (p->c > 0)\n    {\n\tlen += MB_CHAR2LEN(p->c);\n\tp = p->out;\n    }\n    if (p->c != NFA_MCLOSE || p->out->c != NFA_MATCH)\n\treturn NULL;\n\n    ret = alloc(len);\n    if (ret != NULL)\n    {\n\tp = start->out->out; // skip first char, it goes into regstart\n\ts = ret;\n\twhile (p->c > 0)\n\t{\n\t    if (has_mbyte)\n\t\ts += (*mb_char2bytes)(p->c, s);\n\t    else\n\t\t*s++ = p->c;\n\t    p = p->out;\n\t}\n\t*s = NUL;\n    }\n    return ret;\n}\n\n/*\n * Allocate more space for post_start.  Called when\n * running above the estimated number of states.\n */\n    static int\nrealloc_post_list(void)\n{\n    int   nstate_max = (int)(post_end - post_start);\n    int   new_max;\n    int   *new_start;\n    int\t  *old_start;\n\n    // For weird patterns the number of states can be very high. Increasing by\n    // 50% seems a reasonable compromise between memory use and speed.\n    new_max = nstate_max * 3 / 2;\n    new_start = ALLOC_MULT(int, new_max);\n    if (new_start == NULL)\n\treturn FAIL;\n    mch_memmove(new_start, post_start, nstate_max * sizeof(int));\n    old_start = post_start;\n    post_start = new_start;\n    post_ptr = new_start + (post_ptr - old_start);\n    post_end = post_start + new_max;\n    vim_free(old_start);\n    return OK;\n}\n\n/*\n * Search between \"start\" and \"end\" and try to recognize a\n * character class in expanded form. For example [0-9].\n * On success, return the id the character class to be emitted.\n * On failure, return 0 (=FAIL)\n * Start points to the first char of the range, while end should point\n * to the closing brace.\n * Keep in mind that 'ignorecase' applies at execution time, thus [a-z] may\n * need to be interpreted as [a-zA-Z].\n */\n    static int\nnfa_recognize_char_class(char_u *start, char_u *end, int extra_newl)\n{\n#   define CLASS_not\t\t0x80\n#   define CLASS_af\t\t0x40\n#   define CLASS_AF\t\t0x20\n#   define CLASS_az\t\t0x10\n#   define CLASS_AZ\t\t0x08\n#   define CLASS_o7\t\t0x04\n#   define CLASS_o9\t\t0x02\n#   define CLASS_underscore\t0x01\n\n    int\t\tnewl = FALSE;\n    char_u\t*p;\n    int\t\tconfig = 0;\n\n    if (extra_newl == TRUE)\n\tnewl = TRUE;\n\n    if (*end != ']')\n\treturn FAIL;\n    p = start;\n    if (*p == '^')\n    {\n\tconfig |= CLASS_not;\n\tp++;\n    }\n\n    while (p < end)\n    {\n\tif (p + 2 < end && *(p + 1) == '-')\n\t{\n\t    switch (*p)\n\t    {\n\t\tcase '0':\n\t\t    if (*(p + 2) == '9')\n\t\t    {\n\t\t\tconfig |= CLASS_o9;\n\t\t\tbreak;\n\t\t    }\n\t\t    if (*(p + 2) == '7')\n\t\t    {\n\t\t\tconfig |= CLASS_o7;\n\t\t\tbreak;\n\t\t    }\n\t\t    return FAIL;\n\n\t\tcase 'a':\n\t\t    if (*(p + 2) == 'z')\n\t\t    {\n\t\t\tconfig |= CLASS_az;\n\t\t\tbreak;\n\t\t    }\n\t\t    if (*(p + 2) == 'f')\n\t\t    {\n\t\t\tconfig |= CLASS_af;\n\t\t\tbreak;\n\t\t    }\n\t\t    return FAIL;\n\n\t\tcase 'A':\n\t\t    if (*(p + 2) == 'Z')\n\t\t    {\n\t\t\tconfig |= CLASS_AZ;\n\t\t\tbreak;\n\t\t    }\n\t\t    if (*(p + 2) == 'F')\n\t\t    {\n\t\t\tconfig |= CLASS_AF;\n\t\t\tbreak;\n\t\t    }\n\t\t    return FAIL;\n\n\t\tdefault:\n\t\t    return FAIL;\n\t    }\n\t    p += 3;\n\t}\n\telse if (p + 1 < end && *p == '\\\\' && *(p + 1) == 'n')\n\t{\n\t    newl = TRUE;\n\t    p += 2;\n\t}\n\telse if (*p == '_')\n\t{\n\t    config |= CLASS_underscore;\n\t    p ++;\n\t}\n\telse if (*p == '\\n')\n\t{\n\t    newl = TRUE;\n\t    p ++;\n\t}\n\telse\n\t    return FAIL;\n    } // while (p < end)\n\n    if (p != end)\n\treturn FAIL;\n\n    if (newl == TRUE)\n\textra_newl = NFA_ADD_NL;\n\n    switch (config)\n    {\n\tcase CLASS_o9:\n\t    return extra_newl + NFA_DIGIT;\n\tcase CLASS_not |  CLASS_o9:\n\t    return extra_newl + NFA_NDIGIT;\n\tcase CLASS_af | CLASS_AF | CLASS_o9:\n\t    return extra_newl + NFA_HEX;\n\tcase CLASS_not | CLASS_af | CLASS_AF | CLASS_o9:\n\t    return extra_newl + NFA_NHEX;\n\tcase CLASS_o7:\n\t    return extra_newl + NFA_OCTAL;\n\tcase CLASS_not | CLASS_o7:\n\t    return extra_newl + NFA_NOCTAL;\n\tcase CLASS_az | CLASS_AZ | CLASS_o9 | CLASS_underscore:\n\t    return extra_newl + NFA_WORD;\n\tcase CLASS_not | CLASS_az | CLASS_AZ | CLASS_o9 | CLASS_underscore:\n\t    return extra_newl + NFA_NWORD;\n\tcase CLASS_az | CLASS_AZ | CLASS_underscore:\n\t    return extra_newl + NFA_HEAD;\n\tcase CLASS_not | CLASS_az | CLASS_AZ | CLASS_underscore:\n\t    return extra_newl + NFA_NHEAD;\n\tcase CLASS_az | CLASS_AZ:\n\t    return extra_newl + NFA_ALPHA;\n\tcase CLASS_not | CLASS_az | CLASS_AZ:\n\t    return extra_newl + NFA_NALPHA;\n\tcase CLASS_az:\n\t   return extra_newl + NFA_LOWER_IC;\n\tcase CLASS_not | CLASS_az:\n\t    return extra_newl + NFA_NLOWER_IC;\n\tcase CLASS_AZ:\n\t    return extra_newl + NFA_UPPER_IC;\n\tcase CLASS_not | CLASS_AZ:\n\t    return extra_newl + NFA_NUPPER_IC;\n    }\n    return FAIL;\n}\n\n/*\n * Produce the bytes for equivalence class \"c\".\n * Currently only handles latin1, latin9 and utf-8.\n * Emits bytes in postfix notation: 'a,b,NFA_OR,c,NFA_OR' is\n * equivalent to 'a OR b OR c'\n *\n * NOTE! When changing this function, also update reg_equi_class()\n */\n    static int\nnfa_emit_equi_class(int c)\n{\n#define EMIT2(c)    EMIT(c); EMIT(NFA_CONCAT);\n\n    if (enc_utf8 || STRCMP(p_enc, \"latin1\") == 0\n\t\t\t\t\t || STRCMP(p_enc, \"iso-8859-15\") == 0)\n    {\n#ifdef EBCDIC\n# define A_circumflex 0x62\n# define A_diaeresis 0x63\n# define A_grave 0x64\n# define A_acute 0x65\n# define A_virguilla 0x66\n# define A_ring 0x67\n# define C_cedilla 0x68\n# define E_acute 0x71\n# define E_circumflex 0x72\n# define E_diaeresis 0x73\n# define E_grave 0x74\n# define I_acute 0x75\n# define I_circumflex 0x76\n# define I_diaeresis 0x77\n# define I_grave 0x78\n# define N_virguilla 0x69\n# define O_circumflex 0xeb\n# define O_diaeresis 0xec\n# define O_grave 0xed\n# define O_acute 0xee\n# define O_virguilla 0xef\n# define O_slash 0x80\n# define U_circumflex 0xfb\n# define U_diaeresis 0xfc\n# define U_grave 0xfd\n# define U_acute 0xfe\n# define Y_acute 0xba\n# define a_grave 0x42\n# define a_acute 0x43\n# define a_circumflex 0x44\n# define a_virguilla 0x45\n# define a_diaeresis 0x46\n# define a_ring 0x47\n# define c_cedilla 0x48\n# define e_grave 0x51\n# define e_acute 0x52\n# define e_circumflex 0x53\n# define e_diaeresis 0x54\n# define i_grave 0x55\n# define i_acute 0x56\n# define i_circumflex 0x57\n# define i_diaeresis 0x58\n# define n_virguilla 0x49\n# define o_grave 0xcb\n# define o_acute 0xcc\n# define o_circumflex 0xcd\n# define o_virguilla 0xce\n# define o_diaeresis 0xcf\n# define o_slash 0x70\n# define u_grave 0xdb\n# define u_acute 0xdc\n# define u_circumflex 0xdd\n# define u_diaeresis 0xde\n# define y_acute 0x8d\n# define y_diaeresis 0xdf\n#else\n# define A_grave 0xc0\n# define A_acute 0xc1\n# define A_circumflex 0xc2\n# define A_virguilla 0xc3\n# define A_diaeresis 0xc4\n# define A_ring 0xc5\n# define C_cedilla 0xc7\n# define E_grave 0xc8\n# define E_acute 0xc9\n# define E_circumflex 0xca\n# define E_diaeresis 0xcb\n# define I_grave 0xcc\n# define I_acute 0xcd\n# define I_circumflex 0xce\n# define I_diaeresis 0xcf\n# define N_virguilla 0xd1\n# define O_grave 0xd2\n# define O_acute 0xd3\n# define O_circumflex 0xd4\n# define O_virguilla 0xd5\n# define O_diaeresis 0xd6\n# define O_slash 0xd8\n# define U_grave 0xd9\n# define U_acute 0xda\n# define U_circumflex 0xdb\n# define U_diaeresis 0xdc\n# define Y_acute 0xdd\n# define a_grave 0xe0\n# define a_acute 0xe1\n# define a_circumflex 0xe2\n# define a_virguilla 0xe3\n# define a_diaeresis 0xe4\n# define a_ring 0xe5\n# define c_cedilla 0xe7\n# define e_grave 0xe8\n# define e_acute 0xe9\n# define e_circumflex 0xea\n# define e_diaeresis 0xeb\n# define i_grave 0xec\n# define i_acute 0xed\n# define i_circumflex 0xee\n# define i_diaeresis 0xef\n# define n_virguilla 0xf1\n# define o_grave 0xf2\n# define o_acute 0xf3\n# define o_circumflex 0xf4\n# define o_virguilla 0xf5\n# define o_diaeresis 0xf6\n# define o_slash 0xf8\n# define u_grave 0xf9\n# define u_acute 0xfa\n# define u_circumflex 0xfb\n# define u_diaeresis 0xfc\n# define y_acute 0xfd\n# define y_diaeresis 0xff\n#endif\n\tswitch (c)\n\t{\n\t    case 'A': case A_grave: case A_acute: case A_circumflex:\n\t    case A_virguilla: case A_diaeresis: case A_ring:\n\t    case 0x100: case 0x102: case 0x104: case 0x1cd:\n\t    case 0x1de: case 0x1e0: case 0x1fa: case 0x200:\n\t    case 0x202: case 0x226: case 0x23a: case 0x1e00:\n\t    case 0x1ea0: case 0x1ea2: case 0x1ea4: case 0x1ea6:\n\t    case 0x1ea8: case 0x1eaa: case 0x1eac: case 0x1eae:\n\t    case 0x1eb0: case 0x1eb2: case 0x1eb4: case 0x1eb6:\n\t\t    EMIT2('A') EMIT2(A_grave) EMIT2(A_acute)\n\t\t    EMIT2(A_circumflex) EMIT2(A_virguilla)\n\t\t    EMIT2(A_diaeresis) EMIT2(A_ring)\n\t\t    EMIT2(0x100) EMIT2(0x102) EMIT2(0x104)\n\t\t    EMIT2(0x1cd) EMIT2(0x1de) EMIT2(0x1e0)\n\t\t    EMIT2(0x1fa) EMIT2(0x200) EMIT2(0x202)\n\t\t    EMIT2(0x226) EMIT2(0x23a) EMIT2(0x1e00)\n\t\t    EMIT2(0x1ea0) EMIT2(0x1ea2) EMIT2(0x1ea4)\n\t\t    EMIT2(0x1ea6) EMIT2(0x1ea8) EMIT2(0x1eaa)\n\t\t    EMIT2(0x1eac) EMIT2(0x1eae) EMIT2(0x1eb0)\n\t\t    EMIT2(0x1eb2) EMIT2(0x1eb6) EMIT2(0x1eb4)\n\t\t    return OK;\n\n\t    case 'B': case 0x181: case 0x243: case 0x1e02:\n\t    case 0x1e04: case 0x1e06:\n\t\t    EMIT2('B')\n\t\t    EMIT2(0x181) EMIT2(0x243) EMIT2(0x1e02)\n\t\t    EMIT2(0x1e04) EMIT2(0x1e06)\n\t\t    return OK;\n\n\t    case 'C': case C_cedilla: case 0x106: case 0x108:\n\t    case 0x10a: case 0x10c: case 0x187: case 0x23b:\n\t    case 0x1e08: case 0xa792:\n\t\t    EMIT2('C') EMIT2(C_cedilla)\n\t\t    EMIT2(0x106) EMIT2(0x108) EMIT2(0x10a)\n\t\t    EMIT2(0x10c) EMIT2(0x187) EMIT2(0x23b)\n\t\t    EMIT2(0x1e08) EMIT2(0xa792)\n\t\t    return OK;\n\n\t    case 'D': case 0x10e: case 0x110: case 0x18a:\n\t    case 0x1e0a: case 0x1e0c: case 0x1e0e: case 0x1e10:\n\t    case 0x1e12:\n\t\t    EMIT2('D') EMIT2(0x10e) EMIT2(0x110) EMIT2(0x18a)\n\t\t    EMIT2(0x1e0a) EMIT2(0x1e0c) EMIT2(0x1e0e)\n\t\t    EMIT2(0x1e10) EMIT2(0x1e12)\n\t\t    return OK;\n\n\t    case 'E': case E_grave: case E_acute: case E_circumflex:\n\t    case E_diaeresis: case 0x112: case 0x114: case 0x116:\n\t    case 0x118: case 0x11a: case 0x204: case 0x206:\n\t    case 0x228: case 0x246: case 0x1e14: case 0x1e16:\n\t    case 0x1e18: case 0x1e1a: case 0x1e1c: case 0x1eb8:\n\t    case 0x1eba: case 0x1ebc: case 0x1ebe: case 0x1ec0:\n\t    case 0x1ec2: case 0x1ec4: case 0x1ec6:\n\t\t    EMIT2('E') EMIT2(E_grave) EMIT2(E_acute)\n\t\t    EMIT2(E_circumflex) EMIT2(E_diaeresis)\n\t\t    EMIT2(0x112) EMIT2(0x114) EMIT2(0x116)\n\t\t    EMIT2(0x118) EMIT2(0x11a) EMIT2(0x204)\n\t\t    EMIT2(0x206) EMIT2(0x228) EMIT2(0x246)\n\t\t    EMIT2(0x1e14) EMIT2(0x1e16) EMIT2(0x1e18)\n\t\t    EMIT2(0x1e1a) EMIT2(0x1e1c) EMIT2(0x1eb8)\n\t\t    EMIT2(0x1eba) EMIT2(0x1ebc) EMIT2(0x1ebe)\n\t\t    EMIT2(0x1ec0) EMIT2(0x1ec2) EMIT2(0x1ec4)\n\t\t    EMIT2(0x1ec6)\n\t\t    return OK;\n\n\t    case 'F': case 0x191: case 0x1e1e: case 0xa798:\n\t\t    EMIT2('F') EMIT2(0x191) EMIT2(0x1e1e) EMIT2(0xa798)\n\t\t    return OK;\n\n\t    case 'G': case 0x11c: case 0x11e: case 0x120:\n\t    case 0x122: case 0x193: case 0x1e4: case 0x1e6:\n\t    case 0x1f4: case 0x1e20: case 0xa7a0:\n\t\t    EMIT2('G') EMIT2(0x11c) EMIT2(0x11e) EMIT2(0x120)\n\t\t    EMIT2(0x122) EMIT2(0x193) EMIT2(0x1e4)\n\t\t    EMIT2(0x1e6) EMIT2(0x1f4) EMIT2(0x1e20)\n\t\t    EMIT2(0xa7a0)\n\t\t    return OK;\n\n\t    case 'H': case 0x124: case 0x126: case 0x21e:\n\t    case 0x1e22: case 0x1e24: case 0x1e26: case 0x1e28:\n\t    case 0x1e2a: case 0x2c67:\n\t\t    EMIT2('H') EMIT2(0x124) EMIT2(0x126) EMIT2(0x21e)\n\t\t    EMIT2(0x1e22) EMIT2(0x1e24) EMIT2(0x1e26)\n\t\t    EMIT2(0x1e28) EMIT2(0x1e2a) EMIT2(0x2c67)\n\t\t    return OK;\n\n\t    case 'I': case I_grave: case I_acute: case I_circumflex:\n\t    case I_diaeresis: case 0x128: case 0x12a: case 0x12c:\n\t    case 0x12e: case 0x130: case 0x197: case 0x1cf:\n\t    case 0x208: case 0x20a: case 0x1e2c: case 0x1e2e:\n\t    case 0x1ec8: case 0x1eca:\n\t\t    EMIT2('I') EMIT2(I_grave) EMIT2(I_acute)\n\t\t    EMIT2(I_circumflex) EMIT2(I_diaeresis)\n\t\t    EMIT2(0x128) EMIT2(0x12a) EMIT2(0x12c)\n\t\t    EMIT2(0x12e) EMIT2(0x130) EMIT2(0x197)\n\t\t    EMIT2(0x1cf) EMIT2(0x208) EMIT2(0x20a)\n\t\t    EMIT2(0x1e2c) EMIT2(0x1e2e) EMIT2(0x1ec8)\n\t\t    EMIT2(0x1eca)\n\t\t    return OK;\n\n\t    case 'J': case 0x134: case 0x248:\n\t\t    EMIT2('J') EMIT2(0x134) EMIT2(0x248)\n\t\t    return OK;\n\n\t    case 'K': case 0x136: case 0x198: case 0x1e8: case 0x1e30:\n\t    case 0x1e32: case 0x1e34: case 0x2c69: case 0xa740:\n\t\t    EMIT2('K') EMIT2(0x136) EMIT2(0x198) EMIT2(0x1e8)\n\t\t    EMIT2(0x1e30) EMIT2(0x1e32) EMIT2(0x1e34)\n\t\t    EMIT2(0x2c69) EMIT2(0xa740)\n\t\t    return OK;\n\n\t    case 'L': case 0x139: case 0x13b: case 0x13d:\n\t    case 0x13f: case 0x141: case 0x23d: case 0x1e36:\n\t    case 0x1e38: case 0x1e3a: case 0x1e3c: case 0x2c60:\n\t\t    EMIT2('L') EMIT2(0x139) EMIT2(0x13b)\n\t\t    EMIT2(0x13d) EMIT2(0x13f) EMIT2(0x141)\n\t\t    EMIT2(0x23d) EMIT2(0x1e36) EMIT2(0x1e38)\n\t\t    EMIT2(0x1e3a) EMIT2(0x1e3c) EMIT2(0x2c60)\n\t\t    return OK;\n\n\t    case 'M': case 0x1e3e: case 0x1e40: case 0x1e42:\n\t\t    EMIT2('M') EMIT2(0x1e3e) EMIT2(0x1e40)\n\t\t    EMIT2(0x1e42)\n\t\t    return OK;\n\n\t    case 'N': case N_virguilla:\n\t    case 0x143: case 0x145: case 0x147: case 0x1f8:\n\t    case 0x1e44: case 0x1e46: case 0x1e48: case 0x1e4a:\n\t    case 0xa7a4:\n\t\t    EMIT2('N') EMIT2(N_virguilla)\n\t\t    EMIT2(0x143) EMIT2(0x145) EMIT2(0x147)\n\t\t    EMIT2(0x1f8) EMIT2(0x1e44) EMIT2(0x1e46)\n\t\t    EMIT2(0x1e48) EMIT2(0x1e4a) EMIT2(0xa7a4)\n\t\t    return OK;\n\n\t    case 'O': case O_grave: case O_acute: case O_circumflex:\n\t    case O_virguilla: case O_diaeresis: case O_slash:\n\t    case 0x14c: case 0x14e: case 0x150: case 0x19f:\n\t    case 0x1a0: case 0x1d1: case 0x1ea: case 0x1ec:\n\t    case 0x1fe: case 0x20c: case 0x20e: case 0x22a:\n\t    case 0x22c: case 0x22e: case 0x230: case 0x1e4c:\n\t    case 0x1e4e: case 0x1e50: case 0x1e52: case 0x1ecc:\n\t    case 0x1ece: case 0x1ed0: case 0x1ed2: case 0x1ed4:\n\t    case 0x1ed6: case 0x1ed8: case 0x1eda: case 0x1edc:\n\t    case 0x1ede: case 0x1ee0: case 0x1ee2:\n\t\t    EMIT2('O') EMIT2(O_grave) EMIT2(O_acute)\n\t\t    EMIT2(O_circumflex) EMIT2(O_virguilla)\n\t\t    EMIT2(O_diaeresis) EMIT2(O_slash)\n\t\t    EMIT2(0x14c) EMIT2(0x14e) EMIT2(0x150)\n\t\t    EMIT2(0x19f) EMIT2(0x1a0) EMIT2(0x1d1)\n\t\t    EMIT2(0x1ea) EMIT2(0x1ec) EMIT2(0x1fe)\n\t\t    EMIT2(0x20c) EMIT2(0x20e) EMIT2(0x22a)\n\t\t    EMIT2(0x22c) EMIT2(0x22e) EMIT2(0x230)\n\t\t    EMIT2(0x1e4c) EMIT2(0x1e4e) EMIT2(0x1e50)\n\t\t    EMIT2(0x1e52) EMIT2(0x1ecc) EMIT2(0x1ece)\n\t\t    EMIT2(0x1ed0) EMIT2(0x1ed2) EMIT2(0x1ed4)\n\t\t    EMIT2(0x1ed6) EMIT2(0x1ed8) EMIT2(0x1eda)\n\t\t    EMIT2(0x1edc) EMIT2(0x1ede) EMIT2(0x1ee0)\n\t\t    EMIT2(0x1ee2)\n\t\t    return OK;\n\n\t    case 'P': case 0x1a4: case 0x1e54: case 0x1e56: case 0x2c63:\n\t\t    EMIT2('P') EMIT2(0x1a4) EMIT2(0x1e54) EMIT2(0x1e56)\n\t\t    EMIT2(0x2c63)\n\t\t    return OK;\n\n\t    case 'Q': case 0x24a:\n\t\t    EMIT2('Q') EMIT2(0x24a)\n\t\t    return OK;\n\n\t    case 'R': case 0x154: case 0x156: case 0x158: case 0x210:\n\t    case 0x212: case 0x24c: case 0x1e58: case 0x1e5a:\n\t    case 0x1e5c: case 0x1e5e: case 0x2c64: case 0xa7a6:\n\t\t    EMIT2('R') EMIT2(0x154) EMIT2(0x156) EMIT2(0x158)\n\t\t    EMIT2(0x210) EMIT2(0x212) EMIT2(0x24c) EMIT2(0x1e58)\n\t\t    EMIT2(0x1e5a) EMIT2(0x1e5c) EMIT2(0x1e5e) EMIT2(0x2c64)\n\t\t    EMIT2(0xa7a6)\n\t\t    return OK;\n\n\t    case 'S': case 0x15a: case 0x15c: case 0x15e: case 0x160:\n\t    case 0x218: case 0x1e60: case 0x1e62: case 0x1e64:\n\t    case 0x1e66: case 0x1e68: case 0x2c7e: case 0xa7a8:\n\t\t    EMIT2('S') EMIT2(0x15a) EMIT2(0x15c) EMIT2(0x15e)\n\t\t    EMIT2(0x160) EMIT2(0x218) EMIT2(0x1e60) EMIT2(0x1e62)\n\t\t    EMIT2(0x1e64) EMIT2(0x1e66) EMIT2(0x1e68) EMIT2(0x2c7e)\n\t\t    EMIT2(0xa7a8)\n\t\t    return OK;\n\n\t    case 'T': case 0x162: case 0x164: case 0x166: case 0x1ac:\n\t    case 0x1ae: case 0x21a: case 0x23e: case 0x1e6a: case 0x1e6c:\n\t    case 0x1e6e: case 0x1e70:\n\t\t    EMIT2('T') EMIT2(0x162) EMIT2(0x164) EMIT2(0x166)\n\t\t    EMIT2(0x1ac) EMIT2(0x1ae) EMIT2(0x23e) EMIT2(0x21a)\n\t\t    EMIT2(0x1e6a) EMIT2(0x1e6c) EMIT2(0x1e6e) EMIT2(0x1e70)\n\t\t    return OK;\n\n\t    case 'U': case U_grave: case U_acute: case U_diaeresis:\n\t    case U_circumflex: case 0x168: case 0x16a: case 0x16c:\n\t    case 0x16e: case 0x170: case 0x172: case 0x1af:\n\t    case 0x1d3: case 0x1d5: case 0x1d7: case 0x1d9:\n\t    case 0x1db: case 0x214: case 0x216: case 0x244:\n\t    case 0x1e72: case 0x1e74: case 0x1e76: case 0x1e78:\n\t    case 0x1e7a: case 0x1ee4: case 0x1ee6: case 0x1ee8:\n\t    case 0x1eea: case 0x1eec: case 0x1eee: case 0x1ef0:\n\t\t    EMIT2('U') EMIT2(U_grave) EMIT2(U_acute)\n\t\t    EMIT2(U_diaeresis) EMIT2(U_circumflex)\n\t\t    EMIT2(0x168) EMIT2(0x16a)\n\t\t    EMIT2(0x16c) EMIT2(0x16e) EMIT2(0x170)\n\t\t    EMIT2(0x172) EMIT2(0x1af) EMIT2(0x1d3)\n\t\t    EMIT2(0x1d5) EMIT2(0x1d7) EMIT2(0x1d9)\n\t\t    EMIT2(0x1db) EMIT2(0x214) EMIT2(0x216)\n\t\t    EMIT2(0x244) EMIT2(0x1e72) EMIT2(0x1e74)\n\t\t    EMIT2(0x1e76) EMIT2(0x1e78) EMIT2(0x1e7a)\n\t\t    EMIT2(0x1ee4) EMIT2(0x1ee6) EMIT2(0x1ee8)\n\t\t    EMIT2(0x1eea) EMIT2(0x1eec) EMIT2(0x1eee)\n\t\t    EMIT2(0x1ef0)\n\t\t    return OK;\n\n\t    case 'V': case 0x1b2: case 0x1e7c: case 0x1e7e:\n\t\t    EMIT2('V') EMIT2(0x1b2) EMIT2(0x1e7c) EMIT2(0x1e7e)\n\t\t    return OK;\n\n\t    case 'W': case 0x174: case 0x1e80: case 0x1e82: case 0x1e84:\n\t    case 0x1e86: case 0x1e88:\n\t\t    EMIT2('W') EMIT2(0x174) EMIT2(0x1e80) EMIT2(0x1e82)\n\t\t    EMIT2(0x1e84) EMIT2(0x1e86) EMIT2(0x1e88)\n\t\t    return OK;\n\n\t    case 'X': case 0x1e8a: case 0x1e8c:\n\t\t    EMIT2('X') EMIT2(0x1e8a) EMIT2(0x1e8c)\n\t\t    return OK;\n\n\t    case 'Y': case Y_acute: case 0x176: case 0x178:\n\t    case 0x1b3: case 0x232: case 0x24e: case 0x1e8e:\n\t    case 0x1ef2: case 0x1ef4: case 0x1ef6: case 0x1ef8:\n\t\t    EMIT2('Y') EMIT2(Y_acute)\n\t\t    EMIT2(0x176) EMIT2(0x178) EMIT2(0x1b3)\n\t\t    EMIT2(0x232) EMIT2(0x24e) EMIT2(0x1e8e)\n\t\t    EMIT2(0x1ef2) EMIT2(0x1ef4) EMIT2(0x1ef6)\n\t\t    EMIT2(0x1ef8)\n\t\t    return OK;\n\n\t    case 'Z': case 0x179: case 0x17b: case 0x17d:\n\t    case 0x1b5: case 0x1e90: case 0x1e92: case 0x1e94:\n\t    case 0x2c6b:\n\t\t    EMIT2('Z') EMIT2(0x179) EMIT2(0x17b) EMIT2(0x17d)\n\t\t    EMIT2(0x1b5) EMIT2(0x1e90) EMIT2(0x1e92)\n\t\t    EMIT2(0x1e94) EMIT2(0x2c6b)\n\t\t    return OK;\n\n\t    case 'a': case a_grave: case a_acute: case a_circumflex:\n\t    case a_virguilla: case a_diaeresis: case a_ring:\n\t    case 0x101: case 0x103: case 0x105: case 0x1ce:\n\t    case 0x1df: case 0x1e1: case 0x1fb: case 0x201:\n\t    case 0x203: case 0x227: case 0x1d8f: case 0x1e01:\n\t    case 0x1e9a: case 0x1ea1: case 0x1ea3: case 0x1ea5:\n\t    case 0x1ea7: case 0x1ea9: case 0x1eab: case 0x1ead:\n\t    case 0x1eaf: case 0x1eb1: case 0x1eb3: case 0x1eb5:\n\t    case 0x1eb7: case 0x2c65:\n\t\t    EMIT2('a') EMIT2(a_grave) EMIT2(a_acute)\n\t\t    EMIT2(a_circumflex) EMIT2(a_virguilla)\n\t\t    EMIT2(a_diaeresis) EMIT2(a_ring)\n\t\t    EMIT2(0x101) EMIT2(0x103) EMIT2(0x105)\n\t\t    EMIT2(0x1ce) EMIT2(0x1df) EMIT2(0x1e1)\n\t\t    EMIT2(0x1fb) EMIT2(0x201) EMIT2(0x203)\n\t\t    EMIT2(0x227) EMIT2(0x1d8f) EMIT2(0x1e01)\n\t\t    EMIT2(0x1e9a) EMIT2(0x1ea1) EMIT2(0x1ea3)\n\t\t    EMIT2(0x1ea5) EMIT2(0x1ea7) EMIT2(0x1ea9)\n\t\t    EMIT2(0x1eab) EMIT2(0x1ead) EMIT2(0x1eaf)\n\t\t    EMIT2(0x1eb1) EMIT2(0x1eb3) EMIT2(0x1eb5)\n\t\t    EMIT2(0x1eb7) EMIT2(0x2c65)\n\t\t    return OK;\n\n\t    case 'b': case 0x180: case 0x253: case 0x1d6c: case 0x1d80:\n\t    case 0x1e03: case 0x1e05: case 0x1e07:\n\t\t    EMIT2('b') EMIT2(0x180) EMIT2(0x253) EMIT2(0x1d6c)\n\t\t    EMIT2(0x1d80) EMIT2(0x1e03) EMIT2(0x1e05) EMIT2(0x1e07)\n\t\t    return OK;\n\n\t    case 'c': case c_cedilla: case 0x107: case 0x109: case 0x10b:\n\t    case 0x10d: case 0x188: case 0x23c: case 0x1e09: case 0xa793:\n\t    case 0xa794:\n\t\t    EMIT2('c') EMIT2(c_cedilla)\n\t\t    EMIT2(0x107) EMIT2(0x109) EMIT2(0x10b)\n\t\t    EMIT2(0x10d) EMIT2(0x188) EMIT2(0x23c)\n\t\t    EMIT2(0x1e09) EMIT2(0xa793) EMIT2(0xa794)\n\t\t    return OK;\n\n\t    case 'd': case 0x10f: case 0x111: case 0x257: case 0x1d6d:\n\t    case 0x1d81: case 0x1d91: case 0x1e0b: case 0x1e0d: case 0x1e0f:\n\t    case 0x1e11: case 0x1e13:\n\t\t    EMIT2('d') EMIT2(0x10f) EMIT2(0x111)\n\t\t    EMIT2(0x257) EMIT2(0x1d6d) EMIT2(0x1d81)\n\t\t    EMIT2(0x1d91) EMIT2(0x1e0b) EMIT2(0x1e0d)\n\t\t    EMIT2(0x1e0f) EMIT2(0x1e11) EMIT2(0x1e13)\n\t\t    return OK;\n\n\t    case 'e': case e_grave: case e_acute: case e_circumflex:\n\t    case e_diaeresis: case 0x113: case 0x115: case 0x117:\n\t    case 0x119: case 0x11b: case 0x205: case 0x207:\n\t    case 0x229: case 0x247: case 0x1d92: case 0x1e15:\n\t    case 0x1e17: case 0x1e19: case 0x1e1b: case 0x1e1d:\n\t    case 0x1eb9: case 0x1ebb: case 0x1ebd: case 0x1ebf:\n\t    case 0x1ec1: case 0x1ec3: case 0x1ec5: case 0x1ec7:\n\t\t    EMIT2('e') EMIT2(e_grave) EMIT2(e_acute)\n\t\t    EMIT2(e_circumflex) EMIT2(e_diaeresis)\n\t\t    EMIT2(0x113) EMIT2(0x115)\n\t\t    EMIT2(0x117) EMIT2(0x119) EMIT2(0x11b)\n\t\t    EMIT2(0x205) EMIT2(0x207) EMIT2(0x229)\n\t\t    EMIT2(0x247) EMIT2(0x1d92) EMIT2(0x1e15)\n\t\t    EMIT2(0x1e17) EMIT2(0x1e19) EMIT2(0x1e1b)\n\t\t    EMIT2(0x1e1d) EMIT2(0x1eb9) EMIT2(0x1ebb)\n\t\t    EMIT2(0x1ebd) EMIT2(0x1ebf) EMIT2(0x1ec1)\n\t\t    EMIT2(0x1ec3) EMIT2(0x1ec5) EMIT2(0x1ec7)\n\t\t    return OK;\n\n\t    case 'f': case 0x192: case 0x1d6e: case 0x1d82:\n\t    case 0x1e1f: case 0xa799:\n\t\t    EMIT2('f') EMIT2(0x192) EMIT2(0x1d6e) EMIT2(0x1d82)\n\t\t    EMIT2(0x1e1f) EMIT2(0xa799)\n\t\t    return OK;\n\n\t    case 'g': case 0x11d: case 0x11f: case 0x121: case 0x123:\n\t    case 0x1e5: case 0x1e7: case 0x1f5: case 0x260: case 0x1d83:\n\t    case 0x1e21: case 0xa7a1:\n\t\t    EMIT2('g') EMIT2(0x11d) EMIT2(0x11f) EMIT2(0x121)\n\t\t    EMIT2(0x123) EMIT2(0x1e5) EMIT2(0x1e7)\n\t\t    EMIT2(0x1f5) EMIT2(0x260) EMIT2(0x1d83)\n\t\t    EMIT2(0x1e21) EMIT2(0xa7a1)\n\t\t    return OK;\n\n\t    case 'h': case 0x125: case 0x127: case 0x21f: case 0x1e23:\n\t    case 0x1e25: case 0x1e27: case 0x1e29: case 0x1e2b:\n\t    case 0x1e96: case 0x2c68: case 0xa795:\n\t\t    EMIT2('h') EMIT2(0x125) EMIT2(0x127) EMIT2(0x21f)\n\t\t    EMIT2(0x1e23) EMIT2(0x1e25) EMIT2(0x1e27)\n\t\t    EMIT2(0x1e29) EMIT2(0x1e2b) EMIT2(0x1e96)\n\t\t    EMIT2(0x2c68) EMIT2(0xa795)\n\t\t    return OK;\n\n\t    case 'i': case i_grave: case i_acute: case i_circumflex:\n\t    case i_diaeresis: case 0x129: case 0x12b: case 0x12d:\n\t    case 0x12f: case 0x1d0: case 0x209: case 0x20b:\n\t    case 0x268: case 0x1d96: case 0x1e2d: case 0x1e2f:\n\t    case 0x1ec9: case 0x1ecb:\n\t\t    EMIT2('i') EMIT2(i_grave) EMIT2(i_acute)\n\t\t    EMIT2(i_circumflex) EMIT2(i_diaeresis)\n\t\t    EMIT2(0x129) EMIT2(0x12b) EMIT2(0x12d)\n\t\t    EMIT2(0x12f) EMIT2(0x1d0) EMIT2(0x209)\n\t\t    EMIT2(0x20b) EMIT2(0x268) EMIT2(0x1d96)\n\t\t    EMIT2(0x1e2d) EMIT2(0x1e2f) EMIT2(0x1ec9)\n\t\t    EMIT2(0x1ecb) EMIT2(0x1ecb)\n\t\t    return OK;\n\n\t    case 'j': case 0x135: case 0x1f0: case 0x249:\n\t\t    EMIT2('j') EMIT2(0x135) EMIT2(0x1f0) EMIT2(0x249)\n\t\t    return OK;\n\n\t    case 'k': case 0x137: case 0x199: case 0x1e9: case 0x1d84:\n\t    case 0x1e31: case 0x1e33: case 0x1e35: case 0x2c6a: case 0xa741:\n\t\t    EMIT2('k') EMIT2(0x137) EMIT2(0x199) EMIT2(0x1e9)\n\t\t    EMIT2(0x1d84) EMIT2(0x1e31) EMIT2(0x1e33)\n\t\t    EMIT2(0x1e35) EMIT2(0x2c6a) EMIT2(0xa741)\n\t\t    return OK;\n\n\t    case 'l': case 0x13a: case 0x13c: case 0x13e: case 0x140:\n\t    case 0x142: case 0x19a: case 0x1e37: case 0x1e39: case 0x1e3b:\n\t    case 0x1e3d: case 0x2c61:\n\t\t    EMIT2('l') EMIT2(0x13a) EMIT2(0x13c)\n\t\t    EMIT2(0x13e) EMIT2(0x140) EMIT2(0x142)\n\t\t    EMIT2(0x19a) EMIT2(0x1e37) EMIT2(0x1e39)\n\t\t    EMIT2(0x1e3b) EMIT2(0x1e3d) EMIT2(0x2c61)\n\t\t    return OK;\n\n\t    case 'm': case 0x1d6f: case 0x1e3f: case 0x1e41: case 0x1e43:\n\t\t    EMIT2('m') EMIT2(0x1d6f) EMIT2(0x1e3f)\n\t\t    EMIT2(0x1e41) EMIT2(0x1e43)\n\t\t    return OK;\n\n\t    case 'n': case n_virguilla: case 0x144: case 0x146: case 0x148:\n\t    case 0x149: case 0x1f9: case 0x1d70: case 0x1d87: case 0x1e45:\n\t    case 0x1e47: case 0x1e49: case 0x1e4b: case 0xa7a5:\n\t\t    EMIT2('n') EMIT2(n_virguilla)\n\t\t    EMIT2(0x144) EMIT2(0x146) EMIT2(0x148)\n\t\t    EMIT2(0x149) EMIT2(0x1f9) EMIT2(0x1d70)\n\t\t    EMIT2(0x1d87) EMIT2(0x1e45) EMIT2(0x1e47)\n\t\t    EMIT2(0x1e49) EMIT2(0x1e4b) EMIT2(0xa7a5)\n\t\t    return OK;\n\n\t    case 'o': case o_grave: case o_acute: case o_circumflex:\n\t    case o_virguilla: case o_diaeresis: case o_slash:\n\t    case 0x14d: case 0x14f: case 0x151: case 0x1a1:\n\t    case 0x1d2: case 0x1eb: case 0x1ed: case 0x1ff:\n\t    case 0x20d: case 0x20f: case 0x22b: case 0x22d:\n\t    case 0x22f: case 0x231: case 0x275: case 0x1e4d:\n\t    case 0x1e4f: case 0x1e51: case 0x1e53: case 0x1ecd:\n\t    case 0x1ecf: case 0x1ed1: case 0x1ed3: case 0x1ed5:\n\t    case 0x1ed7: case 0x1ed9: case 0x1edb: case 0x1edd:\n\t    case 0x1edf: case 0x1ee1: case 0x1ee3:\n\t\t    EMIT2('o') EMIT2(o_grave) EMIT2(o_acute)\n\t\t    EMIT2(o_circumflex) EMIT2(o_virguilla)\n\t\t    EMIT2(o_diaeresis) EMIT2(o_slash)\n\t\t    EMIT2(0x14d) EMIT2(0x14f) EMIT2(0x151)\n\t\t    EMIT2(0x1a1) EMIT2(0x1d2) EMIT2(0x1eb)\n\t\t    EMIT2(0x1ed) EMIT2(0x1ff) EMIT2(0x20d)\n\t\t    EMIT2(0x20f) EMIT2(0x22b) EMIT2(0x22d)\n\t\t    EMIT2(0x22f) EMIT2(0x231) EMIT2(0x275)\n\t\t    EMIT2(0x1e4d) EMIT2(0x1e4f) EMIT2(0x1e51)\n\t\t    EMIT2(0x1e53) EMIT2(0x1ecd) EMIT2(0x1ecf)\n\t\t    EMIT2(0x1ed1) EMIT2(0x1ed3) EMIT2(0x1ed5)\n\t\t    EMIT2(0x1ed7) EMIT2(0x1ed9) EMIT2(0x1edb)\n\t\t    EMIT2(0x1edd) EMIT2(0x1edf) EMIT2(0x1ee1)\n\t\t    EMIT2(0x1ee3)\n\t\t    return OK;\n\n\t    case 'p': case 0x1a5: case 0x1d71: case 0x1d7d: case 0x1d88:\n\t    case 0x1e55: case 0x1e57:\n\t\t    EMIT2('p') EMIT2(0x1a5) EMIT2(0x1d71) EMIT2(0x1d7d)\n\t\t    EMIT2(0x1d88) EMIT2(0x1e55) EMIT2(0x1e57)\n\t\t    return OK;\n\n\t    case 'q': case 0x24b: case 0x2a0:\n\t\t    EMIT2('q') EMIT2(0x24b) EMIT2(0x2a0)\n\t\t    return OK;\n\n\t    case 'r': case 0x155: case 0x157: case 0x159: case 0x211:\n\t    case 0x213: case 0x24d: case 0x27d: case 0x1d72: case 0x1d73:\n\t    case 0x1d89: case 0x1e59: case 0x1e5b: case 0x1e5d: case 0x1e5f:\n\t    case 0xa7a7:\n\t\t    EMIT2('r') EMIT2(0x155) EMIT2(0x157) EMIT2(0x159)\n\t\t    EMIT2(0x211) EMIT2(0x213) EMIT2(0x24d) EMIT2(0x27d)\n\t\t    EMIT2(0x1d72) EMIT2(0x1d73) EMIT2(0x1d89) EMIT2(0x1e59)\n\t\t    EMIT2(0x1e5b) EMIT2(0x1e5d) EMIT2(0x1e5f) EMIT2(0xa7a7)\n\t\t    return OK;\n\n\t    case 's': case 0x15b: case 0x15d: case 0x15f: case 0x161:\n\t    case 0x219: case 0x23f: case 0x1d74: case 0x1d8a: case 0x1e61:\n\t    case 0x1e63: case 0x1e65: case 0x1e67: case 0x1e69: case 0xa7a9:\n\t\t    EMIT2('s') EMIT2(0x15b) EMIT2(0x15d) EMIT2(0x15f)\n\t\t    EMIT2(0x161) EMIT2(0x219) EMIT2(0x23f) EMIT2(0x1d74)\n\t\t    EMIT2(0x1d8a) EMIT2(0x1e61) EMIT2(0x1e63) EMIT2(0x1e65)\n\t\t    EMIT2(0x1e67) EMIT2(0x1e69) EMIT2(0xa7a9)\n\t\t    return OK;\n\n\t    case 't': case 0x163: case 0x165: case 0x167: case 0x1ab:\n\t    case 0x1ad: case 0x21b: case 0x288: case 0x1d75: case 0x1e6b:\n\t    case 0x1e6d: case 0x1e6f: case 0x1e71: case 0x1e97: case 0x2c66:\n\t\t    EMIT2('t') EMIT2(0x163) EMIT2(0x165) EMIT2(0x167)\n\t\t    EMIT2(0x1ab) EMIT2(0x1ad) EMIT2(0x21b) EMIT2(0x288)\n\t\t    EMIT2(0x1d75) EMIT2(0x1e6b) EMIT2(0x1e6d) EMIT2(0x1e6f)\n\t\t    EMIT2(0x1e71) EMIT2(0x1e97) EMIT2(0x2c66)\n\t\t    return OK;\n\n\t    case 'u': case u_grave: case u_acute: case u_circumflex:\n\t    case u_diaeresis: case 0x169: case 0x16b: case 0x16d:\n\t    case 0x16f: case 0x171: case 0x173: case 0x1b0: case 0x1d4:\n\t    case 0x1d6: case 0x1d8: case 0x1da: case 0x1dc: case 0x215:\n\t    case 0x217: case 0x289: case 0x1d7e: case 0x1d99: case 0x1e73:\n\t    case 0x1e75: case 0x1e77: case 0x1e79: case 0x1e7b:\n\t    case 0x1ee5: case 0x1ee7: case 0x1ee9: case 0x1eeb:\n\t    case 0x1eed: case 0x1eef: case 0x1ef1:\n\t\t    EMIT2('u') EMIT2(u_grave) EMIT2(u_acute)\n\t\t    EMIT2(u_circumflex) EMIT2(u_diaeresis)\n\t\t    EMIT2(0x169) EMIT2(0x16b)\n\t\t    EMIT2(0x16d) EMIT2(0x16f) EMIT2(0x171)\n\t\t    EMIT2(0x173) EMIT2(0x1d6) EMIT2(0x1d8)\n\t\t    EMIT2(0x215) EMIT2(0x217) EMIT2(0x1b0)\n\t\t    EMIT2(0x1d4) EMIT2(0x1da) EMIT2(0x1dc)\n\t\t    EMIT2(0x289) EMIT2(0x1e73) EMIT2(0x1d7e)\n\t\t    EMIT2(0x1d99) EMIT2(0x1e75) EMIT2(0x1e77)\n\t\t    EMIT2(0x1e79) EMIT2(0x1e7b) EMIT2(0x1ee5)\n\t\t    EMIT2(0x1ee7) EMIT2(0x1ee9) EMIT2(0x1eeb)\n\t\t    EMIT2(0x1eed) EMIT2(0x1eef) EMIT2(0x1ef1)\n\t\t    return OK;\n\n\t    case 'v': case 0x28b: case 0x1d8c: case 0x1e7d: case 0x1e7f:\n\t\t    EMIT2('v') EMIT2(0x28b) EMIT2(0x1d8c) EMIT2(0x1e7d)\n\t\t    EMIT2(0x1e7f)\n\t\t    return OK;\n\n\t    case 'w': case 0x175: case 0x1e81: case 0x1e83: case 0x1e85:\n\t    case 0x1e87: case 0x1e89: case 0x1e98:\n\t\t    EMIT2('w') EMIT2(0x175) EMIT2(0x1e81) EMIT2(0x1e83)\n\t\t    EMIT2(0x1e85) EMIT2(0x1e87) EMIT2(0x1e89) EMIT2(0x1e98)\n\t\t    return OK;\n\n\t    case 'x': case 0x1e8b: case 0x1e8d:\n\t\t    EMIT2('x') EMIT2(0x1e8b) EMIT2(0x1e8d)\n\t\t    return OK;\n\n\t    case 'y': case y_acute: case y_diaeresis: case 0x177:\n\t    case 0x1b4: case 0x233: case 0x24f: case 0x1e8f:\n\t    case 0x1e99: case 0x1ef3: case 0x1ef5: case 0x1ef7:\n\t    case 0x1ef9:\n\t\t    EMIT2('y') EMIT2(y_acute) EMIT2(y_diaeresis)\n\t\t    EMIT2(0x177) EMIT2(0x1b4) EMIT2(0x233) EMIT2(0x24f)\n\t\t    EMIT2(0x1e8f) EMIT2(0x1e99) EMIT2(0x1ef3)\n\t\t    EMIT2(0x1ef5) EMIT2(0x1ef7) EMIT2(0x1ef9)\n\t\t    return OK;\n\n\t    case 'z': case 0x17a: case 0x17c: case 0x17e: case 0x1b6:\n\t    case 0x1d76: case 0x1d8e: case 0x1e91: case 0x1e93:\n\t    case 0x1e95: case 0x2c6c:\n\t\t    EMIT2('z') EMIT2(0x17a) EMIT2(0x17c) EMIT2(0x17e)\n\t\t    EMIT2(0x1b6) EMIT2(0x1d76) EMIT2(0x1d8e) EMIT2(0x1e91)\n\t\t    EMIT2(0x1e93) EMIT2(0x1e95) EMIT2(0x2c6c)\n\t\t    return OK;\n\n\t    // default: character itself\n\t}\n    }\n\n    EMIT2(c);\n    return OK;\n#undef EMIT2\n#undef EMIT2\n}\n\n/*\n * Code to parse regular expression.\n *\n * We try to reuse parsing functions in regexp.c to\n * minimize surprise and keep the syntax consistent.\n */\n\n/*\n * Parse the lowest level.\n *\n * An atom can be one of a long list of items.  Many atoms match one character\n * in the text.  It is often an ordinary character or a character class.\n * Braces can be used to make a pattern into an atom.  The \"\\z(\\)\" construct\n * is only for syntax highlighting.\n *\n * atom    ::=     ordinary-atom\n *     or  \\( pattern \\)\n *     or  \\%( pattern \\)\n *     or  \\z( pattern \\)\n */\n    static int\nnfa_regatom(void)\n{\n    int\t\tc;\n    int\t\tcharclass;\n    int\t\tequiclass;\n    int\t\tcollclass;\n    int\t\tgot_coll_char;\n    char_u\t*p;\n    char_u\t*endp;\n    char_u\t*old_regparse = regparse;\n    int\t\textra = 0;\n    int\t\temit_range;\n    int\t\tnegated;\n    int\t\tresult;\n    int\t\tstartc = -1;\n    int\t\tsave_prev_at_start = prev_at_start;\n\n    c = getchr();\n    switch (c)\n    {\n\tcase NUL:\n\t    EMSG_RET_FAIL(_(e_nul_found));\n\n\tcase Magic('^'):\n\t    EMIT(NFA_BOL);\n\t    break;\n\n\tcase Magic('$'):\n\t    EMIT(NFA_EOL);\n#if defined(FEAT_SYN_HL) || defined(PROTO)\n\t    had_eol = TRUE;\n#endif\n\t    break;\n\n\tcase Magic('<'):\n\t    EMIT(NFA_BOW);\n\t    break;\n\n\tcase Magic('>'):\n\t    EMIT(NFA_EOW);\n\t    break;\n\n\tcase Magic('_'):\n\t    c = no_Magic(getchr());\n\t    if (c == NUL)\n\t\tEMSG_RET_FAIL(_(e_nul_found));\n\n\t    if (c == '^')\t// \"\\_^\" is start-of-line\n\t    {\n\t\tEMIT(NFA_BOL);\n\t\tbreak;\n\t    }\n\t    if (c == '$')\t// \"\\_$\" is end-of-line\n\t    {\n\t\tEMIT(NFA_EOL);\n#if defined(FEAT_SYN_HL) || defined(PROTO)\n\t\thad_eol = TRUE;\n#endif\n\t\tbreak;\n\t    }\n\n\t    extra = NFA_ADD_NL;\n\n\t    // \"\\_[\" is collection plus newline\n\t    if (c == '[')\n\t\tgoto collection;\n\n\t// \"\\_x\" is character class plus newline\n\t// FALLTHROUGH\n\n\t/*\n\t * Character classes.\n\t */\n\tcase Magic('.'):\n\tcase Magic('i'):\n\tcase Magic('I'):\n\tcase Magic('k'):\n\tcase Magic('K'):\n\tcase Magic('f'):\n\tcase Magic('F'):\n\tcase Magic('p'):\n\tcase Magic('P'):\n\tcase Magic('s'):\n\tcase Magic('S'):\n\tcase Magic('d'):\n\tcase Magic('D'):\n\tcase Magic('x'):\n\tcase Magic('X'):\n\tcase Magic('o'):\n\tcase Magic('O'):\n\tcase Magic('w'):\n\tcase Magic('W'):\n\tcase Magic('h'):\n\tcase Magic('H'):\n\tcase Magic('a'):\n\tcase Magic('A'):\n\tcase Magic('l'):\n\tcase Magic('L'):\n\tcase Magic('u'):\n\tcase Magic('U'):\n\t    p = vim_strchr(classchars, no_Magic(c));\n\t    if (p == NULL)\n\t    {\n\t\tif (extra == NFA_ADD_NL)\n\t\t{\n\t\t    semsg(_(e_ill_char_class), c);\n\t\t    rc_did_emsg = TRUE;\n\t\t    return FAIL;\n\t\t}\n\t\tsiemsg(\"INTERNAL: Unknown character class char: %d\", c);\n\t\treturn FAIL;\n\t    }\n\n\t    // When '.' is followed by a composing char ignore the dot, so that\n\t    // the composing char is matched here.\n\t    if (enc_utf8 && c == Magic('.') && utf_iscomposing(peekchr()))\n\t    {\n\t\told_regparse = regparse;\n\t\tc = getchr();\n\t\tgoto nfa_do_multibyte;\n\t    }\n\t    EMIT(nfa_classcodes[p - classchars]);\n\t    if (extra == NFA_ADD_NL)\n\t    {\n\t\tEMIT(NFA_NEWL);\n\t\tEMIT(NFA_OR);\n\t\tregflags |= RF_HASNL;\n\t    }\n\t    break;\n\n\tcase Magic('n'):\n\t    if (reg_string)\n\t\t// In a string \"\\n\" matches a newline character.\n\t\tEMIT(NL);\n\t    else\n\t    {\n\t\t// In buffer text \"\\n\" matches the end of a line.\n\t\tEMIT(NFA_NEWL);\n\t\tregflags |= RF_HASNL;\n\t    }\n\t    break;\n\n\tcase Magic('('):\n\t    if (nfa_reg(REG_PAREN) == FAIL)\n\t\treturn FAIL;\t    // cascaded error\n\t    break;\n\n\tcase Magic('|'):\n\tcase Magic('&'):\n\tcase Magic(')'):\n\t    semsg(_(e_misplaced), no_Magic(c));\n\t    return FAIL;\n\n\tcase Magic('='):\n\tcase Magic('?'):\n\tcase Magic('+'):\n\tcase Magic('@'):\n\tcase Magic('*'):\n\tcase Magic('{'):\n\t    // these should follow an atom, not form an atom\n\t    semsg(_(e_misplaced), no_Magic(c));\n\t    return FAIL;\n\n\tcase Magic('~'):\n\t    {\n\t\tchar_u\t    *lp;\n\n\t\t// Previous substitute pattern.\n\t\t// Generated as \"\\%(pattern\\)\".\n\t\tif (reg_prev_sub == NULL)\n\t\t{\n\t\t    emsg(_(e_no_previous_substitute_regular_expression));\n\t\t    return FAIL;\n\t\t}\n\t\tfor (lp = reg_prev_sub; *lp != NUL; MB_CPTR_ADV(lp))\n\t\t{\n\t\t    EMIT(PTR2CHAR(lp));\n\t\t    if (lp != reg_prev_sub)\n\t\t\tEMIT(NFA_CONCAT);\n\t\t}\n\t\tEMIT(NFA_NOPEN);\n\t\tbreak;\n\t    }\n\n\tcase Magic('1'):\n\tcase Magic('2'):\n\tcase Magic('3'):\n\tcase Magic('4'):\n\tcase Magic('5'):\n\tcase Magic('6'):\n\tcase Magic('7'):\n\tcase Magic('8'):\n\tcase Magic('9'):\n\t    {\n\t\tint refnum = no_Magic(c) - '1';\n\n\t\tif (!seen_endbrace(refnum + 1))\n\t\t    return FAIL;\n\t\tEMIT(NFA_BACKREF1 + refnum);\n\t\trex.nfa_has_backref = TRUE;\n\t    }\n\t    break;\n\n\tcase Magic('z'):\n\t    c = no_Magic(getchr());\n\t    switch (c)\n\t    {\n\t\tcase 's':\n\t\t    EMIT(NFA_ZSTART);\n\t\t    if (re_mult_next(\"\\\\zs\") == FAIL)\n\t\t\treturn FAIL;\n\t\t    break;\n\t\tcase 'e':\n\t\t    EMIT(NFA_ZEND);\n\t\t    rex.nfa_has_zend = TRUE;\n\t\t    if (re_mult_next(\"\\\\ze\") == FAIL)\n\t\t\treturn FAIL;\n\t\t    break;\n#ifdef FEAT_SYN_HL\n\t\tcase '1':\n\t\tcase '2':\n\t\tcase '3':\n\t\tcase '4':\n\t\tcase '5':\n\t\tcase '6':\n\t\tcase '7':\n\t\tcase '8':\n\t\tcase '9':\n\t\t    // \\z1...\\z9\n\t\t    if ((reg_do_extmatch & REX_USE) == 0)\n\t\t\tEMSG_RET_FAIL(_(e_z1_not_allowed));\n\t\t    EMIT(NFA_ZREF1 + (no_Magic(c) - '1'));\n\t\t    // No need to set rex.nfa_has_backref, the sub-matches don't\n\t\t    // change when \\z1 .. \\z9 matches or not.\n\t\t    re_has_z = REX_USE;\n\t\t    break;\n\t\tcase '(':\n\t\t    // \\z(\n\t\t    if ((reg_do_extmatch & REX_SET) == 0)\n\t\t\tEMSG_RET_FAIL(_(e_z_not_allowed));\n\t\t    if (nfa_reg(REG_ZPAREN) == FAIL)\n\t\t\treturn FAIL;\t    // cascaded error\n\t\t    re_has_z = REX_SET;\n\t\t    break;\n#endif\n\t\tdefault:\n\t\t    semsg(_(\"E867: (NFA) Unknown operator '\\\\z%c'\"),\n\t\t\t\t\t\t\t\t no_Magic(c));\n\t\t    return FAIL;\n\t    }\n\t    break;\n\n\tcase Magic('%'):\n\t    c = no_Magic(getchr());\n\t    switch (c)\n\t    {\n\t\t// () without a back reference\n\t\tcase '(':\n\t\t    if (nfa_reg(REG_NPAREN) == FAIL)\n\t\t\treturn FAIL;\n\t\t    EMIT(NFA_NOPEN);\n\t\t    break;\n\n\t\tcase 'd':   // %d123 decimal\n\t\tcase 'o':   // %o123 octal\n\t\tcase 'x':   // %xab hex 2\n\t\tcase 'u':   // %uabcd hex 4\n\t\tcase 'U':   // %U1234abcd hex 8\n\t\t    {\n\t\t\tlong nr;\n\n\t\t\tswitch (c)\n\t\t\t{\n\t\t\t    case 'd': nr = getdecchrs(); break;\n\t\t\t    case 'o': nr = getoctchrs(); break;\n\t\t\t    case 'x': nr = gethexchrs(2); break;\n\t\t\t    case 'u': nr = gethexchrs(4); break;\n\t\t\t    case 'U': nr = gethexchrs(8); break;\n\t\t\t    default:  nr = -1; break;\n\t\t\t}\n\n\t\t\tif (nr < 0 || nr > INT_MAX)\n\t\t\t    EMSG2_RET_FAIL(\n\t\t\t       _(\"E678: Invalid character after %s%%[dxouU]\"),\n\t\t\t\t    reg_magic == MAGIC_ALL);\n\t\t\t// A NUL is stored in the text as NL\n\t\t\t// TODO: what if a composing character follows?\n\t\t\tEMIT(nr == 0 ? 0x0a : nr);\n\t\t    }\n\t\t    break;\n\n\t\t// Catch \\%^ and \\%$ regardless of where they appear in the\n\t\t// pattern -- regardless of whether or not it makes sense.\n\t\tcase '^':\n\t\t    EMIT(NFA_BOF);\n\t\t    break;\n\n\t\tcase '$':\n\t\t    EMIT(NFA_EOF);\n\t\t    break;\n\n\t\tcase '#':\n\t\t    EMIT(NFA_CURSOR);\n\t\t    break;\n\n\t\tcase 'V':\n\t\t    EMIT(NFA_VISUAL);\n\t\t    break;\n\n\t\tcase 'C':\n\t\t    EMIT(NFA_ANY_COMPOSING);\n\t\t    break;\n\n\t\tcase '[':\n\t\t    {\n\t\t\tint\t    n;\n\n\t\t\t// \\%[abc]\n\t\t\tfor (n = 0; (c = peekchr()) != ']'; ++n)\n\t\t\t{\n\t\t\t    if (c == NUL)\n\t\t\t\tEMSG2_RET_FAIL(_(e_missing_sb),\n\t\t\t\t\t\t      reg_magic == MAGIC_ALL);\n\t\t\t    // recursive call!\n\t\t\t    if (nfa_regatom() == FAIL)\n\t\t\t\treturn FAIL;\n\t\t\t}\n\t\t\tgetchr();  // get the ]\n\t\t\tif (n == 0)\n\t\t\t    EMSG2_RET_FAIL(_(e_empty_sb),\n\t\t\t\t\t\t      reg_magic == MAGIC_ALL);\n\t\t\tEMIT(NFA_OPT_CHARS);\n\t\t\tEMIT(n);\n\n\t\t\t// Emit as \"\\%(\\%[abc]\\)\" to be able to handle\n\t\t\t// \"\\%[abc]*\" which would cause the empty string to be\n\t\t\t// matched an unlimited number of times. NFA_NOPEN is\n\t\t\t// added only once at a position, while NFA_SPLIT is\n\t\t\t// added multiple times.  This is more efficient than\n\t\t\t// not allowing NFA_SPLIT multiple times, it is used\n\t\t\t// a lot.\n\t\t\tEMIT(NFA_NOPEN);\n\t\t\tbreak;\n\t\t    }\n\n\t\tdefault:\n\t\t    {\n\t\t\tlong_u\tn = 0;\n\t\t\tint\tcmp = c;\n\t\t\tint\tcur = FALSE;\n\n\t\t\tif (c == '<' || c == '>')\n\t\t\t    c = getchr();\n\t\t\tif (no_Magic(c) == '.')\n\t\t\t{\n\t\t\t    cur = TRUE;\n\t\t\t    c = getchr();\n\t\t\t}\n\t\t\twhile (VIM_ISDIGIT(c))\n\t\t\t{\n\t\t\t    long_u tmp;\n\n\t\t\t    if (cur)\n\t\t\t\tsemsg(_(e_regexp_number_after_dot_pos_search),\n\t\t\t\t\t\t\t\t no_Magic(c));\n\t\t\t    tmp = n * 10 + (c - '0');\n\n\t\t\t    if (tmp < n)\n\t\t\t    {\n\t\t\t\t// overflow.\n\t\t\t\temsg(_(e_value_too_large));\n\t\t\t\treturn FAIL;\n\t\t\t    }\n\t\t\t    n = tmp;\n\t\t\t    c = getchr();\n\t\t\t}\n\t\t\tif (c == 'l' || c == 'c' || c == 'v')\n\t\t\t{\n\t\t\t    long_u limit = INT_MAX;\n\n\t\t\t    if (c == 'l')\n\t\t\t    {\n\t\t\t\tif (cur)\n\t\t\t\t    n = curwin->w_cursor.lnum;\n\t\t\t\t// \\%{n}l  \\%{n}<l  \\%{n}>l\n\t\t\t\tEMIT(cmp == '<' ? NFA_LNUM_LT :\n\t\t\t\t     cmp == '>' ? NFA_LNUM_GT : NFA_LNUM);\n\t\t\t\tif (save_prev_at_start)\n\t\t\t\t    at_start = TRUE;\n\t\t\t    }\n\t\t\t    else if (c == 'c')\n\t\t\t    {\n\t\t\t\tif (cur)\n\t\t\t\t{\n\t\t\t\t    n = curwin->w_cursor.col;\n\t\t\t\t    n++;\n\t\t\t\t}\n\t\t\t\t// \\%{n}c  \\%{n}<c  \\%{n}>c\n\t\t\t\tEMIT(cmp == '<' ? NFA_COL_LT :\n\t\t\t\t     cmp == '>' ? NFA_COL_GT : NFA_COL);\n\t\t\t    }\n\t\t\t    else\n\t\t\t    {\n\t\t\t\tif (cur)\n\t\t\t\t{\n\t\t\t\t    colnr_T vcol = 0;\n\n\t\t\t\t    getvvcol(curwin, &curwin->w_cursor,\n\t\t\t\t\t\t\t    NULL, NULL, &vcol);\n\t\t\t\t    n = ++vcol;\n\t\t\t\t}\n\t\t\t\t// \\%{n}v  \\%{n}<v  \\%{n}>v\n\t\t\t\tEMIT(cmp == '<' ? NFA_VCOL_LT :\n\t\t\t\t     cmp == '>' ? NFA_VCOL_GT : NFA_VCOL);\n\t\t\t\tlimit = INT_MAX / MB_MAXBYTES;\n\t\t\t    }\n\t\t\t    if (n >= limit)\n\t\t\t    {\n\t\t\t\temsg(_(e_value_too_large));\n\t\t\t\treturn FAIL;\n\t\t\t    }\n\t\t\t    EMIT((int)n);\n\t\t\t    break;\n\t\t\t}\n\t\t\telse if (c == '\\'' && n == 0)\n\t\t\t{\n\t\t\t    // \\%'m  \\%<'m  \\%>'m\n\t\t\t    EMIT(cmp == '<' ? NFA_MARK_LT :\n\t\t\t\t cmp == '>' ? NFA_MARK_GT : NFA_MARK);\n\t\t\t    EMIT(getchr());\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t    semsg(_(\"E867: (NFA) Unknown operator '\\\\%%%c'\"),\n\t\t\t\t\t\t\t\t no_Magic(c));\n\t\t    return FAIL;\n\t    }\n\t    break;\n\n\tcase Magic('['):\ncollection:\n\t    /*\n\t     * [abc]  uses NFA_START_COLL - NFA_END_COLL\n\t     * [^abc] uses NFA_START_NEG_COLL - NFA_END_NEG_COLL\n\t     * Each character is produced as a regular state, using\n\t     * NFA_CONCAT to bind them together.\n\t     * Besides normal characters there can be:\n\t     * - character classes  NFA_CLASS_*\n\t     * - ranges, two characters followed by NFA_RANGE.\n\t     */\n\n\t    p = regparse;\n\t    endp = skip_anyof(p);\n\t    if (*endp == ']')\n\t    {\n\t\t/*\n\t\t * Try to reverse engineer character classes. For example,\n\t\t * recognize that [0-9] stands for \\d and [A-Za-z_] for \\h,\n\t\t * and perform the necessary substitutions in the NFA.\n\t\t */\n\t\tresult = nfa_recognize_char_class(regparse, endp,\n\t\t\t\t\t\t\t extra == NFA_ADD_NL);\n\t\tif (result != FAIL)\n\t\t{\n\t\t    if (result >= NFA_FIRST_NL && result <= NFA_LAST_NL)\n\t\t    {\n\t\t\tEMIT(result - NFA_ADD_NL);\n\t\t\tEMIT(NFA_NEWL);\n\t\t\tEMIT(NFA_OR);\n\t\t    }\n\t\t    else\n\t\t\tEMIT(result);\n\t\t    regparse = endp;\n\t\t    MB_PTR_ADV(regparse);\n\t\t    return OK;\n\t\t}\n\t\t/*\n\t\t * Failed to recognize a character class. Use the simple\n\t\t * version that turns [abc] into 'a' OR 'b' OR 'c'\n\t\t */\n\t\tstartc = -1;\n\t\tnegated = FALSE;\n\t\tif (*regparse == '^')\t\t\t// negated range\n\t\t{\n\t\t    negated = TRUE;\n\t\t    MB_PTR_ADV(regparse);\n\t\t    EMIT(NFA_START_NEG_COLL);\n\t\t}\n\t\telse\n\t\t    EMIT(NFA_START_COLL);\n\t\tif (*regparse == '-')\n\t\t{\n\t\t    startc = '-';\n\t\t    EMIT(startc);\n\t\t    EMIT(NFA_CONCAT);\n\t\t    MB_PTR_ADV(regparse);\n\t\t}\n\t\t// Emit the OR branches for each character in the []\n\t\temit_range = FALSE;\n\t\twhile (regparse < endp)\n\t\t{\n\t\t    int\t    oldstartc = startc;\n\n\t\t    startc = -1;\n\t\t    got_coll_char = FALSE;\n\t\t    if (*regparse == '[')\n\t\t    {\n\t\t\t// Check for [: :], [= =], [. .]\n\t\t\tequiclass = collclass = 0;\n\t\t\tcharclass = get_char_class(&regparse);\n\t\t\tif (charclass == CLASS_NONE)\n\t\t\t{\n\t\t\t    equiclass = get_equi_class(&regparse);\n\t\t\t    if (equiclass == 0)\n\t\t\t\tcollclass = get_coll_element(&regparse);\n\t\t\t}\n\n\t\t\t// Character class like [:alpha:]\n\t\t\tif (charclass != CLASS_NONE)\n\t\t\t{\n\t\t\t    switch (charclass)\n\t\t\t    {\n\t\t\t\tcase CLASS_ALNUM:\n\t\t\t\t    EMIT(NFA_CLASS_ALNUM);\n\t\t\t\t    break;\n\t\t\t\tcase CLASS_ALPHA:\n\t\t\t\t    EMIT(NFA_CLASS_ALPHA);\n\t\t\t\t    break;\n\t\t\t\tcase CLASS_BLANK:\n\t\t\t\t    EMIT(NFA_CLASS_BLANK);\n\t\t\t\t    break;\n\t\t\t\tcase CLASS_CNTRL:\n\t\t\t\t    EMIT(NFA_CLASS_CNTRL);\n\t\t\t\t    break;\n\t\t\t\tcase CLASS_DIGIT:\n\t\t\t\t    EMIT(NFA_CLASS_DIGIT);\n\t\t\t\t    break;\n\t\t\t\tcase CLASS_GRAPH:\n\t\t\t\t    EMIT(NFA_CLASS_GRAPH);\n\t\t\t\t    break;\n\t\t\t\tcase CLASS_LOWER:\n\t\t\t\t    wants_nfa = TRUE;\n\t\t\t\t    EMIT(NFA_CLASS_LOWER);\n\t\t\t\t    break;\n\t\t\t\tcase CLASS_PRINT:\n\t\t\t\t    EMIT(NFA_CLASS_PRINT);\n\t\t\t\t    break;\n\t\t\t\tcase CLASS_PUNCT:\n\t\t\t\t    EMIT(NFA_CLASS_PUNCT);\n\t\t\t\t    break;\n\t\t\t\tcase CLASS_SPACE:\n\t\t\t\t    EMIT(NFA_CLASS_SPACE);\n\t\t\t\t    break;\n\t\t\t\tcase CLASS_UPPER:\n\t\t\t\t    wants_nfa = TRUE;\n\t\t\t\t    EMIT(NFA_CLASS_UPPER);\n\t\t\t\t    break;\n\t\t\t\tcase CLASS_XDIGIT:\n\t\t\t\t    EMIT(NFA_CLASS_XDIGIT);\n\t\t\t\t    break;\n\t\t\t\tcase CLASS_TAB:\n\t\t\t\t    EMIT(NFA_CLASS_TAB);\n\t\t\t\t    break;\n\t\t\t\tcase CLASS_RETURN:\n\t\t\t\t    EMIT(NFA_CLASS_RETURN);\n\t\t\t\t    break;\n\t\t\t\tcase CLASS_BACKSPACE:\n\t\t\t\t    EMIT(NFA_CLASS_BACKSPACE);\n\t\t\t\t    break;\n\t\t\t\tcase CLASS_ESCAPE:\n\t\t\t\t    EMIT(NFA_CLASS_ESCAPE);\n\t\t\t\t    break;\n\t\t\t\tcase CLASS_IDENT:\n\t\t\t\t    EMIT(NFA_CLASS_IDENT);\n\t\t\t\t    break;\n\t\t\t\tcase CLASS_KEYWORD:\n\t\t\t\t    EMIT(NFA_CLASS_KEYWORD);\n\t\t\t\t    break;\n\t\t\t\tcase CLASS_FNAME:\n\t\t\t\t    EMIT(NFA_CLASS_FNAME);\n\t\t\t\t    break;\n\t\t\t    }\n\t\t\t    EMIT(NFA_CONCAT);\n\t\t\t    continue;\n\t\t\t}\n\t\t\t// Try equivalence class [=a=] and the like\n\t\t\tif (equiclass != 0)\n\t\t\t{\n\t\t\t    result = nfa_emit_equi_class(equiclass);\n\t\t\t    if (result == FAIL)\n\t\t\t    {\n\t\t\t\t// should never happen\n\t\t\t\tEMSG_RET_FAIL(_(\"E868: Error building NFA with equivalence class!\"));\n\t\t\t    }\n\t\t\t    continue;\n\t\t\t}\n\t\t\t// Try collating class like [. .]\n\t\t\tif (collclass != 0)\n\t\t\t{\n\t\t\t    startc = collclass;\t // allow [.a.]-x as a range\n\t\t\t    // Will emit the proper atom at the end of the\n\t\t\t    // while loop.\n\t\t\t}\n\t\t    }\n\t\t    // Try a range like 'a-x' or '\\t-z'. Also allows '-' as a\n\t\t    // start character.\n\t\t    if (*regparse == '-' && oldstartc != -1)\n\t\t    {\n\t\t\temit_range = TRUE;\n\t\t\tstartc = oldstartc;\n\t\t\tMB_PTR_ADV(regparse);\n\t\t\tcontinue;\t    // reading the end of the range\n\t\t    }\n\n\t\t    // Now handle simple and escaped characters.\n\t\t    // Only \"\\]\", \"\\^\", \"\\]\" and \"\\\\\" are special in Vi.  Vim\n\t\t    // accepts \"\\t\", \"\\e\", etc., but only when the 'l' flag in\n\t\t    // 'cpoptions' is not included.\n\t\t    // Posix doesn't recognize backslash at all.\n\t\t    if (*regparse == '\\\\'\n\t\t\t    && !reg_cpo_bsl\n\t\t\t    && regparse + 1 <= endp\n\t\t\t    && (vim_strchr(REGEXP_INRANGE, regparse[1]) != NULL\n\t\t\t\t|| (!reg_cpo_lit\n\t\t\t\t    && vim_strchr(REGEXP_ABBR, regparse[1])\n\t\t\t\t\t\t\t\t      != NULL)\n\t\t\t    )\n\t\t\t)\n\t\t    {\n\t\t\tMB_PTR_ADV(regparse);\n\n\t\t\tif (*regparse == 'n')\n\t\t\t    startc = (reg_string || emit_range\n\t\t\t\t\t|| regparse[1] == '-') ? NL : NFA_NEWL;\n\t\t\telse if (*regparse == 'd'\n\t\t\t\t    || *regparse == 'o'\n\t\t\t\t    || *regparse == 'x'\n\t\t\t\t    || *regparse == 'u'\n\t\t\t\t    || *regparse == 'U'\n\t\t\t\t)\n\t\t\t    {\n\t\t\t\t// TODO(RE) This needs more testing\n\t\t\t\tstartc = coll_get_char();\n\t\t\t\tgot_coll_char = TRUE;\n\t\t\t\tMB_PTR_BACK(old_regparse, regparse);\n\t\t\t    }\n\t\t\t    else\n\t\t\t    {\n\t\t\t\t// \\r,\\t,\\e,\\b\n\t\t\t\tstartc = backslash_trans(*regparse);\n\t\t\t    }\n\t\t    }\n\n\t\t    // Normal printable char\n\t\t    if (startc == -1)\n\t\t\tstartc = PTR2CHAR(regparse);\n\n\t\t    // Previous char was '-', so this char is end of range.\n\t\t    if (emit_range)\n\t\t    {\n\t\t\tint\tendc = startc;\n\n\t\t\tstartc = oldstartc;\n\t\t\tif (startc > endc)\n\t\t\t    EMSG_RET_FAIL(_(e_reverse_range));\n\n\t\t\tif (endc > startc + 2)\n\t\t\t{\n\t\t\t    // Emit a range instead of the sequence of\n\t\t\t    // individual characters.\n\t\t\t    if (startc == 0)\n\t\t\t\t// \\x00 is translated to \\x0a, start at \\x01.\n\t\t\t\tEMIT(1);\n\t\t\t    else\n\t\t\t\t--post_ptr; // remove NFA_CONCAT\n\t\t\t    EMIT(endc);\n\t\t\t    EMIT(NFA_RANGE);\n\t\t\t    EMIT(NFA_CONCAT);\n\t\t\t}\n\t\t\telse if (has_mbyte && ((*mb_char2len)(startc) > 1\n\t\t\t\t    || (*mb_char2len)(endc) > 1))\n\t\t\t{\n\t\t\t    // Emit the characters in the range.\n\t\t\t    // \"startc\" was already emitted, so skip it.\n\t\t\t    //\n\t\t\t    for (c = startc + 1; c <= endc; c++)\n\t\t\t    {\n\t\t\t\tEMIT(c);\n\t\t\t\tEMIT(NFA_CONCAT);\n\t\t\t    }\n\t\t\t}\n\t\t\telse\n\t\t\t{\n#ifdef EBCDIC\n\t\t\t    int alpha_only = FALSE;\n\n\t\t\t    // for alphabetical range skip the gaps\n\t\t\t    // 'i'-'j', 'r'-'s', 'I'-'J' and 'R'-'S'.\n\t\t\t    if (isalpha(startc) && isalpha(endc))\n\t\t\t\talpha_only = TRUE;\n#endif\n\t\t\t    // Emit the range. \"startc\" was already emitted, so\n\t\t\t    // skip it.\n\t\t\t    for (c = startc + 1; c <= endc; c++)\n#ifdef EBCDIC\n\t\t\t\tif (!alpha_only || isalpha(startc))\n#endif\n\t\t\t\t{\n\t\t\t\t    EMIT(c);\n\t\t\t\t    EMIT(NFA_CONCAT);\n\t\t\t\t}\n\t\t\t}\n\t\t\temit_range = FALSE;\n\t\t\tstartc = -1;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// This char (startc) is not part of a range. Just\n\t\t\t// emit it.\n\t\t\t// Normally, simply emit startc. But if we get char\n\t\t\t// code=0 from a collating char, then replace it with\n\t\t\t// 0x0a.\n\t\t\t// This is needed to completely mimic the behaviour of\n\t\t\t// the backtracking engine.\n\t\t\tif (startc == NFA_NEWL)\n\t\t\t{\n\t\t\t    // Line break can't be matched as part of the\n\t\t\t    // collection, add an OR below. But not for negated\n\t\t\t    // range.\n\t\t\t    if (!negated)\n\t\t\t\textra = NFA_ADD_NL;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    if (got_coll_char == TRUE && startc == 0)\n\t\t\t\tEMIT(0x0a);\n\t\t\t    else\n\t\t\t\tEMIT(startc);\n\t\t\t    EMIT(NFA_CONCAT);\n\t\t\t}\n\t\t    }\n\n\t\t    MB_PTR_ADV(regparse);\n\t\t} // while (p < endp)\n\n\t\tMB_PTR_BACK(old_regparse, regparse);\n\t\tif (*regparse == '-')\t    // if last, '-' is just a char\n\t\t{\n\t\t    EMIT('-');\n\t\t    EMIT(NFA_CONCAT);\n\t\t}\n\n\t\t// skip the trailing ]\n\t\tregparse = endp;\n\t\tMB_PTR_ADV(regparse);\n\n\t\t// Mark end of the collection.\n\t\tif (negated == TRUE)\n\t\t    EMIT(NFA_END_NEG_COLL);\n\t\telse\n\t\t    EMIT(NFA_END_COLL);\n\n\t\t// \\_[] also matches \\n but it's not negated\n\t\tif (extra == NFA_ADD_NL)\n\t\t{\n\t\t    EMIT(reg_string ? NL : NFA_NEWL);\n\t\t    EMIT(NFA_OR);\n\t\t}\n\n\t\treturn OK;\n\t    } // if exists closing ]\n\n\t    if (reg_strict)\n\t\tEMSG_RET_FAIL(_(e_missingbracket));\n\t    // FALLTHROUGH\n\n\tdefault:\n\t    {\n\t\tint\tplen;\n\nnfa_do_multibyte:\n\t\t// plen is length of current char with composing chars\n\t\tif (enc_utf8 && ((*mb_char2len)(c)\n\t\t\t    != (plen = utfc_ptr2len(old_regparse))\n\t\t\t\t\t\t       || utf_iscomposing(c)))\n\t\t{\n\t\t    int i = 0;\n\n\t\t    // A base character plus composing characters, or just one\n\t\t    // or more composing characters.\n\t\t    // This requires creating a separate atom as if enclosing\n\t\t    // the characters in (), where NFA_COMPOSING is the ( and\n\t\t    // NFA_END_COMPOSING is the ). Note that right now we are\n\t\t    // building the postfix form, not the NFA itself;\n\t\t    // a composing char could be: a, b, c, NFA_COMPOSING\n\t\t    // where 'b' and 'c' are chars with codes > 256.\n\t\t    for (;;)\n\t\t    {\n\t\t\tEMIT(c);\n\t\t\tif (i > 0)\n\t\t\t    EMIT(NFA_CONCAT);\n\t\t\tif ((i += utf_char2len(c)) >= plen)\n\t\t\t    break;\n\t\t\tc = utf_ptr2char(old_regparse + i);\n\t\t    }\n\t\t    EMIT(NFA_COMPOSING);\n\t\t    regparse = old_regparse + plen;\n\t\t}\n\t\telse\n\t\t{\n\t\t    c = no_Magic(c);\n\t\t    EMIT(c);\n\t\t}\n\t\treturn OK;\n\t    }\n    }\n\n    return OK;\n}\n\n/*\n * Parse something followed by possible [*+=].\n *\n * A piece is an atom, possibly followed by a multi, an indication of how many\n * times the atom can be matched.  Example: \"a*\" matches any sequence of \"a\"\n * characters: \"\", \"a\", \"aa\", etc.\n *\n * piece   ::=\t    atom\n *\tor  atom  multi\n */\n    static int\nnfa_regpiece(void)\n{\n    int\t\ti;\n    int\t\top;\n    int\t\tret;\n    long\tminval, maxval;\n    int\t\tgreedy = TRUE;      // Braces are prefixed with '-' ?\n    parse_state_T old_state;\n    parse_state_T new_state;\n    long\tc2;\n    int\t\told_post_pos;\n    int\t\tmy_post_start;\n    int\t\tquest;\n\n    // Save the current parse state, so that we can use it if <atom>{m,n} is\n    // next.\n    save_parse_state(&old_state);\n\n    // store current pos in the postfix form, for \\{m,n} involving 0s\n    my_post_start = (int)(post_ptr - post_start);\n\n    ret = nfa_regatom();\n    if (ret == FAIL)\n\treturn FAIL;\t    // cascaded error\n\n    op = peekchr();\n    if (re_multi_type(op) == NOT_MULTI)\n\treturn OK;\n\n    skipchr();\n    switch (op)\n    {\n\tcase Magic('*'):\n\t    EMIT(NFA_STAR);\n\t    break;\n\n\tcase Magic('+'):\n\t    /*\n\t     * Trick: Normally, (a*)\\+ would match the whole input \"aaa\".  The\n\t     * first and only submatch would be \"aaa\". But the backtracking\n\t     * engine interprets the plus as \"try matching one more time\", and\n\t     * a* matches a second time at the end of the input, the empty\n\t     * string.\n\t     * The submatch will be the empty string.\n\t     *\n\t     * In order to be consistent with the old engine, we replace\n\t     * <atom>+ with <atom><atom>*\n\t     */\n\t    restore_parse_state(&old_state);\n\t    curchr = -1;\n\t    if (nfa_regatom() == FAIL)\n\t\treturn FAIL;\n\t    EMIT(NFA_STAR);\n\t    EMIT(NFA_CONCAT);\n\t    skipchr();\t\t// skip the \\+\n\t    break;\n\n\tcase Magic('@'):\n\t    c2 = getdecchrs();\n\t    op = no_Magic(getchr());\n\t    i = 0;\n\t    switch(op)\n\t    {\n\t\tcase '=':\n\t\t    // \\@=\n\t\t    i = NFA_PREV_ATOM_NO_WIDTH;\n\t\t    break;\n\t\tcase '!':\n\t\t    // \\@!\n\t\t    i = NFA_PREV_ATOM_NO_WIDTH_NEG;\n\t\t    break;\n\t\tcase '<':\n\t\t    op = no_Magic(getchr());\n\t\t    if (op == '=')\n\t\t\t// \\@<=\n\t\t\ti = NFA_PREV_ATOM_JUST_BEFORE;\n\t\t    else if (op == '!')\n\t\t\t// \\@<!\n\t\t\ti = NFA_PREV_ATOM_JUST_BEFORE_NEG;\n\t\t    break;\n\t\tcase '>':\n\t\t    // \\@>\n\t\t    i = NFA_PREV_ATOM_LIKE_PATTERN;\n\t\t    break;\n\t    }\n\t    if (i == 0)\n\t    {\n\t\tsemsg(_(\"E869: (NFA) Unknown operator '\\\\@%c'\"), op);\n\t\treturn FAIL;\n\t    }\n\t    EMIT(i);\n\t    if (i == NFA_PREV_ATOM_JUST_BEFORE\n\t\t\t\t\t|| i == NFA_PREV_ATOM_JUST_BEFORE_NEG)\n\t\tEMIT(c2);\n\t    break;\n\n\tcase Magic('?'):\n\tcase Magic('='):\n\t    EMIT(NFA_QUEST);\n\t    break;\n\n\tcase Magic('{'):\n\t    // a{2,5} will expand to 'aaa?a?a?'\n\t    // a{-1,3} will expand to 'aa??a??', where ?? is the nongreedy\n\t    // version of '?'\n\t    // \\v(ab){2,3} will expand to '(ab)(ab)(ab)?', where all the\n\t    // parenthesis have the same id\n\n\t    greedy = TRUE;\n\t    c2 = peekchr();\n\t    if (c2 == '-' || c2 == Magic('-'))\n\t    {\n\t\tskipchr();\n\t\tgreedy = FALSE;\n\t    }\n\t    if (!read_limits(&minval, &maxval))\n\t\tEMSG_RET_FAIL(_(\"E870: (NFA regexp) Error reading repetition limits\"));\n\n\t    //  <atom>{0,inf}, <atom>{0,} and <atom>{}  are equivalent to\n\t    //  <atom>*\n\t    if (minval == 0 && maxval == MAX_LIMIT)\n\t    {\n\t\tif (greedy)\t\t// { { (match the braces)\n\t\t    // \\{}, \\{0,}\n\t\t    EMIT(NFA_STAR);\n\t\telse\t\t\t// { { (match the braces)\n\t\t    // \\{-}, \\{-0,}\n\t\t    EMIT(NFA_STAR_NONGREEDY);\n\t\tbreak;\n\t    }\n\n\t    // Special case: x{0} or x{-0}\n\t    if (maxval == 0)\n\t    {\n\t\t// Ignore result of previous call to nfa_regatom()\n\t\tpost_ptr = post_start + my_post_start;\n\t\t// NFA_EMPTY is 0-length and works everywhere\n\t\tEMIT(NFA_EMPTY);\n\t\treturn OK;\n\t    }\n\n\t    // The engine is very inefficient (uses too many states) when the\n\t    // maximum is much larger than the minimum and when the maximum is\n\t    // large.  However, when maxval is MAX_LIMIT, it is okay, as this\n\t    // will emit NFA_STAR.\n\t    // Bail out if we can use the other engine, but only, when the\n\t    // pattern does not need the NFA engine like (e.g. [[:upper:]]\\{2,\\}\n\t    // does not work with with characters > 8 bit with the BT engine)\n\t    if ((nfa_re_flags & RE_AUTO)\n\t\t\t\t   && (maxval > 500 || maxval > minval + 200)\n\t\t\t\t   && (maxval != MAX_LIMIT && minval < 200)\n\t\t\t\t   && !wants_nfa)\n\t\treturn FAIL;\n\n\t    // Ignore previous call to nfa_regatom()\n\t    post_ptr = post_start + my_post_start;\n\t    // Save parse state after the repeated atom and the \\{}\n\t    save_parse_state(&new_state);\n\n\t    quest = (greedy == TRUE? NFA_QUEST : NFA_QUEST_NONGREEDY);\n\t    for (i = 0; i < maxval; i++)\n\t    {\n\t\t// Goto beginning of the repeated atom\n\t\trestore_parse_state(&old_state);\n\t\told_post_pos = (int)(post_ptr - post_start);\n\t\tif (nfa_regatom() == FAIL)\n\t\t    return FAIL;\n\t\t// after \"minval\" times, atoms are optional\n\t\tif (i + 1 > minval)\n\t\t{\n\t\t    if (maxval == MAX_LIMIT)\n\t\t    {\n\t\t\tif (greedy)\n\t\t\t    EMIT(NFA_STAR);\n\t\t\telse\n\t\t\t    EMIT(NFA_STAR_NONGREEDY);\n\t\t    }\n\t\t    else\n\t\t\tEMIT(quest);\n\t\t}\n\t\tif (old_post_pos != my_post_start)\n\t\t    EMIT(NFA_CONCAT);\n\t\tif (i + 1 > minval && maxval == MAX_LIMIT)\n\t\t    break;\n\t    }\n\n\t    // Go to just after the repeated atom and the \\{}\n\t    restore_parse_state(&new_state);\n\t    curchr = -1;\n\n\t    break;\n\n\n\tdefault:\n\t    break;\n    }\t// end switch\n\n    if (re_multi_type(peekchr()) != NOT_MULTI)\n\t// Can't have a multi follow a multi.\n\tEMSG_RET_FAIL(_(\"E871: (NFA regexp) Can't have a multi follow a multi\"));\n\n    return OK;\n}\n\n/*\n * Parse one or more pieces, concatenated.  It matches a match for the\n * first piece, followed by a match for the second piece, etc.  Example:\n * \"f[0-9]b\", first matches \"f\", then a digit and then \"b\".\n *\n * concat  ::=\t    piece\n *\tor  piece piece\n *\tor  piece piece piece\n *\tetc.\n */\n    static int\nnfa_regconcat(void)\n{\n    int\t\tcont = TRUE;\n    int\t\tfirst = TRUE;\n\n    while (cont)\n    {\n\tswitch (peekchr())\n\t{\n\t    case NUL:\n\t    case Magic('|'):\n\t    case Magic('&'):\n\t    case Magic(')'):\n\t\tcont = FALSE;\n\t\tbreak;\n\n\t    case Magic('Z'):\n\t\tregflags |= RF_ICOMBINE;\n\t\tskipchr_keepstart();\n\t\tbreak;\n\t    case Magic('c'):\n\t\tregflags |= RF_ICASE;\n\t\tskipchr_keepstart();\n\t\tbreak;\n\t    case Magic('C'):\n\t\tregflags |= RF_NOICASE;\n\t\tskipchr_keepstart();\n\t\tbreak;\n\t    case Magic('v'):\n\t\treg_magic = MAGIC_ALL;\n\t\tskipchr_keepstart();\n\t\tcurchr = -1;\n\t\tbreak;\n\t    case Magic('m'):\n\t\treg_magic = MAGIC_ON;\n\t\tskipchr_keepstart();\n\t\tcurchr = -1;\n\t\tbreak;\n\t    case Magic('M'):\n\t\treg_magic = MAGIC_OFF;\n\t\tskipchr_keepstart();\n\t\tcurchr = -1;\n\t\tbreak;\n\t    case Magic('V'):\n\t\treg_magic = MAGIC_NONE;\n\t\tskipchr_keepstart();\n\t\tcurchr = -1;\n\t\tbreak;\n\n\t    default:\n\t\tif (nfa_regpiece() == FAIL)\n\t\t    return FAIL;\n\t\tif (first == FALSE)\n\t\t    EMIT(NFA_CONCAT);\n\t\telse\n\t\t    first = FALSE;\n\t\tbreak;\n\t}\n    }\n\n    return OK;\n}\n\n/*\n * Parse a branch, one or more concats, separated by \"\\&\".  It matches the\n * last concat, but only if all the preceding concats also match at the same\n * position.  Examples:\n *      \"foobeep\\&...\" matches \"foo\" in \"foobeep\".\n *      \".*Peter\\&.*Bob\" matches in a line containing both \"Peter\" and \"Bob\"\n *\n * branch ::=\t    concat\n *\t\tor  concat \\& concat\n *\t\tor  concat \\& concat \\& concat\n *\t\tetc.\n */\n    static int\nnfa_regbranch(void)\n{\n    int\t\told_post_pos;\n\n    old_post_pos = (int)(post_ptr - post_start);\n\n    // First branch, possibly the only one\n    if (nfa_regconcat() == FAIL)\n\treturn FAIL;\n\n    // Try next concats\n    while (peekchr() == Magic('&'))\n    {\n\tskipchr();\n\t// if concat is empty do emit a node\n\tif (old_post_pos == (int)(post_ptr - post_start))\n\t    EMIT(NFA_EMPTY);\n\tEMIT(NFA_NOPEN);\n\tEMIT(NFA_PREV_ATOM_NO_WIDTH);\n\told_post_pos = (int)(post_ptr - post_start);\n\tif (nfa_regconcat() == FAIL)\n\t    return FAIL;\n\t// if concat is empty do emit a node\n\tif (old_post_pos == (int)(post_ptr - post_start))\n\t    EMIT(NFA_EMPTY);\n\tEMIT(NFA_CONCAT);\n    }\n\n    // if a branch is empty, emit one node for it\n    if (old_post_pos == (int)(post_ptr - post_start))\n\tEMIT(NFA_EMPTY);\n\n    return OK;\n}\n\n/*\n *  Parse a pattern, one or more branches, separated by \"\\|\".  It matches\n *  anything that matches one of the branches.  Example: \"foo\\|beep\" matches\n *  \"foo\" and matches \"beep\".  If more than one branch matches, the first one\n *  is used.\n *\n *  pattern ::=\t    branch\n *\tor  branch \\| branch\n *\tor  branch \\| branch \\| branch\n *\tetc.\n */\n    static int\nnfa_reg(\n    int\t\tparen)\t// REG_NOPAREN, REG_PAREN, REG_NPAREN or REG_ZPAREN\n{\n    int\t\tparno = 0;\n\n    if (paren == REG_PAREN)\n    {\n\tif (regnpar >= NSUBEXP) // Too many `('\n\t    EMSG_RET_FAIL(_(\"E872: (NFA regexp) Too many '('\"));\n\tparno = regnpar++;\n    }\n#ifdef FEAT_SYN_HL\n    else if (paren == REG_ZPAREN)\n    {\n\t// Make a ZOPEN node.\n\tif (regnzpar >= NSUBEXP)\n\t    EMSG_RET_FAIL(_(\"E879: (NFA regexp) Too many \\\\z(\"));\n\tparno = regnzpar++;\n    }\n#endif\n\n    if (nfa_regbranch() == FAIL)\n\treturn FAIL;\t    // cascaded error\n\n    while (peekchr() == Magic('|'))\n    {\n\tskipchr();\n\tif (nfa_regbranch() == FAIL)\n\t    return FAIL;    // cascaded error\n\tEMIT(NFA_OR);\n    }\n\n    // Check for proper termination.\n    if (paren != REG_NOPAREN && getchr() != Magic(')'))\n    {\n\tif (paren == REG_NPAREN)\n\t    EMSG2_RET_FAIL(_(e_unmatched_str_percent_open),\n\t\t\t\t\t\t       reg_magic == MAGIC_ALL);\n\telse\n\t    EMSG2_RET_FAIL(_(e_unmatched_str_open), reg_magic == MAGIC_ALL);\n    }\n    else if (paren == REG_NOPAREN && peekchr() != NUL)\n    {\n\tif (peekchr() == Magic(')'))\n\t    EMSG2_RET_FAIL(_(e_unmatched_str_close), reg_magic == MAGIC_ALL);\n\telse\n\t    EMSG_RET_FAIL(_(\"E873: (NFA regexp) proper termination error\"));\n    }\n    /*\n     * Here we set the flag allowing back references to this set of\n     * parentheses.\n     */\n    if (paren == REG_PAREN)\n    {\n\thad_endbrace[parno] = TRUE;     // have seen the close paren\n\tEMIT(NFA_MOPEN + parno);\n    }\n#ifdef FEAT_SYN_HL\n    else if (paren == REG_ZPAREN)\n\tEMIT(NFA_ZOPEN + parno);\n#endif\n\n    return OK;\n}\n\n#ifdef DEBUG\nstatic char_u code[50];\n\n    static void\nnfa_set_code(int c)\n{\n    int\t    addnl = FALSE;\n\n    if (c >= NFA_FIRST_NL && c <= NFA_LAST_NL)\n    {\n\taddnl = TRUE;\n\tc -= NFA_ADD_NL;\n    }\n\n    STRCPY(code, \"\");\n    switch (c)\n    {\n\tcase NFA_MATCH:\t    STRCPY(code, \"NFA_MATCH \"); break;\n\tcase NFA_SPLIT:\t    STRCPY(code, \"NFA_SPLIT \"); break;\n\tcase NFA_CONCAT:    STRCPY(code, \"NFA_CONCAT \"); break;\n\tcase NFA_NEWL:\t    STRCPY(code, \"NFA_NEWL \"); break;\n\tcase NFA_ZSTART:    STRCPY(code, \"NFA_ZSTART\"); break;\n\tcase NFA_ZEND:\t    STRCPY(code, \"NFA_ZEND\"); break;\n\n\tcase NFA_BACKREF1:  STRCPY(code, \"NFA_BACKREF1\"); break;\n\tcase NFA_BACKREF2:  STRCPY(code, \"NFA_BACKREF2\"); break;\n\tcase NFA_BACKREF3:  STRCPY(code, \"NFA_BACKREF3\"); break;\n\tcase NFA_BACKREF4:  STRCPY(code, \"NFA_BACKREF4\"); break;\n\tcase NFA_BACKREF5:  STRCPY(code, \"NFA_BACKREF5\"); break;\n\tcase NFA_BACKREF6:  STRCPY(code, \"NFA_BACKREF6\"); break;\n\tcase NFA_BACKREF7:  STRCPY(code, \"NFA_BACKREF7\"); break;\n\tcase NFA_BACKREF8:  STRCPY(code, \"NFA_BACKREF8\"); break;\n\tcase NFA_BACKREF9:  STRCPY(code, \"NFA_BACKREF9\"); break;\n#ifdef FEAT_SYN_HL\n\tcase NFA_ZREF1:\t    STRCPY(code, \"NFA_ZREF1\"); break;\n\tcase NFA_ZREF2:\t    STRCPY(code, \"NFA_ZREF2\"); break;\n\tcase NFA_ZREF3:\t    STRCPY(code, \"NFA_ZREF3\"); break;\n\tcase NFA_ZREF4:\t    STRCPY(code, \"NFA_ZREF4\"); break;\n\tcase NFA_ZREF5:\t    STRCPY(code, \"NFA_ZREF5\"); break;\n\tcase NFA_ZREF6:\t    STRCPY(code, \"NFA_ZREF6\"); break;\n\tcase NFA_ZREF7:\t    STRCPY(code, \"NFA_ZREF7\"); break;\n\tcase NFA_ZREF8:\t    STRCPY(code, \"NFA_ZREF8\"); break;\n\tcase NFA_ZREF9:\t    STRCPY(code, \"NFA_ZREF9\"); break;\n#endif\n\tcase NFA_SKIP:\t    STRCPY(code, \"NFA_SKIP\"); break;\n\n\tcase NFA_PREV_ATOM_NO_WIDTH:\n\t\t\t    STRCPY(code, \"NFA_PREV_ATOM_NO_WIDTH\"); break;\n\tcase NFA_PREV_ATOM_NO_WIDTH_NEG:\n\t\t\t    STRCPY(code, \"NFA_PREV_ATOM_NO_WIDTH_NEG\"); break;\n\tcase NFA_PREV_ATOM_JUST_BEFORE:\n\t\t\t    STRCPY(code, \"NFA_PREV_ATOM_JUST_BEFORE\"); break;\n\tcase NFA_PREV_ATOM_JUST_BEFORE_NEG:\n\t\t\t STRCPY(code, \"NFA_PREV_ATOM_JUST_BEFORE_NEG\"); break;\n\tcase NFA_PREV_ATOM_LIKE_PATTERN:\n\t\t\t    STRCPY(code, \"NFA_PREV_ATOM_LIKE_PATTERN\"); break;\n\n\tcase NFA_NOPEN:\t\t    STRCPY(code, \"NFA_NOPEN\"); break;\n\tcase NFA_NCLOSE:\t    STRCPY(code, \"NFA_NCLOSE\"); break;\n\tcase NFA_START_INVISIBLE:   STRCPY(code, \"NFA_START_INVISIBLE\"); break;\n\tcase NFA_START_INVISIBLE_FIRST:\n\t\t\t     STRCPY(code, \"NFA_START_INVISIBLE_FIRST\"); break;\n\tcase NFA_START_INVISIBLE_NEG:\n\t\t\t       STRCPY(code, \"NFA_START_INVISIBLE_NEG\"); break;\n\tcase NFA_START_INVISIBLE_NEG_FIRST:\n\t\t\t STRCPY(code, \"NFA_START_INVISIBLE_NEG_FIRST\"); break;\n\tcase NFA_START_INVISIBLE_BEFORE:\n\t\t\t    STRCPY(code, \"NFA_START_INVISIBLE_BEFORE\"); break;\n\tcase NFA_START_INVISIBLE_BEFORE_FIRST:\n\t\t      STRCPY(code, \"NFA_START_INVISIBLE_BEFORE_FIRST\"); break;\n\tcase NFA_START_INVISIBLE_BEFORE_NEG:\n\t\t\tSTRCPY(code, \"NFA_START_INVISIBLE_BEFORE_NEG\"); break;\n\tcase NFA_START_INVISIBLE_BEFORE_NEG_FIRST:\n\t\t  STRCPY(code, \"NFA_START_INVISIBLE_BEFORE_NEG_FIRST\"); break;\n\tcase NFA_START_PATTERN:   STRCPY(code, \"NFA_START_PATTERN\"); break;\n\tcase NFA_END_INVISIBLE:\t    STRCPY(code, \"NFA_END_INVISIBLE\"); break;\n\tcase NFA_END_INVISIBLE_NEG: STRCPY(code, \"NFA_END_INVISIBLE_NEG\"); break;\n\tcase NFA_END_PATTERN:\t    STRCPY(code, \"NFA_END_PATTERN\"); break;\n\n\tcase NFA_COMPOSING:\t    STRCPY(code, \"NFA_COMPOSING\"); break;\n\tcase NFA_END_COMPOSING:\t    STRCPY(code, \"NFA_END_COMPOSING\"); break;\n\tcase NFA_OPT_CHARS:\t    STRCPY(code, \"NFA_OPT_CHARS\"); break;\n\n\tcase NFA_MOPEN:\n\tcase NFA_MOPEN1:\n\tcase NFA_MOPEN2:\n\tcase NFA_MOPEN3:\n\tcase NFA_MOPEN4:\n\tcase NFA_MOPEN5:\n\tcase NFA_MOPEN6:\n\tcase NFA_MOPEN7:\n\tcase NFA_MOPEN8:\n\tcase NFA_MOPEN9:\n\t    STRCPY(code, \"NFA_MOPEN(x)\");\n\t    code[10] = c - NFA_MOPEN + '0';\n\t    break;\n\tcase NFA_MCLOSE:\n\tcase NFA_MCLOSE1:\n\tcase NFA_MCLOSE2:\n\tcase NFA_MCLOSE3:\n\tcase NFA_MCLOSE4:\n\tcase NFA_MCLOSE5:\n\tcase NFA_MCLOSE6:\n\tcase NFA_MCLOSE7:\n\tcase NFA_MCLOSE8:\n\tcase NFA_MCLOSE9:\n\t    STRCPY(code, \"NFA_MCLOSE(x)\");\n\t    code[11] = c - NFA_MCLOSE + '0';\n\t    break;\n#ifdef FEAT_SYN_HL\n\tcase NFA_ZOPEN:\n\tcase NFA_ZOPEN1:\n\tcase NFA_ZOPEN2:\n\tcase NFA_ZOPEN3:\n\tcase NFA_ZOPEN4:\n\tcase NFA_ZOPEN5:\n\tcase NFA_ZOPEN6:\n\tcase NFA_ZOPEN7:\n\tcase NFA_ZOPEN8:\n\tcase NFA_ZOPEN9:\n\t    STRCPY(code, \"NFA_ZOPEN(x)\");\n\t    code[10] = c - NFA_ZOPEN + '0';\n\t    break;\n\tcase NFA_ZCLOSE:\n\tcase NFA_ZCLOSE1:\n\tcase NFA_ZCLOSE2:\n\tcase NFA_ZCLOSE3:\n\tcase NFA_ZCLOSE4:\n\tcase NFA_ZCLOSE5:\n\tcase NFA_ZCLOSE6:\n\tcase NFA_ZCLOSE7:\n\tcase NFA_ZCLOSE8:\n\tcase NFA_ZCLOSE9:\n\t    STRCPY(code, \"NFA_ZCLOSE(x)\");\n\t    code[11] = c - NFA_ZCLOSE + '0';\n\t    break;\n#endif\n\tcase NFA_EOL:\t\tSTRCPY(code, \"NFA_EOL \"); break;\n\tcase NFA_BOL:\t\tSTRCPY(code, \"NFA_BOL \"); break;\n\tcase NFA_EOW:\t\tSTRCPY(code, \"NFA_EOW \"); break;\n\tcase NFA_BOW:\t\tSTRCPY(code, \"NFA_BOW \"); break;\n\tcase NFA_EOF:\t\tSTRCPY(code, \"NFA_EOF \"); break;\n\tcase NFA_BOF:\t\tSTRCPY(code, \"NFA_BOF \"); break;\n\tcase NFA_LNUM:\t\tSTRCPY(code, \"NFA_LNUM \"); break;\n\tcase NFA_LNUM_GT:\tSTRCPY(code, \"NFA_LNUM_GT \"); break;\n\tcase NFA_LNUM_LT:\tSTRCPY(code, \"NFA_LNUM_LT \"); break;\n\tcase NFA_COL:\t\tSTRCPY(code, \"NFA_COL \"); break;\n\tcase NFA_COL_GT:\tSTRCPY(code, \"NFA_COL_GT \"); break;\n\tcase NFA_COL_LT:\tSTRCPY(code, \"NFA_COL_LT \"); break;\n\tcase NFA_VCOL:\t\tSTRCPY(code, \"NFA_VCOL \"); break;\n\tcase NFA_VCOL_GT:\tSTRCPY(code, \"NFA_VCOL_GT \"); break;\n\tcase NFA_VCOL_LT:\tSTRCPY(code, \"NFA_VCOL_LT \"); break;\n\tcase NFA_MARK:\t\tSTRCPY(code, \"NFA_MARK \"); break;\n\tcase NFA_MARK_GT:\tSTRCPY(code, \"NFA_MARK_GT \"); break;\n\tcase NFA_MARK_LT:\tSTRCPY(code, \"NFA_MARK_LT \"); break;\n\tcase NFA_CURSOR:\tSTRCPY(code, \"NFA_CURSOR \"); break;\n\tcase NFA_VISUAL:\tSTRCPY(code, \"NFA_VISUAL \"); break;\n\tcase NFA_ANY_COMPOSING:\tSTRCPY(code, \"NFA_ANY_COMPOSING \"); break;\n\n\tcase NFA_STAR:\t\tSTRCPY(code, \"NFA_STAR \"); break;\n\tcase NFA_STAR_NONGREEDY: STRCPY(code, \"NFA_STAR_NONGREEDY \"); break;\n\tcase NFA_QUEST:\t\tSTRCPY(code, \"NFA_QUEST\"); break;\n\tcase NFA_QUEST_NONGREEDY: STRCPY(code, \"NFA_QUEST_NON_GREEDY\"); break;\n\tcase NFA_EMPTY:\t\tSTRCPY(code, \"NFA_EMPTY\"); break;\n\tcase NFA_OR:\t\tSTRCPY(code, \"NFA_OR\"); break;\n\n\tcase NFA_START_COLL:\tSTRCPY(code, \"NFA_START_COLL\"); break;\n\tcase NFA_END_COLL:\tSTRCPY(code, \"NFA_END_COLL\"); break;\n\tcase NFA_START_NEG_COLL: STRCPY(code, \"NFA_START_NEG_COLL\"); break;\n\tcase NFA_END_NEG_COLL:\tSTRCPY(code, \"NFA_END_NEG_COLL\"); break;\n\tcase NFA_RANGE:\t\tSTRCPY(code, \"NFA_RANGE\"); break;\n\tcase NFA_RANGE_MIN:\tSTRCPY(code, \"NFA_RANGE_MIN\"); break;\n\tcase NFA_RANGE_MAX:\tSTRCPY(code, \"NFA_RANGE_MAX\"); break;\n\n\tcase NFA_CLASS_ALNUM:\tSTRCPY(code, \"NFA_CLASS_ALNUM\"); break;\n\tcase NFA_CLASS_ALPHA:\tSTRCPY(code, \"NFA_CLASS_ALPHA\"); break;\n\tcase NFA_CLASS_BLANK:\tSTRCPY(code, \"NFA_CLASS_BLANK\"); break;\n\tcase NFA_CLASS_CNTRL:\tSTRCPY(code, \"NFA_CLASS_CNTRL\"); break;\n\tcase NFA_CLASS_DIGIT:\tSTRCPY(code, \"NFA_CLASS_DIGIT\"); break;\n\tcase NFA_CLASS_GRAPH:\tSTRCPY(code, \"NFA_CLASS_GRAPH\"); break;\n\tcase NFA_CLASS_LOWER:\tSTRCPY(code, \"NFA_CLASS_LOWER\"); break;\n\tcase NFA_CLASS_PRINT:\tSTRCPY(code, \"NFA_CLASS_PRINT\"); break;\n\tcase NFA_CLASS_PUNCT:\tSTRCPY(code, \"NFA_CLASS_PUNCT\"); break;\n\tcase NFA_CLASS_SPACE:\tSTRCPY(code, \"NFA_CLASS_SPACE\"); break;\n\tcase NFA_CLASS_UPPER:\tSTRCPY(code, \"NFA_CLASS_UPPER\"); break;\n\tcase NFA_CLASS_XDIGIT:\tSTRCPY(code, \"NFA_CLASS_XDIGIT\"); break;\n\tcase NFA_CLASS_TAB:\tSTRCPY(code, \"NFA_CLASS_TAB\"); break;\n\tcase NFA_CLASS_RETURN:\tSTRCPY(code, \"NFA_CLASS_RETURN\"); break;\n\tcase NFA_CLASS_BACKSPACE:   STRCPY(code, \"NFA_CLASS_BACKSPACE\"); break;\n\tcase NFA_CLASS_ESCAPE:\tSTRCPY(code, \"NFA_CLASS_ESCAPE\"); break;\n\tcase NFA_CLASS_IDENT:\tSTRCPY(code, \"NFA_CLASS_IDENT\"); break;\n\tcase NFA_CLASS_KEYWORD:\tSTRCPY(code, \"NFA_CLASS_KEYWORD\"); break;\n\tcase NFA_CLASS_FNAME:\tSTRCPY(code, \"NFA_CLASS_FNAME\"); break;\n\n\tcase NFA_ANY:\tSTRCPY(code, \"NFA_ANY\"); break;\n\tcase NFA_IDENT:\tSTRCPY(code, \"NFA_IDENT\"); break;\n\tcase NFA_SIDENT:STRCPY(code, \"NFA_SIDENT\"); break;\n\tcase NFA_KWORD:\tSTRCPY(code, \"NFA_KWORD\"); break;\n\tcase NFA_SKWORD:STRCPY(code, \"NFA_SKWORD\"); break;\n\tcase NFA_FNAME:\tSTRCPY(code, \"NFA_FNAME\"); break;\n\tcase NFA_SFNAME:STRCPY(code, \"NFA_SFNAME\"); break;\n\tcase NFA_PRINT:\tSTRCPY(code, \"NFA_PRINT\"); break;\n\tcase NFA_SPRINT:STRCPY(code, \"NFA_SPRINT\"); break;\n\tcase NFA_WHITE:\tSTRCPY(code, \"NFA_WHITE\"); break;\n\tcase NFA_NWHITE:STRCPY(code, \"NFA_NWHITE\"); break;\n\tcase NFA_DIGIT:\tSTRCPY(code, \"NFA_DIGIT\"); break;\n\tcase NFA_NDIGIT:STRCPY(code, \"NFA_NDIGIT\"); break;\n\tcase NFA_HEX:\tSTRCPY(code, \"NFA_HEX\"); break;\n\tcase NFA_NHEX:\tSTRCPY(code, \"NFA_NHEX\"); break;\n\tcase NFA_OCTAL:\tSTRCPY(code, \"NFA_OCTAL\"); break;\n\tcase NFA_NOCTAL:STRCPY(code, \"NFA_NOCTAL\"); break;\n\tcase NFA_WORD:\tSTRCPY(code, \"NFA_WORD\"); break;\n\tcase NFA_NWORD:\tSTRCPY(code, \"NFA_NWORD\"); break;\n\tcase NFA_HEAD:\tSTRCPY(code, \"NFA_HEAD\"); break;\n\tcase NFA_NHEAD:\tSTRCPY(code, \"NFA_NHEAD\"); break;\n\tcase NFA_ALPHA:\tSTRCPY(code, \"NFA_ALPHA\"); break;\n\tcase NFA_NALPHA:STRCPY(code, \"NFA_NALPHA\"); break;\n\tcase NFA_LOWER:\tSTRCPY(code, \"NFA_LOWER\"); break;\n\tcase NFA_NLOWER:STRCPY(code, \"NFA_NLOWER\"); break;\n\tcase NFA_UPPER:\tSTRCPY(code, \"NFA_UPPER\"); break;\n\tcase NFA_NUPPER:STRCPY(code, \"NFA_NUPPER\"); break;\n\tcase NFA_LOWER_IC:  STRCPY(code, \"NFA_LOWER_IC\"); break;\n\tcase NFA_NLOWER_IC: STRCPY(code, \"NFA_NLOWER_IC\"); break;\n\tcase NFA_UPPER_IC:  STRCPY(code, \"NFA_UPPER_IC\"); break;\n\tcase NFA_NUPPER_IC: STRCPY(code, \"NFA_NUPPER_IC\"); break;\n\n\tdefault:\n\t    STRCPY(code, \"CHAR(x)\");\n\t    code[5] = c;\n    }\n\n    if (addnl == TRUE)\n\tSTRCAT(code, \" + NEWLINE \");\n\n}\n\n#ifdef ENABLE_LOG\nstatic FILE *log_fd;\nstatic char_u e_log_open_failed[] = N_(\"Could not open temporary log file for writing, displaying on stderr... \");\n\n/*\n * Print the postfix notation of the current regexp.\n */\n    static void\nnfa_postfix_dump(char_u *expr, int retval)\n{\n    int *p;\n    FILE *f;\n\n    f = fopen(NFA_REGEXP_DUMP_LOG, \"a\");\n    if (f != NULL)\n    {\n\tfprintf(f, \"\\n-------------------------\\n\");\n\tif (retval == FAIL)\n\t    fprintf(f, \">>> NFA engine failed... \\n\");\n\telse if (retval == OK)\n\t    fprintf(f, \">>> NFA engine succeeded !\\n\");\n\tfprintf(f, \"Regexp: \\\"%s\\\"\\nPostfix notation (char): \\\"\", expr);\n\tfor (p = post_start; *p && p < post_ptr; p++)\n\t{\n\t    nfa_set_code(*p);\n\t    fprintf(f, \"%s, \", code);\n\t}\n\tfprintf(f, \"\\\"\\nPostfix notation (int): \");\n\tfor (p = post_start; *p && p < post_ptr; p++)\n\t\tfprintf(f, \"%d \", *p);\n\tfprintf(f, \"\\n\\n\");\n\tfclose(f);\n    }\n}\n\n/*\n * Print the NFA starting with a root node \"state\".\n */\n    static void\nnfa_print_state(FILE *debugf, nfa_state_T *state)\n{\n    garray_T indent;\n\n    ga_init2(&indent, 1, 64);\n    ga_append(&indent, '\\0');\n    nfa_print_state2(debugf, state, &indent);\n    ga_clear(&indent);\n}\n\n    static void\nnfa_print_state2(FILE *debugf, nfa_state_T *state, garray_T *indent)\n{\n    char_u  *p;\n\n    if (state == NULL)\n\treturn;\n\n    fprintf(debugf, \"(%2d)\", abs(state->id));\n\n    // Output indent\n    p = (char_u *)indent->ga_data;\n    if (indent->ga_len >= 3)\n    {\n\tint\tlast = indent->ga_len - 3;\n\tchar_u\tsave[2];\n\n\tSTRNCPY(save, &p[last], 2);\n\tSTRNCPY(&p[last], \"+-\", 2);\n\tfprintf(debugf, \" %s\", p);\n\tSTRNCPY(&p[last], save, 2);\n    }\n    else\n\tfprintf(debugf, \" %s\", p);\n\n    nfa_set_code(state->c);\n    fprintf(debugf, \"%s (%d) (id=%d) val=%d\\n\",\n\t\t code,\n\t\t state->c,\n\t\t abs(state->id),\n\t\t state->val);\n    if (state->id < 0)\n\treturn;\n\n    state->id = abs(state->id) * -1;\n\n    // grow indent for state->out\n    indent->ga_len -= 1;\n    if (state->out1)\n\tga_concat(indent, (char_u *)\"| \");\n    else\n\tga_concat(indent, (char_u *)\"  \");\n    ga_append(indent, '\\0');\n\n    nfa_print_state2(debugf, state->out, indent);\n\n    // replace last part of indent for state->out1\n    indent->ga_len -= 3;\n    ga_concat(indent, (char_u *)\"  \");\n    ga_append(indent, '\\0');\n\n    nfa_print_state2(debugf, state->out1, indent);\n\n    // shrink indent\n    indent->ga_len -= 3;\n    ga_append(indent, '\\0');\n}\n\n/*\n * Print the NFA state machine.\n */\n    static void\nnfa_dump(nfa_regprog_T *prog)\n{\n    FILE *debugf = fopen(NFA_REGEXP_DUMP_LOG, \"a\");\n\n    if (debugf != NULL)\n    {\n\tnfa_print_state(debugf, prog->start);\n\n\tif (prog->reganch)\n\t    fprintf(debugf, \"reganch: %d\\n\", prog->reganch);\n\tif (prog->regstart != NUL)\n\t    fprintf(debugf, \"regstart: %c (decimal: %d)\\n\",\n\t\t\t\t\t      prog->regstart, prog->regstart);\n\tif (prog->match_text != NULL)\n\t    fprintf(debugf, \"match_text: \\\"%s\\\"\\n\", prog->match_text);\n\n\tfclose(debugf);\n    }\n}\n#endif\t    // ENABLE_LOG\n#endif\t    // DEBUG\n\n/*\n * Parse r.e. @expr and convert it into postfix form.\n * Return the postfix string on success, NULL otherwise.\n */\n    static int *\nre2post(void)\n{\n    if (nfa_reg(REG_NOPAREN) == FAIL)\n\treturn NULL;\n    EMIT(NFA_MOPEN);\n    return post_start;\n}\n\n// NB. Some of the code below is inspired by Russ's.\n\n/*\n * Represents an NFA state plus zero or one or two arrows exiting.\n * if c == MATCH, no arrows out; matching state.\n * If c == SPLIT, unlabeled arrows to out and out1 (if != NULL).\n * If c < 256, labeled arrow with character c to out.\n */\n\nstatic nfa_state_T\t*state_ptr; // points to nfa_prog->state\n\n/*\n * Allocate and initialize nfa_state_T.\n */\n    static nfa_state_T *\nalloc_state(int c, nfa_state_T *out, nfa_state_T *out1)\n{\n    nfa_state_T *s;\n\n    if (istate >= nstate)\n\treturn NULL;\n\n    s = &state_ptr[istate++];\n\n    s->c    = c;\n    s->out  = out;\n    s->out1 = out1;\n    s->val  = 0;\n\n    s->id   = istate;\n    s->lastlist[0] = 0;\n    s->lastlist[1] = 0;\n\n    return s;\n}\n\n/*\n * A partially built NFA without the matching state filled in.\n * Frag_T.start points at the start state.\n * Frag_T.out is a list of places that need to be set to the\n * next state for this fragment.\n */\n\n// Since the out pointers in the list are always\n// uninitialized, we use the pointers themselves\n// as storage for the Ptrlists.\ntypedef union Ptrlist Ptrlist;\nunion Ptrlist\n{\n    Ptrlist\t*next;\n    nfa_state_T\t*s;\n};\n\nstruct Frag\n{\n    nfa_state_T *start;\n    Ptrlist\t*out;\n};\ntypedef struct Frag Frag_T;\n\n/*\n * Initialize a Frag_T struct and return it.\n */\n    static Frag_T\nfrag(nfa_state_T *start, Ptrlist *out)\n{\n    Frag_T n;\n\n    n.start = start;\n    n.out = out;\n    return n;\n}\n\n/*\n * Create singleton list containing just outp.\n */\n    static Ptrlist *\nlist1(\n    nfa_state_T\t**outp)\n{\n    Ptrlist *l;\n\n    l = (Ptrlist *)outp;\n    l->next = NULL;\n    return l;\n}\n\n/*\n * Patch the list of states at out to point to start.\n */\n    static void\npatch(Ptrlist *l, nfa_state_T *s)\n{\n    Ptrlist *next;\n\n    for (; l; l = next)\n    {\n\tnext = l->next;\n\tl->s = s;\n    }\n}\n\n\n/*\n * Join the two lists l1 and l2, returning the combination.\n */\n    static Ptrlist *\nappend(Ptrlist *l1, Ptrlist *l2)\n{\n    Ptrlist *oldl1;\n\n    oldl1 = l1;\n    while (l1->next)\n\tl1 = l1->next;\n    l1->next = l2;\n    return oldl1;\n}\n\n/*\n * Stack used for transforming postfix form into NFA.\n */\nstatic Frag_T empty;\n\n    static void\nst_error(int *postfix UNUSED, int *end UNUSED, int *p UNUSED)\n{\n#ifdef NFA_REGEXP_ERROR_LOG\n    FILE *df;\n    int *p2;\n\n    df = fopen(NFA_REGEXP_ERROR_LOG, \"a\");\n    if (df)\n    {\n\tfprintf(df, \"Error popping the stack!\\n\");\n# ifdef DEBUG\n\tfprintf(df, \"Current regexp is \\\"%s\\\"\\n\", nfa_regengine.expr);\n# endif\n\tfprintf(df, \"Postfix form is: \");\n# ifdef DEBUG\n\tfor (p2 = postfix; p2 < end; p2++)\n\t{\n\t    nfa_set_code(*p2);\n\t    fprintf(df, \"%s, \", code);\n\t}\n\tnfa_set_code(*p);\n\tfprintf(df, \"\\nCurrent position is: \");\n\tfor (p2 = postfix; p2 <= p; p2 ++)\n\t{\n\t    nfa_set_code(*p2);\n\t    fprintf(df, \"%s, \", code);\n\t}\n# else\n\tfor (p2 = postfix; p2 < end; p2++)\n\t    fprintf(df, \"%d, \", *p2);\n\tfprintf(df, \"\\nCurrent position is: \");\n\tfor (p2 = postfix; p2 <= p; p2 ++)\n\t    fprintf(df, \"%d, \", *p2);\n# endif\n\tfprintf(df, \"\\n--------------------------\\n\");\n\tfclose(df);\n    }\n#endif\n    emsg(_(\"E874: (NFA) Could not pop the stack!\"));\n}\n\n/*\n * Push an item onto the stack.\n */\n    static void\nst_push(Frag_T s, Frag_T **p, Frag_T *stack_end)\n{\n    Frag_T *stackp = *p;\n\n    if (stackp >= stack_end)\n\treturn;\n    *stackp = s;\n    *p = *p + 1;\n}\n\n/*\n * Pop an item from the stack.\n */\n    static Frag_T\nst_pop(Frag_T **p, Frag_T *stack)\n{\n    Frag_T *stackp;\n\n    *p = *p - 1;\n    stackp = *p;\n    if (stackp < stack)\n\treturn empty;\n    return **p;\n}\n\n/*\n * Estimate the maximum byte length of anything matching \"state\".\n * When unknown or unlimited return -1.\n */\n    static int\nnfa_max_width(nfa_state_T *startstate, int depth)\n{\n    int\t\t    l, r;\n    nfa_state_T\t    *state = startstate;\n    int\t\t    len = 0;\n\n    // detect looping in a NFA_SPLIT\n    if (depth > 4)\n\treturn -1;\n\n    while (state != NULL)\n    {\n\tswitch (state->c)\n\t{\n\t    case NFA_END_INVISIBLE:\n\t    case NFA_END_INVISIBLE_NEG:\n\t\t// the end, return what we have\n\t\treturn len;\n\n\t    case NFA_SPLIT:\n\t\t// two alternatives, use the maximum\n\t\tl = nfa_max_width(state->out, depth + 1);\n\t\tr = nfa_max_width(state->out1, depth + 1);\n\t\tif (l < 0 || r < 0)\n\t\t    return -1;\n\t\treturn len + (l > r ? l : r);\n\n\t    case NFA_ANY:\n\t    case NFA_START_COLL:\n\t    case NFA_START_NEG_COLL:\n\t\t// matches some character, including composing chars\n\t\tif (enc_utf8)\n\t\t    len += MB_MAXBYTES;\n\t\telse if (has_mbyte)\n\t\t    len += 2;\n\t\telse\n\t\t    ++len;\n\t\tif (state->c != NFA_ANY)\n\t\t{\n\t\t    // skip over the characters\n\t\t    state = state->out1->out;\n\t\t    continue;\n\t\t}\n\t\tbreak;\n\n\t    case NFA_DIGIT:\n\t    case NFA_WHITE:\n\t    case NFA_HEX:\n\t    case NFA_OCTAL:\n\t\t// ascii\n\t\t++len;\n\t\tbreak;\n\n\t    case NFA_IDENT:\n\t    case NFA_SIDENT:\n\t    case NFA_KWORD:\n\t    case NFA_SKWORD:\n\t    case NFA_FNAME:\n\t    case NFA_SFNAME:\n\t    case NFA_PRINT:\n\t    case NFA_SPRINT:\n\t    case NFA_NWHITE:\n\t    case NFA_NDIGIT:\n\t    case NFA_NHEX:\n\t    case NFA_NOCTAL:\n\t    case NFA_WORD:\n\t    case NFA_NWORD:\n\t    case NFA_HEAD:\n\t    case NFA_NHEAD:\n\t    case NFA_ALPHA:\n\t    case NFA_NALPHA:\n\t    case NFA_LOWER:\n\t    case NFA_NLOWER:\n\t    case NFA_UPPER:\n\t    case NFA_NUPPER:\n\t    case NFA_LOWER_IC:\n\t    case NFA_NLOWER_IC:\n\t    case NFA_UPPER_IC:\n\t    case NFA_NUPPER_IC:\n\t    case NFA_ANY_COMPOSING:\n\t\t// possibly non-ascii\n\t\tif (has_mbyte)\n\t\t    len += 3;\n\t\telse\n\t\t    ++len;\n\t\tbreak;\n\n\t    case NFA_START_INVISIBLE:\n\t    case NFA_START_INVISIBLE_NEG:\n\t    case NFA_START_INVISIBLE_BEFORE:\n\t    case NFA_START_INVISIBLE_BEFORE_NEG:\n\t\t// zero-width, out1 points to the END state\n\t\tstate = state->out1->out;\n\t\tcontinue;\n\n\t    case NFA_BACKREF1:\n\t    case NFA_BACKREF2:\n\t    case NFA_BACKREF3:\n\t    case NFA_BACKREF4:\n\t    case NFA_BACKREF5:\n\t    case NFA_BACKREF6:\n\t    case NFA_BACKREF7:\n\t    case NFA_BACKREF8:\n\t    case NFA_BACKREF9:\n#ifdef FEAT_SYN_HL\n\t    case NFA_ZREF1:\n\t    case NFA_ZREF2:\n\t    case NFA_ZREF3:\n\t    case NFA_ZREF4:\n\t    case NFA_ZREF5:\n\t    case NFA_ZREF6:\n\t    case NFA_ZREF7:\n\t    case NFA_ZREF8:\n\t    case NFA_ZREF9:\n#endif\n\t    case NFA_NEWL:\n\t    case NFA_SKIP:\n\t\t// unknown width\n\t\treturn -1;\n\n\t    case NFA_BOL:\n\t    case NFA_EOL:\n\t    case NFA_BOF:\n\t    case NFA_EOF:\n\t    case NFA_BOW:\n\t    case NFA_EOW:\n\t    case NFA_MOPEN:\n\t    case NFA_MOPEN1:\n\t    case NFA_MOPEN2:\n\t    case NFA_MOPEN3:\n\t    case NFA_MOPEN4:\n\t    case NFA_MOPEN5:\n\t    case NFA_MOPEN6:\n\t    case NFA_MOPEN7:\n\t    case NFA_MOPEN8:\n\t    case NFA_MOPEN9:\n#ifdef FEAT_SYN_HL\n\t    case NFA_ZOPEN:\n\t    case NFA_ZOPEN1:\n\t    case NFA_ZOPEN2:\n\t    case NFA_ZOPEN3:\n\t    case NFA_ZOPEN4:\n\t    case NFA_ZOPEN5:\n\t    case NFA_ZOPEN6:\n\t    case NFA_ZOPEN7:\n\t    case NFA_ZOPEN8:\n\t    case NFA_ZOPEN9:\n\t    case NFA_ZCLOSE:\n\t    case NFA_ZCLOSE1:\n\t    case NFA_ZCLOSE2:\n\t    case NFA_ZCLOSE3:\n\t    case NFA_ZCLOSE4:\n\t    case NFA_ZCLOSE5:\n\t    case NFA_ZCLOSE6:\n\t    case NFA_ZCLOSE7:\n\t    case NFA_ZCLOSE8:\n\t    case NFA_ZCLOSE9:\n#endif\n\t    case NFA_MCLOSE:\n\t    case NFA_MCLOSE1:\n\t    case NFA_MCLOSE2:\n\t    case NFA_MCLOSE3:\n\t    case NFA_MCLOSE4:\n\t    case NFA_MCLOSE5:\n\t    case NFA_MCLOSE6:\n\t    case NFA_MCLOSE7:\n\t    case NFA_MCLOSE8:\n\t    case NFA_MCLOSE9:\n\t    case NFA_NOPEN:\n\t    case NFA_NCLOSE:\n\n\t    case NFA_LNUM_GT:\n\t    case NFA_LNUM_LT:\n\t    case NFA_COL_GT:\n\t    case NFA_COL_LT:\n\t    case NFA_VCOL_GT:\n\t    case NFA_VCOL_LT:\n\t    case NFA_MARK_GT:\n\t    case NFA_MARK_LT:\n\t    case NFA_VISUAL:\n\t    case NFA_LNUM:\n\t    case NFA_CURSOR:\n\t    case NFA_COL:\n\t    case NFA_VCOL:\n\t    case NFA_MARK:\n\n\t    case NFA_ZSTART:\n\t    case NFA_ZEND:\n\t    case NFA_OPT_CHARS:\n\t    case NFA_EMPTY:\n\t    case NFA_START_PATTERN:\n\t    case NFA_END_PATTERN:\n\t    case NFA_COMPOSING:\n\t    case NFA_END_COMPOSING:\n\t\t// zero-width\n\t\tbreak;\n\n\t    default:\n\t\tif (state->c < 0)\n\t\t    // don't know what this is\n\t\t    return -1;\n\t\t// normal character\n\t\tlen += MB_CHAR2LEN(state->c);\n\t\tbreak;\n\t}\n\n\t// normal way to continue\n\tstate = state->out;\n    }\n\n    // unrecognized, \"cannot happen\"\n    return -1;\n}\n\n/*\n * Convert a postfix form into its equivalent NFA.\n * Return the NFA start state on success, NULL otherwise.\n */\n    static nfa_state_T *\npost2nfa(int *postfix, int *end, int nfa_calc_size)\n{\n    int\t\t*p;\n    int\t\tmopen;\n    int\t\tmclose;\n    Frag_T\t*stack = NULL;\n    Frag_T\t*stackp = NULL;\n    Frag_T\t*stack_end = NULL;\n    Frag_T\te1;\n    Frag_T\te2;\n    Frag_T\te;\n    nfa_state_T\t*s;\n    nfa_state_T\t*s1;\n    nfa_state_T\t*matchstate;\n    nfa_state_T\t*ret = NULL;\n\n    if (postfix == NULL)\n\treturn NULL;\n\n#define PUSH(s)\t    st_push((s), &stackp, stack_end)\n#define POP()\t    st_pop(&stackp, stack);\t\t\\\n\t\t    if (stackp < stack)\t\t\t\\\n\t\t    {\t\t\t\t\t\\\n\t\t\tst_error(postfix, end, p);\t\\\n\t\t\tvim_free(stack);\t\t\\\n\t\t\treturn NULL;\t\t\t\\\n\t\t    }\n\n    if (nfa_calc_size == FALSE)\n    {\n\t// Allocate space for the stack. Max states on the stack: \"nstate\".\n\tstack = ALLOC_MULT(Frag_T, nstate + 1);\n\tif (stack == NULL)\n\t    return NULL;\n\tstackp = stack;\n\tstack_end = stack + (nstate + 1);\n    }\n\n    for (p = postfix; p < end; ++p)\n    {\n\tswitch (*p)\n\t{\n\tcase NFA_CONCAT:\n\t    // Concatenation.\n\t    // Pay attention: this operator does not exist in the r.e. itself\n\t    // (it is implicit, really).  It is added when r.e. is translated\n\t    // to postfix form in re2post().\n\t    if (nfa_calc_size == TRUE)\n\t    {\n\t\t// nstate += 0;\n\t\tbreak;\n\t    }\n\t    e2 = POP();\n\t    e1 = POP();\n\t    patch(e1.out, e2.start);\n\t    PUSH(frag(e1.start, e2.out));\n\t    break;\n\n\tcase NFA_OR:\n\t    // Alternation\n\t    if (nfa_calc_size == TRUE)\n\t    {\n\t\tnstate++;\n\t\tbreak;\n\t    }\n\t    e2 = POP();\n\t    e1 = POP();\n\t    s = alloc_state(NFA_SPLIT, e1.start, e2.start);\n\t    if (s == NULL)\n\t\tgoto theend;\n\t    PUSH(frag(s, append(e1.out, e2.out)));\n\t    break;\n\n\tcase NFA_STAR:\n\t    // Zero or more, prefer more\n\t    if (nfa_calc_size == TRUE)\n\t    {\n\t\tnstate++;\n\t\tbreak;\n\t    }\n\t    e = POP();\n\t    s = alloc_state(NFA_SPLIT, e.start, NULL);\n\t    if (s == NULL)\n\t\tgoto theend;\n\t    patch(e.out, s);\n\t    PUSH(frag(s, list1(&s->out1)));\n\t    break;\n\n\tcase NFA_STAR_NONGREEDY:\n\t    // Zero or more, prefer zero\n\t    if (nfa_calc_size == TRUE)\n\t    {\n\t\tnstate++;\n\t\tbreak;\n\t    }\n\t    e = POP();\n\t    s = alloc_state(NFA_SPLIT, NULL, e.start);\n\t    if (s == NULL)\n\t\tgoto theend;\n\t    patch(e.out, s);\n\t    PUSH(frag(s, list1(&s->out)));\n\t    break;\n\n\tcase NFA_QUEST:\n\t    // one or zero atoms=> greedy match\n\t    if (nfa_calc_size == TRUE)\n\t    {\n\t\tnstate++;\n\t\tbreak;\n\t    }\n\t    e = POP();\n\t    s = alloc_state(NFA_SPLIT, e.start, NULL);\n\t    if (s == NULL)\n\t\tgoto theend;\n\t    PUSH(frag(s, append(e.out, list1(&s->out1))));\n\t    break;\n\n\tcase NFA_QUEST_NONGREEDY:\n\t    // zero or one atoms => non-greedy match\n\t    if (nfa_calc_size == TRUE)\n\t    {\n\t\tnstate++;\n\t\tbreak;\n\t    }\n\t    e = POP();\n\t    s = alloc_state(NFA_SPLIT, NULL, e.start);\n\t    if (s == NULL)\n\t\tgoto theend;\n\t    PUSH(frag(s, append(e.out, list1(&s->out))));\n\t    break;\n\n\tcase NFA_END_COLL:\n\tcase NFA_END_NEG_COLL:\n\t    // On the stack is the sequence starting with NFA_START_COLL or\n\t    // NFA_START_NEG_COLL and all possible characters. Patch it to\n\t    // add the output to the start.\n\t    if (nfa_calc_size == TRUE)\n\t    {\n\t\tnstate++;\n\t\tbreak;\n\t    }\n\t    e = POP();\n\t    s = alloc_state(NFA_END_COLL, NULL, NULL);\n\t    if (s == NULL)\n\t\tgoto theend;\n\t    patch(e.out, s);\n\t    e.start->out1 = s;\n\t    PUSH(frag(e.start, list1(&s->out)));\n\t    break;\n\n\tcase NFA_RANGE:\n\t    // Before this are two characters, the low and high end of a\n\t    // range.  Turn them into two states with MIN and MAX.\n\t    if (nfa_calc_size == TRUE)\n\t    {\n\t\t// nstate += 0;\n\t\tbreak;\n\t    }\n\t    e2 = POP();\n\t    e1 = POP();\n\t    e2.start->val = e2.start->c;\n\t    e2.start->c = NFA_RANGE_MAX;\n\t    e1.start->val = e1.start->c;\n\t    e1.start->c = NFA_RANGE_MIN;\n\t    patch(e1.out, e2.start);\n\t    PUSH(frag(e1.start, e2.out));\n\t    break;\n\n\tcase NFA_EMPTY:\n\t    // 0-length, used in a repetition with max/min count of 0\n\t    if (nfa_calc_size == TRUE)\n\t    {\n\t\tnstate++;\n\t\tbreak;\n\t    }\n\t    s = alloc_state(NFA_EMPTY, NULL, NULL);\n\t    if (s == NULL)\n\t\tgoto theend;\n\t    PUSH(frag(s, list1(&s->out)));\n\t    break;\n\n\tcase NFA_OPT_CHARS:\n\t  {\n\t    int    n;\n\n\t    // \\%[abc] implemented as:\n\t    //    NFA_SPLIT\n\t    //    +-CHAR(a)\n\t    //    | +-NFA_SPLIT\n\t    //    |   +-CHAR(b)\n\t    //    |   | +-NFA_SPLIT\n\t    //    |   |   +-CHAR(c)\n\t    //    |   |   | +-next\n\t    //    |   |   +- next\n\t    //    |   +- next\n\t    //    +- next\n\t    n = *++p; // get number of characters\n\t    if (nfa_calc_size == TRUE)\n\t    {\n\t\tnstate += n;\n\t\tbreak;\n\t    }\n\t    s = NULL; // avoid compiler warning\n\t    e1.out = NULL; // stores list with out1's\n\t    s1 = NULL; // previous NFA_SPLIT to connect to\n\t    while (n-- > 0)\n\t    {\n\t\te = POP(); // get character\n\t\ts = alloc_state(NFA_SPLIT, e.start, NULL);\n\t\tif (s == NULL)\n\t\t    goto theend;\n\t\tif (e1.out == NULL)\n\t\t    e1 = e;\n\t\tpatch(e.out, s1);\n\t\tappend(e1.out, list1(&s->out1));\n\t\ts1 = s;\n\t    }\n\t    PUSH(frag(s, e1.out));\n\t    break;\n\t  }\n\n\tcase NFA_PREV_ATOM_NO_WIDTH:\n\tcase NFA_PREV_ATOM_NO_WIDTH_NEG:\n\tcase NFA_PREV_ATOM_JUST_BEFORE:\n\tcase NFA_PREV_ATOM_JUST_BEFORE_NEG:\n\tcase NFA_PREV_ATOM_LIKE_PATTERN:\n\t  {\n\t    int before = (*p == NFA_PREV_ATOM_JUST_BEFORE\n\t\t\t\t      || *p == NFA_PREV_ATOM_JUST_BEFORE_NEG);\n\t    int pattern = (*p == NFA_PREV_ATOM_LIKE_PATTERN);\n\t    int start_state;\n\t    int end_state;\n\t    int n = 0;\n\t    nfa_state_T *zend;\n\t    nfa_state_T *skip;\n\n\t    switch (*p)\n\t    {\n\t\tcase NFA_PREV_ATOM_NO_WIDTH:\n\t\t    start_state = NFA_START_INVISIBLE;\n\t\t    end_state = NFA_END_INVISIBLE;\n\t\t    break;\n\t\tcase NFA_PREV_ATOM_NO_WIDTH_NEG:\n\t\t    start_state = NFA_START_INVISIBLE_NEG;\n\t\t    end_state = NFA_END_INVISIBLE_NEG;\n\t\t    break;\n\t\tcase NFA_PREV_ATOM_JUST_BEFORE:\n\t\t    start_state = NFA_START_INVISIBLE_BEFORE;\n\t\t    end_state = NFA_END_INVISIBLE;\n\t\t    break;\n\t\tcase NFA_PREV_ATOM_JUST_BEFORE_NEG:\n\t\t    start_state = NFA_START_INVISIBLE_BEFORE_NEG;\n\t\t    end_state = NFA_END_INVISIBLE_NEG;\n\t\t    break;\n\t\tdefault: // NFA_PREV_ATOM_LIKE_PATTERN:\n\t\t    start_state = NFA_START_PATTERN;\n\t\t    end_state = NFA_END_PATTERN;\n\t\t    break;\n\t    }\n\n\t    if (before)\n\t\tn = *++p; // get the count\n\n\t    // The \\@= operator: match the preceding atom with zero width.\n\t    // The \\@! operator: no match for the preceding atom.\n\t    // The \\@<= operator: match for the preceding atom.\n\t    // The \\@<! operator: no match for the preceding atom.\n\t    // Surrounds the preceding atom with START_INVISIBLE and\n\t    // END_INVISIBLE, similarly to MOPEN.\n\n\t    if (nfa_calc_size == TRUE)\n\t    {\n\t\tnstate += pattern ? 4 : 2;\n\t\tbreak;\n\t    }\n\t    e = POP();\n\t    s1 = alloc_state(end_state, NULL, NULL);\n\t    if (s1 == NULL)\n\t\tgoto theend;\n\n\t    s = alloc_state(start_state, e.start, s1);\n\t    if (s == NULL)\n\t\tgoto theend;\n\t    if (pattern)\n\t    {\n\t\t// NFA_ZEND -> NFA_END_PATTERN -> NFA_SKIP -> what follows.\n\t\tskip = alloc_state(NFA_SKIP, NULL, NULL);\n\t\tif (skip == NULL)\n\t\t    goto theend;\n\t\tzend = alloc_state(NFA_ZEND, s1, NULL);\n\t\tif (zend == NULL)\n\t\t    goto theend;\n\t\ts1->out= skip;\n\t\tpatch(e.out, zend);\n\t\tPUSH(frag(s, list1(&skip->out)));\n\t    }\n\t    else\n\t    {\n\t\tpatch(e.out, s1);\n\t\tPUSH(frag(s, list1(&s1->out)));\n\t\tif (before)\n\t\t{\n\t\t    if (n <= 0)\n\t\t\t// See if we can guess the maximum width, it avoids a\n\t\t\t// lot of pointless tries.\n\t\t\tn = nfa_max_width(e.start, 0);\n\t\t    s->val = n; // store the count\n\t\t}\n\t    }\n\t    break;\n\t  }\n\n\tcase NFA_COMPOSING:\t// char with composing char\n#if 0\n\t    // TODO\n\t    if (regflags & RF_ICOMBINE)\n\t    {\n\t\t// use the base character only\n\t    }\n#endif\n\t    // FALLTHROUGH\n\n\tcase NFA_MOPEN:\t// \\( \\) Submatch\n\tcase NFA_MOPEN1:\n\tcase NFA_MOPEN2:\n\tcase NFA_MOPEN3:\n\tcase NFA_MOPEN4:\n\tcase NFA_MOPEN5:\n\tcase NFA_MOPEN6:\n\tcase NFA_MOPEN7:\n\tcase NFA_MOPEN8:\n\tcase NFA_MOPEN9:\n#ifdef FEAT_SYN_HL\n\tcase NFA_ZOPEN:\t// \\z( \\) Submatch\n\tcase NFA_ZOPEN1:\n\tcase NFA_ZOPEN2:\n\tcase NFA_ZOPEN3:\n\tcase NFA_ZOPEN4:\n\tcase NFA_ZOPEN5:\n\tcase NFA_ZOPEN6:\n\tcase NFA_ZOPEN7:\n\tcase NFA_ZOPEN8:\n\tcase NFA_ZOPEN9:\n#endif\n\tcase NFA_NOPEN:\t// \\%( \\) \"Invisible Submatch\"\n\t    if (nfa_calc_size == TRUE)\n\t    {\n\t\tnstate += 2;\n\t\tbreak;\n\t    }\n\n\t    mopen = *p;\n\t    switch (*p)\n\t    {\n\t\tcase NFA_NOPEN: mclose = NFA_NCLOSE; break;\n#ifdef FEAT_SYN_HL\n\t\tcase NFA_ZOPEN: mclose = NFA_ZCLOSE; break;\n\t\tcase NFA_ZOPEN1: mclose = NFA_ZCLOSE1; break;\n\t\tcase NFA_ZOPEN2: mclose = NFA_ZCLOSE2; break;\n\t\tcase NFA_ZOPEN3: mclose = NFA_ZCLOSE3; break;\n\t\tcase NFA_ZOPEN4: mclose = NFA_ZCLOSE4; break;\n\t\tcase NFA_ZOPEN5: mclose = NFA_ZCLOSE5; break;\n\t\tcase NFA_ZOPEN6: mclose = NFA_ZCLOSE6; break;\n\t\tcase NFA_ZOPEN7: mclose = NFA_ZCLOSE7; break;\n\t\tcase NFA_ZOPEN8: mclose = NFA_ZCLOSE8; break;\n\t\tcase NFA_ZOPEN9: mclose = NFA_ZCLOSE9; break;\n#endif\n\t\tcase NFA_COMPOSING: mclose = NFA_END_COMPOSING; break;\n\t\tdefault:\n\t\t    // NFA_MOPEN, NFA_MOPEN1 .. NFA_MOPEN9\n\t\t    mclose = *p + NSUBEXP;\n\t\t    break;\n\t    }\n\n\t    // Allow \"NFA_MOPEN\" as a valid postfix representation for\n\t    // the empty regexp \"\". In this case, the NFA will be\n\t    // NFA_MOPEN -> NFA_MCLOSE. Note that this also allows\n\t    // empty groups of parenthesis, and empty mbyte chars\n\t    if (stackp == stack)\n\t    {\n\t\ts = alloc_state(mopen, NULL, NULL);\n\t\tif (s == NULL)\n\t\t    goto theend;\n\t\ts1 = alloc_state(mclose, NULL, NULL);\n\t\tif (s1 == NULL)\n\t\t    goto theend;\n\t\tpatch(list1(&s->out), s1);\n\t\tPUSH(frag(s, list1(&s1->out)));\n\t\tbreak;\n\t    }\n\n\t    // At least one node was emitted before NFA_MOPEN, so\n\t    // at least one node will be between NFA_MOPEN and NFA_MCLOSE\n\t    e = POP();\n\t    s = alloc_state(mopen, e.start, NULL);   // `('\n\t    if (s == NULL)\n\t\tgoto theend;\n\n\t    s1 = alloc_state(mclose, NULL, NULL);   // `)'\n\t    if (s1 == NULL)\n\t\tgoto theend;\n\t    patch(e.out, s1);\n\n\t    if (mopen == NFA_COMPOSING)\n\t\t// COMPOSING->out1 = END_COMPOSING\n\t\tpatch(list1(&s->out1), s1);\n\n\t    PUSH(frag(s, list1(&s1->out)));\n\t    break;\n\n\tcase NFA_BACKREF1:\n\tcase NFA_BACKREF2:\n\tcase NFA_BACKREF3:\n\tcase NFA_BACKREF4:\n\tcase NFA_BACKREF5:\n\tcase NFA_BACKREF6:\n\tcase NFA_BACKREF7:\n\tcase NFA_BACKREF8:\n\tcase NFA_BACKREF9:\n#ifdef FEAT_SYN_HL\n\tcase NFA_ZREF1:\n\tcase NFA_ZREF2:\n\tcase NFA_ZREF3:\n\tcase NFA_ZREF4:\n\tcase NFA_ZREF5:\n\tcase NFA_ZREF6:\n\tcase NFA_ZREF7:\n\tcase NFA_ZREF8:\n\tcase NFA_ZREF9:\n#endif\n\t    if (nfa_calc_size == TRUE)\n\t    {\n\t\tnstate += 2;\n\t\tbreak;\n\t    }\n\t    s = alloc_state(*p, NULL, NULL);\n\t    if (s == NULL)\n\t\tgoto theend;\n\t    s1 = alloc_state(NFA_SKIP, NULL, NULL);\n\t    if (s1 == NULL)\n\t\tgoto theend;\n\t    patch(list1(&s->out), s1);\n\t    PUSH(frag(s, list1(&s1->out)));\n\t    break;\n\n\tcase NFA_LNUM:\n\tcase NFA_LNUM_GT:\n\tcase NFA_LNUM_LT:\n\tcase NFA_VCOL:\n\tcase NFA_VCOL_GT:\n\tcase NFA_VCOL_LT:\n\tcase NFA_COL:\n\tcase NFA_COL_GT:\n\tcase NFA_COL_LT:\n\tcase NFA_MARK:\n\tcase NFA_MARK_GT:\n\tcase NFA_MARK_LT:\n\t  {\n\t    int n = *++p; // lnum, col or mark name\n\n\t    if (nfa_calc_size == TRUE)\n\t    {\n\t\tnstate += 1;\n\t\tbreak;\n\t    }\n\t    s = alloc_state(p[-1], NULL, NULL);\n\t    if (s == NULL)\n\t\tgoto theend;\n\t    s->val = n;\n\t    PUSH(frag(s, list1(&s->out)));\n\t    break;\n\t  }\n\n\tcase NFA_ZSTART:\n\tcase NFA_ZEND:\n\tdefault:\n\t    // Operands\n\t    if (nfa_calc_size == TRUE)\n\t    {\n\t\tnstate++;\n\t\tbreak;\n\t    }\n\t    s = alloc_state(*p, NULL, NULL);\n\t    if (s == NULL)\n\t\tgoto theend;\n\t    PUSH(frag(s, list1(&s->out)));\n\t    break;\n\n\t} // switch(*p)\n\n    } // for(p = postfix; *p; ++p)\n\n    if (nfa_calc_size == TRUE)\n    {\n\tnstate++;\n\tgoto theend;\t// Return value when counting size is ignored anyway\n    }\n\n    e = POP();\n    if (stackp != stack)\n    {\n\tvim_free(stack);\n\tEMSG_RET_NULL(_(\"E875: (NFA regexp) (While converting from postfix to NFA), too many states left on stack\"));\n    }\n\n    if (istate >= nstate)\n    {\n\tvim_free(stack);\n\tEMSG_RET_NULL(_(\"E876: (NFA regexp) Not enough space to store the whole NFA \"));\n    }\n\n    matchstate = &state_ptr[istate++]; // the match state\n    matchstate->c = NFA_MATCH;\n    matchstate->out = matchstate->out1 = NULL;\n    matchstate->id = 0;\n\n    patch(e.out, matchstate);\n    ret = e.start;\n\ntheend:\n    vim_free(stack);\n    return ret;\n\n#undef POP1\n#undef PUSH1\n#undef POP2\n#undef PUSH2\n#undef POP\n#undef PUSH\n}\n\n/*\n * After building the NFA program, inspect it to add optimization hints.\n */\n    static void\nnfa_postprocess(nfa_regprog_T *prog)\n{\n    int i;\n    int c;\n\n    for (i = 0; i < prog->nstate; ++i)\n    {\n\tc = prog->state[i].c;\n\tif (c == NFA_START_INVISIBLE\n\t\t|| c == NFA_START_INVISIBLE_NEG\n\t\t|| c == NFA_START_INVISIBLE_BEFORE\n\t\t|| c == NFA_START_INVISIBLE_BEFORE_NEG)\n\t{\n\t    int directly;\n\n\t    // Do it directly when what follows is possibly the end of the\n\t    // match.\n\t    if (match_follows(prog->state[i].out1->out, 0))\n\t\tdirectly = TRUE;\n\t    else\n\t    {\n\t\tint ch_invisible = failure_chance(prog->state[i].out, 0);\n\t\tint ch_follows = failure_chance(prog->state[i].out1->out, 0);\n\n\t\t// Postpone when the invisible match is expensive or has a\n\t\t// lower chance of failing.\n\t\tif (c == NFA_START_INVISIBLE_BEFORE\n\t\t     || c == NFA_START_INVISIBLE_BEFORE_NEG)\n\t\t{\n\t\t    // \"before\" matches are very expensive when\n\t\t    // unbounded, always prefer what follows then,\n\t\t    // unless what follows will always match.\n\t\t    // Otherwise strongly prefer what follows.\n\t\t    if (prog->state[i].val <= 0 && ch_follows > 0)\n\t\t\tdirectly = FALSE;\n\t\t    else\n\t\t\tdirectly = ch_follows * 10 < ch_invisible;\n\t\t}\n\t\telse\n\t\t{\n\t\t    // normal invisible, first do the one with the\n\t\t    // highest failure chance\n\t\t    directly = ch_follows < ch_invisible;\n\t\t}\n\t    }\n\t    if (directly)\n\t\t// switch to the _FIRST state\n\t\t++prog->state[i].c;\n\t}\n    }\n}\n\n/////////////////////////////////////////////////////////////////\n// NFA execution code.\n/////////////////////////////////////////////////////////////////\n\ntypedef struct\n{\n    int\t    in_use; // number of subexpr with useful info\n\n    // When REG_MULTI is TRUE list.multi is used, otherwise list.line.\n    union\n    {\n\tstruct multipos\n\t{\n\t    linenr_T\tstart_lnum;\n\t    linenr_T\tend_lnum;\n\t    colnr_T\tstart_col;\n\t    colnr_T\tend_col;\n\t} multi[NSUBEXP];\n\tstruct linepos\n\t{\n\t    char_u\t*start;\n\t    char_u\t*end;\n\t} line[NSUBEXP];\n    } list;\n} regsub_T;\n\ntypedef struct\n{\n    regsub_T\tnorm; // \\( .. \\) matches\n#ifdef FEAT_SYN_HL\n    regsub_T\tsynt; // \\z( .. \\) matches\n#endif\n} regsubs_T;\n\n// nfa_pim_T stores a Postponed Invisible Match.\ntypedef struct nfa_pim_S nfa_pim_T;\nstruct nfa_pim_S\n{\n    int\t\tresult;\t\t// NFA_PIM_*, see below\n    nfa_state_T\t*state;\t\t// the invisible match start state\n    regsubs_T\tsubs;\t\t// submatch info, only party used\n    union\n    {\n\tlpos_T\tpos;\n\tchar_u\t*ptr;\n    } end;\t\t\t// where the match must end\n};\n\n// Values for done in nfa_pim_T.\n#define NFA_PIM_UNUSED   0\t// pim not used\n#define NFA_PIM_TODO     1\t// pim not done yet\n#define NFA_PIM_MATCH    2\t// pim executed, matches\n#define NFA_PIM_NOMATCH  3\t// pim executed, no match\n\n\n// nfa_thread_T contains execution information of a NFA state\ntypedef struct\n{\n    nfa_state_T\t*state;\n    int\t\tcount;\n    nfa_pim_T\tpim;\t\t// if pim.result != NFA_PIM_UNUSED: postponed\n\t\t\t\t// invisible match\n    regsubs_T\tsubs;\t\t// submatch info, only party used\n} nfa_thread_T;\n\n// nfa_list_T contains the alternative NFA execution states.\ntypedef struct\n{\n    nfa_thread_T    *t;\t\t// allocated array of states\n    int\t\t    n;\t\t// nr of states currently in \"t\"\n    int\t\t    len;\t// max nr of states in \"t\"\n    int\t\t    id;\t\t// ID of the list\n    int\t\t    has_pim;\t// TRUE when any state has a PIM\n} nfa_list_T;\n\n#ifdef ENABLE_LOG\nstatic void log_subexpr(regsub_T *sub);\n\n    static void\nlog_subsexpr(regsubs_T *subs)\n{\n    log_subexpr(&subs->norm);\n# ifdef FEAT_SYN_HL\n    if (rex.nfa_has_zsubexpr)\n\tlog_subexpr(&subs->synt);\n# endif\n}\n\n    static void\nlog_subexpr(regsub_T *sub)\n{\n    int j;\n\n    for (j = 0; j < sub->in_use; j++)\n\tif (REG_MULTI)\n\t    fprintf(log_fd, \"*** group %d, start: c=%d, l=%d, end: c=%d, l=%d\\n\",\n\t\t    j,\n\t\t    sub->list.multi[j].start_col,\n\t\t    (int)sub->list.multi[j].start_lnum,\n\t\t    sub->list.multi[j].end_col,\n\t\t    (int)sub->list.multi[j].end_lnum);\n\telse\n\t{\n\t    char *s = (char *)sub->list.line[j].start;\n\t    char *e = (char *)sub->list.line[j].end;\n\n\t    fprintf(log_fd, \"*** group %d, start: \\\"%s\\\", end: \\\"%s\\\"\\n\",\n\t\t    j,\n\t\t    s == NULL ? \"NULL\" : s,\n\t\t    e == NULL ? \"NULL\" : e);\n\t}\n}\n\n    static char *\npim_info(nfa_pim_T *pim)\n{\n    static char buf[30];\n\n    if (pim == NULL || pim->result == NFA_PIM_UNUSED)\n\tbuf[0] = NUL;\n    else\n    {\n\tsprintf(buf, \" PIM col %d\", REG_MULTI ? (int)pim->end.pos.col\n\t\t: (int)(pim->end.ptr - rex.input));\n    }\n    return buf;\n}\n\n#endif\n\n// Used during execution: whether a match has been found.\nstatic int\t    nfa_match;\n#ifdef FEAT_RELTIME\nstatic proftime_T  *nfa_time_limit;\nstatic int\t   *nfa_timed_out;\nstatic int\t    nfa_time_count;\n#endif\n\nstatic void copy_sub(regsub_T *to, regsub_T *from);\nstatic int pim_equal(nfa_pim_T *one, nfa_pim_T *two);\n\n/*\n * Copy postponed invisible match info from \"from\" to \"to\".\n */\n    static void\ncopy_pim(nfa_pim_T *to, nfa_pim_T *from)\n{\n    to->result = from->result;\n    to->state = from->state;\n    copy_sub(&to->subs.norm, &from->subs.norm);\n#ifdef FEAT_SYN_HL\n    if (rex.nfa_has_zsubexpr)\n\tcopy_sub(&to->subs.synt, &from->subs.synt);\n#endif\n    to->end = from->end;\n}\n\n    static void\nclear_sub(regsub_T *sub)\n{\n    if (REG_MULTI)\n\t// Use 0xff to set lnum to -1\n\tvim_memset(sub->list.multi, 0xff,\n\t\t\t\t  sizeof(struct multipos) * rex.nfa_nsubexpr);\n    else\n\tvim_memset(sub->list.line, 0,\n\t\t\t\t   sizeof(struct linepos) * rex.nfa_nsubexpr);\n    sub->in_use = 0;\n}\n\n/*\n * Copy the submatches from \"from\" to \"to\".\n */\n    static void\ncopy_sub(regsub_T *to, regsub_T *from)\n{\n    to->in_use = from->in_use;\n    if (from->in_use > 0)\n    {\n\t// Copy the match start and end positions.\n\tif (REG_MULTI)\n\t    mch_memmove(&to->list.multi[0],\n\t\t\t&from->list.multi[0],\n\t\t\tsizeof(struct multipos) * from->in_use);\n\telse\n\t    mch_memmove(&to->list.line[0],\n\t\t\t&from->list.line[0],\n\t\t\tsizeof(struct linepos) * from->in_use);\n    }\n}\n\n/*\n * Like copy_sub() but exclude the main match.\n */\n    static void\ncopy_sub_off(regsub_T *to, regsub_T *from)\n{\n    if (to->in_use < from->in_use)\n\tto->in_use = from->in_use;\n    if (from->in_use > 1)\n    {\n\t// Copy the match start and end positions.\n\tif (REG_MULTI)\n\t    mch_memmove(&to->list.multi[1],\n\t\t\t&from->list.multi[1],\n\t\t\tsizeof(struct multipos) * (from->in_use - 1));\n\telse\n\t    mch_memmove(&to->list.line[1],\n\t\t\t&from->list.line[1],\n\t\t\tsizeof(struct linepos) * (from->in_use - 1));\n    }\n}\n\n/*\n * Like copy_sub() but only do the end of the main match if \\ze is present.\n */\n    static void\ncopy_ze_off(regsub_T *to, regsub_T *from)\n{\n    if (rex.nfa_has_zend)\n    {\n\tif (REG_MULTI)\n\t{\n\t    if (from->list.multi[0].end_lnum >= 0)\n\t    {\n\t\tto->list.multi[0].end_lnum = from->list.multi[0].end_lnum;\n\t\tto->list.multi[0].end_col = from->list.multi[0].end_col;\n\t    }\n\t}\n\telse\n\t{\n\t    if (from->list.line[0].end != NULL)\n\t\tto->list.line[0].end = from->list.line[0].end;\n\t}\n    }\n}\n\n/*\n * Return TRUE if \"sub1\" and \"sub2\" have the same start positions.\n * When using back-references also check the end position.\n */\n    static int\nsub_equal(regsub_T *sub1, regsub_T *sub2)\n{\n    int\t\ti;\n    int\t\ttodo;\n    linenr_T\ts1;\n    linenr_T\ts2;\n    char_u\t*sp1;\n    char_u\t*sp2;\n\n    todo = sub1->in_use > sub2->in_use ? sub1->in_use : sub2->in_use;\n    if (REG_MULTI)\n    {\n\tfor (i = 0; i < todo; ++i)\n\t{\n\t    if (i < sub1->in_use)\n\t\ts1 = sub1->list.multi[i].start_lnum;\n\t    else\n\t\ts1 = -1;\n\t    if (i < sub2->in_use)\n\t\ts2 = sub2->list.multi[i].start_lnum;\n\t    else\n\t\ts2 = -1;\n\t    if (s1 != s2)\n\t\treturn FALSE;\n\t    if (s1 != -1 && sub1->list.multi[i].start_col\n\t\t\t\t\t     != sub2->list.multi[i].start_col)\n\t\treturn FALSE;\n\n\t    if (rex.nfa_has_backref)\n\t    {\n\t\tif (i < sub1->in_use)\n\t\t    s1 = sub1->list.multi[i].end_lnum;\n\t\telse\n\t\t    s1 = -1;\n\t\tif (i < sub2->in_use)\n\t\t    s2 = sub2->list.multi[i].end_lnum;\n\t\telse\n\t\t    s2 = -1;\n\t\tif (s1 != s2)\n\t\t    return FALSE;\n\t\tif (s1 != -1 && sub1->list.multi[i].end_col\n\t\t\t\t\t       != sub2->list.multi[i].end_col)\n\t\treturn FALSE;\n\t    }\n\t}\n    }\n    else\n    {\n\tfor (i = 0; i < todo; ++i)\n\t{\n\t    if (i < sub1->in_use)\n\t\tsp1 = sub1->list.line[i].start;\n\t    else\n\t\tsp1 = NULL;\n\t    if (i < sub2->in_use)\n\t\tsp2 = sub2->list.line[i].start;\n\t    else\n\t\tsp2 = NULL;\n\t    if (sp1 != sp2)\n\t\treturn FALSE;\n\t    if (rex.nfa_has_backref)\n\t    {\n\t\tif (i < sub1->in_use)\n\t\t    sp1 = sub1->list.line[i].end;\n\t\telse\n\t\t    sp1 = NULL;\n\t\tif (i < sub2->in_use)\n\t\t    sp2 = sub2->list.line[i].end;\n\t\telse\n\t\t    sp2 = NULL;\n\t\tif (sp1 != sp2)\n\t\t    return FALSE;\n\t    }\n\t}\n    }\n\n    return TRUE;\n}\n\n#ifdef ENABLE_LOG\n    static void\nreport_state(char *action,\n\t     regsub_T *sub,\n\t     nfa_state_T *state,\n\t     int lid,\n\t     nfa_pim_T *pim)\n{\n    int col;\n\n    if (sub->in_use <= 0)\n\tcol = -1;\n    else if (REG_MULTI)\n\tcol = sub->list.multi[0].start_col;\n    else\n\tcol = (int)(sub->list.line[0].start - rex.line);\n    nfa_set_code(state->c);\n    fprintf(log_fd, \"> %s state %d to list %d. char %d: %s (start col %d)%s\\n\",\n\t    action, abs(state->id), lid, state->c, code, col,\n\t    pim_info(pim));\n}\n#endif\n\n/*\n * Return TRUE if the same state is already in list \"l\" with the same\n * positions as \"subs\".\n */\n    static int\nhas_state_with_pos(\n    nfa_list_T\t\t*l,\t// runtime state list\n    nfa_state_T\t\t*state,\t// state to update\n    regsubs_T\t\t*subs,\t// pointers to subexpressions\n    nfa_pim_T\t\t*pim)\t// postponed match or NULL\n{\n    nfa_thread_T\t*thread;\n    int\t\t\ti;\n\n    for (i = 0; i < l->n; ++i)\n    {\n\tthread = &l->t[i];\n\tif (thread->state->id == state->id\n\t\t&& sub_equal(&thread->subs.norm, &subs->norm)\n#ifdef FEAT_SYN_HL\n\t\t&& (!rex.nfa_has_zsubexpr\n\t\t\t\t|| sub_equal(&thread->subs.synt, &subs->synt))\n#endif\n\t\t&& pim_equal(&thread->pim, pim))\n\t    return TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Return TRUE if \"one\" and \"two\" are equal.  That includes when both are not\n * set.\n */\n    static int\npim_equal(nfa_pim_T *one, nfa_pim_T *two)\n{\n    int one_unused = (one == NULL || one->result == NFA_PIM_UNUSED);\n    int two_unused = (two == NULL || two->result == NFA_PIM_UNUSED);\n\n    if (one_unused)\n\t// one is unused: equal when two is also unused\n\treturn two_unused;\n    if (two_unused)\n\t// one is used and two is not: not equal\n\treturn FALSE;\n    // compare the state id\n    if (one->state->id != two->state->id)\n\treturn FALSE;\n    // compare the position\n    if (REG_MULTI)\n\treturn one->end.pos.lnum == two->end.pos.lnum\n\t    && one->end.pos.col == two->end.pos.col;\n    return one->end.ptr == two->end.ptr;\n}\n\n/*\n * Return TRUE if \"state\" leads to a NFA_MATCH without advancing the input.\n */\n    static int\nmatch_follows(nfa_state_T *startstate, int depth)\n{\n    nfa_state_T\t    *state = startstate;\n\n    // avoid too much recursion\n    if (depth > 10)\n\treturn FALSE;\n\n    while (state != NULL)\n    {\n\tswitch (state->c)\n\t{\n\t    case NFA_MATCH:\n\t    case NFA_MCLOSE:\n\t    case NFA_END_INVISIBLE:\n\t    case NFA_END_INVISIBLE_NEG:\n\t    case NFA_END_PATTERN:\n\t\treturn TRUE;\n\n\t    case NFA_SPLIT:\n\t\treturn match_follows(state->out, depth + 1)\n\t\t\t\t     || match_follows(state->out1, depth + 1);\n\n\t    case NFA_START_INVISIBLE:\n\t    case NFA_START_INVISIBLE_FIRST:\n\t    case NFA_START_INVISIBLE_BEFORE:\n\t    case NFA_START_INVISIBLE_BEFORE_FIRST:\n\t    case NFA_START_INVISIBLE_NEG:\n\t    case NFA_START_INVISIBLE_NEG_FIRST:\n\t    case NFA_START_INVISIBLE_BEFORE_NEG:\n\t    case NFA_START_INVISIBLE_BEFORE_NEG_FIRST:\n\t    case NFA_COMPOSING:\n\t\t// skip ahead to next state\n\t\tstate = state->out1->out;\n\t\tcontinue;\n\n\t    case NFA_ANY:\n\t    case NFA_ANY_COMPOSING:\n\t    case NFA_IDENT:\n\t    case NFA_SIDENT:\n\t    case NFA_KWORD:\n\t    case NFA_SKWORD:\n\t    case NFA_FNAME:\n\t    case NFA_SFNAME:\n\t    case NFA_PRINT:\n\t    case NFA_SPRINT:\n\t    case NFA_WHITE:\n\t    case NFA_NWHITE:\n\t    case NFA_DIGIT:\n\t    case NFA_NDIGIT:\n\t    case NFA_HEX:\n\t    case NFA_NHEX:\n\t    case NFA_OCTAL:\n\t    case NFA_NOCTAL:\n\t    case NFA_WORD:\n\t    case NFA_NWORD:\n\t    case NFA_HEAD:\n\t    case NFA_NHEAD:\n\t    case NFA_ALPHA:\n\t    case NFA_NALPHA:\n\t    case NFA_LOWER:\n\t    case NFA_NLOWER:\n\t    case NFA_UPPER:\n\t    case NFA_NUPPER:\n\t    case NFA_LOWER_IC:\n\t    case NFA_NLOWER_IC:\n\t    case NFA_UPPER_IC:\n\t    case NFA_NUPPER_IC:\n\t    case NFA_START_COLL:\n\t    case NFA_START_NEG_COLL:\n\t    case NFA_NEWL:\n\t\t// state will advance input\n\t\treturn FALSE;\n\n\t    default:\n\t\tif (state->c > 0)\n\t\t    // state will advance input\n\t\t    return FALSE;\n\n\t\t// Others: zero-width or possibly zero-width, might still find\n\t\t// a match at the same position, keep looking.\n\t\tbreak;\n\t}\n\tstate = state->out;\n    }\n    return FALSE;\n}\n\n\n/*\n * Return TRUE if \"state\" is already in list \"l\".\n */\n    static int\nstate_in_list(\n    nfa_list_T\t\t*l,\t// runtime state list\n    nfa_state_T\t\t*state,\t// state to update\n    regsubs_T\t\t*subs)\t// pointers to subexpressions\n{\n    if (state->lastlist[nfa_ll_index] == l->id)\n    {\n\tif (!rex.nfa_has_backref || has_state_with_pos(l, state, subs, NULL))\n\t    return TRUE;\n    }\n    return FALSE;\n}\n\n// Offset used for \"off\" by addstate_here().\n#define ADDSTATE_HERE_OFFSET 10\n\n/*\n * Add \"state\" and possibly what follows to state list \".\".\n * Returns \"subs_arg\", possibly copied into temp_subs.\n * Returns NULL when recursiveness is too deep.\n */\n    static regsubs_T *\naddstate(\n    nfa_list_T\t\t*l,\t    // runtime state list\n    nfa_state_T\t\t*state,\t    // state to update\n    regsubs_T\t\t*subs_arg,  // pointers to subexpressions\n    nfa_pim_T\t\t*pim,\t    // postponed look-behind match\n    int\t\t\toff_arg)    // byte offset, when -1 go to next line\n{\n    int\t\t\tsubidx;\n    int\t\t\toff = off_arg;\n    int\t\t\tadd_here = FALSE;\n    int\t\t\tlistindex = 0;\n    int\t\t\tk;\n    int\t\t\tfound = FALSE;\n    nfa_thread_T\t*thread;\n    struct multipos\tsave_multipos;\n    int\t\t\tsave_in_use;\n    char_u\t\t*save_ptr;\n    int\t\t\ti;\n    regsub_T\t\t*sub;\n    regsubs_T\t\t*subs = subs_arg;\n    static regsubs_T\ttemp_subs;\n#ifdef ENABLE_LOG\n    int\t\t\tdid_print = FALSE;\n#endif\n    static int\t\tdepth = 0;\n\n    // This function is called recursively.  When the depth is too much we run\n    // out of stack and crash, limit recursiveness here.\n    if (++depth >= 5000 || subs == NULL)\n    {\n\t--depth;\n\treturn NULL;\n    }\n\n    if (off_arg <= -ADDSTATE_HERE_OFFSET)\n    {\n\tadd_here = TRUE;\n\toff = 0;\n\tlistindex = -(off_arg + ADDSTATE_HERE_OFFSET);\n    }\n\n    switch (state->c)\n    {\n\tcase NFA_NCLOSE:\n\tcase NFA_MCLOSE:\n\tcase NFA_MCLOSE1:\n\tcase NFA_MCLOSE2:\n\tcase NFA_MCLOSE3:\n\tcase NFA_MCLOSE4:\n\tcase NFA_MCLOSE5:\n\tcase NFA_MCLOSE6:\n\tcase NFA_MCLOSE7:\n\tcase NFA_MCLOSE8:\n\tcase NFA_MCLOSE9:\n#ifdef FEAT_SYN_HL\n\tcase NFA_ZCLOSE:\n\tcase NFA_ZCLOSE1:\n\tcase NFA_ZCLOSE2:\n\tcase NFA_ZCLOSE3:\n\tcase NFA_ZCLOSE4:\n\tcase NFA_ZCLOSE5:\n\tcase NFA_ZCLOSE6:\n\tcase NFA_ZCLOSE7:\n\tcase NFA_ZCLOSE8:\n\tcase NFA_ZCLOSE9:\n#endif\n\tcase NFA_MOPEN:\n\tcase NFA_ZEND:\n\tcase NFA_SPLIT:\n\tcase NFA_EMPTY:\n\t    // These nodes are not added themselves but their \"out\" and/or\n\t    // \"out1\" may be added below.\n\t    break;\n\n\tcase NFA_BOL:\n\tcase NFA_BOF:\n\t    // \"^\" won't match past end-of-line, don't bother trying.\n\t    // Except when at the end of the line, or when we are going to the\n\t    // next line for a look-behind match.\n\t    if (rex.input > rex.line\n\t\t    && *rex.input != NUL\n\t\t    && (nfa_endp == NULL\n\t\t\t|| !REG_MULTI\n\t\t\t|| rex.lnum == nfa_endp->se_u.pos.lnum))\n\t\tgoto skip_add;\n\t    // FALLTHROUGH\n\n\tcase NFA_MOPEN1:\n\tcase NFA_MOPEN2:\n\tcase NFA_MOPEN3:\n\tcase NFA_MOPEN4:\n\tcase NFA_MOPEN5:\n\tcase NFA_MOPEN6:\n\tcase NFA_MOPEN7:\n\tcase NFA_MOPEN8:\n\tcase NFA_MOPEN9:\n#ifdef FEAT_SYN_HL\n\tcase NFA_ZOPEN:\n\tcase NFA_ZOPEN1:\n\tcase NFA_ZOPEN2:\n\tcase NFA_ZOPEN3:\n\tcase NFA_ZOPEN4:\n\tcase NFA_ZOPEN5:\n\tcase NFA_ZOPEN6:\n\tcase NFA_ZOPEN7:\n\tcase NFA_ZOPEN8:\n\tcase NFA_ZOPEN9:\n#endif\n\tcase NFA_NOPEN:\n\tcase NFA_ZSTART:\n\t    // These nodes need to be added so that we can bail out when it\n\t    // was added to this list before at the same position to avoid an\n\t    // endless loop for \"\\(\\)*\"\n\n\tdefault:\n\t    if (state->lastlist[nfa_ll_index] == l->id && state->c != NFA_SKIP)\n\t    {\n\t\t// This state is already in the list, don't add it again,\n\t\t// unless it is an MOPEN that is used for a backreference or\n\t\t// when there is a PIM. For NFA_MATCH check the position,\n\t\t// lower position is preferred.\n\t\tif (!rex.nfa_has_backref && pim == NULL && !l->has_pim\n\t\t\t\t\t\t     && state->c != NFA_MATCH)\n\t\t{\n\t\t    // When called from addstate_here() do insert before\n\t\t    // existing states.\n\t\t    if (add_here)\n\t\t    {\n\t\t\tfor (k = 0; k < l->n && k < listindex; ++k)\n\t\t\t    if (l->t[k].state->id == state->id)\n\t\t\t    {\n\t\t\t\tfound = TRUE;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t    }\n\t\t    if (!add_here || found)\n\t\t    {\nskip_add:\n#ifdef ENABLE_LOG\n\t\t\tnfa_set_code(state->c);\n\t\t\tfprintf(log_fd, \"> Not adding state %d to list %d. char %d: %s pim: %s has_pim: %d found: %d\\n\",\n\t\t\t    abs(state->id), l->id, state->c, code,\n\t\t\t    pim == NULL ? \"NULL\" : \"yes\", l->has_pim, found);\n#endif\n\t\t\t--depth;\n\t\t\treturn subs;\n\t\t    }\n\t\t}\n\n\t\t// Do not add the state again when it exists with the same\n\t\t// positions.\n\t\tif (has_state_with_pos(l, state, subs, pim))\n\t\t    goto skip_add;\n\t    }\n\n\t    // When there are backreferences or PIMs the number of states may\n\t    // be (a lot) bigger than anticipated.\n\t    if (l->n == l->len)\n\t    {\n\t\tint\t\tnewlen = l->len * 3 / 2 + 50;\n\t\tsize_t\t\tnewsize = newlen * sizeof(nfa_thread_T);\n\t\tnfa_thread_T\t*newt;\n\n\t\tif ((long)(newsize >> 10) >= p_mmp)\n\t\t{\n\t\t    emsg(_(e_maxmempat));\n\t\t    --depth;\n\t\t    return NULL;\n\t\t}\n\t\tif (subs != &temp_subs)\n\t\t{\n\t\t    // \"subs\" may point into the current array, need to make a\n\t\t    // copy before it becomes invalid.\n\t\t    copy_sub(&temp_subs.norm, &subs->norm);\n#ifdef FEAT_SYN_HL\n\t\t    if (rex.nfa_has_zsubexpr)\n\t\t\tcopy_sub(&temp_subs.synt, &subs->synt);\n#endif\n\t\t    subs = &temp_subs;\n\t\t}\n\n\t\tnewt = vim_realloc(l->t, newsize);\n\t\tif (newt == NULL)\n\t\t{\n\t\t    // out of memory\n\t\t    --depth;\n\t\t    return NULL;\n\t\t}\n\t\tl->t = newt;\n\t\tl->len = newlen;\n\t    }\n\n\t    // add the state to the list\n\t    state->lastlist[nfa_ll_index] = l->id;\n\t    thread = &l->t[l->n++];\n\t    thread->state = state;\n\t    if (pim == NULL)\n\t\tthread->pim.result = NFA_PIM_UNUSED;\n\t    else\n\t    {\n\t\tcopy_pim(&thread->pim, pim);\n\t\tl->has_pim = TRUE;\n\t    }\n\t    copy_sub(&thread->subs.norm, &subs->norm);\n#ifdef FEAT_SYN_HL\n\t    if (rex.nfa_has_zsubexpr)\n\t\tcopy_sub(&thread->subs.synt, &subs->synt);\n#endif\n#ifdef ENABLE_LOG\n\t    report_state(\"Adding\", &thread->subs.norm, state, l->id, pim);\n\t    did_print = TRUE;\n#endif\n    }\n\n#ifdef ENABLE_LOG\n    if (!did_print)\n\treport_state(\"Processing\", &subs->norm, state, l->id, pim);\n#endif\n    switch (state->c)\n    {\n\tcase NFA_MATCH:\n\t    break;\n\n\tcase NFA_SPLIT:\n\t    // order matters here\n\t    subs = addstate(l, state->out, subs, pim, off_arg);\n\t    subs = addstate(l, state->out1, subs, pim, off_arg);\n\t    break;\n\n\tcase NFA_EMPTY:\n\tcase NFA_NOPEN:\n\tcase NFA_NCLOSE:\n\t    subs = addstate(l, state->out, subs, pim, off_arg);\n\t    break;\n\n\tcase NFA_MOPEN:\n\tcase NFA_MOPEN1:\n\tcase NFA_MOPEN2:\n\tcase NFA_MOPEN3:\n\tcase NFA_MOPEN4:\n\tcase NFA_MOPEN5:\n\tcase NFA_MOPEN6:\n\tcase NFA_MOPEN7:\n\tcase NFA_MOPEN8:\n\tcase NFA_MOPEN9:\n#ifdef FEAT_SYN_HL\n\tcase NFA_ZOPEN:\n\tcase NFA_ZOPEN1:\n\tcase NFA_ZOPEN2:\n\tcase NFA_ZOPEN3:\n\tcase NFA_ZOPEN4:\n\tcase NFA_ZOPEN5:\n\tcase NFA_ZOPEN6:\n\tcase NFA_ZOPEN7:\n\tcase NFA_ZOPEN8:\n\tcase NFA_ZOPEN9:\n#endif\n\tcase NFA_ZSTART:\n\t    if (state->c == NFA_ZSTART)\n\t    {\n\t\tsubidx = 0;\n\t\tsub = &subs->norm;\n\t    }\n#ifdef FEAT_SYN_HL\n\t    else if (state->c >= NFA_ZOPEN && state->c <= NFA_ZOPEN9)\n\t    {\n\t\tsubidx = state->c - NFA_ZOPEN;\n\t\tsub = &subs->synt;\n\t    }\n#endif\n\t    else\n\t    {\n\t\tsubidx = state->c - NFA_MOPEN;\n\t\tsub = &subs->norm;\n\t    }\n\n\t    // avoid compiler warnings\n\t    save_ptr = NULL;\n\t    CLEAR_FIELD(save_multipos);\n\n\t    // Set the position (with \"off\" added) in the subexpression.  Save\n\t    // and restore it when it was in use.  Otherwise fill any gap.\n\t    if (REG_MULTI)\n\t    {\n\t\tif (subidx < sub->in_use)\n\t\t{\n\t\t    save_multipos = sub->list.multi[subidx];\n\t\t    save_in_use = -1;\n\t\t}\n\t\telse\n\t\t{\n\t\t    save_in_use = sub->in_use;\n\t\t    for (i = sub->in_use; i < subidx; ++i)\n\t\t    {\n\t\t\tsub->list.multi[i].start_lnum = -1;\n\t\t\tsub->list.multi[i].end_lnum = -1;\n\t\t    }\n\t\t    sub->in_use = subidx + 1;\n\t\t}\n\t\tif (off == -1)\n\t\t{\n\t\t    sub->list.multi[subidx].start_lnum = rex.lnum + 1;\n\t\t    sub->list.multi[subidx].start_col = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t    sub->list.multi[subidx].start_lnum = rex.lnum;\n\t\t    sub->list.multi[subidx].start_col =\n\t\t\t\t\t  (colnr_T)(rex.input - rex.line + off);\n\t\t}\n\t\tsub->list.multi[subidx].end_lnum = -1;\n\t    }\n\t    else\n\t    {\n\t\tif (subidx < sub->in_use)\n\t\t{\n\t\t    save_ptr = sub->list.line[subidx].start;\n\t\t    save_in_use = -1;\n\t\t}\n\t\telse\n\t\t{\n\t\t    save_in_use = sub->in_use;\n\t\t    for (i = sub->in_use; i < subidx; ++i)\n\t\t    {\n\t\t\tsub->list.line[i].start = NULL;\n\t\t\tsub->list.line[i].end = NULL;\n\t\t    }\n\t\t    sub->in_use = subidx + 1;\n\t\t}\n\t\tsub->list.line[subidx].start = rex.input + off;\n\t    }\n\n\t    subs = addstate(l, state->out, subs, pim, off_arg);\n\t    if (subs == NULL)\n\t\tbreak;\n\t    // \"subs\" may have changed, need to set \"sub\" again\n#ifdef FEAT_SYN_HL\n\t    if (state->c >= NFA_ZOPEN && state->c <= NFA_ZOPEN9)\n\t\tsub = &subs->synt;\n\t    else\n#endif\n\t\tsub = &subs->norm;\n\n\t    if (save_in_use == -1)\n\t    {\n\t\tif (REG_MULTI)\n\t\t    sub->list.multi[subidx] = save_multipos;\n\t\telse\n\t\t    sub->list.line[subidx].start = save_ptr;\n\t    }\n\t    else\n\t\tsub->in_use = save_in_use;\n\t    break;\n\n\tcase NFA_MCLOSE:\n\t    if (rex.nfa_has_zend && (REG_MULTI\n\t\t\t? subs->norm.list.multi[0].end_lnum >= 0\n\t\t\t: subs->norm.list.line[0].end != NULL))\n\t    {\n\t\t// Do not overwrite the position set by \\ze.\n\t\tsubs = addstate(l, state->out, subs, pim, off_arg);\n\t\tbreak;\n\t    }\n\t    // FALLTHROUGH\n\tcase NFA_MCLOSE1:\n\tcase NFA_MCLOSE2:\n\tcase NFA_MCLOSE3:\n\tcase NFA_MCLOSE4:\n\tcase NFA_MCLOSE5:\n\tcase NFA_MCLOSE6:\n\tcase NFA_MCLOSE7:\n\tcase NFA_MCLOSE8:\n\tcase NFA_MCLOSE9:\n#ifdef FEAT_SYN_HL\n\tcase NFA_ZCLOSE:\n\tcase NFA_ZCLOSE1:\n\tcase NFA_ZCLOSE2:\n\tcase NFA_ZCLOSE3:\n\tcase NFA_ZCLOSE4:\n\tcase NFA_ZCLOSE5:\n\tcase NFA_ZCLOSE6:\n\tcase NFA_ZCLOSE7:\n\tcase NFA_ZCLOSE8:\n\tcase NFA_ZCLOSE9:\n#endif\n\tcase NFA_ZEND:\n\t    if (state->c == NFA_ZEND)\n\t    {\n\t\tsubidx = 0;\n\t\tsub = &subs->norm;\n\t    }\n#ifdef FEAT_SYN_HL\n\t    else if (state->c >= NFA_ZCLOSE && state->c <= NFA_ZCLOSE9)\n\t    {\n\t\tsubidx = state->c - NFA_ZCLOSE;\n\t\tsub = &subs->synt;\n\t    }\n#endif\n\t    else\n\t    {\n\t\tsubidx = state->c - NFA_MCLOSE;\n\t\tsub = &subs->norm;\n\t    }\n\n\t    // We don't fill in gaps here, there must have been an MOPEN that\n\t    // has done that.\n\t    save_in_use = sub->in_use;\n\t    if (sub->in_use <= subidx)\n\t\tsub->in_use = subidx + 1;\n\t    if (REG_MULTI)\n\t    {\n\t\tsave_multipos = sub->list.multi[subidx];\n\t\tif (off == -1)\n\t\t{\n\t\t    sub->list.multi[subidx].end_lnum = rex.lnum + 1;\n\t\t    sub->list.multi[subidx].end_col = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t    sub->list.multi[subidx].end_lnum = rex.lnum;\n\t\t    sub->list.multi[subidx].end_col =\n\t\t\t\t\t  (colnr_T)(rex.input - rex.line + off);\n\t\t}\n\t\t// avoid compiler warnings\n\t\tsave_ptr = NULL;\n\t    }\n\t    else\n\t    {\n\t\tsave_ptr = sub->list.line[subidx].end;\n\t\tsub->list.line[subidx].end = rex.input + off;\n\t\t// avoid compiler warnings\n\t\tCLEAR_FIELD(save_multipos);\n\t    }\n\n\t    subs = addstate(l, state->out, subs, pim, off_arg);\n\t    if (subs == NULL)\n\t\tbreak;\n\t    // \"subs\" may have changed, need to set \"sub\" again\n#ifdef FEAT_SYN_HL\n\t    if (state->c >= NFA_ZCLOSE && state->c <= NFA_ZCLOSE9)\n\t\tsub = &subs->synt;\n\t    else\n#endif\n\t\tsub = &subs->norm;\n\n\t    if (REG_MULTI)\n\t\tsub->list.multi[subidx] = save_multipos;\n\t    else\n\t\tsub->list.line[subidx].end = save_ptr;\n\t    sub->in_use = save_in_use;\n\t    break;\n    }\n    --depth;\n    return subs;\n}\n\n/*\n * Like addstate(), but the new state(s) are put at position \"*ip\".\n * Used for zero-width matches, next state to use is the added one.\n * This makes sure the order of states to be tried does not change, which\n * matters for alternatives.\n */\n    static regsubs_T *\naddstate_here(\n    nfa_list_T\t\t*l,\t// runtime state list\n    nfa_state_T\t\t*state,\t// state to update\n    regsubs_T\t\t*subs,\t// pointers to subexpressions\n    nfa_pim_T\t\t*pim,   // postponed look-behind match\n    int\t\t\t*ip)\n{\n    int tlen = l->n;\n    int count;\n    int listidx = *ip;\n    regsubs_T *r;\n\n    // First add the state(s) at the end, so that we know how many there are.\n    // Pass the listidx as offset (avoids adding another argument to\n    // addstate().\n    r = addstate(l, state, subs, pim, -listidx - ADDSTATE_HERE_OFFSET);\n    if (r == NULL)\n\treturn NULL;\n\n    // when \"*ip\" was at the end of the list, nothing to do\n    if (listidx + 1 == tlen)\n\treturn r;\n\n    // re-order to put the new state at the current position\n    count = l->n - tlen;\n    if (count == 0)\n\treturn r; // no state got added\n    if (count == 1)\n    {\n\t// overwrite the current state\n\tl->t[listidx] = l->t[l->n - 1];\n    }\n    else if (count > 1)\n    {\n\tif (l->n + count - 1 >= l->len)\n\t{\n\t    // not enough space to move the new states, reallocate the list\n\t    // and move the states to the right position\n\t    int\t\t    newlen = l->len * 3 / 2 + 50;\n\t    size_t\t    newsize = newlen * sizeof(nfa_thread_T);\n\t    nfa_thread_T    *newl;\n\n\t    if ((long)(newsize >> 10) >= p_mmp)\n\t    {\n\t\temsg(_(e_maxmempat));\n\t\treturn NULL;\n\t    }\n\t    newl = alloc(newsize);\n\t    if (newl == NULL)\n\t\treturn NULL;\n\t    l->len = newlen;\n\t    mch_memmove(&(newl[0]),\n\t\t    &(l->t[0]),\n\t\t    sizeof(nfa_thread_T) * listidx);\n\t    mch_memmove(&(newl[listidx]),\n\t\t    &(l->t[l->n - count]),\n\t\t    sizeof(nfa_thread_T) * count);\n\t    mch_memmove(&(newl[listidx + count]),\n\t\t    &(l->t[listidx + 1]),\n\t\t    sizeof(nfa_thread_T) * (l->n - count - listidx - 1));\n\t    vim_free(l->t);\n\t    l->t = newl;\n\t}\n\telse\n\t{\n\t    // make space for new states, then move them from the\n\t    // end to the current position\n\t    mch_memmove(&(l->t[listidx + count]),\n\t\t    &(l->t[listidx + 1]),\n\t\t    sizeof(nfa_thread_T) * (l->n - listidx - 1));\n\t    mch_memmove(&(l->t[listidx]),\n\t\t    &(l->t[l->n - 1]),\n\t\t    sizeof(nfa_thread_T) * count);\n\t}\n    }\n    --l->n;\n    *ip = listidx - 1;\n\n    return r;\n}\n\n/*\n * Check character class \"class\" against current character c.\n */\n    static int\ncheck_char_class(int class, int c)\n{\n    switch (class)\n    {\n\tcase NFA_CLASS_ALNUM:\n\t    if (c >= 1 && c < 128 && isalnum(c))\n\t\treturn OK;\n\t    break;\n\tcase NFA_CLASS_ALPHA:\n\t    if (c >= 1 && c < 128 && isalpha(c))\n\t\treturn OK;\n\t    break;\n\tcase NFA_CLASS_BLANK:\n\t    if (c == ' ' || c == '\\t')\n\t\treturn OK;\n\t    break;\n\tcase NFA_CLASS_CNTRL:\n\t    if (c >= 1 && c <= 127 && iscntrl(c))\n\t\treturn OK;\n\t    break;\n\tcase NFA_CLASS_DIGIT:\n\t    if (VIM_ISDIGIT(c))\n\t\treturn OK;\n\t    break;\n\tcase NFA_CLASS_GRAPH:\n\t    if (c >= 1 && c <= 127 && isgraph(c))\n\t\treturn OK;\n\t    break;\n\tcase NFA_CLASS_LOWER:\n\t    if (MB_ISLOWER(c) && c != 170 && c != 186)\n\t\treturn OK;\n\t    break;\n\tcase NFA_CLASS_PRINT:\n\t    if (vim_isprintc(c))\n\t\treturn OK;\n\t    break;\n\tcase NFA_CLASS_PUNCT:\n\t    if (c >= 1 && c < 128 && ispunct(c))\n\t\treturn OK;\n\t    break;\n\tcase NFA_CLASS_SPACE:\n\t    if ((c >= 9 && c <= 13) || (c == ' '))\n\t\treturn OK;\n\t    break;\n\tcase NFA_CLASS_UPPER:\n\t    if (MB_ISUPPER(c))\n\t\treturn OK;\n\t    break;\n\tcase NFA_CLASS_XDIGIT:\n\t    if (vim_isxdigit(c))\n\t\treturn OK;\n\t    break;\n\tcase NFA_CLASS_TAB:\n\t    if (c == '\\t')\n\t\treturn OK;\n\t    break;\n\tcase NFA_CLASS_RETURN:\n\t    if (c == '\\r')\n\t\treturn OK;\n\t    break;\n\tcase NFA_CLASS_BACKSPACE:\n\t    if (c == '\\b')\n\t\treturn OK;\n\t    break;\n\tcase NFA_CLASS_ESCAPE:\n\t    if (c == '\\033')\n\t\treturn OK;\n\t    break;\n\tcase NFA_CLASS_IDENT:\n\t    if (vim_isIDc(c))\n\t\treturn OK;\n\t    break;\n\tcase NFA_CLASS_KEYWORD:\n\t    if (reg_iswordc(c))\n\t\treturn OK;\n\t    break;\n\tcase NFA_CLASS_FNAME:\n\t    if (vim_isfilec(c))\n\t\treturn OK;\n\t    break;\n\n\tdefault:\n\t    // should not be here :P\n\t    siemsg(_(e_ill_char_class), class);\n\t    return FAIL;\n    }\n    return FAIL;\n}\n\n/*\n * Check for a match with subexpression \"subidx\".\n * Return TRUE if it matches.\n */\n    static int\nmatch_backref(\n    regsub_T\t*sub,\t    // pointers to subexpressions\n    int\t\tsubidx,\n    int\t\t*bytelen)   // out: length of match in bytes\n{\n    int\t\tlen;\n\n    if (sub->in_use <= subidx)\n    {\nretempty:\n\t// backref was not set, match an empty string\n\t*bytelen = 0;\n\treturn TRUE;\n    }\n\n    if (REG_MULTI)\n    {\n\tif (sub->list.multi[subidx].start_lnum < 0\n\t\t\t\t       || sub->list.multi[subidx].end_lnum < 0)\n\t    goto retempty;\n\tif (sub->list.multi[subidx].start_lnum == rex.lnum\n\t\t\t       && sub->list.multi[subidx].end_lnum == rex.lnum)\n\t{\n\t    len = sub->list.multi[subidx].end_col\n\t\t\t\t\t  - sub->list.multi[subidx].start_col;\n\t    if (cstrncmp(rex.line + sub->list.multi[subidx].start_col,\n\t\t\t\t\t\t\t rex.input, &len) == 0)\n\t    {\n\t\t*bytelen = len;\n\t\treturn TRUE;\n\t    }\n\t}\n\telse\n\t{\n\t    if (match_with_backref(\n\t\t\tsub->list.multi[subidx].start_lnum,\n\t\t\tsub->list.multi[subidx].start_col,\n\t\t\tsub->list.multi[subidx].end_lnum,\n\t\t\tsub->list.multi[subidx].end_col,\n\t\t\tbytelen) == RA_MATCH)\n\t\treturn TRUE;\n\t}\n    }\n    else\n    {\n\tif (sub->list.line[subidx].start == NULL\n\t\t\t\t\t|| sub->list.line[subidx].end == NULL)\n\t    goto retempty;\n\tlen = (int)(sub->list.line[subidx].end - sub->list.line[subidx].start);\n\tif (cstrncmp(sub->list.line[subidx].start, rex.input, &len) == 0)\n\t{\n\t    *bytelen = len;\n\t    return TRUE;\n\t}\n    }\n    return FALSE;\n}\n\n#ifdef FEAT_SYN_HL\n\n/*\n * Check for a match with \\z subexpression \"subidx\".\n * Return TRUE if it matches.\n */\n    static int\nmatch_zref(\n    int\t\tsubidx,\n    int\t\t*bytelen)   // out: length of match in bytes\n{\n    int\t\tlen;\n\n    cleanup_zsubexpr();\n    if (re_extmatch_in == NULL || re_extmatch_in->matches[subidx] == NULL)\n    {\n\t// backref was not set, match an empty string\n\t*bytelen = 0;\n\treturn TRUE;\n    }\n\n    len = (int)STRLEN(re_extmatch_in->matches[subidx]);\n    if (cstrncmp(re_extmatch_in->matches[subidx], rex.input, &len) == 0)\n    {\n\t*bytelen = len;\n\treturn TRUE;\n    }\n    return FALSE;\n}\n#endif\n\n/*\n * Save list IDs for all NFA states of \"prog\" into \"list\".\n * Also reset the IDs to zero.\n * Only used for the recursive value lastlist[1].\n */\n    static void\nnfa_save_listids(nfa_regprog_T *prog, int *list)\n{\n    int\t\t    i;\n    nfa_state_T\t    *p;\n\n    // Order in the list is reverse, it's a bit faster that way.\n    p = &prog->state[0];\n    for (i = prog->nstate; --i >= 0; )\n    {\n\tlist[i] = p->lastlist[1];\n\tp->lastlist[1] = 0;\n\t++p;\n    }\n}\n\n/*\n * Restore list IDs from \"list\" to all NFA states.\n */\n    static void\nnfa_restore_listids(nfa_regprog_T *prog, int *list)\n{\n    int\t\t    i;\n    nfa_state_T\t    *p;\n\n    p = &prog->state[0];\n    for (i = prog->nstate; --i >= 0; )\n    {\n\tp->lastlist[1] = list[i];\n\t++p;\n    }\n}\n\n    static int\nnfa_re_num_cmp(long_u val, int op, long_u pos)\n{\n    if (op == 1) return pos > val;\n    if (op == 2) return pos < val;\n    return val == pos;\n}\n\nstatic int nfa_regmatch(nfa_regprog_T *prog, nfa_state_T *start, regsubs_T *submatch, regsubs_T *m);\n\n/*\n * Recursively call nfa_regmatch()\n * \"pim\" is NULL or contains info about a Postponed Invisible Match (start\n * position).\n */\n    static int\nrecursive_regmatch(\n    nfa_state_T\t    *state,\n    nfa_pim_T\t    *pim,\n    nfa_regprog_T   *prog,\n    regsubs_T\t    *submatch,\n    regsubs_T\t    *m,\n    int\t\t    **listids,\n    int\t\t    *listids_len)\n{\n    int\t\tsave_reginput_col = (int)(rex.input - rex.line);\n    int\t\tsave_reglnum = rex.lnum;\n    int\t\tsave_nfa_match = nfa_match;\n    int\t\tsave_nfa_listid = rex.nfa_listid;\n    save_se_T   *save_nfa_endp = nfa_endp;\n    save_se_T   endpos;\n    save_se_T   *endposp = NULL;\n    int\t\tresult;\n    int\t\tneed_restore = FALSE;\n\n    if (pim != NULL)\n    {\n\t// start at the position where the postponed match was\n\tif (REG_MULTI)\n\t    rex.input = rex.line + pim->end.pos.col;\n\telse\n\t    rex.input = pim->end.ptr;\n    }\n\n    if (state->c == NFA_START_INVISIBLE_BEFORE\n\t    || state->c == NFA_START_INVISIBLE_BEFORE_FIRST\n\t    || state->c == NFA_START_INVISIBLE_BEFORE_NEG\n\t    || state->c == NFA_START_INVISIBLE_BEFORE_NEG_FIRST)\n    {\n\t// The recursive match must end at the current position. When \"pim\" is\n\t// not NULL it specifies the current position.\n\tendposp = &endpos;\n\tif (REG_MULTI)\n\t{\n\t    if (pim == NULL)\n\t    {\n\t\tendpos.se_u.pos.col = (int)(rex.input - rex.line);\n\t\tendpos.se_u.pos.lnum = rex.lnum;\n\t    }\n\t    else\n\t\tendpos.se_u.pos = pim->end.pos;\n\t}\n\telse\n\t{\n\t    if (pim == NULL)\n\t\tendpos.se_u.ptr = rex.input;\n\t    else\n\t\tendpos.se_u.ptr = pim->end.ptr;\n\t}\n\n\t// Go back the specified number of bytes, or as far as the\n\t// start of the previous line, to try matching \"\\@<=\" or\n\t// not matching \"\\@<!\". This is very inefficient, limit the number of\n\t// bytes if possible.\n\tif (state->val <= 0)\n\t{\n\t    if (REG_MULTI)\n\t    {\n\t\trex.line = reg_getline(--rex.lnum);\n\t\tif (rex.line == NULL)\n\t\t    // can't go before the first line\n\t\t    rex.line = reg_getline(++rex.lnum);\n\t    }\n\t    rex.input = rex.line;\n\t}\n\telse\n\t{\n\t    if (REG_MULTI && (int)(rex.input - rex.line) < state->val)\n\t    {\n\t\t// Not enough bytes in this line, go to end of\n\t\t// previous line.\n\t\trex.line = reg_getline(--rex.lnum);\n\t\tif (rex.line == NULL)\n\t\t{\n\t\t    // can't go before the first line\n\t\t    rex.line = reg_getline(++rex.lnum);\n\t\t    rex.input = rex.line;\n\t\t}\n\t\telse\n\t\t    rex.input = rex.line + STRLEN(rex.line);\n\t    }\n\t    if ((int)(rex.input - rex.line) >= state->val)\n\t    {\n\t\trex.input -= state->val;\n\t\tif (has_mbyte)\n\t\t    rex.input -= mb_head_off(rex.line, rex.input);\n\t    }\n\t    else\n\t\trex.input = rex.line;\n\t}\n    }\n\n#ifdef ENABLE_LOG\n    if (log_fd != stderr)\n\tfclose(log_fd);\n    log_fd = NULL;\n#endif\n    // Have to clear the lastlist field of the NFA nodes, so that\n    // nfa_regmatch() and addstate() can run properly after recursion.\n    if (nfa_ll_index == 1)\n    {\n\t// Already calling nfa_regmatch() recursively.  Save the lastlist[1]\n\t// values and clear them.\n\tif (*listids == NULL || *listids_len < prog->nstate)\n\t{\n\t    vim_free(*listids);\n\t    *listids = ALLOC_MULT(int, prog->nstate);\n\t    if (*listids == NULL)\n\t    {\n\t\temsg(_(\"E878: (NFA) Could not allocate memory for branch traversal!\"));\n\t\treturn 0;\n\t    }\n\t    *listids_len = prog->nstate;\n\t}\n\tnfa_save_listids(prog, *listids);\n\tneed_restore = TRUE;\n\t// any value of rex.nfa_listid will do\n    }\n    else\n    {\n\t// First recursive nfa_regmatch() call, switch to the second lastlist\n\t// entry.  Make sure rex.nfa_listid is different from a previous\n\t// recursive call, because some states may still have this ID.\n\t++nfa_ll_index;\n\tif (rex.nfa_listid <= rex.nfa_alt_listid)\n\t    rex.nfa_listid = rex.nfa_alt_listid;\n    }\n\n    // Call nfa_regmatch() to check if the current concat matches at this\n    // position. The concat ends with the node NFA_END_INVISIBLE\n    nfa_endp = endposp;\n    result = nfa_regmatch(prog, state->out, submatch, m);\n\n    if (need_restore)\n\tnfa_restore_listids(prog, *listids);\n    else\n    {\n\t--nfa_ll_index;\n\trex.nfa_alt_listid = rex.nfa_listid;\n    }\n\n    // restore position in input text\n    rex.lnum = save_reglnum;\n    if (REG_MULTI)\n\trex.line = reg_getline(rex.lnum);\n    rex.input = rex.line + save_reginput_col;\n    if (result != NFA_TOO_EXPENSIVE)\n    {\n\tnfa_match = save_nfa_match;\n\trex.nfa_listid = save_nfa_listid;\n    }\n    nfa_endp = save_nfa_endp;\n\n#ifdef ENABLE_LOG\n    log_fd = fopen(NFA_REGEXP_RUN_LOG, \"a\");\n    if (log_fd != NULL)\n    {\n\tfprintf(log_fd, \"****************************\\n\");\n\tfprintf(log_fd, \"FINISHED RUNNING nfa_regmatch() recursively\\n\");\n\tfprintf(log_fd, \"MATCH = %s\\n\", result == TRUE ? \"OK\" : \"FALSE\");\n\tfprintf(log_fd, \"****************************\\n\");\n    }\n    else\n    {\n\temsg(_(e_log_open_failed));\n\tlog_fd = stderr;\n    }\n#endif\n\n    return result;\n}\n\n/*\n * Estimate the chance of a match with \"state\" failing.\n * empty match: 0\n * NFA_ANY: 1\n * specific character: 99\n */\n    static int\nfailure_chance(nfa_state_T *state, int depth)\n{\n    int c = state->c;\n    int l, r;\n\n    // detect looping\n    if (depth > 4)\n\treturn 1;\n\n    switch (c)\n    {\n\tcase NFA_SPLIT:\n\t    if (state->out->c == NFA_SPLIT || state->out1->c == NFA_SPLIT)\n\t\t// avoid recursive stuff\n\t\treturn 1;\n\t    // two alternatives, use the lowest failure chance\n\t    l = failure_chance(state->out, depth + 1);\n\t    r = failure_chance(state->out1, depth + 1);\n\t    return l < r ? l : r;\n\n\tcase NFA_ANY:\n\t    // matches anything, unlikely to fail\n\t    return 1;\n\n\tcase NFA_MATCH:\n\tcase NFA_MCLOSE:\n\tcase NFA_ANY_COMPOSING:\n\t    // empty match works always\n\t    return 0;\n\n\tcase NFA_START_INVISIBLE:\n\tcase NFA_START_INVISIBLE_FIRST:\n\tcase NFA_START_INVISIBLE_NEG:\n\tcase NFA_START_INVISIBLE_NEG_FIRST:\n\tcase NFA_START_INVISIBLE_BEFORE:\n\tcase NFA_START_INVISIBLE_BEFORE_FIRST:\n\tcase NFA_START_INVISIBLE_BEFORE_NEG:\n\tcase NFA_START_INVISIBLE_BEFORE_NEG_FIRST:\n\tcase NFA_START_PATTERN:\n\t    // recursive regmatch is expensive, use low failure chance\n\t    return 5;\n\n\tcase NFA_BOL:\n\tcase NFA_EOL:\n\tcase NFA_BOF:\n\tcase NFA_EOF:\n\tcase NFA_NEWL:\n\t    return 99;\n\n\tcase NFA_BOW:\n\tcase NFA_EOW:\n\t    return 90;\n\n\tcase NFA_MOPEN:\n\tcase NFA_MOPEN1:\n\tcase NFA_MOPEN2:\n\tcase NFA_MOPEN3:\n\tcase NFA_MOPEN4:\n\tcase NFA_MOPEN5:\n\tcase NFA_MOPEN6:\n\tcase NFA_MOPEN7:\n\tcase NFA_MOPEN8:\n\tcase NFA_MOPEN9:\n#ifdef FEAT_SYN_HL\n\tcase NFA_ZOPEN:\n\tcase NFA_ZOPEN1:\n\tcase NFA_ZOPEN2:\n\tcase NFA_ZOPEN3:\n\tcase NFA_ZOPEN4:\n\tcase NFA_ZOPEN5:\n\tcase NFA_ZOPEN6:\n\tcase NFA_ZOPEN7:\n\tcase NFA_ZOPEN8:\n\tcase NFA_ZOPEN9:\n\tcase NFA_ZCLOSE:\n\tcase NFA_ZCLOSE1:\n\tcase NFA_ZCLOSE2:\n\tcase NFA_ZCLOSE3:\n\tcase NFA_ZCLOSE4:\n\tcase NFA_ZCLOSE5:\n\tcase NFA_ZCLOSE6:\n\tcase NFA_ZCLOSE7:\n\tcase NFA_ZCLOSE8:\n\tcase NFA_ZCLOSE9:\n#endif\n\tcase NFA_NOPEN:\n\tcase NFA_MCLOSE1:\n\tcase NFA_MCLOSE2:\n\tcase NFA_MCLOSE3:\n\tcase NFA_MCLOSE4:\n\tcase NFA_MCLOSE5:\n\tcase NFA_MCLOSE6:\n\tcase NFA_MCLOSE7:\n\tcase NFA_MCLOSE8:\n\tcase NFA_MCLOSE9:\n\tcase NFA_NCLOSE:\n\t    return failure_chance(state->out, depth + 1);\n\n\tcase NFA_BACKREF1:\n\tcase NFA_BACKREF2:\n\tcase NFA_BACKREF3:\n\tcase NFA_BACKREF4:\n\tcase NFA_BACKREF5:\n\tcase NFA_BACKREF6:\n\tcase NFA_BACKREF7:\n\tcase NFA_BACKREF8:\n\tcase NFA_BACKREF9:\n#ifdef FEAT_SYN_HL\n\tcase NFA_ZREF1:\n\tcase NFA_ZREF2:\n\tcase NFA_ZREF3:\n\tcase NFA_ZREF4:\n\tcase NFA_ZREF5:\n\tcase NFA_ZREF6:\n\tcase NFA_ZREF7:\n\tcase NFA_ZREF8:\n\tcase NFA_ZREF9:\n#endif\n\t    // backreferences don't match in many places\n\t    return 94;\n\n\tcase NFA_LNUM_GT:\n\tcase NFA_LNUM_LT:\n\tcase NFA_COL_GT:\n\tcase NFA_COL_LT:\n\tcase NFA_VCOL_GT:\n\tcase NFA_VCOL_LT:\n\tcase NFA_MARK_GT:\n\tcase NFA_MARK_LT:\n\tcase NFA_VISUAL:\n\t    // before/after positions don't match very often\n\t    return 85;\n\n\tcase NFA_LNUM:\n\t    return 90;\n\n\tcase NFA_CURSOR:\n\tcase NFA_COL:\n\tcase NFA_VCOL:\n\tcase NFA_MARK:\n\t    // specific positions rarely match\n\t    return 98;\n\n\tcase NFA_COMPOSING:\n\t    return 95;\n\n\tdefault:\n\t    if (c > 0)\n\t\t// character match fails often\n\t\treturn 95;\n    }\n\n    // something else, includes character classes\n    return 50;\n}\n\n/*\n * Skip until the char \"c\" we know a match must start with.\n */\n    static int\nskip_to_start(int c, colnr_T *colp)\n{\n    char_u *s;\n\n    // Used often, do some work to avoid call overhead.\n    if (!rex.reg_ic && !has_mbyte)\n\ts = vim_strbyte(rex.line + *colp, c);\n    else\n\ts = cstrchr(rex.line + *colp, c);\n    if (s == NULL)\n\treturn FAIL;\n    *colp = (int)(s - rex.line);\n    return OK;\n}\n\n/*\n * Check for a match with match_text.\n * Called after skip_to_start() has found regstart.\n * Returns zero for no match, 1 for a match.\n */\n    static long\nfind_match_text(colnr_T startcol, int regstart, char_u *match_text)\n{\n    colnr_T col = startcol;\n    int\t    c1, c2;\n    int\t    len1, len2;\n    int\t    match;\n\n    for (;;)\n    {\n\tmatch = TRUE;\n\tlen2 = MB_CHAR2LEN(regstart); // skip regstart\n\tfor (len1 = 0; match_text[len1] != NUL; len1 += MB_CHAR2LEN(c1))\n\t{\n\t    c1 = PTR2CHAR(match_text + len1);\n\t    c2 = PTR2CHAR(rex.line + col + len2);\n\t    if (c1 != c2 && (!rex.reg_ic || MB_CASEFOLD(c1) != MB_CASEFOLD(c2)))\n\t    {\n\t\tmatch = FALSE;\n\t\tbreak;\n\t    }\n\t    len2 += enc_utf8 ? utf_ptr2len(rex.line + col + len2)\n\t\t\t\t\t\t\t     : MB_CHAR2LEN(c2);\n\t}\n\tif (match\n\t\t// check that no composing char follows\n\t\t&& !(enc_utf8\n\t\t\t  && utf_iscomposing(PTR2CHAR(rex.line + col + len2))))\n\t{\n\t    cleanup_subexpr();\n\t    if (REG_MULTI)\n\t    {\n\t\trex.reg_startpos[0].lnum = rex.lnum;\n\t\trex.reg_startpos[0].col = col;\n\t\trex.reg_endpos[0].lnum = rex.lnum;\n\t\trex.reg_endpos[0].col = col + len2;\n\t    }\n\t    else\n\t    {\n\t\trex.reg_startp[0] = rex.line + col;\n\t\trex.reg_endp[0] = rex.line + col + len2;\n\t    }\n\t    return 1L;\n\t}\n\n\t// Try finding regstart after the current match.\n\tcol += MB_CHAR2LEN(regstart); // skip regstart\n\tif (skip_to_start(regstart, &col) == FAIL)\n\t    break;\n    }\n    return 0L;\n}\n\n#ifdef FEAT_RELTIME\n    static int\nnfa_did_time_out()\n{\n    if (nfa_time_limit != NULL && profile_passed_limit(nfa_time_limit))\n    {\n\tif (nfa_timed_out != NULL)\n\t    *nfa_timed_out = TRUE;\n\treturn TRUE;\n    }\n    return FALSE;\n}\n#endif\n\n/*\n * Main matching routine.\n *\n * Run NFA to determine whether it matches rex.input.\n *\n * When \"nfa_endp\" is not NULL it is a required end-of-match position.\n *\n * Return TRUE if there is a match, FALSE if there is no match,\n * NFA_TOO_EXPENSIVE if we end up with too many states.\n * When there is a match \"submatch\" contains the positions.\n *\n * Note: Caller must ensure that: start != NULL.\n */\n    static int\nnfa_regmatch(\n    nfa_regprog_T\t*prog,\n    nfa_state_T\t\t*start,\n    regsubs_T\t\t*submatch,\n    regsubs_T\t\t*m)\n{\n    int\t\tresult = FALSE;\n    size_t\tsize = 0;\n    int\t\tflag = 0;\n    int\t\tgo_to_nextline = FALSE;\n    nfa_thread_T *t;\n    nfa_list_T\tlist[2];\n    int\t\tlistidx;\n    nfa_list_T\t*thislist;\n    nfa_list_T\t*nextlist;\n    int\t\t*listids = NULL;\n    int\t\tlistids_len = 0;\n    nfa_state_T *add_state;\n    int\t\tadd_here;\n    int\t\tadd_count;\n    int\t\tadd_off = 0;\n    int\t\ttoplevel = start->c == NFA_MOPEN;\n    regsubs_T\t*r;\n#ifdef NFA_REGEXP_DEBUG_LOG\n    FILE\t*debug;\n#endif\n\n    // Some patterns may take a long time to match, especially when using\n    // recursive_regmatch(). Allow interrupting them with CTRL-C.\n    fast_breakcheck();\n    if (got_int)\n\treturn FALSE;\n#ifdef FEAT_RELTIME\n    if (nfa_did_time_out())\n\treturn FALSE;\n#endif\n\n#ifdef NFA_REGEXP_DEBUG_LOG\n    debug = fopen(NFA_REGEXP_DEBUG_LOG, \"a\");\n    if (debug == NULL)\n    {\n\tsemsg(\"(NFA) COULD NOT OPEN %s!\", NFA_REGEXP_DEBUG_LOG);\n\treturn FALSE;\n    }\n#endif\n    nfa_match = FALSE;\n\n    // Allocate memory for the lists of nodes.\n    size = (prog->nstate + 1) * sizeof(nfa_thread_T);\n\n    list[0].t = alloc(size);\n    list[0].len = prog->nstate + 1;\n    list[1].t = alloc(size);\n    list[1].len = prog->nstate + 1;\n    if (list[0].t == NULL || list[1].t == NULL)\n\tgoto theend;\n\n#ifdef ENABLE_LOG\n    log_fd = fopen(NFA_REGEXP_RUN_LOG, \"a\");\n    if (log_fd != NULL)\n    {\n\tfprintf(log_fd, \"**********************************\\n\");\n\tnfa_set_code(start->c);\n\tfprintf(log_fd, \" RUNNING nfa_regmatch() starting with state %d, code %s\\n\",\n\tabs(start->id), code);\n\tfprintf(log_fd, \"**********************************\\n\");\n    }\n    else\n    {\n\temsg(_(e_log_open_failed));\n\tlog_fd = stderr;\n    }\n#endif\n\n    thislist = &list[0];\n    thislist->n = 0;\n    thislist->has_pim = FALSE;\n    nextlist = &list[1];\n    nextlist->n = 0;\n    nextlist->has_pim = FALSE;\n#ifdef ENABLE_LOG\n    fprintf(log_fd, \"(---) STARTSTATE first\\n\");\n#endif\n    thislist->id = rex.nfa_listid + 1;\n\n    // Inline optimized code for addstate(thislist, start, m, 0) if we know\n    // it's the first MOPEN.\n    if (toplevel)\n    {\n\tif (REG_MULTI)\n\t{\n\t    m->norm.list.multi[0].start_lnum = rex.lnum;\n\t    m->norm.list.multi[0].start_col = (colnr_T)(rex.input - rex.line);\n\t}\n\telse\n\t    m->norm.list.line[0].start = rex.input;\n\tm->norm.in_use = 1;\n\tr = addstate(thislist, start->out, m, NULL, 0);\n    }\n    else\n\tr = addstate(thislist, start, m, NULL, 0);\n    if (r == NULL)\n    {\n\tnfa_match = NFA_TOO_EXPENSIVE;\n\tgoto theend;\n    }\n\n#define\tADD_STATE_IF_MATCH(state)\t\t\t\\\n    if (result) {\t\t\t\t\t\\\n\tadd_state = state->out;\t\t\t\t\\\n\tadd_off = clen;\t\t\t\t\t\\\n    }\n\n    /*\n     * Run for each character.\n     */\n    for (;;)\n    {\n\tint\tcurc;\n\tint\tclen;\n\n\tif (has_mbyte)\n\t{\n\t    curc = (*mb_ptr2char)(rex.input);\n\t    clen = (*mb_ptr2len)(rex.input);\n\t}\n\telse\n\t{\n\t    curc = *rex.input;\n\t    clen = 1;\n\t}\n\tif (curc == NUL)\n\t{\n\t    clen = 0;\n\t    go_to_nextline = FALSE;\n\t}\n\n\t// swap lists\n\tthislist = &list[flag];\n\tnextlist = &list[flag ^= 1];\n\tnextlist->n = 0;\t    // clear nextlist\n\tnextlist->has_pim = FALSE;\n\t++rex.nfa_listid;\n\tif (prog->re_engine == AUTOMATIC_ENGINE\n\t\t&& (rex.nfa_listid >= NFA_MAX_STATES\n# ifdef FEAT_EVAL\n\t\t    || nfa_fail_for_testing\n# endif\n\t\t    ))\n\t{\n\t    // too many states, retry with old engine\n\t    nfa_match = NFA_TOO_EXPENSIVE;\n\t    goto theend;\n\t}\n\n\tthislist->id = rex.nfa_listid;\n\tnextlist->id = rex.nfa_listid + 1;\n\n#ifdef ENABLE_LOG\n\tfprintf(log_fd, \"------------------------------------------\\n\");\n\tfprintf(log_fd, \">>> Reginput is \\\"%s\\\"\\n\", rex.input);\n\tfprintf(log_fd, \">>> Advanced one character... Current char is %c (code %d) \\n\", curc, (int)curc);\n\tfprintf(log_fd, \">>> Thislist has %d states available: \", thislist->n);\n\t{\n\t    int i;\n\n\t    for (i = 0; i < thislist->n; i++)\n\t\tfprintf(log_fd, \"%d  \", abs(thislist->t[i].state->id));\n\t}\n\tfprintf(log_fd, \"\\n\");\n#endif\n\n#ifdef NFA_REGEXP_DEBUG_LOG\n\tfprintf(debug, \"\\n-------------------\\n\");\n#endif\n\t/*\n\t * If the state lists are empty we can stop.\n\t */\n\tif (thislist->n == 0)\n\t    break;\n\n\t// compute nextlist\n\tfor (listidx = 0; listidx < thislist->n; ++listidx)\n\t{\n\t    // If the list gets very long there probably is something wrong.\n\t    // At least allow interrupting with CTRL-C.\n\t    fast_breakcheck();\n\t    if (got_int)\n\t\tbreak;\n#ifdef FEAT_RELTIME\n\t    if (nfa_time_limit != NULL && ++nfa_time_count == 20)\n\t    {\n\t\tnfa_time_count = 0;\n\t\tif (nfa_did_time_out())\n\t\t    break;\n\t    }\n#endif\n\t    t = &thislist->t[listidx];\n\n#ifdef NFA_REGEXP_DEBUG_LOG\n\t    nfa_set_code(t->state->c);\n\t    fprintf(debug, \"%s, \", code);\n#endif\n#ifdef ENABLE_LOG\n\t    {\n\t\tint col;\n\n\t\tif (t->subs.norm.in_use <= 0)\n\t\t    col = -1;\n\t\telse if (REG_MULTI)\n\t\t    col = t->subs.norm.list.multi[0].start_col;\n\t\telse\n\t\t    col = (int)(t->subs.norm.list.line[0].start - rex.line);\n\t\tnfa_set_code(t->state->c);\n\t\tfprintf(log_fd, \"(%d) char %d %s (start col %d)%s... \\n\",\n\t\t\tabs(t->state->id), (int)t->state->c, code, col,\n\t\t\tpim_info(&t->pim));\n\t    }\n#endif\n\n\t    /*\n\t     * Handle the possible codes of the current state.\n\t     * The most important is NFA_MATCH.\n\t     */\n\t    add_state = NULL;\n\t    add_here = FALSE;\n\t    add_count = 0;\n\t    switch (t->state->c)\n\t    {\n\t    case NFA_MATCH:\n\t      {\n\t\t// If the match is not at the start of the line, ends before a\n\t\t// composing characters and rex.reg_icombine is not set, that\n\t\t// is not really a match.\n\t\tif (enc_utf8 && !rex.reg_icombine\n\t\t\t     && rex.input != rex.line && utf_iscomposing(curc))\n\t\t    break;\n\n\t\tnfa_match = TRUE;\n\t\tcopy_sub(&submatch->norm, &t->subs.norm);\n#ifdef FEAT_SYN_HL\n\t\tif (rex.nfa_has_zsubexpr)\n\t\t    copy_sub(&submatch->synt, &t->subs.synt);\n#endif\n#ifdef ENABLE_LOG\n\t\tlog_subsexpr(&t->subs);\n#endif\n\t\t// Found the left-most longest match, do not look at any other\n\t\t// states at this position.  When the list of states is going\n\t\t// to be empty quit without advancing, so that \"rex.input\" is\n\t\t// correct.\n\t\tif (nextlist->n == 0)\n\t\t    clen = 0;\n\t\tgoto nextchar;\n\t      }\n\n\t    case NFA_END_INVISIBLE:\n\t    case NFA_END_INVISIBLE_NEG:\n\t    case NFA_END_PATTERN:\n\t\t/*\n\t\t * This is only encountered after a NFA_START_INVISIBLE or\n\t\t * NFA_START_INVISIBLE_BEFORE node.\n\t\t * They surround a zero-width group, used with \"\\@=\", \"\\&\",\n\t\t * \"\\@!\", \"\\@<=\" and \"\\@<!\".\n\t\t * If we got here, it means that the current \"invisible\" group\n\t\t * finished successfully, so return control to the parent\n\t\t * nfa_regmatch().  For a look-behind match only when it ends\n\t\t * in the position in \"nfa_endp\".\n\t\t * Submatches are stored in *m, and used in the parent call.\n\t\t */\n#ifdef ENABLE_LOG\n\t\tif (nfa_endp != NULL)\n\t\t{\n\t\t    if (REG_MULTI)\n\t\t\tfprintf(log_fd, \"Current lnum: %d, endp lnum: %d; current col: %d, endp col: %d\\n\",\n\t\t\t\t(int)rex.lnum,\n\t\t\t\t(int)nfa_endp->se_u.pos.lnum,\n\t\t\t\t(int)(rex.input - rex.line),\n\t\t\t\tnfa_endp->se_u.pos.col);\n\t\t    else\n\t\t\tfprintf(log_fd, \"Current col: %d, endp col: %d\\n\",\n\t\t\t\t(int)(rex.input - rex.line),\n\t\t\t\t(int)(nfa_endp->se_u.ptr - rex.input));\n\t\t}\n#endif\n\t\t// If \"nfa_endp\" is set it's only a match if it ends at\n\t\t// \"nfa_endp\"\n\t\tif (nfa_endp != NULL && (REG_MULTI\n\t\t\t? (rex.lnum != nfa_endp->se_u.pos.lnum\n\t\t\t    || (int)(rex.input - rex.line)\n\t\t\t\t\t\t!= nfa_endp->se_u.pos.col)\n\t\t\t: rex.input != nfa_endp->se_u.ptr))\n\t\t    break;\n\n\t\t// do not set submatches for \\@!\n\t\tif (t->state->c != NFA_END_INVISIBLE_NEG)\n\t\t{\n\t\t    copy_sub(&m->norm, &t->subs.norm);\n#ifdef FEAT_SYN_HL\n\t\t    if (rex.nfa_has_zsubexpr)\n\t\t\tcopy_sub(&m->synt, &t->subs.synt);\n#endif\n\t\t}\n#ifdef ENABLE_LOG\n\t\tfprintf(log_fd, \"Match found:\\n\");\n\t\tlog_subsexpr(m);\n#endif\n\t\tnfa_match = TRUE;\n\t\t// See comment above at \"goto nextchar\".\n\t\tif (nextlist->n == 0)\n\t\t    clen = 0;\n\t\tgoto nextchar;\n\n\t    case NFA_START_INVISIBLE:\n\t    case NFA_START_INVISIBLE_FIRST:\n\t    case NFA_START_INVISIBLE_NEG:\n\t    case NFA_START_INVISIBLE_NEG_FIRST:\n\t    case NFA_START_INVISIBLE_BEFORE:\n\t    case NFA_START_INVISIBLE_BEFORE_FIRST:\n\t    case NFA_START_INVISIBLE_BEFORE_NEG:\n\t    case NFA_START_INVISIBLE_BEFORE_NEG_FIRST:\n\t\t{\n#ifdef ENABLE_LOG\n\t\t    fprintf(log_fd, \"Failure chance invisible: %d, what follows: %d\\n\",\n\t\t\t    failure_chance(t->state->out, 0),\n\t\t\t    failure_chance(t->state->out1->out, 0));\n#endif\n\t\t    // Do it directly if there already is a PIM or when\n\t\t    // nfa_postprocess() detected it will work better.\n\t\t    if (t->pim.result != NFA_PIM_UNUSED\n\t\t\t || t->state->c == NFA_START_INVISIBLE_FIRST\n\t\t\t || t->state->c == NFA_START_INVISIBLE_NEG_FIRST\n\t\t\t || t->state->c == NFA_START_INVISIBLE_BEFORE_FIRST\n\t\t\t || t->state->c == NFA_START_INVISIBLE_BEFORE_NEG_FIRST)\n\t\t    {\n\t\t\tint in_use = m->norm.in_use;\n\n\t\t\t// Copy submatch info for the recursive call, opposite\n\t\t\t// of what happens on success below.\n\t\t\tcopy_sub_off(&m->norm, &t->subs.norm);\n#ifdef FEAT_SYN_HL\n\t\t\tif (rex.nfa_has_zsubexpr)\n\t\t\t    copy_sub_off(&m->synt, &t->subs.synt);\n#endif\n\n\t\t\t/*\n\t\t\t * First try matching the invisible match, then what\n\t\t\t * follows.\n\t\t\t */\n\t\t\tresult = recursive_regmatch(t->state, NULL, prog,\n\t\t\t\t\t  submatch, m, &listids, &listids_len);\n\t\t\tif (result == NFA_TOO_EXPENSIVE)\n\t\t\t{\n\t\t\t    nfa_match = result;\n\t\t\t    goto theend;\n\t\t\t}\n\n\t\t\t// for \\@! and \\@<! it is a match when the result is\n\t\t\t// FALSE\n\t\t\tif (result != (t->state->c == NFA_START_INVISIBLE_NEG\n\t\t\t       || t->state->c == NFA_START_INVISIBLE_NEG_FIRST\n\t\t\t       || t->state->c\n\t\t\t\t\t   == NFA_START_INVISIBLE_BEFORE_NEG\n\t\t\t       || t->state->c\n\t\t\t\t     == NFA_START_INVISIBLE_BEFORE_NEG_FIRST))\n\t\t\t{\n\t\t\t    // Copy submatch info from the recursive call\n\t\t\t    copy_sub_off(&t->subs.norm, &m->norm);\n#ifdef FEAT_SYN_HL\n\t\t\t    if (rex.nfa_has_zsubexpr)\n\t\t\t\tcopy_sub_off(&t->subs.synt, &m->synt);\n#endif\n\t\t\t    // If the pattern has \\ze and it matched in the\n\t\t\t    // sub pattern, use it.\n\t\t\t    copy_ze_off(&t->subs.norm, &m->norm);\n\n\t\t\t    // t->state->out1 is the corresponding\n\t\t\t    // END_INVISIBLE node; Add its out to the current\n\t\t\t    // list (zero-width match).\n\t\t\t    add_here = TRUE;\n\t\t\t    add_state = t->state->out1->out;\n\t\t\t}\n\t\t\tm->norm.in_use = in_use;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tnfa_pim_T pim;\n\n\t\t\t/*\n\t\t\t * First try matching what follows.  Only if a match\n\t\t\t * is found verify the invisible match matches.  Add a\n\t\t\t * nfa_pim_T to the following states, it contains info\n\t\t\t * about the invisible match.\n\t\t\t */\n\t\t\tpim.state = t->state;\n\t\t\tpim.result = NFA_PIM_TODO;\n\t\t\tpim.subs.norm.in_use = 0;\n#ifdef FEAT_SYN_HL\n\t\t\tpim.subs.synt.in_use = 0;\n#endif\n\t\t\tif (REG_MULTI)\n\t\t\t{\n\t\t\t    pim.end.pos.col = (int)(rex.input - rex.line);\n\t\t\t    pim.end.pos.lnum = rex.lnum;\n\t\t\t}\n\t\t\telse\n\t\t\t    pim.end.ptr = rex.input;\n\n\t\t\t// t->state->out1 is the corresponding END_INVISIBLE\n\t\t\t// node; Add its out to the current list (zero-width\n\t\t\t// match).\n\t\t\tif (addstate_here(thislist, t->state->out1->out,\n\t\t\t\t\t     &t->subs, &pim, &listidx) == NULL)\n\t\t\t{\n\t\t\t    nfa_match = NFA_TOO_EXPENSIVE;\n\t\t\t    goto theend;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    case NFA_START_PATTERN:\n\t      {\n\t\tnfa_state_T *skip = NULL;\n#ifdef ENABLE_LOG\n\t\tint\t    skip_lid = 0;\n#endif\n\n\t\t// There is no point in trying to match the pattern if the\n\t\t// output state is not going to be added to the list.\n\t\tif (state_in_list(nextlist, t->state->out1->out, &t->subs))\n\t\t{\n\t\t    skip = t->state->out1->out;\n#ifdef ENABLE_LOG\n\t\t    skip_lid = nextlist->id;\n#endif\n\t\t}\n\t\telse if (state_in_list(nextlist,\n\t\t\t\t\t  t->state->out1->out->out, &t->subs))\n\t\t{\n\t\t    skip = t->state->out1->out->out;\n#ifdef ENABLE_LOG\n\t\t    skip_lid = nextlist->id;\n#endif\n\t\t}\n\t\telse if (state_in_list(thislist,\n\t\t\t\t\t  t->state->out1->out->out, &t->subs))\n\t\t{\n\t\t    skip = t->state->out1->out->out;\n#ifdef ENABLE_LOG\n\t\t    skip_lid = thislist->id;\n#endif\n\t\t}\n\t\tif (skip != NULL)\n\t\t{\n#ifdef ENABLE_LOG\n\t\t    nfa_set_code(skip->c);\n\t\t    fprintf(log_fd, \"> Not trying to match pattern, output state %d is already in list %d. char %d: %s\\n\",\n\t\t\t    abs(skip->id), skip_lid, skip->c, code);\n#endif\n\t\t    break;\n\t\t}\n\t\t// Copy submatch info to the recursive call, opposite of what\n\t\t// happens afterwards.\n\t\tcopy_sub_off(&m->norm, &t->subs.norm);\n#ifdef FEAT_SYN_HL\n\t\tif (rex.nfa_has_zsubexpr)\n\t\t    copy_sub_off(&m->synt, &t->subs.synt);\n#endif\n\n\t\t// First try matching the pattern.\n\t\tresult = recursive_regmatch(t->state, NULL, prog,\n\t\t\t\t\t  submatch, m, &listids, &listids_len);\n\t\tif (result == NFA_TOO_EXPENSIVE)\n\t\t{\n\t\t    nfa_match = result;\n\t\t    goto theend;\n\t\t}\n\t\tif (result)\n\t\t{\n\t\t    int bytelen;\n\n#ifdef ENABLE_LOG\n\t\t    fprintf(log_fd, \"NFA_START_PATTERN matches:\\n\");\n\t\t    log_subsexpr(m);\n#endif\n\t\t    // Copy submatch info from the recursive call\n\t\t    copy_sub_off(&t->subs.norm, &m->norm);\n#ifdef FEAT_SYN_HL\n\t\t    if (rex.nfa_has_zsubexpr)\n\t\t\tcopy_sub_off(&t->subs.synt, &m->synt);\n#endif\n\t\t    // Now we need to skip over the matched text and then\n\t\t    // continue with what follows.\n\t\t    if (REG_MULTI)\n\t\t\t// TODO: multi-line match\n\t\t\tbytelen = m->norm.list.multi[0].end_col\n\t\t\t\t\t\t  - (int)(rex.input - rex.line);\n\t\t    else\n\t\t\tbytelen = (int)(m->norm.list.line[0].end - rex.input);\n\n#ifdef ENABLE_LOG\n\t\t    fprintf(log_fd, \"NFA_START_PATTERN length: %d\\n\", bytelen);\n#endif\n\t\t    if (bytelen == 0)\n\t\t    {\n\t\t\t// empty match, output of corresponding\n\t\t\t// NFA_END_PATTERN/NFA_SKIP to be used at current\n\t\t\t// position\n\t\t\tadd_here = TRUE;\n\t\t\tadd_state = t->state->out1->out->out;\n\t\t    }\n\t\t    else if (bytelen <= clen)\n\t\t    {\n\t\t\t// match current character, output of corresponding\n\t\t\t// NFA_END_PATTERN to be used at next position.\n\t\t\tadd_state = t->state->out1->out->out;\n\t\t\tadd_off = clen;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// skip over the matched characters, set character\n\t\t\t// count in NFA_SKIP\n\t\t\tadd_state = t->state->out1->out;\n\t\t\tadd_off = bytelen;\n\t\t\tadd_count = bytelen - clen;\n\t\t    }\n\t\t}\n\t\tbreak;\n\t      }\n\n\t    case NFA_BOL:\n\t\tif (rex.input == rex.line)\n\t\t{\n\t\t    add_here = TRUE;\n\t\t    add_state = t->state->out;\n\t\t}\n\t\tbreak;\n\n\t    case NFA_EOL:\n\t\tif (curc == NUL)\n\t\t{\n\t\t    add_here = TRUE;\n\t\t    add_state = t->state->out;\n\t\t}\n\t\tbreak;\n\n\t    case NFA_BOW:\n\t\tresult = TRUE;\n\n\t\tif (curc == NUL)\n\t\t    result = FALSE;\n\t\telse if (has_mbyte)\n\t\t{\n\t\t    int this_class;\n\n\t\t    // Get class of current and previous char (if it exists).\n\t\t    this_class = mb_get_class_buf(rex.input, rex.reg_buf);\n\t\t    if (this_class <= 1)\n\t\t\tresult = FALSE;\n\t\t    else if (reg_prev_class() == this_class)\n\t\t\tresult = FALSE;\n\t\t}\n\t\telse if (!vim_iswordc_buf(curc, rex.reg_buf)\n\t\t\t   || (rex.input > rex.line\n\t\t\t\t&& vim_iswordc_buf(rex.input[-1], rex.reg_buf)))\n\t\t    result = FALSE;\n\t\tif (result)\n\t\t{\n\t\t    add_here = TRUE;\n\t\t    add_state = t->state->out;\n\t\t}\n\t\tbreak;\n\n\t    case NFA_EOW:\n\t\tresult = TRUE;\n\t\tif (rex.input == rex.line)\n\t\t    result = FALSE;\n\t\telse if (has_mbyte)\n\t\t{\n\t\t    int this_class, prev_class;\n\n\t\t    // Get class of current and previous char (if it exists).\n\t\t    this_class = mb_get_class_buf(rex.input, rex.reg_buf);\n\t\t    prev_class = reg_prev_class();\n\t\t    if (this_class == prev_class\n\t\t\t\t\t|| prev_class == 0 || prev_class == 1)\n\t\t\tresult = FALSE;\n\t\t}\n\t\telse if (!vim_iswordc_buf(rex.input[-1], rex.reg_buf)\n\t\t\t|| (rex.input[0] != NUL\n\t\t\t\t\t&& vim_iswordc_buf(curc, rex.reg_buf)))\n\t\t    result = FALSE;\n\t\tif (result)\n\t\t{\n\t\t    add_here = TRUE;\n\t\t    add_state = t->state->out;\n\t\t}\n\t\tbreak;\n\n\t    case NFA_BOF:\n\t\tif (rex.lnum == 0 && rex.input == rex.line\n\t\t\t\t     && (!REG_MULTI || rex.reg_firstlnum == 1))\n\t\t{\n\t\t    add_here = TRUE;\n\t\t    add_state = t->state->out;\n\t\t}\n\t\tbreak;\n\n\t    case NFA_EOF:\n\t\tif (rex.lnum == rex.reg_maxline && curc == NUL)\n\t\t{\n\t\t    add_here = TRUE;\n\t\t    add_state = t->state->out;\n\t\t}\n\t\tbreak;\n\n\t    case NFA_COMPOSING:\n\t    {\n\t\tint\t    mc = curc;\n\t\tint\t    len = 0;\n\t\tnfa_state_T *end;\n\t\tnfa_state_T *sta;\n\t\tint\t    cchars[MAX_MCO];\n\t\tint\t    ccount = 0;\n\t\tint\t    j;\n\n\t\tsta = t->state->out;\n\t\tlen = 0;\n\t\tif (utf_iscomposing(sta->c))\n\t\t{\n\t\t    // Only match composing character(s), ignore base\n\t\t    // character.  Used for \".{composing}\" and \"{composing}\"\n\t\t    // (no preceding character).\n\t\t    len += mb_char2len(mc);\n\t\t}\n\t\tif (rex.reg_icombine && len == 0)\n\t\t{\n\t\t    // If \\Z was present, then ignore composing characters.\n\t\t    // When ignoring the base character this always matches.\n\t\t    if (sta->c != curc)\n\t\t\tresult = FAIL;\n\t\t    else\n\t\t\tresult = OK;\n\t\t    while (sta->c != NFA_END_COMPOSING)\n\t\t\tsta = sta->out;\n\t\t}\n\n\t\t// Check base character matches first, unless ignored.\n\t\telse if (len > 0 || mc == sta->c)\n\t\t{\n\t\t    if (len == 0)\n\t\t    {\n\t\t\tlen += mb_char2len(mc);\n\t\t\tsta = sta->out;\n\t\t    }\n\n\t\t    // We don't care about the order of composing characters.\n\t\t    // Get them into cchars[] first.\n\t\t    while (len < clen)\n\t\t    {\n\t\t\tmc = mb_ptr2char(rex.input + len);\n\t\t\tcchars[ccount++] = mc;\n\t\t\tlen += mb_char2len(mc);\n\t\t\tif (ccount == MAX_MCO)\n\t\t\t    break;\n\t\t    }\n\n\t\t    // Check that each composing char in the pattern matches a\n\t\t    // composing char in the text.  We do not check if all\n\t\t    // composing chars are matched.\n\t\t    result = OK;\n\t\t    while (sta->c != NFA_END_COMPOSING)\n\t\t    {\n\t\t\tfor (j = 0; j < ccount; ++j)\n\t\t\t    if (cchars[j] == sta->c)\n\t\t\t\tbreak;\n\t\t\tif (j == ccount)\n\t\t\t{\n\t\t\t    result = FAIL;\n\t\t\t    break;\n\t\t\t}\n\t\t\tsta = sta->out;\n\t\t    }\n\t\t}\n\t\telse\n\t\t    result = FAIL;\n\n\t\tend = t->state->out1;\t    // NFA_END_COMPOSING\n\t\tADD_STATE_IF_MATCH(end);\n\t\tbreak;\n\t    }\n\n\t    case NFA_NEWL:\n\t\tif (curc == NUL && !rex.reg_line_lbr && REG_MULTI\n\t\t\t\t\t\t && rex.lnum <= rex.reg_maxline)\n\t\t{\n\t\t    go_to_nextline = TRUE;\n\t\t    // Pass -1 for the offset, which means taking the position\n\t\t    // at the start of the next line.\n\t\t    add_state = t->state->out;\n\t\t    add_off = -1;\n\t\t}\n\t\telse if (curc == '\\n' && rex.reg_line_lbr)\n\t\t{\n\t\t    // match \\n as if it is an ordinary character\n\t\t    add_state = t->state->out;\n\t\t    add_off = 1;\n\t\t}\n\t\tbreak;\n\n\t    case NFA_START_COLL:\n\t    case NFA_START_NEG_COLL:\n\t      {\n\t\t// What follows is a list of characters, until NFA_END_COLL.\n\t\t// One of them must match or none of them must match.\n\t\tnfa_state_T\t*state;\n\t\tint\t\tresult_if_matched;\n\t\tint\t\tc1, c2;\n\n\t\t// Never match EOL. If it's part of the collection it is added\n\t\t// as a separate state with an OR.\n\t\tif (curc == NUL)\n\t\t    break;\n\n\t\tstate = t->state->out;\n\t\tresult_if_matched = (t->state->c == NFA_START_COLL);\n\t\tfor (;;)\n\t\t{\n\t\t    if (state->c == NFA_END_COLL)\n\t\t    {\n\t\t\tresult = !result_if_matched;\n\t\t\tbreak;\n\t\t    }\n\t\t    if (state->c == NFA_RANGE_MIN)\n\t\t    {\n\t\t\tc1 = state->val;\n\t\t\tstate = state->out; // advance to NFA_RANGE_MAX\n\t\t\tc2 = state->val;\n#ifdef ENABLE_LOG\n\t\t\tfprintf(log_fd, \"NFA_RANGE_MIN curc=%d c1=%d c2=%d\\n\",\n\t\t\t\tcurc, c1, c2);\n#endif\n\t\t\tif (curc >= c1 && curc <= c2)\n\t\t\t{\n\t\t\t    result = result_if_matched;\n\t\t\t    break;\n\t\t\t}\n\t\t\tif (rex.reg_ic)\n\t\t\t{\n\t\t\t    int curc_low = MB_CASEFOLD(curc);\n\t\t\t    int done = FALSE;\n\n\t\t\t    for ( ; c1 <= c2; ++c1)\n\t\t\t\tif (MB_CASEFOLD(c1) == curc_low)\n\t\t\t\t{\n\t\t\t\t    result = result_if_matched;\n\t\t\t\t    done = TRUE;\n\t\t\t\t    break;\n\t\t\t\t}\n\t\t\t    if (done)\n\t\t\t\tbreak;\n\t\t\t}\n\t\t    }\n\t\t    else if (state->c < 0 ? check_char_class(state->c, curc)\n\t\t\t       : (curc == state->c\n\t\t\t\t   || (rex.reg_ic && MB_CASEFOLD(curc)\n\t\t\t\t\t\t    == MB_CASEFOLD(state->c))))\n\t\t    {\n\t\t\tresult = result_if_matched;\n\t\t\tbreak;\n\t\t    }\n\t\t    state = state->out;\n\t\t}\n\t\tif (result)\n\t\t{\n\t\t    // next state is in out of the NFA_END_COLL, out1 of\n\t\t    // START points to the END state\n\t\t    add_state = t->state->out1->out;\n\t\t    add_off = clen;\n\t\t}\n\t\tbreak;\n\t      }\n\n\t    case NFA_ANY:\n\t\t// Any char except '\\0', (end of input) does not match.\n\t\tif (curc > 0)\n\t\t{\n\t\t    add_state = t->state->out;\n\t\t    add_off = clen;\n\t\t}\n\t\tbreak;\n\n\t    case NFA_ANY_COMPOSING:\n\t\t// On a composing character skip over it.  Otherwise do\n\t\t// nothing.  Always matches.\n\t\tif (enc_utf8 && utf_iscomposing(curc))\n\t\t{\n\t\t    add_off = clen;\n\t\t}\n\t\telse\n\t\t{\n\t\t    add_here = TRUE;\n\t\t    add_off = 0;\n\t\t}\n\t\tadd_state = t->state->out;\n\t\tbreak;\n\n\t    /*\n\t     * Character classes like \\a for alpha, \\d for digit etc.\n\t     */\n\t    case NFA_IDENT:\t//  \\i\n\t\tresult = vim_isIDc(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_SIDENT:\t//  \\I\n\t\tresult = !VIM_ISDIGIT(curc) && vim_isIDc(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_KWORD:\t//  \\k\n\t\tresult = vim_iswordp_buf(rex.input, rex.reg_buf);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_SKWORD:\t//  \\K\n\t\tresult = !VIM_ISDIGIT(curc)\n\t\t\t\t     && vim_iswordp_buf(rex.input, rex.reg_buf);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_FNAME:\t//  \\f\n\t\tresult = vim_isfilec(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_SFNAME:\t//  \\F\n\t\tresult = !VIM_ISDIGIT(curc) && vim_isfilec(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_PRINT:\t//  \\p\n\t\tresult = vim_isprintc(PTR2CHAR(rex.input));\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_SPRINT:\t//  \\P\n\t\tresult = !VIM_ISDIGIT(curc) && vim_isprintc(PTR2CHAR(rex.input));\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_WHITE:\t//  \\s\n\t\tresult = VIM_ISWHITE(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_NWHITE:\t//  \\S\n\t\tresult = curc != NUL && !VIM_ISWHITE(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_DIGIT:\t//  \\d\n\t\tresult = ri_digit(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_NDIGIT:\t//  \\D\n\t\tresult = curc != NUL && !ri_digit(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_HEX:\t//  \\x\n\t\tresult = ri_hex(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_NHEX:\t//  \\X\n\t\tresult = curc != NUL && !ri_hex(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_OCTAL:\t//  \\o\n\t\tresult = ri_octal(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_NOCTAL:\t//  \\O\n\t\tresult = curc != NUL && !ri_octal(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_WORD:\t//  \\w\n\t\tresult = ri_word(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_NWORD:\t//  \\W\n\t\tresult = curc != NUL && !ri_word(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_HEAD:\t//  \\h\n\t\tresult = ri_head(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_NHEAD:\t//  \\H\n\t\tresult = curc != NUL && !ri_head(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_ALPHA:\t//  \\a\n\t\tresult = ri_alpha(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_NALPHA:\t//  \\A\n\t\tresult = curc != NUL && !ri_alpha(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_LOWER:\t//  \\l\n\t\tresult = ri_lower(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_NLOWER:\t//  \\L\n\t\tresult = curc != NUL && !ri_lower(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_UPPER:\t//  \\u\n\t\tresult = ri_upper(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_NUPPER:\t// \\U\n\t\tresult = curc != NUL && !ri_upper(curc);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_LOWER_IC:\t// [a-z]\n\t\tresult = ri_lower(curc) || (rex.reg_ic && ri_upper(curc));\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_NLOWER_IC:\t// [^a-z]\n\t\tresult = curc != NUL\n\t\t\t&& !(ri_lower(curc) || (rex.reg_ic && ri_upper(curc)));\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_UPPER_IC:\t// [A-Z]\n\t\tresult = ri_upper(curc) || (rex.reg_ic && ri_lower(curc));\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_NUPPER_IC:\t// ^[A-Z]\n\t\tresult = curc != NUL\n\t\t\t&& !(ri_upper(curc) || (rex.reg_ic && ri_lower(curc)));\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\n\t    case NFA_BACKREF1:\n\t    case NFA_BACKREF2:\n\t    case NFA_BACKREF3:\n\t    case NFA_BACKREF4:\n\t    case NFA_BACKREF5:\n\t    case NFA_BACKREF6:\n\t    case NFA_BACKREF7:\n\t    case NFA_BACKREF8:\n\t    case NFA_BACKREF9:\n#ifdef FEAT_SYN_HL\n\t    case NFA_ZREF1:\n\t    case NFA_ZREF2:\n\t    case NFA_ZREF3:\n\t    case NFA_ZREF4:\n\t    case NFA_ZREF5:\n\t    case NFA_ZREF6:\n\t    case NFA_ZREF7:\n\t    case NFA_ZREF8:\n\t    case NFA_ZREF9:\n#endif\n\t\t// \\1 .. \\9  \\z1 .. \\z9\n\t      {\n\t\tint subidx;\n\t\tint bytelen;\n\n\t\tif (t->state->c <= NFA_BACKREF9)\n\t\t{\n\t\t    subidx = t->state->c - NFA_BACKREF1 + 1;\n\t\t    result = match_backref(&t->subs.norm, subidx, &bytelen);\n\t\t}\n#ifdef FEAT_SYN_HL\n\t\telse\n\t\t{\n\t\t    subidx = t->state->c - NFA_ZREF1 + 1;\n\t\t    result = match_zref(subidx, &bytelen);\n\t\t}\n#endif\n\n\t\tif (result)\n\t\t{\n\t\t    if (bytelen == 0)\n\t\t    {\n\t\t\t// empty match always works, output of NFA_SKIP to be\n\t\t\t// used next\n\t\t\tadd_here = TRUE;\n\t\t\tadd_state = t->state->out->out;\n\t\t    }\n\t\t    else if (bytelen <= clen)\n\t\t    {\n\t\t\t// match current character, jump ahead to out of\n\t\t\t// NFA_SKIP\n\t\t\tadd_state = t->state->out->out;\n\t\t\tadd_off = clen;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// skip over the matched characters, set character\n\t\t\t// count in NFA_SKIP\n\t\t\tadd_state = t->state->out;\n\t\t\tadd_off = bytelen;\n\t\t\tadd_count = bytelen - clen;\n\t\t    }\n\t\t}\n\t\tbreak;\n\t      }\n\t    case NFA_SKIP:\n\t      // character of previous matching \\1 .. \\9  or \\@>\n\t      if (t->count - clen <= 0)\n\t      {\n\t\t  // end of match, go to what follows\n\t\t  add_state = t->state->out;\n\t\t  add_off = clen;\n\t      }\n\t      else\n\t      {\n\t\t  // add state again with decremented count\n\t\t  add_state = t->state;\n\t\t  add_off = 0;\n\t\t  add_count = t->count - clen;\n\t      }\n\t      break;\n\n\t    case NFA_LNUM:\n\t    case NFA_LNUM_GT:\n\t    case NFA_LNUM_LT:\n\t\tresult = (REG_MULTI &&\n\t\t\tnfa_re_num_cmp(t->state->val, t->state->c - NFA_LNUM,\n\t\t\t    (long_u)(rex.lnum + rex.reg_firstlnum)));\n\t\tif (result)\n\t\t{\n\t\t    add_here = TRUE;\n\t\t    add_state = t->state->out;\n\t\t}\n\t\tbreak;\n\n\t    case NFA_COL:\n\t    case NFA_COL_GT:\n\t    case NFA_COL_LT:\n\t\tresult = nfa_re_num_cmp(t->state->val, t->state->c - NFA_COL,\n\t\t\t(long_u)(rex.input - rex.line) + 1);\n\t\tif (result)\n\t\t{\n\t\t    add_here = TRUE;\n\t\t    add_state = t->state->out;\n\t\t}\n\t\tbreak;\n\n\t    case NFA_VCOL:\n\t    case NFA_VCOL_GT:\n\t    case NFA_VCOL_LT:\n\t\t{\n\t\t    int     op = t->state->c - NFA_VCOL;\n\t\t    colnr_T col = (colnr_T)(rex.input - rex.line);\n\t\t    win_T   *wp = rex.reg_win == NULL ? curwin : rex.reg_win;\n\n\t\t    // Bail out quickly when there can't be a match, avoid the\n\t\t    // overhead of win_linetabsize() on long lines.\n\t\t    if (op != 1 && col > t->state->val\n\t\t\t    * (has_mbyte ? MB_MAXBYTES : 1))\n\t\t\tbreak;\n\t\t    result = FALSE;\n\t\t    if (op == 1 && col - 1 > t->state->val && col > 100)\n\t\t    {\n\t\t\tint ts = wp->w_buffer->b_p_ts;\n\n\t\t\t// Guess that a character won't use more columns than\n\t\t\t// 'tabstop', with a minimum of 4.\n\t\t\tif (ts < 4)\n\t\t\t    ts = 4;\n\t\t\tresult = col > t->state->val * ts;\n\t\t    }\n\t\t    if (!result)\n\t\t\tresult = nfa_re_num_cmp(t->state->val, op,\n\t\t\t\t(long_u)win_linetabsize(wp, rex.line, col) + 1);\n\t\t    if (result)\n\t\t    {\n\t\t\tadd_here = TRUE;\n\t\t\tadd_state = t->state->out;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t    case NFA_MARK:\n\t    case NFA_MARK_GT:\n\t    case NFA_MARK_LT:\n\t      {\n\t\tsize_t\tcol = rex.input - rex.line;\n\t\tpos_T\t*pos = getmark_buf(rex.reg_buf, t->state->val, FALSE);\n\n\t\t// Line may have been freed, get it again.\n\t\tif (REG_MULTI)\n\t\t{\n\t\t    rex.line = reg_getline(rex.lnum);\n\t\t    rex.input = rex.line + col;\n\t\t}\n\n\t\t// Compare the mark position to the match position, if the mark\n\t\t// exists and mark is set in reg_buf.\n\t\tif (pos != NULL && pos->lnum > 0)\n\t\t{\n\t\t    colnr_T pos_col = pos->lnum == rex.lnum + rex.reg_firstlnum\n\t\t\t\t\t\t\t  && pos->col == MAXCOL\n\t\t\t\t      ? (colnr_T)STRLEN(reg_getline(\n\t\t\t\t\t\tpos->lnum - rex.reg_firstlnum))\n\t\t\t\t      : pos->col;\n\n\t\t    result = (pos->lnum == rex.lnum + rex.reg_firstlnum\n\t\t\t\t? (pos_col == (colnr_T)(rex.input - rex.line)\n\t\t\t\t    ? t->state->c == NFA_MARK\n\t\t\t\t    : (pos_col < (colnr_T)(rex.input - rex.line)\n\t\t\t\t\t? t->state->c == NFA_MARK_GT\n\t\t\t\t\t: t->state->c == NFA_MARK_LT))\n\t\t\t\t: (pos->lnum < rex.lnum + rex.reg_firstlnum\n\t\t\t\t    ? t->state->c == NFA_MARK_GT\n\t\t\t\t    : t->state->c == NFA_MARK_LT));\n\t\t    if (result)\n\t\t    {\n\t\t\tadd_here = TRUE;\n\t\t\tadd_state = t->state->out;\n\t\t    }\n\t\t}\n\t\tbreak;\n\t      }\n\n\t    case NFA_CURSOR:\n\t\tresult = (rex.reg_win != NULL\n\t\t\t&& (rex.lnum + rex.reg_firstlnum\n\t\t\t\t\t\t == rex.reg_win->w_cursor.lnum)\n\t\t\t&& ((colnr_T)(rex.input - rex.line)\n\t\t\t\t\t\t== rex.reg_win->w_cursor.col));\n\t\tif (result)\n\t\t{\n\t\t    add_here = TRUE;\n\t\t    add_state = t->state->out;\n\t\t}\n\t\tbreak;\n\n\t    case NFA_VISUAL:\n\t\tresult = reg_match_visual();\n\t\tif (result)\n\t\t{\n\t\t    add_here = TRUE;\n\t\t    add_state = t->state->out;\n\t\t}\n\t\tbreak;\n\n\t    case NFA_MOPEN1:\n\t    case NFA_MOPEN2:\n\t    case NFA_MOPEN3:\n\t    case NFA_MOPEN4:\n\t    case NFA_MOPEN5:\n\t    case NFA_MOPEN6:\n\t    case NFA_MOPEN7:\n\t    case NFA_MOPEN8:\n\t    case NFA_MOPEN9:\n#ifdef FEAT_SYN_HL\n\t    case NFA_ZOPEN:\n\t    case NFA_ZOPEN1:\n\t    case NFA_ZOPEN2:\n\t    case NFA_ZOPEN3:\n\t    case NFA_ZOPEN4:\n\t    case NFA_ZOPEN5:\n\t    case NFA_ZOPEN6:\n\t    case NFA_ZOPEN7:\n\t    case NFA_ZOPEN8:\n\t    case NFA_ZOPEN9:\n#endif\n\t    case NFA_NOPEN:\n\t    case NFA_ZSTART:\n\t\t// These states are only added to be able to bail out when\n\t\t// they are added again, nothing is to be done.\n\t\tbreak;\n\n\t    default:\t// regular character\n\t      {\n\t\tint c = t->state->c;\n\n#ifdef DEBUG\n\t\tif (c < 0)\n\t\t    siemsg(\"INTERNAL: Negative state char: %ld\", c);\n#endif\n\t\tresult = (c == curc);\n\n\t\tif (!result && rex.reg_ic)\n\t\t    result = MB_CASEFOLD(c) == MB_CASEFOLD(curc);\n\t\t// If rex.reg_icombine is not set only skip over the character\n\t\t// itself.  When it is set skip over composing characters.\n\t\tif (result && enc_utf8 && !rex.reg_icombine)\n\t\t    clen = utf_ptr2len(rex.input);\n\t\tADD_STATE_IF_MATCH(t->state);\n\t\tbreak;\n\t      }\n\n\t    } // switch (t->state->c)\n\n\t    if (add_state != NULL)\n\t    {\n\t\tnfa_pim_T *pim;\n\t\tnfa_pim_T pim_copy;\n\n\t\tif (t->pim.result == NFA_PIM_UNUSED)\n\t\t    pim = NULL;\n\t\telse\n\t\t    pim = &t->pim;\n\n\t\t// Handle the postponed invisible match if the match might end\n\t\t// without advancing and before the end of the line.\n\t\tif (pim != NULL && (clen == 0 || match_follows(add_state, 0)))\n\t\t{\n\t\t    if (pim->result == NFA_PIM_TODO)\n\t\t    {\n#ifdef ENABLE_LOG\n\t\t\tfprintf(log_fd, \"\\n\");\n\t\t\tfprintf(log_fd, \"==================================\\n\");\n\t\t\tfprintf(log_fd, \"Postponed recursive nfa_regmatch()\\n\");\n\t\t\tfprintf(log_fd, \"\\n\");\n#endif\n\t\t\tresult = recursive_regmatch(pim->state, pim,\n\t\t\t\t    prog, submatch, m, &listids, &listids_len);\n\t\t\tpim->result = result ? NFA_PIM_MATCH : NFA_PIM_NOMATCH;\n\t\t\t// for \\@! and \\@<! it is a match when the result is\n\t\t\t// FALSE\n\t\t\tif (result != (pim->state->c == NFA_START_INVISIBLE_NEG\n\t\t\t     || pim->state->c == NFA_START_INVISIBLE_NEG_FIRST\n\t\t\t     || pim->state->c\n\t\t\t\t\t   == NFA_START_INVISIBLE_BEFORE_NEG\n\t\t\t     || pim->state->c\n\t\t\t\t     == NFA_START_INVISIBLE_BEFORE_NEG_FIRST))\n\t\t\t{\n\t\t\t    // Copy submatch info from the recursive call\n\t\t\t    copy_sub_off(&pim->subs.norm, &m->norm);\n#ifdef FEAT_SYN_HL\n\t\t\t    if (rex.nfa_has_zsubexpr)\n\t\t\t\tcopy_sub_off(&pim->subs.synt, &m->synt);\n#endif\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tresult = (pim->result == NFA_PIM_MATCH);\n#ifdef ENABLE_LOG\n\t\t\tfprintf(log_fd, \"\\n\");\n\t\t\tfprintf(log_fd, \"Using previous recursive nfa_regmatch() result, result == %d\\n\", pim->result);\n\t\t\tfprintf(log_fd, \"MATCH = %s\\n\", result == TRUE ? \"OK\" : \"FALSE\");\n\t\t\tfprintf(log_fd, \"\\n\");\n#endif\n\t\t    }\n\n\t\t    // for \\@! and \\@<! it is a match when result is FALSE\n\t\t    if (result != (pim->state->c == NFA_START_INVISIBLE_NEG\n\t\t\t     || pim->state->c == NFA_START_INVISIBLE_NEG_FIRST\n\t\t\t     || pim->state->c\n\t\t\t\t\t   == NFA_START_INVISIBLE_BEFORE_NEG\n\t\t\t     || pim->state->c\n\t\t\t\t     == NFA_START_INVISIBLE_BEFORE_NEG_FIRST))\n\t\t    {\n\t\t\t// Copy submatch info from the recursive call\n\t\t\tcopy_sub_off(&t->subs.norm, &pim->subs.norm);\n#ifdef FEAT_SYN_HL\n\t\t\tif (rex.nfa_has_zsubexpr)\n\t\t\t    copy_sub_off(&t->subs.synt, &pim->subs.synt);\n#endif\n\t\t    }\n\t\t    else\n\t\t\t// look-behind match failed, don't add the state\n\t\t\tcontinue;\n\n\t\t    // Postponed invisible match was handled, don't add it to\n\t\t    // following states.\n\t\t    pim = NULL;\n\t\t}\n\n\t\t// If \"pim\" points into l->t it will become invalid when\n\t\t// adding the state causes the list to be reallocated.  Make a\n\t\t// local copy to avoid that.\n\t\tif (pim == &t->pim)\n\t\t{\n\t\t    copy_pim(&pim_copy, pim);\n\t\t    pim = &pim_copy;\n\t\t}\n\n\t\tif (add_here)\n\t\t    r = addstate_here(thislist, add_state, &t->subs,\n\t\t\t\t\t\t\t\tpim, &listidx);\n\t\telse\n\t\t{\n\t\t    r = addstate(nextlist, add_state, &t->subs, pim, add_off);\n\t\t    if (add_count > 0)\n\t\t\tnextlist->t[nextlist->n - 1].count = add_count;\n\t\t}\n\t\tif (r == NULL)\n\t\t{\n\t\t    nfa_match = NFA_TOO_EXPENSIVE;\n\t\t    goto theend;\n\t\t}\n\t    }\n\n\t} // for (thislist = thislist; thislist->state; thislist++)\n\n\t// Look for the start of a match in the current position by adding the\n\t// start state to the list of states.\n\t// The first found match is the leftmost one, thus the order of states\n\t// matters!\n\t// Do not add the start state in recursive calls of nfa_regmatch(),\n\t// because recursive calls should only start in the first position.\n\t// Unless \"nfa_endp\" is not NULL, then we match the end position.\n\t// Also don't start a match past the first line.\n\tif (nfa_match == FALSE\n\t\t&& ((toplevel\n\t\t\t&& rex.lnum == 0\n\t\t\t&& clen != 0\n\t\t\t&& (rex.reg_maxcol == 0\n\t\t\t    || (colnr_T)(rex.input - rex.line) < rex.reg_maxcol))\n\t\t    || (nfa_endp != NULL\n\t\t\t&& (REG_MULTI\n\t\t\t    ? (rex.lnum < nfa_endp->se_u.pos.lnum\n\t\t\t       || (rex.lnum == nfa_endp->se_u.pos.lnum\n\t\t\t\t   && (int)(rex.input - rex.line)\n\t\t\t\t\t\t    < nfa_endp->se_u.pos.col))\n\t\t\t    : rex.input < nfa_endp->se_u.ptr))))\n\t{\n#ifdef ENABLE_LOG\n\t    fprintf(log_fd, \"(---) STARTSTATE\\n\");\n#endif\n\t    // Inline optimized code for addstate() if we know the state is\n\t    // the first MOPEN.\n\t    if (toplevel)\n\t    {\n\t\tint add = TRUE;\n\t\tint c;\n\n\t\tif (prog->regstart != NUL && clen != 0)\n\t\t{\n\t\t    if (nextlist->n == 0)\n\t\t    {\n\t\t\tcolnr_T col = (colnr_T)(rex.input - rex.line) + clen;\n\n\t\t\t// Nextlist is empty, we can skip ahead to the\n\t\t\t// character that must appear at the start.\n\t\t\tif (skip_to_start(prog->regstart, &col) == FAIL)\n\t\t\t    break;\n#ifdef ENABLE_LOG\n\t\t\tfprintf(log_fd, \"  Skipping ahead %d bytes to regstart\\n\",\n\t\t\t\tcol - ((colnr_T)(rex.input - rex.line) + clen));\n#endif\n\t\t\trex.input = rex.line + col - clen;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// Checking if the required start character matches is\n\t\t\t// cheaper than adding a state that won't match.\n\t\t\tc = PTR2CHAR(rex.input + clen);\n\t\t\tif (c != prog->regstart && (!rex.reg_ic\n\t\t\t     || MB_CASEFOLD(c) != MB_CASEFOLD(prog->regstart)))\n\t\t\t{\n#ifdef ENABLE_LOG\n\t\t\t    fprintf(log_fd, \"  Skipping start state, regstart does not match\\n\");\n#endif\n\t\t\t    add = FALSE;\n\t\t\t}\n\t\t    }\n\t\t}\n\n\t\tif (add)\n\t\t{\n\t\t    if (REG_MULTI)\n\t\t\tm->norm.list.multi[0].start_col =\n\t\t\t\t\t (colnr_T)(rex.input - rex.line) + clen;\n\t\t    else\n\t\t\tm->norm.list.line[0].start = rex.input + clen;\n\t\t    if (addstate(nextlist, start->out, m, NULL, clen) == NULL)\n\t\t    {\n\t\t\tnfa_match = NFA_TOO_EXPENSIVE;\n\t\t\tgoto theend;\n\t\t    }\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tif (addstate(nextlist, start, m, NULL, clen) == NULL)\n\t\t{\n\t\t    nfa_match = NFA_TOO_EXPENSIVE;\n\t\t    goto theend;\n\t\t}\n\t    }\n\t}\n\n#ifdef ENABLE_LOG\n\tfprintf(log_fd, \">>> Thislist had %d states available: \", thislist->n);\n\t{\n\t    int i;\n\n\t    for (i = 0; i < thislist->n; i++)\n\t\tfprintf(log_fd, \"%d  \", abs(thislist->t[i].state->id));\n\t}\n\tfprintf(log_fd, \"\\n\");\n#endif\n\nnextchar:\n\t// Advance to the next character, or advance to the next line, or\n\t// finish.\n\tif (clen != 0)\n\t    rex.input += clen;\n\telse if (go_to_nextline || (nfa_endp != NULL && REG_MULTI\n\t\t\t\t\t&& rex.lnum < nfa_endp->se_u.pos.lnum))\n\t    reg_nextline();\n\telse\n\t    break;\n\n\t// Allow interrupting with CTRL-C.\n\tline_breakcheck();\n\tif (got_int)\n\t    break;\n#ifdef FEAT_RELTIME\n\t// Check for timeout once in a twenty times to avoid overhead.\n\tif (nfa_time_limit != NULL && ++nfa_time_count == 20)\n\t{\n\t    nfa_time_count = 0;\n\t    if (nfa_did_time_out())\n\t\tbreak;\n\t}\n#endif\n    }\n\n#ifdef ENABLE_LOG\n    if (log_fd != stderr)\n\tfclose(log_fd);\n    log_fd = NULL;\n#endif\n\ntheend:\n    // Free memory\n    vim_free(list[0].t);\n    vim_free(list[1].t);\n    vim_free(listids);\n#undef ADD_STATE_IF_MATCH\n#ifdef NFA_REGEXP_DEBUG_LOG\n    fclose(debug);\n#endif\n\n    return nfa_match;\n}\n\n/*\n * Try match of \"prog\" with at rex.line[\"col\"].\n * Returns <= 0 for failure, number of lines contained in the match otherwise.\n */\n    static long\nnfa_regtry(\n    nfa_regprog_T   *prog,\n    colnr_T\t    col,\n    proftime_T\t    *tm UNUSED,\t// timeout limit or NULL\n    int\t\t    *timed_out UNUSED)\t// flag set on timeout or NULL\n{\n    int\t\ti;\n    regsubs_T\tsubs, m;\n    nfa_state_T\t*start = prog->start;\n    int\t\tresult;\n#ifdef ENABLE_LOG\n    FILE\t*f;\n#endif\n\n    rex.input = rex.line + col;\n#ifdef FEAT_RELTIME\n    nfa_time_limit = tm;\n    nfa_timed_out = timed_out;\n    nfa_time_count = 0;\n#endif\n\n#ifdef ENABLE_LOG\n    f = fopen(NFA_REGEXP_RUN_LOG, \"a\");\n    if (f != NULL)\n    {\n\tfprintf(f, \"\\n\\n\\t=======================================================\\n\");\n#ifdef DEBUG\n\tfprintf(f, \"\\tRegexp is \\\"%s\\\"\\n\", nfa_regengine.expr);\n#endif\n\tfprintf(f, \"\\tInput text is \\\"%s\\\" \\n\", rex.input);\n\tfprintf(f, \"\\t=======================================================\\n\\n\");\n\tnfa_print_state(f, start);\n\tfprintf(f, \"\\n\\n\");\n\tfclose(f);\n    }\n    else\n\temsg(\"Could not open temporary log file for writing\");\n#endif\n\n    clear_sub(&subs.norm);\n    clear_sub(&m.norm);\n#ifdef FEAT_SYN_HL\n    clear_sub(&subs.synt);\n    clear_sub(&m.synt);\n#endif\n\n    result = nfa_regmatch(prog, start, &subs, &m);\n    if (result == FALSE)\n\treturn 0;\n    else if (result == NFA_TOO_EXPENSIVE)\n\treturn result;\n\n    cleanup_subexpr();\n    if (REG_MULTI)\n    {\n\tfor (i = 0; i < subs.norm.in_use; i++)\n\t{\n\t    rex.reg_startpos[i].lnum = subs.norm.list.multi[i].start_lnum;\n\t    rex.reg_startpos[i].col = subs.norm.list.multi[i].start_col;\n\n\t    rex.reg_endpos[i].lnum = subs.norm.list.multi[i].end_lnum;\n\t    rex.reg_endpos[i].col = subs.norm.list.multi[i].end_col;\n\t}\n\n\tif (rex.reg_startpos[0].lnum < 0)\n\t{\n\t    rex.reg_startpos[0].lnum = 0;\n\t    rex.reg_startpos[0].col = col;\n\t}\n\tif (rex.reg_endpos[0].lnum < 0)\n\t{\n\t    // pattern has a \\ze but it didn't match, use current end\n\t    rex.reg_endpos[0].lnum = rex.lnum;\n\t    rex.reg_endpos[0].col = (int)(rex.input - rex.line);\n\t}\n\telse\n\t    // Use line number of \"\\ze\".\n\t    rex.lnum = rex.reg_endpos[0].lnum;\n    }\n    else\n    {\n\tfor (i = 0; i < subs.norm.in_use; i++)\n\t{\n\t    rex.reg_startp[i] = subs.norm.list.line[i].start;\n\t    rex.reg_endp[i] = subs.norm.list.line[i].end;\n\t}\n\n\tif (rex.reg_startp[0] == NULL)\n\t    rex.reg_startp[0] = rex.line + col;\n\tif (rex.reg_endp[0] == NULL)\n\t    rex.reg_endp[0] = rex.input;\n    }\n\n#ifdef FEAT_SYN_HL\n    // Package any found \\z(...\\) matches for export. Default is none.\n    unref_extmatch(re_extmatch_out);\n    re_extmatch_out = NULL;\n\n    if (prog->reghasz == REX_SET)\n    {\n\tcleanup_zsubexpr();\n\tre_extmatch_out = make_extmatch();\n\tif (re_extmatch_out == NULL)\n\t    return 0;\n\t// Loop over \\z1, \\z2, etc.  There is no \\z0.\n\tfor (i = 1; i < subs.synt.in_use; i++)\n\t{\n\t    if (REG_MULTI)\n\t    {\n\t\tstruct multipos *mpos = &subs.synt.list.multi[i];\n\n\t\t// Only accept single line matches that are valid.\n\t\tif (mpos->start_lnum >= 0\n\t\t\t&& mpos->start_lnum == mpos->end_lnum\n\t\t\t&& mpos->end_col >= mpos->start_col)\n\t\t    re_extmatch_out->matches[i] =\n\t\t\tvim_strnsave(reg_getline(mpos->start_lnum)\n\t\t\t\t\t\t\t    + mpos->start_col,\n\t\t\t\t\t     mpos->end_col - mpos->start_col);\n\t    }\n\t    else\n\t    {\n\t\tstruct linepos *lpos = &subs.synt.list.line[i];\n\n\t\tif (lpos->start != NULL && lpos->end != NULL)\n\t\t    re_extmatch_out->matches[i] =\n\t\t\t    vim_strnsave(lpos->start, lpos->end - lpos->start);\n\t    }\n\t}\n    }\n#endif\n\n    return 1 + rex.lnum;\n}\n\n/*\n * Match a regexp against a string (\"line\" points to the string) or multiple\n * lines (if \"line\" is NULL, use reg_getline()).\n *\n * Returns <= 0 for failure, number of lines contained in the match otherwise.\n */\n    static long\nnfa_regexec_both(\n    char_u\t*line,\n    colnr_T\tstartcol,\t// column to start looking for match\n    proftime_T\t*tm,\t\t// timeout limit or NULL\n    int\t\t*timed_out)\t// flag set on timeout or NULL\n{\n    nfa_regprog_T   *prog;\n    long\t    retval = 0L;\n    int\t\t    i;\n    colnr_T\t    col = startcol;\n\n    if (REG_MULTI)\n    {\n\tprog = (nfa_regprog_T *)rex.reg_mmatch->regprog;\n\tline = reg_getline((linenr_T)0);    // relative to the cursor\n\trex.reg_startpos = rex.reg_mmatch->startpos;\n\trex.reg_endpos = rex.reg_mmatch->endpos;\n    }\n    else\n    {\n\tprog = (nfa_regprog_T *)rex.reg_match->regprog;\n\trex.reg_startp = rex.reg_match->startp;\n\trex.reg_endp = rex.reg_match->endp;\n    }\n\n    // Be paranoid...\n    if (prog == NULL || line == NULL)\n    {\n\tiemsg(_(e_null_argument));\n\tgoto theend;\n    }\n\n    // If pattern contains \"\\c\" or \"\\C\": overrule value of rex.reg_ic\n    if (prog->regflags & RF_ICASE)\n\trex.reg_ic = TRUE;\n    else if (prog->regflags & RF_NOICASE)\n\trex.reg_ic = FALSE;\n\n    // If pattern contains \"\\Z\" overrule value of rex.reg_icombine\n    if (prog->regflags & RF_ICOMBINE)\n\trex.reg_icombine = TRUE;\n\n    rex.line = line;\n    rex.lnum = 0;    // relative to line\n\n    rex.nfa_has_zend = prog->has_zend;\n    rex.nfa_has_backref = prog->has_backref;\n    rex.nfa_nsubexpr = prog->nsubexp;\n    rex.nfa_listid = 1;\n    rex.nfa_alt_listid = 2;\n#ifdef DEBUG\n    nfa_regengine.expr = prog->pattern;\n#endif\n\n    if (prog->reganch && col > 0)\n\treturn 0L;\n\n    rex.need_clear_subexpr = TRUE;\n#ifdef FEAT_SYN_HL\n    // Clear the external match subpointers if necessary.\n    if (prog->reghasz == REX_SET)\n    {\n\trex.nfa_has_zsubexpr = TRUE;\n\trex.need_clear_zsubexpr = TRUE;\n    }\n    else\n    {\n\trex.nfa_has_zsubexpr = FALSE;\n\trex.need_clear_zsubexpr = FALSE;\n    }\n#endif\n\n    if (prog->regstart != NUL)\n    {\n\t// Skip ahead until a character we know the match must start with.\n\t// When there is none there is no match.\n\tif (skip_to_start(prog->regstart, &col) == FAIL)\n\t    return 0L;\n\n\t// If match_text is set it contains the full text that must match.\n\t// Nothing else to try. Doesn't handle combining chars well.\n\tif (prog->match_text != NULL && !rex.reg_icombine)\n\t    return find_match_text(col, prog->regstart, prog->match_text);\n    }\n\n    // If the start column is past the maximum column: no need to try.\n    if (rex.reg_maxcol > 0 && col >= rex.reg_maxcol)\n\tgoto theend;\n\n    // Set the \"nstate\" used by nfa_regcomp() to zero to trigger an error when\n    // it's accidentally used during execution.\n    nstate = 0;\n    for (i = 0; i < prog->nstate; ++i)\n    {\n\tprog->state[i].id = i;\n\tprog->state[i].lastlist[0] = 0;\n\tprog->state[i].lastlist[1] = 0;\n    }\n\n    retval = nfa_regtry(prog, col, tm, timed_out);\n\n#ifdef DEBUG\n    nfa_regengine.expr = NULL;\n#endif\n\ntheend:\n    if (retval > 0)\n    {\n\t// Make sure the end is never before the start.  Can happen when \\zs and\n\t// \\ze are used.\n\tif (REG_MULTI)\n\t{\n\t    lpos_T *start = &rex.reg_mmatch->startpos[0];\n\t    lpos_T *end = &rex.reg_mmatch->endpos[0];\n\n\t    if (end->lnum < start->lnum\n\t\t\t|| (end->lnum == start->lnum && end->col < start->col))\n\t\trex.reg_mmatch->endpos[0] = rex.reg_mmatch->startpos[0];\n\t}\n\telse\n\t{\n\t    if (rex.reg_match->endp[0] < rex.reg_match->startp[0])\n\t\trex.reg_match->endp[0] = rex.reg_match->startp[0];\n\t}\n    }\n\n    return retval;\n}\n\n/*\n * Compile a regular expression into internal code for the NFA matcher.\n * Returns the program in allocated space.  Returns NULL for an error.\n */\n    static regprog_T *\nnfa_regcomp(char_u *expr, int re_flags)\n{\n    nfa_regprog_T\t*prog = NULL;\n    size_t\t\tprog_size;\n    int\t\t\t*postfix;\n\n    if (expr == NULL)\n\treturn NULL;\n\n#ifdef DEBUG\n    nfa_regengine.expr = expr;\n#endif\n    nfa_re_flags = re_flags;\n\n    init_class_tab();\n\n    if (nfa_regcomp_start(expr, re_flags) == FAIL)\n\treturn NULL;\n\n    // Build postfix form of the regexp. Needed to build the NFA\n    // (and count its size).\n    postfix = re2post();\n    if (postfix == NULL)\n\tgoto fail;\t    // Cascaded (syntax?) error\n\n    /*\n     * In order to build the NFA, we parse the input regexp twice:\n     * 1. first pass to count size (so we can allocate space)\n     * 2. second to emit code\n     */\n#ifdef ENABLE_LOG\n    {\n\tFILE *f = fopen(NFA_REGEXP_RUN_LOG, \"a\");\n\n\tif (f != NULL)\n\t{\n\t    fprintf(f, \"\\n*****************************\\n\\n\\n\\n\\tCompiling regexp \\\"%s\\\"... hold on !\\n\", expr);\n\t    fclose(f);\n\t}\n    }\n#endif\n\n    /*\n     * PASS 1\n     * Count number of NFA states in \"nstate\". Do not build the NFA.\n     */\n    post2nfa(postfix, post_ptr, TRUE);\n\n    // allocate the regprog with space for the compiled regexp\n    prog_size = sizeof(nfa_regprog_T) + sizeof(nfa_state_T) * (nstate - 1);\n    prog = alloc(prog_size);\n    if (prog == NULL)\n\tgoto fail;\n    state_ptr = prog->state;\n    prog->re_in_use = FALSE;\n\n    /*\n     * PASS 2\n     * Build the NFA\n     */\n    prog->start = post2nfa(postfix, post_ptr, FALSE);\n    if (prog->start == NULL)\n\tgoto fail;\n\n    prog->regflags = regflags;\n    prog->engine = &nfa_regengine;\n    prog->nstate = nstate;\n    prog->has_zend = rex.nfa_has_zend;\n    prog->has_backref = rex.nfa_has_backref;\n    prog->nsubexp = regnpar;\n\n    nfa_postprocess(prog);\n\n    prog->reganch = nfa_get_reganch(prog->start, 0);\n    prog->regstart = nfa_get_regstart(prog->start, 0);\n    prog->match_text = nfa_get_match_text(prog->start);\n\n#ifdef ENABLE_LOG\n    nfa_postfix_dump(expr, OK);\n    nfa_dump(prog);\n#endif\n#ifdef FEAT_SYN_HL\n    // Remember whether this pattern has any \\z specials in it.\n    prog->reghasz = re_has_z;\n#endif\n    prog->pattern = vim_strsave(expr);\n#ifdef DEBUG\n    nfa_regengine.expr = NULL;\n#endif\n\nout:\n    VIM_CLEAR(post_start);\n    post_ptr = post_end = NULL;\n    state_ptr = NULL;\n    return (regprog_T *)prog;\n\nfail:\n    VIM_CLEAR(prog);\n#ifdef ENABLE_LOG\n    nfa_postfix_dump(expr, FAIL);\n#endif\n#ifdef DEBUG\n    nfa_regengine.expr = NULL;\n#endif\n    goto out;\n}\n\n/*\n * Free a compiled regexp program, returned by nfa_regcomp().\n */\n    static void\nnfa_regfree(regprog_T *prog)\n{\n    if (prog != NULL)\n    {\n\tvim_free(((nfa_regprog_T *)prog)->match_text);\n\tvim_free(((nfa_regprog_T *)prog)->pattern);\n\tvim_free(prog);\n    }\n}\n\n/*\n * Match a regexp against a string.\n * \"rmp->regprog\" is a compiled regexp as returned by nfa_regcomp().\n * Uses curbuf for line count and 'iskeyword'.\n * If \"line_lbr\" is TRUE consider a \"\\n\" in \"line\" to be a line break.\n *\n * Returns <= 0 for failure, number of lines contained in the match otherwise.\n */\n    static int\nnfa_regexec_nl(\n    regmatch_T\t*rmp,\n    char_u\t*line,\t// string to match against\n    colnr_T\tcol,\t// column to start looking for match\n    int\t\tline_lbr)\n{\n    rex.reg_match = rmp;\n    rex.reg_mmatch = NULL;\n    rex.reg_maxline = 0;\n    rex.reg_line_lbr = line_lbr;\n    rex.reg_buf = curbuf;\n    rex.reg_win = NULL;\n    rex.reg_ic = rmp->rm_ic;\n    rex.reg_icombine = FALSE;\n    rex.reg_maxcol = 0;\n    return nfa_regexec_both(line, col, NULL, NULL);\n}\n\n\n/*\n * Match a regexp against multiple lines.\n * \"rmp->regprog\" is a compiled regexp as returned by vim_regcomp().\n * Uses curbuf for line count and 'iskeyword'.\n *\n * Return <= 0 if there is no match.  Return number of lines contained in the\n * match otherwise.\n *\n * Note: the body is the same as bt_regexec() except for nfa_regexec_both()\n *\n * ! Also NOTE : match may actually be in another line. e.g.:\n * when r.e. is \\nc, cursor is at 'a' and the text buffer looks like\n *\n * +-------------------------+\n * |a                        |\n * |b                        |\n * |c                        |\n * |                         |\n * +-------------------------+\n *\n * then nfa_regexec_multi() returns 3. while the original\n * vim_regexec_multi() returns 0 and a second call at line 2 will return 2.\n *\n * FIXME if this behavior is not compatible.\n */\n    static long\nnfa_regexec_multi(\n    regmmatch_T\t*rmp,\n    win_T\t*win,\t\t// window in which to search or NULL\n    buf_T\t*buf,\t\t// buffer in which to search\n    linenr_T\tlnum,\t\t// nr of line to start looking for match\n    colnr_T\tcol,\t\t// column to start looking for match\n    proftime_T\t*tm,\t\t// timeout limit or NULL\n    int\t\t*timed_out)\t// flag set on timeout or NULL\n{\n    init_regexec_multi(rmp, win, buf, lnum);\n    return nfa_regexec_both(NULL, col, tm, timed_out);\n}\n\n#ifdef DEBUG\n# undef ENABLE_LOG\n#endif\n", "\" Tests for regexp in latin1 encoding\n\nset encoding=latin1\nscriptencoding latin1\n\nsource check.vim\n\nfunc s:equivalence_test()\n  let str = \"A\u0410\u0411\u0412\u0413\u0414\u0415 B C D E\u0418\u0419\u041a\u041b F G H I\u041c\u041d\u041e\u041f J K L M N\u0421 O\u0422\u0423\u0424\u0425\u0426\u0428 P Q R S T U\u0429\u042a\u042b\u042c V W X Y\u042d Z a\u0430\u0431\u0432\u0433\u0434\u0435 b c d e\u0438\u0439\u043a\u043b f g h i\u043c\u043d\u043e\u043f j k l m n\u0441 o\u0442\u0443\u0444\u0445\u0446\u0448 p q r s t u\u0449\u044a\u044b\u044c v w x y\u044d\u044f z\"\n  let groups = split(str)\n  for group1 in groups\n      for c in split(group1, '\\zs')\n\t\" next statement confirms that equivalence class matches every\n\t\" character in group\n        call assert_match('^[[=' . c . '=]]*$', group1)\n        for group2 in groups\n          if group2 != group1\n\t    \" next statement converts that equivalence class doesn't match\n\t    \" a character in any other group\n            call assert_equal(-1, match(group2, '[[=' . c . '=]]'))\n          endif\n        endfor\n      endfor\n  endfor\nendfunc\n\nfunc Test_equivalence_re1()\n  set re=1\n  call s:equivalence_test()\nendfunc\n\nfunc Test_equivalence_re2()\n  set re=2\n  call s:equivalence_test()\nendfunc\n\nfunc Test_recursive_substitute()\n  new\n  s/^/\\=execute(\"s#^##gn\")\n  \" check we are now not in the sandbox\n  call setwinvar(1, 'myvar', 1)\n  bwipe!\nendfunc\n\nfunc Test_nested_backrefs()\n  \" Check example in change.txt.\n  new\n  for re in range(0, 2)\n    exe 'set re=' . re\n    call setline(1, 'aa ab x')\n    1s/\\(\\(a[a-d] \\)*\\)\\(x\\)/-\\1- -\\2- -\\3-/\n    call assert_equal('-aa ab - -ab - -x-', getline(1))\n\n    call assert_equal('-aa ab - -ab - -x-', substitute('aa ab x', '\\(\\(a[a-d] \\)*\\)\\(x\\)', '-\\1- -\\2- -\\3-', ''))\n  endfor\n  bwipe!\n  set re=0\nendfunc\n\nfunc Test_eow_with_optional()\n  let expected = ['abc def', 'abc', 'def', '', '', '', '', '', '', '']\n  for re in range(0, 2)\n    exe 'set re=' . re\n    let actual = matchlist('abc def', '\\(abc\\>\\)\\?\\s*\\(def\\)')\n    call assert_equal(expected, actual)\n  endfor\nendfunc\n\nfunc Test_backref()\n  new\n  call setline(1, ['one', 'two', 'three', 'four', 'five'])\n  call assert_equal(3, search('\\%#=1\\(e\\)\\1'))\n  call assert_equal(3, search('\\%#=2\\(e\\)\\1'))\n  call assert_fails('call search(\"\\\\%#=1\\\\(e\\\\1\\\\)\")', 'E65:')\n  call assert_fails('call search(\"\\\\%#=2\\\\(e\\\\1\\\\)\")', 'E65:')\n  bwipe!\nendfunc\n\nfunc Test_multi_failure()\n  set re=1\n  call assert_fails('/a**', 'E61:')\n  call assert_fails('/a*\\+', 'E62:')\n  call assert_fails('/a\\{a}', 'E554:')\n  set re=2\n  call assert_fails('/a**', 'E871:')\n  call assert_fails('/a*\\+', 'E871:')\n  call assert_fails('/a\\{a}', 'E554:')\n  set re=0\nendfunc\n\nfunc Test_recursive_addstate()\n  \" This will call addstate() recursively until it runs into the limit.\n  let lnum = search('\\v((){328}){389}')\n  call assert_equal(0, lnum)\nendfunc\n\nfunc Test_out_of_memory()\n  new\n  s/^/,n\n  \" This will be slow...\n  call assert_fails('call search(\"\\\\v((n||<)+);\")', 'E363:')\nendfunc\n\nfunc Test_get_equi_class()\n  new\n  \" Incomplete equivalence class caused invalid memory access\n  s/^/[[=\n  call assert_equal(1, search(getline(1)))\n  s/.*/[[.\n  call assert_equal(1, search(getline(1)))\nendfunc\n\nfunc Test_rex_init()\n  set noincsearch\n  set re=1\n  new\n  setlocal iskeyword=a-z\n  call setline(1, ['abc', 'ABC'])\n  call assert_equal(1, search('[[:keyword:]]'))\n  new\n  setlocal iskeyword=A-Z\n  call setline(1, ['abc', 'ABC'])\n  call assert_equal(2, search('[[:keyword:]]'))\n  bwipe!\n  bwipe!\n  set re=0\nendfunc\n\nfunc Test_range_with_newline()\n  new\n  call setline(1, \"a\")\n  call assert_equal(0, search(\"[ -*\\\\n- ]\"))\n  call assert_equal(0, search(\"[ -*\\\\t-\\\\n]\"))\n  bwipe!\nendfunc\n\nfunc Test_pattern_compile_speed()\n  CheckOption spellcapcheck\n  CheckFunction reltimefloat\n\n  let start = reltime()\n  \" this used to be very slow, not it should be about a second\n  set spc=\\\\v(((((Nxxxxxxx&&xxxx){179})+)+)+){179}\n  call assert_inrange(0.01, 10.0, reltimefloat(reltime(start)))\n  set spc=\nendfunc\n\n\" Tests for regexp patterns without multi-byte support.\nfunc Test_regexp_single_line_pat()\n  \" tl is a List of Lists with:\n  \"    regexp engines to test\n  \"       0 - test with 'regexpengine' values 0 and 1\n  \"       1 - test with 'regexpengine' values 0 and 2\n  \"       2 - test with 'regexpengine' values 0, 1 and 2\n  \"    regexp pattern\n  \"    text to test the pattern on\n  \"    expected match (optional)\n  \"    expected submatch 1 (optional)\n  \"    expected submatch 2 (optional)\n  \"    etc.\n  \"  When there is no match use only the first two items.\n  let tl = []\n\n  call add(tl, [2, 'ab', 'aab', 'ab'])\n  call add(tl, [2, 'b', 'abcdef', 'b'])\n  call add(tl, [2, 'bc*', 'abccccdef', 'bcccc'])\n  call add(tl, [2, 'bc\\{-}', 'abccccdef', 'b'])\n  call add(tl, [2, 'bc\\{-}\\(d\\)', 'abccccdef', 'bccccd', 'd'])\n  call add(tl, [2, 'bc*', 'abbdef', 'b'])\n  call add(tl, [2, 'c*', 'ccc', 'ccc'])\n  call add(tl, [2, 'bc*', 'abdef', 'b'])\n  call add(tl, [2, 'c*', 'abdef', ''])\n  call add(tl, [2, 'bc\\+', 'abccccdef', 'bcccc'])\n  call add(tl, [2, 'bc\\+', 'abdef']) \" no match\n  \" match escape character in a string\n  call add(tl, [2, '.\\e.', \"one\\<Esc>two\", \"e\\<Esc>t\"])\n  \" match backspace character in a string\n  call add(tl, [2, '.\\b.', \"one\\<C-H>two\", \"e\\<C-H>t\"])\n  \" match newline character in a string\n  call add(tl, [2, 'o\\nb', \"foo\\nbar\", \"o\\nb\"])\n\n  \" operator \\|\n  call add(tl, [2, 'a\\|ab', 'cabd', 'a']) \" alternation is ordered\n\n  call add(tl, [2, 'c\\?', 'ccb', 'c'])\n  call add(tl, [2, 'bc\\?', 'abd', 'b'])\n  call add(tl, [2, 'bc\\?', 'abccd', 'bc'])\n\n  call add(tl, [2, '\\va{1}', 'ab', 'a'])\n\n  call add(tl, [2, '\\va{2}', 'aa', 'aa'])\n  call add(tl, [2, '\\va{2}', 'caad', 'aa'])\n  call add(tl, [2, '\\va{2}', 'aba'])\n  call add(tl, [2, '\\va{2}', 'ab'])\n  call add(tl, [2, '\\va{2}', 'abaa', 'aa'])\n  call add(tl, [2, '\\va{2}', 'aaa', 'aa'])\n\n  call add(tl, [2, '\\vb{1}', 'abca', 'b'])\n  call add(tl, [2, '\\vba{2}', 'abaa', 'baa'])\n  call add(tl, [2, '\\vba{3}', 'aabaac'])\n\n  call add(tl, [2, '\\v(ab){1}', 'ab', 'ab', 'ab'])\n  call add(tl, [2, '\\v(ab){1}', 'dabc', 'ab', 'ab'])\n  call add(tl, [2, '\\v(ab){1}', 'acb'])\n\n  call add(tl, [2, '\\v(ab){0,2}', 'acb', \"\", \"\"])\n  call add(tl, [2, '\\v(ab){0,2}', 'ab', 'ab', 'ab'])\n  call add(tl, [2, '\\v(ab){1,2}', 'ab', 'ab', 'ab'])\n  call add(tl, [2, '\\v(ab){1,2}', 'ababc', 'abab', 'ab'])\n  call add(tl, [2, '\\v(ab){2,4}', 'ababcab', 'abab', 'ab'])\n  call add(tl, [2, '\\v(ab){2,4}', 'abcababa', 'abab', 'ab'])\n\n  call add(tl, [2, '\\v(ab){2}', 'abab', 'abab', 'ab'])\n  call add(tl, [2, '\\v(ab){2}', 'cdababe', 'abab', 'ab'])\n  call add(tl, [2, '\\v(ab){2}', 'abac'])\n  call add(tl, [2, '\\v(ab){2}', 'abacabab', 'abab', 'ab'])\n  call add(tl, [2, '\\v((ab){2}){2}', 'abababab', 'abababab', 'abab', 'ab'])\n  call add(tl, [2, '\\v((ab){2}){2}', 'abacabababab', 'abababab', 'abab', 'ab'])\n\n  call add(tl, [2, '\\v(a{1}){1}', 'a', 'a', 'a'])\n  call add(tl, [2, '\\v(a{2}){1}', 'aa', 'aa', 'aa'])\n  call add(tl, [2, '\\v(a{2}){1}', 'aaac', 'aa', 'aa'])\n  call add(tl, [2, '\\v(a{2}){1}', 'daaac', 'aa', 'aa'])\n  call add(tl, [2, '\\v(a{1}){2}', 'daaac', 'aa', 'a'])\n  call add(tl, [2, '\\v(a{1}){2}', 'aaa', 'aa', 'a'])\n  call add(tl, [2, '\\v(a{2})+', 'adaac', 'aa', 'aa'])\n  call add(tl, [2, '\\v(a{2})+', 'aa', 'aa', 'aa'])\n  call add(tl, [2, '\\v(a{2}){1}', 'aa', 'aa', 'aa'])\n  call add(tl, [2, '\\v(a{1}){2}', 'aa', 'aa', 'a'])\n  call add(tl, [2, '\\v(a{1}){1}', 'a', 'a', 'a'])\n  call add(tl, [2, '\\v(a{2}){2}', 'aaaa', 'aaaa', 'aa'])\n  call add(tl, [2, '\\v(a{2}){2}', 'aaabaaaa', 'aaaa', 'aa'])\n\n  call add(tl, [2, '\\v(a+){2}', 'dadaac', 'aa', 'a'])\n  call add(tl, [2, '\\v(a{3}){2}', 'aaaaaaa', 'aaaaaa', 'aaa'])\n\n  call add(tl, [2, '\\v(a{1,2}){2}', 'daaac', 'aaa', 'a'])\n  call add(tl, [2, '\\v(a{1,3}){2}', 'daaaac', 'aaaa', 'a'])\n  call add(tl, [2, '\\v(a{1,3}){2}', 'daaaaac', 'aaaaa', 'aa'])\n  call add(tl, [2, '\\v(a{1,3}){3}', 'daac'])\n  call add(tl, [2, '\\v(a{1,2}){2}', 'dac'])\n  call add(tl, [2, '\\v(a+)+', 'daac', 'aa', 'aa'])\n  call add(tl, [2, '\\v(a+)+', 'aaa', 'aaa', 'aaa'])\n  call add(tl, [2, '\\v(a+){1,2}', 'aaa', 'aaa', 'aaa'])\n  call add(tl, [2, '\\v(a+)(a+)', 'aaa', 'aaa', 'aa', 'a'])\n  call add(tl, [2, '\\v(a{3})+', 'daaaac', 'aaa', 'aaa'])\n  call add(tl, [2, '\\v(a|b|c)+', 'aacb', 'aacb', 'b'])\n  call add(tl, [2, '\\v(a|b|c){2}', 'abcb', 'ab', 'b'])\n  call add(tl, [2, '\\v(abc){2}', 'abcabd', ])\n  call add(tl, [2, '\\v(abc){2}', 'abdabcabc','abcabc', 'abc'])\n\n  call add(tl, [2, 'a*', 'cc', ''])\n  call add(tl, [2, '\\v(a*)+', 'cc', ''])\n  call add(tl, [2, '\\v((ab)+)+', 'ab', 'ab', 'ab', 'ab'])\n  call add(tl, [2, '\\v(((ab)+)+)+', 'ab', 'ab', 'ab', 'ab', 'ab'])\n  call add(tl, [2, '\\v(((ab)+)+)+', 'dababc', 'abab', 'abab', 'abab', 'ab'])\n  call add(tl, [2, '\\v(a{0,2})+', 'cc', ''])\n  call add(tl, [2, '\\v(a*)+', '', ''])\n  call add(tl, [2, '\\v((a*)+)+', '', ''])\n  call add(tl, [2, '\\v((ab)*)+', '', ''])\n  call add(tl, [2, '\\va{1,3}', 'aab', 'aa'])\n  call add(tl, [2, '\\va{2,3}', 'abaa', 'aa'])\n\n  call add(tl, [2, '\\v((ab)+|c*)+', 'abcccaba', 'abcccab', '', 'ab'])\n  call add(tl, [2, '\\v(a{2})|(b{3})', 'bbabbbb', 'bbb', '', 'bbb'])\n  call add(tl, [2, '\\va{2}|b{2}', 'abab'])\n  call add(tl, [2, '\\v(a)+|(c)+', 'bbacbaacbbb', 'a', 'a'])\n  call add(tl, [2, '\\vab{2,3}c', 'aabbccccccccccccc', 'abbc'])\n  call add(tl, [2, '\\vab{2,3}c', 'aabbbccccccccccccc', 'abbbc'])\n  call add(tl, [2, '\\vab{2,3}cd{2,3}e', 'aabbbcddee', 'abbbcdde'])\n  call add(tl, [2, '\\va(bc){2}d', 'aabcbfbc' ])\n  call add(tl, [2, '\\va*a{2}', 'a', ])\n  call add(tl, [2, '\\va*a{2}', 'aa', 'aa' ])\n  call add(tl, [2, '\\va*a{2}', 'aaa', 'aaa' ])\n  call add(tl, [2, '\\va*a{2}', 'bbbabcc', ])\n  call add(tl, [2, '\\va*b*|a*c*', 'a', 'a'])\n  call add(tl, [2, '\\va{1}b{1}|a{1}b{1}', ''])\n\n  \" submatches\n  call add(tl, [2, '\\v(a)', 'ab', 'a', 'a'])\n  call add(tl, [2, '\\v(a)(b)', 'ab', 'ab', 'a', 'b'])\n  call add(tl, [2, '\\v(ab)(b)(c)', 'abbc', 'abbc', 'ab', 'b', 'c'])\n  call add(tl, [2, '\\v((a)(b))', 'ab', 'ab', 'ab', 'a', 'b'])\n  call add(tl, [2, '\\v(a)|(b)', 'ab', 'a', 'a'])\n\n  call add(tl, [2, '\\v(a*)+', 'aaaa', 'aaaa', ''])\n  call add(tl, [2, 'x', 'abcdef'])\n\n  \"\n  \" Simple tests\n  \"\n\n  \" Search single groups\n  call add(tl, [2, 'ab', 'aab', 'ab'])\n  call add(tl, [2, 'ab', 'baced'])\n  call add(tl, [2, 'ab', '                    ab           ', 'ab'])\n\n  \" Search multi-modifiers\n  call add(tl, [2, 'x*', 'xcd', 'x'])\n  call add(tl, [2, 'x*', 'xxxxxxxxxxxxxxxxsofijiojgf', 'xxxxxxxxxxxxxxxx'])\n  \" empty match is good\n  call add(tl, [2, 'x*', 'abcdoij', ''])\n  \" no match here\n  call add(tl, [2, 'x\\+', 'abcdoin'])\n  call add(tl, [2, 'x\\+', 'abcdeoijdfxxiuhfij', 'xx'])\n  call add(tl, [2, 'x\\+', 'xxxxx', 'xxxxx'])\n  call add(tl, [2, 'x\\+', 'abc x siufhiush xxxxxxxxx', 'x'])\n  call add(tl, [2, 'x\\=', 'x sdfoij', 'x'])\n  call add(tl, [2, 'x\\=', 'abc sfoij', '']) \" empty match is good\n  call add(tl, [2, 'x\\=', 'xxxxxxxxx c', 'x'])\n  call add(tl, [2, 'x\\?', 'x sdfoij', 'x'])\n  \" empty match is good\n  call add(tl, [2, 'x\\?', 'abc sfoij', ''])\n  call add(tl, [2, 'x\\?', 'xxxxxxxxxx c', 'x'])\n\n  call add(tl, [2, 'a\\{0,0}', 'abcdfdoij', ''])\n  \" same thing as 'a?'\n  call add(tl, [2, 'a\\{0,1}', 'asiubid axxxaaa', 'a'])\n  \" same thing as 'a\\{0,1}'\n  call add(tl, [2, 'a\\{1,0}', 'asiubid axxxaaa', 'a'])\n  call add(tl, [2, 'a\\{3,6}', 'aa siofuh'])\n  call add(tl, [2, 'a\\{3,6}', 'aaaaa asfoij afaa', 'aaaaa'])\n  call add(tl, [2, 'a\\{3,6}', 'aaaaaaaa', 'aaaaaa'])\n  call add(tl, [2, 'a\\{0}', 'asoiuj', ''])\n  call add(tl, [2, 'a\\{2}', 'aaaa', 'aa'])\n  call add(tl, [2, 'a\\{2}', 'iuash fiusahfliusah fiushfilushfi uhsaifuh askfj nasfvius afg aaaa sfiuhuhiushf', 'aa'])\n  call add(tl, [2, 'a\\{2}', 'abcdefghijklmnopqrestuvwxyz1234567890'])\n  \" same thing as 'a*'\n  call add(tl, [2, 'a\\{0,}', 'oij sdigfusnf', ''])\n  call add(tl, [2, 'a\\{0,}', 'aaaaa aa', 'aaaaa'])\n  call add(tl, [2, 'a\\{2,}', 'sdfiougjdsafg'])\n  call add(tl, [2, 'a\\{2,}', 'aaaaasfoij ', 'aaaaa'])\n  call add(tl, [2, 'a\\{5,}', 'xxaaaaxxx '])\n  call add(tl, [2, 'a\\{5,}', 'xxaaaaaxxx ', 'aaaaa'])\n  call add(tl, [2, 'a\\{,0}', 'oidfguih iuhi hiu aaaa', ''])\n  call add(tl, [2, 'a\\{,5}', 'abcd', 'a'])\n  call add(tl, [2, 'a\\{,5}', 'aaaaaaaaaa', 'aaaaa'])\n  \" leading star as normal char when \\{} follows\n  call add(tl, [2, '^*\\{4,}$', '***'])\n  call add(tl, [2, '^*\\{4,}$', '****', '****'])\n  call add(tl, [2, '^*\\{4,}$', '*****', '*****'])\n  \" same thing as 'a*'\n  call add(tl, [2, 'a\\{}', 'bbbcddiuhfcd', ''])\n  call add(tl, [2, 'a\\{}', 'aaaaioudfh coisf jda', 'aaaa'])\n\n  call add(tl, [2, 'a\\{-0,0}', 'abcdfdoij', ''])\n  \" anti-greedy version of 'a?'\n  call add(tl, [2, 'a\\{-0,1}', 'asiubid axxxaaa', ''])\n  call add(tl, [2, 'a\\{-3,6}', 'aa siofuh'])\n  call add(tl, [2, 'a\\{-3,6}', 'aaaaa asfoij afaa', 'aaa'])\n  call add(tl, [2, 'a\\{-3,6}', 'aaaaaaaa', 'aaa'])\n  call add(tl, [2, 'a\\{-0}', 'asoiuj', ''])\n  call add(tl, [2, 'a\\{-2}', 'aaaa', 'aa'])\n  call add(tl, [2, 'a\\{-2}', 'abcdefghijklmnopqrestuvwxyz1234567890'])\n  call add(tl, [2, 'a\\{-0,}', 'oij sdigfusnf', ''])\n  call add(tl, [2, 'a\\{-0,}', 'aaaaa aa', ''])\n  call add(tl, [2, 'a\\{-2,}', 'sdfiougjdsafg'])\n  call add(tl, [2, 'a\\{-2,}', 'aaaaasfoij ', 'aa'])\n  call add(tl, [2, 'a\\{-,0}', 'oidfguih iuhi hiu aaaa', ''])\n  call add(tl, [2, 'a\\{-,5}', 'abcd', ''])\n  call add(tl, [2, 'a\\{-,5}', 'aaaaaaaaaa', ''])\n  \" anti-greedy version of 'a*'\n  call add(tl, [2, 'a\\{-}', 'bbbcddiuhfcd', ''])\n  call add(tl, [2, 'a\\{-}', 'aaaaioudfh coisf jda', ''])\n\n  \" Test groups of characters and submatches\n  call add(tl, [2, '\\(abc\\)*', 'abcabcabc', 'abcabcabc', 'abc'])\n  call add(tl, [2, '\\(ab\\)\\+', 'abababaaaaa', 'ababab', 'ab'])\n  call add(tl, [2, '\\(abaaaaa\\)*cd', 'cd', 'cd', ''])\n  call add(tl, [2, '\\(test1\\)\\? \\(test2\\)\\?', 'test1 test3', 'test1 ', 'test1', ''])\n  call add(tl, [2, '\\(test1\\)\\= \\(test2\\) \\(test4443\\)\\=', ' test2 test4443 yupiiiiiiiiiii', ' test2 test4443', '', 'test2', 'test4443'])\n  call add(tl, [2, '\\(\\(sub1\\) hello \\(sub 2\\)\\)', 'asterix sub1 hello sub 2 obelix', 'sub1 hello sub 2', 'sub1 hello sub 2', 'sub1', 'sub 2'])\n  call add(tl, [2, '\\(\\(\\(yyxxzz\\)\\)\\)', 'abcdddsfiusfyyzzxxyyxxzz', 'yyxxzz', 'yyxxzz', 'yyxxzz', 'yyxxzz'])\n  call add(tl, [2, '\\v((ab)+|c+)+', 'abcccaba', 'abcccab', 'ab', 'ab'])\n  call add(tl, [2, '\\v((ab)|c*)+', 'abcccaba', 'abcccab', '', 'ab'])\n  call add(tl, [2, '\\v(a(c*)+b)+', 'acbababaaa', 'acbabab', 'ab', ''])\n  call add(tl, [2, '\\v(a|b*)+', 'aaaa', 'aaaa', ''])\n  call add(tl, [2, '\\p*', 'a\u0431 \t', 'a\u0431 '])\n\n  \" Test greedy-ness and lazy-ness\n  call add(tl, [2, 'a\\{-2,7}','aaaaaaaaaaaaa', 'aa'])\n  call add(tl, [2, 'a\\{-2,7}x','aaaaaaaaax', 'aaaaaaax'])\n  call add(tl, [2, 'a\\{2,7}','aaaaaaaaaaaaaaaaaaaa', 'aaaaaaa'])\n  call add(tl, [2, 'a\\{2,7}x','aaaaaaaaax', 'aaaaaaax'])\n  call add(tl, [2, '\\vx(.{-,8})yz(.*)','xayxayzxayzxayz','xayxayzxayzxayz','ayxa','xayzxayz'])\n  call add(tl, [2, '\\vx(.*)yz(.*)','xayxayzxayzxayz','xayxayzxayzxayz', 'ayxayzxayzxa',''])\n  call add(tl, [2, '\\v(a{1,2}){-2,3}','aaaaaaa','aaaa','aa'])\n  call add(tl, [2, '\\v(a{-1,3})+', 'aa', 'aa', 'a'])\n  call add(tl, [2, '^\\s\\{-}\\zs\\( x\\|x$\\)', ' x', ' x', ' x'])\n  call add(tl, [2, '^\\s\\{-}\\zs\\(x\\| x$\\)', ' x', ' x', ' x'])\n  call add(tl, [2, '^\\s\\{-}\\ze\\(x\\| x$\\)', ' x', '', ' x'])\n  call add(tl, [2, '^\\(\\s\\{-}\\)\\(x\\| x$\\)', ' x', ' x', '', ' x'])\n\n  \" Test Character classes\n  call add(tl, [2, '\\d\\+e\\d\\d','test 10e23 fd','10e23'])\n\n  \" Test collections and character range []\n  call add(tl, [2, '\\v[a]', 'abcd', 'a'])\n  call add(tl, [2, 'a[bcd]', 'abcd', 'ab'])\n  call add(tl, [2, 'a[b-d]', 'acbd', 'ac'])\n  call add(tl, [2, '[a-d][e-f][x-x]d', 'cexdxx', 'cexd'])\n  call add(tl, [2, '\\v[[:alpha:]]+', 'abcdefghijklmnopqrstuvwxyz6','abcdefghijklmnopqrstuvwxyz'])\n  call add(tl, [2, '[[:alpha:]\\+]', '6x8','x'])\n  call add(tl, [2, '[^abc]\\+','abcabcabc'])\n  call add(tl, [2, '[^abc]','defghiasijvoinasoiunbvb','d'])\n  call add(tl, [2, '[^abc]\\+','ddddddda','ddddddd'])\n  call add(tl, [2, '[^a-d]\\+','aaaAAAZIHFNCddd','AAAZIHFNC'])\n  call add(tl, [2, '[a-f]*','iiiiiiii',''])\n  call add(tl, [2, '[a-f]*','abcdefgh','abcdef'])\n  call add(tl, [2, '[^a-f]\\+','abcdefgh','gh'])\n  call add(tl, [2, '[a-c]\\{-3,6}','abcabc','abc'])\n  call add(tl, [2, '[^[:alpha:]]\\+','abcccadfoij7787ysf287yrnccdu','7787'])\n  call add(tl, [2, '[-a]', '-', '-'])\n  call add(tl, [2, '[a-]', '-', '-'])\n  call add(tl, [2, '[a-f]*\\c','ABCDEFGH','ABCDEF'])\n  call add(tl, [2, '[abc][xyz]\\c','-af-AF-BY--','BY'])\n  \" filename regexp\n  call add(tl, [2, '[-./[:alnum:]_~]\\+', 'log13.file', 'log13.file'])\n  \" special chars\n  call add(tl, [2, '[\\]\\^\\-\\\\]\\+', '\\^\\\\\\-\\---^', '\\^\\\\\\-\\---^'])\n  \" collation elem\n  call add(tl, [2, '[[.a.]]\\+', 'aa', 'aa'])\n  \" middle of regexp\n  call add(tl, [2, 'abc[0-9]*ddd', 'siuhabc ii'])\n  call add(tl, [2, 'abc[0-9]*ddd', 'adf abc44482ddd oijs', 'abc44482ddd'])\n  call add(tl, [2, '\\_[0-9]\\+', 'asfi9888u', '9888'])\n  call add(tl, [2, '[0-9\\n]\\+', 'asfi9888u', '9888'])\n  call add(tl, [2, '\\_[0-9]\\+', \"asfi\\n9888u\", \"\\n9888\"])\n  call add(tl, [2, '\\_f', \"  \\na \", \"\\n\"])\n  call add(tl, [2, '\\_f\\+', \"  \\na \", \"\\na\"])\n  call add(tl, [2, '[0-9A-Za-z-_.]\\+', \" @0_a.A-{ \", \"0_a.A-\"])\n\n  \" Test start/end of line, start/end of file\n  call add(tl, [2, '^a.', \"a_\\nb \", \"a_\"])\n  call add(tl, [2, '^a.', \"b a \\na_\"])\n  call add(tl, [2, '.a$', \" a\\n \"])\n  call add(tl, [2, '.a$', \" a b\\n_a\", \"_a\"])\n  call add(tl, [2, '\\%^a.', \"a a\\na\", \"a \"])\n  call add(tl, [2, '\\%^a', \" a \\na \"])\n  call add(tl, [2, '.a\\%$', \" a\\n \"])\n  call add(tl, [2, '.a\\%$', \" a\\n_a\", \"_a\"])\n\n  \" Test recognition of character classes\n  call add(tl, [2, '[0-7]\\+', 'x0123456789x', '01234567'])\n  call add(tl, [2, '[^0-7]\\+', '0a;X+% 897', 'a;X+% 89'])\n  call add(tl, [2, '[0-9]\\+', 'x0123456789x', '0123456789'])\n  call add(tl, [2, '[^0-9]\\+', '0a;X+% 9', 'a;X+% '])\n  call add(tl, [2, '[0-9a-fA-F]\\+', 'x0189abcdefg', '0189abcdef'])\n  call add(tl, [2, '[^0-9A-Fa-f]\\+', '0189g;X+% ab', 'g;X+% '])\n  call add(tl, [2, '[a-z_A-Z0-9]\\+', ';+aso_SfOij ', 'aso_SfOij'])\n  call add(tl, [2, '[^a-z_A-Z0-9]\\+', 'aSo_;+% sfOij', ';+% '])\n  call add(tl, [2, '[a-z_A-Z]\\+', '0abyz_ABYZ;', 'abyz_ABYZ'])\n  call add(tl, [2, '[^a-z_A-Z]\\+', 'abAB_09;+% yzYZ', '09;+% '])\n  call add(tl, [2, '[a-z]\\+', '0abcxyz1', 'abcxyz'])\n  call add(tl, [2, '[a-z]\\+', 'AabxyzZ', 'abxyz'])\n  call add(tl, [2, '[^a-z]\\+', 'a;X09+% x', ';X09+% '])\n  call add(tl, [2, '[^a-z]\\+', 'abX0;%yz', 'X0;%'])\n  call add(tl, [2, '[a-zA-Z]\\+', '0abABxzXZ9', 'abABxzXZ'])\n  call add(tl, [2, '[^a-zA-Z]\\+', 'ab09_;+ XZ', '09_;+ '])\n  call add(tl, [2, '[A-Z]\\+', 'aABXYZz', 'ABXYZ'])\n  call add(tl, [2, '[^A-Z]\\+', 'ABx0;%YZ', 'x0;%'])\n  call add(tl, [2, '[a-z]\\+\\c', '0abxyzABXYZ;', 'abxyzABXYZ'])\n  call add(tl, [2, '[A-Z]\\+\\c', '0abABxzXZ9', 'abABxzXZ'])\n  call add(tl, [2, '\\c[^a-z]\\+', 'ab09_;+ XZ', '09_;+ '])\n  call add(tl, [2, '\\c[^A-Z]\\+', 'ab09_;+ XZ', '09_;+ '])\n  call add(tl, [2, '\\C[^A-Z]\\+', 'ABCOIJDEOIFNSD jsfoij sa', ' jsfoij sa'])\n\n  \" Tests for \\z features\n  \" match ends at \\ze\n  call add(tl, [2, 'xx \\ze test', 'xx '])\n  call add(tl, [2, 'abc\\zeend', 'oij abcend', 'abc'])\n  call add(tl, [2, 'aa\\zebb\\|aaxx', ' aabb ', 'aa'])\n  call add(tl, [2, 'aa\\zebb\\|aaxx', ' aaxx ', 'aaxx'])\n  call add(tl, [2, 'aabb\\|aa\\zebb', ' aabb ', 'aabb'])\n  call add(tl, [2, 'aa\\zebb\\|aaebb', ' aabb ', 'aa'])\n  \" match starts at \\zs\n  call add(tl, [2, 'abc\\zsdd', 'ddabcddxyzt', 'dd'])\n  call add(tl, [2, 'aa \\zsax', ' ax'])\n  call add(tl, [2, 'abc \\zsmatch\\ze abc', 'abc abc abc match abc abc', 'match'])\n  call add(tl, [2, '\\v(a \\zsif .*){2}', 'a if then a if last', 'if last', 'a if last'])\n  call add(tl, [2, '\\>\\zs.', 'aword. ', '.'])\n  call add(tl, [2, '\\s\\+\\ze\\[/\\|\\s\\zs\\s\\+', 'is   [a t', '  '])\n\n  \" Tests for \\@= and \\& features\n  call add(tl, [2, 'abc\\@=', 'abc', 'ab'])\n  call add(tl, [2, 'abc\\@=cd', 'abcd', 'abcd'])\n  call add(tl, [2, 'abc\\@=', 'ababc', 'ab'])\n  \" will never match, no matter the input text\n  call add(tl, [2, 'abcd\\@=e', 'abcd'])\n  \" will never match\n  call add(tl, [2, 'abcd\\@=e', 'any text in here ... '])\n  call add(tl, [2, '\\v(abc)@=..', 'xabcd', 'ab', 'abc'])\n  call add(tl, [2, '\\(.*John\\)\\@=.*Bob', 'here is John, and here is B'])\n  call add(tl, [2, '\\(John.*\\)\\@=.*Bob', 'John is Bobs friend', 'John is Bob', 'John is Bobs friend'])\n  call add(tl, [2, '\\<\\S\\+\\())\\)\\@=', '$((i=i+1))', 'i=i+1', '))'])\n  call add(tl, [2, '.*John\\&.*Bob', 'here is John, and here is B'])\n  call add(tl, [2, '.*John\\&.*Bob', 'John is Bobs friend', 'John is Bob'])\n  call add(tl, [2, '\\v(test1)@=.*yep', 'this is a test1, yep it is', 'test1, yep', 'test1'])\n  call add(tl, [2, 'foo\\(bar\\)\\@!', 'foobar'])\n  call add(tl, [2, 'foo\\(bar\\)\\@!', 'foo bar', 'foo'])\n  call add(tl, [2, 'if \\(\\(then\\)\\@!.\\)*$', ' if then else'])\n  call add(tl, [2, 'if \\(\\(then\\)\\@!.\\)*$', ' if else ', 'if else ', ' '])\n  call add(tl, [2, '\\(foo\\)\\@!bar', 'foobar', 'bar'])\n  call add(tl, [2, '\\(foo\\)\\@!...bar', 'foobar'])\n  call add(tl, [2, '^\\%(.*bar\\)\\@!.*\\zsfoo', ' bar foo '])\n  call add(tl, [2, '^\\%(.*bar\\)\\@!.*\\zsfoo', ' foo bar '])\n  call add(tl, [2, '^\\%(.*bar\\)\\@!.*\\zsfoo', ' foo xxx ', 'foo'])\n  call add(tl, [2, '[ ]\\@!\\p\\%([ ]\\@!\\p\\)*:', 'implicit mappings:', 'mappings:'])\n  call add(tl, [2, '[ ]\\@!\\p\\([ ]\\@!\\p\\)*:', 'implicit mappings:', 'mappings:', 's'])\n  call add(tl, [2, 'm\\k\\+_\\@=\\%(_\\@!\\k\\)\\@<=\\k\\+e', 'mx__xe', 'mx__xe'])\n  call add(tl, [2, '\\%(\\U\\@<=S\\k*\\|S\\l\\)R', 'SuR', 'SuR'])\n\n  \" Combining different tests and features\n  call add(tl, [2, '[[:alpha:]]\\{-2,6}', '787abcdiuhsasiuhb4', 'ab'])\n  call add(tl, [2, '', 'abcd', ''])\n  call add(tl, [2, '\\v(())', 'any possible text', ''])\n  call add(tl, [2, '\\v%(ab(xyz)c)', '   abxyzc ', 'abxyzc', 'xyz'])\n  call add(tl, [2, '\\v(test|)empty', 'tesempty', 'empty', ''])\n  call add(tl, [2, '\\v(a|aa)(a|aa)', 'aaa', 'aa', 'a', 'a'])\n\n  \" \\%u and friends\n  call add(tl, [2, '\\%d32', 'yes no', ' '])\n  call add(tl, [2, '\\%o40', 'yes no', ' '])\n  call add(tl, [2, '\\%x20', 'yes no', ' '])\n  call add(tl, [2, '\\%u0020', 'yes no', ' '])\n  call add(tl, [2, '\\%U00000020', 'yes no', ' '])\n  call add(tl, [2, '\\%d0', \"yes\\x0ano\", \"\\x0a\"])\n\n  \"\" \\%[abc]\n  call add(tl, [2, 'foo\\%[bar]', 'fobar'])\n  call add(tl, [2, 'foo\\%[bar]', 'foobar', 'foobar'])\n  call add(tl, [2, 'foo\\%[bar]', 'fooxx', 'foo'])\n  call add(tl, [2, 'foo\\%[bar]', 'foobxx', 'foob'])\n  call add(tl, [2, 'foo\\%[bar]', 'foobaxx', 'fooba'])\n  call add(tl, [2, 'foo\\%[bar]', 'foobarxx', 'foobar'])\n  call add(tl, [2, 'foo\\%[bar]x', 'foobxx', 'foobx'])\n  call add(tl, [2, 'foo\\%[bar]x', 'foobarxx', 'foobarx'])\n  call add(tl, [2, '\\%[bar]x', 'barxx', 'barx'])\n  call add(tl, [2, '\\%[bar]x', 'bxx', 'bx'])\n  call add(tl, [2, '\\%[bar]x', 'xxx', 'x'])\n  call add(tl, [2, 'b\\%[[ao]r]', 'bar bor', 'bar'])\n  call add(tl, [2, 'b\\%[[]]r]', 'b]r bor', 'b]r'])\n  call add(tl, [2, '@\\%[\\w\\-]*', '<http://john.net/pandoc/>[@pandoc]', '@pandoc'])\n\n  \" Alternatives, must use first longest match\n  call add(tl, [2, 'goo\\|go', 'google', 'goo'])\n  call add(tl, [2, '\\<goo\\|\\<go', 'google', 'goo'])\n  call add(tl, [2, '\\<goo\\|go', 'google', 'goo'])\n\n  \" Back references\n  call add(tl, [2, '\\(\\i\\+\\) \\1', ' abc abc', 'abc abc', 'abc'])\n  call add(tl, [2, '\\(\\i\\+\\) \\1', 'xgoo goox', 'goo goo', 'goo'])\n  call add(tl, [2, '\\(a\\)\\(b\\)\\(c\\)\\(dd\\)\\(e\\)\\(f\\)\\(g\\)\\(h\\)\\(i\\)\\1\\2\\3\\4\\5\\6\\7\\8\\9', 'xabcddefghiabcddefghix', 'abcddefghiabcddefghi', 'a', 'b', 'c', 'dd', 'e', 'f', 'g', 'h', 'i'])\n  call add(tl, [2, '\\(\\d*\\)a \\1b', ' a b ', 'a b', ''])\n  call add(tl, [2, '^.\\(.\\).\\_..\\1.', \"aaa\\naaa\\nb\", \"aaa\\naaa\", 'a'])\n  call add(tl, [2, '^.*\\.\\(.*\\)/.\\+\\(\\1\\)\\@<!$', 'foo.bat/foo.com', 'foo.bat/foo.com', 'bat'])\n  call add(tl, [2, '^.*\\.\\(.*\\)/.\\+\\(\\1\\)\\@<!$', 'foo.bat/foo.bat'])\n  call add(tl, [2, '^.*\\.\\(.*\\)/.\\+\\(\\1\\)\\@<=$', 'foo.bat/foo.bat', 'foo.bat/foo.bat', 'bat', 'bat'])\n  call add(tl, [2, '\\\\\\@<!\\${\\(\\d\\+\\%(:.\\{-}\\)\\?\\\\\\@<!\\)}', '2013-06-27${0}', '${0}', '0'])\n  call add(tl, [2, '^\\(a*\\)\\1$', 'aaaaaaaa', 'aaaaaaaa', 'aaaa'])\n  call add(tl, [2, '^\\(a\\{-2,}\\)\\1\\+$', 'aaaaaaaaa', 'aaaaaaaaa', 'aaa'])\n\n  \" Look-behind with limit\n  call add(tl, [2, '<\\@<=span.', 'xxspanxx<spanyyy', 'spany'])\n  call add(tl, [2, '<\\@1<=span.', 'xxspanxx<spanyyy', 'spany'])\n  call add(tl, [2, '<\\@2<=span.', 'xxspanxx<spanyyy', 'spany'])\n  call add(tl, [2, '\\(<<\\)\\@<=span.', 'xxspanxxxx<spanxx<<spanyyy', 'spany', '<<'])\n  call add(tl, [2, '\\(<<\\)\\@1<=span.', 'xxspanxxxx<spanxx<<spanyyy'])\n  call add(tl, [2, '\\(<<\\)\\@2<=span.', 'xxspanxxxx<spanxx<<spanyyy', 'spany', '<<'])\n  call add(tl, [2, '\\(foo\\)\\@<!bar.', 'xx foobar1 xbar2 xx', 'bar2'])\n\n  \" look-behind match in front of a zero-width item\n  call add(tl, [2, '\\v\\C%(<Last Changed:\\s+)@<=.*$', '\" test header'])\n  call add(tl, [2, '\\v\\C%(<Last Changed:\\s+)@<=.*$', '\" Last Changed: 1970', '1970'])\n  call add(tl, [2, '\\(foo\\)\\@<=\\>', 'foobar'])\n  call add(tl, [2, '\\(foo\\)\\@<=\\>', 'barfoo', '', 'foo'])\n  call add(tl, [2, '\\(foo\\)\\@<=.*', 'foobar', 'bar', 'foo'])\n\n  \" complicated look-behind match\n  call add(tl, [2, '\\(r\\@<=\\|\\w\\@<!\\)\\/', 'x = /word/;', '/'])\n  call add(tl, [2, '^[a-z]\\+\\ze \\&\\(asdf\\)\\@<!', 'foo bar', 'foo'])\n\n  \"\" \\@>\n  call add(tl, [2, '\\(a*\\)\\@>a', 'aaaa'])\n  call add(tl, [2, '\\(a*\\)\\@>b', 'aaab', 'aaab', 'aaa'])\n  call add(tl, [2, '^\\(.\\{-}b\\)\\@>.', '  abcbd', '  abc', '  ab'])\n  call add(tl, [2, '\\(.\\{-}\\)\\(\\)\\@>$', 'abc', 'abc', 'abc', ''])\n  \" TODO: BT engine does not restore submatch after failure\n  call add(tl, [1, '\\(a*\\)\\@>a\\|a\\+', 'aaaa', 'aaaa'])\n\n  \" \"\\_\" prepended negated collection matches EOL\n  call add(tl, [2, '\\_[^8-9]\\+', \"asfi\\n9888\", \"asfi\\n\"])\n  call add(tl, [2, '\\_[^a]\\+', \"asfi\\n9888\", \"sfi\\n9888\"])\n\n  \" Requiring lots of states.\n  call add(tl, [2, '[0-9a-zA-Z]\\{8}-\\([0-9a-zA-Z]\\{4}-\\)\\{3}[0-9a-zA-Z]\\{12}', \" 12345678-1234-1234-1234-123456789012 \", \"12345678-1234-1234-1234-123456789012\", \"1234-\"])\n\n  \" Skip adding state twice\n  call add(tl, [2, '^\\%(\\%(^\\s*#\\s*if\\>\\|#\\s*if\\)\\)\\(\\%>1c.*$\\)\\@=', \"#if FOO\", \"#if\", ' FOO'])\n\n  \" Test \\%V atom\n  call add(tl, [2, '\\%>70vGesamt', 'Jean-Michel Charlier & Victor Hubinon\\Gesamtausgabe [Salleck]    Buck Danny {Jean-Michel Charlier & Victor Hubinon}\\Gesamtausgabe', 'Gesamt'])\n\n  \" Test for ignoring case and matching repeated characters\n  call add(tl, [2, '\\cb\\+', 'aAbBbBcC', 'bBbB'])\n\n  \" Run the tests\n  for t in tl\n    let re = t[0]\n    let pat = t[1]\n    let text = t[2]\n    let matchidx = 3\n    for engine in [0, 1, 2]\n      if engine == 2 && re == 0 || engine == 1 && re == 1\n        continue\n      endif\n      let &regexpengine = engine\n      try\n        let l = matchlist(text, pat)\n      catch\n        call assert_report('Error ' . engine . ': pat: \\\"' . pat\n              \\ . '\\\", text: \\\"' . text . '\\\", caused an exception: \\\"'\n              \\ . v:exception . '\\\"')\n      endtry\n      \" check the match itself\n      if len(l) == 0 && len(t) > matchidx\n        call assert_report('Error ' . engine . ': pat: \\\"' . pat\n              \\ . '\\\", text: \\\"' . text . '\\\", did not match, expected: \\\"'\n              \\ . t[matchidx] . '\\\"')\n      elseif len(l) > 0 && len(t) == matchidx\n        call assert_report('Error ' . engine . ': pat: \\\"' . pat\n              \\ . '\\\", text: \\\"' . text . '\\\", match: \\\"' . l[0]\n              \\ . '\\\", expected no match')\n      elseif len(t) > matchidx && l[0] != t[matchidx]\n        call assert_report('Error ' . engine . ': pat: \\\"' . pat\n              \\ . '\\\", text: \\\"' . text . '\\\", match: \\\"' . l[0]\n              \\ . '\\\", expected: \\\"' . t[matchidx] . '\\\"')\n      else\n        \" Test passed\n      endif\n\n      \" check all the nine submatches\n      if len(l) > 0\n        for i in range(1, 9)\n          if len(t) <= matchidx + i\n            let e = ''\n          else\n            let e = t[matchidx + i]\n          endif\n          if l[i] != e\n            call assert_report('Error ' . engine . ': pat: \\\"' . pat\n                  \\ . '\\\", text: \\\"' . text . '\\\", submatch ' . i . ': \\\"'\n                  \\ . l[i] . '\\\", expected: \\\"' . e . '\\\"')\n          endif\n        endfor\n        unlet i\n      endif\n    endfor\n  endfor\n\n  unlet t tl e l\nendfunc\n\n\" Tests for multi-line regexp patterns without multi-byte support.\nfunc Test_regexp_multiline_pat()\n  \" tl is a List of Lists with:\n  \"    regexp engines to test\n  \"       0 - test with 'regexpengine' values 0 and 1\n  \"       1 - test with 'regexpengine' values 0 and 2\n  \"       2 - test with 'regexpengine' values 0, 1 and 2\n  \"    regexp pattern\n  \"    List with text to test the pattern on\n  \"    List with the expected match\n  let tl = []\n\n  \" back references\n  call add(tl, [2, '^.\\(.\\).\\_..\\1.', ['aaa', 'aaa', 'b'], ['XX', 'b']])\n  call add(tl, [2, '\\v.*\\/(.*)\\n.*\\/\\1$', ['./Dir1/Dir2/zyxwvuts.txt', './Dir1/Dir2/abcdefgh.bat', '', './Dir1/Dir2/file1.txt', './OtherDir1/OtherDir2/file1.txt'], ['./Dir1/Dir2/zyxwvuts.txt', './Dir1/Dir2/abcdefgh.bat', '', 'XX']])\n\n  \" line breaks\n  call add(tl, [2, '\\S.*\\nx', ['abc', 'def', 'ghi', 'xjk', 'lmn'], ['abc', 'def', 'XXjk', 'lmn']])\n\n  \" Any single character or end-of-line\n  call add(tl, [2, '\\_.\\+', ['a', 'b', 'c'], ['XX']])\n  \" Any identifier or end-of-line\n  call add(tl, [2, '\\_i\\+', ['a', 'b', ';', '2'], ['XX;XX']])\n  \" Any identifier but excluding digits or end-of-line\n  call add(tl, [2, '\\_I\\+', ['a', 'b', ';', '2'], ['XX;XX2XX']])\n  \" Any keyword or end-of-line\n  call add(tl, [2, '\\_k\\+', ['a', 'b', '=', '2'], ['XX=XX']])\n  \" Any keyword but excluding digits or end-of-line\n  call add(tl, [2, '\\_K\\+', ['a', 'b', '=', '2'], ['XX=XX2XX']])\n  \" Any filename character or end-of-line\n  call add(tl, [2, '\\_f\\+', ['a', 'b', '.', '5'], ['XX']])\n  \" Any filename character but excluding digits or end-of-line\n  call add(tl, [2, '\\_F\\+', ['a', 'b', '.', '5'], ['XX5XX']])\n  \" Any printable character or end-of-line\n  call add(tl, [2, '\\_p\\+', ['a', 'b', '=', '4'], ['XX']])\n  \" Any printable character excluding digits or end-of-line\n  call add(tl, [2, '\\_P\\+', ['a', 'b', '=', '4'], ['XX4XX']])\n  \" Any whitespace character or end-of-line\n  call add(tl, [2, '\\_s\\+', [' ', ' ', 'a', 'b'], ['XXaXXbXX']])\n  \" Any non-whitespace character or end-of-line\n  call add(tl, [2, '\\_S\\+', [' ', ' ', 'a', 'b'], [' XX XX']])\n  \" Any decimal digit or end-of-line\n  call add(tl, [2, '\\_d\\+', ['1', 'a', '2', 'b', '3'], ['XXaXXbXX']])\n  \" Any non-decimal digit or end-of-line\n  call add(tl, [2, '\\_D\\+', ['1', 'a', '2', 'b', '3'], ['1XX2XX3XX']])\n  \" Any hexadecimal digit or end-of-line\n  call add(tl, [2, '\\_x\\+', ['1', 'a', 'g', '9', '8'], ['XXgXX']])\n  \" Any non-hexadecimal digit or end-of-line\n  call add(tl, [2, '\\_X\\+', ['1', 'a', 'g', '9', '8'], ['1XXaXX9XX8XX']])\n  \" Any octal digit or end-of-line\n  call add(tl, [2, '\\_o\\+', ['0', '7', '8', '9', '0'], ['XX8XX9XX']])\n  \" Any non-octal digit or end-of-line\n  call add(tl, [2, '\\_O\\+', ['0', '7', '8', '9', '0'], ['0XX7XX0XX']])\n  \" Any word character or end-of-line\n  call add(tl, [2, '\\_w\\+', ['A', 'B', '=', 'C', 'D'], ['XX=XX']])\n  \" Any non-word character or end-of-line\n  call add(tl, [2, '\\_W\\+', ['A', 'B', '=', 'C', 'D'], ['AXXBXXCXXDXX']])\n  \" Any head-of-word character or end-of-line\n  call add(tl, [2, '\\_h\\+', ['a', '1', 'b', '2', 'c'], ['XX1XX2XX']])\n  \" Any non-head-of-word character or end-of-line\n  call add(tl, [2, '\\_H\\+', ['a', '1', 'b', '2', 'c'], ['aXXbXXcXX']])\n  \" Any alphabetic character or end-of-line\n  call add(tl, [2, '\\_a\\+', ['a', '1', 'b', '2', 'c'], ['XX1XX2XX']])\n  \" Any non-alphabetic character or end-of-line\n  call add(tl, [2, '\\_A\\+', ['a', '1', 'b', '2', 'c'], ['aXXbXXcXX']])\n  \" Any lowercase character or end-of-line\n  call add(tl, [2, '\\_l\\+', ['a', 'A', 'b', 'B'], ['XXAXXBXX']])\n  \" Any non-lowercase character or end-of-line\n  call add(tl, [2, '\\_L\\+', ['a', 'A', 'b', 'B'], ['aXXbXX']])\n  \" Any uppercase character or end-of-line\n  call add(tl, [2, '\\_u\\+', ['a', 'A', 'b', 'B'], ['aXXbXX']])\n  \" Any non-uppercase character or end-of-line\n  call add(tl, [2, '\\_U\\+', ['a', 'A', 'b', 'B'], ['XXAXXBXX']])\n  \" Collection or end-of-line\n  call add(tl, [2, '\\_[a-z]\\+', ['a', 'A', 'b', 'B'], ['XXAXXBXX']])\n  \" start of line anywhere in the text\n  call add(tl, [2, 'one\\zs\\_s*\\_^\\zetwo',\n        \\ ['', 'one', ' two', 'one', '', 'two'],\n        \\ ['', 'one', ' two', 'oneXXtwo']])\n  \" end of line anywhere in the text\n  call add(tl, [2, 'one\\zs\\_$\\_s*two',\n        \\ ['', 'one', ' two', 'one', '', 'two'], ['', 'oneXX', 'oneXX']])\n\n  \" Check that \\_[0-9] matching EOL does not break a following \\>\n  call add(tl, [2, '\\<\\(\\(25\\_[0-5]\\|2\\_[0-4]\\_[0-9]\\|\\_[01]\\?\\_[0-9]\\_[0-9]\\?\\)\\.\\)\\{3\\}\\(25\\_[0-5]\\|2\\_[0-4]\\_[0-9]\\|\\_[01]\\?\\_[0-9]\\_[0-9]\\?\\)\\>', ['', 'localnet/192.168.0.1', ''], ['', 'localnet/XX', '']])\n\n  \" Check a pattern with a line break and ^ and $\n  call add(tl, [2, 'a\\n^b$\\n^c', ['a', 'b', 'c'], ['XX']])\n\n  call add(tl, [2, '\\(^.\\+\\n\\)\\1', [' dog', ' dog', 'asdf'], ['XXasdf']])\n\n  \" Run the multi-line tests\n  for t in tl\n    let re = t[0]\n    let pat = t[1]\n    let before = t[2]\n    let after = t[3]\n    for engine in [0, 1, 2]\n      if engine == 2 && re == 0 || engine == 1 && re == 1\n        continue\n      endif\n      let &regexpengine = engine\n      new\n      call setline(1, before)\n      exe '%s/' . pat . '/XX/'\n      let result = getline(1, '$')\n      q!\n      if result != after\n        call assert_report('Error: pat: \\\"' . pat . '\\\", text: \\\"'\n              \\ . string(before) . '\\\", expected: \\\"' . string(after)\n              \\ . '\\\", got: \\\"' . string(result) . '\\\"')\n      else\n        \" Test passed\n      endif\n    endfor\n  endfor\n  unlet t tl\nendfunc\n\n\" Check that using a pattern on two lines doesn't get messed up by using\n\" matchstr() with \\ze in between.\nfunc Test_matchstr_with_ze()\n  new\n  call append(0, ['Substitute here:', '<T=\"\">Ta 5</Title>',\n        \\ '<T=\"\">Ac 7</Title>'])\n  call cursor(1, 1)\n  set re=0\n\n  .+1,.+2s/\"\"/\\='\"' . matchstr(getline(\".\"), '\\d\\+\\ze<') . '\"'\n  call assert_equal(['Substitute here:', '<T=\"5\">Ta 5</Title>',\n        \\ '<T=\"7\">Ac 7</Title>', ''], getline(1, '$'))\n\n  bwipe!\nendfunc\n\n\" Check a pattern with a look beind crossing a line boundary\nfunc Test_lookbehind_across_line()\n  new\n  call append(0, ['Behind:', 'asdfasd<yyy', 'xxstart1', 'asdfasd<yy',\n        \\ 'xxxstart2', 'asdfasd<yy', 'xxstart3'])\n  call cursor(1, 1)\n  call search('\\(<\\_[xy]\\+\\)\\@3<=start')\n  call assert_equal([0, 7, 3, 0], getpos('.'))\n  bwipe!\nendfunc\n\n\" Test for the \\%V atom (match inside the visual area)\nfunc Regex_Match_Visual_Area()\n  call append(0, ['Visual:', 'thexe the thexethe', 'andaxand andaxand',\n        \\ 'oooxofor foroxooo', 'oooxofor foroxooo'])\n  call cursor(1, 1)\n  exe \"normal jfxvfx:s/\\\\%Ve/E/g\\<CR>\"\n  exe \"normal jV:s/\\\\%Va/A/g\\<CR>\"\n  exe \"normal jfx\\<C-V>fxj:s/\\\\%Vo/O/g\\<CR>\"\n  call assert_equal(['Visual:', 'thexE thE thExethe', 'AndAxAnd AndAxAnd',\n        \\ 'oooxOfOr fOrOxooo', 'oooxOfOr fOrOxooo', ''], getline(1, '$'))\n  %d\nendfunc\n\n\" Check matching Visual area\nfunc Test_matching_visual_area()\n  new\n  set regexpengine=1\n  call Regex_Match_Visual_Area()\n  set regexpengine=2\n  call Regex_Match_Visual_Area()\n  set regexpengine&\n  bwipe!\nendfunc\n\n\" Check matching marks\nfunc Regex_Mark()\n  call append(0, ['', '', '', 'Marks:', 'asdfSasdfsadfEasdf', 'asdfSas',\n        \\ 'dfsadfEasdf', '', '', '', '', ''])\n  call cursor(4, 1)\n  exe \"normal jfSmsfEme:.-4,.+6s/.\\\\%>'s.*\\\\%<'e../here/\\<CR>\"\n  exe \"normal jfSmsj0fEme:.-4,.+6s/.\\\\%>'s\\\\_.*\\\\%<'e../again/\\<CR>\"\n  call assert_equal(['', '', '', 'Marks:', 'asdfhereasdf', 'asdfagainasdf',\n        \\ '', '', '', '', '', ''], getline(1, '$'))\n  %d\nendfunc\n\nfunc Test_matching_marks()\n  new\n  set regexpengine=1\n  call Regex_Mark()\n  set regexpengine=2\n  call Regex_Mark()\n  bwipe!\nendfunc\n\n\" Check patterns matching cursor position.\nfunc s:curpos_test()\n  new\n  call setline(1, ['ffooooo', 'boboooo', 'zoooooo', 'koooooo', 'moooooo',\n        \\ \"\\t\\t\\tfoo\", 'abababababababfoo', 'bababababababafoo', '********_',\n        \\ '        xxxxxxxxxxxx    xxxx xxxxxx xxxxxxx x xxxxxxxxx xx xxxxxx xxxxxx xxxxx xxxxxxx xx xxxx xxxxxxxx xxxx xxxxxxxxxxx xxx xxxxxxx xxxxxxxxx xx xxxxxx xx xxxxxxx xxxxxxxxxxxxxxxx xxxxxxxxx  xxx xxxxxxxx xxxxxxxxx xxxx xxx xxxx xxx xxx xxxxx xxxxxxxxxxxx xxxx xxxxxxxxx xxxxxxxxxxx xx xxxxx xxx xxxxxxxx xxxxxx xxx xxx xxxxxxxxx xxxxxxx x xxxxxxxxx xx xxxxxx xxxxxxx  xxxxxxxxxxxxxxxxxx xxxxxxx xxxxxxx xxx xxx xxxxxxxx xxxxxxx  xxxx xxx xxxxxx xxxxx xxxxx xx xxxxxx xxxxxxx xxx xxxxxxxxxxxx xxxx xxxxxxxxx xxxxxx xxxxxx xxxxx xxx xxxxxxx xxxxxxxxxxxxxxxx xxxxxxxxx  xxxxxxxxxx xxxx xx xxxxxxxx xxx xxxxxxxxxxx xxxxx'])\n  call setpos('.', [0, 1, 0, 0])\n  s/\\%>3c.//g\n  call setpos('.', [0, 2, 4, 0])\n  s/\\%#.*$//g\n  call setpos('.', [0, 3, 0, 0])\n  s/\\%<3c./_/g\n  %s/\\%4l\\%>5c./_/g\n  %s/\\%6l\\%>25v./_/g\n  %s/\\%>6l\\%3c./!/g\n  %s/\\%>7l\\%12c./?/g\n  %s/\\%>7l\\%<9l\\%>5v\\%<8v./#/g\n  $s/\\%(|\\u.*\\)\\@<=[^|\\t]\\+$//ge\n  call assert_equal(['ffo', 'bob', '__ooooo', 'koooo__', 'moooooo',\n        \\ '\t\t\tf__', 'ab!babababababfoo',\n        \\ 'ba!ab##abab?bafoo', '**!*****_',\n        \\ '  !     xxx?xxxxxxxx    xxxx xxxxxx xxxxxxx x xxxxxxxxx xx xxxxxx xxxxxx xxxxx xxxxxxx xx xxxx xxxxxxxx xxxx xxxxxxxxxxx xxx xxxxxxx xxxxxxxxx xx xxxxxx xx xxxxxxx xxxxxxxxxxxxxxxx xxxxxxxxx  xxx xxxxxxxx xxxxxxxxx xxxx xxx xxxx xxx xxx xxxxx xxxxxxxxxxxx xxxx xxxxxxxxx xxxxxxxxxxx xx xxxxx xxx xxxxxxxx xxxxxx xxx xxx xxxxxxxxx xxxxxxx x xxxxxxxxx xx xxxxxx xxxxxxx  xxxxxxxxxxxxxxxxxx xxxxxxx xxxxxxx xxx xxx xxxxxxxx xxxxxxx  xxxx xxx xxxxxx xxxxx xxxxx xx xxxxxx xxxxxxx xxx xxxxxxxxxxxx xxxx xxxxxxxxx xxxxxx xxxxxx xxxxx xxx xxxxxxx xxxxxxxxxxxxxxxx xxxxxxxxx  xxxxxxxxxx xxxx xx xxxxxxxx xxx xxxxxxxxxxx xxxxx'],\n        \\ getline(1, '$'))\n  bwipe!\nendfunc\n\nfunc Test_matching_curpos()\n  set re=0\n  call s:curpos_test()\n  set re=1\n  call s:curpos_test()\n  set re=2\n  call s:curpos_test()\n  set re&\nendfunc\n\n\" Test for matching the start and end of a buffer\nfunc Regex_start_end_buffer()\n  call setline(1, repeat(['vim edit'], 20))\n  /\\%^\n  call assert_equal([0, 1, 1, 0], getpos('.'))\n  exe \"normal 50%/\\\\%^..\\<CR>\"\n  call assert_equal([0, 1, 1, 0], getpos('.'))\n  exe \"normal 50%/\\\\%$\\<CR>\"\n  call assert_equal([0, 20, 8, 0], getpos('.'))\n  exe \"normal 6gg/..\\\\%$\\<CR>\"\n  call assert_equal([0, 20, 7, 0], getpos('.'))\n  %d\nendfunc\n\nfunc Test_start_end_of_buffer_match()\n  new\n  set regexpengine=1\n  call Regex_start_end_buffer()\n  set regexpengine=2\n  call Regex_start_end_buffer()\n  bwipe!\nendfunc\n\nfunc Test_ze_before_zs()\n  call assert_equal('', matchstr(' ', '\\%#=1\\ze \\zs'))\n  call assert_equal('', matchstr(' ', '\\%#=2\\ze \\zs'))\n  call assert_equal(repeat([''], 10), matchlist(' ', '\\%#=1\\ze \\zs'))\n  call assert_equal(repeat([''], 10), matchlist(' ', '\\%#=2\\ze \\zs'))\nendfunc\n\n\" Check for detecting error\nfunc Test_regexp_error()\n  call assert_fails(\"call matchlist('x x', '\\\\%#=1 \\\\zs*')\", 'E888:')\n  call assert_fails(\"call matchlist('x x', '\\\\%#=1 \\\\ze*')\", 'E888:')\n  call assert_fails(\"call matchlist('x x', '\\\\%#=2 \\\\zs*')\", 'E888:')\n  call assert_fails(\"call matchlist('x x', '\\\\%#=2 \\\\ze*')\", 'E888:')\n  call assert_fails(\"call matchstr('abcd', '\\\\%o841\\\\%o142')\", 'E678:')\n  call assert_fails(\"call matchstr('abcd', '\\\\%#=2\\\\%2147483647c')\", 'E951:')\n  call assert_fails(\"call matchstr('abcd', '\\\\%#=2\\\\%2147483647l')\", 'E951:')\n  call assert_fails(\"call matchstr('abcd', '\\\\%#=2\\\\%2147483647v')\", 'E951:')\n  call assert_fails('exe \"normal /\\\\%#=1\\\\%[x\\\\%[x]]\\<CR>\"',   'E369:')\n  call assert_fails('exe \"normal /\\\\%#=2\\\\%2147483647l\\<CR>\"', 'E951:')\n  call assert_fails('exe \"normal /\\\\%#=2\\\\%2147483647c\\<CR>\"', 'E951:')\n  call assert_fails('exe \"normal /\\\\%#=2\\\\%102261126v\\<CR>\"',  'E951:')\n  call assert_fails('exe \"normal /\\\\%#=2\\\\%2147483646l\\<CR>\"', 'E486:')\n  call assert_fails('exe \"normal /\\\\%#=2\\\\%2147483646c\\<CR>\"', 'E486:')\n  call assert_fails('exe \"normal /\\\\%#=2\\\\%102261125v\\<CR>\"',  'E486:')\n  call assert_equal('', matchstr('abcd', '\\%o181\\%o142'))\nendfunc\n\n\" Test for using the last substitute string pattern (~)\nfunc Test_regexp_last_subst_string()\n  new\n  s/bar/baz/e\n  call assert_equal(matchstr(\"foo\\nbaz\\nbar\", \"\\\\%#=1\\~\"), \"baz\")\n  call assert_equal(matchstr(\"foo\\nbaz\\nbar\", \"\\\\%#=2\\~\"), \"baz\")\n  close!\nendfunc\n\n\" Check patterns matching cursor position.\nfunc s:curpos_test2()\n  new\n  call setline(1, ['1', '2 foobar eins zwei drei vier f\u044cnf sechse',\n        \\ '3 foobar eins zwei drei vier f\u044cnf sechse',\n        \\ '4 foobar eins zwei drei vier f\u044cnf sechse',\n        \\ '5\tfoobar eins zwei drei vier f\u044cnf sechse',\n        \\ '6\tfoobar eins zwei drei vier f\u044cnf sechse',\n        \\ '7\tfoobar eins zwei drei vier f\u044cnf sechse'])\n  call setpos('.', [0, 2, 10, 0])\n  s/\\%.c.*//g\n  call setpos('.', [0, 3, 15, 0])\n  s/\\%.l.*//g\n  call setpos('.', [0, 5, 3, 0])\n  s/\\%.v.*/_/g\n  call assert_equal(['1',\n        \\ '2 foobar ',\n        \\ '',\n        \\ '4 foobar eins zwei drei vier f\u044cnf sechse',\n        \\ '5\t_',\n        \\ '6\tfoobar eins zwei drei vier f\u044cnf sechse',\n        \\ '7\tfoobar eins zwei drei vier f\u044cnf sechse'],\n        \\ getline(1, '$'))\n  call assert_fails('call search(\"\\\\%.1l\")', 'E1204:')\n  call assert_fails('call search(\"\\\\%.1c\")', 'E1204:')\n  call assert_fails('call search(\"\\\\%.1v\")', 'E1204:')\n  bwipe!\nendfunc\n\n\" Check patterns matching before or after cursor position.\nfunc s:curpos_test3()\n  new\n  call setline(1, ['1', '2 foobar eins zwei drei vier f\u044cnf sechse',\n        \\ '3 foobar eins zwei drei vier f\u044cnf sechse',\n        \\ '4 foobar eins zwei drei vier f\u044cnf sechse',\n        \\ '5\tfoobar eins zwei drei vier f\u044cnf sechse',\n        \\ '6\tfoobar eins zwei drei vier f\u044cnf sechse',\n        \\ '7\tfoobar eins zwei drei vier f\u044cnf sechse'])\n  call setpos('.', [0, 2, 10, 0])\n  \" Note: This removes all columns, except for the column directly in front of\n  \" the cursor. Bug????\n  :s/^.*\\%<.c//\n  call setpos('.', [0, 3, 10, 0])\n  :s/\\%>.c.*$//\n  call setpos('.', [0, 5, 4, 0])\n  \" Note: This removes all columns, except for the column directly in front of\n  \" the cursor. Bug????\n  :s/^.*\\%<.v/_/\n  call setpos('.', [0, 6, 4, 0])\n  :s/\\%>.v.*$/_/\n  call assert_equal(['1',\n        \\ ' eins zwei drei vier f\u044cnf sechse',\n        \\ '3 foobar e',\n        \\ '4 foobar eins zwei drei vier f\u044cnf sechse',\n        \\ '_foobar eins zwei drei vier f\u044cnf sechse',\n        \\ '6\tfo_',\n        \\ '7\tfoobar eins zwei drei vier f\u044cnf sechse'],\n        \\ getline(1, '$'))\n  sil %d\n  call setline(1, ['1', '2 foobar eins zwei drei vier f\u044cnf sechse',\n        \\ '3 foobar eins zwei drei vier f\u044cnf sechse',\n        \\ '4 foobar eins zwei drei vier f\u044cnf sechse',\n        \\ '5\tfoobar eins zwei drei vier f\u044cnf sechse',\n        \\ '6\tfoobar eins zwei drei vier f\u044cnf sechse',\n        \\ '7\tfoobar eins zwei drei vier f\u044cnf sechse'])\n  call setpos('.', [0, 4, 4, 0])\n  %s/\\%<.l.*//\n  call setpos('.', [0, 5, 4, 0])\n  %s/\\%>.l.*//\n  call assert_equal(['', '', '',\n        \\ '4 foobar eins zwei drei vier f\u044cnf sechse',\n        \\ '5\tfoobar eins zwei drei vier f\u044cnf sechse',\n        \\ '', ''],\n        \\ getline(1, '$'))\n  bwipe!\nendfunc\n\n\" Test that matching below, at or after the\n\" cursor position work\nfunc Test_matching_pos()\n  for val in range(3)\n    exe \"set re=\" .. val\n    \" Match at cursor position\n    call s:curpos_test2()\n    \" Match before or after cursor position\n    call s:curpos_test3()\n  endfor\n  set re&\nendfunc\n\nfunc Test_using_mark_position()\n  \" this was using freed memory\n  new\n  norm O0\n  call assert_fails(\"s/\\\\%')\", 'E486:')\n  bwipe!\nendfunc\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n#ifdef FEAT_CINDENT\n\t\"+cindent\",\n#else\n\t\"-cindent\",\n#endif\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n#ifdef EBCDIC\n\t\"+ebcdic\",\n#else\n\t\"-ebcdic\",\n#endif\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n#ifdef FEAT_JUMPLIST\n\t\"+jumplist\",\n#else\n\t\"-jumplist\",\n#endif\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n#ifdef FEAT_LISP\n\t\"+lispindent\",\n#else\n\t\"-lispindent\",\n#endif\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n\t\"+mouse_gpm\",\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n#ifdef FEAT_SMARTINDENT\n\t\"+smartindent\",\n#else\n\t\"-smartindent\",\n#endif\n#ifdef FEAT_SODIUM\n\t\"+sodium\",\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n#ifdef FEAT_TAG_BINS\n\t\"+tag_binary\",\n#else\n\t\"-tag_binary\",\n#endif\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n#ifdef FEAT_TITLE\n\t\"+title\",\n#else\n\t\"-title\",\n#endif\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#ifdef MSWIN\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#else\n# ifdef HAVE_XPM\n\t\"+xpm\",\n# else\n\t\"-xpm\",\n# endif\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef USE_XSMP_INTERACT\n\t\"+xsmp_interact\",\n# else\n#  ifdef USE_XSMP\n\t\"+xsmp\",\n#  else\n\t\"-xsmp\",\n#  endif\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    3612,\n/**/\n    3611,\n/**/\n    3610,\n/**/\n    3609,\n/**/\n    3608,\n/**/\n    3607,\n/**/\n    3606,\n/**/\n    3605,\n/**/\n    3604,\n/**/\n    3603,\n/**/\n    3602,\n/**/\n    3601,\n/**/\n    3600,\n/**/\n    3599,\n/**/\n    3598,\n/**/\n    3597,\n/**/\n    3596,\n/**/\n    3595,\n/**/\n    3594,\n/**/\n    3593,\n/**/\n    3592,\n/**/\n    3591,\n/**/\n    3590,\n/**/\n    3589,\n/**/\n    3588,\n/**/\n    3587,\n/**/\n    3586,\n/**/\n    3585,\n/**/\n    3584,\n/**/\n    3583,\n/**/\n    3582,\n/**/\n    3581,\n/**/\n    3580,\n/**/\n    3579,\n/**/\n    3578,\n/**/\n    3577,\n/**/\n    3576,\n/**/\n    3575,\n/**/\n    3574,\n/**/\n    3573,\n/**/\n    3572,\n/**/\n    3571,\n/**/\n    3570,\n/**/\n    3569,\n/**/\n    3568,\n/**/\n    3567,\n/**/\n    3566,\n/**/\n    3565,\n/**/\n    3564,\n/**/\n    3563,\n/**/\n    3562,\n/**/\n    3561,\n/**/\n    3560,\n/**/\n    3559,\n/**/\n    3558,\n/**/\n    3557,\n/**/\n    3556,\n/**/\n    3555,\n/**/\n    3554,\n/**/\n    3553,\n/**/\n    3552,\n/**/\n    3551,\n/**/\n    3550,\n/**/\n    3549,\n/**/\n    3548,\n/**/\n    3547,\n/**/\n    3546,\n/**/\n    3545,\n/**/\n    3544,\n/**/\n    3543,\n/**/\n    3542,\n/**/\n    3541,\n/**/\n    3540,\n/**/\n    3539,\n/**/\n    3538,\n/**/\n    3537,\n/**/\n    3536,\n/**/\n    3535,\n/**/\n    3534,\n/**/\n    3533,\n/**/\n    3532,\n/**/\n    3531,\n/**/\n    3530,\n/**/\n    3529,\n/**/\n    3528,\n/**/\n    3527,\n/**/\n    3526,\n/**/\n    3525,\n/**/\n    3524,\n/**/\n    3523,\n/**/\n    3522,\n/**/\n    3521,\n/**/\n    3520,\n/**/\n    3519,\n/**/\n    3518,\n/**/\n    3517,\n/**/\n    3516,\n/**/\n    3515,\n/**/\n    3514,\n/**/\n    3513,\n/**/\n    3512,\n/**/\n    3511,\n/**/\n    3510,\n/**/\n    3509,\n/**/\n    3508,\n/**/\n    3507,\n/**/\n    3506,\n/**/\n    3505,\n/**/\n    3504,\n/**/\n    3503,\n/**/\n    3502,\n/**/\n    3501,\n/**/\n    3500,\n/**/\n    3499,\n/**/\n    3498,\n/**/\n    3497,\n/**/\n    3496,\n/**/\n    3495,\n/**/\n    3494,\n/**/\n    3493,\n/**/\n    3492,\n/**/\n    3491,\n/**/\n    3490,\n/**/\n    3489,\n/**/\n    3488,\n/**/\n    3487,\n/**/\n    3486,\n/**/\n    3485,\n/**/\n    3484,\n/**/\n    3483,\n/**/\n    3482,\n/**/\n    3481,\n/**/\n    3480,\n/**/\n    3479,\n/**/\n    3478,\n/**/\n    3477,\n/**/\n    3476,\n/**/\n    3475,\n/**/\n    3474,\n/**/\n    3473,\n/**/\n    3472,\n/**/\n    3471,\n/**/\n    3470,\n/**/\n    3469,\n/**/\n    3468,\n/**/\n    3467,\n/**/\n    3466,\n/**/\n    3465,\n/**/\n    3464,\n/**/\n    3463,\n/**/\n    3462,\n/**/\n    3461,\n/**/\n    3460,\n/**/\n    3459,\n/**/\n    3458,\n/**/\n    3457,\n/**/\n    3456,\n/**/\n    3455,\n/**/\n    3454,\n/**/\n    3453,\n/**/\n    3452,\n/**/\n    3451,\n/**/\n    3450,\n/**/\n    3449,\n/**/\n    3448,\n/**/\n    3447,\n/**/\n    3446,\n/**/\n    3445,\n/**/\n    3444,\n/**/\n    3443,\n/**/\n    3442,\n/**/\n    3441,\n/**/\n    3440,\n/**/\n    3439,\n/**/\n    3438,\n/**/\n    3437,\n/**/\n    3436,\n/**/\n    3435,\n/**/\n    3434,\n/**/\n    3433,\n/**/\n    3432,\n/**/\n    3431,\n/**/\n    3430,\n/**/\n    3429,\n/**/\n    3428,\n/**/\n    3427,\n/**/\n    3426,\n/**/\n    3425,\n/**/\n    3424,\n/**/\n    3423,\n/**/\n    3422,\n/**/\n    3421,\n/**/\n    3420,\n/**/\n    3419,\n/**/\n    3418,\n/**/\n    3417,\n/**/\n    3416,\n/**/\n    3415,\n/**/\n    3414,\n/**/\n    3413,\n/**/\n    3412,\n/**/\n    3411,\n/**/\n    3410,\n/**/\n    3409,\n/**/\n    3408,\n/**/\n    3407,\n/**/\n    3406,\n/**/\n    3405,\n/**/\n    3404,\n/**/\n    3403,\n/**/\n    3402,\n/**/\n    3401,\n/**/\n    3400,\n/**/\n    3399,\n/**/\n    3398,\n/**/\n    3397,\n/**/\n    3396,\n/**/\n    3395,\n/**/\n    3394,\n/**/\n    3393,\n/**/\n    3392,\n/**/\n    3391,\n/**/\n    3390,\n/**/\n    3389,\n/**/\n    3388,\n/**/\n    3387,\n/**/\n    3386,\n/**/\n    3385,\n/**/\n    3384,\n/**/\n    3383,\n/**/\n    3382,\n/**/\n    3381,\n/**/\n    3380,\n/**/\n    3379,\n/**/\n    3378,\n/**/\n    3377,\n/**/\n    3376,\n/**/\n    3375,\n/**/\n    3374,\n/**/\n    3373,\n/**/\n    3372,\n/**/\n    3371,\n/**/\n    3370,\n/**/\n    3369,\n/**/\n    3368,\n/**/\n    3367,\n/**/\n    3366,\n/**/\n    3365,\n/**/\n    3364,\n/**/\n    3363,\n/**/\n    3362,\n/**/\n    3361,\n/**/\n    3360,\n/**/\n    3359,\n/**/\n    3358,\n/**/\n    3357,\n/**/\n    3356,\n/**/\n    3355,\n/**/\n    3354,\n/**/\n    3353,\n/**/\n    3352,\n/**/\n    3351,\n/**/\n    3350,\n/**/\n    3349,\n/**/\n    3348,\n/**/\n    3347,\n/**/\n    3346,\n/**/\n    3345,\n/**/\n    3344,\n/**/\n    3343,\n/**/\n    3342,\n/**/\n    3341,\n/**/\n    3340,\n/**/\n    3339,\n/**/\n    3338,\n/**/\n    3337,\n/**/\n    3336,\n/**/\n    3335,\n/**/\n    3334,\n/**/\n    3333,\n/**/\n    3332,\n/**/\n    3331,\n/**/\n    3330,\n/**/\n    3329,\n/**/\n    3328,\n/**/\n    3327,\n/**/\n    3326,\n/**/\n    3325,\n/**/\n    3324,\n/**/\n    3323,\n/**/\n    3322,\n/**/\n    3321,\n/**/\n    3320,\n/**/\n    3319,\n/**/\n    3318,\n/**/\n    3317,\n/**/\n    3316,\n/**/\n    3315,\n/**/\n    3314,\n/**/\n    3313,\n/**/\n    3312,\n/**/\n    3311,\n/**/\n    3310,\n/**/\n    3309,\n/**/\n    3308,\n/**/\n    3307,\n/**/\n    3306,\n/**/\n    3305,\n/**/\n    3304,\n/**/\n    3303,\n/**/\n    3302,\n/**/\n    3301,\n/**/\n    3300,\n/**/\n    3299,\n/**/\n    3298,\n/**/\n    3297,\n/**/\n    3296,\n/**/\n    3295,\n/**/\n    3294,\n/**/\n    3293,\n/**/\n    3292,\n/**/\n    3291,\n/**/\n    3290,\n/**/\n    3289,\n/**/\n    3288,\n/**/\n    3287,\n/**/\n    3286,\n/**/\n    3285,\n/**/\n    3284,\n/**/\n    3283,\n/**/\n    3282,\n/**/\n    3281,\n/**/\n    3280,\n/**/\n    3279,\n/**/\n    3278,\n/**/\n    3277,\n/**/\n    3276,\n/**/\n    3275,\n/**/\n    3274,\n/**/\n    3273,\n/**/\n    3272,\n/**/\n    3271,\n/**/\n    3270,\n/**/\n    3269,\n/**/\n    3268,\n/**/\n    3267,\n/**/\n    3266,\n/**/\n    3265,\n/**/\n    3264,\n/**/\n    3263,\n/**/\n    3262,\n/**/\n    3261,\n/**/\n    3260,\n/**/\n    3259,\n/**/\n    3258,\n/**/\n    3257,\n/**/\n    3256,\n/**/\n    3255,\n/**/\n    3254,\n/**/\n    3253,\n/**/\n    3252,\n/**/\n    3251,\n/**/\n    3250,\n/**/\n    3249,\n/**/\n    3248,\n/**/\n    3247,\n/**/\n    3246,\n/**/\n    3245,\n/**/\n    3244,\n/**/\n    3243,\n/**/\n    3242,\n/**/\n    3241,\n/**/\n    3240,\n/**/\n    3239,\n/**/\n    3238,\n/**/\n    3237,\n/**/\n    3236,\n/**/\n    3235,\n/**/\n    3234,\n/**/\n    3233,\n/**/\n    3232,\n/**/\n    3231,\n/**/\n    3230,\n/**/\n    3229,\n/**/\n    3228,\n/**/\n    3227,\n/**/\n    3226,\n/**/\n    3225,\n/**/\n    3224,\n/**/\n    3223,\n/**/\n    3222,\n/**/\n    3221,\n/**/\n    3220,\n/**/\n    3219,\n/**/\n    3218,\n/**/\n    3217,\n/**/\n    3216,\n/**/\n    3215,\n/**/\n    3214,\n/**/\n    3213,\n/**/\n    3212,\n/**/\n    3211,\n/**/\n    3210,\n/**/\n    3209,\n/**/\n    3208,\n/**/\n    3207,\n/**/\n    3206,\n/**/\n    3205,\n/**/\n    3204,\n/**/\n    3203,\n/**/\n    3202,\n/**/\n    3201,\n/**/\n    3200,\n/**/\n    3199,\n/**/\n    3198,\n/**/\n    3197,\n/**/\n    3196,\n/**/\n    3195,\n/**/\n    3194,\n/**/\n    3193,\n/**/\n    3192,\n/**/\n    3191,\n/**/\n    3190,\n/**/\n    3189,\n/**/\n    3188,\n/**/\n    3187,\n/**/\n    3186,\n/**/\n    3185,\n/**/\n    3184,\n/**/\n    3183,\n/**/\n    3182,\n/**/\n    3181,\n/**/\n    3180,\n/**/\n    3179,\n/**/\n    3178,\n/**/\n    3177,\n/**/\n    3176,\n/**/\n    3175,\n/**/\n    3174,\n/**/\n    3173,\n/**/\n    3172,\n/**/\n    3171,\n/**/\n    3170,\n/**/\n    3169,\n/**/\n    3168,\n/**/\n    3167,\n/**/\n    3166,\n/**/\n    3165,\n/**/\n    3164,\n/**/\n    3163,\n/**/\n    3162,\n/**/\n    3161,\n/**/\n    3160,\n/**/\n    3159,\n/**/\n    3158,\n/**/\n    3157,\n/**/\n    3156,\n/**/\n    3155,\n/**/\n    3154,\n/**/\n    3153,\n/**/\n    3152,\n/**/\n    3151,\n/**/\n    3150,\n/**/\n    3149,\n/**/\n    3148,\n/**/\n    3147,\n/**/\n    3146,\n/**/\n    3145,\n/**/\n    3144,\n/**/\n    3143,\n/**/\n    3142,\n/**/\n    3141,\n/**/\n    3140,\n/**/\n    3139,\n/**/\n    3138,\n/**/\n    3137,\n/**/\n    3136,\n/**/\n    3135,\n/**/\n    3134,\n/**/\n    3133,\n/**/\n    3132,\n/**/\n    3131,\n/**/\n    3130,\n/**/\n    3129,\n/**/\n    3128,\n/**/\n    3127,\n/**/\n    3126,\n/**/\n    3125,\n/**/\n    3124,\n/**/\n    3123,\n/**/\n    3122,\n/**/\n    3121,\n/**/\n    3120,\n/**/\n    3119,\n/**/\n    3118,\n/**/\n    3117,\n/**/\n    3116,\n/**/\n    3115,\n/**/\n    3114,\n/**/\n    3113,\n/**/\n    3112,\n/**/\n    3111,\n/**/\n    3110,\n/**/\n    3109,\n/**/\n    3108,\n/**/\n    3107,\n/**/\n    3106,\n/**/\n    3105,\n/**/\n    3104,\n/**/\n    3103,\n/**/\n    3102,\n/**/\n    3101,\n/**/\n    3100,\n/**/\n    3099,\n/**/\n    3098,\n/**/\n    3097,\n/**/\n    3096,\n/**/\n    3095,\n/**/\n    3094,\n/**/\n    3093,\n/**/\n    3092,\n/**/\n    3091,\n/**/\n    3090,\n/**/\n    3089,\n/**/\n    3088,\n/**/\n    3087,\n/**/\n    3086,\n/**/\n    3085,\n/**/\n    3084,\n/**/\n    3083,\n/**/\n    3082,\n/**/\n    3081,\n/**/\n    3080,\n/**/\n    3079,\n/**/\n    3078,\n/**/\n    3077,\n/**/\n    3076,\n/**/\n    3075,\n/**/\n    3074,\n/**/\n    3073,\n/**/\n    3072,\n/**/\n    3071,\n/**/\n    3070,\n/**/\n    3069,\n/**/\n    3068,\n/**/\n    3067,\n/**/\n    3066,\n/**/\n    3065,\n/**/\n    3064,\n/**/\n    3063,\n/**/\n    3062,\n/**/\n    3061,\n/**/\n    3060,\n/**/\n    3059,\n/**/\n    3058,\n/**/\n    3057,\n/**/\n    3056,\n/**/\n    3055,\n/**/\n    3054,\n/**/\n    3053,\n/**/\n    3052,\n/**/\n    3051,\n/**/\n    3050,\n/**/\n    3049,\n/**/\n    3048,\n/**/\n    3047,\n/**/\n    3046,\n/**/\n    3045,\n/**/\n    3044,\n/**/\n    3043,\n/**/\n    3042,\n/**/\n    3041,\n/**/\n    3040,\n/**/\n    3039,\n/**/\n    3038,\n/**/\n    3037,\n/**/\n    3036,\n/**/\n    3035,\n/**/\n    3034,\n/**/\n    3033,\n/**/\n    3032,\n/**/\n    3031,\n/**/\n    3030,\n/**/\n    3029,\n/**/\n    3028,\n/**/\n    3027,\n/**/\n    3026,\n/**/\n    3025,\n/**/\n    3024,\n/**/\n    3023,\n/**/\n    3022,\n/**/\n    3021,\n/**/\n    3020,\n/**/\n    3019,\n/**/\n    3018,\n/**/\n    3017,\n/**/\n    3016,\n/**/\n    3015,\n/**/\n    3014,\n/**/\n    3013,\n/**/\n    3012,\n/**/\n    3011,\n/**/\n    3010,\n/**/\n    3009,\n/**/\n    3008,\n/**/\n    3007,\n/**/\n    3006,\n/**/\n    3005,\n/**/\n    3004,\n/**/\n    3003,\n/**/\n    3002,\n/**/\n    3001,\n/**/\n    3000,\n/**/\n    2999,\n/**/\n    2998,\n/**/\n    2997,\n/**/\n    2996,\n/**/\n    2995,\n/**/\n    2994,\n/**/\n    2993,\n/**/\n    2992,\n/**/\n    2991,\n/**/\n    2990,\n/**/\n    2989,\n/**/\n    2988,\n/**/\n    2987,\n/**/\n    2986,\n/**/\n    2985,\n/**/\n    2984,\n/**/\n    2983,\n/**/\n    2982,\n/**/\n    2981,\n/**/\n    2980,\n/**/\n    2979,\n/**/\n    2978,\n/**/\n    2977,\n/**/\n    2976,\n/**/\n    2975,\n/**/\n    2974,\n/**/\n    2973,\n/**/\n    2972,\n/**/\n    2971,\n/**/\n    2970,\n/**/\n    2969,\n/**/\n    2968,\n/**/\n    2967,\n/**/\n    2966,\n/**/\n    2965,\n/**/\n    2964,\n/**/\n    2963,\n/**/\n    2962,\n/**/\n    2961,\n/**/\n    2960,\n/**/\n    2959,\n/**/\n    2958,\n/**/\n    2957,\n/**/\n    2956,\n/**/\n    2955,\n/**/\n    2954,\n/**/\n    2953,\n/**/\n    2952,\n/**/\n    2951,\n/**/\n    2950,\n/**/\n    2949,\n/**/\n    2948,\n/**/\n    2947,\n/**/\n    2946,\n/**/\n    2945,\n/**/\n    2944,\n/**/\n    2943,\n/**/\n    2942,\n/**/\n    2941,\n/**/\n    2940,\n/**/\n    2939,\n/**/\n    2938,\n/**/\n    2937,\n/**/\n    2936,\n/**/\n    2935,\n/**/\n    2934,\n/**/\n    2933,\n/**/\n    2932,\n/**/\n    2931,\n/**/\n    2930,\n/**/\n    2929,\n/**/\n    2928,\n/**/\n    2927,\n/**/\n    2926,\n/**/\n    2925,\n/**/\n    2924,\n/**/\n    2923,\n/**/\n    2922,\n/**/\n    2921,\n/**/\n    2920,\n/**/\n    2919,\n/**/\n    2918,\n/**/\n    2917,\n/**/\n    2916,\n/**/\n    2915,\n/**/\n    2914,\n/**/\n    2913,\n/**/\n    2912,\n/**/\n    2911,\n/**/\n    2910,\n/**/\n    2909,\n/**/\n    2908,\n/**/\n    2907,\n/**/\n    2906,\n/**/\n    2905,\n/**/\n    2904,\n/**/\n    2903,\n/**/\n    2902,\n/**/\n    2901,\n/**/\n    2900,\n/**/\n    2899,\n/**/\n    2898,\n/**/\n    2897,\n/**/\n    2896,\n/**/\n    2895,\n/**/\n    2894,\n/**/\n    2893,\n/**/\n    2892,\n/**/\n    2891,\n/**/\n    2890,\n/**/\n    2889,\n/**/\n    2888,\n/**/\n    2887,\n/**/\n    2886,\n/**/\n    2885,\n/**/\n    2884,\n/**/\n    2883,\n/**/\n    2882,\n/**/\n    2881,\n/**/\n    2880,\n/**/\n    2879,\n/**/\n    2878,\n/**/\n    2877,\n/**/\n    2876,\n/**/\n    2875,\n/**/\n    2874,\n/**/\n    2873,\n/**/\n    2872,\n/**/\n    2871,\n/**/\n    2870,\n/**/\n    2869,\n/**/\n    2868,\n/**/\n    2867,\n/**/\n    2866,\n/**/\n    2865,\n/**/\n    2864,\n/**/\n    2863,\n/**/\n    2862,\n/**/\n    2861,\n/**/\n    2860,\n/**/\n    2859,\n/**/\n    2858,\n/**/\n    2857,\n/**/\n    2856,\n/**/\n    2855,\n/**/\n    2854,\n/**/\n    2853,\n/**/\n    2852,\n/**/\n    2851,\n/**/\n    2850,\n/**/\n    2849,\n/**/\n    2848,\n/**/\n    2847,\n/**/\n    2846,\n/**/\n    2845,\n/**/\n    2844,\n/**/\n    2843,\n/**/\n    2842,\n/**/\n    2841,\n/**/\n    2840,\n/**/\n    2839,\n/**/\n    2838,\n/**/\n    2837,\n/**/\n    2836,\n/**/\n    2835,\n/**/\n    2834,\n/**/\n    2833,\n/**/\n    2832,\n/**/\n    2831,\n/**/\n    2830,\n/**/\n    2829,\n/**/\n    2828,\n/**/\n    2827,\n/**/\n    2826,\n/**/\n    2825,\n/**/\n    2824,\n/**/\n    2823,\n/**/\n    2822,\n/**/\n    2821,\n/**/\n    2820,\n/**/\n    2819,\n/**/\n    2818,\n/**/\n    2817,\n/**/\n    2816,\n/**/\n    2815,\n/**/\n    2814,\n/**/\n    2813,\n/**/\n    2812,\n/**/\n    2811,\n/**/\n    2810,\n/**/\n    2809,\n/**/\n    2808,\n/**/\n    2807,\n/**/\n    2806,\n/**/\n    2805,\n/**/\n    2804,\n/**/\n    2803,\n/**/\n    2802,\n/**/\n    2801,\n/**/\n    2800,\n/**/\n    2799,\n/**/\n    2798,\n/**/\n    2797,\n/**/\n    2796,\n/**/\n    2795,\n/**/\n    2794,\n/**/\n    2793,\n/**/\n    2792,\n/**/\n    2791,\n/**/\n    2790,\n/**/\n    2789,\n/**/\n    2788,\n/**/\n    2787,\n/**/\n    2786,\n/**/\n    2785,\n/**/\n    2784,\n/**/\n    2783,\n/**/\n    2782,\n/**/\n    2781,\n/**/\n    2780,\n/**/\n    2779,\n/**/\n    2778,\n/**/\n    2777,\n/**/\n    2776,\n/**/\n    2775,\n/**/\n    2774,\n/**/\n    2773,\n/**/\n    2772,\n/**/\n    2771,\n/**/\n    2770,\n/**/\n    2769,\n/**/\n    2768,\n/**/\n    2767,\n/**/\n    2766,\n/**/\n    2765,\n/**/\n    2764,\n/**/\n    2763,\n/**/\n    2762,\n/**/\n    2761,\n/**/\n    2760,\n/**/\n    2759,\n/**/\n    2758,\n/**/\n    2757,\n/**/\n    2756,\n/**/\n    2755,\n/**/\n    2754,\n/**/\n    2753,\n/**/\n    2752,\n/**/\n    2751,\n/**/\n    2750,\n/**/\n    2749,\n/**/\n    2748,\n/**/\n    2747,\n/**/\n    2746,\n/**/\n    2745,\n/**/\n    2744,\n/**/\n    2743,\n/**/\n    2742,\n/**/\n    2741,\n/**/\n    2740,\n/**/\n    2739,\n/**/\n    2738,\n/**/\n    2737,\n/**/\n    2736,\n/**/\n    2735,\n/**/\n    2734,\n/**/\n    2733,\n/**/\n    2732,\n/**/\n    2731,\n/**/\n    2730,\n/**/\n    2729,\n/**/\n    2728,\n/**/\n    2727,\n/**/\n    2726,\n/**/\n    2725,\n/**/\n    2724,\n/**/\n    2723,\n/**/\n    2722,\n/**/\n    2721,\n/**/\n    2720,\n/**/\n    2719,\n/**/\n    2718,\n/**/\n    2717,\n/**/\n    2716,\n/**/\n    2715,\n/**/\n    2714,\n/**/\n    2713,\n/**/\n    2712,\n/**/\n    2711,\n/**/\n    2710,\n/**/\n    2709,\n/**/\n    2708,\n/**/\n    2707,\n/**/\n    2706,\n/**/\n    2705,\n/**/\n    2704,\n/**/\n    2703,\n/**/\n    2702,\n/**/\n    2701,\n/**/\n    2700,\n/**/\n    2699,\n/**/\n    2698,\n/**/\n    2697,\n/**/\n    2696,\n/**/\n    2695,\n/**/\n    2694,\n/**/\n    2693,\n/**/\n    2692,\n/**/\n    2691,\n/**/\n    2690,\n/**/\n    2689,\n/**/\n    2688,\n/**/\n    2687,\n/**/\n    2686,\n/**/\n    2685,\n/**/\n    2684,\n/**/\n    2683,\n/**/\n    2682,\n/**/\n    2681,\n/**/\n    2680,\n/**/\n    2679,\n/**/\n    2678,\n/**/\n    2677,\n/**/\n    2676,\n/**/\n    2675,\n/**/\n    2674,\n/**/\n    2673,\n/**/\n    2672,\n/**/\n    2671,\n/**/\n    2670,\n/**/\n    2669,\n/**/\n    2668,\n/**/\n    2667,\n/**/\n    2666,\n/**/\n    2665,\n/**/\n    2664,\n/**/\n    2663,\n/**/\n    2662,\n/**/\n    2661,\n/**/\n    2660,\n/**/\n    2659,\n/**/\n    2658,\n/**/\n    2657,\n/**/\n    2656,\n/**/\n    2655,\n/**/\n    2654,\n/**/\n    2653,\n/**/\n    2652,\n/**/\n    2651,\n/**/\n    2650,\n/**/\n    2649,\n/**/\n    2648,\n/**/\n    2647,\n/**/\n    2646,\n/**/\n    2645,\n/**/\n    2644,\n/**/\n    2643,\n/**/\n    2642,\n/**/\n    2641,\n/**/\n    2640,\n/**/\n    2639,\n/**/\n    2638,\n/**/\n    2637,\n/**/\n    2636,\n/**/\n    2635,\n/**/\n    2634,\n/**/\n    2633,\n/**/\n    2632,\n/**/\n    2631,\n/**/\n    2630,\n/**/\n    2629,\n/**/\n    2628,\n/**/\n    2627,\n/**/\n    2626,\n/**/\n    2625,\n/**/\n    2624,\n/**/\n    2623,\n/**/\n    2622,\n/**/\n    2621,\n/**/\n    2620,\n/**/\n    2619,\n/**/\n    2618,\n/**/\n    2617,\n/**/\n    2616,\n/**/\n    2615,\n/**/\n    2614,\n/**/\n    2613,\n/**/\n    2612,\n/**/\n    2611,\n/**/\n    2610,\n/**/\n    2609,\n/**/\n    2608,\n/**/\n    2607,\n/**/\n    2606,\n/**/\n    2605,\n/**/\n    2604,\n/**/\n    2603,\n/**/\n    2602,\n/**/\n    2601,\n/**/\n    2600,\n/**/\n    2599,\n/**/\n    2598,\n/**/\n    2597,\n/**/\n    2596,\n/**/\n    2595,\n/**/\n    2594,\n/**/\n    2593,\n/**/\n    2592,\n/**/\n    2591,\n/**/\n    2590,\n/**/\n    2589,\n/**/\n    2588,\n/**/\n    2587,\n/**/\n    2586,\n/**/\n    2585,\n/**/\n    2584,\n/**/\n    2583,\n/**/\n    2582,\n/**/\n    2581,\n/**/\n    2580,\n/**/\n    2579,\n/**/\n    2578,\n/**/\n    2577,\n/**/\n    2576,\n/**/\n    2575,\n/**/\n    2574,\n/**/\n    2573,\n/**/\n    2572,\n/**/\n    2571,\n/**/\n    2570,\n/**/\n    2569,\n/**/\n    2568,\n/**/\n    2567,\n/**/\n    2566,\n/**/\n    2565,\n/**/\n    2564,\n/**/\n    2563,\n/**/\n    2562,\n/**/\n    2561,\n/**/\n    2560,\n/**/\n    2559,\n/**/\n    2558,\n/**/\n    2557,\n/**/\n    2556,\n/**/\n    2555,\n/**/\n    2554,\n/**/\n    2553,\n/**/\n    2552,\n/**/\n    2551,\n/**/\n    2550,\n/**/\n    2549,\n/**/\n    2548,\n/**/\n    2547,\n/**/\n    2546,\n/**/\n    2545,\n/**/\n    2544,\n/**/\n    2543,\n/**/\n    2542,\n/**/\n    2541,\n/**/\n    2540,\n/**/\n    2539,\n/**/\n    2538,\n/**/\n    2537,\n/**/\n    2536,\n/**/\n    2535,\n/**/\n    2534,\n/**/\n    2533,\n/**/\n    2532,\n/**/\n    2531,\n/**/\n    2530,\n/**/\n    2529,\n/**/\n    2528,\n/**/\n    2527,\n/**/\n    2526,\n/**/\n    2525,\n/**/\n    2524,\n/**/\n    2523,\n/**/\n    2522,\n/**/\n    2521,\n/**/\n    2520,\n/**/\n    2519,\n/**/\n    2518,\n/**/\n    2517,\n/**/\n    2516,\n/**/\n    2515,\n/**/\n    2514,\n/**/\n    2513,\n/**/\n    2512,\n/**/\n    2511,\n/**/\n    2510,\n/**/\n    2509,\n/**/\n    2508,\n/**/\n    2507,\n/**/\n    2506,\n/**/\n    2505,\n/**/\n    2504,\n/**/\n    2503,\n/**/\n    2502,\n/**/\n    2501,\n/**/\n    2500,\n/**/\n    2499,\n/**/\n    2498,\n/**/\n    2497,\n/**/\n    2496,\n/**/\n    2495,\n/**/\n    2494,\n/**/\n    2493,\n/**/\n    2492,\n/**/\n    2491,\n/**/\n    2490,\n/**/\n    2489,\n/**/\n    2488,\n/**/\n    2487,\n/**/\n    2486,\n/**/\n    2485,\n/**/\n    2484,\n/**/\n    2483,\n/**/\n    2482,\n/**/\n    2481,\n/**/\n    2480,\n/**/\n    2479,\n/**/\n    2478,\n/**/\n    2477,\n/**/\n    2476,\n/**/\n    2475,\n/**/\n    2474,\n/**/\n    2473,\n/**/\n    2472,\n/**/\n    2471,\n/**/\n    2470,\n/**/\n    2469,\n/**/\n    2468,\n/**/\n    2467,\n/**/\n    2466,\n/**/\n    2465,\n/**/\n    2464,\n/**/\n    2463,\n/**/\n    2462,\n/**/\n    2461,\n/**/\n    2460,\n/**/\n    2459,\n/**/\n    2458,\n/**/\n    2457,\n/**/\n    2456,\n/**/\n    2455,\n/**/\n    2454,\n/**/\n    2453,\n/**/\n    2452,\n/**/\n    2451,\n/**/\n    2450,\n/**/\n    2449,\n/**/\n    2448,\n/**/\n    2447,\n/**/\n    2446,\n/**/\n    2445,\n/**/\n    2444,\n/**/\n    2443,\n/**/\n    2442,\n/**/\n    2441,\n/**/\n    2440,\n/**/\n    2439,\n/**/\n    2438,\n/**/\n    2437,\n/**/\n    2436,\n/**/\n    2435,\n/**/\n    2434,\n/**/\n    2433,\n/**/\n    2432,\n/**/\n    2431,\n/**/\n    2430,\n/**/\n    2429,\n/**/\n    2428,\n/**/\n    2427,\n/**/\n    2426,\n/**/\n    2425,\n/**/\n    2424,\n/**/\n    2423,\n/**/\n    2422,\n/**/\n    2421,\n/**/\n    2420,\n/**/\n    2419,\n/**/\n    2418,\n/**/\n    2417,\n/**/\n    2416,\n/**/\n    2415,\n/**/\n    2414,\n/**/\n    2413,\n/**/\n    2412,\n/**/\n    2411,\n/**/\n    2410,\n/**/\n    2409,\n/**/\n    2408,\n/**/\n    2407,\n/**/\n    2406,\n/**/\n    2405,\n/**/\n    2404,\n/**/\n    2403,\n/**/\n    2402,\n/**/\n    2401,\n/**/\n    2400,\n/**/\n    2399,\n/**/\n    2398,\n/**/\n    2397,\n/**/\n    2396,\n/**/\n    2395,\n/**/\n    2394,\n/**/\n    2393,\n/**/\n    2392,\n/**/\n    2391,\n/**/\n    2390,\n/**/\n    2389,\n/**/\n    2388,\n/**/\n    2387,\n/**/\n    2386,\n/**/\n    2385,\n/**/\n    2384,\n/**/\n    2383,\n/**/\n    2382,\n/**/\n    2381,\n/**/\n    2380,\n/**/\n    2379,\n/**/\n    2378,\n/**/\n    2377,\n/**/\n    2376,\n/**/\n    2375,\n/**/\n    2374,\n/**/\n    2373,\n/**/\n    2372,\n/**/\n    2371,\n/**/\n    2370,\n/**/\n    2369,\n/**/\n    2368,\n/**/\n    2367,\n/**/\n    2366,\n/**/\n    2365,\n/**/\n    2364,\n/**/\n    2363,\n/**/\n    2362,\n/**/\n    2361,\n/**/\n    2360,\n/**/\n    2359,\n/**/\n    2358,\n/**/\n    2357,\n/**/\n    2356,\n/**/\n    2355,\n/**/\n    2354,\n/**/\n    2353,\n/**/\n    2352,\n/**/\n    2351,\n/**/\n    2350,\n/**/\n    2349,\n/**/\n    2348,\n/**/\n    2347,\n/**/\n    2346,\n/**/\n    2345,\n/**/\n    2344,\n/**/\n    2343,\n/**/\n    2342,\n/**/\n    2341,\n/**/\n    2340,\n/**/\n    2339,\n/**/\n    2338,\n/**/\n    2337,\n/**/\n    2336,\n/**/\n    2335,\n/**/\n    2334,\n/**/\n    2333,\n/**/\n    2332,\n/**/\n    2331,\n/**/\n    2330,\n/**/\n    2329,\n/**/\n    2328,\n/**/\n    2327,\n/**/\n    2326,\n/**/\n    2325,\n/**/\n    2324,\n/**/\n    2323,\n/**/\n    2322,\n/**/\n    2321,\n/**/\n    2320,\n/**/\n    2319,\n/**/\n    2318,\n/**/\n    2317,\n/**/\n    2316,\n/**/\n    2315,\n/**/\n    2314,\n/**/\n    2313,\n/**/\n    2312,\n/**/\n    2311,\n/**/\n    2310,\n/**/\n    2309,\n/**/\n    2308,\n/**/\n    2307,\n/**/\n    2306,\n/**/\n    2305,\n/**/\n    2304,\n/**/\n    2303,\n/**/\n    2302,\n/**/\n    2301,\n/**/\n    2300,\n/**/\n    2299,\n/**/\n    2298,\n/**/\n    2297,\n/**/\n    2296,\n/**/\n    2295,\n/**/\n    2294,\n/**/\n    2293,\n/**/\n    2292,\n/**/\n    2291,\n/**/\n    2290,\n/**/\n    2289,\n/**/\n    2288,\n/**/\n    2287,\n/**/\n    2286,\n/**/\n    2285,\n/**/\n    2284,\n/**/\n    2283,\n/**/\n    2282,\n/**/\n    2281,\n/**/\n    2280,\n/**/\n    2279,\n/**/\n    2278,\n/**/\n    2277,\n/**/\n    2276,\n/**/\n    2275,\n/**/\n    2274,\n/**/\n    2273,\n/**/\n    2272,\n/**/\n    2271,\n/**/\n    2270,\n/**/\n    2269,\n/**/\n    2268,\n/**/\n    2267,\n/**/\n    2266,\n/**/\n    2265,\n/**/\n    2264,\n/**/\n    2263,\n/**/\n    2262,\n/**/\n    2261,\n/**/\n    2260,\n/**/\n    2259,\n/**/\n    2258,\n/**/\n    2257,\n/**/\n    2256,\n/**/\n    2255,\n/**/\n    2254,\n/**/\n    2253,\n/**/\n    2252,\n/**/\n    2251,\n/**/\n    2250,\n/**/\n    2249,\n/**/\n    2248,\n/**/\n    2247,\n/**/\n    2246,\n/**/\n    2245,\n/**/\n    2244,\n/**/\n    2243,\n/**/\n    2242,\n/**/\n    2241,\n/**/\n    2240,\n/**/\n    2239,\n/**/\n    2238,\n/**/\n    2237,\n/**/\n    2236,\n/**/\n    2235,\n/**/\n    2234,\n/**/\n    2233,\n/**/\n    2232,\n/**/\n    2231,\n/**/\n    2230,\n/**/\n    2229,\n/**/\n    2228,\n/**/\n    2227,\n/**/\n    2226,\n/**/\n    2225,\n/**/\n    2224,\n/**/\n    2223,\n/**/\n    2222,\n/**/\n    2221,\n/**/\n    2220,\n/**/\n    2219,\n/**/\n    2218,\n/**/\n    2217,\n/**/\n    2216,\n/**/\n    2215,\n/**/\n    2214,\n/**/\n    2213,\n/**/\n    2212,\n/**/\n    2211,\n/**/\n    2210,\n/**/\n    2209,\n/**/\n    2208,\n/**/\n    2207,\n/**/\n    2206,\n/**/\n    2205,\n/**/\n    2204,\n/**/\n    2203,\n/**/\n    2202,\n/**/\n    2201,\n/**/\n    2200,\n/**/\n    2199,\n/**/\n    2198,\n/**/\n    2197,\n/**/\n    2196,\n/**/\n    2195,\n/**/\n    2194,\n/**/\n    2193,\n/**/\n    2192,\n/**/\n    2191,\n/**/\n    2190,\n/**/\n    2189,\n/**/\n    2188,\n/**/\n    2187,\n/**/\n    2186,\n/**/\n    2185,\n/**/\n    2184,\n/**/\n    2183,\n/**/\n    2182,\n/**/\n    2181,\n/**/\n    2180,\n/**/\n    2179,\n/**/\n    2178,\n/**/\n    2177,\n/**/\n    2176,\n/**/\n    2175,\n/**/\n    2174,\n/**/\n    2173,\n/**/\n    2172,\n/**/\n    2171,\n/**/\n    2170,\n/**/\n    2169,\n/**/\n    2168,\n/**/\n    2167,\n/**/\n    2166,\n/**/\n    2165,\n/**/\n    2164,\n/**/\n    2163,\n/**/\n    2162,\n/**/\n    2161,\n/**/\n    2160,\n/**/\n    2159,\n/**/\n    2158,\n/**/\n    2157,\n/**/\n    2156,\n/**/\n    2155,\n/**/\n    2154,\n/**/\n    2153,\n/**/\n    2152,\n/**/\n    2151,\n/**/\n    2150,\n/**/\n    2149,\n/**/\n    2148,\n/**/\n    2147,\n/**/\n    2146,\n/**/\n    2145,\n/**/\n    2144,\n/**/\n    2143,\n/**/\n    2142,\n/**/\n    2141,\n/**/\n    2140,\n/**/\n    2139,\n/**/\n    2138,\n/**/\n    2137,\n/**/\n    2136,\n/**/\n    2135,\n/**/\n    2134,\n/**/\n    2133,\n/**/\n    2132,\n/**/\n    2131,\n/**/\n    2130,\n/**/\n    2129,\n/**/\n    2128,\n/**/\n    2127,\n/**/\n    2126,\n/**/\n    2125,\n/**/\n    2124,\n/**/\n    2123,\n/**/\n    2122,\n/**/\n    2121,\n/**/\n    2120,\n/**/\n    2119,\n/**/\n    2118,\n/**/\n    2117,\n/**/\n    2116,\n/**/\n    2115,\n/**/\n    2114,\n/**/\n    2113,\n/**/\n    2112,\n/**/\n    2111,\n/**/\n    2110,\n/**/\n    2109,\n/**/\n    2108,\n/**/\n    2107,\n/**/\n    2106,\n/**/\n    2105,\n/**/\n    2104,\n/**/\n    2103,\n/**/\n    2102,\n/**/\n    2101,\n/**/\n    2100,\n/**/\n    2099,\n/**/\n    2098,\n/**/\n    2097,\n/**/\n    2096,\n/**/\n    2095,\n/**/\n    2094,\n/**/\n    2093,\n/**/\n    2092,\n/**/\n    2091,\n/**/\n    2090,\n/**/\n    2089,\n/**/\n    2088,\n/**/\n    2087,\n/**/\n    2086,\n/**/\n    2085,\n/**/\n    2084,\n/**/\n    2083,\n/**/\n    2082,\n/**/\n    2081,\n/**/\n    2080,\n/**/\n    2079,\n/**/\n    2078,\n/**/\n    2077,\n/**/\n    2076,\n/**/\n    2075,\n/**/\n    2074,\n/**/\n    2073,\n/**/\n    2072,\n/**/\n    2071,\n/**/\n    2070,\n/**/\n    2069,\n/**/\n    2068,\n/**/\n    2067,\n/**/\n    2066,\n/**/\n    2065,\n/**/\n    2064,\n/**/\n    2063,\n/**/\n    2062,\n/**/\n    2061,\n/**/\n    2060,\n/**/\n    2059,\n/**/\n    2058,\n/**/\n    2057,\n/**/\n    2056,\n/**/\n    2055,\n/**/\n    2054,\n/**/\n    2053,\n/**/\n    2052,\n/**/\n    2051,\n/**/\n    2050,\n/**/\n    2049,\n/**/\n    2048,\n/**/\n    2047,\n/**/\n    2046,\n/**/\n    2045,\n/**/\n    2044,\n/**/\n    2043,\n/**/\n    2042,\n/**/\n    2041,\n/**/\n    2040,\n/**/\n    2039,\n/**/\n    2038,\n/**/\n    2037,\n/**/\n    2036,\n/**/\n    2035,\n/**/\n    2034,\n/**/\n    2033,\n/**/\n    2032,\n/**/\n    2031,\n/**/\n    2030,\n/**/\n    2029,\n/**/\n    2028,\n/**/\n    2027,\n/**/\n    2026,\n/**/\n    2025,\n/**/\n    2024,\n/**/\n    2023,\n/**/\n    2022,\n/**/\n    2021,\n/**/\n    2020,\n/**/\n    2019,\n/**/\n    2018,\n/**/\n    2017,\n/**/\n    2016,\n/**/\n    2015,\n/**/\n    2014,\n/**/\n    2013,\n/**/\n    2012,\n/**/\n    2011,\n/**/\n    2010,\n/**/\n    2009,\n/**/\n    2008,\n/**/\n    2007,\n/**/\n    2006,\n/**/\n    2005,\n/**/\n    2004,\n/**/\n    2003,\n/**/\n    2002,\n/**/\n    2001,\n/**/\n    2000,\n/**/\n    1999,\n/**/\n    1998,\n/**/\n    1997,\n/**/\n    1996,\n/**/\n    1995,\n/**/\n    1994,\n/**/\n    1993,\n/**/\n    1992,\n/**/\n    1991,\n/**/\n    1990,\n/**/\n    1989,\n/**/\n    1988,\n/**/\n    1987,\n/**/\n    1986,\n/**/\n    1985,\n/**/\n    1984,\n/**/\n    1983,\n/**/\n    1982,\n/**/\n    1981,\n/**/\n    1980,\n/**/\n    1979,\n/**/\n    1978,\n/**/\n    1977,\n/**/\n    1976,\n/**/\n    1975,\n/**/\n    1974,\n/**/\n    1973,\n/**/\n    1972,\n/**/\n    1971,\n/**/\n    1970,\n/**/\n    1969,\n/**/\n    1968,\n/**/\n    1967,\n/**/\n    1966,\n/**/\n    1965,\n/**/\n    1964,\n/**/\n    1963,\n/**/\n    1962,\n/**/\n    1961,\n/**/\n    1960,\n/**/\n    1959,\n/**/\n    1958,\n/**/\n    1957,\n/**/\n    1956,\n/**/\n    1955,\n/**/\n    1954,\n/**/\n    1953,\n/**/\n    1952,\n/**/\n    1951,\n/**/\n    1950,\n/**/\n    1949,\n/**/\n    1948,\n/**/\n    1947,\n/**/\n    1946,\n/**/\n    1945,\n/**/\n    1944,\n/**/\n    1943,\n/**/\n    1942,\n/**/\n    1941,\n/**/\n    1940,\n/**/\n    1939,\n/**/\n    1938,\n/**/\n    1937,\n/**/\n    1936,\n/**/\n    1935,\n/**/\n    1934,\n/**/\n    1933,\n/**/\n    1932,\n/**/\n    1931,\n/**/\n    1930,\n/**/\n    1929,\n/**/\n    1928,\n/**/\n    1927,\n/**/\n    1926,\n/**/\n    1925,\n/**/\n    1924,\n/**/\n    1923,\n/**/\n    1922,\n/**/\n    1921,\n/**/\n    1920,\n/**/\n    1919,\n/**/\n    1918,\n/**/\n    1917,\n/**/\n    1916,\n/**/\n    1915,\n/**/\n    1914,\n/**/\n    1913,\n/**/\n    1912,\n/**/\n    1911,\n/**/\n    1910,\n/**/\n    1909,\n/**/\n    1908,\n/**/\n    1907,\n/**/\n    1906,\n/**/\n    1905,\n/**/\n    1904,\n/**/\n    1903,\n/**/\n    1902,\n/**/\n    1901,\n/**/\n    1900,\n/**/\n    1899,\n/**/\n    1898,\n/**/\n    1897,\n/**/\n    1896,\n/**/\n    1895,\n/**/\n    1894,\n/**/\n    1893,\n/**/\n    1892,\n/**/\n    1891,\n/**/\n    1890,\n/**/\n    1889,\n/**/\n    1888,\n/**/\n    1887,\n/**/\n    1886,\n/**/\n    1885,\n/**/\n    1884,\n/**/\n    1883,\n/**/\n    1882,\n/**/\n    1881,\n/**/\n    1880,\n/**/\n    1879,\n/**/\n    1878,\n/**/\n    1877,\n/**/\n    1876,\n/**/\n    1875,\n/**/\n    1874,\n/**/\n    1873,\n/**/\n    1872,\n/**/\n    1871,\n/**/\n    1870,\n/**/\n    1869,\n/**/\n    1868,\n/**/\n    1867,\n/**/\n    1866,\n/**/\n    1865,\n/**/\n    1864,\n/**/\n    1863,\n/**/\n    1862,\n/**/\n    1861,\n/**/\n    1860,\n/**/\n    1859,\n/**/\n    1858,\n/**/\n    1857,\n/**/\n    1856,\n/**/\n    1855,\n/**/\n    1854,\n/**/\n    1853,\n/**/\n    1852,\n/**/\n    1851,\n/**/\n    1850,\n/**/\n    1849,\n/**/\n    1848,\n/**/\n    1847,\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    while (l < h)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + (item_count % ncol ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#ifdef FEAT_HUGE\n    msg_puts(_(\"\\nHuge version \"));\n#else\n# ifdef FEAT_BIG\n    msg_puts(_(\"\\nBig version \"));\n# else\n#  ifdef FEAT_NORMAL\n    msg_puts(_(\"\\nNormal version \"));\n#  else\n#   ifdef FEAT_SMALL\n    msg_puts(_(\"\\nSmall version \"));\n#   else\n    msg_puts(_(\"\\nTiny version \"));\n#   endif\n#  endif\n# endif\n#endif\n#ifndef FEAT_GUI\n    msg_puts(_(\"without GUI.\"));\n#else\n# ifdef FEAT_GUI_GTK\n#  ifdef USE_GTK3\n    msg_puts(_(\"with GTK3 GUI.\"));\n#  else\n#   ifdef FEAT_GUI_GNOME\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n#   else\n     msg_puts(_(\"with GTK2 GUI.\"));\n#   endif\n# endif\n# else\n#  ifdef FEAT_GUI_MOTIF\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#  else\n#   ifdef FEAT_GUI_ATHENA\n#    ifdef FEAT_GUI_NEXTAW\n    msg_puts(_(\"with X11-neXtaw GUI.\"));\n#    else\n    msg_puts(_(\"with X11-Athena GUI.\"));\n#    endif\n#   else\n#    ifdef FEAT_GUI_HAIKU\n    msg_puts(_(\"with Haiku GUI.\"));\n#    else\n#     ifdef FEAT_GUI_PHOTON\n    msg_puts(_(\"with Photon GUI.\"));\n#     else\n#      if defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#      endif\n#     endif\n#    endif\n#   endif\n#  endif\n# endif\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version8<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "filenames": ["src/regexp.c", "src/regexp_nfa.c", "src/testdir/test_regexp_latin.vim", "src/version.c"], "buggy_code_start_loc": [1132, 6836, 9, 759], "buggy_code_end_loc": [1133, 6837, 1039, 759], "fixing_code_start_loc": [1132, 6837, 9, 760], "fixing_code_end_loc": [1133, 6846, 1048, 762], "type": "CWE-416", "message": "vim is vulnerable to Use After Free", "other": {"cve": {"id": "CVE-2021-3974", "sourceIdentifier": "security@huntr.dev", "published": "2021-11-19T11:15:07.770", "lastModified": "2022-11-09T03:12:39.860", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "vim is vulnerable to Use After Free"}, {"lang": "es", "value": "vim es vulnerable a un Uso de Memoria previamente Liberada"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:L/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.5}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndExcluding": "8.2.3612", "matchCriteriaId": "7422868F-DDB7-4497-9F60-087B3FB1F176"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2022/01/15/1", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/vim/vim/commit/64066b9acd9f8cffdf4840f797748f938a13f2d6", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/e402cb2c-8ec4-4828-a692-c95f8e0de6d4", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/03/msg00018.html", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/11/msg00009.html", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/FNXY7T5OORA7UJIMGSJBGHFMU6UZWS6P/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/IH2LS2DXBTYOCWGAKFMBF3HTWWXPBEFL/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202208-32", "source": "security@huntr.dev", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/vim/vim/commit/64066b9acd9f8cffdf4840f797748f938a13f2d6"}}