{"buggy_code": ["// Copyright (c) Microsoft. All rights reserved.\n// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n\nimport ifm = require('../Interfaces');\n\nexport class BasicCredentialHandler implements ifm.IRequestHandler {\n    username: string;\n    password: string;\n\n    constructor(username: string, password: string) {\n        this.username = username;\n        this.password = password;\n    }\n\n    // currently implements pre-authorization\n    // TODO: support preAuth = false where it hooks on 401\n    prepareRequest(options:any): void {\n        options.headers['Authorization'] = `Basic ${Buffer.from(`${this.username}:${this.password}`).toString('base64')}`;\n        options.headers['X-TFS-FedAuthRedirect'] = 'Suppress';\n    }\n\n    // This handler cannot handle 401\n    canHandleAuthentication(response: ifm.IHttpClientResponse): boolean {\n        return false;\n    }\n\n    handleAuthentication(httpClient: ifm.IHttpClient, requestInfo: ifm.IRequestInfo, objs): Promise<ifm.IHttpClientResponse> {\n        return null;\n    }\n}\n", "// Copyright (c) Microsoft. All rights reserved.\n// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n\nimport ifm = require('../Interfaces');\n\nexport class BearerCredentialHandler implements ifm.IRequestHandler {\n    token: string;\n\n    constructor(token: string) {\n        this.token = token;\n    }\n\n    // currently implements pre-authorization\n    // TODO: support preAuth = false where it hooks on 401\n    prepareRequest(options:any): void {\n        options.headers['Authorization'] = `Bearer ${this.token}`;\n        options.headers['X-TFS-FedAuthRedirect'] = 'Suppress';\n    }\n\n    // This handler cannot handle 401\n    canHandleAuthentication(response: ifm.IHttpClientResponse): boolean {\n        return false;\n    }\n\n    handleAuthentication(httpClient: ifm.IHttpClient, requestInfo: ifm.IRequestInfo, objs): Promise<ifm.IHttpClientResponse> {\n        return null;\n    }\n}\n", "// Copyright (c) Microsoft. All rights reserved.\n// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n\nimport ifm = require('../Interfaces');\n\nexport class PersonalAccessTokenCredentialHandler implements ifm.IRequestHandler {\n    token: string;\n\n    constructor(token: string) {\n        this.token = token;\n    }\n\n    // currently implements pre-authorization\n    // TODO: support preAuth = false where it hooks on 401\n    prepareRequest(options:any): void {\n        options.headers['Authorization'] = `Basic ${Buffer.from(`PAT:${this.token}`).toString('base64')}`;\n        options.headers['X-TFS-FedAuthRedirect'] = 'Suppress';\n    }\n\n    // This handler cannot handle 401\n    canHandleAuthentication(response: ifm.IHttpClientResponse): boolean {\n        return false;\n    }\n\n    handleAuthentication(httpClient: ifm.IHttpClient, requestInfo: ifm.IRequestInfo, objs): Promise<ifm.IHttpClientResponse> {\n        return null;\n    }\n}\n", "// Copyright (c) Microsoft. All rights reserved.\n// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n\nimport assert = require('assert');\nimport nock = require('nock');\nimport * as httpm from 'typed-rest-client/HttpClient';\nimport * as hm from 'typed-rest-client/Handlers';\n\ndescribe('Authentication Handlers Tests', function () {\n    let _authHandlersOptions: any;\n\n    before(() => {\n        _authHandlersOptions = {\n            basicAuth: {\n                username: 'johndoe',\n                password: 'password'\n            },\n            bearer: {\n                token: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.' +\n                'eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.' +\n                'SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c'\n            },\n            personalAccessToken: {\n                secret: 'scbfb44vxzku5l4xgc3qfazn3lpk4awflfryc76esaiq7aypcbhs'\n            },\n            ntlm: {\n                username: 'Zaphod',\n                password: 'Beeblebrox',\n                domain: 'Ursa-Minor',\n                workstation: 'LightCity'\n            }\n        }\n    });\n\n    afterEach(() => {\n        nock.cleanAll();\n    });\n\n    it('[Basic Auth] - does basic http get request with basic auth', async() => {\n        const url: string = 'http://microsoft.com';\n        const user: string = _authHandlersOptions.basicAuth.username;\n        const pass: string = _authHandlersOptions.basicAuth.password;\n\n        //Set nock for correct credentials\n        const successAuthScope = nock(url)\n            .get('/')\n            .basicAuth({ user, pass })\n            .reply(httpm.HttpCodes.OK, {\n                success: true,\n                source: \"nock\"\n            });\n\n        //Set nock for request without credentials or with incorrect credentials\n        const failureAuthScope = nock(url)\n            .get('/')\n            .reply(httpm.HttpCodes.Unauthorized, {\n                success: false,\n                source: \"nock\"\n            });\n\n        const basicAuthHandler: hm.BasicCredentialHandler = new hm.BasicCredentialHandler(user, pass);\n        let httpClient: httpm.HttpClient = new httpm.HttpClient('typed-rest-client-tests', [basicAuthHandler]);\n        let httpResponse: httpm.HttpClientResponse = await httpClient.get(url);\n        let body: string = await httpResponse.readBody();\n        let asJson: any = JSON.parse(body);\n\n        assert(successAuthScope.isDone());\n        assert(httpResponse.message.statusCode == httpm.HttpCodes.OK, \"status code should be 200 - OK\");\n        assert(asJson.source === \"nock\", \"http get request should be intercepted by nock\");\n        assert(asJson.success, \"Authentication should succeed\");\n\n        httpClient = new httpm.HttpClient('typed-rest-client-tests');\n        httpResponse = await httpClient.get(url);\n        body = await httpResponse.readBody();\n        asJson = JSON.parse(body);\n\n        assert(failureAuthScope.isDone());\n        assert(httpResponse.message.statusCode == httpm.HttpCodes.Unauthorized, \"status code should be 401 - Unauthorized\");\n        assert(asJson.source === \"nock\", \"http get request should be intercepted by nock\");\n        assert(! asJson.success, \"success = false; Authentication should fail\");\n    });\n\n    it('[Basic Auth - Presigned] doesnt use auth when presigned', async() => {\n        const url: string = 'http://microsoft.com';\n        const user: string = _authHandlersOptions.basicAuth.username;\n        const pass: string = _authHandlersOptions.basicAuth.password;\n\n        //Set nock for correct credentials\n        const withAuthCredentialsScope = nock(url)\n            .get('/')\n            .basicAuth({ user, pass })\n            .reply(httpm.HttpCodes.OK, {\n                success: false,\n                presigned: false,\n                source: \"nock\"\n            });\n\n        //Set nock for request without credentials or with incorrect credentials\n        const withNoAuthScope = nock(url)\n            .get('/')\n            .reply(httpm.HttpCodes.OK, {\n                success: true,\n                presigned: true,\n                source: \"nock\"\n            });\n\n        const basicAuthHandler: hm.BasicCredentialHandler = new hm.BasicCredentialHandler(user, pass);\n        const httpClient: httpm.HttpClient = new httpm.HttpClient('typed-rest-client-tests', [basicAuthHandler], {presignedUrlPatterns: [/microsoft/i]});\n        const httpResponse: httpm.HttpClientResponse = await httpClient.get(url);\n        const body: string = await httpResponse.readBody();\n        const asJson: any = JSON.parse(body);\n\n        assert(withNoAuthScope.isDone(), \"With No Authentication Nock Scope should be intercepted\");\n        assert(! withAuthCredentialsScope.isDone(), \"With Auth Creds. Scope should NOT be intercepted as no auth is needed\");\n        assert(httpResponse.message.statusCode == httpm.HttpCodes.OK, \"status code should be 200 - OK\");\n        assert(asJson.source === \"nock\", \"http get request should be intercepted by nock\");\n        assert(asJson.success, \"Authentication should succeed\");\n        assert(asJson.presigned, \"presigned should be true; no need for auth\");\n    });\n\n    it('[Personal Access Token] - does basic http get request with PAT token auth', async() => {\n        const url: string = 'http://microsoft.com';\n        const secret: string = _authHandlersOptions.personalAccessToken.secret;\n        const personalAccessToken: string = Buffer.from(`PAT:${secret}`).toString('base64');\n        const expectedAuthHeader: string = `Basic ${personalAccessToken}`;\n        const patAuthHandler: hm.PersonalAccessTokenCredentialHandler =\n            new hm.PersonalAccessTokenCredentialHandler(secret);\n\n        //Nock request with expecting/matching Authorization header(s)\n        const successAuthScope = nock(url)\n            .matchHeader('Authorization', expectedAuthHeader)\n            .matchHeader('X-TFS-FedAuthRedirect', 'Suppress')\n            .get('/')\n            .reply(httpm.HttpCodes.OK, {\n                success: true,\n                source: \"nock\"\n            });\n\n        //Nock request without Authentication header\n        const failureAuthScope = nock(url)\n            .get('/')\n            .reply(httpm.HttpCodes.Unauthorized, {\n                success: false,\n                source: \"nock\"\n        });\n\n        let httpClient: httpm.HttpClient = new httpm.HttpClient(undefined, [patAuthHandler]);\n        let httpResponse: httpm.HttpClientResponse = await httpClient.get(url);\n        let responseBody: string = await httpResponse.readBody();\n        let asJson: any = JSON.parse(responseBody);\n\n        assert(successAuthScope.isDone(), \"success nock scope should be intercepted\");\n        assert(httpResponse.message.statusCode == httpm.HttpCodes.OK, \"status code should be 200 - OK\");\n        assert(asJson.success, \"Authentication should succeed\");\n        assert(asJson.source === \"nock\", \"http get request should be intercepted by nock\");\n\n        httpClient = new httpm.HttpClient(undefined);\n        httpResponse = await httpClient.get(url);\n        responseBody = await httpResponse.readBody();\n        asJson = JSON.parse(responseBody);\n\n        assert(failureAuthScope.isDone(), \"failureAuth nock scope should be intercepted\");\n        assert(httpResponse.message.statusCode == httpm.HttpCodes.Unauthorized, \"status code should be 401 - Unauthorized\");\n        assert(asJson.source === \"nock\", \"http get request should be intercepted by nock\");\n        assert(! asJson.success, \"success = false; Authentication should fail\");\n    });\n\n    it('[Bearer Token] - does basic http get request with bearer token authentication', async() => {\n        const url: string = 'http://microsoft.com';\n        const bearerToken: string = _authHandlersOptions.bearer.token;\n\n        const expectedAuthHeader: string = `Bearer ${bearerToken}`;\n        const bearerTokenAuthHandler: hm.BearerCredentialHandler = new hm.BearerCredentialHandler(bearerToken);\n\n        //Nock request with expecting/matching Authorization header(s)\n        const successAuthScope = nock(url)\n            .matchHeader('Authorization', expectedAuthHeader)\n            .matchHeader('X-TFS-FedAuthRedirect', 'Suppress')\n            .get('/')\n            .reply(httpm.HttpCodes.OK, {\n                success: true,\n                source: \"nock\"\n            });\n\n        //Nock request without Authentication header\n        const failureAuthScope = nock(url)\n            .get('/')\n            .reply(httpm.HttpCodes.Unauthorized, {\n                success: false,\n                source: \"nock\"\n        });\n\n        /**\n         * Assertions for Success Authentication\n         * with Bearer Token Handler\n         */\n        let httpClient: httpm.HttpClient = new httpm.HttpClient(undefined, [bearerTokenAuthHandler]);\n        let httpResponse: httpm.HttpClientResponse = await httpClient.get(url);\n        let responseBodyAsJSON = await httpResponse.readBody().then(JSON.parse);\n\n        assert(successAuthScope.isDone(), \"Nock Scope with Successful Bearer Auth Intercepted and Done\");\n        assert(responseBodyAsJSON.success, \"Success att. should be set to true\");\n        assert(httpResponse.message.statusCode == httpm.HttpCodes.OK, \"statusCode should be 200 - OK\");\n\n        /**\n         * Assertions for Failure Scope,\n         * Should return Unauthorized (401) and\n         * Success set to false\n         */\n        httpClient = new httpm.HttpClient(undefined);\n        httpResponse = await httpClient.get(url);\n        responseBodyAsJSON = await httpResponse.readBody().then(JSON.parse);\n\n        assert(failureAuthScope.isDone(), \"Nock Scope of failureAuth should be intercepted/done\"); //nock test for failure auth is done\n        assert(! responseBodyAsJSON.success, \"Success should be set to false\"); // success: false\n        assert(httpResponse.message.statusCode === httpm.HttpCodes.Unauthorized, \"statusCode returned should be 401 - Unauthorized\"); //statusCode is 401 - Unauthorized\n    });\n\n    it('[NTLM] - does basic http get request with NTLM Authentication', async() => {\n        /**\n         * Following NTLM Authentication Example on:\n         * https://www.innovation.ch/personal/ronald/ntlm.html\n         * With username: \"Zaphod\", password: \"Beeblebrox\" &\n         * workstation/hostname: \"LightCity\", domain: \"Ursa-Minor\"\n         */\n        const url: string = 'http://microsoft.com';\n        const base64EncodedType1Message = 'NTLM TlRMTVNTUAABAAAAA7IAAAoACgApAAAACQAJACAAAABMSUdIVENJVFlVUlNBLU1JTk9S';\n        const serverChallengeOrNonce = 'NTLM TlRMTVNTUAACAAAAAAAAACgAAAABggAAU3J2Tm9uY2UAAAAAAAAAAA==';\n        const base64EncodedType3Message = 'NTLM TlRMTVNTUAADAAAAGAAYAHIAAAAYABgAigAAABQAFABAAAAADAAMAFQAAAASABIAYAAA' +\n            'AAAAAACiAAAAAYIAAFUAUgBTAEEALQBNAEkATgBPAFIAWgBhAHAAaABvAGQATABJAEcA' +\n            'SABUAEMASQBUAFkArYfKbe/jRoW5xDxHeoxC1gBmfWiS5+iX4OAN4xBKG/IFPwfH3agtPEia6YnhsADT'\n\n        const ntlmScopeType1 = nock(url)\n            .get('/')\n            .reply(httpm.HttpCodes.Unauthorized, {}, {'WWW-Authenticate': 'NTLM'});\n\n        const ntlmScopeType2 = nock(url)\n            .matchHeader('Connection', 'keep-alive')\n            .matchHeader('Authorization', base64EncodedType1Message)\n            .get('/')\n            .reply(httpm.HttpCodes.Unauthorized, {}, {'WWW-Authenticate': serverChallengeOrNonce});\n\n        const ntlmScopeType3 = nock(url)\n            .matchHeader('Connection', 'Close')\n            .matchHeader('Authorization', base64EncodedType3Message)\n            .get('/')\n            .reply(httpm.HttpCodes.OK);\n\n        const ntlmAuthHandler: hm.NtlmCredentialHandler = new hm.NtlmCredentialHandler(\n            _authHandlersOptions.ntlm.username,\n            _authHandlersOptions.ntlm.password,\n            _authHandlersOptions.ntlm.workstation,\n            _authHandlersOptions.ntlm.domain\n        );\n\n        const httpClient: httpm.HttpClient = new httpm.HttpClient(undefined, [ntlmAuthHandler]);\n        const httpResponse: httpm.HttpClientResponse = await httpClient.get(url);\n\n        assert(ntlmScopeType1.isDone() && ntlmScopeType2.isDone() && ntlmScopeType3.isDone(), 'All Nock Scopes Intercepted/Done Successfully');\n        assert(httpResponse.message.statusCode == httpm.HttpCodes.OK, 'Should have status code of 200');\n    });\n});\n"], "fixing_code": ["// Copyright (c) Microsoft. All rights reserved.\n// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n\nimport ifm = require('../Interfaces');\n\nexport class BasicCredentialHandler implements ifm.IRequestHandler {\n    username: string;\n    password: string;\n    allowCrossOriginAuthentication: boolean;\n    origin: string;\n\n    constructor(username: string, password: string, allowCrossOriginAuthentication?: boolean) {\n        this.username = username;\n        this.password = password;\n        this.allowCrossOriginAuthentication = allowCrossOriginAuthentication;\n    }\n\n    // currently implements pre-authorization\n    // TODO: support preAuth = false where it hooks on 401\n    prepareRequest(options:any): void {\n        if (!this.origin) {\n            this.origin = options.host;\n        }\n        // If this is a redirection, don't set the Authorization header\n        if (this.origin === options.host || this.allowCrossOriginAuthentication) {\n            options.headers['Authorization'] = `Basic ${Buffer.from(`${this.username}:${this.password}`).toString('base64')}`;\n        }\n        options.headers['X-TFS-FedAuthRedirect'] = 'Suppress';\n    }\n\n    // This handler cannot handle 401\n    canHandleAuthentication(response: ifm.IHttpClientResponse): boolean {\n        return false;\n    }\n\n    handleAuthentication(httpClient: ifm.IHttpClient, requestInfo: ifm.IRequestInfo, objs): Promise<ifm.IHttpClientResponse> {\n        return null;\n    }\n}\n", "// Copyright (c) Microsoft. All rights reserved.\n// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n\nimport ifm = require('../Interfaces');\n\nexport class BearerCredentialHandler implements ifm.IRequestHandler {\n    token: string;\n    allowCrossOriginAuthentication: boolean;\n    origin: string;\n\n    constructor(token: string, allowCrossOriginAuthentication?: boolean) {\n        this.token = token;\n        this.allowCrossOriginAuthentication = allowCrossOriginAuthentication;\n    }\n\n    // currently implements pre-authorization\n    // TODO: support preAuth = false where it hooks on 401\n    prepareRequest(options:any): void {\n        if (!this.origin) {\n            this.origin = options.host;\n        }\n        // If this is a redirection, don't set the Authorization header\n        if (this.origin === options.host || this.allowCrossOriginAuthentication) {\n            options.headers['Authorization'] = `Bearer ${this.token}`;\n        }\n        options.headers['X-TFS-FedAuthRedirect'] = 'Suppress';\n    }\n\n    // This handler cannot handle 401\n    canHandleAuthentication(response: ifm.IHttpClientResponse): boolean {\n        return false;\n    }\n\n    handleAuthentication(httpClient: ifm.IHttpClient, requestInfo: ifm.IRequestInfo, objs): Promise<ifm.IHttpClientResponse> {\n        return null;\n    }\n}\n", "// Copyright (c) Microsoft. All rights reserved.\n// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n\nimport ifm = require('../Interfaces');\n\nexport class PersonalAccessTokenCredentialHandler implements ifm.IRequestHandler {\n    token: string;\n    allowCrossOriginAuthentication: boolean;\n    origin: string;\n\n    constructor(token: string, allowCrossOriginAuthentication?: boolean) {\n        this.token = token;\n        this.allowCrossOriginAuthentication = allowCrossOriginAuthentication;\n    }\n\n    // currently implements pre-authorization\n    // TODO: support preAuth = false where it hooks on 401\n    prepareRequest(options:any): void {\n        if (!this.origin) {\n            this.origin = options.host;\n        }\n        // If this is a redirection, don't set the Authorization header\n        if (this.origin === options.host || this.allowCrossOriginAuthentication) {\n            options.headers['Authorization'] = `Basic ${Buffer.from(`PAT:${this.token}`).toString('base64')}`;\n        }\n        options.headers['X-TFS-FedAuthRedirect'] = 'Suppress';\n    }\n\n    // This handler cannot handle 401\n    canHandleAuthentication(response: ifm.IHttpClientResponse): boolean {\n        return false;\n    }\n\n    handleAuthentication(httpClient: ifm.IHttpClient, requestInfo: ifm.IRequestInfo, objs): Promise<ifm.IHttpClientResponse> {\n        return null;\n    }\n}\n", "// Copyright (c) Microsoft. All rights reserved.\n// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n\nimport assert = require('assert');\nimport nock = require('nock');\nimport * as httpm from 'typed-rest-client/HttpClient';\nimport * as hm from 'typed-rest-client/Handlers';\n\ndescribe('Authentication Handlers Tests', function () {\n    let _authHandlersOptions: any;\n\n    before(() => {\n        _authHandlersOptions = {\n            basicAuth: {\n                username: 'johndoe',\n                password: 'password'\n            },\n            bearer: {\n                token: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.' +\n                'eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.' +\n                'SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c'\n            },\n            personalAccessToken: {\n                secret: 'scbfb44vxzku5l4xgc3qfazn3lpk4awflfryc76esaiq7aypcbhs'\n            },\n            ntlm: {\n                username: 'Zaphod',\n                password: 'Beeblebrox',\n                domain: 'Ursa-Minor',\n                workstation: 'LightCity'\n            }\n        }\n    });\n\n    afterEach(() => {\n        nock.cleanAll();\n    });\n\n    it('[Basic Auth] - does basic http get request with basic auth', async() => {\n        const url: string = 'http://microsoft.com';\n        const user: string = _authHandlersOptions.basicAuth.username;\n        const pass: string = _authHandlersOptions.basicAuth.password;\n\n        //Set nock for correct credentials\n        const successAuthScope = nock(url)\n            .get('/')\n            .basicAuth({ user, pass })\n            .reply(httpm.HttpCodes.OK, {\n                success: true,\n                source: \"nock\"\n            });\n\n        //Set nock for request without credentials or with incorrect credentials\n        const failureAuthScope = nock(url)\n            .get('/')\n            .reply(httpm.HttpCodes.Unauthorized, {\n                success: false,\n                source: \"nock\"\n            });\n\n        const basicAuthHandler: hm.BasicCredentialHandler = new hm.BasicCredentialHandler(user, pass);\n        let httpClient: httpm.HttpClient = new httpm.HttpClient('typed-rest-client-tests', [basicAuthHandler]);\n        let httpResponse: httpm.HttpClientResponse = await httpClient.get(url);\n        let body: string = await httpResponse.readBody();\n        let asJson: any = JSON.parse(body);\n\n        assert(successAuthScope.isDone());\n        assert(httpResponse.message.statusCode == httpm.HttpCodes.OK, \"status code should be 200 - OK\");\n        assert(asJson.source === \"nock\", \"http get request should be intercepted by nock\");\n        assert(asJson.success, \"Authentication should succeed\");\n\n        httpClient = new httpm.HttpClient('typed-rest-client-tests');\n        httpResponse = await httpClient.get(url);\n        body = await httpResponse.readBody();\n        asJson = JSON.parse(body);\n\n        assert(failureAuthScope.isDone());\n        assert(httpResponse.message.statusCode == httpm.HttpCodes.Unauthorized, \"status code should be 401 - Unauthorized\");\n        assert(asJson.source === \"nock\", \"http get request should be intercepted by nock\");\n        assert(! asJson.success, \"success = false; Authentication should fail\");\n    });\n\n    it('[Basic Auth] - does redirection request with basic auth', async() => {\n        const url: string = 'http://microsoft.com';\n        const redirectionUrl: string = 'http://jfrog.com';\n        const user: string = _authHandlersOptions.basicAuth.username;\n        const pass: string = _authHandlersOptions.basicAuth.password;\n\n        //Set nock for redirection with credentials\n        const redirectAuthScope = nock(url)\n            .get('/')\n            .basicAuth({ user, pass })\n            .reply(httpm.HttpCodes.MovedPermanently, undefined, {\n                location: redirectionUrl\n            });\n\n        //Set nock for request without expecting/matching Authorization header(s)\n        nock(redirectionUrl)\n            .matchHeader('authorization', (val: string | undefined) => !val )\n            .get('/')\n            .reply(httpm.HttpCodes.OK, {\n                success: true,\n                source: \"nock\"\n            });\n\n        //Set nock for request with expecting/matching Authorization header(s)\n        nock(redirectionUrl)\n            .matchHeader('authorization', (val: string | undefined) => val )\n            .get('/')\n            .reply(httpm.HttpCodes.BadRequest, {\n                success: false,\n                source: \"nock\"\n            });\n\n        const basicAuthHandler: hm.BasicCredentialHandler = new hm.BasicCredentialHandler(user, pass);\n        let httpClient: httpm.HttpClient = new httpm.HttpClient('typed-rest-client-tests', [basicAuthHandler]);\n        let httpResponse: httpm.HttpClientResponse = await httpClient.get(url);\n        let body: string = await httpResponse.readBody();\n        let asJson: any = JSON.parse(body);\n\n        assert(redirectAuthScope.isDone());\n        assert(httpResponse.message.statusCode == httpm.HttpCodes.OK, \"status code should be 200 - OK\");\n        assert(asJson.source === \"nock\", \"http get request should be intercepted by nock\");\n        assert(asJson.success, \"Authentication should not occur in redirection to other hosts\");\n    });\n\n    it('[Basic Auth - Presigned] doesnt use auth when presigned', async() => {\n        const url: string = 'http://microsoft.com';\n        const user: string = _authHandlersOptions.basicAuth.username;\n        const pass: string = _authHandlersOptions.basicAuth.password;\n\n        //Set nock for correct credentials\n        const withAuthCredentialsScope = nock(url)\n            .get('/')\n            .basicAuth({ user, pass })\n            .reply(httpm.HttpCodes.OK, {\n                success: false,\n                presigned: false,\n                source: \"nock\"\n            });\n\n        //Set nock for request without credentials or with incorrect credentials\n        const withNoAuthScope = nock(url)\n            .get('/')\n            .reply(httpm.HttpCodes.OK, {\n                success: true,\n                presigned: true,\n                source: \"nock\"\n            });\n\n        const basicAuthHandler: hm.BasicCredentialHandler = new hm.BasicCredentialHandler(user, pass);\n        const httpClient: httpm.HttpClient = new httpm.HttpClient('typed-rest-client-tests', [basicAuthHandler], {presignedUrlPatterns: [/microsoft/i]});\n        const httpResponse: httpm.HttpClientResponse = await httpClient.get(url);\n        const body: string = await httpResponse.readBody();\n        const asJson: any = JSON.parse(body);\n\n        assert(withNoAuthScope.isDone(), \"With No Authentication Nock Scope should be intercepted\");\n        assert(! withAuthCredentialsScope.isDone(), \"With Auth Creds. Scope should NOT be intercepted as no auth is needed\");\n        assert(httpResponse.message.statusCode == httpm.HttpCodes.OK, \"status code should be 200 - OK\");\n        assert(asJson.source === \"nock\", \"http get request should be intercepted by nock\");\n        assert(asJson.success, \"Authentication should succeed\");\n        assert(asJson.presigned, \"presigned should be true; no need for auth\");\n    });\n\n    it('[Personal Access Token] - does basic http get request with PAT token auth', async() => {\n        const url: string = 'http://microsoft.com';\n        const secret: string = _authHandlersOptions.personalAccessToken.secret;\n        const personalAccessToken: string = Buffer.from(`PAT:${secret}`).toString('base64');\n        const expectedAuthHeader: string = `Basic ${personalAccessToken}`;\n        const patAuthHandler: hm.PersonalAccessTokenCredentialHandler =\n            new hm.PersonalAccessTokenCredentialHandler(secret);\n\n        //Nock request with expecting/matching Authorization header(s)\n        const successAuthScope = nock(url)\n            .matchHeader('Authorization', expectedAuthHeader)\n            .matchHeader('X-TFS-FedAuthRedirect', 'Suppress')\n            .get('/')\n            .reply(httpm.HttpCodes.OK, {\n                success: true,\n                source: \"nock\"\n            });\n\n        //Nock request without Authentication header\n        const failureAuthScope = nock(url)\n            .get('/')\n            .reply(httpm.HttpCodes.Unauthorized, {\n                success: false,\n                source: \"nock\"\n        });\n\n        let httpClient: httpm.HttpClient = new httpm.HttpClient(undefined, [patAuthHandler]);\n        let httpResponse: httpm.HttpClientResponse = await httpClient.get(url);\n        let responseBody: string = await httpResponse.readBody();\n        let asJson: any = JSON.parse(responseBody);\n\n        assert(successAuthScope.isDone(), \"success nock scope should be intercepted\");\n        assert(httpResponse.message.statusCode == httpm.HttpCodes.OK, \"status code should be 200 - OK\");\n        assert(asJson.success, \"Authentication should succeed\");\n        assert(asJson.source === \"nock\", \"http get request should be intercepted by nock\");\n\n        httpClient = new httpm.HttpClient(undefined);\n        httpResponse = await httpClient.get(url);\n        responseBody = await httpResponse.readBody();\n        asJson = JSON.parse(responseBody);\n\n        assert(failureAuthScope.isDone(), \"failureAuth nock scope should be intercepted\");\n        assert(httpResponse.message.statusCode == httpm.HttpCodes.Unauthorized, \"status code should be 401 - Unauthorized\");\n        assert(asJson.source === \"nock\", \"http get request should be intercepted by nock\");\n        assert(! asJson.success, \"success = false; Authentication should fail\");\n    });\n\n    it('[Personal Access Token] - does redirection request with PAT token auth', async() => {\n        const url: string = 'http://microsoft.com';\n        const redirectionUrl: string = 'http://jfrog.com';\n        const secret: string = _authHandlersOptions.personalAccessToken.secret;\n        const personalAccessToken: string = Buffer.from(`PAT:${secret}`).toString('base64');\n        const expectedAuthHeader: string = `Basic ${personalAccessToken}`;\n        const patAuthHandler: hm.PersonalAccessTokenCredentialHandler =\n        new hm.PersonalAccessTokenCredentialHandler(secret);\n\n        //Nock request for redirection with expecting/matching Authorization header(s)\n        const redirectAuthScope = nock(url)\n            .matchHeader('Authorization', expectedAuthHeader)\n            .matchHeader('X-TFS-FedAuthRedirect', 'Suppress')\n            .get('/')\n            .reply(httpm.HttpCodes.MovedPermanently, undefined, {\n                location: redirectionUrl\n            });\n\n        //Set nock for request without expecting/matching Authorization header(s)\n        nock(redirectionUrl)\n            .matchHeader('authorization', (val: string | undefined) => !val )\n            .get('/')\n            .reply(httpm.HttpCodes.OK, {\n                success: true,\n                source: \"nock\"\n            });\n\n        //Set nock for request with expecting/matching Authorization header(s)\n        nock(redirectionUrl)\n            .matchHeader('authorization', (val: string | undefined) => val )\n            .get('/')\n            .reply(httpm.HttpCodes.BadRequest, {\n                success: false,\n                source: \"nock\"\n            });\n\n        let httpClient: httpm.HttpClient = new httpm.HttpClient('typed-rest-client-tests', [patAuthHandler]);\n        let httpResponse: httpm.HttpClientResponse = await httpClient.get(url);\n        let body: string = await httpResponse.readBody();\n        let asJson: any = JSON.parse(body);\n\n        assert(redirectAuthScope.isDone());\n        assert(httpResponse.message.statusCode == httpm.HttpCodes.OK, \"status code should be 200 - OK\");\n        assert(asJson.source === \"nock\", \"http get request should be intercepted by nock\");\n        assert(asJson.success, \"Authentication should not occur in redirection to other hosts\");\n    });\n\n    it('[Bearer Token] - does basic http get request with bearer token authentication', async() => {\n        const url: string = 'http://microsoft.com';\n        const bearerToken: string = _authHandlersOptions.bearer.token;\n\n        const expectedAuthHeader: string = `Bearer ${bearerToken}`;\n        const bearerTokenAuthHandler: hm.BearerCredentialHandler = new hm.BearerCredentialHandler(bearerToken);\n\n        //Nock request with expecting/matching Authorization header(s)\n        const successAuthScope = nock(url)\n            .matchHeader('Authorization', expectedAuthHeader)\n            .matchHeader('X-TFS-FedAuthRedirect', 'Suppress')\n            .get('/')\n            .reply(httpm.HttpCodes.OK, {\n                success: true,\n                source: \"nock\"\n            });\n\n        //Nock request without Authentication header\n        const failureAuthScope = nock(url)\n            .get('/')\n            .reply(httpm.HttpCodes.Unauthorized, {\n                success: false,\n                source: \"nock\"\n        });\n\n        /**\n         * Assertions for Success Authentication\n         * with Bearer Token Handler\n         */\n        let httpClient: httpm.HttpClient = new httpm.HttpClient(undefined, [bearerTokenAuthHandler]);\n        let httpResponse: httpm.HttpClientResponse = await httpClient.get(url);\n        let responseBodyAsJSON = await httpResponse.readBody().then(JSON.parse);\n\n        assert(successAuthScope.isDone(), \"Nock Scope with Successful Bearer Auth Intercepted and Done\");\n        assert(responseBodyAsJSON.success, \"Success att. should be set to true\");\n        assert(httpResponse.message.statusCode == httpm.HttpCodes.OK, \"statusCode should be 200 - OK\");\n\n        /**\n         * Assertions for Failure Scope,\n         * Should return Unauthorized (401) and\n         * Success set to false\n         */\n        httpClient = new httpm.HttpClient(undefined);\n        httpResponse = await httpClient.get(url);\n        responseBodyAsJSON = await httpResponse.readBody().then(JSON.parse);\n\n        assert(failureAuthScope.isDone(), \"Nock Scope of failureAuth should be intercepted/done\"); //nock test for failure auth is done\n        assert(! responseBodyAsJSON.success, \"Success should be set to false\"); // success: false\n        assert(httpResponse.message.statusCode === httpm.HttpCodes.Unauthorized, \"statusCode returned should be 401 - Unauthorized\"); //statusCode is 401 - Unauthorized\n    });\n\n    it('[Bearer Token] - does redirection request with bearer token authentication', async() => {\n        const url: string = 'http://microsoft.com';\n        const redirectionUrl: string = 'http://jfrog.com';\n        const bearerToken: string = _authHandlersOptions.bearer.token;\n\n        const expectedAuthHeader: string = `Bearer ${bearerToken}`;\n        const bearerTokenAuthHandler: hm.BearerCredentialHandler = new hm.BearerCredentialHandler(bearerToken);\n\n        //Nock request for redirection with expecting/matching Authorization header(s)\n        const redirectAuthScope = nock(url)\n            .matchHeader('Authorization', expectedAuthHeader)\n            .matchHeader('X-TFS-FedAuthRedirect', 'Suppress')\n            .get('/')\n            .reply(httpm.HttpCodes.MovedPermanently, undefined, {\n                location: redirectionUrl\n            });\n\n        //Set nock for request without expecting/matching Authorization header(s)\n        nock(redirectionUrl)\n            .matchHeader('authorization', (val: string | undefined) => !val )\n            .get('/')\n            .reply(httpm.HttpCodes.OK, {\n                success: true,\n                source: \"nock\"\n            });\n\n        //Set nock for request with expecting/matching Authorization header(s)\n        nock(redirectionUrl)\n            .matchHeader('authorization', (val: string | undefined) => val )\n            .get('/')\n            .reply(httpm.HttpCodes.BadRequest, {\n                success: false,\n                source: \"nock\"\n            });\n\n        let httpClient: httpm.HttpClient = new httpm.HttpClient('typed-rest-client-tests', [bearerTokenAuthHandler]);\n        let httpResponse: httpm.HttpClientResponse = await httpClient.get(url);\n        let body: string = await httpResponse.readBody();\n        let asJson: any = JSON.parse(body);\n\n        assert(redirectAuthScope.isDone());\n        assert(httpResponse.message.statusCode == httpm.HttpCodes.OK, \"status code should be 200 - OK\");\n        assert(asJson.source === \"nock\", \"http get request should be intercepted by nock\");\n        assert(asJson.success, \"Authentication should not occur in redirection to other hosts\");\n    });\n\n    it('[NTLM] - does basic http get request with NTLM Authentication', async() => {\n        /**\n         * Following NTLM Authentication Example on:\n         * https://www.innovation.ch/personal/ronald/ntlm.html\n         * With username: \"Zaphod\", password: \"Beeblebrox\" &\n         * workstation/hostname: \"LightCity\", domain: \"Ursa-Minor\"\n         */\n        const url: string = 'http://microsoft.com';\n        const base64EncodedType1Message = 'NTLM TlRMTVNTUAABAAAAA7IAAAoACgApAAAACQAJACAAAABMSUdIVENJVFlVUlNBLU1JTk9S';\n        const serverChallengeOrNonce = 'NTLM TlRMTVNTUAACAAAAAAAAACgAAAABggAAU3J2Tm9uY2UAAAAAAAAAAA==';\n        const base64EncodedType3Message = 'NTLM TlRMTVNTUAADAAAAGAAYAHIAAAAYABgAigAAABQAFABAAAAADAAMAFQAAAASABIAYAAA' +\n            'AAAAAACiAAAAAYIAAFUAUgBTAEEALQBNAEkATgBPAFIAWgBhAHAAaABvAGQATABJAEcA' +\n            'SABUAEMASQBUAFkArYfKbe/jRoW5xDxHeoxC1gBmfWiS5+iX4OAN4xBKG/IFPwfH3agtPEia6YnhsADT'\n\n        const ntlmScopeType1 = nock(url)\n            .get('/')\n            .reply(httpm.HttpCodes.Unauthorized, {}, {'WWW-Authenticate': 'NTLM'});\n\n        const ntlmScopeType2 = nock(url)\n            .matchHeader('Connection', 'keep-alive')\n            .matchHeader('Authorization', base64EncodedType1Message)\n            .get('/')\n            .reply(httpm.HttpCodes.Unauthorized, {}, {'WWW-Authenticate': serverChallengeOrNonce});\n\n        const ntlmScopeType3 = nock(url)\n            .matchHeader('Connection', 'Close')\n            .matchHeader('Authorization', base64EncodedType3Message)\n            .get('/')\n            .reply(httpm.HttpCodes.OK);\n\n        const ntlmAuthHandler: hm.NtlmCredentialHandler = new hm.NtlmCredentialHandler(\n            _authHandlersOptions.ntlm.username,\n            _authHandlersOptions.ntlm.password,\n            _authHandlersOptions.ntlm.workstation,\n            _authHandlersOptions.ntlm.domain\n        );\n\n        const httpClient: httpm.HttpClient = new httpm.HttpClient(undefined, [ntlmAuthHandler]);\n        const httpResponse: httpm.HttpClientResponse = await httpClient.get(url);\n\n        assert(ntlmScopeType1.isDone() && ntlmScopeType2.isDone() && ntlmScopeType3.isDone(), 'All Nock Scopes Intercepted/Done Successfully');\n        assert(httpResponse.message.statusCode == httpm.HttpCodes.OK, 'Should have status code of 200');\n    });\n});\n"], "filenames": ["lib/handlers/basiccreds.ts", "lib/handlers/bearertoken.ts", "lib/handlers/personalaccesstoken.ts", "test/units/handlers.ts"], "buggy_code_start_loc": [8, 7, 7, 82], "buggy_code_end_loc": [19, 17, 17, 218], "fixing_code_start_loc": [9, 8, 8, 83], "fixing_code_end_loc": [28, 26, 26, 356], "type": "CWE-522", "message": "typed-rest-client is a library for Node Rest and Http Clients with typings for use with TypeScript. Users of the typed-rest-client library version 1.7.3 or lower are vulnerable to leak authentication data to 3rd parties. The flow of the vulnerability is as follows: First, send any request with `BasicCredentialHandler`, `BearerCredentialHandler` or `PersonalAccessTokenCredentialHandler`. Second, the target host may return a redirection (3xx), with a link to a second host. Third, the next request will use the credentials to authenticate with the second host, by setting the `Authorization` header. The expected behavior is that the next request will *NOT* set the `Authorization` header. The problem was fixed in version 1.8.0. There are no known workarounds.", "other": {"cve": {"id": "CVE-2023-30846", "sourceIdentifier": "security-advisories@github.com", "published": "2023-04-26T21:15:09.380", "lastModified": "2023-06-01T14:15:12.120", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "typed-rest-client is a library for Node Rest and Http Clients with typings for use with TypeScript. Users of the typed-rest-client library version 1.7.3 or lower are vulnerable to leak authentication data to 3rd parties. The flow of the vulnerability is as follows: First, send any request with `BasicCredentialHandler`, `BearerCredentialHandler` or `PersonalAccessTokenCredentialHandler`. Second, the target host may return a redirection (3xx), with a link to a second host. Third, the next request will use the credentials to authenticate with the second host, by setting the `Authorization` header. The expected behavior is that the next request will *NOT* set the `Authorization` header. The problem was fixed in version 1.8.0. There are no known workarounds."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-522"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:microsoft:typed-rest-client:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "1.8.0", "matchCriteriaId": "FA141551-3739-4DE0-9840-90B89AB8E1AB"}]}]}], "references": [{"url": "https://github.com/microsoft/typed-rest-client/commit/f9ff755631b982ee1303dfc3e3c823d0d31233e8", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/microsoft/typed-rest-client/security/advisories/GHSA-558p-m34m-vpmq", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20230601-0008/", "source": "security-advisories@github.com"}]}, "github_commit_url": "https://github.com/microsoft/typed-rest-client/commit/f9ff755631b982ee1303dfc3e3c823d0d31233e8"}}