{"buggy_code": ["click==7.1.2\nFlask==1.1.2\ngitdb==4.0.5\nGitPython==3.1.11\nitsdangerous==1.1.0\nJinja2==2.11.3\nMarkdown==3.3.3\nMarkupSafe==1.1.1\npandoc-eqnos==2.4.0\npandoc-fignos==2.4.0\npandoc-secnos==2.2.2\npandoc-tablenos==2.3.0\npandoc-xnos==2.5.0\npandocfilters==1.4.3\npsutil==5.7.3\npypandoc==1.5\nPyYAML==6.0\nrequests==2.27.1\nsmmap==3.0.4\nWerkzeug==1.0.1\nidna==3.3\n", "import os\nfrom shutil import ExecError\nimport time\nimport re\nimport logging\nimport uuid\nimport pypandoc\nimport knowledge_graph\nimport random\nimport string\n\nfrom flask import Flask, render_template, request, redirect, url_for, send_from_directory, make_response\nfrom werkzeug.utils import secure_filename\nfrom random import randint\nfrom threading import Thread\nfrom hashlib import sha256\n\nfrom config import WikmdConfig\nfrom git_manager import WikiRepoManager\nfrom web_dependencies import get_web_deps\n\n\nALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'gif'}\n\nSESSIONS = []\n\ncfg = WikmdConfig()\nUPLOAD_FOLDER = f\"{cfg.wiki_directory}/{cfg.images_route}\"\n\napp = Flask(__name__)\napp.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER\n\n# console logger\napp.logger.setLevel(logging.INFO)\n\n# file logger\nlogger = logging.getLogger('werkzeug')\nlogger.setLevel(logging.ERROR)\n\nwrm = WikiRepoManager(flask_app=app)\n\nSYSTEM_SETTINGS = {\n    \"darktheme\": False,\n    \"listsortMTime\": False,\n    \"web_deps\": get_web_deps(cfg.local_mode, app.logger)\n}\n\ndef save(page_name):\n    \"\"\"\n    Function that saves a *.md page.\n    :param page_name: name of the page\n    \"\"\"\n    content = request.form['CT']\n    app.logger.info(f\"Saving >>> '{page_name}' ...\")\n\n    try:\n        filename = os.path.join(cfg.wiki_directory, page_name + '.md')\n        dirname = os.path.dirname(filename)\n        if not os.path.exists(dirname):\n            os.makedirs(dirname)\n        with open(filename, 'w') as f:\n            f.write(content)\n    except Exception as e:\n        app.logger.error(f\"Error while saving '{page_name}' >>> {str(e)}\")\n\n\ndef search():\n    \"\"\"\n    Function that searches for a term and shows the results.\n    \"\"\"\n    search_term = request.form['ss']\n    escaped_search_term = re.escape(search_term)\n    found = []\n\n    app.logger.info(f\"Searching >>> '{search_term}' ...\")\n\n    for root, subfolder, files in os.walk(cfg.wiki_directory):\n        for item in files:\n            path = os.path.join(root, item)\n            if os.path.join(cfg.wiki_directory, '.git') in str(path):\n                # We don't want to search there\n                app.logger.debug(f\"Skipping {path} is git file\")\n                continue\n            if os.path.join(cfg.wiki_directory, cfg.images_route) in str(path):\n                # Nothing interesting there too\n                continue\n            with open(root + '/' + item, encoding=\"utf8\", errors='ignore') as f:\n                fin = f.read()\n                try:\n                    if (re.search(escaped_search_term, root + '/' + item, re.IGNORECASE) or\n                            re.search(escaped_search_term, fin, re.IGNORECASE) is not None):\n                        # Stripping 'wiki/' part of path before serving as a search result\n                        folder = root[len(cfg.wiki_directory + \"/\"):]\n                        if folder == \"\":\n                            url = os.path.splitext(\n                                root[len(cfg.wiki_directory + \"/\"):] + \"/\" + item)[0]\n                        else:\n                            url = \"/\" + \\\n                                  os.path.splitext(\n                                      root[len(cfg.wiki_directory + \"/\"):] + \"/\" + item)[0]\n\n                        info = {'doc': item,\n                                'url': url,\n                                'folder': folder,\n                                'folder_url': root[len(cfg.wiki_directory + \"/\"):]}\n                        found.append(info)\n                        app.logger.info(f\"Found '{search_term}' in '{item}'\")\n                except Exception as e:\n                    app.logger.error(f\"Error while searching >>> {str(e)}\")\n\n    return render_template('search.html', zoekterm=found, system=SYSTEM_SETTINGS)\n\n\ndef fetch_page_name() -> str:\n    page_name = request.form['PN']\n    if page_name[-4:] == \"{id}\":\n        page_name = f\"{page_name[:-4]}{uuid.uuid4().hex}\"\n    return page_name\n\n\n@app.route('/list/', methods=['GET'])\ndef list_full_wiki():\n    return list_wiki(\"\")\n\n\n@app.route('/list/<path:folderpath>/', methods=['GET'])\ndef list_wiki(folderpath):\n    folder_list = []\n    app.logger.info(\"Showing >>> 'all files'\")\n    for root, subfolder, files in os.walk(os.path.join(cfg.wiki_directory, folderpath)):\n        if root[-1] == '/':\n            root = root[:-1]\n        for item in files:\n            path = os.path.join(root, item)\n            mtime = os.path.getmtime(os.path.join(root, item))\n            if os.path.join(cfg.wiki_directory, '.git') in str(path):\n                # We don't want to search there\n                app.logger.debug(f\"skipping {path}: is git file\")\n                continue\n            if os.path.join(cfg.wiki_directory, cfg.images_route) in str(path):\n                # Nothing interesting there too\n                continue\n\n            folder = root[len(cfg.wiki_directory + \"/\"):]\n            if folder == \"\":\n                if item == cfg.homepage:\n                    continue\n                url = os.path.splitext(\n                    root[len(cfg.wiki_directory + \"/\"):] + \"/\" + item)[0]\n            else:\n                url = \"/\" + \\\n                    os.path.splitext(\n                        root[len(cfg.wiki_directory + \"/\"):] + \"/\" + item)[0]\n\n            info = {'doc': item,\n                    'url': url,\n                    'folder': folder,\n                    'folder_url': folder,\n                    'mtime': mtime,\n                    }\n            folder_list.append(info)\n\n    if SYSTEM_SETTINGS['listsortMTime']:\n        folder_list.sort(key=lambda x: x[\"mtime\"], reverse=True)\n    else:\n        folder_list.sort(key=lambda x: (str(x[\"url\"]).casefold()))\n\n    return render_template('list_files.html', list=folder_list, folder=folderpath, system=SYSTEM_SETTINGS)\n\n\n@app.route('/<path:file_page>', methods=['POST', 'GET'])\ndef file_page(file_page):\n    if request.method == 'POST':\n        return search()\n    else:\n        html = \"\"\n        mod = \"\"\n        folder = \"\"\n\n        if \"favicon\" not in file_page:  # if the GET request is not for the favicon\n            try:\n                md_file_path = os.path.join(cfg.wiki_directory, file_page + \".md\")\n                # latex = pypandoc.convert_file(\"wiki/\" + file_page + \".md\", \"tex\", format=\"md\")\n                # html = pypandoc.convert_text(latex,\"html5\",format='tex', extra_args=[\"--mathjax\"])\n\n                app.logger.info(f\"Converting to HTML with pandoc >>> '{md_file_path}' ...\")\n                html = pypandoc.convert_file(md_file_path, \"html5\",\n                                             format='md', extra_args=[\"--mathjax\"], filters=['pandoc-xnos'])\n\n                mod = \"Last modified: %s\" % time.ctime(os.path.getmtime(md_file_path))\n                folder = file_page.split(\"/\")\n                file_page = folder[-1:][0]\n                folder = folder[:-1]\n                folder = \"/\".join(folder)\n                app.logger.info(f\"Showing HTML page >>> '{file_page}'\")\n            except Exception as a:\n                app.logger.info(a)\n\n        return render_template('content.html', title=file_page, folder=folder, info=html, modif=mod,\n                               system=SYSTEM_SETTINGS)\n\n\n@app.route('/', methods=['POST', 'GET'])\ndef index():\n    if request.method == 'POST':\n        return search()\n    else:\n        html = \"\"\n        app.logger.info(\"Showing HTML page >>> 'homepage'\")\n        try:\n            app.logger.info(\"Converting to HTML with pandoc >>> 'homepage' ...\")\n            html = pypandoc.convert_file(\n                os.path.join(cfg.wiki_directory, cfg.homepage), \"html5\", format='md', extra_args=[\"--mathjax\"],\n                filters=['pandoc-xnos'])\n\n        except Exception as e:\n            app.logger.error(f\"Conversion to HTML failed >>> {str(e)}\")\n\n        return render_template('index.html', homepage=html, system=SYSTEM_SETTINGS)\n\n\n@app.route('/add_new', methods=['POST', 'GET'])\ndef add_new():\n    if(bool(cfg.protect_edit_by_password) and (request.cookies.get('session_wikmd') not in SESSIONS)):\n        return login(\"/add_new\")\n    if request.method == 'POST':\n        page_name = fetch_page_name()\n        save(page_name)\n        git_sync_thread = Thread(target=wrm.git_sync, args=(page_name, \"Add\"))\n        git_sync_thread.start()\n\n        return redirect(url_for(\"file_page\", file_page=page_name))\n    else:\n        return render_template('new.html', upload_path=cfg.images_route, system=SYSTEM_SETTINGS)\n\n\n@app.route('/edit/homepage', methods=['POST', 'GET'])\ndef edit_homepage():\n    if(bool(cfg.protect_edit_by_password) and (request.cookies.get('session_wikmd') not in SESSIONS)):\n        return login(\"/edit/homepage\")\n\n    if request.method == 'POST':\n        page_name = fetch_page_name()\n        save(page_name)\n        git_sync_thread = Thread(target=wrm.git_sync, args=(page_name, \"Edit\"))\n        git_sync_thread.start()\n\n        return redirect(url_for(\"file_page\", file_page=page_name))\n    else:\n\n        with open(os.path.join(cfg.wiki_directory, cfg.homepage), 'r', encoding=\"utf-8\", errors='ignore') as f:\n\n            content = f.read()\n        return render_template(\"new.html\", content=content, title=cfg.homepage_title, upload_path=cfg.images_route,\n                               system=SYSTEM_SETTINGS)\n\n\n@app.route('/remove/<path:page>', methods=['GET'])\ndef remove(page):\n    app.logger.info(request.cookies.get('session_wikmd'))\n    if(bool(cfg.protect_edit_by_password) and (request.cookies.get('session_wikmd') not in SESSIONS)):\n        return redirect(url_for(\"file_page\", file_page=page))\n\n    filename = os.path.join(cfg.wiki_directory, page + '.md')\n    os.remove(filename)\n    git_sync_thread = Thread(target=wrm.git_sync, args=(page, \"Remove\"))\n    git_sync_thread.start()\n    return redirect(\"/\")\n\n\n@app.route('/edit/<path:page>', methods=['POST', 'GET'])\ndef edit(page):\n    if(bool(cfg.protect_edit_by_password) and (request.cookies.get('session_wikmd') not in SESSIONS)):\n        return login(page)\n    filename = os.path.join(cfg.wiki_directory, page + '.md')\n    if request.method == 'POST':\n        page_name = fetch_page_name()\n        if page_name != page:\n            os.remove(filename)\n\n        save(page_name)\n        git_sync_thread = Thread(target=wrm.git_sync, args=(page_name, \"Edit\"))\n        git_sync_thread.start()\n\n        return redirect(url_for(\"file_page\", file_page=page_name))\n    else:\n        with open(filename, 'r', encoding=\"utf-8\", errors='ignore') as f:\n            content = f.read()\n        return render_template(\"new.html\", content=content, title=page, upload_path=cfg.images_route,\n                               system=SYSTEM_SETTINGS)\n\n\n@app.route('/' + cfg.images_route, methods=['POST', 'DELETE'])\ndef upload_file():\n    app.logger.info(f\"Uploading new image ...\")\n    # Upload image when POST\n    if request.method == \"POST\":\n        file_names = []\n        for key in request.files:\n            file = request.files[key]\n            filename = secure_filename(file.filename)\n            # bug found by cat-0\n            while filename in os.listdir(os.path.join(cfg.wiki_directory, cfg.images_route)):\n                app.logger.info(\n                    \"There is a duplicate, solving this by extending the filename...\")\n                filename, file_extension = os.path.splitext(filename)\n                filename = filename + str(randint(1, 9999999)) + file_extension\n\n            file_names.append(filename)\n            try:\n                app.logger.info(f\"Saving image >>> '{filename}' ...\")\n                file.save(os.path.join(app.config['UPLOAD_FOLDER'], filename))\n            except Exception as e:\n                app.logger.error(f\"Error while saving image >>> {str(e)}\")\n        return filename\n\n    # DELETE when DELETE\n    if request.method == \"DELETE\":\n        # request data is in format \"b'nameoffile.png\" decode by utf-8\n        filename = request.data.decode(\"utf-8\")\n        try:\n            app.logger.info(f\"Removing >>> '{str(filename)}' ...\")\n            os.remove((os.path.join(app.config['UPLOAD_FOLDER'], filename)))\n        except Exception as e:\n            app.logger.error(f\"Could not remove {str(filename)}\")\n        return 'OK'\n\n\n@app.route('/knowledge-graph', methods=['GET'])\ndef graph():\n    global links\n    links = knowledge_graph.find_links()\n    return render_template(\"knowledge-graph.html\", links=links, system=SYSTEM_SETTINGS)\n\n\n@app.route('/login', methods=['GET','POST'])\ndef login(page):\n    if request.method == \"POST\":\n        password = request.form[\"password\"]\n        sha_string = sha256(password.encode('utf-8')).hexdigest()\n        if sha_string == cfg.password_in_sha_256.lower():\n            app.logger.info(\"User successfully logged in\")\n            resp = make_response(redirect(page))\n            session = ''.join(random.choice(string.ascii_lowercase) for i in range(231))\n            resp.set_cookie(\"session_wikmd\",session)\n            SESSIONS.append(session)\n            return resp\n        else:\n            app.logger.info(\"Login failed!\")\n    else:\n        app.logger.info(\"Display login page\")\n    return render_template(\"login.html\", system=SYSTEM_SETTINGS)\n\n# Translate id to page path\n\n\n@app.route('/nav/<path:id>/', methods=['GET'])\ndef nav_id_to_page(id):\n    for i in links:\n        if i[\"id\"] == int(id):\n            return redirect(\"/\"+i[\"path\"])\n    return redirect(\"/\")\n\n\n@app.route('/' + cfg.images_route + '/<path:filename>')\ndef display_image(filename):\n    # print('display_image filename: ' + filename)\n    return send_from_directory(UPLOAD_FOLDER, filename, as_attachment=False)\n\n\n@app.route('/toggle-darktheme/', methods=['GET'])\ndef toggle_darktheme():\n    SYSTEM_SETTINGS['darktheme'] = not SYSTEM_SETTINGS['darktheme']\n    return redirect(request.referrer)  # redirect to the same page URL\n\n\n@app.route('/toggle-sorting/', methods=['GET'])\ndef toggle_sort():\n    SYSTEM_SETTINGS['listsortMTime'] = not SYSTEM_SETTINGS['listsortMTime']\n    return redirect(\"/list\")\n\n\ndef run_wiki():\n    \"\"\"\n    Function that runs the wiki as a Flask app.\n    \"\"\"\n    if int(cfg.wikmd_logging) == 1:\n        logging.basicConfig(filename=cfg.wikmd_logging_file, level=logging.INFO)\n\n    app.run(host=cfg.wikmd_host, port=cfg.wikmd_port, debug=True, use_reloader=False)\n\n\nif __name__ == '__main__':\n    run_wiki()\n"], "fixing_code": ["click==7.1.2\nFlask==1.1.2\ngitdb==4.0.5\nGitPython==3.1.11\nitsdangerous==1.1.0\nJinja2==2.11.3\nMarkdown==3.3.3\nMarkupSafe==1.1.1\npandoc-eqnos==2.4.0\npandoc-fignos==2.4.0\npandoc-secnos==2.2.2\npandoc-tablenos==2.3.0\npandoc-xnos==2.5.0\npandocfilters==1.4.3\npsutil==5.7.3\npypandoc==1.5\nPyYAML==6.0\nrequests==2.27.1\nsmmap==3.0.4\nWerkzeug==1.0.1\nidna==3.3\nlxml==4.9.1\n", "import os\nfrom shutil import ExecError\nimport time\nimport re\nimport logging\nimport uuid\nfrom lxml.html.clean import clean_html\nimport pypandoc\nimport knowledge_graph\nimport random\nimport string\n\nfrom flask import Flask, render_template, request, redirect, url_for, send_from_directory, make_response\nfrom werkzeug.utils import secure_filename\nfrom random import randint\nfrom threading import Thread\nfrom hashlib import sha256\n\nfrom config import WikmdConfig\nfrom git_manager import WikiRepoManager\nfrom web_dependencies import get_web_deps\n\n\nALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'gif'}\n\nSESSIONS = []\n\ncfg = WikmdConfig()\nUPLOAD_FOLDER = f\"{cfg.wiki_directory}/{cfg.images_route}\"\n\napp = Flask(__name__)\napp.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER\n\n# console logger\napp.logger.setLevel(logging.INFO)\n\n# file logger\nlogger = logging.getLogger('werkzeug')\nlogger.setLevel(logging.ERROR)\n\nwrm = WikiRepoManager(flask_app=app)\n\nSYSTEM_SETTINGS = {\n    \"darktheme\": False,\n    \"listsortMTime\": False,\n    \"web_deps\": get_web_deps(cfg.local_mode, app.logger)\n}\n\ndef save(page_name):\n    \"\"\"\n    Function that saves a *.md page.\n    :param page_name: name of the page\n    \"\"\"\n    content = request.form['CT']\n    app.logger.info(f\"Saving >>> '{page_name}' ...\")\n\n    try:\n        filename = os.path.join(cfg.wiki_directory, page_name + '.md')\n        dirname = os.path.dirname(filename)\n        if not os.path.exists(dirname):\n            os.makedirs(dirname)\n        with open(filename, 'w') as f:\n            f.write(content)\n    except Exception as e:\n        app.logger.error(f\"Error while saving '{page_name}' >>> {str(e)}\")\n\n\ndef search():\n    \"\"\"\n    Function that searches for a term and shows the results.\n    \"\"\"\n    search_term = request.form['ss']\n    escaped_search_term = re.escape(search_term)\n    found = []\n\n    app.logger.info(f\"Searching >>> '{search_term}' ...\")\n\n    for root, subfolder, files in os.walk(cfg.wiki_directory):\n        for item in files:\n            path = os.path.join(root, item)\n            if os.path.join(cfg.wiki_directory, '.git') in str(path):\n                # We don't want to search there\n                app.logger.debug(f\"Skipping {path} is git file\")\n                continue\n            if os.path.join(cfg.wiki_directory, cfg.images_route) in str(path):\n                # Nothing interesting there too\n                continue\n            with open(root + '/' + item, encoding=\"utf8\", errors='ignore') as f:\n                fin = f.read()\n                try:\n                    if (re.search(escaped_search_term, root + '/' + item, re.IGNORECASE) or\n                            re.search(escaped_search_term, fin, re.IGNORECASE) is not None):\n                        # Stripping 'wiki/' part of path before serving as a search result\n                        folder = root[len(cfg.wiki_directory + \"/\"):]\n                        if folder == \"\":\n                            url = os.path.splitext(\n                                root[len(cfg.wiki_directory + \"/\"):] + \"/\" + item)[0]\n                        else:\n                            url = \"/\" + \\\n                                  os.path.splitext(\n                                      root[len(cfg.wiki_directory + \"/\"):] + \"/\" + item)[0]\n\n                        info = {'doc': item,\n                                'url': url,\n                                'folder': folder,\n                                'folder_url': root[len(cfg.wiki_directory + \"/\"):]}\n                        found.append(info)\n                        app.logger.info(f\"Found '{search_term}' in '{item}'\")\n                except Exception as e:\n                    app.logger.error(f\"Error while searching >>> {str(e)}\")\n\n    return render_template('search.html', zoekterm=found, system=SYSTEM_SETTINGS)\n\n\ndef fetch_page_name() -> str:\n    page_name = request.form['PN']\n    if page_name[-4:] == \"{id}\":\n        page_name = f\"{page_name[:-4]}{uuid.uuid4().hex}\"\n    return page_name\n\n\n@app.route('/list/', methods=['GET'])\ndef list_full_wiki():\n    return list_wiki(\"\")\n\n\n@app.route('/list/<path:folderpath>/', methods=['GET'])\ndef list_wiki(folderpath):\n    folder_list = []\n    app.logger.info(\"Showing >>> 'all files'\")\n    for root, subfolder, files in os.walk(os.path.join(cfg.wiki_directory, folderpath)):\n        if root[-1] == '/':\n            root = root[:-1]\n        for item in files:\n            path = os.path.join(root, item)\n            mtime = os.path.getmtime(os.path.join(root, item))\n            if os.path.join(cfg.wiki_directory, '.git') in str(path):\n                # We don't want to search there\n                app.logger.debug(f\"skipping {path}: is git file\")\n                continue\n            if os.path.join(cfg.wiki_directory, cfg.images_route) in str(path):\n                # Nothing interesting there too\n                continue\n\n            folder = root[len(cfg.wiki_directory + \"/\"):]\n            if folder == \"\":\n                if item == cfg.homepage:\n                    continue\n                url = os.path.splitext(\n                    root[len(cfg.wiki_directory + \"/\"):] + \"/\" + item)[0]\n            else:\n                url = \"/\" + \\\n                    os.path.splitext(\n                        root[len(cfg.wiki_directory + \"/\"):] + \"/\" + item)[0]\n\n            info = {'doc': item,\n                    'url': url,\n                    'folder': folder,\n                    'folder_url': folder,\n                    'mtime': mtime,\n                    }\n            folder_list.append(info)\n\n    if SYSTEM_SETTINGS['listsortMTime']:\n        folder_list.sort(key=lambda x: x[\"mtime\"], reverse=True)\n    else:\n        folder_list.sort(key=lambda x: (str(x[\"url\"]).casefold()))\n\n    return render_template('list_files.html', list=folder_list, folder=folderpath, system=SYSTEM_SETTINGS)\n\n\n@app.route('/<path:file_page>', methods=['POST', 'GET'])\ndef file_page(file_page):\n    if request.method == 'POST':\n        return search()\n    else:\n        html = \"\"\n        mod = \"\"\n        folder = \"\"\n\n        if \"favicon\" not in file_page:  # if the GET request is not for the favicon\n            try:\n                md_file_path = os.path.join(cfg.wiki_directory, file_page + \".md\")\n                # latex = pypandoc.convert_file(\"wiki/\" + file_page + \".md\", \"tex\", format=\"md\")\n                # html = pypandoc.convert_text(latex,\"html5\",format='tex', extra_args=[\"--mathjax\"])\n\n                app.logger.info(f\"Converting to HTML with pandoc >>> '{md_file_path}' ...\")\n                html = pypandoc.convert_file(md_file_path, \"html5\",\n                                             format='md', extra_args=[\"--mathjax\"], filters=['pandoc-xnos'])\n                html = clean_html(html)\n                mod = \"Last modified: %s\" % time.ctime(os.path.getmtime(md_file_path))\n                folder = file_page.split(\"/\")\n                file_page = folder[-1:][0]\n                folder = folder[:-1]\n                folder = \"/\".join(folder)\n                app.logger.info(f\"Showing HTML page >>> '{file_page}'\")\n            except Exception as a:\n                app.logger.info(a)\n\n        return render_template('content.html', title=file_page, folder=folder, info=html, modif=mod,\n                               system=SYSTEM_SETTINGS)\n\n\n@app.route('/', methods=['POST', 'GET'])\ndef index():\n    if request.method == 'POST':\n        return search()\n    else:\n        html = \"\"\n        app.logger.info(\"Showing HTML page >>> 'homepage'\")\n        try:\n            app.logger.info(\"Converting to HTML with pandoc >>> 'homepage' ...\")\n            html = pypandoc.convert_file(\n                os.path.join(cfg.wiki_directory, cfg.homepage), \"html5\", format='md', extra_args=[\"--mathjax\"],\n                filters=['pandoc-xnos'])\n            html = clean_html(html)\n\n        except Exception as e:\n            app.logger.error(f\"Conversion to HTML failed >>> {str(e)}\")\n\n        return render_template('index.html', homepage=html, system=SYSTEM_SETTINGS)\n\n\n@app.route('/add_new', methods=['POST', 'GET'])\ndef add_new():\n    if(bool(cfg.protect_edit_by_password) and (request.cookies.get('session_wikmd') not in SESSIONS)):\n        return login(\"/add_new\")\n    if request.method == 'POST':\n        page_name = fetch_page_name()\n        save(page_name)\n        git_sync_thread = Thread(target=wrm.git_sync, args=(page_name, \"Add\"))\n        git_sync_thread.start()\n\n        return redirect(url_for(\"file_page\", file_page=page_name))\n    else:\n        return render_template('new.html', upload_path=cfg.images_route, system=SYSTEM_SETTINGS)\n\n\n@app.route('/edit/homepage', methods=['POST', 'GET'])\ndef edit_homepage():\n    if(bool(cfg.protect_edit_by_password) and (request.cookies.get('session_wikmd') not in SESSIONS)):\n        return login(\"/edit/homepage\")\n\n    if request.method == 'POST':\n        page_name = fetch_page_name()\n        save(page_name)\n        git_sync_thread = Thread(target=wrm.git_sync, args=(page_name, \"Edit\"))\n        git_sync_thread.start()\n\n        return redirect(url_for(\"file_page\", file_page=page_name))\n    else:\n\n        with open(os.path.join(cfg.wiki_directory, cfg.homepage), 'r', encoding=\"utf-8\", errors='ignore') as f:\n\n            content = f.read()\n        return render_template(\"new.html\", content=content, title=cfg.homepage_title, upload_path=cfg.images_route,\n                               system=SYSTEM_SETTINGS)\n\n\n@app.route('/remove/<path:page>', methods=['GET'])\ndef remove(page):\n    app.logger.info(request.cookies.get('session_wikmd'))\n    if(bool(cfg.protect_edit_by_password) and (request.cookies.get('session_wikmd') not in SESSIONS)):\n        return redirect(url_for(\"file_page\", file_page=page))\n\n    filename = os.path.join(cfg.wiki_directory, page + '.md')\n    os.remove(filename)\n    git_sync_thread = Thread(target=wrm.git_sync, args=(page, \"Remove\"))\n    git_sync_thread.start()\n    return redirect(\"/\")\n\n\n@app.route('/edit/<path:page>', methods=['POST', 'GET'])\ndef edit(page):\n    if(bool(cfg.protect_edit_by_password) and (request.cookies.get('session_wikmd') not in SESSIONS)):\n        return login(page)\n    filename = os.path.join(cfg.wiki_directory, page + '.md')\n    if request.method == 'POST':\n        page_name = fetch_page_name()\n        if page_name != page:\n            os.remove(filename)\n\n        save(page_name)\n        git_sync_thread = Thread(target=wrm.git_sync, args=(page_name, \"Edit\"))\n        git_sync_thread.start()\n\n        return redirect(url_for(\"file_page\", file_page=page_name))\n    else:\n        with open(filename, 'r', encoding=\"utf-8\", errors='ignore') as f:\n            content = f.read()\n        return render_template(\"new.html\", content=content, title=page, upload_path=cfg.images_route,\n                               system=SYSTEM_SETTINGS)\n\n\n@app.route('/' + cfg.images_route, methods=['POST', 'DELETE'])\ndef upload_file():\n    app.logger.info(f\"Uploading new image ...\")\n    # Upload image when POST\n    if request.method == \"POST\":\n        file_names = []\n        for key in request.files:\n            file = request.files[key]\n            filename = secure_filename(file.filename)\n            # bug found by cat-0\n            while filename in os.listdir(os.path.join(cfg.wiki_directory, cfg.images_route)):\n                app.logger.info(\n                    \"There is a duplicate, solving this by extending the filename...\")\n                filename, file_extension = os.path.splitext(filename)\n                filename = filename + str(randint(1, 9999999)) + file_extension\n\n            file_names.append(filename)\n            try:\n                app.logger.info(f\"Saving image >>> '{filename}' ...\")\n                file.save(os.path.join(app.config['UPLOAD_FOLDER'], filename))\n            except Exception as e:\n                app.logger.error(f\"Error while saving image >>> {str(e)}\")\n        return filename\n\n    # DELETE when DELETE\n    if request.method == \"DELETE\":\n        # request data is in format \"b'nameoffile.png\" decode by utf-8\n        filename = request.data.decode(\"utf-8\")\n        try:\n            app.logger.info(f\"Removing >>> '{str(filename)}' ...\")\n            os.remove((os.path.join(app.config['UPLOAD_FOLDER'], filename)))\n        except Exception as e:\n            app.logger.error(f\"Could not remove {str(filename)}\")\n        return 'OK'\n\n\n@app.route('/knowledge-graph', methods=['GET'])\ndef graph():\n    global links\n    links = knowledge_graph.find_links()\n    return render_template(\"knowledge-graph.html\", links=links, system=SYSTEM_SETTINGS)\n\n\n@app.route('/login', methods=['GET','POST'])\ndef login(page):\n    if request.method == \"POST\":\n        password = request.form[\"password\"]\n        sha_string = sha256(password.encode('utf-8')).hexdigest()\n        if sha_string == cfg.password_in_sha_256.lower():\n            app.logger.info(\"User successfully logged in\")\n            resp = make_response(redirect(page))\n            session = ''.join(random.choice(string.ascii_lowercase) for i in range(231))\n            resp.set_cookie(\"session_wikmd\",session)\n            SESSIONS.append(session)\n            return resp\n        else:\n            app.logger.info(\"Login failed!\")\n    else:\n        app.logger.info(\"Display login page\")\n    return render_template(\"login.html\", system=SYSTEM_SETTINGS)\n\n# Translate id to page path\n\n\n@app.route('/nav/<path:id>/', methods=['GET'])\ndef nav_id_to_page(id):\n    for i in links:\n        if i[\"id\"] == int(id):\n            return redirect(\"/\"+i[\"path\"])\n    return redirect(\"/\")\n\n\n@app.route('/' + cfg.images_route + '/<path:filename>')\ndef display_image(filename):\n    # print('display_image filename: ' + filename)\n    return send_from_directory(UPLOAD_FOLDER, filename, as_attachment=False)\n\n\n@app.route('/toggle-darktheme/', methods=['GET'])\ndef toggle_darktheme():\n    SYSTEM_SETTINGS['darktheme'] = not SYSTEM_SETTINGS['darktheme']\n    return redirect(request.referrer)  # redirect to the same page URL\n\n\n@app.route('/toggle-sorting/', methods=['GET'])\ndef toggle_sort():\n    SYSTEM_SETTINGS['listsortMTime'] = not SYSTEM_SETTINGS['listsortMTime']\n    return redirect(\"/list\")\n\n\ndef run_wiki():\n    \"\"\"\n    Function that runs the wiki as a Flask app.\n    \"\"\"\n    if int(cfg.wikmd_logging) == 1:\n        logging.basicConfig(filename=cfg.wikmd_logging_file, level=logging.INFO)\n\n    app.run(host=cfg.wikmd_host, port=cfg.wikmd_port, debug=True, use_reloader=False)\n\n\nif __name__ == '__main__':\n    run_wiki()\n"], "filenames": ["requirements.txt", "wiki.py"], "buggy_code_start_loc": [21, 6], "buggy_code_end_loc": [21, 214], "fixing_code_start_loc": [22, 7], "fixing_code_end_loc": [23, 217], "type": "CWE-79", "message": "Wikmd is a file based wiki that uses markdown. Prior to version 1.7.1, an attacker could capture user's session cookies or execute malicious Javascript when a victim edits a markdown file. Version 1.7.1 fixes this issue.", "other": {"cve": {"id": "CVE-2022-36080", "sourceIdentifier": "security-advisories@github.com", "published": "2022-09-07T21:15:08.630", "lastModified": "2022-09-12T18:24:52.600", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Wikmd is a file based wiki that uses markdown. Prior to version 1.7.1, an attacker could capture user's session cookies or execute malicious Javascript when a victim edits a markdown file. Version 1.7.1 fixes this issue."}, {"lang": "es", "value": "Wikmd es un wiki basado en archivos que usa markdown. En versiones anteriores a 1.7.1, un atacante pod\u00eda capturar las cookies de sesi\u00f3n del usuario o ejecutar Javascript malicioso cuando una v\u00edctima editaba un archivo markdown. La versi\u00f3n 1.7.1 corrige este problema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:wikmd_project:wikmd:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.7.1", "matchCriteriaId": "34AE46B4-06B6-40EE-888F-3AC79226EB08"}]}]}], "references": [{"url": "https://github.com/Linbreux/wikmd/commit/259412c47d64d5b85980f95345179fbf05927798", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/Linbreux/wikmd/security/advisories/GHSA-9m4m-6gqx-gfj3", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Linbreux/wikmd/commit/259412c47d64d5b85980f95345179fbf05927798"}}