{"buggy_code": ["/*\nCopyright (c) 2009-2020 Roger Light <roger@atchoo.org>\n\nAll rights reserved. This program and the accompanying materials\nare made available under the terms of the Eclipse Public License 2.0\nand Eclipse Distribution License v1.0 which accompany this distribution.\n\nThe Eclipse Public License is available at\n   https://www.eclipse.org/legal/epl-2.0/\nand the Eclipse Distribution License is available at\n  http://www.eclipse.org/org/documents/edl-v10.php.\n\nSPDX-License-Identifier: EPL-2.0 OR BSD-3-Clause\n\nContributors:\n   Roger Light - initial implementation and documentation.\n*/\n\n#include \"config.h\"\n\n#include <assert.h>\n#include <errno.h>\n#include <string.h>\n\n#ifdef WITH_BROKER\n#  include \"mosquitto_broker_internal.h\"\n#  ifdef WITH_WEBSOCKETS\n#    include <libwebsockets.h>\n#  endif\n#else\n#  include \"read_handle.h\"\n#endif\n\n#include \"memory_mosq.h\"\n#include \"mqtt_protocol.h\"\n#include \"net_mosq.h\"\n#include \"packet_mosq.h\"\n#include \"read_handle.h\"\n#include \"util_mosq.h\"\n#ifdef WITH_BROKER\n#  include \"sys_tree.h\"\n#  include \"send_mosq.h\"\n#else\n#  define G_BYTES_RECEIVED_INC(A)\n#  define G_BYTES_SENT_INC(A)\n#  define G_MSGS_SENT_INC(A)\n#  define G_PUB_MSGS_SENT_INC(A)\n#endif\n\nint packet__alloc(struct mosquitto__packet *packet)\n{\n\tuint8_t remaining_bytes[5], byte;\n\tuint32_t remaining_length;\n\tint i;\n\n\tassert(packet);\n\n\tremaining_length = packet->remaining_length;\n\tpacket->payload = NULL;\n\tpacket->remaining_count = 0;\n\tdo{\n\t\tbyte = remaining_length % 128;\n\t\tremaining_length = remaining_length / 128;\n\t\t/* If there are more digits to encode, set the top bit of this digit */\n\t\tif(remaining_length > 0){\n\t\t\tbyte = byte | 0x80;\n\t\t}\n\t\tremaining_bytes[packet->remaining_count] = byte;\n\t\tpacket->remaining_count++;\n\t}while(remaining_length > 0 && packet->remaining_count < 5);\n\tif(packet->remaining_count == 5) return MOSQ_ERR_PAYLOAD_SIZE;\n\tpacket->packet_length = packet->remaining_length + 1 + (uint8_t)packet->remaining_count;\n#ifdef WITH_WEBSOCKETS\n\tpacket->payload = mosquitto__malloc(sizeof(uint8_t)*packet->packet_length + LWS_PRE);\n#else\n\tpacket->payload = mosquitto__malloc(sizeof(uint8_t)*packet->packet_length);\n#endif\n\tif(!packet->payload) return MOSQ_ERR_NOMEM;\n\n\tpacket->payload[0] = packet->command;\n\tfor(i=0; i<packet->remaining_count; i++){\n\t\tpacket->payload[i+1] = remaining_bytes[i];\n\t}\n\tpacket->pos = 1U + (uint8_t)packet->remaining_count;\n\n\treturn MOSQ_ERR_SUCCESS;\n}\n\nvoid packet__cleanup(struct mosquitto__packet *packet)\n{\n\tif(!packet) return;\n\n\t/* Free data and reset values */\n\tpacket->command = 0;\n\tpacket->remaining_count = 0;\n\tpacket->remaining_mult = 1;\n\tpacket->remaining_length = 0;\n\tmosquitto__free(packet->payload);\n\tpacket->payload = NULL;\n\tpacket->to_process = 0;\n\tpacket->pos = 0;\n}\n\n\nvoid packet__cleanup_all_no_locks(struct mosquitto *mosq)\n{\n\tstruct mosquitto__packet *packet;\n\n\t/* Out packet cleanup */\n\tif(mosq->out_packet && !mosq->current_out_packet){\n\t\tmosq->current_out_packet = mosq->out_packet;\n\t\tmosq->out_packet = mosq->out_packet->next;\n\t}\n\twhile(mosq->current_out_packet){\n\t\tpacket = mosq->current_out_packet;\n\t\t/* Free data and reset values */\n\t\tmosq->current_out_packet = mosq->out_packet;\n\t\tif(mosq->out_packet){\n\t\t\tmosq->out_packet = mosq->out_packet->next;\n\t\t}\n\n\t\tpacket__cleanup(packet);\n\t\tmosquitto__free(packet);\n\t}\n\n\tpacket__cleanup(&mosq->in_packet);\n}\n\nvoid packet__cleanup_all(struct mosquitto *mosq)\n{\n\tpthread_mutex_lock(&mosq->current_out_packet_mutex);\n\tpthread_mutex_lock(&mosq->out_packet_mutex);\n\n\tpacket__cleanup_all_no_locks(mosq);\n\n\tpthread_mutex_unlock(&mosq->out_packet_mutex);\n\tpthread_mutex_unlock(&mosq->current_out_packet_mutex);\n}\n\n\nint packet__queue(struct mosquitto *mosq, struct mosquitto__packet *packet)\n{\n#ifndef WITH_BROKER\n\tchar sockpair_data = 0;\n#endif\n\tassert(mosq);\n\tassert(packet);\n\n\tpacket->pos = 0;\n\tpacket->to_process = packet->packet_length;\n\n\tpacket->next = NULL;\n\tpthread_mutex_lock(&mosq->out_packet_mutex);\n\tif(mosq->out_packet){\n\t\tmosq->out_packet_last->next = packet;\n\t}else{\n\t\tmosq->out_packet = packet;\n\t}\n\tmosq->out_packet_last = packet;\n\tpthread_mutex_unlock(&mosq->out_packet_mutex);\n#ifdef WITH_BROKER\n#  ifdef WITH_WEBSOCKETS\n\tif(mosq->wsi){\n\t\tlws_callback_on_writable(mosq->wsi);\n\t\treturn MOSQ_ERR_SUCCESS;\n\t}else{\n\t\treturn packet__write(mosq);\n\t}\n#  else\n\treturn packet__write(mosq);\n#  endif\n#else\n\n\t/* Write a single byte to sockpairW (connected to sockpairR) to break out\n\t * of select() if in threaded mode. */\n\tif(mosq->sockpairW != INVALID_SOCKET){\n#ifndef WIN32\n\t\tif(write(mosq->sockpairW, &sockpair_data, 1)){\n\t\t}\n#else\n\t\tsend(mosq->sockpairW, &sockpair_data, 1, 0);\n#endif\n\t}\n\n\tif(mosq->in_callback == false && mosq->threaded == mosq_ts_none){\n\t\treturn packet__write(mosq);\n\t}else{\n\t\treturn MOSQ_ERR_SUCCESS;\n\t}\n#endif\n}\n\n\nint packet__check_oversize(struct mosquitto *mosq, uint32_t remaining_length)\n{\n\tuint32_t len;\n\n\tif(mosq->maximum_packet_size == 0) return MOSQ_ERR_SUCCESS;\n\n\tlen = remaining_length + packet__varint_bytes(remaining_length);\n\tif(len > mosq->maximum_packet_size){\n\t\treturn MOSQ_ERR_OVERSIZE_PACKET;\n\t}else{\n\t\treturn MOSQ_ERR_SUCCESS;\n\t}\n}\n\n\nint packet__write(struct mosquitto *mosq)\n{\n\tssize_t write_length;\n\tstruct mosquitto__packet *packet;\n\tenum mosquitto_client_state state;\n\n\tif(!mosq) return MOSQ_ERR_INVAL;\n\tif(mosq->sock == INVALID_SOCKET) return MOSQ_ERR_NO_CONN;\n\n#ifdef WITH_BROKER\n\tmux__add_out(mosq);\n#endif\n\n\tpthread_mutex_lock(&mosq->current_out_packet_mutex);\n\tpthread_mutex_lock(&mosq->out_packet_mutex);\n\tif(mosq->out_packet && !mosq->current_out_packet){\n\t\tmosq->current_out_packet = mosq->out_packet;\n\t\tmosq->out_packet = mosq->out_packet->next;\n\t\tif(!mosq->out_packet){\n\t\t\tmosq->out_packet_last = NULL;\n\t\t}\n\t}\n\tpthread_mutex_unlock(&mosq->out_packet_mutex);\n\n\tstate = mosquitto__get_state(mosq);\n#if defined(WITH_TLS) && !defined(WITH_BROKER)\n\tif(state == mosq_cs_connect_pending || mosq->want_connect){\n#else\n\tif(state == mosq_cs_connect_pending){\n#endif\n\t\tpthread_mutex_unlock(&mosq->current_out_packet_mutex);\n\t\treturn MOSQ_ERR_SUCCESS;\n\t}\n\n\twhile(mosq->current_out_packet){\n\t\tpacket = mosq->current_out_packet;\n\n\t\twhile(packet->to_process > 0){\n\t\t\twrite_length = net__write(mosq, &(packet->payload[packet->pos]), packet->to_process);\n\t\t\tif(write_length > 0){\n\t\t\t\tG_BYTES_SENT_INC(write_length);\n\t\t\t\tpacket->to_process -= (uint32_t)write_length;\n\t\t\t\tpacket->pos += (uint32_t)write_length;\n\t\t\t}else{\n#ifdef WIN32\n\t\t\t\terrno = WSAGetLastError();\n#endif\n\t\t\t\tif(errno == EAGAIN || errno == COMPAT_EWOULDBLOCK\n#ifdef WIN32\n\t\t\t\t\t\t|| errno == WSAENOTCONN\n#endif\n\t\t\t\t\t\t){\n\t\t\t\t\tpthread_mutex_unlock(&mosq->current_out_packet_mutex);\n\t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n\t\t\t\t}else{\n\t\t\t\t\tpthread_mutex_unlock(&mosq->current_out_packet_mutex);\n\t\t\t\t\tswitch(errno){\n\t\t\t\t\t\tcase COMPAT_ECONNRESET:\n\t\t\t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n\t\t\t\t\t\tcase COMPAT_EINTR:\n\t\t\t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn MOSQ_ERR_ERRNO;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tG_MSGS_SENT_INC(1);\n\t\tif(((packet->command)&0xF6) == CMD_PUBLISH){\n\t\t\tG_PUB_MSGS_SENT_INC(1);\n#ifndef WITH_BROKER\n\t\t\tpthread_mutex_lock(&mosq->callback_mutex);\n\t\t\tif(mosq->on_publish){\n\t\t\t\t/* This is a QoS=0 message */\n\t\t\t\tmosq->in_callback = true;\n\t\t\t\tmosq->on_publish(mosq, mosq->userdata, packet->mid);\n\t\t\t\tmosq->in_callback = false;\n\t\t\t}\n\t\t\tif(mosq->on_publish_v5){\n\t\t\t\t/* This is a QoS=0 message */\n\t\t\t\tmosq->in_callback = true;\n\t\t\t\tmosq->on_publish_v5(mosq, mosq->userdata, packet->mid, 0, NULL);\n\t\t\t\tmosq->in_callback = false;\n\t\t\t}\n\t\t\tpthread_mutex_unlock(&mosq->callback_mutex);\n\t\t}else if(((packet->command)&0xF0) == CMD_DISCONNECT){\n\t\t\tdo_client_disconnect(mosq, MOSQ_ERR_SUCCESS, NULL);\n\t\t\tpacket__cleanup(packet);\n\t\t\tmosquitto__free(packet);\n\t\t\treturn MOSQ_ERR_SUCCESS;\n#endif\n\t\t}else if(((packet->command)&0xF0) == CMD_PUBLISH){\n\t\t\tG_PUB_MSGS_SENT_INC(1);\n\t\t}\n\n\t\t/* Free data and reset values */\n\t\tpthread_mutex_lock(&mosq->out_packet_mutex);\n\t\tmosq->current_out_packet = mosq->out_packet;\n\t\tif(mosq->out_packet){\n\t\t\tmosq->out_packet = mosq->out_packet->next;\n\t\t\tif(!mosq->out_packet){\n\t\t\t\tmosq->out_packet_last = NULL;\n\t\t\t}\n\t\t}\n\t\tpthread_mutex_unlock(&mosq->out_packet_mutex);\n\n\t\tpacket__cleanup(packet);\n\t\tmosquitto__free(packet);\n\n#ifdef WITH_BROKER\n\t\tmosq->next_msg_out = db.now_s + mosq->keepalive;\n\t\tif(mosq->current_out_packet == NULL){\n\t\t\tmux__remove_out(mosq);\n\t\t}\n#else\n\t\tpthread_mutex_lock(&mosq->msgtime_mutex);\n\t\tmosq->next_msg_out = mosquitto_time() + mosq->keepalive;\n\t\tpthread_mutex_unlock(&mosq->msgtime_mutex);\n#endif\n\t}\n\tpthread_mutex_unlock(&mosq->current_out_packet_mutex);\n\treturn MOSQ_ERR_SUCCESS;\n}\n\n\nint packet__read(struct mosquitto *mosq)\n{\n\tuint8_t byte;\n\tssize_t read_length;\n\tint rc = 0;\n\tenum mosquitto_client_state state;\n\n\tif(!mosq){\n\t\treturn MOSQ_ERR_INVAL;\n\t}\n\tif(mosq->sock == INVALID_SOCKET){\n\t\treturn MOSQ_ERR_NO_CONN;\n\t}\n\n\tstate = mosquitto__get_state(mosq);\n\tif(state == mosq_cs_connect_pending){\n\t\treturn MOSQ_ERR_SUCCESS;\n\t}\n\n\t/* This gets called if pselect() indicates that there is network data\n\t * available - ie. at least one byte.  What we do depends on what data we\n\t * already have.\n\t * If we've not got a command, attempt to read one and save it. This should\n\t * always work because it's only a single byte.\n\t * Then try to read the remaining length. This may fail because it is may\n\t * be more than one byte - will need to save data pending next read if it\n\t * does fail.\n\t * Then try to read the remaining payload, where 'payload' here means the\n\t * combined variable header and actual payload. This is the most likely to\n\t * fail due to longer length, so save current data and current position.\n\t * After all data is read, send to mosquitto__handle_packet() to deal with.\n\t * Finally, free the memory and reset everything to starting conditions.\n\t */\n\tif(!mosq->in_packet.command){\n\t\tread_length = net__read(mosq, &byte, 1);\n\t\tif(read_length == 1){\n\t\t\tmosq->in_packet.command = byte;\n#ifdef WITH_BROKER\n\t\t\tG_BYTES_RECEIVED_INC(1);\n\t\t\t/* Clients must send CONNECT as their first command. */\n\t\t\tif(!(mosq->bridge) && state == mosq_cs_connected && (byte&0xF0) != CMD_CONNECT){\n\t\t\t\treturn MOSQ_ERR_PROTOCOL;\n\t\t\t}\n#endif\n\t\t}else{\n\t\t\tif(read_length == 0){\n\t\t\t\treturn MOSQ_ERR_CONN_LOST; /* EOF */\n\t\t\t}\n#ifdef WIN32\n\t\t\terrno = WSAGetLastError();\n#endif\n\t\t\tif(errno == EAGAIN || errno == COMPAT_EWOULDBLOCK){\n\t\t\t\treturn MOSQ_ERR_SUCCESS;\n\t\t\t}else{\n\t\t\t\tswitch(errno){\n\t\t\t\t\tcase COMPAT_ECONNRESET:\n\t\t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n\t\t\t\t\tcase COMPAT_EINTR:\n\t\t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn MOSQ_ERR_ERRNO;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t/* remaining_count is the number of bytes that the remaining_length\n\t * parameter occupied in this incoming packet. We don't use it here as such\n\t * (it is used when allocating an outgoing packet), but we must be able to\n\t * determine whether all of the remaining_length parameter has been read.\n\t * remaining_count has three states here:\n\t *   0 means that we haven't read any remaining_length bytes\n\t *   <0 means we have read some remaining_length bytes but haven't finished\n\t *   >0 means we have finished reading the remaining_length bytes.\n\t */\n\tif(mosq->in_packet.remaining_count <= 0){\n\t\tdo{\n\t\t\tread_length = net__read(mosq, &byte, 1);\n\t\t\tif(read_length == 1){\n\t\t\t\tmosq->in_packet.remaining_count--;\n\t\t\t\t/* Max 4 bytes length for remaining length as defined by protocol.\n\t\t\t\t * Anything more likely means a broken/malicious client.\n\t\t\t\t */\n\t\t\t\tif(mosq->in_packet.remaining_count < -4){\n\t\t\t\t\treturn MOSQ_ERR_PROTOCOL;\n\t\t\t\t}\n\n\t\t\t\tG_BYTES_RECEIVED_INC(1);\n\t\t\t\tmosq->in_packet.remaining_length += (byte & 127) * mosq->in_packet.remaining_mult;\n\t\t\t\tmosq->in_packet.remaining_mult *= 128;\n\t\t\t}else{\n\t\t\t\tif(read_length == 0){\n\t\t\t\t\treturn MOSQ_ERR_CONN_LOST; /* EOF */\n\t\t\t\t}\n#ifdef WIN32\n\t\t\t\terrno = WSAGetLastError();\n#endif\n\t\t\t\tif(errno == EAGAIN || errno == COMPAT_EWOULDBLOCK){\n\t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n\t\t\t\t}else{\n\t\t\t\t\tswitch(errno){\n\t\t\t\t\t\tcase COMPAT_ECONNRESET:\n\t\t\t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n\t\t\t\t\t\tcase COMPAT_EINTR:\n\t\t\t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn MOSQ_ERR_ERRNO;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}while((byte & 128) != 0);\n\t\t/* We have finished reading remaining_length, so make remaining_count\n\t\t * positive. */\n\t\tmosq->in_packet.remaining_count = (int8_t)(mosq->in_packet.remaining_count * -1);\n\n#ifdef WITH_BROKER\n\t\tif(db.config->max_packet_size > 0 && mosq->in_packet.remaining_length+1 > db.config->max_packet_size){\n\t\t\tif(mosq->protocol == mosq_p_mqtt5){\n\t\t\t\tsend__disconnect(mosq, MQTT_RC_PACKET_TOO_LARGE, NULL);\n\t\t\t}\n\t\t\treturn MOSQ_ERR_OVERSIZE_PACKET;\n\t\t}\n#else\n\t\t// FIXME - client case for incoming message received from broker too large\n#endif\n\t\tif(mosq->in_packet.remaining_length > 0){\n\t\t\tmosq->in_packet.payload = mosquitto__malloc(mosq->in_packet.remaining_length*sizeof(uint8_t));\n\t\t\tif(!mosq->in_packet.payload){\n\t\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t\t}\n\t\t\tmosq->in_packet.to_process = mosq->in_packet.remaining_length;\n\t\t}\n\t}\n\twhile(mosq->in_packet.to_process>0){\n\t\tread_length = net__read(mosq, &(mosq->in_packet.payload[mosq->in_packet.pos]), mosq->in_packet.to_process);\n\t\tif(read_length > 0){\n\t\t\tG_BYTES_RECEIVED_INC(read_length);\n\t\t\tmosq->in_packet.to_process -= (uint32_t)read_length;\n\t\t\tmosq->in_packet.pos += (uint32_t)read_length;\n\t\t}else{\n#ifdef WIN32\n\t\t\terrno = WSAGetLastError();\n#endif\n\t\t\tif(errno == EAGAIN || errno == COMPAT_EWOULDBLOCK){\n\t\t\t\tif(mosq->in_packet.to_process > 1000){\n\t\t\t\t\t/* Update last_msg_in time if more than 1000 bytes left to\n\t\t\t\t\t * receive. Helps when receiving large messages.\n\t\t\t\t\t * This is an arbitrary limit, but with some consideration.\n\t\t\t\t\t * If a client can't send 1000 bytes in a second it\n\t\t\t\t\t * probably shouldn't be using a 1 second keep alive. */\n#ifdef WITH_BROKER\n\t\t\t\t\tkeepalive__update(mosq);\n#else\n\t\t\t\t\tpthread_mutex_lock(&mosq->msgtime_mutex);\n\t\t\t\t\tmosq->last_msg_in = mosquitto_time();\n\t\t\t\t\tpthread_mutex_unlock(&mosq->msgtime_mutex);\n#endif\n\t\t\t\t}\n\t\t\t\treturn MOSQ_ERR_SUCCESS;\n\t\t\t}else{\n\t\t\t\tswitch(errno){\n\t\t\t\t\tcase COMPAT_ECONNRESET:\n\t\t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n\t\t\t\t\tcase COMPAT_EINTR:\n\t\t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn MOSQ_ERR_ERRNO;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* All data for this packet is read. */\n\tmosq->in_packet.pos = 0;\n#ifdef WITH_BROKER\n\tG_MSGS_RECEIVED_INC(1);\n\tif(((mosq->in_packet.command)&0xF5) == CMD_PUBLISH){\n\t\tG_PUB_MSGS_RECEIVED_INC(1);\n\t}\n#endif\n\trc = handle__packet(mosq);\n\n\t/* Free data and reset values */\n\tpacket__cleanup(&mosq->in_packet);\n\n#ifdef WITH_BROKER\n\tkeepalive__update(mosq);\n#else\n\tpthread_mutex_lock(&mosq->msgtime_mutex);\n\tmosq->last_msg_in = mosquitto_time();\n\tpthread_mutex_unlock(&mosq->msgtime_mutex);\n#endif\n\treturn rc;\n}\n"], "fixing_code": ["/*\nCopyright (c) 2009-2020 Roger Light <roger@atchoo.org>\n\nAll rights reserved. This program and the accompanying materials\nare made available under the terms of the Eclipse Public License 2.0\nand Eclipse Distribution License v1.0 which accompany this distribution.\n\nThe Eclipse Public License is available at\n   https://www.eclipse.org/legal/epl-2.0/\nand the Eclipse Distribution License is available at\n  http://www.eclipse.org/org/documents/edl-v10.php.\n\nSPDX-License-Identifier: EPL-2.0 OR BSD-3-Clause\n\nContributors:\n   Roger Light - initial implementation and documentation.\n*/\n\n#include \"config.h\"\n\n#include <assert.h>\n#include <errno.h>\n#include <string.h>\n\n#ifdef WITH_BROKER\n#  include \"mosquitto_broker_internal.h\"\n#  ifdef WITH_WEBSOCKETS\n#    include <libwebsockets.h>\n#  endif\n#else\n#  include \"read_handle.h\"\n#endif\n\n#include \"memory_mosq.h\"\n#include \"mqtt_protocol.h\"\n#include \"net_mosq.h\"\n#include \"packet_mosq.h\"\n#include \"read_handle.h\"\n#include \"util_mosq.h\"\n#ifdef WITH_BROKER\n#  include \"sys_tree.h\"\n#  include \"send_mosq.h\"\n#else\n#  define G_BYTES_RECEIVED_INC(A)\n#  define G_BYTES_SENT_INC(A)\n#  define G_MSGS_SENT_INC(A)\n#  define G_PUB_MSGS_SENT_INC(A)\n#endif\n\nint packet__alloc(struct mosquitto__packet *packet)\n{\n\tuint8_t remaining_bytes[5], byte;\n\tuint32_t remaining_length;\n\tint i;\n\n\tassert(packet);\n\n\tremaining_length = packet->remaining_length;\n\tpacket->payload = NULL;\n\tpacket->remaining_count = 0;\n\tdo{\n\t\tbyte = remaining_length % 128;\n\t\tremaining_length = remaining_length / 128;\n\t\t/* If there are more digits to encode, set the top bit of this digit */\n\t\tif(remaining_length > 0){\n\t\t\tbyte = byte | 0x80;\n\t\t}\n\t\tremaining_bytes[packet->remaining_count] = byte;\n\t\tpacket->remaining_count++;\n\t}while(remaining_length > 0 && packet->remaining_count < 5);\n\tif(packet->remaining_count == 5) return MOSQ_ERR_PAYLOAD_SIZE;\n\tpacket->packet_length = packet->remaining_length + 1 + (uint8_t)packet->remaining_count;\n#ifdef WITH_WEBSOCKETS\n\tpacket->payload = mosquitto__malloc(sizeof(uint8_t)*packet->packet_length + LWS_PRE);\n#else\n\tpacket->payload = mosquitto__malloc(sizeof(uint8_t)*packet->packet_length);\n#endif\n\tif(!packet->payload) return MOSQ_ERR_NOMEM;\n\n\tpacket->payload[0] = packet->command;\n\tfor(i=0; i<packet->remaining_count; i++){\n\t\tpacket->payload[i+1] = remaining_bytes[i];\n\t}\n\tpacket->pos = 1U + (uint8_t)packet->remaining_count;\n\n\treturn MOSQ_ERR_SUCCESS;\n}\n\nvoid packet__cleanup(struct mosquitto__packet *packet)\n{\n\tif(!packet) return;\n\n\t/* Free data and reset values */\n\tpacket->command = 0;\n\tpacket->remaining_count = 0;\n\tpacket->remaining_mult = 1;\n\tpacket->remaining_length = 0;\n\tmosquitto__free(packet->payload);\n\tpacket->payload = NULL;\n\tpacket->to_process = 0;\n\tpacket->pos = 0;\n}\n\n\nvoid packet__cleanup_all_no_locks(struct mosquitto *mosq)\n{\n\tstruct mosquitto__packet *packet;\n\n\t/* Out packet cleanup */\n\tif(mosq->out_packet && !mosq->current_out_packet){\n\t\tmosq->current_out_packet = mosq->out_packet;\n\t\tmosq->out_packet = mosq->out_packet->next;\n\t}\n\twhile(mosq->current_out_packet){\n\t\tpacket = mosq->current_out_packet;\n\t\t/* Free data and reset values */\n\t\tmosq->current_out_packet = mosq->out_packet;\n\t\tif(mosq->out_packet){\n\t\t\tmosq->out_packet = mosq->out_packet->next;\n\t\t}\n\n\t\tpacket__cleanup(packet);\n\t\tmosquitto__free(packet);\n\t}\n\n\tpacket__cleanup(&mosq->in_packet);\n}\n\nvoid packet__cleanup_all(struct mosquitto *mosq)\n{\n\tpthread_mutex_lock(&mosq->current_out_packet_mutex);\n\tpthread_mutex_lock(&mosq->out_packet_mutex);\n\n\tpacket__cleanup_all_no_locks(mosq);\n\n\tpthread_mutex_unlock(&mosq->out_packet_mutex);\n\tpthread_mutex_unlock(&mosq->current_out_packet_mutex);\n}\n\n\nint packet__queue(struct mosquitto *mosq, struct mosquitto__packet *packet)\n{\n#ifndef WITH_BROKER\n\tchar sockpair_data = 0;\n#endif\n\tassert(mosq);\n\tassert(packet);\n\n\tpacket->pos = 0;\n\tpacket->to_process = packet->packet_length;\n\n\tpacket->next = NULL;\n\tpthread_mutex_lock(&mosq->out_packet_mutex);\n\tif(mosq->out_packet){\n\t\tmosq->out_packet_last->next = packet;\n\t}else{\n\t\tmosq->out_packet = packet;\n\t}\n\tmosq->out_packet_last = packet;\n\tpthread_mutex_unlock(&mosq->out_packet_mutex);\n#ifdef WITH_BROKER\n#  ifdef WITH_WEBSOCKETS\n\tif(mosq->wsi){\n\t\tlws_callback_on_writable(mosq->wsi);\n\t\treturn MOSQ_ERR_SUCCESS;\n\t}else{\n\t\treturn packet__write(mosq);\n\t}\n#  else\n\treturn packet__write(mosq);\n#  endif\n#else\n\n\t/* Write a single byte to sockpairW (connected to sockpairR) to break out\n\t * of select() if in threaded mode. */\n\tif(mosq->sockpairW != INVALID_SOCKET){\n#ifndef WIN32\n\t\tif(write(mosq->sockpairW, &sockpair_data, 1)){\n\t\t}\n#else\n\t\tsend(mosq->sockpairW, &sockpair_data, 1, 0);\n#endif\n\t}\n\n\tif(mosq->in_callback == false && mosq->threaded == mosq_ts_none){\n\t\treturn packet__write(mosq);\n\t}else{\n\t\treturn MOSQ_ERR_SUCCESS;\n\t}\n#endif\n}\n\n\nint packet__check_oversize(struct mosquitto *mosq, uint32_t remaining_length)\n{\n\tuint32_t len;\n\n\tif(mosq->maximum_packet_size == 0) return MOSQ_ERR_SUCCESS;\n\n\tlen = remaining_length + packet__varint_bytes(remaining_length);\n\tif(len > mosq->maximum_packet_size){\n\t\treturn MOSQ_ERR_OVERSIZE_PACKET;\n\t}else{\n\t\treturn MOSQ_ERR_SUCCESS;\n\t}\n}\n\n\nint packet__write(struct mosquitto *mosq)\n{\n\tssize_t write_length;\n\tstruct mosquitto__packet *packet;\n\tenum mosquitto_client_state state;\n\n\tif(!mosq) return MOSQ_ERR_INVAL;\n\tif(mosq->sock == INVALID_SOCKET) return MOSQ_ERR_NO_CONN;\n\n#ifdef WITH_BROKER\n\tif (mosq->current_out_packet) {\n\t   mux__add_out(mosq);\n\t}\n#endif\n\n\tpthread_mutex_lock(&mosq->current_out_packet_mutex);\n\tpthread_mutex_lock(&mosq->out_packet_mutex);\n\tif(mosq->out_packet && !mosq->current_out_packet){\n\t\tmosq->current_out_packet = mosq->out_packet;\n\t\tmosq->out_packet = mosq->out_packet->next;\n\t\tif(!mosq->out_packet){\n\t\t\tmosq->out_packet_last = NULL;\n\t\t}\n\t}\n\tpthread_mutex_unlock(&mosq->out_packet_mutex);\n\n\tstate = mosquitto__get_state(mosq);\n#if defined(WITH_TLS) && !defined(WITH_BROKER)\n\tif(state == mosq_cs_connect_pending || mosq->want_connect){\n#else\n\tif(state == mosq_cs_connect_pending){\n#endif\n\t\tpthread_mutex_unlock(&mosq->current_out_packet_mutex);\n\t\treturn MOSQ_ERR_SUCCESS;\n\t}\n\n\twhile(mosq->current_out_packet){\n\t\tpacket = mosq->current_out_packet;\n\n\t\twhile(packet->to_process > 0){\n\t\t\twrite_length = net__write(mosq, &(packet->payload[packet->pos]), packet->to_process);\n\t\t\tif(write_length > 0){\n\t\t\t\tG_BYTES_SENT_INC(write_length);\n\t\t\t\tpacket->to_process -= (uint32_t)write_length;\n\t\t\t\tpacket->pos += (uint32_t)write_length;\n\t\t\t}else{\n#ifdef WIN32\n\t\t\t\terrno = WSAGetLastError();\n#endif\n\t\t\t\tif(errno == EAGAIN || errno == COMPAT_EWOULDBLOCK\n#ifdef WIN32\n\t\t\t\t\t\t|| errno == WSAENOTCONN\n#endif\n\t\t\t\t\t\t){\n\t\t\t\t\tpthread_mutex_unlock(&mosq->current_out_packet_mutex);\n\t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n\t\t\t\t}else{\n\t\t\t\t\tpthread_mutex_unlock(&mosq->current_out_packet_mutex);\n\t\t\t\t\tswitch(errno){\n\t\t\t\t\t\tcase COMPAT_ECONNRESET:\n\t\t\t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n\t\t\t\t\t\tcase COMPAT_EINTR:\n\t\t\t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn MOSQ_ERR_ERRNO;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tG_MSGS_SENT_INC(1);\n\t\tif(((packet->command)&0xF6) == CMD_PUBLISH){\n\t\t\tG_PUB_MSGS_SENT_INC(1);\n#ifndef WITH_BROKER\n\t\t\tpthread_mutex_lock(&mosq->callback_mutex);\n\t\t\tif(mosq->on_publish){\n\t\t\t\t/* This is a QoS=0 message */\n\t\t\t\tmosq->in_callback = true;\n\t\t\t\tmosq->on_publish(mosq, mosq->userdata, packet->mid);\n\t\t\t\tmosq->in_callback = false;\n\t\t\t}\n\t\t\tif(mosq->on_publish_v5){\n\t\t\t\t/* This is a QoS=0 message */\n\t\t\t\tmosq->in_callback = true;\n\t\t\t\tmosq->on_publish_v5(mosq, mosq->userdata, packet->mid, 0, NULL);\n\t\t\t\tmosq->in_callback = false;\n\t\t\t}\n\t\t\tpthread_mutex_unlock(&mosq->callback_mutex);\n\t\t}else if(((packet->command)&0xF0) == CMD_DISCONNECT){\n\t\t\tdo_client_disconnect(mosq, MOSQ_ERR_SUCCESS, NULL);\n\t\t\tpacket__cleanup(packet);\n\t\t\tmosquitto__free(packet);\n\t\t\treturn MOSQ_ERR_SUCCESS;\n#endif\n\t\t}else if(((packet->command)&0xF0) == CMD_PUBLISH){\n\t\t\tG_PUB_MSGS_SENT_INC(1);\n\t\t}\n\n\t\t/* Free data and reset values */\n\t\tpthread_mutex_lock(&mosq->out_packet_mutex);\n\t\tmosq->current_out_packet = mosq->out_packet;\n\t\tif(mosq->out_packet){\n\t\t\tmosq->out_packet = mosq->out_packet->next;\n\t\t\tif(!mosq->out_packet){\n\t\t\t\tmosq->out_packet_last = NULL;\n\t\t\t}\n\t\t}\n\t\tpthread_mutex_unlock(&mosq->out_packet_mutex);\n\n\t\tpacket__cleanup(packet);\n\t\tmosquitto__free(packet);\n\n#ifdef WITH_BROKER\n\t\tmosq->next_msg_out = db.now_s + mosq->keepalive;\n\t\tif(mosq->current_out_packet == NULL){\n\t\t\tmux__remove_out(mosq);\n\t\t}\n#else\n\t\tpthread_mutex_lock(&mosq->msgtime_mutex);\n\t\tmosq->next_msg_out = mosquitto_time() + mosq->keepalive;\n\t\tpthread_mutex_unlock(&mosq->msgtime_mutex);\n#endif\n\t}\n\tpthread_mutex_unlock(&mosq->current_out_packet_mutex);\n\treturn MOSQ_ERR_SUCCESS;\n}\n\n\nint packet__read(struct mosquitto *mosq)\n{\n\tuint8_t byte;\n\tssize_t read_length;\n\tint rc = 0;\n\tenum mosquitto_client_state state;\n\n\tif(!mosq){\n\t\treturn MOSQ_ERR_INVAL;\n\t}\n\tif(mosq->sock == INVALID_SOCKET){\n\t\treturn MOSQ_ERR_NO_CONN;\n\t}\n\n\tstate = mosquitto__get_state(mosq);\n\tif(state == mosq_cs_connect_pending){\n\t\treturn MOSQ_ERR_SUCCESS;\n\t}\n\n\t/* This gets called if pselect() indicates that there is network data\n\t * available - ie. at least one byte.  What we do depends on what data we\n\t * already have.\n\t * If we've not got a command, attempt to read one and save it. This should\n\t * always work because it's only a single byte.\n\t * Then try to read the remaining length. This may fail because it is may\n\t * be more than one byte - will need to save data pending next read if it\n\t * does fail.\n\t * Then try to read the remaining payload, where 'payload' here means the\n\t * combined variable header and actual payload. This is the most likely to\n\t * fail due to longer length, so save current data and current position.\n\t * After all data is read, send to mosquitto__handle_packet() to deal with.\n\t * Finally, free the memory and reset everything to starting conditions.\n\t */\n\tif(!mosq->in_packet.command){\n\t\tread_length = net__read(mosq, &byte, 1);\n\t\tif(read_length == 1){\n\t\t\tmosq->in_packet.command = byte;\n#ifdef WITH_BROKER\n\t\t\tG_BYTES_RECEIVED_INC(1);\n\t\t\t/* Clients must send CONNECT as their first command. */\n\t\t\tif(!(mosq->bridge) && state == mosq_cs_connected && (byte&0xF0) != CMD_CONNECT){\n\t\t\t\treturn MOSQ_ERR_PROTOCOL;\n\t\t\t}\n#endif\n\t\t}else{\n\t\t\tif(read_length == 0){\n\t\t\t\treturn MOSQ_ERR_CONN_LOST; /* EOF */\n\t\t\t}\n#ifdef WIN32\n\t\t\terrno = WSAGetLastError();\n#endif\n\t\t\tif(errno == EAGAIN || errno == COMPAT_EWOULDBLOCK){\n\t\t\t\treturn MOSQ_ERR_SUCCESS;\n\t\t\t}else{\n\t\t\t\tswitch(errno){\n\t\t\t\t\tcase COMPAT_ECONNRESET:\n\t\t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n\t\t\t\t\tcase COMPAT_EINTR:\n\t\t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn MOSQ_ERR_ERRNO;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t/* remaining_count is the number of bytes that the remaining_length\n\t * parameter occupied in this incoming packet. We don't use it here as such\n\t * (it is used when allocating an outgoing packet), but we must be able to\n\t * determine whether all of the remaining_length parameter has been read.\n\t * remaining_count has three states here:\n\t *   0 means that we haven't read any remaining_length bytes\n\t *   <0 means we have read some remaining_length bytes but haven't finished\n\t *   >0 means we have finished reading the remaining_length bytes.\n\t */\n\tif(mosq->in_packet.remaining_count <= 0){\n\t\tdo{\n\t\t\tread_length = net__read(mosq, &byte, 1);\n\t\t\tif(read_length == 1){\n\t\t\t\tmosq->in_packet.remaining_count--;\n\t\t\t\t/* Max 4 bytes length for remaining length as defined by protocol.\n\t\t\t\t * Anything more likely means a broken/malicious client.\n\t\t\t\t */\n\t\t\t\tif(mosq->in_packet.remaining_count < -4){\n\t\t\t\t\treturn MOSQ_ERR_PROTOCOL;\n\t\t\t\t}\n\n\t\t\t\tG_BYTES_RECEIVED_INC(1);\n\t\t\t\tmosq->in_packet.remaining_length += (byte & 127) * mosq->in_packet.remaining_mult;\n\t\t\t\tmosq->in_packet.remaining_mult *= 128;\n\t\t\t}else{\n\t\t\t\tif(read_length == 0){\n\t\t\t\t\treturn MOSQ_ERR_CONN_LOST; /* EOF */\n\t\t\t\t}\n#ifdef WIN32\n\t\t\t\terrno = WSAGetLastError();\n#endif\n\t\t\t\tif(errno == EAGAIN || errno == COMPAT_EWOULDBLOCK){\n\t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n\t\t\t\t}else{\n\t\t\t\t\tswitch(errno){\n\t\t\t\t\t\tcase COMPAT_ECONNRESET:\n\t\t\t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n\t\t\t\t\t\tcase COMPAT_EINTR:\n\t\t\t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn MOSQ_ERR_ERRNO;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}while((byte & 128) != 0);\n\t\t/* We have finished reading remaining_length, so make remaining_count\n\t\t * positive. */\n\t\tmosq->in_packet.remaining_count = (int8_t)(mosq->in_packet.remaining_count * -1);\n\n#ifdef WITH_BROKER\n\t\tif(db.config->max_packet_size > 0 && mosq->in_packet.remaining_length+1 > db.config->max_packet_size){\n\t\t\tif(mosq->protocol == mosq_p_mqtt5){\n\t\t\t\tsend__disconnect(mosq, MQTT_RC_PACKET_TOO_LARGE, NULL);\n\t\t\t}\n\t\t\treturn MOSQ_ERR_OVERSIZE_PACKET;\n\t\t}\n#else\n\t\t// FIXME - client case for incoming message received from broker too large\n#endif\n\t\tif(mosq->in_packet.remaining_length > 0){\n\t\t\tmosq->in_packet.payload = mosquitto__malloc(mosq->in_packet.remaining_length*sizeof(uint8_t));\n\t\t\tif(!mosq->in_packet.payload){\n\t\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t\t}\n\t\t\tmosq->in_packet.to_process = mosq->in_packet.remaining_length;\n\t\t}\n\t}\n\twhile(mosq->in_packet.to_process>0){\n\t\tread_length = net__read(mosq, &(mosq->in_packet.payload[mosq->in_packet.pos]), mosq->in_packet.to_process);\n\t\tif(read_length > 0){\n\t\t\tG_BYTES_RECEIVED_INC(read_length);\n\t\t\tmosq->in_packet.to_process -= (uint32_t)read_length;\n\t\t\tmosq->in_packet.pos += (uint32_t)read_length;\n\t\t}else{\n#ifdef WIN32\n\t\t\terrno = WSAGetLastError();\n#endif\n\t\t\tif(errno == EAGAIN || errno == COMPAT_EWOULDBLOCK){\n\t\t\t\tif(mosq->in_packet.to_process > 1000){\n\t\t\t\t\t/* Update last_msg_in time if more than 1000 bytes left to\n\t\t\t\t\t * receive. Helps when receiving large messages.\n\t\t\t\t\t * This is an arbitrary limit, but with some consideration.\n\t\t\t\t\t * If a client can't send 1000 bytes in a second it\n\t\t\t\t\t * probably shouldn't be using a 1 second keep alive. */\n#ifdef WITH_BROKER\n\t\t\t\t\tkeepalive__update(mosq);\n#else\n\t\t\t\t\tpthread_mutex_lock(&mosq->msgtime_mutex);\n\t\t\t\t\tmosq->last_msg_in = mosquitto_time();\n\t\t\t\t\tpthread_mutex_unlock(&mosq->msgtime_mutex);\n#endif\n\t\t\t\t}\n\t\t\t\treturn MOSQ_ERR_SUCCESS;\n\t\t\t}else{\n\t\t\t\tswitch(errno){\n\t\t\t\t\tcase COMPAT_ECONNRESET:\n\t\t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n\t\t\t\t\tcase COMPAT_EINTR:\n\t\t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn MOSQ_ERR_ERRNO;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* All data for this packet is read. */\n\tmosq->in_packet.pos = 0;\n#ifdef WITH_BROKER\n\tG_MSGS_RECEIVED_INC(1);\n\tif(((mosq->in_packet.command)&0xF5) == CMD_PUBLISH){\n\t\tG_PUB_MSGS_RECEIVED_INC(1);\n\t}\n#endif\n\trc = handle__packet(mosq);\n\n\t/* Free data and reset values */\n\tpacket__cleanup(&mosq->in_packet);\n\n#ifdef WITH_BROKER\n\tkeepalive__update(mosq);\n#else\n\tpthread_mutex_lock(&mosq->msgtime_mutex);\n\tmosq->last_msg_in = mosquitto_time();\n\tpthread_mutex_unlock(&mosq->msgtime_mutex);\n#endif\n\treturn rc;\n}\n"], "filenames": ["lib/packet_mosq.c"], "buggy_code_start_loc": [219], "buggy_code_end_loc": [220], "fixing_code_start_loc": [219], "fixing_code_end_loc": [222], "type": "CWE-834", "message": "In Eclipse Mosquito before and including 2.0.5, establishing a connection to the mosquitto server without sending data causes the EPOLLOUT event to be added, which results excessive CPU consumption. This could be used by a malicious actor to perform denial of service type attack. This issue is fixed in 2.0.6\n\n\n", "other": {"cve": {"id": "CVE-2023-5632", "sourceIdentifier": "emo@eclipse.org", "published": "2023-10-18T09:15:10.080", "lastModified": "2023-10-25T17:32:13.007", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In Eclipse Mosquito before and including 2.0.5, establishing a connection to the mosquitto server without sending data causes the EPOLLOUT event to be added, which results excessive CPU consumption. This could be used by a malicious actor to perform denial of service type attack. This issue is fixed in 2.0.6\n\n\n"}, {"lang": "es", "value": "En Eclipse Mosquito anterior a 2.0.5 incluida, establecer una conexi\u00f3n con el servidor mosquitto sin enviar datos provoca que se agregue el evento EPOLLOUT, lo que resulta en un consumo excesivo de CPU. Esto podr\u00eda ser utilizado por un actor malintencionado para realizar un ataque de tipo de denegaci\u00f3n de servicio. Este problema se solucion\u00f3 en 2.0.6."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "emo@eclipse.org", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-834"}]}, {"source": "emo@eclipse.org", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-834"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:eclipse:mosquitto:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.0.6", "matchCriteriaId": "A9ACA0BE-573B-4295-9390-F88687C64298"}]}]}], "references": [{"url": "https://github.com/eclipse/mosquitto/commit/18bad1ff32435e523d7507e9b2ce0010124a8f2d", "source": "emo@eclipse.org", "tags": ["Patch"]}, {"url": "https://github.com/eclipse/mosquitto/pull/2053", "source": "emo@eclipse.org", "tags": ["Issue Tracking"]}]}, "github_commit_url": "https://github.com/eclipse/mosquitto/commit/18bad1ff32435e523d7507e9b2ce0010124a8f2d"}}