{"buggy_code": ["/* \n\tpcd.c\t(c) 1997-8  Grant R. Guenther <grant@torque.net>\n\t\t            Under the terms of the GNU General Public License.\n\n\tThis is a high-level driver for parallel port ATAPI CD-ROM\n        drives based on chips supported by the paride module.\n\n        By default, the driver will autoprobe for a single parallel\n        port ATAPI CD-ROM drive, but if their individual parameters are\n        specified, the driver can handle up to 4 drives.\n\n        The behaviour of the pcd driver can be altered by setting\n        some parameters from the insmod command line.  The following\n        parameters are adjustable:\n\n            drive0      These four arguments can be arrays of       \n            drive1      1-6 integers as follows:\n            drive2\n            drive3      <prt>,<pro>,<uni>,<mod>,<slv>,<dly>\n\n                        Where,\n\n                <prt>   is the base of the parallel port address for\n                        the corresponding drive.  (required)\n\n                <pro>   is the protocol number for the adapter that\n                        supports this drive.  These numbers are\n                        logged by 'paride' when the protocol modules\n                        are initialised.  (0 if not given)\n\n                <uni>   for those adapters that support chained\n                        devices, this is the unit selector for the\n                        chain of devices on the given port.  It should\n                        be zero for devices that don't support chaining.\n                        (0 if not given)\n\n                <mod>   this can be -1 to choose the best mode, or one\n                        of the mode numbers supported by the adapter.\n                        (-1 if not given)\n\n\t\t<slv>   ATAPI CD-ROMs can be jumpered to master or slave.\n\t\t\tSet this to 0 to choose the master drive, 1 to\n                        choose the slave, -1 (the default) to choose the\n\t\t\tfirst drive found.\n\n                <dly>   some parallel ports require the driver to \n                        go more slowly.  -1 sets a default value that\n                        should work with the chosen protocol.  Otherwise,\n                        set this to a small integer, the larger it is\n                        the slower the port i/o.  In some cases, setting\n                        this to zero will speed up the device. (default -1)\n                        \n            major       You may use this parameter to override the\n                        default major number (46) that this driver\n                        will use.  Be sure to change the device\n                        name as well.\n\n            name        This parameter is a character string that\n                        contains the name the kernel will use for this\n                        device (in /proc output, for instance).\n                        (default \"pcd\")\n\n            verbose     This parameter controls the amount of logging\n                        that the driver will do.  Set it to 0 for\n                        normal operation, 1 to see autoprobe progress\n                        messages, or 2 to see additional debugging\n                        output.  (default 0)\n  \n            nice        This parameter controls the driver's use of\n                        idle CPU time, at the expense of some speed.\n \n\tIf this driver is built into the kernel, you can use the\n        following kernel command line parameters, with the same values\n        as the corresponding module parameters listed above:\n\n\t    pcd.drive0\n\t    pcd.drive1\n\t    pcd.drive2\n\t    pcd.drive3\n\t    pcd.nice\n\n        In addition, you can use the parameter pcd.disable to disable\n        the driver entirely.\n\n*/\n\n/* Changes:\n\n\t1.01\tGRG 1998.01.24\tAdded test unit ready support\n\t1.02    GRG 1998.05.06  Changes to pcd_completion, ready_wait,\n\t\t\t\tand loosen interpretation of ATAPI\n\t\t\t        standard for clearing error status.\n\t\t\t\tUse spinlocks. Eliminate sti().\n\t1.03    GRG 1998.06.16  Eliminated an Ugh\n\t1.04\tGRG 1998.08.15  Added extra debugging, improvements to\n\t\t\t\tpcd_completion, use HZ in loop timing\n\t1.05\tGRG 1998.08.16\tConformed to \"Uniform CD-ROM\" standard\n\t1.06    GRG 1998.08.19  Added audio ioctl support\n\t1.07    GRG 1998.09.24  Increased reset timeout, added jumbo support\n\n*/\n\n#define\tPCD_VERSION\t\"1.07\"\n#define PCD_MAJOR\t46\n#define PCD_NAME\t\"pcd\"\n#define PCD_UNITS\t4\n\n/* Here are things one can override from the insmod command.\n   Most are autoprobed by paride unless set here.  Verbose is off\n   by default.\n\n*/\n\nstatic int verbose = 0;\nstatic int major = PCD_MAJOR;\nstatic char *name = PCD_NAME;\nstatic int nice = 0;\nstatic int disable = 0;\n\nstatic int drive0[6] = { 0, 0, 0, -1, -1, -1 };\nstatic int drive1[6] = { 0, 0, 0, -1, -1, -1 };\nstatic int drive2[6] = { 0, 0, 0, -1, -1, -1 };\nstatic int drive3[6] = { 0, 0, 0, -1, -1, -1 };\n\nstatic int (*drives[4])[6] = {&drive0, &drive1, &drive2, &drive3};\nstatic int pcd_drive_count;\n\nenum {D_PRT, D_PRO, D_UNI, D_MOD, D_SLV, D_DLY};\n\n/* end of parameters */\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/cdrom.h>\n#include <linux/spinlock.h>\n#include <linux/blk-mq.h>\n#include <linux/mutex.h>\n#include <linux/uaccess.h>\n\nstatic DEFINE_MUTEX(pcd_mutex);\nstatic DEFINE_SPINLOCK(pcd_lock);\n\nmodule_param(verbose, int, 0644);\nmodule_param(major, int, 0);\nmodule_param(name, charp, 0);\nmodule_param(nice, int, 0);\nmodule_param_array(drive0, int, NULL, 0);\nmodule_param_array(drive1, int, NULL, 0);\nmodule_param_array(drive2, int, NULL, 0);\nmodule_param_array(drive3, int, NULL, 0);\n\n#include \"paride.h\"\n#include \"pseudo.h\"\n\n#define PCD_RETRIES\t     5\n#define PCD_TMO\t\t   800\t/* timeout in jiffies */\n#define PCD_DELAY           50\t/* spin delay in uS */\n#define PCD_READY_TMO\t    20\t/* in seconds */\n#define PCD_RESET_TMO\t   100\t/* in tenths of a second */\n\n#define PCD_SPIN\t(1000000*PCD_TMO)/(HZ*PCD_DELAY)\n\n#define IDE_ERR\t\t0x01\n#define IDE_DRQ         0x08\n#define IDE_READY       0x40\n#define IDE_BUSY        0x80\n\nstatic int pcd_open(struct cdrom_device_info *cdi, int purpose);\nstatic void pcd_release(struct cdrom_device_info *cdi);\nstatic int pcd_drive_status(struct cdrom_device_info *cdi, int slot_nr);\nstatic unsigned int pcd_check_events(struct cdrom_device_info *cdi,\n\t\t\t\t     unsigned int clearing, int slot_nr);\nstatic int pcd_tray_move(struct cdrom_device_info *cdi, int position);\nstatic int pcd_lock_door(struct cdrom_device_info *cdi, int lock);\nstatic int pcd_drive_reset(struct cdrom_device_info *cdi);\nstatic int pcd_get_mcn(struct cdrom_device_info *cdi, struct cdrom_mcn *mcn);\nstatic int pcd_audio_ioctl(struct cdrom_device_info *cdi,\n\t\t\t   unsigned int cmd, void *arg);\nstatic int pcd_packet(struct cdrom_device_info *cdi,\n\t\t      struct packet_command *cgc);\n\nstatic int pcd_detect(void);\nstatic void pcd_probe_capabilities(void);\nstatic void do_pcd_read_drq(void);\nstatic blk_status_t pcd_queue_rq(struct blk_mq_hw_ctx *hctx,\n\t\t\t\t const struct blk_mq_queue_data *bd);\nstatic void do_pcd_read(void);\n\nstruct pcd_unit {\n\tstruct pi_adapter pia;\t/* interface to paride layer */\n\tstruct pi_adapter *pi;\n\tint drive;\t\t/* master/slave */\n\tint last_sense;\t\t/* result of last request sense */\n\tint changed;\t\t/* media change seen */\n\tint present;\t\t/* does this unit exist ? */\n\tchar *name;\t\t/* pcd0, pcd1, etc */\n\tstruct cdrom_device_info info;\t/* uniform cdrom interface */\n\tstruct gendisk *disk;\n\tstruct blk_mq_tag_set tag_set;\n\tstruct list_head rq_list;\n};\n\nstatic struct pcd_unit pcd[PCD_UNITS];\n\nstatic char pcd_scratch[64];\nstatic char pcd_buffer[2048];\t/* raw block buffer */\nstatic int pcd_bufblk = -1;\t/* block in buffer, in CD units,\n\t\t\t\t   -1 for nothing there. See also\n\t\t\t\t   pd_unit.\n\t\t\t\t */\n\n/* the variables below are used mainly in the I/O request engine, which\n   processes only one request at a time.\n*/\n\nstatic struct pcd_unit *pcd_current; /* current request's drive */\nstatic struct request *pcd_req;\nstatic int pcd_retries;\t\t/* retries on current request */\nstatic int pcd_busy;\t\t/* request being processed ? */\nstatic int pcd_sector;\t\t/* address of next requested sector */\nstatic int pcd_count;\t\t/* number of blocks still to do */\nstatic char *pcd_buf;\t\t/* buffer for request in progress */\nstatic void *par_drv;\t\t/* reference of parport driver */\n\n/* kernel glue structures */\n\nstatic int pcd_block_open(struct block_device *bdev, fmode_t mode)\n{\n\tstruct pcd_unit *cd = bdev->bd_disk->private_data;\n\tint ret;\n\n\tcheck_disk_change(bdev);\n\n\tmutex_lock(&pcd_mutex);\n\tret = cdrom_open(&cd->info, bdev, mode);\n\tmutex_unlock(&pcd_mutex);\n\n\treturn ret;\n}\n\nstatic void pcd_block_release(struct gendisk *disk, fmode_t mode)\n{\n\tstruct pcd_unit *cd = disk->private_data;\n\tmutex_lock(&pcd_mutex);\n\tcdrom_release(&cd->info, mode);\n\tmutex_unlock(&pcd_mutex);\n}\n\nstatic int pcd_block_ioctl(struct block_device *bdev, fmode_t mode,\n\t\t\t\tunsigned cmd, unsigned long arg)\n{\n\tstruct pcd_unit *cd = bdev->bd_disk->private_data;\n\tint ret;\n\n\tmutex_lock(&pcd_mutex);\n\tret = cdrom_ioctl(&cd->info, bdev, mode, cmd, arg);\n\tmutex_unlock(&pcd_mutex);\n\n\treturn ret;\n}\n\nstatic unsigned int pcd_block_check_events(struct gendisk *disk,\n\t\t\t\t\t   unsigned int clearing)\n{\n\tstruct pcd_unit *cd = disk->private_data;\n\treturn cdrom_check_events(&cd->info, clearing);\n}\n\nstatic const struct block_device_operations pcd_bdops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= pcd_block_open,\n\t.release\t= pcd_block_release,\n\t.ioctl\t\t= pcd_block_ioctl,\n\t.check_events\t= pcd_block_check_events,\n};\n\nstatic const struct cdrom_device_ops pcd_dops = {\n\t.open\t\t= pcd_open,\n\t.release\t= pcd_release,\n\t.drive_status\t= pcd_drive_status,\n\t.check_events\t= pcd_check_events,\n\t.tray_move\t= pcd_tray_move,\n\t.lock_door\t= pcd_lock_door,\n\t.get_mcn\t= pcd_get_mcn,\n\t.reset\t\t= pcd_drive_reset,\n\t.audio_ioctl\t= pcd_audio_ioctl,\n\t.generic_packet\t= pcd_packet,\n\t.capability\t= CDC_CLOSE_TRAY | CDC_OPEN_TRAY | CDC_LOCK |\n\t\t\t  CDC_MCN | CDC_MEDIA_CHANGED | CDC_RESET |\n\t\t\t  CDC_PLAY_AUDIO | CDC_GENERIC_PACKET | CDC_CD_R |\n\t\t\t  CDC_CD_RW,\n};\n\nstatic const struct blk_mq_ops pcd_mq_ops = {\n\t.queue_rq\t= pcd_queue_rq,\n};\n\nstatic void pcd_init_units(void)\n{\n\tstruct pcd_unit *cd;\n\tint unit;\n\n\tpcd_drive_count = 0;\n\tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {\n\t\tstruct gendisk *disk = alloc_disk(1);\n\n\t\tif (!disk)\n\t\t\tcontinue;\n\n\t\tdisk->queue = blk_mq_init_sq_queue(&cd->tag_set, &pcd_mq_ops,\n\t\t\t\t\t\t   1, BLK_MQ_F_SHOULD_MERGE);\n\t\tif (IS_ERR(disk->queue)) {\n\t\t\tdisk->queue = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\tINIT_LIST_HEAD(&cd->rq_list);\n\t\tdisk->queue->queuedata = cd;\n\t\tblk_queue_bounce_limit(disk->queue, BLK_BOUNCE_HIGH);\n\t\tcd->disk = disk;\n\t\tcd->pi = &cd->pia;\n\t\tcd->present = 0;\n\t\tcd->last_sense = 0;\n\t\tcd->changed = 1;\n\t\tcd->drive = (*drives[unit])[D_SLV];\n\t\tif ((*drives[unit])[D_PRT])\n\t\t\tpcd_drive_count++;\n\n\t\tcd->name = &cd->info.name[0];\n\t\tsnprintf(cd->name, sizeof(cd->info.name), \"%s%d\", name, unit);\n\t\tcd->info.ops = &pcd_dops;\n\t\tcd->info.handle = cd;\n\t\tcd->info.speed = 0;\n\t\tcd->info.capacity = 1;\n\t\tcd->info.mask = 0;\n\t\tdisk->major = major;\n\t\tdisk->first_minor = unit;\n\t\tstrcpy(disk->disk_name, cd->name);\t/* umm... */\n\t\tdisk->fops = &pcd_bdops;\n\t\tdisk->flags = GENHD_FL_BLOCK_EVENTS_ON_EXCL_WRITE;\n\t}\n}\n\nstatic int pcd_open(struct cdrom_device_info *cdi, int purpose)\n{\n\tstruct pcd_unit *cd = cdi->handle;\n\tif (!cd->present)\n\t\treturn -ENODEV;\n\treturn 0;\n}\n\nstatic void pcd_release(struct cdrom_device_info *cdi)\n{\n}\n\nstatic inline int status_reg(struct pcd_unit *cd)\n{\n\treturn pi_read_regr(cd->pi, 1, 6);\n}\n\nstatic inline int read_reg(struct pcd_unit *cd, int reg)\n{\n\treturn pi_read_regr(cd->pi, 0, reg);\n}\n\nstatic inline void write_reg(struct pcd_unit *cd, int reg, int val)\n{\n\tpi_write_regr(cd->pi, 0, reg, val);\n}\n\nstatic int pcd_wait(struct pcd_unit *cd, int go, int stop, char *fun, char *msg)\n{\n\tint j, r, e, s, p;\n\n\tj = 0;\n\twhile ((((r = status_reg(cd)) & go) || (stop && (!(r & stop))))\n\t       && (j++ < PCD_SPIN))\n\t\tudelay(PCD_DELAY);\n\n\tif ((r & (IDE_ERR & stop)) || (j > PCD_SPIN)) {\n\t\ts = read_reg(cd, 7);\n\t\te = read_reg(cd, 1);\n\t\tp = read_reg(cd, 2);\n\t\tif (j > PCD_SPIN)\n\t\t\te |= 0x100;\n\t\tif (fun)\n\t\t\tprintk(\"%s: %s %s: alt=0x%x stat=0x%x err=0x%x\"\n\t\t\t       \" loop=%d phase=%d\\n\",\n\t\t\t       cd->name, fun, msg, r, s, e, j, p);\n\t\treturn (s << 8) + r;\n\t}\n\treturn 0;\n}\n\nstatic int pcd_command(struct pcd_unit *cd, char *cmd, int dlen, char *fun)\n{\n\tpi_connect(cd->pi);\n\n\twrite_reg(cd, 6, 0xa0 + 0x10 * cd->drive);\n\n\tif (pcd_wait(cd, IDE_BUSY | IDE_DRQ, 0, fun, \"before command\")) {\n\t\tpi_disconnect(cd->pi);\n\t\treturn -1;\n\t}\n\n\twrite_reg(cd, 4, dlen % 256);\n\twrite_reg(cd, 5, dlen / 256);\n\twrite_reg(cd, 7, 0xa0);\t/* ATAPI packet command */\n\n\tif (pcd_wait(cd, IDE_BUSY, IDE_DRQ, fun, \"command DRQ\")) {\n\t\tpi_disconnect(cd->pi);\n\t\treturn -1;\n\t}\n\n\tif (read_reg(cd, 2) != 1) {\n\t\tprintk(\"%s: %s: command phase error\\n\", cd->name, fun);\n\t\tpi_disconnect(cd->pi);\n\t\treturn -1;\n\t}\n\n\tpi_write_block(cd->pi, cmd, 12);\n\n\treturn 0;\n}\n\nstatic int pcd_completion(struct pcd_unit *cd, char *buf, char *fun)\n{\n\tint r, d, p, n, k, j;\n\n\tr = -1;\n\tk = 0;\n\tj = 0;\n\n\tif (!pcd_wait(cd, IDE_BUSY, IDE_DRQ | IDE_READY | IDE_ERR,\n\t\t      fun, \"completion\")) {\n\t\tr = 0;\n\t\twhile (read_reg(cd, 7) & IDE_DRQ) {\n\t\t\td = read_reg(cd, 4) + 256 * read_reg(cd, 5);\n\t\t\tn = (d + 3) & 0xfffc;\n\t\t\tp = read_reg(cd, 2) & 3;\n\n\t\t\tif ((p == 2) && (n > 0) && (j == 0)) {\n\t\t\t\tpi_read_block(cd->pi, buf, n);\n\t\t\t\tif (verbose > 1)\n\t\t\t\t\tprintk(\"%s: %s: Read %d bytes\\n\",\n\t\t\t\t\t       cd->name, fun, n);\n\t\t\t\tr = 0;\n\t\t\t\tj++;\n\t\t\t} else {\n\t\t\t\tif (verbose > 1)\n\t\t\t\t\tprintk\n\t\t\t\t\t    (\"%s: %s: Unexpected phase %d, d=%d, k=%d\\n\",\n\t\t\t\t\t     cd->name, fun, p, d, k);\n\t\t\t\tif (verbose < 2)\n\t\t\t\t\tprintk_once(\n\t\t\t\t\t    \"%s: WARNING: ATAPI phase errors\\n\",\n\t\t\t\t\t    cd->name);\n\t\t\t\tmdelay(1);\n\t\t\t}\n\t\t\tif (k++ > PCD_TMO) {\n\t\t\t\tprintk(\"%s: Stuck DRQ\\n\", cd->name);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (pcd_wait\n\t\t\t    (cd, IDE_BUSY, IDE_DRQ | IDE_READY | IDE_ERR, fun,\n\t\t\t     \"completion\")) {\n\t\t\t\tr = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tpi_disconnect(cd->pi);\n\n\treturn r;\n}\n\nstatic void pcd_req_sense(struct pcd_unit *cd, char *fun)\n{\n\tchar rs_cmd[12] = { 0x03, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0 };\n\tchar buf[16];\n\tint r, c;\n\n\tr = pcd_command(cd, rs_cmd, 16, \"Request sense\");\n\tmdelay(1);\n\tif (!r)\n\t\tpcd_completion(cd, buf, \"Request sense\");\n\n\tcd->last_sense = -1;\n\tc = 2;\n\tif (!r) {\n\t\tif (fun)\n\t\t\tprintk(\"%s: %s: Sense key: %x, ASC: %x, ASQ: %x\\n\",\n\t\t\t       cd->name, fun, buf[2] & 0xf, buf[12], buf[13]);\n\t\tc = buf[2] & 0xf;\n\t\tcd->last_sense =\n\t\t    c | ((buf[12] & 0xff) << 8) | ((buf[13] & 0xff) << 16);\n\t}\n\tif ((c == 2) || (c == 6))\n\t\tcd->changed = 1;\n}\n\nstatic int pcd_atapi(struct pcd_unit *cd, char *cmd, int dlen, char *buf, char *fun)\n{\n\tint r;\n\n\tr = pcd_command(cd, cmd, dlen, fun);\n\tmdelay(1);\n\tif (!r)\n\t\tr = pcd_completion(cd, buf, fun);\n\tif (r)\n\t\tpcd_req_sense(cd, fun);\n\n\treturn r;\n}\n\nstatic int pcd_packet(struct cdrom_device_info *cdi, struct packet_command *cgc)\n{\n\treturn pcd_atapi(cdi->handle, cgc->cmd, cgc->buflen, cgc->buffer,\n\t\t\t \"generic packet\");\n}\n\n#define DBMSG(msg)\t((verbose>1)?(msg):NULL)\n\nstatic unsigned int pcd_check_events(struct cdrom_device_info *cdi,\n\t\t\t\t     unsigned int clearing, int slot_nr)\n{\n\tstruct pcd_unit *cd = cdi->handle;\n\tint res = cd->changed;\n\tif (res)\n\t\tcd->changed = 0;\n\treturn res ? DISK_EVENT_MEDIA_CHANGE : 0;\n}\n\nstatic int pcd_lock_door(struct cdrom_device_info *cdi, int lock)\n{\n\tchar un_cmd[12] = { 0x1e, 0, 0, 0, lock, 0, 0, 0, 0, 0, 0, 0 };\n\n\treturn pcd_atapi(cdi->handle, un_cmd, 0, pcd_scratch,\n\t\t\t lock ? \"lock door\" : \"unlock door\");\n}\n\nstatic int pcd_tray_move(struct cdrom_device_info *cdi, int position)\n{\n\tchar ej_cmd[12] = { 0x1b, 0, 0, 0, 3 - position, 0, 0, 0, 0, 0, 0, 0 };\n\n\treturn pcd_atapi(cdi->handle, ej_cmd, 0, pcd_scratch,\n\t\t\t position ? \"eject\" : \"close tray\");\n}\n\nstatic void pcd_sleep(int cs)\n{\n\tschedule_timeout_interruptible(cs);\n}\n\nstatic int pcd_reset(struct pcd_unit *cd)\n{\n\tint i, k, flg;\n\tint expect[5] = { 1, 1, 1, 0x14, 0xeb };\n\n\tpi_connect(cd->pi);\n\twrite_reg(cd, 6, 0xa0 + 0x10 * cd->drive);\n\twrite_reg(cd, 7, 8);\n\n\tpcd_sleep(20 * HZ / 1000);\t/* delay a bit */\n\n\tk = 0;\n\twhile ((k++ < PCD_RESET_TMO) && (status_reg(cd) & IDE_BUSY))\n\t\tpcd_sleep(HZ / 10);\n\n\tflg = 1;\n\tfor (i = 0; i < 5; i++)\n\t\tflg &= (read_reg(cd, i + 1) == expect[i]);\n\n\tif (verbose) {\n\t\tprintk(\"%s: Reset (%d) signature = \", cd->name, k);\n\t\tfor (i = 0; i < 5; i++)\n\t\t\tprintk(\"%3x\", read_reg(cd, i + 1));\n\t\tif (!flg)\n\t\t\tprintk(\" (incorrect)\");\n\t\tprintk(\"\\n\");\n\t}\n\n\tpi_disconnect(cd->pi);\n\treturn flg - 1;\n}\n\nstatic int pcd_drive_reset(struct cdrom_device_info *cdi)\n{\n\treturn pcd_reset(cdi->handle);\n}\n\nstatic int pcd_ready_wait(struct pcd_unit *cd, int tmo)\n{\n\tchar tr_cmd[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n\tint k, p;\n\n\tk = 0;\n\twhile (k < tmo) {\n\t\tcd->last_sense = 0;\n\t\tpcd_atapi(cd, tr_cmd, 0, NULL, DBMSG(\"test unit ready\"));\n\t\tp = cd->last_sense;\n\t\tif (!p)\n\t\t\treturn 0;\n\t\tif (!(((p & 0xffff) == 0x0402) || ((p & 0xff) == 6)))\n\t\t\treturn p;\n\t\tk++;\n\t\tpcd_sleep(HZ);\n\t}\n\treturn 0x000020;\t/* timeout */\n}\n\nstatic int pcd_drive_status(struct cdrom_device_info *cdi, int slot_nr)\n{\n\tchar rc_cmd[12] = { 0x25, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n\tstruct pcd_unit *cd = cdi->handle;\n\n\tif (pcd_ready_wait(cd, PCD_READY_TMO))\n\t\treturn CDS_DRIVE_NOT_READY;\n\tif (pcd_atapi(cd, rc_cmd, 8, pcd_scratch, DBMSG(\"check media\")))\n\t\treturn CDS_NO_DISC;\n\treturn CDS_DISC_OK;\n}\n\nstatic int pcd_identify(struct pcd_unit *cd, char *id)\n{\n\tint k, s;\n\tchar id_cmd[12] = { 0x12, 0, 0, 0, 36, 0, 0, 0, 0, 0, 0, 0 };\n\n\tpcd_bufblk = -1;\n\n\ts = pcd_atapi(cd, id_cmd, 36, pcd_buffer, \"identify\");\n\n\tif (s)\n\t\treturn -1;\n\tif ((pcd_buffer[0] & 0x1f) != 5) {\n\t\tif (verbose)\n\t\t\tprintk(\"%s: %s is not a CD-ROM\\n\",\n\t\t\t       cd->name, cd->drive ? \"Slave\" : \"Master\");\n\t\treturn -1;\n\t}\n\tmemcpy(id, pcd_buffer + 16, 16);\n\tid[16] = 0;\n\tk = 16;\n\twhile ((k >= 0) && (id[k] <= 0x20)) {\n\t\tid[k] = 0;\n\t\tk--;\n\t}\n\n\tprintk(\"%s: %s: %s\\n\", cd->name, cd->drive ? \"Slave\" : \"Master\", id);\n\n\treturn 0;\n}\n\n/*\n * returns  0, with id set if drive is detected\n *\t    -1, if drive detection failed\n */\nstatic int pcd_probe(struct pcd_unit *cd, int ms, char *id)\n{\n\tif (ms == -1) {\n\t\tfor (cd->drive = 0; cd->drive <= 1; cd->drive++)\n\t\t\tif (!pcd_reset(cd) && !pcd_identify(cd, id))\n\t\t\t\treturn 0;\n\t} else {\n\t\tcd->drive = ms;\n\t\tif (!pcd_reset(cd) && !pcd_identify(cd, id))\n\t\t\treturn 0;\n\t}\n\treturn -1;\n}\n\nstatic void pcd_probe_capabilities(void)\n{\n\tint unit, r;\n\tchar buffer[32];\n\tchar cmd[12] = { 0x5a, 1 << 3, 0x2a, 0, 0, 0, 0, 18, 0, 0, 0, 0 };\n\tstruct pcd_unit *cd;\n\n\tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {\n\t\tif (!cd->present)\n\t\t\tcontinue;\n\t\tr = pcd_atapi(cd, cmd, 18, buffer, \"mode sense capabilities\");\n\t\tif (r)\n\t\t\tcontinue;\n\t\t/* we should now have the cap page */\n\t\tif ((buffer[11] & 1) == 0)\n\t\t\tcd->info.mask |= CDC_CD_R;\n\t\tif ((buffer[11] & 2) == 0)\n\t\t\tcd->info.mask |= CDC_CD_RW;\n\t\tif ((buffer[12] & 1) == 0)\n\t\t\tcd->info.mask |= CDC_PLAY_AUDIO;\n\t\tif ((buffer[14] & 1) == 0)\n\t\t\tcd->info.mask |= CDC_LOCK;\n\t\tif ((buffer[14] & 8) == 0)\n\t\t\tcd->info.mask |= CDC_OPEN_TRAY;\n\t\tif ((buffer[14] >> 6) == 0)\n\t\t\tcd->info.mask |= CDC_CLOSE_TRAY;\n\t}\n}\n\nstatic int pcd_detect(void)\n{\n\tchar id[18];\n\tint k, unit;\n\tstruct pcd_unit *cd;\n\n\tprintk(\"%s: %s version %s, major %d, nice %d\\n\",\n\t       name, name, PCD_VERSION, major, nice);\n\n\tpar_drv = pi_register_driver(name);\n\tif (!par_drv) {\n\t\tpr_err(\"failed to register %s driver\\n\", name);\n\t\treturn -1;\n\t}\n\n\tk = 0;\n\tif (pcd_drive_count == 0) { /* nothing spec'd - so autoprobe for 1 */\n\t\tcd = pcd;\n\t\tif (pi_init(cd->pi, 1, -1, -1, -1, -1, -1, pcd_buffer,\n\t\t\t    PI_PCD, verbose, cd->name)) {\n\t\t\tif (!pcd_probe(cd, -1, id) && cd->disk) {\n\t\t\t\tcd->present = 1;\n\t\t\t\tk++;\n\t\t\t} else\n\t\t\t\tpi_release(cd->pi);\n\t\t}\n\t} else {\n\t\tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {\n\t\t\tint *conf = *drives[unit];\n\t\t\tif (!conf[D_PRT])\n\t\t\t\tcontinue;\n\t\t\tif (!pi_init(cd->pi, 0, conf[D_PRT], conf[D_MOD],\n\t\t\t\t     conf[D_UNI], conf[D_PRO], conf[D_DLY],\n\t\t\t\t     pcd_buffer, PI_PCD, verbose, cd->name)) \n\t\t\t\tcontinue;\n\t\t\tif (!pcd_probe(cd, conf[D_SLV], id) && cd->disk) {\n\t\t\t\tcd->present = 1;\n\t\t\t\tk++;\n\t\t\t} else\n\t\t\t\tpi_release(cd->pi);\n\t\t}\n\t}\n\tif (k)\n\t\treturn 0;\n\n\tprintk(\"%s: No CD-ROM drive found\\n\", name);\n\tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {\n\t\tblk_cleanup_queue(cd->disk->queue);\n\t\tcd->disk->queue = NULL;\n\t\tblk_mq_free_tag_set(&cd->tag_set);\n\t\tput_disk(cd->disk);\n\t}\n\tpi_unregister_driver(par_drv);\n\treturn -1;\n}\n\n/* I/O request processing */\nstatic int pcd_queue;\n\nstatic int set_next_request(void)\n{\n\tstruct pcd_unit *cd;\n\tint old_pos = pcd_queue;\n\n\tdo {\n\t\tcd = &pcd[pcd_queue];\n\t\tif (++pcd_queue == PCD_UNITS)\n\t\t\tpcd_queue = 0;\n\t\tif (cd->present && !list_empty(&cd->rq_list)) {\n\t\t\tpcd_req = list_first_entry(&cd->rq_list, struct request,\n\t\t\t\t\t\t\tqueuelist);\n\t\t\tlist_del_init(&pcd_req->queuelist);\n\t\t\tblk_mq_start_request(pcd_req);\n\t\t\tbreak;\n\t\t}\n\t} while (pcd_queue != old_pos);\n\n\treturn pcd_req != NULL;\n}\n\nstatic void pcd_request(void)\n{\n\tstruct pcd_unit *cd;\n\n\tif (pcd_busy)\n\t\treturn;\n\n\tif (!pcd_req && !set_next_request())\n\t\treturn;\n\n\tcd = pcd_req->rq_disk->private_data;\n\tif (cd != pcd_current)\n\t\tpcd_bufblk = -1;\n\tpcd_current = cd;\n\tpcd_sector = blk_rq_pos(pcd_req);\n\tpcd_count = blk_rq_cur_sectors(pcd_req);\n\tpcd_buf = bio_data(pcd_req->bio);\n\tpcd_busy = 1;\n\tps_set_intr(do_pcd_read, NULL, 0, nice);\n}\n\nstatic blk_status_t pcd_queue_rq(struct blk_mq_hw_ctx *hctx,\n\t\t\t\t const struct blk_mq_queue_data *bd)\n{\n\tstruct pcd_unit *cd = hctx->queue->queuedata;\n\n\tif (rq_data_dir(bd->rq) != READ) {\n\t\tblk_mq_start_request(bd->rq);\n\t\treturn BLK_STS_IOERR;\n\t}\n\n\tspin_lock_irq(&pcd_lock);\n\tlist_add_tail(&bd->rq->queuelist, &cd->rq_list);\n\tpcd_request();\n\tspin_unlock_irq(&pcd_lock);\n\n\treturn BLK_STS_OK;\n}\n\nstatic inline void next_request(blk_status_t err)\n{\n\tunsigned long saved_flags;\n\n\tspin_lock_irqsave(&pcd_lock, saved_flags);\n\tif (!blk_update_request(pcd_req, err, blk_rq_cur_bytes(pcd_req))) {\n\t\t__blk_mq_end_request(pcd_req, err);\n\t\tpcd_req = NULL;\n\t}\n\tpcd_busy = 0;\n\tpcd_request();\n\tspin_unlock_irqrestore(&pcd_lock, saved_flags);\n}\n\nstatic int pcd_ready(void)\n{\n\treturn (((status_reg(pcd_current) & (IDE_BUSY | IDE_DRQ)) == IDE_DRQ));\n}\n\nstatic void pcd_transfer(void)\n{\n\n\twhile (pcd_count && (pcd_sector / 4 == pcd_bufblk)) {\n\t\tint o = (pcd_sector % 4) * 512;\n\t\tmemcpy(pcd_buf, pcd_buffer + o, 512);\n\t\tpcd_count--;\n\t\tpcd_buf += 512;\n\t\tpcd_sector++;\n\t}\n}\n\nstatic void pcd_start(void)\n{\n\tint b, i;\n\tchar rd_cmd[12] = { 0xa8, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 };\n\n\tpcd_bufblk = pcd_sector / 4;\n\tb = pcd_bufblk;\n\tfor (i = 0; i < 4; i++) {\n\t\trd_cmd[5 - i] = b & 0xff;\n\t\tb = b >> 8;\n\t}\n\n\tif (pcd_command(pcd_current, rd_cmd, 2048, \"read block\")) {\n\t\tpcd_bufblk = -1;\n\t\tnext_request(BLK_STS_IOERR);\n\t\treturn;\n\t}\n\n\tmdelay(1);\n\n\tps_set_intr(do_pcd_read_drq, pcd_ready, PCD_TMO, nice);\n}\n\nstatic void do_pcd_read(void)\n{\n\tpcd_busy = 1;\n\tpcd_retries = 0;\n\tpcd_transfer();\n\tif (!pcd_count) {\n\t\tnext_request(0);\n\t\treturn;\n\t}\n\n\tpi_do_claimed(pcd_current->pi, pcd_start);\n}\n\nstatic void do_pcd_read_drq(void)\n{\n\tunsigned long saved_flags;\n\n\tif (pcd_completion(pcd_current, pcd_buffer, \"read block\")) {\n\t\tif (pcd_retries < PCD_RETRIES) {\n\t\t\tmdelay(1);\n\t\t\tpcd_retries++;\n\t\t\tpi_do_claimed(pcd_current->pi, pcd_start);\n\t\t\treturn;\n\t\t}\n\t\tpcd_bufblk = -1;\n\t\tnext_request(BLK_STS_IOERR);\n\t\treturn;\n\t}\n\n\tdo_pcd_read();\n\tspin_lock_irqsave(&pcd_lock, saved_flags);\n\tpcd_request();\n\tspin_unlock_irqrestore(&pcd_lock, saved_flags);\n}\n\n/* the audio_ioctl stuff is adapted from sr_ioctl.c */\n\nstatic int pcd_audio_ioctl(struct cdrom_device_info *cdi, unsigned int cmd, void *arg)\n{\n\tstruct pcd_unit *cd = cdi->handle;\n\n\tswitch (cmd) {\n\n\tcase CDROMREADTOCHDR:\n\n\t\t{\n\t\t\tchar cmd[12] =\n\t\t\t    { GPCMD_READ_TOC_PMA_ATIP, 0, 0, 0, 0, 0, 0, 0, 12,\n\t\t\t 0, 0, 0 };\n\t\t\tstruct cdrom_tochdr *tochdr =\n\t\t\t    (struct cdrom_tochdr *) arg;\n\t\t\tchar buffer[32];\n\t\t\tint r;\n\n\t\t\tr = pcd_atapi(cd, cmd, 12, buffer, \"read toc header\");\n\n\t\t\ttochdr->cdth_trk0 = buffer[2];\n\t\t\ttochdr->cdth_trk1 = buffer[3];\n\n\t\t\treturn r ? -EIO : 0;\n\t\t}\n\n\tcase CDROMREADTOCENTRY:\n\n\t\t{\n\t\t\tchar cmd[12] =\n\t\t\t    { GPCMD_READ_TOC_PMA_ATIP, 0, 0, 0, 0, 0, 0, 0, 12,\n\t\t\t 0, 0, 0 };\n\n\t\t\tstruct cdrom_tocentry *tocentry =\n\t\t\t    (struct cdrom_tocentry *) arg;\n\t\t\tunsigned char buffer[32];\n\t\t\tint r;\n\n\t\t\tcmd[1] =\n\t\t\t    (tocentry->cdte_format == CDROM_MSF ? 0x02 : 0);\n\t\t\tcmd[6] = tocentry->cdte_track;\n\n\t\t\tr = pcd_atapi(cd, cmd, 12, buffer, \"read toc entry\");\n\n\t\t\ttocentry->cdte_ctrl = buffer[5] & 0xf;\n\t\t\ttocentry->cdte_adr = buffer[5] >> 4;\n\t\t\ttocentry->cdte_datamode =\n\t\t\t    (tocentry->cdte_ctrl & 0x04) ? 1 : 0;\n\t\t\tif (tocentry->cdte_format == CDROM_MSF) {\n\t\t\t\ttocentry->cdte_addr.msf.minute = buffer[9];\n\t\t\t\ttocentry->cdte_addr.msf.second = buffer[10];\n\t\t\t\ttocentry->cdte_addr.msf.frame = buffer[11];\n\t\t\t} else\n\t\t\t\ttocentry->cdte_addr.lba =\n\t\t\t\t    (((((buffer[8] << 8) + buffer[9]) << 8)\n\t\t\t\t      + buffer[10]) << 8) + buffer[11];\n\n\t\t\treturn r ? -EIO : 0;\n\t\t}\n\n\tdefault:\n\n\t\treturn -ENOSYS;\n\t}\n}\n\nstatic int pcd_get_mcn(struct cdrom_device_info *cdi, struct cdrom_mcn *mcn)\n{\n\tchar cmd[12] =\n\t    { GPCMD_READ_SUBCHANNEL, 0, 0x40, 2, 0, 0, 0, 0, 24, 0, 0, 0 };\n\tchar buffer[32];\n\n\tif (pcd_atapi(cdi->handle, cmd, 24, buffer, \"get mcn\"))\n\t\treturn -EIO;\n\n\tmemcpy(mcn->medium_catalog_number, buffer + 9, 13);\n\tmcn->medium_catalog_number[13] = 0;\n\n\treturn 0;\n}\n\nstatic int __init pcd_init(void)\n{\n\tstruct pcd_unit *cd;\n\tint unit;\n\n\tif (disable)\n\t\treturn -EINVAL;\n\n\tpcd_init_units();\n\n\tif (pcd_detect())\n\t\treturn -ENODEV;\n\n\t/* get the atapi capabilities page */\n\tpcd_probe_capabilities();\n\n\tif (register_blkdev(major, name)) {\n\t\tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++)\n\t\t\tput_disk(cd->disk);\n\t\treturn -EBUSY;\n\t}\n\n\tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {\n\t\tif (cd->present) {\n\t\t\tregister_cdrom(&cd->info);\n\t\t\tcd->disk->private_data = cd;\n\t\t\tadd_disk(cd->disk);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit pcd_exit(void)\n{\n\tstruct pcd_unit *cd;\n\tint unit;\n\n\tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {\n\t\tif (cd->present) {\n\t\t\tdel_gendisk(cd->disk);\n\t\t\tpi_release(cd->pi);\n\t\t\tunregister_cdrom(&cd->info);\n\t\t}\n\t\tblk_cleanup_queue(cd->disk->queue);\n\t\tblk_mq_free_tag_set(&cd->tag_set);\n\t\tput_disk(cd->disk);\n\t}\n\tunregister_blkdev(major, name);\n\tpi_unregister_driver(par_drv);\n}\n\nMODULE_LICENSE(\"GPL\");\nmodule_init(pcd_init)\nmodule_exit(pcd_exit)\n"], "fixing_code": ["/* \n\tpcd.c\t(c) 1997-8  Grant R. Guenther <grant@torque.net>\n\t\t            Under the terms of the GNU General Public License.\n\n\tThis is a high-level driver for parallel port ATAPI CD-ROM\n        drives based on chips supported by the paride module.\n\n        By default, the driver will autoprobe for a single parallel\n        port ATAPI CD-ROM drive, but if their individual parameters are\n        specified, the driver can handle up to 4 drives.\n\n        The behaviour of the pcd driver can be altered by setting\n        some parameters from the insmod command line.  The following\n        parameters are adjustable:\n\n            drive0      These four arguments can be arrays of       \n            drive1      1-6 integers as follows:\n            drive2\n            drive3      <prt>,<pro>,<uni>,<mod>,<slv>,<dly>\n\n                        Where,\n\n                <prt>   is the base of the parallel port address for\n                        the corresponding drive.  (required)\n\n                <pro>   is the protocol number for the adapter that\n                        supports this drive.  These numbers are\n                        logged by 'paride' when the protocol modules\n                        are initialised.  (0 if not given)\n\n                <uni>   for those adapters that support chained\n                        devices, this is the unit selector for the\n                        chain of devices on the given port.  It should\n                        be zero for devices that don't support chaining.\n                        (0 if not given)\n\n                <mod>   this can be -1 to choose the best mode, or one\n                        of the mode numbers supported by the adapter.\n                        (-1 if not given)\n\n\t\t<slv>   ATAPI CD-ROMs can be jumpered to master or slave.\n\t\t\tSet this to 0 to choose the master drive, 1 to\n                        choose the slave, -1 (the default) to choose the\n\t\t\tfirst drive found.\n\n                <dly>   some parallel ports require the driver to \n                        go more slowly.  -1 sets a default value that\n                        should work with the chosen protocol.  Otherwise,\n                        set this to a small integer, the larger it is\n                        the slower the port i/o.  In some cases, setting\n                        this to zero will speed up the device. (default -1)\n                        \n            major       You may use this parameter to override the\n                        default major number (46) that this driver\n                        will use.  Be sure to change the device\n                        name as well.\n\n            name        This parameter is a character string that\n                        contains the name the kernel will use for this\n                        device (in /proc output, for instance).\n                        (default \"pcd\")\n\n            verbose     This parameter controls the amount of logging\n                        that the driver will do.  Set it to 0 for\n                        normal operation, 1 to see autoprobe progress\n                        messages, or 2 to see additional debugging\n                        output.  (default 0)\n  \n            nice        This parameter controls the driver's use of\n                        idle CPU time, at the expense of some speed.\n \n\tIf this driver is built into the kernel, you can use the\n        following kernel command line parameters, with the same values\n        as the corresponding module parameters listed above:\n\n\t    pcd.drive0\n\t    pcd.drive1\n\t    pcd.drive2\n\t    pcd.drive3\n\t    pcd.nice\n\n        In addition, you can use the parameter pcd.disable to disable\n        the driver entirely.\n\n*/\n\n/* Changes:\n\n\t1.01\tGRG 1998.01.24\tAdded test unit ready support\n\t1.02    GRG 1998.05.06  Changes to pcd_completion, ready_wait,\n\t\t\t\tand loosen interpretation of ATAPI\n\t\t\t        standard for clearing error status.\n\t\t\t\tUse spinlocks. Eliminate sti().\n\t1.03    GRG 1998.06.16  Eliminated an Ugh\n\t1.04\tGRG 1998.08.15  Added extra debugging, improvements to\n\t\t\t\tpcd_completion, use HZ in loop timing\n\t1.05\tGRG 1998.08.16\tConformed to \"Uniform CD-ROM\" standard\n\t1.06    GRG 1998.08.19  Added audio ioctl support\n\t1.07    GRG 1998.09.24  Increased reset timeout, added jumbo support\n\n*/\n\n#define\tPCD_VERSION\t\"1.07\"\n#define PCD_MAJOR\t46\n#define PCD_NAME\t\"pcd\"\n#define PCD_UNITS\t4\n\n/* Here are things one can override from the insmod command.\n   Most are autoprobed by paride unless set here.  Verbose is off\n   by default.\n\n*/\n\nstatic int verbose = 0;\nstatic int major = PCD_MAJOR;\nstatic char *name = PCD_NAME;\nstatic int nice = 0;\nstatic int disable = 0;\n\nstatic int drive0[6] = { 0, 0, 0, -1, -1, -1 };\nstatic int drive1[6] = { 0, 0, 0, -1, -1, -1 };\nstatic int drive2[6] = { 0, 0, 0, -1, -1, -1 };\nstatic int drive3[6] = { 0, 0, 0, -1, -1, -1 };\n\nstatic int (*drives[4])[6] = {&drive0, &drive1, &drive2, &drive3};\nstatic int pcd_drive_count;\n\nenum {D_PRT, D_PRO, D_UNI, D_MOD, D_SLV, D_DLY};\n\n/* end of parameters */\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/cdrom.h>\n#include <linux/spinlock.h>\n#include <linux/blk-mq.h>\n#include <linux/mutex.h>\n#include <linux/uaccess.h>\n\nstatic DEFINE_MUTEX(pcd_mutex);\nstatic DEFINE_SPINLOCK(pcd_lock);\n\nmodule_param(verbose, int, 0644);\nmodule_param(major, int, 0);\nmodule_param(name, charp, 0);\nmodule_param(nice, int, 0);\nmodule_param_array(drive0, int, NULL, 0);\nmodule_param_array(drive1, int, NULL, 0);\nmodule_param_array(drive2, int, NULL, 0);\nmodule_param_array(drive3, int, NULL, 0);\n\n#include \"paride.h\"\n#include \"pseudo.h\"\n\n#define PCD_RETRIES\t     5\n#define PCD_TMO\t\t   800\t/* timeout in jiffies */\n#define PCD_DELAY           50\t/* spin delay in uS */\n#define PCD_READY_TMO\t    20\t/* in seconds */\n#define PCD_RESET_TMO\t   100\t/* in tenths of a second */\n\n#define PCD_SPIN\t(1000000*PCD_TMO)/(HZ*PCD_DELAY)\n\n#define IDE_ERR\t\t0x01\n#define IDE_DRQ         0x08\n#define IDE_READY       0x40\n#define IDE_BUSY        0x80\n\nstatic int pcd_open(struct cdrom_device_info *cdi, int purpose);\nstatic void pcd_release(struct cdrom_device_info *cdi);\nstatic int pcd_drive_status(struct cdrom_device_info *cdi, int slot_nr);\nstatic unsigned int pcd_check_events(struct cdrom_device_info *cdi,\n\t\t\t\t     unsigned int clearing, int slot_nr);\nstatic int pcd_tray_move(struct cdrom_device_info *cdi, int position);\nstatic int pcd_lock_door(struct cdrom_device_info *cdi, int lock);\nstatic int pcd_drive_reset(struct cdrom_device_info *cdi);\nstatic int pcd_get_mcn(struct cdrom_device_info *cdi, struct cdrom_mcn *mcn);\nstatic int pcd_audio_ioctl(struct cdrom_device_info *cdi,\n\t\t\t   unsigned int cmd, void *arg);\nstatic int pcd_packet(struct cdrom_device_info *cdi,\n\t\t      struct packet_command *cgc);\n\nstatic int pcd_detect(void);\nstatic void pcd_probe_capabilities(void);\nstatic void do_pcd_read_drq(void);\nstatic blk_status_t pcd_queue_rq(struct blk_mq_hw_ctx *hctx,\n\t\t\t\t const struct blk_mq_queue_data *bd);\nstatic void do_pcd_read(void);\n\nstruct pcd_unit {\n\tstruct pi_adapter pia;\t/* interface to paride layer */\n\tstruct pi_adapter *pi;\n\tint drive;\t\t/* master/slave */\n\tint last_sense;\t\t/* result of last request sense */\n\tint changed;\t\t/* media change seen */\n\tint present;\t\t/* does this unit exist ? */\n\tchar *name;\t\t/* pcd0, pcd1, etc */\n\tstruct cdrom_device_info info;\t/* uniform cdrom interface */\n\tstruct gendisk *disk;\n\tstruct blk_mq_tag_set tag_set;\n\tstruct list_head rq_list;\n};\n\nstatic struct pcd_unit pcd[PCD_UNITS];\n\nstatic char pcd_scratch[64];\nstatic char pcd_buffer[2048];\t/* raw block buffer */\nstatic int pcd_bufblk = -1;\t/* block in buffer, in CD units,\n\t\t\t\t   -1 for nothing there. See also\n\t\t\t\t   pd_unit.\n\t\t\t\t */\n\n/* the variables below are used mainly in the I/O request engine, which\n   processes only one request at a time.\n*/\n\nstatic struct pcd_unit *pcd_current; /* current request's drive */\nstatic struct request *pcd_req;\nstatic int pcd_retries;\t\t/* retries on current request */\nstatic int pcd_busy;\t\t/* request being processed ? */\nstatic int pcd_sector;\t\t/* address of next requested sector */\nstatic int pcd_count;\t\t/* number of blocks still to do */\nstatic char *pcd_buf;\t\t/* buffer for request in progress */\nstatic void *par_drv;\t\t/* reference of parport driver */\n\n/* kernel glue structures */\n\nstatic int pcd_block_open(struct block_device *bdev, fmode_t mode)\n{\n\tstruct pcd_unit *cd = bdev->bd_disk->private_data;\n\tint ret;\n\n\tcheck_disk_change(bdev);\n\n\tmutex_lock(&pcd_mutex);\n\tret = cdrom_open(&cd->info, bdev, mode);\n\tmutex_unlock(&pcd_mutex);\n\n\treturn ret;\n}\n\nstatic void pcd_block_release(struct gendisk *disk, fmode_t mode)\n{\n\tstruct pcd_unit *cd = disk->private_data;\n\tmutex_lock(&pcd_mutex);\n\tcdrom_release(&cd->info, mode);\n\tmutex_unlock(&pcd_mutex);\n}\n\nstatic int pcd_block_ioctl(struct block_device *bdev, fmode_t mode,\n\t\t\t\tunsigned cmd, unsigned long arg)\n{\n\tstruct pcd_unit *cd = bdev->bd_disk->private_data;\n\tint ret;\n\n\tmutex_lock(&pcd_mutex);\n\tret = cdrom_ioctl(&cd->info, bdev, mode, cmd, arg);\n\tmutex_unlock(&pcd_mutex);\n\n\treturn ret;\n}\n\nstatic unsigned int pcd_block_check_events(struct gendisk *disk,\n\t\t\t\t\t   unsigned int clearing)\n{\n\tstruct pcd_unit *cd = disk->private_data;\n\treturn cdrom_check_events(&cd->info, clearing);\n}\n\nstatic const struct block_device_operations pcd_bdops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= pcd_block_open,\n\t.release\t= pcd_block_release,\n\t.ioctl\t\t= pcd_block_ioctl,\n\t.check_events\t= pcd_block_check_events,\n};\n\nstatic const struct cdrom_device_ops pcd_dops = {\n\t.open\t\t= pcd_open,\n\t.release\t= pcd_release,\n\t.drive_status\t= pcd_drive_status,\n\t.check_events\t= pcd_check_events,\n\t.tray_move\t= pcd_tray_move,\n\t.lock_door\t= pcd_lock_door,\n\t.get_mcn\t= pcd_get_mcn,\n\t.reset\t\t= pcd_drive_reset,\n\t.audio_ioctl\t= pcd_audio_ioctl,\n\t.generic_packet\t= pcd_packet,\n\t.capability\t= CDC_CLOSE_TRAY | CDC_OPEN_TRAY | CDC_LOCK |\n\t\t\t  CDC_MCN | CDC_MEDIA_CHANGED | CDC_RESET |\n\t\t\t  CDC_PLAY_AUDIO | CDC_GENERIC_PACKET | CDC_CD_R |\n\t\t\t  CDC_CD_RW,\n};\n\nstatic const struct blk_mq_ops pcd_mq_ops = {\n\t.queue_rq\t= pcd_queue_rq,\n};\n\nstatic void pcd_init_units(void)\n{\n\tstruct pcd_unit *cd;\n\tint unit;\n\n\tpcd_drive_count = 0;\n\tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {\n\t\tstruct gendisk *disk = alloc_disk(1);\n\n\t\tif (!disk)\n\t\t\tcontinue;\n\n\t\tdisk->queue = blk_mq_init_sq_queue(&cd->tag_set, &pcd_mq_ops,\n\t\t\t\t\t\t   1, BLK_MQ_F_SHOULD_MERGE);\n\t\tif (IS_ERR(disk->queue)) {\n\t\t\tput_disk(disk);\n\t\t\tdisk->queue = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\tINIT_LIST_HEAD(&cd->rq_list);\n\t\tdisk->queue->queuedata = cd;\n\t\tblk_queue_bounce_limit(disk->queue, BLK_BOUNCE_HIGH);\n\t\tcd->disk = disk;\n\t\tcd->pi = &cd->pia;\n\t\tcd->present = 0;\n\t\tcd->last_sense = 0;\n\t\tcd->changed = 1;\n\t\tcd->drive = (*drives[unit])[D_SLV];\n\t\tif ((*drives[unit])[D_PRT])\n\t\t\tpcd_drive_count++;\n\n\t\tcd->name = &cd->info.name[0];\n\t\tsnprintf(cd->name, sizeof(cd->info.name), \"%s%d\", name, unit);\n\t\tcd->info.ops = &pcd_dops;\n\t\tcd->info.handle = cd;\n\t\tcd->info.speed = 0;\n\t\tcd->info.capacity = 1;\n\t\tcd->info.mask = 0;\n\t\tdisk->major = major;\n\t\tdisk->first_minor = unit;\n\t\tstrcpy(disk->disk_name, cd->name);\t/* umm... */\n\t\tdisk->fops = &pcd_bdops;\n\t\tdisk->flags = GENHD_FL_BLOCK_EVENTS_ON_EXCL_WRITE;\n\t}\n}\n\nstatic int pcd_open(struct cdrom_device_info *cdi, int purpose)\n{\n\tstruct pcd_unit *cd = cdi->handle;\n\tif (!cd->present)\n\t\treturn -ENODEV;\n\treturn 0;\n}\n\nstatic void pcd_release(struct cdrom_device_info *cdi)\n{\n}\n\nstatic inline int status_reg(struct pcd_unit *cd)\n{\n\treturn pi_read_regr(cd->pi, 1, 6);\n}\n\nstatic inline int read_reg(struct pcd_unit *cd, int reg)\n{\n\treturn pi_read_regr(cd->pi, 0, reg);\n}\n\nstatic inline void write_reg(struct pcd_unit *cd, int reg, int val)\n{\n\tpi_write_regr(cd->pi, 0, reg, val);\n}\n\nstatic int pcd_wait(struct pcd_unit *cd, int go, int stop, char *fun, char *msg)\n{\n\tint j, r, e, s, p;\n\n\tj = 0;\n\twhile ((((r = status_reg(cd)) & go) || (stop && (!(r & stop))))\n\t       && (j++ < PCD_SPIN))\n\t\tudelay(PCD_DELAY);\n\n\tif ((r & (IDE_ERR & stop)) || (j > PCD_SPIN)) {\n\t\ts = read_reg(cd, 7);\n\t\te = read_reg(cd, 1);\n\t\tp = read_reg(cd, 2);\n\t\tif (j > PCD_SPIN)\n\t\t\te |= 0x100;\n\t\tif (fun)\n\t\t\tprintk(\"%s: %s %s: alt=0x%x stat=0x%x err=0x%x\"\n\t\t\t       \" loop=%d phase=%d\\n\",\n\t\t\t       cd->name, fun, msg, r, s, e, j, p);\n\t\treturn (s << 8) + r;\n\t}\n\treturn 0;\n}\n\nstatic int pcd_command(struct pcd_unit *cd, char *cmd, int dlen, char *fun)\n{\n\tpi_connect(cd->pi);\n\n\twrite_reg(cd, 6, 0xa0 + 0x10 * cd->drive);\n\n\tif (pcd_wait(cd, IDE_BUSY | IDE_DRQ, 0, fun, \"before command\")) {\n\t\tpi_disconnect(cd->pi);\n\t\treturn -1;\n\t}\n\n\twrite_reg(cd, 4, dlen % 256);\n\twrite_reg(cd, 5, dlen / 256);\n\twrite_reg(cd, 7, 0xa0);\t/* ATAPI packet command */\n\n\tif (pcd_wait(cd, IDE_BUSY, IDE_DRQ, fun, \"command DRQ\")) {\n\t\tpi_disconnect(cd->pi);\n\t\treturn -1;\n\t}\n\n\tif (read_reg(cd, 2) != 1) {\n\t\tprintk(\"%s: %s: command phase error\\n\", cd->name, fun);\n\t\tpi_disconnect(cd->pi);\n\t\treturn -1;\n\t}\n\n\tpi_write_block(cd->pi, cmd, 12);\n\n\treturn 0;\n}\n\nstatic int pcd_completion(struct pcd_unit *cd, char *buf, char *fun)\n{\n\tint r, d, p, n, k, j;\n\n\tr = -1;\n\tk = 0;\n\tj = 0;\n\n\tif (!pcd_wait(cd, IDE_BUSY, IDE_DRQ | IDE_READY | IDE_ERR,\n\t\t      fun, \"completion\")) {\n\t\tr = 0;\n\t\twhile (read_reg(cd, 7) & IDE_DRQ) {\n\t\t\td = read_reg(cd, 4) + 256 * read_reg(cd, 5);\n\t\t\tn = (d + 3) & 0xfffc;\n\t\t\tp = read_reg(cd, 2) & 3;\n\n\t\t\tif ((p == 2) && (n > 0) && (j == 0)) {\n\t\t\t\tpi_read_block(cd->pi, buf, n);\n\t\t\t\tif (verbose > 1)\n\t\t\t\t\tprintk(\"%s: %s: Read %d bytes\\n\",\n\t\t\t\t\t       cd->name, fun, n);\n\t\t\t\tr = 0;\n\t\t\t\tj++;\n\t\t\t} else {\n\t\t\t\tif (verbose > 1)\n\t\t\t\t\tprintk\n\t\t\t\t\t    (\"%s: %s: Unexpected phase %d, d=%d, k=%d\\n\",\n\t\t\t\t\t     cd->name, fun, p, d, k);\n\t\t\t\tif (verbose < 2)\n\t\t\t\t\tprintk_once(\n\t\t\t\t\t    \"%s: WARNING: ATAPI phase errors\\n\",\n\t\t\t\t\t    cd->name);\n\t\t\t\tmdelay(1);\n\t\t\t}\n\t\t\tif (k++ > PCD_TMO) {\n\t\t\t\tprintk(\"%s: Stuck DRQ\\n\", cd->name);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (pcd_wait\n\t\t\t    (cd, IDE_BUSY, IDE_DRQ | IDE_READY | IDE_ERR, fun,\n\t\t\t     \"completion\")) {\n\t\t\t\tr = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tpi_disconnect(cd->pi);\n\n\treturn r;\n}\n\nstatic void pcd_req_sense(struct pcd_unit *cd, char *fun)\n{\n\tchar rs_cmd[12] = { 0x03, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0 };\n\tchar buf[16];\n\tint r, c;\n\n\tr = pcd_command(cd, rs_cmd, 16, \"Request sense\");\n\tmdelay(1);\n\tif (!r)\n\t\tpcd_completion(cd, buf, \"Request sense\");\n\n\tcd->last_sense = -1;\n\tc = 2;\n\tif (!r) {\n\t\tif (fun)\n\t\t\tprintk(\"%s: %s: Sense key: %x, ASC: %x, ASQ: %x\\n\",\n\t\t\t       cd->name, fun, buf[2] & 0xf, buf[12], buf[13]);\n\t\tc = buf[2] & 0xf;\n\t\tcd->last_sense =\n\t\t    c | ((buf[12] & 0xff) << 8) | ((buf[13] & 0xff) << 16);\n\t}\n\tif ((c == 2) || (c == 6))\n\t\tcd->changed = 1;\n}\n\nstatic int pcd_atapi(struct pcd_unit *cd, char *cmd, int dlen, char *buf, char *fun)\n{\n\tint r;\n\n\tr = pcd_command(cd, cmd, dlen, fun);\n\tmdelay(1);\n\tif (!r)\n\t\tr = pcd_completion(cd, buf, fun);\n\tif (r)\n\t\tpcd_req_sense(cd, fun);\n\n\treturn r;\n}\n\nstatic int pcd_packet(struct cdrom_device_info *cdi, struct packet_command *cgc)\n{\n\treturn pcd_atapi(cdi->handle, cgc->cmd, cgc->buflen, cgc->buffer,\n\t\t\t \"generic packet\");\n}\n\n#define DBMSG(msg)\t((verbose>1)?(msg):NULL)\n\nstatic unsigned int pcd_check_events(struct cdrom_device_info *cdi,\n\t\t\t\t     unsigned int clearing, int slot_nr)\n{\n\tstruct pcd_unit *cd = cdi->handle;\n\tint res = cd->changed;\n\tif (res)\n\t\tcd->changed = 0;\n\treturn res ? DISK_EVENT_MEDIA_CHANGE : 0;\n}\n\nstatic int pcd_lock_door(struct cdrom_device_info *cdi, int lock)\n{\n\tchar un_cmd[12] = { 0x1e, 0, 0, 0, lock, 0, 0, 0, 0, 0, 0, 0 };\n\n\treturn pcd_atapi(cdi->handle, un_cmd, 0, pcd_scratch,\n\t\t\t lock ? \"lock door\" : \"unlock door\");\n}\n\nstatic int pcd_tray_move(struct cdrom_device_info *cdi, int position)\n{\n\tchar ej_cmd[12] = { 0x1b, 0, 0, 0, 3 - position, 0, 0, 0, 0, 0, 0, 0 };\n\n\treturn pcd_atapi(cdi->handle, ej_cmd, 0, pcd_scratch,\n\t\t\t position ? \"eject\" : \"close tray\");\n}\n\nstatic void pcd_sleep(int cs)\n{\n\tschedule_timeout_interruptible(cs);\n}\n\nstatic int pcd_reset(struct pcd_unit *cd)\n{\n\tint i, k, flg;\n\tint expect[5] = { 1, 1, 1, 0x14, 0xeb };\n\n\tpi_connect(cd->pi);\n\twrite_reg(cd, 6, 0xa0 + 0x10 * cd->drive);\n\twrite_reg(cd, 7, 8);\n\n\tpcd_sleep(20 * HZ / 1000);\t/* delay a bit */\n\n\tk = 0;\n\twhile ((k++ < PCD_RESET_TMO) && (status_reg(cd) & IDE_BUSY))\n\t\tpcd_sleep(HZ / 10);\n\n\tflg = 1;\n\tfor (i = 0; i < 5; i++)\n\t\tflg &= (read_reg(cd, i + 1) == expect[i]);\n\n\tif (verbose) {\n\t\tprintk(\"%s: Reset (%d) signature = \", cd->name, k);\n\t\tfor (i = 0; i < 5; i++)\n\t\t\tprintk(\"%3x\", read_reg(cd, i + 1));\n\t\tif (!flg)\n\t\t\tprintk(\" (incorrect)\");\n\t\tprintk(\"\\n\");\n\t}\n\n\tpi_disconnect(cd->pi);\n\treturn flg - 1;\n}\n\nstatic int pcd_drive_reset(struct cdrom_device_info *cdi)\n{\n\treturn pcd_reset(cdi->handle);\n}\n\nstatic int pcd_ready_wait(struct pcd_unit *cd, int tmo)\n{\n\tchar tr_cmd[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n\tint k, p;\n\n\tk = 0;\n\twhile (k < tmo) {\n\t\tcd->last_sense = 0;\n\t\tpcd_atapi(cd, tr_cmd, 0, NULL, DBMSG(\"test unit ready\"));\n\t\tp = cd->last_sense;\n\t\tif (!p)\n\t\t\treturn 0;\n\t\tif (!(((p & 0xffff) == 0x0402) || ((p & 0xff) == 6)))\n\t\t\treturn p;\n\t\tk++;\n\t\tpcd_sleep(HZ);\n\t}\n\treturn 0x000020;\t/* timeout */\n}\n\nstatic int pcd_drive_status(struct cdrom_device_info *cdi, int slot_nr)\n{\n\tchar rc_cmd[12] = { 0x25, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n\tstruct pcd_unit *cd = cdi->handle;\n\n\tif (pcd_ready_wait(cd, PCD_READY_TMO))\n\t\treturn CDS_DRIVE_NOT_READY;\n\tif (pcd_atapi(cd, rc_cmd, 8, pcd_scratch, DBMSG(\"check media\")))\n\t\treturn CDS_NO_DISC;\n\treturn CDS_DISC_OK;\n}\n\nstatic int pcd_identify(struct pcd_unit *cd, char *id)\n{\n\tint k, s;\n\tchar id_cmd[12] = { 0x12, 0, 0, 0, 36, 0, 0, 0, 0, 0, 0, 0 };\n\n\tpcd_bufblk = -1;\n\n\ts = pcd_atapi(cd, id_cmd, 36, pcd_buffer, \"identify\");\n\n\tif (s)\n\t\treturn -1;\n\tif ((pcd_buffer[0] & 0x1f) != 5) {\n\t\tif (verbose)\n\t\t\tprintk(\"%s: %s is not a CD-ROM\\n\",\n\t\t\t       cd->name, cd->drive ? \"Slave\" : \"Master\");\n\t\treturn -1;\n\t}\n\tmemcpy(id, pcd_buffer + 16, 16);\n\tid[16] = 0;\n\tk = 16;\n\twhile ((k >= 0) && (id[k] <= 0x20)) {\n\t\tid[k] = 0;\n\t\tk--;\n\t}\n\n\tprintk(\"%s: %s: %s\\n\", cd->name, cd->drive ? \"Slave\" : \"Master\", id);\n\n\treturn 0;\n}\n\n/*\n * returns  0, with id set if drive is detected\n *\t    -1, if drive detection failed\n */\nstatic int pcd_probe(struct pcd_unit *cd, int ms, char *id)\n{\n\tif (ms == -1) {\n\t\tfor (cd->drive = 0; cd->drive <= 1; cd->drive++)\n\t\t\tif (!pcd_reset(cd) && !pcd_identify(cd, id))\n\t\t\t\treturn 0;\n\t} else {\n\t\tcd->drive = ms;\n\t\tif (!pcd_reset(cd) && !pcd_identify(cd, id))\n\t\t\treturn 0;\n\t}\n\treturn -1;\n}\n\nstatic void pcd_probe_capabilities(void)\n{\n\tint unit, r;\n\tchar buffer[32];\n\tchar cmd[12] = { 0x5a, 1 << 3, 0x2a, 0, 0, 0, 0, 18, 0, 0, 0, 0 };\n\tstruct pcd_unit *cd;\n\n\tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {\n\t\tif (!cd->present)\n\t\t\tcontinue;\n\t\tr = pcd_atapi(cd, cmd, 18, buffer, \"mode sense capabilities\");\n\t\tif (r)\n\t\t\tcontinue;\n\t\t/* we should now have the cap page */\n\t\tif ((buffer[11] & 1) == 0)\n\t\t\tcd->info.mask |= CDC_CD_R;\n\t\tif ((buffer[11] & 2) == 0)\n\t\t\tcd->info.mask |= CDC_CD_RW;\n\t\tif ((buffer[12] & 1) == 0)\n\t\t\tcd->info.mask |= CDC_PLAY_AUDIO;\n\t\tif ((buffer[14] & 1) == 0)\n\t\t\tcd->info.mask |= CDC_LOCK;\n\t\tif ((buffer[14] & 8) == 0)\n\t\t\tcd->info.mask |= CDC_OPEN_TRAY;\n\t\tif ((buffer[14] >> 6) == 0)\n\t\t\tcd->info.mask |= CDC_CLOSE_TRAY;\n\t}\n}\n\nstatic int pcd_detect(void)\n{\n\tchar id[18];\n\tint k, unit;\n\tstruct pcd_unit *cd;\n\n\tprintk(\"%s: %s version %s, major %d, nice %d\\n\",\n\t       name, name, PCD_VERSION, major, nice);\n\n\tpar_drv = pi_register_driver(name);\n\tif (!par_drv) {\n\t\tpr_err(\"failed to register %s driver\\n\", name);\n\t\treturn -1;\n\t}\n\n\tk = 0;\n\tif (pcd_drive_count == 0) { /* nothing spec'd - so autoprobe for 1 */\n\t\tcd = pcd;\n\t\tif (pi_init(cd->pi, 1, -1, -1, -1, -1, -1, pcd_buffer,\n\t\t\t    PI_PCD, verbose, cd->name)) {\n\t\t\tif (!pcd_probe(cd, -1, id) && cd->disk) {\n\t\t\t\tcd->present = 1;\n\t\t\t\tk++;\n\t\t\t} else\n\t\t\t\tpi_release(cd->pi);\n\t\t}\n\t} else {\n\t\tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {\n\t\t\tint *conf = *drives[unit];\n\t\t\tif (!conf[D_PRT])\n\t\t\t\tcontinue;\n\t\t\tif (!pi_init(cd->pi, 0, conf[D_PRT], conf[D_MOD],\n\t\t\t\t     conf[D_UNI], conf[D_PRO], conf[D_DLY],\n\t\t\t\t     pcd_buffer, PI_PCD, verbose, cd->name)) \n\t\t\t\tcontinue;\n\t\t\tif (!pcd_probe(cd, conf[D_SLV], id) && cd->disk) {\n\t\t\t\tcd->present = 1;\n\t\t\t\tk++;\n\t\t\t} else\n\t\t\t\tpi_release(cd->pi);\n\t\t}\n\t}\n\tif (k)\n\t\treturn 0;\n\n\tprintk(\"%s: No CD-ROM drive found\\n\", name);\n\tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {\n\t\tif (!cd->disk)\n\t\t\tcontinue;\n\t\tblk_cleanup_queue(cd->disk->queue);\n\t\tcd->disk->queue = NULL;\n\t\tblk_mq_free_tag_set(&cd->tag_set);\n\t\tput_disk(cd->disk);\n\t}\n\tpi_unregister_driver(par_drv);\n\treturn -1;\n}\n\n/* I/O request processing */\nstatic int pcd_queue;\n\nstatic int set_next_request(void)\n{\n\tstruct pcd_unit *cd;\n\tint old_pos = pcd_queue;\n\n\tdo {\n\t\tcd = &pcd[pcd_queue];\n\t\tif (++pcd_queue == PCD_UNITS)\n\t\t\tpcd_queue = 0;\n\t\tif (cd->present && !list_empty(&cd->rq_list)) {\n\t\t\tpcd_req = list_first_entry(&cd->rq_list, struct request,\n\t\t\t\t\t\t\tqueuelist);\n\t\t\tlist_del_init(&pcd_req->queuelist);\n\t\t\tblk_mq_start_request(pcd_req);\n\t\t\tbreak;\n\t\t}\n\t} while (pcd_queue != old_pos);\n\n\treturn pcd_req != NULL;\n}\n\nstatic void pcd_request(void)\n{\n\tstruct pcd_unit *cd;\n\n\tif (pcd_busy)\n\t\treturn;\n\n\tif (!pcd_req && !set_next_request())\n\t\treturn;\n\n\tcd = pcd_req->rq_disk->private_data;\n\tif (cd != pcd_current)\n\t\tpcd_bufblk = -1;\n\tpcd_current = cd;\n\tpcd_sector = blk_rq_pos(pcd_req);\n\tpcd_count = blk_rq_cur_sectors(pcd_req);\n\tpcd_buf = bio_data(pcd_req->bio);\n\tpcd_busy = 1;\n\tps_set_intr(do_pcd_read, NULL, 0, nice);\n}\n\nstatic blk_status_t pcd_queue_rq(struct blk_mq_hw_ctx *hctx,\n\t\t\t\t const struct blk_mq_queue_data *bd)\n{\n\tstruct pcd_unit *cd = hctx->queue->queuedata;\n\n\tif (rq_data_dir(bd->rq) != READ) {\n\t\tblk_mq_start_request(bd->rq);\n\t\treturn BLK_STS_IOERR;\n\t}\n\n\tspin_lock_irq(&pcd_lock);\n\tlist_add_tail(&bd->rq->queuelist, &cd->rq_list);\n\tpcd_request();\n\tspin_unlock_irq(&pcd_lock);\n\n\treturn BLK_STS_OK;\n}\n\nstatic inline void next_request(blk_status_t err)\n{\n\tunsigned long saved_flags;\n\n\tspin_lock_irqsave(&pcd_lock, saved_flags);\n\tif (!blk_update_request(pcd_req, err, blk_rq_cur_bytes(pcd_req))) {\n\t\t__blk_mq_end_request(pcd_req, err);\n\t\tpcd_req = NULL;\n\t}\n\tpcd_busy = 0;\n\tpcd_request();\n\tspin_unlock_irqrestore(&pcd_lock, saved_flags);\n}\n\nstatic int pcd_ready(void)\n{\n\treturn (((status_reg(pcd_current) & (IDE_BUSY | IDE_DRQ)) == IDE_DRQ));\n}\n\nstatic void pcd_transfer(void)\n{\n\n\twhile (pcd_count && (pcd_sector / 4 == pcd_bufblk)) {\n\t\tint o = (pcd_sector % 4) * 512;\n\t\tmemcpy(pcd_buf, pcd_buffer + o, 512);\n\t\tpcd_count--;\n\t\tpcd_buf += 512;\n\t\tpcd_sector++;\n\t}\n}\n\nstatic void pcd_start(void)\n{\n\tint b, i;\n\tchar rd_cmd[12] = { 0xa8, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 };\n\n\tpcd_bufblk = pcd_sector / 4;\n\tb = pcd_bufblk;\n\tfor (i = 0; i < 4; i++) {\n\t\trd_cmd[5 - i] = b & 0xff;\n\t\tb = b >> 8;\n\t}\n\n\tif (pcd_command(pcd_current, rd_cmd, 2048, \"read block\")) {\n\t\tpcd_bufblk = -1;\n\t\tnext_request(BLK_STS_IOERR);\n\t\treturn;\n\t}\n\n\tmdelay(1);\n\n\tps_set_intr(do_pcd_read_drq, pcd_ready, PCD_TMO, nice);\n}\n\nstatic void do_pcd_read(void)\n{\n\tpcd_busy = 1;\n\tpcd_retries = 0;\n\tpcd_transfer();\n\tif (!pcd_count) {\n\t\tnext_request(0);\n\t\treturn;\n\t}\n\n\tpi_do_claimed(pcd_current->pi, pcd_start);\n}\n\nstatic void do_pcd_read_drq(void)\n{\n\tunsigned long saved_flags;\n\n\tif (pcd_completion(pcd_current, pcd_buffer, \"read block\")) {\n\t\tif (pcd_retries < PCD_RETRIES) {\n\t\t\tmdelay(1);\n\t\t\tpcd_retries++;\n\t\t\tpi_do_claimed(pcd_current->pi, pcd_start);\n\t\t\treturn;\n\t\t}\n\t\tpcd_bufblk = -1;\n\t\tnext_request(BLK_STS_IOERR);\n\t\treturn;\n\t}\n\n\tdo_pcd_read();\n\tspin_lock_irqsave(&pcd_lock, saved_flags);\n\tpcd_request();\n\tspin_unlock_irqrestore(&pcd_lock, saved_flags);\n}\n\n/* the audio_ioctl stuff is adapted from sr_ioctl.c */\n\nstatic int pcd_audio_ioctl(struct cdrom_device_info *cdi, unsigned int cmd, void *arg)\n{\n\tstruct pcd_unit *cd = cdi->handle;\n\n\tswitch (cmd) {\n\n\tcase CDROMREADTOCHDR:\n\n\t\t{\n\t\t\tchar cmd[12] =\n\t\t\t    { GPCMD_READ_TOC_PMA_ATIP, 0, 0, 0, 0, 0, 0, 0, 12,\n\t\t\t 0, 0, 0 };\n\t\t\tstruct cdrom_tochdr *tochdr =\n\t\t\t    (struct cdrom_tochdr *) arg;\n\t\t\tchar buffer[32];\n\t\t\tint r;\n\n\t\t\tr = pcd_atapi(cd, cmd, 12, buffer, \"read toc header\");\n\n\t\t\ttochdr->cdth_trk0 = buffer[2];\n\t\t\ttochdr->cdth_trk1 = buffer[3];\n\n\t\t\treturn r ? -EIO : 0;\n\t\t}\n\n\tcase CDROMREADTOCENTRY:\n\n\t\t{\n\t\t\tchar cmd[12] =\n\t\t\t    { GPCMD_READ_TOC_PMA_ATIP, 0, 0, 0, 0, 0, 0, 0, 12,\n\t\t\t 0, 0, 0 };\n\n\t\t\tstruct cdrom_tocentry *tocentry =\n\t\t\t    (struct cdrom_tocentry *) arg;\n\t\t\tunsigned char buffer[32];\n\t\t\tint r;\n\n\t\t\tcmd[1] =\n\t\t\t    (tocentry->cdte_format == CDROM_MSF ? 0x02 : 0);\n\t\t\tcmd[6] = tocentry->cdte_track;\n\n\t\t\tr = pcd_atapi(cd, cmd, 12, buffer, \"read toc entry\");\n\n\t\t\ttocentry->cdte_ctrl = buffer[5] & 0xf;\n\t\t\ttocentry->cdte_adr = buffer[5] >> 4;\n\t\t\ttocentry->cdte_datamode =\n\t\t\t    (tocentry->cdte_ctrl & 0x04) ? 1 : 0;\n\t\t\tif (tocentry->cdte_format == CDROM_MSF) {\n\t\t\t\ttocentry->cdte_addr.msf.minute = buffer[9];\n\t\t\t\ttocentry->cdte_addr.msf.second = buffer[10];\n\t\t\t\ttocentry->cdte_addr.msf.frame = buffer[11];\n\t\t\t} else\n\t\t\t\ttocentry->cdte_addr.lba =\n\t\t\t\t    (((((buffer[8] << 8) + buffer[9]) << 8)\n\t\t\t\t      + buffer[10]) << 8) + buffer[11];\n\n\t\t\treturn r ? -EIO : 0;\n\t\t}\n\n\tdefault:\n\n\t\treturn -ENOSYS;\n\t}\n}\n\nstatic int pcd_get_mcn(struct cdrom_device_info *cdi, struct cdrom_mcn *mcn)\n{\n\tchar cmd[12] =\n\t    { GPCMD_READ_SUBCHANNEL, 0, 0x40, 2, 0, 0, 0, 0, 24, 0, 0, 0 };\n\tchar buffer[32];\n\n\tif (pcd_atapi(cdi->handle, cmd, 24, buffer, \"get mcn\"))\n\t\treturn -EIO;\n\n\tmemcpy(mcn->medium_catalog_number, buffer + 9, 13);\n\tmcn->medium_catalog_number[13] = 0;\n\n\treturn 0;\n}\n\nstatic int __init pcd_init(void)\n{\n\tstruct pcd_unit *cd;\n\tint unit;\n\n\tif (disable)\n\t\treturn -EINVAL;\n\n\tpcd_init_units();\n\n\tif (pcd_detect())\n\t\treturn -ENODEV;\n\n\t/* get the atapi capabilities page */\n\tpcd_probe_capabilities();\n\n\tif (register_blkdev(major, name)) {\n\t\tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {\n\t\t\tif (!cd->disk)\n\t\t\t\tcontinue;\n\n\t\t\tblk_cleanup_queue(cd->disk->queue);\n\t\t\tblk_mq_free_tag_set(&cd->tag_set);\n\t\t\tput_disk(cd->disk);\n\t\t}\n\t\treturn -EBUSY;\n\t}\n\n\tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {\n\t\tif (cd->present) {\n\t\t\tregister_cdrom(&cd->info);\n\t\t\tcd->disk->private_data = cd;\n\t\t\tadd_disk(cd->disk);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit pcd_exit(void)\n{\n\tstruct pcd_unit *cd;\n\tint unit;\n\n\tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {\n\t\tif (!cd->disk)\n\t\t\tcontinue;\n\n\t\tif (cd->present) {\n\t\t\tdel_gendisk(cd->disk);\n\t\t\tpi_release(cd->pi);\n\t\t\tunregister_cdrom(&cd->info);\n\t\t}\n\t\tblk_cleanup_queue(cd->disk->queue);\n\t\tblk_mq_free_tag_set(&cd->tag_set);\n\t\tput_disk(cd->disk);\n\t}\n\tunregister_blkdev(major, name);\n\tpi_unregister_driver(par_drv);\n}\n\nMODULE_LICENSE(\"GPL\");\nmodule_init(pcd_init)\nmodule_exit(pcd_exit)\n"], "filenames": ["drivers/block/paride/pcd.c"], "buggy_code_start_loc": [316], "buggy_code_end_loc": [1034], "fixing_code_start_loc": [317], "fixing_code_end_loc": [1047], "type": "CWE-476", "message": "An issue was discovered in the Linux kernel before 5.0.9. There is a NULL pointer dereference for a cd data structure if alloc_disk fails in drivers/block/paride/pf.c.", "other": {"cve": {"id": "CVE-2019-15923", "sourceIdentifier": "cve@mitre.org", "published": "2019-09-04T19:15:12.347", "lastModified": "2019-10-04T09:15:13.650", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "An issue was discovered in the Linux kernel before 5.0.9. There is a NULL pointer dereference for a cd data structure if alloc_disk fails in drivers/block/paride/pf.c."}, {"lang": "es", "value": "Se detect\u00f3 un problema en el kernel de Linux versiones anteriores a 5.0.9. Se presenta una desreferencia del puntero NULL para una estructura de datos cd si la funci\u00f3n alloc_disk presenta un fallo en el archivo drivers/block/paride/pf.c."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.0.9", "matchCriteriaId": "6F073F68-1CAE-4D5C-8FF9-E86E008F043B"}]}]}], "references": [{"url": "https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.0.9", "source": "cve@mitre.org", "tags": ["Mailing List", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/f0d1762554014ce0ae347b9f0d088f2c157c8c72", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20191004-0001/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/f0d1762554014ce0ae347b9f0d088f2c157c8c72"}}