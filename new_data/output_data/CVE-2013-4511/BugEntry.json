{"buggy_code": ["/*\n * drivers/uio/uio.c\n *\n * Copyright(C) 2005, Benedikt Spranger <b.spranger@linutronix.de>\n * Copyright(C) 2005, Thomas Gleixner <tglx@linutronix.de>\n * Copyright(C) 2006, Hans J. Koch <hjk@hansjkoch.de>\n * Copyright(C) 2006, Greg Kroah-Hartman <greg@kroah.com>\n *\n * Userspace IO\n *\n * Base Functions\n *\n * Licensed under the GPLv2 only.\n */\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/device.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/cdev.h>\n#include <linux/uio_driver.h>\n\n#define UIO_MAX_DEVICES\t\t(1U << MINORBITS)\n\nstruct uio_device {\n\tstruct module\t\t*owner;\n\tstruct device\t\t*dev;\n\tint\t\t\tminor;\n\tatomic_t\t\tevent;\n\tstruct fasync_struct\t*async_queue;\n\twait_queue_head_t\twait;\n\tstruct uio_info\t\t*info;\n\tstruct kobject\t\t*map_dir;\n\tstruct kobject\t\t*portio_dir;\n};\n\nstatic int uio_major;\nstatic struct cdev *uio_cdev;\nstatic DEFINE_IDR(uio_idr);\nstatic const struct file_operations uio_fops;\n\n/* Protect idr accesses */\nstatic DEFINE_MUTEX(minor_lock);\n\n/*\n * attributes\n */\n\nstruct uio_map {\n\tstruct kobject kobj;\n\tstruct uio_mem *mem;\n};\n#define to_map(map) container_of(map, struct uio_map, kobj)\n\nstatic ssize_t map_name_show(struct uio_mem *mem, char *buf)\n{\n\tif (unlikely(!mem->name))\n\t\tmem->name = \"\";\n\n\treturn sprintf(buf, \"%s\\n\", mem->name);\n}\n\nstatic ssize_t map_addr_show(struct uio_mem *mem, char *buf)\n{\n\treturn sprintf(buf, \"0x%llx\\n\", (unsigned long long)mem->addr);\n}\n\nstatic ssize_t map_size_show(struct uio_mem *mem, char *buf)\n{\n\treturn sprintf(buf, \"0x%lx\\n\", mem->size);\n}\n\nstatic ssize_t map_offset_show(struct uio_mem *mem, char *buf)\n{\n\treturn sprintf(buf, \"0x%llx\\n\", (unsigned long long)mem->addr & ~PAGE_MASK);\n}\n\nstruct map_sysfs_entry {\n\tstruct attribute attr;\n\tssize_t (*show)(struct uio_mem *, char *);\n\tssize_t (*store)(struct uio_mem *, const char *, size_t);\n};\n\nstatic struct map_sysfs_entry name_attribute =\n\t__ATTR(name, S_IRUGO, map_name_show, NULL);\nstatic struct map_sysfs_entry addr_attribute =\n\t__ATTR(addr, S_IRUGO, map_addr_show, NULL);\nstatic struct map_sysfs_entry size_attribute =\n\t__ATTR(size, S_IRUGO, map_size_show, NULL);\nstatic struct map_sysfs_entry offset_attribute =\n\t__ATTR(offset, S_IRUGO, map_offset_show, NULL);\n\nstatic struct attribute *attrs[] = {\n\t&name_attribute.attr,\n\t&addr_attribute.attr,\n\t&size_attribute.attr,\n\t&offset_attribute.attr,\n\tNULL,\t/* need to NULL terminate the list of attributes */\n};\n\nstatic void map_release(struct kobject *kobj)\n{\n\tstruct uio_map *map = to_map(kobj);\n\tkfree(map);\n}\n\nstatic ssize_t map_type_show(struct kobject *kobj, struct attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct uio_map *map = to_map(kobj);\n\tstruct uio_mem *mem = map->mem;\n\tstruct map_sysfs_entry *entry;\n\n\tentry = container_of(attr, struct map_sysfs_entry, attr);\n\n\tif (!entry->show)\n\t\treturn -EIO;\n\n\treturn entry->show(mem, buf);\n}\n\nstatic const struct sysfs_ops map_sysfs_ops = {\n\t.show = map_type_show,\n};\n\nstatic struct kobj_type map_attr_type = {\n\t.release\t= map_release,\n\t.sysfs_ops\t= &map_sysfs_ops,\n\t.default_attrs\t= attrs,\n};\n\nstruct uio_portio {\n\tstruct kobject kobj;\n\tstruct uio_port *port;\n};\n#define to_portio(portio) container_of(portio, struct uio_portio, kobj)\n\nstatic ssize_t portio_name_show(struct uio_port *port, char *buf)\n{\n\tif (unlikely(!port->name))\n\t\tport->name = \"\";\n\n\treturn sprintf(buf, \"%s\\n\", port->name);\n}\n\nstatic ssize_t portio_start_show(struct uio_port *port, char *buf)\n{\n\treturn sprintf(buf, \"0x%lx\\n\", port->start);\n}\n\nstatic ssize_t portio_size_show(struct uio_port *port, char *buf)\n{\n\treturn sprintf(buf, \"0x%lx\\n\", port->size);\n}\n\nstatic ssize_t portio_porttype_show(struct uio_port *port, char *buf)\n{\n\tconst char *porttypes[] = {\"none\", \"x86\", \"gpio\", \"other\"};\n\n\tif ((port->porttype < 0) || (port->porttype > UIO_PORT_OTHER))\n\t\treturn -EINVAL;\n\n\treturn sprintf(buf, \"port_%s\\n\", porttypes[port->porttype]);\n}\n\nstruct portio_sysfs_entry {\n\tstruct attribute attr;\n\tssize_t (*show)(struct uio_port *, char *);\n\tssize_t (*store)(struct uio_port *, const char *, size_t);\n};\n\nstatic struct portio_sysfs_entry portio_name_attribute =\n\t__ATTR(name, S_IRUGO, portio_name_show, NULL);\nstatic struct portio_sysfs_entry portio_start_attribute =\n\t__ATTR(start, S_IRUGO, portio_start_show, NULL);\nstatic struct portio_sysfs_entry portio_size_attribute =\n\t__ATTR(size, S_IRUGO, portio_size_show, NULL);\nstatic struct portio_sysfs_entry portio_porttype_attribute =\n\t__ATTR(porttype, S_IRUGO, portio_porttype_show, NULL);\n\nstatic struct attribute *portio_attrs[] = {\n\t&portio_name_attribute.attr,\n\t&portio_start_attribute.attr,\n\t&portio_size_attribute.attr,\n\t&portio_porttype_attribute.attr,\n\tNULL,\n};\n\nstatic void portio_release(struct kobject *kobj)\n{\n\tstruct uio_portio *portio = to_portio(kobj);\n\tkfree(portio);\n}\n\nstatic ssize_t portio_type_show(struct kobject *kobj, struct attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct uio_portio *portio = to_portio(kobj);\n\tstruct uio_port *port = portio->port;\n\tstruct portio_sysfs_entry *entry;\n\n\tentry = container_of(attr, struct portio_sysfs_entry, attr);\n\n\tif (!entry->show)\n\t\treturn -EIO;\n\n\treturn entry->show(port, buf);\n}\n\nstatic const struct sysfs_ops portio_sysfs_ops = {\n\t.show = portio_type_show,\n};\n\nstatic struct kobj_type portio_attr_type = {\n\t.release\t= portio_release,\n\t.sysfs_ops\t= &portio_sysfs_ops,\n\t.default_attrs\t= portio_attrs,\n};\n\nstatic ssize_t name_show(struct device *dev,\n\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct uio_device *idev = dev_get_drvdata(dev);\n\treturn sprintf(buf, \"%s\\n\", idev->info->name);\n}\nstatic DEVICE_ATTR_RO(name);\n\nstatic ssize_t version_show(struct device *dev,\n\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct uio_device *idev = dev_get_drvdata(dev);\n\treturn sprintf(buf, \"%s\\n\", idev->info->version);\n}\nstatic DEVICE_ATTR_RO(version);\n\nstatic ssize_t event_show(struct device *dev,\n\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct uio_device *idev = dev_get_drvdata(dev);\n\treturn sprintf(buf, \"%u\\n\", (unsigned int)atomic_read(&idev->event));\n}\nstatic DEVICE_ATTR_RO(event);\n\nstatic struct attribute *uio_attrs[] = {\n\t&dev_attr_name.attr,\n\t&dev_attr_version.attr,\n\t&dev_attr_event.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(uio);\n\n/* UIO class infrastructure */\nstatic struct class uio_class = {\n\t.name = \"uio\",\n\t.dev_groups = uio_groups,\n};\n\n/*\n * device functions\n */\nstatic int uio_dev_add_attributes(struct uio_device *idev)\n{\n\tint ret;\n\tint mi, pi;\n\tint map_found = 0;\n\tint portio_found = 0;\n\tstruct uio_mem *mem;\n\tstruct uio_map *map;\n\tstruct uio_port *port;\n\tstruct uio_portio *portio;\n\n\tfor (mi = 0; mi < MAX_UIO_MAPS; mi++) {\n\t\tmem = &idev->info->mem[mi];\n\t\tif (mem->size == 0)\n\t\t\tbreak;\n\t\tif (!map_found) {\n\t\t\tmap_found = 1;\n\t\t\tidev->map_dir = kobject_create_and_add(\"maps\",\n\t\t\t\t\t\t\t&idev->dev->kobj);\n\t\t\tif (!idev->map_dir)\n\t\t\t\tgoto err_map;\n\t\t}\n\t\tmap = kzalloc(sizeof(*map), GFP_KERNEL);\n\t\tif (!map)\n\t\t\tgoto err_map;\n\t\tkobject_init(&map->kobj, &map_attr_type);\n\t\tmap->mem = mem;\n\t\tmem->map = map;\n\t\tret = kobject_add(&map->kobj, idev->map_dir, \"map%d\", mi);\n\t\tif (ret)\n\t\t\tgoto err_map;\n\t\tret = kobject_uevent(&map->kobj, KOBJ_ADD);\n\t\tif (ret)\n\t\t\tgoto err_map;\n\t}\n\n\tfor (pi = 0; pi < MAX_UIO_PORT_REGIONS; pi++) {\n\t\tport = &idev->info->port[pi];\n\t\tif (port->size == 0)\n\t\t\tbreak;\n\t\tif (!portio_found) {\n\t\t\tportio_found = 1;\n\t\t\tidev->portio_dir = kobject_create_and_add(\"portio\",\n\t\t\t\t\t\t\t&idev->dev->kobj);\n\t\t\tif (!idev->portio_dir)\n\t\t\t\tgoto err_portio;\n\t\t}\n\t\tportio = kzalloc(sizeof(*portio), GFP_KERNEL);\n\t\tif (!portio)\n\t\t\tgoto err_portio;\n\t\tkobject_init(&portio->kobj, &portio_attr_type);\n\t\tportio->port = port;\n\t\tport->portio = portio;\n\t\tret = kobject_add(&portio->kobj, idev->portio_dir,\n\t\t\t\t\t\t\t\"port%d\", pi);\n\t\tif (ret)\n\t\t\tgoto err_portio;\n\t\tret = kobject_uevent(&portio->kobj, KOBJ_ADD);\n\t\tif (ret)\n\t\t\tgoto err_portio;\n\t}\n\n\treturn 0;\n\nerr_portio:\n\tfor (pi--; pi >= 0; pi--) {\n\t\tport = &idev->info->port[pi];\n\t\tportio = port->portio;\n\t\tkobject_put(&portio->kobj);\n\t}\n\tkobject_put(idev->portio_dir);\nerr_map:\n\tfor (mi--; mi>=0; mi--) {\n\t\tmem = &idev->info->mem[mi];\n\t\tmap = mem->map;\n\t\tkobject_put(&map->kobj);\n\t}\n\tkobject_put(idev->map_dir);\n\tdev_err(idev->dev, \"error creating sysfs files (%d)\\n\", ret);\n\treturn ret;\n}\n\nstatic void uio_dev_del_attributes(struct uio_device *idev)\n{\n\tint i;\n\tstruct uio_mem *mem;\n\tstruct uio_port *port;\n\n\tfor (i = 0; i < MAX_UIO_MAPS; i++) {\n\t\tmem = &idev->info->mem[i];\n\t\tif (mem->size == 0)\n\t\t\tbreak;\n\t\tkobject_put(&mem->map->kobj);\n\t}\n\tkobject_put(idev->map_dir);\n\n\tfor (i = 0; i < MAX_UIO_PORT_REGIONS; i++) {\n\t\tport = &idev->info->port[i];\n\t\tif (port->size == 0)\n\t\t\tbreak;\n\t\tkobject_put(&port->portio->kobj);\n\t}\n\tkobject_put(idev->portio_dir);\n}\n\nstatic int uio_get_minor(struct uio_device *idev)\n{\n\tint retval = -ENOMEM;\n\n\tmutex_lock(&minor_lock);\n\tretval = idr_alloc(&uio_idr, idev, 0, UIO_MAX_DEVICES, GFP_KERNEL);\n\tif (retval >= 0) {\n\t\tidev->minor = retval;\n\t\tretval = 0;\n\t} else if (retval == -ENOSPC) {\n\t\tdev_err(idev->dev, \"too many uio devices\\n\");\n\t\tretval = -EINVAL;\n\t}\n\tmutex_unlock(&minor_lock);\n\treturn retval;\n}\n\nstatic void uio_free_minor(struct uio_device *idev)\n{\n\tmutex_lock(&minor_lock);\n\tidr_remove(&uio_idr, idev->minor);\n\tmutex_unlock(&minor_lock);\n}\n\n/**\n * uio_event_notify - trigger an interrupt event\n * @info: UIO device capabilities\n */\nvoid uio_event_notify(struct uio_info *info)\n{\n\tstruct uio_device *idev = info->uio_dev;\n\n\tatomic_inc(&idev->event);\n\twake_up_interruptible(&idev->wait);\n\tkill_fasync(&idev->async_queue, SIGIO, POLL_IN);\n}\nEXPORT_SYMBOL_GPL(uio_event_notify);\n\n/**\n * uio_interrupt - hardware interrupt handler\n * @irq: IRQ number, can be UIO_IRQ_CYCLIC for cyclic timer\n * @dev_id: Pointer to the devices uio_device structure\n */\nstatic irqreturn_t uio_interrupt(int irq, void *dev_id)\n{\n\tstruct uio_device *idev = (struct uio_device *)dev_id;\n\tirqreturn_t ret = idev->info->handler(irq, idev->info);\n\n\tif (ret == IRQ_HANDLED)\n\t\tuio_event_notify(idev->info);\n\n\treturn ret;\n}\n\nstruct uio_listener {\n\tstruct uio_device *dev;\n\ts32 event_count;\n};\n\nstatic int uio_open(struct inode *inode, struct file *filep)\n{\n\tstruct uio_device *idev;\n\tstruct uio_listener *listener;\n\tint ret = 0;\n\n\tmutex_lock(&minor_lock);\n\tidev = idr_find(&uio_idr, iminor(inode));\n\tmutex_unlock(&minor_lock);\n\tif (!idev) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tif (!try_module_get(idev->owner)) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tlistener = kmalloc(sizeof(*listener), GFP_KERNEL);\n\tif (!listener) {\n\t\tret = -ENOMEM;\n\t\tgoto err_alloc_listener;\n\t}\n\n\tlistener->dev = idev;\n\tlistener->event_count = atomic_read(&idev->event);\n\tfilep->private_data = listener;\n\n\tif (idev->info->open) {\n\t\tret = idev->info->open(idev->info, inode);\n\t\tif (ret)\n\t\t\tgoto err_infoopen;\n\t}\n\treturn 0;\n\nerr_infoopen:\n\tkfree(listener);\n\nerr_alloc_listener:\n\tmodule_put(idev->owner);\n\nout:\n\treturn ret;\n}\n\nstatic int uio_fasync(int fd, struct file *filep, int on)\n{\n\tstruct uio_listener *listener = filep->private_data;\n\tstruct uio_device *idev = listener->dev;\n\n\treturn fasync_helper(fd, filep, on, &idev->async_queue);\n}\n\nstatic int uio_release(struct inode *inode, struct file *filep)\n{\n\tint ret = 0;\n\tstruct uio_listener *listener = filep->private_data;\n\tstruct uio_device *idev = listener->dev;\n\n\tif (idev->info->release)\n\t\tret = idev->info->release(idev->info, inode);\n\n\tmodule_put(idev->owner);\n\tkfree(listener);\n\treturn ret;\n}\n\nstatic unsigned int uio_poll(struct file *filep, poll_table *wait)\n{\n\tstruct uio_listener *listener = filep->private_data;\n\tstruct uio_device *idev = listener->dev;\n\n\tif (!idev->info->irq)\n\t\treturn -EIO;\n\n\tpoll_wait(filep, &idev->wait, wait);\n\tif (listener->event_count != atomic_read(&idev->event))\n\t\treturn POLLIN | POLLRDNORM;\n\treturn 0;\n}\n\nstatic ssize_t uio_read(struct file *filep, char __user *buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct uio_listener *listener = filep->private_data;\n\tstruct uio_device *idev = listener->dev;\n\tDECLARE_WAITQUEUE(wait, current);\n\tssize_t retval;\n\ts32 event_count;\n\n\tif (!idev->info->irq)\n\t\treturn -EIO;\n\n\tif (count != sizeof(s32))\n\t\treturn -EINVAL;\n\n\tadd_wait_queue(&idev->wait, &wait);\n\n\tdo {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\n\t\tevent_count = atomic_read(&idev->event);\n\t\tif (event_count != listener->event_count) {\n\t\t\tif (copy_to_user(buf, &event_count, count))\n\t\t\t\tretval = -EFAULT;\n\t\t\telse {\n\t\t\t\tlistener->event_count = event_count;\n\t\t\t\tretval = count;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tif (filep->f_flags & O_NONBLOCK) {\n\t\t\tretval = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (signal_pending(current)) {\n\t\t\tretval = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tschedule();\n\t} while (1);\n\n\t__set_current_state(TASK_RUNNING);\n\tremove_wait_queue(&idev->wait, &wait);\n\n\treturn retval;\n}\n\nstatic ssize_t uio_write(struct file *filep, const char __user *buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct uio_listener *listener = filep->private_data;\n\tstruct uio_device *idev = listener->dev;\n\tssize_t retval;\n\ts32 irq_on;\n\n\tif (!idev->info->irq)\n\t\treturn -EIO;\n\n\tif (count != sizeof(s32))\n\t\treturn -EINVAL;\n\n\tif (!idev->info->irqcontrol)\n\t\treturn -ENOSYS;\n\n\tif (copy_from_user(&irq_on, buf, count))\n\t\treturn -EFAULT;\n\n\tretval = idev->info->irqcontrol(idev->info, irq_on);\n\n\treturn retval ? retval : sizeof(s32);\n}\n\nstatic int uio_find_mem_index(struct vm_area_struct *vma)\n{\n\tstruct uio_device *idev = vma->vm_private_data;\n\n\tif (vma->vm_pgoff < MAX_UIO_MAPS) {\n\t\tif (idev->info->mem[vma->vm_pgoff].size == 0)\n\t\t\treturn -1;\n\t\treturn (int)vma->vm_pgoff;\n\t}\n\treturn -1;\n}\n\nstatic int uio_vma_fault(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\tstruct uio_device *idev = vma->vm_private_data;\n\tstruct page *page;\n\tunsigned long offset;\n\n\tint mi = uio_find_mem_index(vma);\n\tif (mi < 0)\n\t\treturn VM_FAULT_SIGBUS;\n\n\t/*\n\t * We need to subtract mi because userspace uses offset = N*PAGE_SIZE\n\t * to use mem[N].\n\t */\n\toffset = (vmf->pgoff - mi) << PAGE_SHIFT;\n\n\tif (idev->info->mem[mi].memtype == UIO_MEM_LOGICAL)\n\t\tpage = virt_to_page(idev->info->mem[mi].addr + offset);\n\telse\n\t\tpage = vmalloc_to_page((void *)(unsigned long)idev->info->mem[mi].addr + offset);\n\tget_page(page);\n\tvmf->page = page;\n\treturn 0;\n}\n\nstatic const struct vm_operations_struct uio_logical_vm_ops = {\n\t.fault = uio_vma_fault,\n};\n\nstatic int uio_mmap_logical(struct vm_area_struct *vma)\n{\n\tvma->vm_flags |= VM_DONTEXPAND | VM_DONTDUMP;\n\tvma->vm_ops = &uio_logical_vm_ops;\n\treturn 0;\n}\n\nstatic const struct vm_operations_struct uio_physical_vm_ops = {\n#ifdef CONFIG_HAVE_IOREMAP_PROT\n\t.access = generic_access_phys,\n#endif\n};\n\nstatic int uio_mmap_physical(struct vm_area_struct *vma)\n{\n\tstruct uio_device *idev = vma->vm_private_data;\n\tint mi = uio_find_mem_index(vma);\n\tif (mi < 0)\n\t\treturn -EINVAL;\n\n\tvma->vm_ops = &uio_physical_vm_ops;\n\n\tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n\n\treturn remap_pfn_range(vma,\n\t\t\t       vma->vm_start,\n\t\t\t       idev->info->mem[mi].addr >> PAGE_SHIFT,\n\t\t\t       vma->vm_end - vma->vm_start,\n\t\t\t       vma->vm_page_prot);\n}\n\nstatic int uio_mmap(struct file *filep, struct vm_area_struct *vma)\n{\n\tstruct uio_listener *listener = filep->private_data;\n\tstruct uio_device *idev = listener->dev;\n\tint mi;\n\tunsigned long requested_pages, actual_pages;\n\tint ret = 0;\n\n\tif (vma->vm_end < vma->vm_start)\n\t\treturn -EINVAL;\n\n\tvma->vm_private_data = idev;\n\n\tmi = uio_find_mem_index(vma);\n\tif (mi < 0)\n\t\treturn -EINVAL;\n\n\trequested_pages = vma_pages(vma);\n\tactual_pages = ((idev->info->mem[mi].addr & ~PAGE_MASK)\n\t\t\t+ idev->info->mem[mi].size + PAGE_SIZE -1) >> PAGE_SHIFT;\n\tif (requested_pages > actual_pages)\n\t\treturn -EINVAL;\n\n\tif (idev->info->mmap) {\n\t\tret = idev->info->mmap(idev->info, vma);\n\t\treturn ret;\n\t}\n\n\tswitch (idev->info->mem[mi].memtype) {\n\t\tcase UIO_MEM_PHYS:\n\t\t\treturn uio_mmap_physical(vma);\n\t\tcase UIO_MEM_LOGICAL:\n\t\tcase UIO_MEM_VIRTUAL:\n\t\t\treturn uio_mmap_logical(vma);\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct file_operations uio_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= uio_open,\n\t.release\t= uio_release,\n\t.read\t\t= uio_read,\n\t.write\t\t= uio_write,\n\t.mmap\t\t= uio_mmap,\n\t.poll\t\t= uio_poll,\n\t.fasync\t\t= uio_fasync,\n\t.llseek\t\t= noop_llseek,\n};\n\nstatic int uio_major_init(void)\n{\n\tstatic const char name[] = \"uio\";\n\tstruct cdev *cdev = NULL;\n\tdev_t uio_dev = 0;\n\tint result;\n\n\tresult = alloc_chrdev_region(&uio_dev, 0, UIO_MAX_DEVICES, name);\n\tif (result)\n\t\tgoto out;\n\n\tresult = -ENOMEM;\n\tcdev = cdev_alloc();\n\tif (!cdev)\n\t\tgoto out_unregister;\n\n\tcdev->owner = THIS_MODULE;\n\tcdev->ops = &uio_fops;\n\tkobject_set_name(&cdev->kobj, \"%s\", name);\n\n\tresult = cdev_add(cdev, uio_dev, UIO_MAX_DEVICES);\n\tif (result)\n\t\tgoto out_put;\n\n\tuio_major = MAJOR(uio_dev);\n\tuio_cdev = cdev;\n\treturn 0;\nout_put:\n\tkobject_put(&cdev->kobj);\nout_unregister:\n\tunregister_chrdev_region(uio_dev, UIO_MAX_DEVICES);\nout:\n\treturn result;\n}\n\nstatic void uio_major_cleanup(void)\n{\n\tunregister_chrdev_region(MKDEV(uio_major, 0), UIO_MAX_DEVICES);\n\tcdev_del(uio_cdev);\n}\n\nstatic int init_uio_class(void)\n{\n\tint ret;\n\n\t/* This is the first time in here, set everything up properly */\n\tret = uio_major_init();\n\tif (ret)\n\t\tgoto exit;\n\n\tret = class_register(&uio_class);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"class_register failed for uio\\n\");\n\t\tgoto err_class_register;\n\t}\n\treturn 0;\n\nerr_class_register:\n\tuio_major_cleanup();\nexit:\n\treturn ret;\n}\n\nstatic void release_uio_class(void)\n{\n\tclass_unregister(&uio_class);\n\tuio_major_cleanup();\n}\n\n/**\n * uio_register_device - register a new userspace IO device\n * @owner:\tmodule that creates the new device\n * @parent:\tparent device\n * @info:\tUIO device capabilities\n *\n * returns zero on success or a negative error code.\n */\nint __uio_register_device(struct module *owner,\n\t\t\t  struct device *parent,\n\t\t\t  struct uio_info *info)\n{\n\tstruct uio_device *idev;\n\tint ret = 0;\n\n\tif (!parent || !info || !info->name || !info->version)\n\t\treturn -EINVAL;\n\n\tinfo->uio_dev = NULL;\n\n\tidev = kzalloc(sizeof(*idev), GFP_KERNEL);\n\tif (!idev) {\n\t\tret = -ENOMEM;\n\t\tgoto err_kzalloc;\n\t}\n\n\tidev->owner = owner;\n\tidev->info = info;\n\tinit_waitqueue_head(&idev->wait);\n\tatomic_set(&idev->event, 0);\n\n\tret = uio_get_minor(idev);\n\tif (ret)\n\t\tgoto err_get_minor;\n\n\tidev->dev = device_create(&uio_class, parent,\n\t\t\t\t  MKDEV(uio_major, idev->minor), idev,\n\t\t\t\t  \"uio%d\", idev->minor);\n\tif (IS_ERR(idev->dev)) {\n\t\tprintk(KERN_ERR \"UIO: device register failed\\n\");\n\t\tret = PTR_ERR(idev->dev);\n\t\tgoto err_device_create;\n\t}\n\n\tret = uio_dev_add_attributes(idev);\n\tif (ret)\n\t\tgoto err_uio_dev_add_attributes;\n\n\tinfo->uio_dev = idev;\n\n\tif (info->irq && (info->irq != UIO_IRQ_CUSTOM)) {\n\t\tret = request_irq(info->irq, uio_interrupt,\n\t\t\t\t  info->irq_flags, info->name, idev);\n\t\tif (ret)\n\t\t\tgoto err_request_irq;\n\t}\n\n\treturn 0;\n\nerr_request_irq:\n\tuio_dev_del_attributes(idev);\nerr_uio_dev_add_attributes:\n\tdevice_destroy(&uio_class, MKDEV(uio_major, idev->minor));\nerr_device_create:\n\tuio_free_minor(idev);\nerr_get_minor:\n\tkfree(idev);\nerr_kzalloc:\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(__uio_register_device);\n\n/**\n * uio_unregister_device - unregister a industrial IO device\n * @info:\tUIO device capabilities\n *\n */\nvoid uio_unregister_device(struct uio_info *info)\n{\n\tstruct uio_device *idev;\n\n\tif (!info || !info->uio_dev)\n\t\treturn;\n\n\tidev = info->uio_dev;\n\n\tuio_free_minor(idev);\n\n\tif (info->irq && (info->irq != UIO_IRQ_CUSTOM))\n\t\tfree_irq(info->irq, idev);\n\n\tuio_dev_del_attributes(idev);\n\n\tdevice_destroy(&uio_class, MKDEV(uio_major, idev->minor));\n\tkfree(idev);\n\n\treturn;\n}\nEXPORT_SYMBOL_GPL(uio_unregister_device);\n\nstatic int __init uio_init(void)\n{\n\treturn init_uio_class();\n}\n\nstatic void __exit uio_exit(void)\n{\n\trelease_uio_class();\n}\n\nmodule_init(uio_init)\nmodule_exit(uio_exit)\nMODULE_LICENSE(\"GPL v2\");\n", "/*\n * BRIEF MODULE DESCRIPTION\n *\tAu1100 LCD Driver.\n *\n * Rewritten for 2.6 by Embedded Alley Solutions\n * \t<source@embeddedalley.com>, based on submissions by\n *  \tKarl Lessard <klessard@sunrisetelecom.com>\n *  \t<c.pellegrin@exadron.com>\n *\n * PM support added by Rodolfo Giometti <giometti@linux.it>\n * Cursor enable/disable by Rodolfo Giometti <giometti@linux.it>\n *\n * Copyright 2002 MontaVista Software\n * Author: MontaVista Software, Inc.\n *\t\tppopov@mvista.com or source@mvista.com\n *\n * Copyright 2002 Alchemy Semiconductor\n * Author: Alchemy Semiconductor\n *\n * Based on:\n * linux/drivers/video/skeletonfb.c -- Skeleton for a frame buffer device\n *  Created 28 Dec 1997 by Geert Uytterhoeven\n *\n *  This program is free software; you can redistribute\t it and/or modify it\n *  under  the terms of\t the GNU General  Public License as published by the\n *  Free Software Foundation;  either version 2 of the\tLicense, or (at your\n *  option) any later version.\n *\n *  THIS  SOFTWARE  IS PROVIDED\t  ``AS\tIS'' AND   ANY\tEXPRESS OR IMPLIED\n *  WARRANTIES,\t  INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF\n *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN\n *  NO\tEVENT  SHALL   THE AUTHOR  BE\t LIABLE FOR ANY\t  DIRECT, INDIRECT,\n *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED\t  TO, PROCUREMENT OF  SUBSTITUTE GOODS\tOR SERVICES; LOSS OF\n *  USE, DATA,\tOR PROFITS; OR\tBUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n *  ANY THEORY OF LIABILITY, WHETHER IN\t CONTRACT, STRICT LIABILITY, OR TORT\n *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n *  You should have received a copy of the  GNU General Public License along\n *  with this program; if not, write  to the Free Software Foundation, Inc.,\n *  675 Mass Ave, Cambridge, MA 02139, USA.\n */\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/fb.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/ctype.h>\n#include <linux/dma-mapping.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#include <asm/mach-au1x00/au1000.h>\n\n#define DEBUG 0\n\n#include \"au1100fb.h\"\n\n#define DRIVER_NAME \"au1100fb\"\n#define DRIVER_DESC \"LCD controller driver for AU1100 processors\"\n\n#define to_au1100fb_device(_info) \\\n\t  (_info ? container_of(_info, struct au1100fb_device, info) : NULL);\n\n/* Bitfields format supported by the controller. Note that the order of formats\n * SHOULD be the same as in the LCD_CONTROL_SBPPF field, so we can retrieve the\n * right pixel format by doing rgb_bitfields[LCD_CONTROL_SBPPF_XXX >> LCD_CONTROL_SBPPF]\n */\nstruct fb_bitfield rgb_bitfields[][4] =\n{\n  \t/*     Red, \t   Green, \t Blue, \t     Transp   */\n\t{ { 10, 6, 0 }, { 5, 5, 0 }, { 0, 5, 0 }, { 0, 0, 0 } },\n\t{ { 11, 5, 0 }, { 5, 6, 0 }, { 0, 5, 0 }, { 0, 0, 0 } },\n\t{ { 11, 5, 0 }, { 6, 5, 0 }, { 0, 6, 0 }, { 0, 0, 0 } },\n\t{ { 10, 5, 0 }, { 5, 5, 0 }, { 0, 5, 0 }, { 15, 1, 0 } },\n\t{ { 11, 5, 0 }, { 6, 5, 0 }, { 1, 5, 0 }, { 0, 1, 0 } },\n\n\t/* The last is used to describe 12bpp format */\n\t{ { 8, 4, 0 },  { 4, 4, 0 }, { 0, 4, 0 }, { 0, 0, 0 } },\n};\n\nstatic struct fb_fix_screeninfo au1100fb_fix = {\n\t.id\t\t= \"AU1100 FB\",\n\t.xpanstep \t= 1,\n\t.ypanstep \t= 1,\n\t.type\t\t= FB_TYPE_PACKED_PIXELS,\n\t.accel\t\t= FB_ACCEL_NONE,\n};\n\nstatic struct fb_var_screeninfo au1100fb_var = {\n\t.activate\t= FB_ACTIVATE_NOW,\n\t.height\t\t= -1,\n\t.width\t\t= -1,\n\t.vmode\t\t= FB_VMODE_NONINTERLACED,\n};\n\n/* fb_blank\n * Blank the screen. Depending on the mode, the screen will be\n * activated with the backlight color, or desactivated\n */\nstatic int au1100fb_fb_blank(int blank_mode, struct fb_info *fbi)\n{\n\tstruct au1100fb_device *fbdev = to_au1100fb_device(fbi);\n\n\tprint_dbg(\"fb_blank %d %p\", blank_mode, fbi);\n\n\tswitch (blank_mode) {\n\n\tcase VESA_NO_BLANKING:\n\t\t/* Turn on panel */\n\t\tfbdev->regs->lcd_control |= LCD_CONTROL_GO;\n\t\tau_sync();\n\t\tbreak;\n\n\tcase VESA_VSYNC_SUSPEND:\n\tcase VESA_HSYNC_SUSPEND:\n\tcase VESA_POWERDOWN:\n\t\t/* Turn off panel */\n\t\tfbdev->regs->lcd_control &= ~LCD_CONTROL_GO;\n\t\tau_sync();\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\n\t}\n\treturn 0;\n}\n\n/*\n * Set hardware with var settings. This will enable the controller with a specific\n * mode, normally validated with the fb_check_var method\n\t */\nint au1100fb_setmode(struct au1100fb_device *fbdev)\n{\n\tstruct fb_info *info = &fbdev->info;\n\tu32 words;\n\tint index;\n\n\tif (!fbdev)\n\t\treturn -EINVAL;\n\n\t/* Update var-dependent FB info */\n\tif (panel_is_active(fbdev->panel) || panel_is_color(fbdev->panel)) {\n\t\tif (info->var.bits_per_pixel <= 8) {\n\t\t\t/* palettized */\n\t\t\tinfo->var.red.offset    = 0;\n\t\t\tinfo->var.red.length    = info->var.bits_per_pixel;\n\t\t\tinfo->var.red.msb_right = 0;\n\n\t\t\tinfo->var.green.offset  = 0;\n\t\t\tinfo->var.green.length  = info->var.bits_per_pixel;\n\t\t\tinfo->var.green.msb_right = 0;\n\n\t\t\tinfo->var.blue.offset   = 0;\n\t\t\tinfo->var.blue.length   = info->var.bits_per_pixel;\n\t\t\tinfo->var.blue.msb_right = 0;\n\n\t\t\tinfo->var.transp.offset = 0;\n\t\t\tinfo->var.transp.length = 0;\n\t\t\tinfo->var.transp.msb_right = 0;\n\n\t\t\tinfo->fix.visual = FB_VISUAL_PSEUDOCOLOR;\n\t\t\tinfo->fix.line_length = info->var.xres_virtual /\n\t\t\t\t\t\t\t(8/info->var.bits_per_pixel);\n\t\t} else {\n\t\t\t/* non-palettized */\n\t\t\tindex = (fbdev->panel->control_base & LCD_CONTROL_SBPPF_MASK) >> LCD_CONTROL_SBPPF_BIT;\n\t\t\tinfo->var.red = rgb_bitfields[index][0];\n\t\t\tinfo->var.green = rgb_bitfields[index][1];\n\t\t\tinfo->var.blue = rgb_bitfields[index][2];\n\t\t\tinfo->var.transp = rgb_bitfields[index][3];\n\n\t\t\tinfo->fix.visual = FB_VISUAL_TRUECOLOR;\n\t\t\tinfo->fix.line_length = info->var.xres_virtual << 1; /* depth=16 */\n\t\t}\n\t} else {\n\t\t/* mono */\n\t\tinfo->fix.visual = FB_VISUAL_MONO10;\n\t\tinfo->fix.line_length = info->var.xres_virtual / 8;\n\t}\n\n\tinfo->screen_size = info->fix.line_length * info->var.yres_virtual;\n\tinfo->var.rotate = ((fbdev->panel->control_base&LCD_CONTROL_SM_MASK) \\\n\t\t\t\t>> LCD_CONTROL_SM_BIT) * 90;\n\n\t/* Determine BPP mode and format */\n\tfbdev->regs->lcd_control = fbdev->panel->control_base;\n\tfbdev->regs->lcd_horztiming = fbdev->panel->horztiming;\n\tfbdev->regs->lcd_verttiming = fbdev->panel->verttiming;\n\tfbdev->regs->lcd_clkcontrol = fbdev->panel->clkcontrol_base;\n\tfbdev->regs->lcd_intenable = 0;\n\tfbdev->regs->lcd_intstatus = 0;\n\tfbdev->regs->lcd_dmaaddr0 = LCD_DMA_SA_N(fbdev->fb_phys);\n\n\tif (panel_is_dual(fbdev->panel)) {\n\t\t/* Second panel display seconf half of screen if possible,\n\t\t * otherwise display the same as the first panel */\n\t\tif (info->var.yres_virtual >= (info->var.yres << 1)) {\n\t\t\tfbdev->regs->lcd_dmaaddr1 = LCD_DMA_SA_N(fbdev->fb_phys +\n\t\t\t\t\t\t\t  (info->fix.line_length *\n\t\t\t\t\t\t          (info->var.yres_virtual >> 1)));\n\t\t} else {\n\t\t\tfbdev->regs->lcd_dmaaddr1 = LCD_DMA_SA_N(fbdev->fb_phys);\n\t\t}\n\t}\n\n\twords = info->fix.line_length / sizeof(u32);\n\tif (!info->var.rotate || (info->var.rotate == 180)) {\n\t\twords *= info->var.yres_virtual;\n\t\tif (info->var.rotate /* 180 */) {\n\t\t\twords -= (words % 8); /* should be divisable by 8 */\n\t\t}\n\t}\n\tfbdev->regs->lcd_words = LCD_WRD_WRDS_N(words);\n\n\tfbdev->regs->lcd_pwmdiv = 0;\n\tfbdev->regs->lcd_pwmhi = 0;\n\n\t/* Resume controller */\n\tfbdev->regs->lcd_control |= LCD_CONTROL_GO;\n\tmdelay(10);\n\tau1100fb_fb_blank(VESA_NO_BLANKING, info);\n\n\treturn 0;\n}\n\n/* fb_setcolreg\n * Set color in LCD palette.\n */\nint au1100fb_fb_setcolreg(unsigned regno, unsigned red, unsigned green, unsigned blue, unsigned transp, struct fb_info *fbi)\n{\n\tstruct au1100fb_device *fbdev;\n\tu32 *palette;\n\tu32 value;\n\n\tfbdev = to_au1100fb_device(fbi);\n\tpalette = fbdev->regs->lcd_pallettebase;\n\n\tif (regno > (AU1100_LCD_NBR_PALETTE_ENTRIES - 1))\n\t\treturn -EINVAL;\n\n\tif (fbi->var.grayscale) {\n\t\t/* Convert color to grayscale */\n\t\tred = green = blue =\n\t\t\t(19595 * red + 38470 * green + 7471 * blue) >> 16;\n\t}\n\n\tif (fbi->fix.visual == FB_VISUAL_TRUECOLOR) {\n\t\t/* Place color in the pseudopalette */\n\t\tif (regno > 16)\n\t\t\treturn -EINVAL;\n\n\t\tpalette = (u32*)fbi->pseudo_palette;\n\n\t\tred   >>= (16 - fbi->var.red.length);\n\t\tgreen >>= (16 - fbi->var.green.length);\n\t\tblue  >>= (16 - fbi->var.blue.length);\n\n\t\tvalue = (red   << fbi->var.red.offset) \t|\n\t\t\t(green << fbi->var.green.offset)|\n\t\t\t(blue  << fbi->var.blue.offset);\n\t\tvalue &= 0xFFFF;\n\n\t} else if (panel_is_active(fbdev->panel)) {\n\t\t/* COLOR TFT PALLETTIZED (use RGB 565) */\n\t\tvalue = (red & 0xF800)|((green >> 5) & 0x07E0)|((blue >> 11) & 0x001F);\n\t\tvalue &= 0xFFFF;\n\n\t} else if (panel_is_color(fbdev->panel)) {\n\t\t/* COLOR STN MODE */\n\t\tvalue = (((panel_swap_rgb(fbdev->panel) ? blue : red) >> 12) & 0x000F) |\n\t\t\t((green >> 8) & 0x00F0) |\n\t\t\t(((panel_swap_rgb(fbdev->panel) ? red : blue) >> 4) & 0x0F00);\n\t\tvalue &= 0xFFF;\n\t} else {\n\t\t/* MONOCHROME MODE */\n\t\tvalue = (green >> 12) & 0x000F;\n\t\tvalue &= 0xF;\n\t}\n\n\tpalette[regno] = value;\n\n\treturn 0;\n}\n\n/* fb_pan_display\n * Pan display in x and/or y as specified\n */\nint au1100fb_fb_pan_display(struct fb_var_screeninfo *var, struct fb_info *fbi)\n{\n\tstruct au1100fb_device *fbdev;\n\tint dy;\n\n\tfbdev = to_au1100fb_device(fbi);\n\n\tprint_dbg(\"fb_pan_display %p %p\", var, fbi);\n\n\tif (!var || !fbdev) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (var->xoffset - fbi->var.xoffset) {\n\t\t/* No support for X panning for now! */\n\t\treturn -EINVAL;\n\t}\n\n\tprint_dbg(\"fb_pan_display 2 %p %p\", var, fbi);\n\tdy = var->yoffset - fbi->var.yoffset;\n\tif (dy) {\n\n\t\tu32 dmaaddr;\n\n\t\tprint_dbg(\"Panning screen of %d lines\", dy);\n\n\t\tdmaaddr = fbdev->regs->lcd_dmaaddr0;\n\t\tdmaaddr += (fbi->fix.line_length * dy);\n\n\t\t/* TODO: Wait for current frame to finished */\n\t\tfbdev->regs->lcd_dmaaddr0 = LCD_DMA_SA_N(dmaaddr);\n\n\t\tif (panel_is_dual(fbdev->panel)) {\n\t\t\tdmaaddr = fbdev->regs->lcd_dmaaddr1;\n\t\t\tdmaaddr += (fbi->fix.line_length * dy);\n\t\t\tfbdev->regs->lcd_dmaaddr0 = LCD_DMA_SA_N(dmaaddr);\n\t}\n\t}\n\tprint_dbg(\"fb_pan_display 3 %p %p\", var, fbi);\n\n\treturn 0;\n}\n\n/* fb_rotate\n * Rotate the display of this angle. This doesn't seems to be used by the core,\n * but as our hardware supports it, so why not implementing it...\n */\nvoid au1100fb_fb_rotate(struct fb_info *fbi, int angle)\n{\n\tstruct au1100fb_device *fbdev = to_au1100fb_device(fbi);\n\n\tprint_dbg(\"fb_rotate %p %d\", fbi, angle);\n\n\tif (fbdev && (angle > 0) && !(angle % 90)) {\n\n\t\tfbdev->regs->lcd_control &= ~LCD_CONTROL_GO;\n\n\t\tfbdev->regs->lcd_control &= ~(LCD_CONTROL_SM_MASK);\n\t\tfbdev->regs->lcd_control |= ((angle/90) << LCD_CONTROL_SM_BIT);\n\n\t\tfbdev->regs->lcd_control |= LCD_CONTROL_GO;\n\t}\n}\n\n/* fb_mmap\n * Map video memory in user space. We don't use the generic fb_mmap method mainly\n * to allow the use of the TLB streaming flag (CCA=6)\n */\nint au1100fb_fb_mmap(struct fb_info *fbi, struct vm_area_struct *vma)\n{\n\tstruct au1100fb_device *fbdev;\n\tunsigned int len;\n\tunsigned long start=0, off;\n\n\tfbdev = to_au1100fb_device(fbi);\n\n\tif (vma->vm_pgoff > (~0UL >> PAGE_SHIFT)) {\n\t\treturn -EINVAL;\n\t}\n\n\tstart = fbdev->fb_phys & PAGE_MASK;\n\tlen = PAGE_ALIGN((start & ~PAGE_MASK) + fbdev->fb_len);\n\n\toff = vma->vm_pgoff << PAGE_SHIFT;\n\n\tif ((vma->vm_end - vma->vm_start + off) > len) {\n\t\treturn -EINVAL;\n\t}\n\n\toff += start;\n\tvma->vm_pgoff = off >> PAGE_SHIFT;\n\n\tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n\tpgprot_val(vma->vm_page_prot) |= (6 << 9); //CCA=6\n\n\tif (io_remap_pfn_range(vma, vma->vm_start, off >> PAGE_SHIFT,\n\t\t\t\tvma->vm_end - vma->vm_start,\n\t\t\t\tvma->vm_page_prot)) {\n\t\treturn -EAGAIN;\n\t}\n\n\treturn 0;\n}\n\nstatic struct fb_ops au1100fb_ops =\n{\n\t.owner\t\t\t= THIS_MODULE,\n\t.fb_setcolreg\t\t= au1100fb_fb_setcolreg,\n\t.fb_blank\t\t= au1100fb_fb_blank,\n\t.fb_pan_display\t\t= au1100fb_fb_pan_display,\n\t.fb_fillrect\t\t= cfb_fillrect,\n\t.fb_copyarea\t\t= cfb_copyarea,\n\t.fb_imageblit\t\t= cfb_imageblit,\n\t.fb_rotate\t\t= au1100fb_fb_rotate,\n\t.fb_mmap\t\t= au1100fb_fb_mmap,\n};\n\n\n/*-------------------------------------------------------------------------*/\n\nstatic int au1100fb_setup(struct au1100fb_device *fbdev)\n{\n\tchar *this_opt, *options;\n\tint num_panels = ARRAY_SIZE(known_lcd_panels);\n\n\tif (num_panels <= 0) {\n\t\tprint_err(\"No LCD panels supported by driver!\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (fb_get_options(DRIVER_NAME, &options))\n\t\treturn -ENODEV;\n\tif (!options)\n\t\treturn -ENODEV;\n\n\twhile ((this_opt = strsep(&options, \",\")) != NULL) {\n\t\t/* Panel option */\n\t\tif (!strncmp(this_opt, \"panel:\", 6)) {\n\t\t\tint i;\n\t\t\tthis_opt += 6;\n\t\t\tfor (i = 0; i < num_panels; i++) {\n\t\t\t\tif (!strncmp(this_opt, known_lcd_panels[i].name,\n\t\t\t\t\t     strlen(this_opt))) {\n\t\t\t\t\tfbdev->panel = &known_lcd_panels[i];\n\t\t\t\t\tfbdev->panel_idx = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i >= num_panels) {\n\t\t\t\tprint_warn(\"Panel '%s' not supported!\", this_opt);\n\t\t\t\treturn -ENODEV;\n\t\t\t}\n\t\t}\n\t\t/* Unsupported option */\n\t\telse\n\t\t\tprint_warn(\"Unsupported option \\\"%s\\\"\", this_opt);\n\t}\n\n\tprint_info(\"Panel=%s\", fbdev->panel->name);\n\n\treturn 0;\n}\n\nstatic int au1100fb_drv_probe(struct platform_device *dev)\n{\n\tstruct au1100fb_device *fbdev = NULL;\n\tstruct resource *regs_res;\n\tunsigned long page;\n\tu32 sys_clksrc;\n\n\t/* Allocate new device private */\n\tfbdev = devm_kzalloc(&dev->dev, sizeof(struct au1100fb_device),\n\t\t\t     GFP_KERNEL);\n\tif (!fbdev) {\n\t\tprint_err(\"fail to allocate device private record\");\n\t\treturn -ENOMEM;\n\t}\n\n\tif (au1100fb_setup(fbdev))\n\t\tgoto failed;\n\n\tplatform_set_drvdata(dev, (void *)fbdev);\n\n\t/* Allocate region for our registers and map them */\n\tregs_res = platform_get_resource(dev, IORESOURCE_MEM, 0);\n\tif (!regs_res) {\n\t\tprint_err(\"fail to retrieve registers resource\");\n\t\treturn -EFAULT;\n\t}\n\n\tau1100fb_fix.mmio_start = regs_res->start;\n\tau1100fb_fix.mmio_len = resource_size(regs_res);\n\n\tif (!devm_request_mem_region(&dev->dev,\n\t\t\t\t     au1100fb_fix.mmio_start,\n\t\t\t\t     au1100fb_fix.mmio_len,\n\t\t\t\t     DRIVER_NAME)) {\n\t\tprint_err(\"fail to lock memory region at 0x%08lx\",\n\t\t\t\tau1100fb_fix.mmio_start);\n\t\treturn -EBUSY;\n\t}\n\n\tfbdev->regs = (struct au1100fb_regs*)KSEG1ADDR(au1100fb_fix.mmio_start);\n\n\tprint_dbg(\"Register memory map at %p\", fbdev->regs);\n\tprint_dbg(\"phys=0x%08x, size=%d\", fbdev->regs_phys, fbdev->regs_len);\n\n\t/* Allocate the framebuffer to the maximum screen size * nbr of video buffers */\n\tfbdev->fb_len = fbdev->panel->xres * fbdev->panel->yres *\n\t\t  \t(fbdev->panel->bpp >> 3) * AU1100FB_NBR_VIDEO_BUFFERS;\n\n\tfbdev->fb_mem = dmam_alloc_coherent(&dev->dev,\n\t\t\t\t\t    PAGE_ALIGN(fbdev->fb_len),\n\t\t\t\t\t    &fbdev->fb_phys, GFP_KERNEL);\n\tif (!fbdev->fb_mem) {\n\t\tprint_err(\"fail to allocate frambuffer (size: %dK))\",\n\t\t\t  fbdev->fb_len / 1024);\n\t\treturn -ENOMEM;\n\t}\n\n\tau1100fb_fix.smem_start = fbdev->fb_phys;\n\tau1100fb_fix.smem_len = fbdev->fb_len;\n\n\t/*\n\t * Set page reserved so that mmap will work. This is necessary\n\t * since we'll be remapping normal memory.\n\t */\n\tfor (page = (unsigned long)fbdev->fb_mem;\n\t     page < PAGE_ALIGN((unsigned long)fbdev->fb_mem + fbdev->fb_len);\n\t     page += PAGE_SIZE) {\n#ifdef CONFIG_DMA_NONCOHERENT\n\t\tSetPageReserved(virt_to_page(CAC_ADDR((void *)page)));\n#else\n\t\tSetPageReserved(virt_to_page(page));\n#endif\n\t}\n\n\tprint_dbg(\"Framebuffer memory map at %p\", fbdev->fb_mem);\n\tprint_dbg(\"phys=0x%08x, size=%dK\", fbdev->fb_phys, fbdev->fb_len / 1024);\n\n\t/* Setup LCD clock to AUX (48 MHz) */\n\tsys_clksrc = au_readl(SYS_CLKSRC) & ~(SYS_CS_ML_MASK | SYS_CS_DL | SYS_CS_CL);\n\tau_writel((sys_clksrc | (1 << SYS_CS_ML_BIT)), SYS_CLKSRC);\n\n\t/* load the panel info into the var struct */\n\tau1100fb_var.bits_per_pixel = fbdev->panel->bpp;\n\tau1100fb_var.xres = fbdev->panel->xres;\n\tau1100fb_var.xres_virtual = au1100fb_var.xres;\n\tau1100fb_var.yres = fbdev->panel->yres;\n\tau1100fb_var.yres_virtual = au1100fb_var.yres;\n\n\tfbdev->info.screen_base = fbdev->fb_mem;\n\tfbdev->info.fbops = &au1100fb_ops;\n\tfbdev->info.fix = au1100fb_fix;\n\n\tfbdev->info.pseudo_palette =\n\t\tdevm_kzalloc(&dev->dev, sizeof(u32) * 16, GFP_KERNEL);\n\tif (!fbdev->info.pseudo_palette)\n\t\treturn -ENOMEM;\n\n\tif (fb_alloc_cmap(&fbdev->info.cmap, AU1100_LCD_NBR_PALETTE_ENTRIES, 0) < 0) {\n\t\tprint_err(\"Fail to allocate colormap (%d entries)\",\n\t\t\t   AU1100_LCD_NBR_PALETTE_ENTRIES);\n\t\treturn -EFAULT;\n\t}\n\n\tfbdev->info.var = au1100fb_var;\n\n\t/* Set h/w registers */\n\tau1100fb_setmode(fbdev);\n\n\t/* Register new framebuffer */\n\tif (register_framebuffer(&fbdev->info) < 0) {\n\t\tprint_err(\"cannot register new framebuffer\");\n\t\tgoto failed;\n\t}\n\n\treturn 0;\n\nfailed:\n\tif (fbdev->fb_mem) {\n\t\tdma_free_noncoherent(&dev->dev, fbdev->fb_len, fbdev->fb_mem,\n\t\t\t\t     fbdev->fb_phys);\n\t}\n\tif (fbdev->info.cmap.len != 0) {\n\t\tfb_dealloc_cmap(&fbdev->info.cmap);\n\t}\n\n\treturn -ENODEV;\n}\n\nint au1100fb_drv_remove(struct platform_device *dev)\n{\n\tstruct au1100fb_device *fbdev = NULL;\n\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tfbdev = (struct au1100fb_device *) platform_get_drvdata(dev);\n\n#if !defined(CONFIG_FRAMEBUFFER_CONSOLE) && defined(CONFIG_LOGO)\n\tau1100fb_fb_blank(VESA_POWERDOWN, &fbdev->info);\n#endif\n\tfbdev->regs->lcd_control &= ~LCD_CONTROL_GO;\n\n\t/* Clean up all probe data */\n\tunregister_framebuffer(&fbdev->info);\n\n\tfb_dealloc_cmap(&fbdev->info.cmap);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\nstatic u32 sys_clksrc;\nstatic struct au1100fb_regs fbregs;\n\nint au1100fb_drv_suspend(struct platform_device *dev, pm_message_t state)\n{\n\tstruct au1100fb_device *fbdev = platform_get_drvdata(dev);\n\n\tif (!fbdev)\n\t\treturn 0;\n\n\t/* Save the clock source state */\n\tsys_clksrc = au_readl(SYS_CLKSRC);\n\n\t/* Blank the LCD */\n\tau1100fb_fb_blank(VESA_POWERDOWN, &fbdev->info);\n\n\t/* Stop LCD clocking */\n\tau_writel(sys_clksrc & ~SYS_CS_ML_MASK, SYS_CLKSRC);\n\n\tmemcpy(&fbregs, fbdev->regs, sizeof(struct au1100fb_regs));\n\n\treturn 0;\n}\n\nint au1100fb_drv_resume(struct platform_device *dev)\n{\n\tstruct au1100fb_device *fbdev = platform_get_drvdata(dev);\n\n\tif (!fbdev)\n\t\treturn 0;\n\n\tmemcpy(fbdev->regs, &fbregs, sizeof(struct au1100fb_regs));\n\n\t/* Restart LCD clocking */\n\tau_writel(sys_clksrc, SYS_CLKSRC);\n\n\t/* Unblank the LCD */\n\tau1100fb_fb_blank(VESA_NO_BLANKING, &fbdev->info);\n\n\treturn 0;\n}\n#else\n#define au1100fb_drv_suspend NULL\n#define au1100fb_drv_resume NULL\n#endif\n\nstatic struct platform_driver au1100fb_driver = {\n\t.driver = {\n\t\t.name\t\t= \"au1100-lcd\",\n\t\t.owner          = THIS_MODULE,\n\t},\n\t.probe\t\t= au1100fb_drv_probe,\n        .remove\t\t= au1100fb_drv_remove,\n\t.suspend\t= au1100fb_drv_suspend,\n        .resume\t\t= au1100fb_drv_resume,\n};\n\nstatic int __init au1100fb_load(void)\n{\n\treturn platform_driver_register(&au1100fb_driver);\n}\n\nstatic void __exit au1100fb_unload(void)\n{\n\tplatform_driver_unregister(&au1100fb_driver);\n}\n\nmodule_init(au1100fb_load);\nmodule_exit(au1100fb_unload);\n\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n", "/*\n * BRIEF MODULE DESCRIPTION\n *\tAu1200 LCD Driver.\n *\n * Copyright 2004-2005 AMD\n * Author: AMD\n *\n * Based on:\n * linux/drivers/video/skeletonfb.c -- Skeleton for a frame buffer device\n *  Created 28 Dec 1997 by Geert Uytterhoeven\n *\n *  This program is free software; you can redistribute\t it and/or modify it\n *  under  the terms of\t the GNU General  Public License as published by the\n *  Free Software Foundation;  either version 2 of the\tLicense, or (at your\n *  option) any later version.\n *\n *  THIS  SOFTWARE  IS PROVIDED\t  ``AS\tIS'' AND   ANY\tEXPRESS OR IMPLIED\n *  WARRANTIES,\t  INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF\n *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN\n *  NO\tEVENT  SHALL   THE AUTHOR  BE\t LIABLE FOR ANY\t  DIRECT, INDIRECT,\n *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED\t  TO, PROCUREMENT OF  SUBSTITUTE GOODS\tOR SERVICES; LOSS OF\n *  USE, DATA,\tOR PROFITS; OR\tBUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n *  ANY THEORY OF LIABILITY, WHETHER IN\t CONTRACT, STRICT LIABILITY, OR TORT\n *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n *  You should have received a copy of the  GNU General Public License along\n *  with this program; if not, write  to the Free Software Foundation, Inc.,\n *  675 Mass Ave, Cambridge, MA 02139, USA.\n */\n\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/fb.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/ctype.h>\n#include <linux/dma-mapping.h>\n#include <linux/slab.h>\n\n#include <asm/mach-au1x00/au1000.h>\n#include <asm/mach-au1x00/au1200fb.h>\t/* platform_data */\n#include \"au1200fb.h\"\n\n#define DRIVER_NAME \"au1200fb\"\n#define DRIVER_DESC \"LCD controller driver for AU1200 processors\"\n\n#define DEBUG 0\n\n#define print_err(f, arg...) printk(KERN_ERR DRIVER_NAME \": \" f \"\\n\", ## arg)\n#define print_warn(f, arg...) printk(KERN_WARNING DRIVER_NAME \": \" f \"\\n\", ## arg)\n#define print_info(f, arg...) printk(KERN_INFO DRIVER_NAME \": \" f \"\\n\", ## arg)\n\n#if DEBUG\n#define print_dbg(f, arg...) printk(KERN_DEBUG __FILE__ \": \" f \"\\n\", ## arg)\n#else\n#define print_dbg(f, arg...) do {} while (0)\n#endif\n\n\n#define AU1200_LCD_FB_IOCTL 0x46FF\n\n#define AU1200_LCD_SET_SCREEN 1\n#define AU1200_LCD_GET_SCREEN 2\n#define AU1200_LCD_SET_WINDOW 3\n#define AU1200_LCD_GET_WINDOW 4\n#define AU1200_LCD_SET_PANEL  5\n#define AU1200_LCD_GET_PANEL  6\n\n#define SCREEN_SIZE\t\t    (1<< 1)\n#define SCREEN_BACKCOLOR    (1<< 2)\n#define SCREEN_BRIGHTNESS   (1<< 3)\n#define SCREEN_COLORKEY     (1<< 4)\n#define SCREEN_MASK         (1<< 5)\n\nstruct au1200_lcd_global_regs_t {\n\tunsigned int flags;\n\tunsigned int xsize;\n\tunsigned int ysize;\n\tunsigned int backcolor;\n\tunsigned int brightness;\n\tunsigned int colorkey;\n\tunsigned int mask;\n\tunsigned int panel_choice;\n\tchar panel_desc[80];\n\n};\n\n#define WIN_POSITION            (1<< 0)\n#define WIN_ALPHA_COLOR         (1<< 1)\n#define WIN_ALPHA_MODE          (1<< 2)\n#define WIN_PRIORITY            (1<< 3)\n#define WIN_CHANNEL             (1<< 4)\n#define WIN_BUFFER_FORMAT       (1<< 5)\n#define WIN_COLOR_ORDER         (1<< 6)\n#define WIN_PIXEL_ORDER         (1<< 7)\n#define WIN_SIZE                (1<< 8)\n#define WIN_COLORKEY_MODE       (1<< 9)\n#define WIN_DOUBLE_BUFFER_MODE  (1<< 10)\n#define WIN_RAM_ARRAY_MODE      (1<< 11)\n#define WIN_BUFFER_SCALE        (1<< 12)\n#define WIN_ENABLE\t            (1<< 13)\n\nstruct au1200_lcd_window_regs_t {\n\tunsigned int flags;\n\tunsigned int xpos;\n\tunsigned int ypos;\n\tunsigned int alpha_color;\n\tunsigned int alpha_mode;\n\tunsigned int priority;\n\tunsigned int channel;\n\tunsigned int buffer_format;\n\tunsigned int color_order;\n\tunsigned int pixel_order;\n\tunsigned int xsize;\n\tunsigned int ysize;\n\tunsigned int colorkey_mode;\n\tunsigned int double_buffer_mode;\n\tunsigned int ram_array_mode;\n\tunsigned int xscale;\n\tunsigned int yscale;\n\tunsigned int enable;\n};\n\n\nstruct au1200_lcd_iodata_t {\n\tunsigned int subcmd;\n\tstruct au1200_lcd_global_regs_t global;\n\tstruct au1200_lcd_window_regs_t window;\n};\n\n#if defined(__BIG_ENDIAN)\n#define LCD_CONTROL_DEFAULT_PO LCD_CONTROL_PO_11\n#else\n#define LCD_CONTROL_DEFAULT_PO LCD_CONTROL_PO_00\n#endif\n#define LCD_CONTROL_DEFAULT_SBPPF LCD_CONTROL_SBPPF_565\n\n/* Private, per-framebuffer management information (independent of the panel itself) */\nstruct au1200fb_device {\n\tstruct fb_info *fb_info;\t\t/* FB driver info record */\n\tstruct au1200fb_platdata *pd;\n\n\tint\t\t\t\t\tplane;\n\tunsigned char* \t\tfb_mem;\t\t/* FrameBuffer memory map */\n\tunsigned int\t\tfb_len;\n\tdma_addr_t    \t\tfb_phys;\n};\n\n/********************************************************************/\n\n/* LCD controller restrictions */\n#define AU1200_LCD_MAX_XRES\t1280\n#define AU1200_LCD_MAX_YRES\t1024\n#define AU1200_LCD_MAX_BPP\t32\n#define AU1200_LCD_MAX_CLK\t96000000 /* fixme: this needs to go away ? */\n#define AU1200_LCD_NBR_PALETTE_ENTRIES 256\n\n/* Default number of visible screen buffer to allocate */\n#define AU1200FB_NBR_VIDEO_BUFFERS 1\n\n/* Default maximum number of fb devices to create */\n#define MAX_DEVICE_COUNT\t4\n\n/* Default window configuration entry to use (see windows[]) */\n#define DEFAULT_WINDOW_INDEX\t2\n\n/********************************************************************/\n\nstatic struct fb_info *_au1200fb_infos[MAX_DEVICE_COUNT];\nstatic struct au1200_lcd *lcd = (struct au1200_lcd *) AU1200_LCD_ADDR;\nstatic int device_count = MAX_DEVICE_COUNT;\nstatic int window_index = DEFAULT_WINDOW_INDEX;\t/* default is zero */\nstatic int panel_index = 2; /* default is zero */\nstatic struct window_settings *win;\nstatic struct panel_settings *panel;\nstatic int noblanking = 1;\nstatic int nohwcursor = 0;\n\nstruct window_settings {\n\tunsigned char name[64];\n\tuint32 mode_backcolor;\n\tuint32 mode_colorkey;\n\tuint32 mode_colorkeymsk;\n\tstruct {\n\t\tint xres;\n\t\tint yres;\n\t\tint xpos;\n\t\tint ypos;\n\t\tuint32 mode_winctrl1; /* winctrl1[FRM,CCO,PO,PIPE] */\n\t\tuint32 mode_winenable;\n\t} w[4];\n};\n\n#if defined(__BIG_ENDIAN)\n#define LCD_WINCTRL1_PO_16BPP LCD_WINCTRL1_PO_00\n#else\n#define LCD_WINCTRL1_PO_16BPP LCD_WINCTRL1_PO_01\n#endif\n\n/*\n * Default window configurations\n */\nstatic struct window_settings windows[] = {\n\t{ /* Index 0 */\n\t\t\"0-FS gfx, 1-video, 2-ovly gfx, 3-ovly gfx\",\n\t\t/* mode_backcolor\t*/ 0x006600ff,\n\t\t/* mode_colorkey,msk*/ 0, 0,\n\t\t{\n\t\t\t{\n\t\t\t/* xres, yres, xpos, ypos */ 0, 0, 0, 0,\n\t\t\t/* mode_winctrl1 */ LCD_WINCTRL1_FRM_16BPP565 |\n\t\t\t\tLCD_WINCTRL1_PO_16BPP,\n\t\t\t/* mode_winenable*/ LCD_WINENABLE_WEN0,\n\t\t\t},\n\t\t\t{\n\t\t\t/* xres, yres, xpos, ypos */ 100, 100, 100, 100,\n\t\t\t/* mode_winctrl1 */ LCD_WINCTRL1_FRM_16BPP565 |\n\t\t\t\tLCD_WINCTRL1_PO_16BPP |\n\t\t\t\tLCD_WINCTRL1_PIPE,\n\t\t\t/* mode_winenable*/ LCD_WINENABLE_WEN1,\n\t\t\t},\n\t\t\t{\n\t\t\t/* xres, yres, xpos, ypos */ 0, 0, 0, 0,\n\t\t\t/* mode_winctrl1 */ LCD_WINCTRL1_FRM_16BPP565 |\n\t\t\t\tLCD_WINCTRL1_PO_16BPP,\n\t\t\t/* mode_winenable*/ 0,\n\t\t\t},\n\t\t\t{\n\t\t\t/* xres, yres, xpos, ypos */ 0, 0, 0, 0,\n\t\t\t/* mode_winctrl1 */ LCD_WINCTRL1_FRM_16BPP565 |\n\t\t\t\tLCD_WINCTRL1_PO_16BPP |\n\t\t\t\tLCD_WINCTRL1_PIPE,\n\t\t\t/* mode_winenable*/ 0,\n\t\t\t},\n\t\t},\n\t},\n\n\t{ /* Index 1 */\n\t\t\"0-FS gfx, 1-video, 2-ovly gfx, 3-ovly gfx\",\n\t\t/* mode_backcolor\t*/ 0x006600ff,\n\t\t/* mode_colorkey,msk*/ 0, 0,\n\t\t{\n\t\t\t{\n\t\t\t/* xres, yres, xpos, ypos */ 320, 240, 5, 5,\n\t\t\t/* mode_winctrl1 */ LCD_WINCTRL1_FRM_24BPP |\n\t\t\t\tLCD_WINCTRL1_PO_00,\n\t\t\t/* mode_winenable*/ LCD_WINENABLE_WEN0,\n\t\t\t},\n\t\t\t{\n\t\t\t/* xres, yres, xpos, ypos */ 0, 0, 0, 0,\n\t\t\t/* mode_winctrl1 */ LCD_WINCTRL1_FRM_16BPP565\n\t\t\t\t| LCD_WINCTRL1_PO_16BPP,\n\t\t\t/* mode_winenable*/ 0,\n\t\t\t},\n\t\t\t{\n\t\t\t/* xres, yres, xpos, ypos */ 100, 100, 0, 0,\n\t\t\t/* mode_winctrl1 */ LCD_WINCTRL1_FRM_16BPP565 |\n\t\t\t\tLCD_WINCTRL1_PO_16BPP |\n\t\t\t\tLCD_WINCTRL1_PIPE,\n\t\t\t/* mode_winenable*/ 0/*LCD_WINENABLE_WEN2*/,\n\t\t\t},\n\t\t\t{\n\t\t\t/* xres, yres, xpos, ypos */ 200, 25, 0, 0,\n\t\t\t/* mode_winctrl1 */ LCD_WINCTRL1_FRM_16BPP565 |\n\t\t\t\tLCD_WINCTRL1_PO_16BPP |\n\t\t\t\tLCD_WINCTRL1_PIPE,\n\t\t\t/* mode_winenable*/ 0,\n\t\t\t},\n\t\t},\n\t},\n\t{ /* Index 2 */\n\t\t\"0-FS gfx, 1-video, 2-ovly gfx, 3-ovly gfx\",\n\t\t/* mode_backcolor\t*/ 0x006600ff,\n\t\t/* mode_colorkey,msk*/ 0, 0,\n\t\t{\n\t\t\t{\n\t\t\t/* xres, yres, xpos, ypos */ 0, 0, 0, 0,\n\t\t\t/* mode_winctrl1 */ LCD_WINCTRL1_FRM_16BPP565 |\n\t\t\t\tLCD_WINCTRL1_PO_16BPP,\n\t\t\t/* mode_winenable*/ LCD_WINENABLE_WEN0,\n\t\t\t},\n\t\t\t{\n\t\t\t/* xres, yres, xpos, ypos */ 0, 0, 0, 0,\n\t\t\t/* mode_winctrl1 */ LCD_WINCTRL1_FRM_16BPP565 |\n\t\t\t\tLCD_WINCTRL1_PO_16BPP,\n\t\t\t/* mode_winenable*/ 0,\n\t\t\t},\n\t\t\t{\n\t\t\t/* xres, yres, xpos, ypos */ 0, 0, 0, 0,\n\t\t\t/* mode_winctrl1 */ LCD_WINCTRL1_FRM_32BPP |\n\t\t\t\tLCD_WINCTRL1_PO_00|LCD_WINCTRL1_PIPE,\n\t\t\t/* mode_winenable*/ 0/*LCD_WINENABLE_WEN2*/,\n\t\t\t},\n\t\t\t{\n\t\t\t/* xres, yres, xpos, ypos */ 0, 0, 0, 0,\n\t\t\t/* mode_winctrl1 */ LCD_WINCTRL1_FRM_16BPP565 |\n\t\t\t\tLCD_WINCTRL1_PO_16BPP |\n\t\t\t\tLCD_WINCTRL1_PIPE,\n\t\t\t/* mode_winenable*/ 0,\n\t\t\t},\n\t\t},\n\t},\n\t/* Need VGA 640 @ 24bpp, @ 32bpp */\n\t/* Need VGA 800 @ 24bpp, @ 32bpp */\n\t/* Need VGA 1024 @ 24bpp, @ 32bpp */\n};\n\n/*\n * Controller configurations for various panels.\n */\n\nstruct panel_settings\n{\n\tconst char name[25];\t\t/* Full name <vendor>_<model> */\n\n\tstruct \tfb_monspecs monspecs; \t/* FB monitor specs */\n\n\t/* panel timings */\n\tuint32 mode_screen;\n\tuint32 mode_horztiming;\n\tuint32 mode_verttiming;\n\tuint32 mode_clkcontrol;\n\tuint32 mode_pwmdiv;\n\tuint32 mode_pwmhi;\n\tuint32 mode_outmask;\n\tuint32 mode_fifoctrl;\n\tuint32 mode_toyclksrc;\n\tuint32 mode_backlight;\n\tuint32 mode_auxpll;\n#define Xres min_xres\n#define Yres min_yres\n\tu32\tmin_xres;\t\t/* Minimum horizontal resolution */\n\tu32\tmax_xres;\t\t/* Maximum horizontal resolution */\n\tu32 \tmin_yres;\t\t/* Minimum vertical resolution */\n\tu32 \tmax_yres;\t\t/* Maximum vertical resolution */\n};\n\n/********************************************************************/\n/* fixme: Maybe a modedb for the CRT ? otherwise panels should be as-is */\n\n/* List of panels known to work with the AU1200 LCD controller.\n * To add a new panel, enter the same specifications as the\n * Generic_TFT one, and MAKE SURE that it doesn't conflicts\n * with the controller restrictions. Restrictions are:\n *\n * STN color panels: max_bpp <= 12\n * STN mono panels: max_bpp <= 4\n * TFT panels: max_bpp <= 16\n * max_xres <= 800\n * max_yres <= 600\n */\nstatic struct panel_settings known_lcd_panels[] =\n{\n\t[0] = { /* QVGA 320x240 H:33.3kHz V:110Hz */\n\t\t.name = \"QVGA_320x240\",\n\t\t.monspecs = {\n\t\t\t.modedb = NULL,\n\t\t\t.modedb_len = 0,\n\t\t\t.hfmin = 30000,\n\t\t\t.hfmax = 70000,\n\t\t\t.vfmin = 60,\n\t\t\t.vfmax = 60,\n\t\t\t.dclkmin = 6000000,\n\t\t\t.dclkmax = 28000000,\n\t\t\t.input = FB_DISP_RGB,\n\t\t},\n\t\t.mode_screen\t\t= LCD_SCREEN_SX_N(320) |\n\t\t\tLCD_SCREEN_SY_N(240),\n\t\t.mode_horztiming\t= 0x00c4623b,\n\t\t.mode_verttiming\t= 0x00502814,\n\t\t.mode_clkcontrol\t= 0x00020002, /* /4=24Mhz */\n\t\t.mode_pwmdiv\t\t= 0x00000000,\n\t\t.mode_pwmhi\t\t= 0x00000000,\n\t\t.mode_outmask\t= 0x00FFFFFF,\n\t\t.mode_fifoctrl\t= 0x2f2f2f2f,\n\t\t.mode_toyclksrc\t= 0x00000004, /* AUXPLL directly */\n\t\t.mode_backlight\t= 0x00000000,\n\t\t.mode_auxpll\t\t= 8, /* 96MHz AUXPLL */\n\t\t320, 320,\n\t\t240, 240,\n\t},\n\n\t[1] = { /* VGA 640x480 H:30.3kHz V:58Hz */\n\t\t.name = \"VGA_640x480\",\n\t\t.monspecs = {\n\t\t\t.modedb = NULL,\n\t\t\t.modedb_len = 0,\n\t\t\t.hfmin = 30000,\n\t\t\t.hfmax = 70000,\n\t\t\t.vfmin = 60,\n\t\t\t.vfmax = 60,\n\t\t\t.dclkmin = 6000000,\n\t\t\t.dclkmax = 28000000,\n\t\t\t.input = FB_DISP_RGB,\n\t\t},\n\t\t.mode_screen\t\t= 0x13f9df80,\n\t\t.mode_horztiming\t= 0x003c5859,\n\t\t.mode_verttiming\t= 0x00741201,\n\t\t.mode_clkcontrol\t= 0x00020001, /* /4=24Mhz */\n\t\t.mode_pwmdiv\t\t= 0x00000000,\n\t\t.mode_pwmhi\t\t= 0x00000000,\n\t\t.mode_outmask\t= 0x00FFFFFF,\n\t\t.mode_fifoctrl\t= 0x2f2f2f2f,\n\t\t.mode_toyclksrc\t= 0x00000004, /* AUXPLL directly */\n\t\t.mode_backlight\t= 0x00000000,\n\t\t.mode_auxpll\t\t= 8, /* 96MHz AUXPLL */\n\t\t640, 480,\n\t\t640, 480,\n\t},\n\n\t[2] = { /* SVGA 800x600 H:46.1kHz V:69Hz */\n\t\t.name = \"SVGA_800x600\",\n\t\t.monspecs = {\n\t\t\t.modedb = NULL,\n\t\t\t.modedb_len = 0,\n\t\t\t.hfmin = 30000,\n\t\t\t.hfmax = 70000,\n\t\t\t.vfmin = 60,\n\t\t\t.vfmax = 60,\n\t\t\t.dclkmin = 6000000,\n\t\t\t.dclkmax = 28000000,\n\t\t\t.input = FB_DISP_RGB,\n\t\t},\n\t\t.mode_screen\t\t= 0x18fa5780,\n\t\t.mode_horztiming\t= 0x00dc7e77,\n\t\t.mode_verttiming\t= 0x00584805,\n\t\t.mode_clkcontrol\t= 0x00020000, /* /2=48Mhz */\n\t\t.mode_pwmdiv\t\t= 0x00000000,\n\t\t.mode_pwmhi\t\t= 0x00000000,\n\t\t.mode_outmask\t= 0x00FFFFFF,\n\t\t.mode_fifoctrl\t= 0x2f2f2f2f,\n\t\t.mode_toyclksrc\t= 0x00000004, /* AUXPLL directly */\n\t\t.mode_backlight\t= 0x00000000,\n\t\t.mode_auxpll\t\t= 8, /* 96MHz AUXPLL */\n\t\t800, 800,\n\t\t600, 600,\n\t},\n\n\t[3] = { /* XVGA 1024x768 H:56.2kHz V:70Hz */\n\t\t.name = \"XVGA_1024x768\",\n\t\t.monspecs = {\n\t\t\t.modedb = NULL,\n\t\t\t.modedb_len = 0,\n\t\t\t.hfmin = 30000,\n\t\t\t.hfmax = 70000,\n\t\t\t.vfmin = 60,\n\t\t\t.vfmax = 60,\n\t\t\t.dclkmin = 6000000,\n\t\t\t.dclkmax = 28000000,\n\t\t\t.input = FB_DISP_RGB,\n\t\t},\n\t\t.mode_screen\t\t= 0x1ffaff80,\n\t\t.mode_horztiming\t= 0x007d0e57,\n\t\t.mode_verttiming\t= 0x00740a01,\n\t\t.mode_clkcontrol\t= 0x000A0000, /* /1 */\n\t\t.mode_pwmdiv\t\t= 0x00000000,\n\t\t.mode_pwmhi\t\t= 0x00000000,\n\t\t.mode_outmask\t= 0x00FFFFFF,\n\t\t.mode_fifoctrl\t= 0x2f2f2f2f,\n\t\t.mode_toyclksrc\t= 0x00000004, /* AUXPLL directly */\n\t\t.mode_backlight\t= 0x00000000,\n\t\t.mode_auxpll\t\t= 6, /* 72MHz AUXPLL */\n\t\t1024, 1024,\n\t\t768, 768,\n\t},\n\n\t[4] = { /* XVGA XVGA 1280x1024 H:68.5kHz V:65Hz */\n\t\t.name = \"XVGA_1280x1024\",\n\t\t.monspecs = {\n\t\t\t.modedb = NULL,\n\t\t\t.modedb_len = 0,\n\t\t\t.hfmin = 30000,\n\t\t\t.hfmax = 70000,\n\t\t\t.vfmin = 60,\n\t\t\t.vfmax = 60,\n\t\t\t.dclkmin = 6000000,\n\t\t\t.dclkmax = 28000000,\n\t\t\t.input = FB_DISP_RGB,\n\t\t},\n\t\t.mode_screen\t\t= 0x27fbff80,\n\t\t.mode_horztiming\t= 0x00cdb2c7,\n\t\t.mode_verttiming\t= 0x00600002,\n\t\t.mode_clkcontrol\t= 0x000A0000, /* /1 */\n\t\t.mode_pwmdiv\t\t= 0x00000000,\n\t\t.mode_pwmhi\t\t= 0x00000000,\n\t\t.mode_outmask\t= 0x00FFFFFF,\n\t\t.mode_fifoctrl\t= 0x2f2f2f2f,\n\t\t.mode_toyclksrc\t= 0x00000004, /* AUXPLL directly */\n\t\t.mode_backlight\t= 0x00000000,\n\t\t.mode_auxpll\t\t= 10, /* 120MHz AUXPLL */\n\t\t1280, 1280,\n\t\t1024, 1024,\n\t},\n\n\t[5] = { /* Samsung 1024x768 TFT */\n\t\t.name = \"Samsung_1024x768_TFT\",\n\t\t.monspecs = {\n\t\t\t.modedb = NULL,\n\t\t\t.modedb_len = 0,\n\t\t\t.hfmin = 30000,\n\t\t\t.hfmax = 70000,\n\t\t\t.vfmin = 60,\n\t\t\t.vfmax = 60,\n\t\t\t.dclkmin = 6000000,\n\t\t\t.dclkmax = 28000000,\n\t\t\t.input = FB_DISP_RGB,\n\t\t},\n\t\t.mode_screen\t\t= 0x1ffaff80,\n\t\t.mode_horztiming\t= 0x018cc677,\n\t\t.mode_verttiming\t= 0x00241217,\n\t\t.mode_clkcontrol\t= 0x00000000, /* SCB 0x1 /4=24Mhz */\n\t\t.mode_pwmdiv\t\t= 0x8000063f, /* SCB 0x0 */\n\t\t.mode_pwmhi\t\t= 0x03400000, /* SCB 0x0 */\n\t\t.mode_outmask\t= 0x00FFFFFF,\n\t\t.mode_fifoctrl\t= 0x2f2f2f2f,\n\t\t.mode_toyclksrc\t= 0x00000004, /* AUXPLL directly */\n\t\t.mode_backlight\t= 0x00000000,\n\t\t.mode_auxpll\t\t= 8, /* 96MHz AUXPLL */\n\t\t1024, 1024,\n\t\t768, 768,\n\t},\n\n\t[6] = { /* Toshiba 640x480 TFT */\n\t\t.name = \"Toshiba_640x480_TFT\",\n\t\t.monspecs = {\n\t\t\t.modedb = NULL,\n\t\t\t.modedb_len = 0,\n\t\t\t.hfmin = 30000,\n\t\t\t.hfmax = 70000,\n\t\t\t.vfmin = 60,\n\t\t\t.vfmax = 60,\n\t\t\t.dclkmin = 6000000,\n\t\t\t.dclkmax = 28000000,\n\t\t\t.input = FB_DISP_RGB,\n\t\t},\n\t\t.mode_screen\t\t= LCD_SCREEN_SX_N(640) |\n\t\t\tLCD_SCREEN_SY_N(480),\n\t\t.mode_horztiming\t= LCD_HORZTIMING_HPW_N(96) |\n\t\t\tLCD_HORZTIMING_HND1_N(13) | LCD_HORZTIMING_HND2_N(51),\n\t\t.mode_verttiming\t= LCD_VERTTIMING_VPW_N(2) |\n\t\t\tLCD_VERTTIMING_VND1_N(11) | LCD_VERTTIMING_VND2_N(32),\n\t\t.mode_clkcontrol\t= 0x00000000, /* /4=24Mhz */\n\t\t.mode_pwmdiv\t\t= 0x8000063f,\n\t\t.mode_pwmhi\t\t= 0x03400000,\n\t\t.mode_outmask\t= 0x00fcfcfc,\n\t\t.mode_fifoctrl\t= 0x2f2f2f2f,\n\t\t.mode_toyclksrc\t= 0x00000004, /* AUXPLL directly */\n\t\t.mode_backlight\t= 0x00000000,\n\t\t.mode_auxpll\t\t= 8, /* 96MHz AUXPLL */\n\t\t640, 480,\n\t\t640, 480,\n\t},\n\n\t[7] = { /* Sharp 320x240 TFT */\n\t\t.name = \"Sharp_320x240_TFT\",\n\t\t.monspecs = {\n\t\t\t.modedb = NULL,\n\t\t\t.modedb_len = 0,\n\t\t\t.hfmin = 12500,\n\t\t\t.hfmax = 20000,\n\t\t\t.vfmin = 38,\n\t\t\t.vfmax = 81,\n\t\t\t.dclkmin = 4500000,\n\t\t\t.dclkmax = 6800000,\n\t\t\t.input = FB_DISP_RGB,\n\t\t},\n\t\t.mode_screen\t\t= LCD_SCREEN_SX_N(320) |\n\t\t\tLCD_SCREEN_SY_N(240),\n\t\t.mode_horztiming\t= LCD_HORZTIMING_HPW_N(60) |\n\t\t\tLCD_HORZTIMING_HND1_N(13) | LCD_HORZTIMING_HND2_N(2),\n\t\t.mode_verttiming\t= LCD_VERTTIMING_VPW_N(2) |\n\t\t\tLCD_VERTTIMING_VND1_N(2) | LCD_VERTTIMING_VND2_N(5),\n\t\t.mode_clkcontrol\t= LCD_CLKCONTROL_PCD_N(7), /*16=6Mhz*/\n\t\t.mode_pwmdiv\t\t= 0x8000063f,\n\t\t.mode_pwmhi\t\t= 0x03400000,\n\t\t.mode_outmask\t= 0x00fcfcfc,\n\t\t.mode_fifoctrl\t= 0x2f2f2f2f,\n\t\t.mode_toyclksrc\t= 0x00000004, /* AUXPLL directly */\n\t\t.mode_backlight\t= 0x00000000,\n\t\t.mode_auxpll\t\t= 8, /* 96MHz AUXPLL */\n\t\t320, 320,\n\t\t240, 240,\n\t},\n\n\t[8] = { /* Toppoly TD070WGCB2 7\" 856x480 TFT */\n\t\t.name = \"Toppoly_TD070WGCB2\",\n\t\t.monspecs = {\n\t\t\t.modedb = NULL,\n\t\t\t.modedb_len = 0,\n\t\t\t.hfmin = 30000,\n\t\t\t.hfmax = 70000,\n\t\t\t.vfmin = 60,\n\t\t\t.vfmax = 60,\n\t\t\t.dclkmin = 6000000,\n\t\t\t.dclkmax = 28000000,\n\t\t\t.input = FB_DISP_RGB,\n\t\t},\n\t\t.mode_screen\t\t= LCD_SCREEN_SX_N(856) |\n\t\t\tLCD_SCREEN_SY_N(480),\n\t\t.mode_horztiming\t= LCD_HORZTIMING_HND2_N(43) |\n\t\t\tLCD_HORZTIMING_HND1_N(43) | LCD_HORZTIMING_HPW_N(114),\n\t\t.mode_verttiming\t= LCD_VERTTIMING_VND2_N(20) |\n\t\t\tLCD_VERTTIMING_VND1_N(21) | LCD_VERTTIMING_VPW_N(4),\n\t\t.mode_clkcontrol\t= 0x00020001, /* /4=24Mhz */\n\t\t.mode_pwmdiv\t\t= 0x8000063f,\n\t\t.mode_pwmhi\t\t= 0x03400000,\n\t\t.mode_outmask\t= 0x00fcfcfc,\n\t\t.mode_fifoctrl\t= 0x2f2f2f2f,\n\t\t.mode_toyclksrc\t= 0x00000004, /* AUXPLL directly */\n\t\t.mode_backlight\t= 0x00000000,\n\t\t.mode_auxpll\t\t= 8, /* 96MHz AUXPLL */\n\t\t856, 856,\n\t\t480, 480,\n\t},\n\t[9] = {\n\t\t.name = \"DB1300_800x480\",\n\t\t.monspecs = {\n\t\t\t.modedb = NULL,\n\t\t\t.modedb_len = 0,\n\t\t\t.hfmin = 30000,\n\t\t\t.hfmax = 70000,\n\t\t\t.vfmin = 60,\n\t\t\t.vfmax = 60,\n\t\t\t.dclkmin = 6000000,\n\t\t\t.dclkmax = 28000000,\n\t\t\t.input = FB_DISP_RGB,\n\t\t},\n\t\t.mode_screen\t\t= LCD_SCREEN_SX_N(800) |\n\t\t\t\t\t  LCD_SCREEN_SY_N(480),\n\t\t.mode_horztiming\t= LCD_HORZTIMING_HPW_N(5) |\n\t\t\t\t\t  LCD_HORZTIMING_HND1_N(16) |\n\t\t\t\t\t  LCD_HORZTIMING_HND2_N(8),\n\t\t.mode_verttiming\t= LCD_VERTTIMING_VPW_N(4) |\n\t\t\t\t\t  LCD_VERTTIMING_VND1_N(8) |\n\t\t\t\t\t  LCD_VERTTIMING_VND2_N(5),\n\t\t.mode_clkcontrol\t= LCD_CLKCONTROL_PCD_N(1) |\n\t\t\t\t\t  LCD_CLKCONTROL_IV |\n\t\t\t\t\t  LCD_CLKCONTROL_IH,\n\t\t.mode_pwmdiv\t\t= 0x00000000,\n\t\t.mode_pwmhi\t\t= 0x00000000,\n\t\t.mode_outmask\t\t= 0x00FFFFFF,\n\t\t.mode_fifoctrl\t\t= 0x2f2f2f2f,\n\t\t.mode_toyclksrc\t\t= 0x00000004, /* AUXPLL directly */\n\t\t.mode_backlight\t\t= 0x00000000,\n\t\t.mode_auxpll\t\t= (48/12) * 2,\n\t\t800, 800,\n\t\t480, 480,\n\t},\n};\n\n#define NUM_PANELS (ARRAY_SIZE(known_lcd_panels))\n\n/********************************************************************/\n\nstatic int winbpp (unsigned int winctrl1)\n{\n\tint bits = 0;\n\n\t/* how many bits are needed for each pixel format */\n\tswitch (winctrl1 & LCD_WINCTRL1_FRM) {\n\tcase LCD_WINCTRL1_FRM_1BPP:\n\t\tbits = 1;\n\t\tbreak;\n\tcase LCD_WINCTRL1_FRM_2BPP:\n\t\tbits = 2;\n\t\tbreak;\n\tcase LCD_WINCTRL1_FRM_4BPP:\n\t\tbits = 4;\n\t\tbreak;\n\tcase LCD_WINCTRL1_FRM_8BPP:\n\t\tbits = 8;\n\t\tbreak;\n\tcase LCD_WINCTRL1_FRM_12BPP:\n\tcase LCD_WINCTRL1_FRM_16BPP655:\n\tcase LCD_WINCTRL1_FRM_16BPP565:\n\tcase LCD_WINCTRL1_FRM_16BPP556:\n\tcase LCD_WINCTRL1_FRM_16BPPI1555:\n\tcase LCD_WINCTRL1_FRM_16BPPI5551:\n\tcase LCD_WINCTRL1_FRM_16BPPA1555:\n\tcase LCD_WINCTRL1_FRM_16BPPA5551:\n\t\tbits = 16;\n\t\tbreak;\n\tcase LCD_WINCTRL1_FRM_24BPP:\n\tcase LCD_WINCTRL1_FRM_32BPP:\n\t\tbits = 32;\n\t\tbreak;\n\t}\n\n\treturn bits;\n}\n\nstatic int fbinfo2index (struct fb_info *fb_info)\n{\n\tint i;\n\n\tfor (i = 0; i < device_count; ++i) {\n\t\tif (fb_info == _au1200fb_infos[i])\n\t\t\treturn i;\n\t}\n\tprintk(\"au1200fb: ERROR: fbinfo2index failed!\\n\");\n\treturn -1;\n}\n\nstatic int au1200_setlocation (struct au1200fb_device *fbdev, int plane,\n\tint xpos, int ypos)\n{\n\tuint32 winctrl0, winctrl1, winenable, fb_offset = 0;\n\tint xsz, ysz;\n\n\t/* FIX!!! NOT CHECKING FOR COMPLETE OFFSCREEN YET */\n\n\twinctrl0 = lcd->window[plane].winctrl0;\n\twinctrl1 = lcd->window[plane].winctrl1;\n\twinctrl0 &= (LCD_WINCTRL0_A | LCD_WINCTRL0_AEN);\n\twinctrl1 &= ~(LCD_WINCTRL1_SZX | LCD_WINCTRL1_SZY);\n\n\t/* Check for off-screen adjustments */\n\txsz = win->w[plane].xres;\n\tysz = win->w[plane].yres;\n\tif ((xpos + win->w[plane].xres) > panel->Xres) {\n\t\t/* Off-screen to the right */\n\t\txsz = panel->Xres - xpos; /* off by 1 ??? */\n\t\t/*printk(\"off screen right\\n\");*/\n\t}\n\n\tif ((ypos + win->w[plane].yres) > panel->Yres) {\n\t\t/* Off-screen to the bottom */\n\t\tysz = panel->Yres - ypos; /* off by 1 ??? */\n\t\t/*printk(\"off screen bottom\\n\");*/\n\t}\n\n\tif (xpos < 0) {\n\t\t/* Off-screen to the left */\n\t\txsz = win->w[plane].xres + xpos;\n\t\tfb_offset += (((0 - xpos) * winbpp(lcd->window[plane].winctrl1))/8);\n\t\txpos = 0;\n\t\t/*printk(\"off screen left\\n\");*/\n\t}\n\n\tif (ypos < 0) {\n\t\t/* Off-screen to the top */\n\t\tysz = win->w[plane].yres + ypos;\n\t\t/* fixme: fb_offset += ((0-ypos)*fb_pars[plane].line_length); */\n\t\typos = 0;\n\t\t/*printk(\"off screen top\\n\");*/\n\t}\n\n\t/* record settings */\n\twin->w[plane].xpos = xpos;\n\twin->w[plane].ypos = ypos;\n\n\txsz -= 1;\n\tysz -= 1;\n\twinctrl0 |= (xpos << 21);\n\twinctrl0 |= (ypos << 10);\n\twinctrl1 |= (xsz << 11);\n\twinctrl1 |= (ysz << 0);\n\n\t/* Disable the window while making changes, then restore WINEN */\n\twinenable = lcd->winenable & (1 << plane);\n\tau_sync();\n\tlcd->winenable &= ~(1 << plane);\n\tlcd->window[plane].winctrl0 = winctrl0;\n\tlcd->window[plane].winctrl1 = winctrl1;\n\tlcd->window[plane].winbuf0 =\n\tlcd->window[plane].winbuf1 = fbdev->fb_phys;\n\tlcd->window[plane].winbufctrl = 0; /* select winbuf0 */\n\tlcd->winenable |= winenable;\n\tau_sync();\n\n\treturn 0;\n}\n\nstatic void au1200_setpanel(struct panel_settings *newpanel,\n\t\t\t    struct au1200fb_platdata *pd)\n{\n\t/*\n\t * Perform global setup/init of LCD controller\n\t */\n\tuint32 winenable;\n\n\t/* Make sure all windows disabled */\n\twinenable = lcd->winenable;\n\tlcd->winenable = 0;\n\tau_sync();\n\t/*\n\t * Ensure everything is disabled before reconfiguring\n\t */\n\tif (lcd->screen & LCD_SCREEN_SEN) {\n\t\t/* Wait for vertical sync period */\n\t\tlcd->intstatus = LCD_INT_SS;\n\t\twhile ((lcd->intstatus & LCD_INT_SS) == 0) {\n\t\t\tau_sync();\n\t\t}\n\n\t\tlcd->screen &= ~LCD_SCREEN_SEN;\t/*disable the controller*/\n\n\t\tdo {\n\t\t\tlcd->intstatus = lcd->intstatus; /*clear interrupts*/\n\t\t\tau_sync();\n\t\t/*wait for controller to shut down*/\n\t\t} while ((lcd->intstatus & LCD_INT_SD) == 0);\n\n\t\t/* Call shutdown of current panel (if up) */\n\t\t/* this must occur last, because if an external clock is driving\n\t\t    the controller, the clock cannot be turned off before first\n\t\t\tshutting down the controller.\n\t\t */\n\t\tif (pd->panel_shutdown)\n\t\t\tpd->panel_shutdown();\n\t}\n\n\t/* Newpanel == NULL indicates a shutdown operation only */\n\tif (newpanel == NULL)\n\t\treturn;\n\n\tpanel = newpanel;\n\n\tprintk(\"Panel(%s), %dx%d\\n\", panel->name, panel->Xres, panel->Yres);\n\n\t/*\n\t * Setup clocking if internal LCD clock source (assumes sys_auxpll valid)\n\t */\n\tif (!(panel->mode_clkcontrol & LCD_CLKCONTROL_EXT))\n\t{\n\t\tuint32 sys_clksrc;\n\t\tau_writel(panel->mode_auxpll, SYS_AUXPLL);\n\t\tsys_clksrc = au_readl(SYS_CLKSRC) & ~0x0000001f;\n\t\tsys_clksrc |= panel->mode_toyclksrc;\n\t\tau_writel(sys_clksrc, SYS_CLKSRC);\n\t}\n\n\t/*\n\t * Configure panel timings\n\t */\n\tlcd->screen = panel->mode_screen;\n\tlcd->horztiming = panel->mode_horztiming;\n\tlcd->verttiming = panel->mode_verttiming;\n\tlcd->clkcontrol = panel->mode_clkcontrol;\n\tlcd->pwmdiv = panel->mode_pwmdiv;\n\tlcd->pwmhi = panel->mode_pwmhi;\n\tlcd->outmask = panel->mode_outmask;\n\tlcd->fifoctrl = panel->mode_fifoctrl;\n\tau_sync();\n\n\t/* fixme: Check window settings to make sure still valid\n\t * for new geometry */\n#if 0\n\tau1200_setlocation(fbdev, 0, win->w[0].xpos, win->w[0].ypos);\n\tau1200_setlocation(fbdev, 1, win->w[1].xpos, win->w[1].ypos);\n\tau1200_setlocation(fbdev, 2, win->w[2].xpos, win->w[2].ypos);\n\tau1200_setlocation(fbdev, 3, win->w[3].xpos, win->w[3].ypos);\n#endif\n\tlcd->winenable = winenable;\n\n\t/*\n\t * Re-enable screen now that it is configured\n\t */\n\tlcd->screen |= LCD_SCREEN_SEN;\n\tau_sync();\n\n\t/* Call init of panel */\n\tif (pd->panel_init)\n\t\tpd->panel_init();\n\n\t/* FIX!!!! not appropriate on panel change!!! Global setup/init */\n\tlcd->intenable = 0;\n\tlcd->intstatus = ~0;\n\tlcd->backcolor = win->mode_backcolor;\n\n\t/* Setup Color Key - FIX!!! */\n\tlcd->colorkey = win->mode_colorkey;\n\tlcd->colorkeymsk = win->mode_colorkeymsk;\n\n\t/* Setup HWCursor - FIX!!! Need to support this eventually */\n\tlcd->hwc.cursorctrl = 0;\n\tlcd->hwc.cursorpos = 0;\n\tlcd->hwc.cursorcolor0 = 0;\n\tlcd->hwc.cursorcolor1 = 0;\n\tlcd->hwc.cursorcolor2 = 0;\n\tlcd->hwc.cursorcolor3 = 0;\n\n\n#if 0\n#define D(X) printk(\"%25s: %08X\\n\", #X, X)\n\tD(lcd->screen);\n\tD(lcd->horztiming);\n\tD(lcd->verttiming);\n\tD(lcd->clkcontrol);\n\tD(lcd->pwmdiv);\n\tD(lcd->pwmhi);\n\tD(lcd->outmask);\n\tD(lcd->fifoctrl);\n\tD(lcd->window[0].winctrl0);\n\tD(lcd->window[0].winctrl1);\n\tD(lcd->window[0].winctrl2);\n\tD(lcd->window[0].winbuf0);\n\tD(lcd->window[0].winbuf1);\n\tD(lcd->window[0].winbufctrl);\n\tD(lcd->window[1].winctrl0);\n\tD(lcd->window[1].winctrl1);\n\tD(lcd->window[1].winctrl2);\n\tD(lcd->window[1].winbuf0);\n\tD(lcd->window[1].winbuf1);\n\tD(lcd->window[1].winbufctrl);\n\tD(lcd->window[2].winctrl0);\n\tD(lcd->window[2].winctrl1);\n\tD(lcd->window[2].winctrl2);\n\tD(lcd->window[2].winbuf0);\n\tD(lcd->window[2].winbuf1);\n\tD(lcd->window[2].winbufctrl);\n\tD(lcd->window[3].winctrl0);\n\tD(lcd->window[3].winctrl1);\n\tD(lcd->window[3].winctrl2);\n\tD(lcd->window[3].winbuf0);\n\tD(lcd->window[3].winbuf1);\n\tD(lcd->window[3].winbufctrl);\n\tD(lcd->winenable);\n\tD(lcd->intenable);\n\tD(lcd->intstatus);\n\tD(lcd->backcolor);\n\tD(lcd->winenable);\n\tD(lcd->colorkey);\n    D(lcd->colorkeymsk);\n\tD(lcd->hwc.cursorctrl);\n\tD(lcd->hwc.cursorpos);\n\tD(lcd->hwc.cursorcolor0);\n\tD(lcd->hwc.cursorcolor1);\n\tD(lcd->hwc.cursorcolor2);\n\tD(lcd->hwc.cursorcolor3);\n#endif\n}\n\nstatic void au1200_setmode(struct au1200fb_device *fbdev)\n{\n\tint plane = fbdev->plane;\n\t/* Window/plane setup */\n\tlcd->window[plane].winctrl1 = ( 0\n\t\t| LCD_WINCTRL1_PRI_N(plane)\n\t\t| win->w[plane].mode_winctrl1 /* FRM,CCO,PO,PIPE */\n\t\t) ;\n\n\tau1200_setlocation(fbdev, plane, win->w[plane].xpos, win->w[plane].ypos);\n\n\tlcd->window[plane].winctrl2 = ( 0\n\t\t| LCD_WINCTRL2_CKMODE_00\n\t\t| LCD_WINCTRL2_DBM\n\t\t| LCD_WINCTRL2_BX_N(fbdev->fb_info->fix.line_length)\n\t\t| LCD_WINCTRL2_SCX_1\n\t\t| LCD_WINCTRL2_SCY_1\n\t\t) ;\n\tlcd->winenable |= win->w[plane].mode_winenable;\n\tau_sync();\n}\n\n\n/* Inline helpers */\n\n/*#define panel_is_dual(panel)  ((panel->mode_screen & LCD_SCREEN_PT) == LCD_SCREEN_PT_010)*/\n/*#define panel_is_active(panel)((panel->mode_screen & LCD_SCREEN_PT) == LCD_SCREEN_PT_010)*/\n\n#define panel_is_color(panel) ((panel->mode_screen & LCD_SCREEN_PT) <= LCD_SCREEN_PT_CDSTN)\n\n/* Bitfields format supported by the controller. */\nstatic struct fb_bitfield rgb_bitfields[][4] = {\n  \t/*     Red, \t   Green, \t Blue, \t     Transp   */\n\t[LCD_WINCTRL1_FRM_16BPP655 >> 25] =\n\t\t{ { 10, 6, 0 }, { 5, 5, 0 }, { 0, 5, 0 }, { 0, 0, 0 } },\n\n\t[LCD_WINCTRL1_FRM_16BPP565 >> 25] =\n\t\t{ { 11, 5, 0 }, { 5, 6, 0 }, { 0, 5, 0 }, { 0, 0, 0 } },\n\n\t[LCD_WINCTRL1_FRM_16BPP556 >> 25] =\n\t\t{ { 11, 5, 0 }, { 6, 5, 0 }, { 0, 6, 0 }, { 0, 0, 0 } },\n\n\t[LCD_WINCTRL1_FRM_16BPPI1555 >> 25] =\n\t\t{ { 10, 5, 0 }, { 5, 5, 0 }, { 0, 5, 0 }, { 0, 0, 0 } },\n\n\t[LCD_WINCTRL1_FRM_16BPPI5551 >> 25] =\n\t\t{ { 11, 5, 0 }, { 6, 5, 0 }, { 1, 5, 0 }, { 0, 0, 0 } },\n\n\t[LCD_WINCTRL1_FRM_16BPPA1555 >> 25] =\n\t\t{ { 10, 5, 0 }, { 5, 5, 0 }, { 0, 5, 0 }, { 15, 1, 0 } },\n\n\t[LCD_WINCTRL1_FRM_16BPPA5551 >> 25] =\n\t\t{ { 11, 5, 0 }, { 6, 5, 0 }, { 1, 5, 0 }, { 0, 1, 0 } },\n\n\t[LCD_WINCTRL1_FRM_24BPP >> 25] =\n\t\t{ { 16, 8, 0 }, { 8, 8, 0 }, { 0, 8, 0 }, { 0, 0, 0 } },\n\n\t[LCD_WINCTRL1_FRM_32BPP >> 25] =\n\t\t{ { 16, 8, 0 }, { 8, 8, 0 }, { 0, 8, 0 }, { 24, 0, 0 } },\n};\n\n/*-------------------------------------------------------------------------*/\n\n/* Helpers */\n\nstatic void au1200fb_update_fbinfo(struct fb_info *fbi)\n{\n\t/* FIX!!!! This also needs to take the window pixel format into account!!! */\n\n\t/* Update var-dependent FB info */\n\tif (panel_is_color(panel)) {\n\t\tif (fbi->var.bits_per_pixel <= 8) {\n\t\t\t/* palettized */\n\t\t\tfbi->fix.visual = FB_VISUAL_PSEUDOCOLOR;\n\t\t\tfbi->fix.line_length = fbi->var.xres_virtual /\n\t\t\t\t(8/fbi->var.bits_per_pixel);\n\t\t} else {\n\t\t\t/* non-palettized */\n\t\t\tfbi->fix.visual = FB_VISUAL_TRUECOLOR;\n\t\t\tfbi->fix.line_length = fbi->var.xres_virtual * (fbi->var.bits_per_pixel / 8);\n\t\t}\n\t} else {\n\t\t/* mono FIX!!! mono 8 and 4 bits */\n\t\tfbi->fix.visual = FB_VISUAL_MONO10;\n\t\tfbi->fix.line_length = fbi->var.xres_virtual / 8;\n\t}\n\n\tfbi->screen_size = fbi->fix.line_length * fbi->var.yres_virtual;\n\tprint_dbg(\"line length: %d\\n\", fbi->fix.line_length);\n\tprint_dbg(\"bits_per_pixel: %d\\n\", fbi->var.bits_per_pixel);\n}\n\n/*-------------------------------------------------------------------------*/\n\n/* AU1200 framebuffer driver */\n\n/* fb_check_var\n * Validate var settings with hardware restrictions and modify it if necessary\n */\nstatic int au1200fb_fb_check_var(struct fb_var_screeninfo *var,\n\tstruct fb_info *fbi)\n{\n\tstruct au1200fb_device *fbdev = fbi->par;\n\tu32 pixclock;\n\tint screen_size, plane;\n\n\tplane = fbdev->plane;\n\n\t/* Make sure that the mode respect all LCD controller and\n\t * panel restrictions. */\n\tvar->xres = win->w[plane].xres;\n\tvar->yres = win->w[plane].yres;\n\n\t/* No need for virtual resolution support */\n\tvar->xres_virtual = var->xres;\n\tvar->yres_virtual = var->yres;\n\n\tvar->bits_per_pixel = winbpp(win->w[plane].mode_winctrl1);\n\n\tscreen_size = var->xres_virtual * var->yres_virtual;\n\tif (var->bits_per_pixel > 8) screen_size *= (var->bits_per_pixel / 8);\n\telse screen_size /= (8/var->bits_per_pixel);\n\n\tif (fbdev->fb_len < screen_size)\n\t\treturn -EINVAL; /* Virtual screen is to big, abort */\n\n\t/* FIX!!!! what are the implicaitons of ignoring this for windows ??? */\n\t/* The max LCD clock is fixed to 48MHz (value of AUX_CLK). The pixel\n\t * clock can only be obtain by dividing this value by an even integer.\n\t * Fallback to a slower pixel clock if necessary. */\n\tpixclock = max((u32)(PICOS2KHZ(var->pixclock) * 1000), fbi->monspecs.dclkmin);\n\tpixclock = min3(pixclock, fbi->monspecs.dclkmax, (u32)AU1200_LCD_MAX_CLK/2);\n\n\tif (AU1200_LCD_MAX_CLK % pixclock) {\n\t\tint diff = AU1200_LCD_MAX_CLK % pixclock;\n\t\tpixclock -= diff;\n\t}\n\n\tvar->pixclock = KHZ2PICOS(pixclock/1000);\n#if 0\n\tif (!panel_is_active(panel)) {\n\t\tint pcd = AU1200_LCD_MAX_CLK / (pixclock * 2) - 1;\n\n\t\tif (!panel_is_color(panel)\n\t\t\t&& (panel->control_base & LCD_CONTROL_MPI) && (pcd < 3)) {\n\t\t\t/* STN 8bit mono panel support is up to 6MHz pixclock */\n\t\t\tvar->pixclock = KHZ2PICOS(6000);\n\t\t} else if (!pcd) {\n\t\t\t/* Other STN panel support is up to 12MHz  */\n\t\t\tvar->pixclock = KHZ2PICOS(12000);\n\t\t}\n\t}\n#endif\n\t/* Set bitfield accordingly */\n\tswitch (var->bits_per_pixel) {\n\t\tcase 16:\n\t\t{\n\t\t\t/* 16bpp True color.\n\t\t\t * These must be set to MATCH WINCTRL[FORM] */\n\t\t\tint idx;\n\t\t\tidx = (win->w[0].mode_winctrl1 & LCD_WINCTRL1_FRM) >> 25;\n\t\t\tvar->red    = rgb_bitfields[idx][0];\n\t\t\tvar->green  = rgb_bitfields[idx][1];\n\t\t\tvar->blue   = rgb_bitfields[idx][2];\n\t\t\tvar->transp = rgb_bitfields[idx][3];\n\t\t\tbreak;\n\t\t}\n\n\t\tcase 32:\n\t\t{\n\t\t\t/* 32bpp True color.\n\t\t\t * These must be set to MATCH WINCTRL[FORM] */\n\t\t\tint idx;\n\t\t\tidx = (win->w[0].mode_winctrl1 & LCD_WINCTRL1_FRM) >> 25;\n\t\t\tvar->red    = rgb_bitfields[idx][0];\n\t\t\tvar->green  = rgb_bitfields[idx][1];\n\t\t\tvar->blue   = rgb_bitfields[idx][2];\n\t\t\tvar->transp = rgb_bitfields[idx][3];\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tprint_dbg(\"Unsupported depth %dbpp\", var->bits_per_pixel);\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n/* fb_set_par\n * Set hardware with var settings. This will enable the controller with a\n * specific mode, normally validated with the fb_check_var method\n */\nstatic int au1200fb_fb_set_par(struct fb_info *fbi)\n{\n\tstruct au1200fb_device *fbdev = fbi->par;\n\n\tau1200fb_update_fbinfo(fbi);\n\tau1200_setmode(fbdev);\n\n\treturn 0;\n}\n\n/* fb_setcolreg\n * Set color in LCD palette.\n */\nstatic int au1200fb_fb_setcolreg(unsigned regno, unsigned red, unsigned green,\n\tunsigned blue, unsigned transp, struct fb_info *fbi)\n{\n\tvolatile u32 *palette = lcd->palette;\n\tu32 value;\n\n\tif (regno > (AU1200_LCD_NBR_PALETTE_ENTRIES - 1))\n\t\treturn -EINVAL;\n\n\tif (fbi->var.grayscale) {\n\t\t/* Convert color to grayscale */\n\t\tred = green = blue =\n\t\t\t(19595 * red + 38470 * green + 7471 * blue) >> 16;\n\t}\n\n\tif (fbi->fix.visual == FB_VISUAL_TRUECOLOR) {\n\t\t/* Place color in the pseudopalette */\n\t\tif (regno > 16)\n\t\t\treturn -EINVAL;\n\n\t\tpalette = (u32*) fbi->pseudo_palette;\n\n\t\tred   >>= (16 - fbi->var.red.length);\n\t\tgreen >>= (16 - fbi->var.green.length);\n\t\tblue  >>= (16 - fbi->var.blue.length);\n\n\t\tvalue = (red   << fbi->var.red.offset) \t|\n\t\t\t(green << fbi->var.green.offset)|\n\t\t\t(blue  << fbi->var.blue.offset);\n\t\tvalue &= 0xFFFF;\n\n\t} else if (1 /*FIX!!! panel_is_active(fbdev->panel)*/) {\n\t\t/* COLOR TFT PALLETTIZED (use RGB 565) */\n\t\tvalue = (red & 0xF800)|((green >> 5) &\n\t\t\t\t0x07E0)|((blue >> 11) & 0x001F);\n\t\tvalue &= 0xFFFF;\n\n\t} else if (0 /*panel_is_color(fbdev->panel)*/) {\n\t\t/* COLOR STN MODE */\n\t\tvalue = 0x1234;\n\t\tvalue &= 0xFFF;\n\t} else {\n\t\t/* MONOCHROME MODE */\n\t\tvalue = (green >> 12) & 0x000F;\n\t\tvalue &= 0xF;\n\t}\n\n\tpalette[regno] = value;\n\n\treturn 0;\n}\n\n/* fb_blank\n * Blank the screen. Depending on the mode, the screen will be\n * activated with the backlight color, or desactivated\n */\nstatic int au1200fb_fb_blank(int blank_mode, struct fb_info *fbi)\n{\n\tstruct au1200fb_device *fbdev = fbi->par;\n\n\t/* Short-circuit screen blanking */\n\tif (noblanking)\n\t\treturn 0;\n\n\tswitch (blank_mode) {\n\n\tcase FB_BLANK_UNBLANK:\n\tcase FB_BLANK_NORMAL:\n\t\t/* printk(\"turn on panel\\n\"); */\n\t\tau1200_setpanel(panel, fbdev->pd);\n\t\tbreak;\n\tcase FB_BLANK_VSYNC_SUSPEND:\n\tcase FB_BLANK_HSYNC_SUSPEND:\n\tcase FB_BLANK_POWERDOWN:\n\t\t/* printk(\"turn off panel\\n\"); */\n\t\tau1200_setpanel(NULL, fbdev->pd);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\n\t}\n\n\t/* FB_BLANK_NORMAL is a soft blank */\n\treturn (blank_mode == FB_BLANK_NORMAL) ? -EINVAL : 0;\n}\n\n/* fb_mmap\n * Map video memory in user space. We don't use the generic fb_mmap\n * method mainly to allow the use of the TLB streaming flag (CCA=6)\n */\nstatic int au1200fb_fb_mmap(struct fb_info *info, struct vm_area_struct *vma)\n\n{\n\tunsigned int len;\n\tunsigned long start=0, off;\n\tstruct au1200fb_device *fbdev = info->par;\n\n\tif (vma->vm_pgoff > (~0UL >> PAGE_SHIFT)) {\n\t\treturn -EINVAL;\n\t}\n\n\tstart = fbdev->fb_phys & PAGE_MASK;\n\tlen = PAGE_ALIGN((start & ~PAGE_MASK) + fbdev->fb_len);\n\n\toff = vma->vm_pgoff << PAGE_SHIFT;\n\n\tif ((vma->vm_end - vma->vm_start + off) > len) {\n\t\treturn -EINVAL;\n\t}\n\n\toff += start;\n\tvma->vm_pgoff = off >> PAGE_SHIFT;\n\n\tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n\tpgprot_val(vma->vm_page_prot) |= _CACHE_MASK; /* CCA=7 */\n\n\treturn io_remap_pfn_range(vma, vma->vm_start, off >> PAGE_SHIFT,\n\t\t\t\t  vma->vm_end - vma->vm_start,\n\t\t\t\t  vma->vm_page_prot);\n}\n\nstatic void set_global(u_int cmd, struct au1200_lcd_global_regs_t *pdata)\n{\n\n\tunsigned int hi1, divider;\n\n\t/* SCREEN_SIZE: user cannot reset size, must switch panel choice */\n\n\tif (pdata->flags & SCREEN_BACKCOLOR)\n\t\tlcd->backcolor = pdata->backcolor;\n\n\tif (pdata->flags & SCREEN_BRIGHTNESS) {\n\n\t\t// limit brightness pwm duty to >= 30/1600\n\t\tif (pdata->brightness < 30) {\n\t\t\tpdata->brightness = 30;\n\t\t}\n\t\tdivider = (lcd->pwmdiv & 0x3FFFF) + 1;\n\t\thi1 = (lcd->pwmhi >> 16) + 1;\n\t\thi1 = (((pdata->brightness & 0xFF)+1) * divider >> 8);\n\t\tlcd->pwmhi &= 0xFFFF;\n\t\tlcd->pwmhi |= (hi1 << 16);\n\t}\n\n\tif (pdata->flags & SCREEN_COLORKEY)\n\t\tlcd->colorkey = pdata->colorkey;\n\n\tif (pdata->flags & SCREEN_MASK)\n\t\tlcd->colorkeymsk = pdata->mask;\n\tau_sync();\n}\n\nstatic void get_global(u_int cmd, struct au1200_lcd_global_regs_t *pdata)\n{\n\tunsigned int hi1, divider;\n\n\tpdata->xsize = ((lcd->screen & LCD_SCREEN_SX) >> 19) + 1;\n\tpdata->ysize = ((lcd->screen & LCD_SCREEN_SY) >> 8) + 1;\n\n\tpdata->backcolor = lcd->backcolor;\n\tpdata->colorkey = lcd->colorkey;\n\tpdata->mask = lcd->colorkeymsk;\n\n\t// brightness\n\thi1 = (lcd->pwmhi >> 16) + 1;\n\tdivider = (lcd->pwmdiv & 0x3FFFF) + 1;\n\tpdata->brightness = ((hi1 << 8) / divider) - 1;\n\tau_sync();\n}\n\nstatic void set_window(unsigned int plane,\n\tstruct au1200_lcd_window_regs_t *pdata)\n{\n\tunsigned int val, bpp;\n\n\t/* Window control register 0 */\n\tif (pdata->flags & WIN_POSITION) {\n\t\tval = lcd->window[plane].winctrl0 & ~(LCD_WINCTRL0_OX |\n\t\t\t\tLCD_WINCTRL0_OY);\n\t\tval |= ((pdata->xpos << 21) & LCD_WINCTRL0_OX);\n\t\tval |= ((pdata->ypos << 10) & LCD_WINCTRL0_OY);\n\t\tlcd->window[plane].winctrl0 = val;\n\t}\n\tif (pdata->flags & WIN_ALPHA_COLOR) {\n\t\tval = lcd->window[plane].winctrl0 & ~(LCD_WINCTRL0_A);\n\t\tval |= ((pdata->alpha_color << 2) & LCD_WINCTRL0_A);\n\t\tlcd->window[plane].winctrl0 = val;\n\t}\n\tif (pdata->flags & WIN_ALPHA_MODE) {\n\t\tval = lcd->window[plane].winctrl0 & ~(LCD_WINCTRL0_AEN);\n\t\tval |= ((pdata->alpha_mode << 1) & LCD_WINCTRL0_AEN);\n\t\tlcd->window[plane].winctrl0 = val;\n\t}\n\n\t/* Window control register 1 */\n\tif (pdata->flags & WIN_PRIORITY) {\n\t\tval = lcd->window[plane].winctrl1 & ~(LCD_WINCTRL1_PRI);\n\t\tval |= ((pdata->priority << 30) & LCD_WINCTRL1_PRI);\n\t\tlcd->window[plane].winctrl1 = val;\n\t}\n\tif (pdata->flags & WIN_CHANNEL) {\n\t\tval = lcd->window[plane].winctrl1 & ~(LCD_WINCTRL1_PIPE);\n\t\tval |= ((pdata->channel << 29) & LCD_WINCTRL1_PIPE);\n\t\tlcd->window[plane].winctrl1 = val;\n\t}\n\tif (pdata->flags & WIN_BUFFER_FORMAT) {\n\t\tval = lcd->window[plane].winctrl1 & ~(LCD_WINCTRL1_FRM);\n\t\tval |= ((pdata->buffer_format << 25) & LCD_WINCTRL1_FRM);\n\t\tlcd->window[plane].winctrl1 = val;\n\t}\n\tif (pdata->flags & WIN_COLOR_ORDER) {\n\t\tval = lcd->window[plane].winctrl1 & ~(LCD_WINCTRL1_CCO);\n\t\tval |= ((pdata->color_order << 24) & LCD_WINCTRL1_CCO);\n\t\tlcd->window[plane].winctrl1 = val;\n\t}\n\tif (pdata->flags & WIN_PIXEL_ORDER) {\n\t\tval = lcd->window[plane].winctrl1 & ~(LCD_WINCTRL1_PO);\n\t\tval |= ((pdata->pixel_order << 22) & LCD_WINCTRL1_PO);\n\t\tlcd->window[plane].winctrl1 = val;\n\t}\n\tif (pdata->flags & WIN_SIZE) {\n\t\tval = lcd->window[plane].winctrl1 & ~(LCD_WINCTRL1_SZX |\n\t\t\t\tLCD_WINCTRL1_SZY);\n\t\tval |= (((pdata->xsize << 11) - 1) & LCD_WINCTRL1_SZX);\n\t\tval |= (((pdata->ysize) - 1) & LCD_WINCTRL1_SZY);\n\t\tlcd->window[plane].winctrl1 = val;\n\t\t/* program buffer line width */\n\t\tbpp = winbpp(val) / 8;\n\t\tval = lcd->window[plane].winctrl2 & ~(LCD_WINCTRL2_BX);\n\t\tval |= (((pdata->xsize * bpp) << 8) & LCD_WINCTRL2_BX);\n\t\tlcd->window[plane].winctrl2 = val;\n\t}\n\n\t/* Window control register 2 */\n\tif (pdata->flags & WIN_COLORKEY_MODE) {\n\t\tval = lcd->window[plane].winctrl2 & ~(LCD_WINCTRL2_CKMODE);\n\t\tval |= ((pdata->colorkey_mode << 24) & LCD_WINCTRL2_CKMODE);\n\t\tlcd->window[plane].winctrl2 = val;\n\t}\n\tif (pdata->flags & WIN_DOUBLE_BUFFER_MODE) {\n\t\tval = lcd->window[plane].winctrl2 & ~(LCD_WINCTRL2_DBM);\n\t\tval |= ((pdata->double_buffer_mode << 23) & LCD_WINCTRL2_DBM);\n\t\tlcd->window[plane].winctrl2 = val;\n\t}\n\tif (pdata->flags & WIN_RAM_ARRAY_MODE) {\n\t\tval = lcd->window[plane].winctrl2 & ~(LCD_WINCTRL2_RAM);\n\t\tval |= ((pdata->ram_array_mode << 21) & LCD_WINCTRL2_RAM);\n\t\tlcd->window[plane].winctrl2 = val;\n\t}\n\n\t/* Buffer line width programmed with WIN_SIZE */\n\n\tif (pdata->flags & WIN_BUFFER_SCALE) {\n\t\tval = lcd->window[plane].winctrl2 & ~(LCD_WINCTRL2_SCX |\n\t\t\t\tLCD_WINCTRL2_SCY);\n\t\tval |= ((pdata->xsize << 11) & LCD_WINCTRL2_SCX);\n\t\tval |= ((pdata->ysize) & LCD_WINCTRL2_SCY);\n\t\tlcd->window[plane].winctrl2 = val;\n\t}\n\n\tif (pdata->flags & WIN_ENABLE) {\n\t\tval = lcd->winenable;\n\t\tval &= ~(1<<plane);\n\t\tval |= (pdata->enable & 1) << plane;\n\t\tlcd->winenable = val;\n\t}\n\tau_sync();\n}\n\nstatic void get_window(unsigned int plane,\n\tstruct au1200_lcd_window_regs_t *pdata)\n{\n\t/* Window control register 0 */\n\tpdata->xpos = (lcd->window[plane].winctrl0 & LCD_WINCTRL0_OX) >> 21;\n\tpdata->ypos = (lcd->window[plane].winctrl0 & LCD_WINCTRL0_OY) >> 10;\n\tpdata->alpha_color = (lcd->window[plane].winctrl0 & LCD_WINCTRL0_A) >> 2;\n\tpdata->alpha_mode = (lcd->window[plane].winctrl0 & LCD_WINCTRL0_AEN) >> 1;\n\n\t/* Window control register 1 */\n\tpdata->priority = (lcd->window[plane].winctrl1& LCD_WINCTRL1_PRI) >> 30;\n\tpdata->channel = (lcd->window[plane].winctrl1 & LCD_WINCTRL1_PIPE) >> 29;\n\tpdata->buffer_format = (lcd->window[plane].winctrl1 & LCD_WINCTRL1_FRM) >> 25;\n\tpdata->color_order = (lcd->window[plane].winctrl1 & LCD_WINCTRL1_CCO) >> 24;\n\tpdata->pixel_order = (lcd->window[plane].winctrl1 & LCD_WINCTRL1_PO) >> 22;\n\tpdata->xsize = ((lcd->window[plane].winctrl1 & LCD_WINCTRL1_SZX) >> 11) + 1;\n\tpdata->ysize = (lcd->window[plane].winctrl1 & LCD_WINCTRL1_SZY) + 1;\n\n\t/* Window control register 2 */\n\tpdata->colorkey_mode = (lcd->window[plane].winctrl2 & LCD_WINCTRL2_CKMODE) >> 24;\n\tpdata->double_buffer_mode = (lcd->window[plane].winctrl2 & LCD_WINCTRL2_DBM) >> 23;\n\tpdata->ram_array_mode = (lcd->window[plane].winctrl2 & LCD_WINCTRL2_RAM) >> 21;\n\n\tpdata->enable = (lcd->winenable >> plane) & 1;\n\tau_sync();\n}\n\nstatic int au1200fb_ioctl(struct fb_info *info, unsigned int cmd,\n                          unsigned long arg)\n{\n\tstruct au1200fb_device *fbdev = info->par;\n\tint plane;\n\tint val;\n\n\tplane = fbinfo2index(info);\n\tprint_dbg(\"au1200fb: ioctl %d on plane %d\\n\", cmd, plane);\n\n\tif (cmd == AU1200_LCD_FB_IOCTL) {\n\t\tstruct au1200_lcd_iodata_t iodata;\n\n\t\tif (copy_from_user(&iodata, (void __user *) arg, sizeof(iodata)))\n\t\t\treturn -EFAULT;\n\n\t\tprint_dbg(\"FB IOCTL called\\n\");\n\n\t\tswitch (iodata.subcmd) {\n\t\tcase AU1200_LCD_SET_SCREEN:\n\t\t\tprint_dbg(\"AU1200_LCD_SET_SCREEN\\n\");\n\t\t\tset_global(cmd, &iodata.global);\n\t\t\tbreak;\n\n\t\tcase AU1200_LCD_GET_SCREEN:\n\t\t\tprint_dbg(\"AU1200_LCD_GET_SCREEN\\n\");\n\t\t\tget_global(cmd, &iodata.global);\n\t\t\tbreak;\n\n\t\tcase AU1200_LCD_SET_WINDOW:\n\t\t\tprint_dbg(\"AU1200_LCD_SET_WINDOW\\n\");\n\t\t\tset_window(plane, &iodata.window);\n\t\t\tbreak;\n\n\t\tcase AU1200_LCD_GET_WINDOW:\n\t\t\tprint_dbg(\"AU1200_LCD_GET_WINDOW\\n\");\n\t\t\tget_window(plane, &iodata.window);\n\t\t\tbreak;\n\n\t\tcase AU1200_LCD_SET_PANEL:\n\t\t\tprint_dbg(\"AU1200_LCD_SET_PANEL\\n\");\n\t\t\tif ((iodata.global.panel_choice >= 0) &&\n\t\t\t\t\t(iodata.global.panel_choice <\n\t\t\t\t\t NUM_PANELS))\n\t\t\t{\n\t\t\t\tstruct panel_settings *newpanel;\n\t\t\t\tpanel_index = iodata.global.panel_choice;\n\t\t\t\tnewpanel = &known_lcd_panels[panel_index];\n\t\t\t\tau1200_setpanel(newpanel, fbdev->pd);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase AU1200_LCD_GET_PANEL:\n\t\t\tprint_dbg(\"AU1200_LCD_GET_PANEL\\n\");\n\t\t\tiodata.global.panel_choice = panel_index;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tval = copy_to_user((void __user *) arg, &iodata, sizeof(iodata));\n\t\tif (val) {\n\t\t\tprint_dbg(\"error: could not copy %d bytes\\n\", val);\n\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\nstatic struct fb_ops au1200fb_fb_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.fb_check_var\t= au1200fb_fb_check_var,\n\t.fb_set_par\t= au1200fb_fb_set_par,\n\t.fb_setcolreg\t= au1200fb_fb_setcolreg,\n\t.fb_blank\t= au1200fb_fb_blank,\n\t.fb_fillrect\t= sys_fillrect,\n\t.fb_copyarea\t= sys_copyarea,\n\t.fb_imageblit\t= sys_imageblit,\n\t.fb_read\t= fb_sys_read,\n\t.fb_write\t= fb_sys_write,\n\t.fb_sync\t= NULL,\n\t.fb_ioctl\t= au1200fb_ioctl,\n\t.fb_mmap\t= au1200fb_fb_mmap,\n};\n\n/*-------------------------------------------------------------------------*/\n\nstatic irqreturn_t au1200fb_handle_irq(int irq, void* dev_id)\n{\n\t/* Nothing to do for now, just clear any pending interrupt */\n\tlcd->intstatus = lcd->intstatus;\n\tau_sync();\n\n\treturn IRQ_HANDLED;\n}\n\n/*-------------------------------------------------------------------------*/\n\n/* AU1200 LCD device probe helpers */\n\nstatic int au1200fb_init_fbinfo(struct au1200fb_device *fbdev)\n{\n\tstruct fb_info *fbi = fbdev->fb_info;\n\tint bpp;\n\n\tfbi->fbops = &au1200fb_fb_ops;\n\n\tbpp = winbpp(win->w[fbdev->plane].mode_winctrl1);\n\n\t/* Copy monitor specs from panel data */\n\t/* fixme: we're setting up LCD controller windows, so these dont give a\n\tdamn as to what the monitor specs are (the panel itself does, but that\n\tisn't done here...so maybe need a generic catchall monitor setting??? */\n\tmemcpy(&fbi->monspecs, &panel->monspecs, sizeof(struct fb_monspecs));\n\n\t/* We first try the user mode passed in argument. If that failed,\n\t * or if no one has been specified, we default to the first mode of the\n\t * panel list. Note that after this call, var data will be set */\n\tif (!fb_find_mode(&fbi->var,\n\t\t\t  fbi,\n\t\t\t  NULL, /* drv_info.opt_mode, */\n\t\t\t  fbi->monspecs.modedb,\n\t\t\t  fbi->monspecs.modedb_len,\n\t\t\t  fbi->monspecs.modedb,\n\t\t\t  bpp)) {\n\n\t\tprint_err(\"Cannot find valid mode for panel %s\", panel->name);\n\t\treturn -EFAULT;\n\t}\n\n\tfbi->pseudo_palette = kcalloc(16, sizeof(u32), GFP_KERNEL);\n\tif (!fbi->pseudo_palette) {\n\t\treturn -ENOMEM;\n\t}\n\n\tif (fb_alloc_cmap(&fbi->cmap, AU1200_LCD_NBR_PALETTE_ENTRIES, 0) < 0) {\n\t\tprint_err(\"Fail to allocate colormap (%d entries)\",\n\t\t\t   AU1200_LCD_NBR_PALETTE_ENTRIES);\n\t\tkfree(fbi->pseudo_palette);\n\t\treturn -EFAULT;\n\t}\n\n\tstrncpy(fbi->fix.id, \"AU1200\", sizeof(fbi->fix.id));\n\tfbi->fix.smem_start = fbdev->fb_phys;\n\tfbi->fix.smem_len = fbdev->fb_len;\n\tfbi->fix.type = FB_TYPE_PACKED_PIXELS;\n\tfbi->fix.xpanstep = 0;\n\tfbi->fix.ypanstep = 0;\n\tfbi->fix.mmio_start = 0;\n\tfbi->fix.mmio_len = 0;\n\tfbi->fix.accel = FB_ACCEL_NONE;\n\n\tfbi->screen_base = (char __iomem *) fbdev->fb_mem;\n\n\tau1200fb_update_fbinfo(fbi);\n\n\treturn 0;\n}\n\n/*-------------------------------------------------------------------------*/\n\n\nstatic int au1200fb_setup(struct au1200fb_platdata *pd)\n{\n\tchar *options = NULL;\n\tchar *this_opt, *endptr;\n\tint num_panels = ARRAY_SIZE(known_lcd_panels);\n\tint panel_idx = -1;\n\n\tfb_get_options(DRIVER_NAME, &options);\n\n\tif (!options)\n\t\tgoto out;\n\n\twhile ((this_opt = strsep(&options, \",\")) != NULL) {\n\t\t/* Panel option - can be panel name,\n\t\t * \"bs\" for board-switch, or number/index */\n\t\tif (!strncmp(this_opt, \"panel:\", 6)) {\n\t\t\tint i;\n\t\t\tlong int li;\n\t\t\tchar *endptr;\n\t\t\tthis_opt += 6;\n\t\t\t/* First check for index, which allows\n\t\t\t * to short circuit this mess */\n\t\t\tli = simple_strtol(this_opt, &endptr, 0);\n\t\t\tif (*endptr == '\\0')\n\t\t\t\tpanel_idx = (int)li;\n\t\t\telse if (strcmp(this_opt, \"bs\") == 0)\n\t\t\t\tpanel_idx = pd->panel_index();\n\t\t\telse {\n\t\t\t\tfor (i = 0; i < num_panels; i++) {\n\t\t\t\t\tif (!strcmp(this_opt,\n\t\t\t\t\t\t    known_lcd_panels[i].name)) {\n\t\t\t\t\t\tpanel_idx = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((panel_idx < 0) || (panel_idx >= num_panels))\n\t\t\t\tprint_warn(\"Panel %s not supported!\", this_opt);\n\t\t\telse\n\t\t\t\tpanel_index = panel_idx;\n\n\t\t} else if (strncmp(this_opt, \"nohwcursor\", 10) == 0)\n\t\t\tnohwcursor = 1;\n\t\telse if (strncmp(this_opt, \"devices:\", 8) == 0) {\n\t\t\tthis_opt += 8;\n\t\t\tdevice_count = simple_strtol(this_opt, &endptr, 0);\n\t\t\tif ((device_count < 0) ||\n\t\t\t    (device_count > MAX_DEVICE_COUNT))\n\t\t\t\tdevice_count = MAX_DEVICE_COUNT;\n\t\t} else if (strncmp(this_opt, \"wincfg:\", 7) == 0) {\n\t\t\tthis_opt += 7;\n\t\t\twindow_index = simple_strtol(this_opt, &endptr, 0);\n\t\t\tif ((window_index < 0) ||\n\t\t\t    (window_index >= ARRAY_SIZE(windows)))\n\t\t\t\twindow_index = DEFAULT_WINDOW_INDEX;\n\t\t} else if (strncmp(this_opt, \"off\", 3) == 0)\n\t\t\treturn 1;\n\t\telse\n\t\t\tprint_warn(\"Unsupported option \\\"%s\\\"\", this_opt);\n\t}\n\nout:\n\treturn 0;\n}\n\n/* AU1200 LCD controller device driver */\nstatic int au1200fb_drv_probe(struct platform_device *dev)\n{\n\tstruct au1200fb_device *fbdev;\n\tstruct au1200fb_platdata *pd;\n\tstruct fb_info *fbi = NULL;\n\tunsigned long page;\n\tint bpp, plane, ret, irq;\n\n\tprint_info(\"\" DRIVER_DESC \"\");\n\n\tpd = dev->dev.platform_data;\n\tif (!pd)\n\t\treturn -ENODEV;\n\n\t/* Setup driver with options */\n\tif (au1200fb_setup(pd))\n\t\treturn -ENODEV;\n\n\t/* Point to the panel selected */\n\tpanel = &known_lcd_panels[panel_index];\n\twin = &windows[window_index];\n\n\tprintk(DRIVER_NAME \": Panel %d %s\\n\", panel_index, panel->name);\n\tprintk(DRIVER_NAME \": Win %d %s\\n\", window_index, win->name);\n\n\t/* shut gcc up */\n\tret = 0;\n\tfbdev = NULL;\n\n\tfor (plane = 0; plane < device_count; ++plane) {\n\t\tbpp = winbpp(win->w[plane].mode_winctrl1);\n\t\tif (win->w[plane].xres == 0)\n\t\t\twin->w[plane].xres = panel->Xres;\n\t\tif (win->w[plane].yres == 0)\n\t\t\twin->w[plane].yres = panel->Yres;\n\n\t\tfbi = framebuffer_alloc(sizeof(struct au1200fb_device),\n\t\t\t\t\t&dev->dev);\n\t\tif (!fbi)\n\t\t\tgoto failed;\n\n\t\t_au1200fb_infos[plane] = fbi;\n\t\tfbdev = fbi->par;\n\t\tfbdev->fb_info = fbi;\n\t\tfbdev->pd = pd;\n\n\t\tfbdev->plane = plane;\n\n\t\t/* Allocate the framebuffer to the maximum screen size */\n\t\tfbdev->fb_len = (win->w[plane].xres * win->w[plane].yres * bpp) / 8;\n\n\t\tfbdev->fb_mem = dmam_alloc_noncoherent(&dev->dev,\n\t\t\t\tPAGE_ALIGN(fbdev->fb_len),\n\t\t\t\t&fbdev->fb_phys, GFP_KERNEL);\n\t\tif (!fbdev->fb_mem) {\n\t\t\tprint_err(\"fail to allocate frambuffer (size: %dK))\",\n\t\t\t\t  fbdev->fb_len / 1024);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\t/*\n\t\t * Set page reserved so that mmap will work. This is necessary\n\t\t * since we'll be remapping normal memory.\n\t\t */\n\t\tfor (page = (unsigned long)fbdev->fb_phys;\n\t\t     page < PAGE_ALIGN((unsigned long)fbdev->fb_phys +\n\t\t\t     fbdev->fb_len);\n\t\t     page += PAGE_SIZE) {\n\t\t\tSetPageReserved(pfn_to_page(page >> PAGE_SHIFT)); /* LCD DMA is NOT coherent on Au1200 */\n\t\t}\n\t\tprint_dbg(\"Framebuffer memory map at %p\", fbdev->fb_mem);\n\t\tprint_dbg(\"phys=0x%08x, size=%dK\", fbdev->fb_phys, fbdev->fb_len / 1024);\n\n\t\t/* Init FB data */\n\t\tif ((ret = au1200fb_init_fbinfo(fbdev)) < 0)\n\t\t\tgoto failed;\n\n\t\t/* Register new framebuffer */\n\t\tret = register_framebuffer(fbi);\n\t\tif (ret < 0) {\n\t\t\tprint_err(\"cannot register new framebuffer\");\n\t\t\tgoto failed;\n\t\t}\n\n\t\tau1200fb_fb_set_par(fbi);\n\n#if !defined(CONFIG_FRAMEBUFFER_CONSOLE) && defined(CONFIG_LOGO)\n\t\tif (plane == 0)\n\t\t\tif (fb_prepare_logo(fbi, FB_ROTATE_UR)) {\n\t\t\t\t/* Start display and show logo on boot */\n\t\t\t\tfb_set_cmap(&fbi->cmap, fbi);\n\t\t\t\tfb_show_logo(fbi, FB_ROTATE_UR);\n\t\t\t}\n#endif\n\t}\n\n\t/* Now hook interrupt too */\n\tirq = platform_get_irq(dev, 0);\n\tret = request_irq(irq, au1200fb_handle_irq,\n\t\t\t  IRQF_SHARED, \"lcd\", (void *)dev);\n\tif (ret) {\n\t\tprint_err(\"fail to request interrupt line %d (err: %d)\",\n\t\t\t  irq, ret);\n\t\tgoto failed;\n\t}\n\n\tplatform_set_drvdata(dev, pd);\n\n\t/* Kickstart the panel */\n\tau1200_setpanel(panel, pd);\n\n\treturn 0;\n\nfailed:\n\t/* NOTE: This only does the current plane/window that failed; others are still active */\n\tif (fbi) {\n\t\tif (fbi->cmap.len != 0)\n\t\t\tfb_dealloc_cmap(&fbi->cmap);\n\t\tkfree(fbi->pseudo_palette);\n\t}\n\tif (plane == 0)\n\t\tfree_irq(AU1200_LCD_INT, (void*)dev);\n\treturn ret;\n}\n\nstatic int au1200fb_drv_remove(struct platform_device *dev)\n{\n\tstruct au1200fb_platdata *pd = platform_get_drvdata(dev);\n\tstruct au1200fb_device *fbdev;\n\tstruct fb_info *fbi;\n\tint plane;\n\n\t/* Turn off the panel */\n\tau1200_setpanel(NULL, pd);\n\n\tfor (plane = 0; plane < device_count; ++plane)\t{\n\t\tfbi = _au1200fb_infos[plane];\n\t\tfbdev = fbi->par;\n\n\t\t/* Clean up all probe data */\n\t\tunregister_framebuffer(fbi);\n\t\tif (fbi->cmap.len != 0)\n\t\t\tfb_dealloc_cmap(&fbi->cmap);\n\t\tkfree(fbi->pseudo_palette);\n\n\t\tframebuffer_release(fbi);\n\t\t_au1200fb_infos[plane] = NULL;\n\t}\n\n\tfree_irq(platform_get_irq(dev, 0), (void *)dev);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\nstatic int au1200fb_drv_suspend(struct device *dev)\n{\n\tstruct au1200fb_platdata *pd = dev_get_drvdata(dev);\n\tau1200_setpanel(NULL, pd);\n\n\tlcd->outmask = 0;\n\tau_sync();\n\n\treturn 0;\n}\n\nstatic int au1200fb_drv_resume(struct device *dev)\n{\n\tstruct au1200fb_platdata *pd = dev_get_drvdata(dev);\n\tstruct fb_info *fbi;\n\tint i;\n\n\t/* Kickstart the panel */\n\tau1200_setpanel(panel, pd);\n\n\tfor (i = 0; i < device_count; i++) {\n\t\tfbi = _au1200fb_infos[i];\n\t\tau1200fb_fb_set_par(fbi);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops au1200fb_pmops = {\n\t.suspend\t= au1200fb_drv_suspend,\n\t.resume\t\t= au1200fb_drv_resume,\n\t.freeze\t\t= au1200fb_drv_suspend,\n\t.thaw\t\t= au1200fb_drv_resume,\n};\n\n#define AU1200FB_PMOPS\t(&au1200fb_pmops)\n\n#else\n#define AU1200FB_PMOPS\tNULL\n#endif /* CONFIG_PM */\n\nstatic struct platform_driver au1200fb_driver = {\n\t.driver = {\n\t\t.name\t= \"au1200-lcd\",\n\t\t.owner\t= THIS_MODULE,\n\t\t.pm\t= AU1200FB_PMOPS,\n\t},\n\t.probe\t\t= au1200fb_drv_probe,\n\t.remove\t\t= au1200fb_drv_remove,\n};\n\n/*-------------------------------------------------------------------------*/\n\nstatic int __init au1200fb_init(void)\n{\n\treturn platform_driver_register(&au1200fb_driver);\n}\n\nstatic void __exit au1200fb_cleanup(void)\n{\n\tplatform_driver_unregister(&au1200fb_driver);\n}\n\nmodule_init(au1200fb_init);\nmodule_exit(au1200fb_cleanup);\n\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n"], "fixing_code": ["/*\n * drivers/uio/uio.c\n *\n * Copyright(C) 2005, Benedikt Spranger <b.spranger@linutronix.de>\n * Copyright(C) 2005, Thomas Gleixner <tglx@linutronix.de>\n * Copyright(C) 2006, Hans J. Koch <hjk@hansjkoch.de>\n * Copyright(C) 2006, Greg Kroah-Hartman <greg@kroah.com>\n *\n * Userspace IO\n *\n * Base Functions\n *\n * Licensed under the GPLv2 only.\n */\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/device.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/cdev.h>\n#include <linux/uio_driver.h>\n\n#define UIO_MAX_DEVICES\t\t(1U << MINORBITS)\n\nstruct uio_device {\n\tstruct module\t\t*owner;\n\tstruct device\t\t*dev;\n\tint\t\t\tminor;\n\tatomic_t\t\tevent;\n\tstruct fasync_struct\t*async_queue;\n\twait_queue_head_t\twait;\n\tstruct uio_info\t\t*info;\n\tstruct kobject\t\t*map_dir;\n\tstruct kobject\t\t*portio_dir;\n};\n\nstatic int uio_major;\nstatic struct cdev *uio_cdev;\nstatic DEFINE_IDR(uio_idr);\nstatic const struct file_operations uio_fops;\n\n/* Protect idr accesses */\nstatic DEFINE_MUTEX(minor_lock);\n\n/*\n * attributes\n */\n\nstruct uio_map {\n\tstruct kobject kobj;\n\tstruct uio_mem *mem;\n};\n#define to_map(map) container_of(map, struct uio_map, kobj)\n\nstatic ssize_t map_name_show(struct uio_mem *mem, char *buf)\n{\n\tif (unlikely(!mem->name))\n\t\tmem->name = \"\";\n\n\treturn sprintf(buf, \"%s\\n\", mem->name);\n}\n\nstatic ssize_t map_addr_show(struct uio_mem *mem, char *buf)\n{\n\treturn sprintf(buf, \"0x%llx\\n\", (unsigned long long)mem->addr);\n}\n\nstatic ssize_t map_size_show(struct uio_mem *mem, char *buf)\n{\n\treturn sprintf(buf, \"0x%lx\\n\", mem->size);\n}\n\nstatic ssize_t map_offset_show(struct uio_mem *mem, char *buf)\n{\n\treturn sprintf(buf, \"0x%llx\\n\", (unsigned long long)mem->addr & ~PAGE_MASK);\n}\n\nstruct map_sysfs_entry {\n\tstruct attribute attr;\n\tssize_t (*show)(struct uio_mem *, char *);\n\tssize_t (*store)(struct uio_mem *, const char *, size_t);\n};\n\nstatic struct map_sysfs_entry name_attribute =\n\t__ATTR(name, S_IRUGO, map_name_show, NULL);\nstatic struct map_sysfs_entry addr_attribute =\n\t__ATTR(addr, S_IRUGO, map_addr_show, NULL);\nstatic struct map_sysfs_entry size_attribute =\n\t__ATTR(size, S_IRUGO, map_size_show, NULL);\nstatic struct map_sysfs_entry offset_attribute =\n\t__ATTR(offset, S_IRUGO, map_offset_show, NULL);\n\nstatic struct attribute *attrs[] = {\n\t&name_attribute.attr,\n\t&addr_attribute.attr,\n\t&size_attribute.attr,\n\t&offset_attribute.attr,\n\tNULL,\t/* need to NULL terminate the list of attributes */\n};\n\nstatic void map_release(struct kobject *kobj)\n{\n\tstruct uio_map *map = to_map(kobj);\n\tkfree(map);\n}\n\nstatic ssize_t map_type_show(struct kobject *kobj, struct attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct uio_map *map = to_map(kobj);\n\tstruct uio_mem *mem = map->mem;\n\tstruct map_sysfs_entry *entry;\n\n\tentry = container_of(attr, struct map_sysfs_entry, attr);\n\n\tif (!entry->show)\n\t\treturn -EIO;\n\n\treturn entry->show(mem, buf);\n}\n\nstatic const struct sysfs_ops map_sysfs_ops = {\n\t.show = map_type_show,\n};\n\nstatic struct kobj_type map_attr_type = {\n\t.release\t= map_release,\n\t.sysfs_ops\t= &map_sysfs_ops,\n\t.default_attrs\t= attrs,\n};\n\nstruct uio_portio {\n\tstruct kobject kobj;\n\tstruct uio_port *port;\n};\n#define to_portio(portio) container_of(portio, struct uio_portio, kobj)\n\nstatic ssize_t portio_name_show(struct uio_port *port, char *buf)\n{\n\tif (unlikely(!port->name))\n\t\tport->name = \"\";\n\n\treturn sprintf(buf, \"%s\\n\", port->name);\n}\n\nstatic ssize_t portio_start_show(struct uio_port *port, char *buf)\n{\n\treturn sprintf(buf, \"0x%lx\\n\", port->start);\n}\n\nstatic ssize_t portio_size_show(struct uio_port *port, char *buf)\n{\n\treturn sprintf(buf, \"0x%lx\\n\", port->size);\n}\n\nstatic ssize_t portio_porttype_show(struct uio_port *port, char *buf)\n{\n\tconst char *porttypes[] = {\"none\", \"x86\", \"gpio\", \"other\"};\n\n\tif ((port->porttype < 0) || (port->porttype > UIO_PORT_OTHER))\n\t\treturn -EINVAL;\n\n\treturn sprintf(buf, \"port_%s\\n\", porttypes[port->porttype]);\n}\n\nstruct portio_sysfs_entry {\n\tstruct attribute attr;\n\tssize_t (*show)(struct uio_port *, char *);\n\tssize_t (*store)(struct uio_port *, const char *, size_t);\n};\n\nstatic struct portio_sysfs_entry portio_name_attribute =\n\t__ATTR(name, S_IRUGO, portio_name_show, NULL);\nstatic struct portio_sysfs_entry portio_start_attribute =\n\t__ATTR(start, S_IRUGO, portio_start_show, NULL);\nstatic struct portio_sysfs_entry portio_size_attribute =\n\t__ATTR(size, S_IRUGO, portio_size_show, NULL);\nstatic struct portio_sysfs_entry portio_porttype_attribute =\n\t__ATTR(porttype, S_IRUGO, portio_porttype_show, NULL);\n\nstatic struct attribute *portio_attrs[] = {\n\t&portio_name_attribute.attr,\n\t&portio_start_attribute.attr,\n\t&portio_size_attribute.attr,\n\t&portio_porttype_attribute.attr,\n\tNULL,\n};\n\nstatic void portio_release(struct kobject *kobj)\n{\n\tstruct uio_portio *portio = to_portio(kobj);\n\tkfree(portio);\n}\n\nstatic ssize_t portio_type_show(struct kobject *kobj, struct attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct uio_portio *portio = to_portio(kobj);\n\tstruct uio_port *port = portio->port;\n\tstruct portio_sysfs_entry *entry;\n\n\tentry = container_of(attr, struct portio_sysfs_entry, attr);\n\n\tif (!entry->show)\n\t\treturn -EIO;\n\n\treturn entry->show(port, buf);\n}\n\nstatic const struct sysfs_ops portio_sysfs_ops = {\n\t.show = portio_type_show,\n};\n\nstatic struct kobj_type portio_attr_type = {\n\t.release\t= portio_release,\n\t.sysfs_ops\t= &portio_sysfs_ops,\n\t.default_attrs\t= portio_attrs,\n};\n\nstatic ssize_t name_show(struct device *dev,\n\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct uio_device *idev = dev_get_drvdata(dev);\n\treturn sprintf(buf, \"%s\\n\", idev->info->name);\n}\nstatic DEVICE_ATTR_RO(name);\n\nstatic ssize_t version_show(struct device *dev,\n\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct uio_device *idev = dev_get_drvdata(dev);\n\treturn sprintf(buf, \"%s\\n\", idev->info->version);\n}\nstatic DEVICE_ATTR_RO(version);\n\nstatic ssize_t event_show(struct device *dev,\n\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct uio_device *idev = dev_get_drvdata(dev);\n\treturn sprintf(buf, \"%u\\n\", (unsigned int)atomic_read(&idev->event));\n}\nstatic DEVICE_ATTR_RO(event);\n\nstatic struct attribute *uio_attrs[] = {\n\t&dev_attr_name.attr,\n\t&dev_attr_version.attr,\n\t&dev_attr_event.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(uio);\n\n/* UIO class infrastructure */\nstatic struct class uio_class = {\n\t.name = \"uio\",\n\t.dev_groups = uio_groups,\n};\n\n/*\n * device functions\n */\nstatic int uio_dev_add_attributes(struct uio_device *idev)\n{\n\tint ret;\n\tint mi, pi;\n\tint map_found = 0;\n\tint portio_found = 0;\n\tstruct uio_mem *mem;\n\tstruct uio_map *map;\n\tstruct uio_port *port;\n\tstruct uio_portio *portio;\n\n\tfor (mi = 0; mi < MAX_UIO_MAPS; mi++) {\n\t\tmem = &idev->info->mem[mi];\n\t\tif (mem->size == 0)\n\t\t\tbreak;\n\t\tif (!map_found) {\n\t\t\tmap_found = 1;\n\t\t\tidev->map_dir = kobject_create_and_add(\"maps\",\n\t\t\t\t\t\t\t&idev->dev->kobj);\n\t\t\tif (!idev->map_dir)\n\t\t\t\tgoto err_map;\n\t\t}\n\t\tmap = kzalloc(sizeof(*map), GFP_KERNEL);\n\t\tif (!map)\n\t\t\tgoto err_map;\n\t\tkobject_init(&map->kobj, &map_attr_type);\n\t\tmap->mem = mem;\n\t\tmem->map = map;\n\t\tret = kobject_add(&map->kobj, idev->map_dir, \"map%d\", mi);\n\t\tif (ret)\n\t\t\tgoto err_map;\n\t\tret = kobject_uevent(&map->kobj, KOBJ_ADD);\n\t\tif (ret)\n\t\t\tgoto err_map;\n\t}\n\n\tfor (pi = 0; pi < MAX_UIO_PORT_REGIONS; pi++) {\n\t\tport = &idev->info->port[pi];\n\t\tif (port->size == 0)\n\t\t\tbreak;\n\t\tif (!portio_found) {\n\t\t\tportio_found = 1;\n\t\t\tidev->portio_dir = kobject_create_and_add(\"portio\",\n\t\t\t\t\t\t\t&idev->dev->kobj);\n\t\t\tif (!idev->portio_dir)\n\t\t\t\tgoto err_portio;\n\t\t}\n\t\tportio = kzalloc(sizeof(*portio), GFP_KERNEL);\n\t\tif (!portio)\n\t\t\tgoto err_portio;\n\t\tkobject_init(&portio->kobj, &portio_attr_type);\n\t\tportio->port = port;\n\t\tport->portio = portio;\n\t\tret = kobject_add(&portio->kobj, idev->portio_dir,\n\t\t\t\t\t\t\t\"port%d\", pi);\n\t\tif (ret)\n\t\t\tgoto err_portio;\n\t\tret = kobject_uevent(&portio->kobj, KOBJ_ADD);\n\t\tif (ret)\n\t\t\tgoto err_portio;\n\t}\n\n\treturn 0;\n\nerr_portio:\n\tfor (pi--; pi >= 0; pi--) {\n\t\tport = &idev->info->port[pi];\n\t\tportio = port->portio;\n\t\tkobject_put(&portio->kobj);\n\t}\n\tkobject_put(idev->portio_dir);\nerr_map:\n\tfor (mi--; mi>=0; mi--) {\n\t\tmem = &idev->info->mem[mi];\n\t\tmap = mem->map;\n\t\tkobject_put(&map->kobj);\n\t}\n\tkobject_put(idev->map_dir);\n\tdev_err(idev->dev, \"error creating sysfs files (%d)\\n\", ret);\n\treturn ret;\n}\n\nstatic void uio_dev_del_attributes(struct uio_device *idev)\n{\n\tint i;\n\tstruct uio_mem *mem;\n\tstruct uio_port *port;\n\n\tfor (i = 0; i < MAX_UIO_MAPS; i++) {\n\t\tmem = &idev->info->mem[i];\n\t\tif (mem->size == 0)\n\t\t\tbreak;\n\t\tkobject_put(&mem->map->kobj);\n\t}\n\tkobject_put(idev->map_dir);\n\n\tfor (i = 0; i < MAX_UIO_PORT_REGIONS; i++) {\n\t\tport = &idev->info->port[i];\n\t\tif (port->size == 0)\n\t\t\tbreak;\n\t\tkobject_put(&port->portio->kobj);\n\t}\n\tkobject_put(idev->portio_dir);\n}\n\nstatic int uio_get_minor(struct uio_device *idev)\n{\n\tint retval = -ENOMEM;\n\n\tmutex_lock(&minor_lock);\n\tretval = idr_alloc(&uio_idr, idev, 0, UIO_MAX_DEVICES, GFP_KERNEL);\n\tif (retval >= 0) {\n\t\tidev->minor = retval;\n\t\tretval = 0;\n\t} else if (retval == -ENOSPC) {\n\t\tdev_err(idev->dev, \"too many uio devices\\n\");\n\t\tretval = -EINVAL;\n\t}\n\tmutex_unlock(&minor_lock);\n\treturn retval;\n}\n\nstatic void uio_free_minor(struct uio_device *idev)\n{\n\tmutex_lock(&minor_lock);\n\tidr_remove(&uio_idr, idev->minor);\n\tmutex_unlock(&minor_lock);\n}\n\n/**\n * uio_event_notify - trigger an interrupt event\n * @info: UIO device capabilities\n */\nvoid uio_event_notify(struct uio_info *info)\n{\n\tstruct uio_device *idev = info->uio_dev;\n\n\tatomic_inc(&idev->event);\n\twake_up_interruptible(&idev->wait);\n\tkill_fasync(&idev->async_queue, SIGIO, POLL_IN);\n}\nEXPORT_SYMBOL_GPL(uio_event_notify);\n\n/**\n * uio_interrupt - hardware interrupt handler\n * @irq: IRQ number, can be UIO_IRQ_CYCLIC for cyclic timer\n * @dev_id: Pointer to the devices uio_device structure\n */\nstatic irqreturn_t uio_interrupt(int irq, void *dev_id)\n{\n\tstruct uio_device *idev = (struct uio_device *)dev_id;\n\tirqreturn_t ret = idev->info->handler(irq, idev->info);\n\n\tif (ret == IRQ_HANDLED)\n\t\tuio_event_notify(idev->info);\n\n\treturn ret;\n}\n\nstruct uio_listener {\n\tstruct uio_device *dev;\n\ts32 event_count;\n};\n\nstatic int uio_open(struct inode *inode, struct file *filep)\n{\n\tstruct uio_device *idev;\n\tstruct uio_listener *listener;\n\tint ret = 0;\n\n\tmutex_lock(&minor_lock);\n\tidev = idr_find(&uio_idr, iminor(inode));\n\tmutex_unlock(&minor_lock);\n\tif (!idev) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tif (!try_module_get(idev->owner)) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tlistener = kmalloc(sizeof(*listener), GFP_KERNEL);\n\tif (!listener) {\n\t\tret = -ENOMEM;\n\t\tgoto err_alloc_listener;\n\t}\n\n\tlistener->dev = idev;\n\tlistener->event_count = atomic_read(&idev->event);\n\tfilep->private_data = listener;\n\n\tif (idev->info->open) {\n\t\tret = idev->info->open(idev->info, inode);\n\t\tif (ret)\n\t\t\tgoto err_infoopen;\n\t}\n\treturn 0;\n\nerr_infoopen:\n\tkfree(listener);\n\nerr_alloc_listener:\n\tmodule_put(idev->owner);\n\nout:\n\treturn ret;\n}\n\nstatic int uio_fasync(int fd, struct file *filep, int on)\n{\n\tstruct uio_listener *listener = filep->private_data;\n\tstruct uio_device *idev = listener->dev;\n\n\treturn fasync_helper(fd, filep, on, &idev->async_queue);\n}\n\nstatic int uio_release(struct inode *inode, struct file *filep)\n{\n\tint ret = 0;\n\tstruct uio_listener *listener = filep->private_data;\n\tstruct uio_device *idev = listener->dev;\n\n\tif (idev->info->release)\n\t\tret = idev->info->release(idev->info, inode);\n\n\tmodule_put(idev->owner);\n\tkfree(listener);\n\treturn ret;\n}\n\nstatic unsigned int uio_poll(struct file *filep, poll_table *wait)\n{\n\tstruct uio_listener *listener = filep->private_data;\n\tstruct uio_device *idev = listener->dev;\n\n\tif (!idev->info->irq)\n\t\treturn -EIO;\n\n\tpoll_wait(filep, &idev->wait, wait);\n\tif (listener->event_count != atomic_read(&idev->event))\n\t\treturn POLLIN | POLLRDNORM;\n\treturn 0;\n}\n\nstatic ssize_t uio_read(struct file *filep, char __user *buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct uio_listener *listener = filep->private_data;\n\tstruct uio_device *idev = listener->dev;\n\tDECLARE_WAITQUEUE(wait, current);\n\tssize_t retval;\n\ts32 event_count;\n\n\tif (!idev->info->irq)\n\t\treturn -EIO;\n\n\tif (count != sizeof(s32))\n\t\treturn -EINVAL;\n\n\tadd_wait_queue(&idev->wait, &wait);\n\n\tdo {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\n\t\tevent_count = atomic_read(&idev->event);\n\t\tif (event_count != listener->event_count) {\n\t\t\tif (copy_to_user(buf, &event_count, count))\n\t\t\t\tretval = -EFAULT;\n\t\t\telse {\n\t\t\t\tlistener->event_count = event_count;\n\t\t\t\tretval = count;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tif (filep->f_flags & O_NONBLOCK) {\n\t\t\tretval = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (signal_pending(current)) {\n\t\t\tretval = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tschedule();\n\t} while (1);\n\n\t__set_current_state(TASK_RUNNING);\n\tremove_wait_queue(&idev->wait, &wait);\n\n\treturn retval;\n}\n\nstatic ssize_t uio_write(struct file *filep, const char __user *buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct uio_listener *listener = filep->private_data;\n\tstruct uio_device *idev = listener->dev;\n\tssize_t retval;\n\ts32 irq_on;\n\n\tif (!idev->info->irq)\n\t\treturn -EIO;\n\n\tif (count != sizeof(s32))\n\t\treturn -EINVAL;\n\n\tif (!idev->info->irqcontrol)\n\t\treturn -ENOSYS;\n\n\tif (copy_from_user(&irq_on, buf, count))\n\t\treturn -EFAULT;\n\n\tretval = idev->info->irqcontrol(idev->info, irq_on);\n\n\treturn retval ? retval : sizeof(s32);\n}\n\nstatic int uio_find_mem_index(struct vm_area_struct *vma)\n{\n\tstruct uio_device *idev = vma->vm_private_data;\n\n\tif (vma->vm_pgoff < MAX_UIO_MAPS) {\n\t\tif (idev->info->mem[vma->vm_pgoff].size == 0)\n\t\t\treturn -1;\n\t\treturn (int)vma->vm_pgoff;\n\t}\n\treturn -1;\n}\n\nstatic int uio_vma_fault(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\tstruct uio_device *idev = vma->vm_private_data;\n\tstruct page *page;\n\tunsigned long offset;\n\n\tint mi = uio_find_mem_index(vma);\n\tif (mi < 0)\n\t\treturn VM_FAULT_SIGBUS;\n\n\t/*\n\t * We need to subtract mi because userspace uses offset = N*PAGE_SIZE\n\t * to use mem[N].\n\t */\n\toffset = (vmf->pgoff - mi) << PAGE_SHIFT;\n\n\tif (idev->info->mem[mi].memtype == UIO_MEM_LOGICAL)\n\t\tpage = virt_to_page(idev->info->mem[mi].addr + offset);\n\telse\n\t\tpage = vmalloc_to_page((void *)(unsigned long)idev->info->mem[mi].addr + offset);\n\tget_page(page);\n\tvmf->page = page;\n\treturn 0;\n}\n\nstatic const struct vm_operations_struct uio_logical_vm_ops = {\n\t.fault = uio_vma_fault,\n};\n\nstatic int uio_mmap_logical(struct vm_area_struct *vma)\n{\n\tvma->vm_flags |= VM_DONTEXPAND | VM_DONTDUMP;\n\tvma->vm_ops = &uio_logical_vm_ops;\n\treturn 0;\n}\n\nstatic const struct vm_operations_struct uio_physical_vm_ops = {\n#ifdef CONFIG_HAVE_IOREMAP_PROT\n\t.access = generic_access_phys,\n#endif\n};\n\nstatic int uio_mmap_physical(struct vm_area_struct *vma)\n{\n\tstruct uio_device *idev = vma->vm_private_data;\n\tint mi = uio_find_mem_index(vma);\n\tstruct uio_mem *mem;\n\tif (mi < 0)\n\t\treturn -EINVAL;\n\tmem = idev->info->mem + mi;\n\n\tif (vma->vm_end - vma->vm_start > mem->size)\n\t\treturn -EINVAL;\n\n\tvma->vm_ops = &uio_physical_vm_ops;\n\tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n\n\t/*\n\t * We cannot use the vm_iomap_memory() helper here,\n\t * because vma->vm_pgoff is the map index we looked\n\t * up above in uio_find_mem_index(), rather than an\n\t * actual page offset into the mmap.\n\t *\n\t * So we just do the physical mmap without a page\n\t * offset.\n\t */\n\treturn remap_pfn_range(vma,\n\t\t\t       vma->vm_start,\n\t\t\t       mem->addr >> PAGE_SHIFT,\n\t\t\t       vma->vm_end - vma->vm_start,\n\t\t\t       vma->vm_page_prot);\n}\n\nstatic int uio_mmap(struct file *filep, struct vm_area_struct *vma)\n{\n\tstruct uio_listener *listener = filep->private_data;\n\tstruct uio_device *idev = listener->dev;\n\tint mi;\n\tunsigned long requested_pages, actual_pages;\n\tint ret = 0;\n\n\tif (vma->vm_end < vma->vm_start)\n\t\treturn -EINVAL;\n\n\tvma->vm_private_data = idev;\n\n\tmi = uio_find_mem_index(vma);\n\tif (mi < 0)\n\t\treturn -EINVAL;\n\n\trequested_pages = vma_pages(vma);\n\tactual_pages = ((idev->info->mem[mi].addr & ~PAGE_MASK)\n\t\t\t+ idev->info->mem[mi].size + PAGE_SIZE -1) >> PAGE_SHIFT;\n\tif (requested_pages > actual_pages)\n\t\treturn -EINVAL;\n\n\tif (idev->info->mmap) {\n\t\tret = idev->info->mmap(idev->info, vma);\n\t\treturn ret;\n\t}\n\n\tswitch (idev->info->mem[mi].memtype) {\n\t\tcase UIO_MEM_PHYS:\n\t\t\treturn uio_mmap_physical(vma);\n\t\tcase UIO_MEM_LOGICAL:\n\t\tcase UIO_MEM_VIRTUAL:\n\t\t\treturn uio_mmap_logical(vma);\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct file_operations uio_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= uio_open,\n\t.release\t= uio_release,\n\t.read\t\t= uio_read,\n\t.write\t\t= uio_write,\n\t.mmap\t\t= uio_mmap,\n\t.poll\t\t= uio_poll,\n\t.fasync\t\t= uio_fasync,\n\t.llseek\t\t= noop_llseek,\n};\n\nstatic int uio_major_init(void)\n{\n\tstatic const char name[] = \"uio\";\n\tstruct cdev *cdev = NULL;\n\tdev_t uio_dev = 0;\n\tint result;\n\n\tresult = alloc_chrdev_region(&uio_dev, 0, UIO_MAX_DEVICES, name);\n\tif (result)\n\t\tgoto out;\n\n\tresult = -ENOMEM;\n\tcdev = cdev_alloc();\n\tif (!cdev)\n\t\tgoto out_unregister;\n\n\tcdev->owner = THIS_MODULE;\n\tcdev->ops = &uio_fops;\n\tkobject_set_name(&cdev->kobj, \"%s\", name);\n\n\tresult = cdev_add(cdev, uio_dev, UIO_MAX_DEVICES);\n\tif (result)\n\t\tgoto out_put;\n\n\tuio_major = MAJOR(uio_dev);\n\tuio_cdev = cdev;\n\treturn 0;\nout_put:\n\tkobject_put(&cdev->kobj);\nout_unregister:\n\tunregister_chrdev_region(uio_dev, UIO_MAX_DEVICES);\nout:\n\treturn result;\n}\n\nstatic void uio_major_cleanup(void)\n{\n\tunregister_chrdev_region(MKDEV(uio_major, 0), UIO_MAX_DEVICES);\n\tcdev_del(uio_cdev);\n}\n\nstatic int init_uio_class(void)\n{\n\tint ret;\n\n\t/* This is the first time in here, set everything up properly */\n\tret = uio_major_init();\n\tif (ret)\n\t\tgoto exit;\n\n\tret = class_register(&uio_class);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"class_register failed for uio\\n\");\n\t\tgoto err_class_register;\n\t}\n\treturn 0;\n\nerr_class_register:\n\tuio_major_cleanup();\nexit:\n\treturn ret;\n}\n\nstatic void release_uio_class(void)\n{\n\tclass_unregister(&uio_class);\n\tuio_major_cleanup();\n}\n\n/**\n * uio_register_device - register a new userspace IO device\n * @owner:\tmodule that creates the new device\n * @parent:\tparent device\n * @info:\tUIO device capabilities\n *\n * returns zero on success or a negative error code.\n */\nint __uio_register_device(struct module *owner,\n\t\t\t  struct device *parent,\n\t\t\t  struct uio_info *info)\n{\n\tstruct uio_device *idev;\n\tint ret = 0;\n\n\tif (!parent || !info || !info->name || !info->version)\n\t\treturn -EINVAL;\n\n\tinfo->uio_dev = NULL;\n\n\tidev = kzalloc(sizeof(*idev), GFP_KERNEL);\n\tif (!idev) {\n\t\tret = -ENOMEM;\n\t\tgoto err_kzalloc;\n\t}\n\n\tidev->owner = owner;\n\tidev->info = info;\n\tinit_waitqueue_head(&idev->wait);\n\tatomic_set(&idev->event, 0);\n\n\tret = uio_get_minor(idev);\n\tif (ret)\n\t\tgoto err_get_minor;\n\n\tidev->dev = device_create(&uio_class, parent,\n\t\t\t\t  MKDEV(uio_major, idev->minor), idev,\n\t\t\t\t  \"uio%d\", idev->minor);\n\tif (IS_ERR(idev->dev)) {\n\t\tprintk(KERN_ERR \"UIO: device register failed\\n\");\n\t\tret = PTR_ERR(idev->dev);\n\t\tgoto err_device_create;\n\t}\n\n\tret = uio_dev_add_attributes(idev);\n\tif (ret)\n\t\tgoto err_uio_dev_add_attributes;\n\n\tinfo->uio_dev = idev;\n\n\tif (info->irq && (info->irq != UIO_IRQ_CUSTOM)) {\n\t\tret = request_irq(info->irq, uio_interrupt,\n\t\t\t\t  info->irq_flags, info->name, idev);\n\t\tif (ret)\n\t\t\tgoto err_request_irq;\n\t}\n\n\treturn 0;\n\nerr_request_irq:\n\tuio_dev_del_attributes(idev);\nerr_uio_dev_add_attributes:\n\tdevice_destroy(&uio_class, MKDEV(uio_major, idev->minor));\nerr_device_create:\n\tuio_free_minor(idev);\nerr_get_minor:\n\tkfree(idev);\nerr_kzalloc:\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(__uio_register_device);\n\n/**\n * uio_unregister_device - unregister a industrial IO device\n * @info:\tUIO device capabilities\n *\n */\nvoid uio_unregister_device(struct uio_info *info)\n{\n\tstruct uio_device *idev;\n\n\tif (!info || !info->uio_dev)\n\t\treturn;\n\n\tidev = info->uio_dev;\n\n\tuio_free_minor(idev);\n\n\tif (info->irq && (info->irq != UIO_IRQ_CUSTOM))\n\t\tfree_irq(info->irq, idev);\n\n\tuio_dev_del_attributes(idev);\n\n\tdevice_destroy(&uio_class, MKDEV(uio_major, idev->minor));\n\tkfree(idev);\n\n\treturn;\n}\nEXPORT_SYMBOL_GPL(uio_unregister_device);\n\nstatic int __init uio_init(void)\n{\n\treturn init_uio_class();\n}\n\nstatic void __exit uio_exit(void)\n{\n\trelease_uio_class();\n}\n\nmodule_init(uio_init)\nmodule_exit(uio_exit)\nMODULE_LICENSE(\"GPL v2\");\n", "/*\n * BRIEF MODULE DESCRIPTION\n *\tAu1100 LCD Driver.\n *\n * Rewritten for 2.6 by Embedded Alley Solutions\n * \t<source@embeddedalley.com>, based on submissions by\n *  \tKarl Lessard <klessard@sunrisetelecom.com>\n *  \t<c.pellegrin@exadron.com>\n *\n * PM support added by Rodolfo Giometti <giometti@linux.it>\n * Cursor enable/disable by Rodolfo Giometti <giometti@linux.it>\n *\n * Copyright 2002 MontaVista Software\n * Author: MontaVista Software, Inc.\n *\t\tppopov@mvista.com or source@mvista.com\n *\n * Copyright 2002 Alchemy Semiconductor\n * Author: Alchemy Semiconductor\n *\n * Based on:\n * linux/drivers/video/skeletonfb.c -- Skeleton for a frame buffer device\n *  Created 28 Dec 1997 by Geert Uytterhoeven\n *\n *  This program is free software; you can redistribute\t it and/or modify it\n *  under  the terms of\t the GNU General  Public License as published by the\n *  Free Software Foundation;  either version 2 of the\tLicense, or (at your\n *  option) any later version.\n *\n *  THIS  SOFTWARE  IS PROVIDED\t  ``AS\tIS'' AND   ANY\tEXPRESS OR IMPLIED\n *  WARRANTIES,\t  INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF\n *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN\n *  NO\tEVENT  SHALL   THE AUTHOR  BE\t LIABLE FOR ANY\t  DIRECT, INDIRECT,\n *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED\t  TO, PROCUREMENT OF  SUBSTITUTE GOODS\tOR SERVICES; LOSS OF\n *  USE, DATA,\tOR PROFITS; OR\tBUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n *  ANY THEORY OF LIABILITY, WHETHER IN\t CONTRACT, STRICT LIABILITY, OR TORT\n *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n *  You should have received a copy of the  GNU General Public License along\n *  with this program; if not, write  to the Free Software Foundation, Inc.,\n *  675 Mass Ave, Cambridge, MA 02139, USA.\n */\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/fb.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/ctype.h>\n#include <linux/dma-mapping.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#include <asm/mach-au1x00/au1000.h>\n\n#define DEBUG 0\n\n#include \"au1100fb.h\"\n\n#define DRIVER_NAME \"au1100fb\"\n#define DRIVER_DESC \"LCD controller driver for AU1100 processors\"\n\n#define to_au1100fb_device(_info) \\\n\t  (_info ? container_of(_info, struct au1100fb_device, info) : NULL);\n\n/* Bitfields format supported by the controller. Note that the order of formats\n * SHOULD be the same as in the LCD_CONTROL_SBPPF field, so we can retrieve the\n * right pixel format by doing rgb_bitfields[LCD_CONTROL_SBPPF_XXX >> LCD_CONTROL_SBPPF]\n */\nstruct fb_bitfield rgb_bitfields[][4] =\n{\n  \t/*     Red, \t   Green, \t Blue, \t     Transp   */\n\t{ { 10, 6, 0 }, { 5, 5, 0 }, { 0, 5, 0 }, { 0, 0, 0 } },\n\t{ { 11, 5, 0 }, { 5, 6, 0 }, { 0, 5, 0 }, { 0, 0, 0 } },\n\t{ { 11, 5, 0 }, { 6, 5, 0 }, { 0, 6, 0 }, { 0, 0, 0 } },\n\t{ { 10, 5, 0 }, { 5, 5, 0 }, { 0, 5, 0 }, { 15, 1, 0 } },\n\t{ { 11, 5, 0 }, { 6, 5, 0 }, { 1, 5, 0 }, { 0, 1, 0 } },\n\n\t/* The last is used to describe 12bpp format */\n\t{ { 8, 4, 0 },  { 4, 4, 0 }, { 0, 4, 0 }, { 0, 0, 0 } },\n};\n\nstatic struct fb_fix_screeninfo au1100fb_fix = {\n\t.id\t\t= \"AU1100 FB\",\n\t.xpanstep \t= 1,\n\t.ypanstep \t= 1,\n\t.type\t\t= FB_TYPE_PACKED_PIXELS,\n\t.accel\t\t= FB_ACCEL_NONE,\n};\n\nstatic struct fb_var_screeninfo au1100fb_var = {\n\t.activate\t= FB_ACTIVATE_NOW,\n\t.height\t\t= -1,\n\t.width\t\t= -1,\n\t.vmode\t\t= FB_VMODE_NONINTERLACED,\n};\n\n/* fb_blank\n * Blank the screen. Depending on the mode, the screen will be\n * activated with the backlight color, or desactivated\n */\nstatic int au1100fb_fb_blank(int blank_mode, struct fb_info *fbi)\n{\n\tstruct au1100fb_device *fbdev = to_au1100fb_device(fbi);\n\n\tprint_dbg(\"fb_blank %d %p\", blank_mode, fbi);\n\n\tswitch (blank_mode) {\n\n\tcase VESA_NO_BLANKING:\n\t\t/* Turn on panel */\n\t\tfbdev->regs->lcd_control |= LCD_CONTROL_GO;\n\t\tau_sync();\n\t\tbreak;\n\n\tcase VESA_VSYNC_SUSPEND:\n\tcase VESA_HSYNC_SUSPEND:\n\tcase VESA_POWERDOWN:\n\t\t/* Turn off panel */\n\t\tfbdev->regs->lcd_control &= ~LCD_CONTROL_GO;\n\t\tau_sync();\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\n\t}\n\treturn 0;\n}\n\n/*\n * Set hardware with var settings. This will enable the controller with a specific\n * mode, normally validated with the fb_check_var method\n\t */\nint au1100fb_setmode(struct au1100fb_device *fbdev)\n{\n\tstruct fb_info *info = &fbdev->info;\n\tu32 words;\n\tint index;\n\n\tif (!fbdev)\n\t\treturn -EINVAL;\n\n\t/* Update var-dependent FB info */\n\tif (panel_is_active(fbdev->panel) || panel_is_color(fbdev->panel)) {\n\t\tif (info->var.bits_per_pixel <= 8) {\n\t\t\t/* palettized */\n\t\t\tinfo->var.red.offset    = 0;\n\t\t\tinfo->var.red.length    = info->var.bits_per_pixel;\n\t\t\tinfo->var.red.msb_right = 0;\n\n\t\t\tinfo->var.green.offset  = 0;\n\t\t\tinfo->var.green.length  = info->var.bits_per_pixel;\n\t\t\tinfo->var.green.msb_right = 0;\n\n\t\t\tinfo->var.blue.offset   = 0;\n\t\t\tinfo->var.blue.length   = info->var.bits_per_pixel;\n\t\t\tinfo->var.blue.msb_right = 0;\n\n\t\t\tinfo->var.transp.offset = 0;\n\t\t\tinfo->var.transp.length = 0;\n\t\t\tinfo->var.transp.msb_right = 0;\n\n\t\t\tinfo->fix.visual = FB_VISUAL_PSEUDOCOLOR;\n\t\t\tinfo->fix.line_length = info->var.xres_virtual /\n\t\t\t\t\t\t\t(8/info->var.bits_per_pixel);\n\t\t} else {\n\t\t\t/* non-palettized */\n\t\t\tindex = (fbdev->panel->control_base & LCD_CONTROL_SBPPF_MASK) >> LCD_CONTROL_SBPPF_BIT;\n\t\t\tinfo->var.red = rgb_bitfields[index][0];\n\t\t\tinfo->var.green = rgb_bitfields[index][1];\n\t\t\tinfo->var.blue = rgb_bitfields[index][2];\n\t\t\tinfo->var.transp = rgb_bitfields[index][3];\n\n\t\t\tinfo->fix.visual = FB_VISUAL_TRUECOLOR;\n\t\t\tinfo->fix.line_length = info->var.xres_virtual << 1; /* depth=16 */\n\t\t}\n\t} else {\n\t\t/* mono */\n\t\tinfo->fix.visual = FB_VISUAL_MONO10;\n\t\tinfo->fix.line_length = info->var.xres_virtual / 8;\n\t}\n\n\tinfo->screen_size = info->fix.line_length * info->var.yres_virtual;\n\tinfo->var.rotate = ((fbdev->panel->control_base&LCD_CONTROL_SM_MASK) \\\n\t\t\t\t>> LCD_CONTROL_SM_BIT) * 90;\n\n\t/* Determine BPP mode and format */\n\tfbdev->regs->lcd_control = fbdev->panel->control_base;\n\tfbdev->regs->lcd_horztiming = fbdev->panel->horztiming;\n\tfbdev->regs->lcd_verttiming = fbdev->panel->verttiming;\n\tfbdev->regs->lcd_clkcontrol = fbdev->panel->clkcontrol_base;\n\tfbdev->regs->lcd_intenable = 0;\n\tfbdev->regs->lcd_intstatus = 0;\n\tfbdev->regs->lcd_dmaaddr0 = LCD_DMA_SA_N(fbdev->fb_phys);\n\n\tif (panel_is_dual(fbdev->panel)) {\n\t\t/* Second panel display seconf half of screen if possible,\n\t\t * otherwise display the same as the first panel */\n\t\tif (info->var.yres_virtual >= (info->var.yres << 1)) {\n\t\t\tfbdev->regs->lcd_dmaaddr1 = LCD_DMA_SA_N(fbdev->fb_phys +\n\t\t\t\t\t\t\t  (info->fix.line_length *\n\t\t\t\t\t\t          (info->var.yres_virtual >> 1)));\n\t\t} else {\n\t\t\tfbdev->regs->lcd_dmaaddr1 = LCD_DMA_SA_N(fbdev->fb_phys);\n\t\t}\n\t}\n\n\twords = info->fix.line_length / sizeof(u32);\n\tif (!info->var.rotate || (info->var.rotate == 180)) {\n\t\twords *= info->var.yres_virtual;\n\t\tif (info->var.rotate /* 180 */) {\n\t\t\twords -= (words % 8); /* should be divisable by 8 */\n\t\t}\n\t}\n\tfbdev->regs->lcd_words = LCD_WRD_WRDS_N(words);\n\n\tfbdev->regs->lcd_pwmdiv = 0;\n\tfbdev->regs->lcd_pwmhi = 0;\n\n\t/* Resume controller */\n\tfbdev->regs->lcd_control |= LCD_CONTROL_GO;\n\tmdelay(10);\n\tau1100fb_fb_blank(VESA_NO_BLANKING, info);\n\n\treturn 0;\n}\n\n/* fb_setcolreg\n * Set color in LCD palette.\n */\nint au1100fb_fb_setcolreg(unsigned regno, unsigned red, unsigned green, unsigned blue, unsigned transp, struct fb_info *fbi)\n{\n\tstruct au1100fb_device *fbdev;\n\tu32 *palette;\n\tu32 value;\n\n\tfbdev = to_au1100fb_device(fbi);\n\tpalette = fbdev->regs->lcd_pallettebase;\n\n\tif (regno > (AU1100_LCD_NBR_PALETTE_ENTRIES - 1))\n\t\treturn -EINVAL;\n\n\tif (fbi->var.grayscale) {\n\t\t/* Convert color to grayscale */\n\t\tred = green = blue =\n\t\t\t(19595 * red + 38470 * green + 7471 * blue) >> 16;\n\t}\n\n\tif (fbi->fix.visual == FB_VISUAL_TRUECOLOR) {\n\t\t/* Place color in the pseudopalette */\n\t\tif (regno > 16)\n\t\t\treturn -EINVAL;\n\n\t\tpalette = (u32*)fbi->pseudo_palette;\n\n\t\tred   >>= (16 - fbi->var.red.length);\n\t\tgreen >>= (16 - fbi->var.green.length);\n\t\tblue  >>= (16 - fbi->var.blue.length);\n\n\t\tvalue = (red   << fbi->var.red.offset) \t|\n\t\t\t(green << fbi->var.green.offset)|\n\t\t\t(blue  << fbi->var.blue.offset);\n\t\tvalue &= 0xFFFF;\n\n\t} else if (panel_is_active(fbdev->panel)) {\n\t\t/* COLOR TFT PALLETTIZED (use RGB 565) */\n\t\tvalue = (red & 0xF800)|((green >> 5) & 0x07E0)|((blue >> 11) & 0x001F);\n\t\tvalue &= 0xFFFF;\n\n\t} else if (panel_is_color(fbdev->panel)) {\n\t\t/* COLOR STN MODE */\n\t\tvalue = (((panel_swap_rgb(fbdev->panel) ? blue : red) >> 12) & 0x000F) |\n\t\t\t((green >> 8) & 0x00F0) |\n\t\t\t(((panel_swap_rgb(fbdev->panel) ? red : blue) >> 4) & 0x0F00);\n\t\tvalue &= 0xFFF;\n\t} else {\n\t\t/* MONOCHROME MODE */\n\t\tvalue = (green >> 12) & 0x000F;\n\t\tvalue &= 0xF;\n\t}\n\n\tpalette[regno] = value;\n\n\treturn 0;\n}\n\n/* fb_pan_display\n * Pan display in x and/or y as specified\n */\nint au1100fb_fb_pan_display(struct fb_var_screeninfo *var, struct fb_info *fbi)\n{\n\tstruct au1100fb_device *fbdev;\n\tint dy;\n\n\tfbdev = to_au1100fb_device(fbi);\n\n\tprint_dbg(\"fb_pan_display %p %p\", var, fbi);\n\n\tif (!var || !fbdev) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (var->xoffset - fbi->var.xoffset) {\n\t\t/* No support for X panning for now! */\n\t\treturn -EINVAL;\n\t}\n\n\tprint_dbg(\"fb_pan_display 2 %p %p\", var, fbi);\n\tdy = var->yoffset - fbi->var.yoffset;\n\tif (dy) {\n\n\t\tu32 dmaaddr;\n\n\t\tprint_dbg(\"Panning screen of %d lines\", dy);\n\n\t\tdmaaddr = fbdev->regs->lcd_dmaaddr0;\n\t\tdmaaddr += (fbi->fix.line_length * dy);\n\n\t\t/* TODO: Wait for current frame to finished */\n\t\tfbdev->regs->lcd_dmaaddr0 = LCD_DMA_SA_N(dmaaddr);\n\n\t\tif (panel_is_dual(fbdev->panel)) {\n\t\t\tdmaaddr = fbdev->regs->lcd_dmaaddr1;\n\t\t\tdmaaddr += (fbi->fix.line_length * dy);\n\t\t\tfbdev->regs->lcd_dmaaddr0 = LCD_DMA_SA_N(dmaaddr);\n\t}\n\t}\n\tprint_dbg(\"fb_pan_display 3 %p %p\", var, fbi);\n\n\treturn 0;\n}\n\n/* fb_rotate\n * Rotate the display of this angle. This doesn't seems to be used by the core,\n * but as our hardware supports it, so why not implementing it...\n */\nvoid au1100fb_fb_rotate(struct fb_info *fbi, int angle)\n{\n\tstruct au1100fb_device *fbdev = to_au1100fb_device(fbi);\n\n\tprint_dbg(\"fb_rotate %p %d\", fbi, angle);\n\n\tif (fbdev && (angle > 0) && !(angle % 90)) {\n\n\t\tfbdev->regs->lcd_control &= ~LCD_CONTROL_GO;\n\n\t\tfbdev->regs->lcd_control &= ~(LCD_CONTROL_SM_MASK);\n\t\tfbdev->regs->lcd_control |= ((angle/90) << LCD_CONTROL_SM_BIT);\n\n\t\tfbdev->regs->lcd_control |= LCD_CONTROL_GO;\n\t}\n}\n\n/* fb_mmap\n * Map video memory in user space. We don't use the generic fb_mmap method mainly\n * to allow the use of the TLB streaming flag (CCA=6)\n */\nint au1100fb_fb_mmap(struct fb_info *fbi, struct vm_area_struct *vma)\n{\n\tstruct au1100fb_device *fbdev;\n\n\tfbdev = to_au1100fb_device(fbi);\n\n\tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n\tpgprot_val(vma->vm_page_prot) |= (6 << 9); //CCA=6\n\n\treturn vm_iomap_memory(vma, fbdev->fb_phys, fbdev->fb_len);\n}\n\nstatic struct fb_ops au1100fb_ops =\n{\n\t.owner\t\t\t= THIS_MODULE,\n\t.fb_setcolreg\t\t= au1100fb_fb_setcolreg,\n\t.fb_blank\t\t= au1100fb_fb_blank,\n\t.fb_pan_display\t\t= au1100fb_fb_pan_display,\n\t.fb_fillrect\t\t= cfb_fillrect,\n\t.fb_copyarea\t\t= cfb_copyarea,\n\t.fb_imageblit\t\t= cfb_imageblit,\n\t.fb_rotate\t\t= au1100fb_fb_rotate,\n\t.fb_mmap\t\t= au1100fb_fb_mmap,\n};\n\n\n/*-------------------------------------------------------------------------*/\n\nstatic int au1100fb_setup(struct au1100fb_device *fbdev)\n{\n\tchar *this_opt, *options;\n\tint num_panels = ARRAY_SIZE(known_lcd_panels);\n\n\tif (num_panels <= 0) {\n\t\tprint_err(\"No LCD panels supported by driver!\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (fb_get_options(DRIVER_NAME, &options))\n\t\treturn -ENODEV;\n\tif (!options)\n\t\treturn -ENODEV;\n\n\twhile ((this_opt = strsep(&options, \",\")) != NULL) {\n\t\t/* Panel option */\n\t\tif (!strncmp(this_opt, \"panel:\", 6)) {\n\t\t\tint i;\n\t\t\tthis_opt += 6;\n\t\t\tfor (i = 0; i < num_panels; i++) {\n\t\t\t\tif (!strncmp(this_opt, known_lcd_panels[i].name,\n\t\t\t\t\t     strlen(this_opt))) {\n\t\t\t\t\tfbdev->panel = &known_lcd_panels[i];\n\t\t\t\t\tfbdev->panel_idx = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i >= num_panels) {\n\t\t\t\tprint_warn(\"Panel '%s' not supported!\", this_opt);\n\t\t\t\treturn -ENODEV;\n\t\t\t}\n\t\t}\n\t\t/* Unsupported option */\n\t\telse\n\t\t\tprint_warn(\"Unsupported option \\\"%s\\\"\", this_opt);\n\t}\n\n\tprint_info(\"Panel=%s\", fbdev->panel->name);\n\n\treturn 0;\n}\n\nstatic int au1100fb_drv_probe(struct platform_device *dev)\n{\n\tstruct au1100fb_device *fbdev = NULL;\n\tstruct resource *regs_res;\n\tunsigned long page;\n\tu32 sys_clksrc;\n\n\t/* Allocate new device private */\n\tfbdev = devm_kzalloc(&dev->dev, sizeof(struct au1100fb_device),\n\t\t\t     GFP_KERNEL);\n\tif (!fbdev) {\n\t\tprint_err(\"fail to allocate device private record\");\n\t\treturn -ENOMEM;\n\t}\n\n\tif (au1100fb_setup(fbdev))\n\t\tgoto failed;\n\n\tplatform_set_drvdata(dev, (void *)fbdev);\n\n\t/* Allocate region for our registers and map them */\n\tregs_res = platform_get_resource(dev, IORESOURCE_MEM, 0);\n\tif (!regs_res) {\n\t\tprint_err(\"fail to retrieve registers resource\");\n\t\treturn -EFAULT;\n\t}\n\n\tau1100fb_fix.mmio_start = regs_res->start;\n\tau1100fb_fix.mmio_len = resource_size(regs_res);\n\n\tif (!devm_request_mem_region(&dev->dev,\n\t\t\t\t     au1100fb_fix.mmio_start,\n\t\t\t\t     au1100fb_fix.mmio_len,\n\t\t\t\t     DRIVER_NAME)) {\n\t\tprint_err(\"fail to lock memory region at 0x%08lx\",\n\t\t\t\tau1100fb_fix.mmio_start);\n\t\treturn -EBUSY;\n\t}\n\n\tfbdev->regs = (struct au1100fb_regs*)KSEG1ADDR(au1100fb_fix.mmio_start);\n\n\tprint_dbg(\"Register memory map at %p\", fbdev->regs);\n\tprint_dbg(\"phys=0x%08x, size=%d\", fbdev->regs_phys, fbdev->regs_len);\n\n\t/* Allocate the framebuffer to the maximum screen size * nbr of video buffers */\n\tfbdev->fb_len = fbdev->panel->xres * fbdev->panel->yres *\n\t\t  \t(fbdev->panel->bpp >> 3) * AU1100FB_NBR_VIDEO_BUFFERS;\n\n\tfbdev->fb_mem = dmam_alloc_coherent(&dev->dev,\n\t\t\t\t\t    PAGE_ALIGN(fbdev->fb_len),\n\t\t\t\t\t    &fbdev->fb_phys, GFP_KERNEL);\n\tif (!fbdev->fb_mem) {\n\t\tprint_err(\"fail to allocate frambuffer (size: %dK))\",\n\t\t\t  fbdev->fb_len / 1024);\n\t\treturn -ENOMEM;\n\t}\n\n\tau1100fb_fix.smem_start = fbdev->fb_phys;\n\tau1100fb_fix.smem_len = fbdev->fb_len;\n\n\t/*\n\t * Set page reserved so that mmap will work. This is necessary\n\t * since we'll be remapping normal memory.\n\t */\n\tfor (page = (unsigned long)fbdev->fb_mem;\n\t     page < PAGE_ALIGN((unsigned long)fbdev->fb_mem + fbdev->fb_len);\n\t     page += PAGE_SIZE) {\n#ifdef CONFIG_DMA_NONCOHERENT\n\t\tSetPageReserved(virt_to_page(CAC_ADDR((void *)page)));\n#else\n\t\tSetPageReserved(virt_to_page(page));\n#endif\n\t}\n\n\tprint_dbg(\"Framebuffer memory map at %p\", fbdev->fb_mem);\n\tprint_dbg(\"phys=0x%08x, size=%dK\", fbdev->fb_phys, fbdev->fb_len / 1024);\n\n\t/* Setup LCD clock to AUX (48 MHz) */\n\tsys_clksrc = au_readl(SYS_CLKSRC) & ~(SYS_CS_ML_MASK | SYS_CS_DL | SYS_CS_CL);\n\tau_writel((sys_clksrc | (1 << SYS_CS_ML_BIT)), SYS_CLKSRC);\n\n\t/* load the panel info into the var struct */\n\tau1100fb_var.bits_per_pixel = fbdev->panel->bpp;\n\tau1100fb_var.xres = fbdev->panel->xres;\n\tau1100fb_var.xres_virtual = au1100fb_var.xres;\n\tau1100fb_var.yres = fbdev->panel->yres;\n\tau1100fb_var.yres_virtual = au1100fb_var.yres;\n\n\tfbdev->info.screen_base = fbdev->fb_mem;\n\tfbdev->info.fbops = &au1100fb_ops;\n\tfbdev->info.fix = au1100fb_fix;\n\n\tfbdev->info.pseudo_palette =\n\t\tdevm_kzalloc(&dev->dev, sizeof(u32) * 16, GFP_KERNEL);\n\tif (!fbdev->info.pseudo_palette)\n\t\treturn -ENOMEM;\n\n\tif (fb_alloc_cmap(&fbdev->info.cmap, AU1100_LCD_NBR_PALETTE_ENTRIES, 0) < 0) {\n\t\tprint_err(\"Fail to allocate colormap (%d entries)\",\n\t\t\t   AU1100_LCD_NBR_PALETTE_ENTRIES);\n\t\treturn -EFAULT;\n\t}\n\n\tfbdev->info.var = au1100fb_var;\n\n\t/* Set h/w registers */\n\tau1100fb_setmode(fbdev);\n\n\t/* Register new framebuffer */\n\tif (register_framebuffer(&fbdev->info) < 0) {\n\t\tprint_err(\"cannot register new framebuffer\");\n\t\tgoto failed;\n\t}\n\n\treturn 0;\n\nfailed:\n\tif (fbdev->fb_mem) {\n\t\tdma_free_noncoherent(&dev->dev, fbdev->fb_len, fbdev->fb_mem,\n\t\t\t\t     fbdev->fb_phys);\n\t}\n\tif (fbdev->info.cmap.len != 0) {\n\t\tfb_dealloc_cmap(&fbdev->info.cmap);\n\t}\n\n\treturn -ENODEV;\n}\n\nint au1100fb_drv_remove(struct platform_device *dev)\n{\n\tstruct au1100fb_device *fbdev = NULL;\n\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tfbdev = (struct au1100fb_device *) platform_get_drvdata(dev);\n\n#if !defined(CONFIG_FRAMEBUFFER_CONSOLE) && defined(CONFIG_LOGO)\n\tau1100fb_fb_blank(VESA_POWERDOWN, &fbdev->info);\n#endif\n\tfbdev->regs->lcd_control &= ~LCD_CONTROL_GO;\n\n\t/* Clean up all probe data */\n\tunregister_framebuffer(&fbdev->info);\n\n\tfb_dealloc_cmap(&fbdev->info.cmap);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\nstatic u32 sys_clksrc;\nstatic struct au1100fb_regs fbregs;\n\nint au1100fb_drv_suspend(struct platform_device *dev, pm_message_t state)\n{\n\tstruct au1100fb_device *fbdev = platform_get_drvdata(dev);\n\n\tif (!fbdev)\n\t\treturn 0;\n\n\t/* Save the clock source state */\n\tsys_clksrc = au_readl(SYS_CLKSRC);\n\n\t/* Blank the LCD */\n\tau1100fb_fb_blank(VESA_POWERDOWN, &fbdev->info);\n\n\t/* Stop LCD clocking */\n\tau_writel(sys_clksrc & ~SYS_CS_ML_MASK, SYS_CLKSRC);\n\n\tmemcpy(&fbregs, fbdev->regs, sizeof(struct au1100fb_regs));\n\n\treturn 0;\n}\n\nint au1100fb_drv_resume(struct platform_device *dev)\n{\n\tstruct au1100fb_device *fbdev = platform_get_drvdata(dev);\n\n\tif (!fbdev)\n\t\treturn 0;\n\n\tmemcpy(fbdev->regs, &fbregs, sizeof(struct au1100fb_regs));\n\n\t/* Restart LCD clocking */\n\tau_writel(sys_clksrc, SYS_CLKSRC);\n\n\t/* Unblank the LCD */\n\tau1100fb_fb_blank(VESA_NO_BLANKING, &fbdev->info);\n\n\treturn 0;\n}\n#else\n#define au1100fb_drv_suspend NULL\n#define au1100fb_drv_resume NULL\n#endif\n\nstatic struct platform_driver au1100fb_driver = {\n\t.driver = {\n\t\t.name\t\t= \"au1100-lcd\",\n\t\t.owner          = THIS_MODULE,\n\t},\n\t.probe\t\t= au1100fb_drv_probe,\n        .remove\t\t= au1100fb_drv_remove,\n\t.suspend\t= au1100fb_drv_suspend,\n        .resume\t\t= au1100fb_drv_resume,\n};\n\nstatic int __init au1100fb_load(void)\n{\n\treturn platform_driver_register(&au1100fb_driver);\n}\n\nstatic void __exit au1100fb_unload(void)\n{\n\tplatform_driver_unregister(&au1100fb_driver);\n}\n\nmodule_init(au1100fb_load);\nmodule_exit(au1100fb_unload);\n\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n", "/*\n * BRIEF MODULE DESCRIPTION\n *\tAu1200 LCD Driver.\n *\n * Copyright 2004-2005 AMD\n * Author: AMD\n *\n * Based on:\n * linux/drivers/video/skeletonfb.c -- Skeleton for a frame buffer device\n *  Created 28 Dec 1997 by Geert Uytterhoeven\n *\n *  This program is free software; you can redistribute\t it and/or modify it\n *  under  the terms of\t the GNU General  Public License as published by the\n *  Free Software Foundation;  either version 2 of the\tLicense, or (at your\n *  option) any later version.\n *\n *  THIS  SOFTWARE  IS PROVIDED\t  ``AS\tIS'' AND   ANY\tEXPRESS OR IMPLIED\n *  WARRANTIES,\t  INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF\n *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN\n *  NO\tEVENT  SHALL   THE AUTHOR  BE\t LIABLE FOR ANY\t  DIRECT, INDIRECT,\n *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED\t  TO, PROCUREMENT OF  SUBSTITUTE GOODS\tOR SERVICES; LOSS OF\n *  USE, DATA,\tOR PROFITS; OR\tBUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n *  ANY THEORY OF LIABILITY, WHETHER IN\t CONTRACT, STRICT LIABILITY, OR TORT\n *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n *  You should have received a copy of the  GNU General Public License along\n *  with this program; if not, write  to the Free Software Foundation, Inc.,\n *  675 Mass Ave, Cambridge, MA 02139, USA.\n */\n\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/fb.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/ctype.h>\n#include <linux/dma-mapping.h>\n#include <linux/slab.h>\n\n#include <asm/mach-au1x00/au1000.h>\n#include <asm/mach-au1x00/au1200fb.h>\t/* platform_data */\n#include \"au1200fb.h\"\n\n#define DRIVER_NAME \"au1200fb\"\n#define DRIVER_DESC \"LCD controller driver for AU1200 processors\"\n\n#define DEBUG 0\n\n#define print_err(f, arg...) printk(KERN_ERR DRIVER_NAME \": \" f \"\\n\", ## arg)\n#define print_warn(f, arg...) printk(KERN_WARNING DRIVER_NAME \": \" f \"\\n\", ## arg)\n#define print_info(f, arg...) printk(KERN_INFO DRIVER_NAME \": \" f \"\\n\", ## arg)\n\n#if DEBUG\n#define print_dbg(f, arg...) printk(KERN_DEBUG __FILE__ \": \" f \"\\n\", ## arg)\n#else\n#define print_dbg(f, arg...) do {} while (0)\n#endif\n\n\n#define AU1200_LCD_FB_IOCTL 0x46FF\n\n#define AU1200_LCD_SET_SCREEN 1\n#define AU1200_LCD_GET_SCREEN 2\n#define AU1200_LCD_SET_WINDOW 3\n#define AU1200_LCD_GET_WINDOW 4\n#define AU1200_LCD_SET_PANEL  5\n#define AU1200_LCD_GET_PANEL  6\n\n#define SCREEN_SIZE\t\t    (1<< 1)\n#define SCREEN_BACKCOLOR    (1<< 2)\n#define SCREEN_BRIGHTNESS   (1<< 3)\n#define SCREEN_COLORKEY     (1<< 4)\n#define SCREEN_MASK         (1<< 5)\n\nstruct au1200_lcd_global_regs_t {\n\tunsigned int flags;\n\tunsigned int xsize;\n\tunsigned int ysize;\n\tunsigned int backcolor;\n\tunsigned int brightness;\n\tunsigned int colorkey;\n\tunsigned int mask;\n\tunsigned int panel_choice;\n\tchar panel_desc[80];\n\n};\n\n#define WIN_POSITION            (1<< 0)\n#define WIN_ALPHA_COLOR         (1<< 1)\n#define WIN_ALPHA_MODE          (1<< 2)\n#define WIN_PRIORITY            (1<< 3)\n#define WIN_CHANNEL             (1<< 4)\n#define WIN_BUFFER_FORMAT       (1<< 5)\n#define WIN_COLOR_ORDER         (1<< 6)\n#define WIN_PIXEL_ORDER         (1<< 7)\n#define WIN_SIZE                (1<< 8)\n#define WIN_COLORKEY_MODE       (1<< 9)\n#define WIN_DOUBLE_BUFFER_MODE  (1<< 10)\n#define WIN_RAM_ARRAY_MODE      (1<< 11)\n#define WIN_BUFFER_SCALE        (1<< 12)\n#define WIN_ENABLE\t            (1<< 13)\n\nstruct au1200_lcd_window_regs_t {\n\tunsigned int flags;\n\tunsigned int xpos;\n\tunsigned int ypos;\n\tunsigned int alpha_color;\n\tunsigned int alpha_mode;\n\tunsigned int priority;\n\tunsigned int channel;\n\tunsigned int buffer_format;\n\tunsigned int color_order;\n\tunsigned int pixel_order;\n\tunsigned int xsize;\n\tunsigned int ysize;\n\tunsigned int colorkey_mode;\n\tunsigned int double_buffer_mode;\n\tunsigned int ram_array_mode;\n\tunsigned int xscale;\n\tunsigned int yscale;\n\tunsigned int enable;\n};\n\n\nstruct au1200_lcd_iodata_t {\n\tunsigned int subcmd;\n\tstruct au1200_lcd_global_regs_t global;\n\tstruct au1200_lcd_window_regs_t window;\n};\n\n#if defined(__BIG_ENDIAN)\n#define LCD_CONTROL_DEFAULT_PO LCD_CONTROL_PO_11\n#else\n#define LCD_CONTROL_DEFAULT_PO LCD_CONTROL_PO_00\n#endif\n#define LCD_CONTROL_DEFAULT_SBPPF LCD_CONTROL_SBPPF_565\n\n/* Private, per-framebuffer management information (independent of the panel itself) */\nstruct au1200fb_device {\n\tstruct fb_info *fb_info;\t\t/* FB driver info record */\n\tstruct au1200fb_platdata *pd;\n\n\tint\t\t\t\t\tplane;\n\tunsigned char* \t\tfb_mem;\t\t/* FrameBuffer memory map */\n\tunsigned int\t\tfb_len;\n\tdma_addr_t    \t\tfb_phys;\n};\n\n/********************************************************************/\n\n/* LCD controller restrictions */\n#define AU1200_LCD_MAX_XRES\t1280\n#define AU1200_LCD_MAX_YRES\t1024\n#define AU1200_LCD_MAX_BPP\t32\n#define AU1200_LCD_MAX_CLK\t96000000 /* fixme: this needs to go away ? */\n#define AU1200_LCD_NBR_PALETTE_ENTRIES 256\n\n/* Default number of visible screen buffer to allocate */\n#define AU1200FB_NBR_VIDEO_BUFFERS 1\n\n/* Default maximum number of fb devices to create */\n#define MAX_DEVICE_COUNT\t4\n\n/* Default window configuration entry to use (see windows[]) */\n#define DEFAULT_WINDOW_INDEX\t2\n\n/********************************************************************/\n\nstatic struct fb_info *_au1200fb_infos[MAX_DEVICE_COUNT];\nstatic struct au1200_lcd *lcd = (struct au1200_lcd *) AU1200_LCD_ADDR;\nstatic int device_count = MAX_DEVICE_COUNT;\nstatic int window_index = DEFAULT_WINDOW_INDEX;\t/* default is zero */\nstatic int panel_index = 2; /* default is zero */\nstatic struct window_settings *win;\nstatic struct panel_settings *panel;\nstatic int noblanking = 1;\nstatic int nohwcursor = 0;\n\nstruct window_settings {\n\tunsigned char name[64];\n\tuint32 mode_backcolor;\n\tuint32 mode_colorkey;\n\tuint32 mode_colorkeymsk;\n\tstruct {\n\t\tint xres;\n\t\tint yres;\n\t\tint xpos;\n\t\tint ypos;\n\t\tuint32 mode_winctrl1; /* winctrl1[FRM,CCO,PO,PIPE] */\n\t\tuint32 mode_winenable;\n\t} w[4];\n};\n\n#if defined(__BIG_ENDIAN)\n#define LCD_WINCTRL1_PO_16BPP LCD_WINCTRL1_PO_00\n#else\n#define LCD_WINCTRL1_PO_16BPP LCD_WINCTRL1_PO_01\n#endif\n\n/*\n * Default window configurations\n */\nstatic struct window_settings windows[] = {\n\t{ /* Index 0 */\n\t\t\"0-FS gfx, 1-video, 2-ovly gfx, 3-ovly gfx\",\n\t\t/* mode_backcolor\t*/ 0x006600ff,\n\t\t/* mode_colorkey,msk*/ 0, 0,\n\t\t{\n\t\t\t{\n\t\t\t/* xres, yres, xpos, ypos */ 0, 0, 0, 0,\n\t\t\t/* mode_winctrl1 */ LCD_WINCTRL1_FRM_16BPP565 |\n\t\t\t\tLCD_WINCTRL1_PO_16BPP,\n\t\t\t/* mode_winenable*/ LCD_WINENABLE_WEN0,\n\t\t\t},\n\t\t\t{\n\t\t\t/* xres, yres, xpos, ypos */ 100, 100, 100, 100,\n\t\t\t/* mode_winctrl1 */ LCD_WINCTRL1_FRM_16BPP565 |\n\t\t\t\tLCD_WINCTRL1_PO_16BPP |\n\t\t\t\tLCD_WINCTRL1_PIPE,\n\t\t\t/* mode_winenable*/ LCD_WINENABLE_WEN1,\n\t\t\t},\n\t\t\t{\n\t\t\t/* xres, yres, xpos, ypos */ 0, 0, 0, 0,\n\t\t\t/* mode_winctrl1 */ LCD_WINCTRL1_FRM_16BPP565 |\n\t\t\t\tLCD_WINCTRL1_PO_16BPP,\n\t\t\t/* mode_winenable*/ 0,\n\t\t\t},\n\t\t\t{\n\t\t\t/* xres, yres, xpos, ypos */ 0, 0, 0, 0,\n\t\t\t/* mode_winctrl1 */ LCD_WINCTRL1_FRM_16BPP565 |\n\t\t\t\tLCD_WINCTRL1_PO_16BPP |\n\t\t\t\tLCD_WINCTRL1_PIPE,\n\t\t\t/* mode_winenable*/ 0,\n\t\t\t},\n\t\t},\n\t},\n\n\t{ /* Index 1 */\n\t\t\"0-FS gfx, 1-video, 2-ovly gfx, 3-ovly gfx\",\n\t\t/* mode_backcolor\t*/ 0x006600ff,\n\t\t/* mode_colorkey,msk*/ 0, 0,\n\t\t{\n\t\t\t{\n\t\t\t/* xres, yres, xpos, ypos */ 320, 240, 5, 5,\n\t\t\t/* mode_winctrl1 */ LCD_WINCTRL1_FRM_24BPP |\n\t\t\t\tLCD_WINCTRL1_PO_00,\n\t\t\t/* mode_winenable*/ LCD_WINENABLE_WEN0,\n\t\t\t},\n\t\t\t{\n\t\t\t/* xres, yres, xpos, ypos */ 0, 0, 0, 0,\n\t\t\t/* mode_winctrl1 */ LCD_WINCTRL1_FRM_16BPP565\n\t\t\t\t| LCD_WINCTRL1_PO_16BPP,\n\t\t\t/* mode_winenable*/ 0,\n\t\t\t},\n\t\t\t{\n\t\t\t/* xres, yres, xpos, ypos */ 100, 100, 0, 0,\n\t\t\t/* mode_winctrl1 */ LCD_WINCTRL1_FRM_16BPP565 |\n\t\t\t\tLCD_WINCTRL1_PO_16BPP |\n\t\t\t\tLCD_WINCTRL1_PIPE,\n\t\t\t/* mode_winenable*/ 0/*LCD_WINENABLE_WEN2*/,\n\t\t\t},\n\t\t\t{\n\t\t\t/* xres, yres, xpos, ypos */ 200, 25, 0, 0,\n\t\t\t/* mode_winctrl1 */ LCD_WINCTRL1_FRM_16BPP565 |\n\t\t\t\tLCD_WINCTRL1_PO_16BPP |\n\t\t\t\tLCD_WINCTRL1_PIPE,\n\t\t\t/* mode_winenable*/ 0,\n\t\t\t},\n\t\t},\n\t},\n\t{ /* Index 2 */\n\t\t\"0-FS gfx, 1-video, 2-ovly gfx, 3-ovly gfx\",\n\t\t/* mode_backcolor\t*/ 0x006600ff,\n\t\t/* mode_colorkey,msk*/ 0, 0,\n\t\t{\n\t\t\t{\n\t\t\t/* xres, yres, xpos, ypos */ 0, 0, 0, 0,\n\t\t\t/* mode_winctrl1 */ LCD_WINCTRL1_FRM_16BPP565 |\n\t\t\t\tLCD_WINCTRL1_PO_16BPP,\n\t\t\t/* mode_winenable*/ LCD_WINENABLE_WEN0,\n\t\t\t},\n\t\t\t{\n\t\t\t/* xres, yres, xpos, ypos */ 0, 0, 0, 0,\n\t\t\t/* mode_winctrl1 */ LCD_WINCTRL1_FRM_16BPP565 |\n\t\t\t\tLCD_WINCTRL1_PO_16BPP,\n\t\t\t/* mode_winenable*/ 0,\n\t\t\t},\n\t\t\t{\n\t\t\t/* xres, yres, xpos, ypos */ 0, 0, 0, 0,\n\t\t\t/* mode_winctrl1 */ LCD_WINCTRL1_FRM_32BPP |\n\t\t\t\tLCD_WINCTRL1_PO_00|LCD_WINCTRL1_PIPE,\n\t\t\t/* mode_winenable*/ 0/*LCD_WINENABLE_WEN2*/,\n\t\t\t},\n\t\t\t{\n\t\t\t/* xres, yres, xpos, ypos */ 0, 0, 0, 0,\n\t\t\t/* mode_winctrl1 */ LCD_WINCTRL1_FRM_16BPP565 |\n\t\t\t\tLCD_WINCTRL1_PO_16BPP |\n\t\t\t\tLCD_WINCTRL1_PIPE,\n\t\t\t/* mode_winenable*/ 0,\n\t\t\t},\n\t\t},\n\t},\n\t/* Need VGA 640 @ 24bpp, @ 32bpp */\n\t/* Need VGA 800 @ 24bpp, @ 32bpp */\n\t/* Need VGA 1024 @ 24bpp, @ 32bpp */\n};\n\n/*\n * Controller configurations for various panels.\n */\n\nstruct panel_settings\n{\n\tconst char name[25];\t\t/* Full name <vendor>_<model> */\n\n\tstruct \tfb_monspecs monspecs; \t/* FB monitor specs */\n\n\t/* panel timings */\n\tuint32 mode_screen;\n\tuint32 mode_horztiming;\n\tuint32 mode_verttiming;\n\tuint32 mode_clkcontrol;\n\tuint32 mode_pwmdiv;\n\tuint32 mode_pwmhi;\n\tuint32 mode_outmask;\n\tuint32 mode_fifoctrl;\n\tuint32 mode_toyclksrc;\n\tuint32 mode_backlight;\n\tuint32 mode_auxpll;\n#define Xres min_xres\n#define Yres min_yres\n\tu32\tmin_xres;\t\t/* Minimum horizontal resolution */\n\tu32\tmax_xres;\t\t/* Maximum horizontal resolution */\n\tu32 \tmin_yres;\t\t/* Minimum vertical resolution */\n\tu32 \tmax_yres;\t\t/* Maximum vertical resolution */\n};\n\n/********************************************************************/\n/* fixme: Maybe a modedb for the CRT ? otherwise panels should be as-is */\n\n/* List of panels known to work with the AU1200 LCD controller.\n * To add a new panel, enter the same specifications as the\n * Generic_TFT one, and MAKE SURE that it doesn't conflicts\n * with the controller restrictions. Restrictions are:\n *\n * STN color panels: max_bpp <= 12\n * STN mono panels: max_bpp <= 4\n * TFT panels: max_bpp <= 16\n * max_xres <= 800\n * max_yres <= 600\n */\nstatic struct panel_settings known_lcd_panels[] =\n{\n\t[0] = { /* QVGA 320x240 H:33.3kHz V:110Hz */\n\t\t.name = \"QVGA_320x240\",\n\t\t.monspecs = {\n\t\t\t.modedb = NULL,\n\t\t\t.modedb_len = 0,\n\t\t\t.hfmin = 30000,\n\t\t\t.hfmax = 70000,\n\t\t\t.vfmin = 60,\n\t\t\t.vfmax = 60,\n\t\t\t.dclkmin = 6000000,\n\t\t\t.dclkmax = 28000000,\n\t\t\t.input = FB_DISP_RGB,\n\t\t},\n\t\t.mode_screen\t\t= LCD_SCREEN_SX_N(320) |\n\t\t\tLCD_SCREEN_SY_N(240),\n\t\t.mode_horztiming\t= 0x00c4623b,\n\t\t.mode_verttiming\t= 0x00502814,\n\t\t.mode_clkcontrol\t= 0x00020002, /* /4=24Mhz */\n\t\t.mode_pwmdiv\t\t= 0x00000000,\n\t\t.mode_pwmhi\t\t= 0x00000000,\n\t\t.mode_outmask\t= 0x00FFFFFF,\n\t\t.mode_fifoctrl\t= 0x2f2f2f2f,\n\t\t.mode_toyclksrc\t= 0x00000004, /* AUXPLL directly */\n\t\t.mode_backlight\t= 0x00000000,\n\t\t.mode_auxpll\t\t= 8, /* 96MHz AUXPLL */\n\t\t320, 320,\n\t\t240, 240,\n\t},\n\n\t[1] = { /* VGA 640x480 H:30.3kHz V:58Hz */\n\t\t.name = \"VGA_640x480\",\n\t\t.monspecs = {\n\t\t\t.modedb = NULL,\n\t\t\t.modedb_len = 0,\n\t\t\t.hfmin = 30000,\n\t\t\t.hfmax = 70000,\n\t\t\t.vfmin = 60,\n\t\t\t.vfmax = 60,\n\t\t\t.dclkmin = 6000000,\n\t\t\t.dclkmax = 28000000,\n\t\t\t.input = FB_DISP_RGB,\n\t\t},\n\t\t.mode_screen\t\t= 0x13f9df80,\n\t\t.mode_horztiming\t= 0x003c5859,\n\t\t.mode_verttiming\t= 0x00741201,\n\t\t.mode_clkcontrol\t= 0x00020001, /* /4=24Mhz */\n\t\t.mode_pwmdiv\t\t= 0x00000000,\n\t\t.mode_pwmhi\t\t= 0x00000000,\n\t\t.mode_outmask\t= 0x00FFFFFF,\n\t\t.mode_fifoctrl\t= 0x2f2f2f2f,\n\t\t.mode_toyclksrc\t= 0x00000004, /* AUXPLL directly */\n\t\t.mode_backlight\t= 0x00000000,\n\t\t.mode_auxpll\t\t= 8, /* 96MHz AUXPLL */\n\t\t640, 480,\n\t\t640, 480,\n\t},\n\n\t[2] = { /* SVGA 800x600 H:46.1kHz V:69Hz */\n\t\t.name = \"SVGA_800x600\",\n\t\t.monspecs = {\n\t\t\t.modedb = NULL,\n\t\t\t.modedb_len = 0,\n\t\t\t.hfmin = 30000,\n\t\t\t.hfmax = 70000,\n\t\t\t.vfmin = 60,\n\t\t\t.vfmax = 60,\n\t\t\t.dclkmin = 6000000,\n\t\t\t.dclkmax = 28000000,\n\t\t\t.input = FB_DISP_RGB,\n\t\t},\n\t\t.mode_screen\t\t= 0x18fa5780,\n\t\t.mode_horztiming\t= 0x00dc7e77,\n\t\t.mode_verttiming\t= 0x00584805,\n\t\t.mode_clkcontrol\t= 0x00020000, /* /2=48Mhz */\n\t\t.mode_pwmdiv\t\t= 0x00000000,\n\t\t.mode_pwmhi\t\t= 0x00000000,\n\t\t.mode_outmask\t= 0x00FFFFFF,\n\t\t.mode_fifoctrl\t= 0x2f2f2f2f,\n\t\t.mode_toyclksrc\t= 0x00000004, /* AUXPLL directly */\n\t\t.mode_backlight\t= 0x00000000,\n\t\t.mode_auxpll\t\t= 8, /* 96MHz AUXPLL */\n\t\t800, 800,\n\t\t600, 600,\n\t},\n\n\t[3] = { /* XVGA 1024x768 H:56.2kHz V:70Hz */\n\t\t.name = \"XVGA_1024x768\",\n\t\t.monspecs = {\n\t\t\t.modedb = NULL,\n\t\t\t.modedb_len = 0,\n\t\t\t.hfmin = 30000,\n\t\t\t.hfmax = 70000,\n\t\t\t.vfmin = 60,\n\t\t\t.vfmax = 60,\n\t\t\t.dclkmin = 6000000,\n\t\t\t.dclkmax = 28000000,\n\t\t\t.input = FB_DISP_RGB,\n\t\t},\n\t\t.mode_screen\t\t= 0x1ffaff80,\n\t\t.mode_horztiming\t= 0x007d0e57,\n\t\t.mode_verttiming\t= 0x00740a01,\n\t\t.mode_clkcontrol\t= 0x000A0000, /* /1 */\n\t\t.mode_pwmdiv\t\t= 0x00000000,\n\t\t.mode_pwmhi\t\t= 0x00000000,\n\t\t.mode_outmask\t= 0x00FFFFFF,\n\t\t.mode_fifoctrl\t= 0x2f2f2f2f,\n\t\t.mode_toyclksrc\t= 0x00000004, /* AUXPLL directly */\n\t\t.mode_backlight\t= 0x00000000,\n\t\t.mode_auxpll\t\t= 6, /* 72MHz AUXPLL */\n\t\t1024, 1024,\n\t\t768, 768,\n\t},\n\n\t[4] = { /* XVGA XVGA 1280x1024 H:68.5kHz V:65Hz */\n\t\t.name = \"XVGA_1280x1024\",\n\t\t.monspecs = {\n\t\t\t.modedb = NULL,\n\t\t\t.modedb_len = 0,\n\t\t\t.hfmin = 30000,\n\t\t\t.hfmax = 70000,\n\t\t\t.vfmin = 60,\n\t\t\t.vfmax = 60,\n\t\t\t.dclkmin = 6000000,\n\t\t\t.dclkmax = 28000000,\n\t\t\t.input = FB_DISP_RGB,\n\t\t},\n\t\t.mode_screen\t\t= 0x27fbff80,\n\t\t.mode_horztiming\t= 0x00cdb2c7,\n\t\t.mode_verttiming\t= 0x00600002,\n\t\t.mode_clkcontrol\t= 0x000A0000, /* /1 */\n\t\t.mode_pwmdiv\t\t= 0x00000000,\n\t\t.mode_pwmhi\t\t= 0x00000000,\n\t\t.mode_outmask\t= 0x00FFFFFF,\n\t\t.mode_fifoctrl\t= 0x2f2f2f2f,\n\t\t.mode_toyclksrc\t= 0x00000004, /* AUXPLL directly */\n\t\t.mode_backlight\t= 0x00000000,\n\t\t.mode_auxpll\t\t= 10, /* 120MHz AUXPLL */\n\t\t1280, 1280,\n\t\t1024, 1024,\n\t},\n\n\t[5] = { /* Samsung 1024x768 TFT */\n\t\t.name = \"Samsung_1024x768_TFT\",\n\t\t.monspecs = {\n\t\t\t.modedb = NULL,\n\t\t\t.modedb_len = 0,\n\t\t\t.hfmin = 30000,\n\t\t\t.hfmax = 70000,\n\t\t\t.vfmin = 60,\n\t\t\t.vfmax = 60,\n\t\t\t.dclkmin = 6000000,\n\t\t\t.dclkmax = 28000000,\n\t\t\t.input = FB_DISP_RGB,\n\t\t},\n\t\t.mode_screen\t\t= 0x1ffaff80,\n\t\t.mode_horztiming\t= 0x018cc677,\n\t\t.mode_verttiming\t= 0x00241217,\n\t\t.mode_clkcontrol\t= 0x00000000, /* SCB 0x1 /4=24Mhz */\n\t\t.mode_pwmdiv\t\t= 0x8000063f, /* SCB 0x0 */\n\t\t.mode_pwmhi\t\t= 0x03400000, /* SCB 0x0 */\n\t\t.mode_outmask\t= 0x00FFFFFF,\n\t\t.mode_fifoctrl\t= 0x2f2f2f2f,\n\t\t.mode_toyclksrc\t= 0x00000004, /* AUXPLL directly */\n\t\t.mode_backlight\t= 0x00000000,\n\t\t.mode_auxpll\t\t= 8, /* 96MHz AUXPLL */\n\t\t1024, 1024,\n\t\t768, 768,\n\t},\n\n\t[6] = { /* Toshiba 640x480 TFT */\n\t\t.name = \"Toshiba_640x480_TFT\",\n\t\t.monspecs = {\n\t\t\t.modedb = NULL,\n\t\t\t.modedb_len = 0,\n\t\t\t.hfmin = 30000,\n\t\t\t.hfmax = 70000,\n\t\t\t.vfmin = 60,\n\t\t\t.vfmax = 60,\n\t\t\t.dclkmin = 6000000,\n\t\t\t.dclkmax = 28000000,\n\t\t\t.input = FB_DISP_RGB,\n\t\t},\n\t\t.mode_screen\t\t= LCD_SCREEN_SX_N(640) |\n\t\t\tLCD_SCREEN_SY_N(480),\n\t\t.mode_horztiming\t= LCD_HORZTIMING_HPW_N(96) |\n\t\t\tLCD_HORZTIMING_HND1_N(13) | LCD_HORZTIMING_HND2_N(51),\n\t\t.mode_verttiming\t= LCD_VERTTIMING_VPW_N(2) |\n\t\t\tLCD_VERTTIMING_VND1_N(11) | LCD_VERTTIMING_VND2_N(32),\n\t\t.mode_clkcontrol\t= 0x00000000, /* /4=24Mhz */\n\t\t.mode_pwmdiv\t\t= 0x8000063f,\n\t\t.mode_pwmhi\t\t= 0x03400000,\n\t\t.mode_outmask\t= 0x00fcfcfc,\n\t\t.mode_fifoctrl\t= 0x2f2f2f2f,\n\t\t.mode_toyclksrc\t= 0x00000004, /* AUXPLL directly */\n\t\t.mode_backlight\t= 0x00000000,\n\t\t.mode_auxpll\t\t= 8, /* 96MHz AUXPLL */\n\t\t640, 480,\n\t\t640, 480,\n\t},\n\n\t[7] = { /* Sharp 320x240 TFT */\n\t\t.name = \"Sharp_320x240_TFT\",\n\t\t.monspecs = {\n\t\t\t.modedb = NULL,\n\t\t\t.modedb_len = 0,\n\t\t\t.hfmin = 12500,\n\t\t\t.hfmax = 20000,\n\t\t\t.vfmin = 38,\n\t\t\t.vfmax = 81,\n\t\t\t.dclkmin = 4500000,\n\t\t\t.dclkmax = 6800000,\n\t\t\t.input = FB_DISP_RGB,\n\t\t},\n\t\t.mode_screen\t\t= LCD_SCREEN_SX_N(320) |\n\t\t\tLCD_SCREEN_SY_N(240),\n\t\t.mode_horztiming\t= LCD_HORZTIMING_HPW_N(60) |\n\t\t\tLCD_HORZTIMING_HND1_N(13) | LCD_HORZTIMING_HND2_N(2),\n\t\t.mode_verttiming\t= LCD_VERTTIMING_VPW_N(2) |\n\t\t\tLCD_VERTTIMING_VND1_N(2) | LCD_VERTTIMING_VND2_N(5),\n\t\t.mode_clkcontrol\t= LCD_CLKCONTROL_PCD_N(7), /*16=6Mhz*/\n\t\t.mode_pwmdiv\t\t= 0x8000063f,\n\t\t.mode_pwmhi\t\t= 0x03400000,\n\t\t.mode_outmask\t= 0x00fcfcfc,\n\t\t.mode_fifoctrl\t= 0x2f2f2f2f,\n\t\t.mode_toyclksrc\t= 0x00000004, /* AUXPLL directly */\n\t\t.mode_backlight\t= 0x00000000,\n\t\t.mode_auxpll\t\t= 8, /* 96MHz AUXPLL */\n\t\t320, 320,\n\t\t240, 240,\n\t},\n\n\t[8] = { /* Toppoly TD070WGCB2 7\" 856x480 TFT */\n\t\t.name = \"Toppoly_TD070WGCB2\",\n\t\t.monspecs = {\n\t\t\t.modedb = NULL,\n\t\t\t.modedb_len = 0,\n\t\t\t.hfmin = 30000,\n\t\t\t.hfmax = 70000,\n\t\t\t.vfmin = 60,\n\t\t\t.vfmax = 60,\n\t\t\t.dclkmin = 6000000,\n\t\t\t.dclkmax = 28000000,\n\t\t\t.input = FB_DISP_RGB,\n\t\t},\n\t\t.mode_screen\t\t= LCD_SCREEN_SX_N(856) |\n\t\t\tLCD_SCREEN_SY_N(480),\n\t\t.mode_horztiming\t= LCD_HORZTIMING_HND2_N(43) |\n\t\t\tLCD_HORZTIMING_HND1_N(43) | LCD_HORZTIMING_HPW_N(114),\n\t\t.mode_verttiming\t= LCD_VERTTIMING_VND2_N(20) |\n\t\t\tLCD_VERTTIMING_VND1_N(21) | LCD_VERTTIMING_VPW_N(4),\n\t\t.mode_clkcontrol\t= 0x00020001, /* /4=24Mhz */\n\t\t.mode_pwmdiv\t\t= 0x8000063f,\n\t\t.mode_pwmhi\t\t= 0x03400000,\n\t\t.mode_outmask\t= 0x00fcfcfc,\n\t\t.mode_fifoctrl\t= 0x2f2f2f2f,\n\t\t.mode_toyclksrc\t= 0x00000004, /* AUXPLL directly */\n\t\t.mode_backlight\t= 0x00000000,\n\t\t.mode_auxpll\t\t= 8, /* 96MHz AUXPLL */\n\t\t856, 856,\n\t\t480, 480,\n\t},\n\t[9] = {\n\t\t.name = \"DB1300_800x480\",\n\t\t.monspecs = {\n\t\t\t.modedb = NULL,\n\t\t\t.modedb_len = 0,\n\t\t\t.hfmin = 30000,\n\t\t\t.hfmax = 70000,\n\t\t\t.vfmin = 60,\n\t\t\t.vfmax = 60,\n\t\t\t.dclkmin = 6000000,\n\t\t\t.dclkmax = 28000000,\n\t\t\t.input = FB_DISP_RGB,\n\t\t},\n\t\t.mode_screen\t\t= LCD_SCREEN_SX_N(800) |\n\t\t\t\t\t  LCD_SCREEN_SY_N(480),\n\t\t.mode_horztiming\t= LCD_HORZTIMING_HPW_N(5) |\n\t\t\t\t\t  LCD_HORZTIMING_HND1_N(16) |\n\t\t\t\t\t  LCD_HORZTIMING_HND2_N(8),\n\t\t.mode_verttiming\t= LCD_VERTTIMING_VPW_N(4) |\n\t\t\t\t\t  LCD_VERTTIMING_VND1_N(8) |\n\t\t\t\t\t  LCD_VERTTIMING_VND2_N(5),\n\t\t.mode_clkcontrol\t= LCD_CLKCONTROL_PCD_N(1) |\n\t\t\t\t\t  LCD_CLKCONTROL_IV |\n\t\t\t\t\t  LCD_CLKCONTROL_IH,\n\t\t.mode_pwmdiv\t\t= 0x00000000,\n\t\t.mode_pwmhi\t\t= 0x00000000,\n\t\t.mode_outmask\t\t= 0x00FFFFFF,\n\t\t.mode_fifoctrl\t\t= 0x2f2f2f2f,\n\t\t.mode_toyclksrc\t\t= 0x00000004, /* AUXPLL directly */\n\t\t.mode_backlight\t\t= 0x00000000,\n\t\t.mode_auxpll\t\t= (48/12) * 2,\n\t\t800, 800,\n\t\t480, 480,\n\t},\n};\n\n#define NUM_PANELS (ARRAY_SIZE(known_lcd_panels))\n\n/********************************************************************/\n\nstatic int winbpp (unsigned int winctrl1)\n{\n\tint bits = 0;\n\n\t/* how many bits are needed for each pixel format */\n\tswitch (winctrl1 & LCD_WINCTRL1_FRM) {\n\tcase LCD_WINCTRL1_FRM_1BPP:\n\t\tbits = 1;\n\t\tbreak;\n\tcase LCD_WINCTRL1_FRM_2BPP:\n\t\tbits = 2;\n\t\tbreak;\n\tcase LCD_WINCTRL1_FRM_4BPP:\n\t\tbits = 4;\n\t\tbreak;\n\tcase LCD_WINCTRL1_FRM_8BPP:\n\t\tbits = 8;\n\t\tbreak;\n\tcase LCD_WINCTRL1_FRM_12BPP:\n\tcase LCD_WINCTRL1_FRM_16BPP655:\n\tcase LCD_WINCTRL1_FRM_16BPP565:\n\tcase LCD_WINCTRL1_FRM_16BPP556:\n\tcase LCD_WINCTRL1_FRM_16BPPI1555:\n\tcase LCD_WINCTRL1_FRM_16BPPI5551:\n\tcase LCD_WINCTRL1_FRM_16BPPA1555:\n\tcase LCD_WINCTRL1_FRM_16BPPA5551:\n\t\tbits = 16;\n\t\tbreak;\n\tcase LCD_WINCTRL1_FRM_24BPP:\n\tcase LCD_WINCTRL1_FRM_32BPP:\n\t\tbits = 32;\n\t\tbreak;\n\t}\n\n\treturn bits;\n}\n\nstatic int fbinfo2index (struct fb_info *fb_info)\n{\n\tint i;\n\n\tfor (i = 0; i < device_count; ++i) {\n\t\tif (fb_info == _au1200fb_infos[i])\n\t\t\treturn i;\n\t}\n\tprintk(\"au1200fb: ERROR: fbinfo2index failed!\\n\");\n\treturn -1;\n}\n\nstatic int au1200_setlocation (struct au1200fb_device *fbdev, int plane,\n\tint xpos, int ypos)\n{\n\tuint32 winctrl0, winctrl1, winenable, fb_offset = 0;\n\tint xsz, ysz;\n\n\t/* FIX!!! NOT CHECKING FOR COMPLETE OFFSCREEN YET */\n\n\twinctrl0 = lcd->window[plane].winctrl0;\n\twinctrl1 = lcd->window[plane].winctrl1;\n\twinctrl0 &= (LCD_WINCTRL0_A | LCD_WINCTRL0_AEN);\n\twinctrl1 &= ~(LCD_WINCTRL1_SZX | LCD_WINCTRL1_SZY);\n\n\t/* Check for off-screen adjustments */\n\txsz = win->w[plane].xres;\n\tysz = win->w[plane].yres;\n\tif ((xpos + win->w[plane].xres) > panel->Xres) {\n\t\t/* Off-screen to the right */\n\t\txsz = panel->Xres - xpos; /* off by 1 ??? */\n\t\t/*printk(\"off screen right\\n\");*/\n\t}\n\n\tif ((ypos + win->w[plane].yres) > panel->Yres) {\n\t\t/* Off-screen to the bottom */\n\t\tysz = panel->Yres - ypos; /* off by 1 ??? */\n\t\t/*printk(\"off screen bottom\\n\");*/\n\t}\n\n\tif (xpos < 0) {\n\t\t/* Off-screen to the left */\n\t\txsz = win->w[plane].xres + xpos;\n\t\tfb_offset += (((0 - xpos) * winbpp(lcd->window[plane].winctrl1))/8);\n\t\txpos = 0;\n\t\t/*printk(\"off screen left\\n\");*/\n\t}\n\n\tif (ypos < 0) {\n\t\t/* Off-screen to the top */\n\t\tysz = win->w[plane].yres + ypos;\n\t\t/* fixme: fb_offset += ((0-ypos)*fb_pars[plane].line_length); */\n\t\typos = 0;\n\t\t/*printk(\"off screen top\\n\");*/\n\t}\n\n\t/* record settings */\n\twin->w[plane].xpos = xpos;\n\twin->w[plane].ypos = ypos;\n\n\txsz -= 1;\n\tysz -= 1;\n\twinctrl0 |= (xpos << 21);\n\twinctrl0 |= (ypos << 10);\n\twinctrl1 |= (xsz << 11);\n\twinctrl1 |= (ysz << 0);\n\n\t/* Disable the window while making changes, then restore WINEN */\n\twinenable = lcd->winenable & (1 << plane);\n\tau_sync();\n\tlcd->winenable &= ~(1 << plane);\n\tlcd->window[plane].winctrl0 = winctrl0;\n\tlcd->window[plane].winctrl1 = winctrl1;\n\tlcd->window[plane].winbuf0 =\n\tlcd->window[plane].winbuf1 = fbdev->fb_phys;\n\tlcd->window[plane].winbufctrl = 0; /* select winbuf0 */\n\tlcd->winenable |= winenable;\n\tau_sync();\n\n\treturn 0;\n}\n\nstatic void au1200_setpanel(struct panel_settings *newpanel,\n\t\t\t    struct au1200fb_platdata *pd)\n{\n\t/*\n\t * Perform global setup/init of LCD controller\n\t */\n\tuint32 winenable;\n\n\t/* Make sure all windows disabled */\n\twinenable = lcd->winenable;\n\tlcd->winenable = 0;\n\tau_sync();\n\t/*\n\t * Ensure everything is disabled before reconfiguring\n\t */\n\tif (lcd->screen & LCD_SCREEN_SEN) {\n\t\t/* Wait for vertical sync period */\n\t\tlcd->intstatus = LCD_INT_SS;\n\t\twhile ((lcd->intstatus & LCD_INT_SS) == 0) {\n\t\t\tau_sync();\n\t\t}\n\n\t\tlcd->screen &= ~LCD_SCREEN_SEN;\t/*disable the controller*/\n\n\t\tdo {\n\t\t\tlcd->intstatus = lcd->intstatus; /*clear interrupts*/\n\t\t\tau_sync();\n\t\t/*wait for controller to shut down*/\n\t\t} while ((lcd->intstatus & LCD_INT_SD) == 0);\n\n\t\t/* Call shutdown of current panel (if up) */\n\t\t/* this must occur last, because if an external clock is driving\n\t\t    the controller, the clock cannot be turned off before first\n\t\t\tshutting down the controller.\n\t\t */\n\t\tif (pd->panel_shutdown)\n\t\t\tpd->panel_shutdown();\n\t}\n\n\t/* Newpanel == NULL indicates a shutdown operation only */\n\tif (newpanel == NULL)\n\t\treturn;\n\n\tpanel = newpanel;\n\n\tprintk(\"Panel(%s), %dx%d\\n\", panel->name, panel->Xres, panel->Yres);\n\n\t/*\n\t * Setup clocking if internal LCD clock source (assumes sys_auxpll valid)\n\t */\n\tif (!(panel->mode_clkcontrol & LCD_CLKCONTROL_EXT))\n\t{\n\t\tuint32 sys_clksrc;\n\t\tau_writel(panel->mode_auxpll, SYS_AUXPLL);\n\t\tsys_clksrc = au_readl(SYS_CLKSRC) & ~0x0000001f;\n\t\tsys_clksrc |= panel->mode_toyclksrc;\n\t\tau_writel(sys_clksrc, SYS_CLKSRC);\n\t}\n\n\t/*\n\t * Configure panel timings\n\t */\n\tlcd->screen = panel->mode_screen;\n\tlcd->horztiming = panel->mode_horztiming;\n\tlcd->verttiming = panel->mode_verttiming;\n\tlcd->clkcontrol = panel->mode_clkcontrol;\n\tlcd->pwmdiv = panel->mode_pwmdiv;\n\tlcd->pwmhi = panel->mode_pwmhi;\n\tlcd->outmask = panel->mode_outmask;\n\tlcd->fifoctrl = panel->mode_fifoctrl;\n\tau_sync();\n\n\t/* fixme: Check window settings to make sure still valid\n\t * for new geometry */\n#if 0\n\tau1200_setlocation(fbdev, 0, win->w[0].xpos, win->w[0].ypos);\n\tau1200_setlocation(fbdev, 1, win->w[1].xpos, win->w[1].ypos);\n\tau1200_setlocation(fbdev, 2, win->w[2].xpos, win->w[2].ypos);\n\tau1200_setlocation(fbdev, 3, win->w[3].xpos, win->w[3].ypos);\n#endif\n\tlcd->winenable = winenable;\n\n\t/*\n\t * Re-enable screen now that it is configured\n\t */\n\tlcd->screen |= LCD_SCREEN_SEN;\n\tau_sync();\n\n\t/* Call init of panel */\n\tif (pd->panel_init)\n\t\tpd->panel_init();\n\n\t/* FIX!!!! not appropriate on panel change!!! Global setup/init */\n\tlcd->intenable = 0;\n\tlcd->intstatus = ~0;\n\tlcd->backcolor = win->mode_backcolor;\n\n\t/* Setup Color Key - FIX!!! */\n\tlcd->colorkey = win->mode_colorkey;\n\tlcd->colorkeymsk = win->mode_colorkeymsk;\n\n\t/* Setup HWCursor - FIX!!! Need to support this eventually */\n\tlcd->hwc.cursorctrl = 0;\n\tlcd->hwc.cursorpos = 0;\n\tlcd->hwc.cursorcolor0 = 0;\n\tlcd->hwc.cursorcolor1 = 0;\n\tlcd->hwc.cursorcolor2 = 0;\n\tlcd->hwc.cursorcolor3 = 0;\n\n\n#if 0\n#define D(X) printk(\"%25s: %08X\\n\", #X, X)\n\tD(lcd->screen);\n\tD(lcd->horztiming);\n\tD(lcd->verttiming);\n\tD(lcd->clkcontrol);\n\tD(lcd->pwmdiv);\n\tD(lcd->pwmhi);\n\tD(lcd->outmask);\n\tD(lcd->fifoctrl);\n\tD(lcd->window[0].winctrl0);\n\tD(lcd->window[0].winctrl1);\n\tD(lcd->window[0].winctrl2);\n\tD(lcd->window[0].winbuf0);\n\tD(lcd->window[0].winbuf1);\n\tD(lcd->window[0].winbufctrl);\n\tD(lcd->window[1].winctrl0);\n\tD(lcd->window[1].winctrl1);\n\tD(lcd->window[1].winctrl2);\n\tD(lcd->window[1].winbuf0);\n\tD(lcd->window[1].winbuf1);\n\tD(lcd->window[1].winbufctrl);\n\tD(lcd->window[2].winctrl0);\n\tD(lcd->window[2].winctrl1);\n\tD(lcd->window[2].winctrl2);\n\tD(lcd->window[2].winbuf0);\n\tD(lcd->window[2].winbuf1);\n\tD(lcd->window[2].winbufctrl);\n\tD(lcd->window[3].winctrl0);\n\tD(lcd->window[3].winctrl1);\n\tD(lcd->window[3].winctrl2);\n\tD(lcd->window[3].winbuf0);\n\tD(lcd->window[3].winbuf1);\n\tD(lcd->window[3].winbufctrl);\n\tD(lcd->winenable);\n\tD(lcd->intenable);\n\tD(lcd->intstatus);\n\tD(lcd->backcolor);\n\tD(lcd->winenable);\n\tD(lcd->colorkey);\n    D(lcd->colorkeymsk);\n\tD(lcd->hwc.cursorctrl);\n\tD(lcd->hwc.cursorpos);\n\tD(lcd->hwc.cursorcolor0);\n\tD(lcd->hwc.cursorcolor1);\n\tD(lcd->hwc.cursorcolor2);\n\tD(lcd->hwc.cursorcolor3);\n#endif\n}\n\nstatic void au1200_setmode(struct au1200fb_device *fbdev)\n{\n\tint plane = fbdev->plane;\n\t/* Window/plane setup */\n\tlcd->window[plane].winctrl1 = ( 0\n\t\t| LCD_WINCTRL1_PRI_N(plane)\n\t\t| win->w[plane].mode_winctrl1 /* FRM,CCO,PO,PIPE */\n\t\t) ;\n\n\tau1200_setlocation(fbdev, plane, win->w[plane].xpos, win->w[plane].ypos);\n\n\tlcd->window[plane].winctrl2 = ( 0\n\t\t| LCD_WINCTRL2_CKMODE_00\n\t\t| LCD_WINCTRL2_DBM\n\t\t| LCD_WINCTRL2_BX_N(fbdev->fb_info->fix.line_length)\n\t\t| LCD_WINCTRL2_SCX_1\n\t\t| LCD_WINCTRL2_SCY_1\n\t\t) ;\n\tlcd->winenable |= win->w[plane].mode_winenable;\n\tau_sync();\n}\n\n\n/* Inline helpers */\n\n/*#define panel_is_dual(panel)  ((panel->mode_screen & LCD_SCREEN_PT) == LCD_SCREEN_PT_010)*/\n/*#define panel_is_active(panel)((panel->mode_screen & LCD_SCREEN_PT) == LCD_SCREEN_PT_010)*/\n\n#define panel_is_color(panel) ((panel->mode_screen & LCD_SCREEN_PT) <= LCD_SCREEN_PT_CDSTN)\n\n/* Bitfields format supported by the controller. */\nstatic struct fb_bitfield rgb_bitfields[][4] = {\n  \t/*     Red, \t   Green, \t Blue, \t     Transp   */\n\t[LCD_WINCTRL1_FRM_16BPP655 >> 25] =\n\t\t{ { 10, 6, 0 }, { 5, 5, 0 }, { 0, 5, 0 }, { 0, 0, 0 } },\n\n\t[LCD_WINCTRL1_FRM_16BPP565 >> 25] =\n\t\t{ { 11, 5, 0 }, { 5, 6, 0 }, { 0, 5, 0 }, { 0, 0, 0 } },\n\n\t[LCD_WINCTRL1_FRM_16BPP556 >> 25] =\n\t\t{ { 11, 5, 0 }, { 6, 5, 0 }, { 0, 6, 0 }, { 0, 0, 0 } },\n\n\t[LCD_WINCTRL1_FRM_16BPPI1555 >> 25] =\n\t\t{ { 10, 5, 0 }, { 5, 5, 0 }, { 0, 5, 0 }, { 0, 0, 0 } },\n\n\t[LCD_WINCTRL1_FRM_16BPPI5551 >> 25] =\n\t\t{ { 11, 5, 0 }, { 6, 5, 0 }, { 1, 5, 0 }, { 0, 0, 0 } },\n\n\t[LCD_WINCTRL1_FRM_16BPPA1555 >> 25] =\n\t\t{ { 10, 5, 0 }, { 5, 5, 0 }, { 0, 5, 0 }, { 15, 1, 0 } },\n\n\t[LCD_WINCTRL1_FRM_16BPPA5551 >> 25] =\n\t\t{ { 11, 5, 0 }, { 6, 5, 0 }, { 1, 5, 0 }, { 0, 1, 0 } },\n\n\t[LCD_WINCTRL1_FRM_24BPP >> 25] =\n\t\t{ { 16, 8, 0 }, { 8, 8, 0 }, { 0, 8, 0 }, { 0, 0, 0 } },\n\n\t[LCD_WINCTRL1_FRM_32BPP >> 25] =\n\t\t{ { 16, 8, 0 }, { 8, 8, 0 }, { 0, 8, 0 }, { 24, 0, 0 } },\n};\n\n/*-------------------------------------------------------------------------*/\n\n/* Helpers */\n\nstatic void au1200fb_update_fbinfo(struct fb_info *fbi)\n{\n\t/* FIX!!!! This also needs to take the window pixel format into account!!! */\n\n\t/* Update var-dependent FB info */\n\tif (panel_is_color(panel)) {\n\t\tif (fbi->var.bits_per_pixel <= 8) {\n\t\t\t/* palettized */\n\t\t\tfbi->fix.visual = FB_VISUAL_PSEUDOCOLOR;\n\t\t\tfbi->fix.line_length = fbi->var.xres_virtual /\n\t\t\t\t(8/fbi->var.bits_per_pixel);\n\t\t} else {\n\t\t\t/* non-palettized */\n\t\t\tfbi->fix.visual = FB_VISUAL_TRUECOLOR;\n\t\t\tfbi->fix.line_length = fbi->var.xres_virtual * (fbi->var.bits_per_pixel / 8);\n\t\t}\n\t} else {\n\t\t/* mono FIX!!! mono 8 and 4 bits */\n\t\tfbi->fix.visual = FB_VISUAL_MONO10;\n\t\tfbi->fix.line_length = fbi->var.xres_virtual / 8;\n\t}\n\n\tfbi->screen_size = fbi->fix.line_length * fbi->var.yres_virtual;\n\tprint_dbg(\"line length: %d\\n\", fbi->fix.line_length);\n\tprint_dbg(\"bits_per_pixel: %d\\n\", fbi->var.bits_per_pixel);\n}\n\n/*-------------------------------------------------------------------------*/\n\n/* AU1200 framebuffer driver */\n\n/* fb_check_var\n * Validate var settings with hardware restrictions and modify it if necessary\n */\nstatic int au1200fb_fb_check_var(struct fb_var_screeninfo *var,\n\tstruct fb_info *fbi)\n{\n\tstruct au1200fb_device *fbdev = fbi->par;\n\tu32 pixclock;\n\tint screen_size, plane;\n\n\tplane = fbdev->plane;\n\n\t/* Make sure that the mode respect all LCD controller and\n\t * panel restrictions. */\n\tvar->xres = win->w[plane].xres;\n\tvar->yres = win->w[plane].yres;\n\n\t/* No need for virtual resolution support */\n\tvar->xres_virtual = var->xres;\n\tvar->yres_virtual = var->yres;\n\n\tvar->bits_per_pixel = winbpp(win->w[plane].mode_winctrl1);\n\n\tscreen_size = var->xres_virtual * var->yres_virtual;\n\tif (var->bits_per_pixel > 8) screen_size *= (var->bits_per_pixel / 8);\n\telse screen_size /= (8/var->bits_per_pixel);\n\n\tif (fbdev->fb_len < screen_size)\n\t\treturn -EINVAL; /* Virtual screen is to big, abort */\n\n\t/* FIX!!!! what are the implicaitons of ignoring this for windows ??? */\n\t/* The max LCD clock is fixed to 48MHz (value of AUX_CLK). The pixel\n\t * clock can only be obtain by dividing this value by an even integer.\n\t * Fallback to a slower pixel clock if necessary. */\n\tpixclock = max((u32)(PICOS2KHZ(var->pixclock) * 1000), fbi->monspecs.dclkmin);\n\tpixclock = min3(pixclock, fbi->monspecs.dclkmax, (u32)AU1200_LCD_MAX_CLK/2);\n\n\tif (AU1200_LCD_MAX_CLK % pixclock) {\n\t\tint diff = AU1200_LCD_MAX_CLK % pixclock;\n\t\tpixclock -= diff;\n\t}\n\n\tvar->pixclock = KHZ2PICOS(pixclock/1000);\n#if 0\n\tif (!panel_is_active(panel)) {\n\t\tint pcd = AU1200_LCD_MAX_CLK / (pixclock * 2) - 1;\n\n\t\tif (!panel_is_color(panel)\n\t\t\t&& (panel->control_base & LCD_CONTROL_MPI) && (pcd < 3)) {\n\t\t\t/* STN 8bit mono panel support is up to 6MHz pixclock */\n\t\t\tvar->pixclock = KHZ2PICOS(6000);\n\t\t} else if (!pcd) {\n\t\t\t/* Other STN panel support is up to 12MHz  */\n\t\t\tvar->pixclock = KHZ2PICOS(12000);\n\t\t}\n\t}\n#endif\n\t/* Set bitfield accordingly */\n\tswitch (var->bits_per_pixel) {\n\t\tcase 16:\n\t\t{\n\t\t\t/* 16bpp True color.\n\t\t\t * These must be set to MATCH WINCTRL[FORM] */\n\t\t\tint idx;\n\t\t\tidx = (win->w[0].mode_winctrl1 & LCD_WINCTRL1_FRM) >> 25;\n\t\t\tvar->red    = rgb_bitfields[idx][0];\n\t\t\tvar->green  = rgb_bitfields[idx][1];\n\t\t\tvar->blue   = rgb_bitfields[idx][2];\n\t\t\tvar->transp = rgb_bitfields[idx][3];\n\t\t\tbreak;\n\t\t}\n\n\t\tcase 32:\n\t\t{\n\t\t\t/* 32bpp True color.\n\t\t\t * These must be set to MATCH WINCTRL[FORM] */\n\t\t\tint idx;\n\t\t\tidx = (win->w[0].mode_winctrl1 & LCD_WINCTRL1_FRM) >> 25;\n\t\t\tvar->red    = rgb_bitfields[idx][0];\n\t\t\tvar->green  = rgb_bitfields[idx][1];\n\t\t\tvar->blue   = rgb_bitfields[idx][2];\n\t\t\tvar->transp = rgb_bitfields[idx][3];\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tprint_dbg(\"Unsupported depth %dbpp\", var->bits_per_pixel);\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n/* fb_set_par\n * Set hardware with var settings. This will enable the controller with a\n * specific mode, normally validated with the fb_check_var method\n */\nstatic int au1200fb_fb_set_par(struct fb_info *fbi)\n{\n\tstruct au1200fb_device *fbdev = fbi->par;\n\n\tau1200fb_update_fbinfo(fbi);\n\tau1200_setmode(fbdev);\n\n\treturn 0;\n}\n\n/* fb_setcolreg\n * Set color in LCD palette.\n */\nstatic int au1200fb_fb_setcolreg(unsigned regno, unsigned red, unsigned green,\n\tunsigned blue, unsigned transp, struct fb_info *fbi)\n{\n\tvolatile u32 *palette = lcd->palette;\n\tu32 value;\n\n\tif (regno > (AU1200_LCD_NBR_PALETTE_ENTRIES - 1))\n\t\treturn -EINVAL;\n\n\tif (fbi->var.grayscale) {\n\t\t/* Convert color to grayscale */\n\t\tred = green = blue =\n\t\t\t(19595 * red + 38470 * green + 7471 * blue) >> 16;\n\t}\n\n\tif (fbi->fix.visual == FB_VISUAL_TRUECOLOR) {\n\t\t/* Place color in the pseudopalette */\n\t\tif (regno > 16)\n\t\t\treturn -EINVAL;\n\n\t\tpalette = (u32*) fbi->pseudo_palette;\n\n\t\tred   >>= (16 - fbi->var.red.length);\n\t\tgreen >>= (16 - fbi->var.green.length);\n\t\tblue  >>= (16 - fbi->var.blue.length);\n\n\t\tvalue = (red   << fbi->var.red.offset) \t|\n\t\t\t(green << fbi->var.green.offset)|\n\t\t\t(blue  << fbi->var.blue.offset);\n\t\tvalue &= 0xFFFF;\n\n\t} else if (1 /*FIX!!! panel_is_active(fbdev->panel)*/) {\n\t\t/* COLOR TFT PALLETTIZED (use RGB 565) */\n\t\tvalue = (red & 0xF800)|((green >> 5) &\n\t\t\t\t0x07E0)|((blue >> 11) & 0x001F);\n\t\tvalue &= 0xFFFF;\n\n\t} else if (0 /*panel_is_color(fbdev->panel)*/) {\n\t\t/* COLOR STN MODE */\n\t\tvalue = 0x1234;\n\t\tvalue &= 0xFFF;\n\t} else {\n\t\t/* MONOCHROME MODE */\n\t\tvalue = (green >> 12) & 0x000F;\n\t\tvalue &= 0xF;\n\t}\n\n\tpalette[regno] = value;\n\n\treturn 0;\n}\n\n/* fb_blank\n * Blank the screen. Depending on the mode, the screen will be\n * activated with the backlight color, or desactivated\n */\nstatic int au1200fb_fb_blank(int blank_mode, struct fb_info *fbi)\n{\n\tstruct au1200fb_device *fbdev = fbi->par;\n\n\t/* Short-circuit screen blanking */\n\tif (noblanking)\n\t\treturn 0;\n\n\tswitch (blank_mode) {\n\n\tcase FB_BLANK_UNBLANK:\n\tcase FB_BLANK_NORMAL:\n\t\t/* printk(\"turn on panel\\n\"); */\n\t\tau1200_setpanel(panel, fbdev->pd);\n\t\tbreak;\n\tcase FB_BLANK_VSYNC_SUSPEND:\n\tcase FB_BLANK_HSYNC_SUSPEND:\n\tcase FB_BLANK_POWERDOWN:\n\t\t/* printk(\"turn off panel\\n\"); */\n\t\tau1200_setpanel(NULL, fbdev->pd);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\n\t}\n\n\t/* FB_BLANK_NORMAL is a soft blank */\n\treturn (blank_mode == FB_BLANK_NORMAL) ? -EINVAL : 0;\n}\n\n/* fb_mmap\n * Map video memory in user space. We don't use the generic fb_mmap\n * method mainly to allow the use of the TLB streaming flag (CCA=6)\n */\nstatic int au1200fb_fb_mmap(struct fb_info *info, struct vm_area_struct *vma)\n{\n\tstruct au1200fb_device *fbdev = info->par;\n\n\tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n\tpgprot_val(vma->vm_page_prot) |= _CACHE_MASK; /* CCA=7 */\n\n\treturn vm_iomap_memory(vma, fbdev->fb_phys, fbdev->fb_len);\n}\n\nstatic void set_global(u_int cmd, struct au1200_lcd_global_regs_t *pdata)\n{\n\n\tunsigned int hi1, divider;\n\n\t/* SCREEN_SIZE: user cannot reset size, must switch panel choice */\n\n\tif (pdata->flags & SCREEN_BACKCOLOR)\n\t\tlcd->backcolor = pdata->backcolor;\n\n\tif (pdata->flags & SCREEN_BRIGHTNESS) {\n\n\t\t// limit brightness pwm duty to >= 30/1600\n\t\tif (pdata->brightness < 30) {\n\t\t\tpdata->brightness = 30;\n\t\t}\n\t\tdivider = (lcd->pwmdiv & 0x3FFFF) + 1;\n\t\thi1 = (lcd->pwmhi >> 16) + 1;\n\t\thi1 = (((pdata->brightness & 0xFF)+1) * divider >> 8);\n\t\tlcd->pwmhi &= 0xFFFF;\n\t\tlcd->pwmhi |= (hi1 << 16);\n\t}\n\n\tif (pdata->flags & SCREEN_COLORKEY)\n\t\tlcd->colorkey = pdata->colorkey;\n\n\tif (pdata->flags & SCREEN_MASK)\n\t\tlcd->colorkeymsk = pdata->mask;\n\tau_sync();\n}\n\nstatic void get_global(u_int cmd, struct au1200_lcd_global_regs_t *pdata)\n{\n\tunsigned int hi1, divider;\n\n\tpdata->xsize = ((lcd->screen & LCD_SCREEN_SX) >> 19) + 1;\n\tpdata->ysize = ((lcd->screen & LCD_SCREEN_SY) >> 8) + 1;\n\n\tpdata->backcolor = lcd->backcolor;\n\tpdata->colorkey = lcd->colorkey;\n\tpdata->mask = lcd->colorkeymsk;\n\n\t// brightness\n\thi1 = (lcd->pwmhi >> 16) + 1;\n\tdivider = (lcd->pwmdiv & 0x3FFFF) + 1;\n\tpdata->brightness = ((hi1 << 8) / divider) - 1;\n\tau_sync();\n}\n\nstatic void set_window(unsigned int plane,\n\tstruct au1200_lcd_window_regs_t *pdata)\n{\n\tunsigned int val, bpp;\n\n\t/* Window control register 0 */\n\tif (pdata->flags & WIN_POSITION) {\n\t\tval = lcd->window[plane].winctrl0 & ~(LCD_WINCTRL0_OX |\n\t\t\t\tLCD_WINCTRL0_OY);\n\t\tval |= ((pdata->xpos << 21) & LCD_WINCTRL0_OX);\n\t\tval |= ((pdata->ypos << 10) & LCD_WINCTRL0_OY);\n\t\tlcd->window[plane].winctrl0 = val;\n\t}\n\tif (pdata->flags & WIN_ALPHA_COLOR) {\n\t\tval = lcd->window[plane].winctrl0 & ~(LCD_WINCTRL0_A);\n\t\tval |= ((pdata->alpha_color << 2) & LCD_WINCTRL0_A);\n\t\tlcd->window[plane].winctrl0 = val;\n\t}\n\tif (pdata->flags & WIN_ALPHA_MODE) {\n\t\tval = lcd->window[plane].winctrl0 & ~(LCD_WINCTRL0_AEN);\n\t\tval |= ((pdata->alpha_mode << 1) & LCD_WINCTRL0_AEN);\n\t\tlcd->window[plane].winctrl0 = val;\n\t}\n\n\t/* Window control register 1 */\n\tif (pdata->flags & WIN_PRIORITY) {\n\t\tval = lcd->window[plane].winctrl1 & ~(LCD_WINCTRL1_PRI);\n\t\tval |= ((pdata->priority << 30) & LCD_WINCTRL1_PRI);\n\t\tlcd->window[plane].winctrl1 = val;\n\t}\n\tif (pdata->flags & WIN_CHANNEL) {\n\t\tval = lcd->window[plane].winctrl1 & ~(LCD_WINCTRL1_PIPE);\n\t\tval |= ((pdata->channel << 29) & LCD_WINCTRL1_PIPE);\n\t\tlcd->window[plane].winctrl1 = val;\n\t}\n\tif (pdata->flags & WIN_BUFFER_FORMAT) {\n\t\tval = lcd->window[plane].winctrl1 & ~(LCD_WINCTRL1_FRM);\n\t\tval |= ((pdata->buffer_format << 25) & LCD_WINCTRL1_FRM);\n\t\tlcd->window[plane].winctrl1 = val;\n\t}\n\tif (pdata->flags & WIN_COLOR_ORDER) {\n\t\tval = lcd->window[plane].winctrl1 & ~(LCD_WINCTRL1_CCO);\n\t\tval |= ((pdata->color_order << 24) & LCD_WINCTRL1_CCO);\n\t\tlcd->window[plane].winctrl1 = val;\n\t}\n\tif (pdata->flags & WIN_PIXEL_ORDER) {\n\t\tval = lcd->window[plane].winctrl1 & ~(LCD_WINCTRL1_PO);\n\t\tval |= ((pdata->pixel_order << 22) & LCD_WINCTRL1_PO);\n\t\tlcd->window[plane].winctrl1 = val;\n\t}\n\tif (pdata->flags & WIN_SIZE) {\n\t\tval = lcd->window[plane].winctrl1 & ~(LCD_WINCTRL1_SZX |\n\t\t\t\tLCD_WINCTRL1_SZY);\n\t\tval |= (((pdata->xsize << 11) - 1) & LCD_WINCTRL1_SZX);\n\t\tval |= (((pdata->ysize) - 1) & LCD_WINCTRL1_SZY);\n\t\tlcd->window[plane].winctrl1 = val;\n\t\t/* program buffer line width */\n\t\tbpp = winbpp(val) / 8;\n\t\tval = lcd->window[plane].winctrl2 & ~(LCD_WINCTRL2_BX);\n\t\tval |= (((pdata->xsize * bpp) << 8) & LCD_WINCTRL2_BX);\n\t\tlcd->window[plane].winctrl2 = val;\n\t}\n\n\t/* Window control register 2 */\n\tif (pdata->flags & WIN_COLORKEY_MODE) {\n\t\tval = lcd->window[plane].winctrl2 & ~(LCD_WINCTRL2_CKMODE);\n\t\tval |= ((pdata->colorkey_mode << 24) & LCD_WINCTRL2_CKMODE);\n\t\tlcd->window[plane].winctrl2 = val;\n\t}\n\tif (pdata->flags & WIN_DOUBLE_BUFFER_MODE) {\n\t\tval = lcd->window[plane].winctrl2 & ~(LCD_WINCTRL2_DBM);\n\t\tval |= ((pdata->double_buffer_mode << 23) & LCD_WINCTRL2_DBM);\n\t\tlcd->window[plane].winctrl2 = val;\n\t}\n\tif (pdata->flags & WIN_RAM_ARRAY_MODE) {\n\t\tval = lcd->window[plane].winctrl2 & ~(LCD_WINCTRL2_RAM);\n\t\tval |= ((pdata->ram_array_mode << 21) & LCD_WINCTRL2_RAM);\n\t\tlcd->window[plane].winctrl2 = val;\n\t}\n\n\t/* Buffer line width programmed with WIN_SIZE */\n\n\tif (pdata->flags & WIN_BUFFER_SCALE) {\n\t\tval = lcd->window[plane].winctrl2 & ~(LCD_WINCTRL2_SCX |\n\t\t\t\tLCD_WINCTRL2_SCY);\n\t\tval |= ((pdata->xsize << 11) & LCD_WINCTRL2_SCX);\n\t\tval |= ((pdata->ysize) & LCD_WINCTRL2_SCY);\n\t\tlcd->window[plane].winctrl2 = val;\n\t}\n\n\tif (pdata->flags & WIN_ENABLE) {\n\t\tval = lcd->winenable;\n\t\tval &= ~(1<<plane);\n\t\tval |= (pdata->enable & 1) << plane;\n\t\tlcd->winenable = val;\n\t}\n\tau_sync();\n}\n\nstatic void get_window(unsigned int plane,\n\tstruct au1200_lcd_window_regs_t *pdata)\n{\n\t/* Window control register 0 */\n\tpdata->xpos = (lcd->window[plane].winctrl0 & LCD_WINCTRL0_OX) >> 21;\n\tpdata->ypos = (lcd->window[plane].winctrl0 & LCD_WINCTRL0_OY) >> 10;\n\tpdata->alpha_color = (lcd->window[plane].winctrl0 & LCD_WINCTRL0_A) >> 2;\n\tpdata->alpha_mode = (lcd->window[plane].winctrl0 & LCD_WINCTRL0_AEN) >> 1;\n\n\t/* Window control register 1 */\n\tpdata->priority = (lcd->window[plane].winctrl1& LCD_WINCTRL1_PRI) >> 30;\n\tpdata->channel = (lcd->window[plane].winctrl1 & LCD_WINCTRL1_PIPE) >> 29;\n\tpdata->buffer_format = (lcd->window[plane].winctrl1 & LCD_WINCTRL1_FRM) >> 25;\n\tpdata->color_order = (lcd->window[plane].winctrl1 & LCD_WINCTRL1_CCO) >> 24;\n\tpdata->pixel_order = (lcd->window[plane].winctrl1 & LCD_WINCTRL1_PO) >> 22;\n\tpdata->xsize = ((lcd->window[plane].winctrl1 & LCD_WINCTRL1_SZX) >> 11) + 1;\n\tpdata->ysize = (lcd->window[plane].winctrl1 & LCD_WINCTRL1_SZY) + 1;\n\n\t/* Window control register 2 */\n\tpdata->colorkey_mode = (lcd->window[plane].winctrl2 & LCD_WINCTRL2_CKMODE) >> 24;\n\tpdata->double_buffer_mode = (lcd->window[plane].winctrl2 & LCD_WINCTRL2_DBM) >> 23;\n\tpdata->ram_array_mode = (lcd->window[plane].winctrl2 & LCD_WINCTRL2_RAM) >> 21;\n\n\tpdata->enable = (lcd->winenable >> plane) & 1;\n\tau_sync();\n}\n\nstatic int au1200fb_ioctl(struct fb_info *info, unsigned int cmd,\n                          unsigned long arg)\n{\n\tstruct au1200fb_device *fbdev = info->par;\n\tint plane;\n\tint val;\n\n\tplane = fbinfo2index(info);\n\tprint_dbg(\"au1200fb: ioctl %d on plane %d\\n\", cmd, plane);\n\n\tif (cmd == AU1200_LCD_FB_IOCTL) {\n\t\tstruct au1200_lcd_iodata_t iodata;\n\n\t\tif (copy_from_user(&iodata, (void __user *) arg, sizeof(iodata)))\n\t\t\treturn -EFAULT;\n\n\t\tprint_dbg(\"FB IOCTL called\\n\");\n\n\t\tswitch (iodata.subcmd) {\n\t\tcase AU1200_LCD_SET_SCREEN:\n\t\t\tprint_dbg(\"AU1200_LCD_SET_SCREEN\\n\");\n\t\t\tset_global(cmd, &iodata.global);\n\t\t\tbreak;\n\n\t\tcase AU1200_LCD_GET_SCREEN:\n\t\t\tprint_dbg(\"AU1200_LCD_GET_SCREEN\\n\");\n\t\t\tget_global(cmd, &iodata.global);\n\t\t\tbreak;\n\n\t\tcase AU1200_LCD_SET_WINDOW:\n\t\t\tprint_dbg(\"AU1200_LCD_SET_WINDOW\\n\");\n\t\t\tset_window(plane, &iodata.window);\n\t\t\tbreak;\n\n\t\tcase AU1200_LCD_GET_WINDOW:\n\t\t\tprint_dbg(\"AU1200_LCD_GET_WINDOW\\n\");\n\t\t\tget_window(plane, &iodata.window);\n\t\t\tbreak;\n\n\t\tcase AU1200_LCD_SET_PANEL:\n\t\t\tprint_dbg(\"AU1200_LCD_SET_PANEL\\n\");\n\t\t\tif ((iodata.global.panel_choice >= 0) &&\n\t\t\t\t\t(iodata.global.panel_choice <\n\t\t\t\t\t NUM_PANELS))\n\t\t\t{\n\t\t\t\tstruct panel_settings *newpanel;\n\t\t\t\tpanel_index = iodata.global.panel_choice;\n\t\t\t\tnewpanel = &known_lcd_panels[panel_index];\n\t\t\t\tau1200_setpanel(newpanel, fbdev->pd);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase AU1200_LCD_GET_PANEL:\n\t\t\tprint_dbg(\"AU1200_LCD_GET_PANEL\\n\");\n\t\t\tiodata.global.panel_choice = panel_index;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tval = copy_to_user((void __user *) arg, &iodata, sizeof(iodata));\n\t\tif (val) {\n\t\t\tprint_dbg(\"error: could not copy %d bytes\\n\", val);\n\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\nstatic struct fb_ops au1200fb_fb_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.fb_check_var\t= au1200fb_fb_check_var,\n\t.fb_set_par\t= au1200fb_fb_set_par,\n\t.fb_setcolreg\t= au1200fb_fb_setcolreg,\n\t.fb_blank\t= au1200fb_fb_blank,\n\t.fb_fillrect\t= sys_fillrect,\n\t.fb_copyarea\t= sys_copyarea,\n\t.fb_imageblit\t= sys_imageblit,\n\t.fb_read\t= fb_sys_read,\n\t.fb_write\t= fb_sys_write,\n\t.fb_sync\t= NULL,\n\t.fb_ioctl\t= au1200fb_ioctl,\n\t.fb_mmap\t= au1200fb_fb_mmap,\n};\n\n/*-------------------------------------------------------------------------*/\n\nstatic irqreturn_t au1200fb_handle_irq(int irq, void* dev_id)\n{\n\t/* Nothing to do for now, just clear any pending interrupt */\n\tlcd->intstatus = lcd->intstatus;\n\tau_sync();\n\n\treturn IRQ_HANDLED;\n}\n\n/*-------------------------------------------------------------------------*/\n\n/* AU1200 LCD device probe helpers */\n\nstatic int au1200fb_init_fbinfo(struct au1200fb_device *fbdev)\n{\n\tstruct fb_info *fbi = fbdev->fb_info;\n\tint bpp;\n\n\tfbi->fbops = &au1200fb_fb_ops;\n\n\tbpp = winbpp(win->w[fbdev->plane].mode_winctrl1);\n\n\t/* Copy monitor specs from panel data */\n\t/* fixme: we're setting up LCD controller windows, so these dont give a\n\tdamn as to what the monitor specs are (the panel itself does, but that\n\tisn't done here...so maybe need a generic catchall monitor setting??? */\n\tmemcpy(&fbi->monspecs, &panel->monspecs, sizeof(struct fb_monspecs));\n\n\t/* We first try the user mode passed in argument. If that failed,\n\t * or if no one has been specified, we default to the first mode of the\n\t * panel list. Note that after this call, var data will be set */\n\tif (!fb_find_mode(&fbi->var,\n\t\t\t  fbi,\n\t\t\t  NULL, /* drv_info.opt_mode, */\n\t\t\t  fbi->monspecs.modedb,\n\t\t\t  fbi->monspecs.modedb_len,\n\t\t\t  fbi->monspecs.modedb,\n\t\t\t  bpp)) {\n\n\t\tprint_err(\"Cannot find valid mode for panel %s\", panel->name);\n\t\treturn -EFAULT;\n\t}\n\n\tfbi->pseudo_palette = kcalloc(16, sizeof(u32), GFP_KERNEL);\n\tif (!fbi->pseudo_palette) {\n\t\treturn -ENOMEM;\n\t}\n\n\tif (fb_alloc_cmap(&fbi->cmap, AU1200_LCD_NBR_PALETTE_ENTRIES, 0) < 0) {\n\t\tprint_err(\"Fail to allocate colormap (%d entries)\",\n\t\t\t   AU1200_LCD_NBR_PALETTE_ENTRIES);\n\t\tkfree(fbi->pseudo_palette);\n\t\treturn -EFAULT;\n\t}\n\n\tstrncpy(fbi->fix.id, \"AU1200\", sizeof(fbi->fix.id));\n\tfbi->fix.smem_start = fbdev->fb_phys;\n\tfbi->fix.smem_len = fbdev->fb_len;\n\tfbi->fix.type = FB_TYPE_PACKED_PIXELS;\n\tfbi->fix.xpanstep = 0;\n\tfbi->fix.ypanstep = 0;\n\tfbi->fix.mmio_start = 0;\n\tfbi->fix.mmio_len = 0;\n\tfbi->fix.accel = FB_ACCEL_NONE;\n\n\tfbi->screen_base = (char __iomem *) fbdev->fb_mem;\n\n\tau1200fb_update_fbinfo(fbi);\n\n\treturn 0;\n}\n\n/*-------------------------------------------------------------------------*/\n\n\nstatic int au1200fb_setup(struct au1200fb_platdata *pd)\n{\n\tchar *options = NULL;\n\tchar *this_opt, *endptr;\n\tint num_panels = ARRAY_SIZE(known_lcd_panels);\n\tint panel_idx = -1;\n\n\tfb_get_options(DRIVER_NAME, &options);\n\n\tif (!options)\n\t\tgoto out;\n\n\twhile ((this_opt = strsep(&options, \",\")) != NULL) {\n\t\t/* Panel option - can be panel name,\n\t\t * \"bs\" for board-switch, or number/index */\n\t\tif (!strncmp(this_opt, \"panel:\", 6)) {\n\t\t\tint i;\n\t\t\tlong int li;\n\t\t\tchar *endptr;\n\t\t\tthis_opt += 6;\n\t\t\t/* First check for index, which allows\n\t\t\t * to short circuit this mess */\n\t\t\tli = simple_strtol(this_opt, &endptr, 0);\n\t\t\tif (*endptr == '\\0')\n\t\t\t\tpanel_idx = (int)li;\n\t\t\telse if (strcmp(this_opt, \"bs\") == 0)\n\t\t\t\tpanel_idx = pd->panel_index();\n\t\t\telse {\n\t\t\t\tfor (i = 0; i < num_panels; i++) {\n\t\t\t\t\tif (!strcmp(this_opt,\n\t\t\t\t\t\t    known_lcd_panels[i].name)) {\n\t\t\t\t\t\tpanel_idx = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((panel_idx < 0) || (panel_idx >= num_panels))\n\t\t\t\tprint_warn(\"Panel %s not supported!\", this_opt);\n\t\t\telse\n\t\t\t\tpanel_index = panel_idx;\n\n\t\t} else if (strncmp(this_opt, \"nohwcursor\", 10) == 0)\n\t\t\tnohwcursor = 1;\n\t\telse if (strncmp(this_opt, \"devices:\", 8) == 0) {\n\t\t\tthis_opt += 8;\n\t\t\tdevice_count = simple_strtol(this_opt, &endptr, 0);\n\t\t\tif ((device_count < 0) ||\n\t\t\t    (device_count > MAX_DEVICE_COUNT))\n\t\t\t\tdevice_count = MAX_DEVICE_COUNT;\n\t\t} else if (strncmp(this_opt, \"wincfg:\", 7) == 0) {\n\t\t\tthis_opt += 7;\n\t\t\twindow_index = simple_strtol(this_opt, &endptr, 0);\n\t\t\tif ((window_index < 0) ||\n\t\t\t    (window_index >= ARRAY_SIZE(windows)))\n\t\t\t\twindow_index = DEFAULT_WINDOW_INDEX;\n\t\t} else if (strncmp(this_opt, \"off\", 3) == 0)\n\t\t\treturn 1;\n\t\telse\n\t\t\tprint_warn(\"Unsupported option \\\"%s\\\"\", this_opt);\n\t}\n\nout:\n\treturn 0;\n}\n\n/* AU1200 LCD controller device driver */\nstatic int au1200fb_drv_probe(struct platform_device *dev)\n{\n\tstruct au1200fb_device *fbdev;\n\tstruct au1200fb_platdata *pd;\n\tstruct fb_info *fbi = NULL;\n\tunsigned long page;\n\tint bpp, plane, ret, irq;\n\n\tprint_info(\"\" DRIVER_DESC \"\");\n\n\tpd = dev->dev.platform_data;\n\tif (!pd)\n\t\treturn -ENODEV;\n\n\t/* Setup driver with options */\n\tif (au1200fb_setup(pd))\n\t\treturn -ENODEV;\n\n\t/* Point to the panel selected */\n\tpanel = &known_lcd_panels[panel_index];\n\twin = &windows[window_index];\n\n\tprintk(DRIVER_NAME \": Panel %d %s\\n\", panel_index, panel->name);\n\tprintk(DRIVER_NAME \": Win %d %s\\n\", window_index, win->name);\n\n\t/* shut gcc up */\n\tret = 0;\n\tfbdev = NULL;\n\n\tfor (plane = 0; plane < device_count; ++plane) {\n\t\tbpp = winbpp(win->w[plane].mode_winctrl1);\n\t\tif (win->w[plane].xres == 0)\n\t\t\twin->w[plane].xres = panel->Xres;\n\t\tif (win->w[plane].yres == 0)\n\t\t\twin->w[plane].yres = panel->Yres;\n\n\t\tfbi = framebuffer_alloc(sizeof(struct au1200fb_device),\n\t\t\t\t\t&dev->dev);\n\t\tif (!fbi)\n\t\t\tgoto failed;\n\n\t\t_au1200fb_infos[plane] = fbi;\n\t\tfbdev = fbi->par;\n\t\tfbdev->fb_info = fbi;\n\t\tfbdev->pd = pd;\n\n\t\tfbdev->plane = plane;\n\n\t\t/* Allocate the framebuffer to the maximum screen size */\n\t\tfbdev->fb_len = (win->w[plane].xres * win->w[plane].yres * bpp) / 8;\n\n\t\tfbdev->fb_mem = dmam_alloc_noncoherent(&dev->dev,\n\t\t\t\tPAGE_ALIGN(fbdev->fb_len),\n\t\t\t\t&fbdev->fb_phys, GFP_KERNEL);\n\t\tif (!fbdev->fb_mem) {\n\t\t\tprint_err(\"fail to allocate frambuffer (size: %dK))\",\n\t\t\t\t  fbdev->fb_len / 1024);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\t/*\n\t\t * Set page reserved so that mmap will work. This is necessary\n\t\t * since we'll be remapping normal memory.\n\t\t */\n\t\tfor (page = (unsigned long)fbdev->fb_phys;\n\t\t     page < PAGE_ALIGN((unsigned long)fbdev->fb_phys +\n\t\t\t     fbdev->fb_len);\n\t\t     page += PAGE_SIZE) {\n\t\t\tSetPageReserved(pfn_to_page(page >> PAGE_SHIFT)); /* LCD DMA is NOT coherent on Au1200 */\n\t\t}\n\t\tprint_dbg(\"Framebuffer memory map at %p\", fbdev->fb_mem);\n\t\tprint_dbg(\"phys=0x%08x, size=%dK\", fbdev->fb_phys, fbdev->fb_len / 1024);\n\n\t\t/* Init FB data */\n\t\tif ((ret = au1200fb_init_fbinfo(fbdev)) < 0)\n\t\t\tgoto failed;\n\n\t\t/* Register new framebuffer */\n\t\tret = register_framebuffer(fbi);\n\t\tif (ret < 0) {\n\t\t\tprint_err(\"cannot register new framebuffer\");\n\t\t\tgoto failed;\n\t\t}\n\n\t\tau1200fb_fb_set_par(fbi);\n\n#if !defined(CONFIG_FRAMEBUFFER_CONSOLE) && defined(CONFIG_LOGO)\n\t\tif (plane == 0)\n\t\t\tif (fb_prepare_logo(fbi, FB_ROTATE_UR)) {\n\t\t\t\t/* Start display and show logo on boot */\n\t\t\t\tfb_set_cmap(&fbi->cmap, fbi);\n\t\t\t\tfb_show_logo(fbi, FB_ROTATE_UR);\n\t\t\t}\n#endif\n\t}\n\n\t/* Now hook interrupt too */\n\tirq = platform_get_irq(dev, 0);\n\tret = request_irq(irq, au1200fb_handle_irq,\n\t\t\t  IRQF_SHARED, \"lcd\", (void *)dev);\n\tif (ret) {\n\t\tprint_err(\"fail to request interrupt line %d (err: %d)\",\n\t\t\t  irq, ret);\n\t\tgoto failed;\n\t}\n\n\tplatform_set_drvdata(dev, pd);\n\n\t/* Kickstart the panel */\n\tau1200_setpanel(panel, pd);\n\n\treturn 0;\n\nfailed:\n\t/* NOTE: This only does the current plane/window that failed; others are still active */\n\tif (fbi) {\n\t\tif (fbi->cmap.len != 0)\n\t\t\tfb_dealloc_cmap(&fbi->cmap);\n\t\tkfree(fbi->pseudo_palette);\n\t}\n\tif (plane == 0)\n\t\tfree_irq(AU1200_LCD_INT, (void*)dev);\n\treturn ret;\n}\n\nstatic int au1200fb_drv_remove(struct platform_device *dev)\n{\n\tstruct au1200fb_platdata *pd = platform_get_drvdata(dev);\n\tstruct au1200fb_device *fbdev;\n\tstruct fb_info *fbi;\n\tint plane;\n\n\t/* Turn off the panel */\n\tau1200_setpanel(NULL, pd);\n\n\tfor (plane = 0; plane < device_count; ++plane)\t{\n\t\tfbi = _au1200fb_infos[plane];\n\t\tfbdev = fbi->par;\n\n\t\t/* Clean up all probe data */\n\t\tunregister_framebuffer(fbi);\n\t\tif (fbi->cmap.len != 0)\n\t\t\tfb_dealloc_cmap(&fbi->cmap);\n\t\tkfree(fbi->pseudo_palette);\n\n\t\tframebuffer_release(fbi);\n\t\t_au1200fb_infos[plane] = NULL;\n\t}\n\n\tfree_irq(platform_get_irq(dev, 0), (void *)dev);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\nstatic int au1200fb_drv_suspend(struct device *dev)\n{\n\tstruct au1200fb_platdata *pd = dev_get_drvdata(dev);\n\tau1200_setpanel(NULL, pd);\n\n\tlcd->outmask = 0;\n\tau_sync();\n\n\treturn 0;\n}\n\nstatic int au1200fb_drv_resume(struct device *dev)\n{\n\tstruct au1200fb_platdata *pd = dev_get_drvdata(dev);\n\tstruct fb_info *fbi;\n\tint i;\n\n\t/* Kickstart the panel */\n\tau1200_setpanel(panel, pd);\n\n\tfor (i = 0; i < device_count; i++) {\n\t\tfbi = _au1200fb_infos[i];\n\t\tau1200fb_fb_set_par(fbi);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops au1200fb_pmops = {\n\t.suspend\t= au1200fb_drv_suspend,\n\t.resume\t\t= au1200fb_drv_resume,\n\t.freeze\t\t= au1200fb_drv_suspend,\n\t.thaw\t\t= au1200fb_drv_resume,\n};\n\n#define AU1200FB_PMOPS\t(&au1200fb_pmops)\n\n#else\n#define AU1200FB_PMOPS\tNULL\n#endif /* CONFIG_PM */\n\nstatic struct platform_driver au1200fb_driver = {\n\t.driver = {\n\t\t.name\t= \"au1200-lcd\",\n\t\t.owner\t= THIS_MODULE,\n\t\t.pm\t= AU1200FB_PMOPS,\n\t},\n\t.probe\t\t= au1200fb_drv_probe,\n\t.remove\t\t= au1200fb_drv_remove,\n};\n\n/*-------------------------------------------------------------------------*/\n\nstatic int __init au1200fb_init(void)\n{\n\treturn platform_driver_register(&au1200fb_driver);\n}\n\nstatic void __exit au1200fb_cleanup(void)\n{\n\tplatform_driver_unregister(&au1200fb_driver);\n}\n\nmodule_init(au1200fb_init);\nmodule_exit(au1200fb_cleanup);\n\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n"], "filenames": ["drivers/uio/uio.c", "drivers/video/au1100fb.c", "drivers/video/au1200fb.c"], "buggy_code_start_loc": [644, 364, 1236], "buggy_code_end_loc": [655, 395, 1264], "fixing_code_start_loc": [645, 363, 1236], "fixing_code_end_loc": [668, 371, 1243], "type": "CWE-189", "message": "Multiple integer overflows in Alchemy LCD frame-buffer drivers in the Linux kernel before 3.12 allow local users to create a read-write memory mapping for the entirety of kernel memory, and consequently gain privileges, via crafted mmap operations, related to the (1) au1100fb_fb_mmap function in drivers/video/au1100fb.c and the (2) au1200fb_fb_mmap function in drivers/video/au1200fb.c.", "other": {"cve": {"id": "CVE-2013-4511", "sourceIdentifier": "secalert@redhat.com", "published": "2013-11-12T14:35:12.197", "lastModified": "2023-02-13T04:47:04.380", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Multiple integer overflows in Alchemy LCD frame-buffer drivers in the Linux kernel before 3.12 allow local users to create a read-write memory mapping for the entirety of kernel memory, and consequently gain privileges, via crafted mmap operations, related to the (1) au1100fb_fb_mmap function in drivers/video/au1100fb.c and the (2) au1200fb_fb_mmap function in drivers/video/au1200fb.c."}, {"lang": "es", "value": "M\u00faltiples desbordamientos de enteros en drivers frame-buffer en Alchemy LCD del kernel de Linux anterior a la versi\u00f3n 3.12 permite a usuarios locales crear y leer-escribir asignaci\u00f3n de memoria para la totalidad de memoria del kernel, y consecuentemente obtener privilegios a trav\u00e9s de operaciones manipuladas mmap, relacionadas con (1) au1100fb_fb_mmap function en drivers/video/au1100fb.c y (2) au1200fb_fb_mmap function en drivers/video/au1200fb.c."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 6.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.4, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-189"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.11.7", "matchCriteriaId": "74676759-D357-4224-9C07-7FCAB195A0CD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "D30AEC07-3CBD-4F4F-9646-BEAA1D98750B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "C2AA8E68-691B-499C-AEDD-3C0BFFE70044"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc3:*:*:*:*:*:*", "matchCriteriaId": "9440475B-5960-4066-A204-F30AAFC87846"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc4:*:*:*:*:*:*", "matchCriteriaId": "53BCFBFB-6AF0-4525-8623-7633CC5E17DB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc5:*:*:*:*:*:*", "matchCriteriaId": "6ED4E86A-74F0-436A-BEB4-3F4EE93A5421"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc6:*:*:*:*:*:*", "matchCriteriaId": "BF0365B0-8E16-4F30-BD92-5DD538CC8135"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc7:*:*:*:*:*:*", "matchCriteriaId": "079505E8-2942-4C33-93D1-35ADA4C39E72"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "38989541-2360-4E0A-AE5A-3D6144AA6114"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "4E51646B-7A0E-40F3-B8C9-239C1DA81DD1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.3:*:*:*:*:*:*:*", "matchCriteriaId": "42A8A507-F8E2-491C-A144-B2448A1DB26E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.4:*:*:*:*:*:*:*", "matchCriteriaId": "901FC6F3-2C2A-4112-AE27-AB102BBE8DEE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.5:*:*:*:*:*:*:*", "matchCriteriaId": "203AD334-DB9F-41B0-A4D1-A6C158EF8C40"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.6:*:*:*:*:*:*:*", "matchCriteriaId": "B3611753-E440-410F-8250-600C996A4B8E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.7:*:*:*:*:*:*:*", "matchCriteriaId": "9739BB47-EEAF-42F1-A557-2AE2EA9526A3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.8:*:*:*:*:*:*:*", "matchCriteriaId": "5A95E3BB-0AFC-4C2E-B9BE-C975E902A266"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.9:*:*:*:*:*:*:*", "matchCriteriaId": "482A6C9A-9B8E-4D1C-917A-F16370745E7C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.10:*:*:*:*:*:*:*", "matchCriteriaId": "C6D87357-63E0-41D0-9F02-1BCBF9A77E63"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.11:*:*:*:*:*:*:*", "matchCriteriaId": "3765A2D6-2D78-4FB1-989E-D5106BFA3F5E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.12:*:*:*:*:*:*:*", "matchCriteriaId": "F54257DB-7023-43C4-AC4D-9590B815CD92"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.13:*:*:*:*:*:*:*", "matchCriteriaId": "61FF5FCD-A4A1-4803-AC53-320A4C838AF6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.14:*:*:*:*:*:*:*", "matchCriteriaId": "9F096553-064F-46A2-877B-F32F163A0F49"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.15:*:*:*:*:*:*:*", "matchCriteriaId": "C0D762D1-E3AD-40EA-8D39-83EEB51B5E85"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.16:*:*:*:*:*:*:*", "matchCriteriaId": "A6187D19-7148-4B87-AD7E-244FF9EE0FA6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.17:*:*:*:*:*:*:*", "matchCriteriaId": "99AC64C2-E391-485C-9CD7-BA09C8FA5E63"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.18:*:*:*:*:*:*:*", "matchCriteriaId": "8CDA5E95-7805-441B-BEF7-4448EA45E964"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.19:*:*:*:*:*:*:*", "matchCriteriaId": "51561053-6C28-4F38-BC9B-3F7A7508EB72"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.20:*:*:*:*:*:*:*", "matchCriteriaId": "118F4A5B-C498-4FC3-BE28-50D18EBE4F22"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.21:*:*:*:*:*:*:*", "matchCriteriaId": "BD38EBE6-FE1A-4B55-9FB5-07952253B7A5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.22:*:*:*:*:*:*:*", "matchCriteriaId": "3A491E47-82AD-4055-9444-2EC0D6715326"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.23:*:*:*:*:*:*:*", "matchCriteriaId": "13C5FD16-23B6-467F-9438-5B554922F974"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.24:*:*:*:*:*:*:*", "matchCriteriaId": "9C67235F-5B51-4BF7-89EC-4810F720246F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.25:*:*:*:*:*:*:*", "matchCriteriaId": "08405DEF-05F4-45F0-AC95-DBF914A36D93"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.26:*:*:*:*:*:*:*", "matchCriteriaId": "1A7B9C4B-4A41-4175-9F07-191C1EE98C1F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.27:*:*:*:*:*:*:*", "matchCriteriaId": "B306E0A8-4D4A-4895-8128-A500D30A7E0C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.28:*:*:*:*:*:*:*", "matchCriteriaId": "295C839A-F34E-4853-A926-55EABC639412"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.29:*:*:*:*:*:*:*", "matchCriteriaId": "2AFD5F49-7EF9-4CFE-95BD-8FD19B500B0A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.30:*:*:*:*:*:*:*", "matchCriteriaId": "00B3DDDD-B2F6-4753-BA38-65A24017857D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.31:*:*:*:*:*:*:*", "matchCriteriaId": "33FCD39E-F4BF-432D-9CF9-F195CF5844F3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.32:*:*:*:*:*:*:*", "matchCriteriaId": "C7308690-CB0D-4758-B80F-D2ADCD2A9D66"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.33:*:*:*:*:*:*:*", "matchCriteriaId": "313A470B-8A2B-478A-82B5-B27D2718331C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.34:*:*:*:*:*:*:*", "matchCriteriaId": "83FF021E-07E3-41CC-AAE8-D99D7FF24B9D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.35:*:*:*:*:*:*:*", "matchCriteriaId": "F72412E3-8DA9-4CC9-A426-B534202ADBA4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.36:*:*:*:*:*:*:*", "matchCriteriaId": "FCAA9D7A-3C3E-4C0B-9D38-EA80E68C2E46"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.37:*:*:*:*:*:*:*", "matchCriteriaId": "4A9E3AE5-3FCF-4CBB-A30B-082BCFBFB0CB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.38:*:*:*:*:*:*:*", "matchCriteriaId": "CF715657-4C3A-4392-B85D-1BBF4DE45D89"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.39:*:*:*:*:*:*:*", "matchCriteriaId": "4B63C618-AC3D-4EF7-AFDF-27B9BF482B78"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.40:*:*:*:*:*:*:*", "matchCriteriaId": "C33DA5A9-5E40-4365-9602-82FB4DCD15B2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.41:*:*:*:*:*:*:*", "matchCriteriaId": "EFAFDB74-40BD-46FA-89AC-617EB2C7160B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.42:*:*:*:*:*:*:*", "matchCriteriaId": "CF5F17DA-30A7-40CF-BD7C-CEDF06D64617"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.43:*:*:*:*:*:*:*", "matchCriteriaId": "71A276F5-BD9D-4C1B-90DF-9B0C15B6F7DF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.44:*:*:*:*:*:*:*", "matchCriteriaId": "F8F6EBEC-3C29-444B-BB85-6EF239B59EC1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.45:*:*:*:*:*:*:*", "matchCriteriaId": "FDB91302-FD18-44CF-A8A8-B31483328539"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.46:*:*:*:*:*:*:*", "matchCriteriaId": "9B81DC2B-46FA-4640-AD6C-2A404D94BA0B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.47:*:*:*:*:*:*:*", "matchCriteriaId": "BA6A1663-BC4C-4FC9-B5EB-A52EDED17B26"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.48:*:*:*:*:*:*:*", "matchCriteriaId": "69C33D6C-6B9F-49F4-B505-E7B589CDEC50"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.49:*:*:*:*:*:*:*", "matchCriteriaId": "C464796B-2F31-4159-A132-82A0C74137B7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.50:*:*:*:*:*:*:*", "matchCriteriaId": "1D6C6E46-FE29-4D2D-A0EC-43DA5112BCC3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.51:*:*:*:*:*:*:*", "matchCriteriaId": "1A370E91-73A1-4D62-8E7B-696B920203F8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.52:*:*:*:*:*:*:*", "matchCriteriaId": "340197CD-9645-4B7E-B976-F3F5A7D4C5BE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.53:*:*:*:*:*:*:*", "matchCriteriaId": "96030636-0C4A-4A10-B768-525D6A0E18CB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.54:*:*:*:*:*:*:*", "matchCriteriaId": "A42D8419-914F-4AD6-B0E9-C1290D514FF1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.55:*:*:*:*:*:*:*", "matchCriteriaId": "F4E2C88B-42EA-4F4F-B1F6-A9332EC6888B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.56:*:*:*:*:*:*:*", "matchCriteriaId": "2449D13B-3314-4182-832F-03F6B11AA31F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.57:*:*:*:*:*:*:*", "matchCriteriaId": "9A35B66C-F050-4462-A58E-FEE061B5582E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.58:*:*:*:*:*:*:*", "matchCriteriaId": "1B551164-0167-49BB-A3AE-4034BDA3DCB4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.59:*:*:*:*:*:*:*", "matchCriteriaId": "7244278E-49B6-4405-A14C-F3540C8F5AF8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.60:*:*:*:*:*:*:*", "matchCriteriaId": "B4C3E4B8-7274-4ABB-B7CE-6A39C183CE18"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.61:*:*:*:*:*:*:*", "matchCriteriaId": "6501EDB9-4847-47F8-90EE-B295626E4CDC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.62:*:*:*:*:*:*:*", "matchCriteriaId": "2D676D48-7521-45E2-8563-6B966FF86A35"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.63:*:*:*:*:*:*:*", "matchCriteriaId": "3B69FA17-0AB9-4986-A5A7-2A4C1DD24222"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.64:*:*:*:*:*:*:*", "matchCriteriaId": "7BC35593-96C7-41F0-B738-1568F8129121"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.65:*:*:*:*:*:*:*", "matchCriteriaId": "38D23794-0E7C-4FA5-A7A8-CF940E3FA962"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.66:*:*:*:*:*:*:*", "matchCriteriaId": "008E1E7D-4C20-4560-9288-EF532ADB0029"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.67:*:*:*:*:*:*:*", "matchCriteriaId": "3B3A7044-A92E-47A9-A7BD-35E5B575F5FD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.68:*:*:*:*:*:*:*", "matchCriteriaId": "783E2980-B6AB-489E-B157-B6A2E10A32CA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:*:*:*:*:*:*:*", "matchCriteriaId": "3DFFE5A6-6A67-4992-84A3-C0F05FACDEAD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:rc1:*:*:*:*:*:*", "matchCriteriaId": "13BBD2A3-AE10-48B9-8776-4FB1CAC37D44"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:rc2:*:*:*:*:*:*", "matchCriteriaId": "B25680CC-8918-4F27-8D7E-A6579215450B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:rc3:*:*:*:*:*:*", "matchCriteriaId": "92C48B4C-410C-4BA8-A28A-B2E928320FCC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:rc4:*:*:*:*:*:*", "matchCriteriaId": "CB447523-855B-461E-8197-95169BE86EB0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.1:*:*:*:*:*:*:*", "matchCriteriaId": "B155BBDF-6DF6-4FF5-9C41-D8A5266DCC67"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.2:*:*:*:*:*:*:*", "matchCriteriaId": "28476DEC-9630-4B40-9D4D-9BC151DC4CA4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.3:*:*:*:*:*:*:*", "matchCriteriaId": "5646880A-2355-4BDD-89E7-825863A0311F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.4:*:*:*:*:*:*:*", "matchCriteriaId": "7FF99148-267A-46F8-9927-A9082269BAF6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.5:*:*:*:*:*:*:*", "matchCriteriaId": "A783C083-5D9C-48F9-B5A6-A97A9604FB19"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.6:*:*:*:*:*:*:*", "matchCriteriaId": "2B817A24-03AC-46CD-BEFA-505457FD2A5D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.7:*:*:*:*:*:*:*", "matchCriteriaId": "51CF1BCE-090E-4B70-BA16-ACB74411293B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.8:*:*:*:*:*:*:*", "matchCriteriaId": "187AAD67-10D7-4B57-B4C6-00443E246AF3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.9:*:*:*:*:*:*:*", "matchCriteriaId": "F341CE88-C5BC-4CDD-9CB5-B6BAD7152E63"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.10:*:*:*:*:*:*:*", "matchCriteriaId": "37ACE2A6-C229-4236-8E9F-235F008F3AA0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:*:*:*:*:*:*:*", "matchCriteriaId": "D3220B70-917F-4F9F-8A3B-2BF581281E8D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:*:*:*:*:*:x86:*", "matchCriteriaId": "7D47A395-821D-4BFF-996E-E849D9A40217"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc2:*:*:*:*:*:*", "matchCriteriaId": "99372D07-C06A-41FA-9843-6D57F99AB5AF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc3:*:*:*:*:*:*", "matchCriteriaId": "2B9DC110-D260-4DB4-B8B0-EF1D160ADA07"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc4:*:*:*:*:*:*", "matchCriteriaId": "6192FE84-4D53-40D4-AF61-78CE7136141A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc5:*:*:*:*:*:*", "matchCriteriaId": "42FEF3CF-1302-45EB-89CC-3786FE4BAC1F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc6:*:*:*:*:*:*", "matchCriteriaId": "AE6A6B58-2C89-4DE4-BA57-78100818095C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc7:*:*:*:*:*:*", "matchCriteriaId": "1D467F87-2F13-4D26-9A93-E0BA526FEA24"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "FE348F7B-02DE-47D5-8011-F83DA9426021"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.1:*:*:*:*:*:x86:*", "matchCriteriaId": "8A603291-33B4-4195-B52D-D2A9938089C1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.2:*:*:*:*:*:*:*", "matchCriteriaId": "E91594EA-F0A3-41B3-A9C6-F7864FC2F229"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.3:*:*:*:*:*:*:*", "matchCriteriaId": "9E1ECCDB-0208-48F6-B44F-16CC0ECE3503"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.4:*:*:*:*:*:*:*", "matchCriteriaId": "FBA8B5DE-372E-47E0-A0F6-BE286D509CC3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.5:*:*:*:*:*:*:*", "matchCriteriaId": "9A1CA083-2CF8-45AE-9E15-1AA3A8352E3B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.6:*:*:*:*:*:*:*", "matchCriteriaId": "19D69A49-5290-4C5F-8157-719AD58D253D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.7:*:*:*:*:*:*:*", "matchCriteriaId": "290BD969-42E7-47B0-B21B-06DE4865432C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.8:*:*:*:*:*:*:*", "matchCriteriaId": "23A9E29E-DE78-4C73-9FBD-C2410F5FC8B8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.9:*:*:*:*:*:*:*", "matchCriteriaId": "018434C9-E75F-45CB-A169-DAB4B1D864D7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.10:*:*:*:*:*:*:*", "matchCriteriaId": "DC0AC68F-EC58-4C4F-8CBC-A59ECC00CCDE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.11:*:*:*:*:*:*:*", "matchCriteriaId": "C123C844-F6D7-471E-A62E-F756042FB1CD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.12:*:*:*:*:*:*:*", "matchCriteriaId": "A11C38BB-7FA2-49B0-AAC9-83DB387A06DB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.13:*:*:*:*:*:*:*", "matchCriteriaId": "61F3733C-E5F6-4855-B471-DF3FB823613B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.14:*:*:*:*:*:*:*", "matchCriteriaId": "1DDCA75F-9A06-4457-9A45-38A38E7F7086"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.15:*:*:*:*:*:*:*", "matchCriteriaId": "7AEA837E-7864-4003-8DB7-111ED710A7E1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.16:*:*:*:*:*:*:*", "matchCriteriaId": "B6FE471F-2D1F-4A1D-A197-7E46B75787E1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.17:*:*:*:*:*:*:*", "matchCriteriaId": "FDA9E6AB-58DC-4EC5-A25C-11F9D0B38BF7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.18:*:*:*:*:*:*:*", "matchCriteriaId": "DC6B8DB3-B05B-41A2-B091-342D66AAE8F5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.19:*:*:*:*:*:*:*", "matchCriteriaId": "958F0FF8-33EF-4A71-A0BD-572C85211DBA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.20:*:*:*:*:*:*:*", "matchCriteriaId": "FBA39F48-B02F-4C48-B304-DA9CCA055244"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.21:*:*:*:*:*:*:*", "matchCriteriaId": "1FF841F3-48A7-41D7-9C45-A8170435A5EB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.22:*:*:*:*:*:*:*", "matchCriteriaId": "EF506916-A6DC-4B1E-90E5-959492AF55F4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.23:*:*:*:*:*:*:*", "matchCriteriaId": "B3CDAD1F-2C6A-48C0-8FAB-C2659373FA25"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.24:*:*:*:*:*:*:*", "matchCriteriaId": "4FFE4B22-C96A-43D0-B993-F51EDD9C5E0E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.25:*:*:*:*:*:*:*", "matchCriteriaId": "F571CC8B-B212-4553-B463-1DB01D616E8A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.26:*:*:*:*:*:*:*", "matchCriteriaId": "84E3E151-D437-48ED-A529-731EEFF88567"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.27:*:*:*:*:*:*:*", "matchCriteriaId": "E9E3EA3C-CCA5-4433-86E0-3D02C4757A0A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.28:*:*:*:*:*:*:*", "matchCriteriaId": "F7AC4F7D-9FA6-4CF1-B2E9-70BF7D4D177C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.29:*:*:*:*:*:*:*", "matchCriteriaId": "3CE3A80D-9648-43CC-8F99-D741ED6552BF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.30:*:*:*:*:*:*:*", "matchCriteriaId": "C8A98C03-A465-41B4-A551-A26FEC7FFD94"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:*:*:*:*:*:*:*", "matchCriteriaId": "AFB76697-1C2F-48C0-9B14-517EC053D4B3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc1:*:*:*:*:*:*", "matchCriteriaId": "BED88DFD-1DC5-4505-A441-44ECDEF0252D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc2:*:*:*:*:*:*", "matchCriteriaId": "DBFD2ACD-728A-4082-BB6A-A1EF6E58E47D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc3:*:*:*:*:*:*", "matchCriteriaId": "C31B0E51-F62D-4053-B04F-FC4D5BC373D2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc4:*:*:*:*:*:*", "matchCriteriaId": "A914303E-1CB6-4AAD-9F5F-DE5433C4E814"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc5:*:*:*:*:*:*", "matchCriteriaId": "203BBA69-90B2-4C5E-8023-C14180742421"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc6:*:*:*:*:*:*", "matchCriteriaId": "0DBFAB53-B889-4028-AC0E-7E165B152A18"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc7:*:*:*:*:*:*", "matchCriteriaId": "FE409AEC-F677-4DEF-8EB7-2C35809043CE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.1:*:*:*:*:*:*:*", "matchCriteriaId": "578EC12B-402F-4AD4-B8F8-C9B2CAB06891"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.2:*:*:*:*:*:*:*", "matchCriteriaId": "877002ED-8097-4BB4-BB88-6FC6306C38B2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.3:*:*:*:*:*:*:*", "matchCriteriaId": "76294CE3-D72C-41D5-9E0F-B693D0042699"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.4:*:*:*:*:*:*:*", "matchCriteriaId": "916E97D4-1FAB-42F5-826B-653B1C0909A8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.5:*:*:*:*:*:*:*", "matchCriteriaId": "33FD2217-C5D0-48C1-AD74-3527127FEF9C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.6:*:*:*:*:*:*:*", "matchCriteriaId": "2E92971F-B629-4E0A-9A50-8B235F9704B8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.7:*:*:*:*:*:*:*", "matchCriteriaId": "EDD3A069-3829-4EE2-9D5A-29459F29D4C1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.8:*:*:*:*:*:*:*", "matchCriteriaId": "A4A0964C-CEB2-41D7-A69C-1599B05B6171"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:*:*:*:*:*:*:*", "matchCriteriaId": "0F960FA6-F904-4A4E-B483-44C70090E9A1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:*:*:*:*:*:x86:*", "matchCriteriaId": "8C3D9C66-933A-469E-9073-75015A8AD17D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc1:*:*:*:*:*:*", "matchCriteriaId": "261C1B41-C9E0-414F-8368-51C0C0B8AD38"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc1:*:*:*:*:x86:*", "matchCriteriaId": "C92F29A0-DEFF-49E4-AE86-5DBDAD51C677"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc2:*:*:*:*:*:*", "matchCriteriaId": "5CCA261D-2B97-492F-89A0-5F209A804350"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc2:*:*:*:*:x86:*", "matchCriteriaId": "5690A703-390D-4D8A-9258-2F47116DAB4F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc3:*:*:*:*:*:*", "matchCriteriaId": "1B1C0C68-9194-473F-BE5E-EC7F184899FA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc3:*:*:*:*:x86:*", "matchCriteriaId": "AB1EDDA7-15AF-4B45-A931-DFCBB1EEB701"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc4:*:*:*:*:*:*", "matchCriteriaId": "D7A6AC9E-BEA6-44B0-B3B3-F0F94E32424A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc4:*:*:*:*:x86:*", "matchCriteriaId": "952FE0DC-B2ED-4080-BF29-A2C265E83FEF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc5:*:*:*:*:*:*", "matchCriteriaId": "16038328-9399-4B85-B777-BA4757D02C9B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc5:*:*:*:*:x86:*", "matchCriteriaId": "1CE7ABDB-6572-40E8-B952-CBE52C999858"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc6:*:*:*:*:*:*", "matchCriteriaId": "16CA2757-FA8D-43D9-96E8-D3C0EB6E1DEF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc6:*:*:*:*:x86:*", "matchCriteriaId": "0F417186-D1ED-4A31-92B2-83DEDA1AF272"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc7:*:*:*:*:*:*", "matchCriteriaId": "E8CB5481-5EAE-401E-BD7E-D3095CCA9E94"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc7:*:*:*:*:x86:*", "matchCriteriaId": "3D4FCFAE-918C-4886-9A17-08A5B94D35F4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.1:*:*:*:*:*:*:*", "matchCriteriaId": "A0F36FAC-141D-476D-84C5-A558C199F904"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.1:*:*:*:*:*:x86:*", "matchCriteriaId": "830D2914-C9FE-406F-AFCE-7A04BB9E2896"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.2:*:*:*:*:*:*:*", "matchCriteriaId": "51D64824-25F6-4761-BD6A-29038A143744"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.2:*:*:*:*:*:x86:*", "matchCriteriaId": "F4B791B5-2EB5-403A-90CC-B219F6277D1F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.3:*:*:*:*:*:*:*", "matchCriteriaId": "E284C8A1-740F-454D-A774-99CD3A21B594"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.3:*:*:*:*:*:x86:*", "matchCriteriaId": "2BA5F34D-7490-4B2B-A7E6-8450F9C1FC31"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.4:*:*:*:*:*:*:*", "matchCriteriaId": "C70D72AE-0CBF-4324-9935-57E28EC6279C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.4:*:*:*:*:*:x86:*", "matchCriteriaId": "B803FE64-FC8D-4650-9FB9-FEEED4340416"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.5:*:*:*:*:*:*:*", "matchCriteriaId": "F674B06B-7E86-4E41-9126-8152D0DDABAE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.5:*:*:*:*:*:x86:*", "matchCriteriaId": "4C560A9A-2388-4980-9E88-118C5EB806B7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.6:*:*:*:*:*:*:*", "matchCriteriaId": "7039B3EC-8B22-413E-B582-B4BEC6181241"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.7:*:*:*:*:*:*:*", "matchCriteriaId": "35CF1DD2-80B9-4476-8963-5C3EF52B33F4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.8:*:*:*:*:*:*:*", "matchCriteriaId": "BFB0B05B-A5CE-4B9C-AE7F-83062868D35B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.9:*:*:*:*:*:*:*", "matchCriteriaId": "D166A66E-7454-47EC-BB56-861A9AFEAFE1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.10:*:*:*:*:*:*:*", "matchCriteriaId": "7DA94F50-2A62-4300-BF4D-A342AAE35629"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.11:*:*:*:*:*:*:*", "matchCriteriaId": "252D937B-50DC-444F-AE73-5FCF6203DF27"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.12:*:*:*:*:*:*:*", "matchCriteriaId": "F6D8EE51-02C1-47BC-A92C-0A8ABEFD28FF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.13:*:*:*:*:*:*:*", "matchCriteriaId": "7F20A5D7-3B38-4911-861A-04C8310D5916"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.14:*:*:*:*:*:*:*", "matchCriteriaId": "D472DE3A-71D8-4F40-9DDE-85929A2B047D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.15:*:*:*:*:*:*:*", "matchCriteriaId": "B2AED943-65A8-4FDB-BBD0-CCEF8682A48C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.16:*:*:*:*:*:*:*", "matchCriteriaId": "D4640185-F3D8-4575-A71D-4C889A93DE2C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.17:*:*:*:*:*:*:*", "matchCriteriaId": "144CCF7C-025E-4879-B2E7-ABB8E4390BE5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.18:*:*:*:*:*:*:*", "matchCriteriaId": "B6FAA052-0B2B-40CE-8C98-919B8D08A5ED"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.19:*:*:*:*:*:*:*", "matchCriteriaId": "4B5A53DE-9C83-4A6B-96F3-23C03BF445D9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.20:*:*:*:*:*:*:*", "matchCriteriaId": "063EB879-CB05-4E33-AA90-9E43516839B5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.21:*:*:*:*:*:*:*", "matchCriteriaId": "2D25764F-4B02-4C65-954E-8C7D6632DE00"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.22:*:*:*:*:*:*:*", "matchCriteriaId": "F31F5BF3-CD0A-465C-857F-273841BCD28A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.23:*:*:*:*:*:*:*", "matchCriteriaId": "FF302C8A-079B-42B9-B455-CD9083BFA067"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.24:*:*:*:*:*:*:*", "matchCriteriaId": "744999C0-33D3-4363-B3DB-E0D02CDD3918"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.25:*:*:*:*:*:*:*", "matchCriteriaId": "C2E77A76-2A60-45D8-9337-867BC22C5110"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.26:*:*:*:*:*:*:*", "matchCriteriaId": "C9F4AAE7-C870-46B7-B559-2949737BE777"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.27:*:*:*:*:*:*:*", "matchCriteriaId": "20FA2824-20B0-48B8-BB0A-4904C1D3E8AA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.28:*:*:*:*:*:*:*", "matchCriteriaId": "9F9B347E-61AC-419F-9701-B862BBFA46F2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.29:*:*:*:*:*:*:*", "matchCriteriaId": "989F351C-8B7C-4C1B-AFA2-AE9431576368"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.30:*:*:*:*:*:*:*", "matchCriteriaId": "8D22172A-9FA7-42E0-8451-165D8E47A573"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.31:*:*:*:*:*:*:*", "matchCriteriaId": "CE31624C-94F9-45D8-9B4A-D0028F10602F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.32:*:*:*:*:*:*:*", "matchCriteriaId": "70967A83-28F6-4568-9ADA-6EF232E5BBC2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.1:*:*:*:*:*:*:*", "matchCriteriaId": "962B0C45-AB29-4383-AC16-C6E8245D0FF7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.2:*:*:*:*:*:*:*", "matchCriteriaId": "A0EE126B-74B2-4F79-BFE1-3DC169F3F9B2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.3:*:*:*:*:*:*:*", "matchCriteriaId": "392075E0-A9C7-4B4A-90F9-7F1ADFF5EFA7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.4:*:*:*:*:*:*:*", "matchCriteriaId": "ECC66968-06F0-4874-A95A-A292C36E45C1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.5:*:*:*:*:*:*:*", "matchCriteriaId": "5FE986E6-1068-4E1B-8EAB-DF1EAF32B4E3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.6:*:*:*:*:*:*:*", "matchCriteriaId": "543E8536-1A8E-4E76-B89F-1B1F9F26FAB8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.7:*:*:*:*:*:*:*", "matchCriteriaId": "EC2B45E3-31E1-4B46-85FA-3A84E75B8F84"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6:*:*:*:*:*:*:*", "matchCriteriaId": "DDB8CC75-D3EE-417C-A83D-CB6D666FE595"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.1:*:*:*:*:*:*:*", "matchCriteriaId": "09A072F1-7BEE-4236-ACBB-55DB8FEF4A03"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.2:*:*:*:*:*:*:*", "matchCriteriaId": "E19D5A58-17D6-4502-A57A-70B2F84817A4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.3:*:*:*:*:*:*:*", "matchCriteriaId": "D58BA035-1204-4DFA-98A1-12111FB6222E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.4:*:*:*:*:*:*:*", "matchCriteriaId": "A17F2E87-8EB8-476A-B5B5-9AE5CF53D9FE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.5:*:*:*:*:*:*:*", "matchCriteriaId": "A8CCC101-5852-4299-9B67-EA1B149D58C0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.6:*:*:*:*:*:*:*", "matchCriteriaId": "B8074D32-C252-4AD3-A579-1C5EDDD7014B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.7:*:*:*:*:*:*:*", "matchCriteriaId": "962AA802-8179-4606-AAC0-9363BAEABC9F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.8:*:*:*:*:*:*:*", "matchCriteriaId": "1286C858-D5A2-45F3-86D1-E50FE53FB23C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.9:*:*:*:*:*:*:*", "matchCriteriaId": "5AC4A13E-F560-4D01-98A3-E2A2B82EB25B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.10:*:*:*:*:*:*:*", "matchCriteriaId": "942C462A-5398-4BB9-A792-598682E1FEF2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.11:*:*:*:*:*:*:*", "matchCriteriaId": "B852F7E0-0282-483D-BB4D-18CB7A4F1392"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7:*:*:*:*:*:*:*", "matchCriteriaId": "53ED9A31-99CC-41C8-8B72-5B2A9B49AA6C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.1:*:*:*:*:*:*:*", "matchCriteriaId": "EFD646BC-62F7-47CF-B0BE-768F701F7D9A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.2:*:*:*:*:*:*:*", "matchCriteriaId": "F43D418E-87C1-4C83-9FF1-4F45B4F452DD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.3:*:*:*:*:*:*:*", "matchCriteriaId": "680D0E00-F29A-487C-8770-8E7EAC672B7C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.4:*:*:*:*:*:*:*", "matchCriteriaId": "2DCA96A4-A836-4E94-A39C-3AD3EA1D9611"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.5:*:*:*:*:*:*:*", "matchCriteriaId": "753C05E3-B603-4E36-B9BA-FAEDCBF62A7D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.6:*:*:*:*:*:*:*", "matchCriteriaId": "E385C2E0-B9F1-4564-8E6D-56FD9E762405"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.7:*:*:*:*:*:*:*", "matchCriteriaId": "041335D4-05E1-4004-9381-28AAD5994B47"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.8:*:*:*:*:*:*:*", "matchCriteriaId": "370F2AE5-3DBC-46B9-AC70-F052C9229C00"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.9:*:*:*:*:*:*:*", "matchCriteriaId": "7A971BE3-259D-4494-BBC5-12793D92DB57"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.10:*:*:*:*:*:*:*", "matchCriteriaId": "8E4719A6-FDEA-4714-A830-E23A52AE90BC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.0:*:*:*:*:*:*:*", "matchCriteriaId": "1A6E41FB-38CE-49F2-B796-9A5AA648E73F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.1:*:*:*:*:*:*:*", "matchCriteriaId": "93523FE1-5993-46CB-9299-7C8C1A04E873"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.2:*:*:*:*:*:*:*", "matchCriteriaId": "27ADC356-6BE9-43A3-9E0B-393DC4B1559A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.3:*:*:*:*:*:*:*", "matchCriteriaId": "4F543D23-1774-4D14-A7D1-AD49EDEA94DD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.4:*:*:*:*:*:*:*", "matchCriteriaId": "FC323F58-CA00-4C3C-BA4D-CC2C0A6E5F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.5:*:*:*:*:*:*:*", "matchCriteriaId": "FEA0B2E3-668D-40ED-9D3D-709EB6449F8D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.6:*:*:*:*:*:*:*", "matchCriteriaId": "3431B258-4EC8-4E7F-87BB-4D934880601E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.7:*:*:*:*:*:*:*", "matchCriteriaId": "1B09FA1E-8B28-4F2A-BA7E-8E1C40365970"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.8:*:*:*:*:*:*:*", "matchCriteriaId": "91917120-9D68-41C0-8B5D-85C256BC6200"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.9:*:*:*:*:*:*:*", "matchCriteriaId": "AAD268A0-096C-4C31-BEC5-D47F5149D462"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.10:*:*:*:*:*:*:*", "matchCriteriaId": "32BD2427-C47F-4660-A1D9-448E500EF5B9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.11:*:*:*:*:*:*:*", "matchCriteriaId": "02048CE5-81C7-4DFB-BC40-CE4C86B7E022"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.12:*:*:*:*:*:*:*", "matchCriteriaId": "934D2B37-0575-4A75-B00B-0028316D6DF0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.13:*:*:*:*:*:*:*", "matchCriteriaId": "06754C21-995C-4850-A4DC-F21826C0F8C5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc1:*:*:*:*:*:*", "matchCriteriaId": "42633FF9-FB0C-4095-B4A1-8D623A98683B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc2:*:*:*:*:*:*", "matchCriteriaId": "08C04619-89A2-4B15-82A2-48BCC662C1F1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc3:*:*:*:*:*:*", "matchCriteriaId": "5B039196-7159-476C-876A-C61242CC41DA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc4:*:*:*:*:*:*", "matchCriteriaId": "3A9E0457-53C9-44DD-ACFB-31EE1D1E060E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc5:*:*:*:*:*:*", "matchCriteriaId": "BEE406E7-87BA-44BA-BF61-673E6CC44A2F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc6:*:*:*:*:*:*", "matchCriteriaId": "29FBA173-658F-45DC-8205-934CACD67166"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc7:*:*:*:*:*:*", "matchCriteriaId": "139700F0-BA32-40CF-B9DF-C9C450384FDE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.0:*:*:*:*:*:*:*", "matchCriteriaId": "E578085C-3968-4543-BEBA-EE3C3CB4FA02"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.1:*:*:*:*:*:*:*", "matchCriteriaId": "4DCFA441-68FB-4559-A245-FF0B79DE43CA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.2:*:*:*:*:*:*:*", "matchCriteriaId": "8C2508D8-6571-4B81-A0D7-E494CCD039CE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.3:*:*:*:*:*:*:*", "matchCriteriaId": "8B516926-5E86-4C0A-85F3-F64E1FCDA249"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.4:*:*:*:*:*:*:*", "matchCriteriaId": "069D774D-79BE-479F-BF4E-F021AD808114"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.5:*:*:*:*:*:*:*", "matchCriteriaId": "D15B27A9-46E0-4DDF-A00C-29F8F1F18D73"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.6:*:*:*:*:*:*:*", "matchCriteriaId": "A381BB4A-28B4-4672-87EE-91B3DDD6C71A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.7:*:*:*:*:*:*:*", "matchCriteriaId": "922F80CF-937D-4FA2-AFF2-6E47FFE9E1E9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.8:*:*:*:*:*:*:*", "matchCriteriaId": "A548ADF4-9E3B-407C-A5ED-05150EB3A185"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.9:*:*:*:*:*:*:*", "matchCriteriaId": "9C623230-4497-41B9-9BD2-7A6CFDD77983"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.10:*:*:*:*:*:*:*", "matchCriteriaId": "C72FA8A6-60A6-4486-A245-7BEF8B2A2711"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.11:*:*:*:*:*:*:*", "matchCriteriaId": "0A498D90-BB99-405E-9FA6-1FBFE179787E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.0:*:*:*:*:*:arm64:*", "matchCriteriaId": "C8409226-20A1-4549-9E11-6D0C3C38DCCE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.1:*:*:*:*:*:*:*", "matchCriteriaId": "D0D32776-8ADB-4E79-846A-C0C99FED19E0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.2:*:*:*:*:*:*:*", "matchCriteriaId": "B7D01673-D13F-487F-81B6-1279C187277E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.3:*:*:*:*:*:*:*", "matchCriteriaId": "ADB27A3E-78E4-40F7-9716-A1099B0D85FB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.4:*:*:*:*:*:*:*", "matchCriteriaId": "16E7136A-A8A6-4BF5-AF5D-AFB5C7A10712"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.5:*:*:*:*:*:*:*", "matchCriteriaId": "6FE127AC-E61D-427A-B998-D60DF5AABA21"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.6:*:*:*:*:*:*:*", "matchCriteriaId": "3819FF99-AEC5-4466-8542-D395419E4308"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.7:*:*:*:*:*:*:*", "matchCriteriaId": "E621FA1A-464B-4D2A-A0D6-EDA475A3709B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.8:*:*:*:*:*:*:*", "matchCriteriaId": "B760B422-EA11-43AB-B6D2-CA54E7229663"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.9:*:*:*:*:*:*:*", "matchCriteriaId": "D2CA7BBC-917C-4F31-A442-465C30444836"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.10:*:*:*:*:*:*:*", "matchCriteriaId": "AE778000-4FD5-4032-86CE-5930EF4CB7C1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.11:*:*:*:*:*:*:*", "matchCriteriaId": "B3344EEB-F037-48FE-81DC-67F6384F7D9A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.12:*:*:*:*:*:*:*", "matchCriteriaId": "0244B0CA-9C67-4F06-BFBA-1F257112AC08"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.13:*:*:*:*:*:*:*", "matchCriteriaId": "2148C13F-4BB0-4D46-A688-F7C726D12497"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.14:*:*:*:*:*:*:*", "matchCriteriaId": "9871AF57-9158-4A41-8340-596B4463289A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.15:*:*:*:*:*:*:*", "matchCriteriaId": "2A875207-DF01-4240-8895-49B62693D27B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.16:*:*:*:*:*:*:*", "matchCriteriaId": "FE04A172-6F3B-4E3B-8D4D-564740FABAAF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.17:*:*:*:*:*:*:*", "matchCriteriaId": "CFEEF8C4-7DC2-4230-B58C-337F39A4DFAF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.18:*:*:*:*:*:*:*", "matchCriteriaId": "9F74DB5C-5096-438C-8C8A-6D337A2FD06A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11:*:*:*:*:*:*:*", "matchCriteriaId": "639E3A57-A9E7-40E6-8929-81CCC0060EFB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.1:*:*:*:*:*:*:*", "matchCriteriaId": "07012ADD-F521-40A8-B067-E87C2238A3D2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.2:*:*:*:*:*:*:*", "matchCriteriaId": "3F5FF393-3F89-4274-B82B-F671358072ED"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.3:*:*:*:*:*:*:*", "matchCriteriaId": "E348698F-54D1-4F5E-B701-CFAF50881E0A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.4:*:*:*:*:*:*:*", "matchCriteriaId": "932205D9-3514-4289-9B55-C7A169276930"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.5:*:*:*:*:*:*:*", "matchCriteriaId": "2ECB2D33-F517-480F-8A6F-99D9D6C49596"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.6:*:*:*:*:*:*:*", "matchCriteriaId": "D16F68DD-E2D4-4AA4-AB81-3796C2947E37"}]}]}], "references": [{"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=7314e613d5ff9f0934f7a0f74ed7973b903315d1", "source": "secalert@redhat.com"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2014-02/msg00002.html", "source": "secalert@redhat.com"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2014-02/msg00003.html", "source": "secalert@redhat.com"}, {"url": "http://lists.opensuse.org/opensuse-updates/2014-02/msg00045.html", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2013/11/04/22", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-2036-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-2037-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-2066-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-2067-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-2068-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-2069-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-2070-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-2071-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-2072-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-2073-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-2074-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-2075-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-2076-1", "source": "secalert@redhat.com"}, {"url": "https://github.com/torvalds/linux/commit/7314e613d5ff9f0934f7a0f74ed7973b903315d1", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}, {"url": "https://www.kernel.org/pub/linux/kernel/v3.x/patch-3.12.bz2", "source": "secalert@redhat.com", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/7314e613d5ff9f0934f7a0f74ed7973b903315d1"}}