{"buggy_code": ["# frozen_string_literal: true\n\nclass UserNotifications < ActionMailer::Base\n  include UserNotificationsHelper\n  include ApplicationHelper\n  helper :application, :email\n  default charset: 'UTF-8'\n  layout 'email_template'\n\n  include Email::BuildEmailHelper\n\n  def signup(user, opts = {})\n    build_user_email_token_by_template(\n      \"user_notifications.signup\",\n      user,\n      opts[:email_token]\n    )\n  end\n\n  def activation_reminder(user, opts = {})\n    build_user_email_token_by_template(\n      \"user_notifications.activation_reminder\",\n      user,\n      opts[:email_token]\n    )\n  end\n\n  def signup_after_approval(user, opts = {})\n    locale = user_locale(user)\n    tips = I18n.t('system_messages.usage_tips.text_body_template',\n                  base_url: Discourse.base_url,\n                  locale: locale)\n\n    build_email(user.email,\n                template: 'user_notifications.signup_after_approval',\n                locale: locale,\n                new_user_tips: tips)\n  end\n\n  def post_approved(user, opts = {})\n    post_url = opts.dig(:notification_data_hash, :post_url)\n\n    return if post_url.nil?\n\n    locale = user_locale(user)\n    build_email(user.email,\n      template: 'user_notifications.post_approved',\n      locale: locale,\n      base_url: Discourse.base_url,\n      post_url: post_url\n    )\n  end\n\n  def signup_after_reject(user, opts = {})\n    locale = user_locale(user)\n    build_email(user.email,\n                template: 'user_notifications.signup_after_reject',\n                locale: locale,\n                reject_reason: opts[:reject_reason])\n  end\n\n  def suspicious_login(user, opts = {})\n    ipinfo = DiscourseIpInfo.get(opts[:client_ip])\n    location = ipinfo[:location]\n    browser = BrowserDetection.browser(opts[:user_agent])\n    device = BrowserDetection.device(opts[:user_agent])\n    os = BrowserDetection.os(opts[:user_agent])\n\n    build_email(\n      user.email,\n      template: \"user_notifications.suspicious_login\",\n      locale: user_locale(user),\n      client_ip: opts[:client_ip],\n      location: location.present? ? location : I18n.t('staff_action_logs.unknown'),\n      browser: I18n.t(\"user_auth_tokens.browser.#{browser}\"),\n      device: I18n.t(\"user_auth_tokens.device.#{device}\"),\n      os: I18n.t(\"user_auth_tokens.os.#{os}\")\n    )\n  end\n\n  def notify_old_email(user, opts = {})\n    build_email(user.email,\n                template: \"user_notifications.notify_old_email\",\n                locale: user_locale(user),\n                new_email: opts[:new_email])\n  end\n\n  def notify_old_email_add(user, opts = {})\n    build_email(user.email,\n                template: \"user_notifications.notify_old_email_add\",\n                locale: user_locale(user),\n                new_email: opts[:new_email])\n  end\n\n  def confirm_old_email(user, opts = {})\n    build_user_email_token_by_template(\n      \"user_notifications.confirm_old_email\",\n      user,\n      opts[:email_token]\n    )\n  end\n\n  def confirm_old_email_add(user, opts = {})\n    build_user_email_token_by_template(\n      \"user_notifications.confirm_old_email_add\",\n      user,\n      opts[:email_token]\n    )\n  end\n\n  def confirm_new_email(user, opts = {})\n    build_user_email_token_by_template(\n      opts[:requested_by_admin] ? \"user_notifications.confirm_new_email_via_admin\" : \"user_notifications.confirm_new_email\",\n      user,\n      opts[:email_token]\n    )\n  end\n\n  def forgot_password(user, opts = {})\n    build_user_email_token_by_template(\n      user.has_password? ? \"user_notifications.forgot_password\" : \"user_notifications.set_password\",\n      user,\n      opts[:email_token]\n    )\n  end\n\n  def email_login(user, opts = {})\n    build_user_email_token_by_template(\n      \"user_notifications.email_login\",\n      user,\n      opts[:email_token]\n    )\n  end\n\n  def admin_login(user, opts = {})\n    build_user_email_token_by_template(\n      \"user_notifications.admin_login\",\n      user,\n      opts[:email_token]\n    )\n  end\n\n  def account_created(user, opts = {})\n    build_user_email_token_by_template(\n      \"user_notifications.account_created\",\n      user,\n      opts[:email_token]\n    )\n  end\n\n  def account_silenced(user, opts = nil)\n    opts ||= {}\n\n    return unless user_history = opts[:user_history]\n\n    if user.silenced_forever?\n      build_email(\n        user.email,\n        template: \"user_notifications.account_silenced_forever\",\n        locale: user_locale(user),\n        reason: user_history.details\n      )\n    else\n      silenced_till = user.silenced_till.in_time_zone(user.user_option.timezone)\n      build_email(\n        user.email,\n        template: \"user_notifications.account_silenced\",\n        locale: user_locale(user),\n        reason: user_history.details,\n        silenced_till: I18n.l(silenced_till, format: :long)\n      )\n    end\n  end\n\n  def account_suspended(user, opts = nil)\n    opts ||= {}\n\n    return unless user_history = opts[:user_history]\n\n    if user.suspended_forever?\n      build_email(\n        user.email,\n        template: \"user_notifications.account_suspended_forever\",\n        locale: user_locale(user),\n        reason: user_history.details\n      )\n    else\n      suspended_till = user.suspended_till.in_time_zone(user.user_option.timezone)\n      build_email(\n        user.email,\n        template: \"user_notifications.account_suspended\",\n        locale: user_locale(user),\n        reason: user_history.details,\n        suspended_till: I18n.l(suspended_till, format: :long)\n      )\n    end\n  end\n\n  def account_exists(user, opts = {})\n    build_email(\n      user.email,\n      template: 'user_notifications.account_exists',\n      locale: user_locale(user),\n      email: user.email\n    )\n  end\n\n  def account_second_factor_disabled(user, opts = {})\n    build_email(\n      user.email,\n      template: 'user_notifications.account_second_factor_disabled',\n      locale: user_locale(user),\n      email: user.email\n    )\n  end\n\n  def digest(user, opts = {})\n    build_summary_for(user)\n    @unsubscribe_key = UnsubscribeKey.create_key_for(@user, UnsubscribeKey::DIGEST_TYPE)\n\n    min_date = opts[:since] || user.last_emailed_at || user.last_seen_at || 1.month.ago\n\n    # Fetch some topics and posts to show\n    digest_opts = { limit: SiteSetting.digest_topics + SiteSetting.digest_other_topics, top_order: true }\n    topics_for_digest = Topic.for_digest(user, min_date, digest_opts).to_a\n    if topics_for_digest.empty? && !user.user_option.try(:include_tl0_in_digests)\n      # Find some topics from new users that are at least 24 hours old\n      topics_for_digest = Topic.for_digest(user, min_date, digest_opts.merge(include_tl0: true)).where('topics.created_at < ?', 24.hours.ago).to_a\n    end\n\n    @popular_topics = topics_for_digest[0, SiteSetting.digest_topics]\n\n    if @popular_topics.present?\n      @other_new_for_you = topics_for_digest.size > SiteSetting.digest_topics ? topics_for_digest[SiteSetting.digest_topics..-1] : []\n\n      @popular_posts = if SiteSetting.digest_posts > 0\n        Post.order(\"posts.score DESC\")\n          .for_mailing_list(user, min_date)\n          .where('posts.post_type = ?', Post.types[:regular])\n          .where('posts.deleted_at IS NULL AND posts.hidden = false AND posts.user_deleted = false')\n          .where(\"posts.post_number > ? AND posts.score > ?\", 1, ScoreCalculator.default_score_weights[:like_score] * 5.0)\n          .where('posts.created_at < ?', (SiteSetting.editing_grace_period || 0).seconds.ago)\n          .limit(SiteSetting.digest_posts)\n      else\n        []\n      end\n\n      @excerpts = {}\n\n      @popular_topics.map do |t|\n        @excerpts[t.first_post.id] = email_excerpt(t.first_post.cooked, t.first_post) if t.first_post.present?\n      end\n\n      # Try to find 3 interesting stats for the top of the digest\n      new_topics_count = Topic.for_digest(user, min_date).count\n\n      if new_topics_count == 0\n        # We used topics from new users instead, so count should match\n        new_topics_count = topics_for_digest.size\n      end\n      @counts = [{ label_key: 'user_notifications.digest.new_topics',\n                   value: new_topics_count,\n                   href: \"#{Discourse.base_url}/new\" }]\n\n      # totalling unread notifications (which are low-priority only) and unread\n      # PMs and bookmark reminder notifications, so the total is both unread low\n      # and high priority PMs\n      value = user.unread_notifications + user.unread_high_priority_notifications\n      @counts << { label_key: 'user_notifications.digest.unread_notifications', value: value, href: \"#{Discourse.base_url}/my/notifications\" } if value > 0\n\n      if @counts.size < 3\n        value = user.unread_notifications_of_type(Notification.types[:liked])\n        @counts << { label_key: 'user_notifications.digest.liked_received', value: value, href: \"#{Discourse.base_url}/my/notifications\" } if value > 0\n      end\n\n      if @counts.size < 3 && user.user_option.digest_after_minutes.to_i >= 1440\n        value = summary_new_users_count(min_date)\n        @counts << { label_key: 'user_notifications.digest.new_users', value: value, href: \"#{Discourse.base_url}/about\" } if value > 0\n      end\n\n      @last_seen_at = short_date(user.last_seen_at || user.created_at)\n\n      @preheader_text = I18n.t('user_notifications.digest.preheader', last_seen_at: @last_seen_at)\n\n      opts = {\n        from_alias: I18n.t('user_notifications.digest.from', site_name: Email.site_title),\n        subject: I18n.t('user_notifications.digest.subject_template', email_prefix: @email_prefix, date: short_date(Time.now)),\n        add_unsubscribe_link: true,\n        unsubscribe_url: \"#{Discourse.base_url}/email/unsubscribe/#{@unsubscribe_key}\",\n      }\n\n      build_email(user.email, opts)\n    end\n  end\n\n  def user_replied(user, opts)\n    opts[:allow_reply_by_email] = true\n    opts[:use_site_subject] = true\n    opts[:show_category_in_subject] = true\n    opts[:show_tags_in_subject] = true\n    notification_email(user, opts)\n  end\n\n  def user_quoted(user, opts)\n    opts[:allow_reply_by_email] = true\n    opts[:use_site_subject] = true\n    opts[:show_category_in_subject] = true\n    opts[:show_tags_in_subject] = true\n    notification_email(user, opts)\n  end\n\n  def user_linked(user, opts)\n    opts[:allow_reply_by_email] = true\n    opts[:use_site_subject] = true\n    opts[:show_category_in_subject] = true\n    opts[:show_tags_in_subject] = true\n    notification_email(user, opts)\n  end\n\n  def user_mentioned(user, opts)\n    opts[:allow_reply_by_email] = true\n    opts[:use_site_subject] = true\n    opts[:show_category_in_subject] = true\n    opts[:show_tags_in_subject] = true\n    notification_email(user, opts)\n  end\n\n  def group_mentioned(user, opts)\n    opts[:allow_reply_by_email] = true\n    opts[:use_site_subject] = true\n    opts[:show_category_in_subject] = true\n    opts[:show_tags_in_subject] = true\n    notification_email(user, opts)\n  end\n\n  def user_posted(user, opts)\n    opts[:allow_reply_by_email] = true\n    opts[:use_site_subject] = true\n    opts[:add_re_to_subject] = true\n    opts[:show_category_in_subject] = true\n    opts[:show_tags_in_subject] = true\n    notification_email(user, opts)\n  end\n\n  def user_private_message(user, opts)\n    opts[:allow_reply_by_email] = true\n    opts[:use_site_subject] = true\n    opts[:add_re_to_subject] = true\n    opts[:show_category_in_subject] = false\n    opts[:show_tags_in_subject] = false\n    opts[:show_group_in_subject] = true if SiteSetting.group_in_subject\n\n    # We use the 'user_posted' event when you are emailed a post in a PM.\n    opts[:notification_type] = 'posted'\n\n    notification_email(user, opts)\n  end\n\n  def user_invited_to_private_message(user, opts)\n    opts[:allow_reply_by_email] = false\n    opts[:use_invite_template] = true\n    notification_email(user, opts)\n  end\n\n  def user_invited_to_topic(user, opts)\n    opts[:allow_reply_by_email] = false\n    opts[:use_invite_template] = true\n    opts[:show_category_in_subject] = true\n    opts[:show_tags_in_subject] = true\n    notification_email(user, opts)\n  end\n\n  def user_watching_first_post(user, opts)\n    user_posted(user, opts)\n  end\n\n  def mailing_list_notify(user, post)\n    opts = {\n      post: post,\n      allow_reply_by_email: true,\n      use_site_subject: true,\n      add_re_to_subject: true,\n      show_category_in_subject: true,\n      show_tags_in_subject: true,\n      notification_type: \"posted\",\n      notification_data_hash: {\n        original_username: post.user.username,\n        topic_title: post.topic.title,\n      },\n    }\n    notification_email(user, opts)\n  end\n\n  protected\n\n  def user_locale(user)\n    user.effective_locale\n  end\n\n  def email_post_markdown(post, add_posted_by = false)\n    result = +\"#{post.raw}\\n\\n\"\n    if add_posted_by\n      result << \"#{I18n.t('user_notifications.posted_by', username: post.username, post_date: post.created_at.strftime(\"%m/%d/%Y\"))}\\n\\n\"\n    end\n    result\n  end\n\n  def self.get_context_posts(post, topic_user, user)\n    if (user.user_option.email_previous_replies == UserOption.previous_replies_type[:never]) ||\n       SiteSetting.private_email?\n      return []\n    end\n\n    allowed_post_types = [Post.types[:regular]]\n    allowed_post_types << Post.types[:whisper] if topic_user.try(:user).try(:staff?)\n\n    context_posts = Post.where(topic_id: post.topic_id)\n      .where(\"post_number < ?\", post.post_number)\n      .where(user_deleted: false)\n      .where(hidden: false)\n      .where(post_type: allowed_post_types)\n      .order('created_at desc')\n      .limit(SiteSetting.email_posts_context)\n\n    if topic_user && topic_user.last_emailed_post_number && user.user_option.email_previous_replies == UserOption.previous_replies_type[:unless_emailed]\n      context_posts = context_posts.where(\"post_number > ?\", topic_user.last_emailed_post_number)\n    end\n\n    context_posts\n  end\n\n  def notification_email(user, opts)\n    notification_type = opts[:notification_type]\n    notification_data = opts[:notification_data_hash]\n    post = opts[:post]\n\n    unless String === notification_type\n      if Numeric === notification_type\n        notification_type = Notification.types[notification_type]\n      end\n      notification_type = notification_type.to_s\n    end\n\n    user_name = notification_data[:original_username]\n\n    if post && SiteSetting.enable_names && SiteSetting.display_name_on_email_from\n      name = User.where(id: notification_data[:original_user_id] || post.user_id).pluck_first(:name)\n      user_name = name unless name.blank?\n    end\n\n    allow_reply_by_email = opts[:allow_reply_by_email] unless user.suspended?\n    original_username = notification_data[:original_username] || notification_data[:display_username]\n\n    if user.staged && post\n      original_subject = IncomingEmail.joins(:post)\n        .where(\"posts.topic_id = ? AND posts.post_number = 1\", post.topic_id)\n        .pluck(:subject)\n        .first\n    end\n\n    if original_subject\n      topic_title = original_subject\n      opts[:use_site_subject] = false\n      opts[:add_re_to_subject] = true\n      use_topic_title_subject = true\n    else\n      topic_title = notification_data[:topic_title]\n      use_topic_title_subject = false\n    end\n\n    email_options = {\n      title: topic_title,\n      post: post,\n      username: original_username,\n      from_alias: I18n.t('email_from', user_name: user_name, site_name: Email.site_title),\n      allow_reply_by_email: allow_reply_by_email,\n      use_site_subject: opts[:use_site_subject],\n      add_re_to_subject: opts[:add_re_to_subject],\n      show_category_in_subject: opts[:show_category_in_subject],\n      show_tags_in_subject: opts[:show_tags_in_subject],\n      show_group_in_subject: opts[:show_group_in_subject],\n      notification_type: notification_type,\n      use_invite_template: opts[:use_invite_template],\n      use_topic_title_subject: use_topic_title_subject,\n      user: user\n    }\n\n    if group_id = notification_data[:group_id]\n      email_options[:group_name] = Group.find_by(id: group_id)&.name\n    end\n\n    send_notification_email(email_options)\n  end\n\n  def send_notification_email(opts)\n    post = opts[:post]\n    title = opts[:title]\n\n    allow_reply_by_email = opts[:allow_reply_by_email]\n    use_site_subject = opts[:use_site_subject]\n    add_re_to_subject = opts[:add_re_to_subject] && post.post_number > 1\n    use_topic_title_subject = opts[:use_topic_title_subject]\n    username = opts[:username]\n    from_alias = opts[:from_alias]\n    notification_type = opts[:notification_type]\n    user = opts[:user]\n    group_name = opts[:group_name]\n    locale = user_locale(user)\n\n    template = +\"user_notifications.user_#{notification_type}\"\n    if post.topic.private_message?\n      template << \"_pm\"\n\n      if group_name\n        template << \"_group\"\n      elsif user.staged\n        template << \"_staged\"\n      end\n    end\n\n    # category name\n    category = Topic.find_by(id: post.topic_id)&.category\n    if opts[:show_category_in_subject] && post.topic_id && category && !category.uncategorized?\n      show_category_in_subject = category.name\n\n      # subcategory case\n      if !category.parent_category_id.nil?\n        show_category_in_subject = \"#{Category.where(id: category.parent_category_id).pluck_first(:name)}/#{show_category_in_subject}\"\n      end\n    else\n      show_category_in_subject = nil\n    end\n\n    # tag names\n    if opts[:show_tags_in_subject] && post.topic_id\n\n      tags = Tag.joins(:topic_tags)\n        .where(\"topic_tags.topic_id = ?\", post.topic_id)\n        .limit(3)\n        .pluck(:name)\n\n      show_tags_in_subject = tags.any? ? tags.join(\" \") : nil\n    end\n\n    group = post.topic.allowed_groups&.first\n\n    if post.topic.private_message?\n      subject_pm =\n        if opts[:show_group_in_subject] && group.present?\n          if group.full_name\n            \"[#{group.full_name}] \"\n          else\n            \"[#{group.name}] \"\n          end\n        else\n          I18n.t('subject_pm')\n        end\n\n      participants = self.class.participants(post, user)\n    end\n\n    if SiteSetting.private_email?\n      title = I18n.t(\"system_messages.private_topic_title\", id: post.topic_id)\n    end\n\n    context = +\"\"\n    tu = TopicUser.get(post.topic_id, user)\n    context_posts = self.class.get_context_posts(post, tu, user)\n\n    # make .present? cheaper\n    context_posts = context_posts.to_a\n\n    if context_posts.present?\n      context << +\"-- \\n*#{I18n.t('user_notifications.previous_discussion')}*\\n\"\n      context_posts.each do |cp|\n        context << email_post_markdown(cp, true)\n      end\n    end\n\n    translation_override_exists = TranslationOverride.where(\n      locale: SiteSetting.default_locale,\n      translation_key: \"#{template}.text_body_template\"\n    ).exists?\n\n    if opts[:use_invite_template]\n      invite_template = +\"user_notifications.invited\"\n      invite_template << \"_group\" if group_name\n\n      invite_template <<\n        if post.topic.private_message?\n          \"_to_private_message_body\"\n        else\n          \"_to_topic_body\"\n        end\n\n      topic_excerpt = post.excerpt.tr(\"\\n\", \" \") if post.is_first_post? && post.excerpt\n      topic_url = post.topic&.url\n\n      if SiteSetting.private_email?\n        topic_excerpt = \"\"\n        topic_url = \"\"\n      end\n\n      message = I18n.t(invite_template,\n        username: username,\n        group_name: group_name,\n        topic_title: gsub_emoji_to_unicode(title),\n        topic_excerpt: topic_excerpt,\n        site_title: SiteSetting.title,\n        site_description: SiteSetting.site_description,\n        topic_url: topic_url\n      )\n\n      html = PrettyText.cook(message, sanitize: false).html_safe\n    else\n      reached_limit = SiteSetting.max_emails_per_day_per_user > 0\n      reached_limit &&= (EmailLog.where(user_id: user.id)\n                              .where('created_at > ?', 1.day.ago)\n                              .count) >= (SiteSetting.max_emails_per_day_per_user - 1)\n\n      in_reply_to_post = post.reply_to_post if user.user_option.email_in_reply_to\n      if SiteSetting.private_email?\n        message = I18n.t('system_messages.contents_hidden')\n      else\n        message = email_post_markdown(post) + (reached_limit ? \"\\n\\n#{I18n.t \"user_notifications.reached_limit\", count: SiteSetting.max_emails_per_day_per_user}\" : \"\")\n      end\n\n      first_footer_classes = \"highlight\"\n      if (allow_reply_by_email && user.staged) || (user.suspended? || user.staged?)\n        first_footer_classes = \"\"\n      end\n\n      unless translation_override_exists\n        html = UserNotificationRenderer.render(\n          template: 'email/notification',\n          format: :html,\n          locals: { context_posts: context_posts,\n                    reached_limit: reached_limit,\n                    post: post,\n                    in_reply_to_post: in_reply_to_post,\n                    classes: Rtl.new(user).css_class,\n                    first_footer_classes: first_footer_classes,\n                    reply_above_line: false\n          }\n        )\n      end\n    end\n\n    email_opts = {\n      topic_title: Emoji.gsub_emoji_to_unicode(title),\n      topic_title_url_encoded: title ? UrlHelper.encode_component(title) : title,\n      message: message,\n      url: post.url(without_slug: SiteSetting.private_email?),\n      post_id: post.id,\n      topic_id: post.topic_id,\n      context: context,\n      username: username,\n      group_name: group_name,\n      add_unsubscribe_link: !user.staged,\n      mailing_list_mode: user.user_option.mailing_list_mode,\n      unsubscribe_url: post.unsubscribe_url(user),\n      allow_reply_by_email: allow_reply_by_email,\n      only_reply_by_email: allow_reply_by_email && user.staged,\n      use_site_subject: use_site_subject,\n      add_re_to_subject: add_re_to_subject,\n      show_category_in_subject: show_category_in_subject,\n      show_tags_in_subject: show_tags_in_subject,\n      private_reply: post.topic.private_message?,\n      subject_pm: subject_pm,\n      participants: participants,\n      include_respond_instructions: !(user.suspended? || user.staged?),\n      template: template,\n      use_topic_title_subject: use_topic_title_subject,\n      site_description: SiteSetting.site_description,\n      site_title: SiteSetting.title,\n      site_title_url_encoded: UrlHelper.encode_component(SiteSetting.title),\n      locale: locale\n    }\n\n    unless translation_override_exists\n      email_opts[:html_override] = html\n    end\n\n    # If we have a display name, change the from address\n    email_opts[:from_alias] = from_alias if from_alias.present?\n\n    TopicUser.change(user.id, post.topic_id, last_emailed_post_number: post.post_number)\n\n    build_email(user.email, email_opts)\n  end\n\n  def self.participants(post, recipient_user, reveal_staged_email: false)\n    list = []\n\n    allowed_groups = post.topic.allowed_groups.order(\"user_count DESC\")\n\n    allowed_groups.each do |g|\n      list.push(\"[#{g.name_full_preferred} (#{g.user_count})](#{g.full_url})\")\n      break if list.size >= SiteSetting.max_participant_names\n    end\n\n    recent_posts_query = post.topic.posts\n      .select(\"user_id, MAX(post_number) AS post_number\")\n      .where(post_type: Post.types[:regular], post_number: ..post.post_number)\n      .where.not(user_id: recipient_user.id)\n      .group(:user_id)\n      .order(\"post_number DESC\")\n      .limit(SiteSetting.max_participant_names)\n      .to_sql\n\n    allowed_users = post.topic.allowed_users\n      .joins(\"LEFT JOIN (#{recent_posts_query}) pu ON topic_allowed_users.user_id = pu.user_id\")\n      .order(\"post_number DESC NULLS LAST\", :id)\n      .where.not(id: recipient_user.id)\n      .human_users\n\n    allowed_users.each do |u|\n      break if list.size >= SiteSetting.max_participant_names\n\n      if reveal_staged_email && u.staged?\n        list.push(\"#{u.email}\")\n      else\n        list.push(\"[#{u.display_name}](#{u.full_url})\")\n      end\n    end\n\n    participants = list.join(I18n.t(\"word_connector.comma\"))\n    others_count = allowed_groups.size + allowed_users.size - list.size\n\n    if others_count > 0\n      I18n.t(\"user_notifications.more_pm_participants\", participants: participants, count: others_count)\n    else\n      participants\n    end\n  end\n\n  private\n\n  def build_user_email_token_by_template(template, user, email_token)\n    build_email(\n      user.email,\n      template: template,\n      locale: user_locale(user),\n      email_token: email_token\n    )\n  end\n\n  def build_summary_for(user)\n    @site_name       = SiteSetting.email_prefix.presence || SiteSetting.title # used by I18n\n    @user            = user\n    @date            = short_date(Time.now)\n    @base_url        = Discourse.base_url\n    @email_prefix    = SiteSetting.email_prefix.presence || SiteSetting.title\n    @header_color    = ColorScheme.hex_for_name('header_primary')\n    @header_bgcolor  = ColorScheme.hex_for_name('header_background')\n    @anchor_color    = ColorScheme.hex_for_name('tertiary')\n    @markdown_linker = MarkdownLinker.new(@base_url)\n    @disable_email_custom_styles = !SiteSetting.apply_custom_styles_to_digest\n  end\n\n  def self.summary_new_users_count_key(min_date_str)\n    \"summary-new-users:#{min_date_str}\"\n  end\n\n  def summary_new_users_count(min_date)\n    min_date_str = min_date.is_a?(String) ? min_date : min_date.strftime('%Y-%m-%d')\n    key = self.class.summary_new_users_count_key(min_date_str)\n    ((count = Discourse.redis.get(key)) && count.to_i) || begin\n      count = User.real.where(active: true, staged: false).not_suspended.where(\"created_at > ?\", min_date_str).count\n      Discourse.redis.setex(key, 1.day, count)\n      count\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nRSpec.describe UserNotifications do\n  let(:user) { Fabricate(:admin) }\n\n  describe \"#get_context_posts\" do\n    it \"does not include hidden/deleted/user_deleted posts in context\" do\n      post1 = create_post\n      _post2 = Fabricate(:post, topic: post1.topic, deleted_at: 1.day.ago)\n      _post3 = Fabricate(:post, topic: post1.topic, user_deleted: true)\n      _post4 = Fabricate(:post, topic: post1.topic, hidden: true)\n      _post5 = Fabricate(:post, topic: post1.topic, post_type: Post.types[:moderator_action])\n      _post6 = Fabricate(:post, topic: post1.topic, post_type: Post.types[:small_action])\n      _post7 = Fabricate(:post, topic: post1.topic, post_type: Post.types[:whisper])\n      last = Fabricate(:post, topic: post1.topic)\n\n      post1.user.user_option.email_previous_replies = UserOption.previous_replies_type[:always]\n\n      # default is only post #1\n      expect(UserNotifications.get_context_posts(last, nil, post1.user).count).to eq(1)\n      # staff members can also see the whisper\n      moderator = build(:moderator)\n      moderator.user_option = UserOption.new\n      moderator.user_option.email_previous_replies = UserOption.previous_replies_type[:always]\n      tu = TopicUser.new(topic: post1.topic, user: moderator)\n      expect(UserNotifications.get_context_posts(last, tu, tu.user).count).to eq(2)\n    end\n\n    it \"allows users to control context\" do\n      post1 = create_post\n      _post2 = Fabricate(:post, topic: post1.topic)\n      post3 = Fabricate(:post, topic: post1.topic)\n\n      user = Fabricate(:user)\n      TopicUser.change(user.id, post1.topic_id, last_emailed_post_number: 1)\n      topic_user = TopicUser.find_by(user_id: user.id, topic_id: post1.topic_id)\n      # to avoid reloads after update_columns\n      user = topic_user.user\n      user.user_option.update_columns(email_previous_replies: UserOption.previous_replies_type[:unless_emailed])\n\n      expect(UserNotifications.get_context_posts(post3, topic_user, user).count).to eq(1)\n\n      user.user_option.update_columns(email_previous_replies: UserOption.previous_replies_type[:never])\n      expect(UserNotifications.get_context_posts(post3, topic_user, user).count).to eq(0)\n\n      user.user_option.update_columns(email_previous_replies: UserOption.previous_replies_type[:always])\n      expect(UserNotifications.get_context_posts(post3, topic_user, user).count).to eq(2)\n\n      SiteSetting.private_email = true\n      expect(UserNotifications.get_context_posts(post3, topic_user, user).count).to eq(0)\n    end\n  end\n\n  describe \".signup\" do\n    subject { UserNotifications.signup(user) }\n\n    it \"works\" do\n      expect(subject.to).to eq([user.email])\n      expect(subject.subject).to be_present\n      expect(subject.from).to eq([SiteSetting.notification_email])\n      expect(subject.body).to be_present\n    end\n  end\n\n  describe \".forgot_password\" do\n    subject { UserNotifications.forgot_password(user) }\n\n    it \"works\" do\n      expect(subject.to).to eq([user.email])\n      expect(subject.subject).to be_present\n      expect(subject.from).to eq([SiteSetting.notification_email])\n      expect(subject.body).to be_present\n    end\n  end\n\n  describe '.post_approved' do\n    fab!(:post) { Fabricate(:post) }\n\n    it 'works' do\n      subject = UserNotifications.post_approved(user, { notification_data_hash: { post_url: post.url } })\n\n      expect(subject.to).to eq([user.email])\n      expect(subject.subject).to be_present\n      expect(subject.from).to eq([SiteSetting.notification_email])\n      expect(subject.body).to be_present\n    end\n  end\n\n  describe \".confirm_new_email\" do\n    let(:opts) do\n      { requested_by_admin: requested_by_admin, email_token: token }\n    end\n    let(:token) { \"test123\" }\n\n    context \"when requested by admin\" do\n      let(:requested_by_admin) { true }\n\n      it \"uses the requested by admin template\" do\n        expect(UserNotifications.confirm_new_email(user, opts).body).to include(\n          \"This email change was requested by a site admin.\"\n        )\n      end\n    end\n\n    context \"when not requested by admin\" do\n      let(:requested_by_admin) { false }\n\n      it \"uses the normal template\" do\n        expect(UserNotifications.confirm_new_email(user, opts).body).not_to include(\n          \"This email change was requested by a site admin.\"\n        )\n      end\n    end\n  end\n\n  describe '.email_login' do\n    let(:email_token) { Fabricate(:email_token, user: user, scope: EmailToken.scopes[:email_login]).token }\n    subject { UserNotifications.email_login(user, email_token: email_token) }\n\n    it \"generates the right email\" do\n      expect(subject.to).to eq([user.email])\n      expect(subject.from).to eq([SiteSetting.notification_email])\n\n      expect(subject.subject).to eq(I18n.t(\n        'user_notifications.email_login.subject_template',\n        email_prefix: SiteSetting.title\n      ))\n\n      expect(subject.body.to_s).to match(I18n.t(\n        'user_notifications.email_login.text_body_template',\n        site_name: SiteSetting.title,\n        base_url: Discourse.base_url,\n        email_token: email_token\n      ))\n    end\n  end\n\n  describe '.digest' do\n    subject { UserNotifications.digest(user) }\n\n    after do\n      Discourse.redis.keys('summary-new-users:*').each { |key| Discourse.redis.del(key) }\n    end\n\n    context \"without new topics\" do\n      it \"doesn't send the email\" do\n        expect(subject.to).to be_blank\n      end\n\n    end\n\n    context \"with topics only from new users\" do\n      let!(:new_today) { Fabricate(:topic, user: Fabricate(:user, trust_level: TrustLevel[0], created_at: 10.minutes.ago), title: \"Hey everyone look at me\") }\n      let!(:new_yesterday) { Fabricate(:topic, user: Fabricate(:user, trust_level: TrustLevel[0], created_at: 25.hours.ago), created_at: 25.hours.ago, title: \"This topic is of interest to you\") }\n\n      it \"returns topics from new users if they're more than 24 hours old\" do\n        expect(subject.to).to eq([user.email])\n        html = subject.html_part.body.to_s\n        expect(html).to include(new_yesterday.title)\n        expect(html).to_not include(new_today.title)\n      end\n    end\n\n    context \"with new topics\" do\n      let!(:popular_topic) { Fabricate(:topic, user: Fabricate(:coding_horror), created_at: 1.hour.ago) }\n\n      it \"works\" do\n        expect(subject.to).to eq([user.email])\n        expect(subject.subject).to be_present\n        expect(subject.from).to eq([SiteSetting.notification_email])\n        expect(subject.html_part.body.to_s).to be_present\n        expect(subject.text_part.body.to_s).to be_present\n        expect(subject.header[\"List-Unsubscribe\"].to_s).to match(/\\/email\\/unsubscribe\\/\\h{64}/)\n        expect(subject.html_part.body.to_s).to include('New Users')\n      end\n\n      it \"doesn't include new user count if digest_after_minutes is low\" do\n        user.user_option.digest_after_minutes = 60\n        expect(subject.html_part.body.to_s).to_not include('New Users')\n      end\n\n      it \"works with min_date string\" do\n        digest = UserNotifications.digest(user, since: 1.month.ago.to_date.to_s)\n        expect(digest.html_part.body.to_s).to be_present\n        expect(digest.text_part.body.to_s).to be_present\n        expect(digest.html_part.body.to_s).to include('New Users')\n      end\n\n      it \"includes email_prefix in email subject instead of site title\" do\n        SiteSetting.email_prefix = \"Try Discourse\"\n        SiteSetting.title = \"Discourse Meta\"\n\n        expect(subject.subject).to match(/Try Discourse/)\n        expect(subject.subject).not_to match(/Discourse Meta/)\n      end\n\n      it \"excludes deleted topics and their posts\" do\n        deleted = Fabricate(:topic, user: Fabricate(:user), title: \"Delete this topic plz\", created_at: 1.hour.ago)\n        post = Fabricate(:post, topic: deleted, score: 100.0, post_number: 2, raw: \"Your wish is my command\", created_at: 1.hour.ago)\n        deleted.trash!\n        html = subject.html_part.body.to_s\n        expect(html).to_not include deleted.title\n        expect(html).to_not include post.raw\n      end\n\n      it \"excludes shared drafts\" do\n        cat = Fabricate(:category)\n        SiteSetting.shared_drafts_category = cat.id\n        topic = Fabricate(:topic, title: \"This is a draft\", category_id: cat.id, created_at: 1.hour.ago)\n        post = Fabricate(\n          :post,\n          topic: topic,\n          score: 100.0,\n          post_number: 2,\n          raw: \"secret draft content\",\n          created_at: 1.hour.ago\n        )\n        html = subject.html_part.body.to_s\n        expect(html).to_not include topic.title\n        expect(html).to_not include post.raw\n      end\n\n      it \"excludes whispers and other post types that don't belong\" do\n        t = Fabricate(:topic, user: Fabricate(:user), title: \"Who likes the same stuff I like?\", created_at: 1.hour.ago)\n        whisper = Fabricate(:post, topic: t, score: 100.0, post_number: 2, raw: \"You like weird stuff\", post_type: Post.types[:whisper], created_at: 1.hour.ago)\n        mod_action = Fabricate(:post, topic: t, score: 100.0, post_number: 3, raw: \"This topic unlisted\", post_type: Post.types[:moderator_action], created_at: 1.hour.ago)\n        small_action = Fabricate(:post, topic: t, score: 100.0, post_number: 4, raw: \"A small action\", post_type: Post.types[:small_action], created_at: 1.hour.ago)\n        html = subject.html_part.body.to_s\n        expect(html).to_not include whisper.raw\n        expect(html).to_not include mod_action.raw\n        expect(html).to_not include small_action.raw\n      end\n\n      it \"excludes deleted and hidden posts\" do\n        t = Fabricate(:topic, user: Fabricate(:user), title: \"Post objectionable stuff here\", created_at: 1.hour.ago)\n        deleted = Fabricate(:post, topic: t, score: 100.0, post_number: 2, raw: \"This post is uncalled for\", deleted_at: 5.minutes.ago, created_at: 1.hour.ago)\n        hidden = Fabricate(:post, topic: t, score: 100.0, post_number: 3, raw: \"Try to find this post\", hidden: true, hidden_at: 5.minutes.ago, hidden_reason_id: Post.hidden_reasons[:flagged_by_tl3_user], created_at: 1.hour.ago)\n        user_deleted = Fabricate(:post, topic: t, score: 100.0, post_number: 4, raw: \"I regret this post\", user_deleted: true, created_at: 1.hour.ago)\n        html = subject.html_part.body.to_s\n        expect(html).to_not include deleted.raw\n        expect(html).to_not include hidden.raw\n        expect(html).to_not include user_deleted.raw\n      end\n\n      it \"excludes posts that are newer than editing grace period\" do\n        SiteSetting.editing_grace_period = 5.minutes\n        too_new = Fabricate(:topic, user: Fabricate(:user), title: \"Oops I need to edit this\", created_at: 1.minute.ago)\n        _too_new_post = Fabricate(:post, user: too_new.user, topic: too_new, score: 100.0, post_number: 1, created_at: 1.minute.ago)\n        html = subject.html_part.body.to_s\n        expect(html).to_not include too_new.title\n      end\n\n      it \"uses theme color\" do\n        cs = Fabricate(:color_scheme, name: 'Fancy', color_scheme_colors: [\n          Fabricate(:color_scheme_color, name: 'header_primary', hex: 'F0F0F0'),\n          Fabricate(:color_scheme_color, name: 'header_background', hex: '1E1E1E')\n        ])\n        theme = Fabricate(:theme,\n                          user_selectable: true,\n                          user: Fabricate(:admin),\n                          color_scheme_id: cs.id\n        )\n\n        theme.set_default!\n\n        html = subject.html_part.body.to_s\n        expect(html).to include 'F0F0F0'\n        expect(html).to include '1E1E1E'\n      end\n\n      it \"supports subfolder\" do\n        set_subfolder \"/forum\"\n        html = subject.html_part.body.to_s\n        text = subject.text_part.body.to_s\n        expect(html).to be_present\n        expect(text).to be_present\n        expect(html).to_not include(\"/forum/forum\")\n        expect(text).to_not include(\"/forum/forum\")\n        expect(subject.header[\"List-Unsubscribe\"].to_s).to match(/http:\\/\\/test.localhost\\/forum\\/email\\/unsubscribe\\/\\h{64}/)\n\n        topic_url = \"http://test.localhost/forum/t/#{popular_topic.slug}/#{popular_topic.id}\"\n        expect(html).to include(topic_url)\n        expect(text).to include(topic_url)\n      end\n\n      it \"applies lang/xml:lang html attributes\" do\n        SiteSetting.default_locale = \"pl_PL\"\n        html = subject.html_part.to_s\n\n        expect(html).to match(' lang=\"pl-PL\"')\n        expect(html).to match(' xml:lang=\"pl-PL\"')\n      end\n    end\n  end\n\n  describe '.user_replied' do\n    let(:response_by_user) { Fabricate(:user, name: \"John Doe\") }\n    let(:category) { Fabricate(:category, name: 'India') }\n    let(:tag1) { Fabricate(:tag, name: 'Taggo') }\n    let(:tag2) { Fabricate(:tag, name: 'Taggie') }\n    let(:topic) { Fabricate(:topic, category: category, tags: [tag1, tag2], title: \"Super cool topic\") }\n    let(:post) { Fabricate(:post, topic: topic, raw: 'This is My super duper cool topic') }\n    let(:response) { Fabricate(:basic_reply, topic: post.topic, user: response_by_user) }\n    let(:user) { Fabricate(:user) }\n    let(:notification) { Fabricate(:replied_notification, user: user, post: response) }\n\n    it 'generates a correct email' do\n\n      SiteSetting.default_email_in_reply_to = true\n\n      # Fabricator is not fabricating this ...\n      SiteSetting.email_subject = \"[%{site_name}] %{optional_pm}%{optional_cat}%{optional_tags}%{topic_title}\"\n      SiteSetting.enable_names = true\n      SiteSetting.display_name_on_posts = true\n      mail = UserNotifications.user_replied(\n        user,\n        post: response,\n        notification_type: notification.notification_type,\n        notification_data_hash: notification.data_hash\n      )\n\n      # from should include full user name\n      expect(mail[:from].display_names).to eql(['John Doe via Discourse'])\n\n      # subject should include category name\n      expect(mail.subject).to match(/India/)\n\n      # subject should include tag names\n      expect(mail.subject).to match(/Taggo/)\n      expect(mail.subject).to match(/Taggie/)\n\n      mail_html = mail.html_part.body.to_s\n\n      expect(mail_html.scan(/My super duper cool topic/).count).to eq(1)\n      expect(mail_html.scan(/In Reply To/).count).to eq(1)\n\n      # 2 \"visit topic\" link\n      expect(mail_html.scan(/Visit Topic/).count).to eq(2)\n\n      # 2 respond to links cause we have 1 context post\n      expect(mail_html.scan(/to respond/).count).to eq(2)\n\n      # 1 unsubscribe\n      expect(mail_html.scan(/To unsubscribe/).count).to eq(1)\n\n      # side effect, topic user is updated with post number\n      tu = TopicUser.get(post.topic_id, user)\n      expect(tu.last_emailed_post_number).to eq(response.post_number)\n\n      # no In Reply To if user opts out\n      user.user_option.email_in_reply_to = false\n      mail = UserNotifications.user_replied(\n        user,\n        post: response,\n        notification_type: notification.notification_type,\n        notification_data_hash: notification.data_hash\n      )\n\n      expect(mail.html_part.body.to_s.scan(/In Reply To/).count).to eq(0)\n\n      SiteSetting.enable_names = true\n      SiteSetting.display_name_on_posts = true\n      SiteSetting.prioritize_username_in_ux = false\n\n      response.user.username = \"bobmarley\"\n      response.user.name = \"Bob Marley\"\n      response.user.save\n\n      mail = UserNotifications.user_replied(\n        user,\n        post: response,\n        notification_type: notification.notification_type,\n        notification_data_hash: notification.data_hash\n      )\n\n      mail_html = mail.html_part.body.to_s\n      expect(mail_html.scan(/>Bob Marley/).count).to eq(1)\n      expect(mail_html.scan(/>bobmarley/).count).to eq(0)\n\n      SiteSetting.prioritize_username_in_ux = true\n\n      mail = UserNotifications.user_replied(\n        user,\n        post: response,\n        notification_type: notification.notification_type,\n        notification_data_hash: notification.data_hash\n      )\n\n      mail_html = mail.html_part.body.to_s\n      expect(mail_html.scan(/>Bob Marley/).count).to eq(0)\n      expect(mail_html.scan(/>bobmarley/).count).to eq(1)\n    end\n\n    it \"doesn't include details when private_email is enabled\" do\n      SiteSetting.private_email = true\n      mail = UserNotifications.user_replied(\n        user,\n        post: response,\n        notification_type: notification.notification_type,\n        notification_data_hash: notification.data_hash\n      )\n\n      expect(mail.html_part.body.to_s).to_not include(response.raw)\n      expect(mail.html_part.body.to_s).to_not include(topic.url)\n      expect(mail.text_part.to_s).to_not include(response.raw)\n      expect(mail.text_part.to_s).to_not include(topic.url)\n    end\n\n    it \"includes excerpt when post_excerpts_in_emails is enabled\" do\n      paragraphs = [\n        \"This is the first paragraph, but you should read more.\",\n        \"And here is its friend, the second paragraph.\"\n      ]\n      SiteSetting.post_excerpts_in_emails = true\n      SiteSetting.post_excerpt_maxlength = paragraphs.first.length\n      response.update!(raw: paragraphs.join(\"\\n\\n\"))\n      mail = UserNotifications.user_replied(\n        user,\n        post: response,\n        notification_type: notification.notification_type,\n        notification_data_hash: notification.data_hash\n      )\n      mail_html = mail.html_part.body.to_s\n      expect(mail_html.scan(/#{paragraphs[0]}/).count).to eq(1)\n      expect(mail_html.scan(/#{paragraphs[1]}/).count).to eq(0)\n    end\n  end\n\n  describe '.user_posted' do\n    let(:response_by_user) { Fabricate(:user, name: \"John Doe\", username: \"john\") }\n    let(:topic) { Fabricate(:topic, title: \"Super cool topic\") }\n    let(:post) { Fabricate(:post, topic: topic) }\n    let(:response) { Fabricate(:post, topic: topic, user: response_by_user) }\n    let(:user) { Fabricate(:user) }\n    let(:notification) { Fabricate(:posted_notification, user: user, post: response) }\n\n    it 'generates a correct email' do\n      SiteSetting.enable_names = false\n      mail = UserNotifications.user_posted(\n        user,\n        post: response,\n        notification_type: notification.notification_type,\n        notification_data_hash: notification.data_hash\n      )\n\n      # from should not include full user name if \"show user full names\" is disabled\n      expect(mail[:from].display_names).to_not eql(['John Doe'])\n\n      # from should include username if \"show user full names\" is disabled\n      expect(mail[:from].display_names).to eql(['john via Discourse'])\n\n      # subject should not include category name\n      expect(mail.subject).not_to match(/Uncategorized/)\n\n      # 1 respond to links as no context by default\n      expect(mail.html_part.body.to_s.scan(/to respond/).count).to eq(1)\n\n      # 1 unsubscribe link\n      expect(mail.html_part.body.to_s.scan(/To unsubscribe/).count).to eq(1)\n\n      # side effect, topic user is updated with post number\n      tu = TopicUser.get(post.topic_id, user)\n      expect(tu.last_emailed_post_number).to eq(response.post_number)\n    end\n\n    it \"doesn't include details when private_email is enabled\" do\n      SiteSetting.private_email = true\n      mail = UserNotifications.user_posted(\n        user,\n        post: response,\n        notification_type: notification.notification_type,\n        notification_data_hash: notification.data_hash\n      )\n\n      expect(mail.html_part.body.to_s).to_not include(response.raw)\n      expect(mail.text_part.to_s).to_not include(response.raw)\n    end\n\n    it \"uses the original subject for staged users\" do\n      incoming_email = Fabricate(\n        :incoming_email,\n        subject: \"Original Subject\",\n        post: post,\n        topic: post.topic,\n        user: user\n      )\n\n      mail = UserNotifications.user_posted(\n        user,\n        post: response,\n        notification_type: notification.notification_type,\n        notification_data_hash: notification.data_hash\n      )\n      expect(mail.subject).to match(/Super cool topic/)\n\n      user.update!(staged: true)\n      mail = UserNotifications.user_posted(\n        user,\n        post: response,\n        notification_type: notification.notification_type,\n        notification_data_hash: notification.data_hash\n      )\n      expect(mail.subject).to eq(\"Re: Original Subject\")\n\n      another_post = Fabricate(:post, topic: topic)\n      incoming_email.update!(post_id: another_post.id)\n\n      mail = UserNotifications.user_private_message(\n        user,\n        post: response,\n        notification_type: notification.notification_type,\n        notification_data_hash: notification.data_hash\n      )\n      expect(mail.subject).to match(/Super cool topic/)\n    end\n  end\n\n  describe '.user_private_message' do\n    let(:response_by_user) { Fabricate(:user, name: \"\", username: \"john\") }\n    let(:topic) { Fabricate(:private_message_topic, title: \"Super cool topic\") }\n    let(:post) { Fabricate(:post, topic: topic) }\n    let(:response) { Fabricate(:post, topic: topic, user: response_by_user) }\n    let(:user) { Fabricate(:user) }\n    let(:notification) { Fabricate(:private_message_notification, user: user, post: response) }\n\n    it 'generates a correct email' do\n      SiteSetting.enable_names = true\n      mail = UserNotifications.user_private_message(\n        user,\n        post: response,\n        notification_type: notification.notification_type,\n        notification_data_hash: notification.data_hash\n      )\n\n      # from should include username if full user name is not provided\n      expect(mail[:from].display_names).to eql(['john via Discourse'])\n\n      # subject should include \"[PM]\"\n      expect(mail.subject).to include(\"[PM] \")\n\n      # 1 \"visit message\" link\n      expect(mail.html_part.body.to_s.scan(/Visit Message/).count).to eq(1)\n\n      # 1 respond to link\n      expect(mail.html_part.body.to_s.scan(/to respond/).count).to eq(1)\n\n      # 1 unsubscribe link\n      expect(mail.html_part.body.to_s.scan(/To unsubscribe/).count).to eq(1)\n\n      # side effect, topic user is updated with post number\n      tu = TopicUser.get(topic.id, user)\n      expect(tu.last_emailed_post_number).to eq(response.post_number)\n    end\n\n    it \"doesn't include details when private_email is enabled\" do\n      SiteSetting.private_email = true\n      mail = UserNotifications.user_private_message(\n        user,\n        post: response,\n        notification_type: notification.notification_type,\n        notification_data_hash: notification.data_hash\n      )\n\n      expect(mail.html_part.body.to_s).to_not include(response.raw)\n      expect(mail.html_part.body.to_s).to_not include(topic.url)\n      expect(mail.text_part.to_s).to_not include(response.raw)\n      expect(mail.text_part.to_s).to_not include(topic.url)\n    end\n\n    it \"doesn't include group name in subject\" do\n      group = Fabricate(:group)\n      topic.allowed_groups = [group]\n      mail = UserNotifications.user_private_message(\n        user,\n        post: response,\n        notification_type: notification.notification_type,\n        notification_data_hash: notification.data_hash\n      )\n\n      expect(mail.subject).to include(\"[PM] \")\n    end\n\n    it \"includes a list of participants (except for the destination user), groups first with member lists\" do\n      group1 = Fabricate(:group, name: \"group1\")\n      group2 = Fabricate(:group, name: \"group2\")\n\n      user1 = Fabricate(:user, username: \"one\", groups: [group1, group2])\n      user2 = Fabricate(:user, username: \"two\", groups: [group1], staged: true)\n\n      topic.allowed_users = [user, user1, user2]\n      topic.allowed_groups = [group1, group2]\n\n      mail = UserNotifications.user_private_message(\n        user,\n        post: response,\n        notification_type: notification.notification_type,\n        notification_data_hash: notification.data_hash\n      )\n\n      expect(mail.body).to include(\"[group1 (2)](http://test.localhost/g/group1), [group2 (1)](http://test.localhost/g/group2), [one](http://test.localhost/u/one), [two](http://test.localhost/u/two)\")\n    end\n\n    context \"when SiteSetting.group_name_in_subject is true\" do\n      before do\n        SiteSetting.group_in_subject = true\n      end\n\n      let(:group) { Fabricate(:group, name: \"my_group\") }\n      let(:mail) do\n        UserNotifications.user_private_message(\n          user,\n          post: response,\n          notification_type: notification.notification_type,\n          notification_data_hash: notification.data_hash\n        )\n      end\n\n      shared_examples \"includes first group name\" do\n        it \"includes first group name in subject\" do\n          expect(mail.subject).to include(\"[my_group] \")\n        end\n\n        context \"when first group has full name\" do\n          it \"includes full name in subject\" do\n            group.full_name = \"My Group\"\n            group.save\n            expect(mail.subject).to include(\"[My Group] \")\n          end\n        end\n      end\n\n      context \"with one group in pm\" do\n        before do\n          topic.allowed_groups = [group]\n        end\n\n        include_examples \"includes first group name\"\n      end\n\n      context \"with multiple groups in pm\" do\n        let(:group2) { Fabricate(:group) }\n\n        before do\n          topic.allowed_groups = [group, group2]\n        end\n\n        include_examples \"includes first group name\"\n      end\n\n      context \"with no groups in pm\" do\n        it \"includes %{optional_pm} in subject\" do\n          expect(mail.subject).to include(\"[PM] \")\n        end\n      end\n    end\n\n    it \"uses the original subject for staged users when topic was started via email\" do\n      incoming_email = Fabricate(\n        :incoming_email,\n        subject: \"Original Subject\",\n        post: post,\n        topic: topic,\n        user: user\n      )\n\n      mail = UserNotifications.user_private_message(\n        user,\n        post: response,\n        notification_type: notification.notification_type,\n        notification_data_hash: notification.data_hash\n      )\n      expect(mail.subject).to match(/Super cool topic/)\n\n      user.update!(staged: true)\n      mail = UserNotifications.user_private_message(\n        user,\n        post: response,\n        notification_type: notification.notification_type,\n        notification_data_hash: notification.data_hash\n      )\n      expect(mail.subject).to eq(\"Re: Original Subject\")\n\n      another_post = Fabricate(:post, topic: topic)\n      incoming_email.update!(post_id: another_post.id)\n\n      mail = UserNotifications.user_private_message(\n        user,\n        post: response,\n        notification_type: notification.notification_type,\n        notification_data_hash: notification.data_hash\n      )\n      expect(mail.subject).to match(/Super cool topic/)\n    end\n  end\n\n  it 'adds a warning when mail limit is reached' do\n    SiteSetting.max_emails_per_day_per_user = 2\n    user = Fabricate(:user)\n\n    user.email_logs.create!(\n      email_type: 'blah',\n      to_address: user.email,\n      user_id: user.id\n    )\n\n    post = Fabricate(:post)\n    reply = Fabricate(:post, topic_id: post.topic_id)\n\n    notification = Fabricate(\n      :notification,\n      topic_id: post.topic_id,\n      post_number: reply.post_number,\n      user: post.user,\n      data: { original_username: 'bob' }.to_json\n    )\n\n    mail = UserNotifications.user_replied(\n      user,\n      post: reply,\n      notification_type: notification.notification_type,\n      notification_data_hash: notification.data_hash\n    )\n\n    # WARNING: you reached the limit of 100 email notifications per day. Further emails will be suppressed.\n    # Consider watching less topics or disabling mailing list mode.\n    expect(mail.html_part.body.to_s).to match(I18n.t(\"user_notifications.reached_limit\", count: 2))\n    expect(mail.body.to_s).to match(I18n.t(\"user_notifications.reached_limit\", count: 2))\n  end\n\n  def expects_build_with(condition)\n    UserNotifications.any_instance.expects(:build_email).with(user.email, condition)\n    mailer = UserNotifications.public_send(\n      mail_type, user,\n      notification_type: Notification.types[notification.notification_type],\n      notification_data_hash: notification.data_hash,\n      post: notification.post\n    )\n\n    mailer.message\n  end\n\n  shared_examples \"supports reply by email\" do\n    context \"with reply_by_email\" do\n      it \"should have allow_reply_by_email set when that feature is enabled\" do\n        expects_build_with(has_entry(:allow_reply_by_email, true))\n      end\n    end\n  end\n\n  shared_examples \"no reply by email\" do\n    context \"with reply_by_email\" do\n      it \"doesn't support reply by email\" do\n        expects_build_with(Not(has_entry(:allow_reply_by_email, true)))\n      end\n    end\n  end\n\n  shared_examples \"respect for private_email\" do\n    context \"with private_email\" do\n      it \"doesn't support reply by email\" do\n        SiteSetting.private_email = true\n\n        mailer = UserNotifications.public_send(\n          mail_type,\n          user,\n          notification_type: Notification.types[notification.notification_type],\n          notification_data_hash: notification.data_hash,\n          post: notification.post\n        )\n        message = mailer.message\n\n        topic = notification.post.topic\n        expect(message.html_part.body.to_s).not_to include(topic.title)\n        expect(message.html_part.body.to_s).not_to include(topic.slug)\n        expect(message.text_part.body.to_s).not_to include(topic.title)\n        expect(message.text_part.body.to_s).not_to include(topic.slug)\n      end\n    end\n  end\n\n  # The parts of emails that are derived from templates are translated\n  shared_examples \"sets user locale\" do\n    context \"with set locale for translating templates\" do\n      it \"sets the locale\" do\n        expects_build_with(has_key(:locale))\n      end\n    end\n  end\n\n  shared_examples \"notification email building\" do\n    let(:post) { Fabricate(:post, user: user) }\n    let(:mail_type) { \"user_#{notification_type}\" }\n    let(:mail_template) { \"user_notifications.#{mail_type}\" }\n    let(:username) { \"walterwhite\" }\n    let(:notification) do\n      Fabricate(:notification,\n                user: user,\n                topic: post.topic,\n                notification_type: Notification.types[notification_type],\n                post_number: post.post_number,\n                data: { original_username: username }.to_json)\n    end\n\n    describe 'email building' do\n      it \"has a username\" do\n        expects_build_with(has_entry(:username, username))\n      end\n\n      it \"has a url\" do\n        expects_build_with(has_key(:url))\n      end\n\n      it \"has a template\" do\n        expects_build_with(has_entry(:template, mail_template))\n      end\n\n      it \"overrides the html part\" do\n        expects_build_with(has_key(:html_override))\n      end\n\n      it \"has a message\" do\n        expects_build_with(has_key(:message))\n      end\n\n      it \"has a context\" do\n        expects_build_with(has_key(:context))\n      end\n\n      it \"has an unsubscribe link\" do\n        expects_build_with(has_key(:add_unsubscribe_link))\n      end\n\n      it \"has an post_id\" do\n        expects_build_with(has_key(:post_id))\n      end\n\n      it \"has an topic_id\" do\n        expects_build_with(has_key(:topic_id))\n      end\n\n      it \"should have user name as from_alias\" do\n        SiteSetting.enable_names = true\n        SiteSetting.display_name_on_posts = true\n        expects_build_with(has_entry(:from_alias, \"#{user.name} via Discourse\"))\n      end\n\n      it \"should not have user name as from_alias if display_name_on_posts is disabled\" do\n        SiteSetting.enable_names = false\n        SiteSetting.display_name_on_posts = false\n        expects_build_with(has_entry(:from_alias, \"walterwhite via Discourse\"))\n      end\n\n      it \"should explain how to respond\" do\n        expects_build_with(Not(has_entry(:include_respond_instructions, false)))\n      end\n\n      it \"should not explain how to respond if the user is suspended\" do\n        User.any_instance.stubs(:suspended?).returns(true)\n        expects_build_with(has_entry(:include_respond_instructions, false))\n      end\n\n      context \"when customized\" do\n        let(:custom_body) do\n          body = +<<~BODY\n            You are now officially notified.\n            %{header_instructions}\n            %{message} %{respond_instructions}\n            %{topic_title_url_encoded}\n            %{site_title_url_encoded}\n          BODY\n\n          body << \"%{context}\" if notification_type != :invited_to_topic\n          body\n        end\n\n        before do\n          TranslationOverride.upsert!(\n            SiteSetting.default_locale,\n            \"#{mail_template}.text_body_template\",\n            custom_body\n          )\n        end\n\n        it \"shouldn't use the default html_override\" do\n          expects_build_with(Not(has_key(:html_override)))\n        end\n      end\n    end\n  end\n\n  describe \"user mentioned email\" do\n    include_examples \"notification email building\" do\n      let(:notification_type) { :mentioned }\n      include_examples \"respect for private_email\"\n      include_examples \"supports reply by email\"\n      include_examples \"sets user locale\"\n    end\n  end\n\n  describe \"group mentioned email\" do\n    include_examples \"notification email building\" do\n      let(:notification_type) { :group_mentioned }\n      let(:post) { Fabricate(:private_message_post) }\n      let(:user) { post.user }\n      let(:mail_type) { \"group_mentioned\" }\n      let(:mail_template) { \"user_notifications.user_#{notification_type}_pm\" }\n\n      include_examples \"respect for private_email\"\n      include_examples \"supports reply by email\"\n      include_examples \"sets user locale\"\n    end\n  end\n\n  describe \"user replied\" do\n    include_examples \"notification email building\" do\n      let(:notification_type) { :replied }\n      include_examples \"respect for private_email\"\n      include_examples \"supports reply by email\"\n      include_examples \"sets user locale\"\n    end\n  end\n\n  describe \"user quoted\" do\n    include_examples \"notification email building\" do\n      let(:notification_type) { :quoted }\n      include_examples \"respect for private_email\"\n      include_examples \"supports reply by email\"\n      include_examples \"sets user locale\"\n    end\n  end\n\n  describe \"user posted\" do\n    include_examples \"notification email building\" do\n      let(:notification_type) { :posted }\n      include_examples \"respect for private_email\"\n      include_examples \"supports reply by email\"\n      include_examples \"sets user locale\"\n    end\n  end\n\n  describe \"user invited to a private message\" do\n    include_examples \"notification email building\" do\n      let(:notification_type) { :invited_to_private_message }\n      let(:post) { Fabricate(:private_message_post) }\n      let(:user) { post.user }\n      let(:mail_template) { \"user_notifications.user_#{notification_type}_pm\" }\n\n      include_examples \"respect for private_email\"\n      include_examples \"no reply by email\"\n      include_examples \"sets user locale\"\n    end\n  end\n\n  describe \"group invited to a private message\" do\n    include_examples \"notification email building\" do\n      let(:notification_type) { :invited_to_private_message }\n      let(:post) { Fabricate(:private_message_post) }\n      let(:user) { post.user }\n      let(:group) { Fabricate(:group) }\n      let(:mail_template) { \"user_notifications.user_#{notification_type}_pm_group\" }\n\n      before do\n        notification.data_hash[:group_id] = group.id\n        notification.save!\n      end\n\n      it \"should include the group name\" do\n        expects_build_with(has_entry(:group_name, group.name))\n      end\n\n      include_examples \"respect for private_email\"\n      include_examples \"no reply by email\"\n      include_examples \"sets user locale\"\n    end\n  end\n\n  describe \"user invited to a topic\" do\n    let(:notification_type) { :invited_to_topic }\n\n    include_examples \"notification email building\" do\n      include_examples \"respect for private_email\"\n      include_examples \"no reply by email\"\n      include_examples \"sets user locale\"\n    end\n\n    context \"when showing the right name in 'From' field\" do\n      let(:inviter) { Fabricate(:user) }\n      let(:invitee) { Fabricate(:user) }\n\n      let(:notification) do\n        Fabricate(:notification,\n          notification_type: Notification.types[:invited_to_topic],\n          user: invitee,\n          topic: post.topic,\n          post_number: post.post_number,\n          data: {\n            topic_title: post.topic.title,\n            display_username: inviter.username,\n            original_user_id: inviter.id,\n            original_username: inviter.username\n          }.to_json\n        )\n      end\n\n      let(:mailer) do\n        UserNotifications.public_send(\n          \"user_invited_to_topic\",\n          invitee,\n          notification_type: Notification.types[notification.notification_type],\n          notification_data_hash: notification.data_hash,\n          post: notification.post\n        )\n      end\n\n      it \"sends the email as the inviter\" do\n        SiteSetting.enable_names = false\n\n        expect(mailer.message.to_s).to include(\"From: #{inviter.username} via #{SiteSetting.title} <#{SiteSetting.notification_email}>\")\n      end\n\n      it \"sends the email as the inviter\" do\n        expect(mailer.message.to_s).to include(\"From: #{inviter.name} via #{SiteSetting.title} <#{SiteSetting.notification_email}>\")\n      end\n    end\n  end\n\n  describe \"watching first post\" do\n    include_examples \"notification email building\" do\n      let(:notification_type) { :invited_to_topic }\n      include_examples \"respect for private_email\"\n      include_examples \"no reply by email\"\n      include_examples \"sets user locale\"\n    end\n  end\n\n  # notification emails derived from templates are translated into the user's locale\n  shared_context \"with notification derived from template\" do\n    let(:user) { Fabricate(:user, locale: locale) }\n    let(:mail_type) { mail_type }\n    let(:notification) { Fabricate(:notification, user: user) }\n  end\n\n  describe \"notifications from template\" do\n    context \"when user locale is allowed\" do\n      before do\n        SiteSetting.allow_user_locale = true\n      end\n\n      %w(signup signup_after_approval confirm_old_email notify_old_email confirm_new_email\n         forgot_password admin_login account_created).each do |mail_type|\n        include_examples \"with notification derived from template\" do\n          let(:locale) { \"fr\" }\n          let(:mail_type) { mail_type }\n          it \"sets the locale\" do\n            expects_build_with(has_entry(:locale, \"fr\"))\n          end\n        end\n      end\n    end\n\n    context \"when user locale is not allowed\" do\n      before do\n        SiteSetting.allow_user_locale = false\n      end\n\n      %w(signup signup_after_approval notify_old_email confirm_old_email confirm_new_email\n         forgot_password admin_login account_created).each do |mail_type|\n        include_examples \"with notification derived from template\" do\n          let(:locale) { \"fr\" }\n          let(:mail_type) { mail_type }\n          it \"sets the locale\" do\n            expects_build_with(has_entry(:locale, \"en\"))\n          end\n        end\n      end\n    end\n\n  end\n\n  describe \"#participants\" do\n    fab!(:group1) { Fabricate(:group, name: \"group1\") }\n    fab!(:group2) { Fabricate(:group, name: \"group2\") }\n    fab!(:group3) { Fabricate(:group, name: \"group3\") }\n    fab!(:user1) { Fabricate(:user, username: \"one\", name: nil, groups: [group1, group2]) }\n    fab!(:user2) { Fabricate(:user, username: \"two\", name: nil, groups: [group1]) }\n    fab!(:user3) { Fabricate(:user, username: \"three\", name: nil, groups: [group3]) }\n    fab!(:user4) { Fabricate(:user, username: \"four\", name: nil, groups: [group1, group3]) }\n    fab!(:admin) { Fabricate(:admin, username: \"admin\", name: nil) }\n\n    fab!(:topic) do\n      t = Fabricate(:private_message_topic, title: \"Super cool topic\")\n      t.allowed_users = [user1, user2, user3, user4, admin]\n      t.allowed_groups = [group1]\n      t\n    end\n    fab!(:posts) do\n      [\n        Fabricate(:post, topic: topic, post_number: 1, user: user2),\n        Fabricate(:post, topic: topic, post_number: 2, user: user1),\n        Fabricate(:post, topic: topic, post_number: 3, user: user2),\n        Fabricate(:small_action, topic: topic, post_number: 4, user: admin),\n        Fabricate(:post, topic: topic, post_number: 5, user: user4),\n        Fabricate(:post, topic: topic, post_number: 6, user: user3),\n        Fabricate(:post, topic: topic, post_number: 7, user: user4)\n      ]\n    end\n\n    it \"returns a list of participants (except for the recipient), groups first, followed by users in order of their last reply\" do\n      expect(UserNotifications.participants(posts.last, user3)).to eq(\"[group1 (3)](http://test.localhost/g/group1), \" \\\n        \"[four](http://test.localhost/u/four), [two](http://test.localhost/u/two), [one](http://test.localhost/u/one), \" \\\n        \"[admin](http://test.localhost/u/admin)\")\n    end\n\n    it \"caps the list according to site setting\" do\n      SiteSetting.max_participant_names = 3\n      list = \"[group1 (3)](http://test.localhost/g/group1), [four](http://test.localhost/u/four), [two](http://test.localhost/u/two)\"\n      expect(UserNotifications.participants(posts.last, user3)).to eq(I18n.t(\"user_notifications.more_pm_participants\", participants: list, count: 2))\n    end\n\n    it \"orders groups by user count\" do\n      SiteSetting.max_participant_names = 3\n      topic.allowed_groups = [group1, group2, group3]\n\n      list = \"[group1 (3)](http://test.localhost/g/group1), [group3 (2)](http://test.localhost/g/group3), [group2 (1)](http://test.localhost/g/group2)\"\n      expect(UserNotifications.participants(posts.last, user3)).to eq(I18n.t(\"user_notifications.more_pm_participants\", participants: list, count: 4))\n    end\n\n    it \"orders users by their last reply and user id\" do\n      expect(UserNotifications.participants(posts[-3], user4)).to eq(\"[group1 (3)](http://test.localhost/g/group1), \" \\\n        \"[two](http://test.localhost/u/two), [one](http://test.localhost/u/one), [three](http://test.localhost/u/three), \" \\\n        \"[admin](http://test.localhost/u/admin)\")\n    end\n\n    it \"prefers full group names when available\" do\n      SiteSetting.max_participant_names = 2\n      topic.allowed_groups = [group1, group2]\n\n      group2.update!(full_name: \"Awesome Group\")\n\n      list = \"[group1 (3)](http://test.localhost/g/group1), [Awesome Group (1)](http://test.localhost/g/group2)\"\n      expect(UserNotifications.participants(posts.last, user3)).to eq(I18n.t(\"user_notifications.more_pm_participants\", participants: list, count: 4))\n    end\n\n    it \"always uses usernames when prioritize_username_in_ux is enabled\" do\n      user4.update!(name: \"James Bond\")\n      user1.update!(name: \"Indiana Jones\")\n\n      SiteSetting.prioritize_username_in_ux = true\n      expect(UserNotifications.participants(posts.last, user3)).to eq(\"[group1 (3)](http://test.localhost/g/group1), \" \\\n        \"[four](http://test.localhost/u/four), [two](http://test.localhost/u/two), [one](http://test.localhost/u/one), \" \\\n        \"[admin](http://test.localhost/u/admin)\")\n\n      SiteSetting.prioritize_username_in_ux = false\n      expect(UserNotifications.participants(posts.last, user3)).to eq(\"[group1 (3)](http://test.localhost/g/group1), \" \\\n        \"[James Bond](http://test.localhost/u/four), [two](http://test.localhost/u/two), [Indiana Jones](http://test.localhost/u/one), \" \\\n        \"[admin](http://test.localhost/u/admin)\")\n    end\n\n    it \"reveals the email address of staged users if enabled\" do\n      user4.update!(staged: true, email: \"james.bond@mi6.invalid\")\n      user1.update!(staged: true, email: \"indiana.jones@example.com\")\n\n      SiteSetting.prioritize_username_in_ux = true\n      expect(UserNotifications.participants(posts.last, user3, reveal_staged_email: true)).to eq( \\\n        \"[group1 (3)](http://test.localhost/g/group1), james.bond@mi6.invalid, [two](http://test.localhost/u/two), \" \\\n        \"indiana.jones@example.com, [admin](http://test.localhost/u/admin)\")\n    end\n\n    it \"does only include human users\" do\n      topic.allowed_users << Discourse.system_user\n\n      expect(UserNotifications.participants(posts.last, user3)).to eq(\"[group1 (3)](http://test.localhost/g/group1), \" \\\n        \"[four](http://test.localhost/u/four), [two](http://test.localhost/u/two), [one](http://test.localhost/u/one), \" \\\n        \"[admin](http://test.localhost/u/admin)\")\n    end\n  end\n\n  describe \".account_silenced\" do\n    fab!(:user_history) { Fabricate(:user_history, action: UserHistory.actions[:silence_user]) }\n\n    it \"adds the silenced_till date in user's timezone\" do\n      user.user_option.timezone = \"Asia/Tbilisi\" # GMT+4\n      user.silenced_till = DateTime.parse(\"May 25, 2020, 12:00pm\")\n\n      mail = UserNotifications.account_silenced(user, { user_history: user_history })\n\n      expect(mail.body).to include(\"May 25, 2020,  4:00pm\")\n    end\n\n    context \"when user doesn't have timezone set\" do\n      before do\n        user.user_option.timezone = nil\n      end\n\n      it \"doesn't raise error\" do\n        expect { UserNotifications.account_silenced(user) }.not_to raise_error\n      end\n\n      it \"adds the silenced_till date in UTC\" do\n        date = \"May 25, 2020, 12:00pm\"\n        user.silenced_till = DateTime.parse(date)\n\n        mail = UserNotifications.account_silenced(user, { user_history: user_history })\n\n        expect(mail.body).to include(date)\n      end\n    end\n  end\n\n  describe \".account_suspended\" do\n    fab!(:user_history) { Fabricate(:user_history, action: UserHistory.actions[:suspend_user]) }\n\n    it \"adds the suspended_till date in user's timezone\" do\n      user.user_option.timezone = \"Asia/Tbilisi\" # GMT+4\n      user.suspended_till = DateTime.parse(\"May 25, 2020, 12:00pm\")\n\n      mail = UserNotifications.account_suspended(user, { user_history: user_history })\n\n      expect(mail.body).to include(\"May 25, 2020,  4:00pm\")\n    end\n\n    context \"when user doesn't have timezone set\" do\n      before do\n        user.user_option.timezone = nil\n      end\n\n      it \"doesn't raise error\" do\n        expect { UserNotifications.account_suspended(user) }.not_to raise_error\n      end\n\n      it \"adds the suspended_till date in UTC\" do\n        date = \"May 25, 2020, 12:00pm\"\n        user.suspended_till = DateTime.parse(date)\n\n        mail = UserNotifications.account_suspended(user, { user_history: user_history })\n\n        expect(mail.body).to include(date)\n      end\n    end\n  end\nend\n"], "fixing_code": ["# frozen_string_literal: true\n\nclass UserNotifications < ActionMailer::Base\n  include UserNotificationsHelper\n  include ApplicationHelper\n  helper :application, :email\n  default charset: 'UTF-8'\n  layout 'email_template'\n\n  include Email::BuildEmailHelper\n\n  def signup(user, opts = {})\n    build_user_email_token_by_template(\n      \"user_notifications.signup\",\n      user,\n      opts[:email_token]\n    )\n  end\n\n  def activation_reminder(user, opts = {})\n    build_user_email_token_by_template(\n      \"user_notifications.activation_reminder\",\n      user,\n      opts[:email_token]\n    )\n  end\n\n  def signup_after_approval(user, opts = {})\n    locale = user_locale(user)\n    tips = I18n.t('system_messages.usage_tips.text_body_template',\n                  base_url: Discourse.base_url,\n                  locale: locale)\n\n    build_email(user.email,\n                template: 'user_notifications.signup_after_approval',\n                locale: locale,\n                new_user_tips: tips)\n  end\n\n  def post_approved(user, opts = {})\n    post_url = opts.dig(:notification_data_hash, :post_url)\n\n    return if post_url.nil?\n\n    locale = user_locale(user)\n    build_email(user.email,\n      template: 'user_notifications.post_approved',\n      locale: locale,\n      base_url: Discourse.base_url,\n      post_url: post_url\n    )\n  end\n\n  def signup_after_reject(user, opts = {})\n    locale = user_locale(user)\n    build_email(user.email,\n                template: 'user_notifications.signup_after_reject',\n                locale: locale,\n                reject_reason: opts[:reject_reason])\n  end\n\n  def suspicious_login(user, opts = {})\n    ipinfo = DiscourseIpInfo.get(opts[:client_ip])\n    location = ipinfo[:location]\n    browser = BrowserDetection.browser(opts[:user_agent])\n    device = BrowserDetection.device(opts[:user_agent])\n    os = BrowserDetection.os(opts[:user_agent])\n\n    build_email(\n      user.email,\n      template: \"user_notifications.suspicious_login\",\n      locale: user_locale(user),\n      client_ip: opts[:client_ip],\n      location: location.present? ? location : I18n.t('staff_action_logs.unknown'),\n      browser: I18n.t(\"user_auth_tokens.browser.#{browser}\"),\n      device: I18n.t(\"user_auth_tokens.device.#{device}\"),\n      os: I18n.t(\"user_auth_tokens.os.#{os}\")\n    )\n  end\n\n  def notify_old_email(user, opts = {})\n    build_email(user.email,\n                template: \"user_notifications.notify_old_email\",\n                locale: user_locale(user),\n                new_email: opts[:new_email])\n  end\n\n  def notify_old_email_add(user, opts = {})\n    build_email(user.email,\n                template: \"user_notifications.notify_old_email_add\",\n                locale: user_locale(user),\n                new_email: opts[:new_email])\n  end\n\n  def confirm_old_email(user, opts = {})\n    build_user_email_token_by_template(\n      \"user_notifications.confirm_old_email\",\n      user,\n      opts[:email_token]\n    )\n  end\n\n  def confirm_old_email_add(user, opts = {})\n    build_user_email_token_by_template(\n      \"user_notifications.confirm_old_email_add\",\n      user,\n      opts[:email_token]\n    )\n  end\n\n  def confirm_new_email(user, opts = {})\n    build_user_email_token_by_template(\n      opts[:requested_by_admin] ? \"user_notifications.confirm_new_email_via_admin\" : \"user_notifications.confirm_new_email\",\n      user,\n      opts[:email_token]\n    )\n  end\n\n  def forgot_password(user, opts = {})\n    build_user_email_token_by_template(\n      user.has_password? ? \"user_notifications.forgot_password\" : \"user_notifications.set_password\",\n      user,\n      opts[:email_token]\n    )\n  end\n\n  def email_login(user, opts = {})\n    build_user_email_token_by_template(\n      \"user_notifications.email_login\",\n      user,\n      opts[:email_token]\n    )\n  end\n\n  def admin_login(user, opts = {})\n    build_user_email_token_by_template(\n      \"user_notifications.admin_login\",\n      user,\n      opts[:email_token]\n    )\n  end\n\n  def account_created(user, opts = {})\n    build_user_email_token_by_template(\n      \"user_notifications.account_created\",\n      user,\n      opts[:email_token]\n    )\n  end\n\n  def account_silenced(user, opts = nil)\n    opts ||= {}\n\n    return unless user_history = opts[:user_history]\n\n    if user.silenced_forever?\n      build_email(\n        user.email,\n        template: \"user_notifications.account_silenced_forever\",\n        locale: user_locale(user),\n        reason: user_history.details\n      )\n    else\n      silenced_till = user.silenced_till.in_time_zone(user.user_option.timezone)\n      build_email(\n        user.email,\n        template: \"user_notifications.account_silenced\",\n        locale: user_locale(user),\n        reason: user_history.details,\n        silenced_till: I18n.l(silenced_till, format: :long)\n      )\n    end\n  end\n\n  def account_suspended(user, opts = nil)\n    opts ||= {}\n\n    return unless user_history = opts[:user_history]\n\n    if user.suspended_forever?\n      build_email(\n        user.email,\n        template: \"user_notifications.account_suspended_forever\",\n        locale: user_locale(user),\n        reason: user_history.details\n      )\n    else\n      suspended_till = user.suspended_till.in_time_zone(user.user_option.timezone)\n      build_email(\n        user.email,\n        template: \"user_notifications.account_suspended\",\n        locale: user_locale(user),\n        reason: user_history.details,\n        suspended_till: I18n.l(suspended_till, format: :long)\n      )\n    end\n  end\n\n  def account_exists(user, opts = {})\n    build_email(\n      user.email,\n      template: 'user_notifications.account_exists',\n      locale: user_locale(user),\n      email: user.email\n    )\n  end\n\n  def account_second_factor_disabled(user, opts = {})\n    build_email(\n      user.email,\n      template: 'user_notifications.account_second_factor_disabled',\n      locale: user_locale(user),\n      email: user.email\n    )\n  end\n\n  def digest(user, opts = {})\n    build_summary_for(user)\n    @unsubscribe_key = UnsubscribeKey.create_key_for(@user, UnsubscribeKey::DIGEST_TYPE)\n\n    min_date = opts[:since] || user.last_emailed_at || user.last_seen_at || 1.month.ago\n\n    # Fetch some topics and posts to show\n    digest_opts = { limit: SiteSetting.digest_topics + SiteSetting.digest_other_topics, top_order: true }\n    topics_for_digest = Topic.for_digest(user, min_date, digest_opts).to_a\n    if topics_for_digest.empty? && !user.user_option.try(:include_tl0_in_digests)\n      # Find some topics from new users that are at least 24 hours old\n      topics_for_digest = Topic.for_digest(user, min_date, digest_opts.merge(include_tl0: true)).where('topics.created_at < ?', 24.hours.ago).to_a\n    end\n\n    @popular_topics = topics_for_digest[0, SiteSetting.digest_topics]\n\n    if @popular_topics.present?\n      @other_new_for_you = topics_for_digest.size > SiteSetting.digest_topics ? topics_for_digest[SiteSetting.digest_topics..-1] : []\n\n      @popular_posts = if SiteSetting.digest_posts > 0\n        Post.order(\"posts.score DESC\")\n          .for_mailing_list(user, min_date)\n          .where('posts.post_type = ?', Post.types[:regular])\n          .where('posts.deleted_at IS NULL AND posts.hidden = false AND posts.user_deleted = false')\n          .where(\"posts.post_number > ? AND posts.score > ?\", 1, ScoreCalculator.default_score_weights[:like_score] * 5.0)\n          .where('posts.created_at < ?', (SiteSetting.editing_grace_period || 0).seconds.ago)\n          .limit(SiteSetting.digest_posts)\n      else\n        []\n      end\n\n      @excerpts = {}\n\n      @popular_topics.map do |t|\n        @excerpts[t.first_post.id] = email_excerpt(t.first_post.cooked, t.first_post) if t.first_post.present?\n      end\n\n      # Try to find 3 interesting stats for the top of the digest\n      new_topics_count = Topic.for_digest(user, min_date).count\n\n      if new_topics_count == 0\n        # We used topics from new users instead, so count should match\n        new_topics_count = topics_for_digest.size\n      end\n      @counts = [{ label_key: 'user_notifications.digest.new_topics',\n                   value: new_topics_count,\n                   href: \"#{Discourse.base_url}/new\" }]\n\n      # totalling unread notifications (which are low-priority only) and unread\n      # PMs and bookmark reminder notifications, so the total is both unread low\n      # and high priority PMs\n      value = user.unread_notifications + user.unread_high_priority_notifications\n      @counts << { label_key: 'user_notifications.digest.unread_notifications', value: value, href: \"#{Discourse.base_url}/my/notifications\" } if value > 0\n\n      if @counts.size < 3\n        value = user.unread_notifications_of_type(Notification.types[:liked])\n        @counts << { label_key: 'user_notifications.digest.liked_received', value: value, href: \"#{Discourse.base_url}/my/notifications\" } if value > 0\n      end\n\n      if @counts.size < 3 && user.user_option.digest_after_minutes.to_i >= 1440\n        value = summary_new_users_count(min_date)\n        @counts << { label_key: 'user_notifications.digest.new_users', value: value, href: \"#{Discourse.base_url}/about\" } if value > 0\n      end\n\n      @last_seen_at = short_date(user.last_seen_at || user.created_at)\n\n      @preheader_text = I18n.t('user_notifications.digest.preheader', last_seen_at: @last_seen_at)\n\n      opts = {\n        from_alias: I18n.t('user_notifications.digest.from', site_name: Email.site_title),\n        subject: I18n.t('user_notifications.digest.subject_template', email_prefix: @email_prefix, date: short_date(Time.now)),\n        add_unsubscribe_link: true,\n        unsubscribe_url: \"#{Discourse.base_url}/email/unsubscribe/#{@unsubscribe_key}\",\n      }\n\n      build_email(user.email, opts)\n    end\n  end\n\n  def user_replied(user, opts)\n    opts[:allow_reply_by_email] = true\n    opts[:use_site_subject] = true\n    opts[:show_category_in_subject] = true\n    opts[:show_tags_in_subject] = true\n    notification_email(user, opts)\n  end\n\n  def user_quoted(user, opts)\n    opts[:allow_reply_by_email] = true\n    opts[:use_site_subject] = true\n    opts[:show_category_in_subject] = true\n    opts[:show_tags_in_subject] = true\n    notification_email(user, opts)\n  end\n\n  def user_linked(user, opts)\n    opts[:allow_reply_by_email] = true\n    opts[:use_site_subject] = true\n    opts[:show_category_in_subject] = true\n    opts[:show_tags_in_subject] = true\n    notification_email(user, opts)\n  end\n\n  def user_mentioned(user, opts)\n    opts[:allow_reply_by_email] = true\n    opts[:use_site_subject] = true\n    opts[:show_category_in_subject] = true\n    opts[:show_tags_in_subject] = true\n    notification_email(user, opts)\n  end\n\n  def group_mentioned(user, opts)\n    opts[:allow_reply_by_email] = true\n    opts[:use_site_subject] = true\n    opts[:show_category_in_subject] = true\n    opts[:show_tags_in_subject] = true\n    notification_email(user, opts)\n  end\n\n  def user_posted(user, opts)\n    opts[:allow_reply_by_email] = true\n    opts[:use_site_subject] = true\n    opts[:add_re_to_subject] = true\n    opts[:show_category_in_subject] = true\n    opts[:show_tags_in_subject] = true\n    notification_email(user, opts)\n  end\n\n  def user_private_message(user, opts)\n    opts[:allow_reply_by_email] = true\n    opts[:use_site_subject] = true\n    opts[:add_re_to_subject] = true\n    opts[:show_category_in_subject] = false\n    opts[:show_tags_in_subject] = false\n    opts[:show_group_in_subject] = true if SiteSetting.group_in_subject\n\n    # We use the 'user_posted' event when you are emailed a post in a PM.\n    opts[:notification_type] = 'posted'\n\n    notification_email(user, opts)\n  end\n\n  def user_invited_to_private_message(user, opts)\n    opts[:allow_reply_by_email] = false\n    opts[:use_invite_template] = true\n    notification_email(user, opts)\n  end\n\n  def user_invited_to_topic(user, opts)\n    opts[:allow_reply_by_email] = false\n    opts[:use_invite_template] = true\n    opts[:show_category_in_subject] = true\n    opts[:show_tags_in_subject] = true\n    notification_email(user, opts)\n  end\n\n  def user_watching_first_post(user, opts)\n    user_posted(user, opts)\n  end\n\n  def mailing_list_notify(user, post)\n    opts = {\n      post: post,\n      allow_reply_by_email: true,\n      use_site_subject: true,\n      add_re_to_subject: true,\n      show_category_in_subject: true,\n      show_tags_in_subject: true,\n      notification_type: \"posted\",\n      notification_data_hash: {\n        original_username: post.user.username,\n        topic_title: post.topic.title,\n      },\n    }\n    notification_email(user, opts)\n  end\n\n  protected\n\n  def user_locale(user)\n    user.effective_locale\n  end\n\n  def email_post_markdown(post, add_posted_by = false)\n    result = +\"#{post.raw}\\n\\n\"\n    if add_posted_by\n      result << \"#{I18n.t('user_notifications.posted_by', username: post.username, post_date: post.created_at.strftime(\"%m/%d/%Y\"))}\\n\\n\"\n    end\n    result\n  end\n\n  def self.get_context_posts(post, topic_user, user)\n    if (user.user_option.email_previous_replies == UserOption.previous_replies_type[:never]) ||\n       SiteSetting.private_email?\n      return []\n    end\n\n    allowed_post_types = [Post.types[:regular]]\n    allowed_post_types << Post.types[:whisper] if topic_user.try(:user).try(:staff?)\n\n    context_posts = Post.where(topic_id: post.topic_id)\n      .where(\"post_number < ?\", post.post_number)\n      .where(user_deleted: false)\n      .where(hidden: false)\n      .where(post_type: allowed_post_types)\n      .order('created_at desc')\n      .limit(SiteSetting.email_posts_context)\n\n    if topic_user && topic_user.last_emailed_post_number && user.user_option.email_previous_replies == UserOption.previous_replies_type[:unless_emailed]\n      context_posts = context_posts.where(\"post_number > ?\", topic_user.last_emailed_post_number)\n    end\n\n    context_posts\n  end\n\n  def notification_email(user, opts)\n    notification_type = opts[:notification_type]\n    notification_data = opts[:notification_data_hash]\n    post = opts[:post]\n\n    unless String === notification_type\n      if Numeric === notification_type\n        notification_type = Notification.types[notification_type]\n      end\n      notification_type = notification_type.to_s\n    end\n\n    user_name = notification_data[:original_username]\n\n    if post && SiteSetting.enable_names && SiteSetting.display_name_on_email_from\n      name = User.where(id: notification_data[:original_user_id] || post.user_id).pluck_first(:name)\n      user_name = name unless name.blank?\n    end\n\n    allow_reply_by_email = opts[:allow_reply_by_email] unless user.suspended?\n    original_username = notification_data[:original_username] || notification_data[:display_username]\n\n    if user.staged && post\n      original_subject = IncomingEmail.joins(:post)\n        .where(\"posts.topic_id = ? AND posts.post_number = 1\", post.topic_id)\n        .pluck(:subject)\n        .first\n    end\n\n    if original_subject\n      topic_title = original_subject\n      opts[:use_site_subject] = false\n      opts[:add_re_to_subject] = true\n      use_topic_title_subject = true\n    else\n      topic_title = notification_data[:topic_title]\n      use_topic_title_subject = false\n    end\n\n    email_options = {\n      title: topic_title,\n      post: post,\n      username: original_username,\n      from_alias: I18n.t('email_from', user_name: user_name, site_name: Email.site_title),\n      allow_reply_by_email: allow_reply_by_email,\n      use_site_subject: opts[:use_site_subject],\n      add_re_to_subject: opts[:add_re_to_subject],\n      show_category_in_subject: opts[:show_category_in_subject],\n      show_tags_in_subject: opts[:show_tags_in_subject],\n      show_group_in_subject: opts[:show_group_in_subject],\n      notification_type: notification_type,\n      use_invite_template: opts[:use_invite_template],\n      use_topic_title_subject: use_topic_title_subject,\n      user: user\n    }\n\n    if group_id = notification_data[:group_id]\n      email_options[:group_name] = Group.find_by(id: group_id)&.name\n    end\n\n    send_notification_email(email_options)\n  end\n\n  def send_notification_email(opts)\n    post = opts[:post]\n    title = opts[:title]\n\n    allow_reply_by_email = opts[:allow_reply_by_email]\n    use_site_subject = opts[:use_site_subject]\n    add_re_to_subject = opts[:add_re_to_subject] && post.post_number > 1\n    use_topic_title_subject = opts[:use_topic_title_subject]\n    username = opts[:username]\n    from_alias = opts[:from_alias]\n    notification_type = opts[:notification_type]\n    user = opts[:user]\n    group_name = opts[:group_name]\n    locale = user_locale(user)\n\n    template = +\"user_notifications.user_#{notification_type}\"\n    if post.topic.private_message?\n      template << \"_pm\"\n\n      if group_name\n        template << \"_group\"\n      elsif user.staged\n        template << \"_staged\"\n      end\n    end\n\n    # category name\n    category = Topic.find_by(id: post.topic_id)&.category\n    if opts[:show_category_in_subject] && post.topic_id && category && !category.uncategorized?\n      show_category_in_subject = category.name\n\n      # subcategory case\n      if !category.parent_category_id.nil?\n        show_category_in_subject = \"#{Category.where(id: category.parent_category_id).pluck_first(:name)}/#{show_category_in_subject}\"\n      end\n    else\n      show_category_in_subject = nil\n    end\n\n    # tag names\n    if opts[:show_tags_in_subject] && post.topic_id\n      tags =\n        DiscourseTagging\n          .visible_tags(Guardian.new(user))\n          .joins(:topic_tags)\n          .where(\"topic_tags.topic_id = ?\", post.topic_id)\n          .limit(3)\n          .pluck(:name)\n\n      show_tags_in_subject = tags.any? ? tags.join(\" \") : nil\n    end\n\n    group = post.topic.allowed_groups&.first\n\n    if post.topic.private_message?\n      subject_pm =\n        if opts[:show_group_in_subject] && group.present?\n          if group.full_name\n            \"[#{group.full_name}] \"\n          else\n            \"[#{group.name}] \"\n          end\n        else\n          I18n.t('subject_pm')\n        end\n\n      participants = self.class.participants(post, user)\n    end\n\n    if SiteSetting.private_email?\n      title = I18n.t(\"system_messages.private_topic_title\", id: post.topic_id)\n    end\n\n    context = +\"\"\n    tu = TopicUser.get(post.topic_id, user)\n    context_posts = self.class.get_context_posts(post, tu, user)\n\n    # make .present? cheaper\n    context_posts = context_posts.to_a\n\n    if context_posts.present?\n      context << +\"-- \\n*#{I18n.t('user_notifications.previous_discussion')}*\\n\"\n      context_posts.each do |cp|\n        context << email_post_markdown(cp, true)\n      end\n    end\n\n    translation_override_exists = TranslationOverride.where(\n      locale: SiteSetting.default_locale,\n      translation_key: \"#{template}.text_body_template\"\n    ).exists?\n\n    if opts[:use_invite_template]\n      invite_template = +\"user_notifications.invited\"\n      invite_template << \"_group\" if group_name\n\n      invite_template <<\n        if post.topic.private_message?\n          \"_to_private_message_body\"\n        else\n          \"_to_topic_body\"\n        end\n\n      topic_excerpt = post.excerpt.tr(\"\\n\", \" \") if post.is_first_post? && post.excerpt\n      topic_url = post.topic&.url\n\n      if SiteSetting.private_email?\n        topic_excerpt = \"\"\n        topic_url = \"\"\n      end\n\n      message = I18n.t(invite_template,\n        username: username,\n        group_name: group_name,\n        topic_title: gsub_emoji_to_unicode(title),\n        topic_excerpt: topic_excerpt,\n        site_title: SiteSetting.title,\n        site_description: SiteSetting.site_description,\n        topic_url: topic_url\n      )\n\n      html = PrettyText.cook(message, sanitize: false).html_safe\n    else\n      reached_limit = SiteSetting.max_emails_per_day_per_user > 0\n      reached_limit &&= (EmailLog.where(user_id: user.id)\n                              .where('created_at > ?', 1.day.ago)\n                              .count) >= (SiteSetting.max_emails_per_day_per_user - 1)\n\n      in_reply_to_post = post.reply_to_post if user.user_option.email_in_reply_to\n      if SiteSetting.private_email?\n        message = I18n.t('system_messages.contents_hidden')\n      else\n        message = email_post_markdown(post) + (reached_limit ? \"\\n\\n#{I18n.t \"user_notifications.reached_limit\", count: SiteSetting.max_emails_per_day_per_user}\" : \"\")\n      end\n\n      first_footer_classes = \"highlight\"\n      if (allow_reply_by_email && user.staged) || (user.suspended? || user.staged?)\n        first_footer_classes = \"\"\n      end\n\n      unless translation_override_exists\n        html = UserNotificationRenderer.render(\n          template: 'email/notification',\n          format: :html,\n          locals: { context_posts: context_posts,\n                    reached_limit: reached_limit,\n                    post: post,\n                    in_reply_to_post: in_reply_to_post,\n                    classes: Rtl.new(user).css_class,\n                    first_footer_classes: first_footer_classes,\n                    reply_above_line: false\n          }\n        )\n      end\n    end\n\n    email_opts = {\n      topic_title: Emoji.gsub_emoji_to_unicode(title),\n      topic_title_url_encoded: title ? UrlHelper.encode_component(title) : title,\n      message: message,\n      url: post.url(without_slug: SiteSetting.private_email?),\n      post_id: post.id,\n      topic_id: post.topic_id,\n      context: context,\n      username: username,\n      group_name: group_name,\n      add_unsubscribe_link: !user.staged,\n      mailing_list_mode: user.user_option.mailing_list_mode,\n      unsubscribe_url: post.unsubscribe_url(user),\n      allow_reply_by_email: allow_reply_by_email,\n      only_reply_by_email: allow_reply_by_email && user.staged,\n      use_site_subject: use_site_subject,\n      add_re_to_subject: add_re_to_subject,\n      show_category_in_subject: show_category_in_subject,\n      show_tags_in_subject: show_tags_in_subject,\n      private_reply: post.topic.private_message?,\n      subject_pm: subject_pm,\n      participants: participants,\n      include_respond_instructions: !(user.suspended? || user.staged?),\n      template: template,\n      use_topic_title_subject: use_topic_title_subject,\n      site_description: SiteSetting.site_description,\n      site_title: SiteSetting.title,\n      site_title_url_encoded: UrlHelper.encode_component(SiteSetting.title),\n      locale: locale\n    }\n\n    unless translation_override_exists\n      email_opts[:html_override] = html\n    end\n\n    # If we have a display name, change the from address\n    email_opts[:from_alias] = from_alias if from_alias.present?\n\n    TopicUser.change(user.id, post.topic_id, last_emailed_post_number: post.post_number)\n\n    build_email(user.email, email_opts)\n  end\n\n  def self.participants(post, recipient_user, reveal_staged_email: false)\n    list = []\n\n    allowed_groups = post.topic.allowed_groups.order(\"user_count DESC\")\n\n    allowed_groups.each do |g|\n      list.push(\"[#{g.name_full_preferred} (#{g.user_count})](#{g.full_url})\")\n      break if list.size >= SiteSetting.max_participant_names\n    end\n\n    recent_posts_query = post.topic.posts\n      .select(\"user_id, MAX(post_number) AS post_number\")\n      .where(post_type: Post.types[:regular], post_number: ..post.post_number)\n      .where.not(user_id: recipient_user.id)\n      .group(:user_id)\n      .order(\"post_number DESC\")\n      .limit(SiteSetting.max_participant_names)\n      .to_sql\n\n    allowed_users = post.topic.allowed_users\n      .joins(\"LEFT JOIN (#{recent_posts_query}) pu ON topic_allowed_users.user_id = pu.user_id\")\n      .order(\"post_number DESC NULLS LAST\", :id)\n      .where.not(id: recipient_user.id)\n      .human_users\n\n    allowed_users.each do |u|\n      break if list.size >= SiteSetting.max_participant_names\n\n      if reveal_staged_email && u.staged?\n        list.push(\"#{u.email}\")\n      else\n        list.push(\"[#{u.display_name}](#{u.full_url})\")\n      end\n    end\n\n    participants = list.join(I18n.t(\"word_connector.comma\"))\n    others_count = allowed_groups.size + allowed_users.size - list.size\n\n    if others_count > 0\n      I18n.t(\"user_notifications.more_pm_participants\", participants: participants, count: others_count)\n    else\n      participants\n    end\n  end\n\n  private\n\n  def build_user_email_token_by_template(template, user, email_token)\n    build_email(\n      user.email,\n      template: template,\n      locale: user_locale(user),\n      email_token: email_token\n    )\n  end\n\n  def build_summary_for(user)\n    @site_name       = SiteSetting.email_prefix.presence || SiteSetting.title # used by I18n\n    @user            = user\n    @date            = short_date(Time.now)\n    @base_url        = Discourse.base_url\n    @email_prefix    = SiteSetting.email_prefix.presence || SiteSetting.title\n    @header_color    = ColorScheme.hex_for_name('header_primary')\n    @header_bgcolor  = ColorScheme.hex_for_name('header_background')\n    @anchor_color    = ColorScheme.hex_for_name('tertiary')\n    @markdown_linker = MarkdownLinker.new(@base_url)\n    @disable_email_custom_styles = !SiteSetting.apply_custom_styles_to_digest\n  end\n\n  def self.summary_new_users_count_key(min_date_str)\n    \"summary-new-users:#{min_date_str}\"\n  end\n\n  def summary_new_users_count(min_date)\n    min_date_str = min_date.is_a?(String) ? min_date : min_date.strftime('%Y-%m-%d')\n    key = self.class.summary_new_users_count_key(min_date_str)\n    ((count = Discourse.redis.get(key)) && count.to_i) || begin\n      count = User.real.where(active: true, staged: false).not_suspended.where(\"created_at > ?\", min_date_str).count\n      Discourse.redis.setex(key, 1.day, count)\n      count\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nRSpec.describe UserNotifications do\n  let(:user) { Fabricate(:admin) }\n\n  describe \"#get_context_posts\" do\n    it \"does not include hidden/deleted/user_deleted posts in context\" do\n      post1 = create_post\n      _post2 = Fabricate(:post, topic: post1.topic, deleted_at: 1.day.ago)\n      _post3 = Fabricate(:post, topic: post1.topic, user_deleted: true)\n      _post4 = Fabricate(:post, topic: post1.topic, hidden: true)\n      _post5 = Fabricate(:post, topic: post1.topic, post_type: Post.types[:moderator_action])\n      _post6 = Fabricate(:post, topic: post1.topic, post_type: Post.types[:small_action])\n      _post7 = Fabricate(:post, topic: post1.topic, post_type: Post.types[:whisper])\n      last = Fabricate(:post, topic: post1.topic)\n\n      post1.user.user_option.email_previous_replies = UserOption.previous_replies_type[:always]\n\n      # default is only post #1\n      expect(UserNotifications.get_context_posts(last, nil, post1.user).count).to eq(1)\n      # staff members can also see the whisper\n      moderator = build(:moderator)\n      moderator.user_option = UserOption.new\n      moderator.user_option.email_previous_replies = UserOption.previous_replies_type[:always]\n      tu = TopicUser.new(topic: post1.topic, user: moderator)\n      expect(UserNotifications.get_context_posts(last, tu, tu.user).count).to eq(2)\n    end\n\n    it \"allows users to control context\" do\n      post1 = create_post\n      _post2 = Fabricate(:post, topic: post1.topic)\n      post3 = Fabricate(:post, topic: post1.topic)\n\n      user = Fabricate(:user)\n      TopicUser.change(user.id, post1.topic_id, last_emailed_post_number: 1)\n      topic_user = TopicUser.find_by(user_id: user.id, topic_id: post1.topic_id)\n      # to avoid reloads after update_columns\n      user = topic_user.user\n      user.user_option.update_columns(email_previous_replies: UserOption.previous_replies_type[:unless_emailed])\n\n      expect(UserNotifications.get_context_posts(post3, topic_user, user).count).to eq(1)\n\n      user.user_option.update_columns(email_previous_replies: UserOption.previous_replies_type[:never])\n      expect(UserNotifications.get_context_posts(post3, topic_user, user).count).to eq(0)\n\n      user.user_option.update_columns(email_previous_replies: UserOption.previous_replies_type[:always])\n      expect(UserNotifications.get_context_posts(post3, topic_user, user).count).to eq(2)\n\n      SiteSetting.private_email = true\n      expect(UserNotifications.get_context_posts(post3, topic_user, user).count).to eq(0)\n    end\n  end\n\n  describe \".signup\" do\n    subject { UserNotifications.signup(user) }\n\n    it \"works\" do\n      expect(subject.to).to eq([user.email])\n      expect(subject.subject).to be_present\n      expect(subject.from).to eq([SiteSetting.notification_email])\n      expect(subject.body).to be_present\n    end\n  end\n\n  describe \".forgot_password\" do\n    subject { UserNotifications.forgot_password(user) }\n\n    it \"works\" do\n      expect(subject.to).to eq([user.email])\n      expect(subject.subject).to be_present\n      expect(subject.from).to eq([SiteSetting.notification_email])\n      expect(subject.body).to be_present\n    end\n  end\n\n  describe '.post_approved' do\n    fab!(:post) { Fabricate(:post) }\n\n    it 'works' do\n      subject = UserNotifications.post_approved(user, { notification_data_hash: { post_url: post.url } })\n\n      expect(subject.to).to eq([user.email])\n      expect(subject.subject).to be_present\n      expect(subject.from).to eq([SiteSetting.notification_email])\n      expect(subject.body).to be_present\n    end\n  end\n\n  describe \".confirm_new_email\" do\n    let(:opts) do\n      { requested_by_admin: requested_by_admin, email_token: token }\n    end\n    let(:token) { \"test123\" }\n\n    context \"when requested by admin\" do\n      let(:requested_by_admin) { true }\n\n      it \"uses the requested by admin template\" do\n        expect(UserNotifications.confirm_new_email(user, opts).body).to include(\n          \"This email change was requested by a site admin.\"\n        )\n      end\n    end\n\n    context \"when not requested by admin\" do\n      let(:requested_by_admin) { false }\n\n      it \"uses the normal template\" do\n        expect(UserNotifications.confirm_new_email(user, opts).body).not_to include(\n          \"This email change was requested by a site admin.\"\n        )\n      end\n    end\n  end\n\n  describe '.email_login' do\n    let(:email_token) { Fabricate(:email_token, user: user, scope: EmailToken.scopes[:email_login]).token }\n    subject { UserNotifications.email_login(user, email_token: email_token) }\n\n    it \"generates the right email\" do\n      expect(subject.to).to eq([user.email])\n      expect(subject.from).to eq([SiteSetting.notification_email])\n\n      expect(subject.subject).to eq(I18n.t(\n        'user_notifications.email_login.subject_template',\n        email_prefix: SiteSetting.title\n      ))\n\n      expect(subject.body.to_s).to match(I18n.t(\n        'user_notifications.email_login.text_body_template',\n        site_name: SiteSetting.title,\n        base_url: Discourse.base_url,\n        email_token: email_token\n      ))\n    end\n  end\n\n  describe '.digest' do\n    subject { UserNotifications.digest(user) }\n\n    after do\n      Discourse.redis.keys('summary-new-users:*').each { |key| Discourse.redis.del(key) }\n    end\n\n    context \"without new topics\" do\n      it \"doesn't send the email\" do\n        expect(subject.to).to be_blank\n      end\n\n    end\n\n    context \"with topics only from new users\" do\n      let!(:new_today) { Fabricate(:topic, user: Fabricate(:user, trust_level: TrustLevel[0], created_at: 10.minutes.ago), title: \"Hey everyone look at me\") }\n      let!(:new_yesterday) { Fabricate(:topic, user: Fabricate(:user, trust_level: TrustLevel[0], created_at: 25.hours.ago), created_at: 25.hours.ago, title: \"This topic is of interest to you\") }\n\n      it \"returns topics from new users if they're more than 24 hours old\" do\n        expect(subject.to).to eq([user.email])\n        html = subject.html_part.body.to_s\n        expect(html).to include(new_yesterday.title)\n        expect(html).to_not include(new_today.title)\n      end\n    end\n\n    context \"with new topics\" do\n      let!(:popular_topic) { Fabricate(:topic, user: Fabricate(:coding_horror), created_at: 1.hour.ago) }\n\n      it \"works\" do\n        expect(subject.to).to eq([user.email])\n        expect(subject.subject).to be_present\n        expect(subject.from).to eq([SiteSetting.notification_email])\n        expect(subject.html_part.body.to_s).to be_present\n        expect(subject.text_part.body.to_s).to be_present\n        expect(subject.header[\"List-Unsubscribe\"].to_s).to match(/\\/email\\/unsubscribe\\/\\h{64}/)\n        expect(subject.html_part.body.to_s).to include('New Users')\n      end\n\n      it \"doesn't include new user count if digest_after_minutes is low\" do\n        user.user_option.digest_after_minutes = 60\n        expect(subject.html_part.body.to_s).to_not include('New Users')\n      end\n\n      it \"works with min_date string\" do\n        digest = UserNotifications.digest(user, since: 1.month.ago.to_date.to_s)\n        expect(digest.html_part.body.to_s).to be_present\n        expect(digest.text_part.body.to_s).to be_present\n        expect(digest.html_part.body.to_s).to include('New Users')\n      end\n\n      it \"includes email_prefix in email subject instead of site title\" do\n        SiteSetting.email_prefix = \"Try Discourse\"\n        SiteSetting.title = \"Discourse Meta\"\n\n        expect(subject.subject).to match(/Try Discourse/)\n        expect(subject.subject).not_to match(/Discourse Meta/)\n      end\n\n      it \"excludes deleted topics and their posts\" do\n        deleted = Fabricate(:topic, user: Fabricate(:user), title: \"Delete this topic plz\", created_at: 1.hour.ago)\n        post = Fabricate(:post, topic: deleted, score: 100.0, post_number: 2, raw: \"Your wish is my command\", created_at: 1.hour.ago)\n        deleted.trash!\n        html = subject.html_part.body.to_s\n        expect(html).to_not include deleted.title\n        expect(html).to_not include post.raw\n      end\n\n      it \"excludes shared drafts\" do\n        cat = Fabricate(:category)\n        SiteSetting.shared_drafts_category = cat.id\n        topic = Fabricate(:topic, title: \"This is a draft\", category_id: cat.id, created_at: 1.hour.ago)\n        post = Fabricate(\n          :post,\n          topic: topic,\n          score: 100.0,\n          post_number: 2,\n          raw: \"secret draft content\",\n          created_at: 1.hour.ago\n        )\n        html = subject.html_part.body.to_s\n        expect(html).to_not include topic.title\n        expect(html).to_not include post.raw\n      end\n\n      it \"excludes whispers and other post types that don't belong\" do\n        t = Fabricate(:topic, user: Fabricate(:user), title: \"Who likes the same stuff I like?\", created_at: 1.hour.ago)\n        whisper = Fabricate(:post, topic: t, score: 100.0, post_number: 2, raw: \"You like weird stuff\", post_type: Post.types[:whisper], created_at: 1.hour.ago)\n        mod_action = Fabricate(:post, topic: t, score: 100.0, post_number: 3, raw: \"This topic unlisted\", post_type: Post.types[:moderator_action], created_at: 1.hour.ago)\n        small_action = Fabricate(:post, topic: t, score: 100.0, post_number: 4, raw: \"A small action\", post_type: Post.types[:small_action], created_at: 1.hour.ago)\n        html = subject.html_part.body.to_s\n        expect(html).to_not include whisper.raw\n        expect(html).to_not include mod_action.raw\n        expect(html).to_not include small_action.raw\n      end\n\n      it \"excludes deleted and hidden posts\" do\n        t = Fabricate(:topic, user: Fabricate(:user), title: \"Post objectionable stuff here\", created_at: 1.hour.ago)\n        deleted = Fabricate(:post, topic: t, score: 100.0, post_number: 2, raw: \"This post is uncalled for\", deleted_at: 5.minutes.ago, created_at: 1.hour.ago)\n        hidden = Fabricate(:post, topic: t, score: 100.0, post_number: 3, raw: \"Try to find this post\", hidden: true, hidden_at: 5.minutes.ago, hidden_reason_id: Post.hidden_reasons[:flagged_by_tl3_user], created_at: 1.hour.ago)\n        user_deleted = Fabricate(:post, topic: t, score: 100.0, post_number: 4, raw: \"I regret this post\", user_deleted: true, created_at: 1.hour.ago)\n        html = subject.html_part.body.to_s\n        expect(html).to_not include deleted.raw\n        expect(html).to_not include hidden.raw\n        expect(html).to_not include user_deleted.raw\n      end\n\n      it \"excludes posts that are newer than editing grace period\" do\n        SiteSetting.editing_grace_period = 5.minutes\n        too_new = Fabricate(:topic, user: Fabricate(:user), title: \"Oops I need to edit this\", created_at: 1.minute.ago)\n        _too_new_post = Fabricate(:post, user: too_new.user, topic: too_new, score: 100.0, post_number: 1, created_at: 1.minute.ago)\n        html = subject.html_part.body.to_s\n        expect(html).to_not include too_new.title\n      end\n\n      it \"uses theme color\" do\n        cs = Fabricate(:color_scheme, name: 'Fancy', color_scheme_colors: [\n          Fabricate(:color_scheme_color, name: 'header_primary', hex: 'F0F0F0'),\n          Fabricate(:color_scheme_color, name: 'header_background', hex: '1E1E1E')\n        ])\n        theme = Fabricate(:theme,\n                          user_selectable: true,\n                          user: Fabricate(:admin),\n                          color_scheme_id: cs.id\n        )\n\n        theme.set_default!\n\n        html = subject.html_part.body.to_s\n        expect(html).to include 'F0F0F0'\n        expect(html).to include '1E1E1E'\n      end\n\n      it \"supports subfolder\" do\n        set_subfolder \"/forum\"\n        html = subject.html_part.body.to_s\n        text = subject.text_part.body.to_s\n        expect(html).to be_present\n        expect(text).to be_present\n        expect(html).to_not include(\"/forum/forum\")\n        expect(text).to_not include(\"/forum/forum\")\n        expect(subject.header[\"List-Unsubscribe\"].to_s).to match(/http:\\/\\/test.localhost\\/forum\\/email\\/unsubscribe\\/\\h{64}/)\n\n        topic_url = \"http://test.localhost/forum/t/#{popular_topic.slug}/#{popular_topic.id}\"\n        expect(html).to include(topic_url)\n        expect(text).to include(topic_url)\n      end\n\n      it \"applies lang/xml:lang html attributes\" do\n        SiteSetting.default_locale = \"pl_PL\"\n        html = subject.html_part.to_s\n\n        expect(html).to match(' lang=\"pl-PL\"')\n        expect(html).to match(' xml:lang=\"pl-PL\"')\n      end\n    end\n  end\n\n  describe '.user_replied' do\n    let(:response_by_user) { Fabricate(:user, name: \"John Doe\") }\n    let(:category) { Fabricate(:category, name: 'India') }\n    let(:tag1) { Fabricate(:tag, name: 'Taggo') }\n    let(:tag2) { Fabricate(:tag, name: 'Taggie') }\n\n    let(:hidden_tag) { Fabricate(:tag, name: \"hidden\") }\n    let!(:hidden_tag_group) do\n      Fabricate(:tag_group, permissions: { \"staff\" => 1 }, tag_names: [hidden_tag.name])\n    end\n\n    let(:topic) { Fabricate(:topic, category: category, tags: [tag1, tag2, hidden_tag], title: \"Super cool topic\") }\n    let(:post) { Fabricate(:post, topic: topic, raw: 'This is My super duper cool topic') }\n    let(:response) { Fabricate(:basic_reply, topic: post.topic, user: response_by_user) }\n    let(:user) { Fabricate(:user) }\n    let(:notification) { Fabricate(:replied_notification, user: user, post: response) }\n\n    it 'generates a correct email' do\n\n      SiteSetting.default_email_in_reply_to = true\n\n      # Fabricator is not fabricating this ...\n      SiteSetting.email_subject = \"[%{site_name}] %{optional_pm}%{optional_cat}%{optional_tags}%{topic_title}\"\n      SiteSetting.enable_names = true\n      SiteSetting.display_name_on_posts = true\n      mail = UserNotifications.user_replied(\n        user,\n        post: response,\n        notification_type: notification.notification_type,\n        notification_data_hash: notification.data_hash\n      )\n\n      # from should include full user name\n      expect(mail[:from].display_names).to eql(['John Doe via Discourse'])\n\n      # subject should include category name\n      expect(mail.subject).to match(/India/)\n\n      # subject should include tag names\n      expect(mail.subject).to match(/Taggo/)\n      expect(mail.subject).to match(/Taggie/)\n\n      mail_html = mail.html_part.body.to_s\n\n      expect(mail_html.scan(/My super duper cool topic/).count).to eq(1)\n      expect(mail_html.scan(/In Reply To/).count).to eq(1)\n\n      # 2 \"visit topic\" link\n      expect(mail_html.scan(/Visit Topic/).count).to eq(2)\n\n      # 2 respond to links cause we have 1 context post\n      expect(mail_html.scan(/to respond/).count).to eq(2)\n\n      # 1 unsubscribe\n      expect(mail_html.scan(/To unsubscribe/).count).to eq(1)\n\n      # side effect, topic user is updated with post number\n      tu = TopicUser.get(post.topic_id, user)\n      expect(tu.last_emailed_post_number).to eq(response.post_number)\n\n      # no In Reply To if user opts out\n      user.user_option.email_in_reply_to = false\n      mail = UserNotifications.user_replied(\n        user,\n        post: response,\n        notification_type: notification.notification_type,\n        notification_data_hash: notification.data_hash\n      )\n\n      expect(mail.html_part.body.to_s.scan(/In Reply To/).count).to eq(0)\n\n      SiteSetting.enable_names = true\n      SiteSetting.display_name_on_posts = true\n      SiteSetting.prioritize_username_in_ux = false\n\n      response.user.username = \"bobmarley\"\n      response.user.name = \"Bob Marley\"\n      response.user.save\n\n      mail = UserNotifications.user_replied(\n        user,\n        post: response,\n        notification_type: notification.notification_type,\n        notification_data_hash: notification.data_hash\n      )\n\n      mail_html = mail.html_part.body.to_s\n      expect(mail_html.scan(/>Bob Marley/).count).to eq(1)\n      expect(mail_html.scan(/>bobmarley/).count).to eq(0)\n\n      expect(mail.subject.scan(/#{tag1.name}/).count).to eq(1)\n      expect(mail.subject.scan(/#{hidden_tag.name}/).count).to eq(0)\n\n      SiteSetting.prioritize_username_in_ux = true\n\n      mail = UserNotifications.user_replied(\n        user,\n        post: response,\n        notification_type: notification.notification_type,\n        notification_data_hash: notification.data_hash\n      )\n\n      mail_html = mail.html_part.body.to_s\n      expect(mail_html.scan(/>Bob Marley/).count).to eq(0)\n      expect(mail_html.scan(/>bobmarley/).count).to eq(1)\n    end\n\n    it \"doesn't include details when private_email is enabled\" do\n      SiteSetting.private_email = true\n      mail = UserNotifications.user_replied(\n        user,\n        post: response,\n        notification_type: notification.notification_type,\n        notification_data_hash: notification.data_hash\n      )\n\n      expect(mail.html_part.body.to_s).to_not include(response.raw)\n      expect(mail.html_part.body.to_s).to_not include(topic.url)\n      expect(mail.text_part.to_s).to_not include(response.raw)\n      expect(mail.text_part.to_s).to_not include(topic.url)\n    end\n\n    it \"includes excerpt when post_excerpts_in_emails is enabled\" do\n      paragraphs = [\n        \"This is the first paragraph, but you should read more.\",\n        \"And here is its friend, the second paragraph.\"\n      ]\n      SiteSetting.post_excerpts_in_emails = true\n      SiteSetting.post_excerpt_maxlength = paragraphs.first.length\n      response.update!(raw: paragraphs.join(\"\\n\\n\"))\n      mail = UserNotifications.user_replied(\n        user,\n        post: response,\n        notification_type: notification.notification_type,\n        notification_data_hash: notification.data_hash\n      )\n      mail_html = mail.html_part.body.to_s\n      expect(mail_html.scan(/#{paragraphs[0]}/).count).to eq(1)\n      expect(mail_html.scan(/#{paragraphs[1]}/).count).to eq(0)\n    end\n  end\n\n  describe '.user_posted' do\n    let(:response_by_user) { Fabricate(:user, name: \"John Doe\", username: \"john\") }\n    let(:topic) { Fabricate(:topic, title: \"Super cool topic\") }\n    let(:post) { Fabricate(:post, topic: topic) }\n    let(:response) { Fabricate(:post, topic: topic, user: response_by_user) }\n    let(:user) { Fabricate(:user) }\n    let(:notification) { Fabricate(:posted_notification, user: user, post: response) }\n\n    it 'generates a correct email' do\n      SiteSetting.enable_names = false\n      mail = UserNotifications.user_posted(\n        user,\n        post: response,\n        notification_type: notification.notification_type,\n        notification_data_hash: notification.data_hash\n      )\n\n      # from should not include full user name if \"show user full names\" is disabled\n      expect(mail[:from].display_names).to_not eql(['John Doe'])\n\n      # from should include username if \"show user full names\" is disabled\n      expect(mail[:from].display_names).to eql(['john via Discourse'])\n\n      # subject should not include category name\n      expect(mail.subject).not_to match(/Uncategorized/)\n\n      # 1 respond to links as no context by default\n      expect(mail.html_part.body.to_s.scan(/to respond/).count).to eq(1)\n\n      # 1 unsubscribe link\n      expect(mail.html_part.body.to_s.scan(/To unsubscribe/).count).to eq(1)\n\n      # side effect, topic user is updated with post number\n      tu = TopicUser.get(post.topic_id, user)\n      expect(tu.last_emailed_post_number).to eq(response.post_number)\n    end\n\n    it \"doesn't include details when private_email is enabled\" do\n      SiteSetting.private_email = true\n      mail = UserNotifications.user_posted(\n        user,\n        post: response,\n        notification_type: notification.notification_type,\n        notification_data_hash: notification.data_hash\n      )\n\n      expect(mail.html_part.body.to_s).to_not include(response.raw)\n      expect(mail.text_part.to_s).to_not include(response.raw)\n    end\n\n    it \"uses the original subject for staged users\" do\n      incoming_email = Fabricate(\n        :incoming_email,\n        subject: \"Original Subject\",\n        post: post,\n        topic: post.topic,\n        user: user\n      )\n\n      mail = UserNotifications.user_posted(\n        user,\n        post: response,\n        notification_type: notification.notification_type,\n        notification_data_hash: notification.data_hash\n      )\n      expect(mail.subject).to match(/Super cool topic/)\n\n      user.update!(staged: true)\n      mail = UserNotifications.user_posted(\n        user,\n        post: response,\n        notification_type: notification.notification_type,\n        notification_data_hash: notification.data_hash\n      )\n      expect(mail.subject).to eq(\"Re: Original Subject\")\n\n      another_post = Fabricate(:post, topic: topic)\n      incoming_email.update!(post_id: another_post.id)\n\n      mail = UserNotifications.user_private_message(\n        user,\n        post: response,\n        notification_type: notification.notification_type,\n        notification_data_hash: notification.data_hash\n      )\n      expect(mail.subject).to match(/Super cool topic/)\n    end\n  end\n\n  describe '.user_private_message' do\n    let(:response_by_user) { Fabricate(:user, name: \"\", username: \"john\") }\n    let(:topic) { Fabricate(:private_message_topic, title: \"Super cool topic\") }\n    let(:post) { Fabricate(:post, topic: topic) }\n    let(:response) { Fabricate(:post, topic: topic, user: response_by_user) }\n    let(:user) { Fabricate(:user) }\n    let(:notification) { Fabricate(:private_message_notification, user: user, post: response) }\n\n    it 'generates a correct email' do\n      SiteSetting.enable_names = true\n      mail = UserNotifications.user_private_message(\n        user,\n        post: response,\n        notification_type: notification.notification_type,\n        notification_data_hash: notification.data_hash\n      )\n\n      # from should include username if full user name is not provided\n      expect(mail[:from].display_names).to eql(['john via Discourse'])\n\n      # subject should include \"[PM]\"\n      expect(mail.subject).to include(\"[PM] \")\n\n      # 1 \"visit message\" link\n      expect(mail.html_part.body.to_s.scan(/Visit Message/).count).to eq(1)\n\n      # 1 respond to link\n      expect(mail.html_part.body.to_s.scan(/to respond/).count).to eq(1)\n\n      # 1 unsubscribe link\n      expect(mail.html_part.body.to_s.scan(/To unsubscribe/).count).to eq(1)\n\n      # side effect, topic user is updated with post number\n      tu = TopicUser.get(topic.id, user)\n      expect(tu.last_emailed_post_number).to eq(response.post_number)\n    end\n\n    it \"doesn't include details when private_email is enabled\" do\n      SiteSetting.private_email = true\n      mail = UserNotifications.user_private_message(\n        user,\n        post: response,\n        notification_type: notification.notification_type,\n        notification_data_hash: notification.data_hash\n      )\n\n      expect(mail.html_part.body.to_s).to_not include(response.raw)\n      expect(mail.html_part.body.to_s).to_not include(topic.url)\n      expect(mail.text_part.to_s).to_not include(response.raw)\n      expect(mail.text_part.to_s).to_not include(topic.url)\n    end\n\n    it \"doesn't include group name in subject\" do\n      group = Fabricate(:group)\n      topic.allowed_groups = [group]\n      mail = UserNotifications.user_private_message(\n        user,\n        post: response,\n        notification_type: notification.notification_type,\n        notification_data_hash: notification.data_hash\n      )\n\n      expect(mail.subject).to include(\"[PM] \")\n    end\n\n    it \"includes a list of participants (except for the destination user), groups first with member lists\" do\n      group1 = Fabricate(:group, name: \"group1\")\n      group2 = Fabricate(:group, name: \"group2\")\n\n      user1 = Fabricate(:user, username: \"one\", groups: [group1, group2])\n      user2 = Fabricate(:user, username: \"two\", groups: [group1], staged: true)\n\n      topic.allowed_users = [user, user1, user2]\n      topic.allowed_groups = [group1, group2]\n\n      mail = UserNotifications.user_private_message(\n        user,\n        post: response,\n        notification_type: notification.notification_type,\n        notification_data_hash: notification.data_hash\n      )\n\n      expect(mail.body).to include(\"[group1 (2)](http://test.localhost/g/group1), [group2 (1)](http://test.localhost/g/group2), [one](http://test.localhost/u/one), [two](http://test.localhost/u/two)\")\n    end\n\n    context \"when SiteSetting.group_name_in_subject is true\" do\n      before do\n        SiteSetting.group_in_subject = true\n      end\n\n      let(:group) { Fabricate(:group, name: \"my_group\") }\n      let(:mail) do\n        UserNotifications.user_private_message(\n          user,\n          post: response,\n          notification_type: notification.notification_type,\n          notification_data_hash: notification.data_hash\n        )\n      end\n\n      shared_examples \"includes first group name\" do\n        it \"includes first group name in subject\" do\n          expect(mail.subject).to include(\"[my_group] \")\n        end\n\n        context \"when first group has full name\" do\n          it \"includes full name in subject\" do\n            group.full_name = \"My Group\"\n            group.save\n            expect(mail.subject).to include(\"[My Group] \")\n          end\n        end\n      end\n\n      context \"with one group in pm\" do\n        before do\n          topic.allowed_groups = [group]\n        end\n\n        include_examples \"includes first group name\"\n      end\n\n      context \"with multiple groups in pm\" do\n        let(:group2) { Fabricate(:group) }\n\n        before do\n          topic.allowed_groups = [group, group2]\n        end\n\n        include_examples \"includes first group name\"\n      end\n\n      context \"with no groups in pm\" do\n        it \"includes %{optional_pm} in subject\" do\n          expect(mail.subject).to include(\"[PM] \")\n        end\n      end\n    end\n\n    it \"uses the original subject for staged users when topic was started via email\" do\n      incoming_email = Fabricate(\n        :incoming_email,\n        subject: \"Original Subject\",\n        post: post,\n        topic: topic,\n        user: user\n      )\n\n      mail = UserNotifications.user_private_message(\n        user,\n        post: response,\n        notification_type: notification.notification_type,\n        notification_data_hash: notification.data_hash\n      )\n      expect(mail.subject).to match(/Super cool topic/)\n\n      user.update!(staged: true)\n      mail = UserNotifications.user_private_message(\n        user,\n        post: response,\n        notification_type: notification.notification_type,\n        notification_data_hash: notification.data_hash\n      )\n      expect(mail.subject).to eq(\"Re: Original Subject\")\n\n      another_post = Fabricate(:post, topic: topic)\n      incoming_email.update!(post_id: another_post.id)\n\n      mail = UserNotifications.user_private_message(\n        user,\n        post: response,\n        notification_type: notification.notification_type,\n        notification_data_hash: notification.data_hash\n      )\n      expect(mail.subject).to match(/Super cool topic/)\n    end\n  end\n\n  it 'adds a warning when mail limit is reached' do\n    SiteSetting.max_emails_per_day_per_user = 2\n    user = Fabricate(:user)\n\n    user.email_logs.create!(\n      email_type: 'blah',\n      to_address: user.email,\n      user_id: user.id\n    )\n\n    post = Fabricate(:post)\n    reply = Fabricate(:post, topic_id: post.topic_id)\n\n    notification = Fabricate(\n      :notification,\n      topic_id: post.topic_id,\n      post_number: reply.post_number,\n      user: post.user,\n      data: { original_username: 'bob' }.to_json\n    )\n\n    mail = UserNotifications.user_replied(\n      user,\n      post: reply,\n      notification_type: notification.notification_type,\n      notification_data_hash: notification.data_hash\n    )\n\n    # WARNING: you reached the limit of 100 email notifications per day. Further emails will be suppressed.\n    # Consider watching less topics or disabling mailing list mode.\n    expect(mail.html_part.body.to_s).to match(I18n.t(\"user_notifications.reached_limit\", count: 2))\n    expect(mail.body.to_s).to match(I18n.t(\"user_notifications.reached_limit\", count: 2))\n  end\n\n  def expects_build_with(condition)\n    UserNotifications.any_instance.expects(:build_email).with(user.email, condition)\n    mailer = UserNotifications.public_send(\n      mail_type, user,\n      notification_type: Notification.types[notification.notification_type],\n      notification_data_hash: notification.data_hash,\n      post: notification.post\n    )\n\n    mailer.message\n  end\n\n  shared_examples \"supports reply by email\" do\n    context \"with reply_by_email\" do\n      it \"should have allow_reply_by_email set when that feature is enabled\" do\n        expects_build_with(has_entry(:allow_reply_by_email, true))\n      end\n    end\n  end\n\n  shared_examples \"no reply by email\" do\n    context \"with reply_by_email\" do\n      it \"doesn't support reply by email\" do\n        expects_build_with(Not(has_entry(:allow_reply_by_email, true)))\n      end\n    end\n  end\n\n  shared_examples \"respect for private_email\" do\n    context \"with private_email\" do\n      it \"doesn't support reply by email\" do\n        SiteSetting.private_email = true\n\n        mailer = UserNotifications.public_send(\n          mail_type,\n          user,\n          notification_type: Notification.types[notification.notification_type],\n          notification_data_hash: notification.data_hash,\n          post: notification.post\n        )\n        message = mailer.message\n\n        topic = notification.post.topic\n        expect(message.html_part.body.to_s).not_to include(topic.title)\n        expect(message.html_part.body.to_s).not_to include(topic.slug)\n        expect(message.text_part.body.to_s).not_to include(topic.title)\n        expect(message.text_part.body.to_s).not_to include(topic.slug)\n      end\n    end\n  end\n\n  # The parts of emails that are derived from templates are translated\n  shared_examples \"sets user locale\" do\n    context \"with set locale for translating templates\" do\n      it \"sets the locale\" do\n        expects_build_with(has_key(:locale))\n      end\n    end\n  end\n\n  shared_examples \"notification email building\" do\n    let(:post) { Fabricate(:post, user: user) }\n    let(:mail_type) { \"user_#{notification_type}\" }\n    let(:mail_template) { \"user_notifications.#{mail_type}\" }\n    let(:username) { \"walterwhite\" }\n    let(:notification) do\n      Fabricate(:notification,\n                user: user,\n                topic: post.topic,\n                notification_type: Notification.types[notification_type],\n                post_number: post.post_number,\n                data: { original_username: username }.to_json)\n    end\n\n    describe 'email building' do\n      it \"has a username\" do\n        expects_build_with(has_entry(:username, username))\n      end\n\n      it \"has a url\" do\n        expects_build_with(has_key(:url))\n      end\n\n      it \"has a template\" do\n        expects_build_with(has_entry(:template, mail_template))\n      end\n\n      it \"overrides the html part\" do\n        expects_build_with(has_key(:html_override))\n      end\n\n      it \"has a message\" do\n        expects_build_with(has_key(:message))\n      end\n\n      it \"has a context\" do\n        expects_build_with(has_key(:context))\n      end\n\n      it \"has an unsubscribe link\" do\n        expects_build_with(has_key(:add_unsubscribe_link))\n      end\n\n      it \"has an post_id\" do\n        expects_build_with(has_key(:post_id))\n      end\n\n      it \"has an topic_id\" do\n        expects_build_with(has_key(:topic_id))\n      end\n\n      it \"should have user name as from_alias\" do\n        SiteSetting.enable_names = true\n        SiteSetting.display_name_on_posts = true\n        expects_build_with(has_entry(:from_alias, \"#{user.name} via Discourse\"))\n      end\n\n      it \"should not have user name as from_alias if display_name_on_posts is disabled\" do\n        SiteSetting.enable_names = false\n        SiteSetting.display_name_on_posts = false\n        expects_build_with(has_entry(:from_alias, \"walterwhite via Discourse\"))\n      end\n\n      it \"should explain how to respond\" do\n        expects_build_with(Not(has_entry(:include_respond_instructions, false)))\n      end\n\n      it \"should not explain how to respond if the user is suspended\" do\n        User.any_instance.stubs(:suspended?).returns(true)\n        expects_build_with(has_entry(:include_respond_instructions, false))\n      end\n\n      context \"when customized\" do\n        let(:custom_body) do\n          body = +<<~BODY\n            You are now officially notified.\n            %{header_instructions}\n            %{message} %{respond_instructions}\n            %{topic_title_url_encoded}\n            %{site_title_url_encoded}\n          BODY\n\n          body << \"%{context}\" if notification_type != :invited_to_topic\n          body\n        end\n\n        before do\n          TranslationOverride.upsert!(\n            SiteSetting.default_locale,\n            \"#{mail_template}.text_body_template\",\n            custom_body\n          )\n        end\n\n        it \"shouldn't use the default html_override\" do\n          expects_build_with(Not(has_key(:html_override)))\n        end\n      end\n    end\n  end\n\n  describe \"user mentioned email\" do\n    include_examples \"notification email building\" do\n      let(:notification_type) { :mentioned }\n      include_examples \"respect for private_email\"\n      include_examples \"supports reply by email\"\n      include_examples \"sets user locale\"\n    end\n  end\n\n  describe \"group mentioned email\" do\n    include_examples \"notification email building\" do\n      let(:notification_type) { :group_mentioned }\n      let(:post) { Fabricate(:private_message_post) }\n      let(:user) { post.user }\n      let(:mail_type) { \"group_mentioned\" }\n      let(:mail_template) { \"user_notifications.user_#{notification_type}_pm\" }\n\n      include_examples \"respect for private_email\"\n      include_examples \"supports reply by email\"\n      include_examples \"sets user locale\"\n    end\n  end\n\n  describe \"user replied\" do\n    include_examples \"notification email building\" do\n      let(:notification_type) { :replied }\n      include_examples \"respect for private_email\"\n      include_examples \"supports reply by email\"\n      include_examples \"sets user locale\"\n    end\n  end\n\n  describe \"user quoted\" do\n    include_examples \"notification email building\" do\n      let(:notification_type) { :quoted }\n      include_examples \"respect for private_email\"\n      include_examples \"supports reply by email\"\n      include_examples \"sets user locale\"\n    end\n  end\n\n  describe \"user posted\" do\n    include_examples \"notification email building\" do\n      let(:notification_type) { :posted }\n      include_examples \"respect for private_email\"\n      include_examples \"supports reply by email\"\n      include_examples \"sets user locale\"\n    end\n  end\n\n  describe \"user invited to a private message\" do\n    include_examples \"notification email building\" do\n      let(:notification_type) { :invited_to_private_message }\n      let(:post) { Fabricate(:private_message_post) }\n      let(:user) { post.user }\n      let(:mail_template) { \"user_notifications.user_#{notification_type}_pm\" }\n\n      include_examples \"respect for private_email\"\n      include_examples \"no reply by email\"\n      include_examples \"sets user locale\"\n    end\n  end\n\n  describe \"group invited to a private message\" do\n    include_examples \"notification email building\" do\n      let(:notification_type) { :invited_to_private_message }\n      let(:post) { Fabricate(:private_message_post) }\n      let(:user) { post.user }\n      let(:group) { Fabricate(:group) }\n      let(:mail_template) { \"user_notifications.user_#{notification_type}_pm_group\" }\n\n      before do\n        notification.data_hash[:group_id] = group.id\n        notification.save!\n      end\n\n      it \"should include the group name\" do\n        expects_build_with(has_entry(:group_name, group.name))\n      end\n\n      include_examples \"respect for private_email\"\n      include_examples \"no reply by email\"\n      include_examples \"sets user locale\"\n    end\n  end\n\n  describe \"user invited to a topic\" do\n    let(:notification_type) { :invited_to_topic }\n\n    include_examples \"notification email building\" do\n      include_examples \"respect for private_email\"\n      include_examples \"no reply by email\"\n      include_examples \"sets user locale\"\n    end\n\n    context \"when showing the right name in 'From' field\" do\n      let(:inviter) { Fabricate(:user) }\n      let(:invitee) { Fabricate(:user) }\n\n      let(:notification) do\n        Fabricate(:notification,\n          notification_type: Notification.types[:invited_to_topic],\n          user: invitee,\n          topic: post.topic,\n          post_number: post.post_number,\n          data: {\n            topic_title: post.topic.title,\n            display_username: inviter.username,\n            original_user_id: inviter.id,\n            original_username: inviter.username\n          }.to_json\n        )\n      end\n\n      let(:mailer) do\n        UserNotifications.public_send(\n          \"user_invited_to_topic\",\n          invitee,\n          notification_type: Notification.types[notification.notification_type],\n          notification_data_hash: notification.data_hash,\n          post: notification.post\n        )\n      end\n\n      it \"sends the email as the inviter\" do\n        SiteSetting.enable_names = false\n\n        expect(mailer.message.to_s).to include(\"From: #{inviter.username} via #{SiteSetting.title} <#{SiteSetting.notification_email}>\")\n      end\n\n      it \"sends the email as the inviter\" do\n        expect(mailer.message.to_s).to include(\"From: #{inviter.name} via #{SiteSetting.title} <#{SiteSetting.notification_email}>\")\n      end\n    end\n  end\n\n  describe \"watching first post\" do\n    include_examples \"notification email building\" do\n      let(:notification_type) { :invited_to_topic }\n      include_examples \"respect for private_email\"\n      include_examples \"no reply by email\"\n      include_examples \"sets user locale\"\n    end\n  end\n\n  # notification emails derived from templates are translated into the user's locale\n  shared_context \"with notification derived from template\" do\n    let(:user) { Fabricate(:user, locale: locale) }\n    let(:mail_type) { mail_type }\n    let(:notification) { Fabricate(:notification, user: user) }\n  end\n\n  describe \"notifications from template\" do\n    context \"when user locale is allowed\" do\n      before do\n        SiteSetting.allow_user_locale = true\n      end\n\n      %w(signup signup_after_approval confirm_old_email notify_old_email confirm_new_email\n         forgot_password admin_login account_created).each do |mail_type|\n        include_examples \"with notification derived from template\" do\n          let(:locale) { \"fr\" }\n          let(:mail_type) { mail_type }\n          it \"sets the locale\" do\n            expects_build_with(has_entry(:locale, \"fr\"))\n          end\n        end\n      end\n    end\n\n    context \"when user locale is not allowed\" do\n      before do\n        SiteSetting.allow_user_locale = false\n      end\n\n      %w(signup signup_after_approval notify_old_email confirm_old_email confirm_new_email\n         forgot_password admin_login account_created).each do |mail_type|\n        include_examples \"with notification derived from template\" do\n          let(:locale) { \"fr\" }\n          let(:mail_type) { mail_type }\n          it \"sets the locale\" do\n            expects_build_with(has_entry(:locale, \"en\"))\n          end\n        end\n      end\n    end\n\n  end\n\n  describe \"#participants\" do\n    fab!(:group1) { Fabricate(:group, name: \"group1\") }\n    fab!(:group2) { Fabricate(:group, name: \"group2\") }\n    fab!(:group3) { Fabricate(:group, name: \"group3\") }\n    fab!(:user1) { Fabricate(:user, username: \"one\", name: nil, groups: [group1, group2]) }\n    fab!(:user2) { Fabricate(:user, username: \"two\", name: nil, groups: [group1]) }\n    fab!(:user3) { Fabricate(:user, username: \"three\", name: nil, groups: [group3]) }\n    fab!(:user4) { Fabricate(:user, username: \"four\", name: nil, groups: [group1, group3]) }\n    fab!(:admin) { Fabricate(:admin, username: \"admin\", name: nil) }\n\n    fab!(:topic) do\n      t = Fabricate(:private_message_topic, title: \"Super cool topic\")\n      t.allowed_users = [user1, user2, user3, user4, admin]\n      t.allowed_groups = [group1]\n      t\n    end\n    fab!(:posts) do\n      [\n        Fabricate(:post, topic: topic, post_number: 1, user: user2),\n        Fabricate(:post, topic: topic, post_number: 2, user: user1),\n        Fabricate(:post, topic: topic, post_number: 3, user: user2),\n        Fabricate(:small_action, topic: topic, post_number: 4, user: admin),\n        Fabricate(:post, topic: topic, post_number: 5, user: user4),\n        Fabricate(:post, topic: topic, post_number: 6, user: user3),\n        Fabricate(:post, topic: topic, post_number: 7, user: user4)\n      ]\n    end\n\n    it \"returns a list of participants (except for the recipient), groups first, followed by users in order of their last reply\" do\n      expect(UserNotifications.participants(posts.last, user3)).to eq(\"[group1 (3)](http://test.localhost/g/group1), \" \\\n        \"[four](http://test.localhost/u/four), [two](http://test.localhost/u/two), [one](http://test.localhost/u/one), \" \\\n        \"[admin](http://test.localhost/u/admin)\")\n    end\n\n    it \"caps the list according to site setting\" do\n      SiteSetting.max_participant_names = 3\n      list = \"[group1 (3)](http://test.localhost/g/group1), [four](http://test.localhost/u/four), [two](http://test.localhost/u/two)\"\n      expect(UserNotifications.participants(posts.last, user3)).to eq(I18n.t(\"user_notifications.more_pm_participants\", participants: list, count: 2))\n    end\n\n    it \"orders groups by user count\" do\n      SiteSetting.max_participant_names = 3\n      topic.allowed_groups = [group1, group2, group3]\n\n      list = \"[group1 (3)](http://test.localhost/g/group1), [group3 (2)](http://test.localhost/g/group3), [group2 (1)](http://test.localhost/g/group2)\"\n      expect(UserNotifications.participants(posts.last, user3)).to eq(I18n.t(\"user_notifications.more_pm_participants\", participants: list, count: 4))\n    end\n\n    it \"orders users by their last reply and user id\" do\n      expect(UserNotifications.participants(posts[-3], user4)).to eq(\"[group1 (3)](http://test.localhost/g/group1), \" \\\n        \"[two](http://test.localhost/u/two), [one](http://test.localhost/u/one), [three](http://test.localhost/u/three), \" \\\n        \"[admin](http://test.localhost/u/admin)\")\n    end\n\n    it \"prefers full group names when available\" do\n      SiteSetting.max_participant_names = 2\n      topic.allowed_groups = [group1, group2]\n\n      group2.update!(full_name: \"Awesome Group\")\n\n      list = \"[group1 (3)](http://test.localhost/g/group1), [Awesome Group (1)](http://test.localhost/g/group2)\"\n      expect(UserNotifications.participants(posts.last, user3)).to eq(I18n.t(\"user_notifications.more_pm_participants\", participants: list, count: 4))\n    end\n\n    it \"always uses usernames when prioritize_username_in_ux is enabled\" do\n      user4.update!(name: \"James Bond\")\n      user1.update!(name: \"Indiana Jones\")\n\n      SiteSetting.prioritize_username_in_ux = true\n      expect(UserNotifications.participants(posts.last, user3)).to eq(\"[group1 (3)](http://test.localhost/g/group1), \" \\\n        \"[four](http://test.localhost/u/four), [two](http://test.localhost/u/two), [one](http://test.localhost/u/one), \" \\\n        \"[admin](http://test.localhost/u/admin)\")\n\n      SiteSetting.prioritize_username_in_ux = false\n      expect(UserNotifications.participants(posts.last, user3)).to eq(\"[group1 (3)](http://test.localhost/g/group1), \" \\\n        \"[James Bond](http://test.localhost/u/four), [two](http://test.localhost/u/two), [Indiana Jones](http://test.localhost/u/one), \" \\\n        \"[admin](http://test.localhost/u/admin)\")\n    end\n\n    it \"reveals the email address of staged users if enabled\" do\n      user4.update!(staged: true, email: \"james.bond@mi6.invalid\")\n      user1.update!(staged: true, email: \"indiana.jones@example.com\")\n\n      SiteSetting.prioritize_username_in_ux = true\n      expect(UserNotifications.participants(posts.last, user3, reveal_staged_email: true)).to eq( \\\n        \"[group1 (3)](http://test.localhost/g/group1), james.bond@mi6.invalid, [two](http://test.localhost/u/two), \" \\\n        \"indiana.jones@example.com, [admin](http://test.localhost/u/admin)\")\n    end\n\n    it \"does only include human users\" do\n      topic.allowed_users << Discourse.system_user\n\n      expect(UserNotifications.participants(posts.last, user3)).to eq(\"[group1 (3)](http://test.localhost/g/group1), \" \\\n        \"[four](http://test.localhost/u/four), [two](http://test.localhost/u/two), [one](http://test.localhost/u/one), \" \\\n        \"[admin](http://test.localhost/u/admin)\")\n    end\n  end\n\n  describe \".account_silenced\" do\n    fab!(:user_history) { Fabricate(:user_history, action: UserHistory.actions[:silence_user]) }\n\n    it \"adds the silenced_till date in user's timezone\" do\n      user.user_option.timezone = \"Asia/Tbilisi\" # GMT+4\n      user.silenced_till = DateTime.parse(\"May 25, 2020, 12:00pm\")\n\n      mail = UserNotifications.account_silenced(user, { user_history: user_history })\n\n      expect(mail.body).to include(\"May 25, 2020,  4:00pm\")\n    end\n\n    context \"when user doesn't have timezone set\" do\n      before do\n        user.user_option.timezone = nil\n      end\n\n      it \"doesn't raise error\" do\n        expect { UserNotifications.account_silenced(user) }.not_to raise_error\n      end\n\n      it \"adds the silenced_till date in UTC\" do\n        date = \"May 25, 2020, 12:00pm\"\n        user.silenced_till = DateTime.parse(date)\n\n        mail = UserNotifications.account_silenced(user, { user_history: user_history })\n\n        expect(mail.body).to include(date)\n      end\n    end\n  end\n\n  describe \".account_suspended\" do\n    fab!(:user_history) { Fabricate(:user_history, action: UserHistory.actions[:suspend_user]) }\n\n    it \"adds the suspended_till date in user's timezone\" do\n      user.user_option.timezone = \"Asia/Tbilisi\" # GMT+4\n      user.suspended_till = DateTime.parse(\"May 25, 2020, 12:00pm\")\n\n      mail = UserNotifications.account_suspended(user, { user_history: user_history })\n\n      expect(mail.body).to include(\"May 25, 2020,  4:00pm\")\n    end\n\n    context \"when user doesn't have timezone set\" do\n      before do\n        user.user_option.timezone = nil\n      end\n\n      it \"doesn't raise error\" do\n        expect { UserNotifications.account_suspended(user) }.not_to raise_error\n      end\n\n      it \"adds the suspended_till date in UTC\" do\n        date = \"May 25, 2020, 12:00pm\"\n        user.suspended_till = DateTime.parse(date)\n\n        mail = UserNotifications.account_suspended(user, { user_history: user_history })\n\n        expect(mail.body).to include(date)\n      end\n    end\n  end\nend\n"], "filenames": ["app/mailers/user_notifications.rb", "spec/mailers/user_notifications_spec.rb"], "buggy_code_start_loc": [536, 301], "buggy_code_end_loc": [541, 378], "fixing_code_start_loc": [536, 301], "fixing_code_end_loc": [543, 388], "type": "CWE-200", "message": "Discourse is an open-source discussion platform. Prior to version 2.8.13 of the `stable` branch and version 2.9.0.beta14 of the `beta` and `tests-passed` branches, unauthorized users may learn of the existence of hidden tags and that they have been applied to topics that they have access to. This issue is patched in version 2.8.13 of the `stable` branch and version 2.9.0.beta14 of the `beta` and `tests-passed` branches. As a workaround, use the `disable_email` site setting to disable all emails to non-staff users.", "other": {"cve": {"id": "CVE-2022-46150", "sourceIdentifier": "security-advisories@github.com", "published": "2022-11-29T18:15:10.467", "lastModified": "2022-12-01T21:57:34.653", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Discourse is an open-source discussion platform. Prior to version 2.8.13 of the `stable` branch and version 2.9.0.beta14 of the `beta` and `tests-passed` branches, unauthorized users may learn of the existence of hidden tags and that they have been applied to topics that they have access to. This issue is patched in version 2.8.13 of the `stable` branch and version 2.9.0.beta14 of the `beta` and `tests-passed` branches. As a workaround, use the `disable_email` site setting to disable all emails to non-staff users."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.8.13", "matchCriteriaId": "140D3326-21AC-459D-8196-E17C9046AE3E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta1:*:*:*:*:*:*", "matchCriteriaId": "B3803EF9-A296-42B7-887F-93C5E68E94C4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta10:*:*:*:*:*:*", "matchCriteriaId": "35BAC488-3622-4B0B-B8EA-879E8C68E8CF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta11:*:*:*:*:*:*", "matchCriteriaId": "406A23B4-B971-4DC8-A132-EE9854FE8546"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta12:*:*:*:*:*:*", "matchCriteriaId": "1DD3C47F-E49F-4E19-9EA7-A322C4CFD541"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta13:*:*:*:*:*:*", "matchCriteriaId": "E924AC08-6978-4DFF-B616-9E3E9D6FBE1B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta2:*:*:*:*:*:*", "matchCriteriaId": "8BA3D313-3C11-43E2-A47D-CBB532D1B6F8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta3:*:*:*:*:*:*", "matchCriteriaId": "6F42673E-65F3-4807-9484-20CB747420FB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta4:*:*:*:*:*:*", "matchCriteriaId": "0B91D023-FCE5-4866-AD8B-BBB675763104"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta5:*:*:*:*:*:*", "matchCriteriaId": "0086484D-0164-449C-8AAE-BE7479CB9706"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta6:*:*:*:*:*:*", "matchCriteriaId": "F9D1B031-96C7-44C0-A0A0-F67ABE55C93C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta7:*:*:*:*:*:*", "matchCriteriaId": "750D2AD9-35E7-4AC7-9C22-AA90DAA34F3F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta8:*:*:*:*:*:*", "matchCriteriaId": "B68E308A-BDAB-4614-A563-4460F7996CBE"}]}]}], "references": [{"url": "https://github.com/discourse/discourse/commit/84c83e8d4a1907f8a2972f0ab44b6402aa910c3b", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/discourse/discourse/security/advisories/GHSA-rqvq-94h8-p5wv", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/discourse/discourse/commit/84c83e8d4a1907f8a2972f0ab44b6402aa910c3b"}}