{"buggy_code": ["/********************************************************************************/\n/*                                                                              */\n/*                      NVRAM File Abstraction Layer                            */\n/*                           Written by Ken Goldman                             */\n/*                       Adapted to SWTPM by Stefan Berger                      */\n/*                     IBM Thomas J. Watson Research Center                     */\n/*                                                                              */\n/* (c) Copyright IBM Corporation 2006, 2010, 2014, 2015.\t\t\t*/\n/*\t\t\t\t\t\t\t\t\t\t*/\n/* All rights reserved.\t\t\t\t\t\t\t\t*/\n/* \t\t\t\t\t\t\t\t\t\t*/\n/* Redistribution and use in source and binary forms, with or without\t\t*/\n/* modification, are permitted provided that the following conditions are\t*/\n/* met:\t\t\t\t\t\t\t\t\t\t*/\n/* \t\t\t\t\t\t\t\t\t\t*/\n/* Redistributions of source code must retain the above copyright notice,\t*/\n/* this list of conditions and the following disclaimer.\t\t\t*/\n/* \t\t\t\t\t\t\t\t\t\t*/\n/* Redistributions in binary form must reproduce the above copyright\t\t*/\n/* notice, this list of conditions and the following disclaimer in the\t\t*/\n/* documentation and/or other materials provided with the distribution.\t\t*/\n/* \t\t\t\t\t\t\t\t\t\t*/\n/* Neither the names of the IBM Corporation nor the names of its\t\t*/\n/* contributors may be used to endorse or promote products derived from\t\t*/\n/* this software without specific prior written permission.\t\t\t*/\n/* \t\t\t\t\t\t\t\t\t\t*/\n/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\t\t*/\n/* \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\t\t*/\n/* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\t*/\n/* A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\t\t*/\n/* HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\t*/\n/* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\t\t*/\n/* LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\t*/\n/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\t*/\n/* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\t\t*/\n/* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\t*/\n/* OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\t\t*/\n/********************************************************************************/\n\n/* This module abstracts out all NVRAM read and write operations.\n\n   This implementation uses standard, portable C files.\n\n   The basic high level abstractions are:\n\n        SWTPM_NVRAM_LoadData();\n        SWTPM_NVRAM_StoreData();\n        SWTPM_NVRAM_DeleteName();\n\n   They take a 'name' that is mapped to a rooted file name.\n*/\n\n#include \"config.h\"\n\n#define _GNU_SOURCE\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <arpa/inet.h>\n#include <fcntl.h>\n\n#include <libtpms/tpm_error.h>\n#include <libtpms/tpm_memory.h>\n#include <libtpms/tpm_nvfilename.h>\n#include <libtpms/tpm_library.h>\n\n#include <openssl/sha.h>\n#include <openssl/rand.h>\n#if OPENSSL_VERSION_NUMBER >= 0x30000000L\n# include <openssl/core_names.h>\n#else\n# include <openssl/hmac.h>\n#endif\n\n#if defined(__OpenBSD__)\n # define OPENSSL_OLD_API\n#else\n #if OPENSSL_VERSION_NUMBER < 0x10100000\n  #define OPENSSL_OLD_API\n #endif\n#endif\n\n#include \"swtpm.h\"\n#include \"swtpm_aes.h\"\n#include \"swtpm_debug.h\"\n#include \"swtpm_nvstore.h\"\n#include \"swtpm_utils.h\"\n#include \"key.h\"\n#include \"logging.h\"\n#include \"tpmstate.h\"\n#include \"tpmlib.h\"\n#include \"tlv.h\"\n#include \"utils.h\"\n#include \"compiler_dependencies.h\"\n\n/* local structures */\ntypedef struct {\n    uint8_t  version;\n    uint8_t  min_version; /* min. required version */\n    uint16_t hdrsize;\n    uint16_t flags;\n    uint32_t totlen; /* length of the header and following data */\n} __attribute__((packed)) blobheader;\n\n#define BLOB_HEADER_VERSION 2\n\n/* flags for blobheader */\n#define BLOB_FLAG_ENCRYPTED              0x01\n#define BLOB_FLAG_MIGRATION_ENCRYPTED    0x02  /* encrypted with migration key */\n#define BLOB_FLAG_MIGRATION_DATA         0x04  /* migration data are available */\n#define BLOB_FLAG_ENCRYPTED_256BIT_KEY   0x08  /* 256 bit file key was used */\n#define BLOB_FLAG_MIGRATION_256BIT_KEY   0x10  /* 256 bit migration key was used */\n\ntypedef struct {\n    enum encryption_mode data_encmode;\n    TPM_SYMMETRIC_KEY_DATA symkey;\n} encryptionkey ;\n\nstatic encryptionkey filekey = {\n    .symkey = {\n        .userKeyLength = 0,\n    },\n};\n\nstatic encryptionkey migrationkey = {\n    .symkey = {\n        .userKeyLength = 0,\n    },\n};\n\nstatic uint32_t g_ivec_length;\nstatic unsigned char *g_ivec;\nstatic struct nvram_backend_ops *g_nvram_backend_ops;\n\n/* local prototypes */\n\nstatic TPM_RESULT SWTPM_NVRAM_EncryptData(const encryptionkey *key,\n                                          tlv_data *td,\n                                          size_t *td_len,\n                                          uint16_t tag_encrypted_data,\n                                          const unsigned char *decrypt_data,\n                                          uint32_t decrypt_length,\n                                          uint16_t tag_ivec);\n\nstatic TPM_RESULT SWTPM_NVRAM_GetDecryptedData(const encryptionkey *key,\n                                               unsigned char **decrypt_data,\n                                               uint32_t *decrypt_length,\n                                               const unsigned char *encrypt_data,\n                                               uint32_t encrypt_length,\n                                               uint16_t tag_decryped_data,\n                                               uint16_t tag_data,\n                                               uint8_t hdrversion,\n                                               uint16_t tag_ivec,\n                                               uint16_t hdrflags,\n                                               uint16_t flag_256bitkey);\n\nstatic TPM_RESULT SWTPM_NVRAM_PrependHeader(unsigned char **data,\n                                            uint32_t *length,\n                                            uint16_t flags);\n\nstatic TPM_RESULT SWTPM_NVRAM_CheckHeader(unsigned char *data, uint32_t length,\n                                          uint32_t *dataoffset,\n                                          uint16_t *hdrflags,\n                                          uint8_t *hdrversion,\n                                          bool quiet);\n\n/* SWTPM_NVRAM_Init() is called once at startup.  It does any NVRAM required initialization.\n\n   This function sets some static variables that are used by all TPM's.\n*/\n\nTPM_RESULT SWTPM_NVRAM_Init(void)\n{\n    const char  *backend_uri;\n    TPM_RESULT  rc = 0;\n    TPM_DEBUG(\" SWTPM_NVRAM_Init:\\n\");\n\n    backend_uri = tpmstate_get_backend_uri();\n    if (!backend_uri) {\n        logprintf(STDERR_FILENO,\n                  \"SWTPM_NVRAM_Init: Missing backend URI.\\n\");\n        rc = TPM_FAIL;\n    } else if (strncmp(backend_uri, \"dir://\", 6) == 0) {\n        g_nvram_backend_ops = &nvram_dir_ops;\n    } else if (strncmp(backend_uri, \"file://\", 7) == 0) {\n        g_nvram_backend_ops = &nvram_linear_ops;\n    } else {\n        logprintf(STDERR_FILENO,\n                  \"SWTPM_NVRAM_Init: Unsupported backend.\\n\");\n        rc = TPM_FAIL;\n    }\n\n    if (rc == 0)\n        rc = g_nvram_backend_ops->prepare(backend_uri);\n\n    return rc;\n}\n\nvoid SWTPM_NVRAM_Shutdown(void)\n{\n    if (g_nvram_backend_ops)\n        g_nvram_backend_ops->cleanup();\n    memset(&filekey, 0, sizeof(filekey));\n    memset(&migrationkey, 0, sizeof(migrationkey));\n}\n\n/* SWTPM_NVRAM_GetFilenameForName() constructs a file name from the name.\n * A temporary filename used to write to may be created. It should be rename()'d to\n * the non-temporary filename.\n */\n\nTPM_RESULT\nSWTPM_NVRAM_GetFilenameForName(char *filename,       /* output: filename */\n                               size_t bufsize,\n                               uint32_t tpm_number,\n                               const char *name,     /* input: abstract name */\n                               TPM_BOOL is_tempfile) /* input: is temporary file? */\n{\n    TPM_RESULT res = TPM_SUCCESS;\n    int n;\n    const char *suffix = \"\";\n\n    TPM_DEBUG(\" SWTPM_NVRAM_GetFilenameForName: For name %s\\n\", name);\n\n    switch (tpmstate_get_version()) {\n    case TPMLIB_TPM_VERSION_1_2:\n        break;\n    case TPMLIB_TPM_VERSION_2:\n        suffix = \"2\";\n        break;\n    }\n\n    if (is_tempfile) {\n        n = snprintf(filename, bufsize, \"TMP%s-%02lx.%s\", suffix, (unsigned long)tpm_number, name);\n    } else {\n        n = snprintf(filename, bufsize, \"tpm%s-%02lx.%s\", suffix, (unsigned long)tpm_number, name);\n    }\n    if ((size_t)n > bufsize) {\n        res = TPM_FAIL;\n    }\n\n    TPM_DEBUG(\"  SWTPM_NVRAM_GetFilenameForName: File name %s\\n\", filename);\n\n    return res;\n}\n\n\n/* Load 'data' of 'length' from the 'name'.\n\n   'data' must be freed after use.\n   \n   Returns\n        0 on success.\n        TPM_RETRY and NULL,0 on non-existent file (non-fatal, first time start up)\n        TPM_FAIL on failure to load (fatal), since it should never occur\n*/\n\nTPM_RESULT\nSWTPM_NVRAM_LoadData(unsigned char **data,     /* freed by caller */\n                     uint32_t *length,\n                     uint32_t tpm_number,\n                     const char *name)\n{\n    TPM_RESULT    rc = 0;\n    int           irc;\n    unsigned char *decrypt_data = NULL;\n    uint32_t      decrypt_length;\n    uint32_t      dataoffset = 0;\n    uint8_t       hdrversion = 0;\n    uint16_t      hdrflags;\n    const char    *backend_uri = NULL;\n\n    TPM_DEBUG(\" SWTPM_NVRAM_LoadData: From file %s\\n\", name);\n    *data = NULL;\n    *length = 0;\n\n    if (rc == 0) {\n        backend_uri = tpmstate_get_backend_uri();\n        rc = g_nvram_backend_ops->load(data, length, tpm_number, name,\n                                       backend_uri);\n    }\n\n    if (rc == 0) {\n        /* this function needs to return the plain data -- no tlv headers */\n\n        /* try to get a header from it -- old files may not have one */\n        irc = SWTPM_NVRAM_CheckHeader(*data, *length, &dataoffset,\n                                      &hdrflags, &hdrversion, true);\n        /* valid header -- this one can only be version 2 or later */\n        if (irc) {\n            hdrversion = 1; /* no header -- payload was written like vers. 1 */\n            hdrflags = 0;\n        }\n\n        rc = SWTPM_NVRAM_GetDecryptedData(&filekey,\n                                          &decrypt_data, &decrypt_length,\n                                          *data + dataoffset,\n                                          *length - dataoffset,\n                                          TAG_ENCRYPTED_DATA, TAG_DATA,\n                                          hdrversion,\n                                          TAG_IVEC_ENCRYPTED_DATA,\n                                          hdrflags,\n                                          BLOB_FLAG_ENCRYPTED_256BIT_KEY);\n        TPM_DEBUG(\" SWTPM_NVRAM_LoadData: SWTPM_NVRAM_GetDecryptedData rc = %d\\n\",\n                  rc);\n        if (rc != 0)\n            logprintf(STDERR_FILENO,\n                      \"SWTPM_NVRAM_LoadData: Error from SWTPM_NVRAM_GetDecryptedData \"\n                      \"rc = %d\\n\", rc);\n\n        if (rc == 0) {\n            TPM_DEBUG(\" SWTPM_NVRAM_LoadData: Decrypted %u bytes of \"\n                      \"data to %u bytes.\\n\",\n                      *length, decrypt_length);\n            free(*data);\n            *data = decrypt_data;\n            *length = decrypt_length;\n        }\n    }\n\n    if (rc != 0) {\n        free(*data);\n        *data = NULL;\n    }\n\n    return rc;\n}\n\n/* SWTPM_NVRAM_StoreData stores 'data' of 'length' to the rooted 'filename'\n\n   Returns\n        0 on success\n        TPM_FAIL for other fatal errors\n*/\n\nstatic TPM_RESULT\nSWTPM_NVRAM_StoreData_Intern(const unsigned char *data,\n                             uint32_t length,\n                             uint32_t tpm_number,\n                             const char *name,\n                             TPM_BOOL encrypt         /* encrypt if key is set */)\n{\n    TPM_RESULT    rc = 0;\n    unsigned char *filedata = NULL;\n    uint32_t      filedata_length = 0;\n    tlv_data      td[3];\n    size_t        td_len = 0;\n    uint16_t      flags = 0;\n    const char    *backend_uri = NULL;\n\n    TPM_DEBUG(\" SWTPM_NVRAM_StoreData: To name %s\\n\", name);\n\n    if (rc == 0) {\n        if (encrypt && SWTPM_NVRAM_Has_FileKey()) {\n            td_len = 3;\n            rc = SWTPM_NVRAM_EncryptData(&filekey, &td[0], &td_len,\n                                         TAG_ENCRYPTED_DATA, data, length,\n                                         TAG_IVEC_ENCRYPTED_DATA);\n            if (rc) {\n                logprintf(STDERR_FILENO,\n                          \"SWTPM_NVRAM_EncryptData failed: 0x%02x\\n\", rc);\n            } else {\n                TPM_DEBUG(\"  SWTPM_NVRAM_StoreData: Encrypted %u bytes before \"\n                          \"write, will write %u bytes\\n\", length,\n                          td[0].tlv.length);\n            }\n            flags |= BLOB_FLAG_ENCRYPTED;\n            if (SWTPM_NVRAM_FileKey_Size() == SWTPM_AES256_BLOCK_SIZE)\n                flags |= BLOB_FLAG_ENCRYPTED_256BIT_KEY;\n        } else {\n            td_len = 1;\n            td[0] = TLV_DATA_CONST(TAG_DATA, length, data);\n        }\n    }\n\n    if (rc == 0)\n        rc = tlv_data_append(&filedata, &filedata_length, td, td_len);\n\n    if (rc == 0)\n        rc = SWTPM_NVRAM_PrependHeader(&filedata, &filedata_length, flags);\n\n    if (rc == 0) {\n        backend_uri = tpmstate_get_backend_uri();\n        rc = g_nvram_backend_ops->store(filedata, filedata_length, tpm_number, name,\n                                        backend_uri);\n    }\n\n    tlv_data_free(td, td_len);\n    free(filedata);\n\n    TPM_DEBUG(\" SWTPM_NVRAM_StoreData: rc=%d\\n\", rc);\n\n    return rc;\n}\n\nTPM_RESULT SWTPM_NVRAM_StoreData(const unsigned char *data,\n                                 uint32_t length,\n                                 uint32_t tpm_number,\n                                 const char *name)\n{\n    return SWTPM_NVRAM_StoreData_Intern(data, length, tpm_number, name, TRUE);\n}\n\n/* SWTPM_NVRAM_DeleteName() deletes the 'name' from NVRAM\n\n   Returns:\n        0 on success, or if the file does not exist and mustExist is FALSE\n        TPM_FAIL if the file could not be removed, since this should never occur and there is\n                no recovery\n\n   NOTE: Not portable code, but supported by Linux and Windows\n*/\n\nTPM_RESULT SWTPM_NVRAM_DeleteName(uint32_t tpm_number,\n                                  const char *name,\n                                  TPM_BOOL mustExist)\n{\n    const char *backend_uri = NULL;\n    backend_uri = tpmstate_get_backend_uri();\n\n    return g_nvram_backend_ops->delete(tpm_number, name, mustExist,\n                                       backend_uri);\n}\n\n\nTPM_RESULT SWTPM_NVRAM_Store_Volatile(void)\n{\n    TPM_RESULT     rc = 0;\n    char           *name = TPM_VOLATILESTATE_NAME;\n    uint32_t       tpm_number = 0;\n    unsigned char  *buffer = NULL;\n    uint32_t       buflen;\n\n    TPM_DEBUG(\" SWTPM_Store_Volatile: Name %s\\n\", name);\n    if (rc == 0) {\n        rc = TPMLIB_VolatileAll_Store(&buffer, &buflen);\n    }\n    if (rc == 0) {\n        /* map name to the rooted filename */\n        rc = SWTPM_NVRAM_StoreData(buffer, buflen, tpm_number, name);\n    }\n\n    free(buffer);\n\n    return rc;\n}\n\nstatic TPM_RESULT\nSWTPM_NVRAM_KeyParamCheck(uint32_t keylen,\n                          enum encryption_mode encmode)\n{\n    TPM_RESULT rc = 0;\n\n    if (keylen != SWTPM_AES128_BLOCK_SIZE &&\n        keylen != SWTPM_AES256_BLOCK_SIZE) {\n        rc = TPM_BAD_KEY_PROPERTY;\n    }\n    switch (encmode) {\n    case ENCRYPTION_MODE_AES_CBC:\n        break;\n    case ENCRYPTION_MODE_UNKNOWN:\n        rc = TPM_BAD_MODE;\n    }\n\n    return rc;\n}\n\nsize_t SWTPM_NVRAM_FileKey_Size(void)\n{\n    return filekey.symkey.userKeyLength;\n}\n\nTPM_RESULT SWTPM_NVRAM_Set_FileKey(const unsigned char *key, uint32_t keylen,\n                                   enum encryption_mode encmode)\n{\n    TPM_RESULT rc;\n\n    rc = SWTPM_NVRAM_KeyParamCheck(keylen, encmode);\n\n    if (rc == 0) {\n        memcpy(filekey.symkey.userKey, key, keylen);\n        filekey.symkey.userKeyLength = keylen;\n        filekey.data_encmode = encmode;\n    }\n\n    return rc;\n}\n\nsize_t SWTPM_NVRAM_MigrationKey_Size(void)\n{\n    return migrationkey.symkey.userKeyLength;\n}\n\nTPM_RESULT SWTPM_NVRAM_Set_MigrationKey(const unsigned char *key,\n                                        uint32_t keylen,\n                                        enum encryption_mode encmode)\n{\n    TPM_RESULT rc;\n\n    rc = SWTPM_NVRAM_KeyParamCheck(keylen, encmode);\n\n    if (rc == 0) {\n        memcpy(migrationkey.symkey.userKey, key, keylen);\n        migrationkey.symkey.userKeyLength = keylen;\n        migrationkey.data_encmode = encmode;\n    }\n\n    return rc;\n}\n\n# if OPENSSL_VERSION_NUMBER >= 0x30000000L\n\nstatic int SWTPM_HMAC(unsigned char *md, unsigned int *md_len,\n                      const void *key, int key_len,\n                      const unsigned char *in, uint32_t in_length,\n                      const unsigned char *ivec, uint32_t ivec_length)\n{\n    OSSL_PARAM params[2];\n    EVP_MAC_CTX *ctx;\n    EVP_MAC *hmac;\n    size_t outl;\n    int ret = 0;\n\n    hmac = EVP_MAC_fetch(NULL, OSSL_MAC_NAME_HMAC, NULL);\n    if (!hmac)\n        return 0;\n\n    ctx = EVP_MAC_CTX_new(hmac);\n    if (!ctx)\n        goto err;\n\n    params[0] = OSSL_PARAM_construct_utf8_string(OSSL_ALG_PARAM_DIGEST,\n                                                 \"sha256\", 0);\n    params[1] = OSSL_PARAM_construct_end();\n\n    if (!EVP_MAC_init(ctx, key, key_len, params) ||\n        !EVP_MAC_update(ctx, in, in_length))\n        goto err;\n\n    if (ivec &&\n        !EVP_MAC_update(ctx, ivec, ivec_length))\n        goto err;\n\n    if (!EVP_MAC_final(ctx, md, &outl, *md_len))\n        goto err;\n    *md_len = outl;\n\n    ret = 1;\n\nerr:\n    EVP_MAC_CTX_free(ctx);\n    EVP_MAC_free(hmac);\n\n    return ret;\n}\n\n#else\n\nstatic int SWTPM_HMAC(unsigned char *md, unsigned int *md_len,\n                      const void *key, int key_len,\n                      const unsigned char *in, uint32_t in_length,\n                      const unsigned char *ivec, uint32_t ivec_length)\n{\n    int ret = 0;\n\n#if defined OPENSSL_OLD_API\n    HMAC_CTX sctx, *ctx = &sctx;\n\n    HMAC_CTX_init(ctx);\n#else\n    HMAC_CTX *ctx = HMAC_CTX_new();\n\n    if (!ctx)\n        return 0;\n#endif\n\n\n    if (!HMAC_Init_ex(ctx, key, key_len, EVP_sha256(), NULL) ||\n        !HMAC_Update(ctx, in, in_length))\n        goto err;\n\n    if (ivec &&\n        !HMAC_Update(ctx, ivec, ivec_length))\n        goto err;\n\n    if (!HMAC_Final(ctx, md, md_len))\n        goto err;\n\n    ret = 1;\n\nerr:\n#if defined OPENSSL_OLD_API\n    HMAC_CTX_cleanup(ctx);\n#else\n    HMAC_CTX_free(ctx);\n#endif\n\n    return ret;\n}\n#endif /* if OPENSSL_VERSION_NUMBER >= 0x30000000L */\n\n/*\n * SWTPM_RollAndSetGlobalIvec: Create an IV for the AES CBC algorithm to use\n *                             Create it with a random number every time.\n *                             and leave the pointer to the data in @td.\n *\n * @td: pointer to tlv_data to get pointer to the random data\n * @tag_ivec: tag for the IV tlv header\n * @ivec_length: number of bytes needed for the ivec\n */\nstatic TPM_RESULT SWTPM_RollAndSetGlobalIvec(tlv_data *td,\n                                             uint16_t tag_ivec,\n                                             uint32_t ivec_length)\n{\n    unsigned char data[16]; /* do not initialize */\n    unsigned char hashbuf[SHA256_DIGEST_LENGTH];\n    void *p;\n\n    if (g_ivec_length < ivec_length) {\n        p = realloc(g_ivec, ivec_length);\n        if (!p) {\n            *td = TLV_DATA_CONST(tag_ivec, 0, NULL);\n\n            logprintf(STDOUT_FILENO,\n                      \"Could not allocate %u bytes.\\n\", ivec_length);\n            return TPM_FAIL;\n        }\n        g_ivec = p;\n        g_ivec_length = ivec_length;\n    }\n\n    if (RAND_bytes(g_ivec, g_ivec_length) != 1) {\n        /* random data from stack to the rescue */\n        SHA256(g_ivec, g_ivec_length, hashbuf);\n        SHA256(data, sizeof(data), hashbuf);\n        memcpy(g_ivec, hashbuf,\n               g_ivec_length < sizeof(hashbuf)\n                   ? g_ivec_length\n                   : sizeof(hashbuf));\n    }\n\n    *td = TLV_DATA_CONST(tag_ivec, g_ivec_length, g_ivec);\n\n    return 0;\n}\n\n/*\n * SWTPM_GetIvec: Get the encryption IV from the data stream. If none is\n *                found a NULL pointer is set in *ivec, otherwise a pointer\n *                to the beginning of the IV and its length are returned.\n */\nstatic void SWTPM_GetIvec(const unsigned char *data, uint32_t length,\n                          const unsigned char **ivec, uint32_t *ivec_length,\n                          uint16_t tag)\n{\n    tlv_data td;\n\n    if (!tlv_data_find_tag(data, length, tag, &td)) {\n        *ivec = NULL;\n    } else {\n        *ivec = td.u.const_ptr;\n        *ivec_length = td.tlv.length;\n    }\n}\n\n/*\n * SWTPM_CalcHMAC\n *\n * @in: input buffer to calculate HMAC on\n * @in_length: length of input buffer\n * @td: pointer to a tlv_data structure to receive the result with the\n *      tag, length, and pointer to an allocated buffer holding the HMAC\n * @tpm_symmetric_key_token: symmetric key\n * @ivec: the IV for AES CBC\n * @ivec_length: the length of the IV\n *\n * Calculate an HMAC on the input buffer with payload and create an output\n * buffer with the HMAC\n */\nstatic TPM_RESULT\nSWTPM_CalcHMAC(const unsigned char *in, uint32_t in_length,\n               tlv_data *td,\n               const TPM_SYMMETRIC_KEY_DATA *tpm_symmetric_key_token,\n               const unsigned char *ivec, uint32_t ivec_length)\n{\n    TPM_RESULT rc = 0;\n    unsigned char md[EVP_MAX_MD_SIZE];\n    unsigned int md_len = sizeof(md);\n    unsigned char *buffer = NULL;\n\n    if (!SWTPM_HMAC(md, &md_len,\n                    tpm_symmetric_key_token->userKey,\n                    tpm_symmetric_key_token->userKeyLength,\n                    in, in_length, ivec, ivec_length)) {\n        logprintf(STDOUT_FILENO, \"HMAC calculation failed.\\n\");\n        return TPM_FAIL;\n    }\n\n    buffer = malloc(md_len);\n\n    if (buffer) {\n        *td = TLV_DATA(TAG_HMAC, md_len, buffer);\n        memcpy(buffer, md, md_len);\n    } else {\n       logprintf(STDOUT_FILENO,\n                 \"Could not allocate %u bytes.\\n\", md_len);\n       rc = TPM_FAIL;\n    }\n\n    return rc;\n}\n\n/*\n * SWTPM_CheckHMAC:\n *\n * @hmac: tlv_data with pointer to hmac bytes\n * @encrypted_data: tlv_data with pointer to encrypted data bytes\n * @tpm_symmetric_key_token: symmetric key\n * @ivec: the IV for AES CBC\n * @ivec_length: the length of the IV\n *\n * Verify the HMAC given the expected @hmac and the @tpm_symmetric_key_token\n * to calculate the HMAC over the @encrypted_data.\n */\nstatic TPM_RESULT\nSWTPM_CheckHMAC(tlv_data *hmac, tlv_data *encrypted_data,\n                const TPM_SYMMETRIC_KEY_DATA *tpm_symmetric_key_token,\n                const unsigned char *ivec, uint32_t ivec_length)\n{\n    const unsigned char *data;\n    uint32_t data_length;\n    unsigned int md_len;\n    unsigned char md[EVP_MAX_MD_SIZE];\n\n    md_len = EVP_MD_size(EVP_sha256());\n    if (md_len > hmac->tlv.length) {\n        logprintf(STDOUT_FILENO, \"Insufficient bytes for CheckHMAC()\\n\");\n        return TPM_FAIL;\n    }\n\n    data = encrypted_data->u.ptr;\n    data_length = encrypted_data->tlv.length;\n\n    if (!SWTPM_HMAC(md, &md_len,\n                    tpm_symmetric_key_token->userKey,\n                    tpm_symmetric_key_token->userKeyLength,\n                    data, data_length, ivec, ivec_length)) {\n        logprintf(STDOUT_FILENO, \"HMAC() call failed.\\n\");\n        return TPM_FAIL;\n    }\n\n    if (memcmp(hmac->u.ptr, md, md_len)) {\n        logprintf(STDOUT_FILENO, \"Verification of HMAC failed. \"\n                  \"Data integrity is compromised\\n\");\n        /* TPM_DECRYPT_ERROR indicates (to libtpms) that something\n           exists but we have the wrong key. */\n        return TPM_DECRYPT_ERROR;\n    }\n\n    return TPM_SUCCESS;\n}\n\n/*\n * SWTPM_CheckHash:\n *\n * @in: input buffer\n * @in_length: input buffer length\n * @out: output buffer\n * @out_length: output buffer length\n */\nstatic TPM_RESULT\nSWTPM_CheckHash(const unsigned char *in, uint32_t in_length,\n                unsigned char **out, uint32_t *out_length)\n{\n    TPM_RESULT rc = 0;\n    unsigned char *dest = NULL;\n    unsigned char hashbuf[SHA256_DIGEST_LENGTH];\n    const unsigned char *data = &in[sizeof(hashbuf)];\n    uint32_t data_length = in_length - sizeof(hashbuf);\n\n    /* hash the data */\n    SHA256(data, data_length, hashbuf);\n\n    if (memcmp(in, hashbuf, sizeof(hashbuf))) {\n        logprintf(STDOUT_FILENO, \"Verification of hash failed. \"\n                  \"Data integrity is compromised\\n\");\n        rc = TPM_FAIL;\n    }\n\n    if (rc == 0) {\n        dest = malloc(data_length);\n        if (dest) {\n            *out = dest;\n            *out_length = data_length;\n            memcpy(dest, data, data_length);\n        } else {\n            logprintf(STDOUT_FILENO,\n                      \"Could not allocated %u bytes.\\n\", data_length);\n            rc = TPM_FAIL;\n        }\n    }\n\n    return rc;\n}\n\nstatic TPM_RESULT\nSWTPM_NVRAM_EncryptData(const encryptionkey *key,\n                        struct tlv_data *td, /* must provide 2 array members */\n                        size_t *td_len,\n                        uint16_t tag_encrypted_data,\n                        const unsigned char *data, uint32_t length,\n                        uint16_t tag_ivec)\n{\n    TPM_RESULT rc = 0;\n    TPM_RESULT irc;\n    unsigned char *tmp_data = NULL;\n    uint32_t tmp_length = 0;\n\n    *td_len = 0;\n\n    if (key->symkey.userKeyLength > 0) {\n        switch (key->data_encmode) {\n        case ENCRYPTION_MODE_UNKNOWN:\n            rc = TPM_BAD_MODE;\n            break;\n        case ENCRYPTION_MODE_AES_CBC:\n            irc = SWTPM_RollAndSetGlobalIvec(&td[2], tag_ivec,\n                                             key->symkey.userKeyLength);\n            rc = SWTPM_SymmetricKeyData_Encrypt(&tmp_data, &tmp_length,\n                                                data, length, &key->symkey,\n                                                td[2].u.const_ptr,\n                                                td[2].tlv.length);\n            if (rc)\n                 break;\n\n            rc = SWTPM_CalcHMAC(tmp_data, tmp_length, &td[1], &key->symkey,\n                                td[2].u.const_ptr, td[2].tlv.length);\n            if (rc == 0) {\n                td[0] = TLV_DATA(tag_encrypted_data, tmp_length, tmp_data);\n                /* in case we couldn't get an IV */\n                *td_len = (irc == 0) ? 3 : 2;\n                tmp_data = NULL;\n            }\n            break;\n        }\n    }\n\n    if (rc)\n        tlv_data_free(td, *td_len);\n\n    free(tmp_data);\n\n    return rc;\n}\n\nstatic TPM_RESULT\nSWTPM_NVRAM_DecryptData(const encryptionkey *key,\n                        unsigned char **decrypt_data, uint32_t *decrypt_length,\n                        const unsigned char *data, uint32_t length,\n                        uint16_t tag_encrypted_data,\n                        uint8_t hdrversion,\n                        uint16_t tag_ivec, uint16_t hdrflags,\n                        uint16_t flag_256bitkey)\n{\n    TPM_RESULT rc = 0;\n    unsigned char *tmp_data = NULL;\n    uint32_t tmp_length = 0;\n    tlv_data td[2];\n    const unsigned char *ivec = NULL;\n    uint32_t ivec_length = 0;\n    size_t keylen;\n\n    if (key->symkey.userKeyLength > 0) {\n        switch (key->data_encmode) {\n        case ENCRYPTION_MODE_UNKNOWN:\n            rc = TPM_BAD_MODE;\n            break;\n        case ENCRYPTION_MODE_AES_CBC:\n            switch (hdrversion) {\n            case 1:\n                rc = SWTPM_SymmetricKeyData_Decrypt(&tmp_data,\n                                                    &tmp_length,\n                                                    data, length,\n                                                    &key->symkey,\n                                                    NULL, 0);\n                if (rc == 0) {\n                    rc = SWTPM_CheckHash(tmp_data, tmp_length,\n                                         decrypt_data, decrypt_length);\n                }\n            break;\n            case 2:\n                keylen = (hdrflags & flag_256bitkey)\n                          ? SWTPM_AES256_BLOCK_SIZE : SWTPM_AES128_BLOCK_SIZE;\n                if (keylen != key->symkey.userKeyLength) {\n                    logprintf(STDERR_FILENO,\n                              \"Wrong decryption key. Need %zu bit key.\\n\",\n                              keylen * 8);\n                    rc = TPM_BAD_KEY_PROPERTY;\n                    break;\n                }\n\n                if (!tlv_data_find_tag(data, length, TAG_HMAC, &td[0]) ||\n                    !tlv_data_find_tag(data, length, tag_encrypted_data,\n                                       &td[1])) {\n                    logprintf(STDERR_FILENO,\n                              \"Could not find HMAC or encrypted data (tag %u) \"\n                              \"in byte stream.\\n\", tag_encrypted_data);\n                    rc = TPM_FAIL;\n                    break;\n                }\n                /* get the IV, if there is one */\n                SWTPM_GetIvec(data, length, &ivec, &ivec_length, tag_ivec);\n\n                rc = SWTPM_CheckHMAC(&td[0], &td[1], &key->symkey,\n                                     ivec, ivec_length);\n                if (rc == 0) {\n                    rc = SWTPM_SymmetricKeyData_Decrypt(decrypt_data,\n                                                        decrypt_length,\n                                                        td[1].u.const_ptr,\n                                                        td[1].tlv.length,\n                                                        &key->symkey,\n                                                        ivec, ivec_length);\n                }\n            break;\n            default:\n                rc = TPM_FAIL;\n            }\n            free(tmp_data);\n        }\n    }\n\n    return rc;\n}\n\nstatic TPM_RESULT\nSWTPM_NVRAM_GetPlainData(unsigned char **plain, uint32_t *plain_length,\n                         const unsigned char *data, uint32_t length,\n                         uint16_t tag_data,\n                         uint8_t hdrversion)\n{\n    TPM_RESULT rc = 0;\n    tlv_data td[1];\n\n    switch (hdrversion) {\n    case 1:\n        *plain = malloc(length);\n        if (*plain) {\n            memcpy(*plain, data, length);\n            *plain_length = length;\n        } else {\n            logprintf(STDERR_FILENO,\n                      \"Could not allocate %u bytes.\\n\", length);\n            rc = TPM_FAIL;\n        }\n    break;\n\n    case 2:\n        if (!tlv_data_find_tag(data, length, tag_data, &td[0])) {\n            logprintf(STDERR_FILENO,\n                      \"Could not find plain data in byte stream.\\n\");\n            rc = TPM_FAIL;\n            break;\n        }\n        *plain = malloc(td->tlv.length);\n        if (*plain) {\n            memcpy(*plain, td->u.const_ptr, td->tlv.length);\n            *plain_length = td->tlv.length;\n        } else {\n            logprintf(STDERR_FILENO,\n                      \"Could not allocate %u bytes.\\n\", td->tlv.length);\n            rc = TPM_FAIL;\n        }\n    break;\n    }\n\n    return rc;\n}\n\n/*\n * SWTPM_NVRAM_GetDecryptedData: Get the decrytped data either by just returning\n *                               the data if they were not encrypted or by\n *                               actually decrypting them if there is a key.\n *                               The plain data is returned, meaning any TLV\n *                               header has been removed.\n * @key: the encryption key, may be NULL\n * @decrypt_data: pointer to a pointer for the result\n * @decrypt_length: the length of the returned data\n * @data: input data\n * @length: length of the input data\n * @tag_encrypted_data: the tag the encrypted data is stored with\n * @tag_data: the tag the plain data is stored with\n * @hdrversion: the version found in the header that determines in what\n *              format the data is stored; tag-length-value is the format\n *              in v2\n * @tag_ivec: the tag for finding the IV\n * @hdrflags: the flags from the header\n * @flag_256bitkey: the flag in the header to check whether we expect a\n *                  256 bit key; different flag for migration and state key\n */\nstatic TPM_RESULT\nSWTPM_NVRAM_GetDecryptedData(const encryptionkey *key,\n                             unsigned char **decrypt_data,\n                             uint32_t *decrypt_length,\n                             const unsigned char *data,\n                             uint32_t length,\n                             uint16_t tag_encrypted_data,\n                             uint16_t tag_data,\n                             uint8_t hdrversion,\n                             uint16_t tag_ivec,\n                             uint16_t hdrflags,\n                             uint16_t flag_256bitkey)\n{\n    if (key && key->symkey.userKeyLength > 0) {\n        /* we assume the data are encrypted when there's a key given */\n        return SWTPM_NVRAM_DecryptData(key, decrypt_data, decrypt_length,\n                                       data, length, tag_encrypted_data,\n                                       hdrversion, tag_ivec, hdrflags,\n                                       flag_256bitkey);\n    }\n    return SWTPM_NVRAM_GetPlainData(decrypt_data, decrypt_length,\n                                    data, length, tag_data, hdrversion);\n}\n\n/*\n * Prepend a header in front of the state blob\n */\nstatic TPM_RESULT\nSWTPM_NVRAM_PrependHeader(unsigned char **data, uint32_t *length,\n                          uint16_t flags)\n{\n    unsigned char *out = NULL;\n    uint32_t out_len = sizeof(blobheader) + *length;\n    blobheader bh = {\n        .version = BLOB_HEADER_VERSION,\n        .min_version = 1,\n        .hdrsize = htons(sizeof(bh)),\n        .flags = htons(flags),\n        .totlen = htonl(out_len),\n    };\n    TPM_RESULT res;\n\n    out = malloc(out_len);\n    if (!out) {\n        logprintf(STDERR_FILENO,\n                  \"Could not allocate %u bytes.\\n\", out_len);\n        res = TPM_FAIL;\n        goto error;\n    }\n\n    memcpy(out, &bh, sizeof(bh));\n    memcpy(&out[sizeof(bh)], *data, *length);\n\n    free(*data);\n\n    *data = out;\n    *length = out_len;\n\n    return TPM_SUCCESS;\n\n error:\n    free(*data);\n    *data = NULL;\n    *length = 0;\n\n    return res;\n}\n\n\nstatic TPM_RESULT\nSWTPM_NVRAM_CheckHeader(unsigned char *data, uint32_t length,\n                        uint32_t *dataoffset, uint16_t *hdrflags,\n                        uint8_t *hdrversion, bool quiet)\n{\n    blobheader *bh = (blobheader *)data;\n\n    if (length < sizeof(bh)) {\n        if (!quiet)\n            logprintf(STDERR_FILENO,\n                      \"not enough bytes for header: %u\\n\", length);\n        return TPM_BAD_PARAMETER;\n    }\n\n    if (ntohl(bh->totlen) != length) {\n        if (!quiet)\n            logprintf(STDERR_FILENO,\n                      \"broken header: bh->totlen %u != %u\\n\",\n                      htonl(bh->totlen), length);\n        return TPM_BAD_PARAMETER;\n    }\n\n    if (bh->min_version > BLOB_HEADER_VERSION) {\n        if (!quiet)\n            logprintf(STDERR_FILENO,\n                      \"Minimum required version for the blob is %d, we \"\n                      \"only support version %d\\n\", bh->min_version,\n                      BLOB_HEADER_VERSION);\n        return TPM_BAD_VERSION;\n    }\n\n    *hdrversion = bh->version;\n    *dataoffset = ntohs(bh->hdrsize);\n    *hdrflags = ntohs(bh->flags);\n\n    return TPM_SUCCESS;\n}\n\n/*\n * Get the state blob with the current name; read it from the filesystem.\n * Decrypt it if the caller asks for it and if a key is set. Return\n * whether it's still encrypyted.\n */\nTPM_RESULT SWTPM_NVRAM_GetStateBlob(unsigned char **data,\n                                    uint32_t *length,\n                                    uint32_t tpm_number,\n                                    const char *name,\n                                    TPM_BOOL decrypt,\n                                    TPM_BOOL *is_encrypted)\n{\n    TPM_RESULT res;\n    uint16_t flags = 0;\n    tlv_data td[3];\n    size_t td_len;\n    unsigned char *plain = NULL, *buffer = NULL;\n    uint32_t plain_len, buffer_len = 0;\n\n    *data = NULL;\n    *length = 0;\n\n    res = SWTPM_NVRAM_LoadData(&plain, &plain_len, tpm_number, name);\n    if (res)\n        return res;\n\n    /* @plain contains unencrypted data without tlv headers */\n\n    /* if the user doesn't want decryption and there's a file key, we need to\n       encrypt the data */\n    if (!decrypt && SWTPM_NVRAM_Has_FileKey()) {\n        td_len = 3;\n        res = SWTPM_NVRAM_EncryptData(&filekey, &td[0], &td_len,\n                                      TAG_ENCRYPTED_DATA, plain, plain_len,\n                                      TAG_IVEC_ENCRYPTED_DATA);\n        if (res)\n            goto err_exit;\n\n        *is_encrypted = TRUE;\n        if (SWTPM_NVRAM_FileKey_Size() == SWTPM_AES256_BLOCK_SIZE)\n            flags |= BLOB_FLAG_ENCRYPTED_256BIT_KEY;\n    } else {\n        *is_encrypted = FALSE;\n        td[0] = TLV_DATA(TAG_DATA, plain_len, plain);\n        plain = NULL;\n        td_len = 1;\n    }\n\n    res = tlv_data_append(&buffer, &buffer_len, td, td_len);\n    if (res)\n        goto err_exit;\n\n    tlv_data_free(td, td_len);\n\n    /* @buffer contains tlv data */\n\n    if (SWTPM_NVRAM_Has_MigrationKey()) {\n        /* we have to encrypt it now with the migration key */\n        flags |= BLOB_FLAG_MIGRATION_ENCRYPTED;\n        if (SWTPM_NVRAM_MigrationKey_Size() == SWTPM_AES256_BLOCK_SIZE)\n             flags |= BLOB_FLAG_MIGRATION_256BIT_KEY;\n\n        td_len = 3;\n        res = SWTPM_NVRAM_EncryptData(&migrationkey, &td[0], &td_len,\n                                      TAG_ENCRYPTED_MIGRATION_DATA,\n                                      buffer, buffer_len,\n                                      TAG_IVEC_ENCRYPTED_MIGRATION_DATA);\n        if (res)\n            goto err_exit;\n    } else {\n        td[0] = TLV_DATA(TAG_MIGRATION_DATA, buffer_len, buffer);\n        buffer = NULL;\n        td_len = 1;\n    }\n    flags |= BLOB_FLAG_MIGRATION_DATA;\n\n    res = tlv_data_append(data, length, td, td_len);\n    if (res)\n        goto err_exit;\n\n    /* put the header in clear text */\n    if (*is_encrypted)\n        flags |= BLOB_FLAG_ENCRYPTED;\n\n    res = SWTPM_NVRAM_PrependHeader(data, length, flags);\n\nerr_exit:\n    tlv_data_free(td, td_len);\n    free(buffer);\n    free(plain);\n\n    return res;\n}\n\n/*\n * Set the state blob with the given name; the caller tells us if\n * the blob is encrypted; if it is encrypted, it will be written\n * into the file as-is, otherwise it will be encrypted if a key is set.\n */\nTPM_RESULT SWTPM_NVRAM_SetStateBlob(unsigned char *data,\n                                    uint32_t length,\n                                    TPM_BOOL is_encrypted,\n                                    uint32_t tpm_number SWTPM_ATTR_UNUSED,\n                                    uint32_t blobtype)\n{\n    TPM_RESULT res;\n    uint32_t dataoffset;\n    unsigned char *plain = NULL, *mig_decrypt = NULL;\n    uint32_t plain_len = 0, mig_decrypt_len = 0;\n    uint16_t hdrflags;\n    enum TPMLIB_StateType st = tpmlib_blobtype_to_statetype(blobtype);\n    const char *blobname = tpmlib_get_blobname(blobtype);\n    uint8_t hdrversion;\n\n    if (st == 0) {\n        logprintf(STDERR_FILENO,\n                  \"Unknown blob type %u\\n\", blobtype);\n        return TPM_BAD_PARAMETER;\n    }\n\n    if (length == 0)\n        return TPMLIB_SetState(st, NULL, 0);\n\n    res = SWTPM_NVRAM_CheckHeader(data, length, &dataoffset, &hdrflags,\n                                  &hdrversion, false);\n    if (res != TPM_SUCCESS)\n        return res;\n\n    if (length - dataoffset == 0)\n        return TPMLIB_SetState(st, NULL, 0);\n\n    /*\n     * We allow setting of blobs that were not encrypted before;\n     * we just will not decrypt them even if the migration key is\n     * set. This allows to 'upgrade' to encryption. 'Downgrading'\n     * will not be possible once a migration key was used.\n     */\n    if ((hdrflags & BLOB_FLAG_MIGRATION_ENCRYPTED)) {\n        /*\n         * we first need to decrypt the data with the migration key\n         */\n        if (!SWTPM_NVRAM_Has_MigrationKey()) {\n            logprintf(STDERR_FILENO,\n                      \"Missing migration key to decrypt %s\\n\", blobname);\n            return TPM_KEYNOTFOUND;\n        }\n\n        res = SWTPM_NVRAM_DecryptData(&migrationkey,\n                                      &mig_decrypt, &mig_decrypt_len,\n                                      &data[dataoffset], length - dataoffset,\n                                      TAG_ENCRYPTED_MIGRATION_DATA,\n                                      hdrversion,\n                                      TAG_IVEC_ENCRYPTED_MIGRATION_DATA,\n                                      hdrflags, BLOB_FLAG_MIGRATION_256BIT_KEY);\n        if (res) {\n            logprintf(STDERR_FILENO,\n                      \"Decrypting the %s blob with the migration key failed; \"\n                      \"res = %d\\n\", blobname, res);\n            return res;\n        }\n    } else {\n        res = SWTPM_NVRAM_GetPlainData(&mig_decrypt, &mig_decrypt_len,\n                                       &data[dataoffset], length - dataoffset,\n                                       TAG_MIGRATION_DATA,\n                                       hdrversion);\n        if (res)\n            return res;\n    }\n\n    /*\n     * Migration key has decrytped the data; if they are still encrypted\n     * with the state encryption key, we need to decrypt them using that\n     * key now.\n     */\n    if (is_encrypted || (hdrflags & BLOB_FLAG_ENCRYPTED)) {\n        if (!SWTPM_NVRAM_Has_FileKey()) {\n            logprintf(STDERR_FILENO,\n                      \"Missing state key to decrypt %s\\n\", blobname);\n            res = TPM_KEYNOTFOUND;\n            goto cleanup;\n        }\n\n        res = SWTPM_NVRAM_DecryptData(&filekey, &plain, &plain_len,\n                                      mig_decrypt, mig_decrypt_len,\n                                      TAG_ENCRYPTED_DATA,\n                                      hdrversion, TAG_IVEC_ENCRYPTED_DATA,\n                                      hdrflags, BLOB_FLAG_ENCRYPTED_256BIT_KEY);\n        if (res) {\n            logprintf(STDERR_FILENO,\n                      \"Decrypting the %s blob with the state key \"\n                      \"failed; res = %d\\n\", blobname, res);\n            goto cleanup;\n        }\n    } else {\n        res = SWTPM_NVRAM_GetPlainData(&plain, &plain_len,\n                                       mig_decrypt, mig_decrypt_len,\n                                       TAG_DATA,\n                                       hdrversion);\n        if (res)\n            goto cleanup;\n    }\n\n    /* SetState will make a copy of the buffer */\n    res = TPMLIB_SetState(st, plain, plain_len);\n\n    free(plain);\n\ncleanup:\n    free(mig_decrypt);\n\n    return res;\n}\n\n/* Example JSON output:\n *  { \"type\": \"swtpm\",\n *    \"states\": [ \"permall\", \"volatilestate\", \"savestate\" ]\n *  }\n */\nint SWTPM_NVRAM_PrintJson(void)\n{\n    TPM_RESULT rc = 0;\n    const char *backend_uri;\n    const char *states[] = {\n        TPM_PERMANENT_ALL_NAME,\n        TPM_VOLATILESTATE_NAME,\n        TPM_SAVESTATE_NAME,\n    };\n    char state_str[200] = \"\";\n    size_t i, n, o, blobsize;\n    int ret = -1;\n\n    rc = SWTPM_NVRAM_Init();\n    if (rc == 0) {\n        o = 0;\n        backend_uri = tpmstate_get_backend_uri();\n\n        for (i = 0; i < ARRAY_LEN(states); i++) {\n            rc = g_nvram_backend_ops->check_state(backend_uri, states[i],\n                                                  &blobsize);\n            if (rc == TPM_SUCCESS) {\n                n = snprintf(&state_str[o], sizeof(state_str) - o,\n                             \"%s {\\\"name\\\": \\\"%s\\\", \\\"size\\\": %zu}\",\n                             (o > 0) ? \",\" : \"\",\n                             states[i], blobsize);\n                if (n >= sizeof(state_str) - o)\n                    goto exit;\n                o += n;\n            } else if (rc != TPM_RETRY) {\n                /* Error other than ENOENT */\n                goto exit;\n            }\n        }\n        printf(\"{ \\\"type\\\": \\\"swtpm\\\", \\\"states\\\": [%s%s] }\",\n               state_str,  (o > 0) ? \" \": \"\");\n        ret = 0;\n    }\n\nexit:\n    return ret;\n}\n"], "fixing_code": ["/********************************************************************************/\n/*                                                                              */\n/*                      NVRAM File Abstraction Layer                            */\n/*                           Written by Ken Goldman                             */\n/*                       Adapted to SWTPM by Stefan Berger                      */\n/*                     IBM Thomas J. Watson Research Center                     */\n/*                                                                              */\n/* (c) Copyright IBM Corporation 2006, 2010, 2014, 2015.\t\t\t*/\n/*\t\t\t\t\t\t\t\t\t\t*/\n/* All rights reserved.\t\t\t\t\t\t\t\t*/\n/* \t\t\t\t\t\t\t\t\t\t*/\n/* Redistribution and use in source and binary forms, with or without\t\t*/\n/* modification, are permitted provided that the following conditions are\t*/\n/* met:\t\t\t\t\t\t\t\t\t\t*/\n/* \t\t\t\t\t\t\t\t\t\t*/\n/* Redistributions of source code must retain the above copyright notice,\t*/\n/* this list of conditions and the following disclaimer.\t\t\t*/\n/* \t\t\t\t\t\t\t\t\t\t*/\n/* Redistributions in binary form must reproduce the above copyright\t\t*/\n/* notice, this list of conditions and the following disclaimer in the\t\t*/\n/* documentation and/or other materials provided with the distribution.\t\t*/\n/* \t\t\t\t\t\t\t\t\t\t*/\n/* Neither the names of the IBM Corporation nor the names of its\t\t*/\n/* contributors may be used to endorse or promote products derived from\t\t*/\n/* this software without specific prior written permission.\t\t\t*/\n/* \t\t\t\t\t\t\t\t\t\t*/\n/* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\t\t*/\n/* \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\t\t*/\n/* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\t*/\n/* A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\t\t*/\n/* HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\t*/\n/* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\t\t*/\n/* LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\t*/\n/* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\t*/\n/* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\t\t*/\n/* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\t*/\n/* OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\t\t*/\n/********************************************************************************/\n\n/* This module abstracts out all NVRAM read and write operations.\n\n   This implementation uses standard, portable C files.\n\n   The basic high level abstractions are:\n\n        SWTPM_NVRAM_LoadData();\n        SWTPM_NVRAM_StoreData();\n        SWTPM_NVRAM_DeleteName();\n\n   They take a 'name' that is mapped to a rooted file name.\n*/\n\n#include \"config.h\"\n\n#define _GNU_SOURCE\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <arpa/inet.h>\n#include <fcntl.h>\n\n#include <libtpms/tpm_error.h>\n#include <libtpms/tpm_memory.h>\n#include <libtpms/tpm_nvfilename.h>\n#include <libtpms/tpm_library.h>\n\n#include <openssl/sha.h>\n#include <openssl/rand.h>\n#if OPENSSL_VERSION_NUMBER >= 0x30000000L\n# include <openssl/core_names.h>\n#else\n# include <openssl/hmac.h>\n#endif\n\n#if defined(__OpenBSD__)\n # define OPENSSL_OLD_API\n#else\n #if OPENSSL_VERSION_NUMBER < 0x10100000\n  #define OPENSSL_OLD_API\n #endif\n#endif\n\n#include \"swtpm.h\"\n#include \"swtpm_aes.h\"\n#include \"swtpm_debug.h\"\n#include \"swtpm_nvstore.h\"\n#include \"swtpm_utils.h\"\n#include \"key.h\"\n#include \"logging.h\"\n#include \"tpmstate.h\"\n#include \"tpmlib.h\"\n#include \"tlv.h\"\n#include \"utils.h\"\n#include \"compiler_dependencies.h\"\n\n/* local structures */\ntypedef struct {\n    uint8_t  version;\n    uint8_t  min_version; /* min. required version */\n    uint16_t hdrsize;\n    uint16_t flags;\n    uint32_t totlen; /* length of the header and following data */\n} __attribute__((packed)) blobheader;\n\n#define BLOB_HEADER_VERSION 2\n\n/* flags for blobheader */\n#define BLOB_FLAG_ENCRYPTED              0x01\n#define BLOB_FLAG_MIGRATION_ENCRYPTED    0x02  /* encrypted with migration key */\n#define BLOB_FLAG_MIGRATION_DATA         0x04  /* migration data are available */\n#define BLOB_FLAG_ENCRYPTED_256BIT_KEY   0x08  /* 256 bit file key was used */\n#define BLOB_FLAG_MIGRATION_256BIT_KEY   0x10  /* 256 bit migration key was used */\n\ntypedef struct {\n    enum encryption_mode data_encmode;\n    TPM_SYMMETRIC_KEY_DATA symkey;\n} encryptionkey ;\n\nstatic encryptionkey filekey = {\n    .symkey = {\n        .userKeyLength = 0,\n    },\n};\n\nstatic encryptionkey migrationkey = {\n    .symkey = {\n        .userKeyLength = 0,\n    },\n};\n\nstatic uint32_t g_ivec_length;\nstatic unsigned char *g_ivec;\nstatic struct nvram_backend_ops *g_nvram_backend_ops;\n\n/* local prototypes */\n\nstatic TPM_RESULT SWTPM_NVRAM_EncryptData(const encryptionkey *key,\n                                          tlv_data *td,\n                                          size_t *td_len,\n                                          uint16_t tag_encrypted_data,\n                                          const unsigned char *decrypt_data,\n                                          uint32_t decrypt_length,\n                                          uint16_t tag_ivec);\n\nstatic TPM_RESULT SWTPM_NVRAM_GetDecryptedData(const encryptionkey *key,\n                                               unsigned char **decrypt_data,\n                                               uint32_t *decrypt_length,\n                                               const unsigned char *encrypt_data,\n                                               uint32_t encrypt_length,\n                                               uint16_t tag_decryped_data,\n                                               uint16_t tag_data,\n                                               uint8_t hdrversion,\n                                               uint16_t tag_ivec,\n                                               uint16_t hdrflags,\n                                               uint16_t flag_256bitkey);\n\nstatic TPM_RESULT SWTPM_NVRAM_PrependHeader(unsigned char **data,\n                                            uint32_t *length,\n                                            uint16_t flags);\n\nstatic TPM_RESULT SWTPM_NVRAM_CheckHeader(unsigned char *data, uint32_t length,\n                                          uint32_t *dataoffset,\n                                          uint16_t *hdrflags,\n                                          uint8_t *hdrversion,\n                                          bool quiet);\n\n/* SWTPM_NVRAM_Init() is called once at startup.  It does any NVRAM required initialization.\n\n   This function sets some static variables that are used by all TPM's.\n*/\n\nTPM_RESULT SWTPM_NVRAM_Init(void)\n{\n    const char  *backend_uri;\n    TPM_RESULT  rc = 0;\n    TPM_DEBUG(\" SWTPM_NVRAM_Init:\\n\");\n\n    backend_uri = tpmstate_get_backend_uri();\n    if (!backend_uri) {\n        logprintf(STDERR_FILENO,\n                  \"SWTPM_NVRAM_Init: Missing backend URI.\\n\");\n        rc = TPM_FAIL;\n    } else if (strncmp(backend_uri, \"dir://\", 6) == 0) {\n        g_nvram_backend_ops = &nvram_dir_ops;\n    } else if (strncmp(backend_uri, \"file://\", 7) == 0) {\n        g_nvram_backend_ops = &nvram_linear_ops;\n    } else {\n        logprintf(STDERR_FILENO,\n                  \"SWTPM_NVRAM_Init: Unsupported backend.\\n\");\n        rc = TPM_FAIL;\n    }\n\n    if (rc == 0)\n        rc = g_nvram_backend_ops->prepare(backend_uri);\n\n    return rc;\n}\n\nvoid SWTPM_NVRAM_Shutdown(void)\n{\n    if (g_nvram_backend_ops)\n        g_nvram_backend_ops->cleanup();\n    memset(&filekey, 0, sizeof(filekey));\n    memset(&migrationkey, 0, sizeof(migrationkey));\n}\n\n/* SWTPM_NVRAM_GetFilenameForName() constructs a file name from the name.\n * A temporary filename used to write to may be created. It should be rename()'d to\n * the non-temporary filename.\n */\n\nTPM_RESULT\nSWTPM_NVRAM_GetFilenameForName(char *filename,       /* output: filename */\n                               size_t bufsize,\n                               uint32_t tpm_number,\n                               const char *name,     /* input: abstract name */\n                               TPM_BOOL is_tempfile) /* input: is temporary file? */\n{\n    TPM_RESULT res = TPM_SUCCESS;\n    int n;\n    const char *suffix = \"\";\n\n    TPM_DEBUG(\" SWTPM_NVRAM_GetFilenameForName: For name %s\\n\", name);\n\n    switch (tpmstate_get_version()) {\n    case TPMLIB_TPM_VERSION_1_2:\n        break;\n    case TPMLIB_TPM_VERSION_2:\n        suffix = \"2\";\n        break;\n    }\n\n    if (is_tempfile) {\n        n = snprintf(filename, bufsize, \"TMP%s-%02lx.%s\", suffix, (unsigned long)tpm_number, name);\n    } else {\n        n = snprintf(filename, bufsize, \"tpm%s-%02lx.%s\", suffix, (unsigned long)tpm_number, name);\n    }\n    if ((size_t)n > bufsize) {\n        res = TPM_FAIL;\n    }\n\n    TPM_DEBUG(\"  SWTPM_NVRAM_GetFilenameForName: File name %s\\n\", filename);\n\n    return res;\n}\n\n\n/* Load 'data' of 'length' from the 'name'.\n\n   'data' must be freed after use.\n   \n   Returns\n        0 on success.\n        TPM_RETRY and NULL,0 on non-existent file (non-fatal, first time start up)\n        TPM_FAIL on failure to load (fatal), since it should never occur\n*/\n\nTPM_RESULT\nSWTPM_NVRAM_LoadData(unsigned char **data,     /* freed by caller */\n                     uint32_t *length,\n                     uint32_t tpm_number,\n                     const char *name)\n{\n    TPM_RESULT    rc = 0;\n    int           irc;\n    unsigned char *decrypt_data = NULL;\n    uint32_t      decrypt_length;\n    uint32_t      dataoffset = 0;\n    uint8_t       hdrversion = 0;\n    uint16_t      hdrflags;\n    const char    *backend_uri = NULL;\n\n    TPM_DEBUG(\" SWTPM_NVRAM_LoadData: From file %s\\n\", name);\n    *data = NULL;\n    *length = 0;\n\n    if (rc == 0) {\n        backend_uri = tpmstate_get_backend_uri();\n        rc = g_nvram_backend_ops->load(data, length, tpm_number, name,\n                                       backend_uri);\n    }\n\n    if (rc == 0) {\n        /* this function needs to return the plain data -- no tlv headers */\n\n        /* try to get a header from it -- old files may not have one */\n        irc = SWTPM_NVRAM_CheckHeader(*data, *length, &dataoffset,\n                                      &hdrflags, &hdrversion, true);\n        /* valid header -- this one can only be version 2 or later */\n        if (irc) {\n            hdrversion = 1; /* no header -- payload was written like vers. 1 */\n            hdrflags = 0;\n        }\n\n        rc = SWTPM_NVRAM_GetDecryptedData(&filekey,\n                                          &decrypt_data, &decrypt_length,\n                                          *data + dataoffset,\n                                          *length - dataoffset,\n                                          TAG_ENCRYPTED_DATA, TAG_DATA,\n                                          hdrversion,\n                                          TAG_IVEC_ENCRYPTED_DATA,\n                                          hdrflags,\n                                          BLOB_FLAG_ENCRYPTED_256BIT_KEY);\n        TPM_DEBUG(\" SWTPM_NVRAM_LoadData: SWTPM_NVRAM_GetDecryptedData rc = %d\\n\",\n                  rc);\n        if (rc != 0)\n            logprintf(STDERR_FILENO,\n                      \"SWTPM_NVRAM_LoadData: Error from SWTPM_NVRAM_GetDecryptedData \"\n                      \"rc = %d\\n\", rc);\n\n        if (rc == 0) {\n            TPM_DEBUG(\" SWTPM_NVRAM_LoadData: Decrypted %u bytes of \"\n                      \"data to %u bytes.\\n\",\n                      *length, decrypt_length);\n            free(*data);\n            *data = decrypt_data;\n            *length = decrypt_length;\n        }\n    }\n\n    if (rc != 0) {\n        free(*data);\n        *data = NULL;\n    }\n\n    return rc;\n}\n\n/* SWTPM_NVRAM_StoreData stores 'data' of 'length' to the rooted 'filename'\n\n   Returns\n        0 on success\n        TPM_FAIL for other fatal errors\n*/\n\nstatic TPM_RESULT\nSWTPM_NVRAM_StoreData_Intern(const unsigned char *data,\n                             uint32_t length,\n                             uint32_t tpm_number,\n                             const char *name,\n                             TPM_BOOL encrypt         /* encrypt if key is set */)\n{\n    TPM_RESULT    rc = 0;\n    unsigned char *filedata = NULL;\n    uint32_t      filedata_length = 0;\n    tlv_data      td[3];\n    size_t        td_len = 0;\n    uint16_t      flags = 0;\n    const char    *backend_uri = NULL;\n\n    TPM_DEBUG(\" SWTPM_NVRAM_StoreData: To name %s\\n\", name);\n\n    if (rc == 0) {\n        if (encrypt && SWTPM_NVRAM_Has_FileKey()) {\n            td_len = 3;\n            rc = SWTPM_NVRAM_EncryptData(&filekey, &td[0], &td_len,\n                                         TAG_ENCRYPTED_DATA, data, length,\n                                         TAG_IVEC_ENCRYPTED_DATA);\n            if (rc) {\n                logprintf(STDERR_FILENO,\n                          \"SWTPM_NVRAM_EncryptData failed: 0x%02x\\n\", rc);\n            } else {\n                TPM_DEBUG(\"  SWTPM_NVRAM_StoreData: Encrypted %u bytes before \"\n                          \"write, will write %u bytes\\n\", length,\n                          td[0].tlv.length);\n            }\n            flags |= BLOB_FLAG_ENCRYPTED;\n            if (SWTPM_NVRAM_FileKey_Size() == SWTPM_AES256_BLOCK_SIZE)\n                flags |= BLOB_FLAG_ENCRYPTED_256BIT_KEY;\n        } else {\n            td_len = 1;\n            td[0] = TLV_DATA_CONST(TAG_DATA, length, data);\n        }\n    }\n\n    if (rc == 0)\n        rc = tlv_data_append(&filedata, &filedata_length, td, td_len);\n\n    if (rc == 0)\n        rc = SWTPM_NVRAM_PrependHeader(&filedata, &filedata_length, flags);\n\n    if (rc == 0) {\n        backend_uri = tpmstate_get_backend_uri();\n        rc = g_nvram_backend_ops->store(filedata, filedata_length, tpm_number, name,\n                                        backend_uri);\n    }\n\n    tlv_data_free(td, td_len);\n    free(filedata);\n\n    TPM_DEBUG(\" SWTPM_NVRAM_StoreData: rc=%d\\n\", rc);\n\n    return rc;\n}\n\nTPM_RESULT SWTPM_NVRAM_StoreData(const unsigned char *data,\n                                 uint32_t length,\n                                 uint32_t tpm_number,\n                                 const char *name)\n{\n    return SWTPM_NVRAM_StoreData_Intern(data, length, tpm_number, name, TRUE);\n}\n\n/* SWTPM_NVRAM_DeleteName() deletes the 'name' from NVRAM\n\n   Returns:\n        0 on success, or if the file does not exist and mustExist is FALSE\n        TPM_FAIL if the file could not be removed, since this should never occur and there is\n                no recovery\n\n   NOTE: Not portable code, but supported by Linux and Windows\n*/\n\nTPM_RESULT SWTPM_NVRAM_DeleteName(uint32_t tpm_number,\n                                  const char *name,\n                                  TPM_BOOL mustExist)\n{\n    const char *backend_uri = NULL;\n    backend_uri = tpmstate_get_backend_uri();\n\n    return g_nvram_backend_ops->delete(tpm_number, name, mustExist,\n                                       backend_uri);\n}\n\n\nTPM_RESULT SWTPM_NVRAM_Store_Volatile(void)\n{\n    TPM_RESULT     rc = 0;\n    char           *name = TPM_VOLATILESTATE_NAME;\n    uint32_t       tpm_number = 0;\n    unsigned char  *buffer = NULL;\n    uint32_t       buflen;\n\n    TPM_DEBUG(\" SWTPM_Store_Volatile: Name %s\\n\", name);\n    if (rc == 0) {\n        rc = TPMLIB_VolatileAll_Store(&buffer, &buflen);\n    }\n    if (rc == 0) {\n        /* map name to the rooted filename */\n        rc = SWTPM_NVRAM_StoreData(buffer, buflen, tpm_number, name);\n    }\n\n    free(buffer);\n\n    return rc;\n}\n\nstatic TPM_RESULT\nSWTPM_NVRAM_KeyParamCheck(uint32_t keylen,\n                          enum encryption_mode encmode)\n{\n    TPM_RESULT rc = 0;\n\n    if (keylen != SWTPM_AES128_BLOCK_SIZE &&\n        keylen != SWTPM_AES256_BLOCK_SIZE) {\n        rc = TPM_BAD_KEY_PROPERTY;\n    }\n    switch (encmode) {\n    case ENCRYPTION_MODE_AES_CBC:\n        break;\n    case ENCRYPTION_MODE_UNKNOWN:\n        rc = TPM_BAD_MODE;\n    }\n\n    return rc;\n}\n\nsize_t SWTPM_NVRAM_FileKey_Size(void)\n{\n    return filekey.symkey.userKeyLength;\n}\n\nTPM_RESULT SWTPM_NVRAM_Set_FileKey(const unsigned char *key, uint32_t keylen,\n                                   enum encryption_mode encmode)\n{\n    TPM_RESULT rc;\n\n    rc = SWTPM_NVRAM_KeyParamCheck(keylen, encmode);\n\n    if (rc == 0) {\n        memcpy(filekey.symkey.userKey, key, keylen);\n        filekey.symkey.userKeyLength = keylen;\n        filekey.data_encmode = encmode;\n    }\n\n    return rc;\n}\n\nsize_t SWTPM_NVRAM_MigrationKey_Size(void)\n{\n    return migrationkey.symkey.userKeyLength;\n}\n\nTPM_RESULT SWTPM_NVRAM_Set_MigrationKey(const unsigned char *key,\n                                        uint32_t keylen,\n                                        enum encryption_mode encmode)\n{\n    TPM_RESULT rc;\n\n    rc = SWTPM_NVRAM_KeyParamCheck(keylen, encmode);\n\n    if (rc == 0) {\n        memcpy(migrationkey.symkey.userKey, key, keylen);\n        migrationkey.symkey.userKeyLength = keylen;\n        migrationkey.data_encmode = encmode;\n    }\n\n    return rc;\n}\n\n# if OPENSSL_VERSION_NUMBER >= 0x30000000L\n\nstatic int SWTPM_HMAC(unsigned char *md, unsigned int *md_len,\n                      const void *key, int key_len,\n                      const unsigned char *in, uint32_t in_length,\n                      const unsigned char *ivec, uint32_t ivec_length)\n{\n    OSSL_PARAM params[2];\n    EVP_MAC_CTX *ctx;\n    EVP_MAC *hmac;\n    size_t outl;\n    int ret = 0;\n\n    hmac = EVP_MAC_fetch(NULL, OSSL_MAC_NAME_HMAC, NULL);\n    if (!hmac)\n        return 0;\n\n    ctx = EVP_MAC_CTX_new(hmac);\n    if (!ctx)\n        goto err;\n\n    params[0] = OSSL_PARAM_construct_utf8_string(OSSL_ALG_PARAM_DIGEST,\n                                                 \"sha256\", 0);\n    params[1] = OSSL_PARAM_construct_end();\n\n    if (!EVP_MAC_init(ctx, key, key_len, params) ||\n        !EVP_MAC_update(ctx, in, in_length))\n        goto err;\n\n    if (ivec &&\n        !EVP_MAC_update(ctx, ivec, ivec_length))\n        goto err;\n\n    if (!EVP_MAC_final(ctx, md, &outl, *md_len))\n        goto err;\n    *md_len = outl;\n\n    ret = 1;\n\nerr:\n    EVP_MAC_CTX_free(ctx);\n    EVP_MAC_free(hmac);\n\n    return ret;\n}\n\n#else\n\nstatic int SWTPM_HMAC(unsigned char *md, unsigned int *md_len,\n                      const void *key, int key_len,\n                      const unsigned char *in, uint32_t in_length,\n                      const unsigned char *ivec, uint32_t ivec_length)\n{\n    int ret = 0;\n\n#if defined OPENSSL_OLD_API\n    HMAC_CTX sctx, *ctx = &sctx;\n\n    HMAC_CTX_init(ctx);\n#else\n    HMAC_CTX *ctx = HMAC_CTX_new();\n\n    if (!ctx)\n        return 0;\n#endif\n\n\n    if (!HMAC_Init_ex(ctx, key, key_len, EVP_sha256(), NULL) ||\n        !HMAC_Update(ctx, in, in_length))\n        goto err;\n\n    if (ivec &&\n        !HMAC_Update(ctx, ivec, ivec_length))\n        goto err;\n\n    if (!HMAC_Final(ctx, md, md_len))\n        goto err;\n\n    ret = 1;\n\nerr:\n#if defined OPENSSL_OLD_API\n    HMAC_CTX_cleanup(ctx);\n#else\n    HMAC_CTX_free(ctx);\n#endif\n\n    return ret;\n}\n#endif /* if OPENSSL_VERSION_NUMBER >= 0x30000000L */\n\n/*\n * SWTPM_RollAndSetGlobalIvec: Create an IV for the AES CBC algorithm to use\n *                             Create it with a random number every time.\n *                             and leave the pointer to the data in @td.\n *\n * @td: pointer to tlv_data to get pointer to the random data\n * @tag_ivec: tag for the IV tlv header\n * @ivec_length: number of bytes needed for the ivec\n */\nstatic TPM_RESULT SWTPM_RollAndSetGlobalIvec(tlv_data *td,\n                                             uint16_t tag_ivec,\n                                             uint32_t ivec_length)\n{\n    unsigned char data[16]; /* do not initialize */\n    unsigned char hashbuf[SHA256_DIGEST_LENGTH];\n    void *p;\n\n    if (g_ivec_length < ivec_length) {\n        p = realloc(g_ivec, ivec_length);\n        if (!p) {\n            *td = TLV_DATA_CONST(tag_ivec, 0, NULL);\n\n            logprintf(STDOUT_FILENO,\n                      \"Could not allocate %u bytes.\\n\", ivec_length);\n            return TPM_FAIL;\n        }\n        g_ivec = p;\n        g_ivec_length = ivec_length;\n    }\n\n    if (RAND_bytes(g_ivec, g_ivec_length) != 1) {\n        /* random data from stack to the rescue */\n        SHA256(g_ivec, g_ivec_length, hashbuf);\n        SHA256(data, sizeof(data), hashbuf);\n        memcpy(g_ivec, hashbuf,\n               g_ivec_length < sizeof(hashbuf)\n                   ? g_ivec_length\n                   : sizeof(hashbuf));\n    }\n\n    *td = TLV_DATA_CONST(tag_ivec, g_ivec_length, g_ivec);\n\n    return 0;\n}\n\n/*\n * SWTPM_GetIvec: Get the encryption IV from the data stream. If none is\n *                found a NULL pointer is set in *ivec, otherwise a pointer\n *                to the beginning of the IV and its length are returned.\n */\nstatic void SWTPM_GetIvec(const unsigned char *data, uint32_t length,\n                          const unsigned char **ivec, uint32_t *ivec_length,\n                          uint16_t tag)\n{\n    tlv_data td;\n\n    if (!tlv_data_find_tag(data, length, tag, &td)) {\n        *ivec = NULL;\n    } else {\n        *ivec = td.u.const_ptr;\n        *ivec_length = td.tlv.length;\n    }\n}\n\n/*\n * SWTPM_CalcHMAC\n *\n * @in: input buffer to calculate HMAC on\n * @in_length: length of input buffer\n * @td: pointer to a tlv_data structure to receive the result with the\n *      tag, length, and pointer to an allocated buffer holding the HMAC\n * @tpm_symmetric_key_token: symmetric key\n * @ivec: the IV for AES CBC\n * @ivec_length: the length of the IV\n *\n * Calculate an HMAC on the input buffer with payload and create an output\n * buffer with the HMAC\n */\nstatic TPM_RESULT\nSWTPM_CalcHMAC(const unsigned char *in, uint32_t in_length,\n               tlv_data *td,\n               const TPM_SYMMETRIC_KEY_DATA *tpm_symmetric_key_token,\n               const unsigned char *ivec, uint32_t ivec_length)\n{\n    TPM_RESULT rc = 0;\n    unsigned char md[EVP_MAX_MD_SIZE];\n    unsigned int md_len = sizeof(md);\n    unsigned char *buffer = NULL;\n\n    if (!SWTPM_HMAC(md, &md_len,\n                    tpm_symmetric_key_token->userKey,\n                    tpm_symmetric_key_token->userKeyLength,\n                    in, in_length, ivec, ivec_length)) {\n        logprintf(STDOUT_FILENO, \"HMAC calculation failed.\\n\");\n        return TPM_FAIL;\n    }\n\n    buffer = malloc(md_len);\n\n    if (buffer) {\n        *td = TLV_DATA(TAG_HMAC, md_len, buffer);\n        memcpy(buffer, md, md_len);\n    } else {\n       logprintf(STDOUT_FILENO,\n                 \"Could not allocate %u bytes.\\n\", md_len);\n       rc = TPM_FAIL;\n    }\n\n    return rc;\n}\n\n/*\n * SWTPM_CheckHMAC:\n *\n * @hmac: tlv_data with pointer to hmac bytes\n * @encrypted_data: tlv_data with pointer to encrypted data bytes\n * @tpm_symmetric_key_token: symmetric key\n * @ivec: the IV for AES CBC\n * @ivec_length: the length of the IV\n *\n * Verify the HMAC given the expected @hmac and the @tpm_symmetric_key_token\n * to calculate the HMAC over the @encrypted_data.\n */\nstatic TPM_RESULT\nSWTPM_CheckHMAC(tlv_data *hmac, tlv_data *encrypted_data,\n                const TPM_SYMMETRIC_KEY_DATA *tpm_symmetric_key_token,\n                const unsigned char *ivec, uint32_t ivec_length)\n{\n    const unsigned char *data;\n    uint32_t data_length;\n    unsigned int md_len;\n    unsigned char md[EVP_MAX_MD_SIZE];\n\n    md_len = EVP_MD_size(EVP_sha256());\n    if (md_len > hmac->tlv.length) {\n        logprintf(STDOUT_FILENO, \"Insufficient bytes for CheckHMAC()\\n\");\n        return TPM_FAIL;\n    }\n\n    data = encrypted_data->u.ptr;\n    data_length = encrypted_data->tlv.length;\n\n    if (!SWTPM_HMAC(md, &md_len,\n                    tpm_symmetric_key_token->userKey,\n                    tpm_symmetric_key_token->userKeyLength,\n                    data, data_length, ivec, ivec_length)) {\n        logprintf(STDOUT_FILENO, \"HMAC() call failed.\\n\");\n        return TPM_FAIL;\n    }\n\n    if (memcmp(hmac->u.ptr, md, md_len)) {\n        logprintf(STDOUT_FILENO, \"Verification of HMAC failed. \"\n                  \"Data integrity is compromised\\n\");\n        /* TPM_DECRYPT_ERROR indicates (to libtpms) that something\n           exists but we have the wrong key. */\n        return TPM_DECRYPT_ERROR;\n    }\n\n    return TPM_SUCCESS;\n}\n\n/*\n * SWTPM_CheckHash:\n *\n * @in: input buffer\n * @in_length: input buffer length\n * @out: output buffer\n * @out_length: output buffer length\n */\nstatic TPM_RESULT\nSWTPM_CheckHash(const unsigned char *in, uint32_t in_length,\n                unsigned char **out, uint32_t *out_length)\n{\n    TPM_RESULT rc = 0;\n    unsigned char *dest = NULL;\n    unsigned char hashbuf[SHA256_DIGEST_LENGTH];\n    const unsigned char *data = &in[sizeof(hashbuf)];\n    uint32_t data_length = in_length - sizeof(hashbuf);\n\n    /* hash the data */\n    SHA256(data, data_length, hashbuf);\n\n    if (memcmp(in, hashbuf, sizeof(hashbuf))) {\n        logprintf(STDOUT_FILENO, \"Verification of hash failed. \"\n                  \"Data integrity is compromised\\n\");\n        rc = TPM_FAIL;\n    }\n\n    if (rc == 0) {\n        dest = malloc(data_length);\n        if (dest) {\n            *out = dest;\n            *out_length = data_length;\n            memcpy(dest, data, data_length);\n        } else {\n            logprintf(STDOUT_FILENO,\n                      \"Could not allocated %u bytes.\\n\", data_length);\n            rc = TPM_FAIL;\n        }\n    }\n\n    return rc;\n}\n\nstatic TPM_RESULT\nSWTPM_NVRAM_EncryptData(const encryptionkey *key,\n                        struct tlv_data *td, /* must provide 2 array members */\n                        size_t *td_len,\n                        uint16_t tag_encrypted_data,\n                        const unsigned char *data, uint32_t length,\n                        uint16_t tag_ivec)\n{\n    TPM_RESULT rc = 0;\n    TPM_RESULT irc;\n    unsigned char *tmp_data = NULL;\n    uint32_t tmp_length = 0;\n\n    *td_len = 0;\n\n    if (key->symkey.userKeyLength > 0) {\n        switch (key->data_encmode) {\n        case ENCRYPTION_MODE_UNKNOWN:\n            rc = TPM_BAD_MODE;\n            break;\n        case ENCRYPTION_MODE_AES_CBC:\n            irc = SWTPM_RollAndSetGlobalIvec(&td[2], tag_ivec,\n                                             key->symkey.userKeyLength);\n            rc = SWTPM_SymmetricKeyData_Encrypt(&tmp_data, &tmp_length,\n                                                data, length, &key->symkey,\n                                                td[2].u.const_ptr,\n                                                td[2].tlv.length);\n            if (rc)\n                 break;\n\n            rc = SWTPM_CalcHMAC(tmp_data, tmp_length, &td[1], &key->symkey,\n                                td[2].u.const_ptr, td[2].tlv.length);\n            if (rc == 0) {\n                td[0] = TLV_DATA(tag_encrypted_data, tmp_length, tmp_data);\n                /* in case we couldn't get an IV */\n                *td_len = (irc == 0) ? 3 : 2;\n                tmp_data = NULL;\n            }\n            break;\n        }\n    }\n\n    if (rc)\n        tlv_data_free(td, *td_len);\n\n    free(tmp_data);\n\n    return rc;\n}\n\nstatic TPM_RESULT\nSWTPM_NVRAM_DecryptData(const encryptionkey *key,\n                        unsigned char **decrypt_data, uint32_t *decrypt_length,\n                        const unsigned char *data, uint32_t length,\n                        uint16_t tag_encrypted_data,\n                        uint8_t hdrversion,\n                        uint16_t tag_ivec, uint16_t hdrflags,\n                        uint16_t flag_256bitkey)\n{\n    TPM_RESULT rc = 0;\n    unsigned char *tmp_data = NULL;\n    uint32_t tmp_length = 0;\n    tlv_data td[2];\n    const unsigned char *ivec = NULL;\n    uint32_t ivec_length = 0;\n    size_t keylen;\n\n    if (key->symkey.userKeyLength > 0) {\n        switch (key->data_encmode) {\n        case ENCRYPTION_MODE_UNKNOWN:\n            rc = TPM_BAD_MODE;\n            break;\n        case ENCRYPTION_MODE_AES_CBC:\n            switch (hdrversion) {\n            case 1:\n                rc = SWTPM_SymmetricKeyData_Decrypt(&tmp_data,\n                                                    &tmp_length,\n                                                    data, length,\n                                                    &key->symkey,\n                                                    NULL, 0);\n                if (rc == 0) {\n                    rc = SWTPM_CheckHash(tmp_data, tmp_length,\n                                         decrypt_data, decrypt_length);\n                }\n            break;\n            case 2:\n                keylen = (hdrflags & flag_256bitkey)\n                          ? SWTPM_AES256_BLOCK_SIZE : SWTPM_AES128_BLOCK_SIZE;\n                if (keylen != key->symkey.userKeyLength) {\n                    logprintf(STDERR_FILENO,\n                              \"Wrong decryption key. Need %zu bit key.\\n\",\n                              keylen * 8);\n                    rc = TPM_BAD_KEY_PROPERTY;\n                    break;\n                }\n\n                if (!tlv_data_find_tag(data, length, TAG_HMAC, &td[0]) ||\n                    !tlv_data_find_tag(data, length, tag_encrypted_data,\n                                       &td[1])) {\n                    logprintf(STDERR_FILENO,\n                              \"Could not find HMAC or encrypted data (tag %u) \"\n                              \"in byte stream.\\n\", tag_encrypted_data);\n                    rc = TPM_FAIL;\n                    break;\n                }\n                /* get the IV, if there is one */\n                SWTPM_GetIvec(data, length, &ivec, &ivec_length, tag_ivec);\n\n                rc = SWTPM_CheckHMAC(&td[0], &td[1], &key->symkey,\n                                     ivec, ivec_length);\n                if (rc == 0) {\n                    rc = SWTPM_SymmetricKeyData_Decrypt(decrypt_data,\n                                                        decrypt_length,\n                                                        td[1].u.const_ptr,\n                                                        td[1].tlv.length,\n                                                        &key->symkey,\n                                                        ivec, ivec_length);\n                }\n            break;\n            default:\n                rc = TPM_FAIL;\n            }\n            free(tmp_data);\n        }\n    }\n\n    return rc;\n}\n\nstatic TPM_RESULT\nSWTPM_NVRAM_GetPlainData(unsigned char **plain, uint32_t *plain_length,\n                         const unsigned char *data, uint32_t length,\n                         uint16_t tag_data,\n                         uint8_t hdrversion)\n{\n    TPM_RESULT rc = 0;\n    tlv_data td[1];\n\n    switch (hdrversion) {\n    case 1:\n        *plain = malloc(length);\n        if (*plain) {\n            memcpy(*plain, data, length);\n            *plain_length = length;\n        } else {\n            logprintf(STDERR_FILENO,\n                      \"Could not allocate %u bytes.\\n\", length);\n            rc = TPM_FAIL;\n        }\n    break;\n\n    case 2:\n        if (!tlv_data_find_tag(data, length, tag_data, &td[0])) {\n            logprintf(STDERR_FILENO,\n                      \"Could not find plain data in byte stream.\\n\");\n            rc = TPM_FAIL;\n            break;\n        }\n        *plain = malloc(td->tlv.length);\n        if (*plain) {\n            memcpy(*plain, td->u.const_ptr, td->tlv.length);\n            *plain_length = td->tlv.length;\n        } else {\n            logprintf(STDERR_FILENO,\n                      \"Could not allocate %u bytes.\\n\", td->tlv.length);\n            rc = TPM_FAIL;\n        }\n    break;\n    }\n\n    return rc;\n}\n\n/*\n * SWTPM_NVRAM_GetDecryptedData: Get the decrytped data either by just returning\n *                               the data if they were not encrypted or by\n *                               actually decrypting them if there is a key.\n *                               The plain data is returned, meaning any TLV\n *                               header has been removed.\n * @key: the encryption key, may be NULL\n * @decrypt_data: pointer to a pointer for the result\n * @decrypt_length: the length of the returned data\n * @data: input data\n * @length: length of the input data\n * @tag_encrypted_data: the tag the encrypted data is stored with\n * @tag_data: the tag the plain data is stored with\n * @hdrversion: the version found in the header that determines in what\n *              format the data is stored; tag-length-value is the format\n *              in v2\n * @tag_ivec: the tag for finding the IV\n * @hdrflags: the flags from the header\n * @flag_256bitkey: the flag in the header to check whether we expect a\n *                  256 bit key; different flag for migration and state key\n */\nstatic TPM_RESULT\nSWTPM_NVRAM_GetDecryptedData(const encryptionkey *key,\n                             unsigned char **decrypt_data,\n                             uint32_t *decrypt_length,\n                             const unsigned char *data,\n                             uint32_t length,\n                             uint16_t tag_encrypted_data,\n                             uint16_t tag_data,\n                             uint8_t hdrversion,\n                             uint16_t tag_ivec,\n                             uint16_t hdrflags,\n                             uint16_t flag_256bitkey)\n{\n    if (key && key->symkey.userKeyLength > 0) {\n        /* we assume the data are encrypted when there's a key given */\n        return SWTPM_NVRAM_DecryptData(key, decrypt_data, decrypt_length,\n                                       data, length, tag_encrypted_data,\n                                       hdrversion, tag_ivec, hdrflags,\n                                       flag_256bitkey);\n    }\n    return SWTPM_NVRAM_GetPlainData(decrypt_data, decrypt_length,\n                                    data, length, tag_data, hdrversion);\n}\n\n/*\n * Prepend a header in front of the state blob\n */\nstatic TPM_RESULT\nSWTPM_NVRAM_PrependHeader(unsigned char **data, uint32_t *length,\n                          uint16_t flags)\n{\n    unsigned char *out = NULL;\n    uint32_t out_len = sizeof(blobheader) + *length;\n    blobheader bh = {\n        .version = BLOB_HEADER_VERSION,\n        .min_version = 1,\n        .hdrsize = htons(sizeof(bh)),\n        .flags = htons(flags),\n        .totlen = htonl(out_len),\n    };\n    TPM_RESULT res;\n\n    out = malloc(out_len);\n    if (!out) {\n        logprintf(STDERR_FILENO,\n                  \"Could not allocate %u bytes.\\n\", out_len);\n        res = TPM_FAIL;\n        goto error;\n    }\n\n    memcpy(out, &bh, sizeof(bh));\n    memcpy(&out[sizeof(bh)], *data, *length);\n\n    free(*data);\n\n    *data = out;\n    *length = out_len;\n\n    return TPM_SUCCESS;\n\n error:\n    free(*data);\n    *data = NULL;\n    *length = 0;\n\n    return res;\n}\n\n\nstatic TPM_RESULT\nSWTPM_NVRAM_CheckHeader(unsigned char *data, uint32_t length,\n                        uint32_t *dataoffset, uint16_t *hdrflags,\n                        uint8_t *hdrversion, bool quiet)\n{\n    blobheader *bh = (blobheader *)data;\n    uint16_t hdrsize;\n\n    if (length < sizeof(bh)) {\n        if (!quiet)\n            logprintf(STDERR_FILENO,\n                      \"not enough bytes for header: %u\\n\", length);\n        return TPM_BAD_PARAMETER;\n    }\n\n    if (ntohl(bh->totlen) != length) {\n        if (!quiet)\n            logprintf(STDERR_FILENO,\n                      \"broken header: bh->totlen %u != %u\\n\",\n                      htonl(bh->totlen), length);\n        return TPM_BAD_PARAMETER;\n    }\n\n    if (bh->min_version > BLOB_HEADER_VERSION) {\n        if (!quiet)\n            logprintf(STDERR_FILENO,\n                      \"Minimum required version for the blob is %d, we \"\n                      \"only support version %d\\n\", bh->min_version,\n                      BLOB_HEADER_VERSION);\n        return TPM_BAD_VERSION;\n    }\n\n    hdrsize = ntohs(bh->hdrsize);\n    if (hdrsize != sizeof(blobheader)) {\n        logprintf(STDERR_FILENO,\n                  \"bad header size: %u != %zu\\n\",\n                  hdrsize, sizeof(blobheader));\n        return TPM_BAD_DATASIZE;\n    }\n\n    *hdrversion = bh->version;\n    *dataoffset = hdrsize;\n    *hdrflags = ntohs(bh->flags);\n\n    return TPM_SUCCESS;\n}\n\n/*\n * Get the state blob with the current name; read it from the filesystem.\n * Decrypt it if the caller asks for it and if a key is set. Return\n * whether it's still encrypyted.\n */\nTPM_RESULT SWTPM_NVRAM_GetStateBlob(unsigned char **data,\n                                    uint32_t *length,\n                                    uint32_t tpm_number,\n                                    const char *name,\n                                    TPM_BOOL decrypt,\n                                    TPM_BOOL *is_encrypted)\n{\n    TPM_RESULT res;\n    uint16_t flags = 0;\n    tlv_data td[3];\n    size_t td_len;\n    unsigned char *plain = NULL, *buffer = NULL;\n    uint32_t plain_len, buffer_len = 0;\n\n    *data = NULL;\n    *length = 0;\n\n    res = SWTPM_NVRAM_LoadData(&plain, &plain_len, tpm_number, name);\n    if (res)\n        return res;\n\n    /* @plain contains unencrypted data without tlv headers */\n\n    /* if the user doesn't want decryption and there's a file key, we need to\n       encrypt the data */\n    if (!decrypt && SWTPM_NVRAM_Has_FileKey()) {\n        td_len = 3;\n        res = SWTPM_NVRAM_EncryptData(&filekey, &td[0], &td_len,\n                                      TAG_ENCRYPTED_DATA, plain, plain_len,\n                                      TAG_IVEC_ENCRYPTED_DATA);\n        if (res)\n            goto err_exit;\n\n        *is_encrypted = TRUE;\n        if (SWTPM_NVRAM_FileKey_Size() == SWTPM_AES256_BLOCK_SIZE)\n            flags |= BLOB_FLAG_ENCRYPTED_256BIT_KEY;\n    } else {\n        *is_encrypted = FALSE;\n        td[0] = TLV_DATA(TAG_DATA, plain_len, plain);\n        plain = NULL;\n        td_len = 1;\n    }\n\n    res = tlv_data_append(&buffer, &buffer_len, td, td_len);\n    if (res)\n        goto err_exit;\n\n    tlv_data_free(td, td_len);\n\n    /* @buffer contains tlv data */\n\n    if (SWTPM_NVRAM_Has_MigrationKey()) {\n        /* we have to encrypt it now with the migration key */\n        flags |= BLOB_FLAG_MIGRATION_ENCRYPTED;\n        if (SWTPM_NVRAM_MigrationKey_Size() == SWTPM_AES256_BLOCK_SIZE)\n             flags |= BLOB_FLAG_MIGRATION_256BIT_KEY;\n\n        td_len = 3;\n        res = SWTPM_NVRAM_EncryptData(&migrationkey, &td[0], &td_len,\n                                      TAG_ENCRYPTED_MIGRATION_DATA,\n                                      buffer, buffer_len,\n                                      TAG_IVEC_ENCRYPTED_MIGRATION_DATA);\n        if (res)\n            goto err_exit;\n    } else {\n        td[0] = TLV_DATA(TAG_MIGRATION_DATA, buffer_len, buffer);\n        buffer = NULL;\n        td_len = 1;\n    }\n    flags |= BLOB_FLAG_MIGRATION_DATA;\n\n    res = tlv_data_append(data, length, td, td_len);\n    if (res)\n        goto err_exit;\n\n    /* put the header in clear text */\n    if (*is_encrypted)\n        flags |= BLOB_FLAG_ENCRYPTED;\n\n    res = SWTPM_NVRAM_PrependHeader(data, length, flags);\n\nerr_exit:\n    tlv_data_free(td, td_len);\n    free(buffer);\n    free(plain);\n\n    return res;\n}\n\n/*\n * Set the state blob with the given name; the caller tells us if\n * the blob is encrypted; if it is encrypted, it will be written\n * into the file as-is, otherwise it will be encrypted if a key is set.\n */\nTPM_RESULT SWTPM_NVRAM_SetStateBlob(unsigned char *data,\n                                    uint32_t length,\n                                    TPM_BOOL is_encrypted,\n                                    uint32_t tpm_number SWTPM_ATTR_UNUSED,\n                                    uint32_t blobtype)\n{\n    TPM_RESULT res;\n    uint32_t dataoffset;\n    unsigned char *plain = NULL, *mig_decrypt = NULL;\n    uint32_t plain_len = 0, mig_decrypt_len = 0;\n    uint16_t hdrflags;\n    enum TPMLIB_StateType st = tpmlib_blobtype_to_statetype(blobtype);\n    const char *blobname = tpmlib_get_blobname(blobtype);\n    uint8_t hdrversion;\n\n    if (st == 0) {\n        logprintf(STDERR_FILENO,\n                  \"Unknown blob type %u\\n\", blobtype);\n        return TPM_BAD_PARAMETER;\n    }\n\n    if (length == 0)\n        return TPMLIB_SetState(st, NULL, 0);\n\n    res = SWTPM_NVRAM_CheckHeader(data, length, &dataoffset, &hdrflags,\n                                  &hdrversion, false);\n    if (res != TPM_SUCCESS)\n        return res;\n\n    if (length - dataoffset == 0)\n        return TPMLIB_SetState(st, NULL, 0);\n\n    /*\n     * We allow setting of blobs that were not encrypted before;\n     * we just will not decrypt them even if the migration key is\n     * set. This allows to 'upgrade' to encryption. 'Downgrading'\n     * will not be possible once a migration key was used.\n     */\n    if ((hdrflags & BLOB_FLAG_MIGRATION_ENCRYPTED)) {\n        /*\n         * we first need to decrypt the data with the migration key\n         */\n        if (!SWTPM_NVRAM_Has_MigrationKey()) {\n            logprintf(STDERR_FILENO,\n                      \"Missing migration key to decrypt %s\\n\", blobname);\n            return TPM_KEYNOTFOUND;\n        }\n\n        res = SWTPM_NVRAM_DecryptData(&migrationkey,\n                                      &mig_decrypt, &mig_decrypt_len,\n                                      &data[dataoffset], length - dataoffset,\n                                      TAG_ENCRYPTED_MIGRATION_DATA,\n                                      hdrversion,\n                                      TAG_IVEC_ENCRYPTED_MIGRATION_DATA,\n                                      hdrflags, BLOB_FLAG_MIGRATION_256BIT_KEY);\n        if (res) {\n            logprintf(STDERR_FILENO,\n                      \"Decrypting the %s blob with the migration key failed; \"\n                      \"res = %d\\n\", blobname, res);\n            return res;\n        }\n    } else {\n        res = SWTPM_NVRAM_GetPlainData(&mig_decrypt, &mig_decrypt_len,\n                                       &data[dataoffset], length - dataoffset,\n                                       TAG_MIGRATION_DATA,\n                                       hdrversion);\n        if (res)\n            return res;\n    }\n\n    /*\n     * Migration key has decrytped the data; if they are still encrypted\n     * with the state encryption key, we need to decrypt them using that\n     * key now.\n     */\n    if (is_encrypted || (hdrflags & BLOB_FLAG_ENCRYPTED)) {\n        if (!SWTPM_NVRAM_Has_FileKey()) {\n            logprintf(STDERR_FILENO,\n                      \"Missing state key to decrypt %s\\n\", blobname);\n            res = TPM_KEYNOTFOUND;\n            goto cleanup;\n        }\n\n        res = SWTPM_NVRAM_DecryptData(&filekey, &plain, &plain_len,\n                                      mig_decrypt, mig_decrypt_len,\n                                      TAG_ENCRYPTED_DATA,\n                                      hdrversion, TAG_IVEC_ENCRYPTED_DATA,\n                                      hdrflags, BLOB_FLAG_ENCRYPTED_256BIT_KEY);\n        if (res) {\n            logprintf(STDERR_FILENO,\n                      \"Decrypting the %s blob with the state key \"\n                      \"failed; res = %d\\n\", blobname, res);\n            goto cleanup;\n        }\n    } else {\n        res = SWTPM_NVRAM_GetPlainData(&plain, &plain_len,\n                                       mig_decrypt, mig_decrypt_len,\n                                       TAG_DATA,\n                                       hdrversion);\n        if (res)\n            goto cleanup;\n    }\n\n    /* SetState will make a copy of the buffer */\n    res = TPMLIB_SetState(st, plain, plain_len);\n\n    free(plain);\n\ncleanup:\n    free(mig_decrypt);\n\n    return res;\n}\n\n/* Example JSON output:\n *  { \"type\": \"swtpm\",\n *    \"states\": [ \"permall\", \"volatilestate\", \"savestate\" ]\n *  }\n */\nint SWTPM_NVRAM_PrintJson(void)\n{\n    TPM_RESULT rc = 0;\n    const char *backend_uri;\n    const char *states[] = {\n        TPM_PERMANENT_ALL_NAME,\n        TPM_VOLATILESTATE_NAME,\n        TPM_SAVESTATE_NAME,\n    };\n    char state_str[200] = \"\";\n    size_t i, n, o, blobsize;\n    int ret = -1;\n\n    rc = SWTPM_NVRAM_Init();\n    if (rc == 0) {\n        o = 0;\n        backend_uri = tpmstate_get_backend_uri();\n\n        for (i = 0; i < ARRAY_LEN(states); i++) {\n            rc = g_nvram_backend_ops->check_state(backend_uri, states[i],\n                                                  &blobsize);\n            if (rc == TPM_SUCCESS) {\n                n = snprintf(&state_str[o], sizeof(state_str) - o,\n                             \"%s {\\\"name\\\": \\\"%s\\\", \\\"size\\\": %zu}\",\n                             (o > 0) ? \",\" : \"\",\n                             states[i], blobsize);\n                if (n >= sizeof(state_str) - o)\n                    goto exit;\n                o += n;\n            } else if (rc != TPM_RETRY) {\n                /* Error other than ENOENT */\n                goto exit;\n            }\n        }\n        printf(\"{ \\\"type\\\": \\\"swtpm\\\", \\\"states\\\": [%s%s] }\",\n               state_str,  (o > 0) ? \" \": \"\");\n        ret = 0;\n    }\n\nexit:\n    return ret;\n}\n"], "filenames": ["src/swtpm/swtpm_nvstore.c"], "buggy_code_start_loc": [1077], "buggy_code_end_loc": [1105], "fixing_code_start_loc": [1078], "fixing_code_end_loc": [1114], "type": "CWE-125", "message": "swtpm is a libtpms-based TPM emulator with socket, character device, and Linux CUSE interface. Versions prior to 0.5.3, 0.6.2, and 0.7.1 are vulnerable to out-of-bounds read. A specially crafted header of swtpm's state, where the blobheader's hdrsize indicator has an invalid value, may cause an out-of-bounds access when the byte array representing the state of the TPM is accessed. This will likely crash swtpm or prevent it from starting since the state cannot be understood. Users should upgrade to swtpm v0.5.3, v0.6.2, or v0.7.1 to receive a patch. There are currently no known workarounds.", "other": {"cve": {"id": "CVE-2022-23645", "sourceIdentifier": "security-advisories@github.com", "published": "2022-02-18T21:15:13.090", "lastModified": "2022-03-07T13:49:53.093", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "swtpm is a libtpms-based TPM emulator with socket, character device, and Linux CUSE interface. Versions prior to 0.5.3, 0.6.2, and 0.7.1 are vulnerable to out-of-bounds read. A specially crafted header of swtpm's state, where the blobheader's hdrsize indicator has an invalid value, may cause an out-of-bounds access when the byte array representing the state of the TPM is accessed. This will likely crash swtpm or prevent it from starting since the state cannot be understood. Users should upgrade to swtpm v0.5.3, v0.6.2, or v0.7.1 to receive a patch. There are currently no known workarounds."}, {"lang": "es", "value": "swtpm es un emulador de TPM basado en libtpms con socket, dispositivo de caracteres e interfaz Linux CUSE. Las versiones anteriores a 0.5.3, 0.6.2 y 0.7.1, son vulnerables a una lectura fuera de l\u00edmites. Un encabezado especialmente dise\u00f1ado del estado de swtpm, donde el indicador hdrsize del blobheader presenta un valor no v\u00e1lido, puede causar un acceso fuera de l\u00edmites cuando es accedido al array de bytes que representa el estado del TPM. Esto probablemente bloquear\u00e1 swtpm o impedir\u00e1 que sea iniciado ya que el estado no puede ser entendido. Los usuarios deben actualizar a swtpm versi\u00f3n v0.5.3, v0.6.2, o v0.7.1 para recibir un parche. Actualmente no se presentan medidas de mitigaci\u00f3n conocidas"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.2, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.5, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:swtpm_project:swtpm:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.5.3", "matchCriteriaId": "29034260-C392-45E1-94C6-A3F7B2F579C1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:swtpm_project:swtpm:*:*:*:*:*:*:*:*", "versionStartIncluding": "0.6.0", "versionEndExcluding": "0.6.2", "matchCriteriaId": "F54F0E14-A4C4-4D58-999A-615E06AC63A1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:swtpm_project:swtpm:0.7.0:-:*:*:*:*:*:*", "matchCriteriaId": "93689630-E73B-4696-B455-CBB77A9FB8AD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:swtpm_project:swtpm:0.7.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "E560701C-A5E0-449B-B7DA-E5774DDBAEAC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:swtpm_project:swtpm:0.7.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "C38734A0-9671-48B5-9868-F916EF26B942"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "F4CFF558-3C47-480D-A2F0-BABF26042943"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}]}]}], "references": [{"url": "https://github.com/stefanberger/swtpm/commit/9f740868fc36761de27df3935513bdebf8852d19", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/stefanberger/swtpm/releases/tag/v0.5.3", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/stefanberger/swtpm/releases/tag/v0.6.2", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/stefanberger/swtpm/releases/tag/v0.7.1", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/stefanberger/swtpm/security/advisories/GHSA-2qgm-8xf4-3hqw", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/WL735FW266GO4C2JX4CJBOIOB7R7AY5A/", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/stefanberger/swtpm/commit/9f740868fc36761de27df3935513bdebf8852d19"}}