{"buggy_code": ["using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Runtime.CompilerServices;\n\nnamespace ServiceStack\n{\n    public static class EnumerableUtils\n    {\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static object FirstOrDefault(IEnumerable items)\n        {\n            if (items == null)\n                return null;\n            foreach (var item in items)\n            {\n                return item;\n            }\n            return null;\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static object ElementAt(IEnumerable items, int index)\n        {\n            if (items == null)\n                return null;\n            var i = 0;\n            foreach (var item in items)\n                if (i++ == index)\n                    return item;\n            return null;\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static List<object> Skip(IEnumerable items, int count)\n        {\n            if (items == null)\n                return TypeConstants.EmptyObjectList;\n            var to = new List<object>();\n            int i = 0;\n            foreach (var item in items)\n            {\n                if (count > i++)\n                    continue;\n\n                to.Add(item);\n            }\n            return to;\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static List<object> SplitOnFirst(IEnumerable items, out object first)\n        {\n            first = null;\n            if (items == null)\n                return TypeConstants.EmptyObjectList;\n            var to = new List<object>();\n            int i = 0;\n            foreach (var item in items)\n            {\n                if (i++ < 1)\n                {\n                    first = item;\n                    continue;\n                }\n                to.Add(item);\n            }\n            return to;\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static List<object> Take(IEnumerable items, int count)\n        {\n            if (items == null)\n                return TypeConstants.EmptyObjectList;\n            var to = new List<object>();\n            int i = 0;\n            foreach (var item in items)\n            {\n                if (count > i++)\n                {\n                    to.Add(item);\n                    continue;\n                }\n                return to;\n            }\n            return to;\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static int Count(IEnumerable items)\n        {\n            if (items == null)\n                return 0;\n            return items is ICollection c\n                ? c.Count\n                : items.Cast<object>().Count();\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static List<object> ToList(IEnumerable items)\n        {\n            if (items == null)\n                return TypeConstants.EmptyObjectList;\n            var to = new List<object>();\n            foreach (var item in items)\n            {\n                to.Add(item);\n            }\n            return to;\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static IEnumerable NullIfEmpty(IEnumerable items)\n        {\n            if (items != null)\n            {\n                foreach (var item in items)\n                    return items;\n            }\n            return null;\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static bool IsEmpty(IEnumerable items) => EnumerableUtils.NullIfEmpty(items) == null;\n    }\n    \n    public static class EnumerableExtensions\n    {\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static bool IsEmpty<T>(this ICollection<T> collection) => collection == null || collection.Count == 0;\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static bool IsEmpty<T>(this T[] collection) => collection == null || collection.Length == 0;\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static HashSet<T> ToHashSet<T>(this IEnumerable<T> items) => new HashSet<T>(items);\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static void Each<T>(this IEnumerable<T> values, Action<T> action)\n        {\n            if (values == null) return;\n\n            foreach (var value in values)\n            {\n                action(value);\n            }\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static void Each<T>(this IEnumerable<T> values, Action<int, T> action)\n        {\n            if (values == null) return;\n\n            var i = 0;\n            foreach (var value in values)\n            {\n                action(i++, value);\n            }\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static void Each<TKey, TValue>(this IDictionary<TKey, TValue> map, Action<TKey, TValue> action)\n        {\n            if (map == null) return;\n\n            var keys = map.Keys.ToList();\n            foreach (var key in keys)\n            {\n                action(key, map[key]);\n            }\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static List<To> Map<To, From>(this IEnumerable<From> items, Func<From, To> converter)\n        {\n            if (items == null)\n                return new List<To>();\n\n            var list = new List<To>();\n            foreach (var item in items)\n            {\n                list.Add(converter(item));\n            }\n            return list;\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static List<To> Map<To>(this System.Collections.IEnumerable items, Func<object, To> converter)\n        {\n            if (items == null)\n                return new List<To>();\n\n            var list = new List<To>();\n            foreach (var item in items)\n            {\n                list.Add(converter(item));\n            }\n            return list;\n        }\n        \n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static List<object> ToObjects<T>(this IEnumerable<T> items)\n        {\n            var to = new List<object>();\n            foreach (var item in items)\n            {\n                to.Add(item);\n            }\n            return to;\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static string FirstNonDefaultOrEmpty(this IEnumerable<string> values)\n        {\n            foreach (var value in values)\n            {\n                if (!string.IsNullOrEmpty(value)) return value;\n            }\n            return null;\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static T FirstNonDefault<T>(this IEnumerable<T> values)\n        {\n            foreach (var value in values)\n            {\n                if (!Equals(value, default(T))) return value;\n            }\n            return default(T);\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static bool EquivalentTo(this byte[] bytes, byte[] other)\n        {\n            var compare = 0;\n            for (var i = 0; i < other.Length; i++)\n                compare |= other[i] ^ bytes[i];\n\n            return compare == 0;\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static bool EquivalentTo<T>(this T[] array, T[] otherArray, Func<T, T, bool> comparer = null)\n        {\n            if (array == null || otherArray == null)\n                return array == otherArray;\n\n            if (array.Length != otherArray.Length)\n                return false;\n\n            if (comparer == null)\n                comparer = (v1, v2) => v1.Equals(v2);\n\n            for (var i = 0; i < array.Length; i++)\n            {\n                if (!comparer(array[i], otherArray[i]))\n                    return false;\n            }\n\n            return true;\n        }\n\n        public static bool EquivalentTo<T>(this IEnumerable<T> thisList, IEnumerable<T> otherList, Func<T, T, bool> comparer = null)\n        {\n            if (comparer == null)\n                comparer = (v1, v2) => v1.Equals(v2);\n\n            if (thisList == null || otherList == null)\n                return thisList == otherList;\n\n            var otherEnum = otherList.GetEnumerator();\n            foreach (var item in thisList)\n            {\n                if (!otherEnum.MoveNext()) return false;\n\n                var thisIsDefault = Equals(item, default(T));\n                var otherIsDefault = Equals(otherEnum.Current, default(T));\n                if (thisIsDefault || otherIsDefault)\n                {\n                    return thisIsDefault && otherIsDefault;\n                }\n\n                if (!comparer(item, otherEnum.Current)) return false;\n            }\n            var hasNoMoreLeftAsWell = !otherEnum.MoveNext();\n            return hasNoMoreLeftAsWell;\n        }\n\n        public static bool EquivalentTo<K, V>(this IDictionary<K, V> a, IDictionary<K, V> b, Func<V,V,bool> comparer = null)\n        {\n            if (comparer == null)\n                comparer = (v1, v2) => v1.Equals(v2);\n\n            if (a == null || b == null)\n                return a == b;\n\n            if (a.Count != b.Count)\n                return false;\n\n            foreach (var entry in a)\n            {\n                V value;\n                if (!b.TryGetValue(entry.Key, out value))\n                    return false;\n                if (entry.Value == null || value == null)\n                {\n                    if (entry.Value == null && value == null)\n                        continue;\n\n                    return false;\n                }\n                if (!comparer(entry.Value, value))\n                    return false;\n            }\n            return true;\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static IEnumerable<T[]> BatchesOf<T>(this IEnumerable<T> sequence, int batchSize)\n        {\n            var batch = new List<T>(batchSize);\n            foreach (var item in sequence)\n            {\n                batch.Add(item);\n                if (batch.Count >= batchSize)\n                {\n                    yield return batch.ToArray();\n                    batch.Clear();\n                }\n            }\n\n            if (batch.Count > 0)\n            {\n                yield return batch.ToArray();\n                batch.Clear();\n            }\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static Dictionary<TKey, T> ToSafeDictionary<T, TKey>(this IEnumerable<T> list, Func<T, TKey> expr)\n        {\n            var map = new Dictionary<TKey, T>();\n            if (list != null)\n            {\n                foreach (var item in list)\n                {\n                    map[expr(item)] = item;\n                }\n            }\n            return map;\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static Dictionary<TKey, TValue> ToDictionary<T, TKey, TValue>(this IEnumerable<T> list, Func<T, KeyValuePair<TKey, TValue>> map)\n        {\n            var to = new Dictionary<TKey, TValue>();\n            foreach (var item in list)\n            {\n                var entry = map(item);\n                to[entry.Key] = entry.Value;\n            }\n            return to;\n        }\n\n        /// <summary>\n        /// Return T[0] when enumerable is null, safe to use in enumerations like foreach\n        /// </summary>\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static IEnumerable<T> Safe<T>(this IEnumerable<T> enumerable) => enumerable ?? TypeConstants<T>.EmptyArray;\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static IEnumerable Safe(this IEnumerable enumerable) => enumerable ?? TypeConstants.EmptyObjectArray;\n    }\n}"], "fixing_code": ["using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Runtime.CompilerServices;\n\nnamespace ServiceStack\n{\n    public static class EnumerableUtils\n    {\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static object FirstOrDefault(IEnumerable items)\n        {\n            if (items == null)\n                return null;\n            foreach (var item in items)\n            {\n                return item;\n            }\n            return null;\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static object ElementAt(IEnumerable items, int index)\n        {\n            if (items == null)\n                return null;\n            var i = 0;\n            foreach (var item in items)\n                if (i++ == index)\n                    return item;\n            return null;\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static List<object> Skip(IEnumerable items, int count)\n        {\n            if (items == null)\n                return TypeConstants.EmptyObjectList;\n            var to = new List<object>();\n            int i = 0;\n            foreach (var item in items)\n            {\n                if (count > i++)\n                    continue;\n\n                to.Add(item);\n            }\n            return to;\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static List<object> SplitOnFirst(IEnumerable items, out object first)\n        {\n            first = null;\n            if (items == null)\n                return TypeConstants.EmptyObjectList;\n            var to = new List<object>();\n            int i = 0;\n            foreach (var item in items)\n            {\n                if (i++ < 1)\n                {\n                    first = item;\n                    continue;\n                }\n                to.Add(item);\n            }\n            return to;\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static List<object> Take(IEnumerable items, int count)\n        {\n            if (items == null)\n                return TypeConstants.EmptyObjectList;\n            var to = new List<object>();\n            int i = 0;\n            foreach (var item in items)\n            {\n                if (count > i++)\n                {\n                    to.Add(item);\n                    continue;\n                }\n                return to;\n            }\n            return to;\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static int Count(IEnumerable items)\n        {\n            if (items == null)\n                return 0;\n            return items is ICollection c\n                ? c.Count\n                : items.Cast<object>().Count();\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static List<object> ToList(IEnumerable items)\n        {\n            if (items == null)\n                return TypeConstants.EmptyObjectList;\n            var to = new List<object>();\n            foreach (var item in items)\n            {\n                to.Add(item);\n            }\n            return to;\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static IEnumerable NullIfEmpty(IEnumerable items)\n        {\n            if (items != null)\n            {\n                foreach (var item in items)\n                    return items;\n            }\n            return null;\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static bool IsEmpty(IEnumerable items) => EnumerableUtils.NullIfEmpty(items) == null;\n    }\n    \n    public static class EnumerableExtensions\n    {\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static bool IsEmpty<T>(this ICollection<T> collection) => collection == null || collection.Count == 0;\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static bool IsEmpty<T>(this T[] collection) => collection == null || collection.Length == 0;\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static HashSet<T> ToHashSet<T>(this IEnumerable<T> items) => new HashSet<T>(items);\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static void Each<T>(this IEnumerable<T> values, Action<T> action)\n        {\n            if (values == null) return;\n\n            foreach (var value in values)\n            {\n                action(value);\n            }\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static void Each<T>(this IEnumerable<T> values, Action<int, T> action)\n        {\n            if (values == null) return;\n\n            var i = 0;\n            foreach (var value in values)\n            {\n                action(i++, value);\n            }\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static void Each<TKey, TValue>(this IDictionary<TKey, TValue> map, Action<TKey, TValue> action)\n        {\n            if (map == null) return;\n\n            var keys = map.Keys.ToList();\n            foreach (var key in keys)\n            {\n                action(key, map[key]);\n            }\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static List<To> Map<To, From>(this IEnumerable<From> items, Func<From, To> converter)\n        {\n            if (items == null)\n                return new List<To>();\n\n            var list = new List<To>();\n            foreach (var item in items)\n            {\n                list.Add(converter(item));\n            }\n            return list;\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static List<To> Map<To>(this System.Collections.IEnumerable items, Func<object, To> converter)\n        {\n            if (items == null)\n                return new List<To>();\n\n            var list = new List<To>();\n            foreach (var item in items)\n            {\n                list.Add(converter(item));\n            }\n            return list;\n        }\n        \n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static List<object> ToObjects<T>(this IEnumerable<T> items)\n        {\n            var to = new List<object>();\n            foreach (var item in items)\n            {\n                to.Add(item);\n            }\n            return to;\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static string FirstNonDefaultOrEmpty(this IEnumerable<string> values)\n        {\n            foreach (var value in values)\n            {\n                if (!string.IsNullOrEmpty(value)) return value;\n            }\n            return null;\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static T FirstNonDefault<T>(this IEnumerable<T> values)\n        {\n            foreach (var value in values)\n            {\n                if (!Equals(value, default(T))) return value;\n            }\n            return default(T);\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static bool EquivalentTo(this byte[] bytes, byte[] other)\n        {\n            if (bytes == null || other == null)\n                return bytes == other;\n\n            if (bytes.Length != other.Length)\n                return false;\n\n            var compare = 0;\n            for (var i = 0; i < other.Length; i++)\n                compare |= other[i] ^ bytes[i];\n\n            return compare == 0;\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static bool EquivalentTo<T>(this T[] array, T[] otherArray, Func<T, T, bool> comparer = null)\n        {\n            if (array == null || otherArray == null)\n                return array == otherArray;\n\n            if (array.Length != otherArray.Length)\n                return false;\n\n            if (comparer == null)\n                comparer = (v1, v2) => v1.Equals(v2);\n\n            for (var i = 0; i < array.Length; i++)\n            {\n                if (!comparer(array[i], otherArray[i]))\n                    return false;\n            }\n\n            return true;\n        }\n\n        public static bool EquivalentTo<T>(this IEnumerable<T> thisList, IEnumerable<T> otherList, Func<T, T, bool> comparer = null)\n        {\n            if (comparer == null)\n                comparer = (v1, v2) => v1.Equals(v2);\n\n            if (thisList == null || otherList == null)\n                return thisList == otherList;\n\n            var otherEnum = otherList.GetEnumerator();\n            foreach (var item in thisList)\n            {\n                if (!otherEnum.MoveNext()) return false;\n\n                var thisIsDefault = Equals(item, default(T));\n                var otherIsDefault = Equals(otherEnum.Current, default(T));\n                if (thisIsDefault || otherIsDefault)\n                {\n                    return thisIsDefault && otherIsDefault;\n                }\n\n                if (!comparer(item, otherEnum.Current)) return false;\n            }\n            var hasNoMoreLeftAsWell = !otherEnum.MoveNext();\n            return hasNoMoreLeftAsWell;\n        }\n\n        public static bool EquivalentTo<K, V>(this IDictionary<K, V> a, IDictionary<K, V> b, Func<V,V,bool> comparer = null)\n        {\n            if (comparer == null)\n                comparer = (v1, v2) => v1.Equals(v2);\n\n            if (a == null || b == null)\n                return a == b;\n\n            if (a.Count != b.Count)\n                return false;\n\n            foreach (var entry in a)\n            {\n                V value;\n                if (!b.TryGetValue(entry.Key, out value))\n                    return false;\n                if (entry.Value == null || value == null)\n                {\n                    if (entry.Value == null && value == null)\n                        continue;\n\n                    return false;\n                }\n                if (!comparer(entry.Value, value))\n                    return false;\n            }\n            return true;\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static IEnumerable<T[]> BatchesOf<T>(this IEnumerable<T> sequence, int batchSize)\n        {\n            var batch = new List<T>(batchSize);\n            foreach (var item in sequence)\n            {\n                batch.Add(item);\n                if (batch.Count >= batchSize)\n                {\n                    yield return batch.ToArray();\n                    batch.Clear();\n                }\n            }\n\n            if (batch.Count > 0)\n            {\n                yield return batch.ToArray();\n                batch.Clear();\n            }\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static Dictionary<TKey, T> ToSafeDictionary<T, TKey>(this IEnumerable<T> list, Func<T, TKey> expr)\n        {\n            var map = new Dictionary<TKey, T>();\n            if (list != null)\n            {\n                foreach (var item in list)\n                {\n                    map[expr(item)] = item;\n                }\n            }\n            return map;\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static Dictionary<TKey, TValue> ToDictionary<T, TKey, TValue>(this IEnumerable<T> list, Func<T, KeyValuePair<TKey, TValue>> map)\n        {\n            var to = new Dictionary<TKey, TValue>();\n            foreach (var item in list)\n            {\n                var entry = map(item);\n                to[entry.Key] = entry.Value;\n            }\n            return to;\n        }\n\n        /// <summary>\n        /// Return T[0] when enumerable is null, safe to use in enumerations like foreach\n        /// </summary>\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static IEnumerable<T> Safe<T>(this IEnumerable<T> enumerable) => enumerable ?? TypeConstants<T>.EmptyArray;\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static IEnumerable Safe(this IEnumerable enumerable) => enumerable ?? TypeConstants.EmptyObjectArray;\n    }\n}"], "filenames": ["src/ServiceStack.Common/EnumerableExtensions.cs"], "buggy_code_start_loc": [236], "buggy_code_end_loc": [236], "fixing_code_start_loc": [237], "fixing_code_end_loc": [243], "type": "CWE-347", "message": "ServiceStack before 5.9.2 mishandles JWT signature verification unless an application has a custom ValidateToken function that establishes a valid minimum length for a signature.", "other": {"cve": {"id": "CVE-2020-28042", "sourceIdentifier": "cve@mitre.org", "published": "2020-11-02T21:15:31.320", "lastModified": "2020-11-17T17:55:08.300", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "ServiceStack before 5.9.2 mishandles JWT signature verification unless an application has a custom ValidateToken function that establishes a valid minimum length for a signature."}, {"lang": "es", "value": "ServiceStack versiones anteriores a 5.9.2, manejan inapropiadamente la verificaci\u00f3n de la firma JWT a menos que una aplicaci\u00f3n tenga una funci\u00f3n ValidateToken personalizado que establezca una longitud m\u00ednima v\u00e1lida para una firma"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-347"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:servicestack:servicestack:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.9.2", "matchCriteriaId": "3CEA8F43-A1EA-4A89-9533-01F5F8163C56"}]}]}], "references": [{"url": "https://forums.servicestack.net/t/servicestack-v5-9-2-released/8850", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://github.com/ServiceStack/ServiceStack/commit/540d4060e877a03ae95343c1a8560a26768585ee", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.shielder.it/advisories/servicestack-jwt-signature-verification-bypass/", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://www.shielder.it/blog/2020/11/re-discovering-a-jwt-authentication-bypass-in-servicestack/", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ServiceStack/ServiceStack/commit/540d4060e877a03ae95343c1a8560a26768585ee"}}