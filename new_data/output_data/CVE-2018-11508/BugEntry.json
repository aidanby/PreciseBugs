{"buggy_code": ["/*\n *  linux/kernel/compat.c\n *\n *  Kernel compatibililty routines for e.g. 32 bit syscall support\n *  on 64 bit kernels.\n *\n *  Copyright (C) 2002-2003 Stephen Rothwell, IBM Corporation\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License version 2 as\n *  published by the Free Software Foundation.\n */\n\n#include <linux/linkage.h>\n#include <linux/compat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/signal.h>\n#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */\n#include <linux/syscalls.h>\n#include <linux/unistd.h>\n#include <linux/security.h>\n#include <linux/timex.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n#include <linux/posix-timers.h>\n#include <linux/times.h>\n#include <linux/ptrace.h>\n#include <linux/gfp.h>\n\n#include <linux/uaccess.h>\n\nint compat_get_timex(struct timex *txc, const struct compat_timex __user *utp)\n{\n\tstruct compat_timex tx32;\n\n\tif (copy_from_user(&tx32, utp, sizeof(struct compat_timex)))\n\t\treturn -EFAULT;\n\n\ttxc->modes = tx32.modes;\n\ttxc->offset = tx32.offset;\n\ttxc->freq = tx32.freq;\n\ttxc->maxerror = tx32.maxerror;\n\ttxc->esterror = tx32.esterror;\n\ttxc->status = tx32.status;\n\ttxc->constant = tx32.constant;\n\ttxc->precision = tx32.precision;\n\ttxc->tolerance = tx32.tolerance;\n\ttxc->time.tv_sec = tx32.time.tv_sec;\n\ttxc->time.tv_usec = tx32.time.tv_usec;\n\ttxc->tick = tx32.tick;\n\ttxc->ppsfreq = tx32.ppsfreq;\n\ttxc->jitter = tx32.jitter;\n\ttxc->shift = tx32.shift;\n\ttxc->stabil = tx32.stabil;\n\ttxc->jitcnt = tx32.jitcnt;\n\ttxc->calcnt = tx32.calcnt;\n\ttxc->errcnt = tx32.errcnt;\n\ttxc->stbcnt = tx32.stbcnt;\n\n\treturn 0;\n}\n\nint compat_put_timex(struct compat_timex __user *utp, const struct timex *txc)\n{\n\tstruct compat_timex tx32;\n\n\tmemset(&tx32, 0, sizeof(struct compat_timex));\n\ttx32.modes = txc->modes;\n\ttx32.offset = txc->offset;\n\ttx32.freq = txc->freq;\n\ttx32.maxerror = txc->maxerror;\n\ttx32.esterror = txc->esterror;\n\ttx32.status = txc->status;\n\ttx32.constant = txc->constant;\n\ttx32.precision = txc->precision;\n\ttx32.tolerance = txc->tolerance;\n\ttx32.time.tv_sec = txc->time.tv_sec;\n\ttx32.time.tv_usec = txc->time.tv_usec;\n\ttx32.tick = txc->tick;\n\ttx32.ppsfreq = txc->ppsfreq;\n\ttx32.jitter = txc->jitter;\n\ttx32.shift = txc->shift;\n\ttx32.stabil = txc->stabil;\n\ttx32.jitcnt = txc->jitcnt;\n\ttx32.calcnt = txc->calcnt;\n\ttx32.errcnt = txc->errcnt;\n\ttx32.stbcnt = txc->stbcnt;\n\ttx32.tai = txc->tai;\n\tif (copy_to_user(utp, &tx32, sizeof(struct compat_timex)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int __compat_get_timeval(struct timeval *tv, const struct compat_timeval __user *ctv)\n{\n\treturn (!access_ok(VERIFY_READ, ctv, sizeof(*ctv)) ||\n\t\t\t__get_user(tv->tv_sec, &ctv->tv_sec) ||\n\t\t\t__get_user(tv->tv_usec, &ctv->tv_usec)) ? -EFAULT : 0;\n}\n\nstatic int __compat_put_timeval(const struct timeval *tv, struct compat_timeval __user *ctv)\n{\n\treturn (!access_ok(VERIFY_WRITE, ctv, sizeof(*ctv)) ||\n\t\t\t__put_user(tv->tv_sec, &ctv->tv_sec) ||\n\t\t\t__put_user(tv->tv_usec, &ctv->tv_usec)) ? -EFAULT : 0;\n}\n\nstatic int __compat_get_timespec(struct timespec *ts, const struct compat_timespec __user *cts)\n{\n\treturn (!access_ok(VERIFY_READ, cts, sizeof(*cts)) ||\n\t\t\t__get_user(ts->tv_sec, &cts->tv_sec) ||\n\t\t\t__get_user(ts->tv_nsec, &cts->tv_nsec)) ? -EFAULT : 0;\n}\n\nstatic int __compat_put_timespec(const struct timespec *ts, struct compat_timespec __user *cts)\n{\n\treturn (!access_ok(VERIFY_WRITE, cts, sizeof(*cts)) ||\n\t\t\t__put_user(ts->tv_sec, &cts->tv_sec) ||\n\t\t\t__put_user(ts->tv_nsec, &cts->tv_nsec)) ? -EFAULT : 0;\n}\n\nstatic int __compat_get_timespec64(struct timespec64 *ts64,\n\t\t\t\t   const struct compat_timespec __user *cts)\n{\n\tstruct compat_timespec ts;\n\tint ret;\n\n\tret = copy_from_user(&ts, cts, sizeof(ts));\n\tif (ret)\n\t\treturn -EFAULT;\n\n\tts64->tv_sec = ts.tv_sec;\n\tts64->tv_nsec = ts.tv_nsec;\n\n\treturn 0;\n}\n\nstatic int __compat_put_timespec64(const struct timespec64 *ts64,\n\t\t\t\t   struct compat_timespec __user *cts)\n{\n\tstruct compat_timespec ts = {\n\t\t.tv_sec = ts64->tv_sec,\n\t\t.tv_nsec = ts64->tv_nsec\n\t};\n\treturn copy_to_user(cts, &ts, sizeof(ts)) ? -EFAULT : 0;\n}\n\nint compat_get_timespec64(struct timespec64 *ts, const void __user *uts)\n{\n\tif (COMPAT_USE_64BIT_TIME)\n\t\treturn copy_from_user(ts, uts, sizeof(*ts)) ? -EFAULT : 0;\n\telse\n\t\treturn __compat_get_timespec64(ts, uts);\n}\nEXPORT_SYMBOL_GPL(compat_get_timespec64);\n\nint compat_put_timespec64(const struct timespec64 *ts, void __user *uts)\n{\n\tif (COMPAT_USE_64BIT_TIME)\n\t\treturn copy_to_user(uts, ts, sizeof(*ts)) ? -EFAULT : 0;\n\telse\n\t\treturn __compat_put_timespec64(ts, uts);\n}\nEXPORT_SYMBOL_GPL(compat_put_timespec64);\n\nint compat_get_timeval(struct timeval *tv, const void __user *utv)\n{\n\tif (COMPAT_USE_64BIT_TIME)\n\t\treturn copy_from_user(tv, utv, sizeof(*tv)) ? -EFAULT : 0;\n\telse\n\t\treturn __compat_get_timeval(tv, utv);\n}\nEXPORT_SYMBOL_GPL(compat_get_timeval);\n\nint compat_put_timeval(const struct timeval *tv, void __user *utv)\n{\n\tif (COMPAT_USE_64BIT_TIME)\n\t\treturn copy_to_user(utv, tv, sizeof(*tv)) ? -EFAULT : 0;\n\telse\n\t\treturn __compat_put_timeval(tv, utv);\n}\nEXPORT_SYMBOL_GPL(compat_put_timeval);\n\nint compat_get_timespec(struct timespec *ts, const void __user *uts)\n{\n\tif (COMPAT_USE_64BIT_TIME)\n\t\treturn copy_from_user(ts, uts, sizeof(*ts)) ? -EFAULT : 0;\n\telse\n\t\treturn __compat_get_timespec(ts, uts);\n}\nEXPORT_SYMBOL_GPL(compat_get_timespec);\n\nint compat_put_timespec(const struct timespec *ts, void __user *uts)\n{\n\tif (COMPAT_USE_64BIT_TIME)\n\t\treturn copy_to_user(uts, ts, sizeof(*ts)) ? -EFAULT : 0;\n\telse\n\t\treturn __compat_put_timespec(ts, uts);\n}\nEXPORT_SYMBOL_GPL(compat_put_timespec);\n\nint get_compat_itimerval(struct itimerval *o, const struct compat_itimerval __user *i)\n{\n\tstruct compat_itimerval v32;\n\n\tif (copy_from_user(&v32, i, sizeof(struct compat_itimerval)))\n\t\treturn -EFAULT;\n\to->it_interval.tv_sec = v32.it_interval.tv_sec;\n\to->it_interval.tv_usec = v32.it_interval.tv_usec;\n\to->it_value.tv_sec = v32.it_value.tv_sec;\n\to->it_value.tv_usec = v32.it_value.tv_usec;\n\treturn 0;\n}\n\nint put_compat_itimerval(struct compat_itimerval __user *o, const struct itimerval *i)\n{\n\tstruct compat_itimerval v32;\n\n\tv32.it_interval.tv_sec = i->it_interval.tv_sec;\n\tv32.it_interval.tv_usec = i->it_interval.tv_usec;\n\tv32.it_value.tv_sec = i->it_value.tv_sec;\n\tv32.it_value.tv_usec = i->it_value.tv_usec;\n\treturn copy_to_user(o, &v32, sizeof(struct compat_itimerval)) ? -EFAULT : 0;\n}\n\n#ifdef __ARCH_WANT_SYS_SIGPROCMASK\n\n/*\n * sys_sigprocmask SIG_SETMASK sets the first (compat) word of the\n * blocked set of signals to the supplied signal set\n */\nstatic inline void compat_sig_setmask(sigset_t *blocked, compat_sigset_word set)\n{\n\tmemcpy(blocked->sig, &set, sizeof(set));\n}\n\nCOMPAT_SYSCALL_DEFINE3(sigprocmask, int, how,\n\t\t       compat_old_sigset_t __user *, nset,\n\t\t       compat_old_sigset_t __user *, oset)\n{\n\told_sigset_t old_set, new_set;\n\tsigset_t new_blocked;\n\n\told_set = current->blocked.sig[0];\n\n\tif (nset) {\n\t\tif (get_user(new_set, nset))\n\t\t\treturn -EFAULT;\n\t\tnew_set &= ~(sigmask(SIGKILL) | sigmask(SIGSTOP));\n\n\t\tnew_blocked = current->blocked;\n\n\t\tswitch (how) {\n\t\tcase SIG_BLOCK:\n\t\t\tsigaddsetmask(&new_blocked, new_set);\n\t\t\tbreak;\n\t\tcase SIG_UNBLOCK:\n\t\t\tsigdelsetmask(&new_blocked, new_set);\n\t\t\tbreak;\n\t\tcase SIG_SETMASK:\n\t\t\tcompat_sig_setmask(&new_blocked, new_set);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tset_current_blocked(&new_blocked);\n\t}\n\n\tif (oset) {\n\t\tif (put_user(old_set, oset))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\n#endif\n\nint put_compat_rusage(const struct rusage *r, struct compat_rusage __user *ru)\n{\n\tstruct compat_rusage r32;\n\tmemset(&r32, 0, sizeof(r32));\n\tr32.ru_utime.tv_sec = r->ru_utime.tv_sec;\n\tr32.ru_utime.tv_usec = r->ru_utime.tv_usec;\n\tr32.ru_stime.tv_sec = r->ru_stime.tv_sec;\n\tr32.ru_stime.tv_usec = r->ru_stime.tv_usec;\n\tr32.ru_maxrss = r->ru_maxrss;\n\tr32.ru_ixrss = r->ru_ixrss;\n\tr32.ru_idrss = r->ru_idrss;\n\tr32.ru_isrss = r->ru_isrss;\n\tr32.ru_minflt = r->ru_minflt;\n\tr32.ru_majflt = r->ru_majflt;\n\tr32.ru_nswap = r->ru_nswap;\n\tr32.ru_inblock = r->ru_inblock;\n\tr32.ru_oublock = r->ru_oublock;\n\tr32.ru_msgsnd = r->ru_msgsnd;\n\tr32.ru_msgrcv = r->ru_msgrcv;\n\tr32.ru_nsignals = r->ru_nsignals;\n\tr32.ru_nvcsw = r->ru_nvcsw;\n\tr32.ru_nivcsw = r->ru_nivcsw;\n\tif (copy_to_user(ru, &r32, sizeof(r32)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int compat_get_user_cpu_mask(compat_ulong_t __user *user_mask_ptr,\n\t\t\t\t    unsigned len, struct cpumask *new_mask)\n{\n\tunsigned long *k;\n\n\tif (len < cpumask_size())\n\t\tmemset(new_mask, 0, cpumask_size());\n\telse if (len > cpumask_size())\n\t\tlen = cpumask_size();\n\n\tk = cpumask_bits(new_mask);\n\treturn compat_get_bitmap(k, user_mask_ptr, len * 8);\n}\n\nCOMPAT_SYSCALL_DEFINE3(sched_setaffinity, compat_pid_t, pid,\n\t\t       unsigned int, len,\n\t\t       compat_ulong_t __user *, user_mask_ptr)\n{\n\tcpumask_var_t new_mask;\n\tint retval;\n\n\tif (!alloc_cpumask_var(&new_mask, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tretval = compat_get_user_cpu_mask(user_mask_ptr, len, new_mask);\n\tif (retval)\n\t\tgoto out;\n\n\tretval = sched_setaffinity(pid, new_mask);\nout:\n\tfree_cpumask_var(new_mask);\n\treturn retval;\n}\n\nCOMPAT_SYSCALL_DEFINE3(sched_getaffinity, compat_pid_t,  pid, unsigned int, len,\n\t\t       compat_ulong_t __user *, user_mask_ptr)\n{\n\tint ret;\n\tcpumask_var_t mask;\n\n\tif ((len * BITS_PER_BYTE) < nr_cpu_ids)\n\t\treturn -EINVAL;\n\tif (len & (sizeof(compat_ulong_t)-1))\n\t\treturn -EINVAL;\n\n\tif (!alloc_cpumask_var(&mask, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tret = sched_getaffinity(pid, mask);\n\tif (ret == 0) {\n\t\tunsigned int retlen = min(len, cpumask_size());\n\n\t\tif (compat_put_bitmap(user_mask_ptr, cpumask_bits(mask), retlen * 8))\n\t\t\tret = -EFAULT;\n\t\telse\n\t\t\tret = retlen;\n\t}\n\tfree_cpumask_var(mask);\n\n\treturn ret;\n}\n\nint get_compat_itimerspec64(struct itimerspec64 *its,\n\t\t\tconst struct compat_itimerspec __user *uits)\n{\n\n\tif (__compat_get_timespec64(&its->it_interval, &uits->it_interval) ||\n\t    __compat_get_timespec64(&its->it_value, &uits->it_value))\n\t\treturn -EFAULT;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(get_compat_itimerspec64);\n\nint put_compat_itimerspec64(const struct itimerspec64 *its,\n\t\t\tstruct compat_itimerspec __user *uits)\n{\n\tif (__compat_put_timespec64(&its->it_interval, &uits->it_interval) ||\n\t    __compat_put_timespec64(&its->it_value, &uits->it_value))\n\t\treturn -EFAULT;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(put_compat_itimerspec64);\n\n/*\n * We currently only need the following fields from the sigevent\n * structure: sigev_value, sigev_signo, sig_notify and (sometimes\n * sigev_notify_thread_id).  The others are handled in user mode.\n * We also assume that copying sigev_value.sival_int is sufficient\n * to keep all the bits of sigev_value.sival_ptr intact.\n */\nint get_compat_sigevent(struct sigevent *event,\n\t\tconst struct compat_sigevent __user *u_event)\n{\n\tmemset(event, 0, sizeof(*event));\n\treturn (!access_ok(VERIFY_READ, u_event, sizeof(*u_event)) ||\n\t\t__get_user(event->sigev_value.sival_int,\n\t\t\t&u_event->sigev_value.sival_int) ||\n\t\t__get_user(event->sigev_signo, &u_event->sigev_signo) ||\n\t\t__get_user(event->sigev_notify, &u_event->sigev_notify) ||\n\t\t__get_user(event->sigev_notify_thread_id,\n\t\t\t&u_event->sigev_notify_thread_id))\n\t\t? -EFAULT : 0;\n}\n\nlong compat_get_bitmap(unsigned long *mask, const compat_ulong_t __user *umask,\n\t\t       unsigned long bitmap_size)\n{\n\tunsigned long nr_compat_longs;\n\n\t/* align bitmap up to nearest compat_long_t boundary */\n\tbitmap_size = ALIGN(bitmap_size, BITS_PER_COMPAT_LONG);\n\tnr_compat_longs = BITS_TO_COMPAT_LONGS(bitmap_size);\n\n\tif (!access_ok(VERIFY_READ, umask, bitmap_size / 8))\n\t\treturn -EFAULT;\n\n\tuser_access_begin();\n\twhile (nr_compat_longs > 1) {\n\t\tcompat_ulong_t l1, l2;\n\t\tunsafe_get_user(l1, umask++, Efault);\n\t\tunsafe_get_user(l2, umask++, Efault);\n\t\t*mask++ = ((unsigned long)l2 << BITS_PER_COMPAT_LONG) | l1;\n\t\tnr_compat_longs -= 2;\n\t}\n\tif (nr_compat_longs)\n\t\tunsafe_get_user(*mask, umask++, Efault);\n\tuser_access_end();\n\treturn 0;\n\nEfault:\n\tuser_access_end();\n\treturn -EFAULT;\n}\n\nlong compat_put_bitmap(compat_ulong_t __user *umask, unsigned long *mask,\n\t\t       unsigned long bitmap_size)\n{\n\tunsigned long nr_compat_longs;\n\n\t/* align bitmap up to nearest compat_long_t boundary */\n\tbitmap_size = ALIGN(bitmap_size, BITS_PER_COMPAT_LONG);\n\tnr_compat_longs = BITS_TO_COMPAT_LONGS(bitmap_size);\n\n\tif (!access_ok(VERIFY_WRITE, umask, bitmap_size / 8))\n\t\treturn -EFAULT;\n\n\tuser_access_begin();\n\twhile (nr_compat_longs > 1) {\n\t\tunsigned long m = *mask++;\n\t\tunsafe_put_user((compat_ulong_t)m, umask++, Efault);\n\t\tunsafe_put_user(m >> BITS_PER_COMPAT_LONG, umask++, Efault);\n\t\tnr_compat_longs -= 2;\n\t}\n\tif (nr_compat_longs)\n\t\tunsafe_put_user((compat_ulong_t)*mask, umask++, Efault);\n\tuser_access_end();\n\treturn 0;\nEfault:\n\tuser_access_end();\n\treturn -EFAULT;\n}\n\nint\nget_compat_sigset(sigset_t *set, const compat_sigset_t __user *compat)\n{\n#ifdef __BIG_ENDIAN\n\tcompat_sigset_t v;\n\tif (copy_from_user(&v, compat, sizeof(compat_sigset_t)))\n\t\treturn -EFAULT;\n\tswitch (_NSIG_WORDS) {\n\tcase 4: set->sig[3] = v.sig[6] | (((long)v.sig[7]) << 32 );\n\tcase 3: set->sig[2] = v.sig[4] | (((long)v.sig[5]) << 32 );\n\tcase 2: set->sig[1] = v.sig[2] | (((long)v.sig[3]) << 32 );\n\tcase 1: set->sig[0] = v.sig[0] | (((long)v.sig[1]) << 32 );\n\t}\n#else\n\tif (copy_from_user(set, compat, sizeof(compat_sigset_t)))\n\t\treturn -EFAULT;\n#endif\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(get_compat_sigset);\n\n/*\n * Allocate user-space memory for the duration of a single system call,\n * in order to marshall parameters inside a compat thunk.\n */\nvoid __user *compat_alloc_user_space(unsigned long len)\n{\n\tvoid __user *ptr;\n\n\t/* If len would occupy more than half of the entire compat space... */\n\tif (unlikely(len > (((compat_uptr_t)~0) >> 1)))\n\t\treturn NULL;\n\n\tptr = arch_compat_alloc_user_space(len);\n\n\tif (unlikely(!access_ok(VERIFY_WRITE, ptr, len)))\n\t\treturn NULL;\n\n\treturn ptr;\n}\nEXPORT_SYMBOL_GPL(compat_alloc_user_space);\n"], "fixing_code": ["/*\n *  linux/kernel/compat.c\n *\n *  Kernel compatibililty routines for e.g. 32 bit syscall support\n *  on 64 bit kernels.\n *\n *  Copyright (C) 2002-2003 Stephen Rothwell, IBM Corporation\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License version 2 as\n *  published by the Free Software Foundation.\n */\n\n#include <linux/linkage.h>\n#include <linux/compat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/signal.h>\n#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */\n#include <linux/syscalls.h>\n#include <linux/unistd.h>\n#include <linux/security.h>\n#include <linux/timex.h>\n#include <linux/export.h>\n#include <linux/migrate.h>\n#include <linux/posix-timers.h>\n#include <linux/times.h>\n#include <linux/ptrace.h>\n#include <linux/gfp.h>\n\n#include <linux/uaccess.h>\n\nint compat_get_timex(struct timex *txc, const struct compat_timex __user *utp)\n{\n\tstruct compat_timex tx32;\n\n\tmemset(txc, 0, sizeof(struct timex));\n\tif (copy_from_user(&tx32, utp, sizeof(struct compat_timex)))\n\t\treturn -EFAULT;\n\n\ttxc->modes = tx32.modes;\n\ttxc->offset = tx32.offset;\n\ttxc->freq = tx32.freq;\n\ttxc->maxerror = tx32.maxerror;\n\ttxc->esterror = tx32.esterror;\n\ttxc->status = tx32.status;\n\ttxc->constant = tx32.constant;\n\ttxc->precision = tx32.precision;\n\ttxc->tolerance = tx32.tolerance;\n\ttxc->time.tv_sec = tx32.time.tv_sec;\n\ttxc->time.tv_usec = tx32.time.tv_usec;\n\ttxc->tick = tx32.tick;\n\ttxc->ppsfreq = tx32.ppsfreq;\n\ttxc->jitter = tx32.jitter;\n\ttxc->shift = tx32.shift;\n\ttxc->stabil = tx32.stabil;\n\ttxc->jitcnt = tx32.jitcnt;\n\ttxc->calcnt = tx32.calcnt;\n\ttxc->errcnt = tx32.errcnt;\n\ttxc->stbcnt = tx32.stbcnt;\n\n\treturn 0;\n}\n\nint compat_put_timex(struct compat_timex __user *utp, const struct timex *txc)\n{\n\tstruct compat_timex tx32;\n\n\tmemset(&tx32, 0, sizeof(struct compat_timex));\n\ttx32.modes = txc->modes;\n\ttx32.offset = txc->offset;\n\ttx32.freq = txc->freq;\n\ttx32.maxerror = txc->maxerror;\n\ttx32.esterror = txc->esterror;\n\ttx32.status = txc->status;\n\ttx32.constant = txc->constant;\n\ttx32.precision = txc->precision;\n\ttx32.tolerance = txc->tolerance;\n\ttx32.time.tv_sec = txc->time.tv_sec;\n\ttx32.time.tv_usec = txc->time.tv_usec;\n\ttx32.tick = txc->tick;\n\ttx32.ppsfreq = txc->ppsfreq;\n\ttx32.jitter = txc->jitter;\n\ttx32.shift = txc->shift;\n\ttx32.stabil = txc->stabil;\n\ttx32.jitcnt = txc->jitcnt;\n\ttx32.calcnt = txc->calcnt;\n\ttx32.errcnt = txc->errcnt;\n\ttx32.stbcnt = txc->stbcnt;\n\ttx32.tai = txc->tai;\n\tif (copy_to_user(utp, &tx32, sizeof(struct compat_timex)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int __compat_get_timeval(struct timeval *tv, const struct compat_timeval __user *ctv)\n{\n\treturn (!access_ok(VERIFY_READ, ctv, sizeof(*ctv)) ||\n\t\t\t__get_user(tv->tv_sec, &ctv->tv_sec) ||\n\t\t\t__get_user(tv->tv_usec, &ctv->tv_usec)) ? -EFAULT : 0;\n}\n\nstatic int __compat_put_timeval(const struct timeval *tv, struct compat_timeval __user *ctv)\n{\n\treturn (!access_ok(VERIFY_WRITE, ctv, sizeof(*ctv)) ||\n\t\t\t__put_user(tv->tv_sec, &ctv->tv_sec) ||\n\t\t\t__put_user(tv->tv_usec, &ctv->tv_usec)) ? -EFAULT : 0;\n}\n\nstatic int __compat_get_timespec(struct timespec *ts, const struct compat_timespec __user *cts)\n{\n\treturn (!access_ok(VERIFY_READ, cts, sizeof(*cts)) ||\n\t\t\t__get_user(ts->tv_sec, &cts->tv_sec) ||\n\t\t\t__get_user(ts->tv_nsec, &cts->tv_nsec)) ? -EFAULT : 0;\n}\n\nstatic int __compat_put_timespec(const struct timespec *ts, struct compat_timespec __user *cts)\n{\n\treturn (!access_ok(VERIFY_WRITE, cts, sizeof(*cts)) ||\n\t\t\t__put_user(ts->tv_sec, &cts->tv_sec) ||\n\t\t\t__put_user(ts->tv_nsec, &cts->tv_nsec)) ? -EFAULT : 0;\n}\n\nstatic int __compat_get_timespec64(struct timespec64 *ts64,\n\t\t\t\t   const struct compat_timespec __user *cts)\n{\n\tstruct compat_timespec ts;\n\tint ret;\n\n\tret = copy_from_user(&ts, cts, sizeof(ts));\n\tif (ret)\n\t\treturn -EFAULT;\n\n\tts64->tv_sec = ts.tv_sec;\n\tts64->tv_nsec = ts.tv_nsec;\n\n\treturn 0;\n}\n\nstatic int __compat_put_timespec64(const struct timespec64 *ts64,\n\t\t\t\t   struct compat_timespec __user *cts)\n{\n\tstruct compat_timespec ts = {\n\t\t.tv_sec = ts64->tv_sec,\n\t\t.tv_nsec = ts64->tv_nsec\n\t};\n\treturn copy_to_user(cts, &ts, sizeof(ts)) ? -EFAULT : 0;\n}\n\nint compat_get_timespec64(struct timespec64 *ts, const void __user *uts)\n{\n\tif (COMPAT_USE_64BIT_TIME)\n\t\treturn copy_from_user(ts, uts, sizeof(*ts)) ? -EFAULT : 0;\n\telse\n\t\treturn __compat_get_timespec64(ts, uts);\n}\nEXPORT_SYMBOL_GPL(compat_get_timespec64);\n\nint compat_put_timespec64(const struct timespec64 *ts, void __user *uts)\n{\n\tif (COMPAT_USE_64BIT_TIME)\n\t\treturn copy_to_user(uts, ts, sizeof(*ts)) ? -EFAULT : 0;\n\telse\n\t\treturn __compat_put_timespec64(ts, uts);\n}\nEXPORT_SYMBOL_GPL(compat_put_timespec64);\n\nint compat_get_timeval(struct timeval *tv, const void __user *utv)\n{\n\tif (COMPAT_USE_64BIT_TIME)\n\t\treturn copy_from_user(tv, utv, sizeof(*tv)) ? -EFAULT : 0;\n\telse\n\t\treturn __compat_get_timeval(tv, utv);\n}\nEXPORT_SYMBOL_GPL(compat_get_timeval);\n\nint compat_put_timeval(const struct timeval *tv, void __user *utv)\n{\n\tif (COMPAT_USE_64BIT_TIME)\n\t\treturn copy_to_user(utv, tv, sizeof(*tv)) ? -EFAULT : 0;\n\telse\n\t\treturn __compat_put_timeval(tv, utv);\n}\nEXPORT_SYMBOL_GPL(compat_put_timeval);\n\nint compat_get_timespec(struct timespec *ts, const void __user *uts)\n{\n\tif (COMPAT_USE_64BIT_TIME)\n\t\treturn copy_from_user(ts, uts, sizeof(*ts)) ? -EFAULT : 0;\n\telse\n\t\treturn __compat_get_timespec(ts, uts);\n}\nEXPORT_SYMBOL_GPL(compat_get_timespec);\n\nint compat_put_timespec(const struct timespec *ts, void __user *uts)\n{\n\tif (COMPAT_USE_64BIT_TIME)\n\t\treturn copy_to_user(uts, ts, sizeof(*ts)) ? -EFAULT : 0;\n\telse\n\t\treturn __compat_put_timespec(ts, uts);\n}\nEXPORT_SYMBOL_GPL(compat_put_timespec);\n\nint get_compat_itimerval(struct itimerval *o, const struct compat_itimerval __user *i)\n{\n\tstruct compat_itimerval v32;\n\n\tif (copy_from_user(&v32, i, sizeof(struct compat_itimerval)))\n\t\treturn -EFAULT;\n\to->it_interval.tv_sec = v32.it_interval.tv_sec;\n\to->it_interval.tv_usec = v32.it_interval.tv_usec;\n\to->it_value.tv_sec = v32.it_value.tv_sec;\n\to->it_value.tv_usec = v32.it_value.tv_usec;\n\treturn 0;\n}\n\nint put_compat_itimerval(struct compat_itimerval __user *o, const struct itimerval *i)\n{\n\tstruct compat_itimerval v32;\n\n\tv32.it_interval.tv_sec = i->it_interval.tv_sec;\n\tv32.it_interval.tv_usec = i->it_interval.tv_usec;\n\tv32.it_value.tv_sec = i->it_value.tv_sec;\n\tv32.it_value.tv_usec = i->it_value.tv_usec;\n\treturn copy_to_user(o, &v32, sizeof(struct compat_itimerval)) ? -EFAULT : 0;\n}\n\n#ifdef __ARCH_WANT_SYS_SIGPROCMASK\n\n/*\n * sys_sigprocmask SIG_SETMASK sets the first (compat) word of the\n * blocked set of signals to the supplied signal set\n */\nstatic inline void compat_sig_setmask(sigset_t *blocked, compat_sigset_word set)\n{\n\tmemcpy(blocked->sig, &set, sizeof(set));\n}\n\nCOMPAT_SYSCALL_DEFINE3(sigprocmask, int, how,\n\t\t       compat_old_sigset_t __user *, nset,\n\t\t       compat_old_sigset_t __user *, oset)\n{\n\told_sigset_t old_set, new_set;\n\tsigset_t new_blocked;\n\n\told_set = current->blocked.sig[0];\n\n\tif (nset) {\n\t\tif (get_user(new_set, nset))\n\t\t\treturn -EFAULT;\n\t\tnew_set &= ~(sigmask(SIGKILL) | sigmask(SIGSTOP));\n\n\t\tnew_blocked = current->blocked;\n\n\t\tswitch (how) {\n\t\tcase SIG_BLOCK:\n\t\t\tsigaddsetmask(&new_blocked, new_set);\n\t\t\tbreak;\n\t\tcase SIG_UNBLOCK:\n\t\t\tsigdelsetmask(&new_blocked, new_set);\n\t\t\tbreak;\n\t\tcase SIG_SETMASK:\n\t\t\tcompat_sig_setmask(&new_blocked, new_set);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tset_current_blocked(&new_blocked);\n\t}\n\n\tif (oset) {\n\t\tif (put_user(old_set, oset))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\n#endif\n\nint put_compat_rusage(const struct rusage *r, struct compat_rusage __user *ru)\n{\n\tstruct compat_rusage r32;\n\tmemset(&r32, 0, sizeof(r32));\n\tr32.ru_utime.tv_sec = r->ru_utime.tv_sec;\n\tr32.ru_utime.tv_usec = r->ru_utime.tv_usec;\n\tr32.ru_stime.tv_sec = r->ru_stime.tv_sec;\n\tr32.ru_stime.tv_usec = r->ru_stime.tv_usec;\n\tr32.ru_maxrss = r->ru_maxrss;\n\tr32.ru_ixrss = r->ru_ixrss;\n\tr32.ru_idrss = r->ru_idrss;\n\tr32.ru_isrss = r->ru_isrss;\n\tr32.ru_minflt = r->ru_minflt;\n\tr32.ru_majflt = r->ru_majflt;\n\tr32.ru_nswap = r->ru_nswap;\n\tr32.ru_inblock = r->ru_inblock;\n\tr32.ru_oublock = r->ru_oublock;\n\tr32.ru_msgsnd = r->ru_msgsnd;\n\tr32.ru_msgrcv = r->ru_msgrcv;\n\tr32.ru_nsignals = r->ru_nsignals;\n\tr32.ru_nvcsw = r->ru_nvcsw;\n\tr32.ru_nivcsw = r->ru_nivcsw;\n\tif (copy_to_user(ru, &r32, sizeof(r32)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int compat_get_user_cpu_mask(compat_ulong_t __user *user_mask_ptr,\n\t\t\t\t    unsigned len, struct cpumask *new_mask)\n{\n\tunsigned long *k;\n\n\tif (len < cpumask_size())\n\t\tmemset(new_mask, 0, cpumask_size());\n\telse if (len > cpumask_size())\n\t\tlen = cpumask_size();\n\n\tk = cpumask_bits(new_mask);\n\treturn compat_get_bitmap(k, user_mask_ptr, len * 8);\n}\n\nCOMPAT_SYSCALL_DEFINE3(sched_setaffinity, compat_pid_t, pid,\n\t\t       unsigned int, len,\n\t\t       compat_ulong_t __user *, user_mask_ptr)\n{\n\tcpumask_var_t new_mask;\n\tint retval;\n\n\tif (!alloc_cpumask_var(&new_mask, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tretval = compat_get_user_cpu_mask(user_mask_ptr, len, new_mask);\n\tif (retval)\n\t\tgoto out;\n\n\tretval = sched_setaffinity(pid, new_mask);\nout:\n\tfree_cpumask_var(new_mask);\n\treturn retval;\n}\n\nCOMPAT_SYSCALL_DEFINE3(sched_getaffinity, compat_pid_t,  pid, unsigned int, len,\n\t\t       compat_ulong_t __user *, user_mask_ptr)\n{\n\tint ret;\n\tcpumask_var_t mask;\n\n\tif ((len * BITS_PER_BYTE) < nr_cpu_ids)\n\t\treturn -EINVAL;\n\tif (len & (sizeof(compat_ulong_t)-1))\n\t\treturn -EINVAL;\n\n\tif (!alloc_cpumask_var(&mask, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tret = sched_getaffinity(pid, mask);\n\tif (ret == 0) {\n\t\tunsigned int retlen = min(len, cpumask_size());\n\n\t\tif (compat_put_bitmap(user_mask_ptr, cpumask_bits(mask), retlen * 8))\n\t\t\tret = -EFAULT;\n\t\telse\n\t\t\tret = retlen;\n\t}\n\tfree_cpumask_var(mask);\n\n\treturn ret;\n}\n\nint get_compat_itimerspec64(struct itimerspec64 *its,\n\t\t\tconst struct compat_itimerspec __user *uits)\n{\n\n\tif (__compat_get_timespec64(&its->it_interval, &uits->it_interval) ||\n\t    __compat_get_timespec64(&its->it_value, &uits->it_value))\n\t\treturn -EFAULT;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(get_compat_itimerspec64);\n\nint put_compat_itimerspec64(const struct itimerspec64 *its,\n\t\t\tstruct compat_itimerspec __user *uits)\n{\n\tif (__compat_put_timespec64(&its->it_interval, &uits->it_interval) ||\n\t    __compat_put_timespec64(&its->it_value, &uits->it_value))\n\t\treturn -EFAULT;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(put_compat_itimerspec64);\n\n/*\n * We currently only need the following fields from the sigevent\n * structure: sigev_value, sigev_signo, sig_notify and (sometimes\n * sigev_notify_thread_id).  The others are handled in user mode.\n * We also assume that copying sigev_value.sival_int is sufficient\n * to keep all the bits of sigev_value.sival_ptr intact.\n */\nint get_compat_sigevent(struct sigevent *event,\n\t\tconst struct compat_sigevent __user *u_event)\n{\n\tmemset(event, 0, sizeof(*event));\n\treturn (!access_ok(VERIFY_READ, u_event, sizeof(*u_event)) ||\n\t\t__get_user(event->sigev_value.sival_int,\n\t\t\t&u_event->sigev_value.sival_int) ||\n\t\t__get_user(event->sigev_signo, &u_event->sigev_signo) ||\n\t\t__get_user(event->sigev_notify, &u_event->sigev_notify) ||\n\t\t__get_user(event->sigev_notify_thread_id,\n\t\t\t&u_event->sigev_notify_thread_id))\n\t\t? -EFAULT : 0;\n}\n\nlong compat_get_bitmap(unsigned long *mask, const compat_ulong_t __user *umask,\n\t\t       unsigned long bitmap_size)\n{\n\tunsigned long nr_compat_longs;\n\n\t/* align bitmap up to nearest compat_long_t boundary */\n\tbitmap_size = ALIGN(bitmap_size, BITS_PER_COMPAT_LONG);\n\tnr_compat_longs = BITS_TO_COMPAT_LONGS(bitmap_size);\n\n\tif (!access_ok(VERIFY_READ, umask, bitmap_size / 8))\n\t\treturn -EFAULT;\n\n\tuser_access_begin();\n\twhile (nr_compat_longs > 1) {\n\t\tcompat_ulong_t l1, l2;\n\t\tunsafe_get_user(l1, umask++, Efault);\n\t\tunsafe_get_user(l2, umask++, Efault);\n\t\t*mask++ = ((unsigned long)l2 << BITS_PER_COMPAT_LONG) | l1;\n\t\tnr_compat_longs -= 2;\n\t}\n\tif (nr_compat_longs)\n\t\tunsafe_get_user(*mask, umask++, Efault);\n\tuser_access_end();\n\treturn 0;\n\nEfault:\n\tuser_access_end();\n\treturn -EFAULT;\n}\n\nlong compat_put_bitmap(compat_ulong_t __user *umask, unsigned long *mask,\n\t\t       unsigned long bitmap_size)\n{\n\tunsigned long nr_compat_longs;\n\n\t/* align bitmap up to nearest compat_long_t boundary */\n\tbitmap_size = ALIGN(bitmap_size, BITS_PER_COMPAT_LONG);\n\tnr_compat_longs = BITS_TO_COMPAT_LONGS(bitmap_size);\n\n\tif (!access_ok(VERIFY_WRITE, umask, bitmap_size / 8))\n\t\treturn -EFAULT;\n\n\tuser_access_begin();\n\twhile (nr_compat_longs > 1) {\n\t\tunsigned long m = *mask++;\n\t\tunsafe_put_user((compat_ulong_t)m, umask++, Efault);\n\t\tunsafe_put_user(m >> BITS_PER_COMPAT_LONG, umask++, Efault);\n\t\tnr_compat_longs -= 2;\n\t}\n\tif (nr_compat_longs)\n\t\tunsafe_put_user((compat_ulong_t)*mask, umask++, Efault);\n\tuser_access_end();\n\treturn 0;\nEfault:\n\tuser_access_end();\n\treturn -EFAULT;\n}\n\nint\nget_compat_sigset(sigset_t *set, const compat_sigset_t __user *compat)\n{\n#ifdef __BIG_ENDIAN\n\tcompat_sigset_t v;\n\tif (copy_from_user(&v, compat, sizeof(compat_sigset_t)))\n\t\treturn -EFAULT;\n\tswitch (_NSIG_WORDS) {\n\tcase 4: set->sig[3] = v.sig[6] | (((long)v.sig[7]) << 32 );\n\tcase 3: set->sig[2] = v.sig[4] | (((long)v.sig[5]) << 32 );\n\tcase 2: set->sig[1] = v.sig[2] | (((long)v.sig[3]) << 32 );\n\tcase 1: set->sig[0] = v.sig[0] | (((long)v.sig[1]) << 32 );\n\t}\n#else\n\tif (copy_from_user(set, compat, sizeof(compat_sigset_t)))\n\t\treturn -EFAULT;\n#endif\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(get_compat_sigset);\n\n/*\n * Allocate user-space memory for the duration of a single system call,\n * in order to marshall parameters inside a compat thunk.\n */\nvoid __user *compat_alloc_user_space(unsigned long len)\n{\n\tvoid __user *ptr;\n\n\t/* If len would occupy more than half of the entire compat space... */\n\tif (unlikely(len > (((compat_uptr_t)~0) >> 1)))\n\t\treturn NULL;\n\n\tptr = arch_compat_alloc_user_space(len);\n\n\tif (unlikely(!access_ok(VERIFY_WRITE, ptr, len)))\n\t\treturn NULL;\n\n\treturn ptr;\n}\nEXPORT_SYMBOL_GPL(compat_alloc_user_space);\n"], "filenames": ["kernel/compat.c"], "buggy_code_start_loc": [36], "buggy_code_end_loc": [36], "fixing_code_start_loc": [37], "fixing_code_end_loc": [38], "type": "CWE-200", "message": "The compat_get_timex function in kernel/compat.c in the Linux kernel before 4.16.9 allows local users to obtain sensitive information from kernel memory via adjtimex.", "other": {"cve": {"id": "CVE-2018-11508", "sourceIdentifier": "cve@mitre.org", "published": "2018-05-28T13:29:00.217", "lastModified": "2019-03-27T16:11:12.093", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The compat_get_timex function in kernel/compat.c in the Linux kernel before 4.16.9 allows local users to obtain sensitive information from kernel memory via adjtimex."}, {"lang": "es", "value": "Se ha descubierto un problema en Moodle 3.x. Al sustituir URL en los portfolios, los usuarios pueden instanciar cualquier clase. Esto tambi\u00e9n puede ser explotado por usuarios que hayan iniciado sesi\u00f3n como invitados para lanzar un ataque DDoS."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.16.9", "matchCriteriaId": "BF0B8062-865E-40C6-83C2-A0104358A338"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:17.10:*:*:*:*:*:*:*", "matchCriteriaId": "9070C9D8-A14A-467F-8253-33B966C16886"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=0a0b98734479aa5b3c671d5190e86273372cab95", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "http://www.securityfocus.com/bid/104292", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugs.chromium.org/p/project-zero/issues/detail?id=1574", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/0a0b98734479aa5b3c671d5190e86273372cab95", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3695-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3695-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3697-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3697-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.exploit-db.com/exploits/46208/", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory", "VDB Entry"]}, {"url": "https://www.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.16.9", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/0a0b98734479aa5b3c671d5190e86273372cab95"}}