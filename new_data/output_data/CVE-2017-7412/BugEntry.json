{"buggy_code": ["# Systemd services for docker.\n\n{ config, lib, pkgs, ... }:\n\nwith lib;\n\nlet\n\n  cfg = config.virtualisation.docker;\n  pro = config.networking.proxy.default;\n  proxy_env = optionalAttrs (pro != null) { Environment = \"\\\"http_proxy=${pro}\\\"\"; };\n\nin\n\n{\n  ###### interface\n\n  options.virtualisation.docker = {\n    enable =\n      mkOption {\n        type = types.bool;\n        default = false;\n        description =\n          ''\n            This option enables docker, a daemon that manages\n            linux containers. Users in the \"docker\" group can interact with\n            the daemon (e.g. to start or stop containers) using the\n            <command>docker</command> command line tool.\n          '';\n      };\n\n    listenOptions =\n      mkOption {\n        type = types.listOf types.str;\n        default = [\"/var/run/docker.sock\"];\n        description =\n          ''\n            A list of unix and tcp docker should listen to. The format follows\n            ListenStream as described in systemd.socket(5).\n          '';\n      };\n\n    enableOnBoot =\n      mkOption {\n        type = types.bool;\n        default = true;\n        description =\n          ''\n            When enabled dockerd is started on boot. This is required for\n            container, which are created with the\n            <literal>--restart=always</literal> flag, to work. If this option is\n            disabled, docker might be started on demand by socket activation.\n          '';\n      };\n\n    liveRestore =\n      mkOption {\n        type = types.bool;\n        default = true;\n        description =\n          ''\n            Allow dockerd to be restarted without affecting running container.\n            This option is incompatible with docker swarm.\n          '';\n      };\n\n    storageDriver =\n      mkOption {\n        type = types.nullOr (types.enum [\"aufs\" \"btrfs\" \"devicemapper\" \"overlay\" \"overlay2\" \"zfs\"]);\n        default = null;\n        description =\n          ''\n            This option determines which Docker storage driver to use. By default\n            it let's docker automatically choose preferred storage driver.\n          '';\n      };\n\n    logDriver =\n      mkOption {\n        type = types.enum [\"none\" \"json-file\" \"syslog\" \"journald\" \"gelf\" \"fluentd\" \"awslogs\" \"splunk\" \"etwlogs\" \"gcplogs\"];\n        default = \"journald\";\n        description =\n          ''\n            This option determines which Docker log driver to use.\n          '';\n      };\n\n    extraOptions =\n      mkOption {\n        type = types.separatedString \" \";\n        default = \"\";\n        description =\n          ''\n            The extra command-line options to pass to\n            <command>docker</command> daemon.\n          '';\n      };\n  };\n\n  ###### implementation\n\n  config = mkIf cfg.enable (mkMerge [{\n      environment.systemPackages = [ pkgs.docker ];\n      users.extraGroups.docker.gid = config.ids.gids.docker;\n      systemd.packages = [ pkgs.docker ];\n\n      systemd.services.docker = {\n        wantedBy = optional cfg.enableOnBoot \"multi-user.target\";\n        serviceConfig = {\n          ExecStart = [\n            \"\"\n            ''\n              ${pkgs.docker}/bin/dockerd \\\n                --group=docker \\\n                --host=fd:// \\\n                --log-driver=${cfg.logDriver} \\\n                ${optionalString (cfg.storageDriver != null) \"--storage-driver=${cfg.storageDriver}\"} \\\n                ${optionalString cfg.liveRestore \"--live-restore\" } \\\n                ${cfg.extraOptions}\n            ''];\n          ExecReload=[\n            \"\"\n            \"${pkgs.procps}/bin/kill -s HUP $MAINPID\"\n          ];\n        } // proxy_env;\n\n        path = [ pkgs.kmod ] ++ (optional (cfg.storageDriver == \"zfs\") pkgs.zfs);\n      };\n      systemd.sockets.docker.socketConfig.ListenStream = cfg.listenOptions;\n    }\n  ]);\n\n  imports = [\n    (mkRemovedOptionModule [\"virtualisation\" \"docker\" \"socketActivation\"] \"This option was removed in favor of starting docker at boot\")\n  ];\n\n}\n"], "fixing_code": ["# Systemd services for docker.\n\n{ config, lib, pkgs, ... }:\n\nwith lib;\n\nlet\n\n  cfg = config.virtualisation.docker;\n  pro = config.networking.proxy.default;\n  proxy_env = optionalAttrs (pro != null) { Environment = \"\\\"http_proxy=${pro}\\\"\"; };\n\nin\n\n{\n  ###### interface\n\n  options.virtualisation.docker = {\n    enable =\n      mkOption {\n        type = types.bool;\n        default = false;\n        description =\n          ''\n            This option enables docker, a daemon that manages\n            linux containers. Users in the \"docker\" group can interact with\n            the daemon (e.g. to start or stop containers) using the\n            <command>docker</command> command line tool.\n          '';\n      };\n\n    listenOptions =\n      mkOption {\n        type = types.listOf types.str;\n        default = [\"/var/run/docker.sock\"];\n        description =\n          ''\n            A list of unix and tcp docker should listen to. The format follows\n            ListenStream as described in systemd.socket(5).\n          '';\n      };\n\n    enableOnBoot =\n      mkOption {\n        type = types.bool;\n        default = true;\n        description =\n          ''\n            When enabled dockerd is started on boot. This is required for\n            container, which are created with the\n            <literal>--restart=always</literal> flag, to work. If this option is\n            disabled, docker might be started on demand by socket activation.\n          '';\n      };\n\n    liveRestore =\n      mkOption {\n        type = types.bool;\n        default = true;\n        description =\n          ''\n            Allow dockerd to be restarted without affecting running container.\n            This option is incompatible with docker swarm.\n          '';\n      };\n\n    storageDriver =\n      mkOption {\n        type = types.nullOr (types.enum [\"aufs\" \"btrfs\" \"devicemapper\" \"overlay\" \"overlay2\" \"zfs\"]);\n        default = null;\n        description =\n          ''\n            This option determines which Docker storage driver to use. By default\n            it let's docker automatically choose preferred storage driver.\n          '';\n      };\n\n    logDriver =\n      mkOption {\n        type = types.enum [\"none\" \"json-file\" \"syslog\" \"journald\" \"gelf\" \"fluentd\" \"awslogs\" \"splunk\" \"etwlogs\" \"gcplogs\"];\n        default = \"journald\";\n        description =\n          ''\n            This option determines which Docker log driver to use.\n          '';\n      };\n\n    extraOptions =\n      mkOption {\n        type = types.separatedString \" \";\n        default = \"\";\n        description =\n          ''\n            The extra command-line options to pass to\n            <command>docker</command> daemon.\n          '';\n      };\n  };\n\n  ###### implementation\n\n  config = mkIf cfg.enable (mkMerge [{\n      environment.systemPackages = [ pkgs.docker ];\n      users.extraGroups.docker.gid = config.ids.gids.docker;\n      systemd.packages = [ pkgs.docker ];\n\n      systemd.services.docker = {\n        wantedBy = optional cfg.enableOnBoot \"multi-user.target\";\n        serviceConfig = {\n          ExecStart = [\n            \"\"\n            ''\n              ${pkgs.docker}/bin/dockerd \\\n                --group=docker \\\n                --host=fd:// \\\n                --log-driver=${cfg.logDriver} \\\n                ${optionalString (cfg.storageDriver != null) \"--storage-driver=${cfg.storageDriver}\"} \\\n                ${optionalString cfg.liveRestore \"--live-restore\" } \\\n                ${cfg.extraOptions}\n            ''];\n          ExecReload=[\n            \"\"\n            \"${pkgs.procps}/bin/kill -s HUP $MAINPID\"\n          ];\n        } // proxy_env;\n\n        path = [ pkgs.kmod ] ++ (optional (cfg.storageDriver == \"zfs\") pkgs.zfs);\n      };\n\n      systemd.sockets.docker = {\n        description = \"Docker Socket for the API\";\n        wantedBy = [ \"sockets.target\" ];\n        socketConfig = {\n          ListenStream = cfg.listenOptions;\n          SocketMode = \"0660\";\n          SocketUser = \"root\";\n          SocketGroup = \"docker\";\n        };\n      };\n    }\n  ]);\n\n  imports = [\n    (mkRemovedOptionModule [\"virtualisation\" \"docker\" \"socketActivation\"] \"This option was removed in favor of starting docker at boot\")\n  ];\n\n}\n"], "filenames": ["nixos/modules/virtualisation/docker.nix"], "buggy_code_start_loc": [129], "buggy_code_end_loc": [130], "fixing_code_start_loc": [129], "fixing_code_end_loc": [140], "type": "NVD-CWE-noinfo", "message": "NixOS 17.03 before 17.03.887 has a world-writable Docker socket, which allows local users to gain privileges by executing docker commands.", "other": {"cve": {"id": "CVE-2017-7412", "sourceIdentifier": "cve@mitre.org", "published": "2017-04-04T00:59:00.160", "lastModified": "2020-05-07T16:17:52.787", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "NixOS 17.03 before 17.03.887 has a world-writable Docker socket, which allows local users to gain privileges by executing docker commands."}, {"lang": "es", "value": "NixOS 17.03 en versiones anteriores a 17.03.887 tiene un Docker socket de escritura universal, el cual permite a los usuarios locales obtener privilegios mediante la ejecuci\u00f3n de comandos docker."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:nixos:nixos:17.03:*:*:*:*:*:*:*", "matchCriteriaId": "8F0BC2AD-9EB3-45A3-9DBD-51851C4E08EB"}]}]}], "references": [{"url": "http://lists.science.uu.nl/pipermail/nix-dev/2017-April/023329.html", "source": "cve@mitre.org", "tags": ["Broken Link"]}, {"url": "https://github.com/NixOS/nixpkgs/commit/6c59d851e2967410cc8fb6ba3f374b1d3efa988e", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/NixOS/nixpkgs/commit/fa4fe7110566d8370983fa81f2b04a833339236d", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/NixOS/nixpkgs/commit/6c59d851e2967410cc8fb6ba3f374b1d3efa988e"}}