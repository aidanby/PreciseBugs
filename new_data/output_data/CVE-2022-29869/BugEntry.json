{"buggy_code": ["/*\n * Mount helper utility for Linux CIFS VFS (virtual filesystem) client\n * Copyright (C) 2003,2010 Steve French  (sfrench@us.ibm.com)\n * Copyright (C) 2008 Jeremy Allison (jra@samba.org)\n * Copyright (C) 2010 Jeff Layton (jlayton@samba.org)\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif /* HAVE_CONFIG_H */\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <grp.h>\n#include <ctype.h>\n#include <sys/types.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <getopt.h>\n#include <errno.h>\n#include <netdb.h>\n#include <string.h>\n#include <mntent.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <paths.h>\n#include <libgen.h>\n#include <time.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#ifdef HAVE_SYS_FSUID_H\n#include <sys/fsuid.h>\n#endif /* HAVE_SYS_FSUID_H */\n#ifdef HAVE_LIBCAP_NG\n#include <cap-ng.h>\n#else /* HAVE_LIBCAP_NG */\n#ifdef HAVE_PRCTL\n#include <sys/prctl.h>\n#endif /* HAVE_PRCTL */\n#ifdef HAVE_LIBCAP\n#include <sys/capability.h>\n#endif /* HAVE_LIBCAP */\n#endif /* HAVE_LIBCAP_NG */\n#include \"mount.h\"\n#include \"util.h\"\n#include \"resolve_host.h\"\n\n#ifndef MS_MOVE \n#define MS_MOVE 8192 \n#endif \n\n#ifndef MS_BIND\n#define MS_BIND 4096\n#endif\n\n/* private flags - clear these before passing to kernel */\n#define MS_USERS\t0x40000000\n#define MS_USER\t\t0x80000000\n\n#define MAX_UNC_LEN 1024\n\n/* I believe that the kernel limits options data to a page */\n#define MAX_OPTIONS_LEN\t4096\n\n/* max length of mtab options */\n#define MTAB_OPTIONS_LEN 220\n\n/*\n * Max share name, username, password and domain sizes match the kernel's\n * allowances for these string sizes which in turn match Microsoft's\n * documentation.\n */\n\n/* Max length of the share name portion of a UNC. Share names over 80\n * characters cannot be accessed via commandline in Windows 2000/XP. */\n#define MAX_SHARE_LEN 256\n\n/* Max user name length. */\n#define MAX_USERNAME_SIZE 256\n\n/* Max domain size. */\n#define MAX_DOMAIN_SIZE 256\n\n/* Max password size. */\n#define MOUNT_PASSWD_SIZE 512\n\n/*\n * mount.cifs has been the subject of many \"security\" bugs that have arisen\n * because of users and distributions installing it as a setuid root program\n * before it had been audited for security holes. The default behavior is\n * now to allow mount.cifs to be run as a setuid root program. Some admins\n * may want to disable this fully, so this switch remains in place.\n */\n#define CIFS_DISABLE_SETUID_CAPABILITY 0\n\n/*\n * When an unprivileged user runs a setuid mount.cifs, we set certain mount\n * flags by default. These defaults can be changed here.\n */\n#define CIFS_SETUID_FLAGS (MS_NOSUID|MS_NODEV)\n\n/*\n * Values for parsing a credentials file.\n */\n#define CRED_UNPARSEABLE 0\n#define CRED_USER        1\n#define CRED_PASS        2\n#define CRED_DOM         4\n\n/*\n * Values for parsing command line options.\n */\n#define OPT_ERROR       -1\n#define OPT_IGNORE      0\n#define OPT_USERS       1\n#define OPT_USER        2\n#define OPT_USER_XATTR  3\n#define OPT_PASS        4\n#define OPT_SEC         5\n#define OPT_IP          6\n#define OPT_UNC         7\n#define OPT_CRED        8\n#define OPT_UID         9\n#define OPT_GID        10\n#define OPT_FMASK      11\n#define OPT_FILE_MODE  12\n#define OPT_DMASK      13\n#define OPT_DIR_MODE   14\n#define OPT_DOM        15\n#define OPT_NO_SUID    16\n#define OPT_SUID       17\n#define OPT_NO_DEV     18\n#define OPT_DEV        19\n#define OPT_NO_LOCK    20\n#define OPT_NO_EXEC    21\n#define OPT_EXEC       22\n#define OPT_GUEST      23\n#define OPT_RO         24\n#define OPT_RW         25\n#define OPT_REMOUNT    26\n#define OPT_MAND       27\n#define OPT_NOMAND     28\n#define OPT_CRUID      29\n#define OPT_BKUPUID    30\n#define OPT_BKUPGID    31\n#define OPT_NOFAIL     32\n#define OPT_SNAPSHOT   33\n\n#define MNT_TMP_FILE \"/.mtab.cifs.XXXXXX\"\n\n#define GMT_NAME_LEN 24 /* length of a @GMT- name */\n#define GMT_FORMAT \"@GMT-%Y.%m.%d-%H.%M.%S\"\n\n#define NTFS_TIME_OFFSET ((unsigned long long)(369*365 + 89) * 24 * 3600 * 10000000)\n\n/*\n* struct for holding parsed mount info for use by privileged process.\n* Please do not keep pointers in this struct.\n* That way, reinit of this struct is a simple memset.\n*/\nstruct parsed_mount_info {\n\tunsigned long flags;\n\tchar host[NI_MAXHOST + 1];\n\tchar share[MAX_SHARE_LEN + 1];\n\tchar prefix[PATH_MAX + 1];\n\tchar options[MAX_OPTIONS_LEN];\n\tchar domain[MAX_DOMAIN_SIZE + 1];\n\tchar username[MAX_USERNAME_SIZE + 1];\n\tchar password[MOUNT_PASSWD_SIZE + 1];\n\tchar addrlist[MAX_ADDR_LIST_LEN];\n\tunsigned int got_user:1;\n\tunsigned int got_password:1;\n\tunsigned int fakemnt:1;\n\tunsigned int nomtab:1;\n\tunsigned int verboseflag:1;\n\tunsigned int nofail:1;\n\tunsigned int got_domain:1;\n\tunsigned int is_krb5:1;\n\tuid_t sudo_uid;\n};\n\nstatic const char *thisprogram;\nstatic const char *cifs_fstype;\n\nstatic int parse_unc(const char *unc_name, struct parsed_mount_info *parsed_info, const char *progname);\n\nstatic int check_setuid(void)\n{\n\tif (geteuid()) {\n\t\tfprintf(stderr, \"This program is not installed setuid root - \"\n\t\t\t\" \\\"user\\\" CIFS mounts not supported.\\n\");\n\t\treturn EX_USAGE;\n\t}\n\n#if CIFS_DISABLE_SETUID_CAPABILITY\n\tif (getuid() && !geteuid()) {\n\t\tprintf(\"This program has been built with the \"\n\t\t       \"ability to run as a setuid root program disabled.\\n\");\n\t\treturn EX_USAGE;\n\t}\n#endif /* CIFS_DISABLE_SETUID_CAPABILITY */\n\n\treturn 0;\n}\n\nstatic int\ncheck_fstab(const char *progname, const char *mountpoint, const char *devname,\n\t    char **options)\n{\n\tFILE *fstab;\n\tstruct mntent *mnt;\n\tsize_t len;\n\n\t/* make sure this mount is listed in /etc/fstab */\n\tfstab = setmntent(_PATH_MNTTAB, \"r\");\n\tif (!fstab) {\n\t\tfprintf(stderr, \"Couldn't open %s for reading!\\n\", _PATH_MNTTAB);\n\t\treturn EX_FILEIO;\n\t}\n\n\twhile ((mnt = getmntent(fstab))) {\n\t\tlen = strlen(mnt->mnt_dir);\n\t\twhile (len > 1) {\n\t\t        if (mnt->mnt_dir[len - 1] == '/')\n\t\t\t        mnt->mnt_dir[len - 1] = '\\0';\n\t\t        else\n\t\t\t\tbreak;\n\t\t\tlen--;\n\t\t}\n\t\tif (!strcmp(mountpoint, mnt->mnt_dir))\n\t\t\tbreak;\n\t}\n\tendmntent(fstab);\n\n\tif (mnt == NULL || strcmp(mnt->mnt_fsname, devname)) {\n\t\tfprintf(stderr, \"%s: permission denied: no match for \"\n\t\t\t\"%s found in %s\\n\", progname, mountpoint, _PATH_MNTTAB);\n\t\treturn EX_USAGE;\n\t}\n\n\t/*\n\t * 'mount' munges the options from fstab before passing them\n\t * to us. It is non-trivial to test that we have the correct\n\t * set of options. We don't want to trust what the user\n\t * gave us, so just take whatever is in /etc/fstab.\n\t */\n\t*options = strdup(mnt->mnt_opts);\n\treturn 0;\n}\n\n/* BB finish BB\n\n\tcifs_umount\n\topen nofollow - avoid symlink exposure? \n\tget owner of dir see if matches self or if root\n\tcall system(umount argv) etc.\n\nBB end finish BB */\n\nstatic int mount_usage(FILE * stream)\n{\n\tfprintf(stream, \"\\nUsage:  %s <remotetarget> <dir> -o <options>\\n\",\n\t\tthisprogram);\n\tfprintf(stream, \"\\nMount the remote target, specified as a UNC name,\");\n\tfprintf(stream, \" to a local directory.\\n\\nOptions:\\n\");\n\tfprintf(stream, \"\\tuser=<arg>\\n\\tpass=<arg>\\n\\tdom=<arg>\\n\");\n\tfprintf(stream, \"\\nLess commonly used options:\");\n\tfprintf(stream,\n\t\t\"\\n\\tcredentials=<filename>,guest,perm,noperm,setuids,nosetuids,rw,ro,\");\n\tfprintf(stream,\n\t\t\"\\n\\tsep=<char>,iocharset=<codepage>,suid,nosuid,exec,noexec,serverino,\");\n\tfprintf(stream,\n\t\t\"\\n\\tnoserverino,mapchars,nomapchars,nolock,servernetbiosname=<SRV_RFC1001NAME>\");\n\tfprintf(stream,\n\t\t\"\\n\\tcache=<strict|none|loose>,nounix,cifsacl,sec=<authentication mechanism>,\");\n\tfprintf(stream,\n\t\t\"\\n\\tsign,seal,fsc,snapshot=<token|time>,nosharesock,persistenthandles,\");\n\tfprintf(stream,\n\t\t\"\\n\\tresilienthandles,rdma,vers=<smb_dialect>,cruid\");\n\tfprintf(stream,\n\t\t\"\\n\\nOptions not needed for servers supporting CIFS Unix extensions\");\n\tfprintf(stream,\n\t\t\"\\n\\t(e.g. unneeded for mounts to most Samba versions):\");\n\tfprintf(stream,\n\t\t\"\\n\\tuid=<uid>,gid=<gid>,dir_mode=<mode>,file_mode=<mode>,sfu,\");\n\tfprintf(stream,\n\t\t\"\\n\\tmfsymlinks,idsfromsid\");\n\tfprintf(stream, \"\\n\\nRarely used options:\");\n\tfprintf(stream,\n\t\t\"\\n\\tport=<tcpport>,rsize=<size>,wsize=<size>,unc=<unc_name>,ip=<ip_address>,\");\n\tfprintf(stream,\n\t\t\"\\n\\tdev,nodev,nouser_xattr,netbiosname=<OUR_RFC1001NAME>,hard,soft,intr,\");\n\tfprintf(stream,\n\t\t\"\\n\\tnointr,ignorecase,noposixpaths,noacl,prefixpath=<path>,nobrl,\");\n\tfprintf(stream,\n\t\t\"\\n\\techo_interval=<seconds>,actimeo=<seconds>,max_credits=<credits>,\");\n\tfprintf(stream,\n\t\t\"\\n\\tbsize=<size>\");\n\tfprintf(stream,\n\t\t\"\\n\\nOptions are described in more detail in the manual page\");\n\tfprintf(stream, \"\\n\\tman 8 %s\\n\", thisprogram);\n\tfprintf(stream, \"\\nTo display the version number of the mount helper:\");\n\tfprintf(stream, \"\\n\\t%s -V\\n\", thisprogram);\n\n\tif (stream == stderr)\n\t\treturn EX_USAGE;\n\treturn 0;\n}\n\n/*\n * CIFS has to \"escape\" commas in the password field so that they don't\n * end up getting confused for option delimiters. Copy password into pw\n * field, turning any commas into double commas.\n */\nstatic int set_password(struct parsed_mount_info *parsed_info, const char *src)\n{\n\tchar *dst = parsed_info->password;\n\tunsigned int i = 0, j = 0;\n\n\twhile (src[i]) {\n\t\tif (src[i] == ',')\n\t\t\tdst[j++] = ',';\n\t\tdst[j++] = src[i++];\n\t\tif (j > sizeof(parsed_info->password)) {\n\t\t\tfprintf(stderr, \"Converted password too long!\\n\");\n\t\t\treturn EX_USAGE;\n\t\t}\n\t}\n\tdst[j] = '\\0';\n\tparsed_info->got_password = 1;\n\treturn 0;\n}\n\n#ifdef HAVE_LIBCAP_NG\nstatic int\ndrop_capabilities(int parent)\n{\n\tcapng_select_t set = CAPNG_SELECT_CAPS;\n\n\tcapng_setpid(getpid());\n\tcapng_clear(CAPNG_SELECT_BOTH);\n\tif (parent) {\n\t\tif (capng_updatev(CAPNG_ADD, CAPNG_PERMITTED, CAP_DAC_READ_SEARCH, CAP_DAC_OVERRIDE, -1)) {\n\t\t\tfprintf(stderr, \"Unable to update capability set.\\n\");\n\t\t\treturn EX_SYSERR;\n\t\t}\n\t\tif (capng_update(CAPNG_ADD, CAPNG_PERMITTED|CAPNG_EFFECTIVE, CAP_SYS_ADMIN)) {\n\t\t\tfprintf(stderr, \"Unable to update capability set.\\n\");\n\t\t\treturn EX_SYSERR;\n\t\t}\n\t} else {\n\t\tif (capng_update(CAPNG_ADD, CAPNG_PERMITTED, CAP_DAC_READ_SEARCH)) {\n\t\t\tfprintf(stderr, \"Unable to update capability set.\\n\");\n\t\t\treturn EX_SYSERR;\n\t\t}\n\t}\n\tif (capng_have_capability(CAPNG_EFFECTIVE, CAP_SETPCAP)) {\n\t\tset = CAPNG_SELECT_BOTH;\n\t}\n\tif (capng_apply(set)) {\n\t\tfprintf(stderr, \"Unable to apply new capability set.\\n\");\n\t\treturn EX_SYSERR;\n\t}\n\treturn 0;\n}\n\nstatic int\ntoggle_dac_capability(int writable, int enable)\n{\n\tunsigned int capability = writable ? CAP_DAC_OVERRIDE : CAP_DAC_READ_SEARCH;\n\n\tif (capng_update(enable ? CAPNG_ADD : CAPNG_DROP, CAPNG_EFFECTIVE, capability)) {\n\t\tfprintf(stderr, \"Unable to update capability set.\\n\");\n\t\treturn EX_SYSERR;\n\t}\n\tif (capng_apply(CAPNG_SELECT_CAPS)) {\n\t\tfprintf(stderr, \"Unable to apply new capability set.\\n\");\n\t\treturn EX_SYSERR;\n\t}\n\treturn 0;\n}\n#else /* HAVE_LIBCAP_NG */\n#ifdef HAVE_LIBCAP\n#ifdef HAVE_PRCTL\nstatic int\nprune_bounding_set(void)\n{\n\tint i, rc = 0;\n\tstatic int bounding_set_cleared;\n\n\tif (bounding_set_cleared)\n\t\treturn 0;\n\n\tfor (i = 0; i <= CAP_LAST_CAP && rc == 0; ++i)\n\t\trc = prctl(PR_CAPBSET_DROP, i);\n\n\tif (rc != 0) {\n\t\tfprintf(stderr, \"Unable to clear capability bounding set: %d\\n\", rc);\n\t\treturn EX_SYSERR;\n\t}\n\n\t++bounding_set_cleared;\n\treturn 0;\n}\n#else /* HAVE_PRCTL */\nstatic int\nprune_bounding_set(void)\n{\n\treturn 0;\n}\n#endif /* HAVE_PRCTL */\nstatic int\ndrop_capabilities(int parent)\n{\n\tint rc, ncaps;\n\tcap_t caps;\n\tcap_value_t cap_list[3];\n\n\trc = prune_bounding_set();\n\tif (rc)\n\t\treturn rc;\n\n\tcaps = cap_get_proc();\n\tif (caps == NULL) {\n\t\tfprintf(stderr, \"Unable to get current capability set: %s\\n\",\n\t\t\tstrerror(errno));\n\t\treturn EX_SYSERR;\n\t}\n\n\tif (cap_clear(caps) == -1) {\n\t\tfprintf(stderr, \"Unable to clear capability set: %s\\n\",\n\t\t\tstrerror(errno));\n\t\trc = EX_SYSERR;\n\t\tgoto free_caps;\n\t}\n\n\tif (parent || getuid() == 0) {\n\t\tncaps = 1;\n\t\tcap_list[0] = CAP_DAC_READ_SEARCH;\n\t\tif (parent) {\n\t\t\tcap_list[1] = CAP_DAC_OVERRIDE;\n\t\t\tcap_list[2] = CAP_SYS_ADMIN;\n\t\t\tncaps += 2;\n\t\t}\n\t\tif (cap_set_flag(caps, CAP_PERMITTED, ncaps, cap_list, CAP_SET) == -1) {\n\t\t\tfprintf(stderr, \"Unable to set permitted capabilities: %s\\n\",\n\t\t\t\tstrerror(errno));\n\t\t\trc = EX_SYSERR;\n\t\t\tgoto free_caps;\n\t\t}\n\t\tif (parent) {\n\t\t\tcap_list[0] = CAP_SYS_ADMIN;\n\t\t\tif (cap_set_flag(caps, CAP_EFFECTIVE, 1, cap_list, CAP_SET) == -1) {\n\t\t\t\tfprintf(stderr, \"Unable to set effective capabilities: %s\\n\",\n\t\t\t\t\tstrerror(errno));\n\t\t\t\trc = EX_SYSERR;\n\t\t\t\tgoto free_caps;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (cap_set_proc(caps) != 0) {\n\t\tfprintf(stderr, \"Unable to set current process capabilities: %s\\n\",\n\t\t\tstrerror(errno));\n\t\trc = EX_SYSERR;\n\t}\nfree_caps:\n\tcap_free(caps);\n\treturn rc;\n}\n\nstatic int\ntoggle_dac_capability(int writable, int enable)\n{\n\tint rc = 0;\n\tcap_t caps;\n\tcap_value_t capability = writable ? CAP_DAC_OVERRIDE : CAP_DAC_READ_SEARCH;\n\n\tcaps = cap_get_proc();\n\tif (caps == NULL) {\n\t\tfprintf(stderr, \"Unable to get current capability set: %s\\n\",\n\t\t\tstrerror(errno));\n\t\treturn EX_SYSERR;\n\t}\n\n\tif (cap_set_flag(caps, CAP_EFFECTIVE, 1, &capability,\n\t\t\t enable ? CAP_SET : CAP_CLEAR) == -1) {\n\t\tfprintf(stderr, \"Unable to %s effective capabilities: %s\\n\",\n\t\t\tenable ? \"set\" : \"clear\", strerror(errno));\n\t\trc = EX_SYSERR;\n\t\tgoto free_caps;\n\t}\n\n\tif (cap_set_proc(caps) != 0) {\n\t\tfprintf(stderr, \"Unable to set current process capabilities: %s\\n\",\n\t\t\tstrerror(errno));\n\t\trc = EX_SYSERR;\n\t}\nfree_caps:\n\tcap_free(caps);\n\treturn rc;\n}\n#else /* HAVE_LIBCAP */\nstatic int\ndrop_capabilities(int parent __attribute((unused)))\n{\n\treturn 0;\n}\n\nstatic int\ntoggle_dac_capability(int writable __attribute((unused)), int enable __attribute((unused)))\n{\n\treturn 0;\n}\n#endif /* HAVE_LIBCAP */\n#endif /* HAVE_LIBCAP_NG */\n\nstatic void null_terminate_endl(char *source)\n{\n\tchar *newline = strchr(source, '\\n');\n\tif (newline)\n\t\t*newline = '\\0';\n}\n\n/*\n * Parse a line from the credentials file.  Changes target to first\n * character after '=' on 'line' and returns the value type of the line\n * Returns CRED_UNPARSEABLE on failure or if either parameter is NULL.\n */\nstatic int parse_cred_line(char *line, char **target)\n{\n\tif (line == NULL || target == NULL)\n\t\tgoto parsing_err;\n\n\t/* position target at first char of value */\n\t*target = strchr(line, '=');\n\tif (!*target)\n\t\tgoto parsing_err;\n\t*target += 1;\n\n\t/* tell the caller which value target points to */\n\tif (strncasecmp(\"user\", line, 4) == 0)\n\t\treturn CRED_USER;\n\tif (strncasecmp(\"pass\", line, 4) == 0)\n\t\treturn CRED_PASS;\n\tif (strncasecmp(\"dom\", line, 3) == 0)\n\t\treturn CRED_DOM;\n\nparsing_err:\n\treturn CRED_UNPARSEABLE;\n}\n\nstatic int open_cred_file(char *file_name,\n\t\t\tstruct parsed_mount_info *parsed_info)\n{\n\tchar *line_buf = NULL;\n\tchar *temp_val = NULL;\n\tFILE *fs = NULL;\n\tint i;\n\tconst int line_buf_size = 4096;\n\tconst int min_non_white = 10;\n\n\ti = toggle_dac_capability(0, 1);\n\tif (i)\n\t\tgoto return_i;\n\n\ti = access(file_name, R_OK);\n\tif (i) {\n\t\ttoggle_dac_capability(0, 0);\n\t\ti = errno;\n\t\tgoto return_i;\n\t}\n\n\tfs = fopen(file_name, \"r\");\n\tif (fs == NULL) {\n\t\ttoggle_dac_capability(0, 0);\n\t\ti = errno;\n\t\tgoto return_i;\n\t}\n\n\ti = toggle_dac_capability(0, 0);\n\tif (i)\n\t\tgoto return_i;\n\n\tline_buf = (char *)malloc(line_buf_size);\n\tif (line_buf == NULL) {\n\t\ti = EX_SYSERR;\n\t\tgoto return_i;\n\t}\n\n\t/* parse line from credentials file */\n\twhile (fgets(line_buf, line_buf_size, fs)) {\n\t\t/* eat leading white space */\n\t\tfor (i = 0; i < line_buf_size - min_non_white + 1; i++) {\n\t\t\tif ((line_buf[i] != ' ') && (line_buf[i] != '\\t'))\n\t\t\t\tbreak;\n\t\t}\n\t\tnull_terminate_endl(line_buf);\n\n\t\t/* parse next token */\n\t\tswitch (parse_cred_line(line_buf + i, &temp_val)) {\n\t\tcase CRED_USER:\n\t\t\tstrlcpy(parsed_info->username, temp_val,\n\t\t\t\tsizeof(parsed_info->username));\n\t\t\tparsed_info->got_user = 1;\n\t\t\tbreak;\n\t\tcase CRED_PASS:\n\t\t\ti = set_password(parsed_info, temp_val);\n\t\t\tif (i)\n\t\t\t\tgoto return_i;\n\t\t\tbreak;\n\t\tcase CRED_DOM:\n\t\t\tif (parsed_info->verboseflag)\n\t\t\t\tfprintf(stderr, \"domain=%s\\n\",\n\t\t\t\t\ttemp_val);\n\t\t\tstrlcpy(parsed_info->domain, temp_val,\n\t\t\t\tsizeof(parsed_info->domain));\n\t\t\tbreak;\n\t\tcase CRED_UNPARSEABLE:\n\t\t\tif (parsed_info->verboseflag)\n\t\t\t\tfprintf(stderr, \"Credential formatted \"\n\t\t\t\t\t\"incorrectly: %s\\n\",\n\t\t\t\t\ttemp_val ? temp_val : \"(null)\");\n\t\t\tbreak;\n\t\t}\n\t}\n\ti = 0;\nreturn_i:\n\tif (fs != NULL)\n\t\tfclose(fs);\n\n\t/* make sure passwords are scrubbed from memory */\n\tif (line_buf != NULL)\n\t\tmemset(line_buf, 0, line_buf_size);\n\tfree(line_buf);\n\treturn i;\n}\n\nstatic int\nget_password_from_file(int file_descript, char *filename,\n\t\t       struct parsed_mount_info *parsed_info, const char *program)\n{\n\tint rc = 0;\n\tchar buf[sizeof(parsed_info->password) + 1];\n\n\tif (filename != NULL) {\n\t\trc = toggle_dac_capability(0, 1);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\trc = access(filename, R_OK);\n\t\tif (rc) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"%s failed: access check of %s failed: %s\\n\",\n\t\t\t\tprogram, filename, strerror(errno));\n\t\t\ttoggle_dac_capability(0, 0);\n\t\t\treturn EX_SYSERR;\n\t\t}\n\n\t\tfile_descript = open(filename, O_RDONLY);\n\t\tif (file_descript < 0) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"%s failed. %s attempting to open password file %s\\n\",\n\t\t\t\tprogram, strerror(errno), filename);\n\t\t\ttoggle_dac_capability(0, 0);\n\t\t\treturn EX_SYSERR;\n\t\t}\n\n\t\trc = toggle_dac_capability(0, 0);\n\t\tif (rc) {\n\t\t\trc = EX_SYSERR;\n\t\t\tgoto get_pw_exit;\n\t\t}\n\t}\n\n\tmemset(buf, 0, sizeof(buf));\n\trc = read(file_descript, buf, sizeof(buf) - 1);\n\tif (rc < 0) {\n\t\tfprintf(stderr,\n\t\t\t\"%s failed. Error %s reading password file\\n\",\n\t\t\tprogram, strerror(errno));\n\t\trc = EX_SYSERR;\n\t\tgoto get_pw_exit;\n\t}\n\n\trc = set_password(parsed_info, buf);\n\nget_pw_exit:\n\tif (filename != NULL)\n\t\tclose(file_descript);\n\treturn rc;\n}\n\n/*\n * Returns OPT_ERROR on unparsable token.\n */\nstatic int parse_opt_token(const char *token)\n{\n\tif (token == NULL)\n\t\treturn OPT_ERROR;\n\n\t/*\n\t * token is NULL terminated and contains exactly the\n\t * keyword so we can match exactly\n\t */\n\tif (strcmp(token, \"users\") == 0)\n\t\treturn OPT_USERS;\n\tif (strcmp(token, \"user_xattr\") == 0)\n\t\treturn OPT_USER_XATTR;\n\tif (strcmp(token, \"user\") == 0 ||\n\t\tstrcmp(token, \"username\") == 0)\n\t\treturn OPT_USER;\n\tif (strcmp(token, \"pass\") == 0 ||\n\t\tstrcmp(token, \"password\") == 0)\n\t\treturn OPT_PASS;\n\tif (strcmp(token, \"sec\") == 0)\n\t\treturn OPT_SEC;\n\tif (strcmp(token, \"ip\") == 0 ||\n\t\tstrcmp(token, \"addr\") == 0)\n\t\treturn OPT_IP;\n\tif (strcmp(token, \"unc\") == 0 ||\n\t\tstrcmp(token, \"target\") == 0 ||\n\t\tstrcmp(token, \"path\") == 0)\n\t\treturn OPT_UNC;\n\tif (strcmp(token, \"dom\") == 0 ||\n\t\tstrcmp(token, \"domain\") == 0 ||\n\t\tstrcmp(token, \"workgroup\") == 0)\n\t\treturn OPT_DOM;\n\tif (strcmp(token, \"cred\") == 0 || /* undocumented */\n\t\tstrcmp(token, \"credentials\") == 0)\n\t\treturn OPT_CRED;\n\tif (strcmp(token, \"uid\") == 0)\n\t\treturn OPT_UID;\n\tif (strcmp(token, \"cruid\") == 0)\n\t\treturn OPT_CRUID;\n\tif (strcmp(token, \"gid\") == 0)\n\t\treturn OPT_GID;\n\tif (strcmp(token, \"fmask\") == 0)\n\t\treturn OPT_FMASK;\n\tif (strcmp(token, \"file_mode\") == 0)\n\t\treturn OPT_FILE_MODE;\n\tif (strcmp(token, \"dmask\") == 0)\n\t\treturn OPT_DMASK;\n\tif (strcmp(token, \"dir_mode\") == 0 ||\n\t\tstrcmp(token, \"dirm\") == 0)\n\t\treturn OPT_DIR_MODE;\n\tif (strcmp(token, \"nosuid\") == 0)\n\t\treturn OPT_NO_SUID;\n\tif (strcmp(token, \"suid\") == 0)\n\t\treturn OPT_SUID;\n\tif (strcmp(token, \"nodev\") == 0)\n\t\treturn OPT_NO_DEV;\n\tif (strcmp(token, \"nobrl\") == 0 ||\n\t\tstrcmp(token, \"nolock\") == 0)\n\t\treturn OPT_NO_LOCK;\n\tif (strcmp(token, \"mand\") == 0)\n\t\treturn OPT_MAND;\n\tif (strcmp(token, \"nomand\") == 0)\n\t\treturn OPT_NOMAND;\n\tif (strcmp(token, \"dev\") == 0)\n\t\treturn OPT_DEV;\n\tif (strcmp(token, \"noexec\") == 0)\n\t\treturn OPT_NO_EXEC;\n\tif (strcmp(token, \"exec\") == 0)\n\t\treturn OPT_EXEC;\n\tif (strcmp(token, \"guest\") == 0)\n\t\treturn OPT_GUEST;\n\tif (strcmp(token, \"ro\") == 0)\n\t\treturn OPT_RO;\n\tif (strcmp(token, \"rw\") == 0)\n\t\treturn OPT_RW;\n\tif (strcmp(token, \"remount\") == 0)\n\t\treturn OPT_REMOUNT;\n\tif (strcmp(token, \"_netdev\") == 0)\n\t\treturn OPT_IGNORE;\n\tif (strcmp(token, \"backupuid\") == 0)\n\t\treturn OPT_BKUPUID;\n\tif (strcmp(token, \"backupgid\") == 0)\n\t\treturn OPT_BKUPGID;\n\tif (strcmp(token, \"nofail\") == 0)\n\t\treturn OPT_NOFAIL;\n\tif (strcmp(token, \"comment\") == 0)\n\t\treturn OPT_IGNORE;\n\tif (strncmp(token, \"x-\", 2) == 0)\n\t\treturn OPT_IGNORE;\n\tif (strncmp(token, \"snapshot\", 8) == 0)\n\t\treturn OPT_SNAPSHOT;\n\n\treturn OPT_ERROR;\n}\n\nstatic int\nparse_options(const char *data, struct parsed_mount_info *parsed_info)\n{\n\tchar *value = NULL;\n\tchar *equals = NULL;\n\tchar *next_keyword = NULL;\n\tchar *out = parsed_info->options;\n\tunsigned long *filesys_flags = &parsed_info->flags;\n\tint out_len = 0;\n\tint word_len;\n\tint rc = 0;\n\tint got_bkupuid = 0;\n\tint got_bkupgid = 0;\n\tint got_uid = 0;\n\tint got_cruid = 0;\n\tint got_gid = 0;\n\tint got_snapshot = 0;\n\tuid_t uid, cruid = 0, bkupuid = 0;\n\tgid_t gid, bkupgid = 0;\n\tchar *ep;\n\tstruct passwd *pw;\n\tstruct group *gr;\n\t/*\n\t * max 64-bit uint in decimal is 18446744073709551615 which is 20 chars\n\t * wide +1 for NULL, and +1 for good measure\n\t */\n\tchar txtbuf[22];\n\tunsigned long long snapshot;\n\tstruct tm tm;\n\n\t/* make sure we're starting from beginning */\n\tout[0] = '\\0';\n\n\t/* BB fixme check for separator override BB */\n\tuid = getuid();\n\tif (uid != 0)\n\t\tgot_uid = 1;\n\n\tgid = getgid();\n\tif (gid != 0)\n\t\tgot_gid = 1;\n\n\tif (!data)\n\t\treturn EX_USAGE;\n\n\t/*\n\t * format is keyword,keyword2=value2,keyword3=value3... \n\t * data  = next keyword\n\t * value = next value ie stuff after equal sign\n\t */\n\twhile (data && *data) {\n\t\tnext_keyword = strchr(data, ',');\t/* BB handle sep= */\n\n\t\t/* temporarily null terminate end of keyword=value pair */\n\t\tif (next_keyword)\n\t\t\t*next_keyword++ = 0;\n\n\t\t/* temporarily null terminate keyword if there's a value */\n\t\tvalue = NULL;\n\t\tif ((equals = strchr(data, '=')) != NULL) {\n\t\t\t*equals = '\\0';\n\t\t\tvalue = equals + 1;\n\t\t}\n\n\t\tswitch(parse_opt_token(data)) {\n\t\tcase OPT_USERS:\n\t\t\tif (!value || !*value) {\n\t\t\t\t*filesys_flags |= MS_USERS;\n\t\t\t\tgoto nocopy;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase OPT_USER:\n\t\t\tif (!value || !*value) {\n\t\t\t\tif (data[4] == '\\0') {\n\t\t\t\t\t*filesys_flags |= MS_USER;\n\t\t\t\t\tgoto nocopy;\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\t\"username specified with no parameter\\n\");\n\t\t\t\t\treturn EX_USAGE;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstrlcpy(parsed_info->username, value,\n\t\t\t\t\tsizeof(parsed_info->username));\n\t\t\t\tparsed_info->got_user = 1;\n\t\t\t\tgoto nocopy;\n\t\t\t}\n\n\t\tcase OPT_PASS:\n\t\t\tif (parsed_info->got_password) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"password specified twice, ignoring second\\n\");\n\t\t\t\tgoto nocopy;\n\t\t\t}\n\t\t\tif (!value || !*value) {\n\t\t\t\tparsed_info->got_password = 1;\n\t\t\t\tgoto nocopy;\n\t\t\t}\n\t\t\trc = set_password(parsed_info, value);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\tgoto nocopy;\n\n\t\tcase OPT_SEC:\n\t\t\tif (value) {\n\t\t\t\tif (!strncmp(value, \"none\", 4))\n\t\t\t\t\tparsed_info->got_password = 1;\n\t\t\t\tif (!strncmp(value, \"krb5\", 4)) {\n\t\t\t\t\tparsed_info->is_krb5 = 1;\n\t\t\t\t\tparsed_info->got_password = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase OPT_IP:\n\t\t\tif (!value || !*value) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"target ip address argument missing\\n\");\n\t\t\t} else if (strnlen(value, MAX_ADDRESS_LEN) <\n\t\t\t\tMAX_ADDRESS_LEN) {\n\t\t\t\tstrlcpy(parsed_info->addrlist, value,\n\t\t\t\t\tMAX_ADDRESS_LEN);\n\t\t\t\tif (parsed_info->verboseflag)\n\t\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\t\"ip address %s override specified\\n\",\n\t\t\t\t\t\tvalue);\n\t\t\t\tgoto nocopy;\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"ip address too long\\n\");\n\t\t\t\treturn EX_USAGE;\n\n\t\t\t}\n\t\t\tbreak;\n\n\t\t/* unc || target || path */\n\t\tcase OPT_UNC:\n\t\t\tif (!value || !*value) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"invalid path to network resource\\n\");\n\t\t\t\treturn EX_USAGE;\n\t\t\t}\n\t\t\trc = parse_unc(value, parsed_info, thisprogram);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\tbreak;\n\n\t\t/* dom || workgroup */\n\t\tcase OPT_DOM:\n\t\t\tif (!value) {\n\t\t\t\t/*\n\t\t\t\t * An empty domain has been passed\n\t\t\t\t */\n\t\t\t\t/* not necessary but better safe than.. */\n\t\t\t\tparsed_info->domain[0] = '\\0';\n\t\t\t\tparsed_info->got_domain = 1;\n\t\t\t\tgoto nocopy;\n\t\t\t}\n\t\t\tif (strnlen(value, sizeof(parsed_info->domain)) >=\n\t\t\t    sizeof(parsed_info->domain)) {\n\t\t\t\tfprintf(stderr, \"domain name too long\\n\");\n\t\t\t\treturn EX_USAGE;\n\t\t\t}\n\t\t\tstrlcpy(parsed_info->domain, value,\n\t\t\t\tsizeof(parsed_info->domain));\n\t\t\tgoto nocopy;\n\n\t\tcase OPT_CRED:\n\t\t\tif (!value || !*value) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"invalid credential file name specified\\n\");\n\t\t\t\treturn EX_USAGE;\n\t\t\t}\n\t\t\trc = open_cred_file(value, parsed_info);\n\t\t\tif (rc) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"error %d (%s) opening credential file %s\\n\",\n\t\t\t\t\trc, strerror(rc), value);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t\tgoto nocopy;\n\n\t\tcase OPT_UID:\n\t\t\tif (!value || !*value)\n\t\t\t\tgoto nocopy;\n\n\t\t\tgot_uid = 1;\n\t\t\tpw = getpwnam(value);\n\t\t\tif (pw) {\n\t\t\t\tuid = pw->pw_uid;\n\t\t\t\tgoto nocopy;\n\t\t\t}\n\n\t\t\terrno = 0;\n\t\t\tuid = strtoul(value, &ep, 10);\n\t\t\tif (errno == 0 && *ep == '\\0')\n\t\t\t\tgoto nocopy;\n\n\t\t\tfprintf(stderr, \"bad option uid=\\\"%s\\\"\\n\", value);\n\t\t\treturn EX_USAGE;\n\t\tcase OPT_CRUID:\n\t\t\tif (!value || !*value)\n\t\t\t\tgoto nocopy;\n\n\t\t\tgot_cruid = 1;\n\t\t\tpw = getpwnam(value);\n\t\t\tif (pw) {\n\t\t\t\tcruid = pw->pw_uid;\n\t\t\t\tgoto nocopy;\n\t\t\t}\n\n\t\t\terrno = 0;\n\t\t\tcruid = strtoul(value, &ep, 10);\n\t\t\tif (errno == 0 && *ep == '\\0')\n\t\t\t\tgoto nocopy;\n\n\t\t\tfprintf(stderr, \"bad option: cruid=\\\"%s\\\"\\n\", value);\n\t\t\treturn EX_USAGE;\n\t\tcase OPT_GID:\n\t\t\tif (!value || !*value)\n\t\t\t\tgoto nocopy;\n\n\t\t\tgot_gid = 1;\n\t\t\tgr = getgrnam(value);\n\t\t\tif (gr) {\n\t\t\t\tgid = gr->gr_gid;\n\t\t\t\tgoto nocopy;\n\t\t\t}\n\n\t\t\terrno = 0;\n\t\t\tgid = strtoul(value, &ep, 10);\n\t\t\tif (errno == 0 && *ep == '\\0')\n\t\t\t\tgoto nocopy;\n\n\t\t\tfprintf(stderr, \"bad option: gid=\\\"%s\\\"\\n\", value);\n\t\t\treturn EX_USAGE;\n\t\t/* fmask falls through to file_mode */\n\t\tcase OPT_FMASK:\n\t\t\tfprintf(stderr,\n\t\t\t\t\"WARNING: CIFS mount option 'fmask' is\\\n\t\t\t\t deprecated. Use 'file_mode' instead.\\n\");\n\t\t\tdata = \"file_mode\";\t/* BB fix this */\n\t\t\t/* Fallthrough */\n\t\tcase OPT_FILE_MODE:\n\t\t\tif (!value || !*value) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"Option '%s' requires a numerical argument\\n\",\n\t\t\t\t\tdata);\n\t\t\t\treturn EX_USAGE;\n\t\t\t}\n\n\t\t\tif (value[0] != '0')\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"WARNING: '%s' not expressed in octal.\\n\",\n\t\t\t\t\tdata);\n\t\t\tbreak;\n\n\t\t/* dmask falls through to dir_mode */\n\t\tcase OPT_DMASK:\n\t\t\tfprintf(stderr,\n\t\t\t\t\"WARNING: CIFS mount option 'dmask' is\\\n\t\t\t\t deprecated. Use 'dir_mode' instead.\\n\");\n\t\t\tdata = \"dir_mode\";\n\t\t\t/* Fallthrough */\n\t\tcase OPT_DIR_MODE:\n\t\t\tif (!value || !*value) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"Option '%s' requires a numerical argument\\n\",\n\t\t\t\t\tdata);\n\t\t\t\treturn EX_USAGE;\n\t\t\t}\n\n\t\t\tif (value[0] != '0')\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"WARNING: '%s' not expressed in octal.\\n\",\n\t\t\t\t\tdata);\n\t\t\tbreak;\n\t\tcase OPT_NO_SUID:\n\t\t\t*filesys_flags |= MS_NOSUID;\n\t\t\tgoto nocopy;\n\t\tcase OPT_SUID:\n\t\t\t*filesys_flags &= ~MS_NOSUID;\n\t\t\tgoto nocopy;\n\t\tcase OPT_NO_DEV:\n\t\t\t*filesys_flags |= MS_NODEV;\n\t\t\tgoto nocopy;\n\t\tcase OPT_NO_LOCK:\n\t\t\t*filesys_flags &= ~MS_MANDLOCK;\n\t\t\tbreak;\n\t\tcase OPT_MAND:\n\t\t\t*filesys_flags |= MS_MANDLOCK;\n\t\t\tgoto nocopy;\n\t\tcase OPT_NOMAND:\n\t\t\t*filesys_flags &= ~MS_MANDLOCK;\n\t\t\tgoto nocopy;\n\t\tcase OPT_DEV:\n\t\t\t*filesys_flags &= ~MS_NODEV;\n\t\t\tgoto nocopy;\n\t\tcase OPT_NO_EXEC:\n\t\t\t*filesys_flags |= MS_NOEXEC;\n\t\t\tgoto nocopy;\n\t\tcase OPT_EXEC:\n\t\t\t*filesys_flags &= ~MS_NOEXEC;\n\t\t\tgoto nocopy;\n\t\tcase OPT_GUEST:\n\t\t\tparsed_info->got_user = 1;\n\t\t\tparsed_info->got_password = 1;\n\t\t\tgoto nocopy;\n\t\tcase OPT_RO:\n\t\t\t*filesys_flags |= MS_RDONLY;\n\t\t\tgoto nocopy;\n\t\tcase OPT_RW:\n\t\t\t*filesys_flags &= ~MS_RDONLY;\n\t\t\tgoto nocopy;\n\t\tcase OPT_REMOUNT:\n\t\t\t*filesys_flags |= MS_REMOUNT;\n\t\t\tgoto nocopy;\n\t\tcase OPT_IGNORE:\n\t\t\tgoto nocopy;\n\t\tcase OPT_BKUPUID:\n\t\t\tif (!value || !*value)\n\t\t\t\tgoto nocopy;\n\n\t\t\tgot_bkupuid = 1;\n\t\t\terrno = 0;\n\t\t\tbkupuid = strtoul(value, &ep, 10);\n\t\t\tif (errno == 0 && *ep == '\\0')\n\t\t\t\tgoto nocopy;\n\n\t\t\tpw = getpwnam(value);\n\t\t\tif (pw == NULL) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"bad user name \\\"%s\\\"\\n\", value);\n\t\t\t\treturn EX_USAGE;\n\t\t\t}\n\n\t\t\tbkupuid = pw->pw_uid;\n\t\t\tgoto nocopy;\n\t\tcase OPT_BKUPGID:\n\t\t\tif (!value || !*value)\n\t\t\t\tgoto nocopy;\n\n\t\t\tgot_bkupgid = 1;\n\t\t\terrno = 0;\n\t\t\tbkupgid = strtoul(value, &ep, 10);\n\t\t\tif (errno == 0 && *ep == '\\0')\n\t\t\t\tgoto nocopy;\n\n\t\t\tgr = getgrnam(value);\n\t\t\tif (gr == NULL) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"bad group name \\\"%s\\\"\\n\", value);\n\t\t\t\treturn EX_USAGE;\n\t\t\t}\n\n\t\t\tbkupgid = gr->gr_gid;\n\t\t\tgoto nocopy;\n\t\tcase OPT_NOFAIL:\n\t\t\tparsed_info->nofail = 1;\n\t\t\tgoto nocopy;\n\t\tcase OPT_SNAPSHOT:\n\t\t\tif (!value || !*value)\n\t\t\t\tgoto nocopy;\n\t\t\tif (strncmp(value, \"@GMT-\", 5))\n\t\t\t\tbreak;\n\t\t\tif ((strlen(value) != GMT_NAME_LEN) ||\n\t\t\t    (strptime(value, GMT_FORMAT, &tm) == NULL)) {\n\t\t\t\tfprintf(stderr, \"bad snapshot token\\n\");\n\t\t\t\treturn EX_USAGE;\n\t\t\t}\n\t\t\tsnapshot = timegm(&tm) * 10000000 + NTFS_TIME_OFFSET;\n\t\t\tgot_snapshot = 1;\n\t\t\tgoto nocopy;\n\t\t}\n\n\t\t/* check size before copying option to buffer */\n\t\tword_len = strlen(data);\n\t\tif (value)\n\t\t\tword_len += 1 + strlen(value);\n\n\t\t/* need 2 extra bytes for comma and null byte */\n\t\tif (out_len + word_len + 2 > MAX_OPTIONS_LEN) {\n\t\t\tfprintf(stderr, \"Options string too long\\n\");\n\t\t\treturn EX_USAGE;\n\t\t}\n\n\t\t/* put back equals sign, if any */\n\t\tif (equals)\n\t\t\t*equals = '=';\n\n\t\t/* go ahead and copy */\n\t\tif (out_len)\n\t\t\tstrlcat(out, \",\", MAX_OPTIONS_LEN);\n\n\t\tstrlcat(out, data, MAX_OPTIONS_LEN);\n\t\tout_len = strlen(out);\nnocopy:\n\t\tdata = next_keyword;\n\t}\n\n\n\t/* special-case the uid and gid */\n\tif (got_uid) {\n\t\tword_len = snprintf(txtbuf, sizeof(txtbuf), \"%u\", uid);\n\n\t\t/* comma + \"uid=\" + terminating NULL == 6 */\n\t\tif (out_len + word_len + 6 > MAX_OPTIONS_LEN) {\n\t\t\tfprintf(stderr, \"Options string too long\\n\");\n\t\t\treturn EX_USAGE;\n\t\t}\n\n\t\tif (out_len) {\n\t\t\tstrlcat(out, \",\", MAX_OPTIONS_LEN);\n\t\t\tout_len++;\n\t\t}\n\t\tsnprintf(out + out_len, word_len + 5, \"uid=%s\", txtbuf);\n\t\tout_len = strlen(out);\n\t}\n\tif (parsed_info->is_krb5 && parsed_info->sudo_uid) {\n\t\tcruid = parsed_info->sudo_uid;\n\t\tgot_cruid = 1;\n\t}\n\tif (got_cruid) {\n\t\tword_len = snprintf(txtbuf, sizeof(txtbuf), \"%u\", cruid);\n\n\t\t/* comma + \"cruid=\" + terminating NULL == 8 */\n\t\tif (out_len + word_len + 8 > MAX_OPTIONS_LEN) {\n\t\t\tfprintf(stderr, \"Options string too long\\n\");\n\t\t\treturn EX_USAGE;\n\t\t}\n\n\t\tif (out_len) {\n\t\t\tstrlcat(out, \",\", MAX_OPTIONS_LEN);\n\t\t\tout_len++;\n\t\t}\n\t\tsnprintf(out + out_len, word_len + 7, \"cruid=%s\", txtbuf);\n\t\tout_len = strlen(out);\n\t}\n\tif (got_gid) {\n\t\tword_len = snprintf(txtbuf, sizeof(txtbuf), \"%u\", gid);\n\n\t\t/* comma + \"gid=\" + terminating NULL == 6 */\n\t\tif (out_len + word_len + 6 > MAX_OPTIONS_LEN) {\n\t\t\tfprintf(stderr, \"Options string too long\\n\");\n\t\t\treturn EX_USAGE;\n\t\t}\n\n\t\tif (out_len) {\n\t\t\tstrlcat(out, \",\", MAX_OPTIONS_LEN);\n\t\t\tout_len++;\n\t\t}\n\t\tsnprintf(out + out_len, word_len + 5, \"gid=%s\", txtbuf);\n\t\tout_len = strlen(out);\n\t}\n\tif (got_bkupuid) {\n\t\tword_len = snprintf(txtbuf, sizeof(txtbuf), \"%u\", bkupuid);\n\n\t\t/* comma + \"backupuid=\" + terminating NULL == 12 */\n\t\tif (out_len + word_len + 12 > MAX_OPTIONS_LEN) {\n\t\t\tfprintf(stderr, \"Options string too long\\n\");\n\t\t\treturn EX_USAGE;\n\t\t}\n\n\t\tif (out_len) {\n\t\t\tstrlcat(out, \",\", MAX_OPTIONS_LEN);\n\t\t\tout_len++;\n\t\t}\n\t\tsnprintf(out + out_len, word_len + 11, \"backupuid=%s\", txtbuf);\n\t\tout_len = strlen(out);\n\t}\n\tif (got_bkupgid) {\n\t\tword_len = snprintf(txtbuf, sizeof(txtbuf), \"%u\", bkupgid);\n\n\t\t/* comma + \"backupgid=\" + terminating NULL == 12 */\n\t\tif (out_len + word_len + 12 > MAX_OPTIONS_LEN) {\n\t\t\tfprintf(stderr, \"Options string too long\\n\");\n\t\t\treturn EX_USAGE;\n\t\t}\n\n\t\tif (out_len) {\n\t\t\tstrlcat(out, \",\", MAX_OPTIONS_LEN);\n\t\t\tout_len++;\n\t\t}\n\t\tsnprintf(out + out_len, word_len + 11, \"backupgid=%s\", txtbuf);\n\t\tout_len = strlen(out);\n\t}\n\tif (got_snapshot) {\n\t\tword_len = snprintf(txtbuf, sizeof(txtbuf), \"%llu\", snapshot);\n\n\t\t/* comma + \"snapshot=\" + terminating NULL == 11 */\n\t\tif (out_len + word_len + 11 > MAX_OPTIONS_LEN) {\n\t\t\tfprintf(stderr, \"Options string too long\\n\");\n\t\t\treturn EX_USAGE;\n\t\t}\n\n\t\tif (out_len) {\n\t\t\tstrlcat(out, \",\", MAX_OPTIONS_LEN);\n\t\t\tout_len++;\n\t\t}\n\t\tsnprintf(out + out_len, word_len + 10, \"snapshot=%s\", txtbuf);\n\t\tout_len = strlen(out);\n\t}\n\n\treturn 0;\n}\n\nstatic int parse_unc(const char *unc_name, struct parsed_mount_info *parsed_info, const char *progname)\n{\n\tint length = strnlen(unc_name, MAX_UNC_LEN);\n\tconst char *host, *share, *prepath;\n\tsize_t hostlen, sharelen, prepathlen;\n\n\tif (length > (MAX_UNC_LEN - 1)) {\n\t\tfprintf(stderr, \"mount error: UNC name too long\\n\");\n\t\treturn EX_USAGE;\n\t}\n\n\tif (length < 3) {\n\t\tfprintf(stderr, \"mount error: UNC name too short\\n\");\n\t\treturn EX_USAGE;\n\t}\n\n\tif ((strncasecmp(\"cifs://\", unc_name, 7) == 0) ||\n\t    (strncasecmp(\"smb://\", unc_name, 6) == 0)) {\n\t\tfprintf(stderr,\n\t\t\t\"Mounting cifs URL not implemented yet. Attempt to mount %s\\n\",\n\t\t\tunc_name);\n\t\treturn EX_USAGE;\n\t}\n\n\tif (strncmp(unc_name, \"//\", 2) && strncmp(unc_name, \"\\\\\\\\\", 2)) {\n\t\tfprintf(stderr, \"%s: bad UNC (%s)\\n\", progname, unc_name);\n\t\treturn EX_USAGE;\n\t}\n\n\thost = unc_name + 2;\n\thostlen = strcspn(host, \"/\\\\\");\n\tif (!hostlen) {\n\t\tfprintf(stderr, \"%s: bad UNC (%s)\\n\", progname, unc_name);\n\t\treturn EX_USAGE;\n\t}\n\tshare = host + hostlen + 1;\n\n\tif (hostlen + 1 > sizeof(parsed_info->host)) {\n\t\tfprintf(stderr, \"%s: host portion of UNC too long\\n\", progname);\n\t\treturn EX_USAGE;\n\t}\n\n\tsharelen = strcspn(share, \"/\\\\\");\n\tif (sharelen + 1 > sizeof(parsed_info->share)) {\n\t\tfprintf(stderr, \"%s: share portion of UNC too long\\n\", progname);\n\t\treturn EX_USAGE;\n\t}\n\n\tprepath = share + sharelen;\n\tif (*prepath != '\\0')\n\t\tprepath++;\n\n\tprepathlen = strlen(prepath);\n\n\tif (prepathlen + 1 > sizeof(parsed_info->prefix)) {\n\t\tfprintf(stderr, \"%s: UNC prefixpath too long\\n\", progname);\n\t\treturn EX_USAGE;\n\t}\n\n\t/* copy pieces into their resepective buffers */\n\tmemcpy(parsed_info->host, host, hostlen);\n\tmemcpy(parsed_info->share, share, sharelen);\n\tmemcpy(parsed_info->prefix, prepath, prepathlen);\n\n\treturn 0;\n}\n\nstatic int get_pw_from_env(struct parsed_mount_info *parsed_info, const char *program)\n{\n\tint rc = 0;\n\n\tif (getenv(\"PASSWD\"))\n\t\trc = set_password(parsed_info, getenv(\"PASSWD\"));\n\telse if (getenv(\"PASSWD_FD\"))\n\t\trc = get_password_from_file(atoi(getenv(\"PASSWD_FD\")), NULL,\n\t\t\t\t\t    parsed_info, program);\n\telse if (getenv(\"PASSWD_FILE\"))\n\t\trc = get_password_from_file(0, getenv(\"PASSWD_FILE\"),\n\t\t\t\t\t    parsed_info, program);\n\n\treturn rc;\n}\n\nstatic struct option longopts[] = {\n\t{\"all\", 0, NULL, 'a'},\n\t{\"help\", 0, NULL, 'h'},\n\t{\"move\", 0, NULL, 'm'},\n\t{\"bind\", 0, NULL, 'b'},\n\t{\"read-only\", 0, NULL, 'r'},\n\t{\"ro\", 0, NULL, 'r'},\n\t{\"verbose\", 0, NULL, 'v'},\n\t{\"version\", 0, NULL, 'V'},\n\t{\"read-write\", 0, NULL, 'w'},\n\t{\"rw\", 0, NULL, 'w'},\n\t{\"options\", 1, NULL, 'o'},\n\t{\"type\", 1, NULL, 't'},\n\t{\"uid\", 1, NULL, '1'},\n\t{\"gid\", 1, NULL, '2'},\n\t{\"user\", 1, NULL, 'u'},\n\t{\"username\", 1, NULL, 'u'},\n\t{\"dom\", 1, NULL, 'd'},\n\t{\"domain\", 1, NULL, 'd'},\n\t{\"password\", 1, NULL, 'p'},\n\t{\"pass\", 1, NULL, 'p'},\n\t{\"credentials\", 1, NULL, 'c'},\n\t{\"port\", 1, NULL, 'P'},\n\t{\"sloppy\", 0, NULL, 's'},\n\t{NULL, 0, NULL, 0}\n};\n\n/* convert a string to uppercase. return false if the string\n * wasn't ASCII. Return success on a NULL ptr */\nstatic int uppercase_string(char *string)\n{\n\tif (!string)\n\t\treturn 1;\n\n\twhile (*string) {\n\t\t/* check for unicode */\n\t\tif ((unsigned char)string[0] & 0x80)\n\t\t\treturn 0;\n\t\t*string = toupper((unsigned char)*string);\n\t\tstring++;\n\t}\n\n\treturn 1;\n}\n\nstatic void print_cifs_mount_version(const char *progname)\n{\n\tprintf(\"%s version: %s\\n\", progname, VERSION);\n}\n\n/*\n * This function borrowed from fuse-utils...\n *\n * glibc's addmntent (at least as of 2.10 or so) doesn't properly encode\n * newlines embedded within the text fields. To make sure no one corrupts\n * the mtab, fail the mount if there are embedded newlines.\n */\nstatic int check_newline(const char *progname, const char *name)\n{\n\tconst char *s;\n\tfor (s = \"\\n\"; *s; s++) {\n\t\tif (strchr(name, *s)) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"%s: illegal character 0x%02x in mount entry\\n\",\n\t\t\t\tprogname, *s);\n\t\t\treturn EX_USAGE;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int check_mtab(const char *progname, const char *devname,\n\t\t      const char *dir)\n{\n\tif (check_newline(progname, devname) || check_newline(progname, dir))\n\t\treturn EX_USAGE;\n\treturn 0;\n}\n\nstatic int\nadd_mtab(char *devname, char *mountpoint, unsigned long flags, const char *fstype)\n{\n\tint rc = 0, tmprc, fd;\n\tuid_t uid;\n\tchar *mount_user = NULL;\n\tstruct mntent mountent;\n\tstruct stat statbuf;\n\tFILE *pmntfile;\n\tsigset_t mask, oldmask;\n\n\tuid = getuid();\n\tif (uid != 0)\n\t\tmount_user = getusername(uid);\n\n\t/*\n\t * Set the real uid to the effective uid. This prevents unprivileged\n\t * users from sending signals to this process, though ^c on controlling\n\t * terminal should still work.\n\t */\n\trc = setreuid(geteuid(), -1);\n\tif (rc != 0) {\n\t\tfprintf(stderr, \"Unable to set real uid to effective uid: %s\\n\",\n\t\t\t\tstrerror(errno));\n\t\treturn EX_FILEIO;\n\t}\n\n\trc = sigfillset(&mask);\n\tif (rc) {\n\t\tfprintf(stderr, \"Unable to set filled signal mask\\n\");\n\t\treturn EX_FILEIO;\n\t}\n\n\trc = sigprocmask(SIG_SETMASK, &mask, &oldmask);\n\tif (rc) {\n\t\tfprintf(stderr, \"Unable to make process ignore signals\\n\");\n\t\treturn EX_FILEIO;\n\t}\n\n\trc = toggle_dac_capability(1, 1);\n\tif (rc)\n\t\treturn EX_FILEIO;\n\n\tatexit(unlock_mtab);\n\trc = lock_mtab();\n\tif (rc) {\n\t\tfprintf(stderr, \"cannot lock mtab\");\n\t\trc = EX_FILEIO;\n\t\tgoto add_mtab_exit;\n\t}\n\n\tpmntfile = setmntent(MOUNTED, \"a+\");\n\tif (!pmntfile) {\n\t\tfprintf(stderr, \"could not update mount table\\n\");\n\t\tunlock_mtab();\n\t\trc = EX_FILEIO;\n\t\tgoto add_mtab_exit;\n\t}\n\n\tfd = fileno(pmntfile);\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"mntent does not appear to be valid\\n\");\n\t\tunlock_mtab();\n\t\trc = EX_FILEIO;\n\t\tgoto add_mtab_exit;\n\t}\n\n\trc = fstat(fd, &statbuf);\n\tif (rc != 0) {\n\t\tfprintf(stderr, \"unable to fstat open mtab\\n\");\n\t\tendmntent(pmntfile);\n\t\tunlock_mtab();\n\t\trc = EX_FILEIO;\n\t\tgoto add_mtab_exit;\n\t}\n\n\tmountent.mnt_fsname = devname;\n\tmountent.mnt_dir = mountpoint;\n\tmountent.mnt_type = (char *)(void *)fstype;\n\tmountent.mnt_opts = (char *)calloc(MTAB_OPTIONS_LEN, 1);\n\tif (mountent.mnt_opts) {\n\t\tif (flags & MS_RDONLY)\n\t\t\tstrlcat(mountent.mnt_opts, \"ro\", MTAB_OPTIONS_LEN);\n\t\telse\n\t\t\tstrlcat(mountent.mnt_opts, \"rw\", MTAB_OPTIONS_LEN);\n\n\t\tif (flags & MS_MANDLOCK)\n\t\t\tstrlcat(mountent.mnt_opts, \",mand\", MTAB_OPTIONS_LEN);\n\t\tif (flags & MS_NOEXEC)\n\t\t\tstrlcat(mountent.mnt_opts, \",noexec\", MTAB_OPTIONS_LEN);\n\t\tif (flags & MS_NOSUID)\n\t\t\tstrlcat(mountent.mnt_opts, \",nosuid\", MTAB_OPTIONS_LEN);\n\t\tif (flags & MS_NODEV)\n\t\t\tstrlcat(mountent.mnt_opts, \",nodev\", MTAB_OPTIONS_LEN);\n\t\tif (flags & MS_SYNCHRONOUS)\n\t\t\tstrlcat(mountent.mnt_opts, \",sync\", MTAB_OPTIONS_LEN);\n\t\tif (mount_user) {\n\t\t\tstrlcat(mountent.mnt_opts, \",user=\", MTAB_OPTIONS_LEN);\n\t\t\tstrlcat(mountent.mnt_opts, mount_user,\n\t\t\t\tMTAB_OPTIONS_LEN);\n\t\t}\n\t}\n\tmountent.mnt_freq = 0;\n\tmountent.mnt_passno = 0;\n\trc = addmntent(pmntfile, &mountent);\n\tif (rc) {\n\t\tint ignore __attribute__((unused));\n\n\t\tfprintf(stderr, \"unable to add mount entry to mtab\\n\");\n\t\tignore = ftruncate(fd, statbuf.st_size);\n\t\trc = EX_FILEIO;\n\t}\n\ttmprc = my_endmntent(pmntfile, statbuf.st_size);\n\tif (tmprc) {\n\t\tfprintf(stderr, \"error %d detected on close of mtab\\n\", tmprc);\n\t\trc = EX_FILEIO;\n\t}\n\tunlock_mtab();\n\tfree(mountent.mnt_opts);\nadd_mtab_exit:\n\ttoggle_dac_capability(1, 0);\n\tsigprocmask(SIG_SETMASK, &oldmask, NULL);\n\n\treturn rc;\n}\n\nstatic int\ndel_mtab(char *mountpoint)\n{\n\tint len, tmprc, rc = 0;\n\tFILE *mnttmp, *mntmtab;\n\tstruct mntent *mountent;\n\tchar *mtabfile, *mtabdir, *mtabtmpfile = NULL;\n\n\tmtabfile = strdup(MOUNTED);\n\tif (!mtabfile) {\n\t\tfprintf(stderr, \"del_mtab: cannot strdup MOUNTED\\n\");\n\t\trc = EX_FILEIO;\n\t\tgoto del_mtab_exit;\n\t}\n\n\tmtabdir = dirname(mtabfile);\n\tlen = strlen(mtabdir) + strlen(MNT_TMP_FILE);\n\tmtabtmpfile = malloc(len + 1);\n\tif (!mtabtmpfile) {\n\t\tfprintf(stderr, \"del_mtab: cannot allocate memory to tmp file\\n\");\n\t\trc = EX_FILEIO;\n\t\tgoto del_mtab_exit;\n\t}\n\n\tif (sprintf(mtabtmpfile, \"%s%s\", mtabdir, MNT_TMP_FILE) != len) {\n\t\tfprintf(stderr, \"del_mtab: error writing new string\\n\");\n\t\trc = EX_FILEIO;\n\t\tgoto del_mtab_exit;\n\t}\n\n\tatexit(unlock_mtab);\n\trc = lock_mtab();\n\tif (rc) {\n\t\tfprintf(stderr, \"del_mtab: cannot lock mtab\\n\");\n\t\trc = EX_FILEIO;\n\t\tgoto del_mtab_exit;\n\t}\n\n\tmtabtmpfile = mktemp(mtabtmpfile);\n\tif (!mtabtmpfile) {\n\t\tfprintf(stderr, \"del_mtab: cannot setup tmp file destination\\n\");\n\t\trc = EX_FILEIO;\n\t\tgoto del_mtab_exit;\n\t}\n\n\tmntmtab = setmntent(MOUNTED, \"r\");\n\tif (!mntmtab) {\n\t\tfprintf(stderr, \"del_mtab: could not update mount table\\n\");\n\t\trc = EX_FILEIO;\n\t\tgoto del_mtab_exit;\n\t}\n\n\tmnttmp = setmntent(mtabtmpfile, \"w\");\n\tif (!mnttmp) {\n\t\tfprintf(stderr, \"del_mtab: could not update mount table\\n\");\n\t\tendmntent(mntmtab);\n\t\trc = EX_FILEIO;\n\t\tgoto del_mtab_exit;\n\t}\n\n\twhile ((mountent = getmntent(mntmtab)) != NULL) {\n\t\tif (!strcmp(mountent->mnt_dir, mountpoint))\n\t\t\tcontinue;\n\t\trc = addmntent(mnttmp, mountent);\n\t\tif (rc) {\n\t\t\tfprintf(stderr, \"del_mtab: unable to add mount entry to mtab\\n\");\n\t\t\trc = EX_FILEIO;\n\t\t\tgoto del_mtab_error;\n\t\t}\n\t}\n\n\tendmntent(mntmtab);\n\n\ttmprc = my_endmntent(mnttmp, 0);\n\tif (tmprc) {\n\t\tfprintf(stderr, \"del_mtab: error %d detected on close of tmp file\\n\", tmprc);\n\t\trc = EX_FILEIO;\n\t\tgoto del_mtab_error;\n\t}\n\n\tif (rename(mtabtmpfile, MOUNTED)) {\n\t\tfprintf(stderr, \"del_mtab: error %d when renaming mtab in place\\n\", errno);\n\t\trc = EX_FILEIO;\n\t\tgoto del_mtab_error;\n\t}\n\ndel_mtab_exit:\n\tunlock_mtab();\n\tfree(mtabtmpfile);\n\tfree(mtabfile);\n\treturn rc;\n\ndel_mtab_error:\n\tif (unlink(mtabtmpfile))\n\t\tfprintf(stderr, \"del_mtab: failed to delete tmp file - %s\\n\",\n\t\t\t\tstrerror(errno));\n\tgoto del_mtab_exit;\n}\n\n/* have the child drop root privileges */\nstatic int\ndrop_child_privs(void)\n{\n\tint rc;\n\tuid_t uid = getuid();\n\tgid_t gid = getgid();\n\n\tif (gid) {\n\t\trc = setgid(gid);\n\t\tif (rc) {\n\t\t\tfprintf(stderr, \"Unable set group identity: %s\\n\",\n\t\t\t\t\tstrerror(errno));\n\t\t\treturn EX_SYSERR;\n\t\t}\n\t}\n\tif (uid) {\n\t\trc = setuid(uid);\n\t\tif (rc) {\n\t\t\tfprintf(stderr, \"Unable set user identity: %s\\n\",\n\t\t\t\t\tstrerror(errno));\n\t\t\treturn EX_SYSERR;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n#ifdef ENABLE_SYSTEMD\nstatic int get_passwd_by_systemd(const char *prompt, char *input, int capacity)\n{\n\tint fd[2];\n\tpid_t pid;\n\tint offs = 0;\n\tint rc = 1;\n\n\tif (pipe(fd) == -1) {\n\t\tfprintf(stderr, \"Failed to create pipe: %s\\n\", strerror(errno));\n\t\treturn 1;\n\t}\n\n\tpid = fork();\n\tif (pid == -1) {\n\t\tfprintf(stderr, \"Unable to fork: %s\\n\", strerror(errno));\n\t\tclose(fd[0]);\n\t\tclose(fd[1]);\n\t\treturn 1;\n\t}\n\tif (pid == 0) {\n\t\tclose(fd[0]);\n\t\tdup2(fd[1], STDOUT_FILENO);\n\t\tif (execlp(\"systemd-ask-password\", \"systemd-ask-password\", prompt, NULL) == -1) {\n\t\t\tfprintf(stderr, \"Failed to execute systemd-ask-password: %s\\n\",\n\t\t\t\tstrerror(errno));\n\t\t}\n\t\texit(1);\n\t}\n\n\tclose(fd[1]);\n\tfor (;;) {\n\t\tif (offs+1 >= capacity) {\n\t\t\tfprintf(stderr, \"Password too long.\\n\");\n\t\t\tkill(pid, SIGTERM);\n\t\t\trc = 1;\n\t\t\tbreak;\n\t\t}\n\t\trc = read(fd[0], input + offs, capacity - offs);\n\t\tif (rc == -1) {\n\t\t\tfprintf(stderr, \"Failed to read from pipe: %s\\n\", strerror(errno));\n\t\t\trc = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (!rc)\n\t\t\tbreak;\n\t\toffs += rc;\n\t\tinput[offs] = '\\0';\n\t}\n\tif (wait(&rc) == -1) {\n\t\tfprintf(stderr, \"Failed to wait child: %s\\n\", strerror(errno));\n\t\trc = 1;\n\t\tgoto out;\n\t}\n\tif (!WIFEXITED(rc) || WEXITSTATUS(rc)) {\n\t\trc = 1;\n\t\tgoto out;\n\t}\n\n\trc = 0;\n\nout:\n\tclose(fd[0]);\n\treturn rc;\n}\n#endif\n\n/*\n * If systemd is running and systemd-ask-password --\n * is available, then use that else fallback on getpass(..)\n *\n * Returns: @input or NULL on error\n */\nstatic char*\nget_password(const char *prompt, char *input, int capacity)\n{\n#ifdef ENABLE_SYSTEMD\n\tint is_systemd_running;\n\tstruct stat a, b;\n\n\tmemset(input, 0, capacity);\n\n\t/* We simply test whether the systemd cgroup hierarchy is\n\t * mounted */\n\tis_systemd_running = (lstat(\"/sys/fs/cgroup\", &a) == 0)\n\t\t&& (lstat(\"/sys/fs/cgroup/systemd\", &b) == 0)\n\t\t&& (a.st_dev != b.st_dev);\n\n\tif (is_systemd_running && !get_passwd_by_systemd(prompt, input, capacity)) {\n\t\tint len = strlen(input);\n\t\tif (input[len - 1] == '\\n')\n\t\t\tinput[len - 1] = '\\0';\n\t\treturn input;\n\t}\n#endif\n\tmemset(input, 0, capacity);\n\n\t/*\n\t * Falling back to getpass(..)\n\t * getpass is obsolete, but there's apparently nothing that replaces it\n\t */\n\tchar *tmp_pass = getpass(prompt);\n\tif (!tmp_pass)\n\t\treturn NULL;\n\n\tstrncpy(input, tmp_pass, capacity - 1);\n\tinput[capacity - 1] = '\\0';\n\n\t/* zero-out the static buffer */\n\tmemset(tmp_pass, 0, strlen(tmp_pass));\n\n\treturn input;\n}\n\nstatic int\nassemble_mountinfo(struct parsed_mount_info *parsed_info,\n\t\t   const char *thisprogram, const char *mountpoint,\n\t\t   const char *orig_dev, char *orgoptions)\n{\n\tint rc;\n\tchar *newopts = NULL;\n\n\trc = drop_capabilities(0);\n\tif (rc)\n\t\tgoto assemble_exit;\n\n\trc = drop_child_privs();\n\tif (rc)\n\t\tgoto assemble_exit;\n\n\tif (getuid()) {\n\t\trc = check_fstab(thisprogram, mountpoint, orig_dev,\n\t\t\t\t &newopts);\n\t\tif (rc)\n\t\t\tgoto assemble_exit;\n\n\t\torgoptions = newopts;\n\t\t/* enable any default user mount flags */\n\t\tparsed_info->flags |= CIFS_SETUID_FLAGS;\n\t}\n\n\trc = get_pw_from_env(parsed_info, thisprogram);\n\tif (rc)\n\t\tgoto assemble_exit;\n\n\tif (orgoptions) {\n\t\trc = parse_options(orgoptions, parsed_info);\n\t\tif (rc)\n\t\t\tgoto assemble_exit;\n\t}\n\n\tif (getuid()) {\n\t\tif (!(parsed_info->flags & (MS_USERS | MS_USER))) {\n\t\t\tfprintf(stderr, \"%s: permission denied\\n\", thisprogram);\n\t\t\trc = EX_USAGE;\n\t\t\tgoto assemble_exit;\n\t\t}\n\t}\n\n\tparsed_info->flags &= ~(MS_USERS | MS_USER);\n\n\trc = parse_unc(orig_dev, parsed_info, thisprogram);\n\tif (rc)\n\t\tgoto assemble_exit;\n\n\tif (parsed_info->addrlist[0] == '\\0')\n\t\trc = resolve_host(parsed_info->host, parsed_info->addrlist);\n\n\tswitch (rc) {\n\tcase EX_USAGE:\n\t\tfprintf(stderr, \"mount error: could not resolve address for \"\n\t\t\t\"%s: %s\\n\", parsed_info->host,\n\t\t\trc == EAI_SYSTEM ? strerror(errno) : gai_strerror(rc));\n\t\tgoto assemble_exit;\n\n\tcase EX_SYSERR:\n\t\tfprintf(stderr, \"mount error: problem parsing address \"\n\t\t\t\"list: %s\\n\", strerror(errno));\n\t\tgoto assemble_exit;\n\t}\n\n\tif (!parsed_info->got_user) {\n\t\t/*\n\t\t * Note that the password will not be retrieved from the\n\t\t * USER env variable (ie user%password form) as there is\n\t\t * already a PASSWD environment varaible\n\t\t */\n\t\tif (getenv(\"USER\"))\n\t\t\tstrlcpy(parsed_info->username, getenv(\"USER\"),\n\t\t\t\tsizeof(parsed_info->username));\n\t\telse\n\t\t\tstrlcpy(parsed_info->username, getusername(getuid()),\n\t\t\t\tsizeof(parsed_info->username));\n\t\tparsed_info->got_user = 1;\n\t}\n\n\tif (!parsed_info->got_password) {\n\t\tchar tmp_pass[MOUNT_PASSWD_SIZE + 1];\n\t\tchar *prompt = NULL;\n\n\t\tif(asprintf(&prompt, \"Password for %s@%s: \", parsed_info->username, orig_dev) < 0)\n\t\t\tprompt = NULL;\n\n\t\tif (get_password(prompt ? prompt : \"Password: \", tmp_pass, MOUNT_PASSWD_SIZE + 1)) {\n\t\t\trc = set_password(parsed_info, tmp_pass);\n\t\t} else {\n\t\t\tfprintf(stderr, \"Error reading password, exiting\\n\");\n\t\t\trc = EX_SYSERR;\n\t\t}\n\n\t\tfree(prompt);\n\t\tif (rc)\n\t\t\tgoto assemble_exit;\n\t}\n\n\t/* copy in user= string */\n\tif (parsed_info->got_user) {\n\t\tif (*parsed_info->options)\n\t\t\tstrlcat(parsed_info->options, \",\",\n\t\t\t\tsizeof(parsed_info->options));\n\t\tstrlcat(parsed_info->options, \"user=\",\n\t\t\tsizeof(parsed_info->options));\n\t\tstrlcat(parsed_info->options, parsed_info->username,\n\t\t\tsizeof(parsed_info->options));\n\t}\n\n\tif (*parsed_info->domain) {\n\t\tif (*parsed_info->options)\n\t\t\tstrlcat(parsed_info->options, \",\",\n\t\t\t\tsizeof(parsed_info->options));\n\t\tstrlcat(parsed_info->options, \"domain=\",\n\t\t\tsizeof(parsed_info->options));\n\t\tstrlcat(parsed_info->options, parsed_info->domain,\n\t\t\tsizeof(parsed_info->options));\n\t} else if (parsed_info->got_domain) {\n\t\tstrlcat(parsed_info->options, \",domain=\",\n\t\t\tsizeof(parsed_info->options));\n\t}\n\nassemble_exit:\n\tfree(newopts);\n\treturn rc;\n}\n\n/*\n * chdir() into the mountpoint and determine \"realpath\". We assume here that\n * \"mountpoint\" is a statically allocated string and does not need to be freed.\n */\nstatic int\nacquire_mountpoint(char **mountpointp)\n{\n\tint rc, dacrc;\n\tuid_t realuid, oldfsuid;\n\tgid_t oldfsgid;\n\tchar *mountpoint = NULL;\n\n\t/*\n\t * Acquire the necessary privileges to chdir to the mountpoint. If\n\t * the real uid is root, then we reacquire CAP_DAC_READ_SEARCH. If\n\t * it's not, then we change the fsuid to the real uid to ensure that\n\t * the mounting user actually has access to the mountpoint.\n\t *\n\t * The mount(8) manpage does not state that users must be able to\n\t * chdir into the mountpoint in order to mount onto it, but if we\n\t * allow that, then an unprivileged user could use this program to\n\t * \"probe\" into directories to which he does not have access.\n\t */\n\trealuid = getuid();\n\tif (realuid == 0) {\n\t\trc = toggle_dac_capability(0, 1);\n\t\tif (rc)\n\t\t\tgoto out;\n\t} else {\n\t\toldfsuid = setfsuid(realuid);\n\t\toldfsgid = setfsgid(getgid());\n\t}\n\n\trc = chdir(*mountpointp);\n\tif (rc) {\n\t\tfprintf(stderr, \"Couldn't chdir to %s: %s\\n\", *mountpointp,\n\t\t\tstrerror(errno));\n\t\trc = EX_USAGE;\n\t\tgoto restore_privs;\n\t}\n\n\tmountpoint = realpath(\".\", NULL);\n\tif (!mountpoint) {\n\t\tfprintf(stderr, \"Unable to resolve %s to canonical path: %s\\n\",\n\t\t\t*mountpointp, strerror(errno));\n\t\trc = EX_SYSERR;\n\t}\n\nrestore_privs:\n\tif (realuid == 0) {\n\t\tdacrc = toggle_dac_capability(0, 0);\n\t\tif (dacrc)\n\t\t\trc = rc ? rc : dacrc;\n\t} else {\n\t\tuid_t __attribute__((unused)) uignore = setfsuid(oldfsuid);\n\t\tgid_t __attribute__((unused)) gignore = setfsgid(oldfsgid);\n\t}\n\nout:\n\tif (rc) {\n\t\tfree(mountpoint);\n\t\tmountpoint = NULL;\n\t}\n\n\t*mountpointp = mountpoint;\n\treturn rc;\n}\n\nint main(int argc, char **argv)\n{\n\tint c;\n\tchar *orgoptions = NULL;\n\tchar *mountpoint = NULL;\n\tchar *options = NULL;\n\tchar *orig_dev = NULL;\n\tchar *currentaddress, *nextaddress;\n\tchar *value = NULL;\n\tchar *ep = NULL;\n\tint rc = 0;\n\tint already_uppercased = 0;\n\tint sloppy = 0;\n\tint fallback_sudo_uid = 0;\n\tsize_t options_size = MAX_OPTIONS_LEN;\n\tstruct parsed_mount_info *parsed_info = NULL;\n\tstruct parsed_mount_info *reinit_parsed_info = NULL;\n\tpid_t pid;\n\tuid_t sudo_uid = 0;\n\n\trc = check_setuid();\n\tif (rc)\n\t\treturn rc;\n\n\trc = drop_capabilities(1);\n\tif (rc)\n\t\treturn EX_SYSERR;\n\n\t/* setlocale(LC_ALL, \"\");\n\t   bindtextdomain(PACKAGE, LOCALEDIR);\n\t   textdomain(PACKAGE); */\n\n\tif (!argc || !argv) {\n\t\trc = mount_usage(stderr);\n\t\tgoto mount_exit;\n\t}\n\n\tthisprogram = basename(argv[0]);\n\tif (thisprogram == NULL)\n\t\tthisprogram = \"mount.cifs\";\n\n\tif(strcmp(thisprogram, \"mount.cifs\") == 0)\n\t\tcifs_fstype = \"cifs\";\n\n\tif(strcmp(thisprogram, \"mount.smb3\") == 0)\n\t\tcifs_fstype = \"smb3\";\n\n\t/* allocate parsed_info as shared anonymous memory range */\n\tparsed_info = mmap((void *)0, sizeof(*parsed_info), PROT_READ | PROT_WRITE,\n\t\t\t   MAP_ANONYMOUS | MAP_SHARED, -1, 0);\n\tif (parsed_info == (struct parsed_mount_info *) -1) {\n\t\tparsed_info = NULL;\n\t\tfprintf(stderr, \"Unable to allocate memory: %s\\n\",\n\t\t\t\tstrerror(errno));\n\t\trc = EX_SYSERR;\n\t\tgoto mount_exit;\n\t}\n\n\treinit_parsed_info = malloc(sizeof(*reinit_parsed_info));\n\tif (reinit_parsed_info == NULL) {\n\t\tfprintf(stderr, \"Unable to allocate memory: %s\\n\",\n\t\t\t\tstrerror(errno));\n\t\trc = EX_SYSERR;\n\t\tgoto mount_exit;\n\t}\n\n\toptions = calloc(options_size, 1);\n\tif (!options) {\n\t\tfprintf(stderr, \"Unable to allocate memory.\\n\");\n\t\trc = EX_SYSERR;\n\t\tgoto mount_exit;\n\t}\n\n\t/* add sharename in opts string as unc= parm */\n\twhile ((c = getopt_long(argc, argv, \"?fhno:rsvVw\",\n\t\t\t\tlongopts, NULL)) != -1) {\n\t\tswitch (c) {\n\t\tcase '?':\n\t\tcase 'h':\t/* help */\n\t\t\trc = mount_usage(stdout);\n\t\t\tgoto mount_exit;\n\t\tcase 'n':\n\t\t\t++parsed_info->nomtab;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\torgoptions = strndup(optarg, MAX_OPTIONS_LEN);\n\t\t\tif (!orgoptions) {\n\t\t\t\trc = EX_SYSERR;\n\t\t\t\tgoto mount_exit;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'r':\t/* mount readonly */\n\t\t\tparsed_info->flags |= MS_RDONLY;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\t++parsed_info->verboseflag;\n\t\t\tbreak;\n\t\tcase 'V':\n\t\t\tprint_cifs_mount_version(thisprogram);\n\t\t\texit(0);\n\t\tcase 'w':\n\t\t\tparsed_info->flags &= ~MS_RDONLY;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\t++parsed_info->fakemnt;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\t++sloppy;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(stderr, \"unknown command-line option: %c\\n\", c);\n\t\t\trc = mount_usage(stderr);\n\t\t\tgoto mount_exit;\n\t\t}\n\t}\n\n\tif (argc < optind + 2) {\n\t\trc = mount_usage(stderr);\n\t\tgoto mount_exit;\n\t}\n\n\torig_dev = argv[optind];\n\tmountpoint = argv[optind + 1];\n\n\t/* chdir into mountpoint as soon as possible */\n\trc = acquire_mountpoint(&mountpoint);\n\tif (rc) {\n\t\tgoto mount_exit;\n\t}\n\n\t/* Before goto assemble_retry, reinitialize parsed_info with reinit_parsed_info */\n\tmemcpy(reinit_parsed_info, parsed_info,\tsizeof(*reinit_parsed_info));\n\nassemble_retry:\n\t/*\n\t * mount.cifs does privilege separation. Most of the code to handle\n\t * assembling the mount info is done in a child process that drops\n\t * privileges. The info is assembled in parsed_info which is a\n\t * shared, mmaped memory segment. The parent waits for the child to\n\t * exit and checks the return code. If it's anything but \"0\", then\n\t * the process exits without attempting anything further.\n\t */\n\tpid = fork();\n\tif (pid == -1) {\n\t\tfprintf(stderr, \"Unable to fork: %s\\n\", strerror(errno));\n\t\trc = EX_SYSERR;\n\t\tgoto mount_exit;\n\t} else if (!pid) {\n\t\t/* child */\n\t\trc = assemble_mountinfo(parsed_info, thisprogram, mountpoint,\n\t\t\t\t\torig_dev, orgoptions);\n\t\tgoto mount_child_exit;\n\t} else {\n\t\t/* parent */\n\t\tpid = wait(&rc);\n\t\tif (!WIFEXITED(rc)) {\n\t\t\tfprintf(stderr, \"Child process terminated abnormally.\\n\");\n\t\t\trc = EX_SYSERR;\n\t\t\tgoto mount_exit;\n\t\t}\n\t\trc = WEXITSTATUS(rc);\n\t\tif (rc)\n\t\t\tgoto mount_exit;\n\t}\n\n\tcurrentaddress = parsed_info->addrlist;\n\tnextaddress = strchr(currentaddress, ',');\n\tif (nextaddress)\n\t\t*nextaddress++ = '\\0';\n\nmount_retry:\n\toptions[0] = '\\0';\n\tif (!currentaddress) {\n\t\tfprintf(stderr, \"Unable to find suitable address.\\n\");\n\t\trc = parsed_info->nofail ? 0 : EX_FAIL;\n\t\tgoto mount_exit;\n\t}\n\tstrlcpy(options, \"ip=\", options_size);\n\tstrlcat(options, currentaddress, options_size);\n\n\tstrlcat(options, \",unc=\\\\\\\\\", options_size);\n\tstrlcat(options, parsed_info->host, options_size);\n\tstrlcat(options, \"\\\\\", options_size);\n\tstrlcat(options, parsed_info->share, options_size);\n\n\tif (*parsed_info->options) {\n\t\tstrlcat(options, \",\", options_size);\n\t\tstrlcat(options, parsed_info->options, options_size);\n\t}\n\n\tif (*parsed_info->prefix) {\n\t\tstrlcat(options, \",prefixpath=\", options_size);\n\t\tstrlcat(options, parsed_info->prefix, options_size);\n\t}\n\n\tif (sloppy)\n\t\tstrlcat(options, \",sloppy\", options_size);\n\n\tif (parsed_info->verboseflag)\n\t\tfprintf(stderr, \"%s kernel mount options: %s\",\n\t\t\tthisprogram, options);\n\n\tif (parsed_info->got_password) {\n\t\t/*\n\t\t * Commas have to be doubled, or else they will\n\t\t * look like the parameter separator\n\t\t */\n\t\tstrlcat(options, \",pass=\", options_size);\n\t\tstrlcat(options, parsed_info->password, options_size);\n\t\tif (parsed_info->verboseflag)\n\t\t\tfprintf(stderr, \",pass=********\");\n\t}\n\n\tif (parsed_info->verboseflag)\n\t\tfprintf(stderr, \"\\n\");\n\n\trc = check_mtab(thisprogram, orig_dev, mountpoint);\n\tif (rc)\n\t\tgoto mount_exit;\n\n\tif (!parsed_info->fakemnt) {\n\t\ttoggle_dac_capability(0, 1);\n\t\trc = mount(orig_dev, \".\", cifs_fstype, parsed_info->flags, options);\n\t\ttoggle_dac_capability(0, 0);\n\t\tif (rc == 0)\n\t\t\tgoto do_mtab;\n\n\t\tswitch (errno) {\n\t\tcase ECONNREFUSED:\n\t\tcase EHOSTUNREACH:\n\t\t\tif (currentaddress) {\n\t\t\t\tfprintf(stderr, \"mount error(%d): could not connect to %s\",\n\t\t\t\t\terrno, currentaddress);\n\t\t\t}\n\t\t\tcurrentaddress = nextaddress;\n\t\t\tif (currentaddress) {\n\t\t\t\tnextaddress = strchr(currentaddress, ',');\n\t\t\t\tif (nextaddress)\n\t\t\t\t\t*nextaddress++ = '\\0';\n\t\t\t}\n\t\t\tgoto mount_retry;\n\t\tcase ENODEV:\n\t\t\tfprintf(stderr,\n\t\t\t\t\"mount error: %s filesystem not supported by the system\\n\", cifs_fstype);\n\t\t\tbreak;\n\t\tcase EHOSTDOWN:\n\t\t\tfprintf(stderr,\n\t\t\t\t\"mount error: Server abruptly closed the connection.\\n\"\n\t\t\t\t\"This can happen if the server does not support the SMB version you are trying to use.\\n\"\n\t\t\t\t\"The default SMB version recently changed from SMB1 to SMB2.1 and above. Try mounting with vers=1.0.\\n\");\n\t\t\tbreak;\n\t\tcase ENXIO:\n\t\t\tif (!already_uppercased &&\n\t\t\t    uppercase_string(parsed_info->host) &&\n\t\t\t    uppercase_string(parsed_info->share) &&\n\t\t\t    uppercase_string(parsed_info->prefix) &&\n\t\t\t    uppercase_string(orig_dev)) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"Retrying with upper case share name\\n\");\n\t\t\t\talready_uppercased = 1;\n\t\t\t\tgoto mount_retry;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ENOKEY:\n\t\t\tif (!fallback_sudo_uid && parsed_info->is_krb5) {\n\t\t\t\t/* mount could have failed because cruid option was not passed when triggered with sudo */\n\t\t\t\tvalue = getenv(\"SUDO_UID\");\n\t\t\t\tif (value) {\n\t\t\t\t\terrno = 0;\n\t\t\t\t\tsudo_uid = strtoul(value, &ep, 10);\n\t\t\t\t\tif (errno == 0 && *ep == '\\0' && sudo_uid) {\n\t\t\t\t\t\t/* Reinitialize parsed_info and assemble options again with sudo_uid */\n\t\t\t\t\t\tmemcpy(parsed_info, reinit_parsed_info, sizeof(*parsed_info));\n\t\t\t\t\t\tparsed_info->sudo_uid = sudo_uid;\n\t\t\t\t\t\tfallback_sudo_uid = 1;\n\t\t\t\t\t\tgoto assemble_retry;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tfprintf(stderr, \"mount error(%d): %s\\n\", errno,\n\t\t\tstrerror(errno));\n\t\tfprintf(stderr,\n\t\t\t\"Refer to the %s(8) manual page (e.g. man \"\n\t\t\t\"%s) and kernel log messages (dmesg)\\n\", thisprogram, thisprogram);\n\t\trc = EX_FAIL;\n\t\tgoto mount_exit;\n\t}\n\ndo_mtab:\n\tif (!parsed_info->nomtab && !mtab_unusable()) {\n\t\tif (parsed_info->flags & MS_REMOUNT) {\n\t\t\trc = del_mtab(mountpoint);\n\t\t\tif (rc)\n\t\t\t\tgoto mount_exit;\n\t\t}\n\n\t\trc = add_mtab(orig_dev, mountpoint, parsed_info->flags, cifs_fstype);\n\t}\n\nmount_exit:\n\tif (parsed_info) {\n\t\tmemset(parsed_info->password, 0, sizeof(parsed_info->password));\n\t\tmunmap(parsed_info, sizeof(*parsed_info));\n\t}\n\nmount_child_exit:\n\t/* Objects to be freed both in main process and child */\n\tfree(reinit_parsed_info);\n\tfree(options);\n\tfree(orgoptions);\n\tfree(mountpoint);\n\treturn rc;\n}\n"], "fixing_code": ["/*\n * Mount helper utility for Linux CIFS VFS (virtual filesystem) client\n * Copyright (C) 2003,2010 Steve French  (sfrench@us.ibm.com)\n * Copyright (C) 2008 Jeremy Allison (jra@samba.org)\n * Copyright (C) 2010 Jeff Layton (jlayton@samba.org)\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif /* HAVE_CONFIG_H */\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <grp.h>\n#include <ctype.h>\n#include <sys/types.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/utsname.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <getopt.h>\n#include <errno.h>\n#include <netdb.h>\n#include <string.h>\n#include <mntent.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <paths.h>\n#include <libgen.h>\n#include <time.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#ifdef HAVE_SYS_FSUID_H\n#include <sys/fsuid.h>\n#endif /* HAVE_SYS_FSUID_H */\n#ifdef HAVE_LIBCAP_NG\n#include <cap-ng.h>\n#else /* HAVE_LIBCAP_NG */\n#ifdef HAVE_PRCTL\n#include <sys/prctl.h>\n#endif /* HAVE_PRCTL */\n#ifdef HAVE_LIBCAP\n#include <sys/capability.h>\n#endif /* HAVE_LIBCAP */\n#endif /* HAVE_LIBCAP_NG */\n#include \"mount.h\"\n#include \"util.h\"\n#include \"resolve_host.h\"\n\n#ifndef MS_MOVE \n#define MS_MOVE 8192 \n#endif \n\n#ifndef MS_BIND\n#define MS_BIND 4096\n#endif\n\n/* private flags - clear these before passing to kernel */\n#define MS_USERS\t0x40000000\n#define MS_USER\t\t0x80000000\n\n#define MAX_UNC_LEN 1024\n\n/* I believe that the kernel limits options data to a page */\n#define MAX_OPTIONS_LEN\t4096\n\n/* max length of mtab options */\n#define MTAB_OPTIONS_LEN 220\n\n/*\n * Max share name, username, password and domain sizes match the kernel's\n * allowances for these string sizes which in turn match Microsoft's\n * documentation.\n */\n\n/* Max length of the share name portion of a UNC. Share names over 80\n * characters cannot be accessed via commandline in Windows 2000/XP. */\n#define MAX_SHARE_LEN 256\n\n/* Max user name length. */\n#define MAX_USERNAME_SIZE 256\n\n/* Max domain size. */\n#define MAX_DOMAIN_SIZE 256\n\n/* Max password size. */\n#define MOUNT_PASSWD_SIZE 512\n\n/*\n * mount.cifs has been the subject of many \"security\" bugs that have arisen\n * because of users and distributions installing it as a setuid root program\n * before it had been audited for security holes. The default behavior is\n * now to allow mount.cifs to be run as a setuid root program. Some admins\n * may want to disable this fully, so this switch remains in place.\n */\n#define CIFS_DISABLE_SETUID_CAPABILITY 0\n\n/*\n * When an unprivileged user runs a setuid mount.cifs, we set certain mount\n * flags by default. These defaults can be changed here.\n */\n#define CIFS_SETUID_FLAGS (MS_NOSUID|MS_NODEV)\n\n/*\n * Values for parsing a credentials file.\n */\n#define CRED_UNPARSEABLE 0\n#define CRED_USER        1\n#define CRED_PASS        2\n#define CRED_DOM         4\n\n/*\n * Values for parsing command line options.\n */\n#define OPT_ERROR       -1\n#define OPT_IGNORE      0\n#define OPT_USERS       1\n#define OPT_USER        2\n#define OPT_USER_XATTR  3\n#define OPT_PASS        4\n#define OPT_SEC         5\n#define OPT_IP          6\n#define OPT_UNC         7\n#define OPT_CRED        8\n#define OPT_UID         9\n#define OPT_GID        10\n#define OPT_FMASK      11\n#define OPT_FILE_MODE  12\n#define OPT_DMASK      13\n#define OPT_DIR_MODE   14\n#define OPT_DOM        15\n#define OPT_NO_SUID    16\n#define OPT_SUID       17\n#define OPT_NO_DEV     18\n#define OPT_DEV        19\n#define OPT_NO_LOCK    20\n#define OPT_NO_EXEC    21\n#define OPT_EXEC       22\n#define OPT_GUEST      23\n#define OPT_RO         24\n#define OPT_RW         25\n#define OPT_REMOUNT    26\n#define OPT_MAND       27\n#define OPT_NOMAND     28\n#define OPT_CRUID      29\n#define OPT_BKUPUID    30\n#define OPT_BKUPGID    31\n#define OPT_NOFAIL     32\n#define OPT_SNAPSHOT   33\n\n#define MNT_TMP_FILE \"/.mtab.cifs.XXXXXX\"\n\n#define GMT_NAME_LEN 24 /* length of a @GMT- name */\n#define GMT_FORMAT \"@GMT-%Y.%m.%d-%H.%M.%S\"\n\n#define NTFS_TIME_OFFSET ((unsigned long long)(369*365 + 89) * 24 * 3600 * 10000000)\n\n/*\n* struct for holding parsed mount info for use by privileged process.\n* Please do not keep pointers in this struct.\n* That way, reinit of this struct is a simple memset.\n*/\nstruct parsed_mount_info {\n\tunsigned long flags;\n\tchar host[NI_MAXHOST + 1];\n\tchar share[MAX_SHARE_LEN + 1];\n\tchar prefix[PATH_MAX + 1];\n\tchar options[MAX_OPTIONS_LEN];\n\tchar domain[MAX_DOMAIN_SIZE + 1];\n\tchar username[MAX_USERNAME_SIZE + 1];\n\tchar password[MOUNT_PASSWD_SIZE + 1];\n\tchar addrlist[MAX_ADDR_LIST_LEN];\n\tunsigned int got_user:1;\n\tunsigned int got_password:1;\n\tunsigned int fakemnt:1;\n\tunsigned int nomtab:1;\n\tunsigned int verboseflag:1;\n\tunsigned int nofail:1;\n\tunsigned int got_domain:1;\n\tunsigned int is_krb5:1;\n\tuid_t sudo_uid;\n};\n\nstatic const char *thisprogram;\nstatic const char *cifs_fstype;\n\nstatic int parse_unc(const char *unc_name, struct parsed_mount_info *parsed_info, const char *progname);\n\nstatic int check_setuid(void)\n{\n\tif (geteuid()) {\n\t\tfprintf(stderr, \"This program is not installed setuid root - \"\n\t\t\t\" \\\"user\\\" CIFS mounts not supported.\\n\");\n\t\treturn EX_USAGE;\n\t}\n\n#if CIFS_DISABLE_SETUID_CAPABILITY\n\tif (getuid() && !geteuid()) {\n\t\tprintf(\"This program has been built with the \"\n\t\t       \"ability to run as a setuid root program disabled.\\n\");\n\t\treturn EX_USAGE;\n\t}\n#endif /* CIFS_DISABLE_SETUID_CAPABILITY */\n\n\treturn 0;\n}\n\nstatic int\ncheck_fstab(const char *progname, const char *mountpoint, const char *devname,\n\t    char **options)\n{\n\tFILE *fstab;\n\tstruct mntent *mnt;\n\tsize_t len;\n\n\t/* make sure this mount is listed in /etc/fstab */\n\tfstab = setmntent(_PATH_MNTTAB, \"r\");\n\tif (!fstab) {\n\t\tfprintf(stderr, \"Couldn't open %s for reading!\\n\", _PATH_MNTTAB);\n\t\treturn EX_FILEIO;\n\t}\n\n\twhile ((mnt = getmntent(fstab))) {\n\t\tlen = strlen(mnt->mnt_dir);\n\t\twhile (len > 1) {\n\t\t        if (mnt->mnt_dir[len - 1] == '/')\n\t\t\t        mnt->mnt_dir[len - 1] = '\\0';\n\t\t        else\n\t\t\t\tbreak;\n\t\t\tlen--;\n\t\t}\n\t\tif (!strcmp(mountpoint, mnt->mnt_dir))\n\t\t\tbreak;\n\t}\n\tendmntent(fstab);\n\n\tif (mnt == NULL || strcmp(mnt->mnt_fsname, devname)) {\n\t\tfprintf(stderr, \"%s: permission denied: no match for \"\n\t\t\t\"%s found in %s\\n\", progname, mountpoint, _PATH_MNTTAB);\n\t\treturn EX_USAGE;\n\t}\n\n\t/*\n\t * 'mount' munges the options from fstab before passing them\n\t * to us. It is non-trivial to test that we have the correct\n\t * set of options. We don't want to trust what the user\n\t * gave us, so just take whatever is in /etc/fstab.\n\t */\n\t*options = strdup(mnt->mnt_opts);\n\treturn 0;\n}\n\n/* BB finish BB\n\n\tcifs_umount\n\topen nofollow - avoid symlink exposure? \n\tget owner of dir see if matches self or if root\n\tcall system(umount argv) etc.\n\nBB end finish BB */\n\nstatic int mount_usage(FILE * stream)\n{\n\tfprintf(stream, \"\\nUsage:  %s <remotetarget> <dir> -o <options>\\n\",\n\t\tthisprogram);\n\tfprintf(stream, \"\\nMount the remote target, specified as a UNC name,\");\n\tfprintf(stream, \" to a local directory.\\n\\nOptions:\\n\");\n\tfprintf(stream, \"\\tuser=<arg>\\n\\tpass=<arg>\\n\\tdom=<arg>\\n\");\n\tfprintf(stream, \"\\nLess commonly used options:\");\n\tfprintf(stream,\n\t\t\"\\n\\tcredentials=<filename>,guest,perm,noperm,setuids,nosetuids,rw,ro,\");\n\tfprintf(stream,\n\t\t\"\\n\\tsep=<char>,iocharset=<codepage>,suid,nosuid,exec,noexec,serverino,\");\n\tfprintf(stream,\n\t\t\"\\n\\tnoserverino,mapchars,nomapchars,nolock,servernetbiosname=<SRV_RFC1001NAME>\");\n\tfprintf(stream,\n\t\t\"\\n\\tcache=<strict|none|loose>,nounix,cifsacl,sec=<authentication mechanism>,\");\n\tfprintf(stream,\n\t\t\"\\n\\tsign,seal,fsc,snapshot=<token|time>,nosharesock,persistenthandles,\");\n\tfprintf(stream,\n\t\t\"\\n\\tresilienthandles,rdma,vers=<smb_dialect>,cruid\");\n\tfprintf(stream,\n\t\t\"\\n\\nOptions not needed for servers supporting CIFS Unix extensions\");\n\tfprintf(stream,\n\t\t\"\\n\\t(e.g. unneeded for mounts to most Samba versions):\");\n\tfprintf(stream,\n\t\t\"\\n\\tuid=<uid>,gid=<gid>,dir_mode=<mode>,file_mode=<mode>,sfu,\");\n\tfprintf(stream,\n\t\t\"\\n\\tmfsymlinks,idsfromsid\");\n\tfprintf(stream, \"\\n\\nRarely used options:\");\n\tfprintf(stream,\n\t\t\"\\n\\tport=<tcpport>,rsize=<size>,wsize=<size>,unc=<unc_name>,ip=<ip_address>,\");\n\tfprintf(stream,\n\t\t\"\\n\\tdev,nodev,nouser_xattr,netbiosname=<OUR_RFC1001NAME>,hard,soft,intr,\");\n\tfprintf(stream,\n\t\t\"\\n\\tnointr,ignorecase,noposixpaths,noacl,prefixpath=<path>,nobrl,\");\n\tfprintf(stream,\n\t\t\"\\n\\techo_interval=<seconds>,actimeo=<seconds>,max_credits=<credits>,\");\n\tfprintf(stream,\n\t\t\"\\n\\tbsize=<size>\");\n\tfprintf(stream,\n\t\t\"\\n\\nOptions are described in more detail in the manual page\");\n\tfprintf(stream, \"\\n\\tman 8 %s\\n\", thisprogram);\n\tfprintf(stream, \"\\nTo display the version number of the mount helper:\");\n\tfprintf(stream, \"\\n\\t%s -V\\n\", thisprogram);\n\n\tif (stream == stderr)\n\t\treturn EX_USAGE;\n\treturn 0;\n}\n\n/*\n * CIFS has to \"escape\" commas in the password field so that they don't\n * end up getting confused for option delimiters. Copy password into pw\n * field, turning any commas into double commas.\n */\nstatic int set_password(struct parsed_mount_info *parsed_info, const char *src)\n{\n\tchar *dst = parsed_info->password;\n\tunsigned int i = 0, j = 0;\n\n\twhile (src[i]) {\n\t\tif (src[i] == ',')\n\t\t\tdst[j++] = ',';\n\t\tdst[j++] = src[i++];\n\t\tif (j > sizeof(parsed_info->password)) {\n\t\t\tfprintf(stderr, \"Converted password too long!\\n\");\n\t\t\treturn EX_USAGE;\n\t\t}\n\t}\n\tdst[j] = '\\0';\n\tparsed_info->got_password = 1;\n\treturn 0;\n}\n\n#ifdef HAVE_LIBCAP_NG\nstatic int\ndrop_capabilities(int parent)\n{\n\tcapng_select_t set = CAPNG_SELECT_CAPS;\n\n\tcapng_setpid(getpid());\n\tcapng_clear(CAPNG_SELECT_BOTH);\n\tif (parent) {\n\t\tif (capng_updatev(CAPNG_ADD, CAPNG_PERMITTED, CAP_DAC_READ_SEARCH, CAP_DAC_OVERRIDE, -1)) {\n\t\t\tfprintf(stderr, \"Unable to update capability set.\\n\");\n\t\t\treturn EX_SYSERR;\n\t\t}\n\t\tif (capng_update(CAPNG_ADD, CAPNG_PERMITTED|CAPNG_EFFECTIVE, CAP_SYS_ADMIN)) {\n\t\t\tfprintf(stderr, \"Unable to update capability set.\\n\");\n\t\t\treturn EX_SYSERR;\n\t\t}\n\t} else {\n\t\tif (capng_update(CAPNG_ADD, CAPNG_PERMITTED, CAP_DAC_READ_SEARCH)) {\n\t\t\tfprintf(stderr, \"Unable to update capability set.\\n\");\n\t\t\treturn EX_SYSERR;\n\t\t}\n\t}\n\tif (capng_have_capability(CAPNG_EFFECTIVE, CAP_SETPCAP)) {\n\t\tset = CAPNG_SELECT_BOTH;\n\t}\n\tif (capng_apply(set)) {\n\t\tfprintf(stderr, \"Unable to apply new capability set.\\n\");\n\t\treturn EX_SYSERR;\n\t}\n\treturn 0;\n}\n\nstatic int\ntoggle_dac_capability(int writable, int enable)\n{\n\tunsigned int capability = writable ? CAP_DAC_OVERRIDE : CAP_DAC_READ_SEARCH;\n\n\tif (capng_update(enable ? CAPNG_ADD : CAPNG_DROP, CAPNG_EFFECTIVE, capability)) {\n\t\tfprintf(stderr, \"Unable to update capability set.\\n\");\n\t\treturn EX_SYSERR;\n\t}\n\tif (capng_apply(CAPNG_SELECT_CAPS)) {\n\t\tfprintf(stderr, \"Unable to apply new capability set.\\n\");\n\t\treturn EX_SYSERR;\n\t}\n\treturn 0;\n}\n#else /* HAVE_LIBCAP_NG */\n#ifdef HAVE_LIBCAP\n#ifdef HAVE_PRCTL\nstatic int\nprune_bounding_set(void)\n{\n\tint i, rc = 0;\n\tstatic int bounding_set_cleared;\n\n\tif (bounding_set_cleared)\n\t\treturn 0;\n\n\tfor (i = 0; i <= CAP_LAST_CAP && rc == 0; ++i)\n\t\trc = prctl(PR_CAPBSET_DROP, i);\n\n\tif (rc != 0) {\n\t\tfprintf(stderr, \"Unable to clear capability bounding set: %d\\n\", rc);\n\t\treturn EX_SYSERR;\n\t}\n\n\t++bounding_set_cleared;\n\treturn 0;\n}\n#else /* HAVE_PRCTL */\nstatic int\nprune_bounding_set(void)\n{\n\treturn 0;\n}\n#endif /* HAVE_PRCTL */\nstatic int\ndrop_capabilities(int parent)\n{\n\tint rc, ncaps;\n\tcap_t caps;\n\tcap_value_t cap_list[3];\n\n\trc = prune_bounding_set();\n\tif (rc)\n\t\treturn rc;\n\n\tcaps = cap_get_proc();\n\tif (caps == NULL) {\n\t\tfprintf(stderr, \"Unable to get current capability set: %s\\n\",\n\t\t\tstrerror(errno));\n\t\treturn EX_SYSERR;\n\t}\n\n\tif (cap_clear(caps) == -1) {\n\t\tfprintf(stderr, \"Unable to clear capability set: %s\\n\",\n\t\t\tstrerror(errno));\n\t\trc = EX_SYSERR;\n\t\tgoto free_caps;\n\t}\n\n\tif (parent || getuid() == 0) {\n\t\tncaps = 1;\n\t\tcap_list[0] = CAP_DAC_READ_SEARCH;\n\t\tif (parent) {\n\t\t\tcap_list[1] = CAP_DAC_OVERRIDE;\n\t\t\tcap_list[2] = CAP_SYS_ADMIN;\n\t\t\tncaps += 2;\n\t\t}\n\t\tif (cap_set_flag(caps, CAP_PERMITTED, ncaps, cap_list, CAP_SET) == -1) {\n\t\t\tfprintf(stderr, \"Unable to set permitted capabilities: %s\\n\",\n\t\t\t\tstrerror(errno));\n\t\t\trc = EX_SYSERR;\n\t\t\tgoto free_caps;\n\t\t}\n\t\tif (parent) {\n\t\t\tcap_list[0] = CAP_SYS_ADMIN;\n\t\t\tif (cap_set_flag(caps, CAP_EFFECTIVE, 1, cap_list, CAP_SET) == -1) {\n\t\t\t\tfprintf(stderr, \"Unable to set effective capabilities: %s\\n\",\n\t\t\t\t\tstrerror(errno));\n\t\t\t\trc = EX_SYSERR;\n\t\t\t\tgoto free_caps;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (cap_set_proc(caps) != 0) {\n\t\tfprintf(stderr, \"Unable to set current process capabilities: %s\\n\",\n\t\t\tstrerror(errno));\n\t\trc = EX_SYSERR;\n\t}\nfree_caps:\n\tcap_free(caps);\n\treturn rc;\n}\n\nstatic int\ntoggle_dac_capability(int writable, int enable)\n{\n\tint rc = 0;\n\tcap_t caps;\n\tcap_value_t capability = writable ? CAP_DAC_OVERRIDE : CAP_DAC_READ_SEARCH;\n\n\tcaps = cap_get_proc();\n\tif (caps == NULL) {\n\t\tfprintf(stderr, \"Unable to get current capability set: %s\\n\",\n\t\t\tstrerror(errno));\n\t\treturn EX_SYSERR;\n\t}\n\n\tif (cap_set_flag(caps, CAP_EFFECTIVE, 1, &capability,\n\t\t\t enable ? CAP_SET : CAP_CLEAR) == -1) {\n\t\tfprintf(stderr, \"Unable to %s effective capabilities: %s\\n\",\n\t\t\tenable ? \"set\" : \"clear\", strerror(errno));\n\t\trc = EX_SYSERR;\n\t\tgoto free_caps;\n\t}\n\n\tif (cap_set_proc(caps) != 0) {\n\t\tfprintf(stderr, \"Unable to set current process capabilities: %s\\n\",\n\t\t\tstrerror(errno));\n\t\trc = EX_SYSERR;\n\t}\nfree_caps:\n\tcap_free(caps);\n\treturn rc;\n}\n#else /* HAVE_LIBCAP */\nstatic int\ndrop_capabilities(int parent __attribute((unused)))\n{\n\treturn 0;\n}\n\nstatic int\ntoggle_dac_capability(int writable __attribute((unused)), int enable __attribute((unused)))\n{\n\treturn 0;\n}\n#endif /* HAVE_LIBCAP */\n#endif /* HAVE_LIBCAP_NG */\n\nstatic void null_terminate_endl(char *source)\n{\n\tchar *newline = strchr(source, '\\n');\n\tif (newline)\n\t\t*newline = '\\0';\n}\n\n/*\n * Parse a line from the credentials file.  Changes target to first\n * character after '=' on 'line' and returns the value type of the line\n * Returns CRED_UNPARSEABLE on failure or if either parameter is NULL.\n */\nstatic int parse_cred_line(char *line, char **target)\n{\n\tif (line == NULL || target == NULL)\n\t\tgoto parsing_err;\n\n\t/* position target at first char of value */\n\t*target = strchr(line, '=');\n\tif (!*target)\n\t\tgoto parsing_err;\n\t*target += 1;\n\n\t/* tell the caller which value target points to */\n\tif (strncasecmp(\"user\", line, 4) == 0)\n\t\treturn CRED_USER;\n\tif (strncasecmp(\"pass\", line, 4) == 0)\n\t\treturn CRED_PASS;\n\tif (strncasecmp(\"dom\", line, 3) == 0)\n\t\treturn CRED_DOM;\n\nparsing_err:\n\treturn CRED_UNPARSEABLE;\n}\n\nstatic int open_cred_file(char *file_name,\n\t\t\tstruct parsed_mount_info *parsed_info)\n{\n\tchar *line_buf = NULL;\n\tchar *temp_val = NULL;\n\tFILE *fs = NULL;\n\tint i;\n\tconst int line_buf_size = 4096;\n\tconst int min_non_white = 10;\n\n\ti = toggle_dac_capability(0, 1);\n\tif (i)\n\t\tgoto return_i;\n\n\ti = access(file_name, R_OK);\n\tif (i) {\n\t\ttoggle_dac_capability(0, 0);\n\t\ti = errno;\n\t\tgoto return_i;\n\t}\n\n\tfs = fopen(file_name, \"r\");\n\tif (fs == NULL) {\n\t\ttoggle_dac_capability(0, 0);\n\t\ti = errno;\n\t\tgoto return_i;\n\t}\n\n\ti = toggle_dac_capability(0, 0);\n\tif (i)\n\t\tgoto return_i;\n\n\tline_buf = (char *)malloc(line_buf_size);\n\tif (line_buf == NULL) {\n\t\ti = EX_SYSERR;\n\t\tgoto return_i;\n\t}\n\n\t/* parse line from credentials file */\n\twhile (fgets(line_buf, line_buf_size, fs)) {\n\t\t/* eat leading white space */\n\t\tfor (i = 0; i < line_buf_size - min_non_white + 1; i++) {\n\t\t\tif ((line_buf[i] != ' ') && (line_buf[i] != '\\t'))\n\t\t\t\tbreak;\n\t\t}\n\t\tnull_terminate_endl(line_buf);\n\n\t\t/* parse next token */\n\t\tswitch (parse_cred_line(line_buf + i, &temp_val)) {\n\t\tcase CRED_USER:\n\t\t\tstrlcpy(parsed_info->username, temp_val,\n\t\t\t\tsizeof(parsed_info->username));\n\t\t\tparsed_info->got_user = 1;\n\t\t\tbreak;\n\t\tcase CRED_PASS:\n\t\t\ti = set_password(parsed_info, temp_val);\n\t\t\tif (i)\n\t\t\t\tgoto return_i;\n\t\t\tbreak;\n\t\tcase CRED_DOM:\n\t\t\tstrlcpy(parsed_info->domain, temp_val,\n\t\t\t\tsizeof(parsed_info->domain));\n\t\t\tbreak;\n\t\tcase CRED_UNPARSEABLE:\n\t\t\tif (parsed_info->verboseflag)\n\t\t\t\tfprintf(stderr, \"Credential formatted \"\n\t\t\t\t\t\"incorrectly\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\ti = 0;\nreturn_i:\n\tif (fs != NULL)\n\t\tfclose(fs);\n\n\t/* make sure passwords are scrubbed from memory */\n\tif (line_buf != NULL)\n\t\tmemset(line_buf, 0, line_buf_size);\n\tfree(line_buf);\n\treturn i;\n}\n\nstatic int\nget_password_from_file(int file_descript, char *filename,\n\t\t       struct parsed_mount_info *parsed_info, const char *program)\n{\n\tint rc = 0;\n\tchar buf[sizeof(parsed_info->password) + 1];\n\n\tif (filename != NULL) {\n\t\trc = toggle_dac_capability(0, 1);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\trc = access(filename, R_OK);\n\t\tif (rc) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"%s failed: access check of %s failed: %s\\n\",\n\t\t\t\tprogram, filename, strerror(errno));\n\t\t\ttoggle_dac_capability(0, 0);\n\t\t\treturn EX_SYSERR;\n\t\t}\n\n\t\tfile_descript = open(filename, O_RDONLY);\n\t\tif (file_descript < 0) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"%s failed. %s attempting to open password file %s\\n\",\n\t\t\t\tprogram, strerror(errno), filename);\n\t\t\ttoggle_dac_capability(0, 0);\n\t\t\treturn EX_SYSERR;\n\t\t}\n\n\t\trc = toggle_dac_capability(0, 0);\n\t\tif (rc) {\n\t\t\trc = EX_SYSERR;\n\t\t\tgoto get_pw_exit;\n\t\t}\n\t}\n\n\tmemset(buf, 0, sizeof(buf));\n\trc = read(file_descript, buf, sizeof(buf) - 1);\n\tif (rc < 0) {\n\t\tfprintf(stderr,\n\t\t\t\"%s failed. Error %s reading password file\\n\",\n\t\t\tprogram, strerror(errno));\n\t\trc = EX_SYSERR;\n\t\tgoto get_pw_exit;\n\t}\n\n\trc = set_password(parsed_info, buf);\n\nget_pw_exit:\n\tif (filename != NULL)\n\t\tclose(file_descript);\n\treturn rc;\n}\n\n/*\n * Returns OPT_ERROR on unparsable token.\n */\nstatic int parse_opt_token(const char *token)\n{\n\tif (token == NULL)\n\t\treturn OPT_ERROR;\n\n\t/*\n\t * token is NULL terminated and contains exactly the\n\t * keyword so we can match exactly\n\t */\n\tif (strcmp(token, \"users\") == 0)\n\t\treturn OPT_USERS;\n\tif (strcmp(token, \"user_xattr\") == 0)\n\t\treturn OPT_USER_XATTR;\n\tif (strcmp(token, \"user\") == 0 ||\n\t\tstrcmp(token, \"username\") == 0)\n\t\treturn OPT_USER;\n\tif (strcmp(token, \"pass\") == 0 ||\n\t\tstrcmp(token, \"password\") == 0)\n\t\treturn OPT_PASS;\n\tif (strcmp(token, \"sec\") == 0)\n\t\treturn OPT_SEC;\n\tif (strcmp(token, \"ip\") == 0 ||\n\t\tstrcmp(token, \"addr\") == 0)\n\t\treturn OPT_IP;\n\tif (strcmp(token, \"unc\") == 0 ||\n\t\tstrcmp(token, \"target\") == 0 ||\n\t\tstrcmp(token, \"path\") == 0)\n\t\treturn OPT_UNC;\n\tif (strcmp(token, \"dom\") == 0 ||\n\t\tstrcmp(token, \"domain\") == 0 ||\n\t\tstrcmp(token, \"workgroup\") == 0)\n\t\treturn OPT_DOM;\n\tif (strcmp(token, \"cred\") == 0 || /* undocumented */\n\t\tstrcmp(token, \"credentials\") == 0)\n\t\treturn OPT_CRED;\n\tif (strcmp(token, \"uid\") == 0)\n\t\treturn OPT_UID;\n\tif (strcmp(token, \"cruid\") == 0)\n\t\treturn OPT_CRUID;\n\tif (strcmp(token, \"gid\") == 0)\n\t\treturn OPT_GID;\n\tif (strcmp(token, \"fmask\") == 0)\n\t\treturn OPT_FMASK;\n\tif (strcmp(token, \"file_mode\") == 0)\n\t\treturn OPT_FILE_MODE;\n\tif (strcmp(token, \"dmask\") == 0)\n\t\treturn OPT_DMASK;\n\tif (strcmp(token, \"dir_mode\") == 0 ||\n\t\tstrcmp(token, \"dirm\") == 0)\n\t\treturn OPT_DIR_MODE;\n\tif (strcmp(token, \"nosuid\") == 0)\n\t\treturn OPT_NO_SUID;\n\tif (strcmp(token, \"suid\") == 0)\n\t\treturn OPT_SUID;\n\tif (strcmp(token, \"nodev\") == 0)\n\t\treturn OPT_NO_DEV;\n\tif (strcmp(token, \"nobrl\") == 0 ||\n\t\tstrcmp(token, \"nolock\") == 0)\n\t\treturn OPT_NO_LOCK;\n\tif (strcmp(token, \"mand\") == 0)\n\t\treturn OPT_MAND;\n\tif (strcmp(token, \"nomand\") == 0)\n\t\treturn OPT_NOMAND;\n\tif (strcmp(token, \"dev\") == 0)\n\t\treturn OPT_DEV;\n\tif (strcmp(token, \"noexec\") == 0)\n\t\treturn OPT_NO_EXEC;\n\tif (strcmp(token, \"exec\") == 0)\n\t\treturn OPT_EXEC;\n\tif (strcmp(token, \"guest\") == 0)\n\t\treturn OPT_GUEST;\n\tif (strcmp(token, \"ro\") == 0)\n\t\treturn OPT_RO;\n\tif (strcmp(token, \"rw\") == 0)\n\t\treturn OPT_RW;\n\tif (strcmp(token, \"remount\") == 0)\n\t\treturn OPT_REMOUNT;\n\tif (strcmp(token, \"_netdev\") == 0)\n\t\treturn OPT_IGNORE;\n\tif (strcmp(token, \"backupuid\") == 0)\n\t\treturn OPT_BKUPUID;\n\tif (strcmp(token, \"backupgid\") == 0)\n\t\treturn OPT_BKUPGID;\n\tif (strcmp(token, \"nofail\") == 0)\n\t\treturn OPT_NOFAIL;\n\tif (strcmp(token, \"comment\") == 0)\n\t\treturn OPT_IGNORE;\n\tif (strncmp(token, \"x-\", 2) == 0)\n\t\treturn OPT_IGNORE;\n\tif (strncmp(token, \"snapshot\", 8) == 0)\n\t\treturn OPT_SNAPSHOT;\n\n\treturn OPT_ERROR;\n}\n\nstatic int\nparse_options(const char *data, struct parsed_mount_info *parsed_info)\n{\n\tchar *value = NULL;\n\tchar *equals = NULL;\n\tchar *next_keyword = NULL;\n\tchar *out = parsed_info->options;\n\tunsigned long *filesys_flags = &parsed_info->flags;\n\tint out_len = 0;\n\tint word_len;\n\tint rc = 0;\n\tint got_bkupuid = 0;\n\tint got_bkupgid = 0;\n\tint got_uid = 0;\n\tint got_cruid = 0;\n\tint got_gid = 0;\n\tint got_snapshot = 0;\n\tuid_t uid, cruid = 0, bkupuid = 0;\n\tgid_t gid, bkupgid = 0;\n\tchar *ep;\n\tstruct passwd *pw;\n\tstruct group *gr;\n\t/*\n\t * max 64-bit uint in decimal is 18446744073709551615 which is 20 chars\n\t * wide +1 for NULL, and +1 for good measure\n\t */\n\tchar txtbuf[22];\n\tunsigned long long snapshot;\n\tstruct tm tm;\n\n\t/* make sure we're starting from beginning */\n\tout[0] = '\\0';\n\n\t/* BB fixme check for separator override BB */\n\tuid = getuid();\n\tif (uid != 0)\n\t\tgot_uid = 1;\n\n\tgid = getgid();\n\tif (gid != 0)\n\t\tgot_gid = 1;\n\n\tif (!data)\n\t\treturn EX_USAGE;\n\n\t/*\n\t * format is keyword,keyword2=value2,keyword3=value3... \n\t * data  = next keyword\n\t * value = next value ie stuff after equal sign\n\t */\n\twhile (data && *data) {\n\t\tnext_keyword = strchr(data, ',');\t/* BB handle sep= */\n\n\t\t/* temporarily null terminate end of keyword=value pair */\n\t\tif (next_keyword)\n\t\t\t*next_keyword++ = 0;\n\n\t\t/* temporarily null terminate keyword if there's a value */\n\t\tvalue = NULL;\n\t\tif ((equals = strchr(data, '=')) != NULL) {\n\t\t\t*equals = '\\0';\n\t\t\tvalue = equals + 1;\n\t\t}\n\n\t\tswitch(parse_opt_token(data)) {\n\t\tcase OPT_USERS:\n\t\t\tif (!value || !*value) {\n\t\t\t\t*filesys_flags |= MS_USERS;\n\t\t\t\tgoto nocopy;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase OPT_USER:\n\t\t\tif (!value || !*value) {\n\t\t\t\tif (data[4] == '\\0') {\n\t\t\t\t\t*filesys_flags |= MS_USER;\n\t\t\t\t\tgoto nocopy;\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\t\"username specified with no parameter\\n\");\n\t\t\t\t\treturn EX_USAGE;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstrlcpy(parsed_info->username, value,\n\t\t\t\t\tsizeof(parsed_info->username));\n\t\t\t\tparsed_info->got_user = 1;\n\t\t\t\tgoto nocopy;\n\t\t\t}\n\n\t\tcase OPT_PASS:\n\t\t\tif (parsed_info->got_password) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"password specified twice, ignoring second\\n\");\n\t\t\t\tgoto nocopy;\n\t\t\t}\n\t\t\tif (!value || !*value) {\n\t\t\t\tparsed_info->got_password = 1;\n\t\t\t\tgoto nocopy;\n\t\t\t}\n\t\t\trc = set_password(parsed_info, value);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\tgoto nocopy;\n\n\t\tcase OPT_SEC:\n\t\t\tif (value) {\n\t\t\t\tif (!strncmp(value, \"none\", 4))\n\t\t\t\t\tparsed_info->got_password = 1;\n\t\t\t\tif (!strncmp(value, \"krb5\", 4)) {\n\t\t\t\t\tparsed_info->is_krb5 = 1;\n\t\t\t\t\tparsed_info->got_password = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase OPT_IP:\n\t\t\tif (!value || !*value) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"target ip address argument missing\\n\");\n\t\t\t} else if (strnlen(value, MAX_ADDRESS_LEN) <\n\t\t\t\tMAX_ADDRESS_LEN) {\n\t\t\t\tstrlcpy(parsed_info->addrlist, value,\n\t\t\t\t\tMAX_ADDRESS_LEN);\n\t\t\t\tif (parsed_info->verboseflag)\n\t\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\t\"ip address %s override specified\\n\",\n\t\t\t\t\t\tvalue);\n\t\t\t\tgoto nocopy;\n\t\t\t} else {\n\t\t\t\tfprintf(stderr, \"ip address too long\\n\");\n\t\t\t\treturn EX_USAGE;\n\n\t\t\t}\n\t\t\tbreak;\n\n\t\t/* unc || target || path */\n\t\tcase OPT_UNC:\n\t\t\tif (!value || !*value) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"invalid path to network resource\\n\");\n\t\t\t\treturn EX_USAGE;\n\t\t\t}\n\t\t\trc = parse_unc(value, parsed_info, thisprogram);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\tbreak;\n\n\t\t/* dom || workgroup */\n\t\tcase OPT_DOM:\n\t\t\tif (!value) {\n\t\t\t\t/*\n\t\t\t\t * An empty domain has been passed\n\t\t\t\t */\n\t\t\t\t/* not necessary but better safe than.. */\n\t\t\t\tparsed_info->domain[0] = '\\0';\n\t\t\t\tparsed_info->got_domain = 1;\n\t\t\t\tgoto nocopy;\n\t\t\t}\n\t\t\tif (strnlen(value, sizeof(parsed_info->domain)) >=\n\t\t\t    sizeof(parsed_info->domain)) {\n\t\t\t\tfprintf(stderr, \"domain name too long\\n\");\n\t\t\t\treturn EX_USAGE;\n\t\t\t}\n\t\t\tstrlcpy(parsed_info->domain, value,\n\t\t\t\tsizeof(parsed_info->domain));\n\t\t\tgoto nocopy;\n\n\t\tcase OPT_CRED:\n\t\t\tif (!value || !*value) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"invalid credential file name specified\\n\");\n\t\t\t\treturn EX_USAGE;\n\t\t\t}\n\t\t\trc = open_cred_file(value, parsed_info);\n\t\t\tif (rc) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"error %d (%s) opening credential file %s\\n\",\n\t\t\t\t\trc, strerror(rc), value);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t\tgoto nocopy;\n\n\t\tcase OPT_UID:\n\t\t\tif (!value || !*value)\n\t\t\t\tgoto nocopy;\n\n\t\t\tgot_uid = 1;\n\t\t\tpw = getpwnam(value);\n\t\t\tif (pw) {\n\t\t\t\tuid = pw->pw_uid;\n\t\t\t\tgoto nocopy;\n\t\t\t}\n\n\t\t\terrno = 0;\n\t\t\tuid = strtoul(value, &ep, 10);\n\t\t\tif (errno == 0 && *ep == '\\0')\n\t\t\t\tgoto nocopy;\n\n\t\t\tfprintf(stderr, \"bad option uid=\\\"%s\\\"\\n\", value);\n\t\t\treturn EX_USAGE;\n\t\tcase OPT_CRUID:\n\t\t\tif (!value || !*value)\n\t\t\t\tgoto nocopy;\n\n\t\t\tgot_cruid = 1;\n\t\t\tpw = getpwnam(value);\n\t\t\tif (pw) {\n\t\t\t\tcruid = pw->pw_uid;\n\t\t\t\tgoto nocopy;\n\t\t\t}\n\n\t\t\terrno = 0;\n\t\t\tcruid = strtoul(value, &ep, 10);\n\t\t\tif (errno == 0 && *ep == '\\0')\n\t\t\t\tgoto nocopy;\n\n\t\t\tfprintf(stderr, \"bad option: cruid=\\\"%s\\\"\\n\", value);\n\t\t\treturn EX_USAGE;\n\t\tcase OPT_GID:\n\t\t\tif (!value || !*value)\n\t\t\t\tgoto nocopy;\n\n\t\t\tgot_gid = 1;\n\t\t\tgr = getgrnam(value);\n\t\t\tif (gr) {\n\t\t\t\tgid = gr->gr_gid;\n\t\t\t\tgoto nocopy;\n\t\t\t}\n\n\t\t\terrno = 0;\n\t\t\tgid = strtoul(value, &ep, 10);\n\t\t\tif (errno == 0 && *ep == '\\0')\n\t\t\t\tgoto nocopy;\n\n\t\t\tfprintf(stderr, \"bad option: gid=\\\"%s\\\"\\n\", value);\n\t\t\treturn EX_USAGE;\n\t\t/* fmask falls through to file_mode */\n\t\tcase OPT_FMASK:\n\t\t\tfprintf(stderr,\n\t\t\t\t\"WARNING: CIFS mount option 'fmask' is\\\n\t\t\t\t deprecated. Use 'file_mode' instead.\\n\");\n\t\t\tdata = \"file_mode\";\t/* BB fix this */\n\t\t\t/* Fallthrough */\n\t\tcase OPT_FILE_MODE:\n\t\t\tif (!value || !*value) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"Option '%s' requires a numerical argument\\n\",\n\t\t\t\t\tdata);\n\t\t\t\treturn EX_USAGE;\n\t\t\t}\n\n\t\t\tif (value[0] != '0')\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"WARNING: '%s' not expressed in octal.\\n\",\n\t\t\t\t\tdata);\n\t\t\tbreak;\n\n\t\t/* dmask falls through to dir_mode */\n\t\tcase OPT_DMASK:\n\t\t\tfprintf(stderr,\n\t\t\t\t\"WARNING: CIFS mount option 'dmask' is\\\n\t\t\t\t deprecated. Use 'dir_mode' instead.\\n\");\n\t\t\tdata = \"dir_mode\";\n\t\t\t/* Fallthrough */\n\t\tcase OPT_DIR_MODE:\n\t\t\tif (!value || !*value) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"Option '%s' requires a numerical argument\\n\",\n\t\t\t\t\tdata);\n\t\t\t\treturn EX_USAGE;\n\t\t\t}\n\n\t\t\tif (value[0] != '0')\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"WARNING: '%s' not expressed in octal.\\n\",\n\t\t\t\t\tdata);\n\t\t\tbreak;\n\t\tcase OPT_NO_SUID:\n\t\t\t*filesys_flags |= MS_NOSUID;\n\t\t\tgoto nocopy;\n\t\tcase OPT_SUID:\n\t\t\t*filesys_flags &= ~MS_NOSUID;\n\t\t\tgoto nocopy;\n\t\tcase OPT_NO_DEV:\n\t\t\t*filesys_flags |= MS_NODEV;\n\t\t\tgoto nocopy;\n\t\tcase OPT_NO_LOCK:\n\t\t\t*filesys_flags &= ~MS_MANDLOCK;\n\t\t\tbreak;\n\t\tcase OPT_MAND:\n\t\t\t*filesys_flags |= MS_MANDLOCK;\n\t\t\tgoto nocopy;\n\t\tcase OPT_NOMAND:\n\t\t\t*filesys_flags &= ~MS_MANDLOCK;\n\t\t\tgoto nocopy;\n\t\tcase OPT_DEV:\n\t\t\t*filesys_flags &= ~MS_NODEV;\n\t\t\tgoto nocopy;\n\t\tcase OPT_NO_EXEC:\n\t\t\t*filesys_flags |= MS_NOEXEC;\n\t\t\tgoto nocopy;\n\t\tcase OPT_EXEC:\n\t\t\t*filesys_flags &= ~MS_NOEXEC;\n\t\t\tgoto nocopy;\n\t\tcase OPT_GUEST:\n\t\t\tparsed_info->got_user = 1;\n\t\t\tparsed_info->got_password = 1;\n\t\t\tgoto nocopy;\n\t\tcase OPT_RO:\n\t\t\t*filesys_flags |= MS_RDONLY;\n\t\t\tgoto nocopy;\n\t\tcase OPT_RW:\n\t\t\t*filesys_flags &= ~MS_RDONLY;\n\t\t\tgoto nocopy;\n\t\tcase OPT_REMOUNT:\n\t\t\t*filesys_flags |= MS_REMOUNT;\n\t\t\tgoto nocopy;\n\t\tcase OPT_IGNORE:\n\t\t\tgoto nocopy;\n\t\tcase OPT_BKUPUID:\n\t\t\tif (!value || !*value)\n\t\t\t\tgoto nocopy;\n\n\t\t\tgot_bkupuid = 1;\n\t\t\terrno = 0;\n\t\t\tbkupuid = strtoul(value, &ep, 10);\n\t\t\tif (errno == 0 && *ep == '\\0')\n\t\t\t\tgoto nocopy;\n\n\t\t\tpw = getpwnam(value);\n\t\t\tif (pw == NULL) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"bad user name \\\"%s\\\"\\n\", value);\n\t\t\t\treturn EX_USAGE;\n\t\t\t}\n\n\t\t\tbkupuid = pw->pw_uid;\n\t\t\tgoto nocopy;\n\t\tcase OPT_BKUPGID:\n\t\t\tif (!value || !*value)\n\t\t\t\tgoto nocopy;\n\n\t\t\tgot_bkupgid = 1;\n\t\t\terrno = 0;\n\t\t\tbkupgid = strtoul(value, &ep, 10);\n\t\t\tif (errno == 0 && *ep == '\\0')\n\t\t\t\tgoto nocopy;\n\n\t\t\tgr = getgrnam(value);\n\t\t\tif (gr == NULL) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"bad group name \\\"%s\\\"\\n\", value);\n\t\t\t\treturn EX_USAGE;\n\t\t\t}\n\n\t\t\tbkupgid = gr->gr_gid;\n\t\t\tgoto nocopy;\n\t\tcase OPT_NOFAIL:\n\t\t\tparsed_info->nofail = 1;\n\t\t\tgoto nocopy;\n\t\tcase OPT_SNAPSHOT:\n\t\t\tif (!value || !*value)\n\t\t\t\tgoto nocopy;\n\t\t\tif (strncmp(value, \"@GMT-\", 5))\n\t\t\t\tbreak;\n\t\t\tif ((strlen(value) != GMT_NAME_LEN) ||\n\t\t\t    (strptime(value, GMT_FORMAT, &tm) == NULL)) {\n\t\t\t\tfprintf(stderr, \"bad snapshot token\\n\");\n\t\t\t\treturn EX_USAGE;\n\t\t\t}\n\t\t\tsnapshot = timegm(&tm) * 10000000 + NTFS_TIME_OFFSET;\n\t\t\tgot_snapshot = 1;\n\t\t\tgoto nocopy;\n\t\t}\n\n\t\t/* check size before copying option to buffer */\n\t\tword_len = strlen(data);\n\t\tif (value)\n\t\t\tword_len += 1 + strlen(value);\n\n\t\t/* need 2 extra bytes for comma and null byte */\n\t\tif (out_len + word_len + 2 > MAX_OPTIONS_LEN) {\n\t\t\tfprintf(stderr, \"Options string too long\\n\");\n\t\t\treturn EX_USAGE;\n\t\t}\n\n\t\t/* put back equals sign, if any */\n\t\tif (equals)\n\t\t\t*equals = '=';\n\n\t\t/* go ahead and copy */\n\t\tif (out_len)\n\t\t\tstrlcat(out, \",\", MAX_OPTIONS_LEN);\n\n\t\tstrlcat(out, data, MAX_OPTIONS_LEN);\n\t\tout_len = strlen(out);\nnocopy:\n\t\tdata = next_keyword;\n\t}\n\n\n\t/* special-case the uid and gid */\n\tif (got_uid) {\n\t\tword_len = snprintf(txtbuf, sizeof(txtbuf), \"%u\", uid);\n\n\t\t/* comma + \"uid=\" + terminating NULL == 6 */\n\t\tif (out_len + word_len + 6 > MAX_OPTIONS_LEN) {\n\t\t\tfprintf(stderr, \"Options string too long\\n\");\n\t\t\treturn EX_USAGE;\n\t\t}\n\n\t\tif (out_len) {\n\t\t\tstrlcat(out, \",\", MAX_OPTIONS_LEN);\n\t\t\tout_len++;\n\t\t}\n\t\tsnprintf(out + out_len, word_len + 5, \"uid=%s\", txtbuf);\n\t\tout_len = strlen(out);\n\t}\n\tif (parsed_info->is_krb5 && parsed_info->sudo_uid) {\n\t\tcruid = parsed_info->sudo_uid;\n\t\tgot_cruid = 1;\n\t}\n\tif (got_cruid) {\n\t\tword_len = snprintf(txtbuf, sizeof(txtbuf), \"%u\", cruid);\n\n\t\t/* comma + \"cruid=\" + terminating NULL == 8 */\n\t\tif (out_len + word_len + 8 > MAX_OPTIONS_LEN) {\n\t\t\tfprintf(stderr, \"Options string too long\\n\");\n\t\t\treturn EX_USAGE;\n\t\t}\n\n\t\tif (out_len) {\n\t\t\tstrlcat(out, \",\", MAX_OPTIONS_LEN);\n\t\t\tout_len++;\n\t\t}\n\t\tsnprintf(out + out_len, word_len + 7, \"cruid=%s\", txtbuf);\n\t\tout_len = strlen(out);\n\t}\n\tif (got_gid) {\n\t\tword_len = snprintf(txtbuf, sizeof(txtbuf), \"%u\", gid);\n\n\t\t/* comma + \"gid=\" + terminating NULL == 6 */\n\t\tif (out_len + word_len + 6 > MAX_OPTIONS_LEN) {\n\t\t\tfprintf(stderr, \"Options string too long\\n\");\n\t\t\treturn EX_USAGE;\n\t\t}\n\n\t\tif (out_len) {\n\t\t\tstrlcat(out, \",\", MAX_OPTIONS_LEN);\n\t\t\tout_len++;\n\t\t}\n\t\tsnprintf(out + out_len, word_len + 5, \"gid=%s\", txtbuf);\n\t\tout_len = strlen(out);\n\t}\n\tif (got_bkupuid) {\n\t\tword_len = snprintf(txtbuf, sizeof(txtbuf), \"%u\", bkupuid);\n\n\t\t/* comma + \"backupuid=\" + terminating NULL == 12 */\n\t\tif (out_len + word_len + 12 > MAX_OPTIONS_LEN) {\n\t\t\tfprintf(stderr, \"Options string too long\\n\");\n\t\t\treturn EX_USAGE;\n\t\t}\n\n\t\tif (out_len) {\n\t\t\tstrlcat(out, \",\", MAX_OPTIONS_LEN);\n\t\t\tout_len++;\n\t\t}\n\t\tsnprintf(out + out_len, word_len + 11, \"backupuid=%s\", txtbuf);\n\t\tout_len = strlen(out);\n\t}\n\tif (got_bkupgid) {\n\t\tword_len = snprintf(txtbuf, sizeof(txtbuf), \"%u\", bkupgid);\n\n\t\t/* comma + \"backupgid=\" + terminating NULL == 12 */\n\t\tif (out_len + word_len + 12 > MAX_OPTIONS_LEN) {\n\t\t\tfprintf(stderr, \"Options string too long\\n\");\n\t\t\treturn EX_USAGE;\n\t\t}\n\n\t\tif (out_len) {\n\t\t\tstrlcat(out, \",\", MAX_OPTIONS_LEN);\n\t\t\tout_len++;\n\t\t}\n\t\tsnprintf(out + out_len, word_len + 11, \"backupgid=%s\", txtbuf);\n\t\tout_len = strlen(out);\n\t}\n\tif (got_snapshot) {\n\t\tword_len = snprintf(txtbuf, sizeof(txtbuf), \"%llu\", snapshot);\n\n\t\t/* comma + \"snapshot=\" + terminating NULL == 11 */\n\t\tif (out_len + word_len + 11 > MAX_OPTIONS_LEN) {\n\t\t\tfprintf(stderr, \"Options string too long\\n\");\n\t\t\treturn EX_USAGE;\n\t\t}\n\n\t\tif (out_len) {\n\t\t\tstrlcat(out, \",\", MAX_OPTIONS_LEN);\n\t\t\tout_len++;\n\t\t}\n\t\tsnprintf(out + out_len, word_len + 10, \"snapshot=%s\", txtbuf);\n\t\tout_len = strlen(out);\n\t}\n\n\treturn 0;\n}\n\nstatic int parse_unc(const char *unc_name, struct parsed_mount_info *parsed_info, const char *progname)\n{\n\tint length = strnlen(unc_name, MAX_UNC_LEN);\n\tconst char *host, *share, *prepath;\n\tsize_t hostlen, sharelen, prepathlen;\n\n\tif (length > (MAX_UNC_LEN - 1)) {\n\t\tfprintf(stderr, \"mount error: UNC name too long\\n\");\n\t\treturn EX_USAGE;\n\t}\n\n\tif (length < 3) {\n\t\tfprintf(stderr, \"mount error: UNC name too short\\n\");\n\t\treturn EX_USAGE;\n\t}\n\n\tif ((strncasecmp(\"cifs://\", unc_name, 7) == 0) ||\n\t    (strncasecmp(\"smb://\", unc_name, 6) == 0)) {\n\t\tfprintf(stderr,\n\t\t\t\"Mounting cifs URL not implemented yet. Attempt to mount %s\\n\",\n\t\t\tunc_name);\n\t\treturn EX_USAGE;\n\t}\n\n\tif (strncmp(unc_name, \"//\", 2) && strncmp(unc_name, \"\\\\\\\\\", 2)) {\n\t\tfprintf(stderr, \"%s: bad UNC (%s)\\n\", progname, unc_name);\n\t\treturn EX_USAGE;\n\t}\n\n\thost = unc_name + 2;\n\thostlen = strcspn(host, \"/\\\\\");\n\tif (!hostlen) {\n\t\tfprintf(stderr, \"%s: bad UNC (%s)\\n\", progname, unc_name);\n\t\treturn EX_USAGE;\n\t}\n\tshare = host + hostlen + 1;\n\n\tif (hostlen + 1 > sizeof(parsed_info->host)) {\n\t\tfprintf(stderr, \"%s: host portion of UNC too long\\n\", progname);\n\t\treturn EX_USAGE;\n\t}\n\n\tsharelen = strcspn(share, \"/\\\\\");\n\tif (sharelen + 1 > sizeof(parsed_info->share)) {\n\t\tfprintf(stderr, \"%s: share portion of UNC too long\\n\", progname);\n\t\treturn EX_USAGE;\n\t}\n\n\tprepath = share + sharelen;\n\tif (*prepath != '\\0')\n\t\tprepath++;\n\n\tprepathlen = strlen(prepath);\n\n\tif (prepathlen + 1 > sizeof(parsed_info->prefix)) {\n\t\tfprintf(stderr, \"%s: UNC prefixpath too long\\n\", progname);\n\t\treturn EX_USAGE;\n\t}\n\n\t/* copy pieces into their resepective buffers */\n\tmemcpy(parsed_info->host, host, hostlen);\n\tmemcpy(parsed_info->share, share, sharelen);\n\tmemcpy(parsed_info->prefix, prepath, prepathlen);\n\n\treturn 0;\n}\n\nstatic int get_pw_from_env(struct parsed_mount_info *parsed_info, const char *program)\n{\n\tint rc = 0;\n\n\tif (getenv(\"PASSWD\"))\n\t\trc = set_password(parsed_info, getenv(\"PASSWD\"));\n\telse if (getenv(\"PASSWD_FD\"))\n\t\trc = get_password_from_file(atoi(getenv(\"PASSWD_FD\")), NULL,\n\t\t\t\t\t    parsed_info, program);\n\telse if (getenv(\"PASSWD_FILE\"))\n\t\trc = get_password_from_file(0, getenv(\"PASSWD_FILE\"),\n\t\t\t\t\t    parsed_info, program);\n\n\treturn rc;\n}\n\nstatic struct option longopts[] = {\n\t{\"all\", 0, NULL, 'a'},\n\t{\"help\", 0, NULL, 'h'},\n\t{\"move\", 0, NULL, 'm'},\n\t{\"bind\", 0, NULL, 'b'},\n\t{\"read-only\", 0, NULL, 'r'},\n\t{\"ro\", 0, NULL, 'r'},\n\t{\"verbose\", 0, NULL, 'v'},\n\t{\"version\", 0, NULL, 'V'},\n\t{\"read-write\", 0, NULL, 'w'},\n\t{\"rw\", 0, NULL, 'w'},\n\t{\"options\", 1, NULL, 'o'},\n\t{\"type\", 1, NULL, 't'},\n\t{\"uid\", 1, NULL, '1'},\n\t{\"gid\", 1, NULL, '2'},\n\t{\"user\", 1, NULL, 'u'},\n\t{\"username\", 1, NULL, 'u'},\n\t{\"dom\", 1, NULL, 'd'},\n\t{\"domain\", 1, NULL, 'd'},\n\t{\"password\", 1, NULL, 'p'},\n\t{\"pass\", 1, NULL, 'p'},\n\t{\"credentials\", 1, NULL, 'c'},\n\t{\"port\", 1, NULL, 'P'},\n\t{\"sloppy\", 0, NULL, 's'},\n\t{NULL, 0, NULL, 0}\n};\n\n/* convert a string to uppercase. return false if the string\n * wasn't ASCII. Return success on a NULL ptr */\nstatic int uppercase_string(char *string)\n{\n\tif (!string)\n\t\treturn 1;\n\n\twhile (*string) {\n\t\t/* check for unicode */\n\t\tif ((unsigned char)string[0] & 0x80)\n\t\t\treturn 0;\n\t\t*string = toupper((unsigned char)*string);\n\t\tstring++;\n\t}\n\n\treturn 1;\n}\n\nstatic void print_cifs_mount_version(const char *progname)\n{\n\tprintf(\"%s version: %s\\n\", progname, VERSION);\n}\n\n/*\n * This function borrowed from fuse-utils...\n *\n * glibc's addmntent (at least as of 2.10 or so) doesn't properly encode\n * newlines embedded within the text fields. To make sure no one corrupts\n * the mtab, fail the mount if there are embedded newlines.\n */\nstatic int check_newline(const char *progname, const char *name)\n{\n\tconst char *s;\n\tfor (s = \"\\n\"; *s; s++) {\n\t\tif (strchr(name, *s)) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"%s: illegal character 0x%02x in mount entry\\n\",\n\t\t\t\tprogname, *s);\n\t\t\treturn EX_USAGE;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int check_mtab(const char *progname, const char *devname,\n\t\t      const char *dir)\n{\n\tif (check_newline(progname, devname) || check_newline(progname, dir))\n\t\treturn EX_USAGE;\n\treturn 0;\n}\n\nstatic int\nadd_mtab(char *devname, char *mountpoint, unsigned long flags, const char *fstype)\n{\n\tint rc = 0, tmprc, fd;\n\tuid_t uid;\n\tchar *mount_user = NULL;\n\tstruct mntent mountent;\n\tstruct stat statbuf;\n\tFILE *pmntfile;\n\tsigset_t mask, oldmask;\n\n\tuid = getuid();\n\tif (uid != 0)\n\t\tmount_user = getusername(uid);\n\n\t/*\n\t * Set the real uid to the effective uid. This prevents unprivileged\n\t * users from sending signals to this process, though ^c on controlling\n\t * terminal should still work.\n\t */\n\trc = setreuid(geteuid(), -1);\n\tif (rc != 0) {\n\t\tfprintf(stderr, \"Unable to set real uid to effective uid: %s\\n\",\n\t\t\t\tstrerror(errno));\n\t\treturn EX_FILEIO;\n\t}\n\n\trc = sigfillset(&mask);\n\tif (rc) {\n\t\tfprintf(stderr, \"Unable to set filled signal mask\\n\");\n\t\treturn EX_FILEIO;\n\t}\n\n\trc = sigprocmask(SIG_SETMASK, &mask, &oldmask);\n\tif (rc) {\n\t\tfprintf(stderr, \"Unable to make process ignore signals\\n\");\n\t\treturn EX_FILEIO;\n\t}\n\n\trc = toggle_dac_capability(1, 1);\n\tif (rc)\n\t\treturn EX_FILEIO;\n\n\tatexit(unlock_mtab);\n\trc = lock_mtab();\n\tif (rc) {\n\t\tfprintf(stderr, \"cannot lock mtab\");\n\t\trc = EX_FILEIO;\n\t\tgoto add_mtab_exit;\n\t}\n\n\tpmntfile = setmntent(MOUNTED, \"a+\");\n\tif (!pmntfile) {\n\t\tfprintf(stderr, \"could not update mount table\\n\");\n\t\tunlock_mtab();\n\t\trc = EX_FILEIO;\n\t\tgoto add_mtab_exit;\n\t}\n\n\tfd = fileno(pmntfile);\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"mntent does not appear to be valid\\n\");\n\t\tunlock_mtab();\n\t\trc = EX_FILEIO;\n\t\tgoto add_mtab_exit;\n\t}\n\n\trc = fstat(fd, &statbuf);\n\tif (rc != 0) {\n\t\tfprintf(stderr, \"unable to fstat open mtab\\n\");\n\t\tendmntent(pmntfile);\n\t\tunlock_mtab();\n\t\trc = EX_FILEIO;\n\t\tgoto add_mtab_exit;\n\t}\n\n\tmountent.mnt_fsname = devname;\n\tmountent.mnt_dir = mountpoint;\n\tmountent.mnt_type = (char *)(void *)fstype;\n\tmountent.mnt_opts = (char *)calloc(MTAB_OPTIONS_LEN, 1);\n\tif (mountent.mnt_opts) {\n\t\tif (flags & MS_RDONLY)\n\t\t\tstrlcat(mountent.mnt_opts, \"ro\", MTAB_OPTIONS_LEN);\n\t\telse\n\t\t\tstrlcat(mountent.mnt_opts, \"rw\", MTAB_OPTIONS_LEN);\n\n\t\tif (flags & MS_MANDLOCK)\n\t\t\tstrlcat(mountent.mnt_opts, \",mand\", MTAB_OPTIONS_LEN);\n\t\tif (flags & MS_NOEXEC)\n\t\t\tstrlcat(mountent.mnt_opts, \",noexec\", MTAB_OPTIONS_LEN);\n\t\tif (flags & MS_NOSUID)\n\t\t\tstrlcat(mountent.mnt_opts, \",nosuid\", MTAB_OPTIONS_LEN);\n\t\tif (flags & MS_NODEV)\n\t\t\tstrlcat(mountent.mnt_opts, \",nodev\", MTAB_OPTIONS_LEN);\n\t\tif (flags & MS_SYNCHRONOUS)\n\t\t\tstrlcat(mountent.mnt_opts, \",sync\", MTAB_OPTIONS_LEN);\n\t\tif (mount_user) {\n\t\t\tstrlcat(mountent.mnt_opts, \",user=\", MTAB_OPTIONS_LEN);\n\t\t\tstrlcat(mountent.mnt_opts, mount_user,\n\t\t\t\tMTAB_OPTIONS_LEN);\n\t\t}\n\t}\n\tmountent.mnt_freq = 0;\n\tmountent.mnt_passno = 0;\n\trc = addmntent(pmntfile, &mountent);\n\tif (rc) {\n\t\tint ignore __attribute__((unused));\n\n\t\tfprintf(stderr, \"unable to add mount entry to mtab\\n\");\n\t\tignore = ftruncate(fd, statbuf.st_size);\n\t\trc = EX_FILEIO;\n\t}\n\ttmprc = my_endmntent(pmntfile, statbuf.st_size);\n\tif (tmprc) {\n\t\tfprintf(stderr, \"error %d detected on close of mtab\\n\", tmprc);\n\t\trc = EX_FILEIO;\n\t}\n\tunlock_mtab();\n\tfree(mountent.mnt_opts);\nadd_mtab_exit:\n\ttoggle_dac_capability(1, 0);\n\tsigprocmask(SIG_SETMASK, &oldmask, NULL);\n\n\treturn rc;\n}\n\nstatic int\ndel_mtab(char *mountpoint)\n{\n\tint len, tmprc, rc = 0;\n\tFILE *mnttmp, *mntmtab;\n\tstruct mntent *mountent;\n\tchar *mtabfile, *mtabdir, *mtabtmpfile = NULL;\n\n\tmtabfile = strdup(MOUNTED);\n\tif (!mtabfile) {\n\t\tfprintf(stderr, \"del_mtab: cannot strdup MOUNTED\\n\");\n\t\trc = EX_FILEIO;\n\t\tgoto del_mtab_exit;\n\t}\n\n\tmtabdir = dirname(mtabfile);\n\tlen = strlen(mtabdir) + strlen(MNT_TMP_FILE);\n\tmtabtmpfile = malloc(len + 1);\n\tif (!mtabtmpfile) {\n\t\tfprintf(stderr, \"del_mtab: cannot allocate memory to tmp file\\n\");\n\t\trc = EX_FILEIO;\n\t\tgoto del_mtab_exit;\n\t}\n\n\tif (sprintf(mtabtmpfile, \"%s%s\", mtabdir, MNT_TMP_FILE) != len) {\n\t\tfprintf(stderr, \"del_mtab: error writing new string\\n\");\n\t\trc = EX_FILEIO;\n\t\tgoto del_mtab_exit;\n\t}\n\n\tatexit(unlock_mtab);\n\trc = lock_mtab();\n\tif (rc) {\n\t\tfprintf(stderr, \"del_mtab: cannot lock mtab\\n\");\n\t\trc = EX_FILEIO;\n\t\tgoto del_mtab_exit;\n\t}\n\n\tmtabtmpfile = mktemp(mtabtmpfile);\n\tif (!mtabtmpfile) {\n\t\tfprintf(stderr, \"del_mtab: cannot setup tmp file destination\\n\");\n\t\trc = EX_FILEIO;\n\t\tgoto del_mtab_exit;\n\t}\n\n\tmntmtab = setmntent(MOUNTED, \"r\");\n\tif (!mntmtab) {\n\t\tfprintf(stderr, \"del_mtab: could not update mount table\\n\");\n\t\trc = EX_FILEIO;\n\t\tgoto del_mtab_exit;\n\t}\n\n\tmnttmp = setmntent(mtabtmpfile, \"w\");\n\tif (!mnttmp) {\n\t\tfprintf(stderr, \"del_mtab: could not update mount table\\n\");\n\t\tendmntent(mntmtab);\n\t\trc = EX_FILEIO;\n\t\tgoto del_mtab_exit;\n\t}\n\n\twhile ((mountent = getmntent(mntmtab)) != NULL) {\n\t\tif (!strcmp(mountent->mnt_dir, mountpoint))\n\t\t\tcontinue;\n\t\trc = addmntent(mnttmp, mountent);\n\t\tif (rc) {\n\t\t\tfprintf(stderr, \"del_mtab: unable to add mount entry to mtab\\n\");\n\t\t\trc = EX_FILEIO;\n\t\t\tgoto del_mtab_error;\n\t\t}\n\t}\n\n\tendmntent(mntmtab);\n\n\ttmprc = my_endmntent(mnttmp, 0);\n\tif (tmprc) {\n\t\tfprintf(stderr, \"del_mtab: error %d detected on close of tmp file\\n\", tmprc);\n\t\trc = EX_FILEIO;\n\t\tgoto del_mtab_error;\n\t}\n\n\tif (rename(mtabtmpfile, MOUNTED)) {\n\t\tfprintf(stderr, \"del_mtab: error %d when renaming mtab in place\\n\", errno);\n\t\trc = EX_FILEIO;\n\t\tgoto del_mtab_error;\n\t}\n\ndel_mtab_exit:\n\tunlock_mtab();\n\tfree(mtabtmpfile);\n\tfree(mtabfile);\n\treturn rc;\n\ndel_mtab_error:\n\tif (unlink(mtabtmpfile))\n\t\tfprintf(stderr, \"del_mtab: failed to delete tmp file - %s\\n\",\n\t\t\t\tstrerror(errno));\n\tgoto del_mtab_exit;\n}\n\n/* have the child drop root privileges */\nstatic int\ndrop_child_privs(void)\n{\n\tint rc;\n\tuid_t uid = getuid();\n\tgid_t gid = getgid();\n\n\tif (gid) {\n\t\trc = setgid(gid);\n\t\tif (rc) {\n\t\t\tfprintf(stderr, \"Unable set group identity: %s\\n\",\n\t\t\t\t\tstrerror(errno));\n\t\t\treturn EX_SYSERR;\n\t\t}\n\t}\n\tif (uid) {\n\t\trc = setuid(uid);\n\t\tif (rc) {\n\t\t\tfprintf(stderr, \"Unable set user identity: %s\\n\",\n\t\t\t\t\tstrerror(errno));\n\t\t\treturn EX_SYSERR;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n#ifdef ENABLE_SYSTEMD\nstatic int get_passwd_by_systemd(const char *prompt, char *input, int capacity)\n{\n\tint fd[2];\n\tpid_t pid;\n\tint offs = 0;\n\tint rc = 1;\n\n\tif (pipe(fd) == -1) {\n\t\tfprintf(stderr, \"Failed to create pipe: %s\\n\", strerror(errno));\n\t\treturn 1;\n\t}\n\n\tpid = fork();\n\tif (pid == -1) {\n\t\tfprintf(stderr, \"Unable to fork: %s\\n\", strerror(errno));\n\t\tclose(fd[0]);\n\t\tclose(fd[1]);\n\t\treturn 1;\n\t}\n\tif (pid == 0) {\n\t\tclose(fd[0]);\n\t\tdup2(fd[1], STDOUT_FILENO);\n\t\tif (execlp(\"systemd-ask-password\", \"systemd-ask-password\", prompt, NULL) == -1) {\n\t\t\tfprintf(stderr, \"Failed to execute systemd-ask-password: %s\\n\",\n\t\t\t\tstrerror(errno));\n\t\t}\n\t\texit(1);\n\t}\n\n\tclose(fd[1]);\n\tfor (;;) {\n\t\tif (offs+1 >= capacity) {\n\t\t\tfprintf(stderr, \"Password too long.\\n\");\n\t\t\tkill(pid, SIGTERM);\n\t\t\trc = 1;\n\t\t\tbreak;\n\t\t}\n\t\trc = read(fd[0], input + offs, capacity - offs);\n\t\tif (rc == -1) {\n\t\t\tfprintf(stderr, \"Failed to read from pipe: %s\\n\", strerror(errno));\n\t\t\trc = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (!rc)\n\t\t\tbreak;\n\t\toffs += rc;\n\t\tinput[offs] = '\\0';\n\t}\n\tif (wait(&rc) == -1) {\n\t\tfprintf(stderr, \"Failed to wait child: %s\\n\", strerror(errno));\n\t\trc = 1;\n\t\tgoto out;\n\t}\n\tif (!WIFEXITED(rc) || WEXITSTATUS(rc)) {\n\t\trc = 1;\n\t\tgoto out;\n\t}\n\n\trc = 0;\n\nout:\n\tclose(fd[0]);\n\treturn rc;\n}\n#endif\n\n/*\n * If systemd is running and systemd-ask-password --\n * is available, then use that else fallback on getpass(..)\n *\n * Returns: @input or NULL on error\n */\nstatic char*\nget_password(const char *prompt, char *input, int capacity)\n{\n#ifdef ENABLE_SYSTEMD\n\tint is_systemd_running;\n\tstruct stat a, b;\n\n\tmemset(input, 0, capacity);\n\n\t/* We simply test whether the systemd cgroup hierarchy is\n\t * mounted */\n\tis_systemd_running = (lstat(\"/sys/fs/cgroup\", &a) == 0)\n\t\t&& (lstat(\"/sys/fs/cgroup/systemd\", &b) == 0)\n\t\t&& (a.st_dev != b.st_dev);\n\n\tif (is_systemd_running && !get_passwd_by_systemd(prompt, input, capacity)) {\n\t\tint len = strlen(input);\n\t\tif (input[len - 1] == '\\n')\n\t\t\tinput[len - 1] = '\\0';\n\t\treturn input;\n\t}\n#endif\n\tmemset(input, 0, capacity);\n\n\t/*\n\t * Falling back to getpass(..)\n\t * getpass is obsolete, but there's apparently nothing that replaces it\n\t */\n\tchar *tmp_pass = getpass(prompt);\n\tif (!tmp_pass)\n\t\treturn NULL;\n\n\tstrncpy(input, tmp_pass, capacity - 1);\n\tinput[capacity - 1] = '\\0';\n\n\t/* zero-out the static buffer */\n\tmemset(tmp_pass, 0, strlen(tmp_pass));\n\n\treturn input;\n}\n\nstatic int\nassemble_mountinfo(struct parsed_mount_info *parsed_info,\n\t\t   const char *thisprogram, const char *mountpoint,\n\t\t   const char *orig_dev, char *orgoptions)\n{\n\tint rc;\n\tchar *newopts = NULL;\n\n\trc = drop_capabilities(0);\n\tif (rc)\n\t\tgoto assemble_exit;\n\n\trc = drop_child_privs();\n\tif (rc)\n\t\tgoto assemble_exit;\n\n\tif (getuid()) {\n\t\trc = check_fstab(thisprogram, mountpoint, orig_dev,\n\t\t\t\t &newopts);\n\t\tif (rc)\n\t\t\tgoto assemble_exit;\n\n\t\torgoptions = newopts;\n\t\t/* enable any default user mount flags */\n\t\tparsed_info->flags |= CIFS_SETUID_FLAGS;\n\t}\n\n\trc = get_pw_from_env(parsed_info, thisprogram);\n\tif (rc)\n\t\tgoto assemble_exit;\n\n\tif (orgoptions) {\n\t\trc = parse_options(orgoptions, parsed_info);\n\t\tif (rc)\n\t\t\tgoto assemble_exit;\n\t}\n\n\tif (getuid()) {\n\t\tif (!(parsed_info->flags & (MS_USERS | MS_USER))) {\n\t\t\tfprintf(stderr, \"%s: permission denied\\n\", thisprogram);\n\t\t\trc = EX_USAGE;\n\t\t\tgoto assemble_exit;\n\t\t}\n\t}\n\n\tparsed_info->flags &= ~(MS_USERS | MS_USER);\n\n\trc = parse_unc(orig_dev, parsed_info, thisprogram);\n\tif (rc)\n\t\tgoto assemble_exit;\n\n\tif (parsed_info->addrlist[0] == '\\0')\n\t\trc = resolve_host(parsed_info->host, parsed_info->addrlist);\n\n\tswitch (rc) {\n\tcase EX_USAGE:\n\t\tfprintf(stderr, \"mount error: could not resolve address for \"\n\t\t\t\"%s: %s\\n\", parsed_info->host,\n\t\t\trc == EAI_SYSTEM ? strerror(errno) : gai_strerror(rc));\n\t\tgoto assemble_exit;\n\n\tcase EX_SYSERR:\n\t\tfprintf(stderr, \"mount error: problem parsing address \"\n\t\t\t\"list: %s\\n\", strerror(errno));\n\t\tgoto assemble_exit;\n\t}\n\n\tif (!parsed_info->got_user) {\n\t\t/*\n\t\t * Note that the password will not be retrieved from the\n\t\t * USER env variable (ie user%password form) as there is\n\t\t * already a PASSWD environment varaible\n\t\t */\n\t\tif (getenv(\"USER\"))\n\t\t\tstrlcpy(parsed_info->username, getenv(\"USER\"),\n\t\t\t\tsizeof(parsed_info->username));\n\t\telse\n\t\t\tstrlcpy(parsed_info->username, getusername(getuid()),\n\t\t\t\tsizeof(parsed_info->username));\n\t\tparsed_info->got_user = 1;\n\t}\n\n\tif (!parsed_info->got_password) {\n\t\tchar tmp_pass[MOUNT_PASSWD_SIZE + 1];\n\t\tchar *prompt = NULL;\n\n\t\tif(asprintf(&prompt, \"Password for %s@%s: \", parsed_info->username, orig_dev) < 0)\n\t\t\tprompt = NULL;\n\n\t\tif (get_password(prompt ? prompt : \"Password: \", tmp_pass, MOUNT_PASSWD_SIZE + 1)) {\n\t\t\trc = set_password(parsed_info, tmp_pass);\n\t\t} else {\n\t\t\tfprintf(stderr, \"Error reading password, exiting\\n\");\n\t\t\trc = EX_SYSERR;\n\t\t}\n\n\t\tfree(prompt);\n\t\tif (rc)\n\t\t\tgoto assemble_exit;\n\t}\n\n\t/* copy in user= string */\n\tif (parsed_info->got_user) {\n\t\tif (*parsed_info->options)\n\t\t\tstrlcat(parsed_info->options, \",\",\n\t\t\t\tsizeof(parsed_info->options));\n\t\tstrlcat(parsed_info->options, \"user=\",\n\t\t\tsizeof(parsed_info->options));\n\t\tstrlcat(parsed_info->options, parsed_info->username,\n\t\t\tsizeof(parsed_info->options));\n\t}\n\n\tif (*parsed_info->domain) {\n\t\tif (*parsed_info->options)\n\t\t\tstrlcat(parsed_info->options, \",\",\n\t\t\t\tsizeof(parsed_info->options));\n\t\tstrlcat(parsed_info->options, \"domain=\",\n\t\t\tsizeof(parsed_info->options));\n\t\tstrlcat(parsed_info->options, parsed_info->domain,\n\t\t\tsizeof(parsed_info->options));\n\t} else if (parsed_info->got_domain) {\n\t\tstrlcat(parsed_info->options, \",domain=\",\n\t\t\tsizeof(parsed_info->options));\n\t}\n\nassemble_exit:\n\tfree(newopts);\n\treturn rc;\n}\n\n/*\n * chdir() into the mountpoint and determine \"realpath\". We assume here that\n * \"mountpoint\" is a statically allocated string and does not need to be freed.\n */\nstatic int\nacquire_mountpoint(char **mountpointp)\n{\n\tint rc, dacrc;\n\tuid_t realuid, oldfsuid;\n\tgid_t oldfsgid;\n\tchar *mountpoint = NULL;\n\n\t/*\n\t * Acquire the necessary privileges to chdir to the mountpoint. If\n\t * the real uid is root, then we reacquire CAP_DAC_READ_SEARCH. If\n\t * it's not, then we change the fsuid to the real uid to ensure that\n\t * the mounting user actually has access to the mountpoint.\n\t *\n\t * The mount(8) manpage does not state that users must be able to\n\t * chdir into the mountpoint in order to mount onto it, but if we\n\t * allow that, then an unprivileged user could use this program to\n\t * \"probe\" into directories to which he does not have access.\n\t */\n\trealuid = getuid();\n\tif (realuid == 0) {\n\t\trc = toggle_dac_capability(0, 1);\n\t\tif (rc)\n\t\t\tgoto out;\n\t} else {\n\t\toldfsuid = setfsuid(realuid);\n\t\toldfsgid = setfsgid(getgid());\n\t}\n\n\trc = chdir(*mountpointp);\n\tif (rc) {\n\t\tfprintf(stderr, \"Couldn't chdir to %s: %s\\n\", *mountpointp,\n\t\t\tstrerror(errno));\n\t\trc = EX_USAGE;\n\t\tgoto restore_privs;\n\t}\n\n\tmountpoint = realpath(\".\", NULL);\n\tif (!mountpoint) {\n\t\tfprintf(stderr, \"Unable to resolve %s to canonical path: %s\\n\",\n\t\t\t*mountpointp, strerror(errno));\n\t\trc = EX_SYSERR;\n\t}\n\nrestore_privs:\n\tif (realuid == 0) {\n\t\tdacrc = toggle_dac_capability(0, 0);\n\t\tif (dacrc)\n\t\t\trc = rc ? rc : dacrc;\n\t} else {\n\t\tuid_t __attribute__((unused)) uignore = setfsuid(oldfsuid);\n\t\tgid_t __attribute__((unused)) gignore = setfsgid(oldfsgid);\n\t}\n\nout:\n\tif (rc) {\n\t\tfree(mountpoint);\n\t\tmountpoint = NULL;\n\t}\n\n\t*mountpointp = mountpoint;\n\treturn rc;\n}\n\nint main(int argc, char **argv)\n{\n\tint c;\n\tchar *orgoptions = NULL;\n\tchar *mountpoint = NULL;\n\tchar *options = NULL;\n\tchar *orig_dev = NULL;\n\tchar *currentaddress, *nextaddress;\n\tchar *value = NULL;\n\tchar *ep = NULL;\n\tint rc = 0;\n\tint already_uppercased = 0;\n\tint sloppy = 0;\n\tint fallback_sudo_uid = 0;\n\tsize_t options_size = MAX_OPTIONS_LEN;\n\tstruct parsed_mount_info *parsed_info = NULL;\n\tstruct parsed_mount_info *reinit_parsed_info = NULL;\n\tpid_t pid;\n\tuid_t sudo_uid = 0;\n\n\trc = check_setuid();\n\tif (rc)\n\t\treturn rc;\n\n\trc = drop_capabilities(1);\n\tif (rc)\n\t\treturn EX_SYSERR;\n\n\t/* setlocale(LC_ALL, \"\");\n\t   bindtextdomain(PACKAGE, LOCALEDIR);\n\t   textdomain(PACKAGE); */\n\n\tif (!argc || !argv) {\n\t\trc = mount_usage(stderr);\n\t\tgoto mount_exit;\n\t}\n\n\tthisprogram = basename(argv[0]);\n\tif (thisprogram == NULL)\n\t\tthisprogram = \"mount.cifs\";\n\n\tif(strcmp(thisprogram, \"mount.cifs\") == 0)\n\t\tcifs_fstype = \"cifs\";\n\n\tif(strcmp(thisprogram, \"mount.smb3\") == 0)\n\t\tcifs_fstype = \"smb3\";\n\n\t/* allocate parsed_info as shared anonymous memory range */\n\tparsed_info = mmap((void *)0, sizeof(*parsed_info), PROT_READ | PROT_WRITE,\n\t\t\t   MAP_ANONYMOUS | MAP_SHARED, -1, 0);\n\tif (parsed_info == (struct parsed_mount_info *) -1) {\n\t\tparsed_info = NULL;\n\t\tfprintf(stderr, \"Unable to allocate memory: %s\\n\",\n\t\t\t\tstrerror(errno));\n\t\trc = EX_SYSERR;\n\t\tgoto mount_exit;\n\t}\n\n\treinit_parsed_info = malloc(sizeof(*reinit_parsed_info));\n\tif (reinit_parsed_info == NULL) {\n\t\tfprintf(stderr, \"Unable to allocate memory: %s\\n\",\n\t\t\t\tstrerror(errno));\n\t\trc = EX_SYSERR;\n\t\tgoto mount_exit;\n\t}\n\n\toptions = calloc(options_size, 1);\n\tif (!options) {\n\t\tfprintf(stderr, \"Unable to allocate memory.\\n\");\n\t\trc = EX_SYSERR;\n\t\tgoto mount_exit;\n\t}\n\n\t/* add sharename in opts string as unc= parm */\n\twhile ((c = getopt_long(argc, argv, \"?fhno:rsvVw\",\n\t\t\t\tlongopts, NULL)) != -1) {\n\t\tswitch (c) {\n\t\tcase '?':\n\t\tcase 'h':\t/* help */\n\t\t\trc = mount_usage(stdout);\n\t\t\tgoto mount_exit;\n\t\tcase 'n':\n\t\t\t++parsed_info->nomtab;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\torgoptions = strndup(optarg, MAX_OPTIONS_LEN);\n\t\t\tif (!orgoptions) {\n\t\t\t\trc = EX_SYSERR;\n\t\t\t\tgoto mount_exit;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'r':\t/* mount readonly */\n\t\t\tparsed_info->flags |= MS_RDONLY;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\t++parsed_info->verboseflag;\n\t\t\tbreak;\n\t\tcase 'V':\n\t\t\tprint_cifs_mount_version(thisprogram);\n\t\t\texit(0);\n\t\tcase 'w':\n\t\t\tparsed_info->flags &= ~MS_RDONLY;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\t++parsed_info->fakemnt;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\t++sloppy;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(stderr, \"unknown command-line option: %c\\n\", c);\n\t\t\trc = mount_usage(stderr);\n\t\t\tgoto mount_exit;\n\t\t}\n\t}\n\n\tif (argc < optind + 2) {\n\t\trc = mount_usage(stderr);\n\t\tgoto mount_exit;\n\t}\n\n\torig_dev = argv[optind];\n\tmountpoint = argv[optind + 1];\n\n\t/* chdir into mountpoint as soon as possible */\n\trc = acquire_mountpoint(&mountpoint);\n\tif (rc) {\n\t\tgoto mount_exit;\n\t}\n\n\t/* Before goto assemble_retry, reinitialize parsed_info with reinit_parsed_info */\n\tmemcpy(reinit_parsed_info, parsed_info,\tsizeof(*reinit_parsed_info));\n\nassemble_retry:\n\t/*\n\t * mount.cifs does privilege separation. Most of the code to handle\n\t * assembling the mount info is done in a child process that drops\n\t * privileges. The info is assembled in parsed_info which is a\n\t * shared, mmaped memory segment. The parent waits for the child to\n\t * exit and checks the return code. If it's anything but \"0\", then\n\t * the process exits without attempting anything further.\n\t */\n\tpid = fork();\n\tif (pid == -1) {\n\t\tfprintf(stderr, \"Unable to fork: %s\\n\", strerror(errno));\n\t\trc = EX_SYSERR;\n\t\tgoto mount_exit;\n\t} else if (!pid) {\n\t\t/* child */\n\t\trc = assemble_mountinfo(parsed_info, thisprogram, mountpoint,\n\t\t\t\t\torig_dev, orgoptions);\n\t\tgoto mount_child_exit;\n\t} else {\n\t\t/* parent */\n\t\tpid = wait(&rc);\n\t\tif (!WIFEXITED(rc)) {\n\t\t\tfprintf(stderr, \"Child process terminated abnormally.\\n\");\n\t\t\trc = EX_SYSERR;\n\t\t\tgoto mount_exit;\n\t\t}\n\t\trc = WEXITSTATUS(rc);\n\t\tif (rc)\n\t\t\tgoto mount_exit;\n\t}\n\n\tcurrentaddress = parsed_info->addrlist;\n\tnextaddress = strchr(currentaddress, ',');\n\tif (nextaddress)\n\t\t*nextaddress++ = '\\0';\n\nmount_retry:\n\toptions[0] = '\\0';\n\tif (!currentaddress) {\n\t\tfprintf(stderr, \"Unable to find suitable address.\\n\");\n\t\trc = parsed_info->nofail ? 0 : EX_FAIL;\n\t\tgoto mount_exit;\n\t}\n\tstrlcpy(options, \"ip=\", options_size);\n\tstrlcat(options, currentaddress, options_size);\n\n\tstrlcat(options, \",unc=\\\\\\\\\", options_size);\n\tstrlcat(options, parsed_info->host, options_size);\n\tstrlcat(options, \"\\\\\", options_size);\n\tstrlcat(options, parsed_info->share, options_size);\n\n\tif (*parsed_info->options) {\n\t\tstrlcat(options, \",\", options_size);\n\t\tstrlcat(options, parsed_info->options, options_size);\n\t}\n\n\tif (*parsed_info->prefix) {\n\t\tstrlcat(options, \",prefixpath=\", options_size);\n\t\tstrlcat(options, parsed_info->prefix, options_size);\n\t}\n\n\tif (sloppy)\n\t\tstrlcat(options, \",sloppy\", options_size);\n\n\tif (parsed_info->verboseflag)\n\t\tfprintf(stderr, \"%s kernel mount options: %s\",\n\t\t\tthisprogram, options);\n\n\tif (parsed_info->got_password) {\n\t\t/*\n\t\t * Commas have to be doubled, or else they will\n\t\t * look like the parameter separator\n\t\t */\n\t\tstrlcat(options, \",pass=\", options_size);\n\t\tstrlcat(options, parsed_info->password, options_size);\n\t\tif (parsed_info->verboseflag)\n\t\t\tfprintf(stderr, \",pass=********\");\n\t}\n\n\tif (parsed_info->verboseflag)\n\t\tfprintf(stderr, \"\\n\");\n\n\trc = check_mtab(thisprogram, orig_dev, mountpoint);\n\tif (rc)\n\t\tgoto mount_exit;\n\n\tif (!parsed_info->fakemnt) {\n\t\ttoggle_dac_capability(0, 1);\n\t\trc = mount(orig_dev, \".\", cifs_fstype, parsed_info->flags, options);\n\t\ttoggle_dac_capability(0, 0);\n\t\tif (rc == 0)\n\t\t\tgoto do_mtab;\n\n\t\tswitch (errno) {\n\t\tcase ECONNREFUSED:\n\t\tcase EHOSTUNREACH:\n\t\t\tif (currentaddress) {\n\t\t\t\tfprintf(stderr, \"mount error(%d): could not connect to %s\",\n\t\t\t\t\terrno, currentaddress);\n\t\t\t}\n\t\t\tcurrentaddress = nextaddress;\n\t\t\tif (currentaddress) {\n\t\t\t\tnextaddress = strchr(currentaddress, ',');\n\t\t\t\tif (nextaddress)\n\t\t\t\t\t*nextaddress++ = '\\0';\n\t\t\t}\n\t\t\tgoto mount_retry;\n\t\tcase ENODEV:\n\t\t\tfprintf(stderr,\n\t\t\t\t\"mount error: %s filesystem not supported by the system\\n\", cifs_fstype);\n\t\t\tbreak;\n\t\tcase EHOSTDOWN:\n\t\t\tfprintf(stderr,\n\t\t\t\t\"mount error: Server abruptly closed the connection.\\n\"\n\t\t\t\t\"This can happen if the server does not support the SMB version you are trying to use.\\n\"\n\t\t\t\t\"The default SMB version recently changed from SMB1 to SMB2.1 and above. Try mounting with vers=1.0.\\n\");\n\t\t\tbreak;\n\t\tcase ENXIO:\n\t\t\tif (!already_uppercased &&\n\t\t\t    uppercase_string(parsed_info->host) &&\n\t\t\t    uppercase_string(parsed_info->share) &&\n\t\t\t    uppercase_string(parsed_info->prefix) &&\n\t\t\t    uppercase_string(orig_dev)) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"Retrying with upper case share name\\n\");\n\t\t\t\talready_uppercased = 1;\n\t\t\t\tgoto mount_retry;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ENOKEY:\n\t\t\tif (!fallback_sudo_uid && parsed_info->is_krb5) {\n\t\t\t\t/* mount could have failed because cruid option was not passed when triggered with sudo */\n\t\t\t\tvalue = getenv(\"SUDO_UID\");\n\t\t\t\tif (value) {\n\t\t\t\t\terrno = 0;\n\t\t\t\t\tsudo_uid = strtoul(value, &ep, 10);\n\t\t\t\t\tif (errno == 0 && *ep == '\\0' && sudo_uid) {\n\t\t\t\t\t\t/* Reinitialize parsed_info and assemble options again with sudo_uid */\n\t\t\t\t\t\tmemcpy(parsed_info, reinit_parsed_info, sizeof(*parsed_info));\n\t\t\t\t\t\tparsed_info->sudo_uid = sudo_uid;\n\t\t\t\t\t\tfallback_sudo_uid = 1;\n\t\t\t\t\t\tgoto assemble_retry;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tfprintf(stderr, \"mount error(%d): %s\\n\", errno,\n\t\t\tstrerror(errno));\n\t\tfprintf(stderr,\n\t\t\t\"Refer to the %s(8) manual page (e.g. man \"\n\t\t\t\"%s) and kernel log messages (dmesg)\\n\", thisprogram, thisprogram);\n\t\trc = EX_FAIL;\n\t\tgoto mount_exit;\n\t}\n\ndo_mtab:\n\tif (!parsed_info->nomtab && !mtab_unusable()) {\n\t\tif (parsed_info->flags & MS_REMOUNT) {\n\t\t\trc = del_mtab(mountpoint);\n\t\t\tif (rc)\n\t\t\t\tgoto mount_exit;\n\t\t}\n\n\t\trc = add_mtab(orig_dev, mountpoint, parsed_info->flags, cifs_fstype);\n\t}\n\nmount_exit:\n\tif (parsed_info) {\n\t\tmemset(parsed_info->password, 0, sizeof(parsed_info->password));\n\t\tmunmap(parsed_info, sizeof(*parsed_info));\n\t}\n\nmount_child_exit:\n\t/* Objects to be freed both in main process and child */\n\tfree(reinit_parsed_info);\n\tfree(options);\n\tfree(orgoptions);\n\tfree(mountpoint);\n\treturn rc;\n}\n"], "filenames": ["mount.cifs.c"], "buggy_code_start_loc": [631], "buggy_code_end_loc": [642], "fixing_code_start_loc": [630], "fixing_code_end_loc": [638], "type": "CWE-668", "message": "cifs-utils through 6.14, with verbose logging, can cause an information leak when a file contains = (equal sign) characters but is not a valid credentials file.", "other": {"cve": {"id": "CVE-2022-29869", "sourceIdentifier": "cve@mitre.org", "published": "2022-04-28T01:15:06.727", "lastModified": "2022-10-05T19:26:49.613", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "cifs-utils through 6.14, with verbose logging, can cause an information leak when a file contains = (equal sign) characters but is not a valid credentials file."}, {"lang": "es", "value": "cifs-utils versiones hasta 6.14, con registro detallado, puede causar un filtrado de informaci\u00f3n cuando un archivo contiene caracteres = (signo de igualdad) pero no es un archivo de credenciales v\u00e1lido"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-668"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:samba:cifs-utils:*:*:*:*:*:*:*:*", "versionEndExcluding": "6.15", "matchCriteriaId": "A994C1D7-9394-43A0-976B-246980F5E77E"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:11.0:*:*:*:*:*:*:*", "matchCriteriaId": "FA6FEEC2-9F11-4643-8827-749718254FED"}]}]}], "references": [{"url": "https://github.com/piastry/cifs-utils/commit/8acc963a2e7e9d63fe1f2e7f73f5a03f83d9c379", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/piastry/cifs-utils/pull/7", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/05/msg00020.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/5WBOLMANBYJILXQKRRK7OCR774PXJAYY/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/HXKZLJYJJEC3TIBFLXUORRMZUKG5W676/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/QIYZ4L6SLSYJQ446VJAO2VGAESURQNSP/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://www.debian.org/security/2022/dsa-5157", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/piastry/cifs-utils/commit/8acc963a2e7e9d63fe1f2e7f73f5a03f83d9c379"}}