{"buggy_code": ["/* signature.c\n *\n * Copyright (C) 2006-2019 wolfSSL Inc.\n *\n * This file is part of wolfSSL.\n *\n * wolfSSL is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * wolfSSL is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335, USA\n */\n\n\n#ifdef HAVE_CONFIG_H\n    #include <config.h>\n#endif\n\n#include <wolfssl/wolfcrypt/settings.h>\n#include <wolfssl/wolfcrypt/signature.h>\n#include <wolfssl/wolfcrypt/error-crypt.h>\n#include <wolfssl/wolfcrypt/logging.h>\n#ifndef NO_ASN\n#include <wolfssl/wolfcrypt/asn.h>\n#endif\n#ifdef HAVE_ECC\n#include <wolfssl/wolfcrypt/ecc.h>\n#endif\n#ifndef NO_RSA\n#include <wolfssl/wolfcrypt/rsa.h>\n#endif\n\n/* If ECC and RSA are disabled then disable signature wrapper */\n#if (!defined(HAVE_ECC) || (defined(HAVE_ECC) && !defined(HAVE_ECC_SIGN) \\\n    && !defined(HAVE_ECC_VERIFY))) && defined(NO_RSA)\n    #undef NO_SIG_WRAPPER\n    #define NO_SIG_WRAPPER\n#endif\n\n/* Signature wrapper disabled check */\n#ifndef NO_SIG_WRAPPER\n\n#if !defined(NO_RSA) && !defined(NO_ASN)\nstatic int wc_SignatureDerEncode(enum wc_HashType hash_type, byte* hash_data,\n    word32 hash_len, word32* hash_enc_len)\n{\n    int ret, oid;\n\n    ret = wc_HashGetOID(hash_type);\n    if (ret < 0) {\n        return ret;\n    }\n    oid = ret;\n\n    ret = wc_EncodeSignature(hash_data, hash_data, hash_len, oid);\n    if (ret > 0) {\n        *hash_enc_len = ret;\n        ret = 0;\n    }\n\n    return ret;\n}\n#endif /* !NO_RSA && !NO_ASN */\n\nint wc_SignatureGetSize(enum wc_SignatureType sig_type,\n    const void* key, word32 key_len)\n{\n    int sig_len = BAD_FUNC_ARG;\n\n    /* Suppress possible unused args if all signature types are disabled */\n    (void)key;\n    (void)key_len;\n\n    switch(sig_type) {\n        case WC_SIGNATURE_TYPE_ECC:\n#ifdef HAVE_ECC\n            /* Sanity check that void* key is at least ecc_key in size */\n            if (key_len >= sizeof(ecc_key)) {\n                sig_len = wc_ecc_sig_size((ecc_key*)key);\n            }\n            else {\n                WOLFSSL_MSG(\"wc_SignatureGetSize: Invalid ECC key size\");\n            }\n#else\n            sig_len = SIG_TYPE_E;\n#endif\n            break;\n\n        case WC_SIGNATURE_TYPE_RSA_W_ENC:\n        case WC_SIGNATURE_TYPE_RSA:\n#ifndef NO_RSA\n            /* Sanity check that void* key is at least RsaKey in size */\n            if (key_len >= sizeof(RsaKey)) {\n                sig_len = wc_RsaEncryptSize((RsaKey*)key);\n            }\n            else {\n                WOLFSSL_MSG(\"wc_SignatureGetSize: Invalid RsaKey key size\");\n            }\n#else\n            sig_len = SIG_TYPE_E;\n#endif\n            break;\n\n        case WC_SIGNATURE_TYPE_NONE:\n        default:\n            sig_len = BAD_FUNC_ARG;\n            break;\n    }\n    return sig_len;\n}\n\nint wc_SignatureVerifyHash(\n    enum wc_HashType hash_type, enum wc_SignatureType sig_type,\n    const byte* hash_data, word32 hash_len,\n    const byte* sig, word32 sig_len,\n    const void* key, word32 key_len)\n{\n    int ret;\n\n    /* Check arguments */\n    if (hash_data == NULL || hash_len <= 0 ||\n        sig == NULL || sig_len <= 0 ||\n        key == NULL || key_len <= 0) {\n        return BAD_FUNC_ARG;\n    }\n\n    /* Validate signature len (1 to max is okay) */\n    if ((int)sig_len > wc_SignatureGetSize(sig_type, key, key_len)) {\n        WOLFSSL_MSG(\"wc_SignatureVerify: Invalid sig type/len\");\n        return BAD_FUNC_ARG;\n    }\n\n    /* Validate hash size */\n    ret = wc_HashGetDigestSize(hash_type);\n    if (ret < 0) {\n        WOLFSSL_MSG(\"wc_SignatureVerify: Invalid hash type/len\");\n        return ret;\n    }\n    ret = 0;\n\n    /* Verify signature using hash */\n    switch (sig_type) {\n        case WC_SIGNATURE_TYPE_ECC:\n        {\n#if defined(HAVE_ECC) && defined(HAVE_ECC_VERIFY)\n            int is_valid_sig = 0;\n\n            /* Perform verification of signature using provided ECC key */\n            do {\n            #ifdef WOLFSSL_ASYNC_CRYPT\n                ret = wc_AsyncWait(ret, &((ecc_key*)key)->asyncDev,\n                    WC_ASYNC_FLAG_CALL_AGAIN);\n            #endif\n            if (ret >= 0)\n                ret = wc_ecc_verify_hash(sig, sig_len, hash_data, hash_len,\n                    &is_valid_sig, (ecc_key*)key);\n            } while (ret == WC_PENDING_E);\n            if (ret != 0 || is_valid_sig != 1) {\n                ret = SIG_VERIFY_E;\n            }\n#else\n            ret = SIG_TYPE_E;\n#endif\n            break;\n        }\n\n        case WC_SIGNATURE_TYPE_RSA_W_ENC:\n        case WC_SIGNATURE_TYPE_RSA:\n        {\n#ifndef NO_RSA\n#if defined(WOLFSSL_CRYPTOCELL)\n        /* the signature must propagate to the cryptocell to get verfied */\n        ret = wc_RsaSSL_Verify(hash_data, hash_len, (byte*)sig, sig_len, (RsaKey*)key);\n        if (ret != 0) {\n            WOLFSSL_MSG(\"RSA Signature Verify difference!\");\n            ret = SIG_VERIFY_E;\n        }\n\n#else /* WOLFSSL_CRYPTOCELL */\n\n            word32 plain_len = hash_len;\n            byte *plain_data;\n\n            /* Make sure the plain text output is at least key size */\n            if (plain_len < sig_len) {\n                plain_len = sig_len;\n            }\n            plain_data = (byte*)XMALLOC(plain_len, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n            if (plain_data) {\n                /* Perform verification of signature using provided RSA key */\n                do {\n                #ifdef WOLFSSL_ASYNC_CRYPT\n                    ret = wc_AsyncWait(ret, &((RsaKey*)key)->asyncDev,\n                        WC_ASYNC_FLAG_CALL_AGAIN);\n                #endif\n                if (ret >= 0)\n                    ret = wc_RsaSSL_Verify(sig, sig_len, plain_data,\n                        plain_len, (RsaKey*)key);\n                } while (ret == WC_PENDING_E);\n                if (ret >= 0) {\n                    if ((word32)ret == hash_len &&\n                            XMEMCMP(plain_data, hash_data, hash_len) == 0) {\n                        ret = 0; /* Success */\n                    }\n                    else {\n                        WOLFSSL_MSG(\"RSA Signature Verify difference!\");\n                        ret = SIG_VERIFY_E;\n                    }\n                }\n                XFREE(plain_data, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n            }\n            else {\n                ret = MEMORY_E;\n            }\n#endif /* !WOLFSSL_CRYPTOCELL */\n#else\n            ret = SIG_TYPE_E;\n#endif\n            break;\n        }\n\n        case WC_SIGNATURE_TYPE_NONE:\n        default:\n            ret = BAD_FUNC_ARG;\n            break;\n    }\n\n    return ret;\n}\n\nint wc_SignatureVerify(\n    enum wc_HashType hash_type, enum wc_SignatureType sig_type,\n    const byte* data, word32 data_len,\n    const byte* sig, word32 sig_len,\n    const void* key, word32 key_len)\n{\n    int ret;\n    word32 hash_len, hash_enc_len;\n#ifdef WOLFSSL_SMALL_STACK\n    byte *hash_data;\n#else\n    byte hash_data[MAX_DER_DIGEST_SZ];\n#endif\n\n    /* Check arguments */\n    if (data == NULL || data_len <= 0 ||\n        sig == NULL || sig_len <= 0 ||\n        key == NULL || key_len <= 0) {\n        return BAD_FUNC_ARG;\n    }\n\n    /* Validate signature len (1 to max is okay) */\n    if ((int)sig_len > wc_SignatureGetSize(sig_type, key, key_len)) {\n        WOLFSSL_MSG(\"wc_SignatureVerify: Invalid sig type/len\");\n        return BAD_FUNC_ARG;\n    }\n\n    /* Validate hash size */\n    ret = wc_HashGetDigestSize(hash_type);\n    if (ret < 0) {\n        WOLFSSL_MSG(\"wc_SignatureVerify: Invalid hash type/len\");\n        return ret;\n    }\n    hash_enc_len = hash_len = ret;\n\n#ifndef NO_RSA\n    if (sig_type == WC_SIGNATURE_TYPE_RSA_W_ENC) {\n        /* For RSA with ASN.1 encoding include room */\n        hash_enc_len += MAX_DER_DIGEST_ASN_SZ;\n    }\n#endif\n\n#ifdef WOLFSSL_SMALL_STACK\n    /* Allocate temporary buffer for hash data */\n    hash_data = (byte*)XMALLOC(hash_enc_len, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n    if (hash_data == NULL) {\n        return MEMORY_E;\n    }\n#endif\n\n    /* Perform hash of data */\n    ret = wc_Hash(hash_type, data, data_len, hash_data, hash_len);\n    if (ret == 0) {\n        /* Handle RSA with DER encoding */\n        if (sig_type == WC_SIGNATURE_TYPE_RSA_W_ENC) {\n        #if defined(NO_RSA) || defined(NO_ASN)\n            ret = SIG_TYPE_E;\n        #else\n            ret = wc_SignatureDerEncode(hash_type, hash_data, hash_len,\n                &hash_enc_len);\n        #endif\n        }\n\n        if (ret == 0) {\n            /* Verify signature using hash */\n            ret = wc_SignatureVerifyHash(hash_type, sig_type,\n                hash_data, hash_enc_len, sig, sig_len, key, key_len);\n        }\n    }\n\n#ifdef WOLFSSL_SMALL_STACK\n    XFREE(hash_data, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n\n    return ret;\n}\n\n\nint wc_SignatureGenerateHash(\n    enum wc_HashType hash_type, enum wc_SignatureType sig_type,\n    const byte* hash_data, word32 hash_len,\n    byte* sig, word32 *sig_len,\n    const void* key, word32 key_len, WC_RNG* rng)\n{\n    int ret;\n\n    /* Suppress possible unused arg if all signature types are disabled */\n    (void)rng;\n\n    /* Check arguments */\n    if (hash_data == NULL || hash_len <= 0 ||\n        sig == NULL || sig_len == NULL || *sig_len <= 0 ||\n        key == NULL || key_len <= 0) {\n        return BAD_FUNC_ARG;\n    }\n\n    /* Validate signature len (needs to be at least max) */\n    if ((int)*sig_len < wc_SignatureGetSize(sig_type, key, key_len)) {\n        WOLFSSL_MSG(\"wc_SignatureGenerate: Invalid sig type/len\");\n        return BAD_FUNC_ARG;\n    }\n\n    /* Validate hash size */\n    ret = wc_HashGetDigestSize(hash_type);\n    if (ret < 0) {\n        WOLFSSL_MSG(\"wc_SignatureGenerate: Invalid hash type/len\");\n        return ret;\n    }\n    ret = 0;\n\n    /* Create signature using hash as data */\n    switch (sig_type) {\n        case WC_SIGNATURE_TYPE_ECC:\n#if defined(HAVE_ECC) && defined(HAVE_ECC_SIGN)\n            /* Create signature using provided ECC key */\n            do {\n            #ifdef WOLFSSL_ASYNC_CRYPT\n                ret = wc_AsyncWait(ret, &((ecc_key*)key)->asyncDev,\n                    WC_ASYNC_FLAG_CALL_AGAIN);\n            #endif\n            if (ret >= 0)\n                ret = wc_ecc_sign_hash(hash_data, hash_len, sig, sig_len,\n                    rng, (ecc_key*)key);\n            } while (ret == WC_PENDING_E);\n#else\n            ret = SIG_TYPE_E;\n#endif\n            break;\n\n        case WC_SIGNATURE_TYPE_RSA_W_ENC:\n        case WC_SIGNATURE_TYPE_RSA:\n#if !defined(NO_RSA) && !defined(WOLFSSL_RSA_PUBLIC_ONLY)\n            /* Create signature using provided RSA key */\n            do {\n            #ifdef WOLFSSL_ASYNC_CRYPT\n                ret = wc_AsyncWait(ret, &((RsaKey*)key)->asyncDev,\n                    WC_ASYNC_FLAG_CALL_AGAIN);\n            #endif\n                if (ret >= 0)\n                    ret = wc_RsaSSL_Sign(hash_data, hash_len, sig, *sig_len,\n                        (RsaKey*)key, rng);\n            } while (ret == WC_PENDING_E);\n            if (ret >= 0) {\n                *sig_len = ret;\n                ret = 0; /* Success */\n            }\n#else\n            ret = SIG_TYPE_E;\n#endif\n            break;\n\n        case WC_SIGNATURE_TYPE_NONE:\n        default:\n            ret = BAD_FUNC_ARG;\n            break;\n    }\n\n    return ret;\n}\n\nint wc_SignatureGenerate(\n    enum wc_HashType hash_type, enum wc_SignatureType sig_type,\n    const byte* data, word32 data_len,\n    byte* sig, word32 *sig_len,\n    const void* key, word32 key_len, WC_RNG* rng)\n{\n    int ret;\n    word32 hash_len, hash_enc_len;\n#ifdef WOLFSSL_SMALL_STACK\n    byte *hash_data;\n#else\n    byte hash_data[MAX_DER_DIGEST_SZ];\n#endif\n\n    /* Check arguments */\n    if (data == NULL || data_len <= 0 ||\n        sig == NULL || sig_len == NULL || *sig_len <= 0 ||\n        key == NULL || key_len <= 0) {\n        return BAD_FUNC_ARG;\n    }\n\n    /* Validate signature len (needs to be at least max) */\n    if ((int)*sig_len < wc_SignatureGetSize(sig_type, key, key_len)) {\n        WOLFSSL_MSG(\"wc_SignatureGenerate: Invalid sig type/len\");\n        return BAD_FUNC_ARG;\n    }\n\n    /* Validate hash size */\n    ret = wc_HashGetDigestSize(hash_type);\n    if (ret < 0) {\n        WOLFSSL_MSG(\"wc_SignatureGenerate: Invalid hash type/len\");\n        return ret;\n    }\n    hash_enc_len = hash_len = ret;\n\n#if !defined(NO_RSA) && !defined(WOLFSSL_RSA_PUBLIC_ONLY)\n    if (sig_type == WC_SIGNATURE_TYPE_RSA_W_ENC) {\n        /* For RSA with ASN.1 encoding include room */\n        hash_enc_len += MAX_DER_DIGEST_ASN_SZ;\n    }\n#endif\n\n#ifdef WOLFSSL_SMALL_STACK\n    /* Allocate temporary buffer for hash data */\n    hash_data = (byte*)XMALLOC(hash_enc_len, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n    if (hash_data == NULL) {\n        return MEMORY_E;\n    }\n#endif\n\n    /* Perform hash of data */\n    ret = wc_Hash(hash_type, data, data_len, hash_data, hash_len);\n    if (ret == 0) {\n        /* Handle RSA with DER encoding */\n        if (sig_type == WC_SIGNATURE_TYPE_RSA_W_ENC) {\n        #if defined(NO_RSA) || defined(NO_ASN) || \\\n                                                defined(WOLFSSL_RSA_PUBLIC_ONLY)\n            ret = SIG_TYPE_E;\n        #else\n            ret = wc_SignatureDerEncode(hash_type, hash_data, hash_len,\n                &hash_enc_len);\n        #endif\n        }\n\n        if (ret == 0) {\n            /* Generate signature using hash */\n            ret = wc_SignatureGenerateHash(hash_type, sig_type,\n                hash_data, hash_enc_len, sig, sig_len, key, key_len, rng);\n        }\n    }\n\n#ifdef WOLFSSL_SMALL_STACK\n    XFREE(hash_data, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n\n    return ret;\n}\n\n#endif /* NO_SIG_WRAPPER */\n", "/* signature.h\n *\n * Copyright (C) 2006-2019 wolfSSL Inc.\n *\n * This file is part of wolfSSL.\n *\n * wolfSSL is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * wolfSSL is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335, USA\n */\n\n/*!\n    \\file wolfssl/wolfcrypt/signature.h\n*/\n\n\n#ifndef WOLF_CRYPT_SIGNATURE_H\n#define WOLF_CRYPT_SIGNATURE_H\n\n#include <wolfssl/wolfcrypt/types.h>\n#include <wolfssl/wolfcrypt/hash.h>\n#include <wolfssl/wolfcrypt/random.h>\n\n#ifdef __cplusplus\n    extern \"C\" {\n#endif\n\nenum wc_SignatureType {\n    WC_SIGNATURE_TYPE_NONE = 0,\n    WC_SIGNATURE_TYPE_ECC = 1,\n    WC_SIGNATURE_TYPE_RSA = 2,\n    WC_SIGNATURE_TYPE_RSA_W_ENC = 3, /* Adds DER header via wc_EncodeSignature */\n};\n\nWOLFSSL_API int wc_SignatureGetSize(enum wc_SignatureType sig_type,\n    const void* key, word32 key_len);\n\nWOLFSSL_API int wc_SignatureVerifyHash(\n    enum wc_HashType hash_type, enum wc_SignatureType sig_type,\n    const byte* hash_data, word32 hash_len,\n    const byte* sig, word32 sig_len,\n    const void* key, word32 key_len);\n\nWOLFSSL_API int wc_SignatureVerify(\n    enum wc_HashType hash_type, enum wc_SignatureType sig_type,\n    const byte* data, word32 data_len,\n    const byte* sig, word32 sig_len,\n    const void* key, word32 key_len);\n\nWOLFSSL_API int wc_SignatureGenerateHash(\n    enum wc_HashType hash_type, enum wc_SignatureType sig_type,\n    const byte* hash_data, word32 hash_len,\n    byte* sig, word32 *sig_len,\n    const void* key, word32 key_len, WC_RNG* rng);\nWOLFSSL_API int wc_SignatureGenerate(\n    enum wc_HashType hash_type, enum wc_SignatureType sig_type,\n    const byte* data, word32 data_len,\n    byte* sig, word32 *sig_len,\n    const void* key, word32 key_len,\n    WC_RNG* rng);\n\n#ifdef __cplusplus\n    } /* extern \"C\" */\n#endif\n\n#endif /* WOLF_CRYPT_SIGNATURE_H */\n"], "fixing_code": ["/* signature.c\n *\n * Copyright (C) 2006-2019 wolfSSL Inc.\n *\n * This file is part of wolfSSL.\n *\n * wolfSSL is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * wolfSSL is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335, USA\n */\n\n\n#ifdef HAVE_CONFIG_H\n    #include <config.h>\n#endif\n\n#include <wolfssl/wolfcrypt/settings.h>\n#include <wolfssl/wolfcrypt/signature.h>\n#include <wolfssl/wolfcrypt/error-crypt.h>\n#include <wolfssl/wolfcrypt/logging.h>\n#ifndef NO_ASN\n#include <wolfssl/wolfcrypt/asn.h>\n#endif\n#ifdef HAVE_ECC\n#include <wolfssl/wolfcrypt/ecc.h>\n#endif\n#ifndef NO_RSA\n#include <wolfssl/wolfcrypt/rsa.h>\n#endif\n\n/* If ECC and RSA are disabled then disable signature wrapper */\n#if (!defined(HAVE_ECC) || (defined(HAVE_ECC) && !defined(HAVE_ECC_SIGN) \\\n    && !defined(HAVE_ECC_VERIFY))) && defined(NO_RSA)\n    #undef NO_SIG_WRAPPER\n    #define NO_SIG_WRAPPER\n#endif\n\n/* Signature wrapper disabled check */\n#ifndef NO_SIG_WRAPPER\n\n#if !defined(NO_RSA) && !defined(NO_ASN)\nstatic int wc_SignatureDerEncode(enum wc_HashType hash_type, byte* hash_data,\n    word32 hash_len, word32* hash_enc_len)\n{\n    int ret, oid;\n\n    ret = wc_HashGetOID(hash_type);\n    if (ret < 0) {\n        return ret;\n    }\n    oid = ret;\n\n    ret = wc_EncodeSignature(hash_data, hash_data, hash_len, oid);\n    if (ret > 0) {\n        *hash_enc_len = ret;\n        ret = 0;\n    }\n\n    return ret;\n}\n#endif /* !NO_RSA && !NO_ASN */\n\nint wc_SignatureGetSize(enum wc_SignatureType sig_type,\n    const void* key, word32 key_len)\n{\n    int sig_len = BAD_FUNC_ARG;\n\n    /* Suppress possible unused args if all signature types are disabled */\n    (void)key;\n    (void)key_len;\n\n    switch(sig_type) {\n        case WC_SIGNATURE_TYPE_ECC:\n#ifdef HAVE_ECC\n            /* Sanity check that void* key is at least ecc_key in size */\n            if (key_len >= sizeof(ecc_key)) {\n                sig_len = wc_ecc_sig_size((ecc_key*)key);\n            }\n            else {\n                WOLFSSL_MSG(\"wc_SignatureGetSize: Invalid ECC key size\");\n            }\n#else\n            sig_len = SIG_TYPE_E;\n#endif\n            break;\n\n        case WC_SIGNATURE_TYPE_RSA_W_ENC:\n        case WC_SIGNATURE_TYPE_RSA:\n#ifndef NO_RSA\n            /* Sanity check that void* key is at least RsaKey in size */\n            if (key_len >= sizeof(RsaKey)) {\n                sig_len = wc_RsaEncryptSize((RsaKey*)key);\n            }\n            else {\n                WOLFSSL_MSG(\"wc_SignatureGetSize: Invalid RsaKey key size\");\n            }\n#else\n            sig_len = SIG_TYPE_E;\n#endif\n            break;\n\n        case WC_SIGNATURE_TYPE_NONE:\n        default:\n            sig_len = BAD_FUNC_ARG;\n            break;\n    }\n    return sig_len;\n}\n\nint wc_SignatureVerifyHash(\n    enum wc_HashType hash_type, enum wc_SignatureType sig_type,\n    const byte* hash_data, word32 hash_len,\n    const byte* sig, word32 sig_len,\n    const void* key, word32 key_len)\n{\n    int ret;\n\n    /* Check arguments */\n    if (hash_data == NULL || hash_len <= 0 ||\n        sig == NULL || sig_len <= 0 ||\n        key == NULL || key_len <= 0) {\n        return BAD_FUNC_ARG;\n    }\n\n    /* Validate signature len (1 to max is okay) */\n    if ((int)sig_len > wc_SignatureGetSize(sig_type, key, key_len)) {\n        WOLFSSL_MSG(\"wc_SignatureVerify: Invalid sig type/len\");\n        return BAD_FUNC_ARG;\n    }\n\n    /* Validate hash size */\n    ret = wc_HashGetDigestSize(hash_type);\n    if (ret < 0) {\n        WOLFSSL_MSG(\"wc_SignatureVerify: Invalid hash type/len\");\n        return ret;\n    }\n    ret = 0;\n\n    /* Verify signature using hash */\n    switch (sig_type) {\n        case WC_SIGNATURE_TYPE_ECC:\n        {\n#if defined(HAVE_ECC) && defined(HAVE_ECC_VERIFY)\n            int is_valid_sig = 0;\n\n            /* Perform verification of signature using provided ECC key */\n            do {\n            #ifdef WOLFSSL_ASYNC_CRYPT\n                ret = wc_AsyncWait(ret, &((ecc_key*)key)->asyncDev,\n                    WC_ASYNC_FLAG_CALL_AGAIN);\n            #endif\n            if (ret >= 0)\n                ret = wc_ecc_verify_hash(sig, sig_len, hash_data, hash_len,\n                    &is_valid_sig, (ecc_key*)key);\n            } while (ret == WC_PENDING_E);\n            if (ret != 0 || is_valid_sig != 1) {\n                ret = SIG_VERIFY_E;\n            }\n#else\n            ret = SIG_TYPE_E;\n#endif\n            break;\n        }\n\n        case WC_SIGNATURE_TYPE_RSA_W_ENC:\n        case WC_SIGNATURE_TYPE_RSA:\n        {\n#ifndef NO_RSA\n#if defined(WOLFSSL_CRYPTOCELL)\n        /* the signature must propagate to the cryptocell to get verfied */\n        ret = wc_RsaSSL_Verify(hash_data, hash_len, (byte*)sig, sig_len, (RsaKey*)key);\n        if (ret != 0) {\n            WOLFSSL_MSG(\"RSA Signature Verify difference!\");\n            ret = SIG_VERIFY_E;\n        }\n\n#else /* WOLFSSL_CRYPTOCELL */\n\n            word32 plain_len = hash_len;\n            byte *plain_data;\n\n            /* Make sure the plain text output is at least key size */\n            if (plain_len < sig_len) {\n                plain_len = sig_len;\n            }\n            plain_data = (byte*)XMALLOC(plain_len, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n            if (plain_data) {\n                /* Perform verification of signature using provided RSA key */\n                do {\n                #ifdef WOLFSSL_ASYNC_CRYPT\n                    ret = wc_AsyncWait(ret, &((RsaKey*)key)->asyncDev,\n                        WC_ASYNC_FLAG_CALL_AGAIN);\n                #endif\n                if (ret >= 0)\n                    ret = wc_RsaSSL_Verify(sig, sig_len, plain_data,\n                        plain_len, (RsaKey*)key);\n                } while (ret == WC_PENDING_E);\n                if (ret >= 0) {\n                    if ((word32)ret == hash_len &&\n                            XMEMCMP(plain_data, hash_data, hash_len) == 0) {\n                        ret = 0; /* Success */\n                    }\n                    else {\n                        WOLFSSL_MSG(\"RSA Signature Verify difference!\");\n                        ret = SIG_VERIFY_E;\n                    }\n                }\n                XFREE(plain_data, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n            }\n            else {\n                ret = MEMORY_E;\n            }\n#endif /* !WOLFSSL_CRYPTOCELL */\n#else\n            ret = SIG_TYPE_E;\n#endif\n            break;\n        }\n\n        case WC_SIGNATURE_TYPE_NONE:\n        default:\n            ret = BAD_FUNC_ARG;\n            break;\n    }\n\n    return ret;\n}\n\nint wc_SignatureVerify(\n    enum wc_HashType hash_type, enum wc_SignatureType sig_type,\n    const byte* data, word32 data_len,\n    const byte* sig, word32 sig_len,\n    const void* key, word32 key_len)\n{\n    int ret;\n    word32 hash_len, hash_enc_len;\n#ifdef WOLFSSL_SMALL_STACK\n    byte *hash_data;\n#else\n    byte hash_data[MAX_DER_DIGEST_SZ];\n#endif\n\n    /* Check arguments */\n    if (data == NULL || data_len <= 0 ||\n        sig == NULL || sig_len <= 0 ||\n        key == NULL || key_len <= 0) {\n        return BAD_FUNC_ARG;\n    }\n\n    /* Validate signature len (1 to max is okay) */\n    if ((int)sig_len > wc_SignatureGetSize(sig_type, key, key_len)) {\n        WOLFSSL_MSG(\"wc_SignatureVerify: Invalid sig type/len\");\n        return BAD_FUNC_ARG;\n    }\n\n    /* Validate hash size */\n    ret = wc_HashGetDigestSize(hash_type);\n    if (ret < 0) {\n        WOLFSSL_MSG(\"wc_SignatureVerify: Invalid hash type/len\");\n        return ret;\n    }\n    hash_enc_len = hash_len = ret;\n\n#ifndef NO_RSA\n    if (sig_type == WC_SIGNATURE_TYPE_RSA_W_ENC) {\n        /* For RSA with ASN.1 encoding include room */\n        hash_enc_len += MAX_DER_DIGEST_ASN_SZ;\n    }\n#endif\n\n#ifdef WOLFSSL_SMALL_STACK\n    /* Allocate temporary buffer for hash data */\n    hash_data = (byte*)XMALLOC(hash_enc_len, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n    if (hash_data == NULL) {\n        return MEMORY_E;\n    }\n#endif\n\n    /* Perform hash of data */\n    ret = wc_Hash(hash_type, data, data_len, hash_data, hash_len);\n    if (ret == 0) {\n        /* Handle RSA with DER encoding */\n        if (sig_type == WC_SIGNATURE_TYPE_RSA_W_ENC) {\n        #if defined(NO_RSA) || defined(NO_ASN)\n            ret = SIG_TYPE_E;\n        #else\n            ret = wc_SignatureDerEncode(hash_type, hash_data, hash_len,\n                &hash_enc_len);\n        #endif\n        }\n\n        if (ret == 0) {\n            /* Verify signature using hash */\n            ret = wc_SignatureVerifyHash(hash_type, sig_type,\n                hash_data, hash_enc_len, sig, sig_len, key, key_len);\n        }\n    }\n\n#ifdef WOLFSSL_SMALL_STACK\n    XFREE(hash_data, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n\n    return ret;\n}\n\n\nint wc_SignatureGenerateHash(\n    enum wc_HashType hash_type, enum wc_SignatureType sig_type,\n    const byte* hash_data, word32 hash_len,\n    byte* sig, word32 *sig_len,\n    const void* key, word32 key_len, WC_RNG* rng)\n{\n    return wc_SignatureGenerateHash_ex(hash_type, sig_type, hash_data, hash_len,\n        sig, sig_len, key, key_len, rng, 1);\n}\n\nint wc_SignatureGenerateHash_ex(\n    enum wc_HashType hash_type, enum wc_SignatureType sig_type,\n    const byte* hash_data, word32 hash_len,\n    byte* sig, word32 *sig_len,\n    const void* key, word32 key_len, WC_RNG* rng, int verify)\n{\n    int ret;\n\n    /* Suppress possible unused arg if all signature types are disabled */\n    (void)rng;\n\n    /* Check arguments */\n    if (hash_data == NULL || hash_len <= 0 ||\n        sig == NULL || sig_len == NULL || *sig_len <= 0 ||\n        key == NULL || key_len <= 0) {\n        return BAD_FUNC_ARG;\n    }\n\n    /* Validate signature len (needs to be at least max) */\n    if ((int)*sig_len < wc_SignatureGetSize(sig_type, key, key_len)) {\n        WOLFSSL_MSG(\"wc_SignatureGenerate: Invalid sig type/len\");\n        return BAD_FUNC_ARG;\n    }\n\n    /* Validate hash size */\n    ret = wc_HashGetDigestSize(hash_type);\n    if (ret < 0) {\n        WOLFSSL_MSG(\"wc_SignatureGenerate: Invalid hash type/len\");\n        return ret;\n    }\n    ret = 0;\n\n    /* Create signature using hash as data */\n    switch (sig_type) {\n        case WC_SIGNATURE_TYPE_ECC:\n#if defined(HAVE_ECC) && defined(HAVE_ECC_SIGN)\n            /* Create signature using provided ECC key */\n            do {\n            #ifdef WOLFSSL_ASYNC_CRYPT\n                ret = wc_AsyncWait(ret, &((ecc_key*)key)->asyncDev,\n                    WC_ASYNC_FLAG_CALL_AGAIN);\n            #endif\n            if (ret >= 0)\n                ret = wc_ecc_sign_hash(hash_data, hash_len, sig, sig_len,\n                    rng, (ecc_key*)key);\n            } while (ret == WC_PENDING_E);\n#else\n            ret = SIG_TYPE_E;\n#endif\n            break;\n\n        case WC_SIGNATURE_TYPE_RSA_W_ENC:\n        case WC_SIGNATURE_TYPE_RSA:\n#if !defined(NO_RSA) && !defined(WOLFSSL_RSA_PUBLIC_ONLY)\n            /* Create signature using provided RSA key */\n            do {\n            #ifdef WOLFSSL_ASYNC_CRYPT\n                ret = wc_AsyncWait(ret, &((RsaKey*)key)->asyncDev,\n                    WC_ASYNC_FLAG_CALL_AGAIN);\n            #endif\n                if (ret >= 0)\n                    ret = wc_RsaSSL_Sign(hash_data, hash_len, sig, *sig_len,\n                        (RsaKey*)key, rng);\n            } while (ret == WC_PENDING_E);\n            if (ret >= 0) {\n                *sig_len = ret;\n                ret = 0; /* Success */\n            }\n#else\n            ret = SIG_TYPE_E;\n#endif\n            break;\n\n        case WC_SIGNATURE_TYPE_NONE:\n        default:\n            ret = BAD_FUNC_ARG;\n            break;\n    }\n\n    if (ret == 0 && verify) {\n        ret = wc_SignatureVerifyHash(hash_type, sig_type, hash_data, hash_len,\n            sig, *sig_len, key, key_len);\n    }\n\n    return ret;\n}\n\nint wc_SignatureGenerate(\n    enum wc_HashType hash_type, enum wc_SignatureType sig_type,\n    const byte* data, word32 data_len,\n    byte* sig, word32 *sig_len,\n    const void* key, word32 key_len, WC_RNG* rng)\n{\n    return wc_SignatureGenerate_ex(hash_type, sig_type, data, data_len, sig,\n        sig_len, key, key_len, rng, 1);\n}\n\nint wc_SignatureGenerate_ex(\n    enum wc_HashType hash_type, enum wc_SignatureType sig_type,\n    const byte* data, word32 data_len,\n    byte* sig, word32 *sig_len,\n    const void* key, word32 key_len, WC_RNG* rng, int verify)\n{\n    int ret;\n    word32 hash_len, hash_enc_len;\n#ifdef WOLFSSL_SMALL_STACK\n    byte *hash_data;\n#else\n    byte hash_data[MAX_DER_DIGEST_SZ];\n#endif\n\n    /* Check arguments */\n    if (data == NULL || data_len <= 0 ||\n        sig == NULL || sig_len == NULL || *sig_len <= 0 ||\n        key == NULL || key_len <= 0) {\n        return BAD_FUNC_ARG;\n    }\n\n    /* Validate signature len (needs to be at least max) */\n    if ((int)*sig_len < wc_SignatureGetSize(sig_type, key, key_len)) {\n        WOLFSSL_MSG(\"wc_SignatureGenerate: Invalid sig type/len\");\n        return BAD_FUNC_ARG;\n    }\n\n    /* Validate hash size */\n    ret = wc_HashGetDigestSize(hash_type);\n    if (ret < 0) {\n        WOLFSSL_MSG(\"wc_SignatureGenerate: Invalid hash type/len\");\n        return ret;\n    }\n    hash_enc_len = hash_len = ret;\n\n#if !defined(NO_RSA) && !defined(WOLFSSL_RSA_PUBLIC_ONLY)\n    if (sig_type == WC_SIGNATURE_TYPE_RSA_W_ENC) {\n        /* For RSA with ASN.1 encoding include room */\n        hash_enc_len += MAX_DER_DIGEST_ASN_SZ;\n    }\n#endif\n\n#ifdef WOLFSSL_SMALL_STACK\n    /* Allocate temporary buffer for hash data */\n    hash_data = (byte*)XMALLOC(hash_enc_len, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n    if (hash_data == NULL) {\n        return MEMORY_E;\n    }\n#endif\n\n    /* Perform hash of data */\n    ret = wc_Hash(hash_type, data, data_len, hash_data, hash_len);\n    if (ret == 0) {\n        /* Handle RSA with DER encoding */\n        if (sig_type == WC_SIGNATURE_TYPE_RSA_W_ENC) {\n        #if defined(NO_RSA) || defined(NO_ASN) || \\\n                                                defined(WOLFSSL_RSA_PUBLIC_ONLY)\n            ret = SIG_TYPE_E;\n        #else\n            ret = wc_SignatureDerEncode(hash_type, hash_data, hash_len,\n                &hash_enc_len);\n        #endif\n        }\n\n        if (ret == 0) {\n            /* Generate signature using hash */\n            ret = wc_SignatureGenerateHash(hash_type, sig_type,\n                hash_data, hash_enc_len, sig, sig_len, key, key_len, rng);\n        }\n    }\n\n    if (ret == 0 && verify) {\n        ret = wc_SignatureVerifyHash(hash_type, sig_type, hash_data,\n            hash_enc_len, sig, *sig_len, key, key_len);\n    }\n\n#ifdef WOLFSSL_SMALL_STACK\n    XFREE(hash_data, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n\n    return ret;\n}\n\n#endif /* NO_SIG_WRAPPER */\n", "/* signature.h\n *\n * Copyright (C) 2006-2019 wolfSSL Inc.\n *\n * This file is part of wolfSSL.\n *\n * wolfSSL is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * wolfSSL is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335, USA\n */\n\n/*!\n    \\file wolfssl/wolfcrypt/signature.h\n*/\n\n\n#ifndef WOLF_CRYPT_SIGNATURE_H\n#define WOLF_CRYPT_SIGNATURE_H\n\n#include <wolfssl/wolfcrypt/types.h>\n#include <wolfssl/wolfcrypt/hash.h>\n#include <wolfssl/wolfcrypt/random.h>\n\n#ifdef __cplusplus\n    extern \"C\" {\n#endif\n\nenum wc_SignatureType {\n    WC_SIGNATURE_TYPE_NONE = 0,\n    WC_SIGNATURE_TYPE_ECC = 1,\n    WC_SIGNATURE_TYPE_RSA = 2,\n    WC_SIGNATURE_TYPE_RSA_W_ENC = 3, /* Adds DER header via wc_EncodeSignature */\n};\n\nWOLFSSL_API int wc_SignatureGetSize(enum wc_SignatureType sig_type,\n    const void* key, word32 key_len);\n\nWOLFSSL_API int wc_SignatureVerifyHash(\n    enum wc_HashType hash_type, enum wc_SignatureType sig_type,\n    const byte* hash_data, word32 hash_len,\n    const byte* sig, word32 sig_len,\n    const void* key, word32 key_len);\n\nWOLFSSL_API int wc_SignatureVerify(\n    enum wc_HashType hash_type, enum wc_SignatureType sig_type,\n    const byte* data, word32 data_len,\n    const byte* sig, word32 sig_len,\n    const void* key, word32 key_len);\n\nWOLFSSL_API int wc_SignatureGenerateHash(\n    enum wc_HashType hash_type, enum wc_SignatureType sig_type,\n    const byte* hash_data, word32 hash_len,\n    byte* sig, word32 *sig_len,\n    const void* key, word32 key_len, WC_RNG* rng);\nWOLFSSL_API int wc_SignatureGenerateHash_ex(\n    enum wc_HashType hash_type, enum wc_SignatureType sig_type,\n    const byte* hash_data, word32 hash_len,\n    byte* sig, word32 *sig_len,\n    const void* key, word32 key_len, WC_RNG* rng, int verify);\nWOLFSSL_API int wc_SignatureGenerate(\n    enum wc_HashType hash_type, enum wc_SignatureType sig_type,\n    const byte* data, word32 data_len,\n    byte* sig, word32 *sig_len,\n    const void* key, word32 key_len,\n    WC_RNG* rng);\nWOLFSSL_API int wc_SignatureGenerate_ex(\n    enum wc_HashType hash_type, enum wc_SignatureType sig_type,\n    const byte* data, word32 data_len,\n    byte* sig, word32 *sig_len,\n    const void* key, word32 key_len,\n    WC_RNG* rng, int verify);\n\n#ifdef __cplusplus\n    } /* extern \"C\" */\n#endif\n\n#endif /* WOLF_CRYPT_SIGNATURE_H */\n"], "filenames": ["wolfcrypt/src/signature.c", "wolfssl/wolfcrypt/signature.h"], "buggy_code_start_loc": [322, 64], "buggy_code_end_loc": [469, 70], "fixing_code_start_loc": [323, 65], "fixing_code_end_loc": [500, 82], "type": "CWE-347", "message": "wolfSSL before 4.3.0 mishandles calls to wc_SignatureGenerateHash, leading to fault injection in RSA cryptography.", "other": {"cve": {"id": "CVE-2019-19962", "sourceIdentifier": "cve@mitre.org", "published": "2019-12-25T00:15:10.837", "lastModified": "2021-07-21T11:39:23.747", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "wolfSSL before 4.3.0 mishandles calls to wc_SignatureGenerateHash, leading to fault injection in RSA cryptography."}, {"lang": "es", "value": "wolfSSL versiones anteriores a 4.3.0 maneja inapropiadamente las llamadas a la funci\u00f3n wc_SignatureGenerateHash, conllevando a la inyecci\u00f3n de fallos en la criptograf\u00eda RSA."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-347"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:wolfssl:wolfssl:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.3.0", "matchCriteriaId": "0D85F9EA-33EB-4A71-81FF-A54ABDFABA01"}]}]}], "references": [{"url": "https://github.com/wolfSSL/wolfssl/commit/23878512c65834d12811b1107d19a001478eca5d", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/wolfSSL/wolfssl/releases/tag/v4.3.0-stable", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/wolfSSL/wolfssl/commit/23878512c65834d12811b1107d19a001478eca5d"}}