{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0\n#include <stdbool.h>\n#include <assert.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"metricgroup.h\"\n#include \"cpumap.h\"\n#include \"cputopo.h\"\n#include \"debug.h\"\n#include \"expr.h\"\n#include \"expr-bison.h\"\n#include \"expr-flex.h\"\n#include \"smt.h\"\n#include <linux/kernel.h>\n#include <linux/zalloc.h>\n#include <ctype.h>\n#include <math.h>\n\n#ifdef PARSER_DEBUG\nextern int expr_debug;\n#endif\n\nstruct expr_id_data {\n\tunion {\n\t\tstruct {\n\t\t\tdouble val;\n\t\t\tint source_count;\n\t\t} val;\n\t\tstruct {\n\t\t\tdouble val;\n\t\t\tconst char *metric_name;\n\t\t\tconst char *metric_expr;\n\t\t} ref;\n\t};\n\n\tenum {\n\t\t/* Holding a double value. */\n\t\tEXPR_ID_DATA__VALUE,\n\t\t/* Reference to another metric. */\n\t\tEXPR_ID_DATA__REF,\n\t\t/* A reference but the value has been computed. */\n\t\tEXPR_ID_DATA__REF_VALUE,\n\t} kind;\n};\n\nstatic size_t key_hash(const void *key, void *ctx __maybe_unused)\n{\n\tconst char *str = (const char *)key;\n\tsize_t hash = 0;\n\n\twhile (*str != '\\0') {\n\t\thash *= 31;\n\t\thash += *str;\n\t\tstr++;\n\t}\n\treturn hash;\n}\n\nstatic bool key_equal(const void *key1, const void *key2,\n\t\t    void *ctx __maybe_unused)\n{\n\treturn !strcmp((const char *)key1, (const char *)key2);\n}\n\nstruct hashmap *ids__new(void)\n{\n\treturn hashmap__new(key_hash, key_equal, NULL);\n}\n\nvoid ids__free(struct hashmap *ids)\n{\n\tstruct hashmap_entry *cur;\n\tsize_t bkt;\n\n\tif (ids == NULL)\n\t\treturn;\n\n\thashmap__for_each_entry(ids, cur, bkt) {\n\t\tfree((char *)cur->key);\n\t\tfree(cur->value);\n\t}\n\n\thashmap__free(ids);\n}\n\nint ids__insert(struct hashmap *ids, const char *id)\n{\n\tstruct expr_id_data *data_ptr = NULL, *old_data = NULL;\n\tchar *old_key = NULL;\n\tint ret;\n\n\tret = hashmap__set(ids, id, data_ptr,\n\t\t\t   (const void **)&old_key, (void **)&old_data);\n\tif (ret)\n\t\tfree(data_ptr);\n\tfree(old_key);\n\tfree(old_data);\n\treturn ret;\n}\n\nstruct hashmap *ids__union(struct hashmap *ids1, struct hashmap *ids2)\n{\n\tsize_t bkt;\n\tstruct hashmap_entry *cur;\n\tint ret;\n\tstruct expr_id_data *old_data = NULL;\n\tchar *old_key = NULL;\n\n\tif (!ids1)\n\t\treturn ids2;\n\n\tif (!ids2)\n\t\treturn ids1;\n\n\tif (hashmap__size(ids1) <  hashmap__size(ids2)) {\n\t\tstruct hashmap *tmp = ids1;\n\n\t\tids1 = ids2;\n\t\tids2 = tmp;\n\t}\n\thashmap__for_each_entry(ids2, cur, bkt) {\n\t\tret = hashmap__set(ids1, cur->key, cur->value,\n\t\t\t\t(const void **)&old_key, (void **)&old_data);\n\t\tfree(old_key);\n\t\tfree(old_data);\n\n\t\tif (ret) {\n\t\t\thashmap__free(ids1);\n\t\t\thashmap__free(ids2);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\thashmap__free(ids2);\n\treturn ids1;\n}\n\n/* Caller must make sure id is allocated */\nint expr__add_id(struct expr_parse_ctx *ctx, const char *id)\n{\n\treturn ids__insert(ctx->ids, id);\n}\n\n/* Caller must make sure id is allocated */\nint expr__add_id_val(struct expr_parse_ctx *ctx, const char *id, double val)\n{\n\treturn expr__add_id_val_source_count(ctx, id, val, /*source_count=*/1);\n}\n\n/* Caller must make sure id is allocated */\nint expr__add_id_val_source_count(struct expr_parse_ctx *ctx, const char *id,\n\t\t\t\t  double val, int source_count)\n{\n\tstruct expr_id_data *data_ptr = NULL, *old_data = NULL;\n\tchar *old_key = NULL;\n\tint ret;\n\n\tdata_ptr = malloc(sizeof(*data_ptr));\n\tif (!data_ptr)\n\t\treturn -ENOMEM;\n\tdata_ptr->val.val = val;\n\tdata_ptr->val.source_count = source_count;\n\tdata_ptr->kind = EXPR_ID_DATA__VALUE;\n\n\tret = hashmap__set(ctx->ids, id, data_ptr,\n\t\t\t   (const void **)&old_key, (void **)&old_data);\n\tif (ret)\n\t\tfree(data_ptr);\n\tfree(old_key);\n\tfree(old_data);\n\treturn ret;\n}\n\nint expr__add_ref(struct expr_parse_ctx *ctx, struct metric_ref *ref)\n{\n\tstruct expr_id_data *data_ptr = NULL, *old_data = NULL;\n\tchar *old_key = NULL;\n\tchar *name, *p;\n\tint ret;\n\n\tdata_ptr = zalloc(sizeof(*data_ptr));\n\tif (!data_ptr)\n\t\treturn -ENOMEM;\n\n\tname = strdup(ref->metric_name);\n\tif (!name) {\n\t\tfree(data_ptr);\n\t\treturn -ENOMEM;\n\t}\n\n\t/*\n\t * The jevents tool converts all metric expressions\n\t * to lowercase, including metric references, hence\n\t * we need to add lowercase name for metric, so it's\n\t * properly found.\n\t */\n\tfor (p = name; *p; p++)\n\t\t*p = tolower(*p);\n\n\t/*\n\t * Intentionally passing just const char pointers,\n\t * originally from 'struct pmu_event' object.\n\t * We don't need to change them, so there's no\n\t * need to create our own copy.\n\t */\n\tdata_ptr->ref.metric_name = ref->metric_name;\n\tdata_ptr->ref.metric_expr = ref->metric_expr;\n\tdata_ptr->kind = EXPR_ID_DATA__REF;\n\n\tret = hashmap__set(ctx->ids, name, data_ptr,\n\t\t\t   (const void **)&old_key, (void **)&old_data);\n\tif (ret)\n\t\tfree(data_ptr);\n\n\tpr_debug2(\"adding ref metric %s: %s\\n\",\n\t\t  ref->metric_name, ref->metric_expr);\n\n\tfree(old_key);\n\tfree(old_data);\n\treturn ret;\n}\n\nint expr__get_id(struct expr_parse_ctx *ctx, const char *id,\n\t\t struct expr_id_data **data)\n{\n\treturn hashmap__find(ctx->ids, id, (void **)data) ? 0 : -1;\n}\n\nbool expr__subset_of_ids(struct expr_parse_ctx *haystack,\n\t\t\t struct expr_parse_ctx *needles)\n{\n\tstruct hashmap_entry *cur;\n\tsize_t bkt;\n\tstruct expr_id_data *data;\n\n\thashmap__for_each_entry(needles->ids, cur, bkt) {\n\t\tif (expr__get_id(haystack, cur->key, &data))\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\n\nint expr__resolve_id(struct expr_parse_ctx *ctx, const char *id,\n\t\t     struct expr_id_data **datap)\n{\n\tstruct expr_id_data *data;\n\n\tif (expr__get_id(ctx, id, datap) || !*datap) {\n\t\tpr_debug(\"%s not found\\n\", id);\n\t\treturn -1;\n\t}\n\n\tdata = *datap;\n\n\tswitch (data->kind) {\n\tcase EXPR_ID_DATA__VALUE:\n\t\tpr_debug2(\"lookup(%s): val %f\\n\", id, data->val.val);\n\t\tbreak;\n\tcase EXPR_ID_DATA__REF:\n\t\tpr_debug2(\"lookup(%s): ref metric name %s\\n\", id,\n\t\t\tdata->ref.metric_name);\n\t\tpr_debug(\"processing metric: %s ENTRY\\n\", id);\n\t\tdata->kind = EXPR_ID_DATA__REF_VALUE;\n\t\tif (expr__parse(&data->ref.val, ctx, data->ref.metric_expr)) {\n\t\t\tpr_debug(\"%s failed to count\\n\", id);\n\t\t\treturn -1;\n\t\t}\n\t\tpr_debug(\"processing metric: %s EXIT: %f\\n\", id, data->ref.val);\n\t\tbreak;\n\tcase EXPR_ID_DATA__REF_VALUE:\n\t\tpr_debug2(\"lookup(%s): ref val %f metric name %s\\n\", id,\n\t\t\tdata->ref.val, data->ref.metric_name);\n\t\tbreak;\n\tdefault:\n\t\tassert(0);  /* Unreachable. */\n\t}\n\n\treturn 0;\n}\n\nvoid expr__del_id(struct expr_parse_ctx *ctx, const char *id)\n{\n\tstruct expr_id_data *old_val = NULL;\n\tchar *old_key = NULL;\n\n\thashmap__delete(ctx->ids, id,\n\t\t\t(const void **)&old_key, (void **)&old_val);\n\tfree(old_key);\n\tfree(old_val);\n}\n\nstruct expr_parse_ctx *expr__ctx_new(void)\n{\n\tstruct expr_parse_ctx *ctx;\n\n\tctx = malloc(sizeof(struct expr_parse_ctx));\n\tif (!ctx)\n\t\treturn NULL;\n\n\tctx->ids = hashmap__new(key_hash, key_equal, NULL);\n\tctx->runtime = 0;\n\n\treturn ctx;\n}\n\nvoid expr__ctx_clear(struct expr_parse_ctx *ctx)\n{\n\tstruct hashmap_entry *cur;\n\tsize_t bkt;\n\n\thashmap__for_each_entry(ctx->ids, cur, bkt) {\n\t\tfree((char *)cur->key);\n\t\tfree(cur->value);\n\t}\n\thashmap__clear(ctx->ids);\n}\n\nvoid expr__ctx_free(struct expr_parse_ctx *ctx)\n{\n\tstruct hashmap_entry *cur;\n\tsize_t bkt;\n\n\thashmap__for_each_entry(ctx->ids, cur, bkt) {\n\t\tfree((char *)cur->key);\n\t\tfree(cur->value);\n\t}\n\thashmap__free(ctx->ids);\n\tfree(ctx);\n}\n\nstatic int\n__expr__parse(double *val, struct expr_parse_ctx *ctx, const char *expr,\n\t      bool compute_ids)\n{\n\tstruct expr_scanner_ctx scanner_ctx = {\n\t\t.runtime = ctx->runtime,\n\t};\n\tYY_BUFFER_STATE buffer;\n\tvoid *scanner;\n\tint ret;\n\n\tpr_debug2(\"parsing metric: %s\\n\", expr);\n\n\tret = expr_lex_init_extra(&scanner_ctx, &scanner);\n\tif (ret)\n\t\treturn ret;\n\n\tbuffer = expr__scan_string(expr, scanner);\n\n#ifdef PARSER_DEBUG\n\texpr_debug = 1;\n\texpr_set_debug(1, scanner);\n#endif\n\n\tret = expr_parse(val, ctx, compute_ids, scanner);\n\n\texpr__flush_buffer(buffer, scanner);\n\texpr__delete_buffer(buffer, scanner);\n\texpr_lex_destroy(scanner);\n\treturn ret;\n}\n\nint expr__parse(double *final_val, struct expr_parse_ctx *ctx,\n\t\tconst char *expr)\n{\n\treturn __expr__parse(final_val, ctx, expr, /*compute_ids=*/false) ? -1 : 0;\n}\n\nint expr__find_ids(const char *expr, const char *one,\n\t\t   struct expr_parse_ctx *ctx)\n{\n\tint ret = __expr__parse(NULL, ctx, expr, /*compute_ids=*/true);\n\n\tif (one)\n\t\texpr__del_id(ctx, one);\n\n\treturn ret;\n}\n\ndouble expr_id_data__value(const struct expr_id_data *data)\n{\n\tif (data->kind == EXPR_ID_DATA__VALUE)\n\t\treturn data->val.val;\n\tassert(data->kind == EXPR_ID_DATA__REF_VALUE);\n\treturn data->ref.val;\n}\n\ndouble expr_id_data__source_count(const struct expr_id_data *data)\n{\n\tassert(data->kind == EXPR_ID_DATA__VALUE);\n\treturn data->val.source_count;\n}\n\ndouble expr__get_literal(const char *literal)\n{\n\tstatic struct cpu_topology *topology;\n\n\tif (!strcmp(\"#smt_on\", literal))\n\t\treturn smt_on() > 0 ? 1.0 : 0.0;\n\n\tif (!strcmp(\"#num_cpus\", literal))\n\t\treturn cpu__max_present_cpu();\n\n\t/*\n\t * Assume that topology strings are consistent, such as CPUs \"0-1\"\n\t * wouldn't be listed as \"0,1\", and so after deduplication the number of\n\t * these strings gives an indication of the number of packages, dies,\n\t * etc.\n\t */\n\tif (!topology) {\n\t\ttopology = cpu_topology__new();\n\t\tif (!topology) {\n\t\t\tpr_err(\"Error creating CPU topology\");\n\t\t\treturn NAN;\n\t\t}\n\t}\n\tif (!strcmp(\"#num_packages\", literal))\n\t\treturn topology->package_cpus_lists;\n\tif (!strcmp(\"#num_dies\", literal))\n\t\treturn topology->die_cpus_lists;\n\tif (!strcmp(\"#num_cores\", literal))\n\t\treturn topology->core_cpus_lists;\n\n\tpr_err(\"Unrecognized literal '%s'\", literal);\n\treturn NAN;\n}\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0\n#include <stdbool.h>\n#include <assert.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"metricgroup.h\"\n#include \"cpumap.h\"\n#include \"cputopo.h\"\n#include \"debug.h\"\n#include \"expr.h\"\n#include \"expr-bison.h\"\n#include \"expr-flex.h\"\n#include \"smt.h\"\n#include <linux/err.h>\n#include <linux/kernel.h>\n#include <linux/zalloc.h>\n#include <ctype.h>\n#include <math.h>\n\n#ifdef PARSER_DEBUG\nextern int expr_debug;\n#endif\n\nstruct expr_id_data {\n\tunion {\n\t\tstruct {\n\t\t\tdouble val;\n\t\t\tint source_count;\n\t\t} val;\n\t\tstruct {\n\t\t\tdouble val;\n\t\t\tconst char *metric_name;\n\t\t\tconst char *metric_expr;\n\t\t} ref;\n\t};\n\n\tenum {\n\t\t/* Holding a double value. */\n\t\tEXPR_ID_DATA__VALUE,\n\t\t/* Reference to another metric. */\n\t\tEXPR_ID_DATA__REF,\n\t\t/* A reference but the value has been computed. */\n\t\tEXPR_ID_DATA__REF_VALUE,\n\t} kind;\n};\n\nstatic size_t key_hash(const void *key, void *ctx __maybe_unused)\n{\n\tconst char *str = (const char *)key;\n\tsize_t hash = 0;\n\n\twhile (*str != '\\0') {\n\t\thash *= 31;\n\t\thash += *str;\n\t\tstr++;\n\t}\n\treturn hash;\n}\n\nstatic bool key_equal(const void *key1, const void *key2,\n\t\t    void *ctx __maybe_unused)\n{\n\treturn !strcmp((const char *)key1, (const char *)key2);\n}\n\nstruct hashmap *ids__new(void)\n{\n\treturn hashmap__new(key_hash, key_equal, NULL);\n}\n\nvoid ids__free(struct hashmap *ids)\n{\n\tstruct hashmap_entry *cur;\n\tsize_t bkt;\n\n\tif (ids == NULL)\n\t\treturn;\n\n\thashmap__for_each_entry(ids, cur, bkt) {\n\t\tfree((char *)cur->key);\n\t\tfree(cur->value);\n\t}\n\n\thashmap__free(ids);\n}\n\nint ids__insert(struct hashmap *ids, const char *id)\n{\n\tstruct expr_id_data *data_ptr = NULL, *old_data = NULL;\n\tchar *old_key = NULL;\n\tint ret;\n\n\tret = hashmap__set(ids, id, data_ptr,\n\t\t\t   (const void **)&old_key, (void **)&old_data);\n\tif (ret)\n\t\tfree(data_ptr);\n\tfree(old_key);\n\tfree(old_data);\n\treturn ret;\n}\n\nstruct hashmap *ids__union(struct hashmap *ids1, struct hashmap *ids2)\n{\n\tsize_t bkt;\n\tstruct hashmap_entry *cur;\n\tint ret;\n\tstruct expr_id_data *old_data = NULL;\n\tchar *old_key = NULL;\n\n\tif (!ids1)\n\t\treturn ids2;\n\n\tif (!ids2)\n\t\treturn ids1;\n\n\tif (hashmap__size(ids1) <  hashmap__size(ids2)) {\n\t\tstruct hashmap *tmp = ids1;\n\n\t\tids1 = ids2;\n\t\tids2 = tmp;\n\t}\n\thashmap__for_each_entry(ids2, cur, bkt) {\n\t\tret = hashmap__set(ids1, cur->key, cur->value,\n\t\t\t\t(const void **)&old_key, (void **)&old_data);\n\t\tfree(old_key);\n\t\tfree(old_data);\n\n\t\tif (ret) {\n\t\t\thashmap__free(ids1);\n\t\t\thashmap__free(ids2);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\thashmap__free(ids2);\n\treturn ids1;\n}\n\n/* Caller must make sure id is allocated */\nint expr__add_id(struct expr_parse_ctx *ctx, const char *id)\n{\n\treturn ids__insert(ctx->ids, id);\n}\n\n/* Caller must make sure id is allocated */\nint expr__add_id_val(struct expr_parse_ctx *ctx, const char *id, double val)\n{\n\treturn expr__add_id_val_source_count(ctx, id, val, /*source_count=*/1);\n}\n\n/* Caller must make sure id is allocated */\nint expr__add_id_val_source_count(struct expr_parse_ctx *ctx, const char *id,\n\t\t\t\t  double val, int source_count)\n{\n\tstruct expr_id_data *data_ptr = NULL, *old_data = NULL;\n\tchar *old_key = NULL;\n\tint ret;\n\n\tdata_ptr = malloc(sizeof(*data_ptr));\n\tif (!data_ptr)\n\t\treturn -ENOMEM;\n\tdata_ptr->val.val = val;\n\tdata_ptr->val.source_count = source_count;\n\tdata_ptr->kind = EXPR_ID_DATA__VALUE;\n\n\tret = hashmap__set(ctx->ids, id, data_ptr,\n\t\t\t   (const void **)&old_key, (void **)&old_data);\n\tif (ret)\n\t\tfree(data_ptr);\n\tfree(old_key);\n\tfree(old_data);\n\treturn ret;\n}\n\nint expr__add_ref(struct expr_parse_ctx *ctx, struct metric_ref *ref)\n{\n\tstruct expr_id_data *data_ptr = NULL, *old_data = NULL;\n\tchar *old_key = NULL;\n\tchar *name, *p;\n\tint ret;\n\n\tdata_ptr = zalloc(sizeof(*data_ptr));\n\tif (!data_ptr)\n\t\treturn -ENOMEM;\n\n\tname = strdup(ref->metric_name);\n\tif (!name) {\n\t\tfree(data_ptr);\n\t\treturn -ENOMEM;\n\t}\n\n\t/*\n\t * The jevents tool converts all metric expressions\n\t * to lowercase, including metric references, hence\n\t * we need to add lowercase name for metric, so it's\n\t * properly found.\n\t */\n\tfor (p = name; *p; p++)\n\t\t*p = tolower(*p);\n\n\t/*\n\t * Intentionally passing just const char pointers,\n\t * originally from 'struct pmu_event' object.\n\t * We don't need to change them, so there's no\n\t * need to create our own copy.\n\t */\n\tdata_ptr->ref.metric_name = ref->metric_name;\n\tdata_ptr->ref.metric_expr = ref->metric_expr;\n\tdata_ptr->kind = EXPR_ID_DATA__REF;\n\n\tret = hashmap__set(ctx->ids, name, data_ptr,\n\t\t\t   (const void **)&old_key, (void **)&old_data);\n\tif (ret)\n\t\tfree(data_ptr);\n\n\tpr_debug2(\"adding ref metric %s: %s\\n\",\n\t\t  ref->metric_name, ref->metric_expr);\n\n\tfree(old_key);\n\tfree(old_data);\n\treturn ret;\n}\n\nint expr__get_id(struct expr_parse_ctx *ctx, const char *id,\n\t\t struct expr_id_data **data)\n{\n\treturn hashmap__find(ctx->ids, id, (void **)data) ? 0 : -1;\n}\n\nbool expr__subset_of_ids(struct expr_parse_ctx *haystack,\n\t\t\t struct expr_parse_ctx *needles)\n{\n\tstruct hashmap_entry *cur;\n\tsize_t bkt;\n\tstruct expr_id_data *data;\n\n\thashmap__for_each_entry(needles->ids, cur, bkt) {\n\t\tif (expr__get_id(haystack, cur->key, &data))\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\n\nint expr__resolve_id(struct expr_parse_ctx *ctx, const char *id,\n\t\t     struct expr_id_data **datap)\n{\n\tstruct expr_id_data *data;\n\n\tif (expr__get_id(ctx, id, datap) || !*datap) {\n\t\tpr_debug(\"%s not found\\n\", id);\n\t\treturn -1;\n\t}\n\n\tdata = *datap;\n\n\tswitch (data->kind) {\n\tcase EXPR_ID_DATA__VALUE:\n\t\tpr_debug2(\"lookup(%s): val %f\\n\", id, data->val.val);\n\t\tbreak;\n\tcase EXPR_ID_DATA__REF:\n\t\tpr_debug2(\"lookup(%s): ref metric name %s\\n\", id,\n\t\t\tdata->ref.metric_name);\n\t\tpr_debug(\"processing metric: %s ENTRY\\n\", id);\n\t\tdata->kind = EXPR_ID_DATA__REF_VALUE;\n\t\tif (expr__parse(&data->ref.val, ctx, data->ref.metric_expr)) {\n\t\t\tpr_debug(\"%s failed to count\\n\", id);\n\t\t\treturn -1;\n\t\t}\n\t\tpr_debug(\"processing metric: %s EXIT: %f\\n\", id, data->ref.val);\n\t\tbreak;\n\tcase EXPR_ID_DATA__REF_VALUE:\n\t\tpr_debug2(\"lookup(%s): ref val %f metric name %s\\n\", id,\n\t\t\tdata->ref.val, data->ref.metric_name);\n\t\tbreak;\n\tdefault:\n\t\tassert(0);  /* Unreachable. */\n\t}\n\n\treturn 0;\n}\n\nvoid expr__del_id(struct expr_parse_ctx *ctx, const char *id)\n{\n\tstruct expr_id_data *old_val = NULL;\n\tchar *old_key = NULL;\n\n\thashmap__delete(ctx->ids, id,\n\t\t\t(const void **)&old_key, (void **)&old_val);\n\tfree(old_key);\n\tfree(old_val);\n}\n\nstruct expr_parse_ctx *expr__ctx_new(void)\n{\n\tstruct expr_parse_ctx *ctx;\n\n\tctx = malloc(sizeof(struct expr_parse_ctx));\n\tif (!ctx)\n\t\treturn NULL;\n\n\tctx->ids = hashmap__new(key_hash, key_equal, NULL);\n\tif (IS_ERR(ctx->ids)) {\n\t\tfree(ctx);\n\t\treturn NULL;\n\t}\n\tctx->runtime = 0;\n\n\treturn ctx;\n}\n\nvoid expr__ctx_clear(struct expr_parse_ctx *ctx)\n{\n\tstruct hashmap_entry *cur;\n\tsize_t bkt;\n\n\thashmap__for_each_entry(ctx->ids, cur, bkt) {\n\t\tfree((char *)cur->key);\n\t\tfree(cur->value);\n\t}\n\thashmap__clear(ctx->ids);\n}\n\nvoid expr__ctx_free(struct expr_parse_ctx *ctx)\n{\n\tstruct hashmap_entry *cur;\n\tsize_t bkt;\n\n\thashmap__for_each_entry(ctx->ids, cur, bkt) {\n\t\tfree((char *)cur->key);\n\t\tfree(cur->value);\n\t}\n\thashmap__free(ctx->ids);\n\tfree(ctx);\n}\n\nstatic int\n__expr__parse(double *val, struct expr_parse_ctx *ctx, const char *expr,\n\t      bool compute_ids)\n{\n\tstruct expr_scanner_ctx scanner_ctx = {\n\t\t.runtime = ctx->runtime,\n\t};\n\tYY_BUFFER_STATE buffer;\n\tvoid *scanner;\n\tint ret;\n\n\tpr_debug2(\"parsing metric: %s\\n\", expr);\n\n\tret = expr_lex_init_extra(&scanner_ctx, &scanner);\n\tif (ret)\n\t\treturn ret;\n\n\tbuffer = expr__scan_string(expr, scanner);\n\n#ifdef PARSER_DEBUG\n\texpr_debug = 1;\n\texpr_set_debug(1, scanner);\n#endif\n\n\tret = expr_parse(val, ctx, compute_ids, scanner);\n\n\texpr__flush_buffer(buffer, scanner);\n\texpr__delete_buffer(buffer, scanner);\n\texpr_lex_destroy(scanner);\n\treturn ret;\n}\n\nint expr__parse(double *final_val, struct expr_parse_ctx *ctx,\n\t\tconst char *expr)\n{\n\treturn __expr__parse(final_val, ctx, expr, /*compute_ids=*/false) ? -1 : 0;\n}\n\nint expr__find_ids(const char *expr, const char *one,\n\t\t   struct expr_parse_ctx *ctx)\n{\n\tint ret = __expr__parse(NULL, ctx, expr, /*compute_ids=*/true);\n\n\tif (one)\n\t\texpr__del_id(ctx, one);\n\n\treturn ret;\n}\n\ndouble expr_id_data__value(const struct expr_id_data *data)\n{\n\tif (data->kind == EXPR_ID_DATA__VALUE)\n\t\treturn data->val.val;\n\tassert(data->kind == EXPR_ID_DATA__REF_VALUE);\n\treturn data->ref.val;\n}\n\ndouble expr_id_data__source_count(const struct expr_id_data *data)\n{\n\tassert(data->kind == EXPR_ID_DATA__VALUE);\n\treturn data->val.source_count;\n}\n\ndouble expr__get_literal(const char *literal)\n{\n\tstatic struct cpu_topology *topology;\n\n\tif (!strcmp(\"#smt_on\", literal))\n\t\treturn smt_on() > 0 ? 1.0 : 0.0;\n\n\tif (!strcmp(\"#num_cpus\", literal))\n\t\treturn cpu__max_present_cpu();\n\n\t/*\n\t * Assume that topology strings are consistent, such as CPUs \"0-1\"\n\t * wouldn't be listed as \"0,1\", and so after deduplication the number of\n\t * these strings gives an indication of the number of packages, dies,\n\t * etc.\n\t */\n\tif (!topology) {\n\t\ttopology = cpu_topology__new();\n\t\tif (!topology) {\n\t\t\tpr_err(\"Error creating CPU topology\");\n\t\t\treturn NAN;\n\t\t}\n\t}\n\tif (!strcmp(\"#num_packages\", literal))\n\t\treturn topology->package_cpus_lists;\n\tif (!strcmp(\"#num_dies\", literal))\n\t\treturn topology->die_cpus_lists;\n\tif (!strcmp(\"#num_cores\", literal))\n\t\treturn topology->core_cpus_lists;\n\n\tpr_err(\"Unrecognized literal '%s'\", literal);\n\treturn NAN;\n}\n"], "filenames": ["tools/perf/util/expr.c"], "buggy_code_start_loc": [14], "buggy_code_end_loc": [301], "fixing_code_start_loc": [15], "fixing_code_end_loc": [307], "type": "CWE-252", "message": "In the Linux kernel before 5.16, tools/perf/util/expr.c lacks a check for the hashmap__new return value.", "other": {"cve": {"id": "CVE-2023-23003", "sourceIdentifier": "cve@mitre.org", "published": "2023-03-01T20:15:14.233", "lastModified": "2023-03-31T11:15:07.037", "vulnStatus": "Undergoing Analysis", "descriptions": [{"lang": "en", "value": "In the Linux kernel before 5.16, tools/perf/util/expr.c lacks a check for the hashmap__new return value."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-252"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.16", "matchCriteriaId": "D692A2AE-8E9E-46AE-8670-7E1284317A25"}]}]}], "references": [{"url": "https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.16", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/0a515a06c5ebfa46fee3ac519e418f801e718da4", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://security.netapp.com/advisory/ntap-20230331-0003/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/0a515a06c5ebfa46fee3ac519e418f801e718da4"}}