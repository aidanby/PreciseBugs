{"buggy_code": ["/*\n   +----------------------------------------------------------------------+\n   | HipHop for PHP                                                       |\n   +----------------------------------------------------------------------+\n   | Copyright (c) 2010-present Facebook, Inc. (http://www.facebook.com)  |\n   | Copyright (c) 1997-2010 The PHP Group                                |\n   +----------------------------------------------------------------------+\n   | This source file is subject to version 3.01 of the PHP license,      |\n   | that is bundled with this package in the file LICENSE, and is        |\n   | available through the world-wide-web at the following url:           |\n   | http://www.php.net/license/3_01.txt                                  |\n   | If you did not receive a copy of the PHP license and are unable to   |\n   | obtain it through the world-wide-web, please send a note to          |\n   | license@php.net so we can mail you a copy immediately.               |\n   +----------------------------------------------------------------------+\n*/\n#include \"hphp/runtime/ext/apc/ext_apc.h\"\n\n#include <fstream>\n\n#ifndef _MSC_VER\n#include <dlfcn.h>\n#endif\n#include <memory>\n#include <set>\n#include <vector>\n#include <stdexcept>\n#include <type_traits>\n\n#include <folly/portability/SysTime.h>\n\n#include \"hphp/util/alloc.h\"\n#include \"hphp/util/async-job.h\"\n#include \"hphp/util/boot-stats.h\"\n#include \"hphp/util/hdf.h\"\n#include \"hphp/util/logger.h\"\n\n#include \"hphp/runtime/base/apc-file-storage.h\"\n#include \"hphp/runtime/base/array-init.h\"\n#include \"hphp/runtime/base/builtin-functions.h\"\n#include \"hphp/runtime/base/comparisons.h\"\n#include \"hphp/runtime/base/concurrent-shared-store.h\"\n#include \"hphp/runtime/base/config.h\"\n#include \"hphp/runtime/base/execution-context.h\"\n#include \"hphp/runtime/base/ini-setting.h\"\n#include \"hphp/runtime/base/program-functions.h\"\n#include \"hphp/runtime/base/runtime-option.h\"\n#include \"hphp/runtime/base/variable-serializer.h\"\n#include \"hphp/runtime/ext/apc/snapshot-builder.h\"\n#include \"hphp/runtime/ext/fb/ext_fb.h\"\n#include \"hphp/runtime/server/cli-server.h\"\n\nusing HPHP::ScopedMem;\n\nnamespace HPHP {\n///////////////////////////////////////////////////////////////////////////////\n\nnamespace {\n\nstd::aligned_storage<\n  sizeof(ConcurrentTableSharedStore),\n  alignof(ConcurrentTableSharedStore)\n>::type s_apc_storage;\n\nusing UserAPCCache = folly::AtomicHashMap<uid_t, ConcurrentTableSharedStore*>;\n\nstd::aligned_storage<\n  sizeof(UserAPCCache),\n  alignof(UserAPCCache)\n>::type s_user_apc_storage;\n\nUserAPCCache& apc_store_local() {\n  void* vpUserStore = &s_user_apc_storage;\n  return *static_cast<UserAPCCache*>(vpUserStore);\n}\n\nConcurrentTableSharedStore& apc_store_local(uid_t uid) {\n  auto& cache = apc_store_local();\n  auto iter = cache.find(uid);\n  if (iter != cache.end()) return *(iter->second);\n  auto table = new ConcurrentTableSharedStore;\n  auto res = cache.insert(uid, table);\n  if (!res.second) delete table;\n  return *res.first->second;\n}\n\nConcurrentTableSharedStore& apc_store() {\n  if (UNLIKELY(!RuntimeOption::RepoAuthoritative &&\n               RuntimeOption::EvalUnixServerQuarantineApc)) {\n    if (auto uc = get_cli_ucred()) {\n      return apc_store_local(uc->uid);\n    }\n  }\n  void* vpStore = &s_apc_storage;\n  return *static_cast<ConcurrentTableSharedStore*>(vpStore);\n}\n\n}\n\n//////////////////////////////////////////////////////////////////////\n\nvoid initialize_apc() {\n  APCStats::Create();\n  // Note: we never destruct APC, currently.\n  void* vpStore = &s_apc_storage;\n  new (vpStore) ConcurrentTableSharedStore;\n\n  if (UNLIKELY(!RuntimeOption::RepoAuthoritative &&\n               RuntimeOption::EvalUnixServerQuarantineApc)) {\n    new (&s_user_apc_storage) UserAPCCache(10);\n  }\n}\n\n//////////////////////////////////////////////////////////////////////\n\nconst StaticString\n  s_delete(\"delete\");\n\nextern void const_load();\n\ntypedef ConcurrentTableSharedStore::KeyValuePair KeyValuePair;\ntypedef ConcurrentTableSharedStore::DumpMode DumpMode;\n\nstatic void* keep_alive;\n\nvoid apcExtension::moduleLoad(const IniSetting::Map& ini, Hdf config) {\n  if (!keep_alive && ini.isString()) {\n    // this is a hack to preserve some dynamic entry points\n    switch (ini.toString().size()) {\n      case 0: keep_alive = (void*)const_load; break;\n      case 2: keep_alive = (void*)const_load_impl_compressed; break;\n      case 4: keep_alive = (void*)apc_load_impl_compressed; break;\n    }\n  }\n\n  Config::Bind(Enable, ini, config, \"Server.APC.EnableApc\", true);\n  Config::Bind(EnableConstLoad, ini, config, \"Server.APC.EnableConstLoad\",\n               false);\n  Config::Bind(ForceConstLoadToAPC, ini, config,\n               \"Server.APC.ForceConstLoadToAPC\", true);\n  Config::Bind(PrimeLibrary, ini, config, \"Server.APC.PrimeLibrary\");\n  Config::Bind(LoadThread, ini, config, \"Server.APC.LoadThread\", 15);\n  Config::Bind(CompletionKeys, ini, config, \"Server.APC.CompletionKeys\");\n  Config::Bind(EnableApcSerialize, ini, config, \"Server.APC.EnableApcSerialize\",\n               true);\n  Config::Bind(ExpireOnSets, ini, config, \"Server.APC.ExpireOnSets\");\n  Config::Bind(PurgeFrequency, ini, config, \"Server.APC.PurgeFrequency\", 4096);\n  Config::Bind(PurgeRate, ini, config, \"Server.APC.PurgeRate\", -1);\n\n  Config::Bind(AllowObj, ini, config, \"Server.APC.AllowObject\");\n  Config::Bind(TTLLimit, ini, config, \"Server.APC.TTLLimit\", -1);\n  // Any TTL > TTLMaxFinite will be made infinite. NB: Applied *after* TTLLimit.\n  Config::Bind(TTLMaxFinite, ini, config, \"Server.APC.TTLMaxFinite\",\n               std::numeric_limits<int64_t>::max());\n  Config::Bind(HotPrefix, ini, config, \"Server.APC.HotPrefix\");\n  Config::Bind(HotSize, ini, config, \"Server.APC.HotSize\", 30000);\n  Config::Bind(HotLoadFactor, ini, config, \"Server.APC.HotLoadFactor\", 0.5);\n  Config::Bind(HotKeyAllocLow, ini, config, \"Server.APC.HotKeyAllocLow\", false);\n  Config::Bind(HotMapAllocLow, ini, config, \"Server.APC.HotMapAllocLow\", false);\n\n  // Loads .so PrimeLibrary, writes snapshot output to this file, then exits.\n  Config::Bind(PrimeLibraryUpgradeDest, ini, config,\n               \"Server.APC.PrimeLibraryUpgradeDest\");\n\n  // FileStorage\n  Config::Bind(UseFileStorage, ini, config, \"Server.APC.FileStorage.Enable\");\n  FileStorageChunkSize = Config::GetInt64(ini, config,\n                                          \"Server.APC.FileStorage.ChunkSize\",\n                                          1LL << 29);\n  Config::Bind(FileStoragePrefix, ini, config, \"Server.APC.FileStorage.Prefix\",\n               \"/tmp/apc_store\");\n  Config::Bind(FileStorageFlagKey, ini, config,\n               \"Server.APC.FileStorage.FlagKey\", \"_madvise_out\");\n  Config::Bind(FileStorageAdviseOutPeriod, ini, config,\n               \"Server.APC.FileStorage.AdviseOutPeriod\", 1800);\n  Config::Bind(FileStorageKeepFileLinked, ini, config,\n               \"Server.APC.FileStorage.KeepFileLinked\");\n\n#ifdef NO_M_DATA\n  Config::Bind(UseUncounted, ini, config, \"Server.APC.MemModelTreadmill\", true);\n#else\n  Config::Bind(UseUncounted, ini, config, \"Server.APC.MemModelTreadmill\",\n               RuntimeOption::ServerExecutionMode());\n#endif\n  Config::Bind(ShareUncounted, ini, config, \"Server.APC.ShareUncounted\", true);\n  if (!UseUncounted && ShareUncounted) ShareUncounted = false;\n\n  IniSetting::Bind(this, IniSetting::PHP_INI_SYSTEM, \"apc.enabled\", &Enable);\n  IniSetting::Bind(this, IniSetting::PHP_INI_SYSTEM, \"apc.stat\",\n                   RuntimeOption::RepoAuthoritative ? \"0\" : \"1\", &Stat);\n  IniSetting::Bind(this, IniSetting::PHP_INI_SYSTEM, \"apc.enable_cli\",\n                   &EnableCLI);\n}\n\nvoid apcExtension::moduleInit() {\n#ifdef NO_M_DATA\n  if (!UseUncounted) {\n    Logger::Error(\"Server.APC.MemModelTreadmill=false ignored in lowptr build\");\n    UseUncounted = true;\n  }\n#endif // NO_M_DATA\n  if (UseFileStorage) {\n    // We use 32 bits to represent offset into a chunk, so don't make it too\n    // large.\n    constexpr int64_t MaxChunkSize = 1LL << 31;\n    if (FileStorageChunkSize > MaxChunkSize) {\n      Logger::Warning(\"Server.APC.FileStorage.ChunkSize too large, \"\n                      \"resetting to %\" PRId64, MaxChunkSize);\n      FileStorageChunkSize = MaxChunkSize;\n    }\n    s_apc_file_storage.enable(FileStoragePrefix, FileStorageChunkSize);\n  }\n\n  HHVM_RC_INT(APC_ITER_TYPE, 0x1);\n  HHVM_RC_INT(APC_ITER_KEY, 0x2);\n  HHVM_RC_INT(APC_ITER_FILENAME, 0x4);\n  HHVM_RC_INT(APC_ITER_DEVICE, 0x8);\n  HHVM_RC_INT(APC_ITER_INODE, 0x10);\n  HHVM_RC_INT(APC_ITER_VALUE, 0x20);\n  HHVM_RC_INT(APC_ITER_MD5, 0x40);\n  HHVM_RC_INT(APC_ITER_NUM_HITS, 0x80);\n  HHVM_RC_INT(APC_ITER_MTIME, 0x100);\n  HHVM_RC_INT(APC_ITER_CTIME, 0x200);\n  HHVM_RC_INT(APC_ITER_DTIME, 0x400);\n  HHVM_RC_INT(APC_ITER_ATIME, 0x800);\n  HHVM_RC_INT(APC_ITER_REFCOUNT, 0x1000);\n  HHVM_RC_INT(APC_ITER_MEM_SIZE, 0x2000);\n  HHVM_RC_INT(APC_ITER_TTL, 0x4000);\n  HHVM_RC_INT(APC_ITER_NONE, 0x0);\n  HHVM_RC_INT(APC_ITER_ALL, 0xFFFFFFFFFF);\n  HHVM_RC_INT(APC_LIST_ACTIVE, 1);\n  HHVM_RC_INT(APC_LIST_DELETED, 2);\n\n  HHVM_FE(apc_add);\n  HHVM_FE(apc_store);\n  HHVM_FE(apc_store_as_primed_do_not_use);\n  HHVM_FE(apc_fetch);\n  HHVM_FE(apc_delete);\n  HHVM_FE(apc_clear_cache);\n  HHVM_FE(apc_inc);\n  HHVM_FE(apc_dec);\n  HHVM_FE(apc_cas);\n  HHVM_FE(apc_exists);\n  HHVM_FE(apc_size);\n  HHVM_FE(apc_cache_info);\n  HHVM_FE(apc_sma_info);\n  loadSystemlib();\n}\n\nvoid apcExtension::moduleShutdown() {\n  if (UseFileStorage) {\n    s_apc_file_storage.cleanup();\n  }\n}\n\n\nbool apcExtension::Enable = true;\nbool apcExtension::EnableConstLoad = false;\nbool apcExtension::ForceConstLoadToAPC = true;\nstd::string apcExtension::PrimeLibrary;\nint apcExtension::LoadThread = 15;\nstd::set<std::string> apcExtension::CompletionKeys;\nbool apcExtension::EnableApcSerialize = true;\nbool apcExtension::ExpireOnSets = false;\nint apcExtension::PurgeFrequency = 4096;\nint apcExtension::PurgeRate = -1;\nbool apcExtension::AllowObj = false;\nint apcExtension::TTLLimit = -1;\nint64_t apcExtension::TTLMaxFinite = std::numeric_limits<int64_t>::max();\nint apcExtension::HotSize = 30000;\ndouble apcExtension::HotLoadFactor = 0.5;\nstd::vector<std::string> apcExtension::HotPrefix;\nbool apcExtension::HotKeyAllocLow = false;\nbool apcExtension::HotMapAllocLow = false;\nstd::string apcExtension::PrimeLibraryUpgradeDest;\nbool apcExtension::UseFileStorage = false;\nint64_t apcExtension::FileStorageChunkSize = int64_t(1LL << 29);\nstd::string apcExtension::FileStoragePrefix = \"/tmp/apc_store\";\nint apcExtension::FileStorageAdviseOutPeriod = 1800;\nstd::string apcExtension::FileStorageFlagKey = \"_madvise_out\";\nbool apcExtension::FileStorageKeepFileLinked = false;\n#ifdef NO_M_DATA\nbool apcExtension::UseUncounted = true;\n#else\nbool apcExtension::UseUncounted = false;\n#endif\nbool apcExtension::ShareUncounted = true;\nbool apcExtension::Stat = true;\n// Different from zend default but matches what we've been returning for years\nbool apcExtension::EnableCLI = true;\n\nstatic apcExtension s_apc_extension;\n\nVariant HHVM_FUNCTION(apc_store,\n                      const Variant& key_or_array,\n                      const Variant& var /* = null */,\n                      int64_t ttl /* = 0 */) {\n  if (!apcExtension::Enable) return Variant(false);\n\n  if (key_or_array.isArray()) {\n    Array valuesArr = key_or_array.toArray();\n\n    for (ArrayIter iter(valuesArr); iter; ++iter) {\n      Variant key = iter.first();\n      if (!key.isString()) {\n        throw_invalid_argument(\"apc key: (not a string)\");\n        return Variant(false);\n      }\n      Variant v = iter.second();\n      apc_store().set(key.toString(), v, ttl);\n    }\n\n    return Variant(ArrayData::Create());\n  }\n\n  if (!key_or_array.isString()) {\n    throw_invalid_argument(\"apc key: (not a string)\");\n    return Variant(false);\n  }\n  String strKey = key_or_array.toString();\n  apc_store().set(strKey, var, ttl);\n  return Variant(true);\n}\n\n/**\n * Stores the key in a similar fashion as \"priming\" would do (no TTL limit).\n * Using this function is equivalent to adding your key to apc_prime.so.\n */\nbool HHVM_FUNCTION(apc_store_as_primed_do_not_use,\n                   const String& key,\n                   const Variant& var) {\n  if (!apcExtension::Enable) return false;\n  apc_store().setWithoutTTL(key, var);\n  return true;\n}\n\nVariant HHVM_FUNCTION(apc_add,\n                      const Variant& key_or_array,\n                      const Variant& var /* = null */,\n                      int64_t ttl /* = 0 */) {\n  if (!apcExtension::Enable) return false;\n\n  if (key_or_array.isArray()) {\n    Array valuesArr = key_or_array.toArray();\n\n    // errors stores all keys corresponding to entries that could not be cached\n    ArrayInit errors(valuesArr.size(), ArrayInit::Map{});\n\n    for (ArrayIter iter(valuesArr); iter; ++iter) {\n      Variant key = iter.first();\n      if (!key.isString()) {\n        throw_invalid_argument(\"apc key: (not a string)\");\n        return false;\n      }\n      Variant v = iter.second();\n      if (!apc_store().add(key.toString(), v, ttl)) {\n        errors.add(key, -1);\n      }\n    }\n    return errors.toVariant();\n  }\n\n  if (!key_or_array.isString()) {\n    throw_invalid_argument(\"apc key: (not a string)\");\n    return false;\n  }\n  String strKey = key_or_array.toString();\n  return apc_store().add(strKey, var, ttl);\n}\n\nTypedValue HHVM_FUNCTION(apc_fetch, const Variant& key, bool& success) {\n  if (!apcExtension::Enable) return make_tv<KindOfBoolean>(false);\n\n  Variant v;\n\n  if (key.isArray()) {\n    bool tmp = false;\n    Array keys = key.toArray();\n    ArrayInit init(keys.size(), ArrayInit::Map{});\n    for (ArrayIter iter(keys); iter; ++iter) {\n      Variant k = iter.second();\n      if (!k.isString()) {\n        throw_invalid_argument(\"apc key: (not a string)\");\n        return make_tv<KindOfBoolean>(false);\n      }\n      String strKey = k.toString();\n      if (apc_store().get(strKey, v)) {\n        tmp = true;\n        init.set(strKey, v);\n      }\n    }\n    success = tmp;\n    return tvReturn(init.toVariant());\n  }\n\n  if (apc_store().get(key.toString(), v)) {\n    success = true;\n  } else {\n    success = false;\n    v = false;\n  }\n  return tvReturn(std::move(v));\n}\n\nVariant HHVM_FUNCTION(apc_delete,\n                      const Variant& key) {\n  if (!apcExtension::Enable) return false;\n\n  if (key.isArray()) {\n    Array keys = key.toArray();\n    PackedArrayInit init(keys.size());\n    for (ArrayIter iter(keys); iter; ++iter) {\n      Variant k = iter.second();\n      if (!k.isString()) {\n        raise_warning(\"apc key is not a string\");\n        init.append(k);\n      } else if (!apc_store().eraseKey(k.toCStrRef())) {\n        init.append(k);\n      }\n    }\n    return init.toVariant();\n  } else if(key.is(KindOfObject)) {\n    if (!key.getObjectData()->getVMClass()->\n         classof(SystemLib::s_APCIteratorClass)) {\n      raise_error(\n        \"apc_delete(): apc_delete object argument must be instance\"\n        \" of APCIterator\"\n      );\n      return false;\n    }\n    const Func* method =\n      SystemLib::s_APCIteratorClass->lookupMethod(s_delete.get());\n    return Variant::attach(\n      g_context->invokeFuncFew(method, key.getObjectData())\n    );\n  }\n\n  return apc_store().eraseKey(key.toString());\n}\n\nbool HHVM_FUNCTION(apc_clear_cache, const String& /*cache_type*/ /* = \"\" */) {\n  if (!apcExtension::Enable) return false;\n  return apc_store().clear();\n}\n\nVariant HHVM_FUNCTION(apc_inc,\n                      const String& key,\n                      int64_t step,\n                      bool& success) {\n  if (!apcExtension::Enable) return false;\n\n  bool found = false;\n  int64_t newValue = apc_store().inc(key, step, found);\n  success = found;\n  if (!found) return false;\n  return newValue;\n}\n\nVariant HHVM_FUNCTION(apc_dec,\n                      const String& key,\n                      int64_t step,\n                      bool& success) {\n  if (!apcExtension::Enable) return false;\n\n  bool found = false;\n  int64_t newValue = apc_store().inc(key, -step, found);\n  success = found;\n  if (!found) return false;\n  return newValue;\n}\n\nbool HHVM_FUNCTION(apc_cas,\n                   const String& key,\n                   int64_t old_cas,\n                   int64_t new_cas) {\n  if (!apcExtension::Enable) return false;\n  return apc_store().cas(key, old_cas, new_cas);\n}\n\nVariant HHVM_FUNCTION(apc_exists,\n                      const Variant& key) {\n  if (!apcExtension::Enable) return false;\n\n  if (key.isArray()) {\n    Array keys = key.toArray();\n    PackedArrayInit init(keys.size());\n    for (ArrayIter iter(keys); iter; ++iter) {\n      Variant k = iter.second();\n      if (!k.isString()) {\n        throw_invalid_argument(\"apc key: (not a string)\");\n        return false;\n      }\n      String strKey = k.toString();\n      if (apc_store().exists(strKey)) {\n        init.append(strKey);\n      }\n    }\n    return init.toVariant();\n  }\n\n  return apc_store().exists(key.toString());\n}\n\nTypedValue HHVM_FUNCTION(apc_size, const String& key) {\n  if (!apcExtension::Enable) return make_tv<KindOfNull>();\n\n  bool found = false;\n  int64_t size = apc_store().size(key, found);\n\n  return found ? make_tv<KindOfInt64>(size) : make_tv<KindOfNull>();\n}\n\nconst StaticString s_user(\"user\");\nconst StaticString s_start_time(\"start_time\");\nconst StaticString s_ttl(\"ttl\");\nconst StaticString s_cache_list(\"cache_list\");\nconst StaticString s_info(\"info\");\nconst StaticString s_in_memory(\"in_memory\");\nconst StaticString s_mem_size(\"mem_size\");\nconst StaticString s_type(\"type\");\nconst StaticString s_c_time(\"creation_time\");\nconst StaticString s_mtime(\"mtime\");\n\n// This is a guess to the size of the info array. It is significantly\n// bigger than what we need but hard to control all the info that we\n// may want to add here.\n// Try to keep it such that we do not have to resize the array\nconst uint32_t kCacheInfoSize = 40;\n// Number of elements in the entry array\nconst int32_t kEntryInfoSize = 7;\n\nVariant HHVM_FUNCTION(apc_cache_info,\n                      const String& cache_type,\n                      bool limited /* = false */) {\n  ArrayInit info(kCacheInfoSize, ArrayInit::Map{});\n  info.add(s_start_time, start_time());\n  if (cache_type.size() != 0 && !cache_type.same(s_user)) {\n    return info.toArray();\n  }\n\n  info.add(s_ttl, apcExtension::TTLLimit);\n\n  std::map<const StringData*, int64_t> stats;\n  APCStats::getAPCStats().collectStats(stats);\n  for (auto it = stats.begin(); it != stats.end(); it++) {\n    info.add(Variant(it->first, Variant::PersistentStrInit{}), it->second);\n  }\n  if (!limited) {\n    auto const entries = apc_store().getEntriesInfo();\n    PackedArrayInit ents(entries.size());\n    for (auto& entry : entries) {\n      ArrayInit ent(kEntryInfoSize, ArrayInit::Map{});\n      ent.add(s_info,\n              Variant::attach(StringData::Make(entry.key.c_str())));\n      ent.add(s_in_memory, entry.inMem);\n      ent.add(s_ttl, entry.ttl);\n      ent.add(s_mem_size, entry.size);\n      ent.add(s_type, static_cast<int64_t>(entry.type));\n      ent.add(s_c_time, entry.c_time);\n      ent.add(s_mtime, entry.mtime);\n      ents.append(ent.toArray());\n    }\n    info.add(s_cache_list, ents.toArray(), false);\n  }\n  return info.toArray();\n}\n\nArray HHVM_FUNCTION(apc_sma_info, bool /*limited*/ /* = false */) {\n  return empty_darray();\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// loading APC from archive files\n\ntypedef void(*PFUNC_APC_LOAD)();\n\n// Structure to hold cache meta data\n// Same definition in ext_apc.cpp\nstruct cache_info {\n  char *a_name;\n  bool use_const;\n};\n\nstatic Mutex dl_mutex;\nstatic PFUNC_APC_LOAD apc_load_func(void *handle, const char *name) {\n#ifdef _MSC_VER\n  throw Exception(\"apc_load_func is not currently supported under MSVC!\");\n#else\n  PFUNC_APC_LOAD p = (PFUNC_APC_LOAD)dlsym(handle, name);\n  if (p == nullptr) {\n    throw Exception(\"Unable to find %s in %s\", name,\n                    apcExtension::PrimeLibrary.c_str());\n  }\n  return p;\n#endif\n}\n\nstruct ApcLoadJob {\n  ApcLoadJob(void *handle, int index) : m_handle(handle), m_index(index) {}\n  void *m_handle; int m_index;\n};\n\nstruct ApcLoadWorker {\n  void onThreadEnter() {\n    g_context.getCheck();\n  }\n  void doJob(std::shared_ptr<ApcLoadJob> job) {\n    char func_name[128];\n    MemoryManager::SuppressOOM so(*tl_heap);\n    snprintf(func_name, sizeof(func_name), \"_apc_load_%d\", job->m_index);\n    apc_load_func(job->m_handle, func_name)();\n  }\n  void onThreadExit() {\n    hphp_memory_cleanup();\n  }\n};\n\nstatic size_t s_const_map_size = 0;\n\nstatic SnapshotBuilder s_snapshotBuilder;\n\nvoid apc_load(int thread) {\n#ifndef _MSC_VER\n  static void *handle = nullptr;\n  if (handle ||\n      apcExtension::PrimeLibrary.empty() ||\n      !apcExtension::Enable) {\n    return;\n  }\n  BootStats::Block timer(\"loading APC data\",\n                         RuntimeOption::ServerExecutionMode());\n  if (apc_store().primeFromSnapshot(apcExtension::PrimeLibrary.c_str())) {\n    return;\n  }\n  Logger::Info(\"Fall back to shared object format\");\n  handle = dlopen(apcExtension::PrimeLibrary.c_str(), RTLD_LAZY);\n  if (!handle) {\n    throw Exception(\"Unable to open apc prime library %s: %s\",\n                    apcExtension::PrimeLibrary.c_str(), dlerror());\n  }\n\n  auto upgradeDest = apcExtension::PrimeLibraryUpgradeDest;\n  if (!upgradeDest.empty()) {\n    thread = 1; // SnapshotBuilder is not (yet) thread-safe.\n    // TODO(9755792): Ensure APCFileStorage is enabled.\n  }\n\n  if (thread <= 1) {\n    apc_load_func(handle, \"_apc_load_all\")();\n  } else {\n    int count = ((int(*)())apc_load_func(handle, \"_apc_load_count\"))();\n\n    std::vector<std::shared_ptr<ApcLoadJob>> jobs;\n    jobs.reserve(count);\n    for (int i = 0; i < count; i++) {\n      jobs.push_back(std::make_shared<ApcLoadJob>(handle, i));\n    }\n    JobDispatcher<ApcLoadJob, ApcLoadWorker>(std::move(jobs), thread).run();\n  }\n\n  apc_store().primeDone();\n  if (!upgradeDest.empty()) {\n    s_snapshotBuilder.writeToFile(upgradeDest);\n  }\n\n  // We've copied all the data out, so close it out.\n  dlclose(handle);\n#endif\n}\n\nvoid apc_advise_out() {\n  apc_store().adviseOut();\n}\n\nsize_t get_const_map_size() {\n  return s_const_map_size;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// Constant and APC priming (always with compressed data).\n\nEXTERNALLY_VISIBLE\nvoid const_load_impl_compressed(\n  struct cache_info* /*info*/, int* /*int_lens*/, const char* /*int_keys*/,\n  long long* /*int_values*/, int* /*char_lens*/, const char* /*char_keys*/,\n  char* /*char_values*/, int* /*string_lens*/, const char* /*strings*/,\n  int* /*object_lens*/, const char* /*objects*/, int* /*thrift_lens*/,\n  const char* /*thrifts*/, int* /*other_lens*/, const char* /*others*/) {\n  // TODO(8117903): Unused; remove after updating www side.\n}\n\nEXTERNALLY_VISIBLE\nvoid apc_load_impl_compressed\n    (struct cache_info *info,\n     int *int_lens, const char *int_keys, long long *int_values,\n     int *char_lens, const char *char_keys, char *char_values,\n     int *string_lens, const char *strings,\n     int *object_lens, const char *objects,\n     int *thrift_lens, const char *thrifts,\n     int *other_lens, const char *others) {\n  bool readOnly = apcExtension::EnableConstLoad && info && info->use_const;\n  if (readOnly && info->a_name) Logger::FInfo(\"const archive {}\", info->a_name);\n  auto& s = apc_store();\n  SnapshotBuilder* snap = apcExtension::PrimeLibraryUpgradeDest.empty() ?\n    nullptr : &s_snapshotBuilder;\n  {\n    int count = int_lens[0];\n    int len = int_lens[1];\n    if (count) {\n      std::vector<KeyValuePair> vars(count);\n      char *keys = gzdecode(int_keys, len);\n      if (keys == nullptr) throw Exception(\"bad compressed apc archive.\");\n      ScopedMem holder(keys);\n      const char *k = keys;\n      long long* v = int_values;\n      for (int i = 0; i < count; i++) {\n        auto& item = vars[i];\n        item.key = k;\n        item.readOnly = readOnly;\n        s.constructPrime(*v++, item);\n        if (UNLIKELY(snap != nullptr)) snap->addInt(v[-1], item);\n        k += int_lens[i + 2] + 1; // skip \\0\n      }\n      s.prime(std::move(vars));\n      assertx((k - keys) == len);\n    }\n  }\n  {\n    int count = char_lens[0];\n    int len = char_lens[1];\n    if (count) {\n      std::vector<KeyValuePair> vars(count);\n      char *keys = gzdecode(char_keys, len);\n      if (keys == nullptr) throw Exception(\"bad compressed apc archive.\");\n      ScopedMem holder(keys);\n      const char *k = keys;\n      char *v = char_values;\n      for (int i = 0; i < count; i++) {\n        auto& item = vars[i];\n        item.key = k;\n        item.readOnly = readOnly;\n        switch (*v++) {\n          case 0:\n            s.constructPrime(false, item);\n            if (UNLIKELY(snap != nullptr)) snap->addFalse(item);\n            break;\n          case 1:\n            s.constructPrime(true, item);\n            if (UNLIKELY(snap != nullptr)) snap->addTrue(item);\n            break;\n          case 2:\n            s.constructPrime(uninit_null(), item);\n            if (UNLIKELY(snap != nullptr)) snap->addNull(item);\n            break;\n        default:\n          throw Exception(\"bad apc archive, unknown char type\");\n        }\n        k += char_lens[i + 2] + 1; // skip \\0\n      }\n      s.prime(std::move(vars));\n      assertx((k - keys) == len);\n    }\n  }\n  {\n    int count = string_lens[0] / 2;\n    int len = string_lens[1];\n    if (count) {\n      std::vector<KeyValuePair> vars(count);\n      char *decoded = gzdecode(strings, len);\n      if (decoded == nullptr) throw Exception(\"bad compressed apc archive.\");\n      ScopedMem holder(decoded);\n      const char *p = decoded;\n      for (int i = 0; i < count; i++) {\n        auto& item = vars[i];\n        item.key = p;\n        item.readOnly = readOnly;\n        p += string_lens[i + i + 2] + 1; // skip \\0\n        // Strings would be copied into APC anyway.\n        String value(p, string_lens[i + i + 3], CopyString);\n        // todo: t2539893: check if value is already a static string\n        s.constructPrime(value, item, false);\n        if (UNLIKELY(snap != nullptr)) snap->addString(value, item);\n        p += string_lens[i + i + 3] + 1; // skip \\0\n      }\n      s.prime(std::move(vars));\n      assertx((p - decoded) == len);\n    }\n  }\n  {\n    int count = object_lens[0] / 2;\n    int len = object_lens[1];\n    if (count) {\n      std::vector<KeyValuePair> vars(count);\n      char *decoded = gzdecode(objects, len);\n      if (decoded == nullptr) throw Exception(\"bad compressed APC archive.\");\n      ScopedMem holder(decoded);\n      const char *p = decoded;\n      for (int i = 0; i < count; i++) {\n        auto& item = vars[i];\n        item.key = p;\n        item.readOnly = readOnly;\n        p += object_lens[i + i + 2] + 1; // skip \\0\n        String value(p, object_lens[i + i + 3], CopyString);\n        s.constructPrime(value, item, true);\n        if (UNLIKELY(snap != nullptr)) snap->addObject(value, item);\n        p += object_lens[i + i + 3] + 1; // skip \\0\n      }\n      s.prime(std::move(vars));\n      assertx((p - decoded) == len);\n    }\n  }\n  {\n    int count = thrift_lens[0] / 2;\n    int len = thrift_lens[1];\n    if (count) {\n      std::vector<KeyValuePair> vars(count);\n      char *decoded = gzdecode(thrifts, len);\n      if (decoded == nullptr) throw Exception(\"bad compressed apc archive.\");\n      ScopedMem holder(decoded);\n      const char *p = decoded;\n      for (int i = 0; i < count; i++) {\n        auto& item = vars[i];\n        item.key = p;\n        item.readOnly = readOnly;\n        p += thrift_lens[i + i + 2] + 1; // skip \\0\n        String value(p, thrift_lens[i + i + 3], CopyString);\n        bool success;\n        Variant v = HHVM_FN(fb_unserialize)(value, success);\n        if (success ==  false) {\n          throw Exception(\"bad apc archive, fb_unserialize failed\");\n        }\n        s.constructPrime(v, item);\n        if (UNLIKELY(snap != nullptr)) snap->addThrift(value, item);\n        p += thrift_lens[i + i + 3] + 1; // skip \\0\n      }\n      s.prime(std::move(vars));\n      assertx((p - decoded) == len);\n    }\n  }\n  {\n    int count = other_lens[0] / 2;\n    int len = other_lens[1];\n    if (count) {\n      std::vector<KeyValuePair> vars(count);\n      char *decoded = gzdecode(others, len);\n      if (decoded == nullptr) throw Exception(\"bad compressed apc archive.\");\n      ScopedMem holder(decoded);\n      const char *p = decoded;\n      for (int i = 0; i < count; i++) {\n        auto& item = vars[i];\n        item.key = p;\n        item.readOnly = readOnly;\n        p += other_lens[i + i + 2] + 1; // skip \\0\n        String value(p, other_lens[i + i + 3], CopyString);\n        Variant v =\n          unserialize_from_string(value, VariableUnserializer::Type::Internal);\n        if (same(v, false)) {\n          // we can't possibly get here if it was a boolean \"false\" that's\n          // supposed to be serialized as a char\n          throw Exception(\"bad apc archive, unserialize_from_string failed\");\n        }\n        s.constructPrime(v, item);\n        if (UNLIKELY(snap != nullptr)) snap->addOther(value, item);\n        p += other_lens[i + i + 3] + 1; // skip \\0\n      }\n      s.prime(std::move(vars));\n      assertx((p - decoded) == len);\n    }\n  }\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\nstatic double my_time() {\n  struct timeval a;\n  double t;\n  gettimeofday(&a, nullptr);\n  t = a.tv_sec + (a.tv_usec/1000000.00);\n  return t;\n}\n\nconst StaticString\n  s_total(\"total\"),\n  s_current(\"current\"),\n  s_filename(\"filename\"),\n  s_name(\"name\"),\n  s_done(\"done\"),\n  s_temp_filename(\"temp_filename\"),\n  s_cancel_upload(\"cancel_upload\"),\n  s_rate(\"rate\");\n\n#define RFC1867_TRACKING_KEY_MAXLEN 63\n#define RFC1867_NAME_MAXLEN 63\n#define RFC1867_FILENAME_MAXLEN 127\n\nint apc_rfc1867_progress(apc_rfc1867_data* rfc1867ApcData, unsigned int event,\n                         void* event_data, void** /*extra*/) {\n  switch (event) {\n  case MULTIPART_EVENT_START: {\n    multipart_event_start *data = (multipart_event_start *) event_data;\n    rfc1867ApcData->content_length = data->content_length;\n    rfc1867ApcData->tracking_key.clear();\n    rfc1867ApcData->name.clear();\n    rfc1867ApcData->cancel_upload = 0;\n    rfc1867ApcData->temp_filename = \"\";\n    rfc1867ApcData->start_time = my_time();\n    rfc1867ApcData->bytes_processed = 0;\n    rfc1867ApcData->prev_bytes_processed = 0;\n    rfc1867ApcData->rate = 0;\n    rfc1867ApcData->update_freq = RuntimeOption::Rfc1867Freq;\n\n    if (rfc1867ApcData->update_freq < 0) {\n      assertx(false); // TODO: support percentage\n      // frequency is a percentage, not bytes\n      rfc1867ApcData->update_freq =\n        rfc1867ApcData->content_length * RuntimeOption::Rfc1867Freq / 100;\n    }\n    break;\n  }\n\n  case MULTIPART_EVENT_FORMDATA: {\n    multipart_event_formdata *data = (multipart_event_formdata *)event_data;\n    if (data->name &&\n        !strncasecmp(data->name, RuntimeOption::Rfc1867Name.c_str(),\n                     RuntimeOption::Rfc1867Name.size()) &&\n        data->value && data->length &&\n        data->length < RFC1867_TRACKING_KEY_MAXLEN -\n                       RuntimeOption::Rfc1867Prefix.size()) {\n      int len = RuntimeOption::Rfc1867Prefix.size();\n      if (len > RFC1867_TRACKING_KEY_MAXLEN) {\n        len = RFC1867_TRACKING_KEY_MAXLEN;\n      }\n      rfc1867ApcData->tracking_key =\n        std::string(RuntimeOption::Rfc1867Prefix.c_str(), len);\n      len = strlen(*data->value);\n      int rem = RFC1867_TRACKING_KEY_MAXLEN -\n                rfc1867ApcData->tracking_key.size();\n      if (len > rem) len = rem;\n      rfc1867ApcData->tracking_key +=\n        std::string(*data->value, len);\n      rfc1867ApcData->bytes_processed = data->post_bytes_processed;\n    }\n    /* Facebook: Temporary fix for a bug in PHP's rfc1867 code,\n       fixed here for convenience:\n       http://cvs.php.net/viewvc.cgi/php-src/main/\n       rfc1867.c?r1=1.173.2.1.2.11&r2=1.173.2.1.2.12 */\n    (*data->newlength) = data->length;\n    break;\n  }\n\n  case MULTIPART_EVENT_FILE_START:\n    if (!rfc1867ApcData->tracking_key.empty()) {\n      multipart_event_file_start *data =\n        (multipart_event_file_start *)event_data;\n\n      rfc1867ApcData->bytes_processed = data->post_bytes_processed;\n      int len = strlen(*data->filename);\n      if (len > RFC1867_FILENAME_MAXLEN) len = RFC1867_FILENAME_MAXLEN;\n      rfc1867ApcData->filename = std::string(*data->filename, len);\n      rfc1867ApcData->temp_filename = \"\";\n      len = strlen(data->name);\n      if (len > RFC1867_NAME_MAXLEN) len = RFC1867_NAME_MAXLEN;\n      rfc1867ApcData->name = std::string(data->name, len);\n      ArrayInit track(6, ArrayInit::Map{});\n      track.set(s_total, rfc1867ApcData->content_length);\n      track.set(s_current, rfc1867ApcData->bytes_processed);\n      track.set(s_filename, rfc1867ApcData->filename);\n      track.set(s_name, rfc1867ApcData->name);\n      track.set(s_done, 0);\n      track.set(s_start_time, rfc1867ApcData->start_time);\n      HHVM_FN(apc_store)(rfc1867ApcData->tracking_key, track.toVariant(), 3600);\n    }\n    break;\n\n  case MULTIPART_EVENT_FILE_DATA:\n    if (!rfc1867ApcData->tracking_key.empty()) {\n      multipart_event_file_data *data =\n        (multipart_event_file_data *) event_data;\n      rfc1867ApcData->bytes_processed = data->post_bytes_processed;\n      if (rfc1867ApcData->bytes_processed -\n          rfc1867ApcData->prev_bytes_processed >\n          rfc1867ApcData->update_freq) {\n        Variant v;\n        if (apc_store().get(rfc1867ApcData->tracking_key, v)) {\n          if (v.isArray()) {\n            ArrayInit track(6, ArrayInit::Map{});\n            track.set(s_total, rfc1867ApcData->content_length);\n            track.set(s_current, rfc1867ApcData->bytes_processed);\n            track.set(s_filename, rfc1867ApcData->filename);\n            track.set(s_name, rfc1867ApcData->name);\n            track.set(s_done, 0);\n            track.set(s_start_time, rfc1867ApcData->start_time);\n            HHVM_FN(apc_store)(rfc1867ApcData->tracking_key, track.toVariant(),\n                               3600);\n          }\n          rfc1867ApcData->prev_bytes_processed =\n            rfc1867ApcData->bytes_processed;\n        }\n      }\n    }\n    break;\n\n  case MULTIPART_EVENT_FILE_END:\n    if (!rfc1867ApcData->tracking_key.empty()) {\n      multipart_event_file_end *data =\n        (multipart_event_file_end *)event_data;\n      rfc1867ApcData->bytes_processed = data->post_bytes_processed;\n      rfc1867ApcData->cancel_upload = data->cancel_upload;\n      rfc1867ApcData->temp_filename = data->temp_filename;\n      ArrayInit track(8, ArrayInit::Map{});\n      track.set(s_total, rfc1867ApcData->content_length);\n      track.set(s_current, rfc1867ApcData->bytes_processed);\n      track.set(s_filename, rfc1867ApcData->filename);\n      track.set(s_name, rfc1867ApcData->name);\n      track.set(s_temp_filename, rfc1867ApcData->temp_filename);\n      track.set(s_cancel_upload, rfc1867ApcData->cancel_upload);\n      track.set(s_done, 0);\n      track.set(s_start_time, rfc1867ApcData->start_time);\n      HHVM_FN(apc_store)(rfc1867ApcData->tracking_key, track.toVariant(), 3600);\n    }\n    break;\n\n  case MULTIPART_EVENT_END:\n    if (!rfc1867ApcData->tracking_key.empty()) {\n      double now = my_time();\n      multipart_event_end *data = (multipart_event_end *)event_data;\n      rfc1867ApcData->bytes_processed = data->post_bytes_processed;\n      if (now>rfc1867ApcData->start_time) {\n        rfc1867ApcData->rate =\n          8.0*rfc1867ApcData->bytes_processed/(now-rfc1867ApcData->start_time);\n      } else {\n        rfc1867ApcData->rate =\n          8.0*rfc1867ApcData->bytes_processed;  /* Too quick */\n        ArrayInit track(8, ArrayInit::Map{});\n        track.set(s_total, rfc1867ApcData->content_length);\n        track.set(s_current, rfc1867ApcData->bytes_processed);\n        track.set(s_rate, rfc1867ApcData->rate);\n        track.set(s_filename, rfc1867ApcData->filename);\n        track.set(s_name, rfc1867ApcData->name);\n        track.set(s_cancel_upload, rfc1867ApcData->cancel_upload);\n        track.set(s_done, 1);\n        track.set(s_start_time, rfc1867ApcData->start_time);\n        HHVM_FN(apc_store)(rfc1867ApcData->tracking_key, track.toVariant(),\n                           3600);\n      }\n    }\n    break;\n  }\n  return 0;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// apc serialization\n\nString apc_serialize(const_variant_ref value,\n                     APCSerializeMode mode /* = Normal */) {\n  auto const enableApcSerialize = apcExtension::EnableApcSerialize;\n  VariableSerializer::Type sType =\n    enableApcSerialize ?\n      VariableSerializer::Type::APCSerialize :\n      VariableSerializer::Type::Internal;\n  auto const options = enableApcSerialize && mode == APCSerializeMode::Prime\n    ? VariableSerializer::kAPC_PRIME_SERIALIZE\n    : 0;\n  VariableSerializer vs(sType, options);\n  return vs.serialize(value, true);\n}\n\nVariant apc_unserialize(const char* data, int len) {\n  VariableUnserializer::Type sType =\n    apcExtension::EnableApcSerialize ?\n      VariableUnserializer::Type::APCSerialize :\n      VariableUnserializer::Type::Internal;\n  return unserialize_ex(data, len, sType);\n}\n\nString apc_reserialize(const String& str) {\n  if (str.empty() ||\n      !apcExtension::EnableApcSerialize) return str;\n\n  VariableUnserializer uns(str.data(), str.size(),\n                           VariableUnserializer::Type::APCSerialize);\n  StringBuffer buf;\n  uns.reserialize(buf);\n\n  return buf.detach();\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// debugging support\n\nbool apc_dump(const char *filename, bool keyOnly, bool metaDump) {\n  DumpMode mode;\n  std::ofstream out(filename);\n\n  // only one of these should ever be specified\n  if (keyOnly && metaDump) {\n    return false;\n  }\n\n  if (out.fail()) {\n    return false;\n  }\n\n  if (keyOnly) {\n    mode = DumpMode::KeyOnly;\n  } else if (metaDump) {\n    mode = DumpMode::KeyAndMeta;\n  } else {\n    mode = DumpMode::KeyAndValue;\n  }\n\n  apc_store().dump(out, mode);\n  out.close();\n  return true;\n}\n\nbool apc_dump_prefix(const char *filename,\n                     const std::string &prefix,\n                     uint32_t count) {\n  std::ofstream out(filename);\n  if (out.fail()) {\n    return false;\n  }\n  SCOPE_EXIT { out.close(); };\n\n  apc_store().dumpPrefix(out, prefix, count);\n  return true;\n}\n\nbool apc_get_random_entries(std::ostream &out, uint32_t count) {\n  apc_store().dumpRandomKeys(out, count);\n  return true;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n}\n", "<?hh\n\nfunction nop($unused) { /* value sink */ }\n\nfunction testApc($before) {\n  apc_delete(\"indep\");\n  if (!apc_add(\"indep\", $before)) {\n    echo \"add failure. weird.\\n\";\n    exit(1);\n  }\n\n  # fetch.\n  $after = __hhvm_intrinsics\\apc_fetch_no_check(\"indep\");\n  var_dump($after);\n  if (!$after) {\n    echo \"fetch failure. surprising.\\n\";\n    exit(2);\n  }\n\n  # cgetm.\n  foreach ($before as $k => $v) {\n    var_dump($after[$k]);\n    if ($after[$k] != $v) {\n      echo \"fetched dubious values \" . $after[$k] . \" != \" . \"$v\\n\";\n      var_dump($after[$k]);\n      exit(3);\n    }\n    if (!isset($after[$k])) {\n      echo \"expected key not set. devestating.\\n\";\n      var_dump($after[$k]);\n      exit(4);\n    }\n  }\n\n  # iterate over the APC array, too\n  foreach ($after as $k => $v) {\n    var_dump($after[$k]);\n    if ($after[$k] != $v) {\n      echo \"incoherent APC iteration. lamentable.\\n\";\n      var_dump($v);\n      exit(5);\n    }\n  }\n\n  # setM\n  $after['newKey'] = array();\n  var_dump($after);\n\n  # unsetm\n  foreach($after as $k => $v) {\n    unset($after[$k]);\n  }\n  var_dump($after);\n}\n\nfunction testKeyTypes() {\n  apc_add(\"keysarray\", array(2 => 'two', '3' => 'three'));\n  $arr = __hhvm_intrinsics\\apc_fetch_no_check(\"keysarray\");\n  foreach (array(2, 3, '2', '3') as $k) {\n    try { var_dump($arr[$k]); } catch (Exception $e) { echo $e->getMessage().\"\\n\"; }\n  }\n}\n\n<<__EntryPoint>> function main(): void {\n  testApc(array(7, 4, 1776));\n  testApc(array(\"sv0\", \"sv1\"));\n  testApc(array(\"sk0\" => \"sv0\", \"sk1\" => \"sv1\"));\n\n  // Also check that foreign arrays work for indirect calls\n  apc_store('foo', array(\"a\"));\n  $a = __hhvm_intrinsics\\apc_fetch_no_check('foo');\n  $b = call_user_func_array(fun(\"strtoupper\"), $a);\n  var_dump($b);\n\n  testKeyTypes();\n}\n", "array(3) {\n  [0]=>\n  int(7)\n  [1]=>\n  int(4)\n  [2]=>\n  int(1776)\n}\nint(7)\nint(4)\nint(1776)\nint(7)\nint(4)\nint(1776)\narray(4) {\n  [0]=>\n  int(7)\n  [1]=>\n  int(4)\n  [2]=>\n  int(1776)\n  [\"newKey\"]=>\n  array(0) {\n  }\n}\narray(0) {\n}\narray(2) {\n  [0]=>\n  string(3) \"sv0\"\n  [1]=>\n  string(3) \"sv1\"\n}\nstring(3) \"sv0\"\nstring(3) \"sv1\"\nstring(3) \"sv0\"\nstring(3) \"sv1\"\narray(3) {\n  [0]=>\n  string(3) \"sv0\"\n  [1]=>\n  string(3) \"sv1\"\n  [\"newKey\"]=>\n  array(0) {\n  }\n}\narray(0) {\n}\narray(2) {\n  [\"sk0\"]=>\n  string(3) \"sv0\"\n  [\"sk1\"]=>\n  string(3) \"sv1\"\n}\nstring(3) \"sv0\"\nstring(3) \"sv1\"\nstring(3) \"sv0\"\nstring(3) \"sv1\"\narray(3) {\n  [\"sk0\"]=>\n  string(3) \"sv0\"\n  [\"sk1\"]=>\n  string(3) \"sv1\"\n  [\"newKey\"]=>\n  array(0) {\n  }\n}\narray(0) {\n}\nstring(1) \"A\"\nstring(3) \"two\"\nUndefined index: 3\nUndefined index: 2\nstring(5) \"three\"\n"], "fixing_code": ["/*\n   +----------------------------------------------------------------------+\n   | HipHop for PHP                                                       |\n   +----------------------------------------------------------------------+\n   | Copyright (c) 2010-present Facebook, Inc. (http://www.facebook.com)  |\n   | Copyright (c) 1997-2010 The PHP Group                                |\n   +----------------------------------------------------------------------+\n   | This source file is subject to version 3.01 of the PHP license,      |\n   | that is bundled with this package in the file LICENSE, and is        |\n   | available through the world-wide-web at the following url:           |\n   | http://www.php.net/license/3_01.txt                                  |\n   | If you did not receive a copy of the PHP license and are unable to   |\n   | obtain it through the world-wide-web, please send a note to          |\n   | license@php.net so we can mail you a copy immediately.               |\n   +----------------------------------------------------------------------+\n*/\n#include \"hphp/runtime/ext/apc/ext_apc.h\"\n\n#include <fstream>\n\n#ifndef _MSC_VER\n#include <dlfcn.h>\n#endif\n#include <memory>\n#include <set>\n#include <vector>\n#include <stdexcept>\n#include <type_traits>\n\n#include <folly/portability/SysTime.h>\n\n#include \"hphp/util/alloc.h\"\n#include \"hphp/util/async-job.h\"\n#include \"hphp/util/boot-stats.h\"\n#include \"hphp/util/hdf.h\"\n#include \"hphp/util/logger.h\"\n\n#include \"hphp/runtime/base/apc-file-storage.h\"\n#include \"hphp/runtime/base/array-init.h\"\n#include \"hphp/runtime/base/builtin-functions.h\"\n#include \"hphp/runtime/base/comparisons.h\"\n#include \"hphp/runtime/base/concurrent-shared-store.h\"\n#include \"hphp/runtime/base/config.h\"\n#include \"hphp/runtime/base/execution-context.h\"\n#include \"hphp/runtime/base/ini-setting.h\"\n#include \"hphp/runtime/base/program-functions.h\"\n#include \"hphp/runtime/base/runtime-option.h\"\n#include \"hphp/runtime/base/variable-serializer.h\"\n#include \"hphp/runtime/ext/apc/snapshot-builder.h\"\n#include \"hphp/runtime/ext/fb/ext_fb.h\"\n#include \"hphp/runtime/server/cli-server.h\"\n\nusing HPHP::ScopedMem;\n\nnamespace HPHP {\n///////////////////////////////////////////////////////////////////////////////\n\nnamespace {\n\nstd::aligned_storage<\n  sizeof(ConcurrentTableSharedStore),\n  alignof(ConcurrentTableSharedStore)\n>::type s_apc_storage;\n\nusing UserAPCCache = folly::AtomicHashMap<uid_t, ConcurrentTableSharedStore*>;\n\nstd::aligned_storage<\n  sizeof(UserAPCCache),\n  alignof(UserAPCCache)\n>::type s_user_apc_storage;\n\nUserAPCCache& apc_store_local() {\n  void* vpUserStore = &s_user_apc_storage;\n  return *static_cast<UserAPCCache*>(vpUserStore);\n}\n\nConcurrentTableSharedStore& apc_store_local(uid_t uid) {\n  auto& cache = apc_store_local();\n  auto iter = cache.find(uid);\n  if (iter != cache.end()) return *(iter->second);\n  auto table = new ConcurrentTableSharedStore;\n  auto res = cache.insert(uid, table);\n  if (!res.second) delete table;\n  return *res.first->second;\n}\n\nConcurrentTableSharedStore& apc_store() {\n  if (UNLIKELY(!RuntimeOption::RepoAuthoritative &&\n               RuntimeOption::EvalUnixServerQuarantineApc)) {\n    if (auto uc = get_cli_ucred()) {\n      return apc_store_local(uc->uid);\n    }\n  }\n  void* vpStore = &s_apc_storage;\n  return *static_cast<ConcurrentTableSharedStore*>(vpStore);\n}\n\nbool isKeyInvalid(const String &key) {\n  // T39154441 - check if invalid chars exist\n  return key.find('\\0') != -1;\n}\n\n}\n\n//////////////////////////////////////////////////////////////////////\n\nvoid initialize_apc() {\n  APCStats::Create();\n  // Note: we never destruct APC, currently.\n  void* vpStore = &s_apc_storage;\n  new (vpStore) ConcurrentTableSharedStore;\n\n  if (UNLIKELY(!RuntimeOption::RepoAuthoritative &&\n               RuntimeOption::EvalUnixServerQuarantineApc)) {\n    new (&s_user_apc_storage) UserAPCCache(10);\n  }\n}\n\n//////////////////////////////////////////////////////////////////////\n\nconst StaticString\n  s_delete(\"delete\");\n\nextern void const_load();\n\ntypedef ConcurrentTableSharedStore::KeyValuePair KeyValuePair;\ntypedef ConcurrentTableSharedStore::DumpMode DumpMode;\n\nstatic void* keep_alive;\n\nvoid apcExtension::moduleLoad(const IniSetting::Map& ini, Hdf config) {\n  if (!keep_alive && ini.isString()) {\n    // this is a hack to preserve some dynamic entry points\n    switch (ini.toString().size()) {\n      case 0: keep_alive = (void*)const_load; break;\n      case 2: keep_alive = (void*)const_load_impl_compressed; break;\n      case 4: keep_alive = (void*)apc_load_impl_compressed; break;\n    }\n  }\n\n  Config::Bind(Enable, ini, config, \"Server.APC.EnableApc\", true);\n  Config::Bind(EnableConstLoad, ini, config, \"Server.APC.EnableConstLoad\",\n               false);\n  Config::Bind(ForceConstLoadToAPC, ini, config,\n               \"Server.APC.ForceConstLoadToAPC\", true);\n  Config::Bind(PrimeLibrary, ini, config, \"Server.APC.PrimeLibrary\");\n  Config::Bind(LoadThread, ini, config, \"Server.APC.LoadThread\", 15);\n  Config::Bind(CompletionKeys, ini, config, \"Server.APC.CompletionKeys\");\n  Config::Bind(EnableApcSerialize, ini, config, \"Server.APC.EnableApcSerialize\",\n               true);\n  Config::Bind(ExpireOnSets, ini, config, \"Server.APC.ExpireOnSets\");\n  Config::Bind(PurgeFrequency, ini, config, \"Server.APC.PurgeFrequency\", 4096);\n  Config::Bind(PurgeRate, ini, config, \"Server.APC.PurgeRate\", -1);\n\n  Config::Bind(AllowObj, ini, config, \"Server.APC.AllowObject\");\n  Config::Bind(TTLLimit, ini, config, \"Server.APC.TTLLimit\", -1);\n  // Any TTL > TTLMaxFinite will be made infinite. NB: Applied *after* TTLLimit.\n  Config::Bind(TTLMaxFinite, ini, config, \"Server.APC.TTLMaxFinite\",\n               std::numeric_limits<int64_t>::max());\n  Config::Bind(HotPrefix, ini, config, \"Server.APC.HotPrefix\");\n  Config::Bind(HotSize, ini, config, \"Server.APC.HotSize\", 30000);\n  Config::Bind(HotLoadFactor, ini, config, \"Server.APC.HotLoadFactor\", 0.5);\n  Config::Bind(HotKeyAllocLow, ini, config, \"Server.APC.HotKeyAllocLow\", false);\n  Config::Bind(HotMapAllocLow, ini, config, \"Server.APC.HotMapAllocLow\", false);\n\n  // Loads .so PrimeLibrary, writes snapshot output to this file, then exits.\n  Config::Bind(PrimeLibraryUpgradeDest, ini, config,\n               \"Server.APC.PrimeLibraryUpgradeDest\");\n\n  // FileStorage\n  Config::Bind(UseFileStorage, ini, config, \"Server.APC.FileStorage.Enable\");\n  FileStorageChunkSize = Config::GetInt64(ini, config,\n                                          \"Server.APC.FileStorage.ChunkSize\",\n                                          1LL << 29);\n  Config::Bind(FileStoragePrefix, ini, config, \"Server.APC.FileStorage.Prefix\",\n               \"/tmp/apc_store\");\n  Config::Bind(FileStorageFlagKey, ini, config,\n               \"Server.APC.FileStorage.FlagKey\", \"_madvise_out\");\n  Config::Bind(FileStorageAdviseOutPeriod, ini, config,\n               \"Server.APC.FileStorage.AdviseOutPeriod\", 1800);\n  Config::Bind(FileStorageKeepFileLinked, ini, config,\n               \"Server.APC.FileStorage.KeepFileLinked\");\n\n#ifdef NO_M_DATA\n  Config::Bind(UseUncounted, ini, config, \"Server.APC.MemModelTreadmill\", true);\n#else\n  Config::Bind(UseUncounted, ini, config, \"Server.APC.MemModelTreadmill\",\n               RuntimeOption::ServerExecutionMode());\n#endif\n  Config::Bind(ShareUncounted, ini, config, \"Server.APC.ShareUncounted\", true);\n  if (!UseUncounted && ShareUncounted) ShareUncounted = false;\n\n  IniSetting::Bind(this, IniSetting::PHP_INI_SYSTEM, \"apc.enabled\", &Enable);\n  IniSetting::Bind(this, IniSetting::PHP_INI_SYSTEM, \"apc.stat\",\n                   RuntimeOption::RepoAuthoritative ? \"0\" : \"1\", &Stat);\n  IniSetting::Bind(this, IniSetting::PHP_INI_SYSTEM, \"apc.enable_cli\",\n                   &EnableCLI);\n}\n\nvoid apcExtension::moduleInit() {\n#ifdef NO_M_DATA\n  if (!UseUncounted) {\n    Logger::Error(\"Server.APC.MemModelTreadmill=false ignored in lowptr build\");\n    UseUncounted = true;\n  }\n#endif // NO_M_DATA\n  if (UseFileStorage) {\n    // We use 32 bits to represent offset into a chunk, so don't make it too\n    // large.\n    constexpr int64_t MaxChunkSize = 1LL << 31;\n    if (FileStorageChunkSize > MaxChunkSize) {\n      Logger::Warning(\"Server.APC.FileStorage.ChunkSize too large, \"\n                      \"resetting to %\" PRId64, MaxChunkSize);\n      FileStorageChunkSize = MaxChunkSize;\n    }\n    s_apc_file_storage.enable(FileStoragePrefix, FileStorageChunkSize);\n  }\n\n  HHVM_RC_INT(APC_ITER_TYPE, 0x1);\n  HHVM_RC_INT(APC_ITER_KEY, 0x2);\n  HHVM_RC_INT(APC_ITER_FILENAME, 0x4);\n  HHVM_RC_INT(APC_ITER_DEVICE, 0x8);\n  HHVM_RC_INT(APC_ITER_INODE, 0x10);\n  HHVM_RC_INT(APC_ITER_VALUE, 0x20);\n  HHVM_RC_INT(APC_ITER_MD5, 0x40);\n  HHVM_RC_INT(APC_ITER_NUM_HITS, 0x80);\n  HHVM_RC_INT(APC_ITER_MTIME, 0x100);\n  HHVM_RC_INT(APC_ITER_CTIME, 0x200);\n  HHVM_RC_INT(APC_ITER_DTIME, 0x400);\n  HHVM_RC_INT(APC_ITER_ATIME, 0x800);\n  HHVM_RC_INT(APC_ITER_REFCOUNT, 0x1000);\n  HHVM_RC_INT(APC_ITER_MEM_SIZE, 0x2000);\n  HHVM_RC_INT(APC_ITER_TTL, 0x4000);\n  HHVM_RC_INT(APC_ITER_NONE, 0x0);\n  HHVM_RC_INT(APC_ITER_ALL, 0xFFFFFFFFFF);\n  HHVM_RC_INT(APC_LIST_ACTIVE, 1);\n  HHVM_RC_INT(APC_LIST_DELETED, 2);\n\n  HHVM_FE(apc_add);\n  HHVM_FE(apc_store);\n  HHVM_FE(apc_store_as_primed_do_not_use);\n  HHVM_FE(apc_fetch);\n  HHVM_FE(apc_delete);\n  HHVM_FE(apc_clear_cache);\n  HHVM_FE(apc_inc);\n  HHVM_FE(apc_dec);\n  HHVM_FE(apc_cas);\n  HHVM_FE(apc_exists);\n  HHVM_FE(apc_size);\n  HHVM_FE(apc_cache_info);\n  HHVM_FE(apc_sma_info);\n  loadSystemlib();\n}\n\nvoid apcExtension::moduleShutdown() {\n  if (UseFileStorage) {\n    s_apc_file_storage.cleanup();\n  }\n}\n\n\nbool apcExtension::Enable = true;\nbool apcExtension::EnableConstLoad = false;\nbool apcExtension::ForceConstLoadToAPC = true;\nstd::string apcExtension::PrimeLibrary;\nint apcExtension::LoadThread = 15;\nstd::set<std::string> apcExtension::CompletionKeys;\nbool apcExtension::EnableApcSerialize = true;\nbool apcExtension::ExpireOnSets = false;\nint apcExtension::PurgeFrequency = 4096;\nint apcExtension::PurgeRate = -1;\nbool apcExtension::AllowObj = false;\nint apcExtension::TTLLimit = -1;\nint64_t apcExtension::TTLMaxFinite = std::numeric_limits<int64_t>::max();\nint apcExtension::HotSize = 30000;\ndouble apcExtension::HotLoadFactor = 0.5;\nstd::vector<std::string> apcExtension::HotPrefix;\nbool apcExtension::HotKeyAllocLow = false;\nbool apcExtension::HotMapAllocLow = false;\nstd::string apcExtension::PrimeLibraryUpgradeDest;\nbool apcExtension::UseFileStorage = false;\nint64_t apcExtension::FileStorageChunkSize = int64_t(1LL << 29);\nstd::string apcExtension::FileStoragePrefix = \"/tmp/apc_store\";\nint apcExtension::FileStorageAdviseOutPeriod = 1800;\nstd::string apcExtension::FileStorageFlagKey = \"_madvise_out\";\nbool apcExtension::FileStorageKeepFileLinked = false;\n#ifdef NO_M_DATA\nbool apcExtension::UseUncounted = true;\n#else\nbool apcExtension::UseUncounted = false;\n#endif\nbool apcExtension::ShareUncounted = true;\nbool apcExtension::Stat = true;\n// Different from zend default but matches what we've been returning for years\nbool apcExtension::EnableCLI = true;\n\nstatic apcExtension s_apc_extension;\n\nVariant HHVM_FUNCTION(apc_store,\n                      const Variant& key_or_array,\n                      const Variant& var /* = null */,\n                      int64_t ttl /* = 0 */) {\n  if (!apcExtension::Enable) return Variant(false);\n\n  if (key_or_array.isArray()) {\n    Array valuesArr = key_or_array.toArray();\n\n    for (ArrayIter iter(valuesArr); iter; ++iter) {\n      Variant key = iter.first();\n      if (!key.isString()) {\n        throw_invalid_argument(\"apc key: (not a string)\");\n        return Variant(false);\n      }\n      Variant v = iter.second();\n\n      auto const& strKey = key.toCStrRef();\n      if (isKeyInvalid(strKey)) {\n        throw_invalid_argument(\"apc key: (contains invalid characters)\");\n        return Variant(false);\n      }\n      apc_store().set(strKey, v, ttl);\n    }\n    return Variant(ArrayData::Create());\n  }\n\n  if (!key_or_array.isString()) {\n    throw_invalid_argument(\"apc key: (not a string)\");\n    return Variant(false);\n  }\n  String strKey = key_or_array.toString();\n\n  if (isKeyInvalid(strKey)) {\n    throw_invalid_argument(\"apc key: (contains invalid characters)\");\n    return Variant(false);\n  }\n  apc_store().set(strKey, var, ttl);\n  return Variant(true);\n}\n\n/**\n * Stores the key in a similar fashion as \"priming\" would do (no TTL limit).\n * Using this function is equivalent to adding your key to apc_prime.so.\n */\nbool HHVM_FUNCTION(apc_store_as_primed_do_not_use,\n                   const String& key,\n                   const Variant& var) {\n  if (!apcExtension::Enable) return false;\n  if (isKeyInvalid(key)) {\n    throw_invalid_argument(\"apc key: (contains invalid characters)\");\n    return false;\n  }\n  apc_store().setWithoutTTL(key, var);\n  return true;\n}\n\nVariant HHVM_FUNCTION(apc_add,\n                      const Variant& key_or_array,\n                      const Variant& var /* = null */,\n                      int64_t ttl /* = 0 */) {\n  if (!apcExtension::Enable) return false;\n\n  if (key_or_array.isArray()) {\n    Array valuesArr = key_or_array.toArray();\n\n    // errors stores all keys corresponding to entries that could not be cached\n    ArrayInit errors(valuesArr.size(), ArrayInit::Map{});\n\n    for (ArrayIter iter(valuesArr); iter; ++iter) {\n      Variant key = iter.first();\n      if (!key.isString()) {\n        throw_invalid_argument(\"apc key: (not a string)\");\n        return false;\n      }\n      Variant v = iter.second();\n\n      auto const& strKey = key.toCStrRef();\n      if (isKeyInvalid(strKey)) {\n        throw_invalid_argument(\"apc key: (contains invalid characters)\");\n        return false;\n      }\n\n      if (!apc_store().add(strKey, v, ttl)) {\n        errors.add(strKey, -1);\n      }\n    }\n    return errors.toVariant();\n  }\n\n  if (!key_or_array.isString()) {\n    throw_invalid_argument(\"apc key: (not a string)\");\n    return false;\n  }\n  String strKey = key_or_array.toString();\n  if (isKeyInvalid(strKey)) {\n    throw_invalid_argument(\"apc key: (contains invalid characters)\");\n    return false;\n  }\n  return apc_store().add(strKey, var, ttl);\n}\n\nTypedValue HHVM_FUNCTION(apc_fetch, const Variant& key, bool& success) {\n  if (!apcExtension::Enable) return make_tv<KindOfBoolean>(false);\n\n  Variant v;\n\n  if (key.isArray()) {\n    bool tmp = false;\n    Array keys = key.toArray();\n    ArrayInit init(keys.size(), ArrayInit::Map{});\n    for (ArrayIter iter(keys); iter; ++iter) {\n      Variant k = iter.second();\n      if (!k.isString()) {\n        throw_invalid_argument(\"apc key: (not a string)\");\n        return make_tv<KindOfBoolean>(false);\n      }\n      String strKey = k.toString();\n      if (apc_store().get(strKey, v)) {\n        tmp = true;\n        init.set(strKey, v);\n      }\n    }\n    success = tmp;\n    return tvReturn(init.toVariant());\n  }\n\n  if (apc_store().get(key.toString(), v)) {\n    success = true;\n  } else {\n    success = false;\n    v = false;\n  }\n  return tvReturn(std::move(v));\n}\n\nVariant HHVM_FUNCTION(apc_delete,\n                      const Variant& key) {\n  if (!apcExtension::Enable) return false;\n\n  if (key.isArray()) {\n    Array keys = key.toArray();\n    PackedArrayInit init(keys.size());\n    for (ArrayIter iter(keys); iter; ++iter) {\n      Variant k = iter.second();\n      if (!k.isString()) {\n        raise_warning(\"apc key is not a string\");\n        init.append(k);\n      } else if (!apc_store().eraseKey(k.toCStrRef())) {\n        init.append(k);\n      }\n    }\n    return init.toVariant();\n  } else if(key.is(KindOfObject)) {\n    if (!key.getObjectData()->getVMClass()->\n         classof(SystemLib::s_APCIteratorClass)) {\n      raise_error(\n        \"apc_delete(): apc_delete object argument must be instance\"\n        \" of APCIterator\"\n      );\n      return false;\n    }\n    const Func* method =\n      SystemLib::s_APCIteratorClass->lookupMethod(s_delete.get());\n    return Variant::attach(\n      g_context->invokeFuncFew(method, key.getObjectData())\n    );\n  }\n\n  return apc_store().eraseKey(key.toString());\n}\n\nbool HHVM_FUNCTION(apc_clear_cache, const String& /*cache_type*/ /* = \"\" */) {\n  if (!apcExtension::Enable) return false;\n  return apc_store().clear();\n}\n\nVariant HHVM_FUNCTION(apc_inc,\n                      const String& key,\n                      int64_t step,\n                      bool& success) {\n  if (!apcExtension::Enable) return false;\n\n  bool found = false;\n  int64_t newValue = apc_store().inc(key, step, found);\n  success = found;\n  if (!found) return false;\n  return newValue;\n}\n\nVariant HHVM_FUNCTION(apc_dec,\n                      const String& key,\n                      int64_t step,\n                      bool& success) {\n  if (!apcExtension::Enable) return false;\n\n  bool found = false;\n  int64_t newValue = apc_store().inc(key, -step, found);\n  success = found;\n  if (!found) return false;\n  return newValue;\n}\n\nbool HHVM_FUNCTION(apc_cas,\n                   const String& key,\n                   int64_t old_cas,\n                   int64_t new_cas) {\n  if (!apcExtension::Enable) return false;\n  return apc_store().cas(key, old_cas, new_cas);\n}\n\nVariant HHVM_FUNCTION(apc_exists,\n                      const Variant& key) {\n  if (!apcExtension::Enable) return false;\n\n  if (key.isArray()) {\n    Array keys = key.toArray();\n    PackedArrayInit init(keys.size());\n    for (ArrayIter iter(keys); iter; ++iter) {\n      Variant k = iter.second();\n      if (!k.isString()) {\n        throw_invalid_argument(\"apc key: (not a string)\");\n        return false;\n      }\n      String strKey = k.toString();\n      if (apc_store().exists(strKey)) {\n        init.append(strKey);\n      }\n    }\n    return init.toVariant();\n  }\n\n  return apc_store().exists(key.toString());\n}\n\nTypedValue HHVM_FUNCTION(apc_size, const String& key) {\n  if (!apcExtension::Enable) return make_tv<KindOfNull>();\n\n  bool found = false;\n  int64_t size = apc_store().size(key, found);\n\n  return found ? make_tv<KindOfInt64>(size) : make_tv<KindOfNull>();\n}\n\nconst StaticString s_user(\"user\");\nconst StaticString s_start_time(\"start_time\");\nconst StaticString s_ttl(\"ttl\");\nconst StaticString s_cache_list(\"cache_list\");\nconst StaticString s_info(\"info\");\nconst StaticString s_in_memory(\"in_memory\");\nconst StaticString s_mem_size(\"mem_size\");\nconst StaticString s_type(\"type\");\nconst StaticString s_c_time(\"creation_time\");\nconst StaticString s_mtime(\"mtime\");\n\n// This is a guess to the size of the info array. It is significantly\n// bigger than what we need but hard to control all the info that we\n// may want to add here.\n// Try to keep it such that we do not have to resize the array\nconst uint32_t kCacheInfoSize = 40;\n// Number of elements in the entry array\nconst int32_t kEntryInfoSize = 7;\n\nVariant HHVM_FUNCTION(apc_cache_info,\n                      const String& cache_type,\n                      bool limited /* = false */) {\n  ArrayInit info(kCacheInfoSize, ArrayInit::Map{});\n  info.add(s_start_time, start_time());\n  if (cache_type.size() != 0 && !cache_type.same(s_user)) {\n    return info.toArray();\n  }\n\n  info.add(s_ttl, apcExtension::TTLLimit);\n\n  std::map<const StringData*, int64_t> stats;\n  APCStats::getAPCStats().collectStats(stats);\n  for (auto it = stats.begin(); it != stats.end(); it++) {\n    info.add(Variant(it->first, Variant::PersistentStrInit{}), it->second);\n  }\n  if (!limited) {\n    auto const entries = apc_store().getEntriesInfo();\n    PackedArrayInit ents(entries.size());\n    for (auto& entry : entries) {\n      ArrayInit ent(kEntryInfoSize, ArrayInit::Map{});\n      ent.add(s_info,\n              Variant::attach(StringData::Make(entry.key.c_str())));\n      ent.add(s_in_memory, entry.inMem);\n      ent.add(s_ttl, entry.ttl);\n      ent.add(s_mem_size, entry.size);\n      ent.add(s_type, static_cast<int64_t>(entry.type));\n      ent.add(s_c_time, entry.c_time);\n      ent.add(s_mtime, entry.mtime);\n      ents.append(ent.toArray());\n    }\n    info.add(s_cache_list, ents.toArray(), false);\n  }\n  return info.toArray();\n}\n\nArray HHVM_FUNCTION(apc_sma_info, bool /*limited*/ /* = false */) {\n  return empty_darray();\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// loading APC from archive files\n\ntypedef void(*PFUNC_APC_LOAD)();\n\n// Structure to hold cache meta data\n// Same definition in ext_apc.cpp\nstruct cache_info {\n  char *a_name;\n  bool use_const;\n};\n\nstatic Mutex dl_mutex;\nstatic PFUNC_APC_LOAD apc_load_func(void *handle, const char *name) {\n#ifdef _MSC_VER\n  throw Exception(\"apc_load_func is not currently supported under MSVC!\");\n#else\n  PFUNC_APC_LOAD p = (PFUNC_APC_LOAD)dlsym(handle, name);\n  if (p == nullptr) {\n    throw Exception(\"Unable to find %s in %s\", name,\n                    apcExtension::PrimeLibrary.c_str());\n  }\n  return p;\n#endif\n}\n\nstruct ApcLoadJob {\n  ApcLoadJob(void *handle, int index) : m_handle(handle), m_index(index) {}\n  void *m_handle; int m_index;\n};\n\nstruct ApcLoadWorker {\n  void onThreadEnter() {\n    g_context.getCheck();\n  }\n  void doJob(std::shared_ptr<ApcLoadJob> job) {\n    char func_name[128];\n    MemoryManager::SuppressOOM so(*tl_heap);\n    snprintf(func_name, sizeof(func_name), \"_apc_load_%d\", job->m_index);\n    apc_load_func(job->m_handle, func_name)();\n  }\n  void onThreadExit() {\n    hphp_memory_cleanup();\n  }\n};\n\nstatic size_t s_const_map_size = 0;\n\nstatic SnapshotBuilder s_snapshotBuilder;\n\nvoid apc_load(int thread) {\n#ifndef _MSC_VER\n  static void *handle = nullptr;\n  if (handle ||\n      apcExtension::PrimeLibrary.empty() ||\n      !apcExtension::Enable) {\n    return;\n  }\n  BootStats::Block timer(\"loading APC data\",\n                         RuntimeOption::ServerExecutionMode());\n  if (apc_store().primeFromSnapshot(apcExtension::PrimeLibrary.c_str())) {\n    return;\n  }\n  Logger::Info(\"Fall back to shared object format\");\n  handle = dlopen(apcExtension::PrimeLibrary.c_str(), RTLD_LAZY);\n  if (!handle) {\n    throw Exception(\"Unable to open apc prime library %s: %s\",\n                    apcExtension::PrimeLibrary.c_str(), dlerror());\n  }\n\n  auto upgradeDest = apcExtension::PrimeLibraryUpgradeDest;\n  if (!upgradeDest.empty()) {\n    thread = 1; // SnapshotBuilder is not (yet) thread-safe.\n    // TODO(9755792): Ensure APCFileStorage is enabled.\n  }\n\n  if (thread <= 1) {\n    apc_load_func(handle, \"_apc_load_all\")();\n  } else {\n    int count = ((int(*)())apc_load_func(handle, \"_apc_load_count\"))();\n\n    std::vector<std::shared_ptr<ApcLoadJob>> jobs;\n    jobs.reserve(count);\n    for (int i = 0; i < count; i++) {\n      jobs.push_back(std::make_shared<ApcLoadJob>(handle, i));\n    }\n    JobDispatcher<ApcLoadJob, ApcLoadWorker>(std::move(jobs), thread).run();\n  }\n\n  apc_store().primeDone();\n  if (!upgradeDest.empty()) {\n    s_snapshotBuilder.writeToFile(upgradeDest);\n  }\n\n  // We've copied all the data out, so close it out.\n  dlclose(handle);\n#endif\n}\n\nvoid apc_advise_out() {\n  apc_store().adviseOut();\n}\n\nsize_t get_const_map_size() {\n  return s_const_map_size;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// Constant and APC priming (always with compressed data).\n\nEXTERNALLY_VISIBLE\nvoid const_load_impl_compressed(\n  struct cache_info* /*info*/, int* /*int_lens*/, const char* /*int_keys*/,\n  long long* /*int_values*/, int* /*char_lens*/, const char* /*char_keys*/,\n  char* /*char_values*/, int* /*string_lens*/, const char* /*strings*/,\n  int* /*object_lens*/, const char* /*objects*/, int* /*thrift_lens*/,\n  const char* /*thrifts*/, int* /*other_lens*/, const char* /*others*/) {\n  // TODO(8117903): Unused; remove after updating www side.\n}\n\nEXTERNALLY_VISIBLE\nvoid apc_load_impl_compressed\n    (struct cache_info *info,\n     int *int_lens, const char *int_keys, long long *int_values,\n     int *char_lens, const char *char_keys, char *char_values,\n     int *string_lens, const char *strings,\n     int *object_lens, const char *objects,\n     int *thrift_lens, const char *thrifts,\n     int *other_lens, const char *others) {\n  bool readOnly = apcExtension::EnableConstLoad && info && info->use_const;\n  if (readOnly && info->a_name) Logger::FInfo(\"const archive {}\", info->a_name);\n  auto& s = apc_store();\n  SnapshotBuilder* snap = apcExtension::PrimeLibraryUpgradeDest.empty() ?\n    nullptr : &s_snapshotBuilder;\n  {\n    int count = int_lens[0];\n    int len = int_lens[1];\n    if (count) {\n      std::vector<KeyValuePair> vars(count);\n      char *keys = gzdecode(int_keys, len);\n      if (keys == nullptr) throw Exception(\"bad compressed apc archive.\");\n      ScopedMem holder(keys);\n      const char *k = keys;\n      long long* v = int_values;\n      for (int i = 0; i < count; i++) {\n        auto& item = vars[i];\n        item.key = k;\n        item.readOnly = readOnly;\n        s.constructPrime(*v++, item);\n        if (UNLIKELY(snap != nullptr)) snap->addInt(v[-1], item);\n        k += int_lens[i + 2] + 1; // skip \\0\n      }\n      s.prime(std::move(vars));\n      assertx((k - keys) == len);\n    }\n  }\n  {\n    int count = char_lens[0];\n    int len = char_lens[1];\n    if (count) {\n      std::vector<KeyValuePair> vars(count);\n      char *keys = gzdecode(char_keys, len);\n      if (keys == nullptr) throw Exception(\"bad compressed apc archive.\");\n      ScopedMem holder(keys);\n      const char *k = keys;\n      char *v = char_values;\n      for (int i = 0; i < count; i++) {\n        auto& item = vars[i];\n        item.key = k;\n        item.readOnly = readOnly;\n        switch (*v++) {\n          case 0:\n            s.constructPrime(false, item);\n            if (UNLIKELY(snap != nullptr)) snap->addFalse(item);\n            break;\n          case 1:\n            s.constructPrime(true, item);\n            if (UNLIKELY(snap != nullptr)) snap->addTrue(item);\n            break;\n          case 2:\n            s.constructPrime(uninit_null(), item);\n            if (UNLIKELY(snap != nullptr)) snap->addNull(item);\n            break;\n        default:\n          throw Exception(\"bad apc archive, unknown char type\");\n        }\n        k += char_lens[i + 2] + 1; // skip \\0\n      }\n      s.prime(std::move(vars));\n      assertx((k - keys) == len);\n    }\n  }\n  {\n    int count = string_lens[0] / 2;\n    int len = string_lens[1];\n    if (count) {\n      std::vector<KeyValuePair> vars(count);\n      char *decoded = gzdecode(strings, len);\n      if (decoded == nullptr) throw Exception(\"bad compressed apc archive.\");\n      ScopedMem holder(decoded);\n      const char *p = decoded;\n      for (int i = 0; i < count; i++) {\n        auto& item = vars[i];\n        item.key = p;\n        item.readOnly = readOnly;\n        p += string_lens[i + i + 2] + 1; // skip \\0\n        // Strings would be copied into APC anyway.\n        String value(p, string_lens[i + i + 3], CopyString);\n        // todo: t2539893: check if value is already a static string\n        s.constructPrime(value, item, false);\n        if (UNLIKELY(snap != nullptr)) snap->addString(value, item);\n        p += string_lens[i + i + 3] + 1; // skip \\0\n      }\n      s.prime(std::move(vars));\n      assertx((p - decoded) == len);\n    }\n  }\n  {\n    int count = object_lens[0] / 2;\n    int len = object_lens[1];\n    if (count) {\n      std::vector<KeyValuePair> vars(count);\n      char *decoded = gzdecode(objects, len);\n      if (decoded == nullptr) throw Exception(\"bad compressed APC archive.\");\n      ScopedMem holder(decoded);\n      const char *p = decoded;\n      for (int i = 0; i < count; i++) {\n        auto& item = vars[i];\n        item.key = p;\n        item.readOnly = readOnly;\n        p += object_lens[i + i + 2] + 1; // skip \\0\n        String value(p, object_lens[i + i + 3], CopyString);\n        s.constructPrime(value, item, true);\n        if (UNLIKELY(snap != nullptr)) snap->addObject(value, item);\n        p += object_lens[i + i + 3] + 1; // skip \\0\n      }\n      s.prime(std::move(vars));\n      assertx((p - decoded) == len);\n    }\n  }\n  {\n    int count = thrift_lens[0] / 2;\n    int len = thrift_lens[1];\n    if (count) {\n      std::vector<KeyValuePair> vars(count);\n      char *decoded = gzdecode(thrifts, len);\n      if (decoded == nullptr) throw Exception(\"bad compressed apc archive.\");\n      ScopedMem holder(decoded);\n      const char *p = decoded;\n      for (int i = 0; i < count; i++) {\n        auto& item = vars[i];\n        item.key = p;\n        item.readOnly = readOnly;\n        p += thrift_lens[i + i + 2] + 1; // skip \\0\n        String value(p, thrift_lens[i + i + 3], CopyString);\n        bool success;\n        Variant v = HHVM_FN(fb_unserialize)(value, success);\n        if (success ==  false) {\n          throw Exception(\"bad apc archive, fb_unserialize failed\");\n        }\n        s.constructPrime(v, item);\n        if (UNLIKELY(snap != nullptr)) snap->addThrift(value, item);\n        p += thrift_lens[i + i + 3] + 1; // skip \\0\n      }\n      s.prime(std::move(vars));\n      assertx((p - decoded) == len);\n    }\n  }\n  {\n    int count = other_lens[0] / 2;\n    int len = other_lens[1];\n    if (count) {\n      std::vector<KeyValuePair> vars(count);\n      char *decoded = gzdecode(others, len);\n      if (decoded == nullptr) throw Exception(\"bad compressed apc archive.\");\n      ScopedMem holder(decoded);\n      const char *p = decoded;\n      for (int i = 0; i < count; i++) {\n        auto& item = vars[i];\n        item.key = p;\n        item.readOnly = readOnly;\n        p += other_lens[i + i + 2] + 1; // skip \\0\n        String value(p, other_lens[i + i + 3], CopyString);\n        Variant v =\n          unserialize_from_string(value, VariableUnserializer::Type::Internal);\n        if (same(v, false)) {\n          // we can't possibly get here if it was a boolean \"false\" that's\n          // supposed to be serialized as a char\n          throw Exception(\"bad apc archive, unserialize_from_string failed\");\n        }\n        s.constructPrime(v, item);\n        if (UNLIKELY(snap != nullptr)) snap->addOther(value, item);\n        p += other_lens[i + i + 3] + 1; // skip \\0\n      }\n      s.prime(std::move(vars));\n      assertx((p - decoded) == len);\n    }\n  }\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\nstatic double my_time() {\n  struct timeval a;\n  double t;\n  gettimeofday(&a, nullptr);\n  t = a.tv_sec + (a.tv_usec/1000000.00);\n  return t;\n}\n\nconst StaticString\n  s_total(\"total\"),\n  s_current(\"current\"),\n  s_filename(\"filename\"),\n  s_name(\"name\"),\n  s_done(\"done\"),\n  s_temp_filename(\"temp_filename\"),\n  s_cancel_upload(\"cancel_upload\"),\n  s_rate(\"rate\");\n\n#define RFC1867_TRACKING_KEY_MAXLEN 63\n#define RFC1867_NAME_MAXLEN 63\n#define RFC1867_FILENAME_MAXLEN 127\n\nint apc_rfc1867_progress(apc_rfc1867_data* rfc1867ApcData, unsigned int event,\n                         void* event_data, void** /*extra*/) {\n  switch (event) {\n  case MULTIPART_EVENT_START: {\n    multipart_event_start *data = (multipart_event_start *) event_data;\n    rfc1867ApcData->content_length = data->content_length;\n    rfc1867ApcData->tracking_key.clear();\n    rfc1867ApcData->name.clear();\n    rfc1867ApcData->cancel_upload = 0;\n    rfc1867ApcData->temp_filename = \"\";\n    rfc1867ApcData->start_time = my_time();\n    rfc1867ApcData->bytes_processed = 0;\n    rfc1867ApcData->prev_bytes_processed = 0;\n    rfc1867ApcData->rate = 0;\n    rfc1867ApcData->update_freq = RuntimeOption::Rfc1867Freq;\n\n    if (rfc1867ApcData->update_freq < 0) {\n      assertx(false); // TODO: support percentage\n      // frequency is a percentage, not bytes\n      rfc1867ApcData->update_freq =\n        rfc1867ApcData->content_length * RuntimeOption::Rfc1867Freq / 100;\n    }\n    break;\n  }\n\n  case MULTIPART_EVENT_FORMDATA: {\n    multipart_event_formdata *data = (multipart_event_formdata *)event_data;\n    if (data->name &&\n        !strncasecmp(data->name, RuntimeOption::Rfc1867Name.c_str(),\n                     RuntimeOption::Rfc1867Name.size()) &&\n        data->value && data->length &&\n        data->length < RFC1867_TRACKING_KEY_MAXLEN -\n                       RuntimeOption::Rfc1867Prefix.size()) {\n      int len = RuntimeOption::Rfc1867Prefix.size();\n      if (len > RFC1867_TRACKING_KEY_MAXLEN) {\n        len = RFC1867_TRACKING_KEY_MAXLEN;\n      }\n      rfc1867ApcData->tracking_key =\n        std::string(RuntimeOption::Rfc1867Prefix.c_str(), len);\n      len = strlen(*data->value);\n      int rem = RFC1867_TRACKING_KEY_MAXLEN -\n                rfc1867ApcData->tracking_key.size();\n      if (len > rem) len = rem;\n      rfc1867ApcData->tracking_key +=\n        std::string(*data->value, len);\n      rfc1867ApcData->bytes_processed = data->post_bytes_processed;\n    }\n    /* Facebook: Temporary fix for a bug in PHP's rfc1867 code,\n       fixed here for convenience:\n       http://cvs.php.net/viewvc.cgi/php-src/main/\n       rfc1867.c?r1=1.173.2.1.2.11&r2=1.173.2.1.2.12 */\n    (*data->newlength) = data->length;\n    break;\n  }\n\n  case MULTIPART_EVENT_FILE_START:\n    if (!rfc1867ApcData->tracking_key.empty()) {\n      multipart_event_file_start *data =\n        (multipart_event_file_start *)event_data;\n\n      rfc1867ApcData->bytes_processed = data->post_bytes_processed;\n      int len = strlen(*data->filename);\n      if (len > RFC1867_FILENAME_MAXLEN) len = RFC1867_FILENAME_MAXLEN;\n      rfc1867ApcData->filename = std::string(*data->filename, len);\n      rfc1867ApcData->temp_filename = \"\";\n      len = strlen(data->name);\n      if (len > RFC1867_NAME_MAXLEN) len = RFC1867_NAME_MAXLEN;\n      rfc1867ApcData->name = std::string(data->name, len);\n      ArrayInit track(6, ArrayInit::Map{});\n      track.set(s_total, rfc1867ApcData->content_length);\n      track.set(s_current, rfc1867ApcData->bytes_processed);\n      track.set(s_filename, rfc1867ApcData->filename);\n      track.set(s_name, rfc1867ApcData->name);\n      track.set(s_done, 0);\n      track.set(s_start_time, rfc1867ApcData->start_time);\n      HHVM_FN(apc_store)(rfc1867ApcData->tracking_key, track.toVariant(), 3600);\n    }\n    break;\n\n  case MULTIPART_EVENT_FILE_DATA:\n    if (!rfc1867ApcData->tracking_key.empty()) {\n      multipart_event_file_data *data =\n        (multipart_event_file_data *) event_data;\n      rfc1867ApcData->bytes_processed = data->post_bytes_processed;\n      if (rfc1867ApcData->bytes_processed -\n          rfc1867ApcData->prev_bytes_processed >\n          rfc1867ApcData->update_freq) {\n        Variant v;\n        if (apc_store().get(rfc1867ApcData->tracking_key, v)) {\n          if (v.isArray()) {\n            ArrayInit track(6, ArrayInit::Map{});\n            track.set(s_total, rfc1867ApcData->content_length);\n            track.set(s_current, rfc1867ApcData->bytes_processed);\n            track.set(s_filename, rfc1867ApcData->filename);\n            track.set(s_name, rfc1867ApcData->name);\n            track.set(s_done, 0);\n            track.set(s_start_time, rfc1867ApcData->start_time);\n            HHVM_FN(apc_store)(rfc1867ApcData->tracking_key, track.toVariant(),\n                               3600);\n          }\n          rfc1867ApcData->prev_bytes_processed =\n            rfc1867ApcData->bytes_processed;\n        }\n      }\n    }\n    break;\n\n  case MULTIPART_EVENT_FILE_END:\n    if (!rfc1867ApcData->tracking_key.empty()) {\n      multipart_event_file_end *data =\n        (multipart_event_file_end *)event_data;\n      rfc1867ApcData->bytes_processed = data->post_bytes_processed;\n      rfc1867ApcData->cancel_upload = data->cancel_upload;\n      rfc1867ApcData->temp_filename = data->temp_filename;\n      ArrayInit track(8, ArrayInit::Map{});\n      track.set(s_total, rfc1867ApcData->content_length);\n      track.set(s_current, rfc1867ApcData->bytes_processed);\n      track.set(s_filename, rfc1867ApcData->filename);\n      track.set(s_name, rfc1867ApcData->name);\n      track.set(s_temp_filename, rfc1867ApcData->temp_filename);\n      track.set(s_cancel_upload, rfc1867ApcData->cancel_upload);\n      track.set(s_done, 0);\n      track.set(s_start_time, rfc1867ApcData->start_time);\n      HHVM_FN(apc_store)(rfc1867ApcData->tracking_key, track.toVariant(), 3600);\n    }\n    break;\n\n  case MULTIPART_EVENT_END:\n    if (!rfc1867ApcData->tracking_key.empty()) {\n      double now = my_time();\n      multipart_event_end *data = (multipart_event_end *)event_data;\n      rfc1867ApcData->bytes_processed = data->post_bytes_processed;\n      if (now>rfc1867ApcData->start_time) {\n        rfc1867ApcData->rate =\n          8.0*rfc1867ApcData->bytes_processed/(now-rfc1867ApcData->start_time);\n      } else {\n        rfc1867ApcData->rate =\n          8.0*rfc1867ApcData->bytes_processed;  /* Too quick */\n        ArrayInit track(8, ArrayInit::Map{});\n        track.set(s_total, rfc1867ApcData->content_length);\n        track.set(s_current, rfc1867ApcData->bytes_processed);\n        track.set(s_rate, rfc1867ApcData->rate);\n        track.set(s_filename, rfc1867ApcData->filename);\n        track.set(s_name, rfc1867ApcData->name);\n        track.set(s_cancel_upload, rfc1867ApcData->cancel_upload);\n        track.set(s_done, 1);\n        track.set(s_start_time, rfc1867ApcData->start_time);\n        HHVM_FN(apc_store)(rfc1867ApcData->tracking_key, track.toVariant(),\n                           3600);\n      }\n    }\n    break;\n  }\n  return 0;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// apc serialization\n\nString apc_serialize(const_variant_ref value,\n                     APCSerializeMode mode /* = Normal */) {\n  auto const enableApcSerialize = apcExtension::EnableApcSerialize;\n  VariableSerializer::Type sType =\n    enableApcSerialize ?\n      VariableSerializer::Type::APCSerialize :\n      VariableSerializer::Type::Internal;\n  auto const options = enableApcSerialize && mode == APCSerializeMode::Prime\n    ? VariableSerializer::kAPC_PRIME_SERIALIZE\n    : 0;\n  VariableSerializer vs(sType, options);\n  return vs.serialize(value, true);\n}\n\nVariant apc_unserialize(const char* data, int len) {\n  VariableUnserializer::Type sType =\n    apcExtension::EnableApcSerialize ?\n      VariableUnserializer::Type::APCSerialize :\n      VariableUnserializer::Type::Internal;\n  return unserialize_ex(data, len, sType);\n}\n\nString apc_reserialize(const String& str) {\n  if (str.empty() ||\n      !apcExtension::EnableApcSerialize) return str;\n\n  VariableUnserializer uns(str.data(), str.size(),\n                           VariableUnserializer::Type::APCSerialize);\n  StringBuffer buf;\n  uns.reserialize(buf);\n\n  return buf.detach();\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// debugging support\n\nbool apc_dump(const char *filename, bool keyOnly, bool metaDump) {\n  DumpMode mode;\n  std::ofstream out(filename);\n\n  // only one of these should ever be specified\n  if (keyOnly && metaDump) {\n    return false;\n  }\n\n  if (out.fail()) {\n    return false;\n  }\n\n  if (keyOnly) {\n    mode = DumpMode::KeyOnly;\n  } else if (metaDump) {\n    mode = DumpMode::KeyAndMeta;\n  } else {\n    mode = DumpMode::KeyAndValue;\n  }\n\n  apc_store().dump(out, mode);\n  out.close();\n  return true;\n}\n\nbool apc_dump_prefix(const char *filename,\n                     const std::string &prefix,\n                     uint32_t count) {\n  std::ofstream out(filename);\n  if (out.fail()) {\n    return false;\n  }\n  SCOPE_EXIT { out.close(); };\n\n  apc_store().dumpPrefix(out, prefix, count);\n  return true;\n}\n\nbool apc_get_random_entries(std::ostream &out, uint32_t count) {\n  apc_store().dumpRandomKeys(out, count);\n  return true;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n}\n", "<?hh\n\nfunction nop($unused) { /* value sink */ }\n\nfunction testApc($before) {\n  apc_delete(\"indep\");\n  if (!apc_add(\"indep\", $before)) {\n    echo \"add failure. weird.\\n\";\n    exit(1);\n  }\n\n  # fetch.\n  $after = __hhvm_intrinsics\\apc_fetch_no_check(\"indep\");\n  var_dump($after);\n  if (!$after) {\n    echo \"fetch failure. surprising.\\n\";\n    exit(2);\n  }\n\n  # cgetm.\n  foreach ($before as $k => $v) {\n    var_dump($after[$k]);\n    if ($after[$k] != $v) {\n      echo \"fetched dubious values \" . $after[$k] . \" != \" . \"$v\\n\";\n      var_dump($after[$k]);\n      exit(3);\n    }\n    if (!isset($after[$k])) {\n      echo \"expected key not set. devestating.\\n\";\n      var_dump($after[$k]);\n      exit(4);\n    }\n  }\n\n  # iterate over the APC array, too\n  foreach ($after as $k => $v) {\n    var_dump($after[$k]);\n    if ($after[$k] != $v) {\n      echo \"incoherent APC iteration. lamentable.\\n\";\n      var_dump($v);\n      exit(5);\n    }\n  }\n\n  # setM\n  $after['newKey'] = array();\n  var_dump($after);\n\n  # unsetm\n  foreach($after as $k => $v) {\n    unset($after[$k]);\n  }\n  var_dump($after);\n}\n\nfunction testKeyTypes() {\n  apc_add(\"keysarray\", array(2 => 'two', '3' => 'three'));\n  $arr = __hhvm_intrinsics\\apc_fetch_no_check(\"keysarray\");\n  foreach (array(2, 3, '2', '3') as $k) {\n    try { var_dump($arr[$k]); } catch (Exception $e) { echo $e->getMessage().\"\\n\"; }\n  }\n}\n\nfunction testInvalidKeys() {\n    // Reject keys with null bytes\n    apc_add(\"bar\\x00baz\", 10);\n    apc_store(\"test\\x00xyz\", \"hello\");\n    apc_store(array(\"validkey\" => \"validvalue\", \"invalid\\x00key\" => \"value\"));\n    foreach (array('bar', 'test', 'validkey', 'invalid') as $k) {\n        var_dump(__hhvm_intrinsics\\apc_fetch_no_check($k));\n    }\n}\n\n<<__EntryPoint>> function main(): void {\n  testApc(array(7, 4, 1776));\n  testApc(array(\"sv0\", \"sv1\"));\n  testApc(array(\"sk0\" => \"sv0\", \"sk1\" => \"sv1\"));\n\n  // Also check that foreign arrays work for indirect calls\n  apc_store('foo', array(\"a\"));\n  $a = __hhvm_intrinsics\\apc_fetch_no_check('foo');\n  $b = call_user_func_array(fun(\"strtoupper\"), $a);\n  var_dump($b);\n\n  testKeyTypes();\n  testInvalidKeys();\n}\n", "array(3) {\n  [0]=>\n  int(7)\n  [1]=>\n  int(4)\n  [2]=>\n  int(1776)\n}\nint(7)\nint(4)\nint(1776)\nint(7)\nint(4)\nint(1776)\narray(4) {\n  [0]=>\n  int(7)\n  [1]=>\n  int(4)\n  [2]=>\n  int(1776)\n  [\"newKey\"]=>\n  array(0) {\n  }\n}\narray(0) {\n}\narray(2) {\n  [0]=>\n  string(3) \"sv0\"\n  [1]=>\n  string(3) \"sv1\"\n}\nstring(3) \"sv0\"\nstring(3) \"sv1\"\nstring(3) \"sv0\"\nstring(3) \"sv1\"\narray(3) {\n  [0]=>\n  string(3) \"sv0\"\n  [1]=>\n  string(3) \"sv1\"\n  [\"newKey\"]=>\n  array(0) {\n  }\n}\narray(0) {\n}\narray(2) {\n  [\"sk0\"]=>\n  string(3) \"sv0\"\n  [\"sk1\"]=>\n  string(3) \"sv1\"\n}\nstring(3) \"sv0\"\nstring(3) \"sv1\"\nstring(3) \"sv0\"\nstring(3) \"sv1\"\narray(3) {\n  [\"sk0\"]=>\n  string(3) \"sv0\"\n  [\"sk1\"]=>\n  string(3) \"sv1\"\n  [\"newKey\"]=>\n  array(0) {\n  }\n}\narray(0) {\n}\nstring(1) \"A\"\nstring(3) \"two\"\nUndefined index: 3\nUndefined index: 2\nstring(5) \"three\"\n\nWarning: Invalid argument: apc key: (contains invalid characters)%S\n\nWarning: Invalid argument: apc key: (contains invalid characters)%S\n\nWarning: Invalid argument: apc key: (contains invalid characters)%S\nbool(false)\nbool(false)\nstring(10) \"validvalue\"\nbool(false)\n"], "filenames": ["hphp/runtime/ext/apc/ext_apc.cpp", "hphp/test/quick/apc.php", "hphp/test/quick/apc.php.expectf"], "buggy_code_start_loc": [95, 63, 74], "buggy_code_end_loc": [367, 75, 74], "fixing_code_start_loc": [96, 64, 75], "fixing_code_end_loc": [398, 87, 85], "type": "NVD-CWE-noinfo", "message": "Various APC functions accept keys containing null bytes as input, leading to premature truncation of input. This issue affects HHVM versions prior to 3.30.12, all versions between 4.0.0 and 4.8.5, all versions between 4.9.0 and 4.23.1, as well as 4.24.0, 4.25.0, 4.26.0, 4.27.0, 4.28.0, and 4.28.1.", "other": {"cve": {"id": "CVE-2019-11936", "sourceIdentifier": "cve-assign@fb.com", "published": "2019-12-04T17:16:43.617", "lastModified": "2021-09-14T12:03:54.157", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Various APC functions accept keys containing null bytes as input, leading to premature truncation of input. This issue affects HHVM versions prior to 3.30.12, all versions between 4.0.0 and 4.8.5, all versions between 4.9.0 and 4.23.1, as well as 4.24.0, 4.25.0, 4.26.0, 4.27.0, 4.28.0, and 4.28.1."}, {"lang": "es", "value": "Varias funciones APC aceptan claves que contienen bytes nulos como entrada, conllevando a un truncamiento prematuro de la entrada. Este problema afecta a HHVM versiones anteriores a la versi\u00f3n 3.30.12, todas las versiones entre 4.0.0 y 4.8.5, todas las versiones entre 4.9.0 y 4.23.1, as\u00ed como las versiones 4.24.0, 4.25.0, 4.26.0, 4.27.0, 4.28.0 y 4.28.1."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}, {"source": "cve-assign@fb.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-626"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:facebook:hhvm:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.30.12", "matchCriteriaId": "A8452024-B97D-4B7B-BB28-AC04328E67B2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:facebook:hhvm:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.0.0", "versionEndIncluding": "4.8.5", "matchCriteriaId": "47FAA7FF-64A7-451F-A389-6CA4240D7871"}, {"vulnerable": true, "criteria": "cpe:2.3:a:facebook:hhvm:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.9.0", "versionEndIncluding": "4.23.1", "matchCriteriaId": "12366B66-DE3D-4387-83BC-E01C77393D58"}, {"vulnerable": true, "criteria": "cpe:2.3:a:facebook:hhvm:4.24.0:*:*:*:*:*:*:*", "matchCriteriaId": "76F33DEA-0DB2-46B5-82C3-CA75D07C952D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:facebook:hhvm:4.25.0:*:*:*:*:*:*:*", "matchCriteriaId": "6B098BF0-EA28-44FA-A5D0-BDE05C2E9FE8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:facebook:hhvm:4.26.0:*:*:*:*:*:*:*", "matchCriteriaId": "0950ED00-A5DC-4DA6-906F-CDC03EE2DA5A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:facebook:hhvm:4.27.0:*:*:*:*:*:*:*", "matchCriteriaId": "D77D46F2-A17B-4CEA-A003-F7952EE3342D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:facebook:hhvm:4.28.0:*:*:*:*:*:*:*", "matchCriteriaId": "D53212BA-6BF8-4FE2-980C-371D5EF170E5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:facebook:hhvm:4.28.1:*:*:*:*:*:*:*", "matchCriteriaId": "F182E9B3-838C-4AFA-94B5-77D30098712E"}]}]}], "references": [{"url": "https://github.com/facebook/hhvm/commit/f57df6d8cf33cb14c40f52287da29360e7003373", "source": "cve-assign@fb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://hhvm.com/blog/2019/10/28/security-update.html", "source": "cve-assign@fb.com", "tags": ["Vendor Advisory"]}, {"url": "https://www.facebook.com/security/advisories/cve-2019-11936", "source": "cve-assign@fb.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/facebook/hhvm/commit/f57df6d8cf33cb14c40f52287da29360e7003373"}}