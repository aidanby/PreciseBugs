{"buggy_code": ["<?php\n\nrequire_once(INCLUDE_DIR.'class.2fa.php');\n\ninterface AuthenticatedUser {\n    // Get basic information\n    function getId();\n    function getUsername();\n    function getUserType();\n\n\n    // Get password reset timestamp\n    function getPasswdResetTimestamp();\n\n    //Backend used to authenticate the user\n    function getAuthBackend();\n\n    // Get 2FA Backend\n    function get2FABackend();\n\n    //Authentication key\n    function setAuthKey($key);\n\n    function getAuthKey();\n\n    // logOut the user\n    function logOut();\n\n    // Signal method to allow performing extra things when a user is logged\n    // into the sysem\n    function onLogin($bk);\n}\n\nabstract class BaseAuthenticatedUser\nimplements AuthenticatedUser {\n    //Authorization key returned by the backend used to authorize the user\n    private $authkey;\n\n    // Get basic information\n    abstract function getId();\n    abstract function getUsername();\n    abstract function getUserType();\n\n    // Get password reset timestamp\n    function getPasswdResetTimestamp() {\n        return null;\n    }\n\n    //Backend used to authenticate the user\n    abstract function getAuthBackend();\n\n    // Get 2FA Backend\n    abstract function get2FABackend();\n\n    //Authentication key\n    function setAuthKey($key) {\n        $this->authkey = $key;\n    }\n\n    function getAuthKey() {\n        return $this->authkey;\n    }\n\n    // logOut the user\n    function logOut() {\n\n        if ($bk = $this->getAuthBackend())\n            return $bk->signOut($this);\n\n        return false;\n    }\n\n    // Signal method to allow performing extra things when a user is logged\n    // into the sysem\n    function onLogin($bk) {}\n}\n\nrequire_once(INCLUDE_DIR.'class.ostsession.php');\nrequire_once(INCLUDE_DIR.'class.usersession.php');\n\ninterface AuthDirectorySearch {\n    /**\n     * Indicates if the backend can be used to search for user information.\n     * Lookup is performed to find user information based on a unique\n     * identifier.\n     */\n    function lookup($id);\n\n    /**\n     * Indicates if the backend supports searching for usernames. This is\n     * distinct from information lookup in that lookup is intended to lookup\n     * information based on a unique identifier\n     */\n    function search($query);\n}\n\n/**\n * Class: ClientCreateRequest\n *\n * Simple container to represent a remote authentication success for a\n * client which should be imported into the local database. The class will\n * provide access to the backend that authenticated the user, the username\n * that the user entered when logging in, and any other information about\n * the user that the backend was able to lookup. Generally, this extra\n * information would be the same information retrieved from calling the\n * AuthDirectorySearch::lookup() method.\n */\nclass ClientCreateRequest {\n\n    var $backend;\n    var $username;\n    var $info;\n\n    function __construct($backend, $username, $info=array()) {\n        $this->backend = $backend;\n        $this->username = $username;\n        $this->info = $info;\n    }\n\n    function getBackend() {\n        return $this->backend;\n    }\n    function setBackend($what) {\n        $this->backend = $what;\n    }\n\n    function getUsername() {\n        return $this->username;\n    }\n    function getInfo() {\n        return $this->info;\n    }\n\n    function attemptAutoRegister() {\n        global $cfg;\n\n        if (!$cfg || $cfg->isClientRegistrationMode(['disabled']))\n            return false;\n\n        // Attempt to automatically register\n        $this_form = UserForm::getUserForm()->getForm($this->getInfo());\n        $bk = $this->getBackend();\n        $defaults = array(\n            'timezone' => $cfg->getDefaultTimezone(),\n            'username' => $this->getUsername(),\n        );\n        if ($bk->supportsInteractiveAuthentication())\n            // User can only be authenticated against this backend\n            $defaults['backend'] = $bk::$id;\n        if ($this_form->isValid(function($f) { return !$f->isVisibleToUsers(); })\n                && ($U = User::fromVars($this_form->getClean()))\n                && ($acct = ClientAccount::createForUser($U, $defaults))\n                // Confirm and save the account\n                && $acct->confirm()\n                // Login, since `tickets.php` will not attempt SSO\n                && ($cl = new ClientSession(new EndUser($U)))\n                && ($bk->login($cl, $bk)))\n            return $cl;\n    }\n}\n\n/**\n * Authentication backend\n *\n * Authentication provides the basis of abstracting the link between the\n * login page with a username and password and the staff member,\n * administrator, or client using the system.\n *\n * The system works by allowing the AUTH_BACKENDS setting from\n * ost-config.php to determine the list of authentication backends or\n * providers and also specify the order they should be evaluated in.\n *\n * The authentication backend should define a authenticate() method which\n * receives a username and optional password. If the authentication\n * succeeds, an instance deriving from <User> should be returned.\n */\nabstract class AuthenticationBackend {\n    static protected $registry = array();\n    static $name;\n    static $id;\n\n\n    /* static */\n    static function register($class) {\n        if (is_string($class) && class_exists($class))\n            $class = new $class();\n\n        if (!is_object($class)\n                || !($class instanceof AuthenticationBackend))\n            return false;\n\n        return static::_register($class);\n    }\n\n    static function _register($class) {\n        // XXX: Raise error if $class::id is already in the registry\n        static::$registry[$class::$id] = $class;\n    }\n\n    static function allRegistered() {\n        return static::$registry;\n    }\n\n    static function getBackend($id) {\n\n        if ($id\n                && ($backends = static::allRegistered())\n                && isset($backends[$id]))\n            return $backends[$id];\n    }\n\n    static function getSearchDirectoryBackend($id) {\n\n        if ($id\n                && ($backends = static::getSearchDirectories())\n                && isset($backends[$id]))\n            return $backends[$id];\n    }\n\n    /*\n     * Allow the backend to do login audit depending on the result\n     * This is mainly used to track failed login attempts\n     */\n    static function authAudit($result, $credentials=null) {\n\n        if (!$result) return;\n\n        foreach (static::allRegistered() as $bk)\n            $bk->audit($result, $credentials);\n    }\n\n    static function process($username, $password=null, &$errors=array()) {\n\n        if (!$username)\n            return false;\n\n        $backends =  static::getAllowedBackends($username);\n        foreach (static::allRegistered() as $bk) {\n            if ($backends //Allowed backends\n                    && $bk->supportsInteractiveAuthentication()\n                    && !in_array($bk::$id, $backends))\n                // User cannot be authenticated against this backend\n                continue;\n\n            // All backends are queried here, even if they don't support\n            // authentication so that extensions like lockouts and audits\n            // can be supported.\n            try {\n                $result = $bk->authenticate($username, $password);\n                if ($result instanceof AuthenticatedUser\n                        && ($bk->login($result, $bk)))\n                    return $result;\n                elseif ($result instanceof ClientCreateRequest\n                        && $bk instanceof UserAuthenticationBackend)\n                    return $result;\n                elseif ($result instanceof AccessDenied) {\n                    break;\n                }\n            }\n            catch (AccessDenied $e) {\n                $result = $e;\n                break;\n            }\n        }\n\n        if (!$result)\n            $result = new AccessDenied(__('Access denied'));\n\n        if ($result && $result instanceof AccessDenied)\n            $errors['err'] = $result->reason;\n\n        $info = array('username' => $username, 'password' => $password);\n        Signal::send('auth.login.failed', null, $info);\n        self::authAudit($result, $info);\n    }\n\n    /*\n     *  Attempt to process non-interactive sign-on e.g  HTTP-Passthrough\n     *\n     * $forcedAuth - indicate if authentication is required.\n     *\n     */\n    function processSignOn(&$errors, $forcedAuth=true) {\n\n        foreach (static::allRegistered() as $bk) {\n            // All backends are queried here, even if they don't support\n            // authentication so that extensions like lockouts and audits\n            // can be supported.\n            try {\n                $result = $bk->signOn();\n                if ($result instanceof AuthenticatedUser) {\n                    //Perform further Object specific checks and the actual login\n                    if (!$bk->login($result, $bk))\n                        continue;\n\n                    return $result;\n                }\n                elseif ($result instanceof ClientCreateRequest\n                        && $bk instanceof UserAuthenticationBackend)\n                    return $result;\n                elseif ($result instanceof AccessDenied) {\n                    break;\n                }\n            }\n            catch (AccessDenied $e) {\n                $result = $e;\n                break;\n            }\n        }\n\n        if (!$result && $forcedAuth)\n            $result = new  AccessDenied(__('Unknown user'));\n\n        if ($result && $result instanceof AccessDenied)\n            $errors['err'] = $result->reason;\n\n        self::authAudit($result);\n    }\n\n    static function getSearchDirectories() {\n        $backends = array();\n        foreach (StaffAuthenticationBackend::allRegistered() as $bk)\n            if ($bk instanceof AuthDirectorySearch)\n                $backends[$bk::$id] = $bk;\n\n        foreach (UserAuthenticationBackend::allRegistered() as $bk)\n            if ($bk instanceof AuthDirectorySearch)\n                $backends[$bk::$id] = $bk;\n\n        return array_unique($backends);\n    }\n\n    static function searchUsers($query) {\n        $users = array();\n        foreach (static::getSearchDirectories() as $bk)\n            $users = array_merge($users, $bk->search($query));\n\n        return $users;\n    }\n\n    /**\n     * Fetches the friendly name of the backend\n     */\n    function getName() {\n        return static::$name;\n    }\n\n    /**\n     * Indicates if the backed supports authentication. Useful if the\n     * backend is used for logging or lockout only\n     */\n    function supportsInteractiveAuthentication() {\n        return true;\n    }\n\n    /**\n     * Indicates if the backend supports changing a user's password. This\n     * would be done in two fashions. Either the currently-logged in user\n     * want to change its own password or a user requests to have their\n     * password reset. This requires an administrative privilege which this\n     * backend might not possess, so it's defined in supportsPasswordReset()\n     */\n    function supportsPasswordChange() {\n        return false;\n    }\n\n\n    /**\n     * Get supported password policies for the backend.\n     *\n     */\n    function getPasswordPolicies($user=null) {\n        return PasswordPolicy::allActivePolicies();\n    }\n\n    /**\n     * Request the backend to update the password for a user. This method is\n     * the main entry for password updates so that password policies can be\n     * applied to the new password before passing the new password to the\n     * backend for updating.\n     *\n     * Throws:\n     * BadPassword \u2014 if password does not meet policy requirement\n     * PasswordUpdateFailed \u2014 if backend failed to update the password\n     */\n    function setPassword($user, $password, $current=false) {\n        foreach ($this->getPasswordPolicies($user) as $P)\n            $P->onSet($password, $current);\n\n        $rv = $this->syncPassword($user, $password);\n        if ($rv) {\n            $info = array('password' => $password, 'current' => $current);\n            Signal::send('auth.pwchange', $user, $info);\n        }\n        return $rv;\n    }\n\n    /*\n     * Request the backend to check the policies for a just logged\n     * in user.\n     * Throws: BadPassword & ExpiredPassword - for password related failures\n     */\n    function checkPolicies($user, $password) {\n        // Password policies\n        foreach ($this->getPasswordPolicies($user) as $P)\n            $P->onLogin($user, $password);\n    }\n\n    /**\n     * Request the backend to update the user's password with the password\n     * given. This method should only be used if the backend advertises\n     * supported password updates with the supportsPasswordChange() method.\n     *\n     * Returns:\n     * true if the password was successfully updated and false otherwise.\n     */\n    protected function syncPassword($user, $password) {\n        return false;\n    }\n\n    function supportsPasswordReset() {\n        return false;\n    }\n\n    function signOn() {\n        return null;\n    }\n\n    protected function validate($auth) {\n        return null;\n    }\n\n    protected function audit($result, $credentials) {\n        return null;\n    }\n\n    abstract function authenticate($username, $password);\n    abstract function login($user, $bk);\n    abstract static function getUser(); //Validates  authenticated users.\n    abstract function getAllowedBackends($userid);\n    abstract protected function getAuthKey($user);\n    abstract static function signOut($user);\n}\n\n/**\n * ExternalAuthenticationBackend\n *\n * External authentication backends are backends such as Google+ which\n * require a redirect to a remote site and a redirect back to osTicket in\n * order for a  user to be authenticated. For such backends, neither the\n * username and password fields nor single sign on alone can be used to\n * authenticate the user.\n */\ninterface ExternalAuthentication {\n\n    /**\n     * Requests the backend to render an external link box. When the user\n     * clicks this box, the backend will be prompted to redirect the user to\n     * the remote site for authentication there.\n     */\n    function renderExternalLink();\n\n    /**\n     * Function: getServiceName\n     *\n     * Called to get the service name displayed on login page.\n     */\n     function getServiceName();\n\n    /**\n     * Function: triggerAuth\n     *\n     * Called when a user clicks the button rendered in the\n     * ::renderExternalLink() function. This method should initiate the\n     * remote authentication mechanism.\n     */\n    function triggerAuth();\n}\n\nabstract class StaffAuthenticationBackend  extends AuthenticationBackend {\n\n    static private $_registry = array();\n\n    static function _register($class) {\n        static::$_registry[$class::$id] = $class;\n    }\n\n    static function allRegistered() {\n        return array_merge(self::$_registry, parent::allRegistered());\n    }\n\n    function isBackendAllowed($staff, $bk) {\n\n        if (!($backends=self::getAllowedBackends($staff->getId())))\n            return true;  //No restrictions\n\n        return in_array($bk::$id, array_map('strtolower', $backends));\n    }\n\n    function getPasswordPolicies($user=null) {\n        global $cfg;\n        $policies = PasswordPolicy::allActivePolicies();\n        if ($cfg && ($policy = $cfg->getStaffPasswordPolicy())) {\n            foreach ($policies as $P)\n                if ($policy == $P::$id)\n                    return array($P);\n        }\n\n        return $policies;\n    }\n\n    function getAllowedBackends($userid) {\n\n        $backends =array();\n        //XXX: Only one backend can be specified at the moment.\n        $sql = 'SELECT backend FROM '.STAFF_TABLE\n              .' WHERE backend IS NOT NULL ';\n        if (is_numeric($userid))\n            $sql.= ' AND staff_id='.db_input($userid);\n        else {\n            $sql.= ' AND (username='.db_input($userid) .' OR email='.db_input($userid).')';\n        }\n\n        if (($res=db_query($sql, false)) && db_num_rows($res))\n            $backends[] = db_result($res);\n\n        return array_filter($backends);\n    }\n\n    function login($staff, $bk) {\n        global $ost;\n\n        if (!$bk || !($staff instanceof Staff))\n            return false;\n\n        // Ensure staff is allowed for realz to be authenticated via the backend.\n        if (!static::isBackendAllowed($staff, $bk)\n            || !($authkey=$bk->getAuthKey($staff)))\n            return false;\n\n        //Log debug info.\n        $ost->logDebug(_S('Agent Login'),\n            sprintf(_S(\"%s logged in [%s], via %s\"), $staff->getUserName(),\n                $_SERVER['REMOTE_ADDR'], get_class($bk))); //Debug.\n\n        $agent = Staff::lookup($staff->getId());\n        $type = array('type' => 'login');\n        Signal::send('person.login', $agent, $type);\n\n        // Check if the agent has 2fa enabled\n        $auth2fa = null;\n        if (($_2fa = $staff->get2FABackend())\n                && ($token=$_2fa->send($staff))) {\n            $auth2fa = sprintf('%s:%s:%s',\n                    $_2fa->getId(), md5($token.$staff->getId()), time());\n        }\n\n        // Tag the authkey.\n        $authkey = $bk::$id.':'.$authkey;\n        // Now set session crap and lets roll baby!\n        $authsession = &$_SESSION['_auth']['staff'];\n        $authsession = array(); //clear.\n        $authsession['id'] = $staff->getId();\n        $authsession['key'] =  $authkey;\n        $authsession['2fa'] =  $auth2fa;\n\n        $staff->setAuthKey($authkey);\n        $staff->refreshSession(true); //set the hash.\n        Signal::send('auth.login.succeeded', $staff);\n\n        if ($bk->supportsInteractiveAuthentication())\n            $staff->cancelResetTokens();\n\n\n        // Update last-used language, login time, etc\n        $staff->onLogin($bk);\n\n        return true;\n    }\n\n    /* Base signOut\n     *\n     * Backend should extend the signout and perform any additional signout\n     * it requires.\n     */\n\n    static function signOut($staff) {\n        global $ost;\n\n        $_SESSION['_auth']['staff'] = array();\n        unset($_SESSION[':token']['staff']);\n        $ost->logDebug(_S('Agent logout'),\n                sprintf(_S(\"%s logged out [%s]\"),\n                    $staff->getUserName(),\n                    $_SERVER['REMOTE_ADDR'])); //Debug.\n\n        $agent = Staff::lookup($staff->getId());\n        $type = array('type' => 'logout');\n        Signal::send('person.logout', $agent, $type);\n        Signal::send('auth.logout', $staff);\n    }\n\n    // Called to get authenticated user (if any)\n    static function getUser() {\n\n        if (!isset($_SESSION['_auth']['staff'])\n                || !$_SESSION['_auth']['staff']['key'])\n            return null;\n\n        list($id, $auth) = explode(':', $_SESSION['_auth']['staff']['key']);\n\n        if (!($bk=static::getBackend($id)) //get the backend\n                || !($staff = $bk->validate($auth)) //Get AuthicatedUser\n                || !($staff instanceof Staff)\n                || !$staff->isActive()\n                || $staff->getId() != $_SESSION['_auth']['staff']['id'] // check ID\n        )\n            return null;\n\n        $staff->setAuthKey($_SESSION['_auth']['staff']['key']);\n\n        return $staff;\n    }\n\n    function authenticate($username, $password) {\n        return false;\n    }\n\n    // Generic authentication key for staff's backend is the username\n    protected function getAuthKey($staff) {\n\n        if(!($staff instanceof Staff))\n            return null;\n\n        return $staff->getUsername();\n    }\n\n    protected function validate($authkey) {\n\n        if (($staff = StaffSession::lookup($authkey))\n            && $staff->getId()\n            && $staff->isActive())\n            return $staff;\n    }\n}\n\nabstract class ExternalStaffAuthenticationBackend\n        extends StaffAuthenticationBackend\n        implements ExternalAuthentication {\n\n    static $fa_icon = \"signin\";\n    static $sign_in_image_url = false;\n    static $service_name = \"External\";\n\n    function getServiceName() {\n        return __(static::$service_name);\n    }\n\n    function renderExternalLink() {\n        $service = sprintf('%s %s',\n                __('Sign in with'),\n                $this->getServiceName());\n        ?>\n        <a class=\"external-sign-in\" title=\"<?php echo $service; ?>\"\n                href=\"login.php?do=ext&amp;bk=<?php echo urlencode(static::$id); ?>\">\n<?php if (static::$sign_in_image_url) { ?>\n        <img class=\"sign-in-image\" src=\"<?php echo static::$sign_in_image_url;\n            ?>\" alt=\"<?php echo $service; ?>\"/>\n<?php } else { ?>\n            <div class=\"external-auth-box\">\n            <span class=\"external-auth-icon\">\n                <i class=\"icon-<?php echo static::$fa_icon; ?> icon-large icon-fixed-with\"></i>\n            </span>\n            <span class=\"external-auth-name\">\n               <?php echo $service; ?>\n            </span>\n            </div>\n<?php } ?>\n        </a><?php\n    }\n\n    function triggerAuth() {\n        $_SESSION['ext:bk:class'] = get_class($this);\n    }\n}\nSignal::connect('api', function($dispatcher) {\n    $dispatcher->append(\n        url('^/auth/ext$', function() {\n            if ($class = $_SESSION['ext:bk:class']) {\n                $bk = StaffAuthenticationBackend::getBackend($class::$id)\n                    ?: UserAuthenticationBackend::getBackend($class::$id);\n                if ($bk instanceof ExternalAuthentication)\n                    $bk->triggerAuth();\n            }\n        })\n    );\n});\n\nabstract class UserAuthenticationBackend  extends AuthenticationBackend {\n\n    static private $_registry = array();\n\n    static function _register($class) {\n        static::$_registry[$class::$id] = $class;\n    }\n\n    static function allRegistered() {\n        return array_merge(self::$_registry, parent::allRegistered());\n    }\n\n\n    function getPasswordPolicies($user=null) {\n        global $cfg;\n        $policies = PasswordPolicy::allActivePolicies();\n        if ($cfg && ($policy = $cfg->getClientPasswordPolicy())) {\n            foreach ($policies as $P)\n                if ($policy == $P::$id)\n                    return array($P);\n        }\n\n        return $policies;\n    }\n\n    function getAllowedBackends($userid) {\n        $backends = array();\n        $sql = 'SELECT A1.backend FROM '.USER_ACCOUNT_TABLE\n              .' A1 INNER JOIN '.USER_EMAIL_TABLE.' A2 ON (A2.user_id = A1.user_id)'\n              .' WHERE backend IS NOT NULL '\n              .' AND (A1.username='.db_input($userid)\n                  .' OR A2.`address`='.db_input($userid).')';\n\n        if (!($res=db_query($sql, false)))\n            return $backends;\n\n        while (list($bk) = db_fetch_row($res))\n            $backends[] = $bk;\n\n        return array_filter($backends);\n    }\n\n    function login($user, $bk) {\n        global $ost;\n\n        if (!$user || !$bk\n                || !$bk::$id //Must have ID\n                || !($authkey = $bk->getAuthKey($user)))\n            return false;\n\n        $acct = $user->getAccount();\n\n        if ($acct) {\n            if (!$acct->isConfirmed())\n                throw new AccessDenied(__('Account confirmation required'));\n            elseif ($acct->isLocked())\n                throw new AccessDenied(__('Account is administratively locked'));\n        }\n\n        // Tag the user and associated ticket in the SESSION\n        $this->setAuthKey($user, $bk, $authkey);\n\n        //The backend used decides the format of the auth key.\n        // XXX: encrypt to hide the bk??\n        $user->setAuthKey($authkey);\n\n        $user->refreshSession(true); //set the hash.\n\n        //Log login info...\n        $msg=sprintf(_S('%1$s (%2$s) logged in [%3$s]'\n                /* Tokens are <username>, <id>, and <ip> */),\n                $user->getUserName(), $user->getId(), $_SERVER['REMOTE_ADDR']);\n        $ost->logDebug(_S('User login'), $msg);\n\n        $u = $user->getSessionUser()->getUser();\n        $type = array('type' => 'login');\n        Signal::send('person.login', $u, $type);\n\n        if ($bk->supportsInteractiveAuthentication() && ($acct=$user->getAccount()))\n            $acct->cancelResetTokens();\n\n        // Update last-used language, login time, etc\n        $user->onLogin($bk);\n\n        return true;\n    }\n\n    function setAuthKey($user, $bk, $key=false) {\n        $authkey = $key ?: $bk->getAuthKey($user);\n\n        //Tag the authkey.\n        $authkey = $bk::$id.':'.$authkey;\n\n        //Set the session goodies\n        $authsession = &$_SESSION['_auth']['user'];\n\n        $authsession = array(); //clear.\n        $authsession['id'] = $user->getId();\n        $authsession['key'] = $authkey;\n    }\n\n    function authenticate($username, $password) {\n        return false;\n    }\n\n    static function signOut($user) {\n        global $ost;\n\n        $_SESSION['_auth']['user'] = array();\n        unset($_SESSION[':token']['client']);\n        $ost->logDebug(_S('User logout'),\n            sprintf(_S(\"%s logged out [%s]\" /* Tokens are <username> and <ip> */),\n                $user->getUserName(), $_SERVER['REMOTE_ADDR']));\n\n        $u = $user->getSessionUser()->getUser();\n        $type = array('type' => 'logout');\n        Signal::send('person.logout', $u, $type);\n    }\n\n    protected function getAuthKey($user) {\n        return  $user->getId();\n    }\n\n    static function getUser() {\n\n        if (!isset($_SESSION['_auth']['user'])\n                || !$_SESSION['_auth']['user']['key'])\n            return null;\n\n        list($id, $auth) = explode(':', $_SESSION['_auth']['user']['key']);\n\n        if (!($bk=static::getBackend($id)) //get the backend\n                || !($user=$bk->validate($auth)) //Get AuthicatedUser\n                || !($user instanceof AuthenticatedUser) // Make sure it user\n                || $user->getId() != $_SESSION['_auth']['user']['id'] // check ID\n                )\n            return null;\n\n        if (($account=$user->getAccount()) && !$account->isActive())\n            return null;\n\n        $user->setAuthKey($_SESSION['_auth']['user']['key']);\n\n        return $user;\n    }\n\n    protected function validate($userid) {\n        if (!($user = User::lookup($userid)))\n            return false;\n        elseif (!($account=$user->getAccount()))\n            return false;\n        elseif (!$account->isActive())\n            return false;\n\n        return new ClientSession(new EndUser($user));\n    }\n}\n\nabstract class ExternalUserAuthenticationBackend\n        extends UserAuthenticationBackend\n        implements ExternalAuthentication {\n\n    static $fa_icon = \"signin\";\n    static $sign_in_image_url = false;\n    static $service_name = \"External\";\n\n    function getServiceName() {\n        return __(static::$service_name);\n    }\n\n    function renderExternalLink() {\n        $service = sprintf('%s %s',\n                __('Sign in with'),\n                $this->getServiceName());\n\n        ?>\n        <a class=\"external-sign-in\" title=\"<?php echo $service; ?>\"\n                href=\"login.php?do=ext&amp;bk=<?php echo urlencode(static::$id); ?>\">\n<?php if (static::$sign_in_image_url) { ?>\n        <img class=\"sign-in-image\" src=\"<?php echo static::$sign_in_image_url;\n            ?>\" alt=\"<?php $service; ?>\"/>\n<?php } else { ?>\n            <div class=\"external-auth-box\">\n            <span class=\"external-auth-icon\">\n                <i class=\"icon-<?php echo static::$fa_icon; ?> icon-large icon-fixed-with\"></i>\n            </span>\n            <span class=\"external-auth-name\">\n                <?php echo $service; ?>\n            </span>\n            </div>\n<?php } ?>\n        </a><?php\n    }\n\n    function triggerAuth() {\n        $_SESSION['ext:bk:class'] = get_class($this);\n    }\n}\n\n/**\n * This will be an exception in later versions of PHP\n */\nclass AccessDenied extends Exception {\n    function __construct($reason) {\n        $this->reason = $reason;\n        parent::__construct($reason);\n    }\n}\n\n/**\n * Simple authentication backend which will lock the login form after a\n * configurable number of attempts\n */\nabstract class AuthStrikeBackend extends AuthenticationBackend {\n\n    function authenticate($username, $password=null) {\n        return static::authTimeout();\n    }\n\n    function signOn() {\n        return static::authTimeout();\n    }\n\n    static function signOut($user) {\n        return false;\n    }\n\n\n    function login($user, $bk) {\n        return false;\n    }\n\n    static function getUser() {\n        return null;\n    }\n\n    function supportsInteractiveAuthentication() {\n        return false;\n    }\n\n    function getAllowedBackends($userid) {\n        return array();\n    }\n\n    function getAuthKey($user) {\n        return null;\n    }\n\n    //Provides audit facility for logins attempts\n    function audit($result, $credentials) {\n\n        //Count failed login attempts as a strike.\n        if ($result instanceof AccessDenied)\n            return static::authStrike($credentials);\n\n    }\n\n    abstract function authStrike($credentials);\n    abstract function authTimeout();\n}\n\n/*\n * Backend to monitor staff's failed login attempts\n */\nclass StaffAuthStrikeBackend extends  AuthStrikeBackend {\n\n    function authTimeout() {\n        global $ost;\n\n        $cfg = $ost->getConfig();\n\n        $authsession = &$_SESSION['_auth']['staff'];\n        if (!$authsession['laststrike'])\n            return;\n\n        //Veto login due to excessive login attempts.\n        if((time()-$authsession['laststrike'])<$cfg->getStaffLoginTimeout()) {\n            $authsession['laststrike'] = time(); //reset timer.\n            return new AccessDenied(__('Maximum failed login attempts reached'));\n        }\n\n        //Timeout is over.\n        //Reset the counter for next round of attempts after the timeout.\n        $authsession['laststrike']=null;\n        $authsession['strikes']=0;\n    }\n\n    function authstrike($credentials) {\n        global $ost;\n\n        $cfg = $ost->getConfig();\n\n        $authsession = &$_SESSION['_auth']['staff'];\n\n        $username = $credentials['username'];\n\n        $authsession['strikes']+=1;\n        if($authsession['strikes']>$cfg->getStaffMaxLogins()) {\n            $authsession['laststrike']=time();\n            $timeout = $cfg->getStaffLoginTimeout()/60;\n            $alert=_S('Excessive login attempts by an agent?').\"\\n\"\n                   ._S('Username').\": $username\\n\"\n                   ._S('IP').\": {$_SERVER['REMOTE_ADDR']}\\n\"\n                   ._S('Time').\": \".date('M j, Y, g:i a T').\"\\n\\n\"\n                   ._S('Attempts').\": {$authsession['strikes']}\\n\"\n                   ._S('Timeout').\": \".sprintf(_N('%d minute', '%d minutes', $timeout), $timeout).\"\\n\\n\";\n            $admin_alert = ($cfg->alertONLoginError() == 1) ? TRUE : FALSE;\n            $ost->logWarning(sprintf(_S('Excessive login attempts (%s)'),$username),\n                    $alert, $admin_alert);\n\n              if ($username) {\n                $agent = Staff::lookup($username);\n                $type = array('type' => 'login', 'msg' => sprintf('Excessive login attempts (%s)', $authsession['strikes']));\n                Signal::send('person.login', $agent, $type);\n              }\n\n            return new AccessDenied(__('Forgot your login info? Contact Admin.'));\n        //Log every other third failed login attempt as a warning.\n        } elseif($authsession['strikes']%3==0) {\n            $alert=_S('Username').\": {$username}\\n\"\n                    ._S('IP').\": {$_SERVER['REMOTE_ADDR']}\\n\"\n                    ._S('Time').\": \".date('M j, Y, g:i a T').\"\\n\\n\"\n                    ._S('Attempts').\": {$authsession['strikes']}\";\n            $ost->logWarning(sprintf(_S('Failed agent login attempt (%s)'),$username),\n                $alert, false);\n        }\n    }\n}\nStaffAuthenticationBackend::register('StaffAuthStrikeBackend');\n\n/*\n * Backend to monitor user's failed login attempts\n */\nclass UserAuthStrikeBackend extends  AuthStrikeBackend {\n\n    function authTimeout() {\n        global $ost;\n\n        $cfg = $ost->getConfig();\n\n        $authsession = &$_SESSION['_auth']['user'];\n        if (!$authsession['laststrike'])\n            return;\n\n        //Veto login due to excessive login attempts.\n        if ((time()-$authsession['laststrike']) < $cfg->getStaffLoginTimeout()) {\n            $authsession['laststrike'] = time(); //reset timer.\n            return new AccessDenied(__(\"You've reached maximum failed login attempts allowed.\"));\n        }\n\n        //Timeout is over.\n        //Reset the counter for next round of attempts after the timeout.\n        $authsession['laststrike']=null;\n        $authsession['strikes']=0;\n    }\n\n    function authstrike($credentials) {\n        global $ost;\n\n        $cfg = $ost->getConfig();\n\n        $authsession = &$_SESSION['_auth']['user'];\n\n        $username = $credentials['username'];\n        $password = $credentials['password'];\n\n        $authsession['strikes']+=1;\n        if($authsession['strikes']>$cfg->getClientMaxLogins()) {\n            $authsession['laststrike'] = time();\n            $alert=_S('Excessive login attempts by a user.').\"\\n\".\n                    _S('Username').\": {$username}\\n\".\n                    _S('IP').\": {$_SERVER['REMOTE_ADDR']}\\n\".\n                    _S('Time').\": \".date('M j, Y, g:i a T').\"\\n\\n\".\n                    _S('Attempts').\": {$authsession['strikes']}\";\n            $admin_alert = ($cfg->alertONLoginError() == 1 ? TRUE : FALSE);\n            $ost->logError(_S('Excessive login attempts (user)'), $alert, $admin_alert);\n\n            if ($username) {\n              $account = UserAccount::lookupByUsername($username);\n              $id = UserEmailModel::getIdByEmail($username);\n              if ($account)\n                  $user = User::lookup($account->user_id);\n              elseif ($id)\n                $user = User::lookup($id);\n\n              if ($user) {\n                $type = array('type' => 'login', 'msg' => sprintf('Excessive login attempts (%s)', $authsession['strikes']));\n                Signal::send('person.login', $user, $type);\n              }\n            }\n\n            return new AccessDenied(__('Access denied'));\n        } elseif($authsession['strikes']%3==0) { //Log every third failed login attempt as a warning.\n            $alert=_S('Username').\": {$username}\\n\".\n                    _S('IP').\": {$_SERVER['REMOTE_ADDR']}\\n\".\n                    _S('Time').\": \".date('M j, Y, g:i a T').\"\\n\\n\".\n                    _S('Attempts').\": {$authsession['strikes']}\";\n            $ost->logWarning(_S('Failed login attempt (user)'), $alert, false);\n        }\n\n    }\n}\nUserAuthenticationBackend::register('UserAuthStrikeBackend');\n\n\nclass osTicketStaffAuthentication extends StaffAuthenticationBackend {\n    static $name = \"Local Authentication\";\n    static $id = \"local\";\n\n    function authenticate($username, $password) {\n        if (($user = StaffSession::lookup($username)) && $user->getId() &&\n                $user->check_passwd($password)) {\n            try {\n                $this->checkPolicies($user, $password);\n            } catch (BadPassword | ExpiredPassword $ex) {\n                $user->change_passwd = 1;\n            }\n            return $user;\n        }\n    }\n\n    function supportsPasswordChange() {\n        return true;\n    }\n\n    function syncPassword($staff, $password) {\n        $staff->passwd = Passwd::hash($password);\n    }\n\n    static function checkPassword($new, $current) {\n        PasswordPolicy::checkPassword($new, $current, new self());\n    }\n\n}\nStaffAuthenticationBackend::register('osTicketStaffAuthentication');\n\nclass PasswordResetTokenBackend extends StaffAuthenticationBackend {\n    static $id = \"pwreset.staff\";\n\n    function supportsInteractiveAuthentication() {\n        return false;\n    }\n\n    function signOn($errors=array()) {\n        global $ost;\n\n        if (!isset($_POST['userid']) || !isset($_POST['token']))\n            return false;\n        elseif (!($_config = new Config('pwreset')))\n            return false;\n\n        $staff = StaffSession::lookup($_POST['userid']);\n        if (!$staff || !$staff->getId())\n            $errors['msg'] = __('Invalid user-id given');\n        elseif (!($id = $_config->get($_POST['token']))\n                || $id != $staff->getId())\n            $errors['msg'] = __('Invalid reset token');\n        elseif (!($ts = $_config->lastModified($_POST['token']))\n                && ($ost->getConfig()->getPwResetWindow() < (time() - strtotime($ts))))\n            $errors['msg'] = __('Invalid reset token');\n        elseif (!$staff->forcePasswdRest())\n            $errors['msg'] = __('Unable to reset password');\n        else\n            return $staff;\n    }\n\n    function login($staff, $bk) {\n        $_SESSION['_staff']['reset-token'] = $_POST['token'];\n        Signal::send('auth.pwreset.login', $staff);\n        return parent::login($staff, $bk);\n    }\n}\nStaffAuthenticationBackend::register('PasswordResetTokenBackend');\n\n/*\n * AuthToken Authentication Backend\n *\n * Provides auto-login facility for end users with valid link\n *\n * Ticket used to loggin is tracked durring the session this is\n * important in the future when auto-logins will be\n * limited to single ticket view.\n */\nclass AuthTokenAuthentication extends UserAuthenticationBackend {\n    static $name = \"Auth Token Authentication\";\n    static $id = \"authtoken\";\n\n\n    function signOn() {\n        global $cfg;\n\n\n        if (!$cfg || !$cfg->isAuthTokenEnabled())\n            return null;\n\n        $user = null;\n        if ($_GET['auth']) {\n            if (($u = TicketUser::lookupByToken($_GET['auth'])))\n                $user = new ClientSession($u);\n        }\n        // Support old ticket based tokens.\n        elseif ($_GET['t'] && $_GET['e'] && $_GET['a']) {\n            if (($ticket = Ticket::lookupByNumber($_GET['t'], $_GET['e']))\n                    // Using old ticket auth code algo - hardcoded here because it\n                    // will be removed in ticket class in the upcoming rewrite\n                    && strcasecmp((string) $_GET['a'], md5($ticket->getId()\n                            .  strtolower($_GET['e']) . SECRET_SALT)) === 0\n                    && ($owner = $ticket->getOwner()))\n                $user = new ClientSession($owner);\n        }\n\n        return $user;\n    }\n\n    function supportsInteractiveAuthentication() {\n        return false;\n    }\n\n    protected function getAuthKey($user) {\n\n        if (!$user)\n            return null;\n\n        //Generate authkey based the type of ticket user\n        // It's required to validate users going forward.\n        $authkey = sprintf('%s%dt%dh%s',  //XXX: Placeholder\n                    ($user->isOwner() ? 'o':'c'),\n                    $user->getId(),\n                    $user->getTicketId(),\n                    md5($user->getId().$this->id));\n\n        return $authkey;\n    }\n\n    protected function validate($authkey) {\n\n        $regex = '/^(?P<type>\\w{1})(?P<id>\\d+)t(?P<tid>\\d+)h(?P<hash>.*)$/i';\n        $matches = array();\n        if (!preg_match($regex, $authkey, $matches))\n            return false;\n\n        $user = null;\n        switch ($matches['type']) {\n            case 'c': //Collaborator\n                $criteria = array(\n                    'user_id' => $matches['id'],\n                    'thread__ticket__ticket_id' => $matches['tid']\n                );\n                if (($c = Collaborator::lookup($criteria))\n                        && ($c->getTicketId() == $matches['tid']))\n                    $user = new ClientSession($c);\n                break;\n            case 'o': //Ticket owner\n                if (($ticket = Ticket::lookup($matches['tid']))\n                        && ($o = $ticket->getOwner())\n                        && ($o->getId() == $matches['id']))\n                    $user = new ClientSession($o);\n                break;\n        }\n\n        //Make sure the authkey matches.\n        if (!$user || strcmp($this->getAuthKey($user), $authkey))\n            return null;\n\n        $user->flagGuest();\n\n        return $user;\n    }\n\n}\n\nUserAuthenticationBackend::register('AuthTokenAuthentication');\n\n//Simple ticket lookup backend used to recover ticket access link.\n// We're using authentication backend so we can guard aganist brute force\n// attempts (which doesn't buy much since the link is emailed)\nclass AccessLinkAuthentication extends UserAuthenticationBackend {\n    static $name = \"Ticket Access Link Authentication\";\n    static $id = \"authlink\";\n\n    function authenticate($email, $number) {\n\n        if (!($ticket = Ticket::lookupByNumber($number))\n                || !($user=User::lookup(array('emails__address' => $email))))\n            return false;\n\n        if (!($user = $this->_getTicketUser($ticket, $user)))\n            return false;\n\n        $_SESSION['_auth']['user-ticket'] = $number;\n        return new ClientSession($user);\n    }\n\n    function _getTicketUser($ticket, $user) {\n        // Ticket owner?\n        if ($ticket->getUserId() == $user->getId())\n            $user = $ticket->getOwner();\n        // Collaborator?\n        elseif (!($user = Collaborator::lookup(array(\n                'user_id' => $user->getId(),\n                'thread__ticket__ticket_id' => $ticket->getId())\n        )))\n            return false; //Bro, we don't know you!\n\n        return $user;\n    }\n\n    // We are not actually logging in the user....\n    function login($user, $bk) {\n        global $cfg;\n\n        if (!$cfg->isClientEmailVerificationRequired()) {\n            return parent::login($user, $bk);\n        }\n        return true;\n    }\n\n    protected function validate($userid) {\n        $number = $_SESSION['_auth']['user-ticket'];\n\n        if (!($ticket = Ticket::lookupByNumber($number)))\n            return false;\n\n        if (!($user = User::lookup($userid)))\n            return false;\n\n        if (!($user = $this->_getTicketUser($ticket, $user)))\n            return false;\n\n        $user = new ClientSession($user);\n        $user->flagGuest();\n        return $user;\n    }\n\n    function supportsInteractiveAuthentication() {\n        return false;\n    }\n}\nUserAuthenticationBackend::register('AccessLinkAuthentication');\n\nclass osTicketClientAuthentication extends UserAuthenticationBackend {\n    static $name = \"Local Client Authentication\";\n    static $id = \"client\";\n\n    function authenticate($username, $password) {\n        if (!($acct = ClientAccount::lookupByUsername($username)))\n            return;\n\n        if (($client = new ClientSession(new EndUser($acct->getUser())))\n                && !$client->getId())\n            return false;\n        elseif (!$acct->check_passwd($password))\n            return false;\n        else\n            return $client;\n    }\n\n    static function checkPassword($new, $current) {\n        PasswordPolicy::checkPassword($new, $current, new self());\n    }\n}\nUserAuthenticationBackend::register('osTicketClientAuthentication');\n\nclass ClientPasswordResetTokenBackend extends UserAuthenticationBackend {\n    static $id = \"pwreset.client\";\n\n    function supportsInteractiveAuthentication() {\n        return false;\n    }\n\n    function signOn($errors=array()) {\n        global $ost;\n\n        if (!isset($_POST['userid']) || !isset($_POST['token']))\n            return false;\n        elseif (!($_config = new Config('pwreset')))\n            return false;\n        elseif (!($acct = ClientAccount::lookupByUsername($_POST['userid']))\n                || !$acct->getId()\n                || !($client = new ClientSession(new EndUser($acct->getUser()))))\n            $errors['msg'] = __('Invalid user-id given');\n        elseif (!($id = $_config->get($_POST['token']))\n                || $id != 'c'.$client->getId())\n            $errors['msg'] = __('Invalid reset token');\n        elseif (!($ts = $_config->lastModified($_POST['token']))\n                && ($ost->getConfig()->getPwResetWindow() < (time() - strtotime($ts))))\n            $errors['msg'] = __('Invalid reset token');\n        elseif (!$acct->forcePasswdReset())\n            $errors['msg'] = __('Unable to reset password');\n        else\n            return $client;\n    }\n\n    function login($client, $bk) {\n        $_SESSION['_client']['reset-token'] = $_POST['token'];\n        Signal::send('auth.pwreset.login', $client);\n        return parent::login($client, $bk);\n    }\n}\nUserAuthenticationBackend::register('ClientPasswordResetTokenBackend');\n\nclass ClientAcctConfirmationTokenBackend extends UserAuthenticationBackend {\n    static $id = \"confirm.client\";\n\n    function supportsInteractiveAuthentication() {\n        return false;\n    }\n\n    function signOn($errors=array()) {\n        global $ost;\n\n        if (!isset($_GET['token']))\n            return false;\n        elseif (!($_config = new Config('pwreset')))\n            return false;\n        elseif (!($id = $_config->get($_GET['token'])))\n            return false;\n        elseif (!($acct = ClientAccount::lookup(array('user_id'=>substr($id,1))))\n                || !$acct->getId()\n                || $id != 'c'.$acct->getUserId()\n                || !($client = new ClientSession(new EndUser($acct->getUser()))))\n            return false;\n        else\n            return $client;\n    }\n}\nUserAuthenticationBackend::register('ClientAcctConfirmationTokenBackend');\n\n// ----- Password Policy --------------------------------------\n\nclass BadPassword extends Exception {}\nclass ExpiredPassword extends Exception {}\nclass PasswordUpdateFailed extends Exception {}\n\nabstract class PasswordPolicy {\n    static protected $registry = array();\n\n    static $id;\n    static $name;\n\n    /**\n     * Check a password and throw BadPassword with a meaningful message if\n     * the password cannot be accepted.\n     */\n    abstract function onset($new, $current);\n\n    /*\n     * Called on login to enforce policies & check for expired passwords\n     */\n    abstract function onLogin($user, $password);\n\n    /*\n     * get friendly name of the policy\n     */\n    function getName() {\n        return static::$name;\n    }\n\n    /*\n     * Check a password aganist all available policies \n     */\n    static function checkPassword($new, $current, $bk=null) {\n        if ($bk && is_a($bk, 'AuthenticationBackend'))\n            $policies = $bk->getPasswordPolicies();\n        else\n            $policies = self::allActivePolicies();\n\n        foreach ($policies as $P)\n            $P->onSet($new, $current);\n    }\n\n    static function allActivePolicies() {\n        $policies = array();\n        foreach (array_reverse(static::$registry) as $P) {\n            if (is_string($P) && class_exists($P))\n                $P = new $P();\n            if ($P instanceof PasswordPolicy)\n                $policies[] = $P;\n        }\n        return $policies;\n    }\n\n    static function register($policy) {\n        static::$registry[] = $policy;\n    }\n\n    static function cleanSessions($model, $user=null) {\n        $criteria = array();\n\n        switch (true) {\n            case ($model instanceof Staff):\n                $criteria['user_id'] = $model->getId();\n\n                if ($user && ($model->getId() == $user->getId()))\n                    array_push($criteria,\n                        Q::not(array('session_id' => $user->session->session_id)));\n                break;\n            case ($model instanceof User):\n                $regexp = '_auth\\|.*\"user\";[a-z]+:[0-9]+:\\{[a-z]+:[0-9]+:\"id\";[a-z]+:'.$model->getId();\n                $criteria['user_id'] = 0;\n                $criteria['session_data__regex'] = $regexp;\n\n                if ($user)\n                    array_push($criteria,\n                        Q::not(array('session_id' => $user->session->session_id)));\n                break;\n            default:\n                return false;\n        }\n\n        return SessionData::objects()->filter($criteria)->delete();\n    }\n}\nSignal::connect('auth.clean', array('PasswordPolicy', 'cleanSessions'));\n\n/*\n * Basic default password policy that ships with osTicket.\n * \n */\nclass osTicketPasswordPolicy\nextends PasswordPolicy {\n    static $id = \"basic\";\n    static $name = /* @trans */ \"Default Basic Policy\";\n\n    function onLogin($user, $password) {\n        global $cfg;\n\n        // Check for possible password expiration\n        // Check is only here for legacy reasons - password management\n        // policies are now done via plugins.\n        if ($cfg && $user\n                && ($period=$cfg->getPasswdResetPeriod())\n                && ($time=$user->getPasswdResetTimestamp())\n                && $time < time()-($period*2629800))\n            throw new ExpiredPassword(__('Expired password'));\n    }\n\n    function onSet($passwd, $current) {\n        if (strlen($passwd) < 6) {\n            throw new BadPassword(\n                __('Password must be at least 6 characters'));\n        }\n        // XXX: Changing case is technicall changing the password\n        if (0 === strcasecmp($passwd, $current)) {\n            throw new BadPassword(\n                __('New password MUST be different from the current password!'));\n        }\n    }\n}\nPasswordPolicy::register('osTicketPasswordPolicy');\n?>\n", "<?php\n/*********************************************************************\n    class.usersession.php\n\n    User (client and staff) sessions handle.\n\n    Peter Rotich <peter@osticket.com>\n    Copyright (c)  2006-2013 osTicket\n    http://www.osticket.com\n\n    Released under the GNU General Public License WITHOUT ANY WARRANTY.\n    See LICENSE.TXT for details.\n\n    vim: expandtab sw=4 ts=4 sts=4:\n**********************************************************************/\n\ninclude_once(INCLUDE_DIR.'class.client.php');\ninclude_once(INCLUDE_DIR.'class.staff.php');\n\n\nclass UserSession {\n   var $session_id = '';\n   var $userID='';\n   var $browser = '';\n   var $ip = '';\n   var $validated=FALSE;\n\n   function __construct($userid){\n\n      $this->browser=(!empty($_SERVER['HTTP_USER_AGENT'])) ? $_SERVER['HTTP_USER_AGENT'] : $_ENV['HTTP_USER_AGENT'];\n      $this->ip=(!empty($_SERVER['REMOTE_ADDR'])) ? $_SERVER['REMOTE_ADDR'] : getenv('REMOTE_ADDR');\n      $this->session_id=session_id();\n      $this->userID=$userid;\n   }\n\n   function isStaff(){\n       return FALSE;\n   }\n\n   function isClient() {\n       return FALSE;\n   }\n\n\n   function getSessionId(){\n       return $this->session_id;\n   }\n\n   function getIP(){\n        return  $this->ip;\n   }\n\n   function getBrowser(){\n       return $this->browser;\n   }\n   function refreshSession(){\n       //nothing to do...clients need to worry about it.\n   }\n\n   function sessionToken(){\n\n      $time  = time();\n      $hash  = md5($time.SESSION_SECRET.$this->userID);\n      $token = \"$hash:$time:\".MD5($this->ip);\n\n      return($token);\n   }\n\n   function getLastUpdate($htoken) {\n       if (!$htoken)\n           return 0;\n\n       @list($hash,$expire,$ip)=explode(\":\",$htoken);\n       return $expire;\n   }\n\n   function isvalidSession($htoken,$maxidletime=0,$checkip=false){\n        global $cfg;\n\n        $token = rawurldecode($htoken);\n\n        #check if we got what we expected....\n        if($token && !strstr($token,\":\"))\n            return FALSE;\n\n        #get the goodies\n        list($hash,$expire,$ip)=explode(\":\",$token);\n\n        #Make sure the session hash is valid\n        if((md5($expire . SESSION_SECRET . $this->userID)!=$hash)){\n            return FALSE;\n        }\n        #is it expired??\n\n\n        if($maxidletime && ((time()-$expire)>$maxidletime)){\n            return FALSE;\n        }\n        #Make sure IP is still same ( proxy access??????)\n        if($checkip && strcmp($ip, MD5($this->ip)))\n            return FALSE;\n\n        $this->validated=TRUE;\n\n        return TRUE;\n   }\n\n   function isValid() {\n        return FALSE;\n   }\n\n}\n\nclass ClientSession extends EndUser {\n\n    var $session;\n    var $token;\n\n    function __construct($user) {\n        parent::__construct($user);\n        $this->token = &$_SESSION[':token']['client'];\n        // XXX: Change the key to user-id\n        $this->session= new UserSession($user->getId());\n    }\n\n    function getSessionUser() {\n        return $this->user;\n    }\n\n    function isValid(){\n        global $_SESSION,$cfg;\n\n        if(!$this->getId() || $this->session->getSessionId()!=session_id())\n            return false;\n\n        return $this->session->isvalidSession($this->token,$cfg->getClientTimeout(),false)?true:false;\n    }\n\n    function refreshSession($force=false){\n        global $cfg;\n\n        $time = $this->session->getLastUpdate($this->token);\n        // Deadband session token updates to once / 30-seconds\n        if (!$force && time() - $time < 30)\n            return;\n\n        $this->token = $this->getSessionToken();\n        //TODO: separate expire time from hash??\n\n        osTicketSession::renewCookie($time, $cfg->getClientSessionTimeout());\n    }\n\n    function getSession() {\n        return $this->session;\n    }\n\n    function getSessionToken() {\n        return $this->session->sessionToken();\n    }\n\n    function getIP(){\n        return $this->session->getIP();\n    }\n}\n\n\nclass StaffSession extends Staff {\n\n    var $session;\n    var $token;\n\n    static function lookup($var) {\n        if ($staff = parent::lookup($var)) {\n            $staff->token = &$_SESSION[':token']['staff'];\n            $staff->session= new UserSession($staff->getId());\n        }\n        return $staff;\n    }\n\n    function clear2FA() {\n        $_SESSION['_auth']['staff']['2fa'] = null;\n        return true;\n    }\n\n    // If 2fa is set then it means it's pending\n    function is2FAPending() {\n        if (!isset($_SESSION['_auth']['staff']['2fa']))\n            return false;\n\n        return true;\n    }\n\n    function isValid(){\n        global $cfg;\n\n        if(!$this->getId() || $this->session->getSessionId()!=session_id())\n            return false;\n\n        if ($this->is2FAPending())\n            return false;\n\n        return $this->session->isvalidSession($this->token,$cfg->getStaffTimeout(),$cfg->enableStaffIPBinding())?true:false;\n    }\n\n    function refreshSession($force=false){\n        global $cfg;\n\n        $time = $this->session->getLastUpdate($this->token);\n        // Deadband session token updates to once / 30-seconds\n        if (!$force && time() - $time < 30)\n            return;\n\n        $this->token=$this->getSessionToken();\n\n        osTicketSession::renewCookie($time, $cfg->getStaffSessionTimeout());\n    }\n\n    function getSession() {\n        return $this->session;\n    }\n\n    function getSessionToken() {\n        return $this->session->sessionToken();\n    }\n\n    function getIP(){\n        return $this->session->getIP();\n    }\n\n}\n\n?>\n", "<?php\n/*********************************************************************\n    open.php\n\n    New tickets handle.\n\n    Peter Rotich <peter@osticket.com>\n    Copyright (c)  2006-2013 osTicket\n    http://www.osticket.com\n\n    Released under the GNU General Public License WITHOUT ANY WARRANTY.\n    See LICENSE.TXT for details.\n\n    vim: expandtab sw=4 ts=4 sts=4:\n**********************************************************************/\nrequire('client.inc.php');\ndefine('SOURCE','Web'); //Ticket source.\n$ticket = null;\n$errors=array();\nif ($_POST) {\n    $vars = $_POST;\n    $vars['deptId']=$vars['emailId']=0; //Just Making sure we don't accept crap...only topicId is expected.\n    if ($thisclient) {\n        $vars['uid']=$thisclient->getId();\n    } elseif($cfg->isCaptchaEnabled()) {\n        if(!$_POST['captcha'])\n            $errors['captcha']=__('Enter text shown on the image');\n        elseif(strcmp($_SESSION['captcha'], md5(strtoupper($_POST['captcha']))))\n            $errors['captcha']=sprintf('%s - %s', __('Invalid'), __('Please try again!'));\n    }\n\n    $tform = TicketForm::objects()->one()->getForm($vars);\n    $messageField = $tform->getField('message');\n    $attachments = $messageField->getWidget()->getAttachments();\n    if (!$errors) {\n        $vars['message'] = $messageField->getClean();\n        if ($messageField->isAttachmentsEnabled())\n            $vars['files'] = $attachments->getFiles();\n    }\n\n    // Drop the draft.. If there are validation errors, the content\n    // submitted will be displayed back to the user\n    Draft::deleteForNamespace('ticket.client.'.substr(session_id(), -12));\n    //Ticket::create...checks for errors..\n    if(($ticket=Ticket::create($vars, $errors, SOURCE))){\n        $msg=__('Support ticket request created');\n        // Drop session-backed form data\n        unset($_SESSION[':form-data']);\n        //Logged in...simply view the newly created ticket.\n        if($thisclient && $thisclient->isValid()) {\n            session_regenerate_id();\n            session_write_close();\n            @header('Location: tickets.php?id='.$ticket->getId());\n        } else\n            $ost->getCSRF()->rotate();\n    }else{\n        $errors['err'] = $errors['err'] ?: sprintf('%s %s',\n            __('Unable to create a ticket.'),\n            __('Correct any errors below and try again.'));\n    }\n}\n\n//page\n$nav->setActiveNav('new');\nif ($cfg->isClientLoginRequired()) {\n    if ($cfg->getClientRegistrationMode() == 'disabled') {\n        Http::redirect('view.php');\n    }\n    elseif (!$thisclient) {\n        require_once 'secure.inc.php';\n    }\n    elseif ($thisclient->isGuest()) {\n        require_once 'login.php';\n        exit();\n    }\n}\n\nrequire(CLIENTINC_DIR.'header.inc.php');\nif ($ticket\n    && (\n        (($topic = $ticket->getTopic()) && ($page = $topic->getPage()))\n        || ($page = $cfg->getThankYouPage())\n    )\n) {\n    // Thank the user and promise speedy resolution!\n    echo Format::viewableImages(\n        $ticket->replaceVars(\n            $page->getLocalBody()\n        ),\n        ['type' => 'P']\n    );\n}\nelse {\n    require(CLIENTINC_DIR.'open.inc.php');\n}\nrequire(CLIENTINC_DIR.'footer.inc.php');\n?>\n"], "fixing_code": ["<?php\n\nrequire_once(INCLUDE_DIR.'class.2fa.php');\n\ninterface AuthenticatedUser {\n    // Get basic information\n    function getId();\n    function getUsername();\n    function getUserType();\n\n\n    // Get password reset timestamp\n    function getPasswdResetTimestamp();\n\n    //Backend used to authenticate the user\n    function getAuthBackend();\n\n    // Get 2FA Backend\n    function get2FABackend();\n\n    //Authentication key\n    function setAuthKey($key);\n\n    function getAuthKey();\n\n    // logOut the user\n    function logOut();\n\n    // Signal method to allow performing extra things when a user is logged\n    // into the sysem\n    function onLogin($bk);\n}\n\nabstract class BaseAuthenticatedUser\nimplements AuthenticatedUser {\n    //Authorization key returned by the backend used to authorize the user\n    private $authkey;\n\n    // Get basic information\n    abstract function getId();\n    abstract function getUsername();\n    abstract function getUserType();\n\n    // Get password reset timestamp\n    function getPasswdResetTimestamp() {\n        return null;\n    }\n\n    //Backend used to authenticate the user\n    abstract function getAuthBackend();\n\n    // Get 2FA Backend\n    abstract function get2FABackend();\n\n    //Authentication key\n    function setAuthKey($key) {\n        $this->authkey = $key;\n    }\n\n    function getAuthKey() {\n        return $this->authkey;\n    }\n\n    // logOut the user\n    function logOut() {\n\n        if ($bk = $this->getAuthBackend())\n            return $bk->signOut($this);\n\n        return false;\n    }\n\n    // Signal method to allow performing extra things when a user is logged\n    // into the sysem\n    function onLogin($bk) {}\n}\n\nrequire_once(INCLUDE_DIR.'class.ostsession.php');\nrequire_once(INCLUDE_DIR.'class.usersession.php');\n\ninterface AuthDirectorySearch {\n    /**\n     * Indicates if the backend can be used to search for user information.\n     * Lookup is performed to find user information based on a unique\n     * identifier.\n     */\n    function lookup($id);\n\n    /**\n     * Indicates if the backend supports searching for usernames. This is\n     * distinct from information lookup in that lookup is intended to lookup\n     * information based on a unique identifier\n     */\n    function search($query);\n}\n\n/**\n * Class: ClientCreateRequest\n *\n * Simple container to represent a remote authentication success for a\n * client which should be imported into the local database. The class will\n * provide access to the backend that authenticated the user, the username\n * that the user entered when logging in, and any other information about\n * the user that the backend was able to lookup. Generally, this extra\n * information would be the same information retrieved from calling the\n * AuthDirectorySearch::lookup() method.\n */\nclass ClientCreateRequest {\n\n    var $backend;\n    var $username;\n    var $info;\n\n    function __construct($backend, $username, $info=array()) {\n        $this->backend = $backend;\n        $this->username = $username;\n        $this->info = $info;\n    }\n\n    function getBackend() {\n        return $this->backend;\n    }\n    function setBackend($what) {\n        $this->backend = $what;\n    }\n\n    function getUsername() {\n        return $this->username;\n    }\n    function getInfo() {\n        return $this->info;\n    }\n\n    function attemptAutoRegister() {\n        global $cfg;\n\n        if (!$cfg || $cfg->isClientRegistrationMode(['disabled']))\n            return false;\n\n        // Attempt to automatically register\n        $this_form = UserForm::getUserForm()->getForm($this->getInfo());\n        $bk = $this->getBackend();\n        $defaults = array(\n            'timezone' => $cfg->getDefaultTimezone(),\n            'username' => $this->getUsername(),\n        );\n        if ($bk->supportsInteractiveAuthentication())\n            // User can only be authenticated against this backend\n            $defaults['backend'] = $bk::$id;\n        if ($this_form->isValid(function($f) { return !$f->isVisibleToUsers(); })\n                && ($U = User::fromVars($this_form->getClean()))\n                && ($acct = ClientAccount::createForUser($U, $defaults))\n                // Confirm and save the account\n                && $acct->confirm()\n                // Login, since `tickets.php` will not attempt SSO\n                && ($cl = new ClientSession(new EndUser($U)))\n                && ($bk->login($cl, $bk)))\n            return $cl;\n    }\n}\n\n/**\n * Authentication backend\n *\n * Authentication provides the basis of abstracting the link between the\n * login page with a username and password and the staff member,\n * administrator, or client using the system.\n *\n * The system works by allowing the AUTH_BACKENDS setting from\n * ost-config.php to determine the list of authentication backends or\n * providers and also specify the order they should be evaluated in.\n *\n * The authentication backend should define a authenticate() method which\n * receives a username and optional password. If the authentication\n * succeeds, an instance deriving from <User> should be returned.\n */\nabstract class AuthenticationBackend {\n    static protected $registry = array();\n    static $name;\n    static $id;\n\n\n    /* static */\n    static function register($class) {\n        if (is_string($class) && class_exists($class))\n            $class = new $class();\n\n        if (!is_object($class)\n                || !($class instanceof AuthenticationBackend))\n            return false;\n\n        return static::_register($class);\n    }\n\n    static function _register($class) {\n        // XXX: Raise error if $class::id is already in the registry\n        static::$registry[$class::$id] = $class;\n    }\n\n    static function allRegistered() {\n        return static::$registry;\n    }\n\n    static function getBackend($id) {\n\n        if ($id\n                && ($backends = static::allRegistered())\n                && isset($backends[$id]))\n            return $backends[$id];\n    }\n\n    static function getSearchDirectoryBackend($id) {\n\n        if ($id\n                && ($backends = static::getSearchDirectories())\n                && isset($backends[$id]))\n            return $backends[$id];\n    }\n\n    /*\n     * Allow the backend to do login audit depending on the result\n     * This is mainly used to track failed login attempts\n     */\n    static function authAudit($result, $credentials=null) {\n\n        if (!$result) return;\n\n        foreach (static::allRegistered() as $bk)\n            $bk->audit($result, $credentials);\n    }\n\n    static function process($username, $password=null, &$errors=array()) {\n\n        if (!$username)\n            return false;\n\n        $backends =  static::getAllowedBackends($username);\n        foreach (static::allRegistered() as $bk) {\n            if ($backends //Allowed backends\n                    && $bk->supportsInteractiveAuthentication()\n                    && !in_array($bk::$id, $backends))\n                // User cannot be authenticated against this backend\n                continue;\n\n            // All backends are queried here, even if they don't support\n            // authentication so that extensions like lockouts and audits\n            // can be supported.\n            try {\n                $result = $bk->authenticate($username, $password);\n                if ($result instanceof AuthenticatedUser\n                        && ($bk->login($result, $bk)))\n                    return $result;\n                elseif ($result instanceof ClientCreateRequest\n                        && $bk instanceof UserAuthenticationBackend)\n                    return $result;\n                elseif ($result instanceof AccessDenied) {\n                    break;\n                }\n            }\n            catch (AccessDenied $e) {\n                $result = $e;\n                break;\n            }\n        }\n\n        if (!$result)\n            $result = new AccessDenied(__('Access denied'));\n\n        if ($result && $result instanceof AccessDenied)\n            $errors['err'] = $result->reason;\n\n        $info = array('username' => $username, 'password' => $password);\n        Signal::send('auth.login.failed', null, $info);\n        self::authAudit($result, $info);\n    }\n\n    /*\n     *  Attempt to process non-interactive sign-on e.g  HTTP-Passthrough\n     *\n     * $forcedAuth - indicate if authentication is required.\n     *\n     */\n    function processSignOn(&$errors, $forcedAuth=true) {\n\n        foreach (static::allRegistered() as $bk) {\n            // All backends are queried here, even if they don't support\n            // authentication so that extensions like lockouts and audits\n            // can be supported.\n            try {\n                $result = $bk->signOn();\n                if ($result instanceof AuthenticatedUser) {\n                    //Perform further Object specific checks and the actual login\n                    if (!$bk->login($result, $bk))\n                        continue;\n\n                    return $result;\n                }\n                elseif ($result instanceof ClientCreateRequest\n                        && $bk instanceof UserAuthenticationBackend)\n                    return $result;\n                elseif ($result instanceof AccessDenied) {\n                    break;\n                }\n            }\n            catch (AccessDenied $e) {\n                $result = $e;\n                break;\n            }\n        }\n\n        if (!$result && $forcedAuth)\n            $result = new  AccessDenied(__('Unknown user'));\n\n        if ($result && $result instanceof AccessDenied)\n            $errors['err'] = $result->reason;\n\n        self::authAudit($result);\n    }\n\n    static function getSearchDirectories() {\n        $backends = array();\n        foreach (StaffAuthenticationBackend::allRegistered() as $bk)\n            if ($bk instanceof AuthDirectorySearch)\n                $backends[$bk::$id] = $bk;\n\n        foreach (UserAuthenticationBackend::allRegistered() as $bk)\n            if ($bk instanceof AuthDirectorySearch)\n                $backends[$bk::$id] = $bk;\n\n        return array_unique($backends);\n    }\n\n    static function searchUsers($query) {\n        $users = array();\n        foreach (static::getSearchDirectories() as $bk)\n            $users = array_merge($users, $bk->search($query));\n\n        return $users;\n    }\n\n    /**\n     * Fetches the friendly name of the backend\n     */\n    function getName() {\n        return static::$name;\n    }\n\n    /**\n     * Indicates if the backed supports authentication. Useful if the\n     * backend is used for logging or lockout only\n     */\n    function supportsInteractiveAuthentication() {\n        return true;\n    }\n\n    /**\n     * Indicates if the backend supports changing a user's password. This\n     * would be done in two fashions. Either the currently-logged in user\n     * want to change its own password or a user requests to have their\n     * password reset. This requires an administrative privilege which this\n     * backend might not possess, so it's defined in supportsPasswordReset()\n     */\n    function supportsPasswordChange() {\n        return false;\n    }\n\n\n    /**\n     * Get supported password policies for the backend.\n     *\n     */\n    function getPasswordPolicies($user=null) {\n        return PasswordPolicy::allActivePolicies();\n    }\n\n    /**\n     * Request the backend to update the password for a user. This method is\n     * the main entry for password updates so that password policies can be\n     * applied to the new password before passing the new password to the\n     * backend for updating.\n     *\n     * Throws:\n     * BadPassword \u2014 if password does not meet policy requirement\n     * PasswordUpdateFailed \u2014 if backend failed to update the password\n     */\n    function setPassword($user, $password, $current=false) {\n        foreach ($this->getPasswordPolicies($user) as $P)\n            $P->onSet($password, $current);\n\n        $rv = $this->syncPassword($user, $password);\n        if ($rv) {\n            $info = array('password' => $password, 'current' => $current);\n            Signal::send('auth.pwchange', $user, $info);\n        }\n        return $rv;\n    }\n\n    /*\n     * Request the backend to check the policies for a just logged\n     * in user.\n     * Throws: BadPassword & ExpiredPassword - for password related failures\n     */\n    function checkPolicies($user, $password) {\n        // Password policies\n        foreach ($this->getPasswordPolicies($user) as $P)\n            $P->onLogin($user, $password);\n    }\n\n    /**\n     * Request the backend to update the user's password with the password\n     * given. This method should only be used if the backend advertises\n     * supported password updates with the supportsPasswordChange() method.\n     *\n     * Returns:\n     * true if the password was successfully updated and false otherwise.\n     */\n    protected function syncPassword($user, $password) {\n        return false;\n    }\n\n    function supportsPasswordReset() {\n        return false;\n    }\n\n    function signOn() {\n        return null;\n    }\n\n    protected function validate($auth) {\n        return null;\n    }\n\n    protected function audit($result, $credentials) {\n        return null;\n    }\n\n    abstract function authenticate($username, $password);\n    abstract function login($user, $bk);\n    abstract static function getUser(); //Validates  authenticated users.\n    abstract function getAllowedBackends($userid);\n    abstract protected function getAuthKey($user);\n    abstract static function signOut($user);\n}\n\n/**\n * ExternalAuthenticationBackend\n *\n * External authentication backends are backends such as Google+ which\n * require a redirect to a remote site and a redirect back to osTicket in\n * order for a  user to be authenticated. For such backends, neither the\n * username and password fields nor single sign on alone can be used to\n * authenticate the user.\n */\ninterface ExternalAuthentication {\n\n    /**\n     * Requests the backend to render an external link box. When the user\n     * clicks this box, the backend will be prompted to redirect the user to\n     * the remote site for authentication there.\n     */\n    function renderExternalLink();\n\n    /**\n     * Function: getServiceName\n     *\n     * Called to get the service name displayed on login page.\n     */\n     function getServiceName();\n\n    /**\n     * Function: triggerAuth\n     *\n     * Called when a user clicks the button rendered in the\n     * ::renderExternalLink() function. This method should initiate the\n     * remote authentication mechanism.\n     */\n    function triggerAuth();\n}\n\nabstract class StaffAuthenticationBackend  extends AuthenticationBackend {\n\n    static private $_registry = array();\n\n    static function _register($class) {\n        static::$_registry[$class::$id] = $class;\n    }\n\n    static function allRegistered() {\n        return array_merge(self::$_registry, parent::allRegistered());\n    }\n\n    function isBackendAllowed($staff, $bk) {\n\n        if (!($backends=self::getAllowedBackends($staff->getId())))\n            return true;  //No restrictions\n\n        return in_array($bk::$id, array_map('strtolower', $backends));\n    }\n\n    function getPasswordPolicies($user=null) {\n        global $cfg;\n        $policies = PasswordPolicy::allActivePolicies();\n        if ($cfg && ($policy = $cfg->getStaffPasswordPolicy())) {\n            foreach ($policies as $P)\n                if ($policy == $P::$id)\n                    return array($P);\n        }\n\n        return $policies;\n    }\n\n    function getAllowedBackends($userid) {\n\n        $backends =array();\n        //XXX: Only one backend can be specified at the moment.\n        $sql = 'SELECT backend FROM '.STAFF_TABLE\n              .' WHERE backend IS NOT NULL ';\n        if (is_numeric($userid))\n            $sql.= ' AND staff_id='.db_input($userid);\n        else {\n            $sql.= ' AND (username='.db_input($userid) .' OR email='.db_input($userid).')';\n        }\n\n        if (($res=db_query($sql, false)) && db_num_rows($res))\n            $backends[] = db_result($res);\n\n        return array_filter($backends);\n    }\n\n    function login($staff, $bk) {\n        global $ost;\n\n        if (!$bk || !($staff instanceof Staff))\n            return false;\n\n        // Ensure staff is allowed for realz to be authenticated via the backend.\n        if (!static::isBackendAllowed($staff, $bk)\n            || !($authkey=$bk->getAuthKey($staff)))\n            return false;\n\n        // Regenerate session id and refresh (avoid session fixation)\n        $staff->regenerateSession();\n        //Log debug info.\n        $ost->logDebug(_S('Agent Login'),\n            sprintf(_S(\"%s logged in [%s], via %s\"), $staff->getUserName(),\n                $_SERVER['REMOTE_ADDR'], get_class($bk))); //Debug.\n\n        $agent = Staff::lookup($staff->getId());\n        $type = array('type' => 'login');\n        Signal::send('person.login', $agent, $type);\n\n        // Check if the agent has 2fa enabled\n        $auth2fa = null;\n        if (($_2fa = $staff->get2FABackend())\n                && ($token=$_2fa->send($staff))) {\n            $auth2fa = sprintf('%s:%s:%s',\n                    $_2fa->getId(), md5($token.$staff->getId()), time());\n        }\n\n        // Tag the authkey.\n        $authkey = $bk::$id.':'.$authkey;\n        // Now set session crap and lets roll baby!\n        $authsession = &$_SESSION['_auth']['staff'];\n        $authsession = array(); //clear.\n        $authsession['id'] = $staff->getId();\n        $authsession['key'] =  $authkey;\n        $authsession['2fa'] =  $auth2fa;\n        // Set session token\n        $staff->setSessionToken();\n        // Set Auth Key\n        $staff->setAuthKey($authkey);\n        Signal::send('auth.login.succeeded', $staff);\n\n        if ($bk->supportsInteractiveAuthentication())\n            $staff->cancelResetTokens();\n\n\n        // Update last-used language, login time, etc\n        $staff->onLogin($bk);\n\n        return true;\n    }\n\n    /* Base signOut\n     *\n     * Backend should extend the signout and perform any additional signout\n     * it requires.\n     */\n\n    static function signOut($staff) {\n        global $ost;\n\n        $_SESSION['_auth']['staff'] = array();\n        unset($_SESSION[':token']['staff']);\n        $ost->logDebug(_S('Agent logout'),\n                sprintf(_S(\"%s logged out [%s]\"),\n                    $staff->getUserName(),\n                    $_SERVER['REMOTE_ADDR'])); //Debug.\n\n        $agent = Staff::lookup($staff->getId());\n        $type = array('type' => 'logout');\n        Signal::send('person.logout', $agent, $type);\n        Signal::send('auth.logout', $staff);\n    }\n\n    // Called to get authenticated user (if any)\n    static function getUser() {\n\n        if (!isset($_SESSION['_auth']['staff'])\n                || !$_SESSION['_auth']['staff']['key'])\n            return null;\n\n        list($id, $auth) = explode(':', $_SESSION['_auth']['staff']['key']);\n\n        if (!($bk=static::getBackend($id)) //get the backend\n                || !($staff = $bk->validate($auth)) //Get AuthicatedUser\n                || !($staff instanceof Staff)\n                || !$staff->isActive()\n                || $staff->getId() != $_SESSION['_auth']['staff']['id'] // check ID\n        )\n            return null;\n\n        $staff->setAuthKey($_SESSION['_auth']['staff']['key']);\n\n        return $staff;\n    }\n\n    function authenticate($username, $password) {\n        return false;\n    }\n\n    // Generic authentication key for staff's backend is the username\n    protected function getAuthKey($staff) {\n\n        if(!($staff instanceof Staff))\n            return null;\n\n        return $staff->getUsername();\n    }\n\n    protected function validate($authkey) {\n\n        if (($staff = StaffSession::lookup($authkey))\n            && $staff->getId()\n            && $staff->isActive())\n            return $staff;\n    }\n}\n\nabstract class ExternalStaffAuthenticationBackend\n        extends StaffAuthenticationBackend\n        implements ExternalAuthentication {\n\n    static $fa_icon = \"signin\";\n    static $sign_in_image_url = false;\n    static $service_name = \"External\";\n\n    function getServiceName() {\n        return __(static::$service_name);\n    }\n\n    function renderExternalLink() {\n        $service = sprintf('%s %s',\n                __('Sign in with'),\n                $this->getServiceName());\n        ?>\n        <a class=\"external-sign-in\" title=\"<?php echo $service; ?>\"\n                href=\"login.php?do=ext&amp;bk=<?php echo urlencode(static::$id); ?>\">\n<?php if (static::$sign_in_image_url) { ?>\n        <img class=\"sign-in-image\" src=\"<?php echo static::$sign_in_image_url;\n            ?>\" alt=\"<?php echo $service; ?>\"/>\n<?php } else { ?>\n            <div class=\"external-auth-box\">\n            <span class=\"external-auth-icon\">\n                <i class=\"icon-<?php echo static::$fa_icon; ?> icon-large icon-fixed-with\"></i>\n            </span>\n            <span class=\"external-auth-name\">\n               <?php echo $service; ?>\n            </span>\n            </div>\n<?php } ?>\n        </a><?php\n    }\n\n    function triggerAuth() {\n        $_SESSION['ext:bk:class'] = get_class($this);\n    }\n}\nSignal::connect('api', function($dispatcher) {\n    $dispatcher->append(\n        url('^/auth/ext$', function() {\n            if ($class = $_SESSION['ext:bk:class']) {\n                $bk = StaffAuthenticationBackend::getBackend($class::$id)\n                    ?: UserAuthenticationBackend::getBackend($class::$id);\n                if ($bk instanceof ExternalAuthentication)\n                    $bk->triggerAuth();\n            }\n        })\n    );\n});\n\nabstract class UserAuthenticationBackend  extends AuthenticationBackend {\n\n    static private $_registry = array();\n\n    static function _register($class) {\n        static::$_registry[$class::$id] = $class;\n    }\n\n    static function allRegistered() {\n        return array_merge(self::$_registry, parent::allRegistered());\n    }\n\n\n    function getPasswordPolicies($user=null) {\n        global $cfg;\n        $policies = PasswordPolicy::allActivePolicies();\n        if ($cfg && ($policy = $cfg->getClientPasswordPolicy())) {\n            foreach ($policies as $P)\n                if ($policy == $P::$id)\n                    return array($P);\n        }\n\n        return $policies;\n    }\n\n    function getAllowedBackends($userid) {\n        $backends = array();\n        $sql = 'SELECT A1.backend FROM '.USER_ACCOUNT_TABLE\n              .' A1 INNER JOIN '.USER_EMAIL_TABLE.' A2 ON (A2.user_id = A1.user_id)'\n              .' WHERE backend IS NOT NULL '\n              .' AND (A1.username='.db_input($userid)\n                  .' OR A2.`address`='.db_input($userid).')';\n\n        if (!($res=db_query($sql, false)))\n            return $backends;\n\n        while (list($bk) = db_fetch_row($res))\n            $backends[] = $bk;\n\n        return array_filter($backends);\n    }\n\n    function login($user, $bk) {\n        global $ost;\n\n        if (!$user || !$bk\n                || !$bk::$id //Must have ID\n                || !($authkey = $bk->getAuthKey($user)))\n            return false;\n\n        $acct = $user->getAccount();\n\n        if ($acct) {\n            if (!$acct->isConfirmed())\n                throw new AccessDenied(__('Account confirmation required'));\n            elseif ($acct->isLocked())\n                throw new AccessDenied(__('Account is administratively locked'));\n        }\n\n        // Regenerate session id and refresh (avoid session fixation)\n        $user->regenerateSession();\n        // Tag the user and associated ticket in the SESSION\n        $this->setAuthKey($user, $bk, $authkey);\n        // Set Session Token\n        $user->setSessionToken();\n        //The backend used decides the format of the auth key.\n        // XXX: encrypt to hide the bk??\n        $user->setAuthKey($authkey);\n        //Log login info...\n        $msg=sprintf(_S('%1$s (%2$s) logged in [%3$s]'\n                /* Tokens are <username>, <id>, and <ip> */),\n                $user->getUserName(), $user->getId(), $_SERVER['REMOTE_ADDR']);\n        $ost->logDebug(_S('User login'), $msg);\n\n        $u = $user->getSessionUser()->getUser();\n        $type = array('type' => 'login');\n        Signal::send('person.login', $u, $type);\n\n        if ($bk->supportsInteractiveAuthentication() && ($acct=$user->getAccount()))\n            $acct->cancelResetTokens();\n\n        // Update last-used language, login time, etc\n        $user->onLogin($bk);\n\n        return true;\n    }\n\n    function setAuthKey($user, $bk, $key=false) {\n        $authkey = $key ?: $bk->getAuthKey($user);\n\n        //Tag the authkey.\n        $authkey = $bk::$id.':'.$authkey;\n\n        //Set the session goodies\n        $authsession = &$_SESSION['_auth']['user'];\n\n        $authsession = array(); //clear.\n        $authsession['id'] = $user->getId();\n        $authsession['key'] = $authkey;\n    }\n\n    function authenticate($username, $password) {\n        return false;\n    }\n\n    static function signOut($user) {\n        global $ost;\n\n        $_SESSION['_auth']['user'] = array();\n        unset($_SESSION[':token']['client']);\n        $ost->logDebug(_S('User logout'),\n            sprintf(_S(\"%s logged out [%s]\" /* Tokens are <username> and <ip> */),\n                $user->getUserName(), $_SERVER['REMOTE_ADDR']));\n\n        $u = $user->getSessionUser()->getUser();\n        $type = array('type' => 'logout');\n        Signal::send('person.logout', $u, $type);\n    }\n\n    protected function getAuthKey($user) {\n        return  $user->getId();\n    }\n\n    static function getUser() {\n\n        if (!isset($_SESSION['_auth']['user'])\n                || !$_SESSION['_auth']['user']['key'])\n            return null;\n\n        list($id, $auth) = explode(':', $_SESSION['_auth']['user']['key']);\n\n        if (!($bk=static::getBackend($id)) //get the backend\n                || !($user=$bk->validate($auth)) //Get AuthicatedUser\n                || !($user instanceof AuthenticatedUser) // Make sure it user\n                || $user->getId() != $_SESSION['_auth']['user']['id'] // check ID\n                )\n            return null;\n\n        if (($account=$user->getAccount()) && !$account->isActive())\n            return null;\n\n        $user->setAuthKey($_SESSION['_auth']['user']['key']);\n\n        return $user;\n    }\n\n    protected function validate($userid) {\n        if (!($user = User::lookup($userid)))\n            return false;\n        elseif (!($account=$user->getAccount()))\n            return false;\n        elseif (!$account->isActive())\n            return false;\n\n        return new ClientSession(new EndUser($user));\n    }\n}\n\nabstract class ExternalUserAuthenticationBackend\n        extends UserAuthenticationBackend\n        implements ExternalAuthentication {\n\n    static $fa_icon = \"signin\";\n    static $sign_in_image_url = false;\n    static $service_name = \"External\";\n\n    function getServiceName() {\n        return __(static::$service_name);\n    }\n\n    function renderExternalLink() {\n        $service = sprintf('%s %s',\n                __('Sign in with'),\n                $this->getServiceName());\n\n        ?>\n        <a class=\"external-sign-in\" title=\"<?php echo $service; ?>\"\n                href=\"login.php?do=ext&amp;bk=<?php echo urlencode(static::$id); ?>\">\n<?php if (static::$sign_in_image_url) { ?>\n        <img class=\"sign-in-image\" src=\"<?php echo static::$sign_in_image_url;\n            ?>\" alt=\"<?php $service; ?>\"/>\n<?php } else { ?>\n            <div class=\"external-auth-box\">\n            <span class=\"external-auth-icon\">\n                <i class=\"icon-<?php echo static::$fa_icon; ?> icon-large icon-fixed-with\"></i>\n            </span>\n            <span class=\"external-auth-name\">\n                <?php echo $service; ?>\n            </span>\n            </div>\n<?php } ?>\n        </a><?php\n    }\n\n    function triggerAuth() {\n        $_SESSION['ext:bk:class'] = get_class($this);\n    }\n}\n\n/**\n * This will be an exception in later versions of PHP\n */\nclass AccessDenied extends Exception {\n    function __construct($reason) {\n        $this->reason = $reason;\n        parent::__construct($reason);\n    }\n}\n\n/**\n * Simple authentication backend which will lock the login form after a\n * configurable number of attempts\n */\nabstract class AuthStrikeBackend extends AuthenticationBackend {\n\n    function authenticate($username, $password=null) {\n        return static::authTimeout();\n    }\n\n    function signOn() {\n        return static::authTimeout();\n    }\n\n    static function signOut($user) {\n        return false;\n    }\n\n\n    function login($user, $bk) {\n        return false;\n    }\n\n    static function getUser() {\n        return null;\n    }\n\n    function supportsInteractiveAuthentication() {\n        return false;\n    }\n\n    function getAllowedBackends($userid) {\n        return array();\n    }\n\n    function getAuthKey($user) {\n        return null;\n    }\n\n    //Provides audit facility for logins attempts\n    function audit($result, $credentials) {\n\n        //Count failed login attempts as a strike.\n        if ($result instanceof AccessDenied)\n            return static::authStrike($credentials);\n\n    }\n\n    abstract function authStrike($credentials);\n    abstract function authTimeout();\n}\n\n/*\n * Backend to monitor staff's failed login attempts\n */\nclass StaffAuthStrikeBackend extends  AuthStrikeBackend {\n\n    function authTimeout() {\n        global $ost;\n\n        $cfg = $ost->getConfig();\n\n        $authsession = &$_SESSION['_auth']['staff'];\n        if (!$authsession['laststrike'])\n            return;\n\n        //Veto login due to excessive login attempts.\n        if((time()-$authsession['laststrike'])<$cfg->getStaffLoginTimeout()) {\n            $authsession['laststrike'] = time(); //reset timer.\n            return new AccessDenied(__('Maximum failed login attempts reached'));\n        }\n\n        //Timeout is over.\n        //Reset the counter for next round of attempts after the timeout.\n        $authsession['laststrike']=null;\n        $authsession['strikes']=0;\n    }\n\n    function authstrike($credentials) {\n        global $ost;\n\n        $cfg = $ost->getConfig();\n\n        $authsession = &$_SESSION['_auth']['staff'];\n\n        $username = $credentials['username'];\n\n        $authsession['strikes']+=1;\n        if($authsession['strikes']>$cfg->getStaffMaxLogins()) {\n            $authsession['laststrike']=time();\n            $timeout = $cfg->getStaffLoginTimeout()/60;\n            $alert=_S('Excessive login attempts by an agent?').\"\\n\"\n                   ._S('Username').\": $username\\n\"\n                   ._S('IP').\": {$_SERVER['REMOTE_ADDR']}\\n\"\n                   ._S('Time').\": \".date('M j, Y, g:i a T').\"\\n\\n\"\n                   ._S('Attempts').\": {$authsession['strikes']}\\n\"\n                   ._S('Timeout').\": \".sprintf(_N('%d minute', '%d minutes', $timeout), $timeout).\"\\n\\n\";\n            $admin_alert = ($cfg->alertONLoginError() == 1) ? TRUE : FALSE;\n            $ost->logWarning(sprintf(_S('Excessive login attempts (%s)'),$username),\n                    $alert, $admin_alert);\n\n              if ($username) {\n                $agent = Staff::lookup($username);\n                $type = array('type' => 'login', 'msg' => sprintf('Excessive login attempts (%s)', $authsession['strikes']));\n                Signal::send('person.login', $agent, $type);\n              }\n\n            return new AccessDenied(__('Forgot your login info? Contact Admin.'));\n        //Log every other third failed login attempt as a warning.\n        } elseif($authsession['strikes']%3==0) {\n            $alert=_S('Username').\": {$username}\\n\"\n                    ._S('IP').\": {$_SERVER['REMOTE_ADDR']}\\n\"\n                    ._S('Time').\": \".date('M j, Y, g:i a T').\"\\n\\n\"\n                    ._S('Attempts').\": {$authsession['strikes']}\";\n            $ost->logWarning(sprintf(_S('Failed agent login attempt (%s)'),$username),\n                $alert, false);\n        }\n    }\n}\nStaffAuthenticationBackend::register('StaffAuthStrikeBackend');\n\n/*\n * Backend to monitor user's failed login attempts\n */\nclass UserAuthStrikeBackend extends  AuthStrikeBackend {\n\n    function authTimeout() {\n        global $ost;\n\n        $cfg = $ost->getConfig();\n\n        $authsession = &$_SESSION['_auth']['user'];\n        if (!$authsession['laststrike'])\n            return;\n\n        //Veto login due to excessive login attempts.\n        if ((time()-$authsession['laststrike']) < $cfg->getStaffLoginTimeout()) {\n            $authsession['laststrike'] = time(); //reset timer.\n            return new AccessDenied(__(\"You've reached maximum failed login attempts allowed.\"));\n        }\n\n        //Timeout is over.\n        //Reset the counter for next round of attempts after the timeout.\n        $authsession['laststrike']=null;\n        $authsession['strikes']=0;\n    }\n\n    function authstrike($credentials) {\n        global $ost;\n\n        $cfg = $ost->getConfig();\n\n        $authsession = &$_SESSION['_auth']['user'];\n\n        $username = $credentials['username'];\n        $password = $credentials['password'];\n\n        $authsession['strikes']+=1;\n        if($authsession['strikes']>$cfg->getClientMaxLogins()) {\n            $authsession['laststrike'] = time();\n            $alert=_S('Excessive login attempts by a user.').\"\\n\".\n                    _S('Username').\": {$username}\\n\".\n                    _S('IP').\": {$_SERVER['REMOTE_ADDR']}\\n\".\n                    _S('Time').\": \".date('M j, Y, g:i a T').\"\\n\\n\".\n                    _S('Attempts').\": {$authsession['strikes']}\";\n            $admin_alert = ($cfg->alertONLoginError() == 1 ? TRUE : FALSE);\n            $ost->logError(_S('Excessive login attempts (user)'), $alert, $admin_alert);\n\n            if ($username) {\n              $account = UserAccount::lookupByUsername($username);\n              $id = UserEmailModel::getIdByEmail($username);\n              if ($account)\n                  $user = User::lookup($account->user_id);\n              elseif ($id)\n                $user = User::lookup($id);\n\n              if ($user) {\n                $type = array('type' => 'login', 'msg' => sprintf('Excessive login attempts (%s)', $authsession['strikes']));\n                Signal::send('person.login', $user, $type);\n              }\n            }\n\n            return new AccessDenied(__('Access denied'));\n        } elseif($authsession['strikes']%3==0) { //Log every third failed login attempt as a warning.\n            $alert=_S('Username').\": {$username}\\n\".\n                    _S('IP').\": {$_SERVER['REMOTE_ADDR']}\\n\".\n                    _S('Time').\": \".date('M j, Y, g:i a T').\"\\n\\n\".\n                    _S('Attempts').\": {$authsession['strikes']}\";\n            $ost->logWarning(_S('Failed login attempt (user)'), $alert, false);\n        }\n\n    }\n}\nUserAuthenticationBackend::register('UserAuthStrikeBackend');\n\n\nclass osTicketStaffAuthentication extends StaffAuthenticationBackend {\n    static $name = \"Local Authentication\";\n    static $id = \"local\";\n\n    function authenticate($username, $password) {\n        if (($user = StaffSession::lookup($username)) && $user->getId() &&\n                $user->check_passwd($password)) {\n            try {\n                $this->checkPolicies($user, $password);\n            } catch (BadPassword | ExpiredPassword $ex) {\n                $user->change_passwd = 1;\n            }\n            return $user;\n        }\n    }\n\n    function supportsPasswordChange() {\n        return true;\n    }\n\n    function syncPassword($staff, $password) {\n        $staff->passwd = Passwd::hash($password);\n    }\n\n    static function checkPassword($new, $current) {\n        PasswordPolicy::checkPassword($new, $current, new self());\n    }\n\n}\nStaffAuthenticationBackend::register('osTicketStaffAuthentication');\n\nclass PasswordResetTokenBackend extends StaffAuthenticationBackend {\n    static $id = \"pwreset.staff\";\n\n    function supportsInteractiveAuthentication() {\n        return false;\n    }\n\n    function signOn($errors=array()) {\n        global $ost;\n\n        if (!isset($_POST['userid']) || !isset($_POST['token']))\n            return false;\n        elseif (!($_config = new Config('pwreset')))\n            return false;\n\n        $staff = StaffSession::lookup($_POST['userid']);\n        if (!$staff || !$staff->getId())\n            $errors['msg'] = __('Invalid user-id given');\n        elseif (!($id = $_config->get($_POST['token']))\n                || $id != $staff->getId())\n            $errors['msg'] = __('Invalid reset token');\n        elseif (!($ts = $_config->lastModified($_POST['token']))\n                && ($ost->getConfig()->getPwResetWindow() < (time() - strtotime($ts))))\n            $errors['msg'] = __('Invalid reset token');\n        elseif (!$staff->forcePasswdRest())\n            $errors['msg'] = __('Unable to reset password');\n        else\n            return $staff;\n    }\n\n    function login($staff, $bk) {\n        $_SESSION['_staff']['reset-token'] = $_POST['token'];\n        Signal::send('auth.pwreset.login', $staff);\n        return parent::login($staff, $bk);\n    }\n}\nStaffAuthenticationBackend::register('PasswordResetTokenBackend');\n\n/*\n * AuthToken Authentication Backend\n *\n * Provides auto-login facility for end users with valid link\n *\n * Ticket used to loggin is tracked durring the session this is\n * important in the future when auto-logins will be\n * limited to single ticket view.\n */\nclass AuthTokenAuthentication extends UserAuthenticationBackend {\n    static $name = \"Auth Token Authentication\";\n    static $id = \"authtoken\";\n\n\n    function signOn() {\n        global $cfg;\n\n\n        if (!$cfg || !$cfg->isAuthTokenEnabled())\n            return null;\n\n        $user = null;\n        if ($_GET['auth']) {\n            if (($u = TicketUser::lookupByToken($_GET['auth'])))\n                $user = new ClientSession($u);\n        }\n        // Support old ticket based tokens.\n        elseif ($_GET['t'] && $_GET['e'] && $_GET['a']) {\n            if (($ticket = Ticket::lookupByNumber($_GET['t'], $_GET['e']))\n                    // Using old ticket auth code algo - hardcoded here because it\n                    // will be removed in ticket class in the upcoming rewrite\n                    && strcasecmp((string) $_GET['a'], md5($ticket->getId()\n                            .  strtolower($_GET['e']) . SECRET_SALT)) === 0\n                    && ($owner = $ticket->getOwner()))\n                $user = new ClientSession($owner);\n        }\n\n        return $user;\n    }\n\n    function supportsInteractiveAuthentication() {\n        return false;\n    }\n\n    protected function getAuthKey($user) {\n\n        if (!$user)\n            return null;\n\n        //Generate authkey based the type of ticket user\n        // It's required to validate users going forward.\n        $authkey = sprintf('%s%dt%dh%s',  //XXX: Placeholder\n                    ($user->isOwner() ? 'o':'c'),\n                    $user->getId(),\n                    $user->getTicketId(),\n                    md5($user->getId().$this->id));\n\n        return $authkey;\n    }\n\n    protected function validate($authkey) {\n\n        $regex = '/^(?P<type>\\w{1})(?P<id>\\d+)t(?P<tid>\\d+)h(?P<hash>.*)$/i';\n        $matches = array();\n        if (!preg_match($regex, $authkey, $matches))\n            return false;\n\n        $user = null;\n        switch ($matches['type']) {\n            case 'c': //Collaborator\n                $criteria = array(\n                    'user_id' => $matches['id'],\n                    'thread__ticket__ticket_id' => $matches['tid']\n                );\n                if (($c = Collaborator::lookup($criteria))\n                        && ($c->getTicketId() == $matches['tid']))\n                    $user = new ClientSession($c);\n                break;\n            case 'o': //Ticket owner\n                if (($ticket = Ticket::lookup($matches['tid']))\n                        && ($o = $ticket->getOwner())\n                        && ($o->getId() == $matches['id']))\n                    $user = new ClientSession($o);\n                break;\n        }\n\n        //Make sure the authkey matches.\n        if (!$user || strcmp($this->getAuthKey($user), $authkey))\n            return null;\n\n        $user->flagGuest();\n\n        return $user;\n    }\n\n}\n\nUserAuthenticationBackend::register('AuthTokenAuthentication');\n\n//Simple ticket lookup backend used to recover ticket access link.\n// We're using authentication backend so we can guard aganist brute force\n// attempts (which doesn't buy much since the link is emailed)\nclass AccessLinkAuthentication extends UserAuthenticationBackend {\n    static $name = \"Ticket Access Link Authentication\";\n    static $id = \"authlink\";\n\n    function authenticate($email, $number) {\n\n        if (!($ticket = Ticket::lookupByNumber($number))\n                || !($user=User::lookup(array('emails__address' => $email))))\n            return false;\n\n        if (!($user = $this->_getTicketUser($ticket, $user)))\n            return false;\n\n        $_SESSION['_auth']['user-ticket'] = $number;\n        return new ClientSession($user);\n    }\n\n    function _getTicketUser($ticket, $user) {\n        // Ticket owner?\n        if ($ticket->getUserId() == $user->getId())\n            $user = $ticket->getOwner();\n        // Collaborator?\n        elseif (!($user = Collaborator::lookup(array(\n                'user_id' => $user->getId(),\n                'thread__ticket__ticket_id' => $ticket->getId())\n        )))\n            return false; //Bro, we don't know you!\n\n        return $user;\n    }\n\n    // We are not actually logging in the user....\n    function login($user, $bk) {\n        global $cfg;\n\n        if (!$cfg->isClientEmailVerificationRequired()) {\n            return parent::login($user, $bk);\n        }\n        return true;\n    }\n\n    protected function validate($userid) {\n        $number = $_SESSION['_auth']['user-ticket'];\n\n        if (!($ticket = Ticket::lookupByNumber($number)))\n            return false;\n\n        if (!($user = User::lookup($userid)))\n            return false;\n\n        if (!($user = $this->_getTicketUser($ticket, $user)))\n            return false;\n\n        $user = new ClientSession($user);\n        $user->flagGuest();\n        return $user;\n    }\n\n    function supportsInteractiveAuthentication() {\n        return false;\n    }\n}\nUserAuthenticationBackend::register('AccessLinkAuthentication');\n\nclass osTicketClientAuthentication extends UserAuthenticationBackend {\n    static $name = \"Local Client Authentication\";\n    static $id = \"client\";\n\n    function authenticate($username, $password) {\n        if (!($acct = ClientAccount::lookupByUsername($username)))\n            return;\n\n        if (($client = new ClientSession(new EndUser($acct->getUser())))\n                && !$client->getId())\n            return false;\n        elseif (!$acct->check_passwd($password))\n            return false;\n        else\n            return $client;\n    }\n\n    static function checkPassword($new, $current) {\n        PasswordPolicy::checkPassword($new, $current, new self());\n    }\n}\nUserAuthenticationBackend::register('osTicketClientAuthentication');\n\nclass ClientPasswordResetTokenBackend extends UserAuthenticationBackend {\n    static $id = \"pwreset.client\";\n\n    function supportsInteractiveAuthentication() {\n        return false;\n    }\n\n    function signOn($errors=array()) {\n        global $ost;\n\n        if (!isset($_POST['userid']) || !isset($_POST['token']))\n            return false;\n        elseif (!($_config = new Config('pwreset')))\n            return false;\n        elseif (!($acct = ClientAccount::lookupByUsername($_POST['userid']))\n                || !$acct->getId()\n                || !($client = new ClientSession(new EndUser($acct->getUser()))))\n            $errors['msg'] = __('Invalid user-id given');\n        elseif (!($id = $_config->get($_POST['token']))\n                || $id != 'c'.$client->getId())\n            $errors['msg'] = __('Invalid reset token');\n        elseif (!($ts = $_config->lastModified($_POST['token']))\n                && ($ost->getConfig()->getPwResetWindow() < (time() - strtotime($ts))))\n            $errors['msg'] = __('Invalid reset token');\n        elseif (!$acct->forcePasswdReset())\n            $errors['msg'] = __('Unable to reset password');\n        else\n            return $client;\n    }\n\n    function login($client, $bk) {\n        $_SESSION['_client']['reset-token'] = $_POST['token'];\n        Signal::send('auth.pwreset.login', $client);\n        return parent::login($client, $bk);\n    }\n}\nUserAuthenticationBackend::register('ClientPasswordResetTokenBackend');\n\nclass ClientAcctConfirmationTokenBackend extends UserAuthenticationBackend {\n    static $id = \"confirm.client\";\n\n    function supportsInteractiveAuthentication() {\n        return false;\n    }\n\n    function signOn($errors=array()) {\n        global $ost;\n\n        if (!isset($_GET['token']))\n            return false;\n        elseif (!($_config = new Config('pwreset')))\n            return false;\n        elseif (!($id = $_config->get($_GET['token'])))\n            return false;\n        elseif (!($acct = ClientAccount::lookup(array('user_id'=>substr($id,1))))\n                || !$acct->getId()\n                || $id != 'c'.$acct->getUserId()\n                || !($client = new ClientSession(new EndUser($acct->getUser()))))\n            return false;\n        else\n            return $client;\n    }\n}\nUserAuthenticationBackend::register('ClientAcctConfirmationTokenBackend');\n\n// ----- Password Policy --------------------------------------\n\nclass BadPassword extends Exception {}\nclass ExpiredPassword extends Exception {}\nclass PasswordUpdateFailed extends Exception {}\n\nabstract class PasswordPolicy {\n    static protected $registry = array();\n\n    static $id;\n    static $name;\n\n    /**\n     * Check a password and throw BadPassword with a meaningful message if\n     * the password cannot be accepted.\n     */\n    abstract function onset($new, $current);\n\n    /*\n     * Called on login to enforce policies & check for expired passwords\n     */\n    abstract function onLogin($user, $password);\n\n    /*\n     * get friendly name of the policy\n     */\n    function getName() {\n        return static::$name;\n    }\n\n    /*\n     * Check a password aganist all available policies \n     */\n    static function checkPassword($new, $current, $bk=null) {\n        if ($bk && is_a($bk, 'AuthenticationBackend'))\n            $policies = $bk->getPasswordPolicies();\n        else\n            $policies = self::allActivePolicies();\n\n        foreach ($policies as $P)\n            $P->onSet($new, $current);\n    }\n\n    static function allActivePolicies() {\n        $policies = array();\n        foreach (array_reverse(static::$registry) as $P) {\n            if (is_string($P) && class_exists($P))\n                $P = new $P();\n            if ($P instanceof PasswordPolicy)\n                $policies[] = $P;\n        }\n        return $policies;\n    }\n\n    static function register($policy) {\n        static::$registry[] = $policy;\n    }\n\n    static function cleanSessions($model, $user=null) {\n        $criteria = array();\n\n        switch (true) {\n            case ($model instanceof Staff):\n                $criteria['user_id'] = $model->getId();\n\n                if ($user && ($model->getId() == $user->getId()))\n                    array_push($criteria,\n                        Q::not(array('session_id' => $user->session->session_id)));\n                break;\n            case ($model instanceof User):\n                $regexp = '_auth\\|.*\"user\";[a-z]+:[0-9]+:\\{[a-z]+:[0-9]+:\"id\";[a-z]+:'.$model->getId();\n                $criteria['user_id'] = 0;\n                $criteria['session_data__regex'] = $regexp;\n\n                if ($user)\n                    array_push($criteria,\n                        Q::not(array('session_id' => $user->session->session_id)));\n                break;\n            default:\n                return false;\n        }\n\n        return SessionData::objects()->filter($criteria)->delete();\n    }\n}\nSignal::connect('auth.clean', array('PasswordPolicy', 'cleanSessions'));\n\n/*\n * Basic default password policy that ships with osTicket.\n * \n */\nclass osTicketPasswordPolicy\nextends PasswordPolicy {\n    static $id = \"basic\";\n    static $name = /* @trans */ \"Default Basic Policy\";\n\n    function onLogin($user, $password) {\n        global $cfg;\n\n        // Check for possible password expiration\n        // Check is only here for legacy reasons - password management\n        // policies are now done via plugins.\n        if ($cfg && $user\n                && ($period=$cfg->getPasswdResetPeriod())\n                && ($time=$user->getPasswdResetTimestamp())\n                && $time < time()-($period*2629800))\n            throw new ExpiredPassword(__('Expired password'));\n    }\n\n    function onSet($passwd, $current) {\n        if (strlen($passwd) < 6) {\n            throw new BadPassword(\n                __('Password must be at least 6 characters'));\n        }\n        // XXX: Changing case is technicall changing the password\n        if (0 === strcasecmp($passwd, $current)) {\n            throw new BadPassword(\n                __('New password MUST be different from the current password!'));\n        }\n    }\n}\nPasswordPolicy::register('osTicketPasswordPolicy');\n?>\n", "<?php\n/*********************************************************************\n    class.usersession.php\n\n    User (client and staff) sessions handle.\n\n    Peter Rotich <peter@osticket.com>\n    Copyright (c)  2006-2013 osTicket\n    http://www.osticket.com\n\n    Released under the GNU General Public License WITHOUT ANY WARRANTY.\n    See LICENSE.TXT for details.\n\n    vim: expandtab sw=4 ts=4 sts=4:\n**********************************************************************/\n\ninclude_once(INCLUDE_DIR.'class.client.php');\ninclude_once(INCLUDE_DIR.'class.staff.php');\n\nclass UserSession {\n   var $session_id = '';\n   var $userID = 0;\n   var $browser = '';\n   var $ip = '';\n   var $validated = false;\n\n   function __construct($userid) {\n      $this->browser = (!empty($_SERVER['HTTP_USER_AGENT'])) ? $_SERVER['HTTP_USER_AGENT'] : $_ENV['HTTP_USER_AGENT'];\n      $this->ip = (!empty($_SERVER['REMOTE_ADDR'])) ? $_SERVER['REMOTE_ADDR'] : getenv('REMOTE_ADDR');\n      $this->session_id = session_id();\n      $this->userID = $userid;\n   }\n\n   function isStaff() {\n       return false;\n   }\n\n   function isClient() {\n       return false;\n   }\n\n   function getSessionId() {\n       return $this->session_id;\n   }\n\n   function getIP() {\n        return  $this->ip;\n   }\n\n   function getBrowser() {\n       return $this->browser;\n   }\n\n   function sessionToken(){\n      $time  = time();\n      $hash  = md5($time.SESSION_SECRET.$this->userID);\n      $token = \"$hash:$time:\".MD5($this->ip);\n      return $token;\n   }\n\n   function getLastUpdate($htoken) {\n       if (!$htoken)\n           return 0;\n\n       @list($hash, $expire, $ip) = explode(\":\", $htoken);\n       return $expire;\n   }\n\n   function isvalidSession($htoken,$maxidletime=0,$checkip=false){\n        global $cfgi;\n\n        // Compare session ids\n        if (strcmp($this->getSessionId(), session_id()))\n            return false;\n\n        // Is the session invalidated?\n        if (isset($_SESSION['KAPUT']) &&  $_SESSION['KAPUT'] < time())\n            return (session_destroy() && false);\n\n        $token = rawurldecode($htoken);\n        // Check if we got what we expected....\n        if ($token && !strstr($token,\":\"))\n            return false;\n\n        // Get the goodies\n        list($hash, $expire, $ip) = explode(\":\",$token);\n\n        // Make sure the session hash is valid\n        if ((md5($expire . SESSION_SECRET . $this->userID) != $hash))\n            return false;\n\n        // is it expired??\n        if ($maxidletime && ((time()-$expire)>$maxidletime))\n            return false;\n\n        #Make sure IP is still same ( proxy access??????)\n        if ($checkip && strcmp($ip, MD5($this->ip)))\n            return false;\n\n        $this->validated = true;\n\n        return true;\n   }\n\n   function regenerateSession($destroy=false) {\n       // Delayed kaput time for current session\n       $_SESSION['KAPUT'] = time() + 60;\n       // Save the session id as old\n       $old = session_id();\n       // Regenerate the session without destroying data\n       session_regenerate_id(false);\n       // Get new session id and close\n       $new = session_id();\n       session_write_close();\n       // Start new session\n       session_id($new);\n       session_start();\n       $this->session_id  = $new;\n       // Make sure new session is not set to KAPUT\n       unset($_SESSION['KAPUT']);\n       // Destroy ?\n       if ($destroy) {\n           // Destrory old session\n           $this->destroySession($old);\n           // Restore new session\n           session_id($new);\n           session_start();\n       }\n       return true;\n   }\n\n   function destroySession($id) {\n       // Close current session\n       session_write_close();\n       // Start target session\n       session_id($id);\n       session_start();\n       // Destroy session\n       session_destroy();\n       session_write_close();\n       return true;\n   }\n\n   function isValid() {\n        return  ($this->validated);\n   }\n\n}\n\n\ntrait UserSessionTrait {\n    // Session Object\n    var $session;\n    // Session Token\n    var $token;\n    // Maximum idle time before session is considered invalid\n    var $maxidletime = 0;\n    // Indicates if session is bound to the IP address\n    var $checkip = false;\n    // User class\n    var $class = '';\n\n    function refreshSession($force=false) {\n        $time = $this->session->getLastUpdate($this->token);\n        // Deadband session token updates to once / 30-seconds\n        if (!$force && time() - $time < 30)\n            return;\n\n        $this->token = $this->getSessionToken();\n        osTicketSession::renewCookie($time, $this->maxidletime);\n    }\n\n    function regenerateSession($destroy=false) {\n        $this->session->regenerateSession($destroy);\n        // Set cookie for the new session id.\n        $this->refreshSession(true);\n    }\n\n    function getSession() {\n        return $this->session;\n    }\n\n    function getSessionToken() {\n        return $this->session->sessionToken();\n    }\n\n    function setSessionToken($token=null) {\n        // Assign memory to token variable\n        $this->token = &$_SESSION[':token'][$this->class];\n        // Set token\n        $this->token = $token ?: $this->getSessionToken();\n    }\n\n    function getIP() {\n        return $this->session->getIP();\n    }\n\n    function isValidSession() {\n        return ($this->getId()\n                && $this->session->isvalidSession($this->token,\n                    $this->maxidletime, $this->checkip));\n    }\n\n    abstract function isValid();\n}\n\nclass ClientSession extends EndUser {\n    use UserSessionTrait;\n\n    function __construct($user) {\n        global $cfg;\n        parent::__construct($user);\n        $this->class ='client';\n        // XXX: Change the key to user-id\n        $this->session = new UserSession($user->getId());\n        $this->setSessionToken();\n        $this->maxidletime = $cfg->getClientTimeout();\n    }\n\n    function getSessionUser() {\n        return $this->user;\n    }\n\n    function isValid() {\n        return $this->isValidSession();\n    }\n}\n\nclass StaffSession extends Staff {\n    use UserSessionTrait;\n\n    static function lookup($var) {\n        global $cfg;\n        if (($staff = parent::lookup($var))) {\n            $staff->class = 'staff';\n            $staff->session = new UserSession($staff->getId());\n            $staff->setSessionToken();\n            $staff->maxidletime = $cfg->getStaffTimeout();\n            $staff->checkip = $cfg->enableStaffIPBinding();\n        }\n        return $staff;\n    }\n\n    function clear2FA() {\n        unset($_SESSION['_auth']['staff']['2fa']);\n        $_SESSION['_auth']['staff']['2fa'] = null;\n        return true;\n    }\n\n    // If 2fa is set then it means it's pending\n    function is2FAPending() {\n        return isset($_SESSION['_auth']['staff']['2fa']);\n    }\n\n    function isValid() {\n        return (!$this->is2FAPending() && $this->isValidSession());\n    }\n}\n?>\n", "<?php\n/*********************************************************************\n    open.php\n\n    New tickets handle.\n\n    Peter Rotich <peter@osticket.com>\n    Copyright (c)  2006-2013 osTicket\n    http://www.osticket.com\n\n    Released under the GNU General Public License WITHOUT ANY WARRANTY.\n    See LICENSE.TXT for details.\n\n    vim: expandtab sw=4 ts=4 sts=4:\n**********************************************************************/\nrequire('client.inc.php');\ndefine('SOURCE','Web'); //Ticket source.\n$ticket = null;\n$errors=array();\nif ($_POST) {\n    $vars = $_POST;\n    $vars['deptId']=$vars['emailId']=0; //Just Making sure we don't accept crap...only topicId is expected.\n    if ($thisclient) {\n        $vars['uid']=$thisclient->getId();\n    } elseif($cfg->isCaptchaEnabled()) {\n        if(!$_POST['captcha'])\n            $errors['captcha']=__('Enter text shown on the image');\n        elseif(strcmp($_SESSION['captcha'], md5(strtoupper($_POST['captcha']))))\n            $errors['captcha']=sprintf('%s - %s', __('Invalid'), __('Please try again!'));\n    }\n\n    $tform = TicketForm::objects()->one()->getForm($vars);\n    $messageField = $tform->getField('message');\n    $attachments = $messageField->getWidget()->getAttachments();\n    if (!$errors) {\n        $vars['message'] = $messageField->getClean();\n        if ($messageField->isAttachmentsEnabled())\n            $vars['files'] = $attachments->getFiles();\n    }\n\n    // Drop the draft.. If there are validation errors, the content\n    // submitted will be displayed back to the user\n    Draft::deleteForNamespace('ticket.client.'.substr(session_id(), -12));\n    //Ticket::create...checks for errors..\n    if(($ticket=Ticket::create($vars, $errors, SOURCE))){\n        $msg=__('Support ticket request created');\n        // Drop session-backed form data\n        unset($_SESSION[':form-data']);\n        //Logged in...simply view the newly created ticket.\n        if ($thisclient && $thisclient->isValid()) {\n            // Regenerate session id\n            $thisclient->regenerateSession();\n            @header('Location: tickets.php?id='.$ticket->getId());\n        } else\n            $ost->getCSRF()->rotate();\n    }else{\n        $errors['err'] = $errors['err'] ?: sprintf('%s %s',\n            __('Unable to create a ticket.'),\n            __('Correct any errors below and try again.'));\n    }\n}\n\n//page\n$nav->setActiveNav('new');\nif ($cfg->isClientLoginRequired()) {\n    if ($cfg->getClientRegistrationMode() == 'disabled') {\n        Http::redirect('view.php');\n    }\n    elseif (!$thisclient) {\n        require_once 'secure.inc.php';\n    }\n    elseif ($thisclient->isGuest()) {\n        require_once 'login.php';\n        exit();\n    }\n}\n\nrequire(CLIENTINC_DIR.'header.inc.php');\nif ($ticket\n    && (\n        (($topic = $ticket->getTopic()) && ($page = $topic->getPage()))\n        || ($page = $cfg->getThankYouPage())\n    )\n) {\n    // Thank the user and promise speedy resolution!\n    echo Format::viewableImages(\n        $ticket->replaceVars(\n            $page->getLocalBody()\n        ),\n        ['type' => 'P']\n    );\n}\nelse {\n    require(CLIENTINC_DIR.'open.inc.php');\n}\nrequire(CLIENTINC_DIR.'footer.inc.php');\n?>\n"], "filenames": ["include/class.auth.php", "include/class.usersession.php", "open.php"], "buggy_code_start_loc": [540, 20, 50], "buggy_code_end_loc": [767, 232, 53], "fixing_code_start_loc": [541, 19, 50], "fixing_code_end_loc": [769, 259, 53], "type": "CWE-384", "message": "Session Fixation vulnerability in in function login in class.auth.php in osTicket through 1.16.2.", "other": {"cve": {"id": "CVE-2022-31888", "sourceIdentifier": "cve@mitre.org", "published": "2023-04-05T22:15:07.180", "lastModified": "2023-04-17T17:17:35.633", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Session Fixation vulnerability in in function login in class.auth.php in osTicket through 1.16.2."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-384"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:enhancesoft:osticket:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.16.2", "matchCriteriaId": "7CDC0050-A305-40B5-A426-ADB30D6DC5FB"}]}]}], "references": [{"url": "https://checkmarx.com/blog/securing-open-source-solutions-a-study-of-osticket-vulnerabilities/", "source": "cve@mitre.org", "tags": ["Exploit"]}, {"url": "https://github.com/osTicket/osTicket/commit/85a76f403a3a116176d0798f39a4c430181d8364", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/osTicket/osTicket/releases/tag/v1.16.3", "source": "cve@mitre.org", "tags": ["Release Notes"]}]}, "github_commit_url": "https://github.com/osTicket/osTicket/commit/85a76f403a3a116176d0798f39a4c430181d8364"}}