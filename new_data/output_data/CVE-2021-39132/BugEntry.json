{"buggy_code": ["/*\n * Copyright 2016 SimplifyOps, Inc. (http://simplifyops.com)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n* ScriptFileProviderLoader.java\n* \n* User: Greg Schueler <a href=\"mailto:greg@dtosolutions.com\">greg@dtosolutions.com</a>\n* Created: 4/13/11 10:07 AM\n* \n*/\npackage com.dtolabs.rundeck.core.plugins;\n\nimport com.dtolabs.rundeck.core.common.FrameworkSupportService;\nimport com.dtolabs.rundeck.core.execution.script.ScriptfileUtils;\nimport com.dtolabs.rundeck.core.execution.service.ProviderLoaderException;\nimport com.dtolabs.rundeck.core.plugins.metadata.ProviderDef;\nimport com.dtolabs.rundeck.core.plugins.metadata.PluginMeta;\nimport com.dtolabs.rundeck.core.utils.FileUtils;\nimport com.dtolabs.rundeck.core.utils.ZipUtil;\nimport com.dtolabs.rundeck.core.utils.cache.FileCache;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.yaml.snakeyaml.Yaml;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.*;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipInputStream;\n\nimport static com.dtolabs.rundeck.core.plugins.JarPluginProviderLoader.RESOURCES_DIR_DEFAULT;\n\n/**\n * ScriptPluginProviderLoader can load a provider instance for a service from a script plugin zip file.\n *\n * Services that want to use this loader need to implement {@link ScriptPluginProviderLoadable}\n *\n * @author Greg Schueler <a href=\"mailto:greg@dtosolutions.com\">greg@dtosolutions.com</a>\n */\npublic class ScriptPluginProviderLoader implements ProviderLoader, FileCache.Expireable, PluginResourceLoader, PluginMetadata {\n\n    private static final Logger         log                               = LoggerFactory.getLogger(ScriptPluginProviderLoader.class.getName());\n    public static final  String         VERSION_1_0                       = \"1.0\";\n    public static final  String         VERSION_1_1                       = \"1.1\";\n    public static final  String         VERSION_1_2                       = \"1.2\";\n    public static final  VersionCompare SUPPORTS_RESOURCES_PLUGIN_VERSION = VersionCompare.forString(VERSION_1_2);\n    public static final  String         VERSION_2_0                       = \"2.0\";\n    public static final  List<String>   SUPPORTED_PLUGIN_VERSIONS;\n    static {\n        SUPPORTED_PLUGIN_VERSIONS = Collections.unmodifiableList(Arrays.asList(\n                VERSION_1_0,\n                VERSION_1_1,\n                VERSION_1_2,\n                VERSION_2_0\n        ));\n    }\n    private final File file;\n    final File cachedir;\n    /**\n     * Dir of expanded zip contents\n     */\n    private File fileExpandedDir;\n    /**\n     * Metadata from the plugin.yaml file\n     */\n    private PluginMeta metadata;\n    /**\n     * Metadata from the plugin.yaml file\n     */\n    private PluginResourceLoader resourceLoader;\n    /**\n     * cache of ident to scriptplugin def mapping\n     */\n    private Map<ProviderIdent, ScriptPluginProvider> pluginProviderDefs =\n        new HashMap<ProviderIdent, ScriptPluginProvider>();\n    private List<String> pluginResourcesList;\n\n    public ScriptPluginProviderLoader(final File file, final File cachedir) {\n        this.file = file;\n        this.cachedir = cachedir;\n    }\n\n    @Override\n    public boolean canLoadForService(final FrameworkSupportService service) {\n        return service instanceof ScriptPluginProviderLoadable;\n    }\n\n    private PluginResourceLoader getResourceLoader() throws PluginException {\n        if (null == resourceLoader) {\n            synchronized (this) {\n                if (null == resourceLoader) {\n                    try {\n                        ZipResourceLoader loader = new ZipResourceLoader(\n                                new File(getFileCacheDir(), \"resources\"),\n                                file,\n                                getPluginResourcesList(),\n                                getFileBasename() + \"/\" + getResourcesBasePath()\n                        );\n                        loader.extractResources();\n                        this.resourceLoader = loader;\n                    } catch (IOException e) {\n                        throw new PluginException(\"Unable to expand plugin libs: \" + e.getMessage(), e);\n                    }\n                }\n            }\n        }\n        return resourceLoader;\n    }\n\n    @Override\n    public List<String> listResources() throws PluginException, IOException {\n        if (supportsResources(getPluginMeta())) {\n            return getResourceLoader().listResources();\n        }\n        return null;\n    }\n\n    @Override\n    public InputStream openResourceStreamFor(final String name) throws PluginException, IOException {\n        if (supportsResources(getPluginMeta())) {\n            return getResourceLoader().openResourceStreamFor(name);\n        }\n        return null;\n    }\n\n    /**\n     * Load a provider instance for the service by name\n     */\n    public synchronized <T> T load(final PluggableService<T> service, final String providerName) throws\n        ProviderLoaderException {\n        if (!(service instanceof ScriptPluginProviderLoadable)) {\n            return null;\n        }\n        ScriptPluginProviderLoadable<T> loader =(ScriptPluginProviderLoadable<T>) service;\n        final ProviderIdent ident = new ProviderIdent(service.getName(), providerName);\n\n        if (null == pluginProviderDefs.get(ident)) {\n            //look for plugin def\n            final PluginMeta pluginMeta;\n            try {\n                pluginMeta = getPluginMeta();\n            } catch (IOException e) {\n                throw new ProviderLoaderException(e, service.getName(), providerName);\n            }\n            if (null == pluginMeta) {\n                throw new ProviderLoaderException(\"Unable to load plugin metadata for file: \" + file, service.getName(),\n                    providerName);\n            }\n            for (final ProviderDef pluginDef : pluginMeta.getPluginDefs()) {\n                if (matchesProvider(ident, pluginDef)) {\n                    final ScriptPluginProvider provider;\n                    try {\n                        provider = getPlugin(pluginMeta, file, pluginDef, ident);\n                    } catch (PluginException e) {\n                        throw new ProviderLoaderException(e, service.getName(), providerName);\n                    }\n                    pluginProviderDefs.put(ident, provider);\n                    break;\n                }\n            }\n        }\n        final ScriptPluginProvider scriptPluginProvider = pluginProviderDefs.get(ident);\n\n        try {\n            getResourceLoader().listResources();\n        } catch(IOException iex) {\n            throw new ProviderLoaderException(iex,service.getName(),providerName);\n        }\n        catch (PluginException e) {\n            throw new ProviderLoaderException(e, service.getName(), providerName);\n        }\n        if (null != scriptPluginProvider) {\n            try {\n                return loader.createScriptProviderInstance(scriptPluginProvider);\n            } catch (PluginException e) {\n                throw new ProviderLoaderException(e, service.getName(), providerName);\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public <T> CloseableProvider<T> loadCloseable(final PluggableService<T> service, final String providerName)\n            throws ProviderLoaderException\n    {\n        final T load = load(service, providerName);\n        if (null == load) {\n            return null;\n        }\n        return Closeables.closeableProvider(load);\n    }\n\n    private Date dateLoaded = null;\n\n    /**\n     * Get the plugin metadata, loading from the file if necessary\n     *\n     * @return loaded metadata or null if not found\n     *\n     * @throws IOException if an error occurs trying to load from the file\n     */\n    private PluginMeta getPluginMeta() throws IOException {\n        if (null != metadata) {\n            return metadata;\n        }\n        metadata = loadMeta(file);\n        metadata.setId(PluginUtils.generateShaIdFromName(metadata.getName()));\n        dateLoaded = new Date();\n        return metadata;\n    }\n\n    /**\n     * Get the ScriptPluginProvider definition from the file for the given provider def and ident\n     */\n    private ScriptPluginProvider getPlugin(\n            final PluginMeta pluginMeta,\n            final File file,\n            final ProviderDef pluginDef,\n            final ProviderIdent ident\n    ) throws\n            ProviderLoaderException, PluginException\n    {\n        if (null == fileExpandedDir) {\n            final File dir;\n            try {\n                dir = expandScriptPlugin(file);\n            } catch (IOException e) {\n                throw new ProviderLoaderException(e, ident.getService(), ident.getProviderName());\n            }\n            fileExpandedDir = dir;\n            if (pluginDef.getPluginType().equals(\"script\")) {\n\n                final File script = new File(fileExpandedDir, pluginDef.getScriptFile());\n                //set executable bit for script-file of the provider\n                try {\n                    ScriptfileUtils.setExecutePermissions(script);\n                } catch (IOException e) {\n                    log.warn(\"Unable to set executable bit for script file: \" + script + \": \" + e.getMessage());\n                }\n            }\n            debug(\"expanded plugin dir! \" + fileExpandedDir);\n        } else {\n            debug(\"expanded plugin dir: \" + fileExpandedDir);\n        }\n        if (pluginDef.getPluginType().equals(\"script\")) {\n            final File script = new File(fileExpandedDir, pluginDef.getScriptFile());\n            if (!script.exists() || !script.isFile()) {\n                throw new PluginException(\"Script file was not found: \" + script.getAbsolutePath());\n            }\n        }\n        return new ScriptPluginProviderImpl(pluginMeta, pluginDef, file, fileExpandedDir);\n    }\n\n    /**\n     * Return true if the ident matches the provider def metadata\n     */\n    private boolean matchesProvider(final ProviderIdent ident, final ProviderDef pluginDef) {\n        return ident.getService().equals(pluginDef.getService()) && ident.getProviderName().equals(pluginDef.getName());\n    }\n\n    /**\n     * Return true if the plugin file can loade a provider for the ident\n     */\n    public synchronized boolean isLoaderFor(final ProviderIdent ident) {\n\n        final PluginMeta pluginMeta;\n        try {\n            pluginMeta = getPluginMeta();\n        } catch (IOException e) {\n            log.warn(\"Unable to load file meta: \" + e.getMessage());\n            return false;\n        }\n        if (null == pluginMeta) {\n            return false;\n        }\n        for (final ProviderDef pluginDef : pluginMeta.getPluginDefs()) {\n            if (matchesProvider(ident, pluginDef)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public List<ProviderIdent> listProviders() {\n        final ArrayList<ProviderIdent> providerIdents = new ArrayList<ProviderIdent>();\n        PluginMeta pluginMeta=null;\n        try {\n            pluginMeta = getPluginMeta();\n        } catch (IOException e) {\n            debug(\"Unable to load file meta: \" + e.getMessage());\n        }\n        if (null == pluginMeta) {\n            return providerIdents;\n        }\n        for (final ProviderDef pluginDef : pluginMeta.getPluginDefs()) {\n            providerIdents.add(new ProviderIdent(pluginDef.getService(), pluginDef.getName()));\n        }\n        return providerIdents;\n    }\n\n\n    /**\n     * Get plugin metadatat from a zip file\n     */\n    static PluginMeta loadMeta(final File jar) throws IOException {\n        FileInputStream fileInputStream = new FileInputStream(jar);\n        try{\n            final ZipInputStream zipinput = new ZipInputStream(fileInputStream);\n            final PluginMeta metadata = ScriptPluginProviderLoader.loadMeta(jar, zipinput);\n            return metadata;\n        }finally {\n            fileInputStream.close();\n        }\n    }\n\n    /**\n     * Load plugin metadata for a file and zip inputstream\n     * @param jar the file\n     * @param zipinput zip input stream\n     * @return loaded metadata, or null if it is invalid or not found\n     */\n    static PluginMeta loadMeta(final File jar, final ZipInputStream zipinput) throws IOException {\n        final String basename = basename(jar);\n        PluginMeta metadata = null;\n        boolean topfound = false;\n        boolean found = false;\n        boolean dirfound = false;\n        boolean resfound = false;\n        ZipEntry nextEntry = zipinput.getNextEntry();\n        Set<String> paths = new HashSet<>();\n        while (null != nextEntry) {\n            paths.add(nextEntry.getName());\n\n            if (!found && !nextEntry.isDirectory() && nextEntry.getName().equals(basename + \"/plugin.yaml\")) {\n//                debug(\"Found metadata: \" + nextEntry.getName());\n                try {\n                    metadata = loadMetadataYaml(zipinput);\n                    found = true;\n                } catch (Throwable e) {\n                    log.error(\"Error parsing metadata file plugin.yaml: \" + e.getMessage(), e);\n                }\n            }\n            nextEntry = zipinput.getNextEntry();\n        }\n        if (!found || metadata == null) {\n            log.error(\"Plugin not loaded: Found no \" + basename + \"/plugin.yaml within: \" + jar.getAbsolutePath());\n        }\n        String resdir = null != metadata ? getResourcesBasePath(metadata) : null;\n\n        for (String path : paths) {\n            if (!topfound && path.startsWith(basename + \"/\")) {\n                topfound = true;\n            }\n            if (!dirfound && (path.startsWith(basename + \"/contents/\") || path.equals(basename + \"/contents\"))) {\n                dirfound = true;\n            }\n            if (!resfound\n                && resdir != null\n                && (path.startsWith(basename + \"/\" + resdir + \"/\") || path.equals(basename + \"/\" + resdir))) {\n                resfound = true;\n            }\n        }\n        if (!topfound) {\n            log.error(\"Plugin not loaded: Found no \" + basename + \"/ dir within file: \" + jar.getAbsolutePath());\n        }\n        if (!dirfound && !resfound) {\n            log.error(\"Plugin not loaded: Found no \" +\n                      basename +\n                      \"/contents or \" +\n                      basename +\n                      \"/\" + resdir + \" dir within: \" +\n                      jar.getAbsolutePath());\n        }\n        if (found && (dirfound || resfound)) {\n            return metadata;\n        }\n        return null;\n    }\n\n    /**\n     * return loaded yaml plugin metadata from the stream\n     */\n    static PluginMeta loadMetadataYaml(final InputStream stream) {\n        final Yaml yaml = new Yaml();\n\n        return yaml.loadAs(stream, PluginMeta.class);\n    }\n\n    /**\n     * Return true if loaded metadata about the plugin file is valid.\n     */\n    static PluginValidation validatePluginMeta(final PluginMeta pluginList, final File file) {\n        PluginValidation.State state = PluginValidation.State.VALID;\n        if (pluginList == null) {\n            return PluginValidation.builder()\n                                   .message(\"No metadata\")\n                                   .state(PluginValidation.State.INVALID)\n                                   .build();\n        }\n        List<String> messages = new ArrayList<>();\n        if (null == pluginList.getName()) {\n            messages.add(\"'name' not found in metadata\");\n            state = PluginValidation.State.INVALID;\n        }\n        if (null == pluginList.getVersion()) {\n            messages.add(\"'version' not found in metadata\");\n            state = PluginValidation.State.INVALID;\n        }\n        if (null == pluginList.getRundeckPluginVersion()) {\n            messages.add(\"'rundeckPluginVersion' not found in metadata\");\n            state = PluginValidation.State.INVALID;\n        } else if (!SUPPORTED_PLUGIN_VERSIONS.contains(pluginList.getRundeckPluginVersion())) {\n            messages.add(\"'rundeckPluginVersion': \\\"\" + pluginList.getRundeckPluginVersion() + \"\\\" is not supported\");\n            state = PluginValidation.State.INVALID;\n        }\n        if(pluginList.getRundeckPluginVersion().equals(VERSION_2_0)) {\n            List<String> validationErrors = new ArrayList<>();\n\n            PluginValidation.State\n                hostCompatState =\n                PluginMetadataValidator.validateTargetHostCompatibility(\n                    validationErrors,\n                    pluginList.getTargetHostCompatibility()\n                );\n            PluginValidation.State\n                versCompatState = PluginMetadataValidator.validateRundeckCompatibility(\n                validationErrors,\n                pluginList.getRundeckCompatibilityVersion()\n            );\n\n            messages.addAll(validationErrors);\n            state = state.or(hostCompatState)\n                         .or(versCompatState);\n\n        }\n        final List<ProviderDef> pluginDefs = pluginList.getPluginDefs();\n        for (final ProviderDef pluginDef : pluginDefs) {\n            try {\n                validateProviderDef(pluginDef);\n            } catch (PluginException e) {\n                messages.add(e.getMessage());\n                state = PluginValidation.State.INVALID;\n            }\n        }\n        return PluginValidation.builder()\n                               .state(state)\n                               .messages(messages)\n                               .build();\n    }\n\n    /**\n     * Expand zip file into plugin cache dir\n     *\n     * @param file zip file\n     *\n     * @return cache dir for the contents of the plugin zip\n     */\n    private File expandScriptPlugin(final File file) throws IOException {\n        if (!cachedir.exists()) {\n            if (!cachedir.mkdirs()) {\n                log.warn(\"Unable to create cache dir: \" + cachedir.getAbsolutePath());\n            }\n        }\n        final File jardir = getFileCacheDir();\n        if (!jardir.exists()) {\n            if (!jardir.mkdir()) {\n                log.warn(\"Unable to create cache dir for plugin: \" + jardir.getAbsolutePath());\n            }\n        }\n        final String prefix = getFileBasename() + \"/contents\";\n\n        debug(\"Expand zip \" + file.getAbsolutePath() + \" to dir: \" + jardir + \", prefix: \" + prefix);\n        ZipUtil.extractZip(file.getAbsolutePath(), jardir, prefix, prefix + \"/\");\n\n        return jardir;\n    }\n\n    /**\n     * Remove any cache dir for the file\n     */\n    private synchronized boolean removeScriptPluginCache() {\n        if (null != fileExpandedDir && fileExpandedDir.exists()) {\n            debug(\"removeScriptPluginCache: \" + fileExpandedDir);\n            return FileUtils.deleteDir(fileExpandedDir);\n        }\n        return true;\n    }\n\n    /**\n     * Basename of the file\n     */\n    String getFileBasename() {\n        return basename(file);\n    }\n\n    /**\n     * Get basename of a file\n     */\n    private static String basename(final File file) {\n        final String name = file.getName();\n        if(name.contains(\".\")) {\n            return name.substring(0, name.lastIndexOf(\".\"));\n        }\n        return name;\n    }\n\n    /**\n     * Get the cache dir for use for this file\n     */\n    File getFileCacheDir() {\n        return new File(cachedir, getFileBasename());\n    }\n\n\n    /**\n     * Validate provider def\n     */\n    private static void validateProviderDef(final ProviderDef pluginDef) throws PluginException {\n\n        if (null == pluginDef.getPluginType() || \"\".equals(pluginDef.getPluginType())) {\n            throw new PluginException(\"Script plugin missing plugin-type\");\n        }\n        if (\"script\".equals(pluginDef.getPluginType())) {\n            validateScriptProviderDef(pluginDef);\n        } else if (\"ui\".equals(pluginDef.getPluginType())) {\n            validateUIProviderDef(pluginDef);\n        } else {\n            throw new PluginException(\"Script plugin has invalid plugin-type: \" + pluginDef.getPluginType());\n        }\n    }\n\n    /**\n     * Validate script provider def\n     */\n    private static void validateScriptProviderDef(final ProviderDef pluginDef) throws PluginException {\n        if (null == pluginDef.getName() || \"\".equals(pluginDef.getName())) {\n            throw new PluginException(\"Script plugin missing name\");\n        }\n        if (null == pluginDef.getService() || \"\".equals(pluginDef.getService())) {\n            throw new PluginException(\"Script plugin missing service\");\n        }\n        if (null == pluginDef.getScriptFile() || \"\".equals(pluginDef.getScriptFile())) {\n            throw new PluginException(\"Script plugin missing script-file\");\n        }\n\n        //make sure service is pluggable service and is script pluggable\n        /* final FrameworkSupportService service = framework.getService(pluginDef.getService());\n        if (!(service instanceof PluggableService)) {\n            throw new PluginException(\n                \"Service '\" + pluginDef.getService() + \"' specified for script plugin '\" + pluginDef.getName()\n                + \"' is not valid: unsupported\");\n        }\n        final PluggableService pservice = (PluggableService) service;\n        if (!pservice.isScriptPluggable()) {\n            throw new PluginException(\n                \"Service '\" + pluginDef.getService() + \"' specified for script plugin '\" + pluginDef.getName()\n                + \"' is not valid: unsupported\");\n        }*/\n    }\n\n    /**\n     * Validate script provider def\n     */\n    private static void validateUIProviderDef(final ProviderDef pluginDef) throws PluginException {\n        if (null == pluginDef.getName() || \"\".equals(pluginDef.getName())) {\n            throw new PluginException(\"UI plugin missing name\");\n        }\n        if (null == pluginDef.getService() || \"\".equals(pluginDef.getService())) {\n            throw new PluginException(\"UI plugin missing service\");\n        }\n        if (null == pluginDef.getPluginData() || null == pluginDef.getPluginData().get(\"ui\")) {\n            throw new PluginException(\"UI plugin missing ui: definition\");\n        }\n\n    }\n\n    private static void debug(final String msg) {\n        if (log.isDebugEnabled()) {\n            log.debug(msg);\n        }\n    }\n\n    /**\n     * Expire the loader cache item\n     */\n    public void expire() {\n        removeScriptPluginCache();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || getClass() != o.getClass()) {\n            return false;\n        }\n\n        ScriptPluginProviderLoader that = (ScriptPluginProviderLoader) o;\n\n        if (cachedir != null ? !cachedir.equals(that.cachedir) : that.cachedir != null) {\n            return false;\n        }\n        if (file != null ? !file.equals(that.file) : that.file != null) {\n            return false;\n        }\n\n        return true;\n    }\n\n    @Override\n    public int hashCode() {\n        int result = file != null ? file.hashCode() : 0;\n        result = 31 * result + (cachedir != null ? cachedir.hashCode() : 0);\n        return result;\n    }\n\n\n    /**\n     * Return the version string metadata value for the plugin file, or null if it is not available or could not\n     * loaded\n     * @param file file\n     * @return version string\n     */\n    static String getVersionForFile(final File file)  {\n        try {\n            final PluginMeta pluginMeta = loadMeta(file);\n            return pluginMeta.getVersion();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    /**\n     * Return default value for \"mergeEnvironment\" based on plugin type version\n     * @param pluginMeta\n     * @return\n     */\n    public static boolean getDefaultMergeEnvVars(final PluginMeta pluginMeta) {\n        if (VERSION_1_0.equals(pluginMeta.getRundeckPluginVersion())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Return true if the plugin version supports resources\n     *\n     * @param pluginMeta\n     *\n     * @return\n     */\n    public static boolean supportsResources(final PluginMeta pluginMeta) {\n        return VersionCompare.forString(pluginMeta.getRundeckPluginVersion()).atLeast(SUPPORTS_RESOURCES_PLUGIN_VERSION);\n    }\n\n    public List<String> getPluginResourcesList() throws IOException {\n        return getPluginMeta().getResourcesList();\n    }\n\n    public String getResourcesBasePath() throws IOException {\n        return getResourcesBasePath(getPluginMeta());\n    }\n\n    public static String getResourcesBasePath(PluginMeta metadata) throws IOException {\n        String resourcesDir = metadata.getResourcesDir();\n        return null != resourcesDir ? resourcesDir : RESOURCES_DIR_DEFAULT;\n    }\n\n    @Override\n    public String getFilename() {\n        return file.getName();\n    }\n\n    @Override\n    public File getFile() {\n        return file;\n    }\n\n    @Override\n    public String getPluginArtifactName() {\n        try {\n            return getPluginMeta().getName();\n        } catch (IOException e) {\n\n        }\n        return null;\n    }\n\n    @Override\n    public String getPluginAuthor() {\n        try {\n            return getPluginMeta().getAuthor();\n        } catch (IOException e) {\n\n        }\n        return null;\n    }\n\n    @Override\n    public String getPluginFileVersion() {\n        try {\n            return getPluginMeta().getVersion();\n        } catch (IOException e) {\n\n        }\n        return null;\n    }\n\n    @Override\n    public String getPluginVersion() {\n        try {\n            return getPluginMeta().getRundeckPluginVersion();\n        } catch (IOException e) {\n\n        }\n        return null;\n    }\n\n    @Override\n    public String getPluginUrl() {\n        try {\n            return getPluginMeta().getUrl();\n        } catch (IOException e) {\n\n        }\n        return null;\n    }\n\n    @Override\n    public Date getPluginDate() {\n        try {\n            String date = getPluginMeta().getDate();\n            return new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ssX\").parse(date);\n        } catch (IOException | NullPointerException | ParseException e) {\n\n        }\n        return null;\n    }\n\n    @Override\n    public Date getDateLoaded() {\n        return dateLoaded;\n    }\n\n    @Override\n    public String getPluginName() {\n        try {\n            return getPluginMeta().getName();\n        } catch (IOException e) {\n\n        }\n        return null;\n    }\n\n    @Override\n    public String getPluginDescription() {\n        try {\n            return getPluginMeta().getDescription();\n        } catch (IOException e) {\n\n        }\n        return null;\n    }\n\n    @Override\n    public String getPluginId() {\n        try {\n            return getPluginMeta().getId();\n        } catch (IOException e) {\n\n        }\n        return null;\n    }\n\n    @Override\n    public String getRundeckCompatibilityVersion() {\n        try {\n            return getPluginMeta().getRundeckCompatibilityVersion();\n        } catch (IOException e) {\n\n        }\n        return null;\n    }\n\n    @Override\n    public String getTargetHostCompatibility() {\n        try {\n            return getPluginMeta().getTargetHostCompatibility();\n        } catch (IOException e) {\n\n        }\n        return null;\n    }\n\n    @Override\n    public List<String> getTags() {\n        try {\n            return getPluginMeta().getTags();\n        } catch (IOException e) {\n\n        }\n        return null;\n    }\n\n    @Override\n    public String getPluginLicense() {\n        try {\n            return getPluginMeta().getLicense();\n        } catch (IOException e) {\n\n        }\n        return null;\n    }\n\n    @Override\n    public String getPluginThirdPartyDependencies() {\n        try {\n            return getPluginMeta().getThirdPartyDependencies();\n        } catch (IOException e) {\n\n        }\n        return null;\n    }\n\n    @Override\n    public String getPluginSourceLink() {\n        try {\n            return getPluginMeta().getSourceLink();\n        } catch (IOException e) {\n\n        }\n        return null;\n    }\n\n    @Override\n    public String getPluginDocsLink() {\n        try {\n            return getPluginMeta().getDocsLink();\n        } catch (IOException e) {\n\n        }\n        return null;\n    }\n\n    @Override\n    public String getPluginType() {\n        return \"script\";\n    }\n}\n", "/*\n * Copyright 2018 Rundeck, Inc. (http://rundeck.com)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.dtolabs.rundeck.core.plugins\n\nimport com.dtolabs.rundeck.core.plugins.metadata.PluginMeta\nimport spock.lang.Specification\nimport spock.lang.Unroll\n\nimport static com.dtolabs.rundeck.core.plugins.PluginValidation.State.INCOMPATIBLE\nimport static com.dtolabs.rundeck.core.plugins.PluginValidation.State.INVALID\nimport static com.dtolabs.rundeck.core.plugins.PluginValidation.State.VALID\n\nclass ScriptPluginProviderLoaderTest extends Specification {\n\n    def \"LoadMetadataYaml with null date\"() {\n        setup:\n        File tmpCacheDir = File.createTempDir()\n\n        when:\n        String pluginName = \"Test script plugin\"\n        ScriptPluginProviderLoader loader = new ScriptPluginProviderLoader(File.createTempFile(\"throwaway\",\"unneeded\"),tmpCacheDir)\n        def pluginYaml = createPluginYaml(pluginName,\"1.2\")\n        def meta = loader.loadMetadataYaml(pluginYaml)\n        def dte = loader.getPluginDate()\n\n        then:\n        noExceptionThrown()\n        meta.name == pluginName\n        meta.rundeckPluginVersion == \"1.2\"\n        dte == null\n    }\n\n    def \"LoadMetadataYaml\"() {\n        setup:\n        File tmpCacheDir = File.createTempDir()\n\n        when:\n        String pluginName = \"Test script plugin\"\n        ScriptPluginProviderLoader loader = new ScriptPluginProviderLoader(File.createTempFile(\"throwaway\",\"unneeded\"),tmpCacheDir)\n        def pluginYaml = createPluginYaml(pluginName,\"1.2\")\n        def meta = loader.loadMetadataYaml(pluginYaml)\n\n        then:\n        meta.name == pluginName\n        meta.rundeckPluginVersion == \"1.2\"\n        meta.date == null\n    }\n\n    @Unroll\n    def \"ValidatePluginMeta\"() {\n        setup:\n        File fakeFile = new File(\"/tmp/fake-plugin.yaml\")\n        when:\n\n        def validation = ScriptPluginProviderLoader.validatePluginMeta(new PluginMeta(pluginMeta),fakeFile)\n\n        then:\n        logResult == validation.messages\n        validation.state.valid == expectation\n        validation.state == state\n\n        where:\n        expectation |state                                                                             | pluginMeta | logResult\n        false       |INVALID| [rundeckPluginVersion: \"1.2\", pluginDefs: []] | [\"'name' not found in metadata\", \"'version' not found in metadata\"]\n        false       |INVALID| [name:\"Test script\",rundeckPluginVersion: \"1.2\", pluginDefs: []]                | [\"'version' not found in metadata\"]\n        true        |VALID| [name:\"Test script\",rundeckPluginVersion: \"1.2\", version:\"1.0\", pluginDefs: []] | []\n        false       |INVALID| [name:\"Test script\",rundeckPluginVersion: \"2.0\", version:\"1.0\", pluginDefs: []] | [\"No targetHostCompatibility property specified in metadata\",\"rundeckCompatibilityVersion cannot be null in metadata\"]\n        false       |INVALID| [name:\"Test script\",rundeckPluginVersion: \"2.0\", version:\"1.0\", targetHostCompatibility:\"all\", pluginDefs: []] | [\"rundeckCompatibilityVersion cannot be null in metadata\"]\n        false       |INCOMPATIBLE| [name:\"Test script\",rundeckPluginVersion: \"2.0\", version:\"1.0\", targetHostCompatibility:\"all\", rundeckCompatibilityVersion:\"1.0\", pluginDefs: []] | [\"Plugin is not compatible with this version of Rundeck\"]\n        true        |VALID| [name:\"Test script\",rundeckPluginVersion: \"2.0\", version:\"1.0\", targetHostCompatibility:\"all\", rundeckCompatibilityVersion:\"3.x\", pluginDefs: []] | []\n        true        |VALID| [name:\"test-script\",display:\"Test script\",rundeckPluginVersion: \"2.0\", version:\"1.0\", targetHostCompatibility:\"all\", rundeckCompatibilityVersion:\"3.x\", pluginDefs: []] | []\n\n    }\n\n\n    ByteArrayInputStream createPluginYaml(String pluginName, String pluginVersion, Map props = [:]) {\n        StringBuilder yaml = new StringBuilder()\n        yaml.append(\"name: ${pluginName}\\n\")\n        yaml.append(\"rundeckPluginVersion: ${pluginVersion}\\n\")\n        props.each { k, v ->\n            yaml.append(\"$k : ${v}\\n\")\n        }\n        new ByteArrayInputStream(yaml.toString().bytes)\n    }\n}\n"], "fixing_code": ["/*\n * Copyright 2016 SimplifyOps, Inc. (http://simplifyops.com)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n* ScriptFileProviderLoader.java\n*\n* User: Greg Schueler <a href=\"mailto:greg@dtosolutions.com\">greg@dtosolutions.com</a>\n* Created: 4/13/11 10:07 AM\n*\n*/\npackage com.dtolabs.rundeck.core.plugins;\n\nimport com.dtolabs.rundeck.core.common.FrameworkSupportService;\nimport com.dtolabs.rundeck.core.execution.script.ScriptfileUtils;\nimport com.dtolabs.rundeck.core.execution.service.ProviderLoaderException;\nimport com.dtolabs.rundeck.core.plugins.metadata.ProviderDef;\nimport com.dtolabs.rundeck.core.plugins.metadata.PluginMeta;\nimport com.dtolabs.rundeck.core.utils.FileUtils;\nimport com.dtolabs.rundeck.core.utils.ZipUtil;\nimport com.dtolabs.rundeck.core.utils.cache.FileCache;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.yaml.snakeyaml.Yaml;\nimport org.yaml.snakeyaml.constructor.Constructor;\nimport org.yaml.snakeyaml.nodes.Tag;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.*;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipInputStream;\n\nimport static com.dtolabs.rundeck.core.plugins.JarPluginProviderLoader.RESOURCES_DIR_DEFAULT;\n\n/**\n * ScriptPluginProviderLoader can load a provider instance for a service from a script plugin zip file.\n *\n * Services that want to use this loader need to implement {@link ScriptPluginProviderLoadable}\n *\n * @author Greg Schueler <a href=\"mailto:greg@dtosolutions.com\">greg@dtosolutions.com</a>\n */\npublic class ScriptPluginProviderLoader implements ProviderLoader, FileCache.Expireable, PluginResourceLoader, PluginMetadata {\n\n    private static final Logger         log                               = LoggerFactory.getLogger(ScriptPluginProviderLoader.class.getName());\n    public static final  String         VERSION_1_0                       = \"1.0\";\n    public static final  String         VERSION_1_1                       = \"1.1\";\n    public static final  String         VERSION_1_2                       = \"1.2\";\n    public static final  VersionCompare SUPPORTS_RESOURCES_PLUGIN_VERSION = VersionCompare.forString(VERSION_1_2);\n    public static final  String         VERSION_2_0                       = \"2.0\";\n    public static final  List<String>   SUPPORTED_PLUGIN_VERSIONS;\n    static {\n        SUPPORTED_PLUGIN_VERSIONS = Collections.unmodifiableList(Arrays.asList(\n                VERSION_1_0,\n                VERSION_1_1,\n                VERSION_1_2,\n                VERSION_2_0\n        ));\n    }\n    private final File file;\n    final File cachedir;\n    /**\n     * Dir of expanded zip contents\n     */\n    private File fileExpandedDir;\n    /**\n     * Metadata from the plugin.yaml file\n     */\n    private PluginMeta metadata;\n    /**\n     * Metadata from the plugin.yaml file\n     */\n    private PluginResourceLoader resourceLoader;\n    /**\n     * cache of ident to scriptplugin def mapping\n     */\n    private Map<ProviderIdent, ScriptPluginProvider> pluginProviderDefs =\n        new HashMap<ProviderIdent, ScriptPluginProvider>();\n    private List<String> pluginResourcesList;\n\n    public ScriptPluginProviderLoader(final File file, final File cachedir) {\n        this.file = file;\n        this.cachedir = cachedir;\n    }\n\n    @Override\n    public boolean canLoadForService(final FrameworkSupportService service) {\n        return service instanceof ScriptPluginProviderLoadable;\n    }\n\n    private PluginResourceLoader getResourceLoader() throws PluginException {\n        if (null == resourceLoader) {\n            synchronized (this) {\n                if (null == resourceLoader) {\n                    try {\n                        ZipResourceLoader loader = new ZipResourceLoader(\n                                new File(getFileCacheDir(), \"resources\"),\n                                file,\n                                getPluginResourcesList(),\n                                getFileBasename() + \"/\" + getResourcesBasePath()\n                        );\n                        loader.extractResources();\n                        this.resourceLoader = loader;\n                    } catch (IOException e) {\n                        throw new PluginException(\"Unable to expand plugin libs: \" + e.getMessage(), e);\n                    }\n                }\n            }\n        }\n        return resourceLoader;\n    }\n\n    @Override\n    public List<String> listResources() throws PluginException, IOException {\n        if (supportsResources(getPluginMeta())) {\n            return getResourceLoader().listResources();\n        }\n        return null;\n    }\n\n    @Override\n    public InputStream openResourceStreamFor(final String name) throws PluginException, IOException {\n        if (supportsResources(getPluginMeta())) {\n            return getResourceLoader().openResourceStreamFor(name);\n        }\n        return null;\n    }\n\n    /**\n     * Load a provider instance for the service by name\n     */\n    public synchronized <T> T load(final PluggableService<T> service, final String providerName) throws\n        ProviderLoaderException {\n        if (!(service instanceof ScriptPluginProviderLoadable)) {\n            return null;\n        }\n        ScriptPluginProviderLoadable<T> loader =(ScriptPluginProviderLoadable<T>) service;\n        final ProviderIdent ident = new ProviderIdent(service.getName(), providerName);\n\n        if (null == pluginProviderDefs.get(ident)) {\n            //look for plugin def\n            final PluginMeta pluginMeta;\n            try {\n                pluginMeta = getPluginMeta();\n            } catch (IOException e) {\n                throw new ProviderLoaderException(e, service.getName(), providerName);\n            }\n            if (null == pluginMeta) {\n                throw new ProviderLoaderException(\"Unable to load plugin metadata for file: \" + file, service.getName(),\n                    providerName);\n            }\n            for (final ProviderDef pluginDef : pluginMeta.getPluginDefs()) {\n                if (matchesProvider(ident, pluginDef)) {\n                    final ScriptPluginProvider provider;\n                    try {\n                        provider = getPlugin(pluginMeta, file, pluginDef, ident);\n                    } catch (PluginException e) {\n                        throw new ProviderLoaderException(e, service.getName(), providerName);\n                    }\n                    pluginProviderDefs.put(ident, provider);\n                    break;\n                }\n            }\n        }\n        final ScriptPluginProvider scriptPluginProvider = pluginProviderDefs.get(ident);\n\n        try {\n            getResourceLoader().listResources();\n        } catch(IOException iex) {\n            throw new ProviderLoaderException(iex,service.getName(),providerName);\n        }\n        catch (PluginException e) {\n            throw new ProviderLoaderException(e, service.getName(), providerName);\n        }\n        if (null != scriptPluginProvider) {\n            try {\n                return loader.createScriptProviderInstance(scriptPluginProvider);\n            } catch (PluginException e) {\n                throw new ProviderLoaderException(e, service.getName(), providerName);\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public <T> CloseableProvider<T> loadCloseable(final PluggableService<T> service, final String providerName)\n            throws ProviderLoaderException\n    {\n        final T load = load(service, providerName);\n        if (null == load) {\n            return null;\n        }\n        return Closeables.closeableProvider(load);\n    }\n\n    private Date dateLoaded = null;\n\n    /**\n     * Get the plugin metadata, loading from the file if necessary\n     *\n     * @return loaded metadata or null if not found\n     *\n     * @throws IOException if an error occurs trying to load from the file\n     */\n    private PluginMeta getPluginMeta() throws IOException {\n        if (null != metadata) {\n            return metadata;\n        }\n        metadata = loadMeta(file);\n        metadata.setId(PluginUtils.generateShaIdFromName(metadata.getName()));\n        dateLoaded = new Date();\n        return metadata;\n    }\n\n    /**\n     * Get the ScriptPluginProvider definition from the file for the given provider def and ident\n     */\n    private ScriptPluginProvider getPlugin(\n            final PluginMeta pluginMeta,\n            final File file,\n            final ProviderDef pluginDef,\n            final ProviderIdent ident\n    ) throws\n            ProviderLoaderException, PluginException\n    {\n        if (null == fileExpandedDir) {\n            final File dir;\n            try {\n                dir = expandScriptPlugin(file);\n            } catch (IOException e) {\n                throw new ProviderLoaderException(e, ident.getService(), ident.getProviderName());\n            }\n            fileExpandedDir = dir;\n            if (pluginDef.getPluginType().equals(\"script\")) {\n\n                final File script = new File(fileExpandedDir, pluginDef.getScriptFile());\n                //set executable bit for script-file of the provider\n                try {\n                    ScriptfileUtils.setExecutePermissions(script);\n                } catch (IOException e) {\n                    log.warn(\"Unable to set executable bit for script file: \" + script + \": \" + e.getMessage());\n                }\n            }\n            debug(\"expanded plugin dir! \" + fileExpandedDir);\n        } else {\n            debug(\"expanded plugin dir: \" + fileExpandedDir);\n        }\n        if (pluginDef.getPluginType().equals(\"script\")) {\n            final File script = new File(fileExpandedDir, pluginDef.getScriptFile());\n            if (!script.exists() || !script.isFile()) {\n                throw new PluginException(\"Script file was not found: \" + script.getAbsolutePath());\n            }\n        }\n        return new ScriptPluginProviderImpl(pluginMeta, pluginDef, file, fileExpandedDir);\n    }\n\n    /**\n     * Return true if the ident matches the provider def metadata\n     */\n    private boolean matchesProvider(final ProviderIdent ident, final ProviderDef pluginDef) {\n        return ident.getService().equals(pluginDef.getService()) && ident.getProviderName().equals(pluginDef.getName());\n    }\n\n    /**\n     * Return true if the plugin file can loade a provider for the ident\n     */\n    public synchronized boolean isLoaderFor(final ProviderIdent ident) {\n\n        final PluginMeta pluginMeta;\n        try {\n            pluginMeta = getPluginMeta();\n        } catch (IOException e) {\n            log.warn(\"Unable to load file meta: \" + e.getMessage());\n            return false;\n        }\n        if (null == pluginMeta) {\n            return false;\n        }\n        for (final ProviderDef pluginDef : pluginMeta.getPluginDefs()) {\n            if (matchesProvider(ident, pluginDef)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public List<ProviderIdent> listProviders() {\n        final ArrayList<ProviderIdent> providerIdents = new ArrayList<ProviderIdent>();\n        PluginMeta pluginMeta=null;\n        try {\n            pluginMeta = getPluginMeta();\n        } catch (IOException e) {\n            debug(\"Unable to load file meta: \" + e.getMessage());\n        }\n        if (null == pluginMeta) {\n            return providerIdents;\n        }\n        for (final ProviderDef pluginDef : pluginMeta.getPluginDefs()) {\n            providerIdents.add(new ProviderIdent(pluginDef.getService(), pluginDef.getName()));\n        }\n        return providerIdents;\n    }\n\n\n    /**\n     * Get plugin metadatat from a zip file\n     */\n    static PluginMeta loadMeta(final File jar) throws IOException {\n        FileInputStream fileInputStream = new FileInputStream(jar);\n        try{\n            final ZipInputStream zipinput = new ZipInputStream(fileInputStream);\n            final PluginMeta metadata = ScriptPluginProviderLoader.loadMeta(jar, zipinput);\n            return metadata;\n        }finally {\n            fileInputStream.close();\n        }\n    }\n\n    /**\n     * Load plugin metadata for a file and zip inputstream\n     * @param jar the file\n     * @param zipinput zip input stream\n     * @return loaded metadata, or null if it is invalid or not found\n     */\n    static PluginMeta loadMeta(final File jar, final ZipInputStream zipinput) throws IOException {\n        final String basename = basename(jar);\n        PluginMeta metadata = null;\n        boolean topfound = false;\n        boolean found = false;\n        boolean dirfound = false;\n        boolean resfound = false;\n        ZipEntry nextEntry = zipinput.getNextEntry();\n        Set<String> paths = new HashSet<>();\n        while (null != nextEntry) {\n            paths.add(nextEntry.getName());\n\n            if (!found && !nextEntry.isDirectory() && nextEntry.getName().equals(basename + \"/plugin.yaml\")) {\n//                debug(\"Found metadata: \" + nextEntry.getName());\n                try {\n                    metadata = loadMetadataYaml(zipinput);\n                    found = true;\n                } catch (Throwable e) {\n                    log.error(\"Error parsing metadata file plugin.yaml: \" + e.getMessage(), e);\n                }\n            }\n            nextEntry = zipinput.getNextEntry();\n        }\n        if (!found || metadata == null) {\n            log.error(\"Plugin not loaded: Found no \" + basename + \"/plugin.yaml within: \" + jar.getAbsolutePath());\n        }\n        String resdir = null != metadata ? getResourcesBasePath(metadata) : null;\n\n        for (String path : paths) {\n            if (!topfound && path.startsWith(basename + \"/\")) {\n                topfound = true;\n            }\n            if (!dirfound && (path.startsWith(basename + \"/contents/\") || path.equals(basename + \"/contents\"))) {\n                dirfound = true;\n            }\n            if (!resfound\n                && resdir != null\n                && (path.startsWith(basename + \"/\" + resdir + \"/\") || path.equals(basename + \"/\" + resdir))) {\n                resfound = true;\n            }\n        }\n        if (!topfound) {\n            log.error(\"Plugin not loaded: Found no \" + basename + \"/ dir within file: \" + jar.getAbsolutePath());\n        }\n        if (!dirfound && !resfound) {\n            log.error(\"Plugin not loaded: Found no \" +\n                      basename +\n                      \"/contents or \" +\n                      basename +\n                      \"/\" + resdir + \" dir within: \" +\n                      jar.getAbsolutePath());\n        }\n        if (found && (dirfound || resfound)) {\n            return metadata;\n        }\n        return null;\n    }\n\n    /**\n     * define only constructor for single type\n     */\n    static class SingleTypeConstructor extends Constructor{\n        public SingleTypeConstructor(Class<?> clazz) {\n            super(clazz);\n            this.yamlConstructors.put(null, undefinedConstructor);\n            this.yamlConstructors.put(new Tag(clazz), new SubtypeConstructYamlObject());\n        }\n        //required because ConstructYamlObject is protected\n        class SubtypeConstructYamlObject extends ConstructYamlObject{\n\n        }\n    }\n    /**\n     * return loaded yaml plugin metadata from the stream\n     */\n    static PluginMeta loadMetadataYaml(final InputStream stream) {\n        final Yaml yaml = new Yaml(new SingleTypeConstructor(PluginMeta.class));\n        return yaml.loadAs(stream, PluginMeta.class);\n    }\n\n    /**\n     * Return true if loaded metadata about the plugin file is valid.\n     */\n    static PluginValidation validatePluginMeta(final PluginMeta pluginList, final File file) {\n        PluginValidation.State state = PluginValidation.State.VALID;\n        if (pluginList == null) {\n            return PluginValidation.builder()\n                                   .message(\"No metadata\")\n                                   .state(PluginValidation.State.INVALID)\n                                   .build();\n        }\n        List<String> messages = new ArrayList<>();\n        if (null == pluginList.getName()) {\n            messages.add(\"'name' not found in metadata\");\n            state = PluginValidation.State.INVALID;\n        }\n        if (null == pluginList.getVersion()) {\n            messages.add(\"'version' not found in metadata\");\n            state = PluginValidation.State.INVALID;\n        }\n        if (null == pluginList.getRundeckPluginVersion()) {\n            messages.add(\"'rundeckPluginVersion' not found in metadata\");\n            state = PluginValidation.State.INVALID;\n        } else if (!SUPPORTED_PLUGIN_VERSIONS.contains(pluginList.getRundeckPluginVersion())) {\n            messages.add(\"'rundeckPluginVersion': \\\"\" + pluginList.getRundeckPluginVersion() + \"\\\" is not supported\");\n            state = PluginValidation.State.INVALID;\n        }\n        if(pluginList.getRundeckPluginVersion().equals(VERSION_2_0)) {\n            List<String> validationErrors = new ArrayList<>();\n\n            PluginValidation.State\n                hostCompatState =\n                PluginMetadataValidator.validateTargetHostCompatibility(\n                    validationErrors,\n                    pluginList.getTargetHostCompatibility()\n                );\n            PluginValidation.State\n                versCompatState = PluginMetadataValidator.validateRundeckCompatibility(\n                validationErrors,\n                pluginList.getRundeckCompatibilityVersion()\n            );\n\n            messages.addAll(validationErrors);\n            state = state.or(hostCompatState)\n                         .or(versCompatState);\n\n        }\n        final List<ProviderDef> pluginDefs = pluginList.getPluginDefs();\n        for (final ProviderDef pluginDef : pluginDefs) {\n            try {\n                validateProviderDef(pluginDef);\n            } catch (PluginException e) {\n                messages.add(e.getMessage());\n                state = PluginValidation.State.INVALID;\n            }\n        }\n        return PluginValidation.builder()\n                               .state(state)\n                               .messages(messages)\n                               .build();\n    }\n\n    /**\n     * Expand zip file into plugin cache dir\n     *\n     * @param file zip file\n     *\n     * @return cache dir for the contents of the plugin zip\n     */\n    private File expandScriptPlugin(final File file) throws IOException {\n        if (!cachedir.exists()) {\n            if (!cachedir.mkdirs()) {\n                log.warn(\"Unable to create cache dir: \" + cachedir.getAbsolutePath());\n            }\n        }\n        final File jardir = getFileCacheDir();\n        if (!jardir.exists()) {\n            if (!jardir.mkdir()) {\n                log.warn(\"Unable to create cache dir for plugin: \" + jardir.getAbsolutePath());\n            }\n        }\n        final String prefix = getFileBasename() + \"/contents\";\n\n        debug(\"Expand zip \" + file.getAbsolutePath() + \" to dir: \" + jardir + \", prefix: \" + prefix);\n        ZipUtil.extractZip(file.getAbsolutePath(), jardir, prefix, prefix + \"/\");\n\n        return jardir;\n    }\n\n    /**\n     * Remove any cache dir for the file\n     */\n    private synchronized boolean removeScriptPluginCache() {\n        if (null != fileExpandedDir && fileExpandedDir.exists()) {\n            debug(\"removeScriptPluginCache: \" + fileExpandedDir);\n            return FileUtils.deleteDir(fileExpandedDir);\n        }\n        return true;\n    }\n\n    /**\n     * Basename of the file\n     */\n    String getFileBasename() {\n        return basename(file);\n    }\n\n    /**\n     * Get basename of a file\n     */\n    private static String basename(final File file) {\n        final String name = file.getName();\n        if(name.contains(\".\")) {\n            return name.substring(0, name.lastIndexOf(\".\"));\n        }\n        return name;\n    }\n\n    /**\n     * Get the cache dir for use for this file\n     */\n    File getFileCacheDir() {\n        return new File(cachedir, getFileBasename());\n    }\n\n\n    /**\n     * Validate provider def\n     */\n    private static void validateProviderDef(final ProviderDef pluginDef) throws PluginException {\n\n        if (null == pluginDef.getPluginType() || \"\".equals(pluginDef.getPluginType())) {\n            throw new PluginException(\"Script plugin missing plugin-type\");\n        }\n        if (\"script\".equals(pluginDef.getPluginType())) {\n            validateScriptProviderDef(pluginDef);\n        } else if (\"ui\".equals(pluginDef.getPluginType())) {\n            validateUIProviderDef(pluginDef);\n        } else {\n            throw new PluginException(\"Script plugin has invalid plugin-type: \" + pluginDef.getPluginType());\n        }\n    }\n\n    /**\n     * Validate script provider def\n     */\n    private static void validateScriptProviderDef(final ProviderDef pluginDef) throws PluginException {\n        if (null == pluginDef.getName() || \"\".equals(pluginDef.getName())) {\n            throw new PluginException(\"Script plugin missing name\");\n        }\n        if (null == pluginDef.getService() || \"\".equals(pluginDef.getService())) {\n            throw new PluginException(\"Script plugin missing service\");\n        }\n        if (null == pluginDef.getScriptFile() || \"\".equals(pluginDef.getScriptFile())) {\n            throw new PluginException(\"Script plugin missing script-file\");\n        }\n\n        //make sure service is pluggable service and is script pluggable\n        /* final FrameworkSupportService service = framework.getService(pluginDef.getService());\n        if (!(service instanceof PluggableService)) {\n            throw new PluginException(\n                \"Service '\" + pluginDef.getService() + \"' specified for script plugin '\" + pluginDef.getName()\n                + \"' is not valid: unsupported\");\n        }\n        final PluggableService pservice = (PluggableService) service;\n        if (!pservice.isScriptPluggable()) {\n            throw new PluginException(\n                \"Service '\" + pluginDef.getService() + \"' specified for script plugin '\" + pluginDef.getName()\n                + \"' is not valid: unsupported\");\n        }*/\n    }\n\n    /**\n     * Validate script provider def\n     */\n    private static void validateUIProviderDef(final ProviderDef pluginDef) throws PluginException {\n        if (null == pluginDef.getName() || \"\".equals(pluginDef.getName())) {\n            throw new PluginException(\"UI plugin missing name\");\n        }\n        if (null == pluginDef.getService() || \"\".equals(pluginDef.getService())) {\n            throw new PluginException(\"UI plugin missing service\");\n        }\n        if (null == pluginDef.getPluginData() || null == pluginDef.getPluginData().get(\"ui\")) {\n            throw new PluginException(\"UI plugin missing ui: definition\");\n        }\n\n    }\n\n    private static void debug(final String msg) {\n        if (log.isDebugEnabled()) {\n            log.debug(msg);\n        }\n    }\n\n    /**\n     * Expire the loader cache item\n     */\n    public void expire() {\n        removeScriptPluginCache();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || getClass() != o.getClass()) {\n            return false;\n        }\n\n        ScriptPluginProviderLoader that = (ScriptPluginProviderLoader) o;\n\n        if (cachedir != null ? !cachedir.equals(that.cachedir) : that.cachedir != null) {\n            return false;\n        }\n        if (file != null ? !file.equals(that.file) : that.file != null) {\n            return false;\n        }\n\n        return true;\n    }\n\n    @Override\n    public int hashCode() {\n        int result = file != null ? file.hashCode() : 0;\n        result = 31 * result + (cachedir != null ? cachedir.hashCode() : 0);\n        return result;\n    }\n\n\n    /**\n     * Return the version string metadata value for the plugin file, or null if it is not available or could not\n     * loaded\n     * @param file file\n     * @return version string\n     */\n    static String getVersionForFile(final File file)  {\n        try {\n            final PluginMeta pluginMeta = loadMeta(file);\n            return pluginMeta.getVersion();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    /**\n     * Return default value for \"mergeEnvironment\" based on plugin type version\n     * @param pluginMeta\n     * @return\n     */\n    public static boolean getDefaultMergeEnvVars(final PluginMeta pluginMeta) {\n        if (VERSION_1_0.equals(pluginMeta.getRundeckPluginVersion())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Return true if the plugin version supports resources\n     *\n     * @param pluginMeta\n     *\n     * @return\n     */\n    public static boolean supportsResources(final PluginMeta pluginMeta) {\n        return VersionCompare.forString(pluginMeta.getRundeckPluginVersion()).atLeast(SUPPORTS_RESOURCES_PLUGIN_VERSION);\n    }\n\n    public List<String> getPluginResourcesList() throws IOException {\n        return getPluginMeta().getResourcesList();\n    }\n\n    public String getResourcesBasePath() throws IOException {\n        return getResourcesBasePath(getPluginMeta());\n    }\n\n    public static String getResourcesBasePath(PluginMeta metadata) throws IOException {\n        String resourcesDir = metadata.getResourcesDir();\n        return null != resourcesDir ? resourcesDir : RESOURCES_DIR_DEFAULT;\n    }\n\n    @Override\n    public String getFilename() {\n        return file.getName();\n    }\n\n    @Override\n    public File getFile() {\n        return file;\n    }\n\n    @Override\n    public String getPluginArtifactName() {\n        try {\n            return getPluginMeta().getName();\n        } catch (IOException e) {\n\n        }\n        return null;\n    }\n\n    @Override\n    public String getPluginAuthor() {\n        try {\n            return getPluginMeta().getAuthor();\n        } catch (IOException e) {\n\n        }\n        return null;\n    }\n\n    @Override\n    public String getPluginFileVersion() {\n        try {\n            return getPluginMeta().getVersion();\n        } catch (IOException e) {\n\n        }\n        return null;\n    }\n\n    @Override\n    public String getPluginVersion() {\n        try {\n            return getPluginMeta().getRundeckPluginVersion();\n        } catch (IOException e) {\n\n        }\n        return null;\n    }\n\n    @Override\n    public String getPluginUrl() {\n        try {\n            return getPluginMeta().getUrl();\n        } catch (IOException e) {\n\n        }\n        return null;\n    }\n\n    @Override\n    public Date getPluginDate() {\n        try {\n            String date = getPluginMeta().getDate();\n            return new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ssX\").parse(date);\n        } catch (IOException | NullPointerException | ParseException e) {\n\n        }\n        return null;\n    }\n\n    @Override\n    public Date getDateLoaded() {\n        return dateLoaded;\n    }\n\n    @Override\n    public String getPluginName() {\n        try {\n            return getPluginMeta().getName();\n        } catch (IOException e) {\n\n        }\n        return null;\n    }\n\n    @Override\n    public String getPluginDescription() {\n        try {\n            return getPluginMeta().getDescription();\n        } catch (IOException e) {\n\n        }\n        return null;\n    }\n\n    @Override\n    public String getPluginId() {\n        try {\n            return getPluginMeta().getId();\n        } catch (IOException e) {\n\n        }\n        return null;\n    }\n\n    @Override\n    public String getRundeckCompatibilityVersion() {\n        try {\n            return getPluginMeta().getRundeckCompatibilityVersion();\n        } catch (IOException e) {\n\n        }\n        return null;\n    }\n\n    @Override\n    public String getTargetHostCompatibility() {\n        try {\n            return getPluginMeta().getTargetHostCompatibility();\n        } catch (IOException e) {\n\n        }\n        return null;\n    }\n\n    @Override\n    public List<String> getTags() {\n        try {\n            return getPluginMeta().getTags();\n        } catch (IOException e) {\n\n        }\n        return null;\n    }\n\n    @Override\n    public String getPluginLicense() {\n        try {\n            return getPluginMeta().getLicense();\n        } catch (IOException e) {\n\n        }\n        return null;\n    }\n\n    @Override\n    public String getPluginThirdPartyDependencies() {\n        try {\n            return getPluginMeta().getThirdPartyDependencies();\n        } catch (IOException e) {\n\n        }\n        return null;\n    }\n\n    @Override\n    public String getPluginSourceLink() {\n        try {\n            return getPluginMeta().getSourceLink();\n        } catch (IOException e) {\n\n        }\n        return null;\n    }\n\n    @Override\n    public String getPluginDocsLink() {\n        try {\n            return getPluginMeta().getDocsLink();\n        } catch (IOException e) {\n\n        }\n        return null;\n    }\n\n    @Override\n    public String getPluginType() {\n        return \"script\";\n    }\n}\n", "/*\n * Copyright 2018 Rundeck, Inc. (http://rundeck.com)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.dtolabs.rundeck.core.plugins\n\nimport com.dtolabs.rundeck.core.plugins.metadata.PluginMeta\nimport com.dtolabs.rundeck.core.plugins.metadata.ProviderDef\nimport org.yaml.snakeyaml.Yaml\nimport org.yaml.snakeyaml.constructor.SafeConstructor\nimport org.yaml.snakeyaml.error.YAMLException\nimport spock.lang.Specification\nimport spock.lang.Unroll\n\nimport static com.dtolabs.rundeck.core.plugins.PluginValidation.State.INCOMPATIBLE\nimport static com.dtolabs.rundeck.core.plugins.PluginValidation.State.INVALID\nimport static com.dtolabs.rundeck.core.plugins.PluginValidation.State.VALID\n\nclass ScriptPluginProviderLoaderTest extends Specification {\n\n    def \"LoadMetadataYaml with null date\"() {\n        setup:\n        File tmpCacheDir = File.createTempDir()\n\n        when:\n        String pluginName = \"Test script plugin\"\n        ScriptPluginProviderLoader loader = new ScriptPluginProviderLoader(File.createTempFile(\"throwaway\",\"unneeded\"),tmpCacheDir)\n        def pluginYaml = createPluginYaml(pluginName,\"1.2\")\n        def meta = loader.loadMetadataYaml(pluginYaml)\n        def dte = loader.getPluginDate()\n\n        then:\n        noExceptionThrown()\n        meta.name == pluginName\n        meta.rundeckPluginVersion == \"1.2\"\n        dte == null\n    }\n\n    def \"LoadMetadataYaml\"() {\n        setup:\n            File tmpCacheDir = File.createTempDir()\n\n            String pluginName = \"Test script plugin\"\n            ScriptPluginProviderLoader loader = new ScriptPluginProviderLoader(File.createTempFile(\"throwaway\",\"unneeded\"),tmpCacheDir)\n            def pluginYaml = createPluginYaml(pluginName,\"1.2\",[\n                author:'author',\n                date:'adate',\n                version:'aversion',\n                url:'aurl',\n                resourcesDir:'adir',\n                resourcesList:['res1','res2'],\n                providers:[\n                    [\n                        'name':'aprov',\n                        'service':'aservice',\n                        'script-file':'afile',\n                        'script-args':'args',\n                        'script-interpreter':'interp',\n                        'interpreter-args-quoted':true,\n                        'plugin-type':'type',\n                        'plugin-meta':[\n                            'meta1':'metaA',\n                            'meta2':'metaB'\n                        ],\n                    ]\n                ],\n            ])\n        when: \"load plugin yaml\"\n            def meta = loader.loadMetadataYaml(pluginYaml)\n\n        then: \"expected values are defined\"\n            meta.name == pluginName\n            meta.rundeckPluginVersion == \"1.2\"\n            meta.date == 'adate'\n            meta.version == 'aversion'\n            meta.url == 'aurl'\n            meta.resourcesDir == 'adir'\n            meta.resourcesList == ['res1','res2']\n            meta.providers.size()==1\n            meta.pluginDefs.size()==1\n            meta.pluginDefs[0] instanceof ProviderDef\n            meta.pluginDefs[0].name=='aprov'\n            meta.pluginDefs[0].service=='aservice'\n            meta.pluginDefs[0].scriptFile=='afile'\n            meta.pluginDefs[0].scriptArgs=='args'\n            meta.pluginDefs[0].scriptInterpreter=='interp'\n            meta.pluginDefs[0].interpreterArgsQuoted==true\n            meta.pluginDefs[0].pluginType=='type'\n            meta.pluginDefs[0].providerMeta==[\n                'meta1':'metaA',\n                'meta2':'metaB'\n            ]\n    }\n    def \"LoadMetadataYaml args array\"() {\n        setup:\n        File tmpCacheDir = File.createTempDir()\n            String pluginName = \"Test script plugin\"\n            ScriptPluginProviderLoader loader = new ScriptPluginProviderLoader(File.createTempFile(\"throwaway\",\"unneeded\"),tmpCacheDir)\n            def pluginYaml = createPluginYaml(pluginName,\"1.2\",[\n                author:'author',\n                date:'adate',\n                version:'aversion',\n                url:'aurl',\n                resourcesDir:'adir',\n                resourcesList:['res1','res2'],\n                providers:[\n                    [\n                        'name':'aprov',\n                        'service':'aservice',\n                        'script-file':'afile',\n                        'script-args':[\n                            'args1',\n                            'args2'\n                        ],\n                        'script-interpreter':'interp',\n                        'interpreter-args-quoted':true,\n                        'plugin-type':'type',\n                        'plugin-meta':[\n                            'meta1':'metaA',\n                            'meta2':'metaB'\n                        ],\n                    ]\n                ],\n            ])\n        when: \"yaml has script-args with a sequence value\"\n        def meta = loader.loadMetadataYaml(pluginYaml)\n\n        then: \"scriptArgsArray is set in the ProviderDef\"\n        meta.name == pluginName\n        meta.rundeckPluginVersion == \"1.2\"\n        meta.date == 'adate'\n        meta.version == 'aversion'\n        meta.url == 'aurl'\n        meta.resourcesDir == 'adir'\n        meta.resourcesList == ['res1','res2']\n        meta.providers.size()==1\n        meta.pluginDefs.size()==1\n        meta.pluginDefs[0] instanceof ProviderDef\n        meta.pluginDefs[0].name=='aprov'\n        meta.pluginDefs[0].service=='aservice'\n        meta.pluginDefs[0].scriptFile=='afile'\n        meta.pluginDefs[0].scriptArgs==null\n        meta.pluginDefs[0].scriptArgsArray.toList()==['args1','args2']\n        meta.pluginDefs[0].scriptInterpreter=='interp'\n        meta.pluginDefs[0].interpreterArgsQuoted==true\n        meta.pluginDefs[0].pluginType=='type'\n        meta.pluginDefs[0].providerMeta==[\n            'meta1':'metaA',\n            'meta2':'metaB'\n        ]\n    }\n\n    static final String TEST_YAML1='''name: plugin-name\nversion: 1.0\nrundeckPluginVersion: 1.2\nproviders:\n    - name: zingbat\n      plugin-meta:\n        test: !!java.lang.Object\n      '''\n    static final String TEST_YAML2='''name: plugin-name\nversion: 1.0\nrundeckPluginVersion: 1.2\nproviders:\n    - !!java.lang.Object\n      '''\n    static final String TEST_YAML3='''name: plugin-name\nversion: 1.0\nrundeckPluginVersion: 1.2\nresourcesList:\n    - !!java.lang.Object\nproviders:\n    - name: zingbat\n      '''\n    static final String TEST_YAML4='''name: plugin-name\nversion: 1.0\nrundeckPluginVersion: 1.2\ntags:\n    - !!java.lang.Object\nproviders:\n    - name: zingbat\n      '''\n\n    def \"LoadMetadataYaml unsafe\"() {\n        setup:\n            File tmpCacheDir = File.createTempDir()\n            ScriptPluginProviderLoader loader = new ScriptPluginProviderLoader(File.createTempFile(\"throwaway\",\"unneeded\"),tmpCacheDir)\n            def pluginYaml =  new ByteArrayInputStream(testYaml.bytes)\n        when: \"load yaml with java class tags\"\n            def meta = loader.loadMetadataYaml(pluginYaml)\n\n        then: \"should throw exception\"\n            YAMLException e = thrown()\n            e.message.contains 'could not determine a constructor for the tag tag:yaml.org,2002:java.lang.Object'\n        where:\n            testYaml<<[\n                TEST_YAML1,\n                TEST_YAML2,\n                TEST_YAML3,\n                TEST_YAML4,\n            ]\n    }\n\n    @Unroll\n    def \"ValidatePluginMeta\"() {\n        setup:\n        File fakeFile = new File(\"/tmp/fake-plugin.yaml\")\n        when:\n\n        def validation = ScriptPluginProviderLoader.validatePluginMeta(new PluginMeta(pluginMeta),fakeFile)\n\n        then:\n        logResult == validation.messages\n        validation.state.valid == expectation\n        validation.state == state\n\n        where:\n        expectation |state                                                                             | pluginMeta | logResult\n        false       |INVALID| [rundeckPluginVersion: \"1.2\", pluginDefs: []] | [\"'name' not found in metadata\", \"'version' not found in metadata\"]\n        false       |INVALID| [name:\"Test script\",rundeckPluginVersion: \"1.2\", pluginDefs: []]                | [\"'version' not found in metadata\"]\n        true        |VALID| [name:\"Test script\",rundeckPluginVersion: \"1.2\", version:\"1.0\", pluginDefs: []] | []\n        false       |INVALID| [name:\"Test script\",rundeckPluginVersion: \"2.0\", version:\"1.0\", pluginDefs: []] | [\"No targetHostCompatibility property specified in metadata\",\"rundeckCompatibilityVersion cannot be null in metadata\"]\n        false       |INVALID| [name:\"Test script\",rundeckPluginVersion: \"2.0\", version:\"1.0\", targetHostCompatibility:\"all\", pluginDefs: []] | [\"rundeckCompatibilityVersion cannot be null in metadata\"]\n        false       |INCOMPATIBLE| [name:\"Test script\",rundeckPluginVersion: \"2.0\", version:\"1.0\", targetHostCompatibility:\"all\", rundeckCompatibilityVersion:\"1.0\", pluginDefs: []] | [\"Plugin is not compatible with this version of Rundeck\"]\n        true        |VALID| [name:\"Test script\",rundeckPluginVersion: \"2.0\", version:\"1.0\", targetHostCompatibility:\"all\", rundeckCompatibilityVersion:\"3.x\", pluginDefs: []] | []\n        true        |VALID| [name:\"test-script\",display:\"Test script\",rundeckPluginVersion: \"2.0\", version:\"1.0\", targetHostCompatibility:\"all\", rundeckCompatibilityVersion:\"3.x\", pluginDefs: []] | []\n\n    }\n\n\n    /**\n     * create yaml stream\n     * @param pluginName `name` value\n     * @param pluginVersion `rundeckPluginVersion` value\n     * @param props additional yaml structure\n     * @return inputstream of yaml string representing the structure\n     */\n    ByteArrayInputStream createPluginYaml(String pluginName, String pluginVersion, Map props = [:]) {\n        Yaml yaml = new Yaml()\n        def map = [name:pluginName,rundeckPluginVersion: pluginVersion] + props\n        def writer=new StringWriter()\n        yaml.dump(map,writer)\n        new ByteArrayInputStream(writer.toString().bytes)\n    }\n}\n"], "filenames": ["core/src/main/java/com/dtolabs/rundeck/core/plugins/ScriptPluginProviderLoader.java", "core/src/test/groovy/com/dtolabs/rundeck/core/plugins/ScriptPluginProviderLoaderTest.groovy"], "buggy_code_start_loc": [19, 18], "buggy_code_end_loc": [403, 97], "fixing_code_start_loc": [19, 19], "fixing_code_end_loc": [418, 255], "type": "CWE-502", "message": "Rundeck is an open source automation service with a web console, command line tools and a WebAPI. Prior to version 3.3.14 and version 3.4.3, an authorized user can upload a zip-format plugin with a crafted plugin.yaml, or a crafted aclpolicy yaml file, or upload an untrusted project archive with a crafted aclpolicy yaml file, that can cause the server to run untrusted code on Rundeck Community or Enterprise Edition. An authenticated user can make a POST request, that can cause the server to run untrusted code on Rundeck Enterprise Edition. The zip-format plugin issues requires authentication and authorization to these access levels, and affects all Rundeck editions:`admin` level access to the `system` resource type. The ACL Policy yaml file upload issues requires authentication and authorization to these access levels, and affects all Rundeck editions: `create` `update` or `admin` level access to a `project_acl` resource, and/or`create` `update` or `admin` level access to the `system_acl` resource. The unauthorized POST request requires authentication, but no specific authorization, and affects Rundeck Enterprise only. Patches are available in versions 3.4.3, 3.3.14", "other": {"cve": {"id": "CVE-2021-39132", "sourceIdentifier": "security-advisories@github.com", "published": "2021-08-30T20:15:07.660", "lastModified": "2021-09-08T15:08:51.240", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Rundeck is an open source automation service with a web console, command line tools and a WebAPI. Prior to version 3.3.14 and version 3.4.3, an authorized user can upload a zip-format plugin with a crafted plugin.yaml, or a crafted aclpolicy yaml file, or upload an untrusted project archive with a crafted aclpolicy yaml file, that can cause the server to run untrusted code on Rundeck Community or Enterprise Edition. An authenticated user can make a POST request, that can cause the server to run untrusted code on Rundeck Enterprise Edition. The zip-format plugin issues requires authentication and authorization to these access levels, and affects all Rundeck editions:`admin` level access to the `system` resource type. The ACL Policy yaml file upload issues requires authentication and authorization to these access levels, and affects all Rundeck editions: `create` `update` or `admin` level access to a `project_acl` resource, and/or`create` `update` or `admin` level access to the `system_acl` resource. The unauthorized POST request requires authentication, but no specific authorization, and affects Rundeck Enterprise only. Patches are available in versions 3.4.3, 3.3.14"}, {"lang": "es", "value": "Rundeck es un servicio de automatizaci\u00f3n de c\u00f3digo abierto con una consola web, herramientas de l\u00ednea de comandos y una WebAPI. Antes de la versi\u00f3n 3.3.14 y la versi\u00f3n 3.4.3, un usuario autorizado puede subir un plugin en formato zip con un plugin.yaml manipulado, o un archivo aclpolicy yaml manipulado, o subir un archivo de proyecto no fiable con un archivo aclpolicy yaml manipulado, que puede hacer que el servidor ejecute c\u00f3digo no fiable en Rundeck Community o Enterprise Edition. Un usuario autenticado puede realizar una solicitud POST, que puede hacer que el servidor ejecute c\u00f3digo no fiable en Rundeck Enterprise Edition. Los problemas del plugin zip-format requieren autenticaci\u00f3n y autorizaci\u00f3n a estos niveles de acceso, y afecta a todas las ediciones de Rundeck:Nivel de acceso `admin` al tipo de recurso `system`. Los problemas de carga de archivos yaml de la pol\u00edtica ACL requieren autenticaci\u00f3n y autorizaci\u00f3n para estos niveles de acceso, y afectan a todas las ediciones de Rundeck: Acceso de nivel `create` `update` o `admin` a un recurso `project_acl`, y/o acceso de nivel `create` `update` o `admin` al recurso `system_acl`. La solicitud POST no autorizada requiere autenticaci\u00f3n, pero no una autorizaci\u00f3n espec\u00edfica, y s\u00f3lo afecta a Rundeck Enterprise. Los parches est\u00e1n disponibles en las versiones 3.4.3, 3.3.14"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-502"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-502"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pagerduty:rundeck:*:*:*:*:community:*:*:*", "versionEndExcluding": "3.3.14", "matchCriteriaId": "7787AC9A-C31F-4056-AAC6-8B332F794A65"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pagerduty:rundeck:*:*:*:*:enterprise:*:*:*", "versionEndExcluding": "3.3.14", "matchCriteriaId": "8A3A2C19-3665-40E3-A3C1-06CD1AB8BFD6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pagerduty:rundeck:*:*:*:*:community:*:*:*", "versionStartIncluding": "3.4.0", "versionEndExcluding": "3.4.3", "matchCriteriaId": "C7884A6F-2CE1-4BD0-B799-7C8D637C1AEF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pagerduty:rundeck:*:*:*:*:enterprise:*:*:*", "versionStartIncluding": "3.4.0", "versionEndExcluding": "3.4.3", "matchCriteriaId": "FC710C1B-24D8-4036-B34D-E4CAA3A8F262"}]}]}], "references": [{"url": "https://github.com/rundeck/rundeck/commit/850d12e21d22833bc148b7f458d7cb5949f829b6", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/rundeck/rundeck/security/advisories/GHSA-q4rf-3fhx-88pf", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/rundeck/rundeck/commit/850d12e21d22833bc148b7f458d7cb5949f829b6"}}