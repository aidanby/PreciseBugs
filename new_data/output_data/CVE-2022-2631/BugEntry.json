{"buggy_code": ["import { Injectable, InternalServerErrorException } from '@nestjs/common';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { User } from '../entities/user.entity';\nimport { FilesService } from '../services/files.service';\nimport { App } from 'src/entities/app.entity';\nimport { Connection, createQueryBuilder, EntityManager, getManager, getRepository, In, Repository } from 'typeorm';\nimport { OrganizationUser } from '../entities/organization_user.entity';\nimport { AppGroupPermission } from 'src/entities/app_group_permission.entity';\nimport { UserGroupPermission } from 'src/entities/user_group_permission.entity';\nimport { GroupPermission } from 'src/entities/group_permission.entity';\nimport { BadRequestException } from '@nestjs/common';\nimport { cleanObject } from 'src/helpers/utils.helper';\nimport { CreateFileDto } from '@dto/create-file.dto';\nconst uuid = require('uuid');\nconst bcrypt = require('bcrypt');\n\n@Injectable()\nexport class UsersService {\n  constructor(\n    private readonly filesService: FilesService,\n    private connection: Connection,\n    @InjectRepository(User)\n    private usersRepository: Repository<User>,\n    @InjectRepository(OrganizationUser)\n    private organizationUsersRepository: Repository<OrganizationUser>,\n    @InjectRepository(App)\n    private appsRepository: Repository<App>\n  ) {}\n\n  async findOne(id: string): Promise<User> {\n    return this.usersRepository.findOne({ where: { id } });\n  }\n\n  async findByEmail(email: string, organisationId?: string, status?: string | Array<string>): Promise<User> {\n    if (!organisationId) {\n      return this.usersRepository.findOne({\n        where: { email },\n      });\n    } else {\n      const statusList = status ? (typeof status === 'object' ? status : [status]) : ['active', 'invited', 'archived'];\n      return await createQueryBuilder(User, 'users')\n        .innerJoinAndSelect(\n          'users.organizationUsers',\n          'organization_users',\n          'organization_users.organizationId = :organisationId',\n          { organisationId }\n        )\n        .where('organization_users.status IN(:...statusList)', {\n          statusList,\n        })\n        .andWhere('users.email = :email', { email })\n        .getOne();\n    }\n  }\n\n  async findByPasswordResetToken(token: string): Promise<User> {\n    return this.usersRepository.findOne({\n      where: { forgotPasswordToken: token },\n    });\n  }\n\n  async create(\n    userParams: any,\n    organizationId: string,\n    groups?: string[],\n    existingUser?: User,\n    isInvite?: boolean,\n    defaultOrganizationId?: string\n  ): Promise<User> {\n    const password = uuid.v4();\n\n    const { email, firstName, lastName } = userParams;\n    let user: User;\n\n    await getManager().transaction(async (manager) => {\n      if (!existingUser) {\n        user = manager.create(User, {\n          email,\n          firstName,\n          lastName,\n          password,\n          invitationToken: isInvite ? uuid.v4() : null,\n          defaultOrganizationId: defaultOrganizationId || organizationId,\n          createdAt: new Date(),\n          updatedAt: new Date(),\n        });\n        await manager.save(user);\n      } else {\n        user = existingUser;\n      }\n    });\n\n    await this.attachUserGroup(groups, organizationId, user.id);\n\n    return user;\n  }\n\n  async attachUserGroup(groups, organizationId, userId) {\n    await getManager().transaction(async (manager) => {\n      for (const group of groups) {\n        const orgGroupPermission = await manager.findOne(GroupPermission, {\n          where: {\n            organizationId: organizationId,\n            group: group,\n          },\n        });\n\n        if (orgGroupPermission) {\n          const userGroupPermission = manager.create(UserGroupPermission, {\n            groupPermissionId: orgGroupPermission.id,\n            userId: userId,\n          });\n          await manager.save(userGroupPermission);\n        } else {\n          throw new BadRequestException(`${group} group does not exist for current organization`);\n        }\n      }\n    });\n  }\n\n  async findOrCreateByEmail(userParams: any, organizationId: string): Promise<{ user: User; newUserCreated: boolean }> {\n    let user: User;\n    let newUserCreated = false;\n\n    user = await this.findByEmail(userParams.email);\n\n    if (user?.organizationUsers?.some((ou) => ou.organizationId === organizationId)) {\n      // User exist in current organization\n      return { user, newUserCreated };\n    }\n\n    const groups = ['all_users'];\n    user = await this.create({ ...userParams }, organizationId, groups, user);\n    newUserCreated = true;\n\n    return { user, newUserCreated };\n  }\n\n  async updateDefaultOrganization(user: User, organizationId: string) {\n    await this.usersRepository.update(user.id, { defaultOrganizationId: organizationId });\n  }\n\n  async update(userId: string, params: any, manager?: EntityManager, organizationId?: string) {\n    const { forgotPasswordToken, password, firstName, lastName, addGroups, removeGroups } = params;\n\n    const hashedPassword = password ? bcrypt.hashSync(password, 10) : undefined;\n\n    const updatableParams = {\n      forgotPasswordToken,\n      firstName,\n      lastName,\n      password: hashedPassword,\n    };\n\n    // removing keys with undefined values\n    cleanObject(updatableParams);\n\n    await this.updateUser(userId, updatableParams);\n    const user = await this.findOne(userId);\n\n    const performUpdateInTransaction = async (manager) => {\n      await this.removeUserGroupPermissionsIfExists(manager, user, removeGroups, organizationId);\n      await this.addUserGroupPermissions(manager, user, addGroups, organizationId);\n    };\n\n    if (manager) {\n      await performUpdateInTransaction(manager);\n    } else {\n      await getManager().transaction(async (manager) => {\n        await performUpdateInTransaction(manager);\n      });\n    }\n\n    return user;\n  }\n\n  async updateUser(userId, updatableParams) {\n    await this.usersRepository.update(userId, updatableParams);\n  }\n\n  async addUserGroupPermissions(manager: EntityManager, user: User, addGroups: string[], organizationId?: string) {\n    const orgId = organizationId || user.defaultOrganizationId;\n    if (addGroups) {\n      const orgGroupPermissions = await this.groupPermissionsForOrganization(orgId);\n\n      for (const group of addGroups) {\n        const orgGroupPermission = orgGroupPermissions.find((permission) => permission.group == group);\n\n        if (orgGroupPermission) {\n          const userGroupPermission = manager.create(UserGroupPermission, {\n            groupPermissionId: orgGroupPermission.id,\n            userId: user.id,\n          });\n          await manager.save(userGroupPermission);\n        } else {\n          throw new BadRequestException(`${group} group does not exist for current organization`);\n        }\n      }\n    }\n  }\n\n  async removeUserGroupPermissionsIfExists(\n    manager: EntityManager,\n    user: User,\n    removeGroups: string[],\n    organizationId?: string\n  ) {\n    const orgId = organizationId || user.defaultOrganizationId;\n    if (removeGroups) {\n      await this.throwErrorIfRemovingLastActiveAdmin(user, removeGroups, orgId);\n      if (removeGroups.includes('all_users')) {\n        throw new BadRequestException('Cannot remove user from default group.');\n      }\n\n      const groupPermissions = await manager.find(GroupPermission, {\n        group: In(removeGroups),\n        organizationId: orgId,\n      });\n      const groupIdsToMaybeRemove = groupPermissions.map((permission) => permission.id);\n\n      await manager.delete(UserGroupPermission, {\n        groupPermissionId: In(groupIdsToMaybeRemove),\n        userId: user.id,\n      });\n    }\n  }\n\n  async throwErrorIfRemovingLastActiveAdmin(user: User, removeGroups: string[] = ['admin'], organizationId: string) {\n    const removingAdmin = removeGroups.includes('admin');\n    if (!removingAdmin) return;\n\n    const result = await createQueryBuilder(User, 'users')\n      .innerJoin('users.groupPermissions', 'group_permissions')\n      .innerJoin('users.organizationUsers', 'organization_users')\n      .where('organization_users.user_id != :userId', { userId: user.id })\n      .andWhere('organization_users.status = :status', { status: 'active' })\n      .andWhere('group_permissions.group = :group', { group: 'admin' })\n      .andWhere('group_permissions.organization_id = :organizationId', {\n        organizationId,\n      })\n      .getCount();\n\n    if (result == 0) throw new BadRequestException('Atleast one active admin is required.');\n  }\n\n  async hasGroup(user: User, group: string, organizationId?: string): Promise<boolean> {\n    const orgId = organizationId || user.organizationId;\n\n    const result = await createQueryBuilder(GroupPermission, 'group_permissions')\n      .innerJoin('group_permissions.userGroupPermission', 'user_group_permissions')\n      .where('group_permissions.organization_id = :organizationId', {\n        organizationId: orgId,\n      })\n      .andWhere('group_permissions.group = :group ', { group })\n      .andWhere('user_group_permissions.user_id = :userId', { userId: user.id })\n      .getCount();\n\n    return result > 0;\n  }\n\n  async userCan(user: User, action: string, entityName: string, resourceId?: string): Promise<boolean> {\n    switch (entityName) {\n      case 'App':\n        return await this.canUserPerformActionOnApp(user, action, resourceId);\n\n      case 'User':\n        return await this.hasGroup(user, 'admin');\n\n      case 'Thread':\n      case 'Comment':\n        return await this.canUserPerformActionOnApp(user, 'update', resourceId);\n\n      case 'Folder':\n        return await this.canUserPerformActionOnFolder(user, action);\n\n      default:\n        return false;\n    }\n  }\n\n  async canUserPerformActionOnApp(user: User, action: string, appId?: string): Promise<boolean> {\n    let permissionGrant: boolean;\n\n    switch (action) {\n      case 'create':\n        permissionGrant = this.canAnyGroupPerformAction('appCreate', await this.groupPermissions(user));\n        break;\n      case 'read':\n      case 'update':\n        permissionGrant =\n          this.canAnyGroupPerformAction(action, await this.appGroupPermissions(user, appId)) ||\n          (await this.isUserOwnerOfApp(user, appId));\n        break;\n      case 'delete':\n        permissionGrant =\n          this.canAnyGroupPerformAction('delete', await this.appGroupPermissions(user, appId)) ||\n          this.canAnyGroupPerformAction('appDelete', await this.groupPermissions(user)) ||\n          (await this.isUserOwnerOfApp(user, appId));\n        break;\n      default:\n        permissionGrant = false;\n        break;\n    }\n\n    return permissionGrant;\n  }\n\n  async canUserPerformActionOnFolder(user: User, action: string): Promise<boolean> {\n    let permissionGrant: boolean;\n\n    switch (action) {\n      case 'create':\n        permissionGrant = this.canAnyGroupPerformAction('folderCreate', await this.groupPermissions(user));\n        break;\n      default:\n        permissionGrant = false;\n        break;\n    }\n\n    return permissionGrant;\n  }\n\n  async isUserOwnerOfApp(user: User, appId: string): Promise<boolean> {\n    const app: App = await this.appsRepository.findOne({\n      where: {\n        id: appId,\n        userId: user.id,\n      },\n    });\n    return !!app && app.organizationId === user.organizationId;\n  }\n\n  async addAvatar(userId: number, imageBuffer: Buffer, filename: string) {\n    const queryRunner = this.connection.createQueryRunner();\n\n    await queryRunner.connect();\n    await queryRunner.startTransaction();\n\n    try {\n      const user = await queryRunner.manager.findOne(User, userId);\n      const currentAvatarId = user.avatarId;\n      const createFileDto = new CreateFileDto();\n      createFileDto.filename = filename;\n      createFileDto.data = imageBuffer;\n      const avatar = await this.filesService.create(createFileDto, queryRunner);\n\n      await queryRunner.manager.update(User, userId, {\n        avatarId: avatar.id,\n      });\n\n      if (currentAvatarId) {\n        await this.filesService.remove(currentAvatarId, queryRunner);\n      }\n\n      await queryRunner.commitTransaction();\n\n      return avatar;\n    } catch (error) {\n      await queryRunner.rollbackTransaction();\n      throw new InternalServerErrorException(error);\n    } finally {\n      await queryRunner.release();\n    }\n  }\n\n  canAnyGroupPerformAction(action: string, permissions: AppGroupPermission[] | GroupPermission[]): boolean {\n    return permissions.some((p) => p[action]);\n  }\n\n  async groupPermissions(user: User): Promise<GroupPermission[]> {\n    const orgUserGroupPermissions = await this.userGroupPermissions(user, user.organizationId);\n    const groupIds = orgUserGroupPermissions.map((p) => p.groupPermissionId);\n    const groupPermissionRepository = getRepository(GroupPermission);\n\n    return await groupPermissionRepository.findByIds(groupIds);\n  }\n\n  async groupPermissionsForOrganization(organizationId: string) {\n    const groupPermissionRepository = getRepository(GroupPermission);\n\n    return await groupPermissionRepository.find({ organizationId });\n  }\n\n  async appGroupPermissions(user: User, appId?: string): Promise<AppGroupPermission[]> {\n    const orgUserGroupPermissions = await this.userGroupPermissions(user, user.organizationId);\n    const groupIds = orgUserGroupPermissions.map((p) => p.groupPermissionId);\n\n    if (!groupIds || groupIds.length === 0) {\n      return [];\n    }\n\n    const query = createQueryBuilder(AppGroupPermission, 'app_group_permissions')\n      .innerJoin(\n        'app_group_permissions.groupPermission',\n        'group_permissions',\n        'group_permissions.organization_id = :organizationId',\n        {\n          organizationId: user.organizationId,\n        }\n      )\n      .where('app_group_permissions.groupPermissionId IN (:...groupIds)', { groupIds });\n\n    if (appId) {\n      query.andWhere('app_group_permissions.appId = :appId', { appId });\n    }\n    return await query.getMany();\n  }\n\n  async userGroupPermissions(user: User, organizationId?: string): Promise<UserGroupPermission[]> {\n    const orgId = organizationId || user.organizationId;\n\n    return await createQueryBuilder(UserGroupPermission, 'user_group_permissions')\n      .innerJoin('user_group_permissions.groupPermission', 'group_permissions')\n      .where('group_permissions.organization_id = :organizationId', {\n        organizationId: orgId,\n      })\n      .andWhere('user_group_permissions.user_id = :userId', { userId: user.id })\n      .getMany();\n  }\n}\n", "/* eslint-disable @typescript-eslint/no-unused-vars */\nimport * as request from 'supertest';\nimport { BadRequestException, INestApplication } from '@nestjs/common';\nimport { authHeaderForUser, clearDB, createUser, createNestAppInstance } from '../test.helper';\n\ndescribe('organization users controller', () => {\n  let app: INestApplication;\n\n  beforeEach(async () => {\n    await clearDB();\n  });\n\n  beforeAll(async () => {\n    app = await createNestAppInstance();\n  });\n\n  it('should allow only admin to be able to invite new users', async () => {\n    // setup a pre existing user of different organization\n    await createUser(app, {\n      email: 'someUser@tooljet.io',\n      groups: ['admin', 'all_users'],\n    });\n\n    // setup organization and user setup to test against\n    const adminUserData = await createUser(app, {\n      email: 'admin@tooljet.io',\n      groups: ['admin', 'all_users'],\n    });\n\n    const organization = adminUserData.organization;\n\n    const developerUserData = await createUser(app, {\n      email: 'developer@tooljet.io',\n      groups: ['developer', 'all_users'],\n      organization,\n    });\n\n    const viewerUserData = await createUser(app, {\n      email: 'viewer@tooljet.io',\n      groups: ['viewer', 'all_users'],\n      organization,\n    });\n\n    await request(app.getHttpServer())\n      .post(`/api/organization_users/`)\n      .set('Authorization', authHeaderForUser(adminUserData.user))\n      .send({ email: 'test@tooljet.io' })\n      .expect(201);\n\n    await request(app.getHttpServer())\n      .post(`/api/organization_users/`)\n      .set('Authorization', authHeaderForUser(developerUserData.user))\n      .send({ email: 'test2@tooljet.io' })\n      .expect(403);\n\n    await request(app.getHttpServer())\n      .post(`/api/organization_users/`)\n      .set('Authorization', authHeaderForUser(viewerUserData.user))\n      .send({ email: 'test3@tooljet.io' })\n      .expect(403);\n  });\n\n  describe('POST /api/organization_users/:id/archive', () => {\n    it('should allow only authenticated users to archive org users', async () => {\n      await request(app.getHttpServer()).post('/api/organization_users/random-id/archive/').expect(401);\n    });\n\n    it('should throw error when trying to remove last active admin', async () => {\n      const adminUserData = await createUser(app, {\n        email: 'admin@tooljet.io',\n        groups: ['admin', 'all_users'],\n        status: 'active',\n      });\n      const organization = adminUserData.organization;\n      const anotherAdminUserData = await createUser(app, {\n        email: 'another-admin@tooljet.io',\n        groups: ['admin', 'all_users'],\n        status: 'active',\n        organization,\n      });\n\n      const _archivedAdmin = await createUser(app, {\n        email: 'archived-admin@tooljet.io',\n        groups: ['admin', 'all_users'],\n        status: 'archived',\n        organization,\n      });\n\n      await request(app.getHttpServer())\n        .post(`/api/organization_users/${anotherAdminUserData.orgUser.id}/archive/`)\n        .set('Authorization', authHeaderForUser(adminUserData.user))\n        .expect(201);\n\n      const response = await request(app.getHttpServer())\n        .post(`/api/organization_users/${adminUserData.orgUser.id}/archive/`)\n        .set('Authorization', authHeaderForUser(adminUserData.user));\n\n      expect(response.statusCode).toEqual(400);\n      expect(response.body.message).toEqual('Atleast one active admin is required.');\n    });\n\n    it('should allow only admin users to archive org users', async () => {\n      const adminUserData = await createUser(app, {\n        email: 'admin@tooljet.io',\n        groups: ['admin', 'all_users'],\n      });\n      const organization = adminUserData.organization;\n      const developerUserData = await createUser(app, {\n        email: 'developer@tooljet.io',\n        groups: ['developer', 'all_users'],\n        organization,\n      });\n      const viewerUserData = await createUser(app, {\n        email: 'viewer@tooljet.io',\n        groups: ['viewer', 'all_users'],\n        organization,\n        status: 'invited',\n      });\n\n      await request(app.getHttpServer())\n        .post(`/api/organization_users/${viewerUserData.orgUser.id}/archive/`)\n        .set('Authorization', authHeaderForUser(developerUserData.user))\n        .expect(403);\n\n      await viewerUserData.orgUser.reload();\n      expect(viewerUserData.orgUser.status).toBe('invited');\n\n      await request(app.getHttpServer())\n        .post(`/api/organization_users/${viewerUserData.orgUser.id}/archive/`)\n        .set('Authorization', authHeaderForUser(adminUserData.user))\n        .expect(201);\n\n      await viewerUserData.orgUser.reload();\n      expect(viewerUserData.orgUser.status).toBe('archived');\n    });\n  });\n\n  describe('POST /api/organization_users/:id/unarchive', () => {\n    it('should allow only authenticated users to unarchive org users', async () => {\n      await request(app.getHttpServer()).post('/api/organization_users/random-id/unarchive/').expect(401);\n    });\n\n    it('should allow only admin users to unarchive org users', async () => {\n      const adminUserData = await createUser(app, {\n        email: 'admin@tooljet.io',\n        status: 'active',\n        groups: ['admin', 'all_users'],\n      });\n      const organization = adminUserData.organization;\n      const developerUserData = await createUser(app, {\n        email: 'developer@tooljet.io',\n        status: 'active',\n        groups: ['developer', 'all_users'],\n        organization,\n      });\n      const viewerUserData = await createUser(app, {\n        email: 'viewer@tooljet.io',\n        status: 'archived',\n        groups: ['viewer', 'all_users'],\n        organization,\n      });\n\n      await request(app.getHttpServer())\n        .post(`/api/organization_users/${viewerUserData.orgUser.id}/unarchive/`)\n        .set('Authorization', authHeaderForUser(developerUserData.user))\n        .expect(403);\n\n      await viewerUserData.orgUser.reload();\n      expect(viewerUserData.orgUser.status).toBe('archived');\n\n      await request(app.getHttpServer())\n        .post(`/api/organization_users/${viewerUserData.orgUser.id}/unarchive/`)\n        .set('Authorization', authHeaderForUser(developerUserData.user))\n        .expect(403);\n\n      await viewerUserData.orgUser.reload();\n      expect(viewerUserData.orgUser.status).toBe('archived');\n\n      await request(app.getHttpServer())\n        .post(`/api/organization_users/${viewerUserData.orgUser.id}/unarchive/`)\n        .set('Authorization', authHeaderForUser(adminUserData.user))\n        .expect(201);\n\n      await viewerUserData.orgUser.reload();\n      await viewerUserData.user.reload();\n      expect(viewerUserData.orgUser.status).toBe('invited');\n      expect(viewerUserData.user.invitationToken).not.toBe('');\n      expect(viewerUserData.user.password).not.toBe('old-password');\n    });\n\n    it('should allow unarchive if user is already archived', async () => {\n      const adminUserData = await createUser(app, {\n        email: 'admin@tooljet.io',\n        status: 'active',\n        groups: ['admin', 'all_users'],\n      });\n      const organization = adminUserData.organization;\n      const developerUserData = await createUser(app, {\n        email: 'developer@tooljet.io',\n        status: 'active',\n        groups: ['developer', 'all_users'],\n        organization,\n      });\n\n      await request(app.getHttpServer())\n        .post(`/api/organization_users/${developerUserData.orgUser.id}/unarchive/`)\n        .set('Authorization', authHeaderForUser(adminUserData.user))\n        .expect(201);\n\n      await developerUserData.orgUser.reload();\n      expect(developerUserData.orgUser.status).toBe('active');\n    });\n  });\n\n  afterAll(async () => {\n    await app.close();\n  });\n});\n"], "fixing_code": ["import { Injectable, InternalServerErrorException } from '@nestjs/common';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { User } from '../entities/user.entity';\nimport { FilesService } from '../services/files.service';\nimport { App } from 'src/entities/app.entity';\nimport { Connection, createQueryBuilder, EntityManager, getManager, getRepository, In, Repository } from 'typeorm';\nimport { OrganizationUser } from '../entities/organization_user.entity';\nimport { AppGroupPermission } from 'src/entities/app_group_permission.entity';\nimport { UserGroupPermission } from 'src/entities/user_group_permission.entity';\nimport { GroupPermission } from 'src/entities/group_permission.entity';\nimport { BadRequestException } from '@nestjs/common';\nimport { cleanObject } from 'src/helpers/utils.helper';\nimport { CreateFileDto } from '@dto/create-file.dto';\nconst uuid = require('uuid');\nconst bcrypt = require('bcrypt');\n\n@Injectable()\nexport class UsersService {\n  constructor(\n    private readonly filesService: FilesService,\n    private connection: Connection,\n    @InjectRepository(User)\n    private usersRepository: Repository<User>,\n    @InjectRepository(OrganizationUser)\n    private organizationUsersRepository: Repository<OrganizationUser>,\n    @InjectRepository(App)\n    private appsRepository: Repository<App>\n  ) {}\n\n  async findOne(id: string): Promise<User> {\n    return this.usersRepository.findOne({ where: { id } });\n  }\n\n  async findByEmail(email: string, organisationId?: string, status?: string | Array<string>): Promise<User> {\n    if (!organisationId) {\n      return this.usersRepository.findOne({\n        where: { email },\n      });\n    } else {\n      const statusList = status ? (typeof status === 'object' ? status : [status]) : ['active', 'invited', 'archived'];\n      return await createQueryBuilder(User, 'users')\n        .innerJoinAndSelect(\n          'users.organizationUsers',\n          'organization_users',\n          'organization_users.organizationId = :organisationId',\n          { organisationId }\n        )\n        .where('organization_users.status IN(:...statusList)', {\n          statusList,\n        })\n        .andWhere('users.email = :email', { email })\n        .getOne();\n    }\n  }\n\n  async findByPasswordResetToken(token: string): Promise<User> {\n    return this.usersRepository.findOne({\n      where: { forgotPasswordToken: token },\n    });\n  }\n\n  async create(\n    userParams: any,\n    organizationId: string,\n    groups?: string[],\n    existingUser?: User,\n    isInvite?: boolean,\n    defaultOrganizationId?: string\n  ): Promise<User> {\n    const password = uuid.v4();\n\n    const { email, firstName, lastName } = userParams;\n    let user: User;\n\n    await getManager().transaction(async (manager) => {\n      if (!existingUser) {\n        user = manager.create(User, {\n          email,\n          firstName,\n          lastName,\n          password,\n          invitationToken: isInvite ? uuid.v4() : null,\n          defaultOrganizationId: defaultOrganizationId || organizationId,\n          createdAt: new Date(),\n          updatedAt: new Date(),\n        });\n        await manager.save(user);\n      } else {\n        user = existingUser;\n      }\n    });\n\n    await this.attachUserGroup(groups, organizationId, user.id);\n\n    return user;\n  }\n\n  async attachUserGroup(groups, organizationId, userId) {\n    await getManager().transaction(async (manager) => {\n      for (const group of groups) {\n        const orgGroupPermission = await manager.findOne(GroupPermission, {\n          where: {\n            organizationId: organizationId,\n            group: group,\n          },\n        });\n\n        if (orgGroupPermission) {\n          const userGroupPermission = manager.create(UserGroupPermission, {\n            groupPermissionId: orgGroupPermission.id,\n            userId: userId,\n          });\n          await manager.save(userGroupPermission);\n        } else {\n          throw new BadRequestException(`${group} group does not exist for current organization`);\n        }\n      }\n    });\n  }\n\n  async findOrCreateByEmail(userParams: any, organizationId: string): Promise<{ user: User; newUserCreated: boolean }> {\n    let user: User;\n    let newUserCreated = false;\n\n    user = await this.findByEmail(userParams.email);\n\n    if (user?.organizationUsers?.some((ou) => ou.organizationId === organizationId)) {\n      // User exist in current organization\n      return { user, newUserCreated };\n    }\n\n    const groups = ['all_users'];\n    user = await this.create({ ...userParams }, organizationId, groups, user);\n    newUserCreated = true;\n\n    return { user, newUserCreated };\n  }\n\n  async updateDefaultOrganization(user: User, organizationId: string) {\n    await this.usersRepository.update(user.id, { defaultOrganizationId: organizationId });\n  }\n\n  async update(userId: string, params: any, manager?: EntityManager, organizationId?: string) {\n    const { forgotPasswordToken, password, firstName, lastName, addGroups, removeGroups } = params;\n\n    const hashedPassword = password ? bcrypt.hashSync(password, 10) : undefined;\n\n    const updatableParams = {\n      forgotPasswordToken,\n      firstName,\n      lastName,\n      password: hashedPassword,\n    };\n\n    // removing keys with undefined values\n    cleanObject(updatableParams);\n\n    let user: User;\n\n    const performUpdateInTransaction = async (manager) => {\n      await manager.update(User, userId, updatableParams);\n      user = await manager.findOne(User, { where: { id: userId } });\n      await this.removeUserGroupPermissionsIfExists(manager, user, removeGroups, organizationId);\n      await this.addUserGroupPermissions(manager, user, addGroups, organizationId);\n    };\n\n    if (manager) {\n      await performUpdateInTransaction(manager);\n    } else {\n      await getManager().transaction(async (manager) => {\n        await performUpdateInTransaction(manager);\n      });\n    }\n\n    return user;\n  }\n\n  async updateUser(userId, updatableParams) {\n    await this.usersRepository.update(userId, updatableParams);\n  }\n\n  async addUserGroupPermissions(manager: EntityManager, user: User, addGroups: string[], organizationId?: string) {\n    const orgId = organizationId || user.defaultOrganizationId;\n    if (addGroups) {\n      const orgGroupPermissions = await this.groupPermissionsForOrganization(orgId);\n\n      for (const group of addGroups) {\n        const orgGroupPermission = orgGroupPermissions.find((permission) => permission.group == group);\n\n        if (orgGroupPermission) {\n          const userGroupPermission = manager.create(UserGroupPermission, {\n            groupPermissionId: orgGroupPermission.id,\n            userId: user.id,\n          });\n          await manager.save(userGroupPermission);\n        } else {\n          throw new BadRequestException(`${group} group does not exist for current organization`);\n        }\n      }\n    }\n  }\n\n  async removeUserGroupPermissionsIfExists(\n    manager: EntityManager,\n    user: User,\n    removeGroups: string[],\n    organizationId?: string\n  ) {\n    const orgId = organizationId || user.defaultOrganizationId;\n    if (removeGroups) {\n      await this.throwErrorIfRemovingLastActiveAdmin(user, removeGroups, orgId);\n      if (removeGroups.includes('all_users')) {\n        throw new BadRequestException('Cannot remove user from default group.');\n      }\n\n      const groupPermissions = await manager.find(GroupPermission, {\n        group: In(removeGroups),\n        organizationId: orgId,\n      });\n      const groupIdsToMaybeRemove = groupPermissions.map((permission) => permission.id);\n\n      await manager.delete(UserGroupPermission, {\n        groupPermissionId: In(groupIdsToMaybeRemove),\n        userId: user.id,\n      });\n    }\n  }\n\n  async throwErrorIfRemovingLastActiveAdmin(user: User, removeGroups: string[] = ['admin'], organizationId: string) {\n    const removingAdmin = removeGroups.includes('admin');\n    if (!removingAdmin) return;\n\n    const result = await createQueryBuilder(User, 'users')\n      .innerJoin('users.groupPermissions', 'group_permissions')\n      .innerJoin('users.organizationUsers', 'organization_users')\n      .where('organization_users.user_id != :userId', { userId: user.id })\n      .andWhere('organization_users.status = :status', { status: 'active' })\n      .andWhere('group_permissions.group = :group', { group: 'admin' })\n      .andWhere('group_permissions.organization_id = :organizationId', {\n        organizationId,\n      })\n      .getCount();\n\n    if (result == 0) throw new BadRequestException('Atleast one active admin is required.');\n  }\n\n  async hasGroup(user: User, group: string, organizationId?: string): Promise<boolean> {\n    const orgId = organizationId || user.organizationId;\n\n    const result = await createQueryBuilder(GroupPermission, 'group_permissions')\n      .innerJoin('group_permissions.userGroupPermission', 'user_group_permissions')\n      .where('group_permissions.organization_id = :organizationId', {\n        organizationId: orgId,\n      })\n      .andWhere('group_permissions.group = :group ', { group })\n      .andWhere('user_group_permissions.user_id = :userId', { userId: user.id })\n      .getCount();\n\n    return result > 0;\n  }\n\n  async userCan(user: User, action: string, entityName: string, resourceId?: string): Promise<boolean> {\n    switch (entityName) {\n      case 'App':\n        return await this.canUserPerformActionOnApp(user, action, resourceId);\n\n      case 'User':\n        return await this.hasGroup(user, 'admin');\n\n      case 'Thread':\n      case 'Comment':\n        return await this.canUserPerformActionOnApp(user, 'update', resourceId);\n\n      case 'Folder':\n        return await this.canUserPerformActionOnFolder(user, action);\n\n      default:\n        return false;\n    }\n  }\n\n  async canUserPerformActionOnApp(user: User, action: string, appId?: string): Promise<boolean> {\n    let permissionGrant: boolean;\n\n    switch (action) {\n      case 'create':\n        permissionGrant = this.canAnyGroupPerformAction('appCreate', await this.groupPermissions(user));\n        break;\n      case 'read':\n      case 'update':\n        permissionGrant =\n          this.canAnyGroupPerformAction(action, await this.appGroupPermissions(user, appId)) ||\n          (await this.isUserOwnerOfApp(user, appId));\n        break;\n      case 'delete':\n        permissionGrant =\n          this.canAnyGroupPerformAction('delete', await this.appGroupPermissions(user, appId)) ||\n          this.canAnyGroupPerformAction('appDelete', await this.groupPermissions(user)) ||\n          (await this.isUserOwnerOfApp(user, appId));\n        break;\n      default:\n        permissionGrant = false;\n        break;\n    }\n\n    return permissionGrant;\n  }\n\n  async canUserPerformActionOnFolder(user: User, action: string): Promise<boolean> {\n    let permissionGrant: boolean;\n\n    switch (action) {\n      case 'create':\n        permissionGrant = this.canAnyGroupPerformAction('folderCreate', await this.groupPermissions(user));\n        break;\n      default:\n        permissionGrant = false;\n        break;\n    }\n\n    return permissionGrant;\n  }\n\n  async isUserOwnerOfApp(user: User, appId: string): Promise<boolean> {\n    const app: App = await this.appsRepository.findOne({\n      where: {\n        id: appId,\n        userId: user.id,\n      },\n    });\n    return !!app && app.organizationId === user.organizationId;\n  }\n\n  async addAvatar(userId: number, imageBuffer: Buffer, filename: string) {\n    const queryRunner = this.connection.createQueryRunner();\n\n    await queryRunner.connect();\n    await queryRunner.startTransaction();\n\n    try {\n      const user = await queryRunner.manager.findOne(User, userId);\n      const currentAvatarId = user.avatarId;\n      const createFileDto = new CreateFileDto();\n      createFileDto.filename = filename;\n      createFileDto.data = imageBuffer;\n      const avatar = await this.filesService.create(createFileDto, queryRunner);\n\n      await queryRunner.manager.update(User, userId, {\n        avatarId: avatar.id,\n      });\n\n      if (currentAvatarId) {\n        await this.filesService.remove(currentAvatarId, queryRunner);\n      }\n\n      await queryRunner.commitTransaction();\n\n      return avatar;\n    } catch (error) {\n      await queryRunner.rollbackTransaction();\n      throw new InternalServerErrorException(error);\n    } finally {\n      await queryRunner.release();\n    }\n  }\n\n  canAnyGroupPerformAction(action: string, permissions: AppGroupPermission[] | GroupPermission[]): boolean {\n    return permissions.some((p) => p[action]);\n  }\n\n  async groupPermissions(user: User): Promise<GroupPermission[]> {\n    const orgUserGroupPermissions = await this.userGroupPermissions(user, user.organizationId);\n    const groupIds = orgUserGroupPermissions.map((p) => p.groupPermissionId);\n    const groupPermissionRepository = getRepository(GroupPermission);\n\n    return await groupPermissionRepository.findByIds(groupIds);\n  }\n\n  async groupPermissionsForOrganization(organizationId: string) {\n    const groupPermissionRepository = getRepository(GroupPermission);\n\n    return await groupPermissionRepository.find({ organizationId });\n  }\n\n  async appGroupPermissions(user: User, appId?: string): Promise<AppGroupPermission[]> {\n    const orgUserGroupPermissions = await this.userGroupPermissions(user, user.organizationId);\n    const groupIds = orgUserGroupPermissions.map((p) => p.groupPermissionId);\n\n    if (!groupIds || groupIds.length === 0) {\n      return [];\n    }\n\n    const query = createQueryBuilder(AppGroupPermission, 'app_group_permissions')\n      .innerJoin(\n        'app_group_permissions.groupPermission',\n        'group_permissions',\n        'group_permissions.organization_id = :organizationId',\n        {\n          organizationId: user.organizationId,\n        }\n      )\n      .where('app_group_permissions.groupPermissionId IN (:...groupIds)', { groupIds });\n\n    if (appId) {\n      query.andWhere('app_group_permissions.appId = :appId', { appId });\n    }\n    return await query.getMany();\n  }\n\n  async userGroupPermissions(user: User, organizationId?: string): Promise<UserGroupPermission[]> {\n    const orgId = organizationId || user.organizationId;\n\n    return await createQueryBuilder(UserGroupPermission, 'user_group_permissions')\n      .innerJoin('user_group_permissions.groupPermission', 'group_permissions')\n      .where('group_permissions.organization_id = :organizationId', {\n        organizationId: orgId,\n      })\n      .andWhere('user_group_permissions.user_id = :userId', { userId: user.id })\n      .getMany();\n  }\n}\n", "/* eslint-disable @typescript-eslint/no-unused-vars */\nimport * as request from 'supertest';\nimport { BadRequestException, INestApplication } from '@nestjs/common';\nimport { authHeaderForUser, clearDB, createUser, createNestAppInstance } from '../test.helper';\n\ndescribe('organization users controller', () => {\n  let app: INestApplication;\n\n  beforeEach(async () => {\n    await clearDB();\n  });\n\n  beforeAll(async () => {\n    app = await createNestAppInstance();\n  });\n\n  it('should allow only admin to be able to invite new users', async () => {\n    // setup a pre existing user of different organization\n    await createUser(app, {\n      email: 'someUser@tooljet.io',\n      groups: ['admin', 'all_users'],\n    });\n\n    // setup organization and user setup to test against\n    const adminUserData = await createUser(app, {\n      email: 'admin@tooljet.io',\n      groups: ['admin', 'all_users'],\n    });\n\n    const organization = adminUserData.organization;\n\n    const developerUserData = await createUser(app, {\n      email: 'developer@tooljet.io',\n      groups: ['developer', 'all_users'],\n      organization,\n    });\n\n    const viewerUserData = await createUser(app, {\n      email: 'viewer@tooljet.io',\n      groups: ['viewer', 'all_users'],\n      organization,\n    });\n\n    await request(app.getHttpServer())\n      .post(`/api/organization_users/`)\n      .set('Authorization', authHeaderForUser(adminUserData.user))\n      .send({ email: 'test@tooljet.io' })\n      .expect(201);\n\n    await request(app.getHttpServer())\n      .post(`/api/organization_users/`)\n      .set('Authorization', authHeaderForUser(developerUserData.user))\n      .send({ email: 'test2@tooljet.io' })\n      .expect(403);\n\n    await request(app.getHttpServer())\n      .post(`/api/organization_users/`)\n      .set('Authorization', authHeaderForUser(viewerUserData.user))\n      .send({ email: 'test3@tooljet.io' })\n      .expect(403);\n  });\n\n  describe('POST /api/organization_users/:id/archive', () => {\n    it('should allow only authenticated users to archive org users', async () => {\n      await request(app.getHttpServer()).post('/api/organization_users/random-id/archive/').expect(401);\n    });\n\n    it('should throw error when trying to remove last active admin', async () => {\n      const adminUserData = await createUser(app, {\n        email: 'admin@tooljet.io',\n        groups: ['admin', 'all_users'],\n        status: 'active',\n      });\n      const organization = adminUserData.organization;\n      const anotherAdminUserData = await createUser(app, {\n        email: 'another-admin@tooljet.io',\n        groups: ['admin', 'all_users'],\n        status: 'active',\n        organization,\n      });\n\n      const _archivedAdmin = await createUser(app, {\n        email: 'archived-admin@tooljet.io',\n        groups: ['admin', 'all_users'],\n        status: 'archived',\n        organization,\n      });\n\n      await request(app.getHttpServer())\n        .post(`/api/organization_users/${anotherAdminUserData.orgUser.id}/archive/`)\n        .set('Authorization', authHeaderForUser(adminUserData.user))\n        .expect(201);\n\n      const response = await request(app.getHttpServer())\n        .post(`/api/organization_users/${adminUserData.orgUser.id}/archive/`)\n        .set('Authorization', authHeaderForUser(adminUserData.user));\n\n      expect(response.statusCode).toEqual(400);\n      expect(response.body.message).toEqual('Atleast one active admin is required.');\n    });\n\n    it('should allow only admin users to archive org users', async () => {\n      const adminUserData = await createUser(app, {\n        email: 'admin@tooljet.io',\n        groups: ['admin', 'all_users'],\n      });\n      const organization = adminUserData.organization;\n      const developerUserData = await createUser(app, {\n        email: 'developer@tooljet.io',\n        groups: ['developer', 'all_users'],\n        organization,\n      });\n      const viewerUserData = await createUser(app, {\n        email: 'viewer@tooljet.io',\n        groups: ['viewer', 'all_users'],\n        organization,\n        status: 'invited',\n      });\n\n      await request(app.getHttpServer())\n        .post(`/api/organization_users/${viewerUserData.orgUser.id}/archive/`)\n        .set('Authorization', authHeaderForUser(developerUserData.user))\n        .expect(403);\n\n      await viewerUserData.orgUser.reload();\n      expect(viewerUserData.orgUser.status).toBe('invited');\n\n      await request(app.getHttpServer())\n        .post(`/api/organization_users/${viewerUserData.orgUser.id}/archive/`)\n        .set('Authorization', authHeaderForUser(adminUserData.user))\n        .expect(201);\n\n      await viewerUserData.orgUser.reload();\n      expect(viewerUserData.orgUser.status).toBe('archived');\n    });\n  });\n\n  describe('POST /api/organization_users/:id/unarchive', () => {\n    it('should allow only authenticated users to unarchive org users', async () => {\n      await request(app.getHttpServer()).post('/api/organization_users/random-id/unarchive/').expect(401);\n    });\n\n    it('should allow only admin users to unarchive org users', async () => {\n      const adminUserData = await createUser(app, {\n        email: 'admin@tooljet.io',\n        status: 'active',\n        groups: ['admin', 'all_users'],\n      });\n      const organization = adminUserData.organization;\n      const developerUserData = await createUser(app, {\n        email: 'developer@tooljet.io',\n        status: 'active',\n        groups: ['developer', 'all_users'],\n        organization,\n      });\n      const viewerUserData = await createUser(app, {\n        email: 'viewer@tooljet.io',\n        status: 'archived',\n        groups: ['viewer', 'all_users'],\n        organization,\n      });\n\n      await request(app.getHttpServer())\n        .post(`/api/organization_users/${viewerUserData.orgUser.id}/unarchive/`)\n        .set('Authorization', authHeaderForUser(developerUserData.user))\n        .expect(403);\n\n      await viewerUserData.orgUser.reload();\n      expect(viewerUserData.orgUser.status).toBe('archived');\n\n      await request(app.getHttpServer())\n        .post(`/api/organization_users/${viewerUserData.orgUser.id}/unarchive/`)\n        .set('Authorization', authHeaderForUser(developerUserData.user))\n        .expect(403);\n\n      await viewerUserData.orgUser.reload();\n      expect(viewerUserData.orgUser.status).toBe('archived');\n\n      await request(app.getHttpServer())\n        .post(`/api/organization_users/${viewerUserData.orgUser.id}/unarchive/`)\n        .set('Authorization', authHeaderForUser(adminUserData.user))\n        .expect(201);\n\n      await viewerUserData.orgUser.reload();\n      await viewerUserData.user.reload();\n      expect(viewerUserData.orgUser.status).toBe('invited');\n      expect(viewerUserData.user.invitationToken).not.toBe('');\n      expect(viewerUserData.user.password).not.toBe('old-password');\n    });\n\n    it('should not allow unarchive if user status is not archived', async () => {\n      const adminUserData = await createUser(app, {\n        email: 'admin@tooljet.io',\n        status: 'active',\n        groups: ['admin', 'all_users'],\n      });\n      const organization = adminUserData.organization;\n      const developerUserData = await createUser(app, {\n        email: 'developer@tooljet.io',\n        status: 'active',\n        groups: ['developer', 'all_users'],\n        organization,\n      });\n\n      await request(app.getHttpServer())\n        .post(`/api/organization_users/${developerUserData.orgUser.id}/unarchive/`)\n        .set('Authorization', authHeaderForUser(adminUserData.user))\n        .expect(400);\n\n      await developerUserData.orgUser.reload();\n      expect(developerUserData.orgUser.status).toBe('active');\n    });\n\n    it('should not allow unarchive if user status is not archived', async () => {\n      const adminUserData = await createUser(app, {\n        email: 'admin@tooljet.io',\n        status: 'active',\n        groups: ['admin', 'all_users'],\n      });\n      const organization = adminUserData.organization;\n      const developerUserData = await createUser(app, {\n        email: 'developer@tooljet.io',\n        status: 'invited',\n        groups: ['developer', 'all_users'],\n        organization,\n      });\n\n      await request(app.getHttpServer())\n        .post(`/api/organization_users/${developerUserData.orgUser.id}/unarchive/`)\n        .set('Authorization', authHeaderForUser(adminUserData.user))\n        .expect(400);\n\n      await developerUserData.orgUser.reload();\n      expect(developerUserData.orgUser.status).toBe('invited');\n    });\n  });\n\n  afterAll(async () => {\n    await app.close();\n  });\n});\n"], "filenames": ["server/src/services/users.service.ts", "server/test/controllers/organization_users.e2e-spec.ts"], "buggy_code_start_loc": [158, 191], "buggy_code_end_loc": [161, 212], "fixing_code_start_loc": [158, 191], "fixing_code_end_loc": [163, 236], "type": "CWE-284", "message": "Improper Access Control in GitHub repository tooljet/tooljet prior to v1.19.0.", "other": {"cve": {"id": "CVE-2022-2631", "sourceIdentifier": "security@huntr.dev", "published": "2022-08-02T17:15:10.777", "lastModified": "2022-08-06T03:08:58.407", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Improper Access Control in GitHub repository tooljet/tooljet prior to v1.19.0."}, {"lang": "es", "value": "Un Control de Acceso Inapropiado en el repositorio de GitHub tooljet/tooljet versiones anteriores a v1.19.0"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-284"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:tooljet:tooljet:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.19.0", "matchCriteriaId": "F5B24A2F-BD67-48CD-AE5F-3C6934645D11"}]}]}], "references": [{"url": "https://github.com/tooljet/tooljet/commit/b9fa229bcae356cbb33300b31483e97e6ea140a7", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/86881f9e-ca48-49b5-9782-3c406316930c", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/tooljet/tooljet/commit/b9fa229bcae356cbb33300b31483e97e6ea140a7"}}