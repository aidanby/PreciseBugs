{"buggy_code": ["/******************************************************************************\n *\n * Project:  KML Driver\n * Purpose:  Implementation of OGRKMLLayer class.\n * Author:   Christopher Condit, condit@sdsc.edu\n *           Jens Oberender, j.obi@troja.net\n *\n ******************************************************************************\n * Copyright (c) 2006, Christopher Condit\n * Copyright (c) 2007-2014, Even Rouault <even dot rouault at mines-paris dot org>\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n ****************************************************************************/\n\n#include \"cpl_port.h\"\n#include \"ogr_kml.h\"\n\n#include <string>\n\n#include \"cpl_conv.h\"\n#include \"cpl_error.h\"\n#include \"cpl_string.h\"\n#include \"cpl_vsi.h\"\n#include \"kml.h\"\n#include \"kmlutility.h\"\n#include \"ogr_api.h\"\n#include \"ogr_core.h\"\n#include \"ogr_feature.h\"\n#include \"ogr_featurestyle.h\"\n#include \"ogr_geometry.h\"\n#include \"ogr_p.h\"\n#include \"ogr_spatialref.h\"\n#include \"ogrsf_frmts.h\"\n\nCPL_CVSID(\"$Id$\")\n\n/* Function utility to dump OGRGeometry to KML text. */\nchar *OGR_G_ExportToKML( OGRGeometryH hGeometry, const char* pszAltitudeMode );\n\n/************************************************************************/\n/*                           OGRKMLLayer()                              */\n/************************************************************************/\n\nOGRKMLLayer::OGRKMLLayer( const char * pszName,\n                          OGRSpatialReference *poSRSIn, bool bWriterIn,\n                          OGRwkbGeometryType eReqType,\n                          OGRKMLDataSource *poDSIn ) :\n    poDS_(poDSIn),\n    poSRS_(poSRSIn ? new OGRSpatialReference(nullptr) : nullptr),\n    poCT_(nullptr),\n    poFeatureDefn_(new OGRFeatureDefn( pszName )),\n    iNextKMLId_(0),\n    nTotalKMLCount_(-1),\n    bWriter_(bWriterIn),\n    nLayerNumber_(0),\n    nWroteFeatureCount_(0),\n    bSchemaWritten_(false),\n    pszName_(CPLStrdup(pszName)),\n    nLastAsked(-1),\n    nLastCount(-1)\n{\n    // KML should be created as WGS84.\n    if( poSRSIn != nullptr )\n    {\n        poSRS_->SetWellKnownGeogCS( \"WGS84\" );\n        if( !poSRS_->IsSame(poSRSIn) )\n        {\n            poCT_ = OGRCreateCoordinateTransformation( poSRSIn, poSRS_ );\n            if( poCT_ == nullptr && poDSIn->IsFirstCTError() )\n            {\n                // If we can't create a transformation, issue a warning - but\n                // continue the transformation.\n                char *pszWKT = nullptr;\n\n                poSRSIn->exportToPrettyWkt( &pszWKT, FALSE );\n\n                CPLError(\n                    CE_Warning, CPLE_AppDefined,\n                    \"Failed to create coordinate transformation between the \"\n                    \"input coordinate system and WGS84.  This may be because \"\n                    \"they are not transformable.  \"\n                    \"KML geometries may not render correctly.  \"\n                    \"This message will not be issued any more.\"\n                    \"\\nSource:\\n%s\\n\",\n                    pszWKT );\n\n                CPLFree( pszWKT );\n                poDSIn->IssuedFirstCTError();\n            }\n        }\n    }\n\n    SetDescription( poFeatureDefn_->GetName() );\n    poFeatureDefn_->Reference();\n    poFeatureDefn_->SetGeomType( eReqType );\n    if( poFeatureDefn_->GetGeomFieldCount() != 0 )\n        poFeatureDefn_->GetGeomFieldDefn(0)->SetSpatialRef(poSRS_);\n\n    OGRFieldDefn oFieldName( \"Name\", OFTString );\n    poFeatureDefn_->AddFieldDefn( &oFieldName );\n\n    OGRFieldDefn oFieldDesc( \"Description\", OFTString );\n    poFeatureDefn_->AddFieldDefn( &oFieldDesc );\n\n    bClosedForWriting = !bWriterIn;\n}\n\n/************************************************************************/\n/*                           ~OGRKMLLayer()                             */\n/************************************************************************/\n\nOGRKMLLayer::~OGRKMLLayer()\n{\n    if( nullptr != poFeatureDefn_ )\n        poFeatureDefn_->Release();\n\n    if( nullptr != poSRS_ )\n        poSRS_->Release();\n\n    if( nullptr != poCT_ )\n        delete poCT_;\n\n    CPLFree( pszName_ );\n}\n\n/************************************************************************/\n/*                            GetLayerDefn()                            */\n/************************************************************************/\n\nOGRFeatureDefn* OGRKMLLayer::GetLayerDefn()\n{\n    return poFeatureDefn_;\n}\n\n/************************************************************************/\n/*                            ResetReading()                            */\n/************************************************************************/\n\nvoid OGRKMLLayer::ResetReading()\n{\n    iNextKMLId_ = 0;\n    nLastAsked = -1;\n    nLastCount = -1;\n}\n\n/************************************************************************/\n/*                           GetNextFeature()                           */\n/************************************************************************/\n\nOGRFeature *OGRKMLLayer::GetNextFeature()\n{\n#ifndef HAVE_EXPAT\n    return nullptr;\n#else\n    /* -------------------------------------------------------------------- */\n    /*      Loop till we find a feature matching our criteria.              */\n    /* -------------------------------------------------------------------- */\n    KML *poKMLFile = poDS_->GetKMLFile();\n    if( poKMLFile == nullptr )\n        return nullptr;\n\n    poKMLFile->selectLayer(nLayerNumber_);\n\n    while( true )\n    {\n        Feature *poFeatureKML =\n            poKMLFile->getFeature(iNextKMLId_++, nLastAsked, nLastCount);\n\n        if( poFeatureKML == nullptr )\n            return nullptr;\n\n        OGRFeature *poFeature = new OGRFeature( poFeatureDefn_ );\n\n        if( poFeatureKML->poGeom )\n        {\n            poFeature->SetGeometryDirectly(poFeatureKML->poGeom);\n            poFeatureKML->poGeom = nullptr;\n        }\n\n        // Add fields.\n        poFeature->SetField( poFeatureDefn_->GetFieldIndex(\"Name\"),\n                             poFeatureKML->sName.c_str() );\n        poFeature->SetField( poFeatureDefn_->GetFieldIndex(\"Description\"),\n                             poFeatureKML->sDescription.c_str() );\n        poFeature->SetFID( iNextKMLId_ - 1 );\n\n        // Clean up.\n        delete poFeatureKML;\n\n        if( poFeature->GetGeometryRef() != nullptr && poSRS_ != nullptr )\n        {\n            poFeature->GetGeometryRef()->assignSpatialReference( poSRS_ );\n        }\n\n        // Check spatial/attribute filters.\n        if( (m_poFilterGeom == nullptr ||\n             FilterGeometry( poFeature->GetGeometryRef() ) ) &&\n            (m_poAttrQuery == nullptr || m_poAttrQuery->Evaluate( poFeature )) )\n        {\n            return poFeature;\n        }\n\n        delete poFeature;\n    }\n\n#endif /* HAVE_EXPAT */\n}\n\n/************************************************************************/\n/*                          GetFeatureCount()                           */\n/************************************************************************/\n\n#ifndef HAVE_EXPAT\nGIntBig OGRKMLLayer::GetFeatureCount( int /* bForce */ ) { return 0; }\n#else\n\nGIntBig OGRKMLLayer::GetFeatureCount( int bForce )\n{\n    if( m_poFilterGeom != nullptr || m_poAttrQuery != nullptr )\n        return OGRLayer::GetFeatureCount(bForce);\n\n    KML *poKMLFile = poDS_->GetKMLFile();\n    if( nullptr == poKMLFile )\n        return 0;\n\n    poKMLFile->selectLayer(nLayerNumber_);\n\n    return poKMLFile->getNumFeatures();\n}\n#endif\n\n/************************************************************************/\n/*                           WriteSchema()                              */\n/************************************************************************/\n\nCPLString OGRKMLLayer::WriteSchema()\n{\n    if( bSchemaWritten_ )\n        return \"\";\n\n    CPLString osRet;\n\n    OGRFeatureDefn *featureDefinition = GetLayerDefn();\n    for( int j = 0; j < featureDefinition->GetFieldCount(); j++ )\n    {\n        OGRFieldDefn *fieldDefinition = featureDefinition->GetFieldDefn(j);\n\n        if (nullptr != poDS_->GetNameField() &&\n            EQUAL(fieldDefinition->GetNameRef(), poDS_->GetNameField()) )\n            continue;\n\n        if (nullptr != poDS_->GetDescriptionField() &&\n            EQUAL(fieldDefinition->GetNameRef(), poDS_->GetDescriptionField()) )\n            continue;\n\n        if( osRet.empty() )\n        {\n            osRet += CPLSPrintf( \"<Schema name=\\\"%s\\\" id=\\\"%s\\\">\\n\",\n                                 pszName_, pszName_ );\n        }\n\n        const char* pszKMLType = nullptr;\n        const char* pszKMLEltName = nullptr;\n        // Match the OGR type to the GDAL type.\n        switch (fieldDefinition->GetType())\n        {\n          case OFTInteger:\n            pszKMLType = \"int\";\n            pszKMLEltName = \"SimpleField\";\n            break;\n          case OFTIntegerList:\n            pszKMLType = \"int\";\n            pszKMLEltName = \"SimpleArrayField\";\n            break;\n          case OFTReal:\n            pszKMLType = \"float\";\n            pszKMLEltName = \"SimpleField\";\n            break;\n          case OFTRealList:\n            pszKMLType = \"float\";\n            pszKMLEltName = \"SimpleArrayField\";\n            break;\n          case OFTString:\n            pszKMLType = \"string\";\n            pszKMLEltName = \"SimpleField\";\n            break;\n          case OFTStringList:\n            pszKMLType = \"string\";\n            pszKMLEltName = \"SimpleArrayField\";\n            break;\n            //TODO: KML doesn't handle these data types yet...\n          case OFTDate:\n          case OFTTime:\n          case OFTDateTime:\n            pszKMLType = \"string\";\n            pszKMLEltName = \"SimpleField\";\n            break;\n\n          default:\n            pszKMLType = \"string\";\n            pszKMLEltName = \"SimpleField\";\n            break;\n        }\n        osRet += CPLSPrintf( \"\\t<%s name=\\\"%s\\\" type=\\\"%s\\\"></%s>\\n\",\n                    pszKMLEltName, fieldDefinition->GetNameRef() ,pszKMLType, pszKMLEltName );\n    }\n\n    if( !osRet.empty() )\n        osRet += CPLSPrintf( \"%s\", \"</Schema>\\n\" );\n\n    return osRet;\n}\n\n/************************************************************************/\n/*                           ICreateFeature()                            */\n/************************************************************************/\n\nOGRErr OGRKMLLayer::ICreateFeature( OGRFeature* poFeature )\n{\n    CPLAssert( nullptr != poFeature );\n    CPLAssert( nullptr != poDS_ );\n\n    if( !bWriter_ )\n        return OGRERR_FAILURE;\n\n    if( bClosedForWriting )\n    {\n        CPLError(\n            CE_Failure, CPLE_NotSupported,\n            \"Interleaved feature adding to different layers is not supported\");\n        return OGRERR_FAILURE;\n    }\n\n    VSILFILE *fp = poDS_->GetOutputFP();\n    CPLAssert( nullptr != fp );\n\n    if( poDS_->GetLayerCount() == 1 && nWroteFeatureCount_ == 0 )\n    {\n        CPLString osRet = WriteSchema();\n        if( !osRet.empty() )\n            VSIFPrintfL( fp, \"%s\", osRet.c_str() );\n        bSchemaWritten_ = true;\n\n        VSIFPrintfL( fp, \"<Folder><name>%s</name>\\n\", pszName_);\n    }\n\n    VSIFPrintfL( fp, \"  <Placemark>\\n\" );\n\n    if( poFeature->GetFID() == OGRNullFID )\n        poFeature->SetFID( iNextKMLId_++ );\n\n    // Find and write the name element\n    if( nullptr != poDS_->GetNameField() )\n    {\n        for( int iField = 0;\n             iField < poFeatureDefn_->GetFieldCount();\n             iField++ )\n        {\n            OGRFieldDefn *poField = poFeatureDefn_->GetFieldDefn( iField );\n\n            if( poFeature->IsFieldSetAndNotNull( iField )\n                && EQUAL(poField->GetNameRef(), poDS_->GetNameField()) )\n            {\n                const char *pszRaw = poFeature->GetFieldAsString( iField );\n                while( *pszRaw == ' ' )\n                    pszRaw++;\n\n                char *pszEscaped = OGRGetXML_UTF8_EscapedString( pszRaw );\n\n                VSIFPrintfL( fp, \"\\t<name>%s</name>\\n\", pszEscaped);\n                CPLFree( pszEscaped );\n            }\n        }\n    }\n\n    if( nullptr != poDS_->GetDescriptionField() )\n    {\n        for( int iField = 0;\n             iField < poFeatureDefn_->GetFieldCount();\n             iField++ )\n        {\n            OGRFieldDefn *poField = poFeatureDefn_->GetFieldDefn( iField );\n\n            if( poFeature->IsFieldSetAndNotNull( iField )\n                && EQUAL(poField->GetNameRef(), poDS_->GetDescriptionField()) )\n            {\n                const char *pszRaw = poFeature->GetFieldAsString( iField );\n                while( *pszRaw == ' ' )\n                    pszRaw++;\n\n                char *pszEscaped = OGRGetXML_UTF8_EscapedString( pszRaw );\n\n                VSIFPrintfL( fp, \"\\t<description>%s</description>\\n\",\n                             pszEscaped);\n                CPLFree( pszEscaped );\n            }\n        }\n    }\n\n    OGRwkbGeometryType eGeomType = wkbNone;\n    if( poFeature->GetGeometryRef() != nullptr )\n        eGeomType = wkbFlatten(poFeature->GetGeometryRef()->getGeometryType());\n\n    if( wkbPolygon == eGeomType\n        || wkbMultiPolygon == eGeomType\n        || wkbLineString == eGeomType\n        || wkbMultiLineString == eGeomType )\n    {\n        OGRStylePen *poPen = nullptr;\n        OGRStyleMgr oSM;\n\n        if( poFeature->GetStyleString() != nullptr )\n        {\n            oSM.InitFromFeature( poFeature );\n\n            for( int i = 0; i < oSM.GetPartCount(); i++ )\n            {\n                OGRStyleTool *poTool = oSM.GetPart(i);\n                if (poTool && poTool->GetType() == OGRSTCPen )\n                {\n                    poPen = (OGRStylePen*) poTool;\n                    break;\n                }\n                delete poTool;\n            }\n        }\n\n        VSIFPrintfL( fp, \"\\t<Style>\");\n        if( poPen != nullptr )\n        {\n            bool bHasWidth = false;\n            GBool bDefault = FALSE;\n\n            /* Require width to be returned in pixel */\n            poPen->SetUnit(OGRSTUPixel);\n            double fW = poPen->Width(bDefault);\n            if( bDefault )\n                fW = 1;\n            else\n                bHasWidth = true;\n            const char* pszColor = poPen->Color(bDefault);\n            const int nColorLen = static_cast<int>(CPLStrnlen(pszColor, 10));\n            if( pszColor != nullptr &&\n                pszColor[0] == '#' &&\n                !bDefault && nColorLen >= 7)\n            {\n                char acColor[9] = {0};\n                /* Order of KML color is aabbggrr, whereas OGR color is #rrggbb[aa] ! */\n                if(nColorLen == 9)\n                {\n                    acColor[0] = pszColor[7]; /* A */\n                    acColor[1] = pszColor[8];\n                }\n                else\n                {\n                    acColor[0] = 'F';\n                    acColor[1] = 'F';\n                }\n                acColor[2] = pszColor[5]; /* B */\n                acColor[3] = pszColor[6];\n                acColor[4] = pszColor[3]; /* G */\n                acColor[5] = pszColor[4];\n                acColor[6] = pszColor[1]; /* R */\n                acColor[7] = pszColor[2];\n                VSIFPrintfL( fp, \"<LineStyle><color>%s</color>\", acColor);\n                if (bHasWidth)\n                    VSIFPrintfL( fp, \"<width>%g</width>\", fW);\n                VSIFPrintfL( fp, \"</LineStyle>\");\n            }\n            else\n            {\n                VSIFPrintfL(\n                    fp, \"<LineStyle><color>ff0000ff</color></LineStyle>\");\n            }\n        }\n        else\n        {\n            VSIFPrintfL( fp, \"<LineStyle><color>ff0000ff</color></LineStyle>\");\n        }\n        delete poPen;\n        // If we're dealing with a polygon, add a line style that will stand out\n        // a bit.\n        VSIFPrintfL( fp, \"<PolyStyle><fill>0</fill></PolyStyle></Style>\\n\" );\n    }\n\n    bool bHasFoundOtherField = false;\n\n    // Write all fields as SchemaData\n    for( int iField = 0; iField < poFeatureDefn_->GetFieldCount(); iField++ )\n    {\n        OGRFieldDefn *poField = poFeatureDefn_->GetFieldDefn( iField );\n\n        if( poFeature->IsFieldSetAndNotNull( iField ))\n        {\n            if (nullptr != poDS_->GetNameField() &&\n                EQUAL(poField->GetNameRef(), poDS_->GetNameField()) )\n                continue;\n\n            if (nullptr != poDS_->GetDescriptionField() &&\n                EQUAL(poField->GetNameRef(), poDS_->GetDescriptionField()) )\n                continue;\n\n            if( !bHasFoundOtherField )\n            {\n                VSIFPrintfL( fp, \"\\t<ExtendedData><SchemaData schemaUrl=\\\"#%s\\\">\\n\", pszName_ );\n                bHasFoundOtherField = true;\n            }\n            const char *pszRaw = poFeature->GetFieldAsString( iField );\n\n            while( *pszRaw == ' ' )\n                pszRaw++;\n\n            char *pszEscaped = nullptr;\n            if (poFeatureDefn_->GetFieldDefn(iField)->GetType() == OFTReal)\n            {\n                pszEscaped = CPLStrdup( pszRaw );\n            }\n            else\n            {\n                pszEscaped = OGRGetXML_UTF8_EscapedString( pszRaw );\n            }\n\n            VSIFPrintfL( fp, \"\\t\\t<SimpleData name=\\\"%s\\\">%s</SimpleData>\\n\",\n                        poField->GetNameRef(), pszEscaped);\n\n            CPLFree( pszEscaped );\n        }\n    }\n\n    if( bHasFoundOtherField )\n    {\n        VSIFPrintfL( fp, \"\\t</SchemaData></ExtendedData>\\n\" );\n    }\n\n    // Write out Geometry - for now it isn't indented properly.\n    if( poFeature->GetGeometryRef() != nullptr )\n    {\n        char* pszGeometry = nullptr;\n        OGREnvelope sGeomBounds;\n        OGRGeometry *poWGS84Geom = nullptr;\n\n        if (nullptr != poCT_)\n        {\n            poWGS84Geom = poFeature->GetGeometryRef()->clone();\n            poWGS84Geom->transform( poCT_ );\n        }\n        else\n        {\n            poWGS84Geom = poFeature->GetGeometryRef();\n        }\n\n        // TODO - porting\n        // pszGeometry = poFeature->GetGeometryRef()->exportToKML();\n        pszGeometry =\n            OGR_G_ExportToKML( (OGRGeometryH)poWGS84Geom,\n                               poDS_->GetAltitudeMode());\n        if( pszGeometry != nullptr )\n        {\n            VSIFPrintfL( fp, \"      %s\\n\", pszGeometry );\n        }\n        else\n        {\n            CPLError(CE_Failure, CPLE_AppDefined,\n                     \"Export of geometry to KML failed\");\n        }\n        CPLFree( pszGeometry );\n\n        poWGS84Geom->getEnvelope( &sGeomBounds );\n        poDS_->GrowExtents( &sGeomBounds );\n\n        if (nullptr != poCT_)\n        {\n            delete poWGS84Geom;\n        }\n    }\n\n    VSIFPrintfL( fp, \"  </Placemark>\\n\" );\n    nWroteFeatureCount_++;\n    return OGRERR_NONE;\n}\n\n/************************************************************************/\n/*                           TestCapability()                           */\n/************************************************************************/\n\nint OGRKMLLayer::TestCapability( const char * pszCap )\n{\n    if( EQUAL(pszCap, OLCSequentialWrite) )\n    {\n        return bWriter_;\n    }\n    else if( EQUAL(pszCap, OLCCreateField) )\n    {\n        return bWriter_ && iNextKMLId_ == 0;\n    }\n    else if( EQUAL(pszCap,OLCFastFeatureCount) )\n    {\n//        if( poFClass == NULL\n//            || m_poFilterGeom != NULL\n//            || m_poAttrQuery != NULL )\n            return FALSE;\n\n//        return poFClass->GetFeatureCount() != -1;\n    }\n\n    else if (EQUAL(pszCap, OLCStringsAsUTF8))\n        return TRUE;\n\n    return FALSE;\n}\n\n/************************************************************************/\n/*                            CreateField()                             */\n/************************************************************************/\n\nOGRErr OGRKMLLayer::CreateField( OGRFieldDefn *poField,\n                                 CPL_UNUSED int bApproxOK )\n{\n    if( !bWriter_ || iNextKMLId_ != 0 )\n        return OGRERR_FAILURE;\n\n    OGRFieldDefn oCleanCopy( poField );\n    poFeatureDefn_->AddFieldDefn( &oCleanCopy );\n\n    return OGRERR_NONE;\n}\n\n/************************************************************************/\n/*                           SetLayerNumber()                           */\n/************************************************************************/\n\nvoid OGRKMLLayer::SetLayerNumber( int nLayer )\n{\n    nLayerNumber_ = nLayer;\n}\n"], "fixing_code": ["/******************************************************************************\n *\n * Project:  KML Driver\n * Purpose:  Implementation of OGRKMLLayer class.\n * Author:   Christopher Condit, condit@sdsc.edu\n *           Jens Oberender, j.obi@troja.net\n *\n ******************************************************************************\n * Copyright (c) 2006, Christopher Condit\n * Copyright (c) 2007-2014, Even Rouault <even dot rouault at mines-paris dot org>\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n ****************************************************************************/\n\n#include \"cpl_port.h\"\n#include \"ogr_kml.h\"\n\n#include <string>\n\n#include \"cpl_conv.h\"\n#include \"cpl_error.h\"\n#include \"cpl_string.h\"\n#include \"cpl_vsi.h\"\n#include \"kml.h\"\n#include \"kmlutility.h\"\n#include \"ogr_api.h\"\n#include \"ogr_core.h\"\n#include \"ogr_feature.h\"\n#include \"ogr_featurestyle.h\"\n#include \"ogr_geometry.h\"\n#include \"ogr_p.h\"\n#include \"ogr_spatialref.h\"\n#include \"ogrsf_frmts.h\"\n\nCPL_CVSID(\"$Id$\")\n\n/* Function utility to dump OGRGeometry to KML text. */\nchar *OGR_G_ExportToKML( OGRGeometryH hGeometry, const char* pszAltitudeMode );\n\n/************************************************************************/\n/*                           OGRKMLLayer()                              */\n/************************************************************************/\n\nOGRKMLLayer::OGRKMLLayer( const char * pszName,\n                          OGRSpatialReference *poSRSIn, bool bWriterIn,\n                          OGRwkbGeometryType eReqType,\n                          OGRKMLDataSource *poDSIn ) :\n    poDS_(poDSIn),\n    poSRS_(poSRSIn ? new OGRSpatialReference(nullptr) : nullptr),\n    poCT_(nullptr),\n    poFeatureDefn_(new OGRFeatureDefn( pszName )),\n    iNextKMLId_(0),\n    nTotalKMLCount_(-1),\n    bWriter_(bWriterIn),\n    nLayerNumber_(0),\n    nWroteFeatureCount_(0),\n    bSchemaWritten_(false),\n    pszName_(CPLStrdup(pszName)),\n    nLastAsked(-1),\n    nLastCount(-1)\n{\n    // KML should be created as WGS84.\n    if( poSRSIn != nullptr )\n    {\n        poSRS_->SetWellKnownGeogCS( \"WGS84\" );\n        poSRS_->SetAxisMappingStrategy(OAMS_TRADITIONAL_GIS_ORDER);\n        if( !poSRS_->IsSame(poSRSIn) )\n        {\n            poCT_ = OGRCreateCoordinateTransformation( poSRSIn, poSRS_ );\n            if( poCT_ == nullptr && poDSIn->IsFirstCTError() )\n            {\n                // If we can't create a transformation, issue a warning - but\n                // continue the transformation.\n                char *pszWKT = nullptr;\n\n                poSRSIn->exportToPrettyWkt( &pszWKT, FALSE );\n\n                CPLError(\n                    CE_Warning, CPLE_AppDefined,\n                    \"Failed to create coordinate transformation between the \"\n                    \"input coordinate system and WGS84.  This may be because \"\n                    \"they are not transformable.  \"\n                    \"KML geometries may not render correctly.  \"\n                    \"This message will not be issued any more.\"\n                    \"\\nSource:\\n%s\\n\",\n                    pszWKT );\n\n                CPLFree( pszWKT );\n                poDSIn->IssuedFirstCTError();\n            }\n        }\n    }\n\n    SetDescription( poFeatureDefn_->GetName() );\n    poFeatureDefn_->Reference();\n    poFeatureDefn_->SetGeomType( eReqType );\n    if( poFeatureDefn_->GetGeomFieldCount() != 0 )\n        poFeatureDefn_->GetGeomFieldDefn(0)->SetSpatialRef(poSRS_);\n\n    OGRFieldDefn oFieldName( \"Name\", OFTString );\n    poFeatureDefn_->AddFieldDefn( &oFieldName );\n\n    OGRFieldDefn oFieldDesc( \"Description\", OFTString );\n    poFeatureDefn_->AddFieldDefn( &oFieldDesc );\n\n    bClosedForWriting = !bWriterIn;\n}\n\n/************************************************************************/\n/*                           ~OGRKMLLayer()                             */\n/************************************************************************/\n\nOGRKMLLayer::~OGRKMLLayer()\n{\n    if( nullptr != poFeatureDefn_ )\n        poFeatureDefn_->Release();\n\n    if( nullptr != poSRS_ )\n        poSRS_->Release();\n\n    if( nullptr != poCT_ )\n        delete poCT_;\n\n    CPLFree( pszName_ );\n}\n\n/************************************************************************/\n/*                            GetLayerDefn()                            */\n/************************************************************************/\n\nOGRFeatureDefn* OGRKMLLayer::GetLayerDefn()\n{\n    return poFeatureDefn_;\n}\n\n/************************************************************************/\n/*                            ResetReading()                            */\n/************************************************************************/\n\nvoid OGRKMLLayer::ResetReading()\n{\n    iNextKMLId_ = 0;\n    nLastAsked = -1;\n    nLastCount = -1;\n}\n\n/************************************************************************/\n/*                           GetNextFeature()                           */\n/************************************************************************/\n\nOGRFeature *OGRKMLLayer::GetNextFeature()\n{\n#ifndef HAVE_EXPAT\n    return nullptr;\n#else\n    /* -------------------------------------------------------------------- */\n    /*      Loop till we find a feature matching our criteria.              */\n    /* -------------------------------------------------------------------- */\n    KML *poKMLFile = poDS_->GetKMLFile();\n    if( poKMLFile == nullptr )\n        return nullptr;\n\n    poKMLFile->selectLayer(nLayerNumber_);\n\n    while( true )\n    {\n        Feature *poFeatureKML =\n            poKMLFile->getFeature(iNextKMLId_++, nLastAsked, nLastCount);\n\n        if( poFeatureKML == nullptr )\n            return nullptr;\n\n        OGRFeature *poFeature = new OGRFeature( poFeatureDefn_ );\n\n        if( poFeatureKML->poGeom )\n        {\n            poFeature->SetGeometryDirectly(poFeatureKML->poGeom);\n            poFeatureKML->poGeom = nullptr;\n        }\n\n        // Add fields.\n        poFeature->SetField( poFeatureDefn_->GetFieldIndex(\"Name\"),\n                             poFeatureKML->sName.c_str() );\n        poFeature->SetField( poFeatureDefn_->GetFieldIndex(\"Description\"),\n                             poFeatureKML->sDescription.c_str() );\n        poFeature->SetFID( iNextKMLId_ - 1 );\n\n        // Clean up.\n        delete poFeatureKML;\n\n        if( poFeature->GetGeometryRef() != nullptr && poSRS_ != nullptr )\n        {\n            poFeature->GetGeometryRef()->assignSpatialReference( poSRS_ );\n        }\n\n        // Check spatial/attribute filters.\n        if( (m_poFilterGeom == nullptr ||\n             FilterGeometry( poFeature->GetGeometryRef() ) ) &&\n            (m_poAttrQuery == nullptr || m_poAttrQuery->Evaluate( poFeature )) )\n        {\n            return poFeature;\n        }\n\n        delete poFeature;\n    }\n\n#endif /* HAVE_EXPAT */\n}\n\n/************************************************************************/\n/*                          GetFeatureCount()                           */\n/************************************************************************/\n\n#ifndef HAVE_EXPAT\nGIntBig OGRKMLLayer::GetFeatureCount( int /* bForce */ ) { return 0; }\n#else\n\nGIntBig OGRKMLLayer::GetFeatureCount( int bForce )\n{\n    if( m_poFilterGeom != nullptr || m_poAttrQuery != nullptr )\n        return OGRLayer::GetFeatureCount(bForce);\n\n    KML *poKMLFile = poDS_->GetKMLFile();\n    if( nullptr == poKMLFile )\n        return 0;\n\n    poKMLFile->selectLayer(nLayerNumber_);\n\n    return poKMLFile->getNumFeatures();\n}\n#endif\n\n/************************************************************************/\n/*                           WriteSchema()                              */\n/************************************************************************/\n\nCPLString OGRKMLLayer::WriteSchema()\n{\n    if( bSchemaWritten_ )\n        return \"\";\n\n    CPLString osRet;\n\n    OGRFeatureDefn *featureDefinition = GetLayerDefn();\n    for( int j = 0; j < featureDefinition->GetFieldCount(); j++ )\n    {\n        OGRFieldDefn *fieldDefinition = featureDefinition->GetFieldDefn(j);\n\n        if (nullptr != poDS_->GetNameField() &&\n            EQUAL(fieldDefinition->GetNameRef(), poDS_->GetNameField()) )\n            continue;\n\n        if (nullptr != poDS_->GetDescriptionField() &&\n            EQUAL(fieldDefinition->GetNameRef(), poDS_->GetDescriptionField()) )\n            continue;\n\n        if( osRet.empty() )\n        {\n            osRet += CPLSPrintf( \"<Schema name=\\\"%s\\\" id=\\\"%s\\\">\\n\",\n                                 pszName_, pszName_ );\n        }\n\n        const char* pszKMLType = nullptr;\n        const char* pszKMLEltName = nullptr;\n        // Match the OGR type to the GDAL type.\n        switch (fieldDefinition->GetType())\n        {\n          case OFTInteger:\n            pszKMLType = \"int\";\n            pszKMLEltName = \"SimpleField\";\n            break;\n          case OFTIntegerList:\n            pszKMLType = \"int\";\n            pszKMLEltName = \"SimpleArrayField\";\n            break;\n          case OFTReal:\n            pszKMLType = \"float\";\n            pszKMLEltName = \"SimpleField\";\n            break;\n          case OFTRealList:\n            pszKMLType = \"float\";\n            pszKMLEltName = \"SimpleArrayField\";\n            break;\n          case OFTString:\n            pszKMLType = \"string\";\n            pszKMLEltName = \"SimpleField\";\n            break;\n          case OFTStringList:\n            pszKMLType = \"string\";\n            pszKMLEltName = \"SimpleArrayField\";\n            break;\n            //TODO: KML doesn't handle these data types yet...\n          case OFTDate:\n          case OFTTime:\n          case OFTDateTime:\n            pszKMLType = \"string\";\n            pszKMLEltName = \"SimpleField\";\n            break;\n\n          default:\n            pszKMLType = \"string\";\n            pszKMLEltName = \"SimpleField\";\n            break;\n        }\n        osRet += CPLSPrintf( \"\\t<%s name=\\\"%s\\\" type=\\\"%s\\\"></%s>\\n\",\n                    pszKMLEltName, fieldDefinition->GetNameRef() ,pszKMLType, pszKMLEltName );\n    }\n\n    if( !osRet.empty() )\n        osRet += CPLSPrintf( \"%s\", \"</Schema>\\n\" );\n\n    return osRet;\n}\n\n/************************************************************************/\n/*                           ICreateFeature()                            */\n/************************************************************************/\n\nOGRErr OGRKMLLayer::ICreateFeature( OGRFeature* poFeature )\n{\n    CPLAssert( nullptr != poFeature );\n    CPLAssert( nullptr != poDS_ );\n\n    if( !bWriter_ )\n        return OGRERR_FAILURE;\n\n    if( bClosedForWriting )\n    {\n        CPLError(\n            CE_Failure, CPLE_NotSupported,\n            \"Interleaved feature adding to different layers is not supported\");\n        return OGRERR_FAILURE;\n    }\n\n    VSILFILE *fp = poDS_->GetOutputFP();\n    CPLAssert( nullptr != fp );\n\n    if( poDS_->GetLayerCount() == 1 && nWroteFeatureCount_ == 0 )\n    {\n        CPLString osRet = WriteSchema();\n        if( !osRet.empty() )\n            VSIFPrintfL( fp, \"%s\", osRet.c_str() );\n        bSchemaWritten_ = true;\n\n        VSIFPrintfL( fp, \"<Folder><name>%s</name>\\n\", pszName_);\n    }\n\n    VSIFPrintfL( fp, \"  <Placemark>\\n\" );\n\n    if( poFeature->GetFID() == OGRNullFID )\n        poFeature->SetFID( iNextKMLId_++ );\n\n    // Find and write the name element\n    if( nullptr != poDS_->GetNameField() )\n    {\n        for( int iField = 0;\n             iField < poFeatureDefn_->GetFieldCount();\n             iField++ )\n        {\n            OGRFieldDefn *poField = poFeatureDefn_->GetFieldDefn( iField );\n\n            if( poFeature->IsFieldSetAndNotNull( iField )\n                && EQUAL(poField->GetNameRef(), poDS_->GetNameField()) )\n            {\n                const char *pszRaw = poFeature->GetFieldAsString( iField );\n                while( *pszRaw == ' ' )\n                    pszRaw++;\n\n                char *pszEscaped = OGRGetXML_UTF8_EscapedString( pszRaw );\n\n                VSIFPrintfL( fp, \"\\t<name>%s</name>\\n\", pszEscaped);\n                CPLFree( pszEscaped );\n            }\n        }\n    }\n\n    if( nullptr != poDS_->GetDescriptionField() )\n    {\n        for( int iField = 0;\n             iField < poFeatureDefn_->GetFieldCount();\n             iField++ )\n        {\n            OGRFieldDefn *poField = poFeatureDefn_->GetFieldDefn( iField );\n\n            if( poFeature->IsFieldSetAndNotNull( iField )\n                && EQUAL(poField->GetNameRef(), poDS_->GetDescriptionField()) )\n            {\n                const char *pszRaw = poFeature->GetFieldAsString( iField );\n                while( *pszRaw == ' ' )\n                    pszRaw++;\n\n                char *pszEscaped = OGRGetXML_UTF8_EscapedString( pszRaw );\n\n                VSIFPrintfL( fp, \"\\t<description>%s</description>\\n\",\n                             pszEscaped);\n                CPLFree( pszEscaped );\n            }\n        }\n    }\n\n    OGRwkbGeometryType eGeomType = wkbNone;\n    if( poFeature->GetGeometryRef() != nullptr )\n        eGeomType = wkbFlatten(poFeature->GetGeometryRef()->getGeometryType());\n\n    if( wkbPolygon == eGeomType\n        || wkbMultiPolygon == eGeomType\n        || wkbLineString == eGeomType\n        || wkbMultiLineString == eGeomType )\n    {\n        OGRStylePen *poPen = nullptr;\n        OGRStyleMgr oSM;\n\n        if( poFeature->GetStyleString() != nullptr )\n        {\n            oSM.InitFromFeature( poFeature );\n\n            for( int i = 0; i < oSM.GetPartCount(); i++ )\n            {\n                OGRStyleTool *poTool = oSM.GetPart(i);\n                if (poTool && poTool->GetType() == OGRSTCPen )\n                {\n                    poPen = (OGRStylePen*) poTool;\n                    break;\n                }\n                delete poTool;\n            }\n        }\n\n        VSIFPrintfL( fp, \"\\t<Style>\");\n        if( poPen != nullptr )\n        {\n            bool bHasWidth = false;\n            GBool bDefault = FALSE;\n\n            /* Require width to be returned in pixel */\n            poPen->SetUnit(OGRSTUPixel);\n            double fW = poPen->Width(bDefault);\n            if( bDefault )\n                fW = 1;\n            else\n                bHasWidth = true;\n            const char* pszColor = poPen->Color(bDefault);\n            const int nColorLen = static_cast<int>(CPLStrnlen(pszColor, 10));\n            if( pszColor != nullptr &&\n                pszColor[0] == '#' &&\n                !bDefault && nColorLen >= 7)\n            {\n                char acColor[9] = {0};\n                /* Order of KML color is aabbggrr, whereas OGR color is #rrggbb[aa] ! */\n                if(nColorLen == 9)\n                {\n                    acColor[0] = pszColor[7]; /* A */\n                    acColor[1] = pszColor[8];\n                }\n                else\n                {\n                    acColor[0] = 'F';\n                    acColor[1] = 'F';\n                }\n                acColor[2] = pszColor[5]; /* B */\n                acColor[3] = pszColor[6];\n                acColor[4] = pszColor[3]; /* G */\n                acColor[5] = pszColor[4];\n                acColor[6] = pszColor[1]; /* R */\n                acColor[7] = pszColor[2];\n                VSIFPrintfL( fp, \"<LineStyle><color>%s</color>\", acColor);\n                if (bHasWidth)\n                    VSIFPrintfL( fp, \"<width>%g</width>\", fW);\n                VSIFPrintfL( fp, \"</LineStyle>\");\n            }\n            else\n            {\n                VSIFPrintfL(\n                    fp, \"<LineStyle><color>ff0000ff</color></LineStyle>\");\n            }\n        }\n        else\n        {\n            VSIFPrintfL( fp, \"<LineStyle><color>ff0000ff</color></LineStyle>\");\n        }\n        delete poPen;\n        // If we're dealing with a polygon, add a line style that will stand out\n        // a bit.\n        VSIFPrintfL( fp, \"<PolyStyle><fill>0</fill></PolyStyle></Style>\\n\" );\n    }\n\n    bool bHasFoundOtherField = false;\n\n    // Write all fields as SchemaData\n    for( int iField = 0; iField < poFeatureDefn_->GetFieldCount(); iField++ )\n    {\n        OGRFieldDefn *poField = poFeatureDefn_->GetFieldDefn( iField );\n\n        if( poFeature->IsFieldSetAndNotNull( iField ))\n        {\n            if (nullptr != poDS_->GetNameField() &&\n                EQUAL(poField->GetNameRef(), poDS_->GetNameField()) )\n                continue;\n\n            if (nullptr != poDS_->GetDescriptionField() &&\n                EQUAL(poField->GetNameRef(), poDS_->GetDescriptionField()) )\n                continue;\n\n            if( !bHasFoundOtherField )\n            {\n                VSIFPrintfL( fp, \"\\t<ExtendedData><SchemaData schemaUrl=\\\"#%s\\\">\\n\", pszName_ );\n                bHasFoundOtherField = true;\n            }\n            const char *pszRaw = poFeature->GetFieldAsString( iField );\n\n            while( *pszRaw == ' ' )\n                pszRaw++;\n\n            char *pszEscaped = nullptr;\n            if (poFeatureDefn_->GetFieldDefn(iField)->GetType() == OFTReal)\n            {\n                pszEscaped = CPLStrdup( pszRaw );\n            }\n            else\n            {\n                pszEscaped = OGRGetXML_UTF8_EscapedString( pszRaw );\n            }\n\n            VSIFPrintfL( fp, \"\\t\\t<SimpleData name=\\\"%s\\\">%s</SimpleData>\\n\",\n                        poField->GetNameRef(), pszEscaped);\n\n            CPLFree( pszEscaped );\n        }\n    }\n\n    if( bHasFoundOtherField )\n    {\n        VSIFPrintfL( fp, \"\\t</SchemaData></ExtendedData>\\n\" );\n    }\n\n    // Write out Geometry - for now it isn't indented properly.\n    if( poFeature->GetGeometryRef() != nullptr )\n    {\n        char* pszGeometry = nullptr;\n        OGREnvelope sGeomBounds;\n        OGRGeometry *poWGS84Geom = nullptr;\n\n        if (nullptr != poCT_)\n        {\n            poWGS84Geom = poFeature->GetGeometryRef()->clone();\n            poWGS84Geom->transform( poCT_ );\n        }\n        else\n        {\n            poWGS84Geom = poFeature->GetGeometryRef();\n        }\n\n        // TODO - porting\n        // pszGeometry = poFeature->GetGeometryRef()->exportToKML();\n        pszGeometry =\n            OGR_G_ExportToKML( (OGRGeometryH)poWGS84Geom,\n                               poDS_->GetAltitudeMode());\n        if( pszGeometry != nullptr )\n        {\n            VSIFPrintfL( fp, \"      %s\\n\", pszGeometry );\n        }\n        else\n        {\n            CPLError(CE_Failure, CPLE_AppDefined,\n                     \"Export of geometry to KML failed\");\n        }\n        CPLFree( pszGeometry );\n\n        poWGS84Geom->getEnvelope( &sGeomBounds );\n        poDS_->GrowExtents( &sGeomBounds );\n\n        if (nullptr != poCT_)\n        {\n            delete poWGS84Geom;\n        }\n    }\n\n    VSIFPrintfL( fp, \"  </Placemark>\\n\" );\n    nWroteFeatureCount_++;\n    return OGRERR_NONE;\n}\n\n/************************************************************************/\n/*                           TestCapability()                           */\n/************************************************************************/\n\nint OGRKMLLayer::TestCapability( const char * pszCap )\n{\n    if( EQUAL(pszCap, OLCSequentialWrite) )\n    {\n        return bWriter_;\n    }\n    else if( EQUAL(pszCap, OLCCreateField) )\n    {\n        return bWriter_ && iNextKMLId_ == 0;\n    }\n    else if( EQUAL(pszCap,OLCFastFeatureCount) )\n    {\n//        if( poFClass == NULL\n//            || m_poFilterGeom != NULL\n//            || m_poAttrQuery != NULL )\n            return FALSE;\n\n//        return poFClass->GetFeatureCount() != -1;\n    }\n\n    else if (EQUAL(pszCap, OLCStringsAsUTF8))\n        return TRUE;\n\n    return FALSE;\n}\n\n/************************************************************************/\n/*                            CreateField()                             */\n/************************************************************************/\n\nOGRErr OGRKMLLayer::CreateField( OGRFieldDefn *poField,\n                                 CPL_UNUSED int bApproxOK )\n{\n    if( !bWriter_ || iNextKMLId_ != 0 )\n        return OGRERR_FAILURE;\n\n    OGRFieldDefn oCleanCopy( poField );\n    poFeatureDefn_->AddFieldDefn( &oCleanCopy );\n\n    return OGRERR_NONE;\n}\n\n/************************************************************************/\n/*                           SetLayerNumber()                           */\n/************************************************************************/\n\nvoid OGRKMLLayer::SetLayerNumber( int nLayer )\n{\n    nLayerNumber_ = nLayer;\n}\n"], "filenames": ["gdal/ogr/ogrsf_frmts/kml/ogrkmllayer.cpp"], "buggy_code_start_loc": [81], "buggy_code_end_loc": [81], "fixing_code_start_loc": [82], "fixing_code_end_loc": [83], "type": "CWE-787", "message": "netCDF in GDAL 2.4.2 through 3.0.4 has a stack-based buffer overflow in nc4_get_att (called from nc4_get_att_tc and nc_get_att_text) and in uffd_cleanup (called from netCDFDataset::~netCDFDataset and netCDFDataset::~netCDFDataset).", "other": {"cve": {"id": "CVE-2019-25050", "sourceIdentifier": "cve@mitre.org", "published": "2021-07-20T07:15:07.603", "lastModified": "2021-07-29T18:27:38.640", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "netCDF in GDAL 2.4.2 through 3.0.4 has a stack-based buffer overflow in nc4_get_att (called from nc4_get_att_tc and nc_get_att_text) and in uffd_cleanup (called from netCDFDataset::~netCDFDataset and netCDFDataset::~netCDFDataset)."}, {"lang": "es", "value": "netCDF en GDAL versiones 2.4.2 hasta 3.0.4, presenta un desbordamiento del b\u00fafer en la regi\u00f3n stack de la memoria en nc4_get_att (llamado desde nc4_get_att_tc y nc_get_att_text) y en uffd_cleanup (llamado desde netCDFDataset::~netCDFDataset y netCDFDataset::~netCDFDataset)"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.6}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:osgeo:gdal:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.4.2", "versionEndIncluding": "3.0.4", "matchCriteriaId": "54048F09-7400-4186-8AFD-93E5935C9200"}]}]}], "references": [{"url": "https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=15143", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=15156", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/OSGeo/gdal/commit/27b9bf644bcf1208f7d6594bdd104cc8a8bb0646", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/OSGeo/gdal/commit/767e3a56144f676ca738ef8f700e0e56035bd05a", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/google/oss-fuzz-vulns/blob/main/vulns/gdal/OSV-2020-392.yaml", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/google/oss-fuzz-vulns/blob/main/vulns/gdal/OSV-2020-420.yaml", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/OSGeo/gdal/commit/27b9bf644bcf1208f7d6594bdd104cc8a8bb0646"}}