{"buggy_code": ["package encoding\n\nimport (\n\t\"encoding/binary\"\n\t\"io\"\n\n\t\"github.com/v2fly/v2ray-core/v4/common\"\n\t\"github.com/v2fly/v2ray-core/v4/common/buf\"\n\t\"github.com/v2fly/v2ray-core/v4/common/net\"\n\t\"github.com/v2fly/v2ray-core/v4/common/protocol\"\n\t\"github.com/v2fly/v2ray-core/v4/common/serial\"\n\t\"github.com/v2fly/v2ray-core/v4/common/uuid\"\n)\n\nvar (\n\tErrCommandTypeMismatch = newError(\"Command type mismatch.\")\n\tErrUnknownCommand      = newError(\"Unknown command.\")\n\tErrCommandTooLarge     = newError(\"Command too large.\")\n)\n\nfunc MarshalCommand(command interface{}, writer io.Writer) error {\n\tif command == nil {\n\t\treturn ErrUnknownCommand\n\t}\n\n\tvar cmdID byte\n\tvar factory CommandFactory\n\tswitch command.(type) {\n\tcase *protocol.CommandSwitchAccount:\n\t\tfactory = new(CommandSwitchAccountFactory)\n\t\tcmdID = 1\n\tdefault:\n\t\treturn ErrUnknownCommand\n\t}\n\n\tbuffer := buf.New()\n\tdefer buffer.Release()\n\n\terr := factory.Marshal(command, buffer)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tauth := Authenticate(buffer.Bytes())\n\tlength := buffer.Len() + 4\n\tif length > 255 {\n\t\treturn ErrCommandTooLarge\n\t}\n\n\tcommon.Must2(writer.Write([]byte{cmdID, byte(length), byte(auth >> 24), byte(auth >> 16), byte(auth >> 8), byte(auth)}))\n\tcommon.Must2(writer.Write(buffer.Bytes()))\n\treturn nil\n}\n\nfunc UnmarshalCommand(cmdID byte, data []byte) (protocol.ResponseCommand, error) {\n\tif len(data) <= 4 {\n\t\treturn nil, newError(\"insufficient length\")\n\t}\n\texpectedAuth := Authenticate(data[4:])\n\tactualAuth := binary.BigEndian.Uint32(data[:4])\n\tif expectedAuth != actualAuth {\n\t\treturn nil, newError(\"invalid auth\")\n\t}\n\n\tvar factory CommandFactory\n\tswitch cmdID {\n\tcase 1:\n\t\tfactory = new(CommandSwitchAccountFactory)\n\tdefault:\n\t\treturn nil, ErrUnknownCommand\n\t}\n\treturn factory.Unmarshal(data[4:])\n}\n\ntype CommandFactory interface {\n\tMarshal(command interface{}, writer io.Writer) error\n\tUnmarshal(data []byte) (interface{}, error)\n}\n\ntype CommandSwitchAccountFactory struct{}\n\nfunc (f *CommandSwitchAccountFactory) Marshal(command interface{}, writer io.Writer) error {\n\tcmd, ok := command.(*protocol.CommandSwitchAccount)\n\tif !ok {\n\t\treturn ErrCommandTypeMismatch\n\t}\n\n\thostStr := \"\"\n\tif cmd.Host != nil {\n\t\thostStr = cmd.Host.String()\n\t}\n\tcommon.Must2(writer.Write([]byte{byte(len(hostStr))}))\n\n\tif len(hostStr) > 0 {\n\t\tcommon.Must2(writer.Write([]byte(hostStr)))\n\t}\n\n\tcommon.Must2(serial.WriteUint16(writer, cmd.Port.Value()))\n\n\tidBytes := cmd.ID.Bytes()\n\tcommon.Must2(writer.Write(idBytes))\n\tcommon.Must2(serial.WriteUint16(writer, cmd.AlterIds))\n\tcommon.Must2(writer.Write([]byte{byte(cmd.Level)}))\n\n\tcommon.Must2(writer.Write([]byte{cmd.ValidMin}))\n\treturn nil\n}\n\nfunc (f *CommandSwitchAccountFactory) Unmarshal(data []byte) (interface{}, error) {\n\tcmd := new(protocol.CommandSwitchAccount)\n\tif len(data) == 0 {\n\t\treturn nil, newError(\"insufficient length.\")\n\t}\n\tlenHost := int(data[0])\n\tif len(data) < lenHost+1 {\n\t\treturn nil, newError(\"insufficient length.\")\n\t}\n\tif lenHost > 0 {\n\t\tcmd.Host = net.ParseAddress(string(data[1 : 1+lenHost]))\n\t}\n\tportStart := 1 + lenHost\n\tif len(data) < portStart+2 {\n\t\treturn nil, newError(\"insufficient length.\")\n\t}\n\tcmd.Port = net.PortFromBytes(data[portStart : portStart+2])\n\tidStart := portStart + 2\n\tif len(data) < idStart+16 {\n\t\treturn nil, newError(\"insufficient length.\")\n\t}\n\tcmd.ID, _ = uuid.ParseBytes(data[idStart : idStart+16])\n\talterIDStart := idStart + 16\n\tif len(data) < alterIDStart+2 {\n\t\treturn nil, newError(\"insufficient length.\")\n\t}\n\tcmd.AlterIds = binary.BigEndian.Uint16(data[alterIDStart : alterIDStart+2])\n\tlevelStart := alterIDStart + 2\n\tif len(data) < levelStart+1 {\n\t\treturn nil, newError(\"insufficient length.\")\n\t}\n\tcmd.Level = uint32(data[levelStart])\n\ttimeStart := levelStart + 1\n\tif len(data) < timeStart {\n\t\treturn nil, newError(\"insufficient length.\")\n\t}\n\tcmd.ValidMin = data[timeStart]\n\treturn cmd, nil\n}\n", "package encoding_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/google/go-cmp/cmp\"\n\n\t\"github.com/v2fly/v2ray-core/v4/common\"\n\t\"github.com/v2fly/v2ray-core/v4/common/buf\"\n\t\"github.com/v2fly/v2ray-core/v4/common/protocol\"\n\t\"github.com/v2fly/v2ray-core/v4/common/uuid\"\n\t. \"github.com/v2fly/v2ray-core/v4/proxy/vmess/encoding\"\n)\n\nfunc TestSwitchAccount(t *testing.T) {\n\tsa := &protocol.CommandSwitchAccount{\n\t\tPort:     1234,\n\t\tID:       uuid.New(),\n\t\tAlterIds: 1024,\n\t\tLevel:    128,\n\t\tValidMin: 16,\n\t}\n\n\tbuffer := buf.New()\n\tcommon.Must(MarshalCommand(sa, buffer))\n\n\tcmd, err := UnmarshalCommand(1, buffer.BytesFrom(2))\n\tcommon.Must(err)\n\n\tsa2, ok := cmd.(*protocol.CommandSwitchAccount)\n\tif !ok {\n\t\tt.Fatal(\"failed to convert command to CommandSwitchAccount\")\n\t}\n\tif r := cmp.Diff(sa2, sa); r != \"\" {\n\t\tt.Error(r)\n\t}\n}\n"], "fixing_code": ["package encoding\n\nimport (\n\t\"encoding/binary\"\n\t\"io\"\n\n\t\"github.com/v2fly/v2ray-core/v4/common\"\n\t\"github.com/v2fly/v2ray-core/v4/common/buf\"\n\t\"github.com/v2fly/v2ray-core/v4/common/net\"\n\t\"github.com/v2fly/v2ray-core/v4/common/protocol\"\n\t\"github.com/v2fly/v2ray-core/v4/common/serial\"\n\t\"github.com/v2fly/v2ray-core/v4/common/uuid\"\n)\n\nvar (\n\tErrCommandTypeMismatch = newError(\"Command type mismatch.\")\n\tErrUnknownCommand      = newError(\"Unknown command.\")\n\tErrCommandTooLarge     = newError(\"Command too large.\")\n)\n\nfunc MarshalCommand(command interface{}, writer io.Writer) error {\n\tif command == nil {\n\t\treturn ErrUnknownCommand\n\t}\n\n\tvar cmdID byte\n\tvar factory CommandFactory\n\tswitch command.(type) {\n\tcase *protocol.CommandSwitchAccount:\n\t\tfactory = new(CommandSwitchAccountFactory)\n\t\tcmdID = 1\n\tdefault:\n\t\treturn ErrUnknownCommand\n\t}\n\n\tbuffer := buf.New()\n\tdefer buffer.Release()\n\n\terr := factory.Marshal(command, buffer)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tauth := Authenticate(buffer.Bytes())\n\tlength := buffer.Len() + 4\n\tif length > 255 {\n\t\treturn ErrCommandTooLarge\n\t}\n\n\tcommon.Must2(writer.Write([]byte{cmdID, byte(length), byte(auth >> 24), byte(auth >> 16), byte(auth >> 8), byte(auth)}))\n\tcommon.Must2(writer.Write(buffer.Bytes()))\n\treturn nil\n}\n\nfunc UnmarshalCommand(cmdID byte, data []byte) (protocol.ResponseCommand, error) {\n\tif len(data) <= 4 {\n\t\treturn nil, newError(\"insufficient length\")\n\t}\n\texpectedAuth := Authenticate(data[4:])\n\tactualAuth := binary.BigEndian.Uint32(data[:4])\n\tif expectedAuth != actualAuth {\n\t\treturn nil, newError(\"invalid auth\")\n\t}\n\n\tvar factory CommandFactory\n\tswitch cmdID {\n\tcase 1:\n\t\tfactory = new(CommandSwitchAccountFactory)\n\tdefault:\n\t\treturn nil, ErrUnknownCommand\n\t}\n\treturn factory.Unmarshal(data[4:])\n}\n\ntype CommandFactory interface {\n\tMarshal(command interface{}, writer io.Writer) error\n\tUnmarshal(data []byte) (interface{}, error)\n}\n\ntype CommandSwitchAccountFactory struct{}\n\nfunc (f *CommandSwitchAccountFactory) Marshal(command interface{}, writer io.Writer) error {\n\tcmd, ok := command.(*protocol.CommandSwitchAccount)\n\tif !ok {\n\t\treturn ErrCommandTypeMismatch\n\t}\n\n\thostStr := \"\"\n\tif cmd.Host != nil {\n\t\thostStr = cmd.Host.String()\n\t}\n\tcommon.Must2(writer.Write([]byte{byte(len(hostStr))}))\n\n\tif len(hostStr) > 0 {\n\t\tcommon.Must2(writer.Write([]byte(hostStr)))\n\t}\n\n\tcommon.Must2(serial.WriteUint16(writer, cmd.Port.Value()))\n\n\tidBytes := cmd.ID.Bytes()\n\tcommon.Must2(writer.Write(idBytes))\n\tcommon.Must2(serial.WriteUint16(writer, cmd.AlterIds))\n\tcommon.Must2(writer.Write([]byte{byte(cmd.Level)}))\n\n\tcommon.Must2(writer.Write([]byte{cmd.ValidMin}))\n\treturn nil\n}\n\nfunc (f *CommandSwitchAccountFactory) Unmarshal(data []byte) (interface{}, error) {\n\tcmd := new(protocol.CommandSwitchAccount)\n\tif len(data) == 0 {\n\t\treturn nil, newError(\"insufficient length.\")\n\t}\n\tlenHost := int(data[0])\n\tif len(data) < lenHost+1 {\n\t\treturn nil, newError(\"insufficient length.\")\n\t}\n\tif lenHost > 0 {\n\t\tcmd.Host = net.ParseAddress(string(data[1 : 1+lenHost]))\n\t}\n\tportStart := 1 + lenHost\n\tif len(data) < portStart+2 {\n\t\treturn nil, newError(\"insufficient length.\")\n\t}\n\tcmd.Port = net.PortFromBytes(data[portStart : portStart+2])\n\tidStart := portStart + 2\n\tif len(data) < idStart+16 {\n\t\treturn nil, newError(\"insufficient length.\")\n\t}\n\tcmd.ID, _ = uuid.ParseBytes(data[idStart : idStart+16])\n\talterIDStart := idStart + 16\n\tif len(data) < alterIDStart+2 {\n\t\treturn nil, newError(\"insufficient length.\")\n\t}\n\tcmd.AlterIds = binary.BigEndian.Uint16(data[alterIDStart : alterIDStart+2])\n\tlevelStart := alterIDStart + 2\n\tif len(data) < levelStart+1 {\n\t\treturn nil, newError(\"insufficient length.\")\n\t}\n\tcmd.Level = uint32(data[levelStart])\n\ttimeStart := levelStart + 1\n\tif len(data) < timeStart+1 {\n\t\treturn nil, newError(\"insufficient length.\")\n\t}\n\tcmd.ValidMin = data[timeStart]\n\treturn cmd, nil\n}\n", "package encoding_test\n\nimport (\n\t\"github.com/stretchr/testify/assert\"\n\t\"testing\"\n\n\t\"github.com/google/go-cmp/cmp\"\n\n\t\"github.com/v2fly/v2ray-core/v4/common\"\n\t\"github.com/v2fly/v2ray-core/v4/common/buf\"\n\t\"github.com/v2fly/v2ray-core/v4/common/protocol\"\n\t\"github.com/v2fly/v2ray-core/v4/common/uuid\"\n\t. \"github.com/v2fly/v2ray-core/v4/proxy/vmess/encoding\"\n)\n\nfunc TestSwitchAccount(t *testing.T) {\n\tsa := &protocol.CommandSwitchAccount{\n\t\tPort:     1234,\n\t\tID:       uuid.New(),\n\t\tAlterIds: 1024,\n\t\tLevel:    128,\n\t\tValidMin: 16,\n\t}\n\n\tbuffer := buf.New()\n\tcommon.Must(MarshalCommand(sa, buffer))\n\n\tcmd, err := UnmarshalCommand(1, buffer.BytesFrom(2))\n\tcommon.Must(err)\n\n\tsa2, ok := cmd.(*protocol.CommandSwitchAccount)\n\tif !ok {\n\t\tt.Fatal(\"failed to convert command to CommandSwitchAccount\")\n\t}\n\tif r := cmp.Diff(sa2, sa); r != \"\" {\n\t\tt.Error(r)\n\t}\n}\n\nfunc TestSwitchAccountBugOffByOne(t *testing.T) {\n\tsa := &protocol.CommandSwitchAccount{\n\t\tPort:     1234,\n\t\tID:       uuid.New(),\n\t\tAlterIds: 1024,\n\t\tLevel:    128,\n\t\tValidMin: 16,\n\t}\n\n\tbuffer := buf.New()\n\tcsaf := CommandSwitchAccountFactory{}\n\tcommon.Must(csaf.Marshal(sa, buffer))\n\n\tPayload := buffer.Bytes()\n\n\tcmd, err := csaf.Unmarshal(Payload[:len(Payload)-1])\n\tassert.Error(t, err)\n\tassert.Nil(t, cmd)\n}\n"], "filenames": ["proxy/vmess/encoding/commands.go", "proxy/vmess/encoding/commands_test.go"], "buggy_code_start_loc": [142, 3], "buggy_code_end_loc": [143, 37], "fixing_code_start_loc": [142, 4], "fixing_code_end_loc": [143, 59], "type": "CWE-193", "message": "Off-by-one Error in GitHub repository v2fly/v2ray-core prior to 4.44.0.", "other": {"cve": {"id": "CVE-2021-4070", "sourceIdentifier": "security@huntr.dev", "published": "2022-02-23T20:15:09.167", "lastModified": "2022-03-02T17:33:44.677", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Off-by-one Error in GitHub repository v2fly/v2ray-core prior to 4.44.0."}, {"lang": "es", "value": "Un Error de Desv\u00edo en el repositorio de GitHub v2fly/v2ray-core versiones anteriores a 4.44.0"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.5, "impactScore": 3.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 6.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-193"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-193"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:v2fly:v2ray-core:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.44.0", "matchCriteriaId": "979DEA5F-2F1E-443A-9585-1BE8D31FEB80"}]}]}], "references": [{"url": "https://github.com/v2fly/v2ray-core/commit/c1af2bfd7aa59a4482aa7f6ec4b9208c1d350b5c", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/8da19456-4d89-41ef-9781-a41efd6a1877", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/v2fly/v2ray-core/commit/c1af2bfd7aa59a4482aa7f6ec4b9208c1d350b5c"}}