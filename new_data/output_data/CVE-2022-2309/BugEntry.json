{"buggy_code": ["# Private/public helper functions for API functions\n\nfrom lxml.includes cimport uri\n\n\ncdef void displayNode(xmlNode* c_node, indent):\n    # to help with debugging\n    cdef xmlNode* c_child\n    try:\n        print indent * u' ', <long>c_node\n        c_child = c_node.children\n        while c_child is not NULL:\n            displayNode(c_child, indent + 1)\n            c_child = c_child.next\n    finally:\n        return  # swallow any exceptions\n\ncdef inline int _assertValidNode(_Element element) except -1:\n    assert element._c_node is not NULL, u\"invalid Element proxy at %s\" % id(element)\n\ncdef inline int _assertValidDoc(_Document doc) except -1:\n    assert doc._c_doc is not NULL, u\"invalid Document proxy at %s\" % id(doc)\n\ncdef _Document _documentOrRaise(object input):\n    u\"\"\"Call this to get the document of a _Document, _ElementTree or _Element\n    object, or to raise an exception if it can't be determined.\n\n    Should be used in all API functions for consistency.\n    \"\"\"\n    cdef _Document doc\n    if isinstance(input, _ElementTree):\n        if (<_ElementTree>input)._context_node is not None:\n            doc = (<_ElementTree>input)._context_node._doc\n        else:\n            doc = None\n    elif isinstance(input, _Element):\n        doc = (<_Element>input)._doc\n    elif isinstance(input, _Document):\n        doc = <_Document>input\n    else:\n        raise TypeError, f\"Invalid input object: {python._fqtypename(input).decode('utf8')}\"\n    if doc is None:\n        raise ValueError, f\"Input object has no document: {python._fqtypename(input).decode('utf8')}\"\n    _assertValidDoc(doc)\n    return doc\n\ncdef _Element _rootNodeOrRaise(object input):\n    u\"\"\"Call this to get the root node of a _Document, _ElementTree or\n     _Element object, or to raise an exception if it can't be determined.\n\n    Should be used in all API functions for consistency.\n     \"\"\"\n    cdef _Element node\n    if isinstance(input, _ElementTree):\n        node = (<_ElementTree>input)._context_node\n    elif isinstance(input, _Element):\n        node = <_Element>input\n    elif isinstance(input, _Document):\n        node = (<_Document>input).getroot()\n    else:\n        raise TypeError, f\"Invalid input object: {python._fqtypename(input).decode('utf8')}\"\n    if (node is None or not node._c_node or\n            node._c_node.type != tree.XML_ELEMENT_NODE):\n        raise ValueError, f\"Input object is not an XML element: {python._fqtypename(input).decode('utf8')}\"\n    _assertValidNode(node)\n    return node\n\ncdef bint _isAncestorOrSame(xmlNode* c_ancestor, xmlNode* c_node):\n    while c_node:\n        if c_node is c_ancestor:\n            return True\n        c_node = c_node.parent\n    return False\n\ncdef _Element _makeElement(tag, xmlDoc* c_doc, _Document doc,\n                           _BaseParser parser, text, tail, attrib, nsmap,\n                           dict extra_attrs):\n    u\"\"\"Create a new element and initialize text content, namespaces and\n    attributes.\n\n    This helper function will reuse as much of the existing document as\n    possible:\n\n    If 'parser' is None, the parser will be inherited from 'doc' or the\n    default parser will be used.\n\n    If 'doc' is None, 'c_doc' is used to create a new _Document and the new\n    element is made its root node.\n\n    If 'c_doc' is also NULL, a new xmlDoc will be created.\n    \"\"\"\n    cdef xmlNode* c_node\n    if doc is not None:\n        c_doc = doc._c_doc\n    ns_utf, name_utf = _getNsTag(tag)\n    if parser is not None and parser._for_html:\n        _htmlTagValidOrRaise(name_utf)\n        if c_doc is NULL:\n            c_doc = _newHTMLDoc()\n    else:\n        _tagValidOrRaise(name_utf)\n        if c_doc is NULL:\n            c_doc = _newXMLDoc()\n    c_node = _createElement(c_doc, name_utf)\n    if c_node is NULL:\n        if doc is None and c_doc is not NULL:\n            tree.xmlFreeDoc(c_doc)\n        raise MemoryError()\n    try:\n        if doc is None:\n            tree.xmlDocSetRootElement(c_doc, c_node)\n            doc = _documentFactory(c_doc, parser)\n        if text is not None:\n            _setNodeText(c_node, text)\n        if tail is not None:\n            _setTailText(c_node, tail)\n        # add namespaces to node if necessary\n        _setNodeNamespaces(c_node, doc, ns_utf, nsmap)\n        _initNodeAttributes(c_node, doc, attrib, extra_attrs)\n        return _elementFactory(doc, c_node)\n    except:\n        # free allocated c_node/c_doc unless Python does it for us\n        if c_node.doc is not c_doc:\n            # node not yet in document => will not be freed by document\n            if tail is not None:\n                _removeText(c_node.next) # tail\n            tree.xmlFreeNode(c_node)\n        if doc is None:\n            # c_doc will not be freed by doc\n            tree.xmlFreeDoc(c_doc)\n        raise\n\ncdef int _initNewElement(_Element element, bint is_html, name_utf, ns_utf,\n                         _BaseParser parser, attrib, nsmap, dict extra_attrs) except -1:\n    u\"\"\"Initialise a new Element object.\n\n    This is used when users instantiate a Python Element subclass\n    directly, without it being mapped to an existing XML node.\n    \"\"\"\n    cdef xmlDoc* c_doc\n    cdef xmlNode* c_node\n    cdef _Document doc\n    if is_html:\n        _htmlTagValidOrRaise(name_utf)\n        c_doc = _newHTMLDoc()\n    else:\n        _tagValidOrRaise(name_utf)\n        c_doc = _newXMLDoc()\n    c_node = _createElement(c_doc, name_utf)\n    if c_node is NULL:\n        if c_doc is not NULL:\n            tree.xmlFreeDoc(c_doc)\n        raise MemoryError()\n    tree.xmlDocSetRootElement(c_doc, c_node)\n    doc = _documentFactory(c_doc, parser)\n    # add namespaces to node if necessary\n    _setNodeNamespaces(c_node, doc, ns_utf, nsmap)\n    _initNodeAttributes(c_node, doc, attrib, extra_attrs)\n    _registerProxy(element, doc, c_node)\n    element._init()\n    return 0\n\ncdef _Element _makeSubElement(_Element parent, tag, text, tail,\n                              attrib, nsmap, dict extra_attrs):\n    u\"\"\"Create a new child element and initialize text content, namespaces and\n    attributes.\n    \"\"\"\n    cdef xmlNode* c_node\n    cdef xmlDoc* c_doc\n    if parent is None or parent._doc is None:\n        return None\n    _assertValidNode(parent)\n    ns_utf, name_utf = _getNsTag(tag)\n    c_doc = parent._doc._c_doc\n\n    if parent._doc._parser is not None and parent._doc._parser._for_html:\n        _htmlTagValidOrRaise(name_utf)\n    else:\n        _tagValidOrRaise(name_utf)\n\n    c_node = _createElement(c_doc, name_utf)\n    if c_node is NULL:\n        raise MemoryError()\n    tree.xmlAddChild(parent._c_node, c_node)\n\n    try:\n        if text is not None:\n            _setNodeText(c_node, text)\n        if tail is not None:\n            _setTailText(c_node, tail)\n\n        # add namespaces to node if necessary\n        _setNodeNamespaces(c_node, parent._doc, ns_utf, nsmap)\n        _initNodeAttributes(c_node, parent._doc, attrib, extra_attrs)\n        return _elementFactory(parent._doc, c_node)\n    except:\n        # make sure we clean up in case of an error\n        _removeNode(parent._doc, c_node)\n        raise\n\n\ncdef int _setNodeNamespaces(xmlNode* c_node, _Document doc,\n                            object node_ns_utf, object nsmap) except -1:\n    u\"\"\"Lookup current namespace prefixes, then set namespace structure for\n    node (if 'node_ns_utf' was provided) and register new ns-prefix mappings.\n\n    'node_ns_utf' should only be passed for a newly created node.\n    \"\"\"\n    cdef xmlNs* c_ns\n    cdef list nsdefs\n\n    if nsmap:\n        for prefix, href in _iter_nsmap(nsmap):\n            href_utf = _utf8(href)\n            _uriValidOrRaise(href_utf)\n            c_href = _xcstr(href_utf)\n            if prefix is not None:\n                prefix_utf = _utf8(prefix)\n                _prefixValidOrRaise(prefix_utf)\n                c_prefix = _xcstr(prefix_utf)\n            else:\n                c_prefix = <const_xmlChar*>NULL\n            # add namespace with prefix if it is not already known\n            c_ns = tree.xmlSearchNs(doc._c_doc, c_node, c_prefix)\n            if c_ns is NULL or \\\n                    c_ns.href is NULL or \\\n                    tree.xmlStrcmp(c_ns.href, c_href) != 0:\n                c_ns = tree.xmlNewNs(c_node, c_href, c_prefix)\n            if href_utf == node_ns_utf:\n                tree.xmlSetNs(c_node, c_ns)\n                node_ns_utf = None\n\n    if node_ns_utf is not None:\n        _uriValidOrRaise(node_ns_utf)\n        doc._setNodeNs(c_node, _xcstr(node_ns_utf))\n    return 0\n\n\ncdef dict _build_nsmap(xmlNode* c_node):\n    \"\"\"\n    Namespace prefix->URI mapping known in the context of this Element.\n    This includes all namespace declarations of the parents.\n    \"\"\"\n    cdef xmlNs* c_ns\n    nsmap = {}\n    while c_node is not NULL and c_node.type == tree.XML_ELEMENT_NODE:\n        c_ns = c_node.nsDef\n        while c_ns is not NULL:\n            prefix = funicodeOrNone(c_ns.prefix)\n            if prefix not in nsmap:\n                nsmap[prefix] = funicodeOrNone(c_ns.href)\n            c_ns = c_ns.next\n        c_node = c_node.parent\n    return nsmap\n\n\ncdef _iter_nsmap(nsmap):\n    \"\"\"\n    Create a reproducibly ordered iterable from an nsmap mapping.\n    Tries to preserve an existing order and sorts if it assumes no order.\n\n    The difference to _iter_attrib() is that None doesn't sort with strings\n    in Py3.x.\n    \"\"\"\n    if python.PY_VERSION_HEX >= 0x03060000:\n        # dicts are insertion-ordered in Py3.6+ => keep the user provided order.\n        if isinstance(nsmap, dict):\n            return nsmap.items()\n    if len(nsmap) <= 1:\n        return nsmap.items()\n    # nsmap will usually be a plain unordered dict => avoid type checking overhead\n    if type(nsmap) is not dict and isinstance(nsmap, OrderedDict):\n        return nsmap.items()  # keep existing order\n    if None not in nsmap:\n        return sorted(nsmap.items())\n\n    # Move the default namespace to the end.  This makes sure libxml2\n    # prefers a prefix if the ns is defined redundantly on the same\n    # element.  That way, users can work around a problem themselves\n    # where default namespace attributes on non-default namespaced\n    # elements serialise without prefix (i.e. into the non-default\n    # namespace).\n    default_ns = nsmap[None]\n    nsdefs = [(k, v) for k, v in nsmap.items() if k is not None]\n    nsdefs.sort()\n    nsdefs.append((None, default_ns))\n    return nsdefs\n\n\ncdef _iter_attrib(attrib):\n    \"\"\"\n    Create a reproducibly ordered iterable from an attrib mapping.\n    Tries to preserve an existing order and sorts if it assumes no order.\n    \"\"\"\n    # dicts are insertion-ordered in Py3.6+ => keep the user provided order.\n    if python.PY_VERSION_HEX >= 0x03060000 and isinstance(attrib, dict) or (\n            isinstance(attrib, (_Attrib, OrderedDict))):\n        return attrib.items()\n    # assume it's an unordered mapping of some kind\n    return sorted(attrib.items())\n\n\ncdef _initNodeAttributes(xmlNode* c_node, _Document doc, attrib, dict extra):\n    u\"\"\"Initialise the attributes of an element node.\n    \"\"\"\n    cdef bint is_html\n    cdef xmlNs* c_ns\n    if attrib is not None and not hasattr(attrib, u'items'):\n        raise TypeError, f\"Invalid attribute dictionary: {python._fqtypename(attrib).decode('utf8')}\"\n    if not attrib and not extra:\n        return  # nothing to do\n    is_html = doc._parser._for_html\n    seen = set()\n    if extra:\n        if python.PY_VERSION_HEX >= 0x03060000:\n            for name, value in extra.items():\n                _addAttributeToNode(c_node, doc, is_html, name, value, seen)\n        else:\n            for name, value in sorted(extra.items()):\n                _addAttributeToNode(c_node, doc, is_html, name, value, seen)\n    if attrib:\n        for name, value in _iter_attrib(attrib):\n            _addAttributeToNode(c_node, doc, is_html, name, value, seen)\n\n\ncdef int _addAttributeToNode(xmlNode* c_node, _Document doc, bint is_html,\n                             name, value, set seen_tags) except -1:\n    ns_utf, name_utf = tag = _getNsTag(name)\n    if tag in seen_tags:\n        return 0\n    seen_tags.add(tag)\n    if not is_html:\n        _attributeValidOrRaise(name_utf)\n    value_utf = _utf8(value)\n    if ns_utf is None:\n        tree.xmlNewProp(c_node, _xcstr(name_utf), _xcstr(value_utf))\n    else:\n        _uriValidOrRaise(ns_utf)\n        c_ns = doc._findOrBuildNodeNs(c_node, _xcstr(ns_utf), NULL, 1)\n        tree.xmlNewNsProp(c_node, c_ns,\n                          _xcstr(name_utf), _xcstr(value_utf))\n    return 0\n\n\nctypedef struct _ns_node_ref:\n    xmlNs* ns\n    xmlNode* node\n\n\ncdef int _collectNsDefs(xmlNode* c_element, _ns_node_ref **_c_ns_list,\n                        size_t *_c_ns_list_len, size_t *_c_ns_list_size) except -1:\n    c_ns_list = _c_ns_list[0]\n    cdef size_t c_ns_list_len = _c_ns_list_len[0]\n    cdef size_t c_ns_list_size = _c_ns_list_size[0]\n\n    c_nsdef = c_element.nsDef\n    while c_nsdef is not NULL:\n        if c_ns_list_len >= c_ns_list_size:\n            if c_ns_list is NULL:\n                c_ns_list_size = 20\n            else:\n                c_ns_list_size *= 2\n            c_nsref_ptr = <_ns_node_ref*> python.lxml_realloc(\n                c_ns_list, c_ns_list_size, sizeof(_ns_node_ref))\n            if c_nsref_ptr is NULL:\n                if c_ns_list is not NULL:\n                    python.lxml_free(c_ns_list)\n                    _c_ns_list[0] = NULL\n                raise MemoryError()\n            c_ns_list = c_nsref_ptr\n\n        c_ns_list[c_ns_list_len] = _ns_node_ref(c_nsdef, c_element)\n        c_ns_list_len += 1\n        c_nsdef = c_nsdef.next\n\n    _c_ns_list_size[0] = c_ns_list_size\n    _c_ns_list_len[0] = c_ns_list_len\n    _c_ns_list[0] = c_ns_list\n\n\ncdef int _removeUnusedNamespaceDeclarations(xmlNode* c_element, set prefixes_to_keep) except -1:\n    u\"\"\"Remove any namespace declarations from a subtree that are not used by\n    any of its elements (or attributes).\n\n    If a 'prefixes_to_keep' is provided, it must be a set of prefixes.\n    Any corresponding namespace mappings will not be removed as part of the cleanup.\n    \"\"\"\n    cdef xmlNode* c_node\n    cdef _ns_node_ref* c_ns_list = NULL\n    cdef size_t c_ns_list_size = 0\n    cdef size_t c_ns_list_len = 0\n    cdef size_t i\n\n    if c_element.parent and c_element.parent.type == tree.XML_DOCUMENT_NODE:\n        # include declarations on the document node\n        _collectNsDefs(c_element.parent, &c_ns_list, &c_ns_list_len, &c_ns_list_size)\n\n    tree.BEGIN_FOR_EACH_ELEMENT_FROM(c_element, c_element, 1)\n    # collect all new namespace declarations into the ns list\n    if c_element.nsDef:\n        _collectNsDefs(c_element, &c_ns_list, &c_ns_list_len, &c_ns_list_size)\n\n    # remove all namespace declarations from the list that are referenced\n    if c_ns_list_len and c_element.type == tree.XML_ELEMENT_NODE:\n        c_node = c_element\n        while c_node and c_ns_list_len:\n            if c_node.ns:\n                for i in range(c_ns_list_len):\n                    if c_node.ns is c_ns_list[i].ns:\n                        c_ns_list_len -= 1\n                        c_ns_list[i] = c_ns_list[c_ns_list_len]\n                        #c_ns_list[c_ns_list_len] = _ns_node_ref(NULL, NULL)\n                        break\n            if c_node is c_element:\n                # continue with attributes\n                c_node = <xmlNode*>c_element.properties\n            else:\n                c_node = c_node.next\n    tree.END_FOR_EACH_ELEMENT_FROM(c_element)\n\n    if c_ns_list is NULL:\n        return 0\n\n    # free all namespace declarations that remained in the list,\n    # except for those we should keep explicitly\n    cdef xmlNs* c_nsdef\n    for i in range(c_ns_list_len):\n        if prefixes_to_keep is not None:\n            if c_ns_list[i].ns.prefix and c_ns_list[i].ns.prefix in prefixes_to_keep:\n                continue\n        c_node = c_ns_list[i].node\n        c_nsdef = c_node.nsDef\n        if c_nsdef is c_ns_list[i].ns:\n            c_node.nsDef = c_node.nsDef.next\n        else:\n            while c_nsdef.next is not c_ns_list[i].ns:\n                c_nsdef = c_nsdef.next\n            c_nsdef.next = c_nsdef.next.next\n        tree.xmlFreeNs(c_ns_list[i].ns)\n    \n    if c_ns_list is not NULL:\n        python.lxml_free(c_ns_list)\n    return 0\n\ncdef xmlNs* _searchNsByHref(xmlNode* c_node, const_xmlChar* c_href, bint is_attribute):\n    u\"\"\"Search a namespace declaration that covers a node (element or\n    attribute).\n\n    For attributes, try to find a prefixed namespace declaration\n    instead of the default namespaces.  This helps in supporting\n    round-trips for attributes on elements with a different namespace.\n    \"\"\"\n    cdef xmlNs* c_ns\n    cdef xmlNs* c_default_ns = NULL\n    cdef xmlNode* c_element\n    if c_href is NULL or c_node is NULL or c_node.type == tree.XML_ENTITY_REF_NODE:\n        return NULL\n    if tree.xmlStrcmp(c_href, tree.XML_XML_NAMESPACE) == 0:\n        # no special cases here, let libxml2 handle this\n        return tree.xmlSearchNsByHref(c_node.doc, c_node, c_href)\n    if c_node.type == tree.XML_ATTRIBUTE_NODE:\n        is_attribute = 1\n    while c_node is not NULL and c_node.type != tree.XML_ELEMENT_NODE:\n        c_node = c_node.parent\n    c_element = c_node\n    while c_node is not NULL:\n        if c_node.type == tree.XML_ELEMENT_NODE:\n            c_ns = c_node.nsDef\n            while c_ns is not NULL:\n                if c_ns.href is not NULL and tree.xmlStrcmp(c_href, c_ns.href) == 0:\n                    if c_ns.prefix is NULL and is_attribute:\n                        # for attributes, continue searching a named\n                        # prefix, but keep the first default namespace\n                        # declaration that we found\n                        if c_default_ns is NULL:\n                            c_default_ns = c_ns\n                    elif tree.xmlSearchNs(\n                        c_element.doc, c_element, c_ns.prefix) is c_ns:\n                        # start node is in namespace scope => found!\n                        return c_ns\n                c_ns = c_ns.next\n            if c_node is not c_element and c_node.ns is not NULL:\n                # optimise: the node may have the namespace itself\n                c_ns = c_node.ns\n                if c_ns.href is not NULL and tree.xmlStrcmp(c_href, c_ns.href) == 0:\n                    if c_ns.prefix is NULL and is_attribute:\n                        # for attributes, continue searching a named\n                        # prefix, but keep the first default namespace\n                        # declaration that we found\n                        if c_default_ns is NULL:\n                            c_default_ns = c_ns\n                    elif tree.xmlSearchNs(\n                        c_element.doc, c_element, c_ns.prefix) is c_ns:\n                        # start node is in namespace scope => found!\n                        return c_ns\n        c_node = c_node.parent\n    # nothing found => use a matching default namespace or fail\n    if c_default_ns is not NULL:\n        if tree.xmlSearchNs(c_element.doc, c_element, NULL) is c_default_ns:\n            return c_default_ns\n    return NULL\n\ncdef int _replaceNodeByChildren(_Document doc, xmlNode* c_node) except -1:\n    # NOTE: this does not deallocate the node, just unlink it!\n    cdef xmlNode* c_parent\n    cdef xmlNode* c_child\n    if c_node.children is NULL:\n        tree.xmlUnlinkNode(c_node)\n        return 0\n\n    c_parent = c_node.parent\n    # fix parent links of children\n    c_child = c_node.children\n    while c_child is not NULL:\n        c_child.parent = c_parent\n        c_child = c_child.next\n\n    # fix namespace references of children if their parent's namespace\n    # declarations get lost\n    if c_node.nsDef is not NULL:\n        c_child = c_node.children\n        while c_child is not NULL:\n            moveNodeToDocument(doc, doc._c_doc, c_child)\n            c_child = c_child.next\n\n    # fix sibling links to/from child slice\n    if c_node.prev is NULL:\n        c_parent.children = c_node.children\n    else:\n        c_node.prev.next = c_node.children\n        c_node.children.prev = c_node.prev\n    if c_node.next is NULL:\n        c_parent.last = c_node.last\n    else:\n        c_node.next.prev = c_node.last\n        c_node.last.next = c_node.next\n\n    # unlink c_node\n    c_node.children = c_node.last = NULL\n    c_node.parent = c_node.next = c_node.prev = NULL\n    return 0\n\ncdef object _attributeValue(xmlNode* c_element, xmlAttr* c_attrib_node):\n    c_href = _getNs(<xmlNode*>c_attrib_node)\n    value = tree.xmlGetNsProp(c_element, c_attrib_node.name, c_href)\n    try:\n        result = funicode(value)\n    finally:\n        tree.xmlFree(value)\n    return result\n\ncdef object _attributeValueFromNsName(xmlNode* c_element,\n                                      const_xmlChar* c_href, const_xmlChar* c_name):\n    c_result = tree.xmlGetNsProp(c_element, c_name, c_href)\n    if c_result is NULL:\n        return None\n    try:\n        result = funicode(c_result)\n    finally:\n        tree.xmlFree(c_result)\n    return result\n\ncdef object _getNodeAttributeValue(xmlNode* c_node, key, default):\n    ns, tag = _getNsTag(key)\n    c_href = <const_xmlChar*>NULL if ns is None else _xcstr(ns)\n    c_result = tree.xmlGetNsProp(c_node, _xcstr(tag), c_href)\n    if c_result is NULL:\n        # XXX free namespace that is not in use..?\n        return default\n    try:\n        result = funicode(c_result)\n    finally:\n        tree.xmlFree(c_result)\n    return result\n\ncdef inline object _getAttributeValue(_Element element, key, default):\n    return _getNodeAttributeValue(element._c_node, key, default)\n\ncdef int _setAttributeValue(_Element element, key, value) except -1:\n    cdef const_xmlChar* c_value\n    cdef xmlNs* c_ns\n    ns, tag = _getNsTag(key)\n    is_html = element._doc._parser._for_html\n    if not is_html:\n        _attributeValidOrRaise(tag)\n    c_tag = _xcstr(tag)\n    if value is None and is_html:\n        c_value = NULL\n    else:\n        if isinstance(value, QName):\n            value = _resolveQNameText(element, value)\n        else:\n            value = _utf8(value)\n        c_value = _xcstr(value)\n    if ns is None:\n        c_ns = NULL\n    else:\n        c_ns = element._doc._findOrBuildNodeNs(element._c_node, _xcstr(ns), NULL, 1)\n    tree.xmlSetNsProp(element._c_node, c_ns, c_tag, c_value)\n    return 0\n\ncdef int _delAttribute(_Element element, key) except -1:\n    ns, tag = _getNsTag(key)\n    c_href = <const_xmlChar*>NULL if ns is None else _xcstr(ns)\n    if _delAttributeFromNsName(element._c_node, c_href, _xcstr(tag)):\n        raise KeyError, key\n    return 0\n\ncdef int _delAttributeFromNsName(xmlNode* c_node, const_xmlChar* c_href, const_xmlChar* c_name):\n    c_attr = tree.xmlHasNsProp(c_node, c_name, c_href)\n    if c_attr is NULL:\n        # XXX free namespace that is not in use..?\n        return -1\n    tree.xmlRemoveProp(c_attr)\n    return 0\n\ncdef list _collectAttributes(xmlNode* c_node, int collecttype):\n    u\"\"\"Collect all attributes of a node in a list.  Depending on collecttype,\n    it collects either the name (1), the value (2) or the name-value tuples.\n    \"\"\"\n    cdef Py_ssize_t count\n    c_attr = c_node.properties\n    count = 0\n    while c_attr is not NULL:\n        if c_attr.type == tree.XML_ATTRIBUTE_NODE:\n            count += 1\n        c_attr = c_attr.next\n\n    if not count:\n        return []\n\n    attributes = [None] * count\n    c_attr = c_node.properties\n    count = 0\n    while c_attr is not NULL:\n        if c_attr.type == tree.XML_ATTRIBUTE_NODE:\n            if collecttype == 1:\n                item = _namespacedName(<xmlNode*>c_attr)\n            elif collecttype == 2:\n                item = _attributeValue(c_node, c_attr)\n            else:\n                item = (_namespacedName(<xmlNode*>c_attr),\n                        _attributeValue(c_node, c_attr))\n            attributes[count] = item\n            count += 1\n        c_attr = c_attr.next\n    return attributes\n\ncdef object __RE_XML_ENCODING = re.compile(\n    ur'^(<\\?xml[^>]+)\\s+encoding\\s*=\\s*[\"\\'][^\"\\']*[\"\\'](\\s*\\?>|)', re.U)\n\ncdef object __REPLACE_XML_ENCODING = __RE_XML_ENCODING.sub\ncdef object __HAS_XML_ENCODING = __RE_XML_ENCODING.match\n\ncdef object _stripEncodingDeclaration(object xml_string):\n    # this is a hack to remove the XML encoding declaration from unicode\n    return __REPLACE_XML_ENCODING(ur'\\g<1>\\g<2>', xml_string)\n\ncdef bint _hasEncodingDeclaration(object xml_string) except -1:\n    # check if a (unicode) string has an XML encoding declaration\n    return __HAS_XML_ENCODING(xml_string) is not None\n\ncdef inline bint _hasText(xmlNode* c_node):\n    return c_node is not NULL and _textNodeOrSkip(c_node.children) is not NULL\n\ncdef inline bint _hasTail(xmlNode* c_node):\n    return c_node is not NULL and _textNodeOrSkip(c_node.next) is not NULL\n\ncdef inline bint _hasNonWhitespaceTail(xmlNode* c_node):\n    return _hasNonWhitespaceText(c_node, tail=True)\n\ncdef bint _hasNonWhitespaceText(xmlNode* c_node, bint tail=False):\n    c_text_node = c_node and _textNodeOrSkip(c_node.next if tail else c_node.children)\n    if c_text_node is NULL:\n        return False\n    while c_text_node is not NULL:\n        if c_text_node.content[0] != c'\\0' and not _collectText(c_text_node).isspace():\n            return True\n        c_text_node = _textNodeOrSkip(c_text_node.next)\n    return False\n\ncdef _collectText(xmlNode* c_node):\n    u\"\"\"Collect all text nodes and return them as a unicode string.\n\n    Start collecting at c_node.\n    \n    If there was no text to collect, return None\n    \"\"\"\n    cdef Py_ssize_t scount\n    cdef xmlChar* c_text\n    cdef xmlNode* c_node_cur\n    # check for multiple text nodes\n    scount = 0\n    c_text = NULL\n    c_node_cur = c_node = _textNodeOrSkip(c_node)\n    while c_node_cur is not NULL:\n        if c_node_cur.content[0] != c'\\0':\n            c_text = c_node_cur.content\n        scount += 1\n        c_node_cur = _textNodeOrSkip(c_node_cur.next)\n\n    # handle two most common cases first\n    if c_text is NULL:\n        return '' if scount > 0 else None\n    if scount == 1:\n        return funicode(c_text)\n\n    # the rest is not performance critical anymore\n    result = b''\n    while c_node is not NULL:\n        result += <unsigned char*>c_node.content\n        c_node = _textNodeOrSkip(c_node.next)\n    return funicode(<const_xmlChar*><unsigned char*>result)\n\ncdef void _removeText(xmlNode* c_node):\n    u\"\"\"Remove all text nodes.\n\n    Start removing at c_node.\n    \"\"\"\n    cdef xmlNode* c_next\n    c_node = _textNodeOrSkip(c_node)\n    while c_node is not NULL:\n        c_next = _textNodeOrSkip(c_node.next)\n        tree.xmlUnlinkNode(c_node)\n        tree.xmlFreeNode(c_node)\n        c_node = c_next\n\ncdef xmlNode* _createTextNode(xmlDoc* doc, value) except NULL:\n    cdef xmlNode* c_text_node\n    if isinstance(value, CDATA):\n        c_text_node = tree.xmlNewCDataBlock(\n            doc, _xcstr((<CDATA>value)._utf8_data),\n            python.PyBytes_GET_SIZE((<CDATA>value)._utf8_data))\n    else:\n        text = _utf8(value)\n        c_text_node = tree.xmlNewDocText(doc, _xcstr(text))\n    if not c_text_node:\n        raise MemoryError()\n    return c_text_node\n\ncdef int _setNodeText(xmlNode* c_node, value) except -1:\n    # remove all text nodes at the start first\n    _removeText(c_node.children)\n    if value is None:\n        return 0\n    # now add new text node with value at start\n    c_text_node = _createTextNode(c_node.doc, value)\n    if c_node.children is NULL:\n        tree.xmlAddChild(c_node, c_text_node)\n    else:\n        tree.xmlAddPrevSibling(c_node.children, c_text_node)\n    return 0\n\ncdef int _setTailText(xmlNode* c_node, value) except -1:\n    # remove all text nodes at the start first\n    _removeText(c_node.next)\n    if value is None:\n        return 0\n    # now append new text node with value\n    c_text_node = _createTextNode(c_node.doc, value)\n    tree.xmlAddNextSibling(c_node, c_text_node)\n    return 0\n\ncdef bytes _resolveQNameText(_Element element, value):\n    cdef xmlNs* c_ns\n    ns, tag = _getNsTag(value)\n    if ns is None:\n        return tag\n    else:\n        c_ns = element._doc._findOrBuildNodeNs(\n            element._c_node, _xcstr(ns), NULL, 0)\n        return python.PyBytes_FromFormat('%s:%s', c_ns.prefix, _cstr(tag))\n\ncdef inline bint _hasChild(xmlNode* c_node):\n    return c_node is not NULL and _findChildForwards(c_node, 0) is not NULL\n\ncdef inline Py_ssize_t _countElements(xmlNode* c_node):\n    u\"Counts the elements within the following siblings and the node itself.\"\n    cdef Py_ssize_t count\n    count = 0\n    while c_node is not NULL:\n        if _isElement(c_node):\n            count += 1\n        c_node = c_node.next\n    return count\n\ncdef int _findChildSlice(\n    slice sliceobject, xmlNode* c_parent,\n    xmlNode** c_start_node, Py_ssize_t* c_step, Py_ssize_t* c_length) except -1:\n    u\"\"\"Resolve a children slice.\n\n    Returns the start node, step size and the slice length in the\n    pointer arguments.\n    \"\"\"\n    cdef Py_ssize_t start = 0, stop = 0, childcount\n    childcount = _countElements(c_parent.children)\n    if childcount == 0:\n        c_start_node[0] = NULL\n        c_length[0] = 0\n        if sliceobject.step is None:\n            c_step[0] = 1\n        else:\n            python._PyEval_SliceIndex(sliceobject.step, c_step)\n        return 0\n    python.PySlice_GetIndicesEx(\n        sliceobject, childcount, &start, &stop, c_step, c_length)\n    if start > childcount / 2:\n        c_start_node[0] = _findChildBackwards(c_parent, childcount - start - 1)\n    else:\n        c_start_node[0] = _findChild(c_parent, start)\n    return 0\n\ncdef bint _isFullSlice(slice sliceobject) except -1:\n    u\"\"\"Conservative guess if this slice is a full slice as in ``s[:]``.\n    \"\"\"\n    cdef Py_ssize_t step = 0\n    if sliceobject is None:\n        return 0\n    if sliceobject.start is None and \\\n            sliceobject.stop is None:\n        if sliceobject.step is None:\n            return 1\n        python._PyEval_SliceIndex(sliceobject.step, &step)\n        if step == 1:\n            return 1\n        return 0\n    return 0\n\ncdef _collectChildren(_Element element):\n    cdef xmlNode* c_node\n    cdef list result = []\n    c_node = element._c_node.children\n    if c_node is not NULL:\n        if not _isElement(c_node):\n            c_node = _nextElement(c_node)\n        while c_node is not NULL:\n            result.append(_elementFactory(element._doc, c_node))\n            c_node = _nextElement(c_node)\n    return result\n\ncdef inline xmlNode* _findChild(xmlNode* c_node, Py_ssize_t index):\n    if index < 0:\n        return _findChildBackwards(c_node, -index - 1)\n    else:\n        return _findChildForwards(c_node, index)\n    \ncdef inline xmlNode* _findChildForwards(xmlNode* c_node, Py_ssize_t index):\n    u\"\"\"Return child element of c_node with index, or return NULL if not found.\n    \"\"\"\n    cdef xmlNode* c_child\n    cdef Py_ssize_t c\n    c_child = c_node.children\n    c = 0\n    while c_child is not NULL:\n        if _isElement(c_child):\n            if c == index:\n                return c_child\n            c += 1\n        c_child = c_child.next\n    return NULL\n\ncdef inline xmlNode* _findChildBackwards(xmlNode* c_node, Py_ssize_t index):\n    u\"\"\"Return child element of c_node with index, or return NULL if not found.\n    Search from the end.\n    \"\"\"\n    cdef xmlNode* c_child\n    cdef Py_ssize_t c\n    c_child = c_node.last\n    c = 0\n    while c_child is not NULL:\n        if _isElement(c_child):\n            if c == index:\n                return c_child\n            c += 1\n        c_child = c_child.prev\n    return NULL\n    \ncdef inline xmlNode* _textNodeOrSkip(xmlNode* c_node) nogil:\n    u\"\"\"Return the node if it's a text node.  Skip over ignorable nodes in a\n    series of text nodes.  Return NULL if a non-ignorable node is found.\n\n    This is used to skip over XInclude nodes when collecting adjacent text\n    nodes.\n    \"\"\"\n    while c_node is not NULL:\n        if c_node.type == tree.XML_TEXT_NODE or \\\n               c_node.type == tree.XML_CDATA_SECTION_NODE:\n            return c_node\n        elif c_node.type == tree.XML_XINCLUDE_START or \\\n                 c_node.type == tree.XML_XINCLUDE_END:\n            c_node = c_node.next\n        else:\n            return NULL\n    return NULL\n\ncdef inline xmlNode* _nextElement(xmlNode* c_node):\n    u\"\"\"Given a node, find the next sibling that is an element.\n    \"\"\"\n    if c_node is NULL:\n        return NULL\n    c_node = c_node.next\n    while c_node is not NULL:\n        if _isElement(c_node):\n            return c_node\n        c_node = c_node.next\n    return NULL\n\ncdef inline xmlNode* _previousElement(xmlNode* c_node):\n    u\"\"\"Given a node, find the next sibling that is an element.\n    \"\"\"\n    if c_node is NULL:\n        return NULL\n    c_node = c_node.prev\n    while c_node is not NULL:\n        if _isElement(c_node):\n            return c_node\n        c_node = c_node.prev\n    return NULL\n\ncdef inline xmlNode* _parentElement(xmlNode* c_node):\n    u\"Given a node, find the parent element.\"\n    if c_node is NULL or not _isElement(c_node):\n        return NULL\n    c_node = c_node.parent\n    if c_node is NULL or not _isElement(c_node):\n        return NULL\n    return c_node\n\ncdef inline bint _tagMatches(xmlNode* c_node, const_xmlChar* c_href, const_xmlChar* c_name):\n    u\"\"\"Tests if the node matches namespace URI and tag name.\n\n    A node matches if it matches both c_href and c_name.\n\n    A node matches c_href if any of the following is true:\n    * c_href is NULL\n    * its namespace is NULL and c_href is the empty string\n    * its namespace string equals the c_href string\n\n    A node matches c_name if any of the following is true:\n    * c_name is NULL\n    * its name string equals the c_name string\n    \"\"\"\n    if c_node is NULL:\n        return 0\n    if c_node.type != tree.XML_ELEMENT_NODE:\n        # not an element, only succeed if we match everything\n        return c_name is NULL and c_href is NULL\n    if c_name is NULL:\n        if c_href is NULL:\n            # always match\n            return 1\n        else:\n            c_node_href = _getNs(c_node)\n            if c_node_href is NULL:\n                return c_href[0] == c'\\0'\n            else:\n                return tree.xmlStrcmp(c_node_href, c_href) == 0\n    elif c_href is NULL:\n        if _getNs(c_node) is not NULL:\n            return 0\n        return c_node.name == c_name or tree.xmlStrcmp(c_node.name, c_name) == 0\n    elif c_node.name == c_name or tree.xmlStrcmp(c_node.name, c_name) == 0:\n        c_node_href = _getNs(c_node)\n        if c_node_href is NULL:\n            return c_href[0] == c'\\0'\n        else:\n            return tree.xmlStrcmp(c_node_href, c_href) == 0\n    else:\n        return 0\n\ncdef inline bint _tagMatchesExactly(xmlNode* c_node, qname* c_qname):\n    u\"\"\"Tests if the node matches namespace URI and tag name.\n\n    This differs from _tagMatches() in that it does not consider a\n    NULL value in qname.href a wildcard, and that it expects the c_name\n    to be taken from the doc dict, i.e. it only compares the names by\n    address.\n\n    A node matches if it matches both href and c_name of the qname.\n\n    A node matches c_href if any of the following is true:\n    * its namespace is NULL and c_href is the empty string\n    * its namespace string equals the c_href string\n\n    A node matches c_name if any of the following is true:\n    * c_name is NULL\n    * its name string points to the same address (!) as c_name\n    \"\"\"\n    return _nsTagMatchesExactly(_getNs(c_node), c_node.name, c_qname)\n\ncdef inline bint _nsTagMatchesExactly(const_xmlChar* c_node_href,\n                                      const_xmlChar* c_node_name,\n                                      qname* c_qname):\n    u\"\"\"Tests if name and namespace URI match those of c_qname.\n\n    This differs from _tagMatches() in that it does not consider a\n    NULL value in qname.href a wildcard, and that it expects the c_name\n    to be taken from the doc dict, i.e. it only compares the names by\n    address.\n\n    A node matches if it matches both href and c_name of the qname.\n\n    A node matches c_href if any of the following is true:\n    * its namespace is NULL and c_href is the empty string\n    * its namespace string equals the c_href string\n\n    A node matches c_name if any of the following is true:\n    * c_name is NULL\n    * its name string points to the same address (!) as c_name\n    \"\"\"\n    cdef char* c_href\n    if c_qname.c_name is not NULL and c_qname.c_name is not c_node_name:\n        return 0\n    if c_qname.href is NULL:\n        return 1\n    c_href = python.__cstr(c_qname.href)\n    if c_href[0] == '\\0':\n        return c_node_href is NULL or c_node_href[0] == '\\0'\n    elif c_node_href is NULL:\n        return 0\n    else:\n        return tree.xmlStrcmp(<const_xmlChar*>c_href, c_node_href) == 0\n\ncdef Py_ssize_t _mapTagsToQnameMatchArray(xmlDoc* c_doc, list ns_tags,\n                                          qname* c_ns_tags, bint force_into_dict) except -1:\n    u\"\"\"Map a sequence of (name, namespace) pairs to a qname array for efficient\n    matching with _tagMatchesExactly() above.\n\n    Note that each qname struct in the array owns its href byte string object\n    if it is not NULL.\n    \"\"\"\n    cdef Py_ssize_t count = 0, i\n    cdef bytes ns, tag\n    for ns, tag in ns_tags:\n        if tag is None:\n            c_tag = <const_xmlChar*>NULL\n        elif force_into_dict:\n            c_tag = tree.xmlDictLookup(c_doc.dict, _xcstr(tag), len(tag))\n            if c_tag is NULL:\n                # clean up before raising the error\n                for i in xrange(count):\n                    cpython.ref.Py_XDECREF(c_ns_tags[i].href)\n                raise MemoryError()\n        else:\n            c_tag = tree.xmlDictExists(c_doc.dict, _xcstr(tag), len(tag))\n            if c_tag is NULL:\n                # not in the dict => not in the document\n                continue\n        c_ns_tags[count].c_name = c_tag\n        if ns is None:\n            c_ns_tags[count].href = NULL\n        else:\n            cpython.ref.Py_INCREF(ns) # keep an owned reference!\n            c_ns_tags[count].href = <python.PyObject*>ns\n        count += 1\n    return count\n\ncdef int _removeNode(_Document doc, xmlNode* c_node) except -1:\n    u\"\"\"Unlink and free a node and subnodes if possible.  Otherwise, make sure\n    it's self-contained.\n    \"\"\"\n    cdef xmlNode* c_next\n    c_next = c_node.next\n    tree.xmlUnlinkNode(c_node)\n    _moveTail(c_next, c_node)\n    if not attemptDeallocation(c_node):\n        # make namespaces absolute\n        moveNodeToDocument(doc, c_node.doc, c_node)\n    return 0\n\ncdef int _removeSiblings(xmlNode* c_element, tree.xmlElementType node_type, bint with_tail) except -1:\n    cdef xmlNode* c_node\n    cdef xmlNode* c_next\n    c_node = c_element.next\n    while c_node is not NULL:\n        c_next = _nextElement(c_node)\n        if c_node.type == node_type:\n            if with_tail:\n                _removeText(c_node.next)\n            tree.xmlUnlinkNode(c_node)\n            attemptDeallocation(c_node)\n        c_node = c_next\n    c_node = c_element.prev\n    while c_node is not NULL:\n        c_next = _previousElement(c_node)\n        if c_node.type == node_type:\n            if with_tail:\n                _removeText(c_node.next)\n            tree.xmlUnlinkNode(c_node)\n            attemptDeallocation(c_node)\n        c_node = c_next\n    return 0\n\ncdef void _moveTail(xmlNode* c_tail, xmlNode* c_target):\n    cdef xmlNode* c_next\n    # tail support: look for any text nodes trailing this node and \n    # move them too\n    c_tail = _textNodeOrSkip(c_tail)\n    while c_tail is not NULL:\n        c_next = _textNodeOrSkip(c_tail.next)\n        c_target = tree.xmlAddNextSibling(c_target, c_tail)\n        c_tail = c_next\n\ncdef int _copyTail(xmlNode* c_tail, xmlNode* c_target) except -1:\n    cdef xmlNode* c_new_tail\n    # tail copying support: look for any text nodes trailing this node and\n    # copy it to the target node\n    c_tail = _textNodeOrSkip(c_tail)\n    while c_tail is not NULL:\n        if c_target.doc is not c_tail.doc:\n            c_new_tail = tree.xmlDocCopyNode(c_tail, c_target.doc, 0)\n        else:\n            c_new_tail = tree.xmlCopyNode(c_tail, 0)\n        if c_new_tail is NULL:\n            raise MemoryError()\n        c_target = tree.xmlAddNextSibling(c_target, c_new_tail)\n        c_tail = _textNodeOrSkip(c_tail.next)\n    return 0\n\ncdef int _copyNonElementSiblings(xmlNode* c_node, xmlNode* c_target) except -1:\n    cdef xmlNode* c_copy\n    cdef xmlNode* c_sibling = c_node\n    while c_sibling.prev != NULL and \\\n            (c_sibling.prev.type == tree.XML_PI_NODE or\n             c_sibling.prev.type == tree.XML_COMMENT_NODE or\n             c_sibling.prev.type == tree.XML_DTD_NODE):\n        c_sibling = c_sibling.prev\n    while c_sibling != c_node:\n        if c_sibling.type == tree.XML_DTD_NODE:\n            c_copy = <xmlNode*>_copyDtd(<tree.xmlDtd*>c_sibling)\n            if c_sibling == <xmlNode*>c_node.doc.intSubset:\n                c_target.doc.intSubset = <tree.xmlDtd*>c_copy\n            else: # c_sibling == c_node.doc.extSubset\n                c_target.doc.extSubset = <tree.xmlDtd*>c_copy\n        else:\n            c_copy = tree.xmlDocCopyNode(c_sibling, c_target.doc, 1)\n            if c_copy is NULL:\n                raise MemoryError()\n        tree.xmlAddPrevSibling(c_target, c_copy)\n        c_sibling = c_sibling.next\n    while c_sibling.next != NULL and \\\n            (c_sibling.next.type == tree.XML_PI_NODE or\n             c_sibling.next.type == tree.XML_COMMENT_NODE):\n        c_sibling = c_sibling.next\n        c_copy = tree.xmlDocCopyNode(c_sibling, c_target.doc, 1)\n        if c_copy is NULL:\n            raise MemoryError()\n        tree.xmlAddNextSibling(c_target, c_copy)\n\ncdef int _deleteSlice(_Document doc, xmlNode* c_node,\n                      Py_ssize_t count, Py_ssize_t step) except -1:\n    u\"\"\"Delete slice, ``count`` items starting with ``c_node`` with a step\n    width of ``step``.\n    \"\"\"\n    cdef xmlNode* c_next\n    cdef Py_ssize_t c, i\n    cdef _node_to_node_function next_element\n    if c_node is NULL:\n        return 0\n    if step > 0:\n        next_element = _nextElement\n    else:\n        step = -step\n        next_element = _previousElement\n    # now start deleting nodes\n    c = 0\n    c_next = c_node\n    while c_node is not NULL and c < count:\n        for i in range(step):\n            c_next = next_element(c_next)\n            if c_next is NULL:\n                break\n        _removeNode(doc, c_node)\n        c += 1\n        c_node = c_next\n    return 0\n\ncdef int _replaceSlice(_Element parent, xmlNode* c_node,\n                       Py_ssize_t slicelength, Py_ssize_t step,\n                       bint left_to_right, elements) except -1:\n    u\"\"\"Replace the slice of ``count`` elements starting at ``c_node`` with\n    positive step width ``step`` by the Elements in ``elements``.  The\n    direction is given by the boolean argument ``left_to_right``.\n\n    ``c_node`` may be NULL to indicate the end of the children list.\n    \"\"\"\n    cdef xmlNode* c_orig_neighbour\n    cdef xmlNode* c_next\n    cdef xmlDoc*  c_source_doc\n    cdef _Element element\n    cdef Py_ssize_t seqlength, i, c\n    cdef _node_to_node_function next_element\n    assert step > 0\n    if left_to_right:\n        next_element = _nextElement\n    else:\n        next_element = _previousElement\n\n    if not isinstance(elements, (list, tuple)):\n        elements = list(elements)\n\n    if step != 1 or not left_to_right:\n        # *replacing* children stepwise with list => check size!\n        seqlength = len(elements)\n        if seqlength != slicelength:\n            raise ValueError, f\"attempt to assign sequence of size {seqlength} \" \\\n                f\"to extended slice of size {slicelength}\"\n\n    if c_node is NULL:\n        # no children yet => add all elements straight away\n        if left_to_right:\n            for element in elements:\n                assert element is not None, u\"Node must not be None\"\n                _appendChild(parent, element)\n        else:\n            for element in elements:\n                assert element is not None, u\"Node must not be None\"\n                _prependChild(parent, element)\n        return 0\n\n    # remove the elements first as some might be re-added\n    if left_to_right:\n        # L->R, remember left neighbour\n        c_orig_neighbour = _previousElement(c_node)\n    else:\n        # R->L, remember right neighbour\n        c_orig_neighbour = _nextElement(c_node)\n\n    # We remove the original slice elements one by one. Since we hold\n    # a Python reference to all elements that we will insert, it is\n    # safe to let _removeNode() try (and fail) to free them even if\n    # the element itself or one of its descendents will be reinserted.\n    c = 0\n    c_next = c_node\n    while c_node is not NULL and c < slicelength:\n        for i in range(step):\n            c_next = next_element(c_next)\n            if c_next is NULL:\n                break\n        _removeNode(parent._doc, c_node)\n        c += 1\n        c_node = c_next\n\n    # make sure each element is inserted only once\n    elements = iter(elements)\n\n    # find the first node right of the new insertion point\n    if left_to_right:\n        if c_orig_neighbour is not NULL:\n            c_node = next_element(c_orig_neighbour)\n        else:\n            # before the first element\n            c_node = _findChildForwards(parent._c_node, 0)\n    elif c_orig_neighbour is NULL:\n        # at the end, but reversed stepping\n        # append one element and go to the next insertion point\n        for element in elements:\n            assert element is not None, u\"Node must not be None\"\n            _appendChild(parent, element)\n            c_node = element._c_node\n            if slicelength > 0:\n                slicelength -= 1\n                for i in range(1, step):\n                    c_node = next_element(c_node)\n                    if c_node is NULL:\n                        break\n            break\n    else:\n        c_node = c_orig_neighbour\n\n    if left_to_right:\n        # adjust step size after removing slice as we are not stepping\n        # over the newly inserted elements\n        step -= 1\n\n    # now insert elements where we removed them\n    if c_node is not NULL:\n        for element in elements:\n            assert element is not None, u\"Node must not be None\"\n            _assertValidNode(element)\n            # move element and tail over\n            c_source_doc = element._c_node.doc\n            c_next = element._c_node.next\n            tree.xmlAddPrevSibling(c_node, element._c_node)\n            _moveTail(c_next, element._c_node)\n\n            # integrate element into new document\n            moveNodeToDocument(parent._doc, c_source_doc, element._c_node)\n\n            # stop at the end of the slice\n            if slicelength > 0:\n                slicelength -= 1\n                for i in range(step):\n                    c_node = next_element(c_node)\n                    if c_node is NULL:\n                        break\n                if c_node is NULL:\n                    break\n        else:\n            # everything inserted\n            return 0\n\n    # append the remaining elements at the respective end\n    if left_to_right:\n        for element in elements:\n            assert element is not None, u\"Node must not be None\"\n            _assertValidNode(element)\n            _appendChild(parent, element)\n    else:\n        for element in elements:\n            assert element is not None, u\"Node must not be None\"\n            _assertValidNode(element)\n            _prependChild(parent, element)\n\n    return 0\n\n\ncdef int _linkChild(xmlNode* c_parent, xmlNode* c_node) except -1:\n    \"\"\"Adaptation of 'xmlAddChild()' that deep-fix the document links iteratively.\n    \"\"\"\n    assert _isElement(c_node)\n    c_node.parent = c_parent\n    if c_parent.children is NULL:\n        c_parent.children = c_parent.last = c_node\n    else:\n        c_node.prev = c_parent.last\n        c_parent.last.next = c_node\n        c_parent.last = c_node\n\n    _setTreeDoc(c_node, c_parent.doc)\n    return 0\n\n\ncdef int _appendChild(_Element parent, _Element child) except -1:\n    u\"\"\"Append a new child to a parent element.\n    \"\"\"\n    c_node = child._c_node\n    c_source_doc = c_node.doc\n    # prevent cycles\n    if _isAncestorOrSame(c_node, parent._c_node):\n        raise ValueError(\"cannot append parent to itself\")\n    # store possible text node\n    c_next = c_node.next\n    # move node itself\n    tree.xmlUnlinkNode(c_node)\n    # do not call xmlAddChild() here since it would deep-traverse the tree\n    _linkChild(parent._c_node, c_node)\n    _moveTail(c_next, c_node)\n    # uh oh, elements may be pointing to different doc when\n    # parent element has moved; change them too..\n    moveNodeToDocument(parent._doc, c_source_doc, c_node)\n    return 0\n\ncdef int _prependChild(_Element parent, _Element child) except -1:\n    u\"\"\"Prepend a new child to a parent element.\n    \"\"\"\n    c_node = child._c_node\n    c_source_doc = c_node.doc\n    # prevent cycles\n    if _isAncestorOrSame(c_node, parent._c_node):\n        raise ValueError(\"cannot append parent to itself\")\n    # store possible text node\n    c_next = c_node.next\n    # move node itself\n    c_child = _findChildForwards(parent._c_node, 0)\n    if c_child is NULL:\n        tree.xmlUnlinkNode(c_node)\n        # do not call xmlAddChild() here since it would deep-traverse the tree\n        _linkChild(parent._c_node, c_node)\n    else:\n        tree.xmlAddPrevSibling(c_child, c_node)\n    _moveTail(c_next, c_node)\n    # uh oh, elements may be pointing to different doc when\n    # parent element has moved; change them too..\n    moveNodeToDocument(parent._doc, c_source_doc, c_node)\n    return 0\n\ncdef int _appendSibling(_Element element, _Element sibling) except -1:\n    u\"\"\"Add a new sibling behind an element.\n    \"\"\"\n    return _addSibling(element, sibling, as_next=True)\n\ncdef int _prependSibling(_Element element, _Element sibling) except -1:\n    u\"\"\"Add a new sibling before an element.\n    \"\"\"\n    return _addSibling(element, sibling, as_next=False)\n\ncdef int _addSibling(_Element element, _Element sibling, bint as_next) except -1:\n    c_node = sibling._c_node\n    c_source_doc = c_node.doc\n    # prevent cycles\n    if _isAncestorOrSame(c_node, element._c_node):\n        if element._c_node is c_node:\n            return 0  # nothing to do\n        raise ValueError(\"cannot add ancestor as sibling, please break cycle first\")\n    # store possible text node\n    c_next = c_node.next\n    # move node itself\n    if as_next:\n        tree.xmlAddNextSibling(element._c_node, c_node)\n    else:\n        tree.xmlAddPrevSibling(element._c_node, c_node)\n    _moveTail(c_next, c_node)\n    # uh oh, elements may be pointing to different doc when\n    # parent element has moved; change them too..\n    moveNodeToDocument(element._doc, c_source_doc, c_node)\n    return 0\n\ncdef inline bint isutf8(const_xmlChar* s):\n    cdef xmlChar c = s[0]\n    while c != c'\\0':\n        if c & 0x80:\n            return True\n        s += 1\n        c = s[0]\n    return False\n\ncdef bint isutf8l(const_xmlChar* s, size_t length):\n    \"\"\"\n    Search for non-ASCII characters in the string, knowing its length in advance.\n    \"\"\"\n    cdef unsigned int i\n    cdef unsigned long non_ascii_mask\n    cdef const unsigned long *lptr = <const unsigned long*> s\n\n    cdef const unsigned long *end = lptr + length // sizeof(unsigned long)\n    if length >= sizeof(non_ascii_mask):\n        # Build constant 0x80808080... mask (and let the C compiler fold it).\n        non_ascii_mask = 0\n        for i in range(sizeof(non_ascii_mask) // 2):\n            non_ascii_mask = (non_ascii_mask << 16) | 0x8080\n\n        # Advance to long-aligned character before we start reading longs.\n        while (<size_t>s) % sizeof(unsigned long) and s < <const_xmlChar *>end:\n            if s[0] & 0x80:\n                return True\n            s += 1\n\n        # Read one long at a time\n        lptr = <const unsigned long*> s\n        while lptr < end:\n            if lptr[0] & non_ascii_mask:\n                return True\n            lptr += 1\n        s = <const_xmlChar *>lptr\n\n    while s < (<const_xmlChar *>end + length % sizeof(unsigned long)):\n        if s[0] & 0x80:\n            return True\n        s += 1\n\n    return False\n\ncdef int _is_valid_xml_ascii(bytes pystring):\n    \"\"\"Check if a string is XML ascii content.\"\"\"\n    cdef signed char ch\n    # When ch is a *signed* char, non-ascii characters are negative integers\n    # and xmlIsChar_ch does not accept them.\n    for ch in pystring:\n        if not tree.xmlIsChar_ch(ch):\n            return 0\n    return 1\n\ncdef bint _is_valid_xml_utf8(bytes pystring):\n    u\"\"\"Check if a string is like valid UTF-8 XML content.\"\"\"\n    cdef const_xmlChar* s = _xcstr(pystring)\n    cdef const_xmlChar* c_end = s + len(pystring)\n    cdef unsigned long next3 = 0\n    if s < c_end - 2:\n        next3 = (s[0] << 8) | (s[1])\n\n    while s < c_end - 2:\n        next3 = 0x00ffffff & ((next3 << 8) | s[2])\n        if s[0] & 0x80:\n            # 0xefbfbe and 0xefbfbf are utf-8 encodings of\n            # forbidden characters \\ufffe and \\uffff\n            if next3 == 0x00efbfbe or next3 == 0x00efbfbf:\n                return 0\n            # 0xeda080 and 0xedbfbf are utf-8 encodings of\n            # \\ud800 and \\udfff. Anything between them (inclusive)\n            # is forbidden, because they are surrogate blocks in utf-16.\n            if 0x00eda080 <= next3 <= 0x00edbfbf:\n                return 0\n        elif not tree.xmlIsChar_ch(s[0]):\n            return 0  # invalid ascii char\n        s += 1\n\n    while s < c_end:\n        if not s[0] & 0x80 and not tree.xmlIsChar_ch(s[0]):\n            return 0  # invalid ascii char\n        s += 1\n\n    return 1\n\ncdef inline object funicodeOrNone(const_xmlChar* s):\n    return funicode(s) if s is not NULL else None\n\ncdef inline object funicodeOrEmpty(const_xmlChar* s):\n    return funicode(s) if s is not NULL else ''\n\ncdef object funicode(const_xmlChar* s):\n    cdef Py_ssize_t slen\n    cdef const_xmlChar* spos\n    cdef bint is_non_ascii\n    if python.LXML_UNICODE_STRINGS:\n        return s.decode('UTF-8')\n    spos = s\n    is_non_ascii = 0\n    while spos[0] != c'\\0':\n        if spos[0] & 0x80:\n            is_non_ascii = 1\n            break\n        spos += 1\n    slen = spos - s\n    if spos[0] != c'\\0':\n        slen += cstring_h.strlen(<const char*> spos)\n    if is_non_ascii:\n        return s[:slen].decode('UTF-8')\n    return <bytes>s[:slen]\n\ncdef bytes _utf8(object s):\n    \"\"\"Test if a string is valid user input and encode it to UTF-8.\n    Reject all bytes/unicode input that contains non-XML characters.\n    Reject all bytes input that contains non-ASCII characters.\n    \"\"\"\n    cdef int valid\n    cdef bytes utf8_string\n    if python.IS_PYTHON2 and type(s) is bytes:\n        utf8_string = <bytes>s\n        valid = _is_valid_xml_ascii(utf8_string)\n    elif isinstance(s, unicode):\n        utf8_string = (<unicode>s).encode('utf8')\n        valid = _is_valid_xml_utf8(utf8_string)\n    elif isinstance(s, (bytes, bytearray)):\n        utf8_string = bytes(s)\n        valid = _is_valid_xml_ascii(utf8_string)\n    else:\n        raise TypeError(\"Argument must be bytes or unicode, got '%.200s'\" % type(s).__name__)\n    if not valid:\n        raise ValueError(\n            \"All strings must be XML compatible: Unicode or ASCII, no NULL bytes or control characters\")\n    return utf8_string\n\n\ncdef bytes _utf8orNone(object s):\n    return _utf8(s) if s is not None else None\n\n\ncdef strrepr(s):\n    \"\"\"Build a representation of strings which we can use in __repr__\n    methods, e.g. _Element.__repr__().\n    \"\"\"\n    return s.encode('unicode-escape') if python.IS_PYTHON2 else s\n\n\ncdef enum:\n    NO_FILE_PATH = 0\n    ABS_UNIX_FILE_PATH = 1\n    ABS_WIN_FILE_PATH = 2\n    REL_FILE_PATH = 3\n\n\ncdef bint _isFilePath(const_xmlChar* c_path):\n    u\"simple heuristic to see if a path is a filename\"\n    cdef xmlChar c\n    # test if it looks like an absolute Unix path or a Windows network path\n    if c_path[0] == c'/':\n        return ABS_UNIX_FILE_PATH\n\n    # test if it looks like an absolute Windows path or URL\n    if c'a' <= c_path[0] <= c'z' or c'A' <= c_path[0] <= c'Z':\n        c_path += 1\n        if c_path[0] == c':' and c_path[1] in b'\\0\\\\':\n            return ABS_WIN_FILE_PATH  # C: or C:\\...\n\n        # test if it looks like a URL with scheme://\n        while c'a' <= c_path[0] <= c'z' or c'A' <= c_path[0] <= c'Z':\n            c_path += 1\n        if c_path[0] == c':' and c_path[1] == c'/' and c_path[2] == c'/':\n            return NO_FILE_PATH\n\n    # assume it's a relative path\n    return REL_FILE_PATH\n\ncdef object _NO_FSPATH = object()\n\ncdef object _getFSPathOrObject(object obj):\n    \"\"\"\n    Get the __fspath__ attribute of an object if it exists.\n    Otherwise, the original object is returned.\n    \"\"\"\n    if _isString(obj):\n        return obj\n    if python.PY_VERSION_HEX >= 0x03060000:\n        try:\n            return python.PY_FSPath(obj)\n        except TypeError:\n            return obj\n    fspath = getattr(obj, '__fspath__', _NO_FSPATH)\n    if fspath is not _NO_FSPATH and callable(fspath):\n        return fspath()\n    return obj\n\ncdef object _encodeFilename(object filename):\n    u\"\"\"Make sure a filename is 8-bit encoded (or None).\n    \"\"\"\n    if filename is None:\n        return None\n    elif isinstance(filename, bytes):\n        return filename\n    elif isinstance(filename, unicode):\n        filename8 = (<unicode>filename).encode('utf8')\n        if _isFilePath(<unsigned char*>filename8):\n            try:\n                return python.PyUnicode_AsEncodedString(\n                    filename, _C_FILENAME_ENCODING, NULL)\n            except UnicodeEncodeError:\n                pass\n        return filename8\n    else:\n        raise TypeError(\"Argument must be string or unicode.\")\n\ncdef object _decodeFilename(const_xmlChar* c_path):\n    u\"\"\"Make the filename a unicode string if we are in Py3.\n    \"\"\"\n    return _decodeFilenameWithLength(c_path, tree.xmlStrlen(c_path))\n\ncdef object _decodeFilenameWithLength(const_xmlChar* c_path, size_t c_len):\n    u\"\"\"Make the filename a unicode string if we are in Py3.\n    \"\"\"\n    if _isFilePath(c_path):\n        try:\n            return python.PyUnicode_Decode(\n                <const_char*>c_path, c_len, _C_FILENAME_ENCODING, NULL)\n        except UnicodeDecodeError:\n            pass\n    try:\n        return (<unsigned char*>c_path)[:c_len].decode('UTF-8')\n    except UnicodeDecodeError:\n        # this is a stupid fallback, but it might still work...\n        return (<unsigned char*>c_path)[:c_len].decode('latin-1', 'replace')\n\ncdef object _encodeFilenameUTF8(object filename):\n    u\"\"\"Recode filename as UTF-8. Tries ASCII, local filesystem encoding and\n    UTF-8 as source encoding.\n    \"\"\"\n    cdef char* c_filename\n    if filename is None:\n        return None\n    elif isinstance(filename, bytes):\n        if not isutf8l(<bytes>filename, len(<bytes>filename)):\n            # plain ASCII!\n            return filename\n        c_filename = _cstr(<bytes>filename)\n        try:\n            # try to decode with default encoding\n            filename = python.PyUnicode_Decode(\n                c_filename, len(<bytes>filename),\n                _C_FILENAME_ENCODING, NULL)\n        except UnicodeDecodeError as decode_exc:\n            try:\n                # try if it's proper UTF-8\n                (<bytes>filename).decode('utf8')\n                return filename\n            except UnicodeDecodeError:\n                raise decode_exc # otherwise re-raise original exception\n    if isinstance(filename, unicode):\n        return (<unicode>filename).encode('utf8')\n    else:\n        raise TypeError(\"Argument must be string or unicode.\")\n\ncdef tuple _getNsTag(tag):\n    u\"\"\"Given a tag, find namespace URI and tag name.\n    Return None for NS uri if no namespace URI provided.\n    \"\"\"\n    return __getNsTag(tag, 0)\n\ncdef tuple _getNsTagWithEmptyNs(tag):\n    u\"\"\"Given a tag, find namespace URI and tag name.  Return None for NS uri\n    if no namespace URI provided, or the empty string if namespace\n    part is '{}'.\n    \"\"\"\n    return __getNsTag(tag, 1)\n\ncdef tuple __getNsTag(tag, bint empty_ns):\n    cdef char* c_tag\n    cdef char* c_ns_end\n    cdef Py_ssize_t taglen\n    cdef Py_ssize_t nslen\n    cdef bytes ns = None\n    # _isString() is much faster than isinstance()\n    if not _isString(tag) and isinstance(tag, QName):\n        tag = (<QName>tag).text\n    tag = _utf8(tag)\n    c_tag = _cstr(tag)\n    if c_tag[0] == c'{':\n        c_tag += 1\n        c_ns_end = cstring_h.strchr(c_tag, c'}')\n        if c_ns_end is NULL:\n            raise ValueError, u\"Invalid tag name\"\n        nslen  = c_ns_end - c_tag\n        taglen = python.PyBytes_GET_SIZE(tag) - nslen - 2\n        if taglen == 0:\n            raise ValueError, u\"Empty tag name\"\n        if nslen > 0:\n            ns = <bytes>c_tag[:nslen]\n        elif empty_ns:\n            ns = b''\n        tag = <bytes>c_ns_end[1:taglen+1]\n    elif python.PyBytes_GET_SIZE(tag) == 0:\n        raise ValueError, u\"Empty tag name\"\n    return ns, tag\n\ncdef inline int _pyXmlNameIsValid(name_utf8):\n    return _xmlNameIsValid(_xcstr(name_utf8)) and b':' not in name_utf8\n\ncdef inline int _pyHtmlNameIsValid(name_utf8):\n    return _htmlNameIsValid(_xcstr(name_utf8))\n\ncdef inline int _xmlNameIsValid(const_xmlChar* c_name):\n    return tree.xmlValidateNameValue(c_name)\n\ncdef int _htmlNameIsValid(const_xmlChar* c_name):\n    if c_name is NULL or c_name[0] == c'\\0':\n        return 0\n    while c_name[0] != c'\\0':\n        if c_name[0] in b'&<>/\"\\'\\t\\n\\x0B\\x0C\\r ':\n            return 0\n        c_name += 1\n    return 1\n\ncdef bint _characterReferenceIsValid(const_xmlChar* c_name):\n    cdef bint is_hex\n    if c_name[0] == c'x':\n        c_name += 1\n        is_hex = 1\n    else:\n        is_hex = 0\n    if c_name[0] == c'\\0':\n        return 0\n    while c_name[0] != c'\\0':\n        if c_name[0] < c'0' or c_name[0] > c'9':\n            if not is_hex:\n                return 0\n            if not (c'a' <= c_name[0] <= c'f'):\n                if not (c'A' <= c_name[0] <= c'F'):\n                    return 0\n        c_name += 1\n    return 1\n\ncdef int _tagValidOrRaise(tag_utf) except -1:\n    if not _pyXmlNameIsValid(tag_utf):\n        raise ValueError(f\"Invalid tag name {(<bytes>tag_utf).decode('utf8')!r}\")\n    return 0\n\ncdef int _htmlTagValidOrRaise(tag_utf) except -1:\n    if not _pyHtmlNameIsValid(tag_utf):\n        raise ValueError(f\"Invalid HTML tag name {(<bytes>tag_utf).decode('utf8')!r}\")\n    return 0\n\ncdef int _attributeValidOrRaise(name_utf) except -1:\n    if not _pyXmlNameIsValid(name_utf):\n        raise ValueError(f\"Invalid attribute name {(<bytes>name_utf).decode('utf8')!r}\")\n    return 0\n\ncdef int _prefixValidOrRaise(tag_utf) except -1:\n    if not _pyXmlNameIsValid(tag_utf):\n        raise ValueError(f\"Invalid namespace prefix {(<bytes>tag_utf).decode('utf8')!r}\")\n    return 0\n\ncdef int _uriValidOrRaise(uri_utf) except -1:\n    cdef uri.xmlURI* c_uri = uri.xmlParseURI(_cstr(uri_utf))\n    if c_uri is NULL:\n        raise ValueError(f\"Invalid namespace URI {(<bytes>uri_utf).decode('utf8')!r}\")\n    uri.xmlFreeURI(c_uri)\n    return 0\n\ncdef inline object _namespacedName(xmlNode* c_node):\n    return _namespacedNameFromNsName(_getNs(c_node), c_node.name)\n\ncdef object _namespacedNameFromNsName(const_xmlChar* href, const_xmlChar* name):\n    if href is NULL:\n        return funicode(name)\n    elif not python.IS_PYPY and (python.LXML_UNICODE_STRINGS or isutf8(name) or isutf8(href)):\n        return python.PyUnicode_FromFormat(\"{%s}%s\", href, name)\n    else:\n        s = python.PyBytes_FromFormat(\"{%s}%s\", href, name)\n        if python.IS_PYPY and (python.LXML_UNICODE_STRINGS or isutf8l(s, len(s))):\n            return (<bytes>s).decode('utf8')\n        else:\n            return s\n\ncdef _getFilenameForFile(source):\n    u\"\"\"Given a Python File or Gzip object, give filename back.\n\n    Returns None if not a file object.\n    \"\"\"\n    # urllib2 provides a geturl() method\n    try:\n        return source.geturl()\n    except:\n        pass\n    # file instances have a name attribute\n    try:\n        filename = source.name\n        if _isString(filename):\n            return os_path_abspath(filename)\n    except:\n        pass\n    # gzip file instances have a filename attribute (before Py3k)\n    try:\n        filename = source.filename\n        if _isString(filename):\n            return os_path_abspath(filename)\n    except:\n        pass\n    # can't determine filename\n    return None\n", "# iterparse -- event-driven parsing\n\nDEF __ITERPARSE_CHUNK_SIZE = 32768\n\ncdef class iterparse:\n    u\"\"\"iterparse(self, source, events=(\"end\",), tag=None, \\\n                  attribute_defaults=False, dtd_validation=False, \\\n                  load_dtd=False, no_network=True, remove_blank_text=False, \\\n                  remove_comments=False, remove_pis=False, encoding=None, \\\n                  html=False, recover=None, huge_tree=False, schema=None)\n\n    Incremental parser.\n\n    Parses XML into a tree and generates tuples (event, element) in a\n    SAX-like fashion. ``event`` is any of 'start', 'end', 'start-ns',\n    'end-ns'.\n\n    For 'start' and 'end', ``element`` is the Element that the parser just\n    found opening or closing.  For 'start-ns', it is a tuple (prefix, URI) of\n    a new namespace declaration.  For 'end-ns', it is simply None.  Note that\n    all start and end events are guaranteed to be properly nested.\n\n    The keyword argument ``events`` specifies a sequence of event type names\n    that should be generated.  By default, only 'end' events will be\n    generated.\n\n    The additional ``tag`` argument restricts the 'start' and 'end' events to\n    those elements that match the given tag.  The ``tag`` argument can also be\n    a sequence of tags to allow matching more than one tag.  By default,\n    events are generated for all elements.  Note that the 'start-ns' and\n    'end-ns' events are not impacted by this restriction.\n\n    The other keyword arguments in the constructor are mainly based on the\n    libxml2 parser configuration.  A DTD will also be loaded if validation or\n    attribute default values are requested.\n\n    Available boolean keyword arguments:\n     - attribute_defaults: read default attributes from DTD\n     - dtd_validation: validate (if DTD is available)\n     - load_dtd: use DTD for parsing\n     - no_network: prevent network access for related files\n     - remove_blank_text: discard blank text nodes\n     - remove_comments: discard comments\n     - remove_pis: discard processing instructions\n     - strip_cdata: replace CDATA sections by normal text content (default: True)\n     - compact: safe memory for short text content (default: True)\n     - resolve_entities: replace entities by their text value (default: True)\n     - huge_tree: disable security restrictions and support very deep trees\n                  and very long text content (only affects libxml2 2.7+)\n     - html: parse input as HTML (default: XML)\n     - recover: try hard to parse through broken input (default: True for HTML,\n                False otherwise)\n\n    Other keyword arguments:\n     - encoding: override the document encoding\n     - schema: an XMLSchema to validate against\n    \"\"\"\n    cdef _FeedParser _parser\n    cdef object _tag\n    cdef object _events\n    cdef readonly object root\n    cdef object _source\n    cdef object _filename\n    cdef object _error\n    cdef bint _close_source_after_read\n\n    def __init__(self, source, events=(u\"end\",), *, tag=None,\n                 attribute_defaults=False, dtd_validation=False,\n                 load_dtd=False, no_network=True, remove_blank_text=False,\n                 compact=True, resolve_entities=True, remove_comments=False,\n                 remove_pis=False, strip_cdata=True, encoding=None,\n                 html=False, recover=None, huge_tree=False, collect_ids=True,\n                 XMLSchema schema=None):\n        if not hasattr(source, 'read'):\n            source = _getFSPathOrObject(source)\n            self._filename = source\n            if python.IS_PYTHON2:\n                source = _encodeFilename(source)\n            source = open(source, 'rb')\n            self._close_source_after_read = True\n        else:\n            self._filename = _getFilenameForFile(source)\n            self._close_source_after_read = False\n\n        if recover is None:\n            recover = html\n\n        if html:\n            # make sure we're not looking for namespaces\n            events = [event for event in events\n                      if event not in ('start-ns', 'end-ns')]\n            parser = HTMLPullParser(\n                events,\n                tag=tag,\n                recover=recover,\n                base_url=self._filename,\n                encoding=encoding,\n                remove_blank_text=remove_blank_text,\n                remove_comments=remove_comments,\n                remove_pis=remove_pis,\n                strip_cdata=strip_cdata,\n                no_network=no_network,\n                target=None,  # TODO\n                schema=schema,\n                compact=compact)\n        else:\n            parser = XMLPullParser(\n                events,\n                tag=tag,\n                recover=recover,\n                base_url=self._filename,\n                encoding=encoding,\n                attribute_defaults=attribute_defaults,\n                dtd_validation=dtd_validation,\n                load_dtd=load_dtd,\n                no_network=no_network,\n                schema=schema,\n                huge_tree=huge_tree,\n                remove_blank_text=remove_blank_text,\n                resolve_entities=resolve_entities,\n                remove_comments=remove_comments,\n                remove_pis=remove_pis,\n                strip_cdata=strip_cdata,\n                collect_ids=True,\n                target=None,  # TODO\n                compact=compact)\n\n        self._events = parser.read_events()\n        self._parser = parser\n        self._source = source\n\n    @property\n    def error_log(self):\n        \"\"\"The error log of the last (or current) parser run.\n        \"\"\"\n        return self._parser.feed_error_log\n\n    @property\n    def resolvers(self):\n        \"\"\"The custom resolver registry of the last (or current) parser run.\n        \"\"\"\n        return self._parser.resolvers\n\n    @property\n    def version(self):\n        \"\"\"The version of the underlying XML parser.\"\"\"\n        return self._parser.version\n\n    def set_element_class_lookup(self, ElementClassLookup lookup = None):\n        u\"\"\"set_element_class_lookup(self, lookup = None)\n\n        Set a lookup scheme for element classes generated from this parser.\n\n        Reset it by passing None or nothing.\n        \"\"\"\n        self._parser.set_element_class_lookup(lookup)\n\n    def makeelement(self, _tag, attrib=None, nsmap=None, **_extra):\n        u\"\"\"makeelement(self, _tag, attrib=None, nsmap=None, **_extra)\n\n        Creates a new element associated with this parser.\n        \"\"\"\n        self._parser.makeelement(\n            _tag, attrib=None, nsmap=None, **_extra)\n\n    @cython.final\n    cdef _close_source(self):\n        if self._source is None:\n            return\n        if not self._close_source_after_read:\n            self._source = None\n            return\n        try:\n            close = self._source.close\n        except AttributeError:\n            close = None\n        finally:\n            self._source = None\n        if close is not None:\n            close()\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        try:\n            return next(self._events)\n        except StopIteration:\n            pass\n        context = <_SaxParserContext>self._parser._getPushParserContext()\n        if self._source is not None:\n            done = False\n            while not done:\n                try:\n                    done = self._read_more_events(context)\n                    return next(self._events)\n                except StopIteration:\n                    pass  # no events yet\n                except Exception as e:\n                    self._error = e\n                    self._close_source()\n                    try:\n                        return next(self._events)\n                    except StopIteration:\n                        break\n        # nothing left to read or return\n        if self._error is not None:\n            error = self._error\n            self._error = None\n            raise error\n        if (context._validator is not None\n                and not context._validator.isvalid()):\n            _raiseParseError(context._c_ctxt, self._filename,\n                             context._error_log)\n        # no errors => all done\n        raise StopIteration\n\n    @cython.final\n    cdef bint _read_more_events(self, _SaxParserContext context) except -123:\n        data = self._source.read(__ITERPARSE_CHUNK_SIZE)\n        if not isinstance(data, bytes):\n            self._close_source()\n            raise TypeError(\"reading file objects must return bytes objects\")\n        if not data:\n            try:\n                self.root = self._parser.close()\n            finally:\n                self._close_source()\n            return True\n        self._parser.feed(data)\n        return False\n\n\ncdef enum _IterwalkSkipStates:\n    IWSKIP_NEXT_IS_START\n    IWSKIP_SKIP_NEXT\n    IWSKIP_CAN_SKIP\n    IWSKIP_CANNOT_SKIP\n\n\ncdef class iterwalk:\n    u\"\"\"iterwalk(self, element_or_tree, events=(\"end\",), tag=None)\n\n    A tree walker that generates events from an existing tree as if it\n    was parsing XML data with ``iterparse()``.\n\n    Just as for ``iterparse()``, the ``tag`` argument can be a single tag or a\n    sequence of tags.\n\n    After receiving a 'start' or 'start-ns' event, the children and\n    descendants of the current element can be excluded from iteration\n    by calling the ``skip_subtree()`` method.\n    \"\"\"\n    cdef _MultiTagMatcher _matcher\n    cdef list   _node_stack\n    cdef list   _events\n    cdef object _pop_event\n    cdef object _include_siblings\n    cdef int    _index\n    cdef int    _event_filter\n    cdef _IterwalkSkipStates _skip_state\n\n    def __init__(self, element_or_tree, events=(u\"end\",), tag=None):\n        cdef _Element root\n        cdef int ns_count\n        root = _rootNodeOrRaise(element_or_tree)\n        self._event_filter = _buildParseEventFilter(events)\n        if tag is None or tag == '*':\n            self._matcher = None\n        else:\n            self._matcher = _MultiTagMatcher.__new__(_MultiTagMatcher, tag)\n        self._node_stack  = []\n        self._events = []\n        self._pop_event = self._events.pop\n        self._skip_state = IWSKIP_CANNOT_SKIP  # ignore all skip requests by default\n\n        if self._event_filter:\n            self._index = 0\n            if self._matcher is not None and self._event_filter & PARSE_EVENT_FILTER_START:\n                self._matcher.cacheTags(root._doc)\n\n            # When processing an ElementTree, add events for the preceding comments/PIs.\n            if self._event_filter & (PARSE_EVENT_FILTER_COMMENT | PARSE_EVENT_FILTER_PI):\n                if isinstance(element_or_tree, _ElementTree):\n                    self._include_siblings = root\n                    for elem in list(root.itersiblings(preceding=True))[::-1]:\n                        if self._event_filter & PARSE_EVENT_FILTER_COMMENT and elem.tag is Comment:\n                            self._events.append((u'comment', elem))\n                        elif self._event_filter & PARSE_EVENT_FILTER_PI and elem.tag is PI:\n                            self._events.append((u'pi', elem))\n\n            ns_count = self._start_node(root)\n            self._node_stack.append( (root, ns_count) )\n        else:\n            self._index = -1\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        cdef xmlNode* c_child\n        cdef _Element node\n        cdef _Element next_node\n        cdef int ns_count = 0\n        if self._events:\n            return self._next_event()\n        if self._matcher is not None and self._index >= 0:\n            node = self._node_stack[self._index][0]\n            self._matcher.cacheTags(node._doc)\n\n        # find next node\n        while self._index >= 0:\n            node = self._node_stack[self._index][0]\n\n            if self._skip_state == IWSKIP_SKIP_NEXT:\n                c_child = NULL\n            else:\n                c_child = self._process_non_elements(\n                    node._doc, _findChildForwards(node._c_node, 0))\n            self._skip_state = IWSKIP_CANNOT_SKIP\n\n            while c_child is NULL:\n                # back off through parents\n                self._index -= 1\n                node = self._end_node()\n                if self._index < 0:\n                    break\n                c_child = self._process_non_elements(\n                    node._doc, _nextElement(node._c_node))\n\n            if c_child is not NULL:\n                next_node = _elementFactory(node._doc, c_child)\n                if self._event_filter & (PARSE_EVENT_FILTER_START |\n                                         PARSE_EVENT_FILTER_START_NS):\n                    ns_count = self._start_node(next_node)\n                elif self._event_filter & PARSE_EVENT_FILTER_END_NS:\n                    ns_count = _countNsDefs(next_node._c_node)\n                self._node_stack.append( (next_node, ns_count) )\n                self._index += 1\n            if self._events:\n                return self._next_event()\n\n        if self._include_siblings is not None:\n            node, self._include_siblings = self._include_siblings, None\n            self._process_non_elements(node._doc, _nextElement(node._c_node))\n            if self._events:\n                return self._next_event()\n\n        raise StopIteration\n\n    @cython.final\n    cdef xmlNode* _process_non_elements(self, _Document doc, xmlNode* c_node):\n        while c_node is not NULL and c_node.type != tree.XML_ELEMENT_NODE:\n            if c_node.type == tree.XML_COMMENT_NODE:\n                if self._event_filter & PARSE_EVENT_FILTER_COMMENT:\n                    self._events.append(\n                        (u\"comment\", _elementFactory(doc, c_node)))\n                c_node = _nextElement(c_node)\n            elif c_node.type == tree.XML_PI_NODE:\n                if self._event_filter & PARSE_EVENT_FILTER_PI:\n                    self._events.append(\n                        (u\"pi\", _elementFactory(doc, c_node)))\n                c_node = _nextElement(c_node)\n            else:\n                break\n        return c_node\n\n    @cython.final\n    cdef _next_event(self):\n        if self._skip_state == IWSKIP_NEXT_IS_START:\n            if self._events[0][0] in (u'start', u'start-ns'):\n                self._skip_state = IWSKIP_CAN_SKIP\n        return self._pop_event(0)\n\n    def skip_subtree(self):\n        \"\"\"Prevent descending into the current subtree.\n        Instead, the next returned event will be the 'end' event of the current element\n        (if included), ignoring any children or descendants.\n\n        This has no effect right after an 'end' or 'end-ns' event.\n        \"\"\"\n        if self._skip_state == IWSKIP_CAN_SKIP:\n            self._skip_state = IWSKIP_SKIP_NEXT\n\n    @cython.final\n    cdef int _start_node(self, _Element node) except -1:\n        cdef int ns_count\n        if self._event_filter & PARSE_EVENT_FILTER_START_NS:\n            ns_count = _appendStartNsEvents(node._c_node, self._events)\n            if self._events:\n                self._skip_state = IWSKIP_NEXT_IS_START\n        elif self._event_filter & PARSE_EVENT_FILTER_END_NS:\n            ns_count = _countNsDefs(node._c_node)\n        else:\n            ns_count = 0\n        if self._event_filter & PARSE_EVENT_FILTER_START:\n            if self._matcher is None or self._matcher.matches(node._c_node):\n                self._events.append( (u\"start\", node) )\n                self._skip_state = IWSKIP_NEXT_IS_START\n        return ns_count\n\n    @cython.final\n    cdef _Element _end_node(self):\n        cdef _Element node\n        cdef int i, ns_count\n        node, ns_count = self._node_stack.pop()\n        if self._event_filter & PARSE_EVENT_FILTER_END:\n            if self._matcher is None or self._matcher.matches(node._c_node):\n                self._events.append( (u\"end\", node) )\n        if self._event_filter & PARSE_EVENT_FILTER_END_NS and ns_count:\n            event = (u\"end-ns\", None)\n            for i in range(ns_count):\n                self._events.append(event)\n        return node\n\n\ncdef int _countNsDefs(xmlNode* c_node):\n    cdef xmlNs* c_ns\n    cdef int count\n    count = 0\n    c_ns = c_node.nsDef\n    while c_ns is not NULL:\n        count += 1\n        c_ns = c_ns.next\n    return count\n\n\ncdef int _appendStartNsEvents(xmlNode* c_node, list event_list) except -1:\n    cdef xmlNs* c_ns\n    cdef int count\n    count = 0\n    c_ns = c_node.nsDef\n    while c_ns is not NULL:\n        ns_tuple = (funicode(c_ns.prefix) if c_ns.prefix is not NULL else '',\n                    funicode(c_ns.href))\n        event_list.append( (u\"start-ns\", ns_tuple) )\n        count += 1\n        c_ns = c_ns.next\n    return count\n", "# -*- coding: utf-8 -*-\n\n\"\"\"\nTests specific to the extended etree API\n\nTests that apply to the general ElementTree API should go into\ntest_elementtree\n\"\"\"\n\nfrom __future__ import absolute_import\n\nfrom collections import OrderedDict\nimport os.path\nimport unittest\nimport copy\nimport sys\nimport re\nimport gc\nimport operator\nimport textwrap\nimport zlib\nimport gzip\n\nfrom .common_imports import etree, StringIO, BytesIO, HelperTestCase\nfrom .common_imports import fileInTestDir, fileUrlInTestDir, read_file, path2url, tmpfile\nfrom .common_imports import SillyFileLike, LargeFileLikeUnicode, doctest, make_doctest\nfrom .common_imports import canonicalize, _str, _bytes\nfrom .common_imports import SimpleFSPath\n\nprint(\"\"\"\nTESTED VERSION: %s\"\"\" % etree.__version__ + \"\"\"\n    Python:           %r\"\"\" % (sys.version_info,) + \"\"\"\n    lxml.etree:       %r\"\"\" % (etree.LXML_VERSION,) + \"\"\"\n    libxml used:      %r\"\"\" % (etree.LIBXML_VERSION,) + \"\"\"\n    libxml compiled:  %r\"\"\" % (etree.LIBXML_COMPILED_VERSION,) + \"\"\"\n    libxslt used:     %r\"\"\" % (etree.LIBXSLT_VERSION,) + \"\"\"\n    libxslt compiled: %r\"\"\" % (etree.LIBXSLT_COMPILED_VERSION,) + \"\"\"\n    FS encoding:      %s\"\"\" % (sys.getfilesystemencoding(),) + \"\"\"\n    Default encoding: %s\"\"\" % (sys.getdefaultencoding(),) + \"\"\"\n    Max Unicode:      %s\"\"\" % (sys.maxunicode,) + \"\"\"\n\"\"\")\n\ntry:\n    _unicode = unicode\nexcept NameError:\n    # Python 3\n    _unicode = str\n\n\nclass ETreeOnlyTestCase(HelperTestCase):\n    \"\"\"Tests only for etree, not ElementTree\"\"\"\n    etree = etree\n\n    def test_version(self):\n        self.assertTrue(isinstance(etree.__version__, _unicode))\n        self.assertTrue(isinstance(etree.LXML_VERSION, tuple))\n        self.assertEqual(len(etree.LXML_VERSION), 4)\n        self.assertTrue(isinstance(etree.LXML_VERSION[0], int))\n        self.assertTrue(isinstance(etree.LXML_VERSION[1], int))\n        self.assertTrue(isinstance(etree.LXML_VERSION[2], int))\n        self.assertTrue(isinstance(etree.LXML_VERSION[3], int))\n        self.assertTrue(etree.__version__.startswith(\n            str(etree.LXML_VERSION[0])))\n\n    def test_c_api(self):\n        if hasattr(self.etree, '__pyx_capi__'):\n            # newer Pyrex compatible C-API\n            self.assertTrue(isinstance(self.etree.__pyx_capi__, dict))\n            self.assertTrue(len(self.etree.__pyx_capi__) > 0)\n        else:\n            # older C-API mechanism\n            self.assertTrue(hasattr(self.etree, '_import_c_api'))\n\n    def test_include_paths(self):\n        import lxml\n        includes = lxml.get_include()\n        self.assertTrue(includes)\n        self.assertTrue(len(includes) >= 2)\n        self.assertTrue(os.path.join(os.path.dirname(lxml.__file__), 'includes') in includes,\n                        includes)\n\n    def test_element_names(self):\n        Element = self.etree.Element\n        el = Element('name')\n        self.assertEqual(el.tag, 'name')\n        el = Element('{}name')\n        self.assertEqual(el.tag, 'name')\n\n    def test_element_name_empty(self):\n        Element = self.etree.Element\n        el = Element('name')\n        self.assertRaises(ValueError, Element, '{}')\n        self.assertRaises(ValueError, setattr, el, 'tag', '{}')\n\n        self.assertRaises(ValueError, Element, '{test}')\n        self.assertRaises(ValueError, setattr, el, 'tag', '{test}')\n\n    def test_element_name_colon(self):\n        Element = self.etree.Element\n        self.assertRaises(ValueError, Element, 'p:name')\n        self.assertRaises(ValueError, Element, '{test}p:name')\n\n        el = Element('name')\n        self.assertRaises(ValueError, setattr, el, 'tag', 'p:name')\n\n    def test_element_name_quote(self):\n        Element = self.etree.Element\n        self.assertRaises(ValueError, Element, \"p'name\")\n        self.assertRaises(ValueError, Element, 'p\"name')\n\n        self.assertRaises(ValueError, Element, \"{test}p'name\")\n        self.assertRaises(ValueError, Element, '{test}p\"name')\n\n        el = Element('name')\n        self.assertRaises(ValueError, setattr, el, 'tag', \"p'name\")\n        self.assertRaises(ValueError, setattr, el, 'tag', 'p\"name')\n\n    def test_element_name_space(self):\n        Element = self.etree.Element\n        self.assertRaises(ValueError, Element, ' name ')\n        self.assertRaises(ValueError, Element, 'na me')\n        self.assertRaises(ValueError, Element, '{test} name')\n\n        el = Element('name')\n        self.assertRaises(ValueError, setattr, el, 'tag', ' name ')\n\n    def test_subelement_name_empty(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        el = Element('name')\n        self.assertRaises(ValueError, SubElement, el, '{}')\n        self.assertRaises(ValueError, SubElement, el, '{test}')\n\n    def test_subelement_name_colon(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        el = Element('name')\n        self.assertRaises(ValueError, SubElement, el, 'p:name')\n        self.assertRaises(ValueError, SubElement, el, '{test}p:name')\n\n    def test_subelement_name_quote(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        el = Element('name')\n        self.assertRaises(ValueError, SubElement, el, \"p'name\")\n        self.assertRaises(ValueError, SubElement, el, \"{test}p'name\")\n\n        self.assertRaises(ValueError, SubElement, el, 'p\"name')\n        self.assertRaises(ValueError, SubElement, el, '{test}p\"name')\n\n    def test_subelement_name_space(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        el = Element('name')\n        self.assertRaises(ValueError, SubElement, el, ' name ')\n        self.assertRaises(ValueError, SubElement, el, 'na me')\n        self.assertRaises(ValueError, SubElement, el, '{test} name')\n\n    def test_subelement_attribute_invalid(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        el = Element('name')\n        self.assertRaises(ValueError, SubElement, el, 'name', {'a b c' : 'abc'})\n        self.assertRaises(ValueError, SubElement, el, 'name', {'a' : 'a\\0\\n'})\n        self.assertEqual(0, len(el))\n\n    def test_qname_empty(self):\n        QName = self.etree.QName\n        self.assertRaises(ValueError, QName, '')\n        self.assertRaises(ValueError, QName, None)\n        self.assertRaises(ValueError, QName, None, None)\n        self.assertRaises(ValueError, QName, 'test', '')\n\n    def test_qname_none(self):\n        QName = self.etree.QName\n        q = QName(None, 'TAG')\n        self.assertEqual('TAG', q)\n        self.assertEqual('TAG', q.localname)\n        self.assertEqual(None, q.namespace)\n\n    def test_qname_colon(self):\n        QName = self.etree.QName\n        self.assertRaises(ValueError, QName, 'p:name')\n        self.assertRaises(ValueError, QName, 'test', 'p:name')\n\n    def test_qname_space(self):\n        QName = self.etree.QName\n        self.assertRaises(ValueError, QName, ' name ')\n        self.assertRaises(ValueError, QName, 'na me')\n        self.assertRaises(ValueError, QName, 'test', ' name')\n\n    def test_qname_namespace_localname(self):\n        # ET doesn't have namespace/localname properties on QNames\n        QName = self.etree.QName\n        namespace, localname = 'http://myns', 'a'\n        qname = QName(namespace, localname)\n        self.assertEqual(namespace, qname.namespace)\n        self.assertEqual(localname, qname.localname)\n\n    def test_qname_element(self):\n        # ET doesn't have namespace/localname properties on QNames\n        QName = self.etree.QName\n        qname1 = QName('http://myns', 'a')\n        a = self.etree.Element(qname1, nsmap={'p' : 'http://myns'})\n\n        qname2 = QName(a)\n        self.assertEqual(a.tag, qname1.text)\n        self.assertEqual(a.tag, qname1)\n        self.assertEqual(qname1.text, qname2.text)\n        self.assertEqual(qname1, qname2.text)\n        self.assertEqual(qname1.text, qname2)\n        self.assertEqual(qname1, qname2)\n\n    def test_qname_text_resolve(self):\n        # ET doesn't resove QNames as text values\n        etree = self.etree\n        qname = etree.QName('http://myns', 'a')\n        a = etree.Element(qname, nsmap={'p' : 'http://myns'})\n        a.text = qname\n\n        self.assertEqual(\"p:a\", a.text)\n\n    def test_nsmap_prefix_invalid(self):\n        etree = self.etree\n        self.assertRaises(ValueError,\n                          etree.Element, \"root\", nsmap={'\"' : 'testns'})\n        self.assertRaises(ValueError,\n                          etree.Element, \"root\", nsmap={'&' : 'testns'})\n        self.assertRaises(ValueError,\n                          etree.Element, \"root\", nsmap={'a:b' : 'testns'})\n\n    def test_clear_keep_tail(self):\n        XML = self.etree.XML\n        tostring = self.etree.tostring\n        a = XML('<a aa=\"A\"><b ba=\"B\">B1</b>B2<c ca=\"C\">C1</c>C2</a>')\n        a[0].clear(keep_tail=True)\n        self.assertEqual(_bytes('<a aa=\"A\"><b/>B2<c ca=\"C\">C1</c>C2</a>'), tostring(a))\n\n    def test_attribute_has_key(self):\n        # ET in Py 3.x has no \"attrib.has_key()\" method\n        XML = self.etree.XML\n\n        root = XML(_bytes('<foo bar=\"Bar\" xmlns:ns=\"http://ns.codespeak.net/test\" ns:baz=\"Baz\" />'))\n        self.assertEqual(\n            True, root.attrib.has_key('bar'))\n        self.assertEqual(\n            False, root.attrib.has_key('baz'))\n        self.assertEqual(\n            False, root.attrib.has_key('hah'))\n        self.assertEqual(\n            True,\n            root.attrib.has_key('{http://ns.codespeak.net/test}baz'))\n\n    def test_attribute_set(self):\n        Element = self.etree.Element\n        root = Element(\"root\")\n        root.set(\"attr\", \"TEST\")\n        self.assertEqual(\"TEST\", root.get(\"attr\"))\n\n    def test_attribute_set_nonstring(self):\n        # ElementTree accepts arbitrary attribute values\n        # lxml.etree allows only strings\n        Element = self.etree.Element\n\n        root = Element(\"root\")\n        root.set(\"attr\", \"TEST\")\n        self.assertEqual(\"TEST\", root.get(\"attr\"))\n        self.assertRaises(TypeError, root.set, \"newattr\", 5)\n\n    def test_attrib_and_keywords(self):\n        Element = self.etree.Element\n\n        root = Element(\"root\")\n        root.set(\"attr\", \"TEST\")\n        self.assertEqual(\"TEST\", root.attrib[\"attr\"])\n\n        root2 = Element(\"root2\", root.attrib, attr2='TOAST')\n        self.assertEqual(\"TEST\", root2.attrib[\"attr\"])\n        self.assertEqual(\"TOAST\", root2.attrib[\"attr2\"])\n        self.assertEqual(None, root.attrib.get(\"attr2\"))\n\n    def test_attrib_order(self):\n        Element = self.etree.Element\n\n        keys = [\"attr%d\" % i for i in range(12, 4, -1)]\n        values = [\"TEST-%d\" % i for i in range(12, 4, -1)]\n        items = list(zip(keys, values))\n\n        root = Element(\"root\")\n        for key, value in items:\n            root.set(key, value)\n        self.assertEqual(keys, root.attrib.keys())\n        self.assertEqual(values, root.attrib.values())\n\n        attr_order = [\n            ('attr_99', 'TOAST-1'),\n            ('attr_98', 'TOAST-2'),\n        ]\n        ordered_dict_types = [OrderedDict, lambda x:x]\n        if sys.version_info >= (3, 6):\n            ordered_dict_types.append(dict)\n        else:\n            # Keyword arguments are not ordered in Py<3.6, and thus get sorted.\n            attr_order.sort()\n        attr_order += items\n        expected_keys = [attr[0] for attr in attr_order]\n        expected_values = [attr[1] for attr in attr_order]\n        expected_items = list(zip(expected_keys, expected_values))\n\n        for dict_type in ordered_dict_types:\n            root2 = Element(\"root2\", dict_type(root.attrib),\n                            attr_99='TOAST-1', attr_98='TOAST-2')\n\n            try:\n                self.assertSequenceEqual(expected_keys, root2.attrib.keys())\n                self.assertSequenceEqual(expected_values, root2.attrib.values())\n                self.assertSequenceEqual(expected_items, root2.attrib.items())\n            except AssertionError as exc:\n                exc.args = (\"Order of '%s': %s\" % (dict_type.__name__, exc.args[0]),) + exc.args[1:]\n                raise\n\n        self.assertEqual(keys, root.attrib.keys())\n        self.assertEqual(values, root.attrib.values())\n\n    def test_attribute_set_invalid(self):\n        # ElementTree accepts arbitrary attribute values\n        # lxml.etree allows only strings, or None for (html5) boolean attributes\n        Element = self.etree.Element\n        root = Element(\"root\")\n        self.assertRaises(TypeError, root.set, \"newattr\", 5)\n        self.assertRaises(TypeError, root.set, \"newattr\", object)\n        self.assertRaises(TypeError, root.set, \"newattr\", None)\n        self.assertRaises(TypeError, root.set, \"newattr\")\n\n    def test_strip_attributes(self):\n        XML = self.etree.XML\n        xml = _bytes('<test a=\"5\" b=\"10\" c=\"20\"><x a=\"4\" b=\"2\"/></test>')\n\n        root = XML(xml)\n        self.etree.strip_attributes(root, 'a')\n        self.assertEqual(_bytes('<test b=\"10\" c=\"20\"><x b=\"2\"></x></test>'),\n                          self._writeElement(root))\n\n        root = XML(xml)\n        self.etree.strip_attributes(root, 'b', 'c')\n        self.assertEqual(_bytes('<test a=\"5\"><x a=\"4\"></x></test>'),\n                          self._writeElement(root))\n\n    def test_strip_attributes_ns(self):\n        XML = self.etree.XML\n        xml = _bytes('<test xmlns:n=\"http://test/ns\" a=\"6\" b=\"10\" c=\"20\" n:a=\"5\"><x a=\"4\" n:b=\"2\"/></test>')\n\n        root = XML(xml)\n        self.etree.strip_attributes(root, 'a')\n        self.assertEqual(\n            _bytes('<test xmlns:n=\"http://test/ns\" b=\"10\" c=\"20\" n:a=\"5\"><x n:b=\"2\"></x></test>'),\n            self._writeElement(root))\n\n        root = XML(xml)\n        self.etree.strip_attributes(root, '{http://test/ns}a', 'c')\n        self.assertEqual(\n            _bytes('<test xmlns:n=\"http://test/ns\" a=\"6\" b=\"10\"><x a=\"4\" n:b=\"2\"></x></test>'),\n            self._writeElement(root))\n\n        root = XML(xml)\n        self.etree.strip_attributes(root, '{http://test/ns}*')\n        self.assertEqual(\n            _bytes('<test xmlns:n=\"http://test/ns\" a=\"6\" b=\"10\" c=\"20\"><x a=\"4\"></x></test>'),\n            self._writeElement(root))\n\n    def test_strip_elements(self):\n        XML = self.etree.XML\n        xml = _bytes('<test><a><b><c/></b></a><x><a><b/><c/></a></x></test>')\n\n        root = XML(xml)\n        self.etree.strip_elements(root, 'a')\n        self.assertEqual(_bytes('<test><x></x></test>'),\n                          self._writeElement(root))\n\n        root = XML(xml)\n        self.etree.strip_elements(root, 'b', 'c', 'X', 'Y', 'Z')\n        self.assertEqual(_bytes('<test><a></a><x><a></a></x></test>'),\n                          self._writeElement(root))\n\n        root = XML(xml)\n        self.etree.strip_elements(root, 'c')\n        self.assertEqual(_bytes('<test><a><b></b></a><x><a><b></b></a></x></test>'),\n                          self._writeElement(root))\n\n    def test_strip_elements_ns(self):\n        XML = self.etree.XML\n        xml = _bytes('<test>TEST<n:a xmlns:n=\"urn:a\">A<b>B<c xmlns=\"urn:c\"/>C</b>BT</n:a>AT<x>X<a>A<b xmlns=\"urn:a\"/>BT<c xmlns=\"urn:x\"/>CT</a>AT</x>XT</test>')\n\n        root = XML(xml)\n        self.etree.strip_elements(root, 'a')\n        self.assertEqual(_bytes('<test>TEST<n:a xmlns:n=\"urn:a\">A<b>B<c xmlns=\"urn:c\"></c>C</b>BT</n:a>AT<x>X</x>XT</test>'),\n                          self._writeElement(root))\n\n        root = XML(xml)\n        self.etree.strip_elements(root, '{urn:a}b', 'c')\n        self.assertEqual(_bytes('<test>TEST<n:a xmlns:n=\"urn:a\">A<b>B<c xmlns=\"urn:c\"></c>C</b>BT</n:a>AT<x>X<a>A<c xmlns=\"urn:x\"></c>CT</a>AT</x>XT</test>'),\n                          self._writeElement(root))\n\n        root = XML(xml)\n        self.etree.strip_elements(root, '{urn:a}*', 'c')\n        self.assertEqual(_bytes('<test>TEST<x>X<a>A<c xmlns=\"urn:x\"></c>CT</a>AT</x>XT</test>'),\n                          self._writeElement(root))\n\n        root = XML(xml)\n        self.etree.strip_elements(root, '{urn:a}*', 'c', with_tail=False)\n        self.assertEqual(_bytes('<test>TESTAT<x>X<a>ABT<c xmlns=\"urn:x\"></c>CT</a>AT</x>XT</test>'),\n                          self._writeElement(root))\n\n    def test_strip_tags(self):\n        XML = self.etree.XML\n        xml = _bytes('<test>TEST<a>A<b>B<c/>CT</b>BT</a>AT<x>X<a>A<b/>BT<c/>CT</a>AT</x>XT</test>')\n\n        root = XML(xml)\n        self.etree.strip_tags(root, 'a')\n        self.assertEqual(_bytes('<test>TESTA<b>B<c></c>CT</b>BTAT<x>XA<b></b>BT<c></c>CTAT</x>XT</test>'),\n                          self._writeElement(root))\n\n        root = XML(xml)\n        self.etree.strip_tags(root, 'b', 'c', 'X', 'Y', 'Z')\n        self.assertEqual(_bytes('<test>TEST<a>ABCTBT</a>AT<x>X<a>ABTCT</a>AT</x>XT</test>'),\n                          self._writeElement(root))\n\n        root = XML(xml)\n        self.etree.strip_tags(root, 'c')\n        self.assertEqual(_bytes('<test>TEST<a>A<b>BCT</b>BT</a>AT<x>X<a>A<b></b>BTCT</a>AT</x>XT</test>'),\n                          self._writeElement(root))\n\n    def test_strip_tags_pi_comment(self):\n        XML = self.etree.XML\n        PI = self.etree.ProcessingInstruction\n        Comment = self.etree.Comment\n        xml = _bytes('<!--comment1-->\\n<?PI1?>\\n<test>TEST<!--comment2-->XT<?PI2?></test>\\n<!--comment3-->\\n<?PI1?>')\n\n        root = XML(xml)\n        self.etree.strip_tags(root, PI)\n        self.assertEqual(_bytes('<!--comment1-->\\n<?PI1?>\\n<test>TEST<!--comment2-->XT</test>\\n<!--comment3-->\\n<?PI1?>'),\n                          self._writeElement(root))\n\n        root = XML(xml)\n        self.etree.strip_tags(root, Comment)\n        self.assertEqual(_bytes('<!--comment1-->\\n<?PI1?>\\n<test>TESTXT<?PI2?></test>\\n<!--comment3-->\\n<?PI1?>'),\n                          self._writeElement(root))\n\n        root = XML(xml)\n        self.etree.strip_tags(root, PI, Comment)\n        self.assertEqual(_bytes('<!--comment1-->\\n<?PI1?>\\n<test>TESTXT</test>\\n<!--comment3-->\\n<?PI1?>'),\n                          self._writeElement(root))\n\n        root = XML(xml)\n        self.etree.strip_tags(root, Comment, PI)\n        self.assertEqual(_bytes('<!--comment1-->\\n<?PI1?>\\n<test>TESTXT</test>\\n<!--comment3-->\\n<?PI1?>'),\n                          self._writeElement(root))\n\n    def test_strip_tags_pi_comment_all(self):\n        XML = self.etree.XML\n        ElementTree = self.etree.ElementTree\n        PI = self.etree.ProcessingInstruction\n        Comment = self.etree.Comment\n        xml = _bytes('<!--comment1-->\\n<?PI1?>\\n<test>TEST<!--comment2-->XT<?PI2?></test>\\n<!--comment3-->\\n<?PI1?>')\n\n        root = XML(xml)\n        self.etree.strip_tags(ElementTree(root), PI)\n        self.assertEqual(_bytes('<!--comment1-->\\n<test>TEST<!--comment2-->XT</test>\\n<!--comment3-->'),\n                          self._writeElement(root))\n\n        root = XML(xml)\n        self.etree.strip_tags(ElementTree(root), Comment)\n        self.assertEqual(_bytes('<?PI1?>\\n<test>TESTXT<?PI2?></test>\\n<?PI1?>'),\n                          self._writeElement(root))\n\n        root = XML(xml)\n        self.etree.strip_tags(ElementTree(root), PI, Comment)\n        self.assertEqual(_bytes('<test>TESTXT</test>'),\n                          self._writeElement(root))\n\n        root = XML(xml)\n        self.etree.strip_tags(ElementTree(root), Comment, PI)\n        self.assertEqual(_bytes('<test>TESTXT</test>'),\n                          self._writeElement(root))\n\n    def test_strip_tags_doc_style(self):\n        XML = self.etree.XML\n        xml = _bytes('''\n        <div>\n            <div>\n                I like <strong>sheep</strong>.\n                <br/>\n                I like lots of <strong>sheep</strong>.\n                <br/>\n                Click <a href=\"http://www.sheep.com\">here</a>\n                 for <a href=\"http://www.sheep.com\">those</a> sheep.\n                <br/>\n            </div>\n        </div>\n        '''.strip())\n\n        root = XML(xml)\n        self.etree.strip_tags(root, 'a')\n        self.assertEqual(re.sub(_bytes('</?a[^>]*>'), _bytes(''), xml).replace(_bytes('<br/>'), _bytes('<br></br>')),\n                          self._writeElement(root))\n\n        root = XML(xml)\n        self.etree.strip_tags(root, 'a', 'br')\n        self.assertEqual(re.sub(_bytes('</?a[^>]*>'), _bytes(''),\n                                 re.sub(_bytes('<br[^>]*>'), _bytes(''), xml)),\n                          self._writeElement(root))\n\n    def test_strip_tags_ns(self):\n        XML = self.etree.XML\n        xml = _bytes('<test>TEST<n:a xmlns:n=\"urn:a\">A<b>B<c xmlns=\"urn:c\"/>CT</b>BT</n:a>AT<x>X<a>A<b xmlns=\"urn:a\"/>BT<c xmlns=\"urn:x\"/>CT</a>AT</x>XT</test>')\n\n        root = XML(xml)\n        self.etree.strip_tags(root, 'a')\n        self.assertEqual(_bytes('<test>TEST<n:a xmlns:n=\"urn:a\">A<b>B<c xmlns=\"urn:c\"></c>CT</b>BT</n:a>AT<x>XA<b xmlns=\"urn:a\"></b>BT<c xmlns=\"urn:x\"></c>CTAT</x>XT</test>'),\n                          self._writeElement(root))\n\n        root = XML(xml)\n        self.etree.strip_tags(root, '{urn:a}b', 'c')\n        self.assertEqual(_bytes('<test>TEST<n:a xmlns:n=\"urn:a\">A<b>B<c xmlns=\"urn:c\"></c>CT</b>BT</n:a>AT<x>X<a>ABT<c xmlns=\"urn:x\"></c>CT</a>AT</x>XT</test>'),\n                          self._writeElement(root))\n\n        root = XML(xml)\n        self.etree.strip_tags(root, '{urn:a}*', 'c')\n        self.assertEqual(_bytes('<test>TESTA<b>B<c xmlns=\"urn:c\"></c>CT</b>BTAT<x>X<a>ABT<c xmlns=\"urn:x\"></c>CT</a>AT</x>XT</test>'),\n                          self._writeElement(root))\n\n    def test_strip_tags_and_remove(self):\n        # previously crashed\n        HTML = self.etree.HTML\n        root = HTML(_bytes('<div><h1>title</h1> <b>foo</b> <p>boo</p></div>'))[0][0]\n        self.assertEqual(_bytes('<div><h1>title</h1> <b>foo</b> <p>boo</p></div>'),\n                          self.etree.tostring(root))\n        self.etree.strip_tags(root, 'b')\n        self.assertEqual(_bytes('<div><h1>title</h1> foo <p>boo</p></div>'),\n                          self.etree.tostring(root))\n        root.remove(root[0])\n        self.assertEqual(_bytes('<div><p>boo</p></div>'),\n                          self.etree.tostring(root))\n\n    def test_pi(self):\n        # lxml.etree separates target and text\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        ProcessingInstruction = self.etree.ProcessingInstruction\n\n        a = Element('a')\n        a.append(ProcessingInstruction('foo', 'some more text'))\n        self.assertEqual(a[0].target, 'foo')\n        self.assertEqual(a[0].text, 'some more text')\n\n    def test_pi_parse(self):\n        XML = self.etree.XML\n        root = XML(_bytes(\"<test><?mypi my test ?></test>\"))\n        self.assertEqual(root[0].target, \"mypi\")\n        self.assertEqual(root[0].text, \"my test \")\n\n    def test_pi_pseudo_attributes_get(self):\n        XML = self.etree.XML\n        root = XML(_bytes(\"<test><?mypi my='1' test=\\\" abc \\\" quotes=\\\"' '\\\" only names ?></test>\"))\n        self.assertEqual(root[0].target, \"mypi\")\n        self.assertEqual(root[0].get('my'), \"1\")\n        self.assertEqual(root[0].get('test'), \" abc \")\n        self.assertEqual(root[0].get('quotes'), \"' '\")\n        self.assertEqual(root[0].get('only'), None)\n        self.assertEqual(root[0].get('names'), None)\n        self.assertEqual(root[0].get('nope'), None)\n\n    def test_pi_pseudo_attributes_attrib(self):\n        XML = self.etree.XML\n        root = XML(_bytes(\"<test><?mypi my='1' test=\\\" abc \\\" quotes=\\\"' '\\\" only names ?></test>\"))\n        self.assertEqual(root[0].target, \"mypi\")\n        self.assertEqual(root[0].attrib['my'], \"1\")\n        self.assertEqual(root[0].attrib['test'], \" abc \")\n        self.assertEqual(root[0].attrib['quotes'], \"' '\")\n        self.assertRaises(KeyError, root[0].attrib.__getitem__, 'only')\n        self.assertRaises(KeyError, root[0].attrib.__getitem__, 'names')\n        self.assertRaises(KeyError, root[0].attrib.__getitem__, 'nope')\n\n    def test_deepcopy_pi(self):\n        # previously caused a crash\n        ProcessingInstruction = self.etree.ProcessingInstruction\n        \n        a = ProcessingInstruction(\"PI\", \"ONE\")\n        b = copy.deepcopy(a)\n        b.text = \"ANOTHER\"\n\n        self.assertEqual('ONE',     a.text)\n        self.assertEqual('ANOTHER', b.text)\n\n    def test_deepcopy_elementtree_pi(self):\n        XML = self.etree.XML\n        tostring = self.etree.tostring\n        root = XML(_bytes(\"<?mypi my test ?><test/><!--comment -->\"))\n        tree1 = self.etree.ElementTree(root)\n        self.assertEqual(_bytes(\"<?mypi my test ?><test/><!--comment -->\"),\n                          tostring(tree1))\n\n        tree2 = copy.deepcopy(tree1)\n        self.assertEqual(_bytes(\"<?mypi my test ?><test/><!--comment -->\"),\n                          tostring(tree2))\n\n        root2 = copy.deepcopy(tree1.getroot())\n        self.assertEqual(_bytes(\"<test/>\"),\n                          tostring(root2))\n\n    def test_deepcopy_elementtree_dtd(self):\n        XML = self.etree.XML\n        tostring = self.etree.tostring\n        xml = _bytes('<!DOCTYPE test [\\n<!ENTITY entity \"tasty\">\\n]>\\n<test/>')\n        root = XML(xml)\n        tree1 = self.etree.ElementTree(root)\n        self.assertEqual(xml, tostring(tree1))\n\n        tree2 = copy.deepcopy(tree1)\n        self.assertEqual(xml, tostring(tree2))\n\n        root2 = copy.deepcopy(tree1.getroot())\n        self.assertEqual(_bytes(\"<test/>\"),\n                          tostring(root2))\n\n    def test_deepcopy_pi_dtd(self):\n        XML = self.etree.XML\n        tostring = self.etree.tostring\n        xml = _bytes('<!-- comment --><!DOCTYPE test [\\n<!ENTITY entity \"tasty\">\\n]>\\n<test/>')\n        root = XML(xml)\n        tree1 = self.etree.ElementTree(root)\n        self.assertEqual(xml, tostring(tree1))\n\n        tree2 = copy.deepcopy(tree1)\n        self.assertEqual(xml, tostring(tree2))\n\n    def test_parse_remove_comments(self):\n        fromstring = self.etree.fromstring\n        tostring = self.etree.tostring\n        XMLParser = self.etree.XMLParser\n\n        xml = _bytes('<a><!--A--><b><!-- B --><c/></b><!--C--></a>')\n        parser = XMLParser(remove_comments=True)\n        root = fromstring(xml, parser)\n        self.assertEqual(\n            _bytes('<a><b><c/></b></a>'),\n            tostring(root))\n\n    def test_parse_remove_pis(self):\n        parse = self.etree.parse\n        tostring = self.etree.tostring\n        XMLParser = self.etree.XMLParser\n\n        xml = _bytes('<?test?><a><?A?><b><?B?><c/></b><?C?></a><?tail?>')\n\n        f = BytesIO(xml)\n        tree = parse(f)\n        self.assertEqual(\n            xml,\n            tostring(tree))\n\n        parser = XMLParser(remove_pis=True)\n        tree = parse(f, parser)\n        self.assertEqual(\n            _bytes('<a><b><c/></b></a>'),\n            tostring(tree))\n\n    def test_parse_parser_type_error(self):\n        # ET raises IOError only\n        parse = self.etree.parse\n        self.assertRaises(TypeError, parse, 'notthere.xml', object())\n\n    def test_iterparse_getiterator(self):\n        iterparse = self.etree.iterparse\n        f = BytesIO('<a><b><d/></b><c/></a>')\n\n        counts = []\n        for event, elem in iterparse(f):\n            counts.append(len(list(elem.getiterator())))\n        self.assertEqual(\n            [1,2,1,4],\n            counts)\n\n    def test_iterparse_tree_comments(self):\n        # ET removes comments\n        iterparse = self.etree.iterparse\n        tostring = self.etree.tostring\n\n        f = BytesIO('<a><!--A--><b><!-- B --><c/></b><!--C--></a>')\n        events = list(iterparse(f))\n        root = events[-1][1]\n        self.assertEqual(3, len(events))\n        self.assertEqual(\n            _bytes('<a><!--A--><b><!-- B --><c/></b><!--C--></a>'),\n            tostring(root))\n\n    def test_iterparse_comments(self):\n        # ET removes comments\n        iterparse = self.etree.iterparse\n        tostring = self.etree.tostring\n\n        def name(event, el):\n            if event == 'comment':\n                return el.text\n            else:\n                return el.tag\n\n        f = BytesIO('<a><!--A--><b><!-- B --><c/></b><!--C--></a>')\n        events = list(iterparse(f, events=('end', 'comment')))\n        root = events[-1][1]\n        self.assertEqual(6, len(events))\n        self.assertEqual(['A', ' B ', 'c', 'b', 'C', 'a'],\n                          [ name(*item) for item in events ])\n        self.assertEqual(\n            _bytes('<a><!--A--><b><!-- B --><c/></b><!--C--></a>'),\n            tostring(root))\n\n    def test_iterparse_pis(self):\n        # ET removes pis\n        iterparse = self.etree.iterparse\n        tostring = self.etree.tostring\n        ElementTree = self.etree.ElementTree\n\n        def name(event, el):\n            if event == 'pi':\n                return el.target, el.text\n            else:\n                return el.tag\n\n        f = BytesIO('<?pia a?><a><?pib b?><b><?pic c?><c/></b><?pid d?></a><?pie e?>')\n        events = list(iterparse(f, events=('end', 'pi')))\n        root = events[-2][1]\n        self.assertEqual(8, len(events))\n        self.assertEqual([('pia','a'), ('pib','b'), ('pic','c'), 'c', 'b',\n                           ('pid','d'), 'a', ('pie','e')],\n                          [ name(*item) for item in events ])\n        self.assertEqual(\n            _bytes('<?pia a?><a><?pib b?><b><?pic c?><c/></b><?pid d?></a><?pie e?>'),\n            tostring(ElementTree(root)))\n\n    def test_iterparse_remove_comments(self):\n        iterparse = self.etree.iterparse\n        tostring = self.etree.tostring\n\n        f = BytesIO('<a><!--A--><b><!-- B --><c/></b><!--C--></a>')\n        events = list(iterparse(f, remove_comments=True,\n                                events=('end', 'comment')))\n        root = events[-1][1]\n        self.assertEqual(3, len(events))\n        self.assertEqual(['c', 'b', 'a'],\n                          [ el.tag for (event, el) in events ])\n        self.assertEqual(\n            _bytes('<a><b><c/></b></a>'),\n            tostring(root))\n\n    def test_iterparse_broken(self):\n        iterparse = self.etree.iterparse\n        f = BytesIO('<a><b><c/></a>')\n        # ET raises ExpatError, lxml raises XMLSyntaxError\n        self.assertRaises(self.etree.XMLSyntaxError, list, iterparse(f))\n\n    def test_iterparse_broken_recover(self):\n        iterparse = self.etree.iterparse\n        f = BytesIO('<a><b><c/></a>')\n        it = iterparse(f, events=('start', 'end'), recover=True)\n        events = [(ev, el.tag) for ev, el in it]\n        root = it.root\n        self.assertTrue(root is not None)\n\n        self.assertEqual(1, events.count(('start', 'a')))\n        self.assertEqual(1, events.count(('end', 'a')))\n\n        self.assertEqual(1, events.count(('start', 'b')))\n        self.assertEqual(1, events.count(('end', 'b')))\n\n        self.assertEqual(1, events.count(('start', 'c')))\n        self.assertEqual(1, events.count(('end', 'c')))\n\n    def test_iterparse_broken_multi_recover(self):\n        iterparse = self.etree.iterparse\n        f = BytesIO('<a><b><c/></d><b><c/></a></b>')\n        it = iterparse(f, events=('start', 'end'), recover=True)\n        events = [(ev, el.tag) for ev, el in it]\n        root = it.root\n        self.assertTrue(root is not None)\n\n        self.assertEqual(1, events.count(('start', 'a')))\n        self.assertEqual(1, events.count(('end', 'a')))\n\n        self.assertEqual(2, events.count(('start', 'b')))\n        self.assertEqual(2, events.count(('end', 'b')))\n\n        self.assertEqual(2, events.count(('start', 'c')))\n        self.assertEqual(2, events.count(('end', 'c')))\n\n    def test_iterparse_strip(self):\n        iterparse = self.etree.iterparse\n        f = BytesIO(\"\"\"\n               <a>  \\n \\n  <b> b test </b>  \\n\n\n               \\n\\t <c> \\n </c> </a>  \\n \"\"\")\n        iterator = iterparse(f, remove_blank_text=True)\n        text = [ (element.text, element.tail)\n                 for event, element in iterator ]\n        self.assertEqual(\n            [(\" b test \", None), (\" \\n \", None), (None, None)],\n            text)\n\n    def test_iterparse_tag(self):\n        iterparse = self.etree.iterparse\n        f = BytesIO('<a><b><d/></b><c/></a>')\n\n        iterator = iterparse(f, tag=\"b\", events=('start', 'end'))\n        events = list(iterator)\n        root = iterator.root\n        self.assertEqual(\n            [('start', root[0]), ('end', root[0])],\n            events)\n\n    def test_iterparse_tag_all(self):\n        iterparse = self.etree.iterparse\n        f = BytesIO('<a><b><d/></b><c/></a>')\n\n        iterator = iterparse(f, tag=\"*\", events=('start', 'end'))\n        events = list(iterator)\n        self.assertEqual(\n            8,\n            len(events))\n\n    def test_iterparse_tag_ns(self):\n        iterparse = self.etree.iterparse\n        f = BytesIO('<a xmlns=\"urn:test:1\"><b><d/></b><c/></a>')\n\n        iterator = iterparse(f, tag=\"{urn:test:1}b\", events=('start', 'end'))\n        events = list(iterator)\n        root = iterator.root\n        self.assertEqual(\n            [('start', root[0]), ('end', root[0])],\n            events)\n\n    def test_iterparse_tag_ns_empty(self):\n        iterparse = self.etree.iterparse\n        f = BytesIO('<a><b><d/></b><c/></a>')\n        iterator = iterparse(f, tag=\"{}b\", events=('start', 'end'))\n        events = list(iterator)\n        root = iterator.root\n        self.assertEqual(\n            [('start', root[0]), ('end', root[0])],\n            events)\n\n        f = BytesIO('<a xmlns=\"urn:test:1\"><b><d/></b><c/></a>')\n        iterator = iterparse(f, tag=\"{}b\", events=('start', 'end'))\n        events = list(iterator)\n        root = iterator.root\n        self.assertEqual([], events)\n\n    def test_iterparse_tag_ns_all(self):\n        iterparse = self.etree.iterparse\n        f = BytesIO('<a xmlns=\"urn:test:1\"><b><d/></b><c/></a>')\n        iterator = iterparse(f, tag=\"{urn:test:1}*\", events=('start', 'end'))\n        events = list(iterator)\n        self.assertEqual(8, len(events))\n\n    def test_iterparse_tag_ns_empty_all(self):\n        iterparse = self.etree.iterparse\n        f = BytesIO('<a xmlns=\"urn:test:1\"><b><d/></b><c/></a>')\n        iterator = iterparse(f, tag=\"{}*\", events=('start', 'end'))\n        events = list(iterator)\n        self.assertEqual([], events)\n\n        f = BytesIO('<a><b><d/></b><c/></a>')\n        iterator = iterparse(f, tag=\"{}*\", events=('start', 'end'))\n        events = list(iterator)\n        self.assertEqual(8, len(events))\n\n    def test_iterparse_encoding_error(self):\n        text = _str('S\u00f8k p\u00e5 nettet')\n        wrong_declaration = \"<?xml version='1.0' encoding='UTF-8'?>\"\n        xml_latin1 = (_str('%s<a>%s</a>') % (wrong_declaration, text)\n                      ).encode('iso-8859-1')\n\n        self.assertRaises(self.etree.ParseError,\n                          list, self.etree.iterparse(BytesIO(xml_latin1)))\n\n    def test_iterparse_encoding_8bit_override(self):\n        text = _str('S\u00f8k p\u00e5 nettet', encoding=\"UTF-8\")\n        wrong_declaration = \"<?xml version='1.0' encoding='UTF-8'?>\"\n        xml_latin1 = (_str('%s<a>%s</a>') % (wrong_declaration, text)\n                      ).encode('iso-8859-1')\n\n        iterator = self.etree.iterparse(BytesIO(xml_latin1),\n                                        encoding=\"iso-8859-1\")\n        self.assertEqual(1, len(list(iterator)))\n\n        a = iterator.root\n        self.assertEqual(a.text, text)\n\n    def test_iterparse_keep_cdata(self):\n        tostring = self.etree.tostring\n        f = BytesIO('<root><![CDATA[test]]></root>')\n        context = self.etree.iterparse(f, strip_cdata=False)\n        content = [ el.text for event,el in context ]\n\n        self.assertEqual(['test'], content)\n        self.assertEqual(_bytes('<root><![CDATA[test]]></root>'),\n                          tostring(context.root))\n\n    def test_parser_encoding_unknown(self):\n        self.assertRaises(\n            LookupError, self.etree.XMLParser, encoding=\"hopefully unknown\")\n\n    def test_parser_encoding(self):\n        self.etree.XMLParser(encoding=\"ascii\")\n        self.etree.XMLParser(encoding=\"utf-8\")\n        self.etree.XMLParser(encoding=\"iso-8859-1\")\n\n    def test_feed_parser_recover(self):\n        parser = self.etree.XMLParser(recover=True)\n\n        parser.feed('<?xml version=')\n        parser.feed('\"1.0\"?><ro')\n        parser.feed('ot><')\n        parser.feed('a test=\"works\"')\n        parser.feed('><othertag/></root') # <a> not closed!\n        parser.feed('>')\n\n        root = parser.close()\n\n        self.assertEqual(root.tag, \"root\")\n        self.assertEqual(len(root), 1)\n        self.assertEqual(root[0].tag, \"a\")\n        self.assertEqual(root[0].get(\"test\"), \"works\")\n        self.assertEqual(len(root[0]), 1)\n        self.assertEqual(root[0][0].tag, \"othertag\")\n        # FIXME: would be nice to get some errors logged ...\n        #self.assertTrue(len(parser.error_log) > 0, \"error log is empty\")\n\n    def test_feed_parser_recover_no_id_dict(self):\n        # test that recover mode plays nicely with the no-id-dict setup\n        parser = self.etree.XMLParser(recover=True, collect_ids=False)\n\n        parser.feed('<?xml version=')\n        parser.feed('\"1.0\"?><ro')\n        parser.feed('ot xml:id=\"123\"><')\n        parser.feed('a test=\"works\" xml:id=')\n        parser.feed('\"321\"><othertag/></root') # <a> not closed!\n        parser.feed('>')\n\n        root = parser.close()\n\n        self.assertEqual(root.tag, \"root\")\n        self.assertEqual(len(root), 1)\n        self.assertEqual(root[0].tag, \"a\")\n        self.assertEqual(root[0].get(\"test\"), \"works\")\n        self.assertEqual(root[0].attrib, {\n            'test': 'works',\n            '{http://www.w3.org/XML/1998/namespace}id': '321'})\n        self.assertEqual(len(root[0]), 1)\n        self.assertEqual(root[0][0].tag, \"othertag\")\n        # FIXME: would be nice to get some errors logged ...\n        #self.assertTrue(len(parser.error_log) > 0, \"error log is empty\")\n\n    def test_elementtree_parser_target_type_error(self):\n        assertEqual = self.assertEqual\n        assertFalse  = self.assertFalse\n\n        events = []\n        class Target(object):\n            def start(self, tag, attrib):\n                events.append(\"start\")\n                assertFalse(attrib)\n                assertEqual(\"TAG\", tag)\n            def end(self, tag):\n                events.append(\"end\")\n                assertEqual(\"TAG\", tag)\n            def close(self):\n                return \"DONE\" # no Element!\n\n        parser = self.etree.XMLParser(target=Target())\n        tree = self.etree.ElementTree()\n\n        self.assertRaises(TypeError,\n                          tree.parse, BytesIO(\"<TAG/>\"), parser=parser)\n        self.assertEqual([\"start\", \"end\"], events)\n\n    def test_parser_target_feed_exception(self):\n        # ET doesn't call .close() on errors\n        events = []\n        class Target(object):\n            def start(self, tag, attrib):\n                events.append(\"start-\" + tag)\n            def end(self, tag):\n                events.append(\"end-\" + tag)\n                if tag == 'a':\n                    raise ValueError(\"dead and gone\")\n            def data(self, data):\n                events.append(\"data-\" + data)\n            def close(self):\n                events.append(\"close\")\n                return \"DONE\"\n\n        parser = self.etree.XMLParser(target=Target())\n\n        try:\n            parser.feed(_bytes('<root>A<a>ca</a>B</root>'))\n            done = parser.close()\n            self.fail(\"error expected, but parsing succeeded\")\n        except ValueError:\n            done = 'value error received as expected'\n\n        self.assertEqual([\"start-root\", \"data-A\", \"start-a\",\n                           \"data-ca\", \"end-a\", \"close\"],\n                          events)\n\n    def test_parser_target_fromstring_exception(self):\n        # ET doesn't call .close() on errors\n        events = []\n        class Target(object):\n            def start(self, tag, attrib):\n                events.append(\"start-\" + tag)\n            def end(self, tag):\n                events.append(\"end-\" + tag)\n                if tag == 'a':\n                    raise ValueError(\"dead and gone\")\n            def data(self, data):\n                events.append(\"data-\" + data)\n            def close(self):\n                events.append(\"close\")\n                return \"DONE\"\n\n        parser = self.etree.XMLParser(target=Target())\n\n        try:\n            done = self.etree.fromstring(_bytes('<root>A<a>ca</a>B</root>'),\n                                         parser=parser)\n            self.fail(\"error expected, but parsing succeeded\")\n        except ValueError:\n            done = 'value error received as expected'\n\n        self.assertEqual([\"start-root\", \"data-A\", \"start-a\",\n                          \"data-ca\", \"end-a\", \"close\"],\n                         events)\n\n    def test_parser_target_feed_no_id_dict(self):\n        # test that target parsing works nicely with the no-id-hash setup\n        events = []\n        class Target(object):\n            def start(self, tag, attrib):\n                events.append(\"start-\" + tag)\n            def end(self, tag):\n                events.append(\"end-\" + tag)\n            def data(self, data):\n                events.append(\"data-\" + data)\n            def comment(self, text):\n                events.append(\"comment-\" + text)\n            def close(self):\n                return \"DONE\"\n\n        parser = self.etree.XMLParser(target=Target(), collect_ids=False)\n\n        parser.feed(_bytes('<!--a--><root xml:id=\"123\">A<!--b-->'))\n        parser.feed(_bytes('<sub xml:id=\"321\"/>B</root>'))\n        done = parser.close()\n\n        self.assertEqual(\"DONE\", done)\n        self.assertEqual([\"comment-a\", \"start-root\", \"data-A\", \"comment-b\",\n                          \"start-sub\", \"end-sub\", \"data-B\", \"end-root\"],\n                         events)\n\n    def test_parser_target_comment(self):\n        events = []\n        class Target(object):\n            def start(self, tag, attrib):\n                events.append(\"start-\" + tag)\n            def end(self, tag):\n                events.append(\"end-\" + tag)\n            def data(self, data):\n                events.append(\"data-\" + data)\n            def comment(self, text):\n                events.append(\"comment-\" + text)\n            def close(self):\n                return \"DONE\"\n\n        parser = self.etree.XMLParser(target=Target())\n\n        parser.feed(_bytes('<!--a--><root>A<!--b--><sub/><!--c-->B</root><!--d-->'))\n        done = parser.close()\n\n        self.assertEqual(\"DONE\", done)\n        self.assertEqual([\"comment-a\", \"start-root\", \"data-A\", \"comment-b\",\n                           \"start-sub\", \"end-sub\", \"comment-c\", \"data-B\",\n                           \"end-root\", \"comment-d\"],\n                          events)\n\n    def test_parser_target_pi(self):\n        events = []\n        class Target(object):\n            def start(self, tag, attrib):\n                events.append(\"start-\" + tag)\n            def end(self, tag):\n                events.append(\"end-\" + tag)\n            def data(self, data):\n                events.append(\"data-\" + data)\n            def pi(self, target, data):\n                events.append(\"pi-\" + target + \"-\" + data)\n            def close(self):\n                return \"DONE\"\n\n        parser = self.etree.XMLParser(target=Target())\n\n        parser.feed(_bytes('<?test a?><root>A<?test b?>B</root><?test c?>'))\n        done = parser.close()\n\n        self.assertEqual(\"DONE\", done)\n        self.assertEqual([\"pi-test-a\", \"start-root\", \"data-A\", \"pi-test-b\",\n                           \"data-B\", \"end-root\", \"pi-test-c\"],\n                          events)\n\n    def test_parser_target_cdata(self):\n        events = []\n        class Target(object):\n            def start(self, tag, attrib):\n                events.append(\"start-\" + tag)\n            def end(self, tag):\n                events.append(\"end-\" + tag)\n            def data(self, data):\n                events.append(\"data-\" + data)\n            def close(self):\n                return \"DONE\"\n\n        parser = self.etree.XMLParser(target=Target(),\n                                      strip_cdata=False)\n\n        parser.feed(_bytes('<root>A<a><![CDATA[ca]]></a>B</root>'))\n        done = parser.close()\n\n        self.assertEqual(\"DONE\", done)\n        self.assertEqual([\"start-root\", \"data-A\", \"start-a\",\n                           \"data-ca\", \"end-a\", \"data-B\", \"end-root\"],\n                          events)\n\n    def test_parser_target_recover(self):\n        events = []\n        class Target(object):\n            def start(self, tag, attrib):\n                events.append(\"start-\" + tag)\n            def end(self, tag):\n                events.append(\"end-\" + tag)\n            def data(self, data):\n                events.append(\"data-\" + data)\n            def close(self):\n                events.append(\"close\")\n                return \"DONE\"\n\n        parser = self.etree.XMLParser(target=Target(),\n                                      recover=True)\n\n        parser.feed(_bytes('<root>A<a>ca</a>B</not-root>'))\n        done = parser.close()\n\n        self.assertEqual(\"DONE\", done)\n        self.assertEqual([\"start-root\", \"data-A\", \"start-a\",\n                           \"data-ca\", \"end-a\", \"data-B\",\n                           \"end-root\", \"close\"],\n                          events)\n\n    def test_iterwalk_tag(self):\n        iterwalk = self.etree.iterwalk\n        root = self.etree.XML(_bytes('<a><b><d/></b><c/></a>'))\n\n        iterator = iterwalk(root, tag=\"b\", events=('start', 'end'))\n        events = list(iterator)\n        self.assertEqual(\n            [('start', root[0]), ('end', root[0])],\n            events)\n\n    def test_iterwalk_tag_all(self):\n        iterwalk = self.etree.iterwalk\n        root = self.etree.XML(_bytes('<a><b><d/></b><c/></a>'))\n\n        iterator = iterwalk(root, tag=\"*\", events=('start', 'end'))\n        events = list(iterator)\n        self.assertEqual(\n            8,\n            len(events))\n\n    def test_iterwalk(self):\n        iterwalk = self.etree.iterwalk\n        root = self.etree.XML(_bytes('<a><b></b><c/></a>'))\n\n        events = list(iterwalk(root))\n        self.assertEqual(\n            [('end', root[0]), ('end', root[1]), ('end', root)],\n            events)\n\n    def test_iterwalk_comments_root_element(self):\n        iterwalk = self.etree.iterwalk\n        root = self.etree.XML(\n            b'<!--C0--><a><!--Ca--><b><!--Cb--></b><!--Cc--><c/></a><!--C99-->')\n\n        iterator = iterwalk(root, events=('start', 'end', 'comment'))\n        events = list(iterator)\n        self.assertEqual(\n            [('start', root), ('comment', root[0]),\n             ('start', root[1]), ('comment', root[1][0]), ('end', root[1]),\n             ('comment', root[2]), ('start', root[3]), ('end', root[3]),\n             ('end', root),\n             ],\n            events)\n\n    def test_iterwalk_comments_tree(self):\n        iterwalk = self.etree.iterwalk\n        root = self.etree.XML(\n            b'<!--C0--><a><!--Ca--><b><!--Cb--></b><!--Cc--><c/></a><!--C99-->')\n\n        iterator = iterwalk(self.etree.ElementTree(root), events=('start', 'end', 'comment'))\n        events = list(iterator)\n        self.assertEqual(\n            [('comment', root.getprevious()),\n             ('start', root), ('comment', root[0]),  # <a>\n             ('start', root[1]), ('comment', root[1][0]), ('end', root[1]),  # <b>\n             ('comment', root[2]), ('start', root[3]), ('end', root[3]),  # <c>\n             ('end', root), ('comment', root.getnext()),\n             ],\n            events)\n\n    def test_iterwalk_pis_root_element(self):\n        iterwalk = self.etree.iterwalk\n        root = self.etree.XML(\n            b'<?C0?><a><?Ca?><b><?Cb?></b><?Cc?><c/></a><?C99?>')\n\n        iterator = iterwalk(root, events=('start', 'end', 'pi'))\n        events = list(iterator)\n        self.assertEqual(\n            [('start', root), ('pi', root[0]),\n             ('start', root[1]), ('pi', root[1][0]), ('end', root[1]),\n             ('pi', root[2]), ('start', root[3]), ('end', root[3]),\n             ('end', root),\n             ],\n            events)\n\n    def test_iterwalk_pis_tree(self):\n        iterwalk = self.etree.iterwalk\n        root = self.etree.XML(\n            b'<?C0?><a><?Ca?><b><?Cb?></b><?Cc?><c/></a><?C99?>')\n\n        iterator = iterwalk(self.etree.ElementTree(root), events=('start', 'end', 'pi'))\n        events = list(iterator)\n        self.assertEqual(\n            [('pi', root.getprevious()),\n             ('start', root), ('pi', root[0]),  # <a>\n             ('start', root[1]), ('pi', root[1][0]), ('end', root[1]),  # <b>\n             ('pi', root[2]), ('start', root[3]), ('end', root[3]),  # <c>\n             ('end', root), ('pi', root.getnext()),\n             ],\n            events)\n\n    def test_iterwalk_pis_comments_tree(self):\n        iterwalk = self.etree.iterwalk\n        root = self.etree.XML(\n            b'<!--C0--><?C0?><!--C1--><a><?Ca?><b><!--Cb--></b><?Cc?><c/></a><!--C99--><?C99?>')\n\n        iterator = iterwalk(self.etree.ElementTree(root), events=('start', 'end', 'pi', 'comment'))\n        events = list(iterator)\n        self.assertEqual(\n            [('comment', root.getprevious().getprevious().getprevious()),\n             ('pi', root.getprevious().getprevious()),\n             ('comment', root.getprevious()),\n             ('start', root), ('pi', root[0]),  # <a>\n             ('start', root[1]), ('comment', root[1][0]), ('end', root[1]),  # <b>\n             ('pi', root[2]), ('start', root[3]), ('end', root[3]),  # <c>\n             ('end', root), ('comment', root.getnext()), ('pi', root.getnext().getnext()),\n             ],\n            events)\n\n    def test_iterwalk_pis_comments_tree_no_events(self):\n        iterwalk = self.etree.iterwalk\n        root = self.etree.XML(\n            b'<!--C0--><?C0?><!--C1--><a><?Ca?><b><!--Cb--></b><?Cc?><c/></a><!--C99--><?C99?>')\n\n        iterator = iterwalk(self.etree.ElementTree(root), events=('start', 'end'))\n        events = list(iterator)\n        self.assertEqual(\n            [('start', root),  # <a>\n             ('start', root[1]), ('end', root[1]),  # <b>\n             ('start', root[3]), ('end', root[3]),  # <c>\n             ('end', root),\n             ],\n            events)\n\n    def test_iterwalk_start(self):\n        iterwalk = self.etree.iterwalk\n        root = self.etree.XML(_bytes('<a><b></b><c/></a>'))\n\n        iterator = iterwalk(root, events=('start',))\n        events = list(iterator)\n        self.assertEqual(\n            [('start', root), ('start', root[0]), ('start', root[1])],\n            events)\n\n    def test_iterwalk_start_end(self):\n        iterwalk = self.etree.iterwalk\n        root = self.etree.XML(_bytes('<a><b></b><c/></a>'))\n\n        iterator = iterwalk(root, events=('start','end'))\n        events = list(iterator)\n        self.assertEqual(\n            [('start', root), ('start', root[0]), ('end', root[0]),\n             ('start', root[1]), ('end', root[1]), ('end', root)],\n            events)\n\n    def test_iterwalk_start_tags(self):\n        iterwalk = self.etree.iterwalk\n        root = self.etree.XML(_bytes('<a><b></b><c/><b><d/></b></a>'))\n\n        iterator = iterwalk(root, events=('start',), tag='b')\n        events = list(iterator)\n        self.assertEqual(\n            [('start', root[0]), ('start', root[2])],\n            events)\n\n    def test_iterwalk_start_end_tags(self):\n        iterwalk = self.etree.iterwalk\n        root = self.etree.XML(_bytes('<a><b></b><c/><b><d/></b></a>'))\n\n        iterator = iterwalk(root, events=('start', 'end'), tag='b')\n        events = list(iterator)\n        self.assertEqual(\n            [('start', root[0]), ('end', root[0]), ('start', root[2]), ('end', root[2])],\n            events)\n\n    def test_iterwalk_start_end_tags_with_root(self):\n        iterwalk = self.etree.iterwalk\n        root = self.etree.XML(_bytes('<a><b></b><c/><b><d/></b></a>'))\n\n        iterator = iterwalk(root, events=('start', 'end'), tag=('b', 'a'))\n        events = list(iterator)\n        self.assertEqual(\n            [('start', root),\n             ('start', root[0]), ('end', root[0]),\n             ('start', root[2]), ('end', root[2]),\n             ('end', root),\n             ],\n            events)\n\n    def test_iterwalk_clear(self):\n        iterwalk = self.etree.iterwalk\n        root = self.etree.XML(_bytes('<a><b></b><c/></a>'))\n\n        iterator = iterwalk(root)\n        for event, elem in iterator:\n            elem.clear()\n\n        self.assertEqual(0,\n                          len(root))\n\n    def test_iterwalk_attrib_ns(self):\n        iterwalk = self.etree.iterwalk\n        root = self.etree.XML(_bytes('<a xmlns=\"ns1\"><b><c xmlns=\"ns2\"/></b></a>'))\n\n        attr_name = '{testns}bla'\n        events = []\n        iterator = iterwalk(root, events=('start','end','start-ns','end-ns'))\n        for event, elem in iterator:\n            events.append(event)\n            if event == 'start':\n                if elem.tag != '{ns1}a':\n                    elem.set(attr_name, 'value')\n\n        self.assertEqual(\n            ['start-ns', 'start', 'start', 'start-ns', 'start',\n             'end', 'end-ns', 'end', 'end', 'end-ns'],\n            events)\n\n        self.assertEqual(\n            None,\n            root.get(attr_name))\n        self.assertEqual(\n            'value',\n            root[0].get(attr_name))\n\n    def test_iterwalk_end_skip(self):\n        iterwalk = self.etree.iterwalk\n        root = self.etree.XML(_bytes('<a><b><c/></b><d><e/></d></a>'))\n\n        iterator = iterwalk(root)\n        tags = []\n        for event, elem in iterator:\n            tags.append(elem.tag)\n            # requesting a skip after an 'end' event should never have an effect\n            iterator.skip_subtree()\n\n        self.assertEqual(['c', 'b', 'e', 'd', 'a'], tags)\n\n    def test_iterwalk_start_end_skip(self):\n        iterwalk = self.etree.iterwalk\n        root = self.etree.XML(_bytes('<a><b><c/></b><d><e/></d></a>'))\n\n        iterator = iterwalk(root, events=('start', 'end'))\n        tags = []\n        for event, elem in iterator:\n            tags.append((event, elem.tag))\n            if elem.tag in ('b', 'e'):\n                # skipping should only have an effect on 'start', not on 'end'\n                iterator.skip_subtree()\n\n        self.assertEqual(\n            [('start', 'a'),\n             ('start', 'b'), ('end', 'b'),  # ignored child 'c'\n             ('start', 'd'),\n             ('start', 'e'), ('end', 'e'),\n             ('end', 'd'),\n             ('end', 'a')],\n            tags)\n\n    def test_iterwalk_ns_skip(self):\n        iterwalk = self.etree.iterwalk\n        root = self.etree.XML(_bytes(\n            '<a xmlns=\"ns1\"><b xmlns=\"nsb\"><c xmlns=\"ns2\"/></b><d xmlns=\"ns2\"><e/></d></a>'))\n\n        events = []\n        iterator = iterwalk(root, events=('start','start-ns','end-ns'))\n        for event, elem in iterator:\n            if event in ('start-ns', 'end-ns'):\n                events.append((event, elem))\n                if event == 'start-ns' and elem == ('', 'nsb'):\n                    events.append('skip')\n                    iterator.skip_subtree()\n            else:\n                events.append((event, elem.tag))\n\n        self.assertEqual(\n            [('start-ns', ('', 'ns1')),\n             ('start', '{ns1}a'),\n             ('start-ns', ('', 'nsb')),\n             'skip',\n             ('start', '{nsb}b'),\n             ('end-ns', None),\n             ('start-ns', ('', 'ns2')),\n             ('start', '{ns2}d'),\n             ('start', '{ns2}e'),\n             ('end-ns', None),\n             ('end-ns', None)\n             ],\n            events)\n\n    def test_iterwalk_getiterator(self):\n        iterwalk = self.etree.iterwalk\n        root = self.etree.XML(_bytes('<a><b><d/></b><c/></a>'))\n\n        counts = []\n        for event, elem in iterwalk(root):\n            counts.append(len(list(elem.getiterator())))\n        self.assertEqual(\n            [1,2,1,4],\n            counts)\n\n    def test_itertext_comment_pi(self):\n        # https://bugs.launchpad.net/lxml/+bug/1844674\n        XML = self.etree.XML\n        root = XML(_bytes(\n            \"<root>RTEXT<a></a>ATAIL<b/><!-- COMMENT -->CTAIL<?PI PITEXT?> PITAIL </root>\"\n        ))\n\n        text = list(root.itertext())\n        self.assertEqual([\"RTEXT\", \"ATAIL\", \"CTAIL\", \" PITAIL \"],\n                          text)\n\n    def test_resolve_string_dtd(self):\n        parse = self.etree.parse\n        parser = self.etree.XMLParser(dtd_validation=True)\n        assertEqual = self.assertEqual\n        test_url = _str(\"__nosuch.dtd\")\n\n        class MyResolver(self.etree.Resolver):\n            def resolve(self, url, id, context):\n                assertEqual(url, test_url)\n                return self.resolve_string(\n                    _str('''<!ENTITY myentity \"%s\">\n                        <!ELEMENT doc ANY>''') % url, context)\n\n        parser.resolvers.add(MyResolver())\n\n        xml = _str('<!DOCTYPE doc SYSTEM \"%s\"><doc>&myentity;</doc>') % test_url\n        tree = parse(StringIO(xml), parser)\n        root = tree.getroot()\n        self.assertEqual(root.text, test_url)\n\n    def test_resolve_bytes_dtd(self):\n        parse = self.etree.parse\n        parser = self.etree.XMLParser(dtd_validation=True)\n        assertEqual = self.assertEqual\n        test_url = _str(\"__nosuch.dtd\")\n\n        class MyResolver(self.etree.Resolver):\n            def resolve(self, url, id, context):\n                assertEqual(url, test_url)\n                return self.resolve_string(\n                    (_str('''<!ENTITY myentity \"%s\">\n                             <!ELEMENT doc ANY>''') % url).encode('utf-8'),\n                    context)\n\n        parser.resolvers.add(MyResolver())\n\n        xml = _str('<!DOCTYPE doc SYSTEM \"%s\"><doc>&myentity;</doc>') % test_url\n        tree = parse(StringIO(xml), parser)\n        root = tree.getroot()\n        self.assertEqual(root.text, test_url)\n\n    def test_resolve_filelike_dtd(self):\n        parse = self.etree.parse\n        parser = self.etree.XMLParser(dtd_validation=True)\n        assertEqual = self.assertEqual\n        test_url = _str(\"__nosuch.dtd\")\n\n        class MyResolver(self.etree.Resolver):\n            def resolve(self, url, id, context):\n                assertEqual(url, test_url)\n                return self.resolve_file(\n                    SillyFileLike(\n                        _str('''<!ENTITY myentity \"%s\">\n                        <!ELEMENT doc ANY>''') % url), context)\n\n        parser.resolvers.add(MyResolver())\n\n        xml = _str('<!DOCTYPE doc SYSTEM \"%s\"><doc>&myentity;</doc>') % test_url\n        tree = parse(StringIO(xml), parser)\n        root = tree.getroot()\n        self.assertEqual(root.text, test_url)\n\n    def test_resolve_filename_dtd(self):\n        parse = self.etree.parse\n        parser = self.etree.XMLParser(attribute_defaults=True)\n        assertEqual = self.assertEqual\n        test_url = _str(\"__nosuch.dtd\")\n\n        class MyResolver(self.etree.Resolver):\n            def resolve(self, url, id, context):\n                assertEqual(url, test_url)\n                return self.resolve_filename(\n                    fileInTestDir('test.dtd'), context)\n\n        parser.resolvers.add(MyResolver())\n\n        xml = _str('<!DOCTYPE a SYSTEM \"%s\"><a><b/></a>') % test_url\n        tree = parse(StringIO(xml), parser)\n        root = tree.getroot()\n        self.assertEqual(\n            root.attrib,    {'default': 'valueA'})\n        self.assertEqual(\n            root[0].attrib, {'default': 'valueB'})\n\n    def test_resolve_filename_dtd_relative(self):\n        parse = self.etree.parse\n        parser = self.etree.XMLParser(attribute_defaults=True)\n        assertEqual = self.assertEqual\n        test_url = _str(\"__nosuch.dtd\")\n\n        class MyResolver(self.etree.Resolver):\n            def resolve(self, url, id, context):\n                expected = fileUrlInTestDir(test_url)\n                url = url.replace('file://', 'file:')  # depends on libxml2 version\n                expected = expected.replace('file://', 'file:')\n                assertEqual(url, expected)\n                return self.resolve_filename(\n                    fileUrlInTestDir('test.dtd'), context)\n\n        parser.resolvers.add(MyResolver())\n\n        xml = _str('<!DOCTYPE a SYSTEM \"%s\"><a><b/></a>') % test_url\n        tree = parse(StringIO(xml), parser,\n                     base_url=fileUrlInTestDir('__test.xml'))\n        root = tree.getroot()\n        self.assertEqual(\n            root.attrib,    {'default': 'valueA'})\n        self.assertEqual(\n            root[0].attrib, {'default': 'valueB'})\n\n    def test_resolve_file_dtd(self):\n        parse = self.etree.parse\n        parser = self.etree.XMLParser(attribute_defaults=True)\n        assertEqual = self.assertEqual\n        test_url = _str(\"__nosuch.dtd\")\n\n        class MyResolver(self.etree.Resolver):\n            def resolve(self, url, id, context):\n                assertEqual(url, test_url)\n                return self.resolve_file(\n                    open(fileInTestDir('test.dtd'), 'rb'), context)\n\n        parser.resolvers.add(MyResolver())\n\n        xml = _str('<!DOCTYPE a SYSTEM \"%s\"><a><b/></a>') % test_url\n        tree = parse(StringIO(xml), parser)\n        root = tree.getroot()\n        self.assertEqual(\n            root.attrib,    {'default': 'valueA'})\n        self.assertEqual(\n            root[0].attrib, {'default': 'valueB'})\n\n    def test_resolve_empty(self):\n        parse = self.etree.parse\n        parser = self.etree.XMLParser(load_dtd=True)\n        assertEqual = self.assertEqual\n        test_url = _str(\"__nosuch.dtd\")\n\n        class check(object):\n            resolved = False\n\n        class MyResolver(self.etree.Resolver):\n            def resolve(self, url, id, context):\n                assertEqual(url, test_url)\n                check.resolved = True\n                return self.resolve_empty(context)\n\n        parser.resolvers.add(MyResolver())\n\n        xml = _str('<!DOCTYPE doc SYSTEM \"%s\"><doc>&myentity;</doc>') % test_url\n        self.assertRaises(etree.XMLSyntaxError, parse, StringIO(xml), parser)\n        self.assertTrue(check.resolved)\n\n    def test_resolve_error(self):\n        parse = self.etree.parse\n        parser = self.etree.XMLParser(dtd_validation=True)\n\n        class _LocalException(Exception):\n            pass\n\n        class MyResolver(self.etree.Resolver):\n            def resolve(self, url, id, context):\n                raise _LocalException\n\n        parser.resolvers.add(MyResolver())\n\n        xml = '<!DOCTYPE doc SYSTEM \"test\"><doc>&myentity;</doc>'\n        self.assertRaises(_LocalException, parse, BytesIO(xml), parser)\n\n    def test_entity_parse(self):\n        parse = self.etree.parse\n        tostring = self.etree.tostring\n        parser = self.etree.XMLParser(resolve_entities=False)\n        Entity = self.etree.Entity\n\n        xml = _bytes('<!DOCTYPE doc SYSTEM \"test\"><doc>&myentity;</doc>')\n        tree = parse(BytesIO(xml), parser)\n        root = tree.getroot()\n        self.assertEqual(root[0].tag, Entity)\n        self.assertEqual(root[0].text, \"&myentity;\")\n        self.assertEqual(root[0].tail, None)\n        self.assertEqual(root[0].name, \"myentity\")\n\n        self.assertEqual(_bytes('<doc>&myentity;</doc>'),\n                          tostring(root))\n\n    def test_entity_restructure(self):\n        xml = _bytes('''<!DOCTYPE root [ <!ENTITY nbsp \"&#160;\"> ]>\n            <root>\n              <child1/>\n              <child2/>\n              <child3>&nbsp;</child3>\n            </root>''')\n\n        parser = self.etree.XMLParser(resolve_entities=False)\n        root = etree.fromstring(xml, parser)\n        self.assertEqual([ el.tag for el in root ],\n                          ['child1', 'child2', 'child3'])\n\n        root[0] = root[-1]\n        self.assertEqual([ el.tag for el in root ],\n                          ['child3', 'child2'])\n        self.assertEqual(root[0][0].text, '&nbsp;')\n        self.assertEqual(root[0][0].name, 'nbsp')\n\n    def test_entity_append(self):\n        Entity = self.etree.Entity\n        Element = self.etree.Element\n        tostring = self.etree.tostring\n\n        root = Element(\"root\")\n        root.append( Entity(\"test\") )\n\n        self.assertEqual(root[0].tag, Entity)\n        self.assertEqual(root[0].text, \"&test;\")\n        self.assertEqual(root[0].tail, None)\n        self.assertEqual(root[0].name, \"test\")\n\n        self.assertEqual(_bytes('<root>&test;</root>'),\n                          tostring(root))\n\n    def test_entity_append_parsed(self):\n        Entity = self.etree.Entity\n        Element = self.etree.Element\n        parser = self.etree.XMLParser(resolve_entities=False)\n        entity = self.etree.XML('''<!DOCTYPE data [\n        <!ENTITY a \"a\">\n        <!ENTITY b \"&a;\">\n        ]>\n        <data>&b;</data>\n        ''', parser)\n\n        el = Element('test')\n        el.append(entity)\n        self.assertEqual(el.tag, 'test')\n        self.assertEqual(el[0].tag, 'data')\n        self.assertEqual(el[0][0].tag, Entity)\n        self.assertEqual(el[0][0].name, 'b')\n\n    def test_entity_values(self):\n        Entity = self.etree.Entity\n        self.assertEqual(Entity(\"test\").text, '&test;')\n        self.assertEqual(Entity(\"#17683\").text, '&#17683;')\n        self.assertEqual(Entity(\"#x1768\").text, '&#x1768;')\n        self.assertEqual(Entity(\"#x98AF\").text, '&#x98AF;')\n\n    def test_entity_error(self):\n        Entity = self.etree.Entity\n        self.assertRaises(ValueError, Entity, 'a b c')\n        self.assertRaises(ValueError, Entity, 'a,b')\n        self.assertRaises(ValueError, Entity, 'a\\0b')\n        self.assertRaises(ValueError, Entity, '#abc')\n        self.assertRaises(ValueError, Entity, '#xxyz')\n\n    def test_cdata(self):\n        CDATA = self.etree.CDATA\n        Element = self.etree.Element\n        tostring = self.etree.tostring\n\n        root = Element(\"root\")\n        root.text = CDATA('test')\n\n        self.assertEqual('test',\n                          root.text)\n        self.assertEqual(_bytes('<root><![CDATA[test]]></root>'),\n                          tostring(root))\n\n    def test_cdata_tail(self):\n        CDATA = self.etree.CDATA\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        tostring = self.etree.tostring\n\n        root = Element(\"root\")\n        child = SubElement(root, 'child')\n        child.tail = CDATA('test')\n\n        self.assertEqual('test', child.tail)\n        self.assertEqual(_bytes('<root><child/><![CDATA[test]]></root>'),\n                         tostring(root))\n\n        root = Element(\"root\")\n        root.tail = CDATA('test')\n\n        self.assertEqual('test', root.tail)\n        self.assertEqual(_bytes('<root/><![CDATA[test]]>'),\n                         tostring(root))\n\n    def test_cdata_type(self):\n        CDATA = self.etree.CDATA\n        Element = self.etree.Element\n        root = Element(\"root\")\n\n        root.text = CDATA(\"test\")\n        self.assertEqual('test', root.text)\n\n        root.text = CDATA(_str(\"test\"))\n        self.assertEqual('test', root.text)\n\n        self.assertRaises(TypeError, CDATA, 1)\n\n    def test_cdata_errors(self):\n        CDATA = self.etree.CDATA\n        Element = self.etree.Element\n\n        root = Element(\"root\")\n        cdata = CDATA('test')\n\n        self.assertRaises(TypeError,\n                          root.set, 'attr', cdata)\n        self.assertRaises(TypeError,\n                          operator.setitem, root.attrib, 'attr', cdata)\n\n    def test_cdata_parser(self):\n        tostring = self.etree.tostring\n        parser = self.etree.XMLParser(strip_cdata=False)\n        root = self.etree.XML(_bytes('<root><![CDATA[test]]></root>'), parser)\n\n        self.assertEqual('test', root.text)\n        self.assertEqual(_bytes('<root><![CDATA[test]]></root>'),\n                          tostring(root))\n\n    def test_cdata_xpath(self):\n        tostring = self.etree.tostring\n        parser = self.etree.XMLParser(strip_cdata=False)\n        root = self.etree.XML(_bytes('<root><![CDATA[test]]></root>'), parser)\n        self.assertEqual(_bytes('<root><![CDATA[test]]></root>'),\n                          tostring(root))\n\n        self.assertEqual(['test'], root.xpath('//text()'))\n\n    # TypeError in etree, AssertionError in ElementTree;\n    def test_setitem_assert(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        \n        self.assertRaises(TypeError,\n                          a.__setitem__, 0, 'foo')\n\n    def test_append_error(self):\n        Element = self.etree.Element\n        root = Element('root')\n        # raises AssertionError in ElementTree\n        self.assertRaises(TypeError, root.append, None)\n        self.assertRaises(TypeError, root.extend, [None])\n        self.assertRaises(TypeError, root.extend, [Element('one'), None])\n        self.assertEqual('one', root[0].tag)\n\n    def test_append_recursive_error(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        root = Element('root')\n        self.assertRaises(ValueError, root.append, root)\n        child = SubElement(root, 'child')\n        self.assertRaises(ValueError, child.append, root)\n        child2 = SubElement(child, 'child2')\n        self.assertRaises(ValueError, child2.append, root)\n        self.assertRaises(ValueError, child2.append, child)\n        self.assertEqual('child2', root[0][0].tag)\n\n    def test_addnext(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        root = Element('root')\n        SubElement(root, 'a')\n        SubElement(root, 'b')\n\n        self.assertEqual(['a', 'b'],\n                          [c.tag for c in root])\n        root[1].addnext(root[0])\n        self.assertEqual(['b', 'a'],\n                          [c.tag for c in root])\n\n    def test_addprevious(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        root = Element('root')\n        SubElement(root, 'a')\n        SubElement(root, 'b')\n\n        self.assertEqual(['a', 'b'],\n                          [c.tag for c in root])\n        root[0].addprevious(root[1])\n        self.assertEqual(['b', 'a'],\n                          [c.tag for c in root])\n\n    def test_addnext_cycle(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        root = Element('root')\n        a = SubElement(root, 'a')\n        b = SubElement(a, 'b')\n        # appending parent as sibling is forbidden\n        self.assertRaises(ValueError, b.addnext, a)\n        self.assertEqual(['a'], [c.tag for c in root])\n        self.assertEqual(['b'], [c.tag for c in a])\n\n    def test_addprevious_cycle(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        root = Element('root')\n        a = SubElement(root, 'a')\n        b = SubElement(a, 'b')\n        # appending parent as sibling is forbidden\n        self.assertRaises(ValueError, b.addprevious, a)\n        self.assertEqual(['a'], [c.tag for c in root])\n        self.assertEqual(['b'], [c.tag for c in a])\n\n    def test_addnext_cycle_long(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        root = Element('root')\n        a = SubElement(root, 'a')\n        b = SubElement(a, 'b')\n        c = SubElement(b, 'c')\n        # appending parent as sibling is forbidden\n        self.assertRaises(ValueError, c.addnext, a)\n\n    def test_addprevious_cycle_long(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        root = Element('root')\n        a = SubElement(root, 'a')\n        b = SubElement(a, 'b')\n        c = SubElement(b, 'c')\n        # appending parent as sibling is forbidden\n        self.assertRaises(ValueError, c.addprevious, a)\n\n    def test_addprevious_noops(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        root = Element('root')\n        a = SubElement(root, 'a')\n        b = SubElement(root, 'b')\n        a.addprevious(a)\n        self.assertEqual('a', root[0].tag)\n        self.assertEqual('b', root[1].tag)\n        b.addprevious(b)\n        self.assertEqual('a', root[0].tag)\n        self.assertEqual('b', root[1].tag)\n        b.addprevious(a)\n        self.assertEqual('a', root[0].tag)\n        self.assertEqual('b', root[1].tag)\n\n    def test_addnext_noops(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        root = Element('root')\n        a = SubElement(root, 'a')\n        b = SubElement(root, 'b')\n        a.addnext(a)\n        self.assertEqual('a', root[0].tag)\n        self.assertEqual('b', root[1].tag)\n        b.addnext(b)\n        self.assertEqual('a', root[0].tag)\n        self.assertEqual('b', root[1].tag)\n        a.addnext(b)\n        self.assertEqual('a', root[0].tag)\n        self.assertEqual('b', root[1].tag)\n\n    def test_addnext_root(self):\n        Element = self.etree.Element\n        a = Element('a')\n        b = Element('b')\n        self.assertRaises(TypeError, a.addnext, b)\n\n    def test_addprevious_pi(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        PI = self.etree.PI\n        root = Element('root')\n        SubElement(root, 'a')\n        pi = PI('TARGET', 'TEXT')\n        pi.tail = \"TAIL\"\n\n        self.assertEqual(_bytes('<root><a></a></root>'),\n                          self._writeElement(root))\n        root[0].addprevious(pi)\n        self.assertEqual(_bytes('<root><?TARGET TEXT?>TAIL<a></a></root>'),\n                          self._writeElement(root))\n\n    def test_addprevious_root_pi(self):\n        Element = self.etree.Element\n        PI = self.etree.PI\n        root = Element('root')\n        pi = PI('TARGET', 'TEXT')\n        pi.tail = \"TAIL\"\n\n        self.assertEqual(_bytes('<root></root>'),\n                          self._writeElement(root))\n        root.addprevious(pi)\n        self.assertEqual(_bytes('<?TARGET TEXT?>\\n<root></root>'),\n                          self._writeElement(root))\n\n    def test_addnext_pi(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        PI = self.etree.PI\n        root = Element('root')\n        SubElement(root, 'a')\n        pi = PI('TARGET', 'TEXT')\n        pi.tail = \"TAIL\"\n\n        self.assertEqual(_bytes('<root><a></a></root>'),\n                          self._writeElement(root))\n        root[0].addnext(pi)\n        self.assertEqual(_bytes('<root><a></a><?TARGET TEXT?>TAIL</root>'),\n                          self._writeElement(root))\n\n    def test_addnext_root_pi(self):\n        Element = self.etree.Element\n        PI = self.etree.PI\n        root = Element('root')\n        pi = PI('TARGET', 'TEXT')\n        pi.tail = \"TAIL\"\n\n        self.assertEqual(_bytes('<root></root>'),\n                          self._writeElement(root))\n        root.addnext(pi)\n        self.assertEqual(_bytes('<root></root>\\n<?TARGET TEXT?>'),\n                          self._writeElement(root))\n\n    def test_addnext_comment(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        Comment = self.etree.Comment\n        root = Element('root')\n        SubElement(root, 'a')\n        comment = Comment('TEXT ')\n        comment.tail = \"TAIL\"\n\n        self.assertEqual(_bytes('<root><a></a></root>'),\n                          self._writeElement(root))\n        root[0].addnext(comment)\n        self.assertEqual(_bytes('<root><a></a><!--TEXT -->TAIL</root>'),\n                          self._writeElement(root))\n\n    def test_addnext_root_comment(self):\n        Element = self.etree.Element\n        Comment = self.etree.Comment\n        root = Element('root')\n        comment = Comment('TEXT ')\n        comment.tail = \"TAIL\"\n\n        self.assertEqual(_bytes('<root></root>'),\n                          self._writeElement(root))\n        root.addnext(comment)\n        self.assertEqual(_bytes('<root></root>\\n<!--TEXT -->'),\n                          self._writeElement(root))\n\n    def test_addprevious_comment(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        Comment = self.etree.Comment\n        root = Element('root')\n        SubElement(root, 'a')\n        comment = Comment('TEXT ')\n        comment.tail = \"TAIL\"\n\n        self.assertEqual(_bytes('<root><a></a></root>'),\n                          self._writeElement(root))\n        root[0].addprevious(comment)\n        self.assertEqual(_bytes('<root><!--TEXT -->TAIL<a></a></root>'),\n                          self._writeElement(root))\n\n    def test_addprevious_root_comment(self):\n        Element = self.etree.Element\n        Comment = self.etree.Comment\n        root = Element('root')\n        comment = Comment('TEXT ')\n        comment.tail = \"TAIL\"\n\n        self.assertEqual(_bytes('<root></root>'),\n                          self._writeElement(root))\n        root.addprevious(comment)\n        self.assertEqual(_bytes('<!--TEXT -->\\n<root></root>'),\n                          self._writeElement(root))\n\n    # ET's Elements have items() and key(), but not values()\n    def test_attribute_values(self):\n        XML = self.etree.XML\n        \n        root = XML(_bytes('<doc alpha=\"Alpha\" beta=\"Beta\" gamma=\"Gamma\"/>'))\n        values = root.values()\n        values.sort()\n        self.assertEqual(['Alpha', 'Beta', 'Gamma'], values)\n\n    # gives error in ElementTree\n    def test_comment_empty(self):\n        Element = self.etree.Element\n        Comment = self.etree.Comment\n\n        a = Element('a')\n        a.append(Comment())\n        self.assertEqual(\n            _bytes('<a><!----></a>'),\n            self._writeElement(a))\n\n    # ElementTree ignores comments\n    def test_comment_parse_empty(self):\n        ElementTree = self.etree.ElementTree\n        tostring = self.etree.tostring\n\n        xml = _bytes('<a><b/><!----><c/></a>')\n        f = BytesIO(xml)\n        doc = ElementTree(file=f)\n        a = doc.getroot()\n        self.assertEqual(\n            '',\n            a[1].text)\n        self.assertEqual(\n            xml,\n            tostring(a))\n\n    # ElementTree ignores comments\n    def test_comment_no_proxy_yet(self):\n        ElementTree = self.etree.ElementTree\n        \n        f = BytesIO('<a><b></b><!-- hoi --><c></c></a>')\n        doc = ElementTree(file=f)\n        a = doc.getroot()\n        self.assertEqual(\n            ' hoi ',\n            a[1].text)\n\n    # does not raise an exception in ElementTree\n    def test_comment_immutable(self):\n        Element = self.etree.Element\n        Comment = self.etree.Comment\n\n        c = Comment()\n        el = Element('myel')\n\n        self.assertRaises(TypeError, c.append, el)\n        self.assertRaises(TypeError, c.insert, 0, el)\n        self.assertRaises(TypeError, c.set, \"myattr\", \"test\")\n\n    def test_comment_immutable_attrib(self):\n        c = self.etree.Comment()\n        self.assertEqual(0, len(c.attrib))\n\n        self.assertFalse(c.attrib.__contains__('nope'))\n        self.assertFalse('nope' in c.attrib)\n        self.assertFalse('nope' in c.attrib.keys())\n        self.assertFalse('nope' in c.attrib.values())\n        self.assertFalse(('nope', 'huhu') in c.attrib.items())\n\n        self.assertEqual([], list(c.attrib))\n        self.assertEqual([], list(c.attrib.keys()))\n        self.assertEqual([], list(c.attrib.items()))\n        self.assertEqual([], list(c.attrib.values()))\n        self.assertEqual([], list(c.attrib.iterkeys()))\n        self.assertEqual([], list(c.attrib.iteritems()))\n        self.assertEqual([], list(c.attrib.itervalues()))\n\n        self.assertEqual('HUHU', c.attrib.pop('nope', 'HUHU'))\n        self.assertRaises(KeyError, c.attrib.pop, 'nope')\n\n        self.assertRaises(KeyError, c.attrib.__getitem__, 'only')\n        self.assertRaises(KeyError, c.attrib.__getitem__, 'names')\n        self.assertRaises(KeyError, c.attrib.__getitem__, 'nope')\n        self.assertRaises(KeyError, c.attrib.__setitem__, 'nope', 'yep')\n        self.assertRaises(KeyError, c.attrib.__delitem__, 'nope')\n\n    # test passing 'None' to dump()\n    def test_dump_none(self):\n        self.assertRaises(TypeError, self.etree.dump, None)\n\n    def test_prefix(self):\n        ElementTree = self.etree.ElementTree\n        \n        f = BytesIO('<a xmlns:foo=\"http://www.infrae.com/ns/1\"><foo:b/></a>')\n        doc = ElementTree(file=f)\n        a = doc.getroot()\n        self.assertEqual(\n            None,\n            a.prefix)\n        self.assertEqual(\n            'foo',\n            a[0].prefix)\n\n    def test_prefix_default_ns(self):\n        ElementTree = self.etree.ElementTree\n        \n        f = BytesIO('<a xmlns=\"http://www.infrae.com/ns/1\"><b/></a>')\n        doc = ElementTree(file=f)\n        a = doc.getroot()\n        self.assertEqual(\n            None,\n            a.prefix)\n        self.assertEqual(\n            None,\n            a[0].prefix)\n\n    def test_getparent(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(b, 'd')\n        self.assertEqual(\n            None,\n            a.getparent())\n        self.assertEqual(\n            a,\n            b.getparent())\n        self.assertEqual(\n            b.getparent(),\n            c.getparent())\n        self.assertEqual(\n            b,\n            d.getparent())\n\n    def test_iterchildren(self):\n        XML = self.etree.XML\n        \n        root = XML(_bytes('<doc><one/><two>Two</two>Hm<three/></doc>'))\n        result = []\n        for el in root.iterchildren():\n            result.append(el.tag)\n        self.assertEqual(['one', 'two', 'three'], result)\n\n    def test_iterchildren_reversed(self):\n        XML = self.etree.XML\n        \n        root = XML(_bytes('<doc><one/><two>Two</two>Hm<three/></doc>'))\n        result = []\n        for el in root.iterchildren(reversed=True):\n            result.append(el.tag)\n        self.assertEqual(['three', 'two', 'one'], result)\n\n    def test_iterchildren_tag(self):\n        XML = self.etree.XML\n        \n        root = XML(_bytes('<doc><one/><two>Two</two>Hm<two>Bla</two></doc>'))\n        result = []\n        for el in root.iterchildren(tag='two'):\n            result.append(el.text)\n        self.assertEqual(['Two', 'Bla'], result)\n\n    def test_iterchildren_tag_posarg(self):\n        XML = self.etree.XML\n\n        root = XML(_bytes('<doc><one/><two>Two</two>Hm<two>Bla</two></doc>'))\n        result = []\n        for el in root.iterchildren('two'):\n            result.append(el.text)\n        self.assertEqual(['Two', 'Bla'], result)\n\n    def test_iterchildren_tag_reversed(self):\n        XML = self.etree.XML\n        \n        root = XML(_bytes('<doc><one/><two>Two</two>Hm<two>Bla</two></doc>'))\n        result = []\n        for el in root.iterchildren(reversed=True, tag='two'):\n            result.append(el.text)\n        self.assertEqual(['Bla', 'Two'], result)\n\n    def test_iterchildren_tag_multiple(self):\n        XML = self.etree.XML\n\n        root = XML(_bytes('<doc><one/><two>Two</two>Hm<two>Bla</two><three/></doc>'))\n        result = []\n        for el in root.iterchildren(tag=['two', 'three']):\n            result.append(el.text)\n        self.assertEqual(['Two', 'Bla', None], result)\n\n    def test_iterchildren_tag_multiple_posarg(self):\n        XML = self.etree.XML\n\n        root = XML(_bytes('<doc><one/><two>Two</two>Hm<two>Bla</two><three/></doc>'))\n        result = []\n        for el in root.iterchildren('two', 'three'):\n            result.append(el.text)\n        self.assertEqual(['Two', 'Bla', None], result)\n\n    def test_iterchildren_tag_multiple_reversed(self):\n        XML = self.etree.XML\n\n        root = XML(_bytes('<doc><one/><two>Two</two>Hm<two>Bla</two><three/></doc>'))\n        result = []\n        for el in root.iterchildren(reversed=True, tag=['two', 'three']):\n            result.append(el.text)\n        self.assertEqual([None, 'Bla', 'Two'], result)\n\n    def test_iterancestors(self):\n        Element    = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(b, 'd')\n        self.assertEqual(\n            [],\n            list(a.iterancestors()))\n        self.assertEqual(\n            [a],\n            list(b.iterancestors()))\n        self.assertEqual(\n            [a],\n            list(c.iterancestors()))\n        self.assertEqual(\n            [b, a],\n            list(d.iterancestors()))\n\n    def test_iterancestors_tag(self):\n        Element    = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(b, 'd')\n        self.assertEqual(\n            [a],\n            list(d.iterancestors('a')))\n        self.assertEqual(\n            [a],\n            list(d.iterancestors(tag='a')))\n\n        self.assertEqual(\n            [b, a],\n            list(d.iterancestors('*')))\n        self.assertEqual(\n            [b, a],\n            list(d.iterancestors(tag='*')))\n\n    def test_iterancestors_tag_multiple(self):\n        Element    = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(b, 'd')\n        self.assertEqual(\n            [b, a],\n            list(d.iterancestors(tag=('a', 'b'))))\n        self.assertEqual(\n            [b, a],\n            list(d.iterancestors('a', 'b')))\n\n        self.assertEqual(\n            [],\n            list(d.iterancestors(tag=('w', 'x', 'y', 'z'))))\n        self.assertEqual(\n            [],\n            list(d.iterancestors('w', 'x', 'y', 'z')))\n\n        self.assertEqual(\n            [],\n            list(d.iterancestors(tag=('d', 'x'))))\n        self.assertEqual(\n            [],\n            list(d.iterancestors('d', 'x')))\n\n        self.assertEqual(\n            [b, a],\n            list(d.iterancestors(tag=('b', '*'))))\n        self.assertEqual(\n            [b, a],\n            list(d.iterancestors('b', '*')))\n\n        self.assertEqual(\n            [b],\n            list(d.iterancestors(tag=('b', 'c'))))\n        self.assertEqual(\n            [b],\n            list(d.iterancestors('b', 'c')))\n\n    def test_iterdescendants(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(b, 'd')\n        e = SubElement(c, 'e')\n\n        self.assertEqual(\n            [b, d, c, e],\n            list(a.iterdescendants()))\n        self.assertEqual(\n            [],\n            list(d.iterdescendants()))\n\n    def test_iterdescendants_tag(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(b, 'd')\n        e = SubElement(c, 'e')\n\n        self.assertEqual(\n            [],\n            list(a.iterdescendants('a')))\n        self.assertEqual(\n            [],\n            list(a.iterdescendants(tag='a')))\n\n        a2 = SubElement(e, 'a')\n        self.assertEqual(\n            [a2],\n            list(a.iterdescendants('a')))\n\n        self.assertEqual(\n            [a2],\n            list(c.iterdescendants('a')))\n        self.assertEqual(\n            [a2],\n            list(c.iterdescendants(tag='a')))\n\n    def test_iterdescendants_tag_multiple(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(b, 'd')\n        e = SubElement(c, 'e')\n\n        self.assertEqual(\n            [b, e],\n            list(a.iterdescendants(tag=('a', 'b', 'e'))))\n        self.assertEqual(\n            [b, e],\n            list(a.iterdescendants('a', 'b', 'e')))\n\n        a2 = SubElement(e, 'a')\n        self.assertEqual(\n            [b, a2],\n            list(a.iterdescendants(tag=('a', 'b'))))\n        self.assertEqual(\n            [b, a2],\n            list(a.iterdescendants('a', 'b')))\n\n        self.assertEqual(\n            [],\n            list(c.iterdescendants(tag=('x', 'y', 'z'))))\n        self.assertEqual(\n            [],\n            list(c.iterdescendants('x', 'y', 'z')))\n\n        self.assertEqual(\n            [b, d, c, e, a2],\n            list(a.iterdescendants(tag=('x', 'y', 'z', '*'))))\n        self.assertEqual(\n            [b, d, c, e, a2],\n            list(a.iterdescendants('x', 'y', 'z', '*')))\n\n    def test_getroottree(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(b, 'd')\n        self.assertEqual(\n            a,\n            a.getroottree().getroot())\n        self.assertEqual(\n            a,\n            b.getroottree().getroot())\n        self.assertEqual(\n            a,\n            d.getroottree().getroot())\n\n    def test_getnext(self):\n        Element    = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        self.assertEqual(\n            None,\n            a.getnext())\n        self.assertEqual(\n            c,\n            b.getnext())\n        self.assertEqual(\n            None,\n            c.getnext())\n\n    def test_getprevious(self):\n        Element    = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(b, 'd')\n        self.assertEqual(\n            None,\n            a.getprevious())\n        self.assertEqual(\n            b,\n            c.getprevious())\n        self.assertEqual(\n            None,\n            b.getprevious())\n\n    def test_itersiblings(self):\n        Element    = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(b, 'd')\n        self.assertEqual(\n            [],\n            list(a.itersiblings()))\n        self.assertEqual(\n            [c],\n            list(b.itersiblings()))\n        self.assertEqual(\n            [],\n            list(c.itersiblings()))\n        self.assertEqual(\n            [b],\n            list(c.itersiblings(preceding=True)))\n        self.assertEqual(\n            [],\n            list(b.itersiblings(preceding=True)))\n\n    def test_itersiblings_tag(self):\n        Element    = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(b, 'd')\n        self.assertEqual(\n            [],\n            list(a.itersiblings(tag='XXX')))\n        self.assertEqual(\n            [c],\n            list(b.itersiblings(tag='c')))\n        self.assertEqual(\n            [c],\n            list(b.itersiblings(tag='*')))\n        self.assertEqual(\n            [b],\n            list(c.itersiblings(preceding=True, tag='b')))\n        self.assertEqual(\n            [],\n            list(c.itersiblings(preceding=True, tag='c')))\n\n    def test_itersiblings_tag_multiple(self):\n        Element    = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(b, 'd')\n        e = SubElement(a, 'e')\n        self.assertEqual(\n            [],\n            list(a.itersiblings(tag=('XXX', 'YYY'))))\n        self.assertEqual(\n            [c, e],\n            list(b.itersiblings(tag=('c', 'd', 'e'))))\n        self.assertEqual(\n            [b],\n            list(c.itersiblings(preceding=True, tag=('b', 'b', 'c', 'd'))))\n        self.assertEqual(\n            [c, b],\n            list(e.itersiblings(preceding=True, tag=('c', '*'))))\n\n    def test_parseid(self):\n        parseid = self.etree.parseid\n        XML     = self.etree.XML\n        xml_text = _bytes('''\n        <!DOCTYPE document [\n        <!ELEMENT document (h1,p)*>\n        <!ELEMENT h1 (#PCDATA)>\n        <!ATTLIST h1 myid ID #REQUIRED>\n        <!ELEMENT p  (#PCDATA)>\n        <!ATTLIST p  someid ID #REQUIRED>\n        ]>\n        <document>\n          <h1 myid=\"chapter1\">...</h1>\n          <p id=\"note1\" class=\"note\">...</p>\n          <p>Regular paragraph.</p>\n          <p xml:id=\"xmlid\">XML:ID paragraph.</p>\n          <p someid=\"warn1\" class=\"warning\">...</p>\n        </document>\n        ''')\n\n        tree, dic = parseid(BytesIO(xml_text))\n        root = tree.getroot()\n        root2 = XML(xml_text)\n        self.assertEqual(self._writeElement(root),\n                          self._writeElement(root2))\n        expected = {\n            \"chapter1\" : root[0],\n            \"xmlid\"    : root[3],\n            \"warn1\"    : root[4]\n            }\n        self.assertTrue(\"chapter1\" in dic)\n        self.assertTrue(\"warn1\" in dic)\n        self.assertTrue(\"xmlid\" in dic)\n        self._checkIDDict(dic, expected)\n\n    def test_XMLDTDID(self):\n        XMLDTDID = self.etree.XMLDTDID\n        XML      = self.etree.XML\n        xml_text = _bytes('''\n        <!DOCTYPE document [\n        <!ELEMENT document (h1,p)*>\n        <!ELEMENT h1 (#PCDATA)>\n        <!ATTLIST h1 myid ID #REQUIRED>\n        <!ELEMENT p  (#PCDATA)>\n        <!ATTLIST p  someid ID #REQUIRED>\n        ]>\n        <document>\n          <h1 myid=\"chapter1\">...</h1>\n          <p id=\"note1\" class=\"note\">...</p>\n          <p>Regular paragraph.</p>\n          <p xml:id=\"xmlid\">XML:ID paragraph.</p>\n          <p someid=\"warn1\" class=\"warning\">...</p>\n        </document>\n        ''')\n\n        root, dic = XMLDTDID(xml_text)\n        root2 = XML(xml_text)\n        self.assertEqual(self._writeElement(root),\n                          self._writeElement(root2))\n        expected = {\n            \"chapter1\" : root[0],\n            \"xmlid\"    : root[3],\n            \"warn1\"    : root[4]\n            }\n        self.assertTrue(\"chapter1\" in dic)\n        self.assertTrue(\"warn1\" in dic)\n        self.assertTrue(\"xmlid\" in dic)\n        self._checkIDDict(dic, expected)\n\n    def test_XMLDTDID_empty(self):\n        XMLDTDID = self.etree.XMLDTDID\n        XML      = self.etree.XML\n        xml_text = _bytes('''\n        <document>\n          <h1 myid=\"chapter1\">...</h1>\n          <p id=\"note1\" class=\"note\">...</p>\n          <p>Regular paragraph.</p>\n          <p someid=\"warn1\" class=\"warning\">...</p>\n        </document>\n        ''')\n\n        root, dic = XMLDTDID(xml_text)\n        root2 = XML(xml_text)\n        self.assertEqual(self._writeElement(root),\n                          self._writeElement(root2))\n        expected = {}\n        self._checkIDDict(dic, expected)\n\n    def test_XMLDTDID_no_id_dict(self):\n        XMLDTDID = self.etree.XMLDTDID\n        XML      = self.etree.XML\n        xml_text = _bytes('''\n        <!DOCTYPE document [\n        <!ELEMENT document (h1,p)*>\n        <!ELEMENT h1 (#PCDATA)>\n        <!ATTLIST h1 myid ID #REQUIRED>\n        <!ELEMENT p  (#PCDATA)>\n        <!ATTLIST p  someid ID #REQUIRED>\n        ]>\n        <document>\n          <h1 myid=\"chapter1\">...</h1>\n          <p id=\"note1\" class=\"note\">...</p>\n          <p>Regular paragraph.</p>\n          <p xml:id=\"xmlid\">XML:ID paragraph.</p>\n          <p someid=\"warn1\" class=\"warning\">...</p>\n        </document>\n        ''')\n\n        parser = etree.XMLParser(collect_ids=False)\n        root, dic = XMLDTDID(xml_text, parser=parser)\n        root2 = XML(xml_text)\n        self.assertEqual(self._writeElement(root),\n                         self._writeElement(root2))\n        self.assertFalse(dic)\n        self._checkIDDict(dic, {})\n\n    def _checkIDDict(self, dic, expected):\n        self.assertEqual(len(dic),\n                          len(expected))\n        self.assertEqual(sorted(dic.items()),\n                          sorted(expected.items()))\n        if sys.version_info < (3,):\n            self.assertEqual(sorted(dic.iteritems()),\n                              sorted(expected.iteritems()))\n        self.assertEqual(sorted(dic.keys()),\n                          sorted(expected.keys()))\n        if sys.version_info < (3,):\n            self.assertEqual(sorted(dic.iterkeys()),\n                              sorted(expected.iterkeys()))\n        if sys.version_info < (3,):\n            self.assertEqual(sorted(dic.values()),\n                              sorted(expected.values()))\n            self.assertEqual(sorted(dic.itervalues()),\n                              sorted(expected.itervalues()))\n\n    def test_register_namespace_xml(self):\n        self.assertRaises(ValueError, self.etree.register_namespace,\n                          \"XML\", \"http://www.w3.org/XML/1998/namespace\")\n        self.assertRaises(ValueError, self.etree.register_namespace,\n                          \"xml\", \"http://www.w3.org/XML/2345\")\n        self.etree.register_namespace(\"xml\", \"http://www.w3.org/XML/1998/namespace\")  # ok\n\n    def test_namespaces(self):\n        etree = self.etree\n\n        r = {'foo': 'http://ns.infrae.com/foo'}\n        e = etree.Element('{http://ns.infrae.com/foo}bar', nsmap=r)\n        self.assertEqual(\n            'foo',\n            e.prefix)\n        self.assertEqual(\n            _bytes('<foo:bar xmlns:foo=\"http://ns.infrae.com/foo\"></foo:bar>'),\n            self._writeElement(e))\n        \n    def test_namespaces_default(self):\n        etree = self.etree\n\n        r = {None: 'http://ns.infrae.com/foo'}\n        e = etree.Element('{http://ns.infrae.com/foo}bar', nsmap=r)\n        self.assertEqual(\n            None,\n            e.prefix)\n        self.assertEqual(\n            '{http://ns.infrae.com/foo}bar',\n            e.tag)\n        self.assertEqual(\n            _bytes('<bar xmlns=\"http://ns.infrae.com/foo\"></bar>'),\n            self._writeElement(e))\n\n    def test_namespaces_default_and_other(self):\n        etree = self.etree\n\n        r = {None: 'http://ns.infrae.com/foo', 'p': 'http://test/'}\n        e = etree.Element('{http://ns.infrae.com/foo}bar', nsmap=r)\n        self.assertEqual(None, e.prefix)\n        self.assertEqual('{http://ns.infrae.com/foo}bar', e.tag)\n        self.assertEqual(\n            _bytes('<bar xmlns=\"http://ns.infrae.com/foo\" xmlns:p=\"http://test/\"></bar>'),\n            self._writeElement(e))\n\n    def test_namespaces_default_and_attr(self):\n        etree = self.etree\n\n        r = {None: 'http://ns.infrae.com/foo',\n             'hoi': 'http://ns.infrae.com/hoi'}\n        e = etree.Element('{http://ns.infrae.com/foo}bar', nsmap=r)\n        e.set('{http://ns.infrae.com/hoi}test', 'value')\n        self.assertEqual(\n            _bytes('<bar xmlns=\"http://ns.infrae.com/foo\" xmlns:hoi=\"http://ns.infrae.com/hoi\" hoi:test=\"value\"></bar>'),\n            self._writeElement(e))\n\n    def test_attribute_keeps_namespace_prefix_on_merge(self):\n        etree = self.etree\n\n        root = etree.Element('{http://test/ns}root',\n                             nsmap={None: 'http://test/ns'})\n        sub = etree.Element('{http://test/ns}sub',\n                            nsmap={'test': 'http://test/ns'})\n\n        sub.attrib['{http://test/ns}attr'] = 'value'\n        self.assertEqual(sub.attrib['{http://test/ns}attr'], 'value')\n        self.assertEqual(\n            _bytes('<test:sub xmlns:test=\"http://test/ns\" test:attr=\"value\"/>'),\n            etree.tostring(sub))\n\n        root.append(sub)\n        self.assertEqual(\n            _bytes('<root xmlns=\"http://test/ns\">'\n                   '<sub xmlns:test=\"http://test/ns\" test:attr=\"value\"/>'\n                   '</root>'),\n            etree.tostring(root))\n\n    def test_attribute_keeps_namespace_prefix_on_merge_with_nons(self):\n        etree = self.etree\n\n        root = etree.Element('root')\n        sub = etree.Element('{http://test/ns}sub',\n                            nsmap={'test': 'http://test/ns'})\n\n        sub.attrib['{http://test/ns}attr'] = 'value'\n        self.assertEqual(sub.attrib['{http://test/ns}attr'], 'value')\n        self.assertEqual(\n            _bytes('<test:sub xmlns:test=\"http://test/ns\" test:attr=\"value\"/>'),\n            etree.tostring(sub))\n\n        root.append(sub)\n        self.assertEqual(\n            _bytes('<root>'\n                   '<test:sub xmlns:test=\"http://test/ns\" test:attr=\"value\"/>'\n                   '</root>'),\n            etree.tostring(root))\n\n    def test_attribute_gets_namespace_prefix_on_merge_with_nons(self):\n        etree = self.etree\n\n        root = etree.Element('root')\n        sub = etree.Element('{http://test/ns}sub',\n                            nsmap={None: 'http://test/ns'})\n\n        sub.attrib['{http://test/ns}attr'] = 'value'\n        self.assertEqual(sub.attrib['{http://test/ns}attr'], 'value')\n        self.assertEqual(\n            _bytes('<sub xmlns=\"http://test/ns\" '\n                   'xmlns:ns0=\"http://test/ns\" ns0:attr=\"value\"/>'),\n            etree.tostring(sub))\n\n        root.append(sub)\n        self.assertEqual(\n            _bytes('<root>'\n                   '<sub xmlns=\"http://test/ns\"'\n                   ' xmlns:ns0=\"http://test/ns\" ns0:attr=\"value\"/>'\n                   '</root>'),\n            etree.tostring(root))\n\n    def test_attribute_gets_namespace_prefix_on_merge(self):\n        etree = self.etree\n\n        root = etree.Element('{http://test/ns}root',\n                             nsmap={'test': 'http://test/ns',\n                                    None: 'http://test/ns'})\n        sub = etree.Element('{http://test/ns}sub',\n                            nsmap={None: 'http://test/ns'})\n\n        sub.attrib['{http://test/ns}attr'] = 'value'\n        self.assertEqual(sub.attrib['{http://test/ns}attr'], 'value')\n        self.assertEqual(\n            _bytes('<sub xmlns=\"http://test/ns\" '\n                   'xmlns:ns0=\"http://test/ns\" ns0:attr=\"value\"/>'),\n            etree.tostring(sub))\n\n        root.append(sub)\n        self.assertEqual(\n            _bytes('<test:root xmlns:test=\"http://test/ns\" xmlns=\"http://test/ns\">'\n                   '<test:sub test:attr=\"value\"/>'\n                   '</test:root>'),\n            etree.tostring(root))\n\n    def test_namespaces_elementtree(self):\n        etree = self.etree\n        r = {None: 'http://ns.infrae.com/foo',\n             'hoi': 'http://ns.infrae.com/hoi'} \n        e = etree.Element('{http://ns.infrae.com/foo}z', nsmap=r)\n        tree = etree.ElementTree(element=e)\n        etree.SubElement(e, '{http://ns.infrae.com/hoi}x')\n        self.assertEqual(\n            _bytes('<z xmlns=\"http://ns.infrae.com/foo\" xmlns:hoi=\"http://ns.infrae.com/hoi\"><hoi:x></hoi:x></z>'),\n            self._writeElement(e))\n\n    def test_namespaces_default_copy_element(self):\n        etree = self.etree\n\n        r = {None: 'http://ns.infrae.com/foo'}\n        e1 = etree.Element('{http://ns.infrae.com/foo}bar', nsmap=r)\n        e2 = etree.Element('{http://ns.infrae.com/foo}bar', nsmap=r)\n\n        e1.append(e2)\n\n        self.assertEqual(\n            None,\n            e1.prefix)\n        self.assertEqual(\n            None,\n            e1[0].prefix)\n        self.assertEqual(\n            '{http://ns.infrae.com/foo}bar',\n            e1.tag)\n        self.assertEqual(\n            '{http://ns.infrae.com/foo}bar',\n            e1[0].tag)\n\n    def test_namespaces_copy_element(self):\n        etree = self.etree\n\n        r = {None: 'http://ns.infrae.com/BAR'}\n        e1 = etree.Element('{http://ns.infrae.com/BAR}bar', nsmap=r)\n        e2 = etree.Element('{http://ns.infrae.com/foo}bar', nsmap=r)\n\n        e1.append(e2)\n\n        self.assertEqual(\n            None,\n            e1.prefix)\n        self.assertNotEqual(\n            None,\n            e2.prefix)\n        self.assertEqual(\n            '{http://ns.infrae.com/BAR}bar',\n            e1.tag)\n        self.assertEqual(\n            '{http://ns.infrae.com/foo}bar',\n            e2.tag)\n\n    def test_namespaces_reuse_after_move(self):\n        ns_href = \"http://a.b.c\"\n        one = self.etree.fromstring(\n            _bytes('<foo><bar xmlns:ns=\"%s\"><ns:baz/></bar></foo>' % ns_href))\n        baz = one[0][0]\n\n        two = self.etree.fromstring(\n            _bytes('<root xmlns:ns=\"%s\"/>' % ns_href))\n        two.append(baz)\n        del one # make sure the source document is deallocated\n\n        self.assertEqual('{%s}baz' % ns_href, baz.tag)\n        self.assertEqual(\n            _bytes('<root xmlns:ns=\"%s\"><ns:baz/></root>' % ns_href),\n            self.etree.tostring(two))\n\n    def test_namespace_cleanup(self):\n        xml = _bytes(\n            '<foo xmlns=\"F\" xmlns:x=\"x\">'\n            '<bar xmlns:ns=\"NS\" xmlns:b=\"b\" xmlns=\"B\">'\n            '<ns:baz/>'\n            '</bar></foo>'\n        )\n        root = self.etree.fromstring(xml)\n        self.assertEqual(xml, self.etree.tostring(root))\n        self.etree.cleanup_namespaces(root)\n        self.assertEqual(\n            _bytes('<foo xmlns=\"F\"><bar xmlns:ns=\"NS\" xmlns=\"B\"><ns:baz/></bar></foo>'),\n            self.etree.tostring(root))\n\n    def test_namespace_cleanup_attributes(self):\n        xml = _bytes(\n            '<foo xmlns=\"F\" xmlns:x=\"X\" xmlns:a=\"A\">'\n            '<bar xmlns:ns=\"NS\" xmlns:b=\"b\" xmlns=\"B\">'\n            '<ns:baz a:test=\"attr\"/>'\n            '</bar></foo>'\n        )\n        root = self.etree.fromstring(xml)\n        self.assertEqual(xml, self.etree.tostring(root))\n        self.etree.cleanup_namespaces(root)\n        self.assertEqual(\n            _bytes('<foo xmlns=\"F\" xmlns:a=\"A\">'\n                   '<bar xmlns:ns=\"NS\" xmlns=\"B\">'\n                   '<ns:baz a:test=\"attr\"/>'\n                   '</bar></foo>'),\n            self.etree.tostring(root))\n\n    def test_namespace_cleanup_many(self):\n        xml = ('<n12:foo ' +\n               ' '.join('xmlns:n{n}=\"NS{n}\"'.format(n=i) for i in range(100)) +\n               '><n68:a/></n12:foo>').encode('utf8')\n        root = self.etree.fromstring(xml)\n        self.assertEqual(xml, self.etree.tostring(root))\n        self.etree.cleanup_namespaces(root)\n        self.assertEqual(\n            b'<n12:foo xmlns:n12=\"NS12\" xmlns:n68=\"NS68\"><n68:a/></n12:foo>',\n            self.etree.tostring(root))\n\n    def test_namespace_cleanup_deep(self):\n        xml = ('<root>' +\n               ''.join('<a xmlns:n{n}=\"NS{n}\">'.format(n=i) for i in range(100)) +\n               '<n64:x/>' + '</a>'*100 + '</root>').encode('utf8')\n        root = self.etree.fromstring(xml)\n        self.assertEqual(xml, self.etree.tostring(root))\n        self.etree.cleanup_namespaces(root)\n        self.assertEqual(\n            b'<root>' + b'<a>'*64 + b'<a xmlns:n64=\"NS64\">' + b'<a>'*35 +\n            b'<n64:x/>' + b'</a>'*100 + b'</root>',\n            self.etree.tostring(root))\n\n    def test_namespace_cleanup_deep_to_top(self):\n        xml = ('<root>' +\n               ''.join('<a xmlns:n{n}=\"NS{n}\">'.format(n=i) for i in range(100)) +\n               '<n64:x xmlns:a=\"A\" a:attr=\"X\"/>' +\n               '</a>'*100 +\n               '</root>').encode('utf8')\n        root = self.etree.fromstring(xml)\n        self.assertEqual(xml, self.etree.tostring(root))\n        self.etree.cleanup_namespaces(root, top_nsmap={'n64': 'NS64'})\n        self.assertEqual(\n            b'<root xmlns:n64=\"NS64\">' + b'<a>'*100 +\n            b'<n64:x xmlns:a=\"A\" a:attr=\"X\"/>' + b'</a>'*100 + b'</root>',\n            self.etree.tostring(root))\n\n    def test_namespace_cleanup_keep_prefixes(self):\n        xml = ('<root xmlns:n64=\"NS64\" xmlns:foo=\"FOO\" xmlns:unused1=\"UNUSED\" xmlns:no=\"NO\">'\n               '<a xmlns:unused2=\"UNUSED\"><n64:x xmlns:a=\"A\" a:attr=\"X\"/></a>'\n               '<foo>foo:bar</foo>'\n               '</root>').encode('utf8')\n        root = self.etree.fromstring(xml)\n        self.assertEqual(xml, self.etree.tostring(root))\n        self.etree.cleanup_namespaces(root, keep_ns_prefixes=['foo'])\n        self.assertEqual(\n            b'<root xmlns:n64=\"NS64\" xmlns:foo=\"FOO\">'\n            b'<a><n64:x xmlns:a=\"A\" a:attr=\"X\"/></a>'\n            b'<foo>foo:bar</foo>'\n            b'</root>',\n            self.etree.tostring(root))\n\n    def test_namespace_cleanup_keep_prefixes_top(self):\n        xml = ('<root xmlns:n64=\"NS64\" xmlns:unused1=\"UNUSED\" xmlns:no=\"NO\">'\n               '<sub xmlns:foo=\"FOO\">'\n               '<a xmlns:unused2=\"UNUSED\"><n64:x xmlns:a=\"A\" a:attr=\"X\"/></a>'\n               '<foo>foo:bar</foo>'\n               '</sub>'\n               '</root>').encode('utf8')\n        root = self.etree.fromstring(xml)\n        self.assertEqual(xml, self.etree.tostring(root))\n        self.etree.cleanup_namespaces(\n            root,\n            top_nsmap={'foo': 'FOO', 'unused1': 'UNUSED'},\n            keep_ns_prefixes=['foo'])\n        self.assertEqual(\n            b'<root xmlns:n64=\"NS64\" xmlns:foo=\"FOO\">'\n            b'<sub>'\n            b'<a><n64:x xmlns:a=\"A\" a:attr=\"X\"/></a>'\n            b'<foo>foo:bar</foo>'\n            b'</sub>'\n            b'</root>',\n            self.etree.tostring(root))\n\n    def test_element_nsmap(self):\n        etree = self.etree\n\n        r = {None: 'http://ns.infrae.com/foo',\n             'hoi': 'http://ns.infrae.com/hoi'}\n        e = etree.Element('{http://ns.infrae.com/foo}bar', nsmap=r)\n        self.assertEqual(\n            r,\n            e.nsmap)\n\n    def test_subelement_nsmap(self):\n        etree = self.etree\n\n        re = {None: 'http://ns.infrae.com/foo',\n             'hoi': 'http://ns.infrae.com/hoi'}\n        e = etree.Element('{http://ns.infrae.com/foo}bar', nsmap=re)\n\n        rs = {None: 'http://ns.infrae.com/honk',\n             'top': 'http://ns.infrae.com/top'}\n        s = etree.SubElement(e, '{http://ns.infrae.com/honk}bar', nsmap=rs)\n\n        r = re.copy()\n        r.update(rs)\n        self.assertEqual(re, e.nsmap)\n        self.assertEqual(r,  s.nsmap)\n\n    def test_html_prefix_nsmap(self):\n        etree = self.etree\n        el = etree.HTML('<hha:page-description>aa</hha:page-description>').find('.//page-description')\n        if etree.LIBXML_VERSION < (2, 9, 11):\n            self.assertEqual({'hha': None}, el.nsmap)\n        else:\n            self.assertEqual({}, el.nsmap)\n\n    def test_getchildren(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(b, 'd')\n        e = SubElement(c, 'e')\n        self.assertEqual(\n            _bytes('<a><b><d></d></b><c><e></e></c></a>'),\n            self.etree.tostring(a, method=\"c14n\"))\n        self.assertEqual(\n            [b, c],\n            a.getchildren())\n        self.assertEqual(\n            [d],\n            b.getchildren())\n        self.assertEqual(\n            [],\n            d.getchildren())\n\n    def test_getiterator(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(b, 'd')\n        e = SubElement(c, 'e')\n\n        self.assertEqual(\n            [a, b, d, c, e],\n            list(a.getiterator()))\n        self.assertEqual(\n            [d],\n            list(d.getiterator()))\n\n    def test_getiterator_empty(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(b, 'd')\n        e = SubElement(c, 'e')\n\n        self.assertEqual(\n            [],\n            list(a.getiterator('none')))\n        self.assertEqual(\n            [],\n            list(e.getiterator('none')))\n        self.assertEqual(\n            [e],\n            list(e.getiterator()))\n\n    def test_getiterator_filter(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(b, 'd')\n        e = SubElement(c, 'e')\n\n        self.assertEqual(\n            [a],\n            list(a.getiterator('a')))\n        a2 = SubElement(e, 'a')\n        self.assertEqual(\n            [a, a2],\n            list(a.getiterator('a')))\n        self.assertEqual(\n            [a2],\n            list(c.getiterator('a')))\n\n    def test_getiterator_filter_all(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(b, 'd')\n        e = SubElement(c, 'e')\n\n        self.assertEqual(\n            [a, b, d, c, e],\n            list(a.getiterator('*')))\n\n    def test_getiterator_filter_comment(self):\n        Element = self.etree.Element\n        Comment = self.etree.Comment\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        comment_b = Comment(\"TEST-b\")\n        b.append(comment_b)\n\n        self.assertEqual(\n            [comment_b],\n            list(a.getiterator(Comment)))\n\n        comment_a = Comment(\"TEST-a\")\n        a.append(comment_a)\n\n        self.assertEqual(\n            [comment_b, comment_a],\n            list(a.getiterator(Comment)))\n\n        self.assertEqual(\n            [comment_b],\n            list(b.getiterator(Comment)))\n\n    def test_getiterator_filter_pi(self):\n        Element = self.etree.Element\n        PI = self.etree.ProcessingInstruction\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        pi_b = PI(\"TEST-b\")\n        b.append(pi_b)\n\n        self.assertEqual(\n            [pi_b],\n            list(a.getiterator(PI)))\n\n        pi_a = PI(\"TEST-a\")\n        a.append(pi_a)\n\n        self.assertEqual(\n            [pi_b, pi_a],\n            list(a.getiterator(PI)))\n\n        self.assertEqual(\n            [pi_b],\n            list(b.getiterator(PI)))\n\n    def test_getiterator_with_text(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        a.text = 'a'\n        b = SubElement(a, 'b')\n        b.text = 'b'\n        b.tail = 'b1'\n        c = SubElement(a, 'c')\n        c.text = 'c'\n        c.tail = 'c1'\n        d = SubElement(b, 'd')\n        d.text = 'd'\n        d.tail = 'd1'\n        e = SubElement(c, 'e')\n        e.text = 'e'\n        e.tail = 'e1'\n\n        self.assertEqual(\n            [a, b, d, c, e],\n            list(a.getiterator()))\n        #self.assertEqual(\n        #    [d],\n        #    list(d.getiterator()))\n\n    def test_getiterator_filter_with_text(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        a.text = 'a'\n        b = SubElement(a, 'b')\n        b.text = 'b'\n        b.tail = 'b1'\n        c = SubElement(a, 'c')\n        c.text = 'c'\n        c.tail = 'c1'\n        d = SubElement(b, 'd')\n        d.text = 'd'\n        d.tail = 'd1'\n        e = SubElement(c, 'e')\n        e.text = 'e'\n        e.tail = 'e1'\n\n        self.assertEqual(\n            [a],\n            list(a.getiterator('a')))\n        a2 = SubElement(e, 'a')\n        self.assertEqual(\n            [a, a2],\n            list(a.getiterator('a')))\n        self.assertEqual(\n            [a2],\n            list(e.getiterator('a')))\n\n    def test_getiterator_filter_multiple(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(b, 'd')\n        e = SubElement(c, 'e')\n        f = SubElement(c, 'f')\n\n        self.assertEqual(\n            [a, b],\n               list(a.getiterator('a', 'b')))\n        self.assertEqual(\n            [],\n              list(a.getiterator('x', 'y')))\n        self.assertEqual(\n            [a, f],\n              list(a.getiterator('f', 'a')))\n        self.assertEqual(\n            [c, e, f],\n               list(c.getiterator('c', '*', 'a')))\n        self.assertEqual(\n            [],\n                  list(a.getiterator( (), () )))\n\n    def test_getiterator_filter_multiple_tuple(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(b, 'd')\n        e = SubElement(c, 'e')\n        f = SubElement(c, 'f')\n\n        self.assertEqual(\n            [a, b],\n                  list(a.getiterator( ('a', 'b') )))\n        self.assertEqual(\n            [],\n              list(a.getiterator( ('x', 'y') )))\n        self.assertEqual(\n            [a, f],\n                  list(a.getiterator( ('f', 'a') )))\n        self.assertEqual(\n            [c, e, f],\n                     list(c.getiterator( ('c', '*', 'a') )))\n        self.assertEqual(\n            [],\n              list(a.getiterator( () )))\n\n    def test_getiterator_filter_namespace(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('{a}a')\n        b = SubElement(a, '{a}b')\n        c = SubElement(a, '{a}c')\n        d = SubElement(b, '{b}d')\n        e = SubElement(c, '{a}e')\n        f = SubElement(c, '{b}f')\n        g = SubElement(c, 'g')\n\n        self.assertEqual(\n            [a],\n            list(a.getiterator('{a}a')))\n        self.assertEqual(\n            [],\n            list(a.getiterator('{b}a')))\n        self.assertEqual(\n            [],\n            list(a.getiterator('a')))\n        self.assertEqual(\n            [a,b,d,c,e,f,g],\n            list(a.getiterator('*')))\n        self.assertEqual(\n            [f],\n            list(c.getiterator('{b}*')))\n        self.assertEqual(\n            [d, f],\n            list(a.getiterator('{b}*')))\n        self.assertEqual(\n            [g],\n            list(a.getiterator('g')))\n        self.assertEqual(\n            [g],\n            list(a.getiterator('{}g')))\n        self.assertEqual(\n            [g],\n            list(a.getiterator('{}*')))\n\n    def test_getiterator_filter_local_name(self):\n        Element = self.etree.Element\n        Comment = self.etree.Comment\n        SubElement = self.etree.SubElement\n\n        a = Element('{a}a')\n        b = SubElement(a, '{nsA}b')\n        c = SubElement(b, '{nsB}b')\n        d = SubElement(a, 'b')\n        e = SubElement(a, '{nsA}e')\n        f = SubElement(e, '{nsB}e')\n        g = SubElement(e, 'e')\n        a.append(Comment('test'))\n\n        self.assertEqual(\n            [b, c, d],\n            list(a.getiterator('{*}b')))\n        self.assertEqual(\n            [e, f, g],\n            list(a.getiterator('{*}e')))\n        self.assertEqual(\n            [a, b, c, d, e, f, g],\n            list(a.getiterator('{*}*')))\n\n    def test_getiterator_filter_entities(self):\n        Element = self.etree.Element\n        Entity = self.etree.Entity\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        entity_b = Entity(\"TEST-b\")\n        b.append(entity_b)\n\n        self.assertEqual(\n            [entity_b],\n            list(a.getiterator(Entity)))\n\n        entity_a = Entity(\"TEST-a\")\n        a.append(entity_a)\n\n        self.assertEqual(\n            [entity_b, entity_a],\n            list(a.getiterator(Entity)))\n\n        self.assertEqual(\n            [entity_b],\n            list(b.getiterator(Entity)))\n\n    def test_getiterator_filter_element(self):\n        Element = self.etree.Element\n        Comment = self.etree.Comment\n        PI = self.etree.PI\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        a.append(Comment(\"test\"))\n        a.append(PI(\"pi\", \"content\"))\n        c = SubElement(a, 'c')\n\n        self.assertEqual(\n            [a, b, c],\n            list(a.getiterator(Element)))\n\n    def test_getiterator_filter_all_comment_pi(self):\n        # ElementTree iterates over everything here\n        Element = self.etree.Element\n        Comment = self.etree.Comment\n        PI = self.etree.PI\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        a.append(Comment(\"test\"))\n        a.append(PI(\"pi\", \"content\"))\n        c = SubElement(a, 'c')\n\n        self.assertEqual(\n            [a, b, c],\n            list(a.getiterator('*')))\n\n    def test_elementtree_getiterator(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        ElementTree = self.etree.ElementTree\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(b, 'd')\n        e = SubElement(c, 'e')\n        t = ElementTree(element=a)\n\n        self.assertEqual(\n            [a, b, d, c, e],\n            list(t.getiterator()))\n\n    def test_elementtree_getiterator_filter(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        ElementTree = self.etree.ElementTree\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(b, 'd')\n        e = SubElement(c, 'e')\n        t = ElementTree(element=a)\n\n        self.assertEqual(\n            [a],\n            list(t.getiterator('a')))\n        a2 = SubElement(e, 'a')\n        self.assertEqual(\n            [a, a2],\n            list(t.getiterator('a')))\n\n    def test_elementtree_getelementpath(self):\n        a  = etree.Element(\"a\")\n        b  = etree.SubElement(a, \"b\")\n        c  = etree.SubElement(a, \"c\")\n        d1 = etree.SubElement(c, \"d\")\n        d2 = etree.SubElement(c, \"d\")\n        c.text = d1.text = 'TEXT'\n\n        tree = etree.ElementTree(a)\n        self.assertEqual('.', tree.getelementpath(a))\n        self.assertEqual('c/d[1]', tree.getelementpath(d1))\n        self.assertEqual('c/d[2]', tree.getelementpath(d2))\n\n        self.assertEqual(d1, tree.find(tree.getelementpath(d1)))\n        self.assertEqual(d2, tree.find(tree.getelementpath(d2)))\n\n        tree = etree.ElementTree(c)\n        self.assertEqual('.', tree.getelementpath(c))\n        self.assertEqual('d[2]', tree.getelementpath(d2))\n        self.assertEqual(d2, tree.find(tree.getelementpath(d2)))\n\n        tree = etree.ElementTree(b)  # not a parent of a/c/d1/d2\n        self.assertEqual('.', tree.getelementpath(b))\n        self.assertRaises(ValueError, tree.getelementpath, a)\n        self.assertRaises(ValueError, tree.getelementpath, c)\n        self.assertRaises(ValueError, tree.getelementpath, d2)\n\n    def test_elementtree_getelementpath_ns(self):\n        a  = etree.Element(\"{http://ns1/}a\")\n        b  = etree.SubElement(a, \"{http://ns1/}b\")\n        c  = etree.SubElement(a, \"{http://ns1/}c\")\n        d1 = etree.SubElement(c, \"{http://ns1/}d\")\n        d2 = etree.SubElement(c, \"{http://ns2/}d\")\n        d3 = etree.SubElement(c, \"{http://ns1/}d\")\n\n        tree = etree.ElementTree(a)\n        self.assertEqual('.', tree.getelementpath(a))\n        self.assertEqual('{http://ns1/}c/{http://ns1/}d[1]',\n                         tree.getelementpath(d1))\n        self.assertEqual('{http://ns1/}c/{http://ns2/}d',\n                         tree.getelementpath(d2))\n        self.assertEqual('{http://ns1/}c/{http://ns1/}d[2]',\n                         tree.getelementpath(d3))\n\n        self.assertEqual(a, tree.find(tree.getelementpath(a)))\n        self.assertEqual(b, tree.find(tree.getelementpath(b)))\n        self.assertEqual(c, tree.find(tree.getelementpath(c)))\n        self.assertEqual(d1, tree.find(tree.getelementpath(d1)))\n        self.assertEqual(d2, tree.find(tree.getelementpath(d2)))\n        self.assertEqual(d3, tree.find(tree.getelementpath(d3)))\n\n        tree = etree.ElementTree(c)\n        self.assertEqual('{http://ns1/}d[1]', tree.getelementpath(d1))\n        self.assertEqual('{http://ns2/}d', tree.getelementpath(d2))\n        self.assertEqual('{http://ns1/}d[2]', tree.getelementpath(d3))\n        self.assertEqual(d1, tree.find(tree.getelementpath(d1)))\n        self.assertEqual(d2, tree.find(tree.getelementpath(d2)))\n        self.assertEqual(d3, tree.find(tree.getelementpath(d3)))\n\n        tree = etree.ElementTree(b)  # not a parent of d1/d2\n        self.assertRaises(ValueError, tree.getelementpath, d1)\n        self.assertRaises(ValueError, tree.getelementpath, d2)\n\n    def test_elementtree_iter_qname(self):\n        XML = self.etree.XML\n        ElementTree = self.etree.ElementTree\n        QName = self.etree.QName\n        tree = ElementTree(XML(\n                _bytes('<a xmlns:x=\"X\" xmlns:y=\"Y\"><x:b><c/></x:b><b/><c><x:b/><b/></c><b/></a>')))\n        self.assertEqual(\n            list(tree.iter(QName(\"b\"))),\n            list(tree.iter(\"b\")),\n        )\n        self.assertEqual(\n            list(tree.iter(QName(\"X\", \"b\"))),\n            list(tree.iter(\"{X}b\")),\n        )\n\n        self.assertEqual(\n            [e.tag for e in tree.iter(QName(\"X\", \"b\"), QName(\"b\"))],\n            ['{X}b', 'b', '{X}b', 'b', 'b']\n        )\n        self.assertEqual(\n            list(tree.iter(QName(\"X\", \"b\"), QName(\"b\"))),\n            list(tree.iter(\"{X}b\", \"b\"))\n        )\n\n    def test_elementtree_find_qname(self):\n        XML = self.etree.XML\n        ElementTree = self.etree.ElementTree\n        QName = self.etree.QName\n        tree = ElementTree(XML(_bytes('<a><b><c/></b><b/><c><b/></c></a>')))\n        self.assertEqual(tree.find(QName(\"c\")), tree.getroot()[2])\n\n    def test_elementtree_findall_qname(self):\n        XML = self.etree.XML\n        ElementTree = self.etree.ElementTree\n        QName = self.etree.QName\n        tree = ElementTree(XML(_bytes('<a><b><c/></b><b/><c><b/></c></a>')))\n        self.assertEqual(len(list(tree.findall(QName(\"c\")))), 1)\n\n    def test_elementtree_findall_ns_qname(self):\n        XML = self.etree.XML\n        ElementTree = self.etree.ElementTree\n        QName = self.etree.QName\n        tree = ElementTree(XML(\n                _bytes('<a xmlns:x=\"X\" xmlns:y=\"Y\"><x:b><c/></x:b><b/><c><x:b/><b/></c><b/></a>')))\n        self.assertEqual(len(list(tree.findall(QName(\"b\")))), 2)\n        self.assertEqual(len(list(tree.findall(QName(\"X\", \"b\")))), 1)\n\n    def test_findall_ns(self):\n        XML = self.etree.XML\n        root = XML(_bytes('<a xmlns:x=\"X\" xmlns:y=\"Y\"><x:b><c/></x:b><b/><c><x:b/><b/></c><b/></a>'))\n        self.assertEqual(len(root.findall(\".//{X}b\")), 2)\n        self.assertEqual(len(root.findall(\".//{X}*\")), 2)\n        self.assertEqual(len(root.findall(\".//b\")), 3)\n\n    def test_findall_different_nsmaps(self):\n        XML = self.etree.XML\n        root = XML(_bytes('<a xmlns:x=\"X\" xmlns:y=\"Y\"><x:b><c/></x:b><b/><c><x:b/><b/></c><y:b/></a>'))\n        nsmap = {'xx': 'X'}\n        self.assertEqual(len(root.findall(\".//xx:b\", namespaces=nsmap)), 2)\n        self.assertEqual(len(root.findall(\".//xx:*\", namespaces=nsmap)), 2)\n        self.assertEqual(len(root.findall(\".//b\", namespaces=nsmap)), 2)\n        nsmap = {'xx': 'Y'}\n        self.assertEqual(len(root.findall(\".//xx:b\", namespaces=nsmap)), 1)\n        self.assertEqual(len(root.findall(\".//xx:*\", namespaces=nsmap)), 1)\n        self.assertEqual(len(root.findall(\".//b\", namespaces=nsmap)), 2)\n\n    def test_findall_empty_prefix(self):\n        XML = self.etree.XML\n        root = XML(_bytes('<a xmlns:x=\"X\" xmlns:y=\"Y\"><x:b><c/></x:b><b/><c><x:b/><b/></c><y:b/></a>'))\n        nsmap = {'xx': 'X'}\n        self.assertEqual(len(root.findall(\".//xx:b\", namespaces=nsmap)), 2)\n        nsmap = {'xx': 'X', None: 'Y'}\n        self.assertEqual(len(root.findall(\".//b\", namespaces=nsmap)), 1)\n        nsmap = {'xx': 'X', '': 'Y'}\n        self.assertEqual(len(root.findall(\".//b\", namespaces=nsmap)), 1)\n\n    def test_findall_syntax_error(self):\n        XML = self.etree.XML\n        root = XML(_bytes('<a><b><c/></b><b/><c><b/><b/></c><b/></a>'))\n        self.assertRaises(SyntaxError, root.findall, '')\n        self.assertRaises(SyntaxError, root.findall, '//')  # absolute path on Element\n        self.assertRaises(SyntaxError, root.findall, './//')\n\n    def test_index(self):\n        etree = self.etree\n        e = etree.Element('foo')\n        for i in range(10):\n            etree.SubElement(e, 'a%s' % i)\n        for i in range(10):\n            self.assertEqual(\n                i,\n                e.index(e[i]))\n        self.assertEqual(\n            3, e.index(e[3], 3))\n        self.assertRaises(\n            ValueError, e.index, e[3], 4)\n        self.assertRaises(\n            ValueError, e.index, e[3], 0, 2)\n        self.assertRaises(\n            ValueError, e.index, e[8], 0, -3)\n        self.assertRaises(\n            ValueError, e.index, e[8], -5, -3)\n        self.assertEqual(\n            8, e.index(e[8], 0, -1))\n        self.assertEqual(\n            8, e.index(e[8], -12, -1))\n        self.assertEqual(\n            0, e.index(e[0], -12, -1))\n\n    def test_replace(self):\n        etree = self.etree\n        e = etree.Element('foo')\n        for i in range(10):\n            el = etree.SubElement(e, 'a%s' % i)\n            el.text = \"text%d\" % i\n            el.tail = \"tail%d\" % i\n\n        child0 = e[0]\n        child1 = e[1]\n        child2 = e[2]\n\n        e.replace(e[0], e[1])\n        self.assertEqual(\n            9, len(e))\n        self.assertEqual(\n            child1, e[0])\n        self.assertEqual(\n            child1.text, \"text1\")\n        self.assertEqual(\n            child1.tail, \"tail1\")\n        self.assertEqual(\n            child0.tail, \"tail0\")\n        self.assertEqual(\n            child2, e[1])\n\n        e.replace(e[-1], e[0])\n        self.assertEqual(\n            child1, e[-1])\n        self.assertEqual(\n            child1.text, \"text1\")\n        self.assertEqual(\n            child1.tail, \"tail1\")\n        self.assertEqual(\n            child2, e[0])\n\n    def test_replace_new(self):\n        etree = self.etree\n        e = etree.Element('foo')\n        for i in range(10):\n            etree.SubElement(e, 'a%s' % i)\n\n        new_element = etree.Element(\"test\")\n        new_element.text = \"TESTTEXT\"\n        new_element.tail = \"TESTTAIL\"\n        child1 = e[1]\n        e.replace(e[0], new_element)\n        self.assertEqual(\n            new_element, e[0])\n        self.assertEqual(\n            \"TESTTEXT\",\n            e[0].text)\n        self.assertEqual(\n            \"TESTTAIL\",\n            e[0].tail)\n        self.assertEqual(\n            child1, e[1])\n\n    def test_setslice_all_reversed(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n\n        e = Element('e')\n        f = Element('f')\n        g = Element('g')\n\n        a[:] = [e, f, g]\n        self.assertEqual(\n            [e, f, g],\n            list(a))\n\n        a[::-1] = [e, f, g]\n        self.assertEqual(\n            [g, f, e],\n            list(a))\n\n    def test_setslice_step(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(a, 'd')\n        e = SubElement(a, 'e')\n\n        x = Element('x')\n        y = Element('y')\n\n        a[1::2] = [x, y]\n        self.assertEqual(\n            [b, x, d, y],\n            list(a))\n\n    def test_setslice_step_negative(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(a, 'd')\n        e = SubElement(a, 'e')\n\n        x = Element('x')\n        y = Element('y')\n\n        a[1::-1] = [x, y]\n        self.assertEqual(\n            [y, x, d, e],\n            list(a))\n\n    def test_setslice_step_negative2(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(a, 'd')\n        e = SubElement(a, 'e')\n\n        x = Element('x')\n        y = Element('y')\n\n        a[::-2] = [x, y]\n        self.assertEqual(\n            [b, y, d, x],\n            list(a))\n\n    def test_setslice_step_overrun(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        try:\n            slice\n        except NameError:\n            print(\"slice() not found\")\n            return\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(a, 'd')\n        e = SubElement(a, 'e')\n\n        x = Element('x')\n        y = Element('y')\n        z = Element('z')\n\n        self.assertRaises(\n            ValueError,\n            operator.setitem, a, slice(1,None,2), [x, y, z])\n\n        self.assertEqual(\n            [b, c, d, e],\n            list(a))\n\n    def test_sourceline_XML(self):\n        XML = self.etree.XML\n        root = XML(_bytes('''<?xml version=\"1.0\"?>\n        <root><test>\n\n        <bla/></test>\n        </root>\n        '''))\n\n        self.assertEqual(\n            [2, 2, 4],\n            [ el.sourceline for el in root.getiterator() ])\n\n    def test_large_sourceline_XML(self):\n        XML = self.etree.XML\n        root = XML(_bytes(\n            '<?xml version=\"1.0\"?>\\n'\n            '<root>' + '\\n' * 65536 +\n            '<p>' + '\\n' * 65536 + '</p>\\n' +\n            '<br/>\\n'\n            '</root>'))\n\n        if self.etree.LIBXML_VERSION >= (2, 9):\n            expected = [2, 131074, 131076]\n        else:\n            expected = [2, 65535, 65535]\n\n        self.assertEqual(expected, [el.sourceline for el in root.iter()])\n\n    def test_sourceline_parse(self):\n        parse = self.etree.parse\n        tree = parse(fileInTestDir('include/test_xinclude.xml'))\n\n        self.assertEqual(\n            [1, 2, 3],\n            [ el.sourceline for el in tree.getiterator() ])\n\n    def test_sourceline_iterparse_end(self):\n        iterparse = self.etree.iterparse\n        lines = [ el.sourceline for (event, el) in \n                  iterparse(fileInTestDir('include/test_xinclude.xml')) ]\n\n        self.assertEqual(\n            [2, 3, 1],\n            lines)\n\n    def test_sourceline_iterparse_start(self):\n        iterparse = self.etree.iterparse\n        lines = [ el.sourceline for (event, el) in \n                  iterparse(fileInTestDir('include/test_xinclude.xml'),\n                            events=(\"start\",)) ]\n\n        self.assertEqual(\n            [1, 2, 3],\n            lines)\n\n    def test_sourceline_element(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        el = Element(\"test\")\n        self.assertEqual(None, el.sourceline)\n\n        child = SubElement(el, \"test\")\n        self.assertEqual(None, el.sourceline)\n        self.assertEqual(None, child.sourceline)\n\n    def test_XML_base_url_docinfo(self):\n        etree = self.etree\n        root = etree.XML(_bytes(\"<root/>\"), base_url=\"http://no/such/url\")\n        docinfo = root.getroottree().docinfo\n        self.assertEqual(docinfo.URL, \"http://no/such/url\")\n\n    def test_XML_set_base_url_docinfo(self):\n        etree = self.etree\n        root = etree.XML(_bytes(\"<root/>\"), base_url=\"http://no/such/url\")\n        docinfo = root.getroottree().docinfo\n        self.assertEqual(docinfo.URL, \"http://no/such/url\")\n        docinfo.URL = \"https://secret/url\"\n        self.assertEqual(docinfo.URL, \"https://secret/url\")\n\n    def test_parse_stringio_base_url(self):\n        etree = self.etree\n        tree = etree.parse(BytesIO(\"<root/>\"), base_url=\"http://no/such/url\")\n        docinfo = tree.docinfo\n        self.assertEqual(docinfo.URL, \"http://no/such/url\")\n\n    def test_parse_base_url_docinfo(self):\n        etree = self.etree\n        tree = etree.parse(fileInTestDir('include/test_xinclude.xml'),\n                           base_url=\"http://no/such/url\")\n        docinfo = tree.docinfo\n        self.assertEqual(docinfo.URL, \"http://no/such/url\")\n\n    def test_HTML_base_url_docinfo(self):\n        etree = self.etree\n        root = etree.HTML(_bytes(\"<html/>\"), base_url=\"http://no/such/url\")\n        docinfo = root.getroottree().docinfo\n        self.assertEqual(docinfo.URL, \"http://no/such/url\")\n\n    def test_docinfo_public(self):\n        etree = self.etree\n        xml_header = '<?xml version=\"1.0\" encoding=\"ascii\"?>'\n        pub_id = \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\n        sys_id = \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"\n        doctype_string = '<!DOCTYPE html PUBLIC \"%s\" \"%s\">' % (pub_id, sys_id)\n\n        xml = _bytes(xml_header + doctype_string + '<html><body></body></html>')\n\n        tree = etree.parse(BytesIO(xml))\n        docinfo = tree.docinfo\n        self.assertEqual(docinfo.encoding,    \"ascii\")\n        self.assertEqual(docinfo.xml_version, \"1.0\")\n        self.assertEqual(docinfo.public_id,   pub_id)\n        self.assertEqual(docinfo.system_url,  sys_id)\n        self.assertEqual(docinfo.root_name,   'html')\n        self.assertEqual(docinfo.doctype, doctype_string)\n\n    def test_docinfo_system(self):\n        etree = self.etree\n        xml_header = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>'\n        sys_id = \"some.dtd\"\n        doctype_string = '<!DOCTYPE html SYSTEM \"%s\">' % sys_id\n        xml = _bytes(xml_header + doctype_string + '<html><body></body></html>')\n\n        tree = etree.parse(BytesIO(xml))\n        docinfo = tree.docinfo\n        self.assertEqual(docinfo.encoding,    \"UTF-8\")\n        self.assertEqual(docinfo.xml_version, \"1.0\")\n        self.assertEqual(docinfo.public_id,   None)\n        self.assertEqual(docinfo.system_url,  sys_id)\n        self.assertEqual(docinfo.root_name,   'html')\n        self.assertEqual(docinfo.doctype, doctype_string)\n\n    def test_docinfo_empty(self):\n        etree = self.etree\n        xml = _bytes('<html><body></body></html>')\n        tree = etree.parse(BytesIO(xml))\n        docinfo = tree.docinfo\n        self.assertEqual(docinfo.encoding,    \"UTF-8\")\n        self.assertEqual(docinfo.xml_version, \"1.0\")\n        self.assertEqual(docinfo.public_id,   None)\n        self.assertEqual(docinfo.system_url,  None)\n        self.assertEqual(docinfo.root_name,   'html')\n        self.assertEqual(docinfo.doctype, '')\n\n    def test_docinfo_name_only(self):\n        etree = self.etree\n        xml = _bytes('<!DOCTYPE root><root></root>')\n        tree = etree.parse(BytesIO(xml))\n        docinfo = tree.docinfo\n        self.assertEqual(docinfo.encoding,    \"UTF-8\")\n        self.assertEqual(docinfo.xml_version, \"1.0\")\n        self.assertEqual(docinfo.public_id,   None)\n        self.assertEqual(docinfo.system_url,  None)\n        self.assertEqual(docinfo.root_name,   'root')\n        self.assertEqual(docinfo.doctype, '<!DOCTYPE root>')\n\n    def test_doctype_name_only_roundtrip(self):\n        etree = self.etree\n        xml = _bytes('<!DOCTYPE root>\\n<root/>')\n        tree = etree.parse(BytesIO(xml))\n        self.assertEqual(xml, etree.tostring(tree))\n\n    def test_doctype_output_override(self):\n        etree = self.etree\n        pub_id = \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\n        sys_id = \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"\n        doctype_string = _bytes('<!DOCTYPE html PUBLIC \"%s\" \"%s\">' % (pub_id, sys_id))\n\n        xml = _bytes('<!DOCTYPE root>\\n<root/>')\n        tree = etree.parse(BytesIO(xml))\n        self.assertEqual(xml.replace(_bytes('<!DOCTYPE root>'), doctype_string),\n                          etree.tostring(tree, doctype=doctype_string))\n\n    def test_xml_base(self):\n        etree = self.etree\n        root = etree.XML(_bytes(\"<root/>\"), base_url=\"http://no/such/url\")\n        self.assertEqual(root.base, \"http://no/such/url\")\n        self.assertEqual(\n            root.get('{http://www.w3.org/XML/1998/namespace}base'), None)\n        root.base = \"https://secret/url\"\n        self.assertEqual(root.base, \"https://secret/url\")\n        self.assertEqual(\n            root.get('{http://www.w3.org/XML/1998/namespace}base'),\n            \"https://secret/url\")\n\n    def test_xml_base_attribute(self):\n        etree = self.etree\n        root = etree.XML(_bytes(\"<root/>\"), base_url=\"http://no/such/url\")\n        self.assertEqual(root.base, \"http://no/such/url\")\n        self.assertEqual(\n            root.get('{http://www.w3.org/XML/1998/namespace}base'), None)\n        root.set('{http://www.w3.org/XML/1998/namespace}base',\n                 \"https://secret/url\")\n        self.assertEqual(root.base, \"https://secret/url\")\n        self.assertEqual(\n            root.get('{http://www.w3.org/XML/1998/namespace}base'),\n            \"https://secret/url\")\n\n    def test_html_base(self):\n        etree = self.etree\n        root = etree.HTML(_bytes(\"<html><body></body></html>\"),\n                          base_url=\"http://no/such/url\")\n        self.assertEqual(root.base, \"http://no/such/url\")\n\n    def test_html_base_tag(self):\n        etree = self.etree\n        root = etree.HTML(_bytes('<html><head><base href=\"http://no/such/url\"></head></html>'))\n        self.assertEqual(root.base, \"http://no/such/url\")\n\n    def test_indent(self):\n        ET = self.etree\n        elem = ET.XML(\"<root></root>\")\n        ET.indent(elem)\n        self.assertEqual(ET.tostring(elem), b'<root/>')\n\n        elem = ET.XML(\"<html><body>text</body></html>\")\n        ET.indent(elem)\n        self.assertEqual(ET.tostring(elem), b'<html>\\n  <body>text</body>\\n</html>')\n\n        elem = ET.XML(\"<html> <body>text</body>  </html>\")\n        ET.indent(elem)\n        self.assertEqual(ET.tostring(elem), b'<html>\\n  <body>text</body>\\n</html>')\n\n        elem = ET.XML(\"<html> <body>text</body>   </html>\")\n        ET.indent(elem)\n        self.assertEqual(ET.tostring(elem), b'<html>\\n  <body>text</body>\\n</html>')\n\n        elem = ET.XML(\"<html><body>text</body>tail</html>\")\n        ET.indent(elem)\n        self.assertEqual(ET.tostring(elem), b'<html>\\n  <body>text</body>tail</html>')\n\n        elem = ET.XML(\"<html><body><p>par</p>\\n<p>text</p>\\t<p><br/></p></body></html>\")\n        ET.indent(elem)\n        self.assertEqual(\n            ET.tostring(elem),\n            b'<html>\\n'\n            b'  <body>\\n'\n            b'    <p>par</p>\\n'\n            b'    <p>text</p>\\n'\n            b'    <p>\\n'\n            b'      <br/>\\n'\n            b'    </p>\\n'\n            b'  </body>\\n'\n            b'</html>'\n        )\n\n        elem = ET.XML(\"<html><body><p>pre<br/>post</p><p>text</p></body></html>\")\n        ET.indent(elem)\n        self.assertEqual(\n            ET.tostring(elem),\n            b'<html>\\n'\n            b'  <body>\\n'\n            b'    <p>pre<br/>post</p>\\n'\n            b'    <p>text</p>\\n'\n            b'  </body>\\n'\n            b'</html>'\n        )\n\n    def test_indent_space(self):\n        ET = self.etree\n        elem = ET.XML(\"<html><body><p>pre<br/>post</p><p>text</p></body></html>\")\n        ET.indent(elem, space='\\t')\n        self.assertEqual(\n            ET.tostring(elem),\n            b'<html>\\n'\n            b'\\t<body>\\n'\n            b'\\t\\t<p>pre<br/>post</p>\\n'\n            b'\\t\\t<p>text</p>\\n'\n            b'\\t</body>\\n'\n            b'</html>'\n        )\n\n        elem = ET.XML(\"<html><body><p>pre<br/>post</p><p>text</p></body></html>\")\n        ET.indent(elem, space='')\n        self.assertEqual(\n            ET.tostring(elem),\n            b'<html>\\n'\n            b'<body>\\n'\n            b'<p>pre<br/>post</p>\\n'\n            b'<p>text</p>\\n'\n            b'</body>\\n'\n            b'</html>'\n        )\n\n    def test_indent_space_caching(self):\n        ET = self.etree\n        elem = ET.XML(\"<html><body><p>par</p><p>text</p><p><br/></p><p /></body></html>\")\n        ET.indent(elem)\n        self.assertEqual(\n            {el.tail for el in elem.iter()},\n            {None, \"\\n\", \"\\n  \", \"\\n    \"}\n        )\n        self.assertEqual(\n            {el.text for el in elem.iter()},\n            {None, \"\\n  \", \"\\n    \", \"\\n      \", \"par\", \"text\"}\n        )\n        # NOTE: lxml does not reuse Python text strings across elements.\n        #self.assertEqual(\n        #    len({el.tail for el in elem.iter()}),\n        #    len({id(el.tail) for el in elem.iter()}),\n        #)\n\n    def test_indent_level(self):\n        ET = self.etree\n        elem = ET.XML(\"<html><body><p>pre<br/>post</p><p>text</p></body></html>\")\n        try:\n            ET.indent(elem, level=-1)\n        except ValueError:\n            pass\n        else:\n            self.assertTrue(False, \"ValueError not raised\")\n        self.assertEqual(\n            ET.tostring(elem),\n            b\"<html><body><p>pre<br/>post</p><p>text</p></body></html>\"\n        )\n\n        ET.indent(elem, level=2)\n        self.assertEqual(\n            ET.tostring(elem),\n            b'<html>\\n'\n            b'      <body>\\n'\n            b'        <p>pre<br/>post</p>\\n'\n            b'        <p>text</p>\\n'\n            b'      </body>\\n'\n            b'    </html>'\n        )\n\n        elem = ET.XML(\"<html><body><p>pre<br/>post</p><p>text</p></body></html>\")\n        ET.indent(elem, level=1, space=' ')\n        self.assertEqual(\n            ET.tostring(elem),\n            b'<html>\\n'\n            b'  <body>\\n'\n            b'   <p>pre<br/>post</p>\\n'\n            b'   <p>text</p>\\n'\n            b'  </body>\\n'\n            b' </html>'\n        )\n\n    def test_parse_fileobject_unicode(self):\n        # parse from a file object that returns unicode strings\n        f = LargeFileLikeUnicode()\n        tree = self.etree.parse(f)\n        root = tree.getroot()\n        self.assertTrue(root.tag.endswith('root'))\n\n    def test_dtd_io(self):\n        # check that DTDs that go in also go back out\n        xml = _bytes('''\\\n        <!DOCTYPE test SYSTEM \"test.dtd\" [\n          <!ENTITY entity \"tasty\">\n          <!ELEMENT test (a)>\n          <!ELEMENT a (#PCDATA)>\n        ]>\n        <test><a>test-test</a></test>\\\n        ''')\n        tree = self.etree.parse(BytesIO(xml))\n        self.assertEqual(self.etree.tostring(tree).replace(_bytes(\" \"), _bytes(\"\")),\n                         xml.replace(_bytes(\" \"), _bytes(\"\")))\n\n    def test_byte_zero(self):\n        Element = self.etree.Element\n\n        a = Element('a')\n        self.assertRaises(ValueError, setattr, a, \"text\", 'ha\\0ho')\n        self.assertRaises(ValueError, setattr, a, \"tail\", 'ha\\0ho')\n\n        self.assertRaises(ValueError, Element, 'ha\\0ho')\n\n    def test_unicode_byte_zero(self):\n        Element = self.etree.Element\n\n        a = Element('a')\n        self.assertRaises(ValueError, setattr, a, \"text\",\n                          _str('ha\\0ho'))\n        self.assertRaises(ValueError, setattr, a, \"tail\",\n                          _str('ha\\0ho'))\n\n        self.assertRaises(ValueError, Element,\n                          _str('ha\\0ho'))\n\n    def test_byte_invalid(self):\n        Element = self.etree.Element\n\n        a = Element('a')\n        self.assertRaises(ValueError, setattr, a, \"text\", 'ha\\x07ho')\n        self.assertRaises(ValueError, setattr, a, \"text\", 'ha\\x02ho')\n\n        self.assertRaises(ValueError, setattr, a, \"tail\", 'ha\\x07ho')\n        self.assertRaises(ValueError, setattr, a, \"tail\", 'ha\\x02ho')\n\n        self.assertRaises(ValueError, Element, 'ha\\x07ho')\n        self.assertRaises(ValueError, Element, 'ha\\x02ho')\n\n    def test_unicode_byte_invalid(self):\n        Element = self.etree.Element\n\n        a = Element('a')\n        self.assertRaises(ValueError, setattr, a, \"text\",\n                          _str('ha\\x07ho'))\n        self.assertRaises(ValueError, setattr, a, \"text\",\n                          _str('ha\\x02ho'))\n\n        self.assertRaises(ValueError, setattr, a, \"tail\",\n                          _str('ha\\x07ho'))\n        self.assertRaises(ValueError, setattr, a, \"tail\",\n                          _str('ha\\x02ho'))\n\n        self.assertRaises(ValueError, Element,\n                          _str('ha\\x07ho'))\n        self.assertRaises(ValueError, Element,\n                          _str('ha\\x02ho'))\n\n    def test_unicode_byte_invalid_sequence(self):\n        Element = self.etree.Element\n\n        a = Element('a')\n        self.assertRaises(ValueError, setattr, a, \"text\",\n                          _str('ha\\u1234\\x07ho'))\n        self.assertRaises(ValueError, setattr, a, \"text\",\n                          _str('ha\\u1234\\x02ho'))\n\n        self.assertRaises(ValueError, setattr, a, \"tail\",\n                          _str('ha\\u1234\\x07ho'))\n        self.assertRaises(ValueError, setattr, a, \"tail\",\n                          _str('ha\\u1234\\x02ho'))\n\n        self.assertRaises(ValueError, Element,\n                          _str('ha\\u1234\\x07ho'))\n        self.assertRaises(ValueError, Element,\n                          _str('ha\\u1234\\x02ho'))\n\n    def test_encoding_tostring_utf16(self):\n        # ElementTree fails to serialize this\n        tostring = self.etree.tostring\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        \n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n\n        result = tostring(a, encoding='UTF-16')\n        self.assertEqual(_bytes('<a><b></b><c></c></a>'),\n                          canonicalize(result))\n\n    def test_tostring_none(self):\n        # ElementTree raises an AssertionError here\n        tostring = self.etree.tostring\n        self.assertRaises(TypeError, self.etree.tostring, None)\n\n    def test_tostring_pretty(self):\n        tostring = self.etree.tostring\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n\n        result = tostring(a)\n        self.assertEqual(result, _bytes(\"<a><b/><c/></a>\"))\n\n        result = tostring(a, pretty_print=False)\n        self.assertEqual(result, _bytes(\"<a><b/><c/></a>\"))\n\n        result = tostring(a, pretty_print=True)\n        self.assertEqual(result, _bytes(\"<a>\\n  <b/>\\n  <c/>\\n</a>\\n\"))\n\n    def test_tostring_with_tail(self):\n        tostring = self.etree.tostring\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        a.tail = \"aTAIL\"\n        b = SubElement(a, 'b')\n        b.tail = \"bTAIL\"\n        c = SubElement(a, 'c')\n\n        result = tostring(a)\n        self.assertEqual(result, _bytes(\"<a><b/>bTAIL<c/></a>aTAIL\"))\n\n        result = tostring(a, with_tail=False)\n        self.assertEqual(result, _bytes(\"<a><b/>bTAIL<c/></a>\"))\n\n        result = tostring(a, with_tail=True)\n        self.assertEqual(result, _bytes(\"<a><b/>bTAIL<c/></a>aTAIL\"))\n\n    def test_tostring_method_html_with_tail(self):\n        tostring = self.etree.tostring\n        html = self.etree.fromstring(\n            '<html><body>'\n            '<div><p>Some text<i>\\r\\n</i></p></div>\\r\\n'\n            '</body></html>',\n            parser=self.etree.HTMLParser())\n        self.assertEqual(html.tag, 'html')\n        div = html.find('.//div')\n        self.assertEqual(div.tail, '\\r\\n')\n        result = tostring(div, method='html')\n        self.assertEqual(\n            result,\n            _bytes(\"<div><p>Some text<i>\\r\\n</i></p></div>\\r\\n\"))\n        result = tostring(div, method='html', with_tail=True)\n        self.assertEqual(\n            result,\n            _bytes(\"<div><p>Some text<i>\\r\\n</i></p></div>\\r\\n\"))\n        result = tostring(div, method='html', with_tail=False)\n        self.assertEqual(\n            result,\n            _bytes(\"<div><p>Some text<i>\\r\\n</i></p></div>\"))\n\n    def test_standalone(self):\n        tostring = self.etree.tostring\n        XML = self.etree.XML\n        ElementTree = self.etree.ElementTree\n        Element = self.etree.Element\n\n        tree = Element(\"root\").getroottree()\n        self.assertEqual(None, tree.docinfo.standalone)\n\n        tree = XML(_bytes(\"<root/>\")).getroottree()\n        self.assertEqual(None, tree.docinfo.standalone)\n\n        tree = XML(_bytes(\n            \"<?xml version='1.0' encoding='ASCII' standalone='yes'?>\\n<root/>\"\n            )).getroottree()\n        self.assertEqual(True, tree.docinfo.standalone)\n\n        tree = XML(_bytes(\n            \"<?xml version='1.0' encoding='ASCII' standalone='no'?>\\n<root/>\"\n            )).getroottree()\n        self.assertEqual(False, tree.docinfo.standalone)\n\n    def test_tostring_standalone(self):\n        tostring = self.etree.tostring\n        XML = self.etree.XML\n        ElementTree = self.etree.ElementTree\n\n        root = XML(_bytes(\"<root/>\"))\n\n        tree = ElementTree(root)\n        self.assertEqual(None, tree.docinfo.standalone)\n\n        result = tostring(root, xml_declaration=True, encoding=\"ASCII\")\n        self.assertEqual(result, _bytes(\n            \"<?xml version='1.0' encoding='ASCII'?>\\n<root/>\"))\n\n        result = tostring(root, xml_declaration=True, encoding=\"ASCII\",\n                          standalone=True)\n        self.assertEqual(result, _bytes(\n            \"<?xml version='1.0' encoding='ASCII' standalone='yes'?>\\n<root/>\"))\n\n        tree = ElementTree(XML(result))\n        self.assertEqual(True, tree.docinfo.standalone)\n\n        result = tostring(root, xml_declaration=True, encoding=\"ASCII\",\n                          standalone=False)\n        self.assertEqual(result, _bytes(\n            \"<?xml version='1.0' encoding='ASCII' standalone='no'?>\\n<root/>\"))\n\n        tree = ElementTree(XML(result))\n        self.assertEqual(False, tree.docinfo.standalone)\n\n    def test_tostring_standalone_in_out(self):\n        tostring = self.etree.tostring\n        XML = self.etree.XML\n        ElementTree = self.etree.ElementTree\n\n        root = XML(_bytes(\n            \"<?xml version='1.0' encoding='UTF-8' standalone='yes'?>\\n<root/>\"))\n\n        tree = ElementTree(root)\n        self.assertEqual(True, tree.docinfo.standalone)\n\n        result = tostring(root, xml_declaration=True, encoding=\"ASCII\")\n        self.assertEqual(result, _bytes(\n            \"<?xml version='1.0' encoding='ASCII'?>\\n<root/>\"))\n\n        result = tostring(root, xml_declaration=True, encoding=\"ASCII\",\n                          standalone=True)\n        self.assertEqual(result, _bytes(\n            \"<?xml version='1.0' encoding='ASCII' standalone='yes'?>\\n<root/>\"))\n\n    def test_tostring_method_text_encoding(self):\n        tostring = self.etree.tostring\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        \n        a = Element('a')\n        a.text = \"A\"\n        a.tail = \"tail\"\n        b = SubElement(a, 'b')\n        b.text = \"B\"\n        b.tail = _str(\"S\u00f8k p\u00e5 nettet\")\n        c = SubElement(a, 'c')\n        c.text = \"C\"\n\n        result = tostring(a, method=\"text\", encoding=\"UTF-16\")\n\n        self.assertEqual(_str('ABS\u00f8k p\u00e5 nettetCtail').encode(\"UTF-16\"),\n                          result)\n\n    def test_tostring_method_text_unicode(self):\n        tostring = self.etree.tostring\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        \n        a = Element('a')\n        a.text = _str('S\u00f8k p\u00e5 nettetA')\n        a.tail = \"tail\"\n        b = SubElement(a, 'b')\n        b.text = \"B\"\n        b.tail = _str('S\u00f8k p\u00e5 nettetB')\n        c = SubElement(a, 'c')\n        c.text = \"C\"\n        \n        self.assertRaises(UnicodeEncodeError,\n                          tostring, a, method=\"text\")\n        \n        self.assertEqual(\n            _str('S\u00f8k p\u00e5 nettetABS\u00f8k p\u00e5 nettetBCtail').encode('utf-8'),\n            tostring(a, encoding=\"UTF-8\", method=\"text\"))\n\n    def test_tounicode(self):\n        tounicode = self.etree.tounicode\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        \n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        \n        self.assertTrue(isinstance(tounicode(a), _unicode))\n        self.assertEqual(_bytes('<a><b></b><c></c></a>'),\n                          canonicalize(tounicode(a)))\n\n    def test_tounicode_element(self):\n        tounicode = self.etree.tounicode\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        \n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(c, 'd')\n        self.assertTrue(isinstance(tounicode(b), _unicode))\n        self.assertTrue(isinstance(tounicode(c), _unicode))\n        self.assertEqual(_bytes('<b></b>'),\n                          canonicalize(tounicode(b)))\n        self.assertEqual(_bytes('<c><d></d></c>'),\n                          canonicalize(tounicode(c)))\n\n    def test_tounicode_none(self):\n        tounicode = self.etree.tounicode\n        self.assertRaises(TypeError, self.etree.tounicode, None)\n\n    def test_tounicode_element_tail(self):\n        tounicode = self.etree.tounicode\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        \n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(c, 'd')\n        b.tail = 'Foo'\n\n        self.assertTrue(isinstance(tounicode(b), _unicode))\n        self.assertTrue(tounicode(b) == '<b/>Foo' or\n                     tounicode(b) == '<b />Foo')\n\n    def test_tounicode_pretty(self):\n        tounicode = self.etree.tounicode\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n\n        result = tounicode(a)\n        self.assertEqual(result, \"<a><b/><c/></a>\")\n\n        result = tounicode(a, pretty_print=False)\n        self.assertEqual(result, \"<a><b/><c/></a>\")\n\n        result = tounicode(a, pretty_print=True)\n        self.assertEqual(result, \"<a>\\n  <b/>\\n  <c/>\\n</a>\\n\")\n\n    def test_tostring_unicode(self):\n        tostring = self.etree.tostring\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        \n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        \n        self.assertTrue(isinstance(tostring(a, encoding=_unicode), _unicode))\n        self.assertEqual(_bytes('<a><b></b><c></c></a>'),\n                          canonicalize(tostring(a, encoding=_unicode)))\n\n    def test_tostring_unicode_element(self):\n        tostring = self.etree.tostring\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        \n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(c, 'd')\n        self.assertTrue(isinstance(tostring(b, encoding=_unicode), _unicode))\n        self.assertTrue(isinstance(tostring(c, encoding=_unicode), _unicode))\n        self.assertEqual(_bytes('<b></b>'),\n                          canonicalize(tostring(b, encoding=_unicode)))\n        self.assertEqual(_bytes('<c><d></d></c>'),\n                          canonicalize(tostring(c, encoding=_unicode)))\n\n    def test_tostring_unicode_none(self):\n        tostring = self.etree.tostring\n        self.assertRaises(TypeError, self.etree.tostring,\n                          None, encoding=_unicode)\n\n    def test_tostring_unicode_element_tail(self):\n        tostring = self.etree.tostring\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        \n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(c, 'd')\n        b.tail = 'Foo'\n\n        self.assertTrue(isinstance(tostring(b, encoding=_unicode), _unicode))\n        self.assertTrue(tostring(b, encoding=_unicode) == '<b/>Foo' or\n                     tostring(b, encoding=_unicode) == '<b />Foo')\n\n    def test_tostring_unicode_pretty(self):\n        tostring = self.etree.tostring\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n\n        result = tostring(a, encoding=_unicode)\n        self.assertEqual(result, \"<a><b/><c/></a>\")\n\n        result = tostring(a, encoding=_unicode, pretty_print=False)\n        self.assertEqual(result, \"<a><b/><c/></a>\")\n\n        result = tostring(a, encoding=_unicode, pretty_print=True)\n        self.assertEqual(result, \"<a>\\n  <b/>\\n  <c/>\\n</a>\\n\")\n\n    def test_pypy_proxy_collect(self):\n        root = etree.Element('parent')\n        etree.SubElement(root, 'child')\n\n        self.assertEqual(len(root), 1)\n        self.assertEqual(root[0].tag, 'child')\n\n        # in PyPy, GC used to kill the Python proxy instance without cleanup\n        gc.collect()\n        self.assertEqual(len(root), 1)\n        self.assertEqual(root[0].tag, 'child')\n\n    def test_element_refcycle(self):\n        class SubEl(etree.ElementBase):\n            pass\n\n        el1 = SubEl()\n        el2 = SubEl()\n        self.assertEqual('SubEl', el1.tag)\n        self.assertEqual('SubEl', el2.tag)\n        el1.other = el2\n        el2.other = el1\n\n        del el1, el2\n        gc.collect()\n        # not really testing anything here, but it shouldn't crash\n\n    def test_proxy_collect_siblings(self):\n        root = etree.Element('parent')\n        c1 = etree.SubElement(root, 'child1')\n        c2 = etree.SubElement(root, 'child2')\n\n        root.remove(c1)\n        root.remove(c2)\n        c1.addnext(c2)\n        del c1\n        # trigger deallocation attempt of c1\n        c2.getprevious()\n        # make sure it wasn't deallocated\n        self.assertEqual('child1', c2.getprevious().tag)\n\n    def test_proxy_collect_siblings_text(self):\n        root = etree.Element('parent')\n        c1 = etree.SubElement(root, 'child1')\n        c2 = etree.SubElement(root, 'child2')\n\n        root.remove(c1)\n        root.remove(c2)\n        c1.addnext(c2)\n        c1.tail = 'abc'\n        c2.tail = 'xyz'\n        del c1\n        # trigger deallocation attempt of c1\n        c2.getprevious()\n        # make sure it wasn't deallocated\n        self.assertEqual('child1', c2.getprevious().tag)\n        self.assertEqual('abc', c2.getprevious().tail)\n\n    def test_parse_source_pathlike(self):\n        etree = self.etree\n        tounicode = self.etree.tounicode\n\n        tree = etree.parse(SimpleFSPath(fileInTestDir('test.xml')))\n        self.assertEqual(_bytes('<a><b></b></a>'),\n                         canonicalize(tounicode(tree)))\n    \n    def test_iterparse_source_pathlike(self):\n        iterparse = self.etree.iterparse\n\n        events = list(iterparse(SimpleFSPath(fileInTestDir('test.xml'))))\n        self.assertEqual(2, len(events))\n\n    # helper methods\n\n    def _writeElement(self, element, encoding='us-ascii', compression=0):\n        \"\"\"Write out element for comparison.\n        \"\"\"\n        ElementTree = self.etree.ElementTree\n        f = BytesIO()\n        tree = ElementTree(element=element)\n        tree.write(f, encoding=encoding, compression=compression)\n        data = f.getvalue()\n        if compression:\n            data = zlib.decompress(data)\n        return canonicalize(data)\n\n\nclass _XIncludeTestCase(HelperTestCase):\n    def test_xinclude_text(self):\n        filename = fileInTestDir('test_broken.xml')\n        root = etree.XML(_bytes('''\\\n        <doc xmlns:xi=\"http://www.w3.org/2001/XInclude\">\n          <xi:include href=\"%s\" parse=\"text\"/>\n        </doc>\n        ''' % path2url(filename)))\n        old_text = root.text\n        content = read_file(filename)\n        old_tail = root[0].tail\n\n        self.include( etree.ElementTree(root) )\n        self.assertEqual(old_text + content + old_tail,\n                          root.text)\n\n    def test_xinclude(self):\n        tree = etree.parse(fileInTestDir('include/test_xinclude.xml'))\n        self.assertNotEqual(\n            'a',\n            tree.getroot()[1].tag)\n        # process xincludes\n        self.include( tree )\n        # check whether we find it replaced with included data\n        self.assertEqual(\n            'a',\n            tree.getroot()[1].tag)\n\n    def test_xinclude_resolver(self):\n        class res(etree.Resolver):\n            include_text = read_file(fileInTestDir('test.xml'))\n            called = {}\n            def resolve(self, url, id, context):\n                if url.endswith(\".dtd\"):\n                    self.called[\"dtd\"] = True\n                    return self.resolve_filename(\n                        fileInTestDir('test.dtd'), context)\n                elif url.endswith(\"test_xinclude.xml\"):\n                    self.called[\"input\"] = True\n                    return None # delegate to default resolver\n                else:\n                    self.called[\"include\"] = True\n                    return self.resolve_string(self.include_text, context)\n\n        res_instance = res()\n        parser = etree.XMLParser(load_dtd = True)\n        parser.resolvers.add(res_instance)\n\n        tree = etree.parse(fileInTestDir('include/test_xinclude.xml'),\n                           parser = parser)\n\n        self.include(tree)\n\n        called = list(res_instance.called.items())\n        called.sort()\n        self.assertEqual(\n            [(\"dtd\", True), (\"include\", True), (\"input\", True)],\n            called)\n\n    def test_xinclude_resolver_recursive(self):\n        data = textwrap.dedent('''\n        <doc xmlns:xi=\"http://www.w3.org/2001/XInclude\">\n        <foo/>\n        <xi:include href=\"./test.xml\" />\n        </doc>\n        ''')\n\n        class Resolver(etree.Resolver):\n            called = {}\n\n            def resolve(self, url, id, context):\n                if url.endswith(\"test_xinclude.xml\"):\n                    assert not self.called.get(\"input\")\n                    self.called[\"input\"] = True\n                    return None  # delegate to default resolver\n                elif url.endswith('/test5.xml'):\n                    assert not self.called.get(\"DONE\")\n                    self.called[\"DONE\"] = True\n                    return self.resolve_string('<DONE/>', context)\n                else:\n                    _, filename = url.rsplit('/', 1)\n                    assert not self.called.get(filename)\n                    self.called[filename] = True\n                    next_data = data.replace(\n                        'test.xml', 'test%d.xml' % len(self.called))\n                    return self.resolve_string(next_data, context)\n\n        res_instance = Resolver()\n        parser = etree.XMLParser(load_dtd=True)\n        parser.resolvers.add(res_instance)\n\n        tree = etree.parse(fileInTestDir('include/test_xinclude.xml'),\n                           parser=parser)\n\n        self.include(tree)\n\n        called = list(res_instance.called.items())\n        called.sort()\n        self.assertEqual(\n            [(\"DONE\", True), (\"input\", True), (\"test.xml\", True),\n             (\"test2.xml\", True), (\"test3.xml\", True), (\"test4.xml\", True)],\n            called)\n\n\nclass ETreeXIncludeTestCase(_XIncludeTestCase):\n    def include(self, tree):\n        tree.xinclude()\n\n\nclass ElementIncludeTestCase(_XIncludeTestCase):\n    from lxml import ElementInclude\n\n    def include(self, tree, loader=None, max_depth=None):\n        self.ElementInclude.include(tree.getroot(), loader=loader, max_depth=max_depth)\n\n    XINCLUDE = {}\n\n    XINCLUDE[\"Recursive1.xml\"] = \"\"\"\\\n    <?xml version='1.0'?>\n    <document xmlns:xi=\"http://www.w3.org/2001/XInclude\">\n      <p>The following is the source code of Recursive2.xml:</p>\n      <xi:include href=\"Recursive2.xml\"/>\n    </document>\n    \"\"\"\n\n    XINCLUDE[\"Recursive2.xml\"] = \"\"\"\\\n    <?xml version='1.0'?>\n    <document xmlns:xi=\"http://www.w3.org/2001/XInclude\">\n      <p>The following is the source code of Recursive3.xml:</p>\n      <xi:include href=\"Recursive3.xml\"/>\n    </document>\n    \"\"\"\n\n    XINCLUDE[\"Recursive3.xml\"] = \"\"\"\\\n    <?xml version='1.0'?>\n    <document xmlns:xi=\"http://www.w3.org/2001/XInclude\">\n      <p>The following is the source code of Recursive1.xml:</p>\n      <xi:include href=\"Recursive1.xml\"/>\n    </document>\n    \"\"\"\n\n    XINCLUDE[\"NonRecursive1.xml\"] = \"\"\"\\\n    <?xml version='1.0'?>\n    <document xmlns:xi=\"http://www.w3.org/2001/XInclude\">\n      <p>The following is multiple times the source code of NonRecursive3.xml:</p>\n      <xi:include href=\"NonRecursive3.xml\"/>\n      <xi:include href=\"NonRecursive3.xml\"/>\n      <p>The following is multiple times the source code of Leaf.xml:</p>\n      <xi:include href=\"Leaf.xml\"/>\n      <xi:include href=\"Leaf.xml\"/>\n      <xi:include href=\"Leaf.xml\"/>\n      <p>One more time the source code of NonRecursive3.xml:</p>\n      <xi:include href=\"NonRecursive3.xml\"/>\n    </document>\n    \"\"\"\n\n    XINCLUDE[\"NonRecursive2.xml\"] = \"\"\"\\\n    <?xml version='1.0'?>\n    <document xmlns:xi=\"http://www.w3.org/2001/XInclude\">\n      <p>The following is multiple times the source code of NonRecursive3.xml:</p>\n      <xi:include href=\"NonRecursive3.xml\"/>\n      <xi:include href=\"NonRecursive3.xml\"/>\n    </document>\n    \"\"\"\n\n    XINCLUDE[\"NonRecursive3.xml\"] = \"\"\"\\\n    <?xml version='1.0'?>\n    <document xmlns:xi=\"http://www.w3.org/2001/XInclude\">\n      <p>The following is multiple times the source code of Leaf.xml:</p>\n      <xi:include href=\"Leaf.xml\"/>\n      <xi:include href=\"Leaf.xml\"/>\n    </document>\n    \"\"\"\n\n    XINCLUDE[\"Leaf.xml\"] = \"\"\"\\\n    <?xml version='1.0'?>\n    <document xmlns:xi=\"http://www.w3.org/2001/XInclude\">\n      <p>No further includes</p>\n    </document>\n    \"\"\"\n\n    def xinclude_loader(self, href, parse=\"xml\", encoding=None):\n        try:\n            data = textwrap.dedent(self.XINCLUDE[href])\n        except KeyError:\n            raise OSError(\"resource not found\")\n        if parse == \"xml\":\n            data = etree.fromstring(data)\n        return data\n\n    def test_xinclude_failures(self):\n        # Test infinitely recursive includes.\n        document = self.xinclude_loader(\"Recursive1.xml\").getroottree()\n        with self.assertRaises(self.ElementInclude.FatalIncludeError) as cm:\n            self.include(document, self.xinclude_loader)\n        self.assertEqual(str(cm.exception),\n                         \"recursive include of 'Recursive2.xml' detected\")\n\n        # Test 'max_depth' limitation.\n        document = self.xinclude_loader(\"Recursive1.xml\").getroottree()\n        with self.assertRaises(self.ElementInclude.FatalIncludeError) as cm:\n            self.include(document, self.xinclude_loader, max_depth=None)\n        self.assertEqual(str(cm.exception),\n                         \"recursive include of 'Recursive2.xml' detected\")\n\n        document = self.xinclude_loader(\"Recursive1.xml\").getroottree()\n        with self.assertRaises(self.ElementInclude.LimitedRecursiveIncludeError) as cm:\n            self.include(document, self.xinclude_loader, max_depth=0)\n        self.assertEqual(str(cm.exception),\n                         \"maximum xinclude depth reached when including file Recursive2.xml\")\n\n        document = self.xinclude_loader(\"Recursive1.xml\").getroottree()\n        with self.assertRaises(self.ElementInclude.LimitedRecursiveIncludeError) as cm:\n            self.include(document, self.xinclude_loader, max_depth=1)\n        self.assertEqual(str(cm.exception),\n                         \"maximum xinclude depth reached when including file Recursive3.xml\")\n\n        document = self.xinclude_loader(\"Recursive1.xml\").getroottree()\n        with self.assertRaises(self.ElementInclude.LimitedRecursiveIncludeError) as cm:\n            self.include(document, self.xinclude_loader, max_depth=2)\n        self.assertEqual(str(cm.exception),\n                         \"maximum xinclude depth reached when including file Recursive1.xml\")\n\n        document = self.xinclude_loader(\"Recursive1.xml\").getroottree()\n        with self.assertRaises(self.ElementInclude.FatalIncludeError) as cm:\n            self.include(document, self.xinclude_loader, max_depth=3)\n        self.assertEqual(str(cm.exception),\n                         \"recursive include of 'Recursive2.xml' detected\")\n\n    def test_multiple_include_of_same_file(self):\n        # Test that including the same file multiple times, but on the same level\n        # is not detected as recursive include\n        document = self.xinclude_loader(\"NonRecursive3.xml\").getroottree()\n        self.include(document, self.xinclude_loader)\n\n        # same but for more than one level\n        document = self.xinclude_loader(\"NonRecursive1.xml\").getroottree()\n        self.include(document, self.xinclude_loader)\n\n        # same but no Leaf.xml in top-level file\n        document = self.xinclude_loader(\"NonRecursive2.xml\").getroottree()\n        self.include(document, self.xinclude_loader)\n\n\nclass ETreeC14NTestCase(HelperTestCase):\n    def test_c14n(self):\n        tree = self.parse(_bytes('<a><b/></a>'))\n        f = BytesIO()\n        tree.write_c14n(f)\n        s = f.getvalue()\n        self.assertEqual(_bytes('<a><b></b></a>'),\n                          s)\n\n    def test_c14n_gzip(self):\n        tree = self.parse(_bytes('<a>'+'<b/>'*200+'</a>'))\n        f = BytesIO()\n        tree.write_c14n(f, compression=9)\n        with gzip.GzipFile(fileobj=BytesIO(f.getvalue())) as gzfile:\n            s = gzfile.read()\n        self.assertEqual(_bytes('<a>'+'<b></b>'*200+'</a>'),\n                          s)\n\n    def test_c14n_file(self):\n        tree = self.parse(_bytes('<a><b/></a>'))\n        with tmpfile() as filename:\n            tree.write_c14n(filename)\n            data = read_file(filename, 'rb')\n        self.assertEqual(_bytes('<a><b></b></a>'),\n                          data)\n    \n    def test_c14n_file_pathlike(self):\n        tree = self.parse(_bytes('<a><b/></a>'))\n        with tmpfile() as filename:\n            tree.write_c14n(SimpleFSPath(filename))\n            data = read_file(filename, 'rb')\n        self.assertEqual(_bytes('<a><b></b></a>'),\n                        data)\n\n    def test_c14n_file_gzip(self):\n        tree = self.parse(_bytes('<a>'+'<b/>'*200+'</a>'))\n        with tmpfile() as filename:\n            tree.write_c14n(filename, compression=9)\n            with gzip.open(filename, 'rb') as f:\n                data = f.read()\n        self.assertEqual(_bytes('<a>'+'<b></b>'*200+'</a>'),\n                          data)\n    \n    def test_c14n_file_gzip_pathlike(self):\n        tree = self.parse(_bytes('<a>'+'<b/>'*200+'</a>'))\n        with tmpfile() as filename:\n            tree.write_c14n(SimpleFSPath(filename), compression=9)\n            with gzip.open(filename, 'rb') as f:\n                data = f.read()\n        self.assertEqual(_bytes('<a>'+'<b></b>'*200+'</a>'),\n                        data)\n\n    def test_c14n2_file_gzip(self):\n        tree = self.parse(_bytes('<a>'+'<b/>'*200+'</a>'))\n        with tmpfile() as filename:\n            tree.write(filename, method='c14n2', compression=9)\n            with gzip.open(filename, 'rb') as f:\n                data = f.read()\n        self.assertEqual(_bytes('<a>'+'<b></b>'*200+'</a>'),\n                          data)\n\n    def test_c14n2_with_text(self):\n        tree = self.parse(\n            b'<?xml version=\"1.0\"?>    <a> abc \\n <b>  btext </b> btail <c/>    ctail </a>     ')\n        f = BytesIO()\n        tree.write(f, method='c14n2')\n        s = f.getvalue()\n        self.assertEqual(b'<a> abc \\n <b>  btext </b> btail <c></c>    ctail </a>',\n                         s)\n\n        f = BytesIO()\n        tree.write(f, method='c14n2', strip_text=True)\n        s = f.getvalue()\n        self.assertEqual(b'<a>abc<b>btext</b>btail<c></c>ctail</a>',\n                         s)\n\n    def test_c14n_with_comments(self):\n        tree = self.parse(_bytes('<!--hi--><a><!--ho--><b/></a><!--hu-->'))\n        f = BytesIO()\n        tree.write_c14n(f)\n        s = f.getvalue()\n        self.assertEqual(_bytes('<!--hi-->\\n<a><!--ho--><b></b></a>\\n<!--hu-->'),\n                          s)\n        f = BytesIO()\n        tree.write_c14n(f, with_comments=True)\n        s = f.getvalue()\n        self.assertEqual(_bytes('<!--hi-->\\n<a><!--ho--><b></b></a>\\n<!--hu-->'),\n                          s)\n        f = BytesIO()\n        tree.write_c14n(f, with_comments=False)\n        s = f.getvalue()\n        self.assertEqual(_bytes('<a><b></b></a>'),\n                          s)\n\n    def test_c14n2_with_comments(self):\n        tree = self.parse(b'<!--hi--> <a> <!-- ho --> <b/> </a> <!-- hu -->')\n        self.assertEqual(\n            b'<!--hi-->\\n<a> <!-- ho --> <b></b> </a>\\n<!-- hu -->',\n            etree.tostring(tree, method='c14n2'))\n\n        self.assertEqual(\n            b'<!--hi-->\\n<a> <!-- ho --> <b></b> </a>\\n<!-- hu -->',\n            etree.tostring(tree, method='c14n2', with_comments=True))\n\n        self.assertEqual(\n            b'<a>  <b></b> </a>',\n            etree.tostring(tree, method='c14n2', with_comments=False))\n\n    def test_c14n2_with_comments_strip_text(self):\n        tree = self.parse(b'<!--hi--> <a> <!-- ho --> <b/> </a> <!-- hu -->')\n        self.assertEqual(\n            b'<!--hi-->\\n<a><!-- ho --><b></b></a>\\n<!-- hu -->',\n            etree.tostring(tree, method='c14n2', with_comments=True, strip_text=True))\n        self.assertEqual(\n            b'<a><b></b></a>',\n            etree.tostring(tree, method='c14n2', with_comments=False, strip_text=True))\n\n    def test_c14n_tostring_with_comments(self):\n        tree = self.parse(_bytes('<!--hi--><a><!--ho--><b/></a><!--hu-->'))\n        s = etree.tostring(tree, method='c14n')\n        self.assertEqual(_bytes('<!--hi-->\\n<a><!--ho--><b></b></a>\\n<!--hu-->'),\n                          s)\n        s = etree.tostring(tree, method='c14n', with_comments=True)\n        self.assertEqual(_bytes('<!--hi-->\\n<a><!--ho--><b></b></a>\\n<!--hu-->'),\n                          s)\n        s = etree.tostring(tree, method='c14n', with_comments=False)\n        self.assertEqual(_bytes('<a><b></b></a>'),\n                          s)\n\n    def test_c14n2_tostring_with_comments(self):\n        tree = self.parse(b'<!--hi--><a><!--ho--><b/></a><!--hu-->')\n        s = etree.tostring(tree, method='c14n2')\n        self.assertEqual(b'<!--hi-->\\n<a><!--ho--><b></b></a>\\n<!--hu-->',\n                          s)\n        s = etree.tostring(tree, method='c14n2', with_comments=True)\n        self.assertEqual(b'<!--hi-->\\n<a><!--ho--><b></b></a>\\n<!--hu-->',\n                          s)\n        s = etree.tostring(tree, method='c14n2', with_comments=False)\n        self.assertEqual(b'<a><b></b></a>',\n                          s)\n\n    def test_c14n_element_tostring_with_comments(self):\n        tree = self.parse(_bytes('<!--hi--><a><!--ho--><b/></a><!--hu-->'))\n        s = etree.tostring(tree.getroot(), method='c14n')\n        self.assertEqual(_bytes('<a><!--ho--><b></b></a>'),\n                          s)\n        s = etree.tostring(tree.getroot(), method='c14n', with_comments=True)\n        self.assertEqual(_bytes('<a><!--ho--><b></b></a>'),\n                          s)\n        s = etree.tostring(tree.getroot(), method='c14n', with_comments=False)\n        self.assertEqual(_bytes('<a><b></b></a>'),\n                          s)\n\n    def test_c14n_exclusive(self):\n        tree = self.parse(_bytes(\n                '<a xmlns=\"http://abc\" xmlns:y=\"http://bcd\" xmlns:z=\"http://cde\"><z:b/></a>'))\n        f = BytesIO()\n        tree.write_c14n(f)\n        s = f.getvalue()\n        self.assertEqual(_bytes('<a xmlns=\"http://abc\" xmlns:y=\"http://bcd\" xmlns:z=\"http://cde\"><z:b></z:b></a>'),\n                          s)\n        f = BytesIO()\n        tree.write_c14n(f, exclusive=False)\n        s = f.getvalue()\n        self.assertEqual(_bytes('<a xmlns=\"http://abc\" xmlns:y=\"http://bcd\" xmlns:z=\"http://cde\"><z:b></z:b></a>'),\n                          s)\n        f = BytesIO()\n        tree.write_c14n(f, exclusive=True)\n        s = f.getvalue()\n        self.assertEqual(_bytes('<a xmlns=\"http://abc\"><z:b xmlns:z=\"http://cde\"></z:b></a>'),\n                          s)\n\n        f = BytesIO()\n        tree.write_c14n(f, exclusive=True, inclusive_ns_prefixes=['z'])\n        s = f.getvalue()\n        self.assertEqual(_bytes('<a xmlns=\"http://abc\" xmlns:z=\"http://cde\"><z:b></z:b></a>'),\n                          s)\n\n    def test_c14n_tostring_exclusive(self):\n        tree = self.parse(_bytes(\n                '<a xmlns=\"http://abc\" xmlns:y=\"http://bcd\" xmlns:z=\"http://cde\"><z:b/></a>'))\n        s = etree.tostring(tree, method='c14n')\n        self.assertEqual(_bytes('<a xmlns=\"http://abc\" xmlns:y=\"http://bcd\" xmlns:z=\"http://cde\"><z:b></z:b></a>'),\n                          s)\n        s = etree.tostring(tree, method='c14n', exclusive=False)\n        self.assertEqual(_bytes('<a xmlns=\"http://abc\" xmlns:y=\"http://bcd\" xmlns:z=\"http://cde\"><z:b></z:b></a>'),\n                          s)\n        s = etree.tostring(tree, method='c14n', exclusive=True)\n        self.assertEqual(_bytes('<a xmlns=\"http://abc\"><z:b xmlns:z=\"http://cde\"></z:b></a>'),\n                          s)\n\n        s = etree.tostring(tree, method='c14n', exclusive=True, inclusive_ns_prefixes=['y'])\n        self.assertEqual(_bytes('<a xmlns=\"http://abc\" xmlns:y=\"http://bcd\"><z:b xmlns:z=\"http://cde\"></z:b></a>'),\n                          s)\n\n    def test_c14n_element_tostring_exclusive(self):\n        tree = self.parse(_bytes(\n                '<a xmlns=\"http://abc\" xmlns:y=\"http://bcd\" xmlns:z=\"http://cde\"><z:b/></a>'))\n        s = etree.tostring(tree.getroot(), method='c14n')\n        self.assertEqual(_bytes('<a xmlns=\"http://abc\" xmlns:y=\"http://bcd\" xmlns:z=\"http://cde\"><z:b></z:b></a>'),\n                          s)\n        s = etree.tostring(tree.getroot(), method='c14n', exclusive=False)\n        self.assertEqual(_bytes('<a xmlns=\"http://abc\" xmlns:y=\"http://bcd\" xmlns:z=\"http://cde\"><z:b></z:b></a>'),\n                          s)\n        s = etree.tostring(tree.getroot(), method='c14n', exclusive=True)\n        self.assertEqual(_bytes('<a xmlns=\"http://abc\"><z:b xmlns:z=\"http://cde\"></z:b></a>'),\n                          s)\n\n        s = etree.tostring(tree.getroot()[0], method='c14n', exclusive=False)\n        self.assertEqual(_bytes('<z:b xmlns=\"http://abc\" xmlns:y=\"http://bcd\" xmlns:z=\"http://cde\"></z:b>'),\n                          s)\n        s = etree.tostring(tree.getroot()[0], method='c14n', exclusive=True)\n        self.assertEqual(_bytes('<z:b xmlns:z=\"http://cde\"></z:b>'),\n                          s)\n\n        s = etree.tostring(tree.getroot()[0], method='c14n', exclusive=True, inclusive_ns_prefixes=['y'])\n        self.assertEqual(_bytes('<z:b xmlns:y=\"http://bcd\" xmlns:z=\"http://cde\"></z:b>'),\n                          s)\n\n    def test_c14n_tostring_inclusive_ns_prefixes(self):\n        \"\"\" Regression test to fix memory allocation issues (use 3+ inclusive NS spaces)\"\"\"\n        tree = self.parse(_bytes(\n                '<a xmlns:x=\"http://abc\" xmlns:y=\"http://bcd\" xmlns:z=\"http://cde\"><z:b/></a>'))\n\n        s = etree.tostring(tree, method='c14n', exclusive=True, inclusive_ns_prefixes=['x', 'y', 'z'])\n        self.assertEqual(_bytes('<a xmlns:x=\"http://abc\" xmlns:y=\"http://bcd\" xmlns:z=\"http://cde\"><z:b></z:b></a>'),\n                          s)\n    \n    def test_python3_problem_bytesio_iterparse(self):\n        content = BytesIO('''<?xml version=\"1.0\" encoding=\"utf-8\"?> <some_ns_id:some_head_elem xmlns:some_ns_id=\"http://www.example.com\" xmlns:xhtml=\"http://www.w3.org/1999/xhtml\"><xhtml:div></xhtml:div></some_ns_id:some_head_elem>'''.encode('utf-8'))\n        def handle_div_end(event, element):\n            if event == 'end' and element.tag.lower().startswith(\"{http://www.w3.org/1999/xhtml}div\"):\n                # for ns_id, ns_uri in element.nsmap.items():\n                #     print(type(ns_id), type(ns_uri), ns_id, '=', ns_uri)\n                etree.tostring(element, method=\"c14n2\")\n        for event, element in etree.iterparse(\n            source=content,\n            events=('start', 'end')\n        ):\n            handle_div_end(event, element)\n    \n    def test_python3_problem_filebased_iterparse(self):\n        with open('test.xml', 'w+b') as f:\n            f.write('''<?xml version=\"1.0\" encoding=\"utf-8\"?> <some_ns_id:some_head_elem xmlns:some_ns_id=\"http://www.example.com\" xmlns:xhtml=\"http://www.w3.org/1999/xhtml\"><xhtml:div></xhtml:div></some_ns_id:some_head_elem>'''.encode('utf-8'))\n        def handle_div_end(event, element):\n            if event == 'end' and element.tag.lower() == \"{http://www.w3.org/1999/xhtml}div\":\n                # for ns_id, ns_uri in element.nsmap.items():\n                #     print(type(ns_id), type(ns_uri), ns_id, '=', ns_uri)\n                etree.tostring(element, method=\"c14n2\")\n        for event, element in etree.iterparse(\n            source='test.xml',\n            events=('start', 'end')\n        ):\n            handle_div_end(event, element)\n    \n    def test_python3_problem_filebased_parse(self):\n        with open('test.xml', 'w+b') as f:\n            f.write('''<?xml version=\"1.0\" encoding=\"utf-8\"?> <some_ns_id:some_head_elem xmlns:some_ns_id=\"http://www.example.com\" xmlns:xhtml=\"http://www.w3.org/1999/xhtml\"><xhtml:div></xhtml:div></some_ns_id:some_head_elem>'''.encode('utf-8'))\n        def serialize_div_element(element):        \n            # for ns_id, ns_uri in element.nsmap.items():\n            #     print(type(ns_id), type(ns_uri), ns_id, '=', ns_uri)\n            etree.tostring(element, method=\"c14n2\")\n        tree = etree.parse(source='test.xml')\n        root = tree.getroot()\n        div = root.xpath('//xhtml:div', namespaces={'xhtml':'http://www.w3.org/1999/xhtml'})[0]\n        serialize_div_element(div)\n\n\nclass ETreeWriteTestCase(HelperTestCase):\n    def test_write(self):\n        tree = self.parse(_bytes('<a><b/></a>'))\n        f = BytesIO()\n        tree.write(f)\n        s = f.getvalue()\n        self.assertEqual(_bytes('<a><b/></a>'),\n                          s)\n\n    def test_write_doctype(self):\n        tree = self.parse(_bytes('<a><b/></a>'))\n        f = BytesIO()\n        tree.write(f, doctype='HUHU')\n        s = f.getvalue()\n        self.assertEqual(_bytes('HUHU\\n<a><b/></a>'),\n                          s)\n\n    def test_write_gzip(self):\n        tree = self.parse(_bytes('<a>'+'<b/>'*200+'</a>'))\n        f = BytesIO()\n        tree.write(f, compression=9)\n        with gzip.GzipFile(fileobj=BytesIO(f.getvalue())) as gzfile:\n            s = gzfile.read()\n        self.assertEqual(_bytes('<a>'+'<b/>'*200+'</a>'),\n                          s)\n\n    def test_write_gzip_doctype(self):\n        tree = self.parse(_bytes('<a>'+'<b/>'*200+'</a>'))\n        f = BytesIO()\n        tree.write(f, compression=9, doctype='<!DOCTYPE a>')\n        with gzip.GzipFile(fileobj=BytesIO(f.getvalue())) as gzfile:\n            s = gzfile.read()\n        self.assertEqual(_bytes('<!DOCTYPE a>\\n<a>'+'<b/>'*200+'</a>'),\n                          s)\n\n    def test_write_gzip_level(self):\n        tree = self.parse(_bytes('<a>'+'<b/>'*200+'</a>'))\n        f = BytesIO()\n        tree.write(f, compression=0)\n        s0 = f.getvalue()\n\n        f = BytesIO()\n        tree.write(f)\n        self.assertEqual(f.getvalue(), s0)\n\n        f = BytesIO()\n        tree.write(f, compression=1)\n        s = f.getvalue()\n        self.assertTrue(len(s) <= len(s0))\n        with gzip.GzipFile(fileobj=BytesIO(s)) as gzfile:\n            s1 = gzfile.read()\n\n        f = BytesIO()\n        tree.write(f, compression=9)\n        s = f.getvalue()\n        self.assertTrue(len(s) <= len(s0))\n        with gzip.GzipFile(fileobj=BytesIO(s)) as gzfile:\n            s9 = gzfile.read()\n\n        self.assertEqual(_bytes('<a>'+'<b/>'*200+'</a>'),\n                          s0)\n        self.assertEqual(_bytes('<a>'+'<b/>'*200+'</a>'),\n                          s1)\n        self.assertEqual(_bytes('<a>'+'<b/>'*200+'</a>'),\n                          s9)\n\n    def test_write_file(self):\n        tree = self.parse(_bytes('<a><b/></a>'))\n        with tmpfile() as filename:\n            tree.write(filename)\n            data = read_file(filename, 'rb')\n        self.assertEqual(_bytes('<a><b/></a>'),\n                          data)\n    \n    def test_write_file_pathlike(self):\n        tree = self.parse(_bytes('<a><b/></a>'))\n        with tmpfile() as filename:\n            tree.write(SimpleFSPath(filename))\n            data = read_file(filename, 'rb')\n        self.assertEqual(_bytes('<a><b/></a>'),\n                        data)\n\n    def test_write_file_gzip(self):\n        tree = self.parse(_bytes('<a>'+'<b/>'*200+'</a>'))\n        with tmpfile() as filename:\n            tree.write(filename, compression=9)\n            with gzip.open(filename, 'rb') as f:\n                data = f.read()\n        self.assertEqual(_bytes('<a>'+'<b/>'*200+'</a>'),\n                          data)\n\n    def test_write_file_gzip_pathlike(self):\n        tree = self.parse(_bytes('<a>'+'<b/>'*200+'</a>'))\n        with tmpfile() as filename:\n            tree.write(SimpleFSPath(filename), compression=9)\n            with gzip.open(filename, 'rb') as f:\n                data = f.read()\n        self.assertEqual(_bytes('<a>'+'<b/>'*200+'</a>'),\n                        data)\n\n    def test_write_file_gzip_parse(self):\n        tree = self.parse(_bytes('<a>'+'<b/>'*200+'</a>'))\n        with tmpfile() as filename:\n            tree.write(filename, compression=9)\n            data = etree.tostring(etree.parse(filename))\n        self.assertEqual(_bytes('<a>'+'<b/>'*200+'</a>'),\n                          data)\n\n    def test_write_file_gzipfile_parse(self):\n        tree = self.parse(_bytes('<a>'+'<b/>'*200+'</a>'))\n        with tmpfile() as filename:\n            tree.write(filename, compression=9)\n            with gzip.GzipFile(filename) as f:\n                data = etree.tostring(etree.parse(f))\n        self.assertEqual(_bytes('<a>'+'<b/>'*200+'</a>'),\n                          data)\n\n    def test_write_file_url(self):\n        xml = _bytes('<a>'+'<b/>'*200+'</a>')\n        tree = self.parse(xml)\n        with tmpfile(prefix=\"p+%20\", suffix=\".xml\") as filename:\n            url = 'file://' + (filename if sys.platform != 'win32'\n                               else '/' + filename.replace('\\\\', '/'))\n            tree.write(url)\n            data = read_file(filename, 'rb').replace(_bytes('\\n'), _bytes(''))\n        self.assertEqual(data, xml)\n\n\nclass ETreeErrorLogTest(HelperTestCase):\n    etree = etree\n\n    def test_parse_error_logging(self):\n        parse = self.etree.parse\n        f = BytesIO('<a><b></c></b></a>')\n        self.etree.clear_error_log()\n        try:\n            parse(f)\n            logs = None\n        except SyntaxError:\n            e = sys.exc_info()[1]\n            logs = e.error_log\n        f.close()\n        self.assertTrue([ log for log in logs\n                       if 'mismatch' in log.message ])\n        self.assertTrue([ log for log in logs\n                       if 'PARSER'   in log.domain_name])\n        self.assertTrue([ log for log in logs\n                       if 'ERR_TAG_NAME_MISMATCH' in log.type_name ])\n        self.assertTrue([ log for log in logs\n                       if 1 == log.line ])\n        self.assertTrue([ log for log in logs\n                       if 15 == log.column ])\n\n    def _test_python_error_logging(self):\n        \"\"\"This can't really be tested as long as there isn't a way to\n        reset the logging setup ...\n        \"\"\"\n        parse = self.etree.parse\n\n        messages = []\n        class Logger(self.etree.PyErrorLog):\n            def log(self, entry, message, *args):\n                messages.append(message)\n\n        self.etree.use_global_python_log(Logger())\n        f = BytesIO('<a><b></c></b></a>')\n        try:\n            parse(f)\n        except SyntaxError:\n            pass\n        f.close()\n\n        self.assertTrue([ message for message in messages\n                       if 'mismatch' in message ])\n        self.assertTrue([ message for message in messages\n                       if ':PARSER:'   in message])\n        self.assertTrue([ message for message in messages\n                       if ':ERR_TAG_NAME_MISMATCH:' in message ])\n        self.assertTrue([ message for message in messages\n                       if ':1:15:' in message ])\n\n\nclass XMLPullParserTest(unittest.TestCase):\n    etree = etree\n\n    def assert_event_tags(self, events, expected):\n        self.assertEqual([(action, elem.tag) for action, elem in events],\n                         expected)\n\n    def test_pull_from_simple_target(self):\n        class Target(object):\n            def start(self, tag, attrib):\n                return 'start(%s)' % tag\n            def end(self, tag):\n                return 'end(%s)' % tag\n            def close(self):\n                return 'close()'\n\n        parser = self.etree.XMLPullParser(target=Target())\n        events = parser.read_events()\n\n        parser.feed('<root><element>')\n        self.assertFalse(list(events))\n        self.assertFalse(list(events))\n        parser.feed('</element><child>')\n        self.assertEqual([('end', 'end(element)')], list(events))\n        parser.feed('</child>')\n        self.assertEqual([('end', 'end(child)')], list(events))\n        parser.feed('</root>')\n        self.assertEqual([('end', 'end(root)')], list(events))\n        self.assertFalse(list(events))\n        self.assertEqual('close()', parser.close())\n\n    def test_pull_from_simple_target_start_end(self):\n        class Target(object):\n            def start(self, tag, attrib):\n                return 'start(%s)' % tag\n            def end(self, tag):\n                return 'end(%s)' % tag\n            def close(self):\n                return 'close()'\n\n        parser = self.etree.XMLPullParser(\n            ['start', 'end'], target=Target())\n        events = parser.read_events()\n\n        parser.feed('<root><element>')\n        self.assertEqual(\n            [('start', 'start(root)'), ('start', 'start(element)')],\n            list(events))\n        self.assertFalse(list(events))\n        parser.feed('</element><child>')\n        self.assertEqual(\n            [('end', 'end(element)'), ('start', 'start(child)')],\n            list(events))\n        parser.feed('</child>')\n        self.assertEqual(\n            [('end', 'end(child)')],\n            list(events))\n        parser.feed('</root>')\n        self.assertEqual(\n            [('end', 'end(root)')],\n            list(events))\n        self.assertFalse(list(events))\n        self.assertEqual('close()', parser.close())\n\n    def test_pull_from_tree_builder(self):\n        parser = self.etree.XMLPullParser(\n            ['start', 'end'], target=etree.TreeBuilder())\n        events = parser.read_events()\n\n        parser.feed('<root><element>')\n        self.assert_event_tags(\n            events, [('start', 'root'), ('start', 'element')])\n        self.assertFalse(list(events))\n        parser.feed('</element><child>')\n        self.assert_event_tags(\n            events, [('end', 'element'), ('start', 'child')])\n        parser.feed('</child>')\n        self.assert_event_tags(\n            events, [('end', 'child')])\n        parser.feed('</root>')\n        self.assert_event_tags(\n            events, [('end', 'root')])\n        self.assertFalse(list(events))\n        root = parser.close()\n        self.assertEqual('root', root.tag)\n\n    def test_pull_from_tree_builder_subclass(self):\n        class Target(etree.TreeBuilder):\n            def end(self, tag):\n                el = super(Target, self).end(tag)\n                el.tag += '-huhu'\n                return el\n\n        parser = self.etree.XMLPullParser(\n            ['start', 'end'], target=Target())\n        events = parser.read_events()\n\n        parser.feed('<root><element>')\n        self.assert_event_tags(\n            events, [('start', 'root'), ('start', 'element')])\n        self.assertFalse(list(events))\n        parser.feed('</element><child>')\n        self.assert_event_tags(\n            events, [('end', 'element-huhu'), ('start', 'child')])\n        parser.feed('</child>')\n        self.assert_event_tags(\n            events, [('end', 'child-huhu')])\n        parser.feed('</root>')\n        self.assert_event_tags(\n            events, [('end', 'root-huhu')])\n        self.assertFalse(list(events))\n        root = parser.close()\n        self.assertEqual('root-huhu', root.tag)\n\n\ndef test_suite():\n    suite = unittest.TestSuite()\n    suite.addTests([unittest.makeSuite(ETreeOnlyTestCase)])\n    suite.addTests([unittest.makeSuite(ETreeXIncludeTestCase)])\n    suite.addTests([unittest.makeSuite(ElementIncludeTestCase)])\n    suite.addTests([unittest.makeSuite(ETreeC14NTestCase)])\n    suite.addTests([unittest.makeSuite(ETreeWriteTestCase)])\n    suite.addTests([unittest.makeSuite(ETreeErrorLogTest)])\n    suite.addTests([unittest.makeSuite(XMLPullParserTest)])\n\n    # add original doctests from ElementTree selftest modules\n    from . import selftest, selftest2\n    suite.addTests(doctest.DocTestSuite(selftest))\n    suite.addTests(doctest.DocTestSuite(selftest2))\n\n    # add doctests\n    suite.addTests(doctest.DocTestSuite(etree))\n    suite.addTests(\n        [make_doctest('../../../doc/tutorial.txt')])\n    suite.addTests(\n        [make_doctest('../../../doc/api.txt')])\n    suite.addTests(\n        [make_doctest('../../../doc/FAQ.txt')])\n    suite.addTests(\n        [make_doctest('../../../doc/parsing.txt')])\n    suite.addTests(\n        [make_doctest('../../../doc/resolvers.txt')])\n    return suite\n\n\nif __name__ == '__main__':\n    print('to test use test.py %s' % __file__)\n"], "fixing_code": ["# Private/public helper functions for API functions\n\nfrom lxml.includes cimport uri\n\n\ncdef void displayNode(xmlNode* c_node, indent):\n    # to help with debugging\n    cdef xmlNode* c_child\n    try:\n        print indent * u' ', <long>c_node\n        c_child = c_node.children\n        while c_child is not NULL:\n            displayNode(c_child, indent + 1)\n            c_child = c_child.next\n    finally:\n        return  # swallow any exceptions\n\ncdef inline int _assertValidNode(_Element element) except -1:\n    assert element._c_node is not NULL, u\"invalid Element proxy at %s\" % id(element)\n\ncdef inline int _assertValidDoc(_Document doc) except -1:\n    assert doc._c_doc is not NULL, u\"invalid Document proxy at %s\" % id(doc)\n\ncdef _Document _documentOrRaise(object input):\n    u\"\"\"Call this to get the document of a _Document, _ElementTree or _Element\n    object, or to raise an exception if it can't be determined.\n\n    Should be used in all API functions for consistency.\n    \"\"\"\n    cdef _Document doc\n    if isinstance(input, _ElementTree):\n        if (<_ElementTree>input)._context_node is not None:\n            doc = (<_ElementTree>input)._context_node._doc\n        else:\n            doc = None\n    elif isinstance(input, _Element):\n        doc = (<_Element>input)._doc\n    elif isinstance(input, _Document):\n        doc = <_Document>input\n    else:\n        raise TypeError, f\"Invalid input object: {python._fqtypename(input).decode('utf8')}\"\n    if doc is None:\n        raise ValueError, f\"Input object has no document: {python._fqtypename(input).decode('utf8')}\"\n    _assertValidDoc(doc)\n    return doc\n\ncdef _Element _rootNodeOrRaise(object input):\n    u\"\"\"Call this to get the root node of a _Document, _ElementTree or\n     _Element object, or to raise an exception if it can't be determined.\n\n    Should be used in all API functions for consistency.\n     \"\"\"\n    cdef _Element node\n    if isinstance(input, _ElementTree):\n        node = (<_ElementTree>input)._context_node\n    elif isinstance(input, _Element):\n        node = <_Element>input\n    elif isinstance(input, _Document):\n        node = (<_Document>input).getroot()\n    else:\n        raise TypeError, f\"Invalid input object: {python._fqtypename(input).decode('utf8')}\"\n    if (node is None or not node._c_node or\n            node._c_node.type != tree.XML_ELEMENT_NODE):\n        raise ValueError, f\"Input object is not an XML element: {python._fqtypename(input).decode('utf8')}\"\n    _assertValidNode(node)\n    return node\n\ncdef bint _isAncestorOrSame(xmlNode* c_ancestor, xmlNode* c_node):\n    while c_node:\n        if c_node is c_ancestor:\n            return True\n        c_node = c_node.parent\n    return False\n\ncdef _Element _makeElement(tag, xmlDoc* c_doc, _Document doc,\n                           _BaseParser parser, text, tail, attrib, nsmap,\n                           dict extra_attrs):\n    u\"\"\"Create a new element and initialize text content, namespaces and\n    attributes.\n\n    This helper function will reuse as much of the existing document as\n    possible:\n\n    If 'parser' is None, the parser will be inherited from 'doc' or the\n    default parser will be used.\n\n    If 'doc' is None, 'c_doc' is used to create a new _Document and the new\n    element is made its root node.\n\n    If 'c_doc' is also NULL, a new xmlDoc will be created.\n    \"\"\"\n    cdef xmlNode* c_node\n    if doc is not None:\n        c_doc = doc._c_doc\n    ns_utf, name_utf = _getNsTag(tag)\n    if parser is not None and parser._for_html:\n        _htmlTagValidOrRaise(name_utf)\n        if c_doc is NULL:\n            c_doc = _newHTMLDoc()\n    else:\n        _tagValidOrRaise(name_utf)\n        if c_doc is NULL:\n            c_doc = _newXMLDoc()\n    c_node = _createElement(c_doc, name_utf)\n    if c_node is NULL:\n        if doc is None and c_doc is not NULL:\n            tree.xmlFreeDoc(c_doc)\n        raise MemoryError()\n    try:\n        if doc is None:\n            tree.xmlDocSetRootElement(c_doc, c_node)\n            doc = _documentFactory(c_doc, parser)\n        if text is not None:\n            _setNodeText(c_node, text)\n        if tail is not None:\n            _setTailText(c_node, tail)\n        # add namespaces to node if necessary\n        _setNodeNamespaces(c_node, doc, ns_utf, nsmap)\n        _initNodeAttributes(c_node, doc, attrib, extra_attrs)\n        return _elementFactory(doc, c_node)\n    except:\n        # free allocated c_node/c_doc unless Python does it for us\n        if c_node.doc is not c_doc:\n            # node not yet in document => will not be freed by document\n            if tail is not None:\n                _removeText(c_node.next) # tail\n            tree.xmlFreeNode(c_node)\n        if doc is None:\n            # c_doc will not be freed by doc\n            tree.xmlFreeDoc(c_doc)\n        raise\n\ncdef int _initNewElement(_Element element, bint is_html, name_utf, ns_utf,\n                         _BaseParser parser, attrib, nsmap, dict extra_attrs) except -1:\n    u\"\"\"Initialise a new Element object.\n\n    This is used when users instantiate a Python Element subclass\n    directly, without it being mapped to an existing XML node.\n    \"\"\"\n    cdef xmlDoc* c_doc\n    cdef xmlNode* c_node\n    cdef _Document doc\n    if is_html:\n        _htmlTagValidOrRaise(name_utf)\n        c_doc = _newHTMLDoc()\n    else:\n        _tagValidOrRaise(name_utf)\n        c_doc = _newXMLDoc()\n    c_node = _createElement(c_doc, name_utf)\n    if c_node is NULL:\n        if c_doc is not NULL:\n            tree.xmlFreeDoc(c_doc)\n        raise MemoryError()\n    tree.xmlDocSetRootElement(c_doc, c_node)\n    doc = _documentFactory(c_doc, parser)\n    # add namespaces to node if necessary\n    _setNodeNamespaces(c_node, doc, ns_utf, nsmap)\n    _initNodeAttributes(c_node, doc, attrib, extra_attrs)\n    _registerProxy(element, doc, c_node)\n    element._init()\n    return 0\n\ncdef _Element _makeSubElement(_Element parent, tag, text, tail,\n                              attrib, nsmap, dict extra_attrs):\n    u\"\"\"Create a new child element and initialize text content, namespaces and\n    attributes.\n    \"\"\"\n    cdef xmlNode* c_node\n    cdef xmlDoc* c_doc\n    if parent is None or parent._doc is None:\n        return None\n    _assertValidNode(parent)\n    ns_utf, name_utf = _getNsTag(tag)\n    c_doc = parent._doc._c_doc\n\n    if parent._doc._parser is not None and parent._doc._parser._for_html:\n        _htmlTagValidOrRaise(name_utf)\n    else:\n        _tagValidOrRaise(name_utf)\n\n    c_node = _createElement(c_doc, name_utf)\n    if c_node is NULL:\n        raise MemoryError()\n    tree.xmlAddChild(parent._c_node, c_node)\n\n    try:\n        if text is not None:\n            _setNodeText(c_node, text)\n        if tail is not None:\n            _setTailText(c_node, tail)\n\n        # add namespaces to node if necessary\n        _setNodeNamespaces(c_node, parent._doc, ns_utf, nsmap)\n        _initNodeAttributes(c_node, parent._doc, attrib, extra_attrs)\n        return _elementFactory(parent._doc, c_node)\n    except:\n        # make sure we clean up in case of an error\n        _removeNode(parent._doc, c_node)\n        raise\n\n\ncdef int _setNodeNamespaces(xmlNode* c_node, _Document doc,\n                            object node_ns_utf, object nsmap) except -1:\n    u\"\"\"Lookup current namespace prefixes, then set namespace structure for\n    node (if 'node_ns_utf' was provided) and register new ns-prefix mappings.\n\n    'node_ns_utf' should only be passed for a newly created node.\n    \"\"\"\n    cdef xmlNs* c_ns\n    cdef list nsdefs\n\n    if nsmap:\n        for prefix, href in _iter_nsmap(nsmap):\n            href_utf = _utf8(href)\n            _uriValidOrRaise(href_utf)\n            c_href = _xcstr(href_utf)\n            if prefix is not None:\n                prefix_utf = _utf8(prefix)\n                _prefixValidOrRaise(prefix_utf)\n                c_prefix = _xcstr(prefix_utf)\n            else:\n                c_prefix = <const_xmlChar*>NULL\n            # add namespace with prefix if it is not already known\n            c_ns = tree.xmlSearchNs(doc._c_doc, c_node, c_prefix)\n            if c_ns is NULL or \\\n                    c_ns.href is NULL or \\\n                    tree.xmlStrcmp(c_ns.href, c_href) != 0:\n                c_ns = tree.xmlNewNs(c_node, c_href, c_prefix)\n            if href_utf == node_ns_utf:\n                tree.xmlSetNs(c_node, c_ns)\n                node_ns_utf = None\n\n    if node_ns_utf is not None:\n        _uriValidOrRaise(node_ns_utf)\n        doc._setNodeNs(c_node, _xcstr(node_ns_utf))\n    return 0\n\n\ncdef dict _build_nsmap(xmlNode* c_node):\n    \"\"\"\n    Namespace prefix->URI mapping known in the context of this Element.\n    This includes all namespace declarations of the parents.\n    \"\"\"\n    cdef xmlNs* c_ns\n    nsmap = {}\n    while c_node is not NULL and c_node.type == tree.XML_ELEMENT_NODE:\n        c_ns = c_node.nsDef\n        while c_ns is not NULL:\n            if c_ns.prefix or c_ns.href:\n                prefix = funicodeOrNone(c_ns.prefix)\n                if prefix not in nsmap:\n                    nsmap[prefix] = funicodeOrNone(c_ns.href)\n            c_ns = c_ns.next\n        c_node = c_node.parent\n    return nsmap\n\n\ncdef _iter_nsmap(nsmap):\n    \"\"\"\n    Create a reproducibly ordered iterable from an nsmap mapping.\n    Tries to preserve an existing order and sorts if it assumes no order.\n\n    The difference to _iter_attrib() is that None doesn't sort with strings\n    in Py3.x.\n    \"\"\"\n    if python.PY_VERSION_HEX >= 0x03060000:\n        # dicts are insertion-ordered in Py3.6+ => keep the user provided order.\n        if isinstance(nsmap, dict):\n            return nsmap.items()\n    if len(nsmap) <= 1:\n        return nsmap.items()\n    # nsmap will usually be a plain unordered dict => avoid type checking overhead\n    if type(nsmap) is not dict and isinstance(nsmap, OrderedDict):\n        return nsmap.items()  # keep existing order\n    if None not in nsmap:\n        return sorted(nsmap.items())\n\n    # Move the default namespace to the end.  This makes sure libxml2\n    # prefers a prefix if the ns is defined redundantly on the same\n    # element.  That way, users can work around a problem themselves\n    # where default namespace attributes on non-default namespaced\n    # elements serialise without prefix (i.e. into the non-default\n    # namespace).\n    default_ns = nsmap[None]\n    nsdefs = [(k, v) for k, v in nsmap.items() if k is not None]\n    nsdefs.sort()\n    nsdefs.append((None, default_ns))\n    return nsdefs\n\n\ncdef _iter_attrib(attrib):\n    \"\"\"\n    Create a reproducibly ordered iterable from an attrib mapping.\n    Tries to preserve an existing order and sorts if it assumes no order.\n    \"\"\"\n    # dicts are insertion-ordered in Py3.6+ => keep the user provided order.\n    if python.PY_VERSION_HEX >= 0x03060000 and isinstance(attrib, dict) or (\n            isinstance(attrib, (_Attrib, OrderedDict))):\n        return attrib.items()\n    # assume it's an unordered mapping of some kind\n    return sorted(attrib.items())\n\n\ncdef _initNodeAttributes(xmlNode* c_node, _Document doc, attrib, dict extra):\n    u\"\"\"Initialise the attributes of an element node.\n    \"\"\"\n    cdef bint is_html\n    cdef xmlNs* c_ns\n    if attrib is not None and not hasattr(attrib, u'items'):\n        raise TypeError, f\"Invalid attribute dictionary: {python._fqtypename(attrib).decode('utf8')}\"\n    if not attrib and not extra:\n        return  # nothing to do\n    is_html = doc._parser._for_html\n    seen = set()\n    if extra:\n        if python.PY_VERSION_HEX >= 0x03060000:\n            for name, value in extra.items():\n                _addAttributeToNode(c_node, doc, is_html, name, value, seen)\n        else:\n            for name, value in sorted(extra.items()):\n                _addAttributeToNode(c_node, doc, is_html, name, value, seen)\n    if attrib:\n        for name, value in _iter_attrib(attrib):\n            _addAttributeToNode(c_node, doc, is_html, name, value, seen)\n\n\ncdef int _addAttributeToNode(xmlNode* c_node, _Document doc, bint is_html,\n                             name, value, set seen_tags) except -1:\n    ns_utf, name_utf = tag = _getNsTag(name)\n    if tag in seen_tags:\n        return 0\n    seen_tags.add(tag)\n    if not is_html:\n        _attributeValidOrRaise(name_utf)\n    value_utf = _utf8(value)\n    if ns_utf is None:\n        tree.xmlNewProp(c_node, _xcstr(name_utf), _xcstr(value_utf))\n    else:\n        _uriValidOrRaise(ns_utf)\n        c_ns = doc._findOrBuildNodeNs(c_node, _xcstr(ns_utf), NULL, 1)\n        tree.xmlNewNsProp(c_node, c_ns,\n                          _xcstr(name_utf), _xcstr(value_utf))\n    return 0\n\n\nctypedef struct _ns_node_ref:\n    xmlNs* ns\n    xmlNode* node\n\n\ncdef int _collectNsDefs(xmlNode* c_element, _ns_node_ref **_c_ns_list,\n                        size_t *_c_ns_list_len, size_t *_c_ns_list_size) except -1:\n    c_ns_list = _c_ns_list[0]\n    cdef size_t c_ns_list_len = _c_ns_list_len[0]\n    cdef size_t c_ns_list_size = _c_ns_list_size[0]\n\n    c_nsdef = c_element.nsDef\n    while c_nsdef is not NULL:\n        if c_ns_list_len >= c_ns_list_size:\n            if c_ns_list is NULL:\n                c_ns_list_size = 20\n            else:\n                c_ns_list_size *= 2\n            c_nsref_ptr = <_ns_node_ref*> python.lxml_realloc(\n                c_ns_list, c_ns_list_size, sizeof(_ns_node_ref))\n            if c_nsref_ptr is NULL:\n                if c_ns_list is not NULL:\n                    python.lxml_free(c_ns_list)\n                    _c_ns_list[0] = NULL\n                raise MemoryError()\n            c_ns_list = c_nsref_ptr\n\n        c_ns_list[c_ns_list_len] = _ns_node_ref(c_nsdef, c_element)\n        c_ns_list_len += 1\n        c_nsdef = c_nsdef.next\n\n    _c_ns_list_size[0] = c_ns_list_size\n    _c_ns_list_len[0] = c_ns_list_len\n    _c_ns_list[0] = c_ns_list\n\n\ncdef int _removeUnusedNamespaceDeclarations(xmlNode* c_element, set prefixes_to_keep) except -1:\n    u\"\"\"Remove any namespace declarations from a subtree that are not used by\n    any of its elements (or attributes).\n\n    If a 'prefixes_to_keep' is provided, it must be a set of prefixes.\n    Any corresponding namespace mappings will not be removed as part of the cleanup.\n    \"\"\"\n    cdef xmlNode* c_node\n    cdef _ns_node_ref* c_ns_list = NULL\n    cdef size_t c_ns_list_size = 0\n    cdef size_t c_ns_list_len = 0\n    cdef size_t i\n\n    if c_element.parent and c_element.parent.type == tree.XML_DOCUMENT_NODE:\n        # include declarations on the document node\n        _collectNsDefs(c_element.parent, &c_ns_list, &c_ns_list_len, &c_ns_list_size)\n\n    tree.BEGIN_FOR_EACH_ELEMENT_FROM(c_element, c_element, 1)\n    # collect all new namespace declarations into the ns list\n    if c_element.nsDef:\n        _collectNsDefs(c_element, &c_ns_list, &c_ns_list_len, &c_ns_list_size)\n\n    # remove all namespace declarations from the list that are referenced\n    if c_ns_list_len and c_element.type == tree.XML_ELEMENT_NODE:\n        c_node = c_element\n        while c_node and c_ns_list_len:\n            if c_node.ns:\n                for i in range(c_ns_list_len):\n                    if c_node.ns is c_ns_list[i].ns:\n                        c_ns_list_len -= 1\n                        c_ns_list[i] = c_ns_list[c_ns_list_len]\n                        #c_ns_list[c_ns_list_len] = _ns_node_ref(NULL, NULL)\n                        break\n            if c_node is c_element:\n                # continue with attributes\n                c_node = <xmlNode*>c_element.properties\n            else:\n                c_node = c_node.next\n    tree.END_FOR_EACH_ELEMENT_FROM(c_element)\n\n    if c_ns_list is NULL:\n        return 0\n\n    # free all namespace declarations that remained in the list,\n    # except for those we should keep explicitly\n    cdef xmlNs* c_nsdef\n    for i in range(c_ns_list_len):\n        if prefixes_to_keep is not None:\n            if c_ns_list[i].ns.prefix and c_ns_list[i].ns.prefix in prefixes_to_keep:\n                continue\n        c_node = c_ns_list[i].node\n        c_nsdef = c_node.nsDef\n        if c_nsdef is c_ns_list[i].ns:\n            c_node.nsDef = c_node.nsDef.next\n        else:\n            while c_nsdef.next is not c_ns_list[i].ns:\n                c_nsdef = c_nsdef.next\n            c_nsdef.next = c_nsdef.next.next\n        tree.xmlFreeNs(c_ns_list[i].ns)\n    \n    if c_ns_list is not NULL:\n        python.lxml_free(c_ns_list)\n    return 0\n\ncdef xmlNs* _searchNsByHref(xmlNode* c_node, const_xmlChar* c_href, bint is_attribute):\n    u\"\"\"Search a namespace declaration that covers a node (element or\n    attribute).\n\n    For attributes, try to find a prefixed namespace declaration\n    instead of the default namespaces.  This helps in supporting\n    round-trips for attributes on elements with a different namespace.\n    \"\"\"\n    cdef xmlNs* c_ns\n    cdef xmlNs* c_default_ns = NULL\n    cdef xmlNode* c_element\n    if c_href is NULL or c_node is NULL or c_node.type == tree.XML_ENTITY_REF_NODE:\n        return NULL\n    if tree.xmlStrcmp(c_href, tree.XML_XML_NAMESPACE) == 0:\n        # no special cases here, let libxml2 handle this\n        return tree.xmlSearchNsByHref(c_node.doc, c_node, c_href)\n    if c_node.type == tree.XML_ATTRIBUTE_NODE:\n        is_attribute = 1\n    while c_node is not NULL and c_node.type != tree.XML_ELEMENT_NODE:\n        c_node = c_node.parent\n    c_element = c_node\n    while c_node is not NULL:\n        if c_node.type == tree.XML_ELEMENT_NODE:\n            c_ns = c_node.nsDef\n            while c_ns is not NULL:\n                if c_ns.href is not NULL and tree.xmlStrcmp(c_href, c_ns.href) == 0:\n                    if c_ns.prefix is NULL and is_attribute:\n                        # for attributes, continue searching a named\n                        # prefix, but keep the first default namespace\n                        # declaration that we found\n                        if c_default_ns is NULL:\n                            c_default_ns = c_ns\n                    elif tree.xmlSearchNs(\n                        c_element.doc, c_element, c_ns.prefix) is c_ns:\n                        # start node is in namespace scope => found!\n                        return c_ns\n                c_ns = c_ns.next\n            if c_node is not c_element and c_node.ns is not NULL:\n                # optimise: the node may have the namespace itself\n                c_ns = c_node.ns\n                if c_ns.href is not NULL and tree.xmlStrcmp(c_href, c_ns.href) == 0:\n                    if c_ns.prefix is NULL and is_attribute:\n                        # for attributes, continue searching a named\n                        # prefix, but keep the first default namespace\n                        # declaration that we found\n                        if c_default_ns is NULL:\n                            c_default_ns = c_ns\n                    elif tree.xmlSearchNs(\n                        c_element.doc, c_element, c_ns.prefix) is c_ns:\n                        # start node is in namespace scope => found!\n                        return c_ns\n        c_node = c_node.parent\n    # nothing found => use a matching default namespace or fail\n    if c_default_ns is not NULL:\n        if tree.xmlSearchNs(c_element.doc, c_element, NULL) is c_default_ns:\n            return c_default_ns\n    return NULL\n\ncdef int _replaceNodeByChildren(_Document doc, xmlNode* c_node) except -1:\n    # NOTE: this does not deallocate the node, just unlink it!\n    cdef xmlNode* c_parent\n    cdef xmlNode* c_child\n    if c_node.children is NULL:\n        tree.xmlUnlinkNode(c_node)\n        return 0\n\n    c_parent = c_node.parent\n    # fix parent links of children\n    c_child = c_node.children\n    while c_child is not NULL:\n        c_child.parent = c_parent\n        c_child = c_child.next\n\n    # fix namespace references of children if their parent's namespace\n    # declarations get lost\n    if c_node.nsDef is not NULL:\n        c_child = c_node.children\n        while c_child is not NULL:\n            moveNodeToDocument(doc, doc._c_doc, c_child)\n            c_child = c_child.next\n\n    # fix sibling links to/from child slice\n    if c_node.prev is NULL:\n        c_parent.children = c_node.children\n    else:\n        c_node.prev.next = c_node.children\n        c_node.children.prev = c_node.prev\n    if c_node.next is NULL:\n        c_parent.last = c_node.last\n    else:\n        c_node.next.prev = c_node.last\n        c_node.last.next = c_node.next\n\n    # unlink c_node\n    c_node.children = c_node.last = NULL\n    c_node.parent = c_node.next = c_node.prev = NULL\n    return 0\n\ncdef object _attributeValue(xmlNode* c_element, xmlAttr* c_attrib_node):\n    c_href = _getNs(<xmlNode*>c_attrib_node)\n    value = tree.xmlGetNsProp(c_element, c_attrib_node.name, c_href)\n    try:\n        result = funicode(value)\n    finally:\n        tree.xmlFree(value)\n    return result\n\ncdef object _attributeValueFromNsName(xmlNode* c_element,\n                                      const_xmlChar* c_href, const_xmlChar* c_name):\n    c_result = tree.xmlGetNsProp(c_element, c_name, c_href)\n    if c_result is NULL:\n        return None\n    try:\n        result = funicode(c_result)\n    finally:\n        tree.xmlFree(c_result)\n    return result\n\ncdef object _getNodeAttributeValue(xmlNode* c_node, key, default):\n    ns, tag = _getNsTag(key)\n    c_href = <const_xmlChar*>NULL if ns is None else _xcstr(ns)\n    c_result = tree.xmlGetNsProp(c_node, _xcstr(tag), c_href)\n    if c_result is NULL:\n        # XXX free namespace that is not in use..?\n        return default\n    try:\n        result = funicode(c_result)\n    finally:\n        tree.xmlFree(c_result)\n    return result\n\ncdef inline object _getAttributeValue(_Element element, key, default):\n    return _getNodeAttributeValue(element._c_node, key, default)\n\ncdef int _setAttributeValue(_Element element, key, value) except -1:\n    cdef const_xmlChar* c_value\n    cdef xmlNs* c_ns\n    ns, tag = _getNsTag(key)\n    is_html = element._doc._parser._for_html\n    if not is_html:\n        _attributeValidOrRaise(tag)\n    c_tag = _xcstr(tag)\n    if value is None and is_html:\n        c_value = NULL\n    else:\n        if isinstance(value, QName):\n            value = _resolveQNameText(element, value)\n        else:\n            value = _utf8(value)\n        c_value = _xcstr(value)\n    if ns is None:\n        c_ns = NULL\n    else:\n        c_ns = element._doc._findOrBuildNodeNs(element._c_node, _xcstr(ns), NULL, 1)\n    tree.xmlSetNsProp(element._c_node, c_ns, c_tag, c_value)\n    return 0\n\ncdef int _delAttribute(_Element element, key) except -1:\n    ns, tag = _getNsTag(key)\n    c_href = <const_xmlChar*>NULL if ns is None else _xcstr(ns)\n    if _delAttributeFromNsName(element._c_node, c_href, _xcstr(tag)):\n        raise KeyError, key\n    return 0\n\ncdef int _delAttributeFromNsName(xmlNode* c_node, const_xmlChar* c_href, const_xmlChar* c_name):\n    c_attr = tree.xmlHasNsProp(c_node, c_name, c_href)\n    if c_attr is NULL:\n        # XXX free namespace that is not in use..?\n        return -1\n    tree.xmlRemoveProp(c_attr)\n    return 0\n\ncdef list _collectAttributes(xmlNode* c_node, int collecttype):\n    u\"\"\"Collect all attributes of a node in a list.  Depending on collecttype,\n    it collects either the name (1), the value (2) or the name-value tuples.\n    \"\"\"\n    cdef Py_ssize_t count\n    c_attr = c_node.properties\n    count = 0\n    while c_attr is not NULL:\n        if c_attr.type == tree.XML_ATTRIBUTE_NODE:\n            count += 1\n        c_attr = c_attr.next\n\n    if not count:\n        return []\n\n    attributes = [None] * count\n    c_attr = c_node.properties\n    count = 0\n    while c_attr is not NULL:\n        if c_attr.type == tree.XML_ATTRIBUTE_NODE:\n            if collecttype == 1:\n                item = _namespacedName(<xmlNode*>c_attr)\n            elif collecttype == 2:\n                item = _attributeValue(c_node, c_attr)\n            else:\n                item = (_namespacedName(<xmlNode*>c_attr),\n                        _attributeValue(c_node, c_attr))\n            attributes[count] = item\n            count += 1\n        c_attr = c_attr.next\n    return attributes\n\ncdef object __RE_XML_ENCODING = re.compile(\n    ur'^(<\\?xml[^>]+)\\s+encoding\\s*=\\s*[\"\\'][^\"\\']*[\"\\'](\\s*\\?>|)', re.U)\n\ncdef object __REPLACE_XML_ENCODING = __RE_XML_ENCODING.sub\ncdef object __HAS_XML_ENCODING = __RE_XML_ENCODING.match\n\ncdef object _stripEncodingDeclaration(object xml_string):\n    # this is a hack to remove the XML encoding declaration from unicode\n    return __REPLACE_XML_ENCODING(ur'\\g<1>\\g<2>', xml_string)\n\ncdef bint _hasEncodingDeclaration(object xml_string) except -1:\n    # check if a (unicode) string has an XML encoding declaration\n    return __HAS_XML_ENCODING(xml_string) is not None\n\ncdef inline bint _hasText(xmlNode* c_node):\n    return c_node is not NULL and _textNodeOrSkip(c_node.children) is not NULL\n\ncdef inline bint _hasTail(xmlNode* c_node):\n    return c_node is not NULL and _textNodeOrSkip(c_node.next) is not NULL\n\ncdef inline bint _hasNonWhitespaceTail(xmlNode* c_node):\n    return _hasNonWhitespaceText(c_node, tail=True)\n\ncdef bint _hasNonWhitespaceText(xmlNode* c_node, bint tail=False):\n    c_text_node = c_node and _textNodeOrSkip(c_node.next if tail else c_node.children)\n    if c_text_node is NULL:\n        return False\n    while c_text_node is not NULL:\n        if c_text_node.content[0] != c'\\0' and not _collectText(c_text_node).isspace():\n            return True\n        c_text_node = _textNodeOrSkip(c_text_node.next)\n    return False\n\ncdef _collectText(xmlNode* c_node):\n    u\"\"\"Collect all text nodes and return them as a unicode string.\n\n    Start collecting at c_node.\n    \n    If there was no text to collect, return None\n    \"\"\"\n    cdef Py_ssize_t scount\n    cdef xmlChar* c_text\n    cdef xmlNode* c_node_cur\n    # check for multiple text nodes\n    scount = 0\n    c_text = NULL\n    c_node_cur = c_node = _textNodeOrSkip(c_node)\n    while c_node_cur is not NULL:\n        if c_node_cur.content[0] != c'\\0':\n            c_text = c_node_cur.content\n        scount += 1\n        c_node_cur = _textNodeOrSkip(c_node_cur.next)\n\n    # handle two most common cases first\n    if c_text is NULL:\n        return '' if scount > 0 else None\n    if scount == 1:\n        return funicode(c_text)\n\n    # the rest is not performance critical anymore\n    result = b''\n    while c_node is not NULL:\n        result += <unsigned char*>c_node.content\n        c_node = _textNodeOrSkip(c_node.next)\n    return funicode(<const_xmlChar*><unsigned char*>result)\n\ncdef void _removeText(xmlNode* c_node):\n    u\"\"\"Remove all text nodes.\n\n    Start removing at c_node.\n    \"\"\"\n    cdef xmlNode* c_next\n    c_node = _textNodeOrSkip(c_node)\n    while c_node is not NULL:\n        c_next = _textNodeOrSkip(c_node.next)\n        tree.xmlUnlinkNode(c_node)\n        tree.xmlFreeNode(c_node)\n        c_node = c_next\n\ncdef xmlNode* _createTextNode(xmlDoc* doc, value) except NULL:\n    cdef xmlNode* c_text_node\n    if isinstance(value, CDATA):\n        c_text_node = tree.xmlNewCDataBlock(\n            doc, _xcstr((<CDATA>value)._utf8_data),\n            python.PyBytes_GET_SIZE((<CDATA>value)._utf8_data))\n    else:\n        text = _utf8(value)\n        c_text_node = tree.xmlNewDocText(doc, _xcstr(text))\n    if not c_text_node:\n        raise MemoryError()\n    return c_text_node\n\ncdef int _setNodeText(xmlNode* c_node, value) except -1:\n    # remove all text nodes at the start first\n    _removeText(c_node.children)\n    if value is None:\n        return 0\n    # now add new text node with value at start\n    c_text_node = _createTextNode(c_node.doc, value)\n    if c_node.children is NULL:\n        tree.xmlAddChild(c_node, c_text_node)\n    else:\n        tree.xmlAddPrevSibling(c_node.children, c_text_node)\n    return 0\n\ncdef int _setTailText(xmlNode* c_node, value) except -1:\n    # remove all text nodes at the start first\n    _removeText(c_node.next)\n    if value is None:\n        return 0\n    # now append new text node with value\n    c_text_node = _createTextNode(c_node.doc, value)\n    tree.xmlAddNextSibling(c_node, c_text_node)\n    return 0\n\ncdef bytes _resolveQNameText(_Element element, value):\n    cdef xmlNs* c_ns\n    ns, tag = _getNsTag(value)\n    if ns is None:\n        return tag\n    else:\n        c_ns = element._doc._findOrBuildNodeNs(\n            element._c_node, _xcstr(ns), NULL, 0)\n        return python.PyBytes_FromFormat('%s:%s', c_ns.prefix, _cstr(tag))\n\ncdef inline bint _hasChild(xmlNode* c_node):\n    return c_node is not NULL and _findChildForwards(c_node, 0) is not NULL\n\ncdef inline Py_ssize_t _countElements(xmlNode* c_node):\n    u\"Counts the elements within the following siblings and the node itself.\"\n    cdef Py_ssize_t count\n    count = 0\n    while c_node is not NULL:\n        if _isElement(c_node):\n            count += 1\n        c_node = c_node.next\n    return count\n\ncdef int _findChildSlice(\n    slice sliceobject, xmlNode* c_parent,\n    xmlNode** c_start_node, Py_ssize_t* c_step, Py_ssize_t* c_length) except -1:\n    u\"\"\"Resolve a children slice.\n\n    Returns the start node, step size and the slice length in the\n    pointer arguments.\n    \"\"\"\n    cdef Py_ssize_t start = 0, stop = 0, childcount\n    childcount = _countElements(c_parent.children)\n    if childcount == 0:\n        c_start_node[0] = NULL\n        c_length[0] = 0\n        if sliceobject.step is None:\n            c_step[0] = 1\n        else:\n            python._PyEval_SliceIndex(sliceobject.step, c_step)\n        return 0\n    python.PySlice_GetIndicesEx(\n        sliceobject, childcount, &start, &stop, c_step, c_length)\n    if start > childcount / 2:\n        c_start_node[0] = _findChildBackwards(c_parent, childcount - start - 1)\n    else:\n        c_start_node[0] = _findChild(c_parent, start)\n    return 0\n\ncdef bint _isFullSlice(slice sliceobject) except -1:\n    u\"\"\"Conservative guess if this slice is a full slice as in ``s[:]``.\n    \"\"\"\n    cdef Py_ssize_t step = 0\n    if sliceobject is None:\n        return 0\n    if sliceobject.start is None and \\\n            sliceobject.stop is None:\n        if sliceobject.step is None:\n            return 1\n        python._PyEval_SliceIndex(sliceobject.step, &step)\n        if step == 1:\n            return 1\n        return 0\n    return 0\n\ncdef _collectChildren(_Element element):\n    cdef xmlNode* c_node\n    cdef list result = []\n    c_node = element._c_node.children\n    if c_node is not NULL:\n        if not _isElement(c_node):\n            c_node = _nextElement(c_node)\n        while c_node is not NULL:\n            result.append(_elementFactory(element._doc, c_node))\n            c_node = _nextElement(c_node)\n    return result\n\ncdef inline xmlNode* _findChild(xmlNode* c_node, Py_ssize_t index):\n    if index < 0:\n        return _findChildBackwards(c_node, -index - 1)\n    else:\n        return _findChildForwards(c_node, index)\n    \ncdef inline xmlNode* _findChildForwards(xmlNode* c_node, Py_ssize_t index):\n    u\"\"\"Return child element of c_node with index, or return NULL if not found.\n    \"\"\"\n    cdef xmlNode* c_child\n    cdef Py_ssize_t c\n    c_child = c_node.children\n    c = 0\n    while c_child is not NULL:\n        if _isElement(c_child):\n            if c == index:\n                return c_child\n            c += 1\n        c_child = c_child.next\n    return NULL\n\ncdef inline xmlNode* _findChildBackwards(xmlNode* c_node, Py_ssize_t index):\n    u\"\"\"Return child element of c_node with index, or return NULL if not found.\n    Search from the end.\n    \"\"\"\n    cdef xmlNode* c_child\n    cdef Py_ssize_t c\n    c_child = c_node.last\n    c = 0\n    while c_child is not NULL:\n        if _isElement(c_child):\n            if c == index:\n                return c_child\n            c += 1\n        c_child = c_child.prev\n    return NULL\n    \ncdef inline xmlNode* _textNodeOrSkip(xmlNode* c_node) nogil:\n    u\"\"\"Return the node if it's a text node.  Skip over ignorable nodes in a\n    series of text nodes.  Return NULL if a non-ignorable node is found.\n\n    This is used to skip over XInclude nodes when collecting adjacent text\n    nodes.\n    \"\"\"\n    while c_node is not NULL:\n        if c_node.type == tree.XML_TEXT_NODE or \\\n               c_node.type == tree.XML_CDATA_SECTION_NODE:\n            return c_node\n        elif c_node.type == tree.XML_XINCLUDE_START or \\\n                 c_node.type == tree.XML_XINCLUDE_END:\n            c_node = c_node.next\n        else:\n            return NULL\n    return NULL\n\ncdef inline xmlNode* _nextElement(xmlNode* c_node):\n    u\"\"\"Given a node, find the next sibling that is an element.\n    \"\"\"\n    if c_node is NULL:\n        return NULL\n    c_node = c_node.next\n    while c_node is not NULL:\n        if _isElement(c_node):\n            return c_node\n        c_node = c_node.next\n    return NULL\n\ncdef inline xmlNode* _previousElement(xmlNode* c_node):\n    u\"\"\"Given a node, find the next sibling that is an element.\n    \"\"\"\n    if c_node is NULL:\n        return NULL\n    c_node = c_node.prev\n    while c_node is not NULL:\n        if _isElement(c_node):\n            return c_node\n        c_node = c_node.prev\n    return NULL\n\ncdef inline xmlNode* _parentElement(xmlNode* c_node):\n    u\"Given a node, find the parent element.\"\n    if c_node is NULL or not _isElement(c_node):\n        return NULL\n    c_node = c_node.parent\n    if c_node is NULL or not _isElement(c_node):\n        return NULL\n    return c_node\n\ncdef inline bint _tagMatches(xmlNode* c_node, const_xmlChar* c_href, const_xmlChar* c_name):\n    u\"\"\"Tests if the node matches namespace URI and tag name.\n\n    A node matches if it matches both c_href and c_name.\n\n    A node matches c_href if any of the following is true:\n    * c_href is NULL\n    * its namespace is NULL and c_href is the empty string\n    * its namespace string equals the c_href string\n\n    A node matches c_name if any of the following is true:\n    * c_name is NULL\n    * its name string equals the c_name string\n    \"\"\"\n    if c_node is NULL:\n        return 0\n    if c_node.type != tree.XML_ELEMENT_NODE:\n        # not an element, only succeed if we match everything\n        return c_name is NULL and c_href is NULL\n    if c_name is NULL:\n        if c_href is NULL:\n            # always match\n            return 1\n        else:\n            c_node_href = _getNs(c_node)\n            if c_node_href is NULL:\n                return c_href[0] == c'\\0'\n            else:\n                return tree.xmlStrcmp(c_node_href, c_href) == 0\n    elif c_href is NULL:\n        if _getNs(c_node) is not NULL:\n            return 0\n        return c_node.name == c_name or tree.xmlStrcmp(c_node.name, c_name) == 0\n    elif c_node.name == c_name or tree.xmlStrcmp(c_node.name, c_name) == 0:\n        c_node_href = _getNs(c_node)\n        if c_node_href is NULL:\n            return c_href[0] == c'\\0'\n        else:\n            return tree.xmlStrcmp(c_node_href, c_href) == 0\n    else:\n        return 0\n\ncdef inline bint _tagMatchesExactly(xmlNode* c_node, qname* c_qname):\n    u\"\"\"Tests if the node matches namespace URI and tag name.\n\n    This differs from _tagMatches() in that it does not consider a\n    NULL value in qname.href a wildcard, and that it expects the c_name\n    to be taken from the doc dict, i.e. it only compares the names by\n    address.\n\n    A node matches if it matches both href and c_name of the qname.\n\n    A node matches c_href if any of the following is true:\n    * its namespace is NULL and c_href is the empty string\n    * its namespace string equals the c_href string\n\n    A node matches c_name if any of the following is true:\n    * c_name is NULL\n    * its name string points to the same address (!) as c_name\n    \"\"\"\n    return _nsTagMatchesExactly(_getNs(c_node), c_node.name, c_qname)\n\ncdef inline bint _nsTagMatchesExactly(const_xmlChar* c_node_href,\n                                      const_xmlChar* c_node_name,\n                                      qname* c_qname):\n    u\"\"\"Tests if name and namespace URI match those of c_qname.\n\n    This differs from _tagMatches() in that it does not consider a\n    NULL value in qname.href a wildcard, and that it expects the c_name\n    to be taken from the doc dict, i.e. it only compares the names by\n    address.\n\n    A node matches if it matches both href and c_name of the qname.\n\n    A node matches c_href if any of the following is true:\n    * its namespace is NULL and c_href is the empty string\n    * its namespace string equals the c_href string\n\n    A node matches c_name if any of the following is true:\n    * c_name is NULL\n    * its name string points to the same address (!) as c_name\n    \"\"\"\n    cdef char* c_href\n    if c_qname.c_name is not NULL and c_qname.c_name is not c_node_name:\n        return 0\n    if c_qname.href is NULL:\n        return 1\n    c_href = python.__cstr(c_qname.href)\n    if c_href[0] == '\\0':\n        return c_node_href is NULL or c_node_href[0] == '\\0'\n    elif c_node_href is NULL:\n        return 0\n    else:\n        return tree.xmlStrcmp(<const_xmlChar*>c_href, c_node_href) == 0\n\ncdef Py_ssize_t _mapTagsToQnameMatchArray(xmlDoc* c_doc, list ns_tags,\n                                          qname* c_ns_tags, bint force_into_dict) except -1:\n    u\"\"\"Map a sequence of (name, namespace) pairs to a qname array for efficient\n    matching with _tagMatchesExactly() above.\n\n    Note that each qname struct in the array owns its href byte string object\n    if it is not NULL.\n    \"\"\"\n    cdef Py_ssize_t count = 0, i\n    cdef bytes ns, tag\n    for ns, tag in ns_tags:\n        if tag is None:\n            c_tag = <const_xmlChar*>NULL\n        elif force_into_dict:\n            c_tag = tree.xmlDictLookup(c_doc.dict, _xcstr(tag), len(tag))\n            if c_tag is NULL:\n                # clean up before raising the error\n                for i in xrange(count):\n                    cpython.ref.Py_XDECREF(c_ns_tags[i].href)\n                raise MemoryError()\n        else:\n            c_tag = tree.xmlDictExists(c_doc.dict, _xcstr(tag), len(tag))\n            if c_tag is NULL:\n                # not in the dict => not in the document\n                continue\n        c_ns_tags[count].c_name = c_tag\n        if ns is None:\n            c_ns_tags[count].href = NULL\n        else:\n            cpython.ref.Py_INCREF(ns) # keep an owned reference!\n            c_ns_tags[count].href = <python.PyObject*>ns\n        count += 1\n    return count\n\ncdef int _removeNode(_Document doc, xmlNode* c_node) except -1:\n    u\"\"\"Unlink and free a node and subnodes if possible.  Otherwise, make sure\n    it's self-contained.\n    \"\"\"\n    cdef xmlNode* c_next\n    c_next = c_node.next\n    tree.xmlUnlinkNode(c_node)\n    _moveTail(c_next, c_node)\n    if not attemptDeallocation(c_node):\n        # make namespaces absolute\n        moveNodeToDocument(doc, c_node.doc, c_node)\n    return 0\n\ncdef int _removeSiblings(xmlNode* c_element, tree.xmlElementType node_type, bint with_tail) except -1:\n    cdef xmlNode* c_node\n    cdef xmlNode* c_next\n    c_node = c_element.next\n    while c_node is not NULL:\n        c_next = _nextElement(c_node)\n        if c_node.type == node_type:\n            if with_tail:\n                _removeText(c_node.next)\n            tree.xmlUnlinkNode(c_node)\n            attemptDeallocation(c_node)\n        c_node = c_next\n    c_node = c_element.prev\n    while c_node is not NULL:\n        c_next = _previousElement(c_node)\n        if c_node.type == node_type:\n            if with_tail:\n                _removeText(c_node.next)\n            tree.xmlUnlinkNode(c_node)\n            attemptDeallocation(c_node)\n        c_node = c_next\n    return 0\n\ncdef void _moveTail(xmlNode* c_tail, xmlNode* c_target):\n    cdef xmlNode* c_next\n    # tail support: look for any text nodes trailing this node and \n    # move them too\n    c_tail = _textNodeOrSkip(c_tail)\n    while c_tail is not NULL:\n        c_next = _textNodeOrSkip(c_tail.next)\n        c_target = tree.xmlAddNextSibling(c_target, c_tail)\n        c_tail = c_next\n\ncdef int _copyTail(xmlNode* c_tail, xmlNode* c_target) except -1:\n    cdef xmlNode* c_new_tail\n    # tail copying support: look for any text nodes trailing this node and\n    # copy it to the target node\n    c_tail = _textNodeOrSkip(c_tail)\n    while c_tail is not NULL:\n        if c_target.doc is not c_tail.doc:\n            c_new_tail = tree.xmlDocCopyNode(c_tail, c_target.doc, 0)\n        else:\n            c_new_tail = tree.xmlCopyNode(c_tail, 0)\n        if c_new_tail is NULL:\n            raise MemoryError()\n        c_target = tree.xmlAddNextSibling(c_target, c_new_tail)\n        c_tail = _textNodeOrSkip(c_tail.next)\n    return 0\n\ncdef int _copyNonElementSiblings(xmlNode* c_node, xmlNode* c_target) except -1:\n    cdef xmlNode* c_copy\n    cdef xmlNode* c_sibling = c_node\n    while c_sibling.prev != NULL and \\\n            (c_sibling.prev.type == tree.XML_PI_NODE or\n             c_sibling.prev.type == tree.XML_COMMENT_NODE or\n             c_sibling.prev.type == tree.XML_DTD_NODE):\n        c_sibling = c_sibling.prev\n    while c_sibling != c_node:\n        if c_sibling.type == tree.XML_DTD_NODE:\n            c_copy = <xmlNode*>_copyDtd(<tree.xmlDtd*>c_sibling)\n            if c_sibling == <xmlNode*>c_node.doc.intSubset:\n                c_target.doc.intSubset = <tree.xmlDtd*>c_copy\n            else: # c_sibling == c_node.doc.extSubset\n                c_target.doc.extSubset = <tree.xmlDtd*>c_copy\n        else:\n            c_copy = tree.xmlDocCopyNode(c_sibling, c_target.doc, 1)\n            if c_copy is NULL:\n                raise MemoryError()\n        tree.xmlAddPrevSibling(c_target, c_copy)\n        c_sibling = c_sibling.next\n    while c_sibling.next != NULL and \\\n            (c_sibling.next.type == tree.XML_PI_NODE or\n             c_sibling.next.type == tree.XML_COMMENT_NODE):\n        c_sibling = c_sibling.next\n        c_copy = tree.xmlDocCopyNode(c_sibling, c_target.doc, 1)\n        if c_copy is NULL:\n            raise MemoryError()\n        tree.xmlAddNextSibling(c_target, c_copy)\n\ncdef int _deleteSlice(_Document doc, xmlNode* c_node,\n                      Py_ssize_t count, Py_ssize_t step) except -1:\n    u\"\"\"Delete slice, ``count`` items starting with ``c_node`` with a step\n    width of ``step``.\n    \"\"\"\n    cdef xmlNode* c_next\n    cdef Py_ssize_t c, i\n    cdef _node_to_node_function next_element\n    if c_node is NULL:\n        return 0\n    if step > 0:\n        next_element = _nextElement\n    else:\n        step = -step\n        next_element = _previousElement\n    # now start deleting nodes\n    c = 0\n    c_next = c_node\n    while c_node is not NULL and c < count:\n        for i in range(step):\n            c_next = next_element(c_next)\n            if c_next is NULL:\n                break\n        _removeNode(doc, c_node)\n        c += 1\n        c_node = c_next\n    return 0\n\ncdef int _replaceSlice(_Element parent, xmlNode* c_node,\n                       Py_ssize_t slicelength, Py_ssize_t step,\n                       bint left_to_right, elements) except -1:\n    u\"\"\"Replace the slice of ``count`` elements starting at ``c_node`` with\n    positive step width ``step`` by the Elements in ``elements``.  The\n    direction is given by the boolean argument ``left_to_right``.\n\n    ``c_node`` may be NULL to indicate the end of the children list.\n    \"\"\"\n    cdef xmlNode* c_orig_neighbour\n    cdef xmlNode* c_next\n    cdef xmlDoc*  c_source_doc\n    cdef _Element element\n    cdef Py_ssize_t seqlength, i, c\n    cdef _node_to_node_function next_element\n    assert step > 0\n    if left_to_right:\n        next_element = _nextElement\n    else:\n        next_element = _previousElement\n\n    if not isinstance(elements, (list, tuple)):\n        elements = list(elements)\n\n    if step != 1 or not left_to_right:\n        # *replacing* children stepwise with list => check size!\n        seqlength = len(elements)\n        if seqlength != slicelength:\n            raise ValueError, f\"attempt to assign sequence of size {seqlength} \" \\\n                f\"to extended slice of size {slicelength}\"\n\n    if c_node is NULL:\n        # no children yet => add all elements straight away\n        if left_to_right:\n            for element in elements:\n                assert element is not None, u\"Node must not be None\"\n                _appendChild(parent, element)\n        else:\n            for element in elements:\n                assert element is not None, u\"Node must not be None\"\n                _prependChild(parent, element)\n        return 0\n\n    # remove the elements first as some might be re-added\n    if left_to_right:\n        # L->R, remember left neighbour\n        c_orig_neighbour = _previousElement(c_node)\n    else:\n        # R->L, remember right neighbour\n        c_orig_neighbour = _nextElement(c_node)\n\n    # We remove the original slice elements one by one. Since we hold\n    # a Python reference to all elements that we will insert, it is\n    # safe to let _removeNode() try (and fail) to free them even if\n    # the element itself or one of its descendents will be reinserted.\n    c = 0\n    c_next = c_node\n    while c_node is not NULL and c < slicelength:\n        for i in range(step):\n            c_next = next_element(c_next)\n            if c_next is NULL:\n                break\n        _removeNode(parent._doc, c_node)\n        c += 1\n        c_node = c_next\n\n    # make sure each element is inserted only once\n    elements = iter(elements)\n\n    # find the first node right of the new insertion point\n    if left_to_right:\n        if c_orig_neighbour is not NULL:\n            c_node = next_element(c_orig_neighbour)\n        else:\n            # before the first element\n            c_node = _findChildForwards(parent._c_node, 0)\n    elif c_orig_neighbour is NULL:\n        # at the end, but reversed stepping\n        # append one element and go to the next insertion point\n        for element in elements:\n            assert element is not None, u\"Node must not be None\"\n            _appendChild(parent, element)\n            c_node = element._c_node\n            if slicelength > 0:\n                slicelength -= 1\n                for i in range(1, step):\n                    c_node = next_element(c_node)\n                    if c_node is NULL:\n                        break\n            break\n    else:\n        c_node = c_orig_neighbour\n\n    if left_to_right:\n        # adjust step size after removing slice as we are not stepping\n        # over the newly inserted elements\n        step -= 1\n\n    # now insert elements where we removed them\n    if c_node is not NULL:\n        for element in elements:\n            assert element is not None, u\"Node must not be None\"\n            _assertValidNode(element)\n            # move element and tail over\n            c_source_doc = element._c_node.doc\n            c_next = element._c_node.next\n            tree.xmlAddPrevSibling(c_node, element._c_node)\n            _moveTail(c_next, element._c_node)\n\n            # integrate element into new document\n            moveNodeToDocument(parent._doc, c_source_doc, element._c_node)\n\n            # stop at the end of the slice\n            if slicelength > 0:\n                slicelength -= 1\n                for i in range(step):\n                    c_node = next_element(c_node)\n                    if c_node is NULL:\n                        break\n                if c_node is NULL:\n                    break\n        else:\n            # everything inserted\n            return 0\n\n    # append the remaining elements at the respective end\n    if left_to_right:\n        for element in elements:\n            assert element is not None, u\"Node must not be None\"\n            _assertValidNode(element)\n            _appendChild(parent, element)\n    else:\n        for element in elements:\n            assert element is not None, u\"Node must not be None\"\n            _assertValidNode(element)\n            _prependChild(parent, element)\n\n    return 0\n\n\ncdef int _linkChild(xmlNode* c_parent, xmlNode* c_node) except -1:\n    \"\"\"Adaptation of 'xmlAddChild()' that deep-fix the document links iteratively.\n    \"\"\"\n    assert _isElement(c_node)\n    c_node.parent = c_parent\n    if c_parent.children is NULL:\n        c_parent.children = c_parent.last = c_node\n    else:\n        c_node.prev = c_parent.last\n        c_parent.last.next = c_node\n        c_parent.last = c_node\n\n    _setTreeDoc(c_node, c_parent.doc)\n    return 0\n\n\ncdef int _appendChild(_Element parent, _Element child) except -1:\n    u\"\"\"Append a new child to a parent element.\n    \"\"\"\n    c_node = child._c_node\n    c_source_doc = c_node.doc\n    # prevent cycles\n    if _isAncestorOrSame(c_node, parent._c_node):\n        raise ValueError(\"cannot append parent to itself\")\n    # store possible text node\n    c_next = c_node.next\n    # move node itself\n    tree.xmlUnlinkNode(c_node)\n    # do not call xmlAddChild() here since it would deep-traverse the tree\n    _linkChild(parent._c_node, c_node)\n    _moveTail(c_next, c_node)\n    # uh oh, elements may be pointing to different doc when\n    # parent element has moved; change them too..\n    moveNodeToDocument(parent._doc, c_source_doc, c_node)\n    return 0\n\ncdef int _prependChild(_Element parent, _Element child) except -1:\n    u\"\"\"Prepend a new child to a parent element.\n    \"\"\"\n    c_node = child._c_node\n    c_source_doc = c_node.doc\n    # prevent cycles\n    if _isAncestorOrSame(c_node, parent._c_node):\n        raise ValueError(\"cannot append parent to itself\")\n    # store possible text node\n    c_next = c_node.next\n    # move node itself\n    c_child = _findChildForwards(parent._c_node, 0)\n    if c_child is NULL:\n        tree.xmlUnlinkNode(c_node)\n        # do not call xmlAddChild() here since it would deep-traverse the tree\n        _linkChild(parent._c_node, c_node)\n    else:\n        tree.xmlAddPrevSibling(c_child, c_node)\n    _moveTail(c_next, c_node)\n    # uh oh, elements may be pointing to different doc when\n    # parent element has moved; change them too..\n    moveNodeToDocument(parent._doc, c_source_doc, c_node)\n    return 0\n\ncdef int _appendSibling(_Element element, _Element sibling) except -1:\n    u\"\"\"Add a new sibling behind an element.\n    \"\"\"\n    return _addSibling(element, sibling, as_next=True)\n\ncdef int _prependSibling(_Element element, _Element sibling) except -1:\n    u\"\"\"Add a new sibling before an element.\n    \"\"\"\n    return _addSibling(element, sibling, as_next=False)\n\ncdef int _addSibling(_Element element, _Element sibling, bint as_next) except -1:\n    c_node = sibling._c_node\n    c_source_doc = c_node.doc\n    # prevent cycles\n    if _isAncestorOrSame(c_node, element._c_node):\n        if element._c_node is c_node:\n            return 0  # nothing to do\n        raise ValueError(\"cannot add ancestor as sibling, please break cycle first\")\n    # store possible text node\n    c_next = c_node.next\n    # move node itself\n    if as_next:\n        tree.xmlAddNextSibling(element._c_node, c_node)\n    else:\n        tree.xmlAddPrevSibling(element._c_node, c_node)\n    _moveTail(c_next, c_node)\n    # uh oh, elements may be pointing to different doc when\n    # parent element has moved; change them too..\n    moveNodeToDocument(element._doc, c_source_doc, c_node)\n    return 0\n\ncdef inline bint isutf8(const_xmlChar* s):\n    cdef xmlChar c = s[0]\n    while c != c'\\0':\n        if c & 0x80:\n            return True\n        s += 1\n        c = s[0]\n    return False\n\ncdef bint isutf8l(const_xmlChar* s, size_t length):\n    \"\"\"\n    Search for non-ASCII characters in the string, knowing its length in advance.\n    \"\"\"\n    cdef unsigned int i\n    cdef unsigned long non_ascii_mask\n    cdef const unsigned long *lptr = <const unsigned long*> s\n\n    cdef const unsigned long *end = lptr + length // sizeof(unsigned long)\n    if length >= sizeof(non_ascii_mask):\n        # Build constant 0x80808080... mask (and let the C compiler fold it).\n        non_ascii_mask = 0\n        for i in range(sizeof(non_ascii_mask) // 2):\n            non_ascii_mask = (non_ascii_mask << 16) | 0x8080\n\n        # Advance to long-aligned character before we start reading longs.\n        while (<size_t>s) % sizeof(unsigned long) and s < <const_xmlChar *>end:\n            if s[0] & 0x80:\n                return True\n            s += 1\n\n        # Read one long at a time\n        lptr = <const unsigned long*> s\n        while lptr < end:\n            if lptr[0] & non_ascii_mask:\n                return True\n            lptr += 1\n        s = <const_xmlChar *>lptr\n\n    while s < (<const_xmlChar *>end + length % sizeof(unsigned long)):\n        if s[0] & 0x80:\n            return True\n        s += 1\n\n    return False\n\ncdef int _is_valid_xml_ascii(bytes pystring):\n    \"\"\"Check if a string is XML ascii content.\"\"\"\n    cdef signed char ch\n    # When ch is a *signed* char, non-ascii characters are negative integers\n    # and xmlIsChar_ch does not accept them.\n    for ch in pystring:\n        if not tree.xmlIsChar_ch(ch):\n            return 0\n    return 1\n\ncdef bint _is_valid_xml_utf8(bytes pystring):\n    u\"\"\"Check if a string is like valid UTF-8 XML content.\"\"\"\n    cdef const_xmlChar* s = _xcstr(pystring)\n    cdef const_xmlChar* c_end = s + len(pystring)\n    cdef unsigned long next3 = 0\n    if s < c_end - 2:\n        next3 = (s[0] << 8) | (s[1])\n\n    while s < c_end - 2:\n        next3 = 0x00ffffff & ((next3 << 8) | s[2])\n        if s[0] & 0x80:\n            # 0xefbfbe and 0xefbfbf are utf-8 encodings of\n            # forbidden characters \\ufffe and \\uffff\n            if next3 == 0x00efbfbe or next3 == 0x00efbfbf:\n                return 0\n            # 0xeda080 and 0xedbfbf are utf-8 encodings of\n            # \\ud800 and \\udfff. Anything between them (inclusive)\n            # is forbidden, because they are surrogate blocks in utf-16.\n            if 0x00eda080 <= next3 <= 0x00edbfbf:\n                return 0\n        elif not tree.xmlIsChar_ch(s[0]):\n            return 0  # invalid ascii char\n        s += 1\n\n    while s < c_end:\n        if not s[0] & 0x80 and not tree.xmlIsChar_ch(s[0]):\n            return 0  # invalid ascii char\n        s += 1\n\n    return 1\n\ncdef inline object funicodeOrNone(const_xmlChar* s):\n    return funicode(s) if s is not NULL else None\n\ncdef inline object funicodeOrEmpty(const_xmlChar* s):\n    return funicode(s) if s is not NULL else ''\n\ncdef object funicode(const_xmlChar* s):\n    cdef Py_ssize_t slen\n    cdef const_xmlChar* spos\n    cdef bint is_non_ascii\n    if python.LXML_UNICODE_STRINGS:\n        return s.decode('UTF-8')\n    spos = s\n    is_non_ascii = 0\n    while spos[0] != c'\\0':\n        if spos[0] & 0x80:\n            is_non_ascii = 1\n            break\n        spos += 1\n    slen = spos - s\n    if spos[0] != c'\\0':\n        slen += cstring_h.strlen(<const char*> spos)\n    if is_non_ascii:\n        return s[:slen].decode('UTF-8')\n    return <bytes>s[:slen]\n\ncdef bytes _utf8(object s):\n    \"\"\"Test if a string is valid user input and encode it to UTF-8.\n    Reject all bytes/unicode input that contains non-XML characters.\n    Reject all bytes input that contains non-ASCII characters.\n    \"\"\"\n    cdef int valid\n    cdef bytes utf8_string\n    if python.IS_PYTHON2 and type(s) is bytes:\n        utf8_string = <bytes>s\n        valid = _is_valid_xml_ascii(utf8_string)\n    elif isinstance(s, unicode):\n        utf8_string = (<unicode>s).encode('utf8')\n        valid = _is_valid_xml_utf8(utf8_string)\n    elif isinstance(s, (bytes, bytearray)):\n        utf8_string = bytes(s)\n        valid = _is_valid_xml_ascii(utf8_string)\n    else:\n        raise TypeError(\"Argument must be bytes or unicode, got '%.200s'\" % type(s).__name__)\n    if not valid:\n        raise ValueError(\n            \"All strings must be XML compatible: Unicode or ASCII, no NULL bytes or control characters\")\n    return utf8_string\n\n\ncdef bytes _utf8orNone(object s):\n    return _utf8(s) if s is not None else None\n\n\ncdef strrepr(s):\n    \"\"\"Build a representation of strings which we can use in __repr__\n    methods, e.g. _Element.__repr__().\n    \"\"\"\n    return s.encode('unicode-escape') if python.IS_PYTHON2 else s\n\n\ncdef enum:\n    NO_FILE_PATH = 0\n    ABS_UNIX_FILE_PATH = 1\n    ABS_WIN_FILE_PATH = 2\n    REL_FILE_PATH = 3\n\n\ncdef bint _isFilePath(const_xmlChar* c_path):\n    u\"simple heuristic to see if a path is a filename\"\n    cdef xmlChar c\n    # test if it looks like an absolute Unix path or a Windows network path\n    if c_path[0] == c'/':\n        return ABS_UNIX_FILE_PATH\n\n    # test if it looks like an absolute Windows path or URL\n    if c'a' <= c_path[0] <= c'z' or c'A' <= c_path[0] <= c'Z':\n        c_path += 1\n        if c_path[0] == c':' and c_path[1] in b'\\0\\\\':\n            return ABS_WIN_FILE_PATH  # C: or C:\\...\n\n        # test if it looks like a URL with scheme://\n        while c'a' <= c_path[0] <= c'z' or c'A' <= c_path[0] <= c'Z':\n            c_path += 1\n        if c_path[0] == c':' and c_path[1] == c'/' and c_path[2] == c'/':\n            return NO_FILE_PATH\n\n    # assume it's a relative path\n    return REL_FILE_PATH\n\ncdef object _NO_FSPATH = object()\n\ncdef object _getFSPathOrObject(object obj):\n    \"\"\"\n    Get the __fspath__ attribute of an object if it exists.\n    Otherwise, the original object is returned.\n    \"\"\"\n    if _isString(obj):\n        return obj\n    if python.PY_VERSION_HEX >= 0x03060000:\n        try:\n            return python.PY_FSPath(obj)\n        except TypeError:\n            return obj\n    fspath = getattr(obj, '__fspath__', _NO_FSPATH)\n    if fspath is not _NO_FSPATH and callable(fspath):\n        return fspath()\n    return obj\n\ncdef object _encodeFilename(object filename):\n    u\"\"\"Make sure a filename is 8-bit encoded (or None).\n    \"\"\"\n    if filename is None:\n        return None\n    elif isinstance(filename, bytes):\n        return filename\n    elif isinstance(filename, unicode):\n        filename8 = (<unicode>filename).encode('utf8')\n        if _isFilePath(<unsigned char*>filename8):\n            try:\n                return python.PyUnicode_AsEncodedString(\n                    filename, _C_FILENAME_ENCODING, NULL)\n            except UnicodeEncodeError:\n                pass\n        return filename8\n    else:\n        raise TypeError(\"Argument must be string or unicode.\")\n\ncdef object _decodeFilename(const_xmlChar* c_path):\n    u\"\"\"Make the filename a unicode string if we are in Py3.\n    \"\"\"\n    return _decodeFilenameWithLength(c_path, tree.xmlStrlen(c_path))\n\ncdef object _decodeFilenameWithLength(const_xmlChar* c_path, size_t c_len):\n    u\"\"\"Make the filename a unicode string if we are in Py3.\n    \"\"\"\n    if _isFilePath(c_path):\n        try:\n            return python.PyUnicode_Decode(\n                <const_char*>c_path, c_len, _C_FILENAME_ENCODING, NULL)\n        except UnicodeDecodeError:\n            pass\n    try:\n        return (<unsigned char*>c_path)[:c_len].decode('UTF-8')\n    except UnicodeDecodeError:\n        # this is a stupid fallback, but it might still work...\n        return (<unsigned char*>c_path)[:c_len].decode('latin-1', 'replace')\n\ncdef object _encodeFilenameUTF8(object filename):\n    u\"\"\"Recode filename as UTF-8. Tries ASCII, local filesystem encoding and\n    UTF-8 as source encoding.\n    \"\"\"\n    cdef char* c_filename\n    if filename is None:\n        return None\n    elif isinstance(filename, bytes):\n        if not isutf8l(<bytes>filename, len(<bytes>filename)):\n            # plain ASCII!\n            return filename\n        c_filename = _cstr(<bytes>filename)\n        try:\n            # try to decode with default encoding\n            filename = python.PyUnicode_Decode(\n                c_filename, len(<bytes>filename),\n                _C_FILENAME_ENCODING, NULL)\n        except UnicodeDecodeError as decode_exc:\n            try:\n                # try if it's proper UTF-8\n                (<bytes>filename).decode('utf8')\n                return filename\n            except UnicodeDecodeError:\n                raise decode_exc # otherwise re-raise original exception\n    if isinstance(filename, unicode):\n        return (<unicode>filename).encode('utf8')\n    else:\n        raise TypeError(\"Argument must be string or unicode.\")\n\ncdef tuple _getNsTag(tag):\n    u\"\"\"Given a tag, find namespace URI and tag name.\n    Return None for NS uri if no namespace URI provided.\n    \"\"\"\n    return __getNsTag(tag, 0)\n\ncdef tuple _getNsTagWithEmptyNs(tag):\n    u\"\"\"Given a tag, find namespace URI and tag name.  Return None for NS uri\n    if no namespace URI provided, or the empty string if namespace\n    part is '{}'.\n    \"\"\"\n    return __getNsTag(tag, 1)\n\ncdef tuple __getNsTag(tag, bint empty_ns):\n    cdef char* c_tag\n    cdef char* c_ns_end\n    cdef Py_ssize_t taglen\n    cdef Py_ssize_t nslen\n    cdef bytes ns = None\n    # _isString() is much faster than isinstance()\n    if not _isString(tag) and isinstance(tag, QName):\n        tag = (<QName>tag).text\n    tag = _utf8(tag)\n    c_tag = _cstr(tag)\n    if c_tag[0] == c'{':\n        c_tag += 1\n        c_ns_end = cstring_h.strchr(c_tag, c'}')\n        if c_ns_end is NULL:\n            raise ValueError, u\"Invalid tag name\"\n        nslen  = c_ns_end - c_tag\n        taglen = python.PyBytes_GET_SIZE(tag) - nslen - 2\n        if taglen == 0:\n            raise ValueError, u\"Empty tag name\"\n        if nslen > 0:\n            ns = <bytes>c_tag[:nslen]\n        elif empty_ns:\n            ns = b''\n        tag = <bytes>c_ns_end[1:taglen+1]\n    elif python.PyBytes_GET_SIZE(tag) == 0:\n        raise ValueError, u\"Empty tag name\"\n    return ns, tag\n\ncdef inline int _pyXmlNameIsValid(name_utf8):\n    return _xmlNameIsValid(_xcstr(name_utf8)) and b':' not in name_utf8\n\ncdef inline int _pyHtmlNameIsValid(name_utf8):\n    return _htmlNameIsValid(_xcstr(name_utf8))\n\ncdef inline int _xmlNameIsValid(const_xmlChar* c_name):\n    return tree.xmlValidateNameValue(c_name)\n\ncdef int _htmlNameIsValid(const_xmlChar* c_name):\n    if c_name is NULL or c_name[0] == c'\\0':\n        return 0\n    while c_name[0] != c'\\0':\n        if c_name[0] in b'&<>/\"\\'\\t\\n\\x0B\\x0C\\r ':\n            return 0\n        c_name += 1\n    return 1\n\ncdef bint _characterReferenceIsValid(const_xmlChar* c_name):\n    cdef bint is_hex\n    if c_name[0] == c'x':\n        c_name += 1\n        is_hex = 1\n    else:\n        is_hex = 0\n    if c_name[0] == c'\\0':\n        return 0\n    while c_name[0] != c'\\0':\n        if c_name[0] < c'0' or c_name[0] > c'9':\n            if not is_hex:\n                return 0\n            if not (c'a' <= c_name[0] <= c'f'):\n                if not (c'A' <= c_name[0] <= c'F'):\n                    return 0\n        c_name += 1\n    return 1\n\ncdef int _tagValidOrRaise(tag_utf) except -1:\n    if not _pyXmlNameIsValid(tag_utf):\n        raise ValueError(f\"Invalid tag name {(<bytes>tag_utf).decode('utf8')!r}\")\n    return 0\n\ncdef int _htmlTagValidOrRaise(tag_utf) except -1:\n    if not _pyHtmlNameIsValid(tag_utf):\n        raise ValueError(f\"Invalid HTML tag name {(<bytes>tag_utf).decode('utf8')!r}\")\n    return 0\n\ncdef int _attributeValidOrRaise(name_utf) except -1:\n    if not _pyXmlNameIsValid(name_utf):\n        raise ValueError(f\"Invalid attribute name {(<bytes>name_utf).decode('utf8')!r}\")\n    return 0\n\ncdef int _prefixValidOrRaise(tag_utf) except -1:\n    if not _pyXmlNameIsValid(tag_utf):\n        raise ValueError(f\"Invalid namespace prefix {(<bytes>tag_utf).decode('utf8')!r}\")\n    return 0\n\ncdef int _uriValidOrRaise(uri_utf) except -1:\n    cdef uri.xmlURI* c_uri = uri.xmlParseURI(_cstr(uri_utf))\n    if c_uri is NULL:\n        raise ValueError(f\"Invalid namespace URI {(<bytes>uri_utf).decode('utf8')!r}\")\n    uri.xmlFreeURI(c_uri)\n    return 0\n\ncdef inline object _namespacedName(xmlNode* c_node):\n    return _namespacedNameFromNsName(_getNs(c_node), c_node.name)\n\ncdef object _namespacedNameFromNsName(const_xmlChar* href, const_xmlChar* name):\n    if href is NULL:\n        return funicode(name)\n    elif not python.IS_PYPY and (python.LXML_UNICODE_STRINGS or isutf8(name) or isutf8(href)):\n        return python.PyUnicode_FromFormat(\"{%s}%s\", href, name)\n    else:\n        s = python.PyBytes_FromFormat(\"{%s}%s\", href, name)\n        if python.IS_PYPY and (python.LXML_UNICODE_STRINGS or isutf8l(s, len(s))):\n            return (<bytes>s).decode('utf8')\n        else:\n            return s\n\ncdef _getFilenameForFile(source):\n    u\"\"\"Given a Python File or Gzip object, give filename back.\n\n    Returns None if not a file object.\n    \"\"\"\n    # urllib2 provides a geturl() method\n    try:\n        return source.geturl()\n    except:\n        pass\n    # file instances have a name attribute\n    try:\n        filename = source.name\n        if _isString(filename):\n            return os_path_abspath(filename)\n    except:\n        pass\n    # gzip file instances have a filename attribute (before Py3k)\n    try:\n        filename = source.filename\n        if _isString(filename):\n            return os_path_abspath(filename)\n    except:\n        pass\n    # can't determine filename\n    return None\n", "# iterparse -- event-driven parsing\n\nDEF __ITERPARSE_CHUNK_SIZE = 32768\n\ncdef class iterparse:\n    u\"\"\"iterparse(self, source, events=(\"end\",), tag=None, \\\n                  attribute_defaults=False, dtd_validation=False, \\\n                  load_dtd=False, no_network=True, remove_blank_text=False, \\\n                  remove_comments=False, remove_pis=False, encoding=None, \\\n                  html=False, recover=None, huge_tree=False, schema=None)\n\n    Incremental parser.\n\n    Parses XML into a tree and generates tuples (event, element) in a\n    SAX-like fashion. ``event`` is any of 'start', 'end', 'start-ns',\n    'end-ns'.\n\n    For 'start' and 'end', ``element`` is the Element that the parser just\n    found opening or closing.  For 'start-ns', it is a tuple (prefix, URI) of\n    a new namespace declaration.  For 'end-ns', it is simply None.  Note that\n    all start and end events are guaranteed to be properly nested.\n\n    The keyword argument ``events`` specifies a sequence of event type names\n    that should be generated.  By default, only 'end' events will be\n    generated.\n\n    The additional ``tag`` argument restricts the 'start' and 'end' events to\n    those elements that match the given tag.  The ``tag`` argument can also be\n    a sequence of tags to allow matching more than one tag.  By default,\n    events are generated for all elements.  Note that the 'start-ns' and\n    'end-ns' events are not impacted by this restriction.\n\n    The other keyword arguments in the constructor are mainly based on the\n    libxml2 parser configuration.  A DTD will also be loaded if validation or\n    attribute default values are requested.\n\n    Available boolean keyword arguments:\n     - attribute_defaults: read default attributes from DTD\n     - dtd_validation: validate (if DTD is available)\n     - load_dtd: use DTD for parsing\n     - no_network: prevent network access for related files\n     - remove_blank_text: discard blank text nodes\n     - remove_comments: discard comments\n     - remove_pis: discard processing instructions\n     - strip_cdata: replace CDATA sections by normal text content (default: True)\n     - compact: safe memory for short text content (default: True)\n     - resolve_entities: replace entities by their text value (default: True)\n     - huge_tree: disable security restrictions and support very deep trees\n                  and very long text content (only affects libxml2 2.7+)\n     - html: parse input as HTML (default: XML)\n     - recover: try hard to parse through broken input (default: True for HTML,\n                False otherwise)\n\n    Other keyword arguments:\n     - encoding: override the document encoding\n     - schema: an XMLSchema to validate against\n    \"\"\"\n    cdef _FeedParser _parser\n    cdef object _tag\n    cdef object _events\n    cdef readonly object root\n    cdef object _source\n    cdef object _filename\n    cdef object _error\n    cdef bint _close_source_after_read\n\n    def __init__(self, source, events=(u\"end\",), *, tag=None,\n                 attribute_defaults=False, dtd_validation=False,\n                 load_dtd=False, no_network=True, remove_blank_text=False,\n                 compact=True, resolve_entities=True, remove_comments=False,\n                 remove_pis=False, strip_cdata=True, encoding=None,\n                 html=False, recover=None, huge_tree=False, collect_ids=True,\n                 XMLSchema schema=None):\n        if not hasattr(source, 'read'):\n            source = _getFSPathOrObject(source)\n            self._filename = source\n            if python.IS_PYTHON2:\n                source = _encodeFilename(source)\n            source = open(source, 'rb')\n            self._close_source_after_read = True\n        else:\n            self._filename = _getFilenameForFile(source)\n            self._close_source_after_read = False\n\n        if recover is None:\n            recover = html\n\n        if html:\n            # make sure we're not looking for namespaces\n            events = [event for event in events\n                      if event not in ('start-ns', 'end-ns')]\n            parser = HTMLPullParser(\n                events,\n                tag=tag,\n                recover=recover,\n                base_url=self._filename,\n                encoding=encoding,\n                remove_blank_text=remove_blank_text,\n                remove_comments=remove_comments,\n                remove_pis=remove_pis,\n                strip_cdata=strip_cdata,\n                no_network=no_network,\n                target=None,  # TODO\n                schema=schema,\n                compact=compact)\n        else:\n            parser = XMLPullParser(\n                events,\n                tag=tag,\n                recover=recover,\n                base_url=self._filename,\n                encoding=encoding,\n                attribute_defaults=attribute_defaults,\n                dtd_validation=dtd_validation,\n                load_dtd=load_dtd,\n                no_network=no_network,\n                schema=schema,\n                huge_tree=huge_tree,\n                remove_blank_text=remove_blank_text,\n                resolve_entities=resolve_entities,\n                remove_comments=remove_comments,\n                remove_pis=remove_pis,\n                strip_cdata=strip_cdata,\n                collect_ids=True,\n                target=None,  # TODO\n                compact=compact)\n\n        self._events = parser.read_events()\n        self._parser = parser\n        self._source = source\n\n    @property\n    def error_log(self):\n        \"\"\"The error log of the last (or current) parser run.\n        \"\"\"\n        return self._parser.feed_error_log\n\n    @property\n    def resolvers(self):\n        \"\"\"The custom resolver registry of the last (or current) parser run.\n        \"\"\"\n        return self._parser.resolvers\n\n    @property\n    def version(self):\n        \"\"\"The version of the underlying XML parser.\"\"\"\n        return self._parser.version\n\n    def set_element_class_lookup(self, ElementClassLookup lookup = None):\n        u\"\"\"set_element_class_lookup(self, lookup = None)\n\n        Set a lookup scheme for element classes generated from this parser.\n\n        Reset it by passing None or nothing.\n        \"\"\"\n        self._parser.set_element_class_lookup(lookup)\n\n    def makeelement(self, _tag, attrib=None, nsmap=None, **_extra):\n        u\"\"\"makeelement(self, _tag, attrib=None, nsmap=None, **_extra)\n\n        Creates a new element associated with this parser.\n        \"\"\"\n        self._parser.makeelement(\n            _tag, attrib=None, nsmap=None, **_extra)\n\n    @cython.final\n    cdef _close_source(self):\n        if self._source is None:\n            return\n        if not self._close_source_after_read:\n            self._source = None\n            return\n        try:\n            close = self._source.close\n        except AttributeError:\n            close = None\n        finally:\n            self._source = None\n        if close is not None:\n            close()\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        try:\n            return next(self._events)\n        except StopIteration:\n            pass\n        context = <_SaxParserContext>self._parser._getPushParserContext()\n        if self._source is not None:\n            done = False\n            while not done:\n                try:\n                    done = self._read_more_events(context)\n                    return next(self._events)\n                except StopIteration:\n                    pass  # no events yet\n                except Exception as e:\n                    self._error = e\n                    self._close_source()\n                    try:\n                        return next(self._events)\n                    except StopIteration:\n                        break\n        # nothing left to read or return\n        if self._error is not None:\n            error = self._error\n            self._error = None\n            raise error\n        if (context._validator is not None\n                and not context._validator.isvalid()):\n            _raiseParseError(context._c_ctxt, self._filename,\n                             context._error_log)\n        # no errors => all done\n        raise StopIteration\n\n    @cython.final\n    cdef bint _read_more_events(self, _SaxParserContext context) except -123:\n        data = self._source.read(__ITERPARSE_CHUNK_SIZE)\n        if not isinstance(data, bytes):\n            self._close_source()\n            raise TypeError(\"reading file objects must return bytes objects\")\n        if not data:\n            try:\n                self.root = self._parser.close()\n            finally:\n                self._close_source()\n            return True\n        self._parser.feed(data)\n        return False\n\n\ncdef enum _IterwalkSkipStates:\n    IWSKIP_NEXT_IS_START\n    IWSKIP_SKIP_NEXT\n    IWSKIP_CAN_SKIP\n    IWSKIP_CANNOT_SKIP\n\n\ncdef class iterwalk:\n    u\"\"\"iterwalk(self, element_or_tree, events=(\"end\",), tag=None)\n\n    A tree walker that generates events from an existing tree as if it\n    was parsing XML data with ``iterparse()``.\n\n    Just as for ``iterparse()``, the ``tag`` argument can be a single tag or a\n    sequence of tags.\n\n    After receiving a 'start' or 'start-ns' event, the children and\n    descendants of the current element can be excluded from iteration\n    by calling the ``skip_subtree()`` method.\n    \"\"\"\n    cdef _MultiTagMatcher _matcher\n    cdef list   _node_stack\n    cdef list   _events\n    cdef object _pop_event\n    cdef object _include_siblings\n    cdef int    _index\n    cdef int    _event_filter\n    cdef _IterwalkSkipStates _skip_state\n\n    def __init__(self, element_or_tree, events=(u\"end\",), tag=None):\n        cdef _Element root\n        cdef int ns_count\n        root = _rootNodeOrRaise(element_or_tree)\n        self._event_filter = _buildParseEventFilter(events)\n        if tag is None or tag == '*':\n            self._matcher = None\n        else:\n            self._matcher = _MultiTagMatcher.__new__(_MultiTagMatcher, tag)\n        self._node_stack  = []\n        self._events = []\n        self._pop_event = self._events.pop\n        self._skip_state = IWSKIP_CANNOT_SKIP  # ignore all skip requests by default\n\n        if self._event_filter:\n            self._index = 0\n            if self._matcher is not None and self._event_filter & PARSE_EVENT_FILTER_START:\n                self._matcher.cacheTags(root._doc)\n\n            # When processing an ElementTree, add events for the preceding comments/PIs.\n            if self._event_filter & (PARSE_EVENT_FILTER_COMMENT | PARSE_EVENT_FILTER_PI):\n                if isinstance(element_or_tree, _ElementTree):\n                    self._include_siblings = root\n                    for elem in list(root.itersiblings(preceding=True))[::-1]:\n                        if self._event_filter & PARSE_EVENT_FILTER_COMMENT and elem.tag is Comment:\n                            self._events.append((u'comment', elem))\n                        elif self._event_filter & PARSE_EVENT_FILTER_PI and elem.tag is PI:\n                            self._events.append((u'pi', elem))\n\n            ns_count = self._start_node(root)\n            self._node_stack.append( (root, ns_count) )\n        else:\n            self._index = -1\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        cdef xmlNode* c_child\n        cdef _Element node\n        cdef _Element next_node\n        cdef int ns_count = 0\n        if self._events:\n            return self._next_event()\n        if self._matcher is not None and self._index >= 0:\n            node = self._node_stack[self._index][0]\n            self._matcher.cacheTags(node._doc)\n\n        # find next node\n        while self._index >= 0:\n            node = self._node_stack[self._index][0]\n\n            if self._skip_state == IWSKIP_SKIP_NEXT:\n                c_child = NULL\n            else:\n                c_child = self._process_non_elements(\n                    node._doc, _findChildForwards(node._c_node, 0))\n            self._skip_state = IWSKIP_CANNOT_SKIP\n\n            while c_child is NULL:\n                # back off through parents\n                self._index -= 1\n                node = self._end_node()\n                if self._index < 0:\n                    break\n                c_child = self._process_non_elements(\n                    node._doc, _nextElement(node._c_node))\n\n            if c_child is not NULL:\n                next_node = _elementFactory(node._doc, c_child)\n                if self._event_filter & (PARSE_EVENT_FILTER_START |\n                                         PARSE_EVENT_FILTER_START_NS):\n                    ns_count = self._start_node(next_node)\n                elif self._event_filter & PARSE_EVENT_FILTER_END_NS:\n                    ns_count = _countNsDefs(next_node._c_node)\n                self._node_stack.append( (next_node, ns_count) )\n                self._index += 1\n            if self._events:\n                return self._next_event()\n\n        if self._include_siblings is not None:\n            node, self._include_siblings = self._include_siblings, None\n            self._process_non_elements(node._doc, _nextElement(node._c_node))\n            if self._events:\n                return self._next_event()\n\n        raise StopIteration\n\n    @cython.final\n    cdef xmlNode* _process_non_elements(self, _Document doc, xmlNode* c_node):\n        while c_node is not NULL and c_node.type != tree.XML_ELEMENT_NODE:\n            if c_node.type == tree.XML_COMMENT_NODE:\n                if self._event_filter & PARSE_EVENT_FILTER_COMMENT:\n                    self._events.append(\n                        (u\"comment\", _elementFactory(doc, c_node)))\n                c_node = _nextElement(c_node)\n            elif c_node.type == tree.XML_PI_NODE:\n                if self._event_filter & PARSE_EVENT_FILTER_PI:\n                    self._events.append(\n                        (u\"pi\", _elementFactory(doc, c_node)))\n                c_node = _nextElement(c_node)\n            else:\n                break\n        return c_node\n\n    @cython.final\n    cdef _next_event(self):\n        if self._skip_state == IWSKIP_NEXT_IS_START:\n            if self._events[0][0] in (u'start', u'start-ns'):\n                self._skip_state = IWSKIP_CAN_SKIP\n        return self._pop_event(0)\n\n    def skip_subtree(self):\n        \"\"\"Prevent descending into the current subtree.\n        Instead, the next returned event will be the 'end' event of the current element\n        (if included), ignoring any children or descendants.\n\n        This has no effect right after an 'end' or 'end-ns' event.\n        \"\"\"\n        if self._skip_state == IWSKIP_CAN_SKIP:\n            self._skip_state = IWSKIP_SKIP_NEXT\n\n    @cython.final\n    cdef int _start_node(self, _Element node) except -1:\n        cdef int ns_count\n        if self._event_filter & PARSE_EVENT_FILTER_START_NS:\n            ns_count = _appendStartNsEvents(node._c_node, self._events)\n            if self._events:\n                self._skip_state = IWSKIP_NEXT_IS_START\n        elif self._event_filter & PARSE_EVENT_FILTER_END_NS:\n            ns_count = _countNsDefs(node._c_node)\n        else:\n            ns_count = 0\n        if self._event_filter & PARSE_EVENT_FILTER_START:\n            if self._matcher is None or self._matcher.matches(node._c_node):\n                self._events.append( (u\"start\", node) )\n                self._skip_state = IWSKIP_NEXT_IS_START\n        return ns_count\n\n    @cython.final\n    cdef _Element _end_node(self):\n        cdef _Element node\n        cdef int i, ns_count\n        node, ns_count = self._node_stack.pop()\n        if self._event_filter & PARSE_EVENT_FILTER_END:\n            if self._matcher is None or self._matcher.matches(node._c_node):\n                self._events.append( (u\"end\", node) )\n        if self._event_filter & PARSE_EVENT_FILTER_END_NS and ns_count:\n            event = (u\"end-ns\", None)\n            for i in range(ns_count):\n                self._events.append(event)\n        return node\n\n\ncdef int _countNsDefs(xmlNode* c_node):\n    cdef xmlNs* c_ns\n    cdef int count\n    count = 0\n    c_ns = c_node.nsDef\n    while c_ns is not NULL:\n        count += (c_ns.href is not NULL)\n        c_ns = c_ns.next\n    return count\n\n\ncdef int _appendStartNsEvents(xmlNode* c_node, list event_list) except -1:\n    cdef xmlNs* c_ns\n    cdef int count\n    count = 0\n    c_ns = c_node.nsDef\n    while c_ns is not NULL:\n        if c_ns.href:\n            ns_tuple = (funicodeOrEmpty(c_ns.prefix),\n                        funicode(c_ns.href))\n            event_list.append( (u\"start-ns\", ns_tuple) )\n            count += 1\n        c_ns = c_ns.next\n    return count\n", "# -*- coding: utf-8 -*-\n\n\"\"\"\nTests specific to the extended etree API\n\nTests that apply to the general ElementTree API should go into\ntest_elementtree\n\"\"\"\n\nfrom __future__ import absolute_import\n\nfrom collections import OrderedDict\nimport os.path\nimport unittest\nimport copy\nimport sys\nimport re\nimport gc\nimport operator\nimport textwrap\nimport zlib\nimport gzip\n\nfrom .common_imports import etree, StringIO, BytesIO, HelperTestCase\nfrom .common_imports import fileInTestDir, fileUrlInTestDir, read_file, path2url, tmpfile\nfrom .common_imports import SillyFileLike, LargeFileLikeUnicode, doctest, make_doctest\nfrom .common_imports import canonicalize, _str, _bytes\nfrom .common_imports import SimpleFSPath\n\nprint(\"\"\"\nTESTED VERSION: %s\"\"\" % etree.__version__ + \"\"\"\n    Python:           %r\"\"\" % (sys.version_info,) + \"\"\"\n    lxml.etree:       %r\"\"\" % (etree.LXML_VERSION,) + \"\"\"\n    libxml used:      %r\"\"\" % (etree.LIBXML_VERSION,) + \"\"\"\n    libxml compiled:  %r\"\"\" % (etree.LIBXML_COMPILED_VERSION,) + \"\"\"\n    libxslt used:     %r\"\"\" % (etree.LIBXSLT_VERSION,) + \"\"\"\n    libxslt compiled: %r\"\"\" % (etree.LIBXSLT_COMPILED_VERSION,) + \"\"\"\n    FS encoding:      %s\"\"\" % (sys.getfilesystemencoding(),) + \"\"\"\n    Default encoding: %s\"\"\" % (sys.getdefaultencoding(),) + \"\"\"\n    Max Unicode:      %s\"\"\" % (sys.maxunicode,) + \"\"\"\n\"\"\")\n\ntry:\n    _unicode = unicode\nexcept NameError:\n    # Python 3\n    _unicode = str\n\n\nclass ETreeOnlyTestCase(HelperTestCase):\n    \"\"\"Tests only for etree, not ElementTree\"\"\"\n    etree = etree\n\n    def test_version(self):\n        self.assertTrue(isinstance(etree.__version__, _unicode))\n        self.assertTrue(isinstance(etree.LXML_VERSION, tuple))\n        self.assertEqual(len(etree.LXML_VERSION), 4)\n        self.assertTrue(isinstance(etree.LXML_VERSION[0], int))\n        self.assertTrue(isinstance(etree.LXML_VERSION[1], int))\n        self.assertTrue(isinstance(etree.LXML_VERSION[2], int))\n        self.assertTrue(isinstance(etree.LXML_VERSION[3], int))\n        self.assertTrue(etree.__version__.startswith(\n            str(etree.LXML_VERSION[0])))\n\n    def test_c_api(self):\n        if hasattr(self.etree, '__pyx_capi__'):\n            # newer Pyrex compatible C-API\n            self.assertTrue(isinstance(self.etree.__pyx_capi__, dict))\n            self.assertTrue(len(self.etree.__pyx_capi__) > 0)\n        else:\n            # older C-API mechanism\n            self.assertTrue(hasattr(self.etree, '_import_c_api'))\n\n    def test_include_paths(self):\n        import lxml\n        includes = lxml.get_include()\n        self.assertTrue(includes)\n        self.assertTrue(len(includes) >= 2)\n        self.assertTrue(os.path.join(os.path.dirname(lxml.__file__), 'includes') in includes,\n                        includes)\n\n    def test_element_names(self):\n        Element = self.etree.Element\n        el = Element('name')\n        self.assertEqual(el.tag, 'name')\n        el = Element('{}name')\n        self.assertEqual(el.tag, 'name')\n\n    def test_element_name_empty(self):\n        Element = self.etree.Element\n        el = Element('name')\n        self.assertRaises(ValueError, Element, '{}')\n        self.assertRaises(ValueError, setattr, el, 'tag', '{}')\n\n        self.assertRaises(ValueError, Element, '{test}')\n        self.assertRaises(ValueError, setattr, el, 'tag', '{test}')\n\n    def test_element_name_colon(self):\n        Element = self.etree.Element\n        self.assertRaises(ValueError, Element, 'p:name')\n        self.assertRaises(ValueError, Element, '{test}p:name')\n\n        el = Element('name')\n        self.assertRaises(ValueError, setattr, el, 'tag', 'p:name')\n\n    def test_element_name_quote(self):\n        Element = self.etree.Element\n        self.assertRaises(ValueError, Element, \"p'name\")\n        self.assertRaises(ValueError, Element, 'p\"name')\n\n        self.assertRaises(ValueError, Element, \"{test}p'name\")\n        self.assertRaises(ValueError, Element, '{test}p\"name')\n\n        el = Element('name')\n        self.assertRaises(ValueError, setattr, el, 'tag', \"p'name\")\n        self.assertRaises(ValueError, setattr, el, 'tag', 'p\"name')\n\n    def test_element_name_space(self):\n        Element = self.etree.Element\n        self.assertRaises(ValueError, Element, ' name ')\n        self.assertRaises(ValueError, Element, 'na me')\n        self.assertRaises(ValueError, Element, '{test} name')\n\n        el = Element('name')\n        self.assertRaises(ValueError, setattr, el, 'tag', ' name ')\n\n    def test_subelement_name_empty(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        el = Element('name')\n        self.assertRaises(ValueError, SubElement, el, '{}')\n        self.assertRaises(ValueError, SubElement, el, '{test}')\n\n    def test_subelement_name_colon(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        el = Element('name')\n        self.assertRaises(ValueError, SubElement, el, 'p:name')\n        self.assertRaises(ValueError, SubElement, el, '{test}p:name')\n\n    def test_subelement_name_quote(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        el = Element('name')\n        self.assertRaises(ValueError, SubElement, el, \"p'name\")\n        self.assertRaises(ValueError, SubElement, el, \"{test}p'name\")\n\n        self.assertRaises(ValueError, SubElement, el, 'p\"name')\n        self.assertRaises(ValueError, SubElement, el, '{test}p\"name')\n\n    def test_subelement_name_space(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        el = Element('name')\n        self.assertRaises(ValueError, SubElement, el, ' name ')\n        self.assertRaises(ValueError, SubElement, el, 'na me')\n        self.assertRaises(ValueError, SubElement, el, '{test} name')\n\n    def test_subelement_attribute_invalid(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        el = Element('name')\n        self.assertRaises(ValueError, SubElement, el, 'name', {'a b c' : 'abc'})\n        self.assertRaises(ValueError, SubElement, el, 'name', {'a' : 'a\\0\\n'})\n        self.assertEqual(0, len(el))\n\n    def test_qname_empty(self):\n        QName = self.etree.QName\n        self.assertRaises(ValueError, QName, '')\n        self.assertRaises(ValueError, QName, None)\n        self.assertRaises(ValueError, QName, None, None)\n        self.assertRaises(ValueError, QName, 'test', '')\n\n    def test_qname_none(self):\n        QName = self.etree.QName\n        q = QName(None, 'TAG')\n        self.assertEqual('TAG', q)\n        self.assertEqual('TAG', q.localname)\n        self.assertEqual(None, q.namespace)\n\n    def test_qname_colon(self):\n        QName = self.etree.QName\n        self.assertRaises(ValueError, QName, 'p:name')\n        self.assertRaises(ValueError, QName, 'test', 'p:name')\n\n    def test_qname_space(self):\n        QName = self.etree.QName\n        self.assertRaises(ValueError, QName, ' name ')\n        self.assertRaises(ValueError, QName, 'na me')\n        self.assertRaises(ValueError, QName, 'test', ' name')\n\n    def test_qname_namespace_localname(self):\n        # ET doesn't have namespace/localname properties on QNames\n        QName = self.etree.QName\n        namespace, localname = 'http://myns', 'a'\n        qname = QName(namespace, localname)\n        self.assertEqual(namespace, qname.namespace)\n        self.assertEqual(localname, qname.localname)\n\n    def test_qname_element(self):\n        # ET doesn't have namespace/localname properties on QNames\n        QName = self.etree.QName\n        qname1 = QName('http://myns', 'a')\n        a = self.etree.Element(qname1, nsmap={'p' : 'http://myns'})\n\n        qname2 = QName(a)\n        self.assertEqual(a.tag, qname1.text)\n        self.assertEqual(a.tag, qname1)\n        self.assertEqual(qname1.text, qname2.text)\n        self.assertEqual(qname1, qname2.text)\n        self.assertEqual(qname1.text, qname2)\n        self.assertEqual(qname1, qname2)\n\n    def test_qname_text_resolve(self):\n        # ET doesn't resove QNames as text values\n        etree = self.etree\n        qname = etree.QName('http://myns', 'a')\n        a = etree.Element(qname, nsmap={'p' : 'http://myns'})\n        a.text = qname\n\n        self.assertEqual(\"p:a\", a.text)\n\n    def test_nsmap_prefix_invalid(self):\n        etree = self.etree\n        self.assertRaises(ValueError,\n                          etree.Element, \"root\", nsmap={'\"' : 'testns'})\n        self.assertRaises(ValueError,\n                          etree.Element, \"root\", nsmap={'&' : 'testns'})\n        self.assertRaises(ValueError,\n                          etree.Element, \"root\", nsmap={'a:b' : 'testns'})\n\n    def test_clear_keep_tail(self):\n        XML = self.etree.XML\n        tostring = self.etree.tostring\n        a = XML('<a aa=\"A\"><b ba=\"B\">B1</b>B2<c ca=\"C\">C1</c>C2</a>')\n        a[0].clear(keep_tail=True)\n        self.assertEqual(_bytes('<a aa=\"A\"><b/>B2<c ca=\"C\">C1</c>C2</a>'), tostring(a))\n\n    def test_attribute_has_key(self):\n        # ET in Py 3.x has no \"attrib.has_key()\" method\n        XML = self.etree.XML\n\n        root = XML(_bytes('<foo bar=\"Bar\" xmlns:ns=\"http://ns.codespeak.net/test\" ns:baz=\"Baz\" />'))\n        self.assertEqual(\n            True, root.attrib.has_key('bar'))\n        self.assertEqual(\n            False, root.attrib.has_key('baz'))\n        self.assertEqual(\n            False, root.attrib.has_key('hah'))\n        self.assertEqual(\n            True,\n            root.attrib.has_key('{http://ns.codespeak.net/test}baz'))\n\n    def test_attribute_set(self):\n        Element = self.etree.Element\n        root = Element(\"root\")\n        root.set(\"attr\", \"TEST\")\n        self.assertEqual(\"TEST\", root.get(\"attr\"))\n\n    def test_attribute_set_nonstring(self):\n        # ElementTree accepts arbitrary attribute values\n        # lxml.etree allows only strings\n        Element = self.etree.Element\n\n        root = Element(\"root\")\n        root.set(\"attr\", \"TEST\")\n        self.assertEqual(\"TEST\", root.get(\"attr\"))\n        self.assertRaises(TypeError, root.set, \"newattr\", 5)\n\n    def test_attrib_and_keywords(self):\n        Element = self.etree.Element\n\n        root = Element(\"root\")\n        root.set(\"attr\", \"TEST\")\n        self.assertEqual(\"TEST\", root.attrib[\"attr\"])\n\n        root2 = Element(\"root2\", root.attrib, attr2='TOAST')\n        self.assertEqual(\"TEST\", root2.attrib[\"attr\"])\n        self.assertEqual(\"TOAST\", root2.attrib[\"attr2\"])\n        self.assertEqual(None, root.attrib.get(\"attr2\"))\n\n    def test_attrib_order(self):\n        Element = self.etree.Element\n\n        keys = [\"attr%d\" % i for i in range(12, 4, -1)]\n        values = [\"TEST-%d\" % i for i in range(12, 4, -1)]\n        items = list(zip(keys, values))\n\n        root = Element(\"root\")\n        for key, value in items:\n            root.set(key, value)\n        self.assertEqual(keys, root.attrib.keys())\n        self.assertEqual(values, root.attrib.values())\n\n        attr_order = [\n            ('attr_99', 'TOAST-1'),\n            ('attr_98', 'TOAST-2'),\n        ]\n        ordered_dict_types = [OrderedDict, lambda x:x]\n        if sys.version_info >= (3, 6):\n            ordered_dict_types.append(dict)\n        else:\n            # Keyword arguments are not ordered in Py<3.6, and thus get sorted.\n            attr_order.sort()\n        attr_order += items\n        expected_keys = [attr[0] for attr in attr_order]\n        expected_values = [attr[1] for attr in attr_order]\n        expected_items = list(zip(expected_keys, expected_values))\n\n        for dict_type in ordered_dict_types:\n            root2 = Element(\"root2\", dict_type(root.attrib),\n                            attr_99='TOAST-1', attr_98='TOAST-2')\n\n            try:\n                self.assertSequenceEqual(expected_keys, root2.attrib.keys())\n                self.assertSequenceEqual(expected_values, root2.attrib.values())\n                self.assertSequenceEqual(expected_items, root2.attrib.items())\n            except AssertionError as exc:\n                exc.args = (\"Order of '%s': %s\" % (dict_type.__name__, exc.args[0]),) + exc.args[1:]\n                raise\n\n        self.assertEqual(keys, root.attrib.keys())\n        self.assertEqual(values, root.attrib.values())\n\n    def test_attribute_set_invalid(self):\n        # ElementTree accepts arbitrary attribute values\n        # lxml.etree allows only strings, or None for (html5) boolean attributes\n        Element = self.etree.Element\n        root = Element(\"root\")\n        self.assertRaises(TypeError, root.set, \"newattr\", 5)\n        self.assertRaises(TypeError, root.set, \"newattr\", object)\n        self.assertRaises(TypeError, root.set, \"newattr\", None)\n        self.assertRaises(TypeError, root.set, \"newattr\")\n\n    def test_strip_attributes(self):\n        XML = self.etree.XML\n        xml = _bytes('<test a=\"5\" b=\"10\" c=\"20\"><x a=\"4\" b=\"2\"/></test>')\n\n        root = XML(xml)\n        self.etree.strip_attributes(root, 'a')\n        self.assertEqual(_bytes('<test b=\"10\" c=\"20\"><x b=\"2\"></x></test>'),\n                          self._writeElement(root))\n\n        root = XML(xml)\n        self.etree.strip_attributes(root, 'b', 'c')\n        self.assertEqual(_bytes('<test a=\"5\"><x a=\"4\"></x></test>'),\n                          self._writeElement(root))\n\n    def test_strip_attributes_ns(self):\n        XML = self.etree.XML\n        xml = _bytes('<test xmlns:n=\"http://test/ns\" a=\"6\" b=\"10\" c=\"20\" n:a=\"5\"><x a=\"4\" n:b=\"2\"/></test>')\n\n        root = XML(xml)\n        self.etree.strip_attributes(root, 'a')\n        self.assertEqual(\n            _bytes('<test xmlns:n=\"http://test/ns\" b=\"10\" c=\"20\" n:a=\"5\"><x n:b=\"2\"></x></test>'),\n            self._writeElement(root))\n\n        root = XML(xml)\n        self.etree.strip_attributes(root, '{http://test/ns}a', 'c')\n        self.assertEqual(\n            _bytes('<test xmlns:n=\"http://test/ns\" a=\"6\" b=\"10\"><x a=\"4\" n:b=\"2\"></x></test>'),\n            self._writeElement(root))\n\n        root = XML(xml)\n        self.etree.strip_attributes(root, '{http://test/ns}*')\n        self.assertEqual(\n            _bytes('<test xmlns:n=\"http://test/ns\" a=\"6\" b=\"10\" c=\"20\"><x a=\"4\"></x></test>'),\n            self._writeElement(root))\n\n    def test_strip_elements(self):\n        XML = self.etree.XML\n        xml = _bytes('<test><a><b><c/></b></a><x><a><b/><c/></a></x></test>')\n\n        root = XML(xml)\n        self.etree.strip_elements(root, 'a')\n        self.assertEqual(_bytes('<test><x></x></test>'),\n                          self._writeElement(root))\n\n        root = XML(xml)\n        self.etree.strip_elements(root, 'b', 'c', 'X', 'Y', 'Z')\n        self.assertEqual(_bytes('<test><a></a><x><a></a></x></test>'),\n                          self._writeElement(root))\n\n        root = XML(xml)\n        self.etree.strip_elements(root, 'c')\n        self.assertEqual(_bytes('<test><a><b></b></a><x><a><b></b></a></x></test>'),\n                          self._writeElement(root))\n\n    def test_strip_elements_ns(self):\n        XML = self.etree.XML\n        xml = _bytes('<test>TEST<n:a xmlns:n=\"urn:a\">A<b>B<c xmlns=\"urn:c\"/>C</b>BT</n:a>AT<x>X<a>A<b xmlns=\"urn:a\"/>BT<c xmlns=\"urn:x\"/>CT</a>AT</x>XT</test>')\n\n        root = XML(xml)\n        self.etree.strip_elements(root, 'a')\n        self.assertEqual(_bytes('<test>TEST<n:a xmlns:n=\"urn:a\">A<b>B<c xmlns=\"urn:c\"></c>C</b>BT</n:a>AT<x>X</x>XT</test>'),\n                          self._writeElement(root))\n\n        root = XML(xml)\n        self.etree.strip_elements(root, '{urn:a}b', 'c')\n        self.assertEqual(_bytes('<test>TEST<n:a xmlns:n=\"urn:a\">A<b>B<c xmlns=\"urn:c\"></c>C</b>BT</n:a>AT<x>X<a>A<c xmlns=\"urn:x\"></c>CT</a>AT</x>XT</test>'),\n                          self._writeElement(root))\n\n        root = XML(xml)\n        self.etree.strip_elements(root, '{urn:a}*', 'c')\n        self.assertEqual(_bytes('<test>TEST<x>X<a>A<c xmlns=\"urn:x\"></c>CT</a>AT</x>XT</test>'),\n                          self._writeElement(root))\n\n        root = XML(xml)\n        self.etree.strip_elements(root, '{urn:a}*', 'c', with_tail=False)\n        self.assertEqual(_bytes('<test>TESTAT<x>X<a>ABT<c xmlns=\"urn:x\"></c>CT</a>AT</x>XT</test>'),\n                          self._writeElement(root))\n\n    def test_strip_tags(self):\n        XML = self.etree.XML\n        xml = _bytes('<test>TEST<a>A<b>B<c/>CT</b>BT</a>AT<x>X<a>A<b/>BT<c/>CT</a>AT</x>XT</test>')\n\n        root = XML(xml)\n        self.etree.strip_tags(root, 'a')\n        self.assertEqual(_bytes('<test>TESTA<b>B<c></c>CT</b>BTAT<x>XA<b></b>BT<c></c>CTAT</x>XT</test>'),\n                          self._writeElement(root))\n\n        root = XML(xml)\n        self.etree.strip_tags(root, 'b', 'c', 'X', 'Y', 'Z')\n        self.assertEqual(_bytes('<test>TEST<a>ABCTBT</a>AT<x>X<a>ABTCT</a>AT</x>XT</test>'),\n                          self._writeElement(root))\n\n        root = XML(xml)\n        self.etree.strip_tags(root, 'c')\n        self.assertEqual(_bytes('<test>TEST<a>A<b>BCT</b>BT</a>AT<x>X<a>A<b></b>BTCT</a>AT</x>XT</test>'),\n                          self._writeElement(root))\n\n    def test_strip_tags_pi_comment(self):\n        XML = self.etree.XML\n        PI = self.etree.ProcessingInstruction\n        Comment = self.etree.Comment\n        xml = _bytes('<!--comment1-->\\n<?PI1?>\\n<test>TEST<!--comment2-->XT<?PI2?></test>\\n<!--comment3-->\\n<?PI1?>')\n\n        root = XML(xml)\n        self.etree.strip_tags(root, PI)\n        self.assertEqual(_bytes('<!--comment1-->\\n<?PI1?>\\n<test>TEST<!--comment2-->XT</test>\\n<!--comment3-->\\n<?PI1?>'),\n                          self._writeElement(root))\n\n        root = XML(xml)\n        self.etree.strip_tags(root, Comment)\n        self.assertEqual(_bytes('<!--comment1-->\\n<?PI1?>\\n<test>TESTXT<?PI2?></test>\\n<!--comment3-->\\n<?PI1?>'),\n                          self._writeElement(root))\n\n        root = XML(xml)\n        self.etree.strip_tags(root, PI, Comment)\n        self.assertEqual(_bytes('<!--comment1-->\\n<?PI1?>\\n<test>TESTXT</test>\\n<!--comment3-->\\n<?PI1?>'),\n                          self._writeElement(root))\n\n        root = XML(xml)\n        self.etree.strip_tags(root, Comment, PI)\n        self.assertEqual(_bytes('<!--comment1-->\\n<?PI1?>\\n<test>TESTXT</test>\\n<!--comment3-->\\n<?PI1?>'),\n                          self._writeElement(root))\n\n    def test_strip_tags_pi_comment_all(self):\n        XML = self.etree.XML\n        ElementTree = self.etree.ElementTree\n        PI = self.etree.ProcessingInstruction\n        Comment = self.etree.Comment\n        xml = _bytes('<!--comment1-->\\n<?PI1?>\\n<test>TEST<!--comment2-->XT<?PI2?></test>\\n<!--comment3-->\\n<?PI1?>')\n\n        root = XML(xml)\n        self.etree.strip_tags(ElementTree(root), PI)\n        self.assertEqual(_bytes('<!--comment1-->\\n<test>TEST<!--comment2-->XT</test>\\n<!--comment3-->'),\n                          self._writeElement(root))\n\n        root = XML(xml)\n        self.etree.strip_tags(ElementTree(root), Comment)\n        self.assertEqual(_bytes('<?PI1?>\\n<test>TESTXT<?PI2?></test>\\n<?PI1?>'),\n                          self._writeElement(root))\n\n        root = XML(xml)\n        self.etree.strip_tags(ElementTree(root), PI, Comment)\n        self.assertEqual(_bytes('<test>TESTXT</test>'),\n                          self._writeElement(root))\n\n        root = XML(xml)\n        self.etree.strip_tags(ElementTree(root), Comment, PI)\n        self.assertEqual(_bytes('<test>TESTXT</test>'),\n                          self._writeElement(root))\n\n    def test_strip_tags_doc_style(self):\n        XML = self.etree.XML\n        xml = _bytes('''\n        <div>\n            <div>\n                I like <strong>sheep</strong>.\n                <br/>\n                I like lots of <strong>sheep</strong>.\n                <br/>\n                Click <a href=\"http://www.sheep.com\">here</a>\n                 for <a href=\"http://www.sheep.com\">those</a> sheep.\n                <br/>\n            </div>\n        </div>\n        '''.strip())\n\n        root = XML(xml)\n        self.etree.strip_tags(root, 'a')\n        self.assertEqual(re.sub(_bytes('</?a[^>]*>'), _bytes(''), xml).replace(_bytes('<br/>'), _bytes('<br></br>')),\n                          self._writeElement(root))\n\n        root = XML(xml)\n        self.etree.strip_tags(root, 'a', 'br')\n        self.assertEqual(re.sub(_bytes('</?a[^>]*>'), _bytes(''),\n                                 re.sub(_bytes('<br[^>]*>'), _bytes(''), xml)),\n                          self._writeElement(root))\n\n    def test_strip_tags_ns(self):\n        XML = self.etree.XML\n        xml = _bytes('<test>TEST<n:a xmlns:n=\"urn:a\">A<b>B<c xmlns=\"urn:c\"/>CT</b>BT</n:a>AT<x>X<a>A<b xmlns=\"urn:a\"/>BT<c xmlns=\"urn:x\"/>CT</a>AT</x>XT</test>')\n\n        root = XML(xml)\n        self.etree.strip_tags(root, 'a')\n        self.assertEqual(_bytes('<test>TEST<n:a xmlns:n=\"urn:a\">A<b>B<c xmlns=\"urn:c\"></c>CT</b>BT</n:a>AT<x>XA<b xmlns=\"urn:a\"></b>BT<c xmlns=\"urn:x\"></c>CTAT</x>XT</test>'),\n                          self._writeElement(root))\n\n        root = XML(xml)\n        self.etree.strip_tags(root, '{urn:a}b', 'c')\n        self.assertEqual(_bytes('<test>TEST<n:a xmlns:n=\"urn:a\">A<b>B<c xmlns=\"urn:c\"></c>CT</b>BT</n:a>AT<x>X<a>ABT<c xmlns=\"urn:x\"></c>CT</a>AT</x>XT</test>'),\n                          self._writeElement(root))\n\n        root = XML(xml)\n        self.etree.strip_tags(root, '{urn:a}*', 'c')\n        self.assertEqual(_bytes('<test>TESTA<b>B<c xmlns=\"urn:c\"></c>CT</b>BTAT<x>X<a>ABT<c xmlns=\"urn:x\"></c>CT</a>AT</x>XT</test>'),\n                          self._writeElement(root))\n\n    def test_strip_tags_and_remove(self):\n        # previously crashed\n        HTML = self.etree.HTML\n        root = HTML(_bytes('<div><h1>title</h1> <b>foo</b> <p>boo</p></div>'))[0][0]\n        self.assertEqual(_bytes('<div><h1>title</h1> <b>foo</b> <p>boo</p></div>'),\n                          self.etree.tostring(root))\n        self.etree.strip_tags(root, 'b')\n        self.assertEqual(_bytes('<div><h1>title</h1> foo <p>boo</p></div>'),\n                          self.etree.tostring(root))\n        root.remove(root[0])\n        self.assertEqual(_bytes('<div><p>boo</p></div>'),\n                          self.etree.tostring(root))\n\n    def test_pi(self):\n        # lxml.etree separates target and text\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        ProcessingInstruction = self.etree.ProcessingInstruction\n\n        a = Element('a')\n        a.append(ProcessingInstruction('foo', 'some more text'))\n        self.assertEqual(a[0].target, 'foo')\n        self.assertEqual(a[0].text, 'some more text')\n\n    def test_pi_parse(self):\n        XML = self.etree.XML\n        root = XML(_bytes(\"<test><?mypi my test ?></test>\"))\n        self.assertEqual(root[0].target, \"mypi\")\n        self.assertEqual(root[0].text, \"my test \")\n\n    def test_pi_pseudo_attributes_get(self):\n        XML = self.etree.XML\n        root = XML(_bytes(\"<test><?mypi my='1' test=\\\" abc \\\" quotes=\\\"' '\\\" only names ?></test>\"))\n        self.assertEqual(root[0].target, \"mypi\")\n        self.assertEqual(root[0].get('my'), \"1\")\n        self.assertEqual(root[0].get('test'), \" abc \")\n        self.assertEqual(root[0].get('quotes'), \"' '\")\n        self.assertEqual(root[0].get('only'), None)\n        self.assertEqual(root[0].get('names'), None)\n        self.assertEqual(root[0].get('nope'), None)\n\n    def test_pi_pseudo_attributes_attrib(self):\n        XML = self.etree.XML\n        root = XML(_bytes(\"<test><?mypi my='1' test=\\\" abc \\\" quotes=\\\"' '\\\" only names ?></test>\"))\n        self.assertEqual(root[0].target, \"mypi\")\n        self.assertEqual(root[0].attrib['my'], \"1\")\n        self.assertEqual(root[0].attrib['test'], \" abc \")\n        self.assertEqual(root[0].attrib['quotes'], \"' '\")\n        self.assertRaises(KeyError, root[0].attrib.__getitem__, 'only')\n        self.assertRaises(KeyError, root[0].attrib.__getitem__, 'names')\n        self.assertRaises(KeyError, root[0].attrib.__getitem__, 'nope')\n\n    def test_deepcopy_pi(self):\n        # previously caused a crash\n        ProcessingInstruction = self.etree.ProcessingInstruction\n        \n        a = ProcessingInstruction(\"PI\", \"ONE\")\n        b = copy.deepcopy(a)\n        b.text = \"ANOTHER\"\n\n        self.assertEqual('ONE',     a.text)\n        self.assertEqual('ANOTHER', b.text)\n\n    def test_deepcopy_elementtree_pi(self):\n        XML = self.etree.XML\n        tostring = self.etree.tostring\n        root = XML(_bytes(\"<?mypi my test ?><test/><!--comment -->\"))\n        tree1 = self.etree.ElementTree(root)\n        self.assertEqual(_bytes(\"<?mypi my test ?><test/><!--comment -->\"),\n                          tostring(tree1))\n\n        tree2 = copy.deepcopy(tree1)\n        self.assertEqual(_bytes(\"<?mypi my test ?><test/><!--comment -->\"),\n                          tostring(tree2))\n\n        root2 = copy.deepcopy(tree1.getroot())\n        self.assertEqual(_bytes(\"<test/>\"),\n                          tostring(root2))\n\n    def test_deepcopy_elementtree_dtd(self):\n        XML = self.etree.XML\n        tostring = self.etree.tostring\n        xml = _bytes('<!DOCTYPE test [\\n<!ENTITY entity \"tasty\">\\n]>\\n<test/>')\n        root = XML(xml)\n        tree1 = self.etree.ElementTree(root)\n        self.assertEqual(xml, tostring(tree1))\n\n        tree2 = copy.deepcopy(tree1)\n        self.assertEqual(xml, tostring(tree2))\n\n        root2 = copy.deepcopy(tree1.getroot())\n        self.assertEqual(_bytes(\"<test/>\"),\n                          tostring(root2))\n\n    def test_deepcopy_pi_dtd(self):\n        XML = self.etree.XML\n        tostring = self.etree.tostring\n        xml = _bytes('<!-- comment --><!DOCTYPE test [\\n<!ENTITY entity \"tasty\">\\n]>\\n<test/>')\n        root = XML(xml)\n        tree1 = self.etree.ElementTree(root)\n        self.assertEqual(xml, tostring(tree1))\n\n        tree2 = copy.deepcopy(tree1)\n        self.assertEqual(xml, tostring(tree2))\n\n    def test_parse_remove_comments(self):\n        fromstring = self.etree.fromstring\n        tostring = self.etree.tostring\n        XMLParser = self.etree.XMLParser\n\n        xml = _bytes('<a><!--A--><b><!-- B --><c/></b><!--C--></a>')\n        parser = XMLParser(remove_comments=True)\n        root = fromstring(xml, parser)\n        self.assertEqual(\n            _bytes('<a><b><c/></b></a>'),\n            tostring(root))\n\n    def test_parse_remove_pis(self):\n        parse = self.etree.parse\n        tostring = self.etree.tostring\n        XMLParser = self.etree.XMLParser\n\n        xml = _bytes('<?test?><a><?A?><b><?B?><c/></b><?C?></a><?tail?>')\n\n        f = BytesIO(xml)\n        tree = parse(f)\n        self.assertEqual(\n            xml,\n            tostring(tree))\n\n        parser = XMLParser(remove_pis=True)\n        tree = parse(f, parser)\n        self.assertEqual(\n            _bytes('<a><b><c/></b></a>'),\n            tostring(tree))\n\n    def test_parse_parser_type_error(self):\n        # ET raises IOError only\n        parse = self.etree.parse\n        self.assertRaises(TypeError, parse, 'notthere.xml', object())\n\n    def test_iterparse_getiterator(self):\n        iterparse = self.etree.iterparse\n        f = BytesIO('<a><b><d/></b><c/></a>')\n\n        counts = []\n        for event, elem in iterparse(f):\n            counts.append(len(list(elem.getiterator())))\n        self.assertEqual(\n            [1,2,1,4],\n            counts)\n\n    def test_iterparse_tree_comments(self):\n        # ET removes comments\n        iterparse = self.etree.iterparse\n        tostring = self.etree.tostring\n\n        f = BytesIO('<a><!--A--><b><!-- B --><c/></b><!--C--></a>')\n        events = list(iterparse(f))\n        root = events[-1][1]\n        self.assertEqual(3, len(events))\n        self.assertEqual(\n            _bytes('<a><!--A--><b><!-- B --><c/></b><!--C--></a>'),\n            tostring(root))\n\n    def test_iterparse_comments(self):\n        # ET removes comments\n        iterparse = self.etree.iterparse\n        tostring = self.etree.tostring\n\n        def name(event, el):\n            if event == 'comment':\n                return el.text\n            else:\n                return el.tag\n\n        f = BytesIO('<a><!--A--><b><!-- B --><c/></b><!--C--></a>')\n        events = list(iterparse(f, events=('end', 'comment')))\n        root = events[-1][1]\n        self.assertEqual(6, len(events))\n        self.assertEqual(['A', ' B ', 'c', 'b', 'C', 'a'],\n                          [ name(*item) for item in events ])\n        self.assertEqual(\n            _bytes('<a><!--A--><b><!-- B --><c/></b><!--C--></a>'),\n            tostring(root))\n\n    def test_iterparse_pis(self):\n        # ET removes pis\n        iterparse = self.etree.iterparse\n        tostring = self.etree.tostring\n        ElementTree = self.etree.ElementTree\n\n        def name(event, el):\n            if event == 'pi':\n                return el.target, el.text\n            else:\n                return el.tag\n\n        f = BytesIO('<?pia a?><a><?pib b?><b><?pic c?><c/></b><?pid d?></a><?pie e?>')\n        events = list(iterparse(f, events=('end', 'pi')))\n        root = events[-2][1]\n        self.assertEqual(8, len(events))\n        self.assertEqual([('pia','a'), ('pib','b'), ('pic','c'), 'c', 'b',\n                           ('pid','d'), 'a', ('pie','e')],\n                          [ name(*item) for item in events ])\n        self.assertEqual(\n            _bytes('<?pia a?><a><?pib b?><b><?pic c?><c/></b><?pid d?></a><?pie e?>'),\n            tostring(ElementTree(root)))\n\n    def test_iterparse_remove_comments(self):\n        iterparse = self.etree.iterparse\n        tostring = self.etree.tostring\n\n        f = BytesIO('<a><!--A--><b><!-- B --><c/></b><!--C--></a>')\n        events = list(iterparse(f, remove_comments=True,\n                                events=('end', 'comment')))\n        root = events[-1][1]\n        self.assertEqual(3, len(events))\n        self.assertEqual(['c', 'b', 'a'],\n                          [ el.tag for (event, el) in events ])\n        self.assertEqual(\n            _bytes('<a><b><c/></b></a>'),\n            tostring(root))\n\n    def test_iterparse_broken(self):\n        iterparse = self.etree.iterparse\n        f = BytesIO('<a><b><c/></a>')\n        # ET raises ExpatError, lxml raises XMLSyntaxError\n        self.assertRaises(self.etree.XMLSyntaxError, list, iterparse(f))\n\n    def test_iterparse_broken_recover(self):\n        iterparse = self.etree.iterparse\n        f = BytesIO('<a><b><c/></a>')\n        it = iterparse(f, events=('start', 'end'), recover=True)\n        events = [(ev, el.tag) for ev, el in it]\n        root = it.root\n        self.assertTrue(root is not None)\n\n        self.assertEqual(1, events.count(('start', 'a')))\n        self.assertEqual(1, events.count(('end', 'a')))\n\n        self.assertEqual(1, events.count(('start', 'b')))\n        self.assertEqual(1, events.count(('end', 'b')))\n\n        self.assertEqual(1, events.count(('start', 'c')))\n        self.assertEqual(1, events.count(('end', 'c')))\n\n    def test_iterparse_broken_multi_recover(self):\n        iterparse = self.etree.iterparse\n        f = BytesIO('<a><b><c/></d><b><c/></a></b>')\n        it = iterparse(f, events=('start', 'end'), recover=True)\n        events = [(ev, el.tag) for ev, el in it]\n        root = it.root\n        self.assertTrue(root is not None)\n\n        self.assertEqual(1, events.count(('start', 'a')))\n        self.assertEqual(1, events.count(('end', 'a')))\n\n        self.assertEqual(2, events.count(('start', 'b')))\n        self.assertEqual(2, events.count(('end', 'b')))\n\n        self.assertEqual(2, events.count(('start', 'c')))\n        self.assertEqual(2, events.count(('end', 'c')))\n\n    def test_iterparse_strip(self):\n        iterparse = self.etree.iterparse\n        f = BytesIO(\"\"\"\n               <a>  \\n \\n  <b> b test </b>  \\n\n\n               \\n\\t <c> \\n </c> </a>  \\n \"\"\")\n        iterator = iterparse(f, remove_blank_text=True)\n        text = [ (element.text, element.tail)\n                 for event, element in iterator ]\n        self.assertEqual(\n            [(\" b test \", None), (\" \\n \", None), (None, None)],\n            text)\n\n    def test_iterparse_tag(self):\n        iterparse = self.etree.iterparse\n        f = BytesIO('<a><b><d/></b><c/></a>')\n\n        iterator = iterparse(f, tag=\"b\", events=('start', 'end'))\n        events = list(iterator)\n        root = iterator.root\n        self.assertEqual(\n            [('start', root[0]), ('end', root[0])],\n            events)\n\n    def test_iterparse_tag_all(self):\n        iterparse = self.etree.iterparse\n        f = BytesIO('<a><b><d/></b><c/></a>')\n\n        iterator = iterparse(f, tag=\"*\", events=('start', 'end'))\n        events = list(iterator)\n        self.assertEqual(\n            8,\n            len(events))\n\n    def test_iterparse_tag_ns(self):\n        iterparse = self.etree.iterparse\n        f = BytesIO('<a xmlns=\"urn:test:1\"><b><d/></b><c/></a>')\n\n        iterator = iterparse(f, tag=\"{urn:test:1}b\", events=('start', 'end'))\n        events = list(iterator)\n        root = iterator.root\n        self.assertEqual(\n            [('start', root[0]), ('end', root[0])],\n            events)\n\n    def test_iterparse_tag_ns_empty(self):\n        iterparse = self.etree.iterparse\n        f = BytesIO('<a><b><d/></b><c/></a>')\n        iterator = iterparse(f, tag=\"{}b\", events=('start', 'end'))\n        events = list(iterator)\n        root = iterator.root\n        self.assertEqual(\n            [('start', root[0]), ('end', root[0])],\n            events)\n\n        f = BytesIO('<a xmlns=\"urn:test:1\"><b><d/></b><c/></a>')\n        iterator = iterparse(f, tag=\"{}b\", events=('start', 'end'))\n        events = list(iterator)\n        root = iterator.root\n        self.assertEqual([], events)\n\n    def test_iterparse_tag_ns_all(self):\n        iterparse = self.etree.iterparse\n        f = BytesIO('<a xmlns=\"urn:test:1\"><b><d/></b><c/></a>')\n        iterator = iterparse(f, tag=\"{urn:test:1}*\", events=('start', 'end'))\n        events = list(iterator)\n        self.assertEqual(8, len(events))\n\n    def test_iterparse_tag_ns_empty_all(self):\n        iterparse = self.etree.iterparse\n        f = BytesIO('<a xmlns=\"urn:test:1\"><b><d/></b><c/></a>')\n        iterator = iterparse(f, tag=\"{}*\", events=('start', 'end'))\n        events = list(iterator)\n        self.assertEqual([], events)\n\n        f = BytesIO('<a><b><d/></b><c/></a>')\n        iterator = iterparse(f, tag=\"{}*\", events=('start', 'end'))\n        events = list(iterator)\n        self.assertEqual(8, len(events))\n\n    def test_iterparse_encoding_error(self):\n        text = _str('S\u00f8k p\u00e5 nettet')\n        wrong_declaration = \"<?xml version='1.0' encoding='UTF-8'?>\"\n        xml_latin1 = (_str('%s<a>%s</a>') % (wrong_declaration, text)\n                      ).encode('iso-8859-1')\n\n        self.assertRaises(self.etree.ParseError,\n                          list, self.etree.iterparse(BytesIO(xml_latin1)))\n\n    def test_iterparse_encoding_8bit_override(self):\n        text = _str('S\u00f8k p\u00e5 nettet', encoding=\"UTF-8\")\n        wrong_declaration = \"<?xml version='1.0' encoding='UTF-8'?>\"\n        xml_latin1 = (_str('%s<a>%s</a>') % (wrong_declaration, text)\n                      ).encode('iso-8859-1')\n\n        iterator = self.etree.iterparse(BytesIO(xml_latin1),\n                                        encoding=\"iso-8859-1\")\n        self.assertEqual(1, len(list(iterator)))\n\n        a = iterator.root\n        self.assertEqual(a.text, text)\n\n    def test_iterparse_keep_cdata(self):\n        tostring = self.etree.tostring\n        f = BytesIO('<root><![CDATA[test]]></root>')\n        context = self.etree.iterparse(f, strip_cdata=False)\n        content = [ el.text for event,el in context ]\n\n        self.assertEqual(['test'], content)\n        self.assertEqual(_bytes('<root><![CDATA[test]]></root>'),\n                          tostring(context.root))\n\n    def test_parser_encoding_unknown(self):\n        self.assertRaises(\n            LookupError, self.etree.XMLParser, encoding=\"hopefully unknown\")\n\n    def test_parser_encoding(self):\n        self.etree.XMLParser(encoding=\"ascii\")\n        self.etree.XMLParser(encoding=\"utf-8\")\n        self.etree.XMLParser(encoding=\"iso-8859-1\")\n\n    def test_feed_parser_recover(self):\n        parser = self.etree.XMLParser(recover=True)\n\n        parser.feed('<?xml version=')\n        parser.feed('\"1.0\"?><ro')\n        parser.feed('ot><')\n        parser.feed('a test=\"works\"')\n        parser.feed('><othertag/></root') # <a> not closed!\n        parser.feed('>')\n\n        root = parser.close()\n\n        self.assertEqual(root.tag, \"root\")\n        self.assertEqual(len(root), 1)\n        self.assertEqual(root[0].tag, \"a\")\n        self.assertEqual(root[0].get(\"test\"), \"works\")\n        self.assertEqual(len(root[0]), 1)\n        self.assertEqual(root[0][0].tag, \"othertag\")\n        # FIXME: would be nice to get some errors logged ...\n        #self.assertTrue(len(parser.error_log) > 0, \"error log is empty\")\n\n    def test_feed_parser_recover_no_id_dict(self):\n        # test that recover mode plays nicely with the no-id-dict setup\n        parser = self.etree.XMLParser(recover=True, collect_ids=False)\n\n        parser.feed('<?xml version=')\n        parser.feed('\"1.0\"?><ro')\n        parser.feed('ot xml:id=\"123\"><')\n        parser.feed('a test=\"works\" xml:id=')\n        parser.feed('\"321\"><othertag/></root') # <a> not closed!\n        parser.feed('>')\n\n        root = parser.close()\n\n        self.assertEqual(root.tag, \"root\")\n        self.assertEqual(len(root), 1)\n        self.assertEqual(root[0].tag, \"a\")\n        self.assertEqual(root[0].get(\"test\"), \"works\")\n        self.assertEqual(root[0].attrib, {\n            'test': 'works',\n            '{http://www.w3.org/XML/1998/namespace}id': '321'})\n        self.assertEqual(len(root[0]), 1)\n        self.assertEqual(root[0][0].tag, \"othertag\")\n        # FIXME: would be nice to get some errors logged ...\n        #self.assertTrue(len(parser.error_log) > 0, \"error log is empty\")\n\n    def test_elementtree_parser_target_type_error(self):\n        assertEqual = self.assertEqual\n        assertFalse  = self.assertFalse\n\n        events = []\n        class Target(object):\n            def start(self, tag, attrib):\n                events.append(\"start\")\n                assertFalse(attrib)\n                assertEqual(\"TAG\", tag)\n            def end(self, tag):\n                events.append(\"end\")\n                assertEqual(\"TAG\", tag)\n            def close(self):\n                return \"DONE\" # no Element!\n\n        parser = self.etree.XMLParser(target=Target())\n        tree = self.etree.ElementTree()\n\n        self.assertRaises(TypeError,\n                          tree.parse, BytesIO(\"<TAG/>\"), parser=parser)\n        self.assertEqual([\"start\", \"end\"], events)\n\n    def test_parser_target_feed_exception(self):\n        # ET doesn't call .close() on errors\n        events = []\n        class Target(object):\n            def start(self, tag, attrib):\n                events.append(\"start-\" + tag)\n            def end(self, tag):\n                events.append(\"end-\" + tag)\n                if tag == 'a':\n                    raise ValueError(\"dead and gone\")\n            def data(self, data):\n                events.append(\"data-\" + data)\n            def close(self):\n                events.append(\"close\")\n                return \"DONE\"\n\n        parser = self.etree.XMLParser(target=Target())\n\n        try:\n            parser.feed(_bytes('<root>A<a>ca</a>B</root>'))\n            done = parser.close()\n            self.fail(\"error expected, but parsing succeeded\")\n        except ValueError:\n            done = 'value error received as expected'\n\n        self.assertEqual([\"start-root\", \"data-A\", \"start-a\",\n                           \"data-ca\", \"end-a\", \"close\"],\n                          events)\n\n    def test_parser_target_fromstring_exception(self):\n        # ET doesn't call .close() on errors\n        events = []\n        class Target(object):\n            def start(self, tag, attrib):\n                events.append(\"start-\" + tag)\n            def end(self, tag):\n                events.append(\"end-\" + tag)\n                if tag == 'a':\n                    raise ValueError(\"dead and gone\")\n            def data(self, data):\n                events.append(\"data-\" + data)\n            def close(self):\n                events.append(\"close\")\n                return \"DONE\"\n\n        parser = self.etree.XMLParser(target=Target())\n\n        try:\n            done = self.etree.fromstring(_bytes('<root>A<a>ca</a>B</root>'),\n                                         parser=parser)\n            self.fail(\"error expected, but parsing succeeded\")\n        except ValueError:\n            done = 'value error received as expected'\n\n        self.assertEqual([\"start-root\", \"data-A\", \"start-a\",\n                          \"data-ca\", \"end-a\", \"close\"],\n                         events)\n\n    def test_parser_target_feed_no_id_dict(self):\n        # test that target parsing works nicely with the no-id-hash setup\n        events = []\n        class Target(object):\n            def start(self, tag, attrib):\n                events.append(\"start-\" + tag)\n            def end(self, tag):\n                events.append(\"end-\" + tag)\n            def data(self, data):\n                events.append(\"data-\" + data)\n            def comment(self, text):\n                events.append(\"comment-\" + text)\n            def close(self):\n                return \"DONE\"\n\n        parser = self.etree.XMLParser(target=Target(), collect_ids=False)\n\n        parser.feed(_bytes('<!--a--><root xml:id=\"123\">A<!--b-->'))\n        parser.feed(_bytes('<sub xml:id=\"321\"/>B</root>'))\n        done = parser.close()\n\n        self.assertEqual(\"DONE\", done)\n        self.assertEqual([\"comment-a\", \"start-root\", \"data-A\", \"comment-b\",\n                          \"start-sub\", \"end-sub\", \"data-B\", \"end-root\"],\n                         events)\n\n    def test_parser_target_comment(self):\n        events = []\n        class Target(object):\n            def start(self, tag, attrib):\n                events.append(\"start-\" + tag)\n            def end(self, tag):\n                events.append(\"end-\" + tag)\n            def data(self, data):\n                events.append(\"data-\" + data)\n            def comment(self, text):\n                events.append(\"comment-\" + text)\n            def close(self):\n                return \"DONE\"\n\n        parser = self.etree.XMLParser(target=Target())\n\n        parser.feed(_bytes('<!--a--><root>A<!--b--><sub/><!--c-->B</root><!--d-->'))\n        done = parser.close()\n\n        self.assertEqual(\"DONE\", done)\n        self.assertEqual([\"comment-a\", \"start-root\", \"data-A\", \"comment-b\",\n                           \"start-sub\", \"end-sub\", \"comment-c\", \"data-B\",\n                           \"end-root\", \"comment-d\"],\n                          events)\n\n    def test_parser_target_pi(self):\n        events = []\n        class Target(object):\n            def start(self, tag, attrib):\n                events.append(\"start-\" + tag)\n            def end(self, tag):\n                events.append(\"end-\" + tag)\n            def data(self, data):\n                events.append(\"data-\" + data)\n            def pi(self, target, data):\n                events.append(\"pi-\" + target + \"-\" + data)\n            def close(self):\n                return \"DONE\"\n\n        parser = self.etree.XMLParser(target=Target())\n\n        parser.feed(_bytes('<?test a?><root>A<?test b?>B</root><?test c?>'))\n        done = parser.close()\n\n        self.assertEqual(\"DONE\", done)\n        self.assertEqual([\"pi-test-a\", \"start-root\", \"data-A\", \"pi-test-b\",\n                           \"data-B\", \"end-root\", \"pi-test-c\"],\n                          events)\n\n    def test_parser_target_cdata(self):\n        events = []\n        class Target(object):\n            def start(self, tag, attrib):\n                events.append(\"start-\" + tag)\n            def end(self, tag):\n                events.append(\"end-\" + tag)\n            def data(self, data):\n                events.append(\"data-\" + data)\n            def close(self):\n                return \"DONE\"\n\n        parser = self.etree.XMLParser(target=Target(),\n                                      strip_cdata=False)\n\n        parser.feed(_bytes('<root>A<a><![CDATA[ca]]></a>B</root>'))\n        done = parser.close()\n\n        self.assertEqual(\"DONE\", done)\n        self.assertEqual([\"start-root\", \"data-A\", \"start-a\",\n                           \"data-ca\", \"end-a\", \"data-B\", \"end-root\"],\n                          events)\n\n    def test_parser_target_recover(self):\n        events = []\n        class Target(object):\n            def start(self, tag, attrib):\n                events.append(\"start-\" + tag)\n            def end(self, tag):\n                events.append(\"end-\" + tag)\n            def data(self, data):\n                events.append(\"data-\" + data)\n            def close(self):\n                events.append(\"close\")\n                return \"DONE\"\n\n        parser = self.etree.XMLParser(target=Target(),\n                                      recover=True)\n\n        parser.feed(_bytes('<root>A<a>ca</a>B</not-root>'))\n        done = parser.close()\n\n        self.assertEqual(\"DONE\", done)\n        self.assertEqual([\"start-root\", \"data-A\", \"start-a\",\n                           \"data-ca\", \"end-a\", \"data-B\",\n                           \"end-root\", \"close\"],\n                          events)\n\n    def test_iterwalk_tag(self):\n        iterwalk = self.etree.iterwalk\n        root = self.etree.XML(_bytes('<a><b><d/></b><c/></a>'))\n\n        iterator = iterwalk(root, tag=\"b\", events=('start', 'end'))\n        events = list(iterator)\n        self.assertEqual(\n            [('start', root[0]), ('end', root[0])],\n            events)\n\n    def test_iterwalk_tag_all(self):\n        iterwalk = self.etree.iterwalk\n        root = self.etree.XML(_bytes('<a><b><d/></b><c/></a>'))\n\n        iterator = iterwalk(root, tag=\"*\", events=('start', 'end'))\n        events = list(iterator)\n        self.assertEqual(\n            8,\n            len(events))\n\n    def test_iterwalk(self):\n        iterwalk = self.etree.iterwalk\n        root = self.etree.XML(_bytes('<a><b></b><c/></a>'))\n\n        events = list(iterwalk(root))\n        self.assertEqual(\n            [('end', root[0]), ('end', root[1]), ('end', root)],\n            events)\n\n    def test_iterwalk_comments_root_element(self):\n        iterwalk = self.etree.iterwalk\n        root = self.etree.XML(\n            b'<!--C0--><a><!--Ca--><b><!--Cb--></b><!--Cc--><c/></a><!--C99-->')\n\n        iterator = iterwalk(root, events=('start', 'end', 'comment'))\n        events = list(iterator)\n        self.assertEqual(\n            [('start', root), ('comment', root[0]),\n             ('start', root[1]), ('comment', root[1][0]), ('end', root[1]),\n             ('comment', root[2]), ('start', root[3]), ('end', root[3]),\n             ('end', root),\n             ],\n            events)\n\n    def test_iterwalk_comments_tree(self):\n        iterwalk = self.etree.iterwalk\n        root = self.etree.XML(\n            b'<!--C0--><a><!--Ca--><b><!--Cb--></b><!--Cc--><c/></a><!--C99-->')\n\n        iterator = iterwalk(self.etree.ElementTree(root), events=('start', 'end', 'comment'))\n        events = list(iterator)\n        self.assertEqual(\n            [('comment', root.getprevious()),\n             ('start', root), ('comment', root[0]),  # <a>\n             ('start', root[1]), ('comment', root[1][0]), ('end', root[1]),  # <b>\n             ('comment', root[2]), ('start', root[3]), ('end', root[3]),  # <c>\n             ('end', root), ('comment', root.getnext()),\n             ],\n            events)\n\n    def test_iterwalk_pis_root_element(self):\n        iterwalk = self.etree.iterwalk\n        root = self.etree.XML(\n            b'<?C0?><a><?Ca?><b><?Cb?></b><?Cc?><c/></a><?C99?>')\n\n        iterator = iterwalk(root, events=('start', 'end', 'pi'))\n        events = list(iterator)\n        self.assertEqual(\n            [('start', root), ('pi', root[0]),\n             ('start', root[1]), ('pi', root[1][0]), ('end', root[1]),\n             ('pi', root[2]), ('start', root[3]), ('end', root[3]),\n             ('end', root),\n             ],\n            events)\n\n    def test_iterwalk_pis_tree(self):\n        iterwalk = self.etree.iterwalk\n        root = self.etree.XML(\n            b'<?C0?><a><?Ca?><b><?Cb?></b><?Cc?><c/></a><?C99?>')\n\n        iterator = iterwalk(self.etree.ElementTree(root), events=('start', 'end', 'pi'))\n        events = list(iterator)\n        self.assertEqual(\n            [('pi', root.getprevious()),\n             ('start', root), ('pi', root[0]),  # <a>\n             ('start', root[1]), ('pi', root[1][0]), ('end', root[1]),  # <b>\n             ('pi', root[2]), ('start', root[3]), ('end', root[3]),  # <c>\n             ('end', root), ('pi', root.getnext()),\n             ],\n            events)\n\n    def test_iterwalk_pis_comments_tree(self):\n        iterwalk = self.etree.iterwalk\n        root = self.etree.XML(\n            b'<!--C0--><?C0?><!--C1--><a><?Ca?><b><!--Cb--></b><?Cc?><c/></a><!--C99--><?C99?>')\n\n        iterator = iterwalk(self.etree.ElementTree(root), events=('start', 'end', 'pi', 'comment'))\n        events = list(iterator)\n        self.assertEqual(\n            [('comment', root.getprevious().getprevious().getprevious()),\n             ('pi', root.getprevious().getprevious()),\n             ('comment', root.getprevious()),\n             ('start', root), ('pi', root[0]),  # <a>\n             ('start', root[1]), ('comment', root[1][0]), ('end', root[1]),  # <b>\n             ('pi', root[2]), ('start', root[3]), ('end', root[3]),  # <c>\n             ('end', root), ('comment', root.getnext()), ('pi', root.getnext().getnext()),\n             ],\n            events)\n\n    def test_iterwalk_pis_comments_tree_no_events(self):\n        iterwalk = self.etree.iterwalk\n        root = self.etree.XML(\n            b'<!--C0--><?C0?><!--C1--><a><?Ca?><b><!--Cb--></b><?Cc?><c/></a><!--C99--><?C99?>')\n\n        iterator = iterwalk(self.etree.ElementTree(root), events=('start', 'end'))\n        events = list(iterator)\n        self.assertEqual(\n            [('start', root),  # <a>\n             ('start', root[1]), ('end', root[1]),  # <b>\n             ('start', root[3]), ('end', root[3]),  # <c>\n             ('end', root),\n             ],\n            events)\n\n    def test_iterwalk_start(self):\n        iterwalk = self.etree.iterwalk\n        root = self.etree.XML(_bytes('<a><b></b><c/></a>'))\n\n        iterator = iterwalk(root, events=('start',))\n        events = list(iterator)\n        self.assertEqual(\n            [('start', root), ('start', root[0]), ('start', root[1])],\n            events)\n\n    def test_iterwalk_start_end(self):\n        iterwalk = self.etree.iterwalk\n        root = self.etree.XML(_bytes('<a><b></b><c/></a>'))\n\n        iterator = iterwalk(root, events=('start','end'))\n        events = list(iterator)\n        self.assertEqual(\n            [('start', root), ('start', root[0]), ('end', root[0]),\n             ('start', root[1]), ('end', root[1]), ('end', root)],\n            events)\n\n    def test_iterwalk_start_tags(self):\n        iterwalk = self.etree.iterwalk\n        root = self.etree.XML(_bytes('<a><b></b><c/><b><d/></b></a>'))\n\n        iterator = iterwalk(root, events=('start',), tag='b')\n        events = list(iterator)\n        self.assertEqual(\n            [('start', root[0]), ('start', root[2])],\n            events)\n\n    def test_iterwalk_start_end_tags(self):\n        iterwalk = self.etree.iterwalk\n        root = self.etree.XML(_bytes('<a><b></b><c/><b><d/></b></a>'))\n\n        iterator = iterwalk(root, events=('start', 'end'), tag='b')\n        events = list(iterator)\n        self.assertEqual(\n            [('start', root[0]), ('end', root[0]), ('start', root[2]), ('end', root[2])],\n            events)\n\n    def test_iterwalk_start_end_tags_with_root(self):\n        iterwalk = self.etree.iterwalk\n        root = self.etree.XML(_bytes('<a><b></b><c/><b><d/></b></a>'))\n\n        iterator = iterwalk(root, events=('start', 'end'), tag=('b', 'a'))\n        events = list(iterator)\n        self.assertEqual(\n            [('start', root),\n             ('start', root[0]), ('end', root[0]),\n             ('start', root[2]), ('end', root[2]),\n             ('end', root),\n             ],\n            events)\n\n    def test_iterwalk_clear(self):\n        iterwalk = self.etree.iterwalk\n        root = self.etree.XML(_bytes('<a><b></b><c/></a>'))\n\n        iterator = iterwalk(root)\n        for event, elem in iterator:\n            elem.clear()\n\n        self.assertEqual(0,\n                          len(root))\n\n    def test_iterwalk_attrib_ns(self):\n        iterwalk = self.etree.iterwalk\n        root = self.etree.XML(_bytes('<a xmlns=\"ns1\"><b><c xmlns=\"ns2\"/></b></a>'))\n\n        attr_name = '{testns}bla'\n        events = []\n        iterator = iterwalk(root, events=('start','end','start-ns','end-ns'))\n        for event, elem in iterator:\n            events.append(event)\n            if event == 'start':\n                if elem.tag != '{ns1}a':\n                    elem.set(attr_name, 'value')\n\n        self.assertEqual(\n            ['start-ns', 'start', 'start', 'start-ns', 'start',\n             'end', 'end-ns', 'end', 'end', 'end-ns'],\n            events)\n\n        self.assertEqual(\n            None,\n            root.get(attr_name))\n        self.assertEqual(\n            'value',\n            root[0].get(attr_name))\n\n    def test_iterwalk_end_skip(self):\n        iterwalk = self.etree.iterwalk\n        root = self.etree.XML(_bytes('<a><b><c/></b><d><e/></d></a>'))\n\n        iterator = iterwalk(root)\n        tags = []\n        for event, elem in iterator:\n            tags.append(elem.tag)\n            # requesting a skip after an 'end' event should never have an effect\n            iterator.skip_subtree()\n\n        self.assertEqual(['c', 'b', 'e', 'd', 'a'], tags)\n\n    def test_iterwalk_start_end_skip(self):\n        iterwalk = self.etree.iterwalk\n        root = self.etree.XML(_bytes('<a><b><c/></b><d><e/></d></a>'))\n\n        iterator = iterwalk(root, events=('start', 'end'))\n        tags = []\n        for event, elem in iterator:\n            tags.append((event, elem.tag))\n            if elem.tag in ('b', 'e'):\n                # skipping should only have an effect on 'start', not on 'end'\n                iterator.skip_subtree()\n\n        self.assertEqual(\n            [('start', 'a'),\n             ('start', 'b'), ('end', 'b'),  # ignored child 'c'\n             ('start', 'd'),\n             ('start', 'e'), ('end', 'e'),\n             ('end', 'd'),\n             ('end', 'a')],\n            tags)\n\n    def test_iterwalk_ns_skip(self):\n        iterwalk = self.etree.iterwalk\n        root = self.etree.XML(_bytes(\n            '<a xmlns=\"ns1\"><b xmlns=\"nsb\"><c xmlns=\"ns2\"/></b><d xmlns=\"ns2\"><e/></d></a>'))\n\n        events = []\n        iterator = iterwalk(root, events=('start','start-ns','end-ns'))\n        for event, elem in iterator:\n            if event in ('start-ns', 'end-ns'):\n                events.append((event, elem))\n                if event == 'start-ns' and elem == ('', 'nsb'):\n                    events.append('skip')\n                    iterator.skip_subtree()\n            else:\n                events.append((event, elem.tag))\n\n        self.assertEqual(\n            [('start-ns', ('', 'ns1')),\n             ('start', '{ns1}a'),\n             ('start-ns', ('', 'nsb')),\n             'skip',\n             ('start', '{nsb}b'),\n             ('end-ns', None),\n             ('start-ns', ('', 'ns2')),\n             ('start', '{ns2}d'),\n             ('start', '{ns2}e'),\n             ('end-ns', None),\n             ('end-ns', None)\n             ],\n            events)\n\n    def test_iterwalk_getiterator(self):\n        iterwalk = self.etree.iterwalk\n        root = self.etree.XML(_bytes('<a><b><d/></b><c/></a>'))\n\n        counts = []\n        for event, elem in iterwalk(root):\n            counts.append(len(list(elem.getiterator())))\n        self.assertEqual(\n            [1,2,1,4],\n            counts)\n\n    def test_walk_after_parse_failure(self):\n        # This used to be an issue because libxml2 can leak empty namespaces\n        # between failed parser runs.  iterwalk() failed to handle such a tree.\n        try:\n            etree.XML('''<anot xmlns=\"1\">''')\n        except etree.XMLSyntaxError:\n            pass\n        else:\n            assert False, \"invalid input did not fail to parse\"\n\n        et = etree.XML('''<root>  </root>''')\n        try:\n            ns = next(etree.iterwalk(et, events=('start-ns',)))\n        except StopIteration:\n            # This would be the expected result, because there was no namespace\n            pass\n        else:\n            # This is a bug in libxml2\n            assert not ns, repr(ns)\n\n    def test_itertext_comment_pi(self):\n        # https://bugs.launchpad.net/lxml/+bug/1844674\n        XML = self.etree.XML\n        root = XML(_bytes(\n            \"<root>RTEXT<a></a>ATAIL<b/><!-- COMMENT -->CTAIL<?PI PITEXT?> PITAIL </root>\"\n        ))\n\n        text = list(root.itertext())\n        self.assertEqual([\"RTEXT\", \"ATAIL\", \"CTAIL\", \" PITAIL \"],\n                          text)\n\n    def test_resolve_string_dtd(self):\n        parse = self.etree.parse\n        parser = self.etree.XMLParser(dtd_validation=True)\n        assertEqual = self.assertEqual\n        test_url = _str(\"__nosuch.dtd\")\n\n        class MyResolver(self.etree.Resolver):\n            def resolve(self, url, id, context):\n                assertEqual(url, test_url)\n                return self.resolve_string(\n                    _str('''<!ENTITY myentity \"%s\">\n                        <!ELEMENT doc ANY>''') % url, context)\n\n        parser.resolvers.add(MyResolver())\n\n        xml = _str('<!DOCTYPE doc SYSTEM \"%s\"><doc>&myentity;</doc>') % test_url\n        tree = parse(StringIO(xml), parser)\n        root = tree.getroot()\n        self.assertEqual(root.text, test_url)\n\n    def test_resolve_bytes_dtd(self):\n        parse = self.etree.parse\n        parser = self.etree.XMLParser(dtd_validation=True)\n        assertEqual = self.assertEqual\n        test_url = _str(\"__nosuch.dtd\")\n\n        class MyResolver(self.etree.Resolver):\n            def resolve(self, url, id, context):\n                assertEqual(url, test_url)\n                return self.resolve_string(\n                    (_str('''<!ENTITY myentity \"%s\">\n                             <!ELEMENT doc ANY>''') % url).encode('utf-8'),\n                    context)\n\n        parser.resolvers.add(MyResolver())\n\n        xml = _str('<!DOCTYPE doc SYSTEM \"%s\"><doc>&myentity;</doc>') % test_url\n        tree = parse(StringIO(xml), parser)\n        root = tree.getroot()\n        self.assertEqual(root.text, test_url)\n\n    def test_resolve_filelike_dtd(self):\n        parse = self.etree.parse\n        parser = self.etree.XMLParser(dtd_validation=True)\n        assertEqual = self.assertEqual\n        test_url = _str(\"__nosuch.dtd\")\n\n        class MyResolver(self.etree.Resolver):\n            def resolve(self, url, id, context):\n                assertEqual(url, test_url)\n                return self.resolve_file(\n                    SillyFileLike(\n                        _str('''<!ENTITY myentity \"%s\">\n                        <!ELEMENT doc ANY>''') % url), context)\n\n        parser.resolvers.add(MyResolver())\n\n        xml = _str('<!DOCTYPE doc SYSTEM \"%s\"><doc>&myentity;</doc>') % test_url\n        tree = parse(StringIO(xml), parser)\n        root = tree.getroot()\n        self.assertEqual(root.text, test_url)\n\n    def test_resolve_filename_dtd(self):\n        parse = self.etree.parse\n        parser = self.etree.XMLParser(attribute_defaults=True)\n        assertEqual = self.assertEqual\n        test_url = _str(\"__nosuch.dtd\")\n\n        class MyResolver(self.etree.Resolver):\n            def resolve(self, url, id, context):\n                assertEqual(url, test_url)\n                return self.resolve_filename(\n                    fileInTestDir('test.dtd'), context)\n\n        parser.resolvers.add(MyResolver())\n\n        xml = _str('<!DOCTYPE a SYSTEM \"%s\"><a><b/></a>') % test_url\n        tree = parse(StringIO(xml), parser)\n        root = tree.getroot()\n        self.assertEqual(\n            root.attrib,    {'default': 'valueA'})\n        self.assertEqual(\n            root[0].attrib, {'default': 'valueB'})\n\n    def test_resolve_filename_dtd_relative(self):\n        parse = self.etree.parse\n        parser = self.etree.XMLParser(attribute_defaults=True)\n        assertEqual = self.assertEqual\n        test_url = _str(\"__nosuch.dtd\")\n\n        class MyResolver(self.etree.Resolver):\n            def resolve(self, url, id, context):\n                expected = fileUrlInTestDir(test_url)\n                url = url.replace('file://', 'file:')  # depends on libxml2 version\n                expected = expected.replace('file://', 'file:')\n                assertEqual(url, expected)\n                return self.resolve_filename(\n                    fileUrlInTestDir('test.dtd'), context)\n\n        parser.resolvers.add(MyResolver())\n\n        xml = _str('<!DOCTYPE a SYSTEM \"%s\"><a><b/></a>') % test_url\n        tree = parse(StringIO(xml), parser,\n                     base_url=fileUrlInTestDir('__test.xml'))\n        root = tree.getroot()\n        self.assertEqual(\n            root.attrib,    {'default': 'valueA'})\n        self.assertEqual(\n            root[0].attrib, {'default': 'valueB'})\n\n    def test_resolve_file_dtd(self):\n        parse = self.etree.parse\n        parser = self.etree.XMLParser(attribute_defaults=True)\n        assertEqual = self.assertEqual\n        test_url = _str(\"__nosuch.dtd\")\n\n        class MyResolver(self.etree.Resolver):\n            def resolve(self, url, id, context):\n                assertEqual(url, test_url)\n                return self.resolve_file(\n                    open(fileInTestDir('test.dtd'), 'rb'), context)\n\n        parser.resolvers.add(MyResolver())\n\n        xml = _str('<!DOCTYPE a SYSTEM \"%s\"><a><b/></a>') % test_url\n        tree = parse(StringIO(xml), parser)\n        root = tree.getroot()\n        self.assertEqual(\n            root.attrib,    {'default': 'valueA'})\n        self.assertEqual(\n            root[0].attrib, {'default': 'valueB'})\n\n    def test_resolve_empty(self):\n        parse = self.etree.parse\n        parser = self.etree.XMLParser(load_dtd=True)\n        assertEqual = self.assertEqual\n        test_url = _str(\"__nosuch.dtd\")\n\n        class check(object):\n            resolved = False\n\n        class MyResolver(self.etree.Resolver):\n            def resolve(self, url, id, context):\n                assertEqual(url, test_url)\n                check.resolved = True\n                return self.resolve_empty(context)\n\n        parser.resolvers.add(MyResolver())\n\n        xml = _str('<!DOCTYPE doc SYSTEM \"%s\"><doc>&myentity;</doc>') % test_url\n        self.assertRaises(etree.XMLSyntaxError, parse, StringIO(xml), parser)\n        self.assertTrue(check.resolved)\n\n    def test_resolve_error(self):\n        parse = self.etree.parse\n        parser = self.etree.XMLParser(dtd_validation=True)\n\n        class _LocalException(Exception):\n            pass\n\n        class MyResolver(self.etree.Resolver):\n            def resolve(self, url, id, context):\n                raise _LocalException\n\n        parser.resolvers.add(MyResolver())\n\n        xml = '<!DOCTYPE doc SYSTEM \"test\"><doc>&myentity;</doc>'\n        self.assertRaises(_LocalException, parse, BytesIO(xml), parser)\n\n    def test_entity_parse(self):\n        parse = self.etree.parse\n        tostring = self.etree.tostring\n        parser = self.etree.XMLParser(resolve_entities=False)\n        Entity = self.etree.Entity\n\n        xml = _bytes('<!DOCTYPE doc SYSTEM \"test\"><doc>&myentity;</doc>')\n        tree = parse(BytesIO(xml), parser)\n        root = tree.getroot()\n        self.assertEqual(root[0].tag, Entity)\n        self.assertEqual(root[0].text, \"&myentity;\")\n        self.assertEqual(root[0].tail, None)\n        self.assertEqual(root[0].name, \"myentity\")\n\n        self.assertEqual(_bytes('<doc>&myentity;</doc>'),\n                          tostring(root))\n\n    def test_entity_restructure(self):\n        xml = _bytes('''<!DOCTYPE root [ <!ENTITY nbsp \"&#160;\"> ]>\n            <root>\n              <child1/>\n              <child2/>\n              <child3>&nbsp;</child3>\n            </root>''')\n\n        parser = self.etree.XMLParser(resolve_entities=False)\n        root = etree.fromstring(xml, parser)\n        self.assertEqual([ el.tag for el in root ],\n                          ['child1', 'child2', 'child3'])\n\n        root[0] = root[-1]\n        self.assertEqual([ el.tag for el in root ],\n                          ['child3', 'child2'])\n        self.assertEqual(root[0][0].text, '&nbsp;')\n        self.assertEqual(root[0][0].name, 'nbsp')\n\n    def test_entity_append(self):\n        Entity = self.etree.Entity\n        Element = self.etree.Element\n        tostring = self.etree.tostring\n\n        root = Element(\"root\")\n        root.append( Entity(\"test\") )\n\n        self.assertEqual(root[0].tag, Entity)\n        self.assertEqual(root[0].text, \"&test;\")\n        self.assertEqual(root[0].tail, None)\n        self.assertEqual(root[0].name, \"test\")\n\n        self.assertEqual(_bytes('<root>&test;</root>'),\n                          tostring(root))\n\n    def test_entity_append_parsed(self):\n        Entity = self.etree.Entity\n        Element = self.etree.Element\n        parser = self.etree.XMLParser(resolve_entities=False)\n        entity = self.etree.XML('''<!DOCTYPE data [\n        <!ENTITY a \"a\">\n        <!ENTITY b \"&a;\">\n        ]>\n        <data>&b;</data>\n        ''', parser)\n\n        el = Element('test')\n        el.append(entity)\n        self.assertEqual(el.tag, 'test')\n        self.assertEqual(el[0].tag, 'data')\n        self.assertEqual(el[0][0].tag, Entity)\n        self.assertEqual(el[0][0].name, 'b')\n\n    def test_entity_values(self):\n        Entity = self.etree.Entity\n        self.assertEqual(Entity(\"test\").text, '&test;')\n        self.assertEqual(Entity(\"#17683\").text, '&#17683;')\n        self.assertEqual(Entity(\"#x1768\").text, '&#x1768;')\n        self.assertEqual(Entity(\"#x98AF\").text, '&#x98AF;')\n\n    def test_entity_error(self):\n        Entity = self.etree.Entity\n        self.assertRaises(ValueError, Entity, 'a b c')\n        self.assertRaises(ValueError, Entity, 'a,b')\n        self.assertRaises(ValueError, Entity, 'a\\0b')\n        self.assertRaises(ValueError, Entity, '#abc')\n        self.assertRaises(ValueError, Entity, '#xxyz')\n\n    def test_cdata(self):\n        CDATA = self.etree.CDATA\n        Element = self.etree.Element\n        tostring = self.etree.tostring\n\n        root = Element(\"root\")\n        root.text = CDATA('test')\n\n        self.assertEqual('test',\n                          root.text)\n        self.assertEqual(_bytes('<root><![CDATA[test]]></root>'),\n                          tostring(root))\n\n    def test_cdata_tail(self):\n        CDATA = self.etree.CDATA\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        tostring = self.etree.tostring\n\n        root = Element(\"root\")\n        child = SubElement(root, 'child')\n        child.tail = CDATA('test')\n\n        self.assertEqual('test', child.tail)\n        self.assertEqual(_bytes('<root><child/><![CDATA[test]]></root>'),\n                         tostring(root))\n\n        root = Element(\"root\")\n        root.tail = CDATA('test')\n\n        self.assertEqual('test', root.tail)\n        self.assertEqual(_bytes('<root/><![CDATA[test]]>'),\n                         tostring(root))\n\n    def test_cdata_type(self):\n        CDATA = self.etree.CDATA\n        Element = self.etree.Element\n        root = Element(\"root\")\n\n        root.text = CDATA(\"test\")\n        self.assertEqual('test', root.text)\n\n        root.text = CDATA(_str(\"test\"))\n        self.assertEqual('test', root.text)\n\n        self.assertRaises(TypeError, CDATA, 1)\n\n    def test_cdata_errors(self):\n        CDATA = self.etree.CDATA\n        Element = self.etree.Element\n\n        root = Element(\"root\")\n        cdata = CDATA('test')\n\n        self.assertRaises(TypeError,\n                          root.set, 'attr', cdata)\n        self.assertRaises(TypeError,\n                          operator.setitem, root.attrib, 'attr', cdata)\n\n    def test_cdata_parser(self):\n        tostring = self.etree.tostring\n        parser = self.etree.XMLParser(strip_cdata=False)\n        root = self.etree.XML(_bytes('<root><![CDATA[test]]></root>'), parser)\n\n        self.assertEqual('test', root.text)\n        self.assertEqual(_bytes('<root><![CDATA[test]]></root>'),\n                          tostring(root))\n\n    def test_cdata_xpath(self):\n        tostring = self.etree.tostring\n        parser = self.etree.XMLParser(strip_cdata=False)\n        root = self.etree.XML(_bytes('<root><![CDATA[test]]></root>'), parser)\n        self.assertEqual(_bytes('<root><![CDATA[test]]></root>'),\n                          tostring(root))\n\n        self.assertEqual(['test'], root.xpath('//text()'))\n\n    # TypeError in etree, AssertionError in ElementTree;\n    def test_setitem_assert(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        \n        self.assertRaises(TypeError,\n                          a.__setitem__, 0, 'foo')\n\n    def test_append_error(self):\n        Element = self.etree.Element\n        root = Element('root')\n        # raises AssertionError in ElementTree\n        self.assertRaises(TypeError, root.append, None)\n        self.assertRaises(TypeError, root.extend, [None])\n        self.assertRaises(TypeError, root.extend, [Element('one'), None])\n        self.assertEqual('one', root[0].tag)\n\n    def test_append_recursive_error(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        root = Element('root')\n        self.assertRaises(ValueError, root.append, root)\n        child = SubElement(root, 'child')\n        self.assertRaises(ValueError, child.append, root)\n        child2 = SubElement(child, 'child2')\n        self.assertRaises(ValueError, child2.append, root)\n        self.assertRaises(ValueError, child2.append, child)\n        self.assertEqual('child2', root[0][0].tag)\n\n    def test_addnext(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        root = Element('root')\n        SubElement(root, 'a')\n        SubElement(root, 'b')\n\n        self.assertEqual(['a', 'b'],\n                          [c.tag for c in root])\n        root[1].addnext(root[0])\n        self.assertEqual(['b', 'a'],\n                          [c.tag for c in root])\n\n    def test_addprevious(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        root = Element('root')\n        SubElement(root, 'a')\n        SubElement(root, 'b')\n\n        self.assertEqual(['a', 'b'],\n                          [c.tag for c in root])\n        root[0].addprevious(root[1])\n        self.assertEqual(['b', 'a'],\n                          [c.tag for c in root])\n\n    def test_addnext_cycle(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        root = Element('root')\n        a = SubElement(root, 'a')\n        b = SubElement(a, 'b')\n        # appending parent as sibling is forbidden\n        self.assertRaises(ValueError, b.addnext, a)\n        self.assertEqual(['a'], [c.tag for c in root])\n        self.assertEqual(['b'], [c.tag for c in a])\n\n    def test_addprevious_cycle(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        root = Element('root')\n        a = SubElement(root, 'a')\n        b = SubElement(a, 'b')\n        # appending parent as sibling is forbidden\n        self.assertRaises(ValueError, b.addprevious, a)\n        self.assertEqual(['a'], [c.tag for c in root])\n        self.assertEqual(['b'], [c.tag for c in a])\n\n    def test_addnext_cycle_long(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        root = Element('root')\n        a = SubElement(root, 'a')\n        b = SubElement(a, 'b')\n        c = SubElement(b, 'c')\n        # appending parent as sibling is forbidden\n        self.assertRaises(ValueError, c.addnext, a)\n\n    def test_addprevious_cycle_long(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        root = Element('root')\n        a = SubElement(root, 'a')\n        b = SubElement(a, 'b')\n        c = SubElement(b, 'c')\n        # appending parent as sibling is forbidden\n        self.assertRaises(ValueError, c.addprevious, a)\n\n    def test_addprevious_noops(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        root = Element('root')\n        a = SubElement(root, 'a')\n        b = SubElement(root, 'b')\n        a.addprevious(a)\n        self.assertEqual('a', root[0].tag)\n        self.assertEqual('b', root[1].tag)\n        b.addprevious(b)\n        self.assertEqual('a', root[0].tag)\n        self.assertEqual('b', root[1].tag)\n        b.addprevious(a)\n        self.assertEqual('a', root[0].tag)\n        self.assertEqual('b', root[1].tag)\n\n    def test_addnext_noops(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        root = Element('root')\n        a = SubElement(root, 'a')\n        b = SubElement(root, 'b')\n        a.addnext(a)\n        self.assertEqual('a', root[0].tag)\n        self.assertEqual('b', root[1].tag)\n        b.addnext(b)\n        self.assertEqual('a', root[0].tag)\n        self.assertEqual('b', root[1].tag)\n        a.addnext(b)\n        self.assertEqual('a', root[0].tag)\n        self.assertEqual('b', root[1].tag)\n\n    def test_addnext_root(self):\n        Element = self.etree.Element\n        a = Element('a')\n        b = Element('b')\n        self.assertRaises(TypeError, a.addnext, b)\n\n    def test_addprevious_pi(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        PI = self.etree.PI\n        root = Element('root')\n        SubElement(root, 'a')\n        pi = PI('TARGET', 'TEXT')\n        pi.tail = \"TAIL\"\n\n        self.assertEqual(_bytes('<root><a></a></root>'),\n                          self._writeElement(root))\n        root[0].addprevious(pi)\n        self.assertEqual(_bytes('<root><?TARGET TEXT?>TAIL<a></a></root>'),\n                          self._writeElement(root))\n\n    def test_addprevious_root_pi(self):\n        Element = self.etree.Element\n        PI = self.etree.PI\n        root = Element('root')\n        pi = PI('TARGET', 'TEXT')\n        pi.tail = \"TAIL\"\n\n        self.assertEqual(_bytes('<root></root>'),\n                          self._writeElement(root))\n        root.addprevious(pi)\n        self.assertEqual(_bytes('<?TARGET TEXT?>\\n<root></root>'),\n                          self._writeElement(root))\n\n    def test_addnext_pi(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        PI = self.etree.PI\n        root = Element('root')\n        SubElement(root, 'a')\n        pi = PI('TARGET', 'TEXT')\n        pi.tail = \"TAIL\"\n\n        self.assertEqual(_bytes('<root><a></a></root>'),\n                          self._writeElement(root))\n        root[0].addnext(pi)\n        self.assertEqual(_bytes('<root><a></a><?TARGET TEXT?>TAIL</root>'),\n                          self._writeElement(root))\n\n    def test_addnext_root_pi(self):\n        Element = self.etree.Element\n        PI = self.etree.PI\n        root = Element('root')\n        pi = PI('TARGET', 'TEXT')\n        pi.tail = \"TAIL\"\n\n        self.assertEqual(_bytes('<root></root>'),\n                          self._writeElement(root))\n        root.addnext(pi)\n        self.assertEqual(_bytes('<root></root>\\n<?TARGET TEXT?>'),\n                          self._writeElement(root))\n\n    def test_addnext_comment(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        Comment = self.etree.Comment\n        root = Element('root')\n        SubElement(root, 'a')\n        comment = Comment('TEXT ')\n        comment.tail = \"TAIL\"\n\n        self.assertEqual(_bytes('<root><a></a></root>'),\n                          self._writeElement(root))\n        root[0].addnext(comment)\n        self.assertEqual(_bytes('<root><a></a><!--TEXT -->TAIL</root>'),\n                          self._writeElement(root))\n\n    def test_addnext_root_comment(self):\n        Element = self.etree.Element\n        Comment = self.etree.Comment\n        root = Element('root')\n        comment = Comment('TEXT ')\n        comment.tail = \"TAIL\"\n\n        self.assertEqual(_bytes('<root></root>'),\n                          self._writeElement(root))\n        root.addnext(comment)\n        self.assertEqual(_bytes('<root></root>\\n<!--TEXT -->'),\n                          self._writeElement(root))\n\n    def test_addprevious_comment(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        Comment = self.etree.Comment\n        root = Element('root')\n        SubElement(root, 'a')\n        comment = Comment('TEXT ')\n        comment.tail = \"TAIL\"\n\n        self.assertEqual(_bytes('<root><a></a></root>'),\n                          self._writeElement(root))\n        root[0].addprevious(comment)\n        self.assertEqual(_bytes('<root><!--TEXT -->TAIL<a></a></root>'),\n                          self._writeElement(root))\n\n    def test_addprevious_root_comment(self):\n        Element = self.etree.Element\n        Comment = self.etree.Comment\n        root = Element('root')\n        comment = Comment('TEXT ')\n        comment.tail = \"TAIL\"\n\n        self.assertEqual(_bytes('<root></root>'),\n                          self._writeElement(root))\n        root.addprevious(comment)\n        self.assertEqual(_bytes('<!--TEXT -->\\n<root></root>'),\n                          self._writeElement(root))\n\n    # ET's Elements have items() and key(), but not values()\n    def test_attribute_values(self):\n        XML = self.etree.XML\n        \n        root = XML(_bytes('<doc alpha=\"Alpha\" beta=\"Beta\" gamma=\"Gamma\"/>'))\n        values = root.values()\n        values.sort()\n        self.assertEqual(['Alpha', 'Beta', 'Gamma'], values)\n\n    # gives error in ElementTree\n    def test_comment_empty(self):\n        Element = self.etree.Element\n        Comment = self.etree.Comment\n\n        a = Element('a')\n        a.append(Comment())\n        self.assertEqual(\n            _bytes('<a><!----></a>'),\n            self._writeElement(a))\n\n    # ElementTree ignores comments\n    def test_comment_parse_empty(self):\n        ElementTree = self.etree.ElementTree\n        tostring = self.etree.tostring\n\n        xml = _bytes('<a><b/><!----><c/></a>')\n        f = BytesIO(xml)\n        doc = ElementTree(file=f)\n        a = doc.getroot()\n        self.assertEqual(\n            '',\n            a[1].text)\n        self.assertEqual(\n            xml,\n            tostring(a))\n\n    # ElementTree ignores comments\n    def test_comment_no_proxy_yet(self):\n        ElementTree = self.etree.ElementTree\n        \n        f = BytesIO('<a><b></b><!-- hoi --><c></c></a>')\n        doc = ElementTree(file=f)\n        a = doc.getroot()\n        self.assertEqual(\n            ' hoi ',\n            a[1].text)\n\n    # does not raise an exception in ElementTree\n    def test_comment_immutable(self):\n        Element = self.etree.Element\n        Comment = self.etree.Comment\n\n        c = Comment()\n        el = Element('myel')\n\n        self.assertRaises(TypeError, c.append, el)\n        self.assertRaises(TypeError, c.insert, 0, el)\n        self.assertRaises(TypeError, c.set, \"myattr\", \"test\")\n\n    def test_comment_immutable_attrib(self):\n        c = self.etree.Comment()\n        self.assertEqual(0, len(c.attrib))\n\n        self.assertFalse(c.attrib.__contains__('nope'))\n        self.assertFalse('nope' in c.attrib)\n        self.assertFalse('nope' in c.attrib.keys())\n        self.assertFalse('nope' in c.attrib.values())\n        self.assertFalse(('nope', 'huhu') in c.attrib.items())\n\n        self.assertEqual([], list(c.attrib))\n        self.assertEqual([], list(c.attrib.keys()))\n        self.assertEqual([], list(c.attrib.items()))\n        self.assertEqual([], list(c.attrib.values()))\n        self.assertEqual([], list(c.attrib.iterkeys()))\n        self.assertEqual([], list(c.attrib.iteritems()))\n        self.assertEqual([], list(c.attrib.itervalues()))\n\n        self.assertEqual('HUHU', c.attrib.pop('nope', 'HUHU'))\n        self.assertRaises(KeyError, c.attrib.pop, 'nope')\n\n        self.assertRaises(KeyError, c.attrib.__getitem__, 'only')\n        self.assertRaises(KeyError, c.attrib.__getitem__, 'names')\n        self.assertRaises(KeyError, c.attrib.__getitem__, 'nope')\n        self.assertRaises(KeyError, c.attrib.__setitem__, 'nope', 'yep')\n        self.assertRaises(KeyError, c.attrib.__delitem__, 'nope')\n\n    # test passing 'None' to dump()\n    def test_dump_none(self):\n        self.assertRaises(TypeError, self.etree.dump, None)\n\n    def test_prefix(self):\n        ElementTree = self.etree.ElementTree\n        \n        f = BytesIO('<a xmlns:foo=\"http://www.infrae.com/ns/1\"><foo:b/></a>')\n        doc = ElementTree(file=f)\n        a = doc.getroot()\n        self.assertEqual(\n            None,\n            a.prefix)\n        self.assertEqual(\n            'foo',\n            a[0].prefix)\n\n    def test_prefix_default_ns(self):\n        ElementTree = self.etree.ElementTree\n        \n        f = BytesIO('<a xmlns=\"http://www.infrae.com/ns/1\"><b/></a>')\n        doc = ElementTree(file=f)\n        a = doc.getroot()\n        self.assertEqual(\n            None,\n            a.prefix)\n        self.assertEqual(\n            None,\n            a[0].prefix)\n\n    def test_getparent(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(b, 'd')\n        self.assertEqual(\n            None,\n            a.getparent())\n        self.assertEqual(\n            a,\n            b.getparent())\n        self.assertEqual(\n            b.getparent(),\n            c.getparent())\n        self.assertEqual(\n            b,\n            d.getparent())\n\n    def test_iterchildren(self):\n        XML = self.etree.XML\n        \n        root = XML(_bytes('<doc><one/><two>Two</two>Hm<three/></doc>'))\n        result = []\n        for el in root.iterchildren():\n            result.append(el.tag)\n        self.assertEqual(['one', 'two', 'three'], result)\n\n    def test_iterchildren_reversed(self):\n        XML = self.etree.XML\n        \n        root = XML(_bytes('<doc><one/><two>Two</two>Hm<three/></doc>'))\n        result = []\n        for el in root.iterchildren(reversed=True):\n            result.append(el.tag)\n        self.assertEqual(['three', 'two', 'one'], result)\n\n    def test_iterchildren_tag(self):\n        XML = self.etree.XML\n        \n        root = XML(_bytes('<doc><one/><two>Two</two>Hm<two>Bla</two></doc>'))\n        result = []\n        for el in root.iterchildren(tag='two'):\n            result.append(el.text)\n        self.assertEqual(['Two', 'Bla'], result)\n\n    def test_iterchildren_tag_posarg(self):\n        XML = self.etree.XML\n\n        root = XML(_bytes('<doc><one/><two>Two</two>Hm<two>Bla</two></doc>'))\n        result = []\n        for el in root.iterchildren('two'):\n            result.append(el.text)\n        self.assertEqual(['Two', 'Bla'], result)\n\n    def test_iterchildren_tag_reversed(self):\n        XML = self.etree.XML\n        \n        root = XML(_bytes('<doc><one/><two>Two</two>Hm<two>Bla</two></doc>'))\n        result = []\n        for el in root.iterchildren(reversed=True, tag='two'):\n            result.append(el.text)\n        self.assertEqual(['Bla', 'Two'], result)\n\n    def test_iterchildren_tag_multiple(self):\n        XML = self.etree.XML\n\n        root = XML(_bytes('<doc><one/><two>Two</two>Hm<two>Bla</two><three/></doc>'))\n        result = []\n        for el in root.iterchildren(tag=['two', 'three']):\n            result.append(el.text)\n        self.assertEqual(['Two', 'Bla', None], result)\n\n    def test_iterchildren_tag_multiple_posarg(self):\n        XML = self.etree.XML\n\n        root = XML(_bytes('<doc><one/><two>Two</two>Hm<two>Bla</two><three/></doc>'))\n        result = []\n        for el in root.iterchildren('two', 'three'):\n            result.append(el.text)\n        self.assertEqual(['Two', 'Bla', None], result)\n\n    def test_iterchildren_tag_multiple_reversed(self):\n        XML = self.etree.XML\n\n        root = XML(_bytes('<doc><one/><two>Two</two>Hm<two>Bla</two><three/></doc>'))\n        result = []\n        for el in root.iterchildren(reversed=True, tag=['two', 'three']):\n            result.append(el.text)\n        self.assertEqual([None, 'Bla', 'Two'], result)\n\n    def test_iterancestors(self):\n        Element    = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(b, 'd')\n        self.assertEqual(\n            [],\n            list(a.iterancestors()))\n        self.assertEqual(\n            [a],\n            list(b.iterancestors()))\n        self.assertEqual(\n            [a],\n            list(c.iterancestors()))\n        self.assertEqual(\n            [b, a],\n            list(d.iterancestors()))\n\n    def test_iterancestors_tag(self):\n        Element    = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(b, 'd')\n        self.assertEqual(\n            [a],\n            list(d.iterancestors('a')))\n        self.assertEqual(\n            [a],\n            list(d.iterancestors(tag='a')))\n\n        self.assertEqual(\n            [b, a],\n            list(d.iterancestors('*')))\n        self.assertEqual(\n            [b, a],\n            list(d.iterancestors(tag='*')))\n\n    def test_iterancestors_tag_multiple(self):\n        Element    = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(b, 'd')\n        self.assertEqual(\n            [b, a],\n            list(d.iterancestors(tag=('a', 'b'))))\n        self.assertEqual(\n            [b, a],\n            list(d.iterancestors('a', 'b')))\n\n        self.assertEqual(\n            [],\n            list(d.iterancestors(tag=('w', 'x', 'y', 'z'))))\n        self.assertEqual(\n            [],\n            list(d.iterancestors('w', 'x', 'y', 'z')))\n\n        self.assertEqual(\n            [],\n            list(d.iterancestors(tag=('d', 'x'))))\n        self.assertEqual(\n            [],\n            list(d.iterancestors('d', 'x')))\n\n        self.assertEqual(\n            [b, a],\n            list(d.iterancestors(tag=('b', '*'))))\n        self.assertEqual(\n            [b, a],\n            list(d.iterancestors('b', '*')))\n\n        self.assertEqual(\n            [b],\n            list(d.iterancestors(tag=('b', 'c'))))\n        self.assertEqual(\n            [b],\n            list(d.iterancestors('b', 'c')))\n\n    def test_iterdescendants(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(b, 'd')\n        e = SubElement(c, 'e')\n\n        self.assertEqual(\n            [b, d, c, e],\n            list(a.iterdescendants()))\n        self.assertEqual(\n            [],\n            list(d.iterdescendants()))\n\n    def test_iterdescendants_tag(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(b, 'd')\n        e = SubElement(c, 'e')\n\n        self.assertEqual(\n            [],\n            list(a.iterdescendants('a')))\n        self.assertEqual(\n            [],\n            list(a.iterdescendants(tag='a')))\n\n        a2 = SubElement(e, 'a')\n        self.assertEqual(\n            [a2],\n            list(a.iterdescendants('a')))\n\n        self.assertEqual(\n            [a2],\n            list(c.iterdescendants('a')))\n        self.assertEqual(\n            [a2],\n            list(c.iterdescendants(tag='a')))\n\n    def test_iterdescendants_tag_multiple(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(b, 'd')\n        e = SubElement(c, 'e')\n\n        self.assertEqual(\n            [b, e],\n            list(a.iterdescendants(tag=('a', 'b', 'e'))))\n        self.assertEqual(\n            [b, e],\n            list(a.iterdescendants('a', 'b', 'e')))\n\n        a2 = SubElement(e, 'a')\n        self.assertEqual(\n            [b, a2],\n            list(a.iterdescendants(tag=('a', 'b'))))\n        self.assertEqual(\n            [b, a2],\n            list(a.iterdescendants('a', 'b')))\n\n        self.assertEqual(\n            [],\n            list(c.iterdescendants(tag=('x', 'y', 'z'))))\n        self.assertEqual(\n            [],\n            list(c.iterdescendants('x', 'y', 'z')))\n\n        self.assertEqual(\n            [b, d, c, e, a2],\n            list(a.iterdescendants(tag=('x', 'y', 'z', '*'))))\n        self.assertEqual(\n            [b, d, c, e, a2],\n            list(a.iterdescendants('x', 'y', 'z', '*')))\n\n    def test_getroottree(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(b, 'd')\n        self.assertEqual(\n            a,\n            a.getroottree().getroot())\n        self.assertEqual(\n            a,\n            b.getroottree().getroot())\n        self.assertEqual(\n            a,\n            d.getroottree().getroot())\n\n    def test_getnext(self):\n        Element    = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        self.assertEqual(\n            None,\n            a.getnext())\n        self.assertEqual(\n            c,\n            b.getnext())\n        self.assertEqual(\n            None,\n            c.getnext())\n\n    def test_getprevious(self):\n        Element    = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(b, 'd')\n        self.assertEqual(\n            None,\n            a.getprevious())\n        self.assertEqual(\n            b,\n            c.getprevious())\n        self.assertEqual(\n            None,\n            b.getprevious())\n\n    def test_itersiblings(self):\n        Element    = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(b, 'd')\n        self.assertEqual(\n            [],\n            list(a.itersiblings()))\n        self.assertEqual(\n            [c],\n            list(b.itersiblings()))\n        self.assertEqual(\n            [],\n            list(c.itersiblings()))\n        self.assertEqual(\n            [b],\n            list(c.itersiblings(preceding=True)))\n        self.assertEqual(\n            [],\n            list(b.itersiblings(preceding=True)))\n\n    def test_itersiblings_tag(self):\n        Element    = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(b, 'd')\n        self.assertEqual(\n            [],\n            list(a.itersiblings(tag='XXX')))\n        self.assertEqual(\n            [c],\n            list(b.itersiblings(tag='c')))\n        self.assertEqual(\n            [c],\n            list(b.itersiblings(tag='*')))\n        self.assertEqual(\n            [b],\n            list(c.itersiblings(preceding=True, tag='b')))\n        self.assertEqual(\n            [],\n            list(c.itersiblings(preceding=True, tag='c')))\n\n    def test_itersiblings_tag_multiple(self):\n        Element    = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(b, 'd')\n        e = SubElement(a, 'e')\n        self.assertEqual(\n            [],\n            list(a.itersiblings(tag=('XXX', 'YYY'))))\n        self.assertEqual(\n            [c, e],\n            list(b.itersiblings(tag=('c', 'd', 'e'))))\n        self.assertEqual(\n            [b],\n            list(c.itersiblings(preceding=True, tag=('b', 'b', 'c', 'd'))))\n        self.assertEqual(\n            [c, b],\n            list(e.itersiblings(preceding=True, tag=('c', '*'))))\n\n    def test_parseid(self):\n        parseid = self.etree.parseid\n        XML     = self.etree.XML\n        xml_text = _bytes('''\n        <!DOCTYPE document [\n        <!ELEMENT document (h1,p)*>\n        <!ELEMENT h1 (#PCDATA)>\n        <!ATTLIST h1 myid ID #REQUIRED>\n        <!ELEMENT p  (#PCDATA)>\n        <!ATTLIST p  someid ID #REQUIRED>\n        ]>\n        <document>\n          <h1 myid=\"chapter1\">...</h1>\n          <p id=\"note1\" class=\"note\">...</p>\n          <p>Regular paragraph.</p>\n          <p xml:id=\"xmlid\">XML:ID paragraph.</p>\n          <p someid=\"warn1\" class=\"warning\">...</p>\n        </document>\n        ''')\n\n        tree, dic = parseid(BytesIO(xml_text))\n        root = tree.getroot()\n        root2 = XML(xml_text)\n        self.assertEqual(self._writeElement(root),\n                          self._writeElement(root2))\n        expected = {\n            \"chapter1\" : root[0],\n            \"xmlid\"    : root[3],\n            \"warn1\"    : root[4]\n            }\n        self.assertTrue(\"chapter1\" in dic)\n        self.assertTrue(\"warn1\" in dic)\n        self.assertTrue(\"xmlid\" in dic)\n        self._checkIDDict(dic, expected)\n\n    def test_XMLDTDID(self):\n        XMLDTDID = self.etree.XMLDTDID\n        XML      = self.etree.XML\n        xml_text = _bytes('''\n        <!DOCTYPE document [\n        <!ELEMENT document (h1,p)*>\n        <!ELEMENT h1 (#PCDATA)>\n        <!ATTLIST h1 myid ID #REQUIRED>\n        <!ELEMENT p  (#PCDATA)>\n        <!ATTLIST p  someid ID #REQUIRED>\n        ]>\n        <document>\n          <h1 myid=\"chapter1\">...</h1>\n          <p id=\"note1\" class=\"note\">...</p>\n          <p>Regular paragraph.</p>\n          <p xml:id=\"xmlid\">XML:ID paragraph.</p>\n          <p someid=\"warn1\" class=\"warning\">...</p>\n        </document>\n        ''')\n\n        root, dic = XMLDTDID(xml_text)\n        root2 = XML(xml_text)\n        self.assertEqual(self._writeElement(root),\n                          self._writeElement(root2))\n        expected = {\n            \"chapter1\" : root[0],\n            \"xmlid\"    : root[3],\n            \"warn1\"    : root[4]\n            }\n        self.assertTrue(\"chapter1\" in dic)\n        self.assertTrue(\"warn1\" in dic)\n        self.assertTrue(\"xmlid\" in dic)\n        self._checkIDDict(dic, expected)\n\n    def test_XMLDTDID_empty(self):\n        XMLDTDID = self.etree.XMLDTDID\n        XML      = self.etree.XML\n        xml_text = _bytes('''\n        <document>\n          <h1 myid=\"chapter1\">...</h1>\n          <p id=\"note1\" class=\"note\">...</p>\n          <p>Regular paragraph.</p>\n          <p someid=\"warn1\" class=\"warning\">...</p>\n        </document>\n        ''')\n\n        root, dic = XMLDTDID(xml_text)\n        root2 = XML(xml_text)\n        self.assertEqual(self._writeElement(root),\n                          self._writeElement(root2))\n        expected = {}\n        self._checkIDDict(dic, expected)\n\n    def test_XMLDTDID_no_id_dict(self):\n        XMLDTDID = self.etree.XMLDTDID\n        XML      = self.etree.XML\n        xml_text = _bytes('''\n        <!DOCTYPE document [\n        <!ELEMENT document (h1,p)*>\n        <!ELEMENT h1 (#PCDATA)>\n        <!ATTLIST h1 myid ID #REQUIRED>\n        <!ELEMENT p  (#PCDATA)>\n        <!ATTLIST p  someid ID #REQUIRED>\n        ]>\n        <document>\n          <h1 myid=\"chapter1\">...</h1>\n          <p id=\"note1\" class=\"note\">...</p>\n          <p>Regular paragraph.</p>\n          <p xml:id=\"xmlid\">XML:ID paragraph.</p>\n          <p someid=\"warn1\" class=\"warning\">...</p>\n        </document>\n        ''')\n\n        parser = etree.XMLParser(collect_ids=False)\n        root, dic = XMLDTDID(xml_text, parser=parser)\n        root2 = XML(xml_text)\n        self.assertEqual(self._writeElement(root),\n                         self._writeElement(root2))\n        self.assertFalse(dic)\n        self._checkIDDict(dic, {})\n\n    def _checkIDDict(self, dic, expected):\n        self.assertEqual(len(dic),\n                          len(expected))\n        self.assertEqual(sorted(dic.items()),\n                          sorted(expected.items()))\n        if sys.version_info < (3,):\n            self.assertEqual(sorted(dic.iteritems()),\n                              sorted(expected.iteritems()))\n        self.assertEqual(sorted(dic.keys()),\n                          sorted(expected.keys()))\n        if sys.version_info < (3,):\n            self.assertEqual(sorted(dic.iterkeys()),\n                              sorted(expected.iterkeys()))\n        if sys.version_info < (3,):\n            self.assertEqual(sorted(dic.values()),\n                              sorted(expected.values()))\n            self.assertEqual(sorted(dic.itervalues()),\n                              sorted(expected.itervalues()))\n\n    def test_register_namespace_xml(self):\n        self.assertRaises(ValueError, self.etree.register_namespace,\n                          \"XML\", \"http://www.w3.org/XML/1998/namespace\")\n        self.assertRaises(ValueError, self.etree.register_namespace,\n                          \"xml\", \"http://www.w3.org/XML/2345\")\n        self.etree.register_namespace(\"xml\", \"http://www.w3.org/XML/1998/namespace\")  # ok\n\n    def test_namespaces(self):\n        etree = self.etree\n\n        r = {'foo': 'http://ns.infrae.com/foo'}\n        e = etree.Element('{http://ns.infrae.com/foo}bar', nsmap=r)\n        self.assertEqual(\n            'foo',\n            e.prefix)\n        self.assertEqual(\n            _bytes('<foo:bar xmlns:foo=\"http://ns.infrae.com/foo\"></foo:bar>'),\n            self._writeElement(e))\n        \n    def test_namespaces_default(self):\n        etree = self.etree\n\n        r = {None: 'http://ns.infrae.com/foo'}\n        e = etree.Element('{http://ns.infrae.com/foo}bar', nsmap=r)\n        self.assertEqual(\n            None,\n            e.prefix)\n        self.assertEqual(\n            '{http://ns.infrae.com/foo}bar',\n            e.tag)\n        self.assertEqual(\n            _bytes('<bar xmlns=\"http://ns.infrae.com/foo\"></bar>'),\n            self._writeElement(e))\n\n    def test_namespaces_default_and_other(self):\n        etree = self.etree\n\n        r = {None: 'http://ns.infrae.com/foo', 'p': 'http://test/'}\n        e = etree.Element('{http://ns.infrae.com/foo}bar', nsmap=r)\n        self.assertEqual(None, e.prefix)\n        self.assertEqual('{http://ns.infrae.com/foo}bar', e.tag)\n        self.assertEqual(\n            _bytes('<bar xmlns=\"http://ns.infrae.com/foo\" xmlns:p=\"http://test/\"></bar>'),\n            self._writeElement(e))\n\n    def test_namespaces_default_and_attr(self):\n        etree = self.etree\n\n        r = {None: 'http://ns.infrae.com/foo',\n             'hoi': 'http://ns.infrae.com/hoi'}\n        e = etree.Element('{http://ns.infrae.com/foo}bar', nsmap=r)\n        e.set('{http://ns.infrae.com/hoi}test', 'value')\n        self.assertEqual(\n            _bytes('<bar xmlns=\"http://ns.infrae.com/foo\" xmlns:hoi=\"http://ns.infrae.com/hoi\" hoi:test=\"value\"></bar>'),\n            self._writeElement(e))\n\n    def test_attribute_keeps_namespace_prefix_on_merge(self):\n        etree = self.etree\n\n        root = etree.Element('{http://test/ns}root',\n                             nsmap={None: 'http://test/ns'})\n        sub = etree.Element('{http://test/ns}sub',\n                            nsmap={'test': 'http://test/ns'})\n\n        sub.attrib['{http://test/ns}attr'] = 'value'\n        self.assertEqual(sub.attrib['{http://test/ns}attr'], 'value')\n        self.assertEqual(\n            _bytes('<test:sub xmlns:test=\"http://test/ns\" test:attr=\"value\"/>'),\n            etree.tostring(sub))\n\n        root.append(sub)\n        self.assertEqual(\n            _bytes('<root xmlns=\"http://test/ns\">'\n                   '<sub xmlns:test=\"http://test/ns\" test:attr=\"value\"/>'\n                   '</root>'),\n            etree.tostring(root))\n\n    def test_attribute_keeps_namespace_prefix_on_merge_with_nons(self):\n        etree = self.etree\n\n        root = etree.Element('root')\n        sub = etree.Element('{http://test/ns}sub',\n                            nsmap={'test': 'http://test/ns'})\n\n        sub.attrib['{http://test/ns}attr'] = 'value'\n        self.assertEqual(sub.attrib['{http://test/ns}attr'], 'value')\n        self.assertEqual(\n            _bytes('<test:sub xmlns:test=\"http://test/ns\" test:attr=\"value\"/>'),\n            etree.tostring(sub))\n\n        root.append(sub)\n        self.assertEqual(\n            _bytes('<root>'\n                   '<test:sub xmlns:test=\"http://test/ns\" test:attr=\"value\"/>'\n                   '</root>'),\n            etree.tostring(root))\n\n    def test_attribute_gets_namespace_prefix_on_merge_with_nons(self):\n        etree = self.etree\n\n        root = etree.Element('root')\n        sub = etree.Element('{http://test/ns}sub',\n                            nsmap={None: 'http://test/ns'})\n\n        sub.attrib['{http://test/ns}attr'] = 'value'\n        self.assertEqual(sub.attrib['{http://test/ns}attr'], 'value')\n        self.assertEqual(\n            _bytes('<sub xmlns=\"http://test/ns\" '\n                   'xmlns:ns0=\"http://test/ns\" ns0:attr=\"value\"/>'),\n            etree.tostring(sub))\n\n        root.append(sub)\n        self.assertEqual(\n            _bytes('<root>'\n                   '<sub xmlns=\"http://test/ns\"'\n                   ' xmlns:ns0=\"http://test/ns\" ns0:attr=\"value\"/>'\n                   '</root>'),\n            etree.tostring(root))\n\n    def test_attribute_gets_namespace_prefix_on_merge(self):\n        etree = self.etree\n\n        root = etree.Element('{http://test/ns}root',\n                             nsmap={'test': 'http://test/ns',\n                                    None: 'http://test/ns'})\n        sub = etree.Element('{http://test/ns}sub',\n                            nsmap={None: 'http://test/ns'})\n\n        sub.attrib['{http://test/ns}attr'] = 'value'\n        self.assertEqual(sub.attrib['{http://test/ns}attr'], 'value')\n        self.assertEqual(\n            _bytes('<sub xmlns=\"http://test/ns\" '\n                   'xmlns:ns0=\"http://test/ns\" ns0:attr=\"value\"/>'),\n            etree.tostring(sub))\n\n        root.append(sub)\n        self.assertEqual(\n            _bytes('<test:root xmlns:test=\"http://test/ns\" xmlns=\"http://test/ns\">'\n                   '<test:sub test:attr=\"value\"/>'\n                   '</test:root>'),\n            etree.tostring(root))\n\n    def test_namespaces_elementtree(self):\n        etree = self.etree\n        r = {None: 'http://ns.infrae.com/foo',\n             'hoi': 'http://ns.infrae.com/hoi'} \n        e = etree.Element('{http://ns.infrae.com/foo}z', nsmap=r)\n        tree = etree.ElementTree(element=e)\n        etree.SubElement(e, '{http://ns.infrae.com/hoi}x')\n        self.assertEqual(\n            _bytes('<z xmlns=\"http://ns.infrae.com/foo\" xmlns:hoi=\"http://ns.infrae.com/hoi\"><hoi:x></hoi:x></z>'),\n            self._writeElement(e))\n\n    def test_namespaces_default_copy_element(self):\n        etree = self.etree\n\n        r = {None: 'http://ns.infrae.com/foo'}\n        e1 = etree.Element('{http://ns.infrae.com/foo}bar', nsmap=r)\n        e2 = etree.Element('{http://ns.infrae.com/foo}bar', nsmap=r)\n\n        e1.append(e2)\n\n        self.assertEqual(\n            None,\n            e1.prefix)\n        self.assertEqual(\n            None,\n            e1[0].prefix)\n        self.assertEqual(\n            '{http://ns.infrae.com/foo}bar',\n            e1.tag)\n        self.assertEqual(\n            '{http://ns.infrae.com/foo}bar',\n            e1[0].tag)\n\n    def test_namespaces_copy_element(self):\n        etree = self.etree\n\n        r = {None: 'http://ns.infrae.com/BAR'}\n        e1 = etree.Element('{http://ns.infrae.com/BAR}bar', nsmap=r)\n        e2 = etree.Element('{http://ns.infrae.com/foo}bar', nsmap=r)\n\n        e1.append(e2)\n\n        self.assertEqual(\n            None,\n            e1.prefix)\n        self.assertNotEqual(\n            None,\n            e2.prefix)\n        self.assertEqual(\n            '{http://ns.infrae.com/BAR}bar',\n            e1.tag)\n        self.assertEqual(\n            '{http://ns.infrae.com/foo}bar',\n            e2.tag)\n\n    def test_namespaces_reuse_after_move(self):\n        ns_href = \"http://a.b.c\"\n        one = self.etree.fromstring(\n            _bytes('<foo><bar xmlns:ns=\"%s\"><ns:baz/></bar></foo>' % ns_href))\n        baz = one[0][0]\n\n        two = self.etree.fromstring(\n            _bytes('<root xmlns:ns=\"%s\"/>' % ns_href))\n        two.append(baz)\n        del one # make sure the source document is deallocated\n\n        self.assertEqual('{%s}baz' % ns_href, baz.tag)\n        self.assertEqual(\n            _bytes('<root xmlns:ns=\"%s\"><ns:baz/></root>' % ns_href),\n            self.etree.tostring(two))\n\n    def test_namespace_cleanup(self):\n        xml = _bytes(\n            '<foo xmlns=\"F\" xmlns:x=\"x\">'\n            '<bar xmlns:ns=\"NS\" xmlns:b=\"b\" xmlns=\"B\">'\n            '<ns:baz/>'\n            '</bar></foo>'\n        )\n        root = self.etree.fromstring(xml)\n        self.assertEqual(xml, self.etree.tostring(root))\n        self.etree.cleanup_namespaces(root)\n        self.assertEqual(\n            _bytes('<foo xmlns=\"F\"><bar xmlns:ns=\"NS\" xmlns=\"B\"><ns:baz/></bar></foo>'),\n            self.etree.tostring(root))\n\n    def test_namespace_cleanup_attributes(self):\n        xml = _bytes(\n            '<foo xmlns=\"F\" xmlns:x=\"X\" xmlns:a=\"A\">'\n            '<bar xmlns:ns=\"NS\" xmlns:b=\"b\" xmlns=\"B\">'\n            '<ns:baz a:test=\"attr\"/>'\n            '</bar></foo>'\n        )\n        root = self.etree.fromstring(xml)\n        self.assertEqual(xml, self.etree.tostring(root))\n        self.etree.cleanup_namespaces(root)\n        self.assertEqual(\n            _bytes('<foo xmlns=\"F\" xmlns:a=\"A\">'\n                   '<bar xmlns:ns=\"NS\" xmlns=\"B\">'\n                   '<ns:baz a:test=\"attr\"/>'\n                   '</bar></foo>'),\n            self.etree.tostring(root))\n\n    def test_namespace_cleanup_many(self):\n        xml = ('<n12:foo ' +\n               ' '.join('xmlns:n{n}=\"NS{n}\"'.format(n=i) for i in range(100)) +\n               '><n68:a/></n12:foo>').encode('utf8')\n        root = self.etree.fromstring(xml)\n        self.assertEqual(xml, self.etree.tostring(root))\n        self.etree.cleanup_namespaces(root)\n        self.assertEqual(\n            b'<n12:foo xmlns:n12=\"NS12\" xmlns:n68=\"NS68\"><n68:a/></n12:foo>',\n            self.etree.tostring(root))\n\n    def test_namespace_cleanup_deep(self):\n        xml = ('<root>' +\n               ''.join('<a xmlns:n{n}=\"NS{n}\">'.format(n=i) for i in range(100)) +\n               '<n64:x/>' + '</a>'*100 + '</root>').encode('utf8')\n        root = self.etree.fromstring(xml)\n        self.assertEqual(xml, self.etree.tostring(root))\n        self.etree.cleanup_namespaces(root)\n        self.assertEqual(\n            b'<root>' + b'<a>'*64 + b'<a xmlns:n64=\"NS64\">' + b'<a>'*35 +\n            b'<n64:x/>' + b'</a>'*100 + b'</root>',\n            self.etree.tostring(root))\n\n    def test_namespace_cleanup_deep_to_top(self):\n        xml = ('<root>' +\n               ''.join('<a xmlns:n{n}=\"NS{n}\">'.format(n=i) for i in range(100)) +\n               '<n64:x xmlns:a=\"A\" a:attr=\"X\"/>' +\n               '</a>'*100 +\n               '</root>').encode('utf8')\n        root = self.etree.fromstring(xml)\n        self.assertEqual(xml, self.etree.tostring(root))\n        self.etree.cleanup_namespaces(root, top_nsmap={'n64': 'NS64'})\n        self.assertEqual(\n            b'<root xmlns:n64=\"NS64\">' + b'<a>'*100 +\n            b'<n64:x xmlns:a=\"A\" a:attr=\"X\"/>' + b'</a>'*100 + b'</root>',\n            self.etree.tostring(root))\n\n    def test_namespace_cleanup_keep_prefixes(self):\n        xml = ('<root xmlns:n64=\"NS64\" xmlns:foo=\"FOO\" xmlns:unused1=\"UNUSED\" xmlns:no=\"NO\">'\n               '<a xmlns:unused2=\"UNUSED\"><n64:x xmlns:a=\"A\" a:attr=\"X\"/></a>'\n               '<foo>foo:bar</foo>'\n               '</root>').encode('utf8')\n        root = self.etree.fromstring(xml)\n        self.assertEqual(xml, self.etree.tostring(root))\n        self.etree.cleanup_namespaces(root, keep_ns_prefixes=['foo'])\n        self.assertEqual(\n            b'<root xmlns:n64=\"NS64\" xmlns:foo=\"FOO\">'\n            b'<a><n64:x xmlns:a=\"A\" a:attr=\"X\"/></a>'\n            b'<foo>foo:bar</foo>'\n            b'</root>',\n            self.etree.tostring(root))\n\n    def test_namespace_cleanup_keep_prefixes_top(self):\n        xml = ('<root xmlns:n64=\"NS64\" xmlns:unused1=\"UNUSED\" xmlns:no=\"NO\">'\n               '<sub xmlns:foo=\"FOO\">'\n               '<a xmlns:unused2=\"UNUSED\"><n64:x xmlns:a=\"A\" a:attr=\"X\"/></a>'\n               '<foo>foo:bar</foo>'\n               '</sub>'\n               '</root>').encode('utf8')\n        root = self.etree.fromstring(xml)\n        self.assertEqual(xml, self.etree.tostring(root))\n        self.etree.cleanup_namespaces(\n            root,\n            top_nsmap={'foo': 'FOO', 'unused1': 'UNUSED'},\n            keep_ns_prefixes=['foo'])\n        self.assertEqual(\n            b'<root xmlns:n64=\"NS64\" xmlns:foo=\"FOO\">'\n            b'<sub>'\n            b'<a><n64:x xmlns:a=\"A\" a:attr=\"X\"/></a>'\n            b'<foo>foo:bar</foo>'\n            b'</sub>'\n            b'</root>',\n            self.etree.tostring(root))\n\n    def test_element_nsmap(self):\n        etree = self.etree\n\n        r = {None: 'http://ns.infrae.com/foo',\n             'hoi': 'http://ns.infrae.com/hoi'}\n        e = etree.Element('{http://ns.infrae.com/foo}bar', nsmap=r)\n        self.assertEqual(\n            r,\n            e.nsmap)\n\n    def test_subelement_nsmap(self):\n        etree = self.etree\n\n        re = {None: 'http://ns.infrae.com/foo',\n             'hoi': 'http://ns.infrae.com/hoi'}\n        e = etree.Element('{http://ns.infrae.com/foo}bar', nsmap=re)\n\n        rs = {None: 'http://ns.infrae.com/honk',\n             'top': 'http://ns.infrae.com/top'}\n        s = etree.SubElement(e, '{http://ns.infrae.com/honk}bar', nsmap=rs)\n\n        r = re.copy()\n        r.update(rs)\n        self.assertEqual(re, e.nsmap)\n        self.assertEqual(r,  s.nsmap)\n\n    def test_html_prefix_nsmap(self):\n        etree = self.etree\n        el = etree.HTML('<hha:page-description>aa</hha:page-description>').find('.//page-description')\n        if etree.LIBXML_VERSION < (2, 9, 11):\n            self.assertEqual({'hha': None}, el.nsmap)\n        else:\n            self.assertEqual({}, el.nsmap)\n\n    def test_getchildren(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(b, 'd')\n        e = SubElement(c, 'e')\n        self.assertEqual(\n            _bytes('<a><b><d></d></b><c><e></e></c></a>'),\n            self.etree.tostring(a, method=\"c14n\"))\n        self.assertEqual(\n            [b, c],\n            a.getchildren())\n        self.assertEqual(\n            [d],\n            b.getchildren())\n        self.assertEqual(\n            [],\n            d.getchildren())\n\n    def test_getiterator(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(b, 'd')\n        e = SubElement(c, 'e')\n\n        self.assertEqual(\n            [a, b, d, c, e],\n            list(a.getiterator()))\n        self.assertEqual(\n            [d],\n            list(d.getiterator()))\n\n    def test_getiterator_empty(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(b, 'd')\n        e = SubElement(c, 'e')\n\n        self.assertEqual(\n            [],\n            list(a.getiterator('none')))\n        self.assertEqual(\n            [],\n            list(e.getiterator('none')))\n        self.assertEqual(\n            [e],\n            list(e.getiterator()))\n\n    def test_getiterator_filter(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(b, 'd')\n        e = SubElement(c, 'e')\n\n        self.assertEqual(\n            [a],\n            list(a.getiterator('a')))\n        a2 = SubElement(e, 'a')\n        self.assertEqual(\n            [a, a2],\n            list(a.getiterator('a')))\n        self.assertEqual(\n            [a2],\n            list(c.getiterator('a')))\n\n    def test_getiterator_filter_all(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(b, 'd')\n        e = SubElement(c, 'e')\n\n        self.assertEqual(\n            [a, b, d, c, e],\n            list(a.getiterator('*')))\n\n    def test_getiterator_filter_comment(self):\n        Element = self.etree.Element\n        Comment = self.etree.Comment\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        comment_b = Comment(\"TEST-b\")\n        b.append(comment_b)\n\n        self.assertEqual(\n            [comment_b],\n            list(a.getiterator(Comment)))\n\n        comment_a = Comment(\"TEST-a\")\n        a.append(comment_a)\n\n        self.assertEqual(\n            [comment_b, comment_a],\n            list(a.getiterator(Comment)))\n\n        self.assertEqual(\n            [comment_b],\n            list(b.getiterator(Comment)))\n\n    def test_getiterator_filter_pi(self):\n        Element = self.etree.Element\n        PI = self.etree.ProcessingInstruction\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        pi_b = PI(\"TEST-b\")\n        b.append(pi_b)\n\n        self.assertEqual(\n            [pi_b],\n            list(a.getiterator(PI)))\n\n        pi_a = PI(\"TEST-a\")\n        a.append(pi_a)\n\n        self.assertEqual(\n            [pi_b, pi_a],\n            list(a.getiterator(PI)))\n\n        self.assertEqual(\n            [pi_b],\n            list(b.getiterator(PI)))\n\n    def test_getiterator_with_text(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        a.text = 'a'\n        b = SubElement(a, 'b')\n        b.text = 'b'\n        b.tail = 'b1'\n        c = SubElement(a, 'c')\n        c.text = 'c'\n        c.tail = 'c1'\n        d = SubElement(b, 'd')\n        d.text = 'd'\n        d.tail = 'd1'\n        e = SubElement(c, 'e')\n        e.text = 'e'\n        e.tail = 'e1'\n\n        self.assertEqual(\n            [a, b, d, c, e],\n            list(a.getiterator()))\n        #self.assertEqual(\n        #    [d],\n        #    list(d.getiterator()))\n\n    def test_getiterator_filter_with_text(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        a.text = 'a'\n        b = SubElement(a, 'b')\n        b.text = 'b'\n        b.tail = 'b1'\n        c = SubElement(a, 'c')\n        c.text = 'c'\n        c.tail = 'c1'\n        d = SubElement(b, 'd')\n        d.text = 'd'\n        d.tail = 'd1'\n        e = SubElement(c, 'e')\n        e.text = 'e'\n        e.tail = 'e1'\n\n        self.assertEqual(\n            [a],\n            list(a.getiterator('a')))\n        a2 = SubElement(e, 'a')\n        self.assertEqual(\n            [a, a2],\n            list(a.getiterator('a')))\n        self.assertEqual(\n            [a2],\n            list(e.getiterator('a')))\n\n    def test_getiterator_filter_multiple(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(b, 'd')\n        e = SubElement(c, 'e')\n        f = SubElement(c, 'f')\n\n        self.assertEqual(\n            [a, b],\n               list(a.getiterator('a', 'b')))\n        self.assertEqual(\n            [],\n              list(a.getiterator('x', 'y')))\n        self.assertEqual(\n            [a, f],\n              list(a.getiterator('f', 'a')))\n        self.assertEqual(\n            [c, e, f],\n               list(c.getiterator('c', '*', 'a')))\n        self.assertEqual(\n            [],\n                  list(a.getiterator( (), () )))\n\n    def test_getiterator_filter_multiple_tuple(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(b, 'd')\n        e = SubElement(c, 'e')\n        f = SubElement(c, 'f')\n\n        self.assertEqual(\n            [a, b],\n                  list(a.getiterator( ('a', 'b') )))\n        self.assertEqual(\n            [],\n              list(a.getiterator( ('x', 'y') )))\n        self.assertEqual(\n            [a, f],\n                  list(a.getiterator( ('f', 'a') )))\n        self.assertEqual(\n            [c, e, f],\n                     list(c.getiterator( ('c', '*', 'a') )))\n        self.assertEqual(\n            [],\n              list(a.getiterator( () )))\n\n    def test_getiterator_filter_namespace(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('{a}a')\n        b = SubElement(a, '{a}b')\n        c = SubElement(a, '{a}c')\n        d = SubElement(b, '{b}d')\n        e = SubElement(c, '{a}e')\n        f = SubElement(c, '{b}f')\n        g = SubElement(c, 'g')\n\n        self.assertEqual(\n            [a],\n            list(a.getiterator('{a}a')))\n        self.assertEqual(\n            [],\n            list(a.getiterator('{b}a')))\n        self.assertEqual(\n            [],\n            list(a.getiterator('a')))\n        self.assertEqual(\n            [a,b,d,c,e,f,g],\n            list(a.getiterator('*')))\n        self.assertEqual(\n            [f],\n            list(c.getiterator('{b}*')))\n        self.assertEqual(\n            [d, f],\n            list(a.getiterator('{b}*')))\n        self.assertEqual(\n            [g],\n            list(a.getiterator('g')))\n        self.assertEqual(\n            [g],\n            list(a.getiterator('{}g')))\n        self.assertEqual(\n            [g],\n            list(a.getiterator('{}*')))\n\n    def test_getiterator_filter_local_name(self):\n        Element = self.etree.Element\n        Comment = self.etree.Comment\n        SubElement = self.etree.SubElement\n\n        a = Element('{a}a')\n        b = SubElement(a, '{nsA}b')\n        c = SubElement(b, '{nsB}b')\n        d = SubElement(a, 'b')\n        e = SubElement(a, '{nsA}e')\n        f = SubElement(e, '{nsB}e')\n        g = SubElement(e, 'e')\n        a.append(Comment('test'))\n\n        self.assertEqual(\n            [b, c, d],\n            list(a.getiterator('{*}b')))\n        self.assertEqual(\n            [e, f, g],\n            list(a.getiterator('{*}e')))\n        self.assertEqual(\n            [a, b, c, d, e, f, g],\n            list(a.getiterator('{*}*')))\n\n    def test_getiterator_filter_entities(self):\n        Element = self.etree.Element\n        Entity = self.etree.Entity\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        entity_b = Entity(\"TEST-b\")\n        b.append(entity_b)\n\n        self.assertEqual(\n            [entity_b],\n            list(a.getiterator(Entity)))\n\n        entity_a = Entity(\"TEST-a\")\n        a.append(entity_a)\n\n        self.assertEqual(\n            [entity_b, entity_a],\n            list(a.getiterator(Entity)))\n\n        self.assertEqual(\n            [entity_b],\n            list(b.getiterator(Entity)))\n\n    def test_getiterator_filter_element(self):\n        Element = self.etree.Element\n        Comment = self.etree.Comment\n        PI = self.etree.PI\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        a.append(Comment(\"test\"))\n        a.append(PI(\"pi\", \"content\"))\n        c = SubElement(a, 'c')\n\n        self.assertEqual(\n            [a, b, c],\n            list(a.getiterator(Element)))\n\n    def test_getiterator_filter_all_comment_pi(self):\n        # ElementTree iterates over everything here\n        Element = self.etree.Element\n        Comment = self.etree.Comment\n        PI = self.etree.PI\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        a.append(Comment(\"test\"))\n        a.append(PI(\"pi\", \"content\"))\n        c = SubElement(a, 'c')\n\n        self.assertEqual(\n            [a, b, c],\n            list(a.getiterator('*')))\n\n    def test_elementtree_getiterator(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        ElementTree = self.etree.ElementTree\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(b, 'd')\n        e = SubElement(c, 'e')\n        t = ElementTree(element=a)\n\n        self.assertEqual(\n            [a, b, d, c, e],\n            list(t.getiterator()))\n\n    def test_elementtree_getiterator_filter(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        ElementTree = self.etree.ElementTree\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(b, 'd')\n        e = SubElement(c, 'e')\n        t = ElementTree(element=a)\n\n        self.assertEqual(\n            [a],\n            list(t.getiterator('a')))\n        a2 = SubElement(e, 'a')\n        self.assertEqual(\n            [a, a2],\n            list(t.getiterator('a')))\n\n    def test_elementtree_getelementpath(self):\n        a  = etree.Element(\"a\")\n        b  = etree.SubElement(a, \"b\")\n        c  = etree.SubElement(a, \"c\")\n        d1 = etree.SubElement(c, \"d\")\n        d2 = etree.SubElement(c, \"d\")\n        c.text = d1.text = 'TEXT'\n\n        tree = etree.ElementTree(a)\n        self.assertEqual('.', tree.getelementpath(a))\n        self.assertEqual('c/d[1]', tree.getelementpath(d1))\n        self.assertEqual('c/d[2]', tree.getelementpath(d2))\n\n        self.assertEqual(d1, tree.find(tree.getelementpath(d1)))\n        self.assertEqual(d2, tree.find(tree.getelementpath(d2)))\n\n        tree = etree.ElementTree(c)\n        self.assertEqual('.', tree.getelementpath(c))\n        self.assertEqual('d[2]', tree.getelementpath(d2))\n        self.assertEqual(d2, tree.find(tree.getelementpath(d2)))\n\n        tree = etree.ElementTree(b)  # not a parent of a/c/d1/d2\n        self.assertEqual('.', tree.getelementpath(b))\n        self.assertRaises(ValueError, tree.getelementpath, a)\n        self.assertRaises(ValueError, tree.getelementpath, c)\n        self.assertRaises(ValueError, tree.getelementpath, d2)\n\n    def test_elementtree_getelementpath_ns(self):\n        a  = etree.Element(\"{http://ns1/}a\")\n        b  = etree.SubElement(a, \"{http://ns1/}b\")\n        c  = etree.SubElement(a, \"{http://ns1/}c\")\n        d1 = etree.SubElement(c, \"{http://ns1/}d\")\n        d2 = etree.SubElement(c, \"{http://ns2/}d\")\n        d3 = etree.SubElement(c, \"{http://ns1/}d\")\n\n        tree = etree.ElementTree(a)\n        self.assertEqual('.', tree.getelementpath(a))\n        self.assertEqual('{http://ns1/}c/{http://ns1/}d[1]',\n                         tree.getelementpath(d1))\n        self.assertEqual('{http://ns1/}c/{http://ns2/}d',\n                         tree.getelementpath(d2))\n        self.assertEqual('{http://ns1/}c/{http://ns1/}d[2]',\n                         tree.getelementpath(d3))\n\n        self.assertEqual(a, tree.find(tree.getelementpath(a)))\n        self.assertEqual(b, tree.find(tree.getelementpath(b)))\n        self.assertEqual(c, tree.find(tree.getelementpath(c)))\n        self.assertEqual(d1, tree.find(tree.getelementpath(d1)))\n        self.assertEqual(d2, tree.find(tree.getelementpath(d2)))\n        self.assertEqual(d3, tree.find(tree.getelementpath(d3)))\n\n        tree = etree.ElementTree(c)\n        self.assertEqual('{http://ns1/}d[1]', tree.getelementpath(d1))\n        self.assertEqual('{http://ns2/}d', tree.getelementpath(d2))\n        self.assertEqual('{http://ns1/}d[2]', tree.getelementpath(d3))\n        self.assertEqual(d1, tree.find(tree.getelementpath(d1)))\n        self.assertEqual(d2, tree.find(tree.getelementpath(d2)))\n        self.assertEqual(d3, tree.find(tree.getelementpath(d3)))\n\n        tree = etree.ElementTree(b)  # not a parent of d1/d2\n        self.assertRaises(ValueError, tree.getelementpath, d1)\n        self.assertRaises(ValueError, tree.getelementpath, d2)\n\n    def test_elementtree_iter_qname(self):\n        XML = self.etree.XML\n        ElementTree = self.etree.ElementTree\n        QName = self.etree.QName\n        tree = ElementTree(XML(\n                _bytes('<a xmlns:x=\"X\" xmlns:y=\"Y\"><x:b><c/></x:b><b/><c><x:b/><b/></c><b/></a>')))\n        self.assertEqual(\n            list(tree.iter(QName(\"b\"))),\n            list(tree.iter(\"b\")),\n        )\n        self.assertEqual(\n            list(tree.iter(QName(\"X\", \"b\"))),\n            list(tree.iter(\"{X}b\")),\n        )\n\n        self.assertEqual(\n            [e.tag for e in tree.iter(QName(\"X\", \"b\"), QName(\"b\"))],\n            ['{X}b', 'b', '{X}b', 'b', 'b']\n        )\n        self.assertEqual(\n            list(tree.iter(QName(\"X\", \"b\"), QName(\"b\"))),\n            list(tree.iter(\"{X}b\", \"b\"))\n        )\n\n    def test_elementtree_find_qname(self):\n        XML = self.etree.XML\n        ElementTree = self.etree.ElementTree\n        QName = self.etree.QName\n        tree = ElementTree(XML(_bytes('<a><b><c/></b><b/><c><b/></c></a>')))\n        self.assertEqual(tree.find(QName(\"c\")), tree.getroot()[2])\n\n    def test_elementtree_findall_qname(self):\n        XML = self.etree.XML\n        ElementTree = self.etree.ElementTree\n        QName = self.etree.QName\n        tree = ElementTree(XML(_bytes('<a><b><c/></b><b/><c><b/></c></a>')))\n        self.assertEqual(len(list(tree.findall(QName(\"c\")))), 1)\n\n    def test_elementtree_findall_ns_qname(self):\n        XML = self.etree.XML\n        ElementTree = self.etree.ElementTree\n        QName = self.etree.QName\n        tree = ElementTree(XML(\n                _bytes('<a xmlns:x=\"X\" xmlns:y=\"Y\"><x:b><c/></x:b><b/><c><x:b/><b/></c><b/></a>')))\n        self.assertEqual(len(list(tree.findall(QName(\"b\")))), 2)\n        self.assertEqual(len(list(tree.findall(QName(\"X\", \"b\")))), 1)\n\n    def test_findall_ns(self):\n        XML = self.etree.XML\n        root = XML(_bytes('<a xmlns:x=\"X\" xmlns:y=\"Y\"><x:b><c/></x:b><b/><c><x:b/><b/></c><b/></a>'))\n        self.assertEqual(len(root.findall(\".//{X}b\")), 2)\n        self.assertEqual(len(root.findall(\".//{X}*\")), 2)\n        self.assertEqual(len(root.findall(\".//b\")), 3)\n\n    def test_findall_different_nsmaps(self):\n        XML = self.etree.XML\n        root = XML(_bytes('<a xmlns:x=\"X\" xmlns:y=\"Y\"><x:b><c/></x:b><b/><c><x:b/><b/></c><y:b/></a>'))\n        nsmap = {'xx': 'X'}\n        self.assertEqual(len(root.findall(\".//xx:b\", namespaces=nsmap)), 2)\n        self.assertEqual(len(root.findall(\".//xx:*\", namespaces=nsmap)), 2)\n        self.assertEqual(len(root.findall(\".//b\", namespaces=nsmap)), 2)\n        nsmap = {'xx': 'Y'}\n        self.assertEqual(len(root.findall(\".//xx:b\", namespaces=nsmap)), 1)\n        self.assertEqual(len(root.findall(\".//xx:*\", namespaces=nsmap)), 1)\n        self.assertEqual(len(root.findall(\".//b\", namespaces=nsmap)), 2)\n\n    def test_findall_empty_prefix(self):\n        XML = self.etree.XML\n        root = XML(_bytes('<a xmlns:x=\"X\" xmlns:y=\"Y\"><x:b><c/></x:b><b/><c><x:b/><b/></c><y:b/></a>'))\n        nsmap = {'xx': 'X'}\n        self.assertEqual(len(root.findall(\".//xx:b\", namespaces=nsmap)), 2)\n        nsmap = {'xx': 'X', None: 'Y'}\n        self.assertEqual(len(root.findall(\".//b\", namespaces=nsmap)), 1)\n        nsmap = {'xx': 'X', '': 'Y'}\n        self.assertEqual(len(root.findall(\".//b\", namespaces=nsmap)), 1)\n\n    def test_findall_syntax_error(self):\n        XML = self.etree.XML\n        root = XML(_bytes('<a><b><c/></b><b/><c><b/><b/></c><b/></a>'))\n        self.assertRaises(SyntaxError, root.findall, '')\n        self.assertRaises(SyntaxError, root.findall, '//')  # absolute path on Element\n        self.assertRaises(SyntaxError, root.findall, './//')\n\n    def test_index(self):\n        etree = self.etree\n        e = etree.Element('foo')\n        for i in range(10):\n            etree.SubElement(e, 'a%s' % i)\n        for i in range(10):\n            self.assertEqual(\n                i,\n                e.index(e[i]))\n        self.assertEqual(\n            3, e.index(e[3], 3))\n        self.assertRaises(\n            ValueError, e.index, e[3], 4)\n        self.assertRaises(\n            ValueError, e.index, e[3], 0, 2)\n        self.assertRaises(\n            ValueError, e.index, e[8], 0, -3)\n        self.assertRaises(\n            ValueError, e.index, e[8], -5, -3)\n        self.assertEqual(\n            8, e.index(e[8], 0, -1))\n        self.assertEqual(\n            8, e.index(e[8], -12, -1))\n        self.assertEqual(\n            0, e.index(e[0], -12, -1))\n\n    def test_replace(self):\n        etree = self.etree\n        e = etree.Element('foo')\n        for i in range(10):\n            el = etree.SubElement(e, 'a%s' % i)\n            el.text = \"text%d\" % i\n            el.tail = \"tail%d\" % i\n\n        child0 = e[0]\n        child1 = e[1]\n        child2 = e[2]\n\n        e.replace(e[0], e[1])\n        self.assertEqual(\n            9, len(e))\n        self.assertEqual(\n            child1, e[0])\n        self.assertEqual(\n            child1.text, \"text1\")\n        self.assertEqual(\n            child1.tail, \"tail1\")\n        self.assertEqual(\n            child0.tail, \"tail0\")\n        self.assertEqual(\n            child2, e[1])\n\n        e.replace(e[-1], e[0])\n        self.assertEqual(\n            child1, e[-1])\n        self.assertEqual(\n            child1.text, \"text1\")\n        self.assertEqual(\n            child1.tail, \"tail1\")\n        self.assertEqual(\n            child2, e[0])\n\n    def test_replace_new(self):\n        etree = self.etree\n        e = etree.Element('foo')\n        for i in range(10):\n            etree.SubElement(e, 'a%s' % i)\n\n        new_element = etree.Element(\"test\")\n        new_element.text = \"TESTTEXT\"\n        new_element.tail = \"TESTTAIL\"\n        child1 = e[1]\n        e.replace(e[0], new_element)\n        self.assertEqual(\n            new_element, e[0])\n        self.assertEqual(\n            \"TESTTEXT\",\n            e[0].text)\n        self.assertEqual(\n            \"TESTTAIL\",\n            e[0].tail)\n        self.assertEqual(\n            child1, e[1])\n\n    def test_setslice_all_reversed(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n\n        e = Element('e')\n        f = Element('f')\n        g = Element('g')\n\n        a[:] = [e, f, g]\n        self.assertEqual(\n            [e, f, g],\n            list(a))\n\n        a[::-1] = [e, f, g]\n        self.assertEqual(\n            [g, f, e],\n            list(a))\n\n    def test_setslice_step(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(a, 'd')\n        e = SubElement(a, 'e')\n\n        x = Element('x')\n        y = Element('y')\n\n        a[1::2] = [x, y]\n        self.assertEqual(\n            [b, x, d, y],\n            list(a))\n\n    def test_setslice_step_negative(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(a, 'd')\n        e = SubElement(a, 'e')\n\n        x = Element('x')\n        y = Element('y')\n\n        a[1::-1] = [x, y]\n        self.assertEqual(\n            [y, x, d, e],\n            list(a))\n\n    def test_setslice_step_negative2(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(a, 'd')\n        e = SubElement(a, 'e')\n\n        x = Element('x')\n        y = Element('y')\n\n        a[::-2] = [x, y]\n        self.assertEqual(\n            [b, y, d, x],\n            list(a))\n\n    def test_setslice_step_overrun(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        try:\n            slice\n        except NameError:\n            print(\"slice() not found\")\n            return\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(a, 'd')\n        e = SubElement(a, 'e')\n\n        x = Element('x')\n        y = Element('y')\n        z = Element('z')\n\n        self.assertRaises(\n            ValueError,\n            operator.setitem, a, slice(1,None,2), [x, y, z])\n\n        self.assertEqual(\n            [b, c, d, e],\n            list(a))\n\n    def test_sourceline_XML(self):\n        XML = self.etree.XML\n        root = XML(_bytes('''<?xml version=\"1.0\"?>\n        <root><test>\n\n        <bla/></test>\n        </root>\n        '''))\n\n        self.assertEqual(\n            [2, 2, 4],\n            [ el.sourceline for el in root.getiterator() ])\n\n    def test_large_sourceline_XML(self):\n        XML = self.etree.XML\n        root = XML(_bytes(\n            '<?xml version=\"1.0\"?>\\n'\n            '<root>' + '\\n' * 65536 +\n            '<p>' + '\\n' * 65536 + '</p>\\n' +\n            '<br/>\\n'\n            '</root>'))\n\n        if self.etree.LIBXML_VERSION >= (2, 9):\n            expected = [2, 131074, 131076]\n        else:\n            expected = [2, 65535, 65535]\n\n        self.assertEqual(expected, [el.sourceline for el in root.iter()])\n\n    def test_sourceline_parse(self):\n        parse = self.etree.parse\n        tree = parse(fileInTestDir('include/test_xinclude.xml'))\n\n        self.assertEqual(\n            [1, 2, 3],\n            [ el.sourceline for el in tree.getiterator() ])\n\n    def test_sourceline_iterparse_end(self):\n        iterparse = self.etree.iterparse\n        lines = [ el.sourceline for (event, el) in \n                  iterparse(fileInTestDir('include/test_xinclude.xml')) ]\n\n        self.assertEqual(\n            [2, 3, 1],\n            lines)\n\n    def test_sourceline_iterparse_start(self):\n        iterparse = self.etree.iterparse\n        lines = [ el.sourceline for (event, el) in \n                  iterparse(fileInTestDir('include/test_xinclude.xml'),\n                            events=(\"start\",)) ]\n\n        self.assertEqual(\n            [1, 2, 3],\n            lines)\n\n    def test_sourceline_element(self):\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        el = Element(\"test\")\n        self.assertEqual(None, el.sourceline)\n\n        child = SubElement(el, \"test\")\n        self.assertEqual(None, el.sourceline)\n        self.assertEqual(None, child.sourceline)\n\n    def test_XML_base_url_docinfo(self):\n        etree = self.etree\n        root = etree.XML(_bytes(\"<root/>\"), base_url=\"http://no/such/url\")\n        docinfo = root.getroottree().docinfo\n        self.assertEqual(docinfo.URL, \"http://no/such/url\")\n\n    def test_XML_set_base_url_docinfo(self):\n        etree = self.etree\n        root = etree.XML(_bytes(\"<root/>\"), base_url=\"http://no/such/url\")\n        docinfo = root.getroottree().docinfo\n        self.assertEqual(docinfo.URL, \"http://no/such/url\")\n        docinfo.URL = \"https://secret/url\"\n        self.assertEqual(docinfo.URL, \"https://secret/url\")\n\n    def test_parse_stringio_base_url(self):\n        etree = self.etree\n        tree = etree.parse(BytesIO(\"<root/>\"), base_url=\"http://no/such/url\")\n        docinfo = tree.docinfo\n        self.assertEqual(docinfo.URL, \"http://no/such/url\")\n\n    def test_parse_base_url_docinfo(self):\n        etree = self.etree\n        tree = etree.parse(fileInTestDir('include/test_xinclude.xml'),\n                           base_url=\"http://no/such/url\")\n        docinfo = tree.docinfo\n        self.assertEqual(docinfo.URL, \"http://no/such/url\")\n\n    def test_HTML_base_url_docinfo(self):\n        etree = self.etree\n        root = etree.HTML(_bytes(\"<html/>\"), base_url=\"http://no/such/url\")\n        docinfo = root.getroottree().docinfo\n        self.assertEqual(docinfo.URL, \"http://no/such/url\")\n\n    def test_docinfo_public(self):\n        etree = self.etree\n        xml_header = '<?xml version=\"1.0\" encoding=\"ascii\"?>'\n        pub_id = \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\n        sys_id = \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"\n        doctype_string = '<!DOCTYPE html PUBLIC \"%s\" \"%s\">' % (pub_id, sys_id)\n\n        xml = _bytes(xml_header + doctype_string + '<html><body></body></html>')\n\n        tree = etree.parse(BytesIO(xml))\n        docinfo = tree.docinfo\n        self.assertEqual(docinfo.encoding,    \"ascii\")\n        self.assertEqual(docinfo.xml_version, \"1.0\")\n        self.assertEqual(docinfo.public_id,   pub_id)\n        self.assertEqual(docinfo.system_url,  sys_id)\n        self.assertEqual(docinfo.root_name,   'html')\n        self.assertEqual(docinfo.doctype, doctype_string)\n\n    def test_docinfo_system(self):\n        etree = self.etree\n        xml_header = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>'\n        sys_id = \"some.dtd\"\n        doctype_string = '<!DOCTYPE html SYSTEM \"%s\">' % sys_id\n        xml = _bytes(xml_header + doctype_string + '<html><body></body></html>')\n\n        tree = etree.parse(BytesIO(xml))\n        docinfo = tree.docinfo\n        self.assertEqual(docinfo.encoding,    \"UTF-8\")\n        self.assertEqual(docinfo.xml_version, \"1.0\")\n        self.assertEqual(docinfo.public_id,   None)\n        self.assertEqual(docinfo.system_url,  sys_id)\n        self.assertEqual(docinfo.root_name,   'html')\n        self.assertEqual(docinfo.doctype, doctype_string)\n\n    def test_docinfo_empty(self):\n        etree = self.etree\n        xml = _bytes('<html><body></body></html>')\n        tree = etree.parse(BytesIO(xml))\n        docinfo = tree.docinfo\n        self.assertEqual(docinfo.encoding,    \"UTF-8\")\n        self.assertEqual(docinfo.xml_version, \"1.0\")\n        self.assertEqual(docinfo.public_id,   None)\n        self.assertEqual(docinfo.system_url,  None)\n        self.assertEqual(docinfo.root_name,   'html')\n        self.assertEqual(docinfo.doctype, '')\n\n    def test_docinfo_name_only(self):\n        etree = self.etree\n        xml = _bytes('<!DOCTYPE root><root></root>')\n        tree = etree.parse(BytesIO(xml))\n        docinfo = tree.docinfo\n        self.assertEqual(docinfo.encoding,    \"UTF-8\")\n        self.assertEqual(docinfo.xml_version, \"1.0\")\n        self.assertEqual(docinfo.public_id,   None)\n        self.assertEqual(docinfo.system_url,  None)\n        self.assertEqual(docinfo.root_name,   'root')\n        self.assertEqual(docinfo.doctype, '<!DOCTYPE root>')\n\n    def test_doctype_name_only_roundtrip(self):\n        etree = self.etree\n        xml = _bytes('<!DOCTYPE root>\\n<root/>')\n        tree = etree.parse(BytesIO(xml))\n        self.assertEqual(xml, etree.tostring(tree))\n\n    def test_doctype_output_override(self):\n        etree = self.etree\n        pub_id = \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\n        sys_id = \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"\n        doctype_string = _bytes('<!DOCTYPE html PUBLIC \"%s\" \"%s\">' % (pub_id, sys_id))\n\n        xml = _bytes('<!DOCTYPE root>\\n<root/>')\n        tree = etree.parse(BytesIO(xml))\n        self.assertEqual(xml.replace(_bytes('<!DOCTYPE root>'), doctype_string),\n                          etree.tostring(tree, doctype=doctype_string))\n\n    def test_xml_base(self):\n        etree = self.etree\n        root = etree.XML(_bytes(\"<root/>\"), base_url=\"http://no/such/url\")\n        self.assertEqual(root.base, \"http://no/such/url\")\n        self.assertEqual(\n            root.get('{http://www.w3.org/XML/1998/namespace}base'), None)\n        root.base = \"https://secret/url\"\n        self.assertEqual(root.base, \"https://secret/url\")\n        self.assertEqual(\n            root.get('{http://www.w3.org/XML/1998/namespace}base'),\n            \"https://secret/url\")\n\n    def test_xml_base_attribute(self):\n        etree = self.etree\n        root = etree.XML(_bytes(\"<root/>\"), base_url=\"http://no/such/url\")\n        self.assertEqual(root.base, \"http://no/such/url\")\n        self.assertEqual(\n            root.get('{http://www.w3.org/XML/1998/namespace}base'), None)\n        root.set('{http://www.w3.org/XML/1998/namespace}base',\n                 \"https://secret/url\")\n        self.assertEqual(root.base, \"https://secret/url\")\n        self.assertEqual(\n            root.get('{http://www.w3.org/XML/1998/namespace}base'),\n            \"https://secret/url\")\n\n    def test_html_base(self):\n        etree = self.etree\n        root = etree.HTML(_bytes(\"<html><body></body></html>\"),\n                          base_url=\"http://no/such/url\")\n        self.assertEqual(root.base, \"http://no/such/url\")\n\n    def test_html_base_tag(self):\n        etree = self.etree\n        root = etree.HTML(_bytes('<html><head><base href=\"http://no/such/url\"></head></html>'))\n        self.assertEqual(root.base, \"http://no/such/url\")\n\n    def test_indent(self):\n        ET = self.etree\n        elem = ET.XML(\"<root></root>\")\n        ET.indent(elem)\n        self.assertEqual(ET.tostring(elem), b'<root/>')\n\n        elem = ET.XML(\"<html><body>text</body></html>\")\n        ET.indent(elem)\n        self.assertEqual(ET.tostring(elem), b'<html>\\n  <body>text</body>\\n</html>')\n\n        elem = ET.XML(\"<html> <body>text</body>  </html>\")\n        ET.indent(elem)\n        self.assertEqual(ET.tostring(elem), b'<html>\\n  <body>text</body>\\n</html>')\n\n        elem = ET.XML(\"<html> <body>text</body>   </html>\")\n        ET.indent(elem)\n        self.assertEqual(ET.tostring(elem), b'<html>\\n  <body>text</body>\\n</html>')\n\n        elem = ET.XML(\"<html><body>text</body>tail</html>\")\n        ET.indent(elem)\n        self.assertEqual(ET.tostring(elem), b'<html>\\n  <body>text</body>tail</html>')\n\n        elem = ET.XML(\"<html><body><p>par</p>\\n<p>text</p>\\t<p><br/></p></body></html>\")\n        ET.indent(elem)\n        self.assertEqual(\n            ET.tostring(elem),\n            b'<html>\\n'\n            b'  <body>\\n'\n            b'    <p>par</p>\\n'\n            b'    <p>text</p>\\n'\n            b'    <p>\\n'\n            b'      <br/>\\n'\n            b'    </p>\\n'\n            b'  </body>\\n'\n            b'</html>'\n        )\n\n        elem = ET.XML(\"<html><body><p>pre<br/>post</p><p>text</p></body></html>\")\n        ET.indent(elem)\n        self.assertEqual(\n            ET.tostring(elem),\n            b'<html>\\n'\n            b'  <body>\\n'\n            b'    <p>pre<br/>post</p>\\n'\n            b'    <p>text</p>\\n'\n            b'  </body>\\n'\n            b'</html>'\n        )\n\n    def test_indent_space(self):\n        ET = self.etree\n        elem = ET.XML(\"<html><body><p>pre<br/>post</p><p>text</p></body></html>\")\n        ET.indent(elem, space='\\t')\n        self.assertEqual(\n            ET.tostring(elem),\n            b'<html>\\n'\n            b'\\t<body>\\n'\n            b'\\t\\t<p>pre<br/>post</p>\\n'\n            b'\\t\\t<p>text</p>\\n'\n            b'\\t</body>\\n'\n            b'</html>'\n        )\n\n        elem = ET.XML(\"<html><body><p>pre<br/>post</p><p>text</p></body></html>\")\n        ET.indent(elem, space='')\n        self.assertEqual(\n            ET.tostring(elem),\n            b'<html>\\n'\n            b'<body>\\n'\n            b'<p>pre<br/>post</p>\\n'\n            b'<p>text</p>\\n'\n            b'</body>\\n'\n            b'</html>'\n        )\n\n    def test_indent_space_caching(self):\n        ET = self.etree\n        elem = ET.XML(\"<html><body><p>par</p><p>text</p><p><br/></p><p /></body></html>\")\n        ET.indent(elem)\n        self.assertEqual(\n            {el.tail for el in elem.iter()},\n            {None, \"\\n\", \"\\n  \", \"\\n    \"}\n        )\n        self.assertEqual(\n            {el.text for el in elem.iter()},\n            {None, \"\\n  \", \"\\n    \", \"\\n      \", \"par\", \"text\"}\n        )\n        # NOTE: lxml does not reuse Python text strings across elements.\n        #self.assertEqual(\n        #    len({el.tail for el in elem.iter()}),\n        #    len({id(el.tail) for el in elem.iter()}),\n        #)\n\n    def test_indent_level(self):\n        ET = self.etree\n        elem = ET.XML(\"<html><body><p>pre<br/>post</p><p>text</p></body></html>\")\n        try:\n            ET.indent(elem, level=-1)\n        except ValueError:\n            pass\n        else:\n            self.assertTrue(False, \"ValueError not raised\")\n        self.assertEqual(\n            ET.tostring(elem),\n            b\"<html><body><p>pre<br/>post</p><p>text</p></body></html>\"\n        )\n\n        ET.indent(elem, level=2)\n        self.assertEqual(\n            ET.tostring(elem),\n            b'<html>\\n'\n            b'      <body>\\n'\n            b'        <p>pre<br/>post</p>\\n'\n            b'        <p>text</p>\\n'\n            b'      </body>\\n'\n            b'    </html>'\n        )\n\n        elem = ET.XML(\"<html><body><p>pre<br/>post</p><p>text</p></body></html>\")\n        ET.indent(elem, level=1, space=' ')\n        self.assertEqual(\n            ET.tostring(elem),\n            b'<html>\\n'\n            b'  <body>\\n'\n            b'   <p>pre<br/>post</p>\\n'\n            b'   <p>text</p>\\n'\n            b'  </body>\\n'\n            b' </html>'\n        )\n\n    def test_parse_fileobject_unicode(self):\n        # parse from a file object that returns unicode strings\n        f = LargeFileLikeUnicode()\n        tree = self.etree.parse(f)\n        root = tree.getroot()\n        self.assertTrue(root.tag.endswith('root'))\n\n    def test_dtd_io(self):\n        # check that DTDs that go in also go back out\n        xml = _bytes('''\\\n        <!DOCTYPE test SYSTEM \"test.dtd\" [\n          <!ENTITY entity \"tasty\">\n          <!ELEMENT test (a)>\n          <!ELEMENT a (#PCDATA)>\n        ]>\n        <test><a>test-test</a></test>\\\n        ''')\n        tree = self.etree.parse(BytesIO(xml))\n        self.assertEqual(self.etree.tostring(tree).replace(_bytes(\" \"), _bytes(\"\")),\n                         xml.replace(_bytes(\" \"), _bytes(\"\")))\n\n    def test_byte_zero(self):\n        Element = self.etree.Element\n\n        a = Element('a')\n        self.assertRaises(ValueError, setattr, a, \"text\", 'ha\\0ho')\n        self.assertRaises(ValueError, setattr, a, \"tail\", 'ha\\0ho')\n\n        self.assertRaises(ValueError, Element, 'ha\\0ho')\n\n    def test_unicode_byte_zero(self):\n        Element = self.etree.Element\n\n        a = Element('a')\n        self.assertRaises(ValueError, setattr, a, \"text\",\n                          _str('ha\\0ho'))\n        self.assertRaises(ValueError, setattr, a, \"tail\",\n                          _str('ha\\0ho'))\n\n        self.assertRaises(ValueError, Element,\n                          _str('ha\\0ho'))\n\n    def test_byte_invalid(self):\n        Element = self.etree.Element\n\n        a = Element('a')\n        self.assertRaises(ValueError, setattr, a, \"text\", 'ha\\x07ho')\n        self.assertRaises(ValueError, setattr, a, \"text\", 'ha\\x02ho')\n\n        self.assertRaises(ValueError, setattr, a, \"tail\", 'ha\\x07ho')\n        self.assertRaises(ValueError, setattr, a, \"tail\", 'ha\\x02ho')\n\n        self.assertRaises(ValueError, Element, 'ha\\x07ho')\n        self.assertRaises(ValueError, Element, 'ha\\x02ho')\n\n    def test_unicode_byte_invalid(self):\n        Element = self.etree.Element\n\n        a = Element('a')\n        self.assertRaises(ValueError, setattr, a, \"text\",\n                          _str('ha\\x07ho'))\n        self.assertRaises(ValueError, setattr, a, \"text\",\n                          _str('ha\\x02ho'))\n\n        self.assertRaises(ValueError, setattr, a, \"tail\",\n                          _str('ha\\x07ho'))\n        self.assertRaises(ValueError, setattr, a, \"tail\",\n                          _str('ha\\x02ho'))\n\n        self.assertRaises(ValueError, Element,\n                          _str('ha\\x07ho'))\n        self.assertRaises(ValueError, Element,\n                          _str('ha\\x02ho'))\n\n    def test_unicode_byte_invalid_sequence(self):\n        Element = self.etree.Element\n\n        a = Element('a')\n        self.assertRaises(ValueError, setattr, a, \"text\",\n                          _str('ha\\u1234\\x07ho'))\n        self.assertRaises(ValueError, setattr, a, \"text\",\n                          _str('ha\\u1234\\x02ho'))\n\n        self.assertRaises(ValueError, setattr, a, \"tail\",\n                          _str('ha\\u1234\\x07ho'))\n        self.assertRaises(ValueError, setattr, a, \"tail\",\n                          _str('ha\\u1234\\x02ho'))\n\n        self.assertRaises(ValueError, Element,\n                          _str('ha\\u1234\\x07ho'))\n        self.assertRaises(ValueError, Element,\n                          _str('ha\\u1234\\x02ho'))\n\n    def test_encoding_tostring_utf16(self):\n        # ElementTree fails to serialize this\n        tostring = self.etree.tostring\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        \n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n\n        result = tostring(a, encoding='UTF-16')\n        self.assertEqual(_bytes('<a><b></b><c></c></a>'),\n                          canonicalize(result))\n\n    def test_tostring_none(self):\n        # ElementTree raises an AssertionError here\n        tostring = self.etree.tostring\n        self.assertRaises(TypeError, self.etree.tostring, None)\n\n    def test_tostring_pretty(self):\n        tostring = self.etree.tostring\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n\n        result = tostring(a)\n        self.assertEqual(result, _bytes(\"<a><b/><c/></a>\"))\n\n        result = tostring(a, pretty_print=False)\n        self.assertEqual(result, _bytes(\"<a><b/><c/></a>\"))\n\n        result = tostring(a, pretty_print=True)\n        self.assertEqual(result, _bytes(\"<a>\\n  <b/>\\n  <c/>\\n</a>\\n\"))\n\n    def test_tostring_with_tail(self):\n        tostring = self.etree.tostring\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        a.tail = \"aTAIL\"\n        b = SubElement(a, 'b')\n        b.tail = \"bTAIL\"\n        c = SubElement(a, 'c')\n\n        result = tostring(a)\n        self.assertEqual(result, _bytes(\"<a><b/>bTAIL<c/></a>aTAIL\"))\n\n        result = tostring(a, with_tail=False)\n        self.assertEqual(result, _bytes(\"<a><b/>bTAIL<c/></a>\"))\n\n        result = tostring(a, with_tail=True)\n        self.assertEqual(result, _bytes(\"<a><b/>bTAIL<c/></a>aTAIL\"))\n\n    def test_tostring_method_html_with_tail(self):\n        tostring = self.etree.tostring\n        html = self.etree.fromstring(\n            '<html><body>'\n            '<div><p>Some text<i>\\r\\n</i></p></div>\\r\\n'\n            '</body></html>',\n            parser=self.etree.HTMLParser())\n        self.assertEqual(html.tag, 'html')\n        div = html.find('.//div')\n        self.assertEqual(div.tail, '\\r\\n')\n        result = tostring(div, method='html')\n        self.assertEqual(\n            result,\n            _bytes(\"<div><p>Some text<i>\\r\\n</i></p></div>\\r\\n\"))\n        result = tostring(div, method='html', with_tail=True)\n        self.assertEqual(\n            result,\n            _bytes(\"<div><p>Some text<i>\\r\\n</i></p></div>\\r\\n\"))\n        result = tostring(div, method='html', with_tail=False)\n        self.assertEqual(\n            result,\n            _bytes(\"<div><p>Some text<i>\\r\\n</i></p></div>\"))\n\n    def test_standalone(self):\n        tostring = self.etree.tostring\n        XML = self.etree.XML\n        ElementTree = self.etree.ElementTree\n        Element = self.etree.Element\n\n        tree = Element(\"root\").getroottree()\n        self.assertEqual(None, tree.docinfo.standalone)\n\n        tree = XML(_bytes(\"<root/>\")).getroottree()\n        self.assertEqual(None, tree.docinfo.standalone)\n\n        tree = XML(_bytes(\n            \"<?xml version='1.0' encoding='ASCII' standalone='yes'?>\\n<root/>\"\n            )).getroottree()\n        self.assertEqual(True, tree.docinfo.standalone)\n\n        tree = XML(_bytes(\n            \"<?xml version='1.0' encoding='ASCII' standalone='no'?>\\n<root/>\"\n            )).getroottree()\n        self.assertEqual(False, tree.docinfo.standalone)\n\n    def test_tostring_standalone(self):\n        tostring = self.etree.tostring\n        XML = self.etree.XML\n        ElementTree = self.etree.ElementTree\n\n        root = XML(_bytes(\"<root/>\"))\n\n        tree = ElementTree(root)\n        self.assertEqual(None, tree.docinfo.standalone)\n\n        result = tostring(root, xml_declaration=True, encoding=\"ASCII\")\n        self.assertEqual(result, _bytes(\n            \"<?xml version='1.0' encoding='ASCII'?>\\n<root/>\"))\n\n        result = tostring(root, xml_declaration=True, encoding=\"ASCII\",\n                          standalone=True)\n        self.assertEqual(result, _bytes(\n            \"<?xml version='1.0' encoding='ASCII' standalone='yes'?>\\n<root/>\"))\n\n        tree = ElementTree(XML(result))\n        self.assertEqual(True, tree.docinfo.standalone)\n\n        result = tostring(root, xml_declaration=True, encoding=\"ASCII\",\n                          standalone=False)\n        self.assertEqual(result, _bytes(\n            \"<?xml version='1.0' encoding='ASCII' standalone='no'?>\\n<root/>\"))\n\n        tree = ElementTree(XML(result))\n        self.assertEqual(False, tree.docinfo.standalone)\n\n    def test_tostring_standalone_in_out(self):\n        tostring = self.etree.tostring\n        XML = self.etree.XML\n        ElementTree = self.etree.ElementTree\n\n        root = XML(_bytes(\n            \"<?xml version='1.0' encoding='UTF-8' standalone='yes'?>\\n<root/>\"))\n\n        tree = ElementTree(root)\n        self.assertEqual(True, tree.docinfo.standalone)\n\n        result = tostring(root, xml_declaration=True, encoding=\"ASCII\")\n        self.assertEqual(result, _bytes(\n            \"<?xml version='1.0' encoding='ASCII'?>\\n<root/>\"))\n\n        result = tostring(root, xml_declaration=True, encoding=\"ASCII\",\n                          standalone=True)\n        self.assertEqual(result, _bytes(\n            \"<?xml version='1.0' encoding='ASCII' standalone='yes'?>\\n<root/>\"))\n\n    def test_tostring_method_text_encoding(self):\n        tostring = self.etree.tostring\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        \n        a = Element('a')\n        a.text = \"A\"\n        a.tail = \"tail\"\n        b = SubElement(a, 'b')\n        b.text = \"B\"\n        b.tail = _str(\"S\u00f8k p\u00e5 nettet\")\n        c = SubElement(a, 'c')\n        c.text = \"C\"\n\n        result = tostring(a, method=\"text\", encoding=\"UTF-16\")\n\n        self.assertEqual(_str('ABS\u00f8k p\u00e5 nettetCtail').encode(\"UTF-16\"),\n                          result)\n\n    def test_tostring_method_text_unicode(self):\n        tostring = self.etree.tostring\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        \n        a = Element('a')\n        a.text = _str('S\u00f8k p\u00e5 nettetA')\n        a.tail = \"tail\"\n        b = SubElement(a, 'b')\n        b.text = \"B\"\n        b.tail = _str('S\u00f8k p\u00e5 nettetB')\n        c = SubElement(a, 'c')\n        c.text = \"C\"\n        \n        self.assertRaises(UnicodeEncodeError,\n                          tostring, a, method=\"text\")\n        \n        self.assertEqual(\n            _str('S\u00f8k p\u00e5 nettetABS\u00f8k p\u00e5 nettetBCtail').encode('utf-8'),\n            tostring(a, encoding=\"UTF-8\", method=\"text\"))\n\n    def test_tounicode(self):\n        tounicode = self.etree.tounicode\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        \n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        \n        self.assertTrue(isinstance(tounicode(a), _unicode))\n        self.assertEqual(_bytes('<a><b></b><c></c></a>'),\n                          canonicalize(tounicode(a)))\n\n    def test_tounicode_element(self):\n        tounicode = self.etree.tounicode\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        \n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(c, 'd')\n        self.assertTrue(isinstance(tounicode(b), _unicode))\n        self.assertTrue(isinstance(tounicode(c), _unicode))\n        self.assertEqual(_bytes('<b></b>'),\n                          canonicalize(tounicode(b)))\n        self.assertEqual(_bytes('<c><d></d></c>'),\n                          canonicalize(tounicode(c)))\n\n    def test_tounicode_none(self):\n        tounicode = self.etree.tounicode\n        self.assertRaises(TypeError, self.etree.tounicode, None)\n\n    def test_tounicode_element_tail(self):\n        tounicode = self.etree.tounicode\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        \n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(c, 'd')\n        b.tail = 'Foo'\n\n        self.assertTrue(isinstance(tounicode(b), _unicode))\n        self.assertTrue(tounicode(b) == '<b/>Foo' or\n                     tounicode(b) == '<b />Foo')\n\n    def test_tounicode_pretty(self):\n        tounicode = self.etree.tounicode\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n\n        result = tounicode(a)\n        self.assertEqual(result, \"<a><b/><c/></a>\")\n\n        result = tounicode(a, pretty_print=False)\n        self.assertEqual(result, \"<a><b/><c/></a>\")\n\n        result = tounicode(a, pretty_print=True)\n        self.assertEqual(result, \"<a>\\n  <b/>\\n  <c/>\\n</a>\\n\")\n\n    def test_tostring_unicode(self):\n        tostring = self.etree.tostring\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        \n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        \n        self.assertTrue(isinstance(tostring(a, encoding=_unicode), _unicode))\n        self.assertEqual(_bytes('<a><b></b><c></c></a>'),\n                          canonicalize(tostring(a, encoding=_unicode)))\n\n    def test_tostring_unicode_element(self):\n        tostring = self.etree.tostring\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        \n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(c, 'd')\n        self.assertTrue(isinstance(tostring(b, encoding=_unicode), _unicode))\n        self.assertTrue(isinstance(tostring(c, encoding=_unicode), _unicode))\n        self.assertEqual(_bytes('<b></b>'),\n                          canonicalize(tostring(b, encoding=_unicode)))\n        self.assertEqual(_bytes('<c><d></d></c>'),\n                          canonicalize(tostring(c, encoding=_unicode)))\n\n    def test_tostring_unicode_none(self):\n        tostring = self.etree.tostring\n        self.assertRaises(TypeError, self.etree.tostring,\n                          None, encoding=_unicode)\n\n    def test_tostring_unicode_element_tail(self):\n        tostring = self.etree.tostring\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n        \n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n        d = SubElement(c, 'd')\n        b.tail = 'Foo'\n\n        self.assertTrue(isinstance(tostring(b, encoding=_unicode), _unicode))\n        self.assertTrue(tostring(b, encoding=_unicode) == '<b/>Foo' or\n                     tostring(b, encoding=_unicode) == '<b />Foo')\n\n    def test_tostring_unicode_pretty(self):\n        tostring = self.etree.tostring\n        Element = self.etree.Element\n        SubElement = self.etree.SubElement\n\n        a = Element('a')\n        b = SubElement(a, 'b')\n        c = SubElement(a, 'c')\n\n        result = tostring(a, encoding=_unicode)\n        self.assertEqual(result, \"<a><b/><c/></a>\")\n\n        result = tostring(a, encoding=_unicode, pretty_print=False)\n        self.assertEqual(result, \"<a><b/><c/></a>\")\n\n        result = tostring(a, encoding=_unicode, pretty_print=True)\n        self.assertEqual(result, \"<a>\\n  <b/>\\n  <c/>\\n</a>\\n\")\n\n    def test_pypy_proxy_collect(self):\n        root = etree.Element('parent')\n        etree.SubElement(root, 'child')\n\n        self.assertEqual(len(root), 1)\n        self.assertEqual(root[0].tag, 'child')\n\n        # in PyPy, GC used to kill the Python proxy instance without cleanup\n        gc.collect()\n        self.assertEqual(len(root), 1)\n        self.assertEqual(root[0].tag, 'child')\n\n    def test_element_refcycle(self):\n        class SubEl(etree.ElementBase):\n            pass\n\n        el1 = SubEl()\n        el2 = SubEl()\n        self.assertEqual('SubEl', el1.tag)\n        self.assertEqual('SubEl', el2.tag)\n        el1.other = el2\n        el2.other = el1\n\n        del el1, el2\n        gc.collect()\n        # not really testing anything here, but it shouldn't crash\n\n    def test_proxy_collect_siblings(self):\n        root = etree.Element('parent')\n        c1 = etree.SubElement(root, 'child1')\n        c2 = etree.SubElement(root, 'child2')\n\n        root.remove(c1)\n        root.remove(c2)\n        c1.addnext(c2)\n        del c1\n        # trigger deallocation attempt of c1\n        c2.getprevious()\n        # make sure it wasn't deallocated\n        self.assertEqual('child1', c2.getprevious().tag)\n\n    def test_proxy_collect_siblings_text(self):\n        root = etree.Element('parent')\n        c1 = etree.SubElement(root, 'child1')\n        c2 = etree.SubElement(root, 'child2')\n\n        root.remove(c1)\n        root.remove(c2)\n        c1.addnext(c2)\n        c1.tail = 'abc'\n        c2.tail = 'xyz'\n        del c1\n        # trigger deallocation attempt of c1\n        c2.getprevious()\n        # make sure it wasn't deallocated\n        self.assertEqual('child1', c2.getprevious().tag)\n        self.assertEqual('abc', c2.getprevious().tail)\n\n    def test_parse_source_pathlike(self):\n        etree = self.etree\n        tounicode = self.etree.tounicode\n\n        tree = etree.parse(SimpleFSPath(fileInTestDir('test.xml')))\n        self.assertEqual(_bytes('<a><b></b></a>'),\n                         canonicalize(tounicode(tree)))\n    \n    def test_iterparse_source_pathlike(self):\n        iterparse = self.etree.iterparse\n\n        events = list(iterparse(SimpleFSPath(fileInTestDir('test.xml'))))\n        self.assertEqual(2, len(events))\n\n    # helper methods\n\n    def _writeElement(self, element, encoding='us-ascii', compression=0):\n        \"\"\"Write out element for comparison.\n        \"\"\"\n        ElementTree = self.etree.ElementTree\n        f = BytesIO()\n        tree = ElementTree(element=element)\n        tree.write(f, encoding=encoding, compression=compression)\n        data = f.getvalue()\n        if compression:\n            data = zlib.decompress(data)\n        return canonicalize(data)\n\n\nclass _XIncludeTestCase(HelperTestCase):\n    def test_xinclude_text(self):\n        filename = fileInTestDir('test_broken.xml')\n        root = etree.XML(_bytes('''\\\n        <doc xmlns:xi=\"http://www.w3.org/2001/XInclude\">\n          <xi:include href=\"%s\" parse=\"text\"/>\n        </doc>\n        ''' % path2url(filename)))\n        old_text = root.text\n        content = read_file(filename)\n        old_tail = root[0].tail\n\n        self.include( etree.ElementTree(root) )\n        self.assertEqual(old_text + content + old_tail,\n                          root.text)\n\n    def test_xinclude(self):\n        tree = etree.parse(fileInTestDir('include/test_xinclude.xml'))\n        self.assertNotEqual(\n            'a',\n            tree.getroot()[1].tag)\n        # process xincludes\n        self.include( tree )\n        # check whether we find it replaced with included data\n        self.assertEqual(\n            'a',\n            tree.getroot()[1].tag)\n\n    def test_xinclude_resolver(self):\n        class res(etree.Resolver):\n            include_text = read_file(fileInTestDir('test.xml'))\n            called = {}\n            def resolve(self, url, id, context):\n                if url.endswith(\".dtd\"):\n                    self.called[\"dtd\"] = True\n                    return self.resolve_filename(\n                        fileInTestDir('test.dtd'), context)\n                elif url.endswith(\"test_xinclude.xml\"):\n                    self.called[\"input\"] = True\n                    return None # delegate to default resolver\n                else:\n                    self.called[\"include\"] = True\n                    return self.resolve_string(self.include_text, context)\n\n        res_instance = res()\n        parser = etree.XMLParser(load_dtd = True)\n        parser.resolvers.add(res_instance)\n\n        tree = etree.parse(fileInTestDir('include/test_xinclude.xml'),\n                           parser = parser)\n\n        self.include(tree)\n\n        called = list(res_instance.called.items())\n        called.sort()\n        self.assertEqual(\n            [(\"dtd\", True), (\"include\", True), (\"input\", True)],\n            called)\n\n    def test_xinclude_resolver_recursive(self):\n        data = textwrap.dedent('''\n        <doc xmlns:xi=\"http://www.w3.org/2001/XInclude\">\n        <foo/>\n        <xi:include href=\"./test.xml\" />\n        </doc>\n        ''')\n\n        class Resolver(etree.Resolver):\n            called = {}\n\n            def resolve(self, url, id, context):\n                if url.endswith(\"test_xinclude.xml\"):\n                    assert not self.called.get(\"input\")\n                    self.called[\"input\"] = True\n                    return None  # delegate to default resolver\n                elif url.endswith('/test5.xml'):\n                    assert not self.called.get(\"DONE\")\n                    self.called[\"DONE\"] = True\n                    return self.resolve_string('<DONE/>', context)\n                else:\n                    _, filename = url.rsplit('/', 1)\n                    assert not self.called.get(filename)\n                    self.called[filename] = True\n                    next_data = data.replace(\n                        'test.xml', 'test%d.xml' % len(self.called))\n                    return self.resolve_string(next_data, context)\n\n        res_instance = Resolver()\n        parser = etree.XMLParser(load_dtd=True)\n        parser.resolvers.add(res_instance)\n\n        tree = etree.parse(fileInTestDir('include/test_xinclude.xml'),\n                           parser=parser)\n\n        self.include(tree)\n\n        called = list(res_instance.called.items())\n        called.sort()\n        self.assertEqual(\n            [(\"DONE\", True), (\"input\", True), (\"test.xml\", True),\n             (\"test2.xml\", True), (\"test3.xml\", True), (\"test4.xml\", True)],\n            called)\n\n\nclass ETreeXIncludeTestCase(_XIncludeTestCase):\n    def include(self, tree):\n        tree.xinclude()\n\n\nclass ElementIncludeTestCase(_XIncludeTestCase):\n    from lxml import ElementInclude\n\n    def include(self, tree, loader=None, max_depth=None):\n        self.ElementInclude.include(tree.getroot(), loader=loader, max_depth=max_depth)\n\n    XINCLUDE = {}\n\n    XINCLUDE[\"Recursive1.xml\"] = \"\"\"\\\n    <?xml version='1.0'?>\n    <document xmlns:xi=\"http://www.w3.org/2001/XInclude\">\n      <p>The following is the source code of Recursive2.xml:</p>\n      <xi:include href=\"Recursive2.xml\"/>\n    </document>\n    \"\"\"\n\n    XINCLUDE[\"Recursive2.xml\"] = \"\"\"\\\n    <?xml version='1.0'?>\n    <document xmlns:xi=\"http://www.w3.org/2001/XInclude\">\n      <p>The following is the source code of Recursive3.xml:</p>\n      <xi:include href=\"Recursive3.xml\"/>\n    </document>\n    \"\"\"\n\n    XINCLUDE[\"Recursive3.xml\"] = \"\"\"\\\n    <?xml version='1.0'?>\n    <document xmlns:xi=\"http://www.w3.org/2001/XInclude\">\n      <p>The following is the source code of Recursive1.xml:</p>\n      <xi:include href=\"Recursive1.xml\"/>\n    </document>\n    \"\"\"\n\n    XINCLUDE[\"NonRecursive1.xml\"] = \"\"\"\\\n    <?xml version='1.0'?>\n    <document xmlns:xi=\"http://www.w3.org/2001/XInclude\">\n      <p>The following is multiple times the source code of NonRecursive3.xml:</p>\n      <xi:include href=\"NonRecursive3.xml\"/>\n      <xi:include href=\"NonRecursive3.xml\"/>\n      <p>The following is multiple times the source code of Leaf.xml:</p>\n      <xi:include href=\"Leaf.xml\"/>\n      <xi:include href=\"Leaf.xml\"/>\n      <xi:include href=\"Leaf.xml\"/>\n      <p>One more time the source code of NonRecursive3.xml:</p>\n      <xi:include href=\"NonRecursive3.xml\"/>\n    </document>\n    \"\"\"\n\n    XINCLUDE[\"NonRecursive2.xml\"] = \"\"\"\\\n    <?xml version='1.0'?>\n    <document xmlns:xi=\"http://www.w3.org/2001/XInclude\">\n      <p>The following is multiple times the source code of NonRecursive3.xml:</p>\n      <xi:include href=\"NonRecursive3.xml\"/>\n      <xi:include href=\"NonRecursive3.xml\"/>\n    </document>\n    \"\"\"\n\n    XINCLUDE[\"NonRecursive3.xml\"] = \"\"\"\\\n    <?xml version='1.0'?>\n    <document xmlns:xi=\"http://www.w3.org/2001/XInclude\">\n      <p>The following is multiple times the source code of Leaf.xml:</p>\n      <xi:include href=\"Leaf.xml\"/>\n      <xi:include href=\"Leaf.xml\"/>\n    </document>\n    \"\"\"\n\n    XINCLUDE[\"Leaf.xml\"] = \"\"\"\\\n    <?xml version='1.0'?>\n    <document xmlns:xi=\"http://www.w3.org/2001/XInclude\">\n      <p>No further includes</p>\n    </document>\n    \"\"\"\n\n    def xinclude_loader(self, href, parse=\"xml\", encoding=None):\n        try:\n            data = textwrap.dedent(self.XINCLUDE[href])\n        except KeyError:\n            raise OSError(\"resource not found\")\n        if parse == \"xml\":\n            data = etree.fromstring(data)\n        return data\n\n    def test_xinclude_failures(self):\n        # Test infinitely recursive includes.\n        document = self.xinclude_loader(\"Recursive1.xml\").getroottree()\n        with self.assertRaises(self.ElementInclude.FatalIncludeError) as cm:\n            self.include(document, self.xinclude_loader)\n        self.assertEqual(str(cm.exception),\n                         \"recursive include of 'Recursive2.xml' detected\")\n\n        # Test 'max_depth' limitation.\n        document = self.xinclude_loader(\"Recursive1.xml\").getroottree()\n        with self.assertRaises(self.ElementInclude.FatalIncludeError) as cm:\n            self.include(document, self.xinclude_loader, max_depth=None)\n        self.assertEqual(str(cm.exception),\n                         \"recursive include of 'Recursive2.xml' detected\")\n\n        document = self.xinclude_loader(\"Recursive1.xml\").getroottree()\n        with self.assertRaises(self.ElementInclude.LimitedRecursiveIncludeError) as cm:\n            self.include(document, self.xinclude_loader, max_depth=0)\n        self.assertEqual(str(cm.exception),\n                         \"maximum xinclude depth reached when including file Recursive2.xml\")\n\n        document = self.xinclude_loader(\"Recursive1.xml\").getroottree()\n        with self.assertRaises(self.ElementInclude.LimitedRecursiveIncludeError) as cm:\n            self.include(document, self.xinclude_loader, max_depth=1)\n        self.assertEqual(str(cm.exception),\n                         \"maximum xinclude depth reached when including file Recursive3.xml\")\n\n        document = self.xinclude_loader(\"Recursive1.xml\").getroottree()\n        with self.assertRaises(self.ElementInclude.LimitedRecursiveIncludeError) as cm:\n            self.include(document, self.xinclude_loader, max_depth=2)\n        self.assertEqual(str(cm.exception),\n                         \"maximum xinclude depth reached when including file Recursive1.xml\")\n\n        document = self.xinclude_loader(\"Recursive1.xml\").getroottree()\n        with self.assertRaises(self.ElementInclude.FatalIncludeError) as cm:\n            self.include(document, self.xinclude_loader, max_depth=3)\n        self.assertEqual(str(cm.exception),\n                         \"recursive include of 'Recursive2.xml' detected\")\n\n    def test_multiple_include_of_same_file(self):\n        # Test that including the same file multiple times, but on the same level\n        # is not detected as recursive include\n        document = self.xinclude_loader(\"NonRecursive3.xml\").getroottree()\n        self.include(document, self.xinclude_loader)\n\n        # same but for more than one level\n        document = self.xinclude_loader(\"NonRecursive1.xml\").getroottree()\n        self.include(document, self.xinclude_loader)\n\n        # same but no Leaf.xml in top-level file\n        document = self.xinclude_loader(\"NonRecursive2.xml\").getroottree()\n        self.include(document, self.xinclude_loader)\n\n\nclass ETreeC14NTestCase(HelperTestCase):\n    def test_c14n(self):\n        tree = self.parse(_bytes('<a><b/></a>'))\n        f = BytesIO()\n        tree.write_c14n(f)\n        s = f.getvalue()\n        self.assertEqual(_bytes('<a><b></b></a>'),\n                          s)\n\n    def test_c14n_gzip(self):\n        tree = self.parse(_bytes('<a>'+'<b/>'*200+'</a>'))\n        f = BytesIO()\n        tree.write_c14n(f, compression=9)\n        with gzip.GzipFile(fileobj=BytesIO(f.getvalue())) as gzfile:\n            s = gzfile.read()\n        self.assertEqual(_bytes('<a>'+'<b></b>'*200+'</a>'),\n                          s)\n\n    def test_c14n_file(self):\n        tree = self.parse(_bytes('<a><b/></a>'))\n        with tmpfile() as filename:\n            tree.write_c14n(filename)\n            data = read_file(filename, 'rb')\n        self.assertEqual(_bytes('<a><b></b></a>'),\n                          data)\n    \n    def test_c14n_file_pathlike(self):\n        tree = self.parse(_bytes('<a><b/></a>'))\n        with tmpfile() as filename:\n            tree.write_c14n(SimpleFSPath(filename))\n            data = read_file(filename, 'rb')\n        self.assertEqual(_bytes('<a><b></b></a>'),\n                        data)\n\n    def test_c14n_file_gzip(self):\n        tree = self.parse(_bytes('<a>'+'<b/>'*200+'</a>'))\n        with tmpfile() as filename:\n            tree.write_c14n(filename, compression=9)\n            with gzip.open(filename, 'rb') as f:\n                data = f.read()\n        self.assertEqual(_bytes('<a>'+'<b></b>'*200+'</a>'),\n                          data)\n    \n    def test_c14n_file_gzip_pathlike(self):\n        tree = self.parse(_bytes('<a>'+'<b/>'*200+'</a>'))\n        with tmpfile() as filename:\n            tree.write_c14n(SimpleFSPath(filename), compression=9)\n            with gzip.open(filename, 'rb') as f:\n                data = f.read()\n        self.assertEqual(_bytes('<a>'+'<b></b>'*200+'</a>'),\n                        data)\n\n    def test_c14n2_file_gzip(self):\n        tree = self.parse(_bytes('<a>'+'<b/>'*200+'</a>'))\n        with tmpfile() as filename:\n            tree.write(filename, method='c14n2', compression=9)\n            with gzip.open(filename, 'rb') as f:\n                data = f.read()\n        self.assertEqual(_bytes('<a>'+'<b></b>'*200+'</a>'),\n                          data)\n\n    def test_c14n2_with_text(self):\n        tree = self.parse(\n            b'<?xml version=\"1.0\"?>    <a> abc \\n <b>  btext </b> btail <c/>    ctail </a>     ')\n        f = BytesIO()\n        tree.write(f, method='c14n2')\n        s = f.getvalue()\n        self.assertEqual(b'<a> abc \\n <b>  btext </b> btail <c></c>    ctail </a>',\n                         s)\n\n        f = BytesIO()\n        tree.write(f, method='c14n2', strip_text=True)\n        s = f.getvalue()\n        self.assertEqual(b'<a>abc<b>btext</b>btail<c></c>ctail</a>',\n                         s)\n\n    def test_c14n_with_comments(self):\n        tree = self.parse(_bytes('<!--hi--><a><!--ho--><b/></a><!--hu-->'))\n        f = BytesIO()\n        tree.write_c14n(f)\n        s = f.getvalue()\n        self.assertEqual(_bytes('<!--hi-->\\n<a><!--ho--><b></b></a>\\n<!--hu-->'),\n                          s)\n        f = BytesIO()\n        tree.write_c14n(f, with_comments=True)\n        s = f.getvalue()\n        self.assertEqual(_bytes('<!--hi-->\\n<a><!--ho--><b></b></a>\\n<!--hu-->'),\n                          s)\n        f = BytesIO()\n        tree.write_c14n(f, with_comments=False)\n        s = f.getvalue()\n        self.assertEqual(_bytes('<a><b></b></a>'),\n                          s)\n\n    def test_c14n2_with_comments(self):\n        tree = self.parse(b'<!--hi--> <a> <!-- ho --> <b/> </a> <!-- hu -->')\n        self.assertEqual(\n            b'<!--hi-->\\n<a> <!-- ho --> <b></b> </a>\\n<!-- hu -->',\n            etree.tostring(tree, method='c14n2'))\n\n        self.assertEqual(\n            b'<!--hi-->\\n<a> <!-- ho --> <b></b> </a>\\n<!-- hu -->',\n            etree.tostring(tree, method='c14n2', with_comments=True))\n\n        self.assertEqual(\n            b'<a>  <b></b> </a>',\n            etree.tostring(tree, method='c14n2', with_comments=False))\n\n    def test_c14n2_with_comments_strip_text(self):\n        tree = self.parse(b'<!--hi--> <a> <!-- ho --> <b/> </a> <!-- hu -->')\n        self.assertEqual(\n            b'<!--hi-->\\n<a><!-- ho --><b></b></a>\\n<!-- hu -->',\n            etree.tostring(tree, method='c14n2', with_comments=True, strip_text=True))\n        self.assertEqual(\n            b'<a><b></b></a>',\n            etree.tostring(tree, method='c14n2', with_comments=False, strip_text=True))\n\n    def test_c14n_tostring_with_comments(self):\n        tree = self.parse(_bytes('<!--hi--><a><!--ho--><b/></a><!--hu-->'))\n        s = etree.tostring(tree, method='c14n')\n        self.assertEqual(_bytes('<!--hi-->\\n<a><!--ho--><b></b></a>\\n<!--hu-->'),\n                          s)\n        s = etree.tostring(tree, method='c14n', with_comments=True)\n        self.assertEqual(_bytes('<!--hi-->\\n<a><!--ho--><b></b></a>\\n<!--hu-->'),\n                          s)\n        s = etree.tostring(tree, method='c14n', with_comments=False)\n        self.assertEqual(_bytes('<a><b></b></a>'),\n                          s)\n\n    def test_c14n2_tostring_with_comments(self):\n        tree = self.parse(b'<!--hi--><a><!--ho--><b/></a><!--hu-->')\n        s = etree.tostring(tree, method='c14n2')\n        self.assertEqual(b'<!--hi-->\\n<a><!--ho--><b></b></a>\\n<!--hu-->',\n                          s)\n        s = etree.tostring(tree, method='c14n2', with_comments=True)\n        self.assertEqual(b'<!--hi-->\\n<a><!--ho--><b></b></a>\\n<!--hu-->',\n                          s)\n        s = etree.tostring(tree, method='c14n2', with_comments=False)\n        self.assertEqual(b'<a><b></b></a>',\n                          s)\n\n    def test_c14n_element_tostring_with_comments(self):\n        tree = self.parse(_bytes('<!--hi--><a><!--ho--><b/></a><!--hu-->'))\n        s = etree.tostring(tree.getroot(), method='c14n')\n        self.assertEqual(_bytes('<a><!--ho--><b></b></a>'),\n                          s)\n        s = etree.tostring(tree.getroot(), method='c14n', with_comments=True)\n        self.assertEqual(_bytes('<a><!--ho--><b></b></a>'),\n                          s)\n        s = etree.tostring(tree.getroot(), method='c14n', with_comments=False)\n        self.assertEqual(_bytes('<a><b></b></a>'),\n                          s)\n\n    def test_c14n_exclusive(self):\n        tree = self.parse(_bytes(\n                '<a xmlns=\"http://abc\" xmlns:y=\"http://bcd\" xmlns:z=\"http://cde\"><z:b/></a>'))\n        f = BytesIO()\n        tree.write_c14n(f)\n        s = f.getvalue()\n        self.assertEqual(_bytes('<a xmlns=\"http://abc\" xmlns:y=\"http://bcd\" xmlns:z=\"http://cde\"><z:b></z:b></a>'),\n                          s)\n        f = BytesIO()\n        tree.write_c14n(f, exclusive=False)\n        s = f.getvalue()\n        self.assertEqual(_bytes('<a xmlns=\"http://abc\" xmlns:y=\"http://bcd\" xmlns:z=\"http://cde\"><z:b></z:b></a>'),\n                          s)\n        f = BytesIO()\n        tree.write_c14n(f, exclusive=True)\n        s = f.getvalue()\n        self.assertEqual(_bytes('<a xmlns=\"http://abc\"><z:b xmlns:z=\"http://cde\"></z:b></a>'),\n                          s)\n\n        f = BytesIO()\n        tree.write_c14n(f, exclusive=True, inclusive_ns_prefixes=['z'])\n        s = f.getvalue()\n        self.assertEqual(_bytes('<a xmlns=\"http://abc\" xmlns:z=\"http://cde\"><z:b></z:b></a>'),\n                          s)\n\n    def test_c14n_tostring_exclusive(self):\n        tree = self.parse(_bytes(\n                '<a xmlns=\"http://abc\" xmlns:y=\"http://bcd\" xmlns:z=\"http://cde\"><z:b/></a>'))\n        s = etree.tostring(tree, method='c14n')\n        self.assertEqual(_bytes('<a xmlns=\"http://abc\" xmlns:y=\"http://bcd\" xmlns:z=\"http://cde\"><z:b></z:b></a>'),\n                          s)\n        s = etree.tostring(tree, method='c14n', exclusive=False)\n        self.assertEqual(_bytes('<a xmlns=\"http://abc\" xmlns:y=\"http://bcd\" xmlns:z=\"http://cde\"><z:b></z:b></a>'),\n                          s)\n        s = etree.tostring(tree, method='c14n', exclusive=True)\n        self.assertEqual(_bytes('<a xmlns=\"http://abc\"><z:b xmlns:z=\"http://cde\"></z:b></a>'),\n                          s)\n\n        s = etree.tostring(tree, method='c14n', exclusive=True, inclusive_ns_prefixes=['y'])\n        self.assertEqual(_bytes('<a xmlns=\"http://abc\" xmlns:y=\"http://bcd\"><z:b xmlns:z=\"http://cde\"></z:b></a>'),\n                          s)\n\n    def test_c14n_element_tostring_exclusive(self):\n        tree = self.parse(_bytes(\n                '<a xmlns=\"http://abc\" xmlns:y=\"http://bcd\" xmlns:z=\"http://cde\"><z:b/></a>'))\n        s = etree.tostring(tree.getroot(), method='c14n')\n        self.assertEqual(_bytes('<a xmlns=\"http://abc\" xmlns:y=\"http://bcd\" xmlns:z=\"http://cde\"><z:b></z:b></a>'),\n                          s)\n        s = etree.tostring(tree.getroot(), method='c14n', exclusive=False)\n        self.assertEqual(_bytes('<a xmlns=\"http://abc\" xmlns:y=\"http://bcd\" xmlns:z=\"http://cde\"><z:b></z:b></a>'),\n                          s)\n        s = etree.tostring(tree.getroot(), method='c14n', exclusive=True)\n        self.assertEqual(_bytes('<a xmlns=\"http://abc\"><z:b xmlns:z=\"http://cde\"></z:b></a>'),\n                          s)\n\n        s = etree.tostring(tree.getroot()[0], method='c14n', exclusive=False)\n        self.assertEqual(_bytes('<z:b xmlns=\"http://abc\" xmlns:y=\"http://bcd\" xmlns:z=\"http://cde\"></z:b>'),\n                          s)\n        s = etree.tostring(tree.getroot()[0], method='c14n', exclusive=True)\n        self.assertEqual(_bytes('<z:b xmlns:z=\"http://cde\"></z:b>'),\n                          s)\n\n        s = etree.tostring(tree.getroot()[0], method='c14n', exclusive=True, inclusive_ns_prefixes=['y'])\n        self.assertEqual(_bytes('<z:b xmlns:y=\"http://bcd\" xmlns:z=\"http://cde\"></z:b>'),\n                          s)\n\n    def test_c14n_tostring_inclusive_ns_prefixes(self):\n        \"\"\" Regression test to fix memory allocation issues (use 3+ inclusive NS spaces)\"\"\"\n        tree = self.parse(_bytes(\n                '<a xmlns:x=\"http://abc\" xmlns:y=\"http://bcd\" xmlns:z=\"http://cde\"><z:b/></a>'))\n\n        s = etree.tostring(tree, method='c14n', exclusive=True, inclusive_ns_prefixes=['x', 'y', 'z'])\n        self.assertEqual(_bytes('<a xmlns:x=\"http://abc\" xmlns:y=\"http://bcd\" xmlns:z=\"http://cde\"><z:b></z:b></a>'),\n                          s)\n    \n    def test_python3_problem_bytesio_iterparse(self):\n        content = BytesIO('''<?xml version=\"1.0\" encoding=\"utf-8\"?> <some_ns_id:some_head_elem xmlns:some_ns_id=\"http://www.example.com\" xmlns:xhtml=\"http://www.w3.org/1999/xhtml\"><xhtml:div></xhtml:div></some_ns_id:some_head_elem>'''.encode('utf-8'))\n        def handle_div_end(event, element):\n            if event == 'end' and element.tag.lower().startswith(\"{http://www.w3.org/1999/xhtml}div\"):\n                # for ns_id, ns_uri in element.nsmap.items():\n                #     print(type(ns_id), type(ns_uri), ns_id, '=', ns_uri)\n                etree.tostring(element, method=\"c14n2\")\n        for event, element in etree.iterparse(\n            source=content,\n            events=('start', 'end')\n        ):\n            handle_div_end(event, element)\n    \n    def test_python3_problem_filebased_iterparse(self):\n        with open('test.xml', 'w+b') as f:\n            f.write('''<?xml version=\"1.0\" encoding=\"utf-8\"?> <some_ns_id:some_head_elem xmlns:some_ns_id=\"http://www.example.com\" xmlns:xhtml=\"http://www.w3.org/1999/xhtml\"><xhtml:div></xhtml:div></some_ns_id:some_head_elem>'''.encode('utf-8'))\n        def handle_div_end(event, element):\n            if event == 'end' and element.tag.lower() == \"{http://www.w3.org/1999/xhtml}div\":\n                # for ns_id, ns_uri in element.nsmap.items():\n                #     print(type(ns_id), type(ns_uri), ns_id, '=', ns_uri)\n                etree.tostring(element, method=\"c14n2\")\n        for event, element in etree.iterparse(\n            source='test.xml',\n            events=('start', 'end')\n        ):\n            handle_div_end(event, element)\n    \n    def test_python3_problem_filebased_parse(self):\n        with open('test.xml', 'w+b') as f:\n            f.write('''<?xml version=\"1.0\" encoding=\"utf-8\"?> <some_ns_id:some_head_elem xmlns:some_ns_id=\"http://www.example.com\" xmlns:xhtml=\"http://www.w3.org/1999/xhtml\"><xhtml:div></xhtml:div></some_ns_id:some_head_elem>'''.encode('utf-8'))\n        def serialize_div_element(element):        \n            # for ns_id, ns_uri in element.nsmap.items():\n            #     print(type(ns_id), type(ns_uri), ns_id, '=', ns_uri)\n            etree.tostring(element, method=\"c14n2\")\n        tree = etree.parse(source='test.xml')\n        root = tree.getroot()\n        div = root.xpath('//xhtml:div', namespaces={'xhtml':'http://www.w3.org/1999/xhtml'})[0]\n        serialize_div_element(div)\n\n\nclass ETreeWriteTestCase(HelperTestCase):\n    def test_write(self):\n        tree = self.parse(_bytes('<a><b/></a>'))\n        f = BytesIO()\n        tree.write(f)\n        s = f.getvalue()\n        self.assertEqual(_bytes('<a><b/></a>'),\n                          s)\n\n    def test_write_doctype(self):\n        tree = self.parse(_bytes('<a><b/></a>'))\n        f = BytesIO()\n        tree.write(f, doctype='HUHU')\n        s = f.getvalue()\n        self.assertEqual(_bytes('HUHU\\n<a><b/></a>'),\n                          s)\n\n    def test_write_gzip(self):\n        tree = self.parse(_bytes('<a>'+'<b/>'*200+'</a>'))\n        f = BytesIO()\n        tree.write(f, compression=9)\n        with gzip.GzipFile(fileobj=BytesIO(f.getvalue())) as gzfile:\n            s = gzfile.read()\n        self.assertEqual(_bytes('<a>'+'<b/>'*200+'</a>'),\n                          s)\n\n    def test_write_gzip_doctype(self):\n        tree = self.parse(_bytes('<a>'+'<b/>'*200+'</a>'))\n        f = BytesIO()\n        tree.write(f, compression=9, doctype='<!DOCTYPE a>')\n        with gzip.GzipFile(fileobj=BytesIO(f.getvalue())) as gzfile:\n            s = gzfile.read()\n        self.assertEqual(_bytes('<!DOCTYPE a>\\n<a>'+'<b/>'*200+'</a>'),\n                          s)\n\n    def test_write_gzip_level(self):\n        tree = self.parse(_bytes('<a>'+'<b/>'*200+'</a>'))\n        f = BytesIO()\n        tree.write(f, compression=0)\n        s0 = f.getvalue()\n\n        f = BytesIO()\n        tree.write(f)\n        self.assertEqual(f.getvalue(), s0)\n\n        f = BytesIO()\n        tree.write(f, compression=1)\n        s = f.getvalue()\n        self.assertTrue(len(s) <= len(s0))\n        with gzip.GzipFile(fileobj=BytesIO(s)) as gzfile:\n            s1 = gzfile.read()\n\n        f = BytesIO()\n        tree.write(f, compression=9)\n        s = f.getvalue()\n        self.assertTrue(len(s) <= len(s0))\n        with gzip.GzipFile(fileobj=BytesIO(s)) as gzfile:\n            s9 = gzfile.read()\n\n        self.assertEqual(_bytes('<a>'+'<b/>'*200+'</a>'),\n                          s0)\n        self.assertEqual(_bytes('<a>'+'<b/>'*200+'</a>'),\n                          s1)\n        self.assertEqual(_bytes('<a>'+'<b/>'*200+'</a>'),\n                          s9)\n\n    def test_write_file(self):\n        tree = self.parse(_bytes('<a><b/></a>'))\n        with tmpfile() as filename:\n            tree.write(filename)\n            data = read_file(filename, 'rb')\n        self.assertEqual(_bytes('<a><b/></a>'),\n                          data)\n    \n    def test_write_file_pathlike(self):\n        tree = self.parse(_bytes('<a><b/></a>'))\n        with tmpfile() as filename:\n            tree.write(SimpleFSPath(filename))\n            data = read_file(filename, 'rb')\n        self.assertEqual(_bytes('<a><b/></a>'),\n                        data)\n\n    def test_write_file_gzip(self):\n        tree = self.parse(_bytes('<a>'+'<b/>'*200+'</a>'))\n        with tmpfile() as filename:\n            tree.write(filename, compression=9)\n            with gzip.open(filename, 'rb') as f:\n                data = f.read()\n        self.assertEqual(_bytes('<a>'+'<b/>'*200+'</a>'),\n                          data)\n\n    def test_write_file_gzip_pathlike(self):\n        tree = self.parse(_bytes('<a>'+'<b/>'*200+'</a>'))\n        with tmpfile() as filename:\n            tree.write(SimpleFSPath(filename), compression=9)\n            with gzip.open(filename, 'rb') as f:\n                data = f.read()\n        self.assertEqual(_bytes('<a>'+'<b/>'*200+'</a>'),\n                        data)\n\n    def test_write_file_gzip_parse(self):\n        tree = self.parse(_bytes('<a>'+'<b/>'*200+'</a>'))\n        with tmpfile() as filename:\n            tree.write(filename, compression=9)\n            data = etree.tostring(etree.parse(filename))\n        self.assertEqual(_bytes('<a>'+'<b/>'*200+'</a>'),\n                          data)\n\n    def test_write_file_gzipfile_parse(self):\n        tree = self.parse(_bytes('<a>'+'<b/>'*200+'</a>'))\n        with tmpfile() as filename:\n            tree.write(filename, compression=9)\n            with gzip.GzipFile(filename) as f:\n                data = etree.tostring(etree.parse(f))\n        self.assertEqual(_bytes('<a>'+'<b/>'*200+'</a>'),\n                          data)\n\n    def test_write_file_url(self):\n        xml = _bytes('<a>'+'<b/>'*200+'</a>')\n        tree = self.parse(xml)\n        with tmpfile(prefix=\"p+%20\", suffix=\".xml\") as filename:\n            url = 'file://' + (filename if sys.platform != 'win32'\n                               else '/' + filename.replace('\\\\', '/'))\n            tree.write(url)\n            data = read_file(filename, 'rb').replace(_bytes('\\n'), _bytes(''))\n        self.assertEqual(data, xml)\n\n\nclass ETreeErrorLogTest(HelperTestCase):\n    etree = etree\n\n    def test_parse_error_logging(self):\n        parse = self.etree.parse\n        f = BytesIO('<a><b></c></b></a>')\n        self.etree.clear_error_log()\n        try:\n            parse(f)\n            logs = None\n        except SyntaxError:\n            e = sys.exc_info()[1]\n            logs = e.error_log\n        f.close()\n        self.assertTrue([ log for log in logs\n                       if 'mismatch' in log.message ])\n        self.assertTrue([ log for log in logs\n                       if 'PARSER'   in log.domain_name])\n        self.assertTrue([ log for log in logs\n                       if 'ERR_TAG_NAME_MISMATCH' in log.type_name ])\n        self.assertTrue([ log for log in logs\n                       if 1 == log.line ])\n        self.assertTrue([ log for log in logs\n                       if 15 == log.column ])\n\n    def _test_python_error_logging(self):\n        \"\"\"This can't really be tested as long as there isn't a way to\n        reset the logging setup ...\n        \"\"\"\n        parse = self.etree.parse\n\n        messages = []\n        class Logger(self.etree.PyErrorLog):\n            def log(self, entry, message, *args):\n                messages.append(message)\n\n        self.etree.use_global_python_log(Logger())\n        f = BytesIO('<a><b></c></b></a>')\n        try:\n            parse(f)\n        except SyntaxError:\n            pass\n        f.close()\n\n        self.assertTrue([ message for message in messages\n                       if 'mismatch' in message ])\n        self.assertTrue([ message for message in messages\n                       if ':PARSER:'   in message])\n        self.assertTrue([ message for message in messages\n                       if ':ERR_TAG_NAME_MISMATCH:' in message ])\n        self.assertTrue([ message for message in messages\n                       if ':1:15:' in message ])\n\n\nclass XMLPullParserTest(unittest.TestCase):\n    etree = etree\n\n    def assert_event_tags(self, events, expected):\n        self.assertEqual([(action, elem.tag) for action, elem in events],\n                         expected)\n\n    def test_pull_from_simple_target(self):\n        class Target(object):\n            def start(self, tag, attrib):\n                return 'start(%s)' % tag\n            def end(self, tag):\n                return 'end(%s)' % tag\n            def close(self):\n                return 'close()'\n\n        parser = self.etree.XMLPullParser(target=Target())\n        events = parser.read_events()\n\n        parser.feed('<root><element>')\n        self.assertFalse(list(events))\n        self.assertFalse(list(events))\n        parser.feed('</element><child>')\n        self.assertEqual([('end', 'end(element)')], list(events))\n        parser.feed('</child>')\n        self.assertEqual([('end', 'end(child)')], list(events))\n        parser.feed('</root>')\n        self.assertEqual([('end', 'end(root)')], list(events))\n        self.assertFalse(list(events))\n        self.assertEqual('close()', parser.close())\n\n    def test_pull_from_simple_target_start_end(self):\n        class Target(object):\n            def start(self, tag, attrib):\n                return 'start(%s)' % tag\n            def end(self, tag):\n                return 'end(%s)' % tag\n            def close(self):\n                return 'close()'\n\n        parser = self.etree.XMLPullParser(\n            ['start', 'end'], target=Target())\n        events = parser.read_events()\n\n        parser.feed('<root><element>')\n        self.assertEqual(\n            [('start', 'start(root)'), ('start', 'start(element)')],\n            list(events))\n        self.assertFalse(list(events))\n        parser.feed('</element><child>')\n        self.assertEqual(\n            [('end', 'end(element)'), ('start', 'start(child)')],\n            list(events))\n        parser.feed('</child>')\n        self.assertEqual(\n            [('end', 'end(child)')],\n            list(events))\n        parser.feed('</root>')\n        self.assertEqual(\n            [('end', 'end(root)')],\n            list(events))\n        self.assertFalse(list(events))\n        self.assertEqual('close()', parser.close())\n\n    def test_pull_from_tree_builder(self):\n        parser = self.etree.XMLPullParser(\n            ['start', 'end'], target=etree.TreeBuilder())\n        events = parser.read_events()\n\n        parser.feed('<root><element>')\n        self.assert_event_tags(\n            events, [('start', 'root'), ('start', 'element')])\n        self.assertFalse(list(events))\n        parser.feed('</element><child>')\n        self.assert_event_tags(\n            events, [('end', 'element'), ('start', 'child')])\n        parser.feed('</child>')\n        self.assert_event_tags(\n            events, [('end', 'child')])\n        parser.feed('</root>')\n        self.assert_event_tags(\n            events, [('end', 'root')])\n        self.assertFalse(list(events))\n        root = parser.close()\n        self.assertEqual('root', root.tag)\n\n    def test_pull_from_tree_builder_subclass(self):\n        class Target(etree.TreeBuilder):\n            def end(self, tag):\n                el = super(Target, self).end(tag)\n                el.tag += '-huhu'\n                return el\n\n        parser = self.etree.XMLPullParser(\n            ['start', 'end'], target=Target())\n        events = parser.read_events()\n\n        parser.feed('<root><element>')\n        self.assert_event_tags(\n            events, [('start', 'root'), ('start', 'element')])\n        self.assertFalse(list(events))\n        parser.feed('</element><child>')\n        self.assert_event_tags(\n            events, [('end', 'element-huhu'), ('start', 'child')])\n        parser.feed('</child>')\n        self.assert_event_tags(\n            events, [('end', 'child-huhu')])\n        parser.feed('</root>')\n        self.assert_event_tags(\n            events, [('end', 'root-huhu')])\n        self.assertFalse(list(events))\n        root = parser.close()\n        self.assertEqual('root-huhu', root.tag)\n\n\ndef test_suite():\n    suite = unittest.TestSuite()\n    suite.addTests([unittest.makeSuite(ETreeOnlyTestCase)])\n    suite.addTests([unittest.makeSuite(ETreeXIncludeTestCase)])\n    suite.addTests([unittest.makeSuite(ElementIncludeTestCase)])\n    suite.addTests([unittest.makeSuite(ETreeC14NTestCase)])\n    suite.addTests([unittest.makeSuite(ETreeWriteTestCase)])\n    suite.addTests([unittest.makeSuite(ETreeErrorLogTest)])\n    suite.addTests([unittest.makeSuite(XMLPullParserTest)])\n\n    # add original doctests from ElementTree selftest modules\n    from . import selftest, selftest2\n    suite.addTests(doctest.DocTestSuite(selftest))\n    suite.addTests(doctest.DocTestSuite(selftest2))\n\n    # add doctests\n    suite.addTests(doctest.DocTestSuite(etree))\n    suite.addTests(\n        [make_doctest('../../../doc/tutorial.txt')])\n    suite.addTests(\n        [make_doctest('../../../doc/api.txt')])\n    suite.addTests(\n        [make_doctest('../../../doc/FAQ.txt')])\n    suite.addTests(\n        [make_doctest('../../../doc/parsing.txt')])\n    suite.addTests(\n        [make_doctest('../../../doc/resolvers.txt')])\n    return suite\n\n\nif __name__ == '__main__':\n    print('to test use test.py %s' % __file__)\n"], "filenames": ["src/lxml/apihelpers.pxi", "src/lxml/iterparse.pxi", "src/lxml/tests/test_etree.py"], "buggy_code_start_loc": [249, 423, 1461], "buggy_code_end_loc": [252, 438, 1461], "fixing_code_start_loc": [249, 423, 1462], "fixing_code_end_loc": [253, 439, 1482], "type": "CWE-476", "message": "NULL Pointer Dereference allows attackers to cause a denial of service (or application crash). This only applies when lxml is used together with libxml2 2.9.10 through 2.9.14. libxml2 2.9.9 and earlier are not affected. It allows triggering crashes through forged input data, given a vulnerable code sequence in the application. The vulnerability is caused by the iterwalk function (also used by the canonicalize function). Such code shouldn't be in wide-spread use, given that parsing + iterwalk would usually be replaced with the more efficient iterparse function. However, an XML converter that serialises to C14N would also be vulnerable, for example, and there are legitimate use cases for this code sequence. If untrusted input is received (also remotely) and processed via iterwalk function, a crash can be triggered.", "other": {"cve": {"id": "CVE-2022-2309", "sourceIdentifier": "security@huntr.dev", "published": "2022-07-05T10:15:08.763", "lastModified": "2022-10-28T18:55:01.567", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "NULL Pointer Dereference allows attackers to cause a denial of service (or application crash). This only applies when lxml is used together with libxml2 2.9.10 through 2.9.14. libxml2 2.9.9 and earlier are not affected. It allows triggering crashes through forged input data, given a vulnerable code sequence in the application. The vulnerability is caused by the iterwalk function (also used by the canonicalize function). Such code shouldn't be in wide-spread use, given that parsing + iterwalk would usually be replaced with the more efficient iterparse function. However, an XML converter that serialises to C14N would also be vulnerable, for example, and there are legitimate use cases for this code sequence. If untrusted input is received (also remotely) and processed via iterwalk function, a crash can be triggered."}, {"lang": "es", "value": "Una desreferencia de puntero NULL permite a atacantes causar una denegaci\u00f3n de servicio (o bloqueo de la aplicaci\u00f3n).&#xa0;Esto solo se aplica cuando lxml se usa junto con libxml2 versiones 2.9.10 hasta 2.9.14.&#xa0;libxml2 versiones 2.9.9 y anteriores no est\u00e1n afectados.&#xa0;Permite desencadenar bloqueos por medio de datos de entrada falsificados, dada una secuencia de c\u00f3digo vulnerable en la aplicaci\u00f3n.&#xa0;La vulnerabilidad es causada por la funci\u00f3n iterwalk (tambi\u00e9n utilizada por la funci\u00f3n canonicalize).&#xa0;Dicho c\u00f3digo no deber\u00eda tener un uso generalizado, dado que parsing + iterwalk generalmente se reemplazar\u00eda con la funci\u00f3n iterparse m\u00e1s eficiente.&#xa0;Sin embargo, un convertidor XML que serializa a C14N tambi\u00e9n ser\u00eda vulnerable, por ejemplo, y existen casos de uso leg\u00edtimos para esta secuencia de c\u00f3digo.&#xa0;Si se recibe una entrada que no es de confianza (tambi\u00e9n de forma remota) y se procesa por medio de la funci\u00f3n iterwalk, se puede desencadenar un bloqueo"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:lxml:lxml:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.9.1", "matchCriteriaId": "738BCE63-2B47-4CFA-9915-C3DE1A3AA9A9"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:a:xmlsoft:libxml2:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.9.10", "versionEndIncluding": "2.9.14", "matchCriteriaId": "E1774300-F6CA-43CA-A6FD-6A302814FB5D"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:37:*:*:*:*:*:*:*", "matchCriteriaId": "E30D0E6F-4AE8-4284-8716-991DFA48CC5D"}]}]}], "references": [{"url": "https://github.com/lxml/lxml/commit/86368e9cf70a0ad23cccd5ee32de847149af0c6f", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/8264e74f-edda-4c40-9956-49de635105ba", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/HGYC6L7ENH5VEGN3YWFBYMGKX6WNS7HZ/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/URHHSIBTPTALXMECRLAC2EVDNAFSR5NO/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202208-06", "source": "security@huntr.dev", "tags": ["Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20220915-0006/", "source": "security@huntr.dev", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/lxml/lxml/commit/86368e9cf70a0ad23cccd5ee32de847149af0c6f"}}