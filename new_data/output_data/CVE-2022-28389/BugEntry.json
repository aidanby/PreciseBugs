{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0-only\n/* SocketCAN driver for Microchip CAN BUS Analyzer Tool\n *\n * Copyright (C) 2017 Mobica Limited\n *\n * This driver is inspired by the 4.6.2 version of net/can/usb/usb_8dev.c\n */\n\n#include <asm/unaligned.h>\n#include <linux/can.h>\n#include <linux/can/dev.h>\n#include <linux/can/error.h>\n#include <linux/can/led.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/signal.h>\n#include <linux/slab.h>\n#include <linux/usb.h>\n\n/* vendor and product id */\n#define MCBA_MODULE_NAME \"mcba_usb\"\n#define MCBA_VENDOR_ID 0x04d8\n#define MCBA_PRODUCT_ID 0x0a30\n\n/* driver constants */\n#define MCBA_MAX_RX_URBS 20\n#define MCBA_MAX_TX_URBS 20\n#define MCBA_CTX_FREE MCBA_MAX_TX_URBS\n\n/* RX buffer must be bigger than msg size since at the\n * beginning USB messages are stacked.\n */\n#define MCBA_USB_RX_BUFF_SIZE 64\n#define MCBA_USB_TX_BUFF_SIZE (sizeof(struct mcba_usb_msg))\n\n/* MCBA endpoint numbers */\n#define MCBA_USB_EP_IN 1\n#define MCBA_USB_EP_OUT 1\n\n/* Microchip command id */\n#define MBCA_CMD_RECEIVE_MESSAGE 0xE3\n#define MBCA_CMD_I_AM_ALIVE_FROM_CAN 0xF5\n#define MBCA_CMD_I_AM_ALIVE_FROM_USB 0xF7\n#define MBCA_CMD_CHANGE_BIT_RATE 0xA1\n#define MBCA_CMD_TRANSMIT_MESSAGE_EV 0xA3\n#define MBCA_CMD_SETUP_TERMINATION_RESISTANCE 0xA8\n#define MBCA_CMD_READ_FW_VERSION 0xA9\n#define MBCA_CMD_NOTHING_TO_SEND 0xFF\n#define MBCA_CMD_TRANSMIT_MESSAGE_RSP 0xE2\n\n#define MCBA_VER_REQ_USB 1\n#define MCBA_VER_REQ_CAN 2\n\n#define MCBA_SIDL_EXID_MASK 0x8\n#define MCBA_DLC_MASK 0xf\n#define MCBA_DLC_RTR_MASK 0x40\n\n#define MCBA_CAN_STATE_WRN_TH 95\n#define MCBA_CAN_STATE_ERR_PSV_TH 127\n\n#define MCBA_TERMINATION_DISABLED CAN_TERMINATION_DISABLED\n#define MCBA_TERMINATION_ENABLED 120\n\nstruct mcba_usb_ctx {\n\tstruct mcba_priv *priv;\n\tu32 ndx;\n\tbool can;\n};\n\n/* Structure to hold all of our device specific stuff */\nstruct mcba_priv {\n\tstruct can_priv can; /* must be the first member */\n\tstruct sk_buff *echo_skb[MCBA_MAX_TX_URBS];\n\tstruct mcba_usb_ctx tx_context[MCBA_MAX_TX_URBS];\n\tstruct usb_device *udev;\n\tstruct net_device *netdev;\n\tstruct usb_anchor tx_submitted;\n\tstruct usb_anchor rx_submitted;\n\tstruct can_berr_counter bec;\n\tbool usb_ka_first_pass;\n\tbool can_ka_first_pass;\n\tbool can_speed_check;\n\tatomic_t free_ctx_cnt;\n\tvoid *rxbuf[MCBA_MAX_RX_URBS];\n\tdma_addr_t rxbuf_dma[MCBA_MAX_RX_URBS];\n};\n\n/* CAN frame */\nstruct __packed mcba_usb_msg_can {\n\tu8 cmd_id;\n\t__be16 eid;\n\t__be16 sid;\n\tu8 dlc;\n\tu8 data[8];\n\tu8 timestamp[4];\n\tu8 checksum;\n};\n\n/* command frame */\nstruct __packed mcba_usb_msg {\n\tu8 cmd_id;\n\tu8 unused[18];\n};\n\nstruct __packed mcba_usb_msg_ka_usb {\n\tu8 cmd_id;\n\tu8 termination_state;\n\tu8 soft_ver_major;\n\tu8 soft_ver_minor;\n\tu8 unused[15];\n};\n\nstruct __packed mcba_usb_msg_ka_can {\n\tu8 cmd_id;\n\tu8 tx_err_cnt;\n\tu8 rx_err_cnt;\n\tu8 rx_buff_ovfl;\n\tu8 tx_bus_off;\n\t__be16 can_bitrate;\n\t__le16 rx_lost;\n\tu8 can_stat;\n\tu8 soft_ver_major;\n\tu8 soft_ver_minor;\n\tu8 debug_mode;\n\tu8 test_complete;\n\tu8 test_result;\n\tu8 unused[4];\n};\n\nstruct __packed mcba_usb_msg_change_bitrate {\n\tu8 cmd_id;\n\t__be16 bitrate;\n\tu8 unused[16];\n};\n\nstruct __packed mcba_usb_msg_termination {\n\tu8 cmd_id;\n\tu8 termination;\n\tu8 unused[17];\n};\n\nstruct __packed mcba_usb_msg_fw_ver {\n\tu8 cmd_id;\n\tu8 pic;\n\tu8 unused[17];\n};\n\nstatic const struct usb_device_id mcba_usb_table[] = {\n\t{ USB_DEVICE(MCBA_VENDOR_ID, MCBA_PRODUCT_ID) },\n\t{} /* Terminating entry */\n};\n\nMODULE_DEVICE_TABLE(usb, mcba_usb_table);\n\nstatic const u16 mcba_termination[] = { MCBA_TERMINATION_DISABLED,\n\t\t\t\t\tMCBA_TERMINATION_ENABLED };\n\nstatic const u32 mcba_bitrate[] = { 20000,  33333,  50000,  80000,  83333,\n\t\t\t\t    100000, 125000, 150000, 175000, 200000,\n\t\t\t\t    225000, 250000, 275000, 300000, 500000,\n\t\t\t\t    625000, 800000, 1000000 };\n\nstatic inline void mcba_init_ctx(struct mcba_priv *priv)\n{\n\tint i = 0;\n\n\tfor (i = 0; i < MCBA_MAX_TX_URBS; i++) {\n\t\tpriv->tx_context[i].ndx = MCBA_CTX_FREE;\n\t\tpriv->tx_context[i].priv = priv;\n\t}\n\n\tatomic_set(&priv->free_ctx_cnt, ARRAY_SIZE(priv->tx_context));\n}\n\nstatic inline struct mcba_usb_ctx *mcba_usb_get_free_ctx(struct mcba_priv *priv,\n\t\t\t\t\t\t\t struct can_frame *cf)\n{\n\tint i = 0;\n\tstruct mcba_usb_ctx *ctx = NULL;\n\n\tfor (i = 0; i < MCBA_MAX_TX_URBS; i++) {\n\t\tif (priv->tx_context[i].ndx == MCBA_CTX_FREE) {\n\t\t\tctx = &priv->tx_context[i];\n\t\t\tctx->ndx = i;\n\n\t\t\tif (cf)\n\t\t\t\tctx->can = true;\n\t\t\telse\n\t\t\t\tctx->can = false;\n\n\t\t\tatomic_dec(&priv->free_ctx_cnt);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!atomic_read(&priv->free_ctx_cnt))\n\t\t/* That was the last free ctx. Slow down tx path */\n\t\tnetif_stop_queue(priv->netdev);\n\n\treturn ctx;\n}\n\n/* mcba_usb_free_ctx and mcba_usb_get_free_ctx are executed by different\n * threads. The order of execution in below function is important.\n */\nstatic inline void mcba_usb_free_ctx(struct mcba_usb_ctx *ctx)\n{\n\t/* Increase number of free ctxs before freeing ctx */\n\tatomic_inc(&ctx->priv->free_ctx_cnt);\n\n\tctx->ndx = MCBA_CTX_FREE;\n\n\t/* Wake up the queue once ctx is marked free */\n\tnetif_wake_queue(ctx->priv->netdev);\n}\n\nstatic void mcba_usb_write_bulk_callback(struct urb *urb)\n{\n\tstruct mcba_usb_ctx *ctx = urb->context;\n\tstruct net_device *netdev;\n\n\tWARN_ON(!ctx);\n\n\tnetdev = ctx->priv->netdev;\n\n\t/* free up our allocated buffer */\n\tusb_free_coherent(urb->dev, urb->transfer_buffer_length,\n\t\t\t  urb->transfer_buffer, urb->transfer_dma);\n\n\tif (ctx->can) {\n\t\tif (!netif_device_present(netdev))\n\t\t\treturn;\n\n\t\tnetdev->stats.tx_packets++;\n\t\tnetdev->stats.tx_bytes += can_get_echo_skb(netdev, ctx->ndx,\n\t\t\t\t\t\t\t   NULL);\n\n\t\tcan_led_event(netdev, CAN_LED_EVENT_TX);\n\t}\n\n\tif (urb->status)\n\t\tnetdev_info(netdev, \"Tx URB aborted (%d)\\n\", urb->status);\n\n\t/* Release the context */\n\tmcba_usb_free_ctx(ctx);\n}\n\n/* Send data to device */\nstatic netdev_tx_t mcba_usb_xmit(struct mcba_priv *priv,\n\t\t\t\t struct mcba_usb_msg *usb_msg,\n\t\t\t\t struct mcba_usb_ctx *ctx)\n{\n\tstruct urb *urb;\n\tu8 *buf;\n\tint err;\n\n\t/* create a URB, and a buffer for it, and copy the data to the URB */\n\turb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (!urb)\n\t\treturn -ENOMEM;\n\n\tbuf = usb_alloc_coherent(priv->udev, MCBA_USB_TX_BUFF_SIZE, GFP_ATOMIC,\n\t\t\t\t &urb->transfer_dma);\n\tif (!buf) {\n\t\terr = -ENOMEM;\n\t\tgoto nomembuf;\n\t}\n\n\tmemcpy(buf, usb_msg, MCBA_USB_TX_BUFF_SIZE);\n\n\tusb_fill_bulk_urb(urb, priv->udev,\n\t\t\t  usb_sndbulkpipe(priv->udev, MCBA_USB_EP_OUT), buf,\n\t\t\t  MCBA_USB_TX_BUFF_SIZE, mcba_usb_write_bulk_callback,\n\t\t\t  ctx);\n\n\turb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\tusb_anchor_urb(urb, &priv->tx_submitted);\n\n\terr = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (unlikely(err))\n\t\tgoto failed;\n\n\t/* Release our reference to this URB, the USB core will eventually free\n\t * it entirely.\n\t */\n\tusb_free_urb(urb);\n\n\treturn 0;\n\nfailed:\n\tusb_unanchor_urb(urb);\n\tusb_free_coherent(priv->udev, MCBA_USB_TX_BUFF_SIZE, buf,\n\t\t\t  urb->transfer_dma);\n\n\tif (err == -ENODEV)\n\t\tnetif_device_detach(priv->netdev);\n\telse\n\t\tnetdev_warn(priv->netdev, \"failed tx_urb %d\\n\", err);\n\nnomembuf:\n\tusb_free_urb(urb);\n\n\treturn err;\n}\n\n/* Send data to device */\nstatic netdev_tx_t mcba_usb_start_xmit(struct sk_buff *skb,\n\t\t\t\t       struct net_device *netdev)\n{\n\tstruct mcba_priv *priv = netdev_priv(netdev);\n\tstruct can_frame *cf = (struct can_frame *)skb->data;\n\tstruct mcba_usb_ctx *ctx = NULL;\n\tstruct net_device_stats *stats = &priv->netdev->stats;\n\tu16 sid;\n\tint err;\n\tstruct mcba_usb_msg_can usb_msg = {\n\t\t.cmd_id = MBCA_CMD_TRANSMIT_MESSAGE_EV\n\t};\n\n\tif (can_dropped_invalid_skb(netdev, skb))\n\t\treturn NETDEV_TX_OK;\n\n\tctx = mcba_usb_get_free_ctx(priv, cf);\n\tif (!ctx)\n\t\treturn NETDEV_TX_BUSY;\n\n\tif (cf->can_id & CAN_EFF_FLAG) {\n\t\t/* SIDH    | SIDL                 | EIDH   | EIDL\n\t\t * 28 - 21 | 20 19 18 x x x 17 16 | 15 - 8 | 7 - 0\n\t\t */\n\t\tsid = MCBA_SIDL_EXID_MASK;\n\t\t/* store 28-18 bits */\n\t\tsid |= (cf->can_id & 0x1ffc0000) >> 13;\n\t\t/* store 17-16 bits */\n\t\tsid |= (cf->can_id & 0x30000) >> 16;\n\t\tput_unaligned_be16(sid, &usb_msg.sid);\n\n\t\t/* store 15-0 bits */\n\t\tput_unaligned_be16(cf->can_id & 0xffff, &usb_msg.eid);\n\t} else {\n\t\t/* SIDH   | SIDL\n\t\t * 10 - 3 | 2 1 0 x x x x x\n\t\t */\n\t\tput_unaligned_be16((cf->can_id & CAN_SFF_MASK) << 5,\n\t\t\t\t   &usb_msg.sid);\n\t\tusb_msg.eid = 0;\n\t}\n\n\tusb_msg.dlc = cf->len;\n\n\tmemcpy(usb_msg.data, cf->data, usb_msg.dlc);\n\n\tif (cf->can_id & CAN_RTR_FLAG)\n\t\tusb_msg.dlc |= MCBA_DLC_RTR_MASK;\n\n\tcan_put_echo_skb(skb, priv->netdev, ctx->ndx, 0);\n\n\terr = mcba_usb_xmit(priv, (struct mcba_usb_msg *)&usb_msg, ctx);\n\tif (err)\n\t\tgoto xmit_failed;\n\n\treturn NETDEV_TX_OK;\n\nxmit_failed:\n\tcan_free_echo_skb(priv->netdev, ctx->ndx, NULL);\n\tmcba_usb_free_ctx(ctx);\n\tdev_kfree_skb(skb);\n\tstats->tx_dropped++;\n\n\treturn NETDEV_TX_OK;\n}\n\n/* Send cmd to device */\nstatic void mcba_usb_xmit_cmd(struct mcba_priv *priv,\n\t\t\t      struct mcba_usb_msg *usb_msg)\n{\n\tstruct mcba_usb_ctx *ctx = NULL;\n\tint err;\n\n\tctx = mcba_usb_get_free_ctx(priv, NULL);\n\tif (!ctx) {\n\t\tnetdev_err(priv->netdev,\n\t\t\t   \"Lack of free ctx. Sending (%d) cmd aborted\",\n\t\t\t   usb_msg->cmd_id);\n\n\t\treturn;\n\t}\n\n\terr = mcba_usb_xmit(priv, usb_msg, ctx);\n\tif (err)\n\t\tnetdev_err(priv->netdev, \"Failed to send cmd (%d)\",\n\t\t\t   usb_msg->cmd_id);\n}\n\nstatic void mcba_usb_xmit_change_bitrate(struct mcba_priv *priv, u16 bitrate)\n{\n\tstruct mcba_usb_msg_change_bitrate usb_msg = {\n\t\t.cmd_id = MBCA_CMD_CHANGE_BIT_RATE\n\t};\n\n\tput_unaligned_be16(bitrate, &usb_msg.bitrate);\n\n\tmcba_usb_xmit_cmd(priv, (struct mcba_usb_msg *)&usb_msg);\n}\n\nstatic void mcba_usb_xmit_read_fw_ver(struct mcba_priv *priv, u8 pic)\n{\n\tstruct mcba_usb_msg_fw_ver usb_msg = {\n\t\t.cmd_id = MBCA_CMD_READ_FW_VERSION,\n\t\t.pic = pic\n\t};\n\n\tmcba_usb_xmit_cmd(priv, (struct mcba_usb_msg *)&usb_msg);\n}\n\nstatic void mcba_usb_process_can(struct mcba_priv *priv,\n\t\t\t\t struct mcba_usb_msg_can *msg)\n{\n\tstruct can_frame *cf;\n\tstruct sk_buff *skb;\n\tstruct net_device_stats *stats = &priv->netdev->stats;\n\tu16 sid;\n\n\tskb = alloc_can_skb(priv->netdev, &cf);\n\tif (!skb)\n\t\treturn;\n\n\tsid = get_unaligned_be16(&msg->sid);\n\n\tif (sid & MCBA_SIDL_EXID_MASK) {\n\t\t/* SIDH    | SIDL                 | EIDH   | EIDL\n\t\t * 28 - 21 | 20 19 18 x x x 17 16 | 15 - 8 | 7 - 0\n\t\t */\n\t\tcf->can_id = CAN_EFF_FLAG;\n\n\t\t/* store 28-18 bits */\n\t\tcf->can_id |= (sid & 0xffe0) << 13;\n\t\t/* store 17-16 bits */\n\t\tcf->can_id |= (sid & 3) << 16;\n\t\t/* store 15-0 bits */\n\t\tcf->can_id |= get_unaligned_be16(&msg->eid);\n\t} else {\n\t\t/* SIDH   | SIDL\n\t\t * 10 - 3 | 2 1 0 x x x x x\n\t\t */\n\t\tcf->can_id = (sid & 0xffe0) >> 5;\n\t}\n\n\tcf->len = can_cc_dlc2len(msg->dlc & MCBA_DLC_MASK);\n\n\tif (msg->dlc & MCBA_DLC_RTR_MASK) {\n\t\tcf->can_id |= CAN_RTR_FLAG;\n\t} else {\n\t\tmemcpy(cf->data, msg->data, cf->len);\n\n\t\tstats->rx_bytes += cf->len;\n\t}\n\tstats->rx_packets++;\n\n\tcan_led_event(priv->netdev, CAN_LED_EVENT_RX);\n\tnetif_rx(skb);\n}\n\nstatic void mcba_usb_process_ka_usb(struct mcba_priv *priv,\n\t\t\t\t    struct mcba_usb_msg_ka_usb *msg)\n{\n\tif (unlikely(priv->usb_ka_first_pass)) {\n\t\tnetdev_info(priv->netdev, \"PIC USB version %u.%u\\n\",\n\t\t\t    msg->soft_ver_major, msg->soft_ver_minor);\n\n\t\tpriv->usb_ka_first_pass = false;\n\t}\n\n\tif (msg->termination_state)\n\t\tpriv->can.termination = MCBA_TERMINATION_ENABLED;\n\telse\n\t\tpriv->can.termination = MCBA_TERMINATION_DISABLED;\n}\n\nstatic u32 convert_can2host_bitrate(struct mcba_usb_msg_ka_can *msg)\n{\n\tconst u32 bitrate = get_unaligned_be16(&msg->can_bitrate);\n\n\tif ((bitrate == 33) || (bitrate == 83))\n\t\treturn bitrate * 1000 + 333;\n\telse\n\t\treturn bitrate * 1000;\n}\n\nstatic void mcba_usb_process_ka_can(struct mcba_priv *priv,\n\t\t\t\t    struct mcba_usb_msg_ka_can *msg)\n{\n\tif (unlikely(priv->can_ka_first_pass)) {\n\t\tnetdev_info(priv->netdev, \"PIC CAN version %u.%u\\n\",\n\t\t\t    msg->soft_ver_major, msg->soft_ver_minor);\n\n\t\tpriv->can_ka_first_pass = false;\n\t}\n\n\tif (unlikely(priv->can_speed_check)) {\n\t\tconst u32 bitrate = convert_can2host_bitrate(msg);\n\n\t\tpriv->can_speed_check = false;\n\n\t\tif (bitrate != priv->can.bittiming.bitrate)\n\t\t\tnetdev_err(\n\t\t\t    priv->netdev,\n\t\t\t    \"Wrong bitrate reported by the device (%u). Expected %u\",\n\t\t\t    bitrate, priv->can.bittiming.bitrate);\n\t}\n\n\tpriv->bec.txerr = msg->tx_err_cnt;\n\tpriv->bec.rxerr = msg->rx_err_cnt;\n\n\tif (msg->tx_bus_off)\n\t\tpriv->can.state = CAN_STATE_BUS_OFF;\n\n\telse if ((priv->bec.txerr > MCBA_CAN_STATE_ERR_PSV_TH) ||\n\t\t (priv->bec.rxerr > MCBA_CAN_STATE_ERR_PSV_TH))\n\t\tpriv->can.state = CAN_STATE_ERROR_PASSIVE;\n\n\telse if ((priv->bec.txerr > MCBA_CAN_STATE_WRN_TH) ||\n\t\t (priv->bec.rxerr > MCBA_CAN_STATE_WRN_TH))\n\t\tpriv->can.state = CAN_STATE_ERROR_WARNING;\n}\n\nstatic void mcba_usb_process_rx(struct mcba_priv *priv,\n\t\t\t\tstruct mcba_usb_msg *msg)\n{\n\tswitch (msg->cmd_id) {\n\tcase MBCA_CMD_I_AM_ALIVE_FROM_CAN:\n\t\tmcba_usb_process_ka_can(priv,\n\t\t\t\t\t(struct mcba_usb_msg_ka_can *)msg);\n\t\tbreak;\n\n\tcase MBCA_CMD_I_AM_ALIVE_FROM_USB:\n\t\tmcba_usb_process_ka_usb(priv,\n\t\t\t\t\t(struct mcba_usb_msg_ka_usb *)msg);\n\t\tbreak;\n\n\tcase MBCA_CMD_RECEIVE_MESSAGE:\n\t\tmcba_usb_process_can(priv, (struct mcba_usb_msg_can *)msg);\n\t\tbreak;\n\n\tcase MBCA_CMD_NOTHING_TO_SEND:\n\t\t/* Side effect of communication between PIC_USB and PIC_CAN.\n\t\t * PIC_CAN is telling us that it has nothing to send\n\t\t */\n\t\tbreak;\n\n\tcase MBCA_CMD_TRANSMIT_MESSAGE_RSP:\n\t\t/* Transmission response from the device containing timestamp */\n\t\tbreak;\n\n\tdefault:\n\t\tnetdev_warn(priv->netdev, \"Unsupported msg (0x%X)\",\n\t\t\t    msg->cmd_id);\n\t\tbreak;\n\t}\n}\n\n/* Callback for reading data from device\n *\n * Check urb status, call read function and resubmit urb read operation.\n */\nstatic void mcba_usb_read_bulk_callback(struct urb *urb)\n{\n\tstruct mcba_priv *priv = urb->context;\n\tstruct net_device *netdev;\n\tint retval;\n\tint pos = 0;\n\n\tnetdev = priv->netdev;\n\n\tif (!netif_device_present(netdev))\n\t\treturn;\n\n\tswitch (urb->status) {\n\tcase 0: /* success */\n\t\tbreak;\n\n\tcase -ENOENT:\n\tcase -EPIPE:\n\tcase -EPROTO:\n\tcase -ESHUTDOWN:\n\t\treturn;\n\n\tdefault:\n\t\tnetdev_info(netdev, \"Rx URB aborted (%d)\\n\", urb->status);\n\n\t\tgoto resubmit_urb;\n\t}\n\n\twhile (pos < urb->actual_length) {\n\t\tstruct mcba_usb_msg *msg;\n\n\t\tif (pos + sizeof(struct mcba_usb_msg) > urb->actual_length) {\n\t\t\tnetdev_err(priv->netdev, \"format error\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tmsg = (struct mcba_usb_msg *)(urb->transfer_buffer + pos);\n\t\tmcba_usb_process_rx(priv, msg);\n\n\t\tpos += sizeof(struct mcba_usb_msg);\n\t}\n\nresubmit_urb:\n\n\tusb_fill_bulk_urb(urb, priv->udev,\n\t\t\t  usb_rcvbulkpipe(priv->udev, MCBA_USB_EP_OUT),\n\t\t\t  urb->transfer_buffer, MCBA_USB_RX_BUFF_SIZE,\n\t\t\t  mcba_usb_read_bulk_callback, priv);\n\n\tretval = usb_submit_urb(urb, GFP_ATOMIC);\n\n\tif (retval == -ENODEV)\n\t\tnetif_device_detach(netdev);\n\telse if (retval)\n\t\tnetdev_err(netdev, \"failed resubmitting read bulk urb: %d\\n\",\n\t\t\t   retval);\n}\n\n/* Start USB device */\nstatic int mcba_usb_start(struct mcba_priv *priv)\n{\n\tstruct net_device *netdev = priv->netdev;\n\tint err, i;\n\n\tmcba_init_ctx(priv);\n\n\tfor (i = 0; i < MCBA_MAX_RX_URBS; i++) {\n\t\tstruct urb *urb = NULL;\n\t\tu8 *buf;\n\t\tdma_addr_t buf_dma;\n\n\t\t/* create a URB, and a buffer for it */\n\t\turb = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!urb) {\n\t\t\terr = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tbuf = usb_alloc_coherent(priv->udev, MCBA_USB_RX_BUFF_SIZE,\n\t\t\t\t\t GFP_KERNEL, &buf_dma);\n\t\tif (!buf) {\n\t\t\tnetdev_err(netdev, \"No memory left for USB buffer\\n\");\n\t\t\tusb_free_urb(urb);\n\t\t\terr = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\turb->transfer_dma = buf_dma;\n\n\t\tusb_fill_bulk_urb(urb, priv->udev,\n\t\t\t\t  usb_rcvbulkpipe(priv->udev, MCBA_USB_EP_IN),\n\t\t\t\t  buf, MCBA_USB_RX_BUFF_SIZE,\n\t\t\t\t  mcba_usb_read_bulk_callback, priv);\n\t\turb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\t\tusb_anchor_urb(urb, &priv->rx_submitted);\n\n\t\terr = usb_submit_urb(urb, GFP_KERNEL);\n\t\tif (err) {\n\t\t\tusb_unanchor_urb(urb);\n\t\t\tusb_free_coherent(priv->udev, MCBA_USB_RX_BUFF_SIZE,\n\t\t\t\t\t  buf, buf_dma);\n\t\t\tusb_free_urb(urb);\n\t\t\tbreak;\n\t\t}\n\n\t\tpriv->rxbuf[i] = buf;\n\t\tpriv->rxbuf_dma[i] = buf_dma;\n\n\t\t/* Drop reference, USB core will take care of freeing it */\n\t\tusb_free_urb(urb);\n\t}\n\n\t/* Did we submit any URBs */\n\tif (i == 0) {\n\t\tnetdev_warn(netdev, \"couldn't setup read URBs\\n\");\n\t\treturn err;\n\t}\n\n\t/* Warn if we've couldn't transmit all the URBs */\n\tif (i < MCBA_MAX_RX_URBS)\n\t\tnetdev_warn(netdev, \"rx performance may be slow\\n\");\n\n\tmcba_usb_xmit_read_fw_ver(priv, MCBA_VER_REQ_USB);\n\tmcba_usb_xmit_read_fw_ver(priv, MCBA_VER_REQ_CAN);\n\n\treturn err;\n}\n\n/* Open USB device */\nstatic int mcba_usb_open(struct net_device *netdev)\n{\n\tstruct mcba_priv *priv = netdev_priv(netdev);\n\tint err;\n\n\t/* common open */\n\terr = open_candev(netdev);\n\tif (err)\n\t\treturn err;\n\n\tpriv->can_speed_check = true;\n\tpriv->can.state = CAN_STATE_ERROR_ACTIVE;\n\n\tcan_led_event(netdev, CAN_LED_EVENT_OPEN);\n\tnetif_start_queue(netdev);\n\n\treturn 0;\n}\n\nstatic void mcba_urb_unlink(struct mcba_priv *priv)\n{\n\tint i;\n\n\tusb_kill_anchored_urbs(&priv->rx_submitted);\n\n\tfor (i = 0; i < MCBA_MAX_RX_URBS; ++i)\n\t\tusb_free_coherent(priv->udev, MCBA_USB_RX_BUFF_SIZE,\n\t\t\t\t  priv->rxbuf[i], priv->rxbuf_dma[i]);\n\n\tusb_kill_anchored_urbs(&priv->tx_submitted);\n}\n\n/* Close USB device */\nstatic int mcba_usb_close(struct net_device *netdev)\n{\n\tstruct mcba_priv *priv = netdev_priv(netdev);\n\n\tpriv->can.state = CAN_STATE_STOPPED;\n\n\tnetif_stop_queue(netdev);\n\n\t/* Stop polling */\n\tmcba_urb_unlink(priv);\n\n\tclose_candev(netdev);\n\tcan_led_event(netdev, CAN_LED_EVENT_STOP);\n\n\treturn 0;\n}\n\n/* Set network device mode\n *\n * Maybe we should leave this function empty, because the device\n * set mode variable with open command.\n */\nstatic int mcba_net_set_mode(struct net_device *netdev, enum can_mode mode)\n{\n\treturn 0;\n}\n\nstatic int mcba_net_get_berr_counter(const struct net_device *netdev,\n\t\t\t\t     struct can_berr_counter *bec)\n{\n\tstruct mcba_priv *priv = netdev_priv(netdev);\n\n\tbec->txerr = priv->bec.txerr;\n\tbec->rxerr = priv->bec.rxerr;\n\n\treturn 0;\n}\n\nstatic const struct net_device_ops mcba_netdev_ops = {\n\t.ndo_open = mcba_usb_open,\n\t.ndo_stop = mcba_usb_close,\n\t.ndo_start_xmit = mcba_usb_start_xmit,\n};\n\n/* Microchip CANBUS has hardcoded bittiming values by default.\n * This function sends request via USB to change the speed and align bittiming\n * values for presentation purposes only\n */\nstatic int mcba_net_set_bittiming(struct net_device *netdev)\n{\n\tstruct mcba_priv *priv = netdev_priv(netdev);\n\tconst u16 bitrate_kbps = priv->can.bittiming.bitrate / 1000;\n\n\tmcba_usb_xmit_change_bitrate(priv, bitrate_kbps);\n\n\treturn 0;\n}\n\nstatic int mcba_set_termination(struct net_device *netdev, u16 term)\n{\n\tstruct mcba_priv *priv = netdev_priv(netdev);\n\tstruct mcba_usb_msg_termination usb_msg = {\n\t\t.cmd_id = MBCA_CMD_SETUP_TERMINATION_RESISTANCE\n\t};\n\n\tif (term == MCBA_TERMINATION_ENABLED)\n\t\tusb_msg.termination = 1;\n\telse\n\t\tusb_msg.termination = 0;\n\n\tmcba_usb_xmit_cmd(priv, (struct mcba_usb_msg *)&usb_msg);\n\n\treturn 0;\n}\n\nstatic int mcba_usb_probe(struct usb_interface *intf,\n\t\t\t  const struct usb_device_id *id)\n{\n\tstruct net_device *netdev;\n\tstruct mcba_priv *priv;\n\tint err;\n\tstruct usb_device *usbdev = interface_to_usbdev(intf);\n\n\tnetdev = alloc_candev(sizeof(struct mcba_priv), MCBA_MAX_TX_URBS);\n\tif (!netdev) {\n\t\tdev_err(&intf->dev, \"Couldn't alloc candev\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpriv = netdev_priv(netdev);\n\n\tpriv->udev = usbdev;\n\tpriv->netdev = netdev;\n\tpriv->usb_ka_first_pass = true;\n\tpriv->can_ka_first_pass = true;\n\tpriv->can_speed_check = false;\n\n\tinit_usb_anchor(&priv->rx_submitted);\n\tinit_usb_anchor(&priv->tx_submitted);\n\n\tusb_set_intfdata(intf, priv);\n\n\t/* Init CAN device */\n\tpriv->can.state = CAN_STATE_STOPPED;\n\tpriv->can.termination_const = mcba_termination;\n\tpriv->can.termination_const_cnt = ARRAY_SIZE(mcba_termination);\n\tpriv->can.bitrate_const = mcba_bitrate;\n\tpriv->can.bitrate_const_cnt = ARRAY_SIZE(mcba_bitrate);\n\n\tpriv->can.do_set_termination = mcba_set_termination;\n\tpriv->can.do_set_mode = mcba_net_set_mode;\n\tpriv->can.do_get_berr_counter = mcba_net_get_berr_counter;\n\tpriv->can.do_set_bittiming = mcba_net_set_bittiming;\n\n\tnetdev->netdev_ops = &mcba_netdev_ops;\n\n\tnetdev->flags |= IFF_ECHO; /* we support local echo */\n\n\tSET_NETDEV_DEV(netdev, &intf->dev);\n\n\terr = register_candev(netdev);\n\tif (err) {\n\t\tnetdev_err(netdev, \"couldn't register CAN device: %d\\n\", err);\n\n\t\tgoto cleanup_free_candev;\n\t}\n\n\tdevm_can_led_init(netdev);\n\n\t/* Start USB dev only if we have successfully registered CAN device */\n\terr = mcba_usb_start(priv);\n\tif (err) {\n\t\tif (err == -ENODEV)\n\t\t\tnetif_device_detach(priv->netdev);\n\n\t\tnetdev_warn(netdev, \"couldn't start device: %d\\n\", err);\n\n\t\tgoto cleanup_unregister_candev;\n\t}\n\n\tdev_info(&intf->dev, \"Microchip CAN BUS Analyzer connected\\n\");\n\n\treturn 0;\n\ncleanup_unregister_candev:\n\tunregister_candev(priv->netdev);\n\ncleanup_free_candev:\n\tfree_candev(netdev);\n\n\treturn err;\n}\n\n/* Called by the usb core when driver is unloaded or device is removed */\nstatic void mcba_usb_disconnect(struct usb_interface *intf)\n{\n\tstruct mcba_priv *priv = usb_get_intfdata(intf);\n\n\tusb_set_intfdata(intf, NULL);\n\n\tnetdev_info(priv->netdev, \"device disconnected\\n\");\n\n\tunregister_candev(priv->netdev);\n\tmcba_urb_unlink(priv);\n\tfree_candev(priv->netdev);\n}\n\nstatic struct usb_driver mcba_usb_driver = {\n\t.name = MCBA_MODULE_NAME,\n\t.probe = mcba_usb_probe,\n\t.disconnect = mcba_usb_disconnect,\n\t.id_table = mcba_usb_table,\n};\n\nmodule_usb_driver(mcba_usb_driver);\n\nMODULE_AUTHOR(\"Remigiusz Ko\u0142\u0142\u0105taj <remigiusz.kollataj@mobica.com>\");\nMODULE_DESCRIPTION(\"SocketCAN driver for Microchip CAN BUS Analyzer Tool\");\nMODULE_LICENSE(\"GPL v2\");\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0-only\n/* SocketCAN driver for Microchip CAN BUS Analyzer Tool\n *\n * Copyright (C) 2017 Mobica Limited\n *\n * This driver is inspired by the 4.6.2 version of net/can/usb/usb_8dev.c\n */\n\n#include <asm/unaligned.h>\n#include <linux/can.h>\n#include <linux/can/dev.h>\n#include <linux/can/error.h>\n#include <linux/can/led.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/signal.h>\n#include <linux/slab.h>\n#include <linux/usb.h>\n\n/* vendor and product id */\n#define MCBA_MODULE_NAME \"mcba_usb\"\n#define MCBA_VENDOR_ID 0x04d8\n#define MCBA_PRODUCT_ID 0x0a30\n\n/* driver constants */\n#define MCBA_MAX_RX_URBS 20\n#define MCBA_MAX_TX_URBS 20\n#define MCBA_CTX_FREE MCBA_MAX_TX_URBS\n\n/* RX buffer must be bigger than msg size since at the\n * beginning USB messages are stacked.\n */\n#define MCBA_USB_RX_BUFF_SIZE 64\n#define MCBA_USB_TX_BUFF_SIZE (sizeof(struct mcba_usb_msg))\n\n/* MCBA endpoint numbers */\n#define MCBA_USB_EP_IN 1\n#define MCBA_USB_EP_OUT 1\n\n/* Microchip command id */\n#define MBCA_CMD_RECEIVE_MESSAGE 0xE3\n#define MBCA_CMD_I_AM_ALIVE_FROM_CAN 0xF5\n#define MBCA_CMD_I_AM_ALIVE_FROM_USB 0xF7\n#define MBCA_CMD_CHANGE_BIT_RATE 0xA1\n#define MBCA_CMD_TRANSMIT_MESSAGE_EV 0xA3\n#define MBCA_CMD_SETUP_TERMINATION_RESISTANCE 0xA8\n#define MBCA_CMD_READ_FW_VERSION 0xA9\n#define MBCA_CMD_NOTHING_TO_SEND 0xFF\n#define MBCA_CMD_TRANSMIT_MESSAGE_RSP 0xE2\n\n#define MCBA_VER_REQ_USB 1\n#define MCBA_VER_REQ_CAN 2\n\n#define MCBA_SIDL_EXID_MASK 0x8\n#define MCBA_DLC_MASK 0xf\n#define MCBA_DLC_RTR_MASK 0x40\n\n#define MCBA_CAN_STATE_WRN_TH 95\n#define MCBA_CAN_STATE_ERR_PSV_TH 127\n\n#define MCBA_TERMINATION_DISABLED CAN_TERMINATION_DISABLED\n#define MCBA_TERMINATION_ENABLED 120\n\nstruct mcba_usb_ctx {\n\tstruct mcba_priv *priv;\n\tu32 ndx;\n\tbool can;\n};\n\n/* Structure to hold all of our device specific stuff */\nstruct mcba_priv {\n\tstruct can_priv can; /* must be the first member */\n\tstruct sk_buff *echo_skb[MCBA_MAX_TX_URBS];\n\tstruct mcba_usb_ctx tx_context[MCBA_MAX_TX_URBS];\n\tstruct usb_device *udev;\n\tstruct net_device *netdev;\n\tstruct usb_anchor tx_submitted;\n\tstruct usb_anchor rx_submitted;\n\tstruct can_berr_counter bec;\n\tbool usb_ka_first_pass;\n\tbool can_ka_first_pass;\n\tbool can_speed_check;\n\tatomic_t free_ctx_cnt;\n\tvoid *rxbuf[MCBA_MAX_RX_URBS];\n\tdma_addr_t rxbuf_dma[MCBA_MAX_RX_URBS];\n};\n\n/* CAN frame */\nstruct __packed mcba_usb_msg_can {\n\tu8 cmd_id;\n\t__be16 eid;\n\t__be16 sid;\n\tu8 dlc;\n\tu8 data[8];\n\tu8 timestamp[4];\n\tu8 checksum;\n};\n\n/* command frame */\nstruct __packed mcba_usb_msg {\n\tu8 cmd_id;\n\tu8 unused[18];\n};\n\nstruct __packed mcba_usb_msg_ka_usb {\n\tu8 cmd_id;\n\tu8 termination_state;\n\tu8 soft_ver_major;\n\tu8 soft_ver_minor;\n\tu8 unused[15];\n};\n\nstruct __packed mcba_usb_msg_ka_can {\n\tu8 cmd_id;\n\tu8 tx_err_cnt;\n\tu8 rx_err_cnt;\n\tu8 rx_buff_ovfl;\n\tu8 tx_bus_off;\n\t__be16 can_bitrate;\n\t__le16 rx_lost;\n\tu8 can_stat;\n\tu8 soft_ver_major;\n\tu8 soft_ver_minor;\n\tu8 debug_mode;\n\tu8 test_complete;\n\tu8 test_result;\n\tu8 unused[4];\n};\n\nstruct __packed mcba_usb_msg_change_bitrate {\n\tu8 cmd_id;\n\t__be16 bitrate;\n\tu8 unused[16];\n};\n\nstruct __packed mcba_usb_msg_termination {\n\tu8 cmd_id;\n\tu8 termination;\n\tu8 unused[17];\n};\n\nstruct __packed mcba_usb_msg_fw_ver {\n\tu8 cmd_id;\n\tu8 pic;\n\tu8 unused[17];\n};\n\nstatic const struct usb_device_id mcba_usb_table[] = {\n\t{ USB_DEVICE(MCBA_VENDOR_ID, MCBA_PRODUCT_ID) },\n\t{} /* Terminating entry */\n};\n\nMODULE_DEVICE_TABLE(usb, mcba_usb_table);\n\nstatic const u16 mcba_termination[] = { MCBA_TERMINATION_DISABLED,\n\t\t\t\t\tMCBA_TERMINATION_ENABLED };\n\nstatic const u32 mcba_bitrate[] = { 20000,  33333,  50000,  80000,  83333,\n\t\t\t\t    100000, 125000, 150000, 175000, 200000,\n\t\t\t\t    225000, 250000, 275000, 300000, 500000,\n\t\t\t\t    625000, 800000, 1000000 };\n\nstatic inline void mcba_init_ctx(struct mcba_priv *priv)\n{\n\tint i = 0;\n\n\tfor (i = 0; i < MCBA_MAX_TX_URBS; i++) {\n\t\tpriv->tx_context[i].ndx = MCBA_CTX_FREE;\n\t\tpriv->tx_context[i].priv = priv;\n\t}\n\n\tatomic_set(&priv->free_ctx_cnt, ARRAY_SIZE(priv->tx_context));\n}\n\nstatic inline struct mcba_usb_ctx *mcba_usb_get_free_ctx(struct mcba_priv *priv,\n\t\t\t\t\t\t\t struct can_frame *cf)\n{\n\tint i = 0;\n\tstruct mcba_usb_ctx *ctx = NULL;\n\n\tfor (i = 0; i < MCBA_MAX_TX_URBS; i++) {\n\t\tif (priv->tx_context[i].ndx == MCBA_CTX_FREE) {\n\t\t\tctx = &priv->tx_context[i];\n\t\t\tctx->ndx = i;\n\n\t\t\tif (cf)\n\t\t\t\tctx->can = true;\n\t\t\telse\n\t\t\t\tctx->can = false;\n\n\t\t\tatomic_dec(&priv->free_ctx_cnt);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!atomic_read(&priv->free_ctx_cnt))\n\t\t/* That was the last free ctx. Slow down tx path */\n\t\tnetif_stop_queue(priv->netdev);\n\n\treturn ctx;\n}\n\n/* mcba_usb_free_ctx and mcba_usb_get_free_ctx are executed by different\n * threads. The order of execution in below function is important.\n */\nstatic inline void mcba_usb_free_ctx(struct mcba_usb_ctx *ctx)\n{\n\t/* Increase number of free ctxs before freeing ctx */\n\tatomic_inc(&ctx->priv->free_ctx_cnt);\n\n\tctx->ndx = MCBA_CTX_FREE;\n\n\t/* Wake up the queue once ctx is marked free */\n\tnetif_wake_queue(ctx->priv->netdev);\n}\n\nstatic void mcba_usb_write_bulk_callback(struct urb *urb)\n{\n\tstruct mcba_usb_ctx *ctx = urb->context;\n\tstruct net_device *netdev;\n\n\tWARN_ON(!ctx);\n\n\tnetdev = ctx->priv->netdev;\n\n\t/* free up our allocated buffer */\n\tusb_free_coherent(urb->dev, urb->transfer_buffer_length,\n\t\t\t  urb->transfer_buffer, urb->transfer_dma);\n\n\tif (ctx->can) {\n\t\tif (!netif_device_present(netdev))\n\t\t\treturn;\n\n\t\tnetdev->stats.tx_packets++;\n\t\tnetdev->stats.tx_bytes += can_get_echo_skb(netdev, ctx->ndx,\n\t\t\t\t\t\t\t   NULL);\n\n\t\tcan_led_event(netdev, CAN_LED_EVENT_TX);\n\t}\n\n\tif (urb->status)\n\t\tnetdev_info(netdev, \"Tx URB aborted (%d)\\n\", urb->status);\n\n\t/* Release the context */\n\tmcba_usb_free_ctx(ctx);\n}\n\n/* Send data to device */\nstatic netdev_tx_t mcba_usb_xmit(struct mcba_priv *priv,\n\t\t\t\t struct mcba_usb_msg *usb_msg,\n\t\t\t\t struct mcba_usb_ctx *ctx)\n{\n\tstruct urb *urb;\n\tu8 *buf;\n\tint err;\n\n\t/* create a URB, and a buffer for it, and copy the data to the URB */\n\turb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (!urb)\n\t\treturn -ENOMEM;\n\n\tbuf = usb_alloc_coherent(priv->udev, MCBA_USB_TX_BUFF_SIZE, GFP_ATOMIC,\n\t\t\t\t &urb->transfer_dma);\n\tif (!buf) {\n\t\terr = -ENOMEM;\n\t\tgoto nomembuf;\n\t}\n\n\tmemcpy(buf, usb_msg, MCBA_USB_TX_BUFF_SIZE);\n\n\tusb_fill_bulk_urb(urb, priv->udev,\n\t\t\t  usb_sndbulkpipe(priv->udev, MCBA_USB_EP_OUT), buf,\n\t\t\t  MCBA_USB_TX_BUFF_SIZE, mcba_usb_write_bulk_callback,\n\t\t\t  ctx);\n\n\turb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\tusb_anchor_urb(urb, &priv->tx_submitted);\n\n\terr = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (unlikely(err))\n\t\tgoto failed;\n\n\t/* Release our reference to this URB, the USB core will eventually free\n\t * it entirely.\n\t */\n\tusb_free_urb(urb);\n\n\treturn 0;\n\nfailed:\n\tusb_unanchor_urb(urb);\n\tusb_free_coherent(priv->udev, MCBA_USB_TX_BUFF_SIZE, buf,\n\t\t\t  urb->transfer_dma);\n\n\tif (err == -ENODEV)\n\t\tnetif_device_detach(priv->netdev);\n\telse\n\t\tnetdev_warn(priv->netdev, \"failed tx_urb %d\\n\", err);\n\nnomembuf:\n\tusb_free_urb(urb);\n\n\treturn err;\n}\n\n/* Send data to device */\nstatic netdev_tx_t mcba_usb_start_xmit(struct sk_buff *skb,\n\t\t\t\t       struct net_device *netdev)\n{\n\tstruct mcba_priv *priv = netdev_priv(netdev);\n\tstruct can_frame *cf = (struct can_frame *)skb->data;\n\tstruct mcba_usb_ctx *ctx = NULL;\n\tstruct net_device_stats *stats = &priv->netdev->stats;\n\tu16 sid;\n\tint err;\n\tstruct mcba_usb_msg_can usb_msg = {\n\t\t.cmd_id = MBCA_CMD_TRANSMIT_MESSAGE_EV\n\t};\n\n\tif (can_dropped_invalid_skb(netdev, skb))\n\t\treturn NETDEV_TX_OK;\n\n\tctx = mcba_usb_get_free_ctx(priv, cf);\n\tif (!ctx)\n\t\treturn NETDEV_TX_BUSY;\n\n\tif (cf->can_id & CAN_EFF_FLAG) {\n\t\t/* SIDH    | SIDL                 | EIDH   | EIDL\n\t\t * 28 - 21 | 20 19 18 x x x 17 16 | 15 - 8 | 7 - 0\n\t\t */\n\t\tsid = MCBA_SIDL_EXID_MASK;\n\t\t/* store 28-18 bits */\n\t\tsid |= (cf->can_id & 0x1ffc0000) >> 13;\n\t\t/* store 17-16 bits */\n\t\tsid |= (cf->can_id & 0x30000) >> 16;\n\t\tput_unaligned_be16(sid, &usb_msg.sid);\n\n\t\t/* store 15-0 bits */\n\t\tput_unaligned_be16(cf->can_id & 0xffff, &usb_msg.eid);\n\t} else {\n\t\t/* SIDH   | SIDL\n\t\t * 10 - 3 | 2 1 0 x x x x x\n\t\t */\n\t\tput_unaligned_be16((cf->can_id & CAN_SFF_MASK) << 5,\n\t\t\t\t   &usb_msg.sid);\n\t\tusb_msg.eid = 0;\n\t}\n\n\tusb_msg.dlc = cf->len;\n\n\tmemcpy(usb_msg.data, cf->data, usb_msg.dlc);\n\n\tif (cf->can_id & CAN_RTR_FLAG)\n\t\tusb_msg.dlc |= MCBA_DLC_RTR_MASK;\n\n\tcan_put_echo_skb(skb, priv->netdev, ctx->ndx, 0);\n\n\terr = mcba_usb_xmit(priv, (struct mcba_usb_msg *)&usb_msg, ctx);\n\tif (err)\n\t\tgoto xmit_failed;\n\n\treturn NETDEV_TX_OK;\n\nxmit_failed:\n\tcan_free_echo_skb(priv->netdev, ctx->ndx, NULL);\n\tmcba_usb_free_ctx(ctx);\n\tstats->tx_dropped++;\n\n\treturn NETDEV_TX_OK;\n}\n\n/* Send cmd to device */\nstatic void mcba_usb_xmit_cmd(struct mcba_priv *priv,\n\t\t\t      struct mcba_usb_msg *usb_msg)\n{\n\tstruct mcba_usb_ctx *ctx = NULL;\n\tint err;\n\n\tctx = mcba_usb_get_free_ctx(priv, NULL);\n\tif (!ctx) {\n\t\tnetdev_err(priv->netdev,\n\t\t\t   \"Lack of free ctx. Sending (%d) cmd aborted\",\n\t\t\t   usb_msg->cmd_id);\n\n\t\treturn;\n\t}\n\n\terr = mcba_usb_xmit(priv, usb_msg, ctx);\n\tif (err)\n\t\tnetdev_err(priv->netdev, \"Failed to send cmd (%d)\",\n\t\t\t   usb_msg->cmd_id);\n}\n\nstatic void mcba_usb_xmit_change_bitrate(struct mcba_priv *priv, u16 bitrate)\n{\n\tstruct mcba_usb_msg_change_bitrate usb_msg = {\n\t\t.cmd_id = MBCA_CMD_CHANGE_BIT_RATE\n\t};\n\n\tput_unaligned_be16(bitrate, &usb_msg.bitrate);\n\n\tmcba_usb_xmit_cmd(priv, (struct mcba_usb_msg *)&usb_msg);\n}\n\nstatic void mcba_usb_xmit_read_fw_ver(struct mcba_priv *priv, u8 pic)\n{\n\tstruct mcba_usb_msg_fw_ver usb_msg = {\n\t\t.cmd_id = MBCA_CMD_READ_FW_VERSION,\n\t\t.pic = pic\n\t};\n\n\tmcba_usb_xmit_cmd(priv, (struct mcba_usb_msg *)&usb_msg);\n}\n\nstatic void mcba_usb_process_can(struct mcba_priv *priv,\n\t\t\t\t struct mcba_usb_msg_can *msg)\n{\n\tstruct can_frame *cf;\n\tstruct sk_buff *skb;\n\tstruct net_device_stats *stats = &priv->netdev->stats;\n\tu16 sid;\n\n\tskb = alloc_can_skb(priv->netdev, &cf);\n\tif (!skb)\n\t\treturn;\n\n\tsid = get_unaligned_be16(&msg->sid);\n\n\tif (sid & MCBA_SIDL_EXID_MASK) {\n\t\t/* SIDH    | SIDL                 | EIDH   | EIDL\n\t\t * 28 - 21 | 20 19 18 x x x 17 16 | 15 - 8 | 7 - 0\n\t\t */\n\t\tcf->can_id = CAN_EFF_FLAG;\n\n\t\t/* store 28-18 bits */\n\t\tcf->can_id |= (sid & 0xffe0) << 13;\n\t\t/* store 17-16 bits */\n\t\tcf->can_id |= (sid & 3) << 16;\n\t\t/* store 15-0 bits */\n\t\tcf->can_id |= get_unaligned_be16(&msg->eid);\n\t} else {\n\t\t/* SIDH   | SIDL\n\t\t * 10 - 3 | 2 1 0 x x x x x\n\t\t */\n\t\tcf->can_id = (sid & 0xffe0) >> 5;\n\t}\n\n\tcf->len = can_cc_dlc2len(msg->dlc & MCBA_DLC_MASK);\n\n\tif (msg->dlc & MCBA_DLC_RTR_MASK) {\n\t\tcf->can_id |= CAN_RTR_FLAG;\n\t} else {\n\t\tmemcpy(cf->data, msg->data, cf->len);\n\n\t\tstats->rx_bytes += cf->len;\n\t}\n\tstats->rx_packets++;\n\n\tcan_led_event(priv->netdev, CAN_LED_EVENT_RX);\n\tnetif_rx(skb);\n}\n\nstatic void mcba_usb_process_ka_usb(struct mcba_priv *priv,\n\t\t\t\t    struct mcba_usb_msg_ka_usb *msg)\n{\n\tif (unlikely(priv->usb_ka_first_pass)) {\n\t\tnetdev_info(priv->netdev, \"PIC USB version %u.%u\\n\",\n\t\t\t    msg->soft_ver_major, msg->soft_ver_minor);\n\n\t\tpriv->usb_ka_first_pass = false;\n\t}\n\n\tif (msg->termination_state)\n\t\tpriv->can.termination = MCBA_TERMINATION_ENABLED;\n\telse\n\t\tpriv->can.termination = MCBA_TERMINATION_DISABLED;\n}\n\nstatic u32 convert_can2host_bitrate(struct mcba_usb_msg_ka_can *msg)\n{\n\tconst u32 bitrate = get_unaligned_be16(&msg->can_bitrate);\n\n\tif ((bitrate == 33) || (bitrate == 83))\n\t\treturn bitrate * 1000 + 333;\n\telse\n\t\treturn bitrate * 1000;\n}\n\nstatic void mcba_usb_process_ka_can(struct mcba_priv *priv,\n\t\t\t\t    struct mcba_usb_msg_ka_can *msg)\n{\n\tif (unlikely(priv->can_ka_first_pass)) {\n\t\tnetdev_info(priv->netdev, \"PIC CAN version %u.%u\\n\",\n\t\t\t    msg->soft_ver_major, msg->soft_ver_minor);\n\n\t\tpriv->can_ka_first_pass = false;\n\t}\n\n\tif (unlikely(priv->can_speed_check)) {\n\t\tconst u32 bitrate = convert_can2host_bitrate(msg);\n\n\t\tpriv->can_speed_check = false;\n\n\t\tif (bitrate != priv->can.bittiming.bitrate)\n\t\t\tnetdev_err(\n\t\t\t    priv->netdev,\n\t\t\t    \"Wrong bitrate reported by the device (%u). Expected %u\",\n\t\t\t    bitrate, priv->can.bittiming.bitrate);\n\t}\n\n\tpriv->bec.txerr = msg->tx_err_cnt;\n\tpriv->bec.rxerr = msg->rx_err_cnt;\n\n\tif (msg->tx_bus_off)\n\t\tpriv->can.state = CAN_STATE_BUS_OFF;\n\n\telse if ((priv->bec.txerr > MCBA_CAN_STATE_ERR_PSV_TH) ||\n\t\t (priv->bec.rxerr > MCBA_CAN_STATE_ERR_PSV_TH))\n\t\tpriv->can.state = CAN_STATE_ERROR_PASSIVE;\n\n\telse if ((priv->bec.txerr > MCBA_CAN_STATE_WRN_TH) ||\n\t\t (priv->bec.rxerr > MCBA_CAN_STATE_WRN_TH))\n\t\tpriv->can.state = CAN_STATE_ERROR_WARNING;\n}\n\nstatic void mcba_usb_process_rx(struct mcba_priv *priv,\n\t\t\t\tstruct mcba_usb_msg *msg)\n{\n\tswitch (msg->cmd_id) {\n\tcase MBCA_CMD_I_AM_ALIVE_FROM_CAN:\n\t\tmcba_usb_process_ka_can(priv,\n\t\t\t\t\t(struct mcba_usb_msg_ka_can *)msg);\n\t\tbreak;\n\n\tcase MBCA_CMD_I_AM_ALIVE_FROM_USB:\n\t\tmcba_usb_process_ka_usb(priv,\n\t\t\t\t\t(struct mcba_usb_msg_ka_usb *)msg);\n\t\tbreak;\n\n\tcase MBCA_CMD_RECEIVE_MESSAGE:\n\t\tmcba_usb_process_can(priv, (struct mcba_usb_msg_can *)msg);\n\t\tbreak;\n\n\tcase MBCA_CMD_NOTHING_TO_SEND:\n\t\t/* Side effect of communication between PIC_USB and PIC_CAN.\n\t\t * PIC_CAN is telling us that it has nothing to send\n\t\t */\n\t\tbreak;\n\n\tcase MBCA_CMD_TRANSMIT_MESSAGE_RSP:\n\t\t/* Transmission response from the device containing timestamp */\n\t\tbreak;\n\n\tdefault:\n\t\tnetdev_warn(priv->netdev, \"Unsupported msg (0x%X)\",\n\t\t\t    msg->cmd_id);\n\t\tbreak;\n\t}\n}\n\n/* Callback for reading data from device\n *\n * Check urb status, call read function and resubmit urb read operation.\n */\nstatic void mcba_usb_read_bulk_callback(struct urb *urb)\n{\n\tstruct mcba_priv *priv = urb->context;\n\tstruct net_device *netdev;\n\tint retval;\n\tint pos = 0;\n\n\tnetdev = priv->netdev;\n\n\tif (!netif_device_present(netdev))\n\t\treturn;\n\n\tswitch (urb->status) {\n\tcase 0: /* success */\n\t\tbreak;\n\n\tcase -ENOENT:\n\tcase -EPIPE:\n\tcase -EPROTO:\n\tcase -ESHUTDOWN:\n\t\treturn;\n\n\tdefault:\n\t\tnetdev_info(netdev, \"Rx URB aborted (%d)\\n\", urb->status);\n\n\t\tgoto resubmit_urb;\n\t}\n\n\twhile (pos < urb->actual_length) {\n\t\tstruct mcba_usb_msg *msg;\n\n\t\tif (pos + sizeof(struct mcba_usb_msg) > urb->actual_length) {\n\t\t\tnetdev_err(priv->netdev, \"format error\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tmsg = (struct mcba_usb_msg *)(urb->transfer_buffer + pos);\n\t\tmcba_usb_process_rx(priv, msg);\n\n\t\tpos += sizeof(struct mcba_usb_msg);\n\t}\n\nresubmit_urb:\n\n\tusb_fill_bulk_urb(urb, priv->udev,\n\t\t\t  usb_rcvbulkpipe(priv->udev, MCBA_USB_EP_OUT),\n\t\t\t  urb->transfer_buffer, MCBA_USB_RX_BUFF_SIZE,\n\t\t\t  mcba_usb_read_bulk_callback, priv);\n\n\tretval = usb_submit_urb(urb, GFP_ATOMIC);\n\n\tif (retval == -ENODEV)\n\t\tnetif_device_detach(netdev);\n\telse if (retval)\n\t\tnetdev_err(netdev, \"failed resubmitting read bulk urb: %d\\n\",\n\t\t\t   retval);\n}\n\n/* Start USB device */\nstatic int mcba_usb_start(struct mcba_priv *priv)\n{\n\tstruct net_device *netdev = priv->netdev;\n\tint err, i;\n\n\tmcba_init_ctx(priv);\n\n\tfor (i = 0; i < MCBA_MAX_RX_URBS; i++) {\n\t\tstruct urb *urb = NULL;\n\t\tu8 *buf;\n\t\tdma_addr_t buf_dma;\n\n\t\t/* create a URB, and a buffer for it */\n\t\turb = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!urb) {\n\t\t\terr = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tbuf = usb_alloc_coherent(priv->udev, MCBA_USB_RX_BUFF_SIZE,\n\t\t\t\t\t GFP_KERNEL, &buf_dma);\n\t\tif (!buf) {\n\t\t\tnetdev_err(netdev, \"No memory left for USB buffer\\n\");\n\t\t\tusb_free_urb(urb);\n\t\t\terr = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\turb->transfer_dma = buf_dma;\n\n\t\tusb_fill_bulk_urb(urb, priv->udev,\n\t\t\t\t  usb_rcvbulkpipe(priv->udev, MCBA_USB_EP_IN),\n\t\t\t\t  buf, MCBA_USB_RX_BUFF_SIZE,\n\t\t\t\t  mcba_usb_read_bulk_callback, priv);\n\t\turb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\t\tusb_anchor_urb(urb, &priv->rx_submitted);\n\n\t\terr = usb_submit_urb(urb, GFP_KERNEL);\n\t\tif (err) {\n\t\t\tusb_unanchor_urb(urb);\n\t\t\tusb_free_coherent(priv->udev, MCBA_USB_RX_BUFF_SIZE,\n\t\t\t\t\t  buf, buf_dma);\n\t\t\tusb_free_urb(urb);\n\t\t\tbreak;\n\t\t}\n\n\t\tpriv->rxbuf[i] = buf;\n\t\tpriv->rxbuf_dma[i] = buf_dma;\n\n\t\t/* Drop reference, USB core will take care of freeing it */\n\t\tusb_free_urb(urb);\n\t}\n\n\t/* Did we submit any URBs */\n\tif (i == 0) {\n\t\tnetdev_warn(netdev, \"couldn't setup read URBs\\n\");\n\t\treturn err;\n\t}\n\n\t/* Warn if we've couldn't transmit all the URBs */\n\tif (i < MCBA_MAX_RX_URBS)\n\t\tnetdev_warn(netdev, \"rx performance may be slow\\n\");\n\n\tmcba_usb_xmit_read_fw_ver(priv, MCBA_VER_REQ_USB);\n\tmcba_usb_xmit_read_fw_ver(priv, MCBA_VER_REQ_CAN);\n\n\treturn err;\n}\n\n/* Open USB device */\nstatic int mcba_usb_open(struct net_device *netdev)\n{\n\tstruct mcba_priv *priv = netdev_priv(netdev);\n\tint err;\n\n\t/* common open */\n\terr = open_candev(netdev);\n\tif (err)\n\t\treturn err;\n\n\tpriv->can_speed_check = true;\n\tpriv->can.state = CAN_STATE_ERROR_ACTIVE;\n\n\tcan_led_event(netdev, CAN_LED_EVENT_OPEN);\n\tnetif_start_queue(netdev);\n\n\treturn 0;\n}\n\nstatic void mcba_urb_unlink(struct mcba_priv *priv)\n{\n\tint i;\n\n\tusb_kill_anchored_urbs(&priv->rx_submitted);\n\n\tfor (i = 0; i < MCBA_MAX_RX_URBS; ++i)\n\t\tusb_free_coherent(priv->udev, MCBA_USB_RX_BUFF_SIZE,\n\t\t\t\t  priv->rxbuf[i], priv->rxbuf_dma[i]);\n\n\tusb_kill_anchored_urbs(&priv->tx_submitted);\n}\n\n/* Close USB device */\nstatic int mcba_usb_close(struct net_device *netdev)\n{\n\tstruct mcba_priv *priv = netdev_priv(netdev);\n\n\tpriv->can.state = CAN_STATE_STOPPED;\n\n\tnetif_stop_queue(netdev);\n\n\t/* Stop polling */\n\tmcba_urb_unlink(priv);\n\n\tclose_candev(netdev);\n\tcan_led_event(netdev, CAN_LED_EVENT_STOP);\n\n\treturn 0;\n}\n\n/* Set network device mode\n *\n * Maybe we should leave this function empty, because the device\n * set mode variable with open command.\n */\nstatic int mcba_net_set_mode(struct net_device *netdev, enum can_mode mode)\n{\n\treturn 0;\n}\n\nstatic int mcba_net_get_berr_counter(const struct net_device *netdev,\n\t\t\t\t     struct can_berr_counter *bec)\n{\n\tstruct mcba_priv *priv = netdev_priv(netdev);\n\n\tbec->txerr = priv->bec.txerr;\n\tbec->rxerr = priv->bec.rxerr;\n\n\treturn 0;\n}\n\nstatic const struct net_device_ops mcba_netdev_ops = {\n\t.ndo_open = mcba_usb_open,\n\t.ndo_stop = mcba_usb_close,\n\t.ndo_start_xmit = mcba_usb_start_xmit,\n};\n\n/* Microchip CANBUS has hardcoded bittiming values by default.\n * This function sends request via USB to change the speed and align bittiming\n * values for presentation purposes only\n */\nstatic int mcba_net_set_bittiming(struct net_device *netdev)\n{\n\tstruct mcba_priv *priv = netdev_priv(netdev);\n\tconst u16 bitrate_kbps = priv->can.bittiming.bitrate / 1000;\n\n\tmcba_usb_xmit_change_bitrate(priv, bitrate_kbps);\n\n\treturn 0;\n}\n\nstatic int mcba_set_termination(struct net_device *netdev, u16 term)\n{\n\tstruct mcba_priv *priv = netdev_priv(netdev);\n\tstruct mcba_usb_msg_termination usb_msg = {\n\t\t.cmd_id = MBCA_CMD_SETUP_TERMINATION_RESISTANCE\n\t};\n\n\tif (term == MCBA_TERMINATION_ENABLED)\n\t\tusb_msg.termination = 1;\n\telse\n\t\tusb_msg.termination = 0;\n\n\tmcba_usb_xmit_cmd(priv, (struct mcba_usb_msg *)&usb_msg);\n\n\treturn 0;\n}\n\nstatic int mcba_usb_probe(struct usb_interface *intf,\n\t\t\t  const struct usb_device_id *id)\n{\n\tstruct net_device *netdev;\n\tstruct mcba_priv *priv;\n\tint err;\n\tstruct usb_device *usbdev = interface_to_usbdev(intf);\n\n\tnetdev = alloc_candev(sizeof(struct mcba_priv), MCBA_MAX_TX_URBS);\n\tif (!netdev) {\n\t\tdev_err(&intf->dev, \"Couldn't alloc candev\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpriv = netdev_priv(netdev);\n\n\tpriv->udev = usbdev;\n\tpriv->netdev = netdev;\n\tpriv->usb_ka_first_pass = true;\n\tpriv->can_ka_first_pass = true;\n\tpriv->can_speed_check = false;\n\n\tinit_usb_anchor(&priv->rx_submitted);\n\tinit_usb_anchor(&priv->tx_submitted);\n\n\tusb_set_intfdata(intf, priv);\n\n\t/* Init CAN device */\n\tpriv->can.state = CAN_STATE_STOPPED;\n\tpriv->can.termination_const = mcba_termination;\n\tpriv->can.termination_const_cnt = ARRAY_SIZE(mcba_termination);\n\tpriv->can.bitrate_const = mcba_bitrate;\n\tpriv->can.bitrate_const_cnt = ARRAY_SIZE(mcba_bitrate);\n\n\tpriv->can.do_set_termination = mcba_set_termination;\n\tpriv->can.do_set_mode = mcba_net_set_mode;\n\tpriv->can.do_get_berr_counter = mcba_net_get_berr_counter;\n\tpriv->can.do_set_bittiming = mcba_net_set_bittiming;\n\n\tnetdev->netdev_ops = &mcba_netdev_ops;\n\n\tnetdev->flags |= IFF_ECHO; /* we support local echo */\n\n\tSET_NETDEV_DEV(netdev, &intf->dev);\n\n\terr = register_candev(netdev);\n\tif (err) {\n\t\tnetdev_err(netdev, \"couldn't register CAN device: %d\\n\", err);\n\n\t\tgoto cleanup_free_candev;\n\t}\n\n\tdevm_can_led_init(netdev);\n\n\t/* Start USB dev only if we have successfully registered CAN device */\n\terr = mcba_usb_start(priv);\n\tif (err) {\n\t\tif (err == -ENODEV)\n\t\t\tnetif_device_detach(priv->netdev);\n\n\t\tnetdev_warn(netdev, \"couldn't start device: %d\\n\", err);\n\n\t\tgoto cleanup_unregister_candev;\n\t}\n\n\tdev_info(&intf->dev, \"Microchip CAN BUS Analyzer connected\\n\");\n\n\treturn 0;\n\ncleanup_unregister_candev:\n\tunregister_candev(priv->netdev);\n\ncleanup_free_candev:\n\tfree_candev(netdev);\n\n\treturn err;\n}\n\n/* Called by the usb core when driver is unloaded or device is removed */\nstatic void mcba_usb_disconnect(struct usb_interface *intf)\n{\n\tstruct mcba_priv *priv = usb_get_intfdata(intf);\n\n\tusb_set_intfdata(intf, NULL);\n\n\tnetdev_info(priv->netdev, \"device disconnected\\n\");\n\n\tunregister_candev(priv->netdev);\n\tmcba_urb_unlink(priv);\n\tfree_candev(priv->netdev);\n}\n\nstatic struct usb_driver mcba_usb_driver = {\n\t.name = MCBA_MODULE_NAME,\n\t.probe = mcba_usb_probe,\n\t.disconnect = mcba_usb_disconnect,\n\t.id_table = mcba_usb_table,\n};\n\nmodule_usb_driver(mcba_usb_driver);\n\nMODULE_AUTHOR(\"Remigiusz Ko\u0142\u0142\u0105taj <remigiusz.kollataj@mobica.com>\");\nMODULE_DESCRIPTION(\"SocketCAN driver for Microchip CAN BUS Analyzer Tool\");\nMODULE_LICENSE(\"GPL v2\");\n"], "filenames": ["drivers/net/can/usb/mcba_usb.c"], "buggy_code_start_loc": [367], "buggy_code_end_loc": [368], "fixing_code_start_loc": [366], "fixing_code_end_loc": [366], "type": "CWE-415", "message": "mcba_usb_start_xmit in drivers/net/can/usb/mcba_usb.c in the Linux kernel through 5.17.1 has a double free.", "other": {"cve": {"id": "CVE-2022-28389", "sourceIdentifier": "cve@mitre.org", "published": "2022-04-03T21:15:08.120", "lastModified": "2023-01-03T15:27:36.087", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "mcba_usb_start_xmit in drivers/net/can/usb/mcba_usb.c in the Linux kernel through 5.17.1 has a double free."}, {"lang": "es", "value": "La funci\u00f3n mcba_usb_start_xmit en el archivo drivers/net/can/usb/mcba_usb.c en el kernel de Linux versiones hasta 5.17.1, presenta una doble liberaci\u00f3n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-415"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "5.17.1", "matchCriteriaId": "63CEA1F5-F935-4664-88B3-3433F56FFB8B"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:11.0:*:*:*:*:*:*:*", "matchCriteriaId": "FA6FEEC2-9F11-4643-8827-749718254FED"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h300s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "6770B6C3-732E-4E22-BF1C-2D2FD610061C"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h300s:-:*:*:*:*:*:*:*", "matchCriteriaId": "9F9C8C20-42EB-4AB5-BD97-212DEB070C43"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h500s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "7FFF7106-ED78-49BA-9EC5-B889E3685D53"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h500s:-:*:*:*:*:*:*:*", "matchCriteriaId": "E63D8B0F-006E-4801-BF9D-1C001BBFB4F9"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h700s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "56409CEC-5A1E-4450-AA42-641E459CC2AF"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h700s:-:*:*:*:*:*:*:*", "matchCriteriaId": "B06F4839-D16A-4A61-9BB5-55B13F41E47F"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h300e_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "108A2215-50FB-4074-94CF-C130FA14566D"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h300e:-:*:*:*:*:*:*:*", "matchCriteriaId": "7AFC73CE-ABB9-42D3-9A71-3F5BC5381E0E"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h500e_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "32F0B6C0-F930-480D-962B-3F4EFDCC13C7"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h500e:-:*:*:*:*:*:*:*", "matchCriteriaId": "803BC414-B250-4E3A-A478-A3881340D6B8"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h700e_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "0FEB3337-BFDE-462A-908B-176F92053CEC"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h700e:-:*:*:*:*:*:*:*", "matchCriteriaId": "736AEAE9-782B-4F71-9893-DED53367E102"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h410s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "D0B4AD8A-F172-4558-AEC6-FF424BA2D912"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h410s:-:*:*:*:*:*:*:*", "matchCriteriaId": "8497A4C9-8474-4A62-8331-3FE862ED4098"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h410c_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "234DEFE0-5CE5-4B0A-96B8-5D227CB8ED31"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h410c:-:*:*:*:*:*:*:*", "matchCriteriaId": "CDDF61B7-EC5C-467C-B710-B89F502CD04F"}]}]}], "references": [{"url": "https://github.com/torvalds/linux/commit/04c9b00ba83594a29813d6b1fb8fdc93a3915174", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/6IHHC455LMSJNG4CSZ5CEAHYWY2DE5YW/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/LAWC35TO642FOP3UCA3C6IF7NAUFOVZ6/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/XFMPUI3WI4U2F7ONHRW36WDY4ZE7LGGT/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20220513-0001/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2022/dsa-5127", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2022/dsa-5173", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/04c9b00ba83594a29813d6b1fb8fdc93a3915174"}}