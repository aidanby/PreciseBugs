{"buggy_code": ["<?php declare(strict_types=1);\n\nnamespace Shopware\\Core\\Framework\\Api\\Controller;\n\nuse Doctrine\\DBAL\\Connection;\nuse Shopware\\Core\\Checkout\\Cart\\ApiOrderCartService;\nuse Shopware\\Core\\Checkout\\Cart\\Price\\Struct\\CalculatedPrice;\nuse Shopware\\Core\\Checkout\\Cart\\Processor;\nuse Shopware\\Core\\Checkout\\Cart\\SalesChannel\\AbstractCartOrderRoute;\nuse Shopware\\Core\\Checkout\\Cart\\SalesChannel\\CartService;\nuse Shopware\\Core\\Checkout\\Cart\\Tax\\Struct\\CalculatedTaxCollection;\nuse Shopware\\Core\\Checkout\\Cart\\Tax\\Struct\\TaxRuleCollection;\nuse Shopware\\Core\\Checkout\\Promotion\\Cart\\PromotionCollector;\nuse Shopware\\Core\\Content\\Product\\Cart\\ProductCartProcessor;\nuse Shopware\\Core\\Framework\\Api\\Context\\AdminApiSource;\nuse Shopware\\Core\\Framework\\Api\\Exception\\InvalidSalesChannelIdException;\nuse Shopware\\Core\\Framework\\Context;\nuse Shopware\\Core\\Framework\\DataAbstractionLayer\\EntityRepositoryInterface;\nuse Shopware\\Core\\Framework\\DataAbstractionLayer\\Exception\\InconsistentCriteriaIdsException;\nuse Shopware\\Core\\Framework\\DataAbstractionLayer\\Search\\Criteria;\nuse Shopware\\Core\\Framework\\DataAbstractionLayer\\Search\\Filter\\EqualsFilter;\nuse Shopware\\Core\\Framework\\DataAbstractionLayer\\Validation\\EntityExists;\nuse Shopware\\Core\\Framework\\Routing\\Annotation\\Acl;\nuse Shopware\\Core\\Framework\\Routing\\Annotation\\RouteScope;\nuse Shopware\\Core\\Framework\\Routing\\Annotation\\Since;\nuse Shopware\\Core\\Framework\\Routing\\Exception\\MissingRequestParameterException;\nuse Shopware\\Core\\Framework\\Routing\\SalesChannelRequestContextResolver;\nuse Shopware\\Core\\Framework\\Util\\Random;\nuse Shopware\\Core\\Framework\\Uuid\\Uuid;\nuse Shopware\\Core\\Framework\\Validation\\DataBag\\DataBag;\nuse Shopware\\Core\\Framework\\Validation\\DataBag\\RequestDataBag;\nuse Shopware\\Core\\Framework\\Validation\\DataValidationDefinition;\nuse Shopware\\Core\\Framework\\Validation\\DataValidator;\nuse Shopware\\Core\\PlatformRequest;\nuse Shopware\\Core\\SalesChannelRequest;\nuse Shopware\\Core\\System\\SalesChannel\\Context\\SalesChannelContextPersister;\nuse Shopware\\Core\\System\\SalesChannel\\Context\\SalesChannelContextService;\nuse Shopware\\Core\\System\\SalesChannel\\Context\\SalesChannelContextServiceInterface;\nuse Shopware\\Core\\System\\SalesChannel\\Context\\SalesChannelContextServiceParameters;\nuse Shopware\\Core\\System\\SalesChannel\\Event\\SalesChannelContextSwitchEvent;\nuse Shopware\\Core\\System\\SalesChannel\\SalesChannelContext;\nuse Shopware\\Core\\System\\SalesChannel\\SalesChannelEntity;\nuse Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\nuse Symfony\\Component\\EventDispatcher\\EventDispatcherInterface;\nuse Symfony\\Component\\HttpFoundation\\JsonResponse;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\RequestStack;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpKernel\\HttpKernelInterface;\nuse Symfony\\Component\\HttpKernel\\KernelInterface;\nuse Symfony\\Component\\Routing\\Annotation\\Route;\nuse Symfony\\Component\\Validator\\Constraints\\GreaterThanOrEqual;\nuse Symfony\\Component\\Validator\\Constraints\\NotBlank;\nuse Symfony\\Component\\Validator\\Constraints\\Type;\n\n/**\n * @RouteScope(scopes={\"api\"})\n */\nclass SalesChannelProxyController extends AbstractController\n{\n    private const CUSTOMER_ID = SalesChannelContextService::CUSTOMER_ID;\n\n    private const SALES_CHANNEL_ID = 'salesChannelId';\n\n    private const ADMIN_ORDER_PERMISSIONS = [\n        ProductCartProcessor::ALLOW_PRODUCT_PRICE_OVERWRITES => true,\n    ];\n\n    protected DataValidator $validator;\n\n    protected SalesChannelContextPersister $contextPersister;\n\n    protected Processor $processor;\n\n    private KernelInterface $kernel;\n\n    private EntityRepositoryInterface $salesChannelRepository;\n\n    private SalesChannelRequestContextResolver $requestContextResolver;\n\n    private EventDispatcherInterface $eventDispatcher;\n\n    private ApiOrderCartService $adminOrderCartService;\n\n    private SalesChannelContextServiceInterface $contextService;\n\n    private AbstractCartOrderRoute $orderRoute;\n\n    private CartService $cartService;\n\n    private Connection $connection;\n\n    public function __construct(\n        KernelInterface $kernel,\n        EntityRepositoryInterface $salesChannelRepository,\n        DataValidator $validator,\n        SalesChannelContextPersister $contextPersister,\n        SalesChannelRequestContextResolver $requestContextResolver,\n        SalesChannelContextServiceInterface $contextService,\n        EventDispatcherInterface $eventDispatcher,\n        ApiOrderCartService $adminOrderCartService,\n        AbstractCartOrderRoute $orderRoute,\n        CartService $cartService,\n        Connection $connection\n    ) {\n        $this->kernel = $kernel;\n        $this->salesChannelRepository = $salesChannelRepository;\n        $this->validator = $validator;\n        $this->contextPersister = $contextPersister;\n        $this->requestContextResolver = $requestContextResolver;\n        $this->contextService = $contextService;\n        $this->eventDispatcher = $eventDispatcher;\n        $this->adminOrderCartService = $adminOrderCartService;\n        $this->orderRoute = $orderRoute;\n        $this->cartService = $cartService;\n        $this->connection = $connection;\n    }\n\n    /**\n     * @Since(\"6.2.0.0\")\n     * @Route(\"/api/_proxy/store-api/{salesChannelId}/{_path}\", name=\"api.proxy.store-api\", requirements={\"_path\" = \".*\"})\n     *\n     * @throws InvalidSalesChannelIdException\n     * @throws InconsistentCriteriaIdsException\n     */\n    public function proxy(string $_path, string $salesChannelId, Request $request, Context $context): Response\n    {\n        $salesChannel = $this->fetchSalesChannel($salesChannelId, $context);\n\n        $salesChannelApiRequest = $this->setUpSalesChannelApiRequest($_path, $salesChannelId, $request, $salesChannel);\n\n        return $this->wrapInSalesChannelApiRoute($salesChannelApiRequest, function () use ($salesChannelApiRequest): Response {\n            return $this->kernel->handle($salesChannelApiRequest, HttpKernelInterface::SUB_REQUEST);\n        });\n    }\n\n    /**\n     * @Since(\"6.3.4.0\")\n     * @Route(\"/api/_proxy-order/{salesChannelId}\", name=\"api.proxy-order.create\")\n     *\n     * @throws InvalidSalesChannelIdException\n     * @throws InconsistentCriteriaIdsException\n     */\n    public function proxyCreateOrder(string $salesChannelId, Request $request, Context $context, RequestDataBag $data): Response\n    {\n        $this->fetchSalesChannel($salesChannelId, $context);\n\n        $salesChannelContext = $this->fetchSalesChannelContext($salesChannelId, $request, $context);\n\n        $cart = $this->cartService->getCart($salesChannelContext->getToken(), $salesChannelContext);\n\n        $order = $this->orderRoute->order($cart, $salesChannelContext, $data)->getOrder();\n\n        $orderId = $order->getId();\n        $userId = $context->getSource() instanceof AdminApiSource ? $context->getSource()->getUserId() : null;\n        $userId = $userId ? Uuid::fromHexToBytes($userId) : null;\n\n        $context->scope(Context::SYSTEM_SCOPE, function () use ($orderId, $userId): void {\n            $this->connection->executeUpdate(\n                'UPDATE `order` SET `created_by_id` = :createdById WHERE `id` = :id',\n                ['createdById' => $userId, 'id' => Uuid::fromHexToBytes($orderId)]\n            );\n        });\n\n        return new JsonResponse($order);\n    }\n\n    /**\n     * @Since(\"6.2.0.0\")\n     * @Route(\"/api/_proxy/switch-customer\", name=\"api.proxy.switch-customer\", methods={\"PATCH\"})\n     * @Acl({\"api_proxy_switch-customer\"})\n     *\n     * @throws InconsistentCriteriaIdsException\n     * @throws InvalidSalesChannelIdException\n     * @throws MissingRequestParameterException\n     */\n    public function assignCustomer(Request $request, Context $context): Response\n    {\n        if (!$request->request->has(self::SALES_CHANNEL_ID)) {\n            throw new MissingRequestParameterException(self::SALES_CHANNEL_ID);\n        }\n\n        $salesChannelId = (string) $request->request->get('salesChannelId');\n\n        if (!$request->request->has(self::CUSTOMER_ID)) {\n            throw new MissingRequestParameterException(self::CUSTOMER_ID);\n        }\n\n        $this->fetchSalesChannel($salesChannelId, $context);\n\n        $salesChannelContext = $this->fetchSalesChannelContext($salesChannelId, $request, $context);\n\n        $this->persistPermissions($request, $salesChannelContext);\n\n        $this->updateCustomerToContext($request->get(self::CUSTOMER_ID), $salesChannelContext);\n\n        $content = json_encode([\n            PlatformRequest::HEADER_CONTEXT_TOKEN => $salesChannelContext->getToken(),\n        ], \\JSON_THROW_ON_ERROR);\n        $response = new Response();\n        $response->setContent($content ?: null);\n\n        return $response;\n    }\n\n    /**\n     * @Since(\"6.2.0.0\")\n     * @Route(\"/api/_proxy/modify-shipping-costs\", name=\"api.proxy.modify-shipping-costs\", methods={\"PATCH\"})\n     *\n     * @throws InconsistentCriteriaIdsException\n     * @throws InvalidSalesChannelIdException\n     * @throws MissingRequestParameterException\n     */\n    public function modifyShippingCosts(Request $request, Context $context): JsonResponse\n    {\n        if (!$request->request->has(self::SALES_CHANNEL_ID)) {\n            throw new MissingRequestParameterException(self::SALES_CHANNEL_ID);\n        }\n\n        $salesChannelId = (string) $request->request->get('salesChannelId');\n\n        $this->fetchSalesChannel($salesChannelId, $context);\n\n        $salesChannelContext = $this->fetchSalesChannelContext($salesChannelId, $request, $context);\n\n        $calculatedPrice = $this->parseCalculatedPriceByRequest($request);\n\n        $cart = $this->adminOrderCartService->updateShippingCosts($calculatedPrice, $salesChannelContext);\n\n        return new JsonResponse(['data' => $cart]);\n    }\n\n    /**\n     * @Since(\"6.2.0.0\")\n     * @Route(\"/api/_proxy/disable-automatic-promotions\", name=\"api.proxy.disable-automatic-promotions\", methods={\"PATCH\"})\n     */\n    public function disableAutomaticPromotions(Request $request): JsonResponse\n    {\n        if (!$request->request->has(self::SALES_CHANNEL_ID)) {\n            throw new MissingRequestParameterException(self::SALES_CHANNEL_ID);\n        }\n\n        $contextToken = $this->getContextToken($request);\n\n        $salesChannelId = (string) $request->request->get('salesChannelId');\n\n        $this->adminOrderCartService->addPermission($contextToken, PromotionCollector::SKIP_AUTOMATIC_PROMOTIONS, $salesChannelId);\n\n        return new JsonResponse();\n    }\n\n    /**\n     * @Since(\"6.2.0.0\")\n     * @Route(\"/api/_proxy/enable-automatic-promotions\", name=\"api.proxy.enable-automatic-promotions\", methods={\"PATCH\"})\n     */\n    public function enableAutomaticPromotions(Request $request): JsonResponse\n    {\n        if (!$request->request->has(self::SALES_CHANNEL_ID)) {\n            throw new MissingRequestParameterException(self::SALES_CHANNEL_ID);\n        }\n\n        $contextToken = $this->getContextToken($request);\n\n        $salesChannelId = (string) $request->request->get('salesChannelId');\n\n        $this->adminOrderCartService->deletePermission($contextToken, PromotionCollector::SKIP_AUTOMATIC_PROMOTIONS, $salesChannelId);\n\n        return new JsonResponse();\n    }\n\n    private function wrapInSalesChannelApiRoute(Request $request, callable $call): Response\n    {\n        /** @var RequestStack $requestStack */\n        $requestStack = $this->get('request_stack');\n\n        $requestStackBackup = $this->clearRequestStackWithBackup($requestStack);\n        $requestStack->push($request);\n\n        try {\n            return $call();\n        } finally {\n            $this->restoreRequestStack($requestStack, $requestStackBackup);\n        }\n    }\n\n    private function setUpSalesChannelApiRequest(string $path, string $salesChannelId, Request $request, SalesChannelEntity $salesChannel): Request\n    {\n        $contextToken = $this->getContextToken($request);\n\n        $server = array_merge($request->server->all(), ['REQUEST_URI' => '/store-api/' . $path]);\n        $subrequest = $request->duplicate(null, null, [], null, null, $server);\n\n        $subrequest->headers->set(PlatformRequest::HEADER_ACCESS_KEY, $salesChannel->getAccessKey());\n        $subrequest->headers->set(PlatformRequest::HEADER_CONTEXT_TOKEN, $contextToken);\n        $subrequest->attributes->set(PlatformRequest::ATTRIBUTE_OAUTH_CLIENT_ID, $salesChannel->getAccessKey());\n\n        $this->requestContextResolver->handleSalesChannelContext(\n            $subrequest,\n            $salesChannelId,\n            $contextToken\n        );\n\n        return $subrequest;\n    }\n\n    /**\n     * @throws InconsistentCriteriaIdsException\n     * @throws InvalidSalesChannelIdException\n     */\n    private function fetchSalesChannel(string $salesChannelId, Context $context): SalesChannelEntity\n    {\n        /** @var SalesChannelEntity|null $salesChannel */\n        $salesChannel = $this->salesChannelRepository->search(new Criteria([$salesChannelId]), $context)->get($salesChannelId);\n\n        if ($salesChannel === null) {\n            throw new InvalidSalesChannelIdException($salesChannelId);\n        }\n\n        return $salesChannel;\n    }\n\n    private function getContextToken(Request $request): string\n    {\n        $contextToken = $request->headers->get(PlatformRequest::HEADER_CONTEXT_TOKEN);\n\n        if ($contextToken === null) {\n            $contextToken = Random::getAlphanumericString(32);\n        }\n\n        return $contextToken;\n    }\n\n    private function clearRequestStackWithBackup(RequestStack $requestStack): array\n    {\n        $requestStackBackup = [];\n\n        while ($requestStack->getMainRequest()) {\n            $requestStackBackup[] = $requestStack->pop();\n        }\n\n        return $requestStackBackup;\n    }\n\n    private function restoreRequestStack(RequestStack $requestStack, array $requestStackBackup): void\n    {\n        $this->clearRequestStackWithBackup($requestStack);\n\n        foreach ($requestStackBackup as $backedUpRequest) {\n            $requestStack->push($backedUpRequest);\n        }\n    }\n\n    private function fetchSalesChannelContext(string $salesChannelId, Request $request, Context $originalContext): SalesChannelContext\n    {\n        $contextToken = $this->getContextToken($request);\n\n        $salesChannelContext = $this->contextService->get(\n            new SalesChannelContextServiceParameters(\n                $salesChannelId,\n                $contextToken,\n                $request->headers->get(PlatformRequest::HEADER_LANGUAGE_ID),\n                $request->attributes->get(SalesChannelRequest::ATTRIBUTE_DOMAIN_CURRENCY_ID),\n                null,\n                $originalContext\n            )\n        );\n\n        return $salesChannelContext;\n    }\n\n    private function updateCustomerToContext(string $customerId, SalesChannelContext $context): void\n    {\n        $data = new DataBag();\n        $data->set(self::CUSTOMER_ID, $customerId);\n\n        $definition = new DataValidationDefinition('context_switch');\n        $parameters = $data->only(\n            self::CUSTOMER_ID\n        );\n\n        $customerCriteria = new Criteria();\n        $customerCriteria->addFilter(new EqualsFilter('customer.id', $parameters[self::CUSTOMER_ID]));\n\n        $definition\n            ->add(self::CUSTOMER_ID, new EntityExists(['entity' => 'customer', 'context' => $context->getContext(), 'criteria' => $customerCriteria]))\n        ;\n\n        $this->validator->validate($parameters, $definition);\n\n        $isSwitchNewCustomer = true;\n        if ($context->getCustomer()) {\n            // Check if customer switch to another customer or not\n            $isSwitchNewCustomer = $context->getCustomer()->getId() !== $parameters[self::CUSTOMER_ID];\n        }\n\n        if (!$isSwitchNewCustomer) {\n            return;\n        }\n\n        $this->contextPersister->save(\n            $context->getToken(),\n            [\n                'customerId' => $parameters[self::CUSTOMER_ID],\n                'billingAddressId' => null,\n                'shippingAddressId' => null,\n                'shippingMethodId' => null,\n                'paymentMethodId' => null,\n                'languageId' => null,\n                'currencyId' => null,\n            ],\n            $context->getSalesChannel()->getId()\n        );\n        $event = new SalesChannelContextSwitchEvent($context, $data);\n        $this->eventDispatcher->dispatch($event);\n    }\n\n    private function persistPermissions(Request $request, SalesChannelContext $salesChannelContext): void\n    {\n        $contextToken = $salesChannelContext->getToken();\n\n        $salesChannelId = $salesChannelContext->getSalesChannelId();\n\n        $payload = $this->contextPersister->load($contextToken, $salesChannelId);\n        $requestPermissions = $request->get(SalesChannelContextService::PERMISSIONS);\n\n        if (\\in_array(SalesChannelContextService::PERMISSIONS, $payload, true) && !$requestPermissions) {\n            return;\n        }\n\n        $payload[SalesChannelContextService::PERMISSIONS] = $requestPermissions\n            ? \\array_fill_keys($requestPermissions, true)\n            : [self::ADMIN_ORDER_PERMISSIONS];\n\n        $this->contextPersister->save($contextToken, $payload, $salesChannelId);\n    }\n\n    private function parseCalculatedPriceByRequest(Request $request): CalculatedPrice\n    {\n        $this->validateShippingCostsParameters($request);\n\n        $shippingCosts = $request->get('shippingCosts');\n\n        return new CalculatedPrice($shippingCosts['unitPrice'], $shippingCosts['totalPrice'], new CalculatedTaxCollection(), new TaxRuleCollection());\n    }\n\n    private function validateShippingCostsParameters(Request $request): void\n    {\n        if (!$request->request->has('shippingCosts')) {\n            throw new MissingRequestParameterException('shippingCosts');\n        }\n\n        $validation = new DataValidationDefinition('shipping-cost');\n        $validation->add('unitPrice', new NotBlank(), new Type('numeric'), new GreaterThanOrEqual(['value' => 0]));\n        $validation->add('totalPrice', new NotBlank(), new Type('numeric'), new GreaterThanOrEqual(['value' => 0]));\n        $this->validator->validate($request->request->all('shippingCosts'), $validation);\n    }\n}\n", "<?php declare(strict_types=1);\n\nnamespace Shopware\\Core\\System\\SalesChannel\\Context;\n\nuse Shopware\\Core\\Checkout\\Cart\\Cart;\nuse Shopware\\Core\\Checkout\\Cart\\CartRuleLoader;\nuse Shopware\\Core\\Checkout\\Cart\\Error\\ErrorCollection;\nuse Shopware\\Core\\Checkout\\Cart\\Event\\CartMergedEvent;\nuse Shopware\\Core\\Checkout\\Cart\\LineItem\\LineItem;\nuse Shopware\\Core\\Checkout\\Cart\\SalesChannel\\CartService;\nuse Shopware\\Core\\System\\SalesChannel\\Event\\SalesChannelContextRestoredEvent;\nuse Shopware\\Core\\System\\SalesChannel\\SalesChannelContext;\nuse Symfony\\Contracts\\EventDispatcher\\EventDispatcherInterface;\n\nclass CartRestorer\n{\n    private AbstractSalesChannelContextFactory $factory;\n\n    private SalesChannelContextPersister $contextPersister;\n\n    private CartService $cartService;\n\n    private EventDispatcherInterface $eventDispatcher;\n\n    private CartRuleLoader $cartRuleLoader;\n\n    public function __construct(\n        AbstractSalesChannelContextFactory $factory,\n        SalesChannelContextPersister $contextPersister,\n        CartService $cartService,\n        CartRuleLoader $cartRuleLoader,\n        EventDispatcherInterface $eventDispatcher\n    ) {\n        $this->factory = $factory;\n        $this->contextPersister = $contextPersister;\n        $this->cartService = $cartService;\n        $this->cartRuleLoader = $cartRuleLoader;\n        $this->eventDispatcher = $eventDispatcher;\n    }\n\n    public function restore(string $customerId, SalesChannelContext $currentContext): SalesChannelContext\n    {\n        $customerPayload = $this->contextPersister->load(\n            $currentContext->getToken(),\n            $currentContext->getSalesChannel()->getId(),\n            $customerId\n        );\n\n        if (empty($customerPayload) || !($customerPayload['expired'] ?? false) && $customerPayload['token'] === $currentContext->getToken()) {\n            return $this->replaceContextToken($customerId, $currentContext);\n        }\n\n        $customerContext = $this->factory->create($customerPayload['token'], $currentContext->getSalesChannel()->getId(), $customerPayload);\n        if ($customerPayload['expired'] ?? false) {\n            $customerContext = $this->replaceContextToken($customerId, $customerContext);\n        }\n\n        $guestCart = $this->cartService->getCart($currentContext->getToken(), $currentContext);\n        $customerCart = $this->cartService->getCart($customerContext->getToken(), $customerContext);\n\n        if ($guestCart->getLineItems()->count() > 0) {\n            $restoredCart = $this->mergeCart($customerCart, $guestCart, $customerContext);\n        } else {\n            $restoredCart = $this->cartService->recalculate($customerCart, $customerContext);\n        }\n\n        $restoredCart->addErrors(...array_values($guestCart->getErrors()->getPersistent()->getElements()));\n\n        $this->deleteGuestContext($currentContext);\n\n        $errors = $restoredCart->getErrors();\n        $result = $this->cartRuleLoader->loadByToken($customerContext, $restoredCart->getToken());\n\n        $cartWithErrors = $result->getCart();\n        $cartWithErrors->setErrors($errors);\n        $this->cartService->setCart($cartWithErrors);\n\n        $this->eventDispatcher->dispatch(new SalesChannelContextRestoredEvent($customerContext));\n\n        return $customerContext;\n    }\n\n    private function mergeCart(Cart $customerCart, Cart $guestCart, SalesChannelContext $customerContext): Cart\n    {\n        $mergeableLineItems = $guestCart->getLineItems()->filter(function (LineItem $item) use ($customerCart) {\n            return ($item->getQuantity() > 0 && $item->isStackable()) || !$customerCart->has($item->getId());\n        });\n\n        $errors = $customerCart->getErrors();\n        $customerCart->setErrors(new ErrorCollection());\n\n        $customerCartClone = clone $customerCart;\n        $customerCart->setErrors($errors);\n        $customerCartClone->setErrors($errors);\n\n        $mergedCart = $this->cartService->add($customerCart, $mergeableLineItems->getElements(), $customerContext);\n\n        $this->eventDispatcher->dispatch(new CartMergedEvent($mergedCart, $customerContext, $customerCartClone));\n\n        return $mergedCart;\n    }\n\n    private function replaceContextToken(string $customerId, SalesChannelContext $currentContext): SalesChannelContext\n    {\n        $newToken = $this->contextPersister->replace($currentContext->getToken(), $currentContext);\n\n        $currentContext->assign([\n            'token' => $newToken,\n        ]);\n\n        $this->contextPersister->save(\n            $newToken,\n            [\n                'customerId' => $customerId,\n                'billingAddressId' => null,\n                'shippingAddressId' => null,\n            ],\n            $currentContext->getSalesChannel()->getId(),\n            $customerId\n        );\n\n        return $currentContext;\n    }\n\n    private function deleteGuestContext(SalesChannelContext $guestContext): void\n    {\n        $this->cartService->deleteCart($guestContext);\n        $this->contextPersister->delete($guestContext->getToken());\n    }\n}\n", "<?php declare(strict_types=1);\n\nnamespace Shopware\\Core\\System\\SalesChannel\\Context;\n\nuse Doctrine\\DBAL\\Connection;\nuse Doctrine\\DBAL\\Driver\\ResultStatement;\nuse Shopware\\Core\\Defaults;\nuse Shopware\\Core\\Framework\\Util\\Random;\nuse Shopware\\Core\\Framework\\Uuid\\Uuid;\nuse Shopware\\Core\\System\\SalesChannel\\Event\\SalesChannelContextTokenChangeEvent;\nuse Shopware\\Core\\System\\SalesChannel\\SalesChannelContext;\nuse Symfony\\Contracts\\EventDispatcher\\EventDispatcherInterface;\n\nclass SalesChannelContextPersister\n{\n    /**\n     * @var Connection\n     */\n    private $connection;\n\n    private EventDispatcherInterface $eventDispatcher;\n\n    /**\n     * @var string\n     */\n    private $lifetimeInterval;\n\n    public function __construct(Connection $connection, EventDispatcherInterface $eventDispatcher, ?string $lifetimeInterval = 'P1D')\n    {\n        $this->connection = $connection;\n        $this->eventDispatcher = $eventDispatcher;\n        $this->lifetimeInterval = $lifetimeInterval ?? 'P1D';\n    }\n\n    public function save(string $token, array $parameters, string $salesChannelId, ?string $customerId = null): void\n    {\n        $existing = $this->load($token, $salesChannelId, $customerId);\n\n        $parameters = array_replace_recursive($existing, $parameters);\n\n        unset($parameters['token']);\n\n        $this->connection->executeUpdate(\n            'REPLACE INTO sales_channel_api_context (`token`, `payload`, `sales_channel_id`, `customer_id`, `updated_at`)\n                VALUES (:token, :payload, :salesChannelId, :customerId, :updatedAt)',\n            [\n                'token' => $token,\n                'payload' => json_encode($parameters),\n                'salesChannelId' => $salesChannelId ? Uuid::fromHexToBytes($salesChannelId) : null,\n                'customerId' => $customerId ? Uuid::fromHexToBytes($customerId) : null,\n                'updatedAt' => (new \\DateTimeImmutable())->format(Defaults::STORAGE_DATE_TIME_FORMAT),\n            ]\n        );\n    }\n\n    public function delete(string $token): void\n    {\n        $this->connection->executeUpdate(\n            'DELETE FROM sales_channel_api_context WHERE token = :token',\n            [\n                'token' => $token,\n            ]\n        );\n    }\n\n    public function replace(string $oldToken, SalesChannelContext $context): string\n    {\n        $newToken = Random::getAlphanumericString(32);\n\n        $affected = $this->connection->executeUpdate(\n            'UPDATE `sales_channel_api_context`\n                   SET `token` = :newToken,\n                       `updated_at` = :updatedAt\n                   WHERE `token` = :oldToken',\n            [\n                'newToken' => $newToken,\n                'oldToken' => $oldToken,\n                'updatedAt' => (new \\DateTimeImmutable())->format(Defaults::STORAGE_DATE_TIME_FORMAT),\n            ]\n        );\n\n        if ($affected === 0) {\n            $customer = $context->getCustomer();\n\n            $this->connection->insert('sales_channel_api_context', [\n                'token' => $newToken,\n                'payload' => json_encode([]),\n                'sales_channel_id' => Uuid::fromHexToBytes($context->getSalesChannel()->getId()),\n                'customer_id' => $customer ? Uuid::fromHexToBytes($customer->getId()) : null,\n                'updated_at' => (new \\DateTimeImmutable())->format(Defaults::STORAGE_DATE_TIME_FORMAT),\n            ]);\n        }\n\n        $this->connection->executeUpdate(\n            'UPDATE `cart`\n                   SET `token` = :newToken\n                   WHERE `token` = :oldToken',\n            [\n                'newToken' => $newToken,\n                'oldToken' => $oldToken,\n            ]\n        );\n\n        $context->assign(['token' => $newToken]);\n        $this->eventDispatcher->dispatch(new SalesChannelContextTokenChangeEvent($context, $oldToken, $newToken));\n\n        return $newToken;\n    }\n\n    public function load(string $token, string $salesChannelId, ?string $customerId = null): array\n    {\n        $qb = $this->connection->createQueryBuilder();\n\n        $qb->select('*');\n        $qb->from('sales_channel_api_context');\n\n        $qb->where('sales_channel_id = :salesChannelId');\n        $qb->setParameter(':salesChannelId', Uuid::fromHexToBytes($salesChannelId));\n\n        if ($customerId !== null) {\n            $qb->andWhere('token = :token OR customer_id = :customerId');\n            $qb->setParameter(':token', $token);\n            $qb->setParameter(':customerId', Uuid::fromHexToBytes($customerId));\n            $qb->setMaxResults(2);\n        } else {\n            $qb->andWhere('token = :token');\n            $qb->setParameter(':token', $token);\n            $qb->setMaxResults(1);\n        }\n\n        /** @var ResultStatement $statement */\n        $statement = $qb->execute();\n\n        if (!$statement instanceof ResultStatement) {\n            return [];\n        }\n\n        $data = $statement->fetchAll();\n\n        if (empty($data)) {\n            return [];\n        }\n\n        $customerContext = $salesChannelId && $customerId ? $this->getCustomerContext($data, $salesChannelId, $customerId) : null;\n\n        $context = $customerContext ?? array_shift($data);\n\n        $updatedAt = new \\DateTimeImmutable($context['updated_at']);\n        $expiredTime = $updatedAt->add(new \\DateInterval($this->lifetimeInterval));\n\n        $payload = array_filter(json_decode($context['payload'], true));\n        $now = new \\DateTimeImmutable();\n        $payload['expired'] = $expiredTime < $now;\n\n        if ($customerId) {\n            $payload['token'] = $context['token'];\n        }\n\n        return $payload;\n    }\n\n    public function revokeAllCustomerTokens(string $customerId, string ...$preserveTokens): void\n    {\n        $revokeParams = [\n            'customerId' => null,\n            'billingAddressId' => null,\n            'shippingAddressId' => null,\n        ];\n\n        $qb = $this->connection->createQueryBuilder();\n        $qb\n            ->update('sales_channel_api_context')\n            ->set('payload', ':payload')\n            ->set('customer_id', 'NULL')\n            ->set('updated_at', ':updatedAt')\n            ->where('customer_id = :customerId')\n            ->setParameter('updatedAt', (new \\DateTime())->format(Defaults::STORAGE_DATE_TIME_FORMAT))\n            ->setParameter(':payload', json_encode($revokeParams))\n            ->setParameter(':customerId', Uuid::fromHexToBytes($customerId));\n\n        // keep tokens valid, which are given in $preserveTokens\n        if ($preserveTokens) {\n            $qb\n                ->andWhere($qb->expr()->notIn('token', ':preserveTokens'))\n                ->setParameter(':preserveTokens', $preserveTokens, Connection::PARAM_STR_ARRAY);\n        }\n\n        $qb->execute();\n    }\n\n    private function getCustomerContext(array $data, string $salesChannelId, string $customerId): ?array\n    {\n        foreach ($data as $row) {\n            if (!empty($row['customer_id'])\n                && Uuid::fromBytesToHex($row['sales_channel_id']) === $salesChannelId\n                && Uuid::fromBytesToHex($row['customer_id']) === $customerId\n            ) {\n                return $row;\n            }\n        }\n\n        return null;\n    }\n}\n", "<?php declare(strict_types=1);\n\nnamespace Shopware\\Core\\System\\Test\\SalesChannel\\Context;\n\nuse Doctrine\\DBAL\\Connection;\nuse PHPUnit\\Framework\\TestCase;\nuse Shopware\\Core\\Checkout\\Cart\\Cart;\nuse Shopware\\Core\\Checkout\\Cart\\CartPersister;\nuse Shopware\\Core\\Checkout\\Cart\\CartRuleLoader;\nuse Shopware\\Core\\Checkout\\Cart\\Event\\CartMergedEvent;\nuse Shopware\\Core\\Checkout\\Cart\\LineItem\\LineItem;\nuse Shopware\\Core\\Checkout\\Cart\\LineItem\\LineItemCollection;\nuse Shopware\\Core\\Checkout\\Cart\\SalesChannel\\CartService;\nuse Shopware\\Core\\Checkout\\Customer\\CustomerEntity;\nuse Shopware\\Core\\Checkout\\Payment\\Cart\\PaymentHandler\\PrePayment;\nuse Shopware\\Core\\Content\\Product\\Aggregate\\ProductVisibility\\ProductVisibilityDefinition;\nuse Shopware\\Core\\Defaults;\nuse Shopware\\Core\\Framework\\Context;\nuse Shopware\\Core\\Framework\\DataAbstractionLayer\\EntityRepositoryInterface;\nuse Shopware\\Core\\Framework\\DataAbstractionLayer\\Search\\Criteria;\nuse Shopware\\Core\\Framework\\DataAbstractionLayer\\Search\\Filter\\EqualsFilter;\nuse Shopware\\Core\\Framework\\Feature;\nuse Shopware\\Core\\Framework\\Test\\TestCaseBase\\IntegrationTestBehaviour;\nuse Shopware\\Core\\Framework\\Util\\Random;\nuse Shopware\\Core\\Framework\\Uuid\\Uuid;\nuse Shopware\\Core\\System\\SalesChannel\\Context\\AbstractSalesChannelContextFactory;\nuse Shopware\\Core\\System\\SalesChannel\\Context\\CartRestorer;\nuse Shopware\\Core\\System\\SalesChannel\\Context\\SalesChannelContextFactory;\nuse Shopware\\Core\\System\\SalesChannel\\Context\\SalesChannelContextPersister;\nuse Shopware\\Core\\System\\SalesChannel\\Context\\SalesChannelContextService;\nuse Shopware\\Core\\System\\SalesChannel\\Event\\SalesChannelContextRestoredEvent;\nuse Shopware\\Core\\System\\SalesChannel\\SalesChannelContext;\nuse Shopware\\Core\\Test\\TestDefaults;\nuse Symfony\\Component\\EventDispatcher\\EventDispatcher;\nuse Symfony\\Contracts\\EventDispatcher\\Event;\n\nclass CartRestorerTest extends TestCase\n{\n    use IntegrationTestBehaviour;\n\n    /**\n     * @var Connection\n     */\n    private $connection;\n\n    /**\n     * @var CartRestorer\n     */\n    private $cartRestorer;\n\n    /**\n     * @var CartService\n     */\n    private $cartService;\n\n    /**\n     * @var array\n     */\n    private $events;\n\n    /**\n     * @var \\Closure\n     */\n    private $callbackFn;\n\n    /**\n     * @var EventDispatcher\n     */\n    private $eventDispatcher;\n\n    /**\n     * @var SalesChannelContextPersister\n     */\n    private $contextPersister;\n\n    /**\n     * @var string\n     */\n    private $customerId;\n\n    public function setUp(): void\n    {\n        $this->connection = $this->getContainer()->get(Connection::class);\n        $this->cartService = $this->getContainer()->get(CartService::class);\n\n        $this->eventDispatcher = $this->getContainer()->get('event_dispatcher');\n\n        $this->events = [];\n\n        $this->callbackFn = function (Event $event): void {\n            $this->events[\\get_class($event)] = $event;\n        };\n\n        $this->contextPersister = $this->getContainer()->get(SalesChannelContextPersister::class);\n        /** @var AbstractSalesChannelContextFactory $contextFactory */\n        $contextFactory = $this->getContainer()->get(SalesChannelContextFactory::class);\n        $cartRuleLoader = $this->getContainer()->get(CartRuleLoader::class);\n\n        $this->customerId = $this->createCustomer()->getId();\n\n        $this->cartRestorer = new CartRestorer(\n            $contextFactory,\n            $this->contextPersister,\n            $this->cartService,\n            $cartRuleLoader,\n            $this->eventDispatcher\n        );\n    }\n\n    public function testRestore(): void\n    {\n        $expectedToken = Uuid::randomHex();\n        $expectedContext = $this->createSalesChannelContext($expectedToken, []);\n\n        $currentContext = $this->createSalesChannelContext('currentToken', [], $this->customerId);\n\n        $this->contextPersister->save($expectedContext->getToken(), [], $currentContext->getSalesChannel()->getId(), $this->customerId);\n\n        $this->eventDispatcher->addListener(SalesChannelContextRestoredEvent::class, $this->callbackFn);\n\n        $restoredContext = $this->cartRestorer->restore($this->customerId, $currentContext);\n\n        static::assertSame($expectedContext->getToken(), $restoredContext->getToken());\n\n        static::assertArrayHasKey(SalesChannelContextRestoredEvent::class, $this->events);\n        $salesChannelRestoredEvent = $this->events[SalesChannelContextRestoredEvent::class];\n        static::assertInstanceOf(SalesChannelContextRestoredEvent::class, $salesChannelRestoredEvent);\n    }\n\n    public function testGuestContextAndCartAreDeleted(): void\n    {\n        $currentContextToken = Random::getAlphanumericString(32);\n\n        $currentContext = $this->createSalesChannelContext($currentContextToken, []);\n\n        $this->contextPersister->save($currentContextToken, [], $currentContext->getSalesChannel()->getId(), $this->customerId);\n\n        $cart = new Cart('test', $currentContextToken);\n\n        $cart->add(new LineItem(Uuid::randomHex(), LineItem::CUSTOM_LINE_ITEM_TYPE));\n        $this->getContainer()->get(CartPersister::class)->save($cart, $currentContext);\n\n        static::assertTrue($this->cartExists($currentContextToken));\n        static::assertTrue($this->contextExists($currentContextToken));\n\n        $newContext = $this->cartRestorer->restore($this->customerId, $currentContext);\n\n        static::assertTrue($this->cartExists($newContext->getToken()));\n        static::assertTrue($this->contextExists($newContext->getToken()));\n\n        static::assertFalse($this->cartExists($currentContextToken));\n        static::assertFalse($this->contextExists($currentContextToken));\n    }\n\n    public function testCartIsRecalculated(): void\n    {\n        $customerContextToken = Random::getAlphanumericString(32);\n\n        $customerContext = $this->createSalesChannelContext($customerContextToken, []);\n\n        $this->contextPersister->save($customerContextToken, [], $customerContext->getSalesChannel()->getId(), $this->customerId);\n\n        $cart = new Cart('test', $customerContextToken);\n\n        $productId = $this->createProduct($customerContext->getContext());\n\n        $productLineItem = new LineItem(Uuid::randomHex(), LineItem::PRODUCT_LINE_ITEM_TYPE, $productId);\n        $productLineItem->setStackable(true);\n        $productLineItem->setQuantity(1);\n\n        $cart->add($productLineItem);\n        $cart->markUnmodified();\n\n        static::assertCount(1, $cart->getLineItems());\n        $this->getContainer()->get(CartPersister::class)->save($cart, $customerContext);\n\n        $this->getContainer()->get('product.repository')->delete([[\n            'id' => $productId,\n        ]], $customerContext->getContext());\n\n        $guestContext = $this->createSalesChannelContext('123123', []);\n\n        $restoreContext = $this->cartRestorer->restore($this->customerId, $guestContext);\n\n        $restoreCart = $this->cartService->getCart($restoreContext->getToken(), $restoreContext);\n\n        static::assertFalse($restoreCart->isModified());\n        // Delete product will removed from cart as result from recalculation\n        static::assertCount(0, $restoreCart->getLineItems());\n    }\n\n    public function testCartIsMergedAndRecalculatedWithTheSavedOne(): void\n    {\n        $currentContextToken = Random::getAlphanumericString(32);\n\n        $currentContext = $this->createSalesChannelContext($currentContextToken, []);\n\n        // Create Guest cart\n        $cart = new Cart('guest-cart', $currentContextToken);\n\n        $productId1 = $this->createProduct($currentContext->getContext());\n        $productId2 = $this->createProduct($currentContext->getContext());\n\n        $productLineItem1 = new LineItem($productId1, LineItem::PRODUCT_LINE_ITEM_TYPE, $productId1);\n        $productLineItem2 = new LineItem($productId2, LineItem::PRODUCT_LINE_ITEM_TYPE, $productId2);\n        $productLineItem1->setStackable(true);\n        $productLineItem2->setStackable(true);\n        $productLineItem1->setQuantity(1);\n        $guestProductQuantity = 5;\n        $productLineItem2->setQuantity($guestProductQuantity);\n\n        $cart->addLineItems(new LineItemCollection([$productLineItem1, $productLineItem2]));\n        $cart->markUnmodified();\n\n        $this->getContainer()->get(CartPersister::class)->save($cart, $currentContext);\n\n        // Create Saved Customer cart\n        $customerToken = Random::getAlphanumericString(32);\n        $customerContext = $this->createSalesChannelContext($customerToken, []);\n\n        $this->contextPersister->save($customerToken, [], $currentContext->getSalesChannel()->getId(), $this->customerId);\n\n        $cart = new Cart('customer-cart', $customerToken);\n\n        $savedLineItem = new LineItem($productId2, LineItem::PRODUCT_LINE_ITEM_TYPE, $productId2);\n        $savedLineItemQuantity = 4;\n        $savedLineItem->setStackable(true);\n        $savedLineItem->setQuantity($savedLineItemQuantity);\n\n        $productId3 = $this->createProduct($customerContext->getContext());\n        $productLineItem3 = new LineItem($productId3, LineItem::PRODUCT_LINE_ITEM_TYPE, $productId3);\n        $productLineItem3->setStackable(true);\n        $productLineItem3->setQuantity(3);\n\n        $cart->addLineItems(new LineItemCollection([$savedLineItem, $productLineItem3]));\n        $cart->markUnmodified();\n\n        $this->getContainer()->get(CartPersister::class)->save($cart, $customerContext);\n\n        // Delete 1 saved item\n        $this->getContainer()->get('product.repository')->delete([[\n            'id' => $productId3,\n        ]], $customerContext->getContext());\n\n        $this->eventDispatcher->addListener(CartMergedEvent::class, $this->callbackFn);\n\n        $restoreContext = $this->cartRestorer->restore($this->customerId, $currentContext);\n\n        $restoreCart = $this->cartService->getCart($restoreContext->getToken(), $restoreContext);\n\n        static::assertFalse($restoreCart->isModified());\n        // Delete product will removed from cart as result from recalculation\n        static::assertEmpty($restoreCart->getLineItems()->get($productId3));\n\n        static::assertArrayHasKey(CartMergedEvent::class, $this->events);\n        $cartMergedEvent = $this->events[CartMergedEvent::class];\n        static::assertInstanceOf(CartMergedEvent::class, $cartMergedEvent);\n\n        static::assertEquals(1, $cartMergedEvent->getPreviousCart()->getLineItems()->count());\n        static::assertEquals($cartMergedEvent->getCart()->getName(), $cartMergedEvent->getPreviousCart()->getName());\n        static::assertEquals($cartMergedEvent->getCart()->getToken(), $cartMergedEvent->getPreviousCart()->getToken());\n\n        static::assertNotEmpty($p1 = $restoreCart->getLineItems()->get($productId1));\n        static::assertEquals(1, $p1->getQuantity());\n        static::assertNotEmpty($savedItem = $restoreCart->getLineItems()->get($savedLineItem->getId()));\n        static::assertEquals($savedLineItemQuantity + $guestProductQuantity, $savedItem->getQuantity());\n    }\n\n    public function testCartMergedEventIsFiredWithCustomerCart(): void\n    {\n        Feature::skipTestIfInActive('FEATURE_NEXT_16824', $this);\n\n        $currentContextToken = Random::getAlphanumericString(32);\n\n        $currentContext = $this->createSalesChannelContext($currentContextToken, []);\n\n        // Create Guest cart\n        $cart = new Cart('guest-cart', $currentContextToken);\n\n        $productId1 = $this->createProduct($currentContext->getContext());\n        $productId2 = $this->createProduct($currentContext->getContext());\n\n        $productLineItem1 = new LineItem($productId1, LineItem::PRODUCT_LINE_ITEM_TYPE, $productId1);\n        $productLineItem2 = new LineItem($productId2, LineItem::PRODUCT_LINE_ITEM_TYPE, $productId2);\n        $productLineItem1->setStackable(true);\n        $productLineItem2->setStackable(true);\n        $productLineItem1->setQuantity(1);\n        $guestProductQuantity = 5;\n        $productLineItem2->setQuantity($guestProductQuantity);\n\n        $cart->addLineItems(new LineItemCollection([$productLineItem1, $productLineItem2]));\n        $cart->markUnmodified();\n\n        $this->getContainer()->get(CartPersister::class)->save($cart, $currentContext);\n\n        // Create Saved Customer cart\n        $customerToken = Random::getAlphanumericString(32);\n        $customerContext = $this->createSalesChannelContext($customerToken, []);\n\n        $this->contextPersister->save($customerToken, [], $currentContext->getSalesChannel()->getId(), $this->customerId);\n\n        $cart = new Cart('customer-cart', $customerToken);\n\n        $this->getContainer()->get(CartPersister::class)->save($cart, $customerContext);\n\n        $this->eventDispatcher->addListener(CartMergedEvent::class, $this->callbackFn);\n\n        $restoreContext = $this->cartRestorer->restore($this->customerId, $currentContext);\n\n        $restoreCart = $this->cartService->getCart($restoreContext->getToken(), $restoreContext);\n\n        static::assertFalse($restoreCart->isModified());\n        static::assertArrayHasKey(CartMergedEvent::class, $this->events);\n\n        /** @var CartMergedEvent $event */\n        $event = $this->events[CartMergedEvent::class];\n\n        static::assertEquals(0, $event->getPreviousCart()->getLineItems()->count());\n        static::assertEquals($event->getCart()->getName(), $event->getPreviousCart()->getName());\n        static::assertEquals($event->getCart()->getToken(), $event->getPreviousCart()->getToken());\n\n        static::assertNotEmpty($p1 = $restoreCart->getLineItems()->get($productId1));\n        static::assertEquals(1, $p1->getQuantity());\n        static::assertNotEmpty($p2 = $restoreCart->getLineItems()->get($productId2));\n        static::assertEquals(5, $p2->getQuantity());\n    }\n\n    private function getStateId(string $state, string $machine)\n    {\n        return $this->getContainer()->get(Connection::class)\n            ->fetchColumn('\n                SELECT LOWER(HEX(state_machine_state.id))\n                FROM state_machine_state\n                    INNER JOIN  state_machine\n                    ON state_machine.id = state_machine_state.state_machine_id\n                    AND state_machine.technical_name = :machine\n                WHERE state_machine_state.technical_name = :state\n            ', [\n                'state' => $state,\n                'machine' => $machine,\n            ]);\n    }\n\n    private function getPrePaymentMethodId(): string\n    {\n        /** @var EntityRepositoryInterface $repository */\n        $repository = $this->getContainer()->get('payment_method.repository');\n\n        $criteria = (new Criteria())\n            ->setLimit(1)\n            ->addFilter(new EqualsFilter('active', true))\n            ->addFilter(new EqualsFilter('handlerIdentifier', PrePayment::class));\n\n        return $repository->searchIds($criteria, Context::createDefaultContext())->getIds()[0];\n    }\n\n    private function createProduct(Context $context): string\n    {\n        $productId = Uuid::randomHex();\n\n        $productNumber = Uuid::randomHex();\n        $data = [\n            'id' => $productId,\n            'productNumber' => $productNumber,\n            'stock' => 1,\n            'name' => 'Test Product',\n            'price' => [['currencyId' => Defaults::CURRENCY, 'gross' => 10.99, 'net' => 11.99, 'linked' => false]],\n            'manufacturer' => ['name' => 'create'],\n            'taxId' => $this->getValidTaxId(),\n            'active' => true,\n            'visibilities' => [\n                ['salesChannelId' => TestDefaults::SALES_CHANNEL, 'visibility' => ProductVisibilityDefinition::VISIBILITY_ALL],\n            ],\n        ];\n        $this->getContainer()->get('product.repository')->create([$data], $context);\n\n        return $productId;\n    }\n\n    private function createSalesChannelContext(string $contextToken, array $salesChannelData, ?string $customerId = null): SalesChannelContext\n    {\n        if ($customerId) {\n            $salesChannelData[SalesChannelContextService::CUSTOMER_ID] = $customerId;\n        }\n\n        return $this->getContainer()->get(SalesChannelContextFactory::class)->create(\n            $contextToken,\n            TestDefaults::SALES_CHANNEL,\n            $salesChannelData\n        );\n    }\n\n    private function cartExists(string $token): bool\n    {\n        $result = (int) $this->connection->executeQuery(\n            'SELECT COUNT(*) FROM cart WHERE `token` = :token',\n            [\n                'token' => $token,\n            ]\n        )->fetchColumn();\n\n        return $result > 0;\n    }\n\n    private function contextExists(string $token): bool\n    {\n        $result = (int) $this->connection->executeQuery(\n            'SELECT COUNT(*) FROM sales_channel_api_context WHERE `token` = :token',\n            [\n                'token' => $token,\n            ]\n        )->fetchColumn();\n\n        return $result > 0;\n    }\n\n    private function createCustomer(): CustomerEntity\n    {\n        $customerId = Uuid::randomHex();\n        $addressId = Uuid::randomHex();\n\n        $data = [\n            [\n                'id' => $customerId,\n                'salesChannelId' => TestDefaults::SALES_CHANNEL,\n                'defaultShippingAddress' => [\n                    'id' => $addressId,\n                    'firstName' => 'Max',\n                    'lastName' => 'Mustermann',\n                    'street' => 'Musterstra\u00dfe 1',\n                    'city' => 'Sch\u00f6ppingen',\n                    'zipcode' => '12345',\n                    'salutationId' => $this->getValidSalutationId(),\n                    'countryId' => $this->getValidCountryId(),\n                ],\n                'defaultBillingAddressId' => $addressId,\n                'defaultPaymentMethodId' => $this->getValidPaymentMethodId(),\n                'groupId' => TestDefaults::FALLBACK_CUSTOMER_GROUP,\n                'email' => 'foo@bar.de',\n                'password' => 'password',\n                'firstName' => 'Max',\n                'lastName' => 'Mustermann',\n                'salutationId' => $this->getValidSalutationId(),\n                'customerNumber' => '12345',\n            ],\n        ];\n\n        $repo = $this->getContainer()->get('customer.repository');\n\n        $repo->create($data, Context::createDefaultContext());\n\n        return $repo->search(new Criteria([$customerId]), Context::createDefaultContext())->first();\n    }\n}\n"], "fixing_code": ["<?php declare(strict_types=1);\n\nnamespace Shopware\\Core\\Framework\\Api\\Controller;\n\nuse Doctrine\\DBAL\\Connection;\nuse Shopware\\Core\\Checkout\\Cart\\ApiOrderCartService;\nuse Shopware\\Core\\Checkout\\Cart\\Price\\Struct\\CalculatedPrice;\nuse Shopware\\Core\\Checkout\\Cart\\Processor;\nuse Shopware\\Core\\Checkout\\Cart\\SalesChannel\\AbstractCartOrderRoute;\nuse Shopware\\Core\\Checkout\\Cart\\SalesChannel\\CartService;\nuse Shopware\\Core\\Checkout\\Cart\\Tax\\Struct\\CalculatedTaxCollection;\nuse Shopware\\Core\\Checkout\\Cart\\Tax\\Struct\\TaxRuleCollection;\nuse Shopware\\Core\\Checkout\\Promotion\\Cart\\PromotionCollector;\nuse Shopware\\Core\\Content\\Product\\Cart\\ProductCartProcessor;\nuse Shopware\\Core\\Framework\\Api\\Context\\AdminApiSource;\nuse Shopware\\Core\\Framework\\Api\\Exception\\InvalidSalesChannelIdException;\nuse Shopware\\Core\\Framework\\Context;\nuse Shopware\\Core\\Framework\\DataAbstractionLayer\\EntityRepositoryInterface;\nuse Shopware\\Core\\Framework\\DataAbstractionLayer\\Exception\\InconsistentCriteriaIdsException;\nuse Shopware\\Core\\Framework\\DataAbstractionLayer\\Search\\Criteria;\nuse Shopware\\Core\\Framework\\DataAbstractionLayer\\Search\\Filter\\EqualsFilter;\nuse Shopware\\Core\\Framework\\DataAbstractionLayer\\Validation\\EntityExists;\nuse Shopware\\Core\\Framework\\Routing\\Annotation\\Acl;\nuse Shopware\\Core\\Framework\\Routing\\Annotation\\RouteScope;\nuse Shopware\\Core\\Framework\\Routing\\Annotation\\Since;\nuse Shopware\\Core\\Framework\\Routing\\Exception\\MissingRequestParameterException;\nuse Shopware\\Core\\Framework\\Routing\\SalesChannelRequestContextResolver;\nuse Shopware\\Core\\Framework\\Util\\Random;\nuse Shopware\\Core\\Framework\\Uuid\\Uuid;\nuse Shopware\\Core\\Framework\\Validation\\DataBag\\DataBag;\nuse Shopware\\Core\\Framework\\Validation\\DataBag\\RequestDataBag;\nuse Shopware\\Core\\Framework\\Validation\\DataValidationDefinition;\nuse Shopware\\Core\\Framework\\Validation\\DataValidator;\nuse Shopware\\Core\\PlatformRequest;\nuse Shopware\\Core\\SalesChannelRequest;\nuse Shopware\\Core\\System\\SalesChannel\\Context\\SalesChannelContextPersister;\nuse Shopware\\Core\\System\\SalesChannel\\Context\\SalesChannelContextService;\nuse Shopware\\Core\\System\\SalesChannel\\Context\\SalesChannelContextServiceInterface;\nuse Shopware\\Core\\System\\SalesChannel\\Context\\SalesChannelContextServiceParameters;\nuse Shopware\\Core\\System\\SalesChannel\\Event\\SalesChannelContextSwitchEvent;\nuse Shopware\\Core\\System\\SalesChannel\\SalesChannelContext;\nuse Shopware\\Core\\System\\SalesChannel\\SalesChannelEntity;\nuse Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;\nuse Symfony\\Component\\EventDispatcher\\EventDispatcherInterface;\nuse Symfony\\Component\\HttpFoundation\\JsonResponse;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\RequestStack;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpKernel\\HttpKernelInterface;\nuse Symfony\\Component\\HttpKernel\\KernelInterface;\nuse Symfony\\Component\\Routing\\Annotation\\Route;\nuse Symfony\\Component\\Validator\\Constraints\\GreaterThanOrEqual;\nuse Symfony\\Component\\Validator\\Constraints\\NotBlank;\nuse Symfony\\Component\\Validator\\Constraints\\Type;\n\n/**\n * @RouteScope(scopes={\"api\"})\n */\nclass SalesChannelProxyController extends AbstractController\n{\n    private const CUSTOMER_ID = SalesChannelContextService::CUSTOMER_ID;\n\n    private const SALES_CHANNEL_ID = 'salesChannelId';\n\n    private const ADMIN_ORDER_PERMISSIONS = [\n        ProductCartProcessor::ALLOW_PRODUCT_PRICE_OVERWRITES => true,\n    ];\n\n    protected DataValidator $validator;\n\n    protected SalesChannelContextPersister $contextPersister;\n\n    protected Processor $processor;\n\n    private KernelInterface $kernel;\n\n    private EntityRepositoryInterface $salesChannelRepository;\n\n    private SalesChannelRequestContextResolver $requestContextResolver;\n\n    private EventDispatcherInterface $eventDispatcher;\n\n    private ApiOrderCartService $adminOrderCartService;\n\n    private SalesChannelContextServiceInterface $contextService;\n\n    private AbstractCartOrderRoute $orderRoute;\n\n    private CartService $cartService;\n\n    private Connection $connection;\n\n    public function __construct(\n        KernelInterface $kernel,\n        EntityRepositoryInterface $salesChannelRepository,\n        DataValidator $validator,\n        SalesChannelContextPersister $contextPersister,\n        SalesChannelRequestContextResolver $requestContextResolver,\n        SalesChannelContextServiceInterface $contextService,\n        EventDispatcherInterface $eventDispatcher,\n        ApiOrderCartService $adminOrderCartService,\n        AbstractCartOrderRoute $orderRoute,\n        CartService $cartService,\n        Connection $connection\n    ) {\n        $this->kernel = $kernel;\n        $this->salesChannelRepository = $salesChannelRepository;\n        $this->validator = $validator;\n        $this->contextPersister = $contextPersister;\n        $this->requestContextResolver = $requestContextResolver;\n        $this->contextService = $contextService;\n        $this->eventDispatcher = $eventDispatcher;\n        $this->adminOrderCartService = $adminOrderCartService;\n        $this->orderRoute = $orderRoute;\n        $this->cartService = $cartService;\n        $this->connection = $connection;\n    }\n\n    /**\n     * @Since(\"6.2.0.0\")\n     * @Route(\"/api/_proxy/store-api/{salesChannelId}/{_path}\", name=\"api.proxy.store-api\", requirements={\"_path\" = \".*\"})\n     *\n     * @throws InvalidSalesChannelIdException\n     * @throws InconsistentCriteriaIdsException\n     */\n    public function proxy(string $_path, string $salesChannelId, Request $request, Context $context): Response\n    {\n        $salesChannel = $this->fetchSalesChannel($salesChannelId, $context);\n\n        $salesChannelApiRequest = $this->setUpSalesChannelApiRequest($_path, $salesChannelId, $request, $salesChannel);\n\n        return $this->wrapInSalesChannelApiRoute($salesChannelApiRequest, function () use ($salesChannelApiRequest): Response {\n            return $this->kernel->handle($salesChannelApiRequest, HttpKernelInterface::SUB_REQUEST);\n        });\n    }\n\n    /**\n     * @Since(\"6.3.4.0\")\n     * @Route(\"/api/_proxy-order/{salesChannelId}\", name=\"api.proxy-order.create\")\n     *\n     * @throws InvalidSalesChannelIdException\n     * @throws InconsistentCriteriaIdsException\n     */\n    public function proxyCreateOrder(string $salesChannelId, Request $request, Context $context, RequestDataBag $data): Response\n    {\n        $this->fetchSalesChannel($salesChannelId, $context);\n\n        $salesChannelContext = $this->fetchSalesChannelContext($salesChannelId, $request, $context);\n\n        $cart = $this->cartService->getCart($salesChannelContext->getToken(), $salesChannelContext);\n\n        $order = $this->orderRoute->order($cart, $salesChannelContext, $data)->getOrder();\n\n        $orderId = $order->getId();\n        $userId = $context->getSource() instanceof AdminApiSource ? $context->getSource()->getUserId() : null;\n        $userId = $userId ? Uuid::fromHexToBytes($userId) : null;\n\n        $context->scope(Context::SYSTEM_SCOPE, function () use ($orderId, $userId): void {\n            $this->connection->executeUpdate(\n                'UPDATE `order` SET `created_by_id` = :createdById WHERE `id` = :id',\n                ['createdById' => $userId, 'id' => Uuid::fromHexToBytes($orderId)]\n            );\n        });\n\n        return new JsonResponse($order);\n    }\n\n    /**\n     * @Since(\"6.2.0.0\")\n     * @Route(\"/api/_proxy/switch-customer\", name=\"api.proxy.switch-customer\", methods={\"PATCH\"})\n     * @Acl({\"api_proxy_switch-customer\"})\n     *\n     * @throws InconsistentCriteriaIdsException\n     * @throws InvalidSalesChannelIdException\n     * @throws MissingRequestParameterException\n     */\n    public function assignCustomer(Request $request, Context $context): Response\n    {\n        if (!$request->request->has(self::SALES_CHANNEL_ID)) {\n            throw new MissingRequestParameterException(self::SALES_CHANNEL_ID);\n        }\n\n        $salesChannelId = (string) $request->request->get('salesChannelId');\n\n        if (!$request->request->has(self::CUSTOMER_ID)) {\n            throw new MissingRequestParameterException(self::CUSTOMER_ID);\n        }\n\n        $this->fetchSalesChannel($salesChannelId, $context);\n\n        $salesChannelContext = $this->fetchSalesChannelContext($salesChannelId, $request, $context);\n\n        $this->persistPermissions($request, $salesChannelContext);\n\n        $this->updateCustomerToContext($request->get(self::CUSTOMER_ID), $salesChannelContext);\n\n        $content = json_encode([\n            PlatformRequest::HEADER_CONTEXT_TOKEN => $salesChannelContext->getToken(),\n        ], \\JSON_THROW_ON_ERROR);\n        $response = new Response();\n        $response->headers->set('content-type', 'application/json');\n        $response->setContent($content ?: null);\n\n        return $response;\n    }\n\n    /**\n     * @Since(\"6.2.0.0\")\n     * @Route(\"/api/_proxy/modify-shipping-costs\", name=\"api.proxy.modify-shipping-costs\", methods={\"PATCH\"})\n     *\n     * @throws InconsistentCriteriaIdsException\n     * @throws InvalidSalesChannelIdException\n     * @throws MissingRequestParameterException\n     */\n    public function modifyShippingCosts(Request $request, Context $context): JsonResponse\n    {\n        if (!$request->request->has(self::SALES_CHANNEL_ID)) {\n            throw new MissingRequestParameterException(self::SALES_CHANNEL_ID);\n        }\n\n        $salesChannelId = (string) $request->request->get('salesChannelId');\n\n        $this->fetchSalesChannel($salesChannelId, $context);\n\n        $salesChannelContext = $this->fetchSalesChannelContext($salesChannelId, $request, $context);\n\n        $calculatedPrice = $this->parseCalculatedPriceByRequest($request);\n\n        $cart = $this->adminOrderCartService->updateShippingCosts($calculatedPrice, $salesChannelContext);\n\n        return new JsonResponse(['data' => $cart]);\n    }\n\n    /**\n     * @Since(\"6.2.0.0\")\n     * @Route(\"/api/_proxy/disable-automatic-promotions\", name=\"api.proxy.disable-automatic-promotions\", methods={\"PATCH\"})\n     */\n    public function disableAutomaticPromotions(Request $request): JsonResponse\n    {\n        if (!$request->request->has(self::SALES_CHANNEL_ID)) {\n            throw new MissingRequestParameterException(self::SALES_CHANNEL_ID);\n        }\n\n        $contextToken = $this->getContextToken($request);\n\n        $salesChannelId = (string) $request->request->get('salesChannelId');\n\n        $this->adminOrderCartService->addPermission($contextToken, PromotionCollector::SKIP_AUTOMATIC_PROMOTIONS, $salesChannelId);\n\n        return new JsonResponse();\n    }\n\n    /**\n     * @Since(\"6.2.0.0\")\n     * @Route(\"/api/_proxy/enable-automatic-promotions\", name=\"api.proxy.enable-automatic-promotions\", methods={\"PATCH\"})\n     */\n    public function enableAutomaticPromotions(Request $request): JsonResponse\n    {\n        if (!$request->request->has(self::SALES_CHANNEL_ID)) {\n            throw new MissingRequestParameterException(self::SALES_CHANNEL_ID);\n        }\n\n        $contextToken = $this->getContextToken($request);\n\n        $salesChannelId = (string) $request->request->get('salesChannelId');\n\n        $this->adminOrderCartService->deletePermission($contextToken, PromotionCollector::SKIP_AUTOMATIC_PROMOTIONS, $salesChannelId);\n\n        return new JsonResponse();\n    }\n\n    private function wrapInSalesChannelApiRoute(Request $request, callable $call): Response\n    {\n        /** @var RequestStack $requestStack */\n        $requestStack = $this->get('request_stack');\n\n        $requestStackBackup = $this->clearRequestStackWithBackup($requestStack);\n        $requestStack->push($request);\n\n        try {\n            return $call();\n        } finally {\n            $this->restoreRequestStack($requestStack, $requestStackBackup);\n        }\n    }\n\n    private function setUpSalesChannelApiRequest(string $path, string $salesChannelId, Request $request, SalesChannelEntity $salesChannel): Request\n    {\n        $contextToken = $this->getContextToken($request);\n\n        $server = array_merge($request->server->all(), ['REQUEST_URI' => '/store-api/' . $path]);\n        $subrequest = $request->duplicate(null, null, [], null, null, $server);\n\n        $subrequest->headers->set(PlatformRequest::HEADER_ACCESS_KEY, $salesChannel->getAccessKey());\n        $subrequest->headers->set(PlatformRequest::HEADER_CONTEXT_TOKEN, $contextToken);\n        $subrequest->attributes->set(PlatformRequest::ATTRIBUTE_OAUTH_CLIENT_ID, $salesChannel->getAccessKey());\n\n        $this->requestContextResolver->handleSalesChannelContext(\n            $subrequest,\n            $salesChannelId,\n            $contextToken\n        );\n\n        return $subrequest;\n    }\n\n    /**\n     * @throws InconsistentCriteriaIdsException\n     * @throws InvalidSalesChannelIdException\n     */\n    private function fetchSalesChannel(string $salesChannelId, Context $context): SalesChannelEntity\n    {\n        /** @var SalesChannelEntity|null $salesChannel */\n        $salesChannel = $this->salesChannelRepository->search(new Criteria([$salesChannelId]), $context)->get($salesChannelId);\n\n        if ($salesChannel === null) {\n            throw new InvalidSalesChannelIdException($salesChannelId);\n        }\n\n        return $salesChannel;\n    }\n\n    private function getContextToken(Request $request): string\n    {\n        $contextToken = $request->headers->get(PlatformRequest::HEADER_CONTEXT_TOKEN);\n\n        if ($contextToken === null) {\n            $contextToken = Random::getAlphanumericString(32);\n        }\n\n        return $contextToken;\n    }\n\n    private function clearRequestStackWithBackup(RequestStack $requestStack): array\n    {\n        $requestStackBackup = [];\n\n        while ($requestStack->getMainRequest()) {\n            $requestStackBackup[] = $requestStack->pop();\n        }\n\n        return $requestStackBackup;\n    }\n\n    private function restoreRequestStack(RequestStack $requestStack, array $requestStackBackup): void\n    {\n        $this->clearRequestStackWithBackup($requestStack);\n\n        foreach ($requestStackBackup as $backedUpRequest) {\n            $requestStack->push($backedUpRequest);\n        }\n    }\n\n    private function fetchSalesChannelContext(string $salesChannelId, Request $request, Context $originalContext): SalesChannelContext\n    {\n        $contextToken = $this->getContextToken($request);\n\n        $salesChannelContext = $this->contextService->get(\n            new SalesChannelContextServiceParameters(\n                $salesChannelId,\n                $contextToken,\n                $request->headers->get(PlatformRequest::HEADER_LANGUAGE_ID),\n                $request->attributes->get(SalesChannelRequest::ATTRIBUTE_DOMAIN_CURRENCY_ID),\n                null,\n                $originalContext\n            )\n        );\n\n        return $salesChannelContext;\n    }\n\n    private function updateCustomerToContext(string $customerId, SalesChannelContext $context): void\n    {\n        $data = new DataBag();\n        $data->set(self::CUSTOMER_ID, $customerId);\n\n        $definition = new DataValidationDefinition('context_switch');\n        $parameters = $data->only(\n            self::CUSTOMER_ID\n        );\n\n        $customerCriteria = new Criteria();\n        $customerCriteria->addFilter(new EqualsFilter('customer.id', $parameters[self::CUSTOMER_ID]));\n\n        $definition\n            ->add(self::CUSTOMER_ID, new EntityExists(['entity' => 'customer', 'context' => $context->getContext(), 'criteria' => $customerCriteria]))\n        ;\n\n        $this->validator->validate($parameters, $definition);\n\n        $isSwitchNewCustomer = true;\n        if ($context->getCustomer()) {\n            // Check if customer switch to another customer or not\n            $isSwitchNewCustomer = $context->getCustomer()->getId() !== $parameters[self::CUSTOMER_ID];\n        }\n\n        if (!$isSwitchNewCustomer) {\n            return;\n        }\n\n        $this->contextPersister->save(\n            $context->getToken(),\n            [\n                'customerId' => $parameters[self::CUSTOMER_ID],\n                'billingAddressId' => null,\n                'shippingAddressId' => null,\n                'shippingMethodId' => null,\n                'paymentMethodId' => null,\n                'languageId' => null,\n                'currencyId' => null,\n            ],\n            $context->getSalesChannel()->getId()\n        );\n        $event = new SalesChannelContextSwitchEvent($context, $data);\n        $this->eventDispatcher->dispatch($event);\n    }\n\n    private function persistPermissions(Request $request, SalesChannelContext $salesChannelContext): void\n    {\n        $contextToken = $salesChannelContext->getToken();\n\n        $salesChannelId = $salesChannelContext->getSalesChannelId();\n\n        $payload = $this->contextPersister->load($contextToken, $salesChannelId);\n        $requestPermissions = $request->get(SalesChannelContextService::PERMISSIONS);\n\n        if (\\in_array(SalesChannelContextService::PERMISSIONS, $payload, true) && !$requestPermissions) {\n            return;\n        }\n\n        $payload[SalesChannelContextService::PERMISSIONS] = $requestPermissions\n            ? \\array_fill_keys($requestPermissions, true)\n            : [self::ADMIN_ORDER_PERMISSIONS];\n\n        $this->contextPersister->save($contextToken, $payload, $salesChannelId);\n    }\n\n    private function parseCalculatedPriceByRequest(Request $request): CalculatedPrice\n    {\n        $this->validateShippingCostsParameters($request);\n\n        $shippingCosts = $request->get('shippingCosts');\n\n        return new CalculatedPrice($shippingCosts['unitPrice'], $shippingCosts['totalPrice'], new CalculatedTaxCollection(), new TaxRuleCollection());\n    }\n\n    private function validateShippingCostsParameters(Request $request): void\n    {\n        if (!$request->request->has('shippingCosts')) {\n            throw new MissingRequestParameterException('shippingCosts');\n        }\n\n        $validation = new DataValidationDefinition('shipping-cost');\n        $validation->add('unitPrice', new NotBlank(), new Type('numeric'), new GreaterThanOrEqual(['value' => 0]));\n        $validation->add('totalPrice', new NotBlank(), new Type('numeric'), new GreaterThanOrEqual(['value' => 0]));\n        $this->validator->validate($request->request->all('shippingCosts'), $validation);\n    }\n}\n", "<?php declare(strict_types=1);\n\nnamespace Shopware\\Core\\System\\SalesChannel\\Context;\n\nuse Shopware\\Core\\Checkout\\Cart\\Cart;\nuse Shopware\\Core\\Checkout\\Cart\\CartRuleLoader;\nuse Shopware\\Core\\Checkout\\Cart\\Error\\ErrorCollection;\nuse Shopware\\Core\\Checkout\\Cart\\Event\\CartMergedEvent;\nuse Shopware\\Core\\Checkout\\Cart\\LineItem\\LineItem;\nuse Shopware\\Core\\Checkout\\Cart\\SalesChannel\\CartService;\nuse Shopware\\Core\\System\\SalesChannel\\Event\\SalesChannelContextRestoredEvent;\nuse Shopware\\Core\\System\\SalesChannel\\SalesChannelContext;\nuse Symfony\\Contracts\\EventDispatcher\\EventDispatcherInterface;\n\nclass CartRestorer\n{\n    private AbstractSalesChannelContextFactory $factory;\n\n    private SalesChannelContextPersister $contextPersister;\n\n    private CartService $cartService;\n\n    private EventDispatcherInterface $eventDispatcher;\n\n    private CartRuleLoader $cartRuleLoader;\n\n    public function __construct(\n        AbstractSalesChannelContextFactory $factory,\n        SalesChannelContextPersister $contextPersister,\n        CartService $cartService,\n        CartRuleLoader $cartRuleLoader,\n        EventDispatcherInterface $eventDispatcher\n    ) {\n        $this->factory = $factory;\n        $this->contextPersister = $contextPersister;\n        $this->cartService = $cartService;\n        $this->cartRuleLoader = $cartRuleLoader;\n        $this->eventDispatcher = $eventDispatcher;\n    }\n\n    public function restore(string $customerId, SalesChannelContext $currentContext): SalesChannelContext\n    {\n        $customerPayload = $this->contextPersister->load(\n            $currentContext->getToken(),\n            $currentContext->getSalesChannel()->getId(),\n            $customerId\n        );\n\n        if (empty($customerPayload) || !empty($customerPayload['permissions']) || !($customerPayload['expired'] ?? false) && $customerPayload['token'] === $currentContext->getToken()) {\n            return $this->replaceContextToken($customerId, $currentContext);\n        }\n\n        $customerContext = $this->factory->create($customerPayload['token'], $currentContext->getSalesChannel()->getId(), $customerPayload);\n        if ($customerPayload['expired'] ?? false) {\n            $customerContext = $this->replaceContextToken($customerId, $customerContext);\n        }\n\n        $guestCart = $this->cartService->getCart($currentContext->getToken(), $currentContext);\n        $customerCart = $this->cartService->getCart($customerContext->getToken(), $customerContext);\n\n        if ($guestCart->getLineItems()->count() > 0) {\n            $restoredCart = $this->mergeCart($customerCart, $guestCart, $customerContext);\n        } else {\n            $restoredCart = $this->cartService->recalculate($customerCart, $customerContext);\n        }\n\n        $restoredCart->addErrors(...array_values($guestCart->getErrors()->getPersistent()->getElements()));\n\n        $this->deleteGuestContext($currentContext);\n\n        $errors = $restoredCart->getErrors();\n        $result = $this->cartRuleLoader->loadByToken($customerContext, $restoredCart->getToken());\n\n        $cartWithErrors = $result->getCart();\n        $cartWithErrors->setErrors($errors);\n        $this->cartService->setCart($cartWithErrors);\n\n        $this->eventDispatcher->dispatch(new SalesChannelContextRestoredEvent($customerContext));\n\n        return $customerContext;\n    }\n\n    private function mergeCart(Cart $customerCart, Cart $guestCart, SalesChannelContext $customerContext): Cart\n    {\n        $mergeableLineItems = $guestCart->getLineItems()->filter(function (LineItem $item) use ($customerCart) {\n            return ($item->getQuantity() > 0 && $item->isStackable()) || !$customerCart->has($item->getId());\n        });\n\n        $errors = $customerCart->getErrors();\n        $customerCart->setErrors(new ErrorCollection());\n\n        $customerCartClone = clone $customerCart;\n        $customerCart->setErrors($errors);\n        $customerCartClone->setErrors($errors);\n\n        $mergedCart = $this->cartService->add($customerCart, $mergeableLineItems->getElements(), $customerContext);\n\n        $this->eventDispatcher->dispatch(new CartMergedEvent($mergedCart, $customerContext, $customerCartClone));\n\n        return $mergedCart;\n    }\n\n    private function replaceContextToken(string $customerId, SalesChannelContext $currentContext): SalesChannelContext\n    {\n        $newToken = $this->contextPersister->replace($currentContext->getToken(), $currentContext);\n\n        $currentContext->assign([\n            'token' => $newToken,\n        ]);\n\n        $this->contextPersister->save(\n            $newToken,\n            [\n                'customerId' => $customerId,\n                'billingAddressId' => null,\n                'shippingAddressId' => null,\n                'permissions' => [],\n            ],\n            $currentContext->getSalesChannel()->getId(),\n            $customerId\n        );\n\n        return $currentContext;\n    }\n\n    private function deleteGuestContext(SalesChannelContext $guestContext): void\n    {\n        $this->cartService->deleteCart($guestContext);\n        $this->contextPersister->delete($guestContext->getToken());\n    }\n}\n", "<?php declare(strict_types=1);\n\nnamespace Shopware\\Core\\System\\SalesChannel\\Context;\n\nuse Doctrine\\DBAL\\Connection;\nuse Doctrine\\DBAL\\Driver\\ResultStatement;\nuse Shopware\\Core\\Defaults;\nuse Shopware\\Core\\Framework\\Util\\Random;\nuse Shopware\\Core\\Framework\\Uuid\\Uuid;\nuse Shopware\\Core\\System\\SalesChannel\\Event\\SalesChannelContextTokenChangeEvent;\nuse Shopware\\Core\\System\\SalesChannel\\SalesChannelContext;\nuse Symfony\\Contracts\\EventDispatcher\\EventDispatcherInterface;\n\nclass SalesChannelContextPersister\n{\n    /**\n     * @var Connection\n     */\n    private $connection;\n\n    private EventDispatcherInterface $eventDispatcher;\n\n    /**\n     * @var string\n     */\n    private $lifetimeInterval;\n\n    public function __construct(Connection $connection, EventDispatcherInterface $eventDispatcher, ?string $lifetimeInterval = 'P1D')\n    {\n        $this->connection = $connection;\n        $this->eventDispatcher = $eventDispatcher;\n        $this->lifetimeInterval = $lifetimeInterval ?? 'P1D';\n    }\n\n    public function save(string $token, array $newParameters, string $salesChannelId, ?string $customerId = null): void\n    {\n        $existing = $this->load($token, $salesChannelId, $customerId);\n\n        $parameters = array_replace_recursive($existing, $newParameters);\n        if (isset($newParameters['permissions']) && $newParameters['permissions'] === []) {\n            $parameters['permissions'] = [];\n        }\n\n        unset($parameters['token']);\n\n        $this->connection->executeUpdate(\n            'REPLACE INTO sales_channel_api_context (`token`, `payload`, `sales_channel_id`, `customer_id`, `updated_at`)\n                VALUES (:token, :payload, :salesChannelId, :customerId, :updatedAt)',\n            [\n                'token' => $token,\n                'payload' => json_encode($parameters),\n                'salesChannelId' => $salesChannelId ? Uuid::fromHexToBytes($salesChannelId) : null,\n                'customerId' => $customerId ? Uuid::fromHexToBytes($customerId) : null,\n                'updatedAt' => (new \\DateTimeImmutable())->format(Defaults::STORAGE_DATE_TIME_FORMAT),\n            ]\n        );\n    }\n\n    public function delete(string $token): void\n    {\n        $this->connection->executeUpdate(\n            'DELETE FROM sales_channel_api_context WHERE token = :token',\n            [\n                'token' => $token,\n            ]\n        );\n    }\n\n    public function replace(string $oldToken, SalesChannelContext $context): string\n    {\n        $newToken = Random::getAlphanumericString(32);\n\n        $affected = $this->connection->executeUpdate(\n            'UPDATE `sales_channel_api_context`\n                   SET `token` = :newToken,\n                       `updated_at` = :updatedAt\n                   WHERE `token` = :oldToken',\n            [\n                'newToken' => $newToken,\n                'oldToken' => $oldToken,\n                'updatedAt' => (new \\DateTimeImmutable())->format(Defaults::STORAGE_DATE_TIME_FORMAT),\n            ]\n        );\n\n        if ($affected === 0) {\n            $customer = $context->getCustomer();\n\n            $this->connection->insert('sales_channel_api_context', [\n                'token' => $newToken,\n                'payload' => json_encode([]),\n                'sales_channel_id' => Uuid::fromHexToBytes($context->getSalesChannel()->getId()),\n                'customer_id' => $customer ? Uuid::fromHexToBytes($customer->getId()) : null,\n                'updated_at' => (new \\DateTimeImmutable())->format(Defaults::STORAGE_DATE_TIME_FORMAT),\n            ]);\n        }\n\n        $this->connection->executeUpdate(\n            'UPDATE `cart`\n                   SET `token` = :newToken\n                   WHERE `token` = :oldToken',\n            [\n                'newToken' => $newToken,\n                'oldToken' => $oldToken,\n            ]\n        );\n\n        $context->assign(['token' => $newToken]);\n        $this->eventDispatcher->dispatch(new SalesChannelContextTokenChangeEvent($context, $oldToken, $newToken));\n\n        return $newToken;\n    }\n\n    public function load(string $token, string $salesChannelId, ?string $customerId = null): array\n    {\n        $qb = $this->connection->createQueryBuilder();\n\n        $qb->select('*');\n        $qb->from('sales_channel_api_context');\n\n        $qb->where('sales_channel_id = :salesChannelId');\n        $qb->setParameter(':salesChannelId', Uuid::fromHexToBytes($salesChannelId));\n\n        if ($customerId !== null) {\n            $qb->andWhere('token = :token OR customer_id = :customerId');\n            $qb->setParameter(':token', $token);\n            $qb->setParameter(':customerId', Uuid::fromHexToBytes($customerId));\n            $qb->setMaxResults(2);\n        } else {\n            $qb->andWhere('token = :token');\n            $qb->setParameter(':token', $token);\n            $qb->setMaxResults(1);\n        }\n\n        /** @var ResultStatement $statement */\n        $statement = $qb->execute();\n\n        if (!$statement instanceof ResultStatement) {\n            return [];\n        }\n\n        $data = $statement->fetchAll();\n\n        if (empty($data)) {\n            return [];\n        }\n\n        $customerContext = $salesChannelId && $customerId ? $this->getCustomerContext($data, $salesChannelId, $customerId) : null;\n\n        $context = $customerContext ?? array_shift($data);\n\n        $updatedAt = new \\DateTimeImmutable($context['updated_at']);\n        $expiredTime = $updatedAt->add(new \\DateInterval($this->lifetimeInterval));\n\n        $payload = array_filter(json_decode($context['payload'], true));\n        $now = new \\DateTimeImmutable();\n        $payload['expired'] = $expiredTime < $now;\n\n        if ($customerId) {\n            $payload['token'] = $context['token'];\n        }\n\n        return $payload;\n    }\n\n    public function revokeAllCustomerTokens(string $customerId, string ...$preserveTokens): void\n    {\n        $revokeParams = [\n            'customerId' => null,\n            'billingAddressId' => null,\n            'shippingAddressId' => null,\n        ];\n\n        $qb = $this->connection->createQueryBuilder();\n        $qb\n            ->update('sales_channel_api_context')\n            ->set('payload', ':payload')\n            ->set('customer_id', 'NULL')\n            ->set('updated_at', ':updatedAt')\n            ->where('customer_id = :customerId')\n            ->setParameter('updatedAt', (new \\DateTime())->format(Defaults::STORAGE_DATE_TIME_FORMAT))\n            ->setParameter(':payload', json_encode($revokeParams))\n            ->setParameter(':customerId', Uuid::fromHexToBytes($customerId));\n\n        // keep tokens valid, which are given in $preserveTokens\n        if ($preserveTokens) {\n            $qb\n                ->andWhere($qb->expr()->notIn('token', ':preserveTokens'))\n                ->setParameter(':preserveTokens', $preserveTokens, Connection::PARAM_STR_ARRAY);\n        }\n\n        $qb->execute();\n    }\n\n    private function getCustomerContext(array $data, string $salesChannelId, string $customerId): ?array\n    {\n        foreach ($data as $row) {\n            if (!empty($row['customer_id'])\n                && Uuid::fromBytesToHex($row['sales_channel_id']) === $salesChannelId\n                && Uuid::fromBytesToHex($row['customer_id']) === $customerId\n            ) {\n                return $row;\n            }\n        }\n\n        return null;\n    }\n}\n", "<?php declare(strict_types=1);\n\nnamespace Shopware\\Core\\System\\Test\\SalesChannel\\Context;\n\nuse Doctrine\\DBAL\\Connection;\nuse PHPUnit\\Framework\\TestCase;\nuse Shopware\\Core\\Checkout\\Cart\\Cart;\nuse Shopware\\Core\\Checkout\\Cart\\CartPersister;\nuse Shopware\\Core\\Checkout\\Cart\\CartRuleLoader;\nuse Shopware\\Core\\Checkout\\Cart\\Event\\CartMergedEvent;\nuse Shopware\\Core\\Checkout\\Cart\\LineItem\\LineItem;\nuse Shopware\\Core\\Checkout\\Cart\\LineItem\\LineItemCollection;\nuse Shopware\\Core\\Checkout\\Cart\\SalesChannel\\CartService;\nuse Shopware\\Core\\Checkout\\Customer\\CustomerEntity;\nuse Shopware\\Core\\Content\\Product\\Aggregate\\ProductVisibility\\ProductVisibilityDefinition;\nuse Shopware\\Core\\Defaults;\nuse Shopware\\Core\\Framework\\Context;\nuse Shopware\\Core\\Framework\\DataAbstractionLayer\\Search\\Criteria;\nuse Shopware\\Core\\Framework\\Feature;\nuse Shopware\\Core\\Framework\\Test\\TestCaseBase\\IntegrationTestBehaviour;\nuse Shopware\\Core\\Framework\\Util\\Random;\nuse Shopware\\Core\\Framework\\Uuid\\Uuid;\nuse Shopware\\Core\\System\\SalesChannel\\Context\\AbstractSalesChannelContextFactory;\nuse Shopware\\Core\\System\\SalesChannel\\Context\\CartRestorer;\nuse Shopware\\Core\\System\\SalesChannel\\Context\\SalesChannelContextFactory;\nuse Shopware\\Core\\System\\SalesChannel\\Context\\SalesChannelContextPersister;\nuse Shopware\\Core\\System\\SalesChannel\\Context\\SalesChannelContextService;\nuse Shopware\\Core\\System\\SalesChannel\\Event\\SalesChannelContextRestoredEvent;\nuse Shopware\\Core\\System\\SalesChannel\\SalesChannelContext;\nuse Shopware\\Core\\Test\\TestDefaults;\nuse Symfony\\Component\\EventDispatcher\\EventDispatcher;\nuse Symfony\\Contracts\\EventDispatcher\\Event;\nuse function json_encode;\n\nclass CartRestorerTest extends TestCase\n{\n    use IntegrationTestBehaviour;\n\n    /**\n     * @var Connection\n     */\n    private $connection;\n\n    /**\n     * @var CartRestorer\n     */\n    private $cartRestorer;\n\n    /**\n     * @var CartService\n     */\n    private $cartService;\n\n    /**\n     * @var array\n     */\n    private $events;\n\n    /**\n     * @var \\Closure\n     */\n    private $callbackFn;\n\n    /**\n     * @var EventDispatcher\n     */\n    private $eventDispatcher;\n\n    /**\n     * @var SalesChannelContextPersister\n     */\n    private $contextPersister;\n\n    /**\n     * @var string\n     */\n    private $customerId;\n\n    public function setUp(): void\n    {\n        $this->connection = $this->getContainer()->get(Connection::class);\n        $this->cartService = $this->getContainer()->get(CartService::class);\n\n        $this->eventDispatcher = $this->getContainer()->get('event_dispatcher');\n\n        $this->events = [];\n\n        $this->callbackFn = function (Event $event): void {\n            $this->events[\\get_class($event)] = $event;\n        };\n\n        $this->contextPersister = $this->getContainer()->get(SalesChannelContextPersister::class);\n        /** @var AbstractSalesChannelContextFactory $contextFactory */\n        $contextFactory = $this->getContainer()->get(SalesChannelContextFactory::class);\n        $cartRuleLoader = $this->getContainer()->get(CartRuleLoader::class);\n\n        $this->customerId = $this->createCustomer()->getId();\n\n        $this->cartRestorer = new CartRestorer(\n            $contextFactory,\n            $this->contextPersister,\n            $this->cartService,\n            $cartRuleLoader,\n            $this->eventDispatcher\n        );\n    }\n\n    public function testRestore(): void\n    {\n        $expectedToken = Uuid::randomHex();\n        $expectedContext = $this->createSalesChannelContext($expectedToken, []);\n\n        $currentContext = $this->createSalesChannelContext('currentToken', [], $this->customerId);\n\n        $this->contextPersister->save($expectedContext->getToken(), [], $currentContext->getSalesChannel()->getId(), $this->customerId);\n\n        $this->eventDispatcher->addListener(SalesChannelContextRestoredEvent::class, $this->callbackFn);\n\n        $restoredContext = $this->cartRestorer->restore($this->customerId, $currentContext);\n\n        static::assertSame($expectedContext->getToken(), $restoredContext->getToken());\n\n        static::assertArrayHasKey(SalesChannelContextRestoredEvent::class, $this->events);\n        $salesChannelRestoredEvent = $this->events[SalesChannelContextRestoredEvent::class];\n        static::assertInstanceOf(SalesChannelContextRestoredEvent::class, $salesChannelRestoredEvent);\n    }\n\n    public function testGuestContextAndCartAreDeleted(): void\n    {\n        $currentContextToken = Random::getAlphanumericString(32);\n\n        $currentContext = $this->createSalesChannelContext($currentContextToken, []);\n\n        $this->contextPersister->save($currentContextToken, [], $currentContext->getSalesChannel()->getId(), $this->customerId);\n\n        $cart = new Cart('test', $currentContextToken);\n\n        $cart->add(new LineItem(Uuid::randomHex(), LineItem::CUSTOM_LINE_ITEM_TYPE));\n        $this->getContainer()->get(CartPersister::class)->save($cart, $currentContext);\n\n        static::assertTrue($this->cartExists($currentContextToken));\n        static::assertTrue($this->contextExists($currentContextToken));\n\n        $newContext = $this->cartRestorer->restore($this->customerId, $currentContext);\n\n        static::assertTrue($this->cartExists($newContext->getToken()));\n        static::assertTrue($this->contextExists($newContext->getToken()));\n\n        static::assertFalse($this->cartExists($currentContextToken));\n        static::assertFalse($this->contextExists($currentContextToken));\n    }\n\n    public function testCartIsRecalculated(): void\n    {\n        $customerContextToken = Random::getAlphanumericString(32);\n\n        $customerContext = $this->createSalesChannelContext($customerContextToken, []);\n\n        $this->contextPersister->save($customerContextToken, [], $customerContext->getSalesChannel()->getId(), $this->customerId);\n\n        $cart = new Cart('test', $customerContextToken);\n\n        $productId = $this->createProduct($customerContext->getContext());\n\n        $productLineItem = new LineItem(Uuid::randomHex(), LineItem::PRODUCT_LINE_ITEM_TYPE, $productId);\n        $productLineItem->setStackable(true);\n        $productLineItem->setQuantity(1);\n\n        $cart->add($productLineItem);\n        $cart->markUnmodified();\n\n        static::assertCount(1, $cart->getLineItems());\n        $this->getContainer()->get(CartPersister::class)->save($cart, $customerContext);\n\n        $this->getContainer()->get('product.repository')->delete([[\n            'id' => $productId,\n        ]], $customerContext->getContext());\n\n        $guestContext = $this->createSalesChannelContext('123123', []);\n\n        $restoreContext = $this->cartRestorer->restore($this->customerId, $guestContext);\n\n        $restoreCart = $this->cartService->getCart($restoreContext->getToken(), $restoreContext);\n\n        static::assertFalse($restoreCart->isModified());\n        // Delete product will removed from cart as result from recalculation\n        static::assertCount(0, $restoreCart->getLineItems());\n    }\n\n    public function testCartIsMergedAndRecalculatedWithTheSavedOne(): void\n    {\n        $currentContextToken = Random::getAlphanumericString(32);\n\n        $currentContext = $this->createSalesChannelContext($currentContextToken, []);\n\n        // Create Guest cart\n        $cart = new Cart('guest-cart', $currentContextToken);\n\n        $productId1 = $this->createProduct($currentContext->getContext());\n        $productId2 = $this->createProduct($currentContext->getContext());\n\n        $productLineItem1 = new LineItem($productId1, LineItem::PRODUCT_LINE_ITEM_TYPE, $productId1);\n        $productLineItem2 = new LineItem($productId2, LineItem::PRODUCT_LINE_ITEM_TYPE, $productId2);\n        $productLineItem1->setStackable(true);\n        $productLineItem2->setStackable(true);\n        $productLineItem1->setQuantity(1);\n        $guestProductQuantity = 5;\n        $productLineItem2->setQuantity($guestProductQuantity);\n\n        $cart->addLineItems(new LineItemCollection([$productLineItem1, $productLineItem2]));\n        $cart->markUnmodified();\n\n        $this->getContainer()->get(CartPersister::class)->save($cart, $currentContext);\n\n        // Create Saved Customer cart\n        $customerToken = Random::getAlphanumericString(32);\n        $customerContext = $this->createSalesChannelContext($customerToken, []);\n\n        $this->contextPersister->save($customerToken, [], $currentContext->getSalesChannel()->getId(), $this->customerId);\n\n        $cart = new Cart('customer-cart', $customerToken);\n\n        $savedLineItem = new LineItem($productId2, LineItem::PRODUCT_LINE_ITEM_TYPE, $productId2);\n        $savedLineItemQuantity = 4;\n        $savedLineItem->setStackable(true);\n        $savedLineItem->setQuantity($savedLineItemQuantity);\n\n        $productId3 = $this->createProduct($customerContext->getContext());\n        $productLineItem3 = new LineItem($productId3, LineItem::PRODUCT_LINE_ITEM_TYPE, $productId3);\n        $productLineItem3->setStackable(true);\n        $productLineItem3->setQuantity(3);\n\n        $cart->addLineItems(new LineItemCollection([$savedLineItem, $productLineItem3]));\n        $cart->markUnmodified();\n\n        $this->getContainer()->get(CartPersister::class)->save($cart, $customerContext);\n\n        // Delete 1 saved item\n        $this->getContainer()->get('product.repository')->delete([[\n            'id' => $productId3,\n        ]], $customerContext->getContext());\n\n        $this->eventDispatcher->addListener(CartMergedEvent::class, $this->callbackFn);\n\n        $restoreContext = $this->cartRestorer->restore($this->customerId, $currentContext);\n\n        $restoreCart = $this->cartService->getCart($restoreContext->getToken(), $restoreContext);\n\n        static::assertFalse($restoreCart->isModified());\n        // Delete product will removed from cart as result from recalculation\n        static::assertEmpty($restoreCart->getLineItems()->get($productId3));\n\n        static::assertArrayHasKey(CartMergedEvent::class, $this->events);\n        $cartMergedEvent = $this->events[CartMergedEvent::class];\n        static::assertInstanceOf(CartMergedEvent::class, $cartMergedEvent);\n\n        static::assertEquals(1, $cartMergedEvent->getPreviousCart()->getLineItems()->count());\n        static::assertEquals($cartMergedEvent->getCart()->getName(), $cartMergedEvent->getPreviousCart()->getName());\n        static::assertEquals($cartMergedEvent->getCart()->getToken(), $cartMergedEvent->getPreviousCart()->getToken());\n\n        static::assertNotEmpty($p1 = $restoreCart->getLineItems()->get($productId1));\n        static::assertEquals(1, $p1->getQuantity());\n        static::assertNotEmpty($savedItem = $restoreCart->getLineItems()->get($savedLineItem->getId()));\n        static::assertEquals($savedLineItemQuantity + $guestProductQuantity, $savedItem->getQuantity());\n    }\n\n    public function testCartMergedEventIsFiredWithCustomerCart(): void\n    {\n        Feature::skipTestIfInActive('FEATURE_NEXT_16824', $this);\n\n        $currentContextToken = Random::getAlphanumericString(32);\n\n        $currentContext = $this->createSalesChannelContext($currentContextToken, []);\n\n        // Create Guest cart\n        $cart = new Cart('guest-cart', $currentContextToken);\n\n        $productId1 = $this->createProduct($currentContext->getContext());\n        $productId2 = $this->createProduct($currentContext->getContext());\n\n        $productLineItem1 = new LineItem($productId1, LineItem::PRODUCT_LINE_ITEM_TYPE, $productId1);\n        $productLineItem2 = new LineItem($productId2, LineItem::PRODUCT_LINE_ITEM_TYPE, $productId2);\n        $productLineItem1->setStackable(true);\n        $productLineItem2->setStackable(true);\n        $productLineItem1->setQuantity(1);\n        $guestProductQuantity = 5;\n        $productLineItem2->setQuantity($guestProductQuantity);\n\n        $cart->addLineItems(new LineItemCollection([$productLineItem1, $productLineItem2]));\n        $cart->markUnmodified();\n\n        $this->getContainer()->get(CartPersister::class)->save($cart, $currentContext);\n\n        // Create Saved Customer cart\n        $customerToken = Random::getAlphanumericString(32);\n        $customerContext = $this->createSalesChannelContext($customerToken, []);\n\n        $this->contextPersister->save($customerToken, [], $currentContext->getSalesChannel()->getId(), $this->customerId);\n\n        $cart = new Cart('customer-cart', $customerToken);\n\n        $this->getContainer()->get(CartPersister::class)->save($cart, $customerContext);\n\n        $this->eventDispatcher->addListener(CartMergedEvent::class, $this->callbackFn);\n\n        $restoreContext = $this->cartRestorer->restore($this->customerId, $currentContext);\n\n        $restoreCart = $this->cartService->getCart($restoreContext->getToken(), $restoreContext);\n\n        static::assertFalse($restoreCart->isModified());\n        static::assertArrayHasKey(CartMergedEvent::class, $this->events);\n\n        /** @var CartMergedEvent $event */\n        $event = $this->events[CartMergedEvent::class];\n\n        static::assertEquals(0, $event->getPreviousCart()->getLineItems()->count());\n        static::assertEquals($event->getCart()->getName(), $event->getPreviousCart()->getName());\n        static::assertEquals($event->getCart()->getToken(), $event->getPreviousCart()->getToken());\n\n        static::assertNotEmpty($p1 = $restoreCart->getLineItems()->get($productId1));\n        static::assertEquals(1, $p1->getQuantity());\n        static::assertNotEmpty($p2 = $restoreCart->getLineItems()->get($productId2));\n        static::assertEquals(5, $p2->getQuantity());\n    }\n\n    public function testPermissionsAreIgnoredOnRestoer(): void\n    {\n        $currentContextToken = Random::getAlphanumericString(32);\n\n        $currentContext = $this->createSalesChannelContext($currentContextToken, []);\n\n        $con = $this->getContainer()->get(Connection::class);\n\n        $con->insert('sales_channel_api_context', [\n            'token' => Random::getAlphanumericString(32),\n            'payload' => json_encode(['expired' => false, 'customerId' => $this->customerId, 'permissions' => ['foo']], \\JSON_THROW_ON_ERROR),\n            'sales_channel_id' => Uuid::fromHexToBytes($currentContext->getSalesChannelId()),\n            'customer_id' => Uuid::fromHexToBytes($this->customerId),\n            'updated_at' => (new \\DateTime())->format(Defaults::STORAGE_DATE_TIME_FORMAT),\n        ]);\n\n        $restoreContext = $this->cartRestorer->restore($this->customerId, $currentContext);\n\n        static::assertSame([], $restoreContext->getPermissions());\n    }\n\n    private function createProduct(Context $context): string\n    {\n        $productId = Uuid::randomHex();\n\n        $productNumber = Uuid::randomHex();\n        $data = [\n            'id' => $productId,\n            'productNumber' => $productNumber,\n            'stock' => 1,\n            'name' => 'Test Product',\n            'price' => [['currencyId' => Defaults::CURRENCY, 'gross' => 10.99, 'net' => 11.99, 'linked' => false]],\n            'manufacturer' => ['name' => 'create'],\n            'taxId' => $this->getValidTaxId(),\n            'active' => true,\n            'visibilities' => [\n                ['salesChannelId' => TestDefaults::SALES_CHANNEL, 'visibility' => ProductVisibilityDefinition::VISIBILITY_ALL],\n            ],\n        ];\n        $this->getContainer()->get('product.repository')->create([$data], $context);\n\n        return $productId;\n    }\n\n    private function createSalesChannelContext(string $contextToken, array $salesChannelData, ?string $customerId = null): SalesChannelContext\n    {\n        if ($customerId) {\n            $salesChannelData[SalesChannelContextService::CUSTOMER_ID] = $customerId;\n        }\n\n        return $this->getContainer()->get(SalesChannelContextFactory::class)->create(\n            $contextToken,\n            TestDefaults::SALES_CHANNEL,\n            $salesChannelData\n        );\n    }\n\n    private function cartExists(string $token): bool\n    {\n        $result = (int) $this->connection->executeQuery(\n            'SELECT COUNT(*) FROM cart WHERE `token` = :token',\n            [\n                'token' => $token,\n            ]\n        )->fetchColumn();\n\n        return $result > 0;\n    }\n\n    private function contextExists(string $token): bool\n    {\n        $result = (int) $this->connection->executeQuery(\n            'SELECT COUNT(*) FROM sales_channel_api_context WHERE `token` = :token',\n            [\n                'token' => $token,\n            ]\n        )->fetchColumn();\n\n        return $result > 0;\n    }\n\n    private function createCustomer(): CustomerEntity\n    {\n        $customerId = Uuid::randomHex();\n        $addressId = Uuid::randomHex();\n\n        $data = [\n            [\n                'id' => $customerId,\n                'salesChannelId' => TestDefaults::SALES_CHANNEL,\n                'defaultShippingAddress' => [\n                    'id' => $addressId,\n                    'firstName' => 'Max',\n                    'lastName' => 'Mustermann',\n                    'street' => 'Musterstra\u00dfe 1',\n                    'city' => 'Sch\u00f6ppingen',\n                    'zipcode' => '12345',\n                    'salutationId' => $this->getValidSalutationId(),\n                    'countryId' => $this->getValidCountryId(),\n                ],\n                'defaultBillingAddressId' => $addressId,\n                'defaultPaymentMethodId' => $this->getValidPaymentMethodId(),\n                'groupId' => TestDefaults::FALLBACK_CUSTOMER_GROUP,\n                'email' => 'foo@bar.de',\n                'password' => 'password',\n                'firstName' => 'Max',\n                'lastName' => 'Mustermann',\n                'salutationId' => $this->getValidSalutationId(),\n                'customerNumber' => '12345',\n            ],\n        ];\n\n        $repo = $this->getContainer()->get('customer.repository');\n\n        $repo->create($data, Context::createDefaultContext());\n\n        return $repo->search(new Criteria([$customerId]), Context::createDefaultContext())->first();\n    }\n}\n"], "filenames": ["src/Core/Framework/Api/Controller/SalesChannelProxyController.php", "src/Core/System/SalesChannel/Context/CartRestorer.php", "src/Core/System/SalesChannel/Context/SalesChannelContextPersister.php", "src/Core/System/Test/SalesChannel/Context/CartRestorerTest.php"], "buggy_code_start_loc": [200, 49, 35, 15], "buggy_code_end_loc": [200, 116, 40, 355], "fixing_code_start_loc": [201, 49, 35, 14], "fixing_code_end_loc": [202, 118, 43, 345], "type": "CWE-732", "message": "Shopware is an open commerce platform based on Symfony Framework and Vue. Permissions set to sales channel context by admin-api are still usable within normal user session. Users are advised to update to the current version 6.4.10.1. For older versions of 6.1, 6.2, and 6.3, corresponding security measures are also available via a plugin. There are no known workarounds for this issue.", "other": {"cve": {"id": "CVE-2022-24872", "sourceIdentifier": "security-advisories@github.com", "published": "2022-04-20T20:15:08.707", "lastModified": "2022-05-03T15:58:23.587", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Shopware is an open commerce platform based on Symfony Framework and Vue. Permissions set to sales channel context by admin-api are still usable within normal user session. Users are advised to update to the current version 6.4.10.1. For older versions of 6.1, 6.2, and 6.3, corresponding security measures are also available via a plugin. There are no known workarounds for this issue."}, {"lang": "es", "value": "Shopware es una plataforma de comercio abierta basada en Symfony Framework y Vue. Los permisos establecidos en el contexto del canal de ventas por el admin-api siguen siendo usables dentro de la sesi\u00f3n normal del usuario. Es recomendado a usuarios actualizar a versi\u00f3n actual 6.4.10.1. Para las versiones anteriores de 6.1, 6.2 y 6.3, las medidas de seguridad correspondientes tambi\u00e9n est\u00e1n disponibles por medio de un plugin. No se presentan medidas de mitigaci\u00f3n conocidas para este problema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.2}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-732"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-732"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:shopware:shopware:*:*:*:*:*:*:*:*", "versionEndExcluding": "6.4.10.1", "matchCriteriaId": "D55965A4-CEC0-409A-88C0-EE94BE12B95A"}]}]}], "references": [{"url": "https://docs.shopware.com/en/shopware-6-en/security-updates/security-update-04-2022", "source": "security-advisories@github.com", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/shopware/platform/commit/083765e2d64a00315050c4891800c9e98ba0c77c", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/shopware/platform/security/advisories/GHSA-9wrv-g75h-8ccc", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/shopware/platform/commit/083765e2d64a00315050c4891800c9e98ba0c77c"}}