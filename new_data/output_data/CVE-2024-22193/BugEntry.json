{"buggy_code": ["# -*- coding: utf-8 -*-\nimport logging\nimport json\n\nfrom flask import g, request, url_for\nfrom flask_restful import Api\nfrom flask_socketio import SocketIO\nfrom http import HTTPStatus\nfrom sqlalchemy import desc\nfrom sqlalchemy.sql import visitors\n\nfrom vantage6.common.globals import STRING_ENCODING\nfrom vantage6.common.task_status import TaskStatus, has_task_finished\nfrom vantage6.server import db\nfrom vantage6.server.permission import (\n    RuleCollection,\n    Scope as S,\n    PermissionManager,\n    Operation as P\n)\nfrom vantage6.server.resource import only_for, ServicesResources, with_user\nfrom vantage6.server.resource.common.output_schema import (\n    TaskSchema,\n    TaskWithResultSchema,\n    TaskWithRunSchema,\n    TaskWithRunAndResultSchema,\n)\nfrom vantage6.server.resource.common.input_schema import TaskInputSchema\nfrom vantage6.server.resource.common.pagination import Pagination\nfrom vantage6.server.resource.event import kill_task\n\n\nmodule_name = __name__.split('.')[-1]\nlog = logging.getLogger(module_name)\n\n\ndef setup(api: Api, api_base: str, services: dict) -> None:\n    \"\"\"\n    Setup the task resource.\n\n    Parameters\n    ----------\n    api : Api\n        Flask restful api instance\n    api_base : str\n        Base url of the api\n    services : dict\n        Dictionary with services required for the resource endpoints\n    \"\"\"\n    path = \"/\".join([api_base, module_name])\n    log.info(f'Setting up \"{path}\" and subdirectories')\n\n    api.add_resource(\n        Tasks,\n        path,\n        endpoint='task_without_id',\n        methods=('GET', 'POST'),\n        resource_class_kwargs=services\n    )\n    api.add_resource(\n        Task,\n        path + '/<int:id>',\n        endpoint='task_with_id',\n        methods=('GET', 'DELETE'),\n        resource_class_kwargs=services\n    )\n\n\n# -----------------------------------------------------------------------------\n# Permissions\n# -----------------------------------------------------------------------------\ndef permissions(permissions: PermissionManager) -> None:\n    \"\"\"\n    Define the permissions for this resource.\n\n    Parameters\n    ----------\n    permissions : PermissionManager\n        Permission manager instance to which permissions are added\n    \"\"\"\n    add = permissions.appender(module_name)\n\n    add(scope=S.GLOBAL, operation=P.VIEW, description=\"view any task\")\n    add(scope=S.COLLABORATION, operation=P.VIEW, assign_to_container=True,\n        assign_to_node=True, description=\"view tasks of your collaborations\")\n    add(scope=S.ORGANIZATION, operation=P.VIEW,\n        description=\"view tasks that your organization initiated\")\n    add(scope=S.OWN, operation=P.VIEW,\n        description=\"view tasks that you initiated\")\n\n    add(scope=S.GLOBAL, operation=P.CREATE, description=\"create a new task\")\n    add(scope=S.COLLABORATION, operation=P.CREATE,\n        description=(\n            \"create a new task for collaborations in which your organization \"\n            \"participates with\"\n        ))\n\n    add(scope=S.GLOBAL, operation=P.DELETE,\n        description=\"delete a task\")\n    add(scope=S.COLLABORATION, operation=P.DELETE,\n        description=\"delete a task from your collaborations\")\n    add(scope=S.ORGANIZATION, operation=P.DELETE,\n        description=(\n            \"delete a task from a collaboration in which your organization \"\n            \"participates with\"\n        ))\n    add(scope=S.OWN, operation=P.DELETE,\n        description=\"delete tasks that you created\")\n\n\n# ------------------------------------------------------------------------------\n# Resources / API's\n# ------------------------------------------------------------------------------\ntask_schema = TaskSchema()\ntask_run_schema = TaskWithRunSchema()\ntask_result_schema = TaskWithResultSchema()\ntask_result_run_schema = TaskWithRunAndResultSchema()\n\ntask_input_schema = TaskInputSchema()\n\n\nclass TaskBase(ServicesResources):\n\n    def __init__(self, socketio, mail, api, permissions, config):\n        super().__init__(socketio, mail, api, permissions, config)\n        self.r: RuleCollection = getattr(self.permissions, module_name)\n        # permissions for the run resource are also relevant for the task\n        # resource as they are sometimes included\n        self.r_run: RuleCollection = getattr(self.permissions, 'run')\n\n    def _select_schema(self) -> TaskSchema:\n        \"\"\"\n        Select the schema to use for serialization.\n\n        Returns\n        -------\n        TaskSchema\n            Schema to use for serialization\n        \"\"\"\n        if self.is_included('runs') and self.is_included('results'):\n            return task_result_run_schema\n        elif self.is_included('runs'):\n            return task_run_schema\n        elif self.is_included('results'):\n            return task_result_schema\n        else:\n            return task_schema\n\n\nclass Tasks(TaskBase):\n\n    @only_for((\"user\", \"node\", \"container\"))\n    def get(self):\n        \"\"\"List tasks\n        ---\n        description: >-\n          Returns a list of tasks.\\n\n\n          ### Permission Table\\n\n          |Rule name|Scope|Operation|Assigned to node|Assigned to container|\n          Description|\\n\n          |--|--|--|--|--|--|\\n\n          |Task|Global|View|\u274c|\u274c|View any task|\\n\n          |Task|Collaboration|View|\u2705|\u2705|View any task in your collaborations|\n          \\n\n          |Task|Organization|View|\u274c|\u274c|View any task that your organization\n          created|\\n\n          |Task|Own|View|\u274c|\u274c|View any task that you created|\\n\n\n          Accessible to users.\n\n        parameters:\n          - in: query\n            name: init_org_id\n            schema:\n              type: int\n            description: The organization id of the origin of the request\n          - in: query\n            name: init_user_id\n            schema:\n              type: int\n            description: The user id of the user that started the task\n          - in: query\n            name: collaboration_id\n            schema:\n              type: int\n            description: The collaboration id to which the task belongs\n          - in: query\n            name: is_user_created\n            schema:\n              type: int\n            description: >-\n              If larger than 0, returns tasks created by a user (top-level\n              tasks). If equal to 0, returns subtask created by an algorithm.\n              If not specified, both are returned.\n          - in: query\n            name: image\n            schema:\n              type: str\n            description: >-\n              (Docker) image name which is used in the task. Name to match\n              with a LIKE operator. \\n\n              * The percent sign (%) represents zero, one, or multiple\n              characters\\n\n              * underscore sign (_) represents one, single character\n          - in: query\n            name: parent_id\n            schema:\n              type: int\n            description: The id of the parent task\n          - in: query\n            name: job_id\n            schema:\n              type: int\n            description: The run id that belongs to the task\n          - in: query\n            name: name\n            schema:\n              type: str\n            description: >-\n              Name to match with a LIKE operator. \\n\n              * The percent sign (%) represents zero, one, or multiple\n              characters\\n\n              * underscore sign (_) represents one, single character\n          - in: query\n            name: description\n            schema:\n              type: string\n            description: >-\n              Description to match with a LIKE operator. \\n\n              * The percent sign (%) represents zero, one, or multiple\n              characters\\n\n              * underscore sign (_) represents one, single character\n          - in: query\n            name: database\n            schema:\n              type: string\n            description: >-\n              Database description to match with a LIKE operator. \\n\n              * The percent sign (%) represents zero, one, or multiple\n              characters\\n\n              * underscore sign (_) represents one, single character\n          - in: query\n            name: run_id\n            schema:\n              type: int\n            description: A run id that belongs to the task\n          - in: query\n            name: include\n            schema:\n              type: array\n              items:\n                type: string\n            description: Include 'results' to include the task's results,\n              'runs' to include details on algorithm runs. For including\n               multiple, do either `include=x,y` or `include=x&include=y`.\n          - in: query\n            name: status\n            schema:\n              type: string\n            description: Filter by task status, e.g. 'active' for active\n              tasks, 'completed' for finished or 'crashed' for failed tasks.\n          - in: query\n            name: page\n            schema:\n              type: integer\n            description: Page number for pagination (default=1)\n          - in: query\n            name: per_page\n            schema:\n              type: integer\n            description: Number of items per page (default=10)\n          - in: query\n            name: sort\n            schema:\n              type: string\n            description: >-\n              Sort by one or more fields, separated by a comma. Use a minus\n              sign (-) in front of the field to sort in descending order.\n\n        responses:\n          200:\n            description: Ok\n          400:\n            description: Non-allowed or wrong parameter values\n          401:\n            description: Unauthorized\n\n        security:\n            - bearerAuth: []\n\n        tags: [\"Task\"]\n        \"\"\"\n        q = g.session.query(db.Task)\n        args = request.args\n\n        auth_org_id = self.obtain_organization_id()\n\n        # check permissions and apply filter if neccassary\n        if not self.r.v_glo.can():\n            if self.r.v_col.can():\n                q = q.join(db.Collaboration).join(db.Organization)\\\n                    .filter(db.Collaboration.organizations.any(id=auth_org_id))\n            elif self.r.v_org.can():\n                q = q.join(db.Organization)\\\n                    .filter(db.Task.init_org_id == auth_org_id)\n            elif self.r.v_own.can():\n                q = q.filter(db.Task.init_user_id == g.user.id)\n            else:\n                return {'msg': 'You lack the permission to do that!'}, \\\n                    HTTPStatus.UNAUTHORIZED\n        # if results are included, check permissions on results\n        if self.is_included('results'):\n            max_scope_task = self.r.get_max_scope(P.VIEW)\n            if not self.r_run.has_at_least_scope(max_scope_task, P.VIEW):\n                max_scope_run = self.r_run.get_max_scope(P.VIEW)\n                return {\n                    'msg': 'You cannot view the results of all tasks, as you '\n                    f'are allowed to view tasks with scope {max_scope_task} '\n                    f'but you can only view results with scope {max_scope_run}'\n                }, HTTPStatus.UNAUTHORIZED\n\n        if 'collaboration_id' in args:\n            collaboration_id = int(args['collaboration_id'])\n            if not self.r.can_for_col(P.VIEW, collaboration_id):\n                return {'msg': 'You lack the permission to view tasks '\n                        f'from collaboration {collaboration_id}!'}, \\\n                    HTTPStatus.UNAUTHORIZED\n            # dont join collaboration table if it is already joined\n            # FIXME refactor this after moving to SQLAlchemy 2.0\n            has_already_joined_collab = False\n            for visitor in visitors.iterate(q.statement):\n                if visitor.__visit_name__ == 'table' and \\\n                        visitor.name == 'collaboration':\n                    has_already_joined_collab = True\n            if not has_already_joined_collab:\n                q = q.join(db.Collaboration)\n            q = q.filter(db.Collaboration.id == collaboration_id)\n\n        if 'init_org_id' in args:\n            init_org_id = int(args['init_org_id'])\n            if not self.r.can_for_org(P.VIEW, init_org_id):\n                return {'msg': 'You lack the permission to view tasks '\n                        f'from organization id={init_org_id}!'}, \\\n                    HTTPStatus.UNAUTHORIZED\n            q = q.filter(db.Task.init_org_id == init_org_id)\n\n        if 'init_user_id' in args:\n            init_user_id = int(args['init_user_id'])\n            init_user = db.User.get(init_user_id)\n            if not init_user:\n                return {'msg': f'User id={init_user_id} does not '\n                        'exist!'}, HTTPStatus.BAD_REQUEST\n            elif not self.r.can_for_org(P.VIEW, init_user.organization_id) \\\n                    and not (self.r.v_own.can() and g.user and\n                             init_user.id == g.user.id):\n                return {'msg': 'You lack the permission to view tasks '\n                        f'from user id={init_user_id}!'}, \\\n                    HTTPStatus.UNAUTHORIZED\n            q = q.filter(db.Task.init_user_id == init_user_id)\n\n        if 'parent_id' in args:\n            parent_id = int(args['parent_id'])\n            parent = db.Task.get(parent_id)\n            if not parent:\n                return {'msg': f'Parent task id={args[\"parent_id\"]} does not '\n                        'exist!'}, HTTPStatus.BAD_REQUEST\n            elif not self.r.can_for_col(P.VIEW, parent.collaboration_id):\n                return {'msg': 'You lack the permission to view tasks '\n                        'from the collaboration that the task with parent_id='\n                        f'{parent.collaboration_id} belongs to!'}, \\\n                    HTTPStatus.UNAUTHORIZED\n            q = q.filter(db.Task.parent_id == int(parent_id))\n\n        if 'job_id' in args:\n            job_id = int(args['job_id'])\n            task_in_job = q.session.query(db.Task).filter(\n                db.Task.job_id == job_id).first()\n            if not task_in_job:\n                return {'msg': f'Job id={args[\"job_id\"]} does not exist!'}, \\\n                    HTTPStatus.BAD_REQUEST\n            elif not self.r.can_for_col(P.VIEW, task_in_job.collaboration_id):\n                return {'msg': 'You lack the permission to view tasks '\n                        'from the collaboration that the task with job_id='\n                        f'{task_in_job.collaboration_id} belongs to!'}, \\\n                    HTTPStatus.UNAUTHORIZED\n            q = q.filter(db.Task.job_id == job_id)\n\n        for param in ['name', 'image', 'description', 'status']:\n            if param in args:\n                q = q.filter(getattr(db.Task, param).like(args[param]))\n\n        if 'run_id' in args:\n            run_id = int(args['run_id'])\n            run = db.Run.get(run_id)\n            if not run:\n                return {'msg': f'Run id={args[\"run_id\"]} does not exist!'}, \\\n                    HTTPStatus.BAD_REQUEST\n            elif not self.r.can_for_col(P.VIEW, run.collaboration_id):\n                return {'msg': 'You lack the permission to view tasks '\n                        'from the collaboration that the run with id='\n                        f'{run.collaboration_id} belongs to!'}, \\\n                    HTTPStatus.UNAUTHORIZED\n            q = q.join(db.Run).filter(db.Run.id == run_id)\n\n        if 'database' in args:\n            q = q.join(db.TaskDatabase)\\\n                 .filter(db.TaskDatabase.database == args['database'])\n\n        if 'is_user_created' in args:\n            try:\n                user_created = int(args['is_user_created'])\n                if user_created == 0:\n                    q = q.filter(db.Task.parent_id.isnot(None))\n                else:\n                    q = q.filter(db.Task.parent_id.is_(None))\n            except ValueError:\n                return {\"msg\": (\n                    \"Invalid value for 'is_user_created' provided: \"\n                    f\"'{args['is_user_created']}'. Should be an integer.\"\n                )}, HTTPStatus.BAD_REQUEST\n\n        # order to get latest task first\n        q = q.order_by(desc(db.Task.id))\n\n        # paginate tasks\n        try:\n            page = Pagination.from_query(q, request, db.Task)\n        except (ValueError, AttributeError) as e:\n            return {'msg': str(e)}, HTTPStatus.BAD_REQUEST\n\n        # serialization schema\n        schema = self._select_schema()\n\n        return self.response(page, schema)\n\n    @only_for((\"user\", \"container\"))\n    def post(self):\n        \"\"\"Adds new computation task\n        ---\n        description: >-\n          Creates a new task within a collaboration. If no `organization_ids`\n          are given the task is send to all organizations within the\n          collaboration. The endpoint can be accessed by both a `User` and\n          `Container`.\\n\n\n          ### Permission Table\\n\n          |Rule name|Scope|Operation|Assigned to node|Assigned to container|\n          Description|\\n\n          |--|--|--|--|--|--|\\n\n          |Task|Global|Create|\u274c|\u274c|Create a new task|\\n\n          |Task|Collaboration|Create|\u274c|\u2705|Create a new task for a specific\n          collaboration in which your organization participates|\\n\n\n          ## Accessed as `User`\\n\n          This endpoint is accessible to users. A new `job_id` is\n          created when a user creates a task. The user needs to be within an\n          organization that is part of the collaboration to which the task is\n          posted.\\n\n\n          ## Accessed as `Container`\\n\n          When this endpoint is accessed by an algorithm container, it is\n          considered to be a child-task of the container, and will get the\n          `job_id` from the initial task. Containers have limited permissions\n          to create tasks: they are only allowed to create tasks in the same\n          collaboration using the same image.\\n\n\n        requestBody:\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/Task'\n\n        responses:\n          200:\n            description: Ok\n          400:\n            description: Supplied organizations are not in the supplied\n              collaboration, or not all required nodes are registered, or you\n              are not in the collaboration yourself\n          401:\n            description: Unauthorized\n          404:\n            description: Collaboration with `collaboration_id` not found\n\n        security:\n          - bearerAuth: []\n\n        tags: [\"Task\"]\n        \"\"\"\n        return self.post_task(request.get_json(), self.socketio, self.r)\n\n    @staticmethod\n    def post_task(data: dict, socketio: SocketIO, rules: RuleCollection):\n        \"\"\"\n        Create new task and algorithm runs. Send the task to the nodes.\n\n        Parameters\n        ----------\n        data : dict\n            Task data\n        \"\"\"\n        # validate request body\n        errors = task_input_schema.validate(data)\n        if errors:\n            return {'msg': 'Request body is incorrect', 'errors': errors}, \\\n                HTTPStatus.BAD_REQUEST\n\n        collaboration_id = data.get('collaboration_id')\n        collaboration = db.Collaboration.get(collaboration_id)\n\n        if not collaboration:\n            return {\n                \"msg\": f\"Collaboration id={collaboration_id} not found!\"\n            }, HTTPStatus.NOT_FOUND\n\n        organizations_json_list = data.get('organizations')\n        org_ids = [org.get(\"id\") for org in organizations_json_list]\n        db_ids = collaboration.get_organization_ids()\n\n        # Check that all organization ids are within the collaboration, this\n        # also ensures us that the organizations exist\n        if not set(org_ids).issubset(db_ids):\n            return {\"msg\": (\n                \"At least one of the supplied organizations in not within \"\n                \"the collaboration.\"\n            )}, HTTPStatus.BAD_REQUEST\n\n        # check if all the organizations have a registered node\n        nodes = g.session.query(db.Node)\\\n            .filter(db.Node.organization_id.in_(org_ids))\\\n            .filter(db.Node.collaboration_id == collaboration_id)\\\n            .all()\n        if len(nodes) < len(org_ids):\n            present_nodes = [node.organization_id for node in nodes]\n            missing = [str(id) for id in org_ids if id not in present_nodes]\n            return {\"msg\": (\n                \"Cannot create this task because there are no nodes registered\"\n                f\" for the following organization(s): {', '.join(missing)}.\"\n            )}, HTTPStatus.BAD_REQUEST\n        # check if any of the nodes that are offline shared their configuration\n        # info and if this prevents this user from creating this task\n        if g.user:\n            for node in nodes:\n                if Tasks._node_doesnt_allow_user_task(node.config):\n                    return {\"msg\": (\n                        \"Cannot create this task because one of the nodes that\"\n                        \" you are trying to send this task to does not allow \"\n                        \"you to create tasks.\"\n                    )}, HTTPStatus.BAD_REQUEST\n\n        # figure out the initiating organization of the task\n        if g.user:\n            init_org = g.user.organization\n        else:  # g.container:\n            init_org = db.Node.get(g.container[\"node_id\"]).organization\n\n        # check if the initiating organization is part of the collaboration\n        if init_org not in collaboration.organizations:\n            return {\n                \"msg\": \"You can only create tasks for collaborations \"\n                       \"you are participating in!\"\n            }, HTTPStatus.UNAUTHORIZED\n\n        # Create the new task in the database\n        image = data.get('image', '')\n\n        # verify permissions\n        if g.user and not rules.can_for_col(P.CREATE, collaboration.id):\n            return {'msg': 'You lack the permission to do that!'}, \\\n                HTTPStatus.UNAUTHORIZED\n\n        elif g.container:\n            # verify that the container has permissions to create the task\n            if not Tasks.__verify_container_permissions(g.container, image,\n                                                        collaboration_id):\n                return {\"msg\": \"Container-token is not valid\"}, \\\n                    HTTPStatus.UNAUTHORIZED\n\n        # permissions ok, create task record and TaskDatabase records\n        task = db.Task(collaboration=collaboration, name=data.get('name', ''),\n                       description=data.get('description', ''), image=image,\n                       init_org=init_org)\n\n        # create job_id. Users can only create top-level -tasks (they will not\n        # have sub-tasks). Therefore, always create a new job_id. Tasks created\n        # by containers are always sub-tasks\n        if g.user:\n            task.job_id = task.next_job_id()\n            task.init_user_id = g.user.id\n            log.debug(f\"New job_id {task.job_id}\")\n        elif g.container:\n            task.parent_id = g.container[\"task_id\"]\n            parent = db.Task.get(g.container[\"task_id\"])\n            task.job_id = parent.job_id\n            task.init_user_id = parent.init_user_id\n            log.debug(f\"Sub task from parent_id={task.parent_id}\")\n\n        # save the databases that the task uses\n        databases = data.get('databases')\n        if isinstance(databases, str):\n            databases = [{'label': databases}]\n        elif databases is None:\n            databases = []\n        db_records = []\n        for database in databases:\n            if 'label' not in database:\n                return {'msg': \"Database label missing! The dictionary \"\n                        f\"{database} should contain a 'label' key\"}, \\\n                    HTTPStatus.BAD_REQUEST\n            # remove label from the database dictionary, which apart from it\n            # may only contain some optional parameters . Save optional\n            # parameters as JSON without spaces to database\n            label = database.pop('label')\n            db_records.append(db.TaskDatabase(\n                task_id=task.id,\n                database=label,\n                parameters=json.dumps(database, separators=(',', ':'))\n            ))\n\n        # All checks completed, save task to database\n        task.save()\n        [db_record.save() for db_record in db_records]  # pylint: disable=W0106\n\n        # send socket event that task has been created\n        socketio.emit(\n            \"task_created\", {\n                \"task_id\": task.id,\n                \"job_id\": task.job_id,\n                \"collaboration_id\": collaboration_id,\n                \"init_org_id\": init_org.id,\n            }, room=f\"collaboration_{collaboration_id}\", namespace='/tasks'\n        )\n\n        # now we need to create results for the nodes to fill. Each node\n        # receives their instructions from a result, not from the task itself\n        log.debug(f\"Assigning task to {len(organizations_json_list)} nodes.\")\n        for org in organizations_json_list:\n            organization = db.Organization.get(org['id'])\n            log.debug(f\"Assigning task to '{organization.name}'.\")\n            input_ = org.get('input')\n            # FIXME: legacy input from the client, could be removed at some\n            # point\n            if isinstance(input_, dict):\n                input_ = json.dumps(input_).encode(STRING_ENCODING)\n            # Create run\n            run = db.Run(\n                task=task,\n                organization=organization,\n                input=input_,\n                status=TaskStatus.PENDING\n            )\n            run.save()\n\n        # notify nodes a new task available (only to online nodes), nodes that\n        # are offline will receive this task on sign in.\n        socketio.emit('new_task', task.id, namespace='/tasks',\n                      room=f'collaboration_{task.collaboration_id}')\n\n        # add some logging\n        log.info(f\"New task for collaboration '{task.collaboration.name}'\")\n        if g.user:\n            log.debug(f\" created by: '{g.user.username}'\")\n        else:\n            log.debug(f\" created by container on node_id=\"\n                      f\"{g.container['node_id']}\"\n                      f\" for (parent) task_id={g.container['task_id']}\")\n\n        log.debug(f\" url: '{url_for('task_with_id', id=task.id)}'\")\n        log.debug(f\" name: '{task.name}'\")\n        log.debug(f\" image: '{task.image}'\")\n\n        return task_schema.dump(task, many=False), HTTPStatus.CREATED\n\n    @staticmethod\n    def __verify_container_permissions(container, image, collaboration_id):\n        \"\"\"Validates that the container is allowed to create the task.\"\"\"\n\n        # check that the image is allowed: algorithm containers can only\n        # create tasks with the same image\n        if not image.endswith(container[\"image\"]):\n            log.warning((f\"Container from node={container['node_id']} \"\n                        f\"attempts to post a task using illegal image!?\"))\n            log.warning(f\"  task image: {image}\")\n            log.warning(f\"  container image: {container['image']}\")\n            return False\n\n        # check that parent task is not completed yet\n        if has_task_finished(db.Task.get(container[\"task_id\"]).status):\n            log.warning(\n                f\"Container from node={container['node_id']} \"\n                f\"attempts to start sub-task for a completed \"\n                f\"task={container['task_id']}\"\n            )\n            return False\n\n        # check that node id is indeed part of the collaboration\n        if not container[\"collaboration_id\"] == collaboration_id:\n            log.warning(\n                f\"Container attempts to create a task outside \"\n                f\"collaboration_id={container['collaboration_id']} in \"\n                f\"collaboration_id={collaboration_id}!\"\n            )\n            return False\n\n        return True\n\n    @staticmethod\n    def _node_doesnt_allow_user_task(\n        node_configs: list[db.NodeConfig]\n    ) -> bool:\n        \"\"\"\n        Checks if the node allows user to create task.\n\n        Parameters\n        ----------\n        node_configs : list[db.NodeConfig]\n            List of node configurations.\n\n        Returns\n        -------\n        bool\n            True if the node doesn't allow the user to create task.\n        \"\"\"\n        has_limitations = False\n        for config_option in node_configs:\n            if config_option.key == \"allowed_users\":\n                has_limitations = True\n                # TODO expand when we allow also usernames, like orgs below\n                if g.user.id == int(config_option.value):\n                    return False\n            elif config_option.key == \"allowed_orgs\":\n                has_limitations = True\n                if config_option.value.isdigit():\n                    if g.user.organization_id == int(config_option.value):\n                        return False\n                else:\n                    org = db.Organization.get_by_name(config_option.value)\n                    if org and g.user.organization_id == org.id:\n                        return False\n        return has_limitations\n\n\nclass Task(TaskBase):\n    \"\"\"Resource for /api/task\"\"\"\n\n    @only_for((\"user\", \"node\", \"container\"))\n    def get(self, id):\n        \"\"\"Get task\n        ---\n        description: >-\n          Returns the task specified by the id.\n\n          ### Permission Table\\n\n          |Rule name|Scope|Operation|Assigned to node|Assigned to container|\n          Description|\\n\n          |--|--|--|--|--|--|\\n\n          |Task|Global|View|\u274c|\u274c|View any task|\\n\n          |Task|Collaboration|View|\u2705|\u2705|View any task in your collaborations|\n          |Task|Organization|View|\u274c|\u274c|View any task that your organization\n          created|\\n\n          |Task|Own|View|\u274c|\u274c|View any task that you created|\\n\n\n          Accessible to users.\n\n        parameters:\n          - in: path\n            name: id\n            schema:\n              type: integer\n            description: Task id\n            required: true\n          - in: query\n            name: include\n            schema:\n              type: string\n            description: Include 'results' to include the task's results,\n              'runs' to include details on algorithm runs. For including\n              multiple, do either `include=x,y` or `include=x&include=y`.\n\n        responses:\n          200:\n            description: Ok\n          404:\n            description: Task not found\n          401:\n            description: Unauthorized\n\n        security:\n          - bearerAuth: []\n\n        tags: [\"Task\"]\n        \"\"\"\n        task = db.Task.get(id)\n        if not task:\n            return {\"msg\": f\"task id={id} is not found\"}, HTTPStatus.NOT_FOUND\n\n        # obtain schema\n        schema = self._select_schema()\n\n        # check permissions\n        if not self.r.can_for_org(P.VIEW, task.init_org_id) \\\n                and not (self.r.v_own.can() and g.user and\n                         task.init_user_id == g.user.id):\n            return {'msg': 'You lack the permission to do that!'}, \\\n                HTTPStatus.UNAUTHORIZED\n        # if results are included, check permissions for results\n        if self.is_included('results') and not \\\n                self.r_run.can_for_org(P.VIEW, task.init_org_id) \\\n                and not (self.r.v_own.can() and g.user and\n                         task.init_user_id == g.user.id):\n            return {'msg': 'You lack the permission to view results for this '\n                    'task!'}, HTTPStatus.UNAUTHORIZED\n\n        return schema.dump(task, many=False), HTTPStatus.OK\n\n    @with_user\n    def delete(self, id):\n        \"\"\"Remove task\n        ---\n        description: >-\n          Remove tasks and their runs.\\n\n\n          ### Permission Table\\n\n          |Rule name|Scope|Operation|Assigned to node|Assigned to container|\n          Description|\\n\n          |--|--|--|--|--|--|\\n\n          |Task|Global|Delete|\u274c|\u274c|Delete a task|\\n\n          |Task|Collaboration|Delete|\u274c|\u274c|Delete a task from a collaboration\n          in which your organization participates|\\n\n          |Task|Organization|Delete|\u274c|\u274c|Delete a task that your organization\n          initiated|\\n\n          |Task|Own|Delete|\u274c|\u274c|Delete a task you created yourself|\\n\n\n          Accessible to users.\n\n        parameters:\n          - in: path\n            name: id\n            schema:\n              type: integer\n            description: Task id\n            required: true\n\n        responses:\n          200:\n            description: Ok\n          404:\n            description: Task not found\n          401:\n            description: Unauthorized\n\n        security:\n          - bearerAuth: []\n\n        tags: [\"Task\"]\n        \"\"\"\n\n        task = db.Task.get(id)\n        if not task:\n            return {\"msg\": f\"Task id={id} not found\"}, HTTPStatus.NOT_FOUND\n\n        # validate permissions\n        if not self.r.can_for_org(P.DELETE, task.init_org_id) and \\\n                not (self.r.d_own.can() and task.init_user_id == g.user.id):\n            return {'msg': 'You lack the permission to do that!'}, \\\n                HTTPStatus.UNAUTHORIZED\n\n        # kill the task if it is still running\n        if not has_task_finished(task.status):\n            kill_task(task, self.socketio)\n\n        # retrieve runs that belong to this task\n        log.info(f'Removing task id={task.id}')\n        for run in task.runs:\n            log.info(f\" Removing run id={run.id}\")\n            run.delete()\n\n        # delete child/grandchild/... tasks\n        Task._delete_subtasks(task)\n\n        # permissions ok, delete...\n        task.delete()\n\n        return {\"msg\": f\"task id={id} and its algorithm run data have been \"\n                       \"successfully deleted\"}, HTTPStatus.OK\n\n    @staticmethod\n    def _delete_subtasks(task: db.Task) -> None:\n        \"\"\"\n        Delete subtasks recursively.\n\n        Parameters\n        ----------\n        task : db.Task\n            Task to delete.\n        \"\"\"\n        for child_task in task.children:\n            Task._delete_subtasks(child_task)\n            log.info(f\" Removing child task id={child_task.id}\")\n            child_task.delete()\n"], "fixing_code": ["# -*- coding: utf-8 -*-\nimport logging\nimport json\n\nfrom flask import g, request, url_for\nfrom flask_restful import Api\nfrom flask_socketio import SocketIO\nfrom http import HTTPStatus\nfrom sqlalchemy import desc\nfrom sqlalchemy.sql import visitors\n\nfrom vantage6.common.globals import STRING_ENCODING\nfrom vantage6.common.task_status import TaskStatus, has_task_finished\nfrom vantage6.common.encryption import DummyCryptor\nfrom vantage6.server import db\nfrom vantage6.server.permission import (\n    RuleCollection,\n    Scope as S,\n    PermissionManager,\n    Operation as P\n)\nfrom vantage6.server.resource import only_for, ServicesResources, with_user\nfrom vantage6.server.resource.common.output_schema import (\n    TaskSchema,\n    TaskWithResultSchema,\n    TaskWithRunSchema,\n    TaskWithRunAndResultSchema,\n)\nfrom vantage6.server.resource.common.input_schema import TaskInputSchema\nfrom vantage6.server.resource.common.pagination import Pagination\nfrom vantage6.server.resource.event import kill_task\n\n\nmodule_name = __name__.split('.')[-1]\nlog = logging.getLogger(module_name)\n\n\ndef setup(api: Api, api_base: str, services: dict) -> None:\n    \"\"\"\n    Setup the task resource.\n\n    Parameters\n    ----------\n    api : Api\n        Flask restful api instance\n    api_base : str\n        Base url of the api\n    services : dict\n        Dictionary with services required for the resource endpoints\n    \"\"\"\n    path = \"/\".join([api_base, module_name])\n    log.info(f'Setting up \"{path}\" and subdirectories')\n\n    api.add_resource(\n        Tasks,\n        path,\n        endpoint='task_without_id',\n        methods=('GET', 'POST'),\n        resource_class_kwargs=services\n    )\n    api.add_resource(\n        Task,\n        path + '/<int:id>',\n        endpoint='task_with_id',\n        methods=('GET', 'DELETE'),\n        resource_class_kwargs=services\n    )\n\n\n# -----------------------------------------------------------------------------\n# Permissions\n# -----------------------------------------------------------------------------\ndef permissions(permissions: PermissionManager) -> None:\n    \"\"\"\n    Define the permissions for this resource.\n\n    Parameters\n    ----------\n    permissions : PermissionManager\n        Permission manager instance to which permissions are added\n    \"\"\"\n    add = permissions.appender(module_name)\n\n    add(scope=S.GLOBAL, operation=P.VIEW, description=\"view any task\")\n    add(scope=S.COLLABORATION, operation=P.VIEW, assign_to_container=True,\n        assign_to_node=True, description=\"view tasks of your collaborations\")\n    add(scope=S.ORGANIZATION, operation=P.VIEW,\n        description=\"view tasks that your organization initiated\")\n    add(scope=S.OWN, operation=P.VIEW,\n        description=\"view tasks that you initiated\")\n\n    add(scope=S.GLOBAL, operation=P.CREATE, description=\"create a new task\")\n    add(scope=S.COLLABORATION, operation=P.CREATE,\n        description=(\n            \"create a new task for collaborations in which your organization \"\n            \"participates with\"\n        ))\n\n    add(scope=S.GLOBAL, operation=P.DELETE,\n        description=\"delete a task\")\n    add(scope=S.COLLABORATION, operation=P.DELETE,\n        description=\"delete a task from your collaborations\")\n    add(scope=S.ORGANIZATION, operation=P.DELETE,\n        description=(\n            \"delete a task from a collaboration in which your organization \"\n            \"participates with\"\n        ))\n    add(scope=S.OWN, operation=P.DELETE,\n        description=\"delete tasks that you created\")\n\n\n# ------------------------------------------------------------------------------\n# Resources / API's\n# ------------------------------------------------------------------------------\ntask_schema = TaskSchema()\ntask_run_schema = TaskWithRunSchema()\ntask_result_schema = TaskWithResultSchema()\ntask_result_run_schema = TaskWithRunAndResultSchema()\n\ntask_input_schema = TaskInputSchema()\n\n\nclass TaskBase(ServicesResources):\n\n    def __init__(self, socketio, mail, api, permissions, config):\n        super().__init__(socketio, mail, api, permissions, config)\n        self.r: RuleCollection = getattr(self.permissions, module_name)\n        # permissions for the run resource are also relevant for the task\n        # resource as they are sometimes included\n        self.r_run: RuleCollection = getattr(self.permissions, 'run')\n\n    def _select_schema(self) -> TaskSchema:\n        \"\"\"\n        Select the schema to use for serialization.\n\n        Returns\n        -------\n        TaskSchema\n            Schema to use for serialization\n        \"\"\"\n        if self.is_included('runs') and self.is_included('results'):\n            return task_result_run_schema\n        elif self.is_included('runs'):\n            return task_run_schema\n        elif self.is_included('results'):\n            return task_result_schema\n        else:\n            return task_schema\n\n\nclass Tasks(TaskBase):\n\n    @only_for((\"user\", \"node\", \"container\"))\n    def get(self):\n        \"\"\"List tasks\n        ---\n        description: >-\n          Returns a list of tasks.\\n\n\n          ### Permission Table\\n\n          |Rule name|Scope|Operation|Assigned to node|Assigned to container|\n          Description|\\n\n          |--|--|--|--|--|--|\\n\n          |Task|Global|View|\u274c|\u274c|View any task|\\n\n          |Task|Collaboration|View|\u2705|\u2705|View any task in your collaborations|\n          \\n\n          |Task|Organization|View|\u274c|\u274c|View any task that your organization\n          created|\\n\n          |Task|Own|View|\u274c|\u274c|View any task that you created|\\n\n\n          Accessible to users.\n\n        parameters:\n          - in: query\n            name: init_org_id\n            schema:\n              type: int\n            description: The organization id of the origin of the request\n          - in: query\n            name: init_user_id\n            schema:\n              type: int\n            description: The user id of the user that started the task\n          - in: query\n            name: collaboration_id\n            schema:\n              type: int\n            description: The collaboration id to which the task belongs\n          - in: query\n            name: is_user_created\n            schema:\n              type: int\n            description: >-\n              If larger than 0, returns tasks created by a user (top-level\n              tasks). If equal to 0, returns subtask created by an algorithm.\n              If not specified, both are returned.\n          - in: query\n            name: image\n            schema:\n              type: str\n            description: >-\n              (Docker) image name which is used in the task. Name to match\n              with a LIKE operator. \\n\n              * The percent sign (%) represents zero, one, or multiple\n              characters\\n\n              * underscore sign (_) represents one, single character\n          - in: query\n            name: parent_id\n            schema:\n              type: int\n            description: The id of the parent task\n          - in: query\n            name: job_id\n            schema:\n              type: int\n            description: The run id that belongs to the task\n          - in: query\n            name: name\n            schema:\n              type: str\n            description: >-\n              Name to match with a LIKE operator. \\n\n              * The percent sign (%) represents zero, one, or multiple\n              characters\\n\n              * underscore sign (_) represents one, single character\n          - in: query\n            name: description\n            schema:\n              type: string\n            description: >-\n              Description to match with a LIKE operator. \\n\n              * The percent sign (%) represents zero, one, or multiple\n              characters\\n\n              * underscore sign (_) represents one, single character\n          - in: query\n            name: database\n            schema:\n              type: string\n            description: >-\n              Database description to match with a LIKE operator. \\n\n              * The percent sign (%) represents zero, one, or multiple\n              characters\\n\n              * underscore sign (_) represents one, single character\n          - in: query\n            name: run_id\n            schema:\n              type: int\n            description: A run id that belongs to the task\n          - in: query\n            name: include\n            schema:\n              type: array\n              items:\n                type: string\n            description: Include 'results' to include the task's results,\n              'runs' to include details on algorithm runs. For including\n               multiple, do either `include=x,y` or `include=x&include=y`.\n          - in: query\n            name: status\n            schema:\n              type: string\n            description: Filter by task status, e.g. 'active' for active\n              tasks, 'completed' for finished or 'crashed' for failed tasks.\n          - in: query\n            name: page\n            schema:\n              type: integer\n            description: Page number for pagination (default=1)\n          - in: query\n            name: per_page\n            schema:\n              type: integer\n            description: Number of items per page (default=10)\n          - in: query\n            name: sort\n            schema:\n              type: string\n            description: >-\n              Sort by one or more fields, separated by a comma. Use a minus\n              sign (-) in front of the field to sort in descending order.\n\n        responses:\n          200:\n            description: Ok\n          400:\n            description: Non-allowed or wrong parameter values\n          401:\n            description: Unauthorized\n\n        security:\n            - bearerAuth: []\n\n        tags: [\"Task\"]\n        \"\"\"\n        q = g.session.query(db.Task)\n        args = request.args\n\n        auth_org_id = self.obtain_organization_id()\n\n        # check permissions and apply filter if neccassary\n        if not self.r.v_glo.can():\n            if self.r.v_col.can():\n                q = q.join(db.Collaboration).join(db.Organization)\\\n                    .filter(db.Collaboration.organizations.any(id=auth_org_id))\n            elif self.r.v_org.can():\n                q = q.join(db.Organization)\\\n                    .filter(db.Task.init_org_id == auth_org_id)\n            elif self.r.v_own.can():\n                q = q.filter(db.Task.init_user_id == g.user.id)\n            else:\n                return {'msg': 'You lack the permission to do that!'}, \\\n                    HTTPStatus.UNAUTHORIZED\n        # if results are included, check permissions on results\n        if self.is_included('results'):\n            max_scope_task = self.r.get_max_scope(P.VIEW)\n            if not self.r_run.has_at_least_scope(max_scope_task, P.VIEW):\n                max_scope_run = self.r_run.get_max_scope(P.VIEW)\n                return {\n                    'msg': 'You cannot view the results of all tasks, as you '\n                    f'are allowed to view tasks with scope {max_scope_task} '\n                    f'but you can only view results with scope {max_scope_run}'\n                }, HTTPStatus.UNAUTHORIZED\n\n        if 'collaboration_id' in args:\n            collaboration_id = int(args['collaboration_id'])\n            if not self.r.can_for_col(P.VIEW, collaboration_id):\n                return {'msg': 'You lack the permission to view tasks '\n                        f'from collaboration {collaboration_id}!'}, \\\n                    HTTPStatus.UNAUTHORIZED\n            # dont join collaboration table if it is already joined\n            # FIXME refactor this after moving to SQLAlchemy 2.0\n            has_already_joined_collab = False\n            for visitor in visitors.iterate(q.statement):\n                if visitor.__visit_name__ == 'table' and \\\n                        visitor.name == 'collaboration':\n                    has_already_joined_collab = True\n            if not has_already_joined_collab:\n                q = q.join(db.Collaboration)\n            q = q.filter(db.Collaboration.id == collaboration_id)\n\n        if 'init_org_id' in args:\n            init_org_id = int(args['init_org_id'])\n            if not self.r.can_for_org(P.VIEW, init_org_id):\n                return {'msg': 'You lack the permission to view tasks '\n                        f'from organization id={init_org_id}!'}, \\\n                    HTTPStatus.UNAUTHORIZED\n            q = q.filter(db.Task.init_org_id == init_org_id)\n\n        if 'init_user_id' in args:\n            init_user_id = int(args['init_user_id'])\n            init_user = db.User.get(init_user_id)\n            if not init_user:\n                return {'msg': f'User id={init_user_id} does not '\n                        'exist!'}, HTTPStatus.BAD_REQUEST\n            elif not self.r.can_for_org(P.VIEW, init_user.organization_id) \\\n                    and not (self.r.v_own.can() and g.user and\n                             init_user.id == g.user.id):\n                return {'msg': 'You lack the permission to view tasks '\n                        f'from user id={init_user_id}!'}, \\\n                    HTTPStatus.UNAUTHORIZED\n            q = q.filter(db.Task.init_user_id == init_user_id)\n\n        if 'parent_id' in args:\n            parent_id = int(args['parent_id'])\n            parent = db.Task.get(parent_id)\n            if not parent:\n                return {'msg': f'Parent task id={args[\"parent_id\"]} does not '\n                        'exist!'}, HTTPStatus.BAD_REQUEST\n            elif not self.r.can_for_col(P.VIEW, parent.collaboration_id):\n                return {'msg': 'You lack the permission to view tasks '\n                        'from the collaboration that the task with parent_id='\n                        f'{parent.collaboration_id} belongs to!'}, \\\n                    HTTPStatus.UNAUTHORIZED\n            q = q.filter(db.Task.parent_id == int(parent_id))\n\n        if 'job_id' in args:\n            job_id = int(args['job_id'])\n            task_in_job = q.session.query(db.Task).filter(\n                db.Task.job_id == job_id).first()\n            if not task_in_job:\n                return {'msg': f'Job id={args[\"job_id\"]} does not exist!'}, \\\n                    HTTPStatus.BAD_REQUEST\n            elif not self.r.can_for_col(P.VIEW, task_in_job.collaboration_id):\n                return {'msg': 'You lack the permission to view tasks '\n                        'from the collaboration that the task with job_id='\n                        f'{task_in_job.collaboration_id} belongs to!'}, \\\n                    HTTPStatus.UNAUTHORIZED\n            q = q.filter(db.Task.job_id == job_id)\n\n        for param in ['name', 'image', 'description', 'status']:\n            if param in args:\n                q = q.filter(getattr(db.Task, param).like(args[param]))\n\n        if 'run_id' in args:\n            run_id = int(args['run_id'])\n            run = db.Run.get(run_id)\n            if not run:\n                return {'msg': f'Run id={args[\"run_id\"]} does not exist!'}, \\\n                    HTTPStatus.BAD_REQUEST\n            elif not self.r.can_for_col(P.VIEW, run.collaboration_id):\n                return {'msg': 'You lack the permission to view tasks '\n                        'from the collaboration that the run with id='\n                        f'{run.collaboration_id} belongs to!'}, \\\n                    HTTPStatus.UNAUTHORIZED\n            q = q.join(db.Run).filter(db.Run.id == run_id)\n\n        if 'database' in args:\n            q = q.join(db.TaskDatabase)\\\n                 .filter(db.TaskDatabase.database == args['database'])\n\n        if 'is_user_created' in args:\n            try:\n                user_created = int(args['is_user_created'])\n                if user_created == 0:\n                    q = q.filter(db.Task.parent_id.isnot(None))\n                else:\n                    q = q.filter(db.Task.parent_id.is_(None))\n            except ValueError:\n                return {\"msg\": (\n                    \"Invalid value for 'is_user_created' provided: \"\n                    f\"'{args['is_user_created']}'. Should be an integer.\"\n                )}, HTTPStatus.BAD_REQUEST\n\n        # order to get latest task first\n        q = q.order_by(desc(db.Task.id))\n\n        # paginate tasks\n        try:\n            page = Pagination.from_query(q, request, db.Task)\n        except (ValueError, AttributeError) as e:\n            return {'msg': str(e)}, HTTPStatus.BAD_REQUEST\n\n        # serialization schema\n        schema = self._select_schema()\n\n        return self.response(page, schema)\n\n    @only_for((\"user\", \"container\"))\n    def post(self):\n        \"\"\"Adds new computation task\n        ---\n        description: >-\n          Creates a new task within a collaboration. If no `organization_ids`\n          are given the task is send to all organizations within the\n          collaboration. The endpoint can be accessed by both a `User` and\n          `Container`.\\n\n\n          ### Permission Table\\n\n          |Rule name|Scope|Operation|Assigned to node|Assigned to container|\n          Description|\\n\n          |--|--|--|--|--|--|\\n\n          |Task|Global|Create|\u274c|\u274c|Create a new task|\\n\n          |Task|Collaboration|Create|\u274c|\u2705|Create a new task for a specific\n          collaboration in which your organization participates|\\n\n\n          ## Accessed as `User`\\n\n          This endpoint is accessible to users. A new `job_id` is\n          created when a user creates a task. The user needs to be within an\n          organization that is part of the collaboration to which the task is\n          posted.\\n\n\n          ## Accessed as `Container`\\n\n          When this endpoint is accessed by an algorithm container, it is\n          considered to be a child-task of the container, and will get the\n          `job_id` from the initial task. Containers have limited permissions\n          to create tasks: they are only allowed to create tasks in the same\n          collaboration using the same image.\\n\n\n        requestBody:\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/Task'\n\n        responses:\n          200:\n            description: Ok\n          400:\n            description: Supplied organizations are not in the supplied\n              collaboration, or not all required nodes are registered, or you\n              are not in the collaboration yourself\n          401:\n            description: Unauthorized\n          404:\n            description: Collaboration with `collaboration_id` not found\n\n        security:\n          - bearerAuth: []\n\n        tags: [\"Task\"]\n        \"\"\"\n        return self.post_task(request.get_json(), self.socketio, self.r)\n\n    # TODO this function should be refactored to make it more readable\n    @staticmethod\n    def post_task(data: dict, socketio: SocketIO, rules: RuleCollection):\n        \"\"\"\n        Create new task and algorithm runs. Send the task to the nodes.\n\n        Parameters\n        ----------\n        data : dict\n            Task data\n        \"\"\"\n        # validate request body\n        errors = task_input_schema.validate(data)\n        if errors:\n            return {'msg': 'Request body is incorrect', 'errors': errors}, \\\n                HTTPStatus.BAD_REQUEST\n\n        collaboration_id = data.get('collaboration_id')\n        collaboration = db.Collaboration.get(collaboration_id)\n\n        if not collaboration:\n            return {\n                \"msg\": f\"Collaboration id={collaboration_id} not found!\"\n            }, HTTPStatus.NOT_FOUND\n\n        organizations_json_list = data.get('organizations')\n        org_ids = [org.get(\"id\") for org in organizations_json_list]\n        db_ids = collaboration.get_organization_ids()\n\n        # Check that all organization ids are within the collaboration, this\n        # also ensures us that the organizations exist\n        if not set(org_ids).issubset(db_ids):\n            return {\"msg\": (\n                \"At least one of the supplied organizations in not within \"\n                \"the collaboration.\"\n            )}, HTTPStatus.BAD_REQUEST\n\n        # check if all the organizations have a registered node\n        nodes = g.session.query(db.Node)\\\n            .filter(db.Node.organization_id.in_(org_ids))\\\n            .filter(db.Node.collaboration_id == collaboration_id)\\\n            .all()\n        if len(nodes) < len(org_ids):\n            present_nodes = [node.organization_id for node in nodes]\n            missing = [str(id) for id in org_ids if id not in present_nodes]\n            return {\"msg\": (\n                \"Cannot create this task because there are no nodes registered\"\n                f\" for the following organization(s): {', '.join(missing)}.\"\n            )}, HTTPStatus.BAD_REQUEST\n        # check if any of the nodes that are offline shared their configuration\n        # info and if this prevents this user from creating this task\n        if g.user:\n            for node in nodes:\n                if Tasks._node_doesnt_allow_user_task(node.config):\n                    return {\"msg\": (\n                        \"Cannot create this task because one of the nodes that\"\n                        \" you are trying to send this task to does not allow \"\n                        \"you to create tasks.\"\n                    )}, HTTPStatus.BAD_REQUEST\n\n        # figure out the initiating organization of the task\n        if g.user:\n            init_org = g.user.organization\n        else:  # g.container:\n            init_org = db.Node.get(g.container[\"node_id\"]).organization\n\n        # check if the initiating organization is part of the collaboration\n        if init_org not in collaboration.organizations:\n            return {\n                \"msg\": \"You can only create tasks for collaborations \"\n                       \"you are participating in!\"\n            }, HTTPStatus.UNAUTHORIZED\n\n        # verify permissions\n        image = data.get('image', '')\n        if g.user and not rules.can_for_col(P.CREATE, collaboration.id):\n            return {'msg': 'You lack the permission to do that!'}, \\\n                HTTPStatus.UNAUTHORIZED\n\n        elif g.container:\n            # verify that the container has permissions to create the task\n            if not Tasks.__verify_container_permissions(g.container, image,\n                                                        collaboration_id):\n                return {\"msg\": \"Container-token is not valid\"}, \\\n                    HTTPStatus.UNAUTHORIZED\n\n        # check that the input is valid. If the collaboration is encrypted, it\n        # should not be possible to read the input, and we should not save it\n        # to the database as it may be sensitive information. Vice versa, if\n        # the collaboration is not encrypted, we should not allow the user to\n        # send encrypted input.\n        is_valid_input, error_msg = Tasks._check_input_encryption(\n            organizations_json_list, collaboration\n        )\n        if not is_valid_input:\n            return {\"msg\": error_msg}, HTTPStatus.BAD_REQUEST\n\n        # permissions ok, create task record and TaskDatabase records\n        task = db.Task(collaboration=collaboration, name=data.get('name', ''),\n                       description=data.get('description', ''), image=image,\n                       init_org=init_org)\n\n        # create job_id. Users can only create top-level -tasks (they will not\n        # have sub-tasks). Therefore, always create a new job_id. Tasks created\n        # by containers are always sub-tasks\n        if g.user:\n            task.job_id = task.next_job_id()\n            task.init_user_id = g.user.id\n            log.debug(f\"New job_id {task.job_id}\")\n        elif g.container:\n            task.parent_id = g.container[\"task_id\"]\n            parent = db.Task.get(g.container[\"task_id\"])\n            task.job_id = parent.job_id\n            task.init_user_id = parent.init_user_id\n            log.debug(f\"Sub task from parent_id={task.parent_id}\")\n\n        # save the databases that the task uses\n        databases = data.get('databases')\n        if isinstance(databases, str):\n            databases = [{'label': databases}]\n        elif databases is None:\n            databases = []\n        db_records = []\n        for database in databases:\n            if 'label' not in database:\n                return {'msg': \"Database label missing! The dictionary \"\n                        f\"{database} should contain a 'label' key\"}, \\\n                    HTTPStatus.BAD_REQUEST\n            # remove label from the database dictionary, which apart from it\n            # may only contain some optional parameters . Save optional\n            # parameters as JSON without spaces to database\n            label = database.pop('label')\n            db_records.append(db.TaskDatabase(\n                task_id=task.id,\n                database=label,\n                parameters=json.dumps(database, separators=(',', ':'))\n            ))\n\n        # All checks completed, save task to database\n        task.save()\n        [db_record.save() for db_record in db_records]  # pylint: disable=W0106\n\n        # send socket event that task has been created\n        socketio.emit(\n            \"task_created\", {\n                \"task_id\": task.id,\n                \"job_id\": task.job_id,\n                \"collaboration_id\": collaboration_id,\n                \"init_org_id\": init_org.id,\n            }, room=f\"collaboration_{collaboration_id}\", namespace='/tasks'\n        )\n\n        # now we need to create results for the nodes to fill. Each node\n        # receives their instructions from a result, not from the task itself\n        log.debug(f\"Assigning task to {len(organizations_json_list)} nodes.\")\n        for org in organizations_json_list:\n            organization = db.Organization.get(org['id'])\n            log.debug(f\"Assigning task to '{organization.name}'.\")\n            input_ = org.get('input')\n            # FIXME: legacy input from the client, could be removed at some\n            # point\n            if isinstance(input_, dict):\n                input_ = json.dumps(input_).encode(STRING_ENCODING)\n            # Create run\n            run = db.Run(\n                task=task,\n                organization=organization,\n                input=input_,\n                status=TaskStatus.PENDING\n            )\n            run.save()\n\n        # notify nodes a new task available (only to online nodes), nodes that\n        # are offline will receive this task on sign in.\n        socketio.emit('new_task', task.id, namespace='/tasks',\n                      room=f'collaboration_{task.collaboration_id}')\n\n        # add some logging\n        log.info(f\"New task for collaboration '{task.collaboration.name}'\")\n        if g.user:\n            log.debug(f\" created by: '{g.user.username}'\")\n        else:\n            log.debug(f\" created by container on node_id=\"\n                      f\"{g.container['node_id']}\"\n                      f\" for (parent) task_id={g.container['task_id']}\")\n\n        log.debug(f\" url: '{url_for('task_with_id', id=task.id)}'\")\n        log.debug(f\" name: '{task.name}'\")\n        log.debug(f\" image: '{task.image}'\")\n\n        return task_schema.dump(task, many=False), HTTPStatus.CREATED\n\n    @staticmethod\n    def __verify_container_permissions(container, image, collaboration_id):\n        \"\"\"Validates that the container is allowed to create the task.\"\"\"\n\n        # check that the image is allowed: algorithm containers can only\n        # create tasks with the same image\n        if not image.endswith(container[\"image\"]):\n            log.warning((f\"Container from node={container['node_id']} \"\n                        f\"attempts to post a task using illegal image!?\"))\n            log.warning(f\"  task image: {image}\")\n            log.warning(f\"  container image: {container['image']}\")\n            return False\n\n        # check that parent task is not completed yet\n        if has_task_finished(db.Task.get(container[\"task_id\"]).status):\n            log.warning(\n                f\"Container from node={container['node_id']} \"\n                f\"attempts to start sub-task for a completed \"\n                f\"task={container['task_id']}\"\n            )\n            return False\n\n        # check that node id is indeed part of the collaboration\n        if not container[\"collaboration_id\"] == collaboration_id:\n            log.warning(\n                f\"Container attempts to create a task outside \"\n                f\"collaboration_id={container['collaboration_id']} in \"\n                f\"collaboration_id={collaboration_id}!\"\n            )\n            return False\n\n        return True\n\n    @staticmethod\n    def _node_doesnt_allow_user_task(\n        node_configs: list[db.NodeConfig]\n    ) -> bool:\n        \"\"\"\n        Checks if the node allows user to create task.\n\n        Parameters\n        ----------\n        node_configs : list[db.NodeConfig]\n            List of node configurations.\n\n        Returns\n        -------\n        bool\n            True if the node doesn't allow the user to create task.\n        \"\"\"\n        has_limitations = False\n        for config_option in node_configs:\n            if config_option.key == \"allowed_users\":\n                has_limitations = True\n                # TODO expand when we allow also usernames, like orgs below\n                if g.user.id == int(config_option.value):\n                    return False\n            elif config_option.key == \"allowed_orgs\":\n                has_limitations = True\n                if config_option.value.isdigit():\n                    if g.user.organization_id == int(config_option.value):\n                        return False\n                else:\n                    org = db.Organization.get_by_name(config_option.value)\n                    if org and g.user.organization_id == org.id:\n                        return False\n        return has_limitations\n\n    @staticmethod\n    def _check_input_encryption(\n        organizations_json_list: list[dict], collaboration: db.Collaboration\n    ) -> tuple[bool, str]:\n        \"\"\"\n        Check if the input encryption status matches the expected status for\n        the collaboration. Also, check that if the input is not encrypted, it\n        can be read as a string.\n\n        Parameters\n        ----------\n        organizations_json_list : list[dict]\n            List of organizations which contains the input per organization.\n        collaboration : db.Collaboration\n            Collaboration object.\n\n        Returns\n        -------\n        bool\n            True if the input is encrypted.\n        str\n            Error message if the input is valid.\n        \"\"\"\n        dummy_cryptor = DummyCryptor()\n        for org in organizations_json_list:\n            input_ = org.get('input')\n            decrypted_input = dummy_cryptor.decrypt_str_to_bytes(input_)\n            is_input_readable = False\n            try:\n                decrypted_input.decode(STRING_ENCODING)\n                is_input_readable = True\n            except UnicodeDecodeError:\n                pass\n\n            if collaboration.encrypted and is_input_readable:\n                return False,  (\n                    \"Your collaboration requires encryption, but input is not \"\n                    \"encrypted! Please encrypt your input before sending it.\"\n                ),\n            elif not collaboration.encrypted and not is_input_readable:\n                return False, (\n                    \"Your task's input cannot be parsed. Your input should be \"\n                    \"a base64 encoded JSON string. Note that if you are using \"\n                    \"the user interface or Python client, this should be done \"\n                    \"for you. Also, make sure not to encrypt your input, \"\n                    \"as your collaboration is set to not use encryption.\"\n                )\n        return True, ''\n\n\nclass Task(TaskBase):\n    \"\"\"Resource for /api/task\"\"\"\n\n    @only_for((\"user\", \"node\", \"container\"))\n    def get(self, id):\n        \"\"\"Get task\n        ---\n        description: >-\n          Returns the task specified by the id.\n\n          ### Permission Table\\n\n          |Rule name|Scope|Operation|Assigned to node|Assigned to container|\n          Description|\\n\n          |--|--|--|--|--|--|\\n\n          |Task|Global|View|\u274c|\u274c|View any task|\\n\n          |Task|Collaboration|View|\u2705|\u2705|View any task in your collaborations|\n          |Task|Organization|View|\u274c|\u274c|View any task that your organization\n          created|\\n\n          |Task|Own|View|\u274c|\u274c|View any task that you created|\\n\n\n          Accessible to users.\n\n        parameters:\n          - in: path\n            name: id\n            schema:\n              type: integer\n            description: Task id\n            required: true\n          - in: query\n            name: include\n            schema:\n              type: string\n            description: Include 'results' to include the task's results,\n              'runs' to include details on algorithm runs. For including\n              multiple, do either `include=x,y` or `include=x&include=y`.\n\n        responses:\n          200:\n            description: Ok\n          404:\n            description: Task not found\n          401:\n            description: Unauthorized\n\n        security:\n          - bearerAuth: []\n\n        tags: [\"Task\"]\n        \"\"\"\n        task = db.Task.get(id)\n        if not task:\n            return {\"msg\": f\"task id={id} is not found\"}, HTTPStatus.NOT_FOUND\n\n        # obtain schema\n        schema = self._select_schema()\n\n        # check permissions\n        if not self.r.can_for_org(P.VIEW, task.init_org_id) \\\n                and not (self.r.v_own.can() and g.user and\n                         task.init_user_id == g.user.id):\n            return {'msg': 'You lack the permission to do that!'}, \\\n                HTTPStatus.UNAUTHORIZED\n        # if results are included, check permissions for results\n        if self.is_included('results') and not \\\n                self.r_run.can_for_org(P.VIEW, task.init_org_id) \\\n                and not (self.r.v_own.can() and g.user and\n                         task.init_user_id == g.user.id):\n            return {'msg': 'You lack the permission to view results for this '\n                    'task!'}, HTTPStatus.UNAUTHORIZED\n\n        return schema.dump(task, many=False), HTTPStatus.OK\n\n    @with_user\n    def delete(self, id):\n        \"\"\"Remove task\n        ---\n        description: >-\n          Remove tasks and their runs.\\n\n\n          ### Permission Table\\n\n          |Rule name|Scope|Operation|Assigned to node|Assigned to container|\n          Description|\\n\n          |--|--|--|--|--|--|\\n\n          |Task|Global|Delete|\u274c|\u274c|Delete a task|\\n\n          |Task|Collaboration|Delete|\u274c|\u274c|Delete a task from a collaboration\n          in which your organization participates|\\n\n          |Task|Organization|Delete|\u274c|\u274c|Delete a task that your organization\n          initiated|\\n\n          |Task|Own|Delete|\u274c|\u274c|Delete a task you created yourself|\\n\n\n          Accessible to users.\n\n        parameters:\n          - in: path\n            name: id\n            schema:\n              type: integer\n            description: Task id\n            required: true\n\n        responses:\n          200:\n            description: Ok\n          404:\n            description: Task not found\n          401:\n            description: Unauthorized\n\n        security:\n          - bearerAuth: []\n\n        tags: [\"Task\"]\n        \"\"\"\n\n        task = db.Task.get(id)\n        if not task:\n            return {\"msg\": f\"Task id={id} not found\"}, HTTPStatus.NOT_FOUND\n\n        # validate permissions\n        if not self.r.can_for_org(P.DELETE, task.init_org_id) and \\\n                not (self.r.d_own.can() and task.init_user_id == g.user.id):\n            return {'msg': 'You lack the permission to do that!'}, \\\n                HTTPStatus.UNAUTHORIZED\n\n        # kill the task if it is still running\n        if not has_task_finished(task.status):\n            kill_task(task, self.socketio)\n\n        # retrieve runs that belong to this task\n        log.info(f'Removing task id={task.id}')\n        for run in task.runs:\n            log.info(f\" Removing run id={run.id}\")\n            run.delete()\n\n        # delete child/grandchild/... tasks\n        Task._delete_subtasks(task)\n\n        # permissions ok, delete...\n        task.delete()\n\n        return {\"msg\": f\"task id={id} and its algorithm run data have been \"\n                       \"successfully deleted\"}, HTTPStatus.OK\n\n    @staticmethod\n    def _delete_subtasks(task: db.Task) -> None:\n        \"\"\"\n        Delete subtasks recursively.\n\n        Parameters\n        ----------\n        task : db.Task\n            Task to delete.\n        \"\"\"\n        for child_task in task.children:\n            Task._delete_subtasks(child_task)\n            log.info(f\" Removing child task id={child_task.id}\")\n            child_task.delete()\n"], "filenames": ["vantage6-server/vantage6/server/resource/task.py"], "buggy_code_start_loc": [13], "buggy_code_end_loc": [742], "fixing_code_start_loc": [14], "fixing_code_end_loc": [803], "type": "CWE-922", "message": "The vantage6 technology enables to manage and deploy privacy enhancing technologies like Federated Learning (FL) and Multi-Party Computation (MPC). There are no checks on whether the input is encrypted if a task is created in an encrypted collaboration. Therefore, a user may accidentally create a task with sensitive input data that will then be stored unencrypted in a database.  Users should ensure they set the encryption setting correctly.  This vulnerability is patched in 4.2.0.", "other": {"cve": {"id": "CVE-2024-22193", "sourceIdentifier": "security-advisories@github.com", "published": "2024-01-30T16:15:48.310", "lastModified": "2024-02-08T16:41:38.277", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The vantage6 technology enables to manage and deploy privacy enhancing technologies like Federated Learning (FL) and Multi-Party Computation (MPC). There are no checks on whether the input is encrypted if a task is created in an encrypted collaboration. Therefore, a user may accidentally create a task with sensitive input data that will then be stored unencrypted in a database.  Users should ensure they set the encryption setting correctly.  This vulnerability is patched in 4.2.0."}, {"lang": "es", "value": "La tecnolog\u00eda vantage6 permite gestionar e implementar tecnolog\u00edas que mejoran la privacidad, como el Federated Learning (FL) y la Multi-Party Computation (MPC). No se comprueba si la entrada est\u00e1 cifrada si se crea una tarea en una colaboraci\u00f3n cifrada. Por lo tanto, un usuario puede crear accidentalmente una tarea con datos de entrada confidenciales que luego se almacenar\u00e1n sin cifrar en una base de datos. Los usuarios deben asegurarse de configurar correctamente la configuraci\u00f3n de cifrado. Esta vulnerabilidad est\u00e1 parcheada en 4.2.0."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 3.5, "baseSeverity": "LOW"}, "exploitabilityScore": 2.1, "impactScore": 1.4}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-922"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vantage6:vantage6:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.2.0", "matchCriteriaId": "A9E3A3A7-C004-4E76-B2A3-46F0F1C68AD4"}]}]}], "references": [{"url": "https://github.com/vantage6/vantage6/commit/6383283733b81abfcacfec7538dc4dc882e98074", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/vantage6/vantage6/security/advisories/GHSA-rjmv-52mp-gjrr", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/vantage6/vantage6/commit/6383283733b81abfcacfec7538dc4dc882e98074"}}