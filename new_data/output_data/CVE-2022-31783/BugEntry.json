{"buggy_code": ["/* liblouis Braille Translation and Back-Translation Library\n\n   Based on the Linux screenreader BRLTTY, copyright (C) 1999-2006 by The\n   BRLTTY Team\n\n   Copyright (C) 2004, 2005, 2006 ViewPlus Technologies, Inc. www.viewplus.com\n   Copyright (C) 2004, 2005, 2006 JJB Software, Inc. www.jjb-software.com\n   Copyright (C) 2016 Mike Gray, American Printing House for the Blind\n   Copyright (C) 2016 Davy Kager, Dedicon\n\n   This file is part of liblouis.\n\n   liblouis is free software: you can redistribute it and/or modify it\n   under the terms of the GNU Lesser General Public License as published\n   by the Free Software Foundation, either version 2.1 of the License, or\n   (at your option) any later version.\n\n   liblouis is distributed in the hope that it will be useful, but\n   WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n   Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public\n   License along with liblouis. If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/**\n * @file\n * @brief Read and compile translation tables\n */\n\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <ctype.h>\n#include <sys/stat.h>\n\n#include \"internal.h\"\n#include \"config.h\"\n\n#define QUOTESUB 28 /* Stand-in for double quotes in strings */\n\n/* needed to make debuggin easier */\n#ifdef DEBUG\nwchar_t wchar;\n#endif\n\n/* The following variables and functions make it possible to specify the\n * path on which all tables for liblouis and all files for liblouisutdml,\n * in their proper directories, will be found.\n */\n\nstatic char *dataPathPtr;\n\nchar *EXPORT_CALL\nlou_setDataPath(const char *path) {\n\tstatic char dataPath[MAXSTRING];\n\tdataPathPtr = NULL;\n\tif (path == NULL) return NULL;\n\tstrcpy(dataPath, path);\n\tdataPathPtr = dataPath;\n\treturn dataPathPtr;\n}\n\nchar *EXPORT_CALL\nlou_getDataPath(void) {\n\treturn dataPathPtr;\n}\n\n/* End of dataPath code. */\n\nstatic int\neqasc2uni(const unsigned char *a, const widechar *b, const int len) {\n\tint k;\n\tfor (k = 0; k < len; k++)\n\t\tif ((widechar)a[k] != b[k]) return 0;\n\treturn 1;\n}\n\ntypedef struct CharsString {\n\twidechar length;\n\twidechar chars[MAXSTRING];\n} CharsString;\n\nstatic int errorCount;\nstatic int warningCount;\n\ntypedef struct TranslationTableChainEntry {\n\tstruct TranslationTableChainEntry *next;\n\tTranslationTableHeader *table;\n\tint tableListLength;\n\tchar tableList[1];\n} TranslationTableChainEntry;\n\nstatic TranslationTableChainEntry *translationTableChain = NULL;\n\ntypedef struct DisplayTableChainEntry {\n\tstruct DisplayTableChainEntry *next;\n\tDisplayTableHeader *table;\n\tint tableListLength;\n\tchar tableList[1];\n} DisplayTableChainEntry;\n\nstatic DisplayTableChainEntry *displayTableChain = NULL;\n\n/* predefined character classes */\nstatic const char *characterClassNames[] = {\n\t\"space\",\n\t\"letter\",\n\t\"digit\",\n\t\"punctuation\",\n\t\"uppercase\",\n\t\"lowercase\",\n\t\"math\",\n\t\"sign\",\n\t\"litdigit\",\n\tNULL,\n};\n\n// names that may not be used for custom attributes\nstatic const char *reservedAttributeNames[] = {\n\t\"numericnocontchars\",\n\t\"numericnocontchar\",\n\t\"numericnocont\",\n\t\"midendnumericmodechars\",\n\t\"midendnumericmodechar\",\n\t\"midendnumericmode\",\n\t\"numericmodechars\",\n\t\"numericmodechar\",\n\t\"numericmode\",\n\t\"capsmodechars\",\n\t\"capsmodechar\",\n\t\"capsmode\",\n\t\"emphmodechars\",\n\t\"emphmodechar\",\n\t\"emphmode\",\n\t\"noemphchars\",\n\t\"noemphchar\",\n\t\"noemph\",\n\t\"seqdelimiter\",\n\t\"seqbeforechars\",\n\t\"seqbeforechar\",\n\t\"seqbefore\",\n\t\"seqafterchars\",\n\t\"seqafterchar\",\n\t\"seqafter\",\n\t\"noletsign\",\n\t\"noletsignbefore\",\n\t\"noletsignafter\",\n\tNULL,\n};\n\nstatic const char *opcodeNames[CTO_None] = {\n\t\"include\",\n\t\"locale\",\n\t\"undefined\",\n\t\"capsletter\",\n\t\"begcapsword\",\n\t\"endcapsword\",\n\t\"begcaps\",\n\t\"endcaps\",\n\t\"begcapsphrase\",\n\t\"endcapsphrase\",\n\t\"lencapsphrase\",\n\t\"modeletter\",\n\t\"begmodeword\",\n\t\"endmodeword\",\n\t\"begmode\",\n\t\"endmode\",\n\t\"begmodephrase\",\n\t\"endmodephrase\",\n\t\"lenmodephrase\",\n\t\"letsign\",\n\t\"noletsignbefore\",\n\t\"noletsign\",\n\t\"noletsignafter\",\n\t\"numsign\",\n\t\"numericmodechars\",\n\t\"midendnumericmodechars\",\n\t\"numericnocontchars\",\n\t\"seqdelimiter\",\n\t\"seqbeforechars\",\n\t\"seqafterchars\",\n\t\"seqafterpattern\",\n\t\"seqafterexpression\",\n\t\"emphclass\",\n\t\"emphletter\",\n\t\"begemphword\",\n\t\"endemphword\",\n\t\"begemph\",\n\t\"endemph\",\n\t\"begemphphrase\",\n\t\"endemphphrase\",\n\t\"lenemphphrase\",\n\t\"capsmodechars\",\n\t\"emphmodechars\",\n\t\"noemphchars\",\n\t\"begcomp\",\n\t\"endcomp\",\n\t\"nocontractsign\",\n\t\"multind\",\n\t\"compdots\",\n\t\"comp6\",\n\t\"class\",\n\t\"after\",\n\t\"before\",\n\t\"noback\",\n\t\"nofor\",\n\t\"empmatchbefore\",\n\t\"empmatchafter\",\n\t\"swapcc\",\n\t\"swapcd\",\n\t\"swapdd\",\n\t\"space\",\n\t\"digit\",\n\t\"punctuation\",\n\t\"math\",\n\t\"sign\",\n\t\"letter\",\n\t\"uppercase\",\n\t\"lowercase\",\n\t\"grouping\",\n\t\"uplow\",\n\t\"litdigit\",\n\t\"display\",\n\t\"replace\",\n\t\"context\",\n\t\"correct\",\n\t\"pass2\",\n\t\"pass3\",\n\t\"pass4\",\n\t\"repeated\",\n\t\"repword\",\n\t\"rependword\",\n\t\"capsnocont\",\n\t\"always\",\n\t\"exactdots\",\n\t\"nocross\",\n\t\"syllable\",\n\t\"nocont\",\n\t\"compbrl\",\n\t\"literal\",\n\t\"largesign\",\n\t\"word\",\n\t\"partword\",\n\t\"joinnum\",\n\t\"joinword\",\n\t\"lowword\",\n\t\"contraction\",\n\t\"sufword\",\n\t\"prfword\",\n\t\"begword\",\n\t\"begmidword\",\n\t\"midword\",\n\t\"midendword\",\n\t\"endword\",\n\t\"prepunc\",\n\t\"postpunc\",\n\t\"begnum\",\n\t\"midnum\",\n\t\"endnum\",\n\t\"decpoint\",\n\t\"hyphen\",\n\t// \"apostrophe\",\n\t// \"initial\",\n\t\"nobreak\",\n\t\"match\",\n\t\"backmatch\",\n\t\"attribute\",\n\t\"base\",\n\t\"macro\",\n};\n\nstatic short opcodeLengths[CTO_None] = { 0 };\n\nstatic void\ncompileError(const FileInfo *file, const char *format, ...);\n\nstatic void\nfree_tablefiles(char **tables);\n\nstatic int\ngetAChar(FileInfo *file) {\n\t/* Read a big endian, little endian or ASCII 8 file and convert it to\n\t * 16- or 32-bit unsigned integers */\n\tint ch1 = 0, ch2 = 0;\n\twidechar character;\n\tif (file->encoding == ascii8)\n\t\tif (file->status == 2) {\n\t\t\tfile->status++;\n\t\t\treturn file->checkencoding[1];\n\t\t}\n\twhile ((ch1 = fgetc(file->in)) != EOF) {\n\t\tif (file->status < 2) file->checkencoding[file->status] = ch1;\n\t\tfile->status++;\n\t\tif (file->status == 2) {\n\t\t\tif (file->checkencoding[0] == 0xfe && file->checkencoding[1] == 0xff)\n\t\t\t\tfile->encoding = bigEndian;\n\t\t\telse if (file->checkencoding[0] == 0xff && file->checkencoding[1] == 0xfe)\n\t\t\t\tfile->encoding = littleEndian;\n\t\t\telse if (file->checkencoding[0] < 128 && file->checkencoding[1] < 128) {\n\t\t\t\tfile->encoding = ascii8;\n\t\t\t\treturn file->checkencoding[0];\n\t\t\t} else {\n\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\"encoding is neither big-endian, little-endian nor ASCII 8.\");\n\t\t\t\tch1 = EOF;\n\t\t\t\tbreak;\n\t\t\t\t;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tswitch (file->encoding) {\n\t\tcase noEncoding:\n\t\t\tbreak;\n\t\tcase ascii8:\n\t\t\treturn ch1;\n\t\t\tbreak;\n\t\tcase bigEndian:\n\t\t\tch2 = fgetc(file->in);\n\t\t\tif (ch2 == EOF) break;\n\t\t\tcharacter = (widechar)(ch1 << 8) | ch2;\n\t\t\treturn (int)character;\n\t\t\tbreak;\n\t\tcase littleEndian:\n\t\t\tch2 = fgetc(file->in);\n\t\t\tif (ch2 == EOF) break;\n\t\t\tcharacter = (widechar)(ch2 << 8) | ch1;\n\t\t\treturn (int)character;\n\t\t\tbreak;\n\t\t}\n\t\tif (ch1 == EOF || ch2 == EOF) break;\n\t}\n\treturn EOF;\n}\n\nint EXPORT_CALL\n_lou_getALine(FileInfo *file) {\n\t/* Read a line of widechar's from an input file */\n\tint ch;\n\tint pch = 0;\n\tfile->linelen = 0;\n\twhile ((ch = getAChar(file)) != EOF) {\n\t\tif (ch == 13) continue;\n\t\tif (pch == '\\\\' && ch == 10) {\n\t\t\tfile->linelen--;\n\t\t\tpch = ch;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ch == 10 || file->linelen >= MAXSTRING - 1) break;\n\t\tfile->line[file->linelen++] = (widechar)ch;\n\t\tpch = ch;\n\t}\n\tfile->line[file->linelen] = 0;\n\tfile->linepos = 0;\n\tif (ch == EOF && !file->linelen) return 0;\n\tfile->lineNumber++;\n\treturn 1;\n}\n\nstatic inline int\natEndOfLine(const FileInfo *file) {\n\treturn file->linepos >= file->linelen;\n}\n\nstatic inline int\natTokenDelimiter(const FileInfo *file) {\n\treturn file->line[file->linepos] <= 32;\n}\n\nstatic int\ngetToken(FileInfo *file, CharsString *result, const char *description) {\n\t/* Find the next string of contiguous non-whitespace characters. If this\n\t * is the last token on the line, return 2 instead of 1. */\n\twhile (!atEndOfLine(file) && atTokenDelimiter(file)) file->linepos++;\n\tresult->length = 0;\n\twhile (!atEndOfLine(file) && !atTokenDelimiter(file)) {\n\t\tint maxlen = MAXSTRING;\n\t\tif (result->length >= maxlen) {\n\t\t\tcompileError(file, \"more than %d characters (bytes)\", maxlen);\n\t\t\treturn 0;\n\t\t} else\n\t\t\tresult->chars[result->length++] = file->line[file->linepos++];\n\t}\n\tif (!result->length) {\n\t\t/* Not enough tokens */\n\t\tif (description) compileError(file, \"%s not specified.\", description);\n\t\treturn 0;\n\t}\n\tresult->chars[result->length] = 0;\n\twhile (!atEndOfLine(file) && atTokenDelimiter(file)) file->linepos++;\n\treturn 1;\n}\n\nstatic void\ncompileError(const FileInfo *file, const char *format, ...) {\n#ifndef __SYMBIAN32__\n\tchar buffer[MAXSTRING];\n\tva_list arguments;\n\tva_start(arguments, format);\n\tvsnprintf(buffer, sizeof(buffer), format, arguments);\n\tva_end(arguments);\n\tif (file)\n\t\t_lou_logMessage(LOU_LOG_ERROR, \"%s:%d: error: %s\", file->fileName,\n\t\t\t\tfile->lineNumber, buffer);\n\telse\n\t\t_lou_logMessage(LOU_LOG_ERROR, \"error: %s\", buffer);\n\terrorCount++;\n#endif\n}\n\nstatic void\ncompileWarning(const FileInfo *file, const char *format, ...) {\n#ifndef __SYMBIAN32__\n\tchar buffer[MAXSTRING];\n\tva_list arguments;\n\tva_start(arguments, format);\n\tvsnprintf(buffer, sizeof(buffer), format, arguments);\n\tva_end(arguments);\n\tif (file)\n\t\t_lou_logMessage(LOU_LOG_WARN, \"%s:%d: warning: %s\", file->fileName,\n\t\t\t\tfile->lineNumber, buffer);\n\telse\n\t\t_lou_logMessage(LOU_LOG_WARN, \"warning: %s\", buffer);\n\twarningCount++;\n#endif\n}\n\nstatic int\nallocateSpaceInTranslationTable(const FileInfo *file, TranslationTableOffset *offset,\n\t\tint size, TranslationTableHeader **table) {\n\t/* allocate memory for table and expand previously allocated memory if necessary */\n\tint spaceNeeded = ((size + OFFSETSIZE - 1) / OFFSETSIZE) * OFFSETSIZE;\n\tTranslationTableOffset newTableSize = (*table)->bytesUsed + spaceNeeded;\n\tTranslationTableOffset tableSize = (*table)->tableSize;\n\tif (newTableSize > tableSize) {\n\t\tTranslationTableHeader *newTable;\n\t\tnewTableSize += (newTableSize / OFFSETSIZE);\n\t\tnewTable = realloc(*table, newTableSize);\n\t\tif (!newTable) {\n\t\t\tcompileError(file, \"Not enough memory for translation table.\");\n\t\t\t_lou_outOfMemory();\n\t\t}\n\t\tmemset(((unsigned char *)newTable) + tableSize, 0, newTableSize - tableSize);\n\t\t/* update references to the old table */\n\t\t{\n\t\t\tTranslationTableChainEntry *entry;\n\t\t\tfor (entry = translationTableChain; entry != NULL; entry = entry->next)\n\t\t\t\tif (entry->table == *table)\n\t\t\t\t\tentry->table = (TranslationTableHeader *)newTable;\n\t\t}\n\t\tnewTable->tableSize = newTableSize;\n\t\t*table = newTable;\n\t}\n\tif (offset != NULL) {\n\t\t*offset = ((*table)->bytesUsed - sizeof(**table)) / OFFSETSIZE;\n\t\t(*table)->bytesUsed += spaceNeeded;\n\t}\n\treturn 1;\n}\n\nstatic int\nallocateSpaceInDisplayTable(const FileInfo *file, TranslationTableOffset *offset,\n\t\tint size, DisplayTableHeader **table) {\n\t/* allocate memory for table and expand previously allocated memory if necessary */\n\tint spaceNeeded = ((size + OFFSETSIZE - 1) / OFFSETSIZE) * OFFSETSIZE;\n\tTranslationTableOffset newTableSize = (*table)->bytesUsed + spaceNeeded;\n\tTranslationTableOffset tableSize = (*table)->tableSize;\n\tif (newTableSize > tableSize) {\n\t\tDisplayTableHeader *newTable;\n\t\tnewTableSize += (newTableSize / OFFSETSIZE);\n\t\tnewTable = realloc(*table, newTableSize);\n\t\tif (!newTable) {\n\t\t\tcompileError(file, \"Not enough memory for display table.\");\n\t\t\t_lou_outOfMemory();\n\t\t}\n\t\tmemset(((unsigned char *)newTable) + tableSize, 0, newTableSize - tableSize);\n\t\t/* update references to the old table */\n\t\t{\n\t\t\tDisplayTableChainEntry *entry;\n\t\t\tfor (entry = displayTableChain; entry != NULL; entry = entry->next)\n\t\t\t\tif (entry->table == *table) entry->table = (DisplayTableHeader *)newTable;\n\t\t}\n\t\tnewTable->tableSize = newTableSize;\n\t\t*table = newTable;\n\t}\n\tif (offset != NULL) {\n\t\t*offset = ((*table)->bytesUsed - sizeof(**table)) / OFFSETSIZE;\n\t\t(*table)->bytesUsed += spaceNeeded;\n\t}\n\treturn 1;\n}\n\nstatic int\nallocateTranslationTable(const FileInfo *file, TranslationTableHeader **table) {\n\t/* Allocate memory for the table and a guess on the number of rules */\n\tconst TranslationTableOffset startSize = 2 * sizeof(**table);\n\tif (*table) return 1;\n\tTranslationTableOffset bytesUsed =\n\t\t\tsizeof(**table) + OFFSETSIZE; /* So no offset is ever zero */\n\tif (!(*table = malloc(startSize))) {\n\t\tcompileError(file, \"Not enough memory\");\n\t\tif (*table != NULL) free(*table);\n\t\t*table = NULL;\n\t\t_lou_outOfMemory();\n\t}\n\tmemset(*table, 0, startSize);\n\t(*table)->tableSize = startSize;\n\t(*table)->bytesUsed = bytesUsed;\n\treturn 1;\n}\n\nstatic int\nallocateDisplayTable(const FileInfo *file, DisplayTableHeader **table) {\n\t/* Allocate memory for the table and a guess on the number of rules */\n\tconst TranslationTableOffset startSize = 2 * sizeof(**table);\n\tif (*table) return 1;\n\tTranslationTableOffset bytesUsed =\n\t\t\tsizeof(**table) + OFFSETSIZE; /* So no offset is ever zero */\n\tif (!(*table = malloc(startSize))) {\n\t\tcompileError(file, \"Not enough memory\");\n\t\tif (*table != NULL) free(*table);\n\t\t*table = NULL;\n\t\t_lou_outOfMemory();\n\t}\n\tmemset(*table, 0, startSize);\n\t(*table)->tableSize = startSize;\n\t(*table)->bytesUsed = bytesUsed;\n\treturn 1;\n}\n\n/* Look up a character or dot pattern. Although the algorithms are almost identical,\n * different tables are needed for characters and dots because of the possibility of\n * conflicts. */\n\nstatic TranslationTableCharacter *\ngetChar(widechar c, TranslationTableHeader *table,\n\t\tTranslationTableOffset *characterOffset) {\n\tconst TranslationTableOffset bucket = table->characters[_lou_charHash(c)];\n\tTranslationTableOffset offset = bucket;\n\twhile (offset) {\n\t\tTranslationTableCharacter *character =\n\t\t\t\t(TranslationTableCharacter *)&table->ruleArea[offset];\n\t\tif (character->value == c) {\n\t\t\tif (characterOffset) *characterOffset = offset;\n\t\t\treturn character;\n\t\t}\n\t\toffset = character->next;\n\t}\n\treturn NULL;\n}\n\nstatic TranslationTableCharacter *\ngetDots(widechar d, TranslationTableHeader *table) {\n\tconst TranslationTableOffset bucket = table->dots[_lou_charHash(d)];\n\tTranslationTableOffset offset = bucket;\n\twhile (offset) {\n\t\tTranslationTableCharacter *character =\n\t\t\t\t(TranslationTableCharacter *)&table->ruleArea[offset];\n\t\tif (character->value == d) return character;\n\t\toffset = character->next;\n\t}\n\treturn NULL;\n}\n\nstatic TranslationTableCharacter *\nputChar(const FileInfo *file, widechar c, TranslationTableHeader **table,\n\t\tTranslationTableOffset *characterOffset) {\n\t/* See if a character is in the appropriate table. If not, insert it. In either case,\n\t * return a pointer to it. */\n\tTranslationTableCharacter *character;\n\tTranslationTableOffset offset;\n\tif ((character = getChar(c, *table, characterOffset))) return character;\n\tif (!allocateSpaceInTranslationTable(file, &offset, sizeof(*character), table))\n\t\treturn NULL;\n\tcharacter = (TranslationTableCharacter *)&(*table)->ruleArea[offset];\n\tmemset(character, 0, sizeof(*character));\n\tcharacter->sourceFile = file->sourceFile;\n\tcharacter->sourceLine = file->lineNumber;\n\tcharacter->value = c;\n\tconst unsigned long int charHash = _lou_charHash(c);\n\tconst TranslationTableOffset bucket = (*table)->characters[charHash];\n\tif (!bucket)\n\t\t(*table)->characters[charHash] = offset;\n\telse {\n\t\tTranslationTableCharacter *oldchar =\n\t\t\t\t(TranslationTableCharacter *)&(*table)->ruleArea[bucket];\n\t\twhile (oldchar->next)\n\t\t\toldchar = (TranslationTableCharacter *)&(*table)->ruleArea[oldchar->next];\n\t\toldchar->next = offset;\n\t}\n\tif (characterOffset) *characterOffset = offset;\n\treturn character;\n}\n\nstatic TranslationTableCharacter *\nputDots(const FileInfo *file, widechar d, TranslationTableHeader **table) {\n\t/* See if a dot pattern is in the appropriate table. If not, insert it. In either\n\t * case, return a pointer to it. */\n\tTranslationTableCharacter *character;\n\tTranslationTableOffset offset;\n\tif ((character = getDots(d, *table))) return character;\n\tif (!allocateSpaceInTranslationTable(file, &offset, sizeof(*character), table))\n\t\treturn NULL;\n\tcharacter = (TranslationTableCharacter *)&(*table)->ruleArea[offset];\n\tmemset(character, 0, sizeof(*character));\n\tcharacter->sourceFile = file->sourceFile;\n\tcharacter->sourceLine = file->lineNumber;\n\tcharacter->value = d;\n\tconst unsigned long int charHash = _lou_charHash(d);\n\tconst TranslationTableOffset bucket = (*table)->dots[charHash];\n\tif (!bucket)\n\t\t(*table)->dots[charHash] = offset;\n\telse {\n\t\tTranslationTableCharacter *oldchar =\n\t\t\t\t(TranslationTableCharacter *)&(*table)->ruleArea[bucket];\n\t\twhile (oldchar->next)\n\t\t\toldchar = (TranslationTableCharacter *)&(*table)->ruleArea[oldchar->next];\n\t\toldchar->next = offset;\n\t}\n\treturn character;\n}\n\n/* Look up a character-dots mapping in a display table. */\n\nstatic CharDotsMapping *\ngetDotsForChar(widechar c, const DisplayTableHeader *table) {\n\tCharDotsMapping *cdPtr;\n\tconst TranslationTableOffset bucket = table->charToDots[_lou_charHash(c)];\n\tTranslationTableOffset offset = bucket;\n\twhile (offset) {\n\t\tcdPtr = (CharDotsMapping *)&table->ruleArea[offset];\n\t\tif (cdPtr->lookFor == c) return cdPtr;\n\t\toffset = cdPtr->next;\n\t}\n\treturn NULL;\n}\n\nstatic CharDotsMapping *\ngetCharForDots(widechar d, const DisplayTableHeader *table) {\n\tCharDotsMapping *cdPtr;\n\tconst TranslationTableOffset bucket = table->dotsToChar[_lou_charHash(d)];\n\tTranslationTableOffset offset = bucket;\n\twhile (offset) {\n\t\tcdPtr = (CharDotsMapping *)&table->ruleArea[offset];\n\t\tif (cdPtr->lookFor == d) return cdPtr;\n\t\toffset = cdPtr->next;\n\t}\n\treturn NULL;\n}\n\nwidechar EXPORT_CALL\n_lou_getDotsForChar(widechar c, const DisplayTableHeader *table) {\n\tCharDotsMapping *cdPtr = getDotsForChar(c, table);\n\tif (cdPtr) return cdPtr->found;\n\treturn LOU_DOTS;\n}\n\nwidechar EXPORT_CALL\n_lou_getCharForDots(widechar d, const DisplayTableHeader *table) {\n\tCharDotsMapping *cdPtr = getCharForDots(d, table);\n\tif (cdPtr) return cdPtr->found;\n\treturn '\\0';\n}\n\nstatic int\nputCharDotsMapping(\n\t\tconst FileInfo *file, widechar c, widechar d, DisplayTableHeader **table) {\n\tif (!getDotsForChar(c, *table)) {\n\t\tCharDotsMapping *cdPtr;\n\t\tTranslationTableOffset offset;\n\t\tif (!allocateSpaceInDisplayTable(file, &offset, sizeof(*cdPtr), table)) return 0;\n\t\tcdPtr = (CharDotsMapping *)&(*table)->ruleArea[offset];\n\t\tcdPtr->next = 0;\n\t\tcdPtr->lookFor = c;\n\t\tcdPtr->found = d;\n\t\tconst unsigned long int charHash = _lou_charHash(c);\n\t\tconst TranslationTableOffset bucket = (*table)->charToDots[charHash];\n\t\tif (!bucket)\n\t\t\t(*table)->charToDots[charHash] = offset;\n\t\telse {\n\t\t\tCharDotsMapping *oldcdPtr = (CharDotsMapping *)&(*table)->ruleArea[bucket];\n\t\t\twhile (oldcdPtr->next)\n\t\t\t\toldcdPtr = (CharDotsMapping *)&(*table)->ruleArea[oldcdPtr->next];\n\t\t\toldcdPtr->next = offset;\n\t\t}\n\t}\n\tif (!getCharForDots(d, *table)) {\n\t\tCharDotsMapping *cdPtr;\n\t\tTranslationTableOffset offset;\n\t\tif (!allocateSpaceInDisplayTable(file, &offset, sizeof(*cdPtr), table)) return 0;\n\t\tcdPtr = (CharDotsMapping *)&(*table)->ruleArea[offset];\n\t\tcdPtr->next = 0;\n\t\tcdPtr->lookFor = d;\n\t\tcdPtr->found = c;\n\t\tconst unsigned long int charHash = _lou_charHash(d);\n\t\tconst TranslationTableOffset bucket = (*table)->dotsToChar[charHash];\n\t\tif (!bucket)\n\t\t\t(*table)->dotsToChar[charHash] = offset;\n\t\telse {\n\t\t\tCharDotsMapping *oldcdPtr = (CharDotsMapping *)&(*table)->ruleArea[bucket];\n\t\t\twhile (oldcdPtr->next)\n\t\t\t\toldcdPtr = (CharDotsMapping *)&(*table)->ruleArea[oldcdPtr->next];\n\t\t\toldcdPtr->next = offset;\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic inline const char *\ngetPartName(int actionPart) {\n\treturn actionPart ? \"action\" : \"test\";\n}\n\nstatic int\npassFindCharacters(const FileInfo *file, widechar *instructions, int end,\n\t\twidechar **characters, int *length) {\n\tint IC = 0;\n\tint lookback = 0;\n\n\t*characters = NULL;\n\t*length = 0;\n\n\twhile (IC < end) {\n\t\twidechar instruction = instructions[IC];\n\n\t\tswitch (instruction) {\n\t\tcase pass_string:\n\t\tcase pass_dots: {\n\t\t\tint count = instructions[IC + 1];\n\t\t\tIC += 2;\n\t\t\tif (count > lookback) {\n\t\t\t\t*characters = &instructions[IC + lookback];\n\t\t\t\t*length = count - lookback;\n\t\t\t\treturn 1;\n\t\t\t} else {\n\t\t\t\tlookback -= count;\n\t\t\t}\n\t\t\tIC += count;\n\t\t\tcontinue;\n\t\t}\n\n\t\tcase pass_attributes:\n\t\t\tIC += 7;\n\t\t\tif (instructions[IC - 2] == instructions[IC - 1] &&\n\t\t\t\t\tinstructions[IC - 1] <= lookback) {\n\t\t\t\tlookback -= instructions[IC - 1];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tgoto NO_CHARACTERS;\n\n\t\tcase pass_swap:\n\t\t\tIC += 2;\n\t\t\t/* fall through */\n\n\t\tcase pass_groupstart:\n\t\tcase pass_groupend:\n\t\tcase pass_groupreplace:\n\t\t\tIC += 3;\n\n\t\tNO_CHARACTERS : { return 1; }\n\n\t\tcase pass_eq:\n\t\tcase pass_lt:\n\t\tcase pass_gt:\n\t\tcase pass_lteq:\n\t\tcase pass_gteq:\n\t\t\tIC += 3;\n\t\t\tcontinue;\n\n\t\tcase pass_lookback:\n\t\t\tlookback += instructions[IC + 1];\n\t\t\tIC += 2;\n\t\t\tcontinue;\n\n\t\tcase pass_not:\n\t\tcase pass_startReplace:\n\t\tcase pass_endReplace:\n\t\tcase pass_first:\n\t\tcase pass_last:\n\t\tcase pass_copy:\n\t\tcase pass_omit:\n\t\tcase pass_plus:\n\t\tcase pass_hyphen:\n\t\t\tIC += 1;\n\t\t\tcontinue;\n\n\t\tcase pass_endTest:\n\t\t\tgoto NO_CHARACTERS;\n\n\t\tdefault:\n\t\t\tcompileError(file, \"unhandled test suboperand: \\\\x%02x\", instruction);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tgoto NO_CHARACTERS;\n}\n\nstatic const char *\nprintSource(const FileInfo *currentFile, const char *sourceFile, int sourceLine) {\n\tstatic char scratchBuf[MAXSTRING];\n\tif (sourceFile) {\n\t\tif (currentFile && currentFile->sourceFile &&\n\t\t\t\tstrcmp(currentFile->sourceFile, sourceFile) == 0)\n\t\t\tsnprintf(scratchBuf, MAXSTRING, \"line %d\", sourceLine);\n\t\telse\n\t\t\tsnprintf(scratchBuf, MAXSTRING, \"%s:%d\", sourceFile, sourceLine);\n\t} else\n\t\tsnprintf(scratchBuf, MAXSTRING, \"source unknown\");\n\treturn scratchBuf;\n}\n\n/* The following functions are called by addRule to handle various cases. */\n\nstatic void\naddForwardRuleWithSingleChar(const FileInfo *file, TranslationTableOffset ruleOffset,\n\t\tTranslationTableRule *rule, TranslationTableHeader **table) {\n\t/* direction = 0, rule->charslen = 1 */\n\tTranslationTableCharacter *character;\n\t// get the character from the table, or if the character is not defined yet, define it\n\t// (without adding attributes)\n\tif (rule->opcode >= CTO_Pass2 && rule->opcode <= CTO_Pass4) {\n\t\tcharacter = putDots(file, rule->charsdots[0], table);\n\t\t// putDots may have moved table, so make sure rule is still valid\n\t\trule = (TranslationTableRule *)&(*table)->ruleArea[ruleOffset];\n\t} else if (rule->opcode == CTO_CompDots || rule->opcode == CTO_Comp6) {\n\t\tcharacter = putChar(file, rule->charsdots[0], table, NULL);\n\t\t// putChar may have moved table, so make sure rule is still valid\n\t\trule = (TranslationTableRule *)&(*table)->ruleArea[ruleOffset];\n\t\tcharacter->compRule = ruleOffset;\n\t\treturn;\n\t} else {\n\t\tcharacter = putChar(file, rule->charsdots[0], table, NULL);\n\t\t// putChar may have moved table, so make sure rule is still valid\n\t\trule = (TranslationTableRule *)&(*table)->ruleArea[ruleOffset];\n\t\t// if the new rule is a character definition rule, set the main definition rule of\n\t\t// this character to it (possibly overwriting previous definition rules)\n\t\t// adding the attributes to the character has already been done elsewhere\n\t\tif (rule->opcode >= CTO_Space && rule->opcode < CTO_UpLow) {\n\t\t\tif (character->definitionRule) {\n\t\t\t\tTranslationTableRule *prevRule =\n\t\t\t\t\t\t(TranslationTableRule *)&(*table)\n\t\t\t\t\t\t\t\t->ruleArea[character->definitionRule];\n\t\t\t\t_lou_logMessage(LOU_LOG_DEBUG,\n\t\t\t\t\t\t\"%s:%d: Character already defined (%s). The new definition will \"\n\t\t\t\t\t\t\"take precedence.\",\n\t\t\t\t\t\tfile->fileName, file->lineNumber,\n\t\t\t\t\t\tprintSource(file, prevRule->sourceFile, prevRule->sourceLine));\n\t\t\t} else if (character->basechar) {\n\t\t\t\t_lou_logMessage(LOU_LOG_DEBUG,\n\t\t\t\t\t\t\"%s:%d: A base rule already exists for this character (%s). The \"\n\t\t\t\t\t\t\"%s rule will take precedence.\",\n\t\t\t\t\t\tfile->fileName, file->lineNumber,\n\t\t\t\t\t\tprintSource(file, character->sourceFile, character->sourceLine),\n\t\t\t\t\t\t_lou_findOpcodeName(rule->opcode));\n\t\t\t\tcharacter->basechar = 0;\n\t\t\t\tcharacter->mode = 0;\n\t\t\t}\n\t\t\tcharacter->definitionRule = ruleOffset;\n\t\t}\n\t}\n\t// add the new rule to the list of rules associated with this character\n\t// if the new rule is a character definition rule, it is inserted at the end of the\n\t// list\n\t// otherwise it is inserted before the first character definition rule\n\tTranslationTableOffset *otherRule = &character->otherRules;\n\twhile (*otherRule) {\n\t\tTranslationTableRule *r = (TranslationTableRule *)&(*table)->ruleArea[*otherRule];\n\t\tif (r->charslen == 0) break;\n\t\tif (r->opcode >= CTO_Space && r->opcode < CTO_UpLow)\n\t\t\tif (!(rule->opcode >= CTO_Space && rule->opcode < CTO_UpLow)) break;\n\t\totherRule = &r->charsnext;\n\t}\n\trule->charsnext = *otherRule;\n\t*otherRule = ruleOffset;\n}\n\nstatic void\naddForwardRuleWithMultipleChars(TranslationTableOffset ruleOffset,\n\t\tTranslationTableRule *rule, TranslationTableHeader *table) {\n\t/* direction = 0 rule->charslen > 1 */\n\tTranslationTableOffset *forRule =\n\t\t\t&table->forRules[_lou_stringHash(&rule->charsdots[0], 0, NULL)];\n\twhile (*forRule) {\n\t\tTranslationTableRule *r = (TranslationTableRule *)&table->ruleArea[*forRule];\n\t\tif (rule->charslen > r->charslen) break;\n\t\tif (rule->charslen == r->charslen)\n\t\t\tif ((r->opcode == CTO_Always) && (rule->opcode != CTO_Always)) break;\n\t\tforRule = &r->charsnext;\n\t}\n\trule->charsnext = *forRule;\n\t*forRule = ruleOffset;\n}\n\nstatic void\naddBackwardRuleWithSingleCell(const FileInfo *file, widechar cell,\n\t\tTranslationTableOffset ruleOffset, TranslationTableRule *rule,\n\t\tTranslationTableHeader **table) {\n\t/* direction = 1, rule->dotslen = 1 */\n\tTranslationTableCharacter *dots;\n\tif (rule->opcode == CTO_SwapCc || rule->opcode == CTO_Repeated)\n\t\treturn; /* too ambiguous */\n\t// get the cell from the table, or if the cell is not defined yet, define it (without\n\t// adding attributes)\n\tdots = putDots(file, cell, table);\n\t// putDots may have moved table, so make sure rule is still valid\n\trule = (TranslationTableRule *)&(*table)->ruleArea[ruleOffset];\n\tif (rule->opcode >= CTO_Space && rule->opcode < CTO_UpLow)\n\t\tdots->definitionRule = ruleOffset;\n\tTranslationTableOffset *otherRule = &dots->otherRules;\n\twhile (*otherRule) {\n\t\tTranslationTableRule *r = (TranslationTableRule *)&(*table)->ruleArea[*otherRule];\n\t\tif (rule->charslen > r->charslen || r->dotslen == 0) break;\n\t\tif (r->opcode >= CTO_Space && r->opcode < CTO_UpLow)\n\t\t\tif (!(rule->opcode >= CTO_Space && rule->opcode < CTO_UpLow)) break;\n\t\totherRule = &r->dotsnext;\n\t}\n\trule->dotsnext = *otherRule;\n\t*otherRule = ruleOffset;\n}\n\nstatic void\naddBackwardRuleWithMultipleCells(widechar *cells, int dotslen,\n\t\tTranslationTableOffset ruleOffset, TranslationTableRule *rule,\n\t\tTranslationTableHeader *table) {\n\t/* direction = 1, dotslen > 1 */\n\tTranslationTableOffset *backRule = &table->backRules[_lou_stringHash(cells, 0, NULL)];\n\tif (rule->opcode == CTO_SwapCc) return;\n\tint ruleLength = dotslen + rule->charslen;\n\twhile (*backRule) {\n\t\tTranslationTableRule *r = (TranslationTableRule *)&table->ruleArea[*backRule];\n\t\tint rLength = r->dotslen + r->charslen;\n\t\tif (ruleLength > rLength) break;\n\t\tif (rLength == ruleLength)\n\t\t\tif ((r->opcode == CTO_Always) && (rule->opcode != CTO_Always)) break;\n\t\tbackRule = &r->dotsnext;\n\t}\n\trule->dotsnext = *backRule;\n\t*backRule = ruleOffset;\n}\n\nstatic int\naddForwardPassRule(TranslationTableOffset ruleOffset, TranslationTableRule *rule,\n\t\tTranslationTableHeader *table) {\n\tTranslationTableOffset *forPassRule;\n\tswitch (rule->opcode) {\n\tcase CTO_Correct:\n\t\tforPassRule = &table->forPassRules[0];\n\t\tbreak;\n\tcase CTO_Context:\n\t\tforPassRule = &table->forPassRules[1];\n\t\tbreak;\n\tcase CTO_Pass2:\n\t\tforPassRule = &table->forPassRules[2];\n\t\tbreak;\n\tcase CTO_Pass3:\n\t\tforPassRule = &table->forPassRules[3];\n\t\tbreak;\n\tcase CTO_Pass4:\n\t\tforPassRule = &table->forPassRules[4];\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\twhile (*forPassRule) {\n\t\tTranslationTableRule *r = (TranslationTableRule *)&table->ruleArea[*forPassRule];\n\t\tif (rule->charslen > r->charslen) break;\n\t\tforPassRule = &r->charsnext;\n\t}\n\trule->charsnext = *forPassRule;\n\t*forPassRule = ruleOffset;\n\treturn 1;\n}\n\nstatic int\naddBackwardPassRule(TranslationTableOffset ruleOffset, TranslationTableRule *rule,\n\t\tTranslationTableHeader *table) {\n\tTranslationTableOffset *backPassRule;\n\tswitch (rule->opcode) {\n\tcase CTO_Correct:\n\t\tbackPassRule = &table->backPassRules[0];\n\t\tbreak;\n\tcase CTO_Context:\n\t\tbackPassRule = &table->backPassRules[1];\n\t\tbreak;\n\tcase CTO_Pass2:\n\t\tbackPassRule = &table->backPassRules[2];\n\t\tbreak;\n\tcase CTO_Pass3:\n\t\tbackPassRule = &table->backPassRules[3];\n\t\tbreak;\n\tcase CTO_Pass4:\n\t\tbackPassRule = &table->backPassRules[4];\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\twhile (*backPassRule) {\n\t\tTranslationTableRule *r = (TranslationTableRule *)&table->ruleArea[*backPassRule];\n\t\tif (rule->charslen > r->charslen) break;\n\t\tbackPassRule = &r->dotsnext;\n\t}\n\trule->dotsnext = *backPassRule;\n\t*backPassRule = ruleOffset;\n\treturn 1;\n}\n\nstatic int\naddRule(const FileInfo *file, TranslationTableOpcode opcode, CharsString *ruleChars,\n\t\tCharsString *ruleDots, TranslationTableCharacterAttributes after,\n\t\tTranslationTableCharacterAttributes before, TranslationTableOffset *ruleOffset,\n\t\tTranslationTableRule **rule, int noback, int nofor,\n\t\tTranslationTableHeader **table) {\n\t/* Add a rule to the table, using the hash function to find the start of\n\t * chains and chaining both the chars and dots strings */\n\tTranslationTableOffset offset;\n\tint ruleSize = sizeof(TranslationTableRule) - (DEFAULTRULESIZE * CHARSIZE);\n\tif (ruleChars) ruleSize += CHARSIZE * ruleChars->length;\n\tif (ruleDots) ruleSize += CHARSIZE * ruleDots->length;\n\tif (!allocateSpaceInTranslationTable(file, &offset, ruleSize, table)) return 0;\n\tTranslationTableRule *r = (TranslationTableRule *)&(*table)->ruleArea[offset];\n\tif (rule) *rule = r;\n\tif (ruleOffset) *ruleOffset = offset;\n\tr->sourceFile = file->sourceFile;\n\tr->sourceLine = file->lineNumber;\n\tr->opcode = opcode;\n\tr->after = after;\n\tr->before = before;\n\tr->nocross = 0;\n\tif (ruleChars)\n\t\tmemcpy(&r->charsdots[0], &ruleChars->chars[0],\n\t\t\t\tCHARSIZE * (r->charslen = ruleChars->length));\n\telse\n\t\tr->charslen = 0;\n\tif (ruleDots)\n\t\tmemcpy(&r->charsdots[r->charslen], &ruleDots->chars[0],\n\t\t\t\tCHARSIZE * (r->dotslen = ruleDots->length));\n\telse\n\t\tr->dotslen = 0;\n\n\t/* link new rule into table. */\n\tif (opcode == CTO_SwapCc || opcode == CTO_SwapCd || opcode == CTO_SwapDd) return 1;\n\tif (opcode >= CTO_Context && opcode <= CTO_Pass4)\n\t\tif (!(opcode == CTO_Context && r->charslen > 0)) {\n\t\t\tif (!nofor)\n\t\t\t\tif (!addForwardPassRule(offset, r, *table)) return 0;\n\t\t\tif (!noback)\n\t\t\t\tif (!addBackwardPassRule(offset, r, *table)) return 0;\n\t\t\treturn 1;\n\t\t}\n\tif (!nofor) {\n\t\tif (r->charslen == 1) {\n\t\t\taddForwardRuleWithSingleChar(file, offset, r, table);\n\t\t\t// addForwardRuleWithSingleChar may have moved table, so make sure rule is\n\t\t\t// still valid\n\t\t\tr = (TranslationTableRule *)&(*table)->ruleArea[offset];\n\t\t\tif (rule) *rule = r;\n\t\t} else if (r->charslen > 1)\n\t\t\taddForwardRuleWithMultipleChars(offset, r, *table);\n\t}\n\tif (!noback) {\n\t\twidechar *cells;\n\t\tint dotslen;\n\n\t\tif (r->opcode == CTO_Context) {\n\t\t\tcells = &r->charsdots[0];\n\t\t\tdotslen = r->charslen;\n\t\t} else {\n\t\t\tcells = &r->charsdots[r->charslen];\n\t\t\tdotslen = r->dotslen;\n\t\t}\n\t\tif (dotslen == 1) {\n\t\t\taddBackwardRuleWithSingleCell(file, *cells, offset, r, table);\n\t\t\t// addBackwardRuleWithSingleCell may have moved table, so make sure rule is\n\t\t\t// still valid\n\t\t\tr = (TranslationTableRule *)&(*table)->ruleArea[offset];\n\t\t\tif (rule) *rule = r;\n\t\t} else if (dotslen > 1)\n\t\t\taddBackwardRuleWithMultipleCells(cells, dotslen, offset, r, *table);\n\t}\n\treturn 1;\n}\n\nstatic const CharacterClass *\nfindCharacterClass(const CharsString *name, const TranslationTableHeader *table) {\n\t/* Find a character class, whether predefined or user-defined */\n\tconst CharacterClass *class = table->characterClasses;\n\twhile (class) {\n\t\tif ((name->length == class->length) &&\n\t\t\t\t(memcmp(&name->chars[0], class->name, CHARSIZE * name->length) == 0))\n\t\t\treturn class;\n\t\tclass = class->next;\n\t}\n\treturn NULL;\n}\n\nstatic TranslationTableCharacterAttributes\ngetNextNumberedAttribute(TranslationTableHeader *table) {\n\t/* Get the next attribute value for numbered attributes, or 0 if there is no more\n\t * space in the table. */\n\tTranslationTableCharacterAttributes next = table->nextNumberedCharacterClassAttribute;\n\tif (next > CTC_UserDefined8) return 0;\n\ttable->nextNumberedCharacterClassAttribute <<= 1;\n\treturn next;\n}\n\nstatic TranslationTableCharacterAttributes\ngetNextAttribute(TranslationTableHeader *table) {\n\t/* Get the next attribute value, or 0 if there is no more space in the table. */\n\tTranslationTableCharacterAttributes next = table->nextCharacterClassAttribute;\n\tif (next) {\n\t\tif (next == CTC_LitDigit)\n\t\t\ttable->nextCharacterClassAttribute = CTC_UserDefined9;\n\t\telse\n\t\t\ttable->nextCharacterClassAttribute <<= 1;\n\t\treturn next;\n\t} else\n\t\treturn getNextNumberedAttribute(table);\n}\n\nstatic CharacterClass *\naddCharacterClass(const FileInfo *file, const widechar *name, int length,\n\t\tTranslationTableHeader *table, int validate) {\n\t/* Define a character class, Whether predefined or user-defined */\n\tif (validate) {\n\t\tfor (int i = 0; i < length; i++) {\n\t\t\tif (!((name[i] >= 'a' && name[i] <= 'z') ||\n\t\t\t\t\t\t(name[i] >= 'A' && name[i] <= 'Z'))) {\n\t\t\t\t// don't abort because in some cases (before/after rules)\n\t\t\t\t// this will work fine, but it will not work in multipass\n\t\t\t\t// expressions\n\t\t\t\tcompileWarning(file,\n\t\t\t\t\t\t\"Invalid attribute name: must be a digit between \"\n\t\t\t\t\t\t\"0 and 7 or a word containing only letters\");\n\t\t\t}\n\t\t}\n\t\t// check that name is not reserved\n\t\tint k = 0;\n\t\twhile (reservedAttributeNames[k]) {\n\t\t\tif (strlen(reservedAttributeNames[k]) == length) {\n\t\t\t\tint i;\n\t\t\t\tfor (i = 0; i < length; i++)\n\t\t\t\t\tif (reservedAttributeNames[k][i] != name[i]) break;\n\t\t\t\tif (i == length) {\n\t\t\t\t\tcompileError(file, \"Attribute name is reserved: %s\",\n\t\t\t\t\t\t\treservedAttributeNames[k]);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tk++;\n\t\t}\n\t}\n\tCharacterClass **classes = &table->characterClasses;\n\tTranslationTableCharacterAttributes attribute = getNextAttribute(table);\n\tCharacterClass *class;\n\tif (attribute) {\n\t\tif (!(class = malloc(sizeof(*class) + CHARSIZE * (length - 1))))\n\t\t\t_lou_outOfMemory();\n\t\telse {\n\t\t\tmemset(class, 0, sizeof(*class));\n\t\t\tmemcpy(class->name, name, CHARSIZE * (class->length = length));\n\t\t\tclass->attribute = attribute;\n\t\t\tclass->next = *classes;\n\t\t\t*classes = class;\n\t\t\treturn class;\n\t\t}\n\t}\n\tcompileError(file, \"character class table overflow.\");\n\treturn NULL;\n}\n\nstatic void\ndeallocateCharacterClasses(TranslationTableHeader *table) {\n\tCharacterClass **classes = &table->characterClasses;\n\twhile (*classes) {\n\t\tCharacterClass *class = *classes;\n\t\t*classes = (*classes)->next;\n\t\tif (class) free(class);\n\t}\n}\n\nstatic int\nallocateCharacterClasses(TranslationTableHeader *table) {\n\t/* Allocate memory for predefined character classes */\n\tint k = 0;\n\ttable->characterClasses = NULL;\n\ttable->nextCharacterClassAttribute = 1;\t // CTC_Space\n\ttable->nextNumberedCharacterClassAttribute = CTC_UserDefined1;\n\twhile (characterClassNames[k]) {\n\t\twidechar wname[MAXSTRING];\n\t\tint length = (int)strlen(characterClassNames[k]);\n\t\tint kk;\n\t\tfor (kk = 0; kk < length; kk++) wname[kk] = (widechar)characterClassNames[k][kk];\n\t\tif (!addCharacterClass(NULL, wname, length, table, 0)) {\n\t\t\tdeallocateCharacterClasses(table);\n\t\t\treturn 0;\n\t\t}\n\t\tk++;\n\t}\n\treturn 1;\n}\n\nstatic TranslationTableOpcode\ngetOpcode(const FileInfo *file, const CharsString *token) {\n\tstatic TranslationTableOpcode lastOpcode = 0;\n\tTranslationTableOpcode opcode = lastOpcode;\n\n\tdo {\n\t\tif (token->length == opcodeLengths[opcode])\n\t\t\tif (eqasc2uni((unsigned char *)opcodeNames[opcode], &token->chars[0],\n\t\t\t\t\t\ttoken->length)) {\n\t\t\t\tlastOpcode = opcode;\n\t\t\t\treturn opcode;\n\t\t\t}\n\t\topcode++;\n\t\tif (opcode >= CTO_None) opcode = 0;\n\t} while (opcode != lastOpcode);\n\treturn CTO_None;\n}\n\nTranslationTableOpcode EXPORT_CALL\n_lou_findOpcodeNumber(const char *toFind) {\n\t/* Used by tools such as lou_debug */\n\tstatic TranslationTableOpcode lastOpcode = 0;\n\tTranslationTableOpcode opcode = lastOpcode;\n\tint length = (int)strlen(toFind);\n\tdo {\n\t\tif (length == opcodeLengths[opcode] &&\n\t\t\t\tstrcasecmp(toFind, opcodeNames[opcode]) == 0) {\n\t\t\tlastOpcode = opcode;\n\t\t\treturn opcode;\n\t\t}\n\t\topcode++;\n\t\tif (opcode >= CTO_None) opcode = 0;\n\t} while (opcode != lastOpcode);\n\treturn CTO_None;\n}\n\nconst char *EXPORT_CALL\n_lou_findOpcodeName(TranslationTableOpcode opcode) {\n\tstatic char scratchBuf[MAXSTRING];\n\t/* Used by tools such as lou_debug */\n\tif (opcode < 0 || opcode >= CTO_None) {\n\t\tsprintf(scratchBuf, \"%u\", opcode);\n\t\treturn scratchBuf;\n\t}\n\treturn opcodeNames[opcode];\n}\n\nstatic widechar\nhexValue(const FileInfo *file, const widechar *digits, int length) {\n\tint k;\n\tunsigned int binaryValue = 0;\n\tfor (k = 0; k < length; k++) {\n\t\tunsigned int hexDigit = 0;\n\t\tif (digits[k] >= '0' && digits[k] <= '9')\n\t\t\thexDigit = digits[k] - '0';\n\t\telse if (digits[k] >= 'a' && digits[k] <= 'f')\n\t\t\thexDigit = digits[k] - 'a' + 10;\n\t\telse if (digits[k] >= 'A' && digits[k] <= 'F')\n\t\t\thexDigit = digits[k] - 'A' + 10;\n\t\telse {\n\t\t\tcompileError(file, \"invalid %d-digit hexadecimal number\", length);\n\t\t\treturn (widechar)0xffffffff;\n\t\t}\n\t\tbinaryValue |= hexDigit << (4 * (length - 1 - k));\n\t}\n\treturn (widechar)binaryValue;\n}\n\n#define MAXBYTES 7\nstatic const unsigned int first0Bit[MAXBYTES] = { 0x80, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC,\n\t0XFE };\n\nstatic int\nparseChars(const FileInfo *file, CharsString *result, CharsString *token) {\n\tint in = 0;\n\tint out = 0;\n\tint lastOutSize = 0;\n\tint lastIn;\n\tunsigned int ch = 0;\n\tint numBytes = 0;\n\tunsigned int utf32 = 0;\n\tint k;\n\twhile (in < token->length) {\n\t\tch = token->chars[in++] & 0xff;\n\t\tif (ch < 128) {\n\t\t\tif (ch == '\\\\') { /* escape sequence */\n\t\t\t\tswitch (ch = token->chars[in]) {\n\t\t\t\tcase '\\\\':\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'e':\n\t\t\t\t\tch = 0x1b;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'f':\n\t\t\t\t\tch = 12;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'n':\n\t\t\t\t\tch = 10;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'r':\n\t\t\t\t\tch = 13;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 's':\n\t\t\t\t\tch = ' ';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 't':\n\t\t\t\t\tch = 9;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'v':\n\t\t\t\t\tch = 11;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'w':\n\t\t\t\t\tch = LOU_ENDSEGMENT;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 34:\n\t\t\t\t\tch = QUOTESUB;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'X':\n\t\t\t\t\tcompileWarning(file, \"\\\\Xhhhh (with a capital 'X') is deprecated.\");\n\t\t\t\tcase 'x':\n\t\t\t\t\tif (token->length - in > 4) {\n\t\t\t\t\t\tch = hexValue(file, &token->chars[in + 1], 4);\n\t\t\t\t\t\tin += 4;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'Y':\n\t\t\t\t\tcompileWarning(file, \"\\\\Yhhhhh (with a capital 'Y') is deprecated.\");\n\t\t\t\tcase 'y':\n\t\t\t\t\tif (CHARSIZE == 2) {\n\t\t\t\t\tnot32:\n\t\t\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\t\t\"liblouis has not been compiled for 32-bit Unicode\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (token->length - in > 5) {\n\t\t\t\t\t\tch = hexValue(file, &token->chars[in + 1], 5);\n\t\t\t\t\t\tin += 5;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'Z':\n\t\t\t\t\tcompileWarning(\n\t\t\t\t\t\t\tfile, \"\\\\Zhhhhhhhh (with a capital 'Z') is deprecated.\");\n\t\t\t\tcase 'z':\n\t\t\t\t\tif (CHARSIZE == 2) goto not32;\n\t\t\t\t\tif (token->length - in > 8) {\n\t\t\t\t\t\tch = hexValue(file, &token->chars[in + 1], 8);\n\t\t\t\t\t\tin += 8;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tcompileError(file, \"invalid escape sequence '\\\\%c'\", ch);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tin++;\n\t\t\t}\n\t\t\tif (out >= MAXSTRING - 1) {\n\t\t\t\tcompileError(file, \"Token too long\");\n\t\t\t\tresult->length = MAXSTRING - 1;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tresult->chars[out++] = (widechar)ch;\n\t\t\tcontinue;\n\t\t}\n\t\tlastOutSize = out;\n\t\tlastIn = in;\n\t\tfor (numBytes = MAXBYTES - 1; numBytes > 0; numBytes--)\n\t\t\tif (ch >= first0Bit[numBytes]) break;\n\t\tutf32 = ch & (0XFF - first0Bit[numBytes]);\n\t\tfor (k = 0; k < numBytes; k++) {\n\t\t\tif (in >= MAXSTRING - 1) break;\n\t\t\tif (out >= MAXSTRING - 1) {\n\t\t\t\tcompileError(file, \"Token too long\");\n\t\t\t\tresult->length = lastOutSize;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif (token->chars[in] < 128 || (token->chars[in] & 0x0040)) {\n\t\t\t\tcompileWarning(file, \"invalid UTF-8. Assuming Latin-1.\");\n\t\t\t\tresult->chars[out++] = token->chars[lastIn];\n\t\t\t\tin = lastIn + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tutf32 = (utf32 << 6) + (token->chars[in++] & 0x3f);\n\t\t}\n\t\tif (out >= MAXSTRING - 1) {\n\t\t\tcompileError(file, \"Token too long\");\n\t\t\tresult->length = lastOutSize;\n\t\t\treturn 1;\n\t\t}\n\t\tif (CHARSIZE == 2 && utf32 > 0xffff) utf32 = 0xffff;\n\t\tresult->chars[out++] = (widechar)utf32;\n\t}\n\tresult->length = out;\n\treturn 1;\n}\n\nint EXPORT_CALL\n_lou_extParseChars(const char *inString, widechar *outString) {\n\t/* Parse external character strings */\n\tCharsString wideIn;\n\tCharsString result;\n\tint k;\n\tfor (k = 0; inString[k] && k < MAXSTRING - 1; k++) wideIn.chars[k] = inString[k];\n\twideIn.chars[k] = 0;\n\twideIn.length = k;\n\tparseChars(NULL, &result, &wideIn);\n\tif (errorCount) {\n\t\terrorCount = 0;\n\t\treturn 0;\n\t}\n\tfor (k = 0; k < result.length; k++) outString[k] = result.chars[k];\n\treturn result.length;\n}\n\nstatic int\nparseDots(const FileInfo *file, CharsString *cells, const CharsString *token) {\n\t/* get dot patterns */\n\twidechar cell = 0; /* assembly place for dots */\n\tint cellCount = 0;\n\tint index;\n\tint start = 0;\n\n\tfor (index = 0; index < token->length; index++) {\n\t\tint started = index != start;\n\t\twidechar character = token->chars[index];\n\t\tswitch (character) { /* or dots to make up Braille cell */\n\t\t\t{\n\t\t\t\tint dot;\n\t\t\tcase '1':\n\t\t\t\tdot = LOU_DOT_1;\n\t\t\t\tgoto haveDot;\n\t\t\tcase '2':\n\t\t\t\tdot = LOU_DOT_2;\n\t\t\t\tgoto haveDot;\n\t\t\tcase '3':\n\t\t\t\tdot = LOU_DOT_3;\n\t\t\t\tgoto haveDot;\n\t\t\tcase '4':\n\t\t\t\tdot = LOU_DOT_4;\n\t\t\t\tgoto haveDot;\n\t\t\tcase '5':\n\t\t\t\tdot = LOU_DOT_5;\n\t\t\t\tgoto haveDot;\n\t\t\tcase '6':\n\t\t\t\tdot = LOU_DOT_6;\n\t\t\t\tgoto haveDot;\n\t\t\tcase '7':\n\t\t\t\tdot = LOU_DOT_7;\n\t\t\t\tgoto haveDot;\n\t\t\tcase '8':\n\t\t\t\tdot = LOU_DOT_8;\n\t\t\t\tgoto haveDot;\n\t\t\tcase '9':\n\t\t\t\tdot = LOU_DOT_9;\n\t\t\t\tgoto haveDot;\n\t\t\tcase 'a':\n\t\t\tcase 'A':\n\t\t\t\tdot = LOU_DOT_10;\n\t\t\t\tgoto haveDot;\n\t\t\tcase 'b':\n\t\t\tcase 'B':\n\t\t\t\tdot = LOU_DOT_11;\n\t\t\t\tgoto haveDot;\n\t\t\tcase 'c':\n\t\t\tcase 'C':\n\t\t\t\tdot = LOU_DOT_12;\n\t\t\t\tgoto haveDot;\n\t\t\tcase 'd':\n\t\t\tcase 'D':\n\t\t\t\tdot = LOU_DOT_13;\n\t\t\t\tgoto haveDot;\n\t\t\tcase 'e':\n\t\t\tcase 'E':\n\t\t\t\tdot = LOU_DOT_14;\n\t\t\t\tgoto haveDot;\n\t\t\tcase 'f':\n\t\t\tcase 'F':\n\t\t\t\tdot = LOU_DOT_15;\n\t\t\thaveDot:\n\t\t\t\tif (started && !cell) goto invalid;\n\t\t\t\tif (cell & dot) {\n\t\t\t\t\tcompileError(file, \"dot specified more than once.\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tcell |= dot;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase '0': /* blank */\n\t\t\tif (started) goto invalid;\n\t\t\tbreak;\n\t\tcase '-': /* got all dots for this cell */\n\t\t\tif (!started) {\n\t\t\t\tcompileError(file, \"missing cell specification.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcells->chars[cellCount++] = cell | LOU_DOTS;\n\t\t\tcell = 0;\n\t\t\tstart = index + 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\tinvalid:\n\t\t\tcompileError(\n\t\t\t\t\tfile, \"invalid dot number %s.\", _lou_showString(&character, 1, 0));\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (index == start) {\n\t\tcompileError(file, \"missing cell specification.\");\n\t\treturn 0;\n\t}\n\tcells->chars[cellCount++] = cell | LOU_DOTS; /* last cell */\n\tcells->length = cellCount;\n\treturn 1;\n}\n\nint EXPORT_CALL\n_lou_extParseDots(const char *inString, widechar *outString) {\n\t/* Parse external dot patterns */\n\tCharsString wideIn;\n\tCharsString result;\n\tint k;\n\tfor (k = 0; inString[k] && k < MAXSTRING - 1; k++) wideIn.chars[k] = inString[k];\n\twideIn.chars[k] = 0;\n\twideIn.length = k;\n\tparseDots(NULL, &result, &wideIn);\n\tif (errorCount) {\n\t\terrorCount = 0;\n\t\treturn 0;\n\t}\n\tfor (k = 0; k < result.length; k++) outString[k] = result.chars[k];\n\toutString[k] = 0;\n\treturn result.length;\n}\n\nstatic int\ngetCharacters(FileInfo *file, CharsString *characters) {\n\t/* Get ruleChars string */\n\tCharsString token;\n\tif (!getToken(file, &token, \"characters\")) return 0;\n\treturn parseChars(file, characters, &token);\n}\n\nstatic int\ngetRuleCharsText(FileInfo *file, CharsString *ruleChars) {\n\tCharsString token;\n\tif (!getToken(file, &token, \"Characters operand\")) return 0;\n\treturn parseChars(file, ruleChars, &token);\n}\n\nstatic int\ngetRuleDotsText(FileInfo *file, CharsString *ruleDots) {\n\tCharsString token;\n\tif (!getToken(file, &token, \"characters\")) return 0;\n\treturn parseChars(file, ruleDots, &token);\n}\n\nstatic int\ngetRuleDotsPattern(FileInfo *file, CharsString *ruleDots) {\n\t/* Interpret the dets operand */\n\tCharsString token;\n\tif (!getToken(file, &token, \"Dots operand\")) return 0;\n\tif (token.length == 1 && token.chars[0] == '=') {\n\t\truleDots->length = 0;\n\t\treturn 1;\n\t} else\n\t\treturn parseDots(file, ruleDots, &token);\n}\n\nstatic int\nincludeFile(const FileInfo *file, CharsString *includedFile,\n\t\tTranslationTableHeader **table, DisplayTableHeader **displayTable);\n\nstatic TranslationTableOffset\nfindRuleName(const CharsString *name, const TranslationTableHeader *table) {\n\tconst RuleName *ruleName = table->ruleNames;\n\twhile (ruleName) {\n\t\tif ((name->length == ruleName->length) &&\n\t\t\t\t(memcmp(&name->chars[0], ruleName->name, CHARSIZE * name->length) == 0))\n\t\t\treturn ruleName->ruleOffset;\n\t\truleName = ruleName->next;\n\t}\n\treturn 0;\n}\n\nstatic int\naddRuleName(const FileInfo *file, CharsString *name, TranslationTableOffset ruleOffset,\n\t\tTranslationTableHeader *table) {\n\tint k;\n\tRuleName *ruleName;\n\tif (!(ruleName = malloc(sizeof(*ruleName) + CHARSIZE * (name->length - 1)))) {\n\t\tcompileError(file, \"not enough memory\");\n\t\t_lou_outOfMemory();\n\t}\n\tmemset(ruleName, 0, sizeof(*ruleName));\n\t// a name is a sequence of characters in the ranges 'a'..'z' and 'A'..'Z'\n\tfor (k = 0; k < name->length; k++) {\n\t\twidechar c = name->chars[k];\n\t\tif ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'))\n\t\t\truleName->name[k] = c;\n\t\telse {\n\t\t\tcompileError(file, \"a name may contain only letters\");\n\t\t\tfree(ruleName);\n\t\t\treturn 0;\n\t\t}\n\t}\n\truleName->length = name->length;\n\truleName->ruleOffset = ruleOffset;\n\truleName->next = table->ruleNames;\n\ttable->ruleNames = ruleName;\n\treturn 1;\n}\n\nstatic void\ndeallocateRuleNames(TranslationTableHeader *table) {\n\tRuleName **ruleName = &table->ruleNames;\n\twhile (*ruleName) {\n\t\tRuleName *rn = *ruleName;\n\t\t*ruleName = rn->next;\n\t\tfree(rn);\n\t}\n}\n\nstatic int\ncompileSwapDots(const FileInfo *file, CharsString *source, CharsString *dest) {\n\tint k = 0;\n\tint kk = 0;\n\tCharsString dotsSource;\n\tCharsString dotsDest;\n\tdest->length = 0;\n\tdotsSource.length = 0;\n\twhile (k <= source->length) {\n\t\tif (source->chars[k] != ',' && k != source->length)\n\t\t\tdotsSource.chars[dotsSource.length++] = source->chars[k];\n\t\telse {\n\t\t\tif (!parseDots(file, &dotsDest, &dotsSource)) return 0;\n\t\t\tdest->chars[dest->length++] = dotsDest.length + 1;\n\t\t\tfor (kk = 0; kk < dotsDest.length; kk++)\n\t\t\t\tdest->chars[dest->length++] = dotsDest.chars[kk];\n\t\t\tdotsSource.length = 0;\n\t\t}\n\t\tk++;\n\t}\n\treturn 1;\n}\n\nstatic int\ncompileSwap(FileInfo *file, TranslationTableOpcode opcode, int noback, int nofor,\n\t\tTranslationTableHeader **table) {\n\tCharsString ruleChars;\n\tCharsString ruleDots;\n\tCharsString name;\n\tCharsString matches;\n\tCharsString replacements;\n\tTranslationTableOffset ruleOffset;\n\tif (!getToken(file, &name, \"name operand\")) return 0;\n\tif (!getToken(file, &matches, \"matches operand\")) return 0;\n\tif (!getToken(file, &replacements, \"replacements operand\")) return 0;\n\tif (opcode == CTO_SwapCc || opcode == CTO_SwapCd) {\n\t\tif (!parseChars(file, &ruleChars, &matches)) return 0;\n\t} else {\n\t\tif (!compileSwapDots(file, &matches, &ruleChars)) return 0;\n\t}\n\tif (opcode == CTO_SwapCc) {\n\t\tif (!parseChars(file, &ruleDots, &replacements)) return 0;\n\t} else {\n\t\tif (!compileSwapDots(file, &replacements, &ruleDots)) return 0;\n\t}\n\tif (!addRule(file, opcode, &ruleChars, &ruleDots, 0, 0, &ruleOffset, NULL, noback,\n\t\t\t\tnofor, table))\n\t\treturn 0;\n\tif (!addRuleName(file, &name, ruleOffset, *table)) return 0;\n\treturn 1;\n}\n\nstatic int\ngetNumber(widechar *string, widechar *number) {\n\t/* Convert a string of wide character digits to an integer */\n\tint k = 0;\n\t*number = 0;\n\twhile (string[k] >= '0' && string[k] <= '9')\n\t\t*number = 10 * *number + (string[k++] - '0');\n\treturn k;\n}\n\n/* Start of multipass compiler */\n\nstatic int\npassGetAttributes(CharsString *passLine, int *passLinepos,\n\t\tTranslationTableCharacterAttributes *attributes, const FileInfo *file) {\n\tint more = 1;\n\t*attributes = 0;\n\twhile (more) {\n\t\tswitch (passLine->chars[*passLinepos]) {\n\t\tcase pass_any:\n\t\t\t*attributes = 0xffffffff;\n\t\t\tbreak;\n\t\tcase pass_digit:\n\t\t\t*attributes |= CTC_Digit;\n\t\t\tbreak;\n\t\tcase pass_litDigit:\n\t\t\t*attributes |= CTC_LitDigit;\n\t\t\tbreak;\n\t\tcase pass_letter:\n\t\t\t*attributes |= CTC_Letter;\n\t\t\tbreak;\n\t\tcase pass_math:\n\t\t\t*attributes |= CTC_Math;\n\t\t\tbreak;\n\t\tcase pass_punctuation:\n\t\t\t*attributes |= CTC_Punctuation;\n\t\t\tbreak;\n\t\tcase pass_sign:\n\t\t\t*attributes |= CTC_Sign;\n\t\t\tbreak;\n\t\tcase pass_space:\n\t\t\t*attributes |= CTC_Space;\n\t\t\tbreak;\n\t\tcase pass_uppercase:\n\t\t\t*attributes |= CTC_UpperCase;\n\t\t\tbreak;\n\t\tcase pass_lowercase:\n\t\t\t*attributes |= CTC_LowerCase;\n\t\t\tbreak;\n\t\tcase pass_class1:\n\t\t\t*attributes |= CTC_UserDefined9;\n\t\t\tbreak;\n\t\tcase pass_class2:\n\t\t\t*attributes |= CTC_UserDefined10;\n\t\t\tbreak;\n\t\tcase pass_class3:\n\t\t\t*attributes |= CTC_UserDefined11;\n\t\t\tbreak;\n\t\tcase pass_class4:\n\t\t\t*attributes |= CTC_UserDefined12;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmore = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (more) (*passLinepos)++;\n\t}\n\tif (!*attributes) {\n\t\tcompileError(file, \"missing attribute\");\n\t\t(*passLinepos)--;\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic int\npassGetDots(CharsString *passLine, int *passLinepos, CharsString *dots,\n\t\tconst FileInfo *file) {\n\tCharsString collectDots;\n\tcollectDots.length = 0;\n\twhile (*passLinepos < passLine->length &&\n\t\t\t(passLine->chars[*passLinepos] == '-' ||\n\t\t\t\t\t(passLine->chars[*passLinepos] >= '0' &&\n\t\t\t\t\t\t\tpassLine->chars[*passLinepos] <= '9') ||\n\t\t\t\t\t((passLine->chars[*passLinepos] | 32) >= 'a' &&\n\t\t\t\t\t\t\t(passLine->chars[*passLinepos] | 32) <= 'f')))\n\t\tcollectDots.chars[collectDots.length++] = passLine->chars[(*passLinepos)++];\n\tif (!parseDots(file, dots, &collectDots)) return 0;\n\treturn 1;\n}\n\nstatic int\npassGetString(CharsString *passLine, int *passLinepos, CharsString *string,\n\t\tconst FileInfo *file) {\n\tstring->length = 0;\n\twhile (1) {\n\t\tif ((*passLinepos >= passLine->length) || !passLine->chars[*passLinepos]) {\n\t\t\tcompileError(file, \"unterminated string\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (passLine->chars[*passLinepos] == 34) break;\n\t\tif (passLine->chars[*passLinepos] == QUOTESUB)\n\t\t\tstring->chars[string->length++] = 34;\n\t\telse\n\t\t\tstring->chars[string->length++] = passLine->chars[*passLinepos];\n\t\t(*passLinepos)++;\n\t}\n\tstring->chars[string->length] = 0;\n\t(*passLinepos)++;\n\treturn 1;\n}\n\nstatic int\npassGetNumber(CharsString *passLine, int *passLinepos, widechar *number) {\n\t/* Convert a string of wide character digits to an integer */\n\t*number = 0;\n\twhile ((*passLinepos < passLine->length) && (passLine->chars[*passLinepos] >= '0') &&\n\t\t\t(passLine->chars[*passLinepos] <= '9'))\n\t\t*number = 10 * (*number) + (passLine->chars[(*passLinepos)++] - '0');\n\treturn 1;\n}\n\nstatic int\npassGetVariableNumber(\n\t\tconst FileInfo *file, CharsString *passLine, int *passLinepos, widechar *number) {\n\tif (!passGetNumber(passLine, passLinepos, number)) {\n\t\tcompileError(file, \"missing variable number\");\n\t\treturn 0;\n\t}\n\tif ((*number >= 0) && (*number < NUMVAR)) return 1;\n\tcompileError(file, \"variable number out of range\");\n\treturn 0;\n}\n\nstatic int\npassGetName(CharsString *passLine, int *passLinepos, CharsString *name) {\n\tname->length = 0;\n\t// a name is a sequence of characters in the ranges 'a'..'z' and 'A'..'Z'\n\tdo {\n\t\twidechar c = passLine->chars[*passLinepos];\n\t\tif ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {\n\t\t\tname->chars[name->length++] = c;\n\t\t\t(*passLinepos)++;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t} while (*passLinepos < passLine->length);\n\treturn 1;\n}\n\nstatic inline int\nwantsString(TranslationTableOpcode opcode, int actionPart, int nofor) {\n\tif (opcode == CTO_Correct) return 1;\n\tif (opcode != CTO_Context) return 0;\n\treturn !nofor == !actionPart;\n}\n\nstatic int\nverifyStringOrDots(const FileInfo *file, TranslationTableOpcode opcode, int isString,\n\t\tint actionPart, int nofor) {\n\tif (!wantsString(opcode, actionPart, nofor) == !isString) return 1;\n\n\tcompileError(file, \"%s are not allowed in the %s part of a %s translation %s rule.\",\n\t\t\tisString ? \"strings\" : \"dots\", getPartName(actionPart),\n\t\t\tnofor ? \"backward\" : \"forward\", _lou_findOpcodeName(opcode));\n\n\treturn 0;\n}\n\nstatic int\ncompilePassOpcode(const FileInfo *file, TranslationTableOpcode opcode, int noback,\n\t\tint nofor, TranslationTableHeader **table) {\n\tstatic CharsString passRuleChars;\n\tstatic CharsString passRuleDots;\n\t/* Compile the operands of a pass opcode */\n\twidechar passSubOp;\n\tconst CharacterClass *class;\n\tTranslationTableRule *rule = NULL;\n\tint k;\n\tint kk = 0;\n\tint endTest = 0;\n\twidechar *passInstructions = passRuleDots.chars;\n\tint passIC = 0; /* Instruction counter */\n\tpassRuleChars.length = 0;\n\tCharsString passHoldString;\n\twidechar passHoldNumber;\n\tCharsString passLine;\n\tint passLinepos = 0;\n\tTranslationTableCharacterAttributes passAttributes;\n\tpassHoldString.length = 0;\n\tfor (k = file->linepos; k < file->linelen; k++)\n\t\tpassHoldString.chars[passHoldString.length++] = file->line[k];\n#define SEPCHAR 0x0001\n\tfor (k = 0; k < passHoldString.length && passHoldString.chars[k] > 32; k++)\n\t\t;\n\tif (k < passHoldString.length)\n\t\tpassHoldString.chars[k] = SEPCHAR;\n\telse {\n\t\tcompileError(file, \"Invalid multipass operands\");\n\t\treturn 0;\n\t}\n\tparseChars(file, &passLine, &passHoldString);\n\t/* Compile test part */\n\tfor (k = 0; k < passLine.length && passLine.chars[k] != SEPCHAR; k++)\n\t\t;\n\tendTest = k;\n\tpassLine.chars[endTest] = pass_endTest;\n\tpassLinepos = 0;\n\twhile (passLinepos <= endTest) {\n\t\tif (passIC >= MAXSTRING) {\n\t\t\tcompileError(file, \"Test part in multipass operand too long\");\n\t\t\treturn 0;\n\t\t}\n\t\tswitch ((passSubOp = passLine.chars[passLinepos])) {\n\t\tcase pass_lookback:\n\t\t\tpassInstructions[passIC++] = pass_lookback;\n\t\t\tpassLinepos++;\n\t\t\tpassGetNumber(&passLine, &passLinepos, &passHoldNumber);\n\t\t\tif (passHoldNumber == 0) passHoldNumber = 1;\n\t\t\tpassInstructions[passIC++] = passHoldNumber;\n\t\t\tbreak;\n\t\tcase pass_not:\n\t\t\tpassInstructions[passIC++] = pass_not;\n\t\t\tpassLinepos++;\n\t\t\tbreak;\n\t\tcase pass_first:\n\t\t\tpassInstructions[passIC++] = pass_first;\n\t\t\tpassLinepos++;\n\t\t\tbreak;\n\t\tcase pass_last:\n\t\t\tpassInstructions[passIC++] = pass_last;\n\t\t\tpassLinepos++;\n\t\t\tbreak;\n\t\tcase pass_search:\n\t\t\tpassInstructions[passIC++] = pass_search;\n\t\t\tpassLinepos++;\n\t\t\tbreak;\n\t\tcase pass_string:\n\t\t\tif (!verifyStringOrDots(file, opcode, 1, 0, nofor)) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tpassLinepos++;\n\t\t\tpassInstructions[passIC++] = pass_string;\n\t\t\tpassGetString(&passLine, &passLinepos, &passHoldString, file);\n\t\t\tif (passHoldString.length == 0) {\n\t\t\t\tcompileError(file, \"empty string in test part\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tgoto testDoCharsDots;\n\t\tcase pass_dots:\n\t\t\tif (!verifyStringOrDots(file, opcode, 0, 0, nofor)) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tpassLinepos++;\n\t\t\tpassInstructions[passIC++] = pass_dots;\n\t\t\tpassGetDots(&passLine, &passLinepos, &passHoldString, file);\n\t\t\tif (passHoldString.length == 0) {\n\t\t\t\tcompileError(file, \"expected dot pattern after @ operand in test part\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\ttestDoCharsDots:\n\t\t\tif (passIC >= MAXSTRING) {\n\t\t\t\tcompileError(\n\t\t\t\t\t\tfile, \"@ operand in test part of multipass operand too long\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tpassInstructions[passIC++] = passHoldString.length;\n\t\t\tfor (kk = 0; kk < passHoldString.length; kk++) {\n\t\t\t\tif (passIC >= MAXSTRING) {\n\t\t\t\t\tcompileError(\n\t\t\t\t\t\t\tfile, \"@ operand in test part of multipass operand too long\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tpassInstructions[passIC++] = passHoldString.chars[kk];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase pass_startReplace:\n\t\t\tpassInstructions[passIC++] = pass_startReplace;\n\t\t\tpassLinepos++;\n\t\t\tbreak;\n\t\tcase pass_endReplace:\n\t\t\tpassInstructions[passIC++] = pass_endReplace;\n\t\t\tpassLinepos++;\n\t\t\tbreak;\n\t\tcase pass_variable:\n\t\t\tpassLinepos++;\n\t\t\tif (!passGetVariableNumber(file, &passLine, &passLinepos, &passHoldNumber))\n\t\t\t\treturn 0;\n\t\t\tswitch (passLine.chars[passLinepos]) {\n\t\t\tcase pass_eq:\n\t\t\t\tpassInstructions[passIC++] = pass_eq;\n\t\t\t\tgoto doComp;\n\t\t\tcase pass_lt:\n\t\t\t\tif (passLine.chars[passLinepos + 1] == pass_eq) {\n\t\t\t\t\tpassLinepos++;\n\t\t\t\t\tpassInstructions[passIC++] = pass_lteq;\n\t\t\t\t} else\n\t\t\t\t\tpassInstructions[passIC++] = pass_lt;\n\t\t\t\tgoto doComp;\n\t\t\tcase pass_gt:\n\t\t\t\tif (passLine.chars[passLinepos + 1] == pass_eq) {\n\t\t\t\t\tpassLinepos++;\n\t\t\t\t\tpassInstructions[passIC++] = pass_gteq;\n\t\t\t\t} else\n\t\t\t\t\tpassInstructions[passIC++] = pass_gt;\n\t\t\tdoComp:\n\t\t\t\tpassInstructions[passIC++] = passHoldNumber;\n\t\t\t\tpassLinepos++;\n\t\t\t\tpassGetNumber(&passLine, &passLinepos, &passHoldNumber);\n\t\t\t\tpassInstructions[passIC++] = passHoldNumber;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tcompileError(file, \"incorrect comparison operator\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase pass_attributes:\n\t\t\tpassLinepos++;\n\t\t\tif (!passGetAttributes(&passLine, &passLinepos, &passAttributes, file))\n\t\t\t\treturn 0;\n\t\tinsertAttributes:\n\t\t\tpassInstructions[passIC++] = pass_attributes;\n\t\t\tpassInstructions[passIC++] = (passAttributes >> 48) & 0xffff;\n\t\t\tpassInstructions[passIC++] = (passAttributes >> 32) & 0xffff;\n\t\t\tpassInstructions[passIC++] = (passAttributes >> 16) & 0xffff;\n\t\t\tpassInstructions[passIC++] = passAttributes & 0xffff;\n\t\tgetRange:\n\t\t\tif (passLine.chars[passLinepos] == pass_until) {\n\t\t\t\tpassLinepos++;\n\t\t\t\tpassInstructions[passIC++] = 1;\n\t\t\t\tpassInstructions[passIC++] = 0xffff;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpassGetNumber(&passLine, &passLinepos, &passHoldNumber);\n\t\t\tif (passHoldNumber == 0) {\n\t\t\t\tpassHoldNumber = passInstructions[passIC++] = 1;\n\t\t\t\tpassInstructions[passIC++] = 1; /* This is not an error */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpassInstructions[passIC++] = passHoldNumber;\n\t\t\tif (passLine.chars[passLinepos] != pass_hyphen) {\n\t\t\t\tpassInstructions[passIC++] = passHoldNumber;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpassLinepos++;\n\t\t\tpassGetNumber(&passLine, &passLinepos, &passHoldNumber);\n\t\t\tif (passHoldNumber == 0) {\n\t\t\t\tcompileError(file, \"invalid range\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tpassInstructions[passIC++] = passHoldNumber;\n\t\t\tbreak;\n\t\tcase pass_groupstart:\n\t\tcase pass_groupend: {\n\t\t\tpassLinepos++;\n\t\t\tpassGetName(&passLine, &passLinepos, &passHoldString);\n\t\t\tTranslationTableOffset ruleOffset = findRuleName(&passHoldString, *table);\n\t\t\tif (ruleOffset)\n\t\t\t\trule = (TranslationTableRule *)&(*table)->ruleArea[ruleOffset];\n\t\t\tif (rule && rule->opcode == CTO_Grouping) {\n\t\t\t\tpassInstructions[passIC++] = passSubOp;\n\t\t\t\tpassInstructions[passIC++] = ruleOffset >> 16;\n\t\t\t\tpassInstructions[passIC++] = ruleOffset & 0xffff;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tcompileError(file, \"%s is not a grouping name\",\n\t\t\t\t\t\t_lou_showString(\n\t\t\t\t\t\t\t\t&passHoldString.chars[0], passHoldString.length, 0));\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase pass_swap: {\n\t\t\tpassLinepos++;\n\t\t\tpassGetName(&passLine, &passLinepos, &passHoldString);\n\t\t\tif ((class = findCharacterClass(&passHoldString, *table))) {\n\t\t\t\tpassAttributes = class->attribute;\n\t\t\t\tgoto insertAttributes;\n\t\t\t}\n\t\t\tTranslationTableOffset ruleOffset = findRuleName(&passHoldString, *table);\n\t\t\tif (ruleOffset)\n\t\t\t\trule = (TranslationTableRule *)&(*table)->ruleArea[ruleOffset];\n\t\t\tif (rule &&\n\t\t\t\t\t(rule->opcode == CTO_SwapCc || rule->opcode == CTO_SwapCd ||\n\t\t\t\t\t\t\trule->opcode == CTO_SwapDd)) {\n\t\t\t\tpassInstructions[passIC++] = pass_swap;\n\t\t\t\tpassInstructions[passIC++] = ruleOffset >> 16;\n\t\t\t\tpassInstructions[passIC++] = ruleOffset & 0xffff;\n\t\t\t\tgoto getRange;\n\t\t\t}\n\t\t\tcompileError(file, \"%s is neither a class name nor a swap name.\",\n\t\t\t\t\t_lou_showString(&passHoldString.chars[0], passHoldString.length, 0));\n\t\t\treturn 0;\n\t\t}\n\t\tcase pass_endTest:\n\t\t\tpassInstructions[passIC++] = pass_endTest;\n\t\t\tpassLinepos++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcompileError(file, \"incorrect operator '%c ' in test part\",\n\t\t\t\t\tpassLine.chars[passLinepos]);\n\t\t\treturn 0;\n\t\t}\n\n\t} /* Compile action part */\n\n\t/* Compile action part */\n\twhile (passLinepos < passLine.length && passLine.chars[passLinepos] <= 32)\n\t\tpassLinepos++;\n\twhile (passLinepos < passLine.length && passLine.chars[passLinepos] > 32) {\n\t\tif (passIC >= MAXSTRING) {\n\t\t\tcompileError(file, \"Action part in multipass operand too long\");\n\t\t\treturn 0;\n\t\t}\n\t\tswitch ((passSubOp = passLine.chars[passLinepos])) {\n\t\tcase pass_string:\n\t\t\tif (!verifyStringOrDots(file, opcode, 1, 1, nofor)) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tpassLinepos++;\n\t\t\tpassInstructions[passIC++] = pass_string;\n\t\t\tpassGetString(&passLine, &passLinepos, &passHoldString, file);\n\t\t\tgoto actionDoCharsDots;\n\t\tcase pass_dots:\n\t\t\tif (!verifyStringOrDots(file, opcode, 0, 1, nofor)) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tpassLinepos++;\n\t\t\tpassGetDots(&passLine, &passLinepos, &passHoldString, file);\n\t\t\tpassInstructions[passIC++] = pass_dots;\n\t\t\tif (passHoldString.length == 0) {\n\t\t\t\tcompileError(file, \"expected dot pattern after @ operand in action part\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\tactionDoCharsDots:\n\t\t\tif (passIC >= MAXSTRING) {\n\t\t\t\tcompileError(\n\t\t\t\t\t\tfile, \"@ operand in action part of multipass operand too long\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tpassInstructions[passIC++] = passHoldString.length;\n\t\t\tfor (kk = 0; kk < passHoldString.length; kk++) {\n\t\t\t\tif (passIC >= MAXSTRING) {\n\t\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\t\"@ operand in action part of multipass operand too long\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tpassInstructions[passIC++] = passHoldString.chars[kk];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase pass_variable:\n\t\t\tpassLinepos++;\n\t\t\tif (!passGetVariableNumber(file, &passLine, &passLinepos, &passHoldNumber))\n\t\t\t\treturn 0;\n\t\t\tswitch (passLine.chars[passLinepos]) {\n\t\t\tcase pass_eq:\n\t\t\t\tpassInstructions[passIC++] = pass_eq;\n\t\t\t\tpassInstructions[passIC++] = passHoldNumber;\n\t\t\t\tpassLinepos++;\n\t\t\t\tpassGetNumber(&passLine, &passLinepos, &passHoldNumber);\n\t\t\t\tpassInstructions[passIC++] = passHoldNumber;\n\t\t\t\tbreak;\n\t\t\tcase pass_plus:\n\t\t\tcase pass_hyphen:\n\t\t\t\tpassInstructions[passIC++] = passLine.chars[passLinepos++];\n\t\t\t\tpassInstructions[passIC++] = passHoldNumber;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tcompileError(file, \"incorrect variable operator in action part\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase pass_copy:\n\t\t\tpassInstructions[passIC++] = pass_copy;\n\t\t\tpassLinepos++;\n\t\t\tbreak;\n\t\tcase pass_omit:\n\t\t\tpassInstructions[passIC++] = pass_omit;\n\t\t\tpassLinepos++;\n\t\t\tbreak;\n\t\tcase pass_groupreplace:\n\t\tcase pass_groupstart:\n\t\tcase pass_groupend: {\n\t\t\tpassLinepos++;\n\t\t\tpassGetName(&passLine, &passLinepos, &passHoldString);\n\t\t\tTranslationTableOffset ruleOffset = findRuleName(&passHoldString, *table);\n\t\t\tif (ruleOffset)\n\t\t\t\trule = (TranslationTableRule *)&(*table)->ruleArea[ruleOffset];\n\t\t\tif (rule && rule->opcode == CTO_Grouping) {\n\t\t\t\tpassInstructions[passIC++] = passSubOp;\n\t\t\t\tpassInstructions[passIC++] = ruleOffset >> 16;\n\t\t\t\tpassInstructions[passIC++] = ruleOffset & 0xffff;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcompileError(file, \"%s is not a grouping name\",\n\t\t\t\t\t_lou_showString(&passHoldString.chars[0], passHoldString.length, 0));\n\t\t\treturn 0;\n\t\t}\n\t\tcase pass_swap: {\n\t\t\tpassLinepos++;\n\t\t\tpassGetName(&passLine, &passLinepos, &passHoldString);\n\t\t\tTranslationTableOffset ruleOffset = findRuleName(&passHoldString, *table);\n\t\t\tif (ruleOffset)\n\t\t\t\trule = (TranslationTableRule *)&(*table)->ruleArea[ruleOffset];\n\t\t\tif (rule &&\n\t\t\t\t\t(rule->opcode == CTO_SwapCc || rule->opcode == CTO_SwapCd ||\n\t\t\t\t\t\t\trule->opcode == CTO_SwapDd)) {\n\t\t\t\tpassInstructions[passIC++] = pass_swap;\n\t\t\t\tpassInstructions[passIC++] = ruleOffset >> 16;\n\t\t\t\tpassInstructions[passIC++] = ruleOffset & 0xffff;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcompileError(file, \"%s is not a swap name.\",\n\t\t\t\t\t_lou_showString(&passHoldString.chars[0], passHoldString.length, 0));\n\t\t\treturn 0;\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tcompileError(file, \"incorrect operator in action part\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* Analyze and add rule */\n\tpassRuleDots.length = passIC;\n\n\t{\n\t\twidechar *characters;\n\t\tint length;\n\t\tint found = passFindCharacters(\n\t\t\t\tfile, passInstructions, passRuleDots.length, &characters, &length);\n\n\t\tif (!found) return 0;\n\n\t\tif (characters) {\n\t\t\tfor (k = 0; k < length; k += 1) passRuleChars.chars[k] = characters[k];\n\t\t\tpassRuleChars.length = k;\n\t\t}\n\t}\n\n\tif (!addRule(file, opcode, &passRuleChars, &passRuleDots, 0, 0, NULL, NULL, noback,\n\t\t\t\tnofor, table))\n\t\treturn 0;\n\treturn 1;\n}\n\n/* End of multipass compiler */\n\nstatic int\ncompileBrailleIndicator(FileInfo *file, const char *ermsg, TranslationTableOpcode opcode,\n\t\tTranslationTableOffset *ruleOffset, int noback, int nofor,\n\t\tTranslationTableHeader **table) {\n\tCharsString token;\n\tCharsString cells;\n\tif (!getToken(file, &token, ermsg)) return 0;\n\tif (!parseDots(file, &cells, &token)) return 0;\n\treturn addRule(\n\t\t\tfile, opcode, NULL, &cells, 0, 0, ruleOffset, NULL, noback, nofor, table);\n}\n\nstatic int\ncompileNumber(FileInfo *file) {\n\tCharsString token;\n\twidechar number;\n\tif (!getToken(file, &token, \"number\")) return 0;\n\tgetNumber(&token.chars[0], &number);\n\tif (!(number > 0)) {\n\t\tcompileError(file, \"a nonzero positive number is required\");\n\t\treturn 0;\n\t}\n\treturn number;\n}\n\nstatic int\ncompileGrouping(FileInfo *file, int noback, int nofor, TranslationTableHeader **table,\n\t\tDisplayTableHeader **displayTable) {\n\tint k;\n\tCharsString name;\n\tCharsString groupChars;\n\tCharsString groupDots;\n\tCharsString dotsParsed;\n\tif (!getToken(file, &name, \"name operand\")) return 0;\n\tif (!getRuleCharsText(file, &groupChars)) return 0;\n\tif (!getToken(file, &groupDots, \"dots operand\")) return 0;\n\tfor (k = 0; k < groupDots.length && groupDots.chars[k] != ','; k++)\n\t\t;\n\tif (k == groupDots.length) {\n\t\tcompileError(file, \"Dots operand must consist of two cells separated by a comma\");\n\t\treturn 0;\n\t}\n\tgroupDots.chars[k] = '-';\n\tif (!parseDots(file, &dotsParsed, &groupDots)) return 0;\n\tif (groupChars.length != 2 || dotsParsed.length != 2) {\n\t\tcompileError(file,\n\t\t\t\t\"two Unicode characters and two cells separated by a comma are needed.\");\n\t\treturn 0;\n\t}\n\tif (table) {\n\t\tTranslationTableOffset ruleOffset;\n\t\tTranslationTableCharacter *charsDotsPtr;\n\t\tcharsDotsPtr = putChar(file, groupChars.chars[0], table, NULL);\n\t\tcharsDotsPtr->attributes |= CTC_Math;\n\t\tcharsDotsPtr = putChar(file, groupChars.chars[1], table, NULL);\n\t\tcharsDotsPtr->attributes |= CTC_Math;\n\t\tcharsDotsPtr = putDots(file, dotsParsed.chars[0], table);\n\t\tcharsDotsPtr->attributes |= CTC_Math;\n\t\tcharsDotsPtr = putDots(file, dotsParsed.chars[1], table);\n\t\tcharsDotsPtr->attributes |= CTC_Math;\n\t\tif (!addRule(file, CTO_Grouping, &groupChars, &dotsParsed, 0, 0, &ruleOffset,\n\t\t\t\t\tNULL, noback, nofor, table))\n\t\t\treturn 0;\n\t\tif (!addRuleName(file, &name, ruleOffset, *table)) return 0;\n\t}\n\tif (displayTable) {\n\t\tputCharDotsMapping(file, groupChars.chars[0], dotsParsed.chars[0], displayTable);\n\t\tputCharDotsMapping(file, groupChars.chars[1], dotsParsed.chars[1], displayTable);\n\t}\n\tif (table) {\n\t\twidechar endChar;\n\t\twidechar endDots;\n\t\tendChar = groupChars.chars[1];\n\t\tendDots = dotsParsed.chars[1];\n\t\tgroupChars.length = dotsParsed.length = 1;\n\t\tif (!addRule(file, CTO_Math, &groupChars, &dotsParsed, 0, 0, NULL, NULL, noback,\n\t\t\t\t\tnofor, table))\n\t\t\treturn 0;\n\t\tgroupChars.chars[0] = endChar;\n\t\tdotsParsed.chars[0] = endDots;\n\t\tif (!addRule(file, CTO_Math, &groupChars, &dotsParsed, 0, 0, NULL, NULL, noback,\n\t\t\t\t\tnofor, table))\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n/* Functions for compiling hyphenation tables */\n\ntypedef struct HyphenDict { /* hyphenation dictionary: finite state machine */\n\tint numStates;\n\tHyphenationState *states;\n} HyphenDict;\n\n#define DEFAULTSTATE 0xffff\n#define HYPHENHASHSIZE 8191\n\ntypedef struct HyphenHashEntry {\n\tstruct HyphenHashEntry *next;\n\tCharsString *key;\n\tint val;\n} HyphenHashEntry;\n\ntypedef struct HyphenHashTab {\n\tHyphenHashEntry *entries[HYPHENHASHSIZE];\n} HyphenHashTab;\n\n/* a hash function from ASU - adapted from Gtk+ */\nstatic unsigned int\nhyphenStringHash(const CharsString *s) {\n\tint k;\n\tunsigned int h = 0, g;\n\tfor (k = 0; k < s->length; k++) {\n\t\th = (h << 4) + s->chars[k];\n\t\tif ((g = h & 0xf0000000)) {\n\t\t\th = h ^ (g >> 24);\n\t\t\th = h ^ g;\n\t\t}\n\t}\n\treturn h;\n}\n\nstatic HyphenHashTab *\nhyphenHashNew(void) {\n\tHyphenHashTab *hashTab;\n\tif (!(hashTab = malloc(sizeof(HyphenHashTab)))) _lou_outOfMemory();\n\tmemset(hashTab, 0, sizeof(HyphenHashTab));\n\treturn hashTab;\n}\n\nstatic void\nhyphenHashFree(HyphenHashTab *hashTab) {\n\tint i;\n\tHyphenHashEntry *e, *next;\n\tfor (i = 0; i < HYPHENHASHSIZE; i++)\n\t\tfor (e = hashTab->entries[i]; e; e = next) {\n\t\t\tnext = e->next;\n\t\t\tfree(e->key);\n\t\t\tfree(e);\n\t\t}\n\tfree(hashTab);\n}\n\n/* assumes that key is not already present! */\nstatic void\nhyphenHashInsert(HyphenHashTab *hashTab, const CharsString *key, int val) {\n\tint i, j;\n\tHyphenHashEntry *e;\n\ti = hyphenStringHash(key) % HYPHENHASHSIZE;\n\tif (!(e = malloc(sizeof(HyphenHashEntry)))) _lou_outOfMemory();\n\te->next = hashTab->entries[i];\n\te->key = malloc((key->length + 1) * CHARSIZE);\n\tif (!e->key) _lou_outOfMemory();\n\te->key->length = key->length;\n\tfor (j = 0; j < key->length; j++) e->key->chars[j] = key->chars[j];\n\te->val = val;\n\thashTab->entries[i] = e;\n}\n\n/* return val if found, otherwise DEFAULTSTATE */\nstatic int\nhyphenHashLookup(HyphenHashTab *hashTab, const CharsString *key) {\n\tint i, j;\n\tHyphenHashEntry *e;\n\tif (key->length == 0) return 0;\n\ti = hyphenStringHash(key) % HYPHENHASHSIZE;\n\tfor (e = hashTab->entries[i]; e; e = e->next) {\n\t\tif (key->length != e->key->length) continue;\n\t\tfor (j = 0; j < key->length; j++)\n\t\t\tif (key->chars[j] != e->key->chars[j]) break;\n\t\tif (j == key->length) return e->val;\n\t}\n\treturn DEFAULTSTATE;\n}\n\nstatic int\nhyphenGetNewState(HyphenDict *dict, HyphenHashTab *hashTab, const CharsString *string) {\n\thyphenHashInsert(hashTab, string, dict->numStates);\n\t/* predicate is true if dict->numStates is a power of two */\n\tif (!(dict->numStates & (dict->numStates - 1)))\n\t\tdict->states =\n\t\t\t\trealloc(dict->states, (dict->numStates << 1) * sizeof(HyphenationState));\n\tif (!dict->states) _lou_outOfMemory();\n\tdict->states[dict->numStates].hyphenPattern = 0;\n\tdict->states[dict->numStates].fallbackState = DEFAULTSTATE;\n\tdict->states[dict->numStates].numTrans = 0;\n\tdict->states[dict->numStates].trans.pointer = NULL;\n\treturn dict->numStates++;\n}\n\n/* add a transition from state1 to state2 through ch - assumes that the\n * transition does not already exist */\nstatic void\nhyphenAddTrans(HyphenDict *dict, int state1, int state2, widechar ch) {\n\tint numTrans;\n\tnumTrans = dict->states[state1].numTrans;\n\tif (numTrans == 0)\n\t\tdict->states[state1].trans.pointer = malloc(sizeof(HyphenationTrans));\n\telse if (!(numTrans & (numTrans - 1)))\n\t\tdict->states[state1].trans.pointer = realloc(dict->states[state1].trans.pointer,\n\t\t\t\t(numTrans << 1) * sizeof(HyphenationTrans));\n\tdict->states[state1].trans.pointer[numTrans].ch = ch;\n\tdict->states[state1].trans.pointer[numTrans].newState = state2;\n\tdict->states[state1].numTrans++;\n}\n\nstatic int\ncompileHyphenation(\n\t\tFileInfo *file, CharsString *encoding, TranslationTableHeader **table) {\n\tCharsString hyph;\n\tHyphenationTrans *holdPointer;\n\tHyphenHashTab *hashTab;\n\tCharsString word;\n\tchar pattern[MAXSTRING + 1];\n\tunsigned int stateNum = 0, lastState = 0;\n\tint i, j, k = encoding->length;\n\twidechar ch;\n\tint found;\n\tHyphenHashEntry *e;\n\tHyphenDict dict;\n\tTranslationTableOffset holdOffset;\n\t/* Set aside enough space for hyphenation states and transitions in\n\t * translation table. Must be done before anything else */\n\tallocateSpaceInTranslationTable(file, NULL, 250000, table);\n\thashTab = hyphenHashNew();\n\tdict.numStates = 1;\n\tdict.states = malloc(sizeof(HyphenationState));\n\tif (!dict.states) _lou_outOfMemory();\n\tdict.states[0].hyphenPattern = 0;\n\tdict.states[0].fallbackState = DEFAULTSTATE;\n\tdict.states[0].numTrans = 0;\n\tdict.states[0].trans.pointer = NULL;\n\tdo {\n\t\tif (encoding->chars[0] == 'I') {\n\t\t\tif (!getToken(file, &hyph, NULL)) continue;\n\t\t} else {\n\t\t\t/* UTF-8 */\n\t\t\tif (!getToken(file, &word, NULL)) continue;\n\t\t\tparseChars(file, &hyph, &word);\n\t\t}\n\t\tif (hyph.length == 0 || hyph.chars[0] == '#' || hyph.chars[0] == '%' ||\n\t\t\t\thyph.chars[0] == '<')\n\t\t\tcontinue; /* comment */\n\t\tj = 0;\n\t\tpattern[j] = '0';\n\t\tfor (i = 0; i < hyph.length; i++) {\n\t\t\tif (hyph.chars[i] >= '0' && hyph.chars[i] <= '9')\n\t\t\t\tpattern[j] = (char)hyph.chars[i];\n\t\t\telse {\n\t\t\t\tword.chars[j] = hyph.chars[i];\n\t\t\t\tpattern[++j] = '0';\n\t\t\t}\n\t\t}\n\t\tword.chars[j] = 0;\n\t\tword.length = j;\n\t\tpattern[j + 1] = 0;\n\t\tfor (i = 0; pattern[i] == '0'; i++)\n\t\t\t;\n\t\tfound = hyphenHashLookup(hashTab, &word);\n\t\tif (found != DEFAULTSTATE)\n\t\t\tstateNum = found;\n\t\telse\n\t\t\tstateNum = hyphenGetNewState(&dict, hashTab, &word);\n\t\tk = j + 2 - i;\n\t\tif (k > 0) {\n\t\t\tallocateSpaceInTranslationTable(\n\t\t\t\t\tfile, &dict.states[stateNum].hyphenPattern, k, table);\n\t\t\tmemcpy(&(*table)->ruleArea[dict.states[stateNum].hyphenPattern], &pattern[i],\n\t\t\t\t\tk);\n\t\t}\n\t\t/* now, put in the prefix transitions */\n\t\twhile (found == DEFAULTSTATE) {\n\t\t\tlastState = stateNum;\n\t\t\tch = word.chars[word.length-- - 1];\n\t\t\tfound = hyphenHashLookup(hashTab, &word);\n\t\t\tif (found != DEFAULTSTATE)\n\t\t\t\tstateNum = found;\n\t\t\telse\n\t\t\t\tstateNum = hyphenGetNewState(&dict, hashTab, &word);\n\t\t\thyphenAddTrans(&dict, stateNum, lastState, ch);\n\t\t}\n\t} while (_lou_getALine(file));\n\t/* put in the fallback states */\n\tfor (i = 0; i < HYPHENHASHSIZE; i++) {\n\t\tfor (e = hashTab->entries[i]; e; e = e->next) {\n\t\t\tfor (j = 1; j <= e->key->length; j++) {\n\t\t\t\tword.length = 0;\n\t\t\t\tfor (k = j; k < e->key->length; k++)\n\t\t\t\t\tword.chars[word.length++] = e->key->chars[k];\n\t\t\t\tstateNum = hyphenHashLookup(hashTab, &word);\n\t\t\t\tif (stateNum != DEFAULTSTATE) break;\n\t\t\t}\n\t\t\tif (e->val) dict.states[e->val].fallbackState = stateNum;\n\t\t}\n\t}\n\thyphenHashFree(hashTab);\n\t/* Transfer hyphenation information to table */\n\tfor (i = 0; i < dict.numStates; i++) {\n\t\tif (dict.states[i].numTrans == 0)\n\t\t\tdict.states[i].trans.offset = 0;\n\t\telse {\n\t\t\tholdPointer = dict.states[i].trans.pointer;\n\t\t\tallocateSpaceInTranslationTable(file, &dict.states[i].trans.offset,\n\t\t\t\t\tdict.states[i].numTrans * sizeof(HyphenationTrans), table);\n\t\t\tmemcpy(&(*table)->ruleArea[dict.states[i].trans.offset], holdPointer,\n\t\t\t\t\tdict.states[i].numTrans * sizeof(HyphenationTrans));\n\t\t\tfree(holdPointer);\n\t\t}\n\t}\n\tallocateSpaceInTranslationTable(\n\t\t\tfile, &holdOffset, dict.numStates * sizeof(HyphenationState), table);\n\t(*table)->hyphenStatesArray = holdOffset;\n\t/* Prevents segmentation fault if table is reallocated */\n\tmemcpy(&(*table)->ruleArea[(*table)->hyphenStatesArray], &dict.states[0],\n\t\t\tdict.numStates * sizeof(HyphenationState));\n\tfree(dict.states);\n\treturn 1;\n}\n\nstatic int\ncompileCharDef(FileInfo *file, TranslationTableOpcode opcode,\n\t\tTranslationTableCharacterAttributes attributes, int noback, int nofor,\n\t\tTranslationTableHeader **table, DisplayTableHeader **displayTable) {\n\tCharsString ruleChars;\n\tCharsString ruleDots;\n\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\tif (!getRuleDotsPattern(file, &ruleDots)) return 0;\n\tif (ruleChars.length != 1) {\n\t\tcompileError(file, \"Exactly one character is required.\");\n\t\treturn 0;\n\t}\n\tif (ruleDots.length < 1) {\n\t\tcompileError(file, \"At least one cell is required.\");\n\t\treturn 0;\n\t}\n\tif (table) {\n\t\tTranslationTableCharacter *character;\n\t\tTranslationTableCharacter *cell = NULL;\n\t\tint k;\n\t\tif (attributes & (CTC_UpperCase | CTC_LowerCase)) attributes |= CTC_Letter;\n\t\tcharacter = putChar(file, ruleChars.chars[0], table, NULL);\n\t\tcharacter->attributes |= attributes;\n\t\tfor (k = ruleDots.length - 1; k >= 0; k -= 1) {\n\t\t\tcell = getDots(ruleDots.chars[k], *table);\n\t\t\tif (!cell) cell = putDots(file, ruleDots.chars[k], table);\n\t\t}\n\t\tif (ruleDots.length == 1) cell->attributes |= attributes;\n\t}\n\tif (displayTable && ruleDots.length == 1)\n\t\tputCharDotsMapping(file, ruleChars.chars[0], ruleDots.chars[0], displayTable);\n\tif (table)\n\t\tif (!addRule(file, opcode, &ruleChars, &ruleDots, 0, 0, NULL, NULL, noback, nofor,\n\t\t\t\t\ttable))\n\t\t\treturn 0;\n\treturn 1;\n}\n\nstatic int\ncompileBeforeAfter(FileInfo *file) {\n\t/* 1=before, 2=after, 0=error */\n\tCharsString token;\n\tCharsString tmp;\n\tif (!getToken(file, &token, \"last word before or after\")) return 0;\n\tif (!parseChars(file, &tmp, &token)) return 0;\n\tif (eqasc2uni((unsigned char *)\"before\", tmp.chars, 6))\n\t\treturn 1;\n\telse if (eqasc2uni((unsigned char *)\"after\", tmp.chars, 5))\n\t\treturn 2;\n\treturn 0;\n}\n\n/**\n * Macro\n */\ntypedef struct {\n\tconst char *name;\n\tconst widechar *definition;\t // fixed part\n\tint definition_length;\n\tconst int *substitutions;  // variable part: position and argument index of each\n\t\t\t\t\t\t\t   // variable substitution\n\tint substitution_count;\n\tint argument_count;\t // number of expected arguments\n} Macro;\n\n/**\n * List of in-scope macros\n */\ntypedef struct MacroList {\n\tconst Macro *head;\n\tconst struct MacroList *tail;\n} MacroList;\n\n/**\n * Create new macro.\n */\nstatic const Macro *\ncreate_macro(const char *name, const widechar *definition, int definition_length,\n\t\tconst int *substitutions, int substitution_count, int argument_count) {\n\tMacro *m = malloc(sizeof(Macro));\n\tm->name = strdup(name);\n\twidechar *definition_copy = malloc(definition_length * sizeof(widechar));\n\tmemcpy(definition_copy, definition, definition_length * sizeof(widechar));\n\tm->definition = definition_copy;\n\tm->definition_length = definition_length;\n\tint *substitutions_copy = malloc(2 * substitution_count * sizeof(int));\n\tmemcpy(substitutions_copy, substitutions, 2 * substitution_count * sizeof(int));\n\tm->substitutions = substitutions_copy;\n\tm->substitution_count = substitution_count;\n\tm->argument_count = argument_count;\n\treturn m;\n}\n\n/**\n * Create new macro list from \"head\" macro and \"tail\" list.\n */\nstatic const MacroList *\ncons_macro(const Macro *head, const MacroList *tail) {\n\tMacroList *list = malloc(sizeof(MacroList));\n\tlist->head = head;\n\tlist->tail = tail;\n\treturn list;\n}\n\n/**\n * Free macro returned by create_macro.\n */\nstatic void\nfree_macro(const Macro *macro) {\n\tif (macro) {\n\t\tfree((char *)macro->name);\n\t\tfree((char *)macro->definition);\n\t\tfree((int *)macro->substitutions);\n\t\tfree((Macro *)macro);\n\t}\n}\n\n/**\n * Free macro list returned by cons_macro.\n */\nstatic void\nfree_macro_list(const MacroList *list) {\n\tif (list) {\n\t\tfree_macro((Macro *)list->head);\n\t\tfree_macro_list((MacroList *)list->tail);\n\t\tfree((MacroList *)list);\n\t}\n}\n\n/**\n * Compile macro\n */\nstatic int\ncompileMacro(FileInfo *file, const Macro **macro) {\n\n\t// parse name\n\tCharsString token;\n\tif (!getToken(file, &token, \"macro name\")) return 0;\n\tswitch (getOpcode(file, &token)) {\n\tcase CTO_UpLow:\t // deprecated so \"uplow\" may be used as macro name\n\tcase CTO_None:\n\t\tbreak;\n\tdefault:\n\t\tcompileError(file, \"Invalid macro name: already taken by an opcode\");\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i < token.length; i++) {\n\t\tif (!((token.chars[i] >= 'a' && token.chars[i] <= 'z') ||\n\t\t\t\t\t(token.chars[i] >= 'A' && token.chars[i] <= 'Z') ||\n\t\t\t\t\t(token.chars[i] >= '0' && token.chars[i] <= '9'))) {\n\t\t\tcompileError(file,\n\t\t\t\t\t\"Invalid macro name: must be a word containing only letters and \"\n\t\t\t\t\t\"digits\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tstatic char name[MAXSTRING + 1];\n\tint name_length;\n\tfor (name_length = 0; name_length < token.length;\n\t\t\tname_length++)\t// we know token can not be longer than MAXSTRING\n\t\tname[name_length] = (char)token.chars[name_length];\n\tname[name_length] = '\\0';\n\n\t// parse body\n\tstatic widechar definition[MAXSTRING];\n\tstatic int substitutions[2 * MAX_MACRO_VAR];\n\tint definition_length = 0;\n\tint substitution_count = 0;\n\tint argument_count = 0;\n\tint dollar = 0;\n\n\t// ignore rest of line after name and read lines until \"eom\" is encountered\n\twhile (_lou_getALine(file)) {\n\t\tif (file->linelen >= 3 && file->line[0] == 'e' && file->line[1] == 'o' &&\n\t\t\t\tfile->line[2] == 'm') {\n\t\t\t*macro = create_macro(name, definition, definition_length, substitutions,\n\t\t\t\t\tsubstitution_count, argument_count);\n\t\t\treturn 1;\n\t\t}\n\t\twhile (!atEndOfLine(file)) {\n\t\t\twidechar c = file->line[file->linepos++];\n\t\t\tif (dollar) {\n\t\t\t\tdollar = 0;\n\t\t\t\tif (c >= '0' && c <= '9') {\n\t\t\t\t\tif (substitution_count >= MAX_MACRO_VAR) {\n\t\t\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\t\t\"Macro can not have more than %d variable substitutions\",\n\t\t\t\t\t\t\t\tMAXSTRING);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tsubstitutions[2 * substitution_count] = definition_length;\n\t\t\t\t\tint arg = c - '0';\n\t\t\t\t\tsubstitutions[2 * substitution_count + 1] = arg;\n\t\t\t\t\tif (arg > argument_count) argument_count = arg;\n\t\t\t\t\tsubstitution_count++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else if (c == '$') {\n\t\t\t\tdollar = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (definition_length >= MAXSTRING) {\n\t\t\t\tcompileError(file, \"Macro exceeds %d characters\", MAXSTRING);\n\t\t\t\treturn 0;\n\t\t\t} else\n\t\t\t\tdefinition[definition_length++] = c;\n\t\t}\n\t\tdollar = 0;\n\t\tif (definition_length >= MAXSTRING) {\n\t\t\tcompileError(file, \"Macro exceeds %d characters\", MAXSTRING);\n\t\t\treturn 0;\n\t\t}\n\t\tdefinition[definition_length++] = '\\n';\n\t}\n\tcompileError(file, \"macro must be terminated with 'eom'\");\n\treturn 0;\n}\n\nstatic int\ncompileRule(FileInfo *file, TranslationTableHeader **table,\n\t\tDisplayTableHeader **displayTable, const MacroList **inScopeMacros) {\n\tCharsString token;\n\tTranslationTableOpcode opcode;\n\tCharsString ruleChars;\n\tCharsString ruleDots;\n\tCharsString cells;\n\tCharsString scratchPad;\n\tCharsString emphClass;\n\tTranslationTableCharacterAttributes after = 0;\n\tTranslationTableCharacterAttributes before = 0;\n\tint noback, nofor, nocross;\n\tnoback = nofor = nocross = 0;\ndoOpcode:\n\tif (!getToken(file, &token, NULL)) return 1;\t\t\t\t  /* blank line */\n\tif (token.chars[0] == '#' || token.chars[0] == '<') return 1; /* comment */\n\tif (file->lineNumber == 1 &&\n\t\t\t(eqasc2uni((unsigned char *)\"ISO\", token.chars, 3) ||\n\t\t\t\t\teqasc2uni((unsigned char *)\"UTF-8\", token.chars, 5))) {\n\t\tif (table)\n\t\t\tcompileHyphenation(file, &token, table);\n\t\telse\n\t\t\t/* ignore the whole file */\n\t\t\twhile (_lou_getALine(file))\n\t\t\t\t;\n\t\treturn 1;\n\t}\n\topcode = getOpcode(file, &token);\n\tswitch (opcode) {\n\tcase CTO_Macro: {\n\t\tconst Macro *macro;\n#ifdef ENABLE_MACROS\n\t\tif (!inScopeMacros) {\n\t\t\tcompileError(file, \"Defining macros only allowed in table files.\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (compileMacro(file, &macro)) {\n\t\t\t*inScopeMacros = cons_macro(macro, *inScopeMacros);\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n#else\n\t\tcompileError(file, \"Macro feature is disabled.\");\n\t\treturn 0;\n#endif\n\t}\n\tcase CTO_IncludeFile: {\n\t\tCharsString includedFile;\n\t\tif (!getToken(file, &token, \"include file name\")) return 0;\n\t\tif (!parseChars(file, &includedFile, &token)) return 0;\n\t\treturn includeFile(file, &includedFile, table, displayTable);\n\t}\n\tcase CTO_NoBack:\n\t\tif (nofor) {\n\t\t\tcompileError(file, \"%s already specified.\", _lou_findOpcodeName(CTO_NoFor));\n\t\t\treturn 0;\n\t\t}\n\t\tnoback = 1;\n\t\tgoto doOpcode;\n\tcase CTO_NoFor:\n\t\tif (noback) {\n\t\t\tcompileError(file, \"%s already specified.\", _lou_findOpcodeName(CTO_NoBack));\n\t\t\treturn 0;\n\t\t}\n\t\tnofor = 1;\n\t\tgoto doOpcode;\n\tcase CTO_Space:\n\t\treturn compileCharDef(\n\t\t\t\tfile, opcode, CTC_Space, noback, nofor, table, displayTable);\n\tcase CTO_Digit:\n\t\treturn compileCharDef(\n\t\t\t\tfile, opcode, CTC_Digit, noback, nofor, table, displayTable);\n\tcase CTO_LitDigit:\n\t\treturn compileCharDef(\n\t\t\t\tfile, opcode, CTC_LitDigit, noback, nofor, table, displayTable);\n\tcase CTO_Punctuation:\n\t\treturn compileCharDef(\n\t\t\t\tfile, opcode, CTC_Punctuation, noback, nofor, table, displayTable);\n\tcase CTO_Math:\n\t\treturn compileCharDef(file, opcode, CTC_Math, noback, nofor, table, displayTable);\n\tcase CTO_Sign:\n\t\treturn compileCharDef(file, opcode, CTC_Sign, noback, nofor, table, displayTable);\n\tcase CTO_Letter:\n\t\treturn compileCharDef(\n\t\t\t\tfile, opcode, CTC_Letter, noback, nofor, table, displayTable);\n\tcase CTO_UpperCase:\n\t\treturn compileCharDef(\n\t\t\t\tfile, opcode, CTC_UpperCase, noback, nofor, table, displayTable);\n\tcase CTO_LowerCase:\n\t\treturn compileCharDef(\n\t\t\t\tfile, opcode, CTC_LowerCase, noback, nofor, table, displayTable);\n\tcase CTO_Grouping:\n\t\treturn compileGrouping(file, noback, nofor, table, displayTable);\n\tcase CTO_Display:\n\t\tif (!displayTable) return 1;  // ignore\n\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\tif (!getRuleDotsPattern(file, &ruleDots)) return 0;\n\t\tif (ruleChars.length != 1 || ruleDots.length != 1) {\n\t\t\tcompileError(file, \"Exactly one character and one cell are required.\");\n\t\t\treturn 0;\n\t\t}\n\t\treturn putCharDotsMapping(\n\t\t\t\tfile, ruleChars.chars[0], ruleDots.chars[0], displayTable);\n\tcase CTO_UpLow:\n\tcase CTO_None: {\n\t\t// check if token is a macro name\n\t\tif (inScopeMacros) {\n\t\t\tconst MacroList *macros = *inScopeMacros;\n\t\t\twhile (macros) {\n\t\t\t\tconst Macro *m = macros->head;\n\t\t\t\tif (token.length == strlen(m->name) &&\n\t\t\t\t\t\teqasc2uni((unsigned char *)m->name, token.chars, token.length)) {\n\t\t\t\t\tif (!inScopeMacros) {\n\t\t\t\t\t\tcompileError(file, \"Calling macros only allowed in table files.\");\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tFileInfo tmpFile;\n\t\t\t\t\tmemset(&tmpFile, 0, sizeof(tmpFile));\n\t\t\t\t\ttmpFile.fileName = file->fileName;\n\t\t\t\t\ttmpFile.sourceFile = file->sourceFile;\n\t\t\t\t\ttmpFile.lineNumber = file->lineNumber;\n\t\t\t\t\ttmpFile.encoding = noEncoding;\n\t\t\t\t\ttmpFile.status = 0;\n\t\t\t\t\ttmpFile.linepos = 0;\n\t\t\t\t\ttmpFile.linelen = 0;\n\t\t\t\t\tint argument_count = 0;\n\t\t\t\t\tCharsString *arguments =\n\t\t\t\t\t\t\tmalloc(m->argument_count * sizeof(CharsString));\n\t\t\t\t\twhile (argument_count < m->argument_count) {\n\t\t\t\t\t\tif (getToken(file, &token, \"macro argument\"))\n\t\t\t\t\t\t\targuments[argument_count++] = token;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (argument_count < m->argument_count) {\n\t\t\t\t\t\tcompileError(file, \"Expected %d arguments\", m->argument_count);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tint i = 0;\n\t\t\t\t\tint subst = 0;\n\t\t\t\t\tint next = subst < m->substitution_count ? m->substitutions[2 * subst]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t : m->definition_length;\n\t\t\t\t\tfor (;;) {\n\t\t\t\t\t\twhile (i < next) {\n\t\t\t\t\t\t\twidechar c = m->definition[i++];\n\t\t\t\t\t\t\tif (c == '\\n') {\n\t\t\t\t\t\t\t\tif (!compileRule(&tmpFile, table, displayTable,\n\t\t\t\t\t\t\t\t\t\t\tinScopeMacros)) {\n\t\t\t\t\t\t\t\t\t_lou_logMessage(LOU_LOG_ERROR,\n\t\t\t\t\t\t\t\t\t\t\t\"result of macro expansion was: %s\",\n\t\t\t\t\t\t\t\t\t\t\t_lou_showString(\n\t\t\t\t\t\t\t\t\t\t\t\t\ttmpFile.line, tmpFile.linelen, 0));\n\t\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ttmpFile.linepos = 0;\n\t\t\t\t\t\t\t\ttmpFile.linelen = 0;\n\t\t\t\t\t\t\t} else if (tmpFile.linelen >= MAXSTRING) {\n\t\t\t\t\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\t\t\t\t\"Line exceeds %d characters (post macro \"\n\t\t\t\t\t\t\t\t\t\t\"expansion)\",\n\t\t\t\t\t\t\t\t\t\tMAXSTRING);\n\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\ttmpFile.line[tmpFile.linelen++] = c;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (subst < m->substitution_count) {\n\t\t\t\t\t\t\tCharsString arg =\n\t\t\t\t\t\t\t\t\targuments[m->substitutions[2 * subst + 1] - 1];\n\t\t\t\t\t\t\tfor (int j = 0; j < arg.length; j++)\n\t\t\t\t\t\t\t\ttmpFile.line[tmpFile.linelen++] = arg.chars[j];\n\t\t\t\t\t\t\tsubst++;\n\t\t\t\t\t\t\tnext = subst < m->substitution_count\n\t\t\t\t\t\t\t\t\t? m->substitutions[2 * subst]\n\t\t\t\t\t\t\t\t\t: m->definition_length;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (!compileRule(\n\t\t\t\t\t\t\t\t\t\t&tmpFile, table, displayTable, inScopeMacros)) {\n\t\t\t\t\t\t\t\t_lou_logMessage(LOU_LOG_ERROR,\n\t\t\t\t\t\t\t\t\t\t\"result of macro expansion was: %s\",\n\t\t\t\t\t\t\t\t\t\t_lou_showString(\n\t\t\t\t\t\t\t\t\t\t\t\ttmpFile.line, tmpFile.linelen, 0));\n\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tmacros = macros->tail;\n\t\t\t}\n\t\t}\n\t\tif (opcode == CTO_UpLow) {\n\t\t\tcompileError(file, \"The uplow opcode is deprecated.\");\n\t\t\treturn 0;\n\t\t}\n\t\tcompileError(file, \"opcode %s not defined.\",\n\t\t\t\t_lou_showString(token.chars, token.length, 0));\n\t\treturn 0;\n\t}\n\n\t/* now only opcodes follow that don't modify the display table */\n\tdefault:\n\t\tif (!table) return 1;\n\t\tswitch (opcode) {\n\t\tcase CTO_Locale:\n\t\t\tcompileWarning(file,\n\t\t\t\t\t\"The locale opcode is not implemented. Use the locale meta data \"\n\t\t\t\t\t\"instead.\");\n\t\t\treturn 1;\n\t\tcase CTO_Undefined: {\n\t\t\t// not passing pointer because compileBrailleIndicator may reallocate table\n\t\t\tTranslationTableOffset ruleOffset = (*table)->undefined;\n\t\t\tif (!compileBrailleIndicator(file, \"undefined character opcode\",\n\t\t\t\t\t\tCTO_Undefined, &ruleOffset, noback, nofor, table))\n\t\t\t\treturn 0;\n\t\t\t(*table)->undefined = ruleOffset;\n\t\t\treturn 1;\n\t\t}\n\t\tcase CTO_Match: {\n\t\t\tint ok = 0;\n\t\t\twidechar *patterns = NULL;\n\t\t\tTranslationTableRule *rule;\n\t\t\tTranslationTableOffset ruleOffset;\n\t\t\tCharsString ptn_before, ptn_after;\n\t\t\tTranslationTableOffset patternsOffset;\n\t\t\tint len, mrk;\n\t\t\tsize_t patternsByteSize = sizeof(*patterns) * 27720;\n\t\t\tpatterns = (widechar *)malloc(patternsByteSize);\n\t\t\tif (!patterns) _lou_outOfMemory();\n\t\t\tmemset(patterns, 0xffff, patternsByteSize);\n\t\t\tnoback = 1;\n\t\t\tgetCharacters(file, &ptn_before);\n\t\t\tgetRuleCharsText(file, &ruleChars);\n\t\t\tgetCharacters(file, &ptn_after);\n\t\t\tgetRuleDotsPattern(file, &ruleDots);\n\t\t\tif (!addRule(file, opcode, &ruleChars, &ruleDots, after, before, &ruleOffset,\n\t\t\t\t\t\t&rule, noback, nofor, table))\n\t\t\t\tgoto CTO_Match_cleanup;\n\t\t\tif (ptn_before.chars[0] == '-' && ptn_before.length == 1)\n\t\t\t\tlen = _lou_pattern_compile(\n\t\t\t\t\t\t&ptn_before.chars[0], 0, &patterns[1], 13841, *table, file);\n\t\t\telse\n\t\t\t\tlen = _lou_pattern_compile(&ptn_before.chars[0], ptn_before.length,\n\t\t\t\t\t\t&patterns[1], 13841, *table, file);\n\t\t\tif (!len) goto CTO_Match_cleanup;\n\t\t\tmrk = patterns[0] = len + 1;\n\t\t\t_lou_pattern_reverse(&patterns[1]);\n\t\t\tif (ptn_after.chars[0] == '-' && ptn_after.length == 1)\n\t\t\t\tlen = _lou_pattern_compile(\n\t\t\t\t\t\t&ptn_after.chars[0], 0, &patterns[mrk], 13841, *table, file);\n\t\t\telse\n\t\t\t\tlen = _lou_pattern_compile(&ptn_after.chars[0], ptn_after.length,\n\t\t\t\t\t\t&patterns[mrk], 13841, *table, file);\n\t\t\tif (!len) goto CTO_Match_cleanup;\n\t\t\tlen += mrk;\n\t\t\tif (!allocateSpaceInTranslationTable(\n\t\t\t\t\t\tfile, &patternsOffset, len * sizeof(widechar), table))\n\t\t\t\tgoto CTO_Match_cleanup;\n\t\t\t// allocateSpaceInTranslationTable may have moved table, so make sure rule is\n\t\t\t// still valid\n\t\t\trule = (TranslationTableRule *)&(*table)->ruleArea[ruleOffset];\n\t\t\tmemcpy(&(*table)->ruleArea[patternsOffset], patterns, len * sizeof(widechar));\n\t\t\trule->patterns = patternsOffset;\n\t\t\tok = 1;\n\t\tCTO_Match_cleanup:\n\t\t\tfree(patterns);\n\t\t\treturn ok;\n\t\t}\n\n\t\tcase CTO_BackMatch: {\n\t\t\tint ok = 0;\n\t\t\twidechar *patterns = NULL;\n\t\t\tTranslationTableRule *rule;\n\t\t\tTranslationTableOffset ruleOffset;\n\t\t\tCharsString ptn_before, ptn_after;\n\t\t\tTranslationTableOffset patternOffset;\n\t\t\tint len, mrk;\n\t\t\tsize_t patternsByteSize = sizeof(*patterns) * 27720;\n\t\t\tpatterns = (widechar *)malloc(patternsByteSize);\n\t\t\tif (!patterns) _lou_outOfMemory();\n\t\t\tmemset(patterns, 0xffff, patternsByteSize);\n\t\t\tnofor = 1;\n\t\t\tgetCharacters(file, &ptn_before);\n\t\t\tgetRuleCharsText(file, &ruleChars);\n\t\t\tgetCharacters(file, &ptn_after);\n\t\t\tgetRuleDotsPattern(file, &ruleDots);\n\t\t\tif (!addRule(file, opcode, &ruleChars, &ruleDots, 0, 0, &ruleOffset, &rule,\n\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\tgoto CTO_BackMatch_cleanup;\n\t\t\tif (ptn_before.chars[0] == '-' && ptn_before.length == 1)\n\t\t\t\tlen = _lou_pattern_compile(\n\t\t\t\t\t\t&ptn_before.chars[0], 0, &patterns[1], 13841, *table, file);\n\t\t\telse\n\t\t\t\tlen = _lou_pattern_compile(&ptn_before.chars[0], ptn_before.length,\n\t\t\t\t\t\t&patterns[1], 13841, *table, file);\n\t\t\tif (!len) goto CTO_BackMatch_cleanup;\n\t\t\tmrk = patterns[0] = len + 1;\n\t\t\t_lou_pattern_reverse(&patterns[1]);\n\t\t\tif (ptn_after.chars[0] == '-' && ptn_after.length == 1)\n\t\t\t\tlen = _lou_pattern_compile(\n\t\t\t\t\t\t&ptn_after.chars[0], 0, &patterns[mrk], 13841, *table, file);\n\t\t\telse\n\t\t\t\tlen = _lou_pattern_compile(&ptn_after.chars[0], ptn_after.length,\n\t\t\t\t\t\t&patterns[mrk], 13841, *table, file);\n\t\t\tif (!len) goto CTO_BackMatch_cleanup;\n\t\t\tlen += mrk;\n\t\t\tif (!allocateSpaceInTranslationTable(\n\t\t\t\t\t\tfile, &patternOffset, len * sizeof(widechar), table))\n\t\t\t\tgoto CTO_BackMatch_cleanup;\n\t\t\t// allocateSpaceInTranslationTable may have moved table, so make sure rule is\n\t\t\t// still valid\n\t\t\trule = (TranslationTableRule *)&(*table)->ruleArea[ruleOffset];\n\t\t\tmemcpy(&(*table)->ruleArea[patternOffset], patterns, len * sizeof(widechar));\n\t\t\trule->patterns = patternOffset;\n\t\t\tok = 1;\n\t\tCTO_BackMatch_cleanup:\n\t\t\tfree(patterns);\n\t\t\treturn ok;\n\t\t}\n\n\t\tcase CTO_CapsLetter:\n\t\tcase CTO_BegCapsWord:\n\t\tcase CTO_EndCapsWord:\n\t\tcase CTO_BegCaps:\n\t\tcase CTO_EndCaps:\n\t\tcase CTO_BegCapsPhrase:\n\t\tcase CTO_EndCapsPhrase:\n\t\tcase CTO_LenCapsPhrase:\n\t\t/* these 8 general purpose opcodes are compiled further down to more specific\n\t\t * internal opcodes:\n\t\t * - modeletter\n\t\t * - begmodeword\n\t\t * - endmodeword\n\t\t * - begmode\n\t\t * - endmode\n\t\t * - begmodephrase\n\t\t * - endmodephrase\n\t\t * - lenmodephrase\n\t\t */\n\t\tcase CTO_ModeLetter:\n\t\tcase CTO_BegModeWord:\n\t\tcase CTO_EndModeWord:\n\t\tcase CTO_BegMode:\n\t\tcase CTO_EndMode:\n\t\tcase CTO_BegModePhrase:\n\t\tcase CTO_EndModePhrase:\n\t\tcase CTO_LenModePhrase: {\n\t\t\tTranslationTableCharacterAttributes mode;\n\t\t\tint i;\n\t\t\tswitch (opcode) {\n\t\t\tcase CTO_CapsLetter:\n\t\t\tcase CTO_BegCapsWord:\n\t\t\tcase CTO_EndCapsWord:\n\t\t\tcase CTO_BegCaps:\n\t\t\tcase CTO_EndCaps:\n\t\t\tcase CTO_BegCapsPhrase:\n\t\t\tcase CTO_EndCapsPhrase:\n\t\t\tcase CTO_LenCapsPhrase:\n\t\t\t\tmode = CTC_UpperCase;\n\t\t\t\ti = 0;\n\t\t\t\topcode += (CTO_ModeLetter - CTO_CapsLetter);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (!getToken(file, &token, \"attribute name\")) return 0;\n\t\t\t\tif (!(*table)->characterClasses && !allocateCharacterClasses(*table)) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tconst CharacterClass *characterClass = findCharacterClass(&token, *table);\n\t\t\t\tif (!characterClass) {\n\t\t\t\t\tcharacterClass =\n\t\t\t\t\t\t\taddCharacterClass(file, token.chars, token.length, *table, 1);\n\t\t\t\t\tif (!characterClass) return 0;\n\t\t\t\t}\n\t\t\t\tmode = characterClass->attribute;\n\t\t\t\tif (!(mode == CTC_UpperCase || mode == CTC_Digit) && mode >= CTC_Space &&\n\t\t\t\t\t\tmode <= CTC_LitDigit) {\n\t\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\t\"mode must be \\\"uppercase\\\", \\\"digit\\\", or a custom \"\n\t\t\t\t\t\t\t\"attribute name.\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\t/* check if this mode is already defined and if the number of modes does\n\t\t\t\t * not exceed the maximal number */\n\t\t\t\tif (mode == CTC_UpperCase)\n\t\t\t\t\ti = 0;\n\t\t\t\telse {\n\t\t\t\t\tfor (i = 1; i < MAX_MODES && (*table)->modes[i].value; i++) {\n\t\t\t\t\t\tif ((*table)->modes[i].mode == mode) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (i == MAX_MODES) {\n\t\t\t\t\t\tcompileError(file, \"Max number of modes (%i) reached\", MAX_MODES);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!(*table)->modes[i].value)\n\t\t\t\t(*table)->modes[i] = (EmphasisClass){ plain_text, mode,\n\t\t\t\t\t0x1 << (MAX_EMPH_CLASSES + i), MAX_EMPH_CLASSES + i };\n\t\t\tswitch (opcode) {\n\t\t\tcase CTO_BegModePhrase: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset =\n\t\t\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][begPhraseOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"first word capital sign\",\n\t\t\t\t\t\t\tCTO_BegCapsPhraseRule + (8 * i), &ruleOffset, noback, nofor,\n\t\t\t\t\t\t\ttable))\n\t\t\t\t\treturn 0;\n\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][begPhraseOffset] = ruleOffset;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tcase CTO_EndModePhrase: {\n\t\t\t\tTranslationTableOffset ruleOffset;\n\t\t\t\tswitch (compileBeforeAfter(file)) {\n\t\t\t\tcase 1:\t // before\n\t\t\t\t\tif ((*table)->emphRules[MAX_EMPH_CLASSES + i][endPhraseAfterOffset]) {\n\t\t\t\t\t\tcompileError(\n\t\t\t\t\t\t\t\tfile, \"Capital sign after last word already defined.\");\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t\t// table\n\t\t\t\t\truleOffset = (*table)->emphRules[MAX_EMPH_CLASSES + i]\n\t\t\t\t\t\t\t\t\t\t\t\t\t[endPhraseBeforeOffset];\n\t\t\t\t\tif (!compileBrailleIndicator(file, \"capital sign before last word\",\n\t\t\t\t\t\t\t\tCTO_EndCapsPhraseBeforeRule + (8 * i), &ruleOffset,\n\t\t\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][endPhraseBeforeOffset] =\n\t\t\t\t\t\t\truleOffset;\n\t\t\t\t\treturn 1;\n\t\t\t\tcase 2:\t // after\n\t\t\t\t\tif ((*table)->emphRules[MAX_EMPH_CLASSES + i]\n\t\t\t\t\t\t\t\t\t\t   [endPhraseBeforeOffset]) {\n\t\t\t\t\t\tcompileError(\n\t\t\t\t\t\t\t\tfile, \"Capital sign before last word already defined.\");\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t\t// table\n\t\t\t\t\truleOffset = (*table)->emphRules[MAX_EMPH_CLASSES + i]\n\t\t\t\t\t\t\t\t\t\t\t\t\t[endPhraseAfterOffset];\n\t\t\t\t\tif (!compileBrailleIndicator(file, \"capital sign after last word\",\n\t\t\t\t\t\t\t\tCTO_EndCapsPhraseAfterRule + (8 * i), &ruleOffset, noback,\n\t\t\t\t\t\t\t\tnofor, table))\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][endPhraseAfterOffset] =\n\t\t\t\t\t\t\truleOffset;\n\t\t\t\t\treturn 1;\n\t\t\t\tdefault:  // error\n\t\t\t\t\tcompileError(file, \"Invalid lastword indicator location.\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcase CTO_BegMode: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset =\n\t\t\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][begOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"first letter capital sign\",\n\t\t\t\t\t\t\tCTO_BegCapsRule + (8 * i), &ruleOffset, noback, nofor, table))\n\t\t\t\t\treturn 0;\n\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][begOffset] = ruleOffset;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tcase CTO_EndMode: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset =\n\t\t\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][endOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"last letter capital sign\",\n\t\t\t\t\t\t\tCTO_EndCapsRule + (8 * i), &ruleOffset, noback, nofor, table))\n\t\t\t\t\treturn 0;\n\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][endOffset] = ruleOffset;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tcase CTO_ModeLetter: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset =\n\t\t\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][letterOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"single letter capital sign\",\n\t\t\t\t\t\t\tCTO_CapsLetterRule + (8 * i), &ruleOffset, noback, nofor,\n\t\t\t\t\t\t\ttable))\n\t\t\t\t\treturn 0;\n\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][letterOffset] = ruleOffset;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tcase CTO_BegModeWord: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset =\n\t\t\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][begWordOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"capital word\",\n\t\t\t\t\t\t\tCTO_BegCapsWordRule + (8 * i), &ruleOffset, noback, nofor,\n\t\t\t\t\t\t\ttable))\n\t\t\t\t\treturn 0;\n\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][begWordOffset] = ruleOffset;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tcase CTO_EndModeWord: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset =\n\t\t\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][endWordOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"capital word stop\",\n\t\t\t\t\t\t\tCTO_EndCapsWordRule + (8 * i), &ruleOffset, noback, nofor,\n\t\t\t\t\t\t\ttable))\n\t\t\t\t\treturn 0;\n\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][endWordOffset] = ruleOffset;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tcase CTO_LenModePhrase:\n\t\t\t\treturn (*table)->emphRules[MAX_EMPH_CLASSES + i][lenPhraseOffset] =\n\t\t\t\t\t\t\t   compileNumber(file);\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t/* these 8 general purpose emphasis opcodes are compiled further down to more\n\t\t * specific internal opcodes:\n\t\t * - emphletter\n\t\t * - begemphword\n\t\t * - endemphword\n\t\t * - begemph\n\t\t * - endemph\n\t\t * - begemphphrase\n\t\t * - endemphphrase\n\t\t * - lenemphphrase\n\t\t */\n\t\tcase CTO_EmphClass:\n\t\t\tif (!getToken(file, &emphClass, \"emphasis class\")) {\n\t\t\t\tcompileError(file, \"emphclass must be followed by a valid class name.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tint k, i;\n\t\t\tchar *s = malloc(sizeof(char) * (emphClass.length + 1));\n\t\t\tfor (k = 0; k < emphClass.length; k++) s[k] = (char)emphClass.chars[k];\n\t\t\ts[k++] = '\\0';\n\t\t\tfor (i = 0; i < MAX_EMPH_CLASSES && (*table)->emphClassNames[i]; i++)\n\t\t\t\tif (strcmp(s, (*table)->emphClassNames[i]) == 0) {\n\t\t\t\t\t_lou_logMessage(LOU_LOG_WARN, \"Duplicate emphasis class: %s\", s);\n\t\t\t\t\twarningCount++;\n\t\t\t\t\tfree(s);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\tif (i == MAX_EMPH_CLASSES) {\n\t\t\t\t_lou_logMessage(LOU_LOG_ERROR,\n\t\t\t\t\t\t\"Max number of emphasis classes (%i) reached\", MAX_EMPH_CLASSES);\n\t\t\t\terrorCount++;\n\t\t\t\tfree(s);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tswitch (i) {\n\t\t\t/* For backwards compatibility (i.e. because programs will assume\n\t\t\t * the first 3 typeform bits are `italic', `underline' and `bold')\n\t\t\t * we require that the first 3 emphclass definitions are (in that\n\t\t\t * order):\n\t\t\t *\n\t\t\t *   emphclass italic\n\t\t\t *   emphclass underline\n\t\t\t *   emphclass bold\n\t\t\t *\n\t\t\t * While it would be possible to use the emphclass opcode only for\n\t\t\t * defining _additional_ classes (not allowing for them to be called\n\t\t\t * italic, underline or bold), thereby reducing the amount of\n\t\t\t * boilerplate, we deliberately choose not to do that in order to\n\t\t\t * not give italic, underline and bold any special status. The\n\t\t\t * hope is that eventually all programs will use liblouis for\n\t\t\t * emphasis the recommended way (i.e. by looking up the supported\n\t\t\t * typeforms in the documentation or API) so that we can drop this\n\t\t\t * restriction.\n\t\t\t */\n\t\t\tcase 0:\n\t\t\t\tif (strcmp(s, \"italic\") != 0) {\n\t\t\t\t\t_lou_logMessage(LOU_LOG_ERROR,\n\t\t\t\t\t\t\t\"First emphasis class must be \\\"italic\\\" but got \"\n\t\t\t\t\t\t\t\"%s\",\n\t\t\t\t\t\t\ts);\n\t\t\t\t\terrorCount++;\n\t\t\t\t\tfree(s);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tif (strcmp(s, \"underline\") != 0) {\n\t\t\t\t\t_lou_logMessage(LOU_LOG_ERROR,\n\t\t\t\t\t\t\t\"Second emphasis class must be \\\"underline\\\" but \"\n\t\t\t\t\t\t\t\"got \"\n\t\t\t\t\t\t\t\"%s\",\n\t\t\t\t\t\t\ts);\n\t\t\t\t\terrorCount++;\n\t\t\t\t\tfree(s);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tif (strcmp(s, \"bold\") != 0) {\n\t\t\t\t\t_lou_logMessage(LOU_LOG_ERROR,\n\t\t\t\t\t\t\t\"Third emphasis class must be \\\"bold\\\" but got \"\n\t\t\t\t\t\t\t\"%s\",\n\t\t\t\t\t\t\ts);\n\t\t\t\t\terrorCount++;\n\t\t\t\t\tfree(s);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t(*table)->emphClassNames[i] = s;\n\t\t\t(*table)->emphClasses[i] = (EmphasisClass){ emph_1\n\t\t\t\t\t\t<< i, /* relies on the order of typeforms emph_1..emph_10 */\n\t\t\t\t0, 0x1 << i, i };\n\t\t\treturn 1;\n\t\tcase CTO_EmphLetter:\n\t\tcase CTO_BegEmphWord:\n\t\tcase CTO_EndEmphWord:\n\t\tcase CTO_BegEmph:\n\t\tcase CTO_EndEmph:\n\t\tcase CTO_BegEmphPhrase:\n\t\tcase CTO_EndEmphPhrase:\n\t\tcase CTO_LenEmphPhrase:\n\t\tcase CTO_EmphModeChars:\n\t\tcase CTO_NoEmphChars: {\n\t\t\tif (!getToken(file, &token, \"emphasis class\")) return 0;\n\t\t\tif (!parseChars(file, &emphClass, &token)) return 0;\n\t\t\tchar *s = malloc(sizeof(char) * (emphClass.length + 1));\n\t\t\tint k, i;\n\t\t\tfor (k = 0; k < emphClass.length; k++) s[k] = (char)emphClass.chars[k];\n\t\t\ts[k++] = '\\0';\n\t\t\tfor (i = 0; i < MAX_EMPH_CLASSES && (*table)->emphClassNames[i]; i++)\n\t\t\t\tif (strcmp(s, (*table)->emphClassNames[i]) == 0) break;\n\t\t\tif (i == MAX_EMPH_CLASSES || !(*table)->emphClassNames[i]) {\n\t\t\t\t_lou_logMessage(LOU_LOG_ERROR, \"Emphasis class %s not declared\", s);\n\t\t\t\terrorCount++;\n\t\t\t\tfree(s);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tint ok = 0;\n\t\t\tswitch (opcode) {\n\t\t\tcase CTO_EmphLetter: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset = (*table)->emphRules[i][letterOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"single letter\",\n\t\t\t\t\t\t\tCTO_Emph1LetterRule + letterOffset + (8 * i), &ruleOffset,\n\t\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\t\tbreak;\n\t\t\t\t(*table)->emphRules[i][letterOffset] = ruleOffset;\n\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CTO_BegEmphWord: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset = (*table)->emphRules[i][begWordOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"word\",\n\t\t\t\t\t\t\tCTO_Emph1LetterRule + begWordOffset + (8 * i), &ruleOffset,\n\t\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\t\tbreak;\n\t\t\t\t(*table)->emphRules[i][begWordOffset] = ruleOffset;\n\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CTO_EndEmphWord: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset = (*table)->emphRules[i][endWordOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"word stop\",\n\t\t\t\t\t\t\tCTO_Emph1LetterRule + endWordOffset + (8 * i), &ruleOffset,\n\t\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\t\tbreak;\n\t\t\t\t(*table)->emphRules[i][endWordOffset] = ruleOffset;\n\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CTO_BegEmph: {\n\t\t\t\t/* fail if both begemph and any of begemphphrase or begemphword are\n\t\t\t\t * defined */\n\t\t\t\tif ((*table)->emphRules[i][begWordOffset] ||\n\t\t\t\t\t\t(*table)->emphRules[i][begPhraseOffset]) {\n\t\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\t\"Cannot define emphasis for both no context and word or \"\n\t\t\t\t\t\t\t\"phrase context, i.e. cannot have both begemph and \"\n\t\t\t\t\t\t\t\"begemphword or begemphphrase.\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset = (*table)->emphRules[i][begOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"first letter\",\n\t\t\t\t\t\t\tCTO_Emph1LetterRule + begOffset + (8 * i), &ruleOffset,\n\t\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\t\tbreak;\n\t\t\t\t(*table)->emphRules[i][begOffset] = ruleOffset;\n\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CTO_EndEmph: {\n\t\t\t\tif ((*table)->emphRules[i][endWordOffset] ||\n\t\t\t\t\t\t(*table)->emphRules[i][endPhraseBeforeOffset] ||\n\t\t\t\t\t\t(*table)->emphRules[i][endPhraseAfterOffset]) {\n\t\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\t\"Cannot define emphasis for both no context and word or \"\n\t\t\t\t\t\t\t\"phrase context, i.e. cannot have both endemph and \"\n\t\t\t\t\t\t\t\"endemphword or endemphphrase.\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset = (*table)->emphRules[i][endOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"last letter\",\n\t\t\t\t\t\t\tCTO_Emph1LetterRule + endOffset + (8 * i), &ruleOffset,\n\t\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\t\tbreak;\n\t\t\t\t(*table)->emphRules[i][endOffset] = ruleOffset;\n\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CTO_BegEmphPhrase: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset =\n\t\t\t\t\t\t(*table)->emphRules[i][begPhraseOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"first word\",\n\t\t\t\t\t\t\tCTO_Emph1LetterRule + begPhraseOffset + (8 * i), &ruleOffset,\n\t\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\t\tbreak;\n\t\t\t\t(*table)->emphRules[i][begPhraseOffset] = ruleOffset;\n\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CTO_EndEmphPhrase:\n\t\t\t\tswitch (compileBeforeAfter(file)) {\n\t\t\t\tcase 1: {  // before\n\t\t\t\t\tif ((*table)->emphRules[i][endPhraseAfterOffset]) {\n\t\t\t\t\t\tcompileError(file, \"last word after already defined.\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t\t// table\n\t\t\t\t\tTranslationTableOffset ruleOffset =\n\t\t\t\t\t\t\t(*table)->emphRules[i][endPhraseBeforeOffset];\n\t\t\t\t\tif (!compileBrailleIndicator(file, \"last word before\",\n\t\t\t\t\t\t\t\tCTO_Emph1LetterRule + endPhraseBeforeOffset + (8 * i),\n\t\t\t\t\t\t\t\t&ruleOffset, noback, nofor, table))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t(*table)->emphRules[i][endPhraseBeforeOffset] = ruleOffset;\n\t\t\t\t\tok = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 2: {  // after\n\t\t\t\t\tif ((*table)->emphRules[i][endPhraseBeforeOffset]) {\n\t\t\t\t\t\tcompileError(file, \"last word before already defined.\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t\t// table\n\t\t\t\t\tTranslationTableOffset ruleOffset =\n\t\t\t\t\t\t\t(*table)->emphRules[i][endPhraseAfterOffset];\n\t\t\t\t\tif (!compileBrailleIndicator(file, \"last word after\",\n\t\t\t\t\t\t\t\tCTO_Emph1LetterRule + endPhraseAfterOffset + (8 * i),\n\t\t\t\t\t\t\t\t&ruleOffset, noback, nofor, table))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t(*table)->emphRules[i][endPhraseAfterOffset] = ruleOffset;\n\t\t\t\t\tok = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdefault:  // error\n\t\t\t\t\tcompileError(file, \"Invalid lastword indicator location.\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase CTO_LenEmphPhrase:\n\t\t\t\tif (((*table)->emphRules[i][lenPhraseOffset] = compileNumber(file)))\n\t\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\tcase CTO_EmphModeChars: {\n\t\t\t\tif (!getRuleCharsText(file, &ruleChars)) break;\n\t\t\t\twidechar *emphmodechars = (*table)->emphModeChars[i];\n\t\t\t\tint len;\n\t\t\t\tfor (len = 0; len < EMPHMODECHARSSIZE && emphmodechars[len]; len++)\n\t\t\t\t\t;\n\t\t\t\tif (len + ruleChars.length > EMPHMODECHARSSIZE) {\n\t\t\t\t\tcompileError(file, \"More than %d characters\", EMPHMODECHARSSIZE);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tok = 1;\n\t\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\t\tif (!getChar(ruleChars.chars[k], *table, NULL)) {\n\t\t\t\t\t\tcompileError(file, \"Emphasis mode character undefined\");\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\temphmodechars[len++] = ruleChars.chars[k];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CTO_NoEmphChars: {\n\t\t\t\tif (!getRuleCharsText(file, &ruleChars)) break;\n\t\t\t\twidechar *noemphchars = (*table)->noEmphChars[i];\n\t\t\t\tint len;\n\t\t\t\tfor (len = 0; len < NOEMPHCHARSSIZE && noemphchars[len]; len++)\n\t\t\t\t\t;\n\t\t\t\tif (len + ruleChars.length > NOEMPHCHARSSIZE) {\n\t\t\t\t\tcompileError(file, \"More than %d characters\", NOEMPHCHARSSIZE);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tok = 1;\n\t\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\t\tif (!getChar(ruleChars.chars[k], *table, NULL)) {\n\t\t\t\t\t\tcompileError(file, \"Character undefined\");\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tnoemphchars[len++] = ruleChars.chars[k];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfree(s);\n\t\t\treturn ok;\n\t\t}\n\t\tcase CTO_LetterSign: {\n\t\t\t// not passing pointer because compileBrailleIndicator may reallocate table\n\t\t\tTranslationTableOffset ruleOffset = (*table)->letterSign;\n\t\t\tif (!compileBrailleIndicator(file, \"letter sign\", CTO_LetterRule, &ruleOffset,\n\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\treturn 0;\n\t\t\t(*table)->letterSign = ruleOffset;\n\t\t\treturn 1;\n\t\t}\n\t\tcase CTO_NoLetsignBefore:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tif (((*table)->noLetsignBeforeCount + ruleChars.length) > LETSIGNBEFORESIZE) {\n\t\t\t\tcompileError(file, \"More than %d characters\", LETSIGNBEFORESIZE);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tfor (int k = 0; k < ruleChars.length; k++)\n\t\t\t\t(*table)->noLetsignBefore[(*table)->noLetsignBeforeCount++] =\n\t\t\t\t\t\truleChars.chars[k];\n\t\t\treturn 1;\n\t\tcase CTO_NoLetsign:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tif (((*table)->noLetsignCount + ruleChars.length) > LETSIGNSIZE) {\n\t\t\t\tcompileError(file, \"More than %d characters\", LETSIGNSIZE);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tfor (int k = 0; k < ruleChars.length; k++)\n\t\t\t\t(*table)->noLetsign[(*table)->noLetsignCount++] = ruleChars.chars[k];\n\t\t\treturn 1;\n\t\tcase CTO_NoLetsignAfter:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tif (((*table)->noLetsignAfterCount + ruleChars.length) > LETSIGNAFTERSIZE) {\n\t\t\t\tcompileError(file, \"More than %d characters\", LETSIGNAFTERSIZE);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tfor (int k = 0; k < ruleChars.length; k++)\n\t\t\t\t(*table)->noLetsignAfter[(*table)->noLetsignAfterCount++] =\n\t\t\t\t\t\truleChars.chars[k];\n\t\t\treturn 1;\n\t\tcase CTO_NumberSign: {\n\t\t\t// not passing pointer because compileBrailleIndicator may reallocate table\n\t\t\tTranslationTableOffset ruleOffset = (*table)->numberSign;\n\t\t\tif (!compileBrailleIndicator(file, \"number sign\", CTO_NumberRule, &ruleOffset,\n\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\treturn 0;\n\t\t\t(*table)->numberSign = ruleOffset;\n\t\t\treturn 1;\n\t\t}\n\n\t\tcase CTO_NumericModeChars:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\tTranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);\n\t\t\t\tif (!c) {\n\t\t\t\t\tcompileError(file, \"Numeric mode character undefined: %s\",\n\t\t\t\t\t\t\t_lou_showString(&ruleChars.chars[k], 1, 0));\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tc->attributes |= CTC_NumericMode;\n\t\t\t\t(*table)->usesNumericMode = 1;\n\t\t\t}\n\t\t\treturn 1;\n\n\t\tcase CTO_MidEndNumericModeChars:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\tTranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);\n\t\t\t\tif (!c) {\n\t\t\t\t\tcompileError(file, \"Midendnumeric mode character undefined\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tc->attributes |= CTC_MidEndNumericMode;\n\t\t\t\t(*table)->usesNumericMode = 1;\n\t\t\t}\n\t\t\treturn 1;\n\n\t\tcase CTO_NumericNoContractChars:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\tTranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);\n\t\t\t\tif (!c) {\n\t\t\t\t\tcompileError(file, \"Numeric no contraction character undefined\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tc->attributes |= CTC_NumericNoContract;\n\t\t\t\t(*table)->usesNumericMode = 1;\n\t\t\t}\n\t\t\treturn 1;\n\n\t\tcase CTO_NoContractSign: {\n\t\t\t// not passing pointer because compileBrailleIndicator may reallocate table\n\t\t\tTranslationTableOffset ruleOffset = (*table)->noContractSign;\n\t\t\tif (!compileBrailleIndicator(file, \"no contractions sign\", CTO_NoContractRule,\n\t\t\t\t\t\t&ruleOffset, noback, nofor, table))\n\t\t\t\treturn 0;\n\t\t\t(*table)->noContractSign = ruleOffset;\n\t\t\treturn 1;\n\t\t}\n\t\tcase CTO_SeqDelimiter:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\tTranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);\n\t\t\t\tif (!c) {\n\t\t\t\t\tcompileError(file, \"Sequence delimiter character undefined\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tc->attributes |= CTC_SeqDelimiter;\n\t\t\t\t(*table)->usesSequences = 1;\n\t\t\t}\n\t\t\treturn 1;\n\n\t\tcase CTO_SeqBeforeChars:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\tTranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);\n\t\t\t\tif (!c) {\n\t\t\t\t\tcompileError(file, \"Sequence before character undefined\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tc->attributes |= CTC_SeqBefore;\n\t\t\t}\n\t\t\treturn 1;\n\n\t\tcase CTO_SeqAfterChars:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\tTranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);\n\t\t\t\tif (!c) {\n\t\t\t\t\tcompileError(file, \"Sequence after character undefined\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tc->attributes |= CTC_SeqAfter;\n\t\t\t}\n\t\t\treturn 1;\n\n\t\tcase CTO_SeqAfterPattern:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tif (((*table)->seqPatternsCount + ruleChars.length + 1) > SEQPATTERNSIZE) {\n\t\t\t\tcompileError(file, \"More than %d characters\", SEQPATTERNSIZE);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tfor (int k = 0; k < ruleChars.length; k++)\n\t\t\t\t(*table)->seqPatterns[(*table)->seqPatternsCount++] = ruleChars.chars[k];\n\t\t\t(*table)->seqPatterns[(*table)->seqPatternsCount++] = 0;\n\t\t\treturn 1;\n\n\t\tcase CTO_SeqAfterExpression:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tfor ((*table)->seqAfterExpressionLength = 0;\n\t\t\t\t\t(*table)->seqAfterExpressionLength < ruleChars.length;\n\t\t\t\t\t(*table)->seqAfterExpressionLength++)\n\t\t\t\t(*table)->seqAfterExpression[(*table)->seqAfterExpressionLength] =\n\t\t\t\t\t\truleChars.chars[(*table)->seqAfterExpressionLength];\n\t\t\t(*table)->seqAfterExpression[(*table)->seqAfterExpressionLength] = 0;\n\t\t\treturn 1;\n\n\t\tcase CTO_CapsModeChars:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\tTranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);\n\t\t\t\tif (!c) {\n\t\t\t\t\tcompileError(file, \"Capital mode character undefined\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tc->attributes |= CTC_CapsMode;\n\t\t\t\t(*table)->hasCapsModeChars = 1;\n\t\t\t}\n\t\t\treturn 1;\n\n\t\tcase CTO_BegComp: {\n\t\t\t// not passing pointer because compileBrailleIndicator may reallocate table\n\t\t\tTranslationTableOffset ruleOffset = (*table)->begComp;\n\t\t\tif (!compileBrailleIndicator(file, \"begin computer braille\", CTO_BegCompRule,\n\t\t\t\t\t\t&ruleOffset, noback, nofor, table))\n\t\t\t\treturn 0;\n\t\t\t(*table)->begComp = ruleOffset;\n\t\t\treturn 1;\n\t\t}\n\t\tcase CTO_EndComp: {\n\t\t\t// not passing pointer because compileBrailleIndicator may reallocate table\n\t\t\tTranslationTableOffset ruleOffset = (*table)->endComp;\n\t\t\tif (!compileBrailleIndicator(file, \"end computer braslle\", CTO_EndCompRule,\n\t\t\t\t\t\t&ruleOffset, noback, nofor, table))\n\t\t\t\treturn 0;\n\t\t\t(*table)->endComp = ruleOffset;\n\t\t\treturn 1;\n\t\t}\n\t\tcase CTO_NoCross:\n\t\t\tif (nocross) {\n\t\t\t\tcompileError(\n\t\t\t\t\t\tfile, \"%s already specified.\", _lou_findOpcodeName(CTO_NoCross));\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tnocross = 1;\n\t\t\tgoto doOpcode;\n\t\tcase CTO_Syllable:\n\t\t\t(*table)->syllables = 1;\n\t\tcase CTO_Always:\n\t\tcase CTO_LargeSign:\n\t\tcase CTO_WholeWord:\n\t\tcase CTO_PartWord:\n\t\tcase CTO_JoinNum:\n\t\tcase CTO_JoinableWord:\n\t\tcase CTO_LowWord:\n\t\tcase CTO_SuffixableWord:\n\t\tcase CTO_PrefixableWord:\n\t\tcase CTO_BegWord:\n\t\tcase CTO_BegMidWord:\n\t\tcase CTO_MidWord:\n\t\tcase CTO_MidEndWord:\n\t\tcase CTO_EndWord:\n\t\tcase CTO_PrePunc:\n\t\tcase CTO_PostPunc:\n\t\tcase CTO_BegNum:\n\t\tcase CTO_MidNum:\n\t\tcase CTO_EndNum:\n\t\tcase CTO_Repeated:\n\t\tcase CTO_RepWord:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tif (!getRuleDotsPattern(file, &ruleDots)) return 0;\n\t\t\tif (ruleDots.length == 0)\n\t\t\t\t// check that all characters in a rule with `=` as second operand are\n\t\t\t\t// defined (or based on another character)\n\t\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\t\tTranslationTableCharacter *c =\n\t\t\t\t\t\t\tgetChar(ruleChars.chars[k], *table, NULL);\n\t\t\t\t\tif (!(c && (c->definitionRule || c->basechar))) {\n\t\t\t\t\t\tcompileError(file, \"Character %s is not defined\",\n\t\t\t\t\t\t\t\t_lou_showString(&ruleChars.chars[k], 1, 0));\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tTranslationTableRule *r;\n\t\t\tif (!addRule(file, opcode, &ruleChars, &ruleDots, after, before, NULL, &r,\n\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\treturn 0;\n\t\t\tif (nocross) r->nocross = 1;\n\t\t\treturn 1;\n\t\t\t// if (opcode == CTO_MidNum)\n\t\t\t// {\n\t\t\t//   TranslationTableCharacter *c = getChar(ruleChars.chars[0]);\n\t\t\t//   if(c)\n\t\t\t//     c->attributes |= CTC_NumericMode;\n\t\t\t// }\n\t\tcase CTO_RepEndWord:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tCharsString dots;\n\t\t\tif (!getToken(file, &dots, \"dots,dots operand\")) return 0;\n\t\t\tint len = dots.length;\n\t\t\tfor (int k = 0; k < len - 1; k++) {\n\t\t\t\tif (dots.chars[k] == ',') {\n\t\t\t\t\tdots.length = k;\n\t\t\t\t\tif (!parseDots(file, &ruleDots, &dots)) return 0;\n\t\t\t\t\truleDots.chars[ruleDots.length++] = ',';\n\t\t\t\t\tk++;\n\t\t\t\t\tif (k == len - 1 && dots.chars[k] == '=') {\n\t\t\t\t\t\t// check that all characters are defined (or based on another\n\t\t\t\t\t\t// character)\n\t\t\t\t\t\tfor (int l = 0; l < ruleChars.length; l++) {\n\t\t\t\t\t\t\tTranslationTableCharacter *c =\n\t\t\t\t\t\t\t\t\tgetChar(ruleChars.chars[l], *table, NULL);\n\t\t\t\t\t\t\tif (!(c && (c->definitionRule || c->basechar))) {\n\t\t\t\t\t\t\t\tcompileError(file, \"Character %s is not defined\",\n\t\t\t\t\t\t\t\t\t\t_lou_showString(&ruleChars.chars[l], 1, 0));\n\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tCharsString x, y;\n\t\t\t\t\t\tx.length = 0;\n\t\t\t\t\t\twhile (k < len) x.chars[x.length++] = dots.chars[k++];\n\t\t\t\t\t\tif (parseDots(file, &y, &x))\n\t\t\t\t\t\t\tfor (int l = 0; l < y.length; l++)\n\t\t\t\t\t\t\t\truleDots.chars[ruleDots.length++] = y.chars[l];\n\t\t\t\t\t}\n\t\t\t\t\treturn addRule(file, opcode, &ruleChars, &ruleDots, after, before,\n\t\t\t\t\t\t\tNULL, NULL, noback, nofor, table);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\tcase CTO_CompDots:\n\t\tcase CTO_Comp6: {\n\t\t\tTranslationTableOffset ruleOffset;\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tif (ruleChars.length != 1) {\n\t\t\t\tcompileError(file, \"first operand must be 1 character\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (nofor || noback) {\n\t\t\t\tcompileWarning(file, \"nofor and noback not allowed on comp6 rules\");\n\t\t\t}\n\t\t\tif (!getRuleDotsPattern(file, &ruleDots)) return 0;\n\t\t\tif (!addRule(file, opcode, &ruleChars, &ruleDots, after, before, &ruleOffset,\n\t\t\t\t\t\tNULL, noback, nofor, table))\n\t\t\t\treturn 0;\n\t\t\treturn 1;\n\t\t}\n\t\tcase CTO_ExactDots:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tif (ruleChars.chars[0] != '@') {\n\t\t\t\tcompileError(file, \"The operand must begin with an at sign (@)\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tfor (int k = 1; k < ruleChars.length; k++)\n\t\t\t\tscratchPad.chars[k - 1] = ruleChars.chars[k];\n\t\t\tscratchPad.length = ruleChars.length - 1;\n\t\t\tif (!parseDots(file, &ruleDots, &scratchPad)) return 0;\n\t\t\treturn addRule(file, opcode, &ruleChars, &ruleDots, before, after, NULL, NULL,\n\t\t\t\t\tnoback, nofor, table);\n\t\tcase CTO_CapsNoCont: {\n\t\t\tTranslationTableOffset ruleOffset;\n\t\t\truleChars.length = 1;\n\t\t\truleChars.chars[0] = 'a';\n\t\t\tif (!addRule(file, CTO_CapsNoContRule, &ruleChars, NULL, after, before,\n\t\t\t\t\t\t&ruleOffset, NULL, noback, nofor, table))\n\t\t\t\treturn 0;\n\t\t\t(*table)->capsNoCont = ruleOffset;\n\t\t\treturn 1;\n\t\t}\n\t\tcase CTO_Replace:\n\t\t\tif (getRuleCharsText(file, &ruleChars)) {\n\t\t\t\tif (atEndOfLine(file))\n\t\t\t\t\truleDots.length = ruleDots.chars[0] = 0;\n\t\t\t\telse {\n\t\t\t\t\tgetRuleDotsText(file, &ruleDots);\n\t\t\t\t\tif (ruleDots.chars[0] == '#')\n\t\t\t\t\t\truleDots.length = ruleDots.chars[0] = 0;\n\t\t\t\t\telse if (ruleDots.chars[0] == '\\\\' && ruleDots.chars[1] == '#')\n\t\t\t\t\t\tmemmove(&ruleDots.chars[0], &ruleDots.chars[1],\n\t\t\t\t\t\t\t\truleDots.length-- * CHARSIZE);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int k = 0; k < ruleChars.length; k++)\n\t\t\t\tputChar(file, ruleChars.chars[k], table, NULL);\n\t\t\tfor (int k = 0; k < ruleDots.length; k++)\n\t\t\t\tputChar(file, ruleDots.chars[k], table, NULL);\n\t\t\treturn addRule(file, opcode, &ruleChars, &ruleDots, after, before, NULL, NULL,\n\t\t\t\t\tnoback, nofor, table);\n\t\tcase CTO_Correct:\n\t\t\t(*table)->corrections = 1;\n\t\t\tgoto doPass;\n\t\tcase CTO_Pass2:\n\t\t\tif ((*table)->numPasses < 2) (*table)->numPasses = 2;\n\t\t\tgoto doPass;\n\t\tcase CTO_Pass3:\n\t\t\tif ((*table)->numPasses < 3) (*table)->numPasses = 3;\n\t\t\tgoto doPass;\n\t\tcase CTO_Pass4:\n\t\t\tif ((*table)->numPasses < 4) (*table)->numPasses = 4;\n\t\tdoPass:\n\t\tcase CTO_Context:\n\t\t\tif (!(nofor || noback)) {\n\t\t\t\tcompileError(file, \"%s or %s must be specified.\",\n\t\t\t\t\t\t_lou_findOpcodeName(CTO_NoFor), _lou_findOpcodeName(CTO_NoBack));\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn compilePassOpcode(file, opcode, noback, nofor, table);\n\t\tcase CTO_Contraction:\n\t\tcase CTO_NoCont:\n\t\tcase CTO_CompBrl:\n\t\tcase CTO_Literal:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\t// check that all characters in a compbrl, contraction,\n\t\t\t// nocont or literal rule are defined (or based on another\n\t\t\t// character)\n\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\tTranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);\n\t\t\t\tif (!(c && (c->definitionRule || c->basechar))) {\n\t\t\t\t\tcompileError(file, \"Character %s is not defined\",\n\t\t\t\t\t\t\t_lou_showString(&ruleChars.chars[k], 1, 0));\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn addRule(file, opcode, &ruleChars, NULL, after, before, NULL, NULL,\n\t\t\t\t\tnoback, nofor, table);\n\t\tcase CTO_MultInd: {\n\t\t\truleChars.length = 0;\n\t\t\tif (!getToken(file, &token, \"multiple braille indicators\") ||\n\t\t\t\t\t!parseDots(file, &cells, &token))\n\t\t\t\treturn 0;\n\t\t\twhile (getToken(file, &token, \"multind opcodes\")) {\n\t\t\t\topcode = getOpcode(file, &token);\n\t\t\t\tif (opcode == CTO_None) {\n\t\t\t\t\tcompileError(file, \"opcode %s not defined.\",\n\t\t\t\t\t\t\t_lou_showString(token.chars, token.length, 0));\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif (!(opcode >= CTO_CapsLetter && opcode < CTO_MultInd)) {\n\t\t\t\t\tcompileError(file, \"Not a braille indicator opcode.\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\truleChars.chars[ruleChars.length++] = (widechar)opcode;\n\t\t\t\tif (atEndOfLine(file)) break;\n\t\t\t}\n\t\t\treturn addRule(file, CTO_MultInd, &ruleChars, &cells, after, before, NULL,\n\t\t\t\t\tNULL, noback, nofor, table);\n\t\t}\n\n\t\tcase CTO_Class:\n\t\t\tcompileWarning(file, \"class is deprecated, use attribute instead\");\n\t\tcase CTO_Attribute: {\n\t\t\tif (nofor || noback) {\n\t\t\t\tcompileWarning(\n\t\t\t\t\t\tfile, \"nofor and noback not allowed before class/attribute\");\n\t\t\t}\n\t\t\tif ((opcode == CTO_Class && (*table)->usesAttributeOrClass == 1) ||\n\t\t\t\t\t(opcode == CTO_Attribute && (*table)->usesAttributeOrClass == 2)) {\n\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\"attribute and class rules must not be both present in a table\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (opcode == CTO_Class)\n\t\t\t\t(*table)->usesAttributeOrClass = 2;\n\t\t\telse\n\t\t\t\t(*table)->usesAttributeOrClass = 1;\n\t\t\tif (!getToken(file, &token, \"attribute name\")) {\n\t\t\t\tcompileError(file, \"Expected %s\", \"attribute name\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (!(*table)->characterClasses && !allocateCharacterClasses(*table)) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tTranslationTableCharacterAttributes attribute = 0;\n\t\t\t{\n\t\t\t\tint attrNumber = -1;\n\t\t\t\tswitch (token.chars[0]) {\n\t\t\t\tcase '0':\n\t\t\t\tcase '1':\n\t\t\t\tcase '2':\n\t\t\t\tcase '3':\n\t\t\t\tcase '4':\n\t\t\t\tcase '5':\n\t\t\t\tcase '6':\n\t\t\t\tcase '7':\n\t\t\t\tcase '8':\n\t\t\t\tcase '9':\n\t\t\t\t\tattrNumber = token.chars[0] - '0';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (attrNumber >= 0) {\n\t\t\t\t\tif (opcode == CTO_Class) {\n\t\t\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\t\t\"Invalid class name: may not contain digits, use \"\n\t\t\t\t\t\t\t\t\"attribute instead of class\");\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (token.length > 1 || attrNumber > 7) {\n\t\t\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\t\t\"Invalid attribute name: must be a digit between 0 and 7 \"\n\t\t\t\t\t\t\t\t\"or a word containing only letters\");\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (!(*table)->numberedAttributes[attrNumber])\n\t\t\t\t\t\t// attribute not used before yet: assign it a value\n\t\t\t\t\t\t(*table)->numberedAttributes[attrNumber] =\n\t\t\t\t\t\t\t\tgetNextNumberedAttribute(*table);\n\t\t\t\t\tattribute = (*table)->numberedAttributes[attrNumber];\n\t\t\t\t} else {\n\t\t\t\t\tconst CharacterClass *namedAttr = findCharacterClass(&token, *table);\n\t\t\t\t\tif (!namedAttr) {\n\t\t\t\t\t\t// no class with that name: create one\n\t\t\t\t\t\tnamedAttr = addCharacterClass(\n\t\t\t\t\t\t\t\tfile, &token.chars[0], token.length, *table, 1);\n\t\t\t\t\t\tif (!namedAttr) return 0;\n\t\t\t\t\t}\n\t\t\t\t\t// there is a class with that name or a new class was successfully\n\t\t\t\t\t// created\n\t\t\t\t\tattribute = namedAttr->attribute;\n\t\t\t\t\tif (attribute == CTC_UpperCase || attribute == CTC_LowerCase)\n\t\t\t\t\t\tattribute |= CTC_Letter;\n\t\t\t\t}\n\t\t\t}\n\t\t\tCharsString characters;\n\t\t\tif (!getCharacters(file, &characters)) return 0;\n\t\t\tfor (int i = 0; i < characters.length; i++) {\n\t\t\t\t// get the character from the table, or if it is not defined yet,\n\t\t\t\t// define it\n\t\t\t\tTranslationTableCharacter *character =\n\t\t\t\t\t\tputChar(file, characters.chars[i], table, NULL);\n\t\t\t\t// set the attribute\n\t\t\t\tcharacter->attributes |= attribute;\n\t\t\t\t// also set the attribute on the associated dots (if any)\n\t\t\t\tif (character->basechar)\n\t\t\t\t\tcharacter = (TranslationTableCharacter *)&(*table)\n\t\t\t\t\t\t\t\t\t\t->ruleArea[character->basechar];\n\t\t\t\tif (character->definitionRule) {\n\t\t\t\t\tTranslationTableRule *defRule =\n\t\t\t\t\t\t\t(TranslationTableRule *)&(*table)\n\t\t\t\t\t\t\t\t\t->ruleArea[character->definitionRule];\n\t\t\t\t\tif (defRule->dotslen == 1) {\n\t\t\t\t\t\tTranslationTableCharacter *dots =\n\t\t\t\t\t\t\t\tgetDots(defRule->charsdots[defRule->charslen], *table);\n\t\t\t\t\t\tif (dots) dots->attributes |= attribute;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\n\t\t\t{\n\t\t\t\tTranslationTableCharacterAttributes *attributes;\n\t\t\t\tconst CharacterClass *class;\n\t\t\tcase CTO_After:\n\t\t\t\tattributes = &after;\n\t\t\t\tgoto doBeforeAfter;\n\t\t\tcase CTO_Before:\n\t\t\t\tattributes = &before;\n\t\t\tdoBeforeAfter:\n\t\t\t\tif (!(*table)->characterClasses) {\n\t\t\t\t\tif (!allocateCharacterClasses(*table)) return 0;\n\t\t\t\t}\n\t\t\t\tif (!getToken(file, &token, \"attribute name\")) return 0;\n\t\t\t\tif (!(class = findCharacterClass(&token, *table))) {\n\t\t\t\t\tcompileError(file, \"attribute not defined\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\t*attributes |= class->attribute;\n\t\t\t\tgoto doOpcode;\n\t\t\t}\n\t\tcase CTO_Base:\n\t\t\tif (nofor || noback) {\n\t\t\t\tcompileWarning(file, \"nofor and noback not allowed before base\");\n\t\t\t}\n\t\t\tif (!getToken(file, &token, \"attribute name\")) {\n\t\t\t\tcompileError(\n\t\t\t\t\t\tfile, \"base opcode must be followed by a valid attribute name.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (!(*table)->characterClasses && !allocateCharacterClasses(*table)) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tconst CharacterClass *mode = findCharacterClass(&token, *table);\n\t\t\tif (!mode) {\n\t\t\t\tmode = addCharacterClass(file, token.chars, token.length, *table, 1);\n\t\t\t\tif (!mode) return 0;\n\t\t\t}\n\t\t\tif (!(mode->attribute == CTC_UpperCase || mode->attribute == CTC_Digit) &&\n\t\t\t\t\tmode->attribute >= CTC_Space && mode->attribute <= CTC_LitDigit) {\n\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\"base opcode must be followed by \\\"uppercase\\\", \\\"digit\\\", or a \"\n\t\t\t\t\t\t\"custom attribute name.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (!getRuleCharsText(file, &token)) return 0;\n\t\t\tif (token.length != 1) {\n\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\"Exactly one character followed by one base character is \"\n\t\t\t\t\t\t\"required.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tTranslationTableOffset characterOffset;\n\t\t\tTranslationTableCharacter *character =\n\t\t\t\t\tputChar(file, token.chars[0], table, &characterOffset);\n\t\t\tif (!getRuleCharsText(file, &token)) return 0;\n\t\t\tif (token.length != 1) {\n\t\t\t\tcompileError(file, \"Exactly one base character is required.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (character->definitionRule) {\n\t\t\t\tTranslationTableRule *prevRule =\n\t\t\t\t\t\t(TranslationTableRule *)&(*table)\n\t\t\t\t\t\t\t\t->ruleArea[character->definitionRule];\n\t\t\t\t_lou_logMessage(LOU_LOG_DEBUG,\n\t\t\t\t\t\t\"%s:%d: Character already defined (%s). The base rule will take \"\n\t\t\t\t\t\t\"precedence.\",\n\t\t\t\t\t\tfile->fileName, file->lineNumber,\n\t\t\t\t\t\tprintSource(file, prevRule->sourceFile, prevRule->sourceLine));\n\t\t\t\tcharacter->definitionRule = 0;\n\t\t\t}\n\t\t\tTranslationTableOffset basechar;\n\t\t\tputChar(file, token.chars[0], table, &basechar);\n\t\t\t// putChar may have moved table, so make sure character is still valid\n\t\t\tcharacter = (TranslationTableCharacter *)&(*table)->ruleArea[characterOffset];\n\t\t\tif (character->basechar) {\n\t\t\t\tif (character->basechar == basechar &&\n\t\t\t\t\t\tcharacter->mode == mode->attribute) {\n\t\t\t\t\t_lou_logMessage(LOU_LOG_DEBUG, \"%s:%d: Duplicate base rule.\",\n\t\t\t\t\t\t\tfile->fileName, file->lineNumber);\n\t\t\t\t} else {\n\t\t\t\t\t_lou_logMessage(LOU_LOG_DEBUG,\n\t\t\t\t\t\t\t\"%s:%d: A different base rule already exists for this \"\n\t\t\t\t\t\t\t\"character (%s). The new rule will take precedence.\",\n\t\t\t\t\t\t\tfile->fileName, file->lineNumber,\n\t\t\t\t\t\t\tprintSource(\n\t\t\t\t\t\t\t\t\tfile, character->sourceFile, character->sourceLine));\n\t\t\t\t}\n\t\t\t}\n\t\t\tcharacter->basechar = basechar;\n\t\t\tcharacter->mode = mode->attribute;\n\t\t\tcharacter->sourceFile = file->sourceFile;\n\t\t\tcharacter->sourceLine = file->lineNumber;\n\t\t\t/* some other processing is done at the end of the compilation, in\n\t\t\t * finalizeTable() */\n\t\t\treturn 1;\n\t\tcase CTO_EmpMatchBefore:\n\t\t\tbefore |= CTC_EmpMatch;\n\t\t\tgoto doOpcode;\n\t\tcase CTO_EmpMatchAfter:\n\t\t\tafter |= CTC_EmpMatch;\n\t\t\tgoto doOpcode;\n\n\t\tcase CTO_SwapCc:\n\t\tcase CTO_SwapCd:\n\t\tcase CTO_SwapDd:\n\t\t\treturn compileSwap(file, opcode, noback, nofor, table);\n\t\tcase CTO_Hyphen:\n\t\tcase CTO_DecPoint:\n\t\t\t//\tcase CTO_Apostrophe:\n\t\t\t//\tcase CTO_Initial:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tif (!getRuleDotsPattern(file, &ruleDots)) return 0;\n\t\t\tif (ruleChars.length != 1 || ruleDots.length < 1) {\n\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\"One Unicode character and at least one cell are \"\n\t\t\t\t\t\t\"required.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn addRule(file, opcode, &ruleChars, &ruleDots, after, before, NULL, NULL,\n\t\t\t\t\tnoback, nofor, table);\n\t\t\t// if (opcode == CTO_DecPoint)\n\t\t\t// {\n\t\t\t//   TranslationTableCharacter *c =\n\t\t\t//   getChar(ruleChars.chars[0]);\n\t\t\t//   if(c)\n\t\t\t//     c->attributes |= CTC_NumericMode;\n\t\t\t// }\n\t\tdefault:\n\t\t\tcompileError(file, \"unimplemented opcode.\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint EXPORT_CALL\nlou_readCharFromFile(const char *fileName, int *mode) {\n\t/* Read a character from a file, whether big-endian, little-endian or\n\t * ASCII8 */\n\tint ch;\n\tstatic FileInfo file;\n\tif (fileName == NULL) return 0;\n\tif (*mode == 1) {\n\t\t*mode = 0;\n\t\tfile.fileName = fileName;\n\t\tfile.encoding = noEncoding;\n\t\tfile.status = 0;\n\t\tfile.lineNumber = 0;\n\t\tif (!(file.in = fopen(file.fileName, \"r\"))) {\n\t\t\t_lou_logMessage(LOU_LOG_ERROR, \"Cannot open file '%s'\", file.fileName);\n\t\t\t*mode = 1;\n\t\t\treturn EOF;\n\t\t}\n\t}\n\tif (file.in == NULL) {\n\t\t*mode = 1;\n\t\treturn EOF;\n\t}\n\tch = getAChar(&file);\n\tif (ch == EOF) {\n\t\tfclose(file.in);\n\t\tfile.in = NULL;\n\t\t*mode = 1;\n\t}\n\treturn ch;\n}\n\nstatic int\nfinalizeTable(TranslationTableHeader *table) {\n\tif (table->finalized) return 1;\n\t// normalize basechar and mode of all characters\n\tfor (int i = 0; i < HASHNUM; i++) {\n\t\tTranslationTableOffset characterOffset = table->characters[i];\n\t\twhile (characterOffset) {\n\t\t\tTranslationTableCharacter *character =\n\t\t\t\t\t(TranslationTableCharacter *)&table->ruleArea[characterOffset];\n\t\t\tif (character->basechar) {\n\t\t\t\tTranslationTableOffset basecharOffset = 0;\n\t\t\t\tTranslationTableCharacter *basechar = character;\n\t\t\t\tTranslationTableCharacterAttributes mode = 0;\n\t\t\t\tint detect_loop = 0;\n\t\t\t\twhile (basechar->basechar) {\n\t\t\t\t\tif (basechar->basechar == characterOffset ||\n\t\t\t\t\t\t\tdetect_loop++ > MAX_MODES) {\n\t\t\t\t\t\t_lou_logMessage(LOU_LOG_ERROR,\n\t\t\t\t\t\t\t\t\"%s: error: Character can not be (indirectly) based on \"\n\t\t\t\t\t\t\t\t\"itself.\",\n\t\t\t\t\t\t\t\tprintSource(NULL, character->sourceFile,\n\t\t\t\t\t\t\t\t\t\tcharacter->sourceLine));\n\t\t\t\t\t\terrorCount++;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\t// inherit basechar mode\n\t\t\t\t\tmode |= basechar->mode;\n\t\t\t\t\t// compute basechar recursively\n\t\t\t\t\tbasecharOffset = basechar->basechar;\n\t\t\t\t\tbasechar =\n\t\t\t\t\t\t\t(TranslationTableCharacter *)&table->ruleArea[basecharOffset];\n\t\t\t\t\tif (character->mode & (basechar->attributes | basechar->mode)) {\n\t\t\t\t\t\tchar *attributeName = NULL;\n\t\t\t\t\t\tconst CharacterClass *class = table->characterClasses;\n\t\t\t\t\t\twhile (class) {\n\t\t\t\t\t\t\tif (class->attribute == character->mode) {\n\t\t\t\t\t\t\t\tattributeName = strdup(\n\t\t\t\t\t\t\t\t\t\t_lou_showString(class->name, class->length, 0));\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tclass = class->next;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t_lou_logMessage(LOU_LOG_ERROR,\n\t\t\t\t\t\t\t\t\"%s: error: Base character %s can not have the %s \"\n\t\t\t\t\t\t\t\t\"attribute.\",\n\t\t\t\t\t\t\t\tprintSource(NULL, character->sourceFile,\n\t\t\t\t\t\t\t\t\t\tcharacter->sourceLine),\n\t\t\t\t\t\t\t\t_lou_showString(&basechar->value, 1, 0),\n\t\t\t\t\t\t\t\tattributeName != NULL ? attributeName : \"?\");\n\t\t\t\t\t\terrorCount++;\n\t\t\t\t\t\tfree(attributeName);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcharacter->mode = mode;\n\t\t\t\tcharacter->basechar = basecharOffset;\n\t\t\t\t// add mode to attributes\n\t\t\t\tcharacter->attributes |= character->mode;\n\t\t\t\tif (character->attributes & (CTC_UpperCase | CTC_LowerCase))\n\t\t\t\t\tcharacter->attributes |= CTC_Letter;\n\t\t\t\t// also set the new attributes on the associated dots of the base\n\t\t\t\t// character\n\t\t\t\tTranslationTableRule *defRule =\n\t\t\t\t\t\t(TranslationTableRule *)&table\n\t\t\t\t\t\t\t\t->ruleArea[basechar->definitionRule];\n\t\t\t\tif (defRule->dotslen == 1) {\n\t\t\t\t\tTranslationTableCharacter *dots =\n\t\t\t\t\t\t\tgetDots(defRule->charsdots[defRule->charslen], table);\n\t\t\t\t\tif (dots) {\n\t\t\t\t\t\tdots->attributes |= character->mode;\n\t\t\t\t\t\tif (dots->attributes & (CTC_UpperCase | CTC_LowerCase))\n\t\t\t\t\t\t\tdots->attributes |= CTC_Letter;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// store all characters that are based on a base character in list\n\t\t\t\tif (basechar->linked) character->linked = basechar->linked;\n\t\t\t\tbasechar->linked = characterOffset;\n\t\t\t}\n\t\t\tcharacterOffset = character->next;\n\t\t}\n\t}\n\t// add noletsign rules from single-letter word and largesign rules\n\tfor (int i = 0; i < HASHNUM; i++) {\n\t\tTranslationTableOffset characterOffset = table->characters[i];\n\t\twhile (characterOffset) {\n\t\t\tTranslationTableCharacter *character =\n\t\t\t\t\t(TranslationTableCharacter *)&table->ruleArea[characterOffset];\n\t\t\tif (character->attributes & CTC_Letter) {\n\t\t\t\tTranslationTableOffset *otherRule = &character->otherRules;\n\t\t\t\twhile (*otherRule) {\n\t\t\t\t\tTranslationTableRule *rule =\n\t\t\t\t\t\t\t(TranslationTableRule *)&table->ruleArea[*otherRule];\n\t\t\t\t\tif (rule->opcode == CTO_WholeWord || rule->opcode == CTO_LargeSign)\n\t\t\t\t\t\tif (table->noLetsignCount < LETSIGNSIZE)\n\t\t\t\t\t\t\ttable->noLetsign[table->noLetsignCount++] =\n\t\t\t\t\t\t\t\t\trule->charsdots[0];\n\t\t\t\t\totherRule = &rule->charsnext;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcharacterOffset = character->next;\n\t\t}\n\t}\n\ttable->finalized = 1;\n\treturn 1;\n}\n\nstatic int\ncompileString(const char *inString, TranslationTableHeader **table,\n\t\tDisplayTableHeader **displayTable) {\n\t/* This function can be used to make changes to tables on the fly. */\n\tint k;\n\tFileInfo file;\n\tif (inString == NULL) return 0;\n\tmemset(&file, 0, sizeof(file));\n\tfile.fileName = inString;\n\tfile.encoding = noEncoding;\n\tfile.lineNumber = 1;\n\tfile.status = 0;\n\tfile.linepos = 0;\n\tfor (k = 0; inString[k]; k++) file.line[k] = inString[k];\n\tfile.line[k] = 0;\n\tfile.linelen = k;\n\tif (table && *table && (*table)->finalized) {\n\t\tcompileError(&file, \"Table is finalized\");\n\t\treturn 0;\n\t}\n\treturn compileRule(&file, table, displayTable, NULL);\n}\n\nstatic int\nsetDefaults(TranslationTableHeader *table) {\n\tfor (int i = 0; i < 3; i++)\n\t\tif (!table->emphRules[i][lenPhraseOffset])\n\t\t\ttable->emphRules[i][lenPhraseOffset] = 4;\n\tif (table->numPasses == 0) table->numPasses = 1;\n\treturn 1;\n}\n\n/* =============== *\n * TABLE RESOLVING *\n * =============== *\n *\n * A table resolver is a function that resolves a `tableList` path against a\n * `base` path, and returns the resolved table(s) as a list of absolute file\n * paths.\n *\n * The function must have the following signature:\n *\n *     char ** (const char * tableList, const char * base)\n *\n * In general, `tableList` is a path in the broad sense. The default\n * implementation accepts only *file* paths. But another implementation could\n * for instance handle URI's. `base` is always a file path however.\n *\n * The idea is to give other programs that use liblouis the ability to define\n * their own table resolver (in C, Java, Python, etc.) when the default\n * resolver is not satisfying. (see also lou_registerTableResolver)\n *\n */\n\n/**\n * Resolve a single (sub)table.\n *\n * Tries to resolve `table` against `base` if base is an absolute path. If\n * that fails, searches `searchPath`.\n *\n */\nstatic char *\nresolveSubtable(const char *table, const char *base, const char *searchPath) {\n\tchar *tableFile;\n\tstatic struct stat info;\n\n\tif (table == NULL || table[0] == '\\0') return NULL;\n\ttableFile = (char *)malloc(MAXSTRING * sizeof(char) * 2);\n\n\t//\n\t// First try to resolve against base\n\t//\n\tif (base) {\n\t\tint k;\n\t\tstrcpy(tableFile, base);\n\t\tk = (int)strlen(tableFile);\n\t\twhile (k >= 0 && tableFile[k] != '/' && tableFile[k] != '\\\\') k--;\n\t\ttableFile[++k] = '\\0';\n\t\tstrcat(tableFile, table);\n\t\tif (stat(tableFile, &info) == 0 && !(info.st_mode & S_IFDIR)) {\n\t\t\t_lou_logMessage(LOU_LOG_DEBUG, \"found table %s\", tableFile);\n\t\t\treturn tableFile;\n\t\t}\n\t}\n\n\t//\n\t// It could be an absolute path, or a path relative to the current working\n\t// directory\n\t//\n\tstrcpy(tableFile, table);\n\tif (stat(tableFile, &info) == 0 && !(info.st_mode & S_IFDIR)) {\n\t\t_lou_logMessage(LOU_LOG_DEBUG, \"found table %s\", tableFile);\n\t\treturn tableFile;\n\t}\n\n\t//\n\t// Then search `LOUIS_TABLEPATH`, `dataPath` and `programPath`\n\t//\n\tif (searchPath[0] != '\\0') {\n\t\tchar *dir;\n\t\tint last;\n\t\tchar *cp;\n\t\tchar *searchPath_copy = strdup(searchPath);\n\t\tfor (dir = searchPath_copy;; dir = cp + 1) {\n\t\t\tfor (cp = dir; *cp != '\\0' && *cp != ','; cp++)\n\t\t\t\t;\n\t\t\tlast = (*cp == '\\0');\n\t\t\t*cp = '\\0';\n\t\t\tif (dir == cp) dir = \".\";\n\t\t\tsprintf(tableFile, \"%s%c%s\", dir, DIR_SEP, table);\n\t\t\tif (stat(tableFile, &info) == 0 && !(info.st_mode & S_IFDIR)) {\n\t\t\t\t_lou_logMessage(LOU_LOG_DEBUG, \"found table %s\", tableFile);\n\t\t\t\tfree(searchPath_copy);\n\t\t\t\treturn tableFile;\n\t\t\t}\n\t\t\tif (last) break;\n\t\t\tsprintf(tableFile, \"%s%c%s%c%s%c%s\", dir, DIR_SEP, \"liblouis\", DIR_SEP,\n\t\t\t\t\t\"tables\", DIR_SEP, table);\n\t\t\tif (stat(tableFile, &info) == 0 && !(info.st_mode & S_IFDIR)) {\n\t\t\t\t_lou_logMessage(LOU_LOG_DEBUG, \"found table %s\", tableFile);\n\t\t\t\tfree(searchPath_copy);\n\t\t\t\treturn tableFile;\n\t\t\t}\n\t\t\tif (last) break;\n\t\t}\n\t\tfree(searchPath_copy);\n\t}\n\tfree(tableFile);\n\treturn NULL;\n}\n\nchar *EXPORT_CALL\n_lou_getTablePath(void) {\n\tchar searchPath[MAXSTRING];\n\tchar *path;\n\tchar *cp;\n\tint envset = 0;\n\tcp = searchPath;\n\tpath = getenv(\"LOUIS_TABLEPATH\");\n\tif (path != NULL && path[0] != '\\0') {\n\t\tenvset = 1;\n\t\tcp += sprintf(cp, \",%s\", path);\n\t}\n\tpath = lou_getDataPath();\n\tif (path != NULL && path[0] != '\\0')\n\t\tcp += sprintf(cp, \",%s%c%s%c%s\", path, DIR_SEP, \"liblouis\", DIR_SEP, \"tables\");\n\tif (!envset) {\n#ifdef _WIN32\n\t\tpath = lou_getProgramPath();\n\t\tif (path != NULL) {\n\t\t\tif (path[0] != '\\0')\n\t\t\t\tcp += sprintf(cp, \",%s%s\", path, \"\\\\share\\\\liblouis\\\\tables\");\n\t\t\tfree(path);\n\t\t}\n#else\n\t\tcp += sprintf(cp, \",%s\", TABLESDIR);\n#endif\n\t}\n\tif (searchPath[0] != '\\0')\n\t\treturn strdup(&searchPath[1]);\n\telse\n\t\treturn strdup(\".\");\n}\n\n/**\n * The default table resolver\n *\n * Tries to resolve tableList against base. The search path is set to\n * `LOUIS_TABLEPATH`, `dataPath` and `programPath` (in that order).\n *\n * @param table A file path, may be absolute or relative. May be a list of\n *              tables separated by comma's. In that case, the first table\n *              is used as the base for the other subtables.\n * @param base A file path or directory path, or NULL.\n * @return The file paths of the resolved subtables, or NULL if the table\n *         could not be resolved.\n *\n */\nchar **EXPORT_CALL\n_lou_defaultTableResolver(const char *tableList, const char *base) {\n\tchar *searchPath;\n\tchar **tableFiles;\n\tchar *subTable;\n\tchar *tableList_copy;\n\tchar *cp;\n\tint last;\n\tint k;\n\n\t/* Set up search path */\n\tsearchPath = _lou_getTablePath();\n\n\t/* Count number of subtables in table list */\n\tk = 0;\n\tfor (cp = (char *)tableList; *cp != '\\0'; cp++)\n\t\tif (*cp == ',') k++;\n\ttableFiles = (char **)calloc(k + 2, sizeof(char *));\n\tif (!tableFiles) _lou_outOfMemory();\n\n\t/* Resolve subtables */\n\tk = 0;\n\ttableList_copy = strdup(tableList);\n\tfor (subTable = tableList_copy;; subTable = cp + 1) {\n\t\tfor (cp = subTable; *cp != '\\0' && *cp != ','; cp++)\n\t\t\t;\n\t\tlast = (*cp == '\\0');\n\t\t*cp = '\\0';\n\t\tif (!(tableFiles[k++] = resolveSubtable(subTable, base, searchPath))) {\n\t\t\tchar *path;\n\t\t\t_lou_logMessage(LOU_LOG_ERROR, \"Cannot resolve table '%s'\", subTable);\n\t\t\tpath = getenv(\"LOUIS_TABLEPATH\");\n\t\t\tif (path != NULL && path[0] != '\\0')\n\t\t\t\t_lou_logMessage(LOU_LOG_ERROR, \"LOUIS_TABLEPATH=%s\", path);\n\t\t\tfree(searchPath);\n\t\t\tfree(tableList_copy);\n\t\t\tfree_tablefiles(tableFiles);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (k == 1) base = subTable;\n\t\tif (last) break;\n\t}\n\tfree(searchPath);\n\tfree(tableList_copy);\n\ttableFiles[k] = NULL;\n\treturn tableFiles;\n}\n\nstatic char **(EXPORT_CALL *tableResolver)(\n\t\tconst char *tableList, const char *base) = &_lou_defaultTableResolver;\n\nstatic char **\ncopyStringArray(char **array) {\n\tint len;\n\tchar **copy;\n\tif (!array) return NULL;\n\tlen = 0;\n\twhile (array[len]) len++;\n\tcopy = malloc((len + 1) * sizeof(char *));\n\tcopy[len] = NULL;\n\twhile (len) {\n\t\tlen--;\n\t\tcopy[len] = strdup(array[len]);\n\t}\n\treturn copy;\n}\n\nchar **EXPORT_CALL\n_lou_resolveTable(const char *tableList, const char *base) {\n\tchar **tableFiles = (*tableResolver)(tableList, base);\n\tchar **result = copyStringArray(tableFiles);\n\tif (tableResolver == &_lou_defaultTableResolver) free_tablefiles(tableFiles);\n\treturn result;\n}\n\n/**\n * Register a new table resolver. Overrides the default resolver.\n *\n * @param resolver The new resolver as a function pointer.\n *\n */\nvoid EXPORT_CALL\nlou_registerTableResolver(\n\t\tchar **(EXPORT_CALL *resolver)(const char *tableList, const char *base)) {\n\ttableResolver = resolver;\n}\n\nstatic int fileCount = 0;\n\n/**\n * Compile a single file\n *\n */\nstatic int\ncompileFile(const char *fileName, TranslationTableHeader **table,\n\t\tDisplayTableHeader **displayTable) {\n\tFileInfo file;\n\tfileCount++;\n\tfile.fileName = fileName;\n\tif (table) {\n\t\tint i;\n\t\tfor (i = 0; (*table)->sourceFiles[i]; i++)\n\t\t\t;\n\t\tif (i >= MAX_SOURCE_FILES) {\n\t\t\t_lou_logMessage(LOU_LOG_WARN, \"Max number of source files (%i) reached\",\n\t\t\t\t\tMAX_SOURCE_FILES);\n\t\t\tfile.sourceFile = NULL;\n\t\t} else {\n\t\t\tfile.sourceFile = (*table)->sourceFiles[i] = strdup(fileName);\n\t\t}\n\t}\n\tfile.encoding = noEncoding;\n\tfile.status = 0;\n\tfile.lineNumber = 0;\n\tif ((file.in = fopen(file.fileName, \"rb\"))) {\n\t\t// the scope of a macro is the current file (after the macro definition)\n\t\tconst MacroList *inscopeMacros = NULL;\n\t\twhile (_lou_getALine(&file))\n\t\t\tif (!compileRule(&file, table, displayTable, &inscopeMacros)) {\n\t\t\t\tif (!errorCount) compileError(&file, \"Rule could not be compiled\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\tfclose(file.in);\n\t\tfree_macro_list(inscopeMacros);\n\t} else {\n\t\t_lou_logMessage(LOU_LOG_ERROR, \"Cannot open table '%s'\", file.fileName);\n\t\terrorCount++;\n\t}\n\treturn !errorCount;\n}\n\nstatic void\nfreeTranslationTable(TranslationTableHeader *t) {\n\tfor (int i = 0; i < MAX_EMPH_CLASSES && t->emphClassNames[i]; i++)\n\t\tfree(t->emphClassNames[i]);\n\tfor (int i = 0; t->sourceFiles[i]; i++) free(t->sourceFiles[i]);\n\tif (t->characterClasses) deallocateCharacterClasses(t);\n\tif (t->ruleNames) deallocateRuleNames(t);\n\tfree(t);\n}\n\n/**\n * Free a char** array\n */\nstatic void\nfree_tablefiles(char **tables) {\n\tchar **table;\n\tif (!tables) return;\n\tfor (table = tables; *table; table++) free(*table);\n\tfree(tables);\n}\n\n/**\n * Implement include opcode\n *\n */\nstatic int\nincludeFile(const FileInfo *file, CharsString *includedFile,\n\t\tTranslationTableHeader **table, DisplayTableHeader **displayTable) {\n\tint k;\n\tchar includeThis[MAXSTRING];\n\tchar **tableFiles;\n\tint rv;\n\tfor (k = 0; k < includedFile->length; k++)\n\t\tincludeThis[k] = (char)includedFile->chars[k];\n\tif (k >= MAXSTRING) {\n\t\tcompileError(file, \"Include statement too long: 'include %s'\", includeThis);\n\t\treturn 0;\n\t}\n\tincludeThis[k] = 0;\n\ttableFiles = _lou_resolveTable(includeThis, file->fileName);\n\tif (tableFiles == NULL) {\n\t\terrorCount++;\n\t\treturn 0;\n\t}\n\tif (tableFiles[1] != NULL) {\n\t\tfree_tablefiles(tableFiles);\n\t\tcompileError(file, \"Table list not supported in include statement: 'include %s'\",\n\t\t\t\tincludeThis);\n\t\treturn 0;\n\t}\n\trv = compileFile(*tableFiles, table, displayTable);\n\tfree_tablefiles(tableFiles);\n\tif (!rv)\n\t\t_lou_logMessage(LOU_LOG_ERROR, \"%s:%d: Error in included file\", file->fileName,\n\t\t\t\tfile->lineNumber);\n\treturn rv;\n}\n\n/**\n * Compile source tables into a table in memory\n *\n */\nstatic int\ncompileTable(const char *tableList, const char *displayTableList,\n\t\tTranslationTableHeader **translationTable, DisplayTableHeader **displayTable) {\n\tchar **tableFiles;\n\tchar **subTable;\n\tif (translationTable && !tableList) return 0;\n\tif (displayTable && !displayTableList) return 0;\n\tif (!translationTable && !displayTable) return 0;\n\tif (translationTable) *translationTable = NULL;\n\tif (displayTable) *displayTable = NULL;\n\terrorCount = warningCount = fileCount = 0;\n\tif (!opcodeLengths[0]) {\n\t\tTranslationTableOpcode opcode;\n\t\tfor (opcode = 0; opcode < CTO_None; opcode++)\n\t\t\topcodeLengths[opcode] = (short)strlen(opcodeNames[opcode]);\n\t}\n\tif (translationTable) allocateTranslationTable(NULL, translationTable);\n\tif (displayTable) allocateDisplayTable(NULL, displayTable);\n\n\tif (translationTable) {\n\t\t(*translationTable)->emphClassNames[0] = NULL;\n\t\t(*translationTable)->characterClasses = NULL;\n\t\t(*translationTable)->ruleNames = NULL;\n\t}\n\n\t/* Compile things that are necesary for the proper operation of\n\t * liblouis or liblouisxml or liblouisutdml */\n\t/* TODO: These definitions seem to be necessary for proper functioning of\n\t   liblouisutdml. Find a way to satisfy those requirements without hard coding\n\t   some characters in every table notably behind the users back */\n\tcompileString(\"space \\\\xffff 123456789abcdef LOU_ENDSEGMENT\", translationTable,\n\t\t\tdisplayTable);\n\n\tif (displayTable && translationTable && strcmp(tableList, displayTableList) == 0) {\n\t\t/* Compile the display and translation tables in one go */\n\n\t\t/* Compile all subtables in the list */\n\t\tif (!(tableFiles = _lou_resolveTable(tableList, NULL))) {\n\t\t\terrorCount++;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tfor (subTable = tableFiles; *subTable; subTable++)\n\t\t\tif (!compileFile(*subTable, translationTable, displayTable)) goto cleanup;\n\t} else {\n\t\t/* Compile the display and translation tables separately */\n\n\t\tif (displayTable) {\n\t\t\tif (!(tableFiles = _lou_resolveTable(displayTableList, NULL))) {\n\t\t\t\terrorCount++;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tfor (subTable = tableFiles; *subTable; subTable++)\n\t\t\t\tif (!compileFile(*subTable, NULL, displayTable)) goto cleanup;\n\t\t\tfree_tablefiles(tableFiles);\n\t\t\ttableFiles = NULL;\n\t\t}\n\t\tif (translationTable) {\n\t\t\tif (!(tableFiles = _lou_resolveTable(tableList, NULL))) {\n\t\t\t\terrorCount++;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tfor (subTable = tableFiles; *subTable; subTable++)\n\t\t\t\tif (!compileFile(*subTable, translationTable, NULL)) goto cleanup;\n\t\t}\n\t}\n\n/* Clean up after compiling files */\ncleanup:\n\tfree_tablefiles(tableFiles);\n\tif (warningCount) _lou_logMessage(LOU_LOG_WARN, \"%d warnings issued\", warningCount);\n\tif (!errorCount) {\n\t\tif (translationTable) setDefaults(*translationTable);\n\t\treturn 1;\n\t} else {\n\t\t_lou_logMessage(LOU_LOG_ERROR, \"%d errors found.\", errorCount);\n\t\tif (translationTable) {\n\t\t\tif (*translationTable) freeTranslationTable(*translationTable);\n\t\t\t*translationTable = NULL;\n\t\t}\n\t\tif (displayTable) {\n\t\t\tif (*displayTable) free(*displayTable);\n\t\t\t*displayTable = NULL;\n\t\t}\n\t\treturn 0;\n\t}\n}\n\n/* Return the emphasis classes declared in tableList. */\nchar const **EXPORT_CALL\nlou_getEmphClasses(const char *tableList) {\n\tconst char *names[MAX_EMPH_CLASSES + 1];\n\tunsigned int count = 0;\n\tconst TranslationTableHeader *table = _lou_getTranslationTable(tableList);\n\tif (!table) return NULL;\n\n\twhile (count < MAX_EMPH_CLASSES) {\n\t\tchar const *name = table->emphClassNames[count];\n\t\tif (!name) break;\n\t\tnames[count++] = name;\n\t}\n\tnames[count++] = NULL;\n\n\t{\n\t\tunsigned int size = count * sizeof(names[0]);\n\t\tchar const **result = malloc(size);\n\t\tif (!result) return NULL;\n\t\t/* The void* cast is necessary to stop MSVC from warning about\n\t\t * different 'const' qualifiers (C4090). */\n\t\tmemcpy((void *)result, names, size);\n\t\treturn result;\n\t}\n}\n\nvoid\ngetTable(const char *tableList, const char *displayTableList,\n\t\tTranslationTableHeader **translationTable, DisplayTableHeader **displayTable);\n\nvoid EXPORT_CALL\n_lou_getTable(const char *tableList, const char *displayTableList,\n\t\tconst TranslationTableHeader **translationTable,\n\t\tconst DisplayTableHeader **displayTable) {\n\tTranslationTableHeader *newTable;\n\tDisplayTableHeader *newDisplayTable;\n\tgetTable(tableList, displayTableList, &newTable, &newDisplayTable);\n\tif (newTable)\n\t\tif (!finalizeTable(newTable)) newTable = NULL;\n\t*translationTable = newTable;\n\t*displayTable = newDisplayTable;\n}\n\n/* Checks and loads tableList. */\nconst void *EXPORT_CALL\nlou_getTable(const char *tableList) {\n\tconst TranslationTableHeader *table;\n\tconst DisplayTableHeader *displayTable;\n\t_lou_getTable(tableList, tableList, &table, &displayTable);\n\tif (!table || !displayTable) return NULL;\n\treturn table;\n}\n\nconst TranslationTableHeader *EXPORT_CALL\n_lou_getTranslationTable(const char *tableList) {\n\tTranslationTableHeader *table;\n\tgetTable(tableList, NULL, &table, NULL);\n\tif (table)\n\t\tif (!finalizeTable(table)) table = NULL;\n\treturn table;\n}\n\nconst DisplayTableHeader *EXPORT_CALL\n_lou_getDisplayTable(const char *tableList) {\n\tDisplayTableHeader *table;\n\tgetTable(NULL, tableList, NULL, &table);\n\treturn table;\n}\n\nvoid\ngetTable(const char *translationTableList, const char *displayTableList,\n\t\tTranslationTableHeader **translationTable, DisplayTableHeader **displayTable) {\n\t/* Keep track of which tables have already been compiled */\n\tint translationTableListLen, displayTableListLen = 0;\n\tif (translationTableList == NULL || *translationTableList == 0)\n\t\ttranslationTable = NULL;\n\tif (displayTableList == NULL || *displayTableList == 0) displayTable = NULL;\n\t/* See if translation table has already been compiled */\n\tif (translationTable) {\n\t\ttranslationTableListLen = (int)strlen(translationTableList);\n\t\t*translationTable = NULL;\n\t\tTranslationTableChainEntry *currentEntry = translationTableChain;\n\t\tTranslationTableChainEntry *prevEntry = NULL;\n\t\twhile (currentEntry != NULL) {\n\t\t\tif (translationTableListLen == currentEntry->tableListLength &&\n\t\t\t\t\t(memcmp(&currentEntry->tableList[0], translationTableList,\n\t\t\t\t\t\t\ttranslationTableListLen)) == 0) {\n\t\t\t\t/* Move the table to the top of the table chain. */\n\t\t\t\tif (prevEntry != NULL) {\n\t\t\t\t\tprevEntry->next = currentEntry->next;\n\t\t\t\t\tcurrentEntry->next = translationTableChain;\n\t\t\t\t\ttranslationTableChain = currentEntry;\n\t\t\t\t}\n\t\t\t\t*translationTable = currentEntry->table;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tprevEntry = currentEntry;\n\t\t\tcurrentEntry = currentEntry->next;\n\t\t}\n\t}\n\t/* See if display table has already been compiled */\n\tif (displayTable) {\n\t\tdisplayTableListLen = (int)strlen(displayTableList);\n\t\t*displayTable = NULL;\n\t\tDisplayTableChainEntry *currentEntry = displayTableChain;\n\t\tDisplayTableChainEntry *prevEntry = NULL;\n\t\twhile (currentEntry != NULL) {\n\t\t\tif (displayTableListLen == currentEntry->tableListLength &&\n\t\t\t\t\t(memcmp(&currentEntry->tableList[0], displayTableList,\n\t\t\t\t\t\t\tdisplayTableListLen)) == 0) {\n\t\t\t\t/* Move the table to the top of the table chain. */\n\t\t\t\tif (prevEntry != NULL) {\n\t\t\t\t\tprevEntry->next = currentEntry->next;\n\t\t\t\t\tcurrentEntry->next = displayTableChain;\n\t\t\t\t\tdisplayTableChain = currentEntry;\n\t\t\t\t}\n\t\t\t\t*displayTable = currentEntry->table;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tprevEntry = currentEntry;\n\t\t\tcurrentEntry = currentEntry->next;\n\t\t}\n\t}\n\tif ((translationTable && *translationTable == NULL) ||\n\t\t\t(displayTable && *displayTable == NULL)) {\n\t\tTranslationTableHeader *newTranslationTable = NULL;\n\t\tDisplayTableHeader *newDisplayTable = NULL;\n\t\tif (compileTable(translationTableList, displayTableList,\n\t\t\t\t\t(translationTable && *translationTable == NULL) ? &newTranslationTable\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t: NULL,\n\t\t\t\t\t(displayTable && *displayTable == NULL) ? &newDisplayTable : NULL)) {\n\t\t\t/* Add a new entry to the top of the table chain. */\n\t\t\tif (newTranslationTable != NULL) {\n\t\t\t\tint entrySize =\n\t\t\t\t\t\tsizeof(TranslationTableChainEntry) + translationTableListLen;\n\t\t\t\tTranslationTableChainEntry *newEntry = malloc(entrySize);\n\t\t\t\tif (!newEntry) _lou_outOfMemory();\n\t\t\t\tnewEntry->next = translationTableChain;\n\t\t\t\tnewEntry->table = newTranslationTable;\n\t\t\t\tnewEntry->tableListLength = translationTableListLen;\n\t\t\t\tmemcpy(&newEntry->tableList[0], translationTableList,\n\t\t\t\t\t\ttranslationTableListLen);\n\t\t\t\ttranslationTableChain = newEntry;\n\t\t\t\t*translationTable = newTranslationTable;\n\t\t\t}\n\t\t\tif (newDisplayTable != NULL) {\n\t\t\t\tint entrySize = sizeof(DisplayTableChainEntry) + displayTableListLen;\n\t\t\t\tDisplayTableChainEntry *newEntry = malloc(entrySize);\n\t\t\t\tif (!newEntry) _lou_outOfMemory();\n\t\t\t\tnewEntry->next = displayTableChain;\n\t\t\t\tnewEntry->table = newDisplayTable;\n\t\t\t\tnewEntry->tableListLength = displayTableListLen;\n\t\t\t\tmemcpy(&newEntry->tableList[0], displayTableList, displayTableListLen);\n\t\t\t\tdisplayTableChain = newEntry;\n\t\t\t\t*displayTable = newDisplayTable;\n\t\t\t}\n\t\t} else {\n\t\t\t_lou_logMessage(\n\t\t\t\t\tLOU_LOG_ERROR, \"%s could not be compiled\", translationTableList);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nint EXPORT_CALL\nlou_checkTable(const char *tableList) {\n\tif (lou_getTable(tableList)) return 1;\n\treturn 0;\n}\n\nformtype EXPORT_CALL\nlou_getTypeformForEmphClass(const char *tableList, const char *emphClass) {\n\tconst TranslationTableHeader *table = _lou_getTranslationTable(tableList);\n\tif (!table) return 0;\n\tfor (int i = 0; i < MAX_EMPH_CLASSES && table->emphClassNames[i]; i++)\n\t\tif (strcmp(emphClass, table->emphClassNames[i]) == 0) return italic << i;\n\treturn 0;\n}\n\nstatic unsigned char *destSpacing = NULL;\nstatic int sizeDestSpacing = 0;\nstatic formtype *typebuf = NULL;\nstatic unsigned int *wordBuffer = NULL;\nstatic EmphasisInfo *emphasisBuffer = NULL;\nstatic int sizeTypebuf = 0;\nstatic widechar *passbuf[MAXPASSBUF] = { NULL };\nstatic int sizePassbuf[MAXPASSBUF] = { 0 };\nstatic int *posMapping1 = NULL;\nstatic int sizePosMapping1 = 0;\nstatic int *posMapping2 = NULL;\nstatic int sizePosMapping2 = 0;\nstatic int *posMapping3 = NULL;\nstatic int sizePosMapping3 = 0;\nvoid *EXPORT_CALL\n_lou_allocMem(AllocBuf buffer, int index, int srcmax, int destmax) {\n\tif (srcmax < 1024) srcmax = 1024;\n\tif (destmax < 1024) destmax = 1024;\n\tswitch (buffer) {\n\tcase alloc_typebuf:\n\t\tif (destmax > sizeTypebuf) {\n\t\t\tif (typebuf != NULL) free(typebuf);\n\t\t\t// TODO: should this be srcmax?\n\t\t\ttypebuf = malloc((destmax + 4) * sizeof(formtype));\n\t\t\tif (!typebuf) _lou_outOfMemory();\n\t\t\tsizeTypebuf = destmax;\n\t\t}\n\t\treturn typebuf;\n\n\tcase alloc_wordBuffer:\n\n\t\tif (wordBuffer != NULL) free(wordBuffer);\n\t\twordBuffer = calloc(srcmax + 4, sizeof(unsigned int));\n\t\tif (wordBuffer == NULL) _lou_outOfMemory();\n\t\treturn wordBuffer;\n\n\tcase alloc_emphasisBuffer:\n\n\t\tif (emphasisBuffer != NULL) free(emphasisBuffer);\n\t\temphasisBuffer = calloc(srcmax + 4, sizeof(EmphasisInfo));\n\t\tif (emphasisBuffer == NULL) _lou_outOfMemory();\n\t\treturn emphasisBuffer;\n\n\tcase alloc_destSpacing:\n\t\tif (destmax > sizeDestSpacing) {\n\t\t\tif (destSpacing != NULL) free(destSpacing);\n\t\t\tdestSpacing = malloc(destmax + 4);\n\t\t\tif (!destSpacing) _lou_outOfMemory();\n\t\t\tsizeDestSpacing = destmax;\n\t\t}\n\t\treturn destSpacing;\n\tcase alloc_passbuf:\n\t\tif (index < 0 || index >= MAXPASSBUF) {\n\t\t\t_lou_logMessage(LOU_LOG_FATAL, \"Index out of bounds: %d\\n\", index);\n\t\t\texit(3);\n\t\t}\n\t\tif (destmax > sizePassbuf[index]) {\n\t\t\tif (passbuf[index] != NULL) free(passbuf[index]);\n\t\t\tpassbuf[index] = malloc((destmax + 4) * CHARSIZE);\n\t\t\tif (!passbuf[index]) _lou_outOfMemory();\n\t\t\tsizePassbuf[index] = destmax;\n\t\t}\n\t\treturn passbuf[index];\n\tcase alloc_posMapping1: {\n\t\tint mapSize;\n\t\tif (srcmax >= destmax)\n\t\t\tmapSize = srcmax;\n\t\telse\n\t\t\tmapSize = destmax;\n\t\tif (mapSize > sizePosMapping1) {\n\t\t\tif (posMapping1 != NULL) free(posMapping1);\n\t\t\tposMapping1 = malloc((mapSize + 4) * sizeof(int));\n\t\t\tif (!posMapping1) _lou_outOfMemory();\n\t\t\tsizePosMapping1 = mapSize;\n\t\t}\n\t}\n\t\treturn posMapping1;\n\tcase alloc_posMapping2: {\n\t\tint mapSize;\n\t\tif (srcmax >= destmax)\n\t\t\tmapSize = srcmax;\n\t\telse\n\t\t\tmapSize = destmax;\n\t\tif (mapSize > sizePosMapping2) {\n\t\t\tif (posMapping2 != NULL) free(posMapping2);\n\t\t\tposMapping2 = malloc((mapSize + 4) * sizeof(int));\n\t\t\tif (!posMapping2) _lou_outOfMemory();\n\t\t\tsizePosMapping2 = mapSize;\n\t\t}\n\t}\n\t\treturn posMapping2;\n\tcase alloc_posMapping3: {\n\t\tint mapSize;\n\t\tif (srcmax >= destmax)\n\t\t\tmapSize = srcmax;\n\t\telse\n\t\t\tmapSize = destmax;\n\t\tif (mapSize > sizePosMapping3) {\n\t\t\tif (posMapping3 != NULL) free(posMapping3);\n\t\t\tposMapping3 = malloc((mapSize + 4) * sizeof(int));\n\t\t\tif (!posMapping3) _lou_outOfMemory();\n\t\t\tsizePosMapping3 = mapSize;\n\t\t}\n\t}\n\t\treturn posMapping3;\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\nvoid EXPORT_CALL\nlou_free(void) {\n\tTranslationTableChainEntry *currentEntry;\n\tTranslationTableChainEntry *previousEntry;\n\tlou_logEnd();\n\tif (translationTableChain != NULL) {\n\t\tcurrentEntry = translationTableChain;\n\t\twhile (currentEntry) {\n\t\t\tfreeTranslationTable(currentEntry->table);\n\t\t\tpreviousEntry = currentEntry;\n\t\t\tcurrentEntry = currentEntry->next;\n\t\t\tfree(previousEntry);\n\t\t}\n\t\ttranslationTableChain = NULL;\n\t}\n\tif (typebuf != NULL) free(typebuf);\n\ttypebuf = NULL;\n\tif (wordBuffer != NULL) free(wordBuffer);\n\twordBuffer = NULL;\n\tif (emphasisBuffer != NULL) free(emphasisBuffer);\n\temphasisBuffer = NULL;\n\tsizeTypebuf = 0;\n\tif (destSpacing != NULL) free(destSpacing);\n\tdestSpacing = NULL;\n\tsizeDestSpacing = 0;\n\t{\n\t\tint k;\n\t\tfor (k = 0; k < MAXPASSBUF; k++) {\n\t\t\tif (passbuf[k] != NULL) free(passbuf[k]);\n\t\t\tpassbuf[k] = NULL;\n\t\t\tsizePassbuf[k] = 0;\n\t\t}\n\t}\n\tif (posMapping1 != NULL) free(posMapping1);\n\tposMapping1 = NULL;\n\tsizePosMapping1 = 0;\n\tif (posMapping2 != NULL) free(posMapping2);\n\tposMapping2 = NULL;\n\tsizePosMapping2 = 0;\n\tif (posMapping3 != NULL) free(posMapping3);\n\tposMapping3 = NULL;\n\tsizePosMapping3 = 0;\n\topcodeLengths[0] = 0;\n}\n\nconst char *EXPORT_CALL\nlou_version(void) {\n\tstatic const char *version = PACKAGE_VERSION;\n\treturn version;\n}\n\nint EXPORT_CALL\nlou_charSize(void) {\n\treturn CHARSIZE;\n}\n\nint EXPORT_CALL\nlou_compileString(const char *tableList, const char *inString) {\n\tTranslationTableHeader *table;\n\tDisplayTableHeader *displayTable;\n\tgetTable(tableList, tableList, &table, &displayTable);\n\tif (!table) return 0;\n\tif (!compileString(inString, &table, &displayTable)) return 0;\n\treturn 1;\n}\n\nint EXPORT_CALL\n_lou_compileTranslationRule(const char *tableList, const char *inString) {\n\tTranslationTableHeader *table;\n\tgetTable(tableList, NULL, &table, NULL);\n\treturn compileString(inString, &table, NULL);\n}\n\nint EXPORT_CALL\n_lou_compileDisplayRule(const char *tableList, const char *inString) {\n\tDisplayTableHeader *table;\n\tgetTable(NULL, tableList, NULL, &table);\n\treturn compileString(inString, NULL, &table);\n}\n\n/**\n * This procedure provides a target for cals that serve as breakpoints\n * for gdb.\n */\n// char *EXPORT_CALL\n// lou_getTablePaths (void)\n// {\n//   static char paths[MAXSTRING];\n//   static char scratchBuf[MAXSTRING];\n//   char *pathList;\n//   strcpy (paths, tablePath);\n//   strcat (paths, \",\");\n//   pathList = getenv (\"LOUIS_TABLEPATH\");\n//   if (pathList)\n//     {\n//       strcat (paths, pathList);\n//       strcat (paths, \",\");\n//     }\n//   pathList = getcwd (scratchBuf, MAXSTRING);\n//   if (pathList)\n//     {\n//       strcat (paths, pathList);\n//       strcat (paths, \",\");\n//     }\n//   pathList = lou_getDataPath ();\n//   if (pathList)\n//     {\n//       strcat (paths, pathList);\n//       strcat (paths, \",\");\n//     }\n// #ifdef _WIN32\n//   strcpy (paths, lou_getProgramPath ());\n//   strcat (paths, \"\\\\share\\\\liblouss\\\\tables\\\\\");\n// #else\n//   strcpy (paths, TABLESDIR);\n// #endif\n//   return paths;\n// }\n"], "fixing_code": ["/* liblouis Braille Translation and Back-Translation Library\n\n   Based on the Linux screenreader BRLTTY, copyright (C) 1999-2006 by The\n   BRLTTY Team\n\n   Copyright (C) 2004, 2005, 2006 ViewPlus Technologies, Inc. www.viewplus.com\n   Copyright (C) 2004, 2005, 2006 JJB Software, Inc. www.jjb-software.com\n   Copyright (C) 2016 Mike Gray, American Printing House for the Blind\n   Copyright (C) 2016 Davy Kager, Dedicon\n\n   This file is part of liblouis.\n\n   liblouis is free software: you can redistribute it and/or modify it\n   under the terms of the GNU Lesser General Public License as published\n   by the Free Software Foundation, either version 2.1 of the License, or\n   (at your option) any later version.\n\n   liblouis is distributed in the hope that it will be useful, but\n   WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n   Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public\n   License along with liblouis. If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/**\n * @file\n * @brief Read and compile translation tables\n */\n\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <ctype.h>\n#include <sys/stat.h>\n\n#include \"internal.h\"\n#include \"config.h\"\n\n#define QUOTESUB 28 /* Stand-in for double quotes in strings */\n\n/* needed to make debuggin easier */\n#ifdef DEBUG\nwchar_t wchar;\n#endif\n\n/* The following variables and functions make it possible to specify the\n * path on which all tables for liblouis and all files for liblouisutdml,\n * in their proper directories, will be found.\n */\n\nstatic char *dataPathPtr;\n\nchar *EXPORT_CALL\nlou_setDataPath(const char *path) {\n\tstatic char dataPath[MAXSTRING];\n\tdataPathPtr = NULL;\n\tif (path == NULL) return NULL;\n\tstrcpy(dataPath, path);\n\tdataPathPtr = dataPath;\n\treturn dataPathPtr;\n}\n\nchar *EXPORT_CALL\nlou_getDataPath(void) {\n\treturn dataPathPtr;\n}\n\n/* End of dataPath code. */\n\nstatic int\neqasc2uni(const unsigned char *a, const widechar *b, const int len) {\n\tint k;\n\tfor (k = 0; k < len; k++)\n\t\tif ((widechar)a[k] != b[k]) return 0;\n\treturn 1;\n}\n\ntypedef struct CharsString {\n\twidechar length;\n\twidechar chars[MAXSTRING];\n} CharsString;\n\nstatic int errorCount;\nstatic int warningCount;\n\ntypedef struct TranslationTableChainEntry {\n\tstruct TranslationTableChainEntry *next;\n\tTranslationTableHeader *table;\n\tint tableListLength;\n\tchar tableList[1];\n} TranslationTableChainEntry;\n\nstatic TranslationTableChainEntry *translationTableChain = NULL;\n\ntypedef struct DisplayTableChainEntry {\n\tstruct DisplayTableChainEntry *next;\n\tDisplayTableHeader *table;\n\tint tableListLength;\n\tchar tableList[1];\n} DisplayTableChainEntry;\n\nstatic DisplayTableChainEntry *displayTableChain = NULL;\n\n/* predefined character classes */\nstatic const char *characterClassNames[] = {\n\t\"space\",\n\t\"letter\",\n\t\"digit\",\n\t\"punctuation\",\n\t\"uppercase\",\n\t\"lowercase\",\n\t\"math\",\n\t\"sign\",\n\t\"litdigit\",\n\tNULL,\n};\n\n// names that may not be used for custom attributes\nstatic const char *reservedAttributeNames[] = {\n\t\"numericnocontchars\",\n\t\"numericnocontchar\",\n\t\"numericnocont\",\n\t\"midendnumericmodechars\",\n\t\"midendnumericmodechar\",\n\t\"midendnumericmode\",\n\t\"numericmodechars\",\n\t\"numericmodechar\",\n\t\"numericmode\",\n\t\"capsmodechars\",\n\t\"capsmodechar\",\n\t\"capsmode\",\n\t\"emphmodechars\",\n\t\"emphmodechar\",\n\t\"emphmode\",\n\t\"noemphchars\",\n\t\"noemphchar\",\n\t\"noemph\",\n\t\"seqdelimiter\",\n\t\"seqbeforechars\",\n\t\"seqbeforechar\",\n\t\"seqbefore\",\n\t\"seqafterchars\",\n\t\"seqafterchar\",\n\t\"seqafter\",\n\t\"noletsign\",\n\t\"noletsignbefore\",\n\t\"noletsignafter\",\n\tNULL,\n};\n\nstatic const char *opcodeNames[CTO_None] = {\n\t\"include\",\n\t\"locale\",\n\t\"undefined\",\n\t\"capsletter\",\n\t\"begcapsword\",\n\t\"endcapsword\",\n\t\"begcaps\",\n\t\"endcaps\",\n\t\"begcapsphrase\",\n\t\"endcapsphrase\",\n\t\"lencapsphrase\",\n\t\"modeletter\",\n\t\"begmodeword\",\n\t\"endmodeword\",\n\t\"begmode\",\n\t\"endmode\",\n\t\"begmodephrase\",\n\t\"endmodephrase\",\n\t\"lenmodephrase\",\n\t\"letsign\",\n\t\"noletsignbefore\",\n\t\"noletsign\",\n\t\"noletsignafter\",\n\t\"numsign\",\n\t\"numericmodechars\",\n\t\"midendnumericmodechars\",\n\t\"numericnocontchars\",\n\t\"seqdelimiter\",\n\t\"seqbeforechars\",\n\t\"seqafterchars\",\n\t\"seqafterpattern\",\n\t\"seqafterexpression\",\n\t\"emphclass\",\n\t\"emphletter\",\n\t\"begemphword\",\n\t\"endemphword\",\n\t\"begemph\",\n\t\"endemph\",\n\t\"begemphphrase\",\n\t\"endemphphrase\",\n\t\"lenemphphrase\",\n\t\"capsmodechars\",\n\t\"emphmodechars\",\n\t\"noemphchars\",\n\t\"begcomp\",\n\t\"endcomp\",\n\t\"nocontractsign\",\n\t\"multind\",\n\t\"compdots\",\n\t\"comp6\",\n\t\"class\",\n\t\"after\",\n\t\"before\",\n\t\"noback\",\n\t\"nofor\",\n\t\"empmatchbefore\",\n\t\"empmatchafter\",\n\t\"swapcc\",\n\t\"swapcd\",\n\t\"swapdd\",\n\t\"space\",\n\t\"digit\",\n\t\"punctuation\",\n\t\"math\",\n\t\"sign\",\n\t\"letter\",\n\t\"uppercase\",\n\t\"lowercase\",\n\t\"grouping\",\n\t\"uplow\",\n\t\"litdigit\",\n\t\"display\",\n\t\"replace\",\n\t\"context\",\n\t\"correct\",\n\t\"pass2\",\n\t\"pass3\",\n\t\"pass4\",\n\t\"repeated\",\n\t\"repword\",\n\t\"rependword\",\n\t\"capsnocont\",\n\t\"always\",\n\t\"exactdots\",\n\t\"nocross\",\n\t\"syllable\",\n\t\"nocont\",\n\t\"compbrl\",\n\t\"literal\",\n\t\"largesign\",\n\t\"word\",\n\t\"partword\",\n\t\"joinnum\",\n\t\"joinword\",\n\t\"lowword\",\n\t\"contraction\",\n\t\"sufword\",\n\t\"prfword\",\n\t\"begword\",\n\t\"begmidword\",\n\t\"midword\",\n\t\"midendword\",\n\t\"endword\",\n\t\"prepunc\",\n\t\"postpunc\",\n\t\"begnum\",\n\t\"midnum\",\n\t\"endnum\",\n\t\"decpoint\",\n\t\"hyphen\",\n\t// \"apostrophe\",\n\t// \"initial\",\n\t\"nobreak\",\n\t\"match\",\n\t\"backmatch\",\n\t\"attribute\",\n\t\"base\",\n\t\"macro\",\n};\n\nstatic short opcodeLengths[CTO_None] = { 0 };\n\nstatic void\ncompileError(const FileInfo *file, const char *format, ...);\n\nstatic void\nfree_tablefiles(char **tables);\n\nstatic int\ngetAChar(FileInfo *file) {\n\t/* Read a big endian, little endian or ASCII 8 file and convert it to\n\t * 16- or 32-bit unsigned integers */\n\tint ch1 = 0, ch2 = 0;\n\twidechar character;\n\tif (file->encoding == ascii8)\n\t\tif (file->status == 2) {\n\t\t\tfile->status++;\n\t\t\treturn file->checkencoding[1];\n\t\t}\n\twhile ((ch1 = fgetc(file->in)) != EOF) {\n\t\tif (file->status < 2) file->checkencoding[file->status] = ch1;\n\t\tfile->status++;\n\t\tif (file->status == 2) {\n\t\t\tif (file->checkencoding[0] == 0xfe && file->checkencoding[1] == 0xff)\n\t\t\t\tfile->encoding = bigEndian;\n\t\t\telse if (file->checkencoding[0] == 0xff && file->checkencoding[1] == 0xfe)\n\t\t\t\tfile->encoding = littleEndian;\n\t\t\telse if (file->checkencoding[0] < 128 && file->checkencoding[1] < 128) {\n\t\t\t\tfile->encoding = ascii8;\n\t\t\t\treturn file->checkencoding[0];\n\t\t\t} else {\n\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\"encoding is neither big-endian, little-endian nor ASCII 8.\");\n\t\t\t\tch1 = EOF;\n\t\t\t\tbreak;\n\t\t\t\t;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tswitch (file->encoding) {\n\t\tcase noEncoding:\n\t\t\tbreak;\n\t\tcase ascii8:\n\t\t\treturn ch1;\n\t\t\tbreak;\n\t\tcase bigEndian:\n\t\t\tch2 = fgetc(file->in);\n\t\t\tif (ch2 == EOF) break;\n\t\t\tcharacter = (widechar)(ch1 << 8) | ch2;\n\t\t\treturn (int)character;\n\t\t\tbreak;\n\t\tcase littleEndian:\n\t\t\tch2 = fgetc(file->in);\n\t\t\tif (ch2 == EOF) break;\n\t\t\tcharacter = (widechar)(ch2 << 8) | ch1;\n\t\t\treturn (int)character;\n\t\t\tbreak;\n\t\t}\n\t\tif (ch1 == EOF || ch2 == EOF) break;\n\t}\n\treturn EOF;\n}\n\nint EXPORT_CALL\n_lou_getALine(FileInfo *file) {\n\t/* Read a line of widechar's from an input file */\n\tint ch;\n\tint pch = 0;\n\tfile->linelen = 0;\n\twhile ((ch = getAChar(file)) != EOF) {\n\t\tif (ch == 13) continue;\n\t\tif (pch == '\\\\' && ch == 10) {\n\t\t\tfile->linelen--;\n\t\t\tpch = ch;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ch == 10 || file->linelen >= MAXSTRING - 1) break;\n\t\tfile->line[file->linelen++] = (widechar)ch;\n\t\tpch = ch;\n\t}\n\tfile->line[file->linelen] = 0;\n\tfile->linepos = 0;\n\tif (ch == EOF && !file->linelen) return 0;\n\tfile->lineNumber++;\n\treturn 1;\n}\n\nstatic inline int\natEndOfLine(const FileInfo *file) {\n\treturn file->linepos >= file->linelen;\n}\n\nstatic inline int\natTokenDelimiter(const FileInfo *file) {\n\treturn file->line[file->linepos] <= 32;\n}\n\nstatic int\ngetToken(FileInfo *file, CharsString *result, const char *description) {\n\t/* Find the next string of contiguous non-whitespace characters. If this\n\t * is the last token on the line, return 2 instead of 1. */\n\twhile (!atEndOfLine(file) && atTokenDelimiter(file)) file->linepos++;\n\tresult->length = 0;\n\twhile (!atEndOfLine(file) && !atTokenDelimiter(file)) {\n\t\tint maxlen = MAXSTRING;\n\t\tif (result->length >= maxlen) {\n\t\t\tcompileError(file, \"more than %d characters (bytes)\", maxlen);\n\t\t\treturn 0;\n\t\t} else\n\t\t\tresult->chars[result->length++] = file->line[file->linepos++];\n\t}\n\tif (!result->length) {\n\t\t/* Not enough tokens */\n\t\tif (description) compileError(file, \"%s not specified.\", description);\n\t\treturn 0;\n\t}\n\tresult->chars[result->length] = 0;\n\twhile (!atEndOfLine(file) && atTokenDelimiter(file)) file->linepos++;\n\treturn 1;\n}\n\nstatic void\ncompileError(const FileInfo *file, const char *format, ...) {\n#ifndef __SYMBIAN32__\n\tchar buffer[MAXSTRING];\n\tva_list arguments;\n\tva_start(arguments, format);\n\tvsnprintf(buffer, sizeof(buffer), format, arguments);\n\tva_end(arguments);\n\tif (file)\n\t\t_lou_logMessage(LOU_LOG_ERROR, \"%s:%d: error: %s\", file->fileName,\n\t\t\t\tfile->lineNumber, buffer);\n\telse\n\t\t_lou_logMessage(LOU_LOG_ERROR, \"error: %s\", buffer);\n\terrorCount++;\n#endif\n}\n\nstatic void\ncompileWarning(const FileInfo *file, const char *format, ...) {\n#ifndef __SYMBIAN32__\n\tchar buffer[MAXSTRING];\n\tva_list arguments;\n\tva_start(arguments, format);\n\tvsnprintf(buffer, sizeof(buffer), format, arguments);\n\tva_end(arguments);\n\tif (file)\n\t\t_lou_logMessage(LOU_LOG_WARN, \"%s:%d: warning: %s\", file->fileName,\n\t\t\t\tfile->lineNumber, buffer);\n\telse\n\t\t_lou_logMessage(LOU_LOG_WARN, \"warning: %s\", buffer);\n\twarningCount++;\n#endif\n}\n\nstatic int\nallocateSpaceInTranslationTable(const FileInfo *file, TranslationTableOffset *offset,\n\t\tint size, TranslationTableHeader **table) {\n\t/* allocate memory for table and expand previously allocated memory if necessary */\n\tint spaceNeeded = ((size + OFFSETSIZE - 1) / OFFSETSIZE) * OFFSETSIZE;\n\tTranslationTableOffset newTableSize = (*table)->bytesUsed + spaceNeeded;\n\tTranslationTableOffset tableSize = (*table)->tableSize;\n\tif (newTableSize > tableSize) {\n\t\tTranslationTableHeader *newTable;\n\t\tnewTableSize += (newTableSize / OFFSETSIZE);\n\t\tnewTable = realloc(*table, newTableSize);\n\t\tif (!newTable) {\n\t\t\tcompileError(file, \"Not enough memory for translation table.\");\n\t\t\t_lou_outOfMemory();\n\t\t}\n\t\tmemset(((unsigned char *)newTable) + tableSize, 0, newTableSize - tableSize);\n\t\t/* update references to the old table */\n\t\t{\n\t\t\tTranslationTableChainEntry *entry;\n\t\t\tfor (entry = translationTableChain; entry != NULL; entry = entry->next)\n\t\t\t\tif (entry->table == *table)\n\t\t\t\t\tentry->table = (TranslationTableHeader *)newTable;\n\t\t}\n\t\tnewTable->tableSize = newTableSize;\n\t\t*table = newTable;\n\t}\n\tif (offset != NULL) {\n\t\t*offset = ((*table)->bytesUsed - sizeof(**table)) / OFFSETSIZE;\n\t\t(*table)->bytesUsed += spaceNeeded;\n\t}\n\treturn 1;\n}\n\nstatic int\nallocateSpaceInDisplayTable(const FileInfo *file, TranslationTableOffset *offset,\n\t\tint size, DisplayTableHeader **table) {\n\t/* allocate memory for table and expand previously allocated memory if necessary */\n\tint spaceNeeded = ((size + OFFSETSIZE - 1) / OFFSETSIZE) * OFFSETSIZE;\n\tTranslationTableOffset newTableSize = (*table)->bytesUsed + spaceNeeded;\n\tTranslationTableOffset tableSize = (*table)->tableSize;\n\tif (newTableSize > tableSize) {\n\t\tDisplayTableHeader *newTable;\n\t\tnewTableSize += (newTableSize / OFFSETSIZE);\n\t\tnewTable = realloc(*table, newTableSize);\n\t\tif (!newTable) {\n\t\t\tcompileError(file, \"Not enough memory for display table.\");\n\t\t\t_lou_outOfMemory();\n\t\t}\n\t\tmemset(((unsigned char *)newTable) + tableSize, 0, newTableSize - tableSize);\n\t\t/* update references to the old table */\n\t\t{\n\t\t\tDisplayTableChainEntry *entry;\n\t\t\tfor (entry = displayTableChain; entry != NULL; entry = entry->next)\n\t\t\t\tif (entry->table == *table) entry->table = (DisplayTableHeader *)newTable;\n\t\t}\n\t\tnewTable->tableSize = newTableSize;\n\t\t*table = newTable;\n\t}\n\tif (offset != NULL) {\n\t\t*offset = ((*table)->bytesUsed - sizeof(**table)) / OFFSETSIZE;\n\t\t(*table)->bytesUsed += spaceNeeded;\n\t}\n\treturn 1;\n}\n\nstatic int\nallocateTranslationTable(const FileInfo *file, TranslationTableHeader **table) {\n\t/* Allocate memory for the table and a guess on the number of rules */\n\tconst TranslationTableOffset startSize = 2 * sizeof(**table);\n\tif (*table) return 1;\n\tTranslationTableOffset bytesUsed =\n\t\t\tsizeof(**table) + OFFSETSIZE; /* So no offset is ever zero */\n\tif (!(*table = malloc(startSize))) {\n\t\tcompileError(file, \"Not enough memory\");\n\t\tif (*table != NULL) free(*table);\n\t\t*table = NULL;\n\t\t_lou_outOfMemory();\n\t}\n\tmemset(*table, 0, startSize);\n\t(*table)->tableSize = startSize;\n\t(*table)->bytesUsed = bytesUsed;\n\treturn 1;\n}\n\nstatic int\nallocateDisplayTable(const FileInfo *file, DisplayTableHeader **table) {\n\t/* Allocate memory for the table and a guess on the number of rules */\n\tconst TranslationTableOffset startSize = 2 * sizeof(**table);\n\tif (*table) return 1;\n\tTranslationTableOffset bytesUsed =\n\t\t\tsizeof(**table) + OFFSETSIZE; /* So no offset is ever zero */\n\tif (!(*table = malloc(startSize))) {\n\t\tcompileError(file, \"Not enough memory\");\n\t\tif (*table != NULL) free(*table);\n\t\t*table = NULL;\n\t\t_lou_outOfMemory();\n\t}\n\tmemset(*table, 0, startSize);\n\t(*table)->tableSize = startSize;\n\t(*table)->bytesUsed = bytesUsed;\n\treturn 1;\n}\n\n/* Look up a character or dot pattern. Although the algorithms are almost identical,\n * different tables are needed for characters and dots because of the possibility of\n * conflicts. */\n\nstatic TranslationTableCharacter *\ngetChar(widechar c, TranslationTableHeader *table,\n\t\tTranslationTableOffset *characterOffset) {\n\tconst TranslationTableOffset bucket = table->characters[_lou_charHash(c)];\n\tTranslationTableOffset offset = bucket;\n\twhile (offset) {\n\t\tTranslationTableCharacter *character =\n\t\t\t\t(TranslationTableCharacter *)&table->ruleArea[offset];\n\t\tif (character->value == c) {\n\t\t\tif (characterOffset) *characterOffset = offset;\n\t\t\treturn character;\n\t\t}\n\t\toffset = character->next;\n\t}\n\treturn NULL;\n}\n\nstatic TranslationTableCharacter *\ngetDots(widechar d, TranslationTableHeader *table) {\n\tconst TranslationTableOffset bucket = table->dots[_lou_charHash(d)];\n\tTranslationTableOffset offset = bucket;\n\twhile (offset) {\n\t\tTranslationTableCharacter *character =\n\t\t\t\t(TranslationTableCharacter *)&table->ruleArea[offset];\n\t\tif (character->value == d) return character;\n\t\toffset = character->next;\n\t}\n\treturn NULL;\n}\n\nstatic TranslationTableCharacter *\nputChar(const FileInfo *file, widechar c, TranslationTableHeader **table,\n\t\tTranslationTableOffset *characterOffset) {\n\t/* See if a character is in the appropriate table. If not, insert it. In either case,\n\t * return a pointer to it. */\n\tTranslationTableCharacter *character;\n\tTranslationTableOffset offset;\n\tif ((character = getChar(c, *table, characterOffset))) return character;\n\tif (!allocateSpaceInTranslationTable(file, &offset, sizeof(*character), table))\n\t\treturn NULL;\n\tcharacter = (TranslationTableCharacter *)&(*table)->ruleArea[offset];\n\tmemset(character, 0, sizeof(*character));\n\tcharacter->sourceFile = file->sourceFile;\n\tcharacter->sourceLine = file->lineNumber;\n\tcharacter->value = c;\n\tconst unsigned long int charHash = _lou_charHash(c);\n\tconst TranslationTableOffset bucket = (*table)->characters[charHash];\n\tif (!bucket)\n\t\t(*table)->characters[charHash] = offset;\n\telse {\n\t\tTranslationTableCharacter *oldchar =\n\t\t\t\t(TranslationTableCharacter *)&(*table)->ruleArea[bucket];\n\t\twhile (oldchar->next)\n\t\t\toldchar = (TranslationTableCharacter *)&(*table)->ruleArea[oldchar->next];\n\t\toldchar->next = offset;\n\t}\n\tif (characterOffset) *characterOffset = offset;\n\treturn character;\n}\n\nstatic TranslationTableCharacter *\nputDots(const FileInfo *file, widechar d, TranslationTableHeader **table) {\n\t/* See if a dot pattern is in the appropriate table. If not, insert it. In either\n\t * case, return a pointer to it. */\n\tTranslationTableCharacter *character;\n\tTranslationTableOffset offset;\n\tif ((character = getDots(d, *table))) return character;\n\tif (!allocateSpaceInTranslationTable(file, &offset, sizeof(*character), table))\n\t\treturn NULL;\n\tcharacter = (TranslationTableCharacter *)&(*table)->ruleArea[offset];\n\tmemset(character, 0, sizeof(*character));\n\tcharacter->sourceFile = file->sourceFile;\n\tcharacter->sourceLine = file->lineNumber;\n\tcharacter->value = d;\n\tconst unsigned long int charHash = _lou_charHash(d);\n\tconst TranslationTableOffset bucket = (*table)->dots[charHash];\n\tif (!bucket)\n\t\t(*table)->dots[charHash] = offset;\n\telse {\n\t\tTranslationTableCharacter *oldchar =\n\t\t\t\t(TranslationTableCharacter *)&(*table)->ruleArea[bucket];\n\t\twhile (oldchar->next)\n\t\t\toldchar = (TranslationTableCharacter *)&(*table)->ruleArea[oldchar->next];\n\t\toldchar->next = offset;\n\t}\n\treturn character;\n}\n\n/* Look up a character-dots mapping in a display table. */\n\nstatic CharDotsMapping *\ngetDotsForChar(widechar c, const DisplayTableHeader *table) {\n\tCharDotsMapping *cdPtr;\n\tconst TranslationTableOffset bucket = table->charToDots[_lou_charHash(c)];\n\tTranslationTableOffset offset = bucket;\n\twhile (offset) {\n\t\tcdPtr = (CharDotsMapping *)&table->ruleArea[offset];\n\t\tif (cdPtr->lookFor == c) return cdPtr;\n\t\toffset = cdPtr->next;\n\t}\n\treturn NULL;\n}\n\nstatic CharDotsMapping *\ngetCharForDots(widechar d, const DisplayTableHeader *table) {\n\tCharDotsMapping *cdPtr;\n\tconst TranslationTableOffset bucket = table->dotsToChar[_lou_charHash(d)];\n\tTranslationTableOffset offset = bucket;\n\twhile (offset) {\n\t\tcdPtr = (CharDotsMapping *)&table->ruleArea[offset];\n\t\tif (cdPtr->lookFor == d) return cdPtr;\n\t\toffset = cdPtr->next;\n\t}\n\treturn NULL;\n}\n\nwidechar EXPORT_CALL\n_lou_getDotsForChar(widechar c, const DisplayTableHeader *table) {\n\tCharDotsMapping *cdPtr = getDotsForChar(c, table);\n\tif (cdPtr) return cdPtr->found;\n\treturn LOU_DOTS;\n}\n\nwidechar EXPORT_CALL\n_lou_getCharForDots(widechar d, const DisplayTableHeader *table) {\n\tCharDotsMapping *cdPtr = getCharForDots(d, table);\n\tif (cdPtr) return cdPtr->found;\n\treturn '\\0';\n}\n\nstatic int\nputCharDotsMapping(\n\t\tconst FileInfo *file, widechar c, widechar d, DisplayTableHeader **table) {\n\tif (!getDotsForChar(c, *table)) {\n\t\tCharDotsMapping *cdPtr;\n\t\tTranslationTableOffset offset;\n\t\tif (!allocateSpaceInDisplayTable(file, &offset, sizeof(*cdPtr), table)) return 0;\n\t\tcdPtr = (CharDotsMapping *)&(*table)->ruleArea[offset];\n\t\tcdPtr->next = 0;\n\t\tcdPtr->lookFor = c;\n\t\tcdPtr->found = d;\n\t\tconst unsigned long int charHash = _lou_charHash(c);\n\t\tconst TranslationTableOffset bucket = (*table)->charToDots[charHash];\n\t\tif (!bucket)\n\t\t\t(*table)->charToDots[charHash] = offset;\n\t\telse {\n\t\t\tCharDotsMapping *oldcdPtr = (CharDotsMapping *)&(*table)->ruleArea[bucket];\n\t\t\twhile (oldcdPtr->next)\n\t\t\t\toldcdPtr = (CharDotsMapping *)&(*table)->ruleArea[oldcdPtr->next];\n\t\t\toldcdPtr->next = offset;\n\t\t}\n\t}\n\tif (!getCharForDots(d, *table)) {\n\t\tCharDotsMapping *cdPtr;\n\t\tTranslationTableOffset offset;\n\t\tif (!allocateSpaceInDisplayTable(file, &offset, sizeof(*cdPtr), table)) return 0;\n\t\tcdPtr = (CharDotsMapping *)&(*table)->ruleArea[offset];\n\t\tcdPtr->next = 0;\n\t\tcdPtr->lookFor = d;\n\t\tcdPtr->found = c;\n\t\tconst unsigned long int charHash = _lou_charHash(d);\n\t\tconst TranslationTableOffset bucket = (*table)->dotsToChar[charHash];\n\t\tif (!bucket)\n\t\t\t(*table)->dotsToChar[charHash] = offset;\n\t\telse {\n\t\t\tCharDotsMapping *oldcdPtr = (CharDotsMapping *)&(*table)->ruleArea[bucket];\n\t\t\twhile (oldcdPtr->next)\n\t\t\t\toldcdPtr = (CharDotsMapping *)&(*table)->ruleArea[oldcdPtr->next];\n\t\t\toldcdPtr->next = offset;\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic inline const char *\ngetPartName(int actionPart) {\n\treturn actionPart ? \"action\" : \"test\";\n}\n\nstatic int\npassFindCharacters(const FileInfo *file, widechar *instructions, int end,\n\t\twidechar **characters, int *length) {\n\tint IC = 0;\n\tint lookback = 0;\n\n\t*characters = NULL;\n\t*length = 0;\n\n\twhile (IC < end) {\n\t\twidechar instruction = instructions[IC];\n\n\t\tswitch (instruction) {\n\t\tcase pass_string:\n\t\tcase pass_dots: {\n\t\t\tint count = instructions[IC + 1];\n\t\t\tIC += 2;\n\t\t\tif (count > lookback) {\n\t\t\t\t*characters = &instructions[IC + lookback];\n\t\t\t\t*length = count - lookback;\n\t\t\t\treturn 1;\n\t\t\t} else {\n\t\t\t\tlookback -= count;\n\t\t\t}\n\t\t\tIC += count;\n\t\t\tcontinue;\n\t\t}\n\n\t\tcase pass_attributes:\n\t\t\tIC += 7;\n\t\t\tif (instructions[IC - 2] == instructions[IC - 1] &&\n\t\t\t\t\tinstructions[IC - 1] <= lookback) {\n\t\t\t\tlookback -= instructions[IC - 1];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tgoto NO_CHARACTERS;\n\n\t\tcase pass_swap:\n\t\t\tIC += 2;\n\t\t\t/* fall through */\n\n\t\tcase pass_groupstart:\n\t\tcase pass_groupend:\n\t\tcase pass_groupreplace:\n\t\t\tIC += 3;\n\n\t\tNO_CHARACTERS : { return 1; }\n\n\t\tcase pass_eq:\n\t\tcase pass_lt:\n\t\tcase pass_gt:\n\t\tcase pass_lteq:\n\t\tcase pass_gteq:\n\t\t\tIC += 3;\n\t\t\tcontinue;\n\n\t\tcase pass_lookback:\n\t\t\tlookback += instructions[IC + 1];\n\t\t\tIC += 2;\n\t\t\tcontinue;\n\n\t\tcase pass_not:\n\t\tcase pass_startReplace:\n\t\tcase pass_endReplace:\n\t\tcase pass_first:\n\t\tcase pass_last:\n\t\tcase pass_copy:\n\t\tcase pass_omit:\n\t\tcase pass_plus:\n\t\tcase pass_hyphen:\n\t\t\tIC += 1;\n\t\t\tcontinue;\n\n\t\tcase pass_endTest:\n\t\t\tgoto NO_CHARACTERS;\n\n\t\tdefault:\n\t\t\tcompileError(file, \"unhandled test suboperand: \\\\x%02x\", instruction);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tgoto NO_CHARACTERS;\n}\n\nstatic const char *\nprintSource(const FileInfo *currentFile, const char *sourceFile, int sourceLine) {\n\tstatic char scratchBuf[MAXSTRING];\n\tif (sourceFile) {\n\t\tif (currentFile && currentFile->sourceFile &&\n\t\t\t\tstrcmp(currentFile->sourceFile, sourceFile) == 0)\n\t\t\tsnprintf(scratchBuf, MAXSTRING, \"line %d\", sourceLine);\n\t\telse\n\t\t\tsnprintf(scratchBuf, MAXSTRING, \"%s:%d\", sourceFile, sourceLine);\n\t} else\n\t\tsnprintf(scratchBuf, MAXSTRING, \"source unknown\");\n\treturn scratchBuf;\n}\n\n/* The following functions are called by addRule to handle various cases. */\n\nstatic void\naddForwardRuleWithSingleChar(const FileInfo *file, TranslationTableOffset ruleOffset,\n\t\tTranslationTableRule *rule, TranslationTableHeader **table) {\n\t/* direction = 0, rule->charslen = 1 */\n\tTranslationTableCharacter *character;\n\t// get the character from the table, or if the character is not defined yet, define it\n\t// (without adding attributes)\n\tif (rule->opcode >= CTO_Pass2 && rule->opcode <= CTO_Pass4) {\n\t\tcharacter = putDots(file, rule->charsdots[0], table);\n\t\t// putDots may have moved table, so make sure rule is still valid\n\t\trule = (TranslationTableRule *)&(*table)->ruleArea[ruleOffset];\n\t} else if (rule->opcode == CTO_CompDots || rule->opcode == CTO_Comp6) {\n\t\tcharacter = putChar(file, rule->charsdots[0], table, NULL);\n\t\t// putChar may have moved table, so make sure rule is still valid\n\t\trule = (TranslationTableRule *)&(*table)->ruleArea[ruleOffset];\n\t\tcharacter->compRule = ruleOffset;\n\t\treturn;\n\t} else {\n\t\tcharacter = putChar(file, rule->charsdots[0], table, NULL);\n\t\t// putChar may have moved table, so make sure rule is still valid\n\t\trule = (TranslationTableRule *)&(*table)->ruleArea[ruleOffset];\n\t\t// if the new rule is a character definition rule, set the main definition rule of\n\t\t// this character to it (possibly overwriting previous definition rules)\n\t\t// adding the attributes to the character has already been done elsewhere\n\t\tif (rule->opcode >= CTO_Space && rule->opcode < CTO_UpLow) {\n\t\t\tif (character->definitionRule) {\n\t\t\t\tTranslationTableRule *prevRule =\n\t\t\t\t\t\t(TranslationTableRule *)&(*table)\n\t\t\t\t\t\t\t\t->ruleArea[character->definitionRule];\n\t\t\t\t_lou_logMessage(LOU_LOG_DEBUG,\n\t\t\t\t\t\t\"%s:%d: Character already defined (%s). The new definition will \"\n\t\t\t\t\t\t\"take precedence.\",\n\t\t\t\t\t\tfile->fileName, file->lineNumber,\n\t\t\t\t\t\tprintSource(file, prevRule->sourceFile, prevRule->sourceLine));\n\t\t\t} else if (character->basechar) {\n\t\t\t\t_lou_logMessage(LOU_LOG_DEBUG,\n\t\t\t\t\t\t\"%s:%d: A base rule already exists for this character (%s). The \"\n\t\t\t\t\t\t\"%s rule will take precedence.\",\n\t\t\t\t\t\tfile->fileName, file->lineNumber,\n\t\t\t\t\t\tprintSource(file, character->sourceFile, character->sourceLine),\n\t\t\t\t\t\t_lou_findOpcodeName(rule->opcode));\n\t\t\t\tcharacter->basechar = 0;\n\t\t\t\tcharacter->mode = 0;\n\t\t\t}\n\t\t\tcharacter->definitionRule = ruleOffset;\n\t\t}\n\t}\n\t// add the new rule to the list of rules associated with this character\n\t// if the new rule is a character definition rule, it is inserted at the end of the\n\t// list\n\t// otherwise it is inserted before the first character definition rule\n\tTranslationTableOffset *otherRule = &character->otherRules;\n\twhile (*otherRule) {\n\t\tTranslationTableRule *r = (TranslationTableRule *)&(*table)->ruleArea[*otherRule];\n\t\tif (r->charslen == 0) break;\n\t\tif (r->opcode >= CTO_Space && r->opcode < CTO_UpLow)\n\t\t\tif (!(rule->opcode >= CTO_Space && rule->opcode < CTO_UpLow)) break;\n\t\totherRule = &r->charsnext;\n\t}\n\trule->charsnext = *otherRule;\n\t*otherRule = ruleOffset;\n}\n\nstatic void\naddForwardRuleWithMultipleChars(TranslationTableOffset ruleOffset,\n\t\tTranslationTableRule *rule, TranslationTableHeader *table) {\n\t/* direction = 0 rule->charslen > 1 */\n\tTranslationTableOffset *forRule =\n\t\t\t&table->forRules[_lou_stringHash(&rule->charsdots[0], 0, NULL)];\n\twhile (*forRule) {\n\t\tTranslationTableRule *r = (TranslationTableRule *)&table->ruleArea[*forRule];\n\t\tif (rule->charslen > r->charslen) break;\n\t\tif (rule->charslen == r->charslen)\n\t\t\tif ((r->opcode == CTO_Always) && (rule->opcode != CTO_Always)) break;\n\t\tforRule = &r->charsnext;\n\t}\n\trule->charsnext = *forRule;\n\t*forRule = ruleOffset;\n}\n\nstatic void\naddBackwardRuleWithSingleCell(const FileInfo *file, widechar cell,\n\t\tTranslationTableOffset ruleOffset, TranslationTableRule *rule,\n\t\tTranslationTableHeader **table) {\n\t/* direction = 1, rule->dotslen = 1 */\n\tTranslationTableCharacter *dots;\n\tif (rule->opcode == CTO_SwapCc || rule->opcode == CTO_Repeated)\n\t\treturn; /* too ambiguous */\n\t// get the cell from the table, or if the cell is not defined yet, define it (without\n\t// adding attributes)\n\tdots = putDots(file, cell, table);\n\t// putDots may have moved table, so make sure rule is still valid\n\trule = (TranslationTableRule *)&(*table)->ruleArea[ruleOffset];\n\tif (rule->opcode >= CTO_Space && rule->opcode < CTO_UpLow)\n\t\tdots->definitionRule = ruleOffset;\n\tTranslationTableOffset *otherRule = &dots->otherRules;\n\twhile (*otherRule) {\n\t\tTranslationTableRule *r = (TranslationTableRule *)&(*table)->ruleArea[*otherRule];\n\t\tif (rule->charslen > r->charslen || r->dotslen == 0) break;\n\t\tif (r->opcode >= CTO_Space && r->opcode < CTO_UpLow)\n\t\t\tif (!(rule->opcode >= CTO_Space && rule->opcode < CTO_UpLow)) break;\n\t\totherRule = &r->dotsnext;\n\t}\n\trule->dotsnext = *otherRule;\n\t*otherRule = ruleOffset;\n}\n\nstatic void\naddBackwardRuleWithMultipleCells(widechar *cells, int dotslen,\n\t\tTranslationTableOffset ruleOffset, TranslationTableRule *rule,\n\t\tTranslationTableHeader *table) {\n\t/* direction = 1, dotslen > 1 */\n\tTranslationTableOffset *backRule = &table->backRules[_lou_stringHash(cells, 0, NULL)];\n\tif (rule->opcode == CTO_SwapCc) return;\n\tint ruleLength = dotslen + rule->charslen;\n\twhile (*backRule) {\n\t\tTranslationTableRule *r = (TranslationTableRule *)&table->ruleArea[*backRule];\n\t\tint rLength = r->dotslen + r->charslen;\n\t\tif (ruleLength > rLength) break;\n\t\tif (rLength == ruleLength)\n\t\t\tif ((r->opcode == CTO_Always) && (rule->opcode != CTO_Always)) break;\n\t\tbackRule = &r->dotsnext;\n\t}\n\trule->dotsnext = *backRule;\n\t*backRule = ruleOffset;\n}\n\nstatic int\naddForwardPassRule(TranslationTableOffset ruleOffset, TranslationTableRule *rule,\n\t\tTranslationTableHeader *table) {\n\tTranslationTableOffset *forPassRule;\n\tswitch (rule->opcode) {\n\tcase CTO_Correct:\n\t\tforPassRule = &table->forPassRules[0];\n\t\tbreak;\n\tcase CTO_Context:\n\t\tforPassRule = &table->forPassRules[1];\n\t\tbreak;\n\tcase CTO_Pass2:\n\t\tforPassRule = &table->forPassRules[2];\n\t\tbreak;\n\tcase CTO_Pass3:\n\t\tforPassRule = &table->forPassRules[3];\n\t\tbreak;\n\tcase CTO_Pass4:\n\t\tforPassRule = &table->forPassRules[4];\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\twhile (*forPassRule) {\n\t\tTranslationTableRule *r = (TranslationTableRule *)&table->ruleArea[*forPassRule];\n\t\tif (rule->charslen > r->charslen) break;\n\t\tforPassRule = &r->charsnext;\n\t}\n\trule->charsnext = *forPassRule;\n\t*forPassRule = ruleOffset;\n\treturn 1;\n}\n\nstatic int\naddBackwardPassRule(TranslationTableOffset ruleOffset, TranslationTableRule *rule,\n\t\tTranslationTableHeader *table) {\n\tTranslationTableOffset *backPassRule;\n\tswitch (rule->opcode) {\n\tcase CTO_Correct:\n\t\tbackPassRule = &table->backPassRules[0];\n\t\tbreak;\n\tcase CTO_Context:\n\t\tbackPassRule = &table->backPassRules[1];\n\t\tbreak;\n\tcase CTO_Pass2:\n\t\tbackPassRule = &table->backPassRules[2];\n\t\tbreak;\n\tcase CTO_Pass3:\n\t\tbackPassRule = &table->backPassRules[3];\n\t\tbreak;\n\tcase CTO_Pass4:\n\t\tbackPassRule = &table->backPassRules[4];\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\twhile (*backPassRule) {\n\t\tTranslationTableRule *r = (TranslationTableRule *)&table->ruleArea[*backPassRule];\n\t\tif (rule->charslen > r->charslen) break;\n\t\tbackPassRule = &r->dotsnext;\n\t}\n\trule->dotsnext = *backPassRule;\n\t*backPassRule = ruleOffset;\n\treturn 1;\n}\n\nstatic int\naddRule(const FileInfo *file, TranslationTableOpcode opcode, CharsString *ruleChars,\n\t\tCharsString *ruleDots, TranslationTableCharacterAttributes after,\n\t\tTranslationTableCharacterAttributes before, TranslationTableOffset *ruleOffset,\n\t\tTranslationTableRule **rule, int noback, int nofor,\n\t\tTranslationTableHeader **table) {\n\t/* Add a rule to the table, using the hash function to find the start of\n\t * chains and chaining both the chars and dots strings */\n\tTranslationTableOffset offset;\n\tint ruleSize = sizeof(TranslationTableRule) - (DEFAULTRULESIZE * CHARSIZE);\n\tif (ruleChars) ruleSize += CHARSIZE * ruleChars->length;\n\tif (ruleDots) ruleSize += CHARSIZE * ruleDots->length;\n\tif (!allocateSpaceInTranslationTable(file, &offset, ruleSize, table)) return 0;\n\tTranslationTableRule *r = (TranslationTableRule *)&(*table)->ruleArea[offset];\n\tif (rule) *rule = r;\n\tif (ruleOffset) *ruleOffset = offset;\n\tr->sourceFile = file->sourceFile;\n\tr->sourceLine = file->lineNumber;\n\tr->opcode = opcode;\n\tr->after = after;\n\tr->before = before;\n\tr->nocross = 0;\n\tif (ruleChars)\n\t\tmemcpy(&r->charsdots[0], &ruleChars->chars[0],\n\t\t\t\tCHARSIZE * (r->charslen = ruleChars->length));\n\telse\n\t\tr->charslen = 0;\n\tif (ruleDots)\n\t\tmemcpy(&r->charsdots[r->charslen], &ruleDots->chars[0],\n\t\t\t\tCHARSIZE * (r->dotslen = ruleDots->length));\n\telse\n\t\tr->dotslen = 0;\n\n\t/* link new rule into table. */\n\tif (opcode == CTO_SwapCc || opcode == CTO_SwapCd || opcode == CTO_SwapDd) return 1;\n\tif (opcode >= CTO_Context && opcode <= CTO_Pass4)\n\t\tif (!(opcode == CTO_Context && r->charslen > 0)) {\n\t\t\tif (!nofor)\n\t\t\t\tif (!addForwardPassRule(offset, r, *table)) return 0;\n\t\t\tif (!noback)\n\t\t\t\tif (!addBackwardPassRule(offset, r, *table)) return 0;\n\t\t\treturn 1;\n\t\t}\n\tif (!nofor) {\n\t\tif (r->charslen == 1) {\n\t\t\taddForwardRuleWithSingleChar(file, offset, r, table);\n\t\t\t// addForwardRuleWithSingleChar may have moved table, so make sure rule is\n\t\t\t// still valid\n\t\t\tr = (TranslationTableRule *)&(*table)->ruleArea[offset];\n\t\t\tif (rule) *rule = r;\n\t\t} else if (r->charslen > 1)\n\t\t\taddForwardRuleWithMultipleChars(offset, r, *table);\n\t}\n\tif (!noback) {\n\t\twidechar *cells;\n\t\tint dotslen;\n\n\t\tif (r->opcode == CTO_Context) {\n\t\t\tcells = &r->charsdots[0];\n\t\t\tdotslen = r->charslen;\n\t\t} else {\n\t\t\tcells = &r->charsdots[r->charslen];\n\t\t\tdotslen = r->dotslen;\n\t\t}\n\t\tif (dotslen == 1) {\n\t\t\taddBackwardRuleWithSingleCell(file, *cells, offset, r, table);\n\t\t\t// addBackwardRuleWithSingleCell may have moved table, so make sure rule is\n\t\t\t// still valid\n\t\t\tr = (TranslationTableRule *)&(*table)->ruleArea[offset];\n\t\t\tif (rule) *rule = r;\n\t\t} else if (dotslen > 1)\n\t\t\taddBackwardRuleWithMultipleCells(cells, dotslen, offset, r, *table);\n\t}\n\treturn 1;\n}\n\nstatic const CharacterClass *\nfindCharacterClass(const CharsString *name, const TranslationTableHeader *table) {\n\t/* Find a character class, whether predefined or user-defined */\n\tconst CharacterClass *class = table->characterClasses;\n\twhile (class) {\n\t\tif ((name->length == class->length) &&\n\t\t\t\t(memcmp(&name->chars[0], class->name, CHARSIZE * name->length) == 0))\n\t\t\treturn class;\n\t\tclass = class->next;\n\t}\n\treturn NULL;\n}\n\nstatic TranslationTableCharacterAttributes\ngetNextNumberedAttribute(TranslationTableHeader *table) {\n\t/* Get the next attribute value for numbered attributes, or 0 if there is no more\n\t * space in the table. */\n\tTranslationTableCharacterAttributes next = table->nextNumberedCharacterClassAttribute;\n\tif (next > CTC_UserDefined8) return 0;\n\ttable->nextNumberedCharacterClassAttribute <<= 1;\n\treturn next;\n}\n\nstatic TranslationTableCharacterAttributes\ngetNextAttribute(TranslationTableHeader *table) {\n\t/* Get the next attribute value, or 0 if there is no more space in the table. */\n\tTranslationTableCharacterAttributes next = table->nextCharacterClassAttribute;\n\tif (next) {\n\t\tif (next == CTC_LitDigit)\n\t\t\ttable->nextCharacterClassAttribute = CTC_UserDefined9;\n\t\telse\n\t\t\ttable->nextCharacterClassAttribute <<= 1;\n\t\treturn next;\n\t} else\n\t\treturn getNextNumberedAttribute(table);\n}\n\nstatic CharacterClass *\naddCharacterClass(const FileInfo *file, const widechar *name, int length,\n\t\tTranslationTableHeader *table, int validate) {\n\t/* Define a character class, Whether predefined or user-defined */\n\tif (validate) {\n\t\tfor (int i = 0; i < length; i++) {\n\t\t\tif (!((name[i] >= 'a' && name[i] <= 'z') ||\n\t\t\t\t\t\t(name[i] >= 'A' && name[i] <= 'Z'))) {\n\t\t\t\t// don't abort because in some cases (before/after rules)\n\t\t\t\t// this will work fine, but it will not work in multipass\n\t\t\t\t// expressions\n\t\t\t\tcompileWarning(file,\n\t\t\t\t\t\t\"Invalid attribute name: must be a digit between \"\n\t\t\t\t\t\t\"0 and 7 or a word containing only letters\");\n\t\t\t}\n\t\t}\n\t\t// check that name is not reserved\n\t\tint k = 0;\n\t\twhile (reservedAttributeNames[k]) {\n\t\t\tif (strlen(reservedAttributeNames[k]) == length) {\n\t\t\t\tint i;\n\t\t\t\tfor (i = 0; i < length; i++)\n\t\t\t\t\tif (reservedAttributeNames[k][i] != name[i]) break;\n\t\t\t\tif (i == length) {\n\t\t\t\t\tcompileError(file, \"Attribute name is reserved: %s\",\n\t\t\t\t\t\t\treservedAttributeNames[k]);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tk++;\n\t\t}\n\t}\n\tCharacterClass **classes = &table->characterClasses;\n\tTranslationTableCharacterAttributes attribute = getNextAttribute(table);\n\tCharacterClass *class;\n\tif (attribute) {\n\t\tif (!(class = malloc(sizeof(*class) + CHARSIZE * (length - 1))))\n\t\t\t_lou_outOfMemory();\n\t\telse {\n\t\t\tmemset(class, 0, sizeof(*class));\n\t\t\tmemcpy(class->name, name, CHARSIZE * (class->length = length));\n\t\t\tclass->attribute = attribute;\n\t\t\tclass->next = *classes;\n\t\t\t*classes = class;\n\t\t\treturn class;\n\t\t}\n\t}\n\tcompileError(file, \"character class table overflow.\");\n\treturn NULL;\n}\n\nstatic void\ndeallocateCharacterClasses(TranslationTableHeader *table) {\n\tCharacterClass **classes = &table->characterClasses;\n\twhile (*classes) {\n\t\tCharacterClass *class = *classes;\n\t\t*classes = (*classes)->next;\n\t\tif (class) free(class);\n\t}\n}\n\nstatic int\nallocateCharacterClasses(TranslationTableHeader *table) {\n\t/* Allocate memory for predefined character classes */\n\tint k = 0;\n\ttable->characterClasses = NULL;\n\ttable->nextCharacterClassAttribute = 1;\t // CTC_Space\n\ttable->nextNumberedCharacterClassAttribute = CTC_UserDefined1;\n\twhile (characterClassNames[k]) {\n\t\twidechar wname[MAXSTRING];\n\t\tint length = (int)strlen(characterClassNames[k]);\n\t\tint kk;\n\t\tfor (kk = 0; kk < length; kk++) wname[kk] = (widechar)characterClassNames[k][kk];\n\t\tif (!addCharacterClass(NULL, wname, length, table, 0)) {\n\t\t\tdeallocateCharacterClasses(table);\n\t\t\treturn 0;\n\t\t}\n\t\tk++;\n\t}\n\treturn 1;\n}\n\nstatic TranslationTableOpcode\ngetOpcode(const FileInfo *file, const CharsString *token) {\n\tstatic TranslationTableOpcode lastOpcode = 0;\n\tTranslationTableOpcode opcode = lastOpcode;\n\n\tdo {\n\t\tif (token->length == opcodeLengths[opcode])\n\t\t\tif (eqasc2uni((unsigned char *)opcodeNames[opcode], &token->chars[0],\n\t\t\t\t\t\ttoken->length)) {\n\t\t\t\tlastOpcode = opcode;\n\t\t\t\treturn opcode;\n\t\t\t}\n\t\topcode++;\n\t\tif (opcode >= CTO_None) opcode = 0;\n\t} while (opcode != lastOpcode);\n\treturn CTO_None;\n}\n\nTranslationTableOpcode EXPORT_CALL\n_lou_findOpcodeNumber(const char *toFind) {\n\t/* Used by tools such as lou_debug */\n\tstatic TranslationTableOpcode lastOpcode = 0;\n\tTranslationTableOpcode opcode = lastOpcode;\n\tint length = (int)strlen(toFind);\n\tdo {\n\t\tif (length == opcodeLengths[opcode] &&\n\t\t\t\tstrcasecmp(toFind, opcodeNames[opcode]) == 0) {\n\t\t\tlastOpcode = opcode;\n\t\t\treturn opcode;\n\t\t}\n\t\topcode++;\n\t\tif (opcode >= CTO_None) opcode = 0;\n\t} while (opcode != lastOpcode);\n\treturn CTO_None;\n}\n\nconst char *EXPORT_CALL\n_lou_findOpcodeName(TranslationTableOpcode opcode) {\n\tstatic char scratchBuf[MAXSTRING];\n\t/* Used by tools such as lou_debug */\n\tif (opcode < 0 || opcode >= CTO_None) {\n\t\tsprintf(scratchBuf, \"%u\", opcode);\n\t\treturn scratchBuf;\n\t}\n\treturn opcodeNames[opcode];\n}\n\nstatic widechar\nhexValue(const FileInfo *file, const widechar *digits, int length) {\n\tint k;\n\tunsigned int binaryValue = 0;\n\tfor (k = 0; k < length; k++) {\n\t\tunsigned int hexDigit = 0;\n\t\tif (digits[k] >= '0' && digits[k] <= '9')\n\t\t\thexDigit = digits[k] - '0';\n\t\telse if (digits[k] >= 'a' && digits[k] <= 'f')\n\t\t\thexDigit = digits[k] - 'a' + 10;\n\t\telse if (digits[k] >= 'A' && digits[k] <= 'F')\n\t\t\thexDigit = digits[k] - 'A' + 10;\n\t\telse {\n\t\t\tcompileError(file, \"invalid %d-digit hexadecimal number\", length);\n\t\t\treturn (widechar)0xffffffff;\n\t\t}\n\t\tbinaryValue |= hexDigit << (4 * (length - 1 - k));\n\t}\n\treturn (widechar)binaryValue;\n}\n\n#define MAXBYTES 7\nstatic const unsigned int first0Bit[MAXBYTES] = { 0x80, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC,\n\t0XFE };\n\nstatic int\nparseChars(const FileInfo *file, CharsString *result, CharsString *token) {\n\tint in = 0;\n\tint out = 0;\n\tint lastOutSize = 0;\n\tint lastIn;\n\tunsigned int ch = 0;\n\tint numBytes = 0;\n\tunsigned int utf32 = 0;\n\tint k;\n\twhile (in < token->length) {\n\t\tch = token->chars[in++] & 0xff;\n\t\tif (ch < 128) {\n\t\t\tif (ch == '\\\\') { /* escape sequence */\n\t\t\t\tswitch (ch = token->chars[in]) {\n\t\t\t\tcase '\\\\':\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'e':\n\t\t\t\t\tch = 0x1b;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'f':\n\t\t\t\t\tch = 12;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'n':\n\t\t\t\t\tch = 10;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'r':\n\t\t\t\t\tch = 13;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 's':\n\t\t\t\t\tch = ' ';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 't':\n\t\t\t\t\tch = 9;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'v':\n\t\t\t\t\tch = 11;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'w':\n\t\t\t\t\tch = LOU_ENDSEGMENT;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 34:\n\t\t\t\t\tch = QUOTESUB;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'X':\n\t\t\t\t\tcompileWarning(file, \"\\\\Xhhhh (with a capital 'X') is deprecated.\");\n\t\t\t\tcase 'x':\n\t\t\t\t\tif (token->length - in > 4) {\n\t\t\t\t\t\tch = hexValue(file, &token->chars[in + 1], 4);\n\t\t\t\t\t\tin += 4;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'Y':\n\t\t\t\t\tcompileWarning(file, \"\\\\Yhhhhh (with a capital 'Y') is deprecated.\");\n\t\t\t\tcase 'y':\n\t\t\t\t\tif (CHARSIZE == 2) {\n\t\t\t\t\tnot32:\n\t\t\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\t\t\"liblouis has not been compiled for 32-bit Unicode\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (token->length - in > 5) {\n\t\t\t\t\t\tch = hexValue(file, &token->chars[in + 1], 5);\n\t\t\t\t\t\tin += 5;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'Z':\n\t\t\t\t\tcompileWarning(\n\t\t\t\t\t\t\tfile, \"\\\\Zhhhhhhhh (with a capital 'Z') is deprecated.\");\n\t\t\t\tcase 'z':\n\t\t\t\t\tif (CHARSIZE == 2) goto not32;\n\t\t\t\t\tif (token->length - in > 8) {\n\t\t\t\t\t\tch = hexValue(file, &token->chars[in + 1], 8);\n\t\t\t\t\t\tin += 8;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tcompileError(file, \"invalid escape sequence '\\\\%c'\", ch);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tin++;\n\t\t\t}\n\t\t\tif (out >= MAXSTRING - 1) {\n\t\t\t\tcompileError(file, \"Token too long\");\n\t\t\t\tresult->length = MAXSTRING - 1;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tresult->chars[out++] = (widechar)ch;\n\t\t\tcontinue;\n\t\t}\n\t\tlastOutSize = out;\n\t\tlastIn = in;\n\t\tfor (numBytes = MAXBYTES - 1; numBytes > 0; numBytes--)\n\t\t\tif (ch >= first0Bit[numBytes]) break;\n\t\tutf32 = ch & (0XFF - first0Bit[numBytes]);\n\t\tfor (k = 0; k < numBytes; k++) {\n\t\t\tif (in >= MAXSTRING - 1) break;\n\t\t\tif (out >= MAXSTRING - 1) {\n\t\t\t\tcompileError(file, \"Token too long\");\n\t\t\t\tresult->length = lastOutSize;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif (token->chars[in] < 128 || (token->chars[in] & 0x0040)) {\n\t\t\t\tcompileWarning(file, \"invalid UTF-8. Assuming Latin-1.\");\n\t\t\t\tresult->chars[out++] = token->chars[lastIn];\n\t\t\t\tin = lastIn + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tutf32 = (utf32 << 6) + (token->chars[in++] & 0x3f);\n\t\t}\n\t\tif (out >= MAXSTRING - 1) {\n\t\t\tcompileError(file, \"Token too long\");\n\t\t\tresult->length = lastOutSize;\n\t\t\treturn 1;\n\t\t}\n\t\tif (CHARSIZE == 2 && utf32 > 0xffff) utf32 = 0xffff;\n\t\tresult->chars[out++] = (widechar)utf32;\n\t}\n\tresult->length = out;\n\treturn 1;\n}\n\nint EXPORT_CALL\n_lou_extParseChars(const char *inString, widechar *outString) {\n\t/* Parse external character strings */\n\tCharsString wideIn;\n\tCharsString result;\n\tint k;\n\tfor (k = 0; inString[k] && k < MAXSTRING - 1; k++) wideIn.chars[k] = inString[k];\n\twideIn.chars[k] = 0;\n\twideIn.length = k;\n\tparseChars(NULL, &result, &wideIn);\n\tif (errorCount) {\n\t\terrorCount = 0;\n\t\treturn 0;\n\t}\n\tfor (k = 0; k < result.length; k++) outString[k] = result.chars[k];\n\treturn result.length;\n}\n\nstatic int\nparseDots(const FileInfo *file, CharsString *cells, const CharsString *token) {\n\t/* get dot patterns */\n\twidechar cell = 0; /* assembly place for dots */\n\tint cellCount = 0;\n\tint index;\n\tint start = 0;\n\n\tfor (index = 0; index < token->length; index++) {\n\t\tint started = index != start;\n\t\twidechar character = token->chars[index];\n\t\tswitch (character) { /* or dots to make up Braille cell */\n\t\t\t{\n\t\t\t\tint dot;\n\t\t\tcase '1':\n\t\t\t\tdot = LOU_DOT_1;\n\t\t\t\tgoto haveDot;\n\t\t\tcase '2':\n\t\t\t\tdot = LOU_DOT_2;\n\t\t\t\tgoto haveDot;\n\t\t\tcase '3':\n\t\t\t\tdot = LOU_DOT_3;\n\t\t\t\tgoto haveDot;\n\t\t\tcase '4':\n\t\t\t\tdot = LOU_DOT_4;\n\t\t\t\tgoto haveDot;\n\t\t\tcase '5':\n\t\t\t\tdot = LOU_DOT_5;\n\t\t\t\tgoto haveDot;\n\t\t\tcase '6':\n\t\t\t\tdot = LOU_DOT_6;\n\t\t\t\tgoto haveDot;\n\t\t\tcase '7':\n\t\t\t\tdot = LOU_DOT_7;\n\t\t\t\tgoto haveDot;\n\t\t\tcase '8':\n\t\t\t\tdot = LOU_DOT_8;\n\t\t\t\tgoto haveDot;\n\t\t\tcase '9':\n\t\t\t\tdot = LOU_DOT_9;\n\t\t\t\tgoto haveDot;\n\t\t\tcase 'a':\n\t\t\tcase 'A':\n\t\t\t\tdot = LOU_DOT_10;\n\t\t\t\tgoto haveDot;\n\t\t\tcase 'b':\n\t\t\tcase 'B':\n\t\t\t\tdot = LOU_DOT_11;\n\t\t\t\tgoto haveDot;\n\t\t\tcase 'c':\n\t\t\tcase 'C':\n\t\t\t\tdot = LOU_DOT_12;\n\t\t\t\tgoto haveDot;\n\t\t\tcase 'd':\n\t\t\tcase 'D':\n\t\t\t\tdot = LOU_DOT_13;\n\t\t\t\tgoto haveDot;\n\t\t\tcase 'e':\n\t\t\tcase 'E':\n\t\t\t\tdot = LOU_DOT_14;\n\t\t\t\tgoto haveDot;\n\t\t\tcase 'f':\n\t\t\tcase 'F':\n\t\t\t\tdot = LOU_DOT_15;\n\t\t\thaveDot:\n\t\t\t\tif (started && !cell) goto invalid;\n\t\t\t\tif (cell & dot) {\n\t\t\t\t\tcompileError(file, \"dot specified more than once.\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tcell |= dot;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase '0': /* blank */\n\t\t\tif (started) goto invalid;\n\t\t\tbreak;\n\t\tcase '-': /* got all dots for this cell */\n\t\t\tif (!started) {\n\t\t\t\tcompileError(file, \"missing cell specification.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcells->chars[cellCount++] = cell | LOU_DOTS;\n\t\t\tcell = 0;\n\t\t\tstart = index + 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\tinvalid:\n\t\t\tcompileError(\n\t\t\t\t\tfile, \"invalid dot number %s.\", _lou_showString(&character, 1, 0));\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (index == start) {\n\t\tcompileError(file, \"missing cell specification.\");\n\t\treturn 0;\n\t}\n\tcells->chars[cellCount++] = cell | LOU_DOTS; /* last cell */\n\tcells->length = cellCount;\n\treturn 1;\n}\n\nint EXPORT_CALL\n_lou_extParseDots(const char *inString, widechar *outString) {\n\t/* Parse external dot patterns */\n\tCharsString wideIn;\n\tCharsString result;\n\tint k;\n\tfor (k = 0; inString[k] && k < MAXSTRING - 1; k++) wideIn.chars[k] = inString[k];\n\twideIn.chars[k] = 0;\n\twideIn.length = k;\n\tparseDots(NULL, &result, &wideIn);\n\tif (errorCount) {\n\t\terrorCount = 0;\n\t\treturn 0;\n\t}\n\tfor (k = 0; k < result.length; k++) outString[k] = result.chars[k];\n\toutString[k] = 0;\n\treturn result.length;\n}\n\nstatic int\ngetCharacters(FileInfo *file, CharsString *characters) {\n\t/* Get ruleChars string */\n\tCharsString token;\n\tif (!getToken(file, &token, \"characters\")) return 0;\n\treturn parseChars(file, characters, &token);\n}\n\nstatic int\ngetRuleCharsText(FileInfo *file, CharsString *ruleChars) {\n\tCharsString token;\n\tif (!getToken(file, &token, \"Characters operand\")) return 0;\n\treturn parseChars(file, ruleChars, &token);\n}\n\nstatic int\ngetRuleDotsText(FileInfo *file, CharsString *ruleDots) {\n\tCharsString token;\n\tif (!getToken(file, &token, \"characters\")) return 0;\n\treturn parseChars(file, ruleDots, &token);\n}\n\nstatic int\ngetRuleDotsPattern(FileInfo *file, CharsString *ruleDots) {\n\t/* Interpret the dets operand */\n\tCharsString token;\n\tif (!getToken(file, &token, \"Dots operand\")) return 0;\n\tif (token.length == 1 && token.chars[0] == '=') {\n\t\truleDots->length = 0;\n\t\treturn 1;\n\t} else\n\t\treturn parseDots(file, ruleDots, &token);\n}\n\nstatic int\nincludeFile(const FileInfo *file, CharsString *includedFile,\n\t\tTranslationTableHeader **table, DisplayTableHeader **displayTable);\n\nstatic TranslationTableOffset\nfindRuleName(const CharsString *name, const TranslationTableHeader *table) {\n\tconst RuleName *ruleName = table->ruleNames;\n\twhile (ruleName) {\n\t\tif ((name->length == ruleName->length) &&\n\t\t\t\t(memcmp(&name->chars[0], ruleName->name, CHARSIZE * name->length) == 0))\n\t\t\treturn ruleName->ruleOffset;\n\t\truleName = ruleName->next;\n\t}\n\treturn 0;\n}\n\nstatic int\naddRuleName(const FileInfo *file, CharsString *name, TranslationTableOffset ruleOffset,\n\t\tTranslationTableHeader *table) {\n\tint k;\n\tRuleName *ruleName;\n\tif (!(ruleName = malloc(sizeof(*ruleName) + CHARSIZE * (name->length - 1)))) {\n\t\tcompileError(file, \"not enough memory\");\n\t\t_lou_outOfMemory();\n\t}\n\tmemset(ruleName, 0, sizeof(*ruleName));\n\t// a name is a sequence of characters in the ranges 'a'..'z' and 'A'..'Z'\n\tfor (k = 0; k < name->length; k++) {\n\t\twidechar c = name->chars[k];\n\t\tif ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'))\n\t\t\truleName->name[k] = c;\n\t\telse {\n\t\t\tcompileError(file, \"a name may contain only letters\");\n\t\t\tfree(ruleName);\n\t\t\treturn 0;\n\t\t}\n\t}\n\truleName->length = name->length;\n\truleName->ruleOffset = ruleOffset;\n\truleName->next = table->ruleNames;\n\ttable->ruleNames = ruleName;\n\treturn 1;\n}\n\nstatic void\ndeallocateRuleNames(TranslationTableHeader *table) {\n\tRuleName **ruleName = &table->ruleNames;\n\twhile (*ruleName) {\n\t\tRuleName *rn = *ruleName;\n\t\t*ruleName = rn->next;\n\t\tfree(rn);\n\t}\n}\n\nstatic int\ncompileSwapDots(const FileInfo *file, CharsString *source, CharsString *dest) {\n\tint k = 0;\n\tint kk = 0;\n\tCharsString dotsSource;\n\tCharsString dotsDest;\n\tdest->length = 0;\n\tdotsSource.length = 0;\n\twhile (k <= source->length) {\n\t\tif (source->chars[k] != ',' && k != source->length)\n\t\t\tdotsSource.chars[dotsSource.length++] = source->chars[k];\n\t\telse {\n\t\t\tif (!parseDots(file, &dotsDest, &dotsSource)) return 0;\n\t\t\tdest->chars[dest->length++] = dotsDest.length + 1;\n\t\t\tfor (kk = 0; kk < dotsDest.length; kk++)\n\t\t\t\tdest->chars[dest->length++] = dotsDest.chars[kk];\n\t\t\tdotsSource.length = 0;\n\t\t}\n\t\tk++;\n\t}\n\treturn 1;\n}\n\nstatic int\ncompileSwap(FileInfo *file, TranslationTableOpcode opcode, int noback, int nofor,\n\t\tTranslationTableHeader **table) {\n\tCharsString ruleChars;\n\tCharsString ruleDots;\n\tCharsString name;\n\tCharsString matches;\n\tCharsString replacements;\n\tTranslationTableOffset ruleOffset;\n\tif (!getToken(file, &name, \"name operand\")) return 0;\n\tif (!getToken(file, &matches, \"matches operand\")) return 0;\n\tif (!getToken(file, &replacements, \"replacements operand\")) return 0;\n\tif (opcode == CTO_SwapCc || opcode == CTO_SwapCd) {\n\t\tif (!parseChars(file, &ruleChars, &matches)) return 0;\n\t} else {\n\t\tif (!compileSwapDots(file, &matches, &ruleChars)) return 0;\n\t}\n\tif (opcode == CTO_SwapCc) {\n\t\tif (!parseChars(file, &ruleDots, &replacements)) return 0;\n\t} else {\n\t\tif (!compileSwapDots(file, &replacements, &ruleDots)) return 0;\n\t}\n\tif (!addRule(file, opcode, &ruleChars, &ruleDots, 0, 0, &ruleOffset, NULL, noback,\n\t\t\t\tnofor, table))\n\t\treturn 0;\n\tif (!addRuleName(file, &name, ruleOffset, *table)) return 0;\n\treturn 1;\n}\n\nstatic int\ngetNumber(widechar *string, widechar *number) {\n\t/* Convert a string of wide character digits to an integer */\n\tint k = 0;\n\t*number = 0;\n\twhile (string[k] >= '0' && string[k] <= '9')\n\t\t*number = 10 * *number + (string[k++] - '0');\n\treturn k;\n}\n\n/* Start of multipass compiler */\n\nstatic int\npassGetAttributes(CharsString *passLine, int *passLinepos,\n\t\tTranslationTableCharacterAttributes *attributes, const FileInfo *file) {\n\tint more = 1;\n\t*attributes = 0;\n\twhile (more) {\n\t\tswitch (passLine->chars[*passLinepos]) {\n\t\tcase pass_any:\n\t\t\t*attributes = 0xffffffff;\n\t\t\tbreak;\n\t\tcase pass_digit:\n\t\t\t*attributes |= CTC_Digit;\n\t\t\tbreak;\n\t\tcase pass_litDigit:\n\t\t\t*attributes |= CTC_LitDigit;\n\t\t\tbreak;\n\t\tcase pass_letter:\n\t\t\t*attributes |= CTC_Letter;\n\t\t\tbreak;\n\t\tcase pass_math:\n\t\t\t*attributes |= CTC_Math;\n\t\t\tbreak;\n\t\tcase pass_punctuation:\n\t\t\t*attributes |= CTC_Punctuation;\n\t\t\tbreak;\n\t\tcase pass_sign:\n\t\t\t*attributes |= CTC_Sign;\n\t\t\tbreak;\n\t\tcase pass_space:\n\t\t\t*attributes |= CTC_Space;\n\t\t\tbreak;\n\t\tcase pass_uppercase:\n\t\t\t*attributes |= CTC_UpperCase;\n\t\t\tbreak;\n\t\tcase pass_lowercase:\n\t\t\t*attributes |= CTC_LowerCase;\n\t\t\tbreak;\n\t\tcase pass_class1:\n\t\t\t*attributes |= CTC_UserDefined9;\n\t\t\tbreak;\n\t\tcase pass_class2:\n\t\t\t*attributes |= CTC_UserDefined10;\n\t\t\tbreak;\n\t\tcase pass_class3:\n\t\t\t*attributes |= CTC_UserDefined11;\n\t\t\tbreak;\n\t\tcase pass_class4:\n\t\t\t*attributes |= CTC_UserDefined12;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmore = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (more) (*passLinepos)++;\n\t}\n\tif (!*attributes) {\n\t\tcompileError(file, \"missing attribute\");\n\t\t(*passLinepos)--;\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic int\npassGetDots(CharsString *passLine, int *passLinepos, CharsString *dots,\n\t\tconst FileInfo *file) {\n\tCharsString collectDots;\n\tcollectDots.length = 0;\n\twhile (*passLinepos < passLine->length &&\n\t\t\t(passLine->chars[*passLinepos] == '-' ||\n\t\t\t\t\t(passLine->chars[*passLinepos] >= '0' &&\n\t\t\t\t\t\t\tpassLine->chars[*passLinepos] <= '9') ||\n\t\t\t\t\t((passLine->chars[*passLinepos] | 32) >= 'a' &&\n\t\t\t\t\t\t\t(passLine->chars[*passLinepos] | 32) <= 'f')))\n\t\tcollectDots.chars[collectDots.length++] = passLine->chars[(*passLinepos)++];\n\tif (!parseDots(file, dots, &collectDots)) return 0;\n\treturn 1;\n}\n\nstatic int\npassGetString(CharsString *passLine, int *passLinepos, CharsString *string,\n\t\tconst FileInfo *file) {\n\tstring->length = 0;\n\twhile (1) {\n\t\tif ((*passLinepos >= passLine->length) || !passLine->chars[*passLinepos]) {\n\t\t\tcompileError(file, \"unterminated string\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (passLine->chars[*passLinepos] == 34) break;\n\t\tif (passLine->chars[*passLinepos] == QUOTESUB)\n\t\t\tstring->chars[string->length++] = 34;\n\t\telse\n\t\t\tstring->chars[string->length++] = passLine->chars[*passLinepos];\n\t\t(*passLinepos)++;\n\t}\n\tstring->chars[string->length] = 0;\n\t(*passLinepos)++;\n\treturn 1;\n}\n\nstatic int\npassGetNumber(CharsString *passLine, int *passLinepos, widechar *number) {\n\t/* Convert a string of wide character digits to an integer */\n\t*number = 0;\n\twhile ((*passLinepos < passLine->length) && (passLine->chars[*passLinepos] >= '0') &&\n\t\t\t(passLine->chars[*passLinepos] <= '9'))\n\t\t*number = 10 * (*number) + (passLine->chars[(*passLinepos)++] - '0');\n\treturn 1;\n}\n\nstatic int\npassGetVariableNumber(\n\t\tconst FileInfo *file, CharsString *passLine, int *passLinepos, widechar *number) {\n\tif (!passGetNumber(passLine, passLinepos, number)) {\n\t\tcompileError(file, \"missing variable number\");\n\t\treturn 0;\n\t}\n\tif ((*number >= 0) && (*number < NUMVAR)) return 1;\n\tcompileError(file, \"variable number out of range\");\n\treturn 0;\n}\n\nstatic int\npassGetName(CharsString *passLine, int *passLinepos, CharsString *name) {\n\tname->length = 0;\n\t// a name is a sequence of characters in the ranges 'a'..'z' and 'A'..'Z'\n\tdo {\n\t\twidechar c = passLine->chars[*passLinepos];\n\t\tif ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {\n\t\t\tname->chars[name->length++] = c;\n\t\t\t(*passLinepos)++;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t} while (*passLinepos < passLine->length);\n\treturn 1;\n}\n\nstatic inline int\nwantsString(TranslationTableOpcode opcode, int actionPart, int nofor) {\n\tif (opcode == CTO_Correct) return 1;\n\tif (opcode != CTO_Context) return 0;\n\treturn !nofor == !actionPart;\n}\n\nstatic int\nverifyStringOrDots(const FileInfo *file, TranslationTableOpcode opcode, int isString,\n\t\tint actionPart, int nofor) {\n\tif (!wantsString(opcode, actionPart, nofor) == !isString) return 1;\n\n\tcompileError(file, \"%s are not allowed in the %s part of a %s translation %s rule.\",\n\t\t\tisString ? \"strings\" : \"dots\", getPartName(actionPart),\n\t\t\tnofor ? \"backward\" : \"forward\", _lou_findOpcodeName(opcode));\n\n\treturn 0;\n}\n\nstatic int\ncompilePassOpcode(const FileInfo *file, TranslationTableOpcode opcode, int noback,\n\t\tint nofor, TranslationTableHeader **table) {\n\tstatic CharsString passRuleChars;\n\tstatic CharsString passRuleDots;\n\t/* Compile the operands of a pass opcode */\n\twidechar passSubOp;\n\tconst CharacterClass *class;\n\tTranslationTableRule *rule = NULL;\n\tint k;\n\tint kk = 0;\n\tint endTest = 0;\n\twidechar *passInstructions = passRuleDots.chars;\n\tint passIC = 0; /* Instruction counter */\n\tpassRuleChars.length = 0;\n\tCharsString passHoldString;\n\twidechar passHoldNumber;\n\tCharsString passLine;\n\tint passLinepos = 0;\n\tTranslationTableCharacterAttributes passAttributes;\n\tpassHoldString.length = 0;\n\tfor (k = file->linepos; k < file->linelen; k++)\n\t\tpassHoldString.chars[passHoldString.length++] = file->line[k];\n#define SEPCHAR 0x0001\n\tfor (k = 0; k < passHoldString.length && passHoldString.chars[k] > 32; k++)\n\t\t;\n\tif (k < passHoldString.length)\n\t\tpassHoldString.chars[k] = SEPCHAR;\n\telse {\n\t\tcompileError(file, \"Invalid multipass operands\");\n\t\treturn 0;\n\t}\n\tparseChars(file, &passLine, &passHoldString);\n\t/* Compile test part */\n\tfor (k = 0; k < passLine.length && passLine.chars[k] != SEPCHAR; k++)\n\t\t;\n\tendTest = k;\n\tpassLine.chars[endTest] = pass_endTest;\n\tpassLinepos = 0;\n\twhile (passLinepos <= endTest) {\n\t\tif (passIC >= MAXSTRING) {\n\t\t\tcompileError(file, \"Test part in multipass operand too long\");\n\t\t\treturn 0;\n\t\t}\n\t\tswitch ((passSubOp = passLine.chars[passLinepos])) {\n\t\tcase pass_lookback:\n\t\t\tpassInstructions[passIC++] = pass_lookback;\n\t\t\tpassLinepos++;\n\t\t\tpassGetNumber(&passLine, &passLinepos, &passHoldNumber);\n\t\t\tif (passHoldNumber == 0) passHoldNumber = 1;\n\t\t\tpassInstructions[passIC++] = passHoldNumber;\n\t\t\tbreak;\n\t\tcase pass_not:\n\t\t\tpassInstructions[passIC++] = pass_not;\n\t\t\tpassLinepos++;\n\t\t\tbreak;\n\t\tcase pass_first:\n\t\t\tpassInstructions[passIC++] = pass_first;\n\t\t\tpassLinepos++;\n\t\t\tbreak;\n\t\tcase pass_last:\n\t\t\tpassInstructions[passIC++] = pass_last;\n\t\t\tpassLinepos++;\n\t\t\tbreak;\n\t\tcase pass_search:\n\t\t\tpassInstructions[passIC++] = pass_search;\n\t\t\tpassLinepos++;\n\t\t\tbreak;\n\t\tcase pass_string:\n\t\t\tif (!verifyStringOrDots(file, opcode, 1, 0, nofor)) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tpassLinepos++;\n\t\t\tpassInstructions[passIC++] = pass_string;\n\t\t\tpassGetString(&passLine, &passLinepos, &passHoldString, file);\n\t\t\tif (passHoldString.length == 0) {\n\t\t\t\tcompileError(file, \"empty string in test part\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tgoto testDoCharsDots;\n\t\tcase pass_dots:\n\t\t\tif (!verifyStringOrDots(file, opcode, 0, 0, nofor)) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tpassLinepos++;\n\t\t\tpassInstructions[passIC++] = pass_dots;\n\t\t\tpassGetDots(&passLine, &passLinepos, &passHoldString, file);\n\t\t\tif (passHoldString.length == 0) {\n\t\t\t\tcompileError(file, \"expected dot pattern after @ operand in test part\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\ttestDoCharsDots:\n\t\t\tif (passIC >= MAXSTRING) {\n\t\t\t\tcompileError(\n\t\t\t\t\t\tfile, \"@ operand in test part of multipass operand too long\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tpassInstructions[passIC++] = passHoldString.length;\n\t\t\tfor (kk = 0; kk < passHoldString.length; kk++) {\n\t\t\t\tif (passIC >= MAXSTRING) {\n\t\t\t\t\tcompileError(\n\t\t\t\t\t\t\tfile, \"@ operand in test part of multipass operand too long\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tpassInstructions[passIC++] = passHoldString.chars[kk];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase pass_startReplace:\n\t\t\tpassInstructions[passIC++] = pass_startReplace;\n\t\t\tpassLinepos++;\n\t\t\tbreak;\n\t\tcase pass_endReplace:\n\t\t\tpassInstructions[passIC++] = pass_endReplace;\n\t\t\tpassLinepos++;\n\t\t\tbreak;\n\t\tcase pass_variable:\n\t\t\tpassLinepos++;\n\t\t\tif (!passGetVariableNumber(file, &passLine, &passLinepos, &passHoldNumber))\n\t\t\t\treturn 0;\n\t\t\tswitch (passLine.chars[passLinepos]) {\n\t\t\tcase pass_eq:\n\t\t\t\tpassInstructions[passIC++] = pass_eq;\n\t\t\t\tgoto doComp;\n\t\t\tcase pass_lt:\n\t\t\t\tif (passLine.chars[passLinepos + 1] == pass_eq) {\n\t\t\t\t\tpassLinepos++;\n\t\t\t\t\tpassInstructions[passIC++] = pass_lteq;\n\t\t\t\t} else\n\t\t\t\t\tpassInstructions[passIC++] = pass_lt;\n\t\t\t\tgoto doComp;\n\t\t\tcase pass_gt:\n\t\t\t\tif (passLine.chars[passLinepos + 1] == pass_eq) {\n\t\t\t\t\tpassLinepos++;\n\t\t\t\t\tpassInstructions[passIC++] = pass_gteq;\n\t\t\t\t} else\n\t\t\t\t\tpassInstructions[passIC++] = pass_gt;\n\t\t\tdoComp:\n\t\t\t\tpassInstructions[passIC++] = passHoldNumber;\n\t\t\t\tpassLinepos++;\n\t\t\t\tpassGetNumber(&passLine, &passLinepos, &passHoldNumber);\n\t\t\t\tpassInstructions[passIC++] = passHoldNumber;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tcompileError(file, \"incorrect comparison operator\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase pass_attributes:\n\t\t\tpassLinepos++;\n\t\t\tif (!passGetAttributes(&passLine, &passLinepos, &passAttributes, file))\n\t\t\t\treturn 0;\n\t\tinsertAttributes:\n\t\t\tpassInstructions[passIC++] = pass_attributes;\n\t\t\tpassInstructions[passIC++] = (passAttributes >> 48) & 0xffff;\n\t\t\tpassInstructions[passIC++] = (passAttributes >> 32) & 0xffff;\n\t\t\tpassInstructions[passIC++] = (passAttributes >> 16) & 0xffff;\n\t\t\tpassInstructions[passIC++] = passAttributes & 0xffff;\n\t\tgetRange:\n\t\t\tif (passLine.chars[passLinepos] == pass_until) {\n\t\t\t\tpassLinepos++;\n\t\t\t\tpassInstructions[passIC++] = 1;\n\t\t\t\tpassInstructions[passIC++] = 0xffff;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpassGetNumber(&passLine, &passLinepos, &passHoldNumber);\n\t\t\tif (passHoldNumber == 0) {\n\t\t\t\tpassHoldNumber = passInstructions[passIC++] = 1;\n\t\t\t\tpassInstructions[passIC++] = 1; /* This is not an error */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpassInstructions[passIC++] = passHoldNumber;\n\t\t\tif (passLine.chars[passLinepos] != pass_hyphen) {\n\t\t\t\tpassInstructions[passIC++] = passHoldNumber;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpassLinepos++;\n\t\t\tpassGetNumber(&passLine, &passLinepos, &passHoldNumber);\n\t\t\tif (passHoldNumber == 0) {\n\t\t\t\tcompileError(file, \"invalid range\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tpassInstructions[passIC++] = passHoldNumber;\n\t\t\tbreak;\n\t\tcase pass_groupstart:\n\t\tcase pass_groupend: {\n\t\t\tpassLinepos++;\n\t\t\tpassGetName(&passLine, &passLinepos, &passHoldString);\n\t\t\tTranslationTableOffset ruleOffset = findRuleName(&passHoldString, *table);\n\t\t\tif (ruleOffset)\n\t\t\t\trule = (TranslationTableRule *)&(*table)->ruleArea[ruleOffset];\n\t\t\tif (rule && rule->opcode == CTO_Grouping) {\n\t\t\t\tpassInstructions[passIC++] = passSubOp;\n\t\t\t\tpassInstructions[passIC++] = ruleOffset >> 16;\n\t\t\t\tpassInstructions[passIC++] = ruleOffset & 0xffff;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tcompileError(file, \"%s is not a grouping name\",\n\t\t\t\t\t\t_lou_showString(\n\t\t\t\t\t\t\t\t&passHoldString.chars[0], passHoldString.length, 0));\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase pass_swap: {\n\t\t\tpassLinepos++;\n\t\t\tpassGetName(&passLine, &passLinepos, &passHoldString);\n\t\t\tif ((class = findCharacterClass(&passHoldString, *table))) {\n\t\t\t\tpassAttributes = class->attribute;\n\t\t\t\tgoto insertAttributes;\n\t\t\t}\n\t\t\tTranslationTableOffset ruleOffset = findRuleName(&passHoldString, *table);\n\t\t\tif (ruleOffset)\n\t\t\t\trule = (TranslationTableRule *)&(*table)->ruleArea[ruleOffset];\n\t\t\tif (rule &&\n\t\t\t\t\t(rule->opcode == CTO_SwapCc || rule->opcode == CTO_SwapCd ||\n\t\t\t\t\t\t\trule->opcode == CTO_SwapDd)) {\n\t\t\t\tpassInstructions[passIC++] = pass_swap;\n\t\t\t\tpassInstructions[passIC++] = ruleOffset >> 16;\n\t\t\t\tpassInstructions[passIC++] = ruleOffset & 0xffff;\n\t\t\t\tgoto getRange;\n\t\t\t}\n\t\t\tcompileError(file, \"%s is neither a class name nor a swap name.\",\n\t\t\t\t\t_lou_showString(&passHoldString.chars[0], passHoldString.length, 0));\n\t\t\treturn 0;\n\t\t}\n\t\tcase pass_endTest:\n\t\t\tpassInstructions[passIC++] = pass_endTest;\n\t\t\tpassLinepos++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcompileError(file, \"incorrect operator '%c ' in test part\",\n\t\t\t\t\tpassLine.chars[passLinepos]);\n\t\t\treturn 0;\n\t\t}\n\n\t} /* Compile action part */\n\n\t/* Compile action part */\n\twhile (passLinepos < passLine.length && passLine.chars[passLinepos] <= 32)\n\t\tpassLinepos++;\n\twhile (passLinepos < passLine.length && passLine.chars[passLinepos] > 32) {\n\t\tif (passIC >= MAXSTRING) {\n\t\t\tcompileError(file, \"Action part in multipass operand too long\");\n\t\t\treturn 0;\n\t\t}\n\t\tswitch ((passSubOp = passLine.chars[passLinepos])) {\n\t\tcase pass_string:\n\t\t\tif (!verifyStringOrDots(file, opcode, 1, 1, nofor)) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tpassLinepos++;\n\t\t\tpassInstructions[passIC++] = pass_string;\n\t\t\tpassGetString(&passLine, &passLinepos, &passHoldString, file);\n\t\t\tgoto actionDoCharsDots;\n\t\tcase pass_dots:\n\t\t\tif (!verifyStringOrDots(file, opcode, 0, 1, nofor)) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tpassLinepos++;\n\t\t\tpassGetDots(&passLine, &passLinepos, &passHoldString, file);\n\t\t\tpassInstructions[passIC++] = pass_dots;\n\t\t\tif (passHoldString.length == 0) {\n\t\t\t\tcompileError(file, \"expected dot pattern after @ operand in action part\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\tactionDoCharsDots:\n\t\t\tif (passIC >= MAXSTRING) {\n\t\t\t\tcompileError(\n\t\t\t\t\t\tfile, \"@ operand in action part of multipass operand too long\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tpassInstructions[passIC++] = passHoldString.length;\n\t\t\tfor (kk = 0; kk < passHoldString.length; kk++) {\n\t\t\t\tif (passIC >= MAXSTRING) {\n\t\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\t\"@ operand in action part of multipass operand too long\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tpassInstructions[passIC++] = passHoldString.chars[kk];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase pass_variable:\n\t\t\tpassLinepos++;\n\t\t\tif (!passGetVariableNumber(file, &passLine, &passLinepos, &passHoldNumber))\n\t\t\t\treturn 0;\n\t\t\tswitch (passLine.chars[passLinepos]) {\n\t\t\tcase pass_eq:\n\t\t\t\tpassInstructions[passIC++] = pass_eq;\n\t\t\t\tpassInstructions[passIC++] = passHoldNumber;\n\t\t\t\tpassLinepos++;\n\t\t\t\tpassGetNumber(&passLine, &passLinepos, &passHoldNumber);\n\t\t\t\tpassInstructions[passIC++] = passHoldNumber;\n\t\t\t\tbreak;\n\t\t\tcase pass_plus:\n\t\t\tcase pass_hyphen:\n\t\t\t\tpassInstructions[passIC++] = passLine.chars[passLinepos++];\n\t\t\t\tpassInstructions[passIC++] = passHoldNumber;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tcompileError(file, \"incorrect variable operator in action part\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase pass_copy:\n\t\t\tpassInstructions[passIC++] = pass_copy;\n\t\t\tpassLinepos++;\n\t\t\tbreak;\n\t\tcase pass_omit:\n\t\t\tpassInstructions[passIC++] = pass_omit;\n\t\t\tpassLinepos++;\n\t\t\tbreak;\n\t\tcase pass_groupreplace:\n\t\tcase pass_groupstart:\n\t\tcase pass_groupend: {\n\t\t\tpassLinepos++;\n\t\t\tpassGetName(&passLine, &passLinepos, &passHoldString);\n\t\t\tTranslationTableOffset ruleOffset = findRuleName(&passHoldString, *table);\n\t\t\tif (ruleOffset)\n\t\t\t\trule = (TranslationTableRule *)&(*table)->ruleArea[ruleOffset];\n\t\t\tif (rule && rule->opcode == CTO_Grouping) {\n\t\t\t\tpassInstructions[passIC++] = passSubOp;\n\t\t\t\tpassInstructions[passIC++] = ruleOffset >> 16;\n\t\t\t\tpassInstructions[passIC++] = ruleOffset & 0xffff;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcompileError(file, \"%s is not a grouping name\",\n\t\t\t\t\t_lou_showString(&passHoldString.chars[0], passHoldString.length, 0));\n\t\t\treturn 0;\n\t\t}\n\t\tcase pass_swap: {\n\t\t\tpassLinepos++;\n\t\t\tpassGetName(&passLine, &passLinepos, &passHoldString);\n\t\t\tTranslationTableOffset ruleOffset = findRuleName(&passHoldString, *table);\n\t\t\tif (ruleOffset)\n\t\t\t\trule = (TranslationTableRule *)&(*table)->ruleArea[ruleOffset];\n\t\t\tif (rule &&\n\t\t\t\t\t(rule->opcode == CTO_SwapCc || rule->opcode == CTO_SwapCd ||\n\t\t\t\t\t\t\trule->opcode == CTO_SwapDd)) {\n\t\t\t\tpassInstructions[passIC++] = pass_swap;\n\t\t\t\tpassInstructions[passIC++] = ruleOffset >> 16;\n\t\t\t\tpassInstructions[passIC++] = ruleOffset & 0xffff;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcompileError(file, \"%s is not a swap name.\",\n\t\t\t\t\t_lou_showString(&passHoldString.chars[0], passHoldString.length, 0));\n\t\t\treturn 0;\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tcompileError(file, \"incorrect operator in action part\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* Analyze and add rule */\n\tpassRuleDots.length = passIC;\n\n\t{\n\t\twidechar *characters;\n\t\tint length;\n\t\tint found = passFindCharacters(\n\t\t\t\tfile, passInstructions, passRuleDots.length, &characters, &length);\n\n\t\tif (!found) return 0;\n\n\t\tif (characters) {\n\t\t\tfor (k = 0; k < length; k += 1) passRuleChars.chars[k] = characters[k];\n\t\t\tpassRuleChars.length = k;\n\t\t}\n\t}\n\n\tif (!addRule(file, opcode, &passRuleChars, &passRuleDots, 0, 0, NULL, NULL, noback,\n\t\t\t\tnofor, table))\n\t\treturn 0;\n\treturn 1;\n}\n\n/* End of multipass compiler */\n\nstatic int\ncompileBrailleIndicator(FileInfo *file, const char *ermsg, TranslationTableOpcode opcode,\n\t\tTranslationTableOffset *ruleOffset, int noback, int nofor,\n\t\tTranslationTableHeader **table) {\n\tCharsString token;\n\tCharsString cells;\n\tif (!getToken(file, &token, ermsg)) return 0;\n\tif (!parseDots(file, &cells, &token)) return 0;\n\treturn addRule(\n\t\t\tfile, opcode, NULL, &cells, 0, 0, ruleOffset, NULL, noback, nofor, table);\n}\n\nstatic int\ncompileNumber(FileInfo *file) {\n\tCharsString token;\n\twidechar number;\n\tif (!getToken(file, &token, \"number\")) return 0;\n\tgetNumber(&token.chars[0], &number);\n\tif (!(number > 0)) {\n\t\tcompileError(file, \"a nonzero positive number is required\");\n\t\treturn 0;\n\t}\n\treturn number;\n}\n\nstatic int\ncompileGrouping(FileInfo *file, int noback, int nofor, TranslationTableHeader **table,\n\t\tDisplayTableHeader **displayTable) {\n\tint k;\n\tCharsString name;\n\tCharsString groupChars;\n\tCharsString groupDots;\n\tCharsString dotsParsed;\n\tif (!getToken(file, &name, \"name operand\")) return 0;\n\tif (!getRuleCharsText(file, &groupChars)) return 0;\n\tif (!getToken(file, &groupDots, \"dots operand\")) return 0;\n\tfor (k = 0; k < groupDots.length && groupDots.chars[k] != ','; k++)\n\t\t;\n\tif (k == groupDots.length) {\n\t\tcompileError(file, \"Dots operand must consist of two cells separated by a comma\");\n\t\treturn 0;\n\t}\n\tgroupDots.chars[k] = '-';\n\tif (!parseDots(file, &dotsParsed, &groupDots)) return 0;\n\tif (groupChars.length != 2 || dotsParsed.length != 2) {\n\t\tcompileError(file,\n\t\t\t\t\"two Unicode characters and two cells separated by a comma are needed.\");\n\t\treturn 0;\n\t}\n\tif (table) {\n\t\tTranslationTableOffset ruleOffset;\n\t\tTranslationTableCharacter *charsDotsPtr;\n\t\tcharsDotsPtr = putChar(file, groupChars.chars[0], table, NULL);\n\t\tcharsDotsPtr->attributes |= CTC_Math;\n\t\tcharsDotsPtr = putChar(file, groupChars.chars[1], table, NULL);\n\t\tcharsDotsPtr->attributes |= CTC_Math;\n\t\tcharsDotsPtr = putDots(file, dotsParsed.chars[0], table);\n\t\tcharsDotsPtr->attributes |= CTC_Math;\n\t\tcharsDotsPtr = putDots(file, dotsParsed.chars[1], table);\n\t\tcharsDotsPtr->attributes |= CTC_Math;\n\t\tif (!addRule(file, CTO_Grouping, &groupChars, &dotsParsed, 0, 0, &ruleOffset,\n\t\t\t\t\tNULL, noback, nofor, table))\n\t\t\treturn 0;\n\t\tif (!addRuleName(file, &name, ruleOffset, *table)) return 0;\n\t}\n\tif (displayTable) {\n\t\tputCharDotsMapping(file, groupChars.chars[0], dotsParsed.chars[0], displayTable);\n\t\tputCharDotsMapping(file, groupChars.chars[1], dotsParsed.chars[1], displayTable);\n\t}\n\tif (table) {\n\t\twidechar endChar;\n\t\twidechar endDots;\n\t\tendChar = groupChars.chars[1];\n\t\tendDots = dotsParsed.chars[1];\n\t\tgroupChars.length = dotsParsed.length = 1;\n\t\tif (!addRule(file, CTO_Math, &groupChars, &dotsParsed, 0, 0, NULL, NULL, noback,\n\t\t\t\t\tnofor, table))\n\t\t\treturn 0;\n\t\tgroupChars.chars[0] = endChar;\n\t\tdotsParsed.chars[0] = endDots;\n\t\tif (!addRule(file, CTO_Math, &groupChars, &dotsParsed, 0, 0, NULL, NULL, noback,\n\t\t\t\t\tnofor, table))\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n/* Functions for compiling hyphenation tables */\n\ntypedef struct HyphenDict { /* hyphenation dictionary: finite state machine */\n\tint numStates;\n\tHyphenationState *states;\n} HyphenDict;\n\n#define DEFAULTSTATE 0xffff\n#define HYPHENHASHSIZE 8191\n\ntypedef struct HyphenHashEntry {\n\tstruct HyphenHashEntry *next;\n\tCharsString *key;\n\tint val;\n} HyphenHashEntry;\n\ntypedef struct HyphenHashTab {\n\tHyphenHashEntry *entries[HYPHENHASHSIZE];\n} HyphenHashTab;\n\n/* a hash function from ASU - adapted from Gtk+ */\nstatic unsigned int\nhyphenStringHash(const CharsString *s) {\n\tint k;\n\tunsigned int h = 0, g;\n\tfor (k = 0; k < s->length; k++) {\n\t\th = (h << 4) + s->chars[k];\n\t\tif ((g = h & 0xf0000000)) {\n\t\t\th = h ^ (g >> 24);\n\t\t\th = h ^ g;\n\t\t}\n\t}\n\treturn h;\n}\n\nstatic HyphenHashTab *\nhyphenHashNew(void) {\n\tHyphenHashTab *hashTab;\n\tif (!(hashTab = malloc(sizeof(HyphenHashTab)))) _lou_outOfMemory();\n\tmemset(hashTab, 0, sizeof(HyphenHashTab));\n\treturn hashTab;\n}\n\nstatic void\nhyphenHashFree(HyphenHashTab *hashTab) {\n\tint i;\n\tHyphenHashEntry *e, *next;\n\tfor (i = 0; i < HYPHENHASHSIZE; i++)\n\t\tfor (e = hashTab->entries[i]; e; e = next) {\n\t\t\tnext = e->next;\n\t\t\tfree(e->key);\n\t\t\tfree(e);\n\t\t}\n\tfree(hashTab);\n}\n\n/* assumes that key is not already present! */\nstatic void\nhyphenHashInsert(HyphenHashTab *hashTab, const CharsString *key, int val) {\n\tint i, j;\n\tHyphenHashEntry *e;\n\ti = hyphenStringHash(key) % HYPHENHASHSIZE;\n\tif (!(e = malloc(sizeof(HyphenHashEntry)))) _lou_outOfMemory();\n\te->next = hashTab->entries[i];\n\te->key = malloc((key->length + 1) * CHARSIZE);\n\tif (!e->key) _lou_outOfMemory();\n\te->key->length = key->length;\n\tfor (j = 0; j < key->length; j++) e->key->chars[j] = key->chars[j];\n\te->val = val;\n\thashTab->entries[i] = e;\n}\n\n/* return val if found, otherwise DEFAULTSTATE */\nstatic int\nhyphenHashLookup(HyphenHashTab *hashTab, const CharsString *key) {\n\tint i, j;\n\tHyphenHashEntry *e;\n\tif (key->length == 0) return 0;\n\ti = hyphenStringHash(key) % HYPHENHASHSIZE;\n\tfor (e = hashTab->entries[i]; e; e = e->next) {\n\t\tif (key->length != e->key->length) continue;\n\t\tfor (j = 0; j < key->length; j++)\n\t\t\tif (key->chars[j] != e->key->chars[j]) break;\n\t\tif (j == key->length) return e->val;\n\t}\n\treturn DEFAULTSTATE;\n}\n\nstatic int\nhyphenGetNewState(HyphenDict *dict, HyphenHashTab *hashTab, const CharsString *string) {\n\thyphenHashInsert(hashTab, string, dict->numStates);\n\t/* predicate is true if dict->numStates is a power of two */\n\tif (!(dict->numStates & (dict->numStates - 1)))\n\t\tdict->states =\n\t\t\t\trealloc(dict->states, (dict->numStates << 1) * sizeof(HyphenationState));\n\tif (!dict->states) _lou_outOfMemory();\n\tdict->states[dict->numStates].hyphenPattern = 0;\n\tdict->states[dict->numStates].fallbackState = DEFAULTSTATE;\n\tdict->states[dict->numStates].numTrans = 0;\n\tdict->states[dict->numStates].trans.pointer = NULL;\n\treturn dict->numStates++;\n}\n\n/* add a transition from state1 to state2 through ch - assumes that the\n * transition does not already exist */\nstatic void\nhyphenAddTrans(HyphenDict *dict, int state1, int state2, widechar ch) {\n\tint numTrans;\n\tnumTrans = dict->states[state1].numTrans;\n\tif (numTrans == 0)\n\t\tdict->states[state1].trans.pointer = malloc(sizeof(HyphenationTrans));\n\telse if (!(numTrans & (numTrans - 1)))\n\t\tdict->states[state1].trans.pointer = realloc(dict->states[state1].trans.pointer,\n\t\t\t\t(numTrans << 1) * sizeof(HyphenationTrans));\n\tdict->states[state1].trans.pointer[numTrans].ch = ch;\n\tdict->states[state1].trans.pointer[numTrans].newState = state2;\n\tdict->states[state1].numTrans++;\n}\n\nstatic int\ncompileHyphenation(\n\t\tFileInfo *file, CharsString *encoding, TranslationTableHeader **table) {\n\tCharsString hyph;\n\tHyphenationTrans *holdPointer;\n\tHyphenHashTab *hashTab;\n\tCharsString word;\n\tchar pattern[MAXSTRING + 1];\n\tunsigned int stateNum = 0, lastState = 0;\n\tint i, j, k = encoding->length;\n\twidechar ch;\n\tint found;\n\tHyphenHashEntry *e;\n\tHyphenDict dict;\n\tTranslationTableOffset holdOffset;\n\t/* Set aside enough space for hyphenation states and transitions in\n\t * translation table. Must be done before anything else */\n\tallocateSpaceInTranslationTable(file, NULL, 250000, table);\n\thashTab = hyphenHashNew();\n\tdict.numStates = 1;\n\tdict.states = malloc(sizeof(HyphenationState));\n\tif (!dict.states) _lou_outOfMemory();\n\tdict.states[0].hyphenPattern = 0;\n\tdict.states[0].fallbackState = DEFAULTSTATE;\n\tdict.states[0].numTrans = 0;\n\tdict.states[0].trans.pointer = NULL;\n\tdo {\n\t\tif (encoding->chars[0] == 'I') {\n\t\t\tif (!getToken(file, &hyph, NULL)) continue;\n\t\t} else {\n\t\t\t/* UTF-8 */\n\t\t\tif (!getToken(file, &word, NULL)) continue;\n\t\t\tparseChars(file, &hyph, &word);\n\t\t}\n\t\tif (hyph.length == 0 || hyph.chars[0] == '#' || hyph.chars[0] == '%' ||\n\t\t\t\thyph.chars[0] == '<')\n\t\t\tcontinue; /* comment */\n\t\tj = 0;\n\t\tpattern[j] = '0';\n\t\tfor (i = 0; i < hyph.length; i++) {\n\t\t\tif (hyph.chars[i] >= '0' && hyph.chars[i] <= '9')\n\t\t\t\tpattern[j] = (char)hyph.chars[i];\n\t\t\telse {\n\t\t\t\tword.chars[j] = hyph.chars[i];\n\t\t\t\tpattern[++j] = '0';\n\t\t\t}\n\t\t}\n\t\tword.chars[j] = 0;\n\t\tword.length = j;\n\t\tpattern[j + 1] = 0;\n\t\tfor (i = 0; pattern[i] == '0'; i++)\n\t\t\t;\n\t\tfound = hyphenHashLookup(hashTab, &word);\n\t\tif (found != DEFAULTSTATE)\n\t\t\tstateNum = found;\n\t\telse\n\t\t\tstateNum = hyphenGetNewState(&dict, hashTab, &word);\n\t\tk = j + 2 - i;\n\t\tif (k > 0) {\n\t\t\tallocateSpaceInTranslationTable(\n\t\t\t\t\tfile, &dict.states[stateNum].hyphenPattern, k, table);\n\t\t\tmemcpy(&(*table)->ruleArea[dict.states[stateNum].hyphenPattern], &pattern[i],\n\t\t\t\t\tk);\n\t\t}\n\t\t/* now, put in the prefix transitions */\n\t\twhile (found == DEFAULTSTATE) {\n\t\t\tlastState = stateNum;\n\t\t\tch = word.chars[word.length-- - 1];\n\t\t\tfound = hyphenHashLookup(hashTab, &word);\n\t\t\tif (found != DEFAULTSTATE)\n\t\t\t\tstateNum = found;\n\t\t\telse\n\t\t\t\tstateNum = hyphenGetNewState(&dict, hashTab, &word);\n\t\t\thyphenAddTrans(&dict, stateNum, lastState, ch);\n\t\t}\n\t} while (_lou_getALine(file));\n\t/* put in the fallback states */\n\tfor (i = 0; i < HYPHENHASHSIZE; i++) {\n\t\tfor (e = hashTab->entries[i]; e; e = e->next) {\n\t\t\tfor (j = 1; j <= e->key->length; j++) {\n\t\t\t\tword.length = 0;\n\t\t\t\tfor (k = j; k < e->key->length; k++)\n\t\t\t\t\tword.chars[word.length++] = e->key->chars[k];\n\t\t\t\tstateNum = hyphenHashLookup(hashTab, &word);\n\t\t\t\tif (stateNum != DEFAULTSTATE) break;\n\t\t\t}\n\t\t\tif (e->val) dict.states[e->val].fallbackState = stateNum;\n\t\t}\n\t}\n\thyphenHashFree(hashTab);\n\t/* Transfer hyphenation information to table */\n\tfor (i = 0; i < dict.numStates; i++) {\n\t\tif (dict.states[i].numTrans == 0)\n\t\t\tdict.states[i].trans.offset = 0;\n\t\telse {\n\t\t\tholdPointer = dict.states[i].trans.pointer;\n\t\t\tallocateSpaceInTranslationTable(file, &dict.states[i].trans.offset,\n\t\t\t\t\tdict.states[i].numTrans * sizeof(HyphenationTrans), table);\n\t\t\tmemcpy(&(*table)->ruleArea[dict.states[i].trans.offset], holdPointer,\n\t\t\t\t\tdict.states[i].numTrans * sizeof(HyphenationTrans));\n\t\t\tfree(holdPointer);\n\t\t}\n\t}\n\tallocateSpaceInTranslationTable(\n\t\t\tfile, &holdOffset, dict.numStates * sizeof(HyphenationState), table);\n\t(*table)->hyphenStatesArray = holdOffset;\n\t/* Prevents segmentation fault if table is reallocated */\n\tmemcpy(&(*table)->ruleArea[(*table)->hyphenStatesArray], &dict.states[0],\n\t\t\tdict.numStates * sizeof(HyphenationState));\n\tfree(dict.states);\n\treturn 1;\n}\n\nstatic int\ncompileCharDef(FileInfo *file, TranslationTableOpcode opcode,\n\t\tTranslationTableCharacterAttributes attributes, int noback, int nofor,\n\t\tTranslationTableHeader **table, DisplayTableHeader **displayTable) {\n\tCharsString ruleChars;\n\tCharsString ruleDots;\n\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\tif (!getRuleDotsPattern(file, &ruleDots)) return 0;\n\tif (ruleChars.length != 1) {\n\t\tcompileError(file, \"Exactly one character is required.\");\n\t\treturn 0;\n\t}\n\tif (ruleDots.length < 1) {\n\t\tcompileError(file, \"At least one cell is required.\");\n\t\treturn 0;\n\t}\n\tif (table) {\n\t\tTranslationTableCharacter *character;\n\t\tTranslationTableCharacter *cell = NULL;\n\t\tint k;\n\t\tif (attributes & (CTC_UpperCase | CTC_LowerCase)) attributes |= CTC_Letter;\n\t\tcharacter = putChar(file, ruleChars.chars[0], table, NULL);\n\t\tcharacter->attributes |= attributes;\n\t\tfor (k = ruleDots.length - 1; k >= 0; k -= 1) {\n\t\t\tcell = getDots(ruleDots.chars[k], *table);\n\t\t\tif (!cell) cell = putDots(file, ruleDots.chars[k], table);\n\t\t}\n\t\tif (ruleDots.length == 1) cell->attributes |= attributes;\n\t}\n\tif (displayTable && ruleDots.length == 1)\n\t\tputCharDotsMapping(file, ruleChars.chars[0], ruleDots.chars[0], displayTable);\n\tif (table)\n\t\tif (!addRule(file, opcode, &ruleChars, &ruleDots, 0, 0, NULL, NULL, noback, nofor,\n\t\t\t\t\ttable))\n\t\t\treturn 0;\n\treturn 1;\n}\n\nstatic int\ncompileBeforeAfter(FileInfo *file) {\n\t/* 1=before, 2=after, 0=error */\n\tCharsString token;\n\tCharsString tmp;\n\tif (!getToken(file, &token, \"last word before or after\")) return 0;\n\tif (!parseChars(file, &tmp, &token)) return 0;\n\tif (eqasc2uni((unsigned char *)\"before\", tmp.chars, 6))\n\t\treturn 1;\n\telse if (eqasc2uni((unsigned char *)\"after\", tmp.chars, 5))\n\t\treturn 2;\n\treturn 0;\n}\n\n/**\n * Macro\n */\ntypedef struct {\n\tconst char *name;\n\tconst widechar *definition;\t // fixed part\n\tint definition_length;\n\tconst int *substitutions;  // variable part: position and argument index of each\n\t\t\t\t\t\t\t   // variable substitution\n\tint substitution_count;\n\tint argument_count;\t // number of expected arguments\n} Macro;\n\n/**\n * List of in-scope macros\n */\ntypedef struct MacroList {\n\tconst Macro *head;\n\tconst struct MacroList *tail;\n} MacroList;\n\n/**\n * Create new macro.\n */\nstatic const Macro *\ncreate_macro(const char *name, const widechar *definition, int definition_length,\n\t\tconst int *substitutions, int substitution_count, int argument_count) {\n\tMacro *m = malloc(sizeof(Macro));\n\tm->name = strdup(name);\n\twidechar *definition_copy = malloc(definition_length * sizeof(widechar));\n\tmemcpy(definition_copy, definition, definition_length * sizeof(widechar));\n\tm->definition = definition_copy;\n\tm->definition_length = definition_length;\n\tint *substitutions_copy = malloc(2 * substitution_count * sizeof(int));\n\tmemcpy(substitutions_copy, substitutions, 2 * substitution_count * sizeof(int));\n\tm->substitutions = substitutions_copy;\n\tm->substitution_count = substitution_count;\n\tm->argument_count = argument_count;\n\treturn m;\n}\n\n/**\n * Create new macro list from \"head\" macro and \"tail\" list.\n */\nstatic const MacroList *\ncons_macro(const Macro *head, const MacroList *tail) {\n\tMacroList *list = malloc(sizeof(MacroList));\n\tlist->head = head;\n\tlist->tail = tail;\n\treturn list;\n}\n\n/**\n * Free macro returned by create_macro.\n */\nstatic void\nfree_macro(const Macro *macro) {\n\tif (macro) {\n\t\tfree((char *)macro->name);\n\t\tfree((char *)macro->definition);\n\t\tfree((int *)macro->substitutions);\n\t\tfree((Macro *)macro);\n\t}\n}\n\n/**\n * Free macro list returned by cons_macro.\n */\nstatic void\nfree_macro_list(const MacroList *list) {\n\tif (list) {\n\t\tfree_macro((Macro *)list->head);\n\t\tfree_macro_list((MacroList *)list->tail);\n\t\tfree((MacroList *)list);\n\t}\n}\n\n/**\n * Compile macro\n */\nstatic int\ncompileMacro(FileInfo *file, const Macro **macro) {\n\n\t// parse name\n\tCharsString token;\n\tif (!getToken(file, &token, \"macro name\")) return 0;\n\tswitch (getOpcode(file, &token)) {\n\tcase CTO_UpLow:\t // deprecated so \"uplow\" may be used as macro name\n\tcase CTO_None:\n\t\tbreak;\n\tdefault:\n\t\tcompileError(file, \"Invalid macro name: already taken by an opcode\");\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i < token.length; i++) {\n\t\tif (!((token.chars[i] >= 'a' && token.chars[i] <= 'z') ||\n\t\t\t\t\t(token.chars[i] >= 'A' && token.chars[i] <= 'Z') ||\n\t\t\t\t\t(token.chars[i] >= '0' && token.chars[i] <= '9'))) {\n\t\t\tcompileError(file,\n\t\t\t\t\t\"Invalid macro name: must be a word containing only letters and \"\n\t\t\t\t\t\"digits\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tstatic char name[MAXSTRING + 1];\n\tint name_length;\n\tfor (name_length = 0; name_length < token.length;\n\t\t\tname_length++)\t// we know token can not be longer than MAXSTRING\n\t\tname[name_length] = (char)token.chars[name_length];\n\tname[name_length] = '\\0';\n\n\t// parse body\n\tstatic widechar definition[MAXSTRING];\n\tstatic int substitutions[2 * MAX_MACRO_VAR];\n\tint definition_length = 0;\n\tint substitution_count = 0;\n\tint argument_count = 0;\n\tint dollar = 0;\n\n\t// ignore rest of line after name and read lines until \"eom\" is encountered\n\twhile (_lou_getALine(file)) {\n\t\tif (file->linelen >= 3 && file->line[0] == 'e' && file->line[1] == 'o' &&\n\t\t\t\tfile->line[2] == 'm') {\n\t\t\t*macro = create_macro(name, definition, definition_length, substitutions,\n\t\t\t\t\tsubstitution_count, argument_count);\n\t\t\treturn 1;\n\t\t}\n\t\twhile (!atEndOfLine(file)) {\n\t\t\twidechar c = file->line[file->linepos++];\n\t\t\tif (dollar) {\n\t\t\t\tdollar = 0;\n\t\t\t\tif (c >= '0' && c <= '9') {\n\t\t\t\t\tif (substitution_count >= MAX_MACRO_VAR) {\n\t\t\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\t\t\"Macro can not have more than %d variable substitutions\",\n\t\t\t\t\t\t\t\tMAXSTRING);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tsubstitutions[2 * substitution_count] = definition_length;\n\t\t\t\t\tint arg = c - '0';\n\t\t\t\t\tsubstitutions[2 * substitution_count + 1] = arg;\n\t\t\t\t\tif (arg > argument_count) argument_count = arg;\n\t\t\t\t\tsubstitution_count++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else if (c == '$') {\n\t\t\t\tdollar = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (definition_length >= MAXSTRING) {\n\t\t\t\tcompileError(file, \"Macro exceeds %d characters\", MAXSTRING);\n\t\t\t\treturn 0;\n\t\t\t} else\n\t\t\t\tdefinition[definition_length++] = c;\n\t\t}\n\t\tdollar = 0;\n\t\tif (definition_length >= MAXSTRING) {\n\t\t\tcompileError(file, \"Macro exceeds %d characters\", MAXSTRING);\n\t\t\treturn 0;\n\t\t}\n\t\tdefinition[definition_length++] = '\\n';\n\t}\n\tcompileError(file, \"macro must be terminated with 'eom'\");\n\treturn 0;\n}\n\nstatic int\ncompileRule(FileInfo *file, TranslationTableHeader **table,\n\t\tDisplayTableHeader **displayTable, const MacroList **inScopeMacros) {\n\tCharsString token;\n\tTranslationTableOpcode opcode;\n\tCharsString ruleChars;\n\tCharsString ruleDots;\n\tCharsString cells;\n\tCharsString scratchPad;\n\tCharsString emphClass;\n\tTranslationTableCharacterAttributes after = 0;\n\tTranslationTableCharacterAttributes before = 0;\n\tint noback, nofor, nocross;\n\tnoback = nofor = nocross = 0;\ndoOpcode:\n\tif (!getToken(file, &token, NULL)) return 1;\t\t\t\t  /* blank line */\n\tif (token.chars[0] == '#' || token.chars[0] == '<') return 1; /* comment */\n\tif (file->lineNumber == 1 &&\n\t\t\t(eqasc2uni((unsigned char *)\"ISO\", token.chars, 3) ||\n\t\t\t\t\teqasc2uni((unsigned char *)\"UTF-8\", token.chars, 5))) {\n\t\tif (table)\n\t\t\tcompileHyphenation(file, &token, table);\n\t\telse\n\t\t\t/* ignore the whole file */\n\t\t\twhile (_lou_getALine(file))\n\t\t\t\t;\n\t\treturn 1;\n\t}\n\topcode = getOpcode(file, &token);\n\tswitch (opcode) {\n\tcase CTO_Macro: {\n\t\tconst Macro *macro;\n#ifdef ENABLE_MACROS\n\t\tif (!inScopeMacros) {\n\t\t\tcompileError(file, \"Defining macros only allowed in table files.\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (compileMacro(file, &macro)) {\n\t\t\t*inScopeMacros = cons_macro(macro, *inScopeMacros);\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n#else\n\t\tcompileError(file, \"Macro feature is disabled.\");\n\t\treturn 0;\n#endif\n\t}\n\tcase CTO_IncludeFile: {\n\t\tCharsString includedFile;\n\t\tif (!getToken(file, &token, \"include file name\")) return 0;\n\t\tif (!parseChars(file, &includedFile, &token)) return 0;\n\t\treturn includeFile(file, &includedFile, table, displayTable);\n\t}\n\tcase CTO_NoBack:\n\t\tif (nofor) {\n\t\t\tcompileError(file, \"%s already specified.\", _lou_findOpcodeName(CTO_NoFor));\n\t\t\treturn 0;\n\t\t}\n\t\tnoback = 1;\n\t\tgoto doOpcode;\n\tcase CTO_NoFor:\n\t\tif (noback) {\n\t\t\tcompileError(file, \"%s already specified.\", _lou_findOpcodeName(CTO_NoBack));\n\t\t\treturn 0;\n\t\t}\n\t\tnofor = 1;\n\t\tgoto doOpcode;\n\tcase CTO_Space:\n\t\treturn compileCharDef(\n\t\t\t\tfile, opcode, CTC_Space, noback, nofor, table, displayTable);\n\tcase CTO_Digit:\n\t\treturn compileCharDef(\n\t\t\t\tfile, opcode, CTC_Digit, noback, nofor, table, displayTable);\n\tcase CTO_LitDigit:\n\t\treturn compileCharDef(\n\t\t\t\tfile, opcode, CTC_LitDigit, noback, nofor, table, displayTable);\n\tcase CTO_Punctuation:\n\t\treturn compileCharDef(\n\t\t\t\tfile, opcode, CTC_Punctuation, noback, nofor, table, displayTable);\n\tcase CTO_Math:\n\t\treturn compileCharDef(file, opcode, CTC_Math, noback, nofor, table, displayTable);\n\tcase CTO_Sign:\n\t\treturn compileCharDef(file, opcode, CTC_Sign, noback, nofor, table, displayTable);\n\tcase CTO_Letter:\n\t\treturn compileCharDef(\n\t\t\t\tfile, opcode, CTC_Letter, noback, nofor, table, displayTable);\n\tcase CTO_UpperCase:\n\t\treturn compileCharDef(\n\t\t\t\tfile, opcode, CTC_UpperCase, noback, nofor, table, displayTable);\n\tcase CTO_LowerCase:\n\t\treturn compileCharDef(\n\t\t\t\tfile, opcode, CTC_LowerCase, noback, nofor, table, displayTable);\n\tcase CTO_Grouping:\n\t\treturn compileGrouping(file, noback, nofor, table, displayTable);\n\tcase CTO_Display:\n\t\tif (!displayTable) return 1;  // ignore\n\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\tif (!getRuleDotsPattern(file, &ruleDots)) return 0;\n\t\tif (ruleChars.length != 1 || ruleDots.length != 1) {\n\t\t\tcompileError(file, \"Exactly one character and one cell are required.\");\n\t\t\treturn 0;\n\t\t}\n\t\treturn putCharDotsMapping(\n\t\t\t\tfile, ruleChars.chars[0], ruleDots.chars[0], displayTable);\n\tcase CTO_UpLow:\n\tcase CTO_None: {\n\t\t// check if token is a macro name\n\t\tif (inScopeMacros) {\n\t\t\tconst MacroList *macros = *inScopeMacros;\n\t\t\twhile (macros) {\n\t\t\t\tconst Macro *m = macros->head;\n\t\t\t\tif (token.length == strlen(m->name) &&\n\t\t\t\t\t\teqasc2uni((unsigned char *)m->name, token.chars, token.length)) {\n\t\t\t\t\tif (!inScopeMacros) {\n\t\t\t\t\t\tcompileError(file, \"Calling macros only allowed in table files.\");\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tFileInfo tmpFile;\n\t\t\t\t\tmemset(&tmpFile, 0, sizeof(tmpFile));\n\t\t\t\t\ttmpFile.fileName = file->fileName;\n\t\t\t\t\ttmpFile.sourceFile = file->sourceFile;\n\t\t\t\t\ttmpFile.lineNumber = file->lineNumber;\n\t\t\t\t\ttmpFile.encoding = noEncoding;\n\t\t\t\t\ttmpFile.status = 0;\n\t\t\t\t\ttmpFile.linepos = 0;\n\t\t\t\t\ttmpFile.linelen = 0;\n\t\t\t\t\tint argument_count = 0;\n\t\t\t\t\tCharsString *arguments =\n\t\t\t\t\t\t\tmalloc(m->argument_count * sizeof(CharsString));\n\t\t\t\t\twhile (argument_count < m->argument_count) {\n\t\t\t\t\t\tif (getToken(file, &token, \"macro argument\"))\n\t\t\t\t\t\t\targuments[argument_count++] = token;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (argument_count < m->argument_count) {\n\t\t\t\t\t\tcompileError(file, \"Expected %d arguments\", m->argument_count);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tint i = 0;\n\t\t\t\t\tint subst = 0;\n\t\t\t\t\tint next = subst < m->substitution_count ? m->substitutions[2 * subst]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t : m->definition_length;\n\t\t\t\t\tfor (;;) {\n\t\t\t\t\t\twhile (i < next) {\n\t\t\t\t\t\t\twidechar c = m->definition[i++];\n\t\t\t\t\t\t\tif (c == '\\n') {\n\t\t\t\t\t\t\t\tif (!compileRule(&tmpFile, table, displayTable,\n\t\t\t\t\t\t\t\t\t\t\tinScopeMacros)) {\n\t\t\t\t\t\t\t\t\t_lou_logMessage(LOU_LOG_ERROR,\n\t\t\t\t\t\t\t\t\t\t\t\"result of macro expansion was: %s\",\n\t\t\t\t\t\t\t\t\t\t\t_lou_showString(\n\t\t\t\t\t\t\t\t\t\t\t\t\ttmpFile.line, tmpFile.linelen, 0));\n\t\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ttmpFile.linepos = 0;\n\t\t\t\t\t\t\t\ttmpFile.linelen = 0;\n\t\t\t\t\t\t\t} else if (tmpFile.linelen >= MAXSTRING) {\n\t\t\t\t\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\t\t\t\t\"Line exceeds %d characters (post macro \"\n\t\t\t\t\t\t\t\t\t\t\"expansion)\",\n\t\t\t\t\t\t\t\t\t\tMAXSTRING);\n\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\ttmpFile.line[tmpFile.linelen++] = c;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (subst < m->substitution_count) {\n\t\t\t\t\t\t\tCharsString arg =\n\t\t\t\t\t\t\t\t\targuments[m->substitutions[2 * subst + 1] - 1];\n\t\t\t\t\t\t\tfor (int j = 0; j < arg.length; j++)\n\t\t\t\t\t\t\t\ttmpFile.line[tmpFile.linelen++] = arg.chars[j];\n\t\t\t\t\t\t\tsubst++;\n\t\t\t\t\t\t\tnext = subst < m->substitution_count\n\t\t\t\t\t\t\t\t\t? m->substitutions[2 * subst]\n\t\t\t\t\t\t\t\t\t: m->definition_length;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (!compileRule(\n\t\t\t\t\t\t\t\t\t\t&tmpFile, table, displayTable, inScopeMacros)) {\n\t\t\t\t\t\t\t\t_lou_logMessage(LOU_LOG_ERROR,\n\t\t\t\t\t\t\t\t\t\t\"result of macro expansion was: %s\",\n\t\t\t\t\t\t\t\t\t\t_lou_showString(\n\t\t\t\t\t\t\t\t\t\t\t\ttmpFile.line, tmpFile.linelen, 0));\n\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tmacros = macros->tail;\n\t\t\t}\n\t\t}\n\t\tif (opcode == CTO_UpLow) {\n\t\t\tcompileError(file, \"The uplow opcode is deprecated.\");\n\t\t\treturn 0;\n\t\t}\n\t\tcompileError(file, \"opcode %s not defined.\",\n\t\t\t\t_lou_showString(token.chars, token.length, 0));\n\t\treturn 0;\n\t}\n\n\t/* now only opcodes follow that don't modify the display table */\n\tdefault:\n\t\tif (!table) return 1;\n\t\tswitch (opcode) {\n\t\tcase CTO_Locale:\n\t\t\tcompileWarning(file,\n\t\t\t\t\t\"The locale opcode is not implemented. Use the locale meta data \"\n\t\t\t\t\t\"instead.\");\n\t\t\treturn 1;\n\t\tcase CTO_Undefined: {\n\t\t\t// not passing pointer because compileBrailleIndicator may reallocate table\n\t\t\tTranslationTableOffset ruleOffset = (*table)->undefined;\n\t\t\tif (!compileBrailleIndicator(file, \"undefined character opcode\",\n\t\t\t\t\t\tCTO_Undefined, &ruleOffset, noback, nofor, table))\n\t\t\t\treturn 0;\n\t\t\t(*table)->undefined = ruleOffset;\n\t\t\treturn 1;\n\t\t}\n\t\tcase CTO_Match: {\n\t\t\tint ok = 0;\n\t\t\twidechar *patterns = NULL;\n\t\t\tTranslationTableRule *rule;\n\t\t\tTranslationTableOffset ruleOffset;\n\t\t\tCharsString ptn_before, ptn_after;\n\t\t\tTranslationTableOffset patternsOffset;\n\t\t\tint len, mrk;\n\t\t\tsize_t patternsByteSize = sizeof(*patterns) * 27720;\n\t\t\tpatterns = (widechar *)malloc(patternsByteSize);\n\t\t\tif (!patterns) _lou_outOfMemory();\n\t\t\tmemset(patterns, 0xffff, patternsByteSize);\n\t\t\tnoback = 1;\n\t\t\tgetCharacters(file, &ptn_before);\n\t\t\tgetRuleCharsText(file, &ruleChars);\n\t\t\tgetCharacters(file, &ptn_after);\n\t\t\tgetRuleDotsPattern(file, &ruleDots);\n\t\t\tif (!addRule(file, opcode, &ruleChars, &ruleDots, after, before, &ruleOffset,\n\t\t\t\t\t\t&rule, noback, nofor, table))\n\t\t\t\tgoto CTO_Match_cleanup;\n\t\t\tif (ptn_before.chars[0] == '-' && ptn_before.length == 1)\n\t\t\t\tlen = _lou_pattern_compile(\n\t\t\t\t\t\t&ptn_before.chars[0], 0, &patterns[1], 13841, *table, file);\n\t\t\telse\n\t\t\t\tlen = _lou_pattern_compile(&ptn_before.chars[0], ptn_before.length,\n\t\t\t\t\t\t&patterns[1], 13841, *table, file);\n\t\t\tif (!len) goto CTO_Match_cleanup;\n\t\t\tmrk = patterns[0] = len + 1;\n\t\t\t_lou_pattern_reverse(&patterns[1]);\n\t\t\tif (ptn_after.chars[0] == '-' && ptn_after.length == 1)\n\t\t\t\tlen = _lou_pattern_compile(\n\t\t\t\t\t\t&ptn_after.chars[0], 0, &patterns[mrk], 13841, *table, file);\n\t\t\telse\n\t\t\t\tlen = _lou_pattern_compile(&ptn_after.chars[0], ptn_after.length,\n\t\t\t\t\t\t&patterns[mrk], 13841, *table, file);\n\t\t\tif (!len) goto CTO_Match_cleanup;\n\t\t\tlen += mrk;\n\t\t\tif (!allocateSpaceInTranslationTable(\n\t\t\t\t\t\tfile, &patternsOffset, len * sizeof(widechar), table))\n\t\t\t\tgoto CTO_Match_cleanup;\n\t\t\t// allocateSpaceInTranslationTable may have moved table, so make sure rule is\n\t\t\t// still valid\n\t\t\trule = (TranslationTableRule *)&(*table)->ruleArea[ruleOffset];\n\t\t\tmemcpy(&(*table)->ruleArea[patternsOffset], patterns, len * sizeof(widechar));\n\t\t\trule->patterns = patternsOffset;\n\t\t\tok = 1;\n\t\tCTO_Match_cleanup:\n\t\t\tfree(patterns);\n\t\t\treturn ok;\n\t\t}\n\n\t\tcase CTO_BackMatch: {\n\t\t\tint ok = 0;\n\t\t\twidechar *patterns = NULL;\n\t\t\tTranslationTableRule *rule;\n\t\t\tTranslationTableOffset ruleOffset;\n\t\t\tCharsString ptn_before, ptn_after;\n\t\t\tTranslationTableOffset patternOffset;\n\t\t\tint len, mrk;\n\t\t\tsize_t patternsByteSize = sizeof(*patterns) * 27720;\n\t\t\tpatterns = (widechar *)malloc(patternsByteSize);\n\t\t\tif (!patterns) _lou_outOfMemory();\n\t\t\tmemset(patterns, 0xffff, patternsByteSize);\n\t\t\tnofor = 1;\n\t\t\tgetCharacters(file, &ptn_before);\n\t\t\tgetRuleCharsText(file, &ruleChars);\n\t\t\tgetCharacters(file, &ptn_after);\n\t\t\tgetRuleDotsPattern(file, &ruleDots);\n\t\t\tif (!addRule(file, opcode, &ruleChars, &ruleDots, 0, 0, &ruleOffset, &rule,\n\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\tgoto CTO_BackMatch_cleanup;\n\t\t\tif (ptn_before.chars[0] == '-' && ptn_before.length == 1)\n\t\t\t\tlen = _lou_pattern_compile(\n\t\t\t\t\t\t&ptn_before.chars[0], 0, &patterns[1], 13841, *table, file);\n\t\t\telse\n\t\t\t\tlen = _lou_pattern_compile(&ptn_before.chars[0], ptn_before.length,\n\t\t\t\t\t\t&patterns[1], 13841, *table, file);\n\t\t\tif (!len) goto CTO_BackMatch_cleanup;\n\t\t\tmrk = patterns[0] = len + 1;\n\t\t\t_lou_pattern_reverse(&patterns[1]);\n\t\t\tif (ptn_after.chars[0] == '-' && ptn_after.length == 1)\n\t\t\t\tlen = _lou_pattern_compile(\n\t\t\t\t\t\t&ptn_after.chars[0], 0, &patterns[mrk], 13841, *table, file);\n\t\t\telse\n\t\t\t\tlen = _lou_pattern_compile(&ptn_after.chars[0], ptn_after.length,\n\t\t\t\t\t\t&patterns[mrk], 13841, *table, file);\n\t\t\tif (!len) goto CTO_BackMatch_cleanup;\n\t\t\tlen += mrk;\n\t\t\tif (!allocateSpaceInTranslationTable(\n\t\t\t\t\t\tfile, &patternOffset, len * sizeof(widechar), table))\n\t\t\t\tgoto CTO_BackMatch_cleanup;\n\t\t\t// allocateSpaceInTranslationTable may have moved table, so make sure rule is\n\t\t\t// still valid\n\t\t\trule = (TranslationTableRule *)&(*table)->ruleArea[ruleOffset];\n\t\t\tmemcpy(&(*table)->ruleArea[patternOffset], patterns, len * sizeof(widechar));\n\t\t\trule->patterns = patternOffset;\n\t\t\tok = 1;\n\t\tCTO_BackMatch_cleanup:\n\t\t\tfree(patterns);\n\t\t\treturn ok;\n\t\t}\n\n\t\tcase CTO_CapsLetter:\n\t\tcase CTO_BegCapsWord:\n\t\tcase CTO_EndCapsWord:\n\t\tcase CTO_BegCaps:\n\t\tcase CTO_EndCaps:\n\t\tcase CTO_BegCapsPhrase:\n\t\tcase CTO_EndCapsPhrase:\n\t\tcase CTO_LenCapsPhrase:\n\t\t/* these 8 general purpose opcodes are compiled further down to more specific\n\t\t * internal opcodes:\n\t\t * - modeletter\n\t\t * - begmodeword\n\t\t * - endmodeword\n\t\t * - begmode\n\t\t * - endmode\n\t\t * - begmodephrase\n\t\t * - endmodephrase\n\t\t * - lenmodephrase\n\t\t */\n\t\tcase CTO_ModeLetter:\n\t\tcase CTO_BegModeWord:\n\t\tcase CTO_EndModeWord:\n\t\tcase CTO_BegMode:\n\t\tcase CTO_EndMode:\n\t\tcase CTO_BegModePhrase:\n\t\tcase CTO_EndModePhrase:\n\t\tcase CTO_LenModePhrase: {\n\t\t\tTranslationTableCharacterAttributes mode;\n\t\t\tint i;\n\t\t\tswitch (opcode) {\n\t\t\tcase CTO_CapsLetter:\n\t\t\tcase CTO_BegCapsWord:\n\t\t\tcase CTO_EndCapsWord:\n\t\t\tcase CTO_BegCaps:\n\t\t\tcase CTO_EndCaps:\n\t\t\tcase CTO_BegCapsPhrase:\n\t\t\tcase CTO_EndCapsPhrase:\n\t\t\tcase CTO_LenCapsPhrase:\n\t\t\t\tmode = CTC_UpperCase;\n\t\t\t\ti = 0;\n\t\t\t\topcode += (CTO_ModeLetter - CTO_CapsLetter);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (!getToken(file, &token, \"attribute name\")) return 0;\n\t\t\t\tif (!(*table)->characterClasses && !allocateCharacterClasses(*table)) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tconst CharacterClass *characterClass = findCharacterClass(&token, *table);\n\t\t\t\tif (!characterClass) {\n\t\t\t\t\tcharacterClass =\n\t\t\t\t\t\t\taddCharacterClass(file, token.chars, token.length, *table, 1);\n\t\t\t\t\tif (!characterClass) return 0;\n\t\t\t\t}\n\t\t\t\tmode = characterClass->attribute;\n\t\t\t\tif (!(mode == CTC_UpperCase || mode == CTC_Digit) && mode >= CTC_Space &&\n\t\t\t\t\t\tmode <= CTC_LitDigit) {\n\t\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\t\"mode must be \\\"uppercase\\\", \\\"digit\\\", or a custom \"\n\t\t\t\t\t\t\t\"attribute name.\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\t/* check if this mode is already defined and if the number of modes does\n\t\t\t\t * not exceed the maximal number */\n\t\t\t\tif (mode == CTC_UpperCase)\n\t\t\t\t\ti = 0;\n\t\t\t\telse {\n\t\t\t\t\tfor (i = 1; i < MAX_MODES && (*table)->modes[i].value; i++) {\n\t\t\t\t\t\tif ((*table)->modes[i].mode == mode) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (i == MAX_MODES) {\n\t\t\t\t\t\tcompileError(file, \"Max number of modes (%i) reached\", MAX_MODES);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!(*table)->modes[i].value)\n\t\t\t\t(*table)->modes[i] = (EmphasisClass){ plain_text, mode,\n\t\t\t\t\t0x1 << (MAX_EMPH_CLASSES + i), MAX_EMPH_CLASSES + i };\n\t\t\tswitch (opcode) {\n\t\t\tcase CTO_BegModePhrase: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset =\n\t\t\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][begPhraseOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"first word capital sign\",\n\t\t\t\t\t\t\tCTO_BegCapsPhraseRule + (8 * i), &ruleOffset, noback, nofor,\n\t\t\t\t\t\t\ttable))\n\t\t\t\t\treturn 0;\n\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][begPhraseOffset] = ruleOffset;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tcase CTO_EndModePhrase: {\n\t\t\t\tTranslationTableOffset ruleOffset;\n\t\t\t\tswitch (compileBeforeAfter(file)) {\n\t\t\t\tcase 1:\t // before\n\t\t\t\t\tif ((*table)->emphRules[MAX_EMPH_CLASSES + i][endPhraseAfterOffset]) {\n\t\t\t\t\t\tcompileError(\n\t\t\t\t\t\t\t\tfile, \"Capital sign after last word already defined.\");\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t\t// table\n\t\t\t\t\truleOffset = (*table)->emphRules[MAX_EMPH_CLASSES + i]\n\t\t\t\t\t\t\t\t\t\t\t\t\t[endPhraseBeforeOffset];\n\t\t\t\t\tif (!compileBrailleIndicator(file, \"capital sign before last word\",\n\t\t\t\t\t\t\t\tCTO_EndCapsPhraseBeforeRule + (8 * i), &ruleOffset,\n\t\t\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][endPhraseBeforeOffset] =\n\t\t\t\t\t\t\truleOffset;\n\t\t\t\t\treturn 1;\n\t\t\t\tcase 2:\t // after\n\t\t\t\t\tif ((*table)->emphRules[MAX_EMPH_CLASSES + i]\n\t\t\t\t\t\t\t\t\t\t   [endPhraseBeforeOffset]) {\n\t\t\t\t\t\tcompileError(\n\t\t\t\t\t\t\t\tfile, \"Capital sign before last word already defined.\");\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t\t// table\n\t\t\t\t\truleOffset = (*table)->emphRules[MAX_EMPH_CLASSES + i]\n\t\t\t\t\t\t\t\t\t\t\t\t\t[endPhraseAfterOffset];\n\t\t\t\t\tif (!compileBrailleIndicator(file, \"capital sign after last word\",\n\t\t\t\t\t\t\t\tCTO_EndCapsPhraseAfterRule + (8 * i), &ruleOffset, noback,\n\t\t\t\t\t\t\t\tnofor, table))\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][endPhraseAfterOffset] =\n\t\t\t\t\t\t\truleOffset;\n\t\t\t\t\treturn 1;\n\t\t\t\tdefault:  // error\n\t\t\t\t\tcompileError(file, \"Invalid lastword indicator location.\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcase CTO_BegMode: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset =\n\t\t\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][begOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"first letter capital sign\",\n\t\t\t\t\t\t\tCTO_BegCapsRule + (8 * i), &ruleOffset, noback, nofor, table))\n\t\t\t\t\treturn 0;\n\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][begOffset] = ruleOffset;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tcase CTO_EndMode: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset =\n\t\t\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][endOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"last letter capital sign\",\n\t\t\t\t\t\t\tCTO_EndCapsRule + (8 * i), &ruleOffset, noback, nofor, table))\n\t\t\t\t\treturn 0;\n\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][endOffset] = ruleOffset;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tcase CTO_ModeLetter: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset =\n\t\t\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][letterOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"single letter capital sign\",\n\t\t\t\t\t\t\tCTO_CapsLetterRule + (8 * i), &ruleOffset, noback, nofor,\n\t\t\t\t\t\t\ttable))\n\t\t\t\t\treturn 0;\n\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][letterOffset] = ruleOffset;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tcase CTO_BegModeWord: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset =\n\t\t\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][begWordOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"capital word\",\n\t\t\t\t\t\t\tCTO_BegCapsWordRule + (8 * i), &ruleOffset, noback, nofor,\n\t\t\t\t\t\t\ttable))\n\t\t\t\t\treturn 0;\n\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][begWordOffset] = ruleOffset;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tcase CTO_EndModeWord: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset =\n\t\t\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][endWordOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"capital word stop\",\n\t\t\t\t\t\t\tCTO_EndCapsWordRule + (8 * i), &ruleOffset, noback, nofor,\n\t\t\t\t\t\t\ttable))\n\t\t\t\t\treturn 0;\n\t\t\t\t(*table)->emphRules[MAX_EMPH_CLASSES + i][endWordOffset] = ruleOffset;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tcase CTO_LenModePhrase:\n\t\t\t\treturn (*table)->emphRules[MAX_EMPH_CLASSES + i][lenPhraseOffset] =\n\t\t\t\t\t\t\t   compileNumber(file);\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t/* these 8 general purpose emphasis opcodes are compiled further down to more\n\t\t * specific internal opcodes:\n\t\t * - emphletter\n\t\t * - begemphword\n\t\t * - endemphword\n\t\t * - begemph\n\t\t * - endemph\n\t\t * - begemphphrase\n\t\t * - endemphphrase\n\t\t * - lenemphphrase\n\t\t */\n\t\tcase CTO_EmphClass:\n\t\t\tif (!getToken(file, &emphClass, \"emphasis class\")) {\n\t\t\t\tcompileError(file, \"emphclass must be followed by a valid class name.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tint k, i;\n\t\t\tchar *s = malloc(sizeof(char) * (emphClass.length + 1));\n\t\t\tfor (k = 0; k < emphClass.length; k++) s[k] = (char)emphClass.chars[k];\n\t\t\ts[k++] = '\\0';\n\t\t\tfor (i = 0; i < MAX_EMPH_CLASSES && (*table)->emphClassNames[i]; i++)\n\t\t\t\tif (strcmp(s, (*table)->emphClassNames[i]) == 0) {\n\t\t\t\t\t_lou_logMessage(LOU_LOG_WARN, \"Duplicate emphasis class: %s\", s);\n\t\t\t\t\twarningCount++;\n\t\t\t\t\tfree(s);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\tif (i == MAX_EMPH_CLASSES) {\n\t\t\t\t_lou_logMessage(LOU_LOG_ERROR,\n\t\t\t\t\t\t\"Max number of emphasis classes (%i) reached\", MAX_EMPH_CLASSES);\n\t\t\t\terrorCount++;\n\t\t\t\tfree(s);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tswitch (i) {\n\t\t\t/* For backwards compatibility (i.e. because programs will assume\n\t\t\t * the first 3 typeform bits are `italic', `underline' and `bold')\n\t\t\t * we require that the first 3 emphclass definitions are (in that\n\t\t\t * order):\n\t\t\t *\n\t\t\t *   emphclass italic\n\t\t\t *   emphclass underline\n\t\t\t *   emphclass bold\n\t\t\t *\n\t\t\t * While it would be possible to use the emphclass opcode only for\n\t\t\t * defining _additional_ classes (not allowing for them to be called\n\t\t\t * italic, underline or bold), thereby reducing the amount of\n\t\t\t * boilerplate, we deliberately choose not to do that in order to\n\t\t\t * not give italic, underline and bold any special status. The\n\t\t\t * hope is that eventually all programs will use liblouis for\n\t\t\t * emphasis the recommended way (i.e. by looking up the supported\n\t\t\t * typeforms in the documentation or API) so that we can drop this\n\t\t\t * restriction.\n\t\t\t */\n\t\t\tcase 0:\n\t\t\t\tif (strcmp(s, \"italic\") != 0) {\n\t\t\t\t\t_lou_logMessage(LOU_LOG_ERROR,\n\t\t\t\t\t\t\t\"First emphasis class must be \\\"italic\\\" but got \"\n\t\t\t\t\t\t\t\"%s\",\n\t\t\t\t\t\t\ts);\n\t\t\t\t\terrorCount++;\n\t\t\t\t\tfree(s);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tif (strcmp(s, \"underline\") != 0) {\n\t\t\t\t\t_lou_logMessage(LOU_LOG_ERROR,\n\t\t\t\t\t\t\t\"Second emphasis class must be \\\"underline\\\" but \"\n\t\t\t\t\t\t\t\"got \"\n\t\t\t\t\t\t\t\"%s\",\n\t\t\t\t\t\t\ts);\n\t\t\t\t\terrorCount++;\n\t\t\t\t\tfree(s);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tif (strcmp(s, \"bold\") != 0) {\n\t\t\t\t\t_lou_logMessage(LOU_LOG_ERROR,\n\t\t\t\t\t\t\t\"Third emphasis class must be \\\"bold\\\" but got \"\n\t\t\t\t\t\t\t\"%s\",\n\t\t\t\t\t\t\ts);\n\t\t\t\t\terrorCount++;\n\t\t\t\t\tfree(s);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t(*table)->emphClassNames[i] = s;\n\t\t\t(*table)->emphClasses[i] = (EmphasisClass){ emph_1\n\t\t\t\t\t\t<< i, /* relies on the order of typeforms emph_1..emph_10 */\n\t\t\t\t0, 0x1 << i, i };\n\t\t\treturn 1;\n\t\tcase CTO_EmphLetter:\n\t\tcase CTO_BegEmphWord:\n\t\tcase CTO_EndEmphWord:\n\t\tcase CTO_BegEmph:\n\t\tcase CTO_EndEmph:\n\t\tcase CTO_BegEmphPhrase:\n\t\tcase CTO_EndEmphPhrase:\n\t\tcase CTO_LenEmphPhrase:\n\t\tcase CTO_EmphModeChars:\n\t\tcase CTO_NoEmphChars: {\n\t\t\tif (!getToken(file, &token, \"emphasis class\")) return 0;\n\t\t\tif (!parseChars(file, &emphClass, &token)) return 0;\n\t\t\tchar *s = malloc(sizeof(char) * (emphClass.length + 1));\n\t\t\tint k, i;\n\t\t\tfor (k = 0; k < emphClass.length; k++) s[k] = (char)emphClass.chars[k];\n\t\t\ts[k++] = '\\0';\n\t\t\tfor (i = 0; i < MAX_EMPH_CLASSES && (*table)->emphClassNames[i]; i++)\n\t\t\t\tif (strcmp(s, (*table)->emphClassNames[i]) == 0) break;\n\t\t\tif (i == MAX_EMPH_CLASSES || !(*table)->emphClassNames[i]) {\n\t\t\t\t_lou_logMessage(LOU_LOG_ERROR, \"Emphasis class %s not declared\", s);\n\t\t\t\terrorCount++;\n\t\t\t\tfree(s);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tint ok = 0;\n\t\t\tswitch (opcode) {\n\t\t\tcase CTO_EmphLetter: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset = (*table)->emphRules[i][letterOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"single letter\",\n\t\t\t\t\t\t\tCTO_Emph1LetterRule + letterOffset + (8 * i), &ruleOffset,\n\t\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\t\tbreak;\n\t\t\t\t(*table)->emphRules[i][letterOffset] = ruleOffset;\n\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CTO_BegEmphWord: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset = (*table)->emphRules[i][begWordOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"word\",\n\t\t\t\t\t\t\tCTO_Emph1LetterRule + begWordOffset + (8 * i), &ruleOffset,\n\t\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\t\tbreak;\n\t\t\t\t(*table)->emphRules[i][begWordOffset] = ruleOffset;\n\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CTO_EndEmphWord: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset = (*table)->emphRules[i][endWordOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"word stop\",\n\t\t\t\t\t\t\tCTO_Emph1LetterRule + endWordOffset + (8 * i), &ruleOffset,\n\t\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\t\tbreak;\n\t\t\t\t(*table)->emphRules[i][endWordOffset] = ruleOffset;\n\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CTO_BegEmph: {\n\t\t\t\t/* fail if both begemph and any of begemphphrase or begemphword are\n\t\t\t\t * defined */\n\t\t\t\tif ((*table)->emphRules[i][begWordOffset] ||\n\t\t\t\t\t\t(*table)->emphRules[i][begPhraseOffset]) {\n\t\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\t\"Cannot define emphasis for both no context and word or \"\n\t\t\t\t\t\t\t\"phrase context, i.e. cannot have both begemph and \"\n\t\t\t\t\t\t\t\"begemphword or begemphphrase.\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset = (*table)->emphRules[i][begOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"first letter\",\n\t\t\t\t\t\t\tCTO_Emph1LetterRule + begOffset + (8 * i), &ruleOffset,\n\t\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\t\tbreak;\n\t\t\t\t(*table)->emphRules[i][begOffset] = ruleOffset;\n\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CTO_EndEmph: {\n\t\t\t\tif ((*table)->emphRules[i][endWordOffset] ||\n\t\t\t\t\t\t(*table)->emphRules[i][endPhraseBeforeOffset] ||\n\t\t\t\t\t\t(*table)->emphRules[i][endPhraseAfterOffset]) {\n\t\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\t\"Cannot define emphasis for both no context and word or \"\n\t\t\t\t\t\t\t\"phrase context, i.e. cannot have both endemph and \"\n\t\t\t\t\t\t\t\"endemphword or endemphphrase.\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset = (*table)->emphRules[i][endOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"last letter\",\n\t\t\t\t\t\t\tCTO_Emph1LetterRule + endOffset + (8 * i), &ruleOffset,\n\t\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\t\tbreak;\n\t\t\t\t(*table)->emphRules[i][endOffset] = ruleOffset;\n\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CTO_BegEmphPhrase: {\n\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t// table\n\t\t\t\tTranslationTableOffset ruleOffset =\n\t\t\t\t\t\t(*table)->emphRules[i][begPhraseOffset];\n\t\t\t\tif (!compileBrailleIndicator(file, \"first word\",\n\t\t\t\t\t\t\tCTO_Emph1LetterRule + begPhraseOffset + (8 * i), &ruleOffset,\n\t\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\t\tbreak;\n\t\t\t\t(*table)->emphRules[i][begPhraseOffset] = ruleOffset;\n\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CTO_EndEmphPhrase:\n\t\t\t\tswitch (compileBeforeAfter(file)) {\n\t\t\t\tcase 1: {  // before\n\t\t\t\t\tif ((*table)->emphRules[i][endPhraseAfterOffset]) {\n\t\t\t\t\t\tcompileError(file, \"last word after already defined.\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t\t// table\n\t\t\t\t\tTranslationTableOffset ruleOffset =\n\t\t\t\t\t\t\t(*table)->emphRules[i][endPhraseBeforeOffset];\n\t\t\t\t\tif (!compileBrailleIndicator(file, \"last word before\",\n\t\t\t\t\t\t\t\tCTO_Emph1LetterRule + endPhraseBeforeOffset + (8 * i),\n\t\t\t\t\t\t\t\t&ruleOffset, noback, nofor, table))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t(*table)->emphRules[i][endPhraseBeforeOffset] = ruleOffset;\n\t\t\t\t\tok = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 2: {  // after\n\t\t\t\t\tif ((*table)->emphRules[i][endPhraseBeforeOffset]) {\n\t\t\t\t\t\tcompileError(file, \"last word before already defined.\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// not passing pointer because compileBrailleIndicator may reallocate\n\t\t\t\t\t// table\n\t\t\t\t\tTranslationTableOffset ruleOffset =\n\t\t\t\t\t\t\t(*table)->emphRules[i][endPhraseAfterOffset];\n\t\t\t\t\tif (!compileBrailleIndicator(file, \"last word after\",\n\t\t\t\t\t\t\t\tCTO_Emph1LetterRule + endPhraseAfterOffset + (8 * i),\n\t\t\t\t\t\t\t\t&ruleOffset, noback, nofor, table))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t(*table)->emphRules[i][endPhraseAfterOffset] = ruleOffset;\n\t\t\t\t\tok = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdefault:  // error\n\t\t\t\t\tcompileError(file, \"Invalid lastword indicator location.\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase CTO_LenEmphPhrase:\n\t\t\t\tif (((*table)->emphRules[i][lenPhraseOffset] = compileNumber(file)))\n\t\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\tcase CTO_EmphModeChars: {\n\t\t\t\tif (!getRuleCharsText(file, &ruleChars)) break;\n\t\t\t\twidechar *emphmodechars = (*table)->emphModeChars[i];\n\t\t\t\tint len;\n\t\t\t\tfor (len = 0; len < EMPHMODECHARSSIZE && emphmodechars[len]; len++)\n\t\t\t\t\t;\n\t\t\t\tif (len + ruleChars.length > EMPHMODECHARSSIZE) {\n\t\t\t\t\tcompileError(file, \"More than %d characters\", EMPHMODECHARSSIZE);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tok = 1;\n\t\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\t\tif (!getChar(ruleChars.chars[k], *table, NULL)) {\n\t\t\t\t\t\tcompileError(file, \"Emphasis mode character undefined\");\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\temphmodechars[len++] = ruleChars.chars[k];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase CTO_NoEmphChars: {\n\t\t\t\tif (!getRuleCharsText(file, &ruleChars)) break;\n\t\t\t\twidechar *noemphchars = (*table)->noEmphChars[i];\n\t\t\t\tint len;\n\t\t\t\tfor (len = 0; len < NOEMPHCHARSSIZE && noemphchars[len]; len++)\n\t\t\t\t\t;\n\t\t\t\tif (len + ruleChars.length > NOEMPHCHARSSIZE) {\n\t\t\t\t\tcompileError(file, \"More than %d characters\", NOEMPHCHARSSIZE);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tok = 1;\n\t\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\t\tif (!getChar(ruleChars.chars[k], *table, NULL)) {\n\t\t\t\t\t\tcompileError(file, \"Character undefined\");\n\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tnoemphchars[len++] = ruleChars.chars[k];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfree(s);\n\t\t\treturn ok;\n\t\t}\n\t\tcase CTO_LetterSign: {\n\t\t\t// not passing pointer because compileBrailleIndicator may reallocate table\n\t\t\tTranslationTableOffset ruleOffset = (*table)->letterSign;\n\t\t\tif (!compileBrailleIndicator(file, \"letter sign\", CTO_LetterRule, &ruleOffset,\n\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\treturn 0;\n\t\t\t(*table)->letterSign = ruleOffset;\n\t\t\treturn 1;\n\t\t}\n\t\tcase CTO_NoLetsignBefore:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tif (((*table)->noLetsignBeforeCount + ruleChars.length) > LETSIGNBEFORESIZE) {\n\t\t\t\tcompileError(file, \"More than %d characters\", LETSIGNBEFORESIZE);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tfor (int k = 0; k < ruleChars.length; k++)\n\t\t\t\t(*table)->noLetsignBefore[(*table)->noLetsignBeforeCount++] =\n\t\t\t\t\t\truleChars.chars[k];\n\t\t\treturn 1;\n\t\tcase CTO_NoLetsign:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tif (((*table)->noLetsignCount + ruleChars.length) > LETSIGNSIZE) {\n\t\t\t\tcompileError(file, \"More than %d characters\", LETSIGNSIZE);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tfor (int k = 0; k < ruleChars.length; k++)\n\t\t\t\t(*table)->noLetsign[(*table)->noLetsignCount++] = ruleChars.chars[k];\n\t\t\treturn 1;\n\t\tcase CTO_NoLetsignAfter:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tif (((*table)->noLetsignAfterCount + ruleChars.length) > LETSIGNAFTERSIZE) {\n\t\t\t\tcompileError(file, \"More than %d characters\", LETSIGNAFTERSIZE);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tfor (int k = 0; k < ruleChars.length; k++)\n\t\t\t\t(*table)->noLetsignAfter[(*table)->noLetsignAfterCount++] =\n\t\t\t\t\t\truleChars.chars[k];\n\t\t\treturn 1;\n\t\tcase CTO_NumberSign: {\n\t\t\t// not passing pointer because compileBrailleIndicator may reallocate table\n\t\t\tTranslationTableOffset ruleOffset = (*table)->numberSign;\n\t\t\tif (!compileBrailleIndicator(file, \"number sign\", CTO_NumberRule, &ruleOffset,\n\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\treturn 0;\n\t\t\t(*table)->numberSign = ruleOffset;\n\t\t\treturn 1;\n\t\t}\n\n\t\tcase CTO_NumericModeChars:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\tTranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);\n\t\t\t\tif (!c) {\n\t\t\t\t\tcompileError(file, \"Numeric mode character undefined: %s\",\n\t\t\t\t\t\t\t_lou_showString(&ruleChars.chars[k], 1, 0));\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tc->attributes |= CTC_NumericMode;\n\t\t\t\t(*table)->usesNumericMode = 1;\n\t\t\t}\n\t\t\treturn 1;\n\n\t\tcase CTO_MidEndNumericModeChars:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\tTranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);\n\t\t\t\tif (!c) {\n\t\t\t\t\tcompileError(file, \"Midendnumeric mode character undefined\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tc->attributes |= CTC_MidEndNumericMode;\n\t\t\t\t(*table)->usesNumericMode = 1;\n\t\t\t}\n\t\t\treturn 1;\n\n\t\tcase CTO_NumericNoContractChars:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\tTranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);\n\t\t\t\tif (!c) {\n\t\t\t\t\tcompileError(file, \"Numeric no contraction character undefined\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tc->attributes |= CTC_NumericNoContract;\n\t\t\t\t(*table)->usesNumericMode = 1;\n\t\t\t}\n\t\t\treturn 1;\n\n\t\tcase CTO_NoContractSign: {\n\t\t\t// not passing pointer because compileBrailleIndicator may reallocate table\n\t\t\tTranslationTableOffset ruleOffset = (*table)->noContractSign;\n\t\t\tif (!compileBrailleIndicator(file, \"no contractions sign\", CTO_NoContractRule,\n\t\t\t\t\t\t&ruleOffset, noback, nofor, table))\n\t\t\t\treturn 0;\n\t\t\t(*table)->noContractSign = ruleOffset;\n\t\t\treturn 1;\n\t\t}\n\t\tcase CTO_SeqDelimiter:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\tTranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);\n\t\t\t\tif (!c) {\n\t\t\t\t\tcompileError(file, \"Sequence delimiter character undefined\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tc->attributes |= CTC_SeqDelimiter;\n\t\t\t\t(*table)->usesSequences = 1;\n\t\t\t}\n\t\t\treturn 1;\n\n\t\tcase CTO_SeqBeforeChars:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\tTranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);\n\t\t\t\tif (!c) {\n\t\t\t\t\tcompileError(file, \"Sequence before character undefined\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tc->attributes |= CTC_SeqBefore;\n\t\t\t}\n\t\t\treturn 1;\n\n\t\tcase CTO_SeqAfterChars:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\tTranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);\n\t\t\t\tif (!c) {\n\t\t\t\t\tcompileError(file, \"Sequence after character undefined\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tc->attributes |= CTC_SeqAfter;\n\t\t\t}\n\t\t\treturn 1;\n\n\t\tcase CTO_SeqAfterPattern:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tif (((*table)->seqPatternsCount + ruleChars.length + 1) > SEQPATTERNSIZE) {\n\t\t\t\tcompileError(file, \"More than %d characters\", SEQPATTERNSIZE);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tfor (int k = 0; k < ruleChars.length; k++)\n\t\t\t\t(*table)->seqPatterns[(*table)->seqPatternsCount++] = ruleChars.chars[k];\n\t\t\t(*table)->seqPatterns[(*table)->seqPatternsCount++] = 0;\n\t\t\treturn 1;\n\n\t\tcase CTO_SeqAfterExpression:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tif ((ruleChars.length + 1) > SEQPATTERNSIZE) {\n\t\t\t\tcompileError(file, \"More than %d characters\", SEQPATTERNSIZE);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tfor (int k = 0; k < ruleChars.length; k++)\n\t\t\t\t(*table)->seqAfterExpression[k] = ruleChars.chars[k];\n\t\t\t(*table)->seqAfterExpression[ruleChars.length] = 0;\n\t\t\t(*table)->seqAfterExpressionLength = ruleChars.length;\n\t\t\treturn 1;\n\n\t\tcase CTO_CapsModeChars:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\tTranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);\n\t\t\t\tif (!c) {\n\t\t\t\t\tcompileError(file, \"Capital mode character undefined\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tc->attributes |= CTC_CapsMode;\n\t\t\t\t(*table)->hasCapsModeChars = 1;\n\t\t\t}\n\t\t\treturn 1;\n\n\t\tcase CTO_BegComp: {\n\t\t\t// not passing pointer because compileBrailleIndicator may reallocate table\n\t\t\tTranslationTableOffset ruleOffset = (*table)->begComp;\n\t\t\tif (!compileBrailleIndicator(file, \"begin computer braille\", CTO_BegCompRule,\n\t\t\t\t\t\t&ruleOffset, noback, nofor, table))\n\t\t\t\treturn 0;\n\t\t\t(*table)->begComp = ruleOffset;\n\t\t\treturn 1;\n\t\t}\n\t\tcase CTO_EndComp: {\n\t\t\t// not passing pointer because compileBrailleIndicator may reallocate table\n\t\t\tTranslationTableOffset ruleOffset = (*table)->endComp;\n\t\t\tif (!compileBrailleIndicator(file, \"end computer braslle\", CTO_EndCompRule,\n\t\t\t\t\t\t&ruleOffset, noback, nofor, table))\n\t\t\t\treturn 0;\n\t\t\t(*table)->endComp = ruleOffset;\n\t\t\treturn 1;\n\t\t}\n\t\tcase CTO_NoCross:\n\t\t\tif (nocross) {\n\t\t\t\tcompileError(\n\t\t\t\t\t\tfile, \"%s already specified.\", _lou_findOpcodeName(CTO_NoCross));\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tnocross = 1;\n\t\t\tgoto doOpcode;\n\t\tcase CTO_Syllable:\n\t\t\t(*table)->syllables = 1;\n\t\tcase CTO_Always:\n\t\tcase CTO_LargeSign:\n\t\tcase CTO_WholeWord:\n\t\tcase CTO_PartWord:\n\t\tcase CTO_JoinNum:\n\t\tcase CTO_JoinableWord:\n\t\tcase CTO_LowWord:\n\t\tcase CTO_SuffixableWord:\n\t\tcase CTO_PrefixableWord:\n\t\tcase CTO_BegWord:\n\t\tcase CTO_BegMidWord:\n\t\tcase CTO_MidWord:\n\t\tcase CTO_MidEndWord:\n\t\tcase CTO_EndWord:\n\t\tcase CTO_PrePunc:\n\t\tcase CTO_PostPunc:\n\t\tcase CTO_BegNum:\n\t\tcase CTO_MidNum:\n\t\tcase CTO_EndNum:\n\t\tcase CTO_Repeated:\n\t\tcase CTO_RepWord:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tif (!getRuleDotsPattern(file, &ruleDots)) return 0;\n\t\t\tif (ruleDots.length == 0)\n\t\t\t\t// check that all characters in a rule with `=` as second operand are\n\t\t\t\t// defined (or based on another character)\n\t\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\t\tTranslationTableCharacter *c =\n\t\t\t\t\t\t\tgetChar(ruleChars.chars[k], *table, NULL);\n\t\t\t\t\tif (!(c && (c->definitionRule || c->basechar))) {\n\t\t\t\t\t\tcompileError(file, \"Character %s is not defined\",\n\t\t\t\t\t\t\t\t_lou_showString(&ruleChars.chars[k], 1, 0));\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tTranslationTableRule *r;\n\t\t\tif (!addRule(file, opcode, &ruleChars, &ruleDots, after, before, NULL, &r,\n\t\t\t\t\t\tnoback, nofor, table))\n\t\t\t\treturn 0;\n\t\t\tif (nocross) r->nocross = 1;\n\t\t\treturn 1;\n\t\t\t// if (opcode == CTO_MidNum)\n\t\t\t// {\n\t\t\t//   TranslationTableCharacter *c = getChar(ruleChars.chars[0]);\n\t\t\t//   if(c)\n\t\t\t//     c->attributes |= CTC_NumericMode;\n\t\t\t// }\n\t\tcase CTO_RepEndWord:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tCharsString dots;\n\t\t\tif (!getToken(file, &dots, \"dots,dots operand\")) return 0;\n\t\t\tint len = dots.length;\n\t\t\tfor (int k = 0; k < len - 1; k++) {\n\t\t\t\tif (dots.chars[k] == ',') {\n\t\t\t\t\tdots.length = k;\n\t\t\t\t\tif (!parseDots(file, &ruleDots, &dots)) return 0;\n\t\t\t\t\truleDots.chars[ruleDots.length++] = ',';\n\t\t\t\t\tk++;\n\t\t\t\t\tif (k == len - 1 && dots.chars[k] == '=') {\n\t\t\t\t\t\t// check that all characters are defined (or based on another\n\t\t\t\t\t\t// character)\n\t\t\t\t\t\tfor (int l = 0; l < ruleChars.length; l++) {\n\t\t\t\t\t\t\tTranslationTableCharacter *c =\n\t\t\t\t\t\t\t\t\tgetChar(ruleChars.chars[l], *table, NULL);\n\t\t\t\t\t\t\tif (!(c && (c->definitionRule || c->basechar))) {\n\t\t\t\t\t\t\t\tcompileError(file, \"Character %s is not defined\",\n\t\t\t\t\t\t\t\t\t\t_lou_showString(&ruleChars.chars[l], 1, 0));\n\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tCharsString x, y;\n\t\t\t\t\t\tx.length = 0;\n\t\t\t\t\t\twhile (k < len) x.chars[x.length++] = dots.chars[k++];\n\t\t\t\t\t\tif (parseDots(file, &y, &x))\n\t\t\t\t\t\t\tfor (int l = 0; l < y.length; l++)\n\t\t\t\t\t\t\t\truleDots.chars[ruleDots.length++] = y.chars[l];\n\t\t\t\t\t}\n\t\t\t\t\treturn addRule(file, opcode, &ruleChars, &ruleDots, after, before,\n\t\t\t\t\t\t\tNULL, NULL, noback, nofor, table);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\tcase CTO_CompDots:\n\t\tcase CTO_Comp6: {\n\t\t\tTranslationTableOffset ruleOffset;\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tif (ruleChars.length != 1) {\n\t\t\t\tcompileError(file, \"first operand must be 1 character\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (nofor || noback) {\n\t\t\t\tcompileWarning(file, \"nofor and noback not allowed on comp6 rules\");\n\t\t\t}\n\t\t\tif (!getRuleDotsPattern(file, &ruleDots)) return 0;\n\t\t\tif (!addRule(file, opcode, &ruleChars, &ruleDots, after, before, &ruleOffset,\n\t\t\t\t\t\tNULL, noback, nofor, table))\n\t\t\t\treturn 0;\n\t\t\treturn 1;\n\t\t}\n\t\tcase CTO_ExactDots:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tif (ruleChars.chars[0] != '@') {\n\t\t\t\tcompileError(file, \"The operand must begin with an at sign (@)\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tfor (int k = 1; k < ruleChars.length; k++)\n\t\t\t\tscratchPad.chars[k - 1] = ruleChars.chars[k];\n\t\t\tscratchPad.length = ruleChars.length - 1;\n\t\t\tif (!parseDots(file, &ruleDots, &scratchPad)) return 0;\n\t\t\treturn addRule(file, opcode, &ruleChars, &ruleDots, before, after, NULL, NULL,\n\t\t\t\t\tnoback, nofor, table);\n\t\tcase CTO_CapsNoCont: {\n\t\t\tTranslationTableOffset ruleOffset;\n\t\t\truleChars.length = 1;\n\t\t\truleChars.chars[0] = 'a';\n\t\t\tif (!addRule(file, CTO_CapsNoContRule, &ruleChars, NULL, after, before,\n\t\t\t\t\t\t&ruleOffset, NULL, noback, nofor, table))\n\t\t\t\treturn 0;\n\t\t\t(*table)->capsNoCont = ruleOffset;\n\t\t\treturn 1;\n\t\t}\n\t\tcase CTO_Replace:\n\t\t\tif (getRuleCharsText(file, &ruleChars)) {\n\t\t\t\tif (atEndOfLine(file))\n\t\t\t\t\truleDots.length = ruleDots.chars[0] = 0;\n\t\t\t\telse {\n\t\t\t\t\tgetRuleDotsText(file, &ruleDots);\n\t\t\t\t\tif (ruleDots.chars[0] == '#')\n\t\t\t\t\t\truleDots.length = ruleDots.chars[0] = 0;\n\t\t\t\t\telse if (ruleDots.chars[0] == '\\\\' && ruleDots.chars[1] == '#')\n\t\t\t\t\t\tmemmove(&ruleDots.chars[0], &ruleDots.chars[1],\n\t\t\t\t\t\t\t\truleDots.length-- * CHARSIZE);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int k = 0; k < ruleChars.length; k++)\n\t\t\t\tputChar(file, ruleChars.chars[k], table, NULL);\n\t\t\tfor (int k = 0; k < ruleDots.length; k++)\n\t\t\t\tputChar(file, ruleDots.chars[k], table, NULL);\n\t\t\treturn addRule(file, opcode, &ruleChars, &ruleDots, after, before, NULL, NULL,\n\t\t\t\t\tnoback, nofor, table);\n\t\tcase CTO_Correct:\n\t\t\t(*table)->corrections = 1;\n\t\t\tgoto doPass;\n\t\tcase CTO_Pass2:\n\t\t\tif ((*table)->numPasses < 2) (*table)->numPasses = 2;\n\t\t\tgoto doPass;\n\t\tcase CTO_Pass3:\n\t\t\tif ((*table)->numPasses < 3) (*table)->numPasses = 3;\n\t\t\tgoto doPass;\n\t\tcase CTO_Pass4:\n\t\t\tif ((*table)->numPasses < 4) (*table)->numPasses = 4;\n\t\tdoPass:\n\t\tcase CTO_Context:\n\t\t\tif (!(nofor || noback)) {\n\t\t\t\tcompileError(file, \"%s or %s must be specified.\",\n\t\t\t\t\t\t_lou_findOpcodeName(CTO_NoFor), _lou_findOpcodeName(CTO_NoBack));\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn compilePassOpcode(file, opcode, noback, nofor, table);\n\t\tcase CTO_Contraction:\n\t\tcase CTO_NoCont:\n\t\tcase CTO_CompBrl:\n\t\tcase CTO_Literal:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\t// check that all characters in a compbrl, contraction,\n\t\t\t// nocont or literal rule are defined (or based on another\n\t\t\t// character)\n\t\t\tfor (int k = 0; k < ruleChars.length; k++) {\n\t\t\t\tTranslationTableCharacter *c = getChar(ruleChars.chars[k], *table, NULL);\n\t\t\t\tif (!(c && (c->definitionRule || c->basechar))) {\n\t\t\t\t\tcompileError(file, \"Character %s is not defined\",\n\t\t\t\t\t\t\t_lou_showString(&ruleChars.chars[k], 1, 0));\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn addRule(file, opcode, &ruleChars, NULL, after, before, NULL, NULL,\n\t\t\t\t\tnoback, nofor, table);\n\t\tcase CTO_MultInd: {\n\t\t\truleChars.length = 0;\n\t\t\tif (!getToken(file, &token, \"multiple braille indicators\") ||\n\t\t\t\t\t!parseDots(file, &cells, &token))\n\t\t\t\treturn 0;\n\t\t\twhile (getToken(file, &token, \"multind opcodes\")) {\n\t\t\t\topcode = getOpcode(file, &token);\n\t\t\t\tif (opcode == CTO_None) {\n\t\t\t\t\tcompileError(file, \"opcode %s not defined.\",\n\t\t\t\t\t\t\t_lou_showString(token.chars, token.length, 0));\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif (!(opcode >= CTO_CapsLetter && opcode < CTO_MultInd)) {\n\t\t\t\t\tcompileError(file, \"Not a braille indicator opcode.\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\truleChars.chars[ruleChars.length++] = (widechar)opcode;\n\t\t\t\tif (atEndOfLine(file)) break;\n\t\t\t}\n\t\t\treturn addRule(file, CTO_MultInd, &ruleChars, &cells, after, before, NULL,\n\t\t\t\t\tNULL, noback, nofor, table);\n\t\t}\n\n\t\tcase CTO_Class:\n\t\t\tcompileWarning(file, \"class is deprecated, use attribute instead\");\n\t\tcase CTO_Attribute: {\n\t\t\tif (nofor || noback) {\n\t\t\t\tcompileWarning(\n\t\t\t\t\t\tfile, \"nofor and noback not allowed before class/attribute\");\n\t\t\t}\n\t\t\tif ((opcode == CTO_Class && (*table)->usesAttributeOrClass == 1) ||\n\t\t\t\t\t(opcode == CTO_Attribute && (*table)->usesAttributeOrClass == 2)) {\n\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\"attribute and class rules must not be both present in a table\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (opcode == CTO_Class)\n\t\t\t\t(*table)->usesAttributeOrClass = 2;\n\t\t\telse\n\t\t\t\t(*table)->usesAttributeOrClass = 1;\n\t\t\tif (!getToken(file, &token, \"attribute name\")) {\n\t\t\t\tcompileError(file, \"Expected %s\", \"attribute name\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (!(*table)->characterClasses && !allocateCharacterClasses(*table)) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tTranslationTableCharacterAttributes attribute = 0;\n\t\t\t{\n\t\t\t\tint attrNumber = -1;\n\t\t\t\tswitch (token.chars[0]) {\n\t\t\t\tcase '0':\n\t\t\t\tcase '1':\n\t\t\t\tcase '2':\n\t\t\t\tcase '3':\n\t\t\t\tcase '4':\n\t\t\t\tcase '5':\n\t\t\t\tcase '6':\n\t\t\t\tcase '7':\n\t\t\t\tcase '8':\n\t\t\t\tcase '9':\n\t\t\t\t\tattrNumber = token.chars[0] - '0';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (attrNumber >= 0) {\n\t\t\t\t\tif (opcode == CTO_Class) {\n\t\t\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\t\t\"Invalid class name: may not contain digits, use \"\n\t\t\t\t\t\t\t\t\"attribute instead of class\");\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (token.length > 1 || attrNumber > 7) {\n\t\t\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\t\t\"Invalid attribute name: must be a digit between 0 and 7 \"\n\t\t\t\t\t\t\t\t\"or a word containing only letters\");\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (!(*table)->numberedAttributes[attrNumber])\n\t\t\t\t\t\t// attribute not used before yet: assign it a value\n\t\t\t\t\t\t(*table)->numberedAttributes[attrNumber] =\n\t\t\t\t\t\t\t\tgetNextNumberedAttribute(*table);\n\t\t\t\t\tattribute = (*table)->numberedAttributes[attrNumber];\n\t\t\t\t} else {\n\t\t\t\t\tconst CharacterClass *namedAttr = findCharacterClass(&token, *table);\n\t\t\t\t\tif (!namedAttr) {\n\t\t\t\t\t\t// no class with that name: create one\n\t\t\t\t\t\tnamedAttr = addCharacterClass(\n\t\t\t\t\t\t\t\tfile, &token.chars[0], token.length, *table, 1);\n\t\t\t\t\t\tif (!namedAttr) return 0;\n\t\t\t\t\t}\n\t\t\t\t\t// there is a class with that name or a new class was successfully\n\t\t\t\t\t// created\n\t\t\t\t\tattribute = namedAttr->attribute;\n\t\t\t\t\tif (attribute == CTC_UpperCase || attribute == CTC_LowerCase)\n\t\t\t\t\t\tattribute |= CTC_Letter;\n\t\t\t\t}\n\t\t\t}\n\t\t\tCharsString characters;\n\t\t\tif (!getCharacters(file, &characters)) return 0;\n\t\t\tfor (int i = 0; i < characters.length; i++) {\n\t\t\t\t// get the character from the table, or if it is not defined yet,\n\t\t\t\t// define it\n\t\t\t\tTranslationTableCharacter *character =\n\t\t\t\t\t\tputChar(file, characters.chars[i], table, NULL);\n\t\t\t\t// set the attribute\n\t\t\t\tcharacter->attributes |= attribute;\n\t\t\t\t// also set the attribute on the associated dots (if any)\n\t\t\t\tif (character->basechar)\n\t\t\t\t\tcharacter = (TranslationTableCharacter *)&(*table)\n\t\t\t\t\t\t\t\t\t\t->ruleArea[character->basechar];\n\t\t\t\tif (character->definitionRule) {\n\t\t\t\t\tTranslationTableRule *defRule =\n\t\t\t\t\t\t\t(TranslationTableRule *)&(*table)\n\t\t\t\t\t\t\t\t\t->ruleArea[character->definitionRule];\n\t\t\t\t\tif (defRule->dotslen == 1) {\n\t\t\t\t\t\tTranslationTableCharacter *dots =\n\t\t\t\t\t\t\t\tgetDots(defRule->charsdots[defRule->charslen], *table);\n\t\t\t\t\t\tif (dots) dots->attributes |= attribute;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\n\t\t\t{\n\t\t\t\tTranslationTableCharacterAttributes *attributes;\n\t\t\t\tconst CharacterClass *class;\n\t\t\tcase CTO_After:\n\t\t\t\tattributes = &after;\n\t\t\t\tgoto doBeforeAfter;\n\t\t\tcase CTO_Before:\n\t\t\t\tattributes = &before;\n\t\t\tdoBeforeAfter:\n\t\t\t\tif (!(*table)->characterClasses) {\n\t\t\t\t\tif (!allocateCharacterClasses(*table)) return 0;\n\t\t\t\t}\n\t\t\t\tif (!getToken(file, &token, \"attribute name\")) return 0;\n\t\t\t\tif (!(class = findCharacterClass(&token, *table))) {\n\t\t\t\t\tcompileError(file, \"attribute not defined\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\t*attributes |= class->attribute;\n\t\t\t\tgoto doOpcode;\n\t\t\t}\n\t\tcase CTO_Base:\n\t\t\tif (nofor || noback) {\n\t\t\t\tcompileWarning(file, \"nofor and noback not allowed before base\");\n\t\t\t}\n\t\t\tif (!getToken(file, &token, \"attribute name\")) {\n\t\t\t\tcompileError(\n\t\t\t\t\t\tfile, \"base opcode must be followed by a valid attribute name.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (!(*table)->characterClasses && !allocateCharacterClasses(*table)) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tconst CharacterClass *mode = findCharacterClass(&token, *table);\n\t\t\tif (!mode) {\n\t\t\t\tmode = addCharacterClass(file, token.chars, token.length, *table, 1);\n\t\t\t\tif (!mode) return 0;\n\t\t\t}\n\t\t\tif (!(mode->attribute == CTC_UpperCase || mode->attribute == CTC_Digit) &&\n\t\t\t\t\tmode->attribute >= CTC_Space && mode->attribute <= CTC_LitDigit) {\n\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\"base opcode must be followed by \\\"uppercase\\\", \\\"digit\\\", or a \"\n\t\t\t\t\t\t\"custom attribute name.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (!getRuleCharsText(file, &token)) return 0;\n\t\t\tif (token.length != 1) {\n\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\"Exactly one character followed by one base character is \"\n\t\t\t\t\t\t\"required.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tTranslationTableOffset characterOffset;\n\t\t\tTranslationTableCharacter *character =\n\t\t\t\t\tputChar(file, token.chars[0], table, &characterOffset);\n\t\t\tif (!getRuleCharsText(file, &token)) return 0;\n\t\t\tif (token.length != 1) {\n\t\t\t\tcompileError(file, \"Exactly one base character is required.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (character->definitionRule) {\n\t\t\t\tTranslationTableRule *prevRule =\n\t\t\t\t\t\t(TranslationTableRule *)&(*table)\n\t\t\t\t\t\t\t\t->ruleArea[character->definitionRule];\n\t\t\t\t_lou_logMessage(LOU_LOG_DEBUG,\n\t\t\t\t\t\t\"%s:%d: Character already defined (%s). The base rule will take \"\n\t\t\t\t\t\t\"precedence.\",\n\t\t\t\t\t\tfile->fileName, file->lineNumber,\n\t\t\t\t\t\tprintSource(file, prevRule->sourceFile, prevRule->sourceLine));\n\t\t\t\tcharacter->definitionRule = 0;\n\t\t\t}\n\t\t\tTranslationTableOffset basechar;\n\t\t\tputChar(file, token.chars[0], table, &basechar);\n\t\t\t// putChar may have moved table, so make sure character is still valid\n\t\t\tcharacter = (TranslationTableCharacter *)&(*table)->ruleArea[characterOffset];\n\t\t\tif (character->basechar) {\n\t\t\t\tif (character->basechar == basechar &&\n\t\t\t\t\t\tcharacter->mode == mode->attribute) {\n\t\t\t\t\t_lou_logMessage(LOU_LOG_DEBUG, \"%s:%d: Duplicate base rule.\",\n\t\t\t\t\t\t\tfile->fileName, file->lineNumber);\n\t\t\t\t} else {\n\t\t\t\t\t_lou_logMessage(LOU_LOG_DEBUG,\n\t\t\t\t\t\t\t\"%s:%d: A different base rule already exists for this \"\n\t\t\t\t\t\t\t\"character (%s). The new rule will take precedence.\",\n\t\t\t\t\t\t\tfile->fileName, file->lineNumber,\n\t\t\t\t\t\t\tprintSource(\n\t\t\t\t\t\t\t\t\tfile, character->sourceFile, character->sourceLine));\n\t\t\t\t}\n\t\t\t}\n\t\t\tcharacter->basechar = basechar;\n\t\t\tcharacter->mode = mode->attribute;\n\t\t\tcharacter->sourceFile = file->sourceFile;\n\t\t\tcharacter->sourceLine = file->lineNumber;\n\t\t\t/* some other processing is done at the end of the compilation, in\n\t\t\t * finalizeTable() */\n\t\t\treturn 1;\n\t\tcase CTO_EmpMatchBefore:\n\t\t\tbefore |= CTC_EmpMatch;\n\t\t\tgoto doOpcode;\n\t\tcase CTO_EmpMatchAfter:\n\t\t\tafter |= CTC_EmpMatch;\n\t\t\tgoto doOpcode;\n\n\t\tcase CTO_SwapCc:\n\t\tcase CTO_SwapCd:\n\t\tcase CTO_SwapDd:\n\t\t\treturn compileSwap(file, opcode, noback, nofor, table);\n\t\tcase CTO_Hyphen:\n\t\tcase CTO_DecPoint:\n\t\t\t//\tcase CTO_Apostrophe:\n\t\t\t//\tcase CTO_Initial:\n\t\t\tif (!getRuleCharsText(file, &ruleChars)) return 0;\n\t\t\tif (!getRuleDotsPattern(file, &ruleDots)) return 0;\n\t\t\tif (ruleChars.length != 1 || ruleDots.length < 1) {\n\t\t\t\tcompileError(file,\n\t\t\t\t\t\t\"One Unicode character and at least one cell are \"\n\t\t\t\t\t\t\"required.\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn addRule(file, opcode, &ruleChars, &ruleDots, after, before, NULL, NULL,\n\t\t\t\t\tnoback, nofor, table);\n\t\t\t// if (opcode == CTO_DecPoint)\n\t\t\t// {\n\t\t\t//   TranslationTableCharacter *c =\n\t\t\t//   getChar(ruleChars.chars[0]);\n\t\t\t//   if(c)\n\t\t\t//     c->attributes |= CTC_NumericMode;\n\t\t\t// }\n\t\tdefault:\n\t\t\tcompileError(file, \"unimplemented opcode.\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint EXPORT_CALL\nlou_readCharFromFile(const char *fileName, int *mode) {\n\t/* Read a character from a file, whether big-endian, little-endian or\n\t * ASCII8 */\n\tint ch;\n\tstatic FileInfo file;\n\tif (fileName == NULL) return 0;\n\tif (*mode == 1) {\n\t\t*mode = 0;\n\t\tfile.fileName = fileName;\n\t\tfile.encoding = noEncoding;\n\t\tfile.status = 0;\n\t\tfile.lineNumber = 0;\n\t\tif (!(file.in = fopen(file.fileName, \"r\"))) {\n\t\t\t_lou_logMessage(LOU_LOG_ERROR, \"Cannot open file '%s'\", file.fileName);\n\t\t\t*mode = 1;\n\t\t\treturn EOF;\n\t\t}\n\t}\n\tif (file.in == NULL) {\n\t\t*mode = 1;\n\t\treturn EOF;\n\t}\n\tch = getAChar(&file);\n\tif (ch == EOF) {\n\t\tfclose(file.in);\n\t\tfile.in = NULL;\n\t\t*mode = 1;\n\t}\n\treturn ch;\n}\n\nstatic int\nfinalizeTable(TranslationTableHeader *table) {\n\tif (table->finalized) return 1;\n\t// normalize basechar and mode of all characters\n\tfor (int i = 0; i < HASHNUM; i++) {\n\t\tTranslationTableOffset characterOffset = table->characters[i];\n\t\twhile (characterOffset) {\n\t\t\tTranslationTableCharacter *character =\n\t\t\t\t\t(TranslationTableCharacter *)&table->ruleArea[characterOffset];\n\t\t\tif (character->basechar) {\n\t\t\t\tTranslationTableOffset basecharOffset = 0;\n\t\t\t\tTranslationTableCharacter *basechar = character;\n\t\t\t\tTranslationTableCharacterAttributes mode = 0;\n\t\t\t\tint detect_loop = 0;\n\t\t\t\twhile (basechar->basechar) {\n\t\t\t\t\tif (basechar->basechar == characterOffset ||\n\t\t\t\t\t\t\tdetect_loop++ > MAX_MODES) {\n\t\t\t\t\t\t_lou_logMessage(LOU_LOG_ERROR,\n\t\t\t\t\t\t\t\t\"%s: error: Character can not be (indirectly) based on \"\n\t\t\t\t\t\t\t\t\"itself.\",\n\t\t\t\t\t\t\t\tprintSource(NULL, character->sourceFile,\n\t\t\t\t\t\t\t\t\t\tcharacter->sourceLine));\n\t\t\t\t\t\terrorCount++;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\t// inherit basechar mode\n\t\t\t\t\tmode |= basechar->mode;\n\t\t\t\t\t// compute basechar recursively\n\t\t\t\t\tbasecharOffset = basechar->basechar;\n\t\t\t\t\tbasechar =\n\t\t\t\t\t\t\t(TranslationTableCharacter *)&table->ruleArea[basecharOffset];\n\t\t\t\t\tif (character->mode & (basechar->attributes | basechar->mode)) {\n\t\t\t\t\t\tchar *attributeName = NULL;\n\t\t\t\t\t\tconst CharacterClass *class = table->characterClasses;\n\t\t\t\t\t\twhile (class) {\n\t\t\t\t\t\t\tif (class->attribute == character->mode) {\n\t\t\t\t\t\t\t\tattributeName = strdup(\n\t\t\t\t\t\t\t\t\t\t_lou_showString(class->name, class->length, 0));\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tclass = class->next;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t_lou_logMessage(LOU_LOG_ERROR,\n\t\t\t\t\t\t\t\t\"%s: error: Base character %s can not have the %s \"\n\t\t\t\t\t\t\t\t\"attribute.\",\n\t\t\t\t\t\t\t\tprintSource(NULL, character->sourceFile,\n\t\t\t\t\t\t\t\t\t\tcharacter->sourceLine),\n\t\t\t\t\t\t\t\t_lou_showString(&basechar->value, 1, 0),\n\t\t\t\t\t\t\t\tattributeName != NULL ? attributeName : \"?\");\n\t\t\t\t\t\terrorCount++;\n\t\t\t\t\t\tfree(attributeName);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcharacter->mode = mode;\n\t\t\t\tcharacter->basechar = basecharOffset;\n\t\t\t\t// add mode to attributes\n\t\t\t\tcharacter->attributes |= character->mode;\n\t\t\t\tif (character->attributes & (CTC_UpperCase | CTC_LowerCase))\n\t\t\t\t\tcharacter->attributes |= CTC_Letter;\n\t\t\t\t// also set the new attributes on the associated dots of the base\n\t\t\t\t// character\n\t\t\t\tTranslationTableRule *defRule =\n\t\t\t\t\t\t(TranslationTableRule *)&table\n\t\t\t\t\t\t\t\t->ruleArea[basechar->definitionRule];\n\t\t\t\tif (defRule->dotslen == 1) {\n\t\t\t\t\tTranslationTableCharacter *dots =\n\t\t\t\t\t\t\tgetDots(defRule->charsdots[defRule->charslen], table);\n\t\t\t\t\tif (dots) {\n\t\t\t\t\t\tdots->attributes |= character->mode;\n\t\t\t\t\t\tif (dots->attributes & (CTC_UpperCase | CTC_LowerCase))\n\t\t\t\t\t\t\tdots->attributes |= CTC_Letter;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// store all characters that are based on a base character in list\n\t\t\t\tif (basechar->linked) character->linked = basechar->linked;\n\t\t\t\tbasechar->linked = characterOffset;\n\t\t\t}\n\t\t\tcharacterOffset = character->next;\n\t\t}\n\t}\n\t// add noletsign rules from single-letter word and largesign rules\n\tfor (int i = 0; i < HASHNUM; i++) {\n\t\tTranslationTableOffset characterOffset = table->characters[i];\n\t\twhile (characterOffset) {\n\t\t\tTranslationTableCharacter *character =\n\t\t\t\t\t(TranslationTableCharacter *)&table->ruleArea[characterOffset];\n\t\t\tif (character->attributes & CTC_Letter) {\n\t\t\t\tTranslationTableOffset *otherRule = &character->otherRules;\n\t\t\t\twhile (*otherRule) {\n\t\t\t\t\tTranslationTableRule *rule =\n\t\t\t\t\t\t\t(TranslationTableRule *)&table->ruleArea[*otherRule];\n\t\t\t\t\tif (rule->opcode == CTO_WholeWord || rule->opcode == CTO_LargeSign)\n\t\t\t\t\t\tif (table->noLetsignCount < LETSIGNSIZE)\n\t\t\t\t\t\t\ttable->noLetsign[table->noLetsignCount++] =\n\t\t\t\t\t\t\t\t\trule->charsdots[0];\n\t\t\t\t\totherRule = &rule->charsnext;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcharacterOffset = character->next;\n\t\t}\n\t}\n\ttable->finalized = 1;\n\treturn 1;\n}\n\nstatic int\ncompileString(const char *inString, TranslationTableHeader **table,\n\t\tDisplayTableHeader **displayTable) {\n\t/* This function can be used to make changes to tables on the fly. */\n\tint k;\n\tFileInfo file;\n\tif (inString == NULL) return 0;\n\tmemset(&file, 0, sizeof(file));\n\tfile.fileName = inString;\n\tfile.encoding = noEncoding;\n\tfile.lineNumber = 1;\n\tfile.status = 0;\n\tfile.linepos = 0;\n\tfor (k = 0; inString[k]; k++) file.line[k] = inString[k];\n\tfile.line[k] = 0;\n\tfile.linelen = k;\n\tif (table && *table && (*table)->finalized) {\n\t\tcompileError(&file, \"Table is finalized\");\n\t\treturn 0;\n\t}\n\treturn compileRule(&file, table, displayTable, NULL);\n}\n\nstatic int\nsetDefaults(TranslationTableHeader *table) {\n\tfor (int i = 0; i < 3; i++)\n\t\tif (!table->emphRules[i][lenPhraseOffset])\n\t\t\ttable->emphRules[i][lenPhraseOffset] = 4;\n\tif (table->numPasses == 0) table->numPasses = 1;\n\treturn 1;\n}\n\n/* =============== *\n * TABLE RESOLVING *\n * =============== *\n *\n * A table resolver is a function that resolves a `tableList` path against a\n * `base` path, and returns the resolved table(s) as a list of absolute file\n * paths.\n *\n * The function must have the following signature:\n *\n *     char ** (const char * tableList, const char * base)\n *\n * In general, `tableList` is a path in the broad sense. The default\n * implementation accepts only *file* paths. But another implementation could\n * for instance handle URI's. `base` is always a file path however.\n *\n * The idea is to give other programs that use liblouis the ability to define\n * their own table resolver (in C, Java, Python, etc.) when the default\n * resolver is not satisfying. (see also lou_registerTableResolver)\n *\n */\n\n/**\n * Resolve a single (sub)table.\n *\n * Tries to resolve `table` against `base` if base is an absolute path. If\n * that fails, searches `searchPath`.\n *\n */\nstatic char *\nresolveSubtable(const char *table, const char *base, const char *searchPath) {\n\tchar *tableFile;\n\tstatic struct stat info;\n\n\tif (table == NULL || table[0] == '\\0') return NULL;\n\ttableFile = (char *)malloc(MAXSTRING * sizeof(char) * 2);\n\n\t//\n\t// First try to resolve against base\n\t//\n\tif (base) {\n\t\tint k;\n\t\tstrcpy(tableFile, base);\n\t\tk = (int)strlen(tableFile);\n\t\twhile (k >= 0 && tableFile[k] != '/' && tableFile[k] != '\\\\') k--;\n\t\ttableFile[++k] = '\\0';\n\t\tstrcat(tableFile, table);\n\t\tif (stat(tableFile, &info) == 0 && !(info.st_mode & S_IFDIR)) {\n\t\t\t_lou_logMessage(LOU_LOG_DEBUG, \"found table %s\", tableFile);\n\t\t\treturn tableFile;\n\t\t}\n\t}\n\n\t//\n\t// It could be an absolute path, or a path relative to the current working\n\t// directory\n\t//\n\tstrcpy(tableFile, table);\n\tif (stat(tableFile, &info) == 0 && !(info.st_mode & S_IFDIR)) {\n\t\t_lou_logMessage(LOU_LOG_DEBUG, \"found table %s\", tableFile);\n\t\treturn tableFile;\n\t}\n\n\t//\n\t// Then search `LOUIS_TABLEPATH`, `dataPath` and `programPath`\n\t//\n\tif (searchPath[0] != '\\0') {\n\t\tchar *dir;\n\t\tint last;\n\t\tchar *cp;\n\t\tchar *searchPath_copy = strdup(searchPath);\n\t\tfor (dir = searchPath_copy;; dir = cp + 1) {\n\t\t\tfor (cp = dir; *cp != '\\0' && *cp != ','; cp++)\n\t\t\t\t;\n\t\t\tlast = (*cp == '\\0');\n\t\t\t*cp = '\\0';\n\t\t\tif (dir == cp) dir = \".\";\n\t\t\tsprintf(tableFile, \"%s%c%s\", dir, DIR_SEP, table);\n\t\t\tif (stat(tableFile, &info) == 0 && !(info.st_mode & S_IFDIR)) {\n\t\t\t\t_lou_logMessage(LOU_LOG_DEBUG, \"found table %s\", tableFile);\n\t\t\t\tfree(searchPath_copy);\n\t\t\t\treturn tableFile;\n\t\t\t}\n\t\t\tif (last) break;\n\t\t\tsprintf(tableFile, \"%s%c%s%c%s%c%s\", dir, DIR_SEP, \"liblouis\", DIR_SEP,\n\t\t\t\t\t\"tables\", DIR_SEP, table);\n\t\t\tif (stat(tableFile, &info) == 0 && !(info.st_mode & S_IFDIR)) {\n\t\t\t\t_lou_logMessage(LOU_LOG_DEBUG, \"found table %s\", tableFile);\n\t\t\t\tfree(searchPath_copy);\n\t\t\t\treturn tableFile;\n\t\t\t}\n\t\t\tif (last) break;\n\t\t}\n\t\tfree(searchPath_copy);\n\t}\n\tfree(tableFile);\n\treturn NULL;\n}\n\nchar *EXPORT_CALL\n_lou_getTablePath(void) {\n\tchar searchPath[MAXSTRING];\n\tchar *path;\n\tchar *cp;\n\tint envset = 0;\n\tcp = searchPath;\n\tpath = getenv(\"LOUIS_TABLEPATH\");\n\tif (path != NULL && path[0] != '\\0') {\n\t\tenvset = 1;\n\t\tcp += sprintf(cp, \",%s\", path);\n\t}\n\tpath = lou_getDataPath();\n\tif (path != NULL && path[0] != '\\0')\n\t\tcp += sprintf(cp, \",%s%c%s%c%s\", path, DIR_SEP, \"liblouis\", DIR_SEP, \"tables\");\n\tif (!envset) {\n#ifdef _WIN32\n\t\tpath = lou_getProgramPath();\n\t\tif (path != NULL) {\n\t\t\tif (path[0] != '\\0')\n\t\t\t\tcp += sprintf(cp, \",%s%s\", path, \"\\\\share\\\\liblouis\\\\tables\");\n\t\t\tfree(path);\n\t\t}\n#else\n\t\tcp += sprintf(cp, \",%s\", TABLESDIR);\n#endif\n\t}\n\tif (searchPath[0] != '\\0')\n\t\treturn strdup(&searchPath[1]);\n\telse\n\t\treturn strdup(\".\");\n}\n\n/**\n * The default table resolver\n *\n * Tries to resolve tableList against base. The search path is set to\n * `LOUIS_TABLEPATH`, `dataPath` and `programPath` (in that order).\n *\n * @param table A file path, may be absolute or relative. May be a list of\n *              tables separated by comma's. In that case, the first table\n *              is used as the base for the other subtables.\n * @param base A file path or directory path, or NULL.\n * @return The file paths of the resolved subtables, or NULL if the table\n *         could not be resolved.\n *\n */\nchar **EXPORT_CALL\n_lou_defaultTableResolver(const char *tableList, const char *base) {\n\tchar *searchPath;\n\tchar **tableFiles;\n\tchar *subTable;\n\tchar *tableList_copy;\n\tchar *cp;\n\tint last;\n\tint k;\n\n\t/* Set up search path */\n\tsearchPath = _lou_getTablePath();\n\n\t/* Count number of subtables in table list */\n\tk = 0;\n\tfor (cp = (char *)tableList; *cp != '\\0'; cp++)\n\t\tif (*cp == ',') k++;\n\ttableFiles = (char **)calloc(k + 2, sizeof(char *));\n\tif (!tableFiles) _lou_outOfMemory();\n\n\t/* Resolve subtables */\n\tk = 0;\n\ttableList_copy = strdup(tableList);\n\tfor (subTable = tableList_copy;; subTable = cp + 1) {\n\t\tfor (cp = subTable; *cp != '\\0' && *cp != ','; cp++)\n\t\t\t;\n\t\tlast = (*cp == '\\0');\n\t\t*cp = '\\0';\n\t\tif (!(tableFiles[k++] = resolveSubtable(subTable, base, searchPath))) {\n\t\t\tchar *path;\n\t\t\t_lou_logMessage(LOU_LOG_ERROR, \"Cannot resolve table '%s'\", subTable);\n\t\t\tpath = getenv(\"LOUIS_TABLEPATH\");\n\t\t\tif (path != NULL && path[0] != '\\0')\n\t\t\t\t_lou_logMessage(LOU_LOG_ERROR, \"LOUIS_TABLEPATH=%s\", path);\n\t\t\tfree(searchPath);\n\t\t\tfree(tableList_copy);\n\t\t\tfree_tablefiles(tableFiles);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (k == 1) base = subTable;\n\t\tif (last) break;\n\t}\n\tfree(searchPath);\n\tfree(tableList_copy);\n\ttableFiles[k] = NULL;\n\treturn tableFiles;\n}\n\nstatic char **(EXPORT_CALL *tableResolver)(\n\t\tconst char *tableList, const char *base) = &_lou_defaultTableResolver;\n\nstatic char **\ncopyStringArray(char **array) {\n\tint len;\n\tchar **copy;\n\tif (!array) return NULL;\n\tlen = 0;\n\twhile (array[len]) len++;\n\tcopy = malloc((len + 1) * sizeof(char *));\n\tcopy[len] = NULL;\n\twhile (len) {\n\t\tlen--;\n\t\tcopy[len] = strdup(array[len]);\n\t}\n\treturn copy;\n}\n\nchar **EXPORT_CALL\n_lou_resolveTable(const char *tableList, const char *base) {\n\tchar **tableFiles = (*tableResolver)(tableList, base);\n\tchar **result = copyStringArray(tableFiles);\n\tif (tableResolver == &_lou_defaultTableResolver) free_tablefiles(tableFiles);\n\treturn result;\n}\n\n/**\n * Register a new table resolver. Overrides the default resolver.\n *\n * @param resolver The new resolver as a function pointer.\n *\n */\nvoid EXPORT_CALL\nlou_registerTableResolver(\n\t\tchar **(EXPORT_CALL *resolver)(const char *tableList, const char *base)) {\n\ttableResolver = resolver;\n}\n\nstatic int fileCount = 0;\n\n/**\n * Compile a single file\n *\n */\nstatic int\ncompileFile(const char *fileName, TranslationTableHeader **table,\n\t\tDisplayTableHeader **displayTable) {\n\tFileInfo file;\n\tfileCount++;\n\tfile.fileName = fileName;\n\tif (table) {\n\t\tint i;\n\t\tfor (i = 0; (*table)->sourceFiles[i]; i++)\n\t\t\t;\n\t\tif (i >= MAX_SOURCE_FILES) {\n\t\t\t_lou_logMessage(LOU_LOG_WARN, \"Max number of source files (%i) reached\",\n\t\t\t\t\tMAX_SOURCE_FILES);\n\t\t\tfile.sourceFile = NULL;\n\t\t} else {\n\t\t\tfile.sourceFile = (*table)->sourceFiles[i] = strdup(fileName);\n\t\t}\n\t}\n\tfile.encoding = noEncoding;\n\tfile.status = 0;\n\tfile.lineNumber = 0;\n\tif ((file.in = fopen(file.fileName, \"rb\"))) {\n\t\t// the scope of a macro is the current file (after the macro definition)\n\t\tconst MacroList *inscopeMacros = NULL;\n\t\twhile (_lou_getALine(&file))\n\t\t\tif (!compileRule(&file, table, displayTable, &inscopeMacros)) {\n\t\t\t\tif (!errorCount) compileError(&file, \"Rule could not be compiled\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\tfclose(file.in);\n\t\tfree_macro_list(inscopeMacros);\n\t} else {\n\t\t_lou_logMessage(LOU_LOG_ERROR, \"Cannot open table '%s'\", file.fileName);\n\t\terrorCount++;\n\t}\n\treturn !errorCount;\n}\n\nstatic void\nfreeTranslationTable(TranslationTableHeader *t) {\n\tfor (int i = 0; i < MAX_EMPH_CLASSES && t->emphClassNames[i]; i++)\n\t\tfree(t->emphClassNames[i]);\n\tfor (int i = 0; t->sourceFiles[i]; i++) free(t->sourceFiles[i]);\n\tif (t->characterClasses) deallocateCharacterClasses(t);\n\tif (t->ruleNames) deallocateRuleNames(t);\n\tfree(t);\n}\n\n/**\n * Free a char** array\n */\nstatic void\nfree_tablefiles(char **tables) {\n\tchar **table;\n\tif (!tables) return;\n\tfor (table = tables; *table; table++) free(*table);\n\tfree(tables);\n}\n\n/**\n * Implement include opcode\n *\n */\nstatic int\nincludeFile(const FileInfo *file, CharsString *includedFile,\n\t\tTranslationTableHeader **table, DisplayTableHeader **displayTable) {\n\tint k;\n\tchar includeThis[MAXSTRING];\n\tchar **tableFiles;\n\tint rv;\n\tfor (k = 0; k < includedFile->length; k++)\n\t\tincludeThis[k] = (char)includedFile->chars[k];\n\tif (k >= MAXSTRING) {\n\t\tcompileError(file, \"Include statement too long: 'include %s'\", includeThis);\n\t\treturn 0;\n\t}\n\tincludeThis[k] = 0;\n\ttableFiles = _lou_resolveTable(includeThis, file->fileName);\n\tif (tableFiles == NULL) {\n\t\terrorCount++;\n\t\treturn 0;\n\t}\n\tif (tableFiles[1] != NULL) {\n\t\tfree_tablefiles(tableFiles);\n\t\tcompileError(file, \"Table list not supported in include statement: 'include %s'\",\n\t\t\t\tincludeThis);\n\t\treturn 0;\n\t}\n\trv = compileFile(*tableFiles, table, displayTable);\n\tfree_tablefiles(tableFiles);\n\tif (!rv)\n\t\t_lou_logMessage(LOU_LOG_ERROR, \"%s:%d: Error in included file\", file->fileName,\n\t\t\t\tfile->lineNumber);\n\treturn rv;\n}\n\n/**\n * Compile source tables into a table in memory\n *\n */\nstatic int\ncompileTable(const char *tableList, const char *displayTableList,\n\t\tTranslationTableHeader **translationTable, DisplayTableHeader **displayTable) {\n\tchar **tableFiles;\n\tchar **subTable;\n\tif (translationTable && !tableList) return 0;\n\tif (displayTable && !displayTableList) return 0;\n\tif (!translationTable && !displayTable) return 0;\n\tif (translationTable) *translationTable = NULL;\n\tif (displayTable) *displayTable = NULL;\n\terrorCount = warningCount = fileCount = 0;\n\tif (!opcodeLengths[0]) {\n\t\tTranslationTableOpcode opcode;\n\t\tfor (opcode = 0; opcode < CTO_None; opcode++)\n\t\t\topcodeLengths[opcode] = (short)strlen(opcodeNames[opcode]);\n\t}\n\tif (translationTable) allocateTranslationTable(NULL, translationTable);\n\tif (displayTable) allocateDisplayTable(NULL, displayTable);\n\n\tif (translationTable) {\n\t\t(*translationTable)->emphClassNames[0] = NULL;\n\t\t(*translationTable)->characterClasses = NULL;\n\t\t(*translationTable)->ruleNames = NULL;\n\t}\n\n\t/* Compile things that are necesary for the proper operation of\n\t * liblouis or liblouisxml or liblouisutdml */\n\t/* TODO: These definitions seem to be necessary for proper functioning of\n\t   liblouisutdml. Find a way to satisfy those requirements without hard coding\n\t   some characters in every table notably behind the users back */\n\tcompileString(\"space \\\\xffff 123456789abcdef LOU_ENDSEGMENT\", translationTable,\n\t\t\tdisplayTable);\n\n\tif (displayTable && translationTable && strcmp(tableList, displayTableList) == 0) {\n\t\t/* Compile the display and translation tables in one go */\n\n\t\t/* Compile all subtables in the list */\n\t\tif (!(tableFiles = _lou_resolveTable(tableList, NULL))) {\n\t\t\terrorCount++;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tfor (subTable = tableFiles; *subTable; subTable++)\n\t\t\tif (!compileFile(*subTable, translationTable, displayTable)) goto cleanup;\n\t} else {\n\t\t/* Compile the display and translation tables separately */\n\n\t\tif (displayTable) {\n\t\t\tif (!(tableFiles = _lou_resolveTable(displayTableList, NULL))) {\n\t\t\t\terrorCount++;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tfor (subTable = tableFiles; *subTable; subTable++)\n\t\t\t\tif (!compileFile(*subTable, NULL, displayTable)) goto cleanup;\n\t\t\tfree_tablefiles(tableFiles);\n\t\t\ttableFiles = NULL;\n\t\t}\n\t\tif (translationTable) {\n\t\t\tif (!(tableFiles = _lou_resolveTable(tableList, NULL))) {\n\t\t\t\terrorCount++;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tfor (subTable = tableFiles; *subTable; subTable++)\n\t\t\t\tif (!compileFile(*subTable, translationTable, NULL)) goto cleanup;\n\t\t}\n\t}\n\n/* Clean up after compiling files */\ncleanup:\n\tfree_tablefiles(tableFiles);\n\tif (warningCount) _lou_logMessage(LOU_LOG_WARN, \"%d warnings issued\", warningCount);\n\tif (!errorCount) {\n\t\tif (translationTable) setDefaults(*translationTable);\n\t\treturn 1;\n\t} else {\n\t\t_lou_logMessage(LOU_LOG_ERROR, \"%d errors found.\", errorCount);\n\t\tif (translationTable) {\n\t\t\tif (*translationTable) freeTranslationTable(*translationTable);\n\t\t\t*translationTable = NULL;\n\t\t}\n\t\tif (displayTable) {\n\t\t\tif (*displayTable) free(*displayTable);\n\t\t\t*displayTable = NULL;\n\t\t}\n\t\treturn 0;\n\t}\n}\n\n/* Return the emphasis classes declared in tableList. */\nchar const **EXPORT_CALL\nlou_getEmphClasses(const char *tableList) {\n\tconst char *names[MAX_EMPH_CLASSES + 1];\n\tunsigned int count = 0;\n\tconst TranslationTableHeader *table = _lou_getTranslationTable(tableList);\n\tif (!table) return NULL;\n\n\twhile (count < MAX_EMPH_CLASSES) {\n\t\tchar const *name = table->emphClassNames[count];\n\t\tif (!name) break;\n\t\tnames[count++] = name;\n\t}\n\tnames[count++] = NULL;\n\n\t{\n\t\tunsigned int size = count * sizeof(names[0]);\n\t\tchar const **result = malloc(size);\n\t\tif (!result) return NULL;\n\t\t/* The void* cast is necessary to stop MSVC from warning about\n\t\t * different 'const' qualifiers (C4090). */\n\t\tmemcpy((void *)result, names, size);\n\t\treturn result;\n\t}\n}\n\nvoid\ngetTable(const char *tableList, const char *displayTableList,\n\t\tTranslationTableHeader **translationTable, DisplayTableHeader **displayTable);\n\nvoid EXPORT_CALL\n_lou_getTable(const char *tableList, const char *displayTableList,\n\t\tconst TranslationTableHeader **translationTable,\n\t\tconst DisplayTableHeader **displayTable) {\n\tTranslationTableHeader *newTable;\n\tDisplayTableHeader *newDisplayTable;\n\tgetTable(tableList, displayTableList, &newTable, &newDisplayTable);\n\tif (newTable)\n\t\tif (!finalizeTable(newTable)) newTable = NULL;\n\t*translationTable = newTable;\n\t*displayTable = newDisplayTable;\n}\n\n/* Checks and loads tableList. */\nconst void *EXPORT_CALL\nlou_getTable(const char *tableList) {\n\tconst TranslationTableHeader *table;\n\tconst DisplayTableHeader *displayTable;\n\t_lou_getTable(tableList, tableList, &table, &displayTable);\n\tif (!table || !displayTable) return NULL;\n\treturn table;\n}\n\nconst TranslationTableHeader *EXPORT_CALL\n_lou_getTranslationTable(const char *tableList) {\n\tTranslationTableHeader *table;\n\tgetTable(tableList, NULL, &table, NULL);\n\tif (table)\n\t\tif (!finalizeTable(table)) table = NULL;\n\treturn table;\n}\n\nconst DisplayTableHeader *EXPORT_CALL\n_lou_getDisplayTable(const char *tableList) {\n\tDisplayTableHeader *table;\n\tgetTable(NULL, tableList, NULL, &table);\n\treturn table;\n}\n\nvoid\ngetTable(const char *translationTableList, const char *displayTableList,\n\t\tTranslationTableHeader **translationTable, DisplayTableHeader **displayTable) {\n\t/* Keep track of which tables have already been compiled */\n\tint translationTableListLen, displayTableListLen = 0;\n\tif (translationTableList == NULL || *translationTableList == 0)\n\t\ttranslationTable = NULL;\n\tif (displayTableList == NULL || *displayTableList == 0) displayTable = NULL;\n\t/* See if translation table has already been compiled */\n\tif (translationTable) {\n\t\ttranslationTableListLen = (int)strlen(translationTableList);\n\t\t*translationTable = NULL;\n\t\tTranslationTableChainEntry *currentEntry = translationTableChain;\n\t\tTranslationTableChainEntry *prevEntry = NULL;\n\t\twhile (currentEntry != NULL) {\n\t\t\tif (translationTableListLen == currentEntry->tableListLength &&\n\t\t\t\t\t(memcmp(&currentEntry->tableList[0], translationTableList,\n\t\t\t\t\t\t\ttranslationTableListLen)) == 0) {\n\t\t\t\t/* Move the table to the top of the table chain. */\n\t\t\t\tif (prevEntry != NULL) {\n\t\t\t\t\tprevEntry->next = currentEntry->next;\n\t\t\t\t\tcurrentEntry->next = translationTableChain;\n\t\t\t\t\ttranslationTableChain = currentEntry;\n\t\t\t\t}\n\t\t\t\t*translationTable = currentEntry->table;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tprevEntry = currentEntry;\n\t\t\tcurrentEntry = currentEntry->next;\n\t\t}\n\t}\n\t/* See if display table has already been compiled */\n\tif (displayTable) {\n\t\tdisplayTableListLen = (int)strlen(displayTableList);\n\t\t*displayTable = NULL;\n\t\tDisplayTableChainEntry *currentEntry = displayTableChain;\n\t\tDisplayTableChainEntry *prevEntry = NULL;\n\t\twhile (currentEntry != NULL) {\n\t\t\tif (displayTableListLen == currentEntry->tableListLength &&\n\t\t\t\t\t(memcmp(&currentEntry->tableList[0], displayTableList,\n\t\t\t\t\t\t\tdisplayTableListLen)) == 0) {\n\t\t\t\t/* Move the table to the top of the table chain. */\n\t\t\t\tif (prevEntry != NULL) {\n\t\t\t\t\tprevEntry->next = currentEntry->next;\n\t\t\t\t\tcurrentEntry->next = displayTableChain;\n\t\t\t\t\tdisplayTableChain = currentEntry;\n\t\t\t\t}\n\t\t\t\t*displayTable = currentEntry->table;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tprevEntry = currentEntry;\n\t\t\tcurrentEntry = currentEntry->next;\n\t\t}\n\t}\n\tif ((translationTable && *translationTable == NULL) ||\n\t\t\t(displayTable && *displayTable == NULL)) {\n\t\tTranslationTableHeader *newTranslationTable = NULL;\n\t\tDisplayTableHeader *newDisplayTable = NULL;\n\t\tif (compileTable(translationTableList, displayTableList,\n\t\t\t\t\t(translationTable && *translationTable == NULL) ? &newTranslationTable\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t: NULL,\n\t\t\t\t\t(displayTable && *displayTable == NULL) ? &newDisplayTable : NULL)) {\n\t\t\t/* Add a new entry to the top of the table chain. */\n\t\t\tif (newTranslationTable != NULL) {\n\t\t\t\tint entrySize =\n\t\t\t\t\t\tsizeof(TranslationTableChainEntry) + translationTableListLen;\n\t\t\t\tTranslationTableChainEntry *newEntry = malloc(entrySize);\n\t\t\t\tif (!newEntry) _lou_outOfMemory();\n\t\t\t\tnewEntry->next = translationTableChain;\n\t\t\t\tnewEntry->table = newTranslationTable;\n\t\t\t\tnewEntry->tableListLength = translationTableListLen;\n\t\t\t\tmemcpy(&newEntry->tableList[0], translationTableList,\n\t\t\t\t\t\ttranslationTableListLen);\n\t\t\t\ttranslationTableChain = newEntry;\n\t\t\t\t*translationTable = newTranslationTable;\n\t\t\t}\n\t\t\tif (newDisplayTable != NULL) {\n\t\t\t\tint entrySize = sizeof(DisplayTableChainEntry) + displayTableListLen;\n\t\t\t\tDisplayTableChainEntry *newEntry = malloc(entrySize);\n\t\t\t\tif (!newEntry) _lou_outOfMemory();\n\t\t\t\tnewEntry->next = displayTableChain;\n\t\t\t\tnewEntry->table = newDisplayTable;\n\t\t\t\tnewEntry->tableListLength = displayTableListLen;\n\t\t\t\tmemcpy(&newEntry->tableList[0], displayTableList, displayTableListLen);\n\t\t\t\tdisplayTableChain = newEntry;\n\t\t\t\t*displayTable = newDisplayTable;\n\t\t\t}\n\t\t} else {\n\t\t\t_lou_logMessage(\n\t\t\t\t\tLOU_LOG_ERROR, \"%s could not be compiled\", translationTableList);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nint EXPORT_CALL\nlou_checkTable(const char *tableList) {\n\tif (lou_getTable(tableList)) return 1;\n\treturn 0;\n}\n\nformtype EXPORT_CALL\nlou_getTypeformForEmphClass(const char *tableList, const char *emphClass) {\n\tconst TranslationTableHeader *table = _lou_getTranslationTable(tableList);\n\tif (!table) return 0;\n\tfor (int i = 0; i < MAX_EMPH_CLASSES && table->emphClassNames[i]; i++)\n\t\tif (strcmp(emphClass, table->emphClassNames[i]) == 0) return italic << i;\n\treturn 0;\n}\n\nstatic unsigned char *destSpacing = NULL;\nstatic int sizeDestSpacing = 0;\nstatic formtype *typebuf = NULL;\nstatic unsigned int *wordBuffer = NULL;\nstatic EmphasisInfo *emphasisBuffer = NULL;\nstatic int sizeTypebuf = 0;\nstatic widechar *passbuf[MAXPASSBUF] = { NULL };\nstatic int sizePassbuf[MAXPASSBUF] = { 0 };\nstatic int *posMapping1 = NULL;\nstatic int sizePosMapping1 = 0;\nstatic int *posMapping2 = NULL;\nstatic int sizePosMapping2 = 0;\nstatic int *posMapping3 = NULL;\nstatic int sizePosMapping3 = 0;\nvoid *EXPORT_CALL\n_lou_allocMem(AllocBuf buffer, int index, int srcmax, int destmax) {\n\tif (srcmax < 1024) srcmax = 1024;\n\tif (destmax < 1024) destmax = 1024;\n\tswitch (buffer) {\n\tcase alloc_typebuf:\n\t\tif (destmax > sizeTypebuf) {\n\t\t\tif (typebuf != NULL) free(typebuf);\n\t\t\t// TODO: should this be srcmax?\n\t\t\ttypebuf = malloc((destmax + 4) * sizeof(formtype));\n\t\t\tif (!typebuf) _lou_outOfMemory();\n\t\t\tsizeTypebuf = destmax;\n\t\t}\n\t\treturn typebuf;\n\n\tcase alloc_wordBuffer:\n\n\t\tif (wordBuffer != NULL) free(wordBuffer);\n\t\twordBuffer = calloc(srcmax + 4, sizeof(unsigned int));\n\t\tif (wordBuffer == NULL) _lou_outOfMemory();\n\t\treturn wordBuffer;\n\n\tcase alloc_emphasisBuffer:\n\n\t\tif (emphasisBuffer != NULL) free(emphasisBuffer);\n\t\temphasisBuffer = calloc(srcmax + 4, sizeof(EmphasisInfo));\n\t\tif (emphasisBuffer == NULL) _lou_outOfMemory();\n\t\treturn emphasisBuffer;\n\n\tcase alloc_destSpacing:\n\t\tif (destmax > sizeDestSpacing) {\n\t\t\tif (destSpacing != NULL) free(destSpacing);\n\t\t\tdestSpacing = malloc(destmax + 4);\n\t\t\tif (!destSpacing) _lou_outOfMemory();\n\t\t\tsizeDestSpacing = destmax;\n\t\t}\n\t\treturn destSpacing;\n\tcase alloc_passbuf:\n\t\tif (index < 0 || index >= MAXPASSBUF) {\n\t\t\t_lou_logMessage(LOU_LOG_FATAL, \"Index out of bounds: %d\\n\", index);\n\t\t\texit(3);\n\t\t}\n\t\tif (destmax > sizePassbuf[index]) {\n\t\t\tif (passbuf[index] != NULL) free(passbuf[index]);\n\t\t\tpassbuf[index] = malloc((destmax + 4) * CHARSIZE);\n\t\t\tif (!passbuf[index]) _lou_outOfMemory();\n\t\t\tsizePassbuf[index] = destmax;\n\t\t}\n\t\treturn passbuf[index];\n\tcase alloc_posMapping1: {\n\t\tint mapSize;\n\t\tif (srcmax >= destmax)\n\t\t\tmapSize = srcmax;\n\t\telse\n\t\t\tmapSize = destmax;\n\t\tif (mapSize > sizePosMapping1) {\n\t\t\tif (posMapping1 != NULL) free(posMapping1);\n\t\t\tposMapping1 = malloc((mapSize + 4) * sizeof(int));\n\t\t\tif (!posMapping1) _lou_outOfMemory();\n\t\t\tsizePosMapping1 = mapSize;\n\t\t}\n\t}\n\t\treturn posMapping1;\n\tcase alloc_posMapping2: {\n\t\tint mapSize;\n\t\tif (srcmax >= destmax)\n\t\t\tmapSize = srcmax;\n\t\telse\n\t\t\tmapSize = destmax;\n\t\tif (mapSize > sizePosMapping2) {\n\t\t\tif (posMapping2 != NULL) free(posMapping2);\n\t\t\tposMapping2 = malloc((mapSize + 4) * sizeof(int));\n\t\t\tif (!posMapping2) _lou_outOfMemory();\n\t\t\tsizePosMapping2 = mapSize;\n\t\t}\n\t}\n\t\treturn posMapping2;\n\tcase alloc_posMapping3: {\n\t\tint mapSize;\n\t\tif (srcmax >= destmax)\n\t\t\tmapSize = srcmax;\n\t\telse\n\t\t\tmapSize = destmax;\n\t\tif (mapSize > sizePosMapping3) {\n\t\t\tif (posMapping3 != NULL) free(posMapping3);\n\t\t\tposMapping3 = malloc((mapSize + 4) * sizeof(int));\n\t\t\tif (!posMapping3) _lou_outOfMemory();\n\t\t\tsizePosMapping3 = mapSize;\n\t\t}\n\t}\n\t\treturn posMapping3;\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\nvoid EXPORT_CALL\nlou_free(void) {\n\tTranslationTableChainEntry *currentEntry;\n\tTranslationTableChainEntry *previousEntry;\n\tlou_logEnd();\n\tif (translationTableChain != NULL) {\n\t\tcurrentEntry = translationTableChain;\n\t\twhile (currentEntry) {\n\t\t\tfreeTranslationTable(currentEntry->table);\n\t\t\tpreviousEntry = currentEntry;\n\t\t\tcurrentEntry = currentEntry->next;\n\t\t\tfree(previousEntry);\n\t\t}\n\t\ttranslationTableChain = NULL;\n\t}\n\tif (typebuf != NULL) free(typebuf);\n\ttypebuf = NULL;\n\tif (wordBuffer != NULL) free(wordBuffer);\n\twordBuffer = NULL;\n\tif (emphasisBuffer != NULL) free(emphasisBuffer);\n\temphasisBuffer = NULL;\n\tsizeTypebuf = 0;\n\tif (destSpacing != NULL) free(destSpacing);\n\tdestSpacing = NULL;\n\tsizeDestSpacing = 0;\n\t{\n\t\tint k;\n\t\tfor (k = 0; k < MAXPASSBUF; k++) {\n\t\t\tif (passbuf[k] != NULL) free(passbuf[k]);\n\t\t\tpassbuf[k] = NULL;\n\t\t\tsizePassbuf[k] = 0;\n\t\t}\n\t}\n\tif (posMapping1 != NULL) free(posMapping1);\n\tposMapping1 = NULL;\n\tsizePosMapping1 = 0;\n\tif (posMapping2 != NULL) free(posMapping2);\n\tposMapping2 = NULL;\n\tsizePosMapping2 = 0;\n\tif (posMapping3 != NULL) free(posMapping3);\n\tposMapping3 = NULL;\n\tsizePosMapping3 = 0;\n\topcodeLengths[0] = 0;\n}\n\nconst char *EXPORT_CALL\nlou_version(void) {\n\tstatic const char *version = PACKAGE_VERSION;\n\treturn version;\n}\n\nint EXPORT_CALL\nlou_charSize(void) {\n\treturn CHARSIZE;\n}\n\nint EXPORT_CALL\nlou_compileString(const char *tableList, const char *inString) {\n\tTranslationTableHeader *table;\n\tDisplayTableHeader *displayTable;\n\tgetTable(tableList, tableList, &table, &displayTable);\n\tif (!table) return 0;\n\tif (!compileString(inString, &table, &displayTable)) return 0;\n\treturn 1;\n}\n\nint EXPORT_CALL\n_lou_compileTranslationRule(const char *tableList, const char *inString) {\n\tTranslationTableHeader *table;\n\tgetTable(tableList, NULL, &table, NULL);\n\treturn compileString(inString, &table, NULL);\n}\n\nint EXPORT_CALL\n_lou_compileDisplayRule(const char *tableList, const char *inString) {\n\tDisplayTableHeader *table;\n\tgetTable(NULL, tableList, NULL, &table);\n\treturn compileString(inString, NULL, &table);\n}\n\n/**\n * This procedure provides a target for cals that serve as breakpoints\n * for gdb.\n */\n// char *EXPORT_CALL\n// lou_getTablePaths (void)\n// {\n//   static char paths[MAXSTRING];\n//   static char scratchBuf[MAXSTRING];\n//   char *pathList;\n//   strcpy (paths, tablePath);\n//   strcat (paths, \",\");\n//   pathList = getenv (\"LOUIS_TABLEPATH\");\n//   if (pathList)\n//     {\n//       strcat (paths, pathList);\n//       strcat (paths, \",\");\n//     }\n//   pathList = getcwd (scratchBuf, MAXSTRING);\n//   if (pathList)\n//     {\n//       strcat (paths, pathList);\n//       strcat (paths, \",\");\n//     }\n//   pathList = lou_getDataPath ();\n//   if (pathList)\n//     {\n//       strcat (paths, pathList);\n//       strcat (paths, \",\");\n//     }\n// #ifdef _WIN32\n//   strcpy (paths, lou_getProgramPath ());\n//   strcat (paths, \"\\\\share\\\\liblouss\\\\tables\\\\\");\n// #else\n//   strcpy (paths, TABLESDIR);\n// #endif\n//   return paths;\n// }\n"], "filenames": ["liblouis/compileTranslationTable.c"], "buggy_code_start_loc": [3739], "buggy_code_end_loc": [3745], "fixing_code_start_loc": [3739], "fixing_code_end_loc": [3747], "type": "CWE-787", "message": "Liblouis 3.21.0 has an out-of-bounds write in compileRule in compileTranslationTable.c, as demonstrated by lou_trace.", "other": {"cve": {"id": "CVE-2022-31783", "sourceIdentifier": "cve@mitre.org", "published": "2022-06-02T14:15:58.050", "lastModified": "2023-02-23T17:58:25.697", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Liblouis 3.21.0 has an out-of-bounds write in compileRule in compileTranslationTable.c, as demonstrated by lou_trace."}, {"lang": "es", "value": "Liblouis versi\u00f3n 3.21.0, presenta una escritura fuera de l\u00edmites en compileRule en el archivo compileTranslationTable.c, como demuestra lou_trace"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:liblouis:liblouis:3.21.0:*:*:*:*:*:*:*", "matchCriteriaId": "CEA1486A-8C18-4ED8-B9F3-D89E428FED1D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}]}]}], "references": [{"url": "https://github.com/liblouis/liblouis/commit/ff747ec5e1ac54d54194846f6fe5bfc689192a85", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/liblouis/liblouis/issues/1214", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/CFD2KIHESDUCNWTEW3USFB5GKTWT624L/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202301-06", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/liblouis/liblouis/commit/ff747ec5e1ac54d54194846f6fe5bfc689192a85"}}