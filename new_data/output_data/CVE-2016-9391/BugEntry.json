{"buggy_code": ["/*\n * Copyright (c) 1999-2000, Image Power, Inc. and the University of\n *   British Columbia.\n * Copyright (c) 2001-2003 Michael David Adams.\n * All rights reserved.\n */\n\n/* __START_OF_JASPER_LICENSE__\n * \n * JasPer License Version 2.0\n * \n * Copyright (c) 2001-2006 Michael David Adams\n * Copyright (c) 1999-2000 Image Power, Inc.\n * Copyright (c) 1999-2000 The University of British Columbia\n * \n * All rights reserved.\n * \n * Permission is hereby granted, free of charge, to any person (the\n * \"User\") obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n * \n * 1.  The above copyright notices and this permission notice (which\n * includes the disclaimer below) shall be included in all copies or\n * substantial portions of the Software.\n * \n * 2.  The name of a copyright holder shall not be used to endorse or\n * promote products derived from the Software without specific prior\n * written permission.\n * \n * THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS\n * LICENSE.  NO USE OF THE SOFTWARE IS AUTHORIZED HEREUNDER EXCEPT UNDER\n * THIS DISCLAIMER.  THE SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS\n * \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.  IN NO\n * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL\n * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING\n * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\n * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION\n * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  NO ASSURANCES ARE\n * PROVIDED BY THE COPYRIGHT HOLDERS THAT THE SOFTWARE DOES NOT INFRINGE\n * THE PATENT OR OTHER INTELLECTUAL PROPERTY RIGHTS OF ANY OTHER ENTITY.\n * EACH COPYRIGHT HOLDER DISCLAIMS ANY LIABILITY TO THE USER FOR CLAIMS\n * BROUGHT BY ANY OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL\n * PROPERTY RIGHTS OR OTHERWISE.  AS A CONDITION TO EXERCISING THE RIGHTS\n * GRANTED HEREUNDER, EACH USER HEREBY ASSUMES SOLE RESPONSIBILITY TO SECURE\n * ANY OTHER INTELLECTUAL PROPERTY RIGHTS NEEDED, IF ANY.  THE SOFTWARE\n * IS NOT FAULT-TOLERANT AND IS NOT INTENDED FOR USE IN MISSION-CRITICAL\n * SYSTEMS, SUCH AS THOSE USED IN THE OPERATION OF NUCLEAR FACILITIES,\n * AIRCRAFT NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL\n * SYSTEMS, DIRECT LIFE SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH\n * THE FAILURE OF THE SOFTWARE OR SYSTEM COULD LEAD DIRECTLY TO DEATH,\n * PERSONAL INJURY, OR SEVERE PHYSICAL OR ENVIRONMENTAL DAMAGE (\"HIGH\n * RISK ACTIVITIES\").  THE COPYRIGHT HOLDERS SPECIFICALLY DISCLAIM ANY\n * EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR HIGH RISK ACTIVITIES.\n * \n * __END_OF_JASPER_LICENSE__\n */\n\n/*\n * Bit Stream Class\n *\n * $Id$\n */\n\n/******************************************************************************\\\n* Includes.\n\\******************************************************************************/\n\n#include <assert.h>\n#include <stdlib.h>\n#include <stdarg.h>\n\n#include \"jasper/jas_malloc.h\"\n#include \"jasper/jas_math.h\"\n#include \"jasper/jas_debug.h\"\n\n#include \"jpc_bs.h\"\n\n/******************************************************************************\\\n* Local function prototypes.\n\\******************************************************************************/\n\nstatic jpc_bitstream_t *jpc_bitstream_alloc(void);\n\n/******************************************************************************\\\n* Code for opening and closing bit streams.\n\\******************************************************************************/\n\n/* Open a bit stream from a stream. */\njpc_bitstream_t *jpc_bitstream_sopen(jas_stream_t *stream, char *mode)\n{\n\tjpc_bitstream_t *bitstream;\n\n\t/* Ensure that the open mode is valid. */\n#if 0 /* This causes a string literal too long error (with c99 pedantic mode).  Why is this so? */\n\tassert(!strcmp(mode, \"r\") || !strcmp(mode, \"w\") || !strcmp(mode, \"r+\")\n\t  || !strcmp(mode, \"w+\"));\n#endif\n\n\tif (!(bitstream = jpc_bitstream_alloc())) {\n\t\treturn 0;\n\t}\n\n\t/* By default, do not close the underlying (character) stream, upon\n\t  the close of the bit stream. */\n\tbitstream->flags_ = JPC_BITSTREAM_NOCLOSE;\n\n\tbitstream->stream_ = stream;\n\tbitstream->openmode_ = (mode[0] == 'w') ? JPC_BITSTREAM_WRITE :\n\t  JPC_BITSTREAM_READ;\n\n\t/* Mark the data buffer as empty. */\n\tbitstream->cnt_ = (bitstream->openmode_ == JPC_BITSTREAM_READ) ? 0 : 8;\n\tbitstream->buf_ = 0;\n\n\treturn bitstream;\n}\n\n/* Close a bit stream. */\nint jpc_bitstream_close(jpc_bitstream_t *bitstream)\n{\n\tint ret = 0;\n\n\t/* Align to the next byte boundary while considering the effects of\n\t  bit stuffing. */\n\tif (jpc_bitstream_align(bitstream)) {\n\t\tret = -1;\n\t}\n\n\t/* If necessary, close the underlying (character) stream. */\n\tif (!(bitstream->flags_ & JPC_BITSTREAM_NOCLOSE) && bitstream->stream_) {\n\t\tif (jas_stream_close(bitstream->stream_)) {\n\t\t\tret = -1;\n\t\t}\n\t\tbitstream->stream_ = 0;\n\t}\n\n\tjas_free(bitstream);\n\treturn ret;\n}\n\n/* Allocate a new bit stream. */\nstatic jpc_bitstream_t *jpc_bitstream_alloc()\n{\n\tjpc_bitstream_t *bitstream;\n\n\t/* Allocate memory for the new bit stream object. */\n\tif (!(bitstream = jas_malloc(sizeof(jpc_bitstream_t)))) {\n\t\treturn 0;\n\t}\n\t/* Initialize all of the data members. */\n\tbitstream->stream_ = 0;\n\tbitstream->cnt_ = 0;\n\tbitstream->flags_ = 0;\n\tbitstream->openmode_ = 0;\n\n\treturn bitstream;\n}\n\n/******************************************************************************\\\n* Code for reading/writing from/to bit streams.\n\\******************************************************************************/\n\n/* Get a bit from a bit stream. */\nint jpc_bitstream_getbit_func(jpc_bitstream_t *bitstream)\n{\n\tint ret;\n\tJAS_DBGLOG(1000, (\"jpc_bitstream_getbit_func(%p)\\n\", bitstream));\n\tret = jpc_bitstream_getbit_macro(bitstream);\n\tJAS_DBGLOG(1000, (\"jpc_bitstream_getbit_func -> %d\\n\", ret));\n\treturn ret;\n}\n\n/* Put a bit to a bit stream. */\nint jpc_bitstream_putbit_func(jpc_bitstream_t *bitstream, int b)\n{\n\tint ret;\n\tJAS_DBGLOG(1000, (\"jpc_bitstream_putbit_func(%p, %d)\\n\", bitstream, b));\n\tret = jpc_bitstream_putbit_macro(bitstream, b);\n\tJAS_DBGLOG(1000, (\"jpc_bitstream_putbit_func() -> %d\\n\", ret));\n\treturn ret;\n}\n\n/* Get one or more bits from a bit stream. */\nlong jpc_bitstream_getbits(jpc_bitstream_t *bitstream, int n)\n{\n\tlong v;\n\tint u;\n\n\t/* We can reliably get at most 31 bits since ISO/IEC 9899 only\n\t  guarantees that a long can represent values up to 2^31-1. */\n\tassert(n >= 0 && n < 32);\n\n\t/* Get the number of bits requested from the specified bit stream. */\n\tv = 0;\n\twhile (--n >= 0) {\n\t\tif ((u = jpc_bitstream_getbit(bitstream)) < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tv = (v << 1) | u;\n\t}\n\treturn v;\n}\n\n/* Put one or more bits to a bit stream. */\nint jpc_bitstream_putbits(jpc_bitstream_t *bitstream, int n, long v)\n{\n\tint m;\n\n\t/* We can reliably put at most 31 bits since ISO/IEC 9899 only\n\t  guarantees that a long can represent values up to 2^31-1. */\n\tassert(n >= 0 && n < 32);\n\t/* Ensure that only the bits to be output are nonzero. */\n\tassert(!(v & (~JAS_ONES(n))));\n\n\t/* Put the desired number of bits to the specified bit stream. */\n\tm = n - 1;\n\twhile (--n >= 0) {\n\t\tif (jpc_bitstream_putbit(bitstream, (v >> m) & 1) == EOF) {\n\t\t\treturn EOF;\n\t\t}\n\t\tv <<= 1;\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\\\n* Code for buffer filling and flushing.\n\\******************************************************************************/\n\n/* Fill the buffer for a bit stream. */\nint jpc_bitstream_fillbuf(jpc_bitstream_t *bitstream)\n{\n\tint c;\n\t/* Note: The count has already been decremented by the caller. */\n\tassert(bitstream->openmode_ & JPC_BITSTREAM_READ);\n\tassert(bitstream->cnt_ <= 0);\n\n\tif (bitstream->flags_ & JPC_BITSTREAM_ERR) {\n\t\tbitstream->cnt_ = 0;\n\t\treturn -1;\n\t}\n\n\tif (bitstream->flags_ & JPC_BITSTREAM_EOF) {\n\t\tbitstream->buf_ = 0x7f;\n\t\tbitstream->cnt_ = 7;\n\t\treturn 1;\n\t}\n\n\tbitstream->buf_ = (bitstream->buf_ << 8) & 0xffff;\n\tif ((c = jas_stream_getc((bitstream)->stream_)) == EOF) {\n\t\tbitstream->flags_ |= JPC_BITSTREAM_EOF;\n\t\treturn 1;\n\t}\n\tbitstream->cnt_ = (bitstream->buf_ == 0xff00) ? 6 : 7;\n\tbitstream->buf_ |= c & ((1 << (bitstream->cnt_ + 1)) - 1);\n\treturn (bitstream->buf_ >> bitstream->cnt_) & 1;\n}\n\n\n/******************************************************************************\\\n* Code related to flushing.\n\\******************************************************************************/\n\n/* Does the bit stream need to be aligned to a byte boundary (considering\n  the effects of bit stuffing)? */\nint jpc_bitstream_needalign(jpc_bitstream_t *bitstream)\n{\n\tif (bitstream->openmode_ & JPC_BITSTREAM_READ) {\n\t\t/* The bit stream is open for reading. */\n\t\t/* If there are any bits buffered for reading, or the\n\t\t  previous byte forced a stuffed bit, alignment is\n\t\t  required. */\n\t\tif ((bitstream->cnt_ < 8 && bitstream->cnt_ > 0) ||\n\t\t  ((bitstream->buf_ >> 8) & 0xff) == 0xff) {\n\t\t\treturn 1;\n\t\t}\n\t} else if (bitstream->openmode_ & JPC_BITSTREAM_WRITE) {\n\t\t/* The bit stream is open for writing. */\n\t\t/* If there are any bits buffered for writing, or the\n\t\t  previous byte forced a stuffed bit, alignment is\n\t\t  required. */\n\t\tif ((bitstream->cnt_ < 8 && bitstream->cnt_ >= 0) ||\n\t\t  ((bitstream->buf_ >> 8) & 0xff) == 0xff) {\n\t\t\treturn 1;\n\t\t}\n\t} else {\n\t\t/* This should not happen.  Famous last words, eh? :-) */\n\t\tassert(0);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n/* How many additional bytes would be output if we align the bit stream? */\nint jpc_bitstream_pending(jpc_bitstream_t *bitstream)\n{\n\tif (bitstream->openmode_ & JPC_BITSTREAM_WRITE) {\n\t\t/* The bit stream is being used for writing. */\n#if 1\n\t\t/* XXX - Is this really correct?  Check someday... */\n\t\tif (bitstream->cnt_ < 8) {\n\t\t\treturn 1;\n\t\t}\n#else\n\t\tif (bitstream->cnt_ < 8) {\n\t\t\tif (((bitstream->buf_ >> 8) & 0xff) == 0xff) {\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n#endif\n\t\treturn 0;\n\t} else {\n\t\t/* This operation should not be invoked on a bit stream that\n\t\t  is being used for reading. */\n\t\treturn -1;\n\t}\n}\n\n/* Align the bit stream to a byte boundary. */\nint jpc_bitstream_align(jpc_bitstream_t *bitstream)\n{\n\tint ret;\n\tif (bitstream->openmode_ & JPC_BITSTREAM_READ) {\n\t\tret = jpc_bitstream_inalign(bitstream, 0, 0);\n\t} else if (bitstream->openmode_ & JPC_BITSTREAM_WRITE) {\n\t\tret = jpc_bitstream_outalign(bitstream, 0);\n\t} else {\n\t\tabort();\n\t}\n\treturn ret;\n}\n\n/* Align a bit stream in the input case. */\nint jpc_bitstream_inalign(jpc_bitstream_t *bitstream, int fillmask,\n  int filldata)\n{\n\tint n;\n\tint v;\n\tint u;\n\tint numfill;\n\tint m;\n\n\tnumfill = 7;\n\tm = 0;\n\tv = 0;\n\tif (bitstream->cnt_ > 0) {\n\t\tn = bitstream->cnt_;\n\t} else if (!bitstream->cnt_) {\n\t\tn = ((bitstream->buf_ & 0xff) == 0xff) ? 7 : 0;\n\t} else {\n\t\tn = 0;\n\t}\n\tif (n > 0) {\n\t\tif ((u = jpc_bitstream_getbits(bitstream, n)) < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tm += n;\n\t\tv = (v << n) | u;\n\t}\n\tif ((bitstream->buf_ & 0xff) == 0xff) {\n\t\tif ((u = jpc_bitstream_getbits(bitstream, 7)) < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tv = (v << 7) | u;\n\t\tm += 7;\n\t}\n\tif (m > numfill) {\n\t\tv >>= m - numfill;\n\t} else {\n\t\tfilldata >>= numfill - m;\n\t\tfillmask >>= numfill - m;\n\t}\n\tif (((~(v ^ filldata)) & fillmask) != fillmask) {\n\t\t/* The actual fill pattern does not match the expected one. */\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n/* Align a bit stream in the output case. */\nint jpc_bitstream_outalign(jpc_bitstream_t *bitstream, int filldata)\n{\n\tint n;\n\tint v;\n\n\t/* Ensure that this bit stream is open for writing. */\n\tassert(bitstream->openmode_ & JPC_BITSTREAM_WRITE);\n\n\t/* Ensure that the first bit of fill data is zero. */\n\t/* Note: The first bit of fill data must be zero.  If this were not\n\t  the case, the fill data itself could cause further bit stuffing to\n\t  be required (which would cause numerous complications). */\n\tassert(!(filldata & (~0x3f)));\n\n\tif (!bitstream->cnt_) {\n\t\tif ((bitstream->buf_ & 0xff) == 0xff) {\n\t\t\tn = 7;\n\t\t\tv = filldata;\n\t\t} else {\n\t\t\tn = 0;\n\t\t\tv = 0;\n\t\t}\n\t} else if (bitstream->cnt_ > 0 && bitstream->cnt_ < 8) {\n\t\tn = bitstream->cnt_;\n\t\tv = filldata >> (7 - n);\n\t} else {\n\t\tn = 0;\n\t\tv = 0;\n\t\treturn 0;\n\t}\n\n\t/* Write the appropriate fill data to the bit stream. */\n\tif (n > 0) {\n\t\tif (jpc_bitstream_putbits(bitstream, n, v)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (bitstream->cnt_ < 8) {\n\t\tassert(bitstream->cnt_ >= 0 && bitstream->cnt_ < 8);\n\t\tassert((bitstream->buf_ & 0xff) != 0xff);\n\t\t/* Force the pending byte of output to be written to the\n\t\t  underlying (character) stream. */\n\t\tif (jas_stream_putc(bitstream->stream_, bitstream->buf_ & 0xff) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t\tbitstream->cnt_ = 8;\n\t\tbitstream->buf_ = (bitstream->buf_ << 8) & 0xffff;\n\t}\n\n\treturn 0;\n}\n", "/*\n * Copyright (c) 1999-2000 Image Power, Inc. and the University of\n *   British Columbia.\n * Copyright (c) 2001-2002 Michael David Adams.\n * All rights reserved.\n */\n\n/* __START_OF_JASPER_LICENSE__\n * \n * JasPer License Version 2.0\n * \n * Copyright (c) 2001-2006 Michael David Adams\n * Copyright (c) 1999-2000 Image Power, Inc.\n * Copyright (c) 1999-2000 The University of British Columbia\n * \n * All rights reserved.\n * \n * Permission is hereby granted, free of charge, to any person (the\n * \"User\") obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n * \n * 1.  The above copyright notices and this permission notice (which\n * includes the disclaimer below) shall be included in all copies or\n * substantial portions of the Software.\n * \n * 2.  The name of a copyright holder shall not be used to endorse or\n * promote products derived from the Software without specific prior\n * written permission.\n * \n * THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS\n * LICENSE.  NO USE OF THE SOFTWARE IS AUTHORIZED HEREUNDER EXCEPT UNDER\n * THIS DISCLAIMER.  THE SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS\n * \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.  IN NO\n * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL\n * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING\n * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\n * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION\n * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  NO ASSURANCES ARE\n * PROVIDED BY THE COPYRIGHT HOLDERS THAT THE SOFTWARE DOES NOT INFRINGE\n * THE PATENT OR OTHER INTELLECTUAL PROPERTY RIGHTS OF ANY OTHER ENTITY.\n * EACH COPYRIGHT HOLDER DISCLAIMS ANY LIABILITY TO THE USER FOR CLAIMS\n * BROUGHT BY ANY OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL\n * PROPERTY RIGHTS OR OTHERWISE.  AS A CONDITION TO EXERCISING THE RIGHTS\n * GRANTED HEREUNDER, EACH USER HEREBY ASSUMES SOLE RESPONSIBILITY TO SECURE\n * ANY OTHER INTELLECTUAL PROPERTY RIGHTS NEEDED, IF ANY.  THE SOFTWARE\n * IS NOT FAULT-TOLERANT AND IS NOT INTENDED FOR USE IN MISSION-CRITICAL\n * SYSTEMS, SUCH AS THOSE USED IN THE OPERATION OF NUCLEAR FACILITIES,\n * AIRCRAFT NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL\n * SYSTEMS, DIRECT LIFE SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH\n * THE FAILURE OF THE SOFTWARE OR SYSTEM COULD LEAD DIRECTLY TO DEATH,\n * PERSONAL INJURY, OR SEVERE PHYSICAL OR ENVIRONMENTAL DAMAGE (\"HIGH\n * RISK ACTIVITIES\").  THE COPYRIGHT HOLDERS SPECIFICALLY DISCLAIM ANY\n * EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR HIGH RISK ACTIVITIES.\n * \n * __END_OF_JASPER_LICENSE__\n */\n\n/*\n * JPEG-2000 Code Stream Library\n *\n * $Id$\n */\n\n/******************************************************************************\\\n* Includes.\n\\******************************************************************************/\n\n#include <stdlib.h>\n#include <assert.h>\n#include <ctype.h>\n#include <inttypes.h>\n\n#include \"jasper/jas_malloc.h\"\n#include \"jasper/jas_debug.h\"\n\n#include \"jpc_cs.h\"\n\n/******************************************************************************\\\n* Types.\n\\******************************************************************************/\n\n/* Marker segment table entry. */\ntypedef struct {\n\tint id;\n\tchar *name;\n\tjpc_msops_t ops;\n} jpc_mstabent_t;\n\n/******************************************************************************\\\n* Local prototypes.\n\\******************************************************************************/\n\nstatic jpc_mstabent_t *jpc_mstab_lookup(int id);\n\nstatic int jpc_poc_dumpparms(jpc_ms_t *ms, FILE *out);\nstatic int jpc_poc_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out);\nstatic int jpc_poc_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in);\nstatic void jpc_poc_destroyparms(jpc_ms_t *ms);\n\nstatic int jpc_unk_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in);\nstatic int jpc_sot_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in);\nstatic int jpc_siz_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in);\nstatic int jpc_cod_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in);\nstatic int jpc_coc_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in);\nstatic int jpc_qcd_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in);\nstatic int jpc_qcc_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in);\nstatic int jpc_rgn_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in);\nstatic int jpc_sop_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in);\nstatic int jpc_ppm_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in);\nstatic int jpc_ppt_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in);\nstatic int jpc_crg_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in);\nstatic int jpc_com_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in);\n\nstatic int jpc_sot_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out);\nstatic int jpc_siz_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out);\nstatic int jpc_cod_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out);\nstatic int jpc_coc_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out);\nstatic int jpc_qcd_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out);\nstatic int jpc_qcc_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out);\nstatic int jpc_rgn_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out);\nstatic int jpc_unk_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out);\nstatic int jpc_sop_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out);\nstatic int jpc_ppm_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out);\nstatic int jpc_ppt_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out);\nstatic int jpc_crg_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out);\nstatic int jpc_com_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out);\n\nstatic int jpc_sot_dumpparms(jpc_ms_t *ms, FILE *out);\nstatic int jpc_siz_dumpparms(jpc_ms_t *ms, FILE *out);\nstatic int jpc_cod_dumpparms(jpc_ms_t *ms, FILE *out);\nstatic int jpc_coc_dumpparms(jpc_ms_t *ms, FILE *out);\nstatic int jpc_qcd_dumpparms(jpc_ms_t *ms, FILE *out);\nstatic int jpc_qcc_dumpparms(jpc_ms_t *ms, FILE *out);\nstatic int jpc_rgn_dumpparms(jpc_ms_t *ms, FILE *out);\nstatic int jpc_unk_dumpparms(jpc_ms_t *ms, FILE *out);\nstatic int jpc_sop_dumpparms(jpc_ms_t *ms, FILE *out);\nstatic int jpc_ppm_dumpparms(jpc_ms_t *ms, FILE *out);\nstatic int jpc_ppt_dumpparms(jpc_ms_t *ms, FILE *out);\nstatic int jpc_crg_dumpparms(jpc_ms_t *ms, FILE *out);\nstatic int jpc_com_dumpparms(jpc_ms_t *ms, FILE *out);\n\nstatic void jpc_siz_destroyparms(jpc_ms_t *ms);\nstatic void jpc_qcd_destroyparms(jpc_ms_t *ms);\nstatic void jpc_qcc_destroyparms(jpc_ms_t *ms);\nstatic void jpc_cod_destroyparms(jpc_ms_t *ms);\nstatic void jpc_coc_destroyparms(jpc_ms_t *ms);\nstatic void jpc_unk_destroyparms(jpc_ms_t *ms);\nstatic void jpc_ppm_destroyparms(jpc_ms_t *ms);\nstatic void jpc_ppt_destroyparms(jpc_ms_t *ms);\nstatic void jpc_crg_destroyparms(jpc_ms_t *ms);\nstatic void jpc_com_destroyparms(jpc_ms_t *ms);\n\nstatic void jpc_qcx_destroycompparms(jpc_qcxcp_t *compparms);\nstatic int jpc_qcx_getcompparms(jpc_qcxcp_t *compparms, jpc_cstate_t *cstate,\n  jas_stream_t *in, uint_fast16_t len);\nstatic int jpc_qcx_putcompparms(jpc_qcxcp_t *compparms, jpc_cstate_t *cstate,\n  jas_stream_t *out);\nstatic void jpc_cox_destroycompparms(jpc_coxcp_t *compparms);\nstatic int jpc_cox_getcompparms(jpc_ms_t *ms, jpc_cstate_t *cstate,\n  jas_stream_t *in, int prtflag, jpc_coxcp_t *compparms);\nstatic int jpc_cox_putcompparms(jpc_ms_t *ms, jpc_cstate_t *cstate,\n  jas_stream_t *out, int prtflag, jpc_coxcp_t *compparms);\n\n/******************************************************************************\\\n* Global data.\n\\******************************************************************************/\n\nstatic jpc_mstabent_t jpc_mstab[] = {\n\t{JPC_MS_SOC, \"SOC\", {0, 0, 0, 0}},\n\t{JPC_MS_SOT, \"SOT\", {0, jpc_sot_getparms, jpc_sot_putparms,\n\t  jpc_sot_dumpparms}},\n\t{JPC_MS_SOD, \"SOD\", {0, 0, 0, 0}},\n\t{JPC_MS_EOC, \"EOC\", {0, 0, 0, 0}},\n\t{JPC_MS_SIZ, \"SIZ\", {jpc_siz_destroyparms, jpc_siz_getparms,\n\t  jpc_siz_putparms, jpc_siz_dumpparms}},\n\t{JPC_MS_COD, \"COD\", {jpc_cod_destroyparms, jpc_cod_getparms,\n\t  jpc_cod_putparms, jpc_cod_dumpparms}},\n\t{JPC_MS_COC, \"COC\", {jpc_coc_destroyparms, jpc_coc_getparms,\n\t  jpc_coc_putparms, jpc_coc_dumpparms}},\n\t{JPC_MS_RGN, \"RGN\", {0, jpc_rgn_getparms, jpc_rgn_putparms,\n\t  jpc_rgn_dumpparms}},\n\t{JPC_MS_QCD, \"QCD\", {jpc_qcd_destroyparms, jpc_qcd_getparms,\n\t  jpc_qcd_putparms, jpc_qcd_dumpparms}},\n\t{JPC_MS_QCC, \"QCC\", {jpc_qcc_destroyparms, jpc_qcc_getparms,\n\t  jpc_qcc_putparms, jpc_qcc_dumpparms}},\n\t{JPC_MS_POC, \"POC\", {jpc_poc_destroyparms, jpc_poc_getparms,\n\t  jpc_poc_putparms, jpc_poc_dumpparms}},\n\t{JPC_MS_TLM, \"TLM\", {0, jpc_unk_getparms, jpc_unk_putparms, 0}},\n\t{JPC_MS_PLM, \"PLM\", {0, jpc_unk_getparms, jpc_unk_putparms, 0}},\n\t{JPC_MS_PPM, \"PPM\", {jpc_ppm_destroyparms, jpc_ppm_getparms,\n\t  jpc_ppm_putparms, jpc_ppm_dumpparms}},\n\t{JPC_MS_PPT, \"PPT\", {jpc_ppt_destroyparms, jpc_ppt_getparms,\n\t  jpc_ppt_putparms, jpc_ppt_dumpparms}},\n\t{JPC_MS_SOP, \"SOP\", {0, jpc_sop_getparms, jpc_sop_putparms,\n\t  jpc_sop_dumpparms}},\n\t{JPC_MS_EPH, \"EPH\", {0, 0, 0, 0}},\n\t{JPC_MS_CRG, \"CRG\", {jpc_crg_destroyparms, jpc_crg_getparms,\n\t  jpc_crg_putparms, jpc_crg_dumpparms}},\n\t{JPC_MS_COM, \"COM\", {jpc_com_destroyparms, jpc_com_getparms,\n\t  jpc_com_putparms, jpc_com_dumpparms}},\n\t{-1, \"UNKNOWN\",  {jpc_unk_destroyparms, jpc_unk_getparms,\n\t  jpc_unk_putparms, jpc_unk_dumpparms}}\n};\n\n/******************************************************************************\\\n* Code stream manipulation functions.\n\\******************************************************************************/\n\n/* Create a code stream state object. */\njpc_cstate_t *jpc_cstate_create()\n{\n\tjpc_cstate_t *cstate;\n\tif (!(cstate = jas_malloc(sizeof(jpc_cstate_t)))) {\n\t\treturn 0;\n\t}\n\tcstate->numcomps = 0;\n\treturn cstate;\n}\n\n/* Destroy a code stream state object. */\nvoid jpc_cstate_destroy(jpc_cstate_t *cstate)\n{\n\tjas_free(cstate);\n}\n\n/* Read a marker segment from a stream. */\njpc_ms_t *jpc_getms(jas_stream_t *in, jpc_cstate_t *cstate)\n{\n\tjpc_ms_t *ms;\n\tjpc_mstabent_t *mstabent;\n\tjas_stream_t *tmpstream;\n\n\tif (!(ms = jpc_ms_create(0))) {\n\t\treturn 0;\n\t}\n\n\t/* Get the marker type. */\n\tif (jpc_getuint16(in, &ms->id) || ms->id < JPC_MS_MIN ||\n\t  ms->id > JPC_MS_MAX) {\n\t\tjpc_ms_destroy(ms);\n\t\treturn 0;\n\t}\n\n\tmstabent = jpc_mstab_lookup(ms->id);\n\tms->ops = &mstabent->ops;\n\n\t/* Get the marker segment length and parameters if present. */\n\t/* Note: It is tacitly assumed that a marker segment cannot have\n\t  parameters unless it has a length field.  That is, there cannot\n\t  be a parameters field without a length field and vice versa. */\n\tif (JPC_MS_HASPARMS(ms->id)) {\n\t\t/* Get the length of the marker segment. */\n\t\tif (jpc_getuint16(in, &ms->len) || ms->len < 3) {\n\t\t\tjpc_ms_destroy(ms);\n\t\t\treturn 0;\n\t\t}\n\t\t/* Calculate the length of the marker segment parameters. */\n\t\tms->len -= 2;\n\t\t/* Create and prepare a temporary memory stream from which to\n\t\t  read the marker segment parameters. */\n\t\t/* Note: This approach provides a simple way of ensuring that\n\t\t  we never read beyond the end of the marker segment (even if\n\t\t  the marker segment length is errantly set too small). */\n\t\tif (!(tmpstream = jas_stream_memopen(0, 0))) {\n\t\t\tjpc_ms_destroy(ms);\n\t\t\treturn 0;\n\t\t}\n\t\tif (jas_stream_copy(tmpstream, in, ms->len) ||\n\t\t  jas_stream_seek(tmpstream, 0, SEEK_SET) < 0) {\n\t\t\tjas_stream_close(tmpstream);\n\t\t\tjpc_ms_destroy(ms);\n\t\t\treturn 0;\n\t\t}\n\t\t/* Get the marker segment parameters. */\n\t\tif ((*ms->ops->getparms)(ms, cstate, tmpstream)) {\n\t\t\tms->ops = 0;\n\t\t\tjpc_ms_destroy(ms);\n\t\t\tjas_stream_close(tmpstream);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (jas_getdbglevel() > 0) {\n\t\t\tjpc_ms_dump(ms, stderr);\n\t\t}\n\n\t\tif (JAS_CAST(ulong, jas_stream_tell(tmpstream)) != ms->len) {\n\t\t\tjas_eprintf(\"warning: trailing garbage in marker segment (%ld bytes)\\n\",\n\t\t\t  ms->len - jas_stream_tell(tmpstream));\n\t\t}\n\n\t\t/* Close the temporary stream. */\n\t\tjas_stream_close(tmpstream);\n\n\t} else {\n\t\t/* There are no marker segment parameters. */\n\t\tms->len = 0;\n\n\t\tif (jas_getdbglevel() > 0) {\n\t\t\tjpc_ms_dump(ms, stderr);\n\t\t}\n\t}\n\n\t/* Update the code stream state information based on the type of\n\t  marker segment read. */\n\t/* Note: This is a bit of a hack, but I'm not going to define another\n\t  type of virtual function for this one special case. */\n\tif (ms->id == JPC_MS_SIZ) {\n\t\tcstate->numcomps = ms->parms.siz.numcomps;\n\t}\n\n\treturn ms;\n}\n\n/* Write a marker segment to a stream. */\nint jpc_putms(jas_stream_t *out, jpc_cstate_t *cstate, jpc_ms_t *ms)\n{\n\tjas_stream_t *tmpstream;\n\tint len;\n\n\t/* Output the marker segment type. */\n\tif (jpc_putuint16(out, ms->id)) {\n\t\treturn -1;\n\t}\n\n\t/* Output the marker segment length and parameters if necessary. */\n\tif (ms->ops->putparms) {\n\t\t/* Create a temporary stream in which to buffer the\n\t\t  parameter data. */\n\t\tif (!(tmpstream = jas_stream_memopen(0, 0))) {\n\t\t\treturn -1;\n\t\t}\n\t\tif ((*ms->ops->putparms)(ms, cstate, tmpstream)) {\n\t\t\tjas_stream_close(tmpstream);\n\t\t\treturn -1;\n\t\t}\n\t\t/* Get the number of bytes of parameter data written. */\n\t\tif ((len = jas_stream_tell(tmpstream)) < 0) {\n\t\t\tjas_stream_close(tmpstream);\n\t\t\treturn -1;\n\t\t}\n\t\tms->len = len;\n\t\t/* Write the marker segment length and parameter data to\n\t\t  the output stream. */\n\t\tif (jas_stream_seek(tmpstream, 0, SEEK_SET) < 0 ||\n\t\t  jpc_putuint16(out, ms->len + 2) ||\n\t\t  jas_stream_copy(out, tmpstream, ms->len) < 0) {\n\t\t\tjas_stream_close(tmpstream);\n\t\t\treturn -1;\n\t\t}\n\t\t/* Close the temporary stream. */\n\t\tjas_stream_close(tmpstream);\n\t}\n\n\t/* This is a bit of a hack, but I'm not going to define another\n\t  type of virtual function for this one special case. */\n\tif (ms->id == JPC_MS_SIZ) {\n\t\tcstate->numcomps = ms->parms.siz.numcomps;\n\t}\n\n\tif (jas_getdbglevel() > 0) {\n\t\tjpc_ms_dump(ms, stderr);\n\t}\n\n\treturn 0;\n}\n\n/******************************************************************************\\\n* Marker segment operations.\n\\******************************************************************************/\n\n/* Create a marker segment of the specified type. */\njpc_ms_t *jpc_ms_create(int type)\n{\n\tjpc_ms_t *ms;\n\tjpc_mstabent_t *mstabent;\n\n\tif (!(ms = jas_malloc(sizeof(jpc_ms_t)))) {\n\t\treturn 0;\n\t}\n\tms->id = type;\n\tms->len = 0;\n\tmstabent = jpc_mstab_lookup(ms->id);\n\tms->ops = &mstabent->ops;\n\tmemset(&ms->parms, 0, sizeof(jpc_msparms_t));\n\treturn ms;\n}\n\n/* Destroy a marker segment. */\nvoid jpc_ms_destroy(jpc_ms_t *ms)\n{\n\tif (ms->ops && ms->ops->destroyparms) {\n\t\t(*ms->ops->destroyparms)(ms);\n\t}\n\tjas_free(ms);\n}\n\n/* Dump a marker segment to a stream for debugging. */\nvoid jpc_ms_dump(jpc_ms_t *ms, FILE *out)\n{\n\tjpc_mstabent_t *mstabent;\n\tmstabent = jpc_mstab_lookup(ms->id);\n\tfprintf(out, \"type = 0x%04\"PRIxFAST16\" (%s);\", ms->id, mstabent->name);\n\tif (JPC_MS_HASPARMS(ms->id)) {\n\t\tfprintf(out, \" len = %\"PRIuFAST16\";\", ms->len + 2);\n\t\tif (ms->ops->dumpparms) {\n\t\t\t(*ms->ops->dumpparms)(ms, out);\n\t\t} else {\n\t\t\tfprintf(out, \"\\n\");\n\t\t}\n\t} else {\n\t\tfprintf(out, \"\\n\");\n\t}\n}\n\n/******************************************************************************\\\n* SOT marker segment operations.\n\\******************************************************************************/\n\nstatic int jpc_sot_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in)\n{\n\tjpc_sot_t *sot = &ms->parms.sot;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tcstate = 0;\n\n\tif (jpc_getuint16(in, &sot->tileno) ||\n\t  jpc_getuint32(in, &sot->len) ||\n\t  jpc_getuint8(in, &sot->partno) ||\n\t  jpc_getuint8(in, &sot->numparts)) {\n\t\treturn -1;\n\t}\n\tif (sot->tileno > 65534 || sot->len < 12 || sot->partno > 254 ||\n\t  sot->numparts < 1 || sot->numparts > 255) {\n\t\treturn -1;\n\t}\n\tif (jas_stream_eof(in)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_sot_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out)\n{\n\tjpc_sot_t *sot = &ms->parms.sot;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tcstate = 0;\n\n\tif (jpc_putuint16(out, sot->tileno) ||\n\t  jpc_putuint32(out, sot->len) ||\n\t  jpc_putuint8(out, sot->partno) ||\n\t  jpc_putuint8(out, sot->numparts)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_sot_dumpparms(jpc_ms_t *ms, FILE *out)\n{\n\tjpc_sot_t *sot = &ms->parms.sot;\n\tfprintf(out,\n\t  \"tileno = %\"PRIuFAST16\"; len = %\"PRIuFAST32\"; partno = %d; numparts = %d\\n\",\n\t  sot->tileno, sot->len, sot->partno, sot->numparts);\n\treturn 0;\n}\n\n/******************************************************************************\\\n* SIZ marker segment operations.\n\\******************************************************************************/\n\nstatic void jpc_siz_destroyparms(jpc_ms_t *ms)\n{\n\tjpc_siz_t *siz = &ms->parms.siz;\n\tif (siz->comps) {\n\t\tjas_free(siz->comps);\n\t}\n}\n\nstatic int jpc_siz_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate,\n  jas_stream_t *in)\n{\n\tjpc_siz_t *siz = &ms->parms.siz;\n\tunsigned int i;\n\tuint_fast8_t tmp;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tcstate = 0;\n\n\tif (jpc_getuint16(in, &siz->caps) ||\n\t  jpc_getuint32(in, &siz->width) ||\n\t  jpc_getuint32(in, &siz->height) ||\n\t  jpc_getuint32(in, &siz->xoff) ||\n\t  jpc_getuint32(in, &siz->yoff) ||\n\t  jpc_getuint32(in, &siz->tilewidth) ||\n\t  jpc_getuint32(in, &siz->tileheight) ||\n\t  jpc_getuint32(in, &siz->tilexoff) ||\n\t  jpc_getuint32(in, &siz->tileyoff) ||\n\t  jpc_getuint16(in, &siz->numcomps)) {\n\t\treturn -1;\n\t}\n\tif (!siz->width || !siz->height || !siz->tilewidth ||\n\t  !siz->tileheight || !siz->numcomps || siz->numcomps > 16384) {\n\t\treturn -1;\n\t}\n\tif (!(siz->comps = jas_alloc2(siz->numcomps, sizeof(jpc_sizcomp_t)))) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < siz->numcomps; ++i) {\n\t\tif (jpc_getuint8(in, &tmp) ||\n\t\t  jpc_getuint8(in, &siz->comps[i].hsamp) ||\n\t\t  jpc_getuint8(in, &siz->comps[i].vsamp)) {\n\t\t\tjas_free(siz->comps);\n\t\t\treturn -1;\n\t\t}\n\t\tif (siz->comps[i].hsamp == 0 || siz->comps[i].hsamp > 255) {\n\t\t\tjas_eprintf(\"invalid XRsiz value %d\\n\", siz->comps[i].hsamp);\n\t\t\tjas_free(siz->comps);\n\t\t\treturn -1;\n\t\t}\n\t\tif (siz->comps[i].vsamp == 0 || siz->comps[i].vsamp > 255) {\n\t\t\tjas_eprintf(\"invalid YRsiz value %d\\n\", siz->comps[i].vsamp);\n\t\t\tjas_free(siz->comps);\n\t\t\treturn -1;\n\t\t}\n\t\tsiz->comps[i].sgnd = (tmp >> 7) & 1;\n\t\tsiz->comps[i].prec = (tmp & 0x7f) + 1;\n\t}\n\tif (jas_stream_eof(in)) {\n\t\tjas_free(siz->comps);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_siz_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out)\n{\n\tjpc_siz_t *siz = &ms->parms.siz;\n\tunsigned int i;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tcstate = 0;\n\n\tassert(siz->width && siz->height && siz->tilewidth &&\n\t  siz->tileheight && siz->numcomps);\n\tif (jpc_putuint16(out, siz->caps) ||\n\t  jpc_putuint32(out, siz->width) ||\n\t  jpc_putuint32(out, siz->height) ||\n\t  jpc_putuint32(out, siz->xoff) ||\n\t  jpc_putuint32(out, siz->yoff) ||\n\t  jpc_putuint32(out, siz->tilewidth) ||\n\t  jpc_putuint32(out, siz->tileheight) ||\n\t  jpc_putuint32(out, siz->tilexoff) ||\n\t  jpc_putuint32(out, siz->tileyoff) ||\n\t  jpc_putuint16(out, siz->numcomps)) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < siz->numcomps; ++i) {\n\t\tif (jpc_putuint8(out, ((siz->comps[i].sgnd & 1) << 7) |\n\t\t  ((siz->comps[i].prec - 1) & 0x7f)) ||\n\t\t  jpc_putuint8(out, siz->comps[i].hsamp) ||\n\t\t  jpc_putuint8(out, siz->comps[i].vsamp)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int jpc_siz_dumpparms(jpc_ms_t *ms, FILE *out)\n{\n\tjpc_siz_t *siz = &ms->parms.siz;\n\tunsigned int i;\n\tfprintf(out, \"caps = 0x%02\"PRIxFAST16\";\\n\", siz->caps);\n\tfprintf(out, \"width = %\"PRIuFAST32\"; height = %\"PRIuFAST32\"; xoff = %\"PRIuFAST32\"; yoff = %\" PRIuFAST32 \";\\n\",\n\t  siz->width, siz->height, siz->xoff, siz->yoff);\n\tfprintf(out, \"tilewidth = %\"PRIuFAST32\"; tileheight = %\"PRIuFAST32\"; \"\n\t  \"tilexoff = %\"PRIuFAST32\"; tileyoff = %\" PRIuFAST32 \";\\n\",\n\t  siz->tilewidth, siz->tileheight, siz->tilexoff, siz->tileyoff);\n\tfprintf(out, \"numcomps = %\"PRIuFAST16\";\\n\", siz->numcomps);\n\tfor (i = 0; i < siz->numcomps; ++i) {\n\t\tfprintf(out, \"prec[%d] = %d; sgnd[%d] = %d; hsamp[%d] = %d; \"\n\t\t  \"vsamp[%d] = %d\\n\", i, siz->comps[i].prec, i,\n\t\t  siz->comps[i].sgnd, i, siz->comps[i].hsamp, i,\n\t\t  siz->comps[i].vsamp);\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\\\n* COD marker segment operations.\n\\******************************************************************************/\n\nstatic void jpc_cod_destroyparms(jpc_ms_t *ms)\n{\n\tjpc_cod_t *cod = &ms->parms.cod;\n\tjpc_cox_destroycompparms(&cod->compparms);\n}\n\nstatic int jpc_cod_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in)\n{\n\tjpc_cod_t *cod = &ms->parms.cod;\n\tif (jpc_getuint8(in, &cod->csty)) {\n\t\treturn -1;\n\t}\n\tif (jpc_getuint8(in, &cod->prg) ||\n\t  jpc_getuint16(in, &cod->numlyrs) ||\n\t  jpc_getuint8(in, &cod->mctrans)) {\n\t\treturn -1;\n\t}\n\tif (cod->numlyrs < 1 || cod->numlyrs > 65535) {\n\t\treturn -1;\n\t}\n\tif (jpc_cox_getcompparms(ms, cstate, in,\n\t  (cod->csty & JPC_COX_PRT) != 0, &cod->compparms)) {\n\t\treturn -1;\n\t}\n\tif (jas_stream_eof(in)) {\n\t\tjpc_cod_destroyparms(ms);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_cod_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out)\n{\n\tjpc_cod_t *cod = &ms->parms.cod;\n\tassert(cod->numlyrs > 0 && cod->compparms.numdlvls <= 32);\n\tassert(cod->compparms.numdlvls == cod->compparms.numrlvls - 1);\n\tif (jpc_putuint8(out, cod->compparms.csty) ||\n\t  jpc_putuint8(out, cod->prg) ||\n\t  jpc_putuint16(out, cod->numlyrs) ||\n\t  jpc_putuint8(out, cod->mctrans)) {\n\t\treturn -1;\n\t}\n\tif (jpc_cox_putcompparms(ms, cstate, out,\n\t  (cod->csty & JPC_COX_PRT) != 0, &cod->compparms)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_cod_dumpparms(jpc_ms_t *ms, FILE *out)\n{\n\tjpc_cod_t *cod = &ms->parms.cod;\n\tint i;\n\tfprintf(out, \"csty = 0x%02x;\\n\", cod->compparms.csty);\n\tfprintf(out, \"numdlvls = %d; qmfbid = %d; mctrans = %d\\n\",\n\t  cod->compparms.numdlvls, cod->compparms.qmfbid, cod->mctrans);\n\tfprintf(out, \"prg = %d; numlyrs = %\"PRIuFAST16\";\\n\",\n\t  cod->prg, cod->numlyrs);\n\tfprintf(out, \"cblkwidthval = %d; cblkheightval = %d; \"\n\t  \"cblksty = 0x%02x;\\n\", cod->compparms.cblkwidthval, cod->compparms.cblkheightval,\n\t  cod->compparms.cblksty);\n\tif (cod->csty & JPC_COX_PRT) {\n\t\tfor (i = 0; i < cod->compparms.numrlvls; ++i) {\n\t\t\tjas_eprintf(\"prcwidth[%d] = %d, prcheight[%d] = %d\\n\",\n\t\t\t  i, cod->compparms.rlvls[i].parwidthval,\n\t\t\t  i, cod->compparms.rlvls[i].parheightval);\n\t\t}\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\\\n* COC marker segment operations.\n\\******************************************************************************/\n\nstatic void jpc_coc_destroyparms(jpc_ms_t *ms)\n{\n\tjpc_coc_t *coc = &ms->parms.coc;\n\tjpc_cox_destroycompparms(&coc->compparms);\n}\n\nstatic int jpc_coc_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in)\n{\n\tjpc_coc_t *coc = &ms->parms.coc;\n\tuint_fast8_t tmp;\n\tif (cstate->numcomps <= 256) {\n\t\tif (jpc_getuint8(in, &tmp)) {\n\t\t\treturn -1;\n\t\t}\n\t\tcoc->compno = tmp;\n\t} else {\n\t\tif (jpc_getuint16(in, &coc->compno)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (jpc_getuint8(in, &coc->compparms.csty)) {\n\t\treturn -1;\n\t}\n\tif (jpc_cox_getcompparms(ms, cstate, in,\n\t  (coc->compparms.csty & JPC_COX_PRT) != 0, &coc->compparms)) {\n\t\treturn -1;\n\t}\n\tif (jas_stream_eof(in)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_coc_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out)\n{\n\tjpc_coc_t *coc = &ms->parms.coc;\n\tassert(coc->compparms.numdlvls <= 32);\n\tif (cstate->numcomps <= 256) {\n\t\tif (jpc_putuint8(out, coc->compno)) {\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\tif (jpc_putuint16(out, coc->compno)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (jpc_putuint8(out, coc->compparms.csty)) {\n\t\treturn -1;\n\t}\n\tif (jpc_cox_putcompparms(ms, cstate, out,\n\t  (coc->compparms.csty & JPC_COX_PRT) != 0, &coc->compparms)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_coc_dumpparms(jpc_ms_t *ms, FILE *out)\n{\n\tjpc_coc_t *coc = &ms->parms.coc;\n\tfprintf(out, \"compno = %\"PRIuFAST16\"; csty = 0x%02x; numdlvls = %d;\\n\",\n\t  coc->compno, coc->compparms.csty, coc->compparms.numdlvls);\n\tfprintf(out, \"cblkwidthval = %d; cblkheightval = %d; \"\n\t  \"cblksty = 0x%02x; qmfbid = %d;\\n\", coc->compparms.cblkwidthval,\n\t  coc->compparms.cblkheightval, coc->compparms.cblksty, coc->compparms.qmfbid);\n\treturn 0;\n}\n/******************************************************************************\\\n* COD/COC marker segment operation helper functions.\n\\******************************************************************************/\n\nstatic void jpc_cox_destroycompparms(jpc_coxcp_t *compparms)\n{\n\t/* Eliminate compiler warning about unused variables. */\n\tcompparms = 0;\n}\n\nstatic int jpc_cox_getcompparms(jpc_ms_t *ms, jpc_cstate_t *cstate,\n  jas_stream_t *in, int prtflag, jpc_coxcp_t *compparms)\n{\n\tuint_fast8_t tmp;\n\tint i;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tms = 0;\n\tcstate = 0;\n\n\tif (jpc_getuint8(in, &compparms->numdlvls) ||\n\t  jpc_getuint8(in, &compparms->cblkwidthval) ||\n\t  jpc_getuint8(in, &compparms->cblkheightval) ||\n\t  jpc_getuint8(in, &compparms->cblksty) ||\n\t  jpc_getuint8(in, &compparms->qmfbid)) {\n\t\treturn -1;\n\t}\n\tif (compparms->numdlvls > 32) {\n\t\tgoto error;\n\t}\n\tcompparms->numrlvls = compparms->numdlvls + 1;\n\tif (compparms->numrlvls > JPC_MAXRLVLS) {\n\t\tgoto error;\n\t}\n\tif (prtflag) {\n\t\tfor (i = 0; i < compparms->numrlvls; ++i) {\n\t\t\tif (jpc_getuint8(in, &tmp)) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tcompparms->rlvls[i].parwidthval = tmp & 0xf;\n\t\t\tcompparms->rlvls[i].parheightval = (tmp >> 4) & 0xf;\n\t\t}\n\t\t/* Sigh.\n\t\tThis bit should be in the same field in both COC and COD mrk segs. */\n\t\tcompparms->csty |= JPC_COX_PRT;\n\t}\n\tif (jas_stream_eof(in)) {\n\t\tgoto error;\n\t}\n\treturn 0;\nerror:\n\tif (compparms) {\n\t\tjpc_cox_destroycompparms(compparms);\n\t}\n\treturn -1;\n}\n\nstatic int jpc_cox_putcompparms(jpc_ms_t *ms, jpc_cstate_t *cstate,\n  jas_stream_t *out, int prtflag, jpc_coxcp_t *compparms)\n{\n\tint i;\n\tassert(compparms->numdlvls <= 32);\n\n\t/* Eliminate compiler warning about unused variables. */\n\tms = 0;\n\tcstate = 0;\n\n\tif (jpc_putuint8(out, compparms->numdlvls) ||\n\t  jpc_putuint8(out, compparms->cblkwidthval) ||\n\t  jpc_putuint8(out, compparms->cblkheightval) ||\n\t  jpc_putuint8(out, compparms->cblksty) ||\n\t  jpc_putuint8(out, compparms->qmfbid)) {\n\t\treturn -1;\n\t}\n\tif (prtflag) {\n\t\tfor (i = 0; i < compparms->numrlvls; ++i) {\n\t\t\tif (jpc_putuint8(out,\n\t\t\t  ((compparms->rlvls[i].parheightval & 0xf) << 4) |\n\t\t\t  (compparms->rlvls[i].parwidthval & 0xf))) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\\\n* RGN marker segment operations.\n\\******************************************************************************/\n\nstatic int jpc_rgn_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in)\n{\n\tjpc_rgn_t *rgn = &ms->parms.rgn;\n\tuint_fast8_t tmp;\n\tif (cstate->numcomps <= 256) {\n\t\tif (jpc_getuint8(in, &tmp)) {\n\t\t\treturn -1;\n\t\t}\n\t\trgn->compno = tmp;\n\t} else {\n\t\tif (jpc_getuint16(in, &rgn->compno)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (jpc_getuint8(in, &rgn->roisty) ||\n\t  jpc_getuint8(in, &rgn->roishift)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_rgn_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out)\n{\n\tjpc_rgn_t *rgn = &ms->parms.rgn;\n\tif (cstate->numcomps <= 256) {\n\t\tif (jpc_putuint8(out, rgn->compno)) {\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\tif (jpc_putuint16(out, rgn->compno)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (jpc_putuint8(out, rgn->roisty) ||\n\t  jpc_putuint8(out, rgn->roishift)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_rgn_dumpparms(jpc_ms_t *ms, FILE *out)\n{\n\tjpc_rgn_t *rgn = &ms->parms.rgn;\n\tfprintf(out, \"compno = %\"PRIuFAST16\"; roisty = %d; roishift = %d\\n\",\n\t  rgn->compno, rgn->roisty, rgn->roishift);\n\treturn 0;\n}\n\n/******************************************************************************\\\n* QCD marker segment operations.\n\\******************************************************************************/\n\nstatic void jpc_qcd_destroyparms(jpc_ms_t *ms)\n{\n\tjpc_qcd_t *qcd = &ms->parms.qcd;\n\tjpc_qcx_destroycompparms(&qcd->compparms);\n}\n\nstatic int jpc_qcd_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in)\n{\n\tjpc_qcxcp_t *compparms = &ms->parms.qcd.compparms;\n\treturn jpc_qcx_getcompparms(compparms, cstate, in, ms->len);\n}\n\nstatic int jpc_qcd_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out)\n{\n\tjpc_qcxcp_t *compparms = &ms->parms.qcd.compparms;\n\treturn jpc_qcx_putcompparms(compparms, cstate, out);\n}\n\nstatic int jpc_qcd_dumpparms(jpc_ms_t *ms, FILE *out)\n{\n\tjpc_qcd_t *qcd = &ms->parms.qcd;\n\tint i;\n\tfprintf(out, \"qntsty = %d; numguard = %d; numstepsizes = %d\\n\",\n\t  (int) qcd->compparms.qntsty, qcd->compparms.numguard, qcd->compparms.numstepsizes);\n\tfor (i = 0; i < qcd->compparms.numstepsizes; ++i) {\n\t\tfprintf(out, \"expn[%d] = 0x%04x; mant[%d] = 0x%04x;\\n\",\n\t\t  i, (unsigned) JPC_QCX_GETEXPN(qcd->compparms.stepsizes[i]),\n\t\t  i, (unsigned) JPC_QCX_GETMANT(qcd->compparms.stepsizes[i]));\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\\\n* QCC marker segment operations.\n\\******************************************************************************/\n\nstatic void jpc_qcc_destroyparms(jpc_ms_t *ms)\n{\n\tjpc_qcc_t *qcc = &ms->parms.qcc;\n\tjpc_qcx_destroycompparms(&qcc->compparms);\n}\n\nstatic int jpc_qcc_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in)\n{\n\tjpc_qcc_t *qcc = &ms->parms.qcc;\n\tuint_fast8_t tmp;\n\tint len;\n\tlen = ms->len;\n\tif (cstate->numcomps <= 256) {\n\t\tif (jpc_getuint8(in, &tmp)) {\n\t\t\treturn -1;\n\t\t}\n\t\tqcc->compno = tmp;\n\t\t--len;\n\t} else {\n\t\tif (jpc_getuint16(in, &qcc->compno)) {\n\t\t\treturn -1;\n\t\t}\n\t\tlen -= 2;\n\t}\n\tif (jpc_qcx_getcompparms(&qcc->compparms, cstate, in, len)) {\n\t\treturn -1;\n\t}\n\tif (jas_stream_eof(in)) {\n\t\tjpc_qcc_destroyparms(ms);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_qcc_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out)\n{\n\tjpc_qcc_t *qcc = &ms->parms.qcc;\n\tif (cstate->numcomps <= 256) {\n\t\tif (jpc_putuint8(out, qcc->compno)) {\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\tif (jpc_putuint16(out, qcc->compno)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (jpc_qcx_putcompparms(&qcc->compparms, cstate, out)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_qcc_dumpparms(jpc_ms_t *ms, FILE *out)\n{\n\tjpc_qcc_t *qcc = &ms->parms.qcc;\n\tint i;\n\tfprintf(out, \"compno = %\"PRIuFAST16\"; qntsty = %d; numguard = %d; \"\n\t  \"numstepsizes = %d\\n\", qcc->compno, qcc->compparms.qntsty, qcc->compparms.numguard,\n\t  qcc->compparms.numstepsizes);\n\tfor (i = 0; i < qcc->compparms.numstepsizes; ++i) {\n\t\tfprintf(out, \"expn[%d] = 0x%04x; mant[%d] = 0x%04x;\\n\",\n\t\t  i, (unsigned) JPC_QCX_GETEXPN(qcc->compparms.stepsizes[i]),\n\t\t  i, (unsigned) JPC_QCX_GETMANT(qcc->compparms.stepsizes[i]));\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\\\n* QCD/QCC marker segment helper functions.\n\\******************************************************************************/\n\nstatic void jpc_qcx_destroycompparms(jpc_qcxcp_t *compparms)\n{\n\tif (compparms->stepsizes) {\n\t\tjas_free(compparms->stepsizes);\n\t}\n}\n\nstatic int jpc_qcx_getcompparms(jpc_qcxcp_t *compparms, jpc_cstate_t *cstate,\n  jas_stream_t *in, uint_fast16_t len)\n{\n\tuint_fast8_t tmp;\n\tint n;\n\tint i;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tcstate = 0;\n\n\tn = 0;\n\tif (jpc_getuint8(in, &tmp)) {\n\t\treturn -1;\n\t}\n\t++n;\n\tcompparms->qntsty = tmp & 0x1f;\n\tcompparms->numguard = (tmp >> 5) & 7;\n\tswitch (compparms->qntsty) {\n\tcase JPC_QCX_SIQNT:\n\t\tcompparms->numstepsizes = 1;\n\t\tbreak;\n\tcase JPC_QCX_NOQNT:\n\t\tcompparms->numstepsizes = (len - n);\n\t\tbreak;\n\tcase JPC_QCX_SEQNT:\n\t\t/* XXX - this is a hack */\n\t\tcompparms->numstepsizes = (len - n) / 2;\n\t\tbreak;\n\t}\n\t/* Ensure that the step size array is sufficiently large. */\n\tif (compparms->numstepsizes > 3 * JPC_MAXRLVLS + 1) {\n\t\tjpc_qcx_destroycompparms(compparms);\n\t\treturn -1;\n\t}\n\tif (compparms->numstepsizes > 0) {\n\t\tif (!(compparms->stepsizes = jas_alloc2(compparms->numstepsizes,\n\t\t  sizeof(uint_fast16_t)))) {\n\t\t\tabort();\n\t\t}\n\t\tfor (i = 0; i < compparms->numstepsizes; ++i) {\n\t\t\tif (compparms->qntsty == JPC_QCX_NOQNT) {\n\t\t\t\tif (jpc_getuint8(in, &tmp)) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tcompparms->stepsizes[i] = JPC_QCX_EXPN(tmp >> 3);\n\t\t\t} else {\n\t\t\t\tif (jpc_getuint16(in, &compparms->stepsizes[i])) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tcompparms->stepsizes = 0;\n\t}\n\tif (jas_stream_error(in) || jas_stream_eof(in)) {\n\t\tjpc_qcx_destroycompparms(compparms);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_qcx_putcompparms(jpc_qcxcp_t *compparms, jpc_cstate_t *cstate,\n  jas_stream_t *out)\n{\n\tint i;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tcstate = 0;\n\n\tjpc_putuint8(out, ((compparms->numguard & 7) << 5) | compparms->qntsty);\n\tfor (i = 0; i < compparms->numstepsizes; ++i) {\n\t\tif (compparms->qntsty == JPC_QCX_NOQNT) {\n\t\t\tif (jpc_putuint8(out, JPC_QCX_GETEXPN(\n\t\t\t  compparms->stepsizes[i]) << 3)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\tif (jpc_putuint16(out, compparms->stepsizes[i])) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\\\n* SOP marker segment operations.\n\\******************************************************************************/\n\nstatic int jpc_sop_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in)\n{\n\tjpc_sop_t *sop = &ms->parms.sop;\n\n\t/* Eliminate compiler warning about unused variable. */\n\tcstate = 0;\n\n\tif (jpc_getuint16(in, &sop->seqno)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_sop_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out)\n{\n\tjpc_sop_t *sop = &ms->parms.sop;\n\n\t/* Eliminate compiler warning about unused variable. */\n\tcstate = 0;\n\n\tif (jpc_putuint16(out, sop->seqno)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_sop_dumpparms(jpc_ms_t *ms, FILE *out)\n{\n\tjpc_sop_t *sop = &ms->parms.sop;\n\tfprintf(out, \"seqno = %\"PRIuFAST16\";\\n\", sop->seqno);\n\treturn 0;\n}\n\n/******************************************************************************\\\n* PPM marker segment operations.\n\\******************************************************************************/\n\nstatic void jpc_ppm_destroyparms(jpc_ms_t *ms)\n{\n\tjpc_ppm_t *ppm = &ms->parms.ppm;\n\tif (ppm->data) {\n\t\tjas_free(ppm->data);\n\t}\n}\n\nstatic int jpc_ppm_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in)\n{\n\tjpc_ppm_t *ppm = &ms->parms.ppm;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tcstate = 0;\n\n\tppm->data = 0;\n\n\tif (ms->len < 1) {\n\t\tgoto error;\n\t}\n\tif (jpc_getuint8(in, &ppm->ind)) {\n\t\tgoto error;\n\t}\n\n\tppm->len = ms->len - 1;\n\tif (ppm->len > 0) {\n\t\tif (!(ppm->data = jas_malloc(ppm->len))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (JAS_CAST(uint, jas_stream_read(in, ppm->data, ppm->len)) != ppm->len) {\n\t\t\tgoto error;\n\t\t}\n\t} else {\n\t\tppm->data = 0;\n\t}\n\treturn 0;\n\nerror:\n\tjpc_ppm_destroyparms(ms);\n\treturn -1;\n}\n\nstatic int jpc_ppm_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out)\n{\n\tjpc_ppm_t *ppm = &ms->parms.ppm;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tcstate = 0;\n\n\tif (JAS_CAST(uint, jas_stream_write(out, (char *) ppm->data, ppm->len)) != ppm->len) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_ppm_dumpparms(jpc_ms_t *ms, FILE *out)\n{\n\tjpc_ppm_t *ppm = &ms->parms.ppm;\n\tfprintf(out, \"ind=%d; len = %\"PRIuFAST16\";\\n\", ppm->ind, ppm->len);\n\tif (ppm->len > 0) {\n\t\tfprintf(out, \"data =\\n\");\n\t\tjas_memdump(out, ppm->data, ppm->len);\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\\\n* PPT marker segment operations.\n\\******************************************************************************/\n\nstatic void jpc_ppt_destroyparms(jpc_ms_t *ms)\n{\n\tjpc_ppt_t *ppt = &ms->parms.ppt;\n\tif (ppt->data) {\n\t\tjas_free(ppt->data);\n\t}\n}\n\nstatic int jpc_ppt_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in)\n{\n\tjpc_ppt_t *ppt = &ms->parms.ppt;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tcstate = 0;\n\n\tppt->data = 0;\n\n\tif (ms->len < 1) {\n\t\tgoto error;\n\t}\n\tif (jpc_getuint8(in, &ppt->ind)) {\n\t\tgoto error;\n\t}\n\tppt->len = ms->len - 1;\n\tif (ppt->len > 0) {\n\t\tif (!(ppt->data = jas_malloc(ppt->len))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (jas_stream_read(in, (char *) ppt->data, ppt->len) != JAS_CAST(int, ppt->len)) {\n\t\t\tgoto error;\n\t\t}\n\t} else {\n\t\tppt->data = 0;\n\t}\n\treturn 0;\n\nerror:\n\tjpc_ppt_destroyparms(ms);\n\treturn -1;\n}\n\nstatic int jpc_ppt_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out)\n{\n\tjpc_ppt_t *ppt = &ms->parms.ppt;\n\n\t/* Eliminate compiler warning about unused variable. */\n\tcstate = 0;\n\n\tif (jpc_putuint8(out, ppt->ind)) {\n\t\treturn -1;\n\t}\n\tif (jas_stream_write(out, (char *) ppt->data, ppt->len) != JAS_CAST(int, ppt->len)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_ppt_dumpparms(jpc_ms_t *ms, FILE *out)\n{\n\tjpc_ppt_t *ppt = &ms->parms.ppt;\n\tfprintf(out, \"ind=%d; len = %\"PRIuFAST32\";\\n\", ppt->ind, ppt->len);\n\tif (ppt->len > 0) {\n\t\tfprintf(out, \"data =\\n\");\n\t\tjas_memdump(out, ppt->data, ppt->len);\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\\\n* POC marker segment operations.\n\\******************************************************************************/\n\nstatic void jpc_poc_destroyparms(jpc_ms_t *ms)\n{\n\tjpc_poc_t *poc = &ms->parms.poc;\n\tif (poc->pchgs) {\n\t\tjas_free(poc->pchgs);\n\t}\n}\n\nstatic int jpc_poc_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in)\n{\n\tjpc_poc_t *poc = &ms->parms.poc;\n\tjpc_pocpchg_t *pchg;\n\tint pchgno;\n\tuint_fast8_t tmp;\n\tpoc->numpchgs = (cstate->numcomps > 256) ? (ms->len / 9) :\n\t  (ms->len / 7);\n\tif (!(poc->pchgs = jas_alloc2(poc->numpchgs, sizeof(jpc_pocpchg_t)))) {\n\t\tgoto error;\n\t}\n\tfor (pchgno = 0, pchg = poc->pchgs; pchgno < poc->numpchgs; ++pchgno,\n\t  ++pchg) {\n\t\tif (jpc_getuint8(in, &pchg->rlvlnostart)) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (cstate->numcomps > 256) {\n\t\t\tif (jpc_getuint16(in, &pchg->compnostart)) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t} else {\n\t\t\tif (jpc_getuint8(in, &tmp)) {\n\t\t\t\tgoto error;\n\t\t\t};\n\t\t\tpchg->compnostart = tmp;\n\t\t}\n\t\tif (jpc_getuint16(in, &pchg->lyrnoend) ||\n\t\t  jpc_getuint8(in, &pchg->rlvlnoend)) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (cstate->numcomps > 256) {\n\t\t\tif (jpc_getuint16(in, &pchg->compnoend)) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t} else {\n\t\t\tif (jpc_getuint8(in, &tmp)) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tpchg->compnoend = tmp;\n\t\t}\n\t\tif (jpc_getuint8(in, &pchg->prgord)) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (pchg->rlvlnostart > pchg->rlvlnoend ||\n\t\t  pchg->compnostart > pchg->compnoend) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\treturn 0;\n\nerror:\n\tjpc_poc_destroyparms(ms);\n\treturn -1;\n}\n\nstatic int jpc_poc_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out)\n{\n\tjpc_poc_t *poc = &ms->parms.poc;\n\tjpc_pocpchg_t *pchg;\n\tint pchgno;\n\tfor (pchgno = 0, pchg = poc->pchgs; pchgno < poc->numpchgs; ++pchgno,\n\t  ++pchg) {\n\t\tif (jpc_putuint8(out, pchg->rlvlnostart) ||\n\t\t  ((cstate->numcomps > 256) ?\n\t\t  jpc_putuint16(out, pchg->compnostart) :\n\t\t  jpc_putuint8(out, pchg->compnostart)) ||\n\t\t  jpc_putuint16(out, pchg->lyrnoend) ||\n\t\t  jpc_putuint8(out, pchg->rlvlnoend) ||\n\t\t  ((cstate->numcomps > 256) ?\n\t\t  jpc_putuint16(out, pchg->compnoend) :\n\t\t  jpc_putuint8(out, pchg->compnoend)) ||\n\t\t  jpc_putuint8(out, pchg->prgord)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int jpc_poc_dumpparms(jpc_ms_t *ms, FILE *out)\n{\n\tjpc_poc_t *poc = &ms->parms.poc;\n\tjpc_pocpchg_t *pchg;\n\tint pchgno;\n\tfor (pchgno = 0, pchg = poc->pchgs; pchgno < poc->numpchgs;\n\t  ++pchgno, ++pchg) {\n\t\tfprintf(out, \"po[%d] = %d; \", pchgno, pchg->prgord);\n\t\tfprintf(out, \"cs[%d] = %\"PRIuFAST16\"; ce[%d] = %\"PRIuFAST16\"; \",\n\t\t  pchgno, pchg->compnostart, pchgno, pchg->compnoend);\n\t\tfprintf(out, \"rs[%d] = %d; re[%d] = %d; \",\n\t\t  pchgno, pchg->rlvlnostart, pchgno, pchg->rlvlnoend);\n\t\tfprintf(out, \"le[%d] = %\"PRIuFAST16\"\\n\", pchgno, pchg->lyrnoend);\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\\\n* CRG marker segment operations.\n\\******************************************************************************/\n\nstatic void jpc_crg_destroyparms(jpc_ms_t *ms)\n{\n\tjpc_crg_t *crg = &ms->parms.crg;\n\tif (crg->comps) {\n\t\tjas_free(crg->comps);\n\t}\n}\n\nstatic int jpc_crg_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in)\n{\n\tjpc_crg_t *crg = &ms->parms.crg;\n\tjpc_crgcomp_t *comp;\n\tuint_fast16_t compno;\n\tcrg->numcomps = cstate->numcomps;\n\tif (!(crg->comps = jas_alloc2(cstate->numcomps, sizeof(jpc_crgcomp_t)))) {\n\t\treturn -1;\n\t}\n\tfor (compno = 0, comp = crg->comps; compno < cstate->numcomps;\n\t  ++compno, ++comp) {\n\t\tif (jpc_getuint16(in, &comp->hoff) ||\n\t\t  jpc_getuint16(in, &comp->voff)) {\n\t\t\tjpc_crg_destroyparms(ms);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int jpc_crg_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out)\n{\n\tjpc_crg_t *crg = &ms->parms.crg;\n\tint compno;\n\tjpc_crgcomp_t *comp;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tcstate = 0;\n\n\tfor (compno = 0, comp = crg->comps; compno < crg->numcomps; ++compno,\n\t  ++comp) {\n\t\tif (jpc_putuint16(out, comp->hoff) ||\n\t\t  jpc_putuint16(out, comp->voff)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int jpc_crg_dumpparms(jpc_ms_t *ms, FILE *out)\n{\n\tjpc_crg_t *crg = &ms->parms.crg;\n\tint compno;\n\tjpc_crgcomp_t *comp;\n\tfor (compno = 0, comp = crg->comps; compno < crg->numcomps; ++compno,\n\t  ++comp) {\n\t\tfprintf(out, \"hoff[%d] = %\"PRIuFAST16\"; voff[%d] = %\"PRIuFAST16\"\\n\",\n\t\t  compno, comp->hoff, compno, comp->voff);\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\\\n* Operations for COM marker segment.\n\\******************************************************************************/\n\nstatic void jpc_com_destroyparms(jpc_ms_t *ms)\n{\n\tjpc_com_t *com = &ms->parms.com;\n\tif (com->data) {\n\t\tjas_free(com->data);\n\t}\n}\n\nstatic int jpc_com_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in)\n{\n\tjpc_com_t *com = &ms->parms.com;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tcstate = 0;\n\n\tif (jpc_getuint16(in, &com->regid)) {\n\t\treturn -1;\n\t}\n\tcom->len = ms->len - 2;\n\tif (com->len > 0) {\n\t\tif (!(com->data = jas_malloc(com->len))) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (jas_stream_read(in, com->data, com->len) != JAS_CAST(int, com->len)) {\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\tcom->data = 0;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_com_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out)\n{\n\tjpc_com_t *com = &ms->parms.com;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tcstate = 0;\n\n\tif (jpc_putuint16(out, com->regid)) {\n\t\treturn -1;\n\t}\n\tif (jas_stream_write(out, com->data, com->len) != JAS_CAST(int, com->len)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_com_dumpparms(jpc_ms_t *ms, FILE *out)\n{\n\tjpc_com_t *com = &ms->parms.com;\n\tunsigned int i;\n\tint printable;\n\tfprintf(out, \"regid = %\"PRIuFAST16\";\\n\", com->regid);\n\tprintable = 1;\n\tfor (i = 0; i < com->len; ++i) {\n\t\tif (!isprint(com->data[i])) {\n\t\t\tprintable = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (printable) {\n\t\tfprintf(out, \"data = \");\n\t\tfwrite(com->data, sizeof(char), com->len, out);\n\t\tfprintf(out, \"\\n\");\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\\\n* Operations for unknown types of marker segments.\n\\******************************************************************************/\n\nstatic void jpc_unk_destroyparms(jpc_ms_t *ms)\n{\n\tjpc_unk_t *unk = &ms->parms.unk;\n\tif (unk->data) {\n\t\tjas_free(unk->data);\n\t}\n}\n\nstatic int jpc_unk_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in)\n{\n\tjpc_unk_t *unk = &ms->parms.unk;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tcstate = 0;\n\n\tif (ms->len > 0) {\n\t\tif (!(unk->data = jas_alloc2(ms->len, sizeof(unsigned char)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (jas_stream_read(in, (char *) unk->data, ms->len) != JAS_CAST(int, ms->len)) {\n\t\t\tjas_free(unk->data);\n\t\t\treturn -1;\n\t\t}\n\t\tunk->len = ms->len;\n\t} else {\n\t\tunk->data = 0;\n\t\tunk->len = 0;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_unk_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out)\n{\n\t/* Eliminate compiler warning about unused variables. */\n\tcstate = 0;\n\tms = 0;\n\tout = 0;\n\n\t/* If this function is called, we are trying to write an unsupported\n\t  type of marker segment.  Return with an error indication.  */\n\treturn -1;\n}\n\nstatic int jpc_unk_dumpparms(jpc_ms_t *ms, FILE *out)\n{\n\tunsigned int i;\n\tjpc_unk_t *unk = &ms->parms.unk;\n\tfor (i = 0; i < unk->len; ++i) {\n\t\tfprintf(out, \"%02x \", unk->data[i]);\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\\\n* Primitive I/O operations.\n\\******************************************************************************/\n\nint jpc_getuint8(jas_stream_t *in, uint_fast8_t *val)\n{\n\tint c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tif (val) {\n\t\t*val = c;\n\t}\n\treturn 0;\n}\n\nint jpc_putuint8(jas_stream_t *out, uint_fast8_t val)\n{\n\tif (jas_stream_putc(out, val & 0xff) == EOF) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nint jpc_getuint16(jas_stream_t *in, uint_fast16_t *val)\n{\n\tuint_fast16_t v;\n\tint c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tv = c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tv = (v << 8) | c;\n\tif (val) {\n\t\t*val = v;\n\t}\n\treturn 0;\n}\n\nint jpc_putuint16(jas_stream_t *out, uint_fast16_t val)\n{\n\tif (jas_stream_putc(out, (val >> 8) & 0xff) == EOF ||\n\t  jas_stream_putc(out, val & 0xff) == EOF) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nint jpc_getuint32(jas_stream_t *in, uint_fast32_t *val)\n{\n\tuint_fast32_t v;\n\tint c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tv = c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tv = (v << 8) | c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tv = (v << 8) | c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tv = (v << 8) | c;\n\tif (val) {\n\t\t*val = v;\n\t}\n\treturn 0;\n}\n\nint jpc_putuint32(jas_stream_t *out, uint_fast32_t val)\n{\n\tif (jas_stream_putc(out, (val >> 24) & 0xff) == EOF ||\n\t  jas_stream_putc(out, (val >> 16) & 0xff) == EOF ||\n\t  jas_stream_putc(out, (val >> 8) & 0xff) == EOF ||\n\t  jas_stream_putc(out, val & 0xff) == EOF) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\\\n* Miscellany\n\\******************************************************************************/\n\nstatic jpc_mstabent_t *jpc_mstab_lookup(int id)\n{\n\tjpc_mstabent_t *mstabent;\n\tfor (mstabent = jpc_mstab;; ++mstabent) {\n\t\tif (mstabent->id == id || mstabent->id < 0) {\n\t\t\treturn mstabent;\n\t\t}\n\t}\n\tassert(0);\n\treturn 0;\n}\n\nint jpc_validate(jas_stream_t *in)\n{\n\tint n;\n\tint i;\n\tunsigned char buf[2];\n\n\tassert(JAS_STREAM_MAXPUTBACK >= 2);\n\n\tif ((n = jas_stream_read(in, (char *) buf, 2)) < 0) {\n\t\treturn -1;\n\t}\n\tfor (i = n - 1; i >= 0; --i) {\n\t\tif (jas_stream_ungetc(in, buf[i]) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (n < 2) {\n\t\treturn -1;\n\t}\n\tif (buf[0] == (JPC_MS_SOC >> 8) && buf[1] == (JPC_MS_SOC & 0xff)) {\n\t\treturn 0;\n\t}\n\treturn -1;\n}\n\nint jpc_getdata(jas_stream_t *in, jas_stream_t *out, long len)\n{\n\treturn jas_stream_copy(out, in, len);\n}\n\nint jpc_putdata(jas_stream_t *out, jas_stream_t *in, long len)\n{\n\treturn jas_stream_copy(out, in, len);\n}\n", "/*\n * Copyright (c) 1999-2000 Image Power, Inc. and the University of\n *   British Columbia.\n * Copyright (c) 2001-2003 Michael David Adams.\n * All rights reserved.\n */\n\n/* __START_OF_JASPER_LICENSE__\n * \n * JasPer License Version 2.0\n * \n * Copyright (c) 2001-2006 Michael David Adams\n * Copyright (c) 1999-2000 Image Power, Inc.\n * Copyright (c) 1999-2000 The University of British Columbia\n * \n * All rights reserved.\n * \n * Permission is hereby granted, free of charge, to any person (the\n * \"User\") obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n * \n * 1.  The above copyright notices and this permission notice (which\n * includes the disclaimer below) shall be included in all copies or\n * substantial portions of the Software.\n * \n * 2.  The name of a copyright holder shall not be used to endorse or\n * promote products derived from the Software without specific prior\n * written permission.\n * \n * THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS\n * LICENSE.  NO USE OF THE SOFTWARE IS AUTHORIZED HEREUNDER EXCEPT UNDER\n * THIS DISCLAIMER.  THE SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS\n * \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.  IN NO\n * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL\n * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING\n * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\n * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION\n * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  NO ASSURANCES ARE\n * PROVIDED BY THE COPYRIGHT HOLDERS THAT THE SOFTWARE DOES NOT INFRINGE\n * THE PATENT OR OTHER INTELLECTUAL PROPERTY RIGHTS OF ANY OTHER ENTITY.\n * EACH COPYRIGHT HOLDER DISCLAIMS ANY LIABILITY TO THE USER FOR CLAIMS\n * BROUGHT BY ANY OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL\n * PROPERTY RIGHTS OR OTHERWISE.  AS A CONDITION TO EXERCISING THE RIGHTS\n * GRANTED HEREUNDER, EACH USER HEREBY ASSUMES SOLE RESPONSIBILITY TO SECURE\n * ANY OTHER INTELLECTUAL PROPERTY RIGHTS NEEDED, IF ANY.  THE SOFTWARE\n * IS NOT FAULT-TOLERANT AND IS NOT INTENDED FOR USE IN MISSION-CRITICAL\n * SYSTEMS, SUCH AS THOSE USED IN THE OPERATION OF NUCLEAR FACILITIES,\n * AIRCRAFT NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL\n * SYSTEMS, DIRECT LIFE SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH\n * THE FAILURE OF THE SOFTWARE OR SYSTEM COULD LEAD DIRECTLY TO DEATH,\n * PERSONAL INJURY, OR SEVERE PHYSICAL OR ENVIRONMENTAL DAMAGE (\"HIGH\n * RISK ACTIVITIES\").  THE COPYRIGHT HOLDERS SPECIFICALLY DISCLAIM ANY\n * EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR HIGH RISK ACTIVITIES.\n * \n * __END_OF_JASPER_LICENSE__\n */\n\n/*\n * $Id$\n */\n\n/******************************************************************************\\\n* Includes.\n\\******************************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <inttypes.h>\n\n#include \"jasper/jas_types.h\"\n#include \"jasper/jas_math.h\"\n#include \"jasper/jas_tvp.h\"\n#include \"jasper/jas_malloc.h\"\n#include \"jasper/jas_debug.h\"\n\n#include \"jpc_fix.h\"\n#include \"jpc_dec.h\"\n#include \"jpc_cs.h\"\n#include \"jpc_mct.h\"\n#include \"jpc_t2dec.h\"\n#include \"jpc_t1dec.h\"\n#include \"jpc_math.h\"\n\n/******************************************************************************\\\n*\n\\******************************************************************************/\n\n#define\tJPC_MHSOC\t0x0001\n  /* In the main header, expecting a SOC marker segment. */\n#define\tJPC_MHSIZ\t0x0002\n  /* In the main header, expecting a SIZ marker segment. */\n#define\tJPC_MH\t\t0x0004\n  /* In the main header, expecting \"other\" marker segments. */\n#define\tJPC_TPHSOT\t0x0008\n  /* In a tile-part header, expecting a SOT marker segment. */\n#define\tJPC_TPH\t\t0x0010\n  /* In a tile-part header, expecting \"other\" marker segments. */\n#define\tJPC_MT\t\t0x0020\n  /* In the main trailer. */\n\ntypedef struct {\n\n\tuint_fast16_t id;\n\t/* The marker segment type. */\n\n\tint validstates;\n\t/* The states in which this type of marker segment can be\n\t  validly encountered. */\n\n\tint (*action)(jpc_dec_t *dec, jpc_ms_t *ms);\n\t/* The action to take upon encountering this type of marker segment. */\n\n} jpc_dec_mstabent_t;\n\n/******************************************************************************\\\n*\n\\******************************************************************************/\n\n/* COD/COC parameters have been specified. */\n#define\tJPC_CSET\t0x0001\n/* QCD/QCC parameters have been specified. */\n#define\tJPC_QSET\t0x0002\n/* COD/COC parameters set from a COC marker segment. */\n#define\tJPC_COC\t0x0004\n/* QCD/QCC parameters set from a QCC marker segment. */\n#define\tJPC_QCC\t0x0008\n\n/******************************************************************************\\\n* Local function prototypes.\n\\******************************************************************************/\n\nstatic int jpc_dec_dump(jpc_dec_t *dec, FILE *out);\n\njpc_ppxstab_t *jpc_ppxstab_create(void);\nvoid jpc_ppxstab_destroy(jpc_ppxstab_t *tab);\nint jpc_ppxstab_grow(jpc_ppxstab_t *tab, int maxents);\nint jpc_ppxstab_insert(jpc_ppxstab_t *tab, jpc_ppxstabent_t *ent);\njpc_streamlist_t *jpc_ppmstabtostreams(jpc_ppxstab_t *tab);\nint jpc_pptstabwrite(jas_stream_t *out, jpc_ppxstab_t *tab);\njpc_ppxstabent_t *jpc_ppxstabent_create(void);\nvoid jpc_ppxstabent_destroy(jpc_ppxstabent_t *ent);\n\nint jpc_streamlist_numstreams(jpc_streamlist_t *streamlist);\njpc_streamlist_t *jpc_streamlist_create(void);\nint jpc_streamlist_insert(jpc_streamlist_t *streamlist, int streamno,\n  jas_stream_t *stream);\njas_stream_t *jpc_streamlist_remove(jpc_streamlist_t *streamlist, int streamno);\nvoid jpc_streamlist_destroy(jpc_streamlist_t *streamlist);\njas_stream_t *jpc_streamlist_get(jpc_streamlist_t *streamlist, int streamno);\n\nstatic void jpc_dec_cp_resetflags(jpc_dec_cp_t *cp);\nstatic jpc_dec_cp_t *jpc_dec_cp_create(uint_fast16_t numcomps);\nstatic int jpc_dec_cp_isvalid(jpc_dec_cp_t *cp);\nstatic jpc_dec_cp_t *jpc_dec_cp_copy(jpc_dec_cp_t *cp);\nstatic int jpc_dec_cp_setfromcod(jpc_dec_cp_t *cp, jpc_cod_t *cod);\nstatic int jpc_dec_cp_setfromcoc(jpc_dec_cp_t *cp, jpc_coc_t *coc);\nstatic int jpc_dec_cp_setfromcox(jpc_dec_cp_t *cp, jpc_dec_ccp_t *ccp,\n  jpc_coxcp_t *compparms, int flags);\nstatic int jpc_dec_cp_setfromqcd(jpc_dec_cp_t *cp, jpc_qcd_t *qcd);\nstatic int jpc_dec_cp_setfromqcc(jpc_dec_cp_t *cp, jpc_qcc_t *qcc);\nstatic int jpc_dec_cp_setfromqcx(jpc_dec_cp_t *cp, jpc_dec_ccp_t *ccp,\n  jpc_qcxcp_t *compparms, int flags);\nstatic int jpc_dec_cp_setfromrgn(jpc_dec_cp_t *cp, jpc_rgn_t *rgn);\nstatic int jpc_dec_cp_prepare(jpc_dec_cp_t *cp);\nstatic void jpc_dec_cp_destroy(jpc_dec_cp_t *cp);\nstatic int jpc_dec_cp_setfrompoc(jpc_dec_cp_t *cp, jpc_poc_t *poc, int reset);\nstatic int jpc_pi_addpchgfrompoc(jpc_pi_t *pi, jpc_poc_t *poc);\n\nstatic int jpc_dec_decode(jpc_dec_t *dec);\nstatic jpc_dec_t *jpc_dec_create(jpc_dec_importopts_t *impopts, jas_stream_t *in);\nstatic void jpc_dec_destroy(jpc_dec_t *dec);\nstatic void jpc_dequantize(jas_matrix_t *x, jpc_fix_t absstepsize);\nstatic void jpc_undo_roi(jas_matrix_t *x, int roishift, int bgshift, int numbps);\nstatic jpc_fix_t jpc_calcabsstepsize(int stepsize, int numbits);\nstatic int jpc_dec_tiledecode(jpc_dec_t *dec, jpc_dec_tile_t *tile);\nstatic int jpc_dec_tileinit(jpc_dec_t *dec, jpc_dec_tile_t *tile);\nstatic int jpc_dec_tilefini(jpc_dec_t *dec, jpc_dec_tile_t *tile);\nstatic int jpc_dec_process_soc(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_sot(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_sod(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_eoc(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_siz(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_cod(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_coc(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_rgn(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_qcd(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_qcc(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_poc(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_ppm(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_ppt(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_com(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_unk(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_crg(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_parseopts(char *optstr, jpc_dec_importopts_t *opts);\n\nstatic jpc_dec_mstabent_t *jpc_dec_mstab_lookup(uint_fast16_t id);\n\n/******************************************************************************\\\n* Global data.\n\\******************************************************************************/\n\njpc_dec_mstabent_t jpc_dec_mstab[] = {\n\t{JPC_MS_SOC, JPC_MHSOC, jpc_dec_process_soc},\n\t{JPC_MS_SOT, JPC_MH | JPC_TPHSOT, jpc_dec_process_sot},\n\t{JPC_MS_SOD, JPC_TPH, jpc_dec_process_sod},\n\t{JPC_MS_EOC, JPC_TPHSOT, jpc_dec_process_eoc},\n\t{JPC_MS_SIZ, JPC_MHSIZ, jpc_dec_process_siz},\n\t{JPC_MS_COD, JPC_MH | JPC_TPH, jpc_dec_process_cod},\n\t{JPC_MS_COC, JPC_MH | JPC_TPH, jpc_dec_process_coc},\n\t{JPC_MS_RGN, JPC_MH | JPC_TPH, jpc_dec_process_rgn},\n\t{JPC_MS_QCD, JPC_MH | JPC_TPH, jpc_dec_process_qcd},\n\t{JPC_MS_QCC, JPC_MH | JPC_TPH, jpc_dec_process_qcc},\n\t{JPC_MS_POC, JPC_MH | JPC_TPH, jpc_dec_process_poc},\n\t{JPC_MS_TLM, JPC_MH, 0},\n\t{JPC_MS_PLM, JPC_MH, 0},\n\t{JPC_MS_PLT, JPC_TPH, 0},\n\t{JPC_MS_PPM, JPC_MH, jpc_dec_process_ppm},\n\t{JPC_MS_PPT, JPC_TPH, jpc_dec_process_ppt},\n\t{JPC_MS_SOP, 0, 0},\n\t{JPC_MS_CRG, JPC_MH, jpc_dec_process_crg},\n\t{JPC_MS_COM, JPC_MH | JPC_TPH, jpc_dec_process_com},\n\t{0, JPC_MH | JPC_TPH, jpc_dec_process_unk}\n};\n\n/******************************************************************************\\\n* The main entry point for the JPEG-2000 decoder.\n\\******************************************************************************/\n\njas_image_t *jpc_decode(jas_stream_t *in, char *optstr)\n{\n\tjpc_dec_importopts_t opts;\n\tjpc_dec_t *dec;\n\tjas_image_t *image;\n\n\tdec = 0;\n\n\tif (jpc_dec_parseopts(optstr, &opts)) {\n\t\tgoto error;\n\t}\n\n\tjpc_initluts();\n\n\tif (!(dec = jpc_dec_create(&opts, in))) {\n\t\tgoto error;\n\t}\n\n\t/* Do most of the work. */\n\tif (jpc_dec_decode(dec)) {\n\t\tgoto error;\n\t}\n\n\tif (jas_image_numcmpts(dec->image) >= 3) {\n\t\tjas_image_setclrspc(dec->image, JAS_CLRSPC_SRGB);\n\t\tjas_image_setcmpttype(dec->image, 0,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_R));\n\t\tjas_image_setcmpttype(dec->image, 1,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_G));\n\t\tjas_image_setcmpttype(dec->image, 2,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_B));\n\t} else {\n\t\tjas_image_setclrspc(dec->image, JAS_CLRSPC_SGRAY);\n\t\tjas_image_setcmpttype(dec->image, 0,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_GRAY_Y));\n\t}\n\n\t/* Save the return value. */\n\timage = dec->image;\n\n\t/* Stop the image from being discarded. */\n\tdec->image = 0;\n\n\t/* Destroy decoder. */\n\tjpc_dec_destroy(dec);\n\n\treturn image;\n\nerror:\n\tif (dec) {\n\t\tjpc_dec_destroy(dec);\n\t}\n\treturn 0;\n}\n\ntypedef enum {\n\tOPT_MAXLYRS,\n\tOPT_MAXPKTS,\n\tOPT_DEBUG\n} optid_t;\n\njas_taginfo_t decopts[] = {\n\t{OPT_MAXLYRS, \"maxlyrs\"},\n\t{OPT_MAXPKTS, \"maxpkts\"},\n\t{OPT_DEBUG, \"debug\"},\n\t{-1, 0}\n};\n\nstatic int jpc_dec_parseopts(char *optstr, jpc_dec_importopts_t *opts)\n{\n\tjas_tvparser_t *tvp;\n\n\topts->debug = 0;\n\topts->maxlyrs = JPC_MAXLYRS;\n\topts->maxpkts = -1;\n\n\tif (!(tvp = jas_tvparser_create(optstr ? optstr : \"\"))) {\n\t\treturn -1;\n\t}\n\n\twhile (!jas_tvparser_next(tvp)) {\n\t\tswitch (jas_taginfo_nonull(jas_taginfos_lookup(decopts,\n\t\t  jas_tvparser_gettag(tvp)))->id) {\n\t\tcase OPT_MAXLYRS:\n\t\t\topts->maxlyrs = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_DEBUG:\n\t\t\topts->debug = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_MAXPKTS:\n\t\t\topts->maxpkts = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tjas_eprintf(\"warning: ignoring invalid option %s\\n\",\n\t\t\t  jas_tvparser_gettag(tvp));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tjas_tvparser_destroy(tvp);\n\n\treturn 0;\n}\n\n/******************************************************************************\\\n* Code for table-driven code stream decoder.\n\\******************************************************************************/\n\nstatic jpc_dec_mstabent_t *jpc_dec_mstab_lookup(uint_fast16_t id)\n{\n\tjpc_dec_mstabent_t *mstabent;\n\tfor (mstabent = jpc_dec_mstab; mstabent->id != 0; ++mstabent) {\n\t\tif (mstabent->id == id) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn mstabent;\n}\n\nstatic int jpc_dec_decode(jpc_dec_t *dec)\n{\n\tjpc_ms_t *ms;\n\tjpc_dec_mstabent_t *mstabent;\n\tint ret;\n\tjpc_cstate_t *cstate;\n\n\tif (!(cstate = jpc_cstate_create())) {\n\t\treturn -1;\n\t}\n\tdec->cstate = cstate;\n\n\t/* Initially, we should expect to encounter a SOC marker segment. */\n\tdec->state = JPC_MHSOC;\n\n\tfor (;;) {\n\n\t\t/* Get the next marker segment in the code stream. */\n\t\tif (!(ms = jpc_getms(dec->in, cstate))) {\n\t\t\tjas_eprintf(\"cannot get marker segment\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tmstabent = jpc_dec_mstab_lookup(ms->id);\n\t\tassert(mstabent);\n\n\t\t/* Ensure that this type of marker segment is permitted\n\t\t  at this point in the code stream. */\n\t\tif (!(dec->state & mstabent->validstates)) {\n\t\t\tjas_eprintf(\"unexpected marker segment type\\n\");\n\t\t\tjpc_ms_destroy(ms);\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* Process the marker segment. */\n\t\tif (mstabent->action) {\n\t\t\tret = (*mstabent->action)(dec, ms);\n\t\t} else {\n\t\t\t/* No explicit action is required. */\n\t\t\tret = 0;\n\t\t}\n\n\t\t/* Destroy the marker segment. */\n\t\tjpc_ms_destroy(ms);\n\n\t\tif (ret < 0) {\n\t\t\treturn -1;\n\t\t} else if (ret > 0) {\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\treturn 0;\n}\n\nstatic int jpc_dec_process_crg(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tint cmptno;\n\tjpc_dec_cmpt_t *cmpt;\n\tjpc_crg_t *crg;\n\n\tcrg = &ms->parms.crg;\n\tfor (cmptno = 0, cmpt = dec->cmpts; cmptno < dec->numcomps; ++cmptno,\n\t  ++cmpt) {\n\t\t/* Ignore the information in the CRG marker segment for now.\n\t\t  This information serves no useful purpose for decoding anyhow.\n\t\t  Some other parts of the code need to be changed if these lines\n\t\t  are uncommented.\n\t\tcmpt->hsubstep = crg->comps[cmptno].hoff;\n\t\tcmpt->vsubstep = crg->comps[cmptno].voff;\n\t\t*/\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_soc(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\t/* Eliminate warnings about unused variables. */\n\tms = 0;\n\n\t/* We should expect to encounter a SIZ marker segment next. */\n\tdec->state = JPC_MHSIZ;\n\n\treturn 0;\n}\n\nstatic int jpc_dec_process_sot(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_dec_tile_t *tile;\n\tjpc_sot_t *sot = &ms->parms.sot;\n\tjas_image_cmptparm_t *compinfos;\n\tjas_image_cmptparm_t *compinfo;\n\tjpc_dec_cmpt_t *cmpt;\n\tint cmptno;\n\n\tif (dec->state == JPC_MH) {\n\n\t\tif (!(compinfos = jas_alloc2(dec->numcomps,\n\t\t  sizeof(jas_image_cmptparm_t)))) {\n\t\t\tabort();\n\t\t}\n\t\tfor (cmptno = 0, cmpt = dec->cmpts, compinfo = compinfos;\n\t\t  cmptno < dec->numcomps; ++cmptno, ++cmpt, ++compinfo) {\n\t\t\tcompinfo->tlx = 0;\n\t\t\tcompinfo->tly = 0;\n\t\t\tcompinfo->prec = cmpt->prec;\n\t\t\tcompinfo->sgnd = cmpt->sgnd;\n\t\t\tcompinfo->width = cmpt->width;\n\t\t\tcompinfo->height = cmpt->height;\n\t\t\tcompinfo->hstep = cmpt->hstep;\n\t\t\tcompinfo->vstep = cmpt->vstep;\n\t\t}\n\n\t\tif (!(dec->image = jas_image_create(dec->numcomps, compinfos,\n\t\t  JAS_CLRSPC_UNKNOWN))) {\n\t\t\tjas_free(compinfos);\n\t\t\treturn -1;\n\t\t}\n\t\tjas_free(compinfos);\n\n\t\t/* Is the packet header information stored in PPM marker segments in\n\t\t  the main header? */\n\t\tif (dec->ppmstab) {\n\t\t\t/* Convert the PPM marker segment data into a collection of streams\n\t\t\t  (one stream per tile-part). */\n\t\t\tif (!(dec->pkthdrstreams = jpc_ppmstabtostreams(dec->ppmstab))) {\n\t\t\t\tabort();\n\t\t\t}\n\t\t\tjpc_ppxstab_destroy(dec->ppmstab);\n\t\t\tdec->ppmstab = 0;\n\t\t}\n\t}\n\n\tif (sot->len > 0) {\n\t\tdec->curtileendoff = jas_stream_getrwcount(dec->in) - ms->len -\n\t\t  4 + sot->len;\n\t} else {\n\t\tdec->curtileendoff = 0;\n\t}\n\n\tif (JAS_CAST(int, sot->tileno) >= dec->numtiles) {\n\t\tjas_eprintf(\"invalid tile number in SOT marker segment\\n\");\n\t\treturn -1;\n\t}\n\t/* Set the current tile. */\n\tdec->curtile = &dec->tiles[sot->tileno];\n\ttile = dec->curtile;\n\t/* Ensure that this is the expected part number. */\n\tif (sot->partno != tile->partno) {\n\t\treturn -1;\n\t}\n\tif (tile->numparts > 0 && sot->partno >= tile->numparts) {\n\t\treturn -1;\n\t}\n\tif (!tile->numparts && sot->numparts > 0) {\n\t\ttile->numparts = sot->numparts;\n\t}\n\n\ttile->pptstab = 0;\n\n\tswitch (tile->state) {\n\tcase JPC_TILE_INIT:\n\t\t/* This is the first tile-part for this tile. */\n\t\ttile->state = JPC_TILE_ACTIVE;\n\t\tassert(!tile->cp);\n\t\tif (!(tile->cp = jpc_dec_cp_copy(dec->cp))) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_resetflags(dec->cp);\n\t\tbreak;\n\tdefault:\n\t\tif (sot->numparts == sot->partno - 1) {\n\t\t\ttile->state = JPC_TILE_ACTIVELAST;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* Note: We do not increment the expected tile-part number until\n\t  all processing for this tile-part is complete. */\n\n\t/* We should expect to encounter other tile-part header marker\n\t  segments next. */\n\tdec->state = JPC_TPH;\n\n\treturn 0;\n}\n\nstatic int jpc_dec_process_sod(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_dec_tile_t *tile;\n\tint pos;\n\n\t/* Eliminate compiler warnings about unused variables. */\n\tms = 0;\n\n\tif (!(tile = dec->curtile)) {\n\t\treturn -1;\n\t}\n\n\tif (!tile->partno) {\n\t\tif (!jpc_dec_cp_isvalid(tile->cp)) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_prepare(tile->cp);\n\t\tif (jpc_dec_tileinit(dec, tile)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* Are packet headers stored in the main header or tile-part header? */\n\tif (dec->pkthdrstreams) {\n\t\t/* Get the stream containing the packet header data for this\n\t\t  tile-part. */\n\t\tif (!(tile->pkthdrstream = jpc_streamlist_remove(dec->pkthdrstreams, 0))) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (tile->pptstab) {\n\t\tif (!tile->pkthdrstream) {\n\t\t\tif (!(tile->pkthdrstream = jas_stream_memopen(0, 0))) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tpos = jas_stream_tell(tile->pkthdrstream);\n\t\tjas_stream_seek(tile->pkthdrstream, 0, SEEK_END);\n\t\tif (jpc_pptstabwrite(tile->pkthdrstream, tile->pptstab)) {\n\t\t\treturn -1;\n\t\t}\n\t\tjas_stream_seek(tile->pkthdrstream, pos, SEEK_SET);\n\t\tjpc_ppxstab_destroy(tile->pptstab);\n\t\ttile->pptstab = 0;\n\t}\n\n\tif (jas_getdbglevel() >= 10) {\n\t\tjpc_dec_dump(dec, stderr);\n\t}\n\n\tif (jpc_dec_decodepkts(dec, (tile->pkthdrstream) ? tile->pkthdrstream :\n\t  dec->in, dec->in)) {\n\t\tjas_eprintf(\"jpc_dec_decodepkts failed\\n\");\n\t\treturn -1;\n\t}\n\n\t/* Gobble any unconsumed tile data. */\n\tif (dec->curtileendoff > 0) {\n\t\tlong curoff;\n\t\tuint_fast32_t n;\n\t\tcuroff = jas_stream_getrwcount(dec->in);\n\t\tif (curoff < dec->curtileendoff) {\n\t\t\tn = dec->curtileendoff - curoff;\n\t\t\tjas_eprintf(\"warning: ignoring trailing garbage (%lu bytes)\\n\",\n\t\t\t  (unsigned long) n);\n\n\t\t\twhile (n-- > 0) {\n\t\t\t\tif (jas_stream_getc(dec->in) == EOF) {\n\t\t\t\t\tjas_eprintf(\"read error\\n\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (curoff > dec->curtileendoff) {\n\t\t\tjas_eprintf(\"warning: not enough tile data (%lu bytes)\\n\",\n\t\t\t  (unsigned long) curoff - dec->curtileendoff);\n\t\t}\n\n\t}\n\n\tif (tile->numparts > 0 && tile->partno == tile->numparts - 1) {\n\t\tif (jpc_dec_tiledecode(dec, tile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_tilefini(dec, tile);\n\t}\n\n\tdec->curtile = 0;\n\n\t/* Increment the expected tile-part number. */\n\t++tile->partno;\n\n\t/* We should expect to encounter a SOT marker segment next. */\n\tdec->state = JPC_TPHSOT;\n\n\treturn 0;\n}\n\nstatic int jpc_dec_tileinit(jpc_dec_t *dec, jpc_dec_tile_t *tile)\n{\n\tjpc_dec_tcomp_t *tcomp;\n\tint compno;\n\tint rlvlno;\n\tjpc_dec_rlvl_t *rlvl;\n\tjpc_dec_band_t *band;\n\tjpc_dec_prc_t *prc;\n\tint bndno;\n\tjpc_tsfb_band_t *bnd;\n\tint bandno;\n\tjpc_dec_ccp_t *ccp;\n\tint prccnt;\n\tjpc_dec_cblk_t *cblk;\n\tint cblkcnt;\n\tuint_fast32_t tlprcxstart;\n\tuint_fast32_t tlprcystart;\n\tuint_fast32_t brprcxend;\n\tuint_fast32_t brprcyend;\n\tuint_fast32_t tlcbgxstart;\n\tuint_fast32_t tlcbgystart;\n\tuint_fast32_t brcbgxend;\n\tuint_fast32_t brcbgyend;\n\tuint_fast32_t cbgxstart;\n\tuint_fast32_t cbgystart;\n\tuint_fast32_t cbgxend;\n\tuint_fast32_t cbgyend;\n\tuint_fast32_t tlcblkxstart;\n\tuint_fast32_t tlcblkystart;\n\tuint_fast32_t brcblkxend;\n\tuint_fast32_t brcblkyend;\n\tuint_fast32_t cblkxstart;\n\tuint_fast32_t cblkystart;\n\tuint_fast32_t cblkxend;\n\tuint_fast32_t cblkyend;\n\tuint_fast32_t tmpxstart;\n\tuint_fast32_t tmpystart;\n\tuint_fast32_t tmpxend;\n\tuint_fast32_t tmpyend;\n\tjpc_dec_cp_t *cp;\n\tjpc_tsfb_band_t bnds[64];\n\tjpc_pchg_t *pchg;\n\tint pchgno;\n\tjpc_dec_cmpt_t *cmpt;\n\n\tcp = tile->cp;\n\ttile->realmode = 0;\n\tif (cp->mctid == JPC_MCT_ICT) {\n\t\ttile->realmode = 1;\n\t}\n\n\tfor (compno = 0, tcomp = tile->tcomps, cmpt = dec->cmpts; compno <\n\t  dec->numcomps; ++compno, ++tcomp, ++cmpt) {\n\t\tccp = &tile->cp->ccps[compno];\n\t\tif (ccp->qmfbid == JPC_COX_INS) {\n\t\t\ttile->realmode = 1;\n\t\t}\n\t\ttcomp->numrlvls = ccp->numrlvls;\n\t\tif (!(tcomp->rlvls = jas_alloc2(tcomp->numrlvls,\n\t\t  sizeof(jpc_dec_rlvl_t)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (!(tcomp->data = jas_seq2d_create(JPC_CEILDIV(tile->xstart,\n\t\t  cmpt->hstep), JPC_CEILDIV(tile->ystart, cmpt->vstep),\n\t\t  JPC_CEILDIV(tile->xend, cmpt->hstep), JPC_CEILDIV(tile->yend,\n\t\t  cmpt->vstep)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (!(tcomp->tsfb = jpc_cod_gettsfb(ccp->qmfbid,\n\t\t  tcomp->numrlvls - 1))) {\n\t\t\treturn -1;\n\t\t}\n\t\t{\n\t\t\tjpc_tsfb_getbands(tcomp->tsfb, jas_seq2d_xstart(tcomp->data),\n\t\t\t  jas_seq2d_ystart(tcomp->data), jas_seq2d_xend(tcomp->data),\n\t\t\t  jas_seq2d_yend(tcomp->data), bnds);\n\t\t}\n\t\tfor (rlvlno = 0, rlvl = tcomp->rlvls; rlvlno < tcomp->numrlvls;\n\t\t  ++rlvlno, ++rlvl) {\n\t\t\trlvl->bands = 0;\n\t\t\trlvl->xstart = JPC_CEILDIVPOW2(tcomp->xstart,\n\t\t\t  tcomp->numrlvls - 1 - rlvlno);\n\t\t\trlvl->ystart = JPC_CEILDIVPOW2(tcomp->ystart,\n\t\t\t  tcomp->numrlvls - 1 - rlvlno);\n\t\t\trlvl->xend = JPC_CEILDIVPOW2(tcomp->xend,\n\t\t\t  tcomp->numrlvls - 1 - rlvlno);\n\t\t\trlvl->yend = JPC_CEILDIVPOW2(tcomp->yend,\n\t\t\t  tcomp->numrlvls - 1 - rlvlno);\n\t\t\trlvl->prcwidthexpn = ccp->prcwidthexpns[rlvlno];\n\t\t\trlvl->prcheightexpn = ccp->prcheightexpns[rlvlno];\n\t\t\ttlprcxstart = JPC_FLOORDIVPOW2(rlvl->xstart,\n\t\t\t  rlvl->prcwidthexpn) << rlvl->prcwidthexpn;\n\t\t\ttlprcystart = JPC_FLOORDIVPOW2(rlvl->ystart,\n\t\t\t  rlvl->prcheightexpn) << rlvl->prcheightexpn;\n\t\t\tbrprcxend = JPC_CEILDIVPOW2(rlvl->xend,\n\t\t\t  rlvl->prcwidthexpn) << rlvl->prcwidthexpn;\n\t\t\tbrprcyend = JPC_CEILDIVPOW2(rlvl->yend,\n\t\t\t  rlvl->prcheightexpn) << rlvl->prcheightexpn;\n\t\t\trlvl->numhprcs = (brprcxend - tlprcxstart) >>\n\t\t\t  rlvl->prcwidthexpn;\n\t\t\trlvl->numvprcs = (brprcyend - tlprcystart) >>\n\t\t\t  rlvl->prcheightexpn;\n\t\t\trlvl->numprcs = rlvl->numhprcs * rlvl->numvprcs;\n\n\t\t\tif (rlvl->xstart >= rlvl->xend || rlvl->ystart >= rlvl->yend) {\n\t\t\t\trlvl->bands = 0;\n\t\t\t\trlvl->numprcs = 0;\n\t\t\t\trlvl->numhprcs = 0;\n\t\t\t\trlvl->numvprcs = 0;\n\t\t\t\tcontinue;\n\t\t\t}\t\n\t\t\tif (!rlvlno) {\n\t\t\t\ttlcbgxstart = tlprcxstart;\n\t\t\t\ttlcbgystart = tlprcystart;\n\t\t\t\tbrcbgxend = brprcxend;\n\t\t\t\tbrcbgyend = brprcyend;\n\t\t\t\trlvl->cbgwidthexpn = rlvl->prcwidthexpn;\n\t\t\t\trlvl->cbgheightexpn = rlvl->prcheightexpn;\n\t\t\t} else {\n\t\t\t\ttlcbgxstart = JPC_CEILDIVPOW2(tlprcxstart, 1);\n\t\t\t\ttlcbgystart = JPC_CEILDIVPOW2(tlprcystart, 1);\n\t\t\t\tbrcbgxend = JPC_CEILDIVPOW2(brprcxend, 1);\n\t\t\t\tbrcbgyend = JPC_CEILDIVPOW2(brprcyend, 1);\n\t\t\t\trlvl->cbgwidthexpn = rlvl->prcwidthexpn - 1;\n\t\t\t\trlvl->cbgheightexpn = rlvl->prcheightexpn - 1;\n\t\t\t}\n\t\t\trlvl->cblkwidthexpn = JAS_MIN(ccp->cblkwidthexpn,\n\t\t\t  rlvl->cbgwidthexpn);\n\t\t\trlvl->cblkheightexpn = JAS_MIN(ccp->cblkheightexpn,\n\t\t\t  rlvl->cbgheightexpn);\n\n\t\t\trlvl->numbands = (!rlvlno) ? 1 : 3;\n\t\t\tif (!(rlvl->bands = jas_alloc2(rlvl->numbands,\n\t\t\t  sizeof(jpc_dec_band_t)))) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (bandno = 0, band = rlvl->bands;\n\t\t\t  bandno < rlvl->numbands; ++bandno, ++band) {\n\t\t\t\tbndno = (!rlvlno) ? 0 : (3 * (rlvlno - 1) +\n\t\t\t\t  bandno + 1);\n\t\t\t\tbnd = &bnds[bndno];\n\n\t\t\t\tband->orient = bnd->orient;\n\t\t\t\tband->stepsize = ccp->stepsizes[bndno];\n\t\t\t\tband->analgain = JPC_NOMINALGAIN(ccp->qmfbid,\n\t\t\t\t  tcomp->numrlvls - 1, rlvlno, band->orient);\n\t\t\t\tband->absstepsize = jpc_calcabsstepsize(band->stepsize,\n\t\t\t\t  cmpt->prec + band->analgain);\n\t\t\t\tband->numbps = ccp->numguardbits +\n\t\t\t\t  JPC_QCX_GETEXPN(band->stepsize) - 1;\n\t\t\t\tband->roishift = (ccp->roishift + band->numbps >= JPC_PREC) ?\n\t\t\t\t  (JPC_PREC - 1 - band->numbps) : ccp->roishift;\n\t\t\t\tband->data = 0;\n\t\t\t\tband->prcs = 0;\n\t\t\t\tif (bnd->xstart == bnd->xend || bnd->ystart == bnd->yend) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!(band->data = jas_seq2d_create(0, 0, 0, 0))) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tjas_seq2d_bindsub(band->data, tcomp->data, bnd->locxstart,\n\t\t\t\t  bnd->locystart, bnd->locxend, bnd->locyend);\n\t\t\t\tjas_seq2d_setshift(band->data, bnd->xstart, bnd->ystart);\n\n\t\t\t\tassert(rlvl->numprcs);\n\n\t\t\t\tif (!(band->prcs = jas_alloc2(rlvl->numprcs,\n\t\t\t\t  sizeof(jpc_dec_prc_t)))) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n/************************************************/\n\t\t\t\tcbgxstart = tlcbgxstart;\n\t\t\t\tcbgystart = tlcbgystart;\n\t\t\t\tfor (prccnt = rlvl->numprcs, prc = band->prcs;\n\t\t\t\t  prccnt > 0; --prccnt, ++prc) {\n\t\t\t\t\tcbgxend = cbgxstart + (1 << rlvl->cbgwidthexpn);\n\t\t\t\t\tcbgyend = cbgystart + (1 << rlvl->cbgheightexpn);\n\t\t\t\t\tprc->xstart = JAS_MAX(cbgxstart, JAS_CAST(uint_fast32_t,\n\t\t\t\t\t  jas_seq2d_xstart(band->data)));\n\t\t\t\t\tprc->ystart = JAS_MAX(cbgystart, JAS_CAST(uint_fast32_t,\n\t\t\t\t\t  jas_seq2d_ystart(band->data)));\n\t\t\t\t\tprc->xend = JAS_MIN(cbgxend, JAS_CAST(uint_fast32_t,\n\t\t\t\t\t  jas_seq2d_xend(band->data)));\n\t\t\t\t\tprc->yend = JAS_MIN(cbgyend, JAS_CAST(uint_fast32_t,\n\t\t\t\t\t  jas_seq2d_yend(band->data)));\n\t\t\t\t\tif (prc->xend > prc->xstart && prc->yend > prc->ystart) {\n\t\t\t\t\t\ttlcblkxstart = JPC_FLOORDIVPOW2(prc->xstart,\n\t\t\t\t\t\t  rlvl->cblkwidthexpn) << rlvl->cblkwidthexpn;\n\t\t\t\t\t\ttlcblkystart = JPC_FLOORDIVPOW2(prc->ystart,\n\t\t\t\t\t\t  rlvl->cblkheightexpn) << rlvl->cblkheightexpn;\n\t\t\t\t\t\tbrcblkxend = JPC_CEILDIVPOW2(prc->xend,\n\t\t\t\t\t\t  rlvl->cblkwidthexpn) << rlvl->cblkwidthexpn;\n\t\t\t\t\t\tbrcblkyend = JPC_CEILDIVPOW2(prc->yend,\n\t\t\t\t\t\t  rlvl->cblkheightexpn) << rlvl->cblkheightexpn;\n\t\t\t\t\t\tprc->numhcblks = (brcblkxend - tlcblkxstart) >>\n\t\t\t\t\t\t  rlvl->cblkwidthexpn;\n\t\t\t\t\t\tprc->numvcblks = (brcblkyend - tlcblkystart) >>\n\t\t\t\t\t\t  rlvl->cblkheightexpn;\n\t\t\t\t\t\tprc->numcblks = prc->numhcblks * prc->numvcblks;\n\t\t\t\t\t\tassert(prc->numcblks > 0);\n\n\t\t\t\t\t\tif (!(prc->incltagtree = jpc_tagtree_create(\n\t\t\t\t\t\t  prc->numhcblks, prc->numvcblks))) {\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!(prc->numimsbstagtree = jpc_tagtree_create(\n\t\t\t\t\t\t  prc->numhcblks, prc->numvcblks))) {\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!(prc->cblks = jas_alloc2(prc->numcblks,\n\t\t\t\t\t\t  sizeof(jpc_dec_cblk_t)))) {\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcblkxstart = cbgxstart;\n\t\t\t\t\t\tcblkystart = cbgystart;\n\t\t\t\t\t\tfor (cblkcnt = prc->numcblks, cblk = prc->cblks; cblkcnt > 0;) {\n\t\t\t\t\t\t\tcblkxend = cblkxstart + (1 << rlvl->cblkwidthexpn);\n\t\t\t\t\t\t\tcblkyend = cblkystart + (1 << rlvl->cblkheightexpn);\n\t\t\t\t\t\t\ttmpxstart = JAS_MAX(cblkxstart, prc->xstart);\n\t\t\t\t\t\t\ttmpystart = JAS_MAX(cblkystart, prc->ystart);\n\t\t\t\t\t\t\ttmpxend = JAS_MIN(cblkxend, prc->xend);\n\t\t\t\t\t\t\ttmpyend = JAS_MIN(cblkyend, prc->yend);\n\t\t\t\t\t\t\tif (tmpxend > tmpxstart && tmpyend > tmpystart) {\n\t\t\t\t\t\t\t\tcblk->firstpassno = -1;\n\t\t\t\t\t\t\t\tcblk->mqdec = 0;\n\t\t\t\t\t\t\t\tcblk->nulldec = 0;\n\t\t\t\t\t\t\t\tcblk->flags = 0;\n\t\t\t\t\t\t\t\tcblk->numpasses = 0;\n\t\t\t\t\t\t\t\tcblk->segs.head = 0;\n\t\t\t\t\t\t\t\tcblk->segs.tail = 0;\n\t\t\t\t\t\t\t\tcblk->curseg = 0;\n\t\t\t\t\t\t\t\tcblk->numimsbs = 0;\n\t\t\t\t\t\t\t\tcblk->numlenbits = 3;\n\t\t\t\t\t\t\t\tcblk->flags = 0;\n\t\t\t\t\t\t\t\tif (!(cblk->data = jas_seq2d_create(0, 0, 0, 0))) {\n\t\t\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tjas_seq2d_bindsub(cblk->data, band->data,\n\t\t\t\t\t\t\t\t  tmpxstart, tmpystart, tmpxend, tmpyend);\n\t\t\t\t\t\t\t\t++cblk;\n\t\t\t\t\t\t\t\t--cblkcnt;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcblkxstart += 1 << rlvl->cblkwidthexpn;\n\t\t\t\t\t\t\tif (cblkxstart >= cbgxend) {\n\t\t\t\t\t\t\t\tcblkxstart = cbgxstart;\n\t\t\t\t\t\t\t\tcblkystart += 1 << rlvl->cblkheightexpn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprc->cblks = 0;\n\t\t\t\t\t\tprc->incltagtree = 0;\n\t\t\t\t\t\tprc->numimsbstagtree = 0;\n\t\t\t\t\t}\n\t\t\t\t\tcbgxstart += 1 << rlvl->cbgwidthexpn;\n\t\t\t\t\tif (cbgxstart >= brcbgxend) {\n\t\t\t\t\t\tcbgxstart = tlcbgxstart;\n\t\t\t\t\t\tcbgystart += 1 << rlvl->cbgheightexpn;\n\t\t\t\t\t}\n\n\t\t\t\t}\n/********************************************/\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!(tile->pi = jpc_dec_pi_create(dec, tile))) {\n\t\treturn -1;\n\t}\n\n\tfor (pchgno = 0; pchgno < jpc_pchglist_numpchgs(tile->cp->pchglist);\n\t  ++pchgno) {\n\t\tpchg = jpc_pchg_copy(jpc_pchglist_get(tile->cp->pchglist, pchgno));\n\t\tassert(pchg);\n\t\tjpc_pi_addpchg(tile->pi, pchg);\n\t}\n\tjpc_pi_init(tile->pi);\n\n\treturn 0;\n}\n\nstatic int jpc_dec_tilefini(jpc_dec_t *dec, jpc_dec_tile_t *tile)\n{\n\tjpc_dec_tcomp_t *tcomp;\n\tint compno;\n\tint bandno;\n\tint rlvlno;\n\tjpc_dec_band_t *band;\n\tjpc_dec_rlvl_t *rlvl;\n\tint prcno;\n\tjpc_dec_prc_t *prc;\n\tjpc_dec_seg_t *seg;\n\tjpc_dec_cblk_t *cblk;\n\tint cblkno;\n\n\tif (tile->tcomps) {\n\n\t\tfor (compno = 0, tcomp = tile->tcomps; compno < dec->numcomps;\n\t\t  ++compno, ++tcomp) {\n\t\t\tfor (rlvlno = 0, rlvl = tcomp->rlvls; rlvlno < tcomp->numrlvls;\n\t\t\t  ++rlvlno, ++rlvl) {\n\t\t\t\tif (!rlvl->bands) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (bandno = 0, band = rlvl->bands; bandno < rlvl->numbands;\n\t\t\t\t  ++bandno, ++band) {\n\t\t\t\t\tif (band->prcs) {\n\t\t\t\t\t\tfor (prcno = 0, prc = band->prcs; prcno <\n\t\t\t\t\t\t  rlvl->numprcs; ++prcno, ++prc) {\n\t\t\t\t\t\t\tif (!prc->cblks) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (cblkno = 0, cblk = prc->cblks; cblkno <\n\t\t\t\t\t\t\t  prc->numcblks; ++cblkno, ++cblk) {\n\n\t\t\t\t\t\t\t\twhile (cblk->segs.head) {\n\t\t\t\t\t\t\t\t\tseg = cblk->segs.head;\n\t\t\t\t\t\t\t\t\tjpc_seglist_remove(&cblk->segs, seg);\n\t\t\t\t\t\t\t\t\tjpc_seg_destroy(seg);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tjas_matrix_destroy(cblk->data);\n\t\t\t\t\t\t\t\tif (cblk->mqdec) {\n\t\t\t\t\t\t\t\t\tjpc_mqdec_destroy(cblk->mqdec);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (cblk->nulldec) {\n\t\t\t\t\t\t\t\t\tjpc_bitstream_close(cblk->nulldec);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (cblk->flags) {\n\t\t\t\t\t\t\t\t\tjas_matrix_destroy(cblk->flags);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (prc->incltagtree) {\n\t\t\t\t\t\t\t\tjpc_tagtree_destroy(prc->incltagtree);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (prc->numimsbstagtree) {\n\t\t\t\t\t\t\t\tjpc_tagtree_destroy(prc->numimsbstagtree);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (prc->cblks) {\n\t\t\t\t\t\t\t\tjas_free(prc->cblks);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (band->data) {\n\t\t\t\t\t\tjas_matrix_destroy(band->data);\n\t\t\t\t\t}\n\t\t\t\t\tif (band->prcs) {\n\t\t\t\t\t\tjas_free(band->prcs);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (rlvl->bands) {\n\t\t\t\t\tjas_free(rlvl->bands);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (tcomp->rlvls) {\n\t\t\t\tjas_free(tcomp->rlvls);\n\t\t\t}\n\t\t\tif (tcomp->data) {\n\t\t\t\tjas_matrix_destroy(tcomp->data);\n\t\t\t}\n\t\t\tif (tcomp->tsfb) {\n\t\t\t\tjpc_tsfb_destroy(tcomp->tsfb);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (tile->cp) {\n\t\tjpc_dec_cp_destroy(tile->cp);\n\t\t//tile->cp = 0;\n\t}\n\tif (tile->tcomps) {\n\t\tjas_free(tile->tcomps);\n\t\t//tile->tcomps = 0;\n\t}\n\tif (tile->pi) {\n\t\tjpc_pi_destroy(tile->pi);\n\t\t//tile->pi = 0;\n\t}\n\tif (tile->pkthdrstream) {\n\t\tjas_stream_close(tile->pkthdrstream);\n\t\t//tile->pkthdrstream = 0;\n\t}\n\tif (tile->pptstab) {\n\t\tjpc_ppxstab_destroy(tile->pptstab);\n\t\t//tile->pptstab = 0;\n\t}\n\n\ttile->state = JPC_TILE_DONE;\n\n\treturn 0;\n}\n\nstatic int jpc_dec_tiledecode(jpc_dec_t *dec, jpc_dec_tile_t *tile)\n{\n\tint i;\n\tint j;\n\tjpc_dec_tcomp_t *tcomp;\n\tjpc_dec_rlvl_t *rlvl;\n\tjpc_dec_band_t *band;\n\tint compno;\n\tint rlvlno;\n\tint bandno;\n\tint adjust;\n\tint v;\n\tjpc_dec_ccp_t *ccp;\n\tjpc_dec_cmpt_t *cmpt;\n\n\tif (jpc_dec_decodecblks(dec, tile)) {\n\t\tjas_eprintf(\"jpc_dec_decodecblks failed\\n\");\n\t\treturn -1;\n\t}\n\n\t/* Perform dequantization. */\n\tfor (compno = 0, tcomp = tile->tcomps; compno < dec->numcomps;\n\t  ++compno, ++tcomp) {\n\t\tccp = &tile->cp->ccps[compno];\n\t\tfor (rlvlno = 0, rlvl = tcomp->rlvls; rlvlno < tcomp->numrlvls;\n\t\t  ++rlvlno, ++rlvl) {\n\t\t\tif (!rlvl->bands) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (bandno = 0, band = rlvl->bands;\n\t\t\t  bandno < rlvl->numbands; ++bandno, ++band) {\n\t\t\t\tif (!band->data) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tjpc_undo_roi(band->data, band->roishift, ccp->roishift -\n\t\t\t\t  band->roishift, band->numbps);\n\t\t\t\tif (tile->realmode) {\n\t\t\t\t\tjas_matrix_asl(band->data, JPC_FIX_FRACBITS);\n\t\t\t\t\tjpc_dequantize(band->data, band->absstepsize);\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Apply an inverse wavelet transform if necessary. */\n\tfor (compno = 0, tcomp = tile->tcomps; compno < dec->numcomps;\n\t  ++compno, ++tcomp) {\n\t\tccp = &tile->cp->ccps[compno];\n\t\tjpc_tsfb_synthesize(tcomp->tsfb, tcomp->data);\n\t}\n\n\n\t/* Apply an inverse intercomponent transform if necessary. */\n\tswitch (tile->cp->mctid) {\n\tcase JPC_MCT_RCT:\n\t\tif (dec->numcomps < 3) {\n\t\t\tjas_eprintf(\"RCT requires at least three components\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (!jas_image_cmpt_domains_same(dec->image)) {\n\t\t\tjas_eprintf(\"RCT requires all components have the same domain\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_irct(tile->tcomps[0].data, tile->tcomps[1].data,\n\t\t  tile->tcomps[2].data);\n\t\tbreak;\n\tcase JPC_MCT_ICT:\n\t\tif (dec->numcomps < 3) {\n\t\t\tjas_eprintf(\"ICT requires at least three components\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (!jas_image_cmpt_domains_same(dec->image)) {\n\t\t\tjas_eprintf(\"RCT requires all components have the same domain\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_iict(tile->tcomps[0].data, tile->tcomps[1].data,\n\t\t  tile->tcomps[2].data);\n\t\tbreak;\n\t}\n\n\t/* Perform rounding and convert to integer values. */\n\tif (tile->realmode) {\n\t\tfor (compno = 0, tcomp = tile->tcomps; compno < dec->numcomps;\n\t\t  ++compno, ++tcomp) {\n\t\t\tfor (i = 0; i < jas_matrix_numrows(tcomp->data); ++i) {\n\t\t\t\tfor (j = 0; j < jas_matrix_numcols(tcomp->data); ++j) {\n\t\t\t\t\tv = jas_matrix_get(tcomp->data, i, j);\n\t\t\t\t\tv = jpc_fix_round(v);\n\t\t\t\t\tjas_matrix_set(tcomp->data, i, j, jpc_fixtoint(v));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Perform level shift. */\n\tfor (compno = 0, tcomp = tile->tcomps, cmpt = dec->cmpts; compno <\n\t  dec->numcomps; ++compno, ++tcomp, ++cmpt) {\n\t\tadjust = cmpt->sgnd ? 0 : (1 << (cmpt->prec - 1));\n\t\tfor (i = 0; i < jas_matrix_numrows(tcomp->data); ++i) {\n\t\t\tfor (j = 0; j < jas_matrix_numcols(tcomp->data); ++j) {\n\t\t\t\t*jas_matrix_getref(tcomp->data, i, j) += adjust;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Perform clipping. */\n\tfor (compno = 0, tcomp = tile->tcomps, cmpt = dec->cmpts; compno <\n\t  dec->numcomps; ++compno, ++tcomp, ++cmpt) {\n\t\tjpc_fix_t mn;\n\t\tjpc_fix_t mx;\n\t\tmn = cmpt->sgnd ? (-(1 << (cmpt->prec - 1))) : (0);\n\t\tmx = cmpt->sgnd ? ((1 << (cmpt->prec - 1)) - 1) : ((1 <<\n\t\t  cmpt->prec) - 1);\n\t\tjas_matrix_clip(tcomp->data, mn, mx);\n\t}\n\n\t/* XXX need to free tsfb struct */\n\n\t/* Write the data for each component of the image. */\n\tfor (compno = 0, tcomp = tile->tcomps, cmpt = dec->cmpts; compno <\n\t  dec->numcomps; ++compno, ++tcomp, ++cmpt) {\n\t\tif (jas_image_writecmpt(dec->image, compno, tcomp->xstart -\n\t\t  JPC_CEILDIV(dec->xstart, cmpt->hstep), tcomp->ystart -\n\t\t  JPC_CEILDIV(dec->ystart, cmpt->vstep), jas_matrix_numcols(\n\t\t  tcomp->data), jas_matrix_numrows(tcomp->data), tcomp->data)) {\n\t\t\tjas_eprintf(\"write component failed\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int jpc_dec_process_eoc(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tint tileno;\n\tjpc_dec_tile_t *tile;\n\n\t/* Eliminate compiler warnings about unused variables. */\n\tms = 0;\n\n\tfor (tileno = 0, tile = dec->tiles; tileno < dec->numtiles; ++tileno,\n\t  ++tile) {\n\t\tif (tile->state == JPC_TILE_ACTIVE) {\n\t\t\tif (jpc_dec_tiledecode(dec, tile)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\t/* If the tile has not yet been finalized, finalize it. */\n\t\t// OLD CODE: jpc_dec_tilefini(dec, tile);\n\t\tif (tile->state != JPC_TILE_DONE) {\n\t\t\tjpc_dec_tilefini(dec, tile);\n\t\t}\n\t}\n\n\t/* We are done processing the code stream. */\n\tdec->state = JPC_MT;\n\n\treturn 1;\n}\n\nstatic int jpc_dec_process_siz(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_siz_t *siz = &ms->parms.siz;\n\tint compno;\n\tint tileno;\n\tjpc_dec_tile_t *tile;\n\tjpc_dec_tcomp_t *tcomp;\n\tint htileno;\n\tint vtileno;\n\tjpc_dec_cmpt_t *cmpt;\n\tsize_t size;\n\n\tdec->xstart = siz->xoff;\n\tdec->ystart = siz->yoff;\n\tdec->xend = siz->width;\n\tdec->yend = siz->height;\n\tdec->tilewidth = siz->tilewidth;\n\tdec->tileheight = siz->tileheight;\n\tdec->tilexoff = siz->tilexoff;\n\tdec->tileyoff = siz->tileyoff;\n\tdec->numcomps = siz->numcomps;\n\tif (!(dec->cp = jpc_dec_cp_create(dec->numcomps))) {\n\t\treturn -1;\n\t}\n\n\tif (!(dec->cmpts = jas_alloc2(dec->numcomps, sizeof(jpc_dec_cmpt_t)))) {\n\t\treturn -1;\n\t}\n\n\tfor (compno = 0, cmpt = dec->cmpts; compno < dec->numcomps; ++compno,\n\t  ++cmpt) {\n\t\tcmpt->prec = siz->comps[compno].prec;\n\t\tcmpt->sgnd = siz->comps[compno].sgnd;\n\t\tcmpt->hstep = siz->comps[compno].hsamp;\n\t\tcmpt->vstep = siz->comps[compno].vsamp;\n\t\tcmpt->width = JPC_CEILDIV(dec->xend, cmpt->hstep) -\n\t\t  JPC_CEILDIV(dec->xstart, cmpt->hstep);\n\t\tcmpt->height = JPC_CEILDIV(dec->yend, cmpt->vstep) -\n\t\t  JPC_CEILDIV(dec->ystart, cmpt->vstep);\n\t\tcmpt->hsubstep = 0;\n\t\tcmpt->vsubstep = 0;\n\t}\n\n\tdec->image = 0;\n\n\tdec->numhtiles = JPC_CEILDIV(dec->xend - dec->tilexoff, dec->tilewidth);\n\tdec->numvtiles = JPC_CEILDIV(dec->yend - dec->tileyoff, dec->tileheight);\n\tif (!jas_safe_size_mul(dec->numhtiles, dec->numvtiles, &size)) {\n\t\treturn -1;\n\t}\n\tdec->numtiles = size;\n\tJAS_DBGLOG(10, (\"numtiles = %d; numhtiles = %d; numvtiles = %d;\\n\",\n\t  dec->numtiles, dec->numhtiles, dec->numvtiles));\n\tif (!(dec->tiles = jas_alloc2(dec->numtiles, sizeof(jpc_dec_tile_t)))) {\n\t\treturn -1;\n\t}\n\n\tfor (tileno = 0, tile = dec->tiles; tileno < dec->numtiles; ++tileno,\n\t  ++tile) {\n\t\thtileno = tileno % dec->numhtiles;\n\t\tvtileno = tileno / dec->numhtiles;\n\t\ttile->realmode = 0;\n\t\ttile->state = JPC_TILE_INIT;\n\t\ttile->xstart = JAS_MAX(dec->tilexoff + htileno * dec->tilewidth,\n\t\t  dec->xstart);\n\t\ttile->ystart = JAS_MAX(dec->tileyoff + vtileno * dec->tileheight,\n\t\t  dec->ystart);\n\t\ttile->xend = JAS_MIN(dec->tilexoff + (htileno + 1) *\n\t\t  dec->tilewidth, dec->xend);\n\t\ttile->yend = JAS_MIN(dec->tileyoff + (vtileno + 1) *\n\t\t  dec->tileheight, dec->yend);\n\t\ttile->numparts = 0;\n\t\ttile->partno = 0;\n\t\ttile->pkthdrstream = 0;\n\t\ttile->pkthdrstreampos = 0;\n\t\ttile->pptstab = 0;\n\t\ttile->cp = 0;\n\t\ttile->pi = 0;\n\t\tif (!(tile->tcomps = jas_alloc2(dec->numcomps,\n\t\t  sizeof(jpc_dec_tcomp_t)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor (compno = 0, cmpt = dec->cmpts, tcomp = tile->tcomps;\n\t\t  compno < dec->numcomps; ++compno, ++cmpt, ++tcomp) {\n\t\t\ttcomp->rlvls = 0;\n\t\t\ttcomp->numrlvls = 0;\n\t\t\ttcomp->data = 0;\n\t\t\ttcomp->xstart = JPC_CEILDIV(tile->xstart, cmpt->hstep);\n\t\t\ttcomp->ystart = JPC_CEILDIV(tile->ystart, cmpt->vstep);\n\t\t\ttcomp->xend = JPC_CEILDIV(tile->xend, cmpt->hstep);\n\t\t\ttcomp->yend = JPC_CEILDIV(tile->yend, cmpt->vstep);\n\t\t\ttcomp->tsfb = 0;\n\t\t}\n\t}\n\n\tdec->pkthdrstreams = 0;\n\n\t/* We should expect to encounter other main header marker segments\n\t  or an SOT marker segment next. */\n\tdec->state = JPC_MH;\n\n\treturn 0;\n}\n\nstatic int jpc_dec_process_cod(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_cod_t *cod = &ms->parms.cod;\n\tjpc_dec_tile_t *tile;\n\n\tswitch (dec->state) {\n\tcase JPC_MH:\n\t\tjpc_dec_cp_setfromcod(dec->cp, cod);\n\t\tbreak;\n\tcase JPC_TPH:\n\t\tif (!(tile = dec->curtile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (tile->partno != 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_setfromcod(tile->cp, cod);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_coc(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_coc_t *coc = &ms->parms.coc;\n\tjpc_dec_tile_t *tile;\n\n\tif (JAS_CAST(int, coc->compno) >= dec->numcomps) {\n\t\tjas_eprintf(\"invalid component number in COC marker segment\\n\");\n\t\treturn -1;\n\t}\n\tswitch (dec->state) {\n\tcase JPC_MH:\n\t\tjpc_dec_cp_setfromcoc(dec->cp, coc);\n\t\tbreak;\n\tcase JPC_TPH:\n\t\tif (!(tile = dec->curtile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (tile->partno > 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_setfromcoc(tile->cp, coc);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_rgn(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_rgn_t *rgn = &ms->parms.rgn;\n\tjpc_dec_tile_t *tile;\n\n\tif (JAS_CAST(int, rgn->compno) >= dec->numcomps) {\n\t\tjas_eprintf(\"invalid component number in RGN marker segment\\n\");\n\t\treturn -1;\n\t}\n\tswitch (dec->state) {\n\tcase JPC_MH:\n\t\tjpc_dec_cp_setfromrgn(dec->cp, rgn);\n\t\tbreak;\n\tcase JPC_TPH:\n\t\tif (!(tile = dec->curtile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (tile->partno > 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_setfromrgn(tile->cp, rgn);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int jpc_dec_process_qcd(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_qcd_t *qcd = &ms->parms.qcd;\n\tjpc_dec_tile_t *tile;\n\n\tswitch (dec->state) {\n\tcase JPC_MH:\n\t\tjpc_dec_cp_setfromqcd(dec->cp, qcd);\n\t\tbreak;\n\tcase JPC_TPH:\n\t\tif (!(tile = dec->curtile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (tile->partno > 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_setfromqcd(tile->cp, qcd);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_qcc(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_qcc_t *qcc = &ms->parms.qcc;\n\tjpc_dec_tile_t *tile;\n\n\tif (JAS_CAST(int, qcc->compno) >= dec->numcomps) {\n\t\tjas_eprintf(\"invalid component number in QCC marker segment\\n\");\n\t\treturn -1;\n\t}\n\tswitch (dec->state) {\n\tcase JPC_MH:\n\t\tjpc_dec_cp_setfromqcc(dec->cp, qcc);\n\t\tbreak;\n\tcase JPC_TPH:\n\t\tif (!(tile = dec->curtile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (tile->partno > 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_setfromqcc(tile->cp, qcc);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_poc(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_poc_t *poc = &ms->parms.poc;\n\tjpc_dec_tile_t *tile;\n\tswitch (dec->state) {\n\tcase JPC_MH:\n\t\tif (jpc_dec_cp_setfrompoc(dec->cp, poc, 1)) {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tcase JPC_TPH:\n\t\tif (!(tile = dec->curtile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (!tile->partno) {\n\t\t\tif (jpc_dec_cp_setfrompoc(tile->cp, poc, (!tile->partno))) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\tjpc_pi_addpchgfrompoc(tile->pi, poc);\n\t\t}\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_ppm(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_ppm_t *ppm = &ms->parms.ppm;\n\tjpc_ppxstabent_t *ppmstabent;\n\n\tif (!dec->ppmstab) {\n\t\tif (!(dec->ppmstab = jpc_ppxstab_create())) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (!(ppmstabent = jpc_ppxstabent_create())) {\n\t\treturn -1;\n\t}\n\tppmstabent->ind = ppm->ind;\n\tppmstabent->data = ppm->data;\n\tppm->data = 0;\n\tppmstabent->len = ppm->len;\n\tif (jpc_ppxstab_insert(dec->ppmstab, ppmstabent)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_ppt(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_ppt_t *ppt = &ms->parms.ppt;\n\tjpc_dec_tile_t *tile;\n\tjpc_ppxstabent_t *pptstabent;\n\n\ttile = dec->curtile;\n\tif (!tile->pptstab) {\n\t\tif (!(tile->pptstab = jpc_ppxstab_create())) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (!(pptstabent = jpc_ppxstabent_create())) {\n\t\treturn -1;\n\t}\n\tpptstabent->ind = ppt->ind;\n\tpptstabent->data = ppt->data;\n\tppt->data = 0;\n\tpptstabent->len = ppt->len;\n\tif (jpc_ppxstab_insert(tile->pptstab, pptstabent)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_com(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\t/* Eliminate compiler warnings about unused variables. */\n\tdec = 0;\n\tms = 0;\n\n\treturn 0;\n}\n\nstatic int jpc_dec_process_unk(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\t/* Eliminate compiler warnings about unused variables. */\n\tdec = 0;\n\n\tjas_eprintf(\"warning: ignoring unknown marker segment\\n\");\n\tjpc_ms_dump(ms, stderr);\n\treturn 0;\n}\n\n/******************************************************************************\\\n*\n\\******************************************************************************/\n\nstatic jpc_dec_cp_t *jpc_dec_cp_create(uint_fast16_t numcomps)\n{\n\tjpc_dec_cp_t *cp;\n\tjpc_dec_ccp_t *ccp;\n\tint compno;\n\n\tif (!(cp = jas_malloc(sizeof(jpc_dec_cp_t)))) {\n\t\treturn 0;\n\t}\n\tcp->flags = 0;\n\tcp->numcomps = numcomps;\n\tcp->prgord = 0;\n\tcp->numlyrs = 0;\n\tcp->mctid = 0;\n\tcp->csty = 0;\n\tif (!(cp->ccps = jas_alloc2(cp->numcomps, sizeof(jpc_dec_ccp_t)))) {\n\t\tgoto error;\n\t}\n\tif (!(cp->pchglist = jpc_pchglist_create())) {\n\t\tgoto error;\n\t}\n\tfor (compno = 0, ccp = cp->ccps; compno < cp->numcomps;\n\t  ++compno, ++ccp) {\n\t\tccp->flags = 0;\n\t\tccp->numrlvls = 0;\n\t\tccp->cblkwidthexpn = 0;\n\t\tccp->cblkheightexpn = 0;\n\t\tccp->qmfbid = 0;\n\t\tccp->numstepsizes = 0;\n\t\tccp->numguardbits = 0;\n\t\tccp->roishift = 0;\n\t\tccp->cblkctx = 0;\n\t}\n\treturn cp;\nerror:\n\tif (cp) {\n\t\tjpc_dec_cp_destroy(cp);\n\t}\n\treturn 0;\n}\n\nstatic jpc_dec_cp_t *jpc_dec_cp_copy(jpc_dec_cp_t *cp)\n{\n\tjpc_dec_cp_t *newcp;\n\tjpc_dec_ccp_t *newccp;\n\tjpc_dec_ccp_t *ccp;\n\tint compno;\n\n\tif (!(newcp = jpc_dec_cp_create(cp->numcomps))) {\n\t\treturn 0;\n\t}\n\tnewcp->flags = cp->flags;\n\tnewcp->prgord = cp->prgord;\n\tnewcp->numlyrs = cp->numlyrs;\n\tnewcp->mctid = cp->mctid;\n\tnewcp->csty = cp->csty;\n\tjpc_pchglist_destroy(newcp->pchglist);\n\tnewcp->pchglist = 0;\n\tif (!(newcp->pchglist = jpc_pchglist_copy(cp->pchglist))) {\n\t\tjas_free(newcp);\n\t\treturn 0;\n\t}\n\tfor (compno = 0, newccp = newcp->ccps, ccp = cp->ccps;\n\t  compno < cp->numcomps;\n\t  ++compno, ++newccp, ++ccp) {\n\t\t*newccp = *ccp;\n\t}\n\treturn newcp;\n}\n\nstatic void jpc_dec_cp_resetflags(jpc_dec_cp_t *cp)\n{\n\tint compno;\n\tjpc_dec_ccp_t *ccp;\n\tcp->flags &= (JPC_CSET | JPC_QSET);\n\tfor (compno = 0, ccp = cp->ccps; compno < cp->numcomps;\n\t  ++compno, ++ccp) {\n\t\tccp->flags = 0;\n\t}\n}\n\nstatic void jpc_dec_cp_destroy(jpc_dec_cp_t *cp)\n{\n\tif (cp->ccps) {\n\t\tjas_free(cp->ccps);\n\t}\n\tif (cp->pchglist) {\n\t\tjpc_pchglist_destroy(cp->pchglist);\n\t}\n\tjas_free(cp);\n}\n\nstatic int jpc_dec_cp_isvalid(jpc_dec_cp_t *cp)\n{\n\tuint_fast16_t compcnt;\n\tjpc_dec_ccp_t *ccp;\n\n\tif (!(cp->flags & JPC_CSET) || !(cp->flags & JPC_QSET)) {\n\t\treturn 0;\n\t}\n\tfor (compcnt = cp->numcomps, ccp = cp->ccps; compcnt > 0; --compcnt,\n\t  ++ccp) {\n\t\t/* Is there enough step sizes for the number of bands? */\n\t\tif ((ccp->qsty != JPC_QCX_SIQNT && JAS_CAST(int, ccp->numstepsizes) < 3 *\n\t\t  ccp->numrlvls - 2) || (ccp->qsty == JPC_QCX_SIQNT &&\n\t\t  ccp->numstepsizes != 1)) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic void calcstepsizes(uint_fast16_t refstepsize, int numrlvls,\n  uint_fast16_t *stepsizes)\n{\n\tint bandno;\n\tint numbands;\n\tuint_fast16_t expn;\n\tuint_fast16_t mant;\n\texpn = JPC_QCX_GETEXPN(refstepsize);\n\tmant = JPC_QCX_GETMANT(refstepsize);\n\tnumbands = 3 * numrlvls - 2;\n\tfor (bandno = 0; bandno < numbands; ++bandno) {\n\t\tstepsizes[bandno] = JPC_QCX_MANT(mant) | JPC_QCX_EXPN(expn +\n\t\t  (numrlvls - 1) - (numrlvls - 1 - ((bandno > 0) ? ((bandno + 2) / 3) : (0))));\n\t}\n}\n\nstatic int jpc_dec_cp_prepare(jpc_dec_cp_t *cp)\n{\n\tjpc_dec_ccp_t *ccp;\n\tint compno;\n\tint i;\n\tfor (compno = 0, ccp = cp->ccps; compno < cp->numcomps;\n\t  ++compno, ++ccp) {\n\t\tif (!(ccp->csty & JPC_COX_PRT)) {\n\t\t\tfor (i = 0; i < JPC_MAXRLVLS; ++i) {\n\t\t\t\tccp->prcwidthexpns[i] = 15;\n\t\t\t\tccp->prcheightexpns[i] = 15;\n\t\t\t}\n\t\t}\n\t\tif (ccp->qsty == JPC_QCX_SIQNT) {\n\t\t\tcalcstepsizes(ccp->stepsizes[0], ccp->numrlvls, ccp->stepsizes);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_cp_setfromcod(jpc_dec_cp_t *cp, jpc_cod_t *cod)\n{\n\tjpc_dec_ccp_t *ccp;\n\tint compno;\n\tcp->flags |= JPC_CSET;\n\tcp->prgord = cod->prg;\n\tif (cod->mctrans) {\n\t\tcp->mctid = (cod->compparms.qmfbid == JPC_COX_INS) ? (JPC_MCT_ICT) : (JPC_MCT_RCT);\n\t} else {\n\t\tcp->mctid = JPC_MCT_NONE;\n\t}\n\tcp->numlyrs = cod->numlyrs;\n\tcp->csty = cod->csty & (JPC_COD_SOP | JPC_COD_EPH);\n\tfor (compno = 0, ccp = cp->ccps; compno < cp->numcomps;\n\t  ++compno, ++ccp) {\n\t\tjpc_dec_cp_setfromcox(cp, ccp, &cod->compparms, 0);\n\t}\n\tcp->flags |= JPC_CSET;\n\treturn 0;\n}\n\nstatic int jpc_dec_cp_setfromcoc(jpc_dec_cp_t *cp, jpc_coc_t *coc)\n{\n\tjpc_dec_cp_setfromcox(cp, &cp->ccps[coc->compno], &coc->compparms, JPC_COC);\n\treturn 0;\n}\n\nstatic int jpc_dec_cp_setfromcox(jpc_dec_cp_t *cp, jpc_dec_ccp_t *ccp,\n  jpc_coxcp_t *compparms, int flags)\n{\n\tint rlvlno;\n\n\t/* Eliminate compiler warnings about unused variables. */\n\tcp = 0;\n\n\tif ((flags & JPC_COC) || !(ccp->flags & JPC_COC)) {\n\t\tccp->numrlvls = compparms->numdlvls + 1;\n\t\tccp->cblkwidthexpn = JPC_COX_GETCBLKSIZEEXPN(\n\t\t  compparms->cblkwidthval);\n\t\tccp->cblkheightexpn = JPC_COX_GETCBLKSIZEEXPN(\n\t\t  compparms->cblkheightval);\n\t\tccp->qmfbid = compparms->qmfbid;\n\t\tccp->cblkctx = compparms->cblksty;\n\t\tccp->csty = compparms->csty & JPC_COX_PRT;\n\t\tfor (rlvlno = 0; rlvlno < compparms->numrlvls; ++rlvlno) {\n\t\t\tccp->prcwidthexpns[rlvlno] =\n\t\t\t  compparms->rlvls[rlvlno].parwidthval;\n\t\t\tccp->prcheightexpns[rlvlno] =\n\t\t\t  compparms->rlvls[rlvlno].parheightval;\n\t\t}\n\t\tccp->flags |= flags | JPC_CSET;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_cp_setfromqcd(jpc_dec_cp_t *cp, jpc_qcd_t *qcd)\n{\n\tint compno;\n\tjpc_dec_ccp_t *ccp;\n\tfor (compno = 0, ccp = cp->ccps; compno < cp->numcomps;\n\t  ++compno, ++ccp) {\n\t\tjpc_dec_cp_setfromqcx(cp, ccp, &qcd->compparms, 0);\n\t}\n\tcp->flags |= JPC_QSET;\n\treturn 0;\n}\n\nstatic int jpc_dec_cp_setfromqcc(jpc_dec_cp_t *cp, jpc_qcc_t *qcc)\n{\n\treturn jpc_dec_cp_setfromqcx(cp, &cp->ccps[qcc->compno], &qcc->compparms, JPC_QCC);\n}\n\nstatic int jpc_dec_cp_setfromqcx(jpc_dec_cp_t *cp, jpc_dec_ccp_t *ccp,\n  jpc_qcxcp_t *compparms, int flags)\n{\n\tint bandno;\n\n\t/* Eliminate compiler warnings about unused variables. */\n\tcp = 0;\n\n\tif ((flags & JPC_QCC) || !(ccp->flags & JPC_QCC)) {\n\t\tccp->flags |= flags | JPC_QSET;\n\t\tfor (bandno = 0; bandno < compparms->numstepsizes; ++bandno) {\n\t\t\tccp->stepsizes[bandno] = compparms->stepsizes[bandno];\n\t\t}\n\t\tccp->numstepsizes = compparms->numstepsizes;\n\t\tccp->numguardbits = compparms->numguard;\n\t\tccp->qsty = compparms->qntsty;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_cp_setfromrgn(jpc_dec_cp_t *cp, jpc_rgn_t *rgn)\n{\n\tjpc_dec_ccp_t *ccp;\n\tccp = &cp->ccps[rgn->compno];\n\tccp->roishift = rgn->roishift;\n\treturn 0;\n}\n\nstatic int jpc_pi_addpchgfrompoc(jpc_pi_t *pi, jpc_poc_t *poc)\n{\n\tint pchgno;\n\tjpc_pchg_t *pchg;\n\tfor (pchgno = 0; pchgno < poc->numpchgs; ++pchgno) {\n\t\tif (!(pchg = jpc_pchg_copy(&poc->pchgs[pchgno]))) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (jpc_pchglist_insert(pi->pchglist, -1, pchg)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_cp_setfrompoc(jpc_dec_cp_t *cp, jpc_poc_t *poc, int reset)\n{\n\tint pchgno;\n\tjpc_pchg_t *pchg;\n\tif (reset) {\n\t\twhile (jpc_pchglist_numpchgs(cp->pchglist) > 0) {\n\t\t\tpchg = jpc_pchglist_remove(cp->pchglist, 0);\n\t\t\tjpc_pchg_destroy(pchg);\n\t\t}\n\t}\n\tfor (pchgno = 0; pchgno < poc->numpchgs; ++pchgno) {\n\t\tif (!(pchg = jpc_pchg_copy(&poc->pchgs[pchgno]))) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (jpc_pchglist_insert(cp->pchglist, -1, pchg)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic jpc_fix_t jpc_calcabsstepsize(int stepsize, int numbits)\n{\n\tjpc_fix_t absstepsize;\n\tint n;\n\n\tabsstepsize = jpc_inttofix(1);\n\tn = JPC_FIX_FRACBITS - 11;\n\tabsstepsize |= (n >= 0) ? (JPC_QCX_GETMANT(stepsize) << n) :\n\t  (JPC_QCX_GETMANT(stepsize) >> (-n));\n\tn = numbits - JPC_QCX_GETEXPN(stepsize);\n\tabsstepsize = (n >= 0) ? (absstepsize << n) : (absstepsize >> (-n));\n\treturn absstepsize;\n}\n\nstatic void jpc_dequantize(jas_matrix_t *x, jpc_fix_t absstepsize)\n{\n\tint i;\n\tint j;\n\tint t;\n\n\tassert(absstepsize >= 0);\n\tif (absstepsize == jpc_inttofix(1)) {\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < jas_matrix_numrows(x); ++i) {\n\t\tfor (j = 0; j < jas_matrix_numcols(x); ++j) {\n\t\t\tt = jas_matrix_get(x, i, j);\n\t\t\tif (t) {\n\t\t\t\tt = jpc_fix_mul(t, absstepsize);\n\t\t\t} else {\n\t\t\t\tt = 0;\n\t\t\t}\n\t\t\tjas_matrix_set(x, i, j, t);\n\t\t}\n\t}\n\n}\n\nstatic void jpc_undo_roi(jas_matrix_t *x, int roishift, int bgshift, int numbps)\n{\n\tint i;\n\tint j;\n\tint thresh;\n\tjpc_fix_t val;\n\tjpc_fix_t mag;\n\tbool warn;\n\tuint_fast32_t mask;\n\n\tif (roishift < 0) {\n\t\t/* We could instead return an error here. */\n\t\t/* I do not think it matters much. */\n\t\tjas_eprintf(\"warning: forcing negative ROI shift to zero \"\n\t\t  \"(bitstream is probably corrupt)\\n\");\n\t\troishift = 0;\n\t}\n\tif (roishift == 0 && bgshift == 0) {\n\t\treturn;\n\t}\n\tthresh = 1 << roishift;\n\n\twarn = false;\n\tfor (i = 0; i < jas_matrix_numrows(x); ++i) {\n\t\tfor (j = 0; j < jas_matrix_numcols(x); ++j) {\n\t\t\tval = jas_matrix_get(x, i, j);\n\t\t\tmag = JAS_ABS(val);\n\t\t\tif (mag >= thresh) {\n\t\t\t\t/* We are dealing with ROI data. */\n\t\t\t\tmag >>= roishift;\n\t\t\t\tval = (val < 0) ? (-mag) : mag;\n\t\t\t\tjas_matrix_set(x, i, j, val);\n\t\t\t} else {\n\t\t\t\t/* We are dealing with non-ROI (i.e., background) data. */\n\t\t\t\tmag <<= bgshift;\n\t\t\t\tmask = (JAS_CAST(uint_fast32_t, 1) << numbps) - 1;\n\t\t\t\t/* Perform a basic sanity check on the sample value. */\n\t\t\t\t/* Some implementations write garbage in the unused\n\t\t\t\t  most-significant bit planes introduced by ROI shifting.\n\t\t\t\t  Here we ensure that any such bits are masked off. */\n\t\t\t\tif (mag & (~mask)) {\n\t\t\t\t\tif (!warn) {\n\t\t\t\t\t\tjas_eprintf(\"warning: possibly corrupt code stream\\n\");\n\t\t\t\t\t\twarn = true;\n\t\t\t\t\t}\n\t\t\t\t\tmag &= mask;\n\t\t\t\t}\n\t\t\t\tval = (val < 0) ? (-mag) : mag;\n\t\t\t\tjas_matrix_set(x, i, j, val);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic jpc_dec_t *jpc_dec_create(jpc_dec_importopts_t *impopts, jas_stream_t *in)\n{\n\tjpc_dec_t *dec;\n\n\tif (!(dec = jas_malloc(sizeof(jpc_dec_t)))) {\n\t\treturn 0;\n\t}\n\n\tdec->image = 0;\n\tdec->xstart = 0;\n\tdec->ystart = 0;\n\tdec->xend = 0;\n\tdec->yend = 0;\n\tdec->tilewidth = 0;\n\tdec->tileheight = 0;\n\tdec->tilexoff = 0;\n\tdec->tileyoff = 0;\n\tdec->numhtiles = 0;\n\tdec->numvtiles = 0;\n\tdec->numtiles = 0;\n\tdec->tiles = 0;\n\tdec->curtile = 0;\n\tdec->numcomps = 0;\n\tdec->in = in;\n\tdec->cp = 0;\n\tdec->maxlyrs = impopts->maxlyrs;\n\tdec->maxpkts = impopts->maxpkts;\ndec->numpkts = 0;\n\tdec->ppmseqno = 0;\n\tdec->state = 0;\n\tdec->cmpts = 0;\n\tdec->pkthdrstreams = 0;\n\tdec->ppmstab = 0;\n\tdec->curtileendoff = 0;\n\n\treturn dec;\n}\n\nstatic void jpc_dec_destroy(jpc_dec_t *dec)\n{\n\tif (dec->cstate) {\n\t\tjpc_cstate_destroy(dec->cstate);\n\t}\n\tif (dec->pkthdrstreams) {\n\t\tjpc_streamlist_destroy(dec->pkthdrstreams);\n\t}\n\tif (dec->image) {\n\t\tjas_image_destroy(dec->image);\n\t}\n\n\tif (dec->cp) {\n\t\tjpc_dec_cp_destroy(dec->cp);\n\t}\n\n\tif (dec->cmpts) {\n\t\tjas_free(dec->cmpts);\n\t}\n\n\tif (dec->tiles) {\n\t\tjas_free(dec->tiles);\n\t}\n\n\tjas_free(dec);\n}\n\n/******************************************************************************\\\n*\n\\******************************************************************************/\n\nvoid jpc_seglist_insert(jpc_dec_seglist_t *list, jpc_dec_seg_t *ins, jpc_dec_seg_t *node)\n{\n\tjpc_dec_seg_t *prev;\n\tjpc_dec_seg_t *next;\n\n\tprev = ins;\n\tnode->prev = prev;\n\tnext = prev ? (prev->next) : 0;\n\tnode->prev = prev;\n\tnode->next = next;\n\tif (prev) {\n\t\tprev->next = node;\n\t} else {\n\t\tlist->head = node;\n\t}\n\tif (next) {\n\t\tnext->prev = node;\n\t} else {\n\t\tlist->tail = node;\n\t}\n}\n\nvoid jpc_seglist_remove(jpc_dec_seglist_t *list, jpc_dec_seg_t *seg)\n{\n\tjpc_dec_seg_t *prev;\n\tjpc_dec_seg_t *next;\n\n\tprev = seg->prev;\n\tnext = seg->next;\n\tif (prev) {\n\t\tprev->next = next;\n\t} else {\n\t\tlist->head = next;\n\t}\n\tif (next) {\n\t\tnext->prev = prev;\n\t} else {\n\t\tlist->tail = prev;\n\t}\n\tseg->prev = 0;\n\tseg->next = 0;\n}\n\njpc_dec_seg_t *jpc_seg_alloc()\n{\n\tjpc_dec_seg_t *seg;\n\n\tif (!(seg = jas_malloc(sizeof(jpc_dec_seg_t)))) {\n\t\treturn 0;\n\t}\n\tseg->prev = 0;\n\tseg->next = 0;\n\tseg->passno = -1;\n\tseg->numpasses = 0;\n\tseg->maxpasses = 0;\n\tseg->type = JPC_SEG_INVALID;\n\tseg->stream = 0;\n\tseg->cnt = 0;\n\tseg->complete = 0;\n\tseg->lyrno = -1;\n\treturn seg;\n}\n\nvoid jpc_seg_destroy(jpc_dec_seg_t *seg)\n{\n\tif (seg->stream) {\n\t\tjas_stream_close(seg->stream);\n\t}\n\tjas_free(seg);\n}\n\nstatic int jpc_dec_dump(jpc_dec_t *dec, FILE *out)\n{\n\tjpc_dec_tile_t *tile;\n\tint tileno;\n\tjpc_dec_tcomp_t *tcomp;\n\tint compno;\n\tjpc_dec_rlvl_t *rlvl;\n\tint rlvlno;\n\tjpc_dec_band_t *band;\n\tint bandno;\n\tjpc_dec_prc_t *prc;\n\tint prcno;\n\tjpc_dec_cblk_t *cblk;\n\tint cblkno;\n\n\tfor (tileno = 0, tile = dec->tiles; tileno < dec->numtiles;\n\t  ++tileno, ++tile) {\n\t\tfor (compno = 0, tcomp = tile->tcomps; compno < dec->numcomps;\n\t\t  ++compno, ++tcomp) {\n\t\t\tfor (rlvlno = 0, rlvl = tcomp->rlvls; rlvlno <\n\t\t\t  tcomp->numrlvls; ++rlvlno, ++rlvl) {\n\t\t\t\tfprintf(out, \"RESOLUTION LEVEL %d\\n\", rlvlno);\n\t\t\t\tfprintf(out, \"xs =%\"PRIuFAST32\", ys = %\"PRIuFAST32\", xe = %\"PRIuFAST32\", ye = %\"PRIuFAST32\", w = %\"PRIuFAST32\", h = %\"PRIuFAST32\"\\n\",\n\t\t\t\t  rlvl->xstart, rlvl->ystart, rlvl->xend, rlvl->yend, rlvl->xend -\n\t\t\t\t  rlvl->xstart, rlvl->yend - rlvl->ystart);\n\t\t\t\tfor (bandno = 0, band = rlvl->bands;\n\t\t\t\t  bandno < rlvl->numbands; ++bandno, ++band) {\n\t\t\t\t\tfprintf(out, \"BAND %d\\n\", bandno);\n\t\t\t\t\tfprintf(out, \"xs =%\"PRIiFAST32\", ys = %\"PRIiFAST32\", xe = %\"PRIiFAST32\", ye = %\"PRIiFAST32\", w = %\"PRIiFAST32\", h = %\"PRIiFAST32\"\\n\",\n\t\t\t\t\t  jas_seq2d_xstart(band->data), jas_seq2d_ystart(band->data), jas_seq2d_xend(band->data),\n\t\t\t\t\t  jas_seq2d_yend(band->data), jas_seq2d_xend(band->data) - jas_seq2d_xstart(band->data),\n\t\t\t\t\t  jas_seq2d_yend(band->data) - jas_seq2d_ystart(band->data));\n\t\t\t\t\tfor (prcno = 0, prc = band->prcs;\n\t\t\t\t\t  prcno < rlvl->numprcs; ++prcno,\n\t\t\t\t\t  ++prc) {\n\t\t\t\t\t\tfprintf(out, \"CODE BLOCK GROUP %d\\n\", prcno);\n\t\t\t\t\t\tfprintf(out, \"xs =%\"PRIuFAST32\", ys = %\"PRIuFAST32\", xe = %\"PRIuFAST32\", ye = %\"PRIuFAST32\", w = %\"PRIuFAST32\", h = %\"PRIuFAST32\"\\n\",\n\t\t\t\t\t\t  prc->xstart, prc->ystart, prc->xend, prc->yend, prc->xend -\n\t\t\t\t\t\t  prc->xstart, prc->yend - prc->ystart);\n\t\t\t\t\t\tfor (cblkno = 0, cblk =\n\t\t\t\t\t\t  prc->cblks; cblkno <\n\t\t\t\t\t\t  prc->numcblks; ++cblkno,\n\t\t\t\t\t\t  ++cblk) {\n\t\t\t\t\t\t\tfprintf(out, \"CODE BLOCK %d\\n\", cblkno);\n\t\t\t\t\t\t\tfprintf(out, \"xs =%\"PRIiFAST32\", ys = %\"PRIiFAST32\", xe = %\"PRIiFAST32\", ye = %\"PRIiFAST32\", w = %\"PRIiFAST32\", h = %\"PRIiFAST32\"\\n\",\n\t\t\t\t\t\t\t  jas_seq2d_xstart(cblk->data), jas_seq2d_ystart(cblk->data), jas_seq2d_xend(cblk->data),\n\t\t\t\t\t\t\t  jas_seq2d_yend(cblk->data), jas_seq2d_xend(cblk->data) - jas_seq2d_xstart(cblk->data),\n\t\t\t\t\t\t\t  jas_seq2d_yend(cblk->data) - jas_seq2d_ystart(cblk->data));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\njpc_streamlist_t *jpc_streamlist_create()\n{\n\tjpc_streamlist_t *streamlist;\n\tint i;\n\n\tif (!(streamlist = jas_malloc(sizeof(jpc_streamlist_t)))) {\n\t\treturn 0;\n\t}\n\tstreamlist->numstreams = 0;\n\tstreamlist->maxstreams = 100;\n\tif (!(streamlist->streams = jas_alloc2(streamlist->maxstreams,\n\t  sizeof(jas_stream_t *)))) {\n\t\tjas_free(streamlist);\n\t\treturn 0;\n\t}\n\tfor (i = 0; i < streamlist->maxstreams; ++i) {\n\t\tstreamlist->streams[i] = 0;\n\t}\n\treturn streamlist;\n}\n\nint jpc_streamlist_insert(jpc_streamlist_t *streamlist, int streamno,\n  jas_stream_t *stream)\n{\n\tjas_stream_t **newstreams;\n\tint newmaxstreams;\n\tint i;\n\t/* Grow the array of streams if necessary. */\n\tif (streamlist->numstreams >= streamlist->maxstreams) {\n\t\tnewmaxstreams = streamlist->maxstreams + 1024;\n\t\tif (!(newstreams = jas_realloc2(streamlist->streams,\n\t\t  (newmaxstreams + 1024), sizeof(jas_stream_t *)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor (i = streamlist->numstreams; i < streamlist->maxstreams; ++i) {\n\t\t\tstreamlist->streams[i] = 0;\n\t\t}\n\t\tstreamlist->maxstreams = newmaxstreams;\n\t\tstreamlist->streams = newstreams;\n\t}\n\tif (streamno != streamlist->numstreams) {\n\t\t/* Can only handle insertion at start of list. */\n\t\treturn -1;\n\t}\n\tstreamlist->streams[streamno] = stream;\n\t++streamlist->numstreams;\n\treturn 0;\n}\n\njas_stream_t *jpc_streamlist_remove(jpc_streamlist_t *streamlist, int streamno)\n{\n\tjas_stream_t *stream;\n\tint i;\n\tif (streamno >= streamlist->numstreams) {\n\t\tabort();\n\t}\n\tstream = streamlist->streams[streamno];\n\tfor (i = streamno + 1; i < streamlist->numstreams; ++i) {\n\t\tstreamlist->streams[i - 1] = streamlist->streams[i];\n\t}\n\t--streamlist->numstreams;\n\treturn stream;\n}\n\nvoid jpc_streamlist_destroy(jpc_streamlist_t *streamlist)\n{\n\tint streamno;\n\tif (streamlist->streams) {\n\t\tfor (streamno = 0; streamno < streamlist->numstreams;\n\t\t  ++streamno) {\n\t\t\tjas_stream_close(streamlist->streams[streamno]);\n\t\t}\n\t\tjas_free(streamlist->streams);\n\t}\n\tjas_free(streamlist);\n}\n\njas_stream_t *jpc_streamlist_get(jpc_streamlist_t *streamlist, int streamno)\n{\n\tassert(streamno < streamlist->numstreams);\n\treturn streamlist->streams[streamno];\n}\n\nint jpc_streamlist_numstreams(jpc_streamlist_t *streamlist)\n{\n\treturn streamlist->numstreams;\n}\n\njpc_ppxstab_t *jpc_ppxstab_create()\n{\n\tjpc_ppxstab_t *tab;\n\n\tif (!(tab = jas_malloc(sizeof(jpc_ppxstab_t)))) {\n\t\treturn 0;\n\t}\n\ttab->numents = 0;\n\ttab->maxents = 0;\n\ttab->ents = 0;\n\treturn tab;\n}\n\nvoid jpc_ppxstab_destroy(jpc_ppxstab_t *tab)\n{\n\tint i;\n\tfor (i = 0; i < tab->numents; ++i) {\n\t\tjpc_ppxstabent_destroy(tab->ents[i]);\n\t}\n\tif (tab->ents) {\n\t\tjas_free(tab->ents);\n\t}\n\tjas_free(tab);\n}\n\nint jpc_ppxstab_grow(jpc_ppxstab_t *tab, int maxents)\n{\n\tjpc_ppxstabent_t **newents;\n\tif (tab->maxents < maxents) {\n\t\tnewents = (tab->ents) ? jas_realloc2(tab->ents, maxents,\n\t\t  sizeof(jpc_ppxstabent_t *)) : jas_alloc2(maxents, sizeof(jpc_ppxstabent_t *));\n\t\tif (!newents) {\n\t\t\treturn -1;\n\t\t}\n\t\ttab->ents = newents;\n\t\ttab->maxents = maxents;\n\t}\n\treturn 0;\n}\n\nint jpc_ppxstab_insert(jpc_ppxstab_t *tab, jpc_ppxstabent_t *ent)\n{\n\tint inspt;\n\tint i;\n\n\tfor (i = 0; i < tab->numents; ++i) {\n\t\tif (tab->ents[i]->ind > ent->ind) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tinspt = i;\n\n\tif (tab->numents >= tab->maxents) {\n\t\tif (jpc_ppxstab_grow(tab, tab->maxents + 128)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tfor (i = tab->numents; i > inspt; --i) {\n\t\ttab->ents[i] = tab->ents[i - 1];\n\t}\n\ttab->ents[i] = ent;\n\t++tab->numents;\n\n\treturn 0;\n}\n\njpc_streamlist_t *jpc_ppmstabtostreams(jpc_ppxstab_t *tab)\n{\n\tjpc_streamlist_t *streams;\n\tuchar *dataptr;\n\tuint_fast32_t datacnt;\n\tuint_fast32_t tpcnt;\n\tjpc_ppxstabent_t *ent;\n\tint entno;\n\tjas_stream_t *stream;\n\tint n;\n\n\tif (!(streams = jpc_streamlist_create())) {\n\t\tgoto error;\n\t}\n\n\tif (!tab->numents) {\n\t\treturn streams;\n\t}\n\n\tentno = 0;\n\tent = tab->ents[entno];\n\tdataptr = ent->data;\n\tdatacnt = ent->len;\n\tfor (;;) {\n\n\t\t/* Get the length of the packet header data for the current\n\t\t  tile-part. */\n\t\tif (datacnt < 4) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (!(stream = jas_stream_memopen(0, 0))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (jpc_streamlist_insert(streams, jpc_streamlist_numstreams(streams),\n\t\t  stream)) {\n\t\t\tgoto error;\n\t\t}\n\t\ttpcnt = (dataptr[0] << 24) | (dataptr[1] << 16) | (dataptr[2] << 8)\n\t\t  | dataptr[3];\n\t\tdatacnt -= 4;\n\t\tdataptr += 4;\n\n\t\t/* Get the packet header data for the current tile-part. */\n\t\twhile (tpcnt) {\n\t\t\tif (!datacnt) {\n\t\t\t\tif (++entno >= tab->numents) {\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tent = tab->ents[entno];\n\t\t\t\tdataptr = ent->data;\n\t\t\t\tdatacnt = ent->len;\n\t\t\t}\n\t\t\tn = JAS_MIN(tpcnt, datacnt);\n\t\t\tif (jas_stream_write(stream, dataptr, n) != n) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\ttpcnt -= n;\n\t\t\tdataptr += n;\n\t\t\tdatacnt -= n;\n\t\t}\n\t\tjas_stream_rewind(stream);\n\t\tif (!datacnt) {\n\t\t\tif (++entno >= tab->numents) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tent = tab->ents[entno];\n\t\t\tdataptr = ent->data;\n\t\t\tdatacnt = ent->len;\n\t\t}\n\t}\n\n\treturn streams;\n\nerror:\n\tif (streams) {\n\t\tjpc_streamlist_destroy(streams);\n\t}\n\treturn 0;\n}\n\nint jpc_pptstabwrite(jas_stream_t *out, jpc_ppxstab_t *tab)\n{\n\tint i;\n\tjpc_ppxstabent_t *ent;\n\tfor (i = 0; i < tab->numents; ++i) {\n\t\tent = tab->ents[i];\n\t\tif (jas_stream_write(out, ent->data, ent->len) != JAS_CAST(int, ent->len)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\njpc_ppxstabent_t *jpc_ppxstabent_create()\n{\n\tjpc_ppxstabent_t *ent;\n\tif (!(ent = jas_malloc(sizeof(jpc_ppxstabent_t)))) {\n\t\treturn 0;\n\t}\n\tent->data = 0;\n\tent->len = 0;\n\tent->ind = 0;\n\treturn ent;\n}\n\nvoid jpc_ppxstabent_destroy(jpc_ppxstabent_t *ent)\n{\n\tif (ent->data) {\n\t\tjas_free(ent->data);\n\t}\n\tjas_free(ent);\n}\n"], "fixing_code": ["/*\n * Copyright (c) 1999-2000, Image Power, Inc. and the University of\n *   British Columbia.\n * Copyright (c) 2001-2003 Michael David Adams.\n * All rights reserved.\n */\n\n/* __START_OF_JASPER_LICENSE__\n * \n * JasPer License Version 2.0\n * \n * Copyright (c) 2001-2006 Michael David Adams\n * Copyright (c) 1999-2000 Image Power, Inc.\n * Copyright (c) 1999-2000 The University of British Columbia\n * \n * All rights reserved.\n * \n * Permission is hereby granted, free of charge, to any person (the\n * \"User\") obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n * \n * 1.  The above copyright notices and this permission notice (which\n * includes the disclaimer below) shall be included in all copies or\n * substantial portions of the Software.\n * \n * 2.  The name of a copyright holder shall not be used to endorse or\n * promote products derived from the Software without specific prior\n * written permission.\n * \n * THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS\n * LICENSE.  NO USE OF THE SOFTWARE IS AUTHORIZED HEREUNDER EXCEPT UNDER\n * THIS DISCLAIMER.  THE SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS\n * \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.  IN NO\n * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL\n * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING\n * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\n * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION\n * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  NO ASSURANCES ARE\n * PROVIDED BY THE COPYRIGHT HOLDERS THAT THE SOFTWARE DOES NOT INFRINGE\n * THE PATENT OR OTHER INTELLECTUAL PROPERTY RIGHTS OF ANY OTHER ENTITY.\n * EACH COPYRIGHT HOLDER DISCLAIMS ANY LIABILITY TO THE USER FOR CLAIMS\n * BROUGHT BY ANY OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL\n * PROPERTY RIGHTS OR OTHERWISE.  AS A CONDITION TO EXERCISING THE RIGHTS\n * GRANTED HEREUNDER, EACH USER HEREBY ASSUMES SOLE RESPONSIBILITY TO SECURE\n * ANY OTHER INTELLECTUAL PROPERTY RIGHTS NEEDED, IF ANY.  THE SOFTWARE\n * IS NOT FAULT-TOLERANT AND IS NOT INTENDED FOR USE IN MISSION-CRITICAL\n * SYSTEMS, SUCH AS THOSE USED IN THE OPERATION OF NUCLEAR FACILITIES,\n * AIRCRAFT NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL\n * SYSTEMS, DIRECT LIFE SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH\n * THE FAILURE OF THE SOFTWARE OR SYSTEM COULD LEAD DIRECTLY TO DEATH,\n * PERSONAL INJURY, OR SEVERE PHYSICAL OR ENVIRONMENTAL DAMAGE (\"HIGH\n * RISK ACTIVITIES\").  THE COPYRIGHT HOLDERS SPECIFICALLY DISCLAIM ANY\n * EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR HIGH RISK ACTIVITIES.\n * \n * __END_OF_JASPER_LICENSE__\n */\n\n/*\n * Bit Stream Class\n *\n * $Id$\n */\n\n/******************************************************************************\\\n* Includes.\n\\******************************************************************************/\n\n#include <assert.h>\n#include <stdlib.h>\n#include <stdarg.h>\n\n#include \"jasper/jas_malloc.h\"\n#include \"jasper/jas_math.h\"\n#include \"jasper/jas_debug.h\"\n\n#include \"jpc_bs.h\"\n\n/******************************************************************************\\\n* Local function prototypes.\n\\******************************************************************************/\n\nstatic jpc_bitstream_t *jpc_bitstream_alloc(void);\n\n/******************************************************************************\\\n* Code for opening and closing bit streams.\n\\******************************************************************************/\n\n/* Open a bit stream from a stream. */\njpc_bitstream_t *jpc_bitstream_sopen(jas_stream_t *stream, char *mode)\n{\n\tjpc_bitstream_t *bitstream;\n\n\t/* Ensure that the open mode is valid. */\n#if 0 /* This causes a string literal too long error (with c99 pedantic mode).  Why is this so? */\n\tassert(!strcmp(mode, \"r\") || !strcmp(mode, \"w\") || !strcmp(mode, \"r+\")\n\t  || !strcmp(mode, \"w+\"));\n#endif\n\n\tif (!(bitstream = jpc_bitstream_alloc())) {\n\t\treturn 0;\n\t}\n\n\t/* By default, do not close the underlying (character) stream, upon\n\t  the close of the bit stream. */\n\tbitstream->flags_ = JPC_BITSTREAM_NOCLOSE;\n\n\tbitstream->stream_ = stream;\n\tbitstream->openmode_ = (mode[0] == 'w') ? JPC_BITSTREAM_WRITE :\n\t  JPC_BITSTREAM_READ;\n\n\t/* Mark the data buffer as empty. */\n\tbitstream->cnt_ = (bitstream->openmode_ == JPC_BITSTREAM_READ) ? 0 : 8;\n\tbitstream->buf_ = 0;\n\n\treturn bitstream;\n}\n\n/* Close a bit stream. */\nint jpc_bitstream_close(jpc_bitstream_t *bitstream)\n{\n\tint ret = 0;\n\n\t/* Align to the next byte boundary while considering the effects of\n\t  bit stuffing. */\n\tif (jpc_bitstream_align(bitstream)) {\n\t\tret = -1;\n\t}\n\n\t/* If necessary, close the underlying (character) stream. */\n\tif (!(bitstream->flags_ & JPC_BITSTREAM_NOCLOSE) && bitstream->stream_) {\n\t\tif (jas_stream_close(bitstream->stream_)) {\n\t\t\tret = -1;\n\t\t}\n\t\tbitstream->stream_ = 0;\n\t}\n\n\tjas_free(bitstream);\n\treturn ret;\n}\n\n/* Allocate a new bit stream. */\nstatic jpc_bitstream_t *jpc_bitstream_alloc()\n{\n\tjpc_bitstream_t *bitstream;\n\n\t/* Allocate memory for the new bit stream object. */\n\tif (!(bitstream = jas_malloc(sizeof(jpc_bitstream_t)))) {\n\t\treturn 0;\n\t}\n\t/* Initialize all of the data members. */\n\tbitstream->stream_ = 0;\n\tbitstream->cnt_ = 0;\n\tbitstream->flags_ = 0;\n\tbitstream->openmode_ = 0;\n\n\treturn bitstream;\n}\n\n/******************************************************************************\\\n* Code for reading/writing from/to bit streams.\n\\******************************************************************************/\n\n/* Get a bit from a bit stream. */\nint jpc_bitstream_getbit_func(jpc_bitstream_t *bitstream)\n{\n\tint ret;\n\tJAS_DBGLOG(1000, (\"jpc_bitstream_getbit_func(%p)\\n\", bitstream));\n\tret = jpc_bitstream_getbit_macro(bitstream);\n\tJAS_DBGLOG(1000, (\"jpc_bitstream_getbit_func -> %d\\n\", ret));\n\treturn ret;\n}\n\n/* Put a bit to a bit stream. */\nint jpc_bitstream_putbit_func(jpc_bitstream_t *bitstream, int b)\n{\n\tint ret;\n\tJAS_DBGLOG(1000, (\"jpc_bitstream_putbit_func(%p, %d)\\n\", bitstream, b));\n\tret = jpc_bitstream_putbit_macro(bitstream, b);\n\tJAS_DBGLOG(1000, (\"jpc_bitstream_putbit_func() -> %d\\n\", ret));\n\treturn ret;\n}\n\n/* Get one or more bits from a bit stream. */\nlong jpc_bitstream_getbits(jpc_bitstream_t *bitstream, int n)\n{\n\tlong v;\n\tint u;\n\n\t/* We can reliably get at most 31 bits since ISO/IEC 9899 only\n\t  guarantees that a long can represent values up to 2^31-1. */\n\t//assert(n >= 0 && n < 32);\n\tif (n < 0 || n >= 32) {\n\t\treturn -1;\n\t}\n\n\t/* Get the number of bits requested from the specified bit stream. */\n\tv = 0;\n\twhile (--n >= 0) {\n\t\tif ((u = jpc_bitstream_getbit(bitstream)) < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tv = (v << 1) | u;\n\t}\n\treturn v;\n}\n\n/* Put one or more bits to a bit stream. */\nint jpc_bitstream_putbits(jpc_bitstream_t *bitstream, int n, long v)\n{\n\tint m;\n\n\t/* We can reliably put at most 31 bits since ISO/IEC 9899 only\n\t  guarantees that a long can represent values up to 2^31-1. */\n\t//assert(n >= 0 && n < 32);\n\tif (n < 0 || n >= 32) {\n\t\treturn EOF;\n\t}\n\t/* Ensure that only the bits to be output are nonzero. */\n\tassert(!(v & (~JAS_ONES(n))));\n\n\t/* Put the desired number of bits to the specified bit stream. */\n\tm = n - 1;\n\twhile (--n >= 0) {\n\t\tif (jpc_bitstream_putbit(bitstream, (v >> m) & 1) == EOF) {\n\t\t\treturn EOF;\n\t\t}\n\t\tv <<= 1;\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\\\n* Code for buffer filling and flushing.\n\\******************************************************************************/\n\n/* Fill the buffer for a bit stream. */\nint jpc_bitstream_fillbuf(jpc_bitstream_t *bitstream)\n{\n\tint c;\n\t/* Note: The count has already been decremented by the caller. */\n\tassert(bitstream->openmode_ & JPC_BITSTREAM_READ);\n\tassert(bitstream->cnt_ <= 0);\n\n\tif (bitstream->flags_ & JPC_BITSTREAM_ERR) {\n\t\tbitstream->cnt_ = 0;\n\t\treturn -1;\n\t}\n\n\tif (bitstream->flags_ & JPC_BITSTREAM_EOF) {\n\t\tbitstream->buf_ = 0x7f;\n\t\tbitstream->cnt_ = 7;\n\t\treturn 1;\n\t}\n\n\tbitstream->buf_ = (bitstream->buf_ << 8) & 0xffff;\n\tif ((c = jas_stream_getc((bitstream)->stream_)) == EOF) {\n\t\tbitstream->flags_ |= JPC_BITSTREAM_EOF;\n\t\treturn 1;\n\t}\n\tbitstream->cnt_ = (bitstream->buf_ == 0xff00) ? 6 : 7;\n\tbitstream->buf_ |= c & ((1 << (bitstream->cnt_ + 1)) - 1);\n\treturn (bitstream->buf_ >> bitstream->cnt_) & 1;\n}\n\n\n/******************************************************************************\\\n* Code related to flushing.\n\\******************************************************************************/\n\n/* Does the bit stream need to be aligned to a byte boundary (considering\n  the effects of bit stuffing)? */\nint jpc_bitstream_needalign(jpc_bitstream_t *bitstream)\n{\n\tif (bitstream->openmode_ & JPC_BITSTREAM_READ) {\n\t\t/* The bit stream is open for reading. */\n\t\t/* If there are any bits buffered for reading, or the\n\t\t  previous byte forced a stuffed bit, alignment is\n\t\t  required. */\n\t\tif ((bitstream->cnt_ < 8 && bitstream->cnt_ > 0) ||\n\t\t  ((bitstream->buf_ >> 8) & 0xff) == 0xff) {\n\t\t\treturn 1;\n\t\t}\n\t} else if (bitstream->openmode_ & JPC_BITSTREAM_WRITE) {\n\t\t/* The bit stream is open for writing. */\n\t\t/* If there are any bits buffered for writing, or the\n\t\t  previous byte forced a stuffed bit, alignment is\n\t\t  required. */\n\t\tif ((bitstream->cnt_ < 8 && bitstream->cnt_ >= 0) ||\n\t\t  ((bitstream->buf_ >> 8) & 0xff) == 0xff) {\n\t\t\treturn 1;\n\t\t}\n\t} else {\n\t\t/* This should not happen.  Famous last words, eh? :-) */\n\t\tassert(0);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n/* How many additional bytes would be output if we align the bit stream? */\nint jpc_bitstream_pending(jpc_bitstream_t *bitstream)\n{\n\tif (bitstream->openmode_ & JPC_BITSTREAM_WRITE) {\n\t\t/* The bit stream is being used for writing. */\n#if 1\n\t\t/* XXX - Is this really correct?  Check someday... */\n\t\tif (bitstream->cnt_ < 8) {\n\t\t\treturn 1;\n\t\t}\n#else\n\t\tif (bitstream->cnt_ < 8) {\n\t\t\tif (((bitstream->buf_ >> 8) & 0xff) == 0xff) {\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n#endif\n\t\treturn 0;\n\t} else {\n\t\t/* This operation should not be invoked on a bit stream that\n\t\t  is being used for reading. */\n\t\treturn -1;\n\t}\n}\n\n/* Align the bit stream to a byte boundary. */\nint jpc_bitstream_align(jpc_bitstream_t *bitstream)\n{\n\tint ret;\n\tif (bitstream->openmode_ & JPC_BITSTREAM_READ) {\n\t\tret = jpc_bitstream_inalign(bitstream, 0, 0);\n\t} else if (bitstream->openmode_ & JPC_BITSTREAM_WRITE) {\n\t\tret = jpc_bitstream_outalign(bitstream, 0);\n\t} else {\n\t\tabort();\n\t}\n\treturn ret;\n}\n\n/* Align a bit stream in the input case. */\nint jpc_bitstream_inalign(jpc_bitstream_t *bitstream, int fillmask,\n  int filldata)\n{\n\tint n;\n\tint v;\n\tint u;\n\tint numfill;\n\tint m;\n\n\tnumfill = 7;\n\tm = 0;\n\tv = 0;\n\tif (bitstream->cnt_ > 0) {\n\t\tn = bitstream->cnt_;\n\t} else if (!bitstream->cnt_) {\n\t\tn = ((bitstream->buf_ & 0xff) == 0xff) ? 7 : 0;\n\t} else {\n\t\tn = 0;\n\t}\n\tif (n > 0) {\n\t\tif ((u = jpc_bitstream_getbits(bitstream, n)) < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tm += n;\n\t\tv = (v << n) | u;\n\t}\n\tif ((bitstream->buf_ & 0xff) == 0xff) {\n\t\tif ((u = jpc_bitstream_getbits(bitstream, 7)) < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tv = (v << 7) | u;\n\t\tm += 7;\n\t}\n\tif (m > numfill) {\n\t\tv >>= m - numfill;\n\t} else {\n\t\tfilldata >>= numfill - m;\n\t\tfillmask >>= numfill - m;\n\t}\n\tif (((~(v ^ filldata)) & fillmask) != fillmask) {\n\t\t/* The actual fill pattern does not match the expected one. */\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n/* Align a bit stream in the output case. */\nint jpc_bitstream_outalign(jpc_bitstream_t *bitstream, int filldata)\n{\n\tint n;\n\tint v;\n\n\t/* Ensure that this bit stream is open for writing. */\n\tassert(bitstream->openmode_ & JPC_BITSTREAM_WRITE);\n\n\t/* Ensure that the first bit of fill data is zero. */\n\t/* Note: The first bit of fill data must be zero.  If this were not\n\t  the case, the fill data itself could cause further bit stuffing to\n\t  be required (which would cause numerous complications). */\n\tassert(!(filldata & (~0x3f)));\n\n\tif (!bitstream->cnt_) {\n\t\tif ((bitstream->buf_ & 0xff) == 0xff) {\n\t\t\tn = 7;\n\t\t\tv = filldata;\n\t\t} else {\n\t\t\tn = 0;\n\t\t\tv = 0;\n\t\t}\n\t} else if (bitstream->cnt_ > 0 && bitstream->cnt_ < 8) {\n\t\tn = bitstream->cnt_;\n\t\tv = filldata >> (7 - n);\n\t} else {\n\t\tn = 0;\n\t\tv = 0;\n\t\treturn 0;\n\t}\n\n\t/* Write the appropriate fill data to the bit stream. */\n\tif (n > 0) {\n\t\tif (jpc_bitstream_putbits(bitstream, n, v)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (bitstream->cnt_ < 8) {\n\t\tassert(bitstream->cnt_ >= 0 && bitstream->cnt_ < 8);\n\t\tassert((bitstream->buf_ & 0xff) != 0xff);\n\t\t/* Force the pending byte of output to be written to the\n\t\t  underlying (character) stream. */\n\t\tif (jas_stream_putc(bitstream->stream_, bitstream->buf_ & 0xff) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t\tbitstream->cnt_ = 8;\n\t\tbitstream->buf_ = (bitstream->buf_ << 8) & 0xffff;\n\t}\n\n\treturn 0;\n}\n", "/*\n * Copyright (c) 1999-2000 Image Power, Inc. and the University of\n *   British Columbia.\n * Copyright (c) 2001-2002 Michael David Adams.\n * All rights reserved.\n */\n\n/* __START_OF_JASPER_LICENSE__\n * \n * JasPer License Version 2.0\n * \n * Copyright (c) 2001-2006 Michael David Adams\n * Copyright (c) 1999-2000 Image Power, Inc.\n * Copyright (c) 1999-2000 The University of British Columbia\n * \n * All rights reserved.\n * \n * Permission is hereby granted, free of charge, to any person (the\n * \"User\") obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n * \n * 1.  The above copyright notices and this permission notice (which\n * includes the disclaimer below) shall be included in all copies or\n * substantial portions of the Software.\n * \n * 2.  The name of a copyright holder shall not be used to endorse or\n * promote products derived from the Software without specific prior\n * written permission.\n * \n * THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS\n * LICENSE.  NO USE OF THE SOFTWARE IS AUTHORIZED HEREUNDER EXCEPT UNDER\n * THIS DISCLAIMER.  THE SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS\n * \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.  IN NO\n * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL\n * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING\n * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\n * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION\n * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  NO ASSURANCES ARE\n * PROVIDED BY THE COPYRIGHT HOLDERS THAT THE SOFTWARE DOES NOT INFRINGE\n * THE PATENT OR OTHER INTELLECTUAL PROPERTY RIGHTS OF ANY OTHER ENTITY.\n * EACH COPYRIGHT HOLDER DISCLAIMS ANY LIABILITY TO THE USER FOR CLAIMS\n * BROUGHT BY ANY OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL\n * PROPERTY RIGHTS OR OTHERWISE.  AS A CONDITION TO EXERCISING THE RIGHTS\n * GRANTED HEREUNDER, EACH USER HEREBY ASSUMES SOLE RESPONSIBILITY TO SECURE\n * ANY OTHER INTELLECTUAL PROPERTY RIGHTS NEEDED, IF ANY.  THE SOFTWARE\n * IS NOT FAULT-TOLERANT AND IS NOT INTENDED FOR USE IN MISSION-CRITICAL\n * SYSTEMS, SUCH AS THOSE USED IN THE OPERATION OF NUCLEAR FACILITIES,\n * AIRCRAFT NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL\n * SYSTEMS, DIRECT LIFE SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH\n * THE FAILURE OF THE SOFTWARE OR SYSTEM COULD LEAD DIRECTLY TO DEATH,\n * PERSONAL INJURY, OR SEVERE PHYSICAL OR ENVIRONMENTAL DAMAGE (\"HIGH\n * RISK ACTIVITIES\").  THE COPYRIGHT HOLDERS SPECIFICALLY DISCLAIM ANY\n * EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR HIGH RISK ACTIVITIES.\n * \n * __END_OF_JASPER_LICENSE__\n */\n\n/*\n * JPEG-2000 Code Stream Library\n *\n * $Id$\n */\n\n/******************************************************************************\\\n* Includes.\n\\******************************************************************************/\n\n#include <stdlib.h>\n#include <assert.h>\n#include <ctype.h>\n#include <inttypes.h>\n\n#include \"jasper/jas_malloc.h\"\n#include \"jasper/jas_debug.h\"\n\n#include \"jpc_cs.h\"\n\n/******************************************************************************\\\n* Types.\n\\******************************************************************************/\n\n/* Marker segment table entry. */\ntypedef struct {\n\tint id;\n\tchar *name;\n\tjpc_msops_t ops;\n} jpc_mstabent_t;\n\n/******************************************************************************\\\n* Local prototypes.\n\\******************************************************************************/\n\nstatic jpc_mstabent_t *jpc_mstab_lookup(int id);\n\nstatic int jpc_poc_dumpparms(jpc_ms_t *ms, FILE *out);\nstatic int jpc_poc_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out);\nstatic int jpc_poc_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in);\nstatic void jpc_poc_destroyparms(jpc_ms_t *ms);\n\nstatic int jpc_unk_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in);\nstatic int jpc_sot_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in);\nstatic int jpc_siz_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in);\nstatic int jpc_cod_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in);\nstatic int jpc_coc_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in);\nstatic int jpc_qcd_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in);\nstatic int jpc_qcc_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in);\nstatic int jpc_rgn_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in);\nstatic int jpc_sop_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in);\nstatic int jpc_ppm_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in);\nstatic int jpc_ppt_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in);\nstatic int jpc_crg_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in);\nstatic int jpc_com_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in);\n\nstatic int jpc_sot_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out);\nstatic int jpc_siz_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out);\nstatic int jpc_cod_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out);\nstatic int jpc_coc_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out);\nstatic int jpc_qcd_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out);\nstatic int jpc_qcc_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out);\nstatic int jpc_rgn_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out);\nstatic int jpc_unk_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out);\nstatic int jpc_sop_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out);\nstatic int jpc_ppm_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out);\nstatic int jpc_ppt_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out);\nstatic int jpc_crg_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out);\nstatic int jpc_com_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out);\n\nstatic int jpc_sot_dumpparms(jpc_ms_t *ms, FILE *out);\nstatic int jpc_siz_dumpparms(jpc_ms_t *ms, FILE *out);\nstatic int jpc_cod_dumpparms(jpc_ms_t *ms, FILE *out);\nstatic int jpc_coc_dumpparms(jpc_ms_t *ms, FILE *out);\nstatic int jpc_qcd_dumpparms(jpc_ms_t *ms, FILE *out);\nstatic int jpc_qcc_dumpparms(jpc_ms_t *ms, FILE *out);\nstatic int jpc_rgn_dumpparms(jpc_ms_t *ms, FILE *out);\nstatic int jpc_unk_dumpparms(jpc_ms_t *ms, FILE *out);\nstatic int jpc_sop_dumpparms(jpc_ms_t *ms, FILE *out);\nstatic int jpc_ppm_dumpparms(jpc_ms_t *ms, FILE *out);\nstatic int jpc_ppt_dumpparms(jpc_ms_t *ms, FILE *out);\nstatic int jpc_crg_dumpparms(jpc_ms_t *ms, FILE *out);\nstatic int jpc_com_dumpparms(jpc_ms_t *ms, FILE *out);\n\nstatic void jpc_siz_destroyparms(jpc_ms_t *ms);\nstatic void jpc_qcd_destroyparms(jpc_ms_t *ms);\nstatic void jpc_qcc_destroyparms(jpc_ms_t *ms);\nstatic void jpc_cod_destroyparms(jpc_ms_t *ms);\nstatic void jpc_coc_destroyparms(jpc_ms_t *ms);\nstatic void jpc_unk_destroyparms(jpc_ms_t *ms);\nstatic void jpc_ppm_destroyparms(jpc_ms_t *ms);\nstatic void jpc_ppt_destroyparms(jpc_ms_t *ms);\nstatic void jpc_crg_destroyparms(jpc_ms_t *ms);\nstatic void jpc_com_destroyparms(jpc_ms_t *ms);\n\nstatic void jpc_qcx_destroycompparms(jpc_qcxcp_t *compparms);\nstatic int jpc_qcx_getcompparms(jpc_qcxcp_t *compparms, jpc_cstate_t *cstate,\n  jas_stream_t *in, uint_fast16_t len);\nstatic int jpc_qcx_putcompparms(jpc_qcxcp_t *compparms, jpc_cstate_t *cstate,\n  jas_stream_t *out);\nstatic void jpc_cox_destroycompparms(jpc_coxcp_t *compparms);\nstatic int jpc_cox_getcompparms(jpc_ms_t *ms, jpc_cstate_t *cstate,\n  jas_stream_t *in, int prtflag, jpc_coxcp_t *compparms);\nstatic int jpc_cox_putcompparms(jpc_ms_t *ms, jpc_cstate_t *cstate,\n  jas_stream_t *out, int prtflag, jpc_coxcp_t *compparms);\n\n/******************************************************************************\\\n* Global data.\n\\******************************************************************************/\n\nstatic jpc_mstabent_t jpc_mstab[] = {\n\t{JPC_MS_SOC, \"SOC\", {0, 0, 0, 0}},\n\t{JPC_MS_SOT, \"SOT\", {0, jpc_sot_getparms, jpc_sot_putparms,\n\t  jpc_sot_dumpparms}},\n\t{JPC_MS_SOD, \"SOD\", {0, 0, 0, 0}},\n\t{JPC_MS_EOC, \"EOC\", {0, 0, 0, 0}},\n\t{JPC_MS_SIZ, \"SIZ\", {jpc_siz_destroyparms, jpc_siz_getparms,\n\t  jpc_siz_putparms, jpc_siz_dumpparms}},\n\t{JPC_MS_COD, \"COD\", {jpc_cod_destroyparms, jpc_cod_getparms,\n\t  jpc_cod_putparms, jpc_cod_dumpparms}},\n\t{JPC_MS_COC, \"COC\", {jpc_coc_destroyparms, jpc_coc_getparms,\n\t  jpc_coc_putparms, jpc_coc_dumpparms}},\n\t{JPC_MS_RGN, \"RGN\", {0, jpc_rgn_getparms, jpc_rgn_putparms,\n\t  jpc_rgn_dumpparms}},\n\t{JPC_MS_QCD, \"QCD\", {jpc_qcd_destroyparms, jpc_qcd_getparms,\n\t  jpc_qcd_putparms, jpc_qcd_dumpparms}},\n\t{JPC_MS_QCC, \"QCC\", {jpc_qcc_destroyparms, jpc_qcc_getparms,\n\t  jpc_qcc_putparms, jpc_qcc_dumpparms}},\n\t{JPC_MS_POC, \"POC\", {jpc_poc_destroyparms, jpc_poc_getparms,\n\t  jpc_poc_putparms, jpc_poc_dumpparms}},\n\t{JPC_MS_TLM, \"TLM\", {0, jpc_unk_getparms, jpc_unk_putparms, 0}},\n\t{JPC_MS_PLM, \"PLM\", {0, jpc_unk_getparms, jpc_unk_putparms, 0}},\n\t{JPC_MS_PPM, \"PPM\", {jpc_ppm_destroyparms, jpc_ppm_getparms,\n\t  jpc_ppm_putparms, jpc_ppm_dumpparms}},\n\t{JPC_MS_PPT, \"PPT\", {jpc_ppt_destroyparms, jpc_ppt_getparms,\n\t  jpc_ppt_putparms, jpc_ppt_dumpparms}},\n\t{JPC_MS_SOP, \"SOP\", {0, jpc_sop_getparms, jpc_sop_putparms,\n\t  jpc_sop_dumpparms}},\n\t{JPC_MS_EPH, \"EPH\", {0, 0, 0, 0}},\n\t{JPC_MS_CRG, \"CRG\", {jpc_crg_destroyparms, jpc_crg_getparms,\n\t  jpc_crg_putparms, jpc_crg_dumpparms}},\n\t{JPC_MS_COM, \"COM\", {jpc_com_destroyparms, jpc_com_getparms,\n\t  jpc_com_putparms, jpc_com_dumpparms}},\n\t{-1, \"UNKNOWN\",  {jpc_unk_destroyparms, jpc_unk_getparms,\n\t  jpc_unk_putparms, jpc_unk_dumpparms}}\n};\n\n/******************************************************************************\\\n* Code stream manipulation functions.\n\\******************************************************************************/\n\n/* Create a code stream state object. */\njpc_cstate_t *jpc_cstate_create()\n{\n\tjpc_cstate_t *cstate;\n\tif (!(cstate = jas_malloc(sizeof(jpc_cstate_t)))) {\n\t\treturn 0;\n\t}\n\tcstate->numcomps = 0;\n\treturn cstate;\n}\n\n/* Destroy a code stream state object. */\nvoid jpc_cstate_destroy(jpc_cstate_t *cstate)\n{\n\tjas_free(cstate);\n}\n\n/* Read a marker segment from a stream. */\njpc_ms_t *jpc_getms(jas_stream_t *in, jpc_cstate_t *cstate)\n{\n\tjpc_ms_t *ms;\n\tjpc_mstabent_t *mstabent;\n\tjas_stream_t *tmpstream;\n\n\tif (!(ms = jpc_ms_create(0))) {\n\t\treturn 0;\n\t}\n\n\t/* Get the marker type. */\n\tif (jpc_getuint16(in, &ms->id) || ms->id < JPC_MS_MIN ||\n\t  ms->id > JPC_MS_MAX) {\n\t\tjpc_ms_destroy(ms);\n\t\treturn 0;\n\t}\n\n\tmstabent = jpc_mstab_lookup(ms->id);\n\tms->ops = &mstabent->ops;\n\n\t/* Get the marker segment length and parameters if present. */\n\t/* Note: It is tacitly assumed that a marker segment cannot have\n\t  parameters unless it has a length field.  That is, there cannot\n\t  be a parameters field without a length field and vice versa. */\n\tif (JPC_MS_HASPARMS(ms->id)) {\n\t\t/* Get the length of the marker segment. */\n\t\tif (jpc_getuint16(in, &ms->len) || ms->len < 3) {\n\t\t\tjpc_ms_destroy(ms);\n\t\t\treturn 0;\n\t\t}\n\t\t/* Calculate the length of the marker segment parameters. */\n\t\tms->len -= 2;\n\t\t/* Create and prepare a temporary memory stream from which to\n\t\t  read the marker segment parameters. */\n\t\t/* Note: This approach provides a simple way of ensuring that\n\t\t  we never read beyond the end of the marker segment (even if\n\t\t  the marker segment length is errantly set too small). */\n\t\tif (!(tmpstream = jas_stream_memopen(0, 0))) {\n\t\t\tjpc_ms_destroy(ms);\n\t\t\treturn 0;\n\t\t}\n\t\tif (jas_stream_copy(tmpstream, in, ms->len) ||\n\t\t  jas_stream_seek(tmpstream, 0, SEEK_SET) < 0) {\n\t\t\tjas_stream_close(tmpstream);\n\t\t\tjpc_ms_destroy(ms);\n\t\t\treturn 0;\n\t\t}\n\t\t/* Get the marker segment parameters. */\n\t\tif ((*ms->ops->getparms)(ms, cstate, tmpstream)) {\n\t\t\tms->ops = 0;\n\t\t\tjpc_ms_destroy(ms);\n\t\t\tjas_stream_close(tmpstream);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (jas_getdbglevel() > 0) {\n\t\t\tjpc_ms_dump(ms, stderr);\n\t\t}\n\n\t\tif (JAS_CAST(ulong, jas_stream_tell(tmpstream)) != ms->len) {\n\t\t\tjas_eprintf(\"warning: trailing garbage in marker segment (%ld bytes)\\n\",\n\t\t\t  ms->len - jas_stream_tell(tmpstream));\n\t\t}\n\n\t\t/* Close the temporary stream. */\n\t\tjas_stream_close(tmpstream);\n\n\t} else {\n\t\t/* There are no marker segment parameters. */\n\t\tms->len = 0;\n\n\t\tif (jas_getdbglevel() > 0) {\n\t\t\tjpc_ms_dump(ms, stderr);\n\t\t}\n\t}\n\n\t/* Update the code stream state information based on the type of\n\t  marker segment read. */\n\t/* Note: This is a bit of a hack, but I'm not going to define another\n\t  type of virtual function for this one special case. */\n\tif (ms->id == JPC_MS_SIZ) {\n\t\tcstate->numcomps = ms->parms.siz.numcomps;\n\t}\n\n\treturn ms;\n}\n\n/* Write a marker segment to a stream. */\nint jpc_putms(jas_stream_t *out, jpc_cstate_t *cstate, jpc_ms_t *ms)\n{\n\tjas_stream_t *tmpstream;\n\tint len;\n\n\t/* Output the marker segment type. */\n\tif (jpc_putuint16(out, ms->id)) {\n\t\treturn -1;\n\t}\n\n\t/* Output the marker segment length and parameters if necessary. */\n\tif (ms->ops->putparms) {\n\t\t/* Create a temporary stream in which to buffer the\n\t\t  parameter data. */\n\t\tif (!(tmpstream = jas_stream_memopen(0, 0))) {\n\t\t\treturn -1;\n\t\t}\n\t\tif ((*ms->ops->putparms)(ms, cstate, tmpstream)) {\n\t\t\tjas_stream_close(tmpstream);\n\t\t\treturn -1;\n\t\t}\n\t\t/* Get the number of bytes of parameter data written. */\n\t\tif ((len = jas_stream_tell(tmpstream)) < 0) {\n\t\t\tjas_stream_close(tmpstream);\n\t\t\treturn -1;\n\t\t}\n\t\tms->len = len;\n\t\t/* Write the marker segment length and parameter data to\n\t\t  the output stream. */\n\t\tif (jas_stream_seek(tmpstream, 0, SEEK_SET) < 0 ||\n\t\t  jpc_putuint16(out, ms->len + 2) ||\n\t\t  jas_stream_copy(out, tmpstream, ms->len) < 0) {\n\t\t\tjas_stream_close(tmpstream);\n\t\t\treturn -1;\n\t\t}\n\t\t/* Close the temporary stream. */\n\t\tjas_stream_close(tmpstream);\n\t}\n\n\t/* This is a bit of a hack, but I'm not going to define another\n\t  type of virtual function for this one special case. */\n\tif (ms->id == JPC_MS_SIZ) {\n\t\tcstate->numcomps = ms->parms.siz.numcomps;\n\t}\n\n\tif (jas_getdbglevel() > 0) {\n\t\tjpc_ms_dump(ms, stderr);\n\t}\n\n\treturn 0;\n}\n\n/******************************************************************************\\\n* Marker segment operations.\n\\******************************************************************************/\n\n/* Create a marker segment of the specified type. */\njpc_ms_t *jpc_ms_create(int type)\n{\n\tjpc_ms_t *ms;\n\tjpc_mstabent_t *mstabent;\n\n\tif (!(ms = jas_malloc(sizeof(jpc_ms_t)))) {\n\t\treturn 0;\n\t}\n\tms->id = type;\n\tms->len = 0;\n\tmstabent = jpc_mstab_lookup(ms->id);\n\tms->ops = &mstabent->ops;\n\tmemset(&ms->parms, 0, sizeof(jpc_msparms_t));\n\treturn ms;\n}\n\n/* Destroy a marker segment. */\nvoid jpc_ms_destroy(jpc_ms_t *ms)\n{\n\tif (ms->ops && ms->ops->destroyparms) {\n\t\t(*ms->ops->destroyparms)(ms);\n\t}\n\tjas_free(ms);\n}\n\n/* Dump a marker segment to a stream for debugging. */\nvoid jpc_ms_dump(jpc_ms_t *ms, FILE *out)\n{\n\tjpc_mstabent_t *mstabent;\n\tmstabent = jpc_mstab_lookup(ms->id);\n\tfprintf(out, \"type = 0x%04\"PRIxFAST16\" (%s);\", ms->id, mstabent->name);\n\tif (JPC_MS_HASPARMS(ms->id)) {\n\t\tfprintf(out, \" len = %\"PRIuFAST16\";\", ms->len + 2);\n\t\tif (ms->ops->dumpparms) {\n\t\t\t(*ms->ops->dumpparms)(ms, out);\n\t\t} else {\n\t\t\tfprintf(out, \"\\n\");\n\t\t}\n\t} else {\n\t\tfprintf(out, \"\\n\");\n\t}\n}\n\n/******************************************************************************\\\n* SOT marker segment operations.\n\\******************************************************************************/\n\nstatic int jpc_sot_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in)\n{\n\tjpc_sot_t *sot = &ms->parms.sot;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tcstate = 0;\n\n\tif (jpc_getuint16(in, &sot->tileno) ||\n\t  jpc_getuint32(in, &sot->len) ||\n\t  jpc_getuint8(in, &sot->partno) ||\n\t  jpc_getuint8(in, &sot->numparts)) {\n\t\treturn -1;\n\t}\n\tif (sot->tileno > 65534 || sot->len < 12 || sot->partno > 254 ||\n\t  sot->numparts < 1 || sot->numparts > 255) {\n\t\treturn -1;\n\t}\n\tif (jas_stream_eof(in)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_sot_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out)\n{\n\tjpc_sot_t *sot = &ms->parms.sot;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tcstate = 0;\n\n\tif (jpc_putuint16(out, sot->tileno) ||\n\t  jpc_putuint32(out, sot->len) ||\n\t  jpc_putuint8(out, sot->partno) ||\n\t  jpc_putuint8(out, sot->numparts)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_sot_dumpparms(jpc_ms_t *ms, FILE *out)\n{\n\tjpc_sot_t *sot = &ms->parms.sot;\n\tfprintf(out,\n\t  \"tileno = %\"PRIuFAST16\"; len = %\"PRIuFAST32\"; partno = %d; numparts = %d\\n\",\n\t  sot->tileno, sot->len, sot->partno, sot->numparts);\n\treturn 0;\n}\n\n/******************************************************************************\\\n* SIZ marker segment operations.\n\\******************************************************************************/\n\nstatic void jpc_siz_destroyparms(jpc_ms_t *ms)\n{\n\tjpc_siz_t *siz = &ms->parms.siz;\n\tif (siz->comps) {\n\t\tjas_free(siz->comps);\n\t}\n}\n\nstatic int jpc_siz_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate,\n  jas_stream_t *in)\n{\n\tjpc_siz_t *siz = &ms->parms.siz;\n\tunsigned int i;\n\tuint_fast8_t tmp;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tcstate = 0;\n\n\tif (jpc_getuint16(in, &siz->caps) ||\n\t  jpc_getuint32(in, &siz->width) ||\n\t  jpc_getuint32(in, &siz->height) ||\n\t  jpc_getuint32(in, &siz->xoff) ||\n\t  jpc_getuint32(in, &siz->yoff) ||\n\t  jpc_getuint32(in, &siz->tilewidth) ||\n\t  jpc_getuint32(in, &siz->tileheight) ||\n\t  jpc_getuint32(in, &siz->tilexoff) ||\n\t  jpc_getuint32(in, &siz->tileyoff) ||\n\t  jpc_getuint16(in, &siz->numcomps)) {\n\t\treturn -1;\n\t}\n\tif (!siz->width || !siz->height || !siz->tilewidth ||\n\t  !siz->tileheight || !siz->numcomps || siz->numcomps > 16384) {\n\t\treturn -1;\n\t}\n\tif (!(siz->comps = jas_alloc2(siz->numcomps, sizeof(jpc_sizcomp_t)))) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < siz->numcomps; ++i) {\n\t\tif (jpc_getuint8(in, &tmp) ||\n\t\t  jpc_getuint8(in, &siz->comps[i].hsamp) ||\n\t\t  jpc_getuint8(in, &siz->comps[i].vsamp)) {\n\t\t\tjas_free(siz->comps);\n\t\t\treturn -1;\n\t\t}\n\t\tif (siz->comps[i].hsamp == 0 || siz->comps[i].hsamp > 255) {\n\t\t\tjas_eprintf(\"invalid XRsiz value %d\\n\", siz->comps[i].hsamp);\n\t\t\tjas_free(siz->comps);\n\t\t\treturn -1;\n\t\t}\n\t\tif (siz->comps[i].vsamp == 0 || siz->comps[i].vsamp > 255) {\n\t\t\tjas_eprintf(\"invalid YRsiz value %d\\n\", siz->comps[i].vsamp);\n\t\t\tjas_free(siz->comps);\n\t\t\treturn -1;\n\t\t}\n\t\tsiz->comps[i].sgnd = (tmp >> 7) & 1;\n\t\tsiz->comps[i].prec = (tmp & 0x7f) + 1;\n\t}\n\tif (jas_stream_eof(in)) {\n\t\tjas_free(siz->comps);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_siz_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out)\n{\n\tjpc_siz_t *siz = &ms->parms.siz;\n\tunsigned int i;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tcstate = 0;\n\n\tassert(siz->width && siz->height && siz->tilewidth &&\n\t  siz->tileheight && siz->numcomps);\n\tif (jpc_putuint16(out, siz->caps) ||\n\t  jpc_putuint32(out, siz->width) ||\n\t  jpc_putuint32(out, siz->height) ||\n\t  jpc_putuint32(out, siz->xoff) ||\n\t  jpc_putuint32(out, siz->yoff) ||\n\t  jpc_putuint32(out, siz->tilewidth) ||\n\t  jpc_putuint32(out, siz->tileheight) ||\n\t  jpc_putuint32(out, siz->tilexoff) ||\n\t  jpc_putuint32(out, siz->tileyoff) ||\n\t  jpc_putuint16(out, siz->numcomps)) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < siz->numcomps; ++i) {\n\t\tif (jpc_putuint8(out, ((siz->comps[i].sgnd & 1) << 7) |\n\t\t  ((siz->comps[i].prec - 1) & 0x7f)) ||\n\t\t  jpc_putuint8(out, siz->comps[i].hsamp) ||\n\t\t  jpc_putuint8(out, siz->comps[i].vsamp)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int jpc_siz_dumpparms(jpc_ms_t *ms, FILE *out)\n{\n\tjpc_siz_t *siz = &ms->parms.siz;\n\tunsigned int i;\n\tfprintf(out, \"caps = 0x%02\"PRIxFAST16\";\\n\", siz->caps);\n\tfprintf(out, \"width = %\"PRIuFAST32\"; height = %\"PRIuFAST32\"; xoff = %\"PRIuFAST32\"; yoff = %\" PRIuFAST32 \";\\n\",\n\t  siz->width, siz->height, siz->xoff, siz->yoff);\n\tfprintf(out, \"tilewidth = %\"PRIuFAST32\"; tileheight = %\"PRIuFAST32\"; \"\n\t  \"tilexoff = %\"PRIuFAST32\"; tileyoff = %\" PRIuFAST32 \";\\n\",\n\t  siz->tilewidth, siz->tileheight, siz->tilexoff, siz->tileyoff);\n\tfprintf(out, \"numcomps = %\"PRIuFAST16\";\\n\", siz->numcomps);\n\tfor (i = 0; i < siz->numcomps; ++i) {\n\t\tfprintf(out, \"prec[%d] = %d; sgnd[%d] = %d; hsamp[%d] = %d; \"\n\t\t  \"vsamp[%d] = %d\\n\", i, siz->comps[i].prec, i,\n\t\t  siz->comps[i].sgnd, i, siz->comps[i].hsamp, i,\n\t\t  siz->comps[i].vsamp);\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\\\n* COD marker segment operations.\n\\******************************************************************************/\n\nstatic void jpc_cod_destroyparms(jpc_ms_t *ms)\n{\n\tjpc_cod_t *cod = &ms->parms.cod;\n\tjpc_cox_destroycompparms(&cod->compparms);\n}\n\nstatic int jpc_cod_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in)\n{\n\tjpc_cod_t *cod = &ms->parms.cod;\n\tif (jpc_getuint8(in, &cod->csty)) {\n\t\treturn -1;\n\t}\n\tif (jpc_getuint8(in, &cod->prg) ||\n\t  jpc_getuint16(in, &cod->numlyrs) ||\n\t  jpc_getuint8(in, &cod->mctrans)) {\n\t\treturn -1;\n\t}\n\tif (cod->numlyrs < 1 || cod->numlyrs > 65535) {\n\t\treturn -1;\n\t}\n\tif (jpc_cox_getcompparms(ms, cstate, in,\n\t  (cod->csty & JPC_COX_PRT) != 0, &cod->compparms)) {\n\t\treturn -1;\n\t}\n\tif (jas_stream_eof(in)) {\n\t\tjpc_cod_destroyparms(ms);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_cod_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out)\n{\n\tjpc_cod_t *cod = &ms->parms.cod;\n\tassert(cod->numlyrs > 0 && cod->compparms.numdlvls <= 32);\n\tassert(cod->compparms.numdlvls == cod->compparms.numrlvls - 1);\n\tif (jpc_putuint8(out, cod->compparms.csty) ||\n\t  jpc_putuint8(out, cod->prg) ||\n\t  jpc_putuint16(out, cod->numlyrs) ||\n\t  jpc_putuint8(out, cod->mctrans)) {\n\t\treturn -1;\n\t}\n\tif (jpc_cox_putcompparms(ms, cstate, out,\n\t  (cod->csty & JPC_COX_PRT) != 0, &cod->compparms)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_cod_dumpparms(jpc_ms_t *ms, FILE *out)\n{\n\tjpc_cod_t *cod = &ms->parms.cod;\n\tint i;\n\tfprintf(out, \"csty = 0x%02x;\\n\", cod->compparms.csty);\n\tfprintf(out, \"numdlvls = %d; qmfbid = %d; mctrans = %d\\n\",\n\t  cod->compparms.numdlvls, cod->compparms.qmfbid, cod->mctrans);\n\tfprintf(out, \"prg = %d; numlyrs = %\"PRIuFAST16\";\\n\",\n\t  cod->prg, cod->numlyrs);\n\tfprintf(out, \"cblkwidthval = %d; cblkheightval = %d; \"\n\t  \"cblksty = 0x%02x;\\n\", cod->compparms.cblkwidthval, cod->compparms.cblkheightval,\n\t  cod->compparms.cblksty);\n\tif (cod->csty & JPC_COX_PRT) {\n\t\tfor (i = 0; i < cod->compparms.numrlvls; ++i) {\n\t\t\tjas_eprintf(\"prcwidth[%d] = %d, prcheight[%d] = %d\\n\",\n\t\t\t  i, cod->compparms.rlvls[i].parwidthval,\n\t\t\t  i, cod->compparms.rlvls[i].parheightval);\n\t\t}\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\\\n* COC marker segment operations.\n\\******************************************************************************/\n\nstatic void jpc_coc_destroyparms(jpc_ms_t *ms)\n{\n\tjpc_coc_t *coc = &ms->parms.coc;\n\tjpc_cox_destroycompparms(&coc->compparms);\n}\n\nstatic int jpc_coc_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in)\n{\n\tjpc_coc_t *coc = &ms->parms.coc;\n\tuint_fast8_t tmp;\n\tif (cstate->numcomps <= 256) {\n\t\tif (jpc_getuint8(in, &tmp)) {\n\t\t\treturn -1;\n\t\t}\n\t\tcoc->compno = tmp;\n\t} else {\n\t\tif (jpc_getuint16(in, &coc->compno)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (jpc_getuint8(in, &coc->compparms.csty)) {\n\t\treturn -1;\n\t}\n\tif (jpc_cox_getcompparms(ms, cstate, in,\n\t  (coc->compparms.csty & JPC_COX_PRT) != 0, &coc->compparms)) {\n\t\treturn -1;\n\t}\n\tif (jas_stream_eof(in)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_coc_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out)\n{\n\tjpc_coc_t *coc = &ms->parms.coc;\n\tassert(coc->compparms.numdlvls <= 32);\n\tif (cstate->numcomps <= 256) {\n\t\tif (jpc_putuint8(out, coc->compno)) {\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\tif (jpc_putuint16(out, coc->compno)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (jpc_putuint8(out, coc->compparms.csty)) {\n\t\treturn -1;\n\t}\n\tif (jpc_cox_putcompparms(ms, cstate, out,\n\t  (coc->compparms.csty & JPC_COX_PRT) != 0, &coc->compparms)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_coc_dumpparms(jpc_ms_t *ms, FILE *out)\n{\n\tjpc_coc_t *coc = &ms->parms.coc;\n\tfprintf(out, \"compno = %\"PRIuFAST16\"; csty = 0x%02x; numdlvls = %d;\\n\",\n\t  coc->compno, coc->compparms.csty, coc->compparms.numdlvls);\n\tfprintf(out, \"cblkwidthval = %d; cblkheightval = %d; \"\n\t  \"cblksty = 0x%02x; qmfbid = %d;\\n\", coc->compparms.cblkwidthval,\n\t  coc->compparms.cblkheightval, coc->compparms.cblksty, coc->compparms.qmfbid);\n\treturn 0;\n}\n/******************************************************************************\\\n* COD/COC marker segment operation helper functions.\n\\******************************************************************************/\n\nstatic void jpc_cox_destroycompparms(jpc_coxcp_t *compparms)\n{\n\t/* Eliminate compiler warning about unused variables. */\n\tcompparms = 0;\n}\n\nstatic int jpc_cox_getcompparms(jpc_ms_t *ms, jpc_cstate_t *cstate,\n  jas_stream_t *in, int prtflag, jpc_coxcp_t *compparms)\n{\n\tuint_fast8_t tmp;\n\tint i;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tms = 0;\n\tcstate = 0;\n\n\tif (jpc_getuint8(in, &compparms->numdlvls) ||\n\t  jpc_getuint8(in, &compparms->cblkwidthval) ||\n\t  jpc_getuint8(in, &compparms->cblkheightval) ||\n\t  jpc_getuint8(in, &compparms->cblksty) ||\n\t  jpc_getuint8(in, &compparms->qmfbid)) {\n\t\treturn -1;\n\t}\n\tif (compparms->numdlvls > 32) {\n\t\tgoto error;\n\t}\n\tcompparms->numrlvls = compparms->numdlvls + 1;\n\tif (compparms->numrlvls > JPC_MAXRLVLS) {\n\t\tgoto error;\n\t}\n\tif (prtflag) {\n\t\tfor (i = 0; i < compparms->numrlvls; ++i) {\n\t\t\tif (jpc_getuint8(in, &tmp)) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tcompparms->rlvls[i].parwidthval = tmp & 0xf;\n\t\t\tcompparms->rlvls[i].parheightval = (tmp >> 4) & 0xf;\n\t\t}\n\t\t/* Sigh.\n\t\tThis bit should be in the same field in both COC and COD mrk segs. */\n\t\tcompparms->csty |= JPC_COX_PRT;\n\t}\n\tif (jas_stream_eof(in)) {\n\t\tgoto error;\n\t}\n\treturn 0;\nerror:\n\tif (compparms) {\n\t\tjpc_cox_destroycompparms(compparms);\n\t}\n\treturn -1;\n}\n\nstatic int jpc_cox_putcompparms(jpc_ms_t *ms, jpc_cstate_t *cstate,\n  jas_stream_t *out, int prtflag, jpc_coxcp_t *compparms)\n{\n\tint i;\n\tassert(compparms->numdlvls <= 32);\n\n\t/* Eliminate compiler warning about unused variables. */\n\tms = 0;\n\tcstate = 0;\n\n\tif (jpc_putuint8(out, compparms->numdlvls) ||\n\t  jpc_putuint8(out, compparms->cblkwidthval) ||\n\t  jpc_putuint8(out, compparms->cblkheightval) ||\n\t  jpc_putuint8(out, compparms->cblksty) ||\n\t  jpc_putuint8(out, compparms->qmfbid)) {\n\t\treturn -1;\n\t}\n\tif (prtflag) {\n\t\tfor (i = 0; i < compparms->numrlvls; ++i) {\n\t\t\tif (jpc_putuint8(out,\n\t\t\t  ((compparms->rlvls[i].parheightval & 0xf) << 4) |\n\t\t\t  (compparms->rlvls[i].parwidthval & 0xf))) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\\\n* RGN marker segment operations.\n\\******************************************************************************/\n\nstatic int jpc_rgn_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in)\n{\n\tjpc_rgn_t *rgn = &ms->parms.rgn;\n\tuint_fast8_t tmp;\n\tif (cstate->numcomps <= 256) {\n\t\tif (jpc_getuint8(in, &tmp)) {\n\t\t\treturn -1;\n\t\t}\n\t\trgn->compno = tmp;\n\t} else {\n\t\tif (jpc_getuint16(in, &rgn->compno)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (jpc_getuint8(in, &rgn->roisty) ||\n\t  jpc_getuint8(in, &rgn->roishift)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_rgn_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out)\n{\n\tjpc_rgn_t *rgn = &ms->parms.rgn;\n\tif (cstate->numcomps <= 256) {\n\t\tif (jpc_putuint8(out, rgn->compno)) {\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\tif (jpc_putuint16(out, rgn->compno)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (jpc_putuint8(out, rgn->roisty) ||\n\t  jpc_putuint8(out, rgn->roishift)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_rgn_dumpparms(jpc_ms_t *ms, FILE *out)\n{\n\tjpc_rgn_t *rgn = &ms->parms.rgn;\n\tfprintf(out, \"compno = %\"PRIuFAST16\"; roisty = %d; roishift = %d\\n\",\n\t  rgn->compno, rgn->roisty, rgn->roishift);\n\treturn 0;\n}\n\n/******************************************************************************\\\n* QCD marker segment operations.\n\\******************************************************************************/\n\nstatic void jpc_qcd_destroyparms(jpc_ms_t *ms)\n{\n\tjpc_qcd_t *qcd = &ms->parms.qcd;\n\tjpc_qcx_destroycompparms(&qcd->compparms);\n}\n\nstatic int jpc_qcd_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in)\n{\n\tjpc_qcxcp_t *compparms = &ms->parms.qcd.compparms;\n\treturn jpc_qcx_getcompparms(compparms, cstate, in, ms->len);\n}\n\nstatic int jpc_qcd_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out)\n{\n\tjpc_qcxcp_t *compparms = &ms->parms.qcd.compparms;\n\treturn jpc_qcx_putcompparms(compparms, cstate, out);\n}\n\nstatic int jpc_qcd_dumpparms(jpc_ms_t *ms, FILE *out)\n{\n\tjpc_qcd_t *qcd = &ms->parms.qcd;\n\tint i;\n\tfprintf(out, \"qntsty = %d; numguard = %d; numstepsizes = %d\\n\",\n\t  (int) qcd->compparms.qntsty, qcd->compparms.numguard, qcd->compparms.numstepsizes);\n\tfor (i = 0; i < qcd->compparms.numstepsizes; ++i) {\n\t\tfprintf(out, \"expn[%d] = 0x%04x; mant[%d] = 0x%04x;\\n\",\n\t\t  i, JAS_CAST(unsigned, JPC_QCX_GETEXPN(qcd->compparms.stepsizes[i])),\n\t\t  i, JAS_CAST(unsigned, JPC_QCX_GETMANT(qcd->compparms.stepsizes[i])));\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\\\n* QCC marker segment operations.\n\\******************************************************************************/\n\nstatic void jpc_qcc_destroyparms(jpc_ms_t *ms)\n{\n\tjpc_qcc_t *qcc = &ms->parms.qcc;\n\tjpc_qcx_destroycompparms(&qcc->compparms);\n}\n\nstatic int jpc_qcc_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in)\n{\n\tjpc_qcc_t *qcc = &ms->parms.qcc;\n\tuint_fast8_t tmp;\n\tint len;\n\tlen = ms->len;\n\tif (cstate->numcomps <= 256) {\n\t\tif (jpc_getuint8(in, &tmp)) {\n\t\t\treturn -1;\n\t\t}\n\t\tqcc->compno = tmp;\n\t\t--len;\n\t} else {\n\t\tif (jpc_getuint16(in, &qcc->compno)) {\n\t\t\treturn -1;\n\t\t}\n\t\tlen -= 2;\n\t}\n\tif (jpc_qcx_getcompparms(&qcc->compparms, cstate, in, len)) {\n\t\treturn -1;\n\t}\n\tif (jas_stream_eof(in)) {\n\t\tjpc_qcc_destroyparms(ms);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_qcc_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out)\n{\n\tjpc_qcc_t *qcc = &ms->parms.qcc;\n\tif (cstate->numcomps <= 256) {\n\t\tif (jpc_putuint8(out, qcc->compno)) {\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\tif (jpc_putuint16(out, qcc->compno)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (jpc_qcx_putcompparms(&qcc->compparms, cstate, out)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_qcc_dumpparms(jpc_ms_t *ms, FILE *out)\n{\n\tjpc_qcc_t *qcc = &ms->parms.qcc;\n\tint i;\n\tfprintf(out, \"compno = %\"PRIuFAST16\"; qntsty = %d; numguard = %d; \"\n\t  \"numstepsizes = %d\\n\", qcc->compno, qcc->compparms.qntsty, qcc->compparms.numguard,\n\t  qcc->compparms.numstepsizes);\n\tfor (i = 0; i < qcc->compparms.numstepsizes; ++i) {\n\t\tfprintf(out, \"expn[%d] = 0x%04x; mant[%d] = 0x%04x;\\n\",\n\t\t  i, (unsigned) JPC_QCX_GETEXPN(qcc->compparms.stepsizes[i]),\n\t\t  i, (unsigned) JPC_QCX_GETMANT(qcc->compparms.stepsizes[i]));\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\\\n* QCD/QCC marker segment helper functions.\n\\******************************************************************************/\n\nstatic void jpc_qcx_destroycompparms(jpc_qcxcp_t *compparms)\n{\n\tif (compparms->stepsizes) {\n\t\tjas_free(compparms->stepsizes);\n\t}\n}\n\nstatic int jpc_qcx_getcompparms(jpc_qcxcp_t *compparms, jpc_cstate_t *cstate,\n  jas_stream_t *in, uint_fast16_t len)\n{\n\tuint_fast8_t tmp;\n\tint n;\n\tint i;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tcstate = 0;\n\n\tn = 0;\n\tif (jpc_getuint8(in, &tmp)) {\n\t\treturn -1;\n\t}\n\t++n;\n\tcompparms->qntsty = tmp & 0x1f;\n\tcompparms->numguard = (tmp >> 5) & 7;\n\tswitch (compparms->qntsty) {\n\tcase JPC_QCX_SIQNT:\n\t\tcompparms->numstepsizes = 1;\n\t\tbreak;\n\tcase JPC_QCX_NOQNT:\n\t\tcompparms->numstepsizes = (len - n);\n\t\tbreak;\n\tcase JPC_QCX_SEQNT:\n\t\t/* XXX - this is a hack */\n\t\tcompparms->numstepsizes = (len - n) / 2;\n\t\tbreak;\n\t}\n\t/* Ensure that the step size array is sufficiently large. */\n\tif (compparms->numstepsizes > 3 * JPC_MAXRLVLS + 1) {\n\t\tjpc_qcx_destroycompparms(compparms);\n\t\treturn -1;\n\t}\n\tif (compparms->numstepsizes > 0) {\n\t\tif (!(compparms->stepsizes = jas_alloc2(compparms->numstepsizes,\n\t\t  sizeof(uint_fast16_t)))) {\n\t\t\tabort();\n\t\t}\n\t\tfor (i = 0; i < compparms->numstepsizes; ++i) {\n\t\t\tif (compparms->qntsty == JPC_QCX_NOQNT) {\n\t\t\t\tif (jpc_getuint8(in, &tmp)) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tcompparms->stepsizes[i] = JPC_QCX_EXPN(tmp >> 3);\n\t\t\t} else {\n\t\t\t\tif (jpc_getuint16(in, &compparms->stepsizes[i])) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tcompparms->stepsizes = 0;\n\t}\n\tif (jas_stream_error(in) || jas_stream_eof(in)) {\n\t\tjpc_qcx_destroycompparms(compparms);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_qcx_putcompparms(jpc_qcxcp_t *compparms, jpc_cstate_t *cstate,\n  jas_stream_t *out)\n{\n\tint i;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tcstate = 0;\n\n\tjpc_putuint8(out, ((compparms->numguard & 7) << 5) | compparms->qntsty);\n\tfor (i = 0; i < compparms->numstepsizes; ++i) {\n\t\tif (compparms->qntsty == JPC_QCX_NOQNT) {\n\t\t\tif (jpc_putuint8(out, JPC_QCX_GETEXPN(\n\t\t\t  compparms->stepsizes[i]) << 3)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\tif (jpc_putuint16(out, compparms->stepsizes[i])) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\\\n* SOP marker segment operations.\n\\******************************************************************************/\n\nstatic int jpc_sop_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in)\n{\n\tjpc_sop_t *sop = &ms->parms.sop;\n\n\t/* Eliminate compiler warning about unused variable. */\n\tcstate = 0;\n\n\tif (jpc_getuint16(in, &sop->seqno)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_sop_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out)\n{\n\tjpc_sop_t *sop = &ms->parms.sop;\n\n\t/* Eliminate compiler warning about unused variable. */\n\tcstate = 0;\n\n\tif (jpc_putuint16(out, sop->seqno)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_sop_dumpparms(jpc_ms_t *ms, FILE *out)\n{\n\tjpc_sop_t *sop = &ms->parms.sop;\n\tfprintf(out, \"seqno = %\"PRIuFAST16\";\\n\", sop->seqno);\n\treturn 0;\n}\n\n/******************************************************************************\\\n* PPM marker segment operations.\n\\******************************************************************************/\n\nstatic void jpc_ppm_destroyparms(jpc_ms_t *ms)\n{\n\tjpc_ppm_t *ppm = &ms->parms.ppm;\n\tif (ppm->data) {\n\t\tjas_free(ppm->data);\n\t}\n}\n\nstatic int jpc_ppm_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in)\n{\n\tjpc_ppm_t *ppm = &ms->parms.ppm;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tcstate = 0;\n\n\tppm->data = 0;\n\n\tif (ms->len < 1) {\n\t\tgoto error;\n\t}\n\tif (jpc_getuint8(in, &ppm->ind)) {\n\t\tgoto error;\n\t}\n\n\tppm->len = ms->len - 1;\n\tif (ppm->len > 0) {\n\t\tif (!(ppm->data = jas_malloc(ppm->len))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (JAS_CAST(uint, jas_stream_read(in, ppm->data, ppm->len)) != ppm->len) {\n\t\t\tgoto error;\n\t\t}\n\t} else {\n\t\tppm->data = 0;\n\t}\n\treturn 0;\n\nerror:\n\tjpc_ppm_destroyparms(ms);\n\treturn -1;\n}\n\nstatic int jpc_ppm_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out)\n{\n\tjpc_ppm_t *ppm = &ms->parms.ppm;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tcstate = 0;\n\n\tif (JAS_CAST(uint, jas_stream_write(out, (char *) ppm->data, ppm->len)) != ppm->len) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_ppm_dumpparms(jpc_ms_t *ms, FILE *out)\n{\n\tjpc_ppm_t *ppm = &ms->parms.ppm;\n\tfprintf(out, \"ind=%d; len = %\"PRIuFAST16\";\\n\", ppm->ind, ppm->len);\n\tif (ppm->len > 0) {\n\t\tfprintf(out, \"data =\\n\");\n\t\tjas_memdump(out, ppm->data, ppm->len);\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\\\n* PPT marker segment operations.\n\\******************************************************************************/\n\nstatic void jpc_ppt_destroyparms(jpc_ms_t *ms)\n{\n\tjpc_ppt_t *ppt = &ms->parms.ppt;\n\tif (ppt->data) {\n\t\tjas_free(ppt->data);\n\t}\n}\n\nstatic int jpc_ppt_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in)\n{\n\tjpc_ppt_t *ppt = &ms->parms.ppt;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tcstate = 0;\n\n\tppt->data = 0;\n\n\tif (ms->len < 1) {\n\t\tgoto error;\n\t}\n\tif (jpc_getuint8(in, &ppt->ind)) {\n\t\tgoto error;\n\t}\n\tppt->len = ms->len - 1;\n\tif (ppt->len > 0) {\n\t\tif (!(ppt->data = jas_malloc(ppt->len))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (jas_stream_read(in, (char *) ppt->data, ppt->len) != JAS_CAST(int, ppt->len)) {\n\t\t\tgoto error;\n\t\t}\n\t} else {\n\t\tppt->data = 0;\n\t}\n\treturn 0;\n\nerror:\n\tjpc_ppt_destroyparms(ms);\n\treturn -1;\n}\n\nstatic int jpc_ppt_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out)\n{\n\tjpc_ppt_t *ppt = &ms->parms.ppt;\n\n\t/* Eliminate compiler warning about unused variable. */\n\tcstate = 0;\n\n\tif (jpc_putuint8(out, ppt->ind)) {\n\t\treturn -1;\n\t}\n\tif (jas_stream_write(out, (char *) ppt->data, ppt->len) != JAS_CAST(int, ppt->len)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_ppt_dumpparms(jpc_ms_t *ms, FILE *out)\n{\n\tjpc_ppt_t *ppt = &ms->parms.ppt;\n\tfprintf(out, \"ind=%d; len = %\"PRIuFAST32\";\\n\", ppt->ind, ppt->len);\n\tif (ppt->len > 0) {\n\t\tfprintf(out, \"data =\\n\");\n\t\tjas_memdump(out, ppt->data, ppt->len);\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\\\n* POC marker segment operations.\n\\******************************************************************************/\n\nstatic void jpc_poc_destroyparms(jpc_ms_t *ms)\n{\n\tjpc_poc_t *poc = &ms->parms.poc;\n\tif (poc->pchgs) {\n\t\tjas_free(poc->pchgs);\n\t}\n}\n\nstatic int jpc_poc_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in)\n{\n\tjpc_poc_t *poc = &ms->parms.poc;\n\tjpc_pocpchg_t *pchg;\n\tint pchgno;\n\tuint_fast8_t tmp;\n\tpoc->numpchgs = (cstate->numcomps > 256) ? (ms->len / 9) :\n\t  (ms->len / 7);\n\tif (!(poc->pchgs = jas_alloc2(poc->numpchgs, sizeof(jpc_pocpchg_t)))) {\n\t\tgoto error;\n\t}\n\tfor (pchgno = 0, pchg = poc->pchgs; pchgno < poc->numpchgs; ++pchgno,\n\t  ++pchg) {\n\t\tif (jpc_getuint8(in, &pchg->rlvlnostart)) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (cstate->numcomps > 256) {\n\t\t\tif (jpc_getuint16(in, &pchg->compnostart)) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t} else {\n\t\t\tif (jpc_getuint8(in, &tmp)) {\n\t\t\t\tgoto error;\n\t\t\t};\n\t\t\tpchg->compnostart = tmp;\n\t\t}\n\t\tif (jpc_getuint16(in, &pchg->lyrnoend) ||\n\t\t  jpc_getuint8(in, &pchg->rlvlnoend)) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (cstate->numcomps > 256) {\n\t\t\tif (jpc_getuint16(in, &pchg->compnoend)) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t} else {\n\t\t\tif (jpc_getuint8(in, &tmp)) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tpchg->compnoend = tmp;\n\t\t}\n\t\tif (jpc_getuint8(in, &pchg->prgord)) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (pchg->rlvlnostart > pchg->rlvlnoend ||\n\t\t  pchg->compnostart > pchg->compnoend) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\treturn 0;\n\nerror:\n\tjpc_poc_destroyparms(ms);\n\treturn -1;\n}\n\nstatic int jpc_poc_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out)\n{\n\tjpc_poc_t *poc = &ms->parms.poc;\n\tjpc_pocpchg_t *pchg;\n\tint pchgno;\n\tfor (pchgno = 0, pchg = poc->pchgs; pchgno < poc->numpchgs; ++pchgno,\n\t  ++pchg) {\n\t\tif (jpc_putuint8(out, pchg->rlvlnostart) ||\n\t\t  ((cstate->numcomps > 256) ?\n\t\t  jpc_putuint16(out, pchg->compnostart) :\n\t\t  jpc_putuint8(out, pchg->compnostart)) ||\n\t\t  jpc_putuint16(out, pchg->lyrnoend) ||\n\t\t  jpc_putuint8(out, pchg->rlvlnoend) ||\n\t\t  ((cstate->numcomps > 256) ?\n\t\t  jpc_putuint16(out, pchg->compnoend) :\n\t\t  jpc_putuint8(out, pchg->compnoend)) ||\n\t\t  jpc_putuint8(out, pchg->prgord)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int jpc_poc_dumpparms(jpc_ms_t *ms, FILE *out)\n{\n\tjpc_poc_t *poc = &ms->parms.poc;\n\tjpc_pocpchg_t *pchg;\n\tint pchgno;\n\tfor (pchgno = 0, pchg = poc->pchgs; pchgno < poc->numpchgs;\n\t  ++pchgno, ++pchg) {\n\t\tfprintf(out, \"po[%d] = %d; \", pchgno, pchg->prgord);\n\t\tfprintf(out, \"cs[%d] = %\"PRIuFAST16\"; ce[%d] = %\"PRIuFAST16\"; \",\n\t\t  pchgno, pchg->compnostart, pchgno, pchg->compnoend);\n\t\tfprintf(out, \"rs[%d] = %d; re[%d] = %d; \",\n\t\t  pchgno, pchg->rlvlnostart, pchgno, pchg->rlvlnoend);\n\t\tfprintf(out, \"le[%d] = %\"PRIuFAST16\"\\n\", pchgno, pchg->lyrnoend);\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\\\n* CRG marker segment operations.\n\\******************************************************************************/\n\nstatic void jpc_crg_destroyparms(jpc_ms_t *ms)\n{\n\tjpc_crg_t *crg = &ms->parms.crg;\n\tif (crg->comps) {\n\t\tjas_free(crg->comps);\n\t}\n}\n\nstatic int jpc_crg_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in)\n{\n\tjpc_crg_t *crg = &ms->parms.crg;\n\tjpc_crgcomp_t *comp;\n\tuint_fast16_t compno;\n\tcrg->numcomps = cstate->numcomps;\n\tif (!(crg->comps = jas_alloc2(cstate->numcomps, sizeof(jpc_crgcomp_t)))) {\n\t\treturn -1;\n\t}\n\tfor (compno = 0, comp = crg->comps; compno < cstate->numcomps;\n\t  ++compno, ++comp) {\n\t\tif (jpc_getuint16(in, &comp->hoff) ||\n\t\t  jpc_getuint16(in, &comp->voff)) {\n\t\t\tjpc_crg_destroyparms(ms);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int jpc_crg_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out)\n{\n\tjpc_crg_t *crg = &ms->parms.crg;\n\tint compno;\n\tjpc_crgcomp_t *comp;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tcstate = 0;\n\n\tfor (compno = 0, comp = crg->comps; compno < crg->numcomps; ++compno,\n\t  ++comp) {\n\t\tif (jpc_putuint16(out, comp->hoff) ||\n\t\t  jpc_putuint16(out, comp->voff)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int jpc_crg_dumpparms(jpc_ms_t *ms, FILE *out)\n{\n\tjpc_crg_t *crg = &ms->parms.crg;\n\tint compno;\n\tjpc_crgcomp_t *comp;\n\tfor (compno = 0, comp = crg->comps; compno < crg->numcomps; ++compno,\n\t  ++comp) {\n\t\tfprintf(out, \"hoff[%d] = %\"PRIuFAST16\"; voff[%d] = %\"PRIuFAST16\"\\n\",\n\t\t  compno, comp->hoff, compno, comp->voff);\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\\\n* Operations for COM marker segment.\n\\******************************************************************************/\n\nstatic void jpc_com_destroyparms(jpc_ms_t *ms)\n{\n\tjpc_com_t *com = &ms->parms.com;\n\tif (com->data) {\n\t\tjas_free(com->data);\n\t}\n}\n\nstatic int jpc_com_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in)\n{\n\tjpc_com_t *com = &ms->parms.com;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tcstate = 0;\n\n\tif (jpc_getuint16(in, &com->regid)) {\n\t\treturn -1;\n\t}\n\tcom->len = ms->len - 2;\n\tif (com->len > 0) {\n\t\tif (!(com->data = jas_malloc(com->len))) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (jas_stream_read(in, com->data, com->len) != JAS_CAST(int, com->len)) {\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\tcom->data = 0;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_com_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out)\n{\n\tjpc_com_t *com = &ms->parms.com;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tcstate = 0;\n\n\tif (jpc_putuint16(out, com->regid)) {\n\t\treturn -1;\n\t}\n\tif (jas_stream_write(out, com->data, com->len) != JAS_CAST(int, com->len)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_com_dumpparms(jpc_ms_t *ms, FILE *out)\n{\n\tjpc_com_t *com = &ms->parms.com;\n\tunsigned int i;\n\tint printable;\n\tfprintf(out, \"regid = %\"PRIuFAST16\";\\n\", com->regid);\n\tprintable = 1;\n\tfor (i = 0; i < com->len; ++i) {\n\t\tif (!isprint(com->data[i])) {\n\t\t\tprintable = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (printable) {\n\t\tfprintf(out, \"data = \");\n\t\tfwrite(com->data, sizeof(char), com->len, out);\n\t\tfprintf(out, \"\\n\");\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\\\n* Operations for unknown types of marker segments.\n\\******************************************************************************/\n\nstatic void jpc_unk_destroyparms(jpc_ms_t *ms)\n{\n\tjpc_unk_t *unk = &ms->parms.unk;\n\tif (unk->data) {\n\t\tjas_free(unk->data);\n\t}\n}\n\nstatic int jpc_unk_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in)\n{\n\tjpc_unk_t *unk = &ms->parms.unk;\n\n\t/* Eliminate compiler warning about unused variables. */\n\tcstate = 0;\n\n\tif (ms->len > 0) {\n\t\tif (!(unk->data = jas_alloc2(ms->len, sizeof(unsigned char)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (jas_stream_read(in, (char *) unk->data, ms->len) != JAS_CAST(int, ms->len)) {\n\t\t\tjas_free(unk->data);\n\t\t\treturn -1;\n\t\t}\n\t\tunk->len = ms->len;\n\t} else {\n\t\tunk->data = 0;\n\t\tunk->len = 0;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_unk_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out)\n{\n\t/* Eliminate compiler warning about unused variables. */\n\tcstate = 0;\n\tms = 0;\n\tout = 0;\n\n\t/* If this function is called, we are trying to write an unsupported\n\t  type of marker segment.  Return with an error indication.  */\n\treturn -1;\n}\n\nstatic int jpc_unk_dumpparms(jpc_ms_t *ms, FILE *out)\n{\n\tunsigned int i;\n\tjpc_unk_t *unk = &ms->parms.unk;\n\tfor (i = 0; i < unk->len; ++i) {\n\t\tfprintf(out, \"%02x \", unk->data[i]);\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\\\n* Primitive I/O operations.\n\\******************************************************************************/\n\nint jpc_getuint8(jas_stream_t *in, uint_fast8_t *val)\n{\n\tint c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tif (val) {\n\t\t*val = c;\n\t}\n\treturn 0;\n}\n\nint jpc_putuint8(jas_stream_t *out, uint_fast8_t val)\n{\n\tif (jas_stream_putc(out, val & 0xff) == EOF) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nint jpc_getuint16(jas_stream_t *in, uint_fast16_t *val)\n{\n\tuint_fast16_t v;\n\tint c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tv = c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tv = (v << 8) | c;\n\tif (val) {\n\t\t*val = v;\n\t}\n\treturn 0;\n}\n\nint jpc_putuint16(jas_stream_t *out, uint_fast16_t val)\n{\n\tif (jas_stream_putc(out, (val >> 8) & 0xff) == EOF ||\n\t  jas_stream_putc(out, val & 0xff) == EOF) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nint jpc_getuint32(jas_stream_t *in, uint_fast32_t *val)\n{\n\tuint_fast32_t v;\n\tint c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tv = c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tv = (v << 8) | c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tv = (v << 8) | c;\n\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\treturn -1;\n\t}\n\tv = (v << 8) | c;\n\tif (val) {\n\t\t*val = v;\n\t}\n\treturn 0;\n}\n\nint jpc_putuint32(jas_stream_t *out, uint_fast32_t val)\n{\n\tif (jas_stream_putc(out, (val >> 24) & 0xff) == EOF ||\n\t  jas_stream_putc(out, (val >> 16) & 0xff) == EOF ||\n\t  jas_stream_putc(out, (val >> 8) & 0xff) == EOF ||\n\t  jas_stream_putc(out, val & 0xff) == EOF) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\\\n* Miscellany\n\\******************************************************************************/\n\nstatic jpc_mstabent_t *jpc_mstab_lookup(int id)\n{\n\tjpc_mstabent_t *mstabent;\n\tfor (mstabent = jpc_mstab;; ++mstabent) {\n\t\tif (mstabent->id == id || mstabent->id < 0) {\n\t\t\treturn mstabent;\n\t\t}\n\t}\n\tassert(0);\n\treturn 0;\n}\n\nint jpc_validate(jas_stream_t *in)\n{\n\tint n;\n\tint i;\n\tunsigned char buf[2];\n\n\tassert(JAS_STREAM_MAXPUTBACK >= 2);\n\n\tif ((n = jas_stream_read(in, (char *) buf, 2)) < 0) {\n\t\treturn -1;\n\t}\n\tfor (i = n - 1; i >= 0; --i) {\n\t\tif (jas_stream_ungetc(in, buf[i]) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (n < 2) {\n\t\treturn -1;\n\t}\n\tif (buf[0] == (JPC_MS_SOC >> 8) && buf[1] == (JPC_MS_SOC & 0xff)) {\n\t\treturn 0;\n\t}\n\treturn -1;\n}\n\nint jpc_getdata(jas_stream_t *in, jas_stream_t *out, long len)\n{\n\treturn jas_stream_copy(out, in, len);\n}\n\nint jpc_putdata(jas_stream_t *out, jas_stream_t *in, long len)\n{\n\treturn jas_stream_copy(out, in, len);\n}\n", "/*\n * Copyright (c) 1999-2000 Image Power, Inc. and the University of\n *   British Columbia.\n * Copyright (c) 2001-2003 Michael David Adams.\n * All rights reserved.\n */\n\n/* __START_OF_JASPER_LICENSE__\n * \n * JasPer License Version 2.0\n * \n * Copyright (c) 2001-2006 Michael David Adams\n * Copyright (c) 1999-2000 Image Power, Inc.\n * Copyright (c) 1999-2000 The University of British Columbia\n * \n * All rights reserved.\n * \n * Permission is hereby granted, free of charge, to any person (the\n * \"User\") obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n * \n * 1.  The above copyright notices and this permission notice (which\n * includes the disclaimer below) shall be included in all copies or\n * substantial portions of the Software.\n * \n * 2.  The name of a copyright holder shall not be used to endorse or\n * promote products derived from the Software without specific prior\n * written permission.\n * \n * THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS\n * LICENSE.  NO USE OF THE SOFTWARE IS AUTHORIZED HEREUNDER EXCEPT UNDER\n * THIS DISCLAIMER.  THE SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS\n * \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.  IN NO\n * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL\n * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING\n * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\n * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION\n * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  NO ASSURANCES ARE\n * PROVIDED BY THE COPYRIGHT HOLDERS THAT THE SOFTWARE DOES NOT INFRINGE\n * THE PATENT OR OTHER INTELLECTUAL PROPERTY RIGHTS OF ANY OTHER ENTITY.\n * EACH COPYRIGHT HOLDER DISCLAIMS ANY LIABILITY TO THE USER FOR CLAIMS\n * BROUGHT BY ANY OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL\n * PROPERTY RIGHTS OR OTHERWISE.  AS A CONDITION TO EXERCISING THE RIGHTS\n * GRANTED HEREUNDER, EACH USER HEREBY ASSUMES SOLE RESPONSIBILITY TO SECURE\n * ANY OTHER INTELLECTUAL PROPERTY RIGHTS NEEDED, IF ANY.  THE SOFTWARE\n * IS NOT FAULT-TOLERANT AND IS NOT INTENDED FOR USE IN MISSION-CRITICAL\n * SYSTEMS, SUCH AS THOSE USED IN THE OPERATION OF NUCLEAR FACILITIES,\n * AIRCRAFT NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL\n * SYSTEMS, DIRECT LIFE SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH\n * THE FAILURE OF THE SOFTWARE OR SYSTEM COULD LEAD DIRECTLY TO DEATH,\n * PERSONAL INJURY, OR SEVERE PHYSICAL OR ENVIRONMENTAL DAMAGE (\"HIGH\n * RISK ACTIVITIES\").  THE COPYRIGHT HOLDERS SPECIFICALLY DISCLAIM ANY\n * EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR HIGH RISK ACTIVITIES.\n * \n * __END_OF_JASPER_LICENSE__\n */\n\n/*\n * $Id$\n */\n\n/******************************************************************************\\\n* Includes.\n\\******************************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <inttypes.h>\n\n#include \"jasper/jas_types.h\"\n#include \"jasper/jas_math.h\"\n#include \"jasper/jas_tvp.h\"\n#include \"jasper/jas_malloc.h\"\n#include \"jasper/jas_debug.h\"\n\n#include \"jpc_fix.h\"\n#include \"jpc_dec.h\"\n#include \"jpc_cs.h\"\n#include \"jpc_mct.h\"\n#include \"jpc_t2dec.h\"\n#include \"jpc_t1dec.h\"\n#include \"jpc_math.h\"\n\n/******************************************************************************\\\n*\n\\******************************************************************************/\n\n#define\tJPC_MHSOC\t0x0001\n  /* In the main header, expecting a SOC marker segment. */\n#define\tJPC_MHSIZ\t0x0002\n  /* In the main header, expecting a SIZ marker segment. */\n#define\tJPC_MH\t\t0x0004\n  /* In the main header, expecting \"other\" marker segments. */\n#define\tJPC_TPHSOT\t0x0008\n  /* In a tile-part header, expecting a SOT marker segment. */\n#define\tJPC_TPH\t\t0x0010\n  /* In a tile-part header, expecting \"other\" marker segments. */\n#define\tJPC_MT\t\t0x0020\n  /* In the main trailer. */\n\ntypedef struct {\n\n\tuint_fast16_t id;\n\t/* The marker segment type. */\n\n\tint validstates;\n\t/* The states in which this type of marker segment can be\n\t  validly encountered. */\n\n\tint (*action)(jpc_dec_t *dec, jpc_ms_t *ms);\n\t/* The action to take upon encountering this type of marker segment. */\n\n} jpc_dec_mstabent_t;\n\n/******************************************************************************\\\n*\n\\******************************************************************************/\n\n/* COD/COC parameters have been specified. */\n#define\tJPC_CSET\t0x0001\n/* QCD/QCC parameters have been specified. */\n#define\tJPC_QSET\t0x0002\n/* COD/COC parameters set from a COC marker segment. */\n#define\tJPC_COC\t0x0004\n/* QCD/QCC parameters set from a QCC marker segment. */\n#define\tJPC_QCC\t0x0008\n\n/******************************************************************************\\\n* Local function prototypes.\n\\******************************************************************************/\n\nstatic int jpc_dec_dump(jpc_dec_t *dec, FILE *out);\n\njpc_ppxstab_t *jpc_ppxstab_create(void);\nvoid jpc_ppxstab_destroy(jpc_ppxstab_t *tab);\nint jpc_ppxstab_grow(jpc_ppxstab_t *tab, int maxents);\nint jpc_ppxstab_insert(jpc_ppxstab_t *tab, jpc_ppxstabent_t *ent);\njpc_streamlist_t *jpc_ppmstabtostreams(jpc_ppxstab_t *tab);\nint jpc_pptstabwrite(jas_stream_t *out, jpc_ppxstab_t *tab);\njpc_ppxstabent_t *jpc_ppxstabent_create(void);\nvoid jpc_ppxstabent_destroy(jpc_ppxstabent_t *ent);\n\nint jpc_streamlist_numstreams(jpc_streamlist_t *streamlist);\njpc_streamlist_t *jpc_streamlist_create(void);\nint jpc_streamlist_insert(jpc_streamlist_t *streamlist, int streamno,\n  jas_stream_t *stream);\njas_stream_t *jpc_streamlist_remove(jpc_streamlist_t *streamlist, int streamno);\nvoid jpc_streamlist_destroy(jpc_streamlist_t *streamlist);\njas_stream_t *jpc_streamlist_get(jpc_streamlist_t *streamlist, int streamno);\n\nstatic void jpc_dec_cp_resetflags(jpc_dec_cp_t *cp);\nstatic jpc_dec_cp_t *jpc_dec_cp_create(uint_fast16_t numcomps);\nstatic int jpc_dec_cp_isvalid(jpc_dec_cp_t *cp);\nstatic jpc_dec_cp_t *jpc_dec_cp_copy(jpc_dec_cp_t *cp);\nstatic int jpc_dec_cp_setfromcod(jpc_dec_cp_t *cp, jpc_cod_t *cod);\nstatic int jpc_dec_cp_setfromcoc(jpc_dec_cp_t *cp, jpc_coc_t *coc);\nstatic int jpc_dec_cp_setfromcox(jpc_dec_cp_t *cp, jpc_dec_ccp_t *ccp,\n  jpc_coxcp_t *compparms, int flags);\nstatic int jpc_dec_cp_setfromqcd(jpc_dec_cp_t *cp, jpc_qcd_t *qcd);\nstatic int jpc_dec_cp_setfromqcc(jpc_dec_cp_t *cp, jpc_qcc_t *qcc);\nstatic int jpc_dec_cp_setfromqcx(jpc_dec_cp_t *cp, jpc_dec_ccp_t *ccp,\n  jpc_qcxcp_t *compparms, int flags);\nstatic int jpc_dec_cp_setfromrgn(jpc_dec_cp_t *cp, jpc_rgn_t *rgn);\nstatic int jpc_dec_cp_prepare(jpc_dec_cp_t *cp);\nstatic void jpc_dec_cp_destroy(jpc_dec_cp_t *cp);\nstatic int jpc_dec_cp_setfrompoc(jpc_dec_cp_t *cp, jpc_poc_t *poc, int reset);\nstatic int jpc_pi_addpchgfrompoc(jpc_pi_t *pi, jpc_poc_t *poc);\n\nstatic int jpc_dec_decode(jpc_dec_t *dec);\nstatic jpc_dec_t *jpc_dec_create(jpc_dec_importopts_t *impopts, jas_stream_t *in);\nstatic void jpc_dec_destroy(jpc_dec_t *dec);\nstatic void jpc_dequantize(jas_matrix_t *x, jpc_fix_t absstepsize);\nstatic void jpc_undo_roi(jas_matrix_t *x, int roishift, int bgshift, int numbps);\nstatic jpc_fix_t jpc_calcabsstepsize(int stepsize, int numbits);\nstatic int jpc_dec_tiledecode(jpc_dec_t *dec, jpc_dec_tile_t *tile);\nstatic int jpc_dec_tileinit(jpc_dec_t *dec, jpc_dec_tile_t *tile);\nstatic int jpc_dec_tilefini(jpc_dec_t *dec, jpc_dec_tile_t *tile);\nstatic int jpc_dec_process_soc(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_sot(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_sod(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_eoc(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_siz(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_cod(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_coc(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_rgn(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_qcd(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_qcc(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_poc(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_ppm(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_ppt(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_com(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_unk(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_process_crg(jpc_dec_t *dec, jpc_ms_t *ms);\nstatic int jpc_dec_parseopts(char *optstr, jpc_dec_importopts_t *opts);\n\nstatic jpc_dec_mstabent_t *jpc_dec_mstab_lookup(uint_fast16_t id);\n\n/******************************************************************************\\\n* Global data.\n\\******************************************************************************/\n\njpc_dec_mstabent_t jpc_dec_mstab[] = {\n\t{JPC_MS_SOC, JPC_MHSOC, jpc_dec_process_soc},\n\t{JPC_MS_SOT, JPC_MH | JPC_TPHSOT, jpc_dec_process_sot},\n\t{JPC_MS_SOD, JPC_TPH, jpc_dec_process_sod},\n\t{JPC_MS_EOC, JPC_TPHSOT, jpc_dec_process_eoc},\n\t{JPC_MS_SIZ, JPC_MHSIZ, jpc_dec_process_siz},\n\t{JPC_MS_COD, JPC_MH | JPC_TPH, jpc_dec_process_cod},\n\t{JPC_MS_COC, JPC_MH | JPC_TPH, jpc_dec_process_coc},\n\t{JPC_MS_RGN, JPC_MH | JPC_TPH, jpc_dec_process_rgn},\n\t{JPC_MS_QCD, JPC_MH | JPC_TPH, jpc_dec_process_qcd},\n\t{JPC_MS_QCC, JPC_MH | JPC_TPH, jpc_dec_process_qcc},\n\t{JPC_MS_POC, JPC_MH | JPC_TPH, jpc_dec_process_poc},\n\t{JPC_MS_TLM, JPC_MH, 0},\n\t{JPC_MS_PLM, JPC_MH, 0},\n\t{JPC_MS_PLT, JPC_TPH, 0},\n\t{JPC_MS_PPM, JPC_MH, jpc_dec_process_ppm},\n\t{JPC_MS_PPT, JPC_TPH, jpc_dec_process_ppt},\n\t{JPC_MS_SOP, 0, 0},\n\t{JPC_MS_CRG, JPC_MH, jpc_dec_process_crg},\n\t{JPC_MS_COM, JPC_MH | JPC_TPH, jpc_dec_process_com},\n\t{0, JPC_MH | JPC_TPH, jpc_dec_process_unk}\n};\n\n/******************************************************************************\\\n* The main entry point for the JPEG-2000 decoder.\n\\******************************************************************************/\n\njas_image_t *jpc_decode(jas_stream_t *in, char *optstr)\n{\n\tjpc_dec_importopts_t opts;\n\tjpc_dec_t *dec;\n\tjas_image_t *image;\n\n\tdec = 0;\n\n\tif (jpc_dec_parseopts(optstr, &opts)) {\n\t\tgoto error;\n\t}\n\n\tjpc_initluts();\n\n\tif (!(dec = jpc_dec_create(&opts, in))) {\n\t\tgoto error;\n\t}\n\n\t/* Do most of the work. */\n\tif (jpc_dec_decode(dec)) {\n\t\tgoto error;\n\t}\n\n\tif (jas_image_numcmpts(dec->image) >= 3) {\n\t\tjas_image_setclrspc(dec->image, JAS_CLRSPC_SRGB);\n\t\tjas_image_setcmpttype(dec->image, 0,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_R));\n\t\tjas_image_setcmpttype(dec->image, 1,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_G));\n\t\tjas_image_setcmpttype(dec->image, 2,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_B));\n\t} else {\n\t\tjas_image_setclrspc(dec->image, JAS_CLRSPC_SGRAY);\n\t\tjas_image_setcmpttype(dec->image, 0,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_GRAY_Y));\n\t}\n\n\t/* Save the return value. */\n\timage = dec->image;\n\n\t/* Stop the image from being discarded. */\n\tdec->image = 0;\n\n\t/* Destroy decoder. */\n\tjpc_dec_destroy(dec);\n\n\treturn image;\n\nerror:\n\tif (dec) {\n\t\tjpc_dec_destroy(dec);\n\t}\n\treturn 0;\n}\n\ntypedef enum {\n\tOPT_MAXLYRS,\n\tOPT_MAXPKTS,\n\tOPT_DEBUG\n} optid_t;\n\njas_taginfo_t decopts[] = {\n\t{OPT_MAXLYRS, \"maxlyrs\"},\n\t{OPT_MAXPKTS, \"maxpkts\"},\n\t{OPT_DEBUG, \"debug\"},\n\t{-1, 0}\n};\n\nstatic int jpc_dec_parseopts(char *optstr, jpc_dec_importopts_t *opts)\n{\n\tjas_tvparser_t *tvp;\n\n\topts->debug = 0;\n\topts->maxlyrs = JPC_MAXLYRS;\n\topts->maxpkts = -1;\n\n\tif (!(tvp = jas_tvparser_create(optstr ? optstr : \"\"))) {\n\t\treturn -1;\n\t}\n\n\twhile (!jas_tvparser_next(tvp)) {\n\t\tswitch (jas_taginfo_nonull(jas_taginfos_lookup(decopts,\n\t\t  jas_tvparser_gettag(tvp)))->id) {\n\t\tcase OPT_MAXLYRS:\n\t\t\topts->maxlyrs = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_DEBUG:\n\t\t\topts->debug = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase OPT_MAXPKTS:\n\t\t\topts->maxpkts = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tjas_eprintf(\"warning: ignoring invalid option %s\\n\",\n\t\t\t  jas_tvparser_gettag(tvp));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tjas_tvparser_destroy(tvp);\n\n\treturn 0;\n}\n\n/******************************************************************************\\\n* Code for table-driven code stream decoder.\n\\******************************************************************************/\n\nstatic jpc_dec_mstabent_t *jpc_dec_mstab_lookup(uint_fast16_t id)\n{\n\tjpc_dec_mstabent_t *mstabent;\n\tfor (mstabent = jpc_dec_mstab; mstabent->id != 0; ++mstabent) {\n\t\tif (mstabent->id == id) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn mstabent;\n}\n\nstatic int jpc_dec_decode(jpc_dec_t *dec)\n{\n\tjpc_ms_t *ms;\n\tjpc_dec_mstabent_t *mstabent;\n\tint ret;\n\tjpc_cstate_t *cstate;\n\n\tif (!(cstate = jpc_cstate_create())) {\n\t\treturn -1;\n\t}\n\tdec->cstate = cstate;\n\n\t/* Initially, we should expect to encounter a SOC marker segment. */\n\tdec->state = JPC_MHSOC;\n\n\tfor (;;) {\n\n\t\t/* Get the next marker segment in the code stream. */\n\t\tif (!(ms = jpc_getms(dec->in, cstate))) {\n\t\t\tjas_eprintf(\"cannot get marker segment\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tmstabent = jpc_dec_mstab_lookup(ms->id);\n\t\tassert(mstabent);\n\n\t\t/* Ensure that this type of marker segment is permitted\n\t\t  at this point in the code stream. */\n\t\tif (!(dec->state & mstabent->validstates)) {\n\t\t\tjas_eprintf(\"unexpected marker segment type\\n\");\n\t\t\tjpc_ms_destroy(ms);\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* Process the marker segment. */\n\t\tif (mstabent->action) {\n\t\t\tret = (*mstabent->action)(dec, ms);\n\t\t} else {\n\t\t\t/* No explicit action is required. */\n\t\t\tret = 0;\n\t\t}\n\n\t\t/* Destroy the marker segment. */\n\t\tjpc_ms_destroy(ms);\n\n\t\tif (ret < 0) {\n\t\t\treturn -1;\n\t\t} else if (ret > 0) {\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\treturn 0;\n}\n\nstatic int jpc_dec_process_crg(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tint cmptno;\n\tjpc_dec_cmpt_t *cmpt;\n\tjpc_crg_t *crg;\n\n\tcrg = &ms->parms.crg;\n\tfor (cmptno = 0, cmpt = dec->cmpts; cmptno < dec->numcomps; ++cmptno,\n\t  ++cmpt) {\n\t\t/* Ignore the information in the CRG marker segment for now.\n\t\t  This information serves no useful purpose for decoding anyhow.\n\t\t  Some other parts of the code need to be changed if these lines\n\t\t  are uncommented.\n\t\tcmpt->hsubstep = crg->comps[cmptno].hoff;\n\t\tcmpt->vsubstep = crg->comps[cmptno].voff;\n\t\t*/\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_soc(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\t/* Eliminate warnings about unused variables. */\n\tms = 0;\n\n\t/* We should expect to encounter a SIZ marker segment next. */\n\tdec->state = JPC_MHSIZ;\n\n\treturn 0;\n}\n\nstatic int jpc_dec_process_sot(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_dec_tile_t *tile;\n\tjpc_sot_t *sot = &ms->parms.sot;\n\tjas_image_cmptparm_t *compinfos;\n\tjas_image_cmptparm_t *compinfo;\n\tjpc_dec_cmpt_t *cmpt;\n\tint cmptno;\n\n\tif (dec->state == JPC_MH) {\n\n\t\tif (!(compinfos = jas_alloc2(dec->numcomps,\n\t\t  sizeof(jas_image_cmptparm_t)))) {\n\t\t\tabort();\n\t\t}\n\t\tfor (cmptno = 0, cmpt = dec->cmpts, compinfo = compinfos;\n\t\t  cmptno < dec->numcomps; ++cmptno, ++cmpt, ++compinfo) {\n\t\t\tcompinfo->tlx = 0;\n\t\t\tcompinfo->tly = 0;\n\t\t\tcompinfo->prec = cmpt->prec;\n\t\t\tcompinfo->sgnd = cmpt->sgnd;\n\t\t\tcompinfo->width = cmpt->width;\n\t\t\tcompinfo->height = cmpt->height;\n\t\t\tcompinfo->hstep = cmpt->hstep;\n\t\t\tcompinfo->vstep = cmpt->vstep;\n\t\t}\n\n\t\tif (!(dec->image = jas_image_create(dec->numcomps, compinfos,\n\t\t  JAS_CLRSPC_UNKNOWN))) {\n\t\t\tjas_free(compinfos);\n\t\t\treturn -1;\n\t\t}\n\t\tjas_free(compinfos);\n\n\t\t/* Is the packet header information stored in PPM marker segments in\n\t\t  the main header? */\n\t\tif (dec->ppmstab) {\n\t\t\t/* Convert the PPM marker segment data into a collection of streams\n\t\t\t  (one stream per tile-part). */\n\t\t\tif (!(dec->pkthdrstreams = jpc_ppmstabtostreams(dec->ppmstab))) {\n\t\t\t\tabort();\n\t\t\t}\n\t\t\tjpc_ppxstab_destroy(dec->ppmstab);\n\t\t\tdec->ppmstab = 0;\n\t\t}\n\t}\n\n\tif (sot->len > 0) {\n\t\tdec->curtileendoff = jas_stream_getrwcount(dec->in) - ms->len -\n\t\t  4 + sot->len;\n\t} else {\n\t\tdec->curtileendoff = 0;\n\t}\n\n\tif (JAS_CAST(int, sot->tileno) >= dec->numtiles) {\n\t\tjas_eprintf(\"invalid tile number in SOT marker segment\\n\");\n\t\treturn -1;\n\t}\n\t/* Set the current tile. */\n\tdec->curtile = &dec->tiles[sot->tileno];\n\ttile = dec->curtile;\n\t/* Ensure that this is the expected part number. */\n\tif (sot->partno != tile->partno) {\n\t\treturn -1;\n\t}\n\tif (tile->numparts > 0 && sot->partno >= tile->numparts) {\n\t\treturn -1;\n\t}\n\tif (!tile->numparts && sot->numparts > 0) {\n\t\ttile->numparts = sot->numparts;\n\t}\n\n\ttile->pptstab = 0;\n\n\tswitch (tile->state) {\n\tcase JPC_TILE_INIT:\n\t\t/* This is the first tile-part for this tile. */\n\t\ttile->state = JPC_TILE_ACTIVE;\n\t\tassert(!tile->cp);\n\t\tif (!(tile->cp = jpc_dec_cp_copy(dec->cp))) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_resetflags(dec->cp);\n\t\tbreak;\n\tdefault:\n\t\tif (sot->numparts == sot->partno - 1) {\n\t\t\ttile->state = JPC_TILE_ACTIVELAST;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* Note: We do not increment the expected tile-part number until\n\t  all processing for this tile-part is complete. */\n\n\t/* We should expect to encounter other tile-part header marker\n\t  segments next. */\n\tdec->state = JPC_TPH;\n\n\treturn 0;\n}\n\nstatic int jpc_dec_process_sod(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_dec_tile_t *tile;\n\tint pos;\n\n\t/* Eliminate compiler warnings about unused variables. */\n\tms = 0;\n\n\tif (!(tile = dec->curtile)) {\n\t\treturn -1;\n\t}\n\n\tif (!tile->partno) {\n\t\tif (!jpc_dec_cp_isvalid(tile->cp)) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_prepare(tile->cp);\n\t\tif (jpc_dec_tileinit(dec, tile)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* Are packet headers stored in the main header or tile-part header? */\n\tif (dec->pkthdrstreams) {\n\t\t/* Get the stream containing the packet header data for this\n\t\t  tile-part. */\n\t\tif (!(tile->pkthdrstream = jpc_streamlist_remove(dec->pkthdrstreams, 0))) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (tile->pptstab) {\n\t\tif (!tile->pkthdrstream) {\n\t\t\tif (!(tile->pkthdrstream = jas_stream_memopen(0, 0))) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tpos = jas_stream_tell(tile->pkthdrstream);\n\t\tjas_stream_seek(tile->pkthdrstream, 0, SEEK_END);\n\t\tif (jpc_pptstabwrite(tile->pkthdrstream, tile->pptstab)) {\n\t\t\treturn -1;\n\t\t}\n\t\tjas_stream_seek(tile->pkthdrstream, pos, SEEK_SET);\n\t\tjpc_ppxstab_destroy(tile->pptstab);\n\t\ttile->pptstab = 0;\n\t}\n\n\tif (jas_getdbglevel() >= 10) {\n\t\tjpc_dec_dump(dec, stderr);\n\t}\n\n\tif (jpc_dec_decodepkts(dec, (tile->pkthdrstream) ? tile->pkthdrstream :\n\t  dec->in, dec->in)) {\n\t\tjas_eprintf(\"jpc_dec_decodepkts failed\\n\");\n\t\treturn -1;\n\t}\n\n\t/* Gobble any unconsumed tile data. */\n\tif (dec->curtileendoff > 0) {\n\t\tlong curoff;\n\t\tuint_fast32_t n;\n\t\tcuroff = jas_stream_getrwcount(dec->in);\n\t\tif (curoff < dec->curtileendoff) {\n\t\t\tn = dec->curtileendoff - curoff;\n\t\t\tjas_eprintf(\"warning: ignoring trailing garbage (%lu bytes)\\n\",\n\t\t\t  (unsigned long) n);\n\n\t\t\twhile (n-- > 0) {\n\t\t\t\tif (jas_stream_getc(dec->in) == EOF) {\n\t\t\t\t\tjas_eprintf(\"read error\\n\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (curoff > dec->curtileendoff) {\n\t\t\tjas_eprintf(\"warning: not enough tile data (%lu bytes)\\n\",\n\t\t\t  (unsigned long) curoff - dec->curtileendoff);\n\t\t}\n\n\t}\n\n\tif (tile->numparts > 0 && tile->partno == tile->numparts - 1) {\n\t\tif (jpc_dec_tiledecode(dec, tile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_tilefini(dec, tile);\n\t}\n\n\tdec->curtile = 0;\n\n\t/* Increment the expected tile-part number. */\n\t++tile->partno;\n\n\t/* We should expect to encounter a SOT marker segment next. */\n\tdec->state = JPC_TPHSOT;\n\n\treturn 0;\n}\n\nstatic int jpc_dec_tileinit(jpc_dec_t *dec, jpc_dec_tile_t *tile)\n{\n\tjpc_dec_tcomp_t *tcomp;\n\tint compno;\n\tint rlvlno;\n\tjpc_dec_rlvl_t *rlvl;\n\tjpc_dec_band_t *band;\n\tjpc_dec_prc_t *prc;\n\tint bndno;\n\tjpc_tsfb_band_t *bnd;\n\tint bandno;\n\tjpc_dec_ccp_t *ccp;\n\tint prccnt;\n\tjpc_dec_cblk_t *cblk;\n\tint cblkcnt;\n\tuint_fast32_t tlprcxstart;\n\tuint_fast32_t tlprcystart;\n\tuint_fast32_t brprcxend;\n\tuint_fast32_t brprcyend;\n\tuint_fast32_t tlcbgxstart;\n\tuint_fast32_t tlcbgystart;\n\tuint_fast32_t brcbgxend;\n\tuint_fast32_t brcbgyend;\n\tuint_fast32_t cbgxstart;\n\tuint_fast32_t cbgystart;\n\tuint_fast32_t cbgxend;\n\tuint_fast32_t cbgyend;\n\tuint_fast32_t tlcblkxstart;\n\tuint_fast32_t tlcblkystart;\n\tuint_fast32_t brcblkxend;\n\tuint_fast32_t brcblkyend;\n\tuint_fast32_t cblkxstart;\n\tuint_fast32_t cblkystart;\n\tuint_fast32_t cblkxend;\n\tuint_fast32_t cblkyend;\n\tuint_fast32_t tmpxstart;\n\tuint_fast32_t tmpystart;\n\tuint_fast32_t tmpxend;\n\tuint_fast32_t tmpyend;\n\tjpc_dec_cp_t *cp;\n\tjpc_tsfb_band_t bnds[64];\n\tjpc_pchg_t *pchg;\n\tint pchgno;\n\tjpc_dec_cmpt_t *cmpt;\n\n\tcp = tile->cp;\n\ttile->realmode = 0;\n\tif (cp->mctid == JPC_MCT_ICT) {\n\t\ttile->realmode = 1;\n\t}\n\n\tfor (compno = 0, tcomp = tile->tcomps, cmpt = dec->cmpts; compno <\n\t  dec->numcomps; ++compno, ++tcomp, ++cmpt) {\n\t\tccp = &tile->cp->ccps[compno];\n\t\tif (ccp->qmfbid == JPC_COX_INS) {\n\t\t\ttile->realmode = 1;\n\t\t}\n\t\ttcomp->numrlvls = ccp->numrlvls;\n\t\tif (!(tcomp->rlvls = jas_alloc2(tcomp->numrlvls,\n\t\t  sizeof(jpc_dec_rlvl_t)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (!(tcomp->data = jas_seq2d_create(JPC_CEILDIV(tile->xstart,\n\t\t  cmpt->hstep), JPC_CEILDIV(tile->ystart, cmpt->vstep),\n\t\t  JPC_CEILDIV(tile->xend, cmpt->hstep), JPC_CEILDIV(tile->yend,\n\t\t  cmpt->vstep)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (!(tcomp->tsfb = jpc_cod_gettsfb(ccp->qmfbid,\n\t\t  tcomp->numrlvls - 1))) {\n\t\t\treturn -1;\n\t\t}\n\t\t{\n\t\t\tjpc_tsfb_getbands(tcomp->tsfb, jas_seq2d_xstart(tcomp->data),\n\t\t\t  jas_seq2d_ystart(tcomp->data), jas_seq2d_xend(tcomp->data),\n\t\t\t  jas_seq2d_yend(tcomp->data), bnds);\n\t\t}\n\t\tfor (rlvlno = 0, rlvl = tcomp->rlvls; rlvlno < tcomp->numrlvls;\n\t\t  ++rlvlno, ++rlvl) {\n\t\t\trlvl->bands = 0;\n\t\t\trlvl->xstart = JPC_CEILDIVPOW2(tcomp->xstart,\n\t\t\t  tcomp->numrlvls - 1 - rlvlno);\n\t\t\trlvl->ystart = JPC_CEILDIVPOW2(tcomp->ystart,\n\t\t\t  tcomp->numrlvls - 1 - rlvlno);\n\t\t\trlvl->xend = JPC_CEILDIVPOW2(tcomp->xend,\n\t\t\t  tcomp->numrlvls - 1 - rlvlno);\n\t\t\trlvl->yend = JPC_CEILDIVPOW2(tcomp->yend,\n\t\t\t  tcomp->numrlvls - 1 - rlvlno);\n\t\t\trlvl->prcwidthexpn = ccp->prcwidthexpns[rlvlno];\n\t\t\trlvl->prcheightexpn = ccp->prcheightexpns[rlvlno];\n\t\t\ttlprcxstart = JPC_FLOORDIVPOW2(rlvl->xstart,\n\t\t\t  rlvl->prcwidthexpn) << rlvl->prcwidthexpn;\n\t\t\ttlprcystart = JPC_FLOORDIVPOW2(rlvl->ystart,\n\t\t\t  rlvl->prcheightexpn) << rlvl->prcheightexpn;\n\t\t\tbrprcxend = JPC_CEILDIVPOW2(rlvl->xend,\n\t\t\t  rlvl->prcwidthexpn) << rlvl->prcwidthexpn;\n\t\t\tbrprcyend = JPC_CEILDIVPOW2(rlvl->yend,\n\t\t\t  rlvl->prcheightexpn) << rlvl->prcheightexpn;\n\t\t\trlvl->numhprcs = (brprcxend - tlprcxstart) >>\n\t\t\t  rlvl->prcwidthexpn;\n\t\t\trlvl->numvprcs = (brprcyend - tlprcystart) >>\n\t\t\t  rlvl->prcheightexpn;\n\t\t\trlvl->numprcs = rlvl->numhprcs * rlvl->numvprcs;\n\n\t\t\tif (rlvl->xstart >= rlvl->xend || rlvl->ystart >= rlvl->yend) {\n\t\t\t\trlvl->bands = 0;\n\t\t\t\trlvl->numprcs = 0;\n\t\t\t\trlvl->numhprcs = 0;\n\t\t\t\trlvl->numvprcs = 0;\n\t\t\t\tcontinue;\n\t\t\t}\t\n\t\t\tif (!rlvlno) {\n\t\t\t\ttlcbgxstart = tlprcxstart;\n\t\t\t\ttlcbgystart = tlprcystart;\n\t\t\t\tbrcbgxend = brprcxend;\n\t\t\t\tbrcbgyend = brprcyend;\n\t\t\t\trlvl->cbgwidthexpn = rlvl->prcwidthexpn;\n\t\t\t\trlvl->cbgheightexpn = rlvl->prcheightexpn;\n\t\t\t} else {\n\t\t\t\ttlcbgxstart = JPC_CEILDIVPOW2(tlprcxstart, 1);\n\t\t\t\ttlcbgystart = JPC_CEILDIVPOW2(tlprcystart, 1);\n\t\t\t\tbrcbgxend = JPC_CEILDIVPOW2(brprcxend, 1);\n\t\t\t\tbrcbgyend = JPC_CEILDIVPOW2(brprcyend, 1);\n\t\t\t\trlvl->cbgwidthexpn = rlvl->prcwidthexpn - 1;\n\t\t\t\trlvl->cbgheightexpn = rlvl->prcheightexpn - 1;\n\t\t\t}\n\t\t\trlvl->cblkwidthexpn = JAS_MIN(ccp->cblkwidthexpn,\n\t\t\t  rlvl->cbgwidthexpn);\n\t\t\trlvl->cblkheightexpn = JAS_MIN(ccp->cblkheightexpn,\n\t\t\t  rlvl->cbgheightexpn);\n\n\t\t\trlvl->numbands = (!rlvlno) ? 1 : 3;\n\t\t\tif (!(rlvl->bands = jas_alloc2(rlvl->numbands,\n\t\t\t  sizeof(jpc_dec_band_t)))) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (bandno = 0, band = rlvl->bands;\n\t\t\t  bandno < rlvl->numbands; ++bandno, ++band) {\n\t\t\t\tbndno = (!rlvlno) ? 0 : (3 * (rlvlno - 1) +\n\t\t\t\t  bandno + 1);\n\t\t\t\tbnd = &bnds[bndno];\n\n\t\t\t\tband->orient = bnd->orient;\n\t\t\t\tband->stepsize = ccp->stepsizes[bndno];\n\t\t\t\tband->analgain = JPC_NOMINALGAIN(ccp->qmfbid,\n\t\t\t\t  tcomp->numrlvls - 1, rlvlno, band->orient);\n\t\t\t\tband->absstepsize = jpc_calcabsstepsize(band->stepsize,\n\t\t\t\t  cmpt->prec + band->analgain);\n\t\t\t\tband->numbps = ccp->numguardbits +\n\t\t\t\t  JPC_QCX_GETEXPN(band->stepsize) - 1;\n\t\t\t\tband->roishift = (ccp->roishift + band->numbps >= JPC_PREC) ?\n\t\t\t\t  (JPC_PREC - 1 - band->numbps) : ccp->roishift;\n\t\t\t\tband->data = 0;\n\t\t\t\tband->prcs = 0;\n\t\t\t\tif (bnd->xstart == bnd->xend || bnd->ystart == bnd->yend) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!(band->data = jas_seq2d_create(0, 0, 0, 0))) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tjas_seq2d_bindsub(band->data, tcomp->data, bnd->locxstart,\n\t\t\t\t  bnd->locystart, bnd->locxend, bnd->locyend);\n\t\t\t\tjas_seq2d_setshift(band->data, bnd->xstart, bnd->ystart);\n\n\t\t\t\tassert(rlvl->numprcs);\n\n\t\t\t\tif (!(band->prcs = jas_alloc2(rlvl->numprcs,\n\t\t\t\t  sizeof(jpc_dec_prc_t)))) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n/************************************************/\n\t\t\t\tcbgxstart = tlcbgxstart;\n\t\t\t\tcbgystart = tlcbgystart;\n\t\t\t\tfor (prccnt = rlvl->numprcs, prc = band->prcs;\n\t\t\t\t  prccnt > 0; --prccnt, ++prc) {\n\t\t\t\t\tcbgxend = cbgxstart + (1 << rlvl->cbgwidthexpn);\n\t\t\t\t\tcbgyend = cbgystart + (1 << rlvl->cbgheightexpn);\n\t\t\t\t\tprc->xstart = JAS_MAX(cbgxstart, JAS_CAST(uint_fast32_t,\n\t\t\t\t\t  jas_seq2d_xstart(band->data)));\n\t\t\t\t\tprc->ystart = JAS_MAX(cbgystart, JAS_CAST(uint_fast32_t,\n\t\t\t\t\t  jas_seq2d_ystart(band->data)));\n\t\t\t\t\tprc->xend = JAS_MIN(cbgxend, JAS_CAST(uint_fast32_t,\n\t\t\t\t\t  jas_seq2d_xend(band->data)));\n\t\t\t\t\tprc->yend = JAS_MIN(cbgyend, JAS_CAST(uint_fast32_t,\n\t\t\t\t\t  jas_seq2d_yend(band->data)));\n\t\t\t\t\tif (prc->xend > prc->xstart && prc->yend > prc->ystart) {\n\t\t\t\t\t\ttlcblkxstart = JPC_FLOORDIVPOW2(prc->xstart,\n\t\t\t\t\t\t  rlvl->cblkwidthexpn) << rlvl->cblkwidthexpn;\n\t\t\t\t\t\ttlcblkystart = JPC_FLOORDIVPOW2(prc->ystart,\n\t\t\t\t\t\t  rlvl->cblkheightexpn) << rlvl->cblkheightexpn;\n\t\t\t\t\t\tbrcblkxend = JPC_CEILDIVPOW2(prc->xend,\n\t\t\t\t\t\t  rlvl->cblkwidthexpn) << rlvl->cblkwidthexpn;\n\t\t\t\t\t\tbrcblkyend = JPC_CEILDIVPOW2(prc->yend,\n\t\t\t\t\t\t  rlvl->cblkheightexpn) << rlvl->cblkheightexpn;\n\t\t\t\t\t\tprc->numhcblks = (brcblkxend - tlcblkxstart) >>\n\t\t\t\t\t\t  rlvl->cblkwidthexpn;\n\t\t\t\t\t\tprc->numvcblks = (brcblkyend - tlcblkystart) >>\n\t\t\t\t\t\t  rlvl->cblkheightexpn;\n\t\t\t\t\t\tprc->numcblks = prc->numhcblks * prc->numvcblks;\n\t\t\t\t\t\tassert(prc->numcblks > 0);\n\n\t\t\t\t\t\tif (!(prc->incltagtree = jpc_tagtree_create(\n\t\t\t\t\t\t  prc->numhcblks, prc->numvcblks))) {\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!(prc->numimsbstagtree = jpc_tagtree_create(\n\t\t\t\t\t\t  prc->numhcblks, prc->numvcblks))) {\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!(prc->cblks = jas_alloc2(prc->numcblks,\n\t\t\t\t\t\t  sizeof(jpc_dec_cblk_t)))) {\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcblkxstart = cbgxstart;\n\t\t\t\t\t\tcblkystart = cbgystart;\n\t\t\t\t\t\tfor (cblkcnt = prc->numcblks, cblk = prc->cblks; cblkcnt > 0;) {\n\t\t\t\t\t\t\tcblkxend = cblkxstart + (1 << rlvl->cblkwidthexpn);\n\t\t\t\t\t\t\tcblkyend = cblkystart + (1 << rlvl->cblkheightexpn);\n\t\t\t\t\t\t\ttmpxstart = JAS_MAX(cblkxstart, prc->xstart);\n\t\t\t\t\t\t\ttmpystart = JAS_MAX(cblkystart, prc->ystart);\n\t\t\t\t\t\t\ttmpxend = JAS_MIN(cblkxend, prc->xend);\n\t\t\t\t\t\t\ttmpyend = JAS_MIN(cblkyend, prc->yend);\n\t\t\t\t\t\t\tif (tmpxend > tmpxstart && tmpyend > tmpystart) {\n\t\t\t\t\t\t\t\tcblk->firstpassno = -1;\n\t\t\t\t\t\t\t\tcblk->mqdec = 0;\n\t\t\t\t\t\t\t\tcblk->nulldec = 0;\n\t\t\t\t\t\t\t\tcblk->flags = 0;\n\t\t\t\t\t\t\t\tcblk->numpasses = 0;\n\t\t\t\t\t\t\t\tcblk->segs.head = 0;\n\t\t\t\t\t\t\t\tcblk->segs.tail = 0;\n\t\t\t\t\t\t\t\tcblk->curseg = 0;\n\t\t\t\t\t\t\t\tcblk->numimsbs = 0;\n\t\t\t\t\t\t\t\tcblk->numlenbits = 3;\n\t\t\t\t\t\t\t\tcblk->flags = 0;\n\t\t\t\t\t\t\t\tif (!(cblk->data = jas_seq2d_create(0, 0, 0, 0))) {\n\t\t\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tjas_seq2d_bindsub(cblk->data, band->data,\n\t\t\t\t\t\t\t\t  tmpxstart, tmpystart, tmpxend, tmpyend);\n\t\t\t\t\t\t\t\t++cblk;\n\t\t\t\t\t\t\t\t--cblkcnt;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcblkxstart += 1 << rlvl->cblkwidthexpn;\n\t\t\t\t\t\t\tif (cblkxstart >= cbgxend) {\n\t\t\t\t\t\t\t\tcblkxstart = cbgxstart;\n\t\t\t\t\t\t\t\tcblkystart += 1 << rlvl->cblkheightexpn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprc->cblks = 0;\n\t\t\t\t\t\tprc->incltagtree = 0;\n\t\t\t\t\t\tprc->numimsbstagtree = 0;\n\t\t\t\t\t}\n\t\t\t\t\tcbgxstart += 1 << rlvl->cbgwidthexpn;\n\t\t\t\t\tif (cbgxstart >= brcbgxend) {\n\t\t\t\t\t\tcbgxstart = tlcbgxstart;\n\t\t\t\t\t\tcbgystart += 1 << rlvl->cbgheightexpn;\n\t\t\t\t\t}\n\n\t\t\t\t}\n/********************************************/\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!(tile->pi = jpc_dec_pi_create(dec, tile))) {\n\t\treturn -1;\n\t}\n\n\tfor (pchgno = 0; pchgno < jpc_pchglist_numpchgs(tile->cp->pchglist);\n\t  ++pchgno) {\n\t\tpchg = jpc_pchg_copy(jpc_pchglist_get(tile->cp->pchglist, pchgno));\n\t\tassert(pchg);\n\t\tjpc_pi_addpchg(tile->pi, pchg);\n\t}\n\tjpc_pi_init(tile->pi);\n\n\treturn 0;\n}\n\nstatic int jpc_dec_tilefini(jpc_dec_t *dec, jpc_dec_tile_t *tile)\n{\n\tjpc_dec_tcomp_t *tcomp;\n\tint compno;\n\tint bandno;\n\tint rlvlno;\n\tjpc_dec_band_t *band;\n\tjpc_dec_rlvl_t *rlvl;\n\tint prcno;\n\tjpc_dec_prc_t *prc;\n\tjpc_dec_seg_t *seg;\n\tjpc_dec_cblk_t *cblk;\n\tint cblkno;\n\n\tif (tile->tcomps) {\n\n\t\tfor (compno = 0, tcomp = tile->tcomps; compno < dec->numcomps;\n\t\t  ++compno, ++tcomp) {\n\t\t\tfor (rlvlno = 0, rlvl = tcomp->rlvls; rlvlno < tcomp->numrlvls;\n\t\t\t  ++rlvlno, ++rlvl) {\n\t\t\t\tif (!rlvl->bands) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (bandno = 0, band = rlvl->bands; bandno < rlvl->numbands;\n\t\t\t\t  ++bandno, ++band) {\n\t\t\t\t\tif (band->prcs) {\n\t\t\t\t\t\tfor (prcno = 0, prc = band->prcs; prcno <\n\t\t\t\t\t\t  rlvl->numprcs; ++prcno, ++prc) {\n\t\t\t\t\t\t\tif (!prc->cblks) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (cblkno = 0, cblk = prc->cblks; cblkno <\n\t\t\t\t\t\t\t  prc->numcblks; ++cblkno, ++cblk) {\n\n\t\t\t\t\t\t\t\twhile (cblk->segs.head) {\n\t\t\t\t\t\t\t\t\tseg = cblk->segs.head;\n\t\t\t\t\t\t\t\t\tjpc_seglist_remove(&cblk->segs, seg);\n\t\t\t\t\t\t\t\t\tjpc_seg_destroy(seg);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tjas_matrix_destroy(cblk->data);\n\t\t\t\t\t\t\t\tif (cblk->mqdec) {\n\t\t\t\t\t\t\t\t\tjpc_mqdec_destroy(cblk->mqdec);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (cblk->nulldec) {\n\t\t\t\t\t\t\t\t\tjpc_bitstream_close(cblk->nulldec);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (cblk->flags) {\n\t\t\t\t\t\t\t\t\tjas_matrix_destroy(cblk->flags);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (prc->incltagtree) {\n\t\t\t\t\t\t\t\tjpc_tagtree_destroy(prc->incltagtree);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (prc->numimsbstagtree) {\n\t\t\t\t\t\t\t\tjpc_tagtree_destroy(prc->numimsbstagtree);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (prc->cblks) {\n\t\t\t\t\t\t\t\tjas_free(prc->cblks);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (band->data) {\n\t\t\t\t\t\tjas_matrix_destroy(band->data);\n\t\t\t\t\t}\n\t\t\t\t\tif (band->prcs) {\n\t\t\t\t\t\tjas_free(band->prcs);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (rlvl->bands) {\n\t\t\t\t\tjas_free(rlvl->bands);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (tcomp->rlvls) {\n\t\t\t\tjas_free(tcomp->rlvls);\n\t\t\t}\n\t\t\tif (tcomp->data) {\n\t\t\t\tjas_matrix_destroy(tcomp->data);\n\t\t\t}\n\t\t\tif (tcomp->tsfb) {\n\t\t\t\tjpc_tsfb_destroy(tcomp->tsfb);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (tile->cp) {\n\t\tjpc_dec_cp_destroy(tile->cp);\n\t\t//tile->cp = 0;\n\t}\n\tif (tile->tcomps) {\n\t\tjas_free(tile->tcomps);\n\t\t//tile->tcomps = 0;\n\t}\n\tif (tile->pi) {\n\t\tjpc_pi_destroy(tile->pi);\n\t\t//tile->pi = 0;\n\t}\n\tif (tile->pkthdrstream) {\n\t\tjas_stream_close(tile->pkthdrstream);\n\t\t//tile->pkthdrstream = 0;\n\t}\n\tif (tile->pptstab) {\n\t\tjpc_ppxstab_destroy(tile->pptstab);\n\t\t//tile->pptstab = 0;\n\t}\n\n\ttile->state = JPC_TILE_DONE;\n\n\treturn 0;\n}\n\nstatic int jpc_dec_tiledecode(jpc_dec_t *dec, jpc_dec_tile_t *tile)\n{\n\tint i;\n\tint j;\n\tjpc_dec_tcomp_t *tcomp;\n\tjpc_dec_rlvl_t *rlvl;\n\tjpc_dec_band_t *band;\n\tint compno;\n\tint rlvlno;\n\tint bandno;\n\tint adjust;\n\tint v;\n\tjpc_dec_ccp_t *ccp;\n\tjpc_dec_cmpt_t *cmpt;\n\n\tif (jpc_dec_decodecblks(dec, tile)) {\n\t\tjas_eprintf(\"jpc_dec_decodecblks failed\\n\");\n\t\treturn -1;\n\t}\n\n\t/* Perform dequantization. */\n\tfor (compno = 0, tcomp = tile->tcomps; compno < dec->numcomps;\n\t  ++compno, ++tcomp) {\n\t\tccp = &tile->cp->ccps[compno];\n\t\tfor (rlvlno = 0, rlvl = tcomp->rlvls; rlvlno < tcomp->numrlvls;\n\t\t  ++rlvlno, ++rlvl) {\n\t\t\tif (!rlvl->bands) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (bandno = 0, band = rlvl->bands;\n\t\t\t  bandno < rlvl->numbands; ++bandno, ++band) {\n\t\t\t\tif (!band->data) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tjpc_undo_roi(band->data, band->roishift, ccp->roishift -\n\t\t\t\t  band->roishift, band->numbps);\n\t\t\t\tif (tile->realmode) {\n\t\t\t\t\tjas_matrix_asl(band->data, JPC_FIX_FRACBITS);\n\t\t\t\t\tjpc_dequantize(band->data, band->absstepsize);\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Apply an inverse wavelet transform if necessary. */\n\tfor (compno = 0, tcomp = tile->tcomps; compno < dec->numcomps;\n\t  ++compno, ++tcomp) {\n\t\tccp = &tile->cp->ccps[compno];\n\t\tjpc_tsfb_synthesize(tcomp->tsfb, tcomp->data);\n\t}\n\n\n\t/* Apply an inverse intercomponent transform if necessary. */\n\tswitch (tile->cp->mctid) {\n\tcase JPC_MCT_RCT:\n\t\tif (dec->numcomps < 3) {\n\t\t\tjas_eprintf(\"RCT requires at least three components\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (!jas_image_cmpt_domains_same(dec->image)) {\n\t\t\tjas_eprintf(\"RCT requires all components have the same domain\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_irct(tile->tcomps[0].data, tile->tcomps[1].data,\n\t\t  tile->tcomps[2].data);\n\t\tbreak;\n\tcase JPC_MCT_ICT:\n\t\tif (dec->numcomps < 3) {\n\t\t\tjas_eprintf(\"ICT requires at least three components\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (!jas_image_cmpt_domains_same(dec->image)) {\n\t\t\tjas_eprintf(\"RCT requires all components have the same domain\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_iict(tile->tcomps[0].data, tile->tcomps[1].data,\n\t\t  tile->tcomps[2].data);\n\t\tbreak;\n\t}\n\n\t/* Perform rounding and convert to integer values. */\n\tif (tile->realmode) {\n\t\tfor (compno = 0, tcomp = tile->tcomps; compno < dec->numcomps;\n\t\t  ++compno, ++tcomp) {\n\t\t\tfor (i = 0; i < jas_matrix_numrows(tcomp->data); ++i) {\n\t\t\t\tfor (j = 0; j < jas_matrix_numcols(tcomp->data); ++j) {\n\t\t\t\t\tv = jas_matrix_get(tcomp->data, i, j);\n\t\t\t\t\tv = jpc_fix_round(v);\n\t\t\t\t\tjas_matrix_set(tcomp->data, i, j, jpc_fixtoint(v));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Perform level shift. */\n\tfor (compno = 0, tcomp = tile->tcomps, cmpt = dec->cmpts; compno <\n\t  dec->numcomps; ++compno, ++tcomp, ++cmpt) {\n\t\tadjust = cmpt->sgnd ? 0 : (1 << (cmpt->prec - 1));\n\t\tfor (i = 0; i < jas_matrix_numrows(tcomp->data); ++i) {\n\t\t\tfor (j = 0; j < jas_matrix_numcols(tcomp->data); ++j) {\n\t\t\t\t*jas_matrix_getref(tcomp->data, i, j) += adjust;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Perform clipping. */\n\tfor (compno = 0, tcomp = tile->tcomps, cmpt = dec->cmpts; compno <\n\t  dec->numcomps; ++compno, ++tcomp, ++cmpt) {\n\t\tjpc_fix_t mn;\n\t\tjpc_fix_t mx;\n\t\tmn = cmpt->sgnd ? (-(1 << (cmpt->prec - 1))) : (0);\n\t\tmx = cmpt->sgnd ? ((1 << (cmpt->prec - 1)) - 1) : ((1 <<\n\t\t  cmpt->prec) - 1);\n\t\tjas_matrix_clip(tcomp->data, mn, mx);\n\t}\n\n\t/* XXX need to free tsfb struct */\n\n\t/* Write the data for each component of the image. */\n\tfor (compno = 0, tcomp = tile->tcomps, cmpt = dec->cmpts; compno <\n\t  dec->numcomps; ++compno, ++tcomp, ++cmpt) {\n\t\tif (jas_image_writecmpt(dec->image, compno, tcomp->xstart -\n\t\t  JPC_CEILDIV(dec->xstart, cmpt->hstep), tcomp->ystart -\n\t\t  JPC_CEILDIV(dec->ystart, cmpt->vstep), jas_matrix_numcols(\n\t\t  tcomp->data), jas_matrix_numrows(tcomp->data), tcomp->data)) {\n\t\t\tjas_eprintf(\"write component failed\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int jpc_dec_process_eoc(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tint tileno;\n\tjpc_dec_tile_t *tile;\n\n\t/* Eliminate compiler warnings about unused variables. */\n\tms = 0;\n\n\tfor (tileno = 0, tile = dec->tiles; tileno < dec->numtiles; ++tileno,\n\t  ++tile) {\n\t\tif (tile->state == JPC_TILE_ACTIVE) {\n\t\t\tif (jpc_dec_tiledecode(dec, tile)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\t/* If the tile has not yet been finalized, finalize it. */\n\t\t// OLD CODE: jpc_dec_tilefini(dec, tile);\n\t\tif (tile->state != JPC_TILE_DONE) {\n\t\t\tjpc_dec_tilefini(dec, tile);\n\t\t}\n\t}\n\n\t/* We are done processing the code stream. */\n\tdec->state = JPC_MT;\n\n\treturn 1;\n}\n\nstatic int jpc_dec_process_siz(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_siz_t *siz = &ms->parms.siz;\n\tint compno;\n\tint tileno;\n\tjpc_dec_tile_t *tile;\n\tjpc_dec_tcomp_t *tcomp;\n\tint htileno;\n\tint vtileno;\n\tjpc_dec_cmpt_t *cmpt;\n\tsize_t size;\n\n\tdec->xstart = siz->xoff;\n\tdec->ystart = siz->yoff;\n\tdec->xend = siz->width;\n\tdec->yend = siz->height;\n\tdec->tilewidth = siz->tilewidth;\n\tdec->tileheight = siz->tileheight;\n\tdec->tilexoff = siz->tilexoff;\n\tdec->tileyoff = siz->tileyoff;\n\tdec->numcomps = siz->numcomps;\n\tif (!(dec->cp = jpc_dec_cp_create(dec->numcomps))) {\n\t\treturn -1;\n\t}\n\n\tif (!(dec->cmpts = jas_alloc2(dec->numcomps, sizeof(jpc_dec_cmpt_t)))) {\n\t\treturn -1;\n\t}\n\n\tfor (compno = 0, cmpt = dec->cmpts; compno < dec->numcomps; ++compno,\n\t  ++cmpt) {\n\t\tcmpt->prec = siz->comps[compno].prec;\n\t\tcmpt->sgnd = siz->comps[compno].sgnd;\n\t\tcmpt->hstep = siz->comps[compno].hsamp;\n\t\tcmpt->vstep = siz->comps[compno].vsamp;\n\t\tcmpt->width = JPC_CEILDIV(dec->xend, cmpt->hstep) -\n\t\t  JPC_CEILDIV(dec->xstart, cmpt->hstep);\n\t\tcmpt->height = JPC_CEILDIV(dec->yend, cmpt->vstep) -\n\t\t  JPC_CEILDIV(dec->ystart, cmpt->vstep);\n\t\tcmpt->hsubstep = 0;\n\t\tcmpt->vsubstep = 0;\n\t}\n\n\tdec->image = 0;\n\n\tdec->numhtiles = JPC_CEILDIV(dec->xend - dec->tilexoff, dec->tilewidth);\n\tdec->numvtiles = JPC_CEILDIV(dec->yend - dec->tileyoff, dec->tileheight);\n\tif (!jas_safe_size_mul(dec->numhtiles, dec->numvtiles, &size)) {\n\t\treturn -1;\n\t}\n\tdec->numtiles = size;\n\tJAS_DBGLOG(10, (\"numtiles = %d; numhtiles = %d; numvtiles = %d;\\n\",\n\t  dec->numtiles, dec->numhtiles, dec->numvtiles));\n\tif (!(dec->tiles = jas_alloc2(dec->numtiles, sizeof(jpc_dec_tile_t)))) {\n\t\treturn -1;\n\t}\n\n\tfor (tileno = 0, tile = dec->tiles; tileno < dec->numtiles; ++tileno,\n\t  ++tile) {\n\t\thtileno = tileno % dec->numhtiles;\n\t\tvtileno = tileno / dec->numhtiles;\n\t\ttile->realmode = 0;\n\t\ttile->state = JPC_TILE_INIT;\n\t\ttile->xstart = JAS_MAX(dec->tilexoff + htileno * dec->tilewidth,\n\t\t  dec->xstart);\n\t\ttile->ystart = JAS_MAX(dec->tileyoff + vtileno * dec->tileheight,\n\t\t  dec->ystart);\n\t\ttile->xend = JAS_MIN(dec->tilexoff + (htileno + 1) *\n\t\t  dec->tilewidth, dec->xend);\n\t\ttile->yend = JAS_MIN(dec->tileyoff + (vtileno + 1) *\n\t\t  dec->tileheight, dec->yend);\n\t\ttile->numparts = 0;\n\t\ttile->partno = 0;\n\t\ttile->pkthdrstream = 0;\n\t\ttile->pkthdrstreampos = 0;\n\t\ttile->pptstab = 0;\n\t\ttile->cp = 0;\n\t\ttile->pi = 0;\n\t\tif (!(tile->tcomps = jas_alloc2(dec->numcomps,\n\t\t  sizeof(jpc_dec_tcomp_t)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor (compno = 0, cmpt = dec->cmpts, tcomp = tile->tcomps;\n\t\t  compno < dec->numcomps; ++compno, ++cmpt, ++tcomp) {\n\t\t\ttcomp->rlvls = 0;\n\t\t\ttcomp->numrlvls = 0;\n\t\t\ttcomp->data = 0;\n\t\t\ttcomp->xstart = JPC_CEILDIV(tile->xstart, cmpt->hstep);\n\t\t\ttcomp->ystart = JPC_CEILDIV(tile->ystart, cmpt->vstep);\n\t\t\ttcomp->xend = JPC_CEILDIV(tile->xend, cmpt->hstep);\n\t\t\ttcomp->yend = JPC_CEILDIV(tile->yend, cmpt->vstep);\n\t\t\ttcomp->tsfb = 0;\n\t\t}\n\t}\n\n\tdec->pkthdrstreams = 0;\n\n\t/* We should expect to encounter other main header marker segments\n\t  or an SOT marker segment next. */\n\tdec->state = JPC_MH;\n\n\treturn 0;\n}\n\nstatic int jpc_dec_process_cod(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_cod_t *cod = &ms->parms.cod;\n\tjpc_dec_tile_t *tile;\n\n\tswitch (dec->state) {\n\tcase JPC_MH:\n\t\tjpc_dec_cp_setfromcod(dec->cp, cod);\n\t\tbreak;\n\tcase JPC_TPH:\n\t\tif (!(tile = dec->curtile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (tile->partno != 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_setfromcod(tile->cp, cod);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_coc(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_coc_t *coc = &ms->parms.coc;\n\tjpc_dec_tile_t *tile;\n\n\tif (JAS_CAST(int, coc->compno) >= dec->numcomps) {\n\t\tjas_eprintf(\"invalid component number in COC marker segment\\n\");\n\t\treturn -1;\n\t}\n\tswitch (dec->state) {\n\tcase JPC_MH:\n\t\tjpc_dec_cp_setfromcoc(dec->cp, coc);\n\t\tbreak;\n\tcase JPC_TPH:\n\t\tif (!(tile = dec->curtile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (tile->partno > 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_setfromcoc(tile->cp, coc);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_rgn(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_rgn_t *rgn = &ms->parms.rgn;\n\tjpc_dec_tile_t *tile;\n\n\tif (JAS_CAST(int, rgn->compno) >= dec->numcomps) {\n\t\tjas_eprintf(\"invalid component number in RGN marker segment\\n\");\n\t\treturn -1;\n\t}\n\tswitch (dec->state) {\n\tcase JPC_MH:\n\t\tjpc_dec_cp_setfromrgn(dec->cp, rgn);\n\t\tbreak;\n\tcase JPC_TPH:\n\t\tif (!(tile = dec->curtile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (tile->partno > 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_setfromrgn(tile->cp, rgn);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int jpc_dec_process_qcd(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_qcd_t *qcd = &ms->parms.qcd;\n\tjpc_dec_tile_t *tile;\n\n\tswitch (dec->state) {\n\tcase JPC_MH:\n\t\tjpc_dec_cp_setfromqcd(dec->cp, qcd);\n\t\tbreak;\n\tcase JPC_TPH:\n\t\tif (!(tile = dec->curtile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (tile->partno > 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_setfromqcd(tile->cp, qcd);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_qcc(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_qcc_t *qcc = &ms->parms.qcc;\n\tjpc_dec_tile_t *tile;\n\n\tif (JAS_CAST(int, qcc->compno) >= dec->numcomps) {\n\t\tjas_eprintf(\"invalid component number in QCC marker segment\\n\");\n\t\treturn -1;\n\t}\n\tswitch (dec->state) {\n\tcase JPC_MH:\n\t\tjpc_dec_cp_setfromqcc(dec->cp, qcc);\n\t\tbreak;\n\tcase JPC_TPH:\n\t\tif (!(tile = dec->curtile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (tile->partno > 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_setfromqcc(tile->cp, qcc);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_poc(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_poc_t *poc = &ms->parms.poc;\n\tjpc_dec_tile_t *tile;\n\tswitch (dec->state) {\n\tcase JPC_MH:\n\t\tif (jpc_dec_cp_setfrompoc(dec->cp, poc, 1)) {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tcase JPC_TPH:\n\t\tif (!(tile = dec->curtile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (!tile->partno) {\n\t\t\tif (jpc_dec_cp_setfrompoc(tile->cp, poc, (!tile->partno))) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\tjpc_pi_addpchgfrompoc(tile->pi, poc);\n\t\t}\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_ppm(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_ppm_t *ppm = &ms->parms.ppm;\n\tjpc_ppxstabent_t *ppmstabent;\n\n\tif (!dec->ppmstab) {\n\t\tif (!(dec->ppmstab = jpc_ppxstab_create())) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (!(ppmstabent = jpc_ppxstabent_create())) {\n\t\treturn -1;\n\t}\n\tppmstabent->ind = ppm->ind;\n\tppmstabent->data = ppm->data;\n\tppm->data = 0;\n\tppmstabent->len = ppm->len;\n\tif (jpc_ppxstab_insert(dec->ppmstab, ppmstabent)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_ppt(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_ppt_t *ppt = &ms->parms.ppt;\n\tjpc_dec_tile_t *tile;\n\tjpc_ppxstabent_t *pptstabent;\n\n\ttile = dec->curtile;\n\tif (!tile->pptstab) {\n\t\tif (!(tile->pptstab = jpc_ppxstab_create())) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (!(pptstabent = jpc_ppxstabent_create())) {\n\t\treturn -1;\n\t}\n\tpptstabent->ind = ppt->ind;\n\tpptstabent->data = ppt->data;\n\tppt->data = 0;\n\tpptstabent->len = ppt->len;\n\tif (jpc_ppxstab_insert(tile->pptstab, pptstabent)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_process_com(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\t/* Eliminate compiler warnings about unused variables. */\n\tdec = 0;\n\tms = 0;\n\n\treturn 0;\n}\n\nstatic int jpc_dec_process_unk(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\t/* Eliminate compiler warnings about unused variables. */\n\tdec = 0;\n\n\tjas_eprintf(\"warning: ignoring unknown marker segment\\n\");\n\tjpc_ms_dump(ms, stderr);\n\treturn 0;\n}\n\n/******************************************************************************\\\n*\n\\******************************************************************************/\n\nstatic jpc_dec_cp_t *jpc_dec_cp_create(uint_fast16_t numcomps)\n{\n\tjpc_dec_cp_t *cp;\n\tjpc_dec_ccp_t *ccp;\n\tint compno;\n\n\tif (!(cp = jas_malloc(sizeof(jpc_dec_cp_t)))) {\n\t\treturn 0;\n\t}\n\tcp->flags = 0;\n\tcp->numcomps = numcomps;\n\tcp->prgord = 0;\n\tcp->numlyrs = 0;\n\tcp->mctid = 0;\n\tcp->csty = 0;\n\tif (!(cp->ccps = jas_alloc2(cp->numcomps, sizeof(jpc_dec_ccp_t)))) {\n\t\tgoto error;\n\t}\n\tif (!(cp->pchglist = jpc_pchglist_create())) {\n\t\tgoto error;\n\t}\n\tfor (compno = 0, ccp = cp->ccps; compno < cp->numcomps;\n\t  ++compno, ++ccp) {\n\t\tccp->flags = 0;\n\t\tccp->numrlvls = 0;\n\t\tccp->cblkwidthexpn = 0;\n\t\tccp->cblkheightexpn = 0;\n\t\tccp->qmfbid = 0;\n\t\tccp->numstepsizes = 0;\n\t\tccp->numguardbits = 0;\n\t\tccp->roishift = 0;\n\t\tccp->cblkctx = 0;\n\t}\n\treturn cp;\nerror:\n\tif (cp) {\n\t\tjpc_dec_cp_destroy(cp);\n\t}\n\treturn 0;\n}\n\nstatic jpc_dec_cp_t *jpc_dec_cp_copy(jpc_dec_cp_t *cp)\n{\n\tjpc_dec_cp_t *newcp;\n\tjpc_dec_ccp_t *newccp;\n\tjpc_dec_ccp_t *ccp;\n\tint compno;\n\n\tif (!(newcp = jpc_dec_cp_create(cp->numcomps))) {\n\t\treturn 0;\n\t}\n\tnewcp->flags = cp->flags;\n\tnewcp->prgord = cp->prgord;\n\tnewcp->numlyrs = cp->numlyrs;\n\tnewcp->mctid = cp->mctid;\n\tnewcp->csty = cp->csty;\n\tjpc_pchglist_destroy(newcp->pchglist);\n\tnewcp->pchglist = 0;\n\tif (!(newcp->pchglist = jpc_pchglist_copy(cp->pchglist))) {\n\t\tjas_free(newcp);\n\t\treturn 0;\n\t}\n\tfor (compno = 0, newccp = newcp->ccps, ccp = cp->ccps;\n\t  compno < cp->numcomps;\n\t  ++compno, ++newccp, ++ccp) {\n\t\t*newccp = *ccp;\n\t}\n\treturn newcp;\n}\n\nstatic void jpc_dec_cp_resetflags(jpc_dec_cp_t *cp)\n{\n\tint compno;\n\tjpc_dec_ccp_t *ccp;\n\tcp->flags &= (JPC_CSET | JPC_QSET);\n\tfor (compno = 0, ccp = cp->ccps; compno < cp->numcomps;\n\t  ++compno, ++ccp) {\n\t\tccp->flags = 0;\n\t}\n}\n\nstatic void jpc_dec_cp_destroy(jpc_dec_cp_t *cp)\n{\n\tif (cp->ccps) {\n\t\tjas_free(cp->ccps);\n\t}\n\tif (cp->pchglist) {\n\t\tjpc_pchglist_destroy(cp->pchglist);\n\t}\n\tjas_free(cp);\n}\n\nstatic int jpc_dec_cp_isvalid(jpc_dec_cp_t *cp)\n{\n\tuint_fast16_t compcnt;\n\tjpc_dec_ccp_t *ccp;\n\n\tif (!(cp->flags & JPC_CSET) || !(cp->flags & JPC_QSET)) {\n\t\treturn 0;\n\t}\n\tfor (compcnt = cp->numcomps, ccp = cp->ccps; compcnt > 0; --compcnt,\n\t  ++ccp) {\n\t\t/* Is there enough step sizes for the number of bands? */\n\t\tif ((ccp->qsty != JPC_QCX_SIQNT && JAS_CAST(int, ccp->numstepsizes) < 3 *\n\t\t  ccp->numrlvls - 2) || (ccp->qsty == JPC_QCX_SIQNT &&\n\t\t  ccp->numstepsizes != 1)) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic void calcstepsizes(uint_fast16_t refstepsize, int numrlvls,\n  uint_fast16_t *stepsizes)\n{\n\tint bandno;\n\tint numbands;\n\tuint_fast16_t expn;\n\tuint_fast16_t mant;\n\texpn = JPC_QCX_GETEXPN(refstepsize);\n\tmant = JPC_QCX_GETMANT(refstepsize);\n\tnumbands = 3 * numrlvls - 2;\n\tfor (bandno = 0; bandno < numbands; ++bandno) {\n//jas_eprintf(\"DEBUG %d %d %d %d %d\\n\", bandno, expn, numrlvls, bandno, ((numrlvls - 1) - (numrlvls - 1 - ((bandno > 0) ? ((bandno + 2) / 3) : (0)))));\n\t\tstepsizes[bandno] = JPC_QCX_MANT(mant) | JPC_QCX_EXPN(expn +\n\t\t  (numrlvls - 1) - (numrlvls - 1 - ((bandno > 0) ? ((bandno + 2) / 3) : (0))));\n\t}\n}\n\nstatic int jpc_dec_cp_prepare(jpc_dec_cp_t *cp)\n{\n\tjpc_dec_ccp_t *ccp;\n\tint compno;\n\tint i;\n\tfor (compno = 0, ccp = cp->ccps; compno < cp->numcomps;\n\t  ++compno, ++ccp) {\n\t\tif (!(ccp->csty & JPC_COX_PRT)) {\n\t\t\tfor (i = 0; i < JPC_MAXRLVLS; ++i) {\n\t\t\t\tccp->prcwidthexpns[i] = 15;\n\t\t\t\tccp->prcheightexpns[i] = 15;\n\t\t\t}\n\t\t}\n\t\tif (ccp->qsty == JPC_QCX_SIQNT) {\n\t\t\tcalcstepsizes(ccp->stepsizes[0], ccp->numrlvls, ccp->stepsizes);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_cp_setfromcod(jpc_dec_cp_t *cp, jpc_cod_t *cod)\n{\n\tjpc_dec_ccp_t *ccp;\n\tint compno;\n\tcp->flags |= JPC_CSET;\n\tcp->prgord = cod->prg;\n\tif (cod->mctrans) {\n\t\tcp->mctid = (cod->compparms.qmfbid == JPC_COX_INS) ? (JPC_MCT_ICT) : (JPC_MCT_RCT);\n\t} else {\n\t\tcp->mctid = JPC_MCT_NONE;\n\t}\n\tcp->numlyrs = cod->numlyrs;\n\tcp->csty = cod->csty & (JPC_COD_SOP | JPC_COD_EPH);\n\tfor (compno = 0, ccp = cp->ccps; compno < cp->numcomps;\n\t  ++compno, ++ccp) {\n\t\tjpc_dec_cp_setfromcox(cp, ccp, &cod->compparms, 0);\n\t}\n\tcp->flags |= JPC_CSET;\n\treturn 0;\n}\n\nstatic int jpc_dec_cp_setfromcoc(jpc_dec_cp_t *cp, jpc_coc_t *coc)\n{\n\tjpc_dec_cp_setfromcox(cp, &cp->ccps[coc->compno], &coc->compparms, JPC_COC);\n\treturn 0;\n}\n\nstatic int jpc_dec_cp_setfromcox(jpc_dec_cp_t *cp, jpc_dec_ccp_t *ccp,\n  jpc_coxcp_t *compparms, int flags)\n{\n\tint rlvlno;\n\n\t/* Eliminate compiler warnings about unused variables. */\n\tcp = 0;\n\n\tif ((flags & JPC_COC) || !(ccp->flags & JPC_COC)) {\n\t\tccp->numrlvls = compparms->numdlvls + 1;\n\t\tccp->cblkwidthexpn = JPC_COX_GETCBLKSIZEEXPN(\n\t\t  compparms->cblkwidthval);\n\t\tccp->cblkheightexpn = JPC_COX_GETCBLKSIZEEXPN(\n\t\t  compparms->cblkheightval);\n\t\tccp->qmfbid = compparms->qmfbid;\n\t\tccp->cblkctx = compparms->cblksty;\n\t\tccp->csty = compparms->csty & JPC_COX_PRT;\n\t\tfor (rlvlno = 0; rlvlno < compparms->numrlvls; ++rlvlno) {\n\t\t\tccp->prcwidthexpns[rlvlno] =\n\t\t\t  compparms->rlvls[rlvlno].parwidthval;\n\t\t\tccp->prcheightexpns[rlvlno] =\n\t\t\t  compparms->rlvls[rlvlno].parheightval;\n\t\t}\n\t\tccp->flags |= flags | JPC_CSET;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_cp_setfromqcd(jpc_dec_cp_t *cp, jpc_qcd_t *qcd)\n{\n\tint compno;\n\tjpc_dec_ccp_t *ccp;\n\tfor (compno = 0, ccp = cp->ccps; compno < cp->numcomps;\n\t  ++compno, ++ccp) {\n\t\tjpc_dec_cp_setfromqcx(cp, ccp, &qcd->compparms, 0);\n\t}\n\tcp->flags |= JPC_QSET;\n\treturn 0;\n}\n\nstatic int jpc_dec_cp_setfromqcc(jpc_dec_cp_t *cp, jpc_qcc_t *qcc)\n{\n\treturn jpc_dec_cp_setfromqcx(cp, &cp->ccps[qcc->compno], &qcc->compparms, JPC_QCC);\n}\n\nstatic int jpc_dec_cp_setfromqcx(jpc_dec_cp_t *cp, jpc_dec_ccp_t *ccp,\n  jpc_qcxcp_t *compparms, int flags)\n{\n\tint bandno;\n\n\t/* Eliminate compiler warnings about unused variables. */\n\tcp = 0;\n\n\tif ((flags & JPC_QCC) || !(ccp->flags & JPC_QCC)) {\n\t\tccp->flags |= flags | JPC_QSET;\n\t\tfor (bandno = 0; bandno < compparms->numstepsizes; ++bandno) {\n\t\t\tccp->stepsizes[bandno] = compparms->stepsizes[bandno];\n\t\t}\n\t\tccp->numstepsizes = compparms->numstepsizes;\n\t\tccp->numguardbits = compparms->numguard;\n\t\tccp->qsty = compparms->qntsty;\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_cp_setfromrgn(jpc_dec_cp_t *cp, jpc_rgn_t *rgn)\n{\n\tjpc_dec_ccp_t *ccp;\n\tccp = &cp->ccps[rgn->compno];\n\tccp->roishift = rgn->roishift;\n\treturn 0;\n}\n\nstatic int jpc_pi_addpchgfrompoc(jpc_pi_t *pi, jpc_poc_t *poc)\n{\n\tint pchgno;\n\tjpc_pchg_t *pchg;\n\tfor (pchgno = 0; pchgno < poc->numpchgs; ++pchgno) {\n\t\tif (!(pchg = jpc_pchg_copy(&poc->pchgs[pchgno]))) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (jpc_pchglist_insert(pi->pchglist, -1, pchg)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int jpc_dec_cp_setfrompoc(jpc_dec_cp_t *cp, jpc_poc_t *poc, int reset)\n{\n\tint pchgno;\n\tjpc_pchg_t *pchg;\n\tif (reset) {\n\t\twhile (jpc_pchglist_numpchgs(cp->pchglist) > 0) {\n\t\t\tpchg = jpc_pchglist_remove(cp->pchglist, 0);\n\t\t\tjpc_pchg_destroy(pchg);\n\t\t}\n\t}\n\tfor (pchgno = 0; pchgno < poc->numpchgs; ++pchgno) {\n\t\tif (!(pchg = jpc_pchg_copy(&poc->pchgs[pchgno]))) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (jpc_pchglist_insert(cp->pchglist, -1, pchg)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic jpc_fix_t jpc_calcabsstepsize(int stepsize, int numbits)\n{\n\tjpc_fix_t absstepsize;\n\tint n;\n\n\tabsstepsize = jpc_inttofix(1);\n\tn = JPC_FIX_FRACBITS - 11;\n\tabsstepsize |= (n >= 0) ? (JPC_QCX_GETMANT(stepsize) << n) :\n\t  (JPC_QCX_GETMANT(stepsize) >> (-n));\n\tn = numbits - JPC_QCX_GETEXPN(stepsize);\n\tabsstepsize = (n >= 0) ? (absstepsize << n) : (absstepsize >> (-n));\n\treturn absstepsize;\n}\n\nstatic void jpc_dequantize(jas_matrix_t *x, jpc_fix_t absstepsize)\n{\n\tint i;\n\tint j;\n\tint t;\n\n\tassert(absstepsize >= 0);\n\tif (absstepsize == jpc_inttofix(1)) {\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < jas_matrix_numrows(x); ++i) {\n\t\tfor (j = 0; j < jas_matrix_numcols(x); ++j) {\n\t\t\tt = jas_matrix_get(x, i, j);\n\t\t\tif (t) {\n\t\t\t\tt = jpc_fix_mul(t, absstepsize);\n\t\t\t} else {\n\t\t\t\tt = 0;\n\t\t\t}\n\t\t\tjas_matrix_set(x, i, j, t);\n\t\t}\n\t}\n\n}\n\nstatic void jpc_undo_roi(jas_matrix_t *x, int roishift, int bgshift, int numbps)\n{\n\tint i;\n\tint j;\n\tint thresh;\n\tjpc_fix_t val;\n\tjpc_fix_t mag;\n\tbool warn;\n\tuint_fast32_t mask;\n\n\tif (roishift < 0) {\n\t\t/* We could instead return an error here. */\n\t\t/* I do not think it matters much. */\n\t\tjas_eprintf(\"warning: forcing negative ROI shift to zero \"\n\t\t  \"(bitstream is probably corrupt)\\n\");\n\t\troishift = 0;\n\t}\n\tif (roishift == 0 && bgshift == 0) {\n\t\treturn;\n\t}\n\tthresh = 1 << roishift;\n\n\twarn = false;\n\tfor (i = 0; i < jas_matrix_numrows(x); ++i) {\n\t\tfor (j = 0; j < jas_matrix_numcols(x); ++j) {\n\t\t\tval = jas_matrix_get(x, i, j);\n\t\t\tmag = JAS_ABS(val);\n\t\t\tif (mag >= thresh) {\n\t\t\t\t/* We are dealing with ROI data. */\n\t\t\t\tmag >>= roishift;\n\t\t\t\tval = (val < 0) ? (-mag) : mag;\n\t\t\t\tjas_matrix_set(x, i, j, val);\n\t\t\t} else {\n\t\t\t\t/* We are dealing with non-ROI (i.e., background) data. */\n\t\t\t\tmag <<= bgshift;\n\t\t\t\tmask = (JAS_CAST(uint_fast32_t, 1) << numbps) - 1;\n\t\t\t\t/* Perform a basic sanity check on the sample value. */\n\t\t\t\t/* Some implementations write garbage in the unused\n\t\t\t\t  most-significant bit planes introduced by ROI shifting.\n\t\t\t\t  Here we ensure that any such bits are masked off. */\n\t\t\t\tif (mag & (~mask)) {\n\t\t\t\t\tif (!warn) {\n\t\t\t\t\t\tjas_eprintf(\"warning: possibly corrupt code stream\\n\");\n\t\t\t\t\t\twarn = true;\n\t\t\t\t\t}\n\t\t\t\t\tmag &= mask;\n\t\t\t\t}\n\t\t\t\tval = (val < 0) ? (-mag) : mag;\n\t\t\t\tjas_matrix_set(x, i, j, val);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic jpc_dec_t *jpc_dec_create(jpc_dec_importopts_t *impopts, jas_stream_t *in)\n{\n\tjpc_dec_t *dec;\n\n\tif (!(dec = jas_malloc(sizeof(jpc_dec_t)))) {\n\t\treturn 0;\n\t}\n\n\tdec->image = 0;\n\tdec->xstart = 0;\n\tdec->ystart = 0;\n\tdec->xend = 0;\n\tdec->yend = 0;\n\tdec->tilewidth = 0;\n\tdec->tileheight = 0;\n\tdec->tilexoff = 0;\n\tdec->tileyoff = 0;\n\tdec->numhtiles = 0;\n\tdec->numvtiles = 0;\n\tdec->numtiles = 0;\n\tdec->tiles = 0;\n\tdec->curtile = 0;\n\tdec->numcomps = 0;\n\tdec->in = in;\n\tdec->cp = 0;\n\tdec->maxlyrs = impopts->maxlyrs;\n\tdec->maxpkts = impopts->maxpkts;\ndec->numpkts = 0;\n\tdec->ppmseqno = 0;\n\tdec->state = 0;\n\tdec->cmpts = 0;\n\tdec->pkthdrstreams = 0;\n\tdec->ppmstab = 0;\n\tdec->curtileendoff = 0;\n\n\treturn dec;\n}\n\nstatic void jpc_dec_destroy(jpc_dec_t *dec)\n{\n\tif (dec->cstate) {\n\t\tjpc_cstate_destroy(dec->cstate);\n\t}\n\tif (dec->pkthdrstreams) {\n\t\tjpc_streamlist_destroy(dec->pkthdrstreams);\n\t}\n\tif (dec->image) {\n\t\tjas_image_destroy(dec->image);\n\t}\n\n\tif (dec->cp) {\n\t\tjpc_dec_cp_destroy(dec->cp);\n\t}\n\n\tif (dec->cmpts) {\n\t\tjas_free(dec->cmpts);\n\t}\n\n\tif (dec->tiles) {\n\t\tjas_free(dec->tiles);\n\t}\n\n\tjas_free(dec);\n}\n\n/******************************************************************************\\\n*\n\\******************************************************************************/\n\nvoid jpc_seglist_insert(jpc_dec_seglist_t *list, jpc_dec_seg_t *ins, jpc_dec_seg_t *node)\n{\n\tjpc_dec_seg_t *prev;\n\tjpc_dec_seg_t *next;\n\n\tprev = ins;\n\tnode->prev = prev;\n\tnext = prev ? (prev->next) : 0;\n\tnode->prev = prev;\n\tnode->next = next;\n\tif (prev) {\n\t\tprev->next = node;\n\t} else {\n\t\tlist->head = node;\n\t}\n\tif (next) {\n\t\tnext->prev = node;\n\t} else {\n\t\tlist->tail = node;\n\t}\n}\n\nvoid jpc_seglist_remove(jpc_dec_seglist_t *list, jpc_dec_seg_t *seg)\n{\n\tjpc_dec_seg_t *prev;\n\tjpc_dec_seg_t *next;\n\n\tprev = seg->prev;\n\tnext = seg->next;\n\tif (prev) {\n\t\tprev->next = next;\n\t} else {\n\t\tlist->head = next;\n\t}\n\tif (next) {\n\t\tnext->prev = prev;\n\t} else {\n\t\tlist->tail = prev;\n\t}\n\tseg->prev = 0;\n\tseg->next = 0;\n}\n\njpc_dec_seg_t *jpc_seg_alloc()\n{\n\tjpc_dec_seg_t *seg;\n\n\tif (!(seg = jas_malloc(sizeof(jpc_dec_seg_t)))) {\n\t\treturn 0;\n\t}\n\tseg->prev = 0;\n\tseg->next = 0;\n\tseg->passno = -1;\n\tseg->numpasses = 0;\n\tseg->maxpasses = 0;\n\tseg->type = JPC_SEG_INVALID;\n\tseg->stream = 0;\n\tseg->cnt = 0;\n\tseg->complete = 0;\n\tseg->lyrno = -1;\n\treturn seg;\n}\n\nvoid jpc_seg_destroy(jpc_dec_seg_t *seg)\n{\n\tif (seg->stream) {\n\t\tjas_stream_close(seg->stream);\n\t}\n\tjas_free(seg);\n}\n\nstatic int jpc_dec_dump(jpc_dec_t *dec, FILE *out)\n{\n\tjpc_dec_tile_t *tile;\n\tint tileno;\n\tjpc_dec_tcomp_t *tcomp;\n\tint compno;\n\tjpc_dec_rlvl_t *rlvl;\n\tint rlvlno;\n\tjpc_dec_band_t *band;\n\tint bandno;\n\tjpc_dec_prc_t *prc;\n\tint prcno;\n\tjpc_dec_cblk_t *cblk;\n\tint cblkno;\n\n\tfor (tileno = 0, tile = dec->tiles; tileno < dec->numtiles;\n\t  ++tileno, ++tile) {\n\t\tfor (compno = 0, tcomp = tile->tcomps; compno < dec->numcomps;\n\t\t  ++compno, ++tcomp) {\n\t\t\tfor (rlvlno = 0, rlvl = tcomp->rlvls; rlvlno <\n\t\t\t  tcomp->numrlvls; ++rlvlno, ++rlvl) {\n\t\t\t\tfprintf(out, \"RESOLUTION LEVEL %d\\n\", rlvlno);\n\t\t\t\tfprintf(out, \"xs =%\"PRIuFAST32\", ys = %\"PRIuFAST32\", xe = %\"PRIuFAST32\", ye = %\"PRIuFAST32\", w = %\"PRIuFAST32\", h = %\"PRIuFAST32\"\\n\",\n\t\t\t\t  rlvl->xstart, rlvl->ystart, rlvl->xend, rlvl->yend, rlvl->xend -\n\t\t\t\t  rlvl->xstart, rlvl->yend - rlvl->ystart);\n\t\t\t\tfor (bandno = 0, band = rlvl->bands;\n\t\t\t\t  bandno < rlvl->numbands; ++bandno, ++band) {\n\t\t\t\t\tfprintf(out, \"BAND %d\\n\", bandno);\n\t\t\t\t\tfprintf(out, \"xs =%\"PRIiFAST32\", ys = %\"PRIiFAST32\", xe = %\"PRIiFAST32\", ye = %\"PRIiFAST32\", w = %\"PRIiFAST32\", h = %\"PRIiFAST32\"\\n\",\n\t\t\t\t\t  jas_seq2d_xstart(band->data), jas_seq2d_ystart(band->data), jas_seq2d_xend(band->data),\n\t\t\t\t\t  jas_seq2d_yend(band->data), jas_seq2d_xend(band->data) - jas_seq2d_xstart(band->data),\n\t\t\t\t\t  jas_seq2d_yend(band->data) - jas_seq2d_ystart(band->data));\n\t\t\t\t\tfor (prcno = 0, prc = band->prcs;\n\t\t\t\t\t  prcno < rlvl->numprcs; ++prcno,\n\t\t\t\t\t  ++prc) {\n\t\t\t\t\t\tfprintf(out, \"CODE BLOCK GROUP %d\\n\", prcno);\n\t\t\t\t\t\tfprintf(out, \"xs =%\"PRIuFAST32\", ys = %\"PRIuFAST32\", xe = %\"PRIuFAST32\", ye = %\"PRIuFAST32\", w = %\"PRIuFAST32\", h = %\"PRIuFAST32\"\\n\",\n\t\t\t\t\t\t  prc->xstart, prc->ystart, prc->xend, prc->yend, prc->xend -\n\t\t\t\t\t\t  prc->xstart, prc->yend - prc->ystart);\n\t\t\t\t\t\tfor (cblkno = 0, cblk =\n\t\t\t\t\t\t  prc->cblks; cblkno <\n\t\t\t\t\t\t  prc->numcblks; ++cblkno,\n\t\t\t\t\t\t  ++cblk) {\n\t\t\t\t\t\t\tfprintf(out, \"CODE BLOCK %d\\n\", cblkno);\n\t\t\t\t\t\t\tfprintf(out, \"xs =%\"PRIiFAST32\", ys = %\"PRIiFAST32\", xe = %\"PRIiFAST32\", ye = %\"PRIiFAST32\", w = %\"PRIiFAST32\", h = %\"PRIiFAST32\"\\n\",\n\t\t\t\t\t\t\t  jas_seq2d_xstart(cblk->data), jas_seq2d_ystart(cblk->data), jas_seq2d_xend(cblk->data),\n\t\t\t\t\t\t\t  jas_seq2d_yend(cblk->data), jas_seq2d_xend(cblk->data) - jas_seq2d_xstart(cblk->data),\n\t\t\t\t\t\t\t  jas_seq2d_yend(cblk->data) - jas_seq2d_ystart(cblk->data));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\njpc_streamlist_t *jpc_streamlist_create()\n{\n\tjpc_streamlist_t *streamlist;\n\tint i;\n\n\tif (!(streamlist = jas_malloc(sizeof(jpc_streamlist_t)))) {\n\t\treturn 0;\n\t}\n\tstreamlist->numstreams = 0;\n\tstreamlist->maxstreams = 100;\n\tif (!(streamlist->streams = jas_alloc2(streamlist->maxstreams,\n\t  sizeof(jas_stream_t *)))) {\n\t\tjas_free(streamlist);\n\t\treturn 0;\n\t}\n\tfor (i = 0; i < streamlist->maxstreams; ++i) {\n\t\tstreamlist->streams[i] = 0;\n\t}\n\treturn streamlist;\n}\n\nint jpc_streamlist_insert(jpc_streamlist_t *streamlist, int streamno,\n  jas_stream_t *stream)\n{\n\tjas_stream_t **newstreams;\n\tint newmaxstreams;\n\tint i;\n\t/* Grow the array of streams if necessary. */\n\tif (streamlist->numstreams >= streamlist->maxstreams) {\n\t\tnewmaxstreams = streamlist->maxstreams + 1024;\n\t\tif (!(newstreams = jas_realloc2(streamlist->streams,\n\t\t  (newmaxstreams + 1024), sizeof(jas_stream_t *)))) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor (i = streamlist->numstreams; i < streamlist->maxstreams; ++i) {\n\t\t\tstreamlist->streams[i] = 0;\n\t\t}\n\t\tstreamlist->maxstreams = newmaxstreams;\n\t\tstreamlist->streams = newstreams;\n\t}\n\tif (streamno != streamlist->numstreams) {\n\t\t/* Can only handle insertion at start of list. */\n\t\treturn -1;\n\t}\n\tstreamlist->streams[streamno] = stream;\n\t++streamlist->numstreams;\n\treturn 0;\n}\n\njas_stream_t *jpc_streamlist_remove(jpc_streamlist_t *streamlist, int streamno)\n{\n\tjas_stream_t *stream;\n\tint i;\n\tif (streamno >= streamlist->numstreams) {\n\t\tabort();\n\t}\n\tstream = streamlist->streams[streamno];\n\tfor (i = streamno + 1; i < streamlist->numstreams; ++i) {\n\t\tstreamlist->streams[i - 1] = streamlist->streams[i];\n\t}\n\t--streamlist->numstreams;\n\treturn stream;\n}\n\nvoid jpc_streamlist_destroy(jpc_streamlist_t *streamlist)\n{\n\tint streamno;\n\tif (streamlist->streams) {\n\t\tfor (streamno = 0; streamno < streamlist->numstreams;\n\t\t  ++streamno) {\n\t\t\tjas_stream_close(streamlist->streams[streamno]);\n\t\t}\n\t\tjas_free(streamlist->streams);\n\t}\n\tjas_free(streamlist);\n}\n\njas_stream_t *jpc_streamlist_get(jpc_streamlist_t *streamlist, int streamno)\n{\n\tassert(streamno < streamlist->numstreams);\n\treturn streamlist->streams[streamno];\n}\n\nint jpc_streamlist_numstreams(jpc_streamlist_t *streamlist)\n{\n\treturn streamlist->numstreams;\n}\n\njpc_ppxstab_t *jpc_ppxstab_create()\n{\n\tjpc_ppxstab_t *tab;\n\n\tif (!(tab = jas_malloc(sizeof(jpc_ppxstab_t)))) {\n\t\treturn 0;\n\t}\n\ttab->numents = 0;\n\ttab->maxents = 0;\n\ttab->ents = 0;\n\treturn tab;\n}\n\nvoid jpc_ppxstab_destroy(jpc_ppxstab_t *tab)\n{\n\tint i;\n\tfor (i = 0; i < tab->numents; ++i) {\n\t\tjpc_ppxstabent_destroy(tab->ents[i]);\n\t}\n\tif (tab->ents) {\n\t\tjas_free(tab->ents);\n\t}\n\tjas_free(tab);\n}\n\nint jpc_ppxstab_grow(jpc_ppxstab_t *tab, int maxents)\n{\n\tjpc_ppxstabent_t **newents;\n\tif (tab->maxents < maxents) {\n\t\tnewents = (tab->ents) ? jas_realloc2(tab->ents, maxents,\n\t\t  sizeof(jpc_ppxstabent_t *)) : jas_alloc2(maxents, sizeof(jpc_ppxstabent_t *));\n\t\tif (!newents) {\n\t\t\treturn -1;\n\t\t}\n\t\ttab->ents = newents;\n\t\ttab->maxents = maxents;\n\t}\n\treturn 0;\n}\n\nint jpc_ppxstab_insert(jpc_ppxstab_t *tab, jpc_ppxstabent_t *ent)\n{\n\tint inspt;\n\tint i;\n\n\tfor (i = 0; i < tab->numents; ++i) {\n\t\tif (tab->ents[i]->ind > ent->ind) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tinspt = i;\n\n\tif (tab->numents >= tab->maxents) {\n\t\tif (jpc_ppxstab_grow(tab, tab->maxents + 128)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tfor (i = tab->numents; i > inspt; --i) {\n\t\ttab->ents[i] = tab->ents[i - 1];\n\t}\n\ttab->ents[i] = ent;\n\t++tab->numents;\n\n\treturn 0;\n}\n\njpc_streamlist_t *jpc_ppmstabtostreams(jpc_ppxstab_t *tab)\n{\n\tjpc_streamlist_t *streams;\n\tuchar *dataptr;\n\tuint_fast32_t datacnt;\n\tuint_fast32_t tpcnt;\n\tjpc_ppxstabent_t *ent;\n\tint entno;\n\tjas_stream_t *stream;\n\tint n;\n\n\tif (!(streams = jpc_streamlist_create())) {\n\t\tgoto error;\n\t}\n\n\tif (!tab->numents) {\n\t\treturn streams;\n\t}\n\n\tentno = 0;\n\tent = tab->ents[entno];\n\tdataptr = ent->data;\n\tdatacnt = ent->len;\n\tfor (;;) {\n\n\t\t/* Get the length of the packet header data for the current\n\t\t  tile-part. */\n\t\tif (datacnt < 4) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (!(stream = jas_stream_memopen(0, 0))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (jpc_streamlist_insert(streams, jpc_streamlist_numstreams(streams),\n\t\t  stream)) {\n\t\t\tgoto error;\n\t\t}\n\t\ttpcnt = (dataptr[0] << 24) | (dataptr[1] << 16) | (dataptr[2] << 8)\n\t\t  | dataptr[3];\n\t\tdatacnt -= 4;\n\t\tdataptr += 4;\n\n\t\t/* Get the packet header data for the current tile-part. */\n\t\twhile (tpcnt) {\n\t\t\tif (!datacnt) {\n\t\t\t\tif (++entno >= tab->numents) {\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tent = tab->ents[entno];\n\t\t\t\tdataptr = ent->data;\n\t\t\t\tdatacnt = ent->len;\n\t\t\t}\n\t\t\tn = JAS_MIN(tpcnt, datacnt);\n\t\t\tif (jas_stream_write(stream, dataptr, n) != n) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\ttpcnt -= n;\n\t\t\tdataptr += n;\n\t\t\tdatacnt -= n;\n\t\t}\n\t\tjas_stream_rewind(stream);\n\t\tif (!datacnt) {\n\t\t\tif (++entno >= tab->numents) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tent = tab->ents[entno];\n\t\t\tdataptr = ent->data;\n\t\t\tdatacnt = ent->len;\n\t\t}\n\t}\n\n\treturn streams;\n\nerror:\n\tif (streams) {\n\t\tjpc_streamlist_destroy(streams);\n\t}\n\treturn 0;\n}\n\nint jpc_pptstabwrite(jas_stream_t *out, jpc_ppxstab_t *tab)\n{\n\tint i;\n\tjpc_ppxstabent_t *ent;\n\tfor (i = 0; i < tab->numents; ++i) {\n\t\tent = tab->ents[i];\n\t\tif (jas_stream_write(out, ent->data, ent->len) != JAS_CAST(int, ent->len)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\njpc_ppxstabent_t *jpc_ppxstabent_create()\n{\n\tjpc_ppxstabent_t *ent;\n\tif (!(ent = jas_malloc(sizeof(jpc_ppxstabent_t)))) {\n\t\treturn 0;\n\t}\n\tent->data = 0;\n\tent->len = 0;\n\tent->ind = 0;\n\treturn ent;\n}\n\nvoid jpc_ppxstabent_destroy(jpc_ppxstabent_t *ent)\n{\n\tif (ent->data) {\n\t\tjas_free(ent->data);\n\t}\n\tjas_free(ent);\n}\n"], "filenames": ["src/libjasper/jpc/jpc_bs.c", "src/libjasper/jpc/jpc_cs.c", "src/libjasper/jpc/jpc_dec.c"], "buggy_code_start_loc": [197, 907, 1643], "buggy_code_end_loc": [218, 909, 1643], "fixing_code_start_loc": [197, 907, 1644], "fixing_code_end_loc": [224, 909, 1645], "type": "NVD-CWE-Other", "message": "The jpc_bitstream_getbits function in jpc_bs.c in JasPer before 2.0.10 allows remote attackers to cause a denial of service (assertion failure) via a very large integer.", "other": {"cve": {"id": "CVE-2016-9391", "sourceIdentifier": "cve@mitre.org", "published": "2017-03-23T18:59:00.740", "lastModified": "2018-06-29T01:29:01.753", "vulnStatus": "Modified", "evaluatorComment": "<a href=\"http://cwe.mitre.org/data/definitions/617.html\">CWE-617: Reachable Assertion</a>", "descriptions": [{"lang": "en", "value": "The jpc_bitstream_getbits function in jpc_bs.c in JasPer before 2.0.10 allows remote attackers to cause a denial of service (assertion failure) via a very large integer."}, {"lang": "es", "value": "La funci\u00f3n jpc_bitstream_getbits en jpc_bs.c en JasPer en versiones anteriores a 2.0.10 permite a atacantes remotos provocar una denegaci\u00f3n de servicio (fallo de aserci\u00f3n) a trav\u00e9s de un entero muy grande."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:jasper_project:jasper:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.0.6", "matchCriteriaId": "0C5899F1-38FD-4D27-96C2-508FFCAAE167"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2016/11/17/1", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "VDB Entry"]}, {"url": "http://www.securityfocus.com/bid/94371", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:1208", "source": "cve@mitre.org"}, {"url": "https://blogs.gentoo.org/ago/2016/11/16/jasper-multiple-assertion-failure", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory", "VDB Entry"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1396967", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/mdadams/jasper/commit/1e84674d95353c64e5c4c0e7232ae86fd6ea813b", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3693-1/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/mdadams/jasper/commit/1e84674d95353c64e5c4c0e7232ae86fd6ea813b"}}