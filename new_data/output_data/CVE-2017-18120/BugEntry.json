{"buggy_code": ["/* gifread.c - Functions to read GIFs.\n   Copyright (C) 1997-2017 Eddie Kohler, ekohler@gmail.com\n   This file is part of the LCDF GIF library.\n\n   The LCDF GIF library is free software. It is distributed under the GNU\n   General Public License, version 2; you can copy, distribute, or alter it at\n   will, as long as this notice is kept intact and this source code is made\n   available. There is no warranty, express or implied. */\n\n#if HAVE_CONFIG_H\n# include <config.h>\n#elif !defined(__cplusplus)\n/* Assume we don't have inline by default */\n# define inline\n#endif\n#include <lcdfgif/gif.h>\n#include <stdarg.h>\n#include <assert.h>\n#include <string.h>\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef struct {\n\n  Gif_Stream *stream;\n\n  Gif_Code *prefix;\n  uint8_t *suffix;\n  uint16_t *length;\n\n  uint16_t width;\n  uint16_t height;\n\n  uint8_t *image;\n  uint8_t *maximage;\n\n  unsigned decodepos;\n\n  Gif_Image* gfi;\n  Gif_ReadErrorHandler handler;\n  int errors[2];\n\n} Gif_Context;\n\n\ntypedef struct Gif_Reader {\n  FILE *f;\n  const uint8_t *v;\n  uint32_t pos;\n  uint32_t length;\n  int is_record;\n  int is_eoi;\n  uint8_t (*byte_getter)(struct Gif_Reader *);\n  uint32_t (*block_getter)(uint8_t*, uint32_t, struct Gif_Reader*);\n  int (*eofer)(struct Gif_Reader *);\n} Gif_Reader;\n\nstatic Gif_ReadErrorHandler default_error_handler = 0;\n\n\n#define gifgetc(grr)\t((char)(*grr->byte_getter)(grr))\n#define gifgetbyte(grr) ((*grr->byte_getter)(grr))\n#define gifgetblock(ptr, size, grr) ((*grr->block_getter)(ptr, size, grr))\n#define gifeof(grr)\t((*grr->eofer)(grr))\n\nstatic inline uint16_t\ngifgetunsigned(Gif_Reader *grr)\n{\n  uint8_t one = gifgetbyte(grr);\n  uint8_t two = gifgetbyte(grr);\n  return one | (two << 8);\n}\n\n\nstatic uint8_t\nfile_byte_getter(Gif_Reader *grr)\n{\n    int i = getc(grr->f);\n    if (i != EOF) {\n        ++grr->pos;\n        return i;\n    } else\n        return 0;\n}\n\nstatic uint32_t\nfile_block_getter(uint8_t *p, uint32_t s, Gif_Reader *grr)\n{\n    size_t nread = fread(p, 1, s, grr->f);\n    if (nread < s)\n        memset(p + nread, 0, s - nread);\n    grr->pos += nread;\n    return nread;\n}\n\nstatic int\nfile_eofer(Gif_Reader *grr)\n{\n  int c = getc(grr->f);\n  if (c == EOF)\n    return 1;\n  else {\n    ungetc(c, grr->f);\n    return 0;\n  }\n}\n\n\nstatic uint8_t\nrecord_byte_getter(Gif_Reader *grr)\n{\n    if (grr->pos < grr->length)\n        return grr->v[grr->pos++];\n    else\n        return 0;\n}\n\nstatic uint32_t\nrecord_block_getter(uint8_t *p, uint32_t s, Gif_Reader *grr)\n{\n    uint32_t ncopy = (grr->pos + s <= grr->length ? s : grr->length - grr->pos);\n    memcpy(p, &grr->v[grr->pos], ncopy);\n    grr->pos += ncopy;\n    if (ncopy < s)\n        memset(p + ncopy, 0, s - ncopy);\n    return ncopy;\n}\n\nstatic int\nrecord_eofer(Gif_Reader *grr)\n{\n    return grr->pos == grr->length;\n}\n\n\nstatic void\nmake_data_reader(Gif_Reader *grr, const uint8_t *data, uint32_t length)\n{\n  grr->v = data;\n  grr->pos = 0;\n  grr->length = length;\n  grr->is_record = 1;\n  grr->byte_getter = record_byte_getter;\n  grr->block_getter = record_block_getter;\n  grr->eofer = record_eofer;\n}\n\n\nstatic void\ngif_read_error(Gif_Context *gfc, int is_error, const char *text)\n{\n    Gif_ReadErrorHandler handler = gfc->handler ? gfc->handler : default_error_handler;\n    if (is_error >= 0)\n        gfc->errors[is_error > 0] += 1;\n    if (handler)\n        handler(gfc->stream, gfc->gfi, is_error, text);\n}\n\n\nstatic uint8_t\none_code(Gif_Context *gfc, Gif_Code code)\n{\n  uint8_t *suffixes = gfc->suffix;\n  Gif_Code *prefixes = gfc->prefix;\n  uint8_t *ptr;\n  int lastsuffix = 0;\n  int codelength = gfc->length[code];\n\n  gfc->decodepos += codelength;\n  ptr = gfc->image + gfc->decodepos;\n  while (codelength > 0) {\n      lastsuffix = suffixes[code];\n      code = prefixes[code];\n      --ptr;\n      if (ptr < gfc->maximage)\n          *ptr = lastsuffix;\n      --codelength;\n  }\n\n  /* return the first pixel in the code, which, since we walked backwards\n     through the code, was the last suffix we processed. */\n  return lastsuffix;\n}\n\nstatic int\nread_image_block(Gif_Reader *grr, uint8_t *buffer, int *bit_pos_store,\n\t\t int *bit_len_store, int bits_needed)\n{\n  int bit_position = *bit_pos_store;\n  int bit_length = *bit_len_store;\n  uint8_t block_len;\n\n  while (bit_position + bits_needed > bit_length) {\n    /* Read in the next data block. */\n    if (bit_position >= 8) {\n      /* Need to shift down the upper, unused part of 'buffer' */\n      int i = bit_position / 8;\n      buffer[0] = buffer[i];\n      buffer[1] = buffer[i+1];\n      bit_position -= i * 8;\n      bit_length -= i * 8;\n    }\n    block_len = gifgetbyte(grr);\n    GIF_DEBUG((\"\\nimage_block(%d) \", block_len));\n    if (block_len == 0) return 0;\n    gifgetblock(buffer + bit_length / 8, block_len, grr);\n    bit_length += block_len * 8;\n  }\n\n  *bit_pos_store = bit_position;\n  *bit_len_store = bit_length;\n  return 1;\n}\n\n\nstatic void\nread_image_data(Gif_Context *gfc, Gif_Reader *grr)\n{\n  /* we need a bit more than GIF_MAX_BLOCK in case a single code is split\n     across blocks */\n  uint8_t buffer[GIF_MAX_BLOCK + 5];\n  int i;\n  uint32_t accum;\n\n  int bit_position;\n  int bit_length;\n\n  Gif_Code code;\n  Gif_Code old_code;\n  Gif_Code clear_code;\n  Gif_Code eoi_code;\n  Gif_Code next_code;\n#define CUR_BUMP_CODE (1 << bits_needed)\n#define CUR_CODE_MASK ((1 << bits_needed) - 1)\n\n  int min_code_size;\n  int bits_needed;\n\n  gfc->decodepos = 0;\n\n  min_code_size = gifgetbyte(grr);\n  GIF_DEBUG((\"\\n\\nmin_code_size(%d) \", min_code_size));\n  if (min_code_size >= GIF_MAX_CODE_BITS) {\n    gif_read_error(gfc, 1, \"image corrupted, min_code_size too big\");\n    min_code_size = GIF_MAX_CODE_BITS - 1;\n  } else if (min_code_size < 2) {\n    gif_read_error(gfc, 1, \"image corrupted, min_code_size too small\");\n    min_code_size = 2;\n  }\n  clear_code = 1 << min_code_size;\n  for (code = 0; code < clear_code; code++) {\n    gfc->prefix[code] = 49428;\n    gfc->suffix[code] = (uint8_t)code;\n    gfc->length[code] = 1;\n  }\n  eoi_code = clear_code + 1;\n\n  next_code = eoi_code;\n  bits_needed = min_code_size + 1;\n\n  code = clear_code;\n\n  bit_length = bit_position = 0;\n  /* Thus the 'Read in the next data block.' code below will be invoked on the\n     first time through: exactly right! */\n\n  while (1) {\n\n    old_code = code;\n\n    /* GET A CODE INTO THE 'code' VARIABLE.\n     *\n     * 9.Dec.1998 - Rather than maintain a byte pointer and a bit offset into\n     * the current byte (and the processing associated with that), we maintain\n     * one number: the offset, in bits, from the beginning of 'buffer'. This\n     * much cleaner choice was inspired by Patrick J. Naughton\n     * <naughton@wind.sun.com>'s GIF-reading code, which does the same thing.\n     * His code distributed as part of XV in xvgif.c. */\n\n    if (bit_position + bits_needed > bit_length)\n      /* Read in the next data block. */\n      if (!read_image_block(grr, buffer, &bit_position, &bit_length,\n\t\t\t    bits_needed))\n\tgoto zero_length_block;\n\n    i = bit_position / 8;\n    accum = buffer[i] + (buffer[i+1] << 8);\n    if (bits_needed >= 8)\n      accum |= (buffer[i+2]) << 16;\n    code = (Gif_Code)((accum >> (bit_position % 8)) & CUR_CODE_MASK);\n    bit_position += bits_needed;\n\n    GIF_DEBUG((\"%d \", code));\n\n    /* CHECK FOR SPECIAL OR BAD CODES: clear_code, eoi_code, or a code that is\n     * too large. */\n    if (code == clear_code) {\n      GIF_DEBUG((\"clear \"));\n      bits_needed = min_code_size + 1;\n      next_code = eoi_code;\n      continue;\n\n    } else if (code == eoi_code)\n      break;\n\n    else if (code > next_code && next_code && next_code != clear_code) {\n      /* code > next_code: a (hopefully recoverable) error.\n\n\t Bug fix, 5/27: Do this even if old_code == clear_code, and set code\n\t to 0 to prevent errors later. (If we didn't zero code, we'd later set\n\t old_code = code; then we had old_code >= next_code; so the prefixes\n\t array got all screwed up!)\n\n\t Bug fix, 4/12/2010: It is not an error if next_code == clear_code.\n\t This happens at the end of a large GIF: see the next comment (\"If no\n\t meaningful next code should be defined....\"). */\n      if (gfc->errors[1] < 20)\n          gif_read_error(gfc, 1, \"image corrupted, code out of range\");\n      else if (gfc->errors[1] == 20)\n          gif_read_error(gfc, 1, \"(not reporting more errors)\");\n      code = 0;\n    }\n\n    /* PROCESS THE CURRENT CODE and define the next code. If no meaningful\n     * next code should be defined, then we have set next_code to either\n     * 'eoi_code' or 'clear_code' -- so we'll store useless prefix/suffix data\n     * in a useless place. */\n\n    /* *First,* set up the prefix and length for the next code\n       (in case code == next_code). */\n    gfc->prefix[next_code] = old_code;\n    gfc->length[next_code] = gfc->length[old_code] + 1;\n\n    /* Use one_code to process code. It's nice that it returns the first\n       pixel in code: that's what we need. */\n    gfc->suffix[next_code] = one_code(gfc, code);\n\n    /* Special processing if code == next_code: we didn't know code's final\n       suffix when we called one_code, but we do now. */\n    /* 7.Mar.2014 -- Avoid error if image has zero width/height. */\n    if (code == next_code && gfc->image + gfc->decodepos <= gfc->maximage)\n      gfc->image[gfc->decodepos - 1] = gfc->suffix[next_code];\n\n    /* Increment next_code except for the 'clear_code' special case (that's\n       when we're reading at the end of a GIF) */\n    if (next_code != clear_code) {\n      next_code++;\n      if (next_code == CUR_BUMP_CODE) {\n\tif (bits_needed < GIF_MAX_CODE_BITS)\n\t  bits_needed++;\n\telse\n\t  next_code = clear_code;\n      }\n    }\n\n  }\n\n  /* read blocks until zero-length reached. */\n  i = gifgetbyte(grr);\n  GIF_DEBUG((\"\\nafter_image(%d)\\n\", i));\n  while (i > 0) {\n    gifgetblock(buffer, i, grr);\n    i = gifgetbyte(grr);\n    GIF_DEBUG((\"\\nafter_image(%d)\\n\", i));\n  }\n\n  /* zero-length block reached. */\n zero_length_block: {\n      long delta = (long) (gfc->maximage - gfc->image) - (long) gfc->decodepos;\n      char buf[BUFSIZ];\n      if (delta > 0) {\n          sprintf(buf, \"missing %ld %s of image data\", delta,\n                  delta == 1 ? \"pixel\" : \"pixels\");\n          gif_read_error(gfc, 1, buf);\n          memset(&gfc->image[gfc->decodepos], 0, delta);\n      } else if (delta < -1) {\n          /* One pixel of superfluous data is OK; that could be the\n             code == next_code case. */\n          sprintf(buf, \"%ld superfluous pixels of image data\", -delta);\n          gif_read_error(gfc, 0, buf);\n      }\n  }\n}\n\n\nstatic Gif_Colormap *\nread_color_table(int size, Gif_Reader *grr)\n{\n  Gif_Colormap *gfcm = Gif_NewFullColormap(size, size);\n  Gif_Color *c;\n  if (!gfcm) return 0;\n\n  GIF_DEBUG((\"colormap(%d) \", size));\n  for (c = gfcm->col; size; size--, c++) {\n    c->gfc_red = gifgetbyte(grr);\n    c->gfc_green = gifgetbyte(grr);\n    c->gfc_blue = gifgetbyte(grr);\n    c->haspixel = 0;\n  }\n\n  return gfcm;\n}\n\n\nstatic int\nread_logical_screen_descriptor(Gif_Stream *gfs, Gif_Reader *grr)\n     /* returns 0 on memory error */\n{\n  uint8_t packed;\n\n  /* we don't care about logical screen width or height */\n  gfs->screen_width = gifgetunsigned(grr);\n  gfs->screen_height = gifgetunsigned(grr);\n\n  packed = gifgetbyte(grr);\n  gfs->background = gifgetbyte(grr);\n\n  /* don't care about pixel aspect ratio */\n  gifgetbyte(grr);\n\n  if (packed & 0x80) { /* have a global color table */\n      int ncol = 1 << ((packed & 0x07) + 1);\n      gfs->global = read_color_table(ncol, grr);\n      if (!gfs->global) return 0;\n      gfs->global->refcount = 1;\n  } else\n      gfs->background = 256;\n\n  return 1;\n}\n\n\nstatic int\nread_compressed_image(Gif_Image *gfi, Gif_Reader *grr, int read_flags)\n{\n  if (grr->is_record) {\n    const uint32_t image_pos = grr->pos;\n\n    /* scan over image */\n    ++grr->pos; /* skip min code size */\n    while (grr->pos < grr->length) {\n        int amt = grr->v[grr->pos];\n        grr->pos += amt + 1;\n        if (amt == 0)\n            break;\n    }\n    if (grr->pos > grr->length)\n        grr->pos = grr->length;\n\n    gfi->compressed_len = grr->pos - image_pos;\n    gfi->compressed_errors = 0;\n    if (read_flags & GIF_READ_CONST_RECORD) {\n      gfi->compressed = (uint8_t*) &grr->v[image_pos];\n      gfi->free_compressed = 0;\n    } else {\n      gfi->compressed = Gif_NewArray(uint8_t, gfi->compressed_len);\n      gfi->free_compressed = Gif_Free;\n      if (!gfi->compressed) return 0;\n      memcpy(gfi->compressed, &grr->v[image_pos], gfi->compressed_len);\n    }\n\n  } else {\n    /* non-record; have to read it block by block. */\n    uint32_t comp_cap = 1024;\n    uint32_t comp_len;\n    uint8_t *comp = Gif_NewArray(uint8_t, comp_cap);\n    int i;\n    if (!comp) return 0;\n\n    /* min code size */\n    i = gifgetbyte(grr);\n    comp[0] = i;\n    comp_len = 1;\n\n    i = gifgetbyte(grr);\n    while (i > 0) {\n      /* add 2 before check so we don't have to check after loop when appending\n\t 0 block */\n      if (comp_len + i + 2 > comp_cap) {\n\tcomp_cap *= 2;\n\tGif_ReArray(comp, uint8_t, comp_cap);\n\tif (!comp) return 0;\n      }\n      comp[comp_len] = i;\n      gifgetblock(comp + comp_len + 1, i, grr);\n      comp_len += i + 1;\n      i = gifgetbyte(grr);\n    }\n    comp[comp_len++] = 0;\n\n    gfi->compressed_len = comp_len;\n    gfi->compressed_errors = 0;\n    gfi->compressed = comp;\n    gfi->free_compressed = Gif_Free;\n  }\n\n  return 1;\n}\n\n\nstatic int\nuncompress_image(Gif_Context *gfc, Gif_Image *gfi, Gif_Reader *grr)\n{\n    int old_nerrors;\n    if (!Gif_CreateUncompressedImage(gfi, gfi->interlace))\n        return 0;\n    gfc->width = gfi->width;\n    gfc->height = gfi->height;\n    gfc->image = gfi->image_data;\n    gfc->maximage = gfi->image_data + (unsigned) gfi->width * (unsigned) gfi->height;\n    old_nerrors = gfc->errors[1];\n    read_image_data(gfc, grr);\n    gfi->compressed_errors = gfc->errors[1] - old_nerrors;\n    return 1;\n}\n\n\nint\nGif_FullUncompressImage(Gif_Stream* gfs, Gif_Image* gfi,\n                        Gif_ReadErrorHandler h)\n{\n  Gif_Context gfc;\n  Gif_Reader grr;\n  int ok = 0;\n\n  /* return right away if image is already uncompressed. this might screw over\n     people who expect re-uncompressing to restore the compressed version. */\n  if (gfi->img)\n    return 2;\n  if (gfi->image_data)\n    /* we have uncompressed data, but not an 'img' array;\n       this shouldn't happen */\n    return 0;\n\n  gfc.stream = gfs;\n  gfc.gfi = gfi;\n  gfc.prefix = Gif_NewArray(Gif_Code, GIF_MAX_CODE);\n  gfc.suffix = Gif_NewArray(uint8_t, GIF_MAX_CODE);\n  gfc.length = Gif_NewArray(uint16_t, GIF_MAX_CODE);\n  gfc.handler = h;\n  gfc.errors[0] = gfc.errors[1] = 0;\n\n  if (gfc.prefix && gfc.suffix && gfc.length && gfi->compressed) {\n    make_data_reader(&grr, gfi->compressed, gfi->compressed_len);\n    ok = uncompress_image(&gfc, gfi, &grr);\n  }\n\n  Gif_DeleteArray(gfc.prefix);\n  Gif_DeleteArray(gfc.suffix);\n  Gif_DeleteArray(gfc.length);\n  if (gfc.errors[0] || gfc.errors[1])\n      gif_read_error(&gfc, -1, 0);\n  return ok && !gfc.errors[1];\n}\n\n\nstatic int\nread_image(Gif_Reader *grr, Gif_Context *gfc, Gif_Image *gfi, int read_flags)\n     /* returns 0 on memory error */\n{\n  uint8_t packed;\n\n  gfi->left = gifgetunsigned(grr);\n  gfi->top = gifgetunsigned(grr);\n  gfi->width = gifgetunsigned(grr);\n  gfi->height = gifgetunsigned(grr);\n  /* Mainline GIF processors (Firefox, etc.) process missing width (height)\n     as screen_width (screen_height). */\n  if (gfi->width == 0)\n      gfi->width = gfc->stream->screen_width;\n  if (gfi->height == 0)\n      gfi->height = gfc->stream->screen_height;\n  /* If still zero, error. */\n  if (gfi->width == 0 || gfi->height == 0) {\n      gif_read_error(gfc, 1, \"image has zero width and/or height\");\n      Gif_MakeImageEmpty(gfi);\n      read_flags = 0;\n  }\n  /* If position out of range, error. */\n  if ((unsigned) gfi->left + (unsigned) gfi->width > 0xFFFF\n      || (unsigned) gfi->top + (unsigned) gfi->height > 0xFFFF) {\n      gif_read_error(gfc, 1, \"image position and/or dimensions out of range\");\n      Gif_MakeImageEmpty(gfi);\n      read_flags = 0;\n  }\n  GIF_DEBUG((\"<%ux%u> \", gfi->width, gfi->height));\n\n  packed = gifgetbyte(grr);\n  if (packed & 0x80) { /* have a local color table */\n    int ncol = 1 << ((packed & 0x07) + 1);\n    gfi->local = read_color_table(ncol, grr);\n    if (!gfi->local) return 0;\n    gfi->local->refcount = 1;\n  }\n\n  gfi->interlace = (packed & 0x40) != 0;\n\n  /* Keep the compressed data if asked */\n  if (read_flags & GIF_READ_COMPRESSED) {\n    if (!read_compressed_image(gfi, grr, read_flags))\n      return 0;\n    if (read_flags & GIF_READ_UNCOMPRESSED) {\n      Gif_Reader new_grr;\n      make_data_reader(&new_grr, gfi->compressed, gfi->compressed_len);\n      if (!uncompress_image(gfc, gfi, &new_grr))\n\treturn 0;\n    }\n\n  } else if (read_flags & GIF_READ_UNCOMPRESSED) {\n    if (!uncompress_image(gfc, gfi, grr))\n      return 0;\n\n  } else {\n    /* skip over the image */\n    uint8_t buffer[GIF_MAX_BLOCK];\n    int i = gifgetbyte(grr);\n    while (i > 0) {\n      gifgetblock(buffer, i, grr);\n      i = gifgetbyte(grr);\n    }\n  }\n\n  return 1;\n}\n\n\nstatic void\nread_graphic_control_extension(Gif_Context *gfc, Gif_Image *gfi,\n\t\t\t       Gif_Reader *grr)\n{\n  uint8_t len;\n  uint8_t crap[GIF_MAX_BLOCK];\n\n  len = gifgetbyte(grr);\n\n  if (len == 4) {\n    uint8_t packed = gifgetbyte(grr);\n    gfi->disposal = (packed >> 2) & 0x07;\n    gfi->delay = gifgetunsigned(grr);\n    gfi->transparent = gifgetbyte(grr);\n    if (!(packed & 0x01)) /* transparent color doesn't exist */\n      gfi->transparent = -1;\n    len -= 4;\n  }\n\n  if (len > 0) {\n    gif_read_error(gfc, 1, \"bad graphic extension\");\n    gifgetblock(crap, len, grr);\n  }\n\n  len = gifgetbyte(grr);\n  while (len > 0) {\n    gif_read_error(gfc, 1, \"bad graphic extension\");\n    gifgetblock(crap, len, grr);\n    len = gifgetbyte(grr);\n  }\n}\n\n\nstatic char *last_name;\n\n\nstatic char *\nsuck_data(char *data, int *store_len, Gif_Reader *grr)\n{\n  uint8_t len = gifgetbyte(grr);\n  int total_len = 0;\n\n  while (len > 0) {\n    Gif_ReArray(data, char, total_len + len + 1);\n    if (!data) return 0;\n    gifgetblock((uint8_t *)data + total_len, len, grr);\n\n    total_len += len;\n    data[total_len] = 0;\n\n    len = gifgetbyte(grr);\n  }\n\n  if (store_len) *store_len = total_len;\n  return data;\n}\n\n\nstatic int\nread_unknown_extension(Gif_Context* gfc, Gif_Reader* grr,\n                       int kind, char* appname, int applength)\n{\n    uint8_t block_len = gifgetbyte(grr);\n    uint8_t* data = 0;\n    int data_len = 0;\n    Gif_Extension *gfex = 0;\n\n    while (block_len > 0) {\n        Gif_ReArray(data, uint8_t, data_len + block_len + 2);\n        if (!data)\n            goto done;\n        data[data_len] = block_len;\n        gifgetblock(data + data_len + 1, block_len, grr);\n        data_len += block_len + 1;\n        block_len = gifgetbyte(grr);\n    }\n\n    if (data)\n        gfex = Gif_NewExtension(kind, appname, applength);\n    if (gfex) {\n        gfex->data = data;\n        gfex->free_data = Gif_Free;\n        gfex->length = data_len;\n        gfex->packetized = 1;\n        data[data_len] = 0;\n        Gif_AddExtension(gfc->stream, gfc->gfi, gfex);\n    }\n\n done:\n    if (!gfex)\n        Gif_DeleteArray(data);\n    while (block_len > 0) {\n        uint8_t buffer[GIF_MAX_BLOCK];\n        gifgetblock(buffer, block_len, grr);\n        block_len = gifgetbyte(grr);\n    }\n    return gfex != 0;\n}\n\n\nstatic int\nread_application_extension(Gif_Context *gfc, Gif_Reader *grr)\n{\n  Gif_Stream *gfs = gfc->stream;\n  uint8_t buffer[GIF_MAX_BLOCK + 1];\n  uint8_t len = gifgetbyte(grr);\n  gifgetblock(buffer, len, grr);\n\n  /* Read the Netscape loop extension. */\n  if (len == 11\n      && (memcmp(buffer, \"NETSCAPE2.0\", 11) == 0\n          || memcmp(buffer, \"ANIMEXTS1.0\", 11) == 0)) {\n\n    len = gifgetbyte(grr);\n    if (len == 3) {\n      gifgetbyte(grr); /* throw away the 1 */\n      gfs->loopcount = gifgetunsigned(grr);\n      len = gifgetbyte(grr);\n      if (len)\n\tgif_read_error(gfc, 1, \"bad loop extension\");\n    } else\n      gif_read_error(gfc, 1, \"bad loop extension\");\n\n    while (len > 0) {\n      gifgetblock(buffer, len, grr);\n      len = gifgetbyte(grr);\n    }\n    return 1;\n\n  } else\n    return read_unknown_extension(gfc, grr, 0xFF, (char*)buffer, len);\n}\n\n\nstatic int\nread_comment_extension(Gif_Image *gfi, Gif_Reader *grr)\n{\n  int len;\n  Gif_Comment *gfcom = gfi->comment;\n  char *m = suck_data(0, &len, grr);\n  if (m) {\n    if (!gfcom)\n      gfcom = gfi->comment = Gif_NewComment();\n    if (!gfcom || !Gif_AddCommentTake(gfcom, m, len))\n      return 0;\n  }\n  return 1;\n}\n\n\nstatic Gif_Stream *\nread_gif(Gif_Reader *grr, int read_flags,\n\t const char* landmark, Gif_ReadErrorHandler handler)\n{\n  Gif_Stream *gfs;\n  Gif_Image *gfi;\n  Gif_Context gfc;\n  int unknown_block_type = 0;\n\n  if (gifgetc(grr) != 'G' ||\n      gifgetc(grr) != 'I' ||\n      gifgetc(grr) != 'F')\n    return 0;\n  (void)gifgetc(grr);\n  (void)gifgetc(grr);\n  (void)gifgetc(grr);\n\n  gfs = Gif_NewStream();\n  gfi = Gif_NewImage();\n\n  gfc.stream = gfs;\n  gfc.prefix = Gif_NewArray(Gif_Code, GIF_MAX_CODE);\n  gfc.suffix = Gif_NewArray(uint8_t, GIF_MAX_CODE);\n  gfc.length = Gif_NewArray(uint16_t, GIF_MAX_CODE);\n  gfc.handler = handler;\n  gfc.gfi = gfi;\n  gfc.errors[0] = gfc.errors[1] = 0;\n\n  if (!gfs || !gfi || !gfc.prefix || !gfc.suffix || !gfc.length)\n    goto done;\n  gfs->landmark = landmark;\n\n  GIF_DEBUG((\"\\nGIF \"));\n  if (!read_logical_screen_descriptor(gfs, grr))\n    goto done;\n  GIF_DEBUG((\"logscrdesc \"));\n\n  while (!gifeof(grr)) {\n\n    uint8_t block = gifgetbyte(grr);\n\n    switch (block) {\n\n     case ',': /* image block */\n      GIF_DEBUG((\"imageread %d \", gfs->nimages));\n\n      gfi->identifier = last_name;\n      last_name = 0;\n      if (!Gif_AddImage(gfs, gfi))\n          goto done;\n      else if (!read_image(grr, &gfc, gfi, read_flags)) {\n          Gif_RemoveImage(gfs, gfs->nimages - 1);\n          gfi = 0;\n          goto done;\n      }\n\n      gfc.gfi = gfi = Gif_NewImage();\n      if (!gfi)\n          goto done;\n      break;\n\n     case ';': /* terminator */\n      GIF_DEBUG((\"term\\n\"));\n      goto done;\n\n     case '!': /* extension */\n      block = gifgetbyte(grr);\n      GIF_DEBUG((\"ext(0x%02X) \", block));\n      switch (block) {\n\n       case 0xF9:\n\tread_graphic_control_extension(&gfc, gfi, grr);\n\tbreak;\n\n       case 0xCE:\n\tlast_name = suck_data(last_name, 0, grr);\n\tbreak;\n\n       case 0xFE:\n\tif (!read_comment_extension(gfi, grr)) goto done;\n\tbreak;\n\n       case 0xFF:\n\tread_application_extension(&gfc, grr);\n\tbreak;\n\n       default:\n        read_unknown_extension(&gfc, grr, block, 0, 0);\n\tbreak;\n\n      }\n      break;\n\n     default:\n       if (!unknown_block_type) {\n\t char buf[256];\n\t sprintf(buf, \"unknown block type %d at file offset %u\", block, grr->pos - 1);\n\t gif_read_error(&gfc, 1, buf);\n\t unknown_block_type = 1;\n       }\n       break;\n\n    }\n\n  }\n\n done:\n\n  /* Move comments and extensions after last image into stream. */\n  if (gfs && gfi) {\n      Gif_Extension* gfex;\n      gfs->end_comment = gfi->comment;\n      gfi->comment = 0;\n      gfs->end_extension_list = gfi->extension_list;\n      gfi->extension_list = 0;\n      for (gfex = gfs->end_extension_list; gfex; gfex = gfex->next)\n          gfex->image = NULL;\n  }\n\n  Gif_DeleteImage(gfi);\n  Gif_DeleteArray(last_name);\n  Gif_DeleteArray(gfc.prefix);\n  Gif_DeleteArray(gfc.suffix);\n  Gif_DeleteArray(gfc.length);\n  gfc.gfi = 0;\n\n  if (gfs)\n    gfs->errors = gfc.errors[1];\n  if (gfs && gfc.errors[1] == 0\n      && !(read_flags & GIF_READ_TRAILING_GARBAGE_OK)\n      && !grr->eofer(grr))\n      gif_read_error(&gfc, 0, \"trailing garbage after GIF ignored\");\n  /* finally, export last message */\n  gif_read_error(&gfc, -1, 0);\n\n  return gfs;\n}\n\n\nGif_Stream *\nGif_FullReadFile(FILE *f, int read_flags,\n\t\t const char* landmark, Gif_ReadErrorHandler h)\n{\n  Gif_Reader grr;\n  if (!f) return 0;\n  grr.f = f;\n  grr.pos = 0;\n  grr.is_record = 0;\n  grr.byte_getter = file_byte_getter;\n  grr.block_getter = file_block_getter;\n  grr.eofer = file_eofer;\n  return read_gif(&grr, read_flags, landmark, h);\n}\n\nGif_Stream *\nGif_FullReadRecord(const Gif_Record *gifrec, int read_flags,\n\t\t   const char* landmark, Gif_ReadErrorHandler h)\n{\n  Gif_Reader grr;\n  if (!gifrec) return 0;\n  make_data_reader(&grr, gifrec->data, gifrec->length);\n  if (read_flags & GIF_READ_CONST_RECORD)\n    read_flags |= GIF_READ_COMPRESSED;\n  return read_gif(&grr, read_flags, landmark, h);\n}\n\n\n#undef Gif_ReadFile\n#undef Gif_ReadRecord\n\nGif_Stream *\nGif_ReadFile(FILE *f)\n{\n  return Gif_FullReadFile(f, GIF_READ_UNCOMPRESSED, 0, 0);\n}\n\nGif_Stream *\nGif_ReadRecord(const Gif_Record *gifrec)\n{\n  return Gif_FullReadRecord(gifrec, GIF_READ_UNCOMPRESSED, 0, 0);\n}\n\nvoid\nGif_SetErrorHandler(Gif_ReadErrorHandler handler) {\n    default_error_handler = handler;\n}\n\n#ifdef __cplusplus\n}\n#endif\n"], "fixing_code": ["/* gifread.c - Functions to read GIFs.\n   Copyright (C) 1997-2017 Eddie Kohler, ekohler@gmail.com\n   This file is part of the LCDF GIF library.\n\n   The LCDF GIF library is free software. It is distributed under the GNU\n   General Public License, version 2; you can copy, distribute, or alter it at\n   will, as long as this notice is kept intact and this source code is made\n   available. There is no warranty, express or implied. */\n\n#if HAVE_CONFIG_H\n# include <config.h>\n#elif !defined(__cplusplus)\n/* Assume we don't have inline by default */\n# define inline\n#endif\n#include <lcdfgif/gif.h>\n#include <stdarg.h>\n#include <assert.h>\n#include <string.h>\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef struct {\n\n  Gif_Stream *stream;\n\n  Gif_Code *prefix;\n  uint8_t *suffix;\n  uint16_t *length;\n\n  uint16_t width;\n  uint16_t height;\n\n  uint8_t *image;\n  uint8_t *maximage;\n\n  unsigned decodepos;\n\n  Gif_Image* gfi;\n  Gif_ReadErrorHandler handler;\n  int errors[2];\n\n} Gif_Context;\n\n\ntypedef struct Gif_Reader {\n  FILE *f;\n  const uint8_t *v;\n  uint32_t pos;\n  uint32_t length;\n  int is_record;\n  int is_eoi;\n  uint8_t (*byte_getter)(struct Gif_Reader *);\n  uint32_t (*block_getter)(uint8_t*, uint32_t, struct Gif_Reader*);\n  int (*eofer)(struct Gif_Reader *);\n} Gif_Reader;\n\nstatic Gif_ReadErrorHandler default_error_handler = 0;\n\n\n#define gifgetc(grr)\t((char)(*grr->byte_getter)(grr))\n#define gifgetbyte(grr) ((*grr->byte_getter)(grr))\n#define gifgetblock(ptr, size, grr) ((*grr->block_getter)(ptr, size, grr))\n#define gifeof(grr)\t((*grr->eofer)(grr))\n\nstatic inline uint16_t\ngifgetunsigned(Gif_Reader *grr)\n{\n  uint8_t one = gifgetbyte(grr);\n  uint8_t two = gifgetbyte(grr);\n  return one | (two << 8);\n}\n\n\nstatic uint8_t\nfile_byte_getter(Gif_Reader *grr)\n{\n    int i = getc(grr->f);\n    if (i != EOF) {\n        ++grr->pos;\n        return i;\n    } else\n        return 0;\n}\n\nstatic uint32_t\nfile_block_getter(uint8_t *p, uint32_t s, Gif_Reader *grr)\n{\n    size_t nread = fread(p, 1, s, grr->f);\n    if (nread < s)\n        memset(p + nread, 0, s - nread);\n    grr->pos += nread;\n    return nread;\n}\n\nstatic int\nfile_eofer(Gif_Reader *grr)\n{\n  int c = getc(grr->f);\n  if (c == EOF)\n    return 1;\n  else {\n    ungetc(c, grr->f);\n    return 0;\n  }\n}\n\n\nstatic uint8_t\nrecord_byte_getter(Gif_Reader *grr)\n{\n    if (grr->pos < grr->length)\n        return grr->v[grr->pos++];\n    else\n        return 0;\n}\n\nstatic uint32_t\nrecord_block_getter(uint8_t *p, uint32_t s, Gif_Reader *grr)\n{\n    uint32_t ncopy = (grr->pos + s <= grr->length ? s : grr->length - grr->pos);\n    memcpy(p, &grr->v[grr->pos], ncopy);\n    grr->pos += ncopy;\n    if (ncopy < s)\n        memset(p + ncopy, 0, s - ncopy);\n    return ncopy;\n}\n\nstatic int\nrecord_eofer(Gif_Reader *grr)\n{\n    return grr->pos == grr->length;\n}\n\n\nstatic void\nmake_data_reader(Gif_Reader *grr, const uint8_t *data, uint32_t length)\n{\n  grr->v = data;\n  grr->pos = 0;\n  grr->length = length;\n  grr->is_record = 1;\n  grr->byte_getter = record_byte_getter;\n  grr->block_getter = record_block_getter;\n  grr->eofer = record_eofer;\n}\n\n\nstatic void\ngif_read_error(Gif_Context *gfc, int is_error, const char *text)\n{\n    Gif_ReadErrorHandler handler = gfc->handler ? gfc->handler : default_error_handler;\n    if (is_error >= 0)\n        gfc->errors[is_error > 0] += 1;\n    if (handler)\n        handler(gfc->stream, gfc->gfi, is_error, text);\n}\n\n\nstatic uint8_t\none_code(Gif_Context *gfc, Gif_Code code)\n{\n  uint8_t *suffixes = gfc->suffix;\n  Gif_Code *prefixes = gfc->prefix;\n  uint8_t *ptr;\n  int lastsuffix = 0;\n  int codelength = gfc->length[code];\n\n  gfc->decodepos += codelength;\n  ptr = gfc->image + gfc->decodepos;\n  while (codelength > 0) {\n      lastsuffix = suffixes[code];\n      code = prefixes[code];\n      --ptr;\n      if (ptr < gfc->maximage)\n          *ptr = lastsuffix;\n      --codelength;\n  }\n\n  /* return the first pixel in the code, which, since we walked backwards\n     through the code, was the last suffix we processed. */\n  return lastsuffix;\n}\n\nstatic int\nread_image_block(Gif_Reader *grr, uint8_t *buffer, int *bit_pos_store,\n\t\t int *bit_len_store, int bits_needed)\n{\n  int bit_position = *bit_pos_store;\n  int bit_length = *bit_len_store;\n  uint8_t block_len;\n\n  while (bit_position + bits_needed > bit_length) {\n    /* Read in the next data block. */\n    if (bit_position >= 8) {\n      /* Need to shift down the upper, unused part of 'buffer' */\n      int i = bit_position / 8;\n      buffer[0] = buffer[i];\n      buffer[1] = buffer[i+1];\n      bit_position -= i * 8;\n      bit_length -= i * 8;\n    }\n    block_len = gifgetbyte(grr);\n    GIF_DEBUG((\"\\nimage_block(%d) \", block_len));\n    if (block_len == 0) return 0;\n    gifgetblock(buffer + bit_length / 8, block_len, grr);\n    bit_length += block_len * 8;\n  }\n\n  *bit_pos_store = bit_position;\n  *bit_len_store = bit_length;\n  return 1;\n}\n\n\nstatic void\nread_image_data(Gif_Context *gfc, Gif_Reader *grr)\n{\n  /* we need a bit more than GIF_MAX_BLOCK in case a single code is split\n     across blocks */\n  uint8_t buffer[GIF_MAX_BLOCK + 5];\n  int i;\n  uint32_t accum;\n\n  int bit_position;\n  int bit_length;\n\n  Gif_Code code;\n  Gif_Code old_code;\n  Gif_Code clear_code;\n  Gif_Code eoi_code;\n  Gif_Code next_code;\n#define CUR_BUMP_CODE (1 << bits_needed)\n#define CUR_CODE_MASK ((1 << bits_needed) - 1)\n\n  int min_code_size;\n  int bits_needed;\n\n  gfc->decodepos = 0;\n\n  min_code_size = gifgetbyte(grr);\n  GIF_DEBUG((\"\\n\\nmin_code_size(%d) \", min_code_size));\n  if (min_code_size >= GIF_MAX_CODE_BITS) {\n    gif_read_error(gfc, 1, \"image corrupted, min_code_size too big\");\n    min_code_size = GIF_MAX_CODE_BITS - 1;\n  } else if (min_code_size < 2) {\n    gif_read_error(gfc, 1, \"image corrupted, min_code_size too small\");\n    min_code_size = 2;\n  }\n  clear_code = 1 << min_code_size;\n  for (code = 0; code < clear_code; code++) {\n    gfc->prefix[code] = 49428;\n    gfc->suffix[code] = (uint8_t)code;\n    gfc->length[code] = 1;\n  }\n  eoi_code = clear_code + 1;\n\n  next_code = eoi_code;\n  bits_needed = min_code_size + 1;\n\n  code = clear_code;\n\n  bit_length = bit_position = 0;\n  /* Thus the 'Read in the next data block.' code below will be invoked on the\n     first time through: exactly right! */\n\n  while (1) {\n\n    old_code = code;\n\n    /* GET A CODE INTO THE 'code' VARIABLE.\n     *\n     * 9.Dec.1998 - Rather than maintain a byte pointer and a bit offset into\n     * the current byte (and the processing associated with that), we maintain\n     * one number: the offset, in bits, from the beginning of 'buffer'. This\n     * much cleaner choice was inspired by Patrick J. Naughton\n     * <naughton@wind.sun.com>'s GIF-reading code, which does the same thing.\n     * His code distributed as part of XV in xvgif.c. */\n\n    if (bit_position + bits_needed > bit_length)\n      /* Read in the next data block. */\n      if (!read_image_block(grr, buffer, &bit_position, &bit_length,\n\t\t\t    bits_needed))\n\tgoto zero_length_block;\n\n    i = bit_position / 8;\n    accum = buffer[i] + (buffer[i+1] << 8);\n    if (bits_needed >= 8)\n      accum |= (buffer[i+2]) << 16;\n    code = (Gif_Code)((accum >> (bit_position % 8)) & CUR_CODE_MASK);\n    bit_position += bits_needed;\n\n    GIF_DEBUG((\"%d \", code));\n\n    /* CHECK FOR SPECIAL OR BAD CODES: clear_code, eoi_code, or a code that is\n     * too large. */\n    if (code == clear_code) {\n      GIF_DEBUG((\"clear \"));\n      bits_needed = min_code_size + 1;\n      next_code = eoi_code;\n      continue;\n\n    } else if (code == eoi_code)\n      break;\n\n    else if (code > next_code && next_code && next_code != clear_code) {\n      /* code > next_code: a (hopefully recoverable) error.\n\n\t Bug fix, 5/27: Do this even if old_code == clear_code, and set code\n\t to 0 to prevent errors later. (If we didn't zero code, we'd later set\n\t old_code = code; then we had old_code >= next_code; so the prefixes\n\t array got all screwed up!)\n\n\t Bug fix, 4/12/2010: It is not an error if next_code == clear_code.\n\t This happens at the end of a large GIF: see the next comment (\"If no\n\t meaningful next code should be defined....\"). */\n      if (gfc->errors[1] < 20)\n          gif_read_error(gfc, 1, \"image corrupted, code out of range\");\n      else if (gfc->errors[1] == 20)\n          gif_read_error(gfc, 1, \"(not reporting more errors)\");\n      code = 0;\n    }\n\n    /* PROCESS THE CURRENT CODE and define the next code. If no meaningful\n     * next code should be defined, then we have set next_code to either\n     * 'eoi_code' or 'clear_code' -- so we'll store useless prefix/suffix data\n     * in a useless place. */\n\n    /* *First,* set up the prefix and length for the next code\n       (in case code == next_code). */\n    gfc->prefix[next_code] = old_code;\n    gfc->length[next_code] = gfc->length[old_code] + 1;\n\n    /* Use one_code to process code. It's nice that it returns the first\n       pixel in code: that's what we need. */\n    gfc->suffix[next_code] = one_code(gfc, code);\n\n    /* Special processing if code == next_code: we didn't know code's final\n       suffix when we called one_code, but we do now. */\n    /* 7.Mar.2014 -- Avoid error if image has zero width/height. */\n    if (code == next_code && gfc->image + gfc->decodepos <= gfc->maximage)\n      gfc->image[gfc->decodepos - 1] = gfc->suffix[next_code];\n\n    /* Increment next_code except for the 'clear_code' special case (that's\n       when we're reading at the end of a GIF) */\n    if (next_code != clear_code) {\n      next_code++;\n      if (next_code == CUR_BUMP_CODE) {\n\tif (bits_needed < GIF_MAX_CODE_BITS)\n\t  bits_needed++;\n\telse\n\t  next_code = clear_code;\n      }\n    }\n\n  }\n\n  /* read blocks until zero-length reached. */\n  i = gifgetbyte(grr);\n  GIF_DEBUG((\"\\nafter_image(%d)\\n\", i));\n  while (i > 0) {\n    gifgetblock(buffer, i, grr);\n    i = gifgetbyte(grr);\n    GIF_DEBUG((\"\\nafter_image(%d)\\n\", i));\n  }\n\n  /* zero-length block reached. */\n zero_length_block: {\n      long delta = (long) (gfc->maximage - gfc->image) - (long) gfc->decodepos;\n      char buf[BUFSIZ];\n      if (delta > 0) {\n          sprintf(buf, \"missing %ld %s of image data\", delta,\n                  delta == 1 ? \"pixel\" : \"pixels\");\n          gif_read_error(gfc, 1, buf);\n          memset(&gfc->image[gfc->decodepos], 0, delta);\n      } else if (delta < -1) {\n          /* One pixel of superfluous data is OK; that could be the\n             code == next_code case. */\n          sprintf(buf, \"%ld superfluous pixels of image data\", -delta);\n          gif_read_error(gfc, 0, buf);\n      }\n  }\n}\n\n\nstatic Gif_Colormap *\nread_color_table(int size, Gif_Reader *grr)\n{\n  Gif_Colormap *gfcm = Gif_NewFullColormap(size, size);\n  Gif_Color *c;\n  if (!gfcm) return 0;\n\n  GIF_DEBUG((\"colormap(%d) \", size));\n  for (c = gfcm->col; size; size--, c++) {\n    c->gfc_red = gifgetbyte(grr);\n    c->gfc_green = gifgetbyte(grr);\n    c->gfc_blue = gifgetbyte(grr);\n    c->haspixel = 0;\n  }\n\n  return gfcm;\n}\n\n\nstatic int\nread_logical_screen_descriptor(Gif_Stream *gfs, Gif_Reader *grr)\n     /* returns 0 on memory error */\n{\n  uint8_t packed;\n\n  /* we don't care about logical screen width or height */\n  gfs->screen_width = gifgetunsigned(grr);\n  gfs->screen_height = gifgetunsigned(grr);\n\n  packed = gifgetbyte(grr);\n  gfs->background = gifgetbyte(grr);\n\n  /* don't care about pixel aspect ratio */\n  gifgetbyte(grr);\n\n  if (packed & 0x80) { /* have a global color table */\n      int ncol = 1 << ((packed & 0x07) + 1);\n      gfs->global = read_color_table(ncol, grr);\n      if (!gfs->global) return 0;\n      gfs->global->refcount = 1;\n  } else\n      gfs->background = 256;\n\n  return 1;\n}\n\n\nstatic int\nread_compressed_image(Gif_Image *gfi, Gif_Reader *grr, int read_flags)\n{\n  if (grr->is_record) {\n    const uint32_t image_pos = grr->pos;\n\n    /* scan over image */\n    ++grr->pos; /* skip min code size */\n    while (grr->pos < grr->length) {\n        int amt = grr->v[grr->pos];\n        grr->pos += amt + 1;\n        if (amt == 0)\n            break;\n    }\n    if (grr->pos > grr->length)\n        grr->pos = grr->length;\n\n    gfi->compressed_len = grr->pos - image_pos;\n    gfi->compressed_errors = 0;\n    if (read_flags & GIF_READ_CONST_RECORD) {\n      gfi->compressed = (uint8_t*) &grr->v[image_pos];\n      gfi->free_compressed = 0;\n    } else {\n      gfi->compressed = Gif_NewArray(uint8_t, gfi->compressed_len);\n      gfi->free_compressed = Gif_Free;\n      if (!gfi->compressed) return 0;\n      memcpy(gfi->compressed, &grr->v[image_pos], gfi->compressed_len);\n    }\n\n  } else {\n    /* non-record; have to read it block by block. */\n    uint32_t comp_cap = 1024;\n    uint32_t comp_len;\n    uint8_t *comp = Gif_NewArray(uint8_t, comp_cap);\n    int i;\n    if (!comp) return 0;\n\n    /* min code size */\n    i = gifgetbyte(grr);\n    comp[0] = i;\n    comp_len = 1;\n\n    i = gifgetbyte(grr);\n    while (i > 0) {\n      /* add 2 before check so we don't have to check after loop when appending\n\t 0 block */\n      if (comp_len + i + 2 > comp_cap) {\n\tcomp_cap *= 2;\n\tGif_ReArray(comp, uint8_t, comp_cap);\n\tif (!comp) return 0;\n      }\n      comp[comp_len] = i;\n      gifgetblock(comp + comp_len + 1, i, grr);\n      comp_len += i + 1;\n      i = gifgetbyte(grr);\n    }\n    comp[comp_len++] = 0;\n\n    gfi->compressed_len = comp_len;\n    gfi->compressed_errors = 0;\n    gfi->compressed = comp;\n    gfi->free_compressed = Gif_Free;\n  }\n\n  return 1;\n}\n\n\nstatic int\nuncompress_image(Gif_Context *gfc, Gif_Image *gfi, Gif_Reader *grr)\n{\n    int old_nerrors;\n    if (!Gif_CreateUncompressedImage(gfi, gfi->interlace))\n        return 0;\n    gfc->width = gfi->width;\n    gfc->height = gfi->height;\n    gfc->image = gfi->image_data;\n    gfc->maximage = gfi->image_data + (unsigned) gfi->width * (unsigned) gfi->height;\n    old_nerrors = gfc->errors[1];\n    read_image_data(gfc, grr);\n    gfi->compressed_errors = gfc->errors[1] - old_nerrors;\n    return 1;\n}\n\n\nint\nGif_FullUncompressImage(Gif_Stream* gfs, Gif_Image* gfi,\n                        Gif_ReadErrorHandler h)\n{\n  Gif_Context gfc;\n  Gif_Reader grr;\n  int ok = 0;\n\n  /* return right away if image is already uncompressed. this might screw over\n     people who expect re-uncompressing to restore the compressed version. */\n  if (gfi->img)\n    return 2;\n  if (gfi->image_data)\n    /* we have uncompressed data, but not an 'img' array;\n       this shouldn't happen */\n    return 0;\n\n  gfc.stream = gfs;\n  gfc.gfi = gfi;\n  gfc.prefix = Gif_NewArray(Gif_Code, GIF_MAX_CODE);\n  gfc.suffix = Gif_NewArray(uint8_t, GIF_MAX_CODE);\n  gfc.length = Gif_NewArray(uint16_t, GIF_MAX_CODE);\n  gfc.handler = h;\n  gfc.errors[0] = gfc.errors[1] = 0;\n\n  if (gfc.prefix && gfc.suffix && gfc.length && gfi->compressed) {\n    make_data_reader(&grr, gfi->compressed, gfi->compressed_len);\n    ok = uncompress_image(&gfc, gfi, &grr);\n  }\n\n  Gif_DeleteArray(gfc.prefix);\n  Gif_DeleteArray(gfc.suffix);\n  Gif_DeleteArray(gfc.length);\n  if (gfc.errors[0] || gfc.errors[1])\n      gif_read_error(&gfc, -1, 0);\n  return ok && !gfc.errors[1];\n}\n\n\nstatic int\nread_image(Gif_Reader *grr, Gif_Context *gfc, Gif_Image *gfi, int read_flags)\n     /* returns 0 on memory error */\n{\n  uint8_t packed;\n\n  gfi->left = gifgetunsigned(grr);\n  gfi->top = gifgetunsigned(grr);\n  gfi->width = gifgetunsigned(grr);\n  gfi->height = gifgetunsigned(grr);\n  /* Mainline GIF processors (Firefox, etc.) process missing width (height)\n     as screen_width (screen_height). */\n  if (gfi->width == 0)\n      gfi->width = gfc->stream->screen_width;\n  if (gfi->height == 0)\n      gfi->height = gfc->stream->screen_height;\n  /* If still zero, error. */\n  if (gfi->width == 0 || gfi->height == 0) {\n      gif_read_error(gfc, 1, \"image has zero width and/or height\");\n      Gif_MakeImageEmpty(gfi);\n      read_flags = 0;\n  }\n  /* If position out of range, error. */\n  if ((unsigned) gfi->left + (unsigned) gfi->width > 0xFFFF\n      || (unsigned) gfi->top + (unsigned) gfi->height > 0xFFFF) {\n      gif_read_error(gfc, 1, \"image position and/or dimensions out of range\");\n      Gif_MakeImageEmpty(gfi);\n      read_flags = 0;\n  }\n  GIF_DEBUG((\"<%ux%u> \", gfi->width, gfi->height));\n\n  packed = gifgetbyte(grr);\n  if (packed & 0x80) { /* have a local color table */\n    int ncol = 1 << ((packed & 0x07) + 1);\n    gfi->local = read_color_table(ncol, grr);\n    if (!gfi->local) return 0;\n    gfi->local->refcount = 1;\n  }\n\n  gfi->interlace = (packed & 0x40) != 0;\n\n  /* Keep the compressed data if asked */\n  if (read_flags & GIF_READ_COMPRESSED) {\n    if (!read_compressed_image(gfi, grr, read_flags))\n      return 0;\n    if (read_flags & GIF_READ_UNCOMPRESSED) {\n      Gif_Reader new_grr;\n      make_data_reader(&new_grr, gfi->compressed, gfi->compressed_len);\n      if (!uncompress_image(gfc, gfi, &new_grr))\n\treturn 0;\n    }\n\n  } else if (read_flags & GIF_READ_UNCOMPRESSED) {\n    if (!uncompress_image(gfc, gfi, grr))\n      return 0;\n\n  } else {\n    /* skip over the image */\n    uint8_t buffer[GIF_MAX_BLOCK];\n    int i = gifgetbyte(grr);\n    while (i > 0) {\n      gifgetblock(buffer, i, grr);\n      i = gifgetbyte(grr);\n    }\n  }\n\n  return 1;\n}\n\n\nstatic void\nread_graphic_control_extension(Gif_Context *gfc, Gif_Image *gfi,\n\t\t\t       Gif_Reader *grr)\n{\n  uint8_t len;\n  uint8_t crap[GIF_MAX_BLOCK];\n\n  len = gifgetbyte(grr);\n\n  if (len == 4) {\n    uint8_t packed = gifgetbyte(grr);\n    gfi->disposal = (packed >> 2) & 0x07;\n    gfi->delay = gifgetunsigned(grr);\n    gfi->transparent = gifgetbyte(grr);\n    if (!(packed & 0x01)) /* transparent color doesn't exist */\n      gfi->transparent = -1;\n    len -= 4;\n  }\n\n  if (len > 0) {\n    gif_read_error(gfc, 1, \"bad graphic extension\");\n    gifgetblock(crap, len, grr);\n  }\n\n  len = gifgetbyte(grr);\n  while (len > 0) {\n    gif_read_error(gfc, 1, \"bad graphic extension\");\n    gifgetblock(crap, len, grr);\n    len = gifgetbyte(grr);\n  }\n}\n\n\nstatic char *last_name;\n\n\nstatic char *\nsuck_data(char *data, int *store_len, Gif_Reader *grr)\n{\n  uint8_t len = gifgetbyte(grr);\n  int total_len = 0;\n\n  while (len > 0) {\n    Gif_ReArray(data, char, total_len + len + 1);\n    if (!data) return 0;\n    gifgetblock((uint8_t *)data + total_len, len, grr);\n\n    total_len += len;\n    data[total_len] = 0;\n\n    len = gifgetbyte(grr);\n  }\n\n  if (store_len) *store_len = total_len;\n  return data;\n}\n\n\nstatic int\nread_unknown_extension(Gif_Context* gfc, Gif_Reader* grr,\n                       int kind, char* appname, int applength)\n{\n    uint8_t block_len = gifgetbyte(grr);\n    uint8_t* data = 0;\n    int data_len = 0;\n    Gif_Extension *gfex = 0;\n\n    while (block_len > 0) {\n        Gif_ReArray(data, uint8_t, data_len + block_len + 2);\n        if (!data)\n            goto done;\n        data[data_len] = block_len;\n        gifgetblock(data + data_len + 1, block_len, grr);\n        data_len += block_len + 1;\n        block_len = gifgetbyte(grr);\n    }\n\n    if (data)\n        gfex = Gif_NewExtension(kind, appname, applength);\n    if (gfex) {\n        gfex->data = data;\n        gfex->free_data = Gif_Free;\n        gfex->length = data_len;\n        gfex->packetized = 1;\n        data[data_len] = 0;\n        Gif_AddExtension(gfc->stream, gfc->gfi, gfex);\n    }\n\n done:\n    if (!gfex)\n        Gif_DeleteArray(data);\n    while (block_len > 0) {\n        uint8_t buffer[GIF_MAX_BLOCK];\n        gifgetblock(buffer, block_len, grr);\n        block_len = gifgetbyte(grr);\n    }\n    return gfex != 0;\n}\n\n\nstatic int\nread_application_extension(Gif_Context *gfc, Gif_Reader *grr)\n{\n  Gif_Stream *gfs = gfc->stream;\n  uint8_t buffer[GIF_MAX_BLOCK + 1];\n  uint8_t len = gifgetbyte(grr);\n  gifgetblock(buffer, len, grr);\n\n  /* Read the Netscape loop extension. */\n  if (len == 11\n      && (memcmp(buffer, \"NETSCAPE2.0\", 11) == 0\n          || memcmp(buffer, \"ANIMEXTS1.0\", 11) == 0)) {\n\n    len = gifgetbyte(grr);\n    if (len == 3) {\n      gifgetbyte(grr); /* throw away the 1 */\n      gfs->loopcount = gifgetunsigned(grr);\n      len = gifgetbyte(grr);\n      if (len)\n\tgif_read_error(gfc, 1, \"bad loop extension\");\n    } else\n      gif_read_error(gfc, 1, \"bad loop extension\");\n\n    while (len > 0) {\n      gifgetblock(buffer, len, grr);\n      len = gifgetbyte(grr);\n    }\n    return 1;\n\n  } else\n    return read_unknown_extension(gfc, grr, 0xFF, (char*)buffer, len);\n}\n\n\nstatic int\nread_comment_extension(Gif_Image *gfi, Gif_Reader *grr)\n{\n  int len;\n  Gif_Comment *gfcom = gfi->comment;\n  char *m = suck_data(0, &len, grr);\n  if (m) {\n    if (!gfcom)\n      gfcom = gfi->comment = Gif_NewComment();\n    if (!gfcom || !Gif_AddCommentTake(gfcom, m, len))\n      return 0;\n  }\n  return 1;\n}\n\n\nstatic Gif_Stream *\nread_gif(Gif_Reader *grr, int read_flags,\n\t const char* landmark, Gif_ReadErrorHandler handler)\n{\n  Gif_Stream *gfs;\n  Gif_Image *gfi;\n  Gif_Context gfc;\n  int unknown_block_type = 0;\n\n  if (gifgetc(grr) != 'G' ||\n      gifgetc(grr) != 'I' ||\n      gifgetc(grr) != 'F')\n    return 0;\n  (void)gifgetc(grr);\n  (void)gifgetc(grr);\n  (void)gifgetc(grr);\n\n  gfs = Gif_NewStream();\n  gfi = Gif_NewImage();\n\n  gfc.stream = gfs;\n  gfc.prefix = Gif_NewArray(Gif_Code, GIF_MAX_CODE);\n  gfc.suffix = Gif_NewArray(uint8_t, GIF_MAX_CODE);\n  gfc.length = Gif_NewArray(uint16_t, GIF_MAX_CODE);\n  gfc.handler = handler;\n  gfc.gfi = gfi;\n  gfc.errors[0] = gfc.errors[1] = 0;\n\n  if (!gfs || !gfi || !gfc.prefix || !gfc.suffix || !gfc.length)\n    goto done;\n  gfs->landmark = landmark;\n\n  GIF_DEBUG((\"\\nGIF \"));\n  if (!read_logical_screen_descriptor(gfs, grr))\n    goto done;\n  GIF_DEBUG((\"logscrdesc \"));\n\n  while (!gifeof(grr)) {\n\n    uint8_t block = gifgetbyte(grr);\n\n    switch (block) {\n\n     case ',': /* image block */\n      GIF_DEBUG((\"imageread %d \", gfs->nimages));\n\n      gfi->identifier = last_name;\n      last_name = 0;\n      if (!Gif_AddImage(gfs, gfi))\n          goto done;\n      else if (!read_image(grr, &gfc, gfi, read_flags)) {\n          Gif_RemoveImage(gfs, gfs->nimages - 1);\n          gfi = 0;\n          goto done;\n      }\n\n      gfc.gfi = gfi = Gif_NewImage();\n      if (!gfi)\n          goto done;\n      break;\n\n     case ';': /* terminator */\n      GIF_DEBUG((\"term\\n\"));\n      goto done;\n\n     case '!': /* extension */\n      block = gifgetbyte(grr);\n      GIF_DEBUG((\"ext(0x%02X) \", block));\n      switch (block) {\n\n       case 0xF9:\n\tread_graphic_control_extension(&gfc, gfi, grr);\n\tbreak;\n\n       case 0xCE:\n\tlast_name = suck_data(last_name, 0, grr);\n\tbreak;\n\n       case 0xFE:\n\tif (!read_comment_extension(gfi, grr)) goto done;\n\tbreak;\n\n       case 0xFF:\n\tread_application_extension(&gfc, grr);\n\tbreak;\n\n       default:\n        read_unknown_extension(&gfc, grr, block, 0, 0);\n\tbreak;\n\n      }\n      break;\n\n     default:\n       if (!unknown_block_type) {\n\t char buf[256];\n\t sprintf(buf, \"unknown block type %d at file offset %u\", block, grr->pos - 1);\n\t gif_read_error(&gfc, 1, buf);\n\t unknown_block_type = 1;\n       }\n       break;\n\n    }\n\n  }\n\n done:\n\n  /* Move comments and extensions after last image into stream. */\n  if (gfs && gfi) {\n      Gif_Extension* gfex;\n      gfs->end_comment = gfi->comment;\n      gfi->comment = 0;\n      gfs->end_extension_list = gfi->extension_list;\n      gfi->extension_list = 0;\n      for (gfex = gfs->end_extension_list; gfex; gfex = gfex->next)\n          gfex->image = NULL;\n  }\n\n  Gif_DeleteImage(gfi);\n  Gif_DeleteArray(last_name);\n  Gif_DeleteArray(gfc.prefix);\n  Gif_DeleteArray(gfc.suffix);\n  Gif_DeleteArray(gfc.length);\n  gfc.gfi = 0;\n  last_name = 0;\n\n  if (gfs)\n    gfs->errors = gfc.errors[1];\n  if (gfs && gfc.errors[1] == 0\n      && !(read_flags & GIF_READ_TRAILING_GARBAGE_OK)\n      && !grr->eofer(grr))\n      gif_read_error(&gfc, 0, \"trailing garbage after GIF ignored\");\n  /* finally, export last message */\n  gif_read_error(&gfc, -1, 0);\n\n  return gfs;\n}\n\n\nGif_Stream *\nGif_FullReadFile(FILE *f, int read_flags,\n\t\t const char* landmark, Gif_ReadErrorHandler h)\n{\n  Gif_Reader grr;\n  if (!f) return 0;\n  grr.f = f;\n  grr.pos = 0;\n  grr.is_record = 0;\n  grr.byte_getter = file_byte_getter;\n  grr.block_getter = file_block_getter;\n  grr.eofer = file_eofer;\n  return read_gif(&grr, read_flags, landmark, h);\n}\n\nGif_Stream *\nGif_FullReadRecord(const Gif_Record *gifrec, int read_flags,\n\t\t   const char* landmark, Gif_ReadErrorHandler h)\n{\n  Gif_Reader grr;\n  if (!gifrec) return 0;\n  make_data_reader(&grr, gifrec->data, gifrec->length);\n  if (read_flags & GIF_READ_CONST_RECORD)\n    read_flags |= GIF_READ_COMPRESSED;\n  return read_gif(&grr, read_flags, landmark, h);\n}\n\n\n#undef Gif_ReadFile\n#undef Gif_ReadRecord\n\nGif_Stream *\nGif_ReadFile(FILE *f)\n{\n  return Gif_FullReadFile(f, GIF_READ_UNCOMPRESSED, 0, 0);\n}\n\nGif_Stream *\nGif_ReadRecord(const Gif_Record *gifrec)\n{\n  return Gif_FullReadRecord(gifrec, GIF_READ_UNCOMPRESSED, 0, 0);\n}\n\nvoid\nGif_SetErrorHandler(Gif_ReadErrorHandler handler) {\n    default_error_handler = handler;\n}\n\n#ifdef __cplusplus\n}\n#endif\n"], "filenames": ["src/gifread.c"], "buggy_code_start_loc": [902], "buggy_code_end_loc": [902], "fixing_code_start_loc": [903], "fixing_code_end_loc": [904], "type": "CWE-415", "message": "A double-free bug in the read_gif function in gifread.c in gifsicle 1.90 allows a remote attacker to cause a denial-of-service attack or unspecified other impact via a maliciously crafted file, because last_name is mishandled, a different vulnerability than CVE-2017-1000421.", "other": {"cve": {"id": "CVE-2017-18120", "sourceIdentifier": "cve@mitre.org", "published": "2018-02-02T09:29:00.227", "lastModified": "2018-02-14T18:21:43.230", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A double-free bug in the read_gif function in gifread.c in gifsicle 1.90 allows a remote attacker to cause a denial-of-service attack or unspecified other impact via a maliciously crafted file, because last_name is mishandled, a different vulnerability than CVE-2017-1000421."}, {"lang": "es", "value": "Un error de doble liberaci\u00f3n (double free) en la funci\u00f3n read_gif en gifread.c en gifsicle 1.90 permite que un atacante remoto provoque un ataque de denegaci\u00f3n de servicio (DoS) u otro tipo de impacto sin especificar mediante un archivo maliciosamente manipulado. Esta vulnerabilidad es diferente de CVE-2017-1000421."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-415"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gifsicle_project:gifsicle:1.90:*:*:*:*:*:*:*", "matchCriteriaId": "AE6734C4-013D-481F-8E4D-C5F57520276D"}]}]}], "references": [{"url": "https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=878739", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=881120", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/kohler/gifsicle/commit/118a46090c50829dc543179019e6140e1235f909", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/kohler/gifsicle/issues/117", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/kohler/gifsicle/commit/118a46090c50829dc543179019e6140e1235f909"}}