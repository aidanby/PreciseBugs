{"buggy_code": ["<?php\n// +-----------------------------------------------------------------------+\n// | Piwigo - a PHP based photo gallery                                    |\n// +-----------------------------------------------------------------------+\n// | Copyright(C) 2008-2016 Piwigo Team                  http://piwigo.org |\n// | Copyright(C) 2003-2008 PhpWebGallery Team    http://phpwebgallery.net |\n// | Copyright(C) 2002-2003 Pierrick LE GALL   http://le-gall.net/pierrick |\n// +-----------------------------------------------------------------------+\n// | This program is free software; you can redistribute it and/or modify  |\n// | it under the terms of the GNU General Public License as published by  |\n// | the Free Software Foundation                                          |\n// |                                                                       |\n// | This program is distributed in the hope that it will be useful, but   |\n// | WITHOUT ANY WARRANTY; without even the implied warranty of            |\n// | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU      |\n// | General Public License for more details.                              |\n// |                                                                       |\n// | You should have received a copy of the GNU General Public License     |\n// | along with this program; if not, write to the Free Software           |\n// | Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, |\n// | USA.                                                                  |\n// +-----------------------------------------------------------------------+\n\ndefine('PHPWG_ROOT_PATH','./');\nsession_cache_limiter('public');\ninclude_once(PHPWG_ROOT_PATH.'include/common.inc.php');\n\n// Check Access and exit when user status is not ok\ncheck_status(ACCESS_GUEST);\n\nfunction guess_mime_type($ext)\n{\n  switch ( strtolower($ext) )\n  {\n    case \"jpe\": case \"jpeg\":\n    case \"jpg\": $ctype=\"image/jpeg\"; break;\n    case \"png\": $ctype=\"image/png\"; break;\n    case \"gif\": $ctype=\"image/gif\"; break;\n    case \"tiff\":\n    case \"tif\": $ctype=\"image/tiff\"; break;\n    case \"txt\": $ctype=\"text/plain\"; break;\n    case \"html\":\n    case \"htm\": $ctype=\"text/html\"; break;\n    case \"xml\": $ctype=\"text/xml\"; break;\n    case \"pdf\": $ctype=\"application/pdf\"; break;\n    case \"zip\": $ctype=\"application/zip\"; break;\n    case \"ogg\": $ctype=\"application/ogg\"; break;\n    default: $ctype=\"application/octet-stream\";\n  }\n  return $ctype;\n}\n\nfunction do_error( $code, $str )\n{\n  set_status_header( $code );\n  echo $str ;\n  exit();\n}\n\nif ($conf['enable_formats'] and isset($_GET['format']))\n{\n  check_input_parameter('format', $_GET, false, PATTERN_ID);\n\n  $query = '\nSELECT\n    *\n  FROM '.IMAGE_FORMAT_TABLE.'\n  WHERE format_id = '.$_GET['format'].'\n;';\n  $formats = query2array($query);\n\n  if (count($formats) == 0)\n  {\n    do_error(400, 'Invalid request - format');\n  }\n\n  $format = $formats[0];\n\n  $_GET['id'] = $format['image_id'];\n  $_GET['part'] = 'f'; // \"f\" for \"format\"\n}\n\n\nif (!isset($_GET['id'])\n    or !is_numeric($_GET['id'])\n    or !isset($_GET['part'])\n    or !in_array($_GET['part'], array('e','r','f') ) )\n{\n  do_error(400, 'Invalid request - id/part');\n}\n\n$query = '\nSELECT * FROM '. IMAGES_TABLE.'\n  WHERE id='.$_GET['id'].'\n;';\n\n$element_info = pwg_db_fetch_assoc(pwg_query($query));\nif ( empty($element_info) )\n{\n  do_error(404, 'Requested id not found');\n}\n\n// special download action for admins\n$is_admin_download = false;\nif (is_admin() and isset($_GET['pwg_token']) and get_pwg_token() == $_GET['pwg_token'])\n{\n  $is_admin_download = true;\n  $user['enabled_high'] = true;\n}\n\n$src_image = new SrcImage($element_info);\n\n// $filter['visible_categories'] and $filter['visible_images']\n// are not used because it's not necessary (filter <> restriction)\n$query='\nSELECT id\n  FROM '.CATEGORIES_TABLE.'\n    INNER JOIN '.IMAGE_CATEGORY_TABLE.' ON category_id = id\n  WHERE image_id = '.$_GET['id'].'\n'.get_sql_condition_FandF(\n  array(\n      'forbidden_categories' => 'category_id',\n      'forbidden_images' => 'image_id',\n    ),\n  '    AND'\n  ).'\n  LIMIT 1\n;';\nif (!$is_admin_download and pwg_db_num_rows(pwg_query($query))<1 )\n{\n  do_error(401, 'Access denied');\n}\n\ninclude_once(PHPWG_ROOT_PATH.'include/functions_picture.inc.php');\n$file='';\nswitch ($_GET['part'])\n{\n  case 'e':\n    if ( $src_image->is_original() and !$user['enabled_high'] )\n    {// we have a photo and the user has no access to HD\n      $deriv = new DerivativeImage(IMG_XXLARGE, $src_image);\n      if ( !$deriv->same_as_source() )\n      {\n        do_error(401, 'Access denied e');\n      }\n    }\n    $file = get_element_path($element_info);\n    break;\n  case 'r':\n    $file = original_to_representative( get_element_path($element_info), $element_info['representative_ext'] );\n    break;\n  case 'f' :\n    $file = original_to_format(get_element_path($element_info), $format['ext']);\n    $element_info['file'] = get_filename_wo_extension($element_info['file']).'.'.$format['ext'];\n    break;\n}\n\nif ( empty($file) )\n{\n  do_error(404, 'Requested file not found');\n}\n\nif ($_GET['part'] == 'e') {\n  pwg_log($_GET['id'], 'high');\n}\nelse if ($_GET['part'] == 'e')\n{\n  pwg_log($_GET['id'], 'other');\n}\nelse if ($_GET['part'] == 'f')\n{\n  pwg_log($_GET['id'], 'high', $format['format_id']);\n}\n\n$http_headers = array();\n\n$ctype = null;\nif (!url_is_remote($file))\n{\n  if ( !@is_readable($file) )\n  {\n    do_error(404, \"Requested file not found - $file\");\n  }\n  $http_headers[] = 'Content-Length: '.@filesize($file);\n  if ( function_exists('mime_content_type') )\n  {\n    $ctype = mime_content_type($file);\n  }\n\n  $gmt_mtime = gmdate('D, d M Y H:i:s', filemtime($file)).' GMT';\n  $http_headers[] = 'Last-Modified: '.$gmt_mtime;\n\n  // following lines would indicate how the client should handle the cache\n  /* $max_age=300;\n  $http_headers[] = 'Expires: '.gmdate('D, d M Y H:i:s', time()+$max_age).' GMT';\n  // HTTP/1.1 only\n  $http_headers[] = 'Cache-Control: private, must-revalidate, max-age='.$max_age;*/\n\n  if ('f' != $_GET['part'] and isset( $_SERVER['HTTP_IF_MODIFIED_SINCE'] ) )\n  {\n    set_status_header(304);\n    foreach ($http_headers as $header)\n    {\n      header( $header );\n    }\n    exit();\n  }\n}\n\nif (!isset($ctype))\n{ // give it a guess\n  $ctype = guess_mime_type( get_extension($file) );\n}\n\n$http_headers[] = 'Content-Type: '.$ctype;\n\nif (isset($_GET['download']))\n{\n  $http_headers[] = 'Content-Disposition: attachment; filename=\"'.$element_info['file'].'\";';\n  $http_headers[] = 'Content-Transfer-Encoding: binary';\n}\nelse\n{\n  $http_headers[] = 'Content-Disposition: inline; filename=\"'\n            .basename($file).'\";';\n}\n\nforeach ($http_headers as $header)\n{\n  header( $header );\n}\n\n// Looking at the safe_mode configuration for execution time\nif (ini_get('safe_mode') == 0)\n{\n  @set_time_limit(0);\n}\n\n@readfile($file);\n\n?>", "<?php\n// +-----------------------------------------------------------------------+\n// | Piwigo - a PHP based photo gallery                                    |\n// +-----------------------------------------------------------------------+\n// | Copyright(C) 2008-2016 Piwigo Team                  http://piwigo.org |\n// | Copyright(C) 2003-2008 PhpWebGallery Team    http://phpwebgallery.net |\n// | Copyright(C) 2002-2003 Pierrick LE GALL   http://le-gall.net/pierrick |\n// +-----------------------------------------------------------------------+\n// | This program is free software; you can redistribute it and/or modify  |\n// | it under the terms of the GNU General Public License as published by  |\n// | the Free Software Foundation                                          |\n// |                                                                       |\n// | This program is distributed in the hope that it will be useful, but   |\n// | WITHOUT ANY WARRANTY; without even the implied warranty of            |\n// | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU      |\n// | General Public License for more details.                              |\n// |                                                                       |\n// | You should have received a copy of the GNU General Public License     |\n// | along with this program; if not, write to the Free Software           |\n// | Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, |\n// | USA.                                                                  |\n// +-----------------------------------------------------------------------+\n\ninclude_once(PHPWG_ROOT_PATH.'admin/include/functions.php');\ninclude_once(PHPWG_ROOT_PATH.'admin/include/image.class.php');\n\n// add default event handler for image and thumbnail resize\nadd_event_handler('upload_image_resize', 'pwg_image_resize');\nadd_event_handler('upload_thumbnail_resize', 'pwg_image_resize');\n\nfunction get_upload_form_config()\n{\n  // default configuration for upload\n  $upload_form_config = array(\n    'original_resize' => array(\n      'default' => false,\n      'can_be_null' => false,\n      ),\n\n    'original_resize_maxwidth' => array(\n      'default' => 2000,\n      'min' => 500,\n      'max' => 20000,\n      'pattern' => '/^\\d+$/',\n      'can_be_null' => false,\n      'error_message' => l10n('The original maximum width must be a number between %d and %d'),\n      ),\n\n    'original_resize_maxheight' => array(\n      'default' => 2000,\n      'min' => 300,\n      'max' => 20000,\n      'pattern' => '/^\\d+$/',\n      'can_be_null' => false,\n      'error_message' => l10n('The original maximum height must be a number between %d and %d'),\n      ),\n\n    'original_resize_quality' => array(\n      'default' => 95,\n      'min' => 50,\n      'max' => 98,\n      'pattern' => '/^\\d+$/',\n      'can_be_null' => false,\n      'error_message' => l10n('The original image quality must be a number between %d and %d'),\n      ),\n    );\n\n  return $upload_form_config;\n}\n\nfunction save_upload_form_config($data, &$errors=array(), &$form_errors=array())\n{\n  if (!is_array($data) or empty($data))\n  {\n    return false;\n  }\n\n  $upload_form_config = get_upload_form_config();\n  $updates = array();\n\n  foreach ($data as $field => $value)\n  {\n    if (!isset($upload_form_config[$field]))\n    {\n      continue;\n    }\n    if (is_bool($upload_form_config[$field]['default']))\n    {\n      if (isset($value))\n      {\n        $value = true;\n      }\n      else\n      {\n        $value = false;\n      }\n\n      $updates[] = array(\n        'param' => $field,\n        'value' => boolean_to_string($value)\n        );\n    }\n    elseif ($upload_form_config[$field]['can_be_null'] and empty($value))\n    {\n      $updates[] = array(\n        'param' => $field,\n        'value' => 'false'\n        );\n    }\n    else\n    {\n      $min = $upload_form_config[$field]['min'];\n      $max = $upload_form_config[$field]['max'];\n      $pattern = $upload_form_config[$field]['pattern'];\n\n      if (preg_match($pattern, $value) and $value >= $min and $value <= $max)\n      {\n         $updates[] = array(\n          'param' => $field,\n          'value' => $value\n          );\n      }\n      else\n      {\n        $errors[] = sprintf(\n          $upload_form_config[$field]['error_message'],\n          $min, $max\n          );\n\n        $form_errors[$field] = '['.$min.' .. '.$max.']';\n      }\n    }\n  }\n\n  if (count($errors) == 0)\n  {\n    mass_updates(\n      CONFIG_TABLE,\n      array(\n        'primary' => array('param'),\n        'update' => array('value')\n        ),\n      $updates\n      );\n    return true;\n  }\n\n  return false;\n}\n\nfunction add_uploaded_file($source_filepath, $original_filename=null, $categories=null, $level=null, $image_id=null, $original_md5sum=null)\n{\n  // 1) move uploaded file to upload/2010/01/22/20100122003814-449ada00.jpg\n  //\n  // 2) keep/resize original\n  //\n  // 3) register in database\n\n  // TODO\n  // * check md5sum (already exists?)\n\n  global $conf, $user;\n\n  if (isset($original_md5sum))\n  {\n    $md5sum = $original_md5sum;\n  }\n  else\n  {\n    $md5sum = md5_file($source_filepath);\n  }\n\n  $file_path = null;\n  $is_tiff = false;\n\n  if (isset($image_id))\n  {\n    // this photo already exists, we update it\n    $query = '\nSELECT\n    path\n  FROM '.IMAGES_TABLE.'\n  WHERE id = '.$image_id.'\n;';\n    $result = pwg_query($query);\n    while ($row = pwg_db_fetch_assoc($result))\n    {\n      $file_path = $row['path'];\n    }\n\n    if (!isset($file_path))\n    {\n      die('['.__FUNCTION__.'] this photo does not exist in the database');\n    }\n\n    // delete all physical files related to the photo (thumbnail, web site, HD)\n    delete_element_files(array($image_id));\n  }\n  else\n  {\n    // this photo is new\n\n    // current date\n    list($dbnow) = pwg_db_fetch_row(pwg_query('SELECT NOW();'));\n    list($year, $month, $day) = preg_split('/[^\\d]/', $dbnow, 4);\n\n    // upload directory hierarchy\n    $upload_dir = sprintf(\n      PHPWG_ROOT_PATH.$conf['upload_dir'].'/%s/%s/%s',\n      $year,\n      $month,\n      $day\n      );\n\n    // compute file path\n    $date_string = preg_replace('/[^\\d]/', '', $dbnow);\n    $random_string = substr($md5sum, 0, 8);\n    $filename_wo_ext = $date_string.'-'.$random_string;\n    $file_path = $upload_dir.'/'.$filename_wo_ext.'.';\n\n    list($width, $height, $type) = getimagesize($source_filepath);\n    \n    if (IMAGETYPE_PNG == $type)\n    {\n      $file_path.= 'png';\n    }\n    elseif (IMAGETYPE_GIF == $type)\n    {\n      $file_path.= 'gif';\n    }\n    elseif (IMAGETYPE_TIFF_MM == $type or IMAGETYPE_TIFF_II == $type)\n    {\n      $is_tiff = true;\n      $file_path.= 'tif';\n    }\n    elseif (IMAGETYPE_JPEG == $type)\n    {\n      $file_path.= 'jpg';\n    }\n    elseif (isset($conf['upload_form_all_types']) and $conf['upload_form_all_types'])\n    {\n      $original_extension = strtolower(get_extension($original_filename));\n\n      if (in_array($original_extension, $conf['file_ext']))\n      {\n        $file_path.= $original_extension;\n      }\n      else\n      {\n        die('unexpected file type');\n      }\n    }\n    else\n    {\n      die('forbidden file type');\n    }\n\n    prepare_directory($upload_dir);\n  }\n\n  if (is_uploaded_file($source_filepath))\n  {\n    move_uploaded_file($source_filepath, $file_path);\n  }\n  else\n  {\n    rename($source_filepath, $file_path);\n  }\n  @chmod($file_path, 0644);\n\n  // handle the uploaded file type by potentially making a\n  // pwg_representative file.\n  $representative_ext = trigger_change('upload_file', null, $file_path);\n\n  global $logger;\n  $logger->info(\"Handling \" . (string)$file_path . \" got \" . (string)$representative_ext);\n  \n  // If it is set to either true (the file didn't need a\n  // representative generated) or false (the generation of the\n  // representative failed), set it to null because we have no\n  // representative file.\n  if (is_bool($representative_ext)) {\n    $representative_ext = null;\n  }\n  \n  if (pwg_image::get_library() != 'gd')\n  {\n    if ($conf['original_resize'])\n    {\n      $need_resize = need_resize($file_path, $conf['original_resize_maxwidth'], $conf['original_resize_maxheight']);\n\n      if ($need_resize)\n      {\n        $img = new pwg_image($file_path);\n\n        $img->pwg_resize(\n          $file_path,\n          $conf['original_resize_maxwidth'],\n          $conf['original_resize_maxheight'],\n          $conf['original_resize_quality'],\n          $conf['upload_form_automatic_rotation'],\n          false\n          );\n\n        $img->destroy();\n      }\n    }\n  }\n\n  // we need to save the rotation angle in the database to compute\n  // width/height of \"multisizes\"\n  $rotation_angle = pwg_image::get_rotation_angle($file_path);\n  $rotation = pwg_image::get_rotation_code_from_angle($rotation_angle);\n\n  $file_infos = pwg_image_infos($file_path);\n\n  if (isset($image_id))\n  {\n    $update = array(\n      'file' => pwg_db_real_escape_string(isset($original_filename) ? $original_filename : basename($file_path)),\n      'filesize' => $file_infos['filesize'],\n      'width' => $file_infos['width'],\n      'height' => $file_infos['height'],\n      'md5sum' => $md5sum,\n      'added_by' => $user['id'],\n      'rotation' => $rotation,\n      );\n\n    if (isset($level))\n    {\n      $update['level'] = $level;\n    }\n\n    single_update(\n      IMAGES_TABLE,\n      $update,\n      array('id' => $image_id)\n      );\n  }\n  else\n  {\n    // database registration\n    $file = pwg_db_real_escape_string(isset($original_filename) ? $original_filename : basename($file_path));\n    $insert = array(\n      'file' => $file,\n      'name' => get_name_from_file($file),\n      'date_available' => $dbnow,\n      'path' => preg_replace('#^'.preg_quote(PHPWG_ROOT_PATH).'#', '', $file_path),\n      'filesize' => $file_infos['filesize'],\n      'width' => $file_infos['width'],\n      'height' => $file_infos['height'],\n      'md5sum' => $md5sum,\n      'added_by' => $user['id'],\n      'rotation' => $rotation,\n      );\n\n    if (isset($level))\n    {\n      $insert['level'] = $level;\n    }\n\n    if (isset($representative_ext))\n    {\n      $insert['representative_ext'] = $representative_ext;\n    }\n\n    single_insert(IMAGES_TABLE, $insert);\n\n    $image_id = pwg_db_insert_id(IMAGES_TABLE);\n  }\n\n  if (isset($categories) and count($categories) > 0)\n  {\n    associate_images_to_categories(\n      array($image_id),\n      $categories\n      );\n  }\n\n  // update metadata from the uploaded file (exif/iptc)\n  if ($conf['use_exif'] and !function_exists('read_exif_data'))\n  {\n    $conf['use_exif'] = false;\n  }\n  sync_metadata(array($image_id));\n\n  invalidate_user_cache();\n\n  // cache thumbnail\n  $query = '\nSELECT\n    id,\n    path\n  FROM '.IMAGES_TABLE.'\n  WHERE id = '.$image_id.'\n;';\n  $image_infos = pwg_db_fetch_assoc(pwg_query($query));\n\n  set_make_full_url();\n  // in case we are on uploadify.php, we have to replace the false path\n  $thumb_url = preg_replace('#admin/include/i#', 'i', DerivativeImage::thumb_url($image_infos));\n  unset_make_full_url();\n\n  fetchRemote($thumb_url, $dest);\n\n\n  return $image_id;\n}\n\nadd_event_handler('upload_file', 'upload_file_pdf');\nfunction upload_file_pdf($representative_ext, $file_path)\n{\n  global $logger, $conf;\n\n  $logger->info(__FUNCTION__.', $file_path = '.$file_path.', $representative_ext = '.$representative_ext);\n\n  if (isset($representative_ext))\n  {\n    return $representative_ext;\n  }\n\n  if (pwg_image::get_library() != 'ext_imagick')\n  {\n    return $representative_ext;\n  }\n\n  if (!in_array(strtolower(get_extension($file_path)), array('pdf')))\n  {\n    return $representative_ext;\n  }\n\n  $ext = conf_get_param('pdf_representative_ext', 'jpg');\n  $jpg_quality = conf_get_param('pdf_jpg_quality', 90);\n\n  // move the uploaded file to pwg_representative sub-directory\n  $representative_file_path = original_to_representative($file_path, $ext);\n  prepare_directory(dirname($representative_file_path));\n\n  $exec = $conf['ext_imagick_dir'].'convert';\n  if ('jpg' == $ext)\n  {\n    $exec.= ' -quality '.$jpg_quality;\n  }\n  $exec.= ' \"'.realpath($file_path).'\"[0]';\n  $exec.= ' \"'.$representative_file_path.'\"';\n  $exec.= ' 2>&1';\n  @exec($exec, $returnarray);\n\n  // Return the extension (if successful) or false (if failed)\n  if (file_exists($representative_file_path))\n  {\n    $representative_ext = $ext;\n  }\n\n  return $representative_ext;\n}\n\nadd_event_handler('upload_file', 'upload_file_tiff');\nfunction upload_file_tiff($representative_ext, $file_path)\n{\n  global $logger, $conf;\n\n  $logger->info(__FUNCTION__.', $file_path = '.$file_path.', $representative_ext = '.$representative_ext);\n\n  if (isset($representative_ext))\n  {\n    return $representative_ext;\n  }\n\n  if (pwg_image::get_library() != 'ext_imagick')\n  {\n    return $representative_ext;\n  }\n\n  if (!in_array(strtolower(get_extension($file_path)), array('tif', 'tiff')))\n  {\n    return $representative_ext;\n  }\n\n  // move the uploaded file to pwg_representative sub-directory\n  $representative_file_path = dirname($file_path).'/pwg_representative/';\n  $representative_file_path.= get_filename_wo_extension(basename($file_path)).'.';\n\n  $representative_ext = $conf['tiff_representative_ext'];\n  $representative_file_path.= $representative_ext;\n\n  prepare_directory(dirname($representative_file_path));\n\n  $exec = $conf['ext_imagick_dir'].'convert';\n\n  if ('jpg' == $conf['tiff_representative_ext'])\n  {\n    $exec .= ' -quality 98';\n  }\n\n  $exec .= ' \"'.realpath($file_path).'\"';\n\n  $dest = pathinfo($representative_file_path);\n  $exec .= ' \"'.realpath($dest['dirname']).'/'.$dest['basename'].'\"';\n\n  $exec .= ' 2>&1';\n  @exec($exec, $returnarray);\n\n  // sometimes ImageMagick creates file-0.jpg (full size) + file-1.jpg\n  // (thumbnail). I don't know how to avoid it.\n  $representative_file_abspath = realpath($dest['dirname']).'/'.$dest['basename'];\n  if (!file_exists($representative_file_abspath))\n  {\n    $first_file_abspath = preg_replace(\n      '/\\.'.$representative_ext.'$/',\n      '-0.'.$representative_ext,\n      $representative_file_abspath\n      );\n\n    if (file_exists($first_file_abspath))\n    {\n      rename($first_file_abspath, $representative_file_abspath);\n    }\n  }\n\n  return get_extension($representative_file_abspath);\n}\n\nadd_event_handler('upload_file', 'upload_file_video');\nfunction upload_file_video($representative_ext, $file_path)\n{\n  global $logger, $conf;\n\n  $logger->info(__FUNCTION__.', $file_path = '.$file_path.', $representative_ext = '.$representative_ext);\n\n  if (isset($representative_ext))\n  {\n    return $representative_ext;\n  }\n\n  $ffmpeg_video_exts = array( // extensions tested with FFmpeg\n    'wmv','mov','mkv','mp4','mpg','flv','asf','xvid','divx','mpeg',\n    'avi','rm', 'm4v', 'ogg', 'ogv', 'webm', 'webmv',\n    );\n\n  if (!in_array(strtolower(get_extension($file_path)), $ffmpeg_video_exts))\n  {\n    return $representative_ext;\n  }\n\n  $representative_file_path = dirname($file_path).'/pwg_representative/';\n  $representative_file_path.= get_filename_wo_extension(basename($file_path)).'.';\n\n  $representative_ext = 'jpg';\n  $representative_file_path.= $representative_ext;\n\n  prepare_directory(dirname($representative_file_path));\n\n  $second = 1;\n\n  $ffmpeg = $conf['ffmpeg_dir'].'ffmpeg';\n  $ffmpeg.= ' -i \"'.$file_path.'\"';\n  $ffmpeg.= ' -an -ss '.$second;\n  $ffmpeg.= ' -t 1 -r 1 -y -vcodec mjpeg -f mjpeg';\n  $ffmpeg.= ' \"'.$representative_file_path.'\"';\n\n  @exec($ffmpeg);\n\n  if (!file_exists($representative_file_path))\n  {\n    return null;\n  }\n\n  return $representative_ext;\n}\n\nfunction prepare_directory($directory)\n{\n  if (!is_dir($directory)) {\n    if (substr(PHP_OS, 0, 3) == 'WIN')\n    {\n      $directory = str_replace('/', DIRECTORY_SEPARATOR, $directory);\n    }\n    umask(0000);\n    $recursive = true;\n    if (!@mkdir($directory, 0777, $recursive))\n    {\n      die('[prepare_directory] cannot create directory \"'.$directory.'\"');\n    }\n  }\n\n  if (!is_writable($directory))\n  {\n    // last chance to make the directory writable\n    @chmod($directory, 0777);\n\n    if (!is_writable($directory))\n    {\n      die('[prepare_directory] directory \"'.$directory.'\" has no write access');\n    }\n  }\n\n  secure_directory($directory);\n}\n\nfunction need_resize($image_filepath, $max_width, $max_height)\n{\n  // TODO : the resize check should take the orientation into account. If a\n  // rotation must be applied to the resized photo, then we should test\n  // invert width and height.\n  list($width, $height) = getimagesize($image_filepath);\n\n  if ($width > $max_width or $height > $max_height)\n  {\n    return true;\n  }\n\n  return false;\n}\n\nfunction pwg_image_infos($path)\n{\n  list($width, $height) = getimagesize($path);\n  $filesize = floor(filesize($path)/1024);\n\n  return array(\n    'width'  => $width,\n    'height' => $height,\n    'filesize' => $filesize,\n    );\n}\n\nfunction is_valid_image_extension($extension)\n{\n  global $conf;\n  \n  if (isset($conf['upload_form_all_types']) and $conf['upload_form_all_types'])\n  {\n    $extensions = $conf['file_ext'];\n  }\n  else\n  {\n    $extensions = $conf['picture_ext'];\n  }\n\n  return array_unique(array_map('strtolower', $extensions));\n}\n\nfunction file_upload_error_message($error_code)\n{\n  switch ($error_code) {\n    case UPLOAD_ERR_INI_SIZE:\n      return sprintf(\n        l10n('The uploaded file exceeds the upload_max_filesize directive in php.ini: %sB'),\n        get_ini_size('upload_max_filesize', false)\n        );\n    case UPLOAD_ERR_FORM_SIZE:\n      return l10n('The uploaded file exceeds the MAX_FILE_SIZE directive that was specified in the HTML form');\n    case UPLOAD_ERR_PARTIAL:\n      return l10n('The uploaded file was only partially uploaded');\n    case UPLOAD_ERR_NO_FILE:\n      return l10n('No file was uploaded');\n    case UPLOAD_ERR_NO_TMP_DIR:\n      return l10n('Missing a temporary folder');\n    case UPLOAD_ERR_CANT_WRITE:\n      return l10n('Failed to write file to disk');\n    case UPLOAD_ERR_EXTENSION:\n      return l10n('File upload stopped by extension');\n    default:\n      return l10n('Unknown upload error');\n  }\n}\n\nfunction get_ini_size($ini_key, $in_bytes=true)\n{\n  $size = ini_get($ini_key);\n\n  if ($in_bytes)\n  {\n    $size = convert_shorthand_notation_to_bytes($size);\n  }\n\n  return $size;\n}\n\nfunction convert_shorthand_notation_to_bytes($value)\n{\n  $suffix = substr($value, -1);\n  $multiply_by = null;\n\n  if ('K' == $suffix)\n  {\n    $multiply_by = 1024;\n  }\n  else if ('M' == $suffix)\n  {\n    $multiply_by = 1024*1024;\n  }\n  else if ('G' == $suffix)\n  {\n    $multiply_by = 1024*1024*1024;\n  }\n\n  if (isset($multiply_by))\n  {\n    $value = substr($value, 0, -1);\n    $value*= $multiply_by;\n  }\n\n  return $value;\n}\n\nfunction add_upload_error($upload_id, $error_message)\n{\n  $_SESSION['uploads_error'][$upload_id][] = $error_message;\n}\n\nfunction ready_for_upload_message()\n{\n  global $conf;\n\n  $relative_dir = preg_replace('#^'.PHPWG_ROOT_PATH.'#', '', $conf['upload_dir']);\n\n  if (!is_dir($conf['upload_dir']))\n  {\n    if (!is_writable(dirname($conf['upload_dir'])))\n    {\n      return sprintf(\n        l10n('Create the \"%s\" directory at the root of your Piwigo installation'),\n        $relative_dir\n        );\n    }\n  }\n  else\n  {\n    if (!is_writable($conf['upload_dir']))\n    {\n      @chmod($conf['upload_dir'], 0777);\n\n      if (!is_writable($conf['upload_dir']))\n      {\n        return sprintf(\n          l10n('Give write access (chmod 777) to \"%s\" directory at the root of your Piwigo installation'),\n          $relative_dir\n          );\n      }\n    }\n  }\n\n  return null;\n}\n?>"], "fixing_code": ["<?php\n// +-----------------------------------------------------------------------+\n// | Piwigo - a PHP based photo gallery                                    |\n// +-----------------------------------------------------------------------+\n// | Copyright(C) 2008-2016 Piwigo Team                  http://piwigo.org |\n// | Copyright(C) 2003-2008 PhpWebGallery Team    http://phpwebgallery.net |\n// | Copyright(C) 2002-2003 Pierrick LE GALL   http://le-gall.net/pierrick |\n// +-----------------------------------------------------------------------+\n// | This program is free software; you can redistribute it and/or modify  |\n// | it under the terms of the GNU General Public License as published by  |\n// | the Free Software Foundation                                          |\n// |                                                                       |\n// | This program is distributed in the hope that it will be useful, but   |\n// | WITHOUT ANY WARRANTY; without even the implied warranty of            |\n// | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU      |\n// | General Public License for more details.                              |\n// |                                                                       |\n// | You should have received a copy of the GNU General Public License     |\n// | along with this program; if not, write to the Free Software           |\n// | Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, |\n// | USA.                                                                  |\n// +-----------------------------------------------------------------------+\n\ndefine('PHPWG_ROOT_PATH','./');\nsession_cache_limiter('public');\ninclude_once(PHPWG_ROOT_PATH.'include/common.inc.php');\n\n// Check Access and exit when user status is not ok\ncheck_status(ACCESS_GUEST);\n\nfunction guess_mime_type($ext)\n{\n  switch ( strtolower($ext) )\n  {\n    case \"jpe\": case \"jpeg\":\n    case \"jpg\": $ctype=\"image/jpeg\"; break;\n    case \"png\": $ctype=\"image/png\"; break;\n    case \"gif\": $ctype=\"image/gif\"; break;\n    case \"tiff\":\n    case \"tif\": $ctype=\"image/tiff\"; break;\n    case \"txt\": $ctype=\"text/plain\"; break;\n    case \"html\":\n    case \"htm\": $ctype=\"text/html\"; break;\n    case \"xml\": $ctype=\"text/xml\"; break;\n    case \"pdf\": $ctype=\"application/pdf\"; break;\n    case \"zip\": $ctype=\"application/zip\"; break;\n    case \"ogg\": $ctype=\"application/ogg\"; break;\n    default: $ctype=\"application/octet-stream\";\n  }\n  return $ctype;\n}\n\nfunction do_error( $code, $str )\n{\n  set_status_header( $code );\n  echo $str ;\n  exit();\n}\n\nif ($conf['enable_formats'] and isset($_GET['format']))\n{\n  check_input_parameter('format', $_GET, false, PATTERN_ID);\n\n  $query = '\nSELECT\n    *\n  FROM '.IMAGE_FORMAT_TABLE.'\n  WHERE format_id = '.$_GET['format'].'\n;';\n  $formats = query2array($query);\n\n  if (count($formats) == 0)\n  {\n    do_error(400, 'Invalid request - format');\n  }\n\n  $format = $formats[0];\n\n  $_GET['id'] = $format['image_id'];\n  $_GET['part'] = 'f'; // \"f\" for \"format\"\n}\n\n\nif (!isset($_GET['id'])\n    or !is_numeric($_GET['id'])\n    or !isset($_GET['part'])\n    or !in_array($_GET['part'], array('e','r','f') ) )\n{\n  do_error(400, 'Invalid request - id/part');\n}\n\n$query = '\nSELECT * FROM '. IMAGES_TABLE.'\n  WHERE id='.$_GET['id'].'\n;';\n\n$element_info = pwg_db_fetch_assoc(pwg_query($query));\nif ( empty($element_info) )\n{\n  do_error(404, 'Requested id not found');\n}\n\n// special download action for admins\n$is_admin_download = false;\nif (is_admin() and isset($_GET['pwg_token']) and get_pwg_token() == $_GET['pwg_token'])\n{\n  $is_admin_download = true;\n  $user['enabled_high'] = true;\n}\n\n$src_image = new SrcImage($element_info);\n\n// $filter['visible_categories'] and $filter['visible_images']\n// are not used because it's not necessary (filter <> restriction)\n$query='\nSELECT id\n  FROM '.CATEGORIES_TABLE.'\n    INNER JOIN '.IMAGE_CATEGORY_TABLE.' ON category_id = id\n  WHERE image_id = '.$_GET['id'].'\n'.get_sql_condition_FandF(\n  array(\n      'forbidden_categories' => 'category_id',\n      'forbidden_images' => 'image_id',\n    ),\n  '    AND'\n  ).'\n  LIMIT 1\n;';\nif (!$is_admin_download and pwg_db_num_rows(pwg_query($query))<1 )\n{\n  do_error(401, 'Access denied');\n}\n\ninclude_once(PHPWG_ROOT_PATH.'include/functions_picture.inc.php');\n$file='';\nswitch ($_GET['part'])\n{\n  case 'e':\n    if ( $src_image->is_original() and !$user['enabled_high'] )\n    {// we have a photo and the user has no access to HD\n      $deriv = new DerivativeImage(IMG_XXLARGE, $src_image);\n      if ( !$deriv->same_as_source() )\n      {\n        do_error(401, 'Access denied e');\n      }\n    }\n    $file = get_element_path($element_info);\n    break;\n  case 'r':\n    $file = original_to_representative( get_element_path($element_info), $element_info['representative_ext'] );\n    break;\n  case 'f' :\n    $file = original_to_format(get_element_path($element_info), $format['ext']);\n    $element_info['file'] = get_filename_wo_extension($element_info['file']).'.'.$format['ext'];\n    break;\n}\n\nif ( empty($file) )\n{\n  do_error(404, 'Requested file not found');\n}\n\nif ($_GET['part'] == 'e') {\n  pwg_log($_GET['id'], 'high');\n}\nelse if ($_GET['part'] == 'e')\n{\n  pwg_log($_GET['id'], 'other');\n}\nelse if ($_GET['part'] == 'f')\n{\n  pwg_log($_GET['id'], 'high', $format['format_id']);\n}\n\n$http_headers = array();\n\n$ctype = null;\nif (!url_is_remote($file))\n{\n  if ( !@is_readable($file) )\n  {\n    do_error(404, \"Requested file not found - $file\");\n  }\n  $http_headers[] = 'Content-Length: '.@filesize($file);\n  if ( function_exists('mime_content_type') )\n  {\n    $ctype = mime_content_type($file);\n  }\n\n  $gmt_mtime = gmdate('D, d M Y H:i:s', filemtime($file)).' GMT';\n  $http_headers[] = 'Last-Modified: '.$gmt_mtime;\n\n  // following lines would indicate how the client should handle the cache\n  /* $max_age=300;\n  $http_headers[] = 'Expires: '.gmdate('D, d M Y H:i:s', time()+$max_age).' GMT';\n  // HTTP/1.1 only\n  $http_headers[] = 'Cache-Control: private, must-revalidate, max-age='.$max_age;*/\n\n  if ('f' != $_GET['part'] and isset( $_SERVER['HTTP_IF_MODIFIED_SINCE'] ) )\n  {\n    set_status_header(304);\n    foreach ($http_headers as $header)\n    {\n      header( $header );\n    }\n    exit();\n  }\n}\n\nif (!isset($ctype))\n{ // give it a guess\n  $ctype = guess_mime_type( get_extension($file) );\n}\n\n$http_headers[] = 'Content-Type: '.$ctype;\n\nif (isset($_GET['download']))\n{\n  $http_headers[] = 'Content-Disposition: attachment; filename=\"'.htmlspecialchars_decode($element_info['file']).'\";';\n  $http_headers[] = 'Content-Transfer-Encoding: binary';\n}\nelse\n{\n  $http_headers[] = 'Content-Disposition: inline; filename=\"'\n            .basename($file).'\";';\n}\n\nforeach ($http_headers as $header)\n{\n  header( $header );\n}\n\n// Looking at the safe_mode configuration for execution time\nif (ini_get('safe_mode') == 0)\n{\n  @set_time_limit(0);\n}\n\n@readfile($file);\n\n?>", "<?php\n// +-----------------------------------------------------------------------+\n// | Piwigo - a PHP based photo gallery                                    |\n// +-----------------------------------------------------------------------+\n// | Copyright(C) 2008-2016 Piwigo Team                  http://piwigo.org |\n// | Copyright(C) 2003-2008 PhpWebGallery Team    http://phpwebgallery.net |\n// | Copyright(C) 2002-2003 Pierrick LE GALL   http://le-gall.net/pierrick |\n// +-----------------------------------------------------------------------+\n// | This program is free software; you can redistribute it and/or modify  |\n// | it under the terms of the GNU General Public License as published by  |\n// | the Free Software Foundation                                          |\n// |                                                                       |\n// | This program is distributed in the hope that it will be useful, but   |\n// | WITHOUT ANY WARRANTY; without even the implied warranty of            |\n// | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU      |\n// | General Public License for more details.                              |\n// |                                                                       |\n// | You should have received a copy of the GNU General Public License     |\n// | along with this program; if not, write to the Free Software           |\n// | Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, |\n// | USA.                                                                  |\n// +-----------------------------------------------------------------------+\n\ninclude_once(PHPWG_ROOT_PATH.'admin/include/functions.php');\ninclude_once(PHPWG_ROOT_PATH.'admin/include/image.class.php');\n\n// add default event handler for image and thumbnail resize\nadd_event_handler('upload_image_resize', 'pwg_image_resize');\nadd_event_handler('upload_thumbnail_resize', 'pwg_image_resize');\n\nfunction get_upload_form_config()\n{\n  // default configuration for upload\n  $upload_form_config = array(\n    'original_resize' => array(\n      'default' => false,\n      'can_be_null' => false,\n      ),\n\n    'original_resize_maxwidth' => array(\n      'default' => 2000,\n      'min' => 500,\n      'max' => 20000,\n      'pattern' => '/^\\d+$/',\n      'can_be_null' => false,\n      'error_message' => l10n('The original maximum width must be a number between %d and %d'),\n      ),\n\n    'original_resize_maxheight' => array(\n      'default' => 2000,\n      'min' => 300,\n      'max' => 20000,\n      'pattern' => '/^\\d+$/',\n      'can_be_null' => false,\n      'error_message' => l10n('The original maximum height must be a number between %d and %d'),\n      ),\n\n    'original_resize_quality' => array(\n      'default' => 95,\n      'min' => 50,\n      'max' => 98,\n      'pattern' => '/^\\d+$/',\n      'can_be_null' => false,\n      'error_message' => l10n('The original image quality must be a number between %d and %d'),\n      ),\n    );\n\n  return $upload_form_config;\n}\n\nfunction save_upload_form_config($data, &$errors=array(), &$form_errors=array())\n{\n  if (!is_array($data) or empty($data))\n  {\n    return false;\n  }\n\n  $upload_form_config = get_upload_form_config();\n  $updates = array();\n\n  foreach ($data as $field => $value)\n  {\n    if (!isset($upload_form_config[$field]))\n    {\n      continue;\n    }\n    if (is_bool($upload_form_config[$field]['default']))\n    {\n      if (isset($value))\n      {\n        $value = true;\n      }\n      else\n      {\n        $value = false;\n      }\n\n      $updates[] = array(\n        'param' => $field,\n        'value' => boolean_to_string($value)\n        );\n    }\n    elseif ($upload_form_config[$field]['can_be_null'] and empty($value))\n    {\n      $updates[] = array(\n        'param' => $field,\n        'value' => 'false'\n        );\n    }\n    else\n    {\n      $min = $upload_form_config[$field]['min'];\n      $max = $upload_form_config[$field]['max'];\n      $pattern = $upload_form_config[$field]['pattern'];\n\n      if (preg_match($pattern, $value) and $value >= $min and $value <= $max)\n      {\n         $updates[] = array(\n          'param' => $field,\n          'value' => $value\n          );\n      }\n      else\n      {\n        $errors[] = sprintf(\n          $upload_form_config[$field]['error_message'],\n          $min, $max\n          );\n\n        $form_errors[$field] = '['.$min.' .. '.$max.']';\n      }\n    }\n  }\n\n  if (count($errors) == 0)\n  {\n    mass_updates(\n      CONFIG_TABLE,\n      array(\n        'primary' => array('param'),\n        'update' => array('value')\n        ),\n      $updates\n      );\n    return true;\n  }\n\n  return false;\n}\n\nfunction add_uploaded_file($source_filepath, $original_filename=null, $categories=null, $level=null, $image_id=null, $original_md5sum=null)\n{\n  // 1) move uploaded file to upload/2010/01/22/20100122003814-449ada00.jpg\n  //\n  // 2) keep/resize original\n  //\n  // 3) register in database\n\n  // TODO\n  // * check md5sum (already exists?)\n\n  global $conf, $user;\n\n  if (!is_null($original_filename))\n  {\n    $original_filename = htmlspecialchars($original_filename);\n  }\n\n  if (isset($original_md5sum))\n  {\n    $md5sum = $original_md5sum;\n  }\n  else\n  {\n    $md5sum = md5_file($source_filepath);\n  }\n\n  $file_path = null;\n  $is_tiff = false;\n\n  if (isset($image_id))\n  {\n    // this photo already exists, we update it\n    $query = '\nSELECT\n    path\n  FROM '.IMAGES_TABLE.'\n  WHERE id = '.$image_id.'\n;';\n    $result = pwg_query($query);\n    while ($row = pwg_db_fetch_assoc($result))\n    {\n      $file_path = $row['path'];\n    }\n\n    if (!isset($file_path))\n    {\n      die('['.__FUNCTION__.'] this photo does not exist in the database');\n    }\n\n    // delete all physical files related to the photo (thumbnail, web site, HD)\n    delete_element_files(array($image_id));\n  }\n  else\n  {\n    // this photo is new\n\n    // current date\n    list($dbnow) = pwg_db_fetch_row(pwg_query('SELECT NOW();'));\n    list($year, $month, $day) = preg_split('/[^\\d]/', $dbnow, 4);\n\n    // upload directory hierarchy\n    $upload_dir = sprintf(\n      PHPWG_ROOT_PATH.$conf['upload_dir'].'/%s/%s/%s',\n      $year,\n      $month,\n      $day\n      );\n\n    // compute file path\n    $date_string = preg_replace('/[^\\d]/', '', $dbnow);\n    $random_string = substr($md5sum, 0, 8);\n    $filename_wo_ext = $date_string.'-'.$random_string;\n    $file_path = $upload_dir.'/'.$filename_wo_ext.'.';\n\n    list($width, $height, $type) = getimagesize($source_filepath);\n    \n    if (IMAGETYPE_PNG == $type)\n    {\n      $file_path.= 'png';\n    }\n    elseif (IMAGETYPE_GIF == $type)\n    {\n      $file_path.= 'gif';\n    }\n    elseif (IMAGETYPE_TIFF_MM == $type or IMAGETYPE_TIFF_II == $type)\n    {\n      $is_tiff = true;\n      $file_path.= 'tif';\n    }\n    elseif (IMAGETYPE_JPEG == $type)\n    {\n      $file_path.= 'jpg';\n    }\n    elseif (isset($conf['upload_form_all_types']) and $conf['upload_form_all_types'])\n    {\n      $original_extension = strtolower(get_extension($original_filename));\n\n      if (in_array($original_extension, $conf['file_ext']))\n      {\n        $file_path.= $original_extension;\n      }\n      else\n      {\n        die('unexpected file type');\n      }\n    }\n    else\n    {\n      die('forbidden file type');\n    }\n\n    prepare_directory($upload_dir);\n  }\n\n  if (is_uploaded_file($source_filepath))\n  {\n    move_uploaded_file($source_filepath, $file_path);\n  }\n  else\n  {\n    rename($source_filepath, $file_path);\n  }\n  @chmod($file_path, 0644);\n\n  // handle the uploaded file type by potentially making a\n  // pwg_representative file.\n  $representative_ext = trigger_change('upload_file', null, $file_path);\n\n  global $logger;\n  $logger->info(\"Handling \" . (string)$file_path . \" got \" . (string)$representative_ext);\n  \n  // If it is set to either true (the file didn't need a\n  // representative generated) or false (the generation of the\n  // representative failed), set it to null because we have no\n  // representative file.\n  if (is_bool($representative_ext)) {\n    $representative_ext = null;\n  }\n  \n  if (pwg_image::get_library() != 'gd')\n  {\n    if ($conf['original_resize'])\n    {\n      $need_resize = need_resize($file_path, $conf['original_resize_maxwidth'], $conf['original_resize_maxheight']);\n\n      if ($need_resize)\n      {\n        $img = new pwg_image($file_path);\n\n        $img->pwg_resize(\n          $file_path,\n          $conf['original_resize_maxwidth'],\n          $conf['original_resize_maxheight'],\n          $conf['original_resize_quality'],\n          $conf['upload_form_automatic_rotation'],\n          false\n          );\n\n        $img->destroy();\n      }\n    }\n  }\n\n  // we need to save the rotation angle in the database to compute\n  // width/height of \"multisizes\"\n  $rotation_angle = pwg_image::get_rotation_angle($file_path);\n  $rotation = pwg_image::get_rotation_code_from_angle($rotation_angle);\n\n  $file_infos = pwg_image_infos($file_path);\n\n  if (isset($image_id))\n  {\n    $update = array(\n      'file' => pwg_db_real_escape_string(isset($original_filename) ? $original_filename : basename($file_path)),\n      'filesize' => $file_infos['filesize'],\n      'width' => $file_infos['width'],\n      'height' => $file_infos['height'],\n      'md5sum' => $md5sum,\n      'added_by' => $user['id'],\n      'rotation' => $rotation,\n      );\n\n    if (isset($level))\n    {\n      $update['level'] = $level;\n    }\n\n    single_update(\n      IMAGES_TABLE,\n      $update,\n      array('id' => $image_id)\n      );\n  }\n  else\n  {\n    // database registration\n    $file = pwg_db_real_escape_string(isset($original_filename) ? $original_filename : basename($file_path));\n    $insert = array(\n      'file' => $file,\n      'name' => get_name_from_file($file),\n      'date_available' => $dbnow,\n      'path' => preg_replace('#^'.preg_quote(PHPWG_ROOT_PATH).'#', '', $file_path),\n      'filesize' => $file_infos['filesize'],\n      'width' => $file_infos['width'],\n      'height' => $file_infos['height'],\n      'md5sum' => $md5sum,\n      'added_by' => $user['id'],\n      'rotation' => $rotation,\n      );\n\n    if (isset($level))\n    {\n      $insert['level'] = $level;\n    }\n\n    if (isset($representative_ext))\n    {\n      $insert['representative_ext'] = $representative_ext;\n    }\n\n    single_insert(IMAGES_TABLE, $insert);\n\n    $image_id = pwg_db_insert_id(IMAGES_TABLE);\n  }\n\n  if (isset($categories) and count($categories) > 0)\n  {\n    associate_images_to_categories(\n      array($image_id),\n      $categories\n      );\n  }\n\n  // update metadata from the uploaded file (exif/iptc)\n  if ($conf['use_exif'] and !function_exists('read_exif_data'))\n  {\n    $conf['use_exif'] = false;\n  }\n  sync_metadata(array($image_id));\n\n  invalidate_user_cache();\n\n  // cache thumbnail\n  $query = '\nSELECT\n    id,\n    path\n  FROM '.IMAGES_TABLE.'\n  WHERE id = '.$image_id.'\n;';\n  $image_infos = pwg_db_fetch_assoc(pwg_query($query));\n\n  set_make_full_url();\n  // in case we are on uploadify.php, we have to replace the false path\n  $thumb_url = preg_replace('#admin/include/i#', 'i', DerivativeImage::thumb_url($image_infos));\n  unset_make_full_url();\n\n  fetchRemote($thumb_url, $dest);\n\n\n  return $image_id;\n}\n\nadd_event_handler('upload_file', 'upload_file_pdf');\nfunction upload_file_pdf($representative_ext, $file_path)\n{\n  global $logger, $conf;\n\n  $logger->info(__FUNCTION__.', $file_path = '.$file_path.', $representative_ext = '.$representative_ext);\n\n  if (isset($representative_ext))\n  {\n    return $representative_ext;\n  }\n\n  if (pwg_image::get_library() != 'ext_imagick')\n  {\n    return $representative_ext;\n  }\n\n  if (!in_array(strtolower(get_extension($file_path)), array('pdf')))\n  {\n    return $representative_ext;\n  }\n\n  $ext = conf_get_param('pdf_representative_ext', 'jpg');\n  $jpg_quality = conf_get_param('pdf_jpg_quality', 90);\n\n  // move the uploaded file to pwg_representative sub-directory\n  $representative_file_path = original_to_representative($file_path, $ext);\n  prepare_directory(dirname($representative_file_path));\n\n  $exec = $conf['ext_imagick_dir'].'convert';\n  if ('jpg' == $ext)\n  {\n    $exec.= ' -quality '.$jpg_quality;\n  }\n  $exec.= ' \"'.realpath($file_path).'\"[0]';\n  $exec.= ' \"'.$representative_file_path.'\"';\n  $exec.= ' 2>&1';\n  @exec($exec, $returnarray);\n\n  // Return the extension (if successful) or false (if failed)\n  if (file_exists($representative_file_path))\n  {\n    $representative_ext = $ext;\n  }\n\n  return $representative_ext;\n}\n\nadd_event_handler('upload_file', 'upload_file_tiff');\nfunction upload_file_tiff($representative_ext, $file_path)\n{\n  global $logger, $conf;\n\n  $logger->info(__FUNCTION__.', $file_path = '.$file_path.', $representative_ext = '.$representative_ext);\n\n  if (isset($representative_ext))\n  {\n    return $representative_ext;\n  }\n\n  if (pwg_image::get_library() != 'ext_imagick')\n  {\n    return $representative_ext;\n  }\n\n  if (!in_array(strtolower(get_extension($file_path)), array('tif', 'tiff')))\n  {\n    return $representative_ext;\n  }\n\n  // move the uploaded file to pwg_representative sub-directory\n  $representative_file_path = dirname($file_path).'/pwg_representative/';\n  $representative_file_path.= get_filename_wo_extension(basename($file_path)).'.';\n\n  $representative_ext = $conf['tiff_representative_ext'];\n  $representative_file_path.= $representative_ext;\n\n  prepare_directory(dirname($representative_file_path));\n\n  $exec = $conf['ext_imagick_dir'].'convert';\n\n  if ('jpg' == $conf['tiff_representative_ext'])\n  {\n    $exec .= ' -quality 98';\n  }\n\n  $exec .= ' \"'.realpath($file_path).'\"';\n\n  $dest = pathinfo($representative_file_path);\n  $exec .= ' \"'.realpath($dest['dirname']).'/'.$dest['basename'].'\"';\n\n  $exec .= ' 2>&1';\n  @exec($exec, $returnarray);\n\n  // sometimes ImageMagick creates file-0.jpg (full size) + file-1.jpg\n  // (thumbnail). I don't know how to avoid it.\n  $representative_file_abspath = realpath($dest['dirname']).'/'.$dest['basename'];\n  if (!file_exists($representative_file_abspath))\n  {\n    $first_file_abspath = preg_replace(\n      '/\\.'.$representative_ext.'$/',\n      '-0.'.$representative_ext,\n      $representative_file_abspath\n      );\n\n    if (file_exists($first_file_abspath))\n    {\n      rename($first_file_abspath, $representative_file_abspath);\n    }\n  }\n\n  return get_extension($representative_file_abspath);\n}\n\nadd_event_handler('upload_file', 'upload_file_video');\nfunction upload_file_video($representative_ext, $file_path)\n{\n  global $logger, $conf;\n\n  $logger->info(__FUNCTION__.', $file_path = '.$file_path.', $representative_ext = '.$representative_ext);\n\n  if (isset($representative_ext))\n  {\n    return $representative_ext;\n  }\n\n  $ffmpeg_video_exts = array( // extensions tested with FFmpeg\n    'wmv','mov','mkv','mp4','mpg','flv','asf','xvid','divx','mpeg',\n    'avi','rm', 'm4v', 'ogg', 'ogv', 'webm', 'webmv',\n    );\n\n  if (!in_array(strtolower(get_extension($file_path)), $ffmpeg_video_exts))\n  {\n    return $representative_ext;\n  }\n\n  $representative_file_path = dirname($file_path).'/pwg_representative/';\n  $representative_file_path.= get_filename_wo_extension(basename($file_path)).'.';\n\n  $representative_ext = 'jpg';\n  $representative_file_path.= $representative_ext;\n\n  prepare_directory(dirname($representative_file_path));\n\n  $second = 1;\n\n  $ffmpeg = $conf['ffmpeg_dir'].'ffmpeg';\n  $ffmpeg.= ' -i \"'.$file_path.'\"';\n  $ffmpeg.= ' -an -ss '.$second;\n  $ffmpeg.= ' -t 1 -r 1 -y -vcodec mjpeg -f mjpeg';\n  $ffmpeg.= ' \"'.$representative_file_path.'\"';\n\n  @exec($ffmpeg);\n\n  if (!file_exists($representative_file_path))\n  {\n    return null;\n  }\n\n  return $representative_ext;\n}\n\nfunction prepare_directory($directory)\n{\n  if (!is_dir($directory)) {\n    if (substr(PHP_OS, 0, 3) == 'WIN')\n    {\n      $directory = str_replace('/', DIRECTORY_SEPARATOR, $directory);\n    }\n    umask(0000);\n    $recursive = true;\n    if (!@mkdir($directory, 0777, $recursive))\n    {\n      die('[prepare_directory] cannot create directory \"'.$directory.'\"');\n    }\n  }\n\n  if (!is_writable($directory))\n  {\n    // last chance to make the directory writable\n    @chmod($directory, 0777);\n\n    if (!is_writable($directory))\n    {\n      die('[prepare_directory] directory \"'.$directory.'\" has no write access');\n    }\n  }\n\n  secure_directory($directory);\n}\n\nfunction need_resize($image_filepath, $max_width, $max_height)\n{\n  // TODO : the resize check should take the orientation into account. If a\n  // rotation must be applied to the resized photo, then we should test\n  // invert width and height.\n  list($width, $height) = getimagesize($image_filepath);\n\n  if ($width > $max_width or $height > $max_height)\n  {\n    return true;\n  }\n\n  return false;\n}\n\nfunction pwg_image_infos($path)\n{\n  list($width, $height) = getimagesize($path);\n  $filesize = floor(filesize($path)/1024);\n\n  return array(\n    'width'  => $width,\n    'height' => $height,\n    'filesize' => $filesize,\n    );\n}\n\nfunction is_valid_image_extension($extension)\n{\n  global $conf;\n  \n  if (isset($conf['upload_form_all_types']) and $conf['upload_form_all_types'])\n  {\n    $extensions = $conf['file_ext'];\n  }\n  else\n  {\n    $extensions = $conf['picture_ext'];\n  }\n\n  return array_unique(array_map('strtolower', $extensions));\n}\n\nfunction file_upload_error_message($error_code)\n{\n  switch ($error_code) {\n    case UPLOAD_ERR_INI_SIZE:\n      return sprintf(\n        l10n('The uploaded file exceeds the upload_max_filesize directive in php.ini: %sB'),\n        get_ini_size('upload_max_filesize', false)\n        );\n    case UPLOAD_ERR_FORM_SIZE:\n      return l10n('The uploaded file exceeds the MAX_FILE_SIZE directive that was specified in the HTML form');\n    case UPLOAD_ERR_PARTIAL:\n      return l10n('The uploaded file was only partially uploaded');\n    case UPLOAD_ERR_NO_FILE:\n      return l10n('No file was uploaded');\n    case UPLOAD_ERR_NO_TMP_DIR:\n      return l10n('Missing a temporary folder');\n    case UPLOAD_ERR_CANT_WRITE:\n      return l10n('Failed to write file to disk');\n    case UPLOAD_ERR_EXTENSION:\n      return l10n('File upload stopped by extension');\n    default:\n      return l10n('Unknown upload error');\n  }\n}\n\nfunction get_ini_size($ini_key, $in_bytes=true)\n{\n  $size = ini_get($ini_key);\n\n  if ($in_bytes)\n  {\n    $size = convert_shorthand_notation_to_bytes($size);\n  }\n\n  return $size;\n}\n\nfunction convert_shorthand_notation_to_bytes($value)\n{\n  $suffix = substr($value, -1);\n  $multiply_by = null;\n\n  if ('K' == $suffix)\n  {\n    $multiply_by = 1024;\n  }\n  else if ('M' == $suffix)\n  {\n    $multiply_by = 1024*1024;\n  }\n  else if ('G' == $suffix)\n  {\n    $multiply_by = 1024*1024*1024;\n  }\n\n  if (isset($multiply_by))\n  {\n    $value = substr($value, 0, -1);\n    $value*= $multiply_by;\n  }\n\n  return $value;\n}\n\nfunction add_upload_error($upload_id, $error_message)\n{\n  $_SESSION['uploads_error'][$upload_id][] = $error_message;\n}\n\nfunction ready_for_upload_message()\n{\n  global $conf;\n\n  $relative_dir = preg_replace('#^'.PHPWG_ROOT_PATH.'#', '', $conf['upload_dir']);\n\n  if (!is_dir($conf['upload_dir']))\n  {\n    if (!is_writable(dirname($conf['upload_dir'])))\n    {\n      return sprintf(\n        l10n('Create the \"%s\" directory at the root of your Piwigo installation'),\n        $relative_dir\n        );\n    }\n  }\n  else\n  {\n    if (!is_writable($conf['upload_dir']))\n    {\n      @chmod($conf['upload_dir'], 0777);\n\n      if (!is_writable($conf['upload_dir']))\n      {\n        return sprintf(\n          l10n('Give write access (chmod 777) to \"%s\" directory at the root of your Piwigo installation'),\n          $relative_dir\n          );\n      }\n    }\n  }\n\n  return null;\n}\n?>"], "filenames": ["action.php", "admin/include/functions_upload.inc.php"], "buggy_code_start_loc": [219, 163], "buggy_code_end_loc": [220, 163], "fixing_code_start_loc": [219, 164], "fixing_code_end_loc": [220, 169], "type": "CWE-79", "message": "Cross-site scripting (XSS) vulnerability in the image upload function in Piwigo before 2.8.6 allows remote attackers to inject arbitrary web script or HTML via a crafted image filename.", "other": {"cve": {"id": "CVE-2017-5608", "sourceIdentifier": "cve@mitre.org", "published": "2017-01-28T18:59:00.133", "lastModified": "2017-02-03T16:08:47.620", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Cross-site scripting (XSS) vulnerability in the image upload function in Piwigo before 2.8.6 allows remote attackers to inject arbitrary web script or HTML via a crafted image filename."}, {"lang": "es", "value": "Vulnerabilidad XSS en la funci\u00f3n de carga de im\u00e1genes en Piwigo en versiones anteriores a 2.8.6 permite a un atacantes inyectar secuencias de comandos web o HTML arbitrarios a trav\u00e9s de un nombre de archivo de imagen manipulado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:piwigo:piwigo:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.8.5", "matchCriteriaId": "6B6B020F-0D8F-4DCB-A443-6A1398E0B3DA"}]}]}], "references": [{"url": "http://piwigo.org/releases/2.8.6", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "http://www.securityfocus.com/bid/95848", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/Piwigo/Piwigo/commit/6ec3f2d0fae0437f0c2cc8c475a26fb6aeb0d4cb", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/Piwigo/Piwigo/issues/600", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Piwigo/Piwigo/commit/6ec3f2d0fae0437f0c2cc8c475a26fb6aeb0d4cb"}}