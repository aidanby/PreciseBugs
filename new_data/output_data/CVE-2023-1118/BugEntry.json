{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n * driver for ENE KB3926 B/C/D/E/F CIR (pnp id: ENE0XXX)\n *\n * Copyright (C) 2010 Maxim Levitsky <maximlevitsky@gmail.com>\n *\n * Special thanks to:\n *   Sami R. <maesesami@gmail.com> for lot of help in debugging and therefore\n *    bringing to life support for transmission & learning mode.\n *\n *   Charlie Andrews <charliethepilot@googlemail.com> for lots of help in\n *   bringing up the support of new firmware buffer that is popular\n *   on latest notebooks\n *\n *   ENE for partial device documentation\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pnp.h>\n#include <linux/io.h>\n#include <linux/interrupt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <media/rc-core.h>\n#include \"ene_ir.h\"\n\nstatic int sample_period;\nstatic bool learning_mode_force;\nstatic int debug;\nstatic bool txsim;\n\nstatic void ene_set_reg_addr(struct ene_device *dev, u16 reg)\n{\n\toutb(reg >> 8, dev->hw_io + ENE_ADDR_HI);\n\toutb(reg & 0xFF, dev->hw_io + ENE_ADDR_LO);\n}\n\n/* read a hardware register */\nstatic u8 ene_read_reg(struct ene_device *dev, u16 reg)\n{\n\tu8 retval;\n\tene_set_reg_addr(dev, reg);\n\tretval = inb(dev->hw_io + ENE_IO);\n\tdbg_regs(\"reg %04x == %02x\", reg, retval);\n\treturn retval;\n}\n\n/* write a hardware register */\nstatic void ene_write_reg(struct ene_device *dev, u16 reg, u8 value)\n{\n\tdbg_regs(\"reg %04x <- %02x\", reg, value);\n\tene_set_reg_addr(dev, reg);\n\toutb(value, dev->hw_io + ENE_IO);\n}\n\n/* Set bits in hardware register */\nstatic void ene_set_reg_mask(struct ene_device *dev, u16 reg, u8 mask)\n{\n\tdbg_regs(\"reg %04x |= %02x\", reg, mask);\n\tene_set_reg_addr(dev, reg);\n\toutb(inb(dev->hw_io + ENE_IO) | mask, dev->hw_io + ENE_IO);\n}\n\n/* Clear bits in hardware register */\nstatic void ene_clear_reg_mask(struct ene_device *dev, u16 reg, u8 mask)\n{\n\tdbg_regs(\"reg %04x &= ~%02x \", reg, mask);\n\tene_set_reg_addr(dev, reg);\n\toutb(inb(dev->hw_io + ENE_IO) & ~mask, dev->hw_io + ENE_IO);\n}\n\n/* A helper to set/clear a bit in register according to boolean variable */\nstatic void ene_set_clear_reg_mask(struct ene_device *dev, u16 reg, u8 mask,\n\t\t\t\t\t\t\t\tbool set)\n{\n\tif (set)\n\t\tene_set_reg_mask(dev, reg, mask);\n\telse\n\t\tene_clear_reg_mask(dev, reg, mask);\n}\n\n/* detect hardware features */\nstatic int ene_hw_detect(struct ene_device *dev)\n{\n\tu8 chip_major, chip_minor;\n\tu8 hw_revision, old_ver;\n\tu8 fw_reg2, fw_reg1;\n\n\tene_clear_reg_mask(dev, ENE_ECSTS, ENE_ECSTS_RSRVD);\n\tchip_major = ene_read_reg(dev, ENE_ECVER_MAJOR);\n\tchip_minor = ene_read_reg(dev, ENE_ECVER_MINOR);\n\tene_set_reg_mask(dev, ENE_ECSTS, ENE_ECSTS_RSRVD);\n\n\thw_revision = ene_read_reg(dev, ENE_ECHV);\n\told_ver = ene_read_reg(dev, ENE_HW_VER_OLD);\n\n\tdev->pll_freq = (ene_read_reg(dev, ENE_PLLFRH) << 4) +\n\t\t(ene_read_reg(dev, ENE_PLLFRL) >> 4);\n\n\tif (sample_period != ENE_DEFAULT_SAMPLE_PERIOD)\n\t\tdev->rx_period_adjust =\n\t\t\tdev->pll_freq == ENE_DEFAULT_PLL_FREQ ? 2 : 4;\n\n\tif (hw_revision == 0xFF) {\n\t\tpr_warn(\"device seems to be disabled\\n\");\n\t\tpr_warn(\"send a mail to lirc-list@lists.sourceforge.net\\n\");\n\t\tpr_warn(\"please attach output of acpidump and dmidecode\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpr_notice(\"chip is 0x%02x%02x - kbver = 0x%02x, rev = 0x%02x\\n\",\n\t\t  chip_major, chip_minor, old_ver, hw_revision);\n\n\tpr_notice(\"PLL freq = %d\\n\", dev->pll_freq);\n\n\tif (chip_major == 0x33) {\n\t\tpr_warn(\"chips 0x33xx aren't supported\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (chip_major == 0x39 && chip_minor == 0x26 && hw_revision == 0xC0) {\n\t\tdev->hw_revision = ENE_HW_C;\n\t\tpr_notice(\"KB3926C detected\\n\");\n\t} else if (old_ver == 0x24 && hw_revision == 0xC0) {\n\t\tdev->hw_revision = ENE_HW_B;\n\t\tpr_notice(\"KB3926B detected\\n\");\n\t} else {\n\t\tdev->hw_revision = ENE_HW_D;\n\t\tpr_notice(\"KB3926D or higher detected\\n\");\n\t}\n\n\t/* detect features hardware supports */\n\tif (dev->hw_revision < ENE_HW_C)\n\t\treturn 0;\n\n\tfw_reg1 = ene_read_reg(dev, ENE_FW1);\n\tfw_reg2 = ene_read_reg(dev, ENE_FW2);\n\n\tpr_notice(\"Firmware regs: %02x %02x\\n\", fw_reg1, fw_reg2);\n\n\tdev->hw_use_gpio_0a = !!(fw_reg2 & ENE_FW2_GP0A);\n\tdev->hw_learning_and_tx_capable = !!(fw_reg2 & ENE_FW2_LEARNING);\n\tdev->hw_extra_buffer = !!(fw_reg1 & ENE_FW1_HAS_EXTRA_BUF);\n\n\tif (dev->hw_learning_and_tx_capable)\n\t\tdev->hw_fan_input = !!(fw_reg2 & ENE_FW2_FAN_INPUT);\n\n\tpr_notice(\"Hardware features:\\n\");\n\n\tif (dev->hw_learning_and_tx_capable) {\n\t\tpr_notice(\"* Supports transmitting & learning mode\\n\");\n\t\tpr_notice(\"   This feature is rare and therefore,\\n\");\n\t\tpr_notice(\"   you are welcome to test it,\\n\");\n\t\tpr_notice(\"   and/or contact the author via:\\n\");\n\t\tpr_notice(\"   lirc-list@lists.sourceforge.net\\n\");\n\t\tpr_notice(\"   or maximlevitsky@gmail.com\\n\");\n\n\t\tpr_notice(\"* Uses GPIO %s for IR raw input\\n\",\n\t\t\t  dev->hw_use_gpio_0a ? \"40\" : \"0A\");\n\n\t\tif (dev->hw_fan_input)\n\t\t\tpr_notice(\"* Uses unused fan feedback input as source of demodulated IR data\\n\");\n\t}\n\n\tif (!dev->hw_fan_input)\n\t\tpr_notice(\"* Uses GPIO %s for IR demodulated input\\n\",\n\t\t\t  dev->hw_use_gpio_0a ? \"0A\" : \"40\");\n\n\tif (dev->hw_extra_buffer)\n\t\tpr_notice(\"* Uses new style input buffer\\n\");\n\treturn 0;\n}\n\n/* Read properties of hw sample buffer */\nstatic void ene_rx_setup_hw_buffer(struct ene_device *dev)\n{\n\tu16 tmp;\n\n\tene_rx_read_hw_pointer(dev);\n\tdev->r_pointer = dev->w_pointer;\n\n\tif (!dev->hw_extra_buffer) {\n\t\tdev->buffer_len = ENE_FW_PACKET_SIZE * 2;\n\t\treturn;\n\t}\n\n\ttmp = ene_read_reg(dev, ENE_FW_SAMPLE_BUFFER);\n\ttmp |= ene_read_reg(dev, ENE_FW_SAMPLE_BUFFER+1) << 8;\n\tdev->extra_buf1_address = tmp;\n\n\tdev->extra_buf1_len = ene_read_reg(dev, ENE_FW_SAMPLE_BUFFER + 2);\n\n\ttmp = ene_read_reg(dev, ENE_FW_SAMPLE_BUFFER + 3);\n\ttmp |= ene_read_reg(dev, ENE_FW_SAMPLE_BUFFER + 4) << 8;\n\tdev->extra_buf2_address = tmp;\n\n\tdev->extra_buf2_len = ene_read_reg(dev, ENE_FW_SAMPLE_BUFFER + 5);\n\n\tdev->buffer_len = dev->extra_buf1_len + dev->extra_buf2_len + 8;\n\n\tpr_notice(\"Hardware uses 2 extended buffers:\\n\");\n\tpr_notice(\"  0x%04x - len : %d\\n\",\n\t\t  dev->extra_buf1_address, dev->extra_buf1_len);\n\tpr_notice(\"  0x%04x - len : %d\\n\",\n\t\t  dev->extra_buf2_address, dev->extra_buf2_len);\n\n\tpr_notice(\"Total buffer len = %d\\n\", dev->buffer_len);\n\n\tif (dev->buffer_len > 64 || dev->buffer_len < 16)\n\t\tgoto error;\n\n\tif (dev->extra_buf1_address > 0xFBFC ||\n\t\t\t\t\tdev->extra_buf1_address < 0xEC00)\n\t\tgoto error;\n\n\tif (dev->extra_buf2_address > 0xFBFC ||\n\t\t\t\t\tdev->extra_buf2_address < 0xEC00)\n\t\tgoto error;\n\n\tif (dev->r_pointer > dev->buffer_len)\n\t\tgoto error;\n\n\tene_set_reg_mask(dev, ENE_FW1, ENE_FW1_EXTRA_BUF_HND);\n\treturn;\nerror:\n\tpr_warn(\"Error validating extra buffers, device probably won't work\\n\");\n\tdev->hw_extra_buffer = false;\n\tene_clear_reg_mask(dev, ENE_FW1, ENE_FW1_EXTRA_BUF_HND);\n}\n\n\n/* Restore the pointers to extra buffers - to make module reload work*/\nstatic void ene_rx_restore_hw_buffer(struct ene_device *dev)\n{\n\tif (!dev->hw_extra_buffer)\n\t\treturn;\n\n\tene_write_reg(dev, ENE_FW_SAMPLE_BUFFER + 0,\n\t\t\t\tdev->extra_buf1_address & 0xFF);\n\tene_write_reg(dev, ENE_FW_SAMPLE_BUFFER + 1,\n\t\t\t\tdev->extra_buf1_address >> 8);\n\tene_write_reg(dev, ENE_FW_SAMPLE_BUFFER + 2, dev->extra_buf1_len);\n\n\tene_write_reg(dev, ENE_FW_SAMPLE_BUFFER + 3,\n\t\t\t\tdev->extra_buf2_address & 0xFF);\n\tene_write_reg(dev, ENE_FW_SAMPLE_BUFFER + 4,\n\t\t\t\tdev->extra_buf2_address >> 8);\n\tene_write_reg(dev, ENE_FW_SAMPLE_BUFFER + 5,\n\t\t\t\tdev->extra_buf2_len);\n\tene_clear_reg_mask(dev, ENE_FW1, ENE_FW1_EXTRA_BUF_HND);\n}\n\n/* Read hardware write pointer */\nstatic void ene_rx_read_hw_pointer(struct ene_device *dev)\n{\n\tif (dev->hw_extra_buffer)\n\t\tdev->w_pointer = ene_read_reg(dev, ENE_FW_RX_POINTER);\n\telse\n\t\tdev->w_pointer = ene_read_reg(dev, ENE_FW2)\n\t\t\t& ENE_FW2_BUF_WPTR ? 0 : ENE_FW_PACKET_SIZE;\n\n\tdbg_verbose(\"RB: HW write pointer: %02x, driver read pointer: %02x\",\n\t\tdev->w_pointer, dev->r_pointer);\n}\n\n/* Gets address of next sample from HW ring buffer */\nstatic int ene_rx_get_sample_reg(struct ene_device *dev)\n{\n\tint r_pointer;\n\n\tif (dev->r_pointer == dev->w_pointer) {\n\t\tdbg_verbose(\"RB: hit end, try update w_pointer\");\n\t\tene_rx_read_hw_pointer(dev);\n\t}\n\n\tif (dev->r_pointer == dev->w_pointer) {\n\t\tdbg_verbose(\"RB: end of data at %d\", dev->r_pointer);\n\t\treturn 0;\n\t}\n\n\tdbg_verbose(\"RB: reading at offset %d\", dev->r_pointer);\n\tr_pointer = dev->r_pointer;\n\n\tdev->r_pointer++;\n\tif (dev->r_pointer == dev->buffer_len)\n\t\tdev->r_pointer = 0;\n\n\tdbg_verbose(\"RB: next read will be from offset %d\", dev->r_pointer);\n\n\tif (r_pointer < 8) {\n\t\tdbg_verbose(\"RB: read at main buffer at %d\", r_pointer);\n\t\treturn ENE_FW_SAMPLE_BUFFER + r_pointer;\n\t}\n\n\tr_pointer -= 8;\n\n\tif (r_pointer < dev->extra_buf1_len) {\n\t\tdbg_verbose(\"RB: read at 1st extra buffer at %d\", r_pointer);\n\t\treturn dev->extra_buf1_address + r_pointer;\n\t}\n\n\tr_pointer -= dev->extra_buf1_len;\n\n\tif (r_pointer < dev->extra_buf2_len) {\n\t\tdbg_verbose(\"RB: read at 2nd extra buffer at %d\", r_pointer);\n\t\treturn dev->extra_buf2_address + r_pointer;\n\t}\n\n\tdbg(\"attempt to read beyond ring buffer end\");\n\treturn 0;\n}\n\n/* Sense current received carrier */\nstatic void ene_rx_sense_carrier(struct ene_device *dev)\n{\n\tint carrier, duty_cycle;\n\tint period = ene_read_reg(dev, ENE_CIRCAR_PRD);\n\tint hperiod = ene_read_reg(dev, ENE_CIRCAR_HPRD);\n\n\tif (!(period & ENE_CIRCAR_PRD_VALID))\n\t\treturn;\n\n\tperiod &= ~ENE_CIRCAR_PRD_VALID;\n\n\tif (!period)\n\t\treturn;\n\n\tdbg(\"RX: hardware carrier period = %02x\", period);\n\tdbg(\"RX: hardware carrier pulse period = %02x\", hperiod);\n\n\tcarrier = 2000000 / period;\n\tduty_cycle = (hperiod * 100) / period;\n\tdbg(\"RX: sensed carrier = %d Hz, duty cycle %d%%\",\n\t\t\t\t\t\tcarrier, duty_cycle);\n\tif (dev->carrier_detect_enabled) {\n\t\tstruct ir_raw_event ev = {\n\t\t\t.carrier_report = true,\n\t\t\t.carrier = carrier,\n\t\t\t.duty_cycle = duty_cycle\n\t\t};\n\t\tir_raw_event_store(dev->rdev, &ev);\n\t}\n}\n\n/* this enables/disables the CIR RX engine */\nstatic void ene_rx_enable_cir_engine(struct ene_device *dev, bool enable)\n{\n\tene_set_clear_reg_mask(dev, ENE_CIRCFG,\n\t\t\tENE_CIRCFG_RX_EN | ENE_CIRCFG_RX_IRQ, enable);\n}\n\n/* this selects input for CIR engine. Ether GPIO 0A or GPIO40*/\nstatic void ene_rx_select_input(struct ene_device *dev, bool gpio_0a)\n{\n\tene_set_clear_reg_mask(dev, ENE_CIRCFG2, ENE_CIRCFG2_GPIO0A, gpio_0a);\n}\n\n/*\n * this enables alternative input via fan tachometer sensor and bypasses\n * the hw CIR engine\n */\nstatic void ene_rx_enable_fan_input(struct ene_device *dev, bool enable)\n{\n\tif (!dev->hw_fan_input)\n\t\treturn;\n\n\tif (!enable)\n\t\tene_write_reg(dev, ENE_FAN_AS_IN1, 0);\n\telse {\n\t\tene_write_reg(dev, ENE_FAN_AS_IN1, ENE_FAN_AS_IN1_EN);\n\t\tene_write_reg(dev, ENE_FAN_AS_IN2, ENE_FAN_AS_IN2_EN);\n\t}\n}\n\n/* setup the receiver for RX*/\nstatic void ene_rx_setup(struct ene_device *dev)\n{\n\tbool learning_mode = dev->learning_mode_enabled ||\n\t\t\t\t\tdev->carrier_detect_enabled;\n\tint sample_period_adjust = 0;\n\n\tdbg(\"RX: setup receiver, learning mode = %d\", learning_mode);\n\n\n\t/* This selects RLC input and clears CFG2 settings */\n\tene_write_reg(dev, ENE_CIRCFG2, 0x00);\n\n\t/* set sample period*/\n\tif (sample_period == ENE_DEFAULT_SAMPLE_PERIOD)\n\t\tsample_period_adjust =\n\t\t\tdev->pll_freq == ENE_DEFAULT_PLL_FREQ ? 1 : 2;\n\n\tene_write_reg(dev, ENE_CIRRLC_CFG,\n\t\t\t(sample_period + sample_period_adjust) |\n\t\t\t\t\t\tENE_CIRRLC_CFG_OVERFLOW);\n\t/* revB doesn't support inputs */\n\tif (dev->hw_revision < ENE_HW_C)\n\t\tgoto select_timeout;\n\n\tif (learning_mode) {\n\n\t\tWARN_ON(!dev->hw_learning_and_tx_capable);\n\n\t\t/* Enable the opposite of the normal input\n\t\tThat means that if GPIO40 is normally used, use GPIO0A\n\t\tand vice versa.\n\t\tThis input will carry non demodulated\n\t\tsignal, and we will tell the hw to demodulate it itself */\n\t\tene_rx_select_input(dev, !dev->hw_use_gpio_0a);\n\t\tdev->rx_fan_input_inuse = false;\n\n\t\t/* Enable carrier demodulation */\n\t\tene_set_reg_mask(dev, ENE_CIRCFG, ENE_CIRCFG_CARR_DEMOD);\n\n\t\t/* Enable carrier detection */\n\t\tene_write_reg(dev, ENE_CIRCAR_PULS, 0x63);\n\t\tene_set_clear_reg_mask(dev, ENE_CIRCFG2, ENE_CIRCFG2_CARR_DETECT,\n\t\t\tdev->carrier_detect_enabled || debug);\n\t} else {\n\t\tif (dev->hw_fan_input)\n\t\t\tdev->rx_fan_input_inuse = true;\n\t\telse\n\t\t\tene_rx_select_input(dev, dev->hw_use_gpio_0a);\n\n\t\t/* Disable carrier detection & demodulation */\n\t\tene_clear_reg_mask(dev, ENE_CIRCFG, ENE_CIRCFG_CARR_DEMOD);\n\t\tene_clear_reg_mask(dev, ENE_CIRCFG2, ENE_CIRCFG2_CARR_DETECT);\n\t}\n\nselect_timeout:\n\tif (dev->rx_fan_input_inuse) {\n\t\tdev->rdev->rx_resolution = ENE_FW_SAMPLE_PERIOD_FAN;\n\n\t\t/* Fan input doesn't support timeouts, it just ends the\n\t\t\tinput with a maximum sample */\n\t\tdev->rdev->min_timeout = dev->rdev->max_timeout =\n\t\t\tENE_FW_SMPL_BUF_FAN_MSK *\n\t\t\t\tENE_FW_SAMPLE_PERIOD_FAN;\n\t} else {\n\t\tdev->rdev->rx_resolution = sample_period;\n\n\t\t/* Theoreticly timeout is unlimited, but we cap it\n\t\t * because it was seen that on one device, it\n\t\t * would stop sending spaces after around 250 msec.\n\t\t * Besides, this is close to 2^32 anyway and timeout is u32.\n\t\t */\n\t\tdev->rdev->min_timeout = 127 * sample_period;\n\t\tdev->rdev->max_timeout = 200000;\n\t}\n\n\tif (dev->hw_learning_and_tx_capable)\n\t\tdev->rdev->tx_resolution = sample_period;\n\n\tif (dev->rdev->timeout > dev->rdev->max_timeout)\n\t\tdev->rdev->timeout = dev->rdev->max_timeout;\n\tif (dev->rdev->timeout < dev->rdev->min_timeout)\n\t\tdev->rdev->timeout = dev->rdev->min_timeout;\n}\n\n/* Enable the device for receive */\nstatic void ene_rx_enable_hw(struct ene_device *dev)\n{\n\tu8 reg_value;\n\n\t/* Enable system interrupt */\n\tif (dev->hw_revision < ENE_HW_C) {\n\t\tene_write_reg(dev, ENEB_IRQ, dev->irq << 1);\n\t\tene_write_reg(dev, ENEB_IRQ_UNK1, 0x01);\n\t} else {\n\t\treg_value = ene_read_reg(dev, ENE_IRQ) & 0xF0;\n\t\treg_value |= ENE_IRQ_UNK_EN;\n\t\treg_value &= ~ENE_IRQ_STATUS;\n\t\treg_value |= (dev->irq & ENE_IRQ_MASK);\n\t\tene_write_reg(dev, ENE_IRQ, reg_value);\n\t}\n\n\t/* Enable inputs */\n\tene_rx_enable_fan_input(dev, dev->rx_fan_input_inuse);\n\tene_rx_enable_cir_engine(dev, !dev->rx_fan_input_inuse);\n\n\t/* ack any pending irqs - just in case */\n\tene_irq_status(dev);\n\n\t/* enable firmware bits */\n\tene_set_reg_mask(dev, ENE_FW1, ENE_FW1_ENABLE | ENE_FW1_IRQ);\n\n\t/* enter idle mode */\n\tir_raw_event_set_idle(dev->rdev, true);\n}\n\n/* Enable the device for receive - wrapper to track the state*/\nstatic void ene_rx_enable(struct ene_device *dev)\n{\n\tene_rx_enable_hw(dev);\n\tdev->rx_enabled = true;\n}\n\n/* Disable the device receiver */\nstatic void ene_rx_disable_hw(struct ene_device *dev)\n{\n\t/* disable inputs */\n\tene_rx_enable_cir_engine(dev, false);\n\tene_rx_enable_fan_input(dev, false);\n\n\t/* disable hardware IRQ and firmware flag */\n\tene_clear_reg_mask(dev, ENE_FW1, ENE_FW1_ENABLE | ENE_FW1_IRQ);\n\tir_raw_event_set_idle(dev->rdev, true);\n}\n\n/* Disable the device receiver - wrapper to track the state */\nstatic void ene_rx_disable(struct ene_device *dev)\n{\n\tene_rx_disable_hw(dev);\n\tdev->rx_enabled = false;\n}\n\n/* This resets the receiver. Useful to stop stream of spaces at end of\n * transmission\n */\nstatic void ene_rx_reset(struct ene_device *dev)\n{\n\tene_clear_reg_mask(dev, ENE_CIRCFG, ENE_CIRCFG_RX_EN);\n\tene_set_reg_mask(dev, ENE_CIRCFG, ENE_CIRCFG_RX_EN);\n}\n\n/* Set up the TX carrier frequency and duty cycle */\nstatic void ene_tx_set_carrier(struct ene_device *dev)\n{\n\tu8 tx_puls_width;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->hw_lock, flags);\n\n\tene_set_clear_reg_mask(dev, ENE_CIRCFG,\n\t\tENE_CIRCFG_TX_CARR, dev->tx_period > 0);\n\n\tif (!dev->tx_period)\n\t\tgoto unlock;\n\n\tBUG_ON(dev->tx_duty_cycle >= 100 || dev->tx_duty_cycle <= 0);\n\n\ttx_puls_width = dev->tx_period / (100 / dev->tx_duty_cycle);\n\n\tif (!tx_puls_width)\n\t\ttx_puls_width = 1;\n\n\tdbg(\"TX: pulse distance = %d * 500 ns\", dev->tx_period);\n\tdbg(\"TX: pulse width = %d * 500 ns\", tx_puls_width);\n\n\tene_write_reg(dev, ENE_CIRMOD_PRD, dev->tx_period | ENE_CIRMOD_PRD_POL);\n\tene_write_reg(dev, ENE_CIRMOD_HPRD, tx_puls_width);\nunlock:\n\tspin_unlock_irqrestore(&dev->hw_lock, flags);\n}\n\n/* Enable/disable transmitters */\nstatic void ene_tx_set_transmitters(struct ene_device *dev)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->hw_lock, flags);\n\tene_set_clear_reg_mask(dev, ENE_GPIOFS8, ENE_GPIOFS8_GPIO41,\n\t\t\t\t\t!!(dev->transmitter_mask & 0x01));\n\tene_set_clear_reg_mask(dev, ENE_GPIOFS1, ENE_GPIOFS1_GPIO0D,\n\t\t\t\t\t!!(dev->transmitter_mask & 0x02));\n\tspin_unlock_irqrestore(&dev->hw_lock, flags);\n}\n\n/* prepare transmission */\nstatic void ene_tx_enable(struct ene_device *dev)\n{\n\tu8 conf1 = ene_read_reg(dev, ENE_CIRCFG);\n\tu8 fwreg2 = ene_read_reg(dev, ENE_FW2);\n\n\tdev->saved_conf1 = conf1;\n\n\t/* Show information about currently connected transmitter jacks */\n\tif (fwreg2 & ENE_FW2_EMMITER1_CONN)\n\t\tdbg(\"TX: Transmitter #1 is connected\");\n\n\tif (fwreg2 & ENE_FW2_EMMITER2_CONN)\n\t\tdbg(\"TX: Transmitter #2 is connected\");\n\n\tif (!(fwreg2 & (ENE_FW2_EMMITER1_CONN | ENE_FW2_EMMITER2_CONN)))\n\t\tpr_warn(\"TX: transmitter cable isn't connected!\\n\");\n\n\t/* disable receive on revc */\n\tif (dev->hw_revision == ENE_HW_C)\n\t\tconf1 &= ~ENE_CIRCFG_RX_EN;\n\n\t/* Enable TX engine */\n\tconf1 |= ENE_CIRCFG_TX_EN | ENE_CIRCFG_TX_IRQ;\n\tene_write_reg(dev, ENE_CIRCFG, conf1);\n}\n\n/* end transmission */\nstatic void ene_tx_disable(struct ene_device *dev)\n{\n\tene_write_reg(dev, ENE_CIRCFG, dev->saved_conf1);\n\tdev->tx_buffer = NULL;\n}\n\n\n/* TX one sample - must be called with dev->hw_lock*/\nstatic void ene_tx_sample(struct ene_device *dev)\n{\n\tu8 raw_tx;\n\tu32 sample;\n\tbool pulse = dev->tx_sample_pulse;\n\n\tif (!dev->tx_buffer) {\n\t\tpr_warn(\"TX: BUG: attempt to transmit NULL buffer\\n\");\n\t\treturn;\n\t}\n\n\t/* Grab next TX sample */\n\tif (!dev->tx_sample) {\n\n\t\tif (dev->tx_pos == dev->tx_len) {\n\t\t\tif (!dev->tx_done) {\n\t\t\t\tdbg(\"TX: no more data to send\");\n\t\t\t\tdev->tx_done = true;\n\t\t\t\tgoto exit;\n\t\t\t} else {\n\t\t\t\tdbg(\"TX: last sample sent by hardware\");\n\t\t\t\tene_tx_disable(dev);\n\t\t\t\tcomplete(&dev->tx_complete);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tsample = dev->tx_buffer[dev->tx_pos++];\n\t\tdev->tx_sample_pulse = !dev->tx_sample_pulse;\n\n\t\tdev->tx_sample = DIV_ROUND_CLOSEST(sample, sample_period);\n\n\t\tif (!dev->tx_sample)\n\t\t\tdev->tx_sample = 1;\n\t}\n\n\traw_tx = min(dev->tx_sample , (unsigned int)ENE_CIRRLC_OUT_MASK);\n\tdev->tx_sample -= raw_tx;\n\n\tdbg(\"TX: sample %8d (%s)\", raw_tx * sample_period,\n\t\t\t\t\t\tpulse ? \"pulse\" : \"space\");\n\tif (pulse)\n\t\traw_tx |= ENE_CIRRLC_OUT_PULSE;\n\n\tene_write_reg(dev,\n\t\tdev->tx_reg ? ENE_CIRRLC_OUT1 : ENE_CIRRLC_OUT0, raw_tx);\n\n\tdev->tx_reg = !dev->tx_reg;\nexit:\n\t/* simulate TX done interrupt */\n\tif (txsim)\n\t\tmod_timer(&dev->tx_sim_timer, jiffies + HZ / 500);\n}\n\n/* timer to simulate tx done interrupt */\nstatic void ene_tx_irqsim(struct timer_list *t)\n{\n\tstruct ene_device *dev = from_timer(dev, t, tx_sim_timer);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->hw_lock, flags);\n\tene_tx_sample(dev);\n\tspin_unlock_irqrestore(&dev->hw_lock, flags);\n}\n\n\n/* read irq status and ack it */\nstatic int ene_irq_status(struct ene_device *dev)\n{\n\tu8 irq_status;\n\tu8 fw_flags1, fw_flags2;\n\tint retval = 0;\n\n\tfw_flags2 = ene_read_reg(dev, ENE_FW2);\n\n\tif (dev->hw_revision < ENE_HW_C) {\n\t\tirq_status = ene_read_reg(dev, ENEB_IRQ_STATUS);\n\n\t\tif (!(irq_status & ENEB_IRQ_STATUS_IR))\n\t\t\treturn 0;\n\n\t\tene_clear_reg_mask(dev, ENEB_IRQ_STATUS, ENEB_IRQ_STATUS_IR);\n\t\treturn ENE_IRQ_RX;\n\t}\n\n\tirq_status = ene_read_reg(dev, ENE_IRQ);\n\tif (!(irq_status & ENE_IRQ_STATUS))\n\t\treturn 0;\n\n\t/* original driver does that twice - a workaround ? */\n\tene_write_reg(dev, ENE_IRQ, irq_status & ~ENE_IRQ_STATUS);\n\tene_write_reg(dev, ENE_IRQ, irq_status & ~ENE_IRQ_STATUS);\n\n\t/* check RX interrupt */\n\tif (fw_flags2 & ENE_FW2_RXIRQ) {\n\t\tretval |= ENE_IRQ_RX;\n\t\tene_write_reg(dev, ENE_FW2, fw_flags2 & ~ENE_FW2_RXIRQ);\n\t}\n\n\t/* check TX interrupt */\n\tfw_flags1 = ene_read_reg(dev, ENE_FW1);\n\tif (fw_flags1 & ENE_FW1_TXIRQ) {\n\t\tene_write_reg(dev, ENE_FW1, fw_flags1 & ~ENE_FW1_TXIRQ);\n\t\tretval |= ENE_IRQ_TX;\n\t}\n\n\treturn retval;\n}\n\n/* interrupt handler */\nstatic irqreturn_t ene_isr(int irq, void *data)\n{\n\tu16 hw_value, reg;\n\tint hw_sample, irq_status;\n\tbool pulse;\n\tunsigned long flags;\n\tirqreturn_t retval = IRQ_NONE;\n\tstruct ene_device *dev = (struct ene_device *)data;\n\tstruct ir_raw_event ev = {};\n\n\tspin_lock_irqsave(&dev->hw_lock, flags);\n\n\tdbg_verbose(\"ISR called\");\n\tene_rx_read_hw_pointer(dev);\n\tirq_status = ene_irq_status(dev);\n\n\tif (!irq_status)\n\t\tgoto unlock;\n\n\tretval = IRQ_HANDLED;\n\n\tif (irq_status & ENE_IRQ_TX) {\n\t\tdbg_verbose(\"TX interrupt\");\n\t\tif (!dev->hw_learning_and_tx_capable) {\n\t\t\tdbg(\"TX interrupt on unsupported device!\");\n\t\t\tgoto unlock;\n\t\t}\n\t\tene_tx_sample(dev);\n\t}\n\n\tif (!(irq_status & ENE_IRQ_RX))\n\t\tgoto unlock;\n\n\tdbg_verbose(\"RX interrupt\");\n\n\tif (dev->hw_learning_and_tx_capable)\n\t\tene_rx_sense_carrier(dev);\n\n\t/* On hardware that don't support extra buffer we need to trust\n\t\tthe interrupt and not track the read pointer */\n\tif (!dev->hw_extra_buffer)\n\t\tdev->r_pointer = dev->w_pointer == 0 ? ENE_FW_PACKET_SIZE : 0;\n\n\twhile (1) {\n\n\t\treg = ene_rx_get_sample_reg(dev);\n\n\t\tdbg_verbose(\"next sample to read at: %04x\", reg);\n\t\tif (!reg)\n\t\t\tbreak;\n\n\t\thw_value = ene_read_reg(dev, reg);\n\n\t\tif (dev->rx_fan_input_inuse) {\n\n\t\t\tint offset = ENE_FW_SMPL_BUF_FAN - ENE_FW_SAMPLE_BUFFER;\n\n\t\t\t/* read high part of the sample */\n\t\t\thw_value |= ene_read_reg(dev, reg + offset) << 8;\n\t\t\tpulse = hw_value & ENE_FW_SMPL_BUF_FAN_PLS;\n\n\t\t\t/* clear space bit, and other unused bits */\n\t\t\thw_value &= ENE_FW_SMPL_BUF_FAN_MSK;\n\t\t\thw_sample = hw_value * ENE_FW_SAMPLE_PERIOD_FAN;\n\n\t\t} else {\n\t\t\tpulse = !(hw_value & ENE_FW_SAMPLE_SPACE);\n\t\t\thw_value &= ~ENE_FW_SAMPLE_SPACE;\n\t\t\thw_sample = hw_value * sample_period;\n\n\t\t\tif (dev->rx_period_adjust) {\n\t\t\t\thw_sample *= 100;\n\t\t\t\thw_sample /= (100 + dev->rx_period_adjust);\n\t\t\t}\n\t\t}\n\n\t\tif (!dev->hw_extra_buffer && !hw_sample) {\n\t\t\tdev->r_pointer = dev->w_pointer;\n\t\t\tcontinue;\n\t\t}\n\n\t\tdbg(\"RX: %d (%s)\", hw_sample, pulse ? \"pulse\" : \"space\");\n\n\t\tev.duration = hw_sample;\n\t\tev.pulse = pulse;\n\t\tir_raw_event_store_with_filter(dev->rdev, &ev);\n\t}\n\n\tir_raw_event_handle(dev->rdev);\nunlock:\n\tspin_unlock_irqrestore(&dev->hw_lock, flags);\n\treturn retval;\n}\n\n/* Initialize default settings */\nstatic void ene_setup_default_settings(struct ene_device *dev)\n{\n\tdev->tx_period = 32;\n\tdev->tx_duty_cycle = 50; /*%*/\n\tdev->transmitter_mask = 0x03;\n\tdev->learning_mode_enabled = learning_mode_force;\n\n\t/* Set reasonable default timeout */\n\tdev->rdev->timeout = MS_TO_US(150);\n}\n\n/* Upload all hardware settings at once. Used at load and resume time */\nstatic void ene_setup_hw_settings(struct ene_device *dev)\n{\n\tif (dev->hw_learning_and_tx_capable) {\n\t\tene_tx_set_carrier(dev);\n\t\tene_tx_set_transmitters(dev);\n\t}\n\n\tene_rx_setup(dev);\n}\n\n/* outside interface: called on first open*/\nstatic int ene_open(struct rc_dev *rdev)\n{\n\tstruct ene_device *dev = rdev->priv;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->hw_lock, flags);\n\tene_rx_enable(dev);\n\tspin_unlock_irqrestore(&dev->hw_lock, flags);\n\treturn 0;\n}\n\n/* outside interface: called on device close*/\nstatic void ene_close(struct rc_dev *rdev)\n{\n\tstruct ene_device *dev = rdev->priv;\n\tunsigned long flags;\n\tspin_lock_irqsave(&dev->hw_lock, flags);\n\n\tene_rx_disable(dev);\n\tspin_unlock_irqrestore(&dev->hw_lock, flags);\n}\n\n/* outside interface: set transmitter mask */\nstatic int ene_set_tx_mask(struct rc_dev *rdev, u32 tx_mask)\n{\n\tstruct ene_device *dev = rdev->priv;\n\tdbg(\"TX: attempt to set transmitter mask %02x\", tx_mask);\n\n\t/* invalid txmask */\n\tif (!tx_mask || tx_mask & ~0x03) {\n\t\tdbg(\"TX: invalid mask\");\n\t\t/* return count of transmitters */\n\t\treturn 2;\n\t}\n\n\tdev->transmitter_mask = tx_mask;\n\tene_tx_set_transmitters(dev);\n\treturn 0;\n}\n\n/* outside interface : set tx carrier */\nstatic int ene_set_tx_carrier(struct rc_dev *rdev, u32 carrier)\n{\n\tstruct ene_device *dev = rdev->priv;\n\tu32 period;\n\n\tdbg(\"TX: attempt to set tx carrier to %d kHz\", carrier);\n\tif (carrier == 0)\n\t\treturn -EINVAL;\n\n\tperiod = 2000000 / carrier;\n\tif (period && (period > ENE_CIRMOD_PRD_MAX ||\n\t\t\tperiod < ENE_CIRMOD_PRD_MIN)) {\n\n\t\tdbg(\"TX: out of range %d-%d kHz carrier\",\n\t\t\t2000 / ENE_CIRMOD_PRD_MIN, 2000 / ENE_CIRMOD_PRD_MAX);\n\t\treturn -EINVAL;\n\t}\n\n\tdev->tx_period = period;\n\tene_tx_set_carrier(dev);\n\treturn 0;\n}\n\n/*outside interface : set tx duty cycle */\nstatic int ene_set_tx_duty_cycle(struct rc_dev *rdev, u32 duty_cycle)\n{\n\tstruct ene_device *dev = rdev->priv;\n\tdbg(\"TX: setting duty cycle to %d%%\", duty_cycle);\n\tdev->tx_duty_cycle = duty_cycle;\n\tene_tx_set_carrier(dev);\n\treturn 0;\n}\n\n/* outside interface: enable learning mode */\nstatic int ene_set_learning_mode(struct rc_dev *rdev, int enable)\n{\n\tstruct ene_device *dev = rdev->priv;\n\tunsigned long flags;\n\tif (enable == dev->learning_mode_enabled)\n\t\treturn 0;\n\n\tspin_lock_irqsave(&dev->hw_lock, flags);\n\tdev->learning_mode_enabled = enable;\n\tene_rx_disable(dev);\n\tene_rx_setup(dev);\n\tene_rx_enable(dev);\n\tspin_unlock_irqrestore(&dev->hw_lock, flags);\n\treturn 0;\n}\n\nstatic int ene_set_carrier_report(struct rc_dev *rdev, int enable)\n{\n\tstruct ene_device *dev = rdev->priv;\n\tunsigned long flags;\n\n\tif (enable == dev->carrier_detect_enabled)\n\t\treturn 0;\n\n\tspin_lock_irqsave(&dev->hw_lock, flags);\n\tdev->carrier_detect_enabled = enable;\n\tene_rx_disable(dev);\n\tene_rx_setup(dev);\n\tene_rx_enable(dev);\n\tspin_unlock_irqrestore(&dev->hw_lock, flags);\n\treturn 0;\n}\n\n/* outside interface: enable or disable idle mode */\nstatic void ene_set_idle(struct rc_dev *rdev, bool idle)\n{\n\tstruct ene_device *dev = rdev->priv;\n\n\tif (idle) {\n\t\tene_rx_reset(dev);\n\t\tdbg(\"RX: end of data\");\n\t}\n}\n\n/* outside interface: transmit */\nstatic int ene_transmit(struct rc_dev *rdev, unsigned *buf, unsigned n)\n{\n\tstruct ene_device *dev = rdev->priv;\n\tunsigned long flags;\n\n\tdev->tx_buffer = buf;\n\tdev->tx_len = n;\n\tdev->tx_pos = 0;\n\tdev->tx_reg = 0;\n\tdev->tx_done = 0;\n\tdev->tx_sample = 0;\n\tdev->tx_sample_pulse = false;\n\n\tdbg(\"TX: %d samples\", dev->tx_len);\n\n\tspin_lock_irqsave(&dev->hw_lock, flags);\n\n\tene_tx_enable(dev);\n\n\t/* Transmit first two samples */\n\tene_tx_sample(dev);\n\tene_tx_sample(dev);\n\n\tspin_unlock_irqrestore(&dev->hw_lock, flags);\n\n\tif (wait_for_completion_timeout(&dev->tx_complete, 2 * HZ) == 0) {\n\t\tdbg(\"TX: timeout\");\n\t\tspin_lock_irqsave(&dev->hw_lock, flags);\n\t\tene_tx_disable(dev);\n\t\tspin_unlock_irqrestore(&dev->hw_lock, flags);\n\t} else\n\t\tdbg(\"TX: done\");\n\treturn n;\n}\n\n/* probe entry */\nstatic int ene_probe(struct pnp_dev *pnp_dev, const struct pnp_device_id *id)\n{\n\tint error = -ENOMEM;\n\tstruct rc_dev *rdev;\n\tstruct ene_device *dev;\n\n\t/* allocate memory */\n\tdev = kzalloc(sizeof(struct ene_device), GFP_KERNEL);\n\trdev = rc_allocate_device(RC_DRIVER_IR_RAW);\n\tif (!dev || !rdev)\n\t\tgoto exit_free_dev_rdev;\n\n\t/* validate resources */\n\terror = -ENODEV;\n\n\t/* init these to -1, as 0 is valid for both */\n\tdev->hw_io = -1;\n\tdev->irq = -1;\n\n\tif (!pnp_port_valid(pnp_dev, 0) ||\n\t    pnp_port_len(pnp_dev, 0) < ENE_IO_SIZE)\n\t\tgoto exit_free_dev_rdev;\n\n\tif (!pnp_irq_valid(pnp_dev, 0))\n\t\tgoto exit_free_dev_rdev;\n\n\tspin_lock_init(&dev->hw_lock);\n\n\tdev->hw_io = pnp_port_start(pnp_dev, 0);\n\tdev->irq = pnp_irq(pnp_dev, 0);\n\n\n\tpnp_set_drvdata(pnp_dev, dev);\n\tdev->pnp_dev = pnp_dev;\n\n\t/* don't allow too short/long sample periods */\n\tif (sample_period < 5 || sample_period > 0x7F)\n\t\tsample_period = ENE_DEFAULT_SAMPLE_PERIOD;\n\n\t/* detect hardware version and features */\n\terror = ene_hw_detect(dev);\n\tif (error)\n\t\tgoto exit_free_dev_rdev;\n\n\tif (!dev->hw_learning_and_tx_capable && txsim) {\n\t\tdev->hw_learning_and_tx_capable = true;\n\t\ttimer_setup(&dev->tx_sim_timer, ene_tx_irqsim, 0);\n\t\tpr_warn(\"Simulation of TX activated\\n\");\n\t}\n\n\tif (!dev->hw_learning_and_tx_capable)\n\t\tlearning_mode_force = false;\n\n\trdev->allowed_protocols = RC_PROTO_BIT_ALL_IR_DECODER;\n\trdev->priv = dev;\n\trdev->open = ene_open;\n\trdev->close = ene_close;\n\trdev->s_idle = ene_set_idle;\n\trdev->driver_name = ENE_DRIVER_NAME;\n\trdev->map_name = RC_MAP_RC6_MCE;\n\trdev->device_name = \"ENE eHome Infrared Remote Receiver\";\n\n\tif (dev->hw_learning_and_tx_capable) {\n\t\trdev->s_wideband_receiver = ene_set_learning_mode;\n\t\tinit_completion(&dev->tx_complete);\n\t\trdev->tx_ir = ene_transmit;\n\t\trdev->s_tx_mask = ene_set_tx_mask;\n\t\trdev->s_tx_carrier = ene_set_tx_carrier;\n\t\trdev->s_tx_duty_cycle = ene_set_tx_duty_cycle;\n\t\trdev->s_carrier_report = ene_set_carrier_report;\n\t\trdev->device_name = \"ENE eHome Infrared Remote Transceiver\";\n\t}\n\n\tdev->rdev = rdev;\n\n\tene_rx_setup_hw_buffer(dev);\n\tene_setup_default_settings(dev);\n\tene_setup_hw_settings(dev);\n\n\tdevice_set_wakeup_capable(&pnp_dev->dev, true);\n\tdevice_set_wakeup_enable(&pnp_dev->dev, true);\n\n\terror = rc_register_device(rdev);\n\tif (error < 0)\n\t\tgoto exit_free_dev_rdev;\n\n\t/* claim the resources */\n\terror = -EBUSY;\n\tif (!request_region(dev->hw_io, ENE_IO_SIZE, ENE_DRIVER_NAME)) {\n\t\tgoto exit_unregister_device;\n\t}\n\n\tif (request_irq(dev->irq, ene_isr,\n\t\t\tIRQF_SHARED, ENE_DRIVER_NAME, (void *)dev)) {\n\t\tgoto exit_release_hw_io;\n\t}\n\n\tpr_notice(\"driver has been successfully loaded\\n\");\n\treturn 0;\n\nexit_release_hw_io:\n\trelease_region(dev->hw_io, ENE_IO_SIZE);\nexit_unregister_device:\n\trc_unregister_device(rdev);\n\trdev = NULL;\nexit_free_dev_rdev:\n\trc_free_device(rdev);\n\tkfree(dev);\n\treturn error;\n}\n\n/* main unload function */\nstatic void ene_remove(struct pnp_dev *pnp_dev)\n{\n\tstruct ene_device *dev = pnp_get_drvdata(pnp_dev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->hw_lock, flags);\n\tene_rx_disable(dev);\n\tene_rx_restore_hw_buffer(dev);\n\tspin_unlock_irqrestore(&dev->hw_lock, flags);\n\n\tfree_irq(dev->irq, dev);\n\trelease_region(dev->hw_io, ENE_IO_SIZE);\n\trc_unregister_device(dev->rdev);\n\tkfree(dev);\n}\n\n/* enable wake on IR (wakes on specific button on original remote) */\nstatic void ene_enable_wake(struct ene_device *dev, bool enable)\n{\n\tdbg(\"wake on IR %s\", enable ? \"enabled\" : \"disabled\");\n\tene_set_clear_reg_mask(dev, ENE_FW1, ENE_FW1_WAKE, enable);\n}\n\n#ifdef CONFIG_PM\nstatic int ene_suspend(struct pnp_dev *pnp_dev, pm_message_t state)\n{\n\tstruct ene_device *dev = pnp_get_drvdata(pnp_dev);\n\tbool wake = device_may_wakeup(&dev->pnp_dev->dev);\n\n\tif (!wake && dev->rx_enabled)\n\t\tene_rx_disable_hw(dev);\n\n\tene_enable_wake(dev, wake);\n\treturn 0;\n}\n\nstatic int ene_resume(struct pnp_dev *pnp_dev)\n{\n\tstruct ene_device *dev = pnp_get_drvdata(pnp_dev);\n\tene_setup_hw_settings(dev);\n\n\tif (dev->rx_enabled)\n\t\tene_rx_enable(dev);\n\n\tene_enable_wake(dev, false);\n\treturn 0;\n}\n#endif\n\nstatic void ene_shutdown(struct pnp_dev *pnp_dev)\n{\n\tstruct ene_device *dev = pnp_get_drvdata(pnp_dev);\n\tene_enable_wake(dev, true);\n}\n\nstatic const struct pnp_device_id ene_ids[] = {\n\t{.id = \"ENE0100\",},\n\t{.id = \"ENE0200\",},\n\t{.id = \"ENE0201\",},\n\t{.id = \"ENE0202\",},\n\t{},\n};\n\nstatic struct pnp_driver ene_driver = {\n\t.name = ENE_DRIVER_NAME,\n\t.id_table = ene_ids,\n\t.flags = PNP_DRIVER_RES_DO_NOT_CHANGE,\n\n\t.probe = ene_probe,\n\t.remove = ene_remove,\n#ifdef CONFIG_PM\n\t.suspend = ene_suspend,\n\t.resume = ene_resume,\n#endif\n\t.shutdown = ene_shutdown,\n};\n\nmodule_param(sample_period, int, S_IRUGO);\nMODULE_PARM_DESC(sample_period, \"Hardware sample period (50 us default)\");\n\nmodule_param(learning_mode_force, bool, S_IRUGO);\nMODULE_PARM_DESC(learning_mode_force, \"Enable learning mode by default\");\n\nmodule_param(debug, int, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(debug, \"Debug level\");\n\nmodule_param(txsim, bool, S_IRUGO);\nMODULE_PARM_DESC(txsim,\n\t\"Simulate TX features on unsupported hardware (dangerous)\");\n\nMODULE_DEVICE_TABLE(pnp, ene_ids);\nMODULE_DESCRIPTION\n\t(\"Infrared input driver for KB3926B/C/D/E/F (aka ENE0100/ENE0200/ENE0201/ENE0202) CIR port\");\n\nMODULE_AUTHOR(\"Maxim Levitsky\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_pnp_driver(ene_driver);\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n * driver for ENE KB3926 B/C/D/E/F CIR (pnp id: ENE0XXX)\n *\n * Copyright (C) 2010 Maxim Levitsky <maximlevitsky@gmail.com>\n *\n * Special thanks to:\n *   Sami R. <maesesami@gmail.com> for lot of help in debugging and therefore\n *    bringing to life support for transmission & learning mode.\n *\n *   Charlie Andrews <charliethepilot@googlemail.com> for lots of help in\n *   bringing up the support of new firmware buffer that is popular\n *   on latest notebooks\n *\n *   ENE for partial device documentation\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pnp.h>\n#include <linux/io.h>\n#include <linux/interrupt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <media/rc-core.h>\n#include \"ene_ir.h\"\n\nstatic int sample_period;\nstatic bool learning_mode_force;\nstatic int debug;\nstatic bool txsim;\n\nstatic void ene_set_reg_addr(struct ene_device *dev, u16 reg)\n{\n\toutb(reg >> 8, dev->hw_io + ENE_ADDR_HI);\n\toutb(reg & 0xFF, dev->hw_io + ENE_ADDR_LO);\n}\n\n/* read a hardware register */\nstatic u8 ene_read_reg(struct ene_device *dev, u16 reg)\n{\n\tu8 retval;\n\tene_set_reg_addr(dev, reg);\n\tretval = inb(dev->hw_io + ENE_IO);\n\tdbg_regs(\"reg %04x == %02x\", reg, retval);\n\treturn retval;\n}\n\n/* write a hardware register */\nstatic void ene_write_reg(struct ene_device *dev, u16 reg, u8 value)\n{\n\tdbg_regs(\"reg %04x <- %02x\", reg, value);\n\tene_set_reg_addr(dev, reg);\n\toutb(value, dev->hw_io + ENE_IO);\n}\n\n/* Set bits in hardware register */\nstatic void ene_set_reg_mask(struct ene_device *dev, u16 reg, u8 mask)\n{\n\tdbg_regs(\"reg %04x |= %02x\", reg, mask);\n\tene_set_reg_addr(dev, reg);\n\toutb(inb(dev->hw_io + ENE_IO) | mask, dev->hw_io + ENE_IO);\n}\n\n/* Clear bits in hardware register */\nstatic void ene_clear_reg_mask(struct ene_device *dev, u16 reg, u8 mask)\n{\n\tdbg_regs(\"reg %04x &= ~%02x \", reg, mask);\n\tene_set_reg_addr(dev, reg);\n\toutb(inb(dev->hw_io + ENE_IO) & ~mask, dev->hw_io + ENE_IO);\n}\n\n/* A helper to set/clear a bit in register according to boolean variable */\nstatic void ene_set_clear_reg_mask(struct ene_device *dev, u16 reg, u8 mask,\n\t\t\t\t\t\t\t\tbool set)\n{\n\tif (set)\n\t\tene_set_reg_mask(dev, reg, mask);\n\telse\n\t\tene_clear_reg_mask(dev, reg, mask);\n}\n\n/* detect hardware features */\nstatic int ene_hw_detect(struct ene_device *dev)\n{\n\tu8 chip_major, chip_minor;\n\tu8 hw_revision, old_ver;\n\tu8 fw_reg2, fw_reg1;\n\n\tene_clear_reg_mask(dev, ENE_ECSTS, ENE_ECSTS_RSRVD);\n\tchip_major = ene_read_reg(dev, ENE_ECVER_MAJOR);\n\tchip_minor = ene_read_reg(dev, ENE_ECVER_MINOR);\n\tene_set_reg_mask(dev, ENE_ECSTS, ENE_ECSTS_RSRVD);\n\n\thw_revision = ene_read_reg(dev, ENE_ECHV);\n\told_ver = ene_read_reg(dev, ENE_HW_VER_OLD);\n\n\tdev->pll_freq = (ene_read_reg(dev, ENE_PLLFRH) << 4) +\n\t\t(ene_read_reg(dev, ENE_PLLFRL) >> 4);\n\n\tif (sample_period != ENE_DEFAULT_SAMPLE_PERIOD)\n\t\tdev->rx_period_adjust =\n\t\t\tdev->pll_freq == ENE_DEFAULT_PLL_FREQ ? 2 : 4;\n\n\tif (hw_revision == 0xFF) {\n\t\tpr_warn(\"device seems to be disabled\\n\");\n\t\tpr_warn(\"send a mail to lirc-list@lists.sourceforge.net\\n\");\n\t\tpr_warn(\"please attach output of acpidump and dmidecode\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpr_notice(\"chip is 0x%02x%02x - kbver = 0x%02x, rev = 0x%02x\\n\",\n\t\t  chip_major, chip_minor, old_ver, hw_revision);\n\n\tpr_notice(\"PLL freq = %d\\n\", dev->pll_freq);\n\n\tif (chip_major == 0x33) {\n\t\tpr_warn(\"chips 0x33xx aren't supported\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (chip_major == 0x39 && chip_minor == 0x26 && hw_revision == 0xC0) {\n\t\tdev->hw_revision = ENE_HW_C;\n\t\tpr_notice(\"KB3926C detected\\n\");\n\t} else if (old_ver == 0x24 && hw_revision == 0xC0) {\n\t\tdev->hw_revision = ENE_HW_B;\n\t\tpr_notice(\"KB3926B detected\\n\");\n\t} else {\n\t\tdev->hw_revision = ENE_HW_D;\n\t\tpr_notice(\"KB3926D or higher detected\\n\");\n\t}\n\n\t/* detect features hardware supports */\n\tif (dev->hw_revision < ENE_HW_C)\n\t\treturn 0;\n\n\tfw_reg1 = ene_read_reg(dev, ENE_FW1);\n\tfw_reg2 = ene_read_reg(dev, ENE_FW2);\n\n\tpr_notice(\"Firmware regs: %02x %02x\\n\", fw_reg1, fw_reg2);\n\n\tdev->hw_use_gpio_0a = !!(fw_reg2 & ENE_FW2_GP0A);\n\tdev->hw_learning_and_tx_capable = !!(fw_reg2 & ENE_FW2_LEARNING);\n\tdev->hw_extra_buffer = !!(fw_reg1 & ENE_FW1_HAS_EXTRA_BUF);\n\n\tif (dev->hw_learning_and_tx_capable)\n\t\tdev->hw_fan_input = !!(fw_reg2 & ENE_FW2_FAN_INPUT);\n\n\tpr_notice(\"Hardware features:\\n\");\n\n\tif (dev->hw_learning_and_tx_capable) {\n\t\tpr_notice(\"* Supports transmitting & learning mode\\n\");\n\t\tpr_notice(\"   This feature is rare and therefore,\\n\");\n\t\tpr_notice(\"   you are welcome to test it,\\n\");\n\t\tpr_notice(\"   and/or contact the author via:\\n\");\n\t\tpr_notice(\"   lirc-list@lists.sourceforge.net\\n\");\n\t\tpr_notice(\"   or maximlevitsky@gmail.com\\n\");\n\n\t\tpr_notice(\"* Uses GPIO %s for IR raw input\\n\",\n\t\t\t  dev->hw_use_gpio_0a ? \"40\" : \"0A\");\n\n\t\tif (dev->hw_fan_input)\n\t\t\tpr_notice(\"* Uses unused fan feedback input as source of demodulated IR data\\n\");\n\t}\n\n\tif (!dev->hw_fan_input)\n\t\tpr_notice(\"* Uses GPIO %s for IR demodulated input\\n\",\n\t\t\t  dev->hw_use_gpio_0a ? \"0A\" : \"40\");\n\n\tif (dev->hw_extra_buffer)\n\t\tpr_notice(\"* Uses new style input buffer\\n\");\n\treturn 0;\n}\n\n/* Read properties of hw sample buffer */\nstatic void ene_rx_setup_hw_buffer(struct ene_device *dev)\n{\n\tu16 tmp;\n\n\tene_rx_read_hw_pointer(dev);\n\tdev->r_pointer = dev->w_pointer;\n\n\tif (!dev->hw_extra_buffer) {\n\t\tdev->buffer_len = ENE_FW_PACKET_SIZE * 2;\n\t\treturn;\n\t}\n\n\ttmp = ene_read_reg(dev, ENE_FW_SAMPLE_BUFFER);\n\ttmp |= ene_read_reg(dev, ENE_FW_SAMPLE_BUFFER+1) << 8;\n\tdev->extra_buf1_address = tmp;\n\n\tdev->extra_buf1_len = ene_read_reg(dev, ENE_FW_SAMPLE_BUFFER + 2);\n\n\ttmp = ene_read_reg(dev, ENE_FW_SAMPLE_BUFFER + 3);\n\ttmp |= ene_read_reg(dev, ENE_FW_SAMPLE_BUFFER + 4) << 8;\n\tdev->extra_buf2_address = tmp;\n\n\tdev->extra_buf2_len = ene_read_reg(dev, ENE_FW_SAMPLE_BUFFER + 5);\n\n\tdev->buffer_len = dev->extra_buf1_len + dev->extra_buf2_len + 8;\n\n\tpr_notice(\"Hardware uses 2 extended buffers:\\n\");\n\tpr_notice(\"  0x%04x - len : %d\\n\",\n\t\t  dev->extra_buf1_address, dev->extra_buf1_len);\n\tpr_notice(\"  0x%04x - len : %d\\n\",\n\t\t  dev->extra_buf2_address, dev->extra_buf2_len);\n\n\tpr_notice(\"Total buffer len = %d\\n\", dev->buffer_len);\n\n\tif (dev->buffer_len > 64 || dev->buffer_len < 16)\n\t\tgoto error;\n\n\tif (dev->extra_buf1_address > 0xFBFC ||\n\t\t\t\t\tdev->extra_buf1_address < 0xEC00)\n\t\tgoto error;\n\n\tif (dev->extra_buf2_address > 0xFBFC ||\n\t\t\t\t\tdev->extra_buf2_address < 0xEC00)\n\t\tgoto error;\n\n\tif (dev->r_pointer > dev->buffer_len)\n\t\tgoto error;\n\n\tene_set_reg_mask(dev, ENE_FW1, ENE_FW1_EXTRA_BUF_HND);\n\treturn;\nerror:\n\tpr_warn(\"Error validating extra buffers, device probably won't work\\n\");\n\tdev->hw_extra_buffer = false;\n\tene_clear_reg_mask(dev, ENE_FW1, ENE_FW1_EXTRA_BUF_HND);\n}\n\n\n/* Restore the pointers to extra buffers - to make module reload work*/\nstatic void ene_rx_restore_hw_buffer(struct ene_device *dev)\n{\n\tif (!dev->hw_extra_buffer)\n\t\treturn;\n\n\tene_write_reg(dev, ENE_FW_SAMPLE_BUFFER + 0,\n\t\t\t\tdev->extra_buf1_address & 0xFF);\n\tene_write_reg(dev, ENE_FW_SAMPLE_BUFFER + 1,\n\t\t\t\tdev->extra_buf1_address >> 8);\n\tene_write_reg(dev, ENE_FW_SAMPLE_BUFFER + 2, dev->extra_buf1_len);\n\n\tene_write_reg(dev, ENE_FW_SAMPLE_BUFFER + 3,\n\t\t\t\tdev->extra_buf2_address & 0xFF);\n\tene_write_reg(dev, ENE_FW_SAMPLE_BUFFER + 4,\n\t\t\t\tdev->extra_buf2_address >> 8);\n\tene_write_reg(dev, ENE_FW_SAMPLE_BUFFER + 5,\n\t\t\t\tdev->extra_buf2_len);\n\tene_clear_reg_mask(dev, ENE_FW1, ENE_FW1_EXTRA_BUF_HND);\n}\n\n/* Read hardware write pointer */\nstatic void ene_rx_read_hw_pointer(struct ene_device *dev)\n{\n\tif (dev->hw_extra_buffer)\n\t\tdev->w_pointer = ene_read_reg(dev, ENE_FW_RX_POINTER);\n\telse\n\t\tdev->w_pointer = ene_read_reg(dev, ENE_FW2)\n\t\t\t& ENE_FW2_BUF_WPTR ? 0 : ENE_FW_PACKET_SIZE;\n\n\tdbg_verbose(\"RB: HW write pointer: %02x, driver read pointer: %02x\",\n\t\tdev->w_pointer, dev->r_pointer);\n}\n\n/* Gets address of next sample from HW ring buffer */\nstatic int ene_rx_get_sample_reg(struct ene_device *dev)\n{\n\tint r_pointer;\n\n\tif (dev->r_pointer == dev->w_pointer) {\n\t\tdbg_verbose(\"RB: hit end, try update w_pointer\");\n\t\tene_rx_read_hw_pointer(dev);\n\t}\n\n\tif (dev->r_pointer == dev->w_pointer) {\n\t\tdbg_verbose(\"RB: end of data at %d\", dev->r_pointer);\n\t\treturn 0;\n\t}\n\n\tdbg_verbose(\"RB: reading at offset %d\", dev->r_pointer);\n\tr_pointer = dev->r_pointer;\n\n\tdev->r_pointer++;\n\tif (dev->r_pointer == dev->buffer_len)\n\t\tdev->r_pointer = 0;\n\n\tdbg_verbose(\"RB: next read will be from offset %d\", dev->r_pointer);\n\n\tif (r_pointer < 8) {\n\t\tdbg_verbose(\"RB: read at main buffer at %d\", r_pointer);\n\t\treturn ENE_FW_SAMPLE_BUFFER + r_pointer;\n\t}\n\n\tr_pointer -= 8;\n\n\tif (r_pointer < dev->extra_buf1_len) {\n\t\tdbg_verbose(\"RB: read at 1st extra buffer at %d\", r_pointer);\n\t\treturn dev->extra_buf1_address + r_pointer;\n\t}\n\n\tr_pointer -= dev->extra_buf1_len;\n\n\tif (r_pointer < dev->extra_buf2_len) {\n\t\tdbg_verbose(\"RB: read at 2nd extra buffer at %d\", r_pointer);\n\t\treturn dev->extra_buf2_address + r_pointer;\n\t}\n\n\tdbg(\"attempt to read beyond ring buffer end\");\n\treturn 0;\n}\n\n/* Sense current received carrier */\nstatic void ene_rx_sense_carrier(struct ene_device *dev)\n{\n\tint carrier, duty_cycle;\n\tint period = ene_read_reg(dev, ENE_CIRCAR_PRD);\n\tint hperiod = ene_read_reg(dev, ENE_CIRCAR_HPRD);\n\n\tif (!(period & ENE_CIRCAR_PRD_VALID))\n\t\treturn;\n\n\tperiod &= ~ENE_CIRCAR_PRD_VALID;\n\n\tif (!period)\n\t\treturn;\n\n\tdbg(\"RX: hardware carrier period = %02x\", period);\n\tdbg(\"RX: hardware carrier pulse period = %02x\", hperiod);\n\n\tcarrier = 2000000 / period;\n\tduty_cycle = (hperiod * 100) / period;\n\tdbg(\"RX: sensed carrier = %d Hz, duty cycle %d%%\",\n\t\t\t\t\t\tcarrier, duty_cycle);\n\tif (dev->carrier_detect_enabled) {\n\t\tstruct ir_raw_event ev = {\n\t\t\t.carrier_report = true,\n\t\t\t.carrier = carrier,\n\t\t\t.duty_cycle = duty_cycle\n\t\t};\n\t\tir_raw_event_store(dev->rdev, &ev);\n\t}\n}\n\n/* this enables/disables the CIR RX engine */\nstatic void ene_rx_enable_cir_engine(struct ene_device *dev, bool enable)\n{\n\tene_set_clear_reg_mask(dev, ENE_CIRCFG,\n\t\t\tENE_CIRCFG_RX_EN | ENE_CIRCFG_RX_IRQ, enable);\n}\n\n/* this selects input for CIR engine. Ether GPIO 0A or GPIO40*/\nstatic void ene_rx_select_input(struct ene_device *dev, bool gpio_0a)\n{\n\tene_set_clear_reg_mask(dev, ENE_CIRCFG2, ENE_CIRCFG2_GPIO0A, gpio_0a);\n}\n\n/*\n * this enables alternative input via fan tachometer sensor and bypasses\n * the hw CIR engine\n */\nstatic void ene_rx_enable_fan_input(struct ene_device *dev, bool enable)\n{\n\tif (!dev->hw_fan_input)\n\t\treturn;\n\n\tif (!enable)\n\t\tene_write_reg(dev, ENE_FAN_AS_IN1, 0);\n\telse {\n\t\tene_write_reg(dev, ENE_FAN_AS_IN1, ENE_FAN_AS_IN1_EN);\n\t\tene_write_reg(dev, ENE_FAN_AS_IN2, ENE_FAN_AS_IN2_EN);\n\t}\n}\n\n/* setup the receiver for RX*/\nstatic void ene_rx_setup(struct ene_device *dev)\n{\n\tbool learning_mode = dev->learning_mode_enabled ||\n\t\t\t\t\tdev->carrier_detect_enabled;\n\tint sample_period_adjust = 0;\n\n\tdbg(\"RX: setup receiver, learning mode = %d\", learning_mode);\n\n\n\t/* This selects RLC input and clears CFG2 settings */\n\tene_write_reg(dev, ENE_CIRCFG2, 0x00);\n\n\t/* set sample period*/\n\tif (sample_period == ENE_DEFAULT_SAMPLE_PERIOD)\n\t\tsample_period_adjust =\n\t\t\tdev->pll_freq == ENE_DEFAULT_PLL_FREQ ? 1 : 2;\n\n\tene_write_reg(dev, ENE_CIRRLC_CFG,\n\t\t\t(sample_period + sample_period_adjust) |\n\t\t\t\t\t\tENE_CIRRLC_CFG_OVERFLOW);\n\t/* revB doesn't support inputs */\n\tif (dev->hw_revision < ENE_HW_C)\n\t\tgoto select_timeout;\n\n\tif (learning_mode) {\n\n\t\tWARN_ON(!dev->hw_learning_and_tx_capable);\n\n\t\t/* Enable the opposite of the normal input\n\t\tThat means that if GPIO40 is normally used, use GPIO0A\n\t\tand vice versa.\n\t\tThis input will carry non demodulated\n\t\tsignal, and we will tell the hw to demodulate it itself */\n\t\tene_rx_select_input(dev, !dev->hw_use_gpio_0a);\n\t\tdev->rx_fan_input_inuse = false;\n\n\t\t/* Enable carrier demodulation */\n\t\tene_set_reg_mask(dev, ENE_CIRCFG, ENE_CIRCFG_CARR_DEMOD);\n\n\t\t/* Enable carrier detection */\n\t\tene_write_reg(dev, ENE_CIRCAR_PULS, 0x63);\n\t\tene_set_clear_reg_mask(dev, ENE_CIRCFG2, ENE_CIRCFG2_CARR_DETECT,\n\t\t\tdev->carrier_detect_enabled || debug);\n\t} else {\n\t\tif (dev->hw_fan_input)\n\t\t\tdev->rx_fan_input_inuse = true;\n\t\telse\n\t\t\tene_rx_select_input(dev, dev->hw_use_gpio_0a);\n\n\t\t/* Disable carrier detection & demodulation */\n\t\tene_clear_reg_mask(dev, ENE_CIRCFG, ENE_CIRCFG_CARR_DEMOD);\n\t\tene_clear_reg_mask(dev, ENE_CIRCFG2, ENE_CIRCFG2_CARR_DETECT);\n\t}\n\nselect_timeout:\n\tif (dev->rx_fan_input_inuse) {\n\t\tdev->rdev->rx_resolution = ENE_FW_SAMPLE_PERIOD_FAN;\n\n\t\t/* Fan input doesn't support timeouts, it just ends the\n\t\t\tinput with a maximum sample */\n\t\tdev->rdev->min_timeout = dev->rdev->max_timeout =\n\t\t\tENE_FW_SMPL_BUF_FAN_MSK *\n\t\t\t\tENE_FW_SAMPLE_PERIOD_FAN;\n\t} else {\n\t\tdev->rdev->rx_resolution = sample_period;\n\n\t\t/* Theoreticly timeout is unlimited, but we cap it\n\t\t * because it was seen that on one device, it\n\t\t * would stop sending spaces after around 250 msec.\n\t\t * Besides, this is close to 2^32 anyway and timeout is u32.\n\t\t */\n\t\tdev->rdev->min_timeout = 127 * sample_period;\n\t\tdev->rdev->max_timeout = 200000;\n\t}\n\n\tif (dev->hw_learning_and_tx_capable)\n\t\tdev->rdev->tx_resolution = sample_period;\n\n\tif (dev->rdev->timeout > dev->rdev->max_timeout)\n\t\tdev->rdev->timeout = dev->rdev->max_timeout;\n\tif (dev->rdev->timeout < dev->rdev->min_timeout)\n\t\tdev->rdev->timeout = dev->rdev->min_timeout;\n}\n\n/* Enable the device for receive */\nstatic void ene_rx_enable_hw(struct ene_device *dev)\n{\n\tu8 reg_value;\n\n\t/* Enable system interrupt */\n\tif (dev->hw_revision < ENE_HW_C) {\n\t\tene_write_reg(dev, ENEB_IRQ, dev->irq << 1);\n\t\tene_write_reg(dev, ENEB_IRQ_UNK1, 0x01);\n\t} else {\n\t\treg_value = ene_read_reg(dev, ENE_IRQ) & 0xF0;\n\t\treg_value |= ENE_IRQ_UNK_EN;\n\t\treg_value &= ~ENE_IRQ_STATUS;\n\t\treg_value |= (dev->irq & ENE_IRQ_MASK);\n\t\tene_write_reg(dev, ENE_IRQ, reg_value);\n\t}\n\n\t/* Enable inputs */\n\tene_rx_enable_fan_input(dev, dev->rx_fan_input_inuse);\n\tene_rx_enable_cir_engine(dev, !dev->rx_fan_input_inuse);\n\n\t/* ack any pending irqs - just in case */\n\tene_irq_status(dev);\n\n\t/* enable firmware bits */\n\tene_set_reg_mask(dev, ENE_FW1, ENE_FW1_ENABLE | ENE_FW1_IRQ);\n\n\t/* enter idle mode */\n\tir_raw_event_set_idle(dev->rdev, true);\n}\n\n/* Enable the device for receive - wrapper to track the state*/\nstatic void ene_rx_enable(struct ene_device *dev)\n{\n\tene_rx_enable_hw(dev);\n\tdev->rx_enabled = true;\n}\n\n/* Disable the device receiver */\nstatic void ene_rx_disable_hw(struct ene_device *dev)\n{\n\t/* disable inputs */\n\tene_rx_enable_cir_engine(dev, false);\n\tene_rx_enable_fan_input(dev, false);\n\n\t/* disable hardware IRQ and firmware flag */\n\tene_clear_reg_mask(dev, ENE_FW1, ENE_FW1_ENABLE | ENE_FW1_IRQ);\n\tir_raw_event_set_idle(dev->rdev, true);\n}\n\n/* Disable the device receiver - wrapper to track the state */\nstatic void ene_rx_disable(struct ene_device *dev)\n{\n\tene_rx_disable_hw(dev);\n\tdev->rx_enabled = false;\n}\n\n/* This resets the receiver. Useful to stop stream of spaces at end of\n * transmission\n */\nstatic void ene_rx_reset(struct ene_device *dev)\n{\n\tene_clear_reg_mask(dev, ENE_CIRCFG, ENE_CIRCFG_RX_EN);\n\tene_set_reg_mask(dev, ENE_CIRCFG, ENE_CIRCFG_RX_EN);\n}\n\n/* Set up the TX carrier frequency and duty cycle */\nstatic void ene_tx_set_carrier(struct ene_device *dev)\n{\n\tu8 tx_puls_width;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->hw_lock, flags);\n\n\tene_set_clear_reg_mask(dev, ENE_CIRCFG,\n\t\tENE_CIRCFG_TX_CARR, dev->tx_period > 0);\n\n\tif (!dev->tx_period)\n\t\tgoto unlock;\n\n\tBUG_ON(dev->tx_duty_cycle >= 100 || dev->tx_duty_cycle <= 0);\n\n\ttx_puls_width = dev->tx_period / (100 / dev->tx_duty_cycle);\n\n\tif (!tx_puls_width)\n\t\ttx_puls_width = 1;\n\n\tdbg(\"TX: pulse distance = %d * 500 ns\", dev->tx_period);\n\tdbg(\"TX: pulse width = %d * 500 ns\", tx_puls_width);\n\n\tene_write_reg(dev, ENE_CIRMOD_PRD, dev->tx_period | ENE_CIRMOD_PRD_POL);\n\tene_write_reg(dev, ENE_CIRMOD_HPRD, tx_puls_width);\nunlock:\n\tspin_unlock_irqrestore(&dev->hw_lock, flags);\n}\n\n/* Enable/disable transmitters */\nstatic void ene_tx_set_transmitters(struct ene_device *dev)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->hw_lock, flags);\n\tene_set_clear_reg_mask(dev, ENE_GPIOFS8, ENE_GPIOFS8_GPIO41,\n\t\t\t\t\t!!(dev->transmitter_mask & 0x01));\n\tene_set_clear_reg_mask(dev, ENE_GPIOFS1, ENE_GPIOFS1_GPIO0D,\n\t\t\t\t\t!!(dev->transmitter_mask & 0x02));\n\tspin_unlock_irqrestore(&dev->hw_lock, flags);\n}\n\n/* prepare transmission */\nstatic void ene_tx_enable(struct ene_device *dev)\n{\n\tu8 conf1 = ene_read_reg(dev, ENE_CIRCFG);\n\tu8 fwreg2 = ene_read_reg(dev, ENE_FW2);\n\n\tdev->saved_conf1 = conf1;\n\n\t/* Show information about currently connected transmitter jacks */\n\tif (fwreg2 & ENE_FW2_EMMITER1_CONN)\n\t\tdbg(\"TX: Transmitter #1 is connected\");\n\n\tif (fwreg2 & ENE_FW2_EMMITER2_CONN)\n\t\tdbg(\"TX: Transmitter #2 is connected\");\n\n\tif (!(fwreg2 & (ENE_FW2_EMMITER1_CONN | ENE_FW2_EMMITER2_CONN)))\n\t\tpr_warn(\"TX: transmitter cable isn't connected!\\n\");\n\n\t/* disable receive on revc */\n\tif (dev->hw_revision == ENE_HW_C)\n\t\tconf1 &= ~ENE_CIRCFG_RX_EN;\n\n\t/* Enable TX engine */\n\tconf1 |= ENE_CIRCFG_TX_EN | ENE_CIRCFG_TX_IRQ;\n\tene_write_reg(dev, ENE_CIRCFG, conf1);\n}\n\n/* end transmission */\nstatic void ene_tx_disable(struct ene_device *dev)\n{\n\tene_write_reg(dev, ENE_CIRCFG, dev->saved_conf1);\n\tdev->tx_buffer = NULL;\n}\n\n\n/* TX one sample - must be called with dev->hw_lock*/\nstatic void ene_tx_sample(struct ene_device *dev)\n{\n\tu8 raw_tx;\n\tu32 sample;\n\tbool pulse = dev->tx_sample_pulse;\n\n\tif (!dev->tx_buffer) {\n\t\tpr_warn(\"TX: BUG: attempt to transmit NULL buffer\\n\");\n\t\treturn;\n\t}\n\n\t/* Grab next TX sample */\n\tif (!dev->tx_sample) {\n\n\t\tif (dev->tx_pos == dev->tx_len) {\n\t\t\tif (!dev->tx_done) {\n\t\t\t\tdbg(\"TX: no more data to send\");\n\t\t\t\tdev->tx_done = true;\n\t\t\t\tgoto exit;\n\t\t\t} else {\n\t\t\t\tdbg(\"TX: last sample sent by hardware\");\n\t\t\t\tene_tx_disable(dev);\n\t\t\t\tcomplete(&dev->tx_complete);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tsample = dev->tx_buffer[dev->tx_pos++];\n\t\tdev->tx_sample_pulse = !dev->tx_sample_pulse;\n\n\t\tdev->tx_sample = DIV_ROUND_CLOSEST(sample, sample_period);\n\n\t\tif (!dev->tx_sample)\n\t\t\tdev->tx_sample = 1;\n\t}\n\n\traw_tx = min(dev->tx_sample , (unsigned int)ENE_CIRRLC_OUT_MASK);\n\tdev->tx_sample -= raw_tx;\n\n\tdbg(\"TX: sample %8d (%s)\", raw_tx * sample_period,\n\t\t\t\t\t\tpulse ? \"pulse\" : \"space\");\n\tif (pulse)\n\t\traw_tx |= ENE_CIRRLC_OUT_PULSE;\n\n\tene_write_reg(dev,\n\t\tdev->tx_reg ? ENE_CIRRLC_OUT1 : ENE_CIRRLC_OUT0, raw_tx);\n\n\tdev->tx_reg = !dev->tx_reg;\nexit:\n\t/* simulate TX done interrupt */\n\tif (txsim)\n\t\tmod_timer(&dev->tx_sim_timer, jiffies + HZ / 500);\n}\n\n/* timer to simulate tx done interrupt */\nstatic void ene_tx_irqsim(struct timer_list *t)\n{\n\tstruct ene_device *dev = from_timer(dev, t, tx_sim_timer);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->hw_lock, flags);\n\tene_tx_sample(dev);\n\tspin_unlock_irqrestore(&dev->hw_lock, flags);\n}\n\n\n/* read irq status and ack it */\nstatic int ene_irq_status(struct ene_device *dev)\n{\n\tu8 irq_status;\n\tu8 fw_flags1, fw_flags2;\n\tint retval = 0;\n\n\tfw_flags2 = ene_read_reg(dev, ENE_FW2);\n\n\tif (dev->hw_revision < ENE_HW_C) {\n\t\tirq_status = ene_read_reg(dev, ENEB_IRQ_STATUS);\n\n\t\tif (!(irq_status & ENEB_IRQ_STATUS_IR))\n\t\t\treturn 0;\n\n\t\tene_clear_reg_mask(dev, ENEB_IRQ_STATUS, ENEB_IRQ_STATUS_IR);\n\t\treturn ENE_IRQ_RX;\n\t}\n\n\tirq_status = ene_read_reg(dev, ENE_IRQ);\n\tif (!(irq_status & ENE_IRQ_STATUS))\n\t\treturn 0;\n\n\t/* original driver does that twice - a workaround ? */\n\tene_write_reg(dev, ENE_IRQ, irq_status & ~ENE_IRQ_STATUS);\n\tene_write_reg(dev, ENE_IRQ, irq_status & ~ENE_IRQ_STATUS);\n\n\t/* check RX interrupt */\n\tif (fw_flags2 & ENE_FW2_RXIRQ) {\n\t\tretval |= ENE_IRQ_RX;\n\t\tene_write_reg(dev, ENE_FW2, fw_flags2 & ~ENE_FW2_RXIRQ);\n\t}\n\n\t/* check TX interrupt */\n\tfw_flags1 = ene_read_reg(dev, ENE_FW1);\n\tif (fw_flags1 & ENE_FW1_TXIRQ) {\n\t\tene_write_reg(dev, ENE_FW1, fw_flags1 & ~ENE_FW1_TXIRQ);\n\t\tretval |= ENE_IRQ_TX;\n\t}\n\n\treturn retval;\n}\n\n/* interrupt handler */\nstatic irqreturn_t ene_isr(int irq, void *data)\n{\n\tu16 hw_value, reg;\n\tint hw_sample, irq_status;\n\tbool pulse;\n\tunsigned long flags;\n\tirqreturn_t retval = IRQ_NONE;\n\tstruct ene_device *dev = (struct ene_device *)data;\n\tstruct ir_raw_event ev = {};\n\n\tspin_lock_irqsave(&dev->hw_lock, flags);\n\n\tdbg_verbose(\"ISR called\");\n\tene_rx_read_hw_pointer(dev);\n\tirq_status = ene_irq_status(dev);\n\n\tif (!irq_status)\n\t\tgoto unlock;\n\n\tretval = IRQ_HANDLED;\n\n\tif (irq_status & ENE_IRQ_TX) {\n\t\tdbg_verbose(\"TX interrupt\");\n\t\tif (!dev->hw_learning_and_tx_capable) {\n\t\t\tdbg(\"TX interrupt on unsupported device!\");\n\t\t\tgoto unlock;\n\t\t}\n\t\tene_tx_sample(dev);\n\t}\n\n\tif (!(irq_status & ENE_IRQ_RX))\n\t\tgoto unlock;\n\n\tdbg_verbose(\"RX interrupt\");\n\n\tif (dev->hw_learning_and_tx_capable)\n\t\tene_rx_sense_carrier(dev);\n\n\t/* On hardware that don't support extra buffer we need to trust\n\t\tthe interrupt and not track the read pointer */\n\tif (!dev->hw_extra_buffer)\n\t\tdev->r_pointer = dev->w_pointer == 0 ? ENE_FW_PACKET_SIZE : 0;\n\n\twhile (1) {\n\n\t\treg = ene_rx_get_sample_reg(dev);\n\n\t\tdbg_verbose(\"next sample to read at: %04x\", reg);\n\t\tif (!reg)\n\t\t\tbreak;\n\n\t\thw_value = ene_read_reg(dev, reg);\n\n\t\tif (dev->rx_fan_input_inuse) {\n\n\t\t\tint offset = ENE_FW_SMPL_BUF_FAN - ENE_FW_SAMPLE_BUFFER;\n\n\t\t\t/* read high part of the sample */\n\t\t\thw_value |= ene_read_reg(dev, reg + offset) << 8;\n\t\t\tpulse = hw_value & ENE_FW_SMPL_BUF_FAN_PLS;\n\n\t\t\t/* clear space bit, and other unused bits */\n\t\t\thw_value &= ENE_FW_SMPL_BUF_FAN_MSK;\n\t\t\thw_sample = hw_value * ENE_FW_SAMPLE_PERIOD_FAN;\n\n\t\t} else {\n\t\t\tpulse = !(hw_value & ENE_FW_SAMPLE_SPACE);\n\t\t\thw_value &= ~ENE_FW_SAMPLE_SPACE;\n\t\t\thw_sample = hw_value * sample_period;\n\n\t\t\tif (dev->rx_period_adjust) {\n\t\t\t\thw_sample *= 100;\n\t\t\t\thw_sample /= (100 + dev->rx_period_adjust);\n\t\t\t}\n\t\t}\n\n\t\tif (!dev->hw_extra_buffer && !hw_sample) {\n\t\t\tdev->r_pointer = dev->w_pointer;\n\t\t\tcontinue;\n\t\t}\n\n\t\tdbg(\"RX: %d (%s)\", hw_sample, pulse ? \"pulse\" : \"space\");\n\n\t\tev.duration = hw_sample;\n\t\tev.pulse = pulse;\n\t\tir_raw_event_store_with_filter(dev->rdev, &ev);\n\t}\n\n\tir_raw_event_handle(dev->rdev);\nunlock:\n\tspin_unlock_irqrestore(&dev->hw_lock, flags);\n\treturn retval;\n}\n\n/* Initialize default settings */\nstatic void ene_setup_default_settings(struct ene_device *dev)\n{\n\tdev->tx_period = 32;\n\tdev->tx_duty_cycle = 50; /*%*/\n\tdev->transmitter_mask = 0x03;\n\tdev->learning_mode_enabled = learning_mode_force;\n\n\t/* Set reasonable default timeout */\n\tdev->rdev->timeout = MS_TO_US(150);\n}\n\n/* Upload all hardware settings at once. Used at load and resume time */\nstatic void ene_setup_hw_settings(struct ene_device *dev)\n{\n\tif (dev->hw_learning_and_tx_capable) {\n\t\tene_tx_set_carrier(dev);\n\t\tene_tx_set_transmitters(dev);\n\t}\n\n\tene_rx_setup(dev);\n}\n\n/* outside interface: called on first open*/\nstatic int ene_open(struct rc_dev *rdev)\n{\n\tstruct ene_device *dev = rdev->priv;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->hw_lock, flags);\n\tene_rx_enable(dev);\n\tspin_unlock_irqrestore(&dev->hw_lock, flags);\n\treturn 0;\n}\n\n/* outside interface: called on device close*/\nstatic void ene_close(struct rc_dev *rdev)\n{\n\tstruct ene_device *dev = rdev->priv;\n\tunsigned long flags;\n\tspin_lock_irqsave(&dev->hw_lock, flags);\n\n\tene_rx_disable(dev);\n\tspin_unlock_irqrestore(&dev->hw_lock, flags);\n}\n\n/* outside interface: set transmitter mask */\nstatic int ene_set_tx_mask(struct rc_dev *rdev, u32 tx_mask)\n{\n\tstruct ene_device *dev = rdev->priv;\n\tdbg(\"TX: attempt to set transmitter mask %02x\", tx_mask);\n\n\t/* invalid txmask */\n\tif (!tx_mask || tx_mask & ~0x03) {\n\t\tdbg(\"TX: invalid mask\");\n\t\t/* return count of transmitters */\n\t\treturn 2;\n\t}\n\n\tdev->transmitter_mask = tx_mask;\n\tene_tx_set_transmitters(dev);\n\treturn 0;\n}\n\n/* outside interface : set tx carrier */\nstatic int ene_set_tx_carrier(struct rc_dev *rdev, u32 carrier)\n{\n\tstruct ene_device *dev = rdev->priv;\n\tu32 period;\n\n\tdbg(\"TX: attempt to set tx carrier to %d kHz\", carrier);\n\tif (carrier == 0)\n\t\treturn -EINVAL;\n\n\tperiod = 2000000 / carrier;\n\tif (period && (period > ENE_CIRMOD_PRD_MAX ||\n\t\t\tperiod < ENE_CIRMOD_PRD_MIN)) {\n\n\t\tdbg(\"TX: out of range %d-%d kHz carrier\",\n\t\t\t2000 / ENE_CIRMOD_PRD_MIN, 2000 / ENE_CIRMOD_PRD_MAX);\n\t\treturn -EINVAL;\n\t}\n\n\tdev->tx_period = period;\n\tene_tx_set_carrier(dev);\n\treturn 0;\n}\n\n/*outside interface : set tx duty cycle */\nstatic int ene_set_tx_duty_cycle(struct rc_dev *rdev, u32 duty_cycle)\n{\n\tstruct ene_device *dev = rdev->priv;\n\tdbg(\"TX: setting duty cycle to %d%%\", duty_cycle);\n\tdev->tx_duty_cycle = duty_cycle;\n\tene_tx_set_carrier(dev);\n\treturn 0;\n}\n\n/* outside interface: enable learning mode */\nstatic int ene_set_learning_mode(struct rc_dev *rdev, int enable)\n{\n\tstruct ene_device *dev = rdev->priv;\n\tunsigned long flags;\n\tif (enable == dev->learning_mode_enabled)\n\t\treturn 0;\n\n\tspin_lock_irqsave(&dev->hw_lock, flags);\n\tdev->learning_mode_enabled = enable;\n\tene_rx_disable(dev);\n\tene_rx_setup(dev);\n\tene_rx_enable(dev);\n\tspin_unlock_irqrestore(&dev->hw_lock, flags);\n\treturn 0;\n}\n\nstatic int ene_set_carrier_report(struct rc_dev *rdev, int enable)\n{\n\tstruct ene_device *dev = rdev->priv;\n\tunsigned long flags;\n\n\tif (enable == dev->carrier_detect_enabled)\n\t\treturn 0;\n\n\tspin_lock_irqsave(&dev->hw_lock, flags);\n\tdev->carrier_detect_enabled = enable;\n\tene_rx_disable(dev);\n\tene_rx_setup(dev);\n\tene_rx_enable(dev);\n\tspin_unlock_irqrestore(&dev->hw_lock, flags);\n\treturn 0;\n}\n\n/* outside interface: enable or disable idle mode */\nstatic void ene_set_idle(struct rc_dev *rdev, bool idle)\n{\n\tstruct ene_device *dev = rdev->priv;\n\n\tif (idle) {\n\t\tene_rx_reset(dev);\n\t\tdbg(\"RX: end of data\");\n\t}\n}\n\n/* outside interface: transmit */\nstatic int ene_transmit(struct rc_dev *rdev, unsigned *buf, unsigned n)\n{\n\tstruct ene_device *dev = rdev->priv;\n\tunsigned long flags;\n\n\tdev->tx_buffer = buf;\n\tdev->tx_len = n;\n\tdev->tx_pos = 0;\n\tdev->tx_reg = 0;\n\tdev->tx_done = 0;\n\tdev->tx_sample = 0;\n\tdev->tx_sample_pulse = false;\n\n\tdbg(\"TX: %d samples\", dev->tx_len);\n\n\tspin_lock_irqsave(&dev->hw_lock, flags);\n\n\tene_tx_enable(dev);\n\n\t/* Transmit first two samples */\n\tene_tx_sample(dev);\n\tene_tx_sample(dev);\n\n\tspin_unlock_irqrestore(&dev->hw_lock, flags);\n\n\tif (wait_for_completion_timeout(&dev->tx_complete, 2 * HZ) == 0) {\n\t\tdbg(\"TX: timeout\");\n\t\tspin_lock_irqsave(&dev->hw_lock, flags);\n\t\tene_tx_disable(dev);\n\t\tspin_unlock_irqrestore(&dev->hw_lock, flags);\n\t} else\n\t\tdbg(\"TX: done\");\n\treturn n;\n}\n\n/* probe entry */\nstatic int ene_probe(struct pnp_dev *pnp_dev, const struct pnp_device_id *id)\n{\n\tint error = -ENOMEM;\n\tstruct rc_dev *rdev;\n\tstruct ene_device *dev;\n\n\t/* allocate memory */\n\tdev = kzalloc(sizeof(struct ene_device), GFP_KERNEL);\n\trdev = rc_allocate_device(RC_DRIVER_IR_RAW);\n\tif (!dev || !rdev)\n\t\tgoto exit_free_dev_rdev;\n\n\t/* validate resources */\n\terror = -ENODEV;\n\n\t/* init these to -1, as 0 is valid for both */\n\tdev->hw_io = -1;\n\tdev->irq = -1;\n\n\tif (!pnp_port_valid(pnp_dev, 0) ||\n\t    pnp_port_len(pnp_dev, 0) < ENE_IO_SIZE)\n\t\tgoto exit_free_dev_rdev;\n\n\tif (!pnp_irq_valid(pnp_dev, 0))\n\t\tgoto exit_free_dev_rdev;\n\n\tspin_lock_init(&dev->hw_lock);\n\n\tdev->hw_io = pnp_port_start(pnp_dev, 0);\n\tdev->irq = pnp_irq(pnp_dev, 0);\n\n\n\tpnp_set_drvdata(pnp_dev, dev);\n\tdev->pnp_dev = pnp_dev;\n\n\t/* don't allow too short/long sample periods */\n\tif (sample_period < 5 || sample_period > 0x7F)\n\t\tsample_period = ENE_DEFAULT_SAMPLE_PERIOD;\n\n\t/* detect hardware version and features */\n\terror = ene_hw_detect(dev);\n\tif (error)\n\t\tgoto exit_free_dev_rdev;\n\n\tif (!dev->hw_learning_and_tx_capable && txsim) {\n\t\tdev->hw_learning_and_tx_capable = true;\n\t\ttimer_setup(&dev->tx_sim_timer, ene_tx_irqsim, 0);\n\t\tpr_warn(\"Simulation of TX activated\\n\");\n\t}\n\n\tif (!dev->hw_learning_and_tx_capable)\n\t\tlearning_mode_force = false;\n\n\trdev->allowed_protocols = RC_PROTO_BIT_ALL_IR_DECODER;\n\trdev->priv = dev;\n\trdev->open = ene_open;\n\trdev->close = ene_close;\n\trdev->s_idle = ene_set_idle;\n\trdev->driver_name = ENE_DRIVER_NAME;\n\trdev->map_name = RC_MAP_RC6_MCE;\n\trdev->device_name = \"ENE eHome Infrared Remote Receiver\";\n\n\tif (dev->hw_learning_and_tx_capable) {\n\t\trdev->s_wideband_receiver = ene_set_learning_mode;\n\t\tinit_completion(&dev->tx_complete);\n\t\trdev->tx_ir = ene_transmit;\n\t\trdev->s_tx_mask = ene_set_tx_mask;\n\t\trdev->s_tx_carrier = ene_set_tx_carrier;\n\t\trdev->s_tx_duty_cycle = ene_set_tx_duty_cycle;\n\t\trdev->s_carrier_report = ene_set_carrier_report;\n\t\trdev->device_name = \"ENE eHome Infrared Remote Transceiver\";\n\t}\n\n\tdev->rdev = rdev;\n\n\tene_rx_setup_hw_buffer(dev);\n\tene_setup_default_settings(dev);\n\tene_setup_hw_settings(dev);\n\n\tdevice_set_wakeup_capable(&pnp_dev->dev, true);\n\tdevice_set_wakeup_enable(&pnp_dev->dev, true);\n\n\terror = rc_register_device(rdev);\n\tif (error < 0)\n\t\tgoto exit_free_dev_rdev;\n\n\t/* claim the resources */\n\terror = -EBUSY;\n\tif (!request_region(dev->hw_io, ENE_IO_SIZE, ENE_DRIVER_NAME)) {\n\t\tgoto exit_unregister_device;\n\t}\n\n\tif (request_irq(dev->irq, ene_isr,\n\t\t\tIRQF_SHARED, ENE_DRIVER_NAME, (void *)dev)) {\n\t\tgoto exit_release_hw_io;\n\t}\n\n\tpr_notice(\"driver has been successfully loaded\\n\");\n\treturn 0;\n\nexit_release_hw_io:\n\trelease_region(dev->hw_io, ENE_IO_SIZE);\nexit_unregister_device:\n\trc_unregister_device(rdev);\n\trdev = NULL;\nexit_free_dev_rdev:\n\trc_free_device(rdev);\n\tkfree(dev);\n\treturn error;\n}\n\n/* main unload function */\nstatic void ene_remove(struct pnp_dev *pnp_dev)\n{\n\tstruct ene_device *dev = pnp_get_drvdata(pnp_dev);\n\tunsigned long flags;\n\n\trc_unregister_device(dev->rdev);\n\tdel_timer_sync(&dev->tx_sim_timer);\n\tspin_lock_irqsave(&dev->hw_lock, flags);\n\tene_rx_disable(dev);\n\tene_rx_restore_hw_buffer(dev);\n\tspin_unlock_irqrestore(&dev->hw_lock, flags);\n\n\tfree_irq(dev->irq, dev);\n\trelease_region(dev->hw_io, ENE_IO_SIZE);\n\tkfree(dev);\n}\n\n/* enable wake on IR (wakes on specific button on original remote) */\nstatic void ene_enable_wake(struct ene_device *dev, bool enable)\n{\n\tdbg(\"wake on IR %s\", enable ? \"enabled\" : \"disabled\");\n\tene_set_clear_reg_mask(dev, ENE_FW1, ENE_FW1_WAKE, enable);\n}\n\n#ifdef CONFIG_PM\nstatic int ene_suspend(struct pnp_dev *pnp_dev, pm_message_t state)\n{\n\tstruct ene_device *dev = pnp_get_drvdata(pnp_dev);\n\tbool wake = device_may_wakeup(&dev->pnp_dev->dev);\n\n\tif (!wake && dev->rx_enabled)\n\t\tene_rx_disable_hw(dev);\n\n\tene_enable_wake(dev, wake);\n\treturn 0;\n}\n\nstatic int ene_resume(struct pnp_dev *pnp_dev)\n{\n\tstruct ene_device *dev = pnp_get_drvdata(pnp_dev);\n\tene_setup_hw_settings(dev);\n\n\tif (dev->rx_enabled)\n\t\tene_rx_enable(dev);\n\n\tene_enable_wake(dev, false);\n\treturn 0;\n}\n#endif\n\nstatic void ene_shutdown(struct pnp_dev *pnp_dev)\n{\n\tstruct ene_device *dev = pnp_get_drvdata(pnp_dev);\n\tene_enable_wake(dev, true);\n}\n\nstatic const struct pnp_device_id ene_ids[] = {\n\t{.id = \"ENE0100\",},\n\t{.id = \"ENE0200\",},\n\t{.id = \"ENE0201\",},\n\t{.id = \"ENE0202\",},\n\t{},\n};\n\nstatic struct pnp_driver ene_driver = {\n\t.name = ENE_DRIVER_NAME,\n\t.id_table = ene_ids,\n\t.flags = PNP_DRIVER_RES_DO_NOT_CHANGE,\n\n\t.probe = ene_probe,\n\t.remove = ene_remove,\n#ifdef CONFIG_PM\n\t.suspend = ene_suspend,\n\t.resume = ene_resume,\n#endif\n\t.shutdown = ene_shutdown,\n};\n\nmodule_param(sample_period, int, S_IRUGO);\nMODULE_PARM_DESC(sample_period, \"Hardware sample period (50 us default)\");\n\nmodule_param(learning_mode_force, bool, S_IRUGO);\nMODULE_PARM_DESC(learning_mode_force, \"Enable learning mode by default\");\n\nmodule_param(debug, int, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(debug, \"Debug level\");\n\nmodule_param(txsim, bool, S_IRUGO);\nMODULE_PARM_DESC(txsim,\n\t\"Simulate TX features on unsupported hardware (dangerous)\");\n\nMODULE_DEVICE_TABLE(pnp, ene_ids);\nMODULE_DESCRIPTION\n\t(\"Infrared input driver for KB3926B/C/D/E/F (aka ENE0100/ENE0200/ENE0201/ENE0202) CIR port\");\n\nMODULE_AUTHOR(\"Maxim Levitsky\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_pnp_driver(ene_driver);\n"], "filenames": ["drivers/media/rc/ene_ir.c"], "buggy_code_start_loc": [1108], "buggy_code_end_loc": [1117], "fixing_code_start_loc": [1109], "fixing_code_end_loc": [1117], "type": "CWE-416", "message": "A flaw use after free in the Linux kernel integrated infrared receiver/transceiver driver was found in the way user detaching rc device. A local user could use this flaw to crash the system or potentially escalate their privileges on the system.", "other": {"cve": {"id": "CVE-2023-1118", "sourceIdentifier": "secalert@redhat.com", "published": "2023-03-02T18:15:09.637", "lastModified": "2023-05-03T14:15:21.720", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "A flaw use after free in the Linux kernel integrated infrared receiver/transceiver driver was found in the way user detaching rc device. A local user could use this flaw to crash the system or potentially escalate their privileges on the system."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "6.3", "matchCriteriaId": "3769AA63-B0A8-4EF1-96F9-6A6A6B305A02"}]}]}], "references": [{"url": "https://github.com/torvalds/linux/commit/29b0589a865b6f66d141d79b2dd1373e4e50fe17", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "https://lists.debian.org/debian-lts-announce/2023/05/msg00005.html", "source": "secalert@redhat.com"}, {"url": "https://lists.debian.org/debian-lts-announce/2023/05/msg00006.html", "source": "secalert@redhat.com"}, {"url": "https://security.netapp.com/advisory/ntap-20230413-0003/", "source": "secalert@redhat.com"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/29b0589a865b6f66d141d79b2dd1373e4e50fe17"}}