{"buggy_code": ["<script>\n  import Tooltip from \"./Tooltip.svelte\"\n  import Icon from \"../Icon/Icon.svelte\"\n\n  export let tooltip = \"\"\n  export let size = \"M\"\n\n  let showTooltip = false\n</script>\n\n<div class:container={!!tooltip}>\n  <slot />\n  {#if tooltip}\n    <div class=\"icon-container\">\n      <div\n        class=\"icon\"\n        class:icon-small={size === \"M\" || size === \"S\"}\n        on:mouseover={() => (showTooltip = true)}\n        on:mouseleave={() => (showTooltip = false)}\n        on:focus\n      >\n        <Icon name=\"InfoOutline\" size=\"S\" disabled={true} />\n      </div>\n      {#if showTooltip}\n        <div class=\"tooltip\">\n          <Tooltip textWrapping={true} direction={\"bottom\"} text={tooltip} />\n        </div>\n      {/if}\n    </div>\n  {/if}\n</div>\n\n<style>\n  .container {\n    display: flex;\n    align-items: center;\n  }\n  .icon-container {\n    position: relative;\n    display: flex;\n    justify-content: center;\n    margin-left: 5px;\n    margin-right: 5px;\n  }\n  .tooltip {\n    position: absolute;\n    display: flex;\n    justify-content: center;\n    top: 15px;\n    z-index: 100;\n    width: 160px;\n  }\n  .icon {\n    transform: scale(0.75);\n  }\n  .icon-small {\n    margin-top: -2px;\n    margin-bottom: -5px;\n  }\n</style>\n", "import { cloneDeep } from \"lodash/fp\"\nimport { get } from \"svelte/store\"\nimport {\n  findAllMatchingComponents,\n  findComponent,\n  findComponentPath,\n  getComponentSettings,\n} from \"./componentUtils\"\nimport { store } from \"builderStore\"\nimport {\n  queries as queriesStores,\n  tables as tablesStore,\n  roles as rolesStore,\n} from \"stores/backend\"\nimport {\n  makePropSafe,\n  isJSBinding,\n  decodeJSBinding,\n  encodeJSBinding,\n} from \"@budibase/string-templates\"\nimport { TableNames } from \"../constants\"\nimport { JSONUtils } from \"@budibase/frontend-core\"\nimport ActionDefinitions from \"components/design/settings/controls/ButtonActionEditor/manifest.json\"\n\n// Regex to match all instances of template strings\nconst CAPTURE_VAR_INSIDE_TEMPLATE = /{{([^}]+)}}/g\nconst CAPTURE_VAR_INSIDE_JS = /\\$\\(\"([^\")]+)\"\\)/g\nconst CAPTURE_HBS_TEMPLATE = /{{[\\S\\s]*?}}/g\n\n/**\n * Gets all bindable data context fields and instance fields.\n */\nexport const getBindableProperties = (asset, componentId) => {\n  const contextBindings = getContextBindings(asset, componentId)\n  const userBindings = getUserBindings()\n  const urlBindings = getUrlBindings(asset)\n  const deviceBindings = getDeviceBindings()\n  const stateBindings = getStateBindings()\n  const selectedRowsBindings = getSelectedRowsBindings(asset)\n  const roleBindings = getRoleBindings()\n  return [\n    ...contextBindings,\n    ...urlBindings,\n    ...stateBindings,\n    ...userBindings,\n    ...deviceBindings,\n    ...selectedRowsBindings,\n    ...roleBindings,\n  ]\n}\n\n/**\n * Gets all rest bindable data fields\n */\nexport const getRestBindings = () => {\n  const userBindings = getUserBindings()\n  return [...userBindings, ...getAuthBindings()]\n}\n\n/**\n * Gets all rest bindable auth fields\n */\nexport const getAuthBindings = () => {\n  let bindings = []\n  const safeUser = makePropSafe(\"user\")\n  const safeOAuth2 = makePropSafe(\"oauth2\")\n  const safeAccessToken = makePropSafe(\"accessToken\")\n\n  const authBindings = [\n    {\n      runtime: `${safeUser}.${safeOAuth2}.${safeAccessToken}`,\n      readable: `Current User.OAuthToken`,\n      key: \"accessToken\",\n    },\n  ]\n\n  bindings = Object.keys(authBindings).map(key => {\n    const fieldBinding = authBindings[key]\n    return {\n      type: \"context\",\n      runtimeBinding: fieldBinding.runtime,\n      readableBinding: fieldBinding.readable,\n      fieldSchema: { type: \"string\", name: fieldBinding.key },\n      providerId: \"user\",\n    }\n  })\n  return bindings\n}\n\n/**\n * Utility - convert a key/value map to an array of custom 'context' bindings\n * @param {object} valueMap Key/value pairings\n * @param {string} prefix A contextual string prefix/path for a user readable binding\n * @return {object[]} An array containing readable/runtime binding objects\n */\nexport const toBindingsArray = (valueMap, prefix) => {\n  if (!valueMap) {\n    return []\n  }\n  return Object.keys(valueMap).reduce((acc, binding) => {\n    if (!binding || !valueMap[binding]) {\n      return acc\n    }\n    acc.push({\n      type: \"context\",\n      runtimeBinding: binding,\n      readableBinding: `${prefix}.${binding}`,\n    })\n    return acc\n  }, [])\n}\n\n/**\n * Utility - coverting a map of readable bindings to runtime\n */\nexport const readableToRuntimeMap = (bindings, ctx) => {\n  if (!bindings || !ctx) {\n    return {}\n  }\n  return Object.keys(ctx).reduce((acc, key) => {\n    let parsedQuery = readableToRuntimeBinding(bindings, ctx[key])\n    acc[key] = parsedQuery\n    return acc\n  }, {})\n}\n\n/**\n * Utility - coverting a map of runtime bindings to readable\n */\nexport const runtimeToReadableMap = (bindings, ctx) => {\n  if (!bindings || !ctx) {\n    return {}\n  }\n  return Object.keys(ctx).reduce((acc, key) => {\n    let parsedQuery = runtimeToReadableBinding(bindings, ctx[key])\n    acc[key] = parsedQuery\n    return acc\n  }, {})\n}\n\n/**\n * Gets the bindable properties exposed by a certain component.\n */\nexport const getComponentBindableProperties = (asset, componentId) => {\n  if (!asset || !componentId) {\n    return []\n  }\n\n  // Ensure that the component exists and exposes context\n  const component = findComponent(asset.props, componentId)\n  const def = store.actions.components.getDefinition(component?._component)\n  if (!def?.context) {\n    return []\n  }\n\n  // Get the bindings for the component\n  return getProviderContextBindings(asset, component)\n}\n\n/**\n * Gets all data provider components above a component.\n */\nexport const getContextProviderComponents = (asset, componentId, type) => {\n  if (!asset || !componentId) {\n    return []\n  }\n\n  // Get the component tree leading up to this component, ignoring the component\n  // itself\n  const path = findComponentPath(asset.props, componentId)\n  path.pop()\n\n  // Filter by only data provider components\n  return path.filter(component => {\n    const def = store.actions.components.getDefinition(component._component)\n    if (!def?.context) {\n      return false\n    }\n\n    // If no type specified, return anything that exposes context\n    if (!type) {\n      return true\n    }\n\n    // Otherwise only match components with the specific context type\n    const contexts = Array.isArray(def.context) ? def.context : [def.context]\n    return contexts.find(context => context.type === type) != null\n  })\n}\n\n/**\n * Gets all data provider components above a component.\n */\nexport const getActionProviderComponents = (asset, componentId, actionType) => {\n  if (!asset || !componentId) {\n    return []\n  }\n\n  // Get the component tree leading up to this component, ignoring the component\n  // itself\n  const path = findComponentPath(asset.props, componentId)\n  path.pop()\n\n  // Filter by only data provider components\n  return path.filter(component => {\n    const def = store.actions.components.getDefinition(component._component)\n    return def?.actions?.includes(actionType)\n  })\n}\n\n/**\n * Gets a datasource object for a certain data provider component\n */\nexport const getDatasourceForProvider = (asset, component) => {\n  const settings = getComponentSettings(component?._component)\n\n  // If this component has a dataProvider setting, go up the stack and use it\n  const dataProviderSetting = settings.find(setting => {\n    return setting.type === \"dataProvider\"\n  })\n  if (dataProviderSetting) {\n    const settingValue = component[dataProviderSetting.key]\n    const providerId = extractLiteralHandlebarsID(settingValue)\n    const provider = findComponent(asset?.props, providerId)\n    return getDatasourceForProvider(asset, provider)\n  }\n\n  // Extract datasource from component instance\n  const validSettingTypes = [\"dataSource\", \"table\", \"schema\"]\n  const datasourceSetting = settings.find(setting => {\n    return validSettingTypes.includes(setting.type)\n  })\n  if (!datasourceSetting) {\n    return null\n  }\n\n  // There are different types of setting which can be a datasource, for\n  // example an actual datasource object, or a table ID string.\n  // Convert the datasource setting into a proper datasource object so that\n  // we can use it properly\n  if (datasourceSetting.type === \"table\") {\n    return {\n      tableId: component[datasourceSetting?.key],\n      type: \"table\",\n    }\n  } else {\n    return component[datasourceSetting?.key]\n  }\n}\n\n/**\n * Gets all bindable data properties from component data contexts.\n */\nconst getContextBindings = (asset, componentId) => {\n  // Extract any components which provide data contexts\n  const dataProviders = getContextProviderComponents(asset, componentId)\n\n  // Generate bindings for all matching components\n  return getProviderContextBindings(asset, dataProviders)\n}\n\n/**\n * Gets the context bindings exposed by a set of data provider components.\n */\nconst getProviderContextBindings = (asset, dataProviders) => {\n  if (!asset || !dataProviders) {\n    return []\n  }\n\n  // Ensure providers is an array\n  if (!Array.isArray(dataProviders)) {\n    dataProviders = [dataProviders]\n  }\n\n  // Create bindings for each data provider\n  let bindings = []\n  dataProviders.forEach(component => {\n    const def = store.actions.components.getDefinition(component._component)\n    const contexts = Array.isArray(def.context) ? def.context : [def.context]\n\n    // Create bindings for each context block provided by this data provider\n    contexts.forEach(context => {\n      if (!context?.type) {\n        return\n      }\n\n      let schema\n      let table\n      let readablePrefix\n      let runtimeSuffix = context.suffix\n\n      if (context.type === \"form\") {\n        // Forms do not need table schemas\n        // Their schemas are built from their component field names\n        schema = buildFormSchema(component)\n        readablePrefix = \"Fields\"\n      } else if (context.type === \"static\") {\n        // Static contexts are fully defined by the components\n        schema = {}\n        const values = context.values || []\n        values.forEach(value => {\n          schema[value.key] = { name: value.label, type: \"string\" }\n        })\n      } else if (context.type === \"schema\") {\n        // Schema contexts are generated dynamically depending on their data\n        const datasource = getDatasourceForProvider(asset, component)\n        if (!datasource) {\n          return\n        }\n        const info = getSchemaForDatasource(asset, datasource)\n        schema = info.schema\n        table = info.table\n\n        // For JSON arrays, use the array name as the readable prefix.\n        // Otherwise use the table name\n        if (datasource.type === \"jsonarray\") {\n          const split = datasource.label.split(\".\")\n          readablePrefix = split[split.length - 1]\n        } else {\n          readablePrefix = info.table?.name\n        }\n      }\n      if (!schema) {\n        return\n      }\n\n      const keys = Object.keys(schema).sort()\n\n      // Generate safe unique runtime prefix\n      let providerId = component._id\n      if (runtimeSuffix) {\n        providerId += `-${runtimeSuffix}`\n      }\n      const safeComponentId = makePropSafe(providerId)\n\n      // Create bindable properties for each schema field\n      keys.forEach(key => {\n        const fieldSchema = schema[key]\n\n        // Make safe runtime binding\n        const safeKey = key.split(\".\").map(makePropSafe).join(\".\")\n        const runtimeBinding = `${safeComponentId}.${safeKey}`\n\n        // Optionally use a prefix with readable bindings\n        let readableBinding = component._instanceName\n        if (readablePrefix) {\n          readableBinding += `.${readablePrefix}`\n        }\n        readableBinding += `.${fieldSchema.name || key}`\n\n        // Create the binding object\n        bindings.push({\n          type: \"context\",\n          runtimeBinding,\n          readableBinding,\n          // Field schema and provider are required to construct relationship\n          // datasource options, based on bindable properties\n          fieldSchema,\n          providerId,\n          // Table ID is used by JSON fields to know what table the field is in\n          tableId: table?._id,\n        })\n      })\n    })\n  })\n\n  return bindings\n}\n\n/**\n * Gets all bindable properties from the logged in user.\n */\nexport const getUserBindings = () => {\n  let bindings = []\n  const { schema } = getSchemaForTable(TableNames.USERS)\n  const keys = Object.keys(schema).sort()\n  const safeUser = makePropSafe(\"user\")\n  keys.forEach(key => {\n    const fieldSchema = schema[key]\n    bindings.push({\n      type: \"context\",\n      runtimeBinding: `${safeUser}.${makePropSafe(key)}`,\n      readableBinding: `Current User.${key}`,\n      // Field schema and provider are required to construct relationship\n      // datasource options, based on bindable properties\n      fieldSchema,\n      providerId: \"user\",\n    })\n  })\n  return bindings\n}\n\n/**\n * Gets all device bindings that are globally available.\n */\nconst getDeviceBindings = () => {\n  let bindings = []\n  if (get(store).clientFeatures?.deviceAwareness) {\n    const safeDevice = makePropSafe(\"device\")\n    bindings.push({\n      type: \"context\",\n      runtimeBinding: `${safeDevice}.${makePropSafe(\"mobile\")}`,\n      readableBinding: `Device.Mobile`,\n    })\n    bindings.push({\n      type: \"context\",\n      runtimeBinding: `${safeDevice}.${makePropSafe(\"tablet\")}`,\n      readableBinding: `Device.Tablet`,\n    })\n  }\n  return bindings\n}\n\n/**\n * Gets all selected rows bindings for tables in the current asset.\n */\nconst getSelectedRowsBindings = asset => {\n  let bindings = []\n  if (get(store).clientFeatures?.rowSelection) {\n    // Add bindings for table components\n    let tables = findAllMatchingComponents(asset?.props, component =>\n      component._component.endsWith(\"table\")\n    )\n    const safeState = makePropSafe(\"rowSelection\")\n    bindings = bindings.concat(\n      tables.map(table => ({\n        type: \"context\",\n        runtimeBinding: `${safeState}.${makePropSafe(table._id)}.${makePropSafe(\n          \"selectedRows\"\n        )}`,\n        readableBinding: `${table._instanceName}.Selected rows`,\n      }))\n    )\n\n    // Add bindings for table blocks\n    let tableBlocks = findAllMatchingComponents(asset?.props, component =>\n      component._component.endsWith(\"tableblock\")\n    )\n    bindings = bindings.concat(\n      tableBlocks.map(block => ({\n        type: \"context\",\n        runtimeBinding: `${safeState}.${makePropSafe(\n          block._id + \"-table\"\n        )}.${makePropSafe(\"selectedRows\")}`,\n        readableBinding: `${block._instanceName}.Selected rows`,\n      }))\n    )\n  }\n  return bindings\n}\n\n/**\n * Gets all state bindings that are globally available.\n */\nconst getStateBindings = () => {\n  let bindings = []\n  if (get(store).clientFeatures?.state) {\n    const safeState = makePropSafe(\"state\")\n    bindings = getAllStateVariables().map(key => ({\n      type: \"context\",\n      runtimeBinding: `${safeState}.${makePropSafe(key)}`,\n      readableBinding: `State.${key}`,\n    }))\n  }\n  return bindings\n}\n\n/**\n * Gets all bindable properties from URL parameters.\n */\nconst getUrlBindings = asset => {\n  const url = asset?.routing?.route ?? \"\"\n  const split = url.split(\"/\")\n  let params = []\n  split.forEach(part => {\n    if (part.startsWith(\":\") && part.length > 1) {\n      params.push(part.replace(/:/g, \"\").replace(/\\?/g, \"\"))\n    }\n  })\n  const safeURL = makePropSafe(\"url\")\n  const urlParamBindings = params.map(param => ({\n    type: \"context\",\n    runtimeBinding: `${safeURL}.${makePropSafe(param)}`,\n    readableBinding: `URL.${param}`,\n  }))\n  const queryParamsBinding = {\n    type: \"context\",\n    runtimeBinding: makePropSafe(\"query\"),\n    readableBinding: \"Query params\",\n  }\n  return urlParamBindings.concat([queryParamsBinding])\n}\n\nconst getRoleBindings = () => {\n  return (get(rolesStore) || []).map(role => {\n    return {\n      type: \"context\",\n      runtimeBinding: `trim \"${role._id}\"`,\n      readableBinding: `Role.${role.name}`,\n    }\n  })\n}\n\n/**\n * Gets all bindable properties exposed in an event action flow up until\n * the specified action ID, as well as context provided for the action\n * setting as a whole by the component.\n */\nexport const getEventContextBindings = (\n  asset,\n  componentId,\n  settingKey,\n  actions,\n  actionId\n) => {\n  let bindings = []\n\n  // Check if any context bindings are provided by the component for this\n  // setting\n  const component = findComponent(asset.props, componentId)\n  const settings = getComponentSettings(component?._component)\n  const eventSetting = settings.find(setting => setting.key === settingKey)\n  if (eventSetting?.context?.length) {\n    eventSetting.context.forEach(contextEntry => {\n      bindings.push({\n        readableBinding: contextEntry.label,\n        runtimeBinding: `${makePropSafe(\"eventContext\")}.${makePropSafe(\n          contextEntry.key\n        )}`,\n      })\n    })\n  }\n\n  // Get the steps leading up to this value\n  const index = actions?.findIndex(action => action.id === actionId)\n  if (index == null || index === -1) {\n    return bindings\n  }\n  const prevActions = actions.slice(0, index)\n\n  // Generate bindings for any steps which provide context\n  prevActions.forEach((action, idx) => {\n    const def = ActionDefinitions.actions.find(\n      x => x.name === action[\"##eventHandlerType\"]\n    )\n    if (def.context) {\n      def.context.forEach(contextValue => {\n        bindings.push({\n          readableBinding: `Action ${idx + 1}.${contextValue.label}`,\n          runtimeBinding: `actions.${idx}.${contextValue.value}`,\n        })\n      })\n    }\n  })\n\n  return bindings\n}\n\n/**\n * Gets the schema for a certain table ID.\n * The options which can be passed in are:\n *   formSchema: whether the schema is for a form\n *   searchableSchema: whether to generate a searchable schema, which may have\n *     fewer fields than a readable schema\n * @param tableId the table ID to get the schema for\n * @param options options for generating the schema\n * @return {{schema: Object, table: Object}}\n */\nexport const getSchemaForTable = (tableId, options) => {\n  return getSchemaForDatasource(null, { type: \"table\", tableId }, options)\n}\n\n/**\n * Gets a schema for a datasource object.\n * The options which can be passed in are:\n *   formSchema: whether the schema is for a form\n *   searchableSchema: whether to generate a searchable schema, which may have\n *     fewer fields than a readable schema\n * @param asset the current root client app asset (layout or screen). This is\n *   optional and only needed for \"provider\" datasource types.\n * @param datasource the datasource definition\n * @param options options for generating the schema\n * @return {{schema: Object, table: Object}}\n */\nexport const getSchemaForDatasource = (asset, datasource, options) => {\n  options = options || {}\n  let schema, table\n\n  if (datasource) {\n    const { type } = datasource\n    const tables = get(tablesStore).list\n\n    // Determine the entity which backs this datasource.\n    // \"provider\" datasources are those targeting another data provider\n    if (type === \"provider\") {\n      const component = findComponent(asset?.props, datasource.providerId)\n      const source = getDatasourceForProvider(asset, component)\n      return getSchemaForDatasource(asset, source, options)\n    }\n\n    // \"query\" datasources are those targeting non-plus datasources or\n    // custom queries\n    else if (type === \"query\") {\n      const queries = get(queriesStores).list\n      table = queries.find(query => query._id === datasource._id)\n    }\n\n    // \"field\" datasources are array-like fields of rows, such as attachments\n    // or multi-select fields\n    else if (type === \"field\") {\n      table = { name: datasource.fieldName }\n      const { fieldType } = datasource\n      if (fieldType === \"attachment\") {\n        schema = {\n          url: {\n            type: \"string\",\n          },\n          name: {\n            type: \"string\",\n          },\n        }\n      } else if (fieldType === \"array\") {\n        schema = {\n          value: {\n            type: \"string\",\n          },\n        }\n      }\n    }\n\n    // \"jsonarray\" datasources are arrays inside JSON fields\n    else if (type === \"jsonarray\") {\n      table = tables.find(table => table._id === datasource.tableId)\n      let tableSchema = table?.schema\n      schema = JSONUtils.getJSONArrayDatasourceSchema(tableSchema, datasource)\n    }\n\n    // Otherwise we assume we're targeting an internal table or a plus\n    // datasource, and we can treat it as a table with a schema\n    else {\n      table = tables.find(table => table._id === datasource.tableId)\n    }\n\n    // Determine the schema from the backing entity if not already determined\n    if (table && !schema) {\n      if (type === \"view\") {\n        // For views, the schema is pulled from the `views` property of the\n        // table\n        schema = cloneDeep(table.views?.[datasource.name]?.schema)\n      } else if (\n        type === \"query\" &&\n        (options.formSchema || options.searchableSchema)\n      ) {\n        // For queries, if we are generating a schema for a form or a searchable\n        // schema then we want to use the query parameters rather than the\n        // query schema\n        schema = {}\n        const params = table.parameters || []\n        params.forEach(param => {\n          if (param?.name) {\n            schema[param.name] = { ...param, type: \"string\" }\n          }\n        })\n      } else {\n        // Otherwise we just want the schema of the table\n        schema = cloneDeep(table.schema)\n      }\n    }\n\n    // Check for any JSON fields so we can add any top level properties\n    if (schema) {\n      let jsonAdditions = {}\n      Object.keys(schema).forEach(fieldKey => {\n        const fieldSchema = schema[fieldKey]\n        if (fieldSchema?.type === \"json\") {\n          const jsonSchema = JSONUtils.convertJSONSchemaToTableSchema(\n            fieldSchema,\n            {\n              squashObjects: true,\n            }\n          )\n          Object.keys(jsonSchema).forEach(jsonKey => {\n            jsonAdditions[`${fieldKey}.${jsonKey}`] = {\n              type: jsonSchema[jsonKey].type,\n              nestedJSON: true,\n            }\n          })\n        }\n      })\n      schema = { ...schema, ...jsonAdditions }\n    }\n\n    // Determine if we should add ID and rev to the schema\n    const isInternal = table && !table.sql\n    const isTable = [\"table\", \"link\"].includes(datasource.type)\n\n    // ID is part of the readable schema for all tables\n    // Rev is part of the readable schema for internal tables only\n    let addId = isTable\n    let addRev = isTable && isInternal\n\n    // Don't add ID or rev for form schemas\n    if (options.formSchema) {\n      addId = false\n      addRev = false\n    }\n\n    // ID is only searchable for internal tables\n    else if (options.searchableSchema) {\n      addId = isTable && isInternal\n    }\n\n    // Add schema properties if required\n    if (schema) {\n      if (addId) {\n        schema[\"_id\"] = { type: \"string\" }\n      }\n      if (addRev) {\n        schema[\"_rev\"] = { type: \"string\" }\n      }\n    }\n\n    // Ensure there are \"name\" properties for all fields and that field schema\n    // are objects\n    let fixedSchema = {}\n    Object.entries(schema || {}).forEach(([fieldName, fieldSchema]) => {\n      if (typeof fieldSchema === \"string\") {\n        fixedSchema[fieldName] = {\n          type: fieldSchema,\n          name: fieldName,\n        }\n      } else {\n        fixedSchema[fieldName] = {\n          ...fieldSchema,\n          name: fieldName,\n        }\n      }\n    })\n    schema = fixedSchema\n  }\n  return { schema, table }\n}\n\n/**\n * Builds a form schema given a form component.\n * A form schema is a schema of all the fields nested anywhere within a form.\n */\nexport const buildFormSchema = component => {\n  let schema = {}\n  if (!component) {\n    return schema\n  }\n  const settings = getComponentSettings(component._component)\n  const fieldSetting = settings.find(\n    setting => setting.key === \"field\" && setting.type.startsWith(\"field/\")\n  )\n  if (fieldSetting && component.field) {\n    const type = fieldSetting.type.split(\"field/\")[1]\n    if (type) {\n      schema[component.field] = { type }\n    }\n  }\n  component._children?.forEach(child => {\n    const childSchema = buildFormSchema(child)\n    schema = { ...schema, ...childSchema }\n  })\n  return schema\n}\n\n/**\n * Returns an array of the keys of any state variables which are set anywhere\n * in the app.\n */\nexport const getAllStateVariables = () => {\n  // Find all button action settings in all components\n  let eventSettings = []\n  getAllAssets().forEach(asset => {\n    findAllMatchingComponents(asset.props, component => {\n      const settings = getComponentSettings(component._component)\n      settings\n        .filter(setting => setting.type === \"event\")\n        .forEach(setting => {\n          eventSettings.push(component[setting.key])\n        })\n    })\n  })\n\n  // Add on load settings from screens\n  get(store).screens.forEach(screen => {\n    if (screen.onLoad) {\n      eventSettings.push(screen.onLoad)\n    }\n  })\n\n  // Extract all state keys from any \"update state\" actions in each setting\n  let bindingSet = new Set()\n  eventSettings.forEach(setting => {\n    if (!Array.isArray(setting)) {\n      return\n    }\n    setting.forEach(action => {\n      if (\n        action[\"##eventHandlerType\"] === \"Update State\" &&\n        action.parameters?.type === \"set\" &&\n        action.parameters?.key &&\n        action.parameters?.value\n      ) {\n        bindingSet.add(action.parameters.key)\n      }\n    })\n  })\n  return Array.from(bindingSet)\n}\n\nexport const getAllAssets = () => {\n  // Get all component containing assets\n  let allAssets = []\n  allAssets = allAssets.concat(get(store).layouts || [])\n  allAssets = allAssets.concat(get(store).screens || [])\n\n  return allAssets\n}\n\n/**\n * Recurses the input object to remove any instances of bindings.\n */\nexport const removeBindings = (obj, replacement = \"Invalid binding\") => {\n  for (let [key, value] of Object.entries(obj)) {\n    if (value && typeof value === \"object\") {\n      obj[key] = removeBindings(value, replacement)\n    } else if (typeof value === \"string\") {\n      obj[key] = value.replace(CAPTURE_HBS_TEMPLATE, replacement)\n    }\n  }\n  return obj\n}\n\n/**\n * When converting from readable to runtime it can sometimes add too many square brackets,\n * this makes sure that doesn't happen.\n */\nconst shouldReplaceBinding = (currentValue, convertFrom, convertTo) => {\n  if (!currentValue?.includes(convertFrom)) {\n    return false\n  }\n  if (convertTo === \"readableBinding\") {\n    return true\n  }\n  // remove all the spaces, if the input is surrounded by spaces e.g. [ Auto ID ] then\n  // this makes sure it is detected\n  const noSpaces = currentValue.replace(/\\s+/g, \"\")\n  const fromNoSpaces = convertFrom.replace(/\\s+/g, \"\")\n  const invalids = [\n    `[${fromNoSpaces}]`,\n    `\"${fromNoSpaces}\"`,\n    `'${fromNoSpaces}'`,\n  ]\n  return !invalids.find(invalid => noSpaces?.includes(invalid))\n}\n\n/**\n * Utility function which replaces a string between given indices.\n */\nconst replaceBetween = (string, start, end, replacement) => {\n  return string.substring(0, start) + replacement + string.substring(end)\n}\n\n/**\n * Utility function for the readableToRuntimeBinding and runtimeToReadableBinding.\n */\nconst bindingReplacement = (\n  bindableProperties,\n  textWithBindings,\n  convertTo\n) => {\n  // Decide from base64 if using JS\n  const isJS = isJSBinding(textWithBindings)\n  if (isJS) {\n    textWithBindings = decodeJSBinding(textWithBindings)\n  }\n\n  // Determine correct regex to find bindings to replace\n  const regex = isJS ? CAPTURE_VAR_INSIDE_JS : CAPTURE_VAR_INSIDE_TEMPLATE\n\n  const convertFrom =\n    convertTo === \"runtimeBinding\" ? \"readableBinding\" : \"runtimeBinding\"\n  if (typeof textWithBindings !== \"string\") {\n    return textWithBindings\n  }\n  // work from longest to shortest\n  const convertFromProps = bindableProperties\n    .map(el => el[convertFrom])\n    .sort((a, b) => {\n      return b.length - a.length\n    })\n  const boundValues = textWithBindings.match(regex) || []\n  let result = textWithBindings\n  for (let boundValue of boundValues) {\n    let newBoundValue = boundValue\n    // we use a search string, where any time we replace something we blank it out\n    // in the search, working from longest to shortest so always use best match first\n    let searchString = newBoundValue\n    for (let from of convertFromProps) {\n      if (isJS || shouldReplaceBinding(newBoundValue, from, convertTo)) {\n        const binding = bindableProperties.find(el => el[convertFrom] === from)\n        let idx\n        do {\n          // see if any instances of this binding exist in the search string\n          idx = searchString.indexOf(from)\n          if (idx !== -1) {\n            let end = idx + from.length,\n              searchReplace = Array(binding[convertTo].length + 1).join(\"*\")\n            // blank out parts of the search string\n            searchString = replaceBetween(searchString, idx, end, searchReplace)\n            newBoundValue = replaceBetween(\n              newBoundValue,\n              idx,\n              end,\n              binding[convertTo]\n            )\n          }\n        } while (idx !== -1)\n      }\n    }\n    result = result.replace(boundValue, newBoundValue)\n  }\n\n  // Re-encode to base64 if using JS\n  if (isJS) {\n    result = encodeJSBinding(result)\n  }\n\n  return result\n}\n\n/**\n * Extracts a component ID from a handlebars expression setting of\n * {{ literal [componentId] }}\n */\nconst extractLiteralHandlebarsID = value => {\n  return value?.match(/{{\\s*literal\\s*\\[+([^\\]]+)].*}}/)?.[1]\n}\n\n/**\n * Converts a readable data binding into a runtime data binding\n */\nexport const readableToRuntimeBinding = (\n  bindableProperties,\n  textWithBindings\n) => {\n  return bindingReplacement(\n    bindableProperties,\n    textWithBindings,\n    \"runtimeBinding\"\n  )\n}\n\n/**\n * Converts a runtime data binding into a readable data binding\n */\nexport const runtimeToReadableBinding = (\n  bindableProperties,\n  textWithBindings\n) => {\n  return bindingReplacement(\n    bindableProperties,\n    textWithBindings,\n    \"readableBinding\"\n  )\n}\n", "import { IntegrationTypes } from \"constants/backend\"\n\nexport function schemaToFields(schema) {\n  const response = {}\n  if (schema && typeof schema === \"object\") {\n    for (let [field, value] of Object.entries(schema)) {\n      response[field] = value?.type || \"string\"\n    }\n  }\n  return response\n}\n\nexport function fieldsToSchema(fields) {\n  const response = {}\n  if (fields && typeof fields === \"object\") {\n    for (let [name, type] of Object.entries(fields)) {\n      response[name] = { name, type }\n    }\n  }\n  return response\n}\n\nexport function breakQueryString(qs) {\n  if (!qs) {\n    return {}\n  }\n  if (qs.includes(\"?\")) {\n    qs = qs.split(\"?\")[1]\n  }\n  const params = qs.split(\"&\")\n  let paramObj = {}\n  for (let param of params) {\n    const split = param.split(\"=\")\n    paramObj[split[0]] = split.slice(1).join(\"=\")\n  }\n  return paramObj\n}\n\nexport function buildQueryString(obj) {\n  let str = \"\"\n  if (obj) {\n    for (let [key, value] of Object.entries(obj)) {\n      if (!key || key === \"\") {\n        continue\n      }\n      if (str !== \"\") {\n        str += \"&\"\n      }\n      str += `${key}=${encodeURIComponent(value || \"\")}`\n    }\n  }\n  return str\n}\n\nexport function keyValueToQueryParameters(obj) {\n  let array = []\n  if (obj && typeof obj === \"object\") {\n    for (let [key, value] of Object.entries(obj)) {\n      array.push({ name: key, default: value })\n    }\n  }\n  return array\n}\n\nexport function queryParametersToKeyValue(array) {\n  let obj = {}\n  if (Array.isArray(array)) {\n    for (let param of array) {\n      obj[param.name] = param.default\n    }\n  }\n  return obj\n}\n\nexport function customQueryIconText(datasource, query) {\n  if (datasource.source !== IntegrationTypes.REST) {\n    return\n  }\n  switch (query.queryVerb) {\n    case \"create\":\n      return \"POST\"\n    case \"update\":\n      return \"PUT\"\n    case \"read\":\n      return \"GET\"\n    case \"delete\":\n      return \"DEL\"\n    case \"patch\":\n      return \"PATCH\"\n  }\n}\n\nexport function customQueryIconColor(datasource, query) {\n  if (datasource.source !== IntegrationTypes.REST) {\n    return\n  }\n  switch (query.queryVerb) {\n    case \"create\":\n      return \"#dcc339\"\n    case \"update\":\n      return \"#5197ec\"\n    case \"read\":\n      return \"#53a761\"\n    case \"delete\":\n      return \"#ea7d82\"\n    case \"patch\":\n    default:\n      return\n  }\n}\n\nexport function customQueryText(datasource, query) {\n  if (!query.name || datasource.source !== IntegrationTypes.REST) {\n    return query.name\n  }\n\n  // Remove protocol\n  let name = query.name\n  if (name.includes(\"//\")) {\n    name = name.split(\"//\")[1]\n  }\n\n  // If no path, return the full name\n  if (!name.includes(\"/\")) {\n    return name\n  }\n\n  // Remove trailing slash\n  if (name.endsWith(\"/\")) {\n    name = name.slice(0, -1)\n  }\n\n  // Only use path\n  const split = name.split(\"/\")\n  if (split[1]) {\n    return `/${split.slice(1).join(\"/\")}`\n  } else {\n    return split[0]\n  }\n}\n\nexport function flipHeaderState(headersActivity) {\n  if (!headersActivity) {\n    return {}\n  }\n  const enabled = {}\n  Object.entries(headersActivity).forEach(([key, value]) => {\n    enabled[key] = !value\n  })\n  return enabled\n}\n\nexport const parseToCsv = (headers, rows) => {\n  let csv = headers?.map(key => `\"${key}\"`)?.join(\",\") || \"\"\n\n  for (let row of rows) {\n    csv = `${csv}\\n${headers\n      .map(header => {\n        let val = row[header]\n        val =\n          typeof val === \"object\" && !(val instanceof Date)\n            ? `\"${JSON.stringify(val).replace(/\"/g, \"'\")}\"`\n            : `\"${val}\"`\n        return val.trim()\n      })\n      .join(\",\")}`\n  }\n  return csv\n}\n\nexport default {\n  breakQueryString,\n  buildQueryString,\n  fieldsToSchema,\n  flipHeaderState,\n  keyValueToQueryParameters,\n  parseToCsv,\n  queryParametersToKeyValue,\n  schemaToFields,\n}\n", "<script>\n  import { params } from \"@roxi/routify\"\n  import { datasources, flags, integrations, queries } from \"stores/backend\"\n  import {\n    Banner,\n    Body,\n    Button,\n    Divider,\n    Heading,\n    Input,\n    Label,\n    Layout,\n    notifications,\n    RadioGroup,\n    Select,\n    Tab,\n    Table,\n    Tabs,\n    TextArea,\n  } from \"@budibase/bbui\"\n  import KeyValueBuilder from \"components/integration/KeyValueBuilder.svelte\"\n  import EditableLabel from \"components/common/inputs/EditableLabel.svelte\"\n  import CodeMirrorEditor, {\n    EditorModes,\n  } from \"components/common/CodeMirrorEditor.svelte\"\n  import RestBodyInput from \"../../_components/RestBodyInput.svelte\"\n  import { capitalise } from \"helpers\"\n  import { onMount } from \"svelte\"\n  import restUtils from \"helpers/data/utils\"\n  import {\n    PaginationLocations,\n    PaginationTypes,\n    RawRestBodyTypes,\n    RestBodyTypes as bodyTypes,\n    SchemaTypeOptions,\n  } from \"constants/backend\"\n  import JSONPreview from \"components/integration/JSONPreview.svelte\"\n  import AccessLevelSelect from \"components/integration/AccessLevelSelect.svelte\"\n  import DynamicVariableModal from \"../../_components/DynamicVariableModal.svelte\"\n  import Placeholder from \"assets/bb-spaceship.svg\"\n  import { cloneDeep } from \"lodash/fp\"\n\n  import {\n    getRestBindings,\n    readableToRuntimeBinding,\n    readableToRuntimeMap,\n    runtimeToReadableBinding,\n    runtimeToReadableMap,\n    toBindingsArray,\n  } from \"builderStore/dataBinding\"\n\n  let query, datasource\n  let breakQs = {},\n    requestBindings = {}\n  let saveId, url\n  let response, schema, enabledHeaders\n  let authConfigId\n  let dynamicVariables, addVariableModal, varBinding, globalDynamicBindings\n  let restBindings = getRestBindings()\n\n  $: staticVariables = datasource?.config?.staticVariables || {}\n\n  $: customRequestBindings = toBindingsArray(requestBindings, \"Binding\")\n  $: globalDynamicRequestBindings = toBindingsArray(\n    globalDynamicBindings,\n    \"Dynamic\"\n  )\n  $: dataSourceStaticBindings = toBindingsArray(\n    staticVariables,\n    \"Datasource.Static\"\n  )\n\n  $: mergedBindings = [\n    ...restBindings,\n    ...customRequestBindings,\n    ...globalDynamicRequestBindings,\n    ...dataSourceStaticBindings,\n  ]\n\n  $: datasourceType = datasource?.source\n  $: integrationInfo = $integrations[datasourceType]\n  $: queryConfig = integrationInfo?.query\n  $: url = buildUrl(url, breakQs)\n  $: checkQueryName(url)\n  $: responseSuccess = response?.info?.code >= 200 && response?.info?.code < 400\n  $: isGet = query?.queryVerb === \"read\"\n  $: authConfigs = buildAuthConfigs(datasource)\n  $: schemaReadOnly = !responseSuccess\n  $: variablesReadOnly = !responseSuccess\n  $: showVariablesTab = shouldShowVariables(dynamicVariables, variablesReadOnly)\n  $: hasSchema =\n    Object.keys(schema || {}).length !== 0 ||\n    Object.keys(query?.schema || {}).length !== 0\n\n  $: runtimeUrlQueries = readableToRuntimeMap(mergedBindings, breakQs)\n\n  function getSelectedQuery() {\n    return cloneDeep(\n      $queries.list.find(q => q._id === $queries.selected) || {\n        datasourceId: $params.selectedDatasource,\n        parameters: [],\n        fields: {\n          // only init the objects, everything else is optional strings\n          disabledHeaders: {},\n          headers: {},\n        },\n        queryVerb: \"read\",\n      }\n    )\n  }\n\n  function checkQueryName(inputUrl = null) {\n    if (query && (!query.name || query.flags.urlName)) {\n      query.flags.urlName = true\n      query.name = url || inputUrl\n    }\n  }\n\n  function buildUrl(base, qsObj) {\n    if (!base) {\n      return base\n    }\n    let qs = restUtils.buildQueryString(\n      runtimeToReadableMap(mergedBindings, qsObj)\n    )\n    let newUrl = base\n    if (base.includes(\"?\")) {\n      const split = base.split(\"?\")\n      newUrl = split[0]\n    }\n    return qs.length === 0 ? newUrl : `${newUrl}?${qs}`\n  }\n\n  function buildQuery() {\n    const newQuery = cloneDeep(query)\n    const queryString = restUtils.buildQueryString(runtimeUrlQueries)\n\n    newQuery.parameters = restUtils.keyValueToQueryParameters(requestBindings)\n    newQuery.fields.requestBody =\n      typeof newQuery.fields.requestBody === \"object\"\n        ? readableToRuntimeMap(mergedBindings, newQuery.fields.requestBody)\n        : readableToRuntimeBinding(mergedBindings, newQuery.fields.requestBody)\n\n    newQuery.fields.path = url.split(\"?\")[0]\n    newQuery.fields.queryString = queryString\n    newQuery.fields.authConfigId = authConfigId\n    newQuery.fields.disabledHeaders = restUtils.flipHeaderState(enabledHeaders)\n    newQuery.schema = restUtils.fieldsToSchema(schema)\n\n    return newQuery\n  }\n\n  async function saveQuery() {\n    const toSave = buildQuery()\n    try {\n      const { _id } = await queries.save(toSave.datasourceId, toSave)\n      saveId = _id\n      query = getSelectedQuery()\n      notifications.success(`Request saved successfully`)\n      if (dynamicVariables) {\n        datasource.config.dynamicVariables = rebuildVariables(saveId)\n        datasource = await datasources.save(datasource)\n      }\n      prettifyQueryRequestBody(\n        query,\n        requestBindings,\n        dynamicVariables,\n        staticVariables,\n        restBindings\n      )\n    } catch (err) {\n      notifications.error(`Error saving query`)\n    }\n  }\n\n  async function runQuery() {\n    try {\n      response = await queries.preview(buildQuery())\n      if (response.rows.length === 0) {\n        notifications.info(\"Request did not return any data\")\n      } else {\n        response.info = response.info || { code: 200 }\n        schema = response.schema\n        notifications.success(\"Request sent successfully\")\n      }\n    } catch (error) {\n      notifications.error(`Query Error: ${error.message}`)\n    }\n  }\n\n  const getAuthConfigId = () => {\n    let id = query.fields.authConfigId\n    if (id) {\n      // find the matching config on the datasource\n      const matchedConfig = datasource?.config?.authConfigs?.filter(\n        c => c._id === id\n      )[0]\n      // clear the id if the config is not found (deleted)\n      // i.e. just show 'None' in the dropdown\n      if (!matchedConfig) {\n        id = undefined\n      }\n    }\n    return id\n  }\n\n  const buildAuthConfigs = datasource => {\n    if (datasource?.config?.authConfigs) {\n      return datasource.config.authConfigs.map(c => ({\n        label: c.name,\n        value: c._id,\n      }))\n    }\n    return []\n  }\n\n  const schemaMenuItems = [\n    {\n      text: \"Create dynamic variable\",\n      onClick: input => {\n        varBinding = `{{ data.0.[${input.name}] }}`\n        addVariableModal.show()\n      },\n    },\n  ]\n  const responseHeadersMenuItems = [\n    {\n      text: \"Create dynamic variable\",\n      onClick: input => {\n        varBinding = `{{ info.headers.[${input.name}] }}`\n        addVariableModal.show()\n      },\n    },\n  ]\n\n  // convert dynamic variables list to simple key/val object\n  const getDynamicVariables = (datasource, queryId, matchFn) => {\n    const variablesList = datasource?.config?.dynamicVariables\n    if (variablesList && variablesList.length > 0) {\n      const filtered = queryId\n        ? variablesList.filter(variable => matchFn(variable, queryId))\n        : variablesList\n      return filtered.reduce(\n        (acc, next) => ({ ...acc, [next.name]: next.value }),\n        {}\n      )\n    }\n    return {}\n  }\n\n  // convert dynamic variables object back to a list, enrich with query id\n  const rebuildVariables = queryId => {\n    let variables = []\n    if (dynamicVariables) {\n      variables = Object.entries(dynamicVariables).map(entry => {\n        return {\n          name: entry[0],\n          value: entry[1],\n          queryId,\n        }\n      })\n    }\n\n    let existing = datasource?.config?.dynamicVariables || []\n    // remove existing query variables (for changes and deletions)\n    existing = existing.filter(variable => variable.queryId !== queryId)\n    // re-add the new query variables\n    return [...existing, ...variables]\n  }\n\n  const shouldShowVariables = (dynamicVariables, variablesReadOnly) => {\n    return !!(\n      dynamicVariables &&\n      // show when editable or when read only and not empty\n      (!variablesReadOnly || Object.keys(dynamicVariables).length > 0)\n    )\n  }\n\n  const updateFlag = async (flag, value) => {\n    try {\n      await flags.updateFlag(flag, value)\n    } catch (error) {\n      notifications.error(\"Error updating flag\")\n    }\n  }\n\n  const prettifyQueryRequestBody = (\n    query,\n    requestBindings,\n    dynamicVariables,\n    staticVariables,\n    restBindings\n  ) => {\n    let customRequestBindings = toBindingsArray(requestBindings, \"Binding\")\n    let dynamicRequestBindings = toBindingsArray(dynamicVariables, \"Dynamic\")\n    let dataSourceStaticBindings = toBindingsArray(\n      staticVariables,\n      \"Datasource.Static\"\n    )\n\n    const prettyBindings = [\n      ...restBindings,\n      ...customRequestBindings,\n      ...dynamicRequestBindings,\n      ...dataSourceStaticBindings,\n    ]\n\n    //Parse the body here as now all bindings have been updated.\n    if (query?.fields?.requestBody) {\n      query.fields.requestBody =\n        typeof query.fields.requestBody === \"object\"\n          ? runtimeToReadableMap(prettyBindings, query.fields.requestBody)\n          : runtimeToReadableBinding(prettyBindings, query.fields.requestBody)\n    }\n  }\n\n  const paramsChanged = evt => {\n    breakQs = {}\n    for (let param of evt.detail) {\n      breakQs[param.name] = param.value\n    }\n  }\n\n  const urlChanged = evt => {\n    breakQs = {}\n    const qs = evt.target.value.split(\"?\")[1]\n    if (qs && qs.length > 0) {\n      const parts = qs.split(\"&\")\n      for (let part of parts) {\n        const [key, value] = part.split(\"=\")\n        breakQs[key] = value\n      }\n    }\n  }\n\n  onMount(async () => {\n    query = getSelectedQuery()\n\n    try {\n      // Clear any unsaved changes to the datasource\n      await datasources.init()\n    } catch (error) {\n      notifications.error(\"Error getting datasources\")\n    }\n\n    datasource = $datasources.list.find(ds => ds._id === query?.datasourceId)\n    const datasourceUrl = datasource?.config.url\n    const qs = query?.fields.queryString\n    breakQs = restUtils.breakQueryString(qs)\n    breakQs = runtimeToReadableMap(mergedBindings, breakQs)\n\n    const path = query.fields.path\n    if (\n      datasourceUrl &&\n      !path?.startsWith(\"http\") &&\n      !path?.startsWith(\"{{\") // don't substitute the datasource url when query starts with a variable e.g. the upgrade path\n    ) {\n      query.fields.path = `${datasource.config.url}/${path ? path : \"\"}`\n    }\n    url = buildUrl(query.fields.path, breakQs)\n    schema = restUtils.schemaToFields(query.schema)\n    requestBindings = restUtils.queryParametersToKeyValue(query.parameters)\n    authConfigId = getAuthConfigId()\n    if (!query.fields.disabledHeaders) {\n      query.fields.disabledHeaders = {}\n    }\n    // make sure the disabled headers are set (migration)\n    for (let header of Object.keys(query.fields.headers)) {\n      if (!query.fields.disabledHeaders[header]) {\n        query.fields.disabledHeaders[header] = false\n      }\n    }\n    enabledHeaders = restUtils.flipHeaderState(query.fields.disabledHeaders)\n    if (query && !query.transformer) {\n      query.transformer = \"return data\"\n    }\n    if (query && !query.flags) {\n      query.flags = {\n        urlName: false,\n      }\n    }\n    if (query && !query.fields.bodyType) {\n      if (query.fields.requestBody) {\n        query.fields.bodyType = RawRestBodyTypes.JSON\n      } else {\n        query.fields.bodyType = RawRestBodyTypes.NONE\n      }\n    }\n    if (query && !query.fields.pagination) {\n      query.fields.pagination = {}\n    }\n    dynamicVariables = getDynamicVariables(\n      datasource,\n      query._id,\n      (variable, queryId) => variable.queryId === queryId\n    )\n    globalDynamicBindings = getDynamicVariables(\n      datasource,\n      query._id,\n      (variable, queryId) => variable.queryId !== queryId\n    )\n\n    prettifyQueryRequestBody(\n      query,\n      requestBindings,\n      globalDynamicBindings,\n      staticVariables,\n      restBindings\n    )\n  })\n</script>\n\n<DynamicVariableModal\n  {datasource}\n  {dynamicVariables}\n  bind:binding={varBinding}\n  bind:this={addVariableModal}\n  on:change={saveQuery}\n/>\n{#if query && queryConfig}\n  <div class=\"inner\">\n    <div class=\"top\">\n      <Layout gap=\"S\">\n        <div class=\"top-bar\">\n          <EditableLabel\n            type=\"heading\"\n            bind:value={query.name}\n            defaultValue=\"Untitled\"\n            on:change={() => (query.flags.urlName = false)}\n            on:save={saveQuery}\n          />\n          <div class=\"access\">\n            <Label>Access level</Label>\n            <AccessLevelSelect {query} {saveId} />\n          </div>\n        </div>\n        <div class=\"url-block\">\n          <div class=\"verb\">\n            <Select\n              bind:value={query.queryVerb}\n              on:change={() => {}}\n              options={Object.keys(queryConfig)}\n              getOptionLabel={verb =>\n                queryConfig[verb]?.displayName || capitalise(verb)}\n            />\n          </div>\n          <div class=\"url\">\n            <Input\n              on:blur={urlChanged}\n              bind:value={url}\n              placeholder=\"http://www.api.com/endpoint\"\n            />\n          </div>\n          <Button primary disabled={!url} on:click={runQuery}>Send</Button>\n          <Button\n            disabled={!query.name}\n            cta\n            on:click={saveQuery}\n            tooltip={!hasSchema\n              ? \"Saving a query before sending will mean no schema is generated\"\n              : null}>Save</Button\n          >\n        </div>\n        <Tabs selected=\"Bindings\" quiet noPadding noHorizPadding onTop>\n          <Tab title=\"Bindings\">\n            <KeyValueBuilder\n              bind:object={requestBindings}\n              tooltip=\"Set the name of the binding which can be used in Handlebars statements throughout your query\"\n              name=\"binding\"\n              headings\n              keyPlaceholder=\"Binding name\"\n              valuePlaceholder=\"Default\"\n              bindings={[\n                ...restBindings,\n                ...globalDynamicRequestBindings,\n                ...dataSourceStaticBindings,\n              ]}\n              bindingDrawerLeft=\"260px\"\n            />\n          </Tab>\n          <Tab title=\"Params\">\n            {#key breakQs}\n              <KeyValueBuilder\n                on:change={paramsChanged}\n                object={breakQs}\n                name=\"param\"\n                headings\n                bindings={mergedBindings}\n                bindingDrawerLeft=\"260px\"\n              />\n            {/key}\n          </Tab>\n          <Tab title=\"Headers\">\n            <KeyValueBuilder\n              bind:object={query.fields.headers}\n              bind:activity={enabledHeaders}\n              toggle\n              name=\"header\"\n              headings\n              bindings={mergedBindings}\n              bindingDrawerLeft=\"260px\"\n            />\n          </Tab>\n          <Tab title=\"Body\">\n            <RadioGroup\n              bind:value={query.fields.bodyType}\n              options={isGet ? [bodyTypes[0]] : bodyTypes}\n              direction=\"horizontal\"\n              getOptionLabel={option => option.name}\n              getOptionValue={option => option.value}\n            />\n            <RestBodyInput bind:bodyType={query.fields.bodyType} bind:query />\n          </Tab>\n          <Tab title=\"Pagination\">\n            <div class=\"pagination\">\n              <Select\n                label=\"Pagination type\"\n                bind:value={query.fields.pagination.type}\n                options={PaginationTypes}\n                placeholder=\"None\"\n              />\n              {#if query.fields.pagination.type}\n                <Select\n                  label=\"Pagination parameters location\"\n                  bind:value={query.fields.pagination.location}\n                  options={PaginationLocations}\n                  placeholer=\"Choose where to send pagination parameters\"\n                />\n                <Input\n                  label={query.fields.pagination.type === \"page\"\n                    ? \"Page number parameter name \"\n                    : \"Request cursor parameter name\"}\n                  bind:value={query.fields.pagination.pageParam}\n                />\n                <Input\n                  label={query.fields.pagination.type === \"page\"\n                    ? \"Page size parameter name\"\n                    : \"Request limit parameter name\"}\n                  bind:value={query.fields.pagination.sizeParam}\n                />\n                {#if query.fields.pagination.type === \"cursor\"}\n                  <Input\n                    label=\"Response body parameter name for cursor\"\n                    bind:value={query.fields.pagination.responseParam}\n                  />\n                {/if}\n              {/if}\n            </div>\n          </Tab>\n          <Tab title=\"Transformer\">\n            <Layout noPadding>\n              {#if !$flags.queryTransformerBanner}\n                <Banner\n                  extraButtonText=\"Learn more\"\n                  extraButtonAction={() =>\n                    window.open(\"https://docs.budibase.com/docs/transformers\")}\n                  on:change={() => updateFlag(\"queryTransformerBanner\", true)}\n                >\n                  Add a JavaScript function to transform the query result.\n                </Banner>\n              {/if}\n              <CodeMirrorEditor\n                height={200}\n                mode={EditorModes.JSON}\n                value={query.transformer}\n                resize=\"vertical\"\n                on:change={e => (query.transformer = e.detail)}\n              />\n            </Layout>\n          </Tab>\n          <div class=\"auth-container\">\n            <div />\n            <!-- spacer -->\n            <div class=\"auth-select\">\n              <Select\n                label=\"Auth\"\n                labelPosition=\"left\"\n                placeholder=\"None\"\n                bind:value={authConfigId}\n                options={authConfigs}\n              />\n            </div>\n          </div>\n        </Tabs>\n      </Layout>\n    </div>\n    <div class=\"bottom\">\n      <Layout paddingY=\"S\" gap=\"S\">\n        <Divider size=\"S\" />\n        {#if !response && Object.keys(schema).length === 0}\n          <Heading size=\"M\">Response</Heading>\n          <div class=\"placeholder\">\n            <div class=\"placeholder-internal\">\n              <img alt=\"placeholder\" src={Placeholder} />\n              <Body size=\"XS\" textAlign=\"center\"\n                >{\"enter a url in the textbox above and click send to get a response\".toUpperCase()}</Body\n              >\n            </div>\n          </div>\n        {:else}\n          <Tabs\n            selected={!response ? \"Schema\" : \"JSON\"}\n            quiet\n            noPadding\n            noHorizPadding\n          >\n            {#if response}\n              <Tab title=\"JSON\">\n                <div>\n                  <JSONPreview height=\"300\" data={response.rows[0]} />\n                </div>\n              </Tab>\n            {/if}\n            {#if schema || response}\n              <Tab title=\"Schema\">\n                <KeyValueBuilder\n                  bind:object={schema}\n                  name=\"schema\"\n                  headings\n                  options={SchemaTypeOptions}\n                  menuItems={schemaMenuItems}\n                  showMenu={!schemaReadOnly}\n                  readOnly={schemaReadOnly}\n                />\n              </Tab>\n            {/if}\n            {#if response}\n              <Tab title=\"Raw\">\n                <TextArea disabled value={response.extra?.raw} height=\"300\" />\n              </Tab>\n              <Tab title=\"Headers\">\n                <KeyValueBuilder\n                  object={response.extra?.headers}\n                  readOnly\n                  menuItems={responseHeadersMenuItems}\n                  showMenu={true}\n                />\n              </Tab>\n              <Tab title=\"Preview\">\n                <div class=\"table\">\n                  {#if response}\n                    <Table\n                      schema={response?.schema}\n                      data={response?.rows}\n                      allowEditColumns={false}\n                      allowEditRows={false}\n                      allowSelectRows={false}\n                    />\n                  {/if}\n                </div>\n              </Tab>\n            {/if}\n            {#if showVariablesTab}\n              <Tab title=\"Dynamic Variables\">\n                <Layout noPadding gap=\"S\">\n                  <Body size=\"S\">\n                    Create dynamic variables based on response body or headers\n                    from this query.\n                  </Body>\n                  <KeyValueBuilder\n                    bind:object={dynamicVariables}\n                    name=\"Variable\"\n                    headings\n                    keyHeading=\"Name\"\n                    keyPlaceholder=\"Variable name\"\n                    valueHeading={`Value`}\n                    valuePlaceholder={`{{ value }}`}\n                    readOnly={variablesReadOnly}\n                  />\n                </Layout>\n              </Tab>\n            {/if}\n            {#if response}\n              <div class=\"stats\">\n                <Label size=\"L\">\n                  Status: <span class={responseSuccess ? \"green\" : \"red\"}\n                    >{response?.info.code}</span\n                  >\n                </Label>\n                <Label size=\"L\">\n                  Time: <span class={responseSuccess ? \"green\" : \"red\"}\n                    >{response?.info.time}</span\n                  >\n                </Label>\n                <Label size=\"L\">\n                  Size: <span class={responseSuccess ? \"green\" : \"red\"}\n                    >{response?.info.size}</span\n                  >\n                </Label>\n              </div>\n            {/if}\n          </Tabs>\n        {/if}\n      </Layout>\n    </div>\n  </div>\n{/if}\n\n<style>\n  .inner {\n    width: 960px;\n    margin: 0 auto;\n    height: 100%;\n  }\n  .table {\n    width: 960px;\n  }\n  .url-block {\n    display: flex;\n    gap: var(--spacing-s);\n  }\n  .verb {\n    flex: 1;\n  }\n  .url {\n    flex: 4;\n  }\n  .top {\n    min-height: 50%;\n  }\n  .bottom {\n    padding-bottom: 50px;\n  }\n  .stats {\n    display: flex;\n    gap: var(--spacing-xl);\n    margin-left: auto !important;\n    margin-right: 0;\n    align-items: center;\n  }\n  .green {\n    color: #53a761;\n  }\n  .red {\n    color: #ea7d82;\n  }\n  .top-bar {\n    display: flex;\n    justify-content: space-between;\n  }\n  .access {\n    display: flex;\n    gap: var(--spacing-m);\n    align-items: center;\n  }\n  .placeholder-internal {\n    display: flex;\n    flex-direction: column;\n    width: 200px;\n    gap: var(--spacing-l);\n  }\n  .placeholder {\n    display: flex;\n    margin-top: var(--spacing-xl);\n    justify-content: center;\n  }\n  .auth-container {\n    width: 100%;\n    display: flex;\n    justify-content: space-between;\n  }\n  .auth-select {\n    width: 200px;\n  }\n  .pagination {\n    display: grid;\n    grid-template-columns: 1fr 1fr;\n    gap: var(--spacing-m);\n  }\n</style>\n", "const {\n  getGlobalDB,\n  getTenantId,\n  isUserInAppTenant,\n} = require(\"@budibase/backend-core/tenancy\")\nconst { generateDevInfoID, SEPARATOR } = require(\"@budibase/backend-core/db\")\nconst { user: userCache } = require(\"@budibase/backend-core/cache\")\nconst {\n  hash,\n  platformLogout,\n  getCookie,\n  clearCookie,\n} = require(\"@budibase/backend-core/utils\")\nconst { encrypt } = require(\"@budibase/backend-core/encryption\")\nconst { newid } = require(\"@budibase/backend-core/utils\")\nconst { users } = require(\"../../../sdk\")\nconst { Cookies } = require(\"@budibase/backend-core/constants\")\nconst { events, featureFlags } = require(\"@budibase/backend-core\")\n\nfunction newApiKey() {\n  return encrypt(`${getTenantId()}${SEPARATOR}${newid()}`)\n}\n\nfunction cleanupDevInfo(info) {\n  // user doesn't need to aware of dev doc info\n  delete info._id\n  delete info._rev\n  return info\n}\n\nexports.generateAPIKey = async ctx => {\n  const db = getGlobalDB()\n  const id = generateDevInfoID(ctx.user._id)\n  let devInfo\n  try {\n    devInfo = await db.get(id)\n  } catch (err) {\n    devInfo = { _id: id, userId: ctx.user._id }\n  }\n  devInfo.apiKey = await newApiKey()\n  await db.put(devInfo)\n  ctx.body = cleanupDevInfo(devInfo)\n}\n\nexports.fetchAPIKey = async ctx => {\n  const db = getGlobalDB()\n  const id = generateDevInfoID(ctx.user._id)\n  let devInfo\n  try {\n    devInfo = await db.get(id)\n  } catch (err) {\n    devInfo = {\n      _id: id,\n      userId: ctx.user._id,\n      apiKey: await newApiKey(),\n    }\n    await db.put(devInfo)\n  }\n  ctx.body = cleanupDevInfo(devInfo)\n}\n\nconst checkCurrentApp = ctx => {\n  const appCookie = getCookie(ctx, Cookies.CurrentApp)\n  if (appCookie && !isUserInAppTenant(appCookie.appId)) {\n    // there is a currentapp cookie from another tenant\n    // remove the cookie as this is incompatible with the builder\n    // due to builder and admin permissions being removed\n    clearCookie(ctx, Cookies.CurrentApp)\n  }\n}\n\n/**\n * Add the attributes that are session based to the current user.\n */\nconst addSessionAttributesToUser = ctx => {\n  ctx.body.account = ctx.user.account\n  ctx.body.license = ctx.user.license\n  ctx.body.budibaseAccess = !!ctx.user.budibaseAccess\n  ctx.body.accountPortalAccess = !!ctx.user.accountPortalAccess\n  ctx.body.csrfToken = ctx.user.csrfToken\n}\n\n/**\n * Remove the attributes that are session based from the current user,\n * so that stale values are not written to the db\n */\nconst removeSessionAttributesFromUser = ctx => {\n  delete ctx.request.body.csrfToken\n  delete ctx.request.body.account\n  delete ctx.request.body.accountPortalAccess\n  delete ctx.request.body.budibaseAccess\n  delete ctx.request.body.license\n}\n\nexports.getSelf = async ctx => {\n  if (!ctx.user) {\n    ctx.throw(403, \"User not logged in\")\n  }\n  const userId = ctx.user._id\n  ctx.params = {\n    id: userId,\n  }\n\n  checkCurrentApp(ctx)\n\n  // get the main body of the user\n  ctx.body = await users.getUser(userId)\n\n  // add the feature flags for this tenant\n  const tenantId = getTenantId()\n  ctx.body.featureFlags = featureFlags.getTenantFeatureFlags(tenantId)\n\n  addSessionAttributesToUser(ctx)\n}\n\nexports.updateSelf = async ctx => {\n  const db = getGlobalDB()\n  const user = await db.get(ctx.user._id)\n  let passwordChange = false\n  if (ctx.request.body.password) {\n    // changing password\n    passwordChange = true\n    ctx.request.body.password = await hash(ctx.request.body.password)\n    // Log all other sessions out apart from the current one\n    await platformLogout({\n      ctx,\n      userId: ctx.user._id,\n      keepActiveSession: true,\n    })\n  }\n  // don't allow sending up an ID/Rev, always use the existing one\n  delete ctx.request.body._id\n  delete ctx.request.body._rev\n  removeSessionAttributesFromUser(ctx)\n\n  const response = await db.put({\n    ...user,\n    ...ctx.request.body,\n  })\n  await userCache.invalidateUser(user._id)\n  ctx.body = {\n    _id: response.id,\n    _rev: response.rev,\n  }\n\n  // remove the old password from the user before sending events\n  delete user.password\n  await events.user.updated(user)\n  if (passwordChange) {\n    await events.user.passwordUpdated(user)\n  }\n}\n", "import { checkInviteCode } from \"../../../utilities/redis\"\nimport { users } from \"../../../sdk\"\nimport env from \"../../../environment\"\nimport {\n  BulkDeleteUsersRequest,\n  CloudAccount,\n  InviteUserRequest,\n  InviteUsersRequest,\n  User,\n} from \"@budibase/types\"\nimport {\n  accounts,\n  cache,\n  errors,\n  events,\n  tenancy,\n  users as usersCore,\n} from \"@budibase/backend-core\"\nimport { checkAnyUserExists } from \"../../../utilities/users\"\nimport { groups as groupUtils } from \"@budibase/pro\"\n\nconst MAX_USERS_UPLOAD_LIMIT = 1000\n\nexport const save = async (ctx: any) => {\n  try {\n    ctx.body = await users.save(ctx.request.body)\n  } catch (err: any) {\n    ctx.throw(err.status || 400, err)\n  }\n}\n\nexport const bulkCreate = async (ctx: any) => {\n  let { users: newUsersRequested, groups } = ctx.request.body\n\n  if (!env.SELF_HOSTED && newUsersRequested.length > MAX_USERS_UPLOAD_LIMIT) {\n    ctx.throw(\n      400,\n      \"Max limit for upload is 1000 users. Please reduce file size and try again.\"\n    )\n  }\n\n  const db = tenancy.getGlobalDB()\n  let groupsToSave: any[] = []\n\n  if (groups.length) {\n    for (const groupId of groups) {\n      let oldGroup = await db.get(groupId)\n      groupsToSave.push(oldGroup)\n    }\n  }\n\n  try {\n    const response = await users.bulkCreate(newUsersRequested, groups)\n    await groupUtils.bulkSaveGroupUsers(groupsToSave, response.successful)\n\n    ctx.body = response\n  } catch (err: any) {\n    ctx.throw(err.status || 400, err)\n  }\n}\n\nconst parseBooleanParam = (param: any) => {\n  return !(param && param === \"false\")\n}\n\nexport const adminUser = async (ctx: any) => {\n  const { email, password, tenantId } = ctx.request.body\n  await tenancy.doInTenant(tenantId, async () => {\n    // account portal sends a pre-hashed password - honour param to prevent double hashing\n    const hashPassword = parseBooleanParam(ctx.request.query.hashPassword)\n    // account portal sends no password for SSO users\n    const requirePassword = parseBooleanParam(ctx.request.query.requirePassword)\n\n    if (await tenancy.doesTenantExist(tenantId)) {\n      ctx.throw(403, \"Organisation already exists.\")\n    }\n\n    const userExists = await checkAnyUserExists()\n    if (userExists) {\n      ctx.throw(\n        403,\n        \"You cannot initialise once an global user has been created.\"\n      )\n    }\n\n    const user: User = {\n      email: email,\n      password: password,\n      createdAt: Date.now(),\n      roles: {},\n      builder: {\n        global: true,\n      },\n      admin: {\n        global: true,\n      },\n      tenantId,\n    }\n    try {\n      // always bust checklist beforehand, if an error occurs but can proceed, don't get\n      // stuck in a cycle\n      await cache.bustCache(cache.CacheKeys.CHECKLIST)\n      const finalUser = await users.save(user, {\n        hashPassword,\n        requirePassword,\n      })\n\n      // events\n      let account: CloudAccount | undefined\n      if (!env.SELF_HOSTED && !env.DISABLE_ACCOUNT_PORTAL) {\n        account = await accounts.getAccountByTenantId(tenantId)\n      }\n      await events.identification.identifyTenantGroup(tenantId, account)\n\n      ctx.body = finalUser\n    } catch (err: any) {\n      ctx.throw(err.status || 400, err)\n    }\n  })\n}\n\nexport const countByApp = async (ctx: any) => {\n  const appId = ctx.params.appId\n  try {\n    ctx.body = await users.countUsersByApp(appId)\n  } catch (err: any) {\n    ctx.throw(err.status || 400, err)\n  }\n}\n\nexport const destroy = async (ctx: any) => {\n  const id = ctx.params.id\n  if (id === ctx.user._id) {\n    ctx.throw(400, \"Unable to delete self.\")\n  }\n\n  await users.destroy(id, ctx.user)\n\n  ctx.body = {\n    message: `User ${id} deleted.`,\n  }\n}\n\nexport const bulkDelete = async (ctx: any) => {\n  const { userIds } = ctx.request.body as BulkDeleteUsersRequest\n  if (userIds?.indexOf(ctx.user._id) !== -1) {\n    ctx.throw(400, \"Unable to delete self.\")\n  }\n\n  try {\n    let response = await users.bulkDelete(userIds)\n\n    ctx.body = response\n  } catch (err) {\n    ctx.throw(err)\n  }\n}\n\nexport const search = async (ctx: any) => {\n  const paginated = await users.paginatedUsers(ctx.request.body)\n  // user hashed password shouldn't ever be returned\n  for (let user of paginated.data) {\n    if (user) {\n      delete user.password\n    }\n  }\n  ctx.body = paginated\n}\n\n// called internally by app server user fetch\nexport const fetch = async (ctx: any) => {\n  const all = await users.allUsers()\n  // user hashed password shouldn't ever be returned\n  for (let user of all) {\n    if (user) {\n      delete user.password\n    }\n  }\n  ctx.body = all\n}\n\n// called internally by app server user find\nexport const find = async (ctx: any) => {\n  ctx.body = await users.getUser(ctx.params.id)\n}\n\nexport const tenantUserLookup = async (ctx: any) => {\n  const id = ctx.params.id\n  const user = await tenancy.getTenantUser(id)\n  if (user) {\n    ctx.body = user\n  } else {\n    ctx.throw(400, \"No tenant user found.\")\n  }\n}\n\nexport const invite = async (ctx: any) => {\n  const request = ctx.request.body as InviteUserRequest\n  const response = await users.invite([request])\n\n  // explicitly throw for single user invite\n  if (response.unsuccessful.length) {\n    const reason = response.unsuccessful[0].reason\n    if (reason === \"Unavailable\") {\n      ctx.throw(400, reason)\n    } else {\n      ctx.throw(500, reason)\n    }\n  }\n\n  ctx.body = {\n    message: \"Invitation has been sent.\",\n  }\n}\n\nexport const inviteMultiple = async (ctx: any) => {\n  const request = ctx.request.body as InviteUsersRequest\n  ctx.body = await users.invite(request)\n}\n\nexport const inviteAccept = async (ctx: any) => {\n  const { inviteCode, password, firstName, lastName } = ctx.request.body\n  try {\n    // info is an extension of the user object that was stored by global\n    const { email, info }: any = await checkInviteCode(inviteCode)\n    ctx.body = await tenancy.doInTenant(info.tenantId, async () => {\n      const saved = await users.save({\n        firstName,\n        lastName,\n        password,\n        email,\n        ...info,\n      })\n      const db = tenancy.getGlobalDB()\n      const user = await db.get(saved._id)\n      await events.user.inviteAccepted(user)\n      return saved\n    })\n  } catch (err: any) {\n    if (err.code === errors.codes.USAGE_LIMIT_EXCEEDED) {\n      // explicitly re-throw limit exceeded errors\n      ctx.throw(400, err)\n    }\n    ctx.throw(400, \"Unable to create new user, invitation invalid.\")\n  }\n}\n"], "fixing_code": ["<script>\n  import Tooltip from \"./Tooltip.svelte\"\n  import Icon from \"../Icon/Icon.svelte\"\n\n  export let tooltip = \"\"\n  export let size = \"M\"\n\n  let showTooltip = false\n</script>\n\n<div class:container={!!tooltip}>\n  <slot />\n  {#if tooltip}\n    <div class=\"icon-container\">\n      <div\n        class=\"icon\"\n        class:icon-small={size === \"M\" || size === \"S\"}\n        on:mouseover={() => (showTooltip = true)}\n        on:mouseleave={() => (showTooltip = false)}\n        on:focus\n      >\n        <Icon name=\"InfoOutline\" size=\"S\" disabled={true} />\n      </div>\n      {#if showTooltip}\n        <div class=\"tooltip\">\n          <Tooltip textWrapping={true} direction={\"bottom\"} text={tooltip} />\n        </div>\n      {/if}\n    </div>\n  {/if}\n</div>\n\n<style>\n  .container {\n    display: flex;\n    align-items: center;\n  }\n  .icon-container {\n    position: relative;\n    display: flex;\n    justify-content: center;\n    margin-left: 5px;\n    margin-right: 5px;\n  }\n  .tooltip {\n    position: absolute;\n    display: flex;\n    justify-content: center;\n    top: 15px;\n    z-index: 200;\n    width: 160px;\n  }\n  .icon {\n    transform: scale(0.75);\n  }\n  .icon-small {\n    margin-top: -2px;\n    margin-bottom: -5px;\n  }\n</style>\n", "import { cloneDeep } from \"lodash/fp\"\nimport { get } from \"svelte/store\"\nimport {\n  findAllMatchingComponents,\n  findComponent,\n  findComponentPath,\n  getComponentSettings,\n} from \"./componentUtils\"\nimport { store } from \"builderStore\"\nimport {\n  queries as queriesStores,\n  roles as rolesStore,\n  tables as tablesStore,\n} from \"stores/backend\"\nimport {\n  decodeJSBinding,\n  encodeJSBinding,\n  isJSBinding,\n  makePropSafe,\n} from \"@budibase/string-templates\"\nimport { TableNames } from \"../constants\"\nimport { JSONUtils } from \"@budibase/frontend-core\"\nimport ActionDefinitions from \"components/design/settings/controls/ButtonActionEditor/manifest.json\"\n\n// Regex to match all instances of template strings\nconst CAPTURE_VAR_INSIDE_TEMPLATE = /{{([^}]+)}}/g\nconst CAPTURE_VAR_INSIDE_JS = /\\$\\(\"([^\")]+)\"\\)/g\nconst CAPTURE_HBS_TEMPLATE = /{{[\\S\\s]*?}}/g\n\n/**\n * Gets all bindable data context fields and instance fields.\n */\nexport const getBindableProperties = (asset, componentId) => {\n  const contextBindings = getContextBindings(asset, componentId)\n  const userBindings = getUserBindings()\n  const urlBindings = getUrlBindings(asset)\n  const deviceBindings = getDeviceBindings()\n  const stateBindings = getStateBindings()\n  const selectedRowsBindings = getSelectedRowsBindings(asset)\n  const roleBindings = getRoleBindings()\n  return [\n    ...contextBindings,\n    ...urlBindings,\n    ...stateBindings,\n    ...userBindings,\n    ...deviceBindings,\n    ...selectedRowsBindings,\n    ...roleBindings,\n  ]\n}\n\n/**\n * Gets all rest bindable data fields\n */\nexport const getRestBindings = () => {\n  const userBindings = getUserBindings()\n  return [...userBindings, ...getAuthBindings()]\n}\n\n/**\n * Gets all rest bindable auth fields\n */\nexport const getAuthBindings = () => {\n  let bindings = []\n  const safeUser = makePropSafe(\"user\")\n  const safeOAuth2 = makePropSafe(\"oauth2\")\n  const safeAccessToken = makePropSafe(\"accessToken\")\n\n  const authBindings = [\n    {\n      runtime: `${safeUser}.${safeOAuth2}.${safeAccessToken}`,\n      readable: `Current User.OAuthToken`,\n      key: \"accessToken\",\n    },\n  ]\n\n  bindings = Object.keys(authBindings).map(key => {\n    const fieldBinding = authBindings[key]\n    return {\n      type: \"context\",\n      runtimeBinding: fieldBinding.runtime,\n      readableBinding: fieldBinding.readable,\n      fieldSchema: { type: \"string\", name: fieldBinding.key },\n      providerId: \"user\",\n    }\n  })\n  return bindings\n}\n\n/**\n * Utility - convert a key/value map to an array of custom 'context' bindings\n * @param {object} valueMap Key/value pairings\n * @param {string} prefix A contextual string prefix/path for a user readable binding\n * @return {object[]} An array containing readable/runtime binding objects\n */\nexport const toBindingsArray = (valueMap, prefix) => {\n  if (!valueMap) {\n    return []\n  }\n  return Object.keys(valueMap).reduce((acc, binding) => {\n    if (!binding || !valueMap[binding]) {\n      return acc\n    }\n    acc.push({\n      type: \"context\",\n      runtimeBinding: binding,\n      readableBinding: `${prefix}.${binding}`,\n    })\n    return acc\n  }, [])\n}\n\n/**\n * Utility - coverting a map of readable bindings to runtime\n */\nexport const readableToRuntimeMap = (bindings, ctx) => {\n  if (!bindings || !ctx) {\n    return {}\n  }\n  return Object.keys(ctx).reduce((acc, key) => {\n    acc[key] = readableToRuntimeBinding(bindings, ctx[key])\n    return acc\n  }, {})\n}\n\n/**\n * Utility - coverting a map of runtime bindings to readable\n */\nexport const runtimeToReadableMap = (bindings, ctx) => {\n  if (!bindings || !ctx) {\n    return {}\n  }\n  return Object.keys(ctx).reduce((acc, key) => {\n    acc[key] = runtimeToReadableBinding(bindings, ctx[key])\n    return acc\n  }, {})\n}\n\n/**\n * Gets the bindable properties exposed by a certain component.\n */\nexport const getComponentBindableProperties = (asset, componentId) => {\n  if (!asset || !componentId) {\n    return []\n  }\n\n  // Ensure that the component exists and exposes context\n  const component = findComponent(asset.props, componentId)\n  const def = store.actions.components.getDefinition(component?._component)\n  if (!def?.context) {\n    return []\n  }\n\n  // Get the bindings for the component\n  return getProviderContextBindings(asset, component)\n}\n\n/**\n * Gets all data provider components above a component.\n */\nexport const getContextProviderComponents = (asset, componentId, type) => {\n  if (!asset || !componentId) {\n    return []\n  }\n\n  // Get the component tree leading up to this component, ignoring the component\n  // itself\n  const path = findComponentPath(asset.props, componentId)\n  path.pop()\n\n  // Filter by only data provider components\n  return path.filter(component => {\n    const def = store.actions.components.getDefinition(component._component)\n    if (!def?.context) {\n      return false\n    }\n\n    // If no type specified, return anything that exposes context\n    if (!type) {\n      return true\n    }\n\n    // Otherwise only match components with the specific context type\n    const contexts = Array.isArray(def.context) ? def.context : [def.context]\n    return contexts.find(context => context.type === type) != null\n  })\n}\n\n/**\n * Gets all data provider components above a component.\n */\nexport const getActionProviderComponents = (asset, componentId, actionType) => {\n  if (!asset || !componentId) {\n    return []\n  }\n\n  // Get the component tree leading up to this component, ignoring the component\n  // itself\n  const path = findComponentPath(asset.props, componentId)\n  path.pop()\n\n  // Filter by only data provider components\n  return path.filter(component => {\n    const def = store.actions.components.getDefinition(component._component)\n    return def?.actions?.includes(actionType)\n  })\n}\n\n/**\n * Gets a datasource object for a certain data provider component\n */\nexport const getDatasourceForProvider = (asset, component) => {\n  const settings = getComponentSettings(component?._component)\n\n  // If this component has a dataProvider setting, go up the stack and use it\n  const dataProviderSetting = settings.find(setting => {\n    return setting.type === \"dataProvider\"\n  })\n  if (dataProviderSetting) {\n    const settingValue = component[dataProviderSetting.key]\n    const providerId = extractLiteralHandlebarsID(settingValue)\n    const provider = findComponent(asset?.props, providerId)\n    return getDatasourceForProvider(asset, provider)\n  }\n\n  // Extract datasource from component instance\n  const validSettingTypes = [\"dataSource\", \"table\", \"schema\"]\n  const datasourceSetting = settings.find(setting => {\n    return validSettingTypes.includes(setting.type)\n  })\n  if (!datasourceSetting) {\n    return null\n  }\n\n  // There are different types of setting which can be a datasource, for\n  // example an actual datasource object, or a table ID string.\n  // Convert the datasource setting into a proper datasource object so that\n  // we can use it properly\n  if (datasourceSetting.type === \"table\") {\n    return {\n      tableId: component[datasourceSetting?.key],\n      type: \"table\",\n    }\n  } else {\n    return component[datasourceSetting?.key]\n  }\n}\n\n/**\n * Gets all bindable data properties from component data contexts.\n */\nconst getContextBindings = (asset, componentId) => {\n  // Extract any components which provide data contexts\n  const dataProviders = getContextProviderComponents(asset, componentId)\n\n  // Generate bindings for all matching components\n  return getProviderContextBindings(asset, dataProviders)\n}\n\n/**\n * Gets the context bindings exposed by a set of data provider components.\n */\nconst getProviderContextBindings = (asset, dataProviders) => {\n  if (!asset || !dataProviders) {\n    return []\n  }\n\n  // Ensure providers is an array\n  if (!Array.isArray(dataProviders)) {\n    dataProviders = [dataProviders]\n  }\n\n  // Create bindings for each data provider\n  let bindings = []\n  dataProviders.forEach(component => {\n    const def = store.actions.components.getDefinition(component._component)\n    const contexts = Array.isArray(def.context) ? def.context : [def.context]\n\n    // Create bindings for each context block provided by this data provider\n    contexts.forEach(context => {\n      if (!context?.type) {\n        return\n      }\n\n      let schema\n      let table\n      let readablePrefix\n      let runtimeSuffix = context.suffix\n\n      if (context.type === \"form\") {\n        // Forms do not need table schemas\n        // Their schemas are built from their component field names\n        schema = buildFormSchema(component)\n        readablePrefix = \"Fields\"\n      } else if (context.type === \"static\") {\n        // Static contexts are fully defined by the components\n        schema = {}\n        const values = context.values || []\n        values.forEach(value => {\n          schema[value.key] = { name: value.label, type: \"string\" }\n        })\n      } else if (context.type === \"schema\") {\n        // Schema contexts are generated dynamically depending on their data\n        const datasource = getDatasourceForProvider(asset, component)\n        if (!datasource) {\n          return\n        }\n        const info = getSchemaForDatasource(asset, datasource)\n        schema = info.schema\n        table = info.table\n\n        // For JSON arrays, use the array name as the readable prefix.\n        // Otherwise use the table name\n        if (datasource.type === \"jsonarray\") {\n          const split = datasource.label.split(\".\")\n          readablePrefix = split[split.length - 1]\n        } else {\n          readablePrefix = info.table?.name\n        }\n      }\n      if (!schema) {\n        return\n      }\n\n      const keys = Object.keys(schema).sort()\n\n      // Generate safe unique runtime prefix\n      let providerId = component._id\n      if (runtimeSuffix) {\n        providerId += `-${runtimeSuffix}`\n      }\n      const safeComponentId = makePropSafe(providerId)\n\n      // Create bindable properties for each schema field\n      keys.forEach(key => {\n        const fieldSchema = schema[key]\n\n        // Make safe runtime binding\n        const safeKey = key.split(\".\").map(makePropSafe).join(\".\")\n        const runtimeBinding = `${safeComponentId}.${safeKey}`\n\n        // Optionally use a prefix with readable bindings\n        let readableBinding = component._instanceName\n        if (readablePrefix) {\n          readableBinding += `.${readablePrefix}`\n        }\n        readableBinding += `.${fieldSchema.name || key}`\n\n        // Create the binding object\n        bindings.push({\n          type: \"context\",\n          runtimeBinding,\n          readableBinding,\n          // Field schema and provider are required to construct relationship\n          // datasource options, based on bindable properties\n          fieldSchema,\n          providerId,\n          // Table ID is used by JSON fields to know what table the field is in\n          tableId: table?._id,\n        })\n      })\n    })\n  })\n\n  return bindings\n}\n\n/**\n * Gets all bindable properties from the logged in user.\n */\nexport const getUserBindings = () => {\n  let bindings = []\n  const { schema } = getSchemaForTable(TableNames.USERS)\n  const keys = Object.keys(schema).sort()\n  const safeUser = makePropSafe(\"user\")\n  keys.forEach(key => {\n    const fieldSchema = schema[key]\n    bindings.push({\n      type: \"context\",\n      runtimeBinding: `${safeUser}.${makePropSafe(key)}`,\n      readableBinding: `Current User.${key}`,\n      // Field schema and provider are required to construct relationship\n      // datasource options, based on bindable properties\n      fieldSchema,\n      providerId: \"user\",\n    })\n  })\n  return bindings\n}\n\n/**\n * Gets all device bindings that are globally available.\n */\nconst getDeviceBindings = () => {\n  let bindings = []\n  if (get(store).clientFeatures?.deviceAwareness) {\n    const safeDevice = makePropSafe(\"device\")\n    bindings.push({\n      type: \"context\",\n      runtimeBinding: `${safeDevice}.${makePropSafe(\"mobile\")}`,\n      readableBinding: `Device.Mobile`,\n    })\n    bindings.push({\n      type: \"context\",\n      runtimeBinding: `${safeDevice}.${makePropSafe(\"tablet\")}`,\n      readableBinding: `Device.Tablet`,\n    })\n  }\n  return bindings\n}\n\n/**\n * Gets all selected rows bindings for tables in the current asset.\n */\nconst getSelectedRowsBindings = asset => {\n  let bindings = []\n  if (get(store).clientFeatures?.rowSelection) {\n    // Add bindings for table components\n    let tables = findAllMatchingComponents(asset?.props, component =>\n      component._component.endsWith(\"table\")\n    )\n    const safeState = makePropSafe(\"rowSelection\")\n    bindings = bindings.concat(\n      tables.map(table => ({\n        type: \"context\",\n        runtimeBinding: `${safeState}.${makePropSafe(table._id)}.${makePropSafe(\n          \"selectedRows\"\n        )}`,\n        readableBinding: `${table._instanceName}.Selected rows`,\n      }))\n    )\n\n    // Add bindings for table blocks\n    let tableBlocks = findAllMatchingComponents(asset?.props, component =>\n      component._component.endsWith(\"tableblock\")\n    )\n    bindings = bindings.concat(\n      tableBlocks.map(block => ({\n        type: \"context\",\n        runtimeBinding: `${safeState}.${makePropSafe(\n          block._id + \"-table\"\n        )}.${makePropSafe(\"selectedRows\")}`,\n        readableBinding: `${block._instanceName}.Selected rows`,\n      }))\n    )\n  }\n  return bindings\n}\n\n/**\n * Gets all state bindings that are globally available.\n */\nconst getStateBindings = () => {\n  let bindings = []\n  if (get(store).clientFeatures?.state) {\n    const safeState = makePropSafe(\"state\")\n    bindings = getAllStateVariables().map(key => ({\n      type: \"context\",\n      runtimeBinding: `${safeState}.${makePropSafe(key)}`,\n      readableBinding: `State.${key}`,\n    }))\n  }\n  return bindings\n}\n\n/**\n * Gets all bindable properties from URL parameters.\n */\nconst getUrlBindings = asset => {\n  const url = asset?.routing?.route ?? \"\"\n  const split = url.split(\"/\")\n  let params = []\n  split.forEach(part => {\n    if (part.startsWith(\":\") && part.length > 1) {\n      params.push(part.replace(/:/g, \"\").replace(/\\?/g, \"\"))\n    }\n  })\n  const safeURL = makePropSafe(\"url\")\n  const urlParamBindings = params.map(param => ({\n    type: \"context\",\n    runtimeBinding: `${safeURL}.${makePropSafe(param)}`,\n    readableBinding: `URL.${param}`,\n  }))\n  const queryParamsBinding = {\n    type: \"context\",\n    runtimeBinding: makePropSafe(\"query\"),\n    readableBinding: \"Query params\",\n  }\n  return urlParamBindings.concat([queryParamsBinding])\n}\n\nconst getRoleBindings = () => {\n  return (get(rolesStore) || []).map(role => {\n    return {\n      type: \"context\",\n      runtimeBinding: `trim \"${role._id}\"`,\n      readableBinding: `Role.${role.name}`,\n    }\n  })\n}\n\n/**\n * Gets all bindable properties exposed in an event action flow up until\n * the specified action ID, as well as context provided for the action\n * setting as a whole by the component.\n */\nexport const getEventContextBindings = (\n  asset,\n  componentId,\n  settingKey,\n  actions,\n  actionId\n) => {\n  let bindings = []\n\n  // Check if any context bindings are provided by the component for this\n  // setting\n  const component = findComponent(asset.props, componentId)\n  const settings = getComponentSettings(component?._component)\n  const eventSetting = settings.find(setting => setting.key === settingKey)\n  if (eventSetting?.context?.length) {\n    eventSetting.context.forEach(contextEntry => {\n      bindings.push({\n        readableBinding: contextEntry.label,\n        runtimeBinding: `${makePropSafe(\"eventContext\")}.${makePropSafe(\n          contextEntry.key\n        )}`,\n      })\n    })\n  }\n\n  // Get the steps leading up to this value\n  const index = actions?.findIndex(action => action.id === actionId)\n  if (index == null || index === -1) {\n    return bindings\n  }\n  const prevActions = actions.slice(0, index)\n\n  // Generate bindings for any steps which provide context\n  prevActions.forEach((action, idx) => {\n    const def = ActionDefinitions.actions.find(\n      x => x.name === action[\"##eventHandlerType\"]\n    )\n    if (def.context) {\n      def.context.forEach(contextValue => {\n        bindings.push({\n          readableBinding: `Action ${idx + 1}.${contextValue.label}`,\n          runtimeBinding: `actions.${idx}.${contextValue.value}`,\n        })\n      })\n    }\n  })\n\n  return bindings\n}\n\n/**\n * Gets the schema for a certain table ID.\n * The options which can be passed in are:\n *   formSchema: whether the schema is for a form\n *   searchableSchema: whether to generate a searchable schema, which may have\n *     fewer fields than a readable schema\n * @param tableId the table ID to get the schema for\n * @param options options for generating the schema\n * @return {{schema: Object, table: Object}}\n */\nexport const getSchemaForTable = (tableId, options) => {\n  return getSchemaForDatasource(null, { type: \"table\", tableId }, options)\n}\n\n/**\n * Gets a schema for a datasource object.\n * The options which can be passed in are:\n *   formSchema: whether the schema is for a form\n *   searchableSchema: whether to generate a searchable schema, which may have\n *     fewer fields than a readable schema\n * @param asset the current root client app asset (layout or screen). This is\n *   optional and only needed for \"provider\" datasource types.\n * @param datasource the datasource definition\n * @param options options for generating the schema\n * @return {{schema: Object, table: Object}}\n */\nexport const getSchemaForDatasource = (asset, datasource, options) => {\n  options = options || {}\n  let schema, table\n\n  if (datasource) {\n    const { type } = datasource\n    const tables = get(tablesStore).list\n\n    // Determine the entity which backs this datasource.\n    // \"provider\" datasources are those targeting another data provider\n    if (type === \"provider\") {\n      const component = findComponent(asset?.props, datasource.providerId)\n      const source = getDatasourceForProvider(asset, component)\n      return getSchemaForDatasource(asset, source, options)\n    }\n\n    // \"query\" datasources are those targeting non-plus datasources or\n    // custom queries\n    else if (type === \"query\") {\n      const queries = get(queriesStores).list\n      table = queries.find(query => query._id === datasource._id)\n    }\n\n    // \"field\" datasources are array-like fields of rows, such as attachments\n    // or multi-select fields\n    else if (type === \"field\") {\n      table = { name: datasource.fieldName }\n      const { fieldType } = datasource\n      if (fieldType === \"attachment\") {\n        schema = {\n          url: {\n            type: \"string\",\n          },\n          name: {\n            type: \"string\",\n          },\n        }\n      } else if (fieldType === \"array\") {\n        schema = {\n          value: {\n            type: \"string\",\n          },\n        }\n      }\n    }\n\n    // \"jsonarray\" datasources are arrays inside JSON fields\n    else if (type === \"jsonarray\") {\n      table = tables.find(table => table._id === datasource.tableId)\n      let tableSchema = table?.schema\n      schema = JSONUtils.getJSONArrayDatasourceSchema(tableSchema, datasource)\n    }\n\n    // Otherwise we assume we're targeting an internal table or a plus\n    // datasource, and we can treat it as a table with a schema\n    else {\n      table = tables.find(table => table._id === datasource.tableId)\n    }\n\n    // Determine the schema from the backing entity if not already determined\n    if (table && !schema) {\n      if (type === \"view\") {\n        // For views, the schema is pulled from the `views` property of the\n        // table\n        schema = cloneDeep(table.views?.[datasource.name]?.schema)\n      } else if (\n        type === \"query\" &&\n        (options.formSchema || options.searchableSchema)\n      ) {\n        // For queries, if we are generating a schema for a form or a searchable\n        // schema then we want to use the query parameters rather than the\n        // query schema\n        schema = {}\n        const params = table.parameters || []\n        params.forEach(param => {\n          if (param?.name) {\n            schema[param.name] = { ...param, type: \"string\" }\n          }\n        })\n      } else {\n        // Otherwise we just want the schema of the table\n        schema = cloneDeep(table.schema)\n      }\n    }\n\n    // Check for any JSON fields so we can add any top level properties\n    if (schema) {\n      let jsonAdditions = {}\n      Object.keys(schema).forEach(fieldKey => {\n        const fieldSchema = schema[fieldKey]\n        if (fieldSchema?.type === \"json\") {\n          const jsonSchema = JSONUtils.convertJSONSchemaToTableSchema(\n            fieldSchema,\n            {\n              squashObjects: true,\n            }\n          )\n          Object.keys(jsonSchema).forEach(jsonKey => {\n            jsonAdditions[`${fieldKey}.${jsonKey}`] = {\n              type: jsonSchema[jsonKey].type,\n              nestedJSON: true,\n            }\n          })\n        }\n      })\n      schema = { ...schema, ...jsonAdditions }\n    }\n\n    // Determine if we should add ID and rev to the schema\n    const isInternal = table && !table.sql\n    const isTable = [\"table\", \"link\"].includes(datasource.type)\n\n    // ID is part of the readable schema for all tables\n    // Rev is part of the readable schema for internal tables only\n    let addId = isTable\n    let addRev = isTable && isInternal\n\n    // Don't add ID or rev for form schemas\n    if (options.formSchema) {\n      addId = false\n      addRev = false\n    }\n\n    // ID is only searchable for internal tables\n    else if (options.searchableSchema) {\n      addId = isTable && isInternal\n    }\n\n    // Add schema properties if required\n    if (schema) {\n      if (addId) {\n        schema[\"_id\"] = { type: \"string\" }\n      }\n      if (addRev) {\n        schema[\"_rev\"] = { type: \"string\" }\n      }\n    }\n\n    // Ensure there are \"name\" properties for all fields and that field schema\n    // are objects\n    let fixedSchema = {}\n    Object.entries(schema || {}).forEach(([fieldName, fieldSchema]) => {\n      if (typeof fieldSchema === \"string\") {\n        fixedSchema[fieldName] = {\n          type: fieldSchema,\n          name: fieldName,\n        }\n      } else {\n        fixedSchema[fieldName] = {\n          ...fieldSchema,\n          name: fieldName,\n        }\n      }\n    })\n    schema = fixedSchema\n  }\n  return { schema, table }\n}\n\n/**\n * Builds a form schema given a form component.\n * A form schema is a schema of all the fields nested anywhere within a form.\n */\nexport const buildFormSchema = component => {\n  let schema = {}\n  if (!component) {\n    return schema\n  }\n  const settings = getComponentSettings(component._component)\n  const fieldSetting = settings.find(\n    setting => setting.key === \"field\" && setting.type.startsWith(\"field/\")\n  )\n  if (fieldSetting && component.field) {\n    const type = fieldSetting.type.split(\"field/\")[1]\n    if (type) {\n      schema[component.field] = { type }\n    }\n  }\n  component._children?.forEach(child => {\n    const childSchema = buildFormSchema(child)\n    schema = { ...schema, ...childSchema }\n  })\n  return schema\n}\n\n/**\n * Returns an array of the keys of any state variables which are set anywhere\n * in the app.\n */\nexport const getAllStateVariables = () => {\n  // Find all button action settings in all components\n  let eventSettings = []\n  getAllAssets().forEach(asset => {\n    findAllMatchingComponents(asset.props, component => {\n      const settings = getComponentSettings(component._component)\n      settings\n        .filter(setting => setting.type === \"event\")\n        .forEach(setting => {\n          eventSettings.push(component[setting.key])\n        })\n    })\n  })\n\n  // Add on load settings from screens\n  get(store).screens.forEach(screen => {\n    if (screen.onLoad) {\n      eventSettings.push(screen.onLoad)\n    }\n  })\n\n  // Extract all state keys from any \"update state\" actions in each setting\n  let bindingSet = new Set()\n  eventSettings.forEach(setting => {\n    if (!Array.isArray(setting)) {\n      return\n    }\n    setting.forEach(action => {\n      if (\n        action[\"##eventHandlerType\"] === \"Update State\" &&\n        action.parameters?.type === \"set\" &&\n        action.parameters?.key &&\n        action.parameters?.value\n      ) {\n        bindingSet.add(action.parameters.key)\n      }\n    })\n  })\n  return Array.from(bindingSet)\n}\n\nexport const getAllAssets = () => {\n  // Get all component containing assets\n  let allAssets = []\n  allAssets = allAssets.concat(get(store).layouts || [])\n  allAssets = allAssets.concat(get(store).screens || [])\n\n  return allAssets\n}\n\n/**\n * Recurses the input object to remove any instances of bindings.\n */\nexport const removeBindings = (obj, replacement = \"Invalid binding\") => {\n  for (let [key, value] of Object.entries(obj)) {\n    if (value && typeof value === \"object\") {\n      obj[key] = removeBindings(value, replacement)\n    } else if (typeof value === \"string\") {\n      obj[key] = value.replace(CAPTURE_HBS_TEMPLATE, replacement)\n    }\n  }\n  return obj\n}\n\n/**\n * When converting from readable to runtime it can sometimes add too many square brackets,\n * this makes sure that doesn't happen.\n */\nconst shouldReplaceBinding = (currentValue, convertFrom, convertTo) => {\n  if (!currentValue?.includes(convertFrom)) {\n    return false\n  }\n  if (convertTo === \"readableBinding\") {\n    return true\n  }\n  // remove all the spaces, if the input is surrounded by spaces e.g. [ Auto ID ] then\n  // this makes sure it is detected\n  const noSpaces = currentValue.replace(/\\s+/g, \"\")\n  const fromNoSpaces = convertFrom.replace(/\\s+/g, \"\")\n  const invalids = [\n    `[${fromNoSpaces}]`,\n    `\"${fromNoSpaces}\"`,\n    `'${fromNoSpaces}'`,\n  ]\n  return !invalids.find(invalid => noSpaces?.includes(invalid))\n}\n\n/**\n * Utility function which replaces a string between given indices.\n */\nconst replaceBetween = (string, start, end, replacement) => {\n  return string.substring(0, start) + replacement + string.substring(end)\n}\n\n/**\n * Utility function for the readableToRuntimeBinding and runtimeToReadableBinding.\n */\nconst bindingReplacement = (\n  bindableProperties,\n  textWithBindings,\n  convertTo\n) => {\n  // Decide from base64 if using JS\n  const isJS = isJSBinding(textWithBindings)\n  if (isJS) {\n    textWithBindings = decodeJSBinding(textWithBindings)\n  }\n\n  // Determine correct regex to find bindings to replace\n  const regex = isJS ? CAPTURE_VAR_INSIDE_JS : CAPTURE_VAR_INSIDE_TEMPLATE\n\n  const convertFrom =\n    convertTo === \"runtimeBinding\" ? \"readableBinding\" : \"runtimeBinding\"\n  if (typeof textWithBindings !== \"string\") {\n    return textWithBindings\n  }\n  // work from longest to shortest\n  const convertFromProps = bindableProperties\n    .map(el => el[convertFrom])\n    .sort((a, b) => {\n      return b.length - a.length\n    })\n  const boundValues = textWithBindings.match(regex) || []\n  let result = textWithBindings\n  for (let boundValue of boundValues) {\n    let newBoundValue = boundValue\n    // we use a search string, where any time we replace something we blank it out\n    // in the search, working from longest to shortest so always use best match first\n    let searchString = newBoundValue\n    for (let from of convertFromProps) {\n      if (isJS || shouldReplaceBinding(newBoundValue, from, convertTo)) {\n        const binding = bindableProperties.find(el => el[convertFrom] === from)\n        let idx\n        do {\n          // see if any instances of this binding exist in the search string\n          idx = searchString.indexOf(from)\n          if (idx !== -1) {\n            let end = idx + from.length,\n              searchReplace = Array(binding[convertTo].length + 1).join(\"*\")\n            // blank out parts of the search string\n            searchString = replaceBetween(searchString, idx, end, searchReplace)\n            newBoundValue = replaceBetween(\n              newBoundValue,\n              idx,\n              end,\n              binding[convertTo]\n            )\n          }\n        } while (idx !== -1)\n      }\n    }\n    result = result.replace(boundValue, newBoundValue)\n  }\n\n  // Re-encode to base64 if using JS\n  if (isJS) {\n    result = encodeJSBinding(result)\n  }\n\n  return result\n}\n\n/**\n * Extracts a component ID from a handlebars expression setting of\n * {{ literal [componentId] }}\n */\nconst extractLiteralHandlebarsID = value => {\n  return value?.match(/{{\\s*literal\\s*\\[+([^\\]]+)].*}}/)?.[1]\n}\n\n/**\n * Converts a readable data binding into a runtime data binding\n */\nexport const readableToRuntimeBinding = (\n  bindableProperties,\n  textWithBindings\n) => {\n  return bindingReplacement(\n    bindableProperties,\n    textWithBindings,\n    \"runtimeBinding\"\n  )\n}\n\n/**\n * Converts a runtime data binding into a readable data binding\n */\nexport const runtimeToReadableBinding = (\n  bindableProperties,\n  textWithBindings\n) => {\n  return bindingReplacement(\n    bindableProperties,\n    textWithBindings,\n    \"readableBinding\"\n  )\n}\n", "import { IntegrationTypes } from \"constants/backend\"\nimport { findHBSBlocks } from \"@budibase/string-templates\"\n\nexport function schemaToFields(schema) {\n  const response = {}\n  if (schema && typeof schema === \"object\") {\n    for (let [field, value] of Object.entries(schema)) {\n      response[field] = value?.type || \"string\"\n    }\n  }\n  return response\n}\n\nexport function fieldsToSchema(fields) {\n  const response = {}\n  if (fields && typeof fields === \"object\") {\n    for (let [name, type] of Object.entries(fields)) {\n      response[name] = { name, type }\n    }\n  }\n  return response\n}\n\nexport function breakQueryString(qs) {\n  if (!qs) {\n    return {}\n  }\n  if (qs.includes(\"?\")) {\n    qs = qs.split(\"?\")[1]\n  }\n  const params = qs.split(\"&\")\n  let paramObj = {}\n  for (let param of params) {\n    const split = param.split(\"=\")\n    console.log(split[1])\n    paramObj[split[0]] = decodeURIComponent(split.slice(1).join(\"=\"))\n  }\n  return paramObj\n}\n\nexport function buildQueryString(obj) {\n  let str = \"\"\n  if (obj) {\n    for (let [key, value] of Object.entries(obj)) {\n      if (!key || key === \"\") {\n        continue\n      }\n      if (str !== \"\") {\n        str += \"&\"\n      }\n      const bindings = findHBSBlocks(value)\n      let count = 0\n      const bindingMarkers = {}\n      bindings.forEach(binding => {\n        const marker = `BINDING...${count++}`\n        value = value.replace(binding, marker)\n        bindingMarkers[marker] = binding\n      })\n      let encoded = encodeURIComponent(value || \"\")\n      Object.entries(bindingMarkers).forEach(([marker, binding]) => {\n        encoded = encoded.replace(marker, binding)\n      })\n      str += `${key}=${encoded}`\n    }\n  }\n  return str\n}\n\nexport function keyValueToQueryParameters(obj) {\n  let array = []\n  if (obj && typeof obj === \"object\") {\n    for (let [key, value] of Object.entries(obj)) {\n      array.push({ name: key, default: value })\n    }\n  }\n  return array\n}\n\nexport function queryParametersToKeyValue(array) {\n  let obj = {}\n  if (Array.isArray(array)) {\n    for (let param of array) {\n      obj[param.name] = param.default\n    }\n  }\n  return obj\n}\n\nexport function customQueryIconText(datasource, query) {\n  if (datasource.source !== IntegrationTypes.REST) {\n    return\n  }\n  switch (query.queryVerb) {\n    case \"create\":\n      return \"POST\"\n    case \"update\":\n      return \"PUT\"\n    case \"read\":\n      return \"GET\"\n    case \"delete\":\n      return \"DEL\"\n    case \"patch\":\n      return \"PATCH\"\n  }\n}\n\nexport function customQueryIconColor(datasource, query) {\n  if (datasource.source !== IntegrationTypes.REST) {\n    return\n  }\n  switch (query.queryVerb) {\n    case \"create\":\n      return \"#dcc339\"\n    case \"update\":\n      return \"#5197ec\"\n    case \"read\":\n      return \"#53a761\"\n    case \"delete\":\n      return \"#ea7d82\"\n    case \"patch\":\n    default:\n      return\n  }\n}\n\nexport function customQueryText(datasource, query) {\n  if (!query.name || datasource.source !== IntegrationTypes.REST) {\n    return query.name\n  }\n\n  // Remove protocol\n  let name = query.name\n  if (name.includes(\"//\")) {\n    name = name.split(\"//\")[1]\n  }\n\n  // If no path, return the full name\n  if (!name.includes(\"/\")) {\n    return name\n  }\n\n  // Remove trailing slash\n  if (name.endsWith(\"/\")) {\n    name = name.slice(0, -1)\n  }\n\n  // Only use path\n  const split = name.split(\"/\")\n  if (split[1]) {\n    return `/${split.slice(1).join(\"/\")}`\n  } else {\n    return split[0]\n  }\n}\n\nexport function flipHeaderState(headersActivity) {\n  if (!headersActivity) {\n    return {}\n  }\n  const enabled = {}\n  Object.entries(headersActivity).forEach(([key, value]) => {\n    enabled[key] = !value\n  })\n  return enabled\n}\n\nexport const parseToCsv = (headers, rows) => {\n  let csv = headers?.map(key => `\"${key}\"`)?.join(\",\") || \"\"\n\n  for (let row of rows) {\n    csv = `${csv}\\n${headers\n      .map(header => {\n        let val = row[header]\n        val =\n          typeof val === \"object\" && !(val instanceof Date)\n            ? `\"${JSON.stringify(val).replace(/\"/g, \"'\")}\"`\n            : `\"${val}\"`\n        return val.trim()\n      })\n      .join(\",\")}`\n  }\n  return csv\n}\n\nexport default {\n  breakQueryString,\n  buildQueryString,\n  fieldsToSchema,\n  flipHeaderState,\n  keyValueToQueryParameters,\n  parseToCsv,\n  queryParametersToKeyValue,\n  schemaToFields,\n}\n", "<script>\n  import { params } from \"@roxi/routify\"\n  import { datasources, flags, integrations, queries } from \"stores/backend\"\n  import {\n    Banner,\n    Body,\n    Button,\n    Divider,\n    Heading,\n    Input,\n    Label,\n    Layout,\n    notifications,\n    RadioGroup,\n    Select,\n    Tab,\n    Table,\n    Tabs,\n    TextArea,\n  } from \"@budibase/bbui\"\n  import KeyValueBuilder from \"components/integration/KeyValueBuilder.svelte\"\n  import EditableLabel from \"components/common/inputs/EditableLabel.svelte\"\n  import CodeMirrorEditor, {\n    EditorModes,\n  } from \"components/common/CodeMirrorEditor.svelte\"\n  import RestBodyInput from \"../../_components/RestBodyInput.svelte\"\n  import { capitalise } from \"helpers\"\n  import { onMount } from \"svelte\"\n  import restUtils from \"helpers/data/utils\"\n  import {\n    PaginationLocations,\n    PaginationTypes,\n    RawRestBodyTypes,\n    RestBodyTypes as bodyTypes,\n    SchemaTypeOptions,\n  } from \"constants/backend\"\n  import JSONPreview from \"components/integration/JSONPreview.svelte\"\n  import AccessLevelSelect from \"components/integration/AccessLevelSelect.svelte\"\n  import DynamicVariableModal from \"../../_components/DynamicVariableModal.svelte\"\n  import Placeholder from \"assets/bb-spaceship.svg\"\n  import { cloneDeep } from \"lodash/fp\"\n\n  import {\n    getRestBindings,\n    readableToRuntimeBinding,\n    readableToRuntimeMap,\n    runtimeToReadableBinding,\n    runtimeToReadableMap,\n    toBindingsArray,\n  } from \"builderStore/dataBinding\"\n\n  let query, datasource\n  let breakQs = {},\n    requestBindings = {}\n  let saveId, url\n  let response, schema, enabledHeaders\n  let authConfigId\n  let dynamicVariables, addVariableModal, varBinding, globalDynamicBindings\n  let restBindings = getRestBindings()\n\n  $: staticVariables = datasource?.config?.staticVariables || {}\n\n  $: customRequestBindings = toBindingsArray(requestBindings, \"Binding\")\n  $: globalDynamicRequestBindings = toBindingsArray(\n    globalDynamicBindings,\n    \"Dynamic\"\n  )\n  $: dataSourceStaticBindings = toBindingsArray(\n    staticVariables,\n    \"Datasource.Static\"\n  )\n\n  $: mergedBindings = [\n    ...restBindings,\n    ...customRequestBindings,\n    ...globalDynamicRequestBindings,\n    ...dataSourceStaticBindings,\n  ]\n\n  $: datasourceType = datasource?.source\n  $: integrationInfo = $integrations[datasourceType]\n  $: queryConfig = integrationInfo?.query\n  $: url = buildUrl(url, breakQs)\n  $: checkQueryName(url)\n  $: responseSuccess = response?.info?.code >= 200 && response?.info?.code < 400\n  $: isGet = query?.queryVerb === \"read\"\n  $: authConfigs = buildAuthConfigs(datasource)\n  $: schemaReadOnly = !responseSuccess\n  $: variablesReadOnly = !responseSuccess\n  $: showVariablesTab = shouldShowVariables(dynamicVariables, variablesReadOnly)\n  $: hasSchema =\n    Object.keys(schema || {}).length !== 0 ||\n    Object.keys(query?.schema || {}).length !== 0\n\n  $: runtimeUrlQueries = readableToRuntimeMap(mergedBindings, breakQs)\n\n  function getSelectedQuery() {\n    return cloneDeep(\n      $queries.list.find(q => q._id === $queries.selected) || {\n        datasourceId: $params.selectedDatasource,\n        parameters: [],\n        fields: {\n          // only init the objects, everything else is optional strings\n          disabledHeaders: {},\n          headers: {},\n        },\n        queryVerb: \"read\",\n      }\n    )\n  }\n\n  function checkQueryName(inputUrl = null) {\n    if (query && (!query.name || query.flags.urlName)) {\n      query.flags.urlName = true\n      query.name = url || inputUrl\n    }\n  }\n\n  function buildUrl(base, qsObj) {\n    if (!base) {\n      return base\n    }\n    let qs = restUtils.buildQueryString(\n      runtimeToReadableMap(mergedBindings, qsObj)\n    )\n    let newUrl = base\n    if (base.includes(\"?\")) {\n      const split = base.split(\"?\")\n      newUrl = split[0]\n    }\n    return qs.length === 0 ? newUrl : `${newUrl}?${qs}`\n  }\n\n  function buildQuery() {\n    const newQuery = cloneDeep(query)\n    const queryString = restUtils.buildQueryString(runtimeUrlQueries)\n\n    newQuery.parameters = restUtils.keyValueToQueryParameters(requestBindings)\n    newQuery.fields.requestBody =\n      typeof newQuery.fields.requestBody === \"object\"\n        ? readableToRuntimeMap(mergedBindings, newQuery.fields.requestBody)\n        : readableToRuntimeBinding(mergedBindings, newQuery.fields.requestBody)\n\n    newQuery.fields.path = url.split(\"?\")[0]\n    newQuery.fields.queryString = queryString\n    newQuery.fields.authConfigId = authConfigId\n    newQuery.fields.disabledHeaders = restUtils.flipHeaderState(enabledHeaders)\n    newQuery.schema = restUtils.fieldsToSchema(schema)\n\n    return newQuery\n  }\n\n  async function saveQuery() {\n    const toSave = buildQuery()\n    try {\n      const { _id } = await queries.save(toSave.datasourceId, toSave)\n      saveId = _id\n      query = getSelectedQuery()\n      notifications.success(`Request saved successfully`)\n      if (dynamicVariables) {\n        datasource.config.dynamicVariables = rebuildVariables(saveId)\n        datasource = await datasources.save(datasource)\n      }\n      prettifyQueryRequestBody(\n        query,\n        requestBindings,\n        dynamicVariables,\n        staticVariables,\n        restBindings\n      )\n    } catch (err) {\n      notifications.error(`Error saving query`)\n    }\n  }\n\n  async function runQuery() {\n    try {\n      response = await queries.preview(buildQuery())\n      if (response.rows.length === 0) {\n        notifications.info(\"Request did not return any data\")\n      } else {\n        response.info = response.info || { code: 200 }\n        schema = response.schema\n        notifications.success(\"Request sent successfully\")\n      }\n    } catch (error) {\n      notifications.error(`Query Error: ${error.message}`)\n    }\n  }\n\n  const getAuthConfigId = () => {\n    let id = query.fields.authConfigId\n    if (id) {\n      // find the matching config on the datasource\n      const matchedConfig = datasource?.config?.authConfigs?.filter(\n        c => c._id === id\n      )[0]\n      // clear the id if the config is not found (deleted)\n      // i.e. just show 'None' in the dropdown\n      if (!matchedConfig) {\n        id = undefined\n      }\n    }\n    return id\n  }\n\n  const buildAuthConfigs = datasource => {\n    if (datasource?.config?.authConfigs) {\n      return datasource.config.authConfigs.map(c => ({\n        label: c.name,\n        value: c._id,\n      }))\n    }\n    return []\n  }\n\n  const schemaMenuItems = [\n    {\n      text: \"Create dynamic variable\",\n      onClick: input => {\n        varBinding = `{{ data.0.[${input.name}] }}`\n        addVariableModal.show()\n      },\n    },\n  ]\n  const responseHeadersMenuItems = [\n    {\n      text: \"Create dynamic variable\",\n      onClick: input => {\n        varBinding = `{{ info.headers.[${input.name}] }}`\n        addVariableModal.show()\n      },\n    },\n  ]\n\n  // convert dynamic variables list to simple key/val object\n  const getDynamicVariables = (datasource, queryId, matchFn) => {\n    const variablesList = datasource?.config?.dynamicVariables\n    if (variablesList && variablesList.length > 0) {\n      const filtered = queryId\n        ? variablesList.filter(variable => matchFn(variable, queryId))\n        : variablesList\n      return filtered.reduce(\n        (acc, next) => ({ ...acc, [next.name]: next.value }),\n        {}\n      )\n    }\n    return {}\n  }\n\n  // convert dynamic variables object back to a list, enrich with query id\n  const rebuildVariables = queryId => {\n    let variables = []\n    if (dynamicVariables) {\n      variables = Object.entries(dynamicVariables).map(entry => {\n        return {\n          name: entry[0],\n          value: entry[1],\n          queryId,\n        }\n      })\n    }\n\n    let existing = datasource?.config?.dynamicVariables || []\n    // remove existing query variables (for changes and deletions)\n    existing = existing.filter(variable => variable.queryId !== queryId)\n    // re-add the new query variables\n    return [...existing, ...variables]\n  }\n\n  const shouldShowVariables = (dynamicVariables, variablesReadOnly) => {\n    return !!(\n      dynamicVariables &&\n      // show when editable or when read only and not empty\n      (!variablesReadOnly || Object.keys(dynamicVariables).length > 0)\n    )\n  }\n\n  const updateFlag = async (flag, value) => {\n    try {\n      await flags.updateFlag(flag, value)\n    } catch (error) {\n      notifications.error(\"Error updating flag\")\n    }\n  }\n\n  const prettifyQueryRequestBody = (\n    query,\n    requestBindings,\n    dynamicVariables,\n    staticVariables,\n    restBindings\n  ) => {\n    let customRequestBindings = toBindingsArray(requestBindings, \"Binding\")\n    let dynamicRequestBindings = toBindingsArray(dynamicVariables, \"Dynamic\")\n    let dataSourceStaticBindings = toBindingsArray(\n      staticVariables,\n      \"Datasource.Static\"\n    )\n\n    const prettyBindings = [\n      ...restBindings,\n      ...customRequestBindings,\n      ...dynamicRequestBindings,\n      ...dataSourceStaticBindings,\n    ]\n\n    //Parse the body here as now all bindings have been updated.\n    if (query?.fields?.requestBody) {\n      query.fields.requestBody =\n        typeof query.fields.requestBody === \"object\"\n          ? runtimeToReadableMap(prettyBindings, query.fields.requestBody)\n          : runtimeToReadableBinding(prettyBindings, query.fields.requestBody)\n    }\n  }\n\n  const paramsChanged = evt => {\n    breakQs = {}\n    for (let param of evt.detail) {\n      breakQs[param.name] = param.value\n    }\n  }\n\n  const urlChanged = evt => {\n    breakQs = {}\n    const qs = evt.target.value.split(\"?\")[1]\n    if (qs && qs.length > 0) {\n      const parts = qs.split(\"&\")\n      for (let part of parts) {\n        const [key, value] = part.split(\"=\")\n        breakQs[key] = value\n      }\n    }\n  }\n\n  onMount(async () => {\n    query = getSelectedQuery()\n\n    try {\n      // Clear any unsaved changes to the datasource\n      await datasources.init()\n    } catch (error) {\n      notifications.error(\"Error getting datasources\")\n    }\n\n    datasource = $datasources.list.find(ds => ds._id === query?.datasourceId)\n    const datasourceUrl = datasource?.config.url\n    const qs = query?.fields.queryString\n    breakQs = restUtils.breakQueryString(qs)\n    console.log(breakQs)\n    breakQs = runtimeToReadableMap(mergedBindings, breakQs)\n\n    const path = query.fields.path\n    if (\n      datasourceUrl &&\n      !path?.startsWith(\"http\") &&\n      !path?.startsWith(\"{{\") // don't substitute the datasource url when query starts with a variable e.g. the upgrade path\n    ) {\n      query.fields.path = `${datasource.config.url}/${path ? path : \"\"}`\n    }\n    url = buildUrl(query.fields.path, breakQs)\n    schema = restUtils.schemaToFields(query.schema)\n    requestBindings = restUtils.queryParametersToKeyValue(query.parameters)\n    authConfigId = getAuthConfigId()\n    if (!query.fields.disabledHeaders) {\n      query.fields.disabledHeaders = {}\n    }\n    // make sure the disabled headers are set (migration)\n    for (let header of Object.keys(query.fields.headers)) {\n      if (!query.fields.disabledHeaders[header]) {\n        query.fields.disabledHeaders[header] = false\n      }\n    }\n    enabledHeaders = restUtils.flipHeaderState(query.fields.disabledHeaders)\n    if (query && !query.transformer) {\n      query.transformer = \"return data\"\n    }\n    if (query && !query.flags) {\n      query.flags = {\n        urlName: false,\n      }\n    }\n    if (query && !query.fields.bodyType) {\n      if (query.fields.requestBody) {\n        query.fields.bodyType = RawRestBodyTypes.JSON\n      } else {\n        query.fields.bodyType = RawRestBodyTypes.NONE\n      }\n    }\n    if (query && !query.fields.pagination) {\n      query.fields.pagination = {}\n    }\n    dynamicVariables = getDynamicVariables(\n      datasource,\n      query._id,\n      (variable, queryId) => variable.queryId === queryId\n    )\n    globalDynamicBindings = getDynamicVariables(\n      datasource,\n      query._id,\n      (variable, queryId) => variable.queryId !== queryId\n    )\n\n    prettifyQueryRequestBody(\n      query,\n      requestBindings,\n      globalDynamicBindings,\n      staticVariables,\n      restBindings\n    )\n  })\n</script>\n\n<DynamicVariableModal\n  {datasource}\n  {dynamicVariables}\n  bind:binding={varBinding}\n  bind:this={addVariableModal}\n  on:change={saveQuery}\n/>\n{#if query && queryConfig}\n  <div class=\"inner\">\n    <div class=\"top\">\n      <Layout gap=\"S\">\n        <div class=\"top-bar\">\n          <EditableLabel\n            type=\"heading\"\n            bind:value={query.name}\n            defaultValue=\"Untitled\"\n            on:change={() => (query.flags.urlName = false)}\n            on:save={saveQuery}\n          />\n          <div class=\"access\">\n            <Label>Access level</Label>\n            <AccessLevelSelect {query} {saveId} />\n          </div>\n        </div>\n        <div class=\"url-block\">\n          <div class=\"verb\">\n            <Select\n              bind:value={query.queryVerb}\n              on:change={() => {}}\n              options={Object.keys(queryConfig)}\n              getOptionLabel={verb =>\n                queryConfig[verb]?.displayName || capitalise(verb)}\n            />\n          </div>\n          <div class=\"url\">\n            <Input\n              on:blur={urlChanged}\n              bind:value={url}\n              placeholder=\"http://www.api.com/endpoint\"\n            />\n          </div>\n          <Button primary disabled={!url} on:click={runQuery}>Send</Button>\n          <Button\n            disabled={!query.name}\n            cta\n            on:click={saveQuery}\n            tooltip={!hasSchema\n              ? \"Saving a query before sending will mean no schema is generated\"\n              : null}>Save</Button\n          >\n        </div>\n        <Tabs selected=\"Bindings\" quiet noPadding noHorizPadding onTop>\n          <Tab title=\"Bindings\">\n            <KeyValueBuilder\n              bind:object={requestBindings}\n              tooltip=\"Set the name of the binding which can be used in Handlebars statements throughout your query\"\n              name=\"binding\"\n              headings\n              keyPlaceholder=\"Binding name\"\n              valuePlaceholder=\"Default\"\n              bindings={[\n                ...restBindings,\n                ...globalDynamicRequestBindings,\n                ...dataSourceStaticBindings,\n              ]}\n              bindingDrawerLeft=\"260px\"\n            />\n          </Tab>\n          <Tab title=\"Params\">\n            {#key breakQs}\n              <KeyValueBuilder\n                on:change={paramsChanged}\n                object={breakQs}\n                name=\"param\"\n                headings\n                bindings={mergedBindings}\n                bindingDrawerLeft=\"260px\"\n              />\n            {/key}\n          </Tab>\n          <Tab title=\"Headers\">\n            <KeyValueBuilder\n              bind:object={query.fields.headers}\n              bind:activity={enabledHeaders}\n              toggle\n              name=\"header\"\n              headings\n              bindings={mergedBindings}\n              bindingDrawerLeft=\"260px\"\n            />\n          </Tab>\n          <Tab title=\"Body\">\n            <RadioGroup\n              bind:value={query.fields.bodyType}\n              options={isGet ? [bodyTypes[0]] : bodyTypes}\n              direction=\"horizontal\"\n              getOptionLabel={option => option.name}\n              getOptionValue={option => option.value}\n            />\n            <RestBodyInput bind:bodyType={query.fields.bodyType} bind:query />\n          </Tab>\n          <Tab title=\"Pagination\">\n            <div class=\"pagination\">\n              <Select\n                label=\"Pagination type\"\n                bind:value={query.fields.pagination.type}\n                options={PaginationTypes}\n                placeholder=\"None\"\n              />\n              {#if query.fields.pagination.type}\n                <Select\n                  label=\"Pagination parameters location\"\n                  bind:value={query.fields.pagination.location}\n                  options={PaginationLocations}\n                  placeholer=\"Choose where to send pagination parameters\"\n                />\n                <Input\n                  label={query.fields.pagination.type === \"page\"\n                    ? \"Page number parameter name \"\n                    : \"Request cursor parameter name\"}\n                  bind:value={query.fields.pagination.pageParam}\n                />\n                <Input\n                  label={query.fields.pagination.type === \"page\"\n                    ? \"Page size parameter name\"\n                    : \"Request limit parameter name\"}\n                  bind:value={query.fields.pagination.sizeParam}\n                />\n                {#if query.fields.pagination.type === \"cursor\"}\n                  <Input\n                    label=\"Response body parameter name for cursor\"\n                    bind:value={query.fields.pagination.responseParam}\n                  />\n                {/if}\n              {/if}\n            </div>\n          </Tab>\n          <Tab title=\"Transformer\">\n            <Layout noPadding>\n              {#if !$flags.queryTransformerBanner}\n                <Banner\n                  extraButtonText=\"Learn more\"\n                  extraButtonAction={() =>\n                    window.open(\"https://docs.budibase.com/docs/transformers\")}\n                  on:change={() => updateFlag(\"queryTransformerBanner\", true)}\n                >\n                  Add a JavaScript function to transform the query result.\n                </Banner>\n              {/if}\n              <CodeMirrorEditor\n                height={200}\n                mode={EditorModes.JSON}\n                value={query.transformer}\n                resize=\"vertical\"\n                on:change={e => (query.transformer = e.detail)}\n              />\n            </Layout>\n          </Tab>\n          <div class=\"auth-container\">\n            <div />\n            <!-- spacer -->\n            <div class=\"auth-select\">\n              <Select\n                label=\"Auth\"\n                labelPosition=\"left\"\n                placeholder=\"None\"\n                bind:value={authConfigId}\n                options={authConfigs}\n              />\n            </div>\n          </div>\n        </Tabs>\n      </Layout>\n    </div>\n    <div class=\"bottom\">\n      <Layout paddingY=\"S\" gap=\"S\">\n        <Divider size=\"S\" />\n        {#if !response && Object.keys(schema).length === 0}\n          <Heading size=\"M\">Response</Heading>\n          <div class=\"placeholder\">\n            <div class=\"placeholder-internal\">\n              <img alt=\"placeholder\" src={Placeholder} />\n              <Body size=\"XS\" textAlign=\"center\"\n                >{\"enter a url in the textbox above and click send to get a response\".toUpperCase()}</Body\n              >\n            </div>\n          </div>\n        {:else}\n          <Tabs\n            selected={!response ? \"Schema\" : \"JSON\"}\n            quiet\n            noPadding\n            noHorizPadding\n          >\n            {#if response}\n              <Tab title=\"JSON\">\n                <div>\n                  <JSONPreview height=\"300\" data={response.rows[0]} />\n                </div>\n              </Tab>\n            {/if}\n            {#if schema || response}\n              <Tab title=\"Schema\">\n                <KeyValueBuilder\n                  bind:object={schema}\n                  name=\"schema\"\n                  headings\n                  options={SchemaTypeOptions}\n                  menuItems={schemaMenuItems}\n                  showMenu={!schemaReadOnly}\n                  readOnly={schemaReadOnly}\n                />\n              </Tab>\n            {/if}\n            {#if response}\n              <Tab title=\"Raw\">\n                <TextArea disabled value={response.extra?.raw} height=\"300\" />\n              </Tab>\n              <Tab title=\"Headers\">\n                <KeyValueBuilder\n                  object={response.extra?.headers}\n                  readOnly\n                  menuItems={responseHeadersMenuItems}\n                  showMenu={true}\n                />\n              </Tab>\n              <Tab title=\"Preview\">\n                <div class=\"table\">\n                  {#if response}\n                    <Table\n                      schema={response?.schema}\n                      data={response?.rows}\n                      allowEditColumns={false}\n                      allowEditRows={false}\n                      allowSelectRows={false}\n                    />\n                  {/if}\n                </div>\n              </Tab>\n            {/if}\n            {#if showVariablesTab}\n              <Tab title=\"Dynamic Variables\">\n                <Layout noPadding gap=\"S\">\n                  <Body size=\"S\">\n                    Create dynamic variables based on response body or headers\n                    from this query.\n                  </Body>\n                  <KeyValueBuilder\n                    bind:object={dynamicVariables}\n                    name=\"Variable\"\n                    headings\n                    keyHeading=\"Name\"\n                    keyPlaceholder=\"Variable name\"\n                    valueHeading={`Value`}\n                    valuePlaceholder={`{{ value }}`}\n                    readOnly={variablesReadOnly}\n                  />\n                </Layout>\n              </Tab>\n            {/if}\n            {#if response}\n              <div class=\"stats\">\n                <Label size=\"L\">\n                  Status: <span class={responseSuccess ? \"green\" : \"red\"}\n                    >{response?.info.code}</span\n                  >\n                </Label>\n                <Label size=\"L\">\n                  Time: <span class={responseSuccess ? \"green\" : \"red\"}\n                    >{response?.info.time}</span\n                  >\n                </Label>\n                <Label size=\"L\">\n                  Size: <span class={responseSuccess ? \"green\" : \"red\"}\n                    >{response?.info.size}</span\n                  >\n                </Label>\n              </div>\n            {/if}\n          </Tabs>\n        {/if}\n      </Layout>\n    </div>\n  </div>\n{/if}\n\n<style>\n  .inner {\n    width: 960px;\n    margin: 0 auto;\n    height: 100%;\n  }\n  .table {\n    width: 960px;\n  }\n  .url-block {\n    display: flex;\n    gap: var(--spacing-s);\n    z-index: 200;\n  }\n  .verb {\n    flex: 1;\n  }\n  .url {\n    flex: 4;\n  }\n  .top {\n    min-height: 50%;\n  }\n  .bottom {\n    padding-bottom: 50px;\n  }\n  .stats {\n    display: flex;\n    gap: var(--spacing-xl);\n    margin-left: auto !important;\n    margin-right: 0;\n    align-items: center;\n  }\n  .green {\n    color: #53a761;\n  }\n  .red {\n    color: #ea7d82;\n  }\n  .top-bar {\n    display: flex;\n    justify-content: space-between;\n  }\n  .access {\n    display: flex;\n    gap: var(--spacing-m);\n    align-items: center;\n  }\n  .placeholder-internal {\n    display: flex;\n    flex-direction: column;\n    width: 200px;\n    gap: var(--spacing-l);\n  }\n  .placeholder {\n    display: flex;\n    margin-top: var(--spacing-xl);\n    justify-content: center;\n  }\n  .auth-container {\n    width: 100%;\n    display: flex;\n    justify-content: space-between;\n  }\n  .auth-select {\n    width: 200px;\n  }\n  .pagination {\n    display: grid;\n    grid-template-columns: 1fr 1fr;\n    gap: var(--spacing-m);\n  }\n</style>\n", "const {\n  getGlobalDB,\n  getTenantId,\n  isUserInAppTenant,\n} = require(\"@budibase/backend-core/tenancy\")\nconst { generateDevInfoID, SEPARATOR } = require(\"@budibase/backend-core/db\")\nconst { user: userCache } = require(\"@budibase/backend-core/cache\")\nconst {\n  hash,\n  platformLogout,\n  getCookie,\n  clearCookie,\n} = require(\"@budibase/backend-core/utils\")\nconst { encrypt } = require(\"@budibase/backend-core/encryption\")\nconst { newid } = require(\"@budibase/backend-core/utils\")\nconst { users } = require(\"../../../sdk\")\nconst { Cookies } = require(\"@budibase/backend-core/constants\")\nconst { events, featureFlags } = require(\"@budibase/backend-core\")\n\nfunction newApiKey() {\n  return encrypt(`${getTenantId()}${SEPARATOR}${newid()}`)\n}\n\nfunction cleanupDevInfo(info) {\n  // user doesn't need to aware of dev doc info\n  delete info._id\n  delete info._rev\n  return info\n}\n\nexports.generateAPIKey = async ctx => {\n  const db = getGlobalDB()\n  const id = generateDevInfoID(ctx.user._id)\n  let devInfo\n  try {\n    devInfo = await db.get(id)\n  } catch (err) {\n    devInfo = { _id: id, userId: ctx.user._id }\n  }\n  devInfo.apiKey = await newApiKey()\n  await db.put(devInfo)\n  ctx.body = cleanupDevInfo(devInfo)\n}\n\nexports.fetchAPIKey = async ctx => {\n  const db = getGlobalDB()\n  const id = generateDevInfoID(ctx.user._id)\n  let devInfo\n  try {\n    devInfo = await db.get(id)\n  } catch (err) {\n    devInfo = {\n      _id: id,\n      userId: ctx.user._id,\n      apiKey: await newApiKey(),\n    }\n    await db.put(devInfo)\n  }\n  ctx.body = cleanupDevInfo(devInfo)\n}\n\nconst checkCurrentApp = ctx => {\n  const appCookie = getCookie(ctx, Cookies.CurrentApp)\n  if (appCookie && !isUserInAppTenant(appCookie.appId)) {\n    // there is a currentapp cookie from another tenant\n    // remove the cookie as this is incompatible with the builder\n    // due to builder and admin permissions being removed\n    clearCookie(ctx, Cookies.CurrentApp)\n  }\n}\n\n/**\n * Add the attributes that are session based to the current user.\n */\nconst addSessionAttributesToUser = ctx => {\n  ctx.body.account = ctx.user.account\n  ctx.body.license = ctx.user.license\n  ctx.body.budibaseAccess = !!ctx.user.budibaseAccess\n  ctx.body.accountPortalAccess = !!ctx.user.accountPortalAccess\n  ctx.body.csrfToken = ctx.user.csrfToken\n}\n\nconst sanitiseUserUpdate = ctx => {\n  const allowed = [\"firstName\", \"lastName\", \"password\", \"forceResetPassword\"]\n  const resp = {}\n  for (let [key, value] of Object.entries(ctx.request.body)) {\n    if (allowed.includes(key)) {\n      resp[key] = value\n    }\n  }\n  return resp\n}\n\nexports.getSelf = async ctx => {\n  if (!ctx.user) {\n    ctx.throw(403, \"User not logged in\")\n  }\n  const userId = ctx.user._id\n  ctx.params = {\n    id: userId,\n  }\n\n  checkCurrentApp(ctx)\n\n  // get the main body of the user\n  ctx.body = await users.getUser(userId)\n\n  // add the feature flags for this tenant\n  const tenantId = getTenantId()\n  ctx.body.featureFlags = featureFlags.getTenantFeatureFlags(tenantId)\n\n  addSessionAttributesToUser(ctx)\n}\n\nexports.updateSelf = async ctx => {\n  const db = getGlobalDB()\n  const user = await db.get(ctx.user._id)\n  let passwordChange = false\n\n  const userUpdateObj = sanitiseUserUpdate(ctx)\n  if (userUpdateObj.password) {\n    // changing password\n    passwordChange = true\n    userUpdateObj.password = await hash(userUpdateObj.password)\n    // Log all other sessions out apart from the current one\n    await platformLogout({\n      ctx,\n      userId: ctx.user._id,\n      keepActiveSession: true,\n    })\n  }\n\n  const response = await db.put({\n    ...user,\n    ...userUpdateObj,\n  })\n  await userCache.invalidateUser(user._id)\n  ctx.body = {\n    _id: response.id,\n    _rev: response.rev,\n  }\n\n  // remove the old password from the user before sending events\n  delete user.password\n  await events.user.updated(user)\n  if (passwordChange) {\n    await events.user.passwordUpdated(user)\n  }\n}\n", "import { checkInviteCode } from \"../../../utilities/redis\"\nimport { users } from \"../../../sdk\"\nimport env from \"../../../environment\"\nimport {\n  BulkDeleteUsersRequest,\n  CloudAccount,\n  InviteUserRequest,\n  InviteUsersRequest,\n  User,\n} from \"@budibase/types\"\nimport {\n  accounts,\n  cache,\n  errors,\n  events,\n  tenancy,\n} from \"@budibase/backend-core\"\nimport { checkAnyUserExists } from \"../../../utilities/users\"\nimport { groups as groupUtils } from \"@budibase/pro\"\n\nconst MAX_USERS_UPLOAD_LIMIT = 1000\n\nexport const save = async (ctx: any) => {\n  try {\n    ctx.body = await users.save(ctx.request.body)\n  } catch (err: any) {\n    ctx.throw(err.status || 400, err)\n  }\n}\n\nexport const bulkCreate = async (ctx: any) => {\n  let { users: newUsersRequested, groups } = ctx.request.body\n\n  if (!env.SELF_HOSTED && newUsersRequested.length > MAX_USERS_UPLOAD_LIMIT) {\n    ctx.throw(\n      400,\n      \"Max limit for upload is 1000 users. Please reduce file size and try again.\"\n    )\n  }\n\n  const db = tenancy.getGlobalDB()\n  let groupsToSave: any[] = []\n\n  if (groups.length) {\n    for (const groupId of groups) {\n      let oldGroup = await db.get(groupId)\n      groupsToSave.push(oldGroup)\n    }\n  }\n\n  try {\n    const response = await users.bulkCreate(newUsersRequested, groups)\n    await groupUtils.bulkSaveGroupUsers(groupsToSave, response.successful)\n\n    ctx.body = response\n  } catch (err: any) {\n    ctx.throw(err.status || 400, err)\n  }\n}\n\nconst parseBooleanParam = (param: any) => {\n  return !(param && param === \"false\")\n}\n\nexport const adminUser = async (ctx: any) => {\n  const { email, password, tenantId } = ctx.request.body\n  await tenancy.doInTenant(tenantId, async () => {\n    // account portal sends a pre-hashed password - honour param to prevent double hashing\n    const hashPassword = parseBooleanParam(ctx.request.query.hashPassword)\n    // account portal sends no password for SSO users\n    const requirePassword = parseBooleanParam(ctx.request.query.requirePassword)\n\n    if (await tenancy.doesTenantExist(tenantId)) {\n      ctx.throw(403, \"Organisation already exists.\")\n    }\n\n    const userExists = await checkAnyUserExists()\n    if (userExists) {\n      ctx.throw(\n        403,\n        \"You cannot initialise once an global user has been created.\"\n      )\n    }\n\n    const user: User = {\n      email: email,\n      password: password,\n      createdAt: Date.now(),\n      roles: {},\n      builder: {\n        global: true,\n      },\n      admin: {\n        global: true,\n      },\n      tenantId,\n    }\n    try {\n      // always bust checklist beforehand, if an error occurs but can proceed, don't get\n      // stuck in a cycle\n      await cache.bustCache(cache.CacheKeys.CHECKLIST)\n      const finalUser = await users.save(user, {\n        hashPassword,\n        requirePassword,\n      })\n\n      // events\n      let account: CloudAccount | undefined\n      if (!env.SELF_HOSTED && !env.DISABLE_ACCOUNT_PORTAL) {\n        account = await accounts.getAccountByTenantId(tenantId)\n      }\n      await events.identification.identifyTenantGroup(tenantId, account)\n\n      ctx.body = finalUser\n    } catch (err: any) {\n      ctx.throw(err.status || 400, err)\n    }\n  })\n}\n\nexport const countByApp = async (ctx: any) => {\n  const appId = ctx.params.appId\n  try {\n    ctx.body = await users.countUsersByApp(appId)\n  } catch (err: any) {\n    ctx.throw(err.status || 400, err)\n  }\n}\n\nexport const destroy = async (ctx: any) => {\n  const id = ctx.params.id\n  if (id === ctx.user._id) {\n    ctx.throw(400, \"Unable to delete self.\")\n  }\n\n  await users.destroy(id, ctx.user)\n\n  ctx.body = {\n    message: `User ${id} deleted.`,\n  }\n}\n\nexport const bulkDelete = async (ctx: any) => {\n  const { userIds } = ctx.request.body as BulkDeleteUsersRequest\n  if (userIds?.indexOf(ctx.user._id) !== -1) {\n    ctx.throw(400, \"Unable to delete self.\")\n  }\n\n  try {\n    ctx.body = await users.bulkDelete(userIds)\n  } catch (err) {\n    ctx.throw(err)\n  }\n}\n\nexport const search = async (ctx: any) => {\n  const paginated = await users.paginatedUsers(ctx.request.body)\n  // user hashed password shouldn't ever be returned\n  for (let user of paginated.data) {\n    if (user) {\n      delete user.password\n    }\n  }\n  ctx.body = paginated\n}\n\n// called internally by app server user fetch\nexport const fetch = async (ctx: any) => {\n  const all = await users.allUsers()\n  // user hashed password shouldn't ever be returned\n  for (let user of all) {\n    if (user) {\n      delete user.password\n    }\n  }\n  ctx.body = all\n}\n\n// called internally by app server user find\nexport const find = async (ctx: any) => {\n  ctx.body = await users.getUser(ctx.params.id)\n}\n\nexport const tenantUserLookup = async (ctx: any) => {\n  const id = ctx.params.id\n  const user = await tenancy.getTenantUser(id)\n  if (user) {\n    ctx.body = user\n  } else {\n    ctx.throw(400, \"No tenant user found.\")\n  }\n}\n\nexport const invite = async (ctx: any) => {\n  const request = ctx.request.body as InviteUserRequest\n  const response = await users.invite([request])\n\n  // explicitly throw for single user invite\n  if (response.unsuccessful.length) {\n    const reason = response.unsuccessful[0].reason\n    if (reason === \"Unavailable\") {\n      ctx.throw(400, reason)\n    } else {\n      ctx.throw(500, reason)\n    }\n  }\n\n  ctx.body = {\n    message: \"Invitation has been sent.\",\n  }\n}\n\nexport const inviteMultiple = async (ctx: any) => {\n  const request = ctx.request.body as InviteUsersRequest\n  ctx.body = await users.invite(request)\n}\n\nexport const inviteAccept = async (ctx: any) => {\n  const { inviteCode, password, firstName, lastName } = ctx.request.body\n  try {\n    // info is an extension of the user object that was stored by global\n    const { email, info }: any = await checkInviteCode(inviteCode)\n    ctx.body = await tenancy.doInTenant(info.tenantId, async () => {\n      const saved = await users.save({\n        firstName,\n        lastName,\n        password,\n        email,\n        ...info,\n      })\n      const db = tenancy.getGlobalDB()\n      const user = await db.get(saved._id)\n      await events.user.inviteAccepted(user)\n      return saved\n    })\n  } catch (err: any) {\n    if (err.code === errors.codes.USAGE_LIMIT_EXCEEDED) {\n      // explicitly re-throw limit exceeded errors\n      ctx.throw(400, err)\n    }\n    ctx.throw(400, \"Unable to create new user, invitation invalid.\")\n  }\n}\n"], "filenames": ["packages/bbui/src/Tooltip/TooltipWrapper.svelte", "packages/builder/src/builderStore/dataBinding.js", "packages/builder/src/helpers/data/utils.js", "packages/builder/src/pages/builder/app/[application]/data/datasource/[selectedDatasource]/rest/[query]/index.svelte", "packages/worker/src/api/controllers/global/self.js", "packages/worker/src/api/controllers/global/users.ts"], "buggy_code_start_loc": [50, 11, 1, 349, 83, 17], "buggy_code_end_loc": [51, 137, 50, 710, 139, 154], "fixing_code_start_loc": [50, 12, 2, 350, 83, 16], "fixing_code_end_loc": [51, 135, 64, 713, 136, 151], "type": "CWE-284", "message": "Improper Access Control in GitHub repository budibase/budibase prior to 1.3.20.", "other": {"cve": {"id": "CVE-2022-3225", "sourceIdentifier": "security@huntr.dev", "published": "2022-09-16T17:15:13.290", "lastModified": "2022-09-19T13:42:17.980", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Improper Access Control in GitHub repository budibase/budibase prior to 1.3.20."}, {"lang": "es", "value": "Un Control de Acceso inapropiado en el repositorio de GitHub budibase/budibase versiones anteriores a 1.3.20"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 5.7, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.1, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-284"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:budibase:budibase:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.3.20", "matchCriteriaId": "89AE1B5B-6459-4D02-9C9E-9E6E7B95B63F"}]}]}], "references": [{"url": "https://github.com/budibase/budibase/commit/d35864be0854216693a01307f81ffcabf6d549df", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/a13a56b7-04da-4560-b8ec-0d637d12a245", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/budibase/budibase/commit/d35864be0854216693a01307f81ffcabf6d549df"}}