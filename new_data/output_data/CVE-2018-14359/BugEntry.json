{"buggy_code": ["/**\n * @file\n * IMAP CRAM-MD5 authentication method\n *\n * @authors\n * Copyright (C) 1999-2001,2005 Brendan Cully <brendan@kublai.com>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page imap_auth_cram IMAP CRAM-MD5 authentication method\n *\n * IMAP CRAM-MD5 authentication method\n */\n\n#include \"config.h\"\n#include <stdio.h>\n#include <string.h>\n#include \"imap_private.h\"\n#include \"mutt/mutt.h\"\n#include \"conn/conn.h\"\n#include \"auth.h\"\n#include \"globals.h\"\n#include \"mutt_account.h\"\n#include \"mutt_socket.h\"\n#include \"options.h\"\n#include \"protos.h\"\n\n#define MD5_BLOCK_LEN 64\n#define MD5_DIGEST_LEN 16\n\n/**\n * hmac_md5 - produce CRAM-MD5 challenge response\n * @param[in]  password  Password to encrypt\n * @param[in]  challenge Challenge from server\n * @param[out] response  Buffer for the response\n */\nstatic void hmac_md5(const char *password, char *challenge, unsigned char *response)\n{\n  struct Md5Ctx ctx;\n  unsigned char ipad[MD5_BLOCK_LEN] = { 0 };\n  unsigned char opad[MD5_BLOCK_LEN] = { 0 };\n  unsigned char secret[MD5_BLOCK_LEN + 1];\n  size_t secret_len;\n\n  secret_len = strlen(password);\n\n  /* passwords longer than MD5_BLOCK_LEN bytes are substituted with their MD5\n   * digests */\n  if (secret_len > MD5_BLOCK_LEN)\n  {\n    unsigned char hash_passwd[MD5_DIGEST_LEN];\n    mutt_md5_bytes(password, secret_len, hash_passwd);\n    mutt_str_strfcpy((char *) secret, (char *) hash_passwd, MD5_DIGEST_LEN);\n    secret_len = MD5_DIGEST_LEN;\n  }\n  else\n    mutt_str_strfcpy((char *) secret, password, sizeof(secret));\n\n  memcpy(ipad, secret, secret_len);\n  memcpy(opad, secret, secret_len);\n\n  for (int i = 0; i < MD5_BLOCK_LEN; i++)\n  {\n    ipad[i] ^= 0x36;\n    opad[i] ^= 0x5c;\n  }\n\n  /* inner hash: challenge and ipadded secret */\n  mutt_md5_init_ctx(&ctx);\n  mutt_md5_process_bytes(ipad, MD5_BLOCK_LEN, &ctx);\n  mutt_md5_process(challenge, &ctx);\n  mutt_md5_finish_ctx(&ctx, response);\n\n  /* outer hash: inner hash and opadded secret */\n  mutt_md5_init_ctx(&ctx);\n  mutt_md5_process_bytes(opad, MD5_BLOCK_LEN, &ctx);\n  mutt_md5_process_bytes(response, MD5_DIGEST_LEN, &ctx);\n  mutt_md5_finish_ctx(&ctx, response);\n}\n\n/**\n * imap_auth_cram_md5 - Authenticate using CRAM-MD5\n * @param idata  Server data\n * @param method Name of this authentication method\n * @retval enum Result, e.g. #IMAP_AUTH_SUCCESS\n */\nenum ImapAuthRes imap_auth_cram_md5(struct ImapData *idata, const char *method)\n{\n  char ibuf[LONG_STRING * 2], obuf[LONG_STRING];\n  unsigned char hmac_response[MD5_DIGEST_LEN];\n  int len;\n  int rc;\n\n  if (!mutt_bit_isset(idata->capabilities, ACRAM_MD5))\n    return IMAP_AUTH_UNAVAIL;\n\n  mutt_message(_(\"Authenticating (CRAM-MD5)...\"));\n\n  /* get auth info */\n  if (mutt_account_getlogin(&idata->conn->account) < 0)\n    return IMAP_AUTH_FAILURE;\n  if (mutt_account_getpass(&idata->conn->account) < 0)\n    return IMAP_AUTH_FAILURE;\n\n  imap_cmd_start(idata, \"AUTHENTICATE CRAM-MD5\");\n\n  /* From RFC2195:\n   * The data encoded in the first ready response contains a presumptively\n   * arbitrary string of random digits, a timestamp, and the fully-qualified\n   * primary host name of the server. The syntax of the unencoded form must\n   * correspond to that of an RFC822 'msg-id' [RFC822] as described in [POP3].\n   */\n  do\n    rc = imap_cmd_step(idata);\n  while (rc == IMAP_CMD_CONTINUE);\n\n  if (rc != IMAP_CMD_RESPOND)\n  {\n    mutt_debug(1, \"Invalid response from server: %s\\n\", ibuf);\n    goto bail;\n  }\n\n  len = mutt_b64_decode(obuf, idata->buf + 2);\n  if (len == -1)\n  {\n    mutt_debug(1, \"Error decoding base64 response.\\n\");\n    goto bail;\n  }\n\n  obuf[len] = '\\0';\n  mutt_debug(2, \"CRAM challenge: %s\\n\", obuf);\n\n  /* The client makes note of the data and then responds with a string\n   * consisting of the user name, a space, and a 'digest'. The latter is\n   * computed by applying the keyed MD5 algorithm from [KEYED-MD5] where the\n   * key is a shared secret and the digested text is the timestamp (including\n   * angle-brackets).\n   *\n   * Note: The user name shouldn't be quoted. Since the digest can't contain\n   *   spaces, there is no ambiguity. Some servers get this wrong, we'll work\n   *   around them when the bug report comes in. Until then, we'll remain\n   *   blissfully RFC-compliant.\n   */\n  hmac_md5(idata->conn->account.pass, obuf, hmac_response);\n  /* dubious optimisation I saw elsewhere: make the whole string in one call */\n  int off = snprintf(obuf, sizeof(obuf), \"%s \", idata->conn->account.user);\n  mutt_md5_toascii(hmac_response, obuf + off);\n  mutt_debug(2, \"CRAM response: %s\\n\", obuf);\n\n  /* ibuf must be long enough to store the base64 encoding of obuf,\n   * plus the additional debris */\n  mutt_b64_encode(ibuf, obuf, strlen(obuf), sizeof(ibuf) - 2);\n  mutt_str_strcat(ibuf, sizeof(ibuf), \"\\r\\n\");\n  mutt_socket_send(idata->conn, ibuf);\n\n  do\n    rc = imap_cmd_step(idata);\n  while (rc == IMAP_CMD_CONTINUE);\n\n  if (rc != IMAP_CMD_OK)\n  {\n    mutt_debug(1, \"Error receiving server response.\\n\");\n    goto bail;\n  }\n\n  if (imap_code(idata->buf))\n    return IMAP_AUTH_SUCCESS;\n\nbail:\n  mutt_error(_(\"CRAM-MD5 authentication failed.\"));\n  return IMAP_AUTH_FAILURE;\n}\n", "/**\n * @file\n * IMAP GSS authentication method\n *\n * @authors\n * Copyright (C) 1999-2001,2005,2009 Brendan Cully <brendan@kublai.com>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page imap_auth_gss IMAP GSS authentication method\n *\n * IMAP GSS authentication method\n *\n * An overview of the authentication method is in RFC 1731.\n *\n * An overview of the C API used is in RFC 2744.\n * Of note is section 3.2, which describes gss_buffer_desc.\n * The length should not include a terminating '\\0' byte, and the client\n * should not expect the value field to be '\\0'terminated.\n */\n\n#include \"config.h\"\n#include <netinet/in.h>\n#include <stdio.h>\n#include <string.h>\n#include \"imap_private.h\"\n#include \"mutt/mutt.h\"\n#include \"conn/conn.h\"\n#include \"mutt.h\"\n#include \"auth.h\"\n#include \"globals.h\"\n#include \"mutt_account.h\"\n#include \"mutt_logging.h\"\n#include \"mutt_socket.h\"\n#include \"options.h\"\n#include \"protos.h\"\n#ifdef HAVE_HEIMDAL\n#include <gssapi/gssapi.h>\n#define gss_nt_service_name GSS_C_NT_HOSTBASED_SERVICE\n#else\n#include <gssapi/gssapi.h>\n#include <gssapi/gssapi_generic.h>\n#endif\n\n#define GSS_BUFSIZE 8192\n\n#define GSS_AUTH_P_NONE 1\n#define GSS_AUTH_P_INTEGRITY 2\n#define GSS_AUTH_P_PRIVACY 4\n\n/**\n * print_gss_error - Print detailed error message to the debug log\n * @param err_maj Error's major number\n * @param err_min Error's minor number\n */\nstatic void print_gss_error(OM_uint32 err_maj, OM_uint32 err_min)\n{\n  OM_uint32 maj_stat, min_stat;\n  OM_uint32 msg_ctx = 0;\n  gss_buffer_desc status_string;\n  char buf_maj[512];\n  char buf_min[512];\n\n  do\n  {\n    maj_stat = gss_display_status(&min_stat, err_maj, GSS_C_GSS_CODE,\n                                  GSS_C_NO_OID, &msg_ctx, &status_string);\n    if (GSS_ERROR(maj_stat))\n      break;\n    size_t status_len = status_string.length;\n    if (status_len >= sizeof(buf_maj))\n      status_len = sizeof(buf_maj) - 1;\n    strncpy(buf_maj, (char *) status_string.value, status_len);\n    buf_maj[status_len] = '\\0';\n    gss_release_buffer(&min_stat, &status_string);\n\n    maj_stat = gss_display_status(&min_stat, err_min, GSS_C_MECH_CODE,\n                                  GSS_C_NULL_OID, &msg_ctx, &status_string);\n    if (!GSS_ERROR(maj_stat))\n    {\n      status_len = status_string.length;\n      if (status_len >= sizeof(buf_min))\n        status_len = sizeof(buf_min) - 1;\n      strncpy(buf_min, (char *) status_string.value, status_len);\n      buf_min[status_len] = '\\0';\n      gss_release_buffer(&min_stat, &status_string);\n    }\n  } while (!GSS_ERROR(maj_stat) && msg_ctx != 0);\n\n  mutt_debug(2, \"((%s:%d )(%s:%d))\\n\", buf_maj, err_maj, buf_min, err_min);\n}\n\n/**\n * imap_auth_gss - GSS Authentication support\n * @param idata  Server data\n * @param method Name of this authentication method\n * @retval enum Result, e.g. #IMAP_AUTH_SUCCESS\n */\nenum ImapAuthRes imap_auth_gss(struct ImapData *idata, const char *method)\n{\n  gss_buffer_desc request_buf, send_token;\n  gss_buffer_t sec_token;\n  gss_name_t target_name;\n  gss_ctx_id_t context;\n  gss_OID mech_name;\n  char server_conf_flags;\n  gss_qop_t quality;\n  int cflags;\n  OM_uint32 maj_stat, min_stat;\n  char buf1[GSS_BUFSIZE], buf2[GSS_BUFSIZE];\n  unsigned long buf_size;\n  int rc;\n\n  if (!mutt_bit_isset(idata->capabilities, AGSSAPI))\n    return IMAP_AUTH_UNAVAIL;\n\n  if (mutt_account_getuser(&idata->conn->account) < 0)\n    return IMAP_AUTH_FAILURE;\n\n  /* get an IMAP service ticket for the server */\n  snprintf(buf1, sizeof(buf1), \"imap@%s\", idata->conn->account.host);\n  request_buf.value = buf1;\n  request_buf.length = strlen(buf1);\n  maj_stat = gss_import_name(&min_stat, &request_buf, gss_nt_service_name, &target_name);\n  if (maj_stat != GSS_S_COMPLETE)\n  {\n    mutt_debug(2, \"Couldn't get service name for [%s]\\n\", buf1);\n    return IMAP_AUTH_UNAVAIL;\n  }\n  else if (DebugLevel >= 2)\n  {\n    gss_display_name(&min_stat, target_name, &request_buf, &mech_name);\n    mutt_debug(2, \"Using service name [%s]\\n\", (char *) request_buf.value);\n    gss_release_buffer(&min_stat, &request_buf);\n  }\n  /* Acquire initial credentials - without a TGT GSSAPI is UNAVAIL */\n  sec_token = GSS_C_NO_BUFFER;\n  context = GSS_C_NO_CONTEXT;\n\n  /* build token */\n  maj_stat = gss_init_sec_context(&min_stat, GSS_C_NO_CREDENTIAL, &context, target_name,\n                                  GSS_C_NO_OID, GSS_C_MUTUAL_FLAG | GSS_C_SEQUENCE_FLAG,\n                                  0, GSS_C_NO_CHANNEL_BINDINGS, sec_token, NULL,\n                                  &send_token, (unsigned int *) &cflags, NULL);\n  if (maj_stat != GSS_S_COMPLETE && maj_stat != GSS_S_CONTINUE_NEEDED)\n  {\n    print_gss_error(maj_stat, min_stat);\n    mutt_debug(1, \"Error acquiring credentials - no TGT?\\n\");\n    gss_release_name(&min_stat, &target_name);\n\n    return IMAP_AUTH_UNAVAIL;\n  }\n\n  /* now begin login */\n  mutt_message(_(\"Authenticating (GSSAPI)...\"));\n\n  imap_cmd_start(idata, \"AUTHENTICATE GSSAPI\");\n\n  /* expect a null continuation response (\"+\") */\n  do\n    rc = imap_cmd_step(idata);\n  while (rc == IMAP_CMD_CONTINUE);\n\n  if (rc != IMAP_CMD_RESPOND)\n  {\n    mutt_debug(2, \"Invalid response from server: %s\\n\", buf1);\n    gss_release_name(&min_stat, &target_name);\n    goto bail;\n  }\n\n  /* now start the security context initialisation loop... */\n  mutt_debug(2, \"Sending credentials\\n\");\n  mutt_b64_encode(buf1, send_token.value, send_token.length, sizeof(buf1) - 2);\n  gss_release_buffer(&min_stat, &send_token);\n  mutt_str_strcat(buf1, sizeof(buf1), \"\\r\\n\");\n  mutt_socket_send(idata->conn, buf1);\n\n  while (maj_stat == GSS_S_CONTINUE_NEEDED)\n  {\n    /* Read server data */\n    do\n      rc = imap_cmd_step(idata);\n    while (rc == IMAP_CMD_CONTINUE);\n\n    if (rc != IMAP_CMD_RESPOND)\n    {\n      mutt_debug(1, \"#1 Error receiving server response.\\n\");\n      gss_release_name(&min_stat, &target_name);\n      goto bail;\n    }\n\n    request_buf.length = mutt_b64_decode(buf2, idata->buf + 2);\n    request_buf.value = buf2;\n    sec_token = &request_buf;\n\n    /* Write client data */\n    maj_stat = gss_init_sec_context(\n        &min_stat, GSS_C_NO_CREDENTIAL, &context, target_name, GSS_C_NO_OID,\n        GSS_C_MUTUAL_FLAG | GSS_C_SEQUENCE_FLAG, 0, GSS_C_NO_CHANNEL_BINDINGS,\n        sec_token, NULL, &send_token, (unsigned int *) &cflags, NULL);\n    if (maj_stat != GSS_S_COMPLETE && maj_stat != GSS_S_CONTINUE_NEEDED)\n    {\n      print_gss_error(maj_stat, min_stat);\n      mutt_debug(1, \"Error exchanging credentials\\n\");\n      gss_release_name(&min_stat, &target_name);\n\n      goto err_abort_cmd;\n    }\n    mutt_b64_encode(buf1, send_token.value, send_token.length, sizeof(buf1) - 2);\n    gss_release_buffer(&min_stat, &send_token);\n    mutt_str_strcat(buf1, sizeof(buf1), \"\\r\\n\");\n    mutt_socket_send(idata->conn, buf1);\n  }\n\n  gss_release_name(&min_stat, &target_name);\n\n  /* get security flags and buffer size */\n  do\n    rc = imap_cmd_step(idata);\n  while (rc == IMAP_CMD_CONTINUE);\n\n  if (rc != IMAP_CMD_RESPOND)\n  {\n    mutt_debug(1, \"#2 Error receiving server response.\\n\");\n    goto bail;\n  }\n  request_buf.length = mutt_b64_decode(buf2, idata->buf + 2);\n  request_buf.value = buf2;\n\n  maj_stat = gss_unwrap(&min_stat, context, &request_buf, &send_token, &cflags, &quality);\n  if (maj_stat != GSS_S_COMPLETE)\n  {\n    print_gss_error(maj_stat, min_stat);\n    mutt_debug(2, \"Couldn't unwrap security level data\\n\");\n    gss_release_buffer(&min_stat, &send_token);\n    goto err_abort_cmd;\n  }\n  mutt_debug(2, \"Credential exchange complete\\n\");\n\n  /* first octet is security levels supported. We want NONE */\n  server_conf_flags = ((char *) send_token.value)[0];\n  if (!(((char *) send_token.value)[0] & GSS_AUTH_P_NONE))\n  {\n    mutt_debug(2, \"Server requires integrity or privacy\\n\");\n    gss_release_buffer(&min_stat, &send_token);\n    goto err_abort_cmd;\n  }\n\n  /* we don't care about buffer size if we don't wrap content. But here it is */\n  ((char *) send_token.value)[0] = '\\0';\n  buf_size = ntohl(*((long *) send_token.value));\n  gss_release_buffer(&min_stat, &send_token);\n  mutt_debug(2, \"Unwrapped security level flags: %c%c%c\\n\",\n             (server_conf_flags & GSS_AUTH_P_NONE) ? 'N' : '-',\n             (server_conf_flags & GSS_AUTH_P_INTEGRITY) ? 'I' : '-',\n             (server_conf_flags & GSS_AUTH_P_PRIVACY) ? 'P' : '-');\n  mutt_debug(2, \"Maximum GSS token size is %ld\\n\", buf_size);\n\n  /* agree to terms (hack!) */\n  buf_size = htonl(buf_size); /* not relevant without integrity/privacy */\n  memcpy(buf1, &buf_size, 4);\n  buf1[0] = GSS_AUTH_P_NONE;\n  /* server decides if principal can log in as user */\n  strncpy(buf1 + 4, idata->conn->account.user, sizeof(buf1) - 4);\n  request_buf.value = buf1;\n  request_buf.length = 4 + strlen(idata->conn->account.user);\n  maj_stat = gss_wrap(&min_stat, context, 0, GSS_C_QOP_DEFAULT, &request_buf,\n                      &cflags, &send_token);\n  if (maj_stat != GSS_S_COMPLETE)\n  {\n    mutt_debug(2, \"Error creating login request\\n\");\n    goto err_abort_cmd;\n  }\n\n  mutt_b64_encode(buf1, send_token.value, send_token.length, sizeof(buf1) - 2);\n  mutt_debug(2, \"Requesting authorisation as %s\\n\", idata->conn->account.user);\n  mutt_str_strcat(buf1, sizeof(buf1), \"\\r\\n\");\n  mutt_socket_send(idata->conn, buf1);\n\n  /* Joy of victory or agony of defeat? */\n  do\n    rc = imap_cmd_step(idata);\n  while (rc == IMAP_CMD_CONTINUE);\n  if (rc == IMAP_CMD_RESPOND)\n  {\n    mutt_debug(1, \"Unexpected server continuation request.\\n\");\n    goto err_abort_cmd;\n  }\n  if (imap_code(idata->buf))\n  {\n    /* flush the security context */\n    mutt_debug(2, \"Releasing GSS credentials\\n\");\n    maj_stat = gss_delete_sec_context(&min_stat, &context, &send_token);\n    if (maj_stat != GSS_S_COMPLETE)\n      mutt_debug(1, \"Error releasing credentials\\n\");\n\n    /* send_token may contain a notification to the server to flush\n     * credentials. RFC1731 doesn't specify what to do, and since this\n     * support is only for authentication, we'll assume the server knows\n     * enough to flush its own credentials */\n    gss_release_buffer(&min_stat, &send_token);\n\n    return IMAP_AUTH_SUCCESS;\n  }\n  else\n    goto bail;\n\nerr_abort_cmd:\n  mutt_socket_send(idata->conn, \"*\\r\\n\");\n  do\n    rc = imap_cmd_step(idata);\n  while (rc == IMAP_CMD_CONTINUE);\n\nbail:\n  mutt_error(_(\"GSSAPI authentication failed.\"));\n  return IMAP_AUTH_FAILURE;\n}\n", "/**\n * @file\n * Conversion to/from base64 encoding\n *\n * @authors\n * Copyright (C) 1993,1995 Carl Harris\n * Copyright (C) 1997 Eric S. Raymond\n * Copyright (C) 1999 Brendan Cully <brendan@kublai.com>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page base64 Conversion to/from base64 encoding\n *\n * Convert between binary data and base64 text, according to RFC2045.\n *\n * @note RFC3548 obsoletes RFC2045.\n * @note RFC4648 obsoletes RFC3548.\n */\n\n#include \"config.h\"\n#include \"base64.h\"\n\n#define BAD -1\n\n/**\n * B64Chars - Characters of the Base64 encoding\n */\nstatic const char B64Chars[64] = {\n  'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n  'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n  'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n  'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n  '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/',\n};\n\n// clang-format off\n/**\n * Index64 - Lookup table for Base64 encoding characters\n *\n * @note This is very similar to the table in imap/utf7.c\n *\n * Encoding chars:\n * * utf7 A-Za-z0-9+,\n * * mime A-Za-z0-9+/\n */\nconst int Index64[128] = {\n    -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1,\n    -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1,\n    -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,62, -1,-1,-1,63,\n    52,53,54,55, 56,57,58,59, 60,61,-1,-1, -1,-1,-1,-1,\n    -1, 0, 1, 2,  3, 4, 5, 6,  7, 8, 9,10, 11,12,13,14,\n    15,16,17,18, 19,20,21,22, 23,24,25,-1, -1,-1,-1,-1,\n    -1,26,27,28, 29,30,31,32, 33,34,35,36, 37,38,39,40,\n    41,42,43,44, 45,46,47,48, 49,50,51,-1, -1,-1,-1,-1\n};\n// clang-format on\n\n/**\n * mutt_b64_encode - Convert raw bytes to null-terminated base64 string\n * @param out  Output buffer for the base64 encoded string\n * @param cin  Input  buffer for the raw bytes\n * @param len  Length of the input buffer\n * @param olen Length of the output buffer\n * @retval num Length of the string written to the output buffer\n *\n * This function performs base64 encoding. The resulting string is guaranteed\n * to be null-terminated. The number of characters up to the terminating\n * null-byte is returned (equivalent to calling strlen() on the output buffer\n * after this function returns).\n */\nsize_t mutt_b64_encode(char *out, const char *cin, size_t len, size_t olen)\n{\n  unsigned char *begin = (unsigned char *) out;\n  const unsigned char *in = (const unsigned char *) cin;\n\n  while ((len >= 3) && (olen > 10))\n  {\n    *out++ = B64Chars[in[0] >> 2];\n    *out++ = B64Chars[((in[0] << 4) & 0x30) | (in[1] >> 4)];\n    *out++ = B64Chars[((in[1] << 2) & 0x3c) | (in[2] >> 6)];\n    *out++ = B64Chars[in[2] & 0x3f];\n    olen -= 4;\n    len -= 3;\n    in += 3;\n  }\n\n  /* clean up remainder */\n  if ((len > 0) && (olen > 4))\n  {\n    unsigned char fragment;\n\n    *out++ = B64Chars[in[0] >> 2];\n    fragment = (in[0] << 4) & 0x30;\n    if (len > 1)\n      fragment |= in[1] >> 4;\n    *out++ = B64Chars[fragment];\n    *out++ = (len < 2) ? '=' : B64Chars[(in[1] << 2) & 0x3c];\n    *out++ = '=';\n  }\n  *out = '\\0';\n  return (out - (char *) begin);\n}\n\n/**\n * mutt_b64_decode - Convert null-terminated base64 string to raw bytes\n * @param out Output buffer for the raw bytes\n * @param in  Input  buffer for the null-terminated base64-encoded string\n * @retval num Success, bytes written\n * @retval -1  Error\n *\n * This function performs base64 decoding. The resulting buffer is NOT\n * null-terminated. If the input buffer contains invalid base64 characters,\n * this function returns -1.\n */\nint mutt_b64_decode(char *out, const char *in)\n{\n  int len = 0;\n  unsigned char digit4;\n\n  do\n  {\n    const unsigned char digit1 = in[0];\n    if ((digit1 > 127) || (base64val(digit1) == BAD))\n      return -1;\n    const unsigned char digit2 = in[1];\n    if ((digit2 > 127) || (base64val(digit2) == BAD))\n      return -1;\n    const unsigned char digit3 = in[2];\n    if ((digit3 > 127) || ((digit3 != '=') && (base64val(digit3) == BAD)))\n      return -1;\n    digit4 = in[3];\n    if ((digit4 > 127) || ((digit4 != '=') && (base64val(digit4) == BAD)))\n      return -1;\n    in += 4;\n\n    /* digits are already sanity-checked */\n    *out++ = (base64val(digit1) << 2) | (base64val(digit2) >> 4);\n    len++;\n    if (digit3 != '=')\n    {\n      *out++ = ((base64val(digit2) << 4) & 0xf0) | (base64val(digit3) >> 2);\n      len++;\n      if (digit4 != '=')\n      {\n        *out++ = ((base64val(digit3) << 6) & 0xc0) | base64val(digit4);\n        len++;\n      }\n    }\n  } while (*in && digit4 != '=');\n\n  return len;\n}\n", "/**\n * @file\n * Conversion to/from base64 encoding\n *\n * @authors\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef _MUTT_BASE64_H\n#define _MUTT_BASE64_H\n\n#include <stdio.h>\n\nextern const int Index64[];\n\n#define base64val(c) Index64[(unsigned int) (c)]\n\nsize_t mutt_b64_encode(char *out, const char *cin, size_t len, size_t olen);\nint    mutt_b64_decode(char *out, const char *in);\n\n#endif /* _MUTT_BASE64_H */\n", "/**\n * @file\n * RFC2047 MIME extensions encoding / decoding routines\n *\n * @authors\n * Copyright (C) 1996-2000,2010 Michael R. Elkins <me@mutt.org>\n * Copyright (C) 2000-2002 Edmund Grimley Evans <edmundo@rano.org>\n * Copyright (C) 2018 Pietro Cerutti <gahr@gahr.ch>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page rfc2047 RFC2047 encoding / decoding functions\n *\n * RFC2047 MIME extensions encoding / decoding routines.\n */\n\n#include \"config.h\"\n#include <assert.h>\n#include <errno.h>\n#include <stdbool.h>\n#include <string.h>\n#include \"rfc2047.h\"\n#include \"base64.h\"\n#include \"buffer.h\"\n#include \"charset.h\"\n#include \"mbyte.h\"\n#include \"memory.h\"\n#include \"mime.h\"\n#include \"regex3.h\"\n#include \"string2.h\"\n\n#define ENCWORD_LEN_MAX 75\n#define ENCWORD_LEN_MIN 9 /* strlen (\"=?.?.?.?=\") */\n\n#define HSPACE(x) (((x) == '\\0') || ((x) == ' ') || ((x) == '\\t'))\n\n#define CONTINUATION_BYTE(c) (((c) &0xc0) == 0x80)\n\ntypedef size_t (*encoder_t)(char *str, const char *buf, size_t buflen, const char *tocode);\n\n/**\n * b_encoder - Base64 Encode a string\n * @param str    String to encode\n * @param buf    Buffer for result\n * @param buflen Length of buffer\n * @param tocode Character encoding\n * @retval num Bytes written to buffer\n */\nstatic size_t b_encoder(char *str, const char *buf, size_t buflen, const char *tocode)\n{\n  char *s0 = str;\n\n  memcpy(str, \"=?\", 2);\n  str += 2;\n  memcpy(str, tocode, strlen(tocode));\n  str += strlen(tocode);\n  memcpy(str, \"?B?\", 3);\n  str += 3;\n\n  while (buflen)\n  {\n    char encoded[11];\n    size_t ret;\n    size_t in_len = MIN(3, buflen);\n\n    ret = mutt_b64_encode(encoded, buf, in_len, sizeof(encoded));\n    for (size_t i = 0; i < ret; i++)\n      *str++ = encoded[i];\n\n    buflen -= in_len;\n    buf += in_len;\n  }\n\n  memcpy(str, \"?=\", 2);\n  str += 2;\n  return (str - s0);\n}\n\n/**\n * q_encoder - Quoted-printable Encode a string\n * @param str    String to encode\n * @param buf    Buffer for result\n * @param buflen Length of buffer\n * @param tocode Character encoding\n * @retval num Bytes written to buffer\n */\nstatic size_t q_encoder(char *str, const char *buf, size_t buflen, const char *tocode)\n{\n  static const char hex[] = \"0123456789ABCDEF\";\n  char *s0 = str;\n\n  memcpy(str, \"=?\", 2);\n  str += 2;\n  memcpy(str, tocode, strlen(tocode));\n  str += strlen(tocode);\n  memcpy(str, \"?Q?\", 3);\n  str += 3;\n  while (buflen--)\n  {\n    unsigned char c = *buf++;\n    if (c == ' ')\n      *str++ = '_';\n    else if ((c >= 0x7f) || (c < 0x20) || (c == '_') || strchr(MimeSpecials, c))\n    {\n      *str++ = '=';\n      *str++ = hex[(c & 0xf0) >> 4];\n      *str++ = hex[c & 0x0f];\n    }\n    else\n      *str++ = c;\n  }\n  memcpy(str, \"?=\", 2);\n  str += 2;\n  return (str - s0);\n}\n\n/**\n * parse_encoded_word - Parse a string and report RFC2047 elements\n * @param[in]  str        String to parse\n * @param[out] enc        Content encoding found in the first RFC2047 word\n * @param[out] charset    Charset found in the first RFC2047 word\n * @param[out] charsetlen Length of the charset string found\n * @param[out] text       Start of the first RFC2047 encoded text\n * @param[out] textlen    Length of the encoded text found\n * @retval ptr Start of the RFC2047 encoded word\n * @retval NULL None was found\n */\nstatic char *parse_encoded_word(char *str, enum ContentEncoding *enc, char **charset,\n                                size_t *charsetlen, char **text, size_t *textlen)\n{\n  static struct Regex *re = NULL;\n  regmatch_t match[4];\n  size_t nmatch = 4;\n\n  if (re == NULL)\n  {\n    re = mutt_regex_compile(\"=\\\\?\"\n                            \"([^][()<>@,;:\\\\\\\"/?. =]+)\" /* charset */\n                            \"\\\\?\"\n                            \"([qQbB])\" /* encoding */\n                            \"\\\\?\"\n                            \"([^?]+)\" /* encoded text - we accept whitespace\n                                         as some mailers do that, see #1189. */\n                            \"\\\\?=\",\n                            REG_EXTENDED);\n    assert(re && \"Something is wrong with your RE engine.\");\n  }\n\n  int rc = regexec(re->regex, str, nmatch, match, 0);\n  if (rc != 0)\n    return NULL;\n\n  /* Charset */\n  *charset = str + match[1].rm_so;\n  *charsetlen = match[1].rm_eo - match[1].rm_so;\n\n  /* Encoding: either Q or B */\n  *enc = ((str[match[2].rm_so] == 'Q') || (str[match[2].rm_so] == 'q')) ?\n             ENCQUOTEDPRINTABLE :\n             ENCBASE64;\n\n  *text = str + match[3].rm_so;\n  *textlen = match[3].rm_eo - match[3].rm_so;\n  return (str + match[0].rm_so);\n}\n\n/**\n * try_block - Attempt to convert a block of text\n * @param d        String to convert\n * @param dlen     Length of string\n * @param fromcode Original encoding\n * @param tocode   New encoding\n * @param encoder  Encoding function\n * @param wlen     Number of characters converted\n * @retval  0 Success, string converted\n * @retval >0 Error, number of bytes that could be converted\n *\n * If the data could be conveted using encoder, then set *encoder and *wlen.\n * Otherwise return an upper bound on the maximum length of the data which\n * could be converted.\n *\n * The data is converted from fromcode (which must be stateless) to tocode,\n * unless fromcode is NULL, in which case the data is assumed to be already in\n * tocode, which should be 8-bit and stateless.\n */\nstatic size_t try_block(const char *d, size_t dlen, const char *fromcode,\n                        const char *tocode, encoder_t *encoder, size_t *wlen)\n{\n  char buf[ENCWORD_LEN_MAX - ENCWORD_LEN_MIN + 1];\n  const char *ib = NULL;\n  char *ob = NULL;\n  size_t ibl, obl;\n  int count, len, len_b, len_q;\n\n  if (fromcode)\n  {\n    iconv_t cd = mutt_ch_iconv_open(tocode, fromcode, 0);\n    assert(cd != (iconv_t)(-1));\n    ib = d;\n    ibl = dlen;\n    ob = buf;\n    obl = sizeof(buf) - strlen(tocode);\n    if (iconv(cd, (ICONV_CONST char **) &ib, &ibl, &ob, &obl) == (size_t)(-1) ||\n        iconv(cd, NULL, NULL, &ob, &obl) == (size_t)(-1))\n    {\n      assert(errno == E2BIG);\n      iconv_close(cd);\n      assert(ib > d);\n      return (ib - d == dlen) ? dlen : ib - d + 1;\n    }\n    iconv_close(cd);\n  }\n  else\n  {\n    if (dlen > (sizeof(buf) - strlen(tocode)))\n      return (sizeof(buf) - strlen(tocode) + 1);\n    memcpy(buf, d, dlen);\n    ob = buf + dlen;\n  }\n\n  count = 0;\n  for (char *p = buf; p < ob; p++)\n  {\n    unsigned char c = *p;\n    assert(strchr(MimeSpecials, '?'));\n    if ((c >= 0x7f) || (c < 0x20) || (*p == '_') ||\n        ((c != ' ') && strchr(MimeSpecials, *p)))\n    {\n      count++;\n    }\n  }\n\n  len = ENCWORD_LEN_MIN - 2 + strlen(tocode);\n  len_b = len + (((ob - buf) + 2) / 3) * 4;\n  len_q = len + (ob - buf) + 2 * count;\n\n  /* Apparently RFC1468 says to use B encoding for iso-2022-jp. */\n  if (mutt_str_strcasecmp(tocode, \"ISO-2022-JP\") == 0)\n    len_q = ENCWORD_LEN_MAX + 1;\n\n  if ((len_b < len_q) && (len_b <= ENCWORD_LEN_MAX))\n  {\n    *encoder = b_encoder;\n    *wlen = len_b;\n    return 0;\n  }\n  else if (len_q <= ENCWORD_LEN_MAX)\n  {\n    *encoder = q_encoder;\n    *wlen = len_q;\n    return 0;\n  }\n  else\n    return dlen;\n}\n\n/**\n * encode_block - Encode a block of text using an encoder\n * @param str      String to convert\n * @param buf      Buffer for result\n * @param buflen   Buffer length\n * @param fromcode Original encoding\n * @param tocode   New encoding\n * @param encoder  Encoding function\n * @retval num Length of the encoded word\n *\n * Encode the data (buf, buflen) into str using the encoder.\n */\nstatic size_t encode_block(char *str, char *buf, size_t buflen, const char *fromcode,\n                           const char *tocode, encoder_t encoder)\n{\n  if (!fromcode)\n  {\n    return (*encoder)(str, buf, buflen, tocode);\n  }\n\n  const iconv_t cd = mutt_ch_iconv_open(tocode, fromcode, 0);\n  assert(cd != (iconv_t)(-1));\n  const char *ib = buf;\n  size_t ibl = buflen;\n  char tmp[ENCWORD_LEN_MAX - ENCWORD_LEN_MIN + 1];\n  char *ob = tmp;\n  size_t obl = sizeof(tmp) - strlen(tocode);\n  const size_t n1 = iconv(cd, (ICONV_CONST char **) &ib, &ibl, &ob, &obl);\n  const size_t n2 = iconv(cd, NULL, NULL, &ob, &obl);\n  assert(n1 != (size_t)(-1) && n2 != (size_t)(-1));\n  iconv_close(cd);\n  return (*encoder)(str, tmp, ob - tmp, tocode);\n}\n\n/**\n * choose_block - Calculate how much data can be converted\n * @param d        String to convert\n * @param dlen     Length of string\n * @param col      Starting column to convert\n * @param fromcode Original encoding\n * @param tocode   New encoding\n * @param encoder  Encoding function\n * @param wlen     Number of characters converted\n * @retval num Bytes that can be converted\n *\n * Discover how much of the data (d, dlen) can be converted into a single\n * encoded word. Return how much data can be converted, and set the length\n * *wlen of the encoded word and *encoder.  We start in column col, which\n * limits the length of the word.\n */\nstatic size_t choose_block(char *d, size_t dlen, int col, const char *fromcode,\n                           const char *tocode, encoder_t *encoder, size_t *wlen)\n{\n  const int utf8 = fromcode && (mutt_str_strcasecmp(fromcode, \"utf-8\") == 0);\n\n  size_t n = dlen;\n  while (true)\n  {\n    assert(n > 0);\n    const size_t nn = try_block(d, n, fromcode, tocode, encoder, wlen);\n    if ((nn == 0) && ((col + *wlen) <= (ENCWORD_LEN_MAX + 1) || (n <= 1)))\n      break;\n    n = (nn ? nn : n) - 1;\n    assert(n > 0);\n    if (utf8)\n      while ((n > 1) && CONTINUATION_BYTE(d[n]))\n        n--;\n  }\n  return n;\n}\n\n/**\n * finalize_chunk - Perform charset conversion and filtering\n * @param[out] res        Buffer where the resulting string is appended\n * @param[in]  buf        Buffer with the input string\n * @param[in]  charset    Charset to use for the conversion\n * @param[in]  charsetlen Length of the charset parameter\n *\n * The buffer buf is reinitialized at the end of this function.\n */\nstatic void finalize_chunk(struct Buffer *res, struct Buffer *buf, char *charset, size_t charsetlen)\n{\n  char end = charset[charsetlen];\n  charset[charsetlen] = '\\0';\n  mutt_ch_convert_string(&buf->data, charset, Charset, MUTT_ICONV_HOOK_FROM);\n  charset[charsetlen] = end;\n  mutt_mb_filter_unprintable(&buf->data);\n  mutt_buffer_addstr(res, buf->data);\n  FREE(&buf->data);\n  mutt_buffer_init(buf);\n}\n\n/**\n * rfc2047_decode_word - Decode an RFC2047-encoded string\n * @param s   String to decode\n * @param len Length of the string\n * @param enc Encoding type\n * @retval ptr Decoded string\n *\n * @note The caller must free the returned string\n */\nstatic char *rfc2047_decode_word(const char *s, size_t len, enum ContentEncoding enc)\n{\n  const char *it = s;\n  const char *end = s + len;\n\n  if (enc == ENCQUOTEDPRINTABLE)\n  {\n    struct Buffer buf = { 0 };\n    for (; it < end; ++it)\n    {\n      if (*it == '_')\n      {\n        mutt_buffer_addch(&buf, ' ');\n      }\n      else if ((*it == '=') && (!(it[1] & ~127) && hexval(it[1]) != -1) &&\n               (!(it[2] & ~127) && hexval(it[2]) != -1))\n      {\n        mutt_buffer_addch(&buf, (hexval(it[1]) << 4) | hexval(it[2]));\n        it += 2;\n      }\n      else\n      {\n        mutt_buffer_addch(&buf, *it);\n      }\n    }\n    mutt_buffer_addch(&buf, '\\0');\n    return buf.data;\n  }\n  else if (enc == ENCBASE64)\n  {\n    char *out = mutt_mem_malloc(3 * len / 4 + 1);\n    int dlen = mutt_b64_decode(out, it);\n    if (dlen == -1)\n    {\n      FREE(&out);\n      return NULL;\n    }\n    out[dlen] = '\\0';\n    return out;\n  }\n\n  assert(0); /* The enc parameter has an invalid value */\n  return NULL;\n}\n\n/**\n * rfc2047_encode - RFC2047-encode a string\n * @param d        String to convert\n * @param dlen     Length of string\n * @param col      Starting column to convert\n * @param fromcode Original encoding\n * @param charsets List of allowable encodings (colon separated)\n * @param e        Encoded string\n * @param elen     Length of encoded string\n * @param specials Special characters to be encoded\n * @retval 0 Success\n */\nstatic int rfc2047_encode(const char *d, size_t dlen, int col, const char *fromcode,\n                          const char *charsets, char **e, size_t *elen, const char *specials)\n{\n  int rc = 0;\n  char *buf = NULL;\n  size_t bufpos, buflen;\n  char *t0 = NULL, *t1 = NULL, *t = NULL;\n  char *s0 = NULL, *s1 = NULL;\n  size_t ulen, r, wlen = 0;\n  encoder_t encoder = NULL;\n  char *tocode1 = NULL;\n  const char *tocode = NULL;\n  char *icode = \"utf-8\";\n\n  /* Try to convert to UTF-8. */\n  char *u = mutt_str_substr_dup(d, d + dlen);\n  if (mutt_ch_convert_string(&u, fromcode, icode, 0) != 0)\n  {\n    rc = 1;\n    icode = 0;\n  }\n  ulen = mutt_str_strlen(u);\n\n  /* Find earliest and latest things we must encode. */\n  s0 = s1 = t0 = t1 = 0;\n  for (t = u; t < (u + ulen); t++)\n  {\n    if ((*t & 0x80) || ((*t == '=') && (t[1] == '?') && ((t == u) || HSPACE(*(t - 1)))))\n    {\n      if (!t0)\n        t0 = t;\n      t1 = t;\n    }\n    else if (specials && *t && strchr(specials, *t))\n    {\n      if (!s0)\n        s0 = t;\n      s1 = t;\n    }\n  }\n\n  /* If we have something to encode, include RFC822 specials */\n  if (t0 && s0 && (s0 < t0))\n    t0 = s0;\n  if (t1 && s1 && (s1 > t1))\n    t1 = s1;\n\n  if (!t0)\n  {\n    /* No encoding is required. */\n    *e = u;\n    *elen = ulen;\n    return rc;\n  }\n\n  /* Choose target charset. */\n  tocode = fromcode;\n  if (icode)\n  {\n    tocode1 = mutt_ch_choose(icode, charsets, u, ulen, 0, 0);\n    if (tocode1)\n      tocode = tocode1;\n    else\n    {\n      rc = 2;\n      icode = 0;\n    }\n  }\n\n  /* Hack to avoid labelling 8-bit data as us-ascii. */\n  if (!icode && mutt_ch_is_us_ascii(tocode))\n    tocode = \"unknown-8bit\";\n\n  /* Adjust t0 for maximum length of line. */\n  t = u + (ENCWORD_LEN_MAX + 1) - col - ENCWORD_LEN_MIN;\n  if (t < u)\n    t = u;\n  if (t < t0)\n    t0 = t;\n\n  /* Adjust t0 until we can encode a character after a space. */\n  for (; t0 > u; t0--)\n  {\n    if (!HSPACE(*(t0 - 1)))\n      continue;\n    t = t0 + 1;\n    if (icode)\n      while ((t < (u + ulen)) && CONTINUATION_BYTE(*t))\n        t++;\n    if ((try_block(t0, t - t0, icode, tocode, &encoder, &wlen) == 0) &&\n        ((col + (t0 - u) + wlen) <= (ENCWORD_LEN_MAX + 1)))\n    {\n      break;\n    }\n  }\n\n  /* Adjust t1 until we can encode a character before a space. */\n  for (; t1 < (u + ulen); t1++)\n  {\n    if (!HSPACE(*t1))\n      continue;\n    t = t1 - 1;\n    if (icode)\n      while (CONTINUATION_BYTE(*t))\n        t--;\n    if ((try_block(t, t1 - t, icode, tocode, &encoder, &wlen) == 0) &&\n        ((1 + wlen + (u + ulen - t1)) <= (ENCWORD_LEN_MAX + 1)))\n    {\n      break;\n    }\n  }\n\n  /* We shall encode the region [t0,t1). */\n\n  /* Initialise the output buffer with the us-ascii prefix. */\n  buflen = 2 * ulen;\n  buf = mutt_mem_malloc(buflen);\n  bufpos = t0 - u;\n  memcpy(buf, u, t0 - u);\n\n  col += t0 - u;\n\n  t = t0;\n  while (true)\n  {\n    /* Find how much we can encode. */\n    size_t n = choose_block(t, t1 - t, col, icode, tocode, &encoder, &wlen);\n    if (n == (t1 - t))\n    {\n      /* See if we can fit the us-ascii suffix, too. */\n      if ((col + wlen + (u + ulen - t1)) <= (ENCWORD_LEN_MAX + 1))\n        break;\n      n = t1 - t - 1;\n      if (icode)\n        while (CONTINUATION_BYTE(t[n]))\n          n--;\n      if (!n)\n      {\n        /* This should only happen in the really stupid case where the\n           only word that needs encoding is one character long, but\n           there is too much us-ascii stuff after it to use a single\n           encoded word. We add the next word to the encoded region\n           and try again. */\n        assert(t1 < (u + ulen));\n        for (t1++; (t1 < (u + ulen)) && !HSPACE(*t1); t1++)\n          ;\n        continue;\n      }\n      n = choose_block(t, n, col, icode, tocode, &encoder, &wlen);\n    }\n\n    /* Add to output buffer. */\n    const char *line_break = \"\\n\\t\";\n    const int lb_len = 2; /* strlen(line_break) */\n\n    if ((bufpos + wlen + lb_len) > buflen)\n    {\n      buflen = bufpos + wlen + lb_len;\n      mutt_mem_realloc(&buf, buflen);\n    }\n    r = encode_block(buf + bufpos, t, n, icode, tocode, encoder);\n    assert(r == wlen);\n    bufpos += wlen;\n    memcpy(buf + bufpos, line_break, lb_len);\n    bufpos += lb_len;\n\n    col = 1;\n\n    t += n;\n  }\n\n  /* Add last encoded word and us-ascii suffix to buffer. */\n  buflen = bufpos + wlen + (u + ulen - t1);\n  mutt_mem_realloc(&buf, buflen + 1);\n  r = encode_block(buf + bufpos, t, t1 - t, icode, tocode, encoder);\n  assert(r == wlen);\n  bufpos += wlen;\n  memcpy(buf + bufpos, t1, u + ulen - t1);\n\n  FREE(&tocode1);\n  FREE(&u);\n\n  buf[buflen] = '\\0';\n\n  *e = buf;\n  *elen = buflen + 1;\n  return rc;\n}\n\n/**\n * mutt_rfc2047_encode - RFC-2047-encode a string\n * @param[in,out] pd       String to be encoded, and resulting encoded string\n * @param[in]     specials Special characters to be encoded\n * @param[in]     col      Starting index in string\n * @param[in]     charsets List of charsets to choose from\n */\nvoid mutt_rfc2047_encode(char **pd, const char *specials, int col, const char *charsets)\n{\n  char *e = NULL;\n  size_t elen;\n\n  if (!Charset || !*pd)\n    return;\n\n  if (!charsets || !*charsets)\n    charsets = \"utf-8\";\n\n  rfc2047_encode(*pd, strlen(*pd), col, Charset, charsets, &e, &elen, specials);\n\n  FREE(pd);\n  *pd = e;\n}\n\n/**\n * mutt_rfc2047_decode - Decode any RFC2047-encoded header fields\n * @param[in,out] pd  String to be decoded, and resulting decoded string\n *\n * Try to decode anything that looks like a valid RFC2047 encoded header field,\n * ignoring RFC822 parsing rules. If decoding fails, for example due to an\n * invalid base64 string, the original input is left untouched.\n */\nvoid mutt_rfc2047_decode(char **pd)\n{\n  if (!pd || !*pd)\n    return;\n\n  struct Buffer buf = { 0 }; /* Output buffer                          */\n  char *s = *pd;             /* Read pointer                           */\n  char *beg;                 /* Begin of encoded word                  */\n  enum ContentEncoding enc;  /* ENCBASE64 or ENCQUOTEDPRINTABLE        */\n  char *charset;             /* Which charset                          */\n  size_t charsetlen;         /* Length of the charset                  */\n  char *text;                /* Encoded text                           */\n  size_t textlen;            /* Length of encoded text                 */\n\n  /* Keep some state in case the next decoded word is using the same charset\n   * and it happens to be split in the middle of a multibyte character.\n   * See https://github.com/neomutt/neomutt/issues/1015\n   */\n  struct Buffer prev = { 0 }; /* Previously decoded word                */\n  char *prev_charset = NULL;  /* Previously used charset                */\n  size_t prev_charsetlen = 0; /* Length of the previously used charset  */\n\n  while (*s)\n  {\n    beg = parse_encoded_word(s, &enc, &charset, &charsetlen, &text, &textlen);\n    if (beg != s)\n    {\n      /* Some non-encoded text was found */\n      size_t holelen = beg ? beg - s : mutt_str_strlen(s);\n\n      /* Ignore whitespace between encoded words */\n      if (beg && mutt_str_lws_len(s, holelen) == holelen)\n      {\n        s = beg;\n        continue;\n      }\n\n      /* If we have some previously decoded text, add it now */\n      if (prev.data)\n      {\n        finalize_chunk(&buf, &prev, prev_charset, prev_charsetlen);\n      }\n\n      /* Add non-encoded part */\n      {\n        if (AssumedCharset && *AssumedCharset)\n        {\n          char *conv = mutt_str_substr_dup(s, s + holelen);\n          mutt_ch_convert_nonmime_string(&conv);\n          mutt_buffer_addstr(&buf, conv);\n          FREE(&conv);\n        }\n        else\n        {\n          mutt_buffer_add(&buf, s, holelen);\n        }\n      }\n      s += holelen;\n    }\n    if (beg)\n    {\n      /* Some encoded text was found */\n      text[textlen] = '\\0';\n      char *decoded = rfc2047_decode_word(text, textlen, enc);\n      if (decoded == NULL)\n      {\n        return;\n      }\n      if (prev.data && ((prev_charsetlen != charsetlen) ||\n                        (strncmp(prev_charset, charset, charsetlen) != 0)))\n      {\n        /* Different charset, convert the previous chunk and add it to the\n         * final result */\n        finalize_chunk(&buf, &prev, prev_charset, prev_charsetlen);\n      }\n\n      mutt_buffer_addstr(&prev, decoded);\n      FREE(&decoded);\n      prev_charset = charset;\n      prev_charsetlen = charsetlen;\n      s = text + textlen + 2; /* Skip final ?= */\n    }\n  }\n\n  /* Save the last chunk */\n  if (prev.data)\n  {\n    finalize_chunk(&buf, &prev, prev_charset, prev_charsetlen);\n  }\n\n  mutt_buffer_addch(&buf, '\\0');\n  *pd = buf.data;\n}\n", "#define TEST_NO_MAIN\n#include \"acutest.h\"\n\n#include \"mutt/base64.h\"\n\n#include <string.h>\n\nstatic const char clear[] = \"Hello\";\nstatic const char encoded[] = \"SGVsbG8=\";\n\nvoid test_base64_encode(void)\n{\n  char buffer[16];\n  size_t len = mutt_b64_encode(buffer, clear, sizeof(clear) - 1, sizeof(buffer));\n  if (!TEST_CHECK(len == sizeof(encoded) - 1))\n  {\n    TEST_MSG(\"Expected: %zu\", sizeof(encoded) - 1);\n    TEST_MSG(\"Actual  : %zu\", len);\n  }\n  if (!TEST_CHECK(strcmp(buffer, encoded) == 0))\n  {\n    TEST_MSG(\"Expected: %zu\", encoded);\n    TEST_MSG(\"Actual  : %zu\", buffer);\n  }\n}\n\nvoid test_base64_decode(void)\n{\n  char buffer[16];\n  int len = mutt_b64_decode(buffer, encoded);\n  if (!TEST_CHECK(len == sizeof(clear) - 1))\n  {\n    TEST_MSG(\"Expected: %zu\", sizeof(clear) - 1);\n    TEST_MSG(\"Actual  : %zu\", len);\n  }\n  buffer[len] = '\\0';\n  if (!TEST_CHECK(strcmp(buffer, clear) == 0))\n  {\n    TEST_MSG(\"Expected: %s\", clear);\n    TEST_MSG(\"Actual  : %s\", buffer);\n  }\n}\n\nvoid test_base64_lengths(void)\n{\n  const char *in = \"FuseMuse\";\n  char out1[32];\n  char out2[32];\n  size_t enclen;\n  int declen;\n\n  /* Encoding a zero-length string should fail */\n  enclen = mutt_b64_encode(out1, in, 0, 32);\n  if (!TEST_CHECK(enclen == 0))\n  {\n    TEST_MSG(\"Expected: %zu\", 0);\n    TEST_MSG(\"Actual  : %zu\", enclen);\n  }\n\n  /* Decoding a zero-length string should fail, too */\n  out1[0] = '\\0';\n  declen = mutt_b64_decode(out2, out1);\n  if (!TEST_CHECK(declen == -1))\n  {\n    TEST_MSG(\"Expected: %zu\", -1);\n    TEST_MSG(\"Actual  : %zu\", declen);\n  }\n\n  /* Encode one to eight bytes, check the lengths of the returned string */\n  for (size_t i = 1; i <= 8; ++i)\n  {\n    enclen = mutt_b64_encode(out1, in, i, 32);\n    size_t exp = ((i + 2) / 3) << 2;\n    if (!TEST_CHECK(enclen == exp))\n    {\n      TEST_MSG(\"Expected: %zu\", exp);\n      TEST_MSG(\"Actual  : %zu\", enclen);\n    }\n    declen = mutt_b64_decode(out2, out1);\n    if (!TEST_CHECK(declen == i))\n    {\n      TEST_MSG(\"Expected: %zu\", i);\n      TEST_MSG(\"Actual  : %zu\", declen);\n    }\n    out2[declen] = '\\0';\n    if (!TEST_CHECK(strncmp(out2, in, i) == 0))\n    {\n      TEST_MSG(\"Expected: %s\", in);\n      TEST_MSG(\"Actual  : %s\", out2);\n    }\n  }\n}\n"], "fixing_code": ["/**\n * @file\n * IMAP CRAM-MD5 authentication method\n *\n * @authors\n * Copyright (C) 1999-2001,2005 Brendan Cully <brendan@kublai.com>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page imap_auth_cram IMAP CRAM-MD5 authentication method\n *\n * IMAP CRAM-MD5 authentication method\n */\n\n#include \"config.h\"\n#include <stdio.h>\n#include <string.h>\n#include \"imap_private.h\"\n#include \"mutt/mutt.h\"\n#include \"conn/conn.h\"\n#include \"auth.h\"\n#include \"globals.h\"\n#include \"mutt_account.h\"\n#include \"mutt_socket.h\"\n#include \"options.h\"\n#include \"protos.h\"\n\n#define MD5_BLOCK_LEN 64\n#define MD5_DIGEST_LEN 16\n\n/**\n * hmac_md5 - produce CRAM-MD5 challenge response\n * @param[in]  password  Password to encrypt\n * @param[in]  challenge Challenge from server\n * @param[out] response  Buffer for the response\n */\nstatic void hmac_md5(const char *password, char *challenge, unsigned char *response)\n{\n  struct Md5Ctx ctx;\n  unsigned char ipad[MD5_BLOCK_LEN] = { 0 };\n  unsigned char opad[MD5_BLOCK_LEN] = { 0 };\n  unsigned char secret[MD5_BLOCK_LEN + 1];\n  size_t secret_len;\n\n  secret_len = strlen(password);\n\n  /* passwords longer than MD5_BLOCK_LEN bytes are substituted with their MD5\n   * digests */\n  if (secret_len > MD5_BLOCK_LEN)\n  {\n    unsigned char hash_passwd[MD5_DIGEST_LEN];\n    mutt_md5_bytes(password, secret_len, hash_passwd);\n    mutt_str_strfcpy((char *) secret, (char *) hash_passwd, MD5_DIGEST_LEN);\n    secret_len = MD5_DIGEST_LEN;\n  }\n  else\n    mutt_str_strfcpy((char *) secret, password, sizeof(secret));\n\n  memcpy(ipad, secret, secret_len);\n  memcpy(opad, secret, secret_len);\n\n  for (int i = 0; i < MD5_BLOCK_LEN; i++)\n  {\n    ipad[i] ^= 0x36;\n    opad[i] ^= 0x5c;\n  }\n\n  /* inner hash: challenge and ipadded secret */\n  mutt_md5_init_ctx(&ctx);\n  mutt_md5_process_bytes(ipad, MD5_BLOCK_LEN, &ctx);\n  mutt_md5_process(challenge, &ctx);\n  mutt_md5_finish_ctx(&ctx, response);\n\n  /* outer hash: inner hash and opadded secret */\n  mutt_md5_init_ctx(&ctx);\n  mutt_md5_process_bytes(opad, MD5_BLOCK_LEN, &ctx);\n  mutt_md5_process_bytes(response, MD5_DIGEST_LEN, &ctx);\n  mutt_md5_finish_ctx(&ctx, response);\n}\n\n/**\n * imap_auth_cram_md5 - Authenticate using CRAM-MD5\n * @param idata  Server data\n * @param method Name of this authentication method\n * @retval enum Result, e.g. #IMAP_AUTH_SUCCESS\n */\nenum ImapAuthRes imap_auth_cram_md5(struct ImapData *idata, const char *method)\n{\n  char ibuf[LONG_STRING * 2], obuf[LONG_STRING];\n  unsigned char hmac_response[MD5_DIGEST_LEN];\n  int len;\n  int rc;\n\n  if (!mutt_bit_isset(idata->capabilities, ACRAM_MD5))\n    return IMAP_AUTH_UNAVAIL;\n\n  mutt_message(_(\"Authenticating (CRAM-MD5)...\"));\n\n  /* get auth info */\n  if (mutt_account_getlogin(&idata->conn->account) < 0)\n    return IMAP_AUTH_FAILURE;\n  if (mutt_account_getpass(&idata->conn->account) < 0)\n    return IMAP_AUTH_FAILURE;\n\n  imap_cmd_start(idata, \"AUTHENTICATE CRAM-MD5\");\n\n  /* From RFC2195:\n   * The data encoded in the first ready response contains a presumptively\n   * arbitrary string of random digits, a timestamp, and the fully-qualified\n   * primary host name of the server. The syntax of the unencoded form must\n   * correspond to that of an RFC822 'msg-id' [RFC822] as described in [POP3].\n   */\n  do\n    rc = imap_cmd_step(idata);\n  while (rc == IMAP_CMD_CONTINUE);\n\n  if (rc != IMAP_CMD_RESPOND)\n  {\n    mutt_debug(1, \"Invalid response from server: %s\\n\", ibuf);\n    goto bail;\n  }\n\n  len = mutt_b64_decode(obuf, idata->buf + 2, sizeof(obuf));\n  if (len == -1)\n  {\n    mutt_debug(1, \"Error decoding base64 response.\\n\");\n    goto bail;\n  }\n\n  obuf[len] = '\\0';\n  mutt_debug(2, \"CRAM challenge: %s\\n\", obuf);\n\n  /* The client makes note of the data and then responds with a string\n   * consisting of the user name, a space, and a 'digest'. The latter is\n   * computed by applying the keyed MD5 algorithm from [KEYED-MD5] where the\n   * key is a shared secret and the digested text is the timestamp (including\n   * angle-brackets).\n   *\n   * Note: The user name shouldn't be quoted. Since the digest can't contain\n   *   spaces, there is no ambiguity. Some servers get this wrong, we'll work\n   *   around them when the bug report comes in. Until then, we'll remain\n   *   blissfully RFC-compliant.\n   */\n  hmac_md5(idata->conn->account.pass, obuf, hmac_response);\n  /* dubious optimisation I saw elsewhere: make the whole string in one call */\n  int off = snprintf(obuf, sizeof(obuf), \"%s \", idata->conn->account.user);\n  mutt_md5_toascii(hmac_response, obuf + off);\n  mutt_debug(2, \"CRAM response: %s\\n\", obuf);\n\n  /* ibuf must be long enough to store the base64 encoding of obuf,\n   * plus the additional debris */\n  mutt_b64_encode(ibuf, obuf, strlen(obuf), sizeof(ibuf) - 2);\n  mutt_str_strcat(ibuf, sizeof(ibuf), \"\\r\\n\");\n  mutt_socket_send(idata->conn, ibuf);\n\n  do\n    rc = imap_cmd_step(idata);\n  while (rc == IMAP_CMD_CONTINUE);\n\n  if (rc != IMAP_CMD_OK)\n  {\n    mutt_debug(1, \"Error receiving server response.\\n\");\n    goto bail;\n  }\n\n  if (imap_code(idata->buf))\n    return IMAP_AUTH_SUCCESS;\n\nbail:\n  mutt_error(_(\"CRAM-MD5 authentication failed.\"));\n  return IMAP_AUTH_FAILURE;\n}\n", "/**\n * @file\n * IMAP GSS authentication method\n *\n * @authors\n * Copyright (C) 1999-2001,2005,2009 Brendan Cully <brendan@kublai.com>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page imap_auth_gss IMAP GSS authentication method\n *\n * IMAP GSS authentication method\n *\n * An overview of the authentication method is in RFC 1731.\n *\n * An overview of the C API used is in RFC 2744.\n * Of note is section 3.2, which describes gss_buffer_desc.\n * The length should not include a terminating '\\0' byte, and the client\n * should not expect the value field to be '\\0'terminated.\n */\n\n#include \"config.h\"\n#include <netinet/in.h>\n#include <stdio.h>\n#include <string.h>\n#include \"imap_private.h\"\n#include \"mutt/mutt.h\"\n#include \"conn/conn.h\"\n#include \"mutt.h\"\n#include \"auth.h\"\n#include \"globals.h\"\n#include \"mutt_account.h\"\n#include \"mutt_logging.h\"\n#include \"mutt_socket.h\"\n#include \"options.h\"\n#include \"protos.h\"\n#ifdef HAVE_HEIMDAL\n#include <gssapi/gssapi.h>\n#define gss_nt_service_name GSS_C_NT_HOSTBASED_SERVICE\n#else\n#include <gssapi/gssapi.h>\n#include <gssapi/gssapi_generic.h>\n#endif\n\n#define GSS_BUFSIZE 8192\n\n#define GSS_AUTH_P_NONE 1\n#define GSS_AUTH_P_INTEGRITY 2\n#define GSS_AUTH_P_PRIVACY 4\n\n/**\n * print_gss_error - Print detailed error message to the debug log\n * @param err_maj Error's major number\n * @param err_min Error's minor number\n */\nstatic void print_gss_error(OM_uint32 err_maj, OM_uint32 err_min)\n{\n  OM_uint32 maj_stat, min_stat;\n  OM_uint32 msg_ctx = 0;\n  gss_buffer_desc status_string;\n  char buf_maj[512];\n  char buf_min[512];\n\n  do\n  {\n    maj_stat = gss_display_status(&min_stat, err_maj, GSS_C_GSS_CODE,\n                                  GSS_C_NO_OID, &msg_ctx, &status_string);\n    if (GSS_ERROR(maj_stat))\n      break;\n    size_t status_len = status_string.length;\n    if (status_len >= sizeof(buf_maj))\n      status_len = sizeof(buf_maj) - 1;\n    strncpy(buf_maj, (char *) status_string.value, status_len);\n    buf_maj[status_len] = '\\0';\n    gss_release_buffer(&min_stat, &status_string);\n\n    maj_stat = gss_display_status(&min_stat, err_min, GSS_C_MECH_CODE,\n                                  GSS_C_NULL_OID, &msg_ctx, &status_string);\n    if (!GSS_ERROR(maj_stat))\n    {\n      status_len = status_string.length;\n      if (status_len >= sizeof(buf_min))\n        status_len = sizeof(buf_min) - 1;\n      strncpy(buf_min, (char *) status_string.value, status_len);\n      buf_min[status_len] = '\\0';\n      gss_release_buffer(&min_stat, &status_string);\n    }\n  } while (!GSS_ERROR(maj_stat) && msg_ctx != 0);\n\n  mutt_debug(2, \"((%s:%d )(%s:%d))\\n\", buf_maj, err_maj, buf_min, err_min);\n}\n\n/**\n * imap_auth_gss - GSS Authentication support\n * @param idata  Server data\n * @param method Name of this authentication method\n * @retval enum Result, e.g. #IMAP_AUTH_SUCCESS\n */\nenum ImapAuthRes imap_auth_gss(struct ImapData *idata, const char *method)\n{\n  gss_buffer_desc request_buf, send_token;\n  gss_buffer_t sec_token;\n  gss_name_t target_name;\n  gss_ctx_id_t context;\n  gss_OID mech_name;\n  char server_conf_flags;\n  gss_qop_t quality;\n  int cflags;\n  OM_uint32 maj_stat, min_stat;\n  char buf1[GSS_BUFSIZE], buf2[GSS_BUFSIZE];\n  unsigned long buf_size;\n  int rc;\n\n  if (!mutt_bit_isset(idata->capabilities, AGSSAPI))\n    return IMAP_AUTH_UNAVAIL;\n\n  if (mutt_account_getuser(&idata->conn->account) < 0)\n    return IMAP_AUTH_FAILURE;\n\n  /* get an IMAP service ticket for the server */\n  snprintf(buf1, sizeof(buf1), \"imap@%s\", idata->conn->account.host);\n  request_buf.value = buf1;\n  request_buf.length = strlen(buf1);\n  maj_stat = gss_import_name(&min_stat, &request_buf, gss_nt_service_name, &target_name);\n  if (maj_stat != GSS_S_COMPLETE)\n  {\n    mutt_debug(2, \"Couldn't get service name for [%s]\\n\", buf1);\n    return IMAP_AUTH_UNAVAIL;\n  }\n  else if (DebugLevel >= 2)\n  {\n    gss_display_name(&min_stat, target_name, &request_buf, &mech_name);\n    mutt_debug(2, \"Using service name [%s]\\n\", (char *) request_buf.value);\n    gss_release_buffer(&min_stat, &request_buf);\n  }\n  /* Acquire initial credentials - without a TGT GSSAPI is UNAVAIL */\n  sec_token = GSS_C_NO_BUFFER;\n  context = GSS_C_NO_CONTEXT;\n\n  /* build token */\n  maj_stat = gss_init_sec_context(&min_stat, GSS_C_NO_CREDENTIAL, &context, target_name,\n                                  GSS_C_NO_OID, GSS_C_MUTUAL_FLAG | GSS_C_SEQUENCE_FLAG,\n                                  0, GSS_C_NO_CHANNEL_BINDINGS, sec_token, NULL,\n                                  &send_token, (unsigned int *) &cflags, NULL);\n  if (maj_stat != GSS_S_COMPLETE && maj_stat != GSS_S_CONTINUE_NEEDED)\n  {\n    print_gss_error(maj_stat, min_stat);\n    mutt_debug(1, \"Error acquiring credentials - no TGT?\\n\");\n    gss_release_name(&min_stat, &target_name);\n\n    return IMAP_AUTH_UNAVAIL;\n  }\n\n  /* now begin login */\n  mutt_message(_(\"Authenticating (GSSAPI)...\"));\n\n  imap_cmd_start(idata, \"AUTHENTICATE GSSAPI\");\n\n  /* expect a null continuation response (\"+\") */\n  do\n    rc = imap_cmd_step(idata);\n  while (rc == IMAP_CMD_CONTINUE);\n\n  if (rc != IMAP_CMD_RESPOND)\n  {\n    mutt_debug(2, \"Invalid response from server: %s\\n\", buf1);\n    gss_release_name(&min_stat, &target_name);\n    goto bail;\n  }\n\n  /* now start the security context initialisation loop... */\n  mutt_debug(2, \"Sending credentials\\n\");\n  mutt_b64_encode(buf1, send_token.value, send_token.length, sizeof(buf1) - 2);\n  gss_release_buffer(&min_stat, &send_token);\n  mutt_str_strcat(buf1, sizeof(buf1), \"\\r\\n\");\n  mutt_socket_send(idata->conn, buf1);\n\n  while (maj_stat == GSS_S_CONTINUE_NEEDED)\n  {\n    /* Read server data */\n    do\n      rc = imap_cmd_step(idata);\n    while (rc == IMAP_CMD_CONTINUE);\n\n    if (rc != IMAP_CMD_RESPOND)\n    {\n      mutt_debug(1, \"#1 Error receiving server response.\\n\");\n      gss_release_name(&min_stat, &target_name);\n      goto bail;\n    }\n\n    request_buf.length = mutt_b64_decode(buf2, idata->buf + 2, sizeof(buf2));\n    request_buf.value = buf2;\n    sec_token = &request_buf;\n\n    /* Write client data */\n    maj_stat = gss_init_sec_context(\n        &min_stat, GSS_C_NO_CREDENTIAL, &context, target_name, GSS_C_NO_OID,\n        GSS_C_MUTUAL_FLAG | GSS_C_SEQUENCE_FLAG, 0, GSS_C_NO_CHANNEL_BINDINGS,\n        sec_token, NULL, &send_token, (unsigned int *) &cflags, NULL);\n    if (maj_stat != GSS_S_COMPLETE && maj_stat != GSS_S_CONTINUE_NEEDED)\n    {\n      print_gss_error(maj_stat, min_stat);\n      mutt_debug(1, \"Error exchanging credentials\\n\");\n      gss_release_name(&min_stat, &target_name);\n\n      goto err_abort_cmd;\n    }\n    mutt_b64_encode(buf1, send_token.value, send_token.length, sizeof(buf1) - 2);\n    gss_release_buffer(&min_stat, &send_token);\n    mutt_str_strcat(buf1, sizeof(buf1), \"\\r\\n\");\n    mutt_socket_send(idata->conn, buf1);\n  }\n\n  gss_release_name(&min_stat, &target_name);\n\n  /* get security flags and buffer size */\n  do\n    rc = imap_cmd_step(idata);\n  while (rc == IMAP_CMD_CONTINUE);\n\n  if (rc != IMAP_CMD_RESPOND)\n  {\n    mutt_debug(1, \"#2 Error receiving server response.\\n\");\n    goto bail;\n  }\n  request_buf.length = mutt_b64_decode(buf2, idata->buf + 2, sizeof(buf2));\n  request_buf.value = buf2;\n\n  maj_stat = gss_unwrap(&min_stat, context, &request_buf, &send_token, &cflags, &quality);\n  if (maj_stat != GSS_S_COMPLETE)\n  {\n    print_gss_error(maj_stat, min_stat);\n    mutt_debug(2, \"Couldn't unwrap security level data\\n\");\n    gss_release_buffer(&min_stat, &send_token);\n    goto err_abort_cmd;\n  }\n  mutt_debug(2, \"Credential exchange complete\\n\");\n\n  /* first octet is security levels supported. We want NONE */\n  server_conf_flags = ((char *) send_token.value)[0];\n  if (!(((char *) send_token.value)[0] & GSS_AUTH_P_NONE))\n  {\n    mutt_debug(2, \"Server requires integrity or privacy\\n\");\n    gss_release_buffer(&min_stat, &send_token);\n    goto err_abort_cmd;\n  }\n\n  /* we don't care about buffer size if we don't wrap content. But here it is */\n  ((char *) send_token.value)[0] = '\\0';\n  buf_size = ntohl(*((long *) send_token.value));\n  gss_release_buffer(&min_stat, &send_token);\n  mutt_debug(2, \"Unwrapped security level flags: %c%c%c\\n\",\n             (server_conf_flags & GSS_AUTH_P_NONE) ? 'N' : '-',\n             (server_conf_flags & GSS_AUTH_P_INTEGRITY) ? 'I' : '-',\n             (server_conf_flags & GSS_AUTH_P_PRIVACY) ? 'P' : '-');\n  mutt_debug(2, \"Maximum GSS token size is %ld\\n\", buf_size);\n\n  /* agree to terms (hack!) */\n  buf_size = htonl(buf_size); /* not relevant without integrity/privacy */\n  memcpy(buf1, &buf_size, 4);\n  buf1[0] = GSS_AUTH_P_NONE;\n  /* server decides if principal can log in as user */\n  strncpy(buf1 + 4, idata->conn->account.user, sizeof(buf1) - 4);\n  request_buf.value = buf1;\n  request_buf.length = 4 + strlen(idata->conn->account.user);\n  maj_stat = gss_wrap(&min_stat, context, 0, GSS_C_QOP_DEFAULT, &request_buf,\n                      &cflags, &send_token);\n  if (maj_stat != GSS_S_COMPLETE)\n  {\n    mutt_debug(2, \"Error creating login request\\n\");\n    goto err_abort_cmd;\n  }\n\n  mutt_b64_encode(buf1, send_token.value, send_token.length, sizeof(buf1) - 2);\n  mutt_debug(2, \"Requesting authorisation as %s\\n\", idata->conn->account.user);\n  mutt_str_strcat(buf1, sizeof(buf1), \"\\r\\n\");\n  mutt_socket_send(idata->conn, buf1);\n\n  /* Joy of victory or agony of defeat? */\n  do\n    rc = imap_cmd_step(idata);\n  while (rc == IMAP_CMD_CONTINUE);\n  if (rc == IMAP_CMD_RESPOND)\n  {\n    mutt_debug(1, \"Unexpected server continuation request.\\n\");\n    goto err_abort_cmd;\n  }\n  if (imap_code(idata->buf))\n  {\n    /* flush the security context */\n    mutt_debug(2, \"Releasing GSS credentials\\n\");\n    maj_stat = gss_delete_sec_context(&min_stat, &context, &send_token);\n    if (maj_stat != GSS_S_COMPLETE)\n      mutt_debug(1, \"Error releasing credentials\\n\");\n\n    /* send_token may contain a notification to the server to flush\n     * credentials. RFC1731 doesn't specify what to do, and since this\n     * support is only for authentication, we'll assume the server knows\n     * enough to flush its own credentials */\n    gss_release_buffer(&min_stat, &send_token);\n\n    return IMAP_AUTH_SUCCESS;\n  }\n  else\n    goto bail;\n\nerr_abort_cmd:\n  mutt_socket_send(idata->conn, \"*\\r\\n\");\n  do\n    rc = imap_cmd_step(idata);\n  while (rc == IMAP_CMD_CONTINUE);\n\nbail:\n  mutt_error(_(\"GSSAPI authentication failed.\"));\n  return IMAP_AUTH_FAILURE;\n}\n", "/**\n * @file\n * Conversion to/from base64 encoding\n *\n * @authors\n * Copyright (C) 1993,1995 Carl Harris\n * Copyright (C) 1997 Eric S. Raymond\n * Copyright (C) 1999 Brendan Cully <brendan@kublai.com>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page base64 Conversion to/from base64 encoding\n *\n * Convert between binary data and base64 text, according to RFC2045.\n *\n * @note RFC3548 obsoletes RFC2045.\n * @note RFC4648 obsoletes RFC3548.\n */\n\n#include \"config.h\"\n#include \"base64.h\"\n\n#define BAD -1\n\n/**\n * B64Chars - Characters of the Base64 encoding\n */\nstatic const char B64Chars[64] = {\n  'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n  'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n  'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n  'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n  '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/',\n};\n\n// clang-format off\n/**\n * Index64 - Lookup table for Base64 encoding characters\n *\n * @note This is very similar to the table in imap/utf7.c\n *\n * Encoding chars:\n * * utf7 A-Za-z0-9+,\n * * mime A-Za-z0-9+/\n */\nconst int Index64[128] = {\n    -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1,\n    -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1,\n    -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,62, -1,-1,-1,63,\n    52,53,54,55, 56,57,58,59, 60,61,-1,-1, -1,-1,-1,-1,\n    -1, 0, 1, 2,  3, 4, 5, 6,  7, 8, 9,10, 11,12,13,14,\n    15,16,17,18, 19,20,21,22, 23,24,25,-1, -1,-1,-1,-1,\n    -1,26,27,28, 29,30,31,32, 33,34,35,36, 37,38,39,40,\n    41,42,43,44, 45,46,47,48, 49,50,51,-1, -1,-1,-1,-1\n};\n// clang-format on\n\n/**\n * mutt_b64_encode - Convert raw bytes to null-terminated base64 string\n * @param out  Output buffer for the base64 encoded string\n * @param cin  Input  buffer for the raw bytes\n * @param len  Length of the input buffer\n * @param olen Length of the output buffer\n * @retval num Length of the string written to the output buffer\n *\n * This function performs base64 encoding. The resulting string is guaranteed\n * to be null-terminated. The number of characters up to the terminating\n * null-byte is returned (equivalent to calling strlen() on the output buffer\n * after this function returns).\n */\nsize_t mutt_b64_encode(char *out, const char *cin, size_t len, size_t olen)\n{\n  unsigned char *begin = (unsigned char *) out;\n  const unsigned char *in = (const unsigned char *) cin;\n\n  while ((len >= 3) && (olen > 10))\n  {\n    *out++ = B64Chars[in[0] >> 2];\n    *out++ = B64Chars[((in[0] << 4) & 0x30) | (in[1] >> 4)];\n    *out++ = B64Chars[((in[1] << 2) & 0x3c) | (in[2] >> 6)];\n    *out++ = B64Chars[in[2] & 0x3f];\n    olen -= 4;\n    len -= 3;\n    in += 3;\n  }\n\n  /* clean up remainder */\n  if ((len > 0) && (olen > 4))\n  {\n    unsigned char fragment;\n\n    *out++ = B64Chars[in[0] >> 2];\n    fragment = (in[0] << 4) & 0x30;\n    if (len > 1)\n      fragment |= in[1] >> 4;\n    *out++ = B64Chars[fragment];\n    *out++ = (len < 2) ? '=' : B64Chars[(in[1] << 2) & 0x3c];\n    *out++ = '=';\n  }\n  *out = '\\0';\n  return (out - (char *) begin);\n}\n\n/**\n * mutt_b64_decode - Convert null-terminated base64 string to raw bytes\n * @param out  Output buffer for the raw bytes\n * @param in   Input  buffer for the null-terminated base64-encoded string\n * @param olen Length of the output buffer\n * @retval num Success, bytes written\n * @retval -1  Error\n *\n * This function performs base64 decoding. The resulting buffer is NOT\n * null-terminated. If the input buffer contains invalid base64 characters,\n * this function returns -1.\n */\nint mutt_b64_decode(char *out, const char *in, size_t olen)\n{\n  int len = 0;\n  unsigned char digit4;\n\n  do\n  {\n    const unsigned char digit1 = in[0];\n    if ((digit1 > 127) || (base64val(digit1) == BAD))\n      return -1;\n    const unsigned char digit2 = in[1];\n    if ((digit2 > 127) || (base64val(digit2) == BAD))\n      return -1;\n    const unsigned char digit3 = in[2];\n    if ((digit3 > 127) || ((digit3 != '=') && (base64val(digit3) == BAD)))\n      return -1;\n    digit4 = in[3];\n    if ((digit4 > 127) || ((digit4 != '=') && (base64val(digit4) == BAD)))\n      return -1;\n    in += 4;\n\n    /* digits are already sanity-checked */\n    if (len == olen)\n      return len;\n    *out++ = (base64val(digit1) << 2) | (base64val(digit2) >> 4);\n    len++;\n    if (digit3 != '=')\n    {\n      if (len == olen)\n        return len;\n      *out++ = ((base64val(digit2) << 4) & 0xf0) | (base64val(digit3) >> 2);\n      len++;\n      if (digit4 != '=')\n      {\n        if (len == olen)\n          return len;\n        *out++ = ((base64val(digit3) << 6) & 0xc0) | base64val(digit4);\n        len++;\n      }\n    }\n  } while (*in && digit4 != '=');\n\n  return len;\n}\n", "/**\n * @file\n * Conversion to/from base64 encoding\n *\n * @authors\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef _MUTT_BASE64_H\n#define _MUTT_BASE64_H\n\n#include <stdio.h>\n\nextern const int Index64[];\n\n#define base64val(c) Index64[(unsigned int) (c)]\n\nsize_t mutt_b64_encode(char *out, const char *cin, size_t len, size_t olen);\nint    mutt_b64_decode(char *out, const char *in, size_t olen);\n\n#endif /* _MUTT_BASE64_H */\n", "/**\n * @file\n * RFC2047 MIME extensions encoding / decoding routines\n *\n * @authors\n * Copyright (C) 1996-2000,2010 Michael R. Elkins <me@mutt.org>\n * Copyright (C) 2000-2002 Edmund Grimley Evans <edmundo@rano.org>\n * Copyright (C) 2018 Pietro Cerutti <gahr@gahr.ch>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page rfc2047 RFC2047 encoding / decoding functions\n *\n * RFC2047 MIME extensions encoding / decoding routines.\n */\n\n#include \"config.h\"\n#include <assert.h>\n#include <errno.h>\n#include <stdbool.h>\n#include <string.h>\n#include \"rfc2047.h\"\n#include \"base64.h\"\n#include \"buffer.h\"\n#include \"charset.h\"\n#include \"mbyte.h\"\n#include \"memory.h\"\n#include \"mime.h\"\n#include \"regex3.h\"\n#include \"string2.h\"\n\n#define ENCWORD_LEN_MAX 75\n#define ENCWORD_LEN_MIN 9 /* strlen (\"=?.?.?.?=\") */\n\n#define HSPACE(x) (((x) == '\\0') || ((x) == ' ') || ((x) == '\\t'))\n\n#define CONTINUATION_BYTE(c) (((c) &0xc0) == 0x80)\n\ntypedef size_t (*encoder_t)(char *str, const char *buf, size_t buflen, const char *tocode);\n\n/**\n * b_encoder - Base64 Encode a string\n * @param str    String to encode\n * @param buf    Buffer for result\n * @param buflen Length of buffer\n * @param tocode Character encoding\n * @retval num Bytes written to buffer\n */\nstatic size_t b_encoder(char *str, const char *buf, size_t buflen, const char *tocode)\n{\n  char *s0 = str;\n\n  memcpy(str, \"=?\", 2);\n  str += 2;\n  memcpy(str, tocode, strlen(tocode));\n  str += strlen(tocode);\n  memcpy(str, \"?B?\", 3);\n  str += 3;\n\n  while (buflen)\n  {\n    char encoded[11];\n    size_t ret;\n    size_t in_len = MIN(3, buflen);\n\n    ret = mutt_b64_encode(encoded, buf, in_len, sizeof(encoded));\n    for (size_t i = 0; i < ret; i++)\n      *str++ = encoded[i];\n\n    buflen -= in_len;\n    buf += in_len;\n  }\n\n  memcpy(str, \"?=\", 2);\n  str += 2;\n  return (str - s0);\n}\n\n/**\n * q_encoder - Quoted-printable Encode a string\n * @param str    String to encode\n * @param buf    Buffer for result\n * @param buflen Length of buffer\n * @param tocode Character encoding\n * @retval num Bytes written to buffer\n */\nstatic size_t q_encoder(char *str, const char *buf, size_t buflen, const char *tocode)\n{\n  static const char hex[] = \"0123456789ABCDEF\";\n  char *s0 = str;\n\n  memcpy(str, \"=?\", 2);\n  str += 2;\n  memcpy(str, tocode, strlen(tocode));\n  str += strlen(tocode);\n  memcpy(str, \"?Q?\", 3);\n  str += 3;\n  while (buflen--)\n  {\n    unsigned char c = *buf++;\n    if (c == ' ')\n      *str++ = '_';\n    else if ((c >= 0x7f) || (c < 0x20) || (c == '_') || strchr(MimeSpecials, c))\n    {\n      *str++ = '=';\n      *str++ = hex[(c & 0xf0) >> 4];\n      *str++ = hex[c & 0x0f];\n    }\n    else\n      *str++ = c;\n  }\n  memcpy(str, \"?=\", 2);\n  str += 2;\n  return (str - s0);\n}\n\n/**\n * parse_encoded_word - Parse a string and report RFC2047 elements\n * @param[in]  str        String to parse\n * @param[out] enc        Content encoding found in the first RFC2047 word\n * @param[out] charset    Charset found in the first RFC2047 word\n * @param[out] charsetlen Length of the charset string found\n * @param[out] text       Start of the first RFC2047 encoded text\n * @param[out] textlen    Length of the encoded text found\n * @retval ptr Start of the RFC2047 encoded word\n * @retval NULL None was found\n */\nstatic char *parse_encoded_word(char *str, enum ContentEncoding *enc, char **charset,\n                                size_t *charsetlen, char **text, size_t *textlen)\n{\n  static struct Regex *re = NULL;\n  regmatch_t match[4];\n  size_t nmatch = 4;\n\n  if (re == NULL)\n  {\n    re = mutt_regex_compile(\"=\\\\?\"\n                            \"([^][()<>@,;:\\\\\\\"/?. =]+)\" /* charset */\n                            \"\\\\?\"\n                            \"([qQbB])\" /* encoding */\n                            \"\\\\?\"\n                            \"([^?]+)\" /* encoded text - we accept whitespace\n                                         as some mailers do that, see #1189. */\n                            \"\\\\?=\",\n                            REG_EXTENDED);\n    assert(re && \"Something is wrong with your RE engine.\");\n  }\n\n  int rc = regexec(re->regex, str, nmatch, match, 0);\n  if (rc != 0)\n    return NULL;\n\n  /* Charset */\n  *charset = str + match[1].rm_so;\n  *charsetlen = match[1].rm_eo - match[1].rm_so;\n\n  /* Encoding: either Q or B */\n  *enc = ((str[match[2].rm_so] == 'Q') || (str[match[2].rm_so] == 'q')) ?\n             ENCQUOTEDPRINTABLE :\n             ENCBASE64;\n\n  *text = str + match[3].rm_so;\n  *textlen = match[3].rm_eo - match[3].rm_so;\n  return (str + match[0].rm_so);\n}\n\n/**\n * try_block - Attempt to convert a block of text\n * @param d        String to convert\n * @param dlen     Length of string\n * @param fromcode Original encoding\n * @param tocode   New encoding\n * @param encoder  Encoding function\n * @param wlen     Number of characters converted\n * @retval  0 Success, string converted\n * @retval >0 Error, number of bytes that could be converted\n *\n * If the data could be conveted using encoder, then set *encoder and *wlen.\n * Otherwise return an upper bound on the maximum length of the data which\n * could be converted.\n *\n * The data is converted from fromcode (which must be stateless) to tocode,\n * unless fromcode is NULL, in which case the data is assumed to be already in\n * tocode, which should be 8-bit and stateless.\n */\nstatic size_t try_block(const char *d, size_t dlen, const char *fromcode,\n                        const char *tocode, encoder_t *encoder, size_t *wlen)\n{\n  char buf[ENCWORD_LEN_MAX - ENCWORD_LEN_MIN + 1];\n  const char *ib = NULL;\n  char *ob = NULL;\n  size_t ibl, obl;\n  int count, len, len_b, len_q;\n\n  if (fromcode)\n  {\n    iconv_t cd = mutt_ch_iconv_open(tocode, fromcode, 0);\n    assert(cd != (iconv_t)(-1));\n    ib = d;\n    ibl = dlen;\n    ob = buf;\n    obl = sizeof(buf) - strlen(tocode);\n    if (iconv(cd, (ICONV_CONST char **) &ib, &ibl, &ob, &obl) == (size_t)(-1) ||\n        iconv(cd, NULL, NULL, &ob, &obl) == (size_t)(-1))\n    {\n      assert(errno == E2BIG);\n      iconv_close(cd);\n      assert(ib > d);\n      return (ib - d == dlen) ? dlen : ib - d + 1;\n    }\n    iconv_close(cd);\n  }\n  else\n  {\n    if (dlen > (sizeof(buf) - strlen(tocode)))\n      return (sizeof(buf) - strlen(tocode) + 1);\n    memcpy(buf, d, dlen);\n    ob = buf + dlen;\n  }\n\n  count = 0;\n  for (char *p = buf; p < ob; p++)\n  {\n    unsigned char c = *p;\n    assert(strchr(MimeSpecials, '?'));\n    if ((c >= 0x7f) || (c < 0x20) || (*p == '_') ||\n        ((c != ' ') && strchr(MimeSpecials, *p)))\n    {\n      count++;\n    }\n  }\n\n  len = ENCWORD_LEN_MIN - 2 + strlen(tocode);\n  len_b = len + (((ob - buf) + 2) / 3) * 4;\n  len_q = len + (ob - buf) + 2 * count;\n\n  /* Apparently RFC1468 says to use B encoding for iso-2022-jp. */\n  if (mutt_str_strcasecmp(tocode, \"ISO-2022-JP\") == 0)\n    len_q = ENCWORD_LEN_MAX + 1;\n\n  if ((len_b < len_q) && (len_b <= ENCWORD_LEN_MAX))\n  {\n    *encoder = b_encoder;\n    *wlen = len_b;\n    return 0;\n  }\n  else if (len_q <= ENCWORD_LEN_MAX)\n  {\n    *encoder = q_encoder;\n    *wlen = len_q;\n    return 0;\n  }\n  else\n    return dlen;\n}\n\n/**\n * encode_block - Encode a block of text using an encoder\n * @param str      String to convert\n * @param buf      Buffer for result\n * @param buflen   Buffer length\n * @param fromcode Original encoding\n * @param tocode   New encoding\n * @param encoder  Encoding function\n * @retval num Length of the encoded word\n *\n * Encode the data (buf, buflen) into str using the encoder.\n */\nstatic size_t encode_block(char *str, char *buf, size_t buflen, const char *fromcode,\n                           const char *tocode, encoder_t encoder)\n{\n  if (!fromcode)\n  {\n    return (*encoder)(str, buf, buflen, tocode);\n  }\n\n  const iconv_t cd = mutt_ch_iconv_open(tocode, fromcode, 0);\n  assert(cd != (iconv_t)(-1));\n  const char *ib = buf;\n  size_t ibl = buflen;\n  char tmp[ENCWORD_LEN_MAX - ENCWORD_LEN_MIN + 1];\n  char *ob = tmp;\n  size_t obl = sizeof(tmp) - strlen(tocode);\n  const size_t n1 = iconv(cd, (ICONV_CONST char **) &ib, &ibl, &ob, &obl);\n  const size_t n2 = iconv(cd, NULL, NULL, &ob, &obl);\n  assert(n1 != (size_t)(-1) && n2 != (size_t)(-1));\n  iconv_close(cd);\n  return (*encoder)(str, tmp, ob - tmp, tocode);\n}\n\n/**\n * choose_block - Calculate how much data can be converted\n * @param d        String to convert\n * @param dlen     Length of string\n * @param col      Starting column to convert\n * @param fromcode Original encoding\n * @param tocode   New encoding\n * @param encoder  Encoding function\n * @param wlen     Number of characters converted\n * @retval num Bytes that can be converted\n *\n * Discover how much of the data (d, dlen) can be converted into a single\n * encoded word. Return how much data can be converted, and set the length\n * *wlen of the encoded word and *encoder.  We start in column col, which\n * limits the length of the word.\n */\nstatic size_t choose_block(char *d, size_t dlen, int col, const char *fromcode,\n                           const char *tocode, encoder_t *encoder, size_t *wlen)\n{\n  const int utf8 = fromcode && (mutt_str_strcasecmp(fromcode, \"utf-8\") == 0);\n\n  size_t n = dlen;\n  while (true)\n  {\n    assert(n > 0);\n    const size_t nn = try_block(d, n, fromcode, tocode, encoder, wlen);\n    if ((nn == 0) && ((col + *wlen) <= (ENCWORD_LEN_MAX + 1) || (n <= 1)))\n      break;\n    n = (nn ? nn : n) - 1;\n    assert(n > 0);\n    if (utf8)\n      while ((n > 1) && CONTINUATION_BYTE(d[n]))\n        n--;\n  }\n  return n;\n}\n\n/**\n * finalize_chunk - Perform charset conversion and filtering\n * @param[out] res        Buffer where the resulting string is appended\n * @param[in]  buf        Buffer with the input string\n * @param[in]  charset    Charset to use for the conversion\n * @param[in]  charsetlen Length of the charset parameter\n *\n * The buffer buf is reinitialized at the end of this function.\n */\nstatic void finalize_chunk(struct Buffer *res, struct Buffer *buf, char *charset, size_t charsetlen)\n{\n  char end = charset[charsetlen];\n  charset[charsetlen] = '\\0';\n  mutt_ch_convert_string(&buf->data, charset, Charset, MUTT_ICONV_HOOK_FROM);\n  charset[charsetlen] = end;\n  mutt_mb_filter_unprintable(&buf->data);\n  mutt_buffer_addstr(res, buf->data);\n  FREE(&buf->data);\n  mutt_buffer_init(buf);\n}\n\n/**\n * rfc2047_decode_word - Decode an RFC2047-encoded string\n * @param s   String to decode\n * @param len Length of the string\n * @param enc Encoding type\n * @retval ptr Decoded string\n *\n * @note The caller must free the returned string\n */\nstatic char *rfc2047_decode_word(const char *s, size_t len, enum ContentEncoding enc)\n{\n  const char *it = s;\n  const char *end = s + len;\n\n  if (enc == ENCQUOTEDPRINTABLE)\n  {\n    struct Buffer buf = { 0 };\n    for (; it < end; ++it)\n    {\n      if (*it == '_')\n      {\n        mutt_buffer_addch(&buf, ' ');\n      }\n      else if ((*it == '=') && (!(it[1] & ~127) && hexval(it[1]) != -1) &&\n               (!(it[2] & ~127) && hexval(it[2]) != -1))\n      {\n        mutt_buffer_addch(&buf, (hexval(it[1]) << 4) | hexval(it[2]));\n        it += 2;\n      }\n      else\n      {\n        mutt_buffer_addch(&buf, *it);\n      }\n    }\n    mutt_buffer_addch(&buf, '\\0');\n    return buf.data;\n  }\n  else if (enc == ENCBASE64)\n  {\n    const int olen = 3 * len / 4 + 1;\n    char *out = mutt_mem_malloc(olen);\n    int dlen = mutt_b64_decode(out, it, olen);\n    if (dlen == -1)\n    {\n      FREE(&out);\n      return NULL;\n    }\n    out[dlen] = '\\0';\n    return out;\n  }\n\n  assert(0); /* The enc parameter has an invalid value */\n  return NULL;\n}\n\n/**\n * rfc2047_encode - RFC2047-encode a string\n * @param d        String to convert\n * @param dlen     Length of string\n * @param col      Starting column to convert\n * @param fromcode Original encoding\n * @param charsets List of allowable encodings (colon separated)\n * @param e        Encoded string\n * @param elen     Length of encoded string\n * @param specials Special characters to be encoded\n * @retval 0 Success\n */\nstatic int rfc2047_encode(const char *d, size_t dlen, int col, const char *fromcode,\n                          const char *charsets, char **e, size_t *elen, const char *specials)\n{\n  int rc = 0;\n  char *buf = NULL;\n  size_t bufpos, buflen;\n  char *t0 = NULL, *t1 = NULL, *t = NULL;\n  char *s0 = NULL, *s1 = NULL;\n  size_t ulen, r, wlen = 0;\n  encoder_t encoder = NULL;\n  char *tocode1 = NULL;\n  const char *tocode = NULL;\n  char *icode = \"utf-8\";\n\n  /* Try to convert to UTF-8. */\n  char *u = mutt_str_substr_dup(d, d + dlen);\n  if (mutt_ch_convert_string(&u, fromcode, icode, 0) != 0)\n  {\n    rc = 1;\n    icode = 0;\n  }\n  ulen = mutt_str_strlen(u);\n\n  /* Find earliest and latest things we must encode. */\n  s0 = s1 = t0 = t1 = 0;\n  for (t = u; t < (u + ulen); t++)\n  {\n    if ((*t & 0x80) || ((*t == '=') && (t[1] == '?') && ((t == u) || HSPACE(*(t - 1)))))\n    {\n      if (!t0)\n        t0 = t;\n      t1 = t;\n    }\n    else if (specials && *t && strchr(specials, *t))\n    {\n      if (!s0)\n        s0 = t;\n      s1 = t;\n    }\n  }\n\n  /* If we have something to encode, include RFC822 specials */\n  if (t0 && s0 && (s0 < t0))\n    t0 = s0;\n  if (t1 && s1 && (s1 > t1))\n    t1 = s1;\n\n  if (!t0)\n  {\n    /* No encoding is required. */\n    *e = u;\n    *elen = ulen;\n    return rc;\n  }\n\n  /* Choose target charset. */\n  tocode = fromcode;\n  if (icode)\n  {\n    tocode1 = mutt_ch_choose(icode, charsets, u, ulen, 0, 0);\n    if (tocode1)\n      tocode = tocode1;\n    else\n    {\n      rc = 2;\n      icode = 0;\n    }\n  }\n\n  /* Hack to avoid labelling 8-bit data as us-ascii. */\n  if (!icode && mutt_ch_is_us_ascii(tocode))\n    tocode = \"unknown-8bit\";\n\n  /* Adjust t0 for maximum length of line. */\n  t = u + (ENCWORD_LEN_MAX + 1) - col - ENCWORD_LEN_MIN;\n  if (t < u)\n    t = u;\n  if (t < t0)\n    t0 = t;\n\n  /* Adjust t0 until we can encode a character after a space. */\n  for (; t0 > u; t0--)\n  {\n    if (!HSPACE(*(t0 - 1)))\n      continue;\n    t = t0 + 1;\n    if (icode)\n      while ((t < (u + ulen)) && CONTINUATION_BYTE(*t))\n        t++;\n    if ((try_block(t0, t - t0, icode, tocode, &encoder, &wlen) == 0) &&\n        ((col + (t0 - u) + wlen) <= (ENCWORD_LEN_MAX + 1)))\n    {\n      break;\n    }\n  }\n\n  /* Adjust t1 until we can encode a character before a space. */\n  for (; t1 < (u + ulen); t1++)\n  {\n    if (!HSPACE(*t1))\n      continue;\n    t = t1 - 1;\n    if (icode)\n      while (CONTINUATION_BYTE(*t))\n        t--;\n    if ((try_block(t, t1 - t, icode, tocode, &encoder, &wlen) == 0) &&\n        ((1 + wlen + (u + ulen - t1)) <= (ENCWORD_LEN_MAX + 1)))\n    {\n      break;\n    }\n  }\n\n  /* We shall encode the region [t0,t1). */\n\n  /* Initialise the output buffer with the us-ascii prefix. */\n  buflen = 2 * ulen;\n  buf = mutt_mem_malloc(buflen);\n  bufpos = t0 - u;\n  memcpy(buf, u, t0 - u);\n\n  col += t0 - u;\n\n  t = t0;\n  while (true)\n  {\n    /* Find how much we can encode. */\n    size_t n = choose_block(t, t1 - t, col, icode, tocode, &encoder, &wlen);\n    if (n == (t1 - t))\n    {\n      /* See if we can fit the us-ascii suffix, too. */\n      if ((col + wlen + (u + ulen - t1)) <= (ENCWORD_LEN_MAX + 1))\n        break;\n      n = t1 - t - 1;\n      if (icode)\n        while (CONTINUATION_BYTE(t[n]))\n          n--;\n      if (!n)\n      {\n        /* This should only happen in the really stupid case where the\n           only word that needs encoding is one character long, but\n           there is too much us-ascii stuff after it to use a single\n           encoded word. We add the next word to the encoded region\n           and try again. */\n        assert(t1 < (u + ulen));\n        for (t1++; (t1 < (u + ulen)) && !HSPACE(*t1); t1++)\n          ;\n        continue;\n      }\n      n = choose_block(t, n, col, icode, tocode, &encoder, &wlen);\n    }\n\n    /* Add to output buffer. */\n    const char *line_break = \"\\n\\t\";\n    const int lb_len = 2; /* strlen(line_break) */\n\n    if ((bufpos + wlen + lb_len) > buflen)\n    {\n      buflen = bufpos + wlen + lb_len;\n      mutt_mem_realloc(&buf, buflen);\n    }\n    r = encode_block(buf + bufpos, t, n, icode, tocode, encoder);\n    assert(r == wlen);\n    bufpos += wlen;\n    memcpy(buf + bufpos, line_break, lb_len);\n    bufpos += lb_len;\n\n    col = 1;\n\n    t += n;\n  }\n\n  /* Add last encoded word and us-ascii suffix to buffer. */\n  buflen = bufpos + wlen + (u + ulen - t1);\n  mutt_mem_realloc(&buf, buflen + 1);\n  r = encode_block(buf + bufpos, t, t1 - t, icode, tocode, encoder);\n  assert(r == wlen);\n  bufpos += wlen;\n  memcpy(buf + bufpos, t1, u + ulen - t1);\n\n  FREE(&tocode1);\n  FREE(&u);\n\n  buf[buflen] = '\\0';\n\n  *e = buf;\n  *elen = buflen + 1;\n  return rc;\n}\n\n/**\n * mutt_rfc2047_encode - RFC-2047-encode a string\n * @param[in,out] pd       String to be encoded, and resulting encoded string\n * @param[in]     specials Special characters to be encoded\n * @param[in]     col      Starting index in string\n * @param[in]     charsets List of charsets to choose from\n */\nvoid mutt_rfc2047_encode(char **pd, const char *specials, int col, const char *charsets)\n{\n  char *e = NULL;\n  size_t elen;\n\n  if (!Charset || !*pd)\n    return;\n\n  if (!charsets || !*charsets)\n    charsets = \"utf-8\";\n\n  rfc2047_encode(*pd, strlen(*pd), col, Charset, charsets, &e, &elen, specials);\n\n  FREE(pd);\n  *pd = e;\n}\n\n/**\n * mutt_rfc2047_decode - Decode any RFC2047-encoded header fields\n * @param[in,out] pd  String to be decoded, and resulting decoded string\n *\n * Try to decode anything that looks like a valid RFC2047 encoded header field,\n * ignoring RFC822 parsing rules. If decoding fails, for example due to an\n * invalid base64 string, the original input is left untouched.\n */\nvoid mutt_rfc2047_decode(char **pd)\n{\n  if (!pd || !*pd)\n    return;\n\n  struct Buffer buf = { 0 }; /* Output buffer                          */\n  char *s = *pd;             /* Read pointer                           */\n  char *beg;                 /* Begin of encoded word                  */\n  enum ContentEncoding enc;  /* ENCBASE64 or ENCQUOTEDPRINTABLE        */\n  char *charset;             /* Which charset                          */\n  size_t charsetlen;         /* Length of the charset                  */\n  char *text;                /* Encoded text                           */\n  size_t textlen;            /* Length of encoded text                 */\n\n  /* Keep some state in case the next decoded word is using the same charset\n   * and it happens to be split in the middle of a multibyte character.\n   * See https://github.com/neomutt/neomutt/issues/1015\n   */\n  struct Buffer prev = { 0 }; /* Previously decoded word                */\n  char *prev_charset = NULL;  /* Previously used charset                */\n  size_t prev_charsetlen = 0; /* Length of the previously used charset  */\n\n  while (*s)\n  {\n    beg = parse_encoded_word(s, &enc, &charset, &charsetlen, &text, &textlen);\n    if (beg != s)\n    {\n      /* Some non-encoded text was found */\n      size_t holelen = beg ? beg - s : mutt_str_strlen(s);\n\n      /* Ignore whitespace between encoded words */\n      if (beg && mutt_str_lws_len(s, holelen) == holelen)\n      {\n        s = beg;\n        continue;\n      }\n\n      /* If we have some previously decoded text, add it now */\n      if (prev.data)\n      {\n        finalize_chunk(&buf, &prev, prev_charset, prev_charsetlen);\n      }\n\n      /* Add non-encoded part */\n      {\n        if (AssumedCharset && *AssumedCharset)\n        {\n          char *conv = mutt_str_substr_dup(s, s + holelen);\n          mutt_ch_convert_nonmime_string(&conv);\n          mutt_buffer_addstr(&buf, conv);\n          FREE(&conv);\n        }\n        else\n        {\n          mutt_buffer_add(&buf, s, holelen);\n        }\n      }\n      s += holelen;\n    }\n    if (beg)\n    {\n      /* Some encoded text was found */\n      text[textlen] = '\\0';\n      char *decoded = rfc2047_decode_word(text, textlen, enc);\n      if (decoded == NULL)\n      {\n        return;\n      }\n      if (prev.data && ((prev_charsetlen != charsetlen) ||\n                        (strncmp(prev_charset, charset, charsetlen) != 0)))\n      {\n        /* Different charset, convert the previous chunk and add it to the\n         * final result */\n        finalize_chunk(&buf, &prev, prev_charset, prev_charsetlen);\n      }\n\n      mutt_buffer_addstr(&prev, decoded);\n      FREE(&decoded);\n      prev_charset = charset;\n      prev_charsetlen = charsetlen;\n      s = text + textlen + 2; /* Skip final ?= */\n    }\n  }\n\n  /* Save the last chunk */\n  if (prev.data)\n  {\n    finalize_chunk(&buf, &prev, prev_charset, prev_charsetlen);\n  }\n\n  mutt_buffer_addch(&buf, '\\0');\n  *pd = buf.data;\n}\n", "#define TEST_NO_MAIN\n#include \"acutest.h\"\n\n#include \"mutt/base64.h\"\n\n#include <string.h>\n\nstatic const char clear[] = \"Hello\";\nstatic const char encoded[] = \"SGVsbG8=\";\n\nvoid test_base64_encode(void)\n{\n  char buffer[16];\n  size_t len = mutt_b64_encode(buffer, clear, sizeof(clear) - 1, sizeof(buffer));\n  if (!TEST_CHECK(len == sizeof(encoded) - 1))\n  {\n    TEST_MSG(\"Expected: %zu\", sizeof(encoded) - 1);\n    TEST_MSG(\"Actual  : %zu\", len);\n  }\n  if (!TEST_CHECK(strcmp(buffer, encoded) == 0))\n  {\n    TEST_MSG(\"Expected: %zu\", encoded);\n    TEST_MSG(\"Actual  : %zu\", buffer);\n  }\n}\n\nvoid test_base64_decode(void)\n{\n  char buffer[16];\n  int len = mutt_b64_decode(buffer, encoded, sizeof(buffer));\n  if (!TEST_CHECK(len == sizeof(clear) - 1))\n  {\n    TEST_MSG(\"Expected: %zu\", sizeof(clear) - 1);\n    TEST_MSG(\"Actual  : %zu\", len);\n  }\n  buffer[len] = '\\0';\n  if (!TEST_CHECK(strcmp(buffer, clear) == 0))\n  {\n    TEST_MSG(\"Expected: %s\", clear);\n    TEST_MSG(\"Actual  : %s\", buffer);\n  }\n}\n\nvoid test_base64_lengths(void)\n{\n  const char *in = \"FuseMuse\";\n  char out1[32];\n  char out2[32];\n  size_t enclen;\n  int declen;\n\n  /* Encoding a zero-length string should fail */\n  enclen = mutt_b64_encode(out1, in, 0, 32);\n  if (!TEST_CHECK(enclen == 0))\n  {\n    TEST_MSG(\"Expected: %zu\", 0);\n    TEST_MSG(\"Actual  : %zu\", enclen);\n  }\n\n  /* Decoding a zero-length string should fail, too */\n  out1[0] = '\\0';\n  declen = mutt_b64_decode(out2, out1, sizeof(out2));\n  if (!TEST_CHECK(declen == -1))\n  {\n    TEST_MSG(\"Expected: %zu\", -1);\n    TEST_MSG(\"Actual  : %zu\", declen);\n  }\n\n  /* Encode one to eight bytes, check the lengths of the returned string */\n  for (size_t i = 1; i <= 8; ++i)\n  {\n    enclen = mutt_b64_encode(out1, in, i, 32);\n    size_t exp = ((i + 2) / 3) << 2;\n    if (!TEST_CHECK(enclen == exp))\n    {\n      TEST_MSG(\"Expected: %zu\", exp);\n      TEST_MSG(\"Actual  : %zu\", enclen);\n    }\n    declen = mutt_b64_decode(out2, out1, sizeof(out2));\n    if (!TEST_CHECK(declen == i))\n    {\n      TEST_MSG(\"Expected: %zu\", i);\n      TEST_MSG(\"Actual  : %zu\", declen);\n    }\n    out2[declen] = '\\0';\n    if (!TEST_CHECK(strncmp(out2, in, i) == 0))\n    {\n      TEST_MSG(\"Expected: %s\", in);\n      TEST_MSG(\"Actual  : %s\", out2);\n    }\n  }\n}\n"], "filenames": ["imap/auth_cram.c", "imap/auth_gss.c", "mutt/base64.c", "mutt/base64.h", "mutt/rfc2047.c", "test/base64.c"], "buggy_code_start_loc": [137, 206, 120, 31, 402, 30], "buggy_code_end_loc": [138, 242, 158, 32, 404, 80], "fixing_code_start_loc": [137, 206, 120, 31, 402, 30], "fixing_code_end_loc": [138, 242, 166, 32, 405, 80], "type": "CWE-120", "message": "An issue was discovered in Mutt before 1.10.1 and NeoMutt before 2018-07-16. They have a buffer overflow via base64 data.", "other": {"cve": {"id": "CVE-2018-14359", "sourceIdentifier": "cve@mitre.org", "published": "2018-07-17T17:29:00.810", "lastModified": "2020-05-19T17:13:37.490", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in Mutt before 1.10.1 and NeoMutt before 2018-07-16. They have a buffer overflow via base64 data."}, {"lang": "es", "value": "Se ha descubierto un problema en Mutt en versiones anteriores a la 1.10.1 y NeoMutt en versiones anteriores al 2018-07-16. Tienen un desbordamiento de b\u00fafer mediante datos en base64."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-120"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mutt:mutt:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.10.1", "matchCriteriaId": "2FA2C3A6-423C-4BE5-8FA7-0241384D58D0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:neomutt:neomutt:*:*:*:*:*:*:*:*", "versionEndExcluding": "20180716", "matchCriteriaId": "1C15CCD1-1752-4913-9506-32035B52A513"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:esm:*:*:*", "matchCriteriaId": "8D305F7A-D159-4716-AB26-5E38BB5CD991"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "http://www.mutt.org/news.html", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://github.com/neomutt/neomutt/commit/6f163e07ae68654d7ac5268cbb7565f6df79ad85", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://gitlab.com/muttmua/mutt/commit/3d9028fec8f4d08db2251096307c0bbbebce669a", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/08/msg00001.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://neomutt.org/2018/07/16/release", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://security.gentoo.org/glsa/201810-07", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3719-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3719-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3719-3/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2018/dsa-4277", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/neomutt/neomutt/commit/6f163e07ae68654d7ac5268cbb7565f6df79ad85"}}