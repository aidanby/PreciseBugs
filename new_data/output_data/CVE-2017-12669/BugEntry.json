{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                         CCCC   AAA   L      SSSSS                           %\n%                        C      A   A  L      SS                              %\n%                        C      AAAAA  L       SSS                            %\n%                        C      A   A  L         SS                           %\n%                         CCCC  A   A  LLLLL  SSSSS                           %\n%                                                                             %\n%                                                                             %\n%                 Read/Write CALS Raster Group 1 Image Format                 %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2017 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://www.imagemagick.org/script/license.php                           %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n% The CALS raster format is a standard developed by the Computer Aided\n% Acquisition and Logistics Support (CALS) office of the United States\n% Department of Defense to standardize graphics data interchange for\n% electronic publishing, especially in the areas of technical graphics,\n% CAD/CAM, and image processing applications.\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/module.h\"\n\f\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n/*\n Forward declarations.\n*/\nstatic MagickBooleanType\n  WriteCALSImage(const ImageInfo *,Image *,ExceptionInfo *);\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s C A L S                                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsCALS() returns MagickTrue if the image format type, identified by the\n%  magick string, is CALS Raster Group 1.\n%\n%  The format of the IsCALS method is:\n%\n%      MagickBooleanType IsCALS(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsCALS(const unsigned char *magick,const size_t length)\n{\n  if (length < 128)\n    return(MagickFalse);\n  if (LocaleNCompare((const char *) magick,\"version: MIL-STD-1840\",21) == 0)\n    return(MagickTrue);\n  if (LocaleNCompare((const char *) magick,\"srcdocid:\",9) == 0)\n    return(MagickTrue);\n  if (LocaleNCompare((const char *) magick,\"rorient:\",8) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d C A L S I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadCALSImage() reads an CALS Raster Group 1 image format image file and\n%  returns it.  It allocates the memory necessary for the new Image structure\n%  and returns a pointer to the new image.\n%\n%  The format of the ReadCALSImage method is:\n%\n%      Image *ReadCALSImage(const ImageInfo *image_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadCALSImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent],\n    header[MagickPathExtent],\n    message[MagickPathExtent];\n\n  FILE\n    *file;\n\n  Image\n    *image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    c,\n    unique_file;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  unsigned long\n    density,\n    direction,\n    height,\n    orientation,\n    pel_path,\n    type,\n    width;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read CALS header.\n  */\n  (void) ResetMagickMemory(header,0,sizeof(header));\n  density=0;\n  direction=0;\n  orientation=1;\n  pel_path=0;\n  type=1;\n  width=0;\n  height=0;\n  for (i=0; i < 16; i++)\n  {\n    if (ReadBlob(image,128,(unsigned char *) header) != 128)\n      break;\n    switch (*header)\n    {\n      case 'R':\n      case 'r':\n      {\n        if (LocaleNCompare(header,\"rdensty:\",8) == 0)\n          {\n            (void) sscanf(header+8,\"%lu\",&density);\n            break;\n          }\n        if (LocaleNCompare(header,\"rpelcnt:\",8) == 0)\n          {\n            (void) sscanf(header+8,\"%lu,%lu\",&width,&height);\n            break;\n          }\n        if (LocaleNCompare(header,\"rorient:\",8) == 0)\n          {\n            (void) sscanf(header+8,\"%lu,%lu\",&pel_path,&direction);\n            if (pel_path == 90)\n              orientation=5;\n            else\n              if (pel_path == 180)\n                orientation=3;\n              else\n                if (pel_path == 270)\n                  orientation=7;\n            if (direction == 90)\n              orientation++;\n            break;\n          }\n        if (LocaleNCompare(header,\"rtype:\",6) == 0)\n          {\n            (void) sscanf(header+6,\"%lu\",&type);\n            break;\n          }\n        break;\n      }\n    }\n  }\n  /*\n    Read CALS pixels.\n  */\n  file=(FILE *) NULL;\n  unique_file=AcquireUniqueFileResource(filename);\n  if (unique_file != -1)\n    file=fdopen(unique_file,\"wb\");\n  if ((unique_file == -1) || (file == (FILE *) NULL))\n    ThrowImageException(FileOpenError,\"UnableToCreateTemporaryFile\");\n  while ((c=ReadBlobByte(image)) != EOF)\n    (void) fputc(c,file);\n  (void) fclose(file);\n  (void) CloseBlob(image);\n  image=DestroyImage(image);\n  read_info=CloneImageInfo(image_info);\n  SetImageInfoBlob(read_info,(void *) NULL,0);\n  (void) FormatLocaleString(read_info->filename,MagickPathExtent,\"group4:%s\",\n    filename);\n  (void) FormatLocaleString(message,MagickPathExtent,\"%lux%lu\",width,height);\n  (void) CloneString(&read_info->size,message);\n  (void) FormatLocaleString(message,MagickPathExtent,\"%lu\",density);\n  (void) CloneString(&read_info->density,message);\n  read_info->orientation=(OrientationType) orientation;\n  image=ReadImage(read_info,exception);\n  if (image != (Image *) NULL)\n    {\n      (void) CopyMagickString(image->filename,image_info->filename,\n        MagickPathExtent);\n      (void) CopyMagickString(image->magick_filename,image_info->filename,\n        MagickPathExtent);\n      (void) CopyMagickString(image->magick,\"CALS\",MagickPathExtent);\n    }\n  read_info=DestroyImageInfo(read_info);\n  (void) RelinquishUniqueFileResource(filename);\n  return(image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r C A L S I m a g e                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterCALSImage() adds attributes for the CALS Raster Group 1 image file\n%  image format to the list of supported formats.  The attributes include the\n%  image format tag, a method to read and/or write the format, whether the\n%  format supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief description\n%  of the format.\n%\n%  The format of the RegisterCALSImage method is:\n%\n%      size_t RegisterCALSImage(void)\n%\n*/\nModuleExport size_t RegisterCALSImage(void)\n{\n#define CALSDescription  \"Continuous Acquisition and Life-cycle Support Type 1\"\n#define CALSNote  \"Specified in MIL-R-28002 and MIL-PRF-28002\"\n\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"CALS\",\"CAL\",CALSDescription);\n  entry->decoder=(DecodeImageHandler *) ReadCALSImage;\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n  entry->encoder=(EncodeImageHandler *) WriteCALSImage;\n#endif\n  entry->flags^=CoderAdjoinFlag;\n  entry->magick=(IsImageFormatHandler *) IsCALS;\n  entry->note=ConstantString(CALSNote);\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"CALS\",\"CALS\",CALSDescription);\n  entry->decoder=(DecodeImageHandler *) ReadCALSImage;\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n  entry->encoder=(EncodeImageHandler *) WriteCALSImage;\n#endif\n  entry->flags^=CoderAdjoinFlag;\n  entry->magick=(IsImageFormatHandler *) IsCALS;\n  entry->note=ConstantString(CALSNote);\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r C A L S I m a g e                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterCALSImage() removes format registrations made by the\n%  CALS module from the list of supported formats.\n%\n%  The format of the UnregisterCALSImage method is:\n%\n%      UnregisterCALSImage(void)\n%\n*/\nModuleExport void UnregisterCALSImage(void)\n{\n  (void) UnregisterMagickInfo(\"CAL\");\n  (void) UnregisterMagickInfo(\"CALS\");\n}\n\f\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e C A L S I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteCALSImage() writes an image to a file in CALS Raster Group 1 image\n%  format.\n%\n%  The format of the WriteCALSImage method is:\n%\n%      MagickBooleanType WriteCALSImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic ssize_t WriteCALSRecord(Image *image,const char *data)\n{\n  char\n    pad[128];\n\n  register const char\n    *p;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    count;\n\n  i=0;\n  count=0;\n  if (data != (const char *) NULL)\n    {\n      p=data;\n      for (i=0; (i < 128) && (p[i] != '\\0'); i++);\n      count=WriteBlob(image,(size_t) i,(const unsigned char *) data);\n    }\n  if (i < 128)\n    {\n      i=128-i;\n      (void) ResetMagickMemory(pad,' ',(size_t) i);\n      count=WriteBlob(image,(size_t) i,(const unsigned char *) pad);\n    }\n  return(count);\n}\n\nstatic MagickBooleanType WriteCALSImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  char\n    header[129];\n\n  Image\n    *group4_image;\n\n  ImageInfo\n    *write_info;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  size_t\n    density,\n    length,\n    orient_x,\n    orient_y;\n\n  ssize_t\n    count;\n\n  unsigned char\n    *group4;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  /*\n    Create standard CALS header.\n  */\n  count=WriteCALSRecord(image,\"srcdocid: NONE\");\n  (void) count;\n  count=WriteCALSRecord(image,\"dstdocid: NONE\");\n  count=WriteCALSRecord(image,\"txtfilid: NONE\");\n  count=WriteCALSRecord(image,\"figid: NONE\");\n  count=WriteCALSRecord(image,\"srcgph: NONE\");\n  count=WriteCALSRecord(image,\"doccls: NONE\");\n  count=WriteCALSRecord(image,\"rtype: 1\");\n  orient_x=0;\n  orient_y=0;\n  switch (image->orientation)\n  {\n    case TopRightOrientation:\n    {\n      orient_x=180;\n      orient_y=270;\n      break;\n    }\n    case BottomRightOrientation:\n    {\n      orient_x=180;\n      orient_y=90;\n      break;\n    }\n    case BottomLeftOrientation:\n    {\n      orient_y=90;\n      break;\n    }\n    case LeftTopOrientation:\n    {\n      orient_x=270;\n      break;\n    }\n    case RightTopOrientation:\n    {\n      orient_x=270;\n      orient_y=180;\n      break;\n    }\n    case RightBottomOrientation:\n    {\n      orient_x=90;\n      orient_y=180;\n      break;\n    }\n    case LeftBottomOrientation:\n    {\n      orient_x=90;\n      break;\n    }\n    default:\n    {\n      orient_y=270;\n      break;\n    }\n  }\n  (void) FormatLocaleString(header,sizeof(header),\"rorient: %03ld,%03ld\",\n    (long) orient_x,(long) orient_y);\n  count=WriteCALSRecord(image,header);\n  (void) FormatLocaleString(header,sizeof(header),\"rpelcnt: %06lu,%06lu\",\n    (unsigned long) image->columns,(unsigned long) image->rows);\n  count=WriteCALSRecord(image,header);  \n  density=200;\n  if (image_info->density != (char *) NULL)\n    {\n      GeometryInfo\n        geometry_info;\n\n      (void) ParseGeometry(image_info->density,&geometry_info);\n      density=(size_t) floor(geometry_info.rho+0.5);\n    }\n  (void) FormatLocaleString(header,sizeof(header),\"rdensty: %04lu\",\n    (unsigned long) density);\n  count=WriteCALSRecord(image,header);\n  count=WriteCALSRecord(image,\"notes: NONE\");\n  (void) ResetMagickMemory(header,' ',128);\n  for (i=0; i < 5; i++)\n    (void) WriteBlob(image,128,(unsigned char *) header);\n  /*\n    Write CALS pixels.\n  */\n  write_info=CloneImageInfo(image_info);\n  (void) CopyMagickString(write_info->filename,\"GROUP4:\",MagickPathExtent);\n  (void) CopyMagickString(write_info->magick,\"GROUP4\",MagickPathExtent);\n  group4_image=CloneImage(image,0,0,MagickTrue,exception);\n  if (group4_image == (Image *) NULL)\n    {\n      (void) CloseBlob(image);\n      return(MagickFalse);\n    }\n  group4=(unsigned char *) ImageToBlob(write_info,group4_image,&length,\n    exception);\n  group4_image=DestroyImage(group4_image);\n  if (group4 == (unsigned char *) NULL)\n    {\n      (void) CloseBlob(image);\n      return(MagickFalse);\n    }\n  write_info=DestroyImageInfo(write_info);\n  if (WriteBlob(image,length,group4) != (ssize_t) length)\n    status=MagickFalse;\n  group4=(unsigned char *) RelinquishMagickMemory(group4);\n  (void) CloseBlob(image);\n  return(status);\n}\n#endif\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                         CCCC   AAA   L      SSSSS                           %\n%                        C      A   A  L      SS                              %\n%                        C      AAAAA  L       SSS                            %\n%                        C      A   A  L         SS                           %\n%                         CCCC  A   A  LLLLL  SSSSS                           %\n%                                                                             %\n%                                                                             %\n%                 Read/Write CALS Raster Group 1 Image Format                 %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2017 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://www.imagemagick.org/script/license.php                           %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n% The CALS raster format is a standard developed by the Computer Aided\n% Acquisition and Logistics Support (CALS) office of the United States\n% Department of Defense to standardize graphics data interchange for\n% electronic publishing, especially in the areas of technical graphics,\n% CAD/CAM, and image processing applications.\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/module.h\"\n\f\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n/*\n Forward declarations.\n*/\nstatic MagickBooleanType\n  WriteCALSImage(const ImageInfo *,Image *,ExceptionInfo *);\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s C A L S                                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsCALS() returns MagickTrue if the image format type, identified by the\n%  magick string, is CALS Raster Group 1.\n%\n%  The format of the IsCALS method is:\n%\n%      MagickBooleanType IsCALS(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsCALS(const unsigned char *magick,const size_t length)\n{\n  if (length < 128)\n    return(MagickFalse);\n  if (LocaleNCompare((const char *) magick,\"version: MIL-STD-1840\",21) == 0)\n    return(MagickTrue);\n  if (LocaleNCompare((const char *) magick,\"srcdocid:\",9) == 0)\n    return(MagickTrue);\n  if (LocaleNCompare((const char *) magick,\"rorient:\",8) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d C A L S I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadCALSImage() reads an CALS Raster Group 1 image format image file and\n%  returns it.  It allocates the memory necessary for the new Image structure\n%  and returns a pointer to the new image.\n%\n%  The format of the ReadCALSImage method is:\n%\n%      Image *ReadCALSImage(const ImageInfo *image_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadCALSImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent],\n    header[MagickPathExtent],\n    message[MagickPathExtent];\n\n  FILE\n    *file;\n\n  Image\n    *image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    c,\n    unique_file;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  unsigned long\n    density,\n    direction,\n    height,\n    orientation,\n    pel_path,\n    type,\n    width;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read CALS header.\n  */\n  (void) ResetMagickMemory(header,0,sizeof(header));\n  density=0;\n  direction=0;\n  orientation=1;\n  pel_path=0;\n  type=1;\n  width=0;\n  height=0;\n  for (i=0; i < 16; i++)\n  {\n    if (ReadBlob(image,128,(unsigned char *) header) != 128)\n      break;\n    switch (*header)\n    {\n      case 'R':\n      case 'r':\n      {\n        if (LocaleNCompare(header,\"rdensty:\",8) == 0)\n          {\n            (void) sscanf(header+8,\"%lu\",&density);\n            break;\n          }\n        if (LocaleNCompare(header,\"rpelcnt:\",8) == 0)\n          {\n            (void) sscanf(header+8,\"%lu,%lu\",&width,&height);\n            break;\n          }\n        if (LocaleNCompare(header,\"rorient:\",8) == 0)\n          {\n            (void) sscanf(header+8,\"%lu,%lu\",&pel_path,&direction);\n            if (pel_path == 90)\n              orientation=5;\n            else\n              if (pel_path == 180)\n                orientation=3;\n              else\n                if (pel_path == 270)\n                  orientation=7;\n            if (direction == 90)\n              orientation++;\n            break;\n          }\n        if (LocaleNCompare(header,\"rtype:\",6) == 0)\n          {\n            (void) sscanf(header+6,\"%lu\",&type);\n            break;\n          }\n        break;\n      }\n    }\n  }\n  /*\n    Read CALS pixels.\n  */\n  file=(FILE *) NULL;\n  unique_file=AcquireUniqueFileResource(filename);\n  if (unique_file != -1)\n    file=fdopen(unique_file,\"wb\");\n  if ((unique_file == -1) || (file == (FILE *) NULL))\n    ThrowImageException(FileOpenError,\"UnableToCreateTemporaryFile\");\n  while ((c=ReadBlobByte(image)) != EOF)\n    (void) fputc(c,file);\n  (void) fclose(file);\n  (void) CloseBlob(image);\n  image=DestroyImage(image);\n  read_info=CloneImageInfo(image_info);\n  SetImageInfoBlob(read_info,(void *) NULL,0);\n  (void) FormatLocaleString(read_info->filename,MagickPathExtent,\"group4:%s\",\n    filename);\n  (void) FormatLocaleString(message,MagickPathExtent,\"%lux%lu\",width,height);\n  (void) CloneString(&read_info->size,message);\n  (void) FormatLocaleString(message,MagickPathExtent,\"%lu\",density);\n  (void) CloneString(&read_info->density,message);\n  read_info->orientation=(OrientationType) orientation;\n  image=ReadImage(read_info,exception);\n  if (image != (Image *) NULL)\n    {\n      (void) CopyMagickString(image->filename,image_info->filename,\n        MagickPathExtent);\n      (void) CopyMagickString(image->magick_filename,image_info->filename,\n        MagickPathExtent);\n      (void) CopyMagickString(image->magick,\"CALS\",MagickPathExtent);\n    }\n  read_info=DestroyImageInfo(read_info);\n  (void) RelinquishUniqueFileResource(filename);\n  return(image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r C A L S I m a g e                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterCALSImage() adds attributes for the CALS Raster Group 1 image file\n%  image format to the list of supported formats.  The attributes include the\n%  image format tag, a method to read and/or write the format, whether the\n%  format supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief description\n%  of the format.\n%\n%  The format of the RegisterCALSImage method is:\n%\n%      size_t RegisterCALSImage(void)\n%\n*/\nModuleExport size_t RegisterCALSImage(void)\n{\n#define CALSDescription  \"Continuous Acquisition and Life-cycle Support Type 1\"\n#define CALSNote  \"Specified in MIL-R-28002 and MIL-PRF-28002\"\n\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"CALS\",\"CAL\",CALSDescription);\n  entry->decoder=(DecodeImageHandler *) ReadCALSImage;\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n  entry->encoder=(EncodeImageHandler *) WriteCALSImage;\n#endif\n  entry->flags^=CoderAdjoinFlag;\n  entry->magick=(IsImageFormatHandler *) IsCALS;\n  entry->note=ConstantString(CALSNote);\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"CALS\",\"CALS\",CALSDescription);\n  entry->decoder=(DecodeImageHandler *) ReadCALSImage;\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n  entry->encoder=(EncodeImageHandler *) WriteCALSImage;\n#endif\n  entry->flags^=CoderAdjoinFlag;\n  entry->magick=(IsImageFormatHandler *) IsCALS;\n  entry->note=ConstantString(CALSNote);\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r C A L S I m a g e                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterCALSImage() removes format registrations made by the\n%  CALS module from the list of supported formats.\n%\n%  The format of the UnregisterCALSImage method is:\n%\n%      UnregisterCALSImage(void)\n%\n*/\nModuleExport void UnregisterCALSImage(void)\n{\n  (void) UnregisterMagickInfo(\"CAL\");\n  (void) UnregisterMagickInfo(\"CALS\");\n}\n\f\n#if defined(MAGICKCORE_TIFF_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e C A L S I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteCALSImage() writes an image to a file in CALS Raster Group 1 image\n%  format.\n%\n%  The format of the WriteCALSImage method is:\n%\n%      MagickBooleanType WriteCALSImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic ssize_t WriteCALSRecord(Image *image,const char *data)\n{\n  char\n    pad[128];\n\n  register const char\n    *p;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    count;\n\n  i=0;\n  count=0;\n  if (data != (const char *) NULL)\n    {\n      p=data;\n      for (i=0; (i < 128) && (p[i] != '\\0'); i++);\n      count=WriteBlob(image,(size_t) i,(const unsigned char *) data);\n    }\n  if (i < 128)\n    {\n      i=128-i;\n      (void) ResetMagickMemory(pad,' ',(size_t) i);\n      count=WriteBlob(image,(size_t) i,(const unsigned char *) pad);\n    }\n  return(count);\n}\n\nstatic MagickBooleanType WriteCALSImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  char\n    header[129];\n\n  Image\n    *group4_image;\n\n  ImageInfo\n    *write_info;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  size_t\n    density,\n    length,\n    orient_x,\n    orient_y;\n\n  ssize_t\n    count;\n\n  unsigned char\n    *group4;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  /*\n    Create standard CALS header.\n  */\n  count=WriteCALSRecord(image,\"srcdocid: NONE\");\n  (void) count;\n  count=WriteCALSRecord(image,\"dstdocid: NONE\");\n  count=WriteCALSRecord(image,\"txtfilid: NONE\");\n  count=WriteCALSRecord(image,\"figid: NONE\");\n  count=WriteCALSRecord(image,\"srcgph: NONE\");\n  count=WriteCALSRecord(image,\"doccls: NONE\");\n  count=WriteCALSRecord(image,\"rtype: 1\");\n  orient_x=0;\n  orient_y=0;\n  switch (image->orientation)\n  {\n    case TopRightOrientation:\n    {\n      orient_x=180;\n      orient_y=270;\n      break;\n    }\n    case BottomRightOrientation:\n    {\n      orient_x=180;\n      orient_y=90;\n      break;\n    }\n    case BottomLeftOrientation:\n    {\n      orient_y=90;\n      break;\n    }\n    case LeftTopOrientation:\n    {\n      orient_x=270;\n      break;\n    }\n    case RightTopOrientation:\n    {\n      orient_x=270;\n      orient_y=180;\n      break;\n    }\n    case RightBottomOrientation:\n    {\n      orient_x=90;\n      orient_y=180;\n      break;\n    }\n    case LeftBottomOrientation:\n    {\n      orient_x=90;\n      break;\n    }\n    default:\n    {\n      orient_y=270;\n      break;\n    }\n  }\n  (void) FormatLocaleString(header,sizeof(header),\"rorient: %03ld,%03ld\",\n    (long) orient_x,(long) orient_y);\n  count=WriteCALSRecord(image,header);\n  (void) FormatLocaleString(header,sizeof(header),\"rpelcnt: %06lu,%06lu\",\n    (unsigned long) image->columns,(unsigned long) image->rows);\n  count=WriteCALSRecord(image,header);  \n  density=200;\n  if (image_info->density != (char *) NULL)\n    {\n      GeometryInfo\n        geometry_info;\n\n      (void) ParseGeometry(image_info->density,&geometry_info);\n      density=(size_t) floor(geometry_info.rho+0.5);\n    }\n  (void) FormatLocaleString(header,sizeof(header),\"rdensty: %04lu\",\n    (unsigned long) density);\n  count=WriteCALSRecord(image,header);\n  count=WriteCALSRecord(image,\"notes: NONE\");\n  (void) ResetMagickMemory(header,' ',128);\n  for (i=0; i < 5; i++)\n    (void) WriteBlob(image,128,(unsigned char *) header);\n  /*\n    Write CALS pixels.\n  */\n  write_info=CloneImageInfo(image_info);\n  (void) CopyMagickString(write_info->filename,\"GROUP4:\",MagickPathExtent);\n  (void) CopyMagickString(write_info->magick,\"GROUP4\",MagickPathExtent);\n  group4_image=CloneImage(image,0,0,MagickTrue,exception);\n  if (group4_image == (Image *) NULL)\n    {\n      write_info=DestroyImageInfo(write_info);\n      (void) CloseBlob(image);\n      return(MagickFalse);\n    }\n  group4=(unsigned char *) ImageToBlob(write_info,group4_image,&length,\n    exception);\n  group4_image=DestroyImage(group4_image);\n  if (group4 == (unsigned char *) NULL)\n    {\n      write_info=DestroyImageInfo(write_info);\n      (void) CloseBlob(image);\n      return(MagickFalse);\n    }\n  write_info=DestroyImageInfo(write_info);\n  if (WriteBlob(image,length,group4) != (ssize_t) length)\n    status=MagickFalse;\n  group4=(unsigned char *) RelinquishMagickMemory(group4);\n  (void) CloseBlob(image);\n  return(status);\n}\n#endif\n"], "filenames": ["coders/cals.c"], "buggy_code_start_loc": [566], "buggy_code_end_loc": [574], "fixing_code_start_loc": [567], "fixing_code_end_loc": [577], "type": "CWE-772", "message": "ImageMagick 7.0.6-2 has a memory leak vulnerability in WriteCALSImage in coders/cals.c.", "other": {"cve": {"id": "CVE-2017-12669", "sourceIdentifier": "cve@mitre.org", "published": "2017-08-07T21:29:00.423", "lastModified": "2020-10-14T18:52:29.867", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "ImageMagick 7.0.6-2 has a memory leak vulnerability in WriteCALSImage in coders/cals.c."}, {"lang": "es", "value": "ImageMagick 7.0.6-2 tiene una vulnerabilidad de filtrado de memoria en WriteCALSImage en coders/cals.c."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-772"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.6-2:*:*:*:*:*:*:*", "matchCriteriaId": "7E47D35D-B2EB-4957-A0C8-7DE54233997F"}]}]}], "references": [{"url": "https://github.com/ImageMagick/ImageMagick/commit/73b6c35cede48ccb2e29dbe62c2d77488e5e70b7", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/issues/571", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/73b6c35cede48ccb2e29dbe62c2d77488e5e70b7"}}