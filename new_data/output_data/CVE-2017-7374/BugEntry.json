{"buggy_code": ["/*\n * This contains encryption functions for per-file encryption.\n *\n * Copyright (C) 2015, Google, Inc.\n * Copyright (C) 2015, Motorola Mobility\n *\n * Written by Michael Halcrow, 2014.\n *\n * Filename encryption additions\n *\tUday Savagaonkar, 2014\n * Encryption policy handling additions\n *\tIldar Muslukhov, 2014\n * Add fscrypt_pullback_bio_page()\n *\tJaegeuk Kim, 2015.\n *\n * This has not yet undergone a rigorous security audit.\n *\n * The usage of AES-XTS should conform to recommendations in NIST\n * Special Publication 800-38E and IEEE P1619/D16.\n */\n\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/module.h>\n#include <linux/scatterlist.h>\n#include <linux/ratelimit.h>\n#include <linux/dcache.h>\n#include <linux/namei.h>\n#include \"fscrypt_private.h\"\n\nstatic unsigned int num_prealloc_crypto_pages = 32;\nstatic unsigned int num_prealloc_crypto_ctxs = 128;\n\nmodule_param(num_prealloc_crypto_pages, uint, 0444);\nMODULE_PARM_DESC(num_prealloc_crypto_pages,\n\t\t\"Number of crypto pages to preallocate\");\nmodule_param(num_prealloc_crypto_ctxs, uint, 0444);\nMODULE_PARM_DESC(num_prealloc_crypto_ctxs,\n\t\t\"Number of crypto contexts to preallocate\");\n\nstatic mempool_t *fscrypt_bounce_page_pool = NULL;\n\nstatic LIST_HEAD(fscrypt_free_ctxs);\nstatic DEFINE_SPINLOCK(fscrypt_ctx_lock);\n\nstruct workqueue_struct *fscrypt_read_workqueue;\nstatic DEFINE_MUTEX(fscrypt_init_mutex);\n\nstatic struct kmem_cache *fscrypt_ctx_cachep;\nstruct kmem_cache *fscrypt_info_cachep;\n\n/**\n * fscrypt_release_ctx() - Releases an encryption context\n * @ctx: The encryption context to release.\n *\n * If the encryption context was allocated from the pre-allocated pool, returns\n * it to that pool. Else, frees it.\n *\n * If there's a bounce page in the context, this frees that.\n */\nvoid fscrypt_release_ctx(struct fscrypt_ctx *ctx)\n{\n\tunsigned long flags;\n\n\tif (ctx->flags & FS_CTX_HAS_BOUNCE_BUFFER_FL && ctx->w.bounce_page) {\n\t\tmempool_free(ctx->w.bounce_page, fscrypt_bounce_page_pool);\n\t\tctx->w.bounce_page = NULL;\n\t}\n\tctx->w.control_page = NULL;\n\tif (ctx->flags & FS_CTX_REQUIRES_FREE_ENCRYPT_FL) {\n\t\tkmem_cache_free(fscrypt_ctx_cachep, ctx);\n\t} else {\n\t\tspin_lock_irqsave(&fscrypt_ctx_lock, flags);\n\t\tlist_add(&ctx->free_list, &fscrypt_free_ctxs);\n\t\tspin_unlock_irqrestore(&fscrypt_ctx_lock, flags);\n\t}\n}\nEXPORT_SYMBOL(fscrypt_release_ctx);\n\n/**\n * fscrypt_get_ctx() - Gets an encryption context\n * @inode:       The inode for which we are doing the crypto\n * @gfp_flags:   The gfp flag for memory allocation\n *\n * Allocates and initializes an encryption context.\n *\n * Return: An allocated and initialized encryption context on success; error\n * value or NULL otherwise.\n */\nstruct fscrypt_ctx *fscrypt_get_ctx(const struct inode *inode, gfp_t gfp_flags)\n{\n\tstruct fscrypt_ctx *ctx = NULL;\n\tstruct fscrypt_info *ci = inode->i_crypt_info;\n\tunsigned long flags;\n\n\tif (ci == NULL)\n\t\treturn ERR_PTR(-ENOKEY);\n\n\t/*\n\t * We first try getting the ctx from a free list because in\n\t * the common case the ctx will have an allocated and\n\t * initialized crypto tfm, so it's probably a worthwhile\n\t * optimization. For the bounce page, we first try getting it\n\t * from the kernel allocator because that's just about as fast\n\t * as getting it from a list and because a cache of free pages\n\t * should generally be a \"last resort\" option for a filesystem\n\t * to be able to do its job.\n\t */\n\tspin_lock_irqsave(&fscrypt_ctx_lock, flags);\n\tctx = list_first_entry_or_null(&fscrypt_free_ctxs,\n\t\t\t\t\tstruct fscrypt_ctx, free_list);\n\tif (ctx)\n\t\tlist_del(&ctx->free_list);\n\tspin_unlock_irqrestore(&fscrypt_ctx_lock, flags);\n\tif (!ctx) {\n\t\tctx = kmem_cache_zalloc(fscrypt_ctx_cachep, gfp_flags);\n\t\tif (!ctx)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tctx->flags |= FS_CTX_REQUIRES_FREE_ENCRYPT_FL;\n\t} else {\n\t\tctx->flags &= ~FS_CTX_REQUIRES_FREE_ENCRYPT_FL;\n\t}\n\tctx->flags &= ~FS_CTX_HAS_BOUNCE_BUFFER_FL;\n\treturn ctx;\n}\nEXPORT_SYMBOL(fscrypt_get_ctx);\n\n/**\n * page_crypt_complete() - completion callback for page crypto\n * @req: The asynchronous cipher request context\n * @res: The result of the cipher operation\n */\nstatic void page_crypt_complete(struct crypto_async_request *req, int res)\n{\n\tstruct fscrypt_completion_result *ecr = req->data;\n\n\tif (res == -EINPROGRESS)\n\t\treturn;\n\tecr->res = res;\n\tcomplete(&ecr->completion);\n}\n\nint fscrypt_do_page_crypto(const struct inode *inode, fscrypt_direction_t rw,\n\t\t\t   u64 lblk_num, struct page *src_page,\n\t\t\t   struct page *dest_page, unsigned int len,\n\t\t\t   unsigned int offs, gfp_t gfp_flags)\n{\n\tstruct {\n\t\t__le64 index;\n\t\tu8 padding[FS_XTS_TWEAK_SIZE - sizeof(__le64)];\n\t} xts_tweak;\n\tstruct skcipher_request *req = NULL;\n\tDECLARE_FS_COMPLETION_RESULT(ecr);\n\tstruct scatterlist dst, src;\n\tstruct fscrypt_info *ci = inode->i_crypt_info;\n\tstruct crypto_skcipher *tfm = ci->ci_ctfm;\n\tint res = 0;\n\n\tBUG_ON(len == 0);\n\n\treq = skcipher_request_alloc(tfm, gfp_flags);\n\tif (!req) {\n\t\tprintk_ratelimited(KERN_ERR\n\t\t\t\t\"%s: crypto_request_alloc() failed\\n\",\n\t\t\t\t__func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tskcipher_request_set_callback(\n\t\treq, CRYPTO_TFM_REQ_MAY_BACKLOG | CRYPTO_TFM_REQ_MAY_SLEEP,\n\t\tpage_crypt_complete, &ecr);\n\n\tBUILD_BUG_ON(sizeof(xts_tweak) != FS_XTS_TWEAK_SIZE);\n\txts_tweak.index = cpu_to_le64(lblk_num);\n\tmemset(xts_tweak.padding, 0, sizeof(xts_tweak.padding));\n\n\tsg_init_table(&dst, 1);\n\tsg_set_page(&dst, dest_page, len, offs);\n\tsg_init_table(&src, 1);\n\tsg_set_page(&src, src_page, len, offs);\n\tskcipher_request_set_crypt(req, &src, &dst, len, &xts_tweak);\n\tif (rw == FS_DECRYPT)\n\t\tres = crypto_skcipher_decrypt(req);\n\telse\n\t\tres = crypto_skcipher_encrypt(req);\n\tif (res == -EINPROGRESS || res == -EBUSY) {\n\t\tBUG_ON(req->base.data != &ecr);\n\t\twait_for_completion(&ecr.completion);\n\t\tres = ecr.res;\n\t}\n\tskcipher_request_free(req);\n\tif (res) {\n\t\tprintk_ratelimited(KERN_ERR\n\t\t\t\"%s: crypto_skcipher_encrypt() returned %d\\n\",\n\t\t\t__func__, res);\n\t\treturn res;\n\t}\n\treturn 0;\n}\n\nstruct page *fscrypt_alloc_bounce_page(struct fscrypt_ctx *ctx,\n\t\t\t\t       gfp_t gfp_flags)\n{\n\tctx->w.bounce_page = mempool_alloc(fscrypt_bounce_page_pool, gfp_flags);\n\tif (ctx->w.bounce_page == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\tctx->flags |= FS_CTX_HAS_BOUNCE_BUFFER_FL;\n\treturn ctx->w.bounce_page;\n}\n\n/**\n * fscypt_encrypt_page() - Encrypts a page\n * @inode:     The inode for which the encryption should take place\n * @page:      The page to encrypt. Must be locked for bounce-page\n *             encryption.\n * @len:       Length of data to encrypt in @page and encrypted\n *             data in returned page.\n * @offs:      Offset of data within @page and returned\n *             page holding encrypted data.\n * @lblk_num:  Logical block number. This must be unique for multiple\n *             calls with same inode, except when overwriting\n *             previously written data.\n * @gfp_flags: The gfp flag for memory allocation\n *\n * Encrypts @page using the ctx encryption context. Performs encryption\n * either in-place or into a newly allocated bounce page.\n * Called on the page write path.\n *\n * Bounce page allocation is the default.\n * In this case, the contents of @page are encrypted and stored in an\n * allocated bounce page. @page has to be locked and the caller must call\n * fscrypt_restore_control_page() on the returned ciphertext page to\n * release the bounce buffer and the encryption context.\n *\n * In-place encryption is used by setting the FS_CFLG_OWN_PAGES flag in\n * fscrypt_operations. Here, the input-page is returned with its content\n * encrypted.\n *\n * Return: A page with the encrypted content on success. Else, an\n * error value or NULL.\n */\nstruct page *fscrypt_encrypt_page(const struct inode *inode,\n\t\t\t\tstruct page *page,\n\t\t\t\tunsigned int len,\n\t\t\t\tunsigned int offs,\n\t\t\t\tu64 lblk_num, gfp_t gfp_flags)\n\n{\n\tstruct fscrypt_ctx *ctx;\n\tstruct page *ciphertext_page = page;\n\tint err;\n\n\tBUG_ON(len % FS_CRYPTO_BLOCK_SIZE != 0);\n\n\tif (inode->i_sb->s_cop->flags & FS_CFLG_OWN_PAGES) {\n\t\t/* with inplace-encryption we just encrypt the page */\n\t\terr = fscrypt_do_page_crypto(inode, FS_ENCRYPT, lblk_num, page,\n\t\t\t\t\t     ciphertext_page, len, offs,\n\t\t\t\t\t     gfp_flags);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\n\t\treturn ciphertext_page;\n\t}\n\n\tBUG_ON(!PageLocked(page));\n\n\tctx = fscrypt_get_ctx(inode, gfp_flags);\n\tif (IS_ERR(ctx))\n\t\treturn (struct page *)ctx;\n\n\t/* The encryption operation will require a bounce page. */\n\tciphertext_page = fscrypt_alloc_bounce_page(ctx, gfp_flags);\n\tif (IS_ERR(ciphertext_page))\n\t\tgoto errout;\n\n\tctx->w.control_page = page;\n\terr = fscrypt_do_page_crypto(inode, FS_ENCRYPT, lblk_num,\n\t\t\t\t     page, ciphertext_page, len, offs,\n\t\t\t\t     gfp_flags);\n\tif (err) {\n\t\tciphertext_page = ERR_PTR(err);\n\t\tgoto errout;\n\t}\n\tSetPagePrivate(ciphertext_page);\n\tset_page_private(ciphertext_page, (unsigned long)ctx);\n\tlock_page(ciphertext_page);\n\treturn ciphertext_page;\n\nerrout:\n\tfscrypt_release_ctx(ctx);\n\treturn ciphertext_page;\n}\nEXPORT_SYMBOL(fscrypt_encrypt_page);\n\n/**\n * fscrypt_decrypt_page() - Decrypts a page in-place\n * @inode:     The corresponding inode for the page to decrypt.\n * @page:      The page to decrypt. Must be locked in case\n *             it is a writeback page (FS_CFLG_OWN_PAGES unset).\n * @len:       Number of bytes in @page to be decrypted.\n * @offs:      Start of data in @page.\n * @lblk_num:  Logical block number.\n *\n * Decrypts page in-place using the ctx encryption context.\n *\n * Called from the read completion callback.\n *\n * Return: Zero on success, non-zero otherwise.\n */\nint fscrypt_decrypt_page(const struct inode *inode, struct page *page,\n\t\t\tunsigned int len, unsigned int offs, u64 lblk_num)\n{\n\tif (!(inode->i_sb->s_cop->flags & FS_CFLG_OWN_PAGES))\n\t\tBUG_ON(!PageLocked(page));\n\n\treturn fscrypt_do_page_crypto(inode, FS_DECRYPT, lblk_num, page, page,\n\t\t\t\t      len, offs, GFP_NOFS);\n}\nEXPORT_SYMBOL(fscrypt_decrypt_page);\n\n/*\n * Validate dentries for encrypted directories to make sure we aren't\n * potentially caching stale data after a key has been added or\n * removed.\n */\nstatic int fscrypt_d_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tstruct dentry *dir;\n\tstruct fscrypt_info *ci;\n\tint dir_has_key, cached_with_key;\n\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\n\tdir = dget_parent(dentry);\n\tif (!d_inode(dir)->i_sb->s_cop->is_encrypted(d_inode(dir))) {\n\t\tdput(dir);\n\t\treturn 0;\n\t}\n\n\tci = d_inode(dir)->i_crypt_info;\n\tif (ci && ci->ci_keyring_key &&\n\t    (ci->ci_keyring_key->flags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t\t\t  (1 << KEY_FLAG_REVOKED) |\n\t\t\t\t\t  (1 << KEY_FLAG_DEAD))))\n\t\tci = NULL;\n\n\t/* this should eventually be an flag in d_flags */\n\tspin_lock(&dentry->d_lock);\n\tcached_with_key = dentry->d_flags & DCACHE_ENCRYPTED_WITH_KEY;\n\tspin_unlock(&dentry->d_lock);\n\tdir_has_key = (ci != NULL);\n\tdput(dir);\n\n\t/*\n\t * If the dentry was cached without the key, and it is a\n\t * negative dentry, it might be a valid name.  We can't check\n\t * if the key has since been made available due to locking\n\t * reasons, so we fail the validation so ext4_lookup() can do\n\t * this check.\n\t *\n\t * We also fail the validation if the dentry was created with\n\t * the key present, but we no longer have the key, or vice versa.\n\t */\n\tif ((!cached_with_key && d_is_negative(dentry)) ||\n\t\t\t(!cached_with_key && dir_has_key) ||\n\t\t\t(cached_with_key && !dir_has_key))\n\t\treturn 0;\n\treturn 1;\n}\n\nconst struct dentry_operations fscrypt_d_ops = {\n\t.d_revalidate = fscrypt_d_revalidate,\n};\nEXPORT_SYMBOL(fscrypt_d_ops);\n\nvoid fscrypt_restore_control_page(struct page *page)\n{\n\tstruct fscrypt_ctx *ctx;\n\n\tctx = (struct fscrypt_ctx *)page_private(page);\n\tset_page_private(page, (unsigned long)NULL);\n\tClearPagePrivate(page);\n\tunlock_page(page);\n\tfscrypt_release_ctx(ctx);\n}\nEXPORT_SYMBOL(fscrypt_restore_control_page);\n\nstatic void fscrypt_destroy(void)\n{\n\tstruct fscrypt_ctx *pos, *n;\n\n\tlist_for_each_entry_safe(pos, n, &fscrypt_free_ctxs, free_list)\n\t\tkmem_cache_free(fscrypt_ctx_cachep, pos);\n\tINIT_LIST_HEAD(&fscrypt_free_ctxs);\n\tmempool_destroy(fscrypt_bounce_page_pool);\n\tfscrypt_bounce_page_pool = NULL;\n}\n\n/**\n * fscrypt_initialize() - allocate major buffers for fs encryption.\n * @cop_flags:  fscrypt operations flags\n *\n * We only call this when we start accessing encrypted files, since it\n * results in memory getting allocated that wouldn't otherwise be used.\n *\n * Return: Zero on success, non-zero otherwise.\n */\nint fscrypt_initialize(unsigned int cop_flags)\n{\n\tint i, res = -ENOMEM;\n\n\t/*\n\t * No need to allocate a bounce page pool if there already is one or\n\t * this FS won't use it.\n\t */\n\tif (cop_flags & FS_CFLG_OWN_PAGES || fscrypt_bounce_page_pool)\n\t\treturn 0;\n\n\tmutex_lock(&fscrypt_init_mutex);\n\tif (fscrypt_bounce_page_pool)\n\t\tgoto already_initialized;\n\n\tfor (i = 0; i < num_prealloc_crypto_ctxs; i++) {\n\t\tstruct fscrypt_ctx *ctx;\n\n\t\tctx = kmem_cache_zalloc(fscrypt_ctx_cachep, GFP_NOFS);\n\t\tif (!ctx)\n\t\t\tgoto fail;\n\t\tlist_add(&ctx->free_list, &fscrypt_free_ctxs);\n\t}\n\n\tfscrypt_bounce_page_pool =\n\t\tmempool_create_page_pool(num_prealloc_crypto_pages, 0);\n\tif (!fscrypt_bounce_page_pool)\n\t\tgoto fail;\n\nalready_initialized:\n\tmutex_unlock(&fscrypt_init_mutex);\n\treturn 0;\nfail:\n\tfscrypt_destroy();\n\tmutex_unlock(&fscrypt_init_mutex);\n\treturn res;\n}\n\n/**\n * fscrypt_init() - Set up for fs encryption.\n */\nstatic int __init fscrypt_init(void)\n{\n\tfscrypt_read_workqueue = alloc_workqueue(\"fscrypt_read_queue\",\n\t\t\t\t\t\t\tWQ_HIGHPRI, 0);\n\tif (!fscrypt_read_workqueue)\n\t\tgoto fail;\n\n\tfscrypt_ctx_cachep = KMEM_CACHE(fscrypt_ctx, SLAB_RECLAIM_ACCOUNT);\n\tif (!fscrypt_ctx_cachep)\n\t\tgoto fail_free_queue;\n\n\tfscrypt_info_cachep = KMEM_CACHE(fscrypt_info, SLAB_RECLAIM_ACCOUNT);\n\tif (!fscrypt_info_cachep)\n\t\tgoto fail_free_ctx;\n\n\treturn 0;\n\nfail_free_ctx:\n\tkmem_cache_destroy(fscrypt_ctx_cachep);\nfail_free_queue:\n\tdestroy_workqueue(fscrypt_read_workqueue);\nfail:\n\treturn -ENOMEM;\n}\nmodule_init(fscrypt_init)\n\n/**\n * fscrypt_exit() - Shutdown the fs encryption system\n */\nstatic void __exit fscrypt_exit(void)\n{\n\tfscrypt_destroy();\n\n\tif (fscrypt_read_workqueue)\n\t\tdestroy_workqueue(fscrypt_read_workqueue);\n\tkmem_cache_destroy(fscrypt_ctx_cachep);\n\tkmem_cache_destroy(fscrypt_info_cachep);\n}\nmodule_exit(fscrypt_exit);\n\nMODULE_LICENSE(\"GPL\");\n", "/*\n * This contains functions for filename crypto management\n *\n * Copyright (C) 2015, Google, Inc.\n * Copyright (C) 2015, Motorola Mobility\n *\n * Written by Uday Savagaonkar, 2014.\n * Modified by Jaegeuk Kim, 2015.\n *\n * This has not yet undergone a rigorous security audit.\n */\n\n#include <linux/scatterlist.h>\n#include <linux/ratelimit.h>\n#include \"fscrypt_private.h\"\n\n/**\n * fname_crypt_complete() - completion callback for filename crypto\n * @req: The asynchronous cipher request context\n * @res: The result of the cipher operation\n */\nstatic void fname_crypt_complete(struct crypto_async_request *req, int res)\n{\n\tstruct fscrypt_completion_result *ecr = req->data;\n\n\tif (res == -EINPROGRESS)\n\t\treturn;\n\tecr->res = res;\n\tcomplete(&ecr->completion);\n}\n\n/**\n * fname_encrypt() - encrypt a filename\n *\n * The caller must have allocated sufficient memory for the @oname string.\n *\n * Return: 0 on success, -errno on failure\n */\nstatic int fname_encrypt(struct inode *inode,\n\t\t\tconst struct qstr *iname, struct fscrypt_str *oname)\n{\n\tstruct skcipher_request *req = NULL;\n\tDECLARE_FS_COMPLETION_RESULT(ecr);\n\tstruct fscrypt_info *ci = inode->i_crypt_info;\n\tstruct crypto_skcipher *tfm = ci->ci_ctfm;\n\tint res = 0;\n\tchar iv[FS_CRYPTO_BLOCK_SIZE];\n\tstruct scatterlist sg;\n\tint padding = 4 << (ci->ci_flags & FS_POLICY_FLAGS_PAD_MASK);\n\tunsigned int lim;\n\tunsigned int cryptlen;\n\n\tlim = inode->i_sb->s_cop->max_namelen(inode);\n\tif (iname->len <= 0 || iname->len > lim)\n\t\treturn -EIO;\n\n\t/*\n\t * Copy the filename to the output buffer for encrypting in-place and\n\t * pad it with the needed number of NUL bytes.\n\t */\n\tcryptlen = max_t(unsigned int, iname->len, FS_CRYPTO_BLOCK_SIZE);\n\tcryptlen = round_up(cryptlen, padding);\n\tcryptlen = min(cryptlen, lim);\n\tmemcpy(oname->name, iname->name, iname->len);\n\tmemset(oname->name + iname->len, 0, cryptlen - iname->len);\n\n\t/* Initialize the IV */\n\tmemset(iv, 0, FS_CRYPTO_BLOCK_SIZE);\n\n\t/* Set up the encryption request */\n\treq = skcipher_request_alloc(tfm, GFP_NOFS);\n\tif (!req) {\n\t\tprintk_ratelimited(KERN_ERR\n\t\t\t\"%s: skcipher_request_alloc() failed\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\tskcipher_request_set_callback(req,\n\t\t\tCRYPTO_TFM_REQ_MAY_BACKLOG | CRYPTO_TFM_REQ_MAY_SLEEP,\n\t\t\tfname_crypt_complete, &ecr);\n\tsg_init_one(&sg, oname->name, cryptlen);\n\tskcipher_request_set_crypt(req, &sg, &sg, cryptlen, iv);\n\n\t/* Do the encryption */\n\tres = crypto_skcipher_encrypt(req);\n\tif (res == -EINPROGRESS || res == -EBUSY) {\n\t\t/* Request is being completed asynchronously; wait for it */\n\t\twait_for_completion(&ecr.completion);\n\t\tres = ecr.res;\n\t}\n\tskcipher_request_free(req);\n\tif (res < 0) {\n\t\tprintk_ratelimited(KERN_ERR\n\t\t\t\t\"%s: Error (error code %d)\\n\", __func__, res);\n\t\treturn res;\n\t}\n\n\toname->len = cryptlen;\n\treturn 0;\n}\n\n/**\n * fname_decrypt() - decrypt a filename\n *\n * The caller must have allocated sufficient memory for the @oname string.\n *\n * Return: 0 on success, -errno on failure\n */\nstatic int fname_decrypt(struct inode *inode,\n\t\t\t\tconst struct fscrypt_str *iname,\n\t\t\t\tstruct fscrypt_str *oname)\n{\n\tstruct skcipher_request *req = NULL;\n\tDECLARE_FS_COMPLETION_RESULT(ecr);\n\tstruct scatterlist src_sg, dst_sg;\n\tstruct fscrypt_info *ci = inode->i_crypt_info;\n\tstruct crypto_skcipher *tfm = ci->ci_ctfm;\n\tint res = 0;\n\tchar iv[FS_CRYPTO_BLOCK_SIZE];\n\tunsigned lim;\n\n\tlim = inode->i_sb->s_cop->max_namelen(inode);\n\tif (iname->len <= 0 || iname->len > lim)\n\t\treturn -EIO;\n\n\t/* Allocate request */\n\treq = skcipher_request_alloc(tfm, GFP_NOFS);\n\tif (!req) {\n\t\tprintk_ratelimited(KERN_ERR\n\t\t\t\"%s: crypto_request_alloc() failed\\n\",  __func__);\n\t\treturn -ENOMEM;\n\t}\n\tskcipher_request_set_callback(req,\n\t\tCRYPTO_TFM_REQ_MAY_BACKLOG | CRYPTO_TFM_REQ_MAY_SLEEP,\n\t\tfname_crypt_complete, &ecr);\n\n\t/* Initialize IV */\n\tmemset(iv, 0, FS_CRYPTO_BLOCK_SIZE);\n\n\t/* Create decryption request */\n\tsg_init_one(&src_sg, iname->name, iname->len);\n\tsg_init_one(&dst_sg, oname->name, oname->len);\n\tskcipher_request_set_crypt(req, &src_sg, &dst_sg, iname->len, iv);\n\tres = crypto_skcipher_decrypt(req);\n\tif (res == -EINPROGRESS || res == -EBUSY) {\n\t\twait_for_completion(&ecr.completion);\n\t\tres = ecr.res;\n\t}\n\tskcipher_request_free(req);\n\tif (res < 0) {\n\t\tprintk_ratelimited(KERN_ERR\n\t\t\t\t\"%s: Error (error code %d)\\n\", __func__, res);\n\t\treturn res;\n\t}\n\n\toname->len = strnlen(oname->name, iname->len);\n\treturn 0;\n}\n\nstatic const char *lookup_table =\n\t\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+,\";\n\n/**\n * digest_encode() -\n *\n * Encodes the input digest using characters from the set [a-zA-Z0-9_+].\n * The encoded string is roughly 4/3 times the size of the input string.\n */\nstatic int digest_encode(const char *src, int len, char *dst)\n{\n\tint i = 0, bits = 0, ac = 0;\n\tchar *cp = dst;\n\n\twhile (i < len) {\n\t\tac += (((unsigned char) src[i]) << bits);\n\t\tbits += 8;\n\t\tdo {\n\t\t\t*cp++ = lookup_table[ac & 0x3f];\n\t\t\tac >>= 6;\n\t\t\tbits -= 6;\n\t\t} while (bits >= 6);\n\t\ti++;\n\t}\n\tif (bits)\n\t\t*cp++ = lookup_table[ac & 0x3f];\n\treturn cp - dst;\n}\n\nstatic int digest_decode(const char *src, int len, char *dst)\n{\n\tint i = 0, bits = 0, ac = 0;\n\tconst char *p;\n\tchar *cp = dst;\n\n\twhile (i < len) {\n\t\tp = strchr(lookup_table, src[i]);\n\t\tif (p == NULL || src[i] == 0)\n\t\t\treturn -2;\n\t\tac += (p - lookup_table) << bits;\n\t\tbits += 6;\n\t\tif (bits >= 8) {\n\t\t\t*cp++ = ac & 0xff;\n\t\t\tac >>= 8;\n\t\t\tbits -= 8;\n\t\t}\n\t\ti++;\n\t}\n\tif (ac)\n\t\treturn -1;\n\treturn cp - dst;\n}\n\nu32 fscrypt_fname_encrypted_size(const struct inode *inode, u32 ilen)\n{\n\tint padding = 32;\n\tstruct fscrypt_info *ci = inode->i_crypt_info;\n\n\tif (ci)\n\t\tpadding = 4 << (ci->ci_flags & FS_POLICY_FLAGS_PAD_MASK);\n\tilen = max(ilen, (u32)FS_CRYPTO_BLOCK_SIZE);\n\treturn round_up(ilen, padding);\n}\nEXPORT_SYMBOL(fscrypt_fname_encrypted_size);\n\n/**\n * fscrypt_fname_crypto_alloc_obuff() -\n *\n * Allocates an output buffer that is sufficient for the crypto operation\n * specified by the context and the direction.\n */\nint fscrypt_fname_alloc_buffer(const struct inode *inode,\n\t\t\t\tu32 ilen, struct fscrypt_str *crypto_str)\n{\n\tunsigned int olen = fscrypt_fname_encrypted_size(inode, ilen);\n\n\tcrypto_str->len = olen;\n\tif (olen < FS_FNAME_CRYPTO_DIGEST_SIZE * 2)\n\t\tolen = FS_FNAME_CRYPTO_DIGEST_SIZE * 2;\n\t/*\n\t * Allocated buffer can hold one more character to null-terminate the\n\t * string\n\t */\n\tcrypto_str->name = kmalloc(olen + 1, GFP_NOFS);\n\tif (!(crypto_str->name))\n\t\treturn -ENOMEM;\n\treturn 0;\n}\nEXPORT_SYMBOL(fscrypt_fname_alloc_buffer);\n\n/**\n * fscrypt_fname_crypto_free_buffer() -\n *\n * Frees the buffer allocated for crypto operation.\n */\nvoid fscrypt_fname_free_buffer(struct fscrypt_str *crypto_str)\n{\n\tif (!crypto_str)\n\t\treturn;\n\tkfree(crypto_str->name);\n\tcrypto_str->name = NULL;\n}\nEXPORT_SYMBOL(fscrypt_fname_free_buffer);\n\n/**\n * fscrypt_fname_disk_to_usr() - converts a filename from disk space to user\n * space\n *\n * The caller must have allocated sufficient memory for the @oname string.\n *\n * Return: 0 on success, -errno on failure\n */\nint fscrypt_fname_disk_to_usr(struct inode *inode,\n\t\t\tu32 hash, u32 minor_hash,\n\t\t\tconst struct fscrypt_str *iname,\n\t\t\tstruct fscrypt_str *oname)\n{\n\tconst struct qstr qname = FSTR_TO_QSTR(iname);\n\tchar buf[24];\n\n\tif (fscrypt_is_dot_dotdot(&qname)) {\n\t\toname->name[0] = '.';\n\t\toname->name[iname->len - 1] = '.';\n\t\toname->len = iname->len;\n\t\treturn 0;\n\t}\n\n\tif (iname->len < FS_CRYPTO_BLOCK_SIZE)\n\t\treturn -EUCLEAN;\n\n\tif (inode->i_crypt_info)\n\t\treturn fname_decrypt(inode, iname, oname);\n\n\tif (iname->len <= FS_FNAME_CRYPTO_DIGEST_SIZE) {\n\t\toname->len = digest_encode(iname->name, iname->len,\n\t\t\t\t\t   oname->name);\n\t\treturn 0;\n\t}\n\tif (hash) {\n\t\tmemcpy(buf, &hash, 4);\n\t\tmemcpy(buf + 4, &minor_hash, 4);\n\t} else {\n\t\tmemset(buf, 0, 8);\n\t}\n\tmemcpy(buf + 8, iname->name + iname->len - 16, 16);\n\toname->name[0] = '_';\n\toname->len = 1 + digest_encode(buf, 24, oname->name + 1);\n\treturn 0;\n}\nEXPORT_SYMBOL(fscrypt_fname_disk_to_usr);\n\n/**\n * fscrypt_fname_usr_to_disk() - converts a filename from user space to disk\n * space\n *\n * The caller must have allocated sufficient memory for the @oname string.\n *\n * Return: 0 on success, -errno on failure\n */\nint fscrypt_fname_usr_to_disk(struct inode *inode,\n\t\t\tconst struct qstr *iname,\n\t\t\tstruct fscrypt_str *oname)\n{\n\tif (fscrypt_is_dot_dotdot(iname)) {\n\t\toname->name[0] = '.';\n\t\toname->name[iname->len - 1] = '.';\n\t\toname->len = iname->len;\n\t\treturn 0;\n\t}\n\tif (inode->i_crypt_info)\n\t\treturn fname_encrypt(inode, iname, oname);\n\t/*\n\t * Without a proper key, a user is not allowed to modify the filenames\n\t * in a directory. Consequently, a user space name cannot be mapped to\n\t * a disk-space name\n\t */\n\treturn -ENOKEY;\n}\nEXPORT_SYMBOL(fscrypt_fname_usr_to_disk);\n\nint fscrypt_setup_filename(struct inode *dir, const struct qstr *iname,\n\t\t\t      int lookup, struct fscrypt_name *fname)\n{\n\tint ret = 0, bigname = 0;\n\n\tmemset(fname, 0, sizeof(struct fscrypt_name));\n\tfname->usr_fname = iname;\n\n\tif (!dir->i_sb->s_cop->is_encrypted(dir) ||\n\t\t\t\tfscrypt_is_dot_dotdot(iname)) {\n\t\tfname->disk_name.name = (unsigned char *)iname->name;\n\t\tfname->disk_name.len = iname->len;\n\t\treturn 0;\n\t}\n\tret = fscrypt_get_crypt_info(dir);\n\tif (ret && ret != -EOPNOTSUPP)\n\t\treturn ret;\n\n\tif (dir->i_crypt_info) {\n\t\tret = fscrypt_fname_alloc_buffer(dir, iname->len,\n\t\t\t\t\t\t\t&fname->crypto_buf);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = fname_encrypt(dir, iname, &fname->crypto_buf);\n\t\tif (ret)\n\t\t\tgoto errout;\n\t\tfname->disk_name.name = fname->crypto_buf.name;\n\t\tfname->disk_name.len = fname->crypto_buf.len;\n\t\treturn 0;\n\t}\n\tif (!lookup)\n\t\treturn -ENOKEY;\n\n\t/*\n\t * We don't have the key and we are doing a lookup; decode the\n\t * user-supplied name\n\t */\n\tif (iname->name[0] == '_')\n\t\tbigname = 1;\n\tif ((bigname && (iname->len != 33)) || (!bigname && (iname->len > 43)))\n\t\treturn -ENOENT;\n\n\tfname->crypto_buf.name = kmalloc(32, GFP_KERNEL);\n\tif (fname->crypto_buf.name == NULL)\n\t\treturn -ENOMEM;\n\n\tret = digest_decode(iname->name + bigname, iname->len - bigname,\n\t\t\t\tfname->crypto_buf.name);\n\tif (ret < 0) {\n\t\tret = -ENOENT;\n\t\tgoto errout;\n\t}\n\tfname->crypto_buf.len = ret;\n\tif (bigname) {\n\t\tmemcpy(&fname->hash, fname->crypto_buf.name, 4);\n\t\tmemcpy(&fname->minor_hash, fname->crypto_buf.name + 4, 4);\n\t} else {\n\t\tfname->disk_name.name = fname->crypto_buf.name;\n\t\tfname->disk_name.len = fname->crypto_buf.len;\n\t}\n\treturn 0;\n\nerrout:\n\tfscrypt_fname_free_buffer(&fname->crypto_buf);\n\treturn ret;\n}\nEXPORT_SYMBOL(fscrypt_setup_filename);\n\nvoid fscrypt_free_filename(struct fscrypt_name *fname)\n{\n\tkfree(fname->crypto_buf.name);\n\tfname->crypto_buf.name = NULL;\n\tfname->usr_fname = NULL;\n\tfname->disk_name.name = NULL;\n}\nEXPORT_SYMBOL(fscrypt_free_filename);\n", "/*\n * fscrypt_private.h\n *\n * Copyright (C) 2015, Google, Inc.\n *\n * This contains encryption key functions.\n *\n * Written by Michael Halcrow, Ildar Muslukhov, and Uday Savagaonkar, 2015.\n */\n\n#ifndef _FSCRYPT_PRIVATE_H\n#define _FSCRYPT_PRIVATE_H\n\n#include <linux/fscrypt_supp.h>\n\n#define FS_FNAME_CRYPTO_DIGEST_SIZE\t32\n\n/* Encryption parameters */\n#define FS_XTS_TWEAK_SIZE\t\t16\n#define FS_AES_128_ECB_KEY_SIZE\t\t16\n#define FS_AES_256_GCM_KEY_SIZE\t\t32\n#define FS_AES_256_CBC_KEY_SIZE\t\t32\n#define FS_AES_256_CTS_KEY_SIZE\t\t32\n#define FS_AES_256_XTS_KEY_SIZE\t\t64\n#define FS_MAX_KEY_SIZE\t\t\t64\n\n#define FS_KEY_DESC_PREFIX\t\t\"fscrypt:\"\n#define FS_KEY_DESC_PREFIX_SIZE\t\t8\n\n#define FS_KEY_DERIVATION_NONCE_SIZE\t\t16\n\n/**\n * Encryption context for inode\n *\n * Protector format:\n *  1 byte: Protector format (1 = this version)\n *  1 byte: File contents encryption mode\n *  1 byte: File names encryption mode\n *  1 byte: Flags\n *  8 bytes: Master Key descriptor\n *  16 bytes: Encryption Key derivation nonce\n */\nstruct fscrypt_context {\n\tu8 format;\n\tu8 contents_encryption_mode;\n\tu8 filenames_encryption_mode;\n\tu8 flags;\n\tu8 master_key_descriptor[FS_KEY_DESCRIPTOR_SIZE];\n\tu8 nonce[FS_KEY_DERIVATION_NONCE_SIZE];\n} __packed;\n\n#define FS_ENCRYPTION_CONTEXT_FORMAT_V1\t\t1\n\n/* This is passed in from userspace into the kernel keyring */\nstruct fscrypt_key {\n\tu32 mode;\n\tu8 raw[FS_MAX_KEY_SIZE];\n\tu32 size;\n} __packed;\n\n/*\n * A pointer to this structure is stored in the file system's in-core\n * representation of an inode.\n */\nstruct fscrypt_info {\n\tu8 ci_data_mode;\n\tu8 ci_filename_mode;\n\tu8 ci_flags;\n\tstruct crypto_skcipher *ci_ctfm;\n\tstruct key *ci_keyring_key;\n\tu8 ci_master_key[FS_KEY_DESCRIPTOR_SIZE];\n};\n\ntypedef enum {\n\tFS_DECRYPT = 0,\n\tFS_ENCRYPT,\n} fscrypt_direction_t;\n\n#define FS_CTX_REQUIRES_FREE_ENCRYPT_FL\t\t0x00000001\n#define FS_CTX_HAS_BOUNCE_BUFFER_FL\t\t0x00000002\n\nstruct fscrypt_completion_result {\n\tstruct completion completion;\n\tint res;\n};\n\n#define DECLARE_FS_COMPLETION_RESULT(ecr) \\\n\tstruct fscrypt_completion_result ecr = { \\\n\t\tCOMPLETION_INITIALIZER_ONSTACK((ecr).completion), 0 }\n\n\n/* crypto.c */\nextern int fscrypt_initialize(unsigned int cop_flags);\nextern struct workqueue_struct *fscrypt_read_workqueue;\nextern int fscrypt_do_page_crypto(const struct inode *inode,\n\t\t\t\t  fscrypt_direction_t rw, u64 lblk_num,\n\t\t\t\t  struct page *src_page,\n\t\t\t\t  struct page *dest_page,\n\t\t\t\t  unsigned int len, unsigned int offs,\n\t\t\t\t  gfp_t gfp_flags);\nextern struct page *fscrypt_alloc_bounce_page(struct fscrypt_ctx *ctx,\n\t\t\t\t\t      gfp_t gfp_flags);\n\n/* keyinfo.c */\nextern int fscrypt_get_crypt_info(struct inode *);\n\n#endif /* _FSCRYPT_PRIVATE_H */\n", "/*\n * key management facility for FS encryption support.\n *\n * Copyright (C) 2015, Google, Inc.\n *\n * This contains encryption key functions.\n *\n * Written by Michael Halcrow, Ildar Muslukhov, and Uday Savagaonkar, 2015.\n */\n\n#include <keys/user-type.h>\n#include <linux/scatterlist.h>\n#include \"fscrypt_private.h\"\n\nstatic void derive_crypt_complete(struct crypto_async_request *req, int rc)\n{\n\tstruct fscrypt_completion_result *ecr = req->data;\n\n\tif (rc == -EINPROGRESS)\n\t\treturn;\n\n\tecr->res = rc;\n\tcomplete(&ecr->completion);\n}\n\n/**\n * derive_key_aes() - Derive a key using AES-128-ECB\n * @deriving_key: Encryption key used for derivation.\n * @source_key:   Source key to which to apply derivation.\n * @derived_key:  Derived key.\n *\n * Return: Zero on success; non-zero otherwise.\n */\nstatic int derive_key_aes(u8 deriving_key[FS_AES_128_ECB_KEY_SIZE],\n\t\t\t\tu8 source_key[FS_AES_256_XTS_KEY_SIZE],\n\t\t\t\tu8 derived_key[FS_AES_256_XTS_KEY_SIZE])\n{\n\tint res = 0;\n\tstruct skcipher_request *req = NULL;\n\tDECLARE_FS_COMPLETION_RESULT(ecr);\n\tstruct scatterlist src_sg, dst_sg;\n\tstruct crypto_skcipher *tfm = crypto_alloc_skcipher(\"ecb(aes)\", 0, 0);\n\n\tif (IS_ERR(tfm)) {\n\t\tres = PTR_ERR(tfm);\n\t\ttfm = NULL;\n\t\tgoto out;\n\t}\n\tcrypto_skcipher_set_flags(tfm, CRYPTO_TFM_REQ_WEAK_KEY);\n\treq = skcipher_request_alloc(tfm, GFP_NOFS);\n\tif (!req) {\n\t\tres = -ENOMEM;\n\t\tgoto out;\n\t}\n\tskcipher_request_set_callback(req,\n\t\t\tCRYPTO_TFM_REQ_MAY_BACKLOG | CRYPTO_TFM_REQ_MAY_SLEEP,\n\t\t\tderive_crypt_complete, &ecr);\n\tres = crypto_skcipher_setkey(tfm, deriving_key,\n\t\t\t\t\tFS_AES_128_ECB_KEY_SIZE);\n\tif (res < 0)\n\t\tgoto out;\n\n\tsg_init_one(&src_sg, source_key, FS_AES_256_XTS_KEY_SIZE);\n\tsg_init_one(&dst_sg, derived_key, FS_AES_256_XTS_KEY_SIZE);\n\tskcipher_request_set_crypt(req, &src_sg, &dst_sg,\n\t\t\t\t\tFS_AES_256_XTS_KEY_SIZE, NULL);\n\tres = crypto_skcipher_encrypt(req);\n\tif (res == -EINPROGRESS || res == -EBUSY) {\n\t\twait_for_completion(&ecr.completion);\n\t\tres = ecr.res;\n\t}\nout:\n\tskcipher_request_free(req);\n\tcrypto_free_skcipher(tfm);\n\treturn res;\n}\n\nstatic int validate_user_key(struct fscrypt_info *crypt_info,\n\t\t\tstruct fscrypt_context *ctx, u8 *raw_key,\n\t\t\tconst char *prefix)\n{\n\tchar *description;\n\tstruct key *keyring_key;\n\tstruct fscrypt_key *master_key;\n\tconst struct user_key_payload *ukp;\n\tint res;\n\n\tdescription = kasprintf(GFP_NOFS, \"%s%*phN\", prefix,\n\t\t\t\tFS_KEY_DESCRIPTOR_SIZE,\n\t\t\t\tctx->master_key_descriptor);\n\tif (!description)\n\t\treturn -ENOMEM;\n\n\tkeyring_key = request_key(&key_type_logon, description, NULL);\n\tkfree(description);\n\tif (IS_ERR(keyring_key))\n\t\treturn PTR_ERR(keyring_key);\n\n\tif (keyring_key->type != &key_type_logon) {\n\t\tprintk_once(KERN_WARNING\n\t\t\t\t\"%s: key type must be logon\\n\", __func__);\n\t\tres = -ENOKEY;\n\t\tgoto out;\n\t}\n\tdown_read(&keyring_key->sem);\n\tukp = user_key_payload(keyring_key);\n\tif (ukp->datalen != sizeof(struct fscrypt_key)) {\n\t\tres = -EINVAL;\n\t\tup_read(&keyring_key->sem);\n\t\tgoto out;\n\t}\n\tmaster_key = (struct fscrypt_key *)ukp->data;\n\tBUILD_BUG_ON(FS_AES_128_ECB_KEY_SIZE != FS_KEY_DERIVATION_NONCE_SIZE);\n\n\tif (master_key->size != FS_AES_256_XTS_KEY_SIZE) {\n\t\tprintk_once(KERN_WARNING\n\t\t\t\t\"%s: key size incorrect: %d\\n\",\n\t\t\t\t__func__, master_key->size);\n\t\tres = -ENOKEY;\n\t\tup_read(&keyring_key->sem);\n\t\tgoto out;\n\t}\n\tres = derive_key_aes(ctx->nonce, master_key->raw, raw_key);\n\tup_read(&keyring_key->sem);\n\tif (res)\n\t\tgoto out;\n\n\tcrypt_info->ci_keyring_key = keyring_key;\n\treturn 0;\nout:\n\tkey_put(keyring_key);\n\treturn res;\n}\n\nstatic int determine_cipher_type(struct fscrypt_info *ci, struct inode *inode,\n\t\t\t\t const char **cipher_str_ret, int *keysize_ret)\n{\n\tif (S_ISREG(inode->i_mode)) {\n\t\tif (ci->ci_data_mode == FS_ENCRYPTION_MODE_AES_256_XTS) {\n\t\t\t*cipher_str_ret = \"xts(aes)\";\n\t\t\t*keysize_ret = FS_AES_256_XTS_KEY_SIZE;\n\t\t\treturn 0;\n\t\t}\n\t\tpr_warn_once(\"fscrypto: unsupported contents encryption mode \"\n\t\t\t     \"%d for inode %lu\\n\",\n\t\t\t     ci->ci_data_mode, inode->i_ino);\n\t\treturn -ENOKEY;\n\t}\n\n\tif (S_ISDIR(inode->i_mode) || S_ISLNK(inode->i_mode)) {\n\t\tif (ci->ci_filename_mode == FS_ENCRYPTION_MODE_AES_256_CTS) {\n\t\t\t*cipher_str_ret = \"cts(cbc(aes))\";\n\t\t\t*keysize_ret = FS_AES_256_CTS_KEY_SIZE;\n\t\t\treturn 0;\n\t\t}\n\t\tpr_warn_once(\"fscrypto: unsupported filenames encryption mode \"\n\t\t\t     \"%d for inode %lu\\n\",\n\t\t\t     ci->ci_filename_mode, inode->i_ino);\n\t\treturn -ENOKEY;\n\t}\n\n\tpr_warn_once(\"fscrypto: unsupported file type %d for inode %lu\\n\",\n\t\t     (inode->i_mode & S_IFMT), inode->i_ino);\n\treturn -ENOKEY;\n}\n\nstatic void put_crypt_info(struct fscrypt_info *ci)\n{\n\tif (!ci)\n\t\treturn;\n\n\tkey_put(ci->ci_keyring_key);\n\tcrypto_free_skcipher(ci->ci_ctfm);\n\tkmem_cache_free(fscrypt_info_cachep, ci);\n}\n\nint fscrypt_get_crypt_info(struct inode *inode)\n{\n\tstruct fscrypt_info *crypt_info;\n\tstruct fscrypt_context ctx;\n\tstruct crypto_skcipher *ctfm;\n\tconst char *cipher_str;\n\tint keysize;\n\tu8 *raw_key = NULL;\n\tint res;\n\n\tres = fscrypt_initialize(inode->i_sb->s_cop->flags);\n\tif (res)\n\t\treturn res;\n\n\tif (!inode->i_sb->s_cop->get_context)\n\t\treturn -EOPNOTSUPP;\nretry:\n\tcrypt_info = ACCESS_ONCE(inode->i_crypt_info);\n\tif (crypt_info) {\n\t\tif (!crypt_info->ci_keyring_key ||\n\t\t\t\tkey_validate(crypt_info->ci_keyring_key) == 0)\n\t\t\treturn 0;\n\t\tfscrypt_put_encryption_info(inode, crypt_info);\n\t\tgoto retry;\n\t}\n\n\tres = inode->i_sb->s_cop->get_context(inode, &ctx, sizeof(ctx));\n\tif (res < 0) {\n\t\tif (!fscrypt_dummy_context_enabled(inode) ||\n\t\t    inode->i_sb->s_cop->is_encrypted(inode))\n\t\t\treturn res;\n\t\t/* Fake up a context for an unencrypted directory */\n\t\tmemset(&ctx, 0, sizeof(ctx));\n\t\tctx.format = FS_ENCRYPTION_CONTEXT_FORMAT_V1;\n\t\tctx.contents_encryption_mode = FS_ENCRYPTION_MODE_AES_256_XTS;\n\t\tctx.filenames_encryption_mode = FS_ENCRYPTION_MODE_AES_256_CTS;\n\t\tmemset(ctx.master_key_descriptor, 0x42, FS_KEY_DESCRIPTOR_SIZE);\n\t} else if (res != sizeof(ctx)) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (ctx.format != FS_ENCRYPTION_CONTEXT_FORMAT_V1)\n\t\treturn -EINVAL;\n\n\tif (ctx.flags & ~FS_POLICY_FLAGS_VALID)\n\t\treturn -EINVAL;\n\n\tcrypt_info = kmem_cache_alloc(fscrypt_info_cachep, GFP_NOFS);\n\tif (!crypt_info)\n\t\treturn -ENOMEM;\n\n\tcrypt_info->ci_flags = ctx.flags;\n\tcrypt_info->ci_data_mode = ctx.contents_encryption_mode;\n\tcrypt_info->ci_filename_mode = ctx.filenames_encryption_mode;\n\tcrypt_info->ci_ctfm = NULL;\n\tcrypt_info->ci_keyring_key = NULL;\n\tmemcpy(crypt_info->ci_master_key, ctx.master_key_descriptor,\n\t\t\t\tsizeof(crypt_info->ci_master_key));\n\n\tres = determine_cipher_type(crypt_info, inode, &cipher_str, &keysize);\n\tif (res)\n\t\tgoto out;\n\n\t/*\n\t * This cannot be a stack buffer because it is passed to the scatterlist\n\t * crypto API as part of key derivation.\n\t */\n\tres = -ENOMEM;\n\traw_key = kmalloc(FS_MAX_KEY_SIZE, GFP_NOFS);\n\tif (!raw_key)\n\t\tgoto out;\n\n\tres = validate_user_key(crypt_info, &ctx, raw_key, FS_KEY_DESC_PREFIX);\n\tif (res && inode->i_sb->s_cop->key_prefix) {\n\t\tint res2 = validate_user_key(crypt_info, &ctx, raw_key,\n\t\t\t\t\t     inode->i_sb->s_cop->key_prefix);\n\t\tif (res2) {\n\t\t\tif (res2 == -ENOKEY)\n\t\t\t\tres = -ENOKEY;\n\t\t\tgoto out;\n\t\t}\n\t} else if (res) {\n\t\tgoto out;\n\t}\n\tctfm = crypto_alloc_skcipher(cipher_str, 0, 0);\n\tif (!ctfm || IS_ERR(ctfm)) {\n\t\tres = ctfm ? PTR_ERR(ctfm) : -ENOMEM;\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s: error %d (inode %u) allocating crypto tfm\\n\",\n\t\t       __func__, res, (unsigned) inode->i_ino);\n\t\tgoto out;\n\t}\n\tcrypt_info->ci_ctfm = ctfm;\n\tcrypto_skcipher_clear_flags(ctfm, ~0);\n\tcrypto_skcipher_set_flags(ctfm, CRYPTO_TFM_REQ_WEAK_KEY);\n\tres = crypto_skcipher_setkey(ctfm, raw_key, keysize);\n\tif (res)\n\t\tgoto out;\n\n\tkzfree(raw_key);\n\traw_key = NULL;\n\tif (cmpxchg(&inode->i_crypt_info, NULL, crypt_info) != NULL) {\n\t\tput_crypt_info(crypt_info);\n\t\tgoto retry;\n\t}\n\treturn 0;\n\nout:\n\tif (res == -ENOKEY)\n\t\tres = 0;\n\tput_crypt_info(crypt_info);\n\tkzfree(raw_key);\n\treturn res;\n}\n\nvoid fscrypt_put_encryption_info(struct inode *inode, struct fscrypt_info *ci)\n{\n\tstruct fscrypt_info *prev;\n\n\tif (ci == NULL)\n\t\tci = ACCESS_ONCE(inode->i_crypt_info);\n\tif (ci == NULL)\n\t\treturn;\n\n\tprev = cmpxchg(&inode->i_crypt_info, ci, NULL);\n\tif (prev != ci)\n\t\treturn;\n\n\tput_crypt_info(ci);\n}\nEXPORT_SYMBOL(fscrypt_put_encryption_info);\n\nint fscrypt_get_encryption_info(struct inode *inode)\n{\n\tstruct fscrypt_info *ci = inode->i_crypt_info;\n\n\tif (!ci ||\n\t\t(ci->ci_keyring_key &&\n\t\t (ci->ci_keyring_key->flags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t\t\t       (1 << KEY_FLAG_REVOKED) |\n\t\t\t\t\t       (1 << KEY_FLAG_DEAD)))))\n\t\treturn fscrypt_get_crypt_info(inode);\n\treturn 0;\n}\nEXPORT_SYMBOL(fscrypt_get_encryption_info);\n"], "fixing_code": ["/*\n * This contains encryption functions for per-file encryption.\n *\n * Copyright (C) 2015, Google, Inc.\n * Copyright (C) 2015, Motorola Mobility\n *\n * Written by Michael Halcrow, 2014.\n *\n * Filename encryption additions\n *\tUday Savagaonkar, 2014\n * Encryption policy handling additions\n *\tIldar Muslukhov, 2014\n * Add fscrypt_pullback_bio_page()\n *\tJaegeuk Kim, 2015.\n *\n * This has not yet undergone a rigorous security audit.\n *\n * The usage of AES-XTS should conform to recommendations in NIST\n * Special Publication 800-38E and IEEE P1619/D16.\n */\n\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/module.h>\n#include <linux/scatterlist.h>\n#include <linux/ratelimit.h>\n#include <linux/dcache.h>\n#include <linux/namei.h>\n#include \"fscrypt_private.h\"\n\nstatic unsigned int num_prealloc_crypto_pages = 32;\nstatic unsigned int num_prealloc_crypto_ctxs = 128;\n\nmodule_param(num_prealloc_crypto_pages, uint, 0444);\nMODULE_PARM_DESC(num_prealloc_crypto_pages,\n\t\t\"Number of crypto pages to preallocate\");\nmodule_param(num_prealloc_crypto_ctxs, uint, 0444);\nMODULE_PARM_DESC(num_prealloc_crypto_ctxs,\n\t\t\"Number of crypto contexts to preallocate\");\n\nstatic mempool_t *fscrypt_bounce_page_pool = NULL;\n\nstatic LIST_HEAD(fscrypt_free_ctxs);\nstatic DEFINE_SPINLOCK(fscrypt_ctx_lock);\n\nstruct workqueue_struct *fscrypt_read_workqueue;\nstatic DEFINE_MUTEX(fscrypt_init_mutex);\n\nstatic struct kmem_cache *fscrypt_ctx_cachep;\nstruct kmem_cache *fscrypt_info_cachep;\n\n/**\n * fscrypt_release_ctx() - Releases an encryption context\n * @ctx: The encryption context to release.\n *\n * If the encryption context was allocated from the pre-allocated pool, returns\n * it to that pool. Else, frees it.\n *\n * If there's a bounce page in the context, this frees that.\n */\nvoid fscrypt_release_ctx(struct fscrypt_ctx *ctx)\n{\n\tunsigned long flags;\n\n\tif (ctx->flags & FS_CTX_HAS_BOUNCE_BUFFER_FL && ctx->w.bounce_page) {\n\t\tmempool_free(ctx->w.bounce_page, fscrypt_bounce_page_pool);\n\t\tctx->w.bounce_page = NULL;\n\t}\n\tctx->w.control_page = NULL;\n\tif (ctx->flags & FS_CTX_REQUIRES_FREE_ENCRYPT_FL) {\n\t\tkmem_cache_free(fscrypt_ctx_cachep, ctx);\n\t} else {\n\t\tspin_lock_irqsave(&fscrypt_ctx_lock, flags);\n\t\tlist_add(&ctx->free_list, &fscrypt_free_ctxs);\n\t\tspin_unlock_irqrestore(&fscrypt_ctx_lock, flags);\n\t}\n}\nEXPORT_SYMBOL(fscrypt_release_ctx);\n\n/**\n * fscrypt_get_ctx() - Gets an encryption context\n * @inode:       The inode for which we are doing the crypto\n * @gfp_flags:   The gfp flag for memory allocation\n *\n * Allocates and initializes an encryption context.\n *\n * Return: An allocated and initialized encryption context on success; error\n * value or NULL otherwise.\n */\nstruct fscrypt_ctx *fscrypt_get_ctx(const struct inode *inode, gfp_t gfp_flags)\n{\n\tstruct fscrypt_ctx *ctx = NULL;\n\tstruct fscrypt_info *ci = inode->i_crypt_info;\n\tunsigned long flags;\n\n\tif (ci == NULL)\n\t\treturn ERR_PTR(-ENOKEY);\n\n\t/*\n\t * We first try getting the ctx from a free list because in\n\t * the common case the ctx will have an allocated and\n\t * initialized crypto tfm, so it's probably a worthwhile\n\t * optimization. For the bounce page, we first try getting it\n\t * from the kernel allocator because that's just about as fast\n\t * as getting it from a list and because a cache of free pages\n\t * should generally be a \"last resort\" option for a filesystem\n\t * to be able to do its job.\n\t */\n\tspin_lock_irqsave(&fscrypt_ctx_lock, flags);\n\tctx = list_first_entry_or_null(&fscrypt_free_ctxs,\n\t\t\t\t\tstruct fscrypt_ctx, free_list);\n\tif (ctx)\n\t\tlist_del(&ctx->free_list);\n\tspin_unlock_irqrestore(&fscrypt_ctx_lock, flags);\n\tif (!ctx) {\n\t\tctx = kmem_cache_zalloc(fscrypt_ctx_cachep, gfp_flags);\n\t\tif (!ctx)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tctx->flags |= FS_CTX_REQUIRES_FREE_ENCRYPT_FL;\n\t} else {\n\t\tctx->flags &= ~FS_CTX_REQUIRES_FREE_ENCRYPT_FL;\n\t}\n\tctx->flags &= ~FS_CTX_HAS_BOUNCE_BUFFER_FL;\n\treturn ctx;\n}\nEXPORT_SYMBOL(fscrypt_get_ctx);\n\n/**\n * page_crypt_complete() - completion callback for page crypto\n * @req: The asynchronous cipher request context\n * @res: The result of the cipher operation\n */\nstatic void page_crypt_complete(struct crypto_async_request *req, int res)\n{\n\tstruct fscrypt_completion_result *ecr = req->data;\n\n\tif (res == -EINPROGRESS)\n\t\treturn;\n\tecr->res = res;\n\tcomplete(&ecr->completion);\n}\n\nint fscrypt_do_page_crypto(const struct inode *inode, fscrypt_direction_t rw,\n\t\t\t   u64 lblk_num, struct page *src_page,\n\t\t\t   struct page *dest_page, unsigned int len,\n\t\t\t   unsigned int offs, gfp_t gfp_flags)\n{\n\tstruct {\n\t\t__le64 index;\n\t\tu8 padding[FS_XTS_TWEAK_SIZE - sizeof(__le64)];\n\t} xts_tweak;\n\tstruct skcipher_request *req = NULL;\n\tDECLARE_FS_COMPLETION_RESULT(ecr);\n\tstruct scatterlist dst, src;\n\tstruct fscrypt_info *ci = inode->i_crypt_info;\n\tstruct crypto_skcipher *tfm = ci->ci_ctfm;\n\tint res = 0;\n\n\tBUG_ON(len == 0);\n\n\treq = skcipher_request_alloc(tfm, gfp_flags);\n\tif (!req) {\n\t\tprintk_ratelimited(KERN_ERR\n\t\t\t\t\"%s: crypto_request_alloc() failed\\n\",\n\t\t\t\t__func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tskcipher_request_set_callback(\n\t\treq, CRYPTO_TFM_REQ_MAY_BACKLOG | CRYPTO_TFM_REQ_MAY_SLEEP,\n\t\tpage_crypt_complete, &ecr);\n\n\tBUILD_BUG_ON(sizeof(xts_tweak) != FS_XTS_TWEAK_SIZE);\n\txts_tweak.index = cpu_to_le64(lblk_num);\n\tmemset(xts_tweak.padding, 0, sizeof(xts_tweak.padding));\n\n\tsg_init_table(&dst, 1);\n\tsg_set_page(&dst, dest_page, len, offs);\n\tsg_init_table(&src, 1);\n\tsg_set_page(&src, src_page, len, offs);\n\tskcipher_request_set_crypt(req, &src, &dst, len, &xts_tweak);\n\tif (rw == FS_DECRYPT)\n\t\tres = crypto_skcipher_decrypt(req);\n\telse\n\t\tres = crypto_skcipher_encrypt(req);\n\tif (res == -EINPROGRESS || res == -EBUSY) {\n\t\tBUG_ON(req->base.data != &ecr);\n\t\twait_for_completion(&ecr.completion);\n\t\tres = ecr.res;\n\t}\n\tskcipher_request_free(req);\n\tif (res) {\n\t\tprintk_ratelimited(KERN_ERR\n\t\t\t\"%s: crypto_skcipher_encrypt() returned %d\\n\",\n\t\t\t__func__, res);\n\t\treturn res;\n\t}\n\treturn 0;\n}\n\nstruct page *fscrypt_alloc_bounce_page(struct fscrypt_ctx *ctx,\n\t\t\t\t       gfp_t gfp_flags)\n{\n\tctx->w.bounce_page = mempool_alloc(fscrypt_bounce_page_pool, gfp_flags);\n\tif (ctx->w.bounce_page == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\tctx->flags |= FS_CTX_HAS_BOUNCE_BUFFER_FL;\n\treturn ctx->w.bounce_page;\n}\n\n/**\n * fscypt_encrypt_page() - Encrypts a page\n * @inode:     The inode for which the encryption should take place\n * @page:      The page to encrypt. Must be locked for bounce-page\n *             encryption.\n * @len:       Length of data to encrypt in @page and encrypted\n *             data in returned page.\n * @offs:      Offset of data within @page and returned\n *             page holding encrypted data.\n * @lblk_num:  Logical block number. This must be unique for multiple\n *             calls with same inode, except when overwriting\n *             previously written data.\n * @gfp_flags: The gfp flag for memory allocation\n *\n * Encrypts @page using the ctx encryption context. Performs encryption\n * either in-place or into a newly allocated bounce page.\n * Called on the page write path.\n *\n * Bounce page allocation is the default.\n * In this case, the contents of @page are encrypted and stored in an\n * allocated bounce page. @page has to be locked and the caller must call\n * fscrypt_restore_control_page() on the returned ciphertext page to\n * release the bounce buffer and the encryption context.\n *\n * In-place encryption is used by setting the FS_CFLG_OWN_PAGES flag in\n * fscrypt_operations. Here, the input-page is returned with its content\n * encrypted.\n *\n * Return: A page with the encrypted content on success. Else, an\n * error value or NULL.\n */\nstruct page *fscrypt_encrypt_page(const struct inode *inode,\n\t\t\t\tstruct page *page,\n\t\t\t\tunsigned int len,\n\t\t\t\tunsigned int offs,\n\t\t\t\tu64 lblk_num, gfp_t gfp_flags)\n\n{\n\tstruct fscrypt_ctx *ctx;\n\tstruct page *ciphertext_page = page;\n\tint err;\n\n\tBUG_ON(len % FS_CRYPTO_BLOCK_SIZE != 0);\n\n\tif (inode->i_sb->s_cop->flags & FS_CFLG_OWN_PAGES) {\n\t\t/* with inplace-encryption we just encrypt the page */\n\t\terr = fscrypt_do_page_crypto(inode, FS_ENCRYPT, lblk_num, page,\n\t\t\t\t\t     ciphertext_page, len, offs,\n\t\t\t\t\t     gfp_flags);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\n\t\treturn ciphertext_page;\n\t}\n\n\tBUG_ON(!PageLocked(page));\n\n\tctx = fscrypt_get_ctx(inode, gfp_flags);\n\tif (IS_ERR(ctx))\n\t\treturn (struct page *)ctx;\n\n\t/* The encryption operation will require a bounce page. */\n\tciphertext_page = fscrypt_alloc_bounce_page(ctx, gfp_flags);\n\tif (IS_ERR(ciphertext_page))\n\t\tgoto errout;\n\n\tctx->w.control_page = page;\n\terr = fscrypt_do_page_crypto(inode, FS_ENCRYPT, lblk_num,\n\t\t\t\t     page, ciphertext_page, len, offs,\n\t\t\t\t     gfp_flags);\n\tif (err) {\n\t\tciphertext_page = ERR_PTR(err);\n\t\tgoto errout;\n\t}\n\tSetPagePrivate(ciphertext_page);\n\tset_page_private(ciphertext_page, (unsigned long)ctx);\n\tlock_page(ciphertext_page);\n\treturn ciphertext_page;\n\nerrout:\n\tfscrypt_release_ctx(ctx);\n\treturn ciphertext_page;\n}\nEXPORT_SYMBOL(fscrypt_encrypt_page);\n\n/**\n * fscrypt_decrypt_page() - Decrypts a page in-place\n * @inode:     The corresponding inode for the page to decrypt.\n * @page:      The page to decrypt. Must be locked in case\n *             it is a writeback page (FS_CFLG_OWN_PAGES unset).\n * @len:       Number of bytes in @page to be decrypted.\n * @offs:      Start of data in @page.\n * @lblk_num:  Logical block number.\n *\n * Decrypts page in-place using the ctx encryption context.\n *\n * Called from the read completion callback.\n *\n * Return: Zero on success, non-zero otherwise.\n */\nint fscrypt_decrypt_page(const struct inode *inode, struct page *page,\n\t\t\tunsigned int len, unsigned int offs, u64 lblk_num)\n{\n\tif (!(inode->i_sb->s_cop->flags & FS_CFLG_OWN_PAGES))\n\t\tBUG_ON(!PageLocked(page));\n\n\treturn fscrypt_do_page_crypto(inode, FS_DECRYPT, lblk_num, page, page,\n\t\t\t\t      len, offs, GFP_NOFS);\n}\nEXPORT_SYMBOL(fscrypt_decrypt_page);\n\n/*\n * Validate dentries for encrypted directories to make sure we aren't\n * potentially caching stale data after a key has been added or\n * removed.\n */\nstatic int fscrypt_d_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tstruct dentry *dir;\n\tint dir_has_key, cached_with_key;\n\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\n\tdir = dget_parent(dentry);\n\tif (!d_inode(dir)->i_sb->s_cop->is_encrypted(d_inode(dir))) {\n\t\tdput(dir);\n\t\treturn 0;\n\t}\n\n\t/* this should eventually be an flag in d_flags */\n\tspin_lock(&dentry->d_lock);\n\tcached_with_key = dentry->d_flags & DCACHE_ENCRYPTED_WITH_KEY;\n\tspin_unlock(&dentry->d_lock);\n\tdir_has_key = (d_inode(dir)->i_crypt_info != NULL);\n\tdput(dir);\n\n\t/*\n\t * If the dentry was cached without the key, and it is a\n\t * negative dentry, it might be a valid name.  We can't check\n\t * if the key has since been made available due to locking\n\t * reasons, so we fail the validation so ext4_lookup() can do\n\t * this check.\n\t *\n\t * We also fail the validation if the dentry was created with\n\t * the key present, but we no longer have the key, or vice versa.\n\t */\n\tif ((!cached_with_key && d_is_negative(dentry)) ||\n\t\t\t(!cached_with_key && dir_has_key) ||\n\t\t\t(cached_with_key && !dir_has_key))\n\t\treturn 0;\n\treturn 1;\n}\n\nconst struct dentry_operations fscrypt_d_ops = {\n\t.d_revalidate = fscrypt_d_revalidate,\n};\nEXPORT_SYMBOL(fscrypt_d_ops);\n\nvoid fscrypt_restore_control_page(struct page *page)\n{\n\tstruct fscrypt_ctx *ctx;\n\n\tctx = (struct fscrypt_ctx *)page_private(page);\n\tset_page_private(page, (unsigned long)NULL);\n\tClearPagePrivate(page);\n\tunlock_page(page);\n\tfscrypt_release_ctx(ctx);\n}\nEXPORT_SYMBOL(fscrypt_restore_control_page);\n\nstatic void fscrypt_destroy(void)\n{\n\tstruct fscrypt_ctx *pos, *n;\n\n\tlist_for_each_entry_safe(pos, n, &fscrypt_free_ctxs, free_list)\n\t\tkmem_cache_free(fscrypt_ctx_cachep, pos);\n\tINIT_LIST_HEAD(&fscrypt_free_ctxs);\n\tmempool_destroy(fscrypt_bounce_page_pool);\n\tfscrypt_bounce_page_pool = NULL;\n}\n\n/**\n * fscrypt_initialize() - allocate major buffers for fs encryption.\n * @cop_flags:  fscrypt operations flags\n *\n * We only call this when we start accessing encrypted files, since it\n * results in memory getting allocated that wouldn't otherwise be used.\n *\n * Return: Zero on success, non-zero otherwise.\n */\nint fscrypt_initialize(unsigned int cop_flags)\n{\n\tint i, res = -ENOMEM;\n\n\t/*\n\t * No need to allocate a bounce page pool if there already is one or\n\t * this FS won't use it.\n\t */\n\tif (cop_flags & FS_CFLG_OWN_PAGES || fscrypt_bounce_page_pool)\n\t\treturn 0;\n\n\tmutex_lock(&fscrypt_init_mutex);\n\tif (fscrypt_bounce_page_pool)\n\t\tgoto already_initialized;\n\n\tfor (i = 0; i < num_prealloc_crypto_ctxs; i++) {\n\t\tstruct fscrypt_ctx *ctx;\n\n\t\tctx = kmem_cache_zalloc(fscrypt_ctx_cachep, GFP_NOFS);\n\t\tif (!ctx)\n\t\t\tgoto fail;\n\t\tlist_add(&ctx->free_list, &fscrypt_free_ctxs);\n\t}\n\n\tfscrypt_bounce_page_pool =\n\t\tmempool_create_page_pool(num_prealloc_crypto_pages, 0);\n\tif (!fscrypt_bounce_page_pool)\n\t\tgoto fail;\n\nalready_initialized:\n\tmutex_unlock(&fscrypt_init_mutex);\n\treturn 0;\nfail:\n\tfscrypt_destroy();\n\tmutex_unlock(&fscrypt_init_mutex);\n\treturn res;\n}\n\n/**\n * fscrypt_init() - Set up for fs encryption.\n */\nstatic int __init fscrypt_init(void)\n{\n\tfscrypt_read_workqueue = alloc_workqueue(\"fscrypt_read_queue\",\n\t\t\t\t\t\t\tWQ_HIGHPRI, 0);\n\tif (!fscrypt_read_workqueue)\n\t\tgoto fail;\n\n\tfscrypt_ctx_cachep = KMEM_CACHE(fscrypt_ctx, SLAB_RECLAIM_ACCOUNT);\n\tif (!fscrypt_ctx_cachep)\n\t\tgoto fail_free_queue;\n\n\tfscrypt_info_cachep = KMEM_CACHE(fscrypt_info, SLAB_RECLAIM_ACCOUNT);\n\tif (!fscrypt_info_cachep)\n\t\tgoto fail_free_ctx;\n\n\treturn 0;\n\nfail_free_ctx:\n\tkmem_cache_destroy(fscrypt_ctx_cachep);\nfail_free_queue:\n\tdestroy_workqueue(fscrypt_read_workqueue);\nfail:\n\treturn -ENOMEM;\n}\nmodule_init(fscrypt_init)\n\n/**\n * fscrypt_exit() - Shutdown the fs encryption system\n */\nstatic void __exit fscrypt_exit(void)\n{\n\tfscrypt_destroy();\n\n\tif (fscrypt_read_workqueue)\n\t\tdestroy_workqueue(fscrypt_read_workqueue);\n\tkmem_cache_destroy(fscrypt_ctx_cachep);\n\tkmem_cache_destroy(fscrypt_info_cachep);\n}\nmodule_exit(fscrypt_exit);\n\nMODULE_LICENSE(\"GPL\");\n", "/*\n * This contains functions for filename crypto management\n *\n * Copyright (C) 2015, Google, Inc.\n * Copyright (C) 2015, Motorola Mobility\n *\n * Written by Uday Savagaonkar, 2014.\n * Modified by Jaegeuk Kim, 2015.\n *\n * This has not yet undergone a rigorous security audit.\n */\n\n#include <linux/scatterlist.h>\n#include <linux/ratelimit.h>\n#include \"fscrypt_private.h\"\n\n/**\n * fname_crypt_complete() - completion callback for filename crypto\n * @req: The asynchronous cipher request context\n * @res: The result of the cipher operation\n */\nstatic void fname_crypt_complete(struct crypto_async_request *req, int res)\n{\n\tstruct fscrypt_completion_result *ecr = req->data;\n\n\tif (res == -EINPROGRESS)\n\t\treturn;\n\tecr->res = res;\n\tcomplete(&ecr->completion);\n}\n\n/**\n * fname_encrypt() - encrypt a filename\n *\n * The caller must have allocated sufficient memory for the @oname string.\n *\n * Return: 0 on success, -errno on failure\n */\nstatic int fname_encrypt(struct inode *inode,\n\t\t\tconst struct qstr *iname, struct fscrypt_str *oname)\n{\n\tstruct skcipher_request *req = NULL;\n\tDECLARE_FS_COMPLETION_RESULT(ecr);\n\tstruct fscrypt_info *ci = inode->i_crypt_info;\n\tstruct crypto_skcipher *tfm = ci->ci_ctfm;\n\tint res = 0;\n\tchar iv[FS_CRYPTO_BLOCK_SIZE];\n\tstruct scatterlist sg;\n\tint padding = 4 << (ci->ci_flags & FS_POLICY_FLAGS_PAD_MASK);\n\tunsigned int lim;\n\tunsigned int cryptlen;\n\n\tlim = inode->i_sb->s_cop->max_namelen(inode);\n\tif (iname->len <= 0 || iname->len > lim)\n\t\treturn -EIO;\n\n\t/*\n\t * Copy the filename to the output buffer for encrypting in-place and\n\t * pad it with the needed number of NUL bytes.\n\t */\n\tcryptlen = max_t(unsigned int, iname->len, FS_CRYPTO_BLOCK_SIZE);\n\tcryptlen = round_up(cryptlen, padding);\n\tcryptlen = min(cryptlen, lim);\n\tmemcpy(oname->name, iname->name, iname->len);\n\tmemset(oname->name + iname->len, 0, cryptlen - iname->len);\n\n\t/* Initialize the IV */\n\tmemset(iv, 0, FS_CRYPTO_BLOCK_SIZE);\n\n\t/* Set up the encryption request */\n\treq = skcipher_request_alloc(tfm, GFP_NOFS);\n\tif (!req) {\n\t\tprintk_ratelimited(KERN_ERR\n\t\t\t\"%s: skcipher_request_alloc() failed\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\tskcipher_request_set_callback(req,\n\t\t\tCRYPTO_TFM_REQ_MAY_BACKLOG | CRYPTO_TFM_REQ_MAY_SLEEP,\n\t\t\tfname_crypt_complete, &ecr);\n\tsg_init_one(&sg, oname->name, cryptlen);\n\tskcipher_request_set_crypt(req, &sg, &sg, cryptlen, iv);\n\n\t/* Do the encryption */\n\tres = crypto_skcipher_encrypt(req);\n\tif (res == -EINPROGRESS || res == -EBUSY) {\n\t\t/* Request is being completed asynchronously; wait for it */\n\t\twait_for_completion(&ecr.completion);\n\t\tres = ecr.res;\n\t}\n\tskcipher_request_free(req);\n\tif (res < 0) {\n\t\tprintk_ratelimited(KERN_ERR\n\t\t\t\t\"%s: Error (error code %d)\\n\", __func__, res);\n\t\treturn res;\n\t}\n\n\toname->len = cryptlen;\n\treturn 0;\n}\n\n/**\n * fname_decrypt() - decrypt a filename\n *\n * The caller must have allocated sufficient memory for the @oname string.\n *\n * Return: 0 on success, -errno on failure\n */\nstatic int fname_decrypt(struct inode *inode,\n\t\t\t\tconst struct fscrypt_str *iname,\n\t\t\t\tstruct fscrypt_str *oname)\n{\n\tstruct skcipher_request *req = NULL;\n\tDECLARE_FS_COMPLETION_RESULT(ecr);\n\tstruct scatterlist src_sg, dst_sg;\n\tstruct fscrypt_info *ci = inode->i_crypt_info;\n\tstruct crypto_skcipher *tfm = ci->ci_ctfm;\n\tint res = 0;\n\tchar iv[FS_CRYPTO_BLOCK_SIZE];\n\tunsigned lim;\n\n\tlim = inode->i_sb->s_cop->max_namelen(inode);\n\tif (iname->len <= 0 || iname->len > lim)\n\t\treturn -EIO;\n\n\t/* Allocate request */\n\treq = skcipher_request_alloc(tfm, GFP_NOFS);\n\tif (!req) {\n\t\tprintk_ratelimited(KERN_ERR\n\t\t\t\"%s: crypto_request_alloc() failed\\n\",  __func__);\n\t\treturn -ENOMEM;\n\t}\n\tskcipher_request_set_callback(req,\n\t\tCRYPTO_TFM_REQ_MAY_BACKLOG | CRYPTO_TFM_REQ_MAY_SLEEP,\n\t\tfname_crypt_complete, &ecr);\n\n\t/* Initialize IV */\n\tmemset(iv, 0, FS_CRYPTO_BLOCK_SIZE);\n\n\t/* Create decryption request */\n\tsg_init_one(&src_sg, iname->name, iname->len);\n\tsg_init_one(&dst_sg, oname->name, oname->len);\n\tskcipher_request_set_crypt(req, &src_sg, &dst_sg, iname->len, iv);\n\tres = crypto_skcipher_decrypt(req);\n\tif (res == -EINPROGRESS || res == -EBUSY) {\n\t\twait_for_completion(&ecr.completion);\n\t\tres = ecr.res;\n\t}\n\tskcipher_request_free(req);\n\tif (res < 0) {\n\t\tprintk_ratelimited(KERN_ERR\n\t\t\t\t\"%s: Error (error code %d)\\n\", __func__, res);\n\t\treturn res;\n\t}\n\n\toname->len = strnlen(oname->name, iname->len);\n\treturn 0;\n}\n\nstatic const char *lookup_table =\n\t\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+,\";\n\n/**\n * digest_encode() -\n *\n * Encodes the input digest using characters from the set [a-zA-Z0-9_+].\n * The encoded string is roughly 4/3 times the size of the input string.\n */\nstatic int digest_encode(const char *src, int len, char *dst)\n{\n\tint i = 0, bits = 0, ac = 0;\n\tchar *cp = dst;\n\n\twhile (i < len) {\n\t\tac += (((unsigned char) src[i]) << bits);\n\t\tbits += 8;\n\t\tdo {\n\t\t\t*cp++ = lookup_table[ac & 0x3f];\n\t\t\tac >>= 6;\n\t\t\tbits -= 6;\n\t\t} while (bits >= 6);\n\t\ti++;\n\t}\n\tif (bits)\n\t\t*cp++ = lookup_table[ac & 0x3f];\n\treturn cp - dst;\n}\n\nstatic int digest_decode(const char *src, int len, char *dst)\n{\n\tint i = 0, bits = 0, ac = 0;\n\tconst char *p;\n\tchar *cp = dst;\n\n\twhile (i < len) {\n\t\tp = strchr(lookup_table, src[i]);\n\t\tif (p == NULL || src[i] == 0)\n\t\t\treturn -2;\n\t\tac += (p - lookup_table) << bits;\n\t\tbits += 6;\n\t\tif (bits >= 8) {\n\t\t\t*cp++ = ac & 0xff;\n\t\t\tac >>= 8;\n\t\t\tbits -= 8;\n\t\t}\n\t\ti++;\n\t}\n\tif (ac)\n\t\treturn -1;\n\treturn cp - dst;\n}\n\nu32 fscrypt_fname_encrypted_size(const struct inode *inode, u32 ilen)\n{\n\tint padding = 32;\n\tstruct fscrypt_info *ci = inode->i_crypt_info;\n\n\tif (ci)\n\t\tpadding = 4 << (ci->ci_flags & FS_POLICY_FLAGS_PAD_MASK);\n\tilen = max(ilen, (u32)FS_CRYPTO_BLOCK_SIZE);\n\treturn round_up(ilen, padding);\n}\nEXPORT_SYMBOL(fscrypt_fname_encrypted_size);\n\n/**\n * fscrypt_fname_crypto_alloc_obuff() -\n *\n * Allocates an output buffer that is sufficient for the crypto operation\n * specified by the context and the direction.\n */\nint fscrypt_fname_alloc_buffer(const struct inode *inode,\n\t\t\t\tu32 ilen, struct fscrypt_str *crypto_str)\n{\n\tunsigned int olen = fscrypt_fname_encrypted_size(inode, ilen);\n\n\tcrypto_str->len = olen;\n\tif (olen < FS_FNAME_CRYPTO_DIGEST_SIZE * 2)\n\t\tolen = FS_FNAME_CRYPTO_DIGEST_SIZE * 2;\n\t/*\n\t * Allocated buffer can hold one more character to null-terminate the\n\t * string\n\t */\n\tcrypto_str->name = kmalloc(olen + 1, GFP_NOFS);\n\tif (!(crypto_str->name))\n\t\treturn -ENOMEM;\n\treturn 0;\n}\nEXPORT_SYMBOL(fscrypt_fname_alloc_buffer);\n\n/**\n * fscrypt_fname_crypto_free_buffer() -\n *\n * Frees the buffer allocated for crypto operation.\n */\nvoid fscrypt_fname_free_buffer(struct fscrypt_str *crypto_str)\n{\n\tif (!crypto_str)\n\t\treturn;\n\tkfree(crypto_str->name);\n\tcrypto_str->name = NULL;\n}\nEXPORT_SYMBOL(fscrypt_fname_free_buffer);\n\n/**\n * fscrypt_fname_disk_to_usr() - converts a filename from disk space to user\n * space\n *\n * The caller must have allocated sufficient memory for the @oname string.\n *\n * Return: 0 on success, -errno on failure\n */\nint fscrypt_fname_disk_to_usr(struct inode *inode,\n\t\t\tu32 hash, u32 minor_hash,\n\t\t\tconst struct fscrypt_str *iname,\n\t\t\tstruct fscrypt_str *oname)\n{\n\tconst struct qstr qname = FSTR_TO_QSTR(iname);\n\tchar buf[24];\n\n\tif (fscrypt_is_dot_dotdot(&qname)) {\n\t\toname->name[0] = '.';\n\t\toname->name[iname->len - 1] = '.';\n\t\toname->len = iname->len;\n\t\treturn 0;\n\t}\n\n\tif (iname->len < FS_CRYPTO_BLOCK_SIZE)\n\t\treturn -EUCLEAN;\n\n\tif (inode->i_crypt_info)\n\t\treturn fname_decrypt(inode, iname, oname);\n\n\tif (iname->len <= FS_FNAME_CRYPTO_DIGEST_SIZE) {\n\t\toname->len = digest_encode(iname->name, iname->len,\n\t\t\t\t\t   oname->name);\n\t\treturn 0;\n\t}\n\tif (hash) {\n\t\tmemcpy(buf, &hash, 4);\n\t\tmemcpy(buf + 4, &minor_hash, 4);\n\t} else {\n\t\tmemset(buf, 0, 8);\n\t}\n\tmemcpy(buf + 8, iname->name + iname->len - 16, 16);\n\toname->name[0] = '_';\n\toname->len = 1 + digest_encode(buf, 24, oname->name + 1);\n\treturn 0;\n}\nEXPORT_SYMBOL(fscrypt_fname_disk_to_usr);\n\n/**\n * fscrypt_fname_usr_to_disk() - converts a filename from user space to disk\n * space\n *\n * The caller must have allocated sufficient memory for the @oname string.\n *\n * Return: 0 on success, -errno on failure\n */\nint fscrypt_fname_usr_to_disk(struct inode *inode,\n\t\t\tconst struct qstr *iname,\n\t\t\tstruct fscrypt_str *oname)\n{\n\tif (fscrypt_is_dot_dotdot(iname)) {\n\t\toname->name[0] = '.';\n\t\toname->name[iname->len - 1] = '.';\n\t\toname->len = iname->len;\n\t\treturn 0;\n\t}\n\tif (inode->i_crypt_info)\n\t\treturn fname_encrypt(inode, iname, oname);\n\t/*\n\t * Without a proper key, a user is not allowed to modify the filenames\n\t * in a directory. Consequently, a user space name cannot be mapped to\n\t * a disk-space name\n\t */\n\treturn -ENOKEY;\n}\nEXPORT_SYMBOL(fscrypt_fname_usr_to_disk);\n\nint fscrypt_setup_filename(struct inode *dir, const struct qstr *iname,\n\t\t\t      int lookup, struct fscrypt_name *fname)\n{\n\tint ret = 0, bigname = 0;\n\n\tmemset(fname, 0, sizeof(struct fscrypt_name));\n\tfname->usr_fname = iname;\n\n\tif (!dir->i_sb->s_cop->is_encrypted(dir) ||\n\t\t\t\tfscrypt_is_dot_dotdot(iname)) {\n\t\tfname->disk_name.name = (unsigned char *)iname->name;\n\t\tfname->disk_name.len = iname->len;\n\t\treturn 0;\n\t}\n\tret = fscrypt_get_encryption_info(dir);\n\tif (ret && ret != -EOPNOTSUPP)\n\t\treturn ret;\n\n\tif (dir->i_crypt_info) {\n\t\tret = fscrypt_fname_alloc_buffer(dir, iname->len,\n\t\t\t\t\t\t\t&fname->crypto_buf);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = fname_encrypt(dir, iname, &fname->crypto_buf);\n\t\tif (ret)\n\t\t\tgoto errout;\n\t\tfname->disk_name.name = fname->crypto_buf.name;\n\t\tfname->disk_name.len = fname->crypto_buf.len;\n\t\treturn 0;\n\t}\n\tif (!lookup)\n\t\treturn -ENOKEY;\n\n\t/*\n\t * We don't have the key and we are doing a lookup; decode the\n\t * user-supplied name\n\t */\n\tif (iname->name[0] == '_')\n\t\tbigname = 1;\n\tif ((bigname && (iname->len != 33)) || (!bigname && (iname->len > 43)))\n\t\treturn -ENOENT;\n\n\tfname->crypto_buf.name = kmalloc(32, GFP_KERNEL);\n\tif (fname->crypto_buf.name == NULL)\n\t\treturn -ENOMEM;\n\n\tret = digest_decode(iname->name + bigname, iname->len - bigname,\n\t\t\t\tfname->crypto_buf.name);\n\tif (ret < 0) {\n\t\tret = -ENOENT;\n\t\tgoto errout;\n\t}\n\tfname->crypto_buf.len = ret;\n\tif (bigname) {\n\t\tmemcpy(&fname->hash, fname->crypto_buf.name, 4);\n\t\tmemcpy(&fname->minor_hash, fname->crypto_buf.name + 4, 4);\n\t} else {\n\t\tfname->disk_name.name = fname->crypto_buf.name;\n\t\tfname->disk_name.len = fname->crypto_buf.len;\n\t}\n\treturn 0;\n\nerrout:\n\tfscrypt_fname_free_buffer(&fname->crypto_buf);\n\treturn ret;\n}\nEXPORT_SYMBOL(fscrypt_setup_filename);\n\nvoid fscrypt_free_filename(struct fscrypt_name *fname)\n{\n\tkfree(fname->crypto_buf.name);\n\tfname->crypto_buf.name = NULL;\n\tfname->usr_fname = NULL;\n\tfname->disk_name.name = NULL;\n}\nEXPORT_SYMBOL(fscrypt_free_filename);\n", "/*\n * fscrypt_private.h\n *\n * Copyright (C) 2015, Google, Inc.\n *\n * This contains encryption key functions.\n *\n * Written by Michael Halcrow, Ildar Muslukhov, and Uday Savagaonkar, 2015.\n */\n\n#ifndef _FSCRYPT_PRIVATE_H\n#define _FSCRYPT_PRIVATE_H\n\n#include <linux/fscrypt_supp.h>\n\n#define FS_FNAME_CRYPTO_DIGEST_SIZE\t32\n\n/* Encryption parameters */\n#define FS_XTS_TWEAK_SIZE\t\t16\n#define FS_AES_128_ECB_KEY_SIZE\t\t16\n#define FS_AES_256_GCM_KEY_SIZE\t\t32\n#define FS_AES_256_CBC_KEY_SIZE\t\t32\n#define FS_AES_256_CTS_KEY_SIZE\t\t32\n#define FS_AES_256_XTS_KEY_SIZE\t\t64\n#define FS_MAX_KEY_SIZE\t\t\t64\n\n#define FS_KEY_DESC_PREFIX\t\t\"fscrypt:\"\n#define FS_KEY_DESC_PREFIX_SIZE\t\t8\n\n#define FS_KEY_DERIVATION_NONCE_SIZE\t\t16\n\n/**\n * Encryption context for inode\n *\n * Protector format:\n *  1 byte: Protector format (1 = this version)\n *  1 byte: File contents encryption mode\n *  1 byte: File names encryption mode\n *  1 byte: Flags\n *  8 bytes: Master Key descriptor\n *  16 bytes: Encryption Key derivation nonce\n */\nstruct fscrypt_context {\n\tu8 format;\n\tu8 contents_encryption_mode;\n\tu8 filenames_encryption_mode;\n\tu8 flags;\n\tu8 master_key_descriptor[FS_KEY_DESCRIPTOR_SIZE];\n\tu8 nonce[FS_KEY_DERIVATION_NONCE_SIZE];\n} __packed;\n\n#define FS_ENCRYPTION_CONTEXT_FORMAT_V1\t\t1\n\n/* This is passed in from userspace into the kernel keyring */\nstruct fscrypt_key {\n\tu32 mode;\n\tu8 raw[FS_MAX_KEY_SIZE];\n\tu32 size;\n} __packed;\n\n/*\n * A pointer to this structure is stored in the file system's in-core\n * representation of an inode.\n */\nstruct fscrypt_info {\n\tu8 ci_data_mode;\n\tu8 ci_filename_mode;\n\tu8 ci_flags;\n\tstruct crypto_skcipher *ci_ctfm;\n\tu8 ci_master_key[FS_KEY_DESCRIPTOR_SIZE];\n};\n\ntypedef enum {\n\tFS_DECRYPT = 0,\n\tFS_ENCRYPT,\n} fscrypt_direction_t;\n\n#define FS_CTX_REQUIRES_FREE_ENCRYPT_FL\t\t0x00000001\n#define FS_CTX_HAS_BOUNCE_BUFFER_FL\t\t0x00000002\n\nstruct fscrypt_completion_result {\n\tstruct completion completion;\n\tint res;\n};\n\n#define DECLARE_FS_COMPLETION_RESULT(ecr) \\\n\tstruct fscrypt_completion_result ecr = { \\\n\t\tCOMPLETION_INITIALIZER_ONSTACK((ecr).completion), 0 }\n\n\n/* crypto.c */\nextern int fscrypt_initialize(unsigned int cop_flags);\nextern struct workqueue_struct *fscrypt_read_workqueue;\nextern int fscrypt_do_page_crypto(const struct inode *inode,\n\t\t\t\t  fscrypt_direction_t rw, u64 lblk_num,\n\t\t\t\t  struct page *src_page,\n\t\t\t\t  struct page *dest_page,\n\t\t\t\t  unsigned int len, unsigned int offs,\n\t\t\t\t  gfp_t gfp_flags);\nextern struct page *fscrypt_alloc_bounce_page(struct fscrypt_ctx *ctx,\n\t\t\t\t\t      gfp_t gfp_flags);\n\n#endif /* _FSCRYPT_PRIVATE_H */\n", "/*\n * key management facility for FS encryption support.\n *\n * Copyright (C) 2015, Google, Inc.\n *\n * This contains encryption key functions.\n *\n * Written by Michael Halcrow, Ildar Muslukhov, and Uday Savagaonkar, 2015.\n */\n\n#include <keys/user-type.h>\n#include <linux/scatterlist.h>\n#include \"fscrypt_private.h\"\n\nstatic void derive_crypt_complete(struct crypto_async_request *req, int rc)\n{\n\tstruct fscrypt_completion_result *ecr = req->data;\n\n\tif (rc == -EINPROGRESS)\n\t\treturn;\n\n\tecr->res = rc;\n\tcomplete(&ecr->completion);\n}\n\n/**\n * derive_key_aes() - Derive a key using AES-128-ECB\n * @deriving_key: Encryption key used for derivation.\n * @source_key:   Source key to which to apply derivation.\n * @derived_key:  Derived key.\n *\n * Return: Zero on success; non-zero otherwise.\n */\nstatic int derive_key_aes(u8 deriving_key[FS_AES_128_ECB_KEY_SIZE],\n\t\t\t\tu8 source_key[FS_AES_256_XTS_KEY_SIZE],\n\t\t\t\tu8 derived_key[FS_AES_256_XTS_KEY_SIZE])\n{\n\tint res = 0;\n\tstruct skcipher_request *req = NULL;\n\tDECLARE_FS_COMPLETION_RESULT(ecr);\n\tstruct scatterlist src_sg, dst_sg;\n\tstruct crypto_skcipher *tfm = crypto_alloc_skcipher(\"ecb(aes)\", 0, 0);\n\n\tif (IS_ERR(tfm)) {\n\t\tres = PTR_ERR(tfm);\n\t\ttfm = NULL;\n\t\tgoto out;\n\t}\n\tcrypto_skcipher_set_flags(tfm, CRYPTO_TFM_REQ_WEAK_KEY);\n\treq = skcipher_request_alloc(tfm, GFP_NOFS);\n\tif (!req) {\n\t\tres = -ENOMEM;\n\t\tgoto out;\n\t}\n\tskcipher_request_set_callback(req,\n\t\t\tCRYPTO_TFM_REQ_MAY_BACKLOG | CRYPTO_TFM_REQ_MAY_SLEEP,\n\t\t\tderive_crypt_complete, &ecr);\n\tres = crypto_skcipher_setkey(tfm, deriving_key,\n\t\t\t\t\tFS_AES_128_ECB_KEY_SIZE);\n\tif (res < 0)\n\t\tgoto out;\n\n\tsg_init_one(&src_sg, source_key, FS_AES_256_XTS_KEY_SIZE);\n\tsg_init_one(&dst_sg, derived_key, FS_AES_256_XTS_KEY_SIZE);\n\tskcipher_request_set_crypt(req, &src_sg, &dst_sg,\n\t\t\t\t\tFS_AES_256_XTS_KEY_SIZE, NULL);\n\tres = crypto_skcipher_encrypt(req);\n\tif (res == -EINPROGRESS || res == -EBUSY) {\n\t\twait_for_completion(&ecr.completion);\n\t\tres = ecr.res;\n\t}\nout:\n\tskcipher_request_free(req);\n\tcrypto_free_skcipher(tfm);\n\treturn res;\n}\n\nstatic int validate_user_key(struct fscrypt_info *crypt_info,\n\t\t\tstruct fscrypt_context *ctx, u8 *raw_key,\n\t\t\tconst char *prefix)\n{\n\tchar *description;\n\tstruct key *keyring_key;\n\tstruct fscrypt_key *master_key;\n\tconst struct user_key_payload *ukp;\n\tint res;\n\n\tdescription = kasprintf(GFP_NOFS, \"%s%*phN\", prefix,\n\t\t\t\tFS_KEY_DESCRIPTOR_SIZE,\n\t\t\t\tctx->master_key_descriptor);\n\tif (!description)\n\t\treturn -ENOMEM;\n\n\tkeyring_key = request_key(&key_type_logon, description, NULL);\n\tkfree(description);\n\tif (IS_ERR(keyring_key))\n\t\treturn PTR_ERR(keyring_key);\n\tdown_read(&keyring_key->sem);\n\n\tif (keyring_key->type != &key_type_logon) {\n\t\tprintk_once(KERN_WARNING\n\t\t\t\t\"%s: key type must be logon\\n\", __func__);\n\t\tres = -ENOKEY;\n\t\tgoto out;\n\t}\n\tukp = user_key_payload(keyring_key);\n\tif (ukp->datalen != sizeof(struct fscrypt_key)) {\n\t\tres = -EINVAL;\n\t\tgoto out;\n\t}\n\tmaster_key = (struct fscrypt_key *)ukp->data;\n\tBUILD_BUG_ON(FS_AES_128_ECB_KEY_SIZE != FS_KEY_DERIVATION_NONCE_SIZE);\n\n\tif (master_key->size != FS_AES_256_XTS_KEY_SIZE) {\n\t\tprintk_once(KERN_WARNING\n\t\t\t\t\"%s: key size incorrect: %d\\n\",\n\t\t\t\t__func__, master_key->size);\n\t\tres = -ENOKEY;\n\t\tgoto out;\n\t}\n\tres = derive_key_aes(ctx->nonce, master_key->raw, raw_key);\nout:\n\tup_read(&keyring_key->sem);\n\tkey_put(keyring_key);\n\treturn res;\n}\n\nstatic int determine_cipher_type(struct fscrypt_info *ci, struct inode *inode,\n\t\t\t\t const char **cipher_str_ret, int *keysize_ret)\n{\n\tif (S_ISREG(inode->i_mode)) {\n\t\tif (ci->ci_data_mode == FS_ENCRYPTION_MODE_AES_256_XTS) {\n\t\t\t*cipher_str_ret = \"xts(aes)\";\n\t\t\t*keysize_ret = FS_AES_256_XTS_KEY_SIZE;\n\t\t\treturn 0;\n\t\t}\n\t\tpr_warn_once(\"fscrypto: unsupported contents encryption mode \"\n\t\t\t     \"%d for inode %lu\\n\",\n\t\t\t     ci->ci_data_mode, inode->i_ino);\n\t\treturn -ENOKEY;\n\t}\n\n\tif (S_ISDIR(inode->i_mode) || S_ISLNK(inode->i_mode)) {\n\t\tif (ci->ci_filename_mode == FS_ENCRYPTION_MODE_AES_256_CTS) {\n\t\t\t*cipher_str_ret = \"cts(cbc(aes))\";\n\t\t\t*keysize_ret = FS_AES_256_CTS_KEY_SIZE;\n\t\t\treturn 0;\n\t\t}\n\t\tpr_warn_once(\"fscrypto: unsupported filenames encryption mode \"\n\t\t\t     \"%d for inode %lu\\n\",\n\t\t\t     ci->ci_filename_mode, inode->i_ino);\n\t\treturn -ENOKEY;\n\t}\n\n\tpr_warn_once(\"fscrypto: unsupported file type %d for inode %lu\\n\",\n\t\t     (inode->i_mode & S_IFMT), inode->i_ino);\n\treturn -ENOKEY;\n}\n\nstatic void put_crypt_info(struct fscrypt_info *ci)\n{\n\tif (!ci)\n\t\treturn;\n\n\tcrypto_free_skcipher(ci->ci_ctfm);\n\tkmem_cache_free(fscrypt_info_cachep, ci);\n}\n\nint fscrypt_get_encryption_info(struct inode *inode)\n{\n\tstruct fscrypt_info *crypt_info;\n\tstruct fscrypt_context ctx;\n\tstruct crypto_skcipher *ctfm;\n\tconst char *cipher_str;\n\tint keysize;\n\tu8 *raw_key = NULL;\n\tint res;\n\n\tif (inode->i_crypt_info)\n\t\treturn 0;\n\n\tres = fscrypt_initialize(inode->i_sb->s_cop->flags);\n\tif (res)\n\t\treturn res;\n\n\tif (!inode->i_sb->s_cop->get_context)\n\t\treturn -EOPNOTSUPP;\n\n\tres = inode->i_sb->s_cop->get_context(inode, &ctx, sizeof(ctx));\n\tif (res < 0) {\n\t\tif (!fscrypt_dummy_context_enabled(inode) ||\n\t\t    inode->i_sb->s_cop->is_encrypted(inode))\n\t\t\treturn res;\n\t\t/* Fake up a context for an unencrypted directory */\n\t\tmemset(&ctx, 0, sizeof(ctx));\n\t\tctx.format = FS_ENCRYPTION_CONTEXT_FORMAT_V1;\n\t\tctx.contents_encryption_mode = FS_ENCRYPTION_MODE_AES_256_XTS;\n\t\tctx.filenames_encryption_mode = FS_ENCRYPTION_MODE_AES_256_CTS;\n\t\tmemset(ctx.master_key_descriptor, 0x42, FS_KEY_DESCRIPTOR_SIZE);\n\t} else if (res != sizeof(ctx)) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (ctx.format != FS_ENCRYPTION_CONTEXT_FORMAT_V1)\n\t\treturn -EINVAL;\n\n\tif (ctx.flags & ~FS_POLICY_FLAGS_VALID)\n\t\treturn -EINVAL;\n\n\tcrypt_info = kmem_cache_alloc(fscrypt_info_cachep, GFP_NOFS);\n\tif (!crypt_info)\n\t\treturn -ENOMEM;\n\n\tcrypt_info->ci_flags = ctx.flags;\n\tcrypt_info->ci_data_mode = ctx.contents_encryption_mode;\n\tcrypt_info->ci_filename_mode = ctx.filenames_encryption_mode;\n\tcrypt_info->ci_ctfm = NULL;\n\tmemcpy(crypt_info->ci_master_key, ctx.master_key_descriptor,\n\t\t\t\tsizeof(crypt_info->ci_master_key));\n\n\tres = determine_cipher_type(crypt_info, inode, &cipher_str, &keysize);\n\tif (res)\n\t\tgoto out;\n\n\t/*\n\t * This cannot be a stack buffer because it is passed to the scatterlist\n\t * crypto API as part of key derivation.\n\t */\n\tres = -ENOMEM;\n\traw_key = kmalloc(FS_MAX_KEY_SIZE, GFP_NOFS);\n\tif (!raw_key)\n\t\tgoto out;\n\n\tres = validate_user_key(crypt_info, &ctx, raw_key, FS_KEY_DESC_PREFIX);\n\tif (res && inode->i_sb->s_cop->key_prefix) {\n\t\tint res2 = validate_user_key(crypt_info, &ctx, raw_key,\n\t\t\t\t\t     inode->i_sb->s_cop->key_prefix);\n\t\tif (res2) {\n\t\t\tif (res2 == -ENOKEY)\n\t\t\t\tres = -ENOKEY;\n\t\t\tgoto out;\n\t\t}\n\t} else if (res) {\n\t\tgoto out;\n\t}\n\tctfm = crypto_alloc_skcipher(cipher_str, 0, 0);\n\tif (!ctfm || IS_ERR(ctfm)) {\n\t\tres = ctfm ? PTR_ERR(ctfm) : -ENOMEM;\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s: error %d (inode %u) allocating crypto tfm\\n\",\n\t\t       __func__, res, (unsigned) inode->i_ino);\n\t\tgoto out;\n\t}\n\tcrypt_info->ci_ctfm = ctfm;\n\tcrypto_skcipher_clear_flags(ctfm, ~0);\n\tcrypto_skcipher_set_flags(ctfm, CRYPTO_TFM_REQ_WEAK_KEY);\n\tres = crypto_skcipher_setkey(ctfm, raw_key, keysize);\n\tif (res)\n\t\tgoto out;\n\n\tif (cmpxchg(&inode->i_crypt_info, NULL, crypt_info) == NULL)\n\t\tcrypt_info = NULL;\nout:\n\tif (res == -ENOKEY)\n\t\tres = 0;\n\tput_crypt_info(crypt_info);\n\tkzfree(raw_key);\n\treturn res;\n}\nEXPORT_SYMBOL(fscrypt_get_encryption_info);\n\nvoid fscrypt_put_encryption_info(struct inode *inode, struct fscrypt_info *ci)\n{\n\tstruct fscrypt_info *prev;\n\n\tif (ci == NULL)\n\t\tci = ACCESS_ONCE(inode->i_crypt_info);\n\tif (ci == NULL)\n\t\treturn;\n\n\tprev = cmpxchg(&inode->i_crypt_info, ci, NULL);\n\tif (prev != ci)\n\t\treturn;\n\n\tput_crypt_info(ci);\n}\nEXPORT_SYMBOL(fscrypt_put_encryption_info);\n"], "filenames": ["fs/crypto/crypto.c", "fs/crypto/fname.c", "fs/crypto/fscrypt_private.h", "fs/crypto/keyinfo.c"], "buggy_code_start_loc": [330, 353, 70, 97], "buggy_code_end_loc": [354, 354, 107, 322], "fixing_code_start_loc": [329, 353, 69, 98], "fixing_code_end_loc": [346, 354, 102, 287], "type": "CWE-416", "message": "Use-after-free vulnerability in fs/crypto/ in the Linux kernel before 4.10.7 allows local users to cause a denial of service (NULL pointer dereference) or possibly gain privileges by revoking keyring keys being used for ext4, f2fs, or ubifs encryption, causing cryptographic transform objects to be freed prematurely.", "other": {"cve": {"id": "CVE-2017-7374", "sourceIdentifier": "cve@mitre.org", "published": "2017-03-31T20:59:00.167", "lastModified": "2023-02-14T21:38:04.967", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Use-after-free vulnerability in fs/crypto/ in the Linux kernel before 4.10.7 allows local users to cause a denial of service (NULL pointer dereference) or possibly gain privileges by revoking keyring keys being used for ext4, f2fs, or ubifs encryption, causing cryptographic transform objects to be freed prematurely."}, {"lang": "es", "value": "Vulnerabilidad de uso despu\u00e9s de liberaci\u00f3n de memoria en fs/crypto/ en el kernel de Linux en versiones anteriores a 4.10.7 permite a usuarios locales provocar una denegaci\u00f3n de servicio (referencia a puntero NULL) o posiblemente obtener privilegios revocando el llavero de claves utilizado para cifrado ext4, f2fs o ubifs, provocando que los objetos de transformaci\u00f3n criptogr\u00e1fica sean liberados prematuramente."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}, {"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.2", "versionEndExcluding": "4.4.59", "matchCriteriaId": "86ECD7D8-40A9-4227-B77D-867268FFDEAC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.5", "versionEndExcluding": "4.9.20", "matchCriteriaId": "D092A759-EAC4-4DDC-A3AF-7BECC8D32811"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.10", "versionEndExcluding": "4.10.7", "matchCriteriaId": "7E814839-1040-4BC0-8D84-A0011E6C3B71"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=1b53cf9815bb4744958d41f3795d5d5a1d365e2d", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/97308", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/torvalds/linux/commit/1b53cf9815bb4744958d41f3795d5d5a1d365e2d", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://source.android.com/security/bulletin/2017-10-01", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.10.7", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/1b53cf9815bb4744958d41f3795d5d5a1d365e2d"}}