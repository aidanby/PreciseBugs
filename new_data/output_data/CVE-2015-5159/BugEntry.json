{"buggy_code": ["# Copyright (C) 2013, Red Hat, Inc.\n# All rights reserved.\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n# THE SOFTWARE.\n\nimport io\nimport logging\nimport select\nimport socket\nimport struct\nimport sys\nimport time\n\ntry:  # Python 3.x\n    import http.client as httplib\n    import urllib.parse as urlparse\nexcept ImportError:  # Python 2.x\n    import httplib\n    import urlparse\n\nimport kdcproxy.codec as codec\nfrom kdcproxy.config import MetaResolver\n\n\nclass HTTPException(Exception):\n\n    def __init__(self, code, msg, headers=[]):\n        headers = list(filter(lambda h: h[0] != 'Content-Length', headers))\n\n        if 'Content-Type' not in dict(headers):\n            headers.append(('Content-Type', 'text/plain; charset=utf-8'))\n\n        if sys.version_info.major == 3 and isinstance(msg, str):\n            msg = bytes(msg, \"utf-8\")\n\n        headers.append(('Content-Length', str(len(msg))))\n\n        super(HTTPException, self).__init__(code, msg, headers)\n        self.code = code\n        self.message = msg\n        self.headers = headers\n\n    def __str__(self):\n        return \"%d %s\" % (self.code, httplib.responses[self.code])\n\n\nclass Application:\n    SOCKTYPES = {\n        \"tcp\": socket.SOCK_STREAM,\n        \"udp\": socket.SOCK_DGRAM,\n    }\n\n    def __init__(self):\n        self.__resolver = MetaResolver()\n\n    def __await_reply(self, pr, rsocks, wsocks, timeout):\n        extra = 0\n        read_buffers = {}\n        while (timeout + extra) > time.time():\n            if not wsocks and not rsocks:\n                break\n\n            r, w, x = select.select(rsocks, wsocks, rsocks + wsocks,\n                                    (timeout + extra) - time.time())\n            for sock in x:\n                sock.close()\n                try:\n                    rsocks.remove(sock)\n                except ValueError:\n                    pass\n                try:\n                    wsocks.remove(sock)\n                except ValueError:\n                    pass\n\n            for sock in w:\n                try:\n                    if self.sock_type(sock) == socket.SOCK_DGRAM:\n                        # If we proxy over UDP, remove the 4-byte length\n                        # prefix since it is TCP only.\n                        sock.sendall(pr.request[4:])\n                    else:\n                        sock.sendall(pr.request)\n                        extra = 10  # New connections get 10 extra seconds\n                except Exception:\n                    logging.exception('Error in recv() of %s', sock)\n                    continue\n                rsocks.append(sock)\n                wsocks.remove(sock)\n\n            for sock in r:\n                try:\n                    reply = self.__handle_recv(sock, read_buffers)\n                except Exception:\n                    logging.exception('Error in recv() of %s', sock)\n                    if self.sock_type(sock) == socket.SOCK_STREAM:\n                        # Remove broken TCP socket from readers\n                        rsocks.remove(sock)\n                else:\n                    if reply is not None:\n                        return reply\n\n        return None\n\n    def __handle_recv(self, sock, read_buffers):\n        if self.sock_type(sock) == socket.SOCK_DGRAM:\n            # For UDP sockets, recv() returns an entire datagram\n            # package. KDC sends one datagram as reply.\n            reply = sock.recv(1048576)\n            # If we proxy over UDP, we will be missing the 4-byte\n            # length prefix. So add it.\n            reply = struct.pack(\"!I\", len(reply)) + reply\n            return reply\n        else:\n            # TCP is a different story. The reply must be buffered\n            # until the full answer is accumulated.\n            buf = read_buffers.get(sock)\n            part = sock.recv(1048576)\n            if buf is None:\n                if len(part) > 4:\n                    # got enough data in the initial package. Now check\n                    # if we got the full package in the first run.\n                    (length, ) = struct.unpack(\"!I\", part[0:4])\n                    if length + 4 == len(part):\n                        return part\n                read_buffers[sock] = buf = io.BytesIO()\n\n            if part:\n                # data received, accumulate it in a buffer\n                buf.write(part)\n                return None\n            else:\n                # EOF received\n                read_buffers.pop(sock)\n                reply = buf.getvalue()\n                return reply\n\n    def __filter_addr(self, addr):\n        if addr[0] not in (socket.AF_INET, socket.AF_INET6):\n            return False\n\n        if addr[1] not in (socket.SOCK_STREAM, socket.SOCK_DGRAM):\n            return False\n\n        if addr[2] not in (socket.IPPROTO_TCP, socket.IPPROTO_UDP):\n            return False\n\n        return True\n\n    def sock_type(self, sock):\n        try:\n            return sock.type & ~socket.SOCK_NONBLOCK\n        except AttributeError:\n            return sock.type\n\n    def __call__(self, env, start_response):\n        try:\n            # Validate the method\n            method = env[\"REQUEST_METHOD\"].upper()\n            if method != \"POST\":\n                raise HTTPException(405, \"Method not allowed (%s).\" % method)\n\n            # Parse the request\n            try:\n                length = int(env[\"CONTENT_LENGTH\"])\n            except AttributeError:\n                length = -1\n            try:\n                pr = codec.decode(env[\"wsgi.input\"].read(length))\n            except codec.ParsingError as e:\n                raise HTTPException(400, e.message)\n\n            # Find the remote proxy\n            servers = self.__resolver.lookup(\n                pr.realm,\n                kpasswd=isinstance(pr, codec.KPASSWDProxyRequest)\n            )\n            if not servers:\n                raise HTTPException(503, \"Can't find remote (%s).\" % pr)\n\n            # Contact the remote server\n            reply = None\n            wsocks = []\n            rsocks = []\n            for server in map(urlparse.urlparse, servers):\n                # Enforce valid, supported URIs\n                scheme = server.scheme.lower().split(\"+\", 1)\n                if scheme[0] not in (\"kerberos\", \"kpasswd\"):\n                    continue\n                if len(scheme) > 1 and scheme[1] not in (\"tcp\", \"udp\"):\n                    continue\n\n                # Do the DNS lookup\n                try:\n                    port = server.port\n                    if port is None:\n                        port = scheme[0]\n                    addrs = socket.getaddrinfo(server.hostname, port)\n                except socket.gaierror:\n                    continue\n\n                # Sort addresses so that we get TCP first.\n                #\n                # Stick a None address on the end so we can get one\n                # more attempt after all servers have been contacted.\n                addrs = tuple(sorted(filter(self.__filter_addr, addrs)))\n                for addr in addrs + (None,):\n                    if addr is not None:\n                        # Bypass unspecified socktypes\n                        if (len(scheme) > 1\n                                and addr[1] != self.SOCKTYPES[scheme[1]]):\n                            continue\n\n                        # Create the socket\n                        sock = socket.socket(*addr[:3])\n                        sock.setblocking(0)\n\n                        # Connect\n                        try:\n                            # In Python 2.x, non-blocking connect() throws\n                            # socket.error() with errno == EINPROGRESS. In\n                            # Python 3.x, it throws io.BlockingIOError().\n                            sock.connect(addr[4])\n                        except socket.error as e:\n                            if e.errno != 115:  # errno != EINPROGRESS\n                                sock.close()\n                                continue\n                        except io.BlockingIOError:\n                            pass\n                        wsocks.append(sock)\n\n                    # Resend packets to UDP servers\n                    for sock in tuple(rsocks):\n                        if self.sock_type(sock) == socket.SOCK_DGRAM:\n                            wsocks.append(sock)\n                            rsocks.remove(sock)\n\n                    # Call select()\n                    timeout = time.time() + (15 if addr is None else 2)\n                    reply = self.__await_reply(pr, rsocks, wsocks, timeout)\n                    if reply is not None:\n                        break\n\n                if reply is not None:\n                    break\n\n            for sock in rsocks + wsocks:\n                sock.close()\n\n            if reply is None:\n                raise HTTPException(503, \"Remote unavailable (%s).\" % pr)\n\n            # Return the result to the client\n            raise HTTPException(200, codec.encode(reply),\n                                [(\"Content-Type\", \"application/kerberos\")])\n        except HTTPException as e:\n            start_response(str(e), e.headers)\n            return [e.message]\n\napplication = Application()\n"], "fixing_code": ["# Copyright (C) 2013, Red Hat, Inc.\n# All rights reserved.\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n# THE SOFTWARE.\n\nimport io\nimport logging\nimport select\nimport socket\nimport struct\nimport sys\nimport time\n\ntry:  # Python 3.x\n    import http.client as httplib\n    import urllib.parse as urlparse\nexcept ImportError:  # Python 2.x\n    import httplib\n    import urlparse\n\nimport kdcproxy.codec as codec\nfrom kdcproxy.config import MetaResolver\n\n\nclass HTTPException(Exception):\n\n    def __init__(self, code, msg, headers=[]):\n        headers = list(filter(lambda h: h[0] != 'Content-Length', headers))\n\n        if 'Content-Type' not in dict(headers):\n            headers.append(('Content-Type', 'text/plain; charset=utf-8'))\n\n        if sys.version_info.major == 3 and isinstance(msg, str):\n            msg = bytes(msg, \"utf-8\")\n\n        headers.append(('Content-Length', str(len(msg))))\n\n        super(HTTPException, self).__init__(code, msg, headers)\n        self.code = code\n        self.message = msg\n        self.headers = headers\n\n    def __str__(self):\n        return \"%d %s\" % (self.code, httplib.responses[self.code])\n\n\nclass Application:\n    MAX_LENGTH = 128 * 1024\n    SOCKTYPES = {\n        \"tcp\": socket.SOCK_STREAM,\n        \"udp\": socket.SOCK_DGRAM,\n    }\n\n    def __init__(self):\n        self.__resolver = MetaResolver()\n\n    def __await_reply(self, pr, rsocks, wsocks, timeout):\n        extra = 0\n        read_buffers = {}\n        while (timeout + extra) > time.time():\n            if not wsocks and not rsocks:\n                break\n\n            r, w, x = select.select(rsocks, wsocks, rsocks + wsocks,\n                                    (timeout + extra) - time.time())\n            for sock in x:\n                sock.close()\n                try:\n                    rsocks.remove(sock)\n                except ValueError:\n                    pass\n                try:\n                    wsocks.remove(sock)\n                except ValueError:\n                    pass\n\n            for sock in w:\n                try:\n                    if self.sock_type(sock) == socket.SOCK_DGRAM:\n                        # If we proxy over UDP, remove the 4-byte length\n                        # prefix since it is TCP only.\n                        sock.sendall(pr.request[4:])\n                    else:\n                        sock.sendall(pr.request)\n                        extra = 10  # New connections get 10 extra seconds\n                except Exception:\n                    logging.exception('Error in recv() of %s', sock)\n                    continue\n                rsocks.append(sock)\n                wsocks.remove(sock)\n\n            for sock in r:\n                try:\n                    reply = self.__handle_recv(sock, read_buffers)\n                except Exception:\n                    logging.exception('Error in recv() of %s', sock)\n                    if self.sock_type(sock) == socket.SOCK_STREAM:\n                        # Remove broken TCP socket from readers\n                        rsocks.remove(sock)\n                else:\n                    if reply is not None:\n                        return reply\n\n        return None\n\n    def __handle_recv(self, sock, read_buffers):\n        if self.sock_type(sock) == socket.SOCK_DGRAM:\n            # For UDP sockets, recv() returns an entire datagram\n            # package. KDC sends one datagram as reply.\n            reply = sock.recv(1048576)\n            # If we proxy over UDP, we will be missing the 4-byte\n            # length prefix. So add it.\n            reply = struct.pack(\"!I\", len(reply)) + reply\n            return reply\n        else:\n            # TCP is a different story. The reply must be buffered\n            # until the full answer is accumulated.\n            buf = read_buffers.get(sock)\n            part = sock.recv(1048576)\n            if buf is None:\n                if len(part) > 4:\n                    # got enough data in the initial package. Now check\n                    # if we got the full package in the first run.\n                    (length, ) = struct.unpack(\"!I\", part[0:4])\n                    if length + 4 == len(part):\n                        return part\n                read_buffers[sock] = buf = io.BytesIO()\n\n            if part:\n                # data received, accumulate it in a buffer\n                buf.write(part)\n                return None\n            else:\n                # EOF received\n                read_buffers.pop(sock)\n                reply = buf.getvalue()\n                return reply\n\n    def __filter_addr(self, addr):\n        if addr[0] not in (socket.AF_INET, socket.AF_INET6):\n            return False\n\n        if addr[1] not in (socket.SOCK_STREAM, socket.SOCK_DGRAM):\n            return False\n\n        if addr[2] not in (socket.IPPROTO_TCP, socket.IPPROTO_UDP):\n            return False\n\n        return True\n\n    def sock_type(self, sock):\n        try:\n            return sock.type & ~socket.SOCK_NONBLOCK\n        except AttributeError:\n            return sock.type\n\n    def __call__(self, env, start_response):\n        try:\n            # Validate the method\n            method = env[\"REQUEST_METHOD\"].upper()\n            if method != \"POST\":\n                raise HTTPException(405, \"Method not allowed (%s).\" % method)\n\n            # Parse the request\n            try:\n                length = int(env[\"CONTENT_LENGTH\"])\n            except AttributeError:\n                raise HTTPException(411, \"Length required.\")\n            if length < 0:\n                raise HTTPException(411, \"Length required.\")\n            if length > self.MAX_LENGTH:\n                raise HTTPException(413, \"Request entity too large.\")\n            try:\n                pr = codec.decode(env[\"wsgi.input\"].read(length))\n            except codec.ParsingError as e:\n                raise HTTPException(400, e.message)\n\n            # Find the remote proxy\n            servers = self.__resolver.lookup(\n                pr.realm,\n                kpasswd=isinstance(pr, codec.KPASSWDProxyRequest)\n            )\n            if not servers:\n                raise HTTPException(503, \"Can't find remote (%s).\" % pr)\n\n            # Contact the remote server\n            reply = None\n            wsocks = []\n            rsocks = []\n            for server in map(urlparse.urlparse, servers):\n                # Enforce valid, supported URIs\n                scheme = server.scheme.lower().split(\"+\", 1)\n                if scheme[0] not in (\"kerberos\", \"kpasswd\"):\n                    continue\n                if len(scheme) > 1 and scheme[1] not in (\"tcp\", \"udp\"):\n                    continue\n\n                # Do the DNS lookup\n                try:\n                    port = server.port\n                    if port is None:\n                        port = scheme[0]\n                    addrs = socket.getaddrinfo(server.hostname, port)\n                except socket.gaierror:\n                    continue\n\n                # Sort addresses so that we get TCP first.\n                #\n                # Stick a None address on the end so we can get one\n                # more attempt after all servers have been contacted.\n                addrs = tuple(sorted(filter(self.__filter_addr, addrs)))\n                for addr in addrs + (None,):\n                    if addr is not None:\n                        # Bypass unspecified socktypes\n                        if (len(scheme) > 1\n                                and addr[1] != self.SOCKTYPES[scheme[1]]):\n                            continue\n\n                        # Create the socket\n                        sock = socket.socket(*addr[:3])\n                        sock.setblocking(0)\n\n                        # Connect\n                        try:\n                            # In Python 2.x, non-blocking connect() throws\n                            # socket.error() with errno == EINPROGRESS. In\n                            # Python 3.x, it throws io.BlockingIOError().\n                            sock.connect(addr[4])\n                        except socket.error as e:\n                            if e.errno != 115:  # errno != EINPROGRESS\n                                sock.close()\n                                continue\n                        except io.BlockingIOError:\n                            pass\n                        wsocks.append(sock)\n\n                    # Resend packets to UDP servers\n                    for sock in tuple(rsocks):\n                        if self.sock_type(sock) == socket.SOCK_DGRAM:\n                            wsocks.append(sock)\n                            rsocks.remove(sock)\n\n                    # Call select()\n                    timeout = time.time() + (15 if addr is None else 2)\n                    reply = self.__await_reply(pr, rsocks, wsocks, timeout)\n                    if reply is not None:\n                        break\n\n                if reply is not None:\n                    break\n\n            for sock in rsocks + wsocks:\n                sock.close()\n\n            if reply is None:\n                raise HTTPException(503, \"Remote unavailable (%s).\" % pr)\n\n            # Return the result to the client\n            raise HTTPException(200, codec.encode(reply),\n                                [(\"Content-Type\", \"application/kerberos\")])\n        except HTTPException as e:\n            start_response(str(e), e.headers)\n            return [e.message]\n\napplication = Application()\n"], "filenames": ["kdcproxy/__init__.py"], "buggy_code_start_loc": [63], "buggy_code_end_loc": [184], "fixing_code_start_loc": [64], "fixing_code_end_loc": [189], "type": "CWE-20", "message": "python-kdcproxy before 0.3.2 allows remote attackers to cause a denial of service via a large POST request.", "other": {"cve": {"id": "CVE-2015-5159", "sourceIdentifier": "secalert@redhat.com", "published": "2018-10-30T18:29:00.207", "lastModified": "2018-12-07T21:25:23.667", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "python-kdcproxy before 0.3.2 allows remote attackers to cause a denial of service via a large POST request."}, {"lang": "es", "value": "python-kdcproxy en versiones anteriores a la 0.3.2 permite que atacantes remotos provoquen una denegaci\u00f3n de servicio (DoS) mediante una petici\u00f3n POST grande."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:kdcproxy_project:kdcproxy:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.3.2", "matchCriteriaId": "4043CD7A-F1C0-4BCD-BAF8-5E368DAEB833"}]}]}], "references": [{"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1245200", "source": "secalert@redhat.com", "tags": ["Mitigation", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/latchset/kdcproxy/commit/f274aa6787cb8b3ec1cc12c440a56665b7231882", "source": "secalert@redhat.com", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/latchset/kdcproxy/commit/f274aa6787cb8b3ec1cc12c440a56665b7231882"}}