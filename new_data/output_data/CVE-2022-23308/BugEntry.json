{"buggy_code": ["0 1 doc 0 0\n1 14 #text 0 1 \n    \n1 1 ns:elem 1 0\n1 14 #text 0 1 \n    \n1 1 elem 0 0\n2 14 #text 0 1 \n        \n2 1 ns:elem 1 0\n2 14 #text 0 1 \n    \n1 15 elem 0 0\n1 14 #text 0 1 \n    \n1 14 #text 0 1 \n            \n1 1 ns:elem 1 0\n1 14 #text 0 1 \n        \n1 14 #text 0 1 \n\n0 15 doc 0 0\n", "/*\n * valid.c : part of the code use to do the DTD handling and the validity\n *           checking\n *\n * See Copyright for the status of this software.\n *\n * daniel@veillard.com\n */\n\n#define IN_LIBXML\n#include \"libxml.h\"\n\n#include <string.h>\n\n#ifdef HAVE_STDLIB_H\n#include <stdlib.h>\n#endif\n\n#include <libxml/xmlmemory.h>\n#include <libxml/hash.h>\n#include <libxml/uri.h>\n#include <libxml/valid.h>\n#include <libxml/parser.h>\n#include <libxml/parserInternals.h>\n#include <libxml/xmlerror.h>\n#include <libxml/list.h>\n#include <libxml/globals.h>\n\nstatic xmlElementPtr xmlGetDtdElementDesc2(xmlDtdPtr dtd, const xmlChar *name,\n\t                           int create);\n/* #define DEBUG_VALID_ALGO */\n/* #define DEBUG_REGEXP_ALGO */\n\n#define TODO\t\t\t\t\t\t\t\t\\\n    xmlGenericError(xmlGenericErrorContext,\t\t\t\t\\\n\t    \"Unimplemented block at %s:%d\\n\",\t\t\t\t\\\n            __FILE__, __LINE__);\n\n#ifdef LIBXML_VALID_ENABLED\nstatic int\nxmlValidateAttributeValueInternal(xmlDocPtr doc, xmlAttributeType type,\n                                  const xmlChar *value);\n#endif\n/************************************************************************\n *\t\t\t\t\t\t\t\t\t*\n *\t\t\tError handling routines\t\t\t\t*\n *\t\t\t\t\t\t\t\t\t*\n ************************************************************************/\n\n/**\n * xmlVErrMemory:\n * @ctxt:  an XML validation parser context\n * @extra:  extra information\n *\n * Handle an out of memory error\n */\nstatic void\nxmlVErrMemory(xmlValidCtxtPtr ctxt, const char *extra)\n{\n    xmlGenericErrorFunc channel = NULL;\n    xmlParserCtxtPtr pctxt = NULL;\n    void *data = NULL;\n\n    if (ctxt != NULL) {\n        channel = ctxt->error;\n        data = ctxt->userData;\n\t/* Use the special values to detect if it is part of a parsing\n\t   context */\n\tif ((ctxt->finishDtd == XML_CTXT_FINISH_DTD_0) ||\n\t    (ctxt->finishDtd == XML_CTXT_FINISH_DTD_1)) {\n\t    long delta = (char *) ctxt - (char *) ctxt->userData;\n\t    if ((delta > 0) && (delta < 250))\n\t\tpctxt = ctxt->userData;\n\t}\n    }\n    if (extra)\n        __xmlRaiseError(NULL, channel, data,\n                        pctxt, NULL, XML_FROM_VALID, XML_ERR_NO_MEMORY,\n                        XML_ERR_FATAL, NULL, 0, extra, NULL, NULL, 0, 0,\n                        \"Memory allocation failed : %s\\n\", extra);\n    else\n        __xmlRaiseError(NULL, channel, data,\n                        pctxt, NULL, XML_FROM_VALID, XML_ERR_NO_MEMORY,\n                        XML_ERR_FATAL, NULL, 0, NULL, NULL, NULL, 0, 0,\n                        \"Memory allocation failed\\n\");\n}\n\n/**\n * xmlErrValid:\n * @ctxt:  an XML validation parser context\n * @error:  the error number\n * @extra:  extra information\n *\n * Handle a validation error\n */\nstatic void LIBXML_ATTR_FORMAT(3,0)\nxmlErrValid(xmlValidCtxtPtr ctxt, xmlParserErrors error,\n            const char *msg, const char *extra)\n{\n    xmlGenericErrorFunc channel = NULL;\n    xmlParserCtxtPtr pctxt = NULL;\n    void *data = NULL;\n\n    if (ctxt != NULL) {\n        channel = ctxt->error;\n        data = ctxt->userData;\n\t/* Use the special values to detect if it is part of a parsing\n\t   context */\n\tif ((ctxt->finishDtd == XML_CTXT_FINISH_DTD_0) ||\n\t    (ctxt->finishDtd == XML_CTXT_FINISH_DTD_1)) {\n\t    long delta = (char *) ctxt - (char *) ctxt->userData;\n\t    if ((delta > 0) && (delta < 250))\n\t\tpctxt = ctxt->userData;\n\t}\n    }\n    if (extra)\n        __xmlRaiseError(NULL, channel, data,\n                        pctxt, NULL, XML_FROM_VALID, error,\n                        XML_ERR_ERROR, NULL, 0, extra, NULL, NULL, 0, 0,\n                        msg, extra);\n    else\n        __xmlRaiseError(NULL, channel, data,\n                        pctxt, NULL, XML_FROM_VALID, error,\n                        XML_ERR_ERROR, NULL, 0, NULL, NULL, NULL, 0, 0,\n                        \"%s\", msg);\n}\n\n#if defined(LIBXML_VALID_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)\n/**\n * xmlErrValidNode:\n * @ctxt:  an XML validation parser context\n * @node:  the node raising the error\n * @error:  the error number\n * @str1:  extra information\n * @str2:  extra information\n * @str3:  extra information\n *\n * Handle a validation error, provide contextual information\n */\nstatic void LIBXML_ATTR_FORMAT(4,0)\nxmlErrValidNode(xmlValidCtxtPtr ctxt,\n                xmlNodePtr node, xmlParserErrors error,\n                const char *msg, const xmlChar * str1,\n                const xmlChar * str2, const xmlChar * str3)\n{\n    xmlStructuredErrorFunc schannel = NULL;\n    xmlGenericErrorFunc channel = NULL;\n    xmlParserCtxtPtr pctxt = NULL;\n    void *data = NULL;\n\n    if (ctxt != NULL) {\n        channel = ctxt->error;\n        data = ctxt->userData;\n\t/* Use the special values to detect if it is part of a parsing\n\t   context */\n\tif ((ctxt->finishDtd == XML_CTXT_FINISH_DTD_0) ||\n\t    (ctxt->finishDtd == XML_CTXT_FINISH_DTD_1)) {\n\t    long delta = (char *) ctxt - (char *) ctxt->userData;\n\t    if ((delta > 0) && (delta < 250))\n\t\tpctxt = ctxt->userData;\n\t}\n    }\n    __xmlRaiseError(schannel, channel, data, pctxt, node, XML_FROM_VALID, error,\n                    XML_ERR_ERROR, NULL, 0,\n                    (const char *) str1,\n                    (const char *) str2,\n                    (const char *) str3, 0, 0, msg, str1, str2, str3);\n}\n#endif /* LIBXML_VALID_ENABLED or LIBXML_SCHEMAS_ENABLED */\n\n#ifdef LIBXML_VALID_ENABLED\n/**\n * xmlErrValidNodeNr:\n * @ctxt:  an XML validation parser context\n * @node:  the node raising the error\n * @error:  the error number\n * @str1:  extra information\n * @int2:  extra information\n * @str3:  extra information\n *\n * Handle a validation error, provide contextual information\n */\nstatic void LIBXML_ATTR_FORMAT(4,0)\nxmlErrValidNodeNr(xmlValidCtxtPtr ctxt,\n                xmlNodePtr node, xmlParserErrors error,\n                const char *msg, const xmlChar * str1,\n                int int2, const xmlChar * str3)\n{\n    xmlStructuredErrorFunc schannel = NULL;\n    xmlGenericErrorFunc channel = NULL;\n    xmlParserCtxtPtr pctxt = NULL;\n    void *data = NULL;\n\n    if (ctxt != NULL) {\n        channel = ctxt->error;\n        data = ctxt->userData;\n\t/* Use the special values to detect if it is part of a parsing\n\t   context */\n\tif ((ctxt->finishDtd == XML_CTXT_FINISH_DTD_0) ||\n\t    (ctxt->finishDtd == XML_CTXT_FINISH_DTD_1)) {\n\t    long delta = (char *) ctxt - (char *) ctxt->userData;\n\t    if ((delta > 0) && (delta < 250))\n\t\tpctxt = ctxt->userData;\n\t}\n    }\n    __xmlRaiseError(schannel, channel, data, pctxt, node, XML_FROM_VALID, error,\n                    XML_ERR_ERROR, NULL, 0,\n                    (const char *) str1,\n                    (const char *) str3,\n                    NULL, int2, 0, msg, str1, int2, str3);\n}\n\n/**\n * xmlErrValidWarning:\n * @ctxt:  an XML validation parser context\n * @node:  the node raising the error\n * @error:  the error number\n * @str1:  extra information\n * @str2:  extra information\n * @str3:  extra information\n *\n * Handle a validation error, provide contextual information\n */\nstatic void LIBXML_ATTR_FORMAT(4,0)\nxmlErrValidWarning(xmlValidCtxtPtr ctxt,\n                xmlNodePtr node, xmlParserErrors error,\n                const char *msg, const xmlChar * str1,\n                const xmlChar * str2, const xmlChar * str3)\n{\n    xmlStructuredErrorFunc schannel = NULL;\n    xmlGenericErrorFunc channel = NULL;\n    xmlParserCtxtPtr pctxt = NULL;\n    void *data = NULL;\n\n    if (ctxt != NULL) {\n        channel = ctxt->warning;\n        data = ctxt->userData;\n\t/* Use the special values to detect if it is part of a parsing\n\t   context */\n\tif ((ctxt->finishDtd == XML_CTXT_FINISH_DTD_0) ||\n\t    (ctxt->finishDtd == XML_CTXT_FINISH_DTD_1)) {\n\t    long delta = (char *) ctxt - (char *) ctxt->userData;\n\t    if ((delta > 0) && (delta < 250))\n\t\tpctxt = ctxt->userData;\n\t}\n    }\n    __xmlRaiseError(schannel, channel, data, pctxt, node, XML_FROM_VALID, error,\n                    XML_ERR_WARNING, NULL, 0,\n                    (const char *) str1,\n                    (const char *) str2,\n                    (const char *) str3, 0, 0, msg, str1, str2, str3);\n}\n\n\n\n#ifdef LIBXML_REGEXP_ENABLED\n/*\n * If regexp are enabled we can do continuous validation without the\n * need of a tree to validate the content model. this is done in each\n * callbacks.\n * Each xmlValidState represent the validation state associated to the\n * set of nodes currently open from the document root to the current element.\n */\n\n\ntypedef struct _xmlValidState {\n    xmlElementPtr\t elemDecl;\t/* pointer to the content model */\n    xmlNodePtr           node;\t\t/* pointer to the current node */\n    xmlRegExecCtxtPtr    exec;\t\t/* regexp runtime */\n} _xmlValidState;\n\n\nstatic int\nvstateVPush(xmlValidCtxtPtr ctxt, xmlElementPtr elemDecl, xmlNodePtr node) {\n    if ((ctxt->vstateMax == 0) || (ctxt->vstateTab == NULL)) {\n\tctxt->vstateMax = 10;\n\tctxt->vstateTab = (xmlValidState *) xmlMalloc(ctxt->vstateMax *\n\t\t              sizeof(ctxt->vstateTab[0]));\n        if (ctxt->vstateTab == NULL) {\n\t    xmlVErrMemory(ctxt, \"malloc failed\");\n\t    return(-1);\n\t}\n    }\n\n    if (ctxt->vstateNr >= ctxt->vstateMax) {\n        xmlValidState *tmp;\n\n\ttmp = (xmlValidState *) xmlRealloc(ctxt->vstateTab,\n\t             2 * ctxt->vstateMax * sizeof(ctxt->vstateTab[0]));\n        if (tmp == NULL) {\n\t    xmlVErrMemory(ctxt, \"realloc failed\");\n\t    return(-1);\n\t}\n\tctxt->vstateMax *= 2;\n\tctxt->vstateTab = tmp;\n    }\n    ctxt->vstate = &ctxt->vstateTab[ctxt->vstateNr];\n    ctxt->vstateTab[ctxt->vstateNr].elemDecl = elemDecl;\n    ctxt->vstateTab[ctxt->vstateNr].node = node;\n    if ((elemDecl != NULL) && (elemDecl->etype == XML_ELEMENT_TYPE_ELEMENT)) {\n\tif (elemDecl->contModel == NULL)\n\t    xmlValidBuildContentModel(ctxt, elemDecl);\n\tif (elemDecl->contModel != NULL) {\n\t    ctxt->vstateTab[ctxt->vstateNr].exec =\n\t\txmlRegNewExecCtxt(elemDecl->contModel, NULL, NULL);\n\t} else {\n\t    ctxt->vstateTab[ctxt->vstateNr].exec = NULL;\n\t    xmlErrValidNode(ctxt, (xmlNodePtr) elemDecl,\n\t                    XML_ERR_INTERNAL_ERROR,\n\t\t\t    \"Failed to build content model regexp for %s\\n\",\n\t\t\t    node->name, NULL, NULL);\n\t}\n    }\n    return(ctxt->vstateNr++);\n}\n\nstatic int\nvstateVPop(xmlValidCtxtPtr ctxt) {\n    xmlElementPtr elemDecl;\n\n    if (ctxt->vstateNr < 1) return(-1);\n    ctxt->vstateNr--;\n    elemDecl = ctxt->vstateTab[ctxt->vstateNr].elemDecl;\n    ctxt->vstateTab[ctxt->vstateNr].elemDecl = NULL;\n    ctxt->vstateTab[ctxt->vstateNr].node = NULL;\n    if ((elemDecl != NULL) && (elemDecl->etype == XML_ELEMENT_TYPE_ELEMENT)) {\n\txmlRegFreeExecCtxt(ctxt->vstateTab[ctxt->vstateNr].exec);\n    }\n    ctxt->vstateTab[ctxt->vstateNr].exec = NULL;\n    if (ctxt->vstateNr >= 1)\n\tctxt->vstate = &ctxt->vstateTab[ctxt->vstateNr - 1];\n    else\n\tctxt->vstate = NULL;\n    return(ctxt->vstateNr);\n}\n\n#else /* not LIBXML_REGEXP_ENABLED */\n/*\n * If regexp are not enabled, it uses a home made algorithm less\n * complex and easier to\n * debug/maintain than a generic NFA -> DFA state based algo. The\n * only restriction is on the deepness of the tree limited by the\n * size of the occurs bitfield\n *\n * this is the content of a saved state for rollbacks\n */\n\n#define ROLLBACK_OR\t0\n#define ROLLBACK_PARENT\t1\n\ntypedef struct _xmlValidState {\n    xmlElementContentPtr cont;\t/* pointer to the content model subtree */\n    xmlNodePtr           node;\t/* pointer to the current node in the list */\n    long                 occurs;/* bitfield for multiple occurrences */\n    unsigned char        depth; /* current depth in the overall tree */\n    unsigned char        state; /* ROLLBACK_XXX */\n} _xmlValidState;\n\n#define MAX_RECURSE 25000\n#define MAX_DEPTH ((sizeof(_xmlValidState.occurs)) * 8)\n#define CONT ctxt->vstate->cont\n#define NODE ctxt->vstate->node\n#define DEPTH ctxt->vstate->depth\n#define OCCURS ctxt->vstate->occurs\n#define STATE ctxt->vstate->state\n\n#define OCCURRENCE (ctxt->vstate->occurs & (1 << DEPTH))\n#define PARENT_OCCURRENCE (ctxt->vstate->occurs & ((1 << DEPTH) - 1))\n\n#define SET_OCCURRENCE ctxt->vstate->occurs |= (1 << DEPTH)\n#define RESET_OCCURRENCE ctxt->vstate->occurs &= ((1 << DEPTH) - 1)\n\nstatic int\nvstateVPush(xmlValidCtxtPtr ctxt, xmlElementContentPtr cont,\n\t    xmlNodePtr node, unsigned char depth, long occurs,\n\t    unsigned char state) {\n    int i = ctxt->vstateNr - 1;\n\n    if (ctxt->vstateNr > MAX_RECURSE) {\n\treturn(-1);\n    }\n    if (ctxt->vstateTab == NULL) {\n\tctxt->vstateMax = 8;\n\tctxt->vstateTab = (xmlValidState *) xmlMalloc(\n\t\t     ctxt->vstateMax * sizeof(ctxt->vstateTab[0]));\n\tif (ctxt->vstateTab == NULL) {\n\t    xmlVErrMemory(ctxt, \"malloc failed\");\n\t    return(-1);\n\t}\n    }\n    if (ctxt->vstateNr >= ctxt->vstateMax) {\n        xmlValidState *tmp;\n\n        tmp = (xmlValidState *) xmlRealloc(ctxt->vstateTab,\n\t             2 * ctxt->vstateMax * sizeof(ctxt->vstateTab[0]));\n        if (tmp == NULL) {\n\t    xmlVErrMemory(ctxt, \"malloc failed\");\n\t    return(-1);\n\t}\n\tctxt->vstateMax *= 2;\n\tctxt->vstateTab = tmp;\n\tctxt->vstate = &ctxt->vstateTab[0];\n    }\n    /*\n     * Don't push on the stack a state already here\n     */\n    if ((i >= 0) && (ctxt->vstateTab[i].cont == cont) &&\n\t(ctxt->vstateTab[i].node == node) &&\n\t(ctxt->vstateTab[i].depth == depth) &&\n\t(ctxt->vstateTab[i].occurs == occurs) &&\n\t(ctxt->vstateTab[i].state == state))\n\treturn(ctxt->vstateNr);\n    ctxt->vstateTab[ctxt->vstateNr].cont = cont;\n    ctxt->vstateTab[ctxt->vstateNr].node = node;\n    ctxt->vstateTab[ctxt->vstateNr].depth = depth;\n    ctxt->vstateTab[ctxt->vstateNr].occurs = occurs;\n    ctxt->vstateTab[ctxt->vstateNr].state = state;\n    return(ctxt->vstateNr++);\n}\n\nstatic int\nvstateVPop(xmlValidCtxtPtr ctxt) {\n    if (ctxt->vstateNr <= 1) return(-1);\n    ctxt->vstateNr--;\n    ctxt->vstate = &ctxt->vstateTab[0];\n    ctxt->vstate->cont =  ctxt->vstateTab[ctxt->vstateNr].cont;\n    ctxt->vstate->node = ctxt->vstateTab[ctxt->vstateNr].node;\n    ctxt->vstate->depth = ctxt->vstateTab[ctxt->vstateNr].depth;\n    ctxt->vstate->occurs = ctxt->vstateTab[ctxt->vstateNr].occurs;\n    ctxt->vstate->state = ctxt->vstateTab[ctxt->vstateNr].state;\n    return(ctxt->vstateNr);\n}\n\n#endif /* LIBXML_REGEXP_ENABLED */\n\nstatic int\nnodeVPush(xmlValidCtxtPtr ctxt, xmlNodePtr value)\n{\n    if (ctxt->nodeMax <= 0) {\n        ctxt->nodeMax = 4;\n        ctxt->nodeTab =\n            (xmlNodePtr *) xmlMalloc(ctxt->nodeMax *\n                                     sizeof(ctxt->nodeTab[0]));\n        if (ctxt->nodeTab == NULL) {\n\t    xmlVErrMemory(ctxt, \"malloc failed\");\n            ctxt->nodeMax = 0;\n            return (0);\n        }\n    }\n    if (ctxt->nodeNr >= ctxt->nodeMax) {\n        xmlNodePtr *tmp;\n        tmp = (xmlNodePtr *) xmlRealloc(ctxt->nodeTab,\n\t\t\t      ctxt->nodeMax * 2 * sizeof(ctxt->nodeTab[0]));\n        if (tmp == NULL) {\n\t    xmlVErrMemory(ctxt, \"realloc failed\");\n            return (0);\n        }\n        ctxt->nodeMax *= 2;\n\tctxt->nodeTab = tmp;\n    }\n    ctxt->nodeTab[ctxt->nodeNr] = value;\n    ctxt->node = value;\n    return (ctxt->nodeNr++);\n}\nstatic xmlNodePtr\nnodeVPop(xmlValidCtxtPtr ctxt)\n{\n    xmlNodePtr ret;\n\n    if (ctxt->nodeNr <= 0)\n        return (NULL);\n    ctxt->nodeNr--;\n    if (ctxt->nodeNr > 0)\n        ctxt->node = ctxt->nodeTab[ctxt->nodeNr - 1];\n    else\n        ctxt->node = NULL;\n    ret = ctxt->nodeTab[ctxt->nodeNr];\n    ctxt->nodeTab[ctxt->nodeNr] = NULL;\n    return (ret);\n}\n\n#ifdef DEBUG_VALID_ALGO\nstatic void\nxmlValidPrintNode(xmlNodePtr cur) {\n    if (cur == NULL) {\n\txmlGenericError(xmlGenericErrorContext, \"null\");\n\treturn;\n    }\n    switch (cur->type) {\n\tcase XML_ELEMENT_NODE:\n\t    xmlGenericError(xmlGenericErrorContext, \"%s \", cur->name);\n\t    break;\n\tcase XML_TEXT_NODE:\n\t    xmlGenericError(xmlGenericErrorContext, \"text \");\n\t    break;\n\tcase XML_CDATA_SECTION_NODE:\n\t    xmlGenericError(xmlGenericErrorContext, \"cdata \");\n\t    break;\n\tcase XML_ENTITY_REF_NODE:\n\t    xmlGenericError(xmlGenericErrorContext, \"&%s; \", cur->name);\n\t    break;\n\tcase XML_PI_NODE:\n\t    xmlGenericError(xmlGenericErrorContext, \"pi(%s) \", cur->name);\n\t    break;\n\tcase XML_COMMENT_NODE:\n\t    xmlGenericError(xmlGenericErrorContext, \"comment \");\n\t    break;\n\tcase XML_ATTRIBUTE_NODE:\n\t    xmlGenericError(xmlGenericErrorContext, \"?attr? \");\n\t    break;\n\tcase XML_ENTITY_NODE:\n\t    xmlGenericError(xmlGenericErrorContext, \"?ent? \");\n\t    break;\n\tcase XML_DOCUMENT_NODE:\n\t    xmlGenericError(xmlGenericErrorContext, \"?doc? \");\n\t    break;\n\tcase XML_DOCUMENT_TYPE_NODE:\n\t    xmlGenericError(xmlGenericErrorContext, \"?doctype? \");\n\t    break;\n\tcase XML_DOCUMENT_FRAG_NODE:\n\t    xmlGenericError(xmlGenericErrorContext, \"?frag? \");\n\t    break;\n\tcase XML_NOTATION_NODE:\n\t    xmlGenericError(xmlGenericErrorContext, \"?nota? \");\n\t    break;\n\tcase XML_HTML_DOCUMENT_NODE:\n\t    xmlGenericError(xmlGenericErrorContext, \"?html? \");\n\t    break;\n#ifdef LIBXML_DOCB_ENABLED\n\tcase XML_DOCB_DOCUMENT_NODE:\n\t    xmlGenericError(xmlGenericErrorContext, \"?docb? \");\n\t    break;\n#endif\n\tcase XML_DTD_NODE:\n\t    xmlGenericError(xmlGenericErrorContext, \"?dtd? \");\n\t    break;\n\tcase XML_ELEMENT_DECL:\n\t    xmlGenericError(xmlGenericErrorContext, \"?edecl? \");\n\t    break;\n\tcase XML_ATTRIBUTE_DECL:\n\t    xmlGenericError(xmlGenericErrorContext, \"?adecl? \");\n\t    break;\n\tcase XML_ENTITY_DECL:\n\t    xmlGenericError(xmlGenericErrorContext, \"?entdecl? \");\n\t    break;\n\tcase XML_NAMESPACE_DECL:\n\t    xmlGenericError(xmlGenericErrorContext, \"?nsdecl? \");\n\t    break;\n\tcase XML_XINCLUDE_START:\n\t    xmlGenericError(xmlGenericErrorContext, \"incstart \");\n\t    break;\n\tcase XML_XINCLUDE_END:\n\t    xmlGenericError(xmlGenericErrorContext, \"incend \");\n\t    break;\n    }\n}\n\nstatic void\nxmlValidPrintNodeList(xmlNodePtr cur) {\n    if (cur == NULL)\n\txmlGenericError(xmlGenericErrorContext, \"null \");\n    while (cur != NULL) {\n\txmlValidPrintNode(cur);\n\tcur = cur->next;\n    }\n}\n\nstatic void\nxmlValidDebug(xmlNodePtr cur, xmlElementContentPtr cont) {\n    char expr[5000];\n\n    expr[0] = 0;\n    xmlGenericError(xmlGenericErrorContext, \"valid: \");\n    xmlValidPrintNodeList(cur);\n    xmlGenericError(xmlGenericErrorContext, \"against \");\n    xmlSnprintfElementContent(expr, 5000, cont, 1);\n    xmlGenericError(xmlGenericErrorContext, \"%s\\n\", expr);\n}\n\nstatic void\nxmlValidDebugState(xmlValidStatePtr state) {\n    xmlGenericError(xmlGenericErrorContext, \"(\");\n    if (state->cont == NULL)\n\txmlGenericError(xmlGenericErrorContext, \"null,\");\n    else\n\tswitch (state->cont->type) {\n            case XML_ELEMENT_CONTENT_PCDATA:\n\t\txmlGenericError(xmlGenericErrorContext, \"pcdata,\");\n\t\tbreak;\n            case XML_ELEMENT_CONTENT_ELEMENT:\n\t\txmlGenericError(xmlGenericErrorContext, \"%s,\",\n\t\t\t        state->cont->name);\n\t\tbreak;\n            case XML_ELEMENT_CONTENT_SEQ:\n\t\txmlGenericError(xmlGenericErrorContext, \"seq,\");\n\t\tbreak;\n            case XML_ELEMENT_CONTENT_OR:\n\t\txmlGenericError(xmlGenericErrorContext, \"or,\");\n\t\tbreak;\n\t}\n    xmlValidPrintNode(state->node);\n    xmlGenericError(xmlGenericErrorContext, \",%d,%X,%d)\",\n\t    state->depth, state->occurs, state->state);\n}\n\nstatic void\nxmlValidStateDebug(xmlValidCtxtPtr ctxt) {\n    int i, j;\n\n    xmlGenericError(xmlGenericErrorContext, \"state: \");\n    xmlValidDebugState(ctxt->vstate);\n    xmlGenericError(xmlGenericErrorContext, \" stack: %d \",\n\t    ctxt->vstateNr - 1);\n    for (i = 0, j = ctxt->vstateNr - 1;(i < 3) && (j > 0);i++,j--)\n\txmlValidDebugState(&ctxt->vstateTab[j]);\n    xmlGenericError(xmlGenericErrorContext, \"\\n\");\n}\n\n/*****\n#define DEBUG_VALID_STATE(n,c) xmlValidDebug(n,c);\n *****/\n\n#define DEBUG_VALID_STATE(n,c) xmlValidStateDebug(ctxt);\n#define DEBUG_VALID_MSG(m)\t\t\t\t\t\\\n    xmlGenericError(xmlGenericErrorContext, \"%s\\n\", m);\n\n#else\n#define DEBUG_VALID_STATE(n,c)\n#define DEBUG_VALID_MSG(m)\n#endif\n\n/* TODO: use hash table for accesses to elem and attribute definitions */\n\n\n#define CHECK_DTD\t\t\t\t\t\t\\\n   if (doc == NULL) return(0);\t\t\t\t\t\\\n   else if ((doc->intSubset == NULL) &&\t\t\t\t\\\n\t    (doc->extSubset == NULL)) return(0)\n\n#ifdef LIBXML_REGEXP_ENABLED\n\n/************************************************************************\n *\t\t\t\t\t\t\t\t\t*\n *\t\tContent model validation based on the regexps\t\t*\n *\t\t\t\t\t\t\t\t\t*\n ************************************************************************/\n\n/**\n * xmlValidBuildAContentModel:\n * @content:  the content model\n * @ctxt:  the schema parser context\n * @name:  the element name whose content is being built\n *\n * Generate the automata sequence needed for that type\n *\n * Returns 1 if successful or 0 in case of error.\n */\nstatic int\nxmlValidBuildAContentModel(xmlElementContentPtr content,\n\t\t           xmlValidCtxtPtr ctxt,\n\t\t           const xmlChar *name) {\n    if (content == NULL) {\n\txmlErrValidNode(ctxt, NULL, XML_ERR_INTERNAL_ERROR,\n\t\t\t\"Found NULL content in content model of %s\\n\",\n\t\t\tname, NULL, NULL);\n\treturn(0);\n    }\n    switch (content->type) {\n\tcase XML_ELEMENT_CONTENT_PCDATA:\n\t    xmlErrValidNode(ctxt, NULL, XML_ERR_INTERNAL_ERROR,\n\t\t\t    \"Found PCDATA in content model of %s\\n\",\n\t\t            name, NULL, NULL);\n\t    return(0);\n\t    break;\n\tcase XML_ELEMENT_CONTENT_ELEMENT: {\n\t    xmlAutomataStatePtr oldstate = ctxt->state;\n\t    xmlChar fn[50];\n\t    xmlChar *fullname;\n\n\t    fullname = xmlBuildQName(content->name, content->prefix, fn, 50);\n\t    if (fullname == NULL) {\n\t        xmlVErrMemory(ctxt, \"Building content model\");\n\t\treturn(0);\n\t    }\n\n\t    switch (content->ocur) {\n\t\tcase XML_ELEMENT_CONTENT_ONCE:\n\t\t    ctxt->state = xmlAutomataNewTransition(ctxt->am,\n\t\t\t    ctxt->state, NULL, fullname, NULL);\n\t\t    break;\n\t\tcase XML_ELEMENT_CONTENT_OPT:\n\t\t    ctxt->state = xmlAutomataNewTransition(ctxt->am,\n\t\t\t    ctxt->state, NULL, fullname, NULL);\n\t\t    xmlAutomataNewEpsilon(ctxt->am, oldstate, ctxt->state);\n\t\t    break;\n\t\tcase XML_ELEMENT_CONTENT_PLUS:\n\t\t    ctxt->state = xmlAutomataNewTransition(ctxt->am,\n\t\t\t    ctxt->state, NULL, fullname, NULL);\n\t\t    xmlAutomataNewTransition(ctxt->am, ctxt->state,\n\t\t\t                     ctxt->state, fullname, NULL);\n\t\t    break;\n\t\tcase XML_ELEMENT_CONTENT_MULT:\n\t\t    ctxt->state = xmlAutomataNewEpsilon(ctxt->am,\n\t\t\t\t\t    ctxt->state, NULL);\n\t\t    xmlAutomataNewTransition(ctxt->am,\n\t\t\t    ctxt->state, ctxt->state, fullname, NULL);\n\t\t    break;\n\t    }\n\t    if ((fullname != fn) && (fullname != content->name))\n\t\txmlFree(fullname);\n\t    break;\n\t}\n\tcase XML_ELEMENT_CONTENT_SEQ: {\n\t    xmlAutomataStatePtr oldstate, oldend;\n\t    xmlElementContentOccur ocur;\n\n\t    /*\n\t     * Simply iterate over the content\n\t     */\n\t    oldstate = ctxt->state;\n\t    ocur = content->ocur;\n\t    if (ocur != XML_ELEMENT_CONTENT_ONCE) {\n\t\tctxt->state = xmlAutomataNewEpsilon(ctxt->am, oldstate, NULL);\n\t\toldstate = ctxt->state;\n\t    }\n\t    do {\n\t\txmlValidBuildAContentModel(content->c1, ctxt, name);\n\t\tcontent = content->c2;\n\t    } while ((content->type == XML_ELEMENT_CONTENT_SEQ) &&\n\t\t     (content->ocur == XML_ELEMENT_CONTENT_ONCE));\n\t    xmlValidBuildAContentModel(content, ctxt, name);\n\t    oldend = ctxt->state;\n\t    ctxt->state = xmlAutomataNewEpsilon(ctxt->am, oldend, NULL);\n\t    switch (ocur) {\n\t\tcase XML_ELEMENT_CONTENT_ONCE:\n\t\t    break;\n\t\tcase XML_ELEMENT_CONTENT_OPT:\n\t\t    xmlAutomataNewEpsilon(ctxt->am, oldstate, ctxt->state);\n\t\t    break;\n\t\tcase XML_ELEMENT_CONTENT_MULT:\n\t\t    xmlAutomataNewEpsilon(ctxt->am, oldstate, ctxt->state);\n\t\t    xmlAutomataNewEpsilon(ctxt->am, oldend, oldstate);\n\t\t    break;\n\t\tcase XML_ELEMENT_CONTENT_PLUS:\n\t\t    xmlAutomataNewEpsilon(ctxt->am, oldend, oldstate);\n\t\t    break;\n\t    }\n\t    break;\n\t}\n\tcase XML_ELEMENT_CONTENT_OR: {\n\t    xmlAutomataStatePtr oldstate, oldend;\n\t    xmlElementContentOccur ocur;\n\n\t    ocur = content->ocur;\n\t    if ((ocur == XML_ELEMENT_CONTENT_PLUS) ||\n\t\t(ocur == XML_ELEMENT_CONTENT_MULT)) {\n\t\tctxt->state = xmlAutomataNewEpsilon(ctxt->am,\n\t\t\tctxt->state, NULL);\n\t    }\n\t    oldstate = ctxt->state;\n\t    oldend = xmlAutomataNewState(ctxt->am);\n\n\t    /*\n\t     * iterate over the subtypes and remerge the end with an\n\t     * epsilon transition\n\t     */\n\t    do {\n\t\tctxt->state = oldstate;\n\t\txmlValidBuildAContentModel(content->c1, ctxt, name);\n\t\txmlAutomataNewEpsilon(ctxt->am, ctxt->state, oldend);\n\t\tcontent = content->c2;\n\t    } while ((content->type == XML_ELEMENT_CONTENT_OR) &&\n\t\t     (content->ocur == XML_ELEMENT_CONTENT_ONCE));\n\t    ctxt->state = oldstate;\n\t    xmlValidBuildAContentModel(content, ctxt, name);\n\t    xmlAutomataNewEpsilon(ctxt->am, ctxt->state, oldend);\n\t    ctxt->state = xmlAutomataNewEpsilon(ctxt->am, oldend, NULL);\n\t    switch (ocur) {\n\t\tcase XML_ELEMENT_CONTENT_ONCE:\n\t\t    break;\n\t\tcase XML_ELEMENT_CONTENT_OPT:\n\t\t    xmlAutomataNewEpsilon(ctxt->am, oldstate, ctxt->state);\n\t\t    break;\n\t\tcase XML_ELEMENT_CONTENT_MULT:\n\t\t    xmlAutomataNewEpsilon(ctxt->am, oldstate, ctxt->state);\n\t\t    xmlAutomataNewEpsilon(ctxt->am, oldend, oldstate);\n\t\t    break;\n\t\tcase XML_ELEMENT_CONTENT_PLUS:\n\t\t    xmlAutomataNewEpsilon(ctxt->am, oldend, oldstate);\n\t\t    break;\n\t    }\n\t    break;\n\t}\n\tdefault:\n\t    xmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,\n\t                \"ContentModel broken for element %s\\n\",\n\t\t\t(const char *) name);\n\t    return(0);\n    }\n    return(1);\n}\n/**\n * xmlValidBuildContentModel:\n * @ctxt:  a validation context\n * @elem:  an element declaration node\n *\n * (Re)Build the automata associated to the content model of this\n * element\n *\n * Returns 1 in case of success, 0 in case of error\n */\nint\nxmlValidBuildContentModel(xmlValidCtxtPtr ctxt, xmlElementPtr elem) {\n\n    if ((ctxt == NULL) || (elem == NULL))\n\treturn(0);\n    if (elem->type != XML_ELEMENT_DECL)\n\treturn(0);\n    if (elem->etype != XML_ELEMENT_TYPE_ELEMENT)\n\treturn(1);\n    /* TODO: should we rebuild in this case ? */\n    if (elem->contModel != NULL) {\n\tif (!xmlRegexpIsDeterminist(elem->contModel)) {\n\t    ctxt->valid = 0;\n\t    return(0);\n\t}\n\treturn(1);\n    }\n\n    ctxt->am = xmlNewAutomata();\n    if (ctxt->am == NULL) {\n\txmlErrValidNode(ctxt, (xmlNodePtr) elem,\n\t                XML_ERR_INTERNAL_ERROR,\n\t                \"Cannot create automata for element %s\\n\",\n\t\t        elem->name, NULL, NULL);\n\treturn(0);\n    }\n    ctxt->state = xmlAutomataGetInitState(ctxt->am);\n    xmlValidBuildAContentModel(elem->content, ctxt, elem->name);\n    xmlAutomataSetFinalState(ctxt->am, ctxt->state);\n    elem->contModel = xmlAutomataCompile(ctxt->am);\n    if (xmlRegexpIsDeterminist(elem->contModel) != 1) {\n\tchar expr[5000];\n\texpr[0] = 0;\n\txmlSnprintfElementContent(expr, 5000, elem->content, 1);\n\txmlErrValidNode(ctxt, (xmlNodePtr) elem,\n\t                XML_DTD_CONTENT_NOT_DETERMINIST,\n\t       \"Content model of %s is not determinist: %s\\n\",\n\t       elem->name, BAD_CAST expr, NULL);\n#ifdef DEBUG_REGEXP_ALGO\n        xmlRegexpPrint(stderr, elem->contModel);\n#endif\n        ctxt->valid = 0;\n\tctxt->state = NULL;\n\txmlFreeAutomata(ctxt->am);\n\tctxt->am = NULL;\n\treturn(0);\n    }\n    ctxt->state = NULL;\n    xmlFreeAutomata(ctxt->am);\n    ctxt->am = NULL;\n    return(1);\n}\n\n#endif /* LIBXML_REGEXP_ENABLED */\n\n/****************************************************************\n *\t\t\t\t\t\t\t\t*\n *\tUtil functions for data allocation/deallocation\t\t*\n *\t\t\t\t\t\t\t\t*\n ****************************************************************/\n\n/**\n * xmlNewValidCtxt:\n *\n * Allocate a validation context structure.\n *\n * Returns NULL if not, otherwise the new validation context structure\n */\nxmlValidCtxtPtr xmlNewValidCtxt(void) {\n    xmlValidCtxtPtr ret;\n\n    if ((ret = xmlMalloc(sizeof (xmlValidCtxt))) == NULL) {\n\txmlVErrMemory(NULL, \"malloc failed\");\n\treturn (NULL);\n    }\n\n    (void) memset(ret, 0, sizeof (xmlValidCtxt));\n\n    return (ret);\n}\n\n/**\n * xmlFreeValidCtxt:\n * @cur:  the validation context to free\n *\n * Free a validation context structure.\n */\nvoid\nxmlFreeValidCtxt(xmlValidCtxtPtr cur) {\n    if (cur->vstateTab != NULL)\n        xmlFree(cur->vstateTab);\n    if (cur->nodeTab != NULL)\n        xmlFree(cur->nodeTab);\n    xmlFree(cur);\n}\n\n#endif /* LIBXML_VALID_ENABLED */\n\n/**\n * xmlNewDocElementContent:\n * @doc:  the document\n * @name:  the subelement name or NULL\n * @type:  the type of element content decl\n *\n * Allocate an element content structure for the document.\n *\n * Returns NULL if not, otherwise the new element content structure\n */\nxmlElementContentPtr\nxmlNewDocElementContent(xmlDocPtr doc, const xmlChar *name,\n                        xmlElementContentType type) {\n    xmlElementContentPtr ret;\n    xmlDictPtr dict = NULL;\n\n    if (doc != NULL)\n        dict = doc->dict;\n\n    switch(type) {\n\tcase XML_ELEMENT_CONTENT_ELEMENT:\n\t    if (name == NULL) {\n\t        xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\n\t\t\t\"xmlNewElementContent : name == NULL !\\n\",\n\t\t\tNULL);\n\t    }\n\t    break;\n        case XML_ELEMENT_CONTENT_PCDATA:\n\tcase XML_ELEMENT_CONTENT_SEQ:\n\tcase XML_ELEMENT_CONTENT_OR:\n\t    if (name != NULL) {\n\t        xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\n\t\t\t\"xmlNewElementContent : name != NULL !\\n\",\n\t\t\tNULL);\n\t    }\n\t    break;\n\tdefault:\n\t    xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\n\t\t    \"Internal: ELEMENT content corrupted invalid type\\n\",\n\t\t    NULL);\n\t    return(NULL);\n    }\n    ret = (xmlElementContentPtr) xmlMalloc(sizeof(xmlElementContent));\n    if (ret == NULL) {\n\txmlVErrMemory(NULL, \"malloc failed\");\n\treturn(NULL);\n    }\n    memset(ret, 0, sizeof(xmlElementContent));\n    ret->type = type;\n    ret->ocur = XML_ELEMENT_CONTENT_ONCE;\n    if (name != NULL) {\n        int l;\n\tconst xmlChar *tmp;\n\n\ttmp = xmlSplitQName3(name, &l);\n\tif (tmp == NULL) {\n\t    if (dict == NULL)\n\t\tret->name = xmlStrdup(name);\n\t    else\n\t        ret->name = xmlDictLookup(dict, name, -1);\n\t} else {\n\t    if (dict == NULL) {\n\t\tret->prefix = xmlStrndup(name, l);\n\t\tret->name = xmlStrdup(tmp);\n\t    } else {\n\t        ret->prefix = xmlDictLookup(dict, name, l);\n\t\tret->name = xmlDictLookup(dict, tmp, -1);\n\t    }\n\t}\n    }\n    return(ret);\n}\n\n/**\n * xmlNewElementContent:\n * @name:  the subelement name or NULL\n * @type:  the type of element content decl\n *\n * Allocate an element content structure.\n * Deprecated in favor of xmlNewDocElementContent\n *\n * Returns NULL if not, otherwise the new element content structure\n */\nxmlElementContentPtr\nxmlNewElementContent(const xmlChar *name, xmlElementContentType type) {\n    return(xmlNewDocElementContent(NULL, name, type));\n}\n\n/**\n * xmlCopyDocElementContent:\n * @doc:  the document owning the element declaration\n * @cur:  An element content pointer.\n *\n * Build a copy of an element content description.\n *\n * Returns the new xmlElementContentPtr or NULL in case of error.\n */\nxmlElementContentPtr\nxmlCopyDocElementContent(xmlDocPtr doc, xmlElementContentPtr cur) {\n    xmlElementContentPtr ret = NULL, prev = NULL, tmp;\n    xmlDictPtr dict = NULL;\n\n    if (cur == NULL) return(NULL);\n\n    if (doc != NULL)\n        dict = doc->dict;\n\n    ret = (xmlElementContentPtr) xmlMalloc(sizeof(xmlElementContent));\n    if (ret == NULL) {\n\txmlVErrMemory(NULL, \"malloc failed\");\n\treturn(NULL);\n    }\n    memset(ret, 0, sizeof(xmlElementContent));\n    ret->type = cur->type;\n    ret->ocur = cur->ocur;\n    if (cur->name != NULL) {\n\tif (dict)\n\t    ret->name = xmlDictLookup(dict, cur->name, -1);\n\telse\n\t    ret->name = xmlStrdup(cur->name);\n    }\n\n    if (cur->prefix != NULL) {\n\tif (dict)\n\t    ret->prefix = xmlDictLookup(dict, cur->prefix, -1);\n\telse\n\t    ret->prefix = xmlStrdup(cur->prefix);\n    }\n    if (cur->c1 != NULL)\n        ret->c1 = xmlCopyDocElementContent(doc, cur->c1);\n    if (ret->c1 != NULL)\n\tret->c1->parent = ret;\n    if (cur->c2 != NULL) {\n        prev = ret;\n\tcur = cur->c2;\n\twhile (cur != NULL) {\n\t    tmp = (xmlElementContentPtr) xmlMalloc(sizeof(xmlElementContent));\n\t    if (tmp == NULL) {\n\t\txmlVErrMemory(NULL, \"malloc failed\");\n\t\treturn(ret);\n\t    }\n\t    memset(tmp, 0, sizeof(xmlElementContent));\n\t    tmp->type = cur->type;\n\t    tmp->ocur = cur->ocur;\n\t    prev->c2 = tmp;\n\t    if (cur->name != NULL) {\n\t\tif (dict)\n\t\t    tmp->name = xmlDictLookup(dict, cur->name, -1);\n\t\telse\n\t\t    tmp->name = xmlStrdup(cur->name);\n\t    }\n\n\t    if (cur->prefix != NULL) {\n\t\tif (dict)\n\t\t    tmp->prefix = xmlDictLookup(dict, cur->prefix, -1);\n\t\telse\n\t\t    tmp->prefix = xmlStrdup(cur->prefix);\n\t    }\n\t    if (cur->c1 != NULL)\n\t        tmp->c1 = xmlCopyDocElementContent(doc,cur->c1);\n\t    if (tmp->c1 != NULL)\n\t\ttmp->c1->parent = ret;\n\t    prev = tmp;\n\t    cur = cur->c2;\n\t}\n    }\n    return(ret);\n}\n\n/**\n * xmlCopyElementContent:\n * @cur:  An element content pointer.\n *\n * Build a copy of an element content description.\n * Deprecated, use xmlCopyDocElementContent instead\n *\n * Returns the new xmlElementContentPtr or NULL in case of error.\n */\nxmlElementContentPtr\nxmlCopyElementContent(xmlElementContentPtr cur) {\n    return(xmlCopyDocElementContent(NULL, cur));\n}\n\n/**\n * xmlFreeDocElementContent:\n * @doc: the document owning the element declaration\n * @cur:  the element content tree to free\n *\n * Free an element content structure. The whole subtree is removed.\n */\nvoid\nxmlFreeDocElementContent(xmlDocPtr doc, xmlElementContentPtr cur) {\n    xmlDictPtr dict = NULL;\n    size_t depth = 0;\n\n    if (cur == NULL)\n        return;\n    if (doc != NULL)\n        dict = doc->dict;\n\n    while (1) {\n        xmlElementContentPtr parent;\n\n        while ((cur->c1 != NULL) || (cur->c2 != NULL)) {\n            cur = (cur->c1 != NULL) ? cur->c1 : cur->c2;\n            depth += 1;\n        }\n\n\tswitch (cur->type) {\n\t    case XML_ELEMENT_CONTENT_PCDATA:\n\t    case XML_ELEMENT_CONTENT_ELEMENT:\n\t    case XML_ELEMENT_CONTENT_SEQ:\n\t    case XML_ELEMENT_CONTENT_OR:\n\t\tbreak;\n\t    default:\n\t\txmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\n\t\t\t\"Internal: ELEMENT content corrupted invalid type\\n\",\n\t\t\tNULL);\n\t\treturn;\n\t}\n\tif (dict) {\n\t    if ((cur->name != NULL) && (!xmlDictOwns(dict, cur->name)))\n\t        xmlFree((xmlChar *) cur->name);\n\t    if ((cur->prefix != NULL) && (!xmlDictOwns(dict, cur->prefix)))\n\t        xmlFree((xmlChar *) cur->prefix);\n\t} else {\n\t    if (cur->name != NULL) xmlFree((xmlChar *) cur->name);\n\t    if (cur->prefix != NULL) xmlFree((xmlChar *) cur->prefix);\n\t}\n        parent = cur->parent;\n        if ((depth == 0) || (parent == NULL)) {\n            xmlFree(cur);\n            break;\n        }\n        if (cur == parent->c1)\n            parent->c1 = NULL;\n        else\n            parent->c2 = NULL;\n\txmlFree(cur);\n\n        if (parent->c2 != NULL) {\n\t    cur = parent->c2;\n        } else {\n            depth -= 1;\n            cur = parent;\n        }\n    }\n}\n\n/**\n * xmlFreeElementContent:\n * @cur:  the element content tree to free\n *\n * Free an element content structure. The whole subtree is removed.\n * Deprecated, use xmlFreeDocElementContent instead\n */\nvoid\nxmlFreeElementContent(xmlElementContentPtr cur) {\n    xmlFreeDocElementContent(NULL, cur);\n}\n\n#ifdef LIBXML_OUTPUT_ENABLED\n/**\n * xmlDumpElementOccur:\n * @buf:  An XML buffer\n * @cur:  An element table\n *\n * Dump the occurrence operator of an element.\n */\nstatic void\nxmlDumpElementOccur(xmlBufferPtr buf, xmlElementContentPtr cur) {\n    switch (cur->ocur) {\n        case XML_ELEMENT_CONTENT_ONCE:\n            break;\n        case XML_ELEMENT_CONTENT_OPT:\n            xmlBufferWriteChar(buf, \"?\");\n            break;\n        case XML_ELEMENT_CONTENT_MULT:\n            xmlBufferWriteChar(buf, \"*\");\n            break;\n        case XML_ELEMENT_CONTENT_PLUS:\n            xmlBufferWriteChar(buf, \"+\");\n            break;\n    }\n}\n\n/**\n * xmlDumpElementContent:\n * @buf:  An XML buffer\n * @content:  An element table\n *\n * This will dump the content of the element table as an XML DTD definition\n */\nstatic void\nxmlDumpElementContent(xmlBufferPtr buf, xmlElementContentPtr content) {\n    xmlElementContentPtr cur;\n\n    if (content == NULL) return;\n\n    xmlBufferWriteChar(buf, \"(\");\n    cur = content;\n\n    do {\n        if (cur == NULL) return;\n\n        switch (cur->type) {\n            case XML_ELEMENT_CONTENT_PCDATA:\n                xmlBufferWriteChar(buf, \"#PCDATA\");\n                break;\n            case XML_ELEMENT_CONTENT_ELEMENT:\n                if (cur->prefix != NULL) {\n                    xmlBufferWriteCHAR(buf, cur->prefix);\n                    xmlBufferWriteChar(buf, \":\");\n                }\n                xmlBufferWriteCHAR(buf, cur->name);\n                break;\n            case XML_ELEMENT_CONTENT_SEQ:\n            case XML_ELEMENT_CONTENT_OR:\n                if ((cur != content) &&\n                    (cur->parent != NULL) &&\n                    ((cur->type != cur->parent->type) ||\n                     (cur->ocur != XML_ELEMENT_CONTENT_ONCE)))\n                    xmlBufferWriteChar(buf, \"(\");\n                cur = cur->c1;\n                continue;\n            default:\n                xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\n                        \"Internal: ELEMENT cur corrupted invalid type\\n\",\n                        NULL);\n        }\n\n        while (cur != content) {\n            xmlElementContentPtr parent = cur->parent;\n\n            if (parent == NULL) return;\n\n            if (((cur->type == XML_ELEMENT_CONTENT_OR) ||\n                 (cur->type == XML_ELEMENT_CONTENT_SEQ)) &&\n                ((cur->type != parent->type) ||\n                 (cur->ocur != XML_ELEMENT_CONTENT_ONCE)))\n                xmlBufferWriteChar(buf, \")\");\n            xmlDumpElementOccur(buf, cur);\n\n            if (cur == parent->c1) {\n                if (parent->type == XML_ELEMENT_CONTENT_SEQ)\n                    xmlBufferWriteChar(buf, \" , \");\n                else if (parent->type == XML_ELEMENT_CONTENT_OR)\n                    xmlBufferWriteChar(buf, \" | \");\n\n                cur = parent->c2;\n                break;\n            }\n\n            cur = parent;\n        }\n    } while (cur != content);\n\n    xmlBufferWriteChar(buf, \")\");\n    xmlDumpElementOccur(buf, content);\n}\n\n/**\n * xmlSprintfElementContent:\n * @buf:  an output buffer\n * @content:  An element table\n * @englob: 1 if one must print the englobing parenthesis, 0 otherwise\n *\n * Deprecated, unsafe, use xmlSnprintfElementContent\n */\nvoid\nxmlSprintfElementContent(char *buf ATTRIBUTE_UNUSED,\n\t                 xmlElementContentPtr content ATTRIBUTE_UNUSED,\n\t\t\t int englob ATTRIBUTE_UNUSED) {\n}\n#endif /* LIBXML_OUTPUT_ENABLED */\n\n/**\n * xmlSnprintfElementContent:\n * @buf:  an output buffer\n * @size:  the buffer size\n * @content:  An element table\n * @englob: 1 if one must print the englobing parenthesis, 0 otherwise\n *\n * This will dump the content of the element content definition\n * Intended just for the debug routine\n */\nvoid\nxmlSnprintfElementContent(char *buf, int size, xmlElementContentPtr content, int englob) {\n    int len;\n\n    if (content == NULL) return;\n    len = strlen(buf);\n    if (size - len < 50) {\n\tif ((size - len > 4) && (buf[len - 1] != '.'))\n\t    strcat(buf, \" ...\");\n\treturn;\n    }\n    if (englob) strcat(buf, \"(\");\n    switch (content->type) {\n        case XML_ELEMENT_CONTENT_PCDATA:\n            strcat(buf, \"#PCDATA\");\n\t    break;\n\tcase XML_ELEMENT_CONTENT_ELEMENT: {\n            int qnameLen = xmlStrlen(content->name);\n\n\t    if (content->prefix != NULL)\n                qnameLen += xmlStrlen(content->prefix) + 1;\n\t    if (size - len < qnameLen + 10) {\n\t\tstrcat(buf, \" ...\");\n\t\treturn;\n\t    }\n\t    if (content->prefix != NULL) {\n\t\tstrcat(buf, (char *) content->prefix);\n\t\tstrcat(buf, \":\");\n\t    }\n\t    if (content->name != NULL)\n\t\tstrcat(buf, (char *) content->name);\n\t    break;\n        }\n\tcase XML_ELEMENT_CONTENT_SEQ:\n\t    if ((content->c1->type == XML_ELEMENT_CONTENT_OR) ||\n\t        (content->c1->type == XML_ELEMENT_CONTENT_SEQ))\n\t\txmlSnprintfElementContent(buf, size, content->c1, 1);\n\t    else\n\t\txmlSnprintfElementContent(buf, size, content->c1, 0);\n\t    len = strlen(buf);\n\t    if (size - len < 50) {\n\t\tif ((size - len > 4) && (buf[len - 1] != '.'))\n\t\t    strcat(buf, \" ...\");\n\t\treturn;\n\t    }\n            strcat(buf, \" , \");\n\t    if (((content->c2->type == XML_ELEMENT_CONTENT_OR) ||\n\t\t (content->c2->ocur != XML_ELEMENT_CONTENT_ONCE)) &&\n\t\t(content->c2->type != XML_ELEMENT_CONTENT_ELEMENT))\n\t\txmlSnprintfElementContent(buf, size, content->c2, 1);\n\t    else\n\t\txmlSnprintfElementContent(buf, size, content->c2, 0);\n\t    break;\n\tcase XML_ELEMENT_CONTENT_OR:\n\t    if ((content->c1->type == XML_ELEMENT_CONTENT_OR) ||\n\t        (content->c1->type == XML_ELEMENT_CONTENT_SEQ))\n\t\txmlSnprintfElementContent(buf, size, content->c1, 1);\n\t    else\n\t\txmlSnprintfElementContent(buf, size, content->c1, 0);\n\t    len = strlen(buf);\n\t    if (size - len < 50) {\n\t\tif ((size - len > 4) && (buf[len - 1] != '.'))\n\t\t    strcat(buf, \" ...\");\n\t\treturn;\n\t    }\n            strcat(buf, \" | \");\n\t    if (((content->c2->type == XML_ELEMENT_CONTENT_SEQ) ||\n\t\t (content->c2->ocur != XML_ELEMENT_CONTENT_ONCE)) &&\n\t\t(content->c2->type != XML_ELEMENT_CONTENT_ELEMENT))\n\t\txmlSnprintfElementContent(buf, size, content->c2, 1);\n\t    else\n\t\txmlSnprintfElementContent(buf, size, content->c2, 0);\n\t    break;\n    }\n    if (size - strlen(buf) <= 2) return;\n    if (englob)\n        strcat(buf, \")\");\n    switch (content->ocur) {\n        case XML_ELEMENT_CONTENT_ONCE:\n\t    break;\n        case XML_ELEMENT_CONTENT_OPT:\n\t    strcat(buf, \"?\");\n\t    break;\n        case XML_ELEMENT_CONTENT_MULT:\n\t    strcat(buf, \"*\");\n\t    break;\n        case XML_ELEMENT_CONTENT_PLUS:\n\t    strcat(buf, \"+\");\n\t    break;\n    }\n}\n\n/****************************************************************\n *\t\t\t\t\t\t\t\t*\n *\tRegistration of DTD declarations\t\t\t*\n *\t\t\t\t\t\t\t\t*\n ****************************************************************/\n\n/**\n * xmlFreeElement:\n * @elem:  An element\n *\n * Deallocate the memory used by an element definition\n */\nstatic void\nxmlFreeElement(xmlElementPtr elem) {\n    if (elem == NULL) return;\n    xmlUnlinkNode((xmlNodePtr) elem);\n    xmlFreeDocElementContent(elem->doc, elem->content);\n    if (elem->name != NULL)\n\txmlFree((xmlChar *) elem->name);\n    if (elem->prefix != NULL)\n\txmlFree((xmlChar *) elem->prefix);\n#ifdef LIBXML_REGEXP_ENABLED\n    if (elem->contModel != NULL)\n\txmlRegFreeRegexp(elem->contModel);\n#endif\n    xmlFree(elem);\n}\n\n\n/**\n * xmlAddElementDecl:\n * @ctxt:  the validation context\n * @dtd:  pointer to the DTD\n * @name:  the entity name\n * @type:  the element type\n * @content:  the element content tree or NULL\n *\n * Register a new element declaration\n *\n * Returns NULL if not, otherwise the entity\n */\nxmlElementPtr\nxmlAddElementDecl(xmlValidCtxtPtr ctxt,\n                  xmlDtdPtr dtd, const xmlChar *name,\n                  xmlElementTypeVal type,\n\t\t  xmlElementContentPtr content) {\n    xmlElementPtr ret;\n    xmlElementTablePtr table;\n    xmlAttributePtr oldAttributes = NULL;\n    xmlChar *ns, *uqname;\n\n    if (dtd == NULL) {\n\treturn(NULL);\n    }\n    if (name == NULL) {\n\treturn(NULL);\n    }\n\n    switch (type) {\n        case XML_ELEMENT_TYPE_EMPTY:\n\t    if (content != NULL) {\n\t\txmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,\n\t\t        \"xmlAddElementDecl: content != NULL for EMPTY\\n\",\n\t\t\tNULL);\n\t\treturn(NULL);\n\t    }\n\t    break;\n\tcase XML_ELEMENT_TYPE_ANY:\n\t    if (content != NULL) {\n\t\txmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,\n\t\t        \"xmlAddElementDecl: content != NULL for ANY\\n\",\n\t\t\tNULL);\n\t\treturn(NULL);\n\t    }\n\t    break;\n\tcase XML_ELEMENT_TYPE_MIXED:\n\t    if (content == NULL) {\n\t\txmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,\n\t\t        \"xmlAddElementDecl: content == NULL for MIXED\\n\",\n\t\t\tNULL);\n\t\treturn(NULL);\n\t    }\n\t    break;\n\tcase XML_ELEMENT_TYPE_ELEMENT:\n\t    if (content == NULL) {\n\t\txmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,\n\t\t        \"xmlAddElementDecl: content == NULL for ELEMENT\\n\",\n\t\t\tNULL);\n\t\treturn(NULL);\n\t    }\n\t    break;\n\tdefault:\n\t    xmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,\n\t\t    \"Internal: ELEMENT decl corrupted invalid type\\n\",\n\t\t    NULL);\n\t    return(NULL);\n    }\n\n    /*\n     * check if name is a QName\n     */\n    uqname = xmlSplitQName2(name, &ns);\n    if (uqname != NULL)\n\tname = uqname;\n\n    /*\n     * Create the Element table if needed.\n     */\n    table = (xmlElementTablePtr) dtd->elements;\n    if (table == NULL) {\n\txmlDictPtr dict = NULL;\n\n\tif (dtd->doc != NULL)\n\t    dict = dtd->doc->dict;\n        table = xmlHashCreateDict(0, dict);\n\tdtd->elements = (void *) table;\n    }\n    if (table == NULL) {\n\txmlVErrMemory(ctxt,\n            \"xmlAddElementDecl: Table creation failed!\\n\");\n\tif (uqname != NULL)\n\t    xmlFree(uqname);\n\tif (ns != NULL)\n\t    xmlFree(ns);\n        return(NULL);\n    }\n\n    /*\n     * lookup old attributes inserted on an undefined element in the\n     * internal subset.\n     */\n    if ((dtd->doc != NULL) && (dtd->doc->intSubset != NULL)) {\n\tret = xmlHashLookup2(dtd->doc->intSubset->elements, name, ns);\n\tif ((ret != NULL) && (ret->etype == XML_ELEMENT_TYPE_UNDEFINED)) {\n\t    oldAttributes = ret->attributes;\n\t    ret->attributes = NULL;\n\t    xmlHashRemoveEntry2(dtd->doc->intSubset->elements, name, ns, NULL);\n\t    xmlFreeElement(ret);\n\t}\n    }\n\n    /*\n     * The element may already be present if one of its attribute\n     * was registered first\n     */\n    ret = xmlHashLookup2(table, name, ns);\n    if (ret != NULL) {\n\tif (ret->etype != XML_ELEMENT_TYPE_UNDEFINED) {\n#ifdef LIBXML_VALID_ENABLED\n\t    /*\n\t     * The element is already defined in this DTD.\n\t     */\n\t    xmlErrValidNode(ctxt, (xmlNodePtr) dtd, XML_DTD_ELEM_REDEFINED,\n\t                    \"Redefinition of element %s\\n\",\n\t\t\t    name, NULL, NULL);\n#endif /* LIBXML_VALID_ENABLED */\n\t    if (uqname != NULL)\n\t\txmlFree(uqname);\n            if (ns != NULL)\n\t        xmlFree(ns);\n\t    return(NULL);\n\t}\n\tif (ns != NULL) {\n\t    xmlFree(ns);\n\t    ns = NULL;\n\t}\n    } else {\n\tret = (xmlElementPtr) xmlMalloc(sizeof(xmlElement));\n\tif (ret == NULL) {\n\t    xmlVErrMemory(ctxt, \"malloc failed\");\n\t    if (uqname != NULL)\n\t\txmlFree(uqname);\n            if (ns != NULL)\n\t        xmlFree(ns);\n\t    return(NULL);\n\t}\n\tmemset(ret, 0, sizeof(xmlElement));\n\tret->type = XML_ELEMENT_DECL;\n\n\t/*\n\t * fill the structure.\n\t */\n\tret->name = xmlStrdup(name);\n\tif (ret->name == NULL) {\n\t    xmlVErrMemory(ctxt, \"malloc failed\");\n\t    if (uqname != NULL)\n\t\txmlFree(uqname);\n            if (ns != NULL)\n\t        xmlFree(ns);\n\t    xmlFree(ret);\n\t    return(NULL);\n\t}\n\tret->prefix = ns;\n\n\t/*\n\t * Validity Check:\n\t * Insertion must not fail\n\t */\n\tif (xmlHashAddEntry2(table, name, ns, ret)) {\n#ifdef LIBXML_VALID_ENABLED\n\t    /*\n\t     * The element is already defined in this DTD.\n\t     */\n\t    xmlErrValidNode(ctxt, (xmlNodePtr) dtd, XML_DTD_ELEM_REDEFINED,\n\t                    \"Redefinition of element %s\\n\",\n\t\t\t    name, NULL, NULL);\n#endif /* LIBXML_VALID_ENABLED */\n\t    xmlFreeElement(ret);\n\t    if (uqname != NULL)\n\t\txmlFree(uqname);\n\t    return(NULL);\n\t}\n\t/*\n\t * For new element, may have attributes from earlier\n\t * definition in internal subset\n\t */\n\tret->attributes = oldAttributes;\n    }\n\n    /*\n     * Finish to fill the structure.\n     */\n    ret->etype = type;\n    /*\n     * Avoid a stupid copy when called by the parser\n     * and flag it by setting a special parent value\n     * so the parser doesn't unallocate it.\n     */\n    if ((ctxt != NULL) &&\n        ((ctxt->finishDtd == XML_CTXT_FINISH_DTD_0) ||\n         (ctxt->finishDtd == XML_CTXT_FINISH_DTD_1))) {\n\tret->content = content;\n\tif (content != NULL)\n\t    content->parent = (xmlElementContentPtr) 1;\n    } else {\n\tret->content = xmlCopyDocElementContent(dtd->doc, content);\n    }\n\n    /*\n     * Link it to the DTD\n     */\n    ret->parent = dtd;\n    ret->doc = dtd->doc;\n    if (dtd->last == NULL) {\n\tdtd->children = dtd->last = (xmlNodePtr) ret;\n    } else {\n        dtd->last->next = (xmlNodePtr) ret;\n\tret->prev = dtd->last;\n\tdtd->last = (xmlNodePtr) ret;\n    }\n    if (uqname != NULL)\n\txmlFree(uqname);\n    return(ret);\n}\n\nstatic void\nxmlFreeElementTableEntry(void *elem, const xmlChar *name ATTRIBUTE_UNUSED) {\n    xmlFreeElement((xmlElementPtr) elem);\n}\n\n/**\n * xmlFreeElementTable:\n * @table:  An element table\n *\n * Deallocate the memory used by an element hash table.\n */\nvoid\nxmlFreeElementTable(xmlElementTablePtr table) {\n    xmlHashFree(table, xmlFreeElementTableEntry);\n}\n\n#ifdef LIBXML_TREE_ENABLED\n/**\n * xmlCopyElement:\n * @elem:  An element\n *\n * Build a copy of an element.\n *\n * Returns the new xmlElementPtr or NULL in case of error.\n */\nstatic void *\nxmlCopyElement(void *payload, const xmlChar *name ATTRIBUTE_UNUSED) {\n    xmlElementPtr elem = (xmlElementPtr) payload;\n    xmlElementPtr cur;\n\n    cur = (xmlElementPtr) xmlMalloc(sizeof(xmlElement));\n    if (cur == NULL) {\n\txmlVErrMemory(NULL, \"malloc failed\");\n\treturn(NULL);\n    }\n    memset(cur, 0, sizeof(xmlElement));\n    cur->type = XML_ELEMENT_DECL;\n    cur->etype = elem->etype;\n    if (elem->name != NULL)\n\tcur->name = xmlStrdup(elem->name);\n    else\n\tcur->name = NULL;\n    if (elem->prefix != NULL)\n\tcur->prefix = xmlStrdup(elem->prefix);\n    else\n\tcur->prefix = NULL;\n    cur->content = xmlCopyElementContent(elem->content);\n    /* TODO : rebuild the attribute list on the copy */\n    cur->attributes = NULL;\n    return(cur);\n}\n\n/**\n * xmlCopyElementTable:\n * @table:  An element table\n *\n * Build a copy of an element table.\n *\n * Returns the new xmlElementTablePtr or NULL in case of error.\n */\nxmlElementTablePtr\nxmlCopyElementTable(xmlElementTablePtr table) {\n    return((xmlElementTablePtr) xmlHashCopy(table, xmlCopyElement));\n}\n#endif /* LIBXML_TREE_ENABLED */\n\n#ifdef LIBXML_OUTPUT_ENABLED\n/**\n * xmlDumpElementDecl:\n * @buf:  the XML buffer output\n * @elem:  An element table\n *\n * This will dump the content of the element declaration as an XML\n * DTD definition\n */\nvoid\nxmlDumpElementDecl(xmlBufferPtr buf, xmlElementPtr elem) {\n    if ((buf == NULL) || (elem == NULL))\n        return;\n    switch (elem->etype) {\n\tcase XML_ELEMENT_TYPE_EMPTY:\n\t    xmlBufferWriteChar(buf, \"<!ELEMENT \");\n\t    if (elem->prefix != NULL) {\n\t\txmlBufferWriteCHAR(buf, elem->prefix);\n\t\txmlBufferWriteChar(buf, \":\");\n\t    }\n\t    xmlBufferWriteCHAR(buf, elem->name);\n\t    xmlBufferWriteChar(buf, \" EMPTY>\\n\");\n\t    break;\n\tcase XML_ELEMENT_TYPE_ANY:\n\t    xmlBufferWriteChar(buf, \"<!ELEMENT \");\n\t    if (elem->prefix != NULL) {\n\t\txmlBufferWriteCHAR(buf, elem->prefix);\n\t\txmlBufferWriteChar(buf, \":\");\n\t    }\n\t    xmlBufferWriteCHAR(buf, elem->name);\n\t    xmlBufferWriteChar(buf, \" ANY>\\n\");\n\t    break;\n\tcase XML_ELEMENT_TYPE_MIXED:\n\t    xmlBufferWriteChar(buf, \"<!ELEMENT \");\n\t    if (elem->prefix != NULL) {\n\t\txmlBufferWriteCHAR(buf, elem->prefix);\n\t\txmlBufferWriteChar(buf, \":\");\n\t    }\n\t    xmlBufferWriteCHAR(buf, elem->name);\n\t    xmlBufferWriteChar(buf, \" \");\n\t    xmlDumpElementContent(buf, elem->content);\n\t    xmlBufferWriteChar(buf, \">\\n\");\n\t    break;\n\tcase XML_ELEMENT_TYPE_ELEMENT:\n\t    xmlBufferWriteChar(buf, \"<!ELEMENT \");\n\t    if (elem->prefix != NULL) {\n\t\txmlBufferWriteCHAR(buf, elem->prefix);\n\t\txmlBufferWriteChar(buf, \":\");\n\t    }\n\t    xmlBufferWriteCHAR(buf, elem->name);\n\t    xmlBufferWriteChar(buf, \" \");\n\t    xmlDumpElementContent(buf, elem->content);\n\t    xmlBufferWriteChar(buf, \">\\n\");\n\t    break;\n\tdefault:\n\t    xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\n\t\t    \"Internal: ELEMENT struct corrupted invalid type\\n\",\n\t\t    NULL);\n    }\n}\n\n/**\n * xmlDumpElementDeclScan:\n * @elem:  An element table\n * @buf:  the XML buffer output\n *\n * This routine is used by the hash scan function.  It just reverses\n * the arguments.\n */\nstatic void\nxmlDumpElementDeclScan(void *elem, void *buf,\n                       const xmlChar *name ATTRIBUTE_UNUSED) {\n    xmlDumpElementDecl((xmlBufferPtr) buf, (xmlElementPtr) elem);\n}\n\n/**\n * xmlDumpElementTable:\n * @buf:  the XML buffer output\n * @table:  An element table\n *\n * This will dump the content of the element table as an XML DTD definition\n */\nvoid\nxmlDumpElementTable(xmlBufferPtr buf, xmlElementTablePtr table) {\n    if ((buf == NULL) || (table == NULL))\n        return;\n    xmlHashScan(table, xmlDumpElementDeclScan, buf);\n}\n#endif /* LIBXML_OUTPUT_ENABLED */\n\n/**\n * xmlCreateEnumeration:\n * @name:  the enumeration name or NULL\n *\n * create and initialize an enumeration attribute node.\n *\n * Returns the xmlEnumerationPtr just created or NULL in case\n *                of error.\n */\nxmlEnumerationPtr\nxmlCreateEnumeration(const xmlChar *name) {\n    xmlEnumerationPtr ret;\n\n    ret = (xmlEnumerationPtr) xmlMalloc(sizeof(xmlEnumeration));\n    if (ret == NULL) {\n\txmlVErrMemory(NULL, \"malloc failed\");\n        return(NULL);\n    }\n    memset(ret, 0, sizeof(xmlEnumeration));\n\n    if (name != NULL)\n        ret->name = xmlStrdup(name);\n    return(ret);\n}\n\n/**\n * xmlFreeEnumeration:\n * @cur:  the tree to free.\n *\n * free an enumeration attribute node (recursive).\n */\nvoid\nxmlFreeEnumeration(xmlEnumerationPtr cur) {\n    if (cur == NULL) return;\n\n    if (cur->next != NULL) xmlFreeEnumeration(cur->next);\n\n    if (cur->name != NULL) xmlFree((xmlChar *) cur->name);\n    xmlFree(cur);\n}\n\n#ifdef LIBXML_TREE_ENABLED\n/**\n * xmlCopyEnumeration:\n * @cur:  the tree to copy.\n *\n * Copy an enumeration attribute node (recursive).\n *\n * Returns the xmlEnumerationPtr just created or NULL in case\n *                of error.\n */\nxmlEnumerationPtr\nxmlCopyEnumeration(xmlEnumerationPtr cur) {\n    xmlEnumerationPtr ret;\n\n    if (cur == NULL) return(NULL);\n    ret = xmlCreateEnumeration((xmlChar *) cur->name);\n    if (ret == NULL) return(NULL);\n\n    if (cur->next != NULL) ret->next = xmlCopyEnumeration(cur->next);\n    else ret->next = NULL;\n\n    return(ret);\n}\n#endif /* LIBXML_TREE_ENABLED */\n\n#ifdef LIBXML_OUTPUT_ENABLED\n/**\n * xmlDumpEnumeration:\n * @buf:  the XML buffer output\n * @enum:  An enumeration\n *\n * This will dump the content of the enumeration\n */\nstatic void\nxmlDumpEnumeration(xmlBufferPtr buf, xmlEnumerationPtr cur) {\n    if ((buf == NULL) || (cur == NULL))\n        return;\n\n    xmlBufferWriteCHAR(buf, cur->name);\n    if (cur->next == NULL)\n\txmlBufferWriteChar(buf, \")\");\n    else {\n\txmlBufferWriteChar(buf, \" | \");\n\txmlDumpEnumeration(buf, cur->next);\n    }\n}\n#endif /* LIBXML_OUTPUT_ENABLED */\n\n#ifdef LIBXML_VALID_ENABLED\n/**\n * xmlScanIDAttributeDecl:\n * @ctxt:  the validation context\n * @elem:  the element name\n * @err: whether to raise errors here\n *\n * Verify that the element don't have too many ID attributes\n * declared.\n *\n * Returns the number of ID attributes found.\n */\nstatic int\nxmlScanIDAttributeDecl(xmlValidCtxtPtr ctxt, xmlElementPtr elem, int err) {\n    xmlAttributePtr cur;\n    int ret = 0;\n\n    if (elem == NULL) return(0);\n    cur = elem->attributes;\n    while (cur != NULL) {\n        if (cur->atype == XML_ATTRIBUTE_ID) {\n\t    ret ++;\n\t    if ((ret > 1) && (err))\n\t\txmlErrValidNode(ctxt, (xmlNodePtr) elem, XML_DTD_MULTIPLE_ID,\n\t       \"Element %s has too many ID attributes defined : %s\\n\",\n\t\t       elem->name, cur->name, NULL);\n\t}\n\tcur = cur->nexth;\n    }\n    return(ret);\n}\n#endif /* LIBXML_VALID_ENABLED */\n\n/**\n * xmlFreeAttribute:\n * @elem:  An attribute\n *\n * Deallocate the memory used by an attribute definition\n */\nstatic void\nxmlFreeAttribute(xmlAttributePtr attr) {\n    xmlDictPtr dict;\n\n    if (attr == NULL) return;\n    if (attr->doc != NULL)\n\tdict = attr->doc->dict;\n    else\n\tdict = NULL;\n    xmlUnlinkNode((xmlNodePtr) attr);\n    if (attr->tree != NULL)\n        xmlFreeEnumeration(attr->tree);\n    if (dict) {\n        if ((attr->elem != NULL) && (!xmlDictOwns(dict, attr->elem)))\n\t    xmlFree((xmlChar *) attr->elem);\n        if ((attr->name != NULL) && (!xmlDictOwns(dict, attr->name)))\n\t    xmlFree((xmlChar *) attr->name);\n        if ((attr->prefix != NULL) && (!xmlDictOwns(dict, attr->prefix)))\n\t    xmlFree((xmlChar *) attr->prefix);\n        if ((attr->defaultValue != NULL) &&\n\t    (!xmlDictOwns(dict, attr->defaultValue)))\n\t    xmlFree((xmlChar *) attr->defaultValue);\n    } else {\n\tif (attr->elem != NULL)\n\t    xmlFree((xmlChar *) attr->elem);\n\tif (attr->name != NULL)\n\t    xmlFree((xmlChar *) attr->name);\n\tif (attr->defaultValue != NULL)\n\t    xmlFree((xmlChar *) attr->defaultValue);\n\tif (attr->prefix != NULL)\n\t    xmlFree((xmlChar *) attr->prefix);\n    }\n    xmlFree(attr);\n}\n\n\n/**\n * xmlAddAttributeDecl:\n * @ctxt:  the validation context\n * @dtd:  pointer to the DTD\n * @elem:  the element name\n * @name:  the attribute name\n * @ns:  the attribute namespace prefix\n * @type:  the attribute type\n * @def:  the attribute default type\n * @defaultValue:  the attribute default value\n * @tree:  if it's an enumeration, the associated list\n *\n * Register a new attribute declaration\n * Note that @tree becomes the ownership of the DTD\n *\n * Returns NULL if not new, otherwise the attribute decl\n */\nxmlAttributePtr\nxmlAddAttributeDecl(xmlValidCtxtPtr ctxt,\n                    xmlDtdPtr dtd, const xmlChar *elem,\n                    const xmlChar *name, const xmlChar *ns,\n\t\t    xmlAttributeType type, xmlAttributeDefault def,\n\t\t    const xmlChar *defaultValue, xmlEnumerationPtr tree) {\n    xmlAttributePtr ret;\n    xmlAttributeTablePtr table;\n    xmlElementPtr elemDef;\n    xmlDictPtr dict = NULL;\n\n    if (dtd == NULL) {\n\txmlFreeEnumeration(tree);\n\treturn(NULL);\n    }\n    if (name == NULL) {\n\txmlFreeEnumeration(tree);\n\treturn(NULL);\n    }\n    if (elem == NULL) {\n\txmlFreeEnumeration(tree);\n\treturn(NULL);\n    }\n    if (dtd->doc != NULL)\n\tdict = dtd->doc->dict;\n\n#ifdef LIBXML_VALID_ENABLED\n    /*\n     * Check the type and possibly the default value.\n     */\n    switch (type) {\n        case XML_ATTRIBUTE_CDATA:\n\t    break;\n        case XML_ATTRIBUTE_ID:\n\t    break;\n        case XML_ATTRIBUTE_IDREF:\n\t    break;\n        case XML_ATTRIBUTE_IDREFS:\n\t    break;\n        case XML_ATTRIBUTE_ENTITY:\n\t    break;\n        case XML_ATTRIBUTE_ENTITIES:\n\t    break;\n        case XML_ATTRIBUTE_NMTOKEN:\n\t    break;\n        case XML_ATTRIBUTE_NMTOKENS:\n\t    break;\n        case XML_ATTRIBUTE_ENUMERATION:\n\t    break;\n        case XML_ATTRIBUTE_NOTATION:\n\t    break;\n\tdefault:\n\t    xmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,\n\t\t    \"Internal: ATTRIBUTE struct corrupted invalid type\\n\",\n\t\t    NULL);\n\t    xmlFreeEnumeration(tree);\n\t    return(NULL);\n    }\n    if ((defaultValue != NULL) &&\n        (!xmlValidateAttributeValueInternal(dtd->doc, type, defaultValue))) {\n\txmlErrValidNode(ctxt, (xmlNodePtr) dtd, XML_DTD_ATTRIBUTE_DEFAULT,\n\t                \"Attribute %s of %s: invalid default value\\n\",\n\t                elem, name, defaultValue);\n\tdefaultValue = NULL;\n\tif (ctxt != NULL)\n\t    ctxt->valid = 0;\n    }\n#endif /* LIBXML_VALID_ENABLED */\n\n    /*\n     * Check first that an attribute defined in the external subset wasn't\n     * already defined in the internal subset\n     */\n    if ((dtd->doc != NULL) && (dtd->doc->extSubset == dtd) &&\n\t(dtd->doc->intSubset != NULL) &&\n\t(dtd->doc->intSubset->attributes != NULL)) {\n        ret = xmlHashLookup3(dtd->doc->intSubset->attributes, name, ns, elem);\n\tif (ret != NULL) {\n\t    xmlFreeEnumeration(tree);\n\t    return(NULL);\n\t}\n    }\n\n    /*\n     * Create the Attribute table if needed.\n     */\n    table = (xmlAttributeTablePtr) dtd->attributes;\n    if (table == NULL) {\n        table = xmlHashCreateDict(0, dict);\n\tdtd->attributes = (void *) table;\n    }\n    if (table == NULL) {\n\txmlVErrMemory(ctxt,\n            \"xmlAddAttributeDecl: Table creation failed!\\n\");\n\txmlFreeEnumeration(tree);\n        return(NULL);\n    }\n\n\n    ret = (xmlAttributePtr) xmlMalloc(sizeof(xmlAttribute));\n    if (ret == NULL) {\n\txmlVErrMemory(ctxt, \"malloc failed\");\n\txmlFreeEnumeration(tree);\n\treturn(NULL);\n    }\n    memset(ret, 0, sizeof(xmlAttribute));\n    ret->type = XML_ATTRIBUTE_DECL;\n\n    /*\n     * fill the structure.\n     */\n    ret->atype = type;\n    /*\n     * doc must be set before possible error causes call\n     * to xmlFreeAttribute (because it's used to check on\n     * dict use)\n     */\n    ret->doc = dtd->doc;\n    if (dict) {\n\tret->name = xmlDictLookup(dict, name, -1);\n\tret->prefix = xmlDictLookup(dict, ns, -1);\n\tret->elem = xmlDictLookup(dict, elem, -1);\n    } else {\n\tret->name = xmlStrdup(name);\n\tret->prefix = xmlStrdup(ns);\n\tret->elem = xmlStrdup(elem);\n    }\n    ret->def = def;\n    ret->tree = tree;\n    if (defaultValue != NULL) {\n        if (dict)\n\t    ret->defaultValue = xmlDictLookup(dict, defaultValue, -1);\n\telse\n\t    ret->defaultValue = xmlStrdup(defaultValue);\n    }\n\n    /*\n     * Validity Check:\n     * Search the DTD for previous declarations of the ATTLIST\n     */\n    if (xmlHashAddEntry3(table, ret->name, ret->prefix, ret->elem, ret) < 0) {\n#ifdef LIBXML_VALID_ENABLED\n\t/*\n\t * The attribute is already defined in this DTD.\n\t */\n\txmlErrValidWarning(ctxt, (xmlNodePtr) dtd, XML_DTD_ATTRIBUTE_REDEFINED,\n\t\t \"Attribute %s of element %s: already defined\\n\",\n\t\t name, elem, NULL);\n#endif /* LIBXML_VALID_ENABLED */\n\txmlFreeAttribute(ret);\n\treturn(NULL);\n    }\n\n    /*\n     * Validity Check:\n     * Multiple ID per element\n     */\n    elemDef = xmlGetDtdElementDesc2(dtd, elem, 1);\n    if (elemDef != NULL) {\n\n#ifdef LIBXML_VALID_ENABLED\n        if ((type == XML_ATTRIBUTE_ID) &&\n\t    (xmlScanIDAttributeDecl(NULL, elemDef, 1) != 0)) {\n\t    xmlErrValidNode(ctxt, (xmlNodePtr) dtd, XML_DTD_MULTIPLE_ID,\n\t   \"Element %s has too may ID attributes defined : %s\\n\",\n\t\t   elem, name, NULL);\n\t    if (ctxt != NULL)\n\t\tctxt->valid = 0;\n\t}\n#endif /* LIBXML_VALID_ENABLED */\n\n\t/*\n\t * Insert namespace default def first they need to be\n\t * processed first.\n\t */\n\tif ((xmlStrEqual(ret->name, BAD_CAST \"xmlns\")) ||\n\t    ((ret->prefix != NULL &&\n\t     (xmlStrEqual(ret->prefix, BAD_CAST \"xmlns\"))))) {\n\t    ret->nexth = elemDef->attributes;\n\t    elemDef->attributes = ret;\n\t} else {\n\t    xmlAttributePtr tmp = elemDef->attributes;\n\n\t    while ((tmp != NULL) &&\n\t\t   ((xmlStrEqual(tmp->name, BAD_CAST \"xmlns\")) ||\n\t\t    ((ret->prefix != NULL &&\n\t\t     (xmlStrEqual(ret->prefix, BAD_CAST \"xmlns\")))))) {\n\t\tif (tmp->nexth == NULL)\n\t\t    break;\n\t\ttmp = tmp->nexth;\n\t    }\n\t    if (tmp != NULL) {\n\t\tret->nexth = tmp->nexth;\n\t        tmp->nexth = ret;\n\t    } else {\n\t\tret->nexth = elemDef->attributes;\n\t\telemDef->attributes = ret;\n\t    }\n\t}\n    }\n\n    /*\n     * Link it to the DTD\n     */\n    ret->parent = dtd;\n    if (dtd->last == NULL) {\n\tdtd->children = dtd->last = (xmlNodePtr) ret;\n    } else {\n        dtd->last->next = (xmlNodePtr) ret;\n\tret->prev = dtd->last;\n\tdtd->last = (xmlNodePtr) ret;\n    }\n    return(ret);\n}\n\nstatic void\nxmlFreeAttributeTableEntry(void *attr, const xmlChar *name ATTRIBUTE_UNUSED) {\n    xmlFreeAttribute((xmlAttributePtr) attr);\n}\n\n/**\n * xmlFreeAttributeTable:\n * @table:  An attribute table\n *\n * Deallocate the memory used by an entities hash table.\n */\nvoid\nxmlFreeAttributeTable(xmlAttributeTablePtr table) {\n    xmlHashFree(table, xmlFreeAttributeTableEntry);\n}\n\n#ifdef LIBXML_TREE_ENABLED\n/**\n * xmlCopyAttribute:\n * @attr:  An attribute\n *\n * Build a copy of an attribute.\n *\n * Returns the new xmlAttributePtr or NULL in case of error.\n */\nstatic void *\nxmlCopyAttribute(void *payload, const xmlChar *name ATTRIBUTE_UNUSED) {\n    xmlAttributePtr attr = (xmlAttributePtr) payload;\n    xmlAttributePtr cur;\n\n    cur = (xmlAttributePtr) xmlMalloc(sizeof(xmlAttribute));\n    if (cur == NULL) {\n\txmlVErrMemory(NULL, \"malloc failed\");\n\treturn(NULL);\n    }\n    memset(cur, 0, sizeof(xmlAttribute));\n    cur->type = XML_ATTRIBUTE_DECL;\n    cur->atype = attr->atype;\n    cur->def = attr->def;\n    cur->tree = xmlCopyEnumeration(attr->tree);\n    if (attr->elem != NULL)\n\tcur->elem = xmlStrdup(attr->elem);\n    if (attr->name != NULL)\n\tcur->name = xmlStrdup(attr->name);\n    if (attr->prefix != NULL)\n\tcur->prefix = xmlStrdup(attr->prefix);\n    if (attr->defaultValue != NULL)\n\tcur->defaultValue = xmlStrdup(attr->defaultValue);\n    return(cur);\n}\n\n/**\n * xmlCopyAttributeTable:\n * @table:  An attribute table\n *\n * Build a copy of an attribute table.\n *\n * Returns the new xmlAttributeTablePtr or NULL in case of error.\n */\nxmlAttributeTablePtr\nxmlCopyAttributeTable(xmlAttributeTablePtr table) {\n    return((xmlAttributeTablePtr) xmlHashCopy(table, xmlCopyAttribute));\n}\n#endif /* LIBXML_TREE_ENABLED */\n\n#ifdef LIBXML_OUTPUT_ENABLED\n/**\n * xmlDumpAttributeDecl:\n * @buf:  the XML buffer output\n * @attr:  An attribute declaration\n *\n * This will dump the content of the attribute declaration as an XML\n * DTD definition\n */\nvoid\nxmlDumpAttributeDecl(xmlBufferPtr buf, xmlAttributePtr attr) {\n    if ((buf == NULL) || (attr == NULL))\n        return;\n    xmlBufferWriteChar(buf, \"<!ATTLIST \");\n    xmlBufferWriteCHAR(buf, attr->elem);\n    xmlBufferWriteChar(buf, \" \");\n    if (attr->prefix != NULL) {\n\txmlBufferWriteCHAR(buf, attr->prefix);\n\txmlBufferWriteChar(buf, \":\");\n    }\n    xmlBufferWriteCHAR(buf, attr->name);\n    switch (attr->atype) {\n\tcase XML_ATTRIBUTE_CDATA:\n\t    xmlBufferWriteChar(buf, \" CDATA\");\n\t    break;\n\tcase XML_ATTRIBUTE_ID:\n\t    xmlBufferWriteChar(buf, \" ID\");\n\t    break;\n\tcase XML_ATTRIBUTE_IDREF:\n\t    xmlBufferWriteChar(buf, \" IDREF\");\n\t    break;\n\tcase XML_ATTRIBUTE_IDREFS:\n\t    xmlBufferWriteChar(buf, \" IDREFS\");\n\t    break;\n\tcase XML_ATTRIBUTE_ENTITY:\n\t    xmlBufferWriteChar(buf, \" ENTITY\");\n\t    break;\n\tcase XML_ATTRIBUTE_ENTITIES:\n\t    xmlBufferWriteChar(buf, \" ENTITIES\");\n\t    break;\n\tcase XML_ATTRIBUTE_NMTOKEN:\n\t    xmlBufferWriteChar(buf, \" NMTOKEN\");\n\t    break;\n\tcase XML_ATTRIBUTE_NMTOKENS:\n\t    xmlBufferWriteChar(buf, \" NMTOKENS\");\n\t    break;\n\tcase XML_ATTRIBUTE_ENUMERATION:\n\t    xmlBufferWriteChar(buf, \" (\");\n\t    xmlDumpEnumeration(buf, attr->tree);\n\t    break;\n\tcase XML_ATTRIBUTE_NOTATION:\n\t    xmlBufferWriteChar(buf, \" NOTATION (\");\n\t    xmlDumpEnumeration(buf, attr->tree);\n\t    break;\n\tdefault:\n\t    xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\n\t\t    \"Internal: ATTRIBUTE struct corrupted invalid type\\n\",\n\t\t    NULL);\n    }\n    switch (attr->def) {\n\tcase XML_ATTRIBUTE_NONE:\n\t    break;\n\tcase XML_ATTRIBUTE_REQUIRED:\n\t    xmlBufferWriteChar(buf, \" #REQUIRED\");\n\t    break;\n\tcase XML_ATTRIBUTE_IMPLIED:\n\t    xmlBufferWriteChar(buf, \" #IMPLIED\");\n\t    break;\n\tcase XML_ATTRIBUTE_FIXED:\n\t    xmlBufferWriteChar(buf, \" #FIXED\");\n\t    break;\n\tdefault:\n\t    xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\n\t\t    \"Internal: ATTRIBUTE struct corrupted invalid def\\n\",\n\t\t    NULL);\n    }\n    if (attr->defaultValue != NULL) {\n\txmlBufferWriteChar(buf, \" \");\n\txmlBufferWriteQuotedString(buf, attr->defaultValue);\n    }\n    xmlBufferWriteChar(buf, \">\\n\");\n}\n\n/**\n * xmlDumpAttributeDeclScan:\n * @attr:  An attribute declaration\n * @buf:  the XML buffer output\n *\n * This is used with the hash scan function - just reverses arguments\n */\nstatic void\nxmlDumpAttributeDeclScan(void *attr, void *buf,\n                         const xmlChar *name ATTRIBUTE_UNUSED) {\n    xmlDumpAttributeDecl((xmlBufferPtr) buf, (xmlAttributePtr) attr);\n}\n\n/**\n * xmlDumpAttributeTable:\n * @buf:  the XML buffer output\n * @table:  An attribute table\n *\n * This will dump the content of the attribute table as an XML DTD definition\n */\nvoid\nxmlDumpAttributeTable(xmlBufferPtr buf, xmlAttributeTablePtr table) {\n    if ((buf == NULL) || (table == NULL))\n        return;\n    xmlHashScan(table, xmlDumpAttributeDeclScan, buf);\n}\n#endif /* LIBXML_OUTPUT_ENABLED */\n\n/************************************************************************\n *\t\t\t\t\t\t\t\t\t*\n *\t\t\t\tNOTATIONs\t\t\t\t*\n *\t\t\t\t\t\t\t\t\t*\n ************************************************************************/\n/**\n * xmlFreeNotation:\n * @not:  A notation\n *\n * Deallocate the memory used by an notation definition\n */\nstatic void\nxmlFreeNotation(xmlNotationPtr nota) {\n    if (nota == NULL) return;\n    if (nota->name != NULL)\n\txmlFree((xmlChar *) nota->name);\n    if (nota->PublicID != NULL)\n\txmlFree((xmlChar *) nota->PublicID);\n    if (nota->SystemID != NULL)\n\txmlFree((xmlChar *) nota->SystemID);\n    xmlFree(nota);\n}\n\n\n/**\n * xmlAddNotationDecl:\n * @dtd:  pointer to the DTD\n * @ctxt:  the validation context\n * @name:  the entity name\n * @PublicID:  the public identifier or NULL\n * @SystemID:  the system identifier or NULL\n *\n * Register a new notation declaration\n *\n * Returns NULL if not, otherwise the entity\n */\nxmlNotationPtr\nxmlAddNotationDecl(xmlValidCtxtPtr ctxt, xmlDtdPtr dtd,\n\t           const xmlChar *name,\n                   const xmlChar *PublicID, const xmlChar *SystemID) {\n    xmlNotationPtr ret;\n    xmlNotationTablePtr table;\n\n    if (dtd == NULL) {\n\treturn(NULL);\n    }\n    if (name == NULL) {\n\treturn(NULL);\n    }\n    if ((PublicID == NULL) && (SystemID == NULL)) {\n\treturn(NULL);\n    }\n\n    /*\n     * Create the Notation table if needed.\n     */\n    table = (xmlNotationTablePtr) dtd->notations;\n    if (table == NULL) {\n\txmlDictPtr dict = NULL;\n\tif (dtd->doc != NULL)\n\t    dict = dtd->doc->dict;\n\n        dtd->notations = table = xmlHashCreateDict(0, dict);\n    }\n    if (table == NULL) {\n\txmlVErrMemory(ctxt,\n\t\t\"xmlAddNotationDecl: Table creation failed!\\n\");\n        return(NULL);\n    }\n\n    ret = (xmlNotationPtr) xmlMalloc(sizeof(xmlNotation));\n    if (ret == NULL) {\n\txmlVErrMemory(ctxt, \"malloc failed\");\n\treturn(NULL);\n    }\n    memset(ret, 0, sizeof(xmlNotation));\n\n    /*\n     * fill the structure.\n     */\n    ret->name = xmlStrdup(name);\n    if (SystemID != NULL)\n        ret->SystemID = xmlStrdup(SystemID);\n    if (PublicID != NULL)\n        ret->PublicID = xmlStrdup(PublicID);\n\n    /*\n     * Validity Check:\n     * Check the DTD for previous declarations of the ATTLIST\n     */\n    if (xmlHashAddEntry(table, name, ret)) {\n#ifdef LIBXML_VALID_ENABLED\n\txmlErrValid(NULL, XML_DTD_NOTATION_REDEFINED,\n\t\t    \"xmlAddNotationDecl: %s already defined\\n\",\n\t\t    (const char *) name);\n#endif /* LIBXML_VALID_ENABLED */\n\txmlFreeNotation(ret);\n\treturn(NULL);\n    }\n    return(ret);\n}\n\nstatic void\nxmlFreeNotationTableEntry(void *nota, const xmlChar *name ATTRIBUTE_UNUSED) {\n    xmlFreeNotation((xmlNotationPtr) nota);\n}\n\n/**\n * xmlFreeNotationTable:\n * @table:  An notation table\n *\n * Deallocate the memory used by an entities hash table.\n */\nvoid\nxmlFreeNotationTable(xmlNotationTablePtr table) {\n    xmlHashFree(table, xmlFreeNotationTableEntry);\n}\n\n#ifdef LIBXML_TREE_ENABLED\n/**\n * xmlCopyNotation:\n * @nota:  A notation\n *\n * Build a copy of a notation.\n *\n * Returns the new xmlNotationPtr or NULL in case of error.\n */\nstatic void *\nxmlCopyNotation(void *payload, const xmlChar *name ATTRIBUTE_UNUSED) {\n    xmlNotationPtr nota = (xmlNotationPtr) payload;\n    xmlNotationPtr cur;\n\n    cur = (xmlNotationPtr) xmlMalloc(sizeof(xmlNotation));\n    if (cur == NULL) {\n\txmlVErrMemory(NULL, \"malloc failed\");\n\treturn(NULL);\n    }\n    if (nota->name != NULL)\n\tcur->name = xmlStrdup(nota->name);\n    else\n\tcur->name = NULL;\n    if (nota->PublicID != NULL)\n\tcur->PublicID = xmlStrdup(nota->PublicID);\n    else\n\tcur->PublicID = NULL;\n    if (nota->SystemID != NULL)\n\tcur->SystemID = xmlStrdup(nota->SystemID);\n    else\n\tcur->SystemID = NULL;\n    return(cur);\n}\n\n/**\n * xmlCopyNotationTable:\n * @table:  A notation table\n *\n * Build a copy of a notation table.\n *\n * Returns the new xmlNotationTablePtr or NULL in case of error.\n */\nxmlNotationTablePtr\nxmlCopyNotationTable(xmlNotationTablePtr table) {\n    return((xmlNotationTablePtr) xmlHashCopy(table, xmlCopyNotation));\n}\n#endif /* LIBXML_TREE_ENABLED */\n\n#ifdef LIBXML_OUTPUT_ENABLED\n/**\n * xmlDumpNotationDecl:\n * @buf:  the XML buffer output\n * @nota:  A notation declaration\n *\n * This will dump the content the notation declaration as an XML DTD definition\n */\nvoid\nxmlDumpNotationDecl(xmlBufferPtr buf, xmlNotationPtr nota) {\n    if ((buf == NULL) || (nota == NULL))\n        return;\n    xmlBufferWriteChar(buf, \"<!NOTATION \");\n    xmlBufferWriteCHAR(buf, nota->name);\n    if (nota->PublicID != NULL) {\n\txmlBufferWriteChar(buf, \" PUBLIC \");\n\txmlBufferWriteQuotedString(buf, nota->PublicID);\n\tif (nota->SystemID != NULL) {\n\t    xmlBufferWriteChar(buf, \" \");\n\t    xmlBufferWriteQuotedString(buf, nota->SystemID);\n\t}\n    } else {\n\txmlBufferWriteChar(buf, \" SYSTEM \");\n\txmlBufferWriteQuotedString(buf, nota->SystemID);\n    }\n    xmlBufferWriteChar(buf, \" >\\n\");\n}\n\n/**\n * xmlDumpNotationDeclScan:\n * @nota:  A notation declaration\n * @buf:  the XML buffer output\n *\n * This is called with the hash scan function, and just reverses args\n */\nstatic void\nxmlDumpNotationDeclScan(void *nota, void *buf,\n                        const xmlChar *name ATTRIBUTE_UNUSED) {\n    xmlDumpNotationDecl((xmlBufferPtr) buf, (xmlNotationPtr) nota);\n}\n\n/**\n * xmlDumpNotationTable:\n * @buf:  the XML buffer output\n * @table:  A notation table\n *\n * This will dump the content of the notation table as an XML DTD definition\n */\nvoid\nxmlDumpNotationTable(xmlBufferPtr buf, xmlNotationTablePtr table) {\n    if ((buf == NULL) || (table == NULL))\n        return;\n    xmlHashScan(table, xmlDumpNotationDeclScan, buf);\n}\n#endif /* LIBXML_OUTPUT_ENABLED */\n\n/************************************************************************\n *\t\t\t\t\t\t\t\t\t*\n *\t\t\t\tIDs\t\t\t\t\t*\n *\t\t\t\t\t\t\t\t\t*\n ************************************************************************/\n/**\n * DICT_FREE:\n * @str:  a string\n *\n * Free a string if it is not owned by the \"dict\" dictionary in the\n * current scope\n */\n#define DICT_FREE(str)\t\t\t\t\t\t\\\n\tif ((str) && ((!dict) ||\t\t\t\t\\\n\t    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))\t\\\n\t    xmlFree((char *)(str));\n\n/**\n * xmlFreeID:\n * @not:  A id\n *\n * Deallocate the memory used by an id definition\n */\nstatic void\nxmlFreeID(xmlIDPtr id) {\n    xmlDictPtr dict = NULL;\n\n    if (id == NULL) return;\n\n    if (id->doc != NULL)\n        dict = id->doc->dict;\n\n    if (id->value != NULL)\n\tDICT_FREE(id->value)\n    if (id->name != NULL)\n\tDICT_FREE(id->name)\n    xmlFree(id);\n}\n\n\n/**\n * xmlAddID:\n * @ctxt:  the validation context\n * @doc:  pointer to the document\n * @value:  the value name\n * @attr:  the attribute holding the ID\n *\n * Register a new id declaration\n *\n * Returns NULL if not, otherwise the new xmlIDPtr\n */\nxmlIDPtr\nxmlAddID(xmlValidCtxtPtr ctxt, xmlDocPtr doc, const xmlChar *value,\n         xmlAttrPtr attr) {\n    xmlIDPtr ret;\n    xmlIDTablePtr table;\n\n    if (doc == NULL) {\n\treturn(NULL);\n    }\n    if (value == NULL) {\n\treturn(NULL);\n    }\n    if (attr == NULL) {\n\treturn(NULL);\n    }\n\n    /*\n     * Create the ID table if needed.\n     */\n    table = (xmlIDTablePtr) doc->ids;\n    if (table == NULL)  {\n        doc->ids = table = xmlHashCreateDict(0, doc->dict);\n    }\n    if (table == NULL) {\n\txmlVErrMemory(ctxt,\n\t\t\"xmlAddID: Table creation failed!\\n\");\n        return(NULL);\n    }\n\n    ret = (xmlIDPtr) xmlMalloc(sizeof(xmlID));\n    if (ret == NULL) {\n\txmlVErrMemory(ctxt, \"malloc failed\");\n\treturn(NULL);\n    }\n\n    /*\n     * fill the structure.\n     */\n    ret->value = xmlStrdup(value);\n    ret->doc = doc;\n    if ((ctxt != NULL) && (ctxt->vstateNr != 0)) {\n\t/*\n\t * Operating in streaming mode, attr is gonna disappear\n\t */\n\tif (doc->dict != NULL)\n\t    ret->name = xmlDictLookup(doc->dict, attr->name, -1);\n\telse\n\t    ret->name = xmlStrdup(attr->name);\n\tret->attr = NULL;\n    } else {\n\tret->attr = attr;\n\tret->name = NULL;\n    }\n    ret->lineno = xmlGetLineNo(attr->parent);\n\n    if (xmlHashAddEntry(table, value, ret) < 0) {\n#ifdef LIBXML_VALID_ENABLED\n\t/*\n\t * The id is already defined in this DTD.\n\t */\n\tif (ctxt != NULL) {\n\t    xmlErrValidNode(ctxt, attr->parent, XML_DTD_ID_REDEFINED,\n\t\t\t    \"ID %s already defined\\n\", value, NULL, NULL);\n\t}\n#endif /* LIBXML_VALID_ENABLED */\n\txmlFreeID(ret);\n\treturn(NULL);\n    }\n    if (attr != NULL)\n\tattr->atype = XML_ATTRIBUTE_ID;\n    return(ret);\n}\n\nstatic void\nxmlFreeIDTableEntry(void *id, const xmlChar *name ATTRIBUTE_UNUSED) {\n    xmlFreeID((xmlIDPtr) id);\n}\n\n/**\n * xmlFreeIDTable:\n * @table:  An id table\n *\n * Deallocate the memory used by an ID hash table.\n */\nvoid\nxmlFreeIDTable(xmlIDTablePtr table) {\n    xmlHashFree(table, xmlFreeIDTableEntry);\n}\n\n/**\n * xmlIsID:\n * @doc:  the document\n * @elem:  the element carrying the attribute\n * @attr:  the attribute\n *\n * Determine whether an attribute is of type ID. In case we have DTD(s)\n * then this is done if DTD loading has been requested. In the case\n * of HTML documents parsed with the HTML parser, then ID detection is\n * done systematically.\n *\n * Returns 0 or 1 depending on the lookup result\n */\nint\nxmlIsID(xmlDocPtr doc, xmlNodePtr elem, xmlAttrPtr attr) {\n    if ((attr == NULL) || (attr->name == NULL)) return(0);\n    if ((attr->ns != NULL) && (attr->ns->prefix != NULL) &&\n        (!strcmp((char *) attr->name, \"id\")) &&\n        (!strcmp((char *) attr->ns->prefix, \"xml\")))\n\treturn(1);\n    if (doc == NULL) return(0);\n    if ((doc->intSubset == NULL) && (doc->extSubset == NULL) &&\n        (doc->type != XML_HTML_DOCUMENT_NODE)) {\n\treturn(0);\n    } else if (doc->type == XML_HTML_DOCUMENT_NODE) {\n        if ((xmlStrEqual(BAD_CAST \"id\", attr->name)) ||\n\t    ((xmlStrEqual(BAD_CAST \"name\", attr->name)) &&\n\t    ((elem == NULL) || (xmlStrEqual(elem->name, BAD_CAST \"a\")))))\n\t    return(1);\n\treturn(0);\n    } else if (elem == NULL) {\n\treturn(0);\n    } else {\n\txmlAttributePtr attrDecl = NULL;\n\n\txmlChar felem[50], fattr[50];\n\txmlChar *fullelemname, *fullattrname;\n\n\tfullelemname = (elem->ns != NULL && elem->ns->prefix != NULL) ?\n\t    xmlBuildQName(elem->name, elem->ns->prefix, felem, 50) :\n\t    (xmlChar *)elem->name;\n\n\tfullattrname = (attr->ns != NULL && attr->ns->prefix != NULL) ?\n\t    xmlBuildQName(attr->name, attr->ns->prefix, fattr, 50) :\n\t    (xmlChar *)attr->name;\n\n\tif (fullelemname != NULL && fullattrname != NULL) {\n\t    attrDecl = xmlGetDtdAttrDesc(doc->intSubset, fullelemname,\n\t\t                         fullattrname);\n\t    if ((attrDecl == NULL) && (doc->extSubset != NULL))\n\t\tattrDecl = xmlGetDtdAttrDesc(doc->extSubset, fullelemname,\n\t\t\t\t\t     fullattrname);\n\t}\n\n\tif ((fullattrname != fattr) && (fullattrname != attr->name))\n\t    xmlFree(fullattrname);\n\tif ((fullelemname != felem) && (fullelemname != elem->name))\n\t    xmlFree(fullelemname);\n\n        if ((attrDecl != NULL) && (attrDecl->atype == XML_ATTRIBUTE_ID))\n\t    return(1);\n    }\n    return(0);\n}\n\n/**\n * xmlRemoveID:\n * @doc:  the document\n * @attr:  the attribute\n *\n * Remove the given attribute from the ID table maintained internally.\n *\n * Returns -1 if the lookup failed and 0 otherwise\n */\nint\nxmlRemoveID(xmlDocPtr doc, xmlAttrPtr attr) {\n    xmlIDTablePtr table;\n    xmlIDPtr id;\n    xmlChar *ID;\n\n    if (doc == NULL) return(-1);\n    if (attr == NULL) return(-1);\n\n    table = (xmlIDTablePtr) doc->ids;\n    if (table == NULL)\n        return(-1);\n\n    ID = xmlNodeListGetString(doc, attr->children, 1);\n    if (ID == NULL)\n        return(-1);\n\n    id = xmlHashLookup(table, ID);\n    if (id == NULL || id->attr != attr) {\n        xmlFree(ID);\n        return(-1);\n    }\n\n    xmlHashRemoveEntry(table, ID, xmlFreeIDTableEntry);\n    xmlFree(ID);\n    attr->atype = 0;\n    return(0);\n}\n\n/**\n * xmlGetID:\n * @doc:  pointer to the document\n * @ID:  the ID value\n *\n * Search the attribute declaring the given ID\n *\n * Returns NULL if not found, otherwise the xmlAttrPtr defining the ID\n */\nxmlAttrPtr\nxmlGetID(xmlDocPtr doc, const xmlChar *ID) {\n    xmlIDTablePtr table;\n    xmlIDPtr id;\n\n    if (doc == NULL) {\n\treturn(NULL);\n    }\n\n    if (ID == NULL) {\n\treturn(NULL);\n    }\n\n    table = (xmlIDTablePtr) doc->ids;\n    if (table == NULL)\n        return(NULL);\n\n    id = xmlHashLookup(table, ID);\n    if (id == NULL)\n\treturn(NULL);\n    if (id->attr == NULL) {\n\t/*\n\t * We are operating on a stream, return a well known reference\n\t * since the attribute node doesn't exist anymore\n\t */\n\treturn((xmlAttrPtr) doc);\n    }\n    return(id->attr);\n}\n\n/************************************************************************\n *\t\t\t\t\t\t\t\t\t*\n *\t\t\t\tRefs\t\t\t\t\t*\n *\t\t\t\t\t\t\t\t\t*\n ************************************************************************/\ntypedef struct xmlRemoveMemo_t\n{\n\txmlListPtr l;\n\txmlAttrPtr ap;\n} xmlRemoveMemo;\n\ntypedef xmlRemoveMemo *xmlRemoveMemoPtr;\n\ntypedef struct xmlValidateMemo_t\n{\n    xmlValidCtxtPtr ctxt;\n    const xmlChar *name;\n} xmlValidateMemo;\n\ntypedef xmlValidateMemo *xmlValidateMemoPtr;\n\n/**\n * xmlFreeRef:\n * @lk:  A list link\n *\n * Deallocate the memory used by a ref definition\n */\nstatic void\nxmlFreeRef(xmlLinkPtr lk) {\n    xmlRefPtr ref = (xmlRefPtr)xmlLinkGetData(lk);\n    if (ref == NULL) return;\n    if (ref->value != NULL)\n        xmlFree((xmlChar *)ref->value);\n    if (ref->name != NULL)\n        xmlFree((xmlChar *)ref->name);\n    xmlFree(ref);\n}\n\n/**\n * xmlFreeRefTableEntry:\n * @list_ref:  A list of references.\n *\n * Deallocate the memory used by a list of references\n */\nstatic void\nxmlFreeRefTableEntry(void *payload, const xmlChar *name ATTRIBUTE_UNUSED) {\n    xmlListPtr list_ref = (xmlListPtr) payload;\n    if (list_ref == NULL) return;\n    xmlListDelete(list_ref);\n}\n\n/**\n * xmlWalkRemoveRef:\n * @data:  Contents of current link\n * @user:  Value supplied by the user\n *\n * Returns 0 to abort the walk or 1 to continue\n */\nstatic int\nxmlWalkRemoveRef(const void *data, void *user)\n{\n    xmlAttrPtr attr0 = ((xmlRefPtr)data)->attr;\n    xmlAttrPtr attr1 = ((xmlRemoveMemoPtr)user)->ap;\n    xmlListPtr ref_list = ((xmlRemoveMemoPtr)user)->l;\n\n    if (attr0 == attr1) { /* Matched: remove and terminate walk */\n        xmlListRemoveFirst(ref_list, (void *)data);\n        return 0;\n    }\n    return 1;\n}\n\n/**\n * xmlDummyCompare\n * @data0:  Value supplied by the user\n * @data1:  Value supplied by the user\n *\n * Do nothing, return 0. Used to create unordered lists.\n */\nstatic int\nxmlDummyCompare(const void *data0 ATTRIBUTE_UNUSED,\n                const void *data1 ATTRIBUTE_UNUSED)\n{\n    return (0);\n}\n\n/**\n * xmlAddRef:\n * @ctxt:  the validation context\n * @doc:  pointer to the document\n * @value:  the value name\n * @attr:  the attribute holding the Ref\n *\n * Register a new ref declaration\n *\n * Returns NULL if not, otherwise the new xmlRefPtr\n */\nxmlRefPtr\nxmlAddRef(xmlValidCtxtPtr ctxt, xmlDocPtr doc, const xmlChar *value,\n    xmlAttrPtr attr) {\n    xmlRefPtr ret;\n    xmlRefTablePtr table;\n    xmlListPtr ref_list;\n\n    if (doc == NULL) {\n        return(NULL);\n    }\n    if (value == NULL) {\n        return(NULL);\n    }\n    if (attr == NULL) {\n        return(NULL);\n    }\n\n    /*\n     * Create the Ref table if needed.\n     */\n    table = (xmlRefTablePtr) doc->refs;\n    if (table == NULL) {\n        doc->refs = table = xmlHashCreateDict(0, doc->dict);\n    }\n    if (table == NULL) {\n\txmlVErrMemory(ctxt,\n            \"xmlAddRef: Table creation failed!\\n\");\n        return(NULL);\n    }\n\n    ret = (xmlRefPtr) xmlMalloc(sizeof(xmlRef));\n    if (ret == NULL) {\n\txmlVErrMemory(ctxt, \"malloc failed\");\n        return(NULL);\n    }\n\n    /*\n     * fill the structure.\n     */\n    ret->value = xmlStrdup(value);\n    if ((ctxt != NULL) && (ctxt->vstateNr != 0)) {\n\t/*\n\t * Operating in streaming mode, attr is gonna disappear\n\t */\n\tret->name = xmlStrdup(attr->name);\n\tret->attr = NULL;\n    } else {\n\tret->name = NULL;\n\tret->attr = attr;\n    }\n    ret->lineno = xmlGetLineNo(attr->parent);\n\n    /* To add a reference :-\n     * References are maintained as a list of references,\n     * Lookup the entry, if no entry create new nodelist\n     * Add the owning node to the NodeList\n     * Return the ref\n     */\n\n    if (NULL == (ref_list = xmlHashLookup(table, value))) {\n        if (NULL == (ref_list = xmlListCreate(xmlFreeRef, xmlDummyCompare))) {\n\t    xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\n\t\t    \"xmlAddRef: Reference list creation failed!\\n\",\n\t\t    NULL);\n\t    goto failed;\n        }\n        if (xmlHashAddEntry(table, value, ref_list) < 0) {\n            xmlListDelete(ref_list);\n\t    xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\n\t\t    \"xmlAddRef: Reference list insertion failed!\\n\",\n\t\t    NULL);\n\t    goto failed;\n        }\n    }\n    if (xmlListAppend(ref_list, ret) != 0) {\n\txmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\n\t\t    \"xmlAddRef: Reference list insertion failed!\\n\",\n\t\t    NULL);\n        goto failed;\n    }\n    return(ret);\nfailed:\n    if (ret != NULL) {\n        if (ret->value != NULL)\n\t    xmlFree((char *)ret->value);\n        if (ret->name != NULL)\n\t    xmlFree((char *)ret->name);\n        xmlFree(ret);\n    }\n    return(NULL);\n}\n\n/**\n * xmlFreeRefTable:\n * @table:  An ref table\n *\n * Deallocate the memory used by an Ref hash table.\n */\nvoid\nxmlFreeRefTable(xmlRefTablePtr table) {\n    xmlHashFree(table, xmlFreeRefTableEntry);\n}\n\n/**\n * xmlIsRef:\n * @doc:  the document\n * @elem:  the element carrying the attribute\n * @attr:  the attribute\n *\n * Determine whether an attribute is of type Ref. In case we have DTD(s)\n * then this is simple, otherwise we use an heuristic: name Ref (upper\n * or lowercase).\n *\n * Returns 0 or 1 depending on the lookup result\n */\nint\nxmlIsRef(xmlDocPtr doc, xmlNodePtr elem, xmlAttrPtr attr) {\n    if (attr == NULL)\n        return(0);\n    if (doc == NULL) {\n        doc = attr->doc;\n\tif (doc == NULL) return(0);\n    }\n\n    if ((doc->intSubset == NULL) && (doc->extSubset == NULL)) {\n        return(0);\n    } else if (doc->type == XML_HTML_DOCUMENT_NODE) {\n        /* TODO @@@ */\n        return(0);\n    } else {\n        xmlAttributePtr attrDecl;\n\n        if (elem == NULL) return(0);\n        attrDecl = xmlGetDtdAttrDesc(doc->intSubset, elem->name, attr->name);\n        if ((attrDecl == NULL) && (doc->extSubset != NULL))\n            attrDecl = xmlGetDtdAttrDesc(doc->extSubset,\n\t\t                         elem->name, attr->name);\n\n\tif ((attrDecl != NULL) &&\n\t    (attrDecl->atype == XML_ATTRIBUTE_IDREF ||\n\t     attrDecl->atype == XML_ATTRIBUTE_IDREFS))\n\treturn(1);\n    }\n    return(0);\n}\n\n/**\n * xmlRemoveRef:\n * @doc:  the document\n * @attr:  the attribute\n *\n * Remove the given attribute from the Ref table maintained internally.\n *\n * Returns -1 if the lookup failed and 0 otherwise\n */\nint\nxmlRemoveRef(xmlDocPtr doc, xmlAttrPtr attr) {\n    xmlListPtr ref_list;\n    xmlRefTablePtr table;\n    xmlChar *ID;\n    xmlRemoveMemo target;\n\n    if (doc == NULL) return(-1);\n    if (attr == NULL) return(-1);\n\n    table = (xmlRefTablePtr) doc->refs;\n    if (table == NULL)\n        return(-1);\n\n    ID = xmlNodeListGetString(doc, attr->children, 1);\n    if (ID == NULL)\n        return(-1);\n\n    ref_list = xmlHashLookup(table, ID);\n    if(ref_list == NULL) {\n        xmlFree(ID);\n        return (-1);\n    }\n\n    /* At this point, ref_list refers to a list of references which\n     * have the same key as the supplied attr. Our list of references\n     * is ordered by reference address and we don't have that information\n     * here to use when removing. We'll have to walk the list and\n     * check for a matching attribute, when we find one stop the walk\n     * and remove the entry.\n     * The list is ordered by reference, so that means we don't have the\n     * key. Passing the list and the reference to the walker means we\n     * will have enough data to be able to remove the entry.\n     */\n    target.l = ref_list;\n    target.ap = attr;\n\n    /* Remove the supplied attr from our list */\n    xmlListWalk(ref_list, xmlWalkRemoveRef, &target);\n\n    /*If the list is empty then remove the list entry in the hash */\n    if (xmlListEmpty(ref_list))\n        xmlHashUpdateEntry(table, ID, NULL, xmlFreeRefTableEntry);\n    xmlFree(ID);\n    return(0);\n}\n\n/**\n * xmlGetRefs:\n * @doc:  pointer to the document\n * @ID:  the ID value\n *\n * Find the set of references for the supplied ID.\n *\n * Returns NULL if not found, otherwise node set for the ID.\n */\nxmlListPtr\nxmlGetRefs(xmlDocPtr doc, const xmlChar *ID) {\n    xmlRefTablePtr table;\n\n    if (doc == NULL) {\n        return(NULL);\n    }\n\n    if (ID == NULL) {\n        return(NULL);\n    }\n\n    table = (xmlRefTablePtr) doc->refs;\n    if (table == NULL)\n        return(NULL);\n\n    return (xmlHashLookup(table, ID));\n}\n\n/************************************************************************\n *\t\t\t\t\t\t\t\t\t*\n *\t\tRoutines for validity checking\t\t\t\t*\n *\t\t\t\t\t\t\t\t\t*\n ************************************************************************/\n\n/**\n * xmlGetDtdElementDesc:\n * @dtd:  a pointer to the DtD to search\n * @name:  the element name\n *\n * Search the DTD for the description of this element\n *\n * returns the xmlElementPtr if found or NULL\n */\n\nxmlElementPtr\nxmlGetDtdElementDesc(xmlDtdPtr dtd, const xmlChar *name) {\n    xmlElementTablePtr table;\n    xmlElementPtr cur;\n    xmlChar *uqname = NULL, *prefix = NULL;\n\n    if ((dtd == NULL) || (name == NULL)) return(NULL);\n    if (dtd->elements == NULL)\n\treturn(NULL);\n    table = (xmlElementTablePtr) dtd->elements;\n\n    uqname = xmlSplitQName2(name, &prefix);\n    if (uqname != NULL)\n        name = uqname;\n    cur = xmlHashLookup2(table, name, prefix);\n    if (prefix != NULL) xmlFree(prefix);\n    if (uqname != NULL) xmlFree(uqname);\n    return(cur);\n}\n/**\n * xmlGetDtdElementDesc2:\n * @dtd:  a pointer to the DtD to search\n * @name:  the element name\n * @create:  create an empty description if not found\n *\n * Search the DTD for the description of this element\n *\n * returns the xmlElementPtr if found or NULL\n */\n\nstatic xmlElementPtr\nxmlGetDtdElementDesc2(xmlDtdPtr dtd, const xmlChar *name, int create) {\n    xmlElementTablePtr table;\n    xmlElementPtr cur;\n    xmlChar *uqname = NULL, *prefix = NULL;\n\n    if (dtd == NULL) return(NULL);\n    if (dtd->elements == NULL) {\n\txmlDictPtr dict = NULL;\n\n\tif (dtd->doc != NULL)\n\t    dict = dtd->doc->dict;\n\n\tif (!create)\n\t    return(NULL);\n\t/*\n\t * Create the Element table if needed.\n\t */\n\ttable = (xmlElementTablePtr) dtd->elements;\n\tif (table == NULL) {\n\t    table = xmlHashCreateDict(0, dict);\n\t    dtd->elements = (void *) table;\n\t}\n\tif (table == NULL) {\n\t    xmlVErrMemory(NULL, \"element table allocation failed\");\n\t    return(NULL);\n\t}\n    }\n    table = (xmlElementTablePtr) dtd->elements;\n\n    uqname = xmlSplitQName2(name, &prefix);\n    if (uqname != NULL)\n        name = uqname;\n    cur = xmlHashLookup2(table, name, prefix);\n    if ((cur == NULL) && (create)) {\n\tcur = (xmlElementPtr) xmlMalloc(sizeof(xmlElement));\n\tif (cur == NULL) {\n\t    xmlVErrMemory(NULL, \"malloc failed\");\n\t    return(NULL);\n\t}\n\tmemset(cur, 0, sizeof(xmlElement));\n\tcur->type = XML_ELEMENT_DECL;\n\n\t/*\n\t * fill the structure.\n\t */\n\tcur->name = xmlStrdup(name);\n\tcur->prefix = xmlStrdup(prefix);\n\tcur->etype = XML_ELEMENT_TYPE_UNDEFINED;\n\n\txmlHashAddEntry2(table, name, prefix, cur);\n    }\n    if (prefix != NULL) xmlFree(prefix);\n    if (uqname != NULL) xmlFree(uqname);\n    return(cur);\n}\n\n/**\n * xmlGetDtdQElementDesc:\n * @dtd:  a pointer to the DtD to search\n * @name:  the element name\n * @prefix:  the element namespace prefix\n *\n * Search the DTD for the description of this element\n *\n * returns the xmlElementPtr if found or NULL\n */\n\nxmlElementPtr\nxmlGetDtdQElementDesc(xmlDtdPtr dtd, const xmlChar *name,\n\t              const xmlChar *prefix) {\n    xmlElementTablePtr table;\n\n    if (dtd == NULL) return(NULL);\n    if (dtd->elements == NULL) return(NULL);\n    table = (xmlElementTablePtr) dtd->elements;\n\n    return(xmlHashLookup2(table, name, prefix));\n}\n\n/**\n * xmlGetDtdAttrDesc:\n * @dtd:  a pointer to the DtD to search\n * @elem:  the element name\n * @name:  the attribute name\n *\n * Search the DTD for the description of this attribute on\n * this element.\n *\n * returns the xmlAttributePtr if found or NULL\n */\n\nxmlAttributePtr\nxmlGetDtdAttrDesc(xmlDtdPtr dtd, const xmlChar *elem, const xmlChar *name) {\n    xmlAttributeTablePtr table;\n    xmlAttributePtr cur;\n    xmlChar *uqname = NULL, *prefix = NULL;\n\n    if (dtd == NULL) return(NULL);\n    if (dtd->attributes == NULL) return(NULL);\n\n    table = (xmlAttributeTablePtr) dtd->attributes;\n    if (table == NULL)\n\treturn(NULL);\n\n    uqname = xmlSplitQName2(name, &prefix);\n\n    if (uqname != NULL) {\n\tcur = xmlHashLookup3(table, uqname, prefix, elem);\n\tif (prefix != NULL) xmlFree(prefix);\n\tif (uqname != NULL) xmlFree(uqname);\n    } else\n\tcur = xmlHashLookup3(table, name, NULL, elem);\n    return(cur);\n}\n\n/**\n * xmlGetDtdQAttrDesc:\n * @dtd:  a pointer to the DtD to search\n * @elem:  the element name\n * @name:  the attribute name\n * @prefix:  the attribute namespace prefix\n *\n * Search the DTD for the description of this qualified attribute on\n * this element.\n *\n * returns the xmlAttributePtr if found or NULL\n */\n\nxmlAttributePtr\nxmlGetDtdQAttrDesc(xmlDtdPtr dtd, const xmlChar *elem, const xmlChar *name,\n\t          const xmlChar *prefix) {\n    xmlAttributeTablePtr table;\n\n    if (dtd == NULL) return(NULL);\n    if (dtd->attributes == NULL) return(NULL);\n    table = (xmlAttributeTablePtr) dtd->attributes;\n\n    return(xmlHashLookup3(table, name, prefix, elem));\n}\n\n/**\n * xmlGetDtdNotationDesc:\n * @dtd:  a pointer to the DtD to search\n * @name:  the notation name\n *\n * Search the DTD for the description of this notation\n *\n * returns the xmlNotationPtr if found or NULL\n */\n\nxmlNotationPtr\nxmlGetDtdNotationDesc(xmlDtdPtr dtd, const xmlChar *name) {\n    xmlNotationTablePtr table;\n\n    if (dtd == NULL) return(NULL);\n    if (dtd->notations == NULL) return(NULL);\n    table = (xmlNotationTablePtr) dtd->notations;\n\n    return(xmlHashLookup(table, name));\n}\n\n#if defined(LIBXML_VALID_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)\n/**\n * xmlValidateNotationUse:\n * @ctxt:  the validation context\n * @doc:  the document\n * @notationName:  the notation name to check\n *\n * Validate that the given name match a notation declaration.\n * - [ VC: Notation Declared ]\n *\n * returns 1 if valid or 0 otherwise\n */\n\nint\nxmlValidateNotationUse(xmlValidCtxtPtr ctxt, xmlDocPtr doc,\n                       const xmlChar *notationName) {\n    xmlNotationPtr notaDecl;\n    if ((doc == NULL) || (doc->intSubset == NULL) ||\n        (notationName == NULL)) return(-1);\n\n    notaDecl = xmlGetDtdNotationDesc(doc->intSubset, notationName);\n    if ((notaDecl == NULL) && (doc->extSubset != NULL))\n\tnotaDecl = xmlGetDtdNotationDesc(doc->extSubset, notationName);\n\n    if ((notaDecl == NULL) && (ctxt != NULL)) {\n\txmlErrValidNode(ctxt, (xmlNodePtr) doc, XML_DTD_UNKNOWN_NOTATION,\n\t                \"NOTATION %s is not declared\\n\",\n\t\t        notationName, NULL, NULL);\n\treturn(0);\n    }\n    return(1);\n}\n#endif /* LIBXML_VALID_ENABLED or LIBXML_SCHEMAS_ENABLED */\n\n/**\n * xmlIsMixedElement:\n * @doc:  the document\n * @name:  the element name\n *\n * Search in the DtDs whether an element accept Mixed content (or ANY)\n * basically if it is supposed to accept text childs\n *\n * returns 0 if no, 1 if yes, and -1 if no element description is available\n */\n\nint\nxmlIsMixedElement(xmlDocPtr doc, const xmlChar *name) {\n    xmlElementPtr elemDecl;\n\n    if ((doc == NULL) || (doc->intSubset == NULL)) return(-1);\n\n    elemDecl = xmlGetDtdElementDesc(doc->intSubset, name);\n    if ((elemDecl == NULL) && (doc->extSubset != NULL))\n\telemDecl = xmlGetDtdElementDesc(doc->extSubset, name);\n    if (elemDecl == NULL) return(-1);\n    switch (elemDecl->etype) {\n\tcase XML_ELEMENT_TYPE_UNDEFINED:\n\t    return(-1);\n\tcase XML_ELEMENT_TYPE_ELEMENT:\n\t    return(0);\n        case XML_ELEMENT_TYPE_EMPTY:\n\t    /*\n\t     * return 1 for EMPTY since we want VC error to pop up\n\t     * on <empty>     </empty> for example\n\t     */\n\tcase XML_ELEMENT_TYPE_ANY:\n\tcase XML_ELEMENT_TYPE_MIXED:\n\t    return(1);\n    }\n    return(1);\n}\n\n#ifdef LIBXML_VALID_ENABLED\n\nstatic int\nxmlIsDocNameStartChar(xmlDocPtr doc, int c) {\n    if ((doc == NULL) || (doc->properties & XML_DOC_OLD10) == 0) {\n        /*\n\t * Use the new checks of production [4] [4a] amd [5] of the\n\t * Update 5 of XML-1.0\n\t */\n\tif (((c >= 'a') && (c <= 'z')) ||\n\t    ((c >= 'A') && (c <= 'Z')) ||\n\t    (c == '_') || (c == ':') ||\n\t    ((c >= 0xC0) && (c <= 0xD6)) ||\n\t    ((c >= 0xD8) && (c <= 0xF6)) ||\n\t    ((c >= 0xF8) && (c <= 0x2FF)) ||\n\t    ((c >= 0x370) && (c <= 0x37D)) ||\n\t    ((c >= 0x37F) && (c <= 0x1FFF)) ||\n\t    ((c >= 0x200C) && (c <= 0x200D)) ||\n\t    ((c >= 0x2070) && (c <= 0x218F)) ||\n\t    ((c >= 0x2C00) && (c <= 0x2FEF)) ||\n\t    ((c >= 0x3001) && (c <= 0xD7FF)) ||\n\t    ((c >= 0xF900) && (c <= 0xFDCF)) ||\n\t    ((c >= 0xFDF0) && (c <= 0xFFFD)) ||\n\t    ((c >= 0x10000) && (c <= 0xEFFFF)))\n\t    return(1);\n    } else {\n        if (IS_LETTER(c) || (c == '_') || (c == ':'))\n\t    return(1);\n    }\n    return(0);\n}\n\nstatic int\nxmlIsDocNameChar(xmlDocPtr doc, int c) {\n    if ((doc == NULL) || (doc->properties & XML_DOC_OLD10) == 0) {\n        /*\n\t * Use the new checks of production [4] [4a] amd [5] of the\n\t * Update 5 of XML-1.0\n\t */\n\tif (((c >= 'a') && (c <= 'z')) ||\n\t    ((c >= 'A') && (c <= 'Z')) ||\n\t    ((c >= '0') && (c <= '9')) || /* !start */\n\t    (c == '_') || (c == ':') ||\n\t    (c == '-') || (c == '.') || (c == 0xB7) || /* !start */\n\t    ((c >= 0xC0) && (c <= 0xD6)) ||\n\t    ((c >= 0xD8) && (c <= 0xF6)) ||\n\t    ((c >= 0xF8) && (c <= 0x2FF)) ||\n\t    ((c >= 0x300) && (c <= 0x36F)) || /* !start */\n\t    ((c >= 0x370) && (c <= 0x37D)) ||\n\t    ((c >= 0x37F) && (c <= 0x1FFF)) ||\n\t    ((c >= 0x200C) && (c <= 0x200D)) ||\n\t    ((c >= 0x203F) && (c <= 0x2040)) || /* !start */\n\t    ((c >= 0x2070) && (c <= 0x218F)) ||\n\t    ((c >= 0x2C00) && (c <= 0x2FEF)) ||\n\t    ((c >= 0x3001) && (c <= 0xD7FF)) ||\n\t    ((c >= 0xF900) && (c <= 0xFDCF)) ||\n\t    ((c >= 0xFDF0) && (c <= 0xFFFD)) ||\n\t    ((c >= 0x10000) && (c <= 0xEFFFF)))\n\t     return(1);\n    } else {\n        if ((IS_LETTER(c)) || (IS_DIGIT(c)) ||\n            (c == '.') || (c == '-') ||\n\t    (c == '_') || (c == ':') ||\n\t    (IS_COMBINING(c)) ||\n\t    (IS_EXTENDER(c)))\n\t    return(1);\n    }\n    return(0);\n}\n\n/**\n * xmlValidateNameValue:\n * @doc:  pointer to the document or NULL\n * @value:  an Name value\n *\n * Validate that the given value match Name production\n *\n * returns 1 if valid or 0 otherwise\n */\n\nstatic int\nxmlValidateNameValueInternal(xmlDocPtr doc, const xmlChar *value) {\n    const xmlChar *cur;\n    int val, len;\n\n    if (value == NULL) return(0);\n    cur = value;\n    val = xmlStringCurrentChar(NULL, cur, &len);\n    cur += len;\n    if (!xmlIsDocNameStartChar(doc, val))\n\treturn(0);\n\n    val = xmlStringCurrentChar(NULL, cur, &len);\n    cur += len;\n    while (xmlIsDocNameChar(doc, val)) {\n\tval = xmlStringCurrentChar(NULL, cur, &len);\n\tcur += len;\n    }\n\n    if (val != 0) return(0);\n\n    return(1);\n}\n\n/**\n * xmlValidateNameValue:\n * @value:  an Name value\n *\n * Validate that the given value match Name production\n *\n * returns 1 if valid or 0 otherwise\n */\n\nint\nxmlValidateNameValue(const xmlChar *value) {\n    return(xmlValidateNameValueInternal(NULL, value));\n}\n\n/**\n * xmlValidateNamesValueInternal:\n * @doc:  pointer to the document or NULL\n * @value:  an Names value\n *\n * Validate that the given value match Names production\n *\n * returns 1 if valid or 0 otherwise\n */\n\nstatic int\nxmlValidateNamesValueInternal(xmlDocPtr doc, const xmlChar *value) {\n    const xmlChar *cur;\n    int val, len;\n\n    if (value == NULL) return(0);\n    cur = value;\n    val = xmlStringCurrentChar(NULL, cur, &len);\n    cur += len;\n\n    if (!xmlIsDocNameStartChar(doc, val))\n\treturn(0);\n\n    val = xmlStringCurrentChar(NULL, cur, &len);\n    cur += len;\n    while (xmlIsDocNameChar(doc, val)) {\n\tval = xmlStringCurrentChar(NULL, cur, &len);\n\tcur += len;\n    }\n\n    /* Should not test IS_BLANK(val) here -- see erratum E20*/\n    while (val == 0x20) {\n\twhile (val == 0x20) {\n\t    val = xmlStringCurrentChar(NULL, cur, &len);\n\t    cur += len;\n\t}\n\n\tif (!xmlIsDocNameStartChar(doc, val))\n\t    return(0);\n\n\tval = xmlStringCurrentChar(NULL, cur, &len);\n\tcur += len;\n\n\twhile (xmlIsDocNameChar(doc, val)) {\n\t    val = xmlStringCurrentChar(NULL, cur, &len);\n\t    cur += len;\n\t}\n    }\n\n    if (val != 0) return(0);\n\n    return(1);\n}\n\n/**\n * xmlValidateNamesValue:\n * @value:  an Names value\n *\n * Validate that the given value match Names production\n *\n * returns 1 if valid or 0 otherwise\n */\n\nint\nxmlValidateNamesValue(const xmlChar *value) {\n    return(xmlValidateNamesValueInternal(NULL, value));\n}\n\n/**\n * xmlValidateNmtokenValueInternal:\n * @doc:  pointer to the document or NULL\n * @value:  an Nmtoken value\n *\n * Validate that the given value match Nmtoken production\n *\n * [ VC: Name Token ]\n *\n * returns 1 if valid or 0 otherwise\n */\n\nstatic int\nxmlValidateNmtokenValueInternal(xmlDocPtr doc, const xmlChar *value) {\n    const xmlChar *cur;\n    int val, len;\n\n    if (value == NULL) return(0);\n    cur = value;\n    val = xmlStringCurrentChar(NULL, cur, &len);\n    cur += len;\n\n    if (!xmlIsDocNameChar(doc, val))\n\treturn(0);\n\n    val = xmlStringCurrentChar(NULL, cur, &len);\n    cur += len;\n    while (xmlIsDocNameChar(doc, val)) {\n\tval = xmlStringCurrentChar(NULL, cur, &len);\n\tcur += len;\n    }\n\n    if (val != 0) return(0);\n\n    return(1);\n}\n\n/**\n * xmlValidateNmtokenValue:\n * @value:  an Nmtoken value\n *\n * Validate that the given value match Nmtoken production\n *\n * [ VC: Name Token ]\n *\n * returns 1 if valid or 0 otherwise\n */\n\nint\nxmlValidateNmtokenValue(const xmlChar *value) {\n    return(xmlValidateNmtokenValueInternal(NULL, value));\n}\n\n/**\n * xmlValidateNmtokensValueInternal:\n * @doc:  pointer to the document or NULL\n * @value:  an Nmtokens value\n *\n * Validate that the given value match Nmtokens production\n *\n * [ VC: Name Token ]\n *\n * returns 1 if valid or 0 otherwise\n */\n\nstatic int\nxmlValidateNmtokensValueInternal(xmlDocPtr doc, const xmlChar *value) {\n    const xmlChar *cur;\n    int val, len;\n\n    if (value == NULL) return(0);\n    cur = value;\n    val = xmlStringCurrentChar(NULL, cur, &len);\n    cur += len;\n\n    while (IS_BLANK(val)) {\n\tval = xmlStringCurrentChar(NULL, cur, &len);\n\tcur += len;\n    }\n\n    if (!xmlIsDocNameChar(doc, val))\n\treturn(0);\n\n    while (xmlIsDocNameChar(doc, val)) {\n\tval = xmlStringCurrentChar(NULL, cur, &len);\n\tcur += len;\n    }\n\n    /* Should not test IS_BLANK(val) here -- see erratum E20*/\n    while (val == 0x20) {\n\twhile (val == 0x20) {\n\t    val = xmlStringCurrentChar(NULL, cur, &len);\n\t    cur += len;\n\t}\n\tif (val == 0) return(1);\n\n\tif (!xmlIsDocNameChar(doc, val))\n\t    return(0);\n\n\tval = xmlStringCurrentChar(NULL, cur, &len);\n\tcur += len;\n\n\twhile (xmlIsDocNameChar(doc, val)) {\n\t    val = xmlStringCurrentChar(NULL, cur, &len);\n\t    cur += len;\n\t}\n    }\n\n    if (val != 0) return(0);\n\n    return(1);\n}\n\n/**\n * xmlValidateNmtokensValue:\n * @value:  an Nmtokens value\n *\n * Validate that the given value match Nmtokens production\n *\n * [ VC: Name Token ]\n *\n * returns 1 if valid or 0 otherwise\n */\n\nint\nxmlValidateNmtokensValue(const xmlChar *value) {\n    return(xmlValidateNmtokensValueInternal(NULL, value));\n}\n\n/**\n * xmlValidateNotationDecl:\n * @ctxt:  the validation context\n * @doc:  a document instance\n * @nota:  a notation definition\n *\n * Try to validate a single notation definition\n * basically it does the following checks as described by the\n * XML-1.0 recommendation:\n *  - it seems that no validity constraint exists on notation declarations\n * But this function get called anyway ...\n *\n * returns 1 if valid or 0 otherwise\n */\n\nint\nxmlValidateNotationDecl(xmlValidCtxtPtr ctxt ATTRIBUTE_UNUSED, xmlDocPtr doc ATTRIBUTE_UNUSED,\n                         xmlNotationPtr nota ATTRIBUTE_UNUSED) {\n    int ret = 1;\n\n    return(ret);\n}\n\n/**\n * xmlValidateAttributeValueInternal:\n * @doc: the document\n * @type:  an attribute type\n * @value:  an attribute value\n *\n * Validate that the given attribute value match  the proper production\n *\n * returns 1 if valid or 0 otherwise\n */\n\nstatic int\nxmlValidateAttributeValueInternal(xmlDocPtr doc, xmlAttributeType type,\n                                  const xmlChar *value) {\n    switch (type) {\n\tcase XML_ATTRIBUTE_ENTITIES:\n\tcase XML_ATTRIBUTE_IDREFS:\n\t    return(xmlValidateNamesValueInternal(doc, value));\n\tcase XML_ATTRIBUTE_ENTITY:\n\tcase XML_ATTRIBUTE_IDREF:\n\tcase XML_ATTRIBUTE_ID:\n\tcase XML_ATTRIBUTE_NOTATION:\n\t    return(xmlValidateNameValueInternal(doc, value));\n\tcase XML_ATTRIBUTE_NMTOKENS:\n\tcase XML_ATTRIBUTE_ENUMERATION:\n\t    return(xmlValidateNmtokensValueInternal(doc, value));\n\tcase XML_ATTRIBUTE_NMTOKEN:\n\t    return(xmlValidateNmtokenValueInternal(doc, value));\n        case XML_ATTRIBUTE_CDATA:\n\t    break;\n    }\n    return(1);\n}\n\n/**\n * xmlValidateAttributeValue:\n * @type:  an attribute type\n * @value:  an attribute value\n *\n * Validate that the given attribute value match  the proper production\n *\n * [ VC: ID ]\n * Values of type ID must match the Name production....\n *\n * [ VC: IDREF ]\n * Values of type IDREF must match the Name production, and values\n * of type IDREFS must match Names ...\n *\n * [ VC: Entity Name ]\n * Values of type ENTITY must match the Name production, values\n * of type ENTITIES must match Names ...\n *\n * [ VC: Name Token ]\n * Values of type NMTOKEN must match the Nmtoken production; values\n * of type NMTOKENS must match Nmtokens.\n *\n * returns 1 if valid or 0 otherwise\n */\nint\nxmlValidateAttributeValue(xmlAttributeType type, const xmlChar *value) {\n    return(xmlValidateAttributeValueInternal(NULL, type, value));\n}\n\n/**\n * xmlValidateAttributeValue2:\n * @ctxt:  the validation context\n * @doc:  the document\n * @name:  the attribute name (used for error reporting only)\n * @type:  the attribute type\n * @value:  the attribute value\n *\n * Validate that the given attribute value match a given type.\n * This typically cannot be done before having finished parsing\n * the subsets.\n *\n * [ VC: IDREF ]\n * Values of type IDREF must match one of the declared IDs\n * Values of type IDREFS must match a sequence of the declared IDs\n * each Name must match the value of an ID attribute on some element\n * in the XML document; i.e. IDREF values must match the value of\n * some ID attribute\n *\n * [ VC: Entity Name ]\n * Values of type ENTITY must match one declared entity\n * Values of type ENTITIES must match a sequence of declared entities\n *\n * [ VC: Notation Attributes ]\n * all notation names in the declaration must be declared.\n *\n * returns 1 if valid or 0 otherwise\n */\n\nstatic int\nxmlValidateAttributeValue2(xmlValidCtxtPtr ctxt, xmlDocPtr doc,\n      const xmlChar *name, xmlAttributeType type, const xmlChar *value) {\n    int ret = 1;\n    switch (type) {\n\tcase XML_ATTRIBUTE_IDREFS:\n\tcase XML_ATTRIBUTE_IDREF:\n\tcase XML_ATTRIBUTE_ID:\n\tcase XML_ATTRIBUTE_NMTOKENS:\n\tcase XML_ATTRIBUTE_ENUMERATION:\n\tcase XML_ATTRIBUTE_NMTOKEN:\n        case XML_ATTRIBUTE_CDATA:\n\t    break;\n\tcase XML_ATTRIBUTE_ENTITY: {\n\t    xmlEntityPtr ent;\n\n\t    ent = xmlGetDocEntity(doc, value);\n\t    /* yeah it's a bit messy... */\n\t    if ((ent == NULL) && (doc->standalone == 1)) {\n\t\tdoc->standalone = 0;\n\t\tent = xmlGetDocEntity(doc, value);\n\t    }\n\t    if (ent == NULL) {\n\t\txmlErrValidNode(ctxt, (xmlNodePtr) doc,\n\t\t\t\tXML_DTD_UNKNOWN_ENTITY,\n   \"ENTITY attribute %s reference an unknown entity \\\"%s\\\"\\n\",\n\t\t       name, value, NULL);\n\t\tret = 0;\n\t    } else if (ent->etype != XML_EXTERNAL_GENERAL_UNPARSED_ENTITY) {\n\t\txmlErrValidNode(ctxt, (xmlNodePtr) doc,\n\t\t\t\tXML_DTD_ENTITY_TYPE,\n   \"ENTITY attribute %s reference an entity \\\"%s\\\" of wrong type\\n\",\n\t\t       name, value, NULL);\n\t\tret = 0;\n\t    }\n\t    break;\n        }\n\tcase XML_ATTRIBUTE_ENTITIES: {\n\t    xmlChar *dup, *nam = NULL, *cur, save;\n\t    xmlEntityPtr ent;\n\n\t    dup = xmlStrdup(value);\n\t    if (dup == NULL)\n\t\treturn(0);\n\t    cur = dup;\n\t    while (*cur != 0) {\n\t\tnam = cur;\n\t\twhile ((*cur != 0) && (!IS_BLANK_CH(*cur))) cur++;\n\t\tsave = *cur;\n\t\t*cur = 0;\n\t\tent = xmlGetDocEntity(doc, nam);\n\t\tif (ent == NULL) {\n\t\t    xmlErrValidNode(ctxt, (xmlNodePtr) doc,\n\t\t\t\t    XML_DTD_UNKNOWN_ENTITY,\n       \"ENTITIES attribute %s reference an unknown entity \\\"%s\\\"\\n\",\n\t\t\t   name, nam, NULL);\n\t\t    ret = 0;\n\t\t} else if (ent->etype != XML_EXTERNAL_GENERAL_UNPARSED_ENTITY) {\n\t\t    xmlErrValidNode(ctxt, (xmlNodePtr) doc,\n\t\t\t\t    XML_DTD_ENTITY_TYPE,\n       \"ENTITIES attribute %s reference an entity \\\"%s\\\" of wrong type\\n\",\n\t\t\t   name, nam, NULL);\n\t\t    ret = 0;\n\t\t}\n\t\tif (save == 0)\n\t\t    break;\n\t\t*cur = save;\n\t\twhile (IS_BLANK_CH(*cur)) cur++;\n\t    }\n\t    xmlFree(dup);\n\t    break;\n\t}\n\tcase XML_ATTRIBUTE_NOTATION: {\n\t    xmlNotationPtr nota;\n\n\t    nota = xmlGetDtdNotationDesc(doc->intSubset, value);\n\t    if ((nota == NULL) && (doc->extSubset != NULL))\n\t\tnota = xmlGetDtdNotationDesc(doc->extSubset, value);\n\n\t    if (nota == NULL) {\n\t\txmlErrValidNode(ctxt, (xmlNodePtr) doc,\n\t\t                XML_DTD_UNKNOWN_NOTATION,\n       \"NOTATION attribute %s reference an unknown notation \\\"%s\\\"\\n\",\n\t\t       name, value, NULL);\n\t\tret = 0;\n\t    }\n\t    break;\n        }\n    }\n    return(ret);\n}\n\n/**\n * xmlValidCtxtNormalizeAttributeValue:\n * @ctxt: the validation context\n * @doc:  the document\n * @elem:  the parent\n * @name:  the attribute name\n * @value:  the attribute value\n * @ctxt:  the validation context or NULL\n *\n * Does the validation related extra step of the normalization of attribute\n * values:\n *\n * If the declared value is not CDATA, then the XML processor must further\n * process the normalized attribute value by discarding any leading and\n * trailing space (#x20) characters, and by replacing sequences of space\n * (#x20) characters by single space (#x20) character.\n *\n * Also  check VC: Standalone Document Declaration in P32, and update\n *  ctxt->valid accordingly\n *\n * returns a new normalized string if normalization is needed, NULL otherwise\n *      the caller must free the returned value.\n */\n\nxmlChar *\nxmlValidCtxtNormalizeAttributeValue(xmlValidCtxtPtr ctxt, xmlDocPtr doc,\n\t     xmlNodePtr elem, const xmlChar *name, const xmlChar *value) {\n    xmlChar *ret, *dst;\n    const xmlChar *src;\n    xmlAttributePtr attrDecl = NULL;\n    int extsubset = 0;\n\n    if (doc == NULL) return(NULL);\n    if (elem == NULL) return(NULL);\n    if (name == NULL) return(NULL);\n    if (value == NULL) return(NULL);\n\n    if ((elem->ns != NULL) && (elem->ns->prefix != NULL)) {\n\txmlChar fn[50];\n\txmlChar *fullname;\n\n\tfullname = xmlBuildQName(elem->name, elem->ns->prefix, fn, 50);\n\tif (fullname == NULL)\n\t    return(NULL);\n\tattrDecl = xmlGetDtdAttrDesc(doc->intSubset, fullname, name);\n\tif ((attrDecl == NULL) && (doc->extSubset != NULL)) {\n\t    attrDecl = xmlGetDtdAttrDesc(doc->extSubset, fullname, name);\n\t    if (attrDecl != NULL)\n\t\textsubset = 1;\n\t}\n\tif ((fullname != fn) && (fullname != elem->name))\n\t    xmlFree(fullname);\n    }\n    if ((attrDecl == NULL) && (doc->intSubset != NULL))\n\tattrDecl = xmlGetDtdAttrDesc(doc->intSubset, elem->name, name);\n    if ((attrDecl == NULL) && (doc->extSubset != NULL)) {\n\tattrDecl = xmlGetDtdAttrDesc(doc->extSubset, elem->name, name);\n\tif (attrDecl != NULL)\n\t    extsubset = 1;\n    }\n\n    if (attrDecl == NULL)\n\treturn(NULL);\n    if (attrDecl->atype == XML_ATTRIBUTE_CDATA)\n\treturn(NULL);\n\n    ret = xmlStrdup(value);\n    if (ret == NULL)\n\treturn(NULL);\n    src = value;\n    dst = ret;\n    while (*src == 0x20) src++;\n    while (*src != 0) {\n\tif (*src == 0x20) {\n\t    while (*src == 0x20) src++;\n\t    if (*src != 0)\n\t\t*dst++ = 0x20;\n\t} else {\n\t    *dst++ = *src++;\n\t}\n    }\n    *dst = 0;\n    if ((doc->standalone) && (extsubset == 1) && (!xmlStrEqual(value, ret))) {\n\txmlErrValidNode(ctxt, elem, XML_DTD_NOT_STANDALONE,\n\"standalone: %s on %s value had to be normalized based on external subset declaration\\n\",\n\t       name, elem->name, NULL);\n\tctxt->valid = 0;\n    }\n    return(ret);\n}\n\n/**\n * xmlValidNormalizeAttributeValue:\n * @doc:  the document\n * @elem:  the parent\n * @name:  the attribute name\n * @value:  the attribute value\n *\n * Does the validation related extra step of the normalization of attribute\n * values:\n *\n * If the declared value is not CDATA, then the XML processor must further\n * process the normalized attribute value by discarding any leading and\n * trailing space (#x20) characters, and by replacing sequences of space\n * (#x20) characters by single space (#x20) character.\n *\n * Returns a new normalized string if normalization is needed, NULL otherwise\n *      the caller must free the returned value.\n */\n\nxmlChar *\nxmlValidNormalizeAttributeValue(xmlDocPtr doc, xmlNodePtr elem,\n\t\t\t        const xmlChar *name, const xmlChar *value) {\n    xmlChar *ret, *dst;\n    const xmlChar *src;\n    xmlAttributePtr attrDecl = NULL;\n\n    if (doc == NULL) return(NULL);\n    if (elem == NULL) return(NULL);\n    if (name == NULL) return(NULL);\n    if (value == NULL) return(NULL);\n\n    if ((elem->ns != NULL) && (elem->ns->prefix != NULL)) {\n\txmlChar fn[50];\n\txmlChar *fullname;\n\n\tfullname = xmlBuildQName(elem->name, elem->ns->prefix, fn, 50);\n\tif (fullname == NULL)\n\t    return(NULL);\n\tif ((fullname != fn) && (fullname != elem->name))\n\t    xmlFree(fullname);\n    }\n    attrDecl = xmlGetDtdAttrDesc(doc->intSubset, elem->name, name);\n    if ((attrDecl == NULL) && (doc->extSubset != NULL))\n\tattrDecl = xmlGetDtdAttrDesc(doc->extSubset, elem->name, name);\n\n    if (attrDecl == NULL)\n\treturn(NULL);\n    if (attrDecl->atype == XML_ATTRIBUTE_CDATA)\n\treturn(NULL);\n\n    ret = xmlStrdup(value);\n    if (ret == NULL)\n\treturn(NULL);\n    src = value;\n    dst = ret;\n    while (*src == 0x20) src++;\n    while (*src != 0) {\n\tif (*src == 0x20) {\n\t    while (*src == 0x20) src++;\n\t    if (*src != 0)\n\t\t*dst++ = 0x20;\n\t} else {\n\t    *dst++ = *src++;\n\t}\n    }\n    *dst = 0;\n    return(ret);\n}\n\nstatic void\nxmlValidateAttributeIdCallback(void *payload, void *data,\n\t                       const xmlChar *name ATTRIBUTE_UNUSED) {\n    xmlAttributePtr attr = (xmlAttributePtr) payload;\n    int *count = (int *) data;\n    if (attr->atype == XML_ATTRIBUTE_ID) (*count)++;\n}\n\n/**\n * xmlValidateAttributeDecl:\n * @ctxt:  the validation context\n * @doc:  a document instance\n * @attr:  an attribute definition\n *\n * Try to validate a single attribute definition\n * basically it does the following checks as described by the\n * XML-1.0 recommendation:\n *  - [ VC: Attribute Default Legal ]\n *  - [ VC: Enumeration ]\n *  - [ VC: ID Attribute Default ]\n *\n * The ID/IDREF uniqueness and matching are done separately\n *\n * returns 1 if valid or 0 otherwise\n */\n\nint\nxmlValidateAttributeDecl(xmlValidCtxtPtr ctxt, xmlDocPtr doc,\n                         xmlAttributePtr attr) {\n    int ret = 1;\n    int val;\n    CHECK_DTD;\n    if(attr == NULL) return(1);\n\n    /* Attribute Default Legal */\n    /* Enumeration */\n    if (attr->defaultValue != NULL) {\n\tval = xmlValidateAttributeValueInternal(doc, attr->atype,\n\t                                        attr->defaultValue);\n\tif (val == 0) {\n\t    xmlErrValidNode(ctxt, (xmlNodePtr) attr, XML_DTD_ATTRIBUTE_DEFAULT,\n\t       \"Syntax of default value for attribute %s of %s is not valid\\n\",\n\t           attr->name, attr->elem, NULL);\n\t}\n        ret &= val;\n    }\n\n    /* ID Attribute Default */\n    if ((attr->atype == XML_ATTRIBUTE_ID)&&\n        (attr->def != XML_ATTRIBUTE_IMPLIED) &&\n\t(attr->def != XML_ATTRIBUTE_REQUIRED)) {\n\txmlErrValidNode(ctxt, (xmlNodePtr) attr, XML_DTD_ID_FIXED,\n          \"ID attribute %s of %s is not valid must be #IMPLIED or #REQUIRED\\n\",\n\t       attr->name, attr->elem, NULL);\n\tret = 0;\n    }\n\n    /* One ID per Element Type */\n    if (attr->atype == XML_ATTRIBUTE_ID) {\n        int nbId;\n\n\t/* the trick is that we parse DtD as their own internal subset */\n        xmlElementPtr elem = xmlGetDtdElementDesc(doc->intSubset,\n\t                                          attr->elem);\n\tif (elem != NULL) {\n\t    nbId = xmlScanIDAttributeDecl(NULL, elem, 0);\n\t} else {\n\t    xmlAttributeTablePtr table;\n\n\t    /*\n\t     * The attribute may be declared in the internal subset and the\n\t     * element in the external subset.\n\t     */\n\t    nbId = 0;\n\t    if (doc->intSubset != NULL) {\n\t\ttable = (xmlAttributeTablePtr) doc->intSubset->attributes;\n\t\txmlHashScan3(table, NULL, NULL, attr->elem,\n\t\t\t     xmlValidateAttributeIdCallback, &nbId);\n\t    }\n\t}\n\tif (nbId > 1) {\n\n\t    xmlErrValidNodeNr(ctxt, (xmlNodePtr) attr, XML_DTD_ID_SUBSET,\n       \"Element %s has %d ID attribute defined in the internal subset : %s\\n\",\n\t\t   attr->elem, nbId, attr->name);\n\t} else if (doc->extSubset != NULL) {\n\t    int extId = 0;\n\t    elem = xmlGetDtdElementDesc(doc->extSubset, attr->elem);\n\t    if (elem != NULL) {\n\t\textId = xmlScanIDAttributeDecl(NULL, elem, 0);\n\t    }\n\t    if (extId > 1) {\n\t\txmlErrValidNodeNr(ctxt, (xmlNodePtr) attr, XML_DTD_ID_SUBSET,\n       \"Element %s has %d ID attribute defined in the external subset : %s\\n\",\n\t\t       attr->elem, extId, attr->name);\n\t    } else if (extId + nbId > 1) {\n\t\txmlErrValidNode(ctxt, (xmlNodePtr) attr, XML_DTD_ID_SUBSET,\n\"Element %s has ID attributes defined in the internal and external subset : %s\\n\",\n\t\t       attr->elem, attr->name, NULL);\n\t    }\n\t}\n    }\n\n    /* Validity Constraint: Enumeration */\n    if ((attr->defaultValue != NULL) && (attr->tree != NULL)) {\n        xmlEnumerationPtr tree = attr->tree;\n\twhile (tree != NULL) {\n\t    if (xmlStrEqual(tree->name, attr->defaultValue)) break;\n\t    tree = tree->next;\n\t}\n\tif (tree == NULL) {\n\t    xmlErrValidNode(ctxt, (xmlNodePtr) attr, XML_DTD_ATTRIBUTE_VALUE,\n\"Default value \\\"%s\\\" for attribute %s of %s is not among the enumerated set\\n\",\n\t\t   attr->defaultValue, attr->name, attr->elem);\n\t    ret = 0;\n\t}\n    }\n\n    return(ret);\n}\n\n/**\n * xmlValidateElementDecl:\n * @ctxt:  the validation context\n * @doc:  a document instance\n * @elem:  an element definition\n *\n * Try to validate a single element definition\n * basically it does the following checks as described by the\n * XML-1.0 recommendation:\n *  - [ VC: One ID per Element Type ]\n *  - [ VC: No Duplicate Types ]\n *  - [ VC: Unique Element Type Declaration ]\n *\n * returns 1 if valid or 0 otherwise\n */\n\nint\nxmlValidateElementDecl(xmlValidCtxtPtr ctxt, xmlDocPtr doc,\n                       xmlElementPtr elem) {\n    int ret = 1;\n    xmlElementPtr tst;\n\n    CHECK_DTD;\n\n    if (elem == NULL) return(1);\n\n#if 0\n#ifdef LIBXML_REGEXP_ENABLED\n    /* Build the regexp associated to the content model */\n    ret = xmlValidBuildContentModel(ctxt, elem);\n#endif\n#endif\n\n    /* No Duplicate Types */\n    if (elem->etype == XML_ELEMENT_TYPE_MIXED) {\n\txmlElementContentPtr cur, next;\n        const xmlChar *name;\n\n\tcur = elem->content;\n\twhile (cur != NULL) {\n\t    if (cur->type != XML_ELEMENT_CONTENT_OR) break;\n\t    if (cur->c1 == NULL) break;\n\t    if (cur->c1->type == XML_ELEMENT_CONTENT_ELEMENT) {\n\t\tname = cur->c1->name;\n\t\tnext = cur->c2;\n\t\twhile (next != NULL) {\n\t\t    if (next->type == XML_ELEMENT_CONTENT_ELEMENT) {\n\t\t        if ((xmlStrEqual(next->name, name)) &&\n\t\t\t    (xmlStrEqual(next->prefix, cur->c1->prefix))) {\n\t\t\t    if (cur->c1->prefix == NULL) {\n\t\t\t\txmlErrValidNode(ctxt, (xmlNodePtr) elem, XML_DTD_CONTENT_ERROR,\n\t\t   \"Definition of %s has duplicate references of %s\\n\",\n\t\t\t\t       elem->name, name, NULL);\n\t\t\t    } else {\n\t\t\t\txmlErrValidNode(ctxt, (xmlNodePtr) elem, XML_DTD_CONTENT_ERROR,\n\t\t   \"Definition of %s has duplicate references of %s:%s\\n\",\n\t\t\t\t       elem->name, cur->c1->prefix, name);\n\t\t\t    }\n\t\t\t    ret = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t    }\n\t\t    if (next->c1 == NULL) break;\n\t\t    if (next->c1->type != XML_ELEMENT_CONTENT_ELEMENT) break;\n\t\t    if ((xmlStrEqual(next->c1->name, name)) &&\n\t\t        (xmlStrEqual(next->c1->prefix, cur->c1->prefix))) {\n\t\t\tif (cur->c1->prefix == NULL) {\n\t\t\t    xmlErrValidNode(ctxt, (xmlNodePtr) elem, XML_DTD_CONTENT_ERROR,\n\t       \"Definition of %s has duplicate references to %s\\n\",\n\t\t\t\t   elem->name, name, NULL);\n\t\t\t} else {\n\t\t\t    xmlErrValidNode(ctxt, (xmlNodePtr) elem, XML_DTD_CONTENT_ERROR,\n\t       \"Definition of %s has duplicate references to %s:%s\\n\",\n\t\t\t\t   elem->name, cur->c1->prefix, name);\n\t\t\t}\n\t\t\tret = 0;\n\t\t    }\n\t\t    next = next->c2;\n\t\t}\n\t    }\n\t    cur = cur->c2;\n\t}\n    }\n\n    /* VC: Unique Element Type Declaration */\n    tst = xmlGetDtdElementDesc(doc->intSubset, elem->name);\n    if ((tst != NULL ) && (tst != elem) &&\n\t((tst->prefix == elem->prefix) ||\n\t (xmlStrEqual(tst->prefix, elem->prefix))) &&\n\t(tst->etype != XML_ELEMENT_TYPE_UNDEFINED)) {\n\txmlErrValidNode(ctxt, (xmlNodePtr) elem, XML_DTD_ELEM_REDEFINED,\n\t                \"Redefinition of element %s\\n\",\n\t\t       elem->name, NULL, NULL);\n\tret = 0;\n    }\n    tst = xmlGetDtdElementDesc(doc->extSubset, elem->name);\n    if ((tst != NULL ) && (tst != elem) &&\n\t((tst->prefix == elem->prefix) ||\n\t (xmlStrEqual(tst->prefix, elem->prefix))) &&\n\t(tst->etype != XML_ELEMENT_TYPE_UNDEFINED)) {\n\txmlErrValidNode(ctxt, (xmlNodePtr) elem, XML_DTD_ELEM_REDEFINED,\n\t                \"Redefinition of element %s\\n\",\n\t\t       elem->name, NULL, NULL);\n\tret = 0;\n    }\n    /* One ID per Element Type\n     * already done when registering the attribute\n    if (xmlScanIDAttributeDecl(ctxt, elem) > 1) {\n\tret = 0;\n    } */\n    return(ret);\n}\n\n/**\n * xmlValidateOneAttribute:\n * @ctxt:  the validation context\n * @doc:  a document instance\n * @elem:  an element instance\n * @attr:  an attribute instance\n * @value:  the attribute value (without entities processing)\n *\n * Try to validate a single attribute for an element\n * basically it does the following checks as described by the\n * XML-1.0 recommendation:\n *  - [ VC: Attribute Value Type ]\n *  - [ VC: Fixed Attribute Default ]\n *  - [ VC: Entity Name ]\n *  - [ VC: Name Token ]\n *  - [ VC: ID ]\n *  - [ VC: IDREF ]\n *  - [ VC: Entity Name ]\n *  - [ VC: Notation Attributes ]\n *\n * The ID/IDREF uniqueness and matching are done separately\n *\n * returns 1 if valid or 0 otherwise\n */\n\nint\nxmlValidateOneAttribute(xmlValidCtxtPtr ctxt, xmlDocPtr doc,\n                        xmlNodePtr elem, xmlAttrPtr attr, const xmlChar *value)\n{\n    xmlAttributePtr attrDecl =  NULL;\n    int val;\n    int ret = 1;\n\n    CHECK_DTD;\n    if ((elem == NULL) || (elem->name == NULL)) return(0);\n    if ((attr == NULL) || (attr->name == NULL)) return(0);\n\n    if ((elem->ns != NULL) && (elem->ns->prefix != NULL)) {\n\txmlChar fn[50];\n\txmlChar *fullname;\n\n\tfullname = xmlBuildQName(elem->name, elem->ns->prefix, fn, 50);\n\tif (fullname == NULL)\n\t    return(0);\n\tif (attr->ns != NULL) {\n\t    attrDecl = xmlGetDtdQAttrDesc(doc->intSubset, fullname,\n\t\t                          attr->name, attr->ns->prefix);\n\t    if ((attrDecl == NULL) && (doc->extSubset != NULL))\n\t\tattrDecl = xmlGetDtdQAttrDesc(doc->extSubset, fullname,\n\t\t\t\t\t      attr->name, attr->ns->prefix);\n\t} else {\n\t    attrDecl = xmlGetDtdAttrDesc(doc->intSubset, fullname, attr->name);\n\t    if ((attrDecl == NULL) && (doc->extSubset != NULL))\n\t\tattrDecl = xmlGetDtdAttrDesc(doc->extSubset,\n\t\t\t\t\t     fullname, attr->name);\n\t}\n\tif ((fullname != fn) && (fullname != elem->name))\n\t    xmlFree(fullname);\n    }\n    if (attrDecl == NULL) {\n\tif (attr->ns != NULL) {\n\t    attrDecl = xmlGetDtdQAttrDesc(doc->intSubset, elem->name,\n\t\t                          attr->name, attr->ns->prefix);\n\t    if ((attrDecl == NULL) && (doc->extSubset != NULL))\n\t\tattrDecl = xmlGetDtdQAttrDesc(doc->extSubset, elem->name,\n\t\t\t\t\t      attr->name, attr->ns->prefix);\n\t} else {\n\t    attrDecl = xmlGetDtdAttrDesc(doc->intSubset,\n\t\t                         elem->name, attr->name);\n\t    if ((attrDecl == NULL) && (doc->extSubset != NULL))\n\t\tattrDecl = xmlGetDtdAttrDesc(doc->extSubset,\n\t\t\t\t\t     elem->name, attr->name);\n\t}\n    }\n\n\n    /* Validity Constraint: Attribute Value Type */\n    if (attrDecl == NULL) {\n\txmlErrValidNode(ctxt, elem, XML_DTD_UNKNOWN_ATTRIBUTE,\n\t       \"No declaration for attribute %s of element %s\\n\",\n\t       attr->name, elem->name, NULL);\n\treturn(0);\n    }\n    attr->atype = attrDecl->atype;\n\n    val = xmlValidateAttributeValueInternal(doc, attrDecl->atype, value);\n    if (val == 0) {\n\t    xmlErrValidNode(ctxt, elem, XML_DTD_ATTRIBUTE_VALUE,\n\t   \"Syntax of value for attribute %s of %s is not valid\\n\",\n\t       attr->name, elem->name, NULL);\n        ret = 0;\n    }\n\n    /* Validity constraint: Fixed Attribute Default */\n    if (attrDecl->def == XML_ATTRIBUTE_FIXED) {\n\tif (!xmlStrEqual(value, attrDecl->defaultValue)) {\n\t    xmlErrValidNode(ctxt, elem, XML_DTD_ATTRIBUTE_DEFAULT,\n\t   \"Value for attribute %s of %s is different from default \\\"%s\\\"\\n\",\n\t\t   attr->name, elem->name, attrDecl->defaultValue);\n\t    ret = 0;\n\t}\n    }\n\n    /* Validity Constraint: ID uniqueness */\n    if (attrDecl->atype == XML_ATTRIBUTE_ID) {\n        if (xmlAddID(ctxt, doc, value, attr) == NULL)\n\t    ret = 0;\n    }\n\n    if ((attrDecl->atype == XML_ATTRIBUTE_IDREF) ||\n\t(attrDecl->atype == XML_ATTRIBUTE_IDREFS)) {\n        if (xmlAddRef(ctxt, doc, value, attr) == NULL)\n\t    ret = 0;\n    }\n\n    /* Validity Constraint: Notation Attributes */\n    if (attrDecl->atype == XML_ATTRIBUTE_NOTATION) {\n        xmlEnumerationPtr tree = attrDecl->tree;\n        xmlNotationPtr nota;\n\n        /* First check that the given NOTATION was declared */\n\tnota = xmlGetDtdNotationDesc(doc->intSubset, value);\n\tif (nota == NULL)\n\t    nota = xmlGetDtdNotationDesc(doc->extSubset, value);\n\n\tif (nota == NULL) {\n\t    xmlErrValidNode(ctxt, elem, XML_DTD_UNKNOWN_NOTATION,\n       \"Value \\\"%s\\\" for attribute %s of %s is not a declared Notation\\n\",\n\t\t   value, attr->name, elem->name);\n\t    ret = 0;\n        }\n\n\t/* Second, verify that it's among the list */\n\twhile (tree != NULL) {\n\t    if (xmlStrEqual(tree->name, value)) break;\n\t    tree = tree->next;\n\t}\n\tif (tree == NULL) {\n\t    xmlErrValidNode(ctxt, elem, XML_DTD_NOTATION_VALUE,\n\"Value \\\"%s\\\" for attribute %s of %s is not among the enumerated notations\\n\",\n\t\t   value, attr->name, elem->name);\n\t    ret = 0;\n\t}\n    }\n\n    /* Validity Constraint: Enumeration */\n    if (attrDecl->atype == XML_ATTRIBUTE_ENUMERATION) {\n        xmlEnumerationPtr tree = attrDecl->tree;\n\twhile (tree != NULL) {\n\t    if (xmlStrEqual(tree->name, value)) break;\n\t    tree = tree->next;\n\t}\n\tif (tree == NULL) {\n\t    xmlErrValidNode(ctxt, elem, XML_DTD_ATTRIBUTE_VALUE,\n       \"Value \\\"%s\\\" for attribute %s of %s is not among the enumerated set\\n\",\n\t\t   value, attr->name, elem->name);\n\t    ret = 0;\n\t}\n    }\n\n    /* Fixed Attribute Default */\n    if ((attrDecl->def == XML_ATTRIBUTE_FIXED) &&\n        (!xmlStrEqual(attrDecl->defaultValue, value))) {\n\txmlErrValidNode(ctxt, elem, XML_DTD_ATTRIBUTE_VALUE,\n\t   \"Value for attribute %s of %s must be \\\"%s\\\"\\n\",\n\t       attr->name, elem->name, attrDecl->defaultValue);\n        ret = 0;\n    }\n\n    /* Extra check for the attribute value */\n    ret &= xmlValidateAttributeValue2(ctxt, doc, attr->name,\n\t\t\t\t      attrDecl->atype, value);\n\n    return(ret);\n}\n\n/**\n * xmlValidateOneNamespace:\n * @ctxt:  the validation context\n * @doc:  a document instance\n * @elem:  an element instance\n * @prefix:  the namespace prefix\n * @ns:  an namespace declaration instance\n * @value:  the attribute value (without entities processing)\n *\n * Try to validate a single namespace declaration for an element\n * basically it does the following checks as described by the\n * XML-1.0 recommendation:\n *  - [ VC: Attribute Value Type ]\n *  - [ VC: Fixed Attribute Default ]\n *  - [ VC: Entity Name ]\n *  - [ VC: Name Token ]\n *  - [ VC: ID ]\n *  - [ VC: IDREF ]\n *  - [ VC: Entity Name ]\n *  - [ VC: Notation Attributes ]\n *\n * The ID/IDREF uniqueness and matching are done separately\n *\n * returns 1 if valid or 0 otherwise\n */\n\nint\nxmlValidateOneNamespace(xmlValidCtxtPtr ctxt, xmlDocPtr doc,\nxmlNodePtr elem, const xmlChar *prefix, xmlNsPtr ns, const xmlChar *value) {\n    /* xmlElementPtr elemDecl; */\n    xmlAttributePtr attrDecl =  NULL;\n    int val;\n    int ret = 1;\n\n    CHECK_DTD;\n    if ((elem == NULL) || (elem->name == NULL)) return(0);\n    if ((ns == NULL) || (ns->href == NULL)) return(0);\n\n    if (prefix != NULL) {\n\txmlChar fn[50];\n\txmlChar *fullname;\n\n\tfullname = xmlBuildQName(elem->name, prefix, fn, 50);\n\tif (fullname == NULL) {\n\t    xmlVErrMemory(ctxt, \"Validating namespace\");\n\t    return(0);\n\t}\n\tif (ns->prefix != NULL) {\n\t    attrDecl = xmlGetDtdQAttrDesc(doc->intSubset, fullname,\n\t\t                          ns->prefix, BAD_CAST \"xmlns\");\n\t    if ((attrDecl == NULL) && (doc->extSubset != NULL))\n\t\tattrDecl = xmlGetDtdQAttrDesc(doc->extSubset, fullname,\n\t\t\t\t\t  ns->prefix, BAD_CAST \"xmlns\");\n\t} else {\n\t    attrDecl = xmlGetDtdAttrDesc(doc->intSubset, fullname,\n\t\t                         BAD_CAST \"xmlns\");\n\t    if ((attrDecl == NULL) && (doc->extSubset != NULL))\n\t\tattrDecl = xmlGetDtdAttrDesc(doc->extSubset, fullname,\n\t\t\t                 BAD_CAST \"xmlns\");\n\t}\n\tif ((fullname != fn) && (fullname != elem->name))\n\t    xmlFree(fullname);\n    }\n    if (attrDecl == NULL) {\n\tif (ns->prefix != NULL) {\n\t    attrDecl = xmlGetDtdQAttrDesc(doc->intSubset, elem->name,\n\t\t                          ns->prefix, BAD_CAST \"xmlns\");\n\t    if ((attrDecl == NULL) && (doc->extSubset != NULL))\n\t\tattrDecl = xmlGetDtdQAttrDesc(doc->extSubset, elem->name,\n\t\t\t\t\t      ns->prefix, BAD_CAST \"xmlns\");\n\t} else {\n\t    attrDecl = xmlGetDtdAttrDesc(doc->intSubset,\n\t\t                         elem->name, BAD_CAST \"xmlns\");\n\t    if ((attrDecl == NULL) && (doc->extSubset != NULL))\n\t\tattrDecl = xmlGetDtdAttrDesc(doc->extSubset,\n\t\t\t\t\t     elem->name, BAD_CAST \"xmlns\");\n\t}\n    }\n\n\n    /* Validity Constraint: Attribute Value Type */\n    if (attrDecl == NULL) {\n\tif (ns->prefix != NULL) {\n\t    xmlErrValidNode(ctxt, elem, XML_DTD_UNKNOWN_ATTRIBUTE,\n\t\t   \"No declaration for attribute xmlns:%s of element %s\\n\",\n\t\t   ns->prefix, elem->name, NULL);\n\t} else {\n\t    xmlErrValidNode(ctxt, elem, XML_DTD_UNKNOWN_ATTRIBUTE,\n\t\t   \"No declaration for attribute xmlns of element %s\\n\",\n\t\t   elem->name, NULL, NULL);\n\t}\n\treturn(0);\n    }\n\n    val = xmlValidateAttributeValueInternal(doc, attrDecl->atype, value);\n    if (val == 0) {\n\tif (ns->prefix != NULL) {\n\t    xmlErrValidNode(ctxt, elem, XML_DTD_INVALID_DEFAULT,\n\t       \"Syntax of value for attribute xmlns:%s of %s is not valid\\n\",\n\t\t   ns->prefix, elem->name, NULL);\n\t} else {\n\t    xmlErrValidNode(ctxt, elem, XML_DTD_INVALID_DEFAULT,\n\t       \"Syntax of value for attribute xmlns of %s is not valid\\n\",\n\t\t   elem->name, NULL, NULL);\n\t}\n        ret = 0;\n    }\n\n    /* Validity constraint: Fixed Attribute Default */\n    if (attrDecl->def == XML_ATTRIBUTE_FIXED) {\n\tif (!xmlStrEqual(value, attrDecl->defaultValue)) {\n\t    if (ns->prefix != NULL) {\n\t\txmlErrValidNode(ctxt, elem, XML_DTD_ATTRIBUTE_DEFAULT,\n       \"Value for attribute xmlns:%s of %s is different from default \\\"%s\\\"\\n\",\n\t\t       ns->prefix, elem->name, attrDecl->defaultValue);\n\t    } else {\n\t\txmlErrValidNode(ctxt, elem, XML_DTD_ATTRIBUTE_DEFAULT,\n       \"Value for attribute xmlns of %s is different from default \\\"%s\\\"\\n\",\n\t\t       elem->name, attrDecl->defaultValue, NULL);\n\t    }\n\t    ret = 0;\n\t}\n    }\n\n    /*\n     * Casting ns to xmlAttrPtr is wrong. We'd need separate functions\n     * xmlAddID and xmlAddRef for namespace declarations, but it makes\n     * no practical sense to use ID types anyway.\n     */\n#if 0\n    /* Validity Constraint: ID uniqueness */\n    if (attrDecl->atype == XML_ATTRIBUTE_ID) {\n        if (xmlAddID(ctxt, doc, value, (xmlAttrPtr) ns) == NULL)\n\t    ret = 0;\n    }\n\n    if ((attrDecl->atype == XML_ATTRIBUTE_IDREF) ||\n\t(attrDecl->atype == XML_ATTRIBUTE_IDREFS)) {\n        if (xmlAddRef(ctxt, doc, value, (xmlAttrPtr) ns) == NULL)\n\t    ret = 0;\n    }\n#endif\n\n    /* Validity Constraint: Notation Attributes */\n    if (attrDecl->atype == XML_ATTRIBUTE_NOTATION) {\n        xmlEnumerationPtr tree = attrDecl->tree;\n        xmlNotationPtr nota;\n\n        /* First check that the given NOTATION was declared */\n\tnota = xmlGetDtdNotationDesc(doc->intSubset, value);\n\tif (nota == NULL)\n\t    nota = xmlGetDtdNotationDesc(doc->extSubset, value);\n\n\tif (nota == NULL) {\n\t    if (ns->prefix != NULL) {\n\t\txmlErrValidNode(ctxt, elem, XML_DTD_UNKNOWN_NOTATION,\n       \"Value \\\"%s\\\" for attribute xmlns:%s of %s is not a declared Notation\\n\",\n\t\t       value, ns->prefix, elem->name);\n\t    } else {\n\t\txmlErrValidNode(ctxt, elem, XML_DTD_UNKNOWN_NOTATION,\n       \"Value \\\"%s\\\" for attribute xmlns of %s is not a declared Notation\\n\",\n\t\t       value, elem->name, NULL);\n\t    }\n\t    ret = 0;\n        }\n\n\t/* Second, verify that it's among the list */\n\twhile (tree != NULL) {\n\t    if (xmlStrEqual(tree->name, value)) break;\n\t    tree = tree->next;\n\t}\n\tif (tree == NULL) {\n\t    if (ns->prefix != NULL) {\n\t\txmlErrValidNode(ctxt, elem, XML_DTD_NOTATION_VALUE,\n\"Value \\\"%s\\\" for attribute xmlns:%s of %s is not among the enumerated notations\\n\",\n\t\t       value, ns->prefix, elem->name);\n\t    } else {\n\t\txmlErrValidNode(ctxt, elem, XML_DTD_NOTATION_VALUE,\n\"Value \\\"%s\\\" for attribute xmlns of %s is not among the enumerated notations\\n\",\n\t\t       value, elem->name, NULL);\n\t    }\n\t    ret = 0;\n\t}\n    }\n\n    /* Validity Constraint: Enumeration */\n    if (attrDecl->atype == XML_ATTRIBUTE_ENUMERATION) {\n        xmlEnumerationPtr tree = attrDecl->tree;\n\twhile (tree != NULL) {\n\t    if (xmlStrEqual(tree->name, value)) break;\n\t    tree = tree->next;\n\t}\n\tif (tree == NULL) {\n\t    if (ns->prefix != NULL) {\n\t\txmlErrValidNode(ctxt, elem, XML_DTD_ATTRIBUTE_VALUE,\n\"Value \\\"%s\\\" for attribute xmlns:%s of %s is not among the enumerated set\\n\",\n\t\t       value, ns->prefix, elem->name);\n\t    } else {\n\t\txmlErrValidNode(ctxt, elem, XML_DTD_ATTRIBUTE_VALUE,\n\"Value \\\"%s\\\" for attribute xmlns of %s is not among the enumerated set\\n\",\n\t\t       value, elem->name, NULL);\n\t    }\n\t    ret = 0;\n\t}\n    }\n\n    /* Fixed Attribute Default */\n    if ((attrDecl->def == XML_ATTRIBUTE_FIXED) &&\n        (!xmlStrEqual(attrDecl->defaultValue, value))) {\n\tif (ns->prefix != NULL) {\n\t    xmlErrValidNode(ctxt, elem, XML_DTD_ELEM_NAMESPACE,\n\t\t   \"Value for attribute xmlns:%s of %s must be \\\"%s\\\"\\n\",\n\t\t   ns->prefix, elem->name, attrDecl->defaultValue);\n\t} else {\n\t    xmlErrValidNode(ctxt, elem, XML_DTD_ELEM_NAMESPACE,\n\t\t   \"Value for attribute xmlns of %s must be \\\"%s\\\"\\n\",\n\t\t   elem->name, attrDecl->defaultValue, NULL);\n\t}\n        ret = 0;\n    }\n\n    /* Extra check for the attribute value */\n    if (ns->prefix != NULL) {\n\tret &= xmlValidateAttributeValue2(ctxt, doc, ns->prefix,\n\t\t\t\t\t  attrDecl->atype, value);\n    } else {\n\tret &= xmlValidateAttributeValue2(ctxt, doc, BAD_CAST \"xmlns\",\n\t\t\t\t\t  attrDecl->atype, value);\n    }\n\n    return(ret);\n}\n\n#ifndef  LIBXML_REGEXP_ENABLED\n/**\n * xmlValidateSkipIgnorable:\n * @ctxt:  the validation context\n * @child:  the child list\n *\n * Skip ignorable elements w.r.t. the validation process\n *\n * returns the first element to consider for validation of the content model\n */\n\nstatic xmlNodePtr\nxmlValidateSkipIgnorable(xmlNodePtr child) {\n    while (child != NULL) {\n\tswitch (child->type) {\n\t    /* These things are ignored (skipped) during validation.  */\n\t    case XML_PI_NODE:\n\t    case XML_COMMENT_NODE:\n\t    case XML_XINCLUDE_START:\n\t    case XML_XINCLUDE_END:\n\t\tchild = child->next;\n\t\tbreak;\n\t    case XML_TEXT_NODE:\n\t\tif (xmlIsBlankNode(child))\n\t\t    child = child->next;\n\t\telse\n\t\t    return(child);\n\t\tbreak;\n\t    /* keep current node */\n\t    default:\n\t\treturn(child);\n\t}\n    }\n    return(child);\n}\n\n/**\n * xmlValidateElementType:\n * @ctxt:  the validation context\n *\n * Try to validate the content model of an element internal function\n *\n * returns 1 if valid or 0 ,-1 in case of error, -2 if an entity\n *           reference is found and -3 if the validation succeeded but\n *           the content model is not determinist.\n */\n\nstatic int\nxmlValidateElementType(xmlValidCtxtPtr ctxt) {\n    int ret = -1;\n    int determinist = 1;\n\n    NODE = xmlValidateSkipIgnorable(NODE);\n    if ((NODE == NULL) && (CONT == NULL))\n\treturn(1);\n    if ((NODE == NULL) &&\n\t((CONT->ocur == XML_ELEMENT_CONTENT_MULT) ||\n\t (CONT->ocur == XML_ELEMENT_CONTENT_OPT))) {\n\treturn(1);\n    }\n    if (CONT == NULL) return(-1);\n    if ((NODE != NULL) && (NODE->type == XML_ENTITY_REF_NODE))\n\treturn(-2);\n\n    /*\n     * We arrive here when more states need to be examined\n     */\ncont:\n\n    /*\n     * We just recovered from a rollback generated by a possible\n     * epsilon transition, go directly to the analysis phase\n     */\n    if (STATE == ROLLBACK_PARENT) {\n\tDEBUG_VALID_MSG(\"restored parent branch\");\n\tDEBUG_VALID_STATE(NODE, CONT)\n\tret = 1;\n\tgoto analyze;\n    }\n\n    DEBUG_VALID_STATE(NODE, CONT)\n    /*\n     * we may have to save a backup state here. This is the equivalent\n     * of handling epsilon transition in NFAs.\n     */\n    if ((CONT != NULL) &&\n\t((CONT->parent == NULL) ||\n\t (CONT->parent->type != XML_ELEMENT_CONTENT_OR)) &&\n\t((CONT->ocur == XML_ELEMENT_CONTENT_MULT) ||\n\t (CONT->ocur == XML_ELEMENT_CONTENT_OPT) ||\n\t ((CONT->ocur == XML_ELEMENT_CONTENT_PLUS) && (OCCURRENCE)))) {\n\tDEBUG_VALID_MSG(\"saving parent branch\");\n\tif (vstateVPush(ctxt, CONT, NODE, DEPTH, OCCURS, ROLLBACK_PARENT) < 0)\n\t    return(0);\n    }\n\n\n    /*\n     * Check first if the content matches\n     */\n    switch (CONT->type) {\n\tcase XML_ELEMENT_CONTENT_PCDATA:\n\t    if (NODE == NULL) {\n\t\tDEBUG_VALID_MSG(\"pcdata failed no node\");\n\t\tret = 0;\n\t\tbreak;\n\t    }\n\t    if (NODE->type == XML_TEXT_NODE) {\n\t\tDEBUG_VALID_MSG(\"pcdata found, skip to next\");\n\t\t/*\n\t\t * go to next element in the content model\n\t\t * skipping ignorable elems\n\t\t */\n\t\tdo {\n\t\t    NODE = NODE->next;\n\t\t    NODE = xmlValidateSkipIgnorable(NODE);\n\t\t    if ((NODE != NULL) &&\n\t\t\t(NODE->type == XML_ENTITY_REF_NODE))\n\t\t\treturn(-2);\n\t\t} while ((NODE != NULL) &&\n\t\t\t ((NODE->type != XML_ELEMENT_NODE) &&\n\t\t\t  (NODE->type != XML_TEXT_NODE) &&\n\t\t\t  (NODE->type != XML_CDATA_SECTION_NODE)));\n                ret = 1;\n\t\tbreak;\n\t    } else {\n\t\tDEBUG_VALID_MSG(\"pcdata failed\");\n\t\tret = 0;\n\t\tbreak;\n\t    }\n\t    break;\n\tcase XML_ELEMENT_CONTENT_ELEMENT:\n\t    if (NODE == NULL) {\n\t\tDEBUG_VALID_MSG(\"element failed no node\");\n\t\tret = 0;\n\t\tbreak;\n\t    }\n\t    ret = ((NODE->type == XML_ELEMENT_NODE) &&\n\t\t   (xmlStrEqual(NODE->name, CONT->name)));\n\t    if (ret == 1) {\n\t\tif ((NODE->ns == NULL) || (NODE->ns->prefix == NULL)) {\n\t\t    ret = (CONT->prefix == NULL);\n\t\t} else if (CONT->prefix == NULL) {\n\t\t    ret = 0;\n\t\t} else {\n\t\t    ret = xmlStrEqual(NODE->ns->prefix, CONT->prefix);\n\t\t}\n\t    }\n\t    if (ret == 1) {\n\t\tDEBUG_VALID_MSG(\"element found, skip to next\");\n\t\t/*\n\t\t * go to next element in the content model\n\t\t * skipping ignorable elems\n\t\t */\n\t\tdo {\n\t\t    NODE = NODE->next;\n\t\t    NODE = xmlValidateSkipIgnorable(NODE);\n\t\t    if ((NODE != NULL) &&\n\t\t\t(NODE->type == XML_ENTITY_REF_NODE))\n\t\t\treturn(-2);\n\t\t} while ((NODE != NULL) &&\n\t\t\t ((NODE->type != XML_ELEMENT_NODE) &&\n\t\t\t  (NODE->type != XML_TEXT_NODE) &&\n\t\t\t  (NODE->type != XML_CDATA_SECTION_NODE)));\n\t    } else {\n\t\tDEBUG_VALID_MSG(\"element failed\");\n\t\tret = 0;\n\t\tbreak;\n\t    }\n\t    break;\n\tcase XML_ELEMENT_CONTENT_OR:\n\t    /*\n\t     * Small optimization.\n\t     */\n\t    if (CONT->c1->type == XML_ELEMENT_CONTENT_ELEMENT) {\n\t\tif ((NODE == NULL) ||\n\t\t    (!xmlStrEqual(NODE->name, CONT->c1->name))) {\n\t\t    DEPTH++;\n\t\t    CONT = CONT->c2;\n\t\t    goto cont;\n\t\t}\n\t\tif ((NODE->ns == NULL) || (NODE->ns->prefix == NULL)) {\n\t\t    ret = (CONT->c1->prefix == NULL);\n\t\t} else if (CONT->c1->prefix == NULL) {\n\t\t    ret = 0;\n\t\t} else {\n\t\t    ret = xmlStrEqual(NODE->ns->prefix, CONT->c1->prefix);\n\t\t}\n\t\tif (ret == 0) {\n\t\t    DEPTH++;\n\t\t    CONT = CONT->c2;\n\t\t    goto cont;\n\t\t}\n\t    }\n\n\t    /*\n\t     * save the second branch 'or' branch\n\t     */\n\t    DEBUG_VALID_MSG(\"saving 'or' branch\");\n\t    if (vstateVPush(ctxt, CONT->c2, NODE, (unsigned char)(DEPTH + 1),\n\t\t\t    OCCURS, ROLLBACK_OR) < 0)\n\t\treturn(-1);\n\t    DEPTH++;\n\t    CONT = CONT->c1;\n\t    goto cont;\n\tcase XML_ELEMENT_CONTENT_SEQ:\n\t    /*\n\t     * Small optimization.\n\t     */\n\t    if ((CONT->c1->type == XML_ELEMENT_CONTENT_ELEMENT) &&\n\t\t((CONT->c1->ocur == XML_ELEMENT_CONTENT_OPT) ||\n\t\t (CONT->c1->ocur == XML_ELEMENT_CONTENT_MULT))) {\n\t\tif ((NODE == NULL) ||\n\t\t    (!xmlStrEqual(NODE->name, CONT->c1->name))) {\n\t\t    DEPTH++;\n\t\t    CONT = CONT->c2;\n\t\t    goto cont;\n\t\t}\n\t\tif ((NODE->ns == NULL) || (NODE->ns->prefix == NULL)) {\n\t\t    ret = (CONT->c1->prefix == NULL);\n\t\t} else if (CONT->c1->prefix == NULL) {\n\t\t    ret = 0;\n\t\t} else {\n\t\t    ret = xmlStrEqual(NODE->ns->prefix, CONT->c1->prefix);\n\t\t}\n\t\tif (ret == 0) {\n\t\t    DEPTH++;\n\t\t    CONT = CONT->c2;\n\t\t    goto cont;\n\t\t}\n\t    }\n\t    DEPTH++;\n\t    CONT = CONT->c1;\n\t    goto cont;\n    }\n\n    /*\n     * At this point handle going up in the tree\n     */\n    if (ret == -1) {\n\tDEBUG_VALID_MSG(\"error found returning\");\n\treturn(ret);\n    }\nanalyze:\n    while (CONT != NULL) {\n\t/*\n\t * First do the analysis depending on the occurrence model at\n\t * this level.\n\t */\n\tif (ret == 0) {\n\t    switch (CONT->ocur) {\n\t\txmlNodePtr cur;\n\n\t\tcase XML_ELEMENT_CONTENT_ONCE:\n\t\t    cur = ctxt->vstate->node;\n\t\t    DEBUG_VALID_MSG(\"Once branch failed, rollback\");\n\t\t    if (vstateVPop(ctxt) < 0 ) {\n\t\t\tDEBUG_VALID_MSG(\"exhaustion, failed\");\n\t\t\treturn(0);\n\t\t    }\n\t\t    if (cur != ctxt->vstate->node)\n\t\t\tdeterminist = -3;\n\t\t    goto cont;\n\t\tcase XML_ELEMENT_CONTENT_PLUS:\n\t\t    if (OCCURRENCE == 0) {\n\t\t\tcur = ctxt->vstate->node;\n\t\t\tDEBUG_VALID_MSG(\"Plus branch failed, rollback\");\n\t\t\tif (vstateVPop(ctxt) < 0 ) {\n\t\t\t    DEBUG_VALID_MSG(\"exhaustion, failed\");\n\t\t\t    return(0);\n\t\t\t}\n\t\t\tif (cur != ctxt->vstate->node)\n\t\t\t    determinist = -3;\n\t\t\tgoto cont;\n\t\t    }\n\t\t    DEBUG_VALID_MSG(\"Plus branch found\");\n\t\t    ret = 1;\n\t\t    break;\n\t\tcase XML_ELEMENT_CONTENT_MULT:\n#ifdef DEBUG_VALID_ALGO\n\t\t    if (OCCURRENCE == 0) {\n\t\t\tDEBUG_VALID_MSG(\"Mult branch failed\");\n\t\t    } else {\n\t\t\tDEBUG_VALID_MSG(\"Mult branch found\");\n\t\t    }\n#endif\n\t\t    ret = 1;\n\t\t    break;\n\t\tcase XML_ELEMENT_CONTENT_OPT:\n\t\t    DEBUG_VALID_MSG(\"Option branch failed\");\n\t\t    ret = 1;\n\t\t    break;\n\t    }\n\t} else {\n\t    switch (CONT->ocur) {\n\t\tcase XML_ELEMENT_CONTENT_OPT:\n\t\t    DEBUG_VALID_MSG(\"Option branch succeeded\");\n\t\t    ret = 1;\n\t\t    break;\n\t\tcase XML_ELEMENT_CONTENT_ONCE:\n\t\t    DEBUG_VALID_MSG(\"Once branch succeeded\");\n\t\t    ret = 1;\n\t\t    break;\n\t\tcase XML_ELEMENT_CONTENT_PLUS:\n\t\t    if (STATE == ROLLBACK_PARENT) {\n\t\t\tDEBUG_VALID_MSG(\"Plus branch rollback\");\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t    }\n\t\t    if (NODE == NULL) {\n\t\t\tDEBUG_VALID_MSG(\"Plus branch exhausted\");\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t    }\n\t\t    DEBUG_VALID_MSG(\"Plus branch succeeded, continuing\");\n\t\t    SET_OCCURRENCE;\n\t\t    goto cont;\n\t\tcase XML_ELEMENT_CONTENT_MULT:\n\t\t    if (STATE == ROLLBACK_PARENT) {\n\t\t\tDEBUG_VALID_MSG(\"Mult branch rollback\");\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t    }\n\t\t    if (NODE == NULL) {\n\t\t\tDEBUG_VALID_MSG(\"Mult branch exhausted\");\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t    }\n\t\t    DEBUG_VALID_MSG(\"Mult branch succeeded, continuing\");\n\t\t    /* SET_OCCURRENCE; */\n\t\t    goto cont;\n\t    }\n\t}\n\tSTATE = 0;\n\n\t/*\n\t * Then act accordingly at the parent level\n\t */\n\tRESET_OCCURRENCE;\n\tif (CONT->parent == NULL)\n\t    break;\n\n\tswitch (CONT->parent->type) {\n\t    case XML_ELEMENT_CONTENT_PCDATA:\n\t\tDEBUG_VALID_MSG(\"Error: parent pcdata\");\n\t\treturn(-1);\n\t    case XML_ELEMENT_CONTENT_ELEMENT:\n\t\tDEBUG_VALID_MSG(\"Error: parent element\");\n\t\treturn(-1);\n\t    case XML_ELEMENT_CONTENT_OR:\n\t\tif (ret == 1) {\n\t\t    DEBUG_VALID_MSG(\"Or succeeded\");\n\t\t    CONT = CONT->parent;\n\t\t    DEPTH--;\n\t\t} else {\n\t\t    DEBUG_VALID_MSG(\"Or failed\");\n\t\t    CONT = CONT->parent;\n\t\t    DEPTH--;\n\t\t}\n\t\tbreak;\n\t    case XML_ELEMENT_CONTENT_SEQ:\n\t\tif (ret == 0) {\n\t\t    DEBUG_VALID_MSG(\"Sequence failed\");\n\t\t    CONT = CONT->parent;\n\t\t    DEPTH--;\n\t\t} else if (CONT == CONT->parent->c1) {\n\t\t    DEBUG_VALID_MSG(\"Sequence testing 2nd branch\");\n\t\t    CONT = CONT->parent->c2;\n\t\t    goto cont;\n\t\t} else {\n\t\t    DEBUG_VALID_MSG(\"Sequence succeeded\");\n\t\t    CONT = CONT->parent;\n\t\t    DEPTH--;\n\t\t}\n\t}\n    }\n    if (NODE != NULL) {\n\txmlNodePtr cur;\n\n\tcur = ctxt->vstate->node;\n\tDEBUG_VALID_MSG(\"Failed, remaining input, rollback\");\n\tif (vstateVPop(ctxt) < 0 ) {\n\t    DEBUG_VALID_MSG(\"exhaustion, failed\");\n\t    return(0);\n\t}\n\tif (cur != ctxt->vstate->node)\n\t    determinist = -3;\n\tgoto cont;\n    }\n    if (ret == 0) {\n\txmlNodePtr cur;\n\n\tcur = ctxt->vstate->node;\n\tDEBUG_VALID_MSG(\"Failure, rollback\");\n\tif (vstateVPop(ctxt) < 0 ) {\n\t    DEBUG_VALID_MSG(\"exhaustion, failed\");\n\t    return(0);\n\t}\n\tif (cur != ctxt->vstate->node)\n\t    determinist = -3;\n\tgoto cont;\n    }\n    return(determinist);\n}\n#endif\n\n/**\n * xmlSnprintfElements:\n * @buf:  an output buffer\n * @size:  the size of the buffer\n * @content:  An element\n * @glob: 1 if one must print the englobing parenthesis, 0 otherwise\n *\n * This will dump the list of elements to the buffer\n * Intended just for the debug routine\n */\nstatic void\nxmlSnprintfElements(char *buf, int size, xmlNodePtr node, int glob) {\n    xmlNodePtr cur;\n    int len;\n\n    if (node == NULL) return;\n    if (glob) strcat(buf, \"(\");\n    cur = node;\n    while (cur != NULL) {\n\tlen = strlen(buf);\n\tif (size - len < 50) {\n\t    if ((size - len > 4) && (buf[len - 1] != '.'))\n\t\tstrcat(buf, \" ...\");\n\t    return;\n\t}\n        switch (cur->type) {\n            case XML_ELEMENT_NODE:\n\t\tif ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {\n\t\t    if (size - len < xmlStrlen(cur->ns->prefix) + 10) {\n\t\t\tif ((size - len > 4) && (buf[len - 1] != '.'))\n\t\t\t    strcat(buf, \" ...\");\n\t\t\treturn;\n\t\t    }\n\t\t    strcat(buf, (char *) cur->ns->prefix);\n\t\t    strcat(buf, \":\");\n\t\t}\n                if (size - len < xmlStrlen(cur->name) + 10) {\n\t\t    if ((size - len > 4) && (buf[len - 1] != '.'))\n\t\t\tstrcat(buf, \" ...\");\n\t\t    return;\n\t\t}\n\t        strcat(buf, (char *) cur->name);\n\t\tif (cur->next != NULL)\n\t\t    strcat(buf, \" \");\n\t\tbreak;\n            case XML_TEXT_NODE:\n\t\tif (xmlIsBlankNode(cur))\n\t\t    break;\n                /* Falls through. */\n            case XML_CDATA_SECTION_NODE:\n            case XML_ENTITY_REF_NODE:\n\t        strcat(buf, \"CDATA\");\n\t\tif (cur->next != NULL)\n\t\t    strcat(buf, \" \");\n\t\tbreak;\n            case XML_ATTRIBUTE_NODE:\n            case XML_DOCUMENT_NODE:\n#ifdef LIBXML_DOCB_ENABLED\n\t    case XML_DOCB_DOCUMENT_NODE:\n#endif\n\t    case XML_HTML_DOCUMENT_NODE:\n            case XML_DOCUMENT_TYPE_NODE:\n            case XML_DOCUMENT_FRAG_NODE:\n            case XML_NOTATION_NODE:\n\t    case XML_NAMESPACE_DECL:\n\t        strcat(buf, \"???\");\n\t\tif (cur->next != NULL)\n\t\t    strcat(buf, \" \");\n\t\tbreak;\n            case XML_ENTITY_NODE:\n            case XML_PI_NODE:\n            case XML_DTD_NODE:\n            case XML_COMMENT_NODE:\n\t    case XML_ELEMENT_DECL:\n\t    case XML_ATTRIBUTE_DECL:\n\t    case XML_ENTITY_DECL:\n\t    case XML_XINCLUDE_START:\n\t    case XML_XINCLUDE_END:\n\t\tbreak;\n\t}\n\tcur = cur->next;\n    }\n    if (glob) strcat(buf, \")\");\n}\n\n/**\n * xmlValidateElementContent:\n * @ctxt:  the validation context\n * @child:  the child list\n * @elemDecl:  pointer to the element declaration\n * @warn:  emit the error message\n * @parent: the parent element (for error reporting)\n *\n * Try to validate the content model of an element\n *\n * returns 1 if valid or 0 if not and -1 in case of error\n */\n\nstatic int\nxmlValidateElementContent(xmlValidCtxtPtr ctxt, xmlNodePtr child,\n       xmlElementPtr elemDecl, int warn, xmlNodePtr parent) {\n    int ret = 1;\n#ifndef  LIBXML_REGEXP_ENABLED\n    xmlNodePtr repl = NULL, last = NULL, tmp;\n#endif\n    xmlNodePtr cur;\n    xmlElementContentPtr cont;\n    const xmlChar *name;\n\n    if ((elemDecl == NULL) || (parent == NULL) || (ctxt == NULL))\n\treturn(-1);\n    cont = elemDecl->content;\n    name = elemDecl->name;\n\n#ifdef LIBXML_REGEXP_ENABLED\n    /* Build the regexp associated to the content model */\n    if (elemDecl->contModel == NULL)\n\tret = xmlValidBuildContentModel(ctxt, elemDecl);\n    if (elemDecl->contModel == NULL) {\n\treturn(-1);\n    } else {\n\txmlRegExecCtxtPtr exec;\n\n\tif (!xmlRegexpIsDeterminist(elemDecl->contModel)) {\n\t    return(-1);\n\t}\n\tctxt->nodeMax = 0;\n\tctxt->nodeNr = 0;\n\tctxt->nodeTab = NULL;\n\texec = xmlRegNewExecCtxt(elemDecl->contModel, NULL, NULL);\n\tif (exec != NULL) {\n\t    cur = child;\n\t    while (cur != NULL) {\n\t\tswitch (cur->type) {\n\t\t    case XML_ENTITY_REF_NODE:\n\t\t\t/*\n\t\t\t * Push the current node to be able to roll back\n\t\t\t * and process within the entity\n\t\t\t */\n\t\t\tif ((cur->children != NULL) &&\n\t\t\t    (cur->children->children != NULL)) {\n\t\t\t    nodeVPush(ctxt, cur);\n\t\t\t    cur = cur->children->children;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tbreak;\n\t\t    case XML_TEXT_NODE:\n\t\t\tif (xmlIsBlankNode(cur))\n\t\t\t    break;\n\t\t\tret = 0;\n\t\t\tgoto fail;\n\t\t    case XML_CDATA_SECTION_NODE:\n\t\t\t/* TODO */\n\t\t\tret = 0;\n\t\t\tgoto fail;\n\t\t    case XML_ELEMENT_NODE:\n\t\t\tif ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {\n\t\t\t    xmlChar fn[50];\n\t\t\t    xmlChar *fullname;\n\n\t\t\t    fullname = xmlBuildQName(cur->name,\n\t\t\t\t                     cur->ns->prefix, fn, 50);\n\t\t\t    if (fullname == NULL) {\n\t\t\t\tret = -1;\n\t\t\t\tgoto fail;\n\t\t\t    }\n                            ret = xmlRegExecPushString(exec, fullname, NULL);\n\t\t\t    if ((fullname != fn) && (fullname != cur->name))\n\t\t\t\txmlFree(fullname);\n\t\t\t} else {\n\t\t\t    ret = xmlRegExecPushString(exec, cur->name, NULL);\n\t\t\t}\n\t\t\tbreak;\n\t\t    default:\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * Switch to next element\n\t\t */\n\t\tcur = cur->next;\n\t\twhile (cur == NULL) {\n\t\t    cur = nodeVPop(ctxt);\n\t\t    if (cur == NULL)\n\t\t\tbreak;\n\t\t    cur = cur->next;\n\t\t}\n\t    }\n\t    ret = xmlRegExecPushString(exec, NULL, NULL);\nfail:\n\t    xmlRegFreeExecCtxt(exec);\n\t}\n    }\n#else  /* LIBXML_REGEXP_ENABLED */\n    /*\n     * Allocate the stack\n     */\n    ctxt->vstateMax = 8;\n    ctxt->vstateTab = (xmlValidState *) xmlMalloc(\n\t\t ctxt->vstateMax * sizeof(ctxt->vstateTab[0]));\n    if (ctxt->vstateTab == NULL) {\n\txmlVErrMemory(ctxt, \"malloc failed\");\n\treturn(-1);\n    }\n    /*\n     * The first entry in the stack is reserved to the current state\n     */\n    ctxt->nodeMax = 0;\n    ctxt->nodeNr = 0;\n    ctxt->nodeTab = NULL;\n    ctxt->vstate = &ctxt->vstateTab[0];\n    ctxt->vstateNr = 1;\n    CONT = cont;\n    NODE = child;\n    DEPTH = 0;\n    OCCURS = 0;\n    STATE = 0;\n    ret = xmlValidateElementType(ctxt);\n    if ((ret == -3) && (warn)) {\n\txmlErrValidWarning(ctxt, child, XML_DTD_CONTENT_NOT_DETERMINIST,\n\t       \"Content model for Element %s is ambiguous\\n\",\n\t                   name, NULL, NULL);\n    } else if (ret == -2) {\n\t/*\n\t * An entities reference appeared at this level.\n\t * Build a minimal representation of this node content\n\t * sufficient to run the validation process on it\n\t */\n\tDEBUG_VALID_MSG(\"Found an entity reference, linearizing\");\n\tcur = child;\n\twhile (cur != NULL) {\n\t    switch (cur->type) {\n\t\tcase XML_ENTITY_REF_NODE:\n\t\t    /*\n\t\t     * Push the current node to be able to roll back\n\t\t     * and process within the entity\n\t\t     */\n\t\t    if ((cur->children != NULL) &&\n\t\t\t(cur->children->children != NULL)) {\n\t\t\tnodeVPush(ctxt, cur);\n\t\t\tcur = cur->children->children;\n\t\t\tcontinue;\n\t\t    }\n\t\t    break;\n\t\tcase XML_TEXT_NODE:\n\t\t    if (xmlIsBlankNode(cur))\n\t\t\tbreak;\n\t\t    /* no break on purpose */\n\t\tcase XML_CDATA_SECTION_NODE:\n\t\t    /* no break on purpose */\n\t\tcase XML_ELEMENT_NODE:\n\t\t    /*\n\t\t     * Allocate a new node and minimally fills in\n\t\t     * what's required\n\t\t     */\n\t\t    tmp = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));\n\t\t    if (tmp == NULL) {\n\t\t\txmlVErrMemory(ctxt, \"malloc failed\");\n\t\t\txmlFreeNodeList(repl);\n\t\t\tret = -1;\n\t\t\tgoto done;\n\t\t    }\n\t\t    tmp->type = cur->type;\n\t\t    tmp->name = cur->name;\n\t\t    tmp->ns = cur->ns;\n\t\t    tmp->next = NULL;\n\t\t    tmp->content = NULL;\n\t\t    if (repl == NULL)\n\t\t\trepl = last = tmp;\n\t\t    else {\n\t\t\tlast->next = tmp;\n\t\t\tlast = tmp;\n\t\t    }\n\t\t    if (cur->type == XML_CDATA_SECTION_NODE) {\n\t\t\t/*\n\t\t\t * E59 spaces in CDATA does not match the\n\t\t\t * nonterminal S\n\t\t\t */\n\t\t\ttmp->content = xmlStrdup(BAD_CAST \"CDATA\");\n\t\t    }\n\t\t    break;\n\t\tdefault:\n\t\t    break;\n\t    }\n\t    /*\n\t     * Switch to next element\n\t     */\n\t    cur = cur->next;\n\t    while (cur == NULL) {\n\t\tcur = nodeVPop(ctxt);\n\t\tif (cur == NULL)\n\t\t    break;\n\t\tcur = cur->next;\n\t    }\n\t}\n\n\t/*\n\t * Relaunch the validation\n\t */\n\tctxt->vstate = &ctxt->vstateTab[0];\n\tctxt->vstateNr = 1;\n\tCONT = cont;\n\tNODE = repl;\n\tDEPTH = 0;\n\tOCCURS = 0;\n\tSTATE = 0;\n\tret = xmlValidateElementType(ctxt);\n    }\n#endif /* LIBXML_REGEXP_ENABLED */\n    if ((warn) && ((ret != 1) && (ret != -3))) {\n\tif (ctxt != NULL) {\n\t    char expr[5000];\n\t    char list[5000];\n\n\t    expr[0] = 0;\n\t    xmlSnprintfElementContent(&expr[0], 5000, cont, 1);\n\t    list[0] = 0;\n#ifndef LIBXML_REGEXP_ENABLED\n\t    if (repl != NULL)\n\t\txmlSnprintfElements(&list[0], 5000, repl, 1);\n\t    else\n#endif /* LIBXML_REGEXP_ENABLED */\n\t\txmlSnprintfElements(&list[0], 5000, child, 1);\n\n\t    if (name != NULL) {\n\t\txmlErrValidNode(ctxt, parent, XML_DTD_CONTENT_MODEL,\n\t   \"Element %s content does not follow the DTD, expecting %s, got %s\\n\",\n\t\t       name, BAD_CAST expr, BAD_CAST list);\n\t    } else {\n\t\txmlErrValidNode(ctxt, parent, XML_DTD_CONTENT_MODEL,\n\t   \"Element content does not follow the DTD, expecting %s, got %s\\n\",\n\t\t       BAD_CAST expr, BAD_CAST list, NULL);\n\t    }\n\t} else {\n\t    if (name != NULL) {\n\t\txmlErrValidNode(ctxt, parent, XML_DTD_CONTENT_MODEL,\n\t\t       \"Element %s content does not follow the DTD\\n\",\n\t\t       name, NULL, NULL);\n\t    } else {\n\t\txmlErrValidNode(ctxt, parent, XML_DTD_CONTENT_MODEL,\n\t\t       \"Element content does not follow the DTD\\n\",\n\t\t                NULL, NULL, NULL);\n\t    }\n\t}\n\tret = 0;\n    }\n    if (ret == -3)\n\tret = 1;\n\n#ifndef  LIBXML_REGEXP_ENABLED\ndone:\n    /*\n     * Deallocate the copy if done, and free up the validation stack\n     */\n    while (repl != NULL) {\n\ttmp = repl->next;\n\txmlFree(repl);\n\trepl = tmp;\n    }\n    ctxt->vstateMax = 0;\n    if (ctxt->vstateTab != NULL) {\n\txmlFree(ctxt->vstateTab);\n\tctxt->vstateTab = NULL;\n    }\n#endif\n    ctxt->nodeMax = 0;\n    ctxt->nodeNr = 0;\n    if (ctxt->nodeTab != NULL) {\n\txmlFree(ctxt->nodeTab);\n\tctxt->nodeTab = NULL;\n    }\n    return(ret);\n\n}\n\n/**\n * xmlValidateCdataElement:\n * @ctxt:  the validation context\n * @doc:  a document instance\n * @elem:  an element instance\n *\n * Check that an element follows #CDATA\n *\n * returns 1 if valid or 0 otherwise\n */\nstatic int\nxmlValidateOneCdataElement(xmlValidCtxtPtr ctxt, xmlDocPtr doc,\n                           xmlNodePtr elem) {\n    int ret = 1;\n    xmlNodePtr cur, child;\n\n    if ((ctxt == NULL) || (doc == NULL) || (elem == NULL) ||\n        (elem->type != XML_ELEMENT_NODE))\n\treturn(0);\n\n    child = elem->children;\n\n    cur = child;\n    while (cur != NULL) {\n\tswitch (cur->type) {\n\t    case XML_ENTITY_REF_NODE:\n\t\t/*\n\t\t * Push the current node to be able to roll back\n\t\t * and process within the entity\n\t\t */\n\t\tif ((cur->children != NULL) &&\n\t\t    (cur->children->children != NULL)) {\n\t\t    nodeVPush(ctxt, cur);\n\t\t    cur = cur->children->children;\n\t\t    continue;\n\t\t}\n\t\tbreak;\n\t    case XML_COMMENT_NODE:\n\t    case XML_PI_NODE:\n\t    case XML_TEXT_NODE:\n\t    case XML_CDATA_SECTION_NODE:\n\t\tbreak;\n\t    default:\n\t\tret = 0;\n\t\tgoto done;\n\t}\n\t/*\n\t * Switch to next element\n\t */\n\tcur = cur->next;\n\twhile (cur == NULL) {\n\t    cur = nodeVPop(ctxt);\n\t    if (cur == NULL)\n\t\tbreak;\n\t    cur = cur->next;\n\t}\n    }\ndone:\n    ctxt->nodeMax = 0;\n    ctxt->nodeNr = 0;\n    if (ctxt->nodeTab != NULL) {\n\txmlFree(ctxt->nodeTab);\n\tctxt->nodeTab = NULL;\n    }\n    return(ret);\n}\n\n/**\n * xmlValidateCheckMixed:\n * @ctxt:  the validation context\n * @cont:  the mixed content model\n * @qname:  the qualified name as appearing in the serialization\n *\n * Check if the given node is part of the content model.\n *\n * Returns 1 if yes, 0 if no, -1 in case of error\n */\nstatic int\nxmlValidateCheckMixed(xmlValidCtxtPtr ctxt,\n\t              xmlElementContentPtr cont, const xmlChar *qname) {\n    const xmlChar *name;\n    int plen;\n    name = xmlSplitQName3(qname, &plen);\n\n    if (name == NULL) {\n\twhile (cont != NULL) {\n\t    if (cont->type == XML_ELEMENT_CONTENT_ELEMENT) {\n\t\tif ((cont->prefix == NULL) && (xmlStrEqual(cont->name, qname)))\n\t\t    return(1);\n\t    } else if ((cont->type == XML_ELEMENT_CONTENT_OR) &&\n\t       (cont->c1 != NULL) &&\n\t       (cont->c1->type == XML_ELEMENT_CONTENT_ELEMENT)){\n\t\tif ((cont->c1->prefix == NULL) &&\n\t\t    (xmlStrEqual(cont->c1->name, qname)))\n\t\t    return(1);\n\t    } else if ((cont->type != XML_ELEMENT_CONTENT_OR) ||\n\t\t(cont->c1 == NULL) ||\n\t\t(cont->c1->type != XML_ELEMENT_CONTENT_PCDATA)){\n\t\txmlErrValid(NULL, XML_DTD_MIXED_CORRUPT,\n\t\t\t\"Internal: MIXED struct corrupted\\n\",\n\t\t\tNULL);\n\t\tbreak;\n\t    }\n\t    cont = cont->c2;\n\t}\n    } else {\n\twhile (cont != NULL) {\n\t    if (cont->type == XML_ELEMENT_CONTENT_ELEMENT) {\n\t\tif ((cont->prefix != NULL) &&\n\t\t    (xmlStrncmp(cont->prefix, qname, plen) == 0) &&\n\t\t    (xmlStrEqual(cont->name, name)))\n\t\t    return(1);\n\t    } else if ((cont->type == XML_ELEMENT_CONTENT_OR) &&\n\t       (cont->c1 != NULL) &&\n\t       (cont->c1->type == XML_ELEMENT_CONTENT_ELEMENT)){\n\t\tif ((cont->c1->prefix != NULL) &&\n\t\t    (xmlStrncmp(cont->c1->prefix, qname, plen) == 0) &&\n\t\t    (xmlStrEqual(cont->c1->name, name)))\n\t\t    return(1);\n\t    } else if ((cont->type != XML_ELEMENT_CONTENT_OR) ||\n\t\t(cont->c1 == NULL) ||\n\t\t(cont->c1->type != XML_ELEMENT_CONTENT_PCDATA)){\n\t\txmlErrValid(ctxt, XML_DTD_MIXED_CORRUPT,\n\t\t\t\"Internal: MIXED struct corrupted\\n\",\n\t\t\tNULL);\n\t\tbreak;\n\t    }\n\t    cont = cont->c2;\n\t}\n    }\n    return(0);\n}\n\n/**\n * xmlValidGetElemDecl:\n * @ctxt:  the validation context\n * @doc:  a document instance\n * @elem:  an element instance\n * @extsubset:  pointer, (out) indicate if the declaration was found\n *              in the external subset.\n *\n * Finds a declaration associated to an element in the document.\n *\n * returns the pointer to the declaration or NULL if not found.\n */\nstatic xmlElementPtr\nxmlValidGetElemDecl(xmlValidCtxtPtr ctxt, xmlDocPtr doc,\n\t            xmlNodePtr elem, int *extsubset) {\n    xmlElementPtr elemDecl = NULL;\n    const xmlChar *prefix = NULL;\n\n    if ((ctxt == NULL) || (doc == NULL) ||\n        (elem == NULL) || (elem->name == NULL))\n        return(NULL);\n    if (extsubset != NULL)\n\t*extsubset = 0;\n\n    /*\n     * Fetch the declaration for the qualified name\n     */\n    if ((elem->ns != NULL) && (elem->ns->prefix != NULL))\n\tprefix = elem->ns->prefix;\n\n    if (prefix != NULL) {\n\telemDecl = xmlGetDtdQElementDesc(doc->intSubset,\n\t\t                         elem->name, prefix);\n\tif ((elemDecl == NULL) && (doc->extSubset != NULL)) {\n\t    elemDecl = xmlGetDtdQElementDesc(doc->extSubset,\n\t\t                             elem->name, prefix);\n\t    if ((elemDecl != NULL) && (extsubset != NULL))\n\t\t*extsubset = 1;\n\t}\n    }\n\n    /*\n     * Fetch the declaration for the non qualified name\n     * This is \"non-strict\" validation should be done on the\n     * full QName but in that case being flexible makes sense.\n     */\n    if (elemDecl == NULL) {\n\telemDecl = xmlGetDtdElementDesc(doc->intSubset, elem->name);\n\tif ((elemDecl == NULL) && (doc->extSubset != NULL)) {\n\t    elemDecl = xmlGetDtdElementDesc(doc->extSubset, elem->name);\n\t    if ((elemDecl != NULL) && (extsubset != NULL))\n\t\t*extsubset = 1;\n\t}\n    }\n    if (elemDecl == NULL) {\n\txmlErrValidNode(ctxt, elem,\n\t\t\tXML_DTD_UNKNOWN_ELEM,\n\t       \"No declaration for element %s\\n\",\n\t       elem->name, NULL, NULL);\n    }\n    return(elemDecl);\n}\n\n#ifdef LIBXML_REGEXP_ENABLED\n/**\n * xmlValidatePushElement:\n * @ctxt:  the validation context\n * @doc:  a document instance\n * @elem:  an element instance\n * @qname:  the qualified name as appearing in the serialization\n *\n * Push a new element start on the validation stack.\n *\n * returns 1 if no validation problem was found or 0 otherwise\n */\nint\nxmlValidatePushElement(xmlValidCtxtPtr ctxt, xmlDocPtr doc,\n                       xmlNodePtr elem, const xmlChar *qname) {\n    int ret = 1;\n    xmlElementPtr eDecl;\n    int extsubset = 0;\n\n    if (ctxt == NULL)\n        return(0);\n/* printf(\"PushElem %s\\n\", qname); */\n    if ((ctxt->vstateNr > 0) && (ctxt->vstate != NULL)) {\n\txmlValidStatePtr state = ctxt->vstate;\n\txmlElementPtr elemDecl;\n\n\t/*\n\t * Check the new element against the content model of the new elem.\n\t */\n\tif (state->elemDecl != NULL) {\n\t    elemDecl = state->elemDecl;\n\n\t    switch(elemDecl->etype) {\n\t\tcase XML_ELEMENT_TYPE_UNDEFINED:\n\t\t    ret = 0;\n\t\t    break;\n\t\tcase XML_ELEMENT_TYPE_EMPTY:\n\t\t    xmlErrValidNode(ctxt, state->node,\n\t\t\t\t    XML_DTD_NOT_EMPTY,\n\t       \"Element %s was declared EMPTY this one has content\\n\",\n\t\t\t   state->node->name, NULL, NULL);\n\t\t    ret = 0;\n\t\t    break;\n\t\tcase XML_ELEMENT_TYPE_ANY:\n\t\t    /* I don't think anything is required then */\n\t\t    break;\n\t\tcase XML_ELEMENT_TYPE_MIXED:\n\t\t    /* simple case of declared as #PCDATA */\n\t\t    if ((elemDecl->content != NULL) &&\n\t\t\t(elemDecl->content->type ==\n\t\t\t XML_ELEMENT_CONTENT_PCDATA)) {\n\t\t\txmlErrValidNode(ctxt, state->node,\n\t\t\t\t\tXML_DTD_NOT_PCDATA,\n\t       \"Element %s was declared #PCDATA but contains non text nodes\\n\",\n\t\t\t\tstate->node->name, NULL, NULL);\n\t\t\tret = 0;\n\t\t    } else {\n\t\t\tret = xmlValidateCheckMixed(ctxt, elemDecl->content,\n\t\t\t\t                    qname);\n\t\t\tif (ret != 1) {\n\t\t\t    xmlErrValidNode(ctxt, state->node,\n\t\t\t\t\t    XML_DTD_INVALID_CHILD,\n\t       \"Element %s is not declared in %s list of possible children\\n\",\n\t\t\t\t    qname, state->node->name, NULL);\n\t\t\t}\n\t\t    }\n\t\t    break;\n\t\tcase XML_ELEMENT_TYPE_ELEMENT:\n\t\t    /*\n\t\t     * TODO:\n\t\t     * VC: Standalone Document Declaration\n\t\t     *     - element types with element content, if white space\n\t\t     *       occurs directly within any instance of those types.\n\t\t     */\n\t\t    if (state->exec != NULL) {\n\t\t\tret = xmlRegExecPushString(state->exec, qname, NULL);\n\t\t\tif (ret < 0) {\n\t\t\t    xmlErrValidNode(ctxt, state->node,\n\t\t\t\t\t    XML_DTD_CONTENT_MODEL,\n\t       \"Element %s content does not follow the DTD, Misplaced %s\\n\",\n\t\t\t\t   state->node->name, qname, NULL);\n\t\t\t    ret = 0;\n\t\t\t} else {\n\t\t\t    ret = 1;\n\t\t\t}\n\t\t    }\n\t\t    break;\n\t    }\n\t}\n    }\n    eDecl = xmlValidGetElemDecl(ctxt, doc, elem, &extsubset);\n    vstateVPush(ctxt, eDecl, elem);\n    return(ret);\n}\n\n/**\n * xmlValidatePushCData:\n * @ctxt:  the validation context\n * @data:  some character data read\n * @len:  the length of the data\n *\n * check the CData parsed for validation in the current stack\n *\n * returns 1 if no validation problem was found or 0 otherwise\n */\nint\nxmlValidatePushCData(xmlValidCtxtPtr ctxt, const xmlChar *data, int len) {\n    int ret = 1;\n\n/* printf(\"CDATA %s %d\\n\", data, len); */\n    if (ctxt == NULL)\n        return(0);\n    if (len <= 0)\n\treturn(ret);\n    if ((ctxt->vstateNr > 0) && (ctxt->vstate != NULL)) {\n\txmlValidStatePtr state = ctxt->vstate;\n\txmlElementPtr elemDecl;\n\n\t/*\n\t * Check the new element against the content model of the new elem.\n\t */\n\tif (state->elemDecl != NULL) {\n\t    elemDecl = state->elemDecl;\n\n\t    switch(elemDecl->etype) {\n\t\tcase XML_ELEMENT_TYPE_UNDEFINED:\n\t\t    ret = 0;\n\t\t    break;\n\t\tcase XML_ELEMENT_TYPE_EMPTY:\n\t\t    xmlErrValidNode(ctxt, state->node,\n\t\t\t\t    XML_DTD_NOT_EMPTY,\n\t       \"Element %s was declared EMPTY this one has content\\n\",\n\t\t\t   state->node->name, NULL, NULL);\n\t\t    ret = 0;\n\t\t    break;\n\t\tcase XML_ELEMENT_TYPE_ANY:\n\t\t    break;\n\t\tcase XML_ELEMENT_TYPE_MIXED:\n\t\t    break;\n\t\tcase XML_ELEMENT_TYPE_ELEMENT: {\n                    int i;\n\n                    for (i = 0;i < len;i++) {\n                        if (!IS_BLANK_CH(data[i])) {\n                            xmlErrValidNode(ctxt, state->node,\n                                            XML_DTD_CONTENT_MODEL,\n       \"Element %s content does not follow the DTD, Text not allowed\\n\",\n                                   state->node->name, NULL, NULL);\n                            ret = 0;\n                            goto done;\n                        }\n                    }\n                    /*\n                     * TODO:\n                     * VC: Standalone Document Declaration\n                     *  element types with element content, if white space\n                     *  occurs directly within any instance of those types.\n                     */\n                    break;\n                }\n\t    }\n\t}\n    }\ndone:\n    return(ret);\n}\n\n/**\n * xmlValidatePopElement:\n * @ctxt:  the validation context\n * @doc:  a document instance\n * @elem:  an element instance\n * @qname:  the qualified name as appearing in the serialization\n *\n * Pop the element end from the validation stack.\n *\n * returns 1 if no validation problem was found or 0 otherwise\n */\nint\nxmlValidatePopElement(xmlValidCtxtPtr ctxt, xmlDocPtr doc ATTRIBUTE_UNUSED,\n                      xmlNodePtr elem ATTRIBUTE_UNUSED,\n\t\t      const xmlChar *qname ATTRIBUTE_UNUSED) {\n    int ret = 1;\n\n    if (ctxt == NULL)\n        return(0);\n/* printf(\"PopElem %s\\n\", qname); */\n    if ((ctxt->vstateNr > 0) && (ctxt->vstate != NULL)) {\n\txmlValidStatePtr state = ctxt->vstate;\n\txmlElementPtr elemDecl;\n\n\t/*\n\t * Check the new element against the content model of the new elem.\n\t */\n\tif (state->elemDecl != NULL) {\n\t    elemDecl = state->elemDecl;\n\n\t    if (elemDecl->etype == XML_ELEMENT_TYPE_ELEMENT) {\n\t\tif (state->exec != NULL) {\n\t\t    ret = xmlRegExecPushString(state->exec, NULL, NULL);\n\t\t    if (ret == 0) {\n\t\t\txmlErrValidNode(ctxt, state->node,\n\t\t\t                XML_DTD_CONTENT_MODEL,\n\t   \"Element %s content does not follow the DTD, Expecting more child\\n\",\n\t\t\t       state->node->name, NULL,NULL);\n\t\t    } else {\n\t\t\t/*\n\t\t\t * previous validation errors should not generate\n\t\t\t * a new one here\n\t\t\t */\n\t\t\tret = 1;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tvstateVPop(ctxt);\n    }\n    return(ret);\n}\n#endif /* LIBXML_REGEXP_ENABLED */\n\n/**\n * xmlValidateOneElement:\n * @ctxt:  the validation context\n * @doc:  a document instance\n * @elem:  an element instance\n *\n * Try to validate a single element and it's attributes,\n * basically it does the following checks as described by the\n * XML-1.0 recommendation:\n *  - [ VC: Element Valid ]\n *  - [ VC: Required Attribute ]\n * Then call xmlValidateOneAttribute() for each attribute present.\n *\n * The ID/IDREF checkings are done separately\n *\n * returns 1 if valid or 0 otherwise\n */\n\nint\nxmlValidateOneElement(xmlValidCtxtPtr ctxt, xmlDocPtr doc,\n                      xmlNodePtr elem) {\n    xmlElementPtr elemDecl = NULL;\n    xmlElementContentPtr cont;\n    xmlAttributePtr attr;\n    xmlNodePtr child;\n    int ret = 1, tmp;\n    const xmlChar *name;\n    int extsubset = 0;\n\n    CHECK_DTD;\n\n    if (elem == NULL) return(0);\n    switch (elem->type) {\n        case XML_ATTRIBUTE_NODE:\n\t    xmlErrValidNode(ctxt, elem, XML_ERR_INTERNAL_ERROR,\n\t\t   \"Attribute element not expected\\n\", NULL, NULL ,NULL);\n\t    return(0);\n        case XML_TEXT_NODE:\n\t    if (elem->children != NULL) {\n\t\txmlErrValidNode(ctxt, elem, XML_ERR_INTERNAL_ERROR,\n\t\t                \"Text element has children !\\n\",\n\t\t\t\tNULL,NULL,NULL);\n\t\treturn(0);\n\t    }\n\t    if (elem->ns != NULL) {\n\t\txmlErrValidNode(ctxt, elem, XML_ERR_INTERNAL_ERROR,\n\t\t                \"Text element has namespace !\\n\",\n\t\t\t\tNULL,NULL,NULL);\n\t\treturn(0);\n\t    }\n\t    if (elem->content == NULL) {\n\t\txmlErrValidNode(ctxt, elem, XML_ERR_INTERNAL_ERROR,\n\t\t                \"Text element has no content !\\n\",\n\t\t\t\tNULL,NULL,NULL);\n\t\treturn(0);\n\t    }\n\t    return(1);\n        case XML_XINCLUDE_START:\n        case XML_XINCLUDE_END:\n            return(1);\n        case XML_CDATA_SECTION_NODE:\n        case XML_ENTITY_REF_NODE:\n        case XML_PI_NODE:\n        case XML_COMMENT_NODE:\n\t    return(1);\n        case XML_ENTITY_NODE:\n\t    xmlErrValidNode(ctxt, elem, XML_ERR_INTERNAL_ERROR,\n\t\t   \"Entity element not expected\\n\", NULL, NULL ,NULL);\n\t    return(0);\n        case XML_NOTATION_NODE:\n\t    xmlErrValidNode(ctxt, elem, XML_ERR_INTERNAL_ERROR,\n\t\t   \"Notation element not expected\\n\", NULL, NULL ,NULL);\n\t    return(0);\n        case XML_DOCUMENT_NODE:\n        case XML_DOCUMENT_TYPE_NODE:\n        case XML_DOCUMENT_FRAG_NODE:\n\t    xmlErrValidNode(ctxt, elem, XML_ERR_INTERNAL_ERROR,\n\t\t   \"Document element not expected\\n\", NULL, NULL ,NULL);\n\t    return(0);\n        case XML_HTML_DOCUMENT_NODE:\n\t    xmlErrValidNode(ctxt, elem, XML_ERR_INTERNAL_ERROR,\n\t\t   \"HTML Document not expected\\n\", NULL, NULL ,NULL);\n\t    return(0);\n        case XML_ELEMENT_NODE:\n\t    break;\n\tdefault:\n\t    xmlErrValidNode(ctxt, elem, XML_ERR_INTERNAL_ERROR,\n\t\t   \"unknown element type\\n\", NULL, NULL ,NULL);\n\t    return(0);\n    }\n\n    /*\n     * Fetch the declaration\n     */\n    elemDecl = xmlValidGetElemDecl(ctxt, doc, elem, &extsubset);\n    if (elemDecl == NULL)\n\treturn(0);\n\n    /*\n     * If vstateNr is not zero that means continuous validation is\n     * activated, do not try to check the content model at that level.\n     */\n    if (ctxt->vstateNr == 0) {\n    /* Check that the element content matches the definition */\n    switch (elemDecl->etype) {\n        case XML_ELEMENT_TYPE_UNDEFINED:\n\t    xmlErrValidNode(ctxt, elem, XML_DTD_UNKNOWN_ELEM,\n\t                    \"No declaration for element %s\\n\",\n\t\t   elem->name, NULL, NULL);\n\t    return(0);\n        case XML_ELEMENT_TYPE_EMPTY:\n\t    if (elem->children != NULL) {\n\t\txmlErrValidNode(ctxt, elem, XML_DTD_NOT_EMPTY,\n\t       \"Element %s was declared EMPTY this one has content\\n\",\n\t               elem->name, NULL, NULL);\n\t\tret = 0;\n\t    }\n\t    break;\n        case XML_ELEMENT_TYPE_ANY:\n\t    /* I don't think anything is required then */\n\t    break;\n        case XML_ELEMENT_TYPE_MIXED:\n\n\t    /* simple case of declared as #PCDATA */\n\t    if ((elemDecl->content != NULL) &&\n\t\t(elemDecl->content->type == XML_ELEMENT_CONTENT_PCDATA)) {\n\t\tret = xmlValidateOneCdataElement(ctxt, doc, elem);\n\t\tif (!ret) {\n\t\t    xmlErrValidNode(ctxt, elem, XML_DTD_NOT_PCDATA,\n\t       \"Element %s was declared #PCDATA but contains non text nodes\\n\",\n\t\t\t   elem->name, NULL, NULL);\n\t\t}\n\t\tbreak;\n\t    }\n\t    child = elem->children;\n\t    /* Hum, this start to get messy */\n\t    while (child != NULL) {\n\t        if (child->type == XML_ELEMENT_NODE) {\n\t\t    name = child->name;\n\t\t    if ((child->ns != NULL) && (child->ns->prefix != NULL)) {\n\t\t\txmlChar fn[50];\n\t\t\txmlChar *fullname;\n\n\t\t\tfullname = xmlBuildQName(child->name, child->ns->prefix,\n\t\t\t\t                 fn, 50);\n\t\t\tif (fullname == NULL)\n\t\t\t    return(0);\n\t\t\tcont = elemDecl->content;\n\t\t\twhile (cont != NULL) {\n\t\t\t    if (cont->type == XML_ELEMENT_CONTENT_ELEMENT) {\n\t\t\t\tif (xmlStrEqual(cont->name, fullname))\n\t\t\t\t    break;\n\t\t\t    } else if ((cont->type == XML_ELEMENT_CONTENT_OR) &&\n\t\t\t       (cont->c1 != NULL) &&\n\t\t\t       (cont->c1->type == XML_ELEMENT_CONTENT_ELEMENT)){\n\t\t\t\tif (xmlStrEqual(cont->c1->name, fullname))\n\t\t\t\t    break;\n\t\t\t    } else if ((cont->type != XML_ELEMENT_CONTENT_OR) ||\n\t\t\t\t(cont->c1 == NULL) ||\n\t\t\t\t(cont->c1->type != XML_ELEMENT_CONTENT_PCDATA)){\n\t\t\t\txmlErrValid(NULL, XML_DTD_MIXED_CORRUPT,\n\t\t\t\t\t\"Internal: MIXED struct corrupted\\n\",\n\t\t\t\t\tNULL);\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t    cont = cont->c2;\n\t\t\t}\n\t\t\tif ((fullname != fn) && (fullname != child->name))\n\t\t\t    xmlFree(fullname);\n\t\t\tif (cont != NULL)\n\t\t\t    goto child_ok;\n\t\t    }\n\t\t    cont = elemDecl->content;\n\t\t    while (cont != NULL) {\n\t\t        if (cont->type == XML_ELEMENT_CONTENT_ELEMENT) {\n\t\t\t    if (xmlStrEqual(cont->name, name)) break;\n\t\t\t} else if ((cont->type == XML_ELEMENT_CONTENT_OR) &&\n\t\t\t   (cont->c1 != NULL) &&\n\t\t\t   (cont->c1->type == XML_ELEMENT_CONTENT_ELEMENT)) {\n\t\t\t    if (xmlStrEqual(cont->c1->name, name)) break;\n\t\t\t} else if ((cont->type != XML_ELEMENT_CONTENT_OR) ||\n\t\t\t    (cont->c1 == NULL) ||\n\t\t\t    (cont->c1->type != XML_ELEMENT_CONTENT_PCDATA)) {\n\t\t\t    xmlErrValid(ctxt, XML_DTD_MIXED_CORRUPT,\n\t\t\t\t    \"Internal: MIXED struct corrupted\\n\",\n\t\t\t\t    NULL);\n\t\t\t    break;\n\t\t\t}\n\t\t\tcont = cont->c2;\n\t\t    }\n\t\t    if (cont == NULL) {\n\t\t\txmlErrValidNode(ctxt, elem, XML_DTD_INVALID_CHILD,\n\t       \"Element %s is not declared in %s list of possible children\\n\",\n\t\t\t       name, elem->name, NULL);\n\t\t\tret = 0;\n\t\t    }\n\t\t}\nchild_ok:\n\t        child = child->next;\n\t    }\n\t    break;\n        case XML_ELEMENT_TYPE_ELEMENT:\n\t    if ((doc->standalone == 1) && (extsubset == 1)) {\n\t\t/*\n\t\t * VC: Standalone Document Declaration\n\t\t *     - element types with element content, if white space\n\t\t *       occurs directly within any instance of those types.\n\t\t */\n\t\tchild = elem->children;\n\t\twhile (child != NULL) {\n\t\t    if (child->type == XML_TEXT_NODE) {\n\t\t\tconst xmlChar *content = child->content;\n\n\t\t\twhile (IS_BLANK_CH(*content))\n\t\t\t    content++;\n\t\t\tif (*content == 0) {\n\t\t\t    xmlErrValidNode(ctxt, elem,\n\t\t\t                    XML_DTD_STANDALONE_WHITE_SPACE,\n\"standalone: %s declared in the external subset contains white spaces nodes\\n\",\n\t\t\t\t   elem->name, NULL, NULL);\n\t\t\t    ret = 0;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t    child =child->next;\n\t\t}\n\t    }\n\t    child = elem->children;\n\t    cont = elemDecl->content;\n\t    tmp = xmlValidateElementContent(ctxt, child, elemDecl, 1, elem);\n\t    if (tmp <= 0)\n\t\tret = tmp;\n\t    break;\n    }\n    } /* not continuous */\n\n    /* [ VC: Required Attribute ] */\n    attr = elemDecl->attributes;\n    while (attr != NULL) {\n\tif (attr->def == XML_ATTRIBUTE_REQUIRED) {\n\t    int qualified = -1;\n\n\t    if ((attr->prefix == NULL) &&\n\t\t(xmlStrEqual(attr->name, BAD_CAST \"xmlns\"))) {\n\t\txmlNsPtr ns;\n\n\t\tns = elem->nsDef;\n\t\twhile (ns != NULL) {\n\t\t    if (ns->prefix == NULL)\n\t\t\tgoto found;\n\t\t    ns = ns->next;\n\t\t}\n\t    } else if (xmlStrEqual(attr->prefix, BAD_CAST \"xmlns\")) {\n\t\txmlNsPtr ns;\n\n\t\tns = elem->nsDef;\n\t\twhile (ns != NULL) {\n\t\t    if (xmlStrEqual(attr->name, ns->prefix))\n\t\t\tgoto found;\n\t\t    ns = ns->next;\n\t\t}\n\t    } else {\n\t\txmlAttrPtr attrib;\n\n\t\tattrib = elem->properties;\n\t\twhile (attrib != NULL) {\n\t\t    if (xmlStrEqual(attrib->name, attr->name)) {\n\t\t\tif (attr->prefix != NULL) {\n\t\t\t    xmlNsPtr nameSpace = attrib->ns;\n\n\t\t\t    if (nameSpace == NULL)\n\t\t\t\tnameSpace = elem->ns;\n\t\t\t    /*\n\t\t\t     * qualified names handling is problematic, having a\n\t\t\t     * different prefix should be possible but DTDs don't\n\t\t\t     * allow to define the URI instead of the prefix :-(\n\t\t\t     */\n\t\t\t    if (nameSpace == NULL) {\n\t\t\t\tif (qualified < 0)\n\t\t\t\t    qualified = 0;\n\t\t\t    } else if (!xmlStrEqual(nameSpace->prefix,\n\t\t\t\t\t\t    attr->prefix)) {\n\t\t\t\tif (qualified < 1)\n\t\t\t\t    qualified = 1;\n\t\t\t    } else\n\t\t\t\tgoto found;\n\t\t\t} else {\n\t\t\t    /*\n\t\t\t     * We should allow applications to define namespaces\n\t\t\t     * for their application even if the DTD doesn't\n\t\t\t     * carry one, otherwise, basically we would always\n\t\t\t     * break.\n\t\t\t     */\n\t\t\t    goto found;\n\t\t\t}\n\t\t    }\n\t\t    attrib = attrib->next;\n\t\t}\n\t    }\n\t    if (qualified == -1) {\n\t\tif (attr->prefix == NULL) {\n\t\t    xmlErrValidNode(ctxt, elem, XML_DTD_MISSING_ATTRIBUTE,\n\t\t       \"Element %s does not carry attribute %s\\n\",\n\t\t\t   elem->name, attr->name, NULL);\n\t\t    ret = 0;\n\t        } else {\n\t\t    xmlErrValidNode(ctxt, elem, XML_DTD_MISSING_ATTRIBUTE,\n\t\t       \"Element %s does not carry attribute %s:%s\\n\",\n\t\t\t   elem->name, attr->prefix,attr->name);\n\t\t    ret = 0;\n\t\t}\n\t    } else if (qualified == 0) {\n\t\txmlErrValidWarning(ctxt, elem, XML_DTD_NO_PREFIX,\n\t\t   \"Element %s required attribute %s:%s has no prefix\\n\",\n\t\t       elem->name, attr->prefix, attr->name);\n\t    } else if (qualified == 1) {\n\t\txmlErrValidWarning(ctxt, elem, XML_DTD_DIFFERENT_PREFIX,\n\t\t   \"Element %s required attribute %s:%s has different prefix\\n\",\n\t\t       elem->name, attr->prefix, attr->name);\n\t    }\n\t} else if (attr->def == XML_ATTRIBUTE_FIXED) {\n\t    /*\n\t     * Special tests checking #FIXED namespace declarations\n\t     * have the right value since this is not done as an\n\t     * attribute checking\n\t     */\n\t    if ((attr->prefix == NULL) &&\n\t\t(xmlStrEqual(attr->name, BAD_CAST \"xmlns\"))) {\n\t\txmlNsPtr ns;\n\n\t\tns = elem->nsDef;\n\t\twhile (ns != NULL) {\n\t\t    if (ns->prefix == NULL) {\n\t\t\tif (!xmlStrEqual(attr->defaultValue, ns->href)) {\n\t\t\t    xmlErrValidNode(ctxt, elem,\n\t\t\t           XML_DTD_ELEM_DEFAULT_NAMESPACE,\n   \"Element %s namespace name for default namespace does not match the DTD\\n\",\n\t\t\t\t   elem->name, NULL, NULL);\n\t\t\t    ret = 0;\n\t\t\t}\n\t\t\tgoto found;\n\t\t    }\n\t\t    ns = ns->next;\n\t\t}\n\t    } else if (xmlStrEqual(attr->prefix, BAD_CAST \"xmlns\")) {\n\t\txmlNsPtr ns;\n\n\t\tns = elem->nsDef;\n\t\twhile (ns != NULL) {\n\t\t    if (xmlStrEqual(attr->name, ns->prefix)) {\n\t\t\tif (!xmlStrEqual(attr->defaultValue, ns->href)) {\n\t\t\t    xmlErrValidNode(ctxt, elem, XML_DTD_ELEM_NAMESPACE,\n\t\t   \"Element %s namespace name for %s does not match the DTD\\n\",\n\t\t\t\t   elem->name, ns->prefix, NULL);\n\t\t\t    ret = 0;\n\t\t\t}\n\t\t\tgoto found;\n\t\t    }\n\t\t    ns = ns->next;\n\t\t}\n\t    }\n\t}\nfound:\n        attr = attr->nexth;\n    }\n    return(ret);\n}\n\n/**\n * xmlValidateRoot:\n * @ctxt:  the validation context\n * @doc:  a document instance\n *\n * Try to validate a the root element\n * basically it does the following check as described by the\n * XML-1.0 recommendation:\n *  - [ VC: Root Element Type ]\n * it doesn't try to recurse or apply other check to the element\n *\n * returns 1 if valid or 0 otherwise\n */\n\nint\nxmlValidateRoot(xmlValidCtxtPtr ctxt, xmlDocPtr doc) {\n    xmlNodePtr root;\n    int ret;\n\n    if (doc == NULL) return(0);\n\n    root = xmlDocGetRootElement(doc);\n    if ((root == NULL) || (root->name == NULL)) {\n\txmlErrValid(ctxt, XML_DTD_NO_ROOT,\n\t            \"no root element\\n\", NULL);\n        return(0);\n    }\n\n    /*\n     * When doing post validation against a separate DTD, those may\n     * no internal subset has been generated\n     */\n    if ((doc->intSubset != NULL) &&\n\t(doc->intSubset->name != NULL)) {\n\t/*\n\t * Check first the document root against the NQName\n\t */\n\tif (!xmlStrEqual(doc->intSubset->name, root->name)) {\n\t    if ((root->ns != NULL) && (root->ns->prefix != NULL)) {\n\t\txmlChar fn[50];\n\t\txmlChar *fullname;\n\n\t\tfullname = xmlBuildQName(root->name, root->ns->prefix, fn, 50);\n\t\tif (fullname == NULL) {\n\t\t    xmlVErrMemory(ctxt, NULL);\n\t\t    return(0);\n\t\t}\n\t\tret = xmlStrEqual(doc->intSubset->name, fullname);\n\t\tif ((fullname != fn) && (fullname != root->name))\n\t\t    xmlFree(fullname);\n\t\tif (ret == 1)\n\t\t    goto name_ok;\n\t    }\n\t    if ((xmlStrEqual(doc->intSubset->name, BAD_CAST \"HTML\")) &&\n\t\t(xmlStrEqual(root->name, BAD_CAST \"html\")))\n\t\tgoto name_ok;\n\t    xmlErrValidNode(ctxt, root, XML_DTD_ROOT_NAME,\n\t\t   \"root and DTD name do not match '%s' and '%s'\\n\",\n\t\t   root->name, doc->intSubset->name, NULL);\n\t    return(0);\n\t}\n    }\nname_ok:\n    return(1);\n}\n\n\n/**\n * xmlValidateElement:\n * @ctxt:  the validation context\n * @doc:  a document instance\n * @elem:  an element instance\n *\n * Try to validate the subtree under an element\n *\n * returns 1 if valid or 0 otherwise\n */\n\nint\nxmlValidateElement(xmlValidCtxtPtr ctxt, xmlDocPtr doc, xmlNodePtr elem) {\n    xmlNodePtr child;\n    xmlAttrPtr attr;\n    xmlNsPtr ns;\n    const xmlChar *value;\n    int ret = 1;\n\n    if (elem == NULL) return(0);\n\n    /*\n     * XInclude elements were added after parsing in the infoset,\n     * they don't really mean anything validation wise.\n     */\n    if ((elem->type == XML_XINCLUDE_START) ||\n\t(elem->type == XML_XINCLUDE_END) ||\n\t(elem->type == XML_NAMESPACE_DECL))\n\treturn(1);\n\n    CHECK_DTD;\n\n    /*\n     * Entities references have to be handled separately\n     */\n    if (elem->type == XML_ENTITY_REF_NODE) {\n\treturn(1);\n    }\n\n    ret &= xmlValidateOneElement(ctxt, doc, elem);\n    if (elem->type == XML_ELEMENT_NODE) {\n\tattr = elem->properties;\n\twhile (attr != NULL) {\n\t    value = xmlNodeListGetString(doc, attr->children, 0);\n\t    ret &= xmlValidateOneAttribute(ctxt, doc, elem, attr, value);\n\t    if (value != NULL)\n\t\txmlFree((char *)value);\n\t    attr= attr->next;\n\t}\n\tns = elem->nsDef;\n\twhile (ns != NULL) {\n\t    if (elem->ns == NULL)\n\t\tret &= xmlValidateOneNamespace(ctxt, doc, elem, NULL,\n\t\t\t\t\t       ns, ns->href);\n\t    else\n\t\tret &= xmlValidateOneNamespace(ctxt, doc, elem,\n\t\t                               elem->ns->prefix, ns, ns->href);\n\t    ns = ns->next;\n\t}\n    }\n    child = elem->children;\n    while (child != NULL) {\n        ret &= xmlValidateElement(ctxt, doc, child);\n        child = child->next;\n    }\n\n    return(ret);\n}\n\n/**\n * xmlValidateRef:\n * @ref:   A reference to be validated\n * @ctxt:  Validation context\n * @name:  Name of ID we are searching for\n *\n */\nstatic void\nxmlValidateRef(xmlRefPtr ref, xmlValidCtxtPtr ctxt,\n\t                   const xmlChar *name) {\n    xmlAttrPtr id;\n    xmlAttrPtr attr;\n\n    if (ref == NULL)\n\treturn;\n    if ((ref->attr == NULL) && (ref->name == NULL))\n\treturn;\n    attr = ref->attr;\n    if (attr == NULL) {\n\txmlChar *dup, *str = NULL, *cur, save;\n\n\tdup = xmlStrdup(name);\n\tif (dup == NULL) {\n\t    ctxt->valid = 0;\n\t    return;\n\t}\n\tcur = dup;\n\twhile (*cur != 0) {\n\t    str = cur;\n\t    while ((*cur != 0) && (!IS_BLANK_CH(*cur))) cur++;\n\t    save = *cur;\n\t    *cur = 0;\n\t    id = xmlGetID(ctxt->doc, str);\n\t    if (id == NULL) {\n\t\txmlErrValidNodeNr(ctxt, NULL, XML_DTD_UNKNOWN_ID,\n\t   \"attribute %s line %d references an unknown ID \\\"%s\\\"\\n\",\n\t\t       ref->name, ref->lineno, str);\n\t\tctxt->valid = 0;\n\t    }\n\t    if (save == 0)\n\t\tbreak;\n\t    *cur = save;\n\t    while (IS_BLANK_CH(*cur)) cur++;\n\t}\n\txmlFree(dup);\n    } else if (attr->atype == XML_ATTRIBUTE_IDREF) {\n\tid = xmlGetID(ctxt->doc, name);\n\tif (id == NULL) {\n\t    xmlErrValidNode(ctxt, attr->parent, XML_DTD_UNKNOWN_ID,\n\t   \"IDREF attribute %s references an unknown ID \\\"%s\\\"\\n\",\n\t\t   attr->name, name, NULL);\n\t    ctxt->valid = 0;\n\t}\n    } else if (attr->atype == XML_ATTRIBUTE_IDREFS) {\n\txmlChar *dup, *str = NULL, *cur, save;\n\n\tdup = xmlStrdup(name);\n\tif (dup == NULL) {\n\t    xmlVErrMemory(ctxt, \"IDREFS split\");\n\t    ctxt->valid = 0;\n\t    return;\n\t}\n\tcur = dup;\n\twhile (*cur != 0) {\n\t    str = cur;\n\t    while ((*cur != 0) && (!IS_BLANK_CH(*cur))) cur++;\n\t    save = *cur;\n\t    *cur = 0;\n\t    id = xmlGetID(ctxt->doc, str);\n\t    if (id == NULL) {\n\t\txmlErrValidNode(ctxt, attr->parent, XML_DTD_UNKNOWN_ID,\n\t   \"IDREFS attribute %s references an unknown ID \\\"%s\\\"\\n\",\n\t\t\t     attr->name, str, NULL);\n\t\tctxt->valid = 0;\n\t    }\n\t    if (save == 0)\n\t\tbreak;\n\t    *cur = save;\n\t    while (IS_BLANK_CH(*cur)) cur++;\n\t}\n\txmlFree(dup);\n    }\n}\n\n/**\n * xmlWalkValidateList:\n * @data:  Contents of current link\n * @user:  Value supplied by the user\n *\n * Returns 0 to abort the walk or 1 to continue\n */\nstatic int\nxmlWalkValidateList(const void *data, void *user)\n{\n\txmlValidateMemoPtr memo = (xmlValidateMemoPtr)user;\n\txmlValidateRef((xmlRefPtr)data, memo->ctxt, memo->name);\n\treturn 1;\n}\n\n/**\n * xmlValidateCheckRefCallback:\n * @ref_list:  List of references\n * @ctxt:  Validation context\n * @name:  Name of ID we are searching for\n *\n */\nstatic void\nxmlValidateCheckRefCallback(void *payload, void *data, const xmlChar *name) {\n    xmlListPtr ref_list = (xmlListPtr) payload;\n    xmlValidCtxtPtr ctxt = (xmlValidCtxtPtr) data;\n    xmlValidateMemo memo;\n\n    if (ref_list == NULL)\n\treturn;\n    memo.ctxt = ctxt;\n    memo.name = name;\n\n    xmlListWalk(ref_list, xmlWalkValidateList, &memo);\n\n}\n\n/**\n * xmlValidateDocumentFinal:\n * @ctxt:  the validation context\n * @doc:  a document instance\n *\n * Does the final step for the document validation once all the\n * incremental validation steps have been completed\n *\n * basically it does the following checks described by the XML Rec\n *\n * Check all the IDREF/IDREFS attributes definition for validity\n *\n * returns 1 if valid or 0 otherwise\n */\n\nint\nxmlValidateDocumentFinal(xmlValidCtxtPtr ctxt, xmlDocPtr doc) {\n    xmlRefTablePtr table;\n    unsigned int save;\n\n    if (ctxt == NULL)\n        return(0);\n    if (doc == NULL) {\n        xmlErrValid(ctxt, XML_DTD_NO_DOC,\n\t\t\"xmlValidateDocumentFinal: doc == NULL\\n\", NULL);\n\treturn(0);\n    }\n\n    /* trick to get correct line id report */\n    save = ctxt->finishDtd;\n    ctxt->finishDtd = 0;\n\n    /*\n     * Check all the NOTATION/NOTATIONS attributes\n     */\n    /*\n     * Check all the ENTITY/ENTITIES attributes definition for validity\n     */\n    /*\n     * Check all the IDREF/IDREFS attributes definition for validity\n     */\n    table = (xmlRefTablePtr) doc->refs;\n    ctxt->doc = doc;\n    ctxt->valid = 1;\n    xmlHashScan(table, xmlValidateCheckRefCallback, ctxt);\n\n    ctxt->finishDtd = save;\n    return(ctxt->valid);\n}\n\n/**\n * xmlValidateDtd:\n * @ctxt:  the validation context\n * @doc:  a document instance\n * @dtd:  a dtd instance\n *\n * Try to validate the document against the dtd instance\n *\n * Basically it does check all the definitions in the DtD.\n * Note the the internal subset (if present) is de-coupled\n * (i.e. not used), which could give problems if ID or IDREF\n * is present.\n *\n * returns 1 if valid or 0 otherwise\n */\n\nint\nxmlValidateDtd(xmlValidCtxtPtr ctxt, xmlDocPtr doc, xmlDtdPtr dtd) {\n    int ret;\n    xmlDtdPtr oldExt, oldInt;\n    xmlNodePtr root;\n\n    if (dtd == NULL) return(0);\n    if (doc == NULL) return(0);\n    oldExt = doc->extSubset;\n    oldInt = doc->intSubset;\n    doc->extSubset = dtd;\n    doc->intSubset = NULL;\n    ret = xmlValidateRoot(ctxt, doc);\n    if (ret == 0) {\n\tdoc->extSubset = oldExt;\n\tdoc->intSubset = oldInt;\n\treturn(ret);\n    }\n    if (doc->ids != NULL) {\n          xmlFreeIDTable(doc->ids);\n          doc->ids = NULL;\n    }\n    if (doc->refs != NULL) {\n          xmlFreeRefTable(doc->refs);\n          doc->refs = NULL;\n    }\n    root = xmlDocGetRootElement(doc);\n    ret = xmlValidateElement(ctxt, doc, root);\n    ret &= xmlValidateDocumentFinal(ctxt, doc);\n    doc->extSubset = oldExt;\n    doc->intSubset = oldInt;\n    return(ret);\n}\n\nstatic void\nxmlValidateNotationCallback(void *payload, void *data,\n\t                    const xmlChar *name ATTRIBUTE_UNUSED) {\n    xmlEntityPtr cur = (xmlEntityPtr) payload;\n    xmlValidCtxtPtr ctxt = (xmlValidCtxtPtr) data;\n    if (cur == NULL)\n\treturn;\n    if (cur->etype == XML_EXTERNAL_GENERAL_UNPARSED_ENTITY) {\n\txmlChar *notation = cur->content;\n\n\tif (notation != NULL) {\n\t    int ret;\n\n\t    ret = xmlValidateNotationUse(ctxt, cur->doc, notation);\n\t    if (ret != 1) {\n\t\tctxt->valid = 0;\n\t    }\n\t}\n    }\n}\n\nstatic void\nxmlValidateAttributeCallback(void *payload, void *data,\n\t                     const xmlChar *name ATTRIBUTE_UNUSED) {\n    xmlAttributePtr cur = (xmlAttributePtr) payload;\n    xmlValidCtxtPtr ctxt = (xmlValidCtxtPtr) data;\n    int ret;\n    xmlDocPtr doc;\n    xmlElementPtr elem = NULL;\n\n    if (cur == NULL)\n\treturn;\n    switch (cur->atype) {\n\tcase XML_ATTRIBUTE_CDATA:\n\tcase XML_ATTRIBUTE_ID:\n\tcase XML_ATTRIBUTE_IDREF\t:\n\tcase XML_ATTRIBUTE_IDREFS:\n\tcase XML_ATTRIBUTE_NMTOKEN:\n\tcase XML_ATTRIBUTE_NMTOKENS:\n\tcase XML_ATTRIBUTE_ENUMERATION:\n\t    break;\n\tcase XML_ATTRIBUTE_ENTITY:\n\tcase XML_ATTRIBUTE_ENTITIES:\n\tcase XML_ATTRIBUTE_NOTATION:\n\t    if (cur->defaultValue != NULL) {\n\n\t\tret = xmlValidateAttributeValue2(ctxt, ctxt->doc, cur->name,\n\t\t\t                         cur->atype, cur->defaultValue);\n\t\tif ((ret == 0) && (ctxt->valid == 1))\n\t\t    ctxt->valid = 0;\n\t    }\n\t    if (cur->tree != NULL) {\n\t\txmlEnumerationPtr tree = cur->tree;\n\t\twhile (tree != NULL) {\n\t\t    ret = xmlValidateAttributeValue2(ctxt, ctxt->doc,\n\t\t\t\t    cur->name, cur->atype, tree->name);\n\t\t    if ((ret == 0) && (ctxt->valid == 1))\n\t\t\tctxt->valid = 0;\n\t\t    tree = tree->next;\n\t\t}\n\t    }\n    }\n    if (cur->atype == XML_ATTRIBUTE_NOTATION) {\n\tdoc = cur->doc;\n\tif (cur->elem == NULL) {\n\t    xmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,\n\t\t   \"xmlValidateAttributeCallback(%s): internal error\\n\",\n\t\t   (const char *) cur->name);\n\t    return;\n\t}\n\n\tif (doc != NULL)\n\t    elem = xmlGetDtdElementDesc(doc->intSubset, cur->elem);\n\tif ((elem == NULL) && (doc != NULL))\n\t    elem = xmlGetDtdElementDesc(doc->extSubset, cur->elem);\n\tif ((elem == NULL) && (cur->parent != NULL) &&\n\t    (cur->parent->type == XML_DTD_NODE))\n\t    elem = xmlGetDtdElementDesc((xmlDtdPtr) cur->parent, cur->elem);\n\tif (elem == NULL) {\n\t    xmlErrValidNode(ctxt, NULL, XML_DTD_UNKNOWN_ELEM,\n\t\t   \"attribute %s: could not find decl for element %s\\n\",\n\t\t   cur->name, cur->elem, NULL);\n\t    return;\n\t}\n\tif (elem->etype == XML_ELEMENT_TYPE_EMPTY) {\n\t    xmlErrValidNode(ctxt, NULL, XML_DTD_EMPTY_NOTATION,\n\t\t   \"NOTATION attribute %s declared for EMPTY element %s\\n\",\n\t\t   cur->name, cur->elem, NULL);\n\t    ctxt->valid = 0;\n\t}\n    }\n}\n\n/**\n * xmlValidateDtdFinal:\n * @ctxt:  the validation context\n * @doc:  a document instance\n *\n * Does the final step for the dtds validation once all the\n * subsets have been parsed\n *\n * basically it does the following checks described by the XML Rec\n * - check that ENTITY and ENTITIES type attributes default or\n *   possible values matches one of the defined entities.\n * - check that NOTATION type attributes default or\n *   possible values matches one of the defined notations.\n *\n * returns 1 if valid or 0 if invalid and -1 if not well-formed\n */\n\nint\nxmlValidateDtdFinal(xmlValidCtxtPtr ctxt, xmlDocPtr doc) {\n    xmlDtdPtr dtd;\n    xmlAttributeTablePtr table;\n    xmlEntitiesTablePtr entities;\n\n    if ((doc == NULL) || (ctxt == NULL)) return(0);\n    if ((doc->intSubset == NULL) && (doc->extSubset == NULL))\n\treturn(0);\n    ctxt->doc = doc;\n    ctxt->valid = 1;\n    dtd = doc->intSubset;\n    if ((dtd != NULL) && (dtd->attributes != NULL)) {\n\ttable = (xmlAttributeTablePtr) dtd->attributes;\n\txmlHashScan(table, xmlValidateAttributeCallback, ctxt);\n    }\n    if ((dtd != NULL) && (dtd->entities != NULL)) {\n\tentities = (xmlEntitiesTablePtr) dtd->entities;\n\txmlHashScan(entities, xmlValidateNotationCallback, ctxt);\n    }\n    dtd = doc->extSubset;\n    if ((dtd != NULL) && (dtd->attributes != NULL)) {\n\ttable = (xmlAttributeTablePtr) dtd->attributes;\n\txmlHashScan(table, xmlValidateAttributeCallback, ctxt);\n    }\n    if ((dtd != NULL) && (dtd->entities != NULL)) {\n\tentities = (xmlEntitiesTablePtr) dtd->entities;\n\txmlHashScan(entities, xmlValidateNotationCallback, ctxt);\n    }\n    return(ctxt->valid);\n}\n\n/**\n * xmlValidateDocument:\n * @ctxt:  the validation context\n * @doc:  a document instance\n *\n * Try to validate the document instance\n *\n * basically it does the all the checks described by the XML Rec\n * i.e. validates the internal and external subset (if present)\n * and validate the document tree.\n *\n * returns 1 if valid or 0 otherwise\n */\n\nint\nxmlValidateDocument(xmlValidCtxtPtr ctxt, xmlDocPtr doc) {\n    int ret;\n    xmlNodePtr root;\n\n    if (doc == NULL)\n        return(0);\n    if ((doc->intSubset == NULL) && (doc->extSubset == NULL)) {\n        xmlErrValid(ctxt, XML_DTD_NO_DTD,\n\t            \"no DTD found!\\n\", NULL);\n\treturn(0);\n    }\n    if ((doc->intSubset != NULL) && ((doc->intSubset->SystemID != NULL) ||\n\t(doc->intSubset->ExternalID != NULL)) && (doc->extSubset == NULL)) {\n\txmlChar *sysID;\n\tif (doc->intSubset->SystemID != NULL) {\n\t    sysID = xmlBuildURI(doc->intSubset->SystemID,\n\t\t\tdoc->URL);\n\t    if (sysID == NULL) {\n\t        xmlErrValid(ctxt, XML_DTD_LOAD_ERROR,\n\t\t\t\"Could not build URI for external subset \\\"%s\\\"\\n\",\n\t\t\t(const char *) doc->intSubset->SystemID);\n\t\treturn 0;\n\t    }\n\t} else\n\t    sysID = NULL;\n        doc->extSubset = xmlParseDTD(doc->intSubset->ExternalID,\n\t\t\t(const xmlChar *)sysID);\n\tif (sysID != NULL)\n\t    xmlFree(sysID);\n        if (doc->extSubset == NULL) {\n\t    if (doc->intSubset->SystemID != NULL) {\n\t\txmlErrValid(ctxt, XML_DTD_LOAD_ERROR,\n\t\t       \"Could not load the external subset \\\"%s\\\"\\n\",\n\t\t       (const char *) doc->intSubset->SystemID);\n\t    } else {\n\t\txmlErrValid(ctxt, XML_DTD_LOAD_ERROR,\n\t\t       \"Could not load the external subset \\\"%s\\\"\\n\",\n\t\t       (const char *) doc->intSubset->ExternalID);\n\t    }\n\t    return(0);\n\t}\n    }\n\n    if (doc->ids != NULL) {\n          xmlFreeIDTable(doc->ids);\n          doc->ids = NULL;\n    }\n    if (doc->refs != NULL) {\n          xmlFreeRefTable(doc->refs);\n          doc->refs = NULL;\n    }\n    ret = xmlValidateDtdFinal(ctxt, doc);\n    if (!xmlValidateRoot(ctxt, doc)) return(0);\n\n    root = xmlDocGetRootElement(doc);\n    ret &= xmlValidateElement(ctxt, doc, root);\n    ret &= xmlValidateDocumentFinal(ctxt, doc);\n    return(ret);\n}\n\n/************************************************************************\n *\t\t\t\t\t\t\t\t\t*\n *\t\tRoutines for dynamic validation editing\t\t\t*\n *\t\t\t\t\t\t\t\t\t*\n ************************************************************************/\n\n/**\n * xmlValidGetPotentialChildren:\n * @ctree:  an element content tree\n * @names:  an array to store the list of child names\n * @len:  a pointer to the number of element in the list\n * @max:  the size of the array\n *\n * Build/extend a list of  potential children allowed by the content tree\n *\n * returns the number of element in the list, or -1 in case of error.\n */\n\nint\nxmlValidGetPotentialChildren(xmlElementContent *ctree,\n                             const xmlChar **names,\n                             int *len, int max) {\n    int i;\n\n    if ((ctree == NULL) || (names == NULL) || (len == NULL))\n        return(-1);\n    if (*len >= max) return(*len);\n\n    switch (ctree->type) {\n\tcase XML_ELEMENT_CONTENT_PCDATA:\n\t    for (i = 0; i < *len;i++)\n\t\tif (xmlStrEqual(BAD_CAST \"#PCDATA\", names[i])) return(*len);\n\t    names[(*len)++] = BAD_CAST \"#PCDATA\";\n\t    break;\n\tcase XML_ELEMENT_CONTENT_ELEMENT:\n\t    for (i = 0; i < *len;i++)\n\t\tif (xmlStrEqual(ctree->name, names[i])) return(*len);\n\t    names[(*len)++] = ctree->name;\n\t    break;\n\tcase XML_ELEMENT_CONTENT_SEQ:\n\t    xmlValidGetPotentialChildren(ctree->c1, names, len, max);\n\t    xmlValidGetPotentialChildren(ctree->c2, names, len, max);\n\t    break;\n\tcase XML_ELEMENT_CONTENT_OR:\n\t    xmlValidGetPotentialChildren(ctree->c1, names, len, max);\n\t    xmlValidGetPotentialChildren(ctree->c2, names, len, max);\n\t    break;\n   }\n\n   return(*len);\n}\n\n/*\n * Dummy function to suppress messages while we try out valid elements\n */\nstatic void XMLCDECL xmlNoValidityErr(void *ctx ATTRIBUTE_UNUSED,\n                                const char *msg ATTRIBUTE_UNUSED, ...) {\n    return;\n}\n\n/**\n * xmlValidGetValidElements:\n * @prev:  an element to insert after\n * @next:  an element to insert next\n * @names:  an array to store the list of child names\n * @max:  the size of the array\n *\n * This function returns the list of authorized children to insert\n * within an existing tree while respecting the validity constraints\n * forced by the Dtd. The insertion point is defined using @prev and\n * @next in the following ways:\n *  to insert before 'node': xmlValidGetValidElements(node->prev, node, ...\n *  to insert next 'node': xmlValidGetValidElements(node, node->next, ...\n *  to replace 'node': xmlValidGetValidElements(node->prev, node->next, ...\n *  to prepend a child to 'node': xmlValidGetValidElements(NULL, node->childs,\n *  to append a child to 'node': xmlValidGetValidElements(node->last, NULL, ...\n *\n * pointers to the element names are inserted at the beginning of the array\n * and do not need to be freed.\n *\n * returns the number of element in the list, or -1 in case of error. If\n *    the function returns the value @max the caller is invited to grow the\n *    receiving array and retry.\n */\n\nint\nxmlValidGetValidElements(xmlNode *prev, xmlNode *next, const xmlChar **names,\n                         int max) {\n    xmlValidCtxt vctxt;\n    int nb_valid_elements = 0;\n    const xmlChar *elements[256]={0};\n    int nb_elements = 0, i;\n    const xmlChar *name;\n\n    xmlNode *ref_node;\n    xmlNode *parent;\n    xmlNode *test_node;\n\n    xmlNode *prev_next;\n    xmlNode *next_prev;\n    xmlNode *parent_childs;\n    xmlNode *parent_last;\n\n    xmlElement *element_desc;\n\n    if (prev == NULL && next == NULL)\n        return(-1);\n\n    if (names == NULL) return(-1);\n    if (max <= 0) return(-1);\n\n    memset(&vctxt, 0, sizeof (xmlValidCtxt));\n    vctxt.error = xmlNoValidityErr;\t/* this suppresses err/warn output */\n\n    nb_valid_elements = 0;\n    ref_node = prev ? prev : next;\n    parent = ref_node->parent;\n\n    /*\n     * Retrieves the parent element declaration\n     */\n    element_desc = xmlGetDtdElementDesc(parent->doc->intSubset,\n                                         parent->name);\n    if ((element_desc == NULL) && (parent->doc->extSubset != NULL))\n        element_desc = xmlGetDtdElementDesc(parent->doc->extSubset,\n                                             parent->name);\n    if (element_desc == NULL) return(-1);\n\n    /*\n     * Do a backup of the current tree structure\n     */\n    prev_next = prev ? prev->next : NULL;\n    next_prev = next ? next->prev : NULL;\n    parent_childs = parent->children;\n    parent_last = parent->last;\n\n    /*\n     * Creates a dummy node and insert it into the tree\n     */\n    test_node = xmlNewDocNode (ref_node->doc, NULL, BAD_CAST \"<!dummy?>\", NULL);\n    if (test_node == NULL)\n        return(-1);\n\n    test_node->parent = parent;\n    test_node->prev = prev;\n    test_node->next = next;\n    name = test_node->name;\n\n    if (prev) prev->next = test_node;\n    else parent->children = test_node;\n\n    if (next) next->prev = test_node;\n    else parent->last = test_node;\n\n    /*\n     * Insert each potential child node and check if the parent is\n     * still valid\n     */\n    nb_elements = xmlValidGetPotentialChildren(element_desc->content,\n\t\t       elements, &nb_elements, 256);\n\n    for (i = 0;i < nb_elements;i++) {\n\ttest_node->name = elements[i];\n\tif (xmlValidateOneElement(&vctxt, parent->doc, parent)) {\n\t    int j;\n\n\t    for (j = 0; j < nb_valid_elements;j++)\n\t\tif (xmlStrEqual(elements[i], names[j])) break;\n\t    names[nb_valid_elements++] = elements[i];\n\t    if (nb_valid_elements >= max) break;\n\t}\n    }\n\n    /*\n     * Restore the tree structure\n     */\n    if (prev) prev->next = prev_next;\n    if (next) next->prev = next_prev;\n    parent->children = parent_childs;\n    parent->last = parent_last;\n\n    /*\n     * Free up the dummy node\n     */\n    test_node->name = name;\n    xmlFreeNode(test_node);\n\n    return(nb_valid_elements);\n}\n#endif /* LIBXML_VALID_ENABLED */\n\n#define bottom_valid\n#include \"elfgcchack.h\"\n"], "fixing_code": ["0 1 doc 0 0\n1 14 #text 0 1 \n    \n1 1 xi:include 1 0\n1 14 #text 0 1 \n    \n1 1 elem 0 0\n2 14 #text 0 1 \n        \n2 1 ns:elem 1 0\n2 14 #text 0 1 \n    \n1 15 elem 0 0\n1 14 #text 0 1 \n    \n1 14 #text 0 1 \n            \n1 1 ns:elem 1 0\n1 14 #text 0 1 \n        \n1 14 #text 0 1 \n\n0 15 doc 0 0\n", "/*\n * valid.c : part of the code use to do the DTD handling and the validity\n *           checking\n *\n * See Copyright for the status of this software.\n *\n * daniel@veillard.com\n */\n\n#define IN_LIBXML\n#include \"libxml.h\"\n\n#include <string.h>\n\n#ifdef HAVE_STDLIB_H\n#include <stdlib.h>\n#endif\n\n#include <libxml/xmlmemory.h>\n#include <libxml/hash.h>\n#include <libxml/uri.h>\n#include <libxml/valid.h>\n#include <libxml/parser.h>\n#include <libxml/parserInternals.h>\n#include <libxml/xmlerror.h>\n#include <libxml/list.h>\n#include <libxml/globals.h>\n\nstatic xmlElementPtr xmlGetDtdElementDesc2(xmlDtdPtr dtd, const xmlChar *name,\n\t                           int create);\n/* #define DEBUG_VALID_ALGO */\n/* #define DEBUG_REGEXP_ALGO */\n\n#define TODO\t\t\t\t\t\t\t\t\\\n    xmlGenericError(xmlGenericErrorContext,\t\t\t\t\\\n\t    \"Unimplemented block at %s:%d\\n\",\t\t\t\t\\\n            __FILE__, __LINE__);\n\n#ifdef LIBXML_VALID_ENABLED\nstatic int\nxmlValidateAttributeValueInternal(xmlDocPtr doc, xmlAttributeType type,\n                                  const xmlChar *value);\n#endif\n/************************************************************************\n *\t\t\t\t\t\t\t\t\t*\n *\t\t\tError handling routines\t\t\t\t*\n *\t\t\t\t\t\t\t\t\t*\n ************************************************************************/\n\n/**\n * xmlVErrMemory:\n * @ctxt:  an XML validation parser context\n * @extra:  extra information\n *\n * Handle an out of memory error\n */\nstatic void\nxmlVErrMemory(xmlValidCtxtPtr ctxt, const char *extra)\n{\n    xmlGenericErrorFunc channel = NULL;\n    xmlParserCtxtPtr pctxt = NULL;\n    void *data = NULL;\n\n    if (ctxt != NULL) {\n        channel = ctxt->error;\n        data = ctxt->userData;\n\t/* Use the special values to detect if it is part of a parsing\n\t   context */\n\tif ((ctxt->finishDtd == XML_CTXT_FINISH_DTD_0) ||\n\t    (ctxt->finishDtd == XML_CTXT_FINISH_DTD_1)) {\n\t    long delta = (char *) ctxt - (char *) ctxt->userData;\n\t    if ((delta > 0) && (delta < 250))\n\t\tpctxt = ctxt->userData;\n\t}\n    }\n    if (extra)\n        __xmlRaiseError(NULL, channel, data,\n                        pctxt, NULL, XML_FROM_VALID, XML_ERR_NO_MEMORY,\n                        XML_ERR_FATAL, NULL, 0, extra, NULL, NULL, 0, 0,\n                        \"Memory allocation failed : %s\\n\", extra);\n    else\n        __xmlRaiseError(NULL, channel, data,\n                        pctxt, NULL, XML_FROM_VALID, XML_ERR_NO_MEMORY,\n                        XML_ERR_FATAL, NULL, 0, NULL, NULL, NULL, 0, 0,\n                        \"Memory allocation failed\\n\");\n}\n\n/**\n * xmlErrValid:\n * @ctxt:  an XML validation parser context\n * @error:  the error number\n * @extra:  extra information\n *\n * Handle a validation error\n */\nstatic void LIBXML_ATTR_FORMAT(3,0)\nxmlErrValid(xmlValidCtxtPtr ctxt, xmlParserErrors error,\n            const char *msg, const char *extra)\n{\n    xmlGenericErrorFunc channel = NULL;\n    xmlParserCtxtPtr pctxt = NULL;\n    void *data = NULL;\n\n    if (ctxt != NULL) {\n        channel = ctxt->error;\n        data = ctxt->userData;\n\t/* Use the special values to detect if it is part of a parsing\n\t   context */\n\tif ((ctxt->finishDtd == XML_CTXT_FINISH_DTD_0) ||\n\t    (ctxt->finishDtd == XML_CTXT_FINISH_DTD_1)) {\n\t    long delta = (char *) ctxt - (char *) ctxt->userData;\n\t    if ((delta > 0) && (delta < 250))\n\t\tpctxt = ctxt->userData;\n\t}\n    }\n    if (extra)\n        __xmlRaiseError(NULL, channel, data,\n                        pctxt, NULL, XML_FROM_VALID, error,\n                        XML_ERR_ERROR, NULL, 0, extra, NULL, NULL, 0, 0,\n                        msg, extra);\n    else\n        __xmlRaiseError(NULL, channel, data,\n                        pctxt, NULL, XML_FROM_VALID, error,\n                        XML_ERR_ERROR, NULL, 0, NULL, NULL, NULL, 0, 0,\n                        \"%s\", msg);\n}\n\n#if defined(LIBXML_VALID_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)\n/**\n * xmlErrValidNode:\n * @ctxt:  an XML validation parser context\n * @node:  the node raising the error\n * @error:  the error number\n * @str1:  extra information\n * @str2:  extra information\n * @str3:  extra information\n *\n * Handle a validation error, provide contextual information\n */\nstatic void LIBXML_ATTR_FORMAT(4,0)\nxmlErrValidNode(xmlValidCtxtPtr ctxt,\n                xmlNodePtr node, xmlParserErrors error,\n                const char *msg, const xmlChar * str1,\n                const xmlChar * str2, const xmlChar * str3)\n{\n    xmlStructuredErrorFunc schannel = NULL;\n    xmlGenericErrorFunc channel = NULL;\n    xmlParserCtxtPtr pctxt = NULL;\n    void *data = NULL;\n\n    if (ctxt != NULL) {\n        channel = ctxt->error;\n        data = ctxt->userData;\n\t/* Use the special values to detect if it is part of a parsing\n\t   context */\n\tif ((ctxt->finishDtd == XML_CTXT_FINISH_DTD_0) ||\n\t    (ctxt->finishDtd == XML_CTXT_FINISH_DTD_1)) {\n\t    long delta = (char *) ctxt - (char *) ctxt->userData;\n\t    if ((delta > 0) && (delta < 250))\n\t\tpctxt = ctxt->userData;\n\t}\n    }\n    __xmlRaiseError(schannel, channel, data, pctxt, node, XML_FROM_VALID, error,\n                    XML_ERR_ERROR, NULL, 0,\n                    (const char *) str1,\n                    (const char *) str2,\n                    (const char *) str3, 0, 0, msg, str1, str2, str3);\n}\n#endif /* LIBXML_VALID_ENABLED or LIBXML_SCHEMAS_ENABLED */\n\n#ifdef LIBXML_VALID_ENABLED\n/**\n * xmlErrValidNodeNr:\n * @ctxt:  an XML validation parser context\n * @node:  the node raising the error\n * @error:  the error number\n * @str1:  extra information\n * @int2:  extra information\n * @str3:  extra information\n *\n * Handle a validation error, provide contextual information\n */\nstatic void LIBXML_ATTR_FORMAT(4,0)\nxmlErrValidNodeNr(xmlValidCtxtPtr ctxt,\n                xmlNodePtr node, xmlParserErrors error,\n                const char *msg, const xmlChar * str1,\n                int int2, const xmlChar * str3)\n{\n    xmlStructuredErrorFunc schannel = NULL;\n    xmlGenericErrorFunc channel = NULL;\n    xmlParserCtxtPtr pctxt = NULL;\n    void *data = NULL;\n\n    if (ctxt != NULL) {\n        channel = ctxt->error;\n        data = ctxt->userData;\n\t/* Use the special values to detect if it is part of a parsing\n\t   context */\n\tif ((ctxt->finishDtd == XML_CTXT_FINISH_DTD_0) ||\n\t    (ctxt->finishDtd == XML_CTXT_FINISH_DTD_1)) {\n\t    long delta = (char *) ctxt - (char *) ctxt->userData;\n\t    if ((delta > 0) && (delta < 250))\n\t\tpctxt = ctxt->userData;\n\t}\n    }\n    __xmlRaiseError(schannel, channel, data, pctxt, node, XML_FROM_VALID, error,\n                    XML_ERR_ERROR, NULL, 0,\n                    (const char *) str1,\n                    (const char *) str3,\n                    NULL, int2, 0, msg, str1, int2, str3);\n}\n\n/**\n * xmlErrValidWarning:\n * @ctxt:  an XML validation parser context\n * @node:  the node raising the error\n * @error:  the error number\n * @str1:  extra information\n * @str2:  extra information\n * @str3:  extra information\n *\n * Handle a validation error, provide contextual information\n */\nstatic void LIBXML_ATTR_FORMAT(4,0)\nxmlErrValidWarning(xmlValidCtxtPtr ctxt,\n                xmlNodePtr node, xmlParserErrors error,\n                const char *msg, const xmlChar * str1,\n                const xmlChar * str2, const xmlChar * str3)\n{\n    xmlStructuredErrorFunc schannel = NULL;\n    xmlGenericErrorFunc channel = NULL;\n    xmlParserCtxtPtr pctxt = NULL;\n    void *data = NULL;\n\n    if (ctxt != NULL) {\n        channel = ctxt->warning;\n        data = ctxt->userData;\n\t/* Use the special values to detect if it is part of a parsing\n\t   context */\n\tif ((ctxt->finishDtd == XML_CTXT_FINISH_DTD_0) ||\n\t    (ctxt->finishDtd == XML_CTXT_FINISH_DTD_1)) {\n\t    long delta = (char *) ctxt - (char *) ctxt->userData;\n\t    if ((delta > 0) && (delta < 250))\n\t\tpctxt = ctxt->userData;\n\t}\n    }\n    __xmlRaiseError(schannel, channel, data, pctxt, node, XML_FROM_VALID, error,\n                    XML_ERR_WARNING, NULL, 0,\n                    (const char *) str1,\n                    (const char *) str2,\n                    (const char *) str3, 0, 0, msg, str1, str2, str3);\n}\n\n\n\n#ifdef LIBXML_REGEXP_ENABLED\n/*\n * If regexp are enabled we can do continuous validation without the\n * need of a tree to validate the content model. this is done in each\n * callbacks.\n * Each xmlValidState represent the validation state associated to the\n * set of nodes currently open from the document root to the current element.\n */\n\n\ntypedef struct _xmlValidState {\n    xmlElementPtr\t elemDecl;\t/* pointer to the content model */\n    xmlNodePtr           node;\t\t/* pointer to the current node */\n    xmlRegExecCtxtPtr    exec;\t\t/* regexp runtime */\n} _xmlValidState;\n\n\nstatic int\nvstateVPush(xmlValidCtxtPtr ctxt, xmlElementPtr elemDecl, xmlNodePtr node) {\n    if ((ctxt->vstateMax == 0) || (ctxt->vstateTab == NULL)) {\n\tctxt->vstateMax = 10;\n\tctxt->vstateTab = (xmlValidState *) xmlMalloc(ctxt->vstateMax *\n\t\t              sizeof(ctxt->vstateTab[0]));\n        if (ctxt->vstateTab == NULL) {\n\t    xmlVErrMemory(ctxt, \"malloc failed\");\n\t    return(-1);\n\t}\n    }\n\n    if (ctxt->vstateNr >= ctxt->vstateMax) {\n        xmlValidState *tmp;\n\n\ttmp = (xmlValidState *) xmlRealloc(ctxt->vstateTab,\n\t             2 * ctxt->vstateMax * sizeof(ctxt->vstateTab[0]));\n        if (tmp == NULL) {\n\t    xmlVErrMemory(ctxt, \"realloc failed\");\n\t    return(-1);\n\t}\n\tctxt->vstateMax *= 2;\n\tctxt->vstateTab = tmp;\n    }\n    ctxt->vstate = &ctxt->vstateTab[ctxt->vstateNr];\n    ctxt->vstateTab[ctxt->vstateNr].elemDecl = elemDecl;\n    ctxt->vstateTab[ctxt->vstateNr].node = node;\n    if ((elemDecl != NULL) && (elemDecl->etype == XML_ELEMENT_TYPE_ELEMENT)) {\n\tif (elemDecl->contModel == NULL)\n\t    xmlValidBuildContentModel(ctxt, elemDecl);\n\tif (elemDecl->contModel != NULL) {\n\t    ctxt->vstateTab[ctxt->vstateNr].exec =\n\t\txmlRegNewExecCtxt(elemDecl->contModel, NULL, NULL);\n\t} else {\n\t    ctxt->vstateTab[ctxt->vstateNr].exec = NULL;\n\t    xmlErrValidNode(ctxt, (xmlNodePtr) elemDecl,\n\t                    XML_ERR_INTERNAL_ERROR,\n\t\t\t    \"Failed to build content model regexp for %s\\n\",\n\t\t\t    node->name, NULL, NULL);\n\t}\n    }\n    return(ctxt->vstateNr++);\n}\n\nstatic int\nvstateVPop(xmlValidCtxtPtr ctxt) {\n    xmlElementPtr elemDecl;\n\n    if (ctxt->vstateNr < 1) return(-1);\n    ctxt->vstateNr--;\n    elemDecl = ctxt->vstateTab[ctxt->vstateNr].elemDecl;\n    ctxt->vstateTab[ctxt->vstateNr].elemDecl = NULL;\n    ctxt->vstateTab[ctxt->vstateNr].node = NULL;\n    if ((elemDecl != NULL) && (elemDecl->etype == XML_ELEMENT_TYPE_ELEMENT)) {\n\txmlRegFreeExecCtxt(ctxt->vstateTab[ctxt->vstateNr].exec);\n    }\n    ctxt->vstateTab[ctxt->vstateNr].exec = NULL;\n    if (ctxt->vstateNr >= 1)\n\tctxt->vstate = &ctxt->vstateTab[ctxt->vstateNr - 1];\n    else\n\tctxt->vstate = NULL;\n    return(ctxt->vstateNr);\n}\n\n#else /* not LIBXML_REGEXP_ENABLED */\n/*\n * If regexp are not enabled, it uses a home made algorithm less\n * complex and easier to\n * debug/maintain than a generic NFA -> DFA state based algo. The\n * only restriction is on the deepness of the tree limited by the\n * size of the occurs bitfield\n *\n * this is the content of a saved state for rollbacks\n */\n\n#define ROLLBACK_OR\t0\n#define ROLLBACK_PARENT\t1\n\ntypedef struct _xmlValidState {\n    xmlElementContentPtr cont;\t/* pointer to the content model subtree */\n    xmlNodePtr           node;\t/* pointer to the current node in the list */\n    long                 occurs;/* bitfield for multiple occurrences */\n    unsigned char        depth; /* current depth in the overall tree */\n    unsigned char        state; /* ROLLBACK_XXX */\n} _xmlValidState;\n\n#define MAX_RECURSE 25000\n#define MAX_DEPTH ((sizeof(_xmlValidState.occurs)) * 8)\n#define CONT ctxt->vstate->cont\n#define NODE ctxt->vstate->node\n#define DEPTH ctxt->vstate->depth\n#define OCCURS ctxt->vstate->occurs\n#define STATE ctxt->vstate->state\n\n#define OCCURRENCE (ctxt->vstate->occurs & (1 << DEPTH))\n#define PARENT_OCCURRENCE (ctxt->vstate->occurs & ((1 << DEPTH) - 1))\n\n#define SET_OCCURRENCE ctxt->vstate->occurs |= (1 << DEPTH)\n#define RESET_OCCURRENCE ctxt->vstate->occurs &= ((1 << DEPTH) - 1)\n\nstatic int\nvstateVPush(xmlValidCtxtPtr ctxt, xmlElementContentPtr cont,\n\t    xmlNodePtr node, unsigned char depth, long occurs,\n\t    unsigned char state) {\n    int i = ctxt->vstateNr - 1;\n\n    if (ctxt->vstateNr > MAX_RECURSE) {\n\treturn(-1);\n    }\n    if (ctxt->vstateTab == NULL) {\n\tctxt->vstateMax = 8;\n\tctxt->vstateTab = (xmlValidState *) xmlMalloc(\n\t\t     ctxt->vstateMax * sizeof(ctxt->vstateTab[0]));\n\tif (ctxt->vstateTab == NULL) {\n\t    xmlVErrMemory(ctxt, \"malloc failed\");\n\t    return(-1);\n\t}\n    }\n    if (ctxt->vstateNr >= ctxt->vstateMax) {\n        xmlValidState *tmp;\n\n        tmp = (xmlValidState *) xmlRealloc(ctxt->vstateTab,\n\t             2 * ctxt->vstateMax * sizeof(ctxt->vstateTab[0]));\n        if (tmp == NULL) {\n\t    xmlVErrMemory(ctxt, \"malloc failed\");\n\t    return(-1);\n\t}\n\tctxt->vstateMax *= 2;\n\tctxt->vstateTab = tmp;\n\tctxt->vstate = &ctxt->vstateTab[0];\n    }\n    /*\n     * Don't push on the stack a state already here\n     */\n    if ((i >= 0) && (ctxt->vstateTab[i].cont == cont) &&\n\t(ctxt->vstateTab[i].node == node) &&\n\t(ctxt->vstateTab[i].depth == depth) &&\n\t(ctxt->vstateTab[i].occurs == occurs) &&\n\t(ctxt->vstateTab[i].state == state))\n\treturn(ctxt->vstateNr);\n    ctxt->vstateTab[ctxt->vstateNr].cont = cont;\n    ctxt->vstateTab[ctxt->vstateNr].node = node;\n    ctxt->vstateTab[ctxt->vstateNr].depth = depth;\n    ctxt->vstateTab[ctxt->vstateNr].occurs = occurs;\n    ctxt->vstateTab[ctxt->vstateNr].state = state;\n    return(ctxt->vstateNr++);\n}\n\nstatic int\nvstateVPop(xmlValidCtxtPtr ctxt) {\n    if (ctxt->vstateNr <= 1) return(-1);\n    ctxt->vstateNr--;\n    ctxt->vstate = &ctxt->vstateTab[0];\n    ctxt->vstate->cont =  ctxt->vstateTab[ctxt->vstateNr].cont;\n    ctxt->vstate->node = ctxt->vstateTab[ctxt->vstateNr].node;\n    ctxt->vstate->depth = ctxt->vstateTab[ctxt->vstateNr].depth;\n    ctxt->vstate->occurs = ctxt->vstateTab[ctxt->vstateNr].occurs;\n    ctxt->vstate->state = ctxt->vstateTab[ctxt->vstateNr].state;\n    return(ctxt->vstateNr);\n}\n\n#endif /* LIBXML_REGEXP_ENABLED */\n\nstatic int\nnodeVPush(xmlValidCtxtPtr ctxt, xmlNodePtr value)\n{\n    if (ctxt->nodeMax <= 0) {\n        ctxt->nodeMax = 4;\n        ctxt->nodeTab =\n            (xmlNodePtr *) xmlMalloc(ctxt->nodeMax *\n                                     sizeof(ctxt->nodeTab[0]));\n        if (ctxt->nodeTab == NULL) {\n\t    xmlVErrMemory(ctxt, \"malloc failed\");\n            ctxt->nodeMax = 0;\n            return (0);\n        }\n    }\n    if (ctxt->nodeNr >= ctxt->nodeMax) {\n        xmlNodePtr *tmp;\n        tmp = (xmlNodePtr *) xmlRealloc(ctxt->nodeTab,\n\t\t\t      ctxt->nodeMax * 2 * sizeof(ctxt->nodeTab[0]));\n        if (tmp == NULL) {\n\t    xmlVErrMemory(ctxt, \"realloc failed\");\n            return (0);\n        }\n        ctxt->nodeMax *= 2;\n\tctxt->nodeTab = tmp;\n    }\n    ctxt->nodeTab[ctxt->nodeNr] = value;\n    ctxt->node = value;\n    return (ctxt->nodeNr++);\n}\nstatic xmlNodePtr\nnodeVPop(xmlValidCtxtPtr ctxt)\n{\n    xmlNodePtr ret;\n\n    if (ctxt->nodeNr <= 0)\n        return (NULL);\n    ctxt->nodeNr--;\n    if (ctxt->nodeNr > 0)\n        ctxt->node = ctxt->nodeTab[ctxt->nodeNr - 1];\n    else\n        ctxt->node = NULL;\n    ret = ctxt->nodeTab[ctxt->nodeNr];\n    ctxt->nodeTab[ctxt->nodeNr] = NULL;\n    return (ret);\n}\n\n/**\n * xmlValidNormalizeString:\n * @str: a string\n *\n * Normalize a string in-place.\n */\nstatic void\nxmlValidNormalizeString(xmlChar *str) {\n    xmlChar *dst;\n    const xmlChar *src;\n\n    if (str == NULL)\n        return;\n    src = str;\n    dst = str;\n\n    while (*src == 0x20) src++;\n    while (*src != 0) {\n\tif (*src == 0x20) {\n\t    while (*src == 0x20) src++;\n\t    if (*src != 0)\n\t\t*dst++ = 0x20;\n\t} else {\n\t    *dst++ = *src++;\n\t}\n    }\n    *dst = 0;\n}\n\n#ifdef DEBUG_VALID_ALGO\nstatic void\nxmlValidPrintNode(xmlNodePtr cur) {\n    if (cur == NULL) {\n\txmlGenericError(xmlGenericErrorContext, \"null\");\n\treturn;\n    }\n    switch (cur->type) {\n\tcase XML_ELEMENT_NODE:\n\t    xmlGenericError(xmlGenericErrorContext, \"%s \", cur->name);\n\t    break;\n\tcase XML_TEXT_NODE:\n\t    xmlGenericError(xmlGenericErrorContext, \"text \");\n\t    break;\n\tcase XML_CDATA_SECTION_NODE:\n\t    xmlGenericError(xmlGenericErrorContext, \"cdata \");\n\t    break;\n\tcase XML_ENTITY_REF_NODE:\n\t    xmlGenericError(xmlGenericErrorContext, \"&%s; \", cur->name);\n\t    break;\n\tcase XML_PI_NODE:\n\t    xmlGenericError(xmlGenericErrorContext, \"pi(%s) \", cur->name);\n\t    break;\n\tcase XML_COMMENT_NODE:\n\t    xmlGenericError(xmlGenericErrorContext, \"comment \");\n\t    break;\n\tcase XML_ATTRIBUTE_NODE:\n\t    xmlGenericError(xmlGenericErrorContext, \"?attr? \");\n\t    break;\n\tcase XML_ENTITY_NODE:\n\t    xmlGenericError(xmlGenericErrorContext, \"?ent? \");\n\t    break;\n\tcase XML_DOCUMENT_NODE:\n\t    xmlGenericError(xmlGenericErrorContext, \"?doc? \");\n\t    break;\n\tcase XML_DOCUMENT_TYPE_NODE:\n\t    xmlGenericError(xmlGenericErrorContext, \"?doctype? \");\n\t    break;\n\tcase XML_DOCUMENT_FRAG_NODE:\n\t    xmlGenericError(xmlGenericErrorContext, \"?frag? \");\n\t    break;\n\tcase XML_NOTATION_NODE:\n\t    xmlGenericError(xmlGenericErrorContext, \"?nota? \");\n\t    break;\n\tcase XML_HTML_DOCUMENT_NODE:\n\t    xmlGenericError(xmlGenericErrorContext, \"?html? \");\n\t    break;\n#ifdef LIBXML_DOCB_ENABLED\n\tcase XML_DOCB_DOCUMENT_NODE:\n\t    xmlGenericError(xmlGenericErrorContext, \"?docb? \");\n\t    break;\n#endif\n\tcase XML_DTD_NODE:\n\t    xmlGenericError(xmlGenericErrorContext, \"?dtd? \");\n\t    break;\n\tcase XML_ELEMENT_DECL:\n\t    xmlGenericError(xmlGenericErrorContext, \"?edecl? \");\n\t    break;\n\tcase XML_ATTRIBUTE_DECL:\n\t    xmlGenericError(xmlGenericErrorContext, \"?adecl? \");\n\t    break;\n\tcase XML_ENTITY_DECL:\n\t    xmlGenericError(xmlGenericErrorContext, \"?entdecl? \");\n\t    break;\n\tcase XML_NAMESPACE_DECL:\n\t    xmlGenericError(xmlGenericErrorContext, \"?nsdecl? \");\n\t    break;\n\tcase XML_XINCLUDE_START:\n\t    xmlGenericError(xmlGenericErrorContext, \"incstart \");\n\t    break;\n\tcase XML_XINCLUDE_END:\n\t    xmlGenericError(xmlGenericErrorContext, \"incend \");\n\t    break;\n    }\n}\n\nstatic void\nxmlValidPrintNodeList(xmlNodePtr cur) {\n    if (cur == NULL)\n\txmlGenericError(xmlGenericErrorContext, \"null \");\n    while (cur != NULL) {\n\txmlValidPrintNode(cur);\n\tcur = cur->next;\n    }\n}\n\nstatic void\nxmlValidDebug(xmlNodePtr cur, xmlElementContentPtr cont) {\n    char expr[5000];\n\n    expr[0] = 0;\n    xmlGenericError(xmlGenericErrorContext, \"valid: \");\n    xmlValidPrintNodeList(cur);\n    xmlGenericError(xmlGenericErrorContext, \"against \");\n    xmlSnprintfElementContent(expr, 5000, cont, 1);\n    xmlGenericError(xmlGenericErrorContext, \"%s\\n\", expr);\n}\n\nstatic void\nxmlValidDebugState(xmlValidStatePtr state) {\n    xmlGenericError(xmlGenericErrorContext, \"(\");\n    if (state->cont == NULL)\n\txmlGenericError(xmlGenericErrorContext, \"null,\");\n    else\n\tswitch (state->cont->type) {\n            case XML_ELEMENT_CONTENT_PCDATA:\n\t\txmlGenericError(xmlGenericErrorContext, \"pcdata,\");\n\t\tbreak;\n            case XML_ELEMENT_CONTENT_ELEMENT:\n\t\txmlGenericError(xmlGenericErrorContext, \"%s,\",\n\t\t\t        state->cont->name);\n\t\tbreak;\n            case XML_ELEMENT_CONTENT_SEQ:\n\t\txmlGenericError(xmlGenericErrorContext, \"seq,\");\n\t\tbreak;\n            case XML_ELEMENT_CONTENT_OR:\n\t\txmlGenericError(xmlGenericErrorContext, \"or,\");\n\t\tbreak;\n\t}\n    xmlValidPrintNode(state->node);\n    xmlGenericError(xmlGenericErrorContext, \",%d,%X,%d)\",\n\t    state->depth, state->occurs, state->state);\n}\n\nstatic void\nxmlValidStateDebug(xmlValidCtxtPtr ctxt) {\n    int i, j;\n\n    xmlGenericError(xmlGenericErrorContext, \"state: \");\n    xmlValidDebugState(ctxt->vstate);\n    xmlGenericError(xmlGenericErrorContext, \" stack: %d \",\n\t    ctxt->vstateNr - 1);\n    for (i = 0, j = ctxt->vstateNr - 1;(i < 3) && (j > 0);i++,j--)\n\txmlValidDebugState(&ctxt->vstateTab[j]);\n    xmlGenericError(xmlGenericErrorContext, \"\\n\");\n}\n\n/*****\n#define DEBUG_VALID_STATE(n,c) xmlValidDebug(n,c);\n *****/\n\n#define DEBUG_VALID_STATE(n,c) xmlValidStateDebug(ctxt);\n#define DEBUG_VALID_MSG(m)\t\t\t\t\t\\\n    xmlGenericError(xmlGenericErrorContext, \"%s\\n\", m);\n\n#else\n#define DEBUG_VALID_STATE(n,c)\n#define DEBUG_VALID_MSG(m)\n#endif\n\n/* TODO: use hash table for accesses to elem and attribute definitions */\n\n\n#define CHECK_DTD\t\t\t\t\t\t\\\n   if (doc == NULL) return(0);\t\t\t\t\t\\\n   else if ((doc->intSubset == NULL) &&\t\t\t\t\\\n\t    (doc->extSubset == NULL)) return(0)\n\n#ifdef LIBXML_REGEXP_ENABLED\n\n/************************************************************************\n *\t\t\t\t\t\t\t\t\t*\n *\t\tContent model validation based on the regexps\t\t*\n *\t\t\t\t\t\t\t\t\t*\n ************************************************************************/\n\n/**\n * xmlValidBuildAContentModel:\n * @content:  the content model\n * @ctxt:  the schema parser context\n * @name:  the element name whose content is being built\n *\n * Generate the automata sequence needed for that type\n *\n * Returns 1 if successful or 0 in case of error.\n */\nstatic int\nxmlValidBuildAContentModel(xmlElementContentPtr content,\n\t\t           xmlValidCtxtPtr ctxt,\n\t\t           const xmlChar *name) {\n    if (content == NULL) {\n\txmlErrValidNode(ctxt, NULL, XML_ERR_INTERNAL_ERROR,\n\t\t\t\"Found NULL content in content model of %s\\n\",\n\t\t\tname, NULL, NULL);\n\treturn(0);\n    }\n    switch (content->type) {\n\tcase XML_ELEMENT_CONTENT_PCDATA:\n\t    xmlErrValidNode(ctxt, NULL, XML_ERR_INTERNAL_ERROR,\n\t\t\t    \"Found PCDATA in content model of %s\\n\",\n\t\t            name, NULL, NULL);\n\t    return(0);\n\t    break;\n\tcase XML_ELEMENT_CONTENT_ELEMENT: {\n\t    xmlAutomataStatePtr oldstate = ctxt->state;\n\t    xmlChar fn[50];\n\t    xmlChar *fullname;\n\n\t    fullname = xmlBuildQName(content->name, content->prefix, fn, 50);\n\t    if (fullname == NULL) {\n\t        xmlVErrMemory(ctxt, \"Building content model\");\n\t\treturn(0);\n\t    }\n\n\t    switch (content->ocur) {\n\t\tcase XML_ELEMENT_CONTENT_ONCE:\n\t\t    ctxt->state = xmlAutomataNewTransition(ctxt->am,\n\t\t\t    ctxt->state, NULL, fullname, NULL);\n\t\t    break;\n\t\tcase XML_ELEMENT_CONTENT_OPT:\n\t\t    ctxt->state = xmlAutomataNewTransition(ctxt->am,\n\t\t\t    ctxt->state, NULL, fullname, NULL);\n\t\t    xmlAutomataNewEpsilon(ctxt->am, oldstate, ctxt->state);\n\t\t    break;\n\t\tcase XML_ELEMENT_CONTENT_PLUS:\n\t\t    ctxt->state = xmlAutomataNewTransition(ctxt->am,\n\t\t\t    ctxt->state, NULL, fullname, NULL);\n\t\t    xmlAutomataNewTransition(ctxt->am, ctxt->state,\n\t\t\t                     ctxt->state, fullname, NULL);\n\t\t    break;\n\t\tcase XML_ELEMENT_CONTENT_MULT:\n\t\t    ctxt->state = xmlAutomataNewEpsilon(ctxt->am,\n\t\t\t\t\t    ctxt->state, NULL);\n\t\t    xmlAutomataNewTransition(ctxt->am,\n\t\t\t    ctxt->state, ctxt->state, fullname, NULL);\n\t\t    break;\n\t    }\n\t    if ((fullname != fn) && (fullname != content->name))\n\t\txmlFree(fullname);\n\t    break;\n\t}\n\tcase XML_ELEMENT_CONTENT_SEQ: {\n\t    xmlAutomataStatePtr oldstate, oldend;\n\t    xmlElementContentOccur ocur;\n\n\t    /*\n\t     * Simply iterate over the content\n\t     */\n\t    oldstate = ctxt->state;\n\t    ocur = content->ocur;\n\t    if (ocur != XML_ELEMENT_CONTENT_ONCE) {\n\t\tctxt->state = xmlAutomataNewEpsilon(ctxt->am, oldstate, NULL);\n\t\toldstate = ctxt->state;\n\t    }\n\t    do {\n\t\txmlValidBuildAContentModel(content->c1, ctxt, name);\n\t\tcontent = content->c2;\n\t    } while ((content->type == XML_ELEMENT_CONTENT_SEQ) &&\n\t\t     (content->ocur == XML_ELEMENT_CONTENT_ONCE));\n\t    xmlValidBuildAContentModel(content, ctxt, name);\n\t    oldend = ctxt->state;\n\t    ctxt->state = xmlAutomataNewEpsilon(ctxt->am, oldend, NULL);\n\t    switch (ocur) {\n\t\tcase XML_ELEMENT_CONTENT_ONCE:\n\t\t    break;\n\t\tcase XML_ELEMENT_CONTENT_OPT:\n\t\t    xmlAutomataNewEpsilon(ctxt->am, oldstate, ctxt->state);\n\t\t    break;\n\t\tcase XML_ELEMENT_CONTENT_MULT:\n\t\t    xmlAutomataNewEpsilon(ctxt->am, oldstate, ctxt->state);\n\t\t    xmlAutomataNewEpsilon(ctxt->am, oldend, oldstate);\n\t\t    break;\n\t\tcase XML_ELEMENT_CONTENT_PLUS:\n\t\t    xmlAutomataNewEpsilon(ctxt->am, oldend, oldstate);\n\t\t    break;\n\t    }\n\t    break;\n\t}\n\tcase XML_ELEMENT_CONTENT_OR: {\n\t    xmlAutomataStatePtr oldstate, oldend;\n\t    xmlElementContentOccur ocur;\n\n\t    ocur = content->ocur;\n\t    if ((ocur == XML_ELEMENT_CONTENT_PLUS) ||\n\t\t(ocur == XML_ELEMENT_CONTENT_MULT)) {\n\t\tctxt->state = xmlAutomataNewEpsilon(ctxt->am,\n\t\t\tctxt->state, NULL);\n\t    }\n\t    oldstate = ctxt->state;\n\t    oldend = xmlAutomataNewState(ctxt->am);\n\n\t    /*\n\t     * iterate over the subtypes and remerge the end with an\n\t     * epsilon transition\n\t     */\n\t    do {\n\t\tctxt->state = oldstate;\n\t\txmlValidBuildAContentModel(content->c1, ctxt, name);\n\t\txmlAutomataNewEpsilon(ctxt->am, ctxt->state, oldend);\n\t\tcontent = content->c2;\n\t    } while ((content->type == XML_ELEMENT_CONTENT_OR) &&\n\t\t     (content->ocur == XML_ELEMENT_CONTENT_ONCE));\n\t    ctxt->state = oldstate;\n\t    xmlValidBuildAContentModel(content, ctxt, name);\n\t    xmlAutomataNewEpsilon(ctxt->am, ctxt->state, oldend);\n\t    ctxt->state = xmlAutomataNewEpsilon(ctxt->am, oldend, NULL);\n\t    switch (ocur) {\n\t\tcase XML_ELEMENT_CONTENT_ONCE:\n\t\t    break;\n\t\tcase XML_ELEMENT_CONTENT_OPT:\n\t\t    xmlAutomataNewEpsilon(ctxt->am, oldstate, ctxt->state);\n\t\t    break;\n\t\tcase XML_ELEMENT_CONTENT_MULT:\n\t\t    xmlAutomataNewEpsilon(ctxt->am, oldstate, ctxt->state);\n\t\t    xmlAutomataNewEpsilon(ctxt->am, oldend, oldstate);\n\t\t    break;\n\t\tcase XML_ELEMENT_CONTENT_PLUS:\n\t\t    xmlAutomataNewEpsilon(ctxt->am, oldend, oldstate);\n\t\t    break;\n\t    }\n\t    break;\n\t}\n\tdefault:\n\t    xmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,\n\t                \"ContentModel broken for element %s\\n\",\n\t\t\t(const char *) name);\n\t    return(0);\n    }\n    return(1);\n}\n/**\n * xmlValidBuildContentModel:\n * @ctxt:  a validation context\n * @elem:  an element declaration node\n *\n * (Re)Build the automata associated to the content model of this\n * element\n *\n * Returns 1 in case of success, 0 in case of error\n */\nint\nxmlValidBuildContentModel(xmlValidCtxtPtr ctxt, xmlElementPtr elem) {\n\n    if ((ctxt == NULL) || (elem == NULL))\n\treturn(0);\n    if (elem->type != XML_ELEMENT_DECL)\n\treturn(0);\n    if (elem->etype != XML_ELEMENT_TYPE_ELEMENT)\n\treturn(1);\n    /* TODO: should we rebuild in this case ? */\n    if (elem->contModel != NULL) {\n\tif (!xmlRegexpIsDeterminist(elem->contModel)) {\n\t    ctxt->valid = 0;\n\t    return(0);\n\t}\n\treturn(1);\n    }\n\n    ctxt->am = xmlNewAutomata();\n    if (ctxt->am == NULL) {\n\txmlErrValidNode(ctxt, (xmlNodePtr) elem,\n\t                XML_ERR_INTERNAL_ERROR,\n\t                \"Cannot create automata for element %s\\n\",\n\t\t        elem->name, NULL, NULL);\n\treturn(0);\n    }\n    ctxt->state = xmlAutomataGetInitState(ctxt->am);\n    xmlValidBuildAContentModel(elem->content, ctxt, elem->name);\n    xmlAutomataSetFinalState(ctxt->am, ctxt->state);\n    elem->contModel = xmlAutomataCompile(ctxt->am);\n    if (xmlRegexpIsDeterminist(elem->contModel) != 1) {\n\tchar expr[5000];\n\texpr[0] = 0;\n\txmlSnprintfElementContent(expr, 5000, elem->content, 1);\n\txmlErrValidNode(ctxt, (xmlNodePtr) elem,\n\t                XML_DTD_CONTENT_NOT_DETERMINIST,\n\t       \"Content model of %s is not determinist: %s\\n\",\n\t       elem->name, BAD_CAST expr, NULL);\n#ifdef DEBUG_REGEXP_ALGO\n        xmlRegexpPrint(stderr, elem->contModel);\n#endif\n        ctxt->valid = 0;\n\tctxt->state = NULL;\n\txmlFreeAutomata(ctxt->am);\n\tctxt->am = NULL;\n\treturn(0);\n    }\n    ctxt->state = NULL;\n    xmlFreeAutomata(ctxt->am);\n    ctxt->am = NULL;\n    return(1);\n}\n\n#endif /* LIBXML_REGEXP_ENABLED */\n\n/****************************************************************\n *\t\t\t\t\t\t\t\t*\n *\tUtil functions for data allocation/deallocation\t\t*\n *\t\t\t\t\t\t\t\t*\n ****************************************************************/\n\n/**\n * xmlNewValidCtxt:\n *\n * Allocate a validation context structure.\n *\n * Returns NULL if not, otherwise the new validation context structure\n */\nxmlValidCtxtPtr xmlNewValidCtxt(void) {\n    xmlValidCtxtPtr ret;\n\n    if ((ret = xmlMalloc(sizeof (xmlValidCtxt))) == NULL) {\n\txmlVErrMemory(NULL, \"malloc failed\");\n\treturn (NULL);\n    }\n\n    (void) memset(ret, 0, sizeof (xmlValidCtxt));\n\n    return (ret);\n}\n\n/**\n * xmlFreeValidCtxt:\n * @cur:  the validation context to free\n *\n * Free a validation context structure.\n */\nvoid\nxmlFreeValidCtxt(xmlValidCtxtPtr cur) {\n    if (cur->vstateTab != NULL)\n        xmlFree(cur->vstateTab);\n    if (cur->nodeTab != NULL)\n        xmlFree(cur->nodeTab);\n    xmlFree(cur);\n}\n\n#endif /* LIBXML_VALID_ENABLED */\n\n/**\n * xmlNewDocElementContent:\n * @doc:  the document\n * @name:  the subelement name or NULL\n * @type:  the type of element content decl\n *\n * Allocate an element content structure for the document.\n *\n * Returns NULL if not, otherwise the new element content structure\n */\nxmlElementContentPtr\nxmlNewDocElementContent(xmlDocPtr doc, const xmlChar *name,\n                        xmlElementContentType type) {\n    xmlElementContentPtr ret;\n    xmlDictPtr dict = NULL;\n\n    if (doc != NULL)\n        dict = doc->dict;\n\n    switch(type) {\n\tcase XML_ELEMENT_CONTENT_ELEMENT:\n\t    if (name == NULL) {\n\t        xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\n\t\t\t\"xmlNewElementContent : name == NULL !\\n\",\n\t\t\tNULL);\n\t    }\n\t    break;\n        case XML_ELEMENT_CONTENT_PCDATA:\n\tcase XML_ELEMENT_CONTENT_SEQ:\n\tcase XML_ELEMENT_CONTENT_OR:\n\t    if (name != NULL) {\n\t        xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\n\t\t\t\"xmlNewElementContent : name != NULL !\\n\",\n\t\t\tNULL);\n\t    }\n\t    break;\n\tdefault:\n\t    xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\n\t\t    \"Internal: ELEMENT content corrupted invalid type\\n\",\n\t\t    NULL);\n\t    return(NULL);\n    }\n    ret = (xmlElementContentPtr) xmlMalloc(sizeof(xmlElementContent));\n    if (ret == NULL) {\n\txmlVErrMemory(NULL, \"malloc failed\");\n\treturn(NULL);\n    }\n    memset(ret, 0, sizeof(xmlElementContent));\n    ret->type = type;\n    ret->ocur = XML_ELEMENT_CONTENT_ONCE;\n    if (name != NULL) {\n        int l;\n\tconst xmlChar *tmp;\n\n\ttmp = xmlSplitQName3(name, &l);\n\tif (tmp == NULL) {\n\t    if (dict == NULL)\n\t\tret->name = xmlStrdup(name);\n\t    else\n\t        ret->name = xmlDictLookup(dict, name, -1);\n\t} else {\n\t    if (dict == NULL) {\n\t\tret->prefix = xmlStrndup(name, l);\n\t\tret->name = xmlStrdup(tmp);\n\t    } else {\n\t        ret->prefix = xmlDictLookup(dict, name, l);\n\t\tret->name = xmlDictLookup(dict, tmp, -1);\n\t    }\n\t}\n    }\n    return(ret);\n}\n\n/**\n * xmlNewElementContent:\n * @name:  the subelement name or NULL\n * @type:  the type of element content decl\n *\n * Allocate an element content structure.\n * Deprecated in favor of xmlNewDocElementContent\n *\n * Returns NULL if not, otherwise the new element content structure\n */\nxmlElementContentPtr\nxmlNewElementContent(const xmlChar *name, xmlElementContentType type) {\n    return(xmlNewDocElementContent(NULL, name, type));\n}\n\n/**\n * xmlCopyDocElementContent:\n * @doc:  the document owning the element declaration\n * @cur:  An element content pointer.\n *\n * Build a copy of an element content description.\n *\n * Returns the new xmlElementContentPtr or NULL in case of error.\n */\nxmlElementContentPtr\nxmlCopyDocElementContent(xmlDocPtr doc, xmlElementContentPtr cur) {\n    xmlElementContentPtr ret = NULL, prev = NULL, tmp;\n    xmlDictPtr dict = NULL;\n\n    if (cur == NULL) return(NULL);\n\n    if (doc != NULL)\n        dict = doc->dict;\n\n    ret = (xmlElementContentPtr) xmlMalloc(sizeof(xmlElementContent));\n    if (ret == NULL) {\n\txmlVErrMemory(NULL, \"malloc failed\");\n\treturn(NULL);\n    }\n    memset(ret, 0, sizeof(xmlElementContent));\n    ret->type = cur->type;\n    ret->ocur = cur->ocur;\n    if (cur->name != NULL) {\n\tif (dict)\n\t    ret->name = xmlDictLookup(dict, cur->name, -1);\n\telse\n\t    ret->name = xmlStrdup(cur->name);\n    }\n\n    if (cur->prefix != NULL) {\n\tif (dict)\n\t    ret->prefix = xmlDictLookup(dict, cur->prefix, -1);\n\telse\n\t    ret->prefix = xmlStrdup(cur->prefix);\n    }\n    if (cur->c1 != NULL)\n        ret->c1 = xmlCopyDocElementContent(doc, cur->c1);\n    if (ret->c1 != NULL)\n\tret->c1->parent = ret;\n    if (cur->c2 != NULL) {\n        prev = ret;\n\tcur = cur->c2;\n\twhile (cur != NULL) {\n\t    tmp = (xmlElementContentPtr) xmlMalloc(sizeof(xmlElementContent));\n\t    if (tmp == NULL) {\n\t\txmlVErrMemory(NULL, \"malloc failed\");\n\t\treturn(ret);\n\t    }\n\t    memset(tmp, 0, sizeof(xmlElementContent));\n\t    tmp->type = cur->type;\n\t    tmp->ocur = cur->ocur;\n\t    prev->c2 = tmp;\n\t    if (cur->name != NULL) {\n\t\tif (dict)\n\t\t    tmp->name = xmlDictLookup(dict, cur->name, -1);\n\t\telse\n\t\t    tmp->name = xmlStrdup(cur->name);\n\t    }\n\n\t    if (cur->prefix != NULL) {\n\t\tif (dict)\n\t\t    tmp->prefix = xmlDictLookup(dict, cur->prefix, -1);\n\t\telse\n\t\t    tmp->prefix = xmlStrdup(cur->prefix);\n\t    }\n\t    if (cur->c1 != NULL)\n\t        tmp->c1 = xmlCopyDocElementContent(doc,cur->c1);\n\t    if (tmp->c1 != NULL)\n\t\ttmp->c1->parent = ret;\n\t    prev = tmp;\n\t    cur = cur->c2;\n\t}\n    }\n    return(ret);\n}\n\n/**\n * xmlCopyElementContent:\n * @cur:  An element content pointer.\n *\n * Build a copy of an element content description.\n * Deprecated, use xmlCopyDocElementContent instead\n *\n * Returns the new xmlElementContentPtr or NULL in case of error.\n */\nxmlElementContentPtr\nxmlCopyElementContent(xmlElementContentPtr cur) {\n    return(xmlCopyDocElementContent(NULL, cur));\n}\n\n/**\n * xmlFreeDocElementContent:\n * @doc: the document owning the element declaration\n * @cur:  the element content tree to free\n *\n * Free an element content structure. The whole subtree is removed.\n */\nvoid\nxmlFreeDocElementContent(xmlDocPtr doc, xmlElementContentPtr cur) {\n    xmlDictPtr dict = NULL;\n    size_t depth = 0;\n\n    if (cur == NULL)\n        return;\n    if (doc != NULL)\n        dict = doc->dict;\n\n    while (1) {\n        xmlElementContentPtr parent;\n\n        while ((cur->c1 != NULL) || (cur->c2 != NULL)) {\n            cur = (cur->c1 != NULL) ? cur->c1 : cur->c2;\n            depth += 1;\n        }\n\n\tswitch (cur->type) {\n\t    case XML_ELEMENT_CONTENT_PCDATA:\n\t    case XML_ELEMENT_CONTENT_ELEMENT:\n\t    case XML_ELEMENT_CONTENT_SEQ:\n\t    case XML_ELEMENT_CONTENT_OR:\n\t\tbreak;\n\t    default:\n\t\txmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\n\t\t\t\"Internal: ELEMENT content corrupted invalid type\\n\",\n\t\t\tNULL);\n\t\treturn;\n\t}\n\tif (dict) {\n\t    if ((cur->name != NULL) && (!xmlDictOwns(dict, cur->name)))\n\t        xmlFree((xmlChar *) cur->name);\n\t    if ((cur->prefix != NULL) && (!xmlDictOwns(dict, cur->prefix)))\n\t        xmlFree((xmlChar *) cur->prefix);\n\t} else {\n\t    if (cur->name != NULL) xmlFree((xmlChar *) cur->name);\n\t    if (cur->prefix != NULL) xmlFree((xmlChar *) cur->prefix);\n\t}\n        parent = cur->parent;\n        if ((depth == 0) || (parent == NULL)) {\n            xmlFree(cur);\n            break;\n        }\n        if (cur == parent->c1)\n            parent->c1 = NULL;\n        else\n            parent->c2 = NULL;\n\txmlFree(cur);\n\n        if (parent->c2 != NULL) {\n\t    cur = parent->c2;\n        } else {\n            depth -= 1;\n            cur = parent;\n        }\n    }\n}\n\n/**\n * xmlFreeElementContent:\n * @cur:  the element content tree to free\n *\n * Free an element content structure. The whole subtree is removed.\n * Deprecated, use xmlFreeDocElementContent instead\n */\nvoid\nxmlFreeElementContent(xmlElementContentPtr cur) {\n    xmlFreeDocElementContent(NULL, cur);\n}\n\n#ifdef LIBXML_OUTPUT_ENABLED\n/**\n * xmlDumpElementOccur:\n * @buf:  An XML buffer\n * @cur:  An element table\n *\n * Dump the occurrence operator of an element.\n */\nstatic void\nxmlDumpElementOccur(xmlBufferPtr buf, xmlElementContentPtr cur) {\n    switch (cur->ocur) {\n        case XML_ELEMENT_CONTENT_ONCE:\n            break;\n        case XML_ELEMENT_CONTENT_OPT:\n            xmlBufferWriteChar(buf, \"?\");\n            break;\n        case XML_ELEMENT_CONTENT_MULT:\n            xmlBufferWriteChar(buf, \"*\");\n            break;\n        case XML_ELEMENT_CONTENT_PLUS:\n            xmlBufferWriteChar(buf, \"+\");\n            break;\n    }\n}\n\n/**\n * xmlDumpElementContent:\n * @buf:  An XML buffer\n * @content:  An element table\n *\n * This will dump the content of the element table as an XML DTD definition\n */\nstatic void\nxmlDumpElementContent(xmlBufferPtr buf, xmlElementContentPtr content) {\n    xmlElementContentPtr cur;\n\n    if (content == NULL) return;\n\n    xmlBufferWriteChar(buf, \"(\");\n    cur = content;\n\n    do {\n        if (cur == NULL) return;\n\n        switch (cur->type) {\n            case XML_ELEMENT_CONTENT_PCDATA:\n                xmlBufferWriteChar(buf, \"#PCDATA\");\n                break;\n            case XML_ELEMENT_CONTENT_ELEMENT:\n                if (cur->prefix != NULL) {\n                    xmlBufferWriteCHAR(buf, cur->prefix);\n                    xmlBufferWriteChar(buf, \":\");\n                }\n                xmlBufferWriteCHAR(buf, cur->name);\n                break;\n            case XML_ELEMENT_CONTENT_SEQ:\n            case XML_ELEMENT_CONTENT_OR:\n                if ((cur != content) &&\n                    (cur->parent != NULL) &&\n                    ((cur->type != cur->parent->type) ||\n                     (cur->ocur != XML_ELEMENT_CONTENT_ONCE)))\n                    xmlBufferWriteChar(buf, \"(\");\n                cur = cur->c1;\n                continue;\n            default:\n                xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\n                        \"Internal: ELEMENT cur corrupted invalid type\\n\",\n                        NULL);\n        }\n\n        while (cur != content) {\n            xmlElementContentPtr parent = cur->parent;\n\n            if (parent == NULL) return;\n\n            if (((cur->type == XML_ELEMENT_CONTENT_OR) ||\n                 (cur->type == XML_ELEMENT_CONTENT_SEQ)) &&\n                ((cur->type != parent->type) ||\n                 (cur->ocur != XML_ELEMENT_CONTENT_ONCE)))\n                xmlBufferWriteChar(buf, \")\");\n            xmlDumpElementOccur(buf, cur);\n\n            if (cur == parent->c1) {\n                if (parent->type == XML_ELEMENT_CONTENT_SEQ)\n                    xmlBufferWriteChar(buf, \" , \");\n                else if (parent->type == XML_ELEMENT_CONTENT_OR)\n                    xmlBufferWriteChar(buf, \" | \");\n\n                cur = parent->c2;\n                break;\n            }\n\n            cur = parent;\n        }\n    } while (cur != content);\n\n    xmlBufferWriteChar(buf, \")\");\n    xmlDumpElementOccur(buf, content);\n}\n\n/**\n * xmlSprintfElementContent:\n * @buf:  an output buffer\n * @content:  An element table\n * @englob: 1 if one must print the englobing parenthesis, 0 otherwise\n *\n * Deprecated, unsafe, use xmlSnprintfElementContent\n */\nvoid\nxmlSprintfElementContent(char *buf ATTRIBUTE_UNUSED,\n\t                 xmlElementContentPtr content ATTRIBUTE_UNUSED,\n\t\t\t int englob ATTRIBUTE_UNUSED) {\n}\n#endif /* LIBXML_OUTPUT_ENABLED */\n\n/**\n * xmlSnprintfElementContent:\n * @buf:  an output buffer\n * @size:  the buffer size\n * @content:  An element table\n * @englob: 1 if one must print the englobing parenthesis, 0 otherwise\n *\n * This will dump the content of the element content definition\n * Intended just for the debug routine\n */\nvoid\nxmlSnprintfElementContent(char *buf, int size, xmlElementContentPtr content, int englob) {\n    int len;\n\n    if (content == NULL) return;\n    len = strlen(buf);\n    if (size - len < 50) {\n\tif ((size - len > 4) && (buf[len - 1] != '.'))\n\t    strcat(buf, \" ...\");\n\treturn;\n    }\n    if (englob) strcat(buf, \"(\");\n    switch (content->type) {\n        case XML_ELEMENT_CONTENT_PCDATA:\n            strcat(buf, \"#PCDATA\");\n\t    break;\n\tcase XML_ELEMENT_CONTENT_ELEMENT: {\n            int qnameLen = xmlStrlen(content->name);\n\n\t    if (content->prefix != NULL)\n                qnameLen += xmlStrlen(content->prefix) + 1;\n\t    if (size - len < qnameLen + 10) {\n\t\tstrcat(buf, \" ...\");\n\t\treturn;\n\t    }\n\t    if (content->prefix != NULL) {\n\t\tstrcat(buf, (char *) content->prefix);\n\t\tstrcat(buf, \":\");\n\t    }\n\t    if (content->name != NULL)\n\t\tstrcat(buf, (char *) content->name);\n\t    break;\n        }\n\tcase XML_ELEMENT_CONTENT_SEQ:\n\t    if ((content->c1->type == XML_ELEMENT_CONTENT_OR) ||\n\t        (content->c1->type == XML_ELEMENT_CONTENT_SEQ))\n\t\txmlSnprintfElementContent(buf, size, content->c1, 1);\n\t    else\n\t\txmlSnprintfElementContent(buf, size, content->c1, 0);\n\t    len = strlen(buf);\n\t    if (size - len < 50) {\n\t\tif ((size - len > 4) && (buf[len - 1] != '.'))\n\t\t    strcat(buf, \" ...\");\n\t\treturn;\n\t    }\n            strcat(buf, \" , \");\n\t    if (((content->c2->type == XML_ELEMENT_CONTENT_OR) ||\n\t\t (content->c2->ocur != XML_ELEMENT_CONTENT_ONCE)) &&\n\t\t(content->c2->type != XML_ELEMENT_CONTENT_ELEMENT))\n\t\txmlSnprintfElementContent(buf, size, content->c2, 1);\n\t    else\n\t\txmlSnprintfElementContent(buf, size, content->c2, 0);\n\t    break;\n\tcase XML_ELEMENT_CONTENT_OR:\n\t    if ((content->c1->type == XML_ELEMENT_CONTENT_OR) ||\n\t        (content->c1->type == XML_ELEMENT_CONTENT_SEQ))\n\t\txmlSnprintfElementContent(buf, size, content->c1, 1);\n\t    else\n\t\txmlSnprintfElementContent(buf, size, content->c1, 0);\n\t    len = strlen(buf);\n\t    if (size - len < 50) {\n\t\tif ((size - len > 4) && (buf[len - 1] != '.'))\n\t\t    strcat(buf, \" ...\");\n\t\treturn;\n\t    }\n            strcat(buf, \" | \");\n\t    if (((content->c2->type == XML_ELEMENT_CONTENT_SEQ) ||\n\t\t (content->c2->ocur != XML_ELEMENT_CONTENT_ONCE)) &&\n\t\t(content->c2->type != XML_ELEMENT_CONTENT_ELEMENT))\n\t\txmlSnprintfElementContent(buf, size, content->c2, 1);\n\t    else\n\t\txmlSnprintfElementContent(buf, size, content->c2, 0);\n\t    break;\n    }\n    if (size - strlen(buf) <= 2) return;\n    if (englob)\n        strcat(buf, \")\");\n    switch (content->ocur) {\n        case XML_ELEMENT_CONTENT_ONCE:\n\t    break;\n        case XML_ELEMENT_CONTENT_OPT:\n\t    strcat(buf, \"?\");\n\t    break;\n        case XML_ELEMENT_CONTENT_MULT:\n\t    strcat(buf, \"*\");\n\t    break;\n        case XML_ELEMENT_CONTENT_PLUS:\n\t    strcat(buf, \"+\");\n\t    break;\n    }\n}\n\n/****************************************************************\n *\t\t\t\t\t\t\t\t*\n *\tRegistration of DTD declarations\t\t\t*\n *\t\t\t\t\t\t\t\t*\n ****************************************************************/\n\n/**\n * xmlFreeElement:\n * @elem:  An element\n *\n * Deallocate the memory used by an element definition\n */\nstatic void\nxmlFreeElement(xmlElementPtr elem) {\n    if (elem == NULL) return;\n    xmlUnlinkNode((xmlNodePtr) elem);\n    xmlFreeDocElementContent(elem->doc, elem->content);\n    if (elem->name != NULL)\n\txmlFree((xmlChar *) elem->name);\n    if (elem->prefix != NULL)\n\txmlFree((xmlChar *) elem->prefix);\n#ifdef LIBXML_REGEXP_ENABLED\n    if (elem->contModel != NULL)\n\txmlRegFreeRegexp(elem->contModel);\n#endif\n    xmlFree(elem);\n}\n\n\n/**\n * xmlAddElementDecl:\n * @ctxt:  the validation context\n * @dtd:  pointer to the DTD\n * @name:  the entity name\n * @type:  the element type\n * @content:  the element content tree or NULL\n *\n * Register a new element declaration\n *\n * Returns NULL if not, otherwise the entity\n */\nxmlElementPtr\nxmlAddElementDecl(xmlValidCtxtPtr ctxt,\n                  xmlDtdPtr dtd, const xmlChar *name,\n                  xmlElementTypeVal type,\n\t\t  xmlElementContentPtr content) {\n    xmlElementPtr ret;\n    xmlElementTablePtr table;\n    xmlAttributePtr oldAttributes = NULL;\n    xmlChar *ns, *uqname;\n\n    if (dtd == NULL) {\n\treturn(NULL);\n    }\n    if (name == NULL) {\n\treturn(NULL);\n    }\n\n    switch (type) {\n        case XML_ELEMENT_TYPE_EMPTY:\n\t    if (content != NULL) {\n\t\txmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,\n\t\t        \"xmlAddElementDecl: content != NULL for EMPTY\\n\",\n\t\t\tNULL);\n\t\treturn(NULL);\n\t    }\n\t    break;\n\tcase XML_ELEMENT_TYPE_ANY:\n\t    if (content != NULL) {\n\t\txmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,\n\t\t        \"xmlAddElementDecl: content != NULL for ANY\\n\",\n\t\t\tNULL);\n\t\treturn(NULL);\n\t    }\n\t    break;\n\tcase XML_ELEMENT_TYPE_MIXED:\n\t    if (content == NULL) {\n\t\txmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,\n\t\t        \"xmlAddElementDecl: content == NULL for MIXED\\n\",\n\t\t\tNULL);\n\t\treturn(NULL);\n\t    }\n\t    break;\n\tcase XML_ELEMENT_TYPE_ELEMENT:\n\t    if (content == NULL) {\n\t\txmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,\n\t\t        \"xmlAddElementDecl: content == NULL for ELEMENT\\n\",\n\t\t\tNULL);\n\t\treturn(NULL);\n\t    }\n\t    break;\n\tdefault:\n\t    xmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,\n\t\t    \"Internal: ELEMENT decl corrupted invalid type\\n\",\n\t\t    NULL);\n\t    return(NULL);\n    }\n\n    /*\n     * check if name is a QName\n     */\n    uqname = xmlSplitQName2(name, &ns);\n    if (uqname != NULL)\n\tname = uqname;\n\n    /*\n     * Create the Element table if needed.\n     */\n    table = (xmlElementTablePtr) dtd->elements;\n    if (table == NULL) {\n\txmlDictPtr dict = NULL;\n\n\tif (dtd->doc != NULL)\n\t    dict = dtd->doc->dict;\n        table = xmlHashCreateDict(0, dict);\n\tdtd->elements = (void *) table;\n    }\n    if (table == NULL) {\n\txmlVErrMemory(ctxt,\n            \"xmlAddElementDecl: Table creation failed!\\n\");\n\tif (uqname != NULL)\n\t    xmlFree(uqname);\n\tif (ns != NULL)\n\t    xmlFree(ns);\n        return(NULL);\n    }\n\n    /*\n     * lookup old attributes inserted on an undefined element in the\n     * internal subset.\n     */\n    if ((dtd->doc != NULL) && (dtd->doc->intSubset != NULL)) {\n\tret = xmlHashLookup2(dtd->doc->intSubset->elements, name, ns);\n\tif ((ret != NULL) && (ret->etype == XML_ELEMENT_TYPE_UNDEFINED)) {\n\t    oldAttributes = ret->attributes;\n\t    ret->attributes = NULL;\n\t    xmlHashRemoveEntry2(dtd->doc->intSubset->elements, name, ns, NULL);\n\t    xmlFreeElement(ret);\n\t}\n    }\n\n    /*\n     * The element may already be present if one of its attribute\n     * was registered first\n     */\n    ret = xmlHashLookup2(table, name, ns);\n    if (ret != NULL) {\n\tif (ret->etype != XML_ELEMENT_TYPE_UNDEFINED) {\n#ifdef LIBXML_VALID_ENABLED\n\t    /*\n\t     * The element is already defined in this DTD.\n\t     */\n\t    xmlErrValidNode(ctxt, (xmlNodePtr) dtd, XML_DTD_ELEM_REDEFINED,\n\t                    \"Redefinition of element %s\\n\",\n\t\t\t    name, NULL, NULL);\n#endif /* LIBXML_VALID_ENABLED */\n\t    if (uqname != NULL)\n\t\txmlFree(uqname);\n            if (ns != NULL)\n\t        xmlFree(ns);\n\t    return(NULL);\n\t}\n\tif (ns != NULL) {\n\t    xmlFree(ns);\n\t    ns = NULL;\n\t}\n    } else {\n\tret = (xmlElementPtr) xmlMalloc(sizeof(xmlElement));\n\tif (ret == NULL) {\n\t    xmlVErrMemory(ctxt, \"malloc failed\");\n\t    if (uqname != NULL)\n\t\txmlFree(uqname);\n            if (ns != NULL)\n\t        xmlFree(ns);\n\t    return(NULL);\n\t}\n\tmemset(ret, 0, sizeof(xmlElement));\n\tret->type = XML_ELEMENT_DECL;\n\n\t/*\n\t * fill the structure.\n\t */\n\tret->name = xmlStrdup(name);\n\tif (ret->name == NULL) {\n\t    xmlVErrMemory(ctxt, \"malloc failed\");\n\t    if (uqname != NULL)\n\t\txmlFree(uqname);\n            if (ns != NULL)\n\t        xmlFree(ns);\n\t    xmlFree(ret);\n\t    return(NULL);\n\t}\n\tret->prefix = ns;\n\n\t/*\n\t * Validity Check:\n\t * Insertion must not fail\n\t */\n\tif (xmlHashAddEntry2(table, name, ns, ret)) {\n#ifdef LIBXML_VALID_ENABLED\n\t    /*\n\t     * The element is already defined in this DTD.\n\t     */\n\t    xmlErrValidNode(ctxt, (xmlNodePtr) dtd, XML_DTD_ELEM_REDEFINED,\n\t                    \"Redefinition of element %s\\n\",\n\t\t\t    name, NULL, NULL);\n#endif /* LIBXML_VALID_ENABLED */\n\t    xmlFreeElement(ret);\n\t    if (uqname != NULL)\n\t\txmlFree(uqname);\n\t    return(NULL);\n\t}\n\t/*\n\t * For new element, may have attributes from earlier\n\t * definition in internal subset\n\t */\n\tret->attributes = oldAttributes;\n    }\n\n    /*\n     * Finish to fill the structure.\n     */\n    ret->etype = type;\n    /*\n     * Avoid a stupid copy when called by the parser\n     * and flag it by setting a special parent value\n     * so the parser doesn't unallocate it.\n     */\n    if ((ctxt != NULL) &&\n        ((ctxt->finishDtd == XML_CTXT_FINISH_DTD_0) ||\n         (ctxt->finishDtd == XML_CTXT_FINISH_DTD_1))) {\n\tret->content = content;\n\tif (content != NULL)\n\t    content->parent = (xmlElementContentPtr) 1;\n    } else {\n\tret->content = xmlCopyDocElementContent(dtd->doc, content);\n    }\n\n    /*\n     * Link it to the DTD\n     */\n    ret->parent = dtd;\n    ret->doc = dtd->doc;\n    if (dtd->last == NULL) {\n\tdtd->children = dtd->last = (xmlNodePtr) ret;\n    } else {\n        dtd->last->next = (xmlNodePtr) ret;\n\tret->prev = dtd->last;\n\tdtd->last = (xmlNodePtr) ret;\n    }\n    if (uqname != NULL)\n\txmlFree(uqname);\n    return(ret);\n}\n\nstatic void\nxmlFreeElementTableEntry(void *elem, const xmlChar *name ATTRIBUTE_UNUSED) {\n    xmlFreeElement((xmlElementPtr) elem);\n}\n\n/**\n * xmlFreeElementTable:\n * @table:  An element table\n *\n * Deallocate the memory used by an element hash table.\n */\nvoid\nxmlFreeElementTable(xmlElementTablePtr table) {\n    xmlHashFree(table, xmlFreeElementTableEntry);\n}\n\n#ifdef LIBXML_TREE_ENABLED\n/**\n * xmlCopyElement:\n * @elem:  An element\n *\n * Build a copy of an element.\n *\n * Returns the new xmlElementPtr or NULL in case of error.\n */\nstatic void *\nxmlCopyElement(void *payload, const xmlChar *name ATTRIBUTE_UNUSED) {\n    xmlElementPtr elem = (xmlElementPtr) payload;\n    xmlElementPtr cur;\n\n    cur = (xmlElementPtr) xmlMalloc(sizeof(xmlElement));\n    if (cur == NULL) {\n\txmlVErrMemory(NULL, \"malloc failed\");\n\treturn(NULL);\n    }\n    memset(cur, 0, sizeof(xmlElement));\n    cur->type = XML_ELEMENT_DECL;\n    cur->etype = elem->etype;\n    if (elem->name != NULL)\n\tcur->name = xmlStrdup(elem->name);\n    else\n\tcur->name = NULL;\n    if (elem->prefix != NULL)\n\tcur->prefix = xmlStrdup(elem->prefix);\n    else\n\tcur->prefix = NULL;\n    cur->content = xmlCopyElementContent(elem->content);\n    /* TODO : rebuild the attribute list on the copy */\n    cur->attributes = NULL;\n    return(cur);\n}\n\n/**\n * xmlCopyElementTable:\n * @table:  An element table\n *\n * Build a copy of an element table.\n *\n * Returns the new xmlElementTablePtr or NULL in case of error.\n */\nxmlElementTablePtr\nxmlCopyElementTable(xmlElementTablePtr table) {\n    return((xmlElementTablePtr) xmlHashCopy(table, xmlCopyElement));\n}\n#endif /* LIBXML_TREE_ENABLED */\n\n#ifdef LIBXML_OUTPUT_ENABLED\n/**\n * xmlDumpElementDecl:\n * @buf:  the XML buffer output\n * @elem:  An element table\n *\n * This will dump the content of the element declaration as an XML\n * DTD definition\n */\nvoid\nxmlDumpElementDecl(xmlBufferPtr buf, xmlElementPtr elem) {\n    if ((buf == NULL) || (elem == NULL))\n        return;\n    switch (elem->etype) {\n\tcase XML_ELEMENT_TYPE_EMPTY:\n\t    xmlBufferWriteChar(buf, \"<!ELEMENT \");\n\t    if (elem->prefix != NULL) {\n\t\txmlBufferWriteCHAR(buf, elem->prefix);\n\t\txmlBufferWriteChar(buf, \":\");\n\t    }\n\t    xmlBufferWriteCHAR(buf, elem->name);\n\t    xmlBufferWriteChar(buf, \" EMPTY>\\n\");\n\t    break;\n\tcase XML_ELEMENT_TYPE_ANY:\n\t    xmlBufferWriteChar(buf, \"<!ELEMENT \");\n\t    if (elem->prefix != NULL) {\n\t\txmlBufferWriteCHAR(buf, elem->prefix);\n\t\txmlBufferWriteChar(buf, \":\");\n\t    }\n\t    xmlBufferWriteCHAR(buf, elem->name);\n\t    xmlBufferWriteChar(buf, \" ANY>\\n\");\n\t    break;\n\tcase XML_ELEMENT_TYPE_MIXED:\n\t    xmlBufferWriteChar(buf, \"<!ELEMENT \");\n\t    if (elem->prefix != NULL) {\n\t\txmlBufferWriteCHAR(buf, elem->prefix);\n\t\txmlBufferWriteChar(buf, \":\");\n\t    }\n\t    xmlBufferWriteCHAR(buf, elem->name);\n\t    xmlBufferWriteChar(buf, \" \");\n\t    xmlDumpElementContent(buf, elem->content);\n\t    xmlBufferWriteChar(buf, \">\\n\");\n\t    break;\n\tcase XML_ELEMENT_TYPE_ELEMENT:\n\t    xmlBufferWriteChar(buf, \"<!ELEMENT \");\n\t    if (elem->prefix != NULL) {\n\t\txmlBufferWriteCHAR(buf, elem->prefix);\n\t\txmlBufferWriteChar(buf, \":\");\n\t    }\n\t    xmlBufferWriteCHAR(buf, elem->name);\n\t    xmlBufferWriteChar(buf, \" \");\n\t    xmlDumpElementContent(buf, elem->content);\n\t    xmlBufferWriteChar(buf, \">\\n\");\n\t    break;\n\tdefault:\n\t    xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\n\t\t    \"Internal: ELEMENT struct corrupted invalid type\\n\",\n\t\t    NULL);\n    }\n}\n\n/**\n * xmlDumpElementDeclScan:\n * @elem:  An element table\n * @buf:  the XML buffer output\n *\n * This routine is used by the hash scan function.  It just reverses\n * the arguments.\n */\nstatic void\nxmlDumpElementDeclScan(void *elem, void *buf,\n                       const xmlChar *name ATTRIBUTE_UNUSED) {\n    xmlDumpElementDecl((xmlBufferPtr) buf, (xmlElementPtr) elem);\n}\n\n/**\n * xmlDumpElementTable:\n * @buf:  the XML buffer output\n * @table:  An element table\n *\n * This will dump the content of the element table as an XML DTD definition\n */\nvoid\nxmlDumpElementTable(xmlBufferPtr buf, xmlElementTablePtr table) {\n    if ((buf == NULL) || (table == NULL))\n        return;\n    xmlHashScan(table, xmlDumpElementDeclScan, buf);\n}\n#endif /* LIBXML_OUTPUT_ENABLED */\n\n/**\n * xmlCreateEnumeration:\n * @name:  the enumeration name or NULL\n *\n * create and initialize an enumeration attribute node.\n *\n * Returns the xmlEnumerationPtr just created or NULL in case\n *                of error.\n */\nxmlEnumerationPtr\nxmlCreateEnumeration(const xmlChar *name) {\n    xmlEnumerationPtr ret;\n\n    ret = (xmlEnumerationPtr) xmlMalloc(sizeof(xmlEnumeration));\n    if (ret == NULL) {\n\txmlVErrMemory(NULL, \"malloc failed\");\n        return(NULL);\n    }\n    memset(ret, 0, sizeof(xmlEnumeration));\n\n    if (name != NULL)\n        ret->name = xmlStrdup(name);\n    return(ret);\n}\n\n/**\n * xmlFreeEnumeration:\n * @cur:  the tree to free.\n *\n * free an enumeration attribute node (recursive).\n */\nvoid\nxmlFreeEnumeration(xmlEnumerationPtr cur) {\n    if (cur == NULL) return;\n\n    if (cur->next != NULL) xmlFreeEnumeration(cur->next);\n\n    if (cur->name != NULL) xmlFree((xmlChar *) cur->name);\n    xmlFree(cur);\n}\n\n#ifdef LIBXML_TREE_ENABLED\n/**\n * xmlCopyEnumeration:\n * @cur:  the tree to copy.\n *\n * Copy an enumeration attribute node (recursive).\n *\n * Returns the xmlEnumerationPtr just created or NULL in case\n *                of error.\n */\nxmlEnumerationPtr\nxmlCopyEnumeration(xmlEnumerationPtr cur) {\n    xmlEnumerationPtr ret;\n\n    if (cur == NULL) return(NULL);\n    ret = xmlCreateEnumeration((xmlChar *) cur->name);\n    if (ret == NULL) return(NULL);\n\n    if (cur->next != NULL) ret->next = xmlCopyEnumeration(cur->next);\n    else ret->next = NULL;\n\n    return(ret);\n}\n#endif /* LIBXML_TREE_ENABLED */\n\n#ifdef LIBXML_OUTPUT_ENABLED\n/**\n * xmlDumpEnumeration:\n * @buf:  the XML buffer output\n * @enum:  An enumeration\n *\n * This will dump the content of the enumeration\n */\nstatic void\nxmlDumpEnumeration(xmlBufferPtr buf, xmlEnumerationPtr cur) {\n    if ((buf == NULL) || (cur == NULL))\n        return;\n\n    xmlBufferWriteCHAR(buf, cur->name);\n    if (cur->next == NULL)\n\txmlBufferWriteChar(buf, \")\");\n    else {\n\txmlBufferWriteChar(buf, \" | \");\n\txmlDumpEnumeration(buf, cur->next);\n    }\n}\n#endif /* LIBXML_OUTPUT_ENABLED */\n\n#ifdef LIBXML_VALID_ENABLED\n/**\n * xmlScanIDAttributeDecl:\n * @ctxt:  the validation context\n * @elem:  the element name\n * @err: whether to raise errors here\n *\n * Verify that the element don't have too many ID attributes\n * declared.\n *\n * Returns the number of ID attributes found.\n */\nstatic int\nxmlScanIDAttributeDecl(xmlValidCtxtPtr ctxt, xmlElementPtr elem, int err) {\n    xmlAttributePtr cur;\n    int ret = 0;\n\n    if (elem == NULL) return(0);\n    cur = elem->attributes;\n    while (cur != NULL) {\n        if (cur->atype == XML_ATTRIBUTE_ID) {\n\t    ret ++;\n\t    if ((ret > 1) && (err))\n\t\txmlErrValidNode(ctxt, (xmlNodePtr) elem, XML_DTD_MULTIPLE_ID,\n\t       \"Element %s has too many ID attributes defined : %s\\n\",\n\t\t       elem->name, cur->name, NULL);\n\t}\n\tcur = cur->nexth;\n    }\n    return(ret);\n}\n#endif /* LIBXML_VALID_ENABLED */\n\n/**\n * xmlFreeAttribute:\n * @elem:  An attribute\n *\n * Deallocate the memory used by an attribute definition\n */\nstatic void\nxmlFreeAttribute(xmlAttributePtr attr) {\n    xmlDictPtr dict;\n\n    if (attr == NULL) return;\n    if (attr->doc != NULL)\n\tdict = attr->doc->dict;\n    else\n\tdict = NULL;\n    xmlUnlinkNode((xmlNodePtr) attr);\n    if (attr->tree != NULL)\n        xmlFreeEnumeration(attr->tree);\n    if (dict) {\n        if ((attr->elem != NULL) && (!xmlDictOwns(dict, attr->elem)))\n\t    xmlFree((xmlChar *) attr->elem);\n        if ((attr->name != NULL) && (!xmlDictOwns(dict, attr->name)))\n\t    xmlFree((xmlChar *) attr->name);\n        if ((attr->prefix != NULL) && (!xmlDictOwns(dict, attr->prefix)))\n\t    xmlFree((xmlChar *) attr->prefix);\n        if ((attr->defaultValue != NULL) &&\n\t    (!xmlDictOwns(dict, attr->defaultValue)))\n\t    xmlFree((xmlChar *) attr->defaultValue);\n    } else {\n\tif (attr->elem != NULL)\n\t    xmlFree((xmlChar *) attr->elem);\n\tif (attr->name != NULL)\n\t    xmlFree((xmlChar *) attr->name);\n\tif (attr->defaultValue != NULL)\n\t    xmlFree((xmlChar *) attr->defaultValue);\n\tif (attr->prefix != NULL)\n\t    xmlFree((xmlChar *) attr->prefix);\n    }\n    xmlFree(attr);\n}\n\n\n/**\n * xmlAddAttributeDecl:\n * @ctxt:  the validation context\n * @dtd:  pointer to the DTD\n * @elem:  the element name\n * @name:  the attribute name\n * @ns:  the attribute namespace prefix\n * @type:  the attribute type\n * @def:  the attribute default type\n * @defaultValue:  the attribute default value\n * @tree:  if it's an enumeration, the associated list\n *\n * Register a new attribute declaration\n * Note that @tree becomes the ownership of the DTD\n *\n * Returns NULL if not new, otherwise the attribute decl\n */\nxmlAttributePtr\nxmlAddAttributeDecl(xmlValidCtxtPtr ctxt,\n                    xmlDtdPtr dtd, const xmlChar *elem,\n                    const xmlChar *name, const xmlChar *ns,\n\t\t    xmlAttributeType type, xmlAttributeDefault def,\n\t\t    const xmlChar *defaultValue, xmlEnumerationPtr tree) {\n    xmlAttributePtr ret;\n    xmlAttributeTablePtr table;\n    xmlElementPtr elemDef;\n    xmlDictPtr dict = NULL;\n\n    if (dtd == NULL) {\n\txmlFreeEnumeration(tree);\n\treturn(NULL);\n    }\n    if (name == NULL) {\n\txmlFreeEnumeration(tree);\n\treturn(NULL);\n    }\n    if (elem == NULL) {\n\txmlFreeEnumeration(tree);\n\treturn(NULL);\n    }\n    if (dtd->doc != NULL)\n\tdict = dtd->doc->dict;\n\n#ifdef LIBXML_VALID_ENABLED\n    /*\n     * Check the type and possibly the default value.\n     */\n    switch (type) {\n        case XML_ATTRIBUTE_CDATA:\n\t    break;\n        case XML_ATTRIBUTE_ID:\n\t    break;\n        case XML_ATTRIBUTE_IDREF:\n\t    break;\n        case XML_ATTRIBUTE_IDREFS:\n\t    break;\n        case XML_ATTRIBUTE_ENTITY:\n\t    break;\n        case XML_ATTRIBUTE_ENTITIES:\n\t    break;\n        case XML_ATTRIBUTE_NMTOKEN:\n\t    break;\n        case XML_ATTRIBUTE_NMTOKENS:\n\t    break;\n        case XML_ATTRIBUTE_ENUMERATION:\n\t    break;\n        case XML_ATTRIBUTE_NOTATION:\n\t    break;\n\tdefault:\n\t    xmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,\n\t\t    \"Internal: ATTRIBUTE struct corrupted invalid type\\n\",\n\t\t    NULL);\n\t    xmlFreeEnumeration(tree);\n\t    return(NULL);\n    }\n    if ((defaultValue != NULL) &&\n        (!xmlValidateAttributeValueInternal(dtd->doc, type, defaultValue))) {\n\txmlErrValidNode(ctxt, (xmlNodePtr) dtd, XML_DTD_ATTRIBUTE_DEFAULT,\n\t                \"Attribute %s of %s: invalid default value\\n\",\n\t                elem, name, defaultValue);\n\tdefaultValue = NULL;\n\tif (ctxt != NULL)\n\t    ctxt->valid = 0;\n    }\n#endif /* LIBXML_VALID_ENABLED */\n\n    /*\n     * Check first that an attribute defined in the external subset wasn't\n     * already defined in the internal subset\n     */\n    if ((dtd->doc != NULL) && (dtd->doc->extSubset == dtd) &&\n\t(dtd->doc->intSubset != NULL) &&\n\t(dtd->doc->intSubset->attributes != NULL)) {\n        ret = xmlHashLookup3(dtd->doc->intSubset->attributes, name, ns, elem);\n\tif (ret != NULL) {\n\t    xmlFreeEnumeration(tree);\n\t    return(NULL);\n\t}\n    }\n\n    /*\n     * Create the Attribute table if needed.\n     */\n    table = (xmlAttributeTablePtr) dtd->attributes;\n    if (table == NULL) {\n        table = xmlHashCreateDict(0, dict);\n\tdtd->attributes = (void *) table;\n    }\n    if (table == NULL) {\n\txmlVErrMemory(ctxt,\n            \"xmlAddAttributeDecl: Table creation failed!\\n\");\n\txmlFreeEnumeration(tree);\n        return(NULL);\n    }\n\n\n    ret = (xmlAttributePtr) xmlMalloc(sizeof(xmlAttribute));\n    if (ret == NULL) {\n\txmlVErrMemory(ctxt, \"malloc failed\");\n\txmlFreeEnumeration(tree);\n\treturn(NULL);\n    }\n    memset(ret, 0, sizeof(xmlAttribute));\n    ret->type = XML_ATTRIBUTE_DECL;\n\n    /*\n     * fill the structure.\n     */\n    ret->atype = type;\n    /*\n     * doc must be set before possible error causes call\n     * to xmlFreeAttribute (because it's used to check on\n     * dict use)\n     */\n    ret->doc = dtd->doc;\n    if (dict) {\n\tret->name = xmlDictLookup(dict, name, -1);\n\tret->prefix = xmlDictLookup(dict, ns, -1);\n\tret->elem = xmlDictLookup(dict, elem, -1);\n    } else {\n\tret->name = xmlStrdup(name);\n\tret->prefix = xmlStrdup(ns);\n\tret->elem = xmlStrdup(elem);\n    }\n    ret->def = def;\n    ret->tree = tree;\n    if (defaultValue != NULL) {\n        if (dict)\n\t    ret->defaultValue = xmlDictLookup(dict, defaultValue, -1);\n\telse\n\t    ret->defaultValue = xmlStrdup(defaultValue);\n    }\n\n    /*\n     * Validity Check:\n     * Search the DTD for previous declarations of the ATTLIST\n     */\n    if (xmlHashAddEntry3(table, ret->name, ret->prefix, ret->elem, ret) < 0) {\n#ifdef LIBXML_VALID_ENABLED\n\t/*\n\t * The attribute is already defined in this DTD.\n\t */\n\txmlErrValidWarning(ctxt, (xmlNodePtr) dtd, XML_DTD_ATTRIBUTE_REDEFINED,\n\t\t \"Attribute %s of element %s: already defined\\n\",\n\t\t name, elem, NULL);\n#endif /* LIBXML_VALID_ENABLED */\n\txmlFreeAttribute(ret);\n\treturn(NULL);\n    }\n\n    /*\n     * Validity Check:\n     * Multiple ID per element\n     */\n    elemDef = xmlGetDtdElementDesc2(dtd, elem, 1);\n    if (elemDef != NULL) {\n\n#ifdef LIBXML_VALID_ENABLED\n        if ((type == XML_ATTRIBUTE_ID) &&\n\t    (xmlScanIDAttributeDecl(NULL, elemDef, 1) != 0)) {\n\t    xmlErrValidNode(ctxt, (xmlNodePtr) dtd, XML_DTD_MULTIPLE_ID,\n\t   \"Element %s has too may ID attributes defined : %s\\n\",\n\t\t   elem, name, NULL);\n\t    if (ctxt != NULL)\n\t\tctxt->valid = 0;\n\t}\n#endif /* LIBXML_VALID_ENABLED */\n\n\t/*\n\t * Insert namespace default def first they need to be\n\t * processed first.\n\t */\n\tif ((xmlStrEqual(ret->name, BAD_CAST \"xmlns\")) ||\n\t    ((ret->prefix != NULL &&\n\t     (xmlStrEqual(ret->prefix, BAD_CAST \"xmlns\"))))) {\n\t    ret->nexth = elemDef->attributes;\n\t    elemDef->attributes = ret;\n\t} else {\n\t    xmlAttributePtr tmp = elemDef->attributes;\n\n\t    while ((tmp != NULL) &&\n\t\t   ((xmlStrEqual(tmp->name, BAD_CAST \"xmlns\")) ||\n\t\t    ((ret->prefix != NULL &&\n\t\t     (xmlStrEqual(ret->prefix, BAD_CAST \"xmlns\")))))) {\n\t\tif (tmp->nexth == NULL)\n\t\t    break;\n\t\ttmp = tmp->nexth;\n\t    }\n\t    if (tmp != NULL) {\n\t\tret->nexth = tmp->nexth;\n\t        tmp->nexth = ret;\n\t    } else {\n\t\tret->nexth = elemDef->attributes;\n\t\telemDef->attributes = ret;\n\t    }\n\t}\n    }\n\n    /*\n     * Link it to the DTD\n     */\n    ret->parent = dtd;\n    if (dtd->last == NULL) {\n\tdtd->children = dtd->last = (xmlNodePtr) ret;\n    } else {\n        dtd->last->next = (xmlNodePtr) ret;\n\tret->prev = dtd->last;\n\tdtd->last = (xmlNodePtr) ret;\n    }\n    return(ret);\n}\n\nstatic void\nxmlFreeAttributeTableEntry(void *attr, const xmlChar *name ATTRIBUTE_UNUSED) {\n    xmlFreeAttribute((xmlAttributePtr) attr);\n}\n\n/**\n * xmlFreeAttributeTable:\n * @table:  An attribute table\n *\n * Deallocate the memory used by an entities hash table.\n */\nvoid\nxmlFreeAttributeTable(xmlAttributeTablePtr table) {\n    xmlHashFree(table, xmlFreeAttributeTableEntry);\n}\n\n#ifdef LIBXML_TREE_ENABLED\n/**\n * xmlCopyAttribute:\n * @attr:  An attribute\n *\n * Build a copy of an attribute.\n *\n * Returns the new xmlAttributePtr or NULL in case of error.\n */\nstatic void *\nxmlCopyAttribute(void *payload, const xmlChar *name ATTRIBUTE_UNUSED) {\n    xmlAttributePtr attr = (xmlAttributePtr) payload;\n    xmlAttributePtr cur;\n\n    cur = (xmlAttributePtr) xmlMalloc(sizeof(xmlAttribute));\n    if (cur == NULL) {\n\txmlVErrMemory(NULL, \"malloc failed\");\n\treturn(NULL);\n    }\n    memset(cur, 0, sizeof(xmlAttribute));\n    cur->type = XML_ATTRIBUTE_DECL;\n    cur->atype = attr->atype;\n    cur->def = attr->def;\n    cur->tree = xmlCopyEnumeration(attr->tree);\n    if (attr->elem != NULL)\n\tcur->elem = xmlStrdup(attr->elem);\n    if (attr->name != NULL)\n\tcur->name = xmlStrdup(attr->name);\n    if (attr->prefix != NULL)\n\tcur->prefix = xmlStrdup(attr->prefix);\n    if (attr->defaultValue != NULL)\n\tcur->defaultValue = xmlStrdup(attr->defaultValue);\n    return(cur);\n}\n\n/**\n * xmlCopyAttributeTable:\n * @table:  An attribute table\n *\n * Build a copy of an attribute table.\n *\n * Returns the new xmlAttributeTablePtr or NULL in case of error.\n */\nxmlAttributeTablePtr\nxmlCopyAttributeTable(xmlAttributeTablePtr table) {\n    return((xmlAttributeTablePtr) xmlHashCopy(table, xmlCopyAttribute));\n}\n#endif /* LIBXML_TREE_ENABLED */\n\n#ifdef LIBXML_OUTPUT_ENABLED\n/**\n * xmlDumpAttributeDecl:\n * @buf:  the XML buffer output\n * @attr:  An attribute declaration\n *\n * This will dump the content of the attribute declaration as an XML\n * DTD definition\n */\nvoid\nxmlDumpAttributeDecl(xmlBufferPtr buf, xmlAttributePtr attr) {\n    if ((buf == NULL) || (attr == NULL))\n        return;\n    xmlBufferWriteChar(buf, \"<!ATTLIST \");\n    xmlBufferWriteCHAR(buf, attr->elem);\n    xmlBufferWriteChar(buf, \" \");\n    if (attr->prefix != NULL) {\n\txmlBufferWriteCHAR(buf, attr->prefix);\n\txmlBufferWriteChar(buf, \":\");\n    }\n    xmlBufferWriteCHAR(buf, attr->name);\n    switch (attr->atype) {\n\tcase XML_ATTRIBUTE_CDATA:\n\t    xmlBufferWriteChar(buf, \" CDATA\");\n\t    break;\n\tcase XML_ATTRIBUTE_ID:\n\t    xmlBufferWriteChar(buf, \" ID\");\n\t    break;\n\tcase XML_ATTRIBUTE_IDREF:\n\t    xmlBufferWriteChar(buf, \" IDREF\");\n\t    break;\n\tcase XML_ATTRIBUTE_IDREFS:\n\t    xmlBufferWriteChar(buf, \" IDREFS\");\n\t    break;\n\tcase XML_ATTRIBUTE_ENTITY:\n\t    xmlBufferWriteChar(buf, \" ENTITY\");\n\t    break;\n\tcase XML_ATTRIBUTE_ENTITIES:\n\t    xmlBufferWriteChar(buf, \" ENTITIES\");\n\t    break;\n\tcase XML_ATTRIBUTE_NMTOKEN:\n\t    xmlBufferWriteChar(buf, \" NMTOKEN\");\n\t    break;\n\tcase XML_ATTRIBUTE_NMTOKENS:\n\t    xmlBufferWriteChar(buf, \" NMTOKENS\");\n\t    break;\n\tcase XML_ATTRIBUTE_ENUMERATION:\n\t    xmlBufferWriteChar(buf, \" (\");\n\t    xmlDumpEnumeration(buf, attr->tree);\n\t    break;\n\tcase XML_ATTRIBUTE_NOTATION:\n\t    xmlBufferWriteChar(buf, \" NOTATION (\");\n\t    xmlDumpEnumeration(buf, attr->tree);\n\t    break;\n\tdefault:\n\t    xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\n\t\t    \"Internal: ATTRIBUTE struct corrupted invalid type\\n\",\n\t\t    NULL);\n    }\n    switch (attr->def) {\n\tcase XML_ATTRIBUTE_NONE:\n\t    break;\n\tcase XML_ATTRIBUTE_REQUIRED:\n\t    xmlBufferWriteChar(buf, \" #REQUIRED\");\n\t    break;\n\tcase XML_ATTRIBUTE_IMPLIED:\n\t    xmlBufferWriteChar(buf, \" #IMPLIED\");\n\t    break;\n\tcase XML_ATTRIBUTE_FIXED:\n\t    xmlBufferWriteChar(buf, \" #FIXED\");\n\t    break;\n\tdefault:\n\t    xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\n\t\t    \"Internal: ATTRIBUTE struct corrupted invalid def\\n\",\n\t\t    NULL);\n    }\n    if (attr->defaultValue != NULL) {\n\txmlBufferWriteChar(buf, \" \");\n\txmlBufferWriteQuotedString(buf, attr->defaultValue);\n    }\n    xmlBufferWriteChar(buf, \">\\n\");\n}\n\n/**\n * xmlDumpAttributeDeclScan:\n * @attr:  An attribute declaration\n * @buf:  the XML buffer output\n *\n * This is used with the hash scan function - just reverses arguments\n */\nstatic void\nxmlDumpAttributeDeclScan(void *attr, void *buf,\n                         const xmlChar *name ATTRIBUTE_UNUSED) {\n    xmlDumpAttributeDecl((xmlBufferPtr) buf, (xmlAttributePtr) attr);\n}\n\n/**\n * xmlDumpAttributeTable:\n * @buf:  the XML buffer output\n * @table:  An attribute table\n *\n * This will dump the content of the attribute table as an XML DTD definition\n */\nvoid\nxmlDumpAttributeTable(xmlBufferPtr buf, xmlAttributeTablePtr table) {\n    if ((buf == NULL) || (table == NULL))\n        return;\n    xmlHashScan(table, xmlDumpAttributeDeclScan, buf);\n}\n#endif /* LIBXML_OUTPUT_ENABLED */\n\n/************************************************************************\n *\t\t\t\t\t\t\t\t\t*\n *\t\t\t\tNOTATIONs\t\t\t\t*\n *\t\t\t\t\t\t\t\t\t*\n ************************************************************************/\n/**\n * xmlFreeNotation:\n * @not:  A notation\n *\n * Deallocate the memory used by an notation definition\n */\nstatic void\nxmlFreeNotation(xmlNotationPtr nota) {\n    if (nota == NULL) return;\n    if (nota->name != NULL)\n\txmlFree((xmlChar *) nota->name);\n    if (nota->PublicID != NULL)\n\txmlFree((xmlChar *) nota->PublicID);\n    if (nota->SystemID != NULL)\n\txmlFree((xmlChar *) nota->SystemID);\n    xmlFree(nota);\n}\n\n\n/**\n * xmlAddNotationDecl:\n * @dtd:  pointer to the DTD\n * @ctxt:  the validation context\n * @name:  the entity name\n * @PublicID:  the public identifier or NULL\n * @SystemID:  the system identifier or NULL\n *\n * Register a new notation declaration\n *\n * Returns NULL if not, otherwise the entity\n */\nxmlNotationPtr\nxmlAddNotationDecl(xmlValidCtxtPtr ctxt, xmlDtdPtr dtd,\n\t           const xmlChar *name,\n                   const xmlChar *PublicID, const xmlChar *SystemID) {\n    xmlNotationPtr ret;\n    xmlNotationTablePtr table;\n\n    if (dtd == NULL) {\n\treturn(NULL);\n    }\n    if (name == NULL) {\n\treturn(NULL);\n    }\n    if ((PublicID == NULL) && (SystemID == NULL)) {\n\treturn(NULL);\n    }\n\n    /*\n     * Create the Notation table if needed.\n     */\n    table = (xmlNotationTablePtr) dtd->notations;\n    if (table == NULL) {\n\txmlDictPtr dict = NULL;\n\tif (dtd->doc != NULL)\n\t    dict = dtd->doc->dict;\n\n        dtd->notations = table = xmlHashCreateDict(0, dict);\n    }\n    if (table == NULL) {\n\txmlVErrMemory(ctxt,\n\t\t\"xmlAddNotationDecl: Table creation failed!\\n\");\n        return(NULL);\n    }\n\n    ret = (xmlNotationPtr) xmlMalloc(sizeof(xmlNotation));\n    if (ret == NULL) {\n\txmlVErrMemory(ctxt, \"malloc failed\");\n\treturn(NULL);\n    }\n    memset(ret, 0, sizeof(xmlNotation));\n\n    /*\n     * fill the structure.\n     */\n    ret->name = xmlStrdup(name);\n    if (SystemID != NULL)\n        ret->SystemID = xmlStrdup(SystemID);\n    if (PublicID != NULL)\n        ret->PublicID = xmlStrdup(PublicID);\n\n    /*\n     * Validity Check:\n     * Check the DTD for previous declarations of the ATTLIST\n     */\n    if (xmlHashAddEntry(table, name, ret)) {\n#ifdef LIBXML_VALID_ENABLED\n\txmlErrValid(NULL, XML_DTD_NOTATION_REDEFINED,\n\t\t    \"xmlAddNotationDecl: %s already defined\\n\",\n\t\t    (const char *) name);\n#endif /* LIBXML_VALID_ENABLED */\n\txmlFreeNotation(ret);\n\treturn(NULL);\n    }\n    return(ret);\n}\n\nstatic void\nxmlFreeNotationTableEntry(void *nota, const xmlChar *name ATTRIBUTE_UNUSED) {\n    xmlFreeNotation((xmlNotationPtr) nota);\n}\n\n/**\n * xmlFreeNotationTable:\n * @table:  An notation table\n *\n * Deallocate the memory used by an entities hash table.\n */\nvoid\nxmlFreeNotationTable(xmlNotationTablePtr table) {\n    xmlHashFree(table, xmlFreeNotationTableEntry);\n}\n\n#ifdef LIBXML_TREE_ENABLED\n/**\n * xmlCopyNotation:\n * @nota:  A notation\n *\n * Build a copy of a notation.\n *\n * Returns the new xmlNotationPtr or NULL in case of error.\n */\nstatic void *\nxmlCopyNotation(void *payload, const xmlChar *name ATTRIBUTE_UNUSED) {\n    xmlNotationPtr nota = (xmlNotationPtr) payload;\n    xmlNotationPtr cur;\n\n    cur = (xmlNotationPtr) xmlMalloc(sizeof(xmlNotation));\n    if (cur == NULL) {\n\txmlVErrMemory(NULL, \"malloc failed\");\n\treturn(NULL);\n    }\n    if (nota->name != NULL)\n\tcur->name = xmlStrdup(nota->name);\n    else\n\tcur->name = NULL;\n    if (nota->PublicID != NULL)\n\tcur->PublicID = xmlStrdup(nota->PublicID);\n    else\n\tcur->PublicID = NULL;\n    if (nota->SystemID != NULL)\n\tcur->SystemID = xmlStrdup(nota->SystemID);\n    else\n\tcur->SystemID = NULL;\n    return(cur);\n}\n\n/**\n * xmlCopyNotationTable:\n * @table:  A notation table\n *\n * Build a copy of a notation table.\n *\n * Returns the new xmlNotationTablePtr or NULL in case of error.\n */\nxmlNotationTablePtr\nxmlCopyNotationTable(xmlNotationTablePtr table) {\n    return((xmlNotationTablePtr) xmlHashCopy(table, xmlCopyNotation));\n}\n#endif /* LIBXML_TREE_ENABLED */\n\n#ifdef LIBXML_OUTPUT_ENABLED\n/**\n * xmlDumpNotationDecl:\n * @buf:  the XML buffer output\n * @nota:  A notation declaration\n *\n * This will dump the content the notation declaration as an XML DTD definition\n */\nvoid\nxmlDumpNotationDecl(xmlBufferPtr buf, xmlNotationPtr nota) {\n    if ((buf == NULL) || (nota == NULL))\n        return;\n    xmlBufferWriteChar(buf, \"<!NOTATION \");\n    xmlBufferWriteCHAR(buf, nota->name);\n    if (nota->PublicID != NULL) {\n\txmlBufferWriteChar(buf, \" PUBLIC \");\n\txmlBufferWriteQuotedString(buf, nota->PublicID);\n\tif (nota->SystemID != NULL) {\n\t    xmlBufferWriteChar(buf, \" \");\n\t    xmlBufferWriteQuotedString(buf, nota->SystemID);\n\t}\n    } else {\n\txmlBufferWriteChar(buf, \" SYSTEM \");\n\txmlBufferWriteQuotedString(buf, nota->SystemID);\n    }\n    xmlBufferWriteChar(buf, \" >\\n\");\n}\n\n/**\n * xmlDumpNotationDeclScan:\n * @nota:  A notation declaration\n * @buf:  the XML buffer output\n *\n * This is called with the hash scan function, and just reverses args\n */\nstatic void\nxmlDumpNotationDeclScan(void *nota, void *buf,\n                        const xmlChar *name ATTRIBUTE_UNUSED) {\n    xmlDumpNotationDecl((xmlBufferPtr) buf, (xmlNotationPtr) nota);\n}\n\n/**\n * xmlDumpNotationTable:\n * @buf:  the XML buffer output\n * @table:  A notation table\n *\n * This will dump the content of the notation table as an XML DTD definition\n */\nvoid\nxmlDumpNotationTable(xmlBufferPtr buf, xmlNotationTablePtr table) {\n    if ((buf == NULL) || (table == NULL))\n        return;\n    xmlHashScan(table, xmlDumpNotationDeclScan, buf);\n}\n#endif /* LIBXML_OUTPUT_ENABLED */\n\n/************************************************************************\n *\t\t\t\t\t\t\t\t\t*\n *\t\t\t\tIDs\t\t\t\t\t*\n *\t\t\t\t\t\t\t\t\t*\n ************************************************************************/\n/**\n * DICT_FREE:\n * @str:  a string\n *\n * Free a string if it is not owned by the \"dict\" dictionary in the\n * current scope\n */\n#define DICT_FREE(str)\t\t\t\t\t\t\\\n\tif ((str) && ((!dict) ||\t\t\t\t\\\n\t    (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))\t\\\n\t    xmlFree((char *)(str));\n\nstatic int\nxmlIsStreaming(xmlValidCtxtPtr ctxt) {\n    xmlParserCtxtPtr pctxt;\n\n    if (ctxt == NULL)\n        return(0);\n    /*\n     * These magic values are also abused to detect whether we're validating\n     * while parsing a document. In this case, userData points to the parser\n     * context.\n     */\n    if ((ctxt->finishDtd != XML_CTXT_FINISH_DTD_0) &&\n        (ctxt->finishDtd != XML_CTXT_FINISH_DTD_1))\n        return(0);\n    pctxt = ctxt->userData;\n    return(pctxt->parseMode == XML_PARSE_READER);\n}\n\n/**\n * xmlFreeID:\n * @not:  A id\n *\n * Deallocate the memory used by an id definition\n */\nstatic void\nxmlFreeID(xmlIDPtr id) {\n    xmlDictPtr dict = NULL;\n\n    if (id == NULL) return;\n\n    if (id->doc != NULL)\n        dict = id->doc->dict;\n\n    if (id->value != NULL)\n\tDICT_FREE(id->value)\n    if (id->name != NULL)\n\tDICT_FREE(id->name)\n    xmlFree(id);\n}\n\n\n/**\n * xmlAddID:\n * @ctxt:  the validation context\n * @doc:  pointer to the document\n * @value:  the value name\n * @attr:  the attribute holding the ID\n *\n * Register a new id declaration\n *\n * Returns NULL if not, otherwise the new xmlIDPtr\n */\nxmlIDPtr\nxmlAddID(xmlValidCtxtPtr ctxt, xmlDocPtr doc, const xmlChar *value,\n         xmlAttrPtr attr) {\n    xmlIDPtr ret;\n    xmlIDTablePtr table;\n\n    if (doc == NULL) {\n\treturn(NULL);\n    }\n    if ((value == NULL) || (value[0] == 0)) {\n\treturn(NULL);\n    }\n    if (attr == NULL) {\n\treturn(NULL);\n    }\n\n    /*\n     * Create the ID table if needed.\n     */\n    table = (xmlIDTablePtr) doc->ids;\n    if (table == NULL)  {\n        doc->ids = table = xmlHashCreateDict(0, doc->dict);\n    }\n    if (table == NULL) {\n\txmlVErrMemory(ctxt,\n\t\t\"xmlAddID: Table creation failed!\\n\");\n        return(NULL);\n    }\n\n    ret = (xmlIDPtr) xmlMalloc(sizeof(xmlID));\n    if (ret == NULL) {\n\txmlVErrMemory(ctxt, \"malloc failed\");\n\treturn(NULL);\n    }\n\n    /*\n     * fill the structure.\n     */\n    ret->value = xmlStrdup(value);\n    ret->doc = doc;\n    if (xmlIsStreaming(ctxt)) {\n\t/*\n\t * Operating in streaming mode, attr is gonna disappear\n\t */\n\tif (doc->dict != NULL)\n\t    ret->name = xmlDictLookup(doc->dict, attr->name, -1);\n\telse\n\t    ret->name = xmlStrdup(attr->name);\n\tret->attr = NULL;\n    } else {\n\tret->attr = attr;\n\tret->name = NULL;\n    }\n    ret->lineno = xmlGetLineNo(attr->parent);\n\n    if (xmlHashAddEntry(table, value, ret) < 0) {\n#ifdef LIBXML_VALID_ENABLED\n\t/*\n\t * The id is already defined in this DTD.\n\t */\n\tif (ctxt != NULL) {\n\t    xmlErrValidNode(ctxt, attr->parent, XML_DTD_ID_REDEFINED,\n\t\t\t    \"ID %s already defined\\n\", value, NULL, NULL);\n\t}\n#endif /* LIBXML_VALID_ENABLED */\n\txmlFreeID(ret);\n\treturn(NULL);\n    }\n    if (attr != NULL)\n\tattr->atype = XML_ATTRIBUTE_ID;\n    return(ret);\n}\n\nstatic void\nxmlFreeIDTableEntry(void *id, const xmlChar *name ATTRIBUTE_UNUSED) {\n    xmlFreeID((xmlIDPtr) id);\n}\n\n/**\n * xmlFreeIDTable:\n * @table:  An id table\n *\n * Deallocate the memory used by an ID hash table.\n */\nvoid\nxmlFreeIDTable(xmlIDTablePtr table) {\n    xmlHashFree(table, xmlFreeIDTableEntry);\n}\n\n/**\n * xmlIsID:\n * @doc:  the document\n * @elem:  the element carrying the attribute\n * @attr:  the attribute\n *\n * Determine whether an attribute is of type ID. In case we have DTD(s)\n * then this is done if DTD loading has been requested. In the case\n * of HTML documents parsed with the HTML parser, then ID detection is\n * done systematically.\n *\n * Returns 0 or 1 depending on the lookup result\n */\nint\nxmlIsID(xmlDocPtr doc, xmlNodePtr elem, xmlAttrPtr attr) {\n    if ((attr == NULL) || (attr->name == NULL)) return(0);\n    if ((attr->ns != NULL) && (attr->ns->prefix != NULL) &&\n        (!strcmp((char *) attr->name, \"id\")) &&\n        (!strcmp((char *) attr->ns->prefix, \"xml\")))\n\treturn(1);\n    if (doc == NULL) return(0);\n    if ((doc->intSubset == NULL) && (doc->extSubset == NULL) &&\n        (doc->type != XML_HTML_DOCUMENT_NODE)) {\n\treturn(0);\n    } else if (doc->type == XML_HTML_DOCUMENT_NODE) {\n        if ((xmlStrEqual(BAD_CAST \"id\", attr->name)) ||\n\t    ((xmlStrEqual(BAD_CAST \"name\", attr->name)) &&\n\t    ((elem == NULL) || (xmlStrEqual(elem->name, BAD_CAST \"a\")))))\n\t    return(1);\n\treturn(0);\n    } else if (elem == NULL) {\n\treturn(0);\n    } else {\n\txmlAttributePtr attrDecl = NULL;\n\n\txmlChar felem[50], fattr[50];\n\txmlChar *fullelemname, *fullattrname;\n\n\tfullelemname = (elem->ns != NULL && elem->ns->prefix != NULL) ?\n\t    xmlBuildQName(elem->name, elem->ns->prefix, felem, 50) :\n\t    (xmlChar *)elem->name;\n\n\tfullattrname = (attr->ns != NULL && attr->ns->prefix != NULL) ?\n\t    xmlBuildQName(attr->name, attr->ns->prefix, fattr, 50) :\n\t    (xmlChar *)attr->name;\n\n\tif (fullelemname != NULL && fullattrname != NULL) {\n\t    attrDecl = xmlGetDtdAttrDesc(doc->intSubset, fullelemname,\n\t\t                         fullattrname);\n\t    if ((attrDecl == NULL) && (doc->extSubset != NULL))\n\t\tattrDecl = xmlGetDtdAttrDesc(doc->extSubset, fullelemname,\n\t\t\t\t\t     fullattrname);\n\t}\n\n\tif ((fullattrname != fattr) && (fullattrname != attr->name))\n\t    xmlFree(fullattrname);\n\tif ((fullelemname != felem) && (fullelemname != elem->name))\n\t    xmlFree(fullelemname);\n\n        if ((attrDecl != NULL) && (attrDecl->atype == XML_ATTRIBUTE_ID))\n\t    return(1);\n    }\n    return(0);\n}\n\n/**\n * xmlRemoveID:\n * @doc:  the document\n * @attr:  the attribute\n *\n * Remove the given attribute from the ID table maintained internally.\n *\n * Returns -1 if the lookup failed and 0 otherwise\n */\nint\nxmlRemoveID(xmlDocPtr doc, xmlAttrPtr attr) {\n    xmlIDTablePtr table;\n    xmlIDPtr id;\n    xmlChar *ID;\n\n    if (doc == NULL) return(-1);\n    if (attr == NULL) return(-1);\n\n    table = (xmlIDTablePtr) doc->ids;\n    if (table == NULL)\n        return(-1);\n\n    ID = xmlNodeListGetString(doc, attr->children, 1);\n    if (ID == NULL)\n        return(-1);\n    xmlValidNormalizeString(ID);\n\n    id = xmlHashLookup(table, ID);\n    if (id == NULL || id->attr != attr) {\n        xmlFree(ID);\n        return(-1);\n    }\n\n    xmlHashRemoveEntry(table, ID, xmlFreeIDTableEntry);\n    xmlFree(ID);\n    attr->atype = 0;\n    return(0);\n}\n\n/**\n * xmlGetID:\n * @doc:  pointer to the document\n * @ID:  the ID value\n *\n * Search the attribute declaring the given ID\n *\n * Returns NULL if not found, otherwise the xmlAttrPtr defining the ID\n */\nxmlAttrPtr\nxmlGetID(xmlDocPtr doc, const xmlChar *ID) {\n    xmlIDTablePtr table;\n    xmlIDPtr id;\n\n    if (doc == NULL) {\n\treturn(NULL);\n    }\n\n    if (ID == NULL) {\n\treturn(NULL);\n    }\n\n    table = (xmlIDTablePtr) doc->ids;\n    if (table == NULL)\n        return(NULL);\n\n    id = xmlHashLookup(table, ID);\n    if (id == NULL)\n\treturn(NULL);\n    if (id->attr == NULL) {\n\t/*\n\t * We are operating on a stream, return a well known reference\n\t * since the attribute node doesn't exist anymore\n\t */\n\treturn((xmlAttrPtr) doc);\n    }\n    return(id->attr);\n}\n\n/************************************************************************\n *\t\t\t\t\t\t\t\t\t*\n *\t\t\t\tRefs\t\t\t\t\t*\n *\t\t\t\t\t\t\t\t\t*\n ************************************************************************/\ntypedef struct xmlRemoveMemo_t\n{\n\txmlListPtr l;\n\txmlAttrPtr ap;\n} xmlRemoveMemo;\n\ntypedef xmlRemoveMemo *xmlRemoveMemoPtr;\n\ntypedef struct xmlValidateMemo_t\n{\n    xmlValidCtxtPtr ctxt;\n    const xmlChar *name;\n} xmlValidateMemo;\n\ntypedef xmlValidateMemo *xmlValidateMemoPtr;\n\n/**\n * xmlFreeRef:\n * @lk:  A list link\n *\n * Deallocate the memory used by a ref definition\n */\nstatic void\nxmlFreeRef(xmlLinkPtr lk) {\n    xmlRefPtr ref = (xmlRefPtr)xmlLinkGetData(lk);\n    if (ref == NULL) return;\n    if (ref->value != NULL)\n        xmlFree((xmlChar *)ref->value);\n    if (ref->name != NULL)\n        xmlFree((xmlChar *)ref->name);\n    xmlFree(ref);\n}\n\n/**\n * xmlFreeRefTableEntry:\n * @list_ref:  A list of references.\n *\n * Deallocate the memory used by a list of references\n */\nstatic void\nxmlFreeRefTableEntry(void *payload, const xmlChar *name ATTRIBUTE_UNUSED) {\n    xmlListPtr list_ref = (xmlListPtr) payload;\n    if (list_ref == NULL) return;\n    xmlListDelete(list_ref);\n}\n\n/**\n * xmlWalkRemoveRef:\n * @data:  Contents of current link\n * @user:  Value supplied by the user\n *\n * Returns 0 to abort the walk or 1 to continue\n */\nstatic int\nxmlWalkRemoveRef(const void *data, void *user)\n{\n    xmlAttrPtr attr0 = ((xmlRefPtr)data)->attr;\n    xmlAttrPtr attr1 = ((xmlRemoveMemoPtr)user)->ap;\n    xmlListPtr ref_list = ((xmlRemoveMemoPtr)user)->l;\n\n    if (attr0 == attr1) { /* Matched: remove and terminate walk */\n        xmlListRemoveFirst(ref_list, (void *)data);\n        return 0;\n    }\n    return 1;\n}\n\n/**\n * xmlDummyCompare\n * @data0:  Value supplied by the user\n * @data1:  Value supplied by the user\n *\n * Do nothing, return 0. Used to create unordered lists.\n */\nstatic int\nxmlDummyCompare(const void *data0 ATTRIBUTE_UNUSED,\n                const void *data1 ATTRIBUTE_UNUSED)\n{\n    return (0);\n}\n\n/**\n * xmlAddRef:\n * @ctxt:  the validation context\n * @doc:  pointer to the document\n * @value:  the value name\n * @attr:  the attribute holding the Ref\n *\n * Register a new ref declaration\n *\n * Returns NULL if not, otherwise the new xmlRefPtr\n */\nxmlRefPtr\nxmlAddRef(xmlValidCtxtPtr ctxt, xmlDocPtr doc, const xmlChar *value,\n    xmlAttrPtr attr) {\n    xmlRefPtr ret;\n    xmlRefTablePtr table;\n    xmlListPtr ref_list;\n\n    if (doc == NULL) {\n        return(NULL);\n    }\n    if (value == NULL) {\n        return(NULL);\n    }\n    if (attr == NULL) {\n        return(NULL);\n    }\n\n    /*\n     * Create the Ref table if needed.\n     */\n    table = (xmlRefTablePtr) doc->refs;\n    if (table == NULL) {\n        doc->refs = table = xmlHashCreateDict(0, doc->dict);\n    }\n    if (table == NULL) {\n\txmlVErrMemory(ctxt,\n            \"xmlAddRef: Table creation failed!\\n\");\n        return(NULL);\n    }\n\n    ret = (xmlRefPtr) xmlMalloc(sizeof(xmlRef));\n    if (ret == NULL) {\n\txmlVErrMemory(ctxt, \"malloc failed\");\n        return(NULL);\n    }\n\n    /*\n     * fill the structure.\n     */\n    ret->value = xmlStrdup(value);\n    if (xmlIsStreaming(ctxt)) {\n\t/*\n\t * Operating in streaming mode, attr is gonna disappear\n\t */\n\tret->name = xmlStrdup(attr->name);\n\tret->attr = NULL;\n    } else {\n\tret->name = NULL;\n\tret->attr = attr;\n    }\n    ret->lineno = xmlGetLineNo(attr->parent);\n\n    /* To add a reference :-\n     * References are maintained as a list of references,\n     * Lookup the entry, if no entry create new nodelist\n     * Add the owning node to the NodeList\n     * Return the ref\n     */\n\n    if (NULL == (ref_list = xmlHashLookup(table, value))) {\n        if (NULL == (ref_list = xmlListCreate(xmlFreeRef, xmlDummyCompare))) {\n\t    xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\n\t\t    \"xmlAddRef: Reference list creation failed!\\n\",\n\t\t    NULL);\n\t    goto failed;\n        }\n        if (xmlHashAddEntry(table, value, ref_list) < 0) {\n            xmlListDelete(ref_list);\n\t    xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\n\t\t    \"xmlAddRef: Reference list insertion failed!\\n\",\n\t\t    NULL);\n\t    goto failed;\n        }\n    }\n    if (xmlListAppend(ref_list, ret) != 0) {\n\txmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\n\t\t    \"xmlAddRef: Reference list insertion failed!\\n\",\n\t\t    NULL);\n        goto failed;\n    }\n    return(ret);\nfailed:\n    if (ret != NULL) {\n        if (ret->value != NULL)\n\t    xmlFree((char *)ret->value);\n        if (ret->name != NULL)\n\t    xmlFree((char *)ret->name);\n        xmlFree(ret);\n    }\n    return(NULL);\n}\n\n/**\n * xmlFreeRefTable:\n * @table:  An ref table\n *\n * Deallocate the memory used by an Ref hash table.\n */\nvoid\nxmlFreeRefTable(xmlRefTablePtr table) {\n    xmlHashFree(table, xmlFreeRefTableEntry);\n}\n\n/**\n * xmlIsRef:\n * @doc:  the document\n * @elem:  the element carrying the attribute\n * @attr:  the attribute\n *\n * Determine whether an attribute is of type Ref. In case we have DTD(s)\n * then this is simple, otherwise we use an heuristic: name Ref (upper\n * or lowercase).\n *\n * Returns 0 or 1 depending on the lookup result\n */\nint\nxmlIsRef(xmlDocPtr doc, xmlNodePtr elem, xmlAttrPtr attr) {\n    if (attr == NULL)\n        return(0);\n    if (doc == NULL) {\n        doc = attr->doc;\n\tif (doc == NULL) return(0);\n    }\n\n    if ((doc->intSubset == NULL) && (doc->extSubset == NULL)) {\n        return(0);\n    } else if (doc->type == XML_HTML_DOCUMENT_NODE) {\n        /* TODO @@@ */\n        return(0);\n    } else {\n        xmlAttributePtr attrDecl;\n\n        if (elem == NULL) return(0);\n        attrDecl = xmlGetDtdAttrDesc(doc->intSubset, elem->name, attr->name);\n        if ((attrDecl == NULL) && (doc->extSubset != NULL))\n            attrDecl = xmlGetDtdAttrDesc(doc->extSubset,\n\t\t                         elem->name, attr->name);\n\n\tif ((attrDecl != NULL) &&\n\t    (attrDecl->atype == XML_ATTRIBUTE_IDREF ||\n\t     attrDecl->atype == XML_ATTRIBUTE_IDREFS))\n\treturn(1);\n    }\n    return(0);\n}\n\n/**\n * xmlRemoveRef:\n * @doc:  the document\n * @attr:  the attribute\n *\n * Remove the given attribute from the Ref table maintained internally.\n *\n * Returns -1 if the lookup failed and 0 otherwise\n */\nint\nxmlRemoveRef(xmlDocPtr doc, xmlAttrPtr attr) {\n    xmlListPtr ref_list;\n    xmlRefTablePtr table;\n    xmlChar *ID;\n    xmlRemoveMemo target;\n\n    if (doc == NULL) return(-1);\n    if (attr == NULL) return(-1);\n\n    table = (xmlRefTablePtr) doc->refs;\n    if (table == NULL)\n        return(-1);\n\n    ID = xmlNodeListGetString(doc, attr->children, 1);\n    if (ID == NULL)\n        return(-1);\n\n    ref_list = xmlHashLookup(table, ID);\n    if(ref_list == NULL) {\n        xmlFree(ID);\n        return (-1);\n    }\n\n    /* At this point, ref_list refers to a list of references which\n     * have the same key as the supplied attr. Our list of references\n     * is ordered by reference address and we don't have that information\n     * here to use when removing. We'll have to walk the list and\n     * check for a matching attribute, when we find one stop the walk\n     * and remove the entry.\n     * The list is ordered by reference, so that means we don't have the\n     * key. Passing the list and the reference to the walker means we\n     * will have enough data to be able to remove the entry.\n     */\n    target.l = ref_list;\n    target.ap = attr;\n\n    /* Remove the supplied attr from our list */\n    xmlListWalk(ref_list, xmlWalkRemoveRef, &target);\n\n    /*If the list is empty then remove the list entry in the hash */\n    if (xmlListEmpty(ref_list))\n        xmlHashUpdateEntry(table, ID, NULL, xmlFreeRefTableEntry);\n    xmlFree(ID);\n    return(0);\n}\n\n/**\n * xmlGetRefs:\n * @doc:  pointer to the document\n * @ID:  the ID value\n *\n * Find the set of references for the supplied ID.\n *\n * Returns NULL if not found, otherwise node set for the ID.\n */\nxmlListPtr\nxmlGetRefs(xmlDocPtr doc, const xmlChar *ID) {\n    xmlRefTablePtr table;\n\n    if (doc == NULL) {\n        return(NULL);\n    }\n\n    if (ID == NULL) {\n        return(NULL);\n    }\n\n    table = (xmlRefTablePtr) doc->refs;\n    if (table == NULL)\n        return(NULL);\n\n    return (xmlHashLookup(table, ID));\n}\n\n/************************************************************************\n *\t\t\t\t\t\t\t\t\t*\n *\t\tRoutines for validity checking\t\t\t\t*\n *\t\t\t\t\t\t\t\t\t*\n ************************************************************************/\n\n/**\n * xmlGetDtdElementDesc:\n * @dtd:  a pointer to the DtD to search\n * @name:  the element name\n *\n * Search the DTD for the description of this element\n *\n * returns the xmlElementPtr if found or NULL\n */\n\nxmlElementPtr\nxmlGetDtdElementDesc(xmlDtdPtr dtd, const xmlChar *name) {\n    xmlElementTablePtr table;\n    xmlElementPtr cur;\n    xmlChar *uqname = NULL, *prefix = NULL;\n\n    if ((dtd == NULL) || (name == NULL)) return(NULL);\n    if (dtd->elements == NULL)\n\treturn(NULL);\n    table = (xmlElementTablePtr) dtd->elements;\n\n    uqname = xmlSplitQName2(name, &prefix);\n    if (uqname != NULL)\n        name = uqname;\n    cur = xmlHashLookup2(table, name, prefix);\n    if (prefix != NULL) xmlFree(prefix);\n    if (uqname != NULL) xmlFree(uqname);\n    return(cur);\n}\n/**\n * xmlGetDtdElementDesc2:\n * @dtd:  a pointer to the DtD to search\n * @name:  the element name\n * @create:  create an empty description if not found\n *\n * Search the DTD for the description of this element\n *\n * returns the xmlElementPtr if found or NULL\n */\n\nstatic xmlElementPtr\nxmlGetDtdElementDesc2(xmlDtdPtr dtd, const xmlChar *name, int create) {\n    xmlElementTablePtr table;\n    xmlElementPtr cur;\n    xmlChar *uqname = NULL, *prefix = NULL;\n\n    if (dtd == NULL) return(NULL);\n    if (dtd->elements == NULL) {\n\txmlDictPtr dict = NULL;\n\n\tif (dtd->doc != NULL)\n\t    dict = dtd->doc->dict;\n\n\tif (!create)\n\t    return(NULL);\n\t/*\n\t * Create the Element table if needed.\n\t */\n\ttable = (xmlElementTablePtr) dtd->elements;\n\tif (table == NULL) {\n\t    table = xmlHashCreateDict(0, dict);\n\t    dtd->elements = (void *) table;\n\t}\n\tif (table == NULL) {\n\t    xmlVErrMemory(NULL, \"element table allocation failed\");\n\t    return(NULL);\n\t}\n    }\n    table = (xmlElementTablePtr) dtd->elements;\n\n    uqname = xmlSplitQName2(name, &prefix);\n    if (uqname != NULL)\n        name = uqname;\n    cur = xmlHashLookup2(table, name, prefix);\n    if ((cur == NULL) && (create)) {\n\tcur = (xmlElementPtr) xmlMalloc(sizeof(xmlElement));\n\tif (cur == NULL) {\n\t    xmlVErrMemory(NULL, \"malloc failed\");\n\t    return(NULL);\n\t}\n\tmemset(cur, 0, sizeof(xmlElement));\n\tcur->type = XML_ELEMENT_DECL;\n\n\t/*\n\t * fill the structure.\n\t */\n\tcur->name = xmlStrdup(name);\n\tcur->prefix = xmlStrdup(prefix);\n\tcur->etype = XML_ELEMENT_TYPE_UNDEFINED;\n\n\txmlHashAddEntry2(table, name, prefix, cur);\n    }\n    if (prefix != NULL) xmlFree(prefix);\n    if (uqname != NULL) xmlFree(uqname);\n    return(cur);\n}\n\n/**\n * xmlGetDtdQElementDesc:\n * @dtd:  a pointer to the DtD to search\n * @name:  the element name\n * @prefix:  the element namespace prefix\n *\n * Search the DTD for the description of this element\n *\n * returns the xmlElementPtr if found or NULL\n */\n\nxmlElementPtr\nxmlGetDtdQElementDesc(xmlDtdPtr dtd, const xmlChar *name,\n\t              const xmlChar *prefix) {\n    xmlElementTablePtr table;\n\n    if (dtd == NULL) return(NULL);\n    if (dtd->elements == NULL) return(NULL);\n    table = (xmlElementTablePtr) dtd->elements;\n\n    return(xmlHashLookup2(table, name, prefix));\n}\n\n/**\n * xmlGetDtdAttrDesc:\n * @dtd:  a pointer to the DtD to search\n * @elem:  the element name\n * @name:  the attribute name\n *\n * Search the DTD for the description of this attribute on\n * this element.\n *\n * returns the xmlAttributePtr if found or NULL\n */\n\nxmlAttributePtr\nxmlGetDtdAttrDesc(xmlDtdPtr dtd, const xmlChar *elem, const xmlChar *name) {\n    xmlAttributeTablePtr table;\n    xmlAttributePtr cur;\n    xmlChar *uqname = NULL, *prefix = NULL;\n\n    if (dtd == NULL) return(NULL);\n    if (dtd->attributes == NULL) return(NULL);\n\n    table = (xmlAttributeTablePtr) dtd->attributes;\n    if (table == NULL)\n\treturn(NULL);\n\n    uqname = xmlSplitQName2(name, &prefix);\n\n    if (uqname != NULL) {\n\tcur = xmlHashLookup3(table, uqname, prefix, elem);\n\tif (prefix != NULL) xmlFree(prefix);\n\tif (uqname != NULL) xmlFree(uqname);\n    } else\n\tcur = xmlHashLookup3(table, name, NULL, elem);\n    return(cur);\n}\n\n/**\n * xmlGetDtdQAttrDesc:\n * @dtd:  a pointer to the DtD to search\n * @elem:  the element name\n * @name:  the attribute name\n * @prefix:  the attribute namespace prefix\n *\n * Search the DTD for the description of this qualified attribute on\n * this element.\n *\n * returns the xmlAttributePtr if found or NULL\n */\n\nxmlAttributePtr\nxmlGetDtdQAttrDesc(xmlDtdPtr dtd, const xmlChar *elem, const xmlChar *name,\n\t          const xmlChar *prefix) {\n    xmlAttributeTablePtr table;\n\n    if (dtd == NULL) return(NULL);\n    if (dtd->attributes == NULL) return(NULL);\n    table = (xmlAttributeTablePtr) dtd->attributes;\n\n    return(xmlHashLookup3(table, name, prefix, elem));\n}\n\n/**\n * xmlGetDtdNotationDesc:\n * @dtd:  a pointer to the DtD to search\n * @name:  the notation name\n *\n * Search the DTD for the description of this notation\n *\n * returns the xmlNotationPtr if found or NULL\n */\n\nxmlNotationPtr\nxmlGetDtdNotationDesc(xmlDtdPtr dtd, const xmlChar *name) {\n    xmlNotationTablePtr table;\n\n    if (dtd == NULL) return(NULL);\n    if (dtd->notations == NULL) return(NULL);\n    table = (xmlNotationTablePtr) dtd->notations;\n\n    return(xmlHashLookup(table, name));\n}\n\n#if defined(LIBXML_VALID_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)\n/**\n * xmlValidateNotationUse:\n * @ctxt:  the validation context\n * @doc:  the document\n * @notationName:  the notation name to check\n *\n * Validate that the given name match a notation declaration.\n * - [ VC: Notation Declared ]\n *\n * returns 1 if valid or 0 otherwise\n */\n\nint\nxmlValidateNotationUse(xmlValidCtxtPtr ctxt, xmlDocPtr doc,\n                       const xmlChar *notationName) {\n    xmlNotationPtr notaDecl;\n    if ((doc == NULL) || (doc->intSubset == NULL) ||\n        (notationName == NULL)) return(-1);\n\n    notaDecl = xmlGetDtdNotationDesc(doc->intSubset, notationName);\n    if ((notaDecl == NULL) && (doc->extSubset != NULL))\n\tnotaDecl = xmlGetDtdNotationDesc(doc->extSubset, notationName);\n\n    if ((notaDecl == NULL) && (ctxt != NULL)) {\n\txmlErrValidNode(ctxt, (xmlNodePtr) doc, XML_DTD_UNKNOWN_NOTATION,\n\t                \"NOTATION %s is not declared\\n\",\n\t\t        notationName, NULL, NULL);\n\treturn(0);\n    }\n    return(1);\n}\n#endif /* LIBXML_VALID_ENABLED or LIBXML_SCHEMAS_ENABLED */\n\n/**\n * xmlIsMixedElement:\n * @doc:  the document\n * @name:  the element name\n *\n * Search in the DtDs whether an element accept Mixed content (or ANY)\n * basically if it is supposed to accept text childs\n *\n * returns 0 if no, 1 if yes, and -1 if no element description is available\n */\n\nint\nxmlIsMixedElement(xmlDocPtr doc, const xmlChar *name) {\n    xmlElementPtr elemDecl;\n\n    if ((doc == NULL) || (doc->intSubset == NULL)) return(-1);\n\n    elemDecl = xmlGetDtdElementDesc(doc->intSubset, name);\n    if ((elemDecl == NULL) && (doc->extSubset != NULL))\n\telemDecl = xmlGetDtdElementDesc(doc->extSubset, name);\n    if (elemDecl == NULL) return(-1);\n    switch (elemDecl->etype) {\n\tcase XML_ELEMENT_TYPE_UNDEFINED:\n\t    return(-1);\n\tcase XML_ELEMENT_TYPE_ELEMENT:\n\t    return(0);\n        case XML_ELEMENT_TYPE_EMPTY:\n\t    /*\n\t     * return 1 for EMPTY since we want VC error to pop up\n\t     * on <empty>     </empty> for example\n\t     */\n\tcase XML_ELEMENT_TYPE_ANY:\n\tcase XML_ELEMENT_TYPE_MIXED:\n\t    return(1);\n    }\n    return(1);\n}\n\n#ifdef LIBXML_VALID_ENABLED\n\nstatic int\nxmlIsDocNameStartChar(xmlDocPtr doc, int c) {\n    if ((doc == NULL) || (doc->properties & XML_DOC_OLD10) == 0) {\n        /*\n\t * Use the new checks of production [4] [4a] amd [5] of the\n\t * Update 5 of XML-1.0\n\t */\n\tif (((c >= 'a') && (c <= 'z')) ||\n\t    ((c >= 'A') && (c <= 'Z')) ||\n\t    (c == '_') || (c == ':') ||\n\t    ((c >= 0xC0) && (c <= 0xD6)) ||\n\t    ((c >= 0xD8) && (c <= 0xF6)) ||\n\t    ((c >= 0xF8) && (c <= 0x2FF)) ||\n\t    ((c >= 0x370) && (c <= 0x37D)) ||\n\t    ((c >= 0x37F) && (c <= 0x1FFF)) ||\n\t    ((c >= 0x200C) && (c <= 0x200D)) ||\n\t    ((c >= 0x2070) && (c <= 0x218F)) ||\n\t    ((c >= 0x2C00) && (c <= 0x2FEF)) ||\n\t    ((c >= 0x3001) && (c <= 0xD7FF)) ||\n\t    ((c >= 0xF900) && (c <= 0xFDCF)) ||\n\t    ((c >= 0xFDF0) && (c <= 0xFFFD)) ||\n\t    ((c >= 0x10000) && (c <= 0xEFFFF)))\n\t    return(1);\n    } else {\n        if (IS_LETTER(c) || (c == '_') || (c == ':'))\n\t    return(1);\n    }\n    return(0);\n}\n\nstatic int\nxmlIsDocNameChar(xmlDocPtr doc, int c) {\n    if ((doc == NULL) || (doc->properties & XML_DOC_OLD10) == 0) {\n        /*\n\t * Use the new checks of production [4] [4a] amd [5] of the\n\t * Update 5 of XML-1.0\n\t */\n\tif (((c >= 'a') && (c <= 'z')) ||\n\t    ((c >= 'A') && (c <= 'Z')) ||\n\t    ((c >= '0') && (c <= '9')) || /* !start */\n\t    (c == '_') || (c == ':') ||\n\t    (c == '-') || (c == '.') || (c == 0xB7) || /* !start */\n\t    ((c >= 0xC0) && (c <= 0xD6)) ||\n\t    ((c >= 0xD8) && (c <= 0xF6)) ||\n\t    ((c >= 0xF8) && (c <= 0x2FF)) ||\n\t    ((c >= 0x300) && (c <= 0x36F)) || /* !start */\n\t    ((c >= 0x370) && (c <= 0x37D)) ||\n\t    ((c >= 0x37F) && (c <= 0x1FFF)) ||\n\t    ((c >= 0x200C) && (c <= 0x200D)) ||\n\t    ((c >= 0x203F) && (c <= 0x2040)) || /* !start */\n\t    ((c >= 0x2070) && (c <= 0x218F)) ||\n\t    ((c >= 0x2C00) && (c <= 0x2FEF)) ||\n\t    ((c >= 0x3001) && (c <= 0xD7FF)) ||\n\t    ((c >= 0xF900) && (c <= 0xFDCF)) ||\n\t    ((c >= 0xFDF0) && (c <= 0xFFFD)) ||\n\t    ((c >= 0x10000) && (c <= 0xEFFFF)))\n\t     return(1);\n    } else {\n        if ((IS_LETTER(c)) || (IS_DIGIT(c)) ||\n            (c == '.') || (c == '-') ||\n\t    (c == '_') || (c == ':') ||\n\t    (IS_COMBINING(c)) ||\n\t    (IS_EXTENDER(c)))\n\t    return(1);\n    }\n    return(0);\n}\n\n/**\n * xmlValidateNameValue:\n * @doc:  pointer to the document or NULL\n * @value:  an Name value\n *\n * Validate that the given value match Name production\n *\n * returns 1 if valid or 0 otherwise\n */\n\nstatic int\nxmlValidateNameValueInternal(xmlDocPtr doc, const xmlChar *value) {\n    const xmlChar *cur;\n    int val, len;\n\n    if (value == NULL) return(0);\n    cur = value;\n    val = xmlStringCurrentChar(NULL, cur, &len);\n    cur += len;\n    if (!xmlIsDocNameStartChar(doc, val))\n\treturn(0);\n\n    val = xmlStringCurrentChar(NULL, cur, &len);\n    cur += len;\n    while (xmlIsDocNameChar(doc, val)) {\n\tval = xmlStringCurrentChar(NULL, cur, &len);\n\tcur += len;\n    }\n\n    if (val != 0) return(0);\n\n    return(1);\n}\n\n/**\n * xmlValidateNameValue:\n * @value:  an Name value\n *\n * Validate that the given value match Name production\n *\n * returns 1 if valid or 0 otherwise\n */\n\nint\nxmlValidateNameValue(const xmlChar *value) {\n    return(xmlValidateNameValueInternal(NULL, value));\n}\n\n/**\n * xmlValidateNamesValueInternal:\n * @doc:  pointer to the document or NULL\n * @value:  an Names value\n *\n * Validate that the given value match Names production\n *\n * returns 1 if valid or 0 otherwise\n */\n\nstatic int\nxmlValidateNamesValueInternal(xmlDocPtr doc, const xmlChar *value) {\n    const xmlChar *cur;\n    int val, len;\n\n    if (value == NULL) return(0);\n    cur = value;\n    val = xmlStringCurrentChar(NULL, cur, &len);\n    cur += len;\n\n    if (!xmlIsDocNameStartChar(doc, val))\n\treturn(0);\n\n    val = xmlStringCurrentChar(NULL, cur, &len);\n    cur += len;\n    while (xmlIsDocNameChar(doc, val)) {\n\tval = xmlStringCurrentChar(NULL, cur, &len);\n\tcur += len;\n    }\n\n    /* Should not test IS_BLANK(val) here -- see erratum E20*/\n    while (val == 0x20) {\n\twhile (val == 0x20) {\n\t    val = xmlStringCurrentChar(NULL, cur, &len);\n\t    cur += len;\n\t}\n\n\tif (!xmlIsDocNameStartChar(doc, val))\n\t    return(0);\n\n\tval = xmlStringCurrentChar(NULL, cur, &len);\n\tcur += len;\n\n\twhile (xmlIsDocNameChar(doc, val)) {\n\t    val = xmlStringCurrentChar(NULL, cur, &len);\n\t    cur += len;\n\t}\n    }\n\n    if (val != 0) return(0);\n\n    return(1);\n}\n\n/**\n * xmlValidateNamesValue:\n * @value:  an Names value\n *\n * Validate that the given value match Names production\n *\n * returns 1 if valid or 0 otherwise\n */\n\nint\nxmlValidateNamesValue(const xmlChar *value) {\n    return(xmlValidateNamesValueInternal(NULL, value));\n}\n\n/**\n * xmlValidateNmtokenValueInternal:\n * @doc:  pointer to the document or NULL\n * @value:  an Nmtoken value\n *\n * Validate that the given value match Nmtoken production\n *\n * [ VC: Name Token ]\n *\n * returns 1 if valid or 0 otherwise\n */\n\nstatic int\nxmlValidateNmtokenValueInternal(xmlDocPtr doc, const xmlChar *value) {\n    const xmlChar *cur;\n    int val, len;\n\n    if (value == NULL) return(0);\n    cur = value;\n    val = xmlStringCurrentChar(NULL, cur, &len);\n    cur += len;\n\n    if (!xmlIsDocNameChar(doc, val))\n\treturn(0);\n\n    val = xmlStringCurrentChar(NULL, cur, &len);\n    cur += len;\n    while (xmlIsDocNameChar(doc, val)) {\n\tval = xmlStringCurrentChar(NULL, cur, &len);\n\tcur += len;\n    }\n\n    if (val != 0) return(0);\n\n    return(1);\n}\n\n/**\n * xmlValidateNmtokenValue:\n * @value:  an Nmtoken value\n *\n * Validate that the given value match Nmtoken production\n *\n * [ VC: Name Token ]\n *\n * returns 1 if valid or 0 otherwise\n */\n\nint\nxmlValidateNmtokenValue(const xmlChar *value) {\n    return(xmlValidateNmtokenValueInternal(NULL, value));\n}\n\n/**\n * xmlValidateNmtokensValueInternal:\n * @doc:  pointer to the document or NULL\n * @value:  an Nmtokens value\n *\n * Validate that the given value match Nmtokens production\n *\n * [ VC: Name Token ]\n *\n * returns 1 if valid or 0 otherwise\n */\n\nstatic int\nxmlValidateNmtokensValueInternal(xmlDocPtr doc, const xmlChar *value) {\n    const xmlChar *cur;\n    int val, len;\n\n    if (value == NULL) return(0);\n    cur = value;\n    val = xmlStringCurrentChar(NULL, cur, &len);\n    cur += len;\n\n    while (IS_BLANK(val)) {\n\tval = xmlStringCurrentChar(NULL, cur, &len);\n\tcur += len;\n    }\n\n    if (!xmlIsDocNameChar(doc, val))\n\treturn(0);\n\n    while (xmlIsDocNameChar(doc, val)) {\n\tval = xmlStringCurrentChar(NULL, cur, &len);\n\tcur += len;\n    }\n\n    /* Should not test IS_BLANK(val) here -- see erratum E20*/\n    while (val == 0x20) {\n\twhile (val == 0x20) {\n\t    val = xmlStringCurrentChar(NULL, cur, &len);\n\t    cur += len;\n\t}\n\tif (val == 0) return(1);\n\n\tif (!xmlIsDocNameChar(doc, val))\n\t    return(0);\n\n\tval = xmlStringCurrentChar(NULL, cur, &len);\n\tcur += len;\n\n\twhile (xmlIsDocNameChar(doc, val)) {\n\t    val = xmlStringCurrentChar(NULL, cur, &len);\n\t    cur += len;\n\t}\n    }\n\n    if (val != 0) return(0);\n\n    return(1);\n}\n\n/**\n * xmlValidateNmtokensValue:\n * @value:  an Nmtokens value\n *\n * Validate that the given value match Nmtokens production\n *\n * [ VC: Name Token ]\n *\n * returns 1 if valid or 0 otherwise\n */\n\nint\nxmlValidateNmtokensValue(const xmlChar *value) {\n    return(xmlValidateNmtokensValueInternal(NULL, value));\n}\n\n/**\n * xmlValidateNotationDecl:\n * @ctxt:  the validation context\n * @doc:  a document instance\n * @nota:  a notation definition\n *\n * Try to validate a single notation definition\n * basically it does the following checks as described by the\n * XML-1.0 recommendation:\n *  - it seems that no validity constraint exists on notation declarations\n * But this function get called anyway ...\n *\n * returns 1 if valid or 0 otherwise\n */\n\nint\nxmlValidateNotationDecl(xmlValidCtxtPtr ctxt ATTRIBUTE_UNUSED, xmlDocPtr doc ATTRIBUTE_UNUSED,\n                         xmlNotationPtr nota ATTRIBUTE_UNUSED) {\n    int ret = 1;\n\n    return(ret);\n}\n\n/**\n * xmlValidateAttributeValueInternal:\n * @doc: the document\n * @type:  an attribute type\n * @value:  an attribute value\n *\n * Validate that the given attribute value match  the proper production\n *\n * returns 1 if valid or 0 otherwise\n */\n\nstatic int\nxmlValidateAttributeValueInternal(xmlDocPtr doc, xmlAttributeType type,\n                                  const xmlChar *value) {\n    switch (type) {\n\tcase XML_ATTRIBUTE_ENTITIES:\n\tcase XML_ATTRIBUTE_IDREFS:\n\t    return(xmlValidateNamesValueInternal(doc, value));\n\tcase XML_ATTRIBUTE_ENTITY:\n\tcase XML_ATTRIBUTE_IDREF:\n\tcase XML_ATTRIBUTE_ID:\n\tcase XML_ATTRIBUTE_NOTATION:\n\t    return(xmlValidateNameValueInternal(doc, value));\n\tcase XML_ATTRIBUTE_NMTOKENS:\n\tcase XML_ATTRIBUTE_ENUMERATION:\n\t    return(xmlValidateNmtokensValueInternal(doc, value));\n\tcase XML_ATTRIBUTE_NMTOKEN:\n\t    return(xmlValidateNmtokenValueInternal(doc, value));\n        case XML_ATTRIBUTE_CDATA:\n\t    break;\n    }\n    return(1);\n}\n\n/**\n * xmlValidateAttributeValue:\n * @type:  an attribute type\n * @value:  an attribute value\n *\n * Validate that the given attribute value match  the proper production\n *\n * [ VC: ID ]\n * Values of type ID must match the Name production....\n *\n * [ VC: IDREF ]\n * Values of type IDREF must match the Name production, and values\n * of type IDREFS must match Names ...\n *\n * [ VC: Entity Name ]\n * Values of type ENTITY must match the Name production, values\n * of type ENTITIES must match Names ...\n *\n * [ VC: Name Token ]\n * Values of type NMTOKEN must match the Nmtoken production; values\n * of type NMTOKENS must match Nmtokens.\n *\n * returns 1 if valid or 0 otherwise\n */\nint\nxmlValidateAttributeValue(xmlAttributeType type, const xmlChar *value) {\n    return(xmlValidateAttributeValueInternal(NULL, type, value));\n}\n\n/**\n * xmlValidateAttributeValue2:\n * @ctxt:  the validation context\n * @doc:  the document\n * @name:  the attribute name (used for error reporting only)\n * @type:  the attribute type\n * @value:  the attribute value\n *\n * Validate that the given attribute value match a given type.\n * This typically cannot be done before having finished parsing\n * the subsets.\n *\n * [ VC: IDREF ]\n * Values of type IDREF must match one of the declared IDs\n * Values of type IDREFS must match a sequence of the declared IDs\n * each Name must match the value of an ID attribute on some element\n * in the XML document; i.e. IDREF values must match the value of\n * some ID attribute\n *\n * [ VC: Entity Name ]\n * Values of type ENTITY must match one declared entity\n * Values of type ENTITIES must match a sequence of declared entities\n *\n * [ VC: Notation Attributes ]\n * all notation names in the declaration must be declared.\n *\n * returns 1 if valid or 0 otherwise\n */\n\nstatic int\nxmlValidateAttributeValue2(xmlValidCtxtPtr ctxt, xmlDocPtr doc,\n      const xmlChar *name, xmlAttributeType type, const xmlChar *value) {\n    int ret = 1;\n    switch (type) {\n\tcase XML_ATTRIBUTE_IDREFS:\n\tcase XML_ATTRIBUTE_IDREF:\n\tcase XML_ATTRIBUTE_ID:\n\tcase XML_ATTRIBUTE_NMTOKENS:\n\tcase XML_ATTRIBUTE_ENUMERATION:\n\tcase XML_ATTRIBUTE_NMTOKEN:\n        case XML_ATTRIBUTE_CDATA:\n\t    break;\n\tcase XML_ATTRIBUTE_ENTITY: {\n\t    xmlEntityPtr ent;\n\n\t    ent = xmlGetDocEntity(doc, value);\n\t    /* yeah it's a bit messy... */\n\t    if ((ent == NULL) && (doc->standalone == 1)) {\n\t\tdoc->standalone = 0;\n\t\tent = xmlGetDocEntity(doc, value);\n\t    }\n\t    if (ent == NULL) {\n\t\txmlErrValidNode(ctxt, (xmlNodePtr) doc,\n\t\t\t\tXML_DTD_UNKNOWN_ENTITY,\n   \"ENTITY attribute %s reference an unknown entity \\\"%s\\\"\\n\",\n\t\t       name, value, NULL);\n\t\tret = 0;\n\t    } else if (ent->etype != XML_EXTERNAL_GENERAL_UNPARSED_ENTITY) {\n\t\txmlErrValidNode(ctxt, (xmlNodePtr) doc,\n\t\t\t\tXML_DTD_ENTITY_TYPE,\n   \"ENTITY attribute %s reference an entity \\\"%s\\\" of wrong type\\n\",\n\t\t       name, value, NULL);\n\t\tret = 0;\n\t    }\n\t    break;\n        }\n\tcase XML_ATTRIBUTE_ENTITIES: {\n\t    xmlChar *dup, *nam = NULL, *cur, save;\n\t    xmlEntityPtr ent;\n\n\t    dup = xmlStrdup(value);\n\t    if (dup == NULL)\n\t\treturn(0);\n\t    cur = dup;\n\t    while (*cur != 0) {\n\t\tnam = cur;\n\t\twhile ((*cur != 0) && (!IS_BLANK_CH(*cur))) cur++;\n\t\tsave = *cur;\n\t\t*cur = 0;\n\t\tent = xmlGetDocEntity(doc, nam);\n\t\tif (ent == NULL) {\n\t\t    xmlErrValidNode(ctxt, (xmlNodePtr) doc,\n\t\t\t\t    XML_DTD_UNKNOWN_ENTITY,\n       \"ENTITIES attribute %s reference an unknown entity \\\"%s\\\"\\n\",\n\t\t\t   name, nam, NULL);\n\t\t    ret = 0;\n\t\t} else if (ent->etype != XML_EXTERNAL_GENERAL_UNPARSED_ENTITY) {\n\t\t    xmlErrValidNode(ctxt, (xmlNodePtr) doc,\n\t\t\t\t    XML_DTD_ENTITY_TYPE,\n       \"ENTITIES attribute %s reference an entity \\\"%s\\\" of wrong type\\n\",\n\t\t\t   name, nam, NULL);\n\t\t    ret = 0;\n\t\t}\n\t\tif (save == 0)\n\t\t    break;\n\t\t*cur = save;\n\t\twhile (IS_BLANK_CH(*cur)) cur++;\n\t    }\n\t    xmlFree(dup);\n\t    break;\n\t}\n\tcase XML_ATTRIBUTE_NOTATION: {\n\t    xmlNotationPtr nota;\n\n\t    nota = xmlGetDtdNotationDesc(doc->intSubset, value);\n\t    if ((nota == NULL) && (doc->extSubset != NULL))\n\t\tnota = xmlGetDtdNotationDesc(doc->extSubset, value);\n\n\t    if (nota == NULL) {\n\t\txmlErrValidNode(ctxt, (xmlNodePtr) doc,\n\t\t                XML_DTD_UNKNOWN_NOTATION,\n       \"NOTATION attribute %s reference an unknown notation \\\"%s\\\"\\n\",\n\t\t       name, value, NULL);\n\t\tret = 0;\n\t    }\n\t    break;\n        }\n    }\n    return(ret);\n}\n\n/**\n * xmlValidCtxtNormalizeAttributeValue:\n * @ctxt: the validation context\n * @doc:  the document\n * @elem:  the parent\n * @name:  the attribute name\n * @value:  the attribute value\n * @ctxt:  the validation context or NULL\n *\n * Does the validation related extra step of the normalization of attribute\n * values:\n *\n * If the declared value is not CDATA, then the XML processor must further\n * process the normalized attribute value by discarding any leading and\n * trailing space (#x20) characters, and by replacing sequences of space\n * (#x20) characters by single space (#x20) character.\n *\n * Also  check VC: Standalone Document Declaration in P32, and update\n *  ctxt->valid accordingly\n *\n * returns a new normalized string if normalization is needed, NULL otherwise\n *      the caller must free the returned value.\n */\n\nxmlChar *\nxmlValidCtxtNormalizeAttributeValue(xmlValidCtxtPtr ctxt, xmlDocPtr doc,\n\t     xmlNodePtr elem, const xmlChar *name, const xmlChar *value) {\n    xmlChar *ret;\n    xmlAttributePtr attrDecl = NULL;\n    int extsubset = 0;\n\n    if (doc == NULL) return(NULL);\n    if (elem == NULL) return(NULL);\n    if (name == NULL) return(NULL);\n    if (value == NULL) return(NULL);\n\n    if ((elem->ns != NULL) && (elem->ns->prefix != NULL)) {\n\txmlChar fn[50];\n\txmlChar *fullname;\n\n\tfullname = xmlBuildQName(elem->name, elem->ns->prefix, fn, 50);\n\tif (fullname == NULL)\n\t    return(NULL);\n\tattrDecl = xmlGetDtdAttrDesc(doc->intSubset, fullname, name);\n\tif ((attrDecl == NULL) && (doc->extSubset != NULL)) {\n\t    attrDecl = xmlGetDtdAttrDesc(doc->extSubset, fullname, name);\n\t    if (attrDecl != NULL)\n\t\textsubset = 1;\n\t}\n\tif ((fullname != fn) && (fullname != elem->name))\n\t    xmlFree(fullname);\n    }\n    if ((attrDecl == NULL) && (doc->intSubset != NULL))\n\tattrDecl = xmlGetDtdAttrDesc(doc->intSubset, elem->name, name);\n    if ((attrDecl == NULL) && (doc->extSubset != NULL)) {\n\tattrDecl = xmlGetDtdAttrDesc(doc->extSubset, elem->name, name);\n\tif (attrDecl != NULL)\n\t    extsubset = 1;\n    }\n\n    if (attrDecl == NULL)\n\treturn(NULL);\n    if (attrDecl->atype == XML_ATTRIBUTE_CDATA)\n\treturn(NULL);\n\n    ret = xmlStrdup(value);\n    if (ret == NULL)\n\treturn(NULL);\n    xmlValidNormalizeString(ret);\n    if ((doc->standalone) && (extsubset == 1) && (!xmlStrEqual(value, ret))) {\n\txmlErrValidNode(ctxt, elem, XML_DTD_NOT_STANDALONE,\n\"standalone: %s on %s value had to be normalized based on external subset declaration\\n\",\n\t       name, elem->name, NULL);\n\tctxt->valid = 0;\n    }\n    return(ret);\n}\n\n/**\n * xmlValidNormalizeAttributeValue:\n * @doc:  the document\n * @elem:  the parent\n * @name:  the attribute name\n * @value:  the attribute value\n *\n * Does the validation related extra step of the normalization of attribute\n * values:\n *\n * If the declared value is not CDATA, then the XML processor must further\n * process the normalized attribute value by discarding any leading and\n * trailing space (#x20) characters, and by replacing sequences of space\n * (#x20) characters by single space (#x20) character.\n *\n * Returns a new normalized string if normalization is needed, NULL otherwise\n *      the caller must free the returned value.\n */\n\nxmlChar *\nxmlValidNormalizeAttributeValue(xmlDocPtr doc, xmlNodePtr elem,\n\t\t\t        const xmlChar *name, const xmlChar *value) {\n    xmlChar *ret;\n    xmlAttributePtr attrDecl = NULL;\n\n    if (doc == NULL) return(NULL);\n    if (elem == NULL) return(NULL);\n    if (name == NULL) return(NULL);\n    if (value == NULL) return(NULL);\n\n    if ((elem->ns != NULL) && (elem->ns->prefix != NULL)) {\n\txmlChar fn[50];\n\txmlChar *fullname;\n\n\tfullname = xmlBuildQName(elem->name, elem->ns->prefix, fn, 50);\n\tif (fullname == NULL)\n\t    return(NULL);\n\tif ((fullname != fn) && (fullname != elem->name))\n\t    xmlFree(fullname);\n    }\n    attrDecl = xmlGetDtdAttrDesc(doc->intSubset, elem->name, name);\n    if ((attrDecl == NULL) && (doc->extSubset != NULL))\n\tattrDecl = xmlGetDtdAttrDesc(doc->extSubset, elem->name, name);\n\n    if (attrDecl == NULL)\n\treturn(NULL);\n    if (attrDecl->atype == XML_ATTRIBUTE_CDATA)\n\treturn(NULL);\n\n    ret = xmlStrdup(value);\n    if (ret == NULL)\n\treturn(NULL);\n    xmlValidNormalizeString(ret);\n    return(ret);\n}\n\nstatic void\nxmlValidateAttributeIdCallback(void *payload, void *data,\n\t                       const xmlChar *name ATTRIBUTE_UNUSED) {\n    xmlAttributePtr attr = (xmlAttributePtr) payload;\n    int *count = (int *) data;\n    if (attr->atype == XML_ATTRIBUTE_ID) (*count)++;\n}\n\n/**\n * xmlValidateAttributeDecl:\n * @ctxt:  the validation context\n * @doc:  a document instance\n * @attr:  an attribute definition\n *\n * Try to validate a single attribute definition\n * basically it does the following checks as described by the\n * XML-1.0 recommendation:\n *  - [ VC: Attribute Default Legal ]\n *  - [ VC: Enumeration ]\n *  - [ VC: ID Attribute Default ]\n *\n * The ID/IDREF uniqueness and matching are done separately\n *\n * returns 1 if valid or 0 otherwise\n */\n\nint\nxmlValidateAttributeDecl(xmlValidCtxtPtr ctxt, xmlDocPtr doc,\n                         xmlAttributePtr attr) {\n    int ret = 1;\n    int val;\n    CHECK_DTD;\n    if(attr == NULL) return(1);\n\n    /* Attribute Default Legal */\n    /* Enumeration */\n    if (attr->defaultValue != NULL) {\n\tval = xmlValidateAttributeValueInternal(doc, attr->atype,\n\t                                        attr->defaultValue);\n\tif (val == 0) {\n\t    xmlErrValidNode(ctxt, (xmlNodePtr) attr, XML_DTD_ATTRIBUTE_DEFAULT,\n\t       \"Syntax of default value for attribute %s of %s is not valid\\n\",\n\t           attr->name, attr->elem, NULL);\n\t}\n        ret &= val;\n    }\n\n    /* ID Attribute Default */\n    if ((attr->atype == XML_ATTRIBUTE_ID)&&\n        (attr->def != XML_ATTRIBUTE_IMPLIED) &&\n\t(attr->def != XML_ATTRIBUTE_REQUIRED)) {\n\txmlErrValidNode(ctxt, (xmlNodePtr) attr, XML_DTD_ID_FIXED,\n          \"ID attribute %s of %s is not valid must be #IMPLIED or #REQUIRED\\n\",\n\t       attr->name, attr->elem, NULL);\n\tret = 0;\n    }\n\n    /* One ID per Element Type */\n    if (attr->atype == XML_ATTRIBUTE_ID) {\n        int nbId;\n\n\t/* the trick is that we parse DtD as their own internal subset */\n        xmlElementPtr elem = xmlGetDtdElementDesc(doc->intSubset,\n\t                                          attr->elem);\n\tif (elem != NULL) {\n\t    nbId = xmlScanIDAttributeDecl(NULL, elem, 0);\n\t} else {\n\t    xmlAttributeTablePtr table;\n\n\t    /*\n\t     * The attribute may be declared in the internal subset and the\n\t     * element in the external subset.\n\t     */\n\t    nbId = 0;\n\t    if (doc->intSubset != NULL) {\n\t\ttable = (xmlAttributeTablePtr) doc->intSubset->attributes;\n\t\txmlHashScan3(table, NULL, NULL, attr->elem,\n\t\t\t     xmlValidateAttributeIdCallback, &nbId);\n\t    }\n\t}\n\tif (nbId > 1) {\n\n\t    xmlErrValidNodeNr(ctxt, (xmlNodePtr) attr, XML_DTD_ID_SUBSET,\n       \"Element %s has %d ID attribute defined in the internal subset : %s\\n\",\n\t\t   attr->elem, nbId, attr->name);\n\t} else if (doc->extSubset != NULL) {\n\t    int extId = 0;\n\t    elem = xmlGetDtdElementDesc(doc->extSubset, attr->elem);\n\t    if (elem != NULL) {\n\t\textId = xmlScanIDAttributeDecl(NULL, elem, 0);\n\t    }\n\t    if (extId > 1) {\n\t\txmlErrValidNodeNr(ctxt, (xmlNodePtr) attr, XML_DTD_ID_SUBSET,\n       \"Element %s has %d ID attribute defined in the external subset : %s\\n\",\n\t\t       attr->elem, extId, attr->name);\n\t    } else if (extId + nbId > 1) {\n\t\txmlErrValidNode(ctxt, (xmlNodePtr) attr, XML_DTD_ID_SUBSET,\n\"Element %s has ID attributes defined in the internal and external subset : %s\\n\",\n\t\t       attr->elem, attr->name, NULL);\n\t    }\n\t}\n    }\n\n    /* Validity Constraint: Enumeration */\n    if ((attr->defaultValue != NULL) && (attr->tree != NULL)) {\n        xmlEnumerationPtr tree = attr->tree;\n\twhile (tree != NULL) {\n\t    if (xmlStrEqual(tree->name, attr->defaultValue)) break;\n\t    tree = tree->next;\n\t}\n\tif (tree == NULL) {\n\t    xmlErrValidNode(ctxt, (xmlNodePtr) attr, XML_DTD_ATTRIBUTE_VALUE,\n\"Default value \\\"%s\\\" for attribute %s of %s is not among the enumerated set\\n\",\n\t\t   attr->defaultValue, attr->name, attr->elem);\n\t    ret = 0;\n\t}\n    }\n\n    return(ret);\n}\n\n/**\n * xmlValidateElementDecl:\n * @ctxt:  the validation context\n * @doc:  a document instance\n * @elem:  an element definition\n *\n * Try to validate a single element definition\n * basically it does the following checks as described by the\n * XML-1.0 recommendation:\n *  - [ VC: One ID per Element Type ]\n *  - [ VC: No Duplicate Types ]\n *  - [ VC: Unique Element Type Declaration ]\n *\n * returns 1 if valid or 0 otherwise\n */\n\nint\nxmlValidateElementDecl(xmlValidCtxtPtr ctxt, xmlDocPtr doc,\n                       xmlElementPtr elem) {\n    int ret = 1;\n    xmlElementPtr tst;\n\n    CHECK_DTD;\n\n    if (elem == NULL) return(1);\n\n#if 0\n#ifdef LIBXML_REGEXP_ENABLED\n    /* Build the regexp associated to the content model */\n    ret = xmlValidBuildContentModel(ctxt, elem);\n#endif\n#endif\n\n    /* No Duplicate Types */\n    if (elem->etype == XML_ELEMENT_TYPE_MIXED) {\n\txmlElementContentPtr cur, next;\n        const xmlChar *name;\n\n\tcur = elem->content;\n\twhile (cur != NULL) {\n\t    if (cur->type != XML_ELEMENT_CONTENT_OR) break;\n\t    if (cur->c1 == NULL) break;\n\t    if (cur->c1->type == XML_ELEMENT_CONTENT_ELEMENT) {\n\t\tname = cur->c1->name;\n\t\tnext = cur->c2;\n\t\twhile (next != NULL) {\n\t\t    if (next->type == XML_ELEMENT_CONTENT_ELEMENT) {\n\t\t        if ((xmlStrEqual(next->name, name)) &&\n\t\t\t    (xmlStrEqual(next->prefix, cur->c1->prefix))) {\n\t\t\t    if (cur->c1->prefix == NULL) {\n\t\t\t\txmlErrValidNode(ctxt, (xmlNodePtr) elem, XML_DTD_CONTENT_ERROR,\n\t\t   \"Definition of %s has duplicate references of %s\\n\",\n\t\t\t\t       elem->name, name, NULL);\n\t\t\t    } else {\n\t\t\t\txmlErrValidNode(ctxt, (xmlNodePtr) elem, XML_DTD_CONTENT_ERROR,\n\t\t   \"Definition of %s has duplicate references of %s:%s\\n\",\n\t\t\t\t       elem->name, cur->c1->prefix, name);\n\t\t\t    }\n\t\t\t    ret = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t    }\n\t\t    if (next->c1 == NULL) break;\n\t\t    if (next->c1->type != XML_ELEMENT_CONTENT_ELEMENT) break;\n\t\t    if ((xmlStrEqual(next->c1->name, name)) &&\n\t\t        (xmlStrEqual(next->c1->prefix, cur->c1->prefix))) {\n\t\t\tif (cur->c1->prefix == NULL) {\n\t\t\t    xmlErrValidNode(ctxt, (xmlNodePtr) elem, XML_DTD_CONTENT_ERROR,\n\t       \"Definition of %s has duplicate references to %s\\n\",\n\t\t\t\t   elem->name, name, NULL);\n\t\t\t} else {\n\t\t\t    xmlErrValidNode(ctxt, (xmlNodePtr) elem, XML_DTD_CONTENT_ERROR,\n\t       \"Definition of %s has duplicate references to %s:%s\\n\",\n\t\t\t\t   elem->name, cur->c1->prefix, name);\n\t\t\t}\n\t\t\tret = 0;\n\t\t    }\n\t\t    next = next->c2;\n\t\t}\n\t    }\n\t    cur = cur->c2;\n\t}\n    }\n\n    /* VC: Unique Element Type Declaration */\n    tst = xmlGetDtdElementDesc(doc->intSubset, elem->name);\n    if ((tst != NULL ) && (tst != elem) &&\n\t((tst->prefix == elem->prefix) ||\n\t (xmlStrEqual(tst->prefix, elem->prefix))) &&\n\t(tst->etype != XML_ELEMENT_TYPE_UNDEFINED)) {\n\txmlErrValidNode(ctxt, (xmlNodePtr) elem, XML_DTD_ELEM_REDEFINED,\n\t                \"Redefinition of element %s\\n\",\n\t\t       elem->name, NULL, NULL);\n\tret = 0;\n    }\n    tst = xmlGetDtdElementDesc(doc->extSubset, elem->name);\n    if ((tst != NULL ) && (tst != elem) &&\n\t((tst->prefix == elem->prefix) ||\n\t (xmlStrEqual(tst->prefix, elem->prefix))) &&\n\t(tst->etype != XML_ELEMENT_TYPE_UNDEFINED)) {\n\txmlErrValidNode(ctxt, (xmlNodePtr) elem, XML_DTD_ELEM_REDEFINED,\n\t                \"Redefinition of element %s\\n\",\n\t\t       elem->name, NULL, NULL);\n\tret = 0;\n    }\n    /* One ID per Element Type\n     * already done when registering the attribute\n    if (xmlScanIDAttributeDecl(ctxt, elem) > 1) {\n\tret = 0;\n    } */\n    return(ret);\n}\n\n/**\n * xmlValidateOneAttribute:\n * @ctxt:  the validation context\n * @doc:  a document instance\n * @elem:  an element instance\n * @attr:  an attribute instance\n * @value:  the attribute value (without entities processing)\n *\n * Try to validate a single attribute for an element\n * basically it does the following checks as described by the\n * XML-1.0 recommendation:\n *  - [ VC: Attribute Value Type ]\n *  - [ VC: Fixed Attribute Default ]\n *  - [ VC: Entity Name ]\n *  - [ VC: Name Token ]\n *  - [ VC: ID ]\n *  - [ VC: IDREF ]\n *  - [ VC: Entity Name ]\n *  - [ VC: Notation Attributes ]\n *\n * The ID/IDREF uniqueness and matching are done separately\n *\n * returns 1 if valid or 0 otherwise\n */\n\nint\nxmlValidateOneAttribute(xmlValidCtxtPtr ctxt, xmlDocPtr doc,\n                        xmlNodePtr elem, xmlAttrPtr attr, const xmlChar *value)\n{\n    xmlAttributePtr attrDecl =  NULL;\n    int val;\n    int ret = 1;\n\n    CHECK_DTD;\n    if ((elem == NULL) || (elem->name == NULL)) return(0);\n    if ((attr == NULL) || (attr->name == NULL)) return(0);\n\n    if ((elem->ns != NULL) && (elem->ns->prefix != NULL)) {\n\txmlChar fn[50];\n\txmlChar *fullname;\n\n\tfullname = xmlBuildQName(elem->name, elem->ns->prefix, fn, 50);\n\tif (fullname == NULL)\n\t    return(0);\n\tif (attr->ns != NULL) {\n\t    attrDecl = xmlGetDtdQAttrDesc(doc->intSubset, fullname,\n\t\t                          attr->name, attr->ns->prefix);\n\t    if ((attrDecl == NULL) && (doc->extSubset != NULL))\n\t\tattrDecl = xmlGetDtdQAttrDesc(doc->extSubset, fullname,\n\t\t\t\t\t      attr->name, attr->ns->prefix);\n\t} else {\n\t    attrDecl = xmlGetDtdAttrDesc(doc->intSubset, fullname, attr->name);\n\t    if ((attrDecl == NULL) && (doc->extSubset != NULL))\n\t\tattrDecl = xmlGetDtdAttrDesc(doc->extSubset,\n\t\t\t\t\t     fullname, attr->name);\n\t}\n\tif ((fullname != fn) && (fullname != elem->name))\n\t    xmlFree(fullname);\n    }\n    if (attrDecl == NULL) {\n\tif (attr->ns != NULL) {\n\t    attrDecl = xmlGetDtdQAttrDesc(doc->intSubset, elem->name,\n\t\t                          attr->name, attr->ns->prefix);\n\t    if ((attrDecl == NULL) && (doc->extSubset != NULL))\n\t\tattrDecl = xmlGetDtdQAttrDesc(doc->extSubset, elem->name,\n\t\t\t\t\t      attr->name, attr->ns->prefix);\n\t} else {\n\t    attrDecl = xmlGetDtdAttrDesc(doc->intSubset,\n\t\t                         elem->name, attr->name);\n\t    if ((attrDecl == NULL) && (doc->extSubset != NULL))\n\t\tattrDecl = xmlGetDtdAttrDesc(doc->extSubset,\n\t\t\t\t\t     elem->name, attr->name);\n\t}\n    }\n\n\n    /* Validity Constraint: Attribute Value Type */\n    if (attrDecl == NULL) {\n\txmlErrValidNode(ctxt, elem, XML_DTD_UNKNOWN_ATTRIBUTE,\n\t       \"No declaration for attribute %s of element %s\\n\",\n\t       attr->name, elem->name, NULL);\n\treturn(0);\n    }\n    attr->atype = attrDecl->atype;\n\n    val = xmlValidateAttributeValueInternal(doc, attrDecl->atype, value);\n    if (val == 0) {\n\t    xmlErrValidNode(ctxt, elem, XML_DTD_ATTRIBUTE_VALUE,\n\t   \"Syntax of value for attribute %s of %s is not valid\\n\",\n\t       attr->name, elem->name, NULL);\n        ret = 0;\n    }\n\n    /* Validity constraint: Fixed Attribute Default */\n    if (attrDecl->def == XML_ATTRIBUTE_FIXED) {\n\tif (!xmlStrEqual(value, attrDecl->defaultValue)) {\n\t    xmlErrValidNode(ctxt, elem, XML_DTD_ATTRIBUTE_DEFAULT,\n\t   \"Value for attribute %s of %s is different from default \\\"%s\\\"\\n\",\n\t\t   attr->name, elem->name, attrDecl->defaultValue);\n\t    ret = 0;\n\t}\n    }\n\n    /* Validity Constraint: ID uniqueness */\n    if (attrDecl->atype == XML_ATTRIBUTE_ID) {\n        if (xmlAddID(ctxt, doc, value, attr) == NULL)\n\t    ret = 0;\n    }\n\n    if ((attrDecl->atype == XML_ATTRIBUTE_IDREF) ||\n\t(attrDecl->atype == XML_ATTRIBUTE_IDREFS)) {\n        if (xmlAddRef(ctxt, doc, value, attr) == NULL)\n\t    ret = 0;\n    }\n\n    /* Validity Constraint: Notation Attributes */\n    if (attrDecl->atype == XML_ATTRIBUTE_NOTATION) {\n        xmlEnumerationPtr tree = attrDecl->tree;\n        xmlNotationPtr nota;\n\n        /* First check that the given NOTATION was declared */\n\tnota = xmlGetDtdNotationDesc(doc->intSubset, value);\n\tif (nota == NULL)\n\t    nota = xmlGetDtdNotationDesc(doc->extSubset, value);\n\n\tif (nota == NULL) {\n\t    xmlErrValidNode(ctxt, elem, XML_DTD_UNKNOWN_NOTATION,\n       \"Value \\\"%s\\\" for attribute %s of %s is not a declared Notation\\n\",\n\t\t   value, attr->name, elem->name);\n\t    ret = 0;\n        }\n\n\t/* Second, verify that it's among the list */\n\twhile (tree != NULL) {\n\t    if (xmlStrEqual(tree->name, value)) break;\n\t    tree = tree->next;\n\t}\n\tif (tree == NULL) {\n\t    xmlErrValidNode(ctxt, elem, XML_DTD_NOTATION_VALUE,\n\"Value \\\"%s\\\" for attribute %s of %s is not among the enumerated notations\\n\",\n\t\t   value, attr->name, elem->name);\n\t    ret = 0;\n\t}\n    }\n\n    /* Validity Constraint: Enumeration */\n    if (attrDecl->atype == XML_ATTRIBUTE_ENUMERATION) {\n        xmlEnumerationPtr tree = attrDecl->tree;\n\twhile (tree != NULL) {\n\t    if (xmlStrEqual(tree->name, value)) break;\n\t    tree = tree->next;\n\t}\n\tif (tree == NULL) {\n\t    xmlErrValidNode(ctxt, elem, XML_DTD_ATTRIBUTE_VALUE,\n       \"Value \\\"%s\\\" for attribute %s of %s is not among the enumerated set\\n\",\n\t\t   value, attr->name, elem->name);\n\t    ret = 0;\n\t}\n    }\n\n    /* Fixed Attribute Default */\n    if ((attrDecl->def == XML_ATTRIBUTE_FIXED) &&\n        (!xmlStrEqual(attrDecl->defaultValue, value))) {\n\txmlErrValidNode(ctxt, elem, XML_DTD_ATTRIBUTE_VALUE,\n\t   \"Value for attribute %s of %s must be \\\"%s\\\"\\n\",\n\t       attr->name, elem->name, attrDecl->defaultValue);\n        ret = 0;\n    }\n\n    /* Extra check for the attribute value */\n    ret &= xmlValidateAttributeValue2(ctxt, doc, attr->name,\n\t\t\t\t      attrDecl->atype, value);\n\n    return(ret);\n}\n\n/**\n * xmlValidateOneNamespace:\n * @ctxt:  the validation context\n * @doc:  a document instance\n * @elem:  an element instance\n * @prefix:  the namespace prefix\n * @ns:  an namespace declaration instance\n * @value:  the attribute value (without entities processing)\n *\n * Try to validate a single namespace declaration for an element\n * basically it does the following checks as described by the\n * XML-1.0 recommendation:\n *  - [ VC: Attribute Value Type ]\n *  - [ VC: Fixed Attribute Default ]\n *  - [ VC: Entity Name ]\n *  - [ VC: Name Token ]\n *  - [ VC: ID ]\n *  - [ VC: IDREF ]\n *  - [ VC: Entity Name ]\n *  - [ VC: Notation Attributes ]\n *\n * The ID/IDREF uniqueness and matching are done separately\n *\n * returns 1 if valid or 0 otherwise\n */\n\nint\nxmlValidateOneNamespace(xmlValidCtxtPtr ctxt, xmlDocPtr doc,\nxmlNodePtr elem, const xmlChar *prefix, xmlNsPtr ns, const xmlChar *value) {\n    /* xmlElementPtr elemDecl; */\n    xmlAttributePtr attrDecl =  NULL;\n    int val;\n    int ret = 1;\n\n    CHECK_DTD;\n    if ((elem == NULL) || (elem->name == NULL)) return(0);\n    if ((ns == NULL) || (ns->href == NULL)) return(0);\n\n    if (prefix != NULL) {\n\txmlChar fn[50];\n\txmlChar *fullname;\n\n\tfullname = xmlBuildQName(elem->name, prefix, fn, 50);\n\tif (fullname == NULL) {\n\t    xmlVErrMemory(ctxt, \"Validating namespace\");\n\t    return(0);\n\t}\n\tif (ns->prefix != NULL) {\n\t    attrDecl = xmlGetDtdQAttrDesc(doc->intSubset, fullname,\n\t\t                          ns->prefix, BAD_CAST \"xmlns\");\n\t    if ((attrDecl == NULL) && (doc->extSubset != NULL))\n\t\tattrDecl = xmlGetDtdQAttrDesc(doc->extSubset, fullname,\n\t\t\t\t\t  ns->prefix, BAD_CAST \"xmlns\");\n\t} else {\n\t    attrDecl = xmlGetDtdAttrDesc(doc->intSubset, fullname,\n\t\t                         BAD_CAST \"xmlns\");\n\t    if ((attrDecl == NULL) && (doc->extSubset != NULL))\n\t\tattrDecl = xmlGetDtdAttrDesc(doc->extSubset, fullname,\n\t\t\t                 BAD_CAST \"xmlns\");\n\t}\n\tif ((fullname != fn) && (fullname != elem->name))\n\t    xmlFree(fullname);\n    }\n    if (attrDecl == NULL) {\n\tif (ns->prefix != NULL) {\n\t    attrDecl = xmlGetDtdQAttrDesc(doc->intSubset, elem->name,\n\t\t                          ns->prefix, BAD_CAST \"xmlns\");\n\t    if ((attrDecl == NULL) && (doc->extSubset != NULL))\n\t\tattrDecl = xmlGetDtdQAttrDesc(doc->extSubset, elem->name,\n\t\t\t\t\t      ns->prefix, BAD_CAST \"xmlns\");\n\t} else {\n\t    attrDecl = xmlGetDtdAttrDesc(doc->intSubset,\n\t\t                         elem->name, BAD_CAST \"xmlns\");\n\t    if ((attrDecl == NULL) && (doc->extSubset != NULL))\n\t\tattrDecl = xmlGetDtdAttrDesc(doc->extSubset,\n\t\t\t\t\t     elem->name, BAD_CAST \"xmlns\");\n\t}\n    }\n\n\n    /* Validity Constraint: Attribute Value Type */\n    if (attrDecl == NULL) {\n\tif (ns->prefix != NULL) {\n\t    xmlErrValidNode(ctxt, elem, XML_DTD_UNKNOWN_ATTRIBUTE,\n\t\t   \"No declaration for attribute xmlns:%s of element %s\\n\",\n\t\t   ns->prefix, elem->name, NULL);\n\t} else {\n\t    xmlErrValidNode(ctxt, elem, XML_DTD_UNKNOWN_ATTRIBUTE,\n\t\t   \"No declaration for attribute xmlns of element %s\\n\",\n\t\t   elem->name, NULL, NULL);\n\t}\n\treturn(0);\n    }\n\n    val = xmlValidateAttributeValueInternal(doc, attrDecl->atype, value);\n    if (val == 0) {\n\tif (ns->prefix != NULL) {\n\t    xmlErrValidNode(ctxt, elem, XML_DTD_INVALID_DEFAULT,\n\t       \"Syntax of value for attribute xmlns:%s of %s is not valid\\n\",\n\t\t   ns->prefix, elem->name, NULL);\n\t} else {\n\t    xmlErrValidNode(ctxt, elem, XML_DTD_INVALID_DEFAULT,\n\t       \"Syntax of value for attribute xmlns of %s is not valid\\n\",\n\t\t   elem->name, NULL, NULL);\n\t}\n        ret = 0;\n    }\n\n    /* Validity constraint: Fixed Attribute Default */\n    if (attrDecl->def == XML_ATTRIBUTE_FIXED) {\n\tif (!xmlStrEqual(value, attrDecl->defaultValue)) {\n\t    if (ns->prefix != NULL) {\n\t\txmlErrValidNode(ctxt, elem, XML_DTD_ATTRIBUTE_DEFAULT,\n       \"Value for attribute xmlns:%s of %s is different from default \\\"%s\\\"\\n\",\n\t\t       ns->prefix, elem->name, attrDecl->defaultValue);\n\t    } else {\n\t\txmlErrValidNode(ctxt, elem, XML_DTD_ATTRIBUTE_DEFAULT,\n       \"Value for attribute xmlns of %s is different from default \\\"%s\\\"\\n\",\n\t\t       elem->name, attrDecl->defaultValue, NULL);\n\t    }\n\t    ret = 0;\n\t}\n    }\n\n    /*\n     * Casting ns to xmlAttrPtr is wrong. We'd need separate functions\n     * xmlAddID and xmlAddRef for namespace declarations, but it makes\n     * no practical sense to use ID types anyway.\n     */\n#if 0\n    /* Validity Constraint: ID uniqueness */\n    if (attrDecl->atype == XML_ATTRIBUTE_ID) {\n        if (xmlAddID(ctxt, doc, value, (xmlAttrPtr) ns) == NULL)\n\t    ret = 0;\n    }\n\n    if ((attrDecl->atype == XML_ATTRIBUTE_IDREF) ||\n\t(attrDecl->atype == XML_ATTRIBUTE_IDREFS)) {\n        if (xmlAddRef(ctxt, doc, value, (xmlAttrPtr) ns) == NULL)\n\t    ret = 0;\n    }\n#endif\n\n    /* Validity Constraint: Notation Attributes */\n    if (attrDecl->atype == XML_ATTRIBUTE_NOTATION) {\n        xmlEnumerationPtr tree = attrDecl->tree;\n        xmlNotationPtr nota;\n\n        /* First check that the given NOTATION was declared */\n\tnota = xmlGetDtdNotationDesc(doc->intSubset, value);\n\tif (nota == NULL)\n\t    nota = xmlGetDtdNotationDesc(doc->extSubset, value);\n\n\tif (nota == NULL) {\n\t    if (ns->prefix != NULL) {\n\t\txmlErrValidNode(ctxt, elem, XML_DTD_UNKNOWN_NOTATION,\n       \"Value \\\"%s\\\" for attribute xmlns:%s of %s is not a declared Notation\\n\",\n\t\t       value, ns->prefix, elem->name);\n\t    } else {\n\t\txmlErrValidNode(ctxt, elem, XML_DTD_UNKNOWN_NOTATION,\n       \"Value \\\"%s\\\" for attribute xmlns of %s is not a declared Notation\\n\",\n\t\t       value, elem->name, NULL);\n\t    }\n\t    ret = 0;\n        }\n\n\t/* Second, verify that it's among the list */\n\twhile (tree != NULL) {\n\t    if (xmlStrEqual(tree->name, value)) break;\n\t    tree = tree->next;\n\t}\n\tif (tree == NULL) {\n\t    if (ns->prefix != NULL) {\n\t\txmlErrValidNode(ctxt, elem, XML_DTD_NOTATION_VALUE,\n\"Value \\\"%s\\\" for attribute xmlns:%s of %s is not among the enumerated notations\\n\",\n\t\t       value, ns->prefix, elem->name);\n\t    } else {\n\t\txmlErrValidNode(ctxt, elem, XML_DTD_NOTATION_VALUE,\n\"Value \\\"%s\\\" for attribute xmlns of %s is not among the enumerated notations\\n\",\n\t\t       value, elem->name, NULL);\n\t    }\n\t    ret = 0;\n\t}\n    }\n\n    /* Validity Constraint: Enumeration */\n    if (attrDecl->atype == XML_ATTRIBUTE_ENUMERATION) {\n        xmlEnumerationPtr tree = attrDecl->tree;\n\twhile (tree != NULL) {\n\t    if (xmlStrEqual(tree->name, value)) break;\n\t    tree = tree->next;\n\t}\n\tif (tree == NULL) {\n\t    if (ns->prefix != NULL) {\n\t\txmlErrValidNode(ctxt, elem, XML_DTD_ATTRIBUTE_VALUE,\n\"Value \\\"%s\\\" for attribute xmlns:%s of %s is not among the enumerated set\\n\",\n\t\t       value, ns->prefix, elem->name);\n\t    } else {\n\t\txmlErrValidNode(ctxt, elem, XML_DTD_ATTRIBUTE_VALUE,\n\"Value \\\"%s\\\" for attribute xmlns of %s is not among the enumerated set\\n\",\n\t\t       value, elem->name, NULL);\n\t    }\n\t    ret = 0;\n\t}\n    }\n\n    /* Fixed Attribute Default */\n    if ((attrDecl->def == XML_ATTRIBUTE_FIXED) &&\n        (!xmlStrEqual(attrDecl->defaultValue, value))) {\n\tif (ns->prefix != NULL) {\n\t    xmlErrValidNode(ctxt, elem, XML_DTD_ELEM_NAMESPACE,\n\t\t   \"Value for attribute xmlns:%s of %s must be \\\"%s\\\"\\n\",\n\t\t   ns->prefix, elem->name, attrDecl->defaultValue);\n\t} else {\n\t    xmlErrValidNode(ctxt, elem, XML_DTD_ELEM_NAMESPACE,\n\t\t   \"Value for attribute xmlns of %s must be \\\"%s\\\"\\n\",\n\t\t   elem->name, attrDecl->defaultValue, NULL);\n\t}\n        ret = 0;\n    }\n\n    /* Extra check for the attribute value */\n    if (ns->prefix != NULL) {\n\tret &= xmlValidateAttributeValue2(ctxt, doc, ns->prefix,\n\t\t\t\t\t  attrDecl->atype, value);\n    } else {\n\tret &= xmlValidateAttributeValue2(ctxt, doc, BAD_CAST \"xmlns\",\n\t\t\t\t\t  attrDecl->atype, value);\n    }\n\n    return(ret);\n}\n\n#ifndef  LIBXML_REGEXP_ENABLED\n/**\n * xmlValidateSkipIgnorable:\n * @ctxt:  the validation context\n * @child:  the child list\n *\n * Skip ignorable elements w.r.t. the validation process\n *\n * returns the first element to consider for validation of the content model\n */\n\nstatic xmlNodePtr\nxmlValidateSkipIgnorable(xmlNodePtr child) {\n    while (child != NULL) {\n\tswitch (child->type) {\n\t    /* These things are ignored (skipped) during validation.  */\n\t    case XML_PI_NODE:\n\t    case XML_COMMENT_NODE:\n\t    case XML_XINCLUDE_START:\n\t    case XML_XINCLUDE_END:\n\t\tchild = child->next;\n\t\tbreak;\n\t    case XML_TEXT_NODE:\n\t\tif (xmlIsBlankNode(child))\n\t\t    child = child->next;\n\t\telse\n\t\t    return(child);\n\t\tbreak;\n\t    /* keep current node */\n\t    default:\n\t\treturn(child);\n\t}\n    }\n    return(child);\n}\n\n/**\n * xmlValidateElementType:\n * @ctxt:  the validation context\n *\n * Try to validate the content model of an element internal function\n *\n * returns 1 if valid or 0 ,-1 in case of error, -2 if an entity\n *           reference is found and -3 if the validation succeeded but\n *           the content model is not determinist.\n */\n\nstatic int\nxmlValidateElementType(xmlValidCtxtPtr ctxt) {\n    int ret = -1;\n    int determinist = 1;\n\n    NODE = xmlValidateSkipIgnorable(NODE);\n    if ((NODE == NULL) && (CONT == NULL))\n\treturn(1);\n    if ((NODE == NULL) &&\n\t((CONT->ocur == XML_ELEMENT_CONTENT_MULT) ||\n\t (CONT->ocur == XML_ELEMENT_CONTENT_OPT))) {\n\treturn(1);\n    }\n    if (CONT == NULL) return(-1);\n    if ((NODE != NULL) && (NODE->type == XML_ENTITY_REF_NODE))\n\treturn(-2);\n\n    /*\n     * We arrive here when more states need to be examined\n     */\ncont:\n\n    /*\n     * We just recovered from a rollback generated by a possible\n     * epsilon transition, go directly to the analysis phase\n     */\n    if (STATE == ROLLBACK_PARENT) {\n\tDEBUG_VALID_MSG(\"restored parent branch\");\n\tDEBUG_VALID_STATE(NODE, CONT)\n\tret = 1;\n\tgoto analyze;\n    }\n\n    DEBUG_VALID_STATE(NODE, CONT)\n    /*\n     * we may have to save a backup state here. This is the equivalent\n     * of handling epsilon transition in NFAs.\n     */\n    if ((CONT != NULL) &&\n\t((CONT->parent == NULL) ||\n\t (CONT->parent->type != XML_ELEMENT_CONTENT_OR)) &&\n\t((CONT->ocur == XML_ELEMENT_CONTENT_MULT) ||\n\t (CONT->ocur == XML_ELEMENT_CONTENT_OPT) ||\n\t ((CONT->ocur == XML_ELEMENT_CONTENT_PLUS) && (OCCURRENCE)))) {\n\tDEBUG_VALID_MSG(\"saving parent branch\");\n\tif (vstateVPush(ctxt, CONT, NODE, DEPTH, OCCURS, ROLLBACK_PARENT) < 0)\n\t    return(0);\n    }\n\n\n    /*\n     * Check first if the content matches\n     */\n    switch (CONT->type) {\n\tcase XML_ELEMENT_CONTENT_PCDATA:\n\t    if (NODE == NULL) {\n\t\tDEBUG_VALID_MSG(\"pcdata failed no node\");\n\t\tret = 0;\n\t\tbreak;\n\t    }\n\t    if (NODE->type == XML_TEXT_NODE) {\n\t\tDEBUG_VALID_MSG(\"pcdata found, skip to next\");\n\t\t/*\n\t\t * go to next element in the content model\n\t\t * skipping ignorable elems\n\t\t */\n\t\tdo {\n\t\t    NODE = NODE->next;\n\t\t    NODE = xmlValidateSkipIgnorable(NODE);\n\t\t    if ((NODE != NULL) &&\n\t\t\t(NODE->type == XML_ENTITY_REF_NODE))\n\t\t\treturn(-2);\n\t\t} while ((NODE != NULL) &&\n\t\t\t ((NODE->type != XML_ELEMENT_NODE) &&\n\t\t\t  (NODE->type != XML_TEXT_NODE) &&\n\t\t\t  (NODE->type != XML_CDATA_SECTION_NODE)));\n                ret = 1;\n\t\tbreak;\n\t    } else {\n\t\tDEBUG_VALID_MSG(\"pcdata failed\");\n\t\tret = 0;\n\t\tbreak;\n\t    }\n\t    break;\n\tcase XML_ELEMENT_CONTENT_ELEMENT:\n\t    if (NODE == NULL) {\n\t\tDEBUG_VALID_MSG(\"element failed no node\");\n\t\tret = 0;\n\t\tbreak;\n\t    }\n\t    ret = ((NODE->type == XML_ELEMENT_NODE) &&\n\t\t   (xmlStrEqual(NODE->name, CONT->name)));\n\t    if (ret == 1) {\n\t\tif ((NODE->ns == NULL) || (NODE->ns->prefix == NULL)) {\n\t\t    ret = (CONT->prefix == NULL);\n\t\t} else if (CONT->prefix == NULL) {\n\t\t    ret = 0;\n\t\t} else {\n\t\t    ret = xmlStrEqual(NODE->ns->prefix, CONT->prefix);\n\t\t}\n\t    }\n\t    if (ret == 1) {\n\t\tDEBUG_VALID_MSG(\"element found, skip to next\");\n\t\t/*\n\t\t * go to next element in the content model\n\t\t * skipping ignorable elems\n\t\t */\n\t\tdo {\n\t\t    NODE = NODE->next;\n\t\t    NODE = xmlValidateSkipIgnorable(NODE);\n\t\t    if ((NODE != NULL) &&\n\t\t\t(NODE->type == XML_ENTITY_REF_NODE))\n\t\t\treturn(-2);\n\t\t} while ((NODE != NULL) &&\n\t\t\t ((NODE->type != XML_ELEMENT_NODE) &&\n\t\t\t  (NODE->type != XML_TEXT_NODE) &&\n\t\t\t  (NODE->type != XML_CDATA_SECTION_NODE)));\n\t    } else {\n\t\tDEBUG_VALID_MSG(\"element failed\");\n\t\tret = 0;\n\t\tbreak;\n\t    }\n\t    break;\n\tcase XML_ELEMENT_CONTENT_OR:\n\t    /*\n\t     * Small optimization.\n\t     */\n\t    if (CONT->c1->type == XML_ELEMENT_CONTENT_ELEMENT) {\n\t\tif ((NODE == NULL) ||\n\t\t    (!xmlStrEqual(NODE->name, CONT->c1->name))) {\n\t\t    DEPTH++;\n\t\t    CONT = CONT->c2;\n\t\t    goto cont;\n\t\t}\n\t\tif ((NODE->ns == NULL) || (NODE->ns->prefix == NULL)) {\n\t\t    ret = (CONT->c1->prefix == NULL);\n\t\t} else if (CONT->c1->prefix == NULL) {\n\t\t    ret = 0;\n\t\t} else {\n\t\t    ret = xmlStrEqual(NODE->ns->prefix, CONT->c1->prefix);\n\t\t}\n\t\tif (ret == 0) {\n\t\t    DEPTH++;\n\t\t    CONT = CONT->c2;\n\t\t    goto cont;\n\t\t}\n\t    }\n\n\t    /*\n\t     * save the second branch 'or' branch\n\t     */\n\t    DEBUG_VALID_MSG(\"saving 'or' branch\");\n\t    if (vstateVPush(ctxt, CONT->c2, NODE, (unsigned char)(DEPTH + 1),\n\t\t\t    OCCURS, ROLLBACK_OR) < 0)\n\t\treturn(-1);\n\t    DEPTH++;\n\t    CONT = CONT->c1;\n\t    goto cont;\n\tcase XML_ELEMENT_CONTENT_SEQ:\n\t    /*\n\t     * Small optimization.\n\t     */\n\t    if ((CONT->c1->type == XML_ELEMENT_CONTENT_ELEMENT) &&\n\t\t((CONT->c1->ocur == XML_ELEMENT_CONTENT_OPT) ||\n\t\t (CONT->c1->ocur == XML_ELEMENT_CONTENT_MULT))) {\n\t\tif ((NODE == NULL) ||\n\t\t    (!xmlStrEqual(NODE->name, CONT->c1->name))) {\n\t\t    DEPTH++;\n\t\t    CONT = CONT->c2;\n\t\t    goto cont;\n\t\t}\n\t\tif ((NODE->ns == NULL) || (NODE->ns->prefix == NULL)) {\n\t\t    ret = (CONT->c1->prefix == NULL);\n\t\t} else if (CONT->c1->prefix == NULL) {\n\t\t    ret = 0;\n\t\t} else {\n\t\t    ret = xmlStrEqual(NODE->ns->prefix, CONT->c1->prefix);\n\t\t}\n\t\tif (ret == 0) {\n\t\t    DEPTH++;\n\t\t    CONT = CONT->c2;\n\t\t    goto cont;\n\t\t}\n\t    }\n\t    DEPTH++;\n\t    CONT = CONT->c1;\n\t    goto cont;\n    }\n\n    /*\n     * At this point handle going up in the tree\n     */\n    if (ret == -1) {\n\tDEBUG_VALID_MSG(\"error found returning\");\n\treturn(ret);\n    }\nanalyze:\n    while (CONT != NULL) {\n\t/*\n\t * First do the analysis depending on the occurrence model at\n\t * this level.\n\t */\n\tif (ret == 0) {\n\t    switch (CONT->ocur) {\n\t\txmlNodePtr cur;\n\n\t\tcase XML_ELEMENT_CONTENT_ONCE:\n\t\t    cur = ctxt->vstate->node;\n\t\t    DEBUG_VALID_MSG(\"Once branch failed, rollback\");\n\t\t    if (vstateVPop(ctxt) < 0 ) {\n\t\t\tDEBUG_VALID_MSG(\"exhaustion, failed\");\n\t\t\treturn(0);\n\t\t    }\n\t\t    if (cur != ctxt->vstate->node)\n\t\t\tdeterminist = -3;\n\t\t    goto cont;\n\t\tcase XML_ELEMENT_CONTENT_PLUS:\n\t\t    if (OCCURRENCE == 0) {\n\t\t\tcur = ctxt->vstate->node;\n\t\t\tDEBUG_VALID_MSG(\"Plus branch failed, rollback\");\n\t\t\tif (vstateVPop(ctxt) < 0 ) {\n\t\t\t    DEBUG_VALID_MSG(\"exhaustion, failed\");\n\t\t\t    return(0);\n\t\t\t}\n\t\t\tif (cur != ctxt->vstate->node)\n\t\t\t    determinist = -3;\n\t\t\tgoto cont;\n\t\t    }\n\t\t    DEBUG_VALID_MSG(\"Plus branch found\");\n\t\t    ret = 1;\n\t\t    break;\n\t\tcase XML_ELEMENT_CONTENT_MULT:\n#ifdef DEBUG_VALID_ALGO\n\t\t    if (OCCURRENCE == 0) {\n\t\t\tDEBUG_VALID_MSG(\"Mult branch failed\");\n\t\t    } else {\n\t\t\tDEBUG_VALID_MSG(\"Mult branch found\");\n\t\t    }\n#endif\n\t\t    ret = 1;\n\t\t    break;\n\t\tcase XML_ELEMENT_CONTENT_OPT:\n\t\t    DEBUG_VALID_MSG(\"Option branch failed\");\n\t\t    ret = 1;\n\t\t    break;\n\t    }\n\t} else {\n\t    switch (CONT->ocur) {\n\t\tcase XML_ELEMENT_CONTENT_OPT:\n\t\t    DEBUG_VALID_MSG(\"Option branch succeeded\");\n\t\t    ret = 1;\n\t\t    break;\n\t\tcase XML_ELEMENT_CONTENT_ONCE:\n\t\t    DEBUG_VALID_MSG(\"Once branch succeeded\");\n\t\t    ret = 1;\n\t\t    break;\n\t\tcase XML_ELEMENT_CONTENT_PLUS:\n\t\t    if (STATE == ROLLBACK_PARENT) {\n\t\t\tDEBUG_VALID_MSG(\"Plus branch rollback\");\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t    }\n\t\t    if (NODE == NULL) {\n\t\t\tDEBUG_VALID_MSG(\"Plus branch exhausted\");\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t    }\n\t\t    DEBUG_VALID_MSG(\"Plus branch succeeded, continuing\");\n\t\t    SET_OCCURRENCE;\n\t\t    goto cont;\n\t\tcase XML_ELEMENT_CONTENT_MULT:\n\t\t    if (STATE == ROLLBACK_PARENT) {\n\t\t\tDEBUG_VALID_MSG(\"Mult branch rollback\");\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t    }\n\t\t    if (NODE == NULL) {\n\t\t\tDEBUG_VALID_MSG(\"Mult branch exhausted\");\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t    }\n\t\t    DEBUG_VALID_MSG(\"Mult branch succeeded, continuing\");\n\t\t    /* SET_OCCURRENCE; */\n\t\t    goto cont;\n\t    }\n\t}\n\tSTATE = 0;\n\n\t/*\n\t * Then act accordingly at the parent level\n\t */\n\tRESET_OCCURRENCE;\n\tif (CONT->parent == NULL)\n\t    break;\n\n\tswitch (CONT->parent->type) {\n\t    case XML_ELEMENT_CONTENT_PCDATA:\n\t\tDEBUG_VALID_MSG(\"Error: parent pcdata\");\n\t\treturn(-1);\n\t    case XML_ELEMENT_CONTENT_ELEMENT:\n\t\tDEBUG_VALID_MSG(\"Error: parent element\");\n\t\treturn(-1);\n\t    case XML_ELEMENT_CONTENT_OR:\n\t\tif (ret == 1) {\n\t\t    DEBUG_VALID_MSG(\"Or succeeded\");\n\t\t    CONT = CONT->parent;\n\t\t    DEPTH--;\n\t\t} else {\n\t\t    DEBUG_VALID_MSG(\"Or failed\");\n\t\t    CONT = CONT->parent;\n\t\t    DEPTH--;\n\t\t}\n\t\tbreak;\n\t    case XML_ELEMENT_CONTENT_SEQ:\n\t\tif (ret == 0) {\n\t\t    DEBUG_VALID_MSG(\"Sequence failed\");\n\t\t    CONT = CONT->parent;\n\t\t    DEPTH--;\n\t\t} else if (CONT == CONT->parent->c1) {\n\t\t    DEBUG_VALID_MSG(\"Sequence testing 2nd branch\");\n\t\t    CONT = CONT->parent->c2;\n\t\t    goto cont;\n\t\t} else {\n\t\t    DEBUG_VALID_MSG(\"Sequence succeeded\");\n\t\t    CONT = CONT->parent;\n\t\t    DEPTH--;\n\t\t}\n\t}\n    }\n    if (NODE != NULL) {\n\txmlNodePtr cur;\n\n\tcur = ctxt->vstate->node;\n\tDEBUG_VALID_MSG(\"Failed, remaining input, rollback\");\n\tif (vstateVPop(ctxt) < 0 ) {\n\t    DEBUG_VALID_MSG(\"exhaustion, failed\");\n\t    return(0);\n\t}\n\tif (cur != ctxt->vstate->node)\n\t    determinist = -3;\n\tgoto cont;\n    }\n    if (ret == 0) {\n\txmlNodePtr cur;\n\n\tcur = ctxt->vstate->node;\n\tDEBUG_VALID_MSG(\"Failure, rollback\");\n\tif (vstateVPop(ctxt) < 0 ) {\n\t    DEBUG_VALID_MSG(\"exhaustion, failed\");\n\t    return(0);\n\t}\n\tif (cur != ctxt->vstate->node)\n\t    determinist = -3;\n\tgoto cont;\n    }\n    return(determinist);\n}\n#endif\n\n/**\n * xmlSnprintfElements:\n * @buf:  an output buffer\n * @size:  the size of the buffer\n * @content:  An element\n * @glob: 1 if one must print the englobing parenthesis, 0 otherwise\n *\n * This will dump the list of elements to the buffer\n * Intended just for the debug routine\n */\nstatic void\nxmlSnprintfElements(char *buf, int size, xmlNodePtr node, int glob) {\n    xmlNodePtr cur;\n    int len;\n\n    if (node == NULL) return;\n    if (glob) strcat(buf, \"(\");\n    cur = node;\n    while (cur != NULL) {\n\tlen = strlen(buf);\n\tif (size - len < 50) {\n\t    if ((size - len > 4) && (buf[len - 1] != '.'))\n\t\tstrcat(buf, \" ...\");\n\t    return;\n\t}\n        switch (cur->type) {\n            case XML_ELEMENT_NODE:\n\t\tif ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {\n\t\t    if (size - len < xmlStrlen(cur->ns->prefix) + 10) {\n\t\t\tif ((size - len > 4) && (buf[len - 1] != '.'))\n\t\t\t    strcat(buf, \" ...\");\n\t\t\treturn;\n\t\t    }\n\t\t    strcat(buf, (char *) cur->ns->prefix);\n\t\t    strcat(buf, \":\");\n\t\t}\n                if (size - len < xmlStrlen(cur->name) + 10) {\n\t\t    if ((size - len > 4) && (buf[len - 1] != '.'))\n\t\t\tstrcat(buf, \" ...\");\n\t\t    return;\n\t\t}\n\t        strcat(buf, (char *) cur->name);\n\t\tif (cur->next != NULL)\n\t\t    strcat(buf, \" \");\n\t\tbreak;\n            case XML_TEXT_NODE:\n\t\tif (xmlIsBlankNode(cur))\n\t\t    break;\n                /* Falls through. */\n            case XML_CDATA_SECTION_NODE:\n            case XML_ENTITY_REF_NODE:\n\t        strcat(buf, \"CDATA\");\n\t\tif (cur->next != NULL)\n\t\t    strcat(buf, \" \");\n\t\tbreak;\n            case XML_ATTRIBUTE_NODE:\n            case XML_DOCUMENT_NODE:\n#ifdef LIBXML_DOCB_ENABLED\n\t    case XML_DOCB_DOCUMENT_NODE:\n#endif\n\t    case XML_HTML_DOCUMENT_NODE:\n            case XML_DOCUMENT_TYPE_NODE:\n            case XML_DOCUMENT_FRAG_NODE:\n            case XML_NOTATION_NODE:\n\t    case XML_NAMESPACE_DECL:\n\t        strcat(buf, \"???\");\n\t\tif (cur->next != NULL)\n\t\t    strcat(buf, \" \");\n\t\tbreak;\n            case XML_ENTITY_NODE:\n            case XML_PI_NODE:\n            case XML_DTD_NODE:\n            case XML_COMMENT_NODE:\n\t    case XML_ELEMENT_DECL:\n\t    case XML_ATTRIBUTE_DECL:\n\t    case XML_ENTITY_DECL:\n\t    case XML_XINCLUDE_START:\n\t    case XML_XINCLUDE_END:\n\t\tbreak;\n\t}\n\tcur = cur->next;\n    }\n    if (glob) strcat(buf, \")\");\n}\n\n/**\n * xmlValidateElementContent:\n * @ctxt:  the validation context\n * @child:  the child list\n * @elemDecl:  pointer to the element declaration\n * @warn:  emit the error message\n * @parent: the parent element (for error reporting)\n *\n * Try to validate the content model of an element\n *\n * returns 1 if valid or 0 if not and -1 in case of error\n */\n\nstatic int\nxmlValidateElementContent(xmlValidCtxtPtr ctxt, xmlNodePtr child,\n       xmlElementPtr elemDecl, int warn, xmlNodePtr parent) {\n    int ret = 1;\n#ifndef  LIBXML_REGEXP_ENABLED\n    xmlNodePtr repl = NULL, last = NULL, tmp;\n#endif\n    xmlNodePtr cur;\n    xmlElementContentPtr cont;\n    const xmlChar *name;\n\n    if ((elemDecl == NULL) || (parent == NULL) || (ctxt == NULL))\n\treturn(-1);\n    cont = elemDecl->content;\n    name = elemDecl->name;\n\n#ifdef LIBXML_REGEXP_ENABLED\n    /* Build the regexp associated to the content model */\n    if (elemDecl->contModel == NULL)\n\tret = xmlValidBuildContentModel(ctxt, elemDecl);\n    if (elemDecl->contModel == NULL) {\n\treturn(-1);\n    } else {\n\txmlRegExecCtxtPtr exec;\n\n\tif (!xmlRegexpIsDeterminist(elemDecl->contModel)) {\n\t    return(-1);\n\t}\n\tctxt->nodeMax = 0;\n\tctxt->nodeNr = 0;\n\tctxt->nodeTab = NULL;\n\texec = xmlRegNewExecCtxt(elemDecl->contModel, NULL, NULL);\n\tif (exec != NULL) {\n\t    cur = child;\n\t    while (cur != NULL) {\n\t\tswitch (cur->type) {\n\t\t    case XML_ENTITY_REF_NODE:\n\t\t\t/*\n\t\t\t * Push the current node to be able to roll back\n\t\t\t * and process within the entity\n\t\t\t */\n\t\t\tif ((cur->children != NULL) &&\n\t\t\t    (cur->children->children != NULL)) {\n\t\t\t    nodeVPush(ctxt, cur);\n\t\t\t    cur = cur->children->children;\n\t\t\t    continue;\n\t\t\t}\n\t\t\tbreak;\n\t\t    case XML_TEXT_NODE:\n\t\t\tif (xmlIsBlankNode(cur))\n\t\t\t    break;\n\t\t\tret = 0;\n\t\t\tgoto fail;\n\t\t    case XML_CDATA_SECTION_NODE:\n\t\t\t/* TODO */\n\t\t\tret = 0;\n\t\t\tgoto fail;\n\t\t    case XML_ELEMENT_NODE:\n\t\t\tif ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {\n\t\t\t    xmlChar fn[50];\n\t\t\t    xmlChar *fullname;\n\n\t\t\t    fullname = xmlBuildQName(cur->name,\n\t\t\t\t                     cur->ns->prefix, fn, 50);\n\t\t\t    if (fullname == NULL) {\n\t\t\t\tret = -1;\n\t\t\t\tgoto fail;\n\t\t\t    }\n                            ret = xmlRegExecPushString(exec, fullname, NULL);\n\t\t\t    if ((fullname != fn) && (fullname != cur->name))\n\t\t\t\txmlFree(fullname);\n\t\t\t} else {\n\t\t\t    ret = xmlRegExecPushString(exec, cur->name, NULL);\n\t\t\t}\n\t\t\tbreak;\n\t\t    default:\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * Switch to next element\n\t\t */\n\t\tcur = cur->next;\n\t\twhile (cur == NULL) {\n\t\t    cur = nodeVPop(ctxt);\n\t\t    if (cur == NULL)\n\t\t\tbreak;\n\t\t    cur = cur->next;\n\t\t}\n\t    }\n\t    ret = xmlRegExecPushString(exec, NULL, NULL);\nfail:\n\t    xmlRegFreeExecCtxt(exec);\n\t}\n    }\n#else  /* LIBXML_REGEXP_ENABLED */\n    /*\n     * Allocate the stack\n     */\n    ctxt->vstateMax = 8;\n    ctxt->vstateTab = (xmlValidState *) xmlMalloc(\n\t\t ctxt->vstateMax * sizeof(ctxt->vstateTab[0]));\n    if (ctxt->vstateTab == NULL) {\n\txmlVErrMemory(ctxt, \"malloc failed\");\n\treturn(-1);\n    }\n    /*\n     * The first entry in the stack is reserved to the current state\n     */\n    ctxt->nodeMax = 0;\n    ctxt->nodeNr = 0;\n    ctxt->nodeTab = NULL;\n    ctxt->vstate = &ctxt->vstateTab[0];\n    ctxt->vstateNr = 1;\n    CONT = cont;\n    NODE = child;\n    DEPTH = 0;\n    OCCURS = 0;\n    STATE = 0;\n    ret = xmlValidateElementType(ctxt);\n    if ((ret == -3) && (warn)) {\n\txmlErrValidWarning(ctxt, child, XML_DTD_CONTENT_NOT_DETERMINIST,\n\t       \"Content model for Element %s is ambiguous\\n\",\n\t                   name, NULL, NULL);\n    } else if (ret == -2) {\n\t/*\n\t * An entities reference appeared at this level.\n\t * Build a minimal representation of this node content\n\t * sufficient to run the validation process on it\n\t */\n\tDEBUG_VALID_MSG(\"Found an entity reference, linearizing\");\n\tcur = child;\n\twhile (cur != NULL) {\n\t    switch (cur->type) {\n\t\tcase XML_ENTITY_REF_NODE:\n\t\t    /*\n\t\t     * Push the current node to be able to roll back\n\t\t     * and process within the entity\n\t\t     */\n\t\t    if ((cur->children != NULL) &&\n\t\t\t(cur->children->children != NULL)) {\n\t\t\tnodeVPush(ctxt, cur);\n\t\t\tcur = cur->children->children;\n\t\t\tcontinue;\n\t\t    }\n\t\t    break;\n\t\tcase XML_TEXT_NODE:\n\t\t    if (xmlIsBlankNode(cur))\n\t\t\tbreak;\n\t\t    /* no break on purpose */\n\t\tcase XML_CDATA_SECTION_NODE:\n\t\t    /* no break on purpose */\n\t\tcase XML_ELEMENT_NODE:\n\t\t    /*\n\t\t     * Allocate a new node and minimally fills in\n\t\t     * what's required\n\t\t     */\n\t\t    tmp = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));\n\t\t    if (tmp == NULL) {\n\t\t\txmlVErrMemory(ctxt, \"malloc failed\");\n\t\t\txmlFreeNodeList(repl);\n\t\t\tret = -1;\n\t\t\tgoto done;\n\t\t    }\n\t\t    tmp->type = cur->type;\n\t\t    tmp->name = cur->name;\n\t\t    tmp->ns = cur->ns;\n\t\t    tmp->next = NULL;\n\t\t    tmp->content = NULL;\n\t\t    if (repl == NULL)\n\t\t\trepl = last = tmp;\n\t\t    else {\n\t\t\tlast->next = tmp;\n\t\t\tlast = tmp;\n\t\t    }\n\t\t    if (cur->type == XML_CDATA_SECTION_NODE) {\n\t\t\t/*\n\t\t\t * E59 spaces in CDATA does not match the\n\t\t\t * nonterminal S\n\t\t\t */\n\t\t\ttmp->content = xmlStrdup(BAD_CAST \"CDATA\");\n\t\t    }\n\t\t    break;\n\t\tdefault:\n\t\t    break;\n\t    }\n\t    /*\n\t     * Switch to next element\n\t     */\n\t    cur = cur->next;\n\t    while (cur == NULL) {\n\t\tcur = nodeVPop(ctxt);\n\t\tif (cur == NULL)\n\t\t    break;\n\t\tcur = cur->next;\n\t    }\n\t}\n\n\t/*\n\t * Relaunch the validation\n\t */\n\tctxt->vstate = &ctxt->vstateTab[0];\n\tctxt->vstateNr = 1;\n\tCONT = cont;\n\tNODE = repl;\n\tDEPTH = 0;\n\tOCCURS = 0;\n\tSTATE = 0;\n\tret = xmlValidateElementType(ctxt);\n    }\n#endif /* LIBXML_REGEXP_ENABLED */\n    if ((warn) && ((ret != 1) && (ret != -3))) {\n\tif (ctxt != NULL) {\n\t    char expr[5000];\n\t    char list[5000];\n\n\t    expr[0] = 0;\n\t    xmlSnprintfElementContent(&expr[0], 5000, cont, 1);\n\t    list[0] = 0;\n#ifndef LIBXML_REGEXP_ENABLED\n\t    if (repl != NULL)\n\t\txmlSnprintfElements(&list[0], 5000, repl, 1);\n\t    else\n#endif /* LIBXML_REGEXP_ENABLED */\n\t\txmlSnprintfElements(&list[0], 5000, child, 1);\n\n\t    if (name != NULL) {\n\t\txmlErrValidNode(ctxt, parent, XML_DTD_CONTENT_MODEL,\n\t   \"Element %s content does not follow the DTD, expecting %s, got %s\\n\",\n\t\t       name, BAD_CAST expr, BAD_CAST list);\n\t    } else {\n\t\txmlErrValidNode(ctxt, parent, XML_DTD_CONTENT_MODEL,\n\t   \"Element content does not follow the DTD, expecting %s, got %s\\n\",\n\t\t       BAD_CAST expr, BAD_CAST list, NULL);\n\t    }\n\t} else {\n\t    if (name != NULL) {\n\t\txmlErrValidNode(ctxt, parent, XML_DTD_CONTENT_MODEL,\n\t\t       \"Element %s content does not follow the DTD\\n\",\n\t\t       name, NULL, NULL);\n\t    } else {\n\t\txmlErrValidNode(ctxt, parent, XML_DTD_CONTENT_MODEL,\n\t\t       \"Element content does not follow the DTD\\n\",\n\t\t                NULL, NULL, NULL);\n\t    }\n\t}\n\tret = 0;\n    }\n    if (ret == -3)\n\tret = 1;\n\n#ifndef  LIBXML_REGEXP_ENABLED\ndone:\n    /*\n     * Deallocate the copy if done, and free up the validation stack\n     */\n    while (repl != NULL) {\n\ttmp = repl->next;\n\txmlFree(repl);\n\trepl = tmp;\n    }\n    ctxt->vstateMax = 0;\n    if (ctxt->vstateTab != NULL) {\n\txmlFree(ctxt->vstateTab);\n\tctxt->vstateTab = NULL;\n    }\n#endif\n    ctxt->nodeMax = 0;\n    ctxt->nodeNr = 0;\n    if (ctxt->nodeTab != NULL) {\n\txmlFree(ctxt->nodeTab);\n\tctxt->nodeTab = NULL;\n    }\n    return(ret);\n\n}\n\n/**\n * xmlValidateCdataElement:\n * @ctxt:  the validation context\n * @doc:  a document instance\n * @elem:  an element instance\n *\n * Check that an element follows #CDATA\n *\n * returns 1 if valid or 0 otherwise\n */\nstatic int\nxmlValidateOneCdataElement(xmlValidCtxtPtr ctxt, xmlDocPtr doc,\n                           xmlNodePtr elem) {\n    int ret = 1;\n    xmlNodePtr cur, child;\n\n    if ((ctxt == NULL) || (doc == NULL) || (elem == NULL) ||\n        (elem->type != XML_ELEMENT_NODE))\n\treturn(0);\n\n    child = elem->children;\n\n    cur = child;\n    while (cur != NULL) {\n\tswitch (cur->type) {\n\t    case XML_ENTITY_REF_NODE:\n\t\t/*\n\t\t * Push the current node to be able to roll back\n\t\t * and process within the entity\n\t\t */\n\t\tif ((cur->children != NULL) &&\n\t\t    (cur->children->children != NULL)) {\n\t\t    nodeVPush(ctxt, cur);\n\t\t    cur = cur->children->children;\n\t\t    continue;\n\t\t}\n\t\tbreak;\n\t    case XML_COMMENT_NODE:\n\t    case XML_PI_NODE:\n\t    case XML_TEXT_NODE:\n\t    case XML_CDATA_SECTION_NODE:\n\t\tbreak;\n\t    default:\n\t\tret = 0;\n\t\tgoto done;\n\t}\n\t/*\n\t * Switch to next element\n\t */\n\tcur = cur->next;\n\twhile (cur == NULL) {\n\t    cur = nodeVPop(ctxt);\n\t    if (cur == NULL)\n\t\tbreak;\n\t    cur = cur->next;\n\t}\n    }\ndone:\n    ctxt->nodeMax = 0;\n    ctxt->nodeNr = 0;\n    if (ctxt->nodeTab != NULL) {\n\txmlFree(ctxt->nodeTab);\n\tctxt->nodeTab = NULL;\n    }\n    return(ret);\n}\n\n/**\n * xmlValidateCheckMixed:\n * @ctxt:  the validation context\n * @cont:  the mixed content model\n * @qname:  the qualified name as appearing in the serialization\n *\n * Check if the given node is part of the content model.\n *\n * Returns 1 if yes, 0 if no, -1 in case of error\n */\nstatic int\nxmlValidateCheckMixed(xmlValidCtxtPtr ctxt,\n\t              xmlElementContentPtr cont, const xmlChar *qname) {\n    const xmlChar *name;\n    int plen;\n    name = xmlSplitQName3(qname, &plen);\n\n    if (name == NULL) {\n\twhile (cont != NULL) {\n\t    if (cont->type == XML_ELEMENT_CONTENT_ELEMENT) {\n\t\tif ((cont->prefix == NULL) && (xmlStrEqual(cont->name, qname)))\n\t\t    return(1);\n\t    } else if ((cont->type == XML_ELEMENT_CONTENT_OR) &&\n\t       (cont->c1 != NULL) &&\n\t       (cont->c1->type == XML_ELEMENT_CONTENT_ELEMENT)){\n\t\tif ((cont->c1->prefix == NULL) &&\n\t\t    (xmlStrEqual(cont->c1->name, qname)))\n\t\t    return(1);\n\t    } else if ((cont->type != XML_ELEMENT_CONTENT_OR) ||\n\t\t(cont->c1 == NULL) ||\n\t\t(cont->c1->type != XML_ELEMENT_CONTENT_PCDATA)){\n\t\txmlErrValid(NULL, XML_DTD_MIXED_CORRUPT,\n\t\t\t\"Internal: MIXED struct corrupted\\n\",\n\t\t\tNULL);\n\t\tbreak;\n\t    }\n\t    cont = cont->c2;\n\t}\n    } else {\n\twhile (cont != NULL) {\n\t    if (cont->type == XML_ELEMENT_CONTENT_ELEMENT) {\n\t\tif ((cont->prefix != NULL) &&\n\t\t    (xmlStrncmp(cont->prefix, qname, plen) == 0) &&\n\t\t    (xmlStrEqual(cont->name, name)))\n\t\t    return(1);\n\t    } else if ((cont->type == XML_ELEMENT_CONTENT_OR) &&\n\t       (cont->c1 != NULL) &&\n\t       (cont->c1->type == XML_ELEMENT_CONTENT_ELEMENT)){\n\t\tif ((cont->c1->prefix != NULL) &&\n\t\t    (xmlStrncmp(cont->c1->prefix, qname, plen) == 0) &&\n\t\t    (xmlStrEqual(cont->c1->name, name)))\n\t\t    return(1);\n\t    } else if ((cont->type != XML_ELEMENT_CONTENT_OR) ||\n\t\t(cont->c1 == NULL) ||\n\t\t(cont->c1->type != XML_ELEMENT_CONTENT_PCDATA)){\n\t\txmlErrValid(ctxt, XML_DTD_MIXED_CORRUPT,\n\t\t\t\"Internal: MIXED struct corrupted\\n\",\n\t\t\tNULL);\n\t\tbreak;\n\t    }\n\t    cont = cont->c2;\n\t}\n    }\n    return(0);\n}\n\n/**\n * xmlValidGetElemDecl:\n * @ctxt:  the validation context\n * @doc:  a document instance\n * @elem:  an element instance\n * @extsubset:  pointer, (out) indicate if the declaration was found\n *              in the external subset.\n *\n * Finds a declaration associated to an element in the document.\n *\n * returns the pointer to the declaration or NULL if not found.\n */\nstatic xmlElementPtr\nxmlValidGetElemDecl(xmlValidCtxtPtr ctxt, xmlDocPtr doc,\n\t            xmlNodePtr elem, int *extsubset) {\n    xmlElementPtr elemDecl = NULL;\n    const xmlChar *prefix = NULL;\n\n    if ((ctxt == NULL) || (doc == NULL) ||\n        (elem == NULL) || (elem->name == NULL))\n        return(NULL);\n    if (extsubset != NULL)\n\t*extsubset = 0;\n\n    /*\n     * Fetch the declaration for the qualified name\n     */\n    if ((elem->ns != NULL) && (elem->ns->prefix != NULL))\n\tprefix = elem->ns->prefix;\n\n    if (prefix != NULL) {\n\telemDecl = xmlGetDtdQElementDesc(doc->intSubset,\n\t\t                         elem->name, prefix);\n\tif ((elemDecl == NULL) && (doc->extSubset != NULL)) {\n\t    elemDecl = xmlGetDtdQElementDesc(doc->extSubset,\n\t\t                             elem->name, prefix);\n\t    if ((elemDecl != NULL) && (extsubset != NULL))\n\t\t*extsubset = 1;\n\t}\n    }\n\n    /*\n     * Fetch the declaration for the non qualified name\n     * This is \"non-strict\" validation should be done on the\n     * full QName but in that case being flexible makes sense.\n     */\n    if (elemDecl == NULL) {\n\telemDecl = xmlGetDtdElementDesc(doc->intSubset, elem->name);\n\tif ((elemDecl == NULL) && (doc->extSubset != NULL)) {\n\t    elemDecl = xmlGetDtdElementDesc(doc->extSubset, elem->name);\n\t    if ((elemDecl != NULL) && (extsubset != NULL))\n\t\t*extsubset = 1;\n\t}\n    }\n    if (elemDecl == NULL) {\n\txmlErrValidNode(ctxt, elem,\n\t\t\tXML_DTD_UNKNOWN_ELEM,\n\t       \"No declaration for element %s\\n\",\n\t       elem->name, NULL, NULL);\n    }\n    return(elemDecl);\n}\n\n#ifdef LIBXML_REGEXP_ENABLED\n/**\n * xmlValidatePushElement:\n * @ctxt:  the validation context\n * @doc:  a document instance\n * @elem:  an element instance\n * @qname:  the qualified name as appearing in the serialization\n *\n * Push a new element start on the validation stack.\n *\n * returns 1 if no validation problem was found or 0 otherwise\n */\nint\nxmlValidatePushElement(xmlValidCtxtPtr ctxt, xmlDocPtr doc,\n                       xmlNodePtr elem, const xmlChar *qname) {\n    int ret = 1;\n    xmlElementPtr eDecl;\n    int extsubset = 0;\n\n    if (ctxt == NULL)\n        return(0);\n/* printf(\"PushElem %s\\n\", qname); */\n    if ((ctxt->vstateNr > 0) && (ctxt->vstate != NULL)) {\n\txmlValidStatePtr state = ctxt->vstate;\n\txmlElementPtr elemDecl;\n\n\t/*\n\t * Check the new element against the content model of the new elem.\n\t */\n\tif (state->elemDecl != NULL) {\n\t    elemDecl = state->elemDecl;\n\n\t    switch(elemDecl->etype) {\n\t\tcase XML_ELEMENT_TYPE_UNDEFINED:\n\t\t    ret = 0;\n\t\t    break;\n\t\tcase XML_ELEMENT_TYPE_EMPTY:\n\t\t    xmlErrValidNode(ctxt, state->node,\n\t\t\t\t    XML_DTD_NOT_EMPTY,\n\t       \"Element %s was declared EMPTY this one has content\\n\",\n\t\t\t   state->node->name, NULL, NULL);\n\t\t    ret = 0;\n\t\t    break;\n\t\tcase XML_ELEMENT_TYPE_ANY:\n\t\t    /* I don't think anything is required then */\n\t\t    break;\n\t\tcase XML_ELEMENT_TYPE_MIXED:\n\t\t    /* simple case of declared as #PCDATA */\n\t\t    if ((elemDecl->content != NULL) &&\n\t\t\t(elemDecl->content->type ==\n\t\t\t XML_ELEMENT_CONTENT_PCDATA)) {\n\t\t\txmlErrValidNode(ctxt, state->node,\n\t\t\t\t\tXML_DTD_NOT_PCDATA,\n\t       \"Element %s was declared #PCDATA but contains non text nodes\\n\",\n\t\t\t\tstate->node->name, NULL, NULL);\n\t\t\tret = 0;\n\t\t    } else {\n\t\t\tret = xmlValidateCheckMixed(ctxt, elemDecl->content,\n\t\t\t\t                    qname);\n\t\t\tif (ret != 1) {\n\t\t\t    xmlErrValidNode(ctxt, state->node,\n\t\t\t\t\t    XML_DTD_INVALID_CHILD,\n\t       \"Element %s is not declared in %s list of possible children\\n\",\n\t\t\t\t    qname, state->node->name, NULL);\n\t\t\t}\n\t\t    }\n\t\t    break;\n\t\tcase XML_ELEMENT_TYPE_ELEMENT:\n\t\t    /*\n\t\t     * TODO:\n\t\t     * VC: Standalone Document Declaration\n\t\t     *     - element types with element content, if white space\n\t\t     *       occurs directly within any instance of those types.\n\t\t     */\n\t\t    if (state->exec != NULL) {\n\t\t\tret = xmlRegExecPushString(state->exec, qname, NULL);\n\t\t\tif (ret < 0) {\n\t\t\t    xmlErrValidNode(ctxt, state->node,\n\t\t\t\t\t    XML_DTD_CONTENT_MODEL,\n\t       \"Element %s content does not follow the DTD, Misplaced %s\\n\",\n\t\t\t\t   state->node->name, qname, NULL);\n\t\t\t    ret = 0;\n\t\t\t} else {\n\t\t\t    ret = 1;\n\t\t\t}\n\t\t    }\n\t\t    break;\n\t    }\n\t}\n    }\n    eDecl = xmlValidGetElemDecl(ctxt, doc, elem, &extsubset);\n    vstateVPush(ctxt, eDecl, elem);\n    return(ret);\n}\n\n/**\n * xmlValidatePushCData:\n * @ctxt:  the validation context\n * @data:  some character data read\n * @len:  the length of the data\n *\n * check the CData parsed for validation in the current stack\n *\n * returns 1 if no validation problem was found or 0 otherwise\n */\nint\nxmlValidatePushCData(xmlValidCtxtPtr ctxt, const xmlChar *data, int len) {\n    int ret = 1;\n\n/* printf(\"CDATA %s %d\\n\", data, len); */\n    if (ctxt == NULL)\n        return(0);\n    if (len <= 0)\n\treturn(ret);\n    if ((ctxt->vstateNr > 0) && (ctxt->vstate != NULL)) {\n\txmlValidStatePtr state = ctxt->vstate;\n\txmlElementPtr elemDecl;\n\n\t/*\n\t * Check the new element against the content model of the new elem.\n\t */\n\tif (state->elemDecl != NULL) {\n\t    elemDecl = state->elemDecl;\n\n\t    switch(elemDecl->etype) {\n\t\tcase XML_ELEMENT_TYPE_UNDEFINED:\n\t\t    ret = 0;\n\t\t    break;\n\t\tcase XML_ELEMENT_TYPE_EMPTY:\n\t\t    xmlErrValidNode(ctxt, state->node,\n\t\t\t\t    XML_DTD_NOT_EMPTY,\n\t       \"Element %s was declared EMPTY this one has content\\n\",\n\t\t\t   state->node->name, NULL, NULL);\n\t\t    ret = 0;\n\t\t    break;\n\t\tcase XML_ELEMENT_TYPE_ANY:\n\t\t    break;\n\t\tcase XML_ELEMENT_TYPE_MIXED:\n\t\t    break;\n\t\tcase XML_ELEMENT_TYPE_ELEMENT: {\n                    int i;\n\n                    for (i = 0;i < len;i++) {\n                        if (!IS_BLANK_CH(data[i])) {\n                            xmlErrValidNode(ctxt, state->node,\n                                            XML_DTD_CONTENT_MODEL,\n       \"Element %s content does not follow the DTD, Text not allowed\\n\",\n                                   state->node->name, NULL, NULL);\n                            ret = 0;\n                            goto done;\n                        }\n                    }\n                    /*\n                     * TODO:\n                     * VC: Standalone Document Declaration\n                     *  element types with element content, if white space\n                     *  occurs directly within any instance of those types.\n                     */\n                    break;\n                }\n\t    }\n\t}\n    }\ndone:\n    return(ret);\n}\n\n/**\n * xmlValidatePopElement:\n * @ctxt:  the validation context\n * @doc:  a document instance\n * @elem:  an element instance\n * @qname:  the qualified name as appearing in the serialization\n *\n * Pop the element end from the validation stack.\n *\n * returns 1 if no validation problem was found or 0 otherwise\n */\nint\nxmlValidatePopElement(xmlValidCtxtPtr ctxt, xmlDocPtr doc ATTRIBUTE_UNUSED,\n                      xmlNodePtr elem ATTRIBUTE_UNUSED,\n\t\t      const xmlChar *qname ATTRIBUTE_UNUSED) {\n    int ret = 1;\n\n    if (ctxt == NULL)\n        return(0);\n/* printf(\"PopElem %s\\n\", qname); */\n    if ((ctxt->vstateNr > 0) && (ctxt->vstate != NULL)) {\n\txmlValidStatePtr state = ctxt->vstate;\n\txmlElementPtr elemDecl;\n\n\t/*\n\t * Check the new element against the content model of the new elem.\n\t */\n\tif (state->elemDecl != NULL) {\n\t    elemDecl = state->elemDecl;\n\n\t    if (elemDecl->etype == XML_ELEMENT_TYPE_ELEMENT) {\n\t\tif (state->exec != NULL) {\n\t\t    ret = xmlRegExecPushString(state->exec, NULL, NULL);\n\t\t    if (ret == 0) {\n\t\t\txmlErrValidNode(ctxt, state->node,\n\t\t\t                XML_DTD_CONTENT_MODEL,\n\t   \"Element %s content does not follow the DTD, Expecting more child\\n\",\n\t\t\t       state->node->name, NULL,NULL);\n\t\t    } else {\n\t\t\t/*\n\t\t\t * previous validation errors should not generate\n\t\t\t * a new one here\n\t\t\t */\n\t\t\tret = 1;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tvstateVPop(ctxt);\n    }\n    return(ret);\n}\n#endif /* LIBXML_REGEXP_ENABLED */\n\n/**\n * xmlValidateOneElement:\n * @ctxt:  the validation context\n * @doc:  a document instance\n * @elem:  an element instance\n *\n * Try to validate a single element and it's attributes,\n * basically it does the following checks as described by the\n * XML-1.0 recommendation:\n *  - [ VC: Element Valid ]\n *  - [ VC: Required Attribute ]\n * Then call xmlValidateOneAttribute() for each attribute present.\n *\n * The ID/IDREF checkings are done separately\n *\n * returns 1 if valid or 0 otherwise\n */\n\nint\nxmlValidateOneElement(xmlValidCtxtPtr ctxt, xmlDocPtr doc,\n                      xmlNodePtr elem) {\n    xmlElementPtr elemDecl = NULL;\n    xmlElementContentPtr cont;\n    xmlAttributePtr attr;\n    xmlNodePtr child;\n    int ret = 1, tmp;\n    const xmlChar *name;\n    int extsubset = 0;\n\n    CHECK_DTD;\n\n    if (elem == NULL) return(0);\n    switch (elem->type) {\n        case XML_ATTRIBUTE_NODE:\n\t    xmlErrValidNode(ctxt, elem, XML_ERR_INTERNAL_ERROR,\n\t\t   \"Attribute element not expected\\n\", NULL, NULL ,NULL);\n\t    return(0);\n        case XML_TEXT_NODE:\n\t    if (elem->children != NULL) {\n\t\txmlErrValidNode(ctxt, elem, XML_ERR_INTERNAL_ERROR,\n\t\t                \"Text element has children !\\n\",\n\t\t\t\tNULL,NULL,NULL);\n\t\treturn(0);\n\t    }\n\t    if (elem->ns != NULL) {\n\t\txmlErrValidNode(ctxt, elem, XML_ERR_INTERNAL_ERROR,\n\t\t                \"Text element has namespace !\\n\",\n\t\t\t\tNULL,NULL,NULL);\n\t\treturn(0);\n\t    }\n\t    if (elem->content == NULL) {\n\t\txmlErrValidNode(ctxt, elem, XML_ERR_INTERNAL_ERROR,\n\t\t                \"Text element has no content !\\n\",\n\t\t\t\tNULL,NULL,NULL);\n\t\treturn(0);\n\t    }\n\t    return(1);\n        case XML_XINCLUDE_START:\n        case XML_XINCLUDE_END:\n            return(1);\n        case XML_CDATA_SECTION_NODE:\n        case XML_ENTITY_REF_NODE:\n        case XML_PI_NODE:\n        case XML_COMMENT_NODE:\n\t    return(1);\n        case XML_ENTITY_NODE:\n\t    xmlErrValidNode(ctxt, elem, XML_ERR_INTERNAL_ERROR,\n\t\t   \"Entity element not expected\\n\", NULL, NULL ,NULL);\n\t    return(0);\n        case XML_NOTATION_NODE:\n\t    xmlErrValidNode(ctxt, elem, XML_ERR_INTERNAL_ERROR,\n\t\t   \"Notation element not expected\\n\", NULL, NULL ,NULL);\n\t    return(0);\n        case XML_DOCUMENT_NODE:\n        case XML_DOCUMENT_TYPE_NODE:\n        case XML_DOCUMENT_FRAG_NODE:\n\t    xmlErrValidNode(ctxt, elem, XML_ERR_INTERNAL_ERROR,\n\t\t   \"Document element not expected\\n\", NULL, NULL ,NULL);\n\t    return(0);\n        case XML_HTML_DOCUMENT_NODE:\n\t    xmlErrValidNode(ctxt, elem, XML_ERR_INTERNAL_ERROR,\n\t\t   \"HTML Document not expected\\n\", NULL, NULL ,NULL);\n\t    return(0);\n        case XML_ELEMENT_NODE:\n\t    break;\n\tdefault:\n\t    xmlErrValidNode(ctxt, elem, XML_ERR_INTERNAL_ERROR,\n\t\t   \"unknown element type\\n\", NULL, NULL ,NULL);\n\t    return(0);\n    }\n\n    /*\n     * Fetch the declaration\n     */\n    elemDecl = xmlValidGetElemDecl(ctxt, doc, elem, &extsubset);\n    if (elemDecl == NULL)\n\treturn(0);\n\n    /*\n     * If vstateNr is not zero that means continuous validation is\n     * activated, do not try to check the content model at that level.\n     */\n    if (ctxt->vstateNr == 0) {\n    /* Check that the element content matches the definition */\n    switch (elemDecl->etype) {\n        case XML_ELEMENT_TYPE_UNDEFINED:\n\t    xmlErrValidNode(ctxt, elem, XML_DTD_UNKNOWN_ELEM,\n\t                    \"No declaration for element %s\\n\",\n\t\t   elem->name, NULL, NULL);\n\t    return(0);\n        case XML_ELEMENT_TYPE_EMPTY:\n\t    if (elem->children != NULL) {\n\t\txmlErrValidNode(ctxt, elem, XML_DTD_NOT_EMPTY,\n\t       \"Element %s was declared EMPTY this one has content\\n\",\n\t               elem->name, NULL, NULL);\n\t\tret = 0;\n\t    }\n\t    break;\n        case XML_ELEMENT_TYPE_ANY:\n\t    /* I don't think anything is required then */\n\t    break;\n        case XML_ELEMENT_TYPE_MIXED:\n\n\t    /* simple case of declared as #PCDATA */\n\t    if ((elemDecl->content != NULL) &&\n\t\t(elemDecl->content->type == XML_ELEMENT_CONTENT_PCDATA)) {\n\t\tret = xmlValidateOneCdataElement(ctxt, doc, elem);\n\t\tif (!ret) {\n\t\t    xmlErrValidNode(ctxt, elem, XML_DTD_NOT_PCDATA,\n\t       \"Element %s was declared #PCDATA but contains non text nodes\\n\",\n\t\t\t   elem->name, NULL, NULL);\n\t\t}\n\t\tbreak;\n\t    }\n\t    child = elem->children;\n\t    /* Hum, this start to get messy */\n\t    while (child != NULL) {\n\t        if (child->type == XML_ELEMENT_NODE) {\n\t\t    name = child->name;\n\t\t    if ((child->ns != NULL) && (child->ns->prefix != NULL)) {\n\t\t\txmlChar fn[50];\n\t\t\txmlChar *fullname;\n\n\t\t\tfullname = xmlBuildQName(child->name, child->ns->prefix,\n\t\t\t\t                 fn, 50);\n\t\t\tif (fullname == NULL)\n\t\t\t    return(0);\n\t\t\tcont = elemDecl->content;\n\t\t\twhile (cont != NULL) {\n\t\t\t    if (cont->type == XML_ELEMENT_CONTENT_ELEMENT) {\n\t\t\t\tif (xmlStrEqual(cont->name, fullname))\n\t\t\t\t    break;\n\t\t\t    } else if ((cont->type == XML_ELEMENT_CONTENT_OR) &&\n\t\t\t       (cont->c1 != NULL) &&\n\t\t\t       (cont->c1->type == XML_ELEMENT_CONTENT_ELEMENT)){\n\t\t\t\tif (xmlStrEqual(cont->c1->name, fullname))\n\t\t\t\t    break;\n\t\t\t    } else if ((cont->type != XML_ELEMENT_CONTENT_OR) ||\n\t\t\t\t(cont->c1 == NULL) ||\n\t\t\t\t(cont->c1->type != XML_ELEMENT_CONTENT_PCDATA)){\n\t\t\t\txmlErrValid(NULL, XML_DTD_MIXED_CORRUPT,\n\t\t\t\t\t\"Internal: MIXED struct corrupted\\n\",\n\t\t\t\t\tNULL);\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t    cont = cont->c2;\n\t\t\t}\n\t\t\tif ((fullname != fn) && (fullname != child->name))\n\t\t\t    xmlFree(fullname);\n\t\t\tif (cont != NULL)\n\t\t\t    goto child_ok;\n\t\t    }\n\t\t    cont = elemDecl->content;\n\t\t    while (cont != NULL) {\n\t\t        if (cont->type == XML_ELEMENT_CONTENT_ELEMENT) {\n\t\t\t    if (xmlStrEqual(cont->name, name)) break;\n\t\t\t} else if ((cont->type == XML_ELEMENT_CONTENT_OR) &&\n\t\t\t   (cont->c1 != NULL) &&\n\t\t\t   (cont->c1->type == XML_ELEMENT_CONTENT_ELEMENT)) {\n\t\t\t    if (xmlStrEqual(cont->c1->name, name)) break;\n\t\t\t} else if ((cont->type != XML_ELEMENT_CONTENT_OR) ||\n\t\t\t    (cont->c1 == NULL) ||\n\t\t\t    (cont->c1->type != XML_ELEMENT_CONTENT_PCDATA)) {\n\t\t\t    xmlErrValid(ctxt, XML_DTD_MIXED_CORRUPT,\n\t\t\t\t    \"Internal: MIXED struct corrupted\\n\",\n\t\t\t\t    NULL);\n\t\t\t    break;\n\t\t\t}\n\t\t\tcont = cont->c2;\n\t\t    }\n\t\t    if (cont == NULL) {\n\t\t\txmlErrValidNode(ctxt, elem, XML_DTD_INVALID_CHILD,\n\t       \"Element %s is not declared in %s list of possible children\\n\",\n\t\t\t       name, elem->name, NULL);\n\t\t\tret = 0;\n\t\t    }\n\t\t}\nchild_ok:\n\t        child = child->next;\n\t    }\n\t    break;\n        case XML_ELEMENT_TYPE_ELEMENT:\n\t    if ((doc->standalone == 1) && (extsubset == 1)) {\n\t\t/*\n\t\t * VC: Standalone Document Declaration\n\t\t *     - element types with element content, if white space\n\t\t *       occurs directly within any instance of those types.\n\t\t */\n\t\tchild = elem->children;\n\t\twhile (child != NULL) {\n\t\t    if (child->type == XML_TEXT_NODE) {\n\t\t\tconst xmlChar *content = child->content;\n\n\t\t\twhile (IS_BLANK_CH(*content))\n\t\t\t    content++;\n\t\t\tif (*content == 0) {\n\t\t\t    xmlErrValidNode(ctxt, elem,\n\t\t\t                    XML_DTD_STANDALONE_WHITE_SPACE,\n\"standalone: %s declared in the external subset contains white spaces nodes\\n\",\n\t\t\t\t   elem->name, NULL, NULL);\n\t\t\t    ret = 0;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t    child =child->next;\n\t\t}\n\t    }\n\t    child = elem->children;\n\t    cont = elemDecl->content;\n\t    tmp = xmlValidateElementContent(ctxt, child, elemDecl, 1, elem);\n\t    if (tmp <= 0)\n\t\tret = tmp;\n\t    break;\n    }\n    } /* not continuous */\n\n    /* [ VC: Required Attribute ] */\n    attr = elemDecl->attributes;\n    while (attr != NULL) {\n\tif (attr->def == XML_ATTRIBUTE_REQUIRED) {\n\t    int qualified = -1;\n\n\t    if ((attr->prefix == NULL) &&\n\t\t(xmlStrEqual(attr->name, BAD_CAST \"xmlns\"))) {\n\t\txmlNsPtr ns;\n\n\t\tns = elem->nsDef;\n\t\twhile (ns != NULL) {\n\t\t    if (ns->prefix == NULL)\n\t\t\tgoto found;\n\t\t    ns = ns->next;\n\t\t}\n\t    } else if (xmlStrEqual(attr->prefix, BAD_CAST \"xmlns\")) {\n\t\txmlNsPtr ns;\n\n\t\tns = elem->nsDef;\n\t\twhile (ns != NULL) {\n\t\t    if (xmlStrEqual(attr->name, ns->prefix))\n\t\t\tgoto found;\n\t\t    ns = ns->next;\n\t\t}\n\t    } else {\n\t\txmlAttrPtr attrib;\n\n\t\tattrib = elem->properties;\n\t\twhile (attrib != NULL) {\n\t\t    if (xmlStrEqual(attrib->name, attr->name)) {\n\t\t\tif (attr->prefix != NULL) {\n\t\t\t    xmlNsPtr nameSpace = attrib->ns;\n\n\t\t\t    if (nameSpace == NULL)\n\t\t\t\tnameSpace = elem->ns;\n\t\t\t    /*\n\t\t\t     * qualified names handling is problematic, having a\n\t\t\t     * different prefix should be possible but DTDs don't\n\t\t\t     * allow to define the URI instead of the prefix :-(\n\t\t\t     */\n\t\t\t    if (nameSpace == NULL) {\n\t\t\t\tif (qualified < 0)\n\t\t\t\t    qualified = 0;\n\t\t\t    } else if (!xmlStrEqual(nameSpace->prefix,\n\t\t\t\t\t\t    attr->prefix)) {\n\t\t\t\tif (qualified < 1)\n\t\t\t\t    qualified = 1;\n\t\t\t    } else\n\t\t\t\tgoto found;\n\t\t\t} else {\n\t\t\t    /*\n\t\t\t     * We should allow applications to define namespaces\n\t\t\t     * for their application even if the DTD doesn't\n\t\t\t     * carry one, otherwise, basically we would always\n\t\t\t     * break.\n\t\t\t     */\n\t\t\t    goto found;\n\t\t\t}\n\t\t    }\n\t\t    attrib = attrib->next;\n\t\t}\n\t    }\n\t    if (qualified == -1) {\n\t\tif (attr->prefix == NULL) {\n\t\t    xmlErrValidNode(ctxt, elem, XML_DTD_MISSING_ATTRIBUTE,\n\t\t       \"Element %s does not carry attribute %s\\n\",\n\t\t\t   elem->name, attr->name, NULL);\n\t\t    ret = 0;\n\t        } else {\n\t\t    xmlErrValidNode(ctxt, elem, XML_DTD_MISSING_ATTRIBUTE,\n\t\t       \"Element %s does not carry attribute %s:%s\\n\",\n\t\t\t   elem->name, attr->prefix,attr->name);\n\t\t    ret = 0;\n\t\t}\n\t    } else if (qualified == 0) {\n\t\txmlErrValidWarning(ctxt, elem, XML_DTD_NO_PREFIX,\n\t\t   \"Element %s required attribute %s:%s has no prefix\\n\",\n\t\t       elem->name, attr->prefix, attr->name);\n\t    } else if (qualified == 1) {\n\t\txmlErrValidWarning(ctxt, elem, XML_DTD_DIFFERENT_PREFIX,\n\t\t   \"Element %s required attribute %s:%s has different prefix\\n\",\n\t\t       elem->name, attr->prefix, attr->name);\n\t    }\n\t} else if (attr->def == XML_ATTRIBUTE_FIXED) {\n\t    /*\n\t     * Special tests checking #FIXED namespace declarations\n\t     * have the right value since this is not done as an\n\t     * attribute checking\n\t     */\n\t    if ((attr->prefix == NULL) &&\n\t\t(xmlStrEqual(attr->name, BAD_CAST \"xmlns\"))) {\n\t\txmlNsPtr ns;\n\n\t\tns = elem->nsDef;\n\t\twhile (ns != NULL) {\n\t\t    if (ns->prefix == NULL) {\n\t\t\tif (!xmlStrEqual(attr->defaultValue, ns->href)) {\n\t\t\t    xmlErrValidNode(ctxt, elem,\n\t\t\t           XML_DTD_ELEM_DEFAULT_NAMESPACE,\n   \"Element %s namespace name for default namespace does not match the DTD\\n\",\n\t\t\t\t   elem->name, NULL, NULL);\n\t\t\t    ret = 0;\n\t\t\t}\n\t\t\tgoto found;\n\t\t    }\n\t\t    ns = ns->next;\n\t\t}\n\t    } else if (xmlStrEqual(attr->prefix, BAD_CAST \"xmlns\")) {\n\t\txmlNsPtr ns;\n\n\t\tns = elem->nsDef;\n\t\twhile (ns != NULL) {\n\t\t    if (xmlStrEqual(attr->name, ns->prefix)) {\n\t\t\tif (!xmlStrEqual(attr->defaultValue, ns->href)) {\n\t\t\t    xmlErrValidNode(ctxt, elem, XML_DTD_ELEM_NAMESPACE,\n\t\t   \"Element %s namespace name for %s does not match the DTD\\n\",\n\t\t\t\t   elem->name, ns->prefix, NULL);\n\t\t\t    ret = 0;\n\t\t\t}\n\t\t\tgoto found;\n\t\t    }\n\t\t    ns = ns->next;\n\t\t}\n\t    }\n\t}\nfound:\n        attr = attr->nexth;\n    }\n    return(ret);\n}\n\n/**\n * xmlValidateRoot:\n * @ctxt:  the validation context\n * @doc:  a document instance\n *\n * Try to validate a the root element\n * basically it does the following check as described by the\n * XML-1.0 recommendation:\n *  - [ VC: Root Element Type ]\n * it doesn't try to recurse or apply other check to the element\n *\n * returns 1 if valid or 0 otherwise\n */\n\nint\nxmlValidateRoot(xmlValidCtxtPtr ctxt, xmlDocPtr doc) {\n    xmlNodePtr root;\n    int ret;\n\n    if (doc == NULL) return(0);\n\n    root = xmlDocGetRootElement(doc);\n    if ((root == NULL) || (root->name == NULL)) {\n\txmlErrValid(ctxt, XML_DTD_NO_ROOT,\n\t            \"no root element\\n\", NULL);\n        return(0);\n    }\n\n    /*\n     * When doing post validation against a separate DTD, those may\n     * no internal subset has been generated\n     */\n    if ((doc->intSubset != NULL) &&\n\t(doc->intSubset->name != NULL)) {\n\t/*\n\t * Check first the document root against the NQName\n\t */\n\tif (!xmlStrEqual(doc->intSubset->name, root->name)) {\n\t    if ((root->ns != NULL) && (root->ns->prefix != NULL)) {\n\t\txmlChar fn[50];\n\t\txmlChar *fullname;\n\n\t\tfullname = xmlBuildQName(root->name, root->ns->prefix, fn, 50);\n\t\tif (fullname == NULL) {\n\t\t    xmlVErrMemory(ctxt, NULL);\n\t\t    return(0);\n\t\t}\n\t\tret = xmlStrEqual(doc->intSubset->name, fullname);\n\t\tif ((fullname != fn) && (fullname != root->name))\n\t\t    xmlFree(fullname);\n\t\tif (ret == 1)\n\t\t    goto name_ok;\n\t    }\n\t    if ((xmlStrEqual(doc->intSubset->name, BAD_CAST \"HTML\")) &&\n\t\t(xmlStrEqual(root->name, BAD_CAST \"html\")))\n\t\tgoto name_ok;\n\t    xmlErrValidNode(ctxt, root, XML_DTD_ROOT_NAME,\n\t\t   \"root and DTD name do not match '%s' and '%s'\\n\",\n\t\t   root->name, doc->intSubset->name, NULL);\n\t    return(0);\n\t}\n    }\nname_ok:\n    return(1);\n}\n\n\n/**\n * xmlValidateElement:\n * @ctxt:  the validation context\n * @doc:  a document instance\n * @elem:  an element instance\n *\n * Try to validate the subtree under an element\n *\n * returns 1 if valid or 0 otherwise\n */\n\nint\nxmlValidateElement(xmlValidCtxtPtr ctxt, xmlDocPtr doc, xmlNodePtr elem) {\n    xmlNodePtr child;\n    xmlAttrPtr attr;\n    xmlNsPtr ns;\n    const xmlChar *value;\n    int ret = 1;\n\n    if (elem == NULL) return(0);\n\n    /*\n     * XInclude elements were added after parsing in the infoset,\n     * they don't really mean anything validation wise.\n     */\n    if ((elem->type == XML_XINCLUDE_START) ||\n\t(elem->type == XML_XINCLUDE_END) ||\n\t(elem->type == XML_NAMESPACE_DECL))\n\treturn(1);\n\n    CHECK_DTD;\n\n    /*\n     * Entities references have to be handled separately\n     */\n    if (elem->type == XML_ENTITY_REF_NODE) {\n\treturn(1);\n    }\n\n    ret &= xmlValidateOneElement(ctxt, doc, elem);\n    if (elem->type == XML_ELEMENT_NODE) {\n\tattr = elem->properties;\n\twhile (attr != NULL) {\n\t    value = xmlNodeListGetString(doc, attr->children, 0);\n\t    ret &= xmlValidateOneAttribute(ctxt, doc, elem, attr, value);\n\t    if (value != NULL)\n\t\txmlFree((char *)value);\n\t    attr= attr->next;\n\t}\n\tns = elem->nsDef;\n\twhile (ns != NULL) {\n\t    if (elem->ns == NULL)\n\t\tret &= xmlValidateOneNamespace(ctxt, doc, elem, NULL,\n\t\t\t\t\t       ns, ns->href);\n\t    else\n\t\tret &= xmlValidateOneNamespace(ctxt, doc, elem,\n\t\t                               elem->ns->prefix, ns, ns->href);\n\t    ns = ns->next;\n\t}\n    }\n    child = elem->children;\n    while (child != NULL) {\n        ret &= xmlValidateElement(ctxt, doc, child);\n        child = child->next;\n    }\n\n    return(ret);\n}\n\n/**\n * xmlValidateRef:\n * @ref:   A reference to be validated\n * @ctxt:  Validation context\n * @name:  Name of ID we are searching for\n *\n */\nstatic void\nxmlValidateRef(xmlRefPtr ref, xmlValidCtxtPtr ctxt,\n\t                   const xmlChar *name) {\n    xmlAttrPtr id;\n    xmlAttrPtr attr;\n\n    if (ref == NULL)\n\treturn;\n    if ((ref->attr == NULL) && (ref->name == NULL))\n\treturn;\n    attr = ref->attr;\n    if (attr == NULL) {\n\txmlChar *dup, *str = NULL, *cur, save;\n\n\tdup = xmlStrdup(name);\n\tif (dup == NULL) {\n\t    ctxt->valid = 0;\n\t    return;\n\t}\n\tcur = dup;\n\twhile (*cur != 0) {\n\t    str = cur;\n\t    while ((*cur != 0) && (!IS_BLANK_CH(*cur))) cur++;\n\t    save = *cur;\n\t    *cur = 0;\n\t    id = xmlGetID(ctxt->doc, str);\n\t    if (id == NULL) {\n\t\txmlErrValidNodeNr(ctxt, NULL, XML_DTD_UNKNOWN_ID,\n\t   \"attribute %s line %d references an unknown ID \\\"%s\\\"\\n\",\n\t\t       ref->name, ref->lineno, str);\n\t\tctxt->valid = 0;\n\t    }\n\t    if (save == 0)\n\t\tbreak;\n\t    *cur = save;\n\t    while (IS_BLANK_CH(*cur)) cur++;\n\t}\n\txmlFree(dup);\n    } else if (attr->atype == XML_ATTRIBUTE_IDREF) {\n\tid = xmlGetID(ctxt->doc, name);\n\tif (id == NULL) {\n\t    xmlErrValidNode(ctxt, attr->parent, XML_DTD_UNKNOWN_ID,\n\t   \"IDREF attribute %s references an unknown ID \\\"%s\\\"\\n\",\n\t\t   attr->name, name, NULL);\n\t    ctxt->valid = 0;\n\t}\n    } else if (attr->atype == XML_ATTRIBUTE_IDREFS) {\n\txmlChar *dup, *str = NULL, *cur, save;\n\n\tdup = xmlStrdup(name);\n\tif (dup == NULL) {\n\t    xmlVErrMemory(ctxt, \"IDREFS split\");\n\t    ctxt->valid = 0;\n\t    return;\n\t}\n\tcur = dup;\n\twhile (*cur != 0) {\n\t    str = cur;\n\t    while ((*cur != 0) && (!IS_BLANK_CH(*cur))) cur++;\n\t    save = *cur;\n\t    *cur = 0;\n\t    id = xmlGetID(ctxt->doc, str);\n\t    if (id == NULL) {\n\t\txmlErrValidNode(ctxt, attr->parent, XML_DTD_UNKNOWN_ID,\n\t   \"IDREFS attribute %s references an unknown ID \\\"%s\\\"\\n\",\n\t\t\t     attr->name, str, NULL);\n\t\tctxt->valid = 0;\n\t    }\n\t    if (save == 0)\n\t\tbreak;\n\t    *cur = save;\n\t    while (IS_BLANK_CH(*cur)) cur++;\n\t}\n\txmlFree(dup);\n    }\n}\n\n/**\n * xmlWalkValidateList:\n * @data:  Contents of current link\n * @user:  Value supplied by the user\n *\n * Returns 0 to abort the walk or 1 to continue\n */\nstatic int\nxmlWalkValidateList(const void *data, void *user)\n{\n\txmlValidateMemoPtr memo = (xmlValidateMemoPtr)user;\n\txmlValidateRef((xmlRefPtr)data, memo->ctxt, memo->name);\n\treturn 1;\n}\n\n/**\n * xmlValidateCheckRefCallback:\n * @ref_list:  List of references\n * @ctxt:  Validation context\n * @name:  Name of ID we are searching for\n *\n */\nstatic void\nxmlValidateCheckRefCallback(void *payload, void *data, const xmlChar *name) {\n    xmlListPtr ref_list = (xmlListPtr) payload;\n    xmlValidCtxtPtr ctxt = (xmlValidCtxtPtr) data;\n    xmlValidateMemo memo;\n\n    if (ref_list == NULL)\n\treturn;\n    memo.ctxt = ctxt;\n    memo.name = name;\n\n    xmlListWalk(ref_list, xmlWalkValidateList, &memo);\n\n}\n\n/**\n * xmlValidateDocumentFinal:\n * @ctxt:  the validation context\n * @doc:  a document instance\n *\n * Does the final step for the document validation once all the\n * incremental validation steps have been completed\n *\n * basically it does the following checks described by the XML Rec\n *\n * Check all the IDREF/IDREFS attributes definition for validity\n *\n * returns 1 if valid or 0 otherwise\n */\n\nint\nxmlValidateDocumentFinal(xmlValidCtxtPtr ctxt, xmlDocPtr doc) {\n    xmlRefTablePtr table;\n    unsigned int save;\n\n    if (ctxt == NULL)\n        return(0);\n    if (doc == NULL) {\n        xmlErrValid(ctxt, XML_DTD_NO_DOC,\n\t\t\"xmlValidateDocumentFinal: doc == NULL\\n\", NULL);\n\treturn(0);\n    }\n\n    /* trick to get correct line id report */\n    save = ctxt->finishDtd;\n    ctxt->finishDtd = 0;\n\n    /*\n     * Check all the NOTATION/NOTATIONS attributes\n     */\n    /*\n     * Check all the ENTITY/ENTITIES attributes definition for validity\n     */\n    /*\n     * Check all the IDREF/IDREFS attributes definition for validity\n     */\n    table = (xmlRefTablePtr) doc->refs;\n    ctxt->doc = doc;\n    ctxt->valid = 1;\n    xmlHashScan(table, xmlValidateCheckRefCallback, ctxt);\n\n    ctxt->finishDtd = save;\n    return(ctxt->valid);\n}\n\n/**\n * xmlValidateDtd:\n * @ctxt:  the validation context\n * @doc:  a document instance\n * @dtd:  a dtd instance\n *\n * Try to validate the document against the dtd instance\n *\n * Basically it does check all the definitions in the DtD.\n * Note the the internal subset (if present) is de-coupled\n * (i.e. not used), which could give problems if ID or IDREF\n * is present.\n *\n * returns 1 if valid or 0 otherwise\n */\n\nint\nxmlValidateDtd(xmlValidCtxtPtr ctxt, xmlDocPtr doc, xmlDtdPtr dtd) {\n    int ret;\n    xmlDtdPtr oldExt, oldInt;\n    xmlNodePtr root;\n\n    if (dtd == NULL) return(0);\n    if (doc == NULL) return(0);\n    oldExt = doc->extSubset;\n    oldInt = doc->intSubset;\n    doc->extSubset = dtd;\n    doc->intSubset = NULL;\n    ret = xmlValidateRoot(ctxt, doc);\n    if (ret == 0) {\n\tdoc->extSubset = oldExt;\n\tdoc->intSubset = oldInt;\n\treturn(ret);\n    }\n    if (doc->ids != NULL) {\n          xmlFreeIDTable(doc->ids);\n          doc->ids = NULL;\n    }\n    if (doc->refs != NULL) {\n          xmlFreeRefTable(doc->refs);\n          doc->refs = NULL;\n    }\n    root = xmlDocGetRootElement(doc);\n    ret = xmlValidateElement(ctxt, doc, root);\n    ret &= xmlValidateDocumentFinal(ctxt, doc);\n    doc->extSubset = oldExt;\n    doc->intSubset = oldInt;\n    return(ret);\n}\n\nstatic void\nxmlValidateNotationCallback(void *payload, void *data,\n\t                    const xmlChar *name ATTRIBUTE_UNUSED) {\n    xmlEntityPtr cur = (xmlEntityPtr) payload;\n    xmlValidCtxtPtr ctxt = (xmlValidCtxtPtr) data;\n    if (cur == NULL)\n\treturn;\n    if (cur->etype == XML_EXTERNAL_GENERAL_UNPARSED_ENTITY) {\n\txmlChar *notation = cur->content;\n\n\tif (notation != NULL) {\n\t    int ret;\n\n\t    ret = xmlValidateNotationUse(ctxt, cur->doc, notation);\n\t    if (ret != 1) {\n\t\tctxt->valid = 0;\n\t    }\n\t}\n    }\n}\n\nstatic void\nxmlValidateAttributeCallback(void *payload, void *data,\n\t                     const xmlChar *name ATTRIBUTE_UNUSED) {\n    xmlAttributePtr cur = (xmlAttributePtr) payload;\n    xmlValidCtxtPtr ctxt = (xmlValidCtxtPtr) data;\n    int ret;\n    xmlDocPtr doc;\n    xmlElementPtr elem = NULL;\n\n    if (cur == NULL)\n\treturn;\n    switch (cur->atype) {\n\tcase XML_ATTRIBUTE_CDATA:\n\tcase XML_ATTRIBUTE_ID:\n\tcase XML_ATTRIBUTE_IDREF\t:\n\tcase XML_ATTRIBUTE_IDREFS:\n\tcase XML_ATTRIBUTE_NMTOKEN:\n\tcase XML_ATTRIBUTE_NMTOKENS:\n\tcase XML_ATTRIBUTE_ENUMERATION:\n\t    break;\n\tcase XML_ATTRIBUTE_ENTITY:\n\tcase XML_ATTRIBUTE_ENTITIES:\n\tcase XML_ATTRIBUTE_NOTATION:\n\t    if (cur->defaultValue != NULL) {\n\n\t\tret = xmlValidateAttributeValue2(ctxt, ctxt->doc, cur->name,\n\t\t\t                         cur->atype, cur->defaultValue);\n\t\tif ((ret == 0) && (ctxt->valid == 1))\n\t\t    ctxt->valid = 0;\n\t    }\n\t    if (cur->tree != NULL) {\n\t\txmlEnumerationPtr tree = cur->tree;\n\t\twhile (tree != NULL) {\n\t\t    ret = xmlValidateAttributeValue2(ctxt, ctxt->doc,\n\t\t\t\t    cur->name, cur->atype, tree->name);\n\t\t    if ((ret == 0) && (ctxt->valid == 1))\n\t\t\tctxt->valid = 0;\n\t\t    tree = tree->next;\n\t\t}\n\t    }\n    }\n    if (cur->atype == XML_ATTRIBUTE_NOTATION) {\n\tdoc = cur->doc;\n\tif (cur->elem == NULL) {\n\t    xmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,\n\t\t   \"xmlValidateAttributeCallback(%s): internal error\\n\",\n\t\t   (const char *) cur->name);\n\t    return;\n\t}\n\n\tif (doc != NULL)\n\t    elem = xmlGetDtdElementDesc(doc->intSubset, cur->elem);\n\tif ((elem == NULL) && (doc != NULL))\n\t    elem = xmlGetDtdElementDesc(doc->extSubset, cur->elem);\n\tif ((elem == NULL) && (cur->parent != NULL) &&\n\t    (cur->parent->type == XML_DTD_NODE))\n\t    elem = xmlGetDtdElementDesc((xmlDtdPtr) cur->parent, cur->elem);\n\tif (elem == NULL) {\n\t    xmlErrValidNode(ctxt, NULL, XML_DTD_UNKNOWN_ELEM,\n\t\t   \"attribute %s: could not find decl for element %s\\n\",\n\t\t   cur->name, cur->elem, NULL);\n\t    return;\n\t}\n\tif (elem->etype == XML_ELEMENT_TYPE_EMPTY) {\n\t    xmlErrValidNode(ctxt, NULL, XML_DTD_EMPTY_NOTATION,\n\t\t   \"NOTATION attribute %s declared for EMPTY element %s\\n\",\n\t\t   cur->name, cur->elem, NULL);\n\t    ctxt->valid = 0;\n\t}\n    }\n}\n\n/**\n * xmlValidateDtdFinal:\n * @ctxt:  the validation context\n * @doc:  a document instance\n *\n * Does the final step for the dtds validation once all the\n * subsets have been parsed\n *\n * basically it does the following checks described by the XML Rec\n * - check that ENTITY and ENTITIES type attributes default or\n *   possible values matches one of the defined entities.\n * - check that NOTATION type attributes default or\n *   possible values matches one of the defined notations.\n *\n * returns 1 if valid or 0 if invalid and -1 if not well-formed\n */\n\nint\nxmlValidateDtdFinal(xmlValidCtxtPtr ctxt, xmlDocPtr doc) {\n    xmlDtdPtr dtd;\n    xmlAttributeTablePtr table;\n    xmlEntitiesTablePtr entities;\n\n    if ((doc == NULL) || (ctxt == NULL)) return(0);\n    if ((doc->intSubset == NULL) && (doc->extSubset == NULL))\n\treturn(0);\n    ctxt->doc = doc;\n    ctxt->valid = 1;\n    dtd = doc->intSubset;\n    if ((dtd != NULL) && (dtd->attributes != NULL)) {\n\ttable = (xmlAttributeTablePtr) dtd->attributes;\n\txmlHashScan(table, xmlValidateAttributeCallback, ctxt);\n    }\n    if ((dtd != NULL) && (dtd->entities != NULL)) {\n\tentities = (xmlEntitiesTablePtr) dtd->entities;\n\txmlHashScan(entities, xmlValidateNotationCallback, ctxt);\n    }\n    dtd = doc->extSubset;\n    if ((dtd != NULL) && (dtd->attributes != NULL)) {\n\ttable = (xmlAttributeTablePtr) dtd->attributes;\n\txmlHashScan(table, xmlValidateAttributeCallback, ctxt);\n    }\n    if ((dtd != NULL) && (dtd->entities != NULL)) {\n\tentities = (xmlEntitiesTablePtr) dtd->entities;\n\txmlHashScan(entities, xmlValidateNotationCallback, ctxt);\n    }\n    return(ctxt->valid);\n}\n\n/**\n * xmlValidateDocument:\n * @ctxt:  the validation context\n * @doc:  a document instance\n *\n * Try to validate the document instance\n *\n * basically it does the all the checks described by the XML Rec\n * i.e. validates the internal and external subset (if present)\n * and validate the document tree.\n *\n * returns 1 if valid or 0 otherwise\n */\n\nint\nxmlValidateDocument(xmlValidCtxtPtr ctxt, xmlDocPtr doc) {\n    int ret;\n    xmlNodePtr root;\n\n    if (doc == NULL)\n        return(0);\n    if ((doc->intSubset == NULL) && (doc->extSubset == NULL)) {\n        xmlErrValid(ctxt, XML_DTD_NO_DTD,\n\t            \"no DTD found!\\n\", NULL);\n\treturn(0);\n    }\n    if ((doc->intSubset != NULL) && ((doc->intSubset->SystemID != NULL) ||\n\t(doc->intSubset->ExternalID != NULL)) && (doc->extSubset == NULL)) {\n\txmlChar *sysID;\n\tif (doc->intSubset->SystemID != NULL) {\n\t    sysID = xmlBuildURI(doc->intSubset->SystemID,\n\t\t\tdoc->URL);\n\t    if (sysID == NULL) {\n\t        xmlErrValid(ctxt, XML_DTD_LOAD_ERROR,\n\t\t\t\"Could not build URI for external subset \\\"%s\\\"\\n\",\n\t\t\t(const char *) doc->intSubset->SystemID);\n\t\treturn 0;\n\t    }\n\t} else\n\t    sysID = NULL;\n        doc->extSubset = xmlParseDTD(doc->intSubset->ExternalID,\n\t\t\t(const xmlChar *)sysID);\n\tif (sysID != NULL)\n\t    xmlFree(sysID);\n        if (doc->extSubset == NULL) {\n\t    if (doc->intSubset->SystemID != NULL) {\n\t\txmlErrValid(ctxt, XML_DTD_LOAD_ERROR,\n\t\t       \"Could not load the external subset \\\"%s\\\"\\n\",\n\t\t       (const char *) doc->intSubset->SystemID);\n\t    } else {\n\t\txmlErrValid(ctxt, XML_DTD_LOAD_ERROR,\n\t\t       \"Could not load the external subset \\\"%s\\\"\\n\",\n\t\t       (const char *) doc->intSubset->ExternalID);\n\t    }\n\t    return(0);\n\t}\n    }\n\n    if (doc->ids != NULL) {\n          xmlFreeIDTable(doc->ids);\n          doc->ids = NULL;\n    }\n    if (doc->refs != NULL) {\n          xmlFreeRefTable(doc->refs);\n          doc->refs = NULL;\n    }\n    ret = xmlValidateDtdFinal(ctxt, doc);\n    if (!xmlValidateRoot(ctxt, doc)) return(0);\n\n    root = xmlDocGetRootElement(doc);\n    ret &= xmlValidateElement(ctxt, doc, root);\n    ret &= xmlValidateDocumentFinal(ctxt, doc);\n    return(ret);\n}\n\n/************************************************************************\n *\t\t\t\t\t\t\t\t\t*\n *\t\tRoutines for dynamic validation editing\t\t\t*\n *\t\t\t\t\t\t\t\t\t*\n ************************************************************************/\n\n/**\n * xmlValidGetPotentialChildren:\n * @ctree:  an element content tree\n * @names:  an array to store the list of child names\n * @len:  a pointer to the number of element in the list\n * @max:  the size of the array\n *\n * Build/extend a list of  potential children allowed by the content tree\n *\n * returns the number of element in the list, or -1 in case of error.\n */\n\nint\nxmlValidGetPotentialChildren(xmlElementContent *ctree,\n                             const xmlChar **names,\n                             int *len, int max) {\n    int i;\n\n    if ((ctree == NULL) || (names == NULL) || (len == NULL))\n        return(-1);\n    if (*len >= max) return(*len);\n\n    switch (ctree->type) {\n\tcase XML_ELEMENT_CONTENT_PCDATA:\n\t    for (i = 0; i < *len;i++)\n\t\tif (xmlStrEqual(BAD_CAST \"#PCDATA\", names[i])) return(*len);\n\t    names[(*len)++] = BAD_CAST \"#PCDATA\";\n\t    break;\n\tcase XML_ELEMENT_CONTENT_ELEMENT:\n\t    for (i = 0; i < *len;i++)\n\t\tif (xmlStrEqual(ctree->name, names[i])) return(*len);\n\t    names[(*len)++] = ctree->name;\n\t    break;\n\tcase XML_ELEMENT_CONTENT_SEQ:\n\t    xmlValidGetPotentialChildren(ctree->c1, names, len, max);\n\t    xmlValidGetPotentialChildren(ctree->c2, names, len, max);\n\t    break;\n\tcase XML_ELEMENT_CONTENT_OR:\n\t    xmlValidGetPotentialChildren(ctree->c1, names, len, max);\n\t    xmlValidGetPotentialChildren(ctree->c2, names, len, max);\n\t    break;\n   }\n\n   return(*len);\n}\n\n/*\n * Dummy function to suppress messages while we try out valid elements\n */\nstatic void XMLCDECL xmlNoValidityErr(void *ctx ATTRIBUTE_UNUSED,\n                                const char *msg ATTRIBUTE_UNUSED, ...) {\n    return;\n}\n\n/**\n * xmlValidGetValidElements:\n * @prev:  an element to insert after\n * @next:  an element to insert next\n * @names:  an array to store the list of child names\n * @max:  the size of the array\n *\n * This function returns the list of authorized children to insert\n * within an existing tree while respecting the validity constraints\n * forced by the Dtd. The insertion point is defined using @prev and\n * @next in the following ways:\n *  to insert before 'node': xmlValidGetValidElements(node->prev, node, ...\n *  to insert next 'node': xmlValidGetValidElements(node, node->next, ...\n *  to replace 'node': xmlValidGetValidElements(node->prev, node->next, ...\n *  to prepend a child to 'node': xmlValidGetValidElements(NULL, node->childs,\n *  to append a child to 'node': xmlValidGetValidElements(node->last, NULL, ...\n *\n * pointers to the element names are inserted at the beginning of the array\n * and do not need to be freed.\n *\n * returns the number of element in the list, or -1 in case of error. If\n *    the function returns the value @max the caller is invited to grow the\n *    receiving array and retry.\n */\n\nint\nxmlValidGetValidElements(xmlNode *prev, xmlNode *next, const xmlChar **names,\n                         int max) {\n    xmlValidCtxt vctxt;\n    int nb_valid_elements = 0;\n    const xmlChar *elements[256]={0};\n    int nb_elements = 0, i;\n    const xmlChar *name;\n\n    xmlNode *ref_node;\n    xmlNode *parent;\n    xmlNode *test_node;\n\n    xmlNode *prev_next;\n    xmlNode *next_prev;\n    xmlNode *parent_childs;\n    xmlNode *parent_last;\n\n    xmlElement *element_desc;\n\n    if (prev == NULL && next == NULL)\n        return(-1);\n\n    if (names == NULL) return(-1);\n    if (max <= 0) return(-1);\n\n    memset(&vctxt, 0, sizeof (xmlValidCtxt));\n    vctxt.error = xmlNoValidityErr;\t/* this suppresses err/warn output */\n\n    nb_valid_elements = 0;\n    ref_node = prev ? prev : next;\n    parent = ref_node->parent;\n\n    /*\n     * Retrieves the parent element declaration\n     */\n    element_desc = xmlGetDtdElementDesc(parent->doc->intSubset,\n                                         parent->name);\n    if ((element_desc == NULL) && (parent->doc->extSubset != NULL))\n        element_desc = xmlGetDtdElementDesc(parent->doc->extSubset,\n                                             parent->name);\n    if (element_desc == NULL) return(-1);\n\n    /*\n     * Do a backup of the current tree structure\n     */\n    prev_next = prev ? prev->next : NULL;\n    next_prev = next ? next->prev : NULL;\n    parent_childs = parent->children;\n    parent_last = parent->last;\n\n    /*\n     * Creates a dummy node and insert it into the tree\n     */\n    test_node = xmlNewDocNode (ref_node->doc, NULL, BAD_CAST \"<!dummy?>\", NULL);\n    if (test_node == NULL)\n        return(-1);\n\n    test_node->parent = parent;\n    test_node->prev = prev;\n    test_node->next = next;\n    name = test_node->name;\n\n    if (prev) prev->next = test_node;\n    else parent->children = test_node;\n\n    if (next) next->prev = test_node;\n    else parent->last = test_node;\n\n    /*\n     * Insert each potential child node and check if the parent is\n     * still valid\n     */\n    nb_elements = xmlValidGetPotentialChildren(element_desc->content,\n\t\t       elements, &nb_elements, 256);\n\n    for (i = 0;i < nb_elements;i++) {\n\ttest_node->name = elements[i];\n\tif (xmlValidateOneElement(&vctxt, parent->doc, parent)) {\n\t    int j;\n\n\t    for (j = 0; j < nb_valid_elements;j++)\n\t\tif (xmlStrEqual(elements[i], names[j])) break;\n\t    names[nb_valid_elements++] = elements[i];\n\t    if (nb_valid_elements >= max) break;\n\t}\n    }\n\n    /*\n     * Restore the tree structure\n     */\n    if (prev) prev->next = prev_next;\n    if (next) next->prev = next_prev;\n    parent->children = parent_childs;\n    parent->last = parent_last;\n\n    /*\n     * Free up the dummy node\n     */\n    test_node->name = name;\n    xmlFreeNode(test_node);\n\n    return(nb_valid_elements);\n}\n#endif /* LIBXML_VALID_ENABLED */\n\n#define bottom_valid\n#include \"elfgcchack.h\"\n"], "filenames": ["result/XInclude/ns1.xml.rdr", "valid.c"], "buggy_code_start_loc": [4, 479], "buggy_code_end_loc": [5, 4161], "fixing_code_start_loc": [4, 480], "fixing_code_end_loc": [5, 4183], "type": "CWE-416", "message": "valid.c in libxml2 before 2.9.13 has a use-after-free of ID and IDREF attributes.", "other": {"cve": {"id": "CVE-2022-23308", "sourceIdentifier": "cve@mitre.org", "published": "2022-02-26T05:15:08.280", "lastModified": "2022-11-02T13:18:35.983", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "valid.c in libxml2 before 2.9.13 has a use-after-free of ID and IDREF attributes."}, {"lang": "es", "value": "El archivo valid.c en libxml2 versiones anteriores a 2.9.13, presenta un uso de memoria previamente liberada de los atributos ID e IDREF.\n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:xmlsoft:libxml2:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.9.13", "matchCriteriaId": "75F3B6C3-9C14-4576-BF39-4A1D774A0979"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:apple:ipados:*:*:*:*:*:*:*:*", "versionEndExcluding": "15.5", "matchCriteriaId": "5B3F8579-F907-4E15-A4D6-1459A6687594"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:iphone_os:*:*:*:*:*:*:*:*", "versionEndExcluding": "15.5", "matchCriteriaId": "29151647-DA19-4B1B-B1CD-2E05A712F941"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:mac_os_x:*:*:*:*:*:*:*:*", "versionStartIncluding": "10.15.0", "versionEndExcluding": "10.15.7", "matchCriteriaId": "1632ED85-FDBF-4E46-AF1A-15594CC8E946"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:mac_os_x:10.15.7:*:*:*:*:*:*:*", "matchCriteriaId": "89161D20-EB9C-4EC0-8D82-75B27CE49264"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:mac_os_x:10.15.7:security_update_2020-001:*:*:*:*:*:*", "matchCriteriaId": "F1F4BF7F-90D4-4668-B4E6-B06F4070F448"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:mac_os_x:10.15.7:security_update_2021-001:*:*:*:*:*:*", "matchCriteriaId": "0F441A43-1669-478D-9EC8-E96882DE4F9F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:mac_os_x:10.15.7:security_update_2021-002:*:*:*:*:*:*", "matchCriteriaId": "D425C653-37A2-448C-BF2F-B684ADB08A26"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:mac_os_x:10.15.7:security_update_2021-003:*:*:*:*:*:*", "matchCriteriaId": "A54D63B7-B92B-47C3-B1C5-9892E5873A98"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:mac_os_x:10.15.7:security_update_2021-004:*:*:*:*:*:*", "matchCriteriaId": "3456176F-9185-4EE2-A8CE-3D989D674AB7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:mac_os_x:10.15.7:security_update_2021-005:*:*:*:*:*:*", "matchCriteriaId": "D337EE21-2F00-484D-9285-F2B0248D7A19"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:mac_os_x:10.15.7:security_update_2021-006:*:*:*:*:*:*", "matchCriteriaId": "012052B5-9AA7-4FD3-9C80-5F615330039D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:mac_os_x:10.15.7:security_update_2021-007:*:*:*:*:*:*", "matchCriteriaId": "50F21A3C-0AC3-48C5-A4F8-5A7B478875B4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:mac_os_x:10.15.7:security_update_2021-008:*:*:*:*:*:*", "matchCriteriaId": "8E974DC6-F7D9-4389-9AF9-863F6E419CE6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:mac_os_x:10.15.7:security_update_2022-001:*:*:*:*:*:*", "matchCriteriaId": "156A6382-2BD3-4882-90B2-8E7CF6659E17"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:mac_os_x:10.15.7:security_update_2022-003:*:*:*:*:*:*", "matchCriteriaId": "49F537A0-DC42-4176-B22F-C80D179DD99D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:macos:*:*:*:*:*:*:*:*", "versionStartIncluding": "11.6.0", "versionEndExcluding": "11.6.6", "matchCriteriaId": "787E02EF-92F4-46E6-BB1E-0BF49C50A096"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:macos:*:*:*:*:*:*:*:*", "versionStartIncluding": "12.0", "versionEndExcluding": "12.4", "matchCriteriaId": "35154201-43EA-4C22-B0BA-D1A24C46D320"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:tvos:*:*:*:*:*:*:*:*", "versionEndExcluding": "15.5", "matchCriteriaId": "4C98BE9E-8463-4CB9-8E42-A68DC0B20BD8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:watchos:*:*:*:*:*:*:*:*", "versionEndExcluding": "8.6", "matchCriteriaId": "E8BAAD78-60FC-4EC3-B727-55F0C0969D6A"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:active_iq_unified_manager:-:*:*:*:*:vmware_vsphere:*:*", "matchCriteriaId": "3A756737-1CC4-42C2-A4DF-E1C893B4E2D5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:clustered_data_ontap:-:*:*:*:*:*:*:*", "matchCriteriaId": "1FE996B1-6951-4F85-AA58-B99A379D2163"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:clustered_data_ontap_antivirus_connector:-:*:*:*:*:*:*:*", "matchCriteriaId": "62347994-1353-497C-9C4A-D5D8D95F67E8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:manageability_software_development_kit:-:*:*:*:*:*:*:*", "matchCriteriaId": "D39DCAE7-494F-40B2-867F-6C6A077939DD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:ontap_select_deploy_administration_utility:-:*:*:*:*:*:*:*", "matchCriteriaId": "E7CF3019-975D-40BB-A8A4-894E62BD3797"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:smi-s_provider:-:*:*:*:*:*:*:*", "matchCriteriaId": "4BB0FDCF-3750-44C6-AC5C-0CC2AAD14093"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:snapdrive:-:*:*:*:*:unix:*:*", "matchCriteriaId": "61D7EF01-F618-497F-9375-8003CEA3D380"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:snapmanager:-:*:*:*:*:oracle:*:*", "matchCriteriaId": "26A2B713-7D6D-420A-93A4-E0D983C983DF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:solidfire\\,_enterprise_sds_\\&_hci_storage_node:-:*:*:*:*:*:*:*", "matchCriteriaId": "DAA3919C-B2B1-4CB5-BA76-7A079AAFFC52"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:solidfire_\\&_hci_management_node:-:*:*:*:*:*:*:*", "matchCriteriaId": "D6D700C5-F67F-4FFB-BE69-D524592A3D2E"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:bootstrap_os:-:*:*:*:*:*:*:*", "matchCriteriaId": "95BA156C-C977-4F0C-8DFB-3FAE9CC8C02D"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:hci_compute_node:-:*:*:*:*:*:*:*", "matchCriteriaId": "AD7447BC-F315-4298-A822-549942FC118B"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h300s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "6770B6C3-732E-4E22-BF1C-2D2FD610061C"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h300s:-:*:*:*:*:*:*:*", "matchCriteriaId": "9F9C8C20-42EB-4AB5-BD97-212DEB070C43"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h500s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "7FFF7106-ED78-49BA-9EC5-B889E3685D53"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h500s:-:*:*:*:*:*:*:*", "matchCriteriaId": "E63D8B0F-006E-4801-BF9D-1C001BBFB4F9"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h700s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "56409CEC-5A1E-4450-AA42-641E459CC2AF"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h700s:-:*:*:*:*:*:*:*", "matchCriteriaId": "B06F4839-D16A-4A61-9BB5-55B13F41E47F"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h300e_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "108A2215-50FB-4074-94CF-C130FA14566D"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h300e:-:*:*:*:*:*:*:*", "matchCriteriaId": "7AFC73CE-ABB9-42D3-9A71-3F5BC5381E0E"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h500e_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "32F0B6C0-F930-480D-962B-3F4EFDCC13C7"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h500e:-:*:*:*:*:*:*:*", "matchCriteriaId": "803BC414-B250-4E3A-A478-A3881340D6B8"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h700e_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "0FEB3337-BFDE-462A-908B-176F92053CEC"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h700e:-:*:*:*:*:*:*:*", "matchCriteriaId": "736AEAE9-782B-4F71-9893-DED53367E102"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h410s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "D0B4AD8A-F172-4558-AEC6-FF424BA2D912"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h410s:-:*:*:*:*:*:*:*", "matchCriteriaId": "8497A4C9-8474-4A62-8331-3FE862ED4098"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h410c_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "234DEFE0-5CE5-4B0A-96B8-5D227CB8ED31"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h410c:-:*:*:*:*:*:*:*", "matchCriteriaId": "CDDF61B7-EC5C-467C-B710-B89F502CD04F"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_cloud_native_core_binding_support_function:22.2.0:*:*:*:*:*:*:*", "matchCriteriaId": "FEA64107-8025-4DC7-8222-F898ADEC6864"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_cloud_native_core_network_function_cloud_native_environment:22.1.0:*:*:*:*:*:*:*", "matchCriteriaId": "04E6C8E9-2024-496C-9BFD-4548A5B44E2E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_cloud_native_core_network_repository_function:22.1.2:*:*:*:*:*:*:*", "matchCriteriaId": "A264E0DE-209D-49B1-8B26-51AB8BBC97F1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_cloud_native_core_network_repository_function:22.2.0:*:*:*:*:*:*:*", "matchCriteriaId": "EBB5FF32-7362-4A1E-AD24-EF6B8770FCAD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_cloud_native_core_network_slice_selection_function:22.1.1:*:*:*:*:*:*:*", "matchCriteriaId": "4F4637E5-3324-441D-94E9-C2DBE9A6B502"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_cloud_native_core_unified_data_repository:22.2.0:*:*:*:*:*:*:*", "matchCriteriaId": "74810125-09E6-4F27-B541-AFB61112AC56"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:mysql_workbench:*:*:*:*:*:*:*:*", "versionEndIncluding": "8.0.29", "matchCriteriaId": "76CA1C43-5BEC-4ABF-9E0A-E55D6C8311AB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:zfs_storage_appliance_kit:8.8:*:*:*:*:*:*:*", "matchCriteriaId": "D3E503FB-6279-4D4A-91D8-E237ECF9D2B0"}]}]}], "references": [{"url": "http://seclists.org/fulldisclosure/2022/May/33", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://seclists.org/fulldisclosure/2022/May/34", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://seclists.org/fulldisclosure/2022/May/35", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://seclists.org/fulldisclosure/2022/May/36", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://seclists.org/fulldisclosure/2022/May/37", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://seclists.org/fulldisclosure/2022/May/38", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/GNOME/libxml2/commit/652dd12a858989b14eed4e84e453059cd3ba340e", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://gitlab.gnome.org/GNOME/libxml2/-/blob/v2.9.13/NEWS", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/04/msg00004.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/LA3MWWAYZADWJ5F6JOUBX65UZAMQB7RF/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202210-03", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20220331-0008/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://support.apple.com/kb/HT213253", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://support.apple.com/kb/HT213254", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://support.apple.com/kb/HT213255", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://support.apple.com/kb/HT213256", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://support.apple.com/kb/HT213257", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://support.apple.com/kb/HT213258", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpujul2022.html", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/GNOME/libxml2/commit/652dd12a858989b14eed4e84e453059cd3ba340e"}}