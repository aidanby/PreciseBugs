{"buggy_code": ["import type { IObjectOf } from \"@thi.ng/api\";\nimport { maybeParseFloat, maybeParseInt, unescape } from \"@thi.ng/strings\";\nimport { base64Decode } from \"@thi.ng/transducers-binary\";\nimport { execSync } from \"child_process\";\nimport { readFileSync } from \"fs\";\nimport { resolve as resolvePath } from \"path\";\nimport { IS_NODE, NODE_ONLY, TagParser } from \"./api\";\n\nexport const BUILTINS: IObjectOf<TagParser> = {\n    base64: IS_NODE\n        ? (_, body) => Buffer.from(body, \"base64\")\n        : (_, body) => new Uint8Array([...base64Decode(body)]),\n    date: (_, body) => new Date(body),\n    file: (_, path, ctx) => {\n        if (IS_NODE && ctx.opts.includes) {\n            path = resolvePath(ctx.opts.root!, unescape(path));\n            ctx.logger.debug(\"loading value from:\", path);\n            return readFileSync(path).toString();\n        } else {\n            ctx.logger.debug(\"skipping file value:\", path);\n            return path;\n        }\n    },\n    gpg: IS_NODE\n        ? (_, body, ctx) =>\n              (ctx.opts.decrypt\n                  ? execSync(`echo \"${body}\" | gpg --decrypt`).toString()\n                  : body\n              ).trim()\n        : NODE_ONLY,\n    hex: (_, body) => maybeParseInt(body, 0, 16),\n    json: (_, body) => JSON.parse(unescape(body)),\n    list: (_, body) => body.split(/[\\n\\r\\t ]+/g).map(unescape),\n    num: (_, body) => maybeParseFloat(body, 0),\n};\n"], "fixing_code": ["import type { IObjectOf } from \"@thi.ng/api\";\nimport { maybeParseFloat, maybeParseInt, unescape } from \"@thi.ng/strings\";\nimport { base64Decode } from \"@thi.ng/transducers-binary\";\nimport { execFileSync } from \"child_process\";\nimport { readFileSync } from \"fs\";\nimport { resolve as resolvePath } from \"path\";\nimport { IS_NODE, NODE_ONLY, TagParser } from \"./api\";\n\nexport const BUILTINS: IObjectOf<TagParser> = {\n    base64: IS_NODE\n        ? (_, body) => Buffer.from(body, \"base64\")\n        : (_, body) => new Uint8Array([...base64Decode(body)]),\n    date: (_, body) => new Date(body),\n    file: (_, path, ctx) => {\n        if (IS_NODE && ctx.opts.includes) {\n            path = resolvePath(ctx.opts.root!, unescape(path));\n            ctx.logger.debug(\"loading value from:\", path);\n            return readFileSync(path).toString();\n        } else {\n            ctx.logger.debug(\"skipping file value:\", path);\n            return path;\n        }\n    },\n    gpg: IS_NODE\n        ? (_, body, ctx) =>\n              (ctx.opts.decrypt\n                  ? execFileSync(\"gpg\", [\"--decrypt\"], {\n                        input: body,\n                    }).toString()\n                  : body\n              ).trim()\n        : NODE_ONLY,\n    hex: (_, body) => maybeParseInt(body, 0, 16),\n    json: (_, body) => JSON.parse(unescape(body)),\n    list: (_, body) => body.split(/[\\n\\r\\t ]+/g).map(unescape),\n    num: (_, body) => maybeParseFloat(body, 0),\n};\n"], "filenames": ["packages/egf/src/tags.ts"], "buggy_code_start_loc": [4], "buggy_code_end_loc": [28], "fixing_code_start_loc": [4], "fixing_code_end_loc": [30], "type": "CWE-78", "message": "Potential for arbitrary code execution in npm package @thi.ng/egf `#gpg`-tagged property values (only if `decrypt: true` option is enabled). PR with patch has been submitted and will has been released as of v0.4.0 By default the EGF parse functions do NOT attempt to decrypt values (since GPG only available in non-browser env). However, if GPG encrypted values are used/required: 1. Perform a regex search for `#gpg`-tagged values in the EGF source file/string and check for backtick (\\`) chars in the encrypted value string 2. Replace/remove them or skip parsing if present.", "other": {"cve": {"id": "CVE-2021-21412", "sourceIdentifier": "security-advisories@github.com", "published": "2021-03-30T18:15:15.840", "lastModified": "2021-04-02T19:00:29.997", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Potential for arbitrary code execution in npm package @thi.ng/egf `#gpg`-tagged property values (only if `decrypt: true` option is enabled). PR with patch has been submitted and will has been released as of v0.4.0 By default the EGF parse functions do NOT attempt to decrypt values (since GPG only available in non-browser env). However, if GPG encrypted values are used/required: 1. Perform a regex search for `#gpg`-tagged values in the EGF source file/string and check for backtick (\\`) chars in the encrypted value string 2. Replace/remove them or skip parsing if present."}, {"lang": "es", "value": "Un potencial para una ejecuci\u00f3n de c\u00f3digo arbitraria en los valores de propiedad `#gpg`-tagged de @thi.ng/egf del paquete npm (solo si la opci\u00f3n `decrypt: true` est\u00e1 habilitada).&#xa0;Se ha enviado el PR con parche y se lanzar\u00e1 a partir de la versi\u00f3n v0.4.0 Por defecto, las funciones de an\u00e1lisis de EGF NO intentan descifrar valores (ya que GPG solo est\u00e1 disponible en entornos que no son del navegador).&#xa0;Sin embargo, si los valores cifrados GPG son usados o requeridos: 1. Realice una b\u00fasqueda de expresiones regulares para los valores `#gpg`-tagged en el archivo o cadena de origen EGF y compruebe los caracteres de comillas invertidas (\\`) en la cadena de valores cifrados 2. Reemplace u omita el an\u00e1lisis sint\u00e1ctico si est\u00e1 presente."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.1, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-78"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:\\@thi.ng\\/egf_project:\\@thi.ng\\/egf:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "0.4.0", "matchCriteriaId": "1E041F81-B590-4D49-8173-368C0F6AA0BF"}]}]}], "references": [{"url": "https://github.com/thi-ng/umbrella/blob/develop/packages/egf/CHANGELOG.md#040-2021-03-27", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/thi-ng/umbrella/commit/88f61656e5f5cfba960013b8133186389efaf243", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/thi-ng/umbrella/security/advisories/GHSA-rj44-gpjc-29r7", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.npmjs.com/package/@thi.ng/egf", "source": "security-advisories@github.com", "tags": ["Product", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/thi-ng/umbrella/commit/88f61656e5f5cfba960013b8133186389efaf243"}}